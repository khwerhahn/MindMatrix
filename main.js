/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the GitHub repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@supabase/node-fetch/browser.js
var browser_exports = {};
__export(browser_exports, {
  Headers: () => Headers2,
  Request: () => Request2,
  Response: () => Response2,
  default: () => browser_default,
  fetch: () => fetch2
});
var getGlobal, globalObject, fetch2, browser_default, Headers2, Request2, Response2;
var init_browser = __esm({
  "node_modules/@supabase/node-fetch/browser.js"() {
    "use strict";
    getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    globalObject = getGlobal();
    fetch2 = globalObject.fetch;
    browser_default = globalObject.fetch.bind(globalObject);
    Headers2 = globalObject.Headers;
    Request2 = globalObject.Request;
    Response2 = globalObject.Response;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js
var require_PostgrestError = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestError2 = class extends Error {
      constructor(context) {
        super(context.message);
        this.name = "PostgrestError";
        this.details = context.details;
        this.hint = context.hint;
        this.code = context.code;
      }
    };
    exports.default = PostgrestError2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js
var require_PostgrestBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var node_fetch_1 = __importDefault((init_browser(), __toCommonJS(browser_exports)));
    var PostgrestError_1 = __importDefault(require_PostgrestError());
    var PostgrestBuilder2 = class {
      constructor(builder) {
        this.shouldThrowOnError = false;
        this.method = builder.method;
        this.url = builder.url;
        this.headers = builder.headers;
        this.schema = builder.schema;
        this.body = builder.body;
        this.shouldThrowOnError = builder.shouldThrowOnError;
        this.signal = builder.signal;
        this.isMaybeSingle = builder.isMaybeSingle;
        if (builder.fetch) {
          this.fetch = builder.fetch;
        } else if (typeof fetch === "undefined") {
          this.fetch = node_fetch_1.default;
        } else {
          this.fetch = fetch;
        }
      }
      /**
       * If there's an error with the query, throwOnError will reject the promise by
       * throwing the error instead of returning it as part of a successful response.
       *
       * {@link https://github.com/supabase/supabase-js/issues/92}
       */
      throwOnError() {
        this.shouldThrowOnError = true;
        return this;
      }
      /**
       * Set an HTTP header for the request.
       */
      setHeader(name, value) {
        this.headers = Object.assign({}, this.headers);
        this.headers[name] = value;
        return this;
      }
      then(onfulfilled, onrejected) {
        if (this.schema === void 0) {
        } else if (["GET", "HEAD"].includes(this.method)) {
          this.headers["Accept-Profile"] = this.schema;
        } else {
          this.headers["Content-Profile"] = this.schema;
        }
        if (this.method !== "GET" && this.method !== "HEAD") {
          this.headers["Content-Type"] = "application/json";
        }
        const _fetch = this.fetch;
        let res = _fetch(this.url.toString(), {
          method: this.method,
          headers: this.headers,
          body: JSON.stringify(this.body),
          signal: this.signal
        }).then(async (res2) => {
          var _a2, _b, _c;
          let error = null;
          let data = null;
          let count = null;
          let status = res2.status;
          let statusText = res2.statusText;
          if (res2.ok) {
            if (this.method !== "HEAD") {
              const body = await res2.text();
              if (body === "") {
              } else if (this.headers["Accept"] === "text/csv") {
                data = body;
              } else if (this.headers["Accept"] && this.headers["Accept"].includes("application/vnd.pgrst.plan+text")) {
                data = body;
              } else {
                data = JSON.parse(body);
              }
            }
            const countHeader = (_a2 = this.headers["Prefer"]) === null || _a2 === void 0 ? void 0 : _a2.match(/count=(exact|planned|estimated)/);
            const contentRange = (_b = res2.headers.get("content-range")) === null || _b === void 0 ? void 0 : _b.split("/");
            if (countHeader && contentRange && contentRange.length > 1) {
              count = parseInt(contentRange[1]);
            }
            if (this.isMaybeSingle && this.method === "GET" && Array.isArray(data)) {
              if (data.length > 1) {
                error = {
                  // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553
                  code: "PGRST116",
                  details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                  hint: null,
                  message: "JSON object requested, multiple (or no) rows returned"
                };
                data = null;
                count = null;
                status = 406;
                statusText = "Not Acceptable";
              } else if (data.length === 1) {
                data = data[0];
              } else {
                data = null;
              }
            }
          } else {
            const body = await res2.text();
            try {
              error = JSON.parse(body);
              if (Array.isArray(error) && res2.status === 404) {
                data = [];
                error = null;
                status = 200;
                statusText = "OK";
              }
            } catch (_d) {
              if (res2.status === 404 && body === "") {
                status = 204;
                statusText = "No Content";
              } else {
                error = {
                  message: body
                };
              }
            }
            if (error && this.isMaybeSingle && ((_c = error === null || error === void 0 ? void 0 : error.details) === null || _c === void 0 ? void 0 : _c.includes("0 rows"))) {
              error = null;
              status = 200;
              statusText = "OK";
            }
            if (error && this.shouldThrowOnError) {
              throw new PostgrestError_1.default(error);
            }
          }
          const postgrestResponse = {
            error,
            data,
            count,
            status,
            statusText
          };
          return postgrestResponse;
        });
        if (!this.shouldThrowOnError) {
          res = res.catch((fetchError) => {
            var _a2, _b, _c;
            return {
              error: {
                message: `${(_a2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _a2 !== void 0 ? _a2 : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,
                details: `${(_b = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _b !== void 0 ? _b : ""}`,
                hint: "",
                code: `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) !== null && _c !== void 0 ? _c : ""}`
              },
              data: null,
              count: null,
              status: 0,
              statusText: ""
            };
          });
        }
        return res.then(onfulfilled, onrejected);
      }
    };
    exports.default = PostgrestBuilder2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js
var require_PostgrestTransformBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestBuilder_1 = __importDefault(require_PostgrestBuilder());
    var PostgrestTransformBuilder2 = class extends PostgrestBuilder_1.default {
      /**
       * Perform a SELECT on the query result.
       *
       * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
       * return modified rows. By calling this method, modified rows are returned in
       * `data`.
       *
       * @param columns - The columns to retrieve, separated by commas
       */
      select(columns) {
        let quoted = false;
        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c) => {
          if (/\s/.test(c) && !quoted) {
            return "";
          }
          if (c === '"') {
            quoted = !quoted;
          }
          return c;
        }).join("");
        this.url.searchParams.set("select", cleanedColumns);
        if (this.headers["Prefer"]) {
          this.headers["Prefer"] += ",";
        }
        this.headers["Prefer"] += "return=representation";
        return this;
      }
      /**
       * Order the query result by `column`.
       *
       * You can call this method multiple times to order by multiple columns.
       *
       * You can order referenced tables, but it only affects the ordering of the
       * parent table if you use `!inner` in the query.
       *
       * @param column - The column to order by
       * @param options - Named parameters
       * @param options.ascending - If `true`, the result will be in ascending order
       * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
       * `null`s appear last.
       * @param options.referencedTable - Set this to order a referenced table by
       * its columns
       * @param options.foreignTable - Deprecated, use `options.referencedTable`
       * instead
       */
      order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {
        const key = referencedTable ? `${referencedTable}.order` : "order";
        const existingOrder = this.url.searchParams.get(key);
        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ""}${column}.${ascending ? "asc" : "desc"}${nullsFirst === void 0 ? "" : nullsFirst ? ".nullsfirst" : ".nullslast"}`);
        return this;
      }
      /**
       * Limit the query result by `count`.
       *
       * @param count - The maximum number of rows to return
       * @param options - Named parameters
       * @param options.referencedTable - Set this to limit rows of referenced
       * tables instead of the parent table
       * @param options.foreignTable - Deprecated, use `options.referencedTable`
       * instead
       */
      limit(count, { foreignTable, referencedTable = foreignTable } = {}) {
        const key = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
        this.url.searchParams.set(key, `${count}`);
        return this;
      }
      /**
       * Limit the query result by starting at an offset `from` and ending at the offset `to`.
       * Only records within this range are returned.
       * This respects the query order and if there is no order clause the range could behave unexpectedly.
       * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
       * and fourth rows of the query.
       *
       * @param from - The starting index from which to limit the result
       * @param to - The last index to which to limit the result
       * @param options - Named parameters
       * @param options.referencedTable - Set this to limit rows of referenced
       * tables instead of the parent table
       * @param options.foreignTable - Deprecated, use `options.referencedTable`
       * instead
       */
      range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {
        const keyOffset = typeof referencedTable === "undefined" ? "offset" : `${referencedTable}.offset`;
        const keyLimit = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
        this.url.searchParams.set(keyOffset, `${from}`);
        this.url.searchParams.set(keyLimit, `${to - from + 1}`);
        return this;
      }
      /**
       * Set the AbortSignal for the fetch request.
       *
       * @param signal - The AbortSignal to use for the fetch request
       */
      abortSignal(signal) {
        this.signal = signal;
        return this;
      }
      /**
       * Return `data` as a single object instead of an array of objects.
       *
       * Query result must be one row (e.g. using `.limit(1)`), otherwise this
       * returns an error.
       */
      single() {
        this.headers["Accept"] = "application/vnd.pgrst.object+json";
        return this;
      }
      /**
       * Return `data` as a single object instead of an array of objects.
       *
       * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
       * this returns an error.
       */
      maybeSingle() {
        if (this.method === "GET") {
          this.headers["Accept"] = "application/json";
        } else {
          this.headers["Accept"] = "application/vnd.pgrst.object+json";
        }
        this.isMaybeSingle = true;
        return this;
      }
      /**
       * Return `data` as a string in CSV format.
       */
      csv() {
        this.headers["Accept"] = "text/csv";
        return this;
      }
      /**
       * Return `data` as an object in [GeoJSON](https://geojson.org) format.
       */
      geojson() {
        this.headers["Accept"] = "application/geo+json";
        return this;
      }
      /**
       * Return `data` as the EXPLAIN plan for the query.
       *
       * You need to enable the
       * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
       * setting before using this method.
       *
       * @param options - Named parameters
       *
       * @param options.analyze - If `true`, the query will be executed and the
       * actual run time will be returned
       *
       * @param options.verbose - If `true`, the query identifier will be returned
       * and `data` will include the output columns of the query
       *
       * @param options.settings - If `true`, include information on configuration
       * parameters that affect query planning
       *
       * @param options.buffers - If `true`, include information on buffer usage
       *
       * @param options.wal - If `true`, include information on WAL record generation
       *
       * @param options.format - The format of the output, can be `"text"` (default)
       * or `"json"`
       */
      explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = "text" } = {}) {
        var _a2;
        const options = [
          analyze ? "analyze" : null,
          verbose ? "verbose" : null,
          settings ? "settings" : null,
          buffers ? "buffers" : null,
          wal ? "wal" : null
        ].filter(Boolean).join("|");
        const forMediatype = (_a2 = this.headers["Accept"]) !== null && _a2 !== void 0 ? _a2 : "application/json";
        this.headers["Accept"] = `application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`;
        if (format === "json")
          return this;
        else
          return this;
      }
      /**
       * Rollback the query.
       *
       * `data` will still be returned, but the query is not committed.
       */
      rollback() {
        var _a2;
        if (((_a2 = this.headers["Prefer"]) !== null && _a2 !== void 0 ? _a2 : "").trim().length > 0) {
          this.headers["Prefer"] += ",tx=rollback";
        } else {
          this.headers["Prefer"] = "tx=rollback";
        }
        return this;
      }
      /**
       * Override the type of the returned `data`.
       *
       * @typeParam NewResult - The new result type to override with
       */
      returns() {
        return this;
      }
    };
    exports.default = PostgrestTransformBuilder2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js
var require_PostgrestFilterBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestTransformBuilder_1 = __importDefault(require_PostgrestTransformBuilder());
    var PostgrestFilterBuilder2 = class extends PostgrestTransformBuilder_1.default {
      /**
       * Match only rows where `column` is equal to `value`.
       *
       * To check if the value of `column` is NULL, you should use `.is()` instead.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      eq(column, value) {
        this.url.searchParams.append(column, `eq.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is not equal to `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      neq(column, value) {
        this.url.searchParams.append(column, `neq.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is greater than `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      gt(column, value) {
        this.url.searchParams.append(column, `gt.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is greater than or equal to `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      gte(column, value) {
        this.url.searchParams.append(column, `gte.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is less than `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      lt(column, value) {
        this.url.searchParams.append(column, `lt.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is less than or equal to `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      lte(column, value) {
        this.url.searchParams.append(column, `lte.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` matches `pattern` case-sensitively.
       *
       * @param column - The column to filter on
       * @param pattern - The pattern to match with
       */
      like(column, pattern) {
        this.url.searchParams.append(column, `like.${pattern}`);
        return this;
      }
      /**
       * Match only rows where `column` matches all of `patterns` case-sensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      likeAllOf(column, patterns) {
        this.url.searchParams.append(column, `like(all).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` matches any of `patterns` case-sensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      likeAnyOf(column, patterns) {
        this.url.searchParams.append(column, `like(any).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` matches `pattern` case-insensitively.
       *
       * @param column - The column to filter on
       * @param pattern - The pattern to match with
       */
      ilike(column, pattern) {
        this.url.searchParams.append(column, `ilike.${pattern}`);
        return this;
      }
      /**
       * Match only rows where `column` matches all of `patterns` case-insensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      ilikeAllOf(column, patterns) {
        this.url.searchParams.append(column, `ilike(all).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` matches any of `patterns` case-insensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      ilikeAnyOf(column, patterns) {
        this.url.searchParams.append(column, `ilike(any).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` IS `value`.
       *
       * For non-boolean columns, this is only relevant for checking if the value of
       * `column` is NULL by setting `value` to `null`.
       *
       * For boolean columns, you can also set `value` to `true` or `false` and it
       * will behave the same way as `.eq()`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      is(column, value) {
        this.url.searchParams.append(column, `is.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is included in the `values` array.
       *
       * @param column - The column to filter on
       * @param values - The values array to filter with
       */
      in(column, values) {
        const cleanedValues = Array.from(new Set(values)).map((s) => {
          if (typeof s === "string" && new RegExp("[,()]").test(s))
            return `"${s}"`;
          else
            return `${s}`;
        }).join(",");
        this.url.searchParams.append(column, `in.(${cleanedValues})`);
        return this;
      }
      /**
       * Only relevant for jsonb, array, and range columns. Match only rows where
       * `column` contains every element appearing in `value`.
       *
       * @param column - The jsonb, array, or range column to filter on
       * @param value - The jsonb, array, or range value to filter with
       */
      contains(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(column, `cs.${value}`);
        } else if (Array.isArray(value)) {
          this.url.searchParams.append(column, `cs.{${value.join(",")}}`);
        } else {
          this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);
        }
        return this;
      }
      /**
       * Only relevant for jsonb, array, and range columns. Match only rows where
       * every element appearing in `column` is contained by `value`.
       *
       * @param column - The jsonb, array, or range column to filter on
       * @param value - The jsonb, array, or range value to filter with
       */
      containedBy(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(column, `cd.${value}`);
        } else if (Array.isArray(value)) {
          this.url.searchParams.append(column, `cd.{${value.join(",")}}`);
        } else {
          this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);
        }
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is greater than any element in `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeGt(column, range) {
        this.url.searchParams.append(column, `sr.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is either contained in `range` or greater than any element in
       * `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeGte(column, range) {
        this.url.searchParams.append(column, `nxl.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is less than any element in `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeLt(column, range) {
        this.url.searchParams.append(column, `sl.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is either contained in `range` or less than any element in
       * `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeLte(column, range) {
        this.url.searchParams.append(column, `nxr.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where `column` is
       * mutually exclusive to `range` and there can be no element between the two
       * ranges.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeAdjacent(column, range) {
        this.url.searchParams.append(column, `adj.${range}`);
        return this;
      }
      /**
       * Only relevant for array and range columns. Match only rows where
       * `column` and `value` have an element in common.
       *
       * @param column - The array or range column to filter on
       * @param value - The array or range value to filter with
       */
      overlaps(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(column, `ov.${value}`);
        } else {
          this.url.searchParams.append(column, `ov.{${value.join(",")}}`);
        }
        return this;
      }
      /**
       * Only relevant for text and tsvector columns. Match only rows where
       * `column` matches the query string in `query`.
       *
       * @param column - The text or tsvector column to filter on
       * @param query - The query text to match with
       * @param options - Named parameters
       * @param options.config - The text search configuration to use
       * @param options.type - Change how the `query` text is interpreted
       */
      textSearch(column, query, { config, type } = {}) {
        let typePart = "";
        if (type === "plain") {
          typePart = "pl";
        } else if (type === "phrase") {
          typePart = "ph";
        } else if (type === "websearch") {
          typePart = "w";
        }
        const configPart = config === void 0 ? "" : `(${config})`;
        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);
        return this;
      }
      /**
       * Match only rows where each column in `query` keys is equal to its
       * associated value. Shorthand for multiple `.eq()`s.
       *
       * @param query - The object to filter with, with column names as keys mapped
       * to their filter values
       */
      match(query) {
        Object.entries(query).forEach(([column, value]) => {
          this.url.searchParams.append(column, `eq.${value}`);
        });
        return this;
      }
      /**
       * Match only rows which doesn't satisfy the filter.
       *
       * Unlike most filters, `opearator` and `value` are used as-is and need to
       * follow [PostgREST
       * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
       * to make sure they are properly sanitized.
       *
       * @param column - The column to filter on
       * @param operator - The operator to be negated to filter with, following
       * PostgREST syntax
       * @param value - The value to filter with, following PostgREST syntax
       */
      not(column, operator, value) {
        this.url.searchParams.append(column, `not.${operator}.${value}`);
        return this;
      }
      /**
       * Match only rows which satisfy at least one of the filters.
       *
       * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
       * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
       * to make sure it's properly sanitized.
       *
       * It's currently not possible to do an `.or()` filter across multiple tables.
       *
       * @param filters - The filters to use, following PostgREST syntax
       * @param options - Named parameters
       * @param options.referencedTable - Set this to filter on referenced tables
       * instead of the parent table
       * @param options.foreignTable - Deprecated, use `referencedTable` instead
       */
      or(filters, { foreignTable, referencedTable = foreignTable } = {}) {
        const key = referencedTable ? `${referencedTable}.or` : "or";
        this.url.searchParams.append(key, `(${filters})`);
        return this;
      }
      /**
       * Match only rows which satisfy the filter. This is an escape hatch - you
       * should use the specific filter methods wherever possible.
       *
       * Unlike most filters, `opearator` and `value` are used as-is and need to
       * follow [PostgREST
       * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
       * to make sure they are properly sanitized.
       *
       * @param column - The column to filter on
       * @param operator - The operator to filter with, following PostgREST syntax
       * @param value - The value to filter with, following PostgREST syntax
       */
      filter(column, operator, value) {
        this.url.searchParams.append(column, `${operator}.${value}`);
        return this;
      }
    };
    exports.default = PostgrestFilterBuilder2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js
var require_PostgrestQueryBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestFilterBuilder_1 = __importDefault(require_PostgrestFilterBuilder());
    var PostgrestQueryBuilder2 = class {
      constructor(url, { headers = {}, schema, fetch: fetch4 }) {
        this.url = url;
        this.headers = headers;
        this.schema = schema;
        this.fetch = fetch4;
      }
      /**
       * Perform a SELECT query on the table or view.
       *
       * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
       *
       * @param options - Named parameters
       *
       * @param options.head - When set to `true`, `data` will not be returned.
       * Useful if you only need the count.
       *
       * @param options.count - Count algorithm to use to count rows in the table or view.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      select(columns, { head: head2 = false, count } = {}) {
        const method = head2 ? "HEAD" : "GET";
        let quoted = false;
        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c) => {
          if (/\s/.test(c) && !quoted) {
            return "";
          }
          if (c === '"') {
            quoted = !quoted;
          }
          return c;
        }).join("");
        this.url.searchParams.set("select", cleanedColumns);
        if (count) {
          this.headers["Prefer"] = `count=${count}`;
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
      /**
       * Perform an INSERT into the table or view.
       *
       * By default, inserted rows are not returned. To return it, chain the call
       * with `.select()`.
       *
       * @param values - The values to insert. Pass an object to insert a single row
       * or an array to insert multiple rows.
       *
       * @param options - Named parameters
       *
       * @param options.count - Count algorithm to use to count inserted rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       *
       * @param options.defaultToNull - Make missing fields default to `null`.
       * Otherwise, use the default value for the column. Only applies for bulk
       * inserts.
       */
      insert(values, { count, defaultToNull = true } = {}) {
        const method = "POST";
        const prefersHeaders = [];
        if (this.headers["Prefer"]) {
          prefersHeaders.push(this.headers["Prefer"]);
        }
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        if (!defaultToNull) {
          prefersHeaders.push("missing=default");
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        if (Array.isArray(values)) {
          const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
          if (columns.length > 0) {
            const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
            this.url.searchParams.set("columns", uniqueColumns.join(","));
          }
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: values,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
      /**
       * Perform an UPSERT on the table or view. Depending on the column(s) passed
       * to `onConflict`, `.upsert()` allows you to perform the equivalent of
       * `.insert()` if a row with the corresponding `onConflict` columns doesn't
       * exist, or if it does exist, perform an alternative action depending on
       * `ignoreDuplicates`.
       *
       * By default, upserted rows are not returned. To return it, chain the call
       * with `.select()`.
       *
       * @param values - The values to upsert with. Pass an object to upsert a
       * single row or an array to upsert multiple rows.
       *
       * @param options - Named parameters
       *
       * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
       * duplicate rows are determined. Two rows are duplicates if all the
       * `onConflict` columns are equal.
       *
       * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
       * `false`, duplicate rows are merged with existing rows.
       *
       * @param options.count - Count algorithm to use to count upserted rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       *
       * @param options.defaultToNull - Make missing fields default to `null`.
       * Otherwise, use the default value for the column. This only applies when
       * inserting new rows, not when merging with existing rows under
       * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
       */
      upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {
        const method = "POST";
        const prefersHeaders = [`resolution=${ignoreDuplicates ? "ignore" : "merge"}-duplicates`];
        if (onConflict !== void 0)
          this.url.searchParams.set("on_conflict", onConflict);
        if (this.headers["Prefer"]) {
          prefersHeaders.push(this.headers["Prefer"]);
        }
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        if (!defaultToNull) {
          prefersHeaders.push("missing=default");
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        if (Array.isArray(values)) {
          const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
          if (columns.length > 0) {
            const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
            this.url.searchParams.set("columns", uniqueColumns.join(","));
          }
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: values,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
      /**
       * Perform an UPDATE on the table or view.
       *
       * By default, updated rows are not returned. To return it, chain the call
       * with `.select()` after filters.
       *
       * @param values - The values to update with
       *
       * @param options - Named parameters
       *
       * @param options.count - Count algorithm to use to count updated rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      update(values, { count } = {}) {
        const method = "PATCH";
        const prefersHeaders = [];
        if (this.headers["Prefer"]) {
          prefersHeaders.push(this.headers["Prefer"]);
        }
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: values,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
      /**
       * Perform a DELETE on the table or view.
       *
       * By default, deleted rows are not returned. To return it, chain the call
       * with `.select()` after filters.
       *
       * @param options - Named parameters
       *
       * @param options.count - Count algorithm to use to count deleted rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      delete({ count } = {}) {
        const method = "DELETE";
        const prefersHeaders = [];
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        if (this.headers["Prefer"]) {
          prefersHeaders.unshift(this.headers["Prefer"]);
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
    };
    exports.default = PostgrestQueryBuilder2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/version.js
var require_version = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "0.0.0-automated";
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/constants.js
var require_constants = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_HEADERS = void 0;
    var version_1 = require_version();
    exports.DEFAULT_HEADERS = { "X-Client-Info": `postgrest-js/${version_1.version}` };
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js
var require_PostgrestClient = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestQueryBuilder_1 = __importDefault(require_PostgrestQueryBuilder());
    var PostgrestFilterBuilder_1 = __importDefault(require_PostgrestFilterBuilder());
    var constants_1 = require_constants();
    var PostgrestClient2 = class {
      // TODO: Add back shouldThrowOnError once we figure out the typings
      /**
       * Creates a PostgREST client.
       *
       * @param url - URL of the PostgREST endpoint
       * @param options - Named parameters
       * @param options.headers - Custom headers
       * @param options.schema - Postgres schema to switch to
       * @param options.fetch - Custom fetch
       */
      constructor(url, { headers = {}, schema, fetch: fetch4 } = {}) {
        this.url = url;
        this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);
        this.schemaName = schema;
        this.fetch = fetch4;
      }
      /**
       * Perform a query on a table or a view.
       *
       * @param relation - The table or view name to query
       */
      from(relation) {
        const url = new URL(`${this.url}/${relation}`);
        return new PostgrestQueryBuilder_1.default(url, {
          headers: Object.assign({}, this.headers),
          schema: this.schemaName,
          fetch: this.fetch
        });
      }
      /**
       * Select a schema to query or perform an function (rpc) call.
       *
       * The schema needs to be on the list of exposed schemas inside Supabase.
       *
       * @param schema - The schema to query
       */
      schema(schema) {
        return new PostgrestClient2(this.url, {
          headers: this.headers,
          schema,
          fetch: this.fetch
        });
      }
      /**
       * Perform a function call.
       *
       * @param fn - The function name to call
       * @param args - The arguments to pass to the function call
       * @param options - Named parameters
       * @param options.head - When set to `true`, `data` will not be returned.
       * Useful if you only need the count.
       * @param options.get - When set to `true`, the function will be called with
       * read-only access mode.
       * @param options.count - Count algorithm to use to count rows returned by the
       * function. Only applicable for [set-returning
       * functions](https://www.postgresql.org/docs/current/functions-srf.html).
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      rpc(fn, args = {}, { head: head2 = false, get: get2 = false, count } = {}) {
        let method;
        const url = new URL(`${this.url}/rpc/${fn}`);
        let body;
        if (head2 || get2) {
          method = head2 ? "HEAD" : "GET";
          Object.entries(args).filter(([_, value]) => value !== void 0).map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(",")}}` : `${value}`]).forEach(([name, value]) => {
            url.searchParams.append(name, value);
          });
        } else {
          method = "POST";
          body = args;
        }
        const headers = Object.assign({}, this.headers);
        if (count) {
          headers["Prefer"] = `count=${count}`;
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url,
          headers,
          schema: this.schemaName,
          body,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
    };
    exports.default = PostgrestClient2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PostgrestError = exports.PostgrestBuilder = exports.PostgrestTransformBuilder = exports.PostgrestFilterBuilder = exports.PostgrestQueryBuilder = exports.PostgrestClient = void 0;
    var PostgrestClient_1 = __importDefault(require_PostgrestClient());
    exports.PostgrestClient = PostgrestClient_1.default;
    var PostgrestQueryBuilder_1 = __importDefault(require_PostgrestQueryBuilder());
    exports.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;
    var PostgrestFilterBuilder_1 = __importDefault(require_PostgrestFilterBuilder());
    exports.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;
    var PostgrestTransformBuilder_1 = __importDefault(require_PostgrestTransformBuilder());
    exports.PostgrestTransformBuilder = PostgrestTransformBuilder_1.default;
    var PostgrestBuilder_1 = __importDefault(require_PostgrestBuilder());
    exports.PostgrestBuilder = PostgrestBuilder_1.default;
    var PostgrestError_1 = __importDefault(require_PostgrestError());
    exports.PostgrestError = PostgrestError_1.default;
    exports.default = {
      PostgrestClient: PostgrestClient_1.default,
      PostgrestQueryBuilder: PostgrestQueryBuilder_1.default,
      PostgrestFilterBuilder: PostgrestFilterBuilder_1.default,
      PostgrestTransformBuilder: PostgrestTransformBuilder_1.default,
      PostgrestBuilder: PostgrestBuilder_1.default,
      PostgrestError: PostgrestError_1.default
    };
  }
});

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MindMatrixPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian12 = require("obsidian");

// node_modules/@supabase/functions-js/dist/module/helper.js
var resolveFetch = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => Promise.resolve().then(() => (init_browser(), browser_exports)).then(({ default: fetch4 }) => fetch4(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};

// node_modules/@supabase/functions-js/dist/module/types.js
var FunctionsError = class extends Error {
  constructor(message, name = "FunctionsError", context) {
    super(message);
    this.name = name;
    this.context = context;
  }
};
var FunctionsFetchError = class extends FunctionsError {
  constructor(context) {
    super("Failed to send a request to the Edge Function", "FunctionsFetchError", context);
  }
};
var FunctionsRelayError = class extends FunctionsError {
  constructor(context) {
    super("Relay Error invoking the Edge Function", "FunctionsRelayError", context);
  }
};
var FunctionsHttpError = class extends FunctionsError {
  constructor(context) {
    super("Edge Function returned a non-2xx status code", "FunctionsHttpError", context);
  }
};
var FunctionRegion;
(function(FunctionRegion2) {
  FunctionRegion2["Any"] = "any";
  FunctionRegion2["ApNortheast1"] = "ap-northeast-1";
  FunctionRegion2["ApNortheast2"] = "ap-northeast-2";
  FunctionRegion2["ApSouth1"] = "ap-south-1";
  FunctionRegion2["ApSoutheast1"] = "ap-southeast-1";
  FunctionRegion2["ApSoutheast2"] = "ap-southeast-2";
  FunctionRegion2["CaCentral1"] = "ca-central-1";
  FunctionRegion2["EuCentral1"] = "eu-central-1";
  FunctionRegion2["EuWest1"] = "eu-west-1";
  FunctionRegion2["EuWest2"] = "eu-west-2";
  FunctionRegion2["EuWest3"] = "eu-west-3";
  FunctionRegion2["SaEast1"] = "sa-east-1";
  FunctionRegion2["UsEast1"] = "us-east-1";
  FunctionRegion2["UsWest1"] = "us-west-1";
  FunctionRegion2["UsWest2"] = "us-west-2";
})(FunctionRegion || (FunctionRegion = {}));

// node_modules/@supabase/functions-js/dist/module/FunctionsClient.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FunctionsClient = class {
  constructor(url, { headers = {}, customFetch, region = FunctionRegion.Any } = {}) {
    this.url = url;
    this.headers = headers;
    this.region = region;
    this.fetch = resolveFetch(customFetch);
  }
  /**
   * Updates the authorization header
   * @param token - the new jwt token sent in the authorisation header
   */
  setAuth(token) {
    this.headers.Authorization = `Bearer ${token}`;
  }
  /**
   * Invokes a function
   * @param functionName - The name of the Function to invoke.
   * @param options - Options for invoking the Function.
   */
  invoke(functionName, options = {}) {
    var _a2;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const { headers, method, body: functionArgs } = options;
        let _headers = {};
        let { region } = options;
        if (!region) {
          region = this.region;
        }
        if (region && region !== "any") {
          _headers["x-region"] = region;
        }
        let body;
        if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, "Content-Type") || !headers)) {
          if (typeof Blob !== "undefined" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
            _headers["Content-Type"] = "application/octet-stream";
            body = functionArgs;
          } else if (typeof functionArgs === "string") {
            _headers["Content-Type"] = "text/plain";
            body = functionArgs;
          } else if (typeof FormData !== "undefined" && functionArgs instanceof FormData) {
            body = functionArgs;
          } else {
            _headers["Content-Type"] = "application/json";
            body = JSON.stringify(functionArgs);
          }
        }
        const response = yield this.fetch(`${this.url}/${functionName}`, {
          method: method || "POST",
          // headers priority is (high to low):
          // 1. invoke-level headers
          // 2. client-level headers
          // 3. default Content-Type header
          headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),
          body
        }).catch((fetchError) => {
          throw new FunctionsFetchError(fetchError);
        });
        const isRelayError = response.headers.get("x-relay-error");
        if (isRelayError && isRelayError === "true") {
          throw new FunctionsRelayError(response);
        }
        if (!response.ok) {
          throw new FunctionsHttpError(response);
        }
        let responseType = ((_a2 = response.headers.get("Content-Type")) !== null && _a2 !== void 0 ? _a2 : "text/plain").split(";")[0].trim();
        let data;
        if (responseType === "application/json") {
          data = yield response.json();
        } else if (responseType === "application/octet-stream") {
          data = yield response.blob();
        } else if (responseType === "text/event-stream") {
          data = response;
        } else if (responseType === "multipart/form-data") {
          data = yield response.formData();
        } else {
          data = yield response.text();
        }
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    });
  }
};

// node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs
var import_cjs = __toESM(require_cjs(), 1);
var {
  PostgrestClient,
  PostgrestQueryBuilder,
  PostgrestFilterBuilder,
  PostgrestTransformBuilder,
  PostgrestBuilder,
  PostgrestError
} = import_cjs.default;

// node_modules/@supabase/realtime-js/dist/module/lib/version.js
var version = "2.11.2";

// node_modules/@supabase/realtime-js/dist/module/lib/constants.js
var DEFAULT_HEADERS = { "X-Client-Info": `realtime-js/${version}` };
var VSN = "1.0.0";
var DEFAULT_TIMEOUT = 1e4;
var WS_CLOSE_NORMAL = 1e3;
var SOCKET_STATES;
(function(SOCKET_STATES2) {
  SOCKET_STATES2[SOCKET_STATES2["connecting"] = 0] = "connecting";
  SOCKET_STATES2[SOCKET_STATES2["open"] = 1] = "open";
  SOCKET_STATES2[SOCKET_STATES2["closing"] = 2] = "closing";
  SOCKET_STATES2[SOCKET_STATES2["closed"] = 3] = "closed";
})(SOCKET_STATES || (SOCKET_STATES = {}));
var CHANNEL_STATES;
(function(CHANNEL_STATES2) {
  CHANNEL_STATES2["closed"] = "closed";
  CHANNEL_STATES2["errored"] = "errored";
  CHANNEL_STATES2["joined"] = "joined";
  CHANNEL_STATES2["joining"] = "joining";
  CHANNEL_STATES2["leaving"] = "leaving";
})(CHANNEL_STATES || (CHANNEL_STATES = {}));
var CHANNEL_EVENTS;
(function(CHANNEL_EVENTS2) {
  CHANNEL_EVENTS2["close"] = "phx_close";
  CHANNEL_EVENTS2["error"] = "phx_error";
  CHANNEL_EVENTS2["join"] = "phx_join";
  CHANNEL_EVENTS2["reply"] = "phx_reply";
  CHANNEL_EVENTS2["leave"] = "phx_leave";
  CHANNEL_EVENTS2["access_token"] = "access_token";
})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));
var TRANSPORTS;
(function(TRANSPORTS2) {
  TRANSPORTS2["websocket"] = "websocket";
})(TRANSPORTS || (TRANSPORTS = {}));
var CONNECTION_STATE;
(function(CONNECTION_STATE2) {
  CONNECTION_STATE2["Connecting"] = "connecting";
  CONNECTION_STATE2["Open"] = "open";
  CONNECTION_STATE2["Closing"] = "closing";
  CONNECTION_STATE2["Closed"] = "closed";
})(CONNECTION_STATE || (CONNECTION_STATE = {}));

// node_modules/@supabase/realtime-js/dist/module/lib/serializer.js
var Serializer = class {
  constructor() {
    this.HEADER_LENGTH = 1;
  }
  decode(rawPayload, callback) {
    if (rawPayload.constructor === ArrayBuffer) {
      return callback(this._binaryDecode(rawPayload));
    }
    if (typeof rawPayload === "string") {
      return callback(JSON.parse(rawPayload));
    }
    return callback({});
  }
  _binaryDecode(buffer) {
    const view = new DataView(buffer);
    const decoder = new TextDecoder();
    return this._decodeBroadcast(buffer, view, decoder);
  }
  _decodeBroadcast(buffer, view, decoder) {
    const topicSize = view.getUint8(1);
    const eventSize = view.getUint8(2);
    let offset = this.HEADER_LENGTH + 2;
    const topic = decoder.decode(buffer.slice(offset, offset + topicSize));
    offset = offset + topicSize;
    const event = decoder.decode(buffer.slice(offset, offset + eventSize));
    offset = offset + eventSize;
    const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));
    return { ref: null, topic, event, payload: data };
  }
};

// node_modules/@supabase/realtime-js/dist/module/lib/timer.js
var Timer = class {
  constructor(callback, timerCalc) {
    this.callback = callback;
    this.timerCalc = timerCalc;
    this.timer = void 0;
    this.tries = 0;
    this.callback = callback;
    this.timerCalc = timerCalc;
  }
  reset() {
    this.tries = 0;
    clearTimeout(this.timer);
  }
  // Cancels any previous scheduleTimeout and schedules callback
  scheduleTimeout() {
    clearTimeout(this.timer);
    this.timer = setTimeout(() => {
      this.tries = this.tries + 1;
      this.callback();
    }, this.timerCalc(this.tries + 1));
  }
};

// node_modules/@supabase/realtime-js/dist/module/lib/transformers.js
var PostgresTypes;
(function(PostgresTypes2) {
  PostgresTypes2["abstime"] = "abstime";
  PostgresTypes2["bool"] = "bool";
  PostgresTypes2["date"] = "date";
  PostgresTypes2["daterange"] = "daterange";
  PostgresTypes2["float4"] = "float4";
  PostgresTypes2["float8"] = "float8";
  PostgresTypes2["int2"] = "int2";
  PostgresTypes2["int4"] = "int4";
  PostgresTypes2["int4range"] = "int4range";
  PostgresTypes2["int8"] = "int8";
  PostgresTypes2["int8range"] = "int8range";
  PostgresTypes2["json"] = "json";
  PostgresTypes2["jsonb"] = "jsonb";
  PostgresTypes2["money"] = "money";
  PostgresTypes2["numeric"] = "numeric";
  PostgresTypes2["oid"] = "oid";
  PostgresTypes2["reltime"] = "reltime";
  PostgresTypes2["text"] = "text";
  PostgresTypes2["time"] = "time";
  PostgresTypes2["timestamp"] = "timestamp";
  PostgresTypes2["timestamptz"] = "timestamptz";
  PostgresTypes2["timetz"] = "timetz";
  PostgresTypes2["tsrange"] = "tsrange";
  PostgresTypes2["tstzrange"] = "tstzrange";
})(PostgresTypes || (PostgresTypes = {}));
var convertChangeData = (columns, record, options = {}) => {
  var _a2;
  const skipTypes = (_a2 = options.skipTypes) !== null && _a2 !== void 0 ? _a2 : [];
  return Object.keys(record).reduce((acc, rec_key) => {
    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
    return acc;
  }, {});
};
var convertColumn = (columnName, columns, record, skipTypes) => {
  const column = columns.find((x) => x.name === columnName);
  const colType = column === null || column === void 0 ? void 0 : column.type;
  const value = record[columnName];
  if (colType && !skipTypes.includes(colType)) {
    return convertCell(colType, value);
  }
  return noop(value);
};
var convertCell = (type, value) => {
  if (type.charAt(0) === "_") {
    const dataType = type.slice(1, type.length);
    return toArray(value, dataType);
  }
  switch (type) {
    case PostgresTypes.bool:
      return toBoolean(value);
    case PostgresTypes.float4:
    case PostgresTypes.float8:
    case PostgresTypes.int2:
    case PostgresTypes.int4:
    case PostgresTypes.int8:
    case PostgresTypes.numeric:
    case PostgresTypes.oid:
      return toNumber(value);
    case PostgresTypes.json:
    case PostgresTypes.jsonb:
      return toJson(value);
    case PostgresTypes.timestamp:
      return toTimestampString(value);
    case PostgresTypes.abstime:
    case PostgresTypes.date:
    case PostgresTypes.daterange:
    case PostgresTypes.int4range:
    case PostgresTypes.int8range:
    case PostgresTypes.money:
    case PostgresTypes.reltime:
    case PostgresTypes.text:
    case PostgresTypes.time:
    case PostgresTypes.timestamptz:
    case PostgresTypes.timetz:
    case PostgresTypes.tsrange:
    case PostgresTypes.tstzrange:
      return noop(value);
    default:
      return noop(value);
  }
};
var noop = (value) => {
  return value;
};
var toBoolean = (value) => {
  switch (value) {
    case "t":
      return true;
    case "f":
      return false;
    default:
      return value;
  }
};
var toNumber = (value) => {
  if (typeof value === "string") {
    const parsedValue = parseFloat(value);
    if (!Number.isNaN(parsedValue)) {
      return parsedValue;
    }
  }
  return value;
};
var toJson = (value) => {
  if (typeof value === "string") {
    try {
      return JSON.parse(value);
    } catch (error) {
      console.log(`JSON parse error: ${error}`);
      return value;
    }
  }
  return value;
};
var toArray = (value, type) => {
  if (typeof value !== "string") {
    return value;
  }
  const lastIdx = value.length - 1;
  const closeBrace = value[lastIdx];
  const openBrace = value[0];
  if (openBrace === "{" && closeBrace === "}") {
    let arr;
    const valTrim = value.slice(1, lastIdx);
    try {
      arr = JSON.parse("[" + valTrim + "]");
    } catch (_) {
      arr = valTrim ? valTrim.split(",") : [];
    }
    return arr.map((val) => convertCell(type, val));
  }
  return value;
};
var toTimestampString = (value) => {
  if (typeof value === "string") {
    return value.replace(" ", "T");
  }
  return value;
};
var httpEndpointURL = (socketUrl) => {
  let url = socketUrl;
  url = url.replace(/^ws/i, "http");
  url = url.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, "");
  return url.replace(/\/+$/, "");
};

// node_modules/@supabase/realtime-js/dist/module/lib/push.js
var Push = class {
  /**
   * Initializes the Push
   *
   * @param channel The Channel
   * @param event The event, for example `"phx_join"`
   * @param payload The payload, for example `{user_id: 123}`
   * @param timeout The push timeout in milliseconds
   */
  constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {
    this.channel = channel;
    this.event = event;
    this.payload = payload;
    this.timeout = timeout;
    this.sent = false;
    this.timeoutTimer = void 0;
    this.ref = "";
    this.receivedResp = null;
    this.recHooks = [];
    this.refEvent = null;
  }
  resend(timeout) {
    this.timeout = timeout;
    this._cancelRefEvent();
    this.ref = "";
    this.refEvent = null;
    this.receivedResp = null;
    this.sent = false;
    this.send();
  }
  send() {
    if (this._hasReceived("timeout")) {
      return;
    }
    this.startTimeout();
    this.sent = true;
    this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload,
      ref: this.ref,
      join_ref: this.channel._joinRef()
    });
  }
  updatePayload(payload) {
    this.payload = Object.assign(Object.assign({}, this.payload), payload);
  }
  receive(status, callback) {
    var _a2;
    if (this._hasReceived(status)) {
      callback((_a2 = this.receivedResp) === null || _a2 === void 0 ? void 0 : _a2.response);
    }
    this.recHooks.push({ status, callback });
    return this;
  }
  startTimeout() {
    if (this.timeoutTimer) {
      return;
    }
    this.ref = this.channel.socket._makeRef();
    this.refEvent = this.channel._replyEventName(this.ref);
    const callback = (payload) => {
      this._cancelRefEvent();
      this._cancelTimeout();
      this.receivedResp = payload;
      this._matchReceive(payload);
    };
    this.channel._on(this.refEvent, {}, callback);
    this.timeoutTimer = setTimeout(() => {
      this.trigger("timeout", {});
    }, this.timeout);
  }
  trigger(status, response) {
    if (this.refEvent)
      this.channel._trigger(this.refEvent, { status, response });
  }
  destroy() {
    this._cancelRefEvent();
    this._cancelTimeout();
  }
  _cancelRefEvent() {
    if (!this.refEvent) {
      return;
    }
    this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer);
    this.timeoutTimer = void 0;
  }
  _matchReceive({ status, response }) {
    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
  }
  _hasReceived(status) {
    return this.receivedResp && this.receivedResp.status === status;
  }
};

// node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js
var REALTIME_PRESENCE_LISTEN_EVENTS;
(function(REALTIME_PRESENCE_LISTEN_EVENTS2) {
  REALTIME_PRESENCE_LISTEN_EVENTS2["SYNC"] = "sync";
  REALTIME_PRESENCE_LISTEN_EVENTS2["JOIN"] = "join";
  REALTIME_PRESENCE_LISTEN_EVENTS2["LEAVE"] = "leave";
})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));
var RealtimePresence = class {
  /**
   * Initializes the Presence.
   *
   * @param channel - The RealtimeChannel
   * @param opts - The options,
   *        for example `{events: {state: 'state', diff: 'diff'}}`
   */
  constructor(channel, opts) {
    this.channel = channel;
    this.state = {};
    this.pendingDiffs = [];
    this.joinRef = null;
    this.caller = {
      onJoin: () => {
      },
      onLeave: () => {
      },
      onSync: () => {
      }
    };
    const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {
      state: "presence_state",
      diff: "presence_diff"
    };
    this.channel._on(events.state, {}, (newState) => {
      const { onJoin, onLeave, onSync } = this.caller;
      this.joinRef = this.channel._joinRef();
      this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);
      this.pendingDiffs.forEach((diff) => {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
      });
      this.pendingDiffs = [];
      onSync();
    });
    this.channel._on(events.diff, {}, (diff) => {
      const { onJoin, onLeave, onSync } = this.caller;
      if (this.inPendingSyncState()) {
        this.pendingDiffs.push(diff);
      } else {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
        onSync();
      }
    });
    this.onJoin((key, currentPresences, newPresences) => {
      this.channel._trigger("presence", {
        event: "join",
        key,
        currentPresences,
        newPresences
      });
    });
    this.onLeave((key, currentPresences, leftPresences) => {
      this.channel._trigger("presence", {
        event: "leave",
        key,
        currentPresences,
        leftPresences
      });
    });
    this.onSync(() => {
      this.channel._trigger("presence", { event: "sync" });
    });
  }
  /**
   * Used to sync the list of presences on the server with the
   * client's state.
   *
   * An optional `onJoin` and `onLeave` callback can be provided to
   * react to changes in the client's local presences across
   * disconnects and reconnects with the server.
   *
   * @internal
   */
  static syncState(currentState, newState, onJoin, onLeave) {
    const state = this.cloneDeep(currentState);
    const transformedState = this.transformState(newState);
    const joins = {};
    const leaves = {};
    this.map(state, (key, presences) => {
      if (!transformedState[key]) {
        leaves[key] = presences;
      }
    });
    this.map(transformedState, (key, newPresences) => {
      const currentPresences = state[key];
      if (currentPresences) {
        const newPresenceRefs = newPresences.map((m) => m.presence_ref);
        const curPresenceRefs = currentPresences.map((m) => m.presence_ref);
        const joinedPresences = newPresences.filter((m) => curPresenceRefs.indexOf(m.presence_ref) < 0);
        const leftPresences = currentPresences.filter((m) => newPresenceRefs.indexOf(m.presence_ref) < 0);
        if (joinedPresences.length > 0) {
          joins[key] = joinedPresences;
        }
        if (leftPresences.length > 0) {
          leaves[key] = leftPresences;
        }
      } else {
        joins[key] = newPresences;
      }
    });
    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);
  }
  /**
   * Used to sync a diff of presence join and leave events from the
   * server, as they happen.
   *
   * Like `syncState`, `syncDiff` accepts optional `onJoin` and
   * `onLeave` callbacks to react to a user joining or leaving from a
   * device.
   *
   * @internal
   */
  static syncDiff(state, diff, onJoin, onLeave) {
    const { joins, leaves } = {
      joins: this.transformState(diff.joins),
      leaves: this.transformState(diff.leaves)
    };
    if (!onJoin) {
      onJoin = () => {
      };
    }
    if (!onLeave) {
      onLeave = () => {
      };
    }
    this.map(joins, (key, newPresences) => {
      var _a2;
      const currentPresences = (_a2 = state[key]) !== null && _a2 !== void 0 ? _a2 : [];
      state[key] = this.cloneDeep(newPresences);
      if (currentPresences.length > 0) {
        const joinedPresenceRefs = state[key].map((m) => m.presence_ref);
        const curPresences = currentPresences.filter((m) => joinedPresenceRefs.indexOf(m.presence_ref) < 0);
        state[key].unshift(...curPresences);
      }
      onJoin(key, currentPresences, newPresences);
    });
    this.map(leaves, (key, leftPresences) => {
      let currentPresences = state[key];
      if (!currentPresences)
        return;
      const presenceRefsToRemove = leftPresences.map((m) => m.presence_ref);
      currentPresences = currentPresences.filter((m) => presenceRefsToRemove.indexOf(m.presence_ref) < 0);
      state[key] = currentPresences;
      onLeave(key, currentPresences, leftPresences);
      if (currentPresences.length === 0)
        delete state[key];
    });
    return state;
  }
  /** @internal */
  static map(obj, func) {
    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));
  }
  /**
   * Remove 'metas' key
   * Change 'phx_ref' to 'presence_ref'
   * Remove 'phx_ref' and 'phx_ref_prev'
   *
   * @example
   * // returns {
   *  abc123: [
   *    { presence_ref: '2', user_id: 1 },
   *    { presence_ref: '3', user_id: 2 }
   *  ]
   * }
   * RealtimePresence.transformState({
   *  abc123: {
   *    metas: [
   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
   *      { phx_ref: '3', user_id: 2 }
   *    ]
   *  }
   * })
   *
   * @internal
   */
  static transformState(state) {
    state = this.cloneDeep(state);
    return Object.getOwnPropertyNames(state).reduce((newState, key) => {
      const presences = state[key];
      if ("metas" in presences) {
        newState[key] = presences.metas.map((presence) => {
          presence["presence_ref"] = presence["phx_ref"];
          delete presence["phx_ref"];
          delete presence["phx_ref_prev"];
          return presence;
        });
      } else {
        newState[key] = presences;
      }
      return newState;
    }, {});
  }
  /** @internal */
  static cloneDeep(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  /** @internal */
  onJoin(callback) {
    this.caller.onJoin = callback;
  }
  /** @internal */
  onLeave(callback) {
    this.caller.onLeave = callback;
  }
  /** @internal */
  onSync(callback) {
    this.caller.onSync = callback;
  }
  /** @internal */
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
};

// node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js
var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2) {
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["ALL"] = "*";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["INSERT"] = "INSERT";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["UPDATE"] = "UPDATE";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["DELETE"] = "DELETE";
})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
var REALTIME_LISTEN_TYPES;
(function(REALTIME_LISTEN_TYPES2) {
  REALTIME_LISTEN_TYPES2["BROADCAST"] = "broadcast";
  REALTIME_LISTEN_TYPES2["PRESENCE"] = "presence";
  REALTIME_LISTEN_TYPES2["POSTGRES_CHANGES"] = "postgres_changes";
  REALTIME_LISTEN_TYPES2["SYSTEM"] = "system";
})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));
var REALTIME_SUBSCRIBE_STATES;
(function(REALTIME_SUBSCRIBE_STATES2) {
  REALTIME_SUBSCRIBE_STATES2["SUBSCRIBED"] = "SUBSCRIBED";
  REALTIME_SUBSCRIBE_STATES2["TIMED_OUT"] = "TIMED_OUT";
  REALTIME_SUBSCRIBE_STATES2["CLOSED"] = "CLOSED";
  REALTIME_SUBSCRIBE_STATES2["CHANNEL_ERROR"] = "CHANNEL_ERROR";
})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));
var RealtimeChannel = class {
  constructor(topic, params = { config: {} }, socket) {
    this.topic = topic;
    this.params = params;
    this.socket = socket;
    this.bindings = {};
    this.state = CHANNEL_STATES.closed;
    this.joinedOnce = false;
    this.pushBuffer = [];
    this.subTopic = topic.replace(/^realtime:/i, "");
    this.params.config = Object.assign({
      broadcast: { ack: false, self: false },
      presence: { key: "" },
      private: false
    }, params.config);
    this.timeout = this.socket.timeout;
    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
    this.joinPush.receive("ok", () => {
      this.state = CHANNEL_STATES.joined;
      this.rejoinTimer.reset();
      this.pushBuffer.forEach((pushEvent) => pushEvent.send());
      this.pushBuffer = [];
    });
    this._onClose(() => {
      this.rejoinTimer.reset();
      this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`);
      this.state = CHANNEL_STATES.closed;
      this.socket._remove(this);
    });
    this._onError((reason) => {
      if (this._isLeaving() || this._isClosed()) {
        return;
      }
      this.socket.log("channel", `error ${this.topic}`, reason);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this.joinPush.receive("timeout", () => {
      if (!this._isJoining()) {
        return;
      }
      this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {
      this._trigger(this._replyEventName(ref), payload);
    });
    this.presence = new RealtimePresence(this);
    this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint) + "/api/broadcast";
    this.private = this.params.config.private || false;
  }
  /** Subscribe registers your client with the server */
  subscribe(callback, timeout = this.timeout) {
    var _a2, _b;
    if (!this.socket.isConnected()) {
      this.socket.connect();
    }
    if (this.joinedOnce) {
      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;
    } else {
      const { config: { broadcast, presence, private: isPrivate } } = this.params;
      this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));
      this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));
      const accessTokenPayload = {};
      const config = {
        broadcast,
        presence,
        postgres_changes: (_b = (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [],
        private: isPrivate
      };
      if (this.socket.accessTokenValue) {
        accessTokenPayload.access_token = this.socket.accessTokenValue;
      }
      this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));
      this.joinedOnce = true;
      this._rejoin(timeout);
      this.joinPush.receive("ok", async ({ postgres_changes }) => {
        var _a3;
        this.socket.setAuth();
        if (postgres_changes === void 0) {
          callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          return;
        } else {
          const clientPostgresBindings = this.bindings.postgres_changes;
          const bindingsLen = (_a3 = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a3 !== void 0 ? _a3 : 0;
          const newPostgresBindings = [];
          for (let i = 0; i < bindingsLen; i++) {
            const clientPostgresBinding = clientPostgresBindings[i];
            const { filter: { event, schema, table, filter } } = clientPostgresBinding;
            const serverPostgresFilter = postgres_changes && postgres_changes[i];
            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {
              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));
            } else {
              this.unsubscribe();
              callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
              return;
            }
          }
          this.bindings.postgres_changes = newPostgresBindings;
          callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          return;
        }
      }).receive("error", (error) => {
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(", ") || "error")));
        return;
      }).receive("timeout", () => {
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);
        return;
      });
    }
    return this;
  }
  presenceState() {
    return this.presence.state;
  }
  async track(payload, opts = {}) {
    return await this.send({
      type: "presence",
      event: "track",
      payload
    }, opts.timeout || this.timeout);
  }
  async untrack(opts = {}) {
    return await this.send({
      type: "presence",
      event: "untrack"
    }, opts);
  }
  on(type, filter, callback) {
    return this._on(type, filter, callback);
  }
  /**
   * Sends a message into the channel.
   *
   * @param args Arguments to send to channel
   * @param args.type The type of event to send
   * @param args.event The name of the event being sent
   * @param args.payload Payload to be sent
   * @param opts Options to be used during the send process
   */
  async send(args, opts = {}) {
    var _a2, _b;
    if (!this._canPush() && args.type === "broadcast") {
      const { event, payload: endpoint_payload } = args;
      const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
      const options = {
        method: "POST",
        headers: {
          Authorization: authorization,
          apikey: this.socket.apiKey ? this.socket.apiKey : "",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: [
            {
              topic: this.subTopic,
              event,
              payload: endpoint_payload,
              private: this.private
            }
          ]
        })
      };
      try {
        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a2 = opts.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout);
        await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());
        return response.ok ? "ok" : "error";
      } catch (error) {
        if (error.name === "AbortError") {
          return "timed out";
        } else {
          return "error";
        }
      }
    } else {
      return new Promise((resolve) => {
        var _a3, _b2, _c;
        const push2 = this._push(args.type, args, opts.timeout || this.timeout);
        if (args.type === "broadcast" && !((_c = (_b2 = (_a3 = this.params) === null || _a3 === void 0 ? void 0 : _a3.config) === null || _b2 === void 0 ? void 0 : _b2.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {
          resolve("ok");
        }
        push2.receive("ok", () => resolve("ok"));
        push2.receive("error", () => resolve("error"));
        push2.receive("timeout", () => resolve("timed out"));
      });
    }
  }
  updateJoinPayload(payload) {
    this.joinPush.updatePayload(payload);
  }
  /**
   * Leaves the channel.
   *
   * Unsubscribes from server events, and instructs channel to terminate on server.
   * Triggers onClose() hooks.
   *
   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
   * channel.unsubscribe().receive("ok", () => alert("left!") )
   */
  unsubscribe(timeout = this.timeout) {
    this.state = CHANNEL_STATES.leaving;
    const onClose = () => {
      this.socket.log("channel", `leave ${this.topic}`);
      this._trigger(CHANNEL_EVENTS.close, "leave", this._joinRef());
    };
    this.rejoinTimer.reset();
    this.joinPush.destroy();
    return new Promise((resolve) => {
      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);
      leavePush.receive("ok", () => {
        onClose();
        resolve("ok");
      }).receive("timeout", () => {
        onClose();
        resolve("timed out");
      }).receive("error", () => {
        resolve("error");
      });
      leavePush.send();
      if (!this._canPush()) {
        leavePush.trigger("ok", {});
      }
    });
  }
  /** @internal */
  async _fetchWithTimeout(url, options, timeout) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));
    clearTimeout(id);
    return response;
  }
  /** @internal */
  _push(event, payload, timeout = this.timeout) {
    if (!this.joinedOnce) {
      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    }
    let pushEvent = new Push(this, event, payload, timeout);
    if (this._canPush()) {
      pushEvent.send();
    } else {
      pushEvent.startTimeout();
      this.pushBuffer.push(pushEvent);
    }
    return pushEvent;
  }
  /**
   * Overridable message hook
   *
   * Receives all events for specialized message handling before dispatching to the channel callbacks.
   * Must return the payload, modified or unmodified.
   *
   * @internal
   */
  _onMessage(_event, payload, _ref) {
    return payload;
  }
  /** @internal */
  _isMember(topic) {
    return this.topic === topic;
  }
  /** @internal */
  _joinRef() {
    return this.joinPush.ref;
  }
  /** @internal */
  _trigger(type, payload, ref) {
    var _a2, _b;
    const typeLower = type.toLocaleLowerCase();
    const { close, error, leave, join } = CHANNEL_EVENTS;
    const events = [close, error, leave, join];
    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
      return;
    }
    let handledPayload = this._onMessage(typeLower, payload, ref);
    if (payload && !handledPayload) {
      throw "channel onMessage callbacks must return the payload, modified or unmodified";
    }
    if (["insert", "update", "delete"].includes(typeLower)) {
      (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.filter((bind) => {
        var _a3, _b2, _c;
        return ((_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event) === "*" || ((_c = (_b2 = bind.filter) === null || _b2 === void 0 ? void 0 : _b2.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
      }).map((bind) => bind.callback(handledPayload, ref));
    } else {
      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {
        var _a3, _b2, _c, _d, _e, _f;
        if (["broadcast", "presence", "postgres_changes"].includes(typeLower)) {
          if ("id" in bind) {
            const bindId = bind.id;
            const bindEvent = (_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event;
            return bindId && ((_b2 = payload.ids) === null || _b2 === void 0 ? void 0 : _b2.includes(bindId)) && (bindEvent === "*" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));
          } else {
            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();
            return bindEvent === "*" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());
          }
        } else {
          return bind.type.toLocaleLowerCase() === typeLower;
        }
      }).map((bind) => {
        if (typeof handledPayload === "object" && "ids" in handledPayload) {
          const postgresChanges = handledPayload.data;
          const { schema, table, commit_timestamp, type: type2, errors } = postgresChanges;
          const enrichedPayload = {
            schema,
            table,
            commit_timestamp,
            eventType: type2,
            new: {},
            old: {},
            errors
          };
          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));
        }
        bind.callback(handledPayload, ref);
      });
    }
  }
  /** @internal */
  _isClosed() {
    return this.state === CHANNEL_STATES.closed;
  }
  /** @internal */
  _isJoined() {
    return this.state === CHANNEL_STATES.joined;
  }
  /** @internal */
  _isJoining() {
    return this.state === CHANNEL_STATES.joining;
  }
  /** @internal */
  _isLeaving() {
    return this.state === CHANNEL_STATES.leaving;
  }
  /** @internal */
  _replyEventName(ref) {
    return `chan_reply_${ref}`;
  }
  /** @internal */
  _on(type, filter, callback) {
    const typeLower = type.toLocaleLowerCase();
    const binding = {
      type: typeLower,
      filter,
      callback
    };
    if (this.bindings[typeLower]) {
      this.bindings[typeLower].push(binding);
    } else {
      this.bindings[typeLower] = [binding];
    }
    return this;
  }
  /** @internal */
  _off(type, filter) {
    const typeLower = type.toLocaleLowerCase();
    this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {
      var _a2;
      return !(((_a2 = bind.type) === null || _a2 === void 0 ? void 0 : _a2.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
    });
    return this;
  }
  /** @internal */
  static isEqual(obj1, obj2) {
    if (Object.keys(obj1).length !== Object.keys(obj2).length) {
      return false;
    }
    for (const k in obj1) {
      if (obj1[k] !== obj2[k]) {
        return false;
      }
    }
    return true;
  }
  /** @internal */
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout();
    if (this.socket.isConnected()) {
      this._rejoin();
    }
  }
  /**
   * Registers a callback that will be executed when the channel closes.
   *
   * @internal
   */
  _onClose(callback) {
    this._on(CHANNEL_EVENTS.close, {}, callback);
  }
  /**
   * Registers a callback that will be executed when the channel encounteres an error.
   *
   * @internal
   */
  _onError(callback) {
    this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));
  }
  /**
   * Returns `true` if the socket is connected and the channel has been joined.
   *
   * @internal
   */
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  /** @internal */
  _rejoin(timeout = this.timeout) {
    if (this._isLeaving()) {
      return;
    }
    this.socket._leaveOpenTopic(this.topic);
    this.state = CHANNEL_STATES.joining;
    this.joinPush.resend(timeout);
  }
  /** @internal */
  _getPayloadRecords(payload) {
    const records = {
      new: {},
      old: {}
    };
    if (payload.type === "INSERT" || payload.type === "UPDATE") {
      records.new = convertChangeData(payload.columns, payload.record);
    }
    if (payload.type === "UPDATE" || payload.type === "DELETE") {
      records.old = convertChangeData(payload.columns, payload.old_record);
    }
    return records;
  }
};

// node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js
var noop2 = () => {
};
var NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket !== "undefined";
var WORKER_SCRIPT = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
var RealtimeClient = class {
  /**
   * Initializes the Socket.
   *
   * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
   * @param httpEndpoint The string HTTP endpoint, ie, "https://example.com", "/" (inherited host & protocol)
   * @param options.transport The Websocket Transport, for example WebSocket.
   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
   * @param options.params The optional params to pass when connecting.
   * @param options.headers The optional headers to pass when connecting.
   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
   * @param options.worker Use Web Worker to set a side flow. Defaults to false.
   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.
   */
  constructor(endPoint, options) {
    var _a2;
    this.accessTokenValue = null;
    this.apiKey = null;
    this.channels = [];
    this.endPoint = "";
    this.httpEndpoint = "";
    this.headers = DEFAULT_HEADERS;
    this.params = {};
    this.timeout = DEFAULT_TIMEOUT;
    this.heartbeatIntervalMs = 3e4;
    this.heartbeatTimer = void 0;
    this.pendingHeartbeatRef = null;
    this.ref = 0;
    this.logger = noop2;
    this.conn = null;
    this.sendBuffer = [];
    this.serializer = new Serializer();
    this.stateChangeCallbacks = {
      open: [],
      close: [],
      error: [],
      message: []
    };
    this.accessToken = null;
    this._resolveFetch = (customFetch) => {
      let _fetch;
      if (customFetch) {
        _fetch = customFetch;
      } else if (typeof fetch === "undefined") {
        _fetch = (...args) => Promise.resolve().then(() => (init_browser(), browser_exports)).then(({ default: fetch4 }) => fetch4(...args));
      } else {
        _fetch = fetch;
      }
      return (...args) => _fetch(...args);
    };
    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
    this.httpEndpoint = httpEndpointURL(endPoint);
    if (options === null || options === void 0 ? void 0 : options.transport) {
      this.transport = options.transport;
    } else {
      this.transport = null;
    }
    if (options === null || options === void 0 ? void 0 : options.params)
      this.params = options.params;
    if (options === null || options === void 0 ? void 0 : options.headers)
      this.headers = Object.assign(Object.assign({}, this.headers), options.headers);
    if (options === null || options === void 0 ? void 0 : options.timeout)
      this.timeout = options.timeout;
    if (options === null || options === void 0 ? void 0 : options.logger)
      this.logger = options.logger;
    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)
      this.heartbeatIntervalMs = options.heartbeatIntervalMs;
    const accessTokenValue = (_a2 = options === null || options === void 0 ? void 0 : options.params) === null || _a2 === void 0 ? void 0 : _a2.apikey;
    if (accessTokenValue) {
      this.accessTokenValue = accessTokenValue;
      this.apiKey = accessTokenValue;
    }
    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : (tries) => {
      return [1e3, 2e3, 5e3, 1e4][tries - 1] || 1e4;
    };
    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {
      return callback(JSON.stringify(payload));
    };
    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);
    this.reconnectTimer = new Timer(async () => {
      this.disconnect();
      this.connect();
    }, this.reconnectAfterMs);
    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);
    if (options === null || options === void 0 ? void 0 : options.worker) {
      if (typeof window !== "undefined" && !window.Worker) {
        throw new Error("Web Worker is not supported");
      }
      this.worker = (options === null || options === void 0 ? void 0 : options.worker) || false;
      this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;
    }
    this.accessToken = (options === null || options === void 0 ? void 0 : options.accessToken) || null;
  }
  /**
   * Connects the socket, unless already connected.
   */
  connect() {
    if (this.conn) {
      return;
    }
    if (this.transport) {
      this.conn = new this.transport(this.endpointURL(), void 0, {
        headers: this.headers
      });
      return;
    }
    if (NATIVE_WEBSOCKET_AVAILABLE) {
      this.conn = new WebSocket(this.endpointURL());
      this.setupConnection();
      return;
    }
    this.conn = new WSWebSocketDummy(this.endpointURL(), void 0, {
      close: () => {
        this.conn = null;
      }
    });
    Promise.resolve().then(() => __toESM(require_browser())).then(({ default: WS }) => {
      this.conn = new WS(this.endpointURL(), void 0, {
        headers: this.headers
      });
      this.setupConnection();
    });
  }
  /**
   * Returns the URL of the websocket.
   * @returns string The URL of the websocket.
   */
  endpointURL() {
    return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));
  }
  /**
   * Disconnects the socket.
   *
   * @param code A numeric status code to send on disconnect.
   * @param reason A custom reason for the disconnect.
   */
  disconnect(code, reason) {
    if (this.conn) {
      this.conn.onclose = function() {
      };
      if (code) {
        this.conn.close(code, reason !== null && reason !== void 0 ? reason : "");
      } else {
        this.conn.close();
      }
      this.conn = null;
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.reconnectTimer.reset();
    }
  }
  /**
   * Returns all created channels
   */
  getChannels() {
    return this.channels;
  }
  /**
   * Unsubscribes and removes a single channel
   * @param channel A RealtimeChannel instance
   */
  async removeChannel(channel) {
    const status = await channel.unsubscribe();
    if (this.channels.length === 0) {
      this.disconnect();
    }
    return status;
  }
  /**
   * Unsubscribes and removes all channels
   */
  async removeAllChannels() {
    const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));
    this.disconnect();
    return values_1;
  }
  /**
   * Logs the message.
   *
   * For customized logging, `this.logger` can be overridden.
   */
  log(kind2, msg, data) {
    this.logger(kind2, msg, data);
  }
  /**
   * Returns the current state of the socket.
   */
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case SOCKET_STATES.connecting:
        return CONNECTION_STATE.Connecting;
      case SOCKET_STATES.open:
        return CONNECTION_STATE.Open;
      case SOCKET_STATES.closing:
        return CONNECTION_STATE.Closing;
      default:
        return CONNECTION_STATE.Closed;
    }
  }
  /**
   * Returns `true` is the connection is open.
   */
  isConnected() {
    return this.connectionState() === CONNECTION_STATE.Open;
  }
  channel(topic, params = { config: {} }) {
    const chan = new RealtimeChannel(`realtime:${topic}`, params, this);
    this.channels.push(chan);
    return chan;
  }
  /**
   * Push out a message if the socket is connected.
   *
   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
   */
  push(data) {
    const { topic, event, payload, ref } = data;
    const callback = () => {
      this.encode(data, (result) => {
        var _a2;
        (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.send(result);
      });
    };
    this.log("push", `${topic} ${event} (${ref})`, payload);
    if (this.isConnected()) {
      callback();
    } else {
      this.sendBuffer.push(callback);
    }
  }
  /**
   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
   *
   * If param is null it will use the `accessToken` callback function or the token set on the client.
   *
   * On callback used, it will set the value of the token internal to the client.
   *
   * @param token A JWT string to override the token set on the client.
   */
  async setAuth(token = null) {
    let tokenToSend = token || this.accessToken && await this.accessToken() || this.accessTokenValue;
    if (tokenToSend) {
      let parsed = null;
      try {
        parsed = JSON.parse(atob(tokenToSend.split(".")[1]));
      } catch (_error) {
      }
      if (parsed && parsed.exp) {
        let now = Math.floor(Date.now() / 1e3);
        let valid = now - parsed.exp < 0;
        if (!valid) {
          this.log("auth", `InvalidJWTToken: Invalid value for JWT claim "exp" with value ${parsed.exp}`);
          return Promise.reject(`InvalidJWTToken: Invalid value for JWT claim "exp" with value ${parsed.exp}`);
        }
      }
      this.accessTokenValue = tokenToSend;
      this.channels.forEach((channel) => {
        tokenToSend && channel.updateJoinPayload({ access_token: tokenToSend });
        if (channel.joinedOnce && channel._isJoined()) {
          channel._push(CHANNEL_EVENTS.access_token, {
            access_token: tokenToSend
          });
        }
      });
    }
  }
  /**
   * Sends a heartbeat message if the socket is connected.
   */
  async sendHeartbeat() {
    var _a2;
    if (!this.isConnected()) {
      return;
    }
    if (this.pendingHeartbeatRef) {
      this.pendingHeartbeatRef = null;
      this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
      (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.close(WS_CLOSE_NORMAL, "hearbeat timeout");
      return;
    }
    this.pendingHeartbeatRef = this._makeRef();
    this.push({
      topic: "phoenix",
      event: "heartbeat",
      payload: {},
      ref: this.pendingHeartbeatRef
    });
    this.setAuth();
  }
  /**
   * Flushes send buffer
   */
  flushSendBuffer() {
    if (this.isConnected() && this.sendBuffer.length > 0) {
      this.sendBuffer.forEach((callback) => callback());
      this.sendBuffer = [];
    }
  }
  /**
   * Return the next message ref, accounting for overflows
   *
   * @internal
   */
  _makeRef() {
    let newRef = this.ref + 1;
    if (newRef === this.ref) {
      this.ref = 0;
    } else {
      this.ref = newRef;
    }
    return this.ref.toString();
  }
  /**
   * Unsubscribe from channels with the specified topic.
   *
   * @internal
   */
  _leaveOpenTopic(topic) {
    let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));
    if (dupChannel) {
      this.log("transport", `leaving duplicate topic "${topic}"`);
      dupChannel.unsubscribe();
    }
  }
  /**
   * Removes a subscription from the socket.
   *
   * @param channel An open subscription.
   *
   * @internal
   */
  _remove(channel) {
    this.channels = this.channels.filter((c) => c._joinRef() !== channel._joinRef());
  }
  /**
   * Sets up connection handlers.
   *
   * @internal
   */
  setupConnection() {
    if (this.conn) {
      this.conn.binaryType = "arraybuffer";
      this.conn.onopen = () => this._onConnOpen();
      this.conn.onerror = (error) => this._onConnError(error);
      this.conn.onmessage = (event) => this._onConnMessage(event);
      this.conn.onclose = (event) => this._onConnClose(event);
    }
  }
  /** @internal */
  _onConnMessage(rawMessage) {
    this.decode(rawMessage.data, (msg) => {
      let { topic, event, payload, ref } = msg;
      if (ref && ref === this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
      }
      this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
      this.channels.filter((channel) => channel._isMember(topic)).forEach((channel) => channel._trigger(event, payload, ref));
      this.stateChangeCallbacks.message.forEach((callback) => callback(msg));
    });
  }
  /** @internal */
  async _onConnOpen() {
    this.log("transport", `connected to ${this.endpointURL()}`);
    this.flushSendBuffer();
    this.reconnectTimer.reset();
    if (!this.worker) {
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    } else {
      if (this.workerUrl) {
        this.log("worker", `starting worker for from ${this.workerUrl}`);
      } else {
        this.log("worker", `starting default worker`);
      }
      const objectUrl = this._workerObjectUrl(this.workerUrl);
      this.workerRef = new Worker(objectUrl);
      this.workerRef.onerror = (error) => {
        this.log("worker", "worker error", error.message);
        this.workerRef.terminate();
      };
      this.workerRef.onmessage = (event) => {
        if (event.data.event === "keepAlive") {
          this.sendHeartbeat();
        }
      };
      this.workerRef.postMessage({
        event: "start",
        interval: this.heartbeatIntervalMs
      });
    }
    this.stateChangeCallbacks.open.forEach((callback) => callback());
  }
  /** @internal */
  _onConnClose(event) {
    this.log("transport", "close", event);
    this._triggerChanError();
    this.heartbeatTimer && clearInterval(this.heartbeatTimer);
    this.reconnectTimer.scheduleTimeout();
    this.stateChangeCallbacks.close.forEach((callback) => callback(event));
  }
  /** @internal */
  _onConnError(error) {
    this.log("transport", error.message);
    this._triggerChanError();
    this.stateChangeCallbacks.error.forEach((callback) => callback(error));
  }
  /** @internal */
  _triggerChanError() {
    this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));
  }
  /** @internal */
  _appendParams(url, params) {
    if (Object.keys(params).length === 0) {
      return url;
    }
    const prefix = url.match(/\?/) ? "&" : "?";
    const query = new URLSearchParams(params);
    return `${url}${prefix}${query}`;
  }
  _workerObjectUrl(url) {
    let result_url;
    if (url) {
      result_url = url;
    } else {
      const blob = new Blob([WORKER_SCRIPT], { type: "application/javascript" });
      result_url = URL.createObjectURL(blob);
    }
    return result_url;
  }
};
var WSWebSocketDummy = class {
  constructor(address, _protocols, options) {
    this.binaryType = "arraybuffer";
    this.onclose = () => {
    };
    this.onerror = () => {
    };
    this.onmessage = () => {
    };
    this.onopen = () => {
    };
    this.readyState = SOCKET_STATES.connecting;
    this.send = () => {
    };
    this.url = null;
    this.url = address;
    this.close = options.close;
  }
};

// node_modules/@supabase/storage-js/dist/module/lib/errors.js
var StorageError = class extends Error {
  constructor(message) {
    super(message);
    this.__isStorageError = true;
    this.name = "StorageError";
  }
};
function isStorageError(error) {
  return typeof error === "object" && error !== null && "__isStorageError" in error;
}
var StorageApiError = class extends StorageError {
  constructor(message, status) {
    super(message);
    this.name = "StorageApiError";
    this.status = status;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    };
  }
};
var StorageUnknownError = class extends StorageError {
  constructor(message, originalError) {
    super(message);
    this.name = "StorageUnknownError";
    this.originalError = originalError;
  }
};

// node_modules/@supabase/storage-js/dist/module/lib/helpers.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var resolveFetch2 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => Promise.resolve().then(() => (init_browser(), browser_exports)).then(({ default: fetch4 }) => fetch4(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
var resolveResponse = () => __awaiter2(void 0, void 0, void 0, function* () {
  if (typeof Response === "undefined") {
    return (yield Promise.resolve().then(() => (init_browser(), browser_exports))).Response;
  }
  return Response;
});
var recursiveToCamel = (item) => {
  if (Array.isArray(item)) {
    return item.map((el) => recursiveToCamel(el));
  } else if (typeof item === "function" || item !== Object(item)) {
    return item;
  }
  const result = {};
  Object.entries(item).forEach(([key, value]) => {
    const newKey = key.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ""));
    result[newKey] = recursiveToCamel(value);
  });
  return result;
};

// node_modules/@supabase/storage-js/dist/module/lib/fetch.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
var handleError = (error, reject, options) => __awaiter3(void 0, void 0, void 0, function* () {
  const Res = yield resolveResponse();
  if (error instanceof Res && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
    error.json().then((err) => {
      reject(new StorageApiError(_getErrorMessage(err), error.status || 500));
    }).catch((err) => {
      reject(new StorageUnknownError(_getErrorMessage(err), err));
    });
  } else {
    reject(new StorageUnknownError(_getErrorMessage(error), error));
  }
});
var _getRequestParams = (method, options, parameters, body) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET") {
    return params;
  }
  params.headers = Object.assign({ "Content-Type": "application/json" }, options === null || options === void 0 ? void 0 : options.headers);
  if (body) {
    params.body = JSON.stringify(body);
  }
  return Object.assign(Object.assign({}, params), parameters);
};
function _handleRequest(fetcher, method, url, options, parameters, body) {
  return __awaiter3(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      fetcher(url, _getRequestParams(method, options, parameters, body)).then((result) => {
        if (!result.ok)
          throw result;
        if (options === null || options === void 0 ? void 0 : options.noResolveJson)
          return result;
        return result.json();
      }).then((data) => resolve(data)).catch((error) => handleError(error, reject, options));
    });
  });
}
function get(fetcher, url, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "GET", url, options, parameters);
  });
}
function post(fetcher, url, body, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "POST", url, options, parameters, body);
  });
}
function put(fetcher, url, body, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "PUT", url, options, parameters, body);
  });
}
function head(fetcher, url, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "HEAD", url, Object.assign(Object.assign({}, options), { noResolveJson: true }), parameters);
  });
}
function remove(fetcher, url, body, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "DELETE", url, options, parameters, body);
  });
}

// node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_SEARCH_OPTIONS = {
  limit: 100,
  offset: 0,
  sortBy: {
    column: "name",
    order: "asc"
  }
};
var DEFAULT_FILE_OPTIONS = {
  cacheControl: "3600",
  contentType: "text/plain;charset=UTF-8",
  upsert: false
};
var StorageFileApi = class {
  constructor(url, headers = {}, bucketId, fetch4) {
    this.url = url;
    this.headers = headers;
    this.bucketId = bucketId;
    this.fetch = resolveFetch2(fetch4);
  }
  /**
   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
   *
   * @param method HTTP method.
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadOrUpdate(method, path, fileBody, fileOptions) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        let body;
        const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
        let headers = Object.assign(Object.assign({}, this.headers), method === "POST" && { "x-upsert": String(options.upsert) });
        const metadata = options.metadata;
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          body = new FormData();
          body.append("cacheControl", options.cacheControl);
          if (metadata) {
            body.append("metadata", this.encodeMetadata(metadata));
          }
          body.append("", fileBody);
        } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
          body = fileBody;
          body.append("cacheControl", options.cacheControl);
          if (metadata) {
            body.append("metadata", this.encodeMetadata(metadata));
          }
        } else {
          body = fileBody;
          headers["cache-control"] = `max-age=${options.cacheControl}`;
          headers["content-type"] = options.contentType;
          if (metadata) {
            headers["x-metadata"] = this.toBase64(this.encodeMetadata(metadata));
          }
        }
        if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) {
          headers = Object.assign(Object.assign({}, headers), fileOptions.headers);
        }
        const cleanPath = this._removeEmptyFolders(path);
        const _path = this._getFinalPath(cleanPath);
        const res = yield this.fetch(`${this.url}/object/${_path}`, Object.assign({ method, body, headers }, (options === null || options === void 0 ? void 0 : options.duplex) ? { duplex: options.duplex } : {}));
        const data = yield res.json();
        if (res.ok) {
          return {
            data: { path: cleanPath, id: data.Id, fullPath: data.Key },
            error: null
          };
        } else {
          const error = data;
          return { data: null, error };
        }
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Uploads a file to an existing bucket.
   *
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  upload(path, fileBody, fileOptions) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("POST", path, fileBody, fileOptions);
    });
  }
  /**
   * Upload a file with a token generated from `createSignedUploadUrl`.
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param token The token generated from `createSignedUploadUrl`
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadToSignedUrl(path, token, fileBody, fileOptions) {
    return __awaiter4(this, void 0, void 0, function* () {
      const cleanPath = this._removeEmptyFolders(path);
      const _path = this._getFinalPath(cleanPath);
      const url = new URL(this.url + `/object/upload/sign/${_path}`);
      url.searchParams.set("token", token);
      try {
        let body;
        const options = Object.assign({ upsert: DEFAULT_FILE_OPTIONS.upsert }, fileOptions);
        const headers = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(options.upsert) });
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          body = new FormData();
          body.append("cacheControl", options.cacheControl);
          body.append("", fileBody);
        } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
          body = fileBody;
          body.append("cacheControl", options.cacheControl);
        } else {
          body = fileBody;
          headers["cache-control"] = `max-age=${options.cacheControl}`;
          headers["content-type"] = options.contentType;
        }
        const res = yield this.fetch(url.toString(), {
          method: "PUT",
          body,
          headers
        });
        const data = yield res.json();
        if (res.ok) {
          return {
            data: { path: cleanPath, fullPath: data.Key },
            error: null
          };
        } else {
          const error = data;
          return { data: null, error };
        }
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a signed upload URL.
   * Signed upload URLs can be used to upload files to the bucket without further authentication.
   * They are valid for 2 hours.
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param options.upsert If set to true, allows the file to be overwritten if it already exists.
   */
  createSignedUploadUrl(path, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        const headers = Object.assign({}, this.headers);
        if (options === null || options === void 0 ? void 0 : options.upsert) {
          headers["x-upsert"] = "true";
        }
        const data = yield post(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, { headers });
        const url = new URL(this.url + data.url);
        const token = url.searchParams.get("token");
        if (!token) {
          throw new StorageError("No token returned by API");
        }
        return { data: { signedUrl: url.toString(), path, token }, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Replaces an existing file at the specified path with a new one.
   *
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  update(path, fileBody, fileOptions) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("PUT", path, fileBody, fileOptions);
    });
  }
  /**
   * Moves an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
   * @param options The destination options.
   */
  move(fromPath, toPath, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/object/move`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath,
          destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Copies an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
   * @param options The destination options.
   */
  copy(fromPath, toPath, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/object/copy`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath,
          destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
        }, { headers: this.headers });
        return { data: { path: data.Key }, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  createSignedUrl(path, expiresIn, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        let data = yield post(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({ expiresIn }, (options === null || options === void 0 ? void 0 : options.transform) ? { transform: options.transform } : {}), { headers: this.headers });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
        const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);
        data = { signedUrl };
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   */
  createSignedUrls(paths, expiresIn, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
        return {
          data: data.map((datum) => Object.assign(Object.assign({}, datum), { signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null })),
          error: null
        };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
   *
   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
   * @param options.transform Transform the asset before serving it to the client.
   */
  download(path, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
      const renderPath = wantsTransformation ? "render/image/authenticated" : "object";
      const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
      const queryString = transformationQuery ? `?${transformationQuery}` : "";
      try {
        const _path = this._getFinalPath(path);
        const res = yield get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {
          headers: this.headers,
          noResolveJson: true
        });
        const data = yield res.blob();
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the details of an existing file.
   * @param path
   */
  info(path) {
    return __awaiter4(this, void 0, void 0, function* () {
      const _path = this._getFinalPath(path);
      try {
        const data = yield get(this.fetch, `${this.url}/object/info/${_path}`, {
          headers: this.headers
        });
        return { data: recursiveToCamel(data), error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Checks the existence of a file.
   * @param path
   */
  exists(path) {
    return __awaiter4(this, void 0, void 0, function* () {
      const _path = this._getFinalPath(path);
      try {
        yield head(this.fetch, `${this.url}/object/${_path}`, {
          headers: this.headers
        });
        return { data: true, error: null };
      } catch (error) {
        if (isStorageError(error) && error instanceof StorageUnknownError) {
          const originalError = error.originalError;
          if ([400, 404].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) {
            return { data: false, error };
          }
        }
        throw error;
      }
    });
  }
  /**
   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
   *
   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  getPublicUrl(path, options) {
    const _path = this._getFinalPath(path);
    const _queryString = [];
    const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? "" : options.download}` : "";
    if (downloadQueryParam !== "") {
      _queryString.push(downloadQueryParam);
    }
    const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
    const renderPath = wantsTransformation ? "render/image" : "object";
    const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
    if (transformationQuery !== "") {
      _queryString.push(transformationQuery);
    }
    let queryString = _queryString.join("&");
    if (queryString !== "") {
      queryString = `?${queryString}`;
    }
    return {
      data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) }
    };
  }
  /**
   * Deletes files within the same bucket
   *
   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
   */
  remove(paths) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Get file metadata
   * @param id the file id to retrieve metadata
   */
  // async getMetadata(
  //   id: string
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Update file metadata
   * @param id the file id to update metadata
   * @param meta the new file metadata
   */
  // async updateMetadata(
  //   id: string,
  //   meta: Metadata
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await post(
  //       this.fetch,
  //       `${this.url}/metadata/${id}`,
  //       { ...meta },
  //       { headers: this.headers }
  //     )
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Lists all the files within a bucket.
   * @param path The folder path.
   */
  list(path, options, parameters) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || "" });
        const data = yield post(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  encodeMetadata(metadata) {
    return JSON.stringify(metadata);
  }
  toBase64(data) {
    if (typeof Buffer !== "undefined") {
      return Buffer.from(data).toString("base64");
    }
    return btoa(data);
  }
  _getFinalPath(path) {
    return `${this.bucketId}/${path}`;
  }
  _removeEmptyFolders(path) {
    return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
  }
  transformOptsToQueryString(transform) {
    const params = [];
    if (transform.width) {
      params.push(`width=${transform.width}`);
    }
    if (transform.height) {
      params.push(`height=${transform.height}`);
    }
    if (transform.resize) {
      params.push(`resize=${transform.resize}`);
    }
    if (transform.format) {
      params.push(`format=${transform.format}`);
    }
    if (transform.quality) {
      params.push(`quality=${transform.quality}`);
    }
    return params.join("&");
  }
};

// node_modules/@supabase/storage-js/dist/module/lib/version.js
var version2 = "2.7.1";

// node_modules/@supabase/storage-js/dist/module/lib/constants.js
var DEFAULT_HEADERS2 = { "X-Client-Info": `storage-js/${version2}` };

// node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var StorageBucketApi = class {
  constructor(url, headers = {}, fetch4) {
    this.url = url;
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS2), headers);
    this.fetch = resolveFetch2(fetch4);
  }
  /**
   * Retrieves the details of all Storage buckets within an existing project.
   */
  listBuckets() {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield get(this.fetch, `${this.url}/bucket`, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the details of an existing Storage bucket.
   *
   * @param id The unique identifier of the bucket you would like to retrieve.
   */
  getBucket(id) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a new Storage bucket
   *
   * @param id A unique identifier for the bucket you are creating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   * @returns newly created bucket id
   */
  createBucket(id, options = {
    public: false
  }) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/bucket`, {
          id,
          name: id,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Updates a Storage bucket
   *
   * @param id A unique identifier for the bucket you are updating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   */
  updateBucket(id, options) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield put(this.fetch, `${this.url}/bucket/${id}`, {
          id,
          name: id,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Removes all objects inside a single bucket.
   *
   * @param id The unique identifier of the bucket you would like to empty.
   */
  emptyBucket(id) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
   * You must first `empty()` the bucket.
   *
   * @param id The unique identifier of the bucket you would like to delete.
   */
  deleteBucket(id) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
};

// node_modules/@supabase/storage-js/dist/module/StorageClient.js
var StorageClient = class extends StorageBucketApi {
  constructor(url, headers = {}, fetch4) {
    super(url, headers, fetch4);
  }
  /**
   * Perform file operation in a bucket.
   *
   * @param id The bucket id to operate on.
   */
  from(id) {
    return new StorageFileApi(this.url, this.headers, id, this.fetch);
  }
};

// node_modules/@supabase/supabase-js/dist/module/lib/version.js
var version3 = "2.47.16";

// node_modules/@supabase/supabase-js/dist/module/lib/constants.js
var JS_ENV = "";
if (typeof Deno !== "undefined") {
  JS_ENV = "deno";
} else if (typeof document !== "undefined") {
  JS_ENV = "web";
} else if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
  JS_ENV = "react-native";
} else {
  JS_ENV = "node";
}
var DEFAULT_HEADERS3 = { "X-Client-Info": `supabase-js-${JS_ENV}/${version3}` };
var DEFAULT_GLOBAL_OPTIONS = {
  headers: DEFAULT_HEADERS3
};
var DEFAULT_DB_OPTIONS = {
  schema: "public"
};
var DEFAULT_AUTH_OPTIONS = {
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  flowType: "implicit"
};
var DEFAULT_REALTIME_OPTIONS = {};

// node_modules/@supabase/supabase-js/dist/module/lib/fetch.js
init_browser();
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var resolveFetch3 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = browser_default;
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
var resolveHeadersConstructor = () => {
  if (typeof Headers === "undefined") {
    return Headers2;
  }
  return Headers;
};
var fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {
  const fetch4 = resolveFetch3(customFetch);
  const HeadersConstructor = resolveHeadersConstructor();
  return (input, init) => __awaiter6(void 0, void 0, void 0, function* () {
    var _a2;
    const accessToken = (_a2 = yield getAccessToken()) !== null && _a2 !== void 0 ? _a2 : supabaseKey;
    let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
    if (!headers.has("apikey")) {
      headers.set("apikey", supabaseKey);
    }
    if (!headers.has("Authorization")) {
      headers.set("Authorization", `Bearer ${accessToken}`);
    }
    return fetch4(input, Object.assign(Object.assign({}, init), { headers }));
  });
};

// node_modules/@supabase/supabase-js/dist/module/lib/helpers.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function stripTrailingSlash(url) {
  return url.replace(/\/$/, "");
}
function applySettingDefaults(options, defaults2) {
  const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;
  const { db: DEFAULT_DB_OPTIONS2, auth: DEFAULT_AUTH_OPTIONS2, realtime: DEFAULT_REALTIME_OPTIONS2, global: DEFAULT_GLOBAL_OPTIONS2 } = defaults2;
  const result = {
    db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS2), dbOptions),
    auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS2), authOptions),
    realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS2), realtimeOptions),
    global: Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS2), globalOptions),
    accessToken: () => __awaiter7(this, void 0, void 0, function* () {
      return "";
    })
  };
  if (options.accessToken) {
    result.accessToken = options.accessToken;
  } else {
    delete result.accessToken;
  }
  return result;
}

// node_modules/@supabase/auth-js/dist/module/lib/version.js
var version4 = "2.67.3";

// node_modules/@supabase/auth-js/dist/module/lib/constants.js
var GOTRUE_URL = "http://localhost:9999";
var STORAGE_KEY = "supabase.auth.token";
var DEFAULT_HEADERS4 = { "X-Client-Info": `gotrue-js/${version4}` };
var EXPIRY_MARGIN = 10;
var API_VERSION_HEADER_NAME = "X-Supabase-Api-Version";
var API_VERSIONS = {
  "2024-01-01": {
    timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
    name: "2024-01-01"
  }
};

// node_modules/@supabase/auth-js/dist/module/lib/helpers.js
function expiresAt(expiresIn) {
  const timeNow = Math.round(Date.now() / 1e3);
  return timeNow + expiresIn;
}
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
var isBrowser = () => typeof window !== "undefined" && typeof document !== "undefined";
var localStorageWriteTests = {
  tested: false,
  writable: false
};
var supportsLocalStorage = () => {
  if (!isBrowser()) {
    return false;
  }
  try {
    if (typeof globalThis.localStorage !== "object") {
      return false;
    }
  } catch (e) {
    return false;
  }
  if (localStorageWriteTests.tested) {
    return localStorageWriteTests.writable;
  }
  const randomKey = `lswt-${Math.random()}${Math.random()}`;
  try {
    globalThis.localStorage.setItem(randomKey, randomKey);
    globalThis.localStorage.removeItem(randomKey);
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = true;
  } catch (e) {
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = false;
  }
  return localStorageWriteTests.writable;
};
function parseParametersFromURL(href) {
  const result = {};
  const url = new URL(href);
  if (url.hash && url.hash[0] === "#") {
    try {
      const hashSearchParams = new URLSearchParams(url.hash.substring(1));
      hashSearchParams.forEach((value, key) => {
        result[key] = value;
      });
    } catch (e) {
    }
  }
  url.searchParams.forEach((value, key) => {
    result[key] = value;
  });
  return result;
}
var resolveFetch4 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => Promise.resolve().then(() => (init_browser(), browser_exports)).then(({ default: fetch4 }) => fetch4(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
var looksLikeFetchResponse = (maybeResponse) => {
  return typeof maybeResponse === "object" && maybeResponse !== null && "status" in maybeResponse && "ok" in maybeResponse && "json" in maybeResponse && typeof maybeResponse.json === "function";
};
var setItemAsync = async (storage, key, data) => {
  await storage.setItem(key, JSON.stringify(data));
};
var getItemAsync = async (storage, key) => {
  const value = await storage.getItem(key);
  if (!value) {
    return null;
  }
  try {
    return JSON.parse(value);
  } catch (_a2) {
    return value;
  }
};
var removeItemAsync = async (storage, key) => {
  await storage.removeItem(key);
};
function decodeBase64URL(value) {
  const key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let base64 = "";
  let chr1, chr2, chr3;
  let enc1, enc2, enc3, enc4;
  let i = 0;
  value = value.replace("-", "+").replace("_", "/");
  while (i < value.length) {
    enc1 = key.indexOf(value.charAt(i++));
    enc2 = key.indexOf(value.charAt(i++));
    enc3 = key.indexOf(value.charAt(i++));
    enc4 = key.indexOf(value.charAt(i++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    base64 = base64 + String.fromCharCode(chr1);
    if (enc3 != 64 && chr2 != 0) {
      base64 = base64 + String.fromCharCode(chr2);
    }
    if (enc4 != 64 && chr3 != 0) {
      base64 = base64 + String.fromCharCode(chr3);
    }
  }
  return base64;
}
var Deferred = class {
  constructor() {
    ;
    this.promise = new Deferred.promiseConstructor((res, rej) => {
      ;
      this.resolve = res;
      this.reject = rej;
    });
  }
};
Deferred.promiseConstructor = Promise;
function decodeJWTPayload(token) {
  const base64UrlRegex = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i;
  const parts = token.split(".");
  if (parts.length !== 3) {
    throw new Error("JWT is not valid: not a JWT structure");
  }
  if (!base64UrlRegex.test(parts[1])) {
    throw new Error("JWT is not valid: payload is not in base64url format");
  }
  const base64Url = parts[1];
  return JSON.parse(decodeBase64URL(base64Url));
}
async function sleep(time) {
  return await new Promise((accept) => {
    setTimeout(() => accept(null), time);
  });
}
function retryable(fn, isRetryable) {
  const promise = new Promise((accept, reject) => {
    ;
    (async () => {
      for (let attempt = 0; attempt < Infinity; attempt++) {
        try {
          const result = await fn(attempt);
          if (!isRetryable(attempt, null, result)) {
            accept(result);
            return;
          }
        } catch (e) {
          if (!isRetryable(attempt, e)) {
            reject(e);
            return;
          }
        }
      }
    })();
  });
  return promise;
}
function dec2hex(dec) {
  return ("0" + dec.toString(16)).substr(-2);
}
function generatePKCEVerifier() {
  const verifierLength = 56;
  const array = new Uint32Array(verifierLength);
  if (typeof crypto === "undefined") {
    const charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
    const charSetLen = charSet.length;
    let verifier = "";
    for (let i = 0; i < verifierLength; i++) {
      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));
    }
    return verifier;
  }
  crypto.getRandomValues(array);
  return Array.from(array, dec2hex).join("");
}
async function sha256(randomString) {
  const encoder = new TextEncoder();
  const encodedData = encoder.encode(randomString);
  const hash = await crypto.subtle.digest("SHA-256", encodedData);
  const bytes = new Uint8Array(hash);
  return Array.from(bytes).map((c) => String.fromCharCode(c)).join("");
}
function base64urlencode(str2) {
  return btoa(str2).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function generatePKCEChallenge(verifier) {
  const hasCryptoSupport = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined" && typeof TextEncoder !== "undefined";
  if (!hasCryptoSupport) {
    console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.");
    return verifier;
  }
  const hashed = await sha256(verifier);
  return base64urlencode(hashed);
}
async function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {
  const codeVerifier = generatePKCEVerifier();
  let storedCodeVerifier = codeVerifier;
  if (isPasswordRecovery) {
    storedCodeVerifier += "/PASSWORD_RECOVERY";
  }
  await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);
  const codeChallenge = await generatePKCEChallenge(codeVerifier);
  const codeChallengeMethod = codeVerifier === codeChallenge ? "plain" : "s256";
  return [codeChallenge, codeChallengeMethod];
}
var API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function parseResponseAPIVersion(response) {
  const apiVersion = response.headers.get(API_VERSION_HEADER_NAME);
  if (!apiVersion) {
    return null;
  }
  if (!apiVersion.match(API_VERSION_REGEX)) {
    return null;
  }
  try {
    const date = new Date(`${apiVersion}T00:00:00.0Z`);
    return date;
  } catch (e) {
    return null;
  }
}

// node_modules/@supabase/auth-js/dist/module/lib/errors.js
var AuthError = class extends Error {
  constructor(message, status, code) {
    super(message);
    this.__isAuthError = true;
    this.name = "AuthError";
    this.status = status;
    this.code = code;
  }
};
function isAuthError(error) {
  return typeof error === "object" && error !== null && "__isAuthError" in error;
}
var AuthApiError = class extends AuthError {
  constructor(message, status, code) {
    super(message, status, code);
    this.name = "AuthApiError";
    this.status = status;
    this.code = code;
  }
};
function isAuthApiError(error) {
  return isAuthError(error) && error.name === "AuthApiError";
}
var AuthUnknownError = class extends AuthError {
  constructor(message, originalError) {
    super(message);
    this.name = "AuthUnknownError";
    this.originalError = originalError;
  }
};
var CustomAuthError = class extends AuthError {
  constructor(message, name, status, code) {
    super(message, status, code);
    this.name = name;
    this.status = status;
  }
};
var AuthSessionMissingError = class extends CustomAuthError {
  constructor() {
    super("Auth session missing!", "AuthSessionMissingError", 400, void 0);
  }
};
function isAuthSessionMissingError(error) {
  return isAuthError(error) && error.name === "AuthSessionMissingError";
}
var AuthInvalidTokenResponseError = class extends CustomAuthError {
  constructor() {
    super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0);
  }
};
var AuthInvalidCredentialsError = class extends CustomAuthError {
  constructor(message) {
    super(message, "AuthInvalidCredentialsError", 400, void 0);
  }
};
var AuthImplicitGrantRedirectError = class extends CustomAuthError {
  constructor(message, details = null) {
    super(message, "AuthImplicitGrantRedirectError", 500, void 0);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
};
function isAuthImplicitGrantRedirectError(error) {
  return isAuthError(error) && error.name === "AuthImplicitGrantRedirectError";
}
var AuthPKCEGrantCodeExchangeError = class extends CustomAuthError {
  constructor(message, details = null) {
    super(message, "AuthPKCEGrantCodeExchangeError", 500, void 0);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
};
var AuthRetryableFetchError = class extends CustomAuthError {
  constructor(message, status) {
    super(message, "AuthRetryableFetchError", status, void 0);
  }
};
function isAuthRetryableFetchError(error) {
  return isAuthError(error) && error.name === "AuthRetryableFetchError";
}
var AuthWeakPasswordError = class extends CustomAuthError {
  constructor(message, status, reasons) {
    super(message, "AuthWeakPasswordError", status, "weak_password");
    this.reasons = reasons;
  }
};

// node_modules/@supabase/auth-js/dist/module/lib/fetch.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var _getErrorMessage2 = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
var NETWORK_ERROR_CODES = [502, 503, 504];
async function handleError2(error) {
  var _a2;
  if (!looksLikeFetchResponse(error)) {
    throw new AuthRetryableFetchError(_getErrorMessage2(error), 0);
  }
  if (NETWORK_ERROR_CODES.includes(error.status)) {
    throw new AuthRetryableFetchError(_getErrorMessage2(error), error.status);
  }
  let data;
  try {
    data = await error.json();
  } catch (e) {
    throw new AuthUnknownError(_getErrorMessage2(e), e);
  }
  let errorCode = void 0;
  const responseAPIVersion = parseResponseAPIVersion(error);
  if (responseAPIVersion && responseAPIVersion.getTime() >= API_VERSIONS["2024-01-01"].timestamp && typeof data === "object" && data && typeof data.code === "string") {
    errorCode = data.code;
  } else if (typeof data === "object" && data && typeof data.error_code === "string") {
    errorCode = data.error_code;
  }
  if (!errorCode) {
    if (typeof data === "object" && data && typeof data.weak_password === "object" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
      throw new AuthWeakPasswordError(_getErrorMessage2(data), error.status, data.weak_password.reasons);
    }
  } else if (errorCode === "weak_password") {
    throw new AuthWeakPasswordError(_getErrorMessage2(data), error.status, ((_a2 = data.weak_password) === null || _a2 === void 0 ? void 0 : _a2.reasons) || []);
  } else if (errorCode === "session_not_found") {
    throw new AuthSessionMissingError();
  }
  throw new AuthApiError(_getErrorMessage2(data), error.status || 500, errorCode);
}
var _getRequestParams2 = (method, options, parameters, body) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET") {
    return params;
  }
  params.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, options === null || options === void 0 ? void 0 : options.headers);
  params.body = JSON.stringify(body);
  return Object.assign(Object.assign({}, params), parameters);
};
async function _request(fetcher, method, url, options) {
  var _a2;
  const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
  if (!headers[API_VERSION_HEADER_NAME]) {
    headers[API_VERSION_HEADER_NAME] = API_VERSIONS["2024-01-01"].name;
  }
  if (options === null || options === void 0 ? void 0 : options.jwt) {
    headers["Authorization"] = `Bearer ${options.jwt}`;
  }
  const qs = (_a2 = options === null || options === void 0 ? void 0 : options.query) !== null && _a2 !== void 0 ? _a2 : {};
  if (options === null || options === void 0 ? void 0 : options.redirectTo) {
    qs["redirect_to"] = options.redirectTo;
  }
  const queryString = Object.keys(qs).length ? "?" + new URLSearchParams(qs).toString() : "";
  const data = await _handleRequest2(fetcher, method, url + queryString, {
    headers,
    noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson
  }, {}, options === null || options === void 0 ? void 0 : options.body);
  return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };
}
async function _handleRequest2(fetcher, method, url, options, parameters, body) {
  const requestParams = _getRequestParams2(method, options, parameters, body);
  let result;
  try {
    result = await fetcher(url, Object.assign({}, requestParams));
  } catch (e) {
    console.error(e);
    throw new AuthRetryableFetchError(_getErrorMessage2(e), 0);
  }
  if (!result.ok) {
    await handleError2(result);
  }
  if (options === null || options === void 0 ? void 0 : options.noResolveJson) {
    return result;
  }
  try {
    return await result.json();
  } catch (e) {
    await handleError2(e);
  }
}
function _sessionResponse(data) {
  var _a2;
  let session = null;
  if (hasSession(data)) {
    session = Object.assign({}, data);
    if (!data.expires_at) {
      session.expires_at = expiresAt(data.expires_in);
    }
  }
  const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
  return { data: { session, user }, error: null };
}
function _sessionResponsePassword(data) {
  const response = _sessionResponse(data);
  if (!response.error && data.weak_password && typeof data.weak_password === "object" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === "string" && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
    response.data.weak_password = data.weak_password;
  }
  return response;
}
function _userResponse(data) {
  var _a2;
  const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
  return { data: { user }, error: null };
}
function _ssoResponse(data) {
  return { data, error: null };
}
function _generateLinkResponse(data) {
  const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
  const properties = {
    action_link,
    email_otp,
    hashed_token,
    redirect_to,
    verification_type
  };
  const user = Object.assign({}, rest);
  return {
    data: {
      properties,
      user
    },
    error: null
  };
}
function _noResolveJsonResponse(data) {
  return data;
}
function hasSession(data) {
  return data.access_token && data.refresh_token && data.expires_in;
}

// node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var GoTrueAdminApi = class {
  constructor({ url = "", headers = {}, fetch: fetch4 }) {
    this.url = url;
    this.headers = headers;
    this.fetch = resolveFetch4(fetch4);
    this.mfa = {
      listFactors: this._listFactors.bind(this),
      deleteFactor: this._deleteFactor.bind(this)
    };
  }
  /**
   * Removes a logged-in session.
   * @param jwt A valid, logged-in JWT.
   * @param scope The logout sope.
   */
  async signOut(jwt, scope = "global") {
    try {
      await _request(this.fetch, "POST", `${this.url}/logout?scope=${scope}`, {
        headers: this.headers,
        jwt,
        noResolveJson: true
      });
      return { data: null, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Sends an invite link to an email address.
   * @param email The email address of the user.
   * @param options Additional options to be included when inviting.
   */
  async inviteUserByEmail(email, options = {}) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/invite`, {
        body: { email, data: options.data },
        headers: this.headers,
        redirectTo: options.redirectTo,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Generates email links and OTPs to be sent via a custom email provider.
   * @param email The user's email.
   * @param options.password User password. For signup only.
   * @param options.data Optional user metadata. For signup only.
   * @param options.redirectTo The redirect url which should be appended to the generated link
   */
  async generateLink(params) {
    try {
      const { options } = params, rest = __rest2(params, ["options"]);
      const body = Object.assign(Object.assign({}, rest), options);
      if ("newEmail" in rest) {
        body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;
        delete body["newEmail"];
      }
      return await _request(this.fetch, "POST", `${this.url}/admin/generate_link`, {
        body,
        headers: this.headers,
        xform: _generateLinkResponse,
        redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo
      });
    } catch (error) {
      if (isAuthError(error)) {
        return {
          data: {
            properties: null,
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  // User Admin API
  /**
   * Creates a new user.
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async createUser(attributes) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/admin/users`, {
        body: attributes,
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Get a list of users.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
   */
  async listUsers(params) {
    var _a2, _b, _c, _d, _e, _f, _g;
    try {
      const pagination = { nextPage: null, lastPage: 0, total: 0 };
      const response = await _request(this.fetch, "GET", `${this.url}/admin/users`, {
        headers: this.headers,
        noResolveJson: true,
        query: {
          page: (_b = (_a2 = params === null || params === void 0 ? void 0 : params.page) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : "",
          per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
        },
        xform: _noResolveJsonResponse
      });
      if (response.error)
        throw response.error;
      const users = await response.json();
      const total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
      const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
      if (links.length > 0) {
        links.forEach((link) => {
          const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
          const rel = JSON.parse(link.split(";")[1].split("=")[1]);
          pagination[`${rel}Page`] = page;
        });
        pagination.total = parseInt(total);
      }
      return { data: Object.assign(Object.assign({}, users), pagination), error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { users: [] }, error };
      }
      throw error;
    }
  }
  /**
   * Get user by id.
   *
   * @param uid The user's unique identifier
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async getUserById(uid) {
    try {
      return await _request(this.fetch, "GET", `${this.url}/admin/users/${uid}`, {
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Updates the user data.
   *
   * @param attributes The data you want to update.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async updateUserById(uid, attributes) {
    try {
      return await _request(this.fetch, "PUT", `${this.url}/admin/users/${uid}`, {
        body: attributes,
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Delete a user. Requires a `service_role` key.
   *
   * @param id The user id you want to remove.
   * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.
   * Defaults to false for backward compatibility.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async deleteUser(id, shouldSoftDelete = false) {
    try {
      return await _request(this.fetch, "DELETE", `${this.url}/admin/users/${id}`, {
        headers: this.headers,
        body: {
          should_soft_delete: shouldSoftDelete
        },
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  async _listFactors(params) {
    try {
      const { data, error } = await _request(this.fetch, "GET", `${this.url}/admin/users/${params.userId}/factors`, {
        headers: this.headers,
        xform: (factors) => {
          return { data: { factors }, error: null };
        }
      });
      return { data, error };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  async _deleteFactor(params) {
    try {
      const data = await _request(this.fetch, "DELETE", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {
        headers: this.headers
      });
      return { data, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
};

// node_modules/@supabase/auth-js/dist/module/lib/local-storage.js
var localStorageAdapter = {
  getItem: (key) => {
    if (!supportsLocalStorage()) {
      return null;
    }
    return globalThis.localStorage.getItem(key);
  },
  setItem: (key, value) => {
    if (!supportsLocalStorage()) {
      return;
    }
    globalThis.localStorage.setItem(key, value);
  },
  removeItem: (key) => {
    if (!supportsLocalStorage()) {
      return;
    }
    globalThis.localStorage.removeItem(key);
  }
};
function memoryLocalStorageAdapter(store = {}) {
  return {
    getItem: (key) => {
      return store[key] || null;
    },
    setItem: (key, value) => {
      store[key] = value;
    },
    removeItem: (key) => {
      delete store[key];
    }
  };
}

// node_modules/@supabase/auth-js/dist/module/lib/polyfills.js
function polyfillGlobalThis() {
  if (typeof globalThis === "object")
    return;
  try {
    Object.defineProperty(Object.prototype, "__magic__", {
      get: function() {
        return this;
      },
      configurable: true
    });
    __magic__.globalThis = __magic__;
    delete Object.prototype.__magic__;
  } catch (e) {
    if (typeof self !== "undefined") {
      self.globalThis = self;
    }
  }
}

// node_modules/@supabase/auth-js/dist/module/lib/locks.js
var internals = {
  /**
   * @experimental
   */
  debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
var LockAcquireTimeoutError = class extends Error {
  constructor(message) {
    super(message);
    this.isAcquireTimeout = true;
  }
};
var NavigatorLockAcquireTimeoutError = class extends LockAcquireTimeoutError {
};
async function navigatorLock(name, acquireTimeout, fn) {
  if (internals.debug) {
    console.log("@supabase/gotrue-js: navigatorLock: acquire lock", name, acquireTimeout);
  }
  const abortController = new globalThis.AbortController();
  if (acquireTimeout > 0) {
    setTimeout(() => {
      abortController.abort();
      if (internals.debug) {
        console.log("@supabase/gotrue-js: navigatorLock acquire timed out", name);
      }
    }, acquireTimeout);
  }
  return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {
    mode: "exclusive",
    ifAvailable: true
  } : {
    mode: "exclusive",
    signal: abortController.signal
  }, async (lock) => {
    if (lock) {
      if (internals.debug) {
        console.log("@supabase/gotrue-js: navigatorLock: acquired", name, lock.name);
      }
      try {
        return await fn();
      } finally {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: released", name, lock.name);
        }
      }
    } else {
      if (acquireTimeout === 0) {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: not immediately available", name);
        }
        throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock "${name}" immediately failed`);
      } else {
        if (internals.debug) {
          try {
            const result = await globalThis.navigator.locks.query();
            console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(result, null, "  "));
          } catch (e) {
            console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", e);
          }
        }
        console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request");
        return await fn();
      }
    }
  }));
}

// node_modules/@supabase/auth-js/dist/module/GoTrueClient.js
polyfillGlobalThis();
var DEFAULT_OPTIONS = {
  url: GOTRUE_URL,
  storageKey: STORAGE_KEY,
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  headers: DEFAULT_HEADERS4,
  flowType: "implicit",
  debug: false,
  hasCustomAuthorizationHeader: false
};
var AUTO_REFRESH_TICK_DURATION = 30 * 1e3;
var AUTO_REFRESH_TICK_THRESHOLD = 3;
async function lockNoOp(name, acquireTimeout, fn) {
  return await fn();
}
var GoTrueClient = class {
  /**
   * Create a new client for use in the browser.
   */
  constructor(options) {
    var _a2, _b;
    this.memoryStorage = null;
    this.stateChangeEmitters = /* @__PURE__ */ new Map();
    this.autoRefreshTicker = null;
    this.visibilityChangedCallback = null;
    this.refreshingDeferred = null;
    this.initializePromise = null;
    this.detectSessionInUrl = true;
    this.hasCustomAuthorizationHeader = false;
    this.suppressGetSessionWarning = false;
    this.lockAcquired = false;
    this.pendingInLock = [];
    this.broadcastChannel = null;
    this.logger = console.log;
    this.instanceID = GoTrueClient.nextInstanceID;
    GoTrueClient.nextInstanceID += 1;
    if (this.instanceID > 0 && isBrowser()) {
      console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");
    }
    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    this.logDebugMessages = !!settings.debug;
    if (typeof settings.debug === "function") {
      this.logger = settings.debug;
    }
    this.persistSession = settings.persistSession;
    this.storageKey = settings.storageKey;
    this.autoRefreshToken = settings.autoRefreshToken;
    this.admin = new GoTrueAdminApi({
      url: settings.url,
      headers: settings.headers,
      fetch: settings.fetch
    });
    this.url = settings.url;
    this.headers = settings.headers;
    this.fetch = resolveFetch4(settings.fetch);
    this.lock = settings.lock || lockNoOp;
    this.detectSessionInUrl = settings.detectSessionInUrl;
    this.flowType = settings.flowType;
    this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;
    if (settings.lock) {
      this.lock = settings.lock;
    } else if (isBrowser() && ((_a2 = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a2 === void 0 ? void 0 : _a2.locks)) {
      this.lock = navigatorLock;
    } else {
      this.lock = lockNoOp;
    }
    this.mfa = {
      verify: this._verify.bind(this),
      enroll: this._enroll.bind(this),
      unenroll: this._unenroll.bind(this),
      challenge: this._challenge.bind(this),
      listFactors: this._listFactors.bind(this),
      challengeAndVerify: this._challengeAndVerify.bind(this),
      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)
    };
    if (this.persistSession) {
      if (settings.storage) {
        this.storage = settings.storage;
      } else {
        if (supportsLocalStorage()) {
          this.storage = localStorageAdapter;
        } else {
          this.memoryStorage = {};
          this.storage = memoryLocalStorageAdapter(this.memoryStorage);
        }
      }
    } else {
      this.memoryStorage = {};
      this.storage = memoryLocalStorageAdapter(this.memoryStorage);
    }
    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
      } catch (e) {
        console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", e);
      }
      (_b = this.broadcastChannel) === null || _b === void 0 ? void 0 : _b.addEventListener("message", async (event) => {
        this._debug("received broadcast notification from other tab or client", event);
        await this._notifyAllSubscribers(event.data.event, event.data.session, false);
      });
    }
    this.initialize();
  }
  _debug(...args) {
    if (this.logDebugMessages) {
      this.logger(`GoTrueClient@${this.instanceID} (${version4}) ${new Date().toISOString()}`, ...args);
    }
    return this;
  }
  /**
   * Initializes the client session either from the url or from storage.
   * This method is automatically called when instantiating the client, but should also be called
   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
   */
  async initialize() {
    if (this.initializePromise) {
      return await this.initializePromise;
    }
    this.initializePromise = (async () => {
      return await this._acquireLock(-1, async () => {
        return await this._initialize();
      });
    })();
    return await this.initializePromise;
  }
  /**
   * IMPORTANT:
   * 1. Never throw in this method, as it is called from the constructor
   * 2. Never return a session from this method as it would be cached over
   *    the whole lifetime of the client
   */
  async _initialize() {
    var _a2;
    try {
      const params = parseParametersFromURL(window.location.href);
      let callbackUrlType = "none";
      if (this._isImplicitGrantCallback(params)) {
        callbackUrlType = "implicit";
      } else if (await this._isPKCECallback(params)) {
        callbackUrlType = "pkce";
      }
      if (isBrowser() && this.detectSessionInUrl && callbackUrlType !== "none") {
        const { data, error } = await this._getSessionFromURL(params, callbackUrlType);
        if (error) {
          this._debug("#_initialize()", "error detecting session from URL", error);
          if (isAuthImplicitGrantRedirectError(error)) {
            const errorCode = (_a2 = error.details) === null || _a2 === void 0 ? void 0 : _a2.code;
            if (errorCode === "identity_already_exists" || errorCode === "identity_not_found" || errorCode === "single_identity_not_deletable") {
              return { error };
            }
          }
          await this._removeSession();
          return { error };
        }
        const { session, redirectType } = data;
        this._debug("#_initialize()", "detected session in URL", session, "redirect type", redirectType);
        await this._saveSession(session);
        setTimeout(async () => {
          if (redirectType === "recovery") {
            await this._notifyAllSubscribers("PASSWORD_RECOVERY", session);
          } else {
            await this._notifyAllSubscribers("SIGNED_IN", session);
          }
        }, 0);
        return { error: null };
      }
      await this._recoverAndRefresh();
      return { error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { error };
      }
      return {
        error: new AuthUnknownError("Unexpected error during initialization", error)
      };
    } finally {
      await this._handleVisibilityChange();
      this._debug("#_initialize()", "end");
    }
  }
  /**
   * Creates a new anonymous user.
   *
   * @returns A session where the is_anonymous claim in the access token JWT set to true
   */
  async signInAnonymously(credentials) {
    var _a2, _b, _c;
    try {
      const res = await _request(this.fetch, "POST", `${this.url}/signup`, {
        headers: this.headers,
        body: {
          data: (_b = (_a2 = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a2 === void 0 ? void 0 : _a2.data) !== null && _b !== void 0 ? _b : {},
          gotrue_meta_security: { captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken }
        },
        xform: _sessionResponse
      });
      const { data, error } = res;
      if (error || !data) {
        return { data: { user: null, session: null }, error };
      }
      const session = data.session;
      const user = data.user;
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return { data: { user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Creates a new user.
   *
   * Be aware that if a user account exists in the system you may get back an
   * error message that attempts to hide this information from the user.
   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
   *
   * @returns A logged-in session if the server has "autoconfirm" ON
   * @returns A user if the server has "autoconfirm" OFF
   */
  async signUp(credentials) {
    var _a2, _b, _c;
    try {
      let res;
      if ("email" in credentials) {
        const { email, password, options } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        res = await _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: {
            email,
            password,
            data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          xform: _sessionResponse
        });
      } else if ("phone" in credentials) {
        const { phone, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone,
            password,
            data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},
            channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : "sms",
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponse
        });
      } else {
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
      }
      const { data, error } = res;
      if (error || !data) {
        return { data: { user: null, session: null }, error };
      }
      const session = data.session;
      const user = data.user;
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return { data: { user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in an existing user with an email and password or phone and password.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or that the
   * email/phone and password combination is wrong or that the account can only
   * be accessed via social login.
   */
  async signInWithPassword(credentials) {
    try {
      let res;
      if ("email" in credentials) {
        const { email, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            email,
            password,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponsePassword
        });
      } else if ("phone" in credentials) {
        const { phone, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            phone,
            password,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponsePassword
        });
      } else {
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
      }
      const { data, error } = res;
      if (error) {
        return { data: { user: null, session: null }, error };
      } else if (!data || !data.session || !data.user) {
        return { data: { user: null, session: null }, error: new AuthInvalidTokenResponseError() };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return {
        data: Object.assign({ user: data.user, session: data.session }, data.weak_password ? { weakPassword: data.weak_password } : null),
        error
      };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in an existing user via a third-party provider.
   * This method supports the PKCE flow.
   */
  async signInWithOAuth(credentials) {
    var _a2, _b, _c, _d;
    return await this._handleProviderSignIn(credentials.provider, {
      redirectTo: (_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo,
      scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
      queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
      skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect
    });
  }
  /**
   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
   */
  async exchangeCodeForSession(authCode) {
    await this.initializePromise;
    return this._acquireLock(-1, async () => {
      return this._exchangeCodeForSession(authCode);
    });
  }
  async _exchangeCodeForSession(authCode) {
    const storageItem = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : "").split("/");
    try {
      const { data, error } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
        headers: this.headers,
        body: {
          auth_code: authCode,
          code_verifier: codeVerifier
        },
        xform: _sessionResponse
      });
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (error) {
        throw error;
      }
      if (!data || !data.session || !data.user) {
        return {
          data: { user: null, session: null, redirectType: null },
          error: new AuthInvalidTokenResponseError()
        };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return { data: Object.assign(Object.assign({}, data), { redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null }), error };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null, redirectType: null }, error };
      }
      throw error;
    }
  }
  /**
   * Allows signing in with an OIDC ID token. The authentication provider used
   * should be enabled and configured.
   */
  async signInWithIdToken(credentials) {
    try {
      const { options, provider, token, access_token, nonce } = credentials;
      const res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
        headers: this.headers,
        body: {
          provider,
          id_token: token,
          access_token,
          nonce,
          gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
        },
        xform: _sessionResponse
      });
      const { data, error } = res;
      if (error) {
        return { data: { user: null, session: null }, error };
      } else if (!data || !data.session || !data.user) {
        return {
          data: { user: null, session: null },
          error: new AuthInvalidTokenResponseError()
        };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return { data, error };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in a user using magiclink or a one-time password (OTP).
   *
   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or, that the account
   * can only be accessed via social login.
   *
   * Do note that you will need to configure a Whatsapp sender on Twilio
   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
   * channel is not supported on other providers
   * at this time.
   * This method supports PKCE when an email is passed.
   */
  async signInWithOtp(credentials) {
    var _a2, _b, _c, _d, _e;
    try {
      if ("email" in credentials) {
        const { email, options } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        const { error } = await _request(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email,
            data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
            create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return { data: { user: null, session: null }, error };
      }
      if ("phone" in credentials) {
        const { phone, options } = credentials;
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            phone,
            data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},
            create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : "sms"
          }
        });
        return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error };
      }
      throw new AuthInvalidCredentialsError("You must provide either an email or phone number.");
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in a user given a User supplied OTP or TokenHash received through mobile or email.
   */
  async verifyOtp(params) {
    var _a2, _b;
    try {
      let redirectTo = void 0;
      let captchaToken = void 0;
      if ("options" in params) {
        redirectTo = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo;
        captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;
      }
      const { data, error } = await _request(this.fetch, "POST", `${this.url}/verify`, {
        headers: this.headers,
        body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: captchaToken } }),
        redirectTo,
        xform: _sessionResponse
      });
      if (error) {
        throw error;
      }
      if (!data) {
        throw new Error("An error occurred on token verification.");
      }
      const session = data.session;
      const user = data.user;
      if (session === null || session === void 0 ? void 0 : session.access_token) {
        await this._saveSession(session);
        await this._notifyAllSubscribers(params.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", session);
      }
      return { data: { user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Attempts a single-sign on using an enterprise Identity Provider. A
   * successful SSO attempt will redirect the current page to the identity
   * provider authorization page. The redirect URL is implementation and SSO
   * protocol specific.
   *
   * You can use it by providing a SSO domain. Typically you can extract this
   * domain by asking users for their email address. If this domain is
   * registered on the Auth instance the redirect will use that organization's
   * currently active SSO Identity Provider for the login.
   *
   * If you have built an organization-specific login page, you can use the
   * organization's SSO Identity Provider UUID directly instead.
   */
  async signInWithSSO(params) {
    var _a2, _b, _c;
    try {
      let codeChallenge = null;
      let codeChallengeMethod = null;
      if (this.flowType === "pkce") {
        ;
        [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
      }
      return await _request(this.fetch, "POST", `${this.url}/sso`, {
        body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in params ? { provider_id: params.providerId } : null), "domain" in params ? { domain: params.domain } : null), { redirect_to: (_b = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo) !== null && _b !== void 0 ? _b : void 0 }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } } : null), { skip_http_redirect: true, code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
        headers: this.headers,
        xform: _ssoResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Sends a reauthentication OTP to the user's email or phone number.
   * Requires the user to be signed-in.
   */
  async reauthenticate() {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._reauthenticate();
    });
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError)
          throw sessionError;
        if (!session)
          throw new AuthSessionMissingError();
        const { error } = await _request(this.fetch, "GET", `${this.url}/reauthenticate`, {
          headers: this.headers,
          jwt: session.access_token
        });
        return { data: { user: null, session: null }, error };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
   */
  async resend(credentials) {
    try {
      const endpoint = `${this.url}/resend`;
      if ("email" in credentials) {
        const { email, type, options } = credentials;
        const { error } = await _request(this.fetch, "POST", endpoint, {
          headers: this.headers,
          body: {
            email,
            type,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return { data: { user: null, session: null }, error };
      } else if ("phone" in credentials) {
        const { phone, type, options } = credentials;
        const { data, error } = await _request(this.fetch, "POST", endpoint, {
          headers: this.headers,
          body: {
            phone,
            type,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          }
        });
        return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error };
      }
      throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a type");
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Returns the session, refreshing it if necessary.
   *
   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
   *
   * **IMPORTANT:** This method loads values directly from the storage attached
   * to the client. If that storage is based on request cookies for example,
   * the values in it may not be authentic and therefore it's strongly advised
   * against using this method and its results in such circumstances. A warning
   * will be emitted if this is detected. Use {@link #getUser()} instead.
   */
  async getSession() {
    await this.initializePromise;
    const result = await this._acquireLock(-1, async () => {
      return this._useSession(async (result2) => {
        return result2;
      });
    });
    return result;
  }
  /**
   * Acquires a global lock based on the storage key.
   */
  async _acquireLock(acquireTimeout, fn) {
    this._debug("#_acquireLock", "begin", acquireTimeout);
    try {
      if (this.lockAcquired) {
        const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
        const result = (async () => {
          await last;
          return await fn();
        })();
        this.pendingInLock.push((async () => {
          try {
            await result;
          } catch (e) {
          }
        })());
        return result;
      }
      return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async () => {
        this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
        try {
          this.lockAcquired = true;
          const result = fn();
          this.pendingInLock.push((async () => {
            try {
              await result;
            } catch (e) {
            }
          })());
          await result;
          while (this.pendingInLock.length) {
            const waitOn = [...this.pendingInLock];
            await Promise.all(waitOn);
            this.pendingInLock.splice(0, waitOn.length);
          }
          return await result;
        } finally {
          this._debug("#_acquireLock", "lock released for storage key", this.storageKey);
          this.lockAcquired = false;
        }
      });
    } finally {
      this._debug("#_acquireLock", "end");
    }
  }
  /**
   * Use instead of {@link #getSession} inside the library. It is
   * semantically usually what you want, as getting a session involves some
   * processing afterwards that requires only one client operating on the
   * session at once across multiple tabs or processes.
   */
  async _useSession(fn) {
    this._debug("#_useSession", "begin");
    try {
      const result = await this.__loadSession();
      return await fn(result);
    } finally {
      this._debug("#_useSession", "end");
    }
  }
  /**
   * NEVER USE DIRECTLY!
   *
   * Always use {@link #_useSession}.
   */
  async __loadSession() {
    this._debug("#__loadSession()", "begin");
    if (!this.lockAcquired) {
      this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
    }
    try {
      let currentSession = null;
      const maybeSession = await getItemAsync(this.storage, this.storageKey);
      this._debug("#getSession()", "session from storage", maybeSession);
      if (maybeSession !== null) {
        if (this._isValidSession(maybeSession)) {
          currentSession = maybeSession;
        } else {
          this._debug("#getSession()", "session from storage is not valid");
          await this._removeSession();
        }
      }
      if (!currentSession) {
        return { data: { session: null }, error: null };
      }
      const hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1e3 : false;
      this._debug("#__loadSession()", `session has${hasExpired ? "" : " not"} expired`, "expires_at", currentSession.expires_at);
      if (!hasExpired) {
        if (this.storage.isServer) {
          let suppressWarning = this.suppressGetSessionWarning;
          const proxySession = new Proxy(currentSession, {
            get: (target, prop, receiver) => {
              if (!suppressWarning && prop === "user") {
                console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.");
                suppressWarning = true;
                this.suppressGetSessionWarning = true;
              }
              return Reflect.get(target, prop, receiver);
            }
          });
          currentSession = proxySession;
        }
        return { data: { session: currentSession }, error: null };
      }
      const { session, error } = await this._callRefreshToken(currentSession.refresh_token);
      if (error) {
        return { data: { session: null }, error };
      }
      return { data: { session }, error: null };
    } finally {
      this._debug("#__loadSession()", "end");
    }
  }
  /**
   * Gets the current user details if there is an existing session. This method
   * performs a network request to the Supabase Auth server, so the returned
   * value is authentic and can be used to base authorization rules on.
   *
   * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.
   */
  async getUser(jwt) {
    if (jwt) {
      return await this._getUser(jwt);
    }
    await this.initializePromise;
    const result = await this._acquireLock(-1, async () => {
      return await this._getUser();
    });
    return result;
  }
  async _getUser(jwt) {
    try {
      if (jwt) {
        return await _request(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt,
          xform: _userResponse
        });
      }
      return await this._useSession(async (result) => {
        var _a2, _b, _c;
        const { data, error } = result;
        if (error) {
          throw error;
        }
        if (!((_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) && !this.hasCustomAuthorizationHeader) {
          return { data: { user: null }, error: new AuthSessionMissingError() };
        }
        return await _request(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : void 0,
          xform: _userResponse
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        if (isAuthSessionMissingError(error)) {
          await this._removeSession();
          await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        }
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Updates user data for a logged in user.
   */
  async updateUser(attributes, options = {}) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._updateUser(attributes, options);
    });
  }
  async _updateUser(attributes, options = {}) {
    try {
      return await this._useSession(async (result) => {
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          throw sessionError;
        }
        if (!sessionData.session) {
          throw new AuthSessionMissingError();
        }
        const session = sessionData.session;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce" && attributes.email != null) {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        const { data, error: userError } = await _request(this.fetch, "PUT", `${this.url}/user`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: Object.assign(Object.assign({}, attributes), { code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
          jwt: session.access_token,
          xform: _userResponse
        });
        if (userError)
          throw userError;
        session.user = data.user;
        await this._saveSession(session);
        await this._notifyAllSubscribers("USER_UPDATED", session);
        return { data: { user: session.user }, error: null };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Decodes a JWT (without performing any validation).
   */
  _decodeJWT(jwt) {
    return decodeJWTPayload(jwt);
  }
  /**
   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
   * If the refresh token or access token in the current session is invalid, an error will be thrown.
   * @param currentSession The current session that minimally contains an access token and refresh token.
   */
  async setSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._setSession(currentSession);
    });
  }
  async _setSession(currentSession) {
    try {
      if (!currentSession.access_token || !currentSession.refresh_token) {
        throw new AuthSessionMissingError();
      }
      const timeNow = Date.now() / 1e3;
      let expiresAt2 = timeNow;
      let hasExpired = true;
      let session = null;
      const payload = decodeJWTPayload(currentSession.access_token);
      if (payload.exp) {
        expiresAt2 = payload.exp;
        hasExpired = expiresAt2 <= timeNow;
      }
      if (hasExpired) {
        const { session: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return { data: { user: null, session: null }, error };
        }
        if (!refreshedSession) {
          return { data: { user: null, session: null }, error: null };
        }
        session = refreshedSession;
      } else {
        const { data, error } = await this._getUser(currentSession.access_token);
        if (error) {
          throw error;
        }
        session = {
          access_token: currentSession.access_token,
          refresh_token: currentSession.refresh_token,
          user: data.user,
          token_type: "bearer",
          expires_in: expiresAt2 - timeNow,
          expires_at: expiresAt2
        };
        await this._saveSession(session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return { data: { user: session.user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { session: null, user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Returns a new session, regardless of expiry status.
   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
   * If the current session's refresh token is invalid, an error will be thrown.
   * @param currentSession The current session. If passed in, it must contain a refresh token.
   */
  async refreshSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._refreshSession(currentSession);
    });
  }
  async _refreshSession(currentSession) {
    try {
      return await this._useSession(async (result) => {
        var _a2;
        if (!currentSession) {
          const { data, error: error2 } = result;
          if (error2) {
            throw error2;
          }
          currentSession = (_a2 = data.session) !== null && _a2 !== void 0 ? _a2 : void 0;
        }
        if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {
          throw new AuthSessionMissingError();
        }
        const { session, error } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return { data: { user: null, session: null }, error };
        }
        if (!session) {
          return { data: { user: null, session: null }, error: null };
        }
        return { data: { user: session.user, session }, error: null };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Gets the session data from a URL string
   */
  async _getSessionFromURL(params, callbackUrlType) {
    try {
      if (!isBrowser())
        throw new AuthImplicitGrantRedirectError("No browser detected.");
      if (params.error || params.error_description || params.error_code) {
        throw new AuthImplicitGrantRedirectError(params.error_description || "Error in URL with unspecified error_description", {
          error: params.error || "unspecified_error",
          code: params.error_code || "unspecified_code"
        });
      }
      switch (callbackUrlType) {
        case "implicit":
          if (this.flowType === "pkce") {
            throw new AuthPKCEGrantCodeExchangeError("Not a valid PKCE flow url.");
          }
          break;
        case "pkce":
          if (this.flowType === "implicit") {
            throw new AuthImplicitGrantRedirectError("Not a valid implicit grant flow url.");
          }
          break;
        default:
      }
      if (callbackUrlType === "pkce") {
        this._debug("#_initialize()", "begin", "is PKCE flow", true);
        if (!params.code)
          throw new AuthPKCEGrantCodeExchangeError("No code detected.");
        const { data: data2, error: error2 } = await this._exchangeCodeForSession(params.code);
        if (error2)
          throw error2;
        const url = new URL(window.location.href);
        url.searchParams.delete("code");
        window.history.replaceState(window.history.state, "", url.toString());
        return { data: { session: data2.session, redirectType: null }, error: null };
      }
      const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;
      if (!access_token || !expires_in || !refresh_token || !token_type) {
        throw new AuthImplicitGrantRedirectError("No session defined in URL");
      }
      const timeNow = Math.round(Date.now() / 1e3);
      const expiresIn = parseInt(expires_in);
      let expiresAt2 = timeNow + expiresIn;
      if (expires_at) {
        expiresAt2 = parseInt(expires_at);
      }
      const actuallyExpiresIn = expiresAt2 - timeNow;
      if (actuallyExpiresIn * 1e3 <= AUTO_REFRESH_TICK_DURATION) {
        console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);
      }
      const issuedAt = expiresAt2 - expiresIn;
      if (timeNow - issuedAt >= 120) {
        console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", issuedAt, expiresAt2, timeNow);
      } else if (timeNow - issuedAt < 0) {
        console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", issuedAt, expiresAt2, timeNow);
      }
      const { data, error } = await this._getUser(access_token);
      if (error)
        throw error;
      const session = {
        provider_token,
        provider_refresh_token,
        access_token,
        expires_in: expiresIn,
        expires_at: expiresAt2,
        refresh_token,
        token_type,
        user: data.user
      };
      window.location.hash = "";
      this._debug("#_getSessionFromURL()", "clearing window.location.hash");
      return { data: { session, redirectType: params.type }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { session: null, redirectType: null }, error };
      }
      throw error;
    }
  }
  /**
   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
   */
  _isImplicitGrantCallback(params) {
    return Boolean(params.access_token || params.error_description);
  }
  /**
   * Checks if the current URL and backing storage contain parameters given by a PKCE flow
   */
  async _isPKCECallback(params) {
    const currentStorageContent = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    return !!(params.code && currentStorageContent);
  }
  /**
   * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
   *
   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
   *
   * If using `others` scope, no `SIGNED_OUT` event is fired!
   */
  async signOut(options = { scope: "global" }) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._signOut(options);
    });
  }
  async _signOut({ scope } = { scope: "global" }) {
    return await this._useSession(async (result) => {
      var _a2;
      const { data, error: sessionError } = result;
      if (sessionError) {
        return { error: sessionError };
      }
      const accessToken = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token;
      if (accessToken) {
        const { error } = await this.admin.signOut(accessToken, scope);
        if (error) {
          if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401 || error.status === 403))) {
            return { error };
          }
        }
      }
      if (scope !== "others") {
        await this._removeSession();
        await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      }
      return { error: null };
    });
  }
  /**
   * Receive a notification every time an auth event happens.
   * @param callback A callback function to be invoked when an auth event happens.
   */
  onAuthStateChange(callback) {
    const id = uuid();
    const subscription = {
      id,
      callback,
      unsubscribe: () => {
        this._debug("#unsubscribe()", "state change callback with id removed", id);
        this.stateChangeEmitters.delete(id);
      }
    };
    this._debug("#onAuthStateChange()", "registered callback with id", id);
    this.stateChangeEmitters.set(id, subscription);
    (async () => {
      await this.initializePromise;
      await this._acquireLock(-1, async () => {
        this._emitInitialSession(id);
      });
    })();
    return { data: { subscription } };
  }
  async _emitInitialSession(id) {
    return await this._useSession(async (result) => {
      var _a2, _b;
      try {
        const { data: { session }, error } = result;
        if (error)
          throw error;
        await ((_a2 = this.stateChangeEmitters.get(id)) === null || _a2 === void 0 ? void 0 : _a2.callback("INITIAL_SESSION", session));
        this._debug("INITIAL_SESSION", "callback id", id, "session", session);
      } catch (err) {
        await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback("INITIAL_SESSION", null));
        this._debug("INITIAL_SESSION", "callback id", id, "error", err);
        console.error(err);
      }
    });
  }
  /**
   * Sends a password reset request to an email address. This method supports the PKCE flow.
   *
   * @param email The email address of the user.
   * @param options.redirectTo The URL to send the user to after they click the password reset link.
   * @param options.captchaToken Verification token received when the user completes the captcha on the site.
   */
  async resetPasswordForEmail(email, options = {}) {
    let codeChallenge = null;
    let codeChallengeMethod = null;
    if (this.flowType === "pkce") {
      ;
      [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(
        this.storage,
        this.storageKey,
        true
        // isPasswordRecovery
      );
    }
    try {
      return await _request(this.fetch, "POST", `${this.url}/recover`, {
        body: {
          email,
          code_challenge: codeChallenge,
          code_challenge_method: codeChallengeMethod,
          gotrue_meta_security: { captcha_token: options.captchaToken }
        },
        headers: this.headers,
        redirectTo: options.redirectTo
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Gets all the identities linked to a user.
   */
  async getUserIdentities() {
    var _a2;
    try {
      const { data, error } = await this.getUser();
      if (error)
        throw error;
      return { data: { identities: (_a2 = data.user.identities) !== null && _a2 !== void 0 ? _a2 : [] }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Links an oauth identity to an existing user.
   * This method supports the PKCE flow.
   */
  async linkIdentity(credentials) {
    var _a2;
    try {
      const { data, error } = await this._useSession(async (result) => {
        var _a3, _b, _c, _d, _e;
        const { data: data2, error: error2 } = result;
        if (error2)
          throw error2;
        const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {
          redirectTo: (_a3 = credentials.options) === null || _a3 === void 0 ? void 0 : _a3.redirectTo,
          scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
          queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
          skipBrowserRedirect: true
        });
        return await _request(this.fetch, "GET", url, {
          headers: this.headers,
          jwt: (_e = (_d = data2.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : void 0
        });
      });
      if (error)
        throw error;
      if (isBrowser() && !((_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.skipBrowserRedirect)) {
        window.location.assign(data === null || data === void 0 ? void 0 : data.url);
      }
      return { data: { provider: credentials.provider, url: data === null || data === void 0 ? void 0 : data.url }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { provider: credentials.provider, url: null }, error };
      }
      throw error;
    }
  }
  /**
   * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.
   */
  async unlinkIdentity(identity) {
    try {
      return await this._useSession(async (result) => {
        var _a2, _b;
        const { data, error } = result;
        if (error) {
          throw error;
        }
        return await _request(this.fetch, "DELETE", `${this.url}/user/identities/${identity.identity_id}`, {
          headers: this.headers,
          jwt: (_b = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b !== void 0 ? _b : void 0
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Generates a new JWT.
   * @param refreshToken A valid refresh token that was returned on login.
   */
  async _refreshAccessToken(refreshToken) {
    const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, "begin");
    try {
      const startedAt = Date.now();
      return await retryable(async (attempt) => {
        if (attempt > 0) {
          await sleep(200 * Math.pow(2, attempt - 1));
        }
        this._debug(debugName, "refreshing attempt", attempt);
        return await _request(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
          body: { refresh_token: refreshToken },
          headers: this.headers,
          xform: _sessionResponse
        });
      }, (attempt, error) => {
        const nextBackOffInterval = 200 * Math.pow(2, attempt);
        return error && isAuthRetryableFetchError(error) && // retryable only if the request can be sent before the backoff overflows the tick duration
        Date.now() + nextBackOffInterval - startedAt < AUTO_REFRESH_TICK_DURATION;
      });
    } catch (error) {
      this._debug(debugName, "error", error);
      if (isAuthError(error)) {
        return { data: { session: null, user: null }, error };
      }
      throw error;
    } finally {
      this._debug(debugName, "end");
    }
  }
  _isValidSession(maybeSession) {
    const isValidSession = typeof maybeSession === "object" && maybeSession !== null && "access_token" in maybeSession && "refresh_token" in maybeSession && "expires_at" in maybeSession;
    return isValidSession;
  }
  async _handleProviderSignIn(provider, options) {
    const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {
      redirectTo: options.redirectTo,
      scopes: options.scopes,
      queryParams: options.queryParams
    });
    this._debug("#_handleProviderSignIn()", "provider", provider, "options", options, "url", url);
    if (isBrowser() && !options.skipBrowserRedirect) {
      window.location.assign(url);
    }
    return { data: { provider, url }, error: null };
  }
  /**
   * Recovers the session from LocalStorage and refreshes the token
   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
   */
  async _recoverAndRefresh() {
    var _a2;
    const debugName = "#_recoverAndRefresh()";
    this._debug(debugName, "begin");
    try {
      const currentSession = await getItemAsync(this.storage, this.storageKey);
      this._debug(debugName, "session from storage", currentSession);
      if (!this._isValidSession(currentSession)) {
        this._debug(debugName, "session is not valid");
        if (currentSession !== null) {
          await this._removeSession();
        }
        return;
      }
      const timeNow = Math.round(Date.now() / 1e3);
      const expiresWithMargin = ((_a2 = currentSession.expires_at) !== null && _a2 !== void 0 ? _a2 : Infinity) < timeNow + EXPIRY_MARGIN;
      this._debug(debugName, `session has${expiresWithMargin ? "" : " not"} expired with margin of ${EXPIRY_MARGIN}s`);
      if (expiresWithMargin) {
        if (this.autoRefreshToken && currentSession.refresh_token) {
          const { error } = await this._callRefreshToken(currentSession.refresh_token);
          if (error) {
            console.error(error);
            if (!isAuthRetryableFetchError(error)) {
              this._debug(debugName, "refresh failed with a non-retryable error, removing the session", error);
              await this._removeSession();
            }
          }
        }
      } else {
        await this._notifyAllSubscribers("SIGNED_IN", currentSession);
      }
    } catch (err) {
      this._debug(debugName, "error", err);
      console.error(err);
      return;
    } finally {
      this._debug(debugName, "end");
    }
  }
  async _callRefreshToken(refreshToken) {
    var _a2, _b;
    if (!refreshToken) {
      throw new AuthSessionMissingError();
    }
    if (this.refreshingDeferred) {
      return this.refreshingDeferred.promise;
    }
    const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, "begin");
    try {
      this.refreshingDeferred = new Deferred();
      const { data, error } = await this._refreshAccessToken(refreshToken);
      if (error)
        throw error;
      if (!data.session)
        throw new AuthSessionMissingError();
      await this._saveSession(data.session);
      await this._notifyAllSubscribers("TOKEN_REFRESHED", data.session);
      const result = { session: data.session, error: null };
      this.refreshingDeferred.resolve(result);
      return result;
    } catch (error) {
      this._debug(debugName, "error", error);
      if (isAuthError(error)) {
        const result = { session: null, error };
        if (!isAuthRetryableFetchError(error)) {
          await this._removeSession();
        }
        (_a2 = this.refreshingDeferred) === null || _a2 === void 0 ? void 0 : _a2.resolve(result);
        return result;
      }
      (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);
      throw error;
    } finally {
      this.refreshingDeferred = null;
      this._debug(debugName, "end");
    }
  }
  async _notifyAllSubscribers(event, session, broadcast = true) {
    const debugName = `#_notifyAllSubscribers(${event})`;
    this._debug(debugName, "begin", session, `broadcast = ${broadcast}`);
    try {
      if (this.broadcastChannel && broadcast) {
        this.broadcastChannel.postMessage({ event, session });
      }
      const errors = [];
      const promises = Array.from(this.stateChangeEmitters.values()).map(async (x) => {
        try {
          await x.callback(event, session);
        } catch (e) {
          errors.push(e);
        }
      });
      await Promise.all(promises);
      if (errors.length > 0) {
        for (let i = 0; i < errors.length; i += 1) {
          console.error(errors[i]);
        }
        throw errors[0];
      }
    } finally {
      this._debug(debugName, "end");
    }
  }
  /**
   * set currentSession and currentUser
   * process to _startAutoRefreshToken if possible
   */
  async _saveSession(session) {
    this._debug("#_saveSession()", session);
    this.suppressGetSessionWarning = true;
    await setItemAsync(this.storage, this.storageKey, session);
  }
  async _removeSession() {
    this._debug("#_removeSession()");
    await removeItemAsync(this.storage, this.storageKey);
    await this._notifyAllSubscribers("SIGNED_OUT", null);
  }
  /**
   * Removes any registered visibilitychange callback.
   *
   * {@see #startAutoRefresh}
   * {@see #stopAutoRefresh}
   */
  _removeVisibilityChangedCallback() {
    this._debug("#_removeVisibilityChangedCallback()");
    const callback = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {
        window.removeEventListener("visibilitychange", callback);
      }
    } catch (e) {
      console.error("removing visibilitychange callback failed", e);
    }
  }
  /**
   * This is the private implementation of {@link #startAutoRefresh}. Use this
   * within the library.
   */
  async _startAutoRefresh() {
    await this._stopAutoRefresh();
    this._debug("#_startAutoRefresh()");
    const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION);
    this.autoRefreshTicker = ticker;
    if (ticker && typeof ticker === "object" && typeof ticker.unref === "function") {
      ticker.unref();
    } else if (typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function") {
      Deno.unrefTimer(ticker);
    }
    setTimeout(async () => {
      await this.initializePromise;
      await this._autoRefreshTokenTick();
    }, 0);
  }
  /**
   * This is the private implementation of {@link #stopAutoRefresh}. Use this
   * within the library.
   */
  async _stopAutoRefresh() {
    this._debug("#_stopAutoRefresh()");
    const ticker = this.autoRefreshTicker;
    this.autoRefreshTicker = null;
    if (ticker) {
      clearInterval(ticker);
    }
  }
  /**
   * Starts an auto-refresh process in the background. The session is checked
   * every few seconds. Close to the time of expiration a process is started to
   * refresh the session. If refreshing fails it will be retried for as long as
   * necessary.
   *
   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
   * to call this function, it will be called for you.
   *
   * On browsers the refresh process works only when the tab/window is in the
   * foreground to conserve resources as well as prevent race conditions and
   * flooding auth with requests. If you call this method any managed
   * visibility change callback will be removed and you must manage visibility
   * changes on your own.
   *
   * On non-browser platforms the refresh process works *continuously* in the
   * background, which may not be desirable. You should hook into your
   * platform's foreground indication mechanism and call these methods
   * appropriately to conserve resources.
   *
   * {@see #stopAutoRefresh}
   */
  async startAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._startAutoRefresh();
  }
  /**
   * Stops an active auto refresh process running in the background (if any).
   *
   * If you call this method any managed visibility change callback will be
   * removed and you must manage visibility changes on your own.
   *
   * See {@link #startAutoRefresh} for more details.
   */
  async stopAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._stopAutoRefresh();
  }
  /**
   * Runs the auto refresh token tick.
   */
  async _autoRefreshTokenTick() {
    this._debug("#_autoRefreshTokenTick()", "begin");
    try {
      await this._acquireLock(0, async () => {
        try {
          const now = Date.now();
          try {
            return await this._useSession(async (result) => {
              const { data: { session } } = result;
              if (!session || !session.refresh_token || !session.expires_at) {
                this._debug("#_autoRefreshTokenTick()", "no session");
                return;
              }
              const expiresInTicks = Math.floor((session.expires_at * 1e3 - now) / AUTO_REFRESH_TICK_DURATION);
              this._debug("#_autoRefreshTokenTick()", `access token expires in ${expiresInTicks} ticks, a tick lasts ${AUTO_REFRESH_TICK_DURATION}ms, refresh threshold is ${AUTO_REFRESH_TICK_THRESHOLD} ticks`);
              if (expiresInTicks <= AUTO_REFRESH_TICK_THRESHOLD) {
                await this._callRefreshToken(session.refresh_token);
              }
            });
          } catch (e) {
            console.error("Auto refresh tick failed with error. This is likely a transient error.", e);
          }
        } finally {
          this._debug("#_autoRefreshTokenTick()", "end");
        }
      });
    } catch (e) {
      if (e.isAcquireTimeout || e instanceof LockAcquireTimeoutError) {
        this._debug("auto refresh token tick lock not available");
      } else {
        throw e;
      }
    }
  }
  /**
   * Registers callbacks on the browser / platform, which in-turn run
   * algorithms when the browser window/tab are in foreground. On non-browser
   * platforms it assumes always foreground.
   */
  async _handleVisibilityChange() {
    this._debug("#_handleVisibilityChange()");
    if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
      if (this.autoRefreshToken) {
        this.startAutoRefresh();
      }
      return false;
    }
    try {
      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false);
      window === null || window === void 0 ? void 0 : window.addEventListener("visibilitychange", this.visibilityChangedCallback);
      await this._onVisibilityChanged(true);
    } catch (error) {
      console.error("_handleVisibilityChange", error);
    }
  }
  /**
   * Callback registered with `window.addEventListener('visibilitychange')`.
   */
  async _onVisibilityChanged(calledFromInitialize) {
    const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
    this._debug(methodName, "visibilityState", document.visibilityState);
    if (document.visibilityState === "visible") {
      if (this.autoRefreshToken) {
        this._startAutoRefresh();
      }
      if (!calledFromInitialize) {
        await this.initializePromise;
        await this._acquireLock(-1, async () => {
          if (document.visibilityState !== "visible") {
            this._debug(methodName, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
            return;
          }
          await this._recoverAndRefresh();
        });
      }
    } else if (document.visibilityState === "hidden") {
      if (this.autoRefreshToken) {
        this._stopAutoRefresh();
      }
    }
  }
  /**
   * Generates the relevant login URL for a third-party provider.
   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
   * @param options.scopes A space-separated list of scopes granted to the OAuth application.
   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
   */
  async _getUrlForProvider(url, provider, options) {
    const urlParams = [`provider=${encodeURIComponent(provider)}`];
    if (options === null || options === void 0 ? void 0 : options.redirectTo) {
      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
    }
    if (options === null || options === void 0 ? void 0 : options.scopes) {
      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
    }
    if (this.flowType === "pkce") {
      const [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
      const flowParams = new URLSearchParams({
        code_challenge: `${encodeURIComponent(codeChallenge)}`,
        code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`
      });
      urlParams.push(flowParams.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.queryParams) {
      const query = new URLSearchParams(options.queryParams);
      urlParams.push(query.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {
      urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);
    }
    return `${url}?${urlParams.join("&")}`;
  }
  async _unenroll(params) {
    try {
      return await this._useSession(async (result) => {
        var _a2;
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          return { data: null, error: sessionError };
        }
        return await _request(this.fetch, "DELETE", `${this.url}/factors/${params.factorId}`, {
          headers: this.headers,
          jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  async _enroll(params) {
    try {
      return await this._useSession(async (result) => {
        var _a2, _b;
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          return { data: null, error: sessionError };
        }
        const body = Object.assign({ friendly_name: params.friendlyName, factor_type: params.factorType }, params.factorType === "phone" ? { phone: params.phone } : { issuer: params.issuer });
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/factors`, {
          body,
          headers: this.headers,
          jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
        });
        if (error) {
          return { data: null, error };
        }
        if (params.factorType === "totp" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {
          data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;
        }
        return { data, error: null };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * {@see GoTrueMFAApi#verify}
   */
  async _verify(params) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (result) => {
          var _a2;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return { data: null, error: sessionError };
          }
          const { data, error } = await _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/verify`, {
            body: { code: params.code, challenge_id: params.challengeId },
            headers: this.headers,
            jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
          });
          if (error) {
            return { data: null, error };
          }
          await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + data.expires_in }, data));
          await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", data);
          return { data, error };
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challenge}
   */
  async _challenge(params) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (result) => {
          var _a2;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return { data: null, error: sessionError };
          }
          return await _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/challenge`, {
            body: { channel: params.channel },
            headers: this.headers,
            jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
          });
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challengeAndVerify}
   */
  async _challengeAndVerify(params) {
    const { data: challengeData, error: challengeError } = await this._challenge({
      factorId: params.factorId
    });
    if (challengeError) {
      return { data: null, error: challengeError };
    }
    return await this._verify({
      factorId: params.factorId,
      challengeId: challengeData.id,
      code: params.code
    });
  }
  /**
   * {@see GoTrueMFAApi#listFactors}
   */
  async _listFactors() {
    const { data: { user }, error: userError } = await this.getUser();
    if (userError) {
      return { data: null, error: userError };
    }
    const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];
    const totp = factors.filter((factor) => factor.factor_type === "totp" && factor.status === "verified");
    const phone = factors.filter((factor) => factor.factor_type === "phone" && factor.status === "verified");
    return {
      data: {
        all: factors,
        totp,
        phone
      },
      error: null
    };
  }
  /**
   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
   */
  async _getAuthenticatorAssuranceLevel() {
    return this._acquireLock(-1, async () => {
      return await this._useSession(async (result) => {
        var _a2, _b;
        const { data: { session }, error: sessionError } = result;
        if (sessionError) {
          return { data: null, error: sessionError };
        }
        if (!session) {
          return {
            data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },
            error: null
          };
        }
        const payload = this._decodeJWT(session.access_token);
        let currentLevel = null;
        if (payload.aal) {
          currentLevel = payload.aal;
        }
        let nextLevel = currentLevel;
        const verifiedFactors = (_b = (_a2 = session.user.factors) === null || _a2 === void 0 ? void 0 : _a2.filter((factor) => factor.status === "verified")) !== null && _b !== void 0 ? _b : [];
        if (verifiedFactors.length > 0) {
          nextLevel = "aal2";
        }
        const currentAuthenticationMethods = payload.amr || [];
        return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };
      });
    });
  }
};
GoTrueClient.nextInstanceID = 0;

// node_modules/@supabase/auth-js/dist/module/AuthClient.js
var AuthClient = GoTrueClient;
var AuthClient_default = AuthClient;

// node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js
var SupabaseAuthClient = class extends AuthClient_default {
  constructor(options) {
    super(options);
  }
};

// node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SupabaseClient = class {
  /**
   * Create a new client for use in the browser.
   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
   * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
   * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
   * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
   * @param options.realtime Options passed along to realtime-js constructor.
   * @param options.global.fetch A custom fetch implementation.
   * @param options.global.headers Any additional headers to send with each network request.
   */
  constructor(supabaseUrl, supabaseKey, options) {
    var _a2, _b, _c;
    this.supabaseUrl = supabaseUrl;
    this.supabaseKey = supabaseKey;
    if (!supabaseUrl)
      throw new Error("supabaseUrl is required.");
    if (!supabaseKey)
      throw new Error("supabaseKey is required.");
    const _supabaseUrl = stripTrailingSlash(supabaseUrl);
    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, "ws");
    this.authUrl = `${_supabaseUrl}/auth/v1`;
    this.storageUrl = `${_supabaseUrl}/storage/v1`;
    this.functionsUrl = `${_supabaseUrl}/functions/v1`;
    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split(".")[0]}-auth-token`;
    const DEFAULTS = {
      db: DEFAULT_DB_OPTIONS,
      realtime: DEFAULT_REALTIME_OPTIONS,
      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), { storageKey: defaultStorageKey }),
      global: DEFAULT_GLOBAL_OPTIONS
    };
    const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);
    this.storageKey = (_a2 = settings.auth.storageKey) !== null && _a2 !== void 0 ? _a2 : "";
    this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};
    if (!settings.accessToken) {
      this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);
    } else {
      this.accessToken = settings.accessToken;
      this.auth = new Proxy({}, {
        get: (_, prop) => {
          throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);
        }
      });
    }
    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);
    this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers, accessToken: this._getAccessToken.bind(this) }, settings.realtime));
    this.rest = new PostgrestClient(`${_supabaseUrl}/rest/v1`, {
      headers: this.headers,
      schema: settings.db.schema,
      fetch: this.fetch
    });
    if (!settings.accessToken) {
      this._listenForAuthEvents();
    }
  }
  /**
   * Supabase Functions allows you to deploy and invoke edge functions.
   */
  get functions() {
    return new FunctionsClient(this.functionsUrl, {
      headers: this.headers,
      customFetch: this.fetch
    });
  }
  /**
   * Supabase Storage allows you to manage user-generated content, such as photos or videos.
   */
  get storage() {
    return new StorageClient(this.storageUrl, this.headers, this.fetch);
  }
  /**
   * Perform a query on a table or a view.
   *
   * @param relation - The table or view name to query
   */
  from(relation) {
    return this.rest.from(relation);
  }
  // NOTE: signatures must be kept in sync with PostgrestClient.schema
  /**
   * Select a schema to query or perform an function (rpc) call.
   *
   * The schema needs to be on the list of exposed schemas inside Supabase.
   *
   * @param schema - The schema to query
   */
  schema(schema) {
    return this.rest.schema(schema);
  }
  // NOTE: signatures must be kept in sync with PostgrestClient.rpc
  /**
   * Perform a function call.
   *
   * @param fn - The function name to call
   * @param args - The arguments to pass to the function call
   * @param options - Named parameters
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   * @param options.get - When set to `true`, the function will be called with
   * read-only access mode.
   * @param options.count - Count algorithm to use to count rows returned by the
   * function. Only applicable for [set-returning
   * functions](https://www.postgresql.org/docs/current/functions-srf.html).
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  rpc(fn, args = {}, options = {}) {
    return this.rest.rpc(fn, args, options);
  }
  /**
   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
   *
   * @param {string} name - The name of the Realtime channel.
   * @param {Object} opts - The options to pass to the Realtime channel.
   *
   */
  channel(name, opts = { config: {} }) {
    return this.realtime.channel(name, opts);
  }
  /**
   * Returns all Realtime channels.
   */
  getChannels() {
    return this.realtime.getChannels();
  }
  /**
   * Unsubscribes and removes Realtime channel from Realtime client.
   *
   * @param {RealtimeChannel} channel - The name of the Realtime channel.
   *
   */
  removeChannel(channel) {
    return this.realtime.removeChannel(channel);
  }
  /**
   * Unsubscribes and removes all Realtime channels from Realtime client.
   */
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  _getAccessToken() {
    var _a2, _b;
    return __awaiter8(this, void 0, void 0, function* () {
      if (this.accessToken) {
        return yield this.accessToken();
      }
      const { data } = yield this.auth.getSession();
      return (_b = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b !== void 0 ? _b : null;
    });
  }
  _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, storageKey, flowType, lock, debug: debug2 }, headers, fetch4) {
    const authHeaders = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`
    };
    return new SupabaseAuthClient({
      url: this.authUrl,
      headers: Object.assign(Object.assign({}, authHeaders), headers),
      storageKey,
      autoRefreshToken,
      persistSession,
      detectSessionInUrl,
      storage,
      flowType,
      lock,
      debug: debug2,
      fetch: fetch4,
      // auth checks if there is a custom authorizaiton header using this flag
      // so it knows whether to return an error when getUser is called with no session
      hasCustomAuthorizationHeader: "Authorization" in this.headers
    });
  }
  _initRealtimeClient(options) {
    return new RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), { params: Object.assign({ apikey: this.supabaseKey }, options === null || options === void 0 ? void 0 : options.params) }));
  }
  _listenForAuthEvents() {
    let data = this.auth.onAuthStateChange((event, session) => {
      this._handleTokenChanged(event, "CLIENT", session === null || session === void 0 ? void 0 : session.access_token);
    });
    return data;
  }
  _handleTokenChanged(event, source, token) {
    if ((event === "TOKEN_REFRESHED" || event === "SIGNED_IN") && this.changedAccessToken !== token) {
      this.changedAccessToken = token;
    } else if (event === "SIGNED_OUT") {
      this.realtime.setAuth();
      if (source == "STORAGE")
        this.auth.signOut();
      this.changedAccessToken = void 0;
    }
  }
};

// node_modules/@supabase/supabase-js/dist/module/index.js
var createClient = (supabaseUrl, supabaseKey, options) => {
  return new SupabaseClient(supabaseUrl, supabaseKey, options);
};

// settings/Settings.ts
var DEFAULT_CHUNKING_OPTIONS = {
  chunkSize: 1e3,
  // Default size of each chunk in characters
  chunkOverlap: 200,
  // Default overlap between chunks
  minChunkSize: 100
  // Minimum chunk size to ensure usability
};
function generateDeviceId() {
  return crypto.randomUUID();
}
var SYSTEM_EXCLUSIONS = {
  folders: [
    ".obsidian",
    // Obsidian config folder
    ".trash",
    // Obsidian trash folder
    ".git",
    // Git folder if used
    "node_modules"
    // Node modules if used
  ],
  fileTypes: [
    ".mp3",
    ".jpg",
    ".png",
    ".pdf",
    // Non-markdown files
    ".excalidraw"
    // Excalidraw files
  ],
  filePrefixes: ["_", "."],
  // Hidden and special files
  files: [
    "_mindmatrixsync.md",
    // Sync file
    "_mindmatrixsync.md.backup"
    // Sync backup file
  ]
};
var DEFAULT_SETTINGS = {
  vaultId: null,
  lastKnownVaultName: "",
  supabase: {
    url: "",
    apiKey: "",
    initialized: false,
    lastSetupAttempt: 0,
    setupRetries: 0
  },
  openai: {
    apiKey: "",
    model: "text-embedding-ada-002",
    maxTokens: 8e3,
    temperature: 0
  },
  chunking: { ...DEFAULT_CHUNKING_OPTIONS },
  // Use default chunking options
  queue: {
    maxConcurrent: 3,
    retryAttempts: 3,
    retryDelay: 1e3
  },
  exclusions: {
    // User-facing exclusions (initially empty)
    excludedFolders: [],
    excludedFileTypes: [],
    excludedFilePrefixes: [],
    excludedFiles: [],
    // System exclusions (hidden from UI)
    systemExcludedFolders: [...SYSTEM_EXCLUSIONS.folders],
    systemExcludedFileTypes: [...SYSTEM_EXCLUSIONS.fileTypes],
    systemExcludedFilePrefixes: [...SYSTEM_EXCLUSIONS.filePrefixes],
    systemExcludedFiles: [...SYSTEM_EXCLUSIONS.files]
  },
  debug: {
    enableDebugLogs: false,
    logLevel: "info",
    logToFile: false
  },
  enableAutoSync: true,
  enableNotifications: true,
  enableProgressBar: true,
  sync: {
    syncFilePath: "_mindmatrixsync.md",
    backupInterval: 36e5,
    // 1 hour in milliseconds
    checkInterval: 3e5,
    // 5 minutes in milliseconds
    checkAttempts: 3,
    timeout: 4e4,
    requireSync: true,
    // New cross-device settings
    deviceId: generateDeviceId(),
    deviceName: `Device-${Math.floor(Math.random() * 1e3)}`,
    knownDevices: [],
    connectionCheckInterval: 6e4,
    // 1 minute
    offlineQueueEnabled: true,
    conflictResolutionStrategy: "newest-wins"
  },
  initialSync: {
    batchSize: 50,
    maxConcurrentBatches: 3,
    enableAutoInitialSync: true,
    priorityRules: [
      { pattern: "daily/", priority: 3 },
      { pattern: "projects/", priority: 2 },
      { pattern: "archive/", priority: 1 }
    ]
  }
};
function getAllExclusions(settings) {
  const exclusions = settings.exclusions;
  return {
    excludedFolders: [
      ...exclusions.systemExcludedFolders || SYSTEM_EXCLUSIONS.folders,
      ...exclusions.excludedFolders || []
    ],
    excludedFileTypes: [
      ...exclusions.systemExcludedFileTypes || SYSTEM_EXCLUSIONS.fileTypes,
      ...exclusions.excludedFileTypes || []
    ],
    excludedFilePrefixes: [
      ...exclusions.systemExcludedFilePrefixes || SYSTEM_EXCLUSIONS.filePrefixes,
      ...exclusions.excludedFilePrefixes || []
    ],
    excludedFiles: [
      ...exclusions.systemExcludedFiles || SYSTEM_EXCLUSIONS.files,
      ...exclusions.excludedFiles || []
    ]
  };
}
function getUserExclusions(settings) {
  const exclusions = settings.exclusions;
  return {
    excludedFolders: exclusions.excludedFolders || [],
    excludedFileTypes: exclusions.excludedFileTypes || [],
    excludedFilePrefixes: exclusions.excludedFilePrefixes || [],
    excludedFiles: exclusions.excludedFiles || []
  };
}
function isVaultInitialized(settings) {
  return settings.vaultId !== null && settings.vaultId !== void 0 && settings.vaultId !== "";
}
function generateVaultId() {
  return crypto.randomUUID();
}

// services/SupabaseService.ts
var import_obsidian = require("obsidian");
var _SupabaseService = class {
  // Table for tracking file status
  constructor(settings) {
    this.TABLE_NAME = "obsidian_documents";
    this.FILE_STATUS_TABLE = "obsidian_file_status";
    if (!settings.supabase.url || !settings.supabase.apiKey) {
      console.warn("Supabase configuration is incomplete. Supabase service will not be initialized.");
      this.client = null;
      return;
    }
    if (!isVaultInitialized(settings)) {
      throw new Error("Vault is not initialized");
    }
    this.settings = settings;
    this.client = createClient(settings.supabase.url, settings.supabase.apiKey);
  }
  static async getInstance(settings) {
    if (!settings.supabase.url || !settings.supabase.apiKey) {
      console.warn("Supabase configuration is incomplete. Returning null.");
      return null;
    }
    if (!_SupabaseService.instance) {
      _SupabaseService.instance = new _SupabaseService(settings);
      await _SupabaseService.instance.initializeDatabase();
    } else if (_SupabaseService.instance.settings.supabase.url !== settings.supabase.url || _SupabaseService.instance.settings.supabase.apiKey !== settings.supabase.apiKey || _SupabaseService.instance.settings.vaultId !== settings.vaultId) {
      _SupabaseService.instance = new _SupabaseService(settings);
      await _SupabaseService.instance.initializeDatabase();
    }
    return _SupabaseService.instance;
  }
  async initializeDatabase() {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping database initialization.");
      return;
    }
    try {
      new import_obsidian.Notice("Checking database connection...");
      const { error: testError } = await this.client.from(this.TABLE_NAME).select("id").limit(1);
      if (testError && !testError.message.includes("does not exist")) {
        throw new Error(`Database connection failed: ${testError.message}`);
      }
      await this.initializeFileStatusTable();
      new import_obsidian.Notice("Database connection verified");
      this.settings.supabase.initialized = true;
    } catch (error) {
      console.error("Database initialization error:", error);
      new import_obsidian.Notice(`Database error: ${error.message}`);
      throw error;
    }
  }
  /**
   * Ensures that obsidian_file_status table exists.
   */
  async initializeFileStatusTable() {
    if (!this.client)
      return;
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.log("File status table missing. Please create it manually or run setup SQL.");
        new import_obsidian.Notice("Some database tables are missing. Plugin will work with limited functionality.", 5e3);
      } else {
        console.log("File status table exists and is accessible");
      }
    } catch (error) {
      console.error("Error initializing file status table:", error);
      throw new Error(`Failed to initialize file status table: ${error.message}`);
    }
  }
  /**
   * Inserts or updates document chunks in the obsidian_documents table.
   */
  async upsertChunks(chunks) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping upsertChunks.");
      return;
    }
    try {
      if (chunks.length === 0) {
        console.log("No chunks to upsert");
        return;
      }
      const obsidianId = chunks[0].metadata.obsidianId;
      const { error: deleteError } = await this.client.from(this.TABLE_NAME).delete().eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
      if (deleteError) {
        console.error("Error deleting existing chunks:", deleteError);
        throw deleteError;
      }
      const chunksToInsert = chunks.map((chunk) => ({
        vault_id: this.settings.vaultId,
        obsidian_id: chunk.metadata.obsidianId,
        chunk_index: chunk.chunkIndex,
        content: chunk.content,
        metadata: chunk.metadata,
        embedding: chunk.embedding,
        last_updated: new Date().toISOString(),
        vectorized_at: new Date().toISOString()
      }));
      const { error: insertError } = await this.client.from(this.TABLE_NAME).insert(chunksToInsert);
      if (insertError) {
        console.error("Error inserting new chunks:", insertError);
        throw insertError;
      }
      await this.updateFileVectorizationStatus(chunks[0].metadata);
      console.log("Successfully updated chunks:", {
        numberOfChunks: chunks.length,
        vaultId: this.settings.vaultId,
        obsidianId
      });
    } catch (error) {
      console.error("Failed to upsert chunks:", error);
      throw error;
    }
  }
  /**
   * Bulk upsert method for file status records.
   * Improves performance for large vaults.
   */
  async bulkUpsertFileStatuses(statuses) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping bulkUpsertFileStatuses.");
      return;
    }
    try {
      if (statuses.length === 0)
        return;
      const { error } = await this.client.from(this.FILE_STATUS_TABLE).upsert(statuses, { onConflict: "vault_id,file_path" });
      if (error) {
        console.error("Error during bulk upsert of file statuses:", error);
        throw error;
      }
      console.log(`Bulk upsert of ${statuses.length} file statuses successful.`);
    } catch (error) {
      console.error("Failed to bulk upsert file statuses:", error);
      throw error;
    }
  }
  /**
   * Creates or updates a record in the obsidian_file_status table
   * to reflect the latest file status using provided metadata.
   */
  async updateFileVectorizationStatus(metadata) {
    var _a2, _b;
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping updateFileVectorizationStatus.");
      return;
    }
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Skipping status update.");
        return;
      }
      const fileStatus = {
        vault_id: this.settings.vaultId,
        file_path: metadata.obsidianId,
        last_modified: metadata.lastModified,
        last_vectorized: new Date().toISOString(),
        content_hash: ((_a2 = metadata.customMetadata) == null ? void 0 : _a2.contentHash) || "",
        status: "PENDING",
        tags: metadata.tags || [],
        aliases: ((_b = metadata.customMetadata) == null ? void 0 : _b.aliases) || [],
        links: metadata.links || [],
        updated_at: new Date().toISOString()
      };
      const { error } = await this.client.from(this.FILE_STATUS_TABLE).upsert(fileStatus, { onConflict: "vault_id,file_path" });
      if (error) {
        console.error("Error updating file vectorization status:", error);
        throw error;
      }
      console.log("File vectorization status updated:", metadata.obsidianId);
    } catch (error) {
      console.error("Failed to update file vectorization status:", error);
    }
  }
  /**
   * Marks a file as deleted in the obsidian_file_status table.
   */
  async updateFileStatusOnDelete(filePath) {
    if (!this.client)
      return;
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Skipping status update on delete.");
        return;
      }
      const { error } = await this.client.from(this.FILE_STATUS_TABLE).update({
        status: "deleted",
        updated_at: new Date().toISOString()
      }).eq("vault_id", this.settings.vaultId).eq("file_path", filePath);
      if (error) {
        console.error("Error updating file status on delete:", error);
        throw error;
      }
    } catch (error) {
      console.error("Failed to update file status on delete:", error);
    }
  }
  /**
   * Deletes document chunks for a given obsidianId from the obsidian_documents table.
   */
  async deleteDocumentChunks(obsidianId) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping deleteDocumentChunks.");
      return;
    }
    try {
      const { error } = await this.client.from(this.TABLE_NAME).delete().eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
      if (error)
        throw error;
      await this.updateFileStatusOnDelete(obsidianId);
    } catch (error) {
      console.error("Failed to delete chunks:", error);
      throw error;
    }
  }
  /**
   * Retrieves document chunks for a given obsidianId.
   */
  async getDocumentChunks(obsidianId) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping getDocumentChunks.");
      return [];
    }
    try {
      const { data, error } = await this.client.from(this.TABLE_NAME).select("*").eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId).order("chunk_index");
      if (error)
        throw error;
      return data.map((row) => ({
        content: row.content,
        chunkIndex: row.chunk_index,
        metadata: row.metadata,
        embedding: row.embedding,
        vectorized_at: row.vectorized_at
      }));
    } catch (error) {
      console.error("Failed to get chunks:", error);
      throw error;
    }
  }
  /**
   * Checks if a file has been vectorized based on the obsidian_file_status table.
   */
  async isFileVectorized(filePath) {
    if (!this.client)
      return false;
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Assuming file is not vectorized.");
        return false;
      }
      const { data, error } = await this.client.from(this.FILE_STATUS_TABLE).select("status, last_vectorized").eq("vault_id", this.settings.vaultId).eq("file_path", filePath).single();
      if (error) {
        if (error.code === "PGRST116") {
          return false;
        }
        throw error;
      }
      return data && data.status === "vectorized" && !!data.last_vectorized;
    } catch (error) {
      console.error("Failed to check if file is vectorized:", error);
      return false;
    }
  }
  /**
   * Retrieves the vectorization status of a file from the database.
   */
  async getFileVectorizationStatus(filePath) {
    if (!this.client) {
      return {
        isVectorized: false,
        lastModified: 0,
        lastVectorized: null,
        contentHash: null,
        status: null
      };
    }
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Returning default status.");
        return {
          isVectorized: false,
          lastModified: 0,
          lastVectorized: null,
          contentHash: null,
          status: null
        };
      }
      const { data, error } = await this.client.from(this.FILE_STATUS_TABLE).select("*").eq("vault_id", this.settings.vaultId).eq("file_path", filePath).single();
      if (error) {
        if (error.code === "PGRST116") {
          return {
            isVectorized: false,
            lastModified: 0,
            lastVectorized: null,
            contentHash: null,
            status: null
          };
        }
        throw error;
      }
      return {
        isVectorized: data.status === "vectorized",
        lastModified: data.last_modified,
        lastVectorized: data.last_vectorized,
        contentHash: data.content_hash,
        status: data.status
      };
    } catch (error) {
      console.error("Failed to get file vectorization status:", error);
      return {
        isVectorized: false,
        lastModified: 0,
        lastVectorized: null,
        contentHash: null,
        status: null
      };
    }
  }
  /**
   * Determines if a file needs vectorizing based on last_modified and content_hash.
   */
  async needsVectorizing(filePath, lastModified, contentHash) {
    if (!this.client)
      return true;
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Assuming file needs vectorizing.");
        return true;
      }
      const status = await this.getFileVectorizationStatus(filePath);
      if (!status.status) {
        return true;
      }
      if (status.contentHash !== contentHash) {
        return true;
      }
      if (lastModified > status.lastModified) {
        return true;
      }
      return false;
    } catch (error) {
      console.error("Failed to check if file needs vectorizing:", error);
      return true;
    }
  }
  /**
   * Retrieves all files that do not have a status of 'vectorized' in the database.
   */
  async getFilesNeedingVectorization() {
    if (!this.client)
      return [];
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Unable to determine files needing vectorization.");
        return [];
      }
      const { data, error } = await this.client.from(this.FILE_STATUS_TABLE).select("file_path").eq("vault_id", this.settings.vaultId).not("status", "eq", "vectorized");
      if (error)
        throw error;
      return data.map((row) => row.file_path);
    } catch (error) {
      console.error("Failed to get files needing vectorization:", error);
      return [];
    }
  }
  /**
   * Performs a semantic search using the match_documents function.
   */
  async semanticSearch(embedding, limit2 = 5) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping semanticSearch.");
      return [];
    }
    try {
      const { data, error } = await this.client.rpc("match_documents", {
        query_embedding: embedding,
        search_vault_id: this.settings.vaultId,
        match_count: limit2
      });
      if (error)
        throw error;
      return data.map((row) => ({
        content: row.content,
        metadata: row.metadata,
        similarity: row.similarity
      }));
    } catch (error) {
      console.error("Failed to perform semantic search:", error);
      throw error;
    }
  }
  /**
   * Tests the connection by selecting from the obsidian_documents table.
   */
  async testConnection() {
    if (!this.client)
      return false;
    try {
      const { error } = await this.client.from(this.TABLE_NAME).select("id").limit(1);
      if (error && error.message && error.message.includes("does not exist")) {
        return true;
      }
      return !error;
    } catch (e) {
      return false;
    }
  }
  /**
   * Returns all unique obsidian_ids from the obsidian_documents table for the current vault.
   */
  async getAllDocumentIds() {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping getAllDocumentIds.");
      return [];
    }
    try {
      const { data, error } = await this.client.from(this.TABLE_NAME).select("obsidian_id").eq("vault_id", this.settings.vaultId).distinct();
      if (error) {
        if (error.message.includes("does not exist")) {
          return [];
        }
        throw error;
      }
      return data.map((row) => row.obsidian_id);
    } catch (error) {
      console.error("Failed to get document IDs:", error);
      throw error;
    }
  }
  /**
   * Creates the required database tables if needed (manual invocation).
   */
  async createRequiredTables() {
    if (!this.client) {
      return {
        success: false,
        message: "Supabase client not initialized"
      };
    }
    try {
      const createFileStatusTableSQL = `
				CREATE TABLE IF NOT EXISTS ${this.FILE_STATUS_TABLE} (
					id BIGSERIAL PRIMARY KEY,
					vault_id TEXT NOT NULL,
					file_path TEXT NOT NULL,
					last_modified BIGINT NOT NULL,
					last_vectorized TIMESTAMPTZ,
					content_hash TEXT,
					status TEXT,
					tags TEXT[],
					aliases TEXT[],
					links TEXT[],
					created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
					updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
					UNIQUE(vault_id, file_path)
				);
				CREATE INDEX IF NOT EXISTS idx_file_status_vault_path ON ${this.FILE_STATUS_TABLE}(vault_id, file_path);
			`;
      const { error } = await this.client.rpc("run_sql", { sql: createFileStatusTableSQL });
      if (error) {
        return { success: false, message: `Could not create tables: ${error.message}` };
      }
      return { success: true, message: "Tables created successfully" };
    } catch (error) {
      return { success: false, message: `Error creating tables: ${error.message}` };
    }
  }
};
var SupabaseService = _SupabaseService;
SupabaseService.instance = null;

// node_modules/openai/internal/qs/formats.mjs
var default_format = "RFC3986";
var formatters = {
  RFC1738: (v) => String(v).replace(/%20/g, "+"),
  RFC3986: (v) => String(v)
};
var RFC1738 = "RFC1738";

// node_modules/openai/internal/qs/utils.mjs
var is_array = Array.isArray;
var hex_table = (() => {
  const array = [];
  for (let i = 0; i < 256; ++i) {
    array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array;
})();
var limit = 1024;
var encode = (str2, _defaultEncoder, charset, _kind, format) => {
  if (str2.length === 0) {
    return str2;
  }
  let string = str2;
  if (typeof str2 === "symbol") {
    string = Symbol.prototype.toString.call(str2);
  } else if (typeof str2 !== "string") {
    string = String(str2);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  let out = "";
  for (let j = 0; j < string.length; j += limit) {
    const segment = string.length >= limit ? string.slice(j, j + limit) : string;
    const arr = [];
    for (let i = 0; i < segment.length; ++i) {
      let c = segment.charCodeAt(i);
      if (c === 45 || // -
      c === 46 || // .
      c === 95 || // _
      c === 126 || // ~
      c >= 48 && c <= 57 || // 0-9
      c >= 65 && c <= 90 || // a-z
      c >= 97 && c <= 122 || // A-Z
      format === RFC1738 && (c === 40 || c === 41)) {
        arr[arr.length] = segment.charAt(i);
        continue;
      }
      if (c < 128) {
        arr[arr.length] = hex_table[c];
        continue;
      }
      if (c < 2048) {
        arr[arr.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        arr[arr.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
      arr[arr.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
    }
    out += arr.join("");
  }
  return out;
};
function is_buffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn) {
  if (is_array(val)) {
    const mapped = [];
    for (let i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
}

// node_modules/openai/internal/qs/stringify.mjs
var has = Object.prototype.hasOwnProperty;
var array_prefix_generators = {
  brackets(prefix) {
    return String(prefix) + "[]";
  },
  comma: "comma",
  indices(prefix, key) {
    return String(prefix) + "[" + key + "]";
  },
  repeat(prefix) {
    return String(prefix);
  }
};
var is_array2 = Array.isArray;
var push = Array.prototype.push;
var push_to_array = function(arr, value_or_array) {
  push.apply(arr, is_array2(value_or_array) ? value_or_array : [value_or_array]);
};
var to_ISO = Date.prototype.toISOString;
var defaults = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: encode,
  encodeValuesOnly: false,
  format: default_format,
  formatter: formatters[default_format],
  /** @deprecated */
  indices: false,
  serializeDate(date) {
    return to_ISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
function is_non_nullish_primitive(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
}
var sentinel = {};
function inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
  let obj = object;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
    const pos = tmp_sc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate == null ? void 0 : serializeDate(obj);
  } else if (generateArrayPrefix === "comma" && is_array2(obj)) {
    obj = maybe_map(obj, function(value) {
      if (value instanceof Date) {
        return serializeDate == null ? void 0 : serializeDate(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? (
        // @ts-expect-error
        encoder(prefix, defaults.encoder, charset, "key", format)
      ) : prefix;
    }
    obj = "";
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder) {
      const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
      return [
        (formatter == null ? void 0 : formatter(key_value)) + "=" + // @ts-expect-error
        (formatter == null ? void 0 : formatter(encoder(obj, defaults.encoder, charset, "value", format)))
      ];
    }
    return [(formatter == null ? void 0 : formatter(prefix)) + "=" + (formatter == null ? void 0 : formatter(String(obj)))];
  }
  const values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && is_array2(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = maybe_map(obj, encoder);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (is_array2(filter)) {
    obj_keys = filter;
  } else {
    const keys = Object.keys(obj);
    obj_keys = sort ? keys.sort(sort) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && is_array2(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && is_array2(obj) && obj.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j = 0; j < obj_keys.length; ++j) {
    const key = obj_keys[j];
    const value = (
      // @ts-ignore
      typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
    );
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = is_array2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel.set(object, step);
    const valueSideChannel = /* @__PURE__ */ new WeakMap();
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(values, inner_stringify(
      value,
      key_prefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      // @ts-ignore
      generateArrayPrefix === "comma" && encodeValuesOnly && is_array2(obj) ? null : encoder,
      filter,
      sort,
      allowDots,
      serializeDate,
      format,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
}
function normalize_stringify_options(opts = defaults) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset = opts.charset || defaults.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has.call(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format = opts.format;
  }
  const formatter = formatters[format];
  let filter = defaults.filter;
  if (typeof opts.filter === "function" || is_array2(opts.filter)) {
    filter = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
    // @ts-ignore
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter,
    format,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
    // @ts-ignore
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
}
function stringify(object, opts = {}) {
  let obj = object;
  const options = normalize_stringify_options(opts);
  let obj_keys;
  let filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (is_array2(options.filter)) {
    filter = options.filter;
    obj_keys = filter;
  }
  const keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options.sort) {
    obj_keys.sort(options.sort);
  }
  const sideChannel = /* @__PURE__ */ new WeakMap();
  for (let i = 0; i < obj_keys.length; ++i) {
    const key = obj_keys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    push_to_array(keys, inner_stringify(
      obj[key],
      key,
      // @ts-expect-error
      generateArrayPrefix,
      commaRoundTrip,
      options.allowEmptyArrays,
      options.strictNullHandling,
      options.skipNulls,
      options.encodeDotInKeys,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel
    ));
  }
  const joined = keys.join(options.delimiter);
  let prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}

// node_modules/openai/version.mjs
var VERSION = "4.79.1";

// node_modules/openai/_shims/registry.mjs
var auto = false;
var kind = void 0;
var fetch3 = void 0;
var Request3 = void 0;
var Response3 = void 0;
var Headers3 = void 0;
var FormData2 = void 0;
var Blob2 = void 0;
var File2 = void 0;
var ReadableStream2 = void 0;
var getMultipartRequestOptions = void 0;
var getDefaultAgent = void 0;
var fileFromPath = void 0;
var isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
  }
  if (kind) {
    throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch3 = shims.fetch;
  Request3 = shims.Request;
  Response3 = shims.Response;
  Headers3 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}

// node_modules/openai/_shims/MultipartBody.mjs
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// node_modules/openai/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import \u2026 from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}

// node_modules/openai/_shims/index.mjs
if (!kind)
  setShims(getRuntime(), { auto: true });

// node_modules/openai/error.mjs
var OpenAIError = class extends Error {
};
var APIError = class extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.request_id = headers == null ? void 0 : headers["x-request-id"];
    this.error = error;
    const data = error;
    this.code = data == null ? void 0 : data["code"];
    this.param = data == null ? void 0 : data["param"];
    this.type = data == null ? void 0 : data["type"];
  }
  static makeMessage(status, error, message) {
    const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error = errorResponse == null ? void 0 : errorResponse["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message != null ? message : "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
};
var AuthenticationError = class extends APIError {
};
var PermissionDeniedError = class extends APIError {
};
var NotFoundError = class extends APIError {
};
var ConflictError = class extends APIError {
};
var UnprocessableEntityError = class extends APIError {
};
var RateLimitError = class extends APIError {
};
var InternalServerError = class extends APIError {
};
var LengthFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the length limit was reached`);
  }
};
var ContentFilterFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the request was rejected by the content filter`);
  }
};

// node_modules/openai/internal/decoders/line.mjs
var LineDecoder = class {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);
    if (trailingNewline) {
      lines.pop();
    }
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    var _a2;
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        (_a2 = this.textDecoder) != null ? _a2 : this.textDecoder = new TextDecoder("utf8");
        return this.textDecoder.decode(bytes);
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;

// node_modules/openai/streaming.mjs
var Stream = class {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError(void 0, data.error, void 0, void 0);
            }
            yield data;
          } else {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (sse.event == "error") {
              throw new APIError(void 0, data.error, data.message, void 0);
            }
            yield { event: sse.event, data };
          }
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = readableStreamAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new Stream(() => teeIterator(left), this.controller),
      new Stream(() => teeIterator(right), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self2 = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream2({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a2;
        await ((_a2 = iter.return) == null ? void 0 : _a2.call(iter));
      }
    });
  }
};
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = readableStreamAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 2; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition(str2, delimiter) {
  const index2 = str2.indexOf(delimiter);
  if (index2 !== -1) {
    return [str2.substring(0, index2), delimiter, str2.substring(index2 + delimiter.length)];
  }
  return [str2, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/openai/uploads.mjs
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isUploadable = (value) => {
  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};
async function toFile(value, name, options) {
  var _a2, _b, _c;
  value = await value;
  if (isFileLike(value)) {
    return value;
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = (_a2 = new URL(value.url).pathname.split(/[\\/]/).pop()) != null ? _a2 : "unknown_file");
    const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];
    return new File2(data, name, options);
  }
  const bits = await getBytes(value);
  name || (name = (_b = getName(value)) != null ? _b : "unknown_file");
  if (!(options == null ? void 0 : options.type)) {
    const type = (_c = bits[0]) == null ? void 0 : _c.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes(value) {
  var _a2;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a2 = value == null ? void 0 : value.constructor) == null ? void 0 : _a2.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a2;
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  ((_a2 = getStringFromMaybeBuffer(value.path)) == null ? void 0 : _a2.split(/[\\/]/).pop());
}
var getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return void 0;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
var createForm = async (body) => {
  const form = new FormData2();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/openai/core.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const isJSON = (contentType == null ? void 0 : contentType.includes("application/json")) || (contentType == null ? void 0 : contentType.includes("application/vnd.api+json"));
  if (isJSON) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return _addRequestID(json, response);
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
function _addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("x-request-id"),
    enumerable: false
  });
}
var APIPromise = class extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("x-request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 6e5,
    // 10 minutes
    httpAgent,
    fetch: overriddenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overriddenFetch != null ? overriddenFetch : fetch3;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then(async (opts2) => {
      const body = opts2 && isBlobLike(opts2 == null ? void 0 : opts2.body) ? new DataView(await opts2.body.arrayBuffer()) : (opts2 == null ? void 0 : opts2.body) instanceof DataView ? opts2.body : (opts2 == null ? void 0 : opts2.body) instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2 == null ? void 0 : opts2.body) ? new DataView(opts2.body.buffer) : opts2 == null ? void 0 : opts2.body;
      return { method, path, ...opts2, body };
    }));
  }
  getAPIList(path, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    } else if (ArrayBuffer.isView(body)) {
      return body.byteLength.toString();
    }
    return null;
  }
  buildRequest(options, { retryCount = 0 } = {}) {
    var _a2, _b, _c, _d, _e, _f;
    const { method, path, query, headers = {} } = options;
    const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    const timeout = (_a2 = options.timeout) != null ? _a2 : this.timeout;
    const httpAgent = (_c = (_b = options.httpAgent) != null ? _b : this.httpAgent) != null ? _c : getDefaultAgent(url);
    const minAgentTimeout = timeout + 1e3;
    if (typeof ((_d = httpAgent == null ? void 0 : httpAgent.options) == null ? void 0 : _d.timeout) === "number" && minAgentTimeout > ((_e = httpAgent.options.timeout) != null ? _e : 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: (_f = options.signal) != null ? _f : null
    };
    return { req, url, timeout };
  }
  buildHeaders({ options, headers, contentLength, retryCount }) {
    const reqHeaders = {};
    if (contentLength) {
      reqHeaders["content-length"] = contentLength;
    }
    const defaultHeaders = this.defaultHeaders(options);
    applyHeadersMut(reqHeaders, defaultHeaders);
    applyHeadersMut(reqHeaders, headers);
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["content-type"];
    }
    if (getHeader(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader(headers, "x-stainless-retry-count") === void 0) {
      reqHeaders["x-stainless-retry-count"] = String(retryCount);
    }
    this.validateHeaders(reqHeaders, headers);
    return reqHeaders;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    var _a2, _b, _c;
    const options = await optionsInput;
    const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if ((_b = options.signal) == null ? void 0 : _b.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if ((_c = options.signal) == null ? void 0 : _c.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e) => castToError(e).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page2);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const fetchOptions = {
      signal: controller.signal,
      ...options
    };
    if (fetchOptions.method) {
      fetchOptions.method = fetchOptions.method.toUpperCase();
    }
    return (
      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
      this.fetch.call(void 0, url, fetchOptions).finally(() => {
        clearTimeout(timeout);
      })
    );
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    var _a2;
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after-ms"];
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after"];
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep2(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
};
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo && typeof nextOptions.query === "object") {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page2) {
    super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
var requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true,
  __binaryRequest: true,
  __binaryResponse: true,
  __streamClass: true
};
var isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
};
var getPlatformProperties = () => {
  var _a2, _b;
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : (_b = (_a2 = Deno.version) == null ? void 0 : _a2.deno) != null ? _b : "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders != null ? _platformHeaders : _platformHeaders = getPlatformProperties();
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep2 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      return new Error(JSON.stringify(err));
    } catch (e) {
    }
  }
  return new Error(err);
};
var readEnv = (env) => {
  var _a2, _b, _c, _d, _e, _f;
  if (typeof process !== "undefined") {
    return (_c = (_b = (_a2 = process.env) == null ? void 0 : _a2[env]) == null ? void 0 : _b.trim()) != null ? _c : void 0;
  }
  if (typeof Deno !== "undefined") {
    return (_f = (_e = (_d = Deno.env) == null ? void 0 : _d.get) == null ? void 0 : _e.call(_d, env)) == null ? void 0 : _f.trim();
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k in newHeaders) {
    if (!hasOwn(newHeaders, k))
      continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
var SENSITIVE_HEADERS = /* @__PURE__ */ new Set(["authorization", "api-key"]);
function debug(action, ...args) {
  var _a2;
  if (typeof process !== "undefined" && ((_a2 = process == null ? void 0 : process.env) == null ? void 0 : _a2["DEBUG"]) === "true") {
    const modifiedArgs = args.map((arg) => {
      if (!arg) {
        return arg;
      }
      if (arg["headers"]) {
        const modifiedArg2 = { ...arg, headers: { ...arg["headers"] } };
        for (const header in arg["headers"]) {
          if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
            modifiedArg2["headers"][header] = "REDACTED";
          }
        }
        return modifiedArg2;
      }
      let modifiedArg = null;
      for (const header in arg) {
        if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
          modifiedArg != null ? modifiedArg : modifiedArg = { ...arg };
          modifiedArg[header] = "REDACTED";
        }
      }
      return modifiedArg != null ? modifiedArg : arg;
    });
    console.log(`OpenAI:DEBUG:${action}`, ...modifiedArgs);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
var isHeadersProtocol = (headers) => {
  return typeof (headers == null ? void 0 : headers.get) === "function";
};
var getHeader = (headers, header) => {
  var _a2;
  const lowerCasedHeader = header.toLowerCase();
  if (isHeadersProtocol(headers)) {
    const intercapsHeader = ((_a2 = header[0]) == null ? void 0 : _a2.toUpperCase()) + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
      const value = headers.get(key);
      if (value) {
        return value;
      }
    }
  }
  for (const [key, value] of Object.entries(headers)) {
    if (key.toLowerCase() === lowerCasedHeader) {
      if (Array.isArray(value)) {
        if (value.length <= 1)
          return value[0];
        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
        return value[0];
      }
      return value;
    }
  }
  return void 0;
};
function isObj(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj);
}

// node_modules/openai/pagination.mjs
var Page = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    var _a2;
    return (_a2 = this.data) != null ? _a2 : [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
};
var CursorPage = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
  }
  getPaginatedItems() {
    var _a2;
    return (_a2 = this.data) != null ? _a2 : [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info)
      return null;
    if ("params" in info)
      return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    var _a2;
    const data = this.getPaginatedItems();
    if (!data.length) {
      return null;
    }
    const id = (_a2 = data[data.length - 1]) == null ? void 0 : _a2.id;
    if (!id) {
      return null;
    }
    return { params: { after: id } };
  }
};

// node_modules/openai/resource.mjs
var APIResource = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/openai/resources/chat/completions.mjs
var Completions = class extends APIResource {
  create(body, options) {
    var _a2;
    return this._client.post("/chat/completions", { body, ...options, stream: (_a2 = body.stream) != null ? _a2 : false });
  }
};

// node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this._client);
  }
};
Chat.Completions = Completions;

// node_modules/openai/resources/audio/speech.mjs
var Speech = class extends APIResource {
  /**
   * Generates audio from the input text.
   */
  create(body, options) {
    return this._client.post("/audio/speech", {
      body,
      ...options,
      headers: { Accept: "application/octet-stream", ...options == null ? void 0 : options.headers },
      __binaryResponse: true
    });
  }
};

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource {
  create(body, options) {
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions({ body, ...options }));
  }
};

// node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource {
  create(body, options) {
    return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options }));
  }
};

// node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
};
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;
Audio.Speech = Speech;

// node_modules/openai/resources/batches.mjs
var Batches = class extends APIResource {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(body, options) {
    return this._client.post("/batches", { body, ...options });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(batchId, options) {
    return this._client.get(`/batches/${batchId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/batches", BatchesPage, { query, ...options });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(batchId, options) {
    return this._client.post(`/batches/${batchId}/cancel`, options);
  }
};
var BatchesPage = class extends CursorPage {
};
Batches.BatchesPage = BatchesPage;

// node_modules/openai/resources/beta/assistants.mjs
var Assistants = class extends APIResource {
  /**
   * Create an assistant with a model and instructions.
   */
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves an assistant.
   */
  retrieve(assistantId, options) {
    return this._client.get(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies an assistant.
   */
  update(assistantId, body, options) {
    return this._client.post(`/assistants/${assistantId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/assistants", AssistantsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete an assistant.
   */
  del(assistantId, options) {
    return this._client.delete(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};
var AssistantsPage = class extends CursorPage {
};
Assistants.AssistantsPage = AssistantsPage;

// node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}

// node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage = (message) => {
  return (message == null ? void 0 : message.role) === "assistant";
};
var isFunctionMessage = (message) => {
  return (message == null ? void 0 : message.role) === "function";
};
var isToolMessage = (message) => {
  return (message == null ? void 0 : message.role) === "tool";
};

// node_modules/openai/lib/EventStream.mjs
var __classPrivateFieldSet2 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EventStream_instances;
var _EventStream_connectedPromise;
var _EventStream_resolveConnectedPromise;
var _EventStream_rejectConnectedPromise;
var _EventStream_endPromise;
var _EventStream_resolveEndPromise;
var _EventStream_rejectEndPromise;
var _EventStream_listeners;
var _EventStream_ended;
var _EventStream_errored;
var _EventStream_aborted;
var _EventStream_catchingPromiseCreated;
var _EventStream_handleError;
var EventStream = class {
  constructor() {
    _EventStream_instances.add(this);
    this.controller = new AbortController();
    _EventStream_connectedPromise.set(this, void 0);
    _EventStream_resolveConnectedPromise.set(this, () => {
    });
    _EventStream_rejectConnectedPromise.set(this, () => {
    });
    _EventStream_endPromise.set(this, void 0);
    _EventStream_resolveEndPromise.set(this, () => {
    });
    _EventStream_rejectEndPromise.set(this, () => {
    });
    _EventStream_listeners.set(this, {});
    _EventStream_ended.set(this, false);
    _EventStream_errored.set(this, false);
    _EventStream_aborted.set(this, false);
    _EventStream_catchingPromiseCreated.set(this, false);
    __classPrivateFieldSet2(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _EventStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet2(this, _EventStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet2(this, _EventStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _EventStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet2(this, _EventStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet2(this, _EventStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet2(this, _EventStream_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet2(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
    }, 0);
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet2(this, _EventStream_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet2(this, _EventStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet2(this, _EventStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet2(this, _EventStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index2 = listeners.findIndex((l) => l.listener === listener);
    if (index2 >= 0)
      listeners.splice(index2, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _EventStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet2(this, _EventStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet2(this, _EventStream_endPromise, "f");
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet2(this, _EventStream_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet2(this, _EventStream_ended, true, "f");
      __classPrivateFieldGet2(this, _EventStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
  }
};
_EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error) {
  __classPrivateFieldSet2(this, _EventStream_errored, true, "f");
  if (error instanceof Error && error.name === "AbortError") {
    error = new APIUserAbortError();
  }
  if (error instanceof APIUserAbortError) {
    __classPrivateFieldSet2(this, _EventStream_aborted, true, "f");
    return this._emit("abort", error);
  }
  if (error instanceof OpenAIError) {
    return this._emit("error", error);
  }
  if (error instanceof Error) {
    const openAIError = new OpenAIError(error.message);
    openAIError.cause = error;
    return this._emit("error", openAIError);
  }
  return this._emit("error", new OpenAIError(String(error)));
};

// node_modules/openai/lib/parser.mjs
function isAutoParsableResponseFormat(response_format) {
  return (response_format == null ? void 0 : response_format["$brand"]) === "auto-parseable-response-format";
}
function isAutoParsableTool(tool) {
  return (tool == null ? void 0 : tool["$brand"]) === "auto-parseable-tool";
}
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => {
        var _a2;
        return {
          ...choice,
          message: { ...choice.message, parsed: null, tool_calls: (_a2 = choice.message.tool_calls) != null ? _a2 : [] }
        };
      })
    };
  }
  return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    var _a2, _b;
    if (choice.finish_reason === "length") {
      throw new LengthFinishReasonError();
    }
    if (choice.finish_reason === "content_filter") {
      throw new ContentFilterFinishReasonError();
    }
    return {
      ...choice,
      message: {
        ...choice.message,
        tool_calls: (_b = (_a2 = choice.message.tool_calls) == null ? void 0 : _a2.map((toolCall) => parseToolCall(params, toolCall))) != null ? _b : [],
        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
      }
    };
  });
  return { ...completion, choices };
}
function parseResponseFormat(params, content) {
  var _a2, _b;
  if (((_a2 = params.response_format) == null ? void 0 : _a2.type) !== "json_schema") {
    return null;
  }
  if (((_b = params.response_format) == null ? void 0 : _b.type) === "json_schema") {
    if ("$parseRaw" in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
function parseToolCall(params, toolCall) {
  var _a2;
  const inputTool = (_a2 = params.tools) == null ? void 0 : _a2.find((inputTool2) => {
    var _a3;
    return ((_a3 = inputTool2.function) == null ? void 0 : _a3.name) === toolCall.function.name;
  });
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCall.function.arguments) : null
    }
  };
}
function shouldParseToolCall(params, toolCall) {
  var _a2;
  if (!params) {
    return false;
  }
  const inputTool = (_a2 = params.tools) == null ? void 0 : _a2.find((inputTool2) => {
    var _a3;
    return ((_a3 = inputTool2.function) == null ? void 0 : _a3.name) === toolCall.function.name;
  });
  return isAutoParsableTool(inputTool) || (inputTool == null ? void 0 : inputTool.function.strict) || false;
}
function hasAutoParseableInput(params) {
  var _a2, _b;
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return (_b = (_a2 = params.tools) == null ? void 0 : _a2.some((t) => isAutoParsableTool(t) || t.type === "function" && t.function.strict === true)) != null ? _b : false;
}
function validateInputTools(tools) {
  for (const tool of tools != null ? tools : []) {
    if (tool.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
    }
    if (tool.function.strict !== true) {
      throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
    }
  }
}

// node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var __classPrivateFieldGet3 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractChatCompletionRunner_instances;
var _AbstractChatCompletionRunner_getFinalContent;
var _AbstractChatCompletionRunner_getFinalMessage;
var _AbstractChatCompletionRunner_getFinalFunctionCall;
var _AbstractChatCompletionRunner_getFinalFunctionCallResult;
var _AbstractChatCompletionRunner_calculateTotalUsage;
var _AbstractChatCompletionRunner_validateParams;
var _AbstractChatCompletionRunner_stringifyFunctionCallResult;
var DEFAULT_MAX_CHAT_COMPLETIONS = 10;
var AbstractChatCompletionRunner = class extends EventStream {
  constructor() {
    super(...arguments);
    _AbstractChatCompletionRunner_instances.add(this);
    this._chatCompletions = [];
    this.messages = [];
  }
  _addChatCompletion(chatCompletion) {
    var _a2;
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = (_a2 = chatCompletion.choices[0]) == null ? void 0 : _a2.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {
        this._emit("functionCallResult", message.content);
      } else if (isAssistantMessage(message) && message.function_call) {
        this._emit("functionCall", message.function_call);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionCall", tool_call.function);
          }
        }
      }
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionCall() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
  }
  async finalFunctionCallResult() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(client, params, options) {
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
  }
  async _runChatCompletion(client, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(client, params, options);
  }
  async _runFunctions(client, params, options) {
    var _a2;
    const role = "function";
    const { function_call = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof function_call !== "string" && (function_call == null ? void 0 : function_call.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const functionsByName = {};
    for (const f of params.functions) {
      functionsByName[f.name || f.function.name] = f;
    }
    const functions = params.functions.map((f) => ({
      name: f.name || f.function.name,
      parameters: f.parameters,
      description: f.description
    }));
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        function_call,
        functions,
        messages: [...this.messages]
      }, options);
      const message = (_a2 = chatCompletion.choices[0]) == null ? void 0 : _a2.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.function_call)
        return;
      const { name, arguments: args } = message.function_call;
      const fn = functionsByName[name];
      if (!fn) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f) => JSON.stringify(f.name)).join(", ")}. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      } else if (singleFunctionToCall && singleFunctionToCall !== name) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      }
      let parsed;
      try {
        parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
      } catch (error) {
        this._addMessage({
          role,
          name,
          content: error instanceof Error ? error.message : String(error)
        });
        continue;
      }
      const rawContent = await fn.function(parsed, this);
      const content = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
      this._addMessage({ role, name, content });
      if (singleFunctionToCall)
        return;
    }
  }
  async _runTools(client, params, options) {
    var _a2, _b, _c;
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && ((_a2 = tool_choice == null ? void 0 : tool_choice.function) == null ? void 0 : _a2.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const inputTools = params.tools.map((tool) => {
      if (isAutoParsableTool(tool)) {
        if (!tool.$callback) {
          throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
        }
        return {
          type: "function",
          function: {
            function: tool.$callback,
            name: tool.function.name,
            description: tool.function.description || "",
            parameters: tool.function.parameters,
            parse: tool.$parseRaw,
            strict: true
          }
        };
      }
      return tool;
    });
    const functionsByName = {};
    for (const f of inputTools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
      type: "function",
      function: {
        name: t.function.name || t.function.function.name,
        parameters: t.function.parameters,
        description: t.function.description,
        strict: t.function.strict
      }
    } : t) : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options);
      const message = (_b = chatCompletion.choices[0]) == null ? void 0 : _b.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!((_c = message.tool_calls) == null ? void 0 : _c.length)) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error) {
          const content2 = error instanceof Error ? error.message : String(error);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
};
_AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  var _a2;
  return (_a2 = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content) != null ? _a2 : null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  var _a2, _b;
  let i = this.messages.length;
  while (i-- > 0) {
    const message = this.messages[i];
    if (isAssistantMessage(message)) {
      const { function_call, ...rest } = message;
      const ret = {
        ...rest,
        content: (_a2 = message.content) != null ? _a2 : null,
        refusal: (_b = message.refusal) != null ? _b : null
      };
      if (function_call) {
        ret.function_call = function_call;
      }
      return ret;
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall2() {
  var _a2, _b;
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isAssistantMessage(message) && (message == null ? void 0 : message.function_call)) {
      return message.function_call;
    }
    if (isAssistantMessage(message) && ((_a2 = message == null ? void 0 : message.tool_calls) == null ? void 0 : _a2.length)) {
      return (_b = message.tool_calls.at(-1)) == null ? void 0 : _b.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isFunctionMessage(message) && message.content != null) {
      return message.content;
    }
    if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => {
      var _a2;
      return x.role === "assistant" && ((_a2 = x.tool_calls) == null ? void 0 : _a2.some((y) => y.type === "function" && y.id === message.tool_call_id));
    })) {
      return message.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
};

// node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner = class extends AbstractChatCompletionRunner {
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(client, params, options) {
    const runner = new ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(client, params, opts));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
  _addMessage(message, emit = true) {
    super._addMessage(message, emit);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
};

// node_modules/openai/_vendor/partial-json-parser/parser.mjs
var STR = 1;
var NUM = 2;
var ARR = 4;
var OBJ = 8;
var NULL = 16;
var BOOL = 32;
var NAN = 64;
var INFINITY = 128;
var MINUS_INFINITY = 256;
var INF = INFINITY | MINUS_INFINITY;
var SPECIAL = NULL | BOOL | INF | NAN;
var ATOM = STR | NUM | SPECIAL;
var COLLECTION = ARR | OBJ;
var ALL = ATOM | COLLECTION;
var Allow = {
  STR,
  NUM,
  ARR,
  OBJ,
  NULL,
  BOOL,
  NAN,
  INFINITY,
  MINUS_INFINITY,
  INF,
  SPECIAL,
  ATOM,
  COLLECTION,
  ALL
};
var PartialJSON = class extends Error {
};
var MalformedJSON = class extends Error {
};
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
var _parseJSON = (jsonString, allow) => {
  const length = jsonString.length;
  let index2 = 0;
  const markPartialJSON = (msg) => {
    throw new PartialJSON(`${msg} at position ${index2}`);
  };
  const throwMalformedError = (msg) => {
    throw new MalformedJSON(`${msg} at position ${index2}`);
  };
  const parseAny = () => {
    skipBlank();
    if (index2 >= length)
      markPartialJSON("Unexpected end of input");
    if (jsonString[index2] === '"')
      return parseStr();
    if (jsonString[index2] === "{")
      return parseObj();
    if (jsonString[index2] === "[")
      return parseArr();
    if (jsonString.substring(index2, index2 + 4) === "null" || Allow.NULL & allow && length - index2 < 4 && "null".startsWith(jsonString.substring(index2))) {
      index2 += 4;
      return null;
    }
    if (jsonString.substring(index2, index2 + 4) === "true" || Allow.BOOL & allow && length - index2 < 4 && "true".startsWith(jsonString.substring(index2))) {
      index2 += 4;
      return true;
    }
    if (jsonString.substring(index2, index2 + 5) === "false" || Allow.BOOL & allow && length - index2 < 5 && "false".startsWith(jsonString.substring(index2))) {
      index2 += 5;
      return false;
    }
    if (jsonString.substring(index2, index2 + 8) === "Infinity" || Allow.INFINITY & allow && length - index2 < 8 && "Infinity".startsWith(jsonString.substring(index2))) {
      index2 += 8;
      return Infinity;
    }
    if (jsonString.substring(index2, index2 + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index2 && length - index2 < 9 && "-Infinity".startsWith(jsonString.substring(index2))) {
      index2 += 9;
      return -Infinity;
    }
    if (jsonString.substring(index2, index2 + 3) === "NaN" || Allow.NAN & allow && length - index2 < 3 && "NaN".startsWith(jsonString.substring(index2))) {
      index2 += 3;
      return NaN;
    }
    return parseNum();
  };
  const parseStr = () => {
    const start = index2;
    let escape2 = false;
    index2++;
    while (index2 < length && (jsonString[index2] !== '"' || escape2 && jsonString[index2 - 1] === "\\")) {
      escape2 = jsonString[index2] === "\\" ? !escape2 : false;
      index2++;
    }
    if (jsonString.charAt(index2) == '"') {
      try {
        return JSON.parse(jsonString.substring(start, ++index2 - Number(escape2)));
      } catch (e) {
        throwMalformedError(String(e));
      }
    } else if (Allow.STR & allow) {
      try {
        return JSON.parse(jsonString.substring(start, index2 - Number(escape2)) + '"');
      } catch (e) {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
      }
    }
    markPartialJSON("Unterminated string literal");
  };
  const parseObj = () => {
    index2++;
    skipBlank();
    const obj = {};
    try {
      while (jsonString[index2] !== "}") {
        skipBlank();
        if (index2 >= length && Allow.OBJ & allow)
          return obj;
        const key = parseStr();
        skipBlank();
        index2++;
        try {
          const value = parseAny();
          Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
        } catch (e) {
          if (Allow.OBJ & allow)
            return obj;
          else
            throw e;
        }
        skipBlank();
        if (jsonString[index2] === ",")
          index2++;
      }
    } catch (e) {
      if (Allow.OBJ & allow)
        return obj;
      else
        markPartialJSON("Expected '}' at end of object");
    }
    index2++;
    return obj;
  };
  const parseArr = () => {
    index2++;
    const arr = [];
    try {
      while (jsonString[index2] !== "]") {
        arr.push(parseAny());
        skipBlank();
        if (jsonString[index2] === ",") {
          index2++;
        }
      }
    } catch (e) {
      if (Allow.ARR & allow) {
        return arr;
      }
      markPartialJSON("Expected ']' at end of array");
    }
    index2++;
    return arr;
  };
  const parseNum = () => {
    if (index2 === 0) {
      if (jsonString === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString);
      } catch (e) {
        if (Allow.NUM & allow) {
          try {
            if ("." === jsonString[jsonString.length - 1])
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
          } catch (e2) {
          }
        }
        throwMalformedError(String(e));
      }
    }
    const start = index2;
    if (jsonString[index2] === "-")
      index2++;
    while (jsonString[index2] && !",]}".includes(jsonString[index2]))
      index2++;
    if (index2 == length && !(Allow.NUM & allow))
      markPartialJSON("Unterminated number literal");
    try {
      return JSON.parse(jsonString.substring(start, index2));
    } catch (e) {
      if (jsonString.substring(start, index2) === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
      } catch (e2) {
        throwMalformedError(String(e2));
      }
    }
  };
  const skipBlank = () => {
    while (index2 < length && " \n\r	".includes(jsonString[index2])) {
      index2++;
    }
  };
  return parseAny();
};
var partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);

// node_modules/openai/lib/ChatCompletionStream.mjs
var __classPrivateFieldSet3 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet4 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ChatCompletionStream_instances;
var _ChatCompletionStream_params;
var _ChatCompletionStream_choiceEventStates;
var _ChatCompletionStream_currentChatCompletionSnapshot;
var _ChatCompletionStream_beginRequest;
var _ChatCompletionStream_getChoiceEventState;
var _ChatCompletionStream_addChunk;
var _ChatCompletionStream_emitToolCallDoneEvent;
var _ChatCompletionStream_emitContentDoneEvents;
var _ChatCompletionStream_endRequest;
var _ChatCompletionStream_getAutoParseableResponseFormat;
var _ChatCompletionStream_accumulateChatCompletion;
var ChatCompletionStream = class extends AbstractChatCompletionRunner {
  constructor(params) {
    super();
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_params.set(this, void 0);
    _ChatCompletionStream_choiceEventStates.set(this, void 0);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
    __classPrivateFieldSet3(this, _ChatCompletionStream_params, params, "f");
    __classPrivateFieldSet3(this, _ChatCompletionStream_choiceEventStates, [], "f");
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet4(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStream(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(client, params, options) {
    const runner = new ChatCompletionStream(params);
    runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(client, params, options) {
    var _a2;
    super._createChatCompletion;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
  }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
    let state = __classPrivateFieldGet4(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
    if (state) {
      return state;
    }
    state = {
      content_done: false,
      refusal_done: false,
      logprobs_content_done: false,
      logprobs_refusal_done: false,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    };
    __classPrivateFieldGet4(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
    return state;
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    for (const choice of chunk.choices) {
      const choiceSnapshot = completion.choices[choice.index];
      if (choice.delta.content != null && ((_a2 = choiceSnapshot.message) == null ? void 0 : _a2.role) === "assistant" && ((_b = choiceSnapshot.message) == null ? void 0 : _b.content)) {
        this._emit("content", choice.delta.content, choiceSnapshot.message.content);
        this._emit("content.delta", {
          delta: choice.delta.content,
          snapshot: choiceSnapshot.message.content,
          parsed: choiceSnapshot.message.parsed
        });
      }
      if (choice.delta.refusal != null && ((_c = choiceSnapshot.message) == null ? void 0 : _c.role) === "assistant" && ((_d = choiceSnapshot.message) == null ? void 0 : _d.refusal)) {
        this._emit("refusal.delta", {
          delta: choice.delta.refusal,
          snapshot: choiceSnapshot.message.refusal
        });
      }
      if (((_e = choice.logprobs) == null ? void 0 : _e.content) != null && ((_f = choiceSnapshot.message) == null ? void 0 : _f.role) === "assistant") {
        this._emit("logprobs.content.delta", {
          content: (_g = choice.logprobs) == null ? void 0 : _g.content,
          snapshot: (_i = (_h = choiceSnapshot.logprobs) == null ? void 0 : _h.content) != null ? _i : []
        });
      }
      if (((_j = choice.logprobs) == null ? void 0 : _j.refusal) != null && ((_k = choiceSnapshot.message) == null ? void 0 : _k.role) === "assistant") {
        this._emit("logprobs.refusal.delta", {
          refusal: (_l = choice.logprobs) == null ? void 0 : _l.refusal,
          snapshot: (_n = (_m = choiceSnapshot.logprobs) == null ? void 0 : _m.refusal) != null ? _n : []
        });
      }
      const state = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.finish_reason) {
        __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
        if (state.current_tool_call_index != null) {
          __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
        }
      }
      for (const toolCall of (_o = choice.delta.tool_calls) != null ? _o : []) {
        if (state.current_tool_call_index !== toolCall.index) {
          __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        state.current_tool_call_index = toolCall.index;
      }
      for (const toolCallDelta of (_p = choice.delta.tool_calls) != null ? _p : []) {
        const toolCallSnapshot = (_q = choiceSnapshot.message.tool_calls) == null ? void 0 : _q[toolCallDelta.index];
        if (!(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type)) {
          continue;
        }
        if ((toolCallSnapshot == null ? void 0 : toolCallSnapshot.type) === "function") {
          this._emit("tool_calls.function.arguments.delta", {
            name: (_r = toolCallSnapshot.function) == null ? void 0 : _r.name,
            index: toolCallDelta.index,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: toolCallSnapshot.function.parsed_arguments,
            arguments_delta: (_t = (_s = toolCallDelta.function) == null ? void 0 : _s.arguments) != null ? _t : ""
          });
        } else {
          assertNever(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type);
        }
      }
    }
  }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
    var _a2, _b, _c;
    const state = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (state.done_tool_calls.has(toolCallIndex)) {
      return;
    }
    const toolCallSnapshot = (_a2 = choiceSnapshot.message.tool_calls) == null ? void 0 : _a2[toolCallIndex];
    if (!toolCallSnapshot) {
      throw new Error("no tool call snapshot");
    }
    if (!toolCallSnapshot.type) {
      throw new Error("tool call snapshot missing `type`");
    }
    if (toolCallSnapshot.type === "function") {
      const inputTool = (_c = (_b = __classPrivateFieldGet4(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _b.tools) == null ? void 0 : _c.find((tool) => tool.type === "function" && tool.function.name === toolCallSnapshot.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: toolCallSnapshot.function.name,
        index: toolCallIndex,
        arguments: toolCallSnapshot.function.arguments,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCallSnapshot.function.arguments) : null
      });
    } else {
      assertNever(toolCallSnapshot.type);
    }
  }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
    var _a2, _b;
    const state = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (choiceSnapshot.message.content && !state.content_done) {
      state.content_done = true;
      const responseFormat = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
      this._emit("content.done", {
        content: choiceSnapshot.message.content,
        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
      });
    }
    if (choiceSnapshot.message.refusal && !state.refusal_done) {
      state.refusal_done = true;
      this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
    }
    if (((_a2 = choiceSnapshot.logprobs) == null ? void 0 : _a2.content) && !state.logprobs_content_done) {
      state.logprobs_content_done = true;
      this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
    }
    if (((_b = choiceSnapshot.logprobs) == null ? void 0 : _b.refusal) && !state.logprobs_refusal_done) {
      state.logprobs_refusal_done = true;
      this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet4(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
    __classPrivateFieldSet3(this, _ChatCompletionStream_choiceEventStates, [], "f");
    return finalizeChatCompletion(snapshot, __classPrivateFieldGet4(this, _ChatCompletionStream_params, "f"));
  }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
    var _a2;
    const responseFormat = (_a2 = __classPrivateFieldGet4(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _a2.response_format;
    if (isAutoParsableResponseFormat(responseFormat)) {
      return responseFormat;
    }
    return null;
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
    var _a3, _b2, _c2, _d2, _e, _f;
    var _a2, _b, _c, _d;
    let snapshot = __classPrivateFieldGet4(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      }, "f");
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index: index2, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index2];
      if (!choice) {
        choice = snapshot.choices[index2] = { finish_reason, index: index2, message: {}, logprobs, ...other };
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = Object.assign({}, logprobs);
        } else {
          const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
          assertIsEmpty(rest3);
          Object.assign(choice.logprobs, rest3);
          if (content2) {
            (_a3 = (_a2 = choice.logprobs).content) != null ? _a3 : _a2.content = [];
            choice.logprobs.content.push(...content2);
          }
          if (refusal2) {
            (_b2 = (_b = choice.logprobs).refusal) != null ? _b2 : _b.refusal = [];
            choice.logprobs.refusal.push(...refusal2);
          }
        }
      }
      if (finish_reason) {
        choice.finish_reason = finish_reason;
        if (__classPrivateFieldGet4(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput(__classPrivateFieldGet4(this, _ChatCompletionStream_params, "f"))) {
          if (finish_reason === "length") {
            throw new LengthFinishReasonError();
          }
          if (finish_reason === "content_filter") {
            throw new ContentFilterFinishReasonError();
          }
        }
      }
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
      assertIsEmpty(rest2);
      Object.assign(choice.message, rest2);
      if (refusal) {
        choice.message.refusal = (choice.message.refusal || "") + refusal;
      }
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_c2 = (_c = choice.message.function_call).arguments) != null ? _c2 : _c.arguments = "";
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (content) {
        choice.message.content = (choice.message.content || "") + content;
        if (!choice.message.refusal && __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
          choice.message.parsed = partialParse(choice.message.content);
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index3, id, type, function: fn, ...rest3 } of tool_calls) {
          const tool_call = (_d2 = (_d = choice.message.tool_calls)[index3]) != null ? _d2 : _d[index3] = {};
          Object.assign(tool_call, rest3);
          if (id)
            tool_call.id = id;
          if (type)
            tool_call.type = type;
          if (fn)
            (_f = tool_call.function) != null ? _f : tool_call.function = { name: (_e = fn.name) != null ? _e : "", arguments: "" };
          if (fn == null ? void 0 : fn.name)
            tool_call.function.name = fn.name;
          if (fn == null ? void 0 : fn.arguments) {
            tool_call.function.arguments += fn.arguments;
            if (shouldParseToolCall(__classPrivateFieldGet4(this, _ChatCompletionStream_params, "f"), tool_call)) {
              tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
            }
          }
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function finalizeChatCompletion(snapshot, params) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index: index2, logprobs, ...choiceRest }) => {
      var _a2, _b, _c;
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index2}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index2}`);
      }
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index2}`);
        }
        if (!name) {
          throw new OpenAIError(`missing function_call.name for choice ${index2}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name },
            role,
            refusal: (_a2 = message.refusal) != null ? _a2 : null
          },
          finish_reason,
          index: index2,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index: index2,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: (_b = message.refusal) != null ? _b : null,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].id
${str(snapshot)}`);
              }
              if (type == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].type
${str(snapshot)}`);
              }
              if (name == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].function.name
${str(snapshot)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
              }
              return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: (_c = message.refusal) != null ? _c : null },
        finish_reason,
        index: index2,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
  return maybeParseChatCompletion(completion, params);
}
function str(x) {
  return JSON.stringify(x);
}
function assertIsEmpty(obj) {
  return;
}
function assertNever(_x) {
}

// node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner = class extends ChatCompletionStream {
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStreamingRunner(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(client, params, options) {
    const runner = new ChatCompletionStreamingRunner(null);
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(client, params, opts));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new ChatCompletionStreamingRunner(
      // @ts-expect-error TODO these types are incompatible
      params
    );
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
};

// node_modules/openai/resources/beta/chat/completions.mjs
var Completions2 = class extends APIResource {
  parse(body, options) {
    validateInputTools(body.tools);
    return this._client.chat.completions.create(body, {
      ...options,
      headers: {
        ...options == null ? void 0 : options.headers,
        "X-Stainless-Helper-Method": "beta.chat.completions.parse"
      }
    })._thenUnwrap((completion) => parseChatCompletion(completion, body));
  }
  runFunctions(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runFunctions(this._client, body, options);
    }
    return ChatCompletionRunner.runFunctions(this._client, body, options);
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client, body, options);
    }
    return ChatCompletionRunner.runTools(this._client, body, options);
  }
  /**
   * Creates a chat completion stream
   */
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(this._client, body, options);
  }
};

// node_modules/openai/resources/beta/chat/chat.mjs
var Chat2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions2(this._client);
  }
};
(function(Chat3) {
  Chat3.Completions = Completions2;
})(Chat2 || (Chat2 = {}));

// node_modules/openai/resources/beta/realtime/sessions.mjs
var Sessions = class extends APIResource {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   */
  create(body, options) {
    return this._client.post("/realtime/sessions", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};

// node_modules/openai/resources/beta/realtime/realtime.mjs
var Realtime = class extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions(this._client);
  }
};
Realtime.Sessions = Sessions;

// node_modules/openai/lib/AssistantStream.mjs
var __classPrivateFieldGet5 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet4 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _AssistantStream_instances;
var _AssistantStream_events;
var _AssistantStream_runStepSnapshots;
var _AssistantStream_messageSnapshots;
var _AssistantStream_messageSnapshot;
var _AssistantStream_finalRun;
var _AssistantStream_currentContentIndex;
var _AssistantStream_currentContent;
var _AssistantStream_currentToolCallIndex;
var _AssistantStream_currentToolCall;
var _AssistantStream_currentEvent;
var _AssistantStream_currentRunSnapshot;
var _AssistantStream_currentRunStepSnapshot;
var _AssistantStream_addEvent;
var _AssistantStream_endRequest;
var _AssistantStream_handleMessage;
var _AssistantStream_handleRunStep;
var _AssistantStream_handleEvent;
var _AssistantStream_accumulateRunStep;
var _AssistantStream_accumulateMessage;
var _AssistantStream_accumulateContent;
var _AssistantStream_handleRun;
var AssistantStream = class extends EventStream {
  constructor() {
    super(...arguments);
    _AssistantStream_instances.add(this);
    _AssistantStream_events.set(this, []);
    _AssistantStream_runStepSnapshots.set(this, {});
    _AssistantStream_messageSnapshots.set(this, {});
    _AssistantStream_messageSnapshot.set(this, void 0);
    _AssistantStream_finalRun.set(this, void 0);
    _AssistantStream_currentContentIndex.set(this, void 0);
    _AssistantStream_currentContent.set(this, void 0);
    _AssistantStream_currentToolCallIndex.set(this, void 0);
    _AssistantStream_currentToolCall.set(this, void 0);
    _AssistantStream_currentEvent.set(this, void 0);
    _AssistantStream_currentRunSnapshot.set(this, void 0);
    _AssistantStream_currentRunStepSnapshot.set(this, void 0);
  }
  [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  static fromReadableStream(stream) {
    const runner = new AssistantStream();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  async _fromReadableStream(readableStream, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
  static createToolAssistantStream(threadId, runId, runs, params, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createToolAssistantStream(run, threadId, runId, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.submitToolOutputs(threadId, runId, body, {
      ...options,
      signal: this.controller.signal
    });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static createThreadAssistantStream(params, thread, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._threadAssistantStream(params, thread, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  static createAssistantStream(threadId, runs, params, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._runAssistantStream(threadId, runs, params, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  currentEvent() {
    return __classPrivateFieldGet5(this, _AssistantStream_currentEvent, "f");
  }
  currentRun() {
    return __classPrivateFieldGet5(this, _AssistantStream_currentRunSnapshot, "f");
  }
  currentMessageSnapshot() {
    return __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f");
  }
  currentRunStepSnapshot() {
    return __classPrivateFieldGet5(this, _AssistantStream_currentRunStepSnapshot, "f");
  }
  async finalRunSteps() {
    await this.done();
    return Object.values(__classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f"));
  }
  async finalMessages() {
    await this.done();
    return Object.values(__classPrivateFieldGet5(this, _AssistantStream_messageSnapshots, "f"));
  }
  async finalRun() {
    await this.done();
    if (!__classPrivateFieldGet5(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run was not received.");
    return __classPrivateFieldGet5(this, _AssistantStream_finalRun, "f");
  }
  async _createThreadAssistantStream(thread, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  async _createAssistantStream(run, threadId, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static accumulateDelta(acc, delta) {
    for (const [key, deltaValue] of Object.entries(delta)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = deltaValue;
        continue;
      }
      let accValue = acc[key];
      if (accValue === null || accValue === void 0) {
        acc[key] = deltaValue;
        continue;
      }
      if (key === "index" || key === "type") {
        acc[key] = deltaValue;
        continue;
      }
      if (typeof accValue === "string" && typeof deltaValue === "string") {
        accValue += deltaValue;
      } else if (typeof accValue === "number" && typeof deltaValue === "number") {
        accValue += deltaValue;
      } else if (isObj(accValue) && isObj(deltaValue)) {
        accValue = this.accumulateDelta(accValue, deltaValue);
      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
        if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
          accValue.push(...deltaValue);
          continue;
        }
        for (const deltaEntry of deltaValue) {
          if (!isObj(deltaEntry)) {
            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
          }
          const index2 = deltaEntry["index"];
          if (index2 == null) {
            console.error(deltaEntry);
            throw new Error("Expected array delta entry to have an `index` property");
          }
          if (typeof index2 !== "number") {
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index2}`);
          }
          const accEntry = accValue[index2];
          if (accEntry == null) {
            accValue.push(deltaEntry);
          } else {
            accValue[index2] = this.accumulateDelta(accEntry, deltaEntry);
          }
        }
        continue;
      } else {
        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
      }
      acc[key] = accValue;
    }
    return acc;
  }
  _addRun(run) {
    return run;
  }
  async _threadAssistantStream(params, thread, options) {
    return await this._createThreadAssistantStream(thread, params, options);
  }
  async _runAssistantStream(threadId, runs, params, options) {
    return await this._createAssistantStream(runs, threadId, params, options);
  }
  async _runToolAssistantStream(threadId, runId, runs, params, options) {
    return await this._createToolAssistantStream(runs, threadId, runId, params, options);
  }
};
_AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
  if (this.ended)
    return;
  __classPrivateFieldSet4(this, _AssistantStream_currentEvent, event, "f");
  __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
  switch (event.event) {
    case "thread.created":
      break;
    case "thread.run.created":
    case "thread.run.queued":
    case "thread.run.in_progress":
    case "thread.run.requires_action":
    case "thread.run.completed":
    case "thread.run.failed":
    case "thread.run.cancelling":
    case "thread.run.cancelled":
    case "thread.run.expired":
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
      break;
    case "thread.run.step.created":
    case "thread.run.step.in_progress":
    case "thread.run.step.delta":
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
      break;
    case "thread.message.created":
    case "thread.message.in_progress":
    case "thread.message.delta":
    case "thread.message.completed":
    case "thread.message.incomplete":
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
      break;
    case "error":
      throw new Error("Encountered an error event in event processing - errors should be processed earlier");
  }
}, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
  if (this.ended) {
    throw new OpenAIError(`stream has ended, this shouldn't happen`);
  }
  if (!__classPrivateFieldGet5(this, _AssistantStream_finalRun, "f"))
    throw Error("Final run has not been received");
  return __classPrivateFieldGet5(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
  const [accumulatedMessage, newContent] = __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
  __classPrivateFieldSet4(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
  __classPrivateFieldGet5(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
  for (const content of newContent) {
    const snapshotContent = accumulatedMessage.content[content.index];
    if ((snapshotContent == null ? void 0 : snapshotContent.type) == "text") {
      this._emit("textCreated", snapshotContent.text);
    }
  }
  switch (event.event) {
    case "thread.message.created":
      this._emit("messageCreated", event.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      this._emit("messageDelta", event.data.delta, accumulatedMessage);
      if (event.data.delta.content) {
        for (const content of event.data.delta.content) {
          if (content.type == "text" && content.text) {
            let textDelta = content.text;
            let snapshot = accumulatedMessage.content[content.index];
            if (snapshot && snapshot.type == "text") {
              this._emit("textDelta", textDelta, snapshot.text);
            } else {
              throw Error("The snapshot associated with this text delta is not text or missing");
            }
          }
          if (content.index != __classPrivateFieldGet5(this, _AssistantStream_currentContentIndex, "f")) {
            if (__classPrivateFieldGet5(this, _AssistantStream_currentContent, "f")) {
              switch (__classPrivateFieldGet5(this, _AssistantStream_currentContent, "f").type) {
                case "text":
                  this._emit("textDone", __classPrivateFieldGet5(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", __classPrivateFieldGet5(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
            __classPrivateFieldSet4(this, _AssistantStream_currentContentIndex, content.index, "f");
          }
          __classPrivateFieldSet4(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
        }
      }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (__classPrivateFieldGet5(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
        const currentContent = event.data.content[__classPrivateFieldGet5(this, _AssistantStream_currentContentIndex, "f")];
        if (currentContent) {
          switch (currentContent.type) {
            case "image_file":
              this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
              break;
            case "text":
              this._emit("textDone", currentContent.text, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
              break;
          }
        }
      }
      if (__classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f")) {
        this._emit("messageDone", event.data);
      }
      __classPrivateFieldSet4(this, _AssistantStream_messageSnapshot, void 0, "f");
  }
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
  const accumulatedRunStep = __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
  __classPrivateFieldSet4(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
  switch (event.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", event.data);
      break;
    case "thread.run.step.delta":
      const delta = event.data.delta;
      if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
        for (const toolCall of delta.step_details.tool_calls) {
          if (toolCall.index == __classPrivateFieldGet5(this, _AssistantStream_currentToolCallIndex, "f")) {
            this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
          } else {
            if (__classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"));
            }
            __classPrivateFieldSet4(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
            __classPrivateFieldSet4(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
            if (__classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"))
              this._emit("toolCallCreated", __classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"));
          }
        }
      }
      this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldSet4(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
      const details = event.data.step_details;
      if (details.type == "tool_calls") {
        if (__classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet4(this, _AssistantStream_currentToolCall, void 0, "f");
        }
      }
      this._emit("runStepDone", event.data, accumulatedRunStep);
      break;
    case "thread.run.step.in_progress":
      break;
  }
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
  __classPrivateFieldGet5(this, _AssistantStream_events, "f").push(event);
  this._emit("event", event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
  switch (event.event) {
    case "thread.run.step.created":
      __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      return event.data;
    case "thread.run.step.delta":
      let snapshot = __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      if (!snapshot) {
        throw Error("Received a RunStepDelta before creation of a snapshot");
      }
      let data = event.data;
      if (data.delta) {
        const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);
        __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
      }
      return __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      break;
  }
  if (__classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
    return __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
  throw new Error("No snapshot available");
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
  let newContent = [];
  switch (event.event) {
    case "thread.message.created":
      return [event.data, newContent];
    case "thread.message.delta":
      if (!snapshot) {
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      }
      let data = event.data;
      if (data.delta.content) {
        for (const contentElement of data.delta.content) {
          if (contentElement.index in snapshot.content) {
            let currentContent = snapshot.content[contentElement.index];
            snapshot.content[contentElement.index] = __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
          } else {
            snapshot.content[contentElement.index] = contentElement;
            newContent.push(contentElement);
          }
        }
      }
      return [snapshot, newContent];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (snapshot) {
        return [snapshot, newContent];
      } else {
        throw Error("Received thread message event with no existing snapshot");
      }
  }
  throw Error("Tried to accumulate a non-message event");
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
  return AssistantStream.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
  __classPrivateFieldSet4(this, _AssistantStream_currentRunSnapshot, event.data, "f");
  switch (event.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
      __classPrivateFieldSet4(this, _AssistantStream_finalRun, event.data, "f");
      if (__classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f")) {
        this._emit("toolCallDone", __classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"));
        __classPrivateFieldSet4(this, _AssistantStream_currentToolCall, void 0, "f");
      }
      break;
    case "thread.run.cancelling":
      break;
  }
};

// node_modules/openai/resources/beta/threads/messages.mjs
var Messages = class extends APIResource {
  /**
   * Create a message.
   */
  create(threadId, body, options) {
    return this._client.post(`/threads/${threadId}/messages`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieve a message.
   */
  retrieve(threadId, messageId, options) {
    return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a message.
   */
  update(threadId, messageId, body, options) {
    return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Deletes a message.
   */
  del(threadId, messageId, options) {
    return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};
var MessagesPage = class extends CursorPage {
};
Messages.MessagesPage = MessagesPage;

// node_modules/openai/resources/beta/threads/runs/steps.mjs
var Steps = class extends APIResource {
  retrieve(threadId, runId, stepId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.retrieve(threadId, runId, stepId, {}, query);
    }
    return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, runId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, runId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};
var RunStepsPage = class extends CursorPage {
};
Steps.RunStepsPage = RunStepsPage;

// node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs = class extends APIResource {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadId, params, options) {
    var _a2;
    const { include, ...body } = params;
    return this._client.post(`/threads/${threadId}/runs`, {
      query: { include },
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
      stream: (_a2 = params.stream) != null ? _a2 : false
    });
  }
  /**
   * Retrieves a run.
   */
  retrieve(threadId, runId, options) {
    return this._client.get(`/threads/${threadId}/runs/${runId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a run.
   */
  update(threadId, runId, body, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   */
  cancel(threadId, runId, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(threadId, body, options) {
    const run = await this.create(threadId, body, options);
    return await this.poll(threadId, run.id, options);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(threadId, runId, options) {
    const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
    if (options == null ? void 0 : options.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const { data: run, response } = await this.retrieve(threadId, runId, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, ...headers }
      }).withResponse();
      switch (run.status) {
        case "queued":
        case "in_progress":
        case "cancelling":
          let sleepInterval = 5e3;
          if (options == null ? void 0 : options.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return run;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  submitToolOutputs(threadId, runId, body, options) {
    var _a2;
    return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
      stream: (_a2 = body.stream) != null ? _a2 : false
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(threadId, runId, body, options) {
    const run = await this.submitToolOutputs(threadId, runId, body, options);
    return await this.poll(threadId, run.id, options);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(threadId, runId, body, options) {
    return AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);
  }
};
var RunsPage = class extends CursorPage {
};
Runs.RunsPage = RunsPage;
Runs.Steps = Steps;
Runs.RunStepsPage = RunStepsPage;

// node_modules/openai/resources/beta/threads/threads.mjs
var Threads = class extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs(this._client);
    this.messages = new Messages(this._client);
  }
  create(body = {}, options) {
    if (isRequestOptions(body)) {
      return this.create({}, body);
    }
    return this._client.post("/threads", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a thread.
   */
  retrieve(threadId, options) {
    return this._client.get(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a thread.
   */
  update(threadId, body, options) {
    return this._client.post(`/threads/${threadId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete a thread.
   */
  del(threadId, options) {
    return this._client.delete(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  createAndRun(body, options) {
    var _a2;
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
      stream: (_a2 = body.stream) != null ? _a2 : false
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(body, options) {
    const run = await this.createAndRun(body, options);
    return await this.runs.poll(run.thread_id, run.id, options);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(body, options) {
    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
  }
};
Threads.Runs = Runs;
Threads.RunsPage = RunsPage;
Threads.Messages = Messages;
Threads.MessagesPage = MessagesPage;

// node_modules/openai/lib/Util.mjs
var allSettledWithThrow = async (promises) => {
  const results = await Promise.allSettled(promises);
  const rejected = results.filter((result) => result.status === "rejected");
  if (rejected.length) {
    for (const result of rejected) {
      console.error(result.reason);
    }
    throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
  }
  const values = [];
  for (const result of results) {
    if (result.status === "fulfilled") {
      values.push(result.value);
    }
  }
  return values;
};

// node_modules/openai/resources/beta/vector-stores/files.mjs
var Files = class extends APIResource {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/files`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(vectorStoreId, fileId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(vectorStoreId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(vectorStoreId, {}, query);
    }
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  del(vectorStoreId, fileId, options) {
    return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const file = await this.create(vectorStoreId, body, options);
    return await this.poll(vectorStoreId, file.id, options);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(vectorStoreId, fileId, options) {
    const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
    if (options == null ? void 0 : options.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const fileResponse = await this.retrieve(vectorStoreId, fileId, {
        ...options,
        headers
      }).withResponse();
      const file = fileResponse.data;
      switch (file.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options == null ? void 0 : options.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "failed":
        case "completed":
          return file;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(vectorStoreId, file, options) {
    const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
    return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(vectorStoreId, file, options) {
    const fileInfo = await this.upload(vectorStoreId, file, options);
    return await this.poll(vectorStoreId, fileInfo.id, options);
  }
};
var VectorStoreFilesPage = class extends CursorPage {
};
Files.VectorStoreFilesPage = VectorStoreFilesPage;

// node_modules/openai/resources/beta/vector-stores/file-batches.mjs
var FileBatches = class extends APIResource {
  /**
   * Create a vector store file batch.
   */
  create(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(vectorStoreId, batchId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(vectorStoreId, batchId, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const batch = await this.create(vectorStoreId, body);
    return await this.poll(vectorStoreId, batch.id, options);
  }
  listFiles(vectorStoreId, batchId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listFiles(vectorStoreId, batchId, {}, query);
    }
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, VectorStoreFilesPage, { query, ...options, headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers } });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(vectorStoreId, batchId, options) {
    const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
    if (options == null ? void 0 : options.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {
        ...options,
        headers
      }).withResponse();
      switch (batch.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options == null ? void 0 : options.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return batch;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
    var _a2;
    if (files == null || files.length == 0) {
      throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
    }
    const configuredConcurrency = (_a2 = options == null ? void 0 : options.maxConcurrency) != null ? _a2 : 5;
    const concurrencyLimit = Math.min(configuredConcurrency, files.length);
    const client = this._client;
    const fileIterator = files.values();
    const allFileIds = [...fileIds];
    async function processFiles(iterator) {
      for (let item of iterator) {
        const fileObj = await client.files.create({ file: item, purpose: "assistants" }, options);
        allFileIds.push(fileObj.id);
      }
    }
    const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
    await allSettledWithThrow(workers);
    return await this.createAndPoll(vectorStoreId, {
      file_ids: allFileIds
    });
  }
};

// node_modules/openai/resources/beta/vector-stores/vector-stores.mjs
var VectorStores = class extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files(this._client);
    this.fileBatches = new FileBatches(this._client);
  }
  /**
   * Create a vector store.
   */
  create(body, options) {
    return this._client.post("/vector_stores", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(vectorStoreId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a vector store.
   */
  update(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/vector_stores", VectorStoresPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete a vector store.
   */
  del(vectorStoreId, options) {
    return this._client.delete(`/vector_stores/${vectorStoreId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};
var VectorStoresPage = class extends CursorPage {
};
VectorStores.VectorStoresPage = VectorStoresPage;
VectorStores.Files = Files;
VectorStores.VectorStoreFilesPage = VectorStoreFilesPage;
VectorStores.FileBatches = FileBatches;

// node_modules/openai/resources/beta/beta.mjs
var Beta = class extends APIResource {
  constructor() {
    super(...arguments);
    this.realtime = new Realtime(this._client);
    this.vectorStores = new VectorStores(this._client);
    this.chat = new Chat2(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads(this._client);
  }
};
Beta.Realtime = Realtime;
Beta.VectorStores = VectorStores;
Beta.VectorStoresPage = VectorStoresPage;
Beta.Assistants = Assistants;
Beta.AssistantsPage = AssistantsPage;
Beta.Threads = Threads;

// node_modules/openai/resources/completions.mjs
var Completions3 = class extends APIResource {
  create(body, options) {
    var _a2;
    return this._client.post("/completions", { body, ...options, stream: (_a2 = body.stream) != null ? _a2 : false });
  }
};

// node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(body, options) {
    return this._client.post("/embeddings", { body, ...options });
  }
};

// node_modules/openai/resources/files.mjs
var Files2 = class extends APIResource {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 100 GB.
   *
   * The Assistants API supports files up to 2 million tokens and of specific file
   * types. See the
   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
   * details.
   *
   * The Fine-tuning API only supports `.jsonl` files. The input also has certain
   * required formats for fine-tuning
   * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
   * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   * models.
   *
   * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
   * has a specific required
   * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(body, options) {
    return this._client.post("/files", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileId, options) {
    return this._client.get(`/files/${fileId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/files", FileObjectsPage, { query, ...options });
  }
  /**
   * Delete a file.
   */
  del(fileId, options) {
    return this._client.delete(`/files/${fileId}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, {
      ...options,
      headers: { Accept: "application/binary", ...options == null ? void 0 : options.headers },
      __binaryResponse: true
    });
  }
  /**
   * Returns the contents of the specified file.
   *
   * @deprecated The `.content()` method should be used instead
   */
  retrieveContent(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, options);
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep2(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};
var FileObjectsPage = class extends CursorPage {
};
Files2.FileObjectsPage = FileObjectsPage;

// node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs
var Checkpoints = class extends APIResource {
  list(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, { query, ...options });
  }
};
var FineTuningJobCheckpointsPage = class extends CursorPage {
};
Checkpoints.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;

// node_modules/openai/resources/fine-tuning/jobs/jobs.mjs
var Jobs = class extends APIResource {
  constructor() {
    super(...arguments);
    this.checkpoints = new Checkpoints(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  retrieve(fineTuningJobId, options) {
    return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuningJobId, options) {
    return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
  }
  listEvents(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
      query,
      ...options
    });
  }
};
var FineTuningJobsPage = class extends CursorPage {
};
var FineTuningJobEventsPage = class extends CursorPage {
};
Jobs.FineTuningJobsPage = FineTuningJobsPage;
Jobs.FineTuningJobEventsPage = FineTuningJobEventsPage;
Jobs.Checkpoints = Checkpoints;
Jobs.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource {
  constructor() {
    super(...arguments);
    this.jobs = new Jobs(this._client);
  }
};
FineTuning.Jobs = Jobs;
FineTuning.FineTuningJobsPage = FineTuningJobsPage;
FineTuning.FineTuningJobEventsPage = FineTuningJobEventsPage;

// node_modules/openai/resources/images.mjs
var Images = class extends APIResource {
  /**
   * Creates a variation of a given image.
   */
  createVariation(body, options) {
    return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an edited or extended image given an original image and a prompt.
   */
  edit(body, options) {
    return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an image given a prompt.
   */
  generate(body, options) {
    return this._client.post("/images/generations", { body, ...options });
  }
};

// node_modules/openai/resources/models.mjs
var Models = class extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options) {
    return this._client.get(`/models/${model}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this._client.getAPIList("/models", ModelsPage, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(model, options) {
    return this._client.delete(`/models/${model}`, options);
  }
};
var ModelsPage = class extends Page {
};
Models.ModelsPage = ModelsPage;

// node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
};

// node_modules/openai/resources/uploads/parts.mjs
var Parts = class extends APIResource {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(uploadId, body, options) {
    return this._client.post(`/uploads/${uploadId}/parts`, multipartFormRequestOptions({ body, ...options }));
  }
};

// node_modules/openai/resources/uploads/uploads.mjs
var Uploads = class extends APIResource {
  constructor() {
    super(...arguments);
    this.parts = new Parts(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose`s, the correct `mime_type` must be specified. Please refer
   * to documentation for the supported MIME types for your use case:
   *
   * - [Assistants](https://platform.openai.com/docs/assistants/tools/file-search#supported-files)
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(body, options) {
    return this._client.post("/uploads", { body, ...options });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(uploadId, options) {
    return this._client.post(`/uploads/${uploadId}/cancel`, options);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(uploadId, body, options) {
    return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });
  }
};
Uploads.Parts = Parts;

// node_modules/openai/index.mjs
var _a;
var OpenAI = class extends APIClient {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = ((_a2) => (_a2 = readEnv("OPENAI_ORG_ID")) != null ? _a2 : null)(), project = ((_b) => (_b = readEnv("OPENAI_PROJECT_ID")) != null ? _b : null)(), ...opts } = {}) {
    var _a3;
    if (apiKey === void 0) {
      throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
    }
    const options = {
      apiKey,
      organization,
      project,
      ...opts,
      baseURL: baseURL || `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    super({
      baseURL: options.baseURL,
      timeout: (_a3 = options.timeout) != null ? _a3 : 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.completions = new Completions3(this);
    this.chat = new Chat(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files2(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.beta = new Beta(this);
    this.batches = new Batches(this);
    this.uploads = new Uploads(this);
    this._options = options;
    this.apiKey = apiKey;
    this.organization = organization;
    this.project = project;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      "OpenAI-Project": this.project,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
  stringifyQuery(query) {
    return stringify(query, { arrayFormat: "brackets" });
  }
};
_a = OpenAI;
OpenAI.OpenAI = _a;
OpenAI.DEFAULT_TIMEOUT = 6e5;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
OpenAI.toFile = toFile;
OpenAI.fileFromPath = fileFromPath;
OpenAI.Completions = Completions3;
OpenAI.Chat = Chat;
OpenAI.Embeddings = Embeddings;
OpenAI.Files = Files2;
OpenAI.FileObjectsPage = FileObjectsPage;
OpenAI.Images = Images;
OpenAI.Audio = Audio;
OpenAI.Moderations = Moderations;
OpenAI.Models = Models;
OpenAI.ModelsPage = ModelsPage;
OpenAI.FineTuning = FineTuning;
OpenAI.Beta = Beta;
OpenAI.Batches = Batches;
OpenAI.BatchesPage = BatchesPage;
OpenAI.Uploads = Uploads;
var openai_default = OpenAI;

// services/OpenAIService.ts
var import_obsidian2 = require("obsidian");
var OpenAIService = class {
  constructor(settings, errorHandler) {
    this.rateLimitDelay = 20;
    // ms between requests
    this.lastRequestTime = 0;
    this.settings = settings;
    this.errorHandler = errorHandler;
    if (!settings.apiKey) {
      console.warn("OpenAI API key is missing. OpenAIService will not be initialized.");
      this.client = null;
      return;
    }
    this.client = new openai_default({
      apiKey: settings.apiKey,
      dangerouslyAllowBrowser: true
      // Enable browser-like environment usage
    });
  }
  /**
   * Check if the service is initialized
   */
  isInitialized() {
    return this.client !== null;
  }
  /**
   * Creates embeddings for the given text chunks with rate limiting and retries
   */
  async createEmbeddings(chunks) {
    if (!this.client) {
      console.warn("OpenAIService is not initialized. Cannot create embeddings.");
      new import_obsidian2.Notice("OpenAI API key is missing. Please set it in the plugin settings.");
      return chunks.map(() => ({
        data: [],
        usage: { prompt_tokens: 0, total_tokens: 0 },
        model: "text-embedding-ada-002"
        // Default model to maintain output consistency
      }));
    }
    const embeddings = [];
    for (let i = 0; i < chunks.length; i++) {
      try {
        const timeSinceLastRequest = Date.now() - this.lastRequestTime;
        if (timeSinceLastRequest < this.rateLimitDelay) {
          await new Promise(
            (resolve) => setTimeout(resolve, this.rateLimitDelay - timeSinceLastRequest)
          );
        }
        const response = await this.client.embeddings.create({
          model: "text-embedding-ada-002",
          // Use the correct model
          input: chunks[i],
          encoding_format: "float"
        });
        this.lastRequestTime = Date.now();
        embeddings.push({
          data: [
            {
              embedding: response.data[0].embedding,
              index: i
            }
          ],
          usage: {
            prompt_tokens: response.usage.prompt_tokens,
            total_tokens: response.usage.total_tokens
          },
          model: response.model
        });
      } catch (error) {
        this.handleEmbeddingError(error, chunks[i]);
        embeddings.push({
          data: [],
          usage: { prompt_tokens: 0, total_tokens: 0 },
          model: "text-embedding-ada-002"
        });
      }
    }
    return embeddings;
  }
  /**
   * Handles various types of OpenAI API errors
   */
  handleEmbeddingError(error, chunk) {
    let errorMessage;
    if (error instanceof openai_default.APIError) {
      switch (error.status) {
        case 429:
          errorMessage = "Rate limit exceeded. Please try again later.";
          break;
        case 401:
          errorMessage = "Invalid API key. Please check your settings.";
          break;
        case 413:
          errorMessage = "Text chunk too large for embedding.";
          break;
        default:
          errorMessage = `OpenAI API error: ${error.message}`;
      }
    } else {
      errorMessage = `Unexpected error: ${error.message}`;
    }
    this.errorHandler.handleError(error, {
      context: "OpenAIService.createEmbeddings",
      metadata: {
        chunkPreview: chunk.substring(0, 100) + "..."
        // First 100 chars for context
      }
    });
    new import_obsidian2.Notice(`Error creating embedding: ${errorMessage}`);
  }
  /**
   * Updates service settings
   */
  updateSettings(settings) {
    this.settings = settings;
    if (!settings.apiKey) {
      console.warn("OpenAI API key is missing. OpenAIService will not be initialized.");
      this.client = null;
      return;
    }
    this.client = new openai_default({
      apiKey: settings.apiKey,
      dangerouslyAllowBrowser: true
      // Ensure this remains enabled
    });
  }
  /**
   * Updates rate limiting parameters
   */
  updateRateLimit(delayMs) {
    this.rateLimitDelay = delayMs;
  }
};

// services/QueueService.ts
var import_obsidian4 = require("obsidian");

// services/MetadataExtractor.ts
var import_obsidian3 = require("obsidian");
var MetadataExtractor = class {
  /**
   * Extracts all metadata from an Obsidian file
   */
  async extractMetadata(file, content) {
    const fileContent = content || await file.vault.read(file);
    const frontMatter = this.extractFrontMatter(fileContent);
    const metadata = {
      obsidianId: file.path,
      path: file.path,
      lastModified: file.stat.mtime,
      created: file.stat.ctime,
      size: file.stat.size,
      frontMatter,
      tags: this.extractTags(fileContent, frontMatter),
      links: this.extractLinks(fileContent),
      customMetadata: {}
    };
    const aliases = this.extractAliases(frontMatter);
    if (aliases.length > 0) {
      metadata.customMetadata.aliases = aliases;
    }
    const loc = this.extractSourceLocation(frontMatter);
    if (loc) {
      metadata.loc = loc;
    }
    if (frontMatter == null ? void 0 : frontMatter.source) {
      metadata.source = frontMatter.source;
    }
    if (frontMatter == null ? void 0 : frontMatter.file_id) {
      metadata.file_id = frontMatter.file_id;
    }
    if (frontMatter == null ? void 0 : frontMatter.blobType) {
      metadata.blobType = frontMatter.blobType;
    }
    return metadata;
  }
  /**
   * Extracts metadata from the provided content and merges it with the given base metadata and front matter.
   * This new method is used by the TextSplitter to enhance metadata based on parsed front matter.
   */
  async extractMetadataFromContent(content, baseMetadata, frontMatter) {
    const merged = { ...baseMetadata };
    if (frontMatter) {
      merged.frontMatter = frontMatter;
      if (frontMatter.tags) {
        merged.tags = Array.isArray(frontMatter.tags) ? frontMatter.tags : [frontMatter.tags];
      }
      if (frontMatter.aliases) {
        merged.customMetadata = merged.customMetadata || {};
        merged.customMetadata.aliases = Array.isArray(frontMatter.aliases) ? frontMatter.aliases : [frontMatter.aliases];
      }
    }
    return merged;
  }
  /**
   * Extracts YAML front matter from document content
   */
  extractFrontMatter(content) {
    try {
      const frontMatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if (!frontMatterMatch)
        return void 0;
      const yaml = frontMatterMatch[1];
      return (0, import_obsidian3.parseYaml)(yaml);
    } catch (error) {
      console.error("Error parsing frontmatter:", error);
      throw new Error(`${"YAML_PARSE_ERROR" /* YAML_PARSE_ERROR */}: ${error.message}`);
    }
  }
  /**
   * Extracts internal links from document content.
   */
  extractLinks(content) {
    const linkRegex = /\[\[(.*?)(?:\|.*?)?\]\]/g;
    const links = /* @__PURE__ */ new Set();
    let match;
    while ((match = linkRegex.exec(content)) !== null) {
      const link = match[1].split("|")[0];
      const cleanLink = this.cleanLink(link);
      if (cleanLink) {
        links.add(cleanLink);
      }
    }
    return Array.from(links);
  }
  /**
   * Cleans and normalizes a link path.
   */
  cleanLink(link) {
    let cleanLink = link.split("#")[0];
    cleanLink = cleanLink.split("?")[0];
    cleanLink = cleanLink.trim();
    return cleanLink;
  }
  /**
   * Extracts tags from both content and front matter.
   */
  extractTags(content, frontMatter) {
    const tags = /* @__PURE__ */ new Set();
    const tagRegex = /#([A-Za-z0-9/_-]+)/g;
    let match;
    while ((match = tagRegex.exec(content)) !== null) {
      tags.add(match[1]);
    }
    if (frontMatter == null ? void 0 : frontMatter.tags) {
      const frontMatterTags = Array.isArray(frontMatter.tags) ? frontMatter.tags : [frontMatter.tags];
      frontMatterTags.forEach((tag) => {
        if (typeof tag === "string") {
          const cleanTag = tag.startsWith("#") ? tag.slice(1) : tag;
          tags.add(cleanTag);
        }
      });
    }
    return Array.from(tags);
  }
  /**
   * Extracts aliases from front matter.
   */
  extractAliases(frontMatter) {
    if (!(frontMatter == null ? void 0 : frontMatter.aliases))
      return [];
    if (Array.isArray(frontMatter.aliases)) {
      return frontMatter.aliases.filter((alias) => typeof alias === "string");
    }
    if (typeof frontMatter.aliases === "string") {
      return [frontMatter.aliases];
    }
    return [];
  }
  /**
   * Extracts source location information from front matter.
   */
  extractSourceLocation(frontMatter) {
    var _a2, _b, _c, _d;
    if (!((_b = (_a2 = frontMatter == null ? void 0 : frontMatter.loc) == null ? void 0 : _a2.lines) == null ? void 0 : _b.from) || !((_d = (_c = frontMatter == null ? void 0 : frontMatter.loc) == null ? void 0 : _c.lines) == null ? void 0 : _d.to)) {
      return void 0;
    }
    return {
      lines: {
        from: Number(frontMatter.loc.lines.from),
        to: Number(frontMatter.loc.lines.to)
      }
    };
  }
};

// utils/TextSplitter.ts
var TextSplitter = class {
  constructor(settings, metadataExtractor) {
    // Regex patterns for splitting
    this.SENTENCE_BOUNDARY = /[.!?]\s+/;
    this.PARAGRAPH_BOUNDARY = /\n\s*\n/;
    this.YAML_FRONT_MATTER = /^---\n([\s\S]*?)\n---/;
    this.settings = settings || { ...DEFAULT_CHUNKING_OPTIONS };
    this.validateSettings(this.settings);
    this.metadataExtractor = metadataExtractor || new MetadataExtractor();
  }
  /**
   * Returns the current chunking settings.
   */
  getSettings() {
    return this.settings;
  }
  validateSettings(settings) {
    if (settings.chunkSize <= 0) {
      throw new Error("Chunk size must be greater than 0.");
    }
    if (settings.chunkOverlap >= settings.chunkSize) {
      throw new Error("Chunk overlap must be less than chunk size.");
    }
    if (settings.minChunkSize > settings.chunkSize) {
      throw new Error("Minimum chunk size must not exceed chunk size.");
    }
  }
  /**
   * Splits a document into chunks while enhancing metadata.
   * Extracts YAML front matter if present, and then uses the MetadataExtractor
   * to merge additional metadata (e.g., tags, aliases, links) into the base metadata
   * without modifying the original note content.
   */
  async splitDocument(content, metadata) {
    try {
      console.log("Starting document split:", {
        contentLength: content.length,
        settings: this.settings
      });
      if (!(content == null ? void 0 : content.trim())) {
        console.log("Empty content received");
        return [];
      }
      let frontMatter = null;
      const frontMatterMatch = this.YAML_FRONT_MATTER.exec(content);
      if (frontMatterMatch) {
        try {
          frontMatter = this.parseFrontMatter(frontMatterMatch[1]);
          const enhancedMetadata = await this.metadataExtractor.extractMetadataFromContent(
            content,
            metadata,
            frontMatter
          );
          metadata = { ...metadata, ...enhancedMetadata };
          console.log("Front matter extracted and metadata enhanced:", { frontMatter });
        } catch (error) {
          console.warn("Failed to parse front matter:", error);
        }
      }
      const trimmedContent = content.trim();
      if (trimmedContent.length <= Math.max(this.settings.minChunkSize, this.settings.chunkSize)) {
        if (trimmedContent.length === 0) {
          console.log("No content after trimming, returning empty array");
          return [];
        }
        console.log("Content is smaller than chunk size, creating single chunk:", {
          contentLength: trimmedContent.length,
          chunkSize: this.settings.chunkSize,
          minChunkSize: this.settings.minChunkSize
        });
        const singleChunk = this.createChunk(trimmedContent, 0, metadata);
        console.log("Created single chunk:", {
          chunkSize: singleChunk.content.length,
          preview: singleChunk.content.substring(0, 100)
        });
        return [singleChunk];
      }
      const paragraphs = content.split(this.PARAGRAPH_BOUNDARY).map((p) => p.trim()).filter((p) => p.length > 0);
      console.log("Split into paragraphs:", {
        paragraphCount: paragraphs.length,
        paragraphs: paragraphs.map((p) => p.substring(0, 100))
      });
      let chunks = [];
      let currentChunk = "";
      let chunkIndex = 0;
      for (const paragraph of paragraphs) {
        if (paragraph.length >= this.settings.chunkSize) {
          if (currentChunk) {
            chunks.push(this.createChunk(currentChunk, chunkIndex++, metadata));
            currentChunk = "";
          }
          const sentences = paragraph.split(this.SENTENCE_BOUNDARY);
          let sentenceChunk = "";
          for (const sentence of sentences) {
            const trimmedSentence = sentence.trim();
            if (!trimmedSentence)
              continue;
            if ((sentenceChunk + " " + trimmedSentence).length > this.settings.chunkSize) {
              if (sentenceChunk) {
                chunks.push(this.createChunk(sentenceChunk, chunkIndex++, metadata));
                sentenceChunk = trimmedSentence;
              } else {
                let position = 0;
                while (position < trimmedSentence.length) {
                  const chunkText = trimmedSentence.slice(
                    position,
                    Math.min(position + this.settings.chunkSize, trimmedSentence.length)
                  );
                  chunks.push(this.createChunk(chunkText, chunkIndex++, metadata));
                  position += this.settings.chunkSize;
                }
                sentenceChunk = "";
              }
            } else {
              sentenceChunk += (sentenceChunk ? " " : "") + trimmedSentence;
            }
          }
          if (sentenceChunk) {
            chunks.push(this.createChunk(sentenceChunk, chunkIndex++, metadata));
          }
        } else {
          const potentialChunkSize = currentChunk ? currentChunk.length + 2 + paragraph.length : paragraph.length;
          if (potentialChunkSize <= this.settings.chunkSize) {
            currentChunk += (currentChunk ? "\n\n" : "") + paragraph;
          } else {
            if (currentChunk) {
              chunks.push(this.createChunk(currentChunk, chunkIndex++, metadata));
            }
            currentChunk = paragraph;
          }
        }
      }
      if (currentChunk) {
        chunks.push(this.createChunk(currentChunk, chunkIndex++, metadata));
      }
      if (chunks.length === 0 && trimmedContent.length > 0) {
        console.log("Creating fallback chunk for content:", { contentLength: trimmedContent.length });
        chunks.push(this.createChunk(trimmedContent, 0, metadata));
      }
      if (this.settings.chunkOverlap > 0 && chunks.length > 1) {
        chunks = this.applyOverlap(chunks);
      }
      console.log("Finished creating chunks:", {
        chunkCount: chunks.length,
        chunkSizes: chunks.map((c) => c.content.length),
        chunkPreviews: chunks.map((c) => ({
          index: c.chunkIndex,
          size: c.content.length,
          preview: c.content.substring(0, 100)
        }))
      });
      return chunks;
    } catch (error) {
      console.error("Error in splitDocument:", error);
      throw {
        type: "CHUNKING_ERROR" /* CHUNKING_ERROR */,
        message: "Error occurred during document chunking",
        details: error.message
      };
    }
  }
  createChunk(content, index2, metadata) {
    const trimmedContent = content.trim();
    if (trimmedContent.length < this.settings.minChunkSize) {
      console.warn("Chunk smaller than minChunkSize:", {
        size: trimmedContent.length,
        minSize: this.settings.minChunkSize
      });
    }
    return {
      content: trimmedContent,
      chunkIndex: index2,
      metadata: { ...metadata }
    };
  }
  applyOverlap(chunks) {
    if (chunks.length <= 1)
      return chunks;
    const chunksWithOverlap = [...chunks];
    for (let i = chunksWithOverlap.length - 1; i > 0; i--) {
      const currentChunk = { ...chunksWithOverlap[i] };
      const previousChunk = chunksWithOverlap[i - 1];
      const overlapText = previousChunk.content.slice(-this.settings.chunkOverlap);
      if (overlapText) {
        chunksWithOverlap[i] = {
          ...currentChunk,
          content: overlapText + "\n\n" + currentChunk.content
        };
      }
    }
    return chunksWithOverlap;
  }
  parseFrontMatter(frontMatter) {
    try {
      const result = {};
      const lines = frontMatter.split("\n");
      for (const line of lines) {
        const trimmedLine = line.trim();
        if (!trimmedLine || trimmedLine.startsWith("#"))
          continue;
        const separatorIndex = line.indexOf(":");
        if (separatorIndex === -1)
          continue;
        const key = line.slice(0, separatorIndex).trim();
        let value = line.slice(separatorIndex + 1).trim();
        value = value.replace(/^["'](.*)["']$/, "$1");
        if (value.startsWith("- ")) {
          result[key] = value.split("\n").map((item) => item.replace("- ", "").trim()).filter(Boolean);
        } else {
          result[key] = value;
        }
      }
      return result;
    } catch (error) {
      console.warn("Failed to parse front matter:", error);
      return {};
    }
  }
};

// services/EventEmitter.ts
var EventEmitter = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
  }
  /**
   * Emit an event with associated data.
   * Listeners registered for this event will be called with the data.
   */
  emit(event, data) {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      for (const callback of callbacks) {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in listener for event "${event}":`, error);
        }
      }
    }
  }
  /**
   * Register a callback to be invoked when the specified event is emitted.
   * Returns an unsubscribe function.
   */
  on(event, callback) {
    var _a2;
    if (!this.listeners.has(event)) {
      this.listeners.set(event, /* @__PURE__ */ new Set());
    }
    (_a2 = this.listeners.get(event)) == null ? void 0 : _a2.add(callback);
    return () => {
      var _a3;
      (_a3 = this.listeners.get(event)) == null ? void 0 : _a3.delete(callback);
    };
  }
};

// services/QueueService.ts
var QueueService = class {
  constructor(maxConcurrent, maxRetries, supabaseService, openAIService, errorHandler, notificationManager, vault, chunkSettings) {
    this.maxConcurrent = maxConcurrent;
    this.maxRetries = maxRetries;
    this.supabaseService = supabaseService;
    this.openAIService = openAIService;
    this.errorHandler = errorHandler;
    this.notificationManager = notificationManager;
    this.queue = [];
    this.processingQueue = [];
    this.isProcessing = false;
    this.isStopped = true;
    this.processingInterval = null;
    this.vault = vault;
    const validatedChunkSettings = chunkSettings || { ...DEFAULT_CHUNKING_OPTIONS };
    try {
      this.textSplitter = new TextSplitter(validatedChunkSettings);
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "QueueService.constructor",
        metadata: validatedChunkSettings
      });
      throw new Error("Failed to initialize TextSplitter with provided settings.");
    }
    this.eventEmitter = new EventEmitter();
  }
  start() {
    if (!this.isStopped)
      return;
    this.isStopped = false;
    this.processQueue();
    this.processingInterval = setInterval(() => {
      if (!this.isProcessing) {
        this.processQueue();
      }
    }, 1e3);
    this.eventEmitter.emit("queue-status", {
      queueSize: this.queue.length,
      pendingChanges: 0,
      processingCount: this.processingQueue.length,
      status: "processing"
    });
  }
  stop() {
    this.isStopped = true;
    if (this.processingInterval) {
      clearInterval(this.processingInterval);
      this.processingInterval = null;
    }
    this.eventEmitter.emit("queue-status", {
      queueSize: this.queue.length,
      pendingChanges: 0,
      processingCount: this.processingQueue.length,
      status: "paused"
    });
  }
  async addTask(task) {
    if (this.queue.length >= 1e3) {
      throw new Error("QUEUE_FULL" /* QUEUE_FULL */);
    }
    console.log("Adding task to queue:", {
      id: task.id,
      type: task.type,
      priority: task.priority
    });
    if (task.priority > 1) {
      this.queue.unshift(task);
    } else {
      this.queue.push(task);
    }
    this.eventEmitter.emit("queue-progress", {
      processed: 0,
      total: this.queue.length,
      currentTask: task.id
    });
    if (!this.isProcessing && !this.isStopped) {
      this.processQueue();
    }
  }
  async processQueue() {
    if (this.isProcessing || this.isStopped || this.queue.length === 0) {
      return;
    }
    this.isProcessing = true;
    try {
      while (this.queue.length > 0 && this.processingQueue.length < this.maxConcurrent) {
        const task = this.queue.shift();
        if (task) {
          this.processingQueue.push(task);
          this.processTask(task).catch((error) => {
            this.handleTaskError(task, error);
          });
        }
      }
    } catch (error) {
      this.errorHandler.handleError(error, { context: "QueueService.processQueue" });
    } finally {
      this.isProcessing = false;
    }
  }
  async processTask(task) {
    console.log("Processing task:", {
      id: task.id,
      type: task.type,
      status: task.status
    });
    try {
      task.status = "PROCESSING" /* PROCESSING */;
      task.startedAt = Date.now();
      this.notifyProgress(task.id, 0, `Starting ${task.type.toLowerCase()}`);
      switch (task.type) {
        case "CREATE" /* CREATE */:
        case "UPDATE" /* UPDATE */:
          await this.processCreateUpdateTask(task);
          break;
        case "DELETE" /* DELETE */:
          await this.processDeleteTask(task);
          break;
        default:
          throw new Error(`Unsupported task type: ${task.type}`);
      }
      task.status = "COMPLETED" /* COMPLETED */;
      task.completedAt = Date.now();
      this.notifyProgress(task.id, 100, "Task completed");
      console.log("Task completed successfully:", task.id);
      this.eventEmitter.emit("queue-progress", {
        processed: 1,
        total: this.queue.length + 1,
        currentTask: task.id
      });
    } catch (error) {
      console.error("Error processing task:", {
        taskId: task.id,
        error
      });
      await this.handleTaskError(task, error);
    } finally {
      this.removeFromProcessingQueue(task);
    }
  }
  async processCreateUpdateTask(task) {
    var _a2;
    if (!this.supabaseService || !this.openAIService) {
      throw new Error("Required services not initialized");
    }
    try {
      console.log("Reading file:", task.id);
      const file = this.vault.getAbstractFileByPath(task.id);
      if (!(file instanceof import_obsidian4.TFile)) {
        throw new Error(`File not found or not a TFile: ${task.id}`);
      }
      const content = await this.vault.read(file);
      console.log("File content read successfully:", {
        fileId: task.id,
        contentLength: content.length,
        contentPreview: content.substring(0, 100)
      });
      this.notifyProgress(task.id, 20, "Splitting content");
      const chunks = await this.textSplitter.splitDocument(content, task.metadata);
      if (!chunks || !Array.isArray(chunks) || chunks.length === 0) {
        console.log("No valid chunks created for file:", {
          fileId: task.id,
          contentLength: content.length,
          settings: this.textSplitter.getSettings()
        });
        return;
      }
      console.log("Content split into chunks:", {
        numberOfChunks: chunks.length,
        chunkSizes: chunks.map((c) => c.content.length),
        firstChunkPreview: (_a2 = chunks[0]) == null ? void 0 : _a2.content.substring(0, 100)
      });
      this.notifyProgress(task.id, 40, "Generating embeddings");
      for (let i = 0; i < chunks.length; i++) {
        const response = await this.openAIService.createEmbeddings([chunks[i].content]);
        if (response.length > 0 && response[0].data.length > 0) {
          chunks[i].embedding = response[0].data[0].embedding;
          chunks[i].vectorized_at = new Date().toISOString();
          console.log(`Generated embedding for chunk ${i + 1}/${chunks.length}`);
        } else {
          throw new Error(`Failed to generate embedding for chunk ${i + 1}`);
        }
        this.notifyProgress(task.id, 40 + Math.floor(i / chunks.length * 30), `Processed ${i + 1} of ${chunks.length} chunks`);
      }
      const enhancedChunks = chunks.map((chunk) => ({
        ...chunk,
        metadata: {
          ...chunk.metadata,
          aliases: chunk.metadata.aliases || [],
          links: chunk.metadata.links || [],
          tags: chunk.metadata.tags || []
        }
      }));
      this.notifyProgress(task.id, 70, "Saving to database");
      await this.supabaseService.upsertChunks(enhancedChunks);
      console.log("Chunks saved to database:", {
        numberOfChunks: enhancedChunks.length,
        fileId: task.id
      });
      this.notifyProgress(task.id, 100, "Processing completed");
    } catch (error) {
      console.error("Error in processCreateUpdateTask:", {
        error,
        taskId: task.id,
        metadata: task.metadata
      });
      throw error;
    }
  }
  async processDeleteTask(task) {
    if (!this.supabaseService) {
      throw new Error("Supabase service not initialized");
    }
    try {
      this.notifyProgress(task.id, 50, "Deleting from database");
      await this.supabaseService.deleteDocumentChunks(task.metadata.obsidianId);
      this.notifyProgress(task.id, 100, "Delete completed");
    } catch (error) {
      console.error("Error in processDeleteTask:", {
        error,
        taskId: task.id,
        metadata: task.metadata
      });
      throw error;
    }
  }
  async handleTaskError(task, error) {
    task.retryCount = (task.retryCount || 0) + 1;
    task.updatedAt = Date.now();
    if (task.retryCount < this.maxRetries) {
      task.status = "RETRYING" /* RETRYING */;
      this.queue.unshift(task);
      this.notifyProgress(task.id, 0, `Retry attempt ${task.retryCount}`);
      console.log("Task queued for retry:", {
        taskId: task.id,
        retryCount: task.retryCount,
        maxRetries: this.maxRetries
      });
    } else {
      task.status = "FAILED" /* FAILED */;
      task.error = {
        message: error.message,
        code: error.code || "UNKNOWN_ERROR",
        stack: error.stack
      };
      task.completedAt = Date.now();
      console.error("Task failed after max retries:", {
        taskId: task.id,
        error: task.error
      });
    }
    this.errorHandler.handleError(error, {
      context: "QueueService.processTask",
      taskId: task.id,
      taskType: task.type
    });
    this.eventEmitter.emit("queue-progress", {
      processed: 0,
      total: this.queue.length,
      currentTask: task.id
    });
  }
  removeFromProcessingQueue(task) {
    const index2 = this.processingQueue.findIndex((t) => t.id === task.id);
    if (index2 !== -1) {
      this.processingQueue.splice(index2, 1);
    }
  }
  notifyProgress(taskId, progress, message) {
    this.notificationManager.updateProgress({
      taskId,
      progress,
      currentStep: message,
      totalSteps: 1,
      currentStepNumber: 1
    });
    this.eventEmitter.emit("queue-progress", {
      processed: progress,
      total: 100,
      currentTask: taskId
    });
  }
  getQueueStats() {
    const now = Date.now();
    const oneHour = 60 * 60 * 1e3;
    const tasksByStatus = this.queue.reduce((acc, task) => {
      acc[task.status] = (acc[task.status] || 0) + 1;
      return acc;
    }, {});
    const tasksByType = this.queue.reduce((acc, task) => {
      acc[task.type] = (acc[task.type] || 0) + 1;
      return acc;
    }, {});
    const completedTasks = this.queue.filter(
      (task) => task.status === "COMPLETED" /* COMPLETED */ && task.completedAt
    );
    const averageTime = completedTasks.length > 0 ? completedTasks.reduce((sum, task) => sum + (task.completedAt - task.startedAt), 0) / completedTasks.length : 0;
    const tasksLastHour = completedTasks.filter(
      (task) => task.completedAt > now - oneHour
    ).length;
    return {
      totalTasks: this.queue.length,
      tasksByStatus,
      tasksByType,
      averageProcessingTime: averageTime,
      failedTasks: tasksByStatus["FAILED" /* FAILED */] || 0,
      retryingTasks: tasksByStatus["RETRYING" /* RETRYING */] || 0,
      tasksLastHour
    };
  }
  clear() {
    this.queue = [];
    this.processingQueue = [];
    this.notificationManager.clear();
  }
  updateSettings(settings) {
    this.maxConcurrent = settings.maxConcurrent;
    this.maxRetries = settings.maxRetries;
    if (settings.chunkSettings) {
      this.textSplitter = new TextSplitter(settings.chunkSettings);
    }
  }
  /**
   * Subscribe to queue events.
   * @param eventName The event to subscribe to.
   * @param callback The callback function.
   */
  on(eventName, callback) {
    return this.eventEmitter.on(eventName, callback);
  }
};

// utils/FileTracker.ts
var import_obsidian6 = require("obsidian");

// services/SyncFileManager.ts
var import_obsidian5 = require("obsidian");

// models/SyncModels.ts
var SyncErrorType = /* @__PURE__ */ ((SyncErrorType2) => {
  SyncErrorType2["SYNC_FILE_MISSING"] = "sync_file_missing";
  SyncErrorType2["SYNC_FILE_CORRUPT"] = "sync_file_corrupt";
  SyncErrorType2["SYNC_FILE_OUTDATED"] = "sync_file_outdated";
  SyncErrorType2["DEVICE_MISMATCH"] = "device_mismatch";
  SyncErrorType2["CONFLICT_DETECTED"] = "conflict_detected";
  SyncErrorType2["DATABASE_UNAVAILABLE"] = "database_unavailable";
  SyncErrorType2["SYNC_INTERRUPTED"] = "sync_interrupted";
  SyncErrorType2["UNKNOWN_ERROR"] = "unknown_error";
  return SyncErrorType2;
})(SyncErrorType || {});
var MAX_CONNECTION_EVENTS = 20;
var MAX_PENDING_OPERATIONS = 100;
var MAX_CONFLICTS = 50;
function getPlatformInfo() {
  const userAgent = window.navigator.userAgent;
  if (userAgent.indexOf("Win") !== -1)
    return "Windows";
  if (userAgent.indexOf("Mac") !== -1)
    return "macOS";
  if (userAgent.indexOf("iPhone") !== -1 || userAgent.indexOf("iPad") !== -1)
    return "iOS";
  if (userAgent.indexOf("Android") !== -1)
    return "Android";
  if (userAgent.indexOf("Linux") !== -1)
    return "Linux";
  return "Unknown";
}
function createEmptySyncFileData(vaultId, deviceId, deviceName, pluginVersion) {
  const now = Date.now();
  const platform = getPlatformInfo();
  const device = {
    deviceId,
    name: deviceName,
    platform,
    lastSeen: now,
    lastSyncTime: now
  };
  const devices = {};
  devices[deviceId] = device;
  return {
    header: {
      lastGlobalSync: now,
      syncState: "initializing" /* INITIALIZING */,
      vaultId,
      pluginVersion,
      lastWriter: deviceId,
      devices
    },
    connectionEvents: [],
    pendingOperations: [],
    conflicts: [],
    lastDatabaseCheck: now,
    databaseStatus: "unknown"
  };
}
function trimSyncHistoryArrays(data) {
  return {
    ...data,
    connectionEvents: data.connectionEvents.slice(-MAX_CONNECTION_EVENTS),
    pendingOperations: data.pendingOperations.slice(-MAX_PENDING_OPERATIONS),
    conflicts: data.conflicts.slice(-MAX_CONFLICTS)
  };
}
function updateDeviceInSyncFile(data, deviceId, deviceName, pluginVersion) {
  const now = Date.now();
  const platform = getPlatformInfo();
  const newData = JSON.parse(JSON.stringify(data));
  if (!newData.header.devices) {
    newData.header.devices = {};
  }
  if (newData.header.devices[deviceId]) {
    newData.header.devices[deviceId] = {
      ...newData.header.devices[deviceId],
      name: deviceName,
      platform,
      lastSeen: now,
      pluginVersion: pluginVersion || newData.header.devices[deviceId].pluginVersion
    };
  } else {
    newData.header.devices[deviceId] = {
      deviceId,
      name: deviceName,
      platform,
      lastSeen: now,
      lastSyncTime: now,
      pluginVersion
    };
  }
  newData.header.lastWriter = deviceId;
  if (pluginVersion) {
    newData.header.pluginVersion = pluginVersion;
  }
  return newData;
}
function updateDatabaseStatus(data, status) {
  const newData = JSON.parse(JSON.stringify(data));
  newData.databaseStatus = status;
  newData.lastDatabaseCheck = Date.now();
  if (status === "unavailable") {
    newData.header.syncState = "offline" /* OFFLINE */;
  } else if (status === "available") {
    newData.header.syncState = "online" /* ONLINE */;
  }
  return newData;
}
function updateDeviceSyncTime(data, deviceId) {
  const newData = JSON.parse(JSON.stringify(data));
  const now = Date.now();
  if (newData.header.devices && newData.header.devices[deviceId]) {
    newData.header.devices[deviceId].lastSyncTime = now;
    newData.header.devices[deviceId].lastSeen = now;
    newData.header.lastGlobalSync = now;
  }
  return newData;
}

// services/SyncFileManager.ts
var SyncFileManager = class {
  constructor(vault, errorHandler, syncFilePath = "_mindmatrixsync.md", backupInterval = 36e5, vaultId, deviceId, deviceName, pluginVersion) {
    this.vault = vault;
    this.errorHandler = errorHandler;
    this.lastBackup = 0;
    this.syncFile = null;
    this.currentSyncData = null;
    this.syncFilePath = syncFilePath;
    this.backupPath = `${syncFilePath}.backup`;
    this.backupInterval = backupInterval;
    this.vaultId = vaultId;
    this.deviceId = deviceId;
    this.deviceName = deviceName;
    this.pluginVersion = pluginVersion;
  }
  /**
   * Initialize or validate the sync file
   */
  async initialize() {
    try {
      const existingFile = this.vault.getAbstractFileByPath(this.syncFilePath);
      if (existingFile instanceof import_obsidian5.TFile) {
        this.syncFile = existingFile;
        const validationResult = await this.validateSyncFile();
        if (!validationResult.isValid) {
          const recovered = await this.repairSyncFile();
          if (!recovered) {
            await this.createSyncFile();
          }
        }
      } else {
        await this.createSyncFile();
      }
      await this.createBackup();
      return await this.validateSyncFile();
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.initialize",
        metadata: { syncFilePath: this.syncFilePath }
      });
      try {
        await this.createSyncFile();
        return { isValid: true };
      } catch (createError) {
        return {
          isValid: false,
          error: `Failed to initialize sync file: ${createError.message}`
        };
      }
    }
  }
  /**
   * Create a new sync file with the new structure
   */
  async createSyncFile() {
    console.log("Starting sync file creation with wait periods...");
    const FILE_OP_DELAY = 1e3;
    const existingFile = this.vault.getAbstractFileByPath(this.syncFilePath);
    this.currentSyncData = createEmptySyncFileData(
      this.vaultId,
      this.deviceId,
      this.deviceName,
      this.pluginVersion
    );
    const initialContent = this.generateSyncFileContent(this.currentSyncData);
    if (existingFile instanceof import_obsidian5.TFile) {
      try {
        console.log("Existing sync file found, attempting to modify it");
        this.syncFile = existingFile;
        await this.vault.modify(existingFile, initialContent);
        console.log("Successfully modified existing sync file");
        await new Promise((resolve) => setTimeout(resolve, FILE_OP_DELAY));
        return;
      } catch (modifyError) {
        console.warn("Failed to modify existing sync file, will try delete and recreate:", modifyError);
        try {
          await this.vault.delete(existingFile);
          await new Promise((resolve) => setTimeout(resolve, FILE_OP_DELAY));
        } catch (deleteError) {
          console.error("Failed to delete existing sync file:", deleteError);
          throw new Error(`Cannot modify or delete sync file: ${modifyError.message}, ${deleteError.message}`);
        }
      }
    }
    console.log("Waiting before creating sync file...");
    await new Promise((resolve) => setTimeout(resolve, FILE_OP_DELAY));
    let createAttempts = 0;
    const maxAttempts = 3;
    while (createAttempts < maxAttempts) {
      try {
        this.syncFile = await this.vault.create(this.syncFilePath, initialContent);
        console.log("Sync file created successfully");
        break;
      } catch (createError) {
        createAttempts++;
        console.warn(`Create attempt ${createAttempts} failed:`, createError);
        if (createAttempts >= maxAttempts) {
          const finalCheck = this.vault.getAbstractFileByPath(this.syncFilePath);
          if (finalCheck instanceof import_obsidian5.TFile) {
            console.log("Sync file exists despite creation error, using it");
            this.syncFile = finalCheck;
            return;
          }
          throw new Error(`Failed to create sync file after ${maxAttempts} attempts: ${createError.message}`);
        }
        const waitTime = FILE_OP_DELAY * (createAttempts + 1);
        console.log(`Waiting ${waitTime}ms before retry...`);
        await new Promise((resolve) => setTimeout(resolve, waitTime));
      }
    }
    const fileExists = this.vault.getAbstractFileByPath(this.syncFilePath);
    if (!fileExists) {
      throw this.errorHandler.handleSyncError(
        "sync_file_missing" /* SYNC_FILE_MISSING */,
        "Sync file creation failed - file not found after wait period",
        { context: "SyncFileManager.createSyncFile" },
        void 0,
        this.deviceId,
        false
      );
    }
    console.log("Sync file creation completed successfully");
  }
  /**
   * Generate sync file content from data
   */
  generateSyncFileContent(data) {
    const yamlContent = (0, import_obsidian5.stringifyYaml)(data);
    return `---
${yamlContent}---

## Mind Matrix Sync File

This file manages cross-device coordination for the Mind Matrix plugin.
Do not modify this file manually.
`;
  }
  /**
   * Validate sync file structure and content
   */
  async validateSyncFile() {
    if (!this.syncFile) {
      return {
        isValid: false,
        error: "Sync file not initialized"
      };
    }
    try {
      const content = await this.vault.read(this.syncFile);
      const yamlMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if (!yamlMatch) {
        console.log("Invalid sync file format: Missing YAML front matter. Will recreate file.");
        await this.createSyncFile();
        return { isValid: true };
      }
      const yamlContent = yamlMatch[1];
      let parsedData;
      try {
        parsedData = (0, import_obsidian5.parseYaml)(yamlContent);
      } catch (parseError) {
        console.log("Failed to parse YAML content:", parseError);
        await this.createSyncFile();
        return { isValid: true };
      }
      if (!parsedData || typeof parsedData !== "object") {
        console.log("Invalid sync file format: Cannot parse YAML content. Will recreate file.");
        await this.createSyncFile();
        return { isValid: true };
      }
      if (content.includes("| File Path | Last Modified |")) {
        console.log("Detected old format sync file. Will convert to new format.");
        await this.createSyncFile();
        return { isValid: true };
      }
      if (!parsedData.header || !parsedData.header.vaultId || !parsedData.header.lastGlobalSync || !parsedData.header.devices) {
        console.log("Invalid sync file format: Missing required fields. Will recreate file.");
        await this.createSyncFile();
        return { isValid: true };
      }
      if (parsedData.header.vaultId !== this.vaultId) {
        console.log("Vault ID mismatch. Old ID:", parsedData.header.vaultId, "New ID:", this.vaultId);
        parsedData.header.vaultId = this.vaultId;
      }
      this.currentSyncData = parsedData;
      if (!this.currentSyncData.connectionEvents)
        this.currentSyncData.connectionEvents = [];
      if (!this.currentSyncData.pendingOperations)
        this.currentSyncData.pendingOperations = [];
      if (!this.currentSyncData.conflicts)
        this.currentSyncData.conflicts = [];
      if (!this.currentSyncData.lastDatabaseCheck)
        this.currentSyncData.lastDatabaseCheck = Date.now();
      if (!this.currentSyncData.databaseStatus)
        this.currentSyncData.databaseStatus = "unknown";
      if (!this.currentSyncData.header.fileStatuses)
        this.currentSyncData.header.fileStatuses = {};
      this.currentSyncData = updateDeviceInSyncFile(
        this.currentSyncData,
        this.deviceId,
        this.deviceName,
        this.pluginVersion
      );
      await this.writeSyncFile(this.currentSyncData);
      return { isValid: true };
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.validateSyncFile" });
      console.log("Failed to validate sync file, will recreate:", error);
      try {
        await this.createSyncFile();
        return { isValid: true };
      } catch (createError) {
        return {
          isValid: false,
          error: `Failed to validate and recreate sync file: ${createError.message}`
        };
      }
    }
  }
  /**
   * Alias for validateSyncFile() to support legacy calls.
   */
  async validateSyncState() {
    return await this.validateSyncFile();
  }
  /**
   * Repair corrupted sync file
   */
  async repairSyncFile() {
    try {
      const restored = await this.restoreFromBackup();
      if (restored) {
        return true;
      }
      await this.createSyncFile();
      return true;
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.repairSyncFile",
        metadata: { syncFilePath: this.syncFilePath }
      });
      return false;
    }
  }
  /**
   * Read and parse the sync file
   */
  async readSyncFile() {
    if (!this.syncFile) {
      throw this.errorHandler.handleSyncError(
        "sync_file_missing" /* SYNC_FILE_MISSING */,
        "Sync file not initialized",
        { context: "SyncFileManager.readSyncFile" },
        void 0,
        this.deviceId
      );
    }
    try {
      const content = await this.vault.read(this.syncFile);
      const yamlMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if (!yamlMatch) {
        throw this.errorHandler.handleSyncError(
          "sync_file_corrupt" /* SYNC_FILE_CORRUPT */,
          "Invalid sync file format: Missing YAML front matter",
          { context: "SyncFileManager.readSyncFile" },
          void 0,
          this.deviceId
        );
      }
      const yamlContent = yamlMatch[1];
      const parsedData = (0, import_obsidian5.parseYaml)(yamlContent);
      if (!parsedData || !parsedData.header) {
        throw this.errorHandler.handleSyncError(
          "sync_file_corrupt" /* SYNC_FILE_CORRUPT */,
          "Invalid sync file format: Missing required fields",
          { context: "SyncFileManager.readSyncFile" },
          void 0,
          this.deviceId
        );
      }
      this.currentSyncData = parsedData;
      return parsedData;
    } catch (error) {
      if (!this.errorHandler.isSyncError(error)) {
        throw this.errorHandler.handleSyncError(
          "sync_file_corrupt" /* SYNC_FILE_CORRUPT */,
          `Error reading sync file: ${error.message}`,
          { context: "SyncFileManager.readSyncFile" },
          void 0,
          this.deviceId
        );
      }
      throw error;
    }
  }
  /**
   * Write sync data to the sync file
   */
  async writeSyncFile(data) {
    if (!this.syncFile) {
      throw this.errorHandler.handleSyncError(
        "sync_file_missing" /* SYNC_FILE_MISSING */,
        "Sync file not initialized",
        { context: "SyncFileManager.writeSyncFile" },
        void 0,
        this.deviceId
      );
    }
    try {
      const content = this.generateSyncFileContent(data);
      await this.vault.modify(this.syncFile, content);
      this.currentSyncData = data;
      if (Date.now() - this.lastBackup >= this.backupInterval) {
        await this.createBackup();
      }
    } catch (error) {
      throw this.errorHandler.handleSyncError(
        "unknown_error" /* UNKNOWN_ERROR */,
        `Failed to write sync file: ${error.message}`,
        { context: "SyncFileManager.writeSyncFile" },
        void 0,
        this.deviceId
      );
    }
  }
  /**
   * Create a backup of the sync file
   */
  async createBackup() {
    if (!this.syncFile)
      return;
    try {
      const content = await this.vault.read(this.syncFile);
      const backupFile = this.vault.getAbstractFileByPath(this.backupPath);
      if (backupFile instanceof import_obsidian5.TFile) {
        await this.vault.modify(backupFile, content);
      } else {
        await this.vault.create(this.backupPath, content);
      }
      this.lastBackup = Date.now();
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.createBackup" });
    }
  }
  /**
   * Restore sync file from backup
   */
  async restoreFromBackup() {
    const backupFile = this.vault.getAbstractFileByPath(this.backupPath);
    if (!(backupFile instanceof import_obsidian5.TFile)) {
      return false;
    }
    try {
      const content = await this.vault.read(backupFile);
      if (this.syncFile) {
        await this.vault.modify(this.syncFile, content);
      } else {
        this.syncFile = await this.vault.create(this.syncFilePath, content);
      }
      const validationResult = await this.validateSyncFile();
      return validationResult.isValid;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.restoreFromBackup" });
      return false;
    }
  }
  /**
   * Update the database connection status
   */
  async updateDatabaseStatus(status) {
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      if (this.currentSyncData) {
        const updatedData = updateDatabaseStatus(this.currentSyncData, status);
        if (status === "unavailable" && this.currentSyncData.databaseStatus !== "unavailable") {
          updatedData.connectionEvents.push({
            timestamp: Date.now(),
            eventType: "disconnected",
            deviceId: this.deviceId,
            details: "Database connection lost"
          });
        }
        if (status === "available" && this.currentSyncData.databaseStatus !== "available") {
          updatedData.connectionEvents.push({
            timestamp: Date.now(),
            eventType: "connected",
            deviceId: this.deviceId,
            details: "Database connection established"
          });
        }
        const trimmedData = trimSyncHistoryArrays(updatedData);
        await this.writeSyncFile(trimmedData);
      }
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.updateDatabaseStatus",
        metadata: { status }
      });
    }
  }
  /**
   * Update device sync timestamp and status
   */
  async updateDeviceSyncTimestamp() {
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      if (this.currentSyncData) {
        const updatedData = updateDeviceSyncTime(this.currentSyncData, this.deviceId);
        await this.writeSyncFile(updatedData);
      }
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.updateDeviceSyncTimestamp" });
    }
  }
  /**
   * **New Method:**
   * Updates the sync status for a given file in the sync file.
   * This method is used as a fallback when the database isn't available.
   */
  async updateSyncStatus(filePath, status, additionalData) {
    if (!this.currentSyncData) {
      await this.readSyncFile();
    }
    if (this.currentSyncData) {
      this.currentSyncData.header.fileStatuses = this.currentSyncData.header.fileStatuses || {};
      this.currentSyncData.header.fileStatuses[filePath] = {
        status,
        lastModified: additionalData.lastModified,
        hash: additionalData.hash,
        updatedAt: Date.now()
      };
      await this.writeSyncFile(this.currentSyncData);
    } else {
      throw new Error("Sync file data unavailable for updateSyncStatus");
    }
  }
  /**
   * Gets the sync status for a specific file path.
   */
  async getSyncStatus(path) {
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      if (this.currentSyncData && this.currentSyncData.header.fileStatuses) {
        return this.currentSyncData.header.fileStatuses[path] || null;
      }
      return null;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.getSyncStatus", metadata: { path } });
      return null;
    }
  }
  /**
   * Get all pending operations
   */
  async getPendingOperations() {
    var _a2;
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      return ((_a2 = this.currentSyncData) == null ? void 0 : _a2.pendingOperations) || [];
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.getPendingOperations" });
      return [];
    }
  }
  /**
   * Get current sync state
   */
  async getSyncState() {
    var _a2;
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      return ((_a2 = this.currentSyncData) == null ? void 0 : _a2.header.syncState) || "unknown" /* UNKNOWN */;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.getSyncState" });
      return "unknown" /* UNKNOWN */;
    }
  }
  /**
   * Get information about all known devices
   */
  async getKnownDevices() {
    var _a2;
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      return ((_a2 = this.currentSyncData) == null ? void 0 : _a2.header.devices) || {};
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.getKnownDevices" });
      return {};
    }
  }
  /**
   * Check if there are conflicts that need resolution
   */
  async detectConflicts() {
    var _a2;
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      const pendingConflicts = ((_a2 = this.currentSyncData) == null ? void 0 : _a2.conflicts.filter(
        (conflict) => conflict.resolutionStatus === "pending"
      )) || [];
      return pendingConflicts;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.detectConflicts" });
      return [];
    }
  }
  /**
   * Attempt to resolve a conflict based on a given resolution strategy.
   * Supports strategies:
   * - "newest-wins": Automatically resolves by favoring the most recent update.
   * - "keep-both": Marks as resolved and leaves both versions intact.
   * - "manual": Flags the conflict for manual intervention (does not auto-resolve).
   */
  async resolveConflict(conflictId, resolutionStrategy) {
    var _a2;
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      const conflictIndex = (_a2 = this.currentSyncData) == null ? void 0 : _a2.conflicts.findIndex((c) => c.id === conflictId);
      if (conflictIndex === void 0 || conflictIndex < 0) {
        console.warn("Conflict not found:", conflictId);
        return false;
      }
      const conflict = this.currentSyncData.conflicts[conflictIndex];
      switch (resolutionStrategy) {
        case "newest-wins":
          conflict.resolutionStrategy = "newest-wins";
          conflict.resolutionStatus = "resolved";
          conflict.resolvedAt = Date.now();
          conflict.resolvedBy = this.deviceId;
          break;
        case "keep-both":
          conflict.resolutionStrategy = "keep-both";
          conflict.resolutionStatus = "resolved";
          conflict.resolvedAt = Date.now();
          conflict.resolvedBy = this.deviceId;
          break;
        case "manual":
          conflict.resolutionStrategy = "manual";
          console.log("Manual resolution required for conflict:", conflictId);
          return false;
        default:
          throw new Error("Unsupported resolution strategy");
      }
      await this.writeSyncFile(this.currentSyncData);
      return true;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.resolveConflict", metadata: { conflictId } });
      return false;
    }
  }
  /**
   * Attempt to resolve all detected conflicts using a default strategy.
   */
  async resolveAllConflicts(defaultStrategy = "newest-wins") {
    try {
      const conflicts = await this.detectConflicts();
      for (const conflict of conflicts) {
        await this.resolveConflict(conflict.id, defaultStrategy);
      }
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.resolveAllConflicts" });
    }
  }
  /**
   * Update the last sync timestamp in the sync file header.
   */
  async updateLastSync() {
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      if (this.currentSyncData) {
        this.currentSyncData.header.lastGlobalSync = Date.now();
        await this.writeSyncFile(this.currentSyncData);
      }
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.updateLastSync" });
    }
  }
  /**
   * Gets all sync entries from the sync file.
   */
  async getAllSyncEntries() {
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      if (this.currentSyncData && this.currentSyncData.header.fileStatuses) {
        return Object.entries(this.currentSyncData.header.fileStatuses).map(([filePath, data]) => ({
          filePath,
          status: data.status,
          lastModified: data.lastModified,
          hash: data.hash
        }));
      }
      return [];
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.getAllSyncEntries" });
      return [];
    }
  }
  /**
   * Attempt recovery operations when sync issues are detected.
   */
  async attemptRecovery() {
    try {
      const recovered = await this.restoreFromBackup();
      if (recovered) {
        console.log("Successfully recovered from backup");
        return true;
      }
      console.log("Backup restoration failed, attempting to recreate sync file");
      await this.createSyncFile();
      const validationResult = await this.validateSyncFile();
      return validationResult.isValid;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.attemptRecovery" });
      return false;
    }
  }
};

// utils/FileTracker.ts
var FileTracker = class {
  /**
   * @param vault The Obsidian vault instance.
   * @param errorHandler Centralized error handler.
   * @param syncFilePath Path to the sync file.
   * @param supabaseService Optional Supabase service instance.
   * @param offlineQueueManager Optional OfflineQueueManager for offline mode.
   */
  constructor(vault, errorHandler, syncFilePath = "_mindmatrixsync.md", supabaseService = null, offlineQueueManager) {
    this.vault = vault;
    this.errorHandler = errorHandler;
    this.supabaseService = supabaseService;
    this.eventQueue = [];
    this.isProcessing = false;
    this.processingTimeout = 1e3;
    // Optional offline queue manager for offline operations
    this.offlineQueueManager = null;
    this.syncFilePath = syncFilePath;
    this.syncManager = new SyncFileManager(vault, errorHandler, syncFilePath);
    if (offlineQueueManager) {
      this.offlineQueueManager = offlineQueueManager;
    }
  }
  /**
   * Initialize the file tracker.
   * If a Supabase service is available, reconcile the database with the local sync file.
   */
  async initialize() {
    try {
      console.log("[FileTracker.initialize] Starting FileTracker initialization");
      console.log(`[FileTracker.initialize] Sync file path: ${this.syncFilePath}`);
      await this.syncManager.initialize();
      if (this.supabaseService) {
        await this.reconcileDatabaseWithSyncFile();
      } else {
        console.log("Supabase service not available. Using sync file only for tracking.");
      }
      console.log("FileTracker initialized.");
    } catch (error) {
      this.errorHandler.handleError(error, { context: "FileTracker.initialize" });
      throw error;
    }
  }
  /**
   * Reconcile database records with local sync file entries.
   * Ensures that each file in the vault has an up-to-date status in the database.
   */
  async reconcileDatabaseWithSyncFile() {
    try {
      if (!this.supabaseService)
        return;
      const syncEntries = await this.syncManager.getAllSyncEntries();
      const entriesMap = new Map(syncEntries.map((entry) => [entry.filePath, entry]));
      const files = this.vault.getFiles();
      for (const file of files) {
        if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path))
          continue;
        try {
          const dbStatus = await this.supabaseService.getFileVectorizationStatus(file.path);
          const currentHash = await this.calculateFileHash(file);
          if (dbStatus.isVectorized) {
            const fileModifiedSinceDb = file.stat.mtime > (dbStatus.lastModified || 0);
            if (fileModifiedSinceDb) {
              const metadata = await this.createFileMetadata(file);
              await this.supabaseService.updateFileVectorizationStatus(metadata);
              console.log(`Database record updated to PENDING for modified file: ${file.path}`);
            }
          } else {
            const metadata = await this.createFileMetadata(file);
            await this.supabaseService.updateFileVectorizationStatus(metadata);
            console.log(`Database record created/updated for file: ${file.path}`);
          }
        } catch (error) {
          this.errorHandler.handleError(error, {
            context: "FileTracker.reconcileDatabaseWithSyncFile",
            metadata: { filePath: file.path }
          });
        }
      }
      for (const entry of syncEntries) {
        const file = this.vault.getAbstractFileByPath(entry.filePath);
        if (!file && entry.status !== "ERROR" && this.supabaseService) {
          await this.supabaseService.updateFileStatusOnDelete(entry.filePath);
          console.log(`Database record marked as deleted for file: ${entry.filePath}`);
        }
      }
    } catch (error) {
      console.error("Error reconciling database with sync file:", error);
    }
  }
  async handleCreate(file) {
    if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path))
      return;
    const event = { type: "create", file, timestamp: Date.now() };
    await this.queueEvent(event);
  }
  async handleModify(file) {
    if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path))
      return;
    const event = { type: "modify", file, timestamp: Date.now() };
    await this.queueEvent(event);
  }
  async handleDelete(file) {
    if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path))
      return;
    const event = { type: "delete", file, timestamp: Date.now() };
    await this.queueEvent(event);
    if (this.offlineQueueManager) {
      await this.offlineQueueManager.queueOperation({
        operationType: "delete",
        fileId: file.path,
        timestamp: Date.now()
      });
    } else if (this.supabaseService) {
      try {
        await this.supabaseService.updateFileStatusOnDelete(file.path);
      } catch (error) {
        console.error("Error updating database for deleted file:", error);
      }
    } else {
      await this.syncManager.updateSyncStatus(file.path, "OK", {
        lastModified: Date.now(),
        hash: ""
      });
    }
  }
  async handleRename(file, oldPath) {
    if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path))
      return;
    const event = { type: "rename", file, oldPath, timestamp: Date.now() };
    await this.queueEvent(event);
    const newHash = await this.calculateFileHash(file);
    const metadata = await this.createFileMetadata(file);
    if (this.offlineQueueManager) {
      await this.offlineQueueManager.queueOperation({
        operationType: "rename",
        fileId: file.path,
        metadata: { oldPath },
        timestamp: Date.now()
      });
    } else if (this.supabaseService) {
      await this.supabaseService.updateFileVectorizationStatus(metadata);
      await this.supabaseService.updateFileStatusOnDelete(oldPath);
    } else {
      await this.syncManager.updateSyncStatus(file.path, "PENDING", {
        lastModified: file.stat.mtime,
        hash: newHash
      });
      await this.syncManager.updateSyncStatus(oldPath, "OK", {
        lastModified: Date.now(),
        hash: ""
      });
    }
  }
  async queueEvent(event) {
    this.eventQueue.push(event);
    if (!this.isProcessing) {
      setTimeout(() => this.processEventQueue(), this.processingTimeout);
    }
  }
  async processEventQueue() {
    var _a2;
    if (this.isProcessing || this.eventQueue.length === 0)
      return;
    this.isProcessing = true;
    try {
      const eventsByPath = /* @__PURE__ */ new Map();
      for (const event of this.eventQueue) {
        const path = event.file.path;
        if (!eventsByPath.has(path)) {
          eventsByPath.set(path, []);
        }
        (_a2 = eventsByPath.get(path)) == null ? void 0 : _a2.push(event);
      }
      for (const [path, events] of eventsByPath) {
        await this.processFileEvents(path, events);
      }
      this.eventQueue = [];
    } catch (error) {
      this.errorHandler.handleError(error, { context: "FileTracker.processEventQueue" });
    } finally {
      this.isProcessing = false;
    }
  }
  async processFileEvents(path, events) {
    events.sort((a, b) => a.timestamp - b.timestamp);
    const finalEvent = events[events.length - 1];
    try {
      if (finalEvent.type !== "delete") {
        const newHash = await this.calculateFileHash(finalEvent.file);
        let needsVectorizing = true;
        if (this.supabaseService) {
          try {
            needsVectorizing = await this.supabaseService.needsVectorizing(
              path,
              finalEvent.file.stat.mtime,
              newHash
            );
          } catch (error) {
            console.error("Error checking if file needs vectorizing:", error);
            needsVectorizing = true;
          }
        } else {
          const syncStatus = await this.syncManager.getSyncStatus(path);
          if (syncStatus && syncStatus.hash === newHash && finalEvent.file.stat.mtime <= syncStatus.lastModified && syncStatus.status !== "PENDING") {
            needsVectorizing = false;
          }
        }
        if (needsVectorizing) {
          const metadata = await this.createFileMetadata(finalEvent.file);
          if (this.supabaseService) {
            await this.supabaseService.updateFileVectorizationStatus(metadata);
          } else {
            await this.syncManager.updateSyncStatus(path, "PENDING", {
              lastModified: finalEvent.file.stat.mtime,
              hash: newHash
            });
          }
        }
      }
    } catch (error) {
      this.errorHandler.handleError(error, { context: "FileTracker.processFileEvents", metadata: { path, eventType: finalEvent.type } });
    }
  }
  async calculateFileHash(file) {
    try {
      const content = await this.vault.read(file);
      return await this.hashString(content);
    } catch (error) {
      this.errorHandler.handleError(error, { context: "FileTracker.calculateFileHash", metadata: { filePath: file.path } });
      return "";
    }
  }
  async hashString(str2) {
    const encoder = new TextEncoder();
    const data = encoder.encode(str2);
    const buffer = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(buffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  async createFileMetadata(file) {
    try {
      const content = await this.vault.read(file);
      const lineCount = content.split("\n").length;
      let additionalMetadata = {};
      if (this.supabaseService) {
        try {
          const status = await this.supabaseService.getFileVectorizationStatus(file.path);
          if (status.isVectorized) {
            additionalMetadata = {
              lastVectorized: status.lastVectorized,
              contentHash: status.contentHash
            };
          }
        } catch (error) {
          console.error("Error getting file status from database:", error);
        }
      }
      return {
        obsidianId: file.path,
        path: file.path,
        lastModified: file.stat.mtime,
        created: file.stat.ctime,
        size: file.stat.size,
        customMetadata: { ...additionalMetadata },
        loc: { lines: { from: 1, to: lineCount } },
        source: "obsidian",
        file_id: file.path,
        blobType: "text/markdown"
      };
    } catch (error) {
      this.errorHandler.handleError(error, { context: "FileTracker.createFileMetadata", metadata: { filePath: file.path } });
      return {
        obsidianId: file.path,
        path: file.path,
        lastModified: file.stat.mtime,
        created: file.stat.ctime,
        size: file.stat.size,
        customMetadata: {}
      };
    }
  }
  shouldTrackFile(filePath) {
    var _a2;
    const fileName = ((_a2 = filePath.split("/").pop()) == null ? void 0 : _a2.toLowerCase()) || filePath.toLowerCase();
    if (fileName === "_mindmatrixsync.md" || fileName === "_mindmatrixsync.md.backup") {
      return false;
    }
    return true;
  }
  /**
   * Retrieve sync status for a given file from the sync file.
   */
  async getSyncStatus(path) {
    return await this.syncManager.getSyncStatus(path);
  }
  /**
   * Retrieve all sync statuses.
   */
  async getAllSyncStatuses() {
    return await this.syncManager.getAllSyncEntries();
  }
  /**
   * Allows late binding of the Supabase service.
   */
  setSupabaseService(service) {
    this.supabaseService = service;
  }
  /**
   * Clear the event queue.
   */
  clearQueue() {
    this.eventQueue = [];
  }
  /**
   * Update the processing timeout.
   */
  setProcessingTimeout(timeout) {
    this.processingTimeout = timeout;
  }
};

// utils/ErrorHandler.ts
var import_obsidian7 = require("obsidian");
var ErrorHandler = class {
  constructor(settings, vaultPath) {
    this.errorLogs = [];
    this.maxLogs = 100;
    this.settings = settings;
    if (settings.logToFile && vaultPath) {
      this.logFilePath = `${vaultPath}/.obsidian/mind-matrix.log`;
    }
  }
  /**
   * Handles errors with context and optional recovery.
   */
  handleError(error, context, level = "error") {
    if (!this.shouldLog(level)) {
      return;
    }
    const errorLog = {
      timestamp: Date.now(),
      error: this.normalizeError(error),
      context,
      level,
      handled: false
    };
    this.errorLogs.unshift(errorLog);
    if (this.errorLogs.length > this.maxLogs) {
      this.errorLogs.pop();
    }
    if (level === "error" || level === "warn" && this.settings.logLevel === "debug") {
      new import_obsidian7.Notice(`Error: ${error.message}`);
    }
    if (this.settings.enableDebugLogs) {
      console.group(`[${level.toUpperCase()}] ${context.context}`);
      console.error("Error details:", error);
      console.error("Context:", context);
      if (error.stack) {
        console.error("Stack trace:", error.stack);
      }
      console.groupEnd();
    }
    if (this.settings.logToFile && this.logFilePath) {
      this.writeToLogFile(errorLog);
    }
  }
  /**
   * Creates and handles a sync error.
   */
  handleSyncError(type, message, context, details, deviceId, recoverable = true) {
    const error = {
      name: "SyncError",
      message,
      type,
      details,
      deviceId,
      recoverable,
      stack: new Error().stack
    };
    this.handleError(error, context, recoverable ? "warn" : "error");
    return error;
  }
  /**
   * Handles connection errors specifically for sync operations.
   */
  handleConnectionError(error, context, deviceId) {
    let syncError;
    if (error && error.type && Object.values(SyncErrorType).includes(error.type)) {
      syncError = error;
    } else {
      syncError = {
        name: "SyncError",
        message: error.message || "Database connection error",
        type: "database_unavailable" /* DATABASE_UNAVAILABLE */,
        details: { originalError: error },
        deviceId,
        recoverable: true,
        stack: error.stack || new Error().stack
      };
    }
    this.handleError(syncError, { context }, "warn");
  }
  /**
   * Checks if the given error level should be logged.
   */
  shouldLog(level) {
    const levels = { error: 0, warn: 1, info: 2, debug: 3 };
    return levels[level] <= levels[this.settings.logLevel];
  }
  /**
   * Normalizes different error formats.
   */
  normalizeError(error) {
    if (error instanceof Error) {
      return error;
    }
    if (error && error.type && Object.values(SyncErrorType).includes(error.type)) {
      const syncError = new Error(error.message || "Sync error");
      syncError.name = "SyncError";
      Object.assign(syncError, error);
      return syncError;
    }
    if (this.isSupabaseError(error)) {
      return new Error(`Database error (${error.code}): ${error.message}${error.hint ? ` - ${error.hint}` : ""}`);
    }
    if (typeof error === "string") {
      return new Error(error);
    }
    if (typeof error === "object") {
      const message = error.message || "Unknown error";
      const normalizedError = new Error(message);
      Object.assign(normalizedError, error);
      return normalizedError;
    }
    return new Error("Unknown error occurred");
  }
  /**
   * Type guard for Supabase errors.
   */
  isSupabaseError(error) {
    return error && typeof error === "object" && "code" in error && "details" in error;
  }
  /**
   * Type guard for Sync errors.
   */
  isSyncError(error) {
    return error && typeof error === "object" && "type" in error && Object.values(SyncErrorType).includes(error.type);
  }
  /**
   * Shows an appropriate notification based on error type.
   */
  showErrorNotification(error) {
    let message = "An error occurred";
    let duration = 4e3;
    if (this.isSyncError(error)) {
      switch (error.type) {
        case "sync_file_missing" /* SYNC_FILE_MISSING */:
          message = "Sync file is missing. Will attempt to recreate.";
          break;
        case "sync_file_corrupt" /* SYNC_FILE_CORRUPT */:
          message = "Sync file is corrupted. Will attempt to repair.";
          break;
        case "device_mismatch" /* DEVICE_MISMATCH */:
          message = "Device identification issue. Check plugin settings.";
          break;
        case "conflict_detected" /* CONFLICT_DETECTED */:
          message = "Sync conflict detected. Check sync status for details.";
          duration = 6e3;
          break;
        case "database_unavailable" /* DATABASE_UNAVAILABLE */:
          message = "Database connection unavailable. Operating in offline mode.";
          break;
        case "sync_interrupted" /* SYNC_INTERRUPTED */:
          message = "Sync operation was interrupted. Will retry.";
          break;
        default:
          message = `Sync error: ${error.message}`;
      }
    } else if (this.isSupabaseError(error)) {
      switch (error.code) {
        case "42P01":
          message = "Database table not found. Please run setup SQL.";
          break;
        case "42501":
          message = "Insufficient database permissions.";
          break;
        case "23505":
          message = "Duplicate entry found.";
          break;
        default:
          message = `Database error: ${error.message}`;
      }
      duration = 6e3;
    } else if (error.type === "CHUNKING_ERROR" /* CHUNKING_ERROR */) {
      message = "Error splitting document into chunks";
    } else if (error.type === "EMBEDDING_ERROR" /* EMBEDDING_ERROR */) {
      message = "Error generating embeddings";
    } else if (error.type === "DATABASE_ERROR" /* DATABASE_ERROR */) {
      message = "Database operation failed";
    } else if (error.type === "INVALID_METADATA" /* INVALID_METADATA */) {
      message = "Invalid document metadata";
    } else if (error.type === "FILE_ACCESS_ERROR" /* FILE_ACCESS_ERROR */) {
      message = "Error accessing file";
    } else if (error.type === "YAML_PARSE_ERROR" /* YAML_PARSE_ERROR */) {
      message = "Error parsing YAML front matter";
    } else if (error.type === "VECTOR_EXTENSION_ERROR" /* VECTOR_EXTENSION_ERROR */) {
      message = "Vector extension not available";
    } else if (error.type === "SYNC_ERROR" /* SYNC_ERROR */) {
      message = "Sync operation failed";
    } else if (error.type === "QUEUE_FULL" /* QUEUE_FULL */) {
      message = "Task queue is full";
    } else if (error.type === "TASK_TIMEOUT" /* TASK_TIMEOUT */) {
      message = "Task timed out";
    } else if (error.type === "TASK_CANCELLED" /* TASK_CANCELLED */) {
      message = "Task was cancelled";
    } else if (error.type === "MAX_RETRIES_EXCEEDED" /* MAX_RETRIES_EXCEEDED */) {
      message = "Maximum retry attempts exceeded";
    } else if (error.type === "INVALID_TASK_STATE" /* INVALID_TASK_STATE */) {
      message = "Invalid task state";
    } else if (error.type === "TASK_NOT_FOUND" /* TASK_NOT_FOUND */) {
      message = "Task not found";
    }
    if (error.message && !this.isSyncError(error)) {
      message = `${message}: ${error.message}`;
    }
    new import_obsidian7.Notice(message, duration);
  }
  /**
   * Writes error log to file.
   */
  writeToLogFile(log) {
    var _a2, _b, _c;
    if (!this.logFilePath)
      return;
    const logEntry = {
      timestamp: new Date(log.timestamp).toISOString(),
      level: log.level.toUpperCase(),
      context: log.context.context,
      error: log.error.message,
      stack: log.error.stack,
      metadata: log.context.metadata
    };
    try {
      if ((_c = (_b = (_a2 = window.app) == null ? void 0 : _a2.vault) == null ? void 0 : _b.adapter) == null ? void 0 : _c.append) {
        window.app.vault.adapter.append(
          this.logFilePath,
          JSON.stringify(logEntry) + "\n"
        );
      }
    } catch (error) {
      console.error("Failed to write to log file:", error);
    }
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  getRecentLogs(count = 10) {
    return this.errorLogs.slice(0, count);
  }
  clearLogs() {
    this.errorLogs = [];
  }
  getErrorStats() {
    return this.errorLogs.reduce((acc, log) => {
      const errorType = log.error.name || "Unknown";
      acc[errorType] = (acc[errorType] || 0) + 1;
      return acc;
    }, {});
  }
  getSyncErrorStats() {
    const stats = {};
    Object.values(SyncErrorType).forEach((type) => {
      stats[type] = 0;
    });
    this.errorLogs.forEach((log) => {
      if (this.isSyncError(log.error)) {
        stats[log.error.type] = (stats[log.error.type] || 0) + 1;
      }
    });
    return stats;
  }
};

// utils/NotificationManager.ts
var import_obsidian8 = require("obsidian");
var NotificationManager = class {
  constructor(statusBarEl, enableNotifications, enableProgressBar) {
    this.fixedProgressBar = null;
    this.notificationQueue = [];
    this.isProcessingQueue = false;
    this.statusBarItem = statusBarEl;
    this.enableNotifications = enableNotifications;
    this.enableProgressBar = enableProgressBar;
    this.initializeStatusBar();
  }
  /**
   * Shows a notification message.
   */
  showNotification(message, duration = 4e3) {
    if (!this.enableNotifications)
      return;
    this.notificationQueue.push(message);
    if (!this.isProcessingQueue) {
      this.processNotificationQueue();
    }
  }
  /**
   * Updates the fixed progress bar with the current progress (in percent) and status message.
   */
  updateProgress(progress) {
    if (!this.enableProgressBar)
      return;
    if (!this.fixedProgressBar) {
      this.fixedProgressBar = this.createFixedProgressBar();
    }
    const progressPercentage = Math.round(progress.progress);
    this.fixedProgressBar.fill.style.width = `${progressPercentage}%`;
    this.fixedProgressBar.text.textContent = `${progressPercentage}% - ${progress.currentStep} (${progress.currentStepNumber}/${progress.totalSteps})`;
  }
  /**
   * Initializes the status bar container.
   */
  initializeStatusBar() {
    this.statusBarItem.innerHTML = "";
    const container = document.createElement("div");
    container.addClass("fixed-progress-container");
    this.statusBarItem.appendChild(container);
  }
  /**
   * Creates a fixed progress bar element.
   */
  createFixedProgressBar() {
    const container = document.createElement("div");
    container.addClass("fixed-progress-bar-container");
    const bar = document.createElement("div");
    bar.addClass("fixed-progress-bar");
    const fill = document.createElement("div");
    fill.addClass("fixed-progress-fill");
    const text = document.createElement("div");
    text.addClass("fixed-progress-text");
    bar.appendChild(fill);
    container.appendChild(bar);
    container.appendChild(text);
    this.statusBarItem.appendChild(container);
    return { container, fill, text };
  }
  /**
   * Processes the notification queue sequentially.
   */
  async processNotificationQueue() {
    if (this.isProcessingQueue || this.notificationQueue.length === 0)
      return;
    this.isProcessingQueue = true;
    try {
      while (this.notificationQueue.length > 0) {
        const message = this.notificationQueue.shift();
        if (message) {
          new import_obsidian8.Notice(message);
          await new Promise((resolve) => setTimeout(resolve, 500));
        }
      }
    } finally {
      this.isProcessingQueue = false;
    }
  }
  /**
   * Updates notification settings.
   */
  updateSettings(enableNotifications, enableProgressBar) {
    this.enableNotifications = enableNotifications;
    this.enableProgressBar = enableProgressBar;
  }
  /**
   * Clears all notifications.
   */
  clear() {
    this.notificationQueue = [];
  }
};

// settings/SettingsTab.ts
var import_obsidian9 = require("obsidian");
var MindMatrixSettingsTab = class extends import_obsidian9.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.settings = plugin.settings;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    console.log("DEBUG - All Exclusion Settings:", {
      userSettings: this.settings.exclusions,
      systemDefaults: SYSTEM_EXCLUSIONS
    });
    containerEl.createEl("h2", { text: "Vault Identification" });
    if (isVaultInitialized(this.settings)) {
      new import_obsidian9.Setting(containerEl).setName("Vault ID").setDesc("Unique identifier for this vault in the database.").addText(
        (text) => text.setValue(this.settings.vaultId).setDisabled(true)
      );
      new import_obsidian9.Setting(containerEl).setName("Vault Name").setDesc("The name of your current vault.").addText(
        (text) => text.setValue(this.settings.lastKnownVaultName).setDisabled(true)
      );
      new import_obsidian9.Setting(containerEl).setName("Reset Vault ID").setDesc("Generate a new vault ID (requires full resync).").addButton(
        (btn) => btn.setButtonText("Reset").setWarning().onClick(async () => {
          const confirmed = await this.showResetConfirmation();
          if (confirmed) {
            this.settings.vaultId = generateVaultId();
            this.settings.lastKnownVaultName = this.app.vault.getName();
            await this.plugin.saveSettings();
            new import_obsidian9.Notice("Vault ID has been reset. Please resync your vault.");
            this.display();
          }
        })
      );
    } else {
      new import_obsidian9.Setting(containerEl).setName("Initialize Vault").setDesc("Generate a unique identifier for this vault to begin syncing.").addButton(
        (btn) => btn.setButtonText("Initialize").onClick(async () => {
          this.settings.vaultId = generateVaultId();
          this.settings.lastKnownVaultName = this.app.vault.getName();
          await this.plugin.saveSettings();
          new import_obsidian9.Notice("Vault has been initialized.");
          this.display();
        })
      );
    }
    containerEl.createEl("h2", { text: "Supabase Configuration" });
    new import_obsidian9.Setting(containerEl).setName("Supabase URL").setDesc("The URL of your Supabase project (e.g., https://your-project.supabase.co).").addText(
      (text) => text.setPlaceholder("https://your-project.supabase.co").setValue(this.settings.supabase.url).onChange(async (value) => {
        this.settings.supabase.url = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Supabase URL updated.");
      })
    );
    new import_obsidian9.Setting(containerEl).setName("Supabase API Key").setDesc("Your Supabase API key (found in your Supabase dashboard).").addText(
      (text) => text.setPlaceholder("Enter your API key").setValue(this.settings.supabase.apiKey).onChange(async (value) => {
        this.settings.supabase.apiKey = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Supabase API key updated.");
      })
    );
    containerEl.createEl("h2", { text: "OpenAI Configuration" });
    new import_obsidian9.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key for generating embeddings.").addText(
      (text) => text.setPlaceholder("Enter your API key").setValue(this.settings.openai.apiKey).onChange(async (value) => {
        this.settings.openai.apiKey = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("OpenAI API key updated.");
      })
    );
    containerEl.createEl("h2", { text: "Document Processing" });
    new import_obsidian9.Setting(containerEl).setName("Chunk Size").setDesc("Maximum size of text chunks (in characters).").addText(
      (text) => text.setValue(String(this.settings.chunking.chunkSize)).onChange(async (value) => {
        const numValue = Number(value);
        if (!isNaN(numValue) && numValue > 0) {
          this.settings.chunking.chunkSize = numValue;
          await this.plugin.saveSettings();
          new import_obsidian9.Notice("Chunk size updated.");
        }
      })
    );
    new import_obsidian9.Setting(containerEl).setName("Chunk Overlap").setDesc("Overlap between text chunks (in characters).").addText(
      (text) => text.setValue(String(this.settings.chunking.chunkOverlap)).onChange(async (value) => {
        const numValue = Number(value);
        if (!isNaN(numValue) && numValue >= 0) {
          this.settings.chunking.chunkOverlap = numValue;
          await this.plugin.saveSettings();
          new import_obsidian9.Notice("Chunk overlap updated.");
        }
      })
    );
    containerEl.createEl("h2", { text: "Exclusions" });
    const userExclusions = getUserExclusions(this.settings);
    console.log("DEBUG - User Exclusions from getUserExclusions():", userExclusions);
    const systemFolders = new Set(SYSTEM_EXCLUSIONS.folders);
    const systemFileTypes = new Set(SYSTEM_EXCLUSIONS.fileTypes);
    const systemFilePrefixes = new Set(SYSTEM_EXCLUSIONS.filePrefixes);
    const systemFiles = new Set(SYSTEM_EXCLUSIONS.files);
    console.log("DEBUG - System Exclusion Sets:", {
      folders: Array.from(systemFolders),
      fileTypes: Array.from(systemFileTypes),
      filePrefixes: Array.from(systemFilePrefixes),
      files: Array.from(systemFiles)
    });
    const filteredUserFolders = userExclusions.excludedFolders.filter((folder) => !systemFolders.has(folder));
    const filteredUserFileTypes = userExclusions.excludedFileTypes.filter((type) => !systemFileTypes.has(type));
    const filteredUserFilePrefixes = userExclusions.excludedFilePrefixes.filter((prefix) => !systemFilePrefixes.has(prefix));
    const filteredUserFiles = userExclusions.excludedFiles.filter((file) => !systemFiles.has(file));
    console.log("DEBUG - Filtered User Exclusions:", {
      folders: filteredUserFolders,
      fileTypes: filteredUserFileTypes,
      filePrefixes: filteredUserFilePrefixes,
      files: filteredUserFiles
    });
    new import_obsidian9.Setting(containerEl).setName("Excluded Folders").setDesc("Folders to exclude from syncing (comma-separated).").addText((text) => {
      const value = filteredUserFolders.join(", ");
      console.log("DEBUG - Setting excluded folders field value:", value);
      return text.setPlaceholder("folder1, folder2").setValue(value).onChange(async (value2) => {
        console.log("DEBUG - Folders onChange event value:", value2);
        const userFolders = value2.split(",").map((s) => s.trim()).filter((s) => s);
        const finalFolders = userFolders.filter((folder) => !systemFolders.has(folder));
        console.log("DEBUG - Final folders to save:", finalFolders);
        this.settings.exclusions.excludedFolders = finalFolders;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Excluded folders updated.");
      });
    });
    new import_obsidian9.Setting(containerEl).setName("Excluded File Types").setDesc("File extensions to exclude (comma-separated, include the dot).").addText((text) => {
      const value = filteredUserFileTypes.join(", ");
      return text.setPlaceholder(".type1, .type2").setValue(value).onChange(async (value2) => {
        const userFileTypes = value2.split(",").map((s) => s.trim()).filter((s) => s);
        const finalFileTypes = userFileTypes.filter((type) => !systemFileTypes.has(type));
        this.settings.exclusions.excludedFileTypes = finalFileTypes;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Excluded file types updated.");
      });
    });
    new import_obsidian9.Setting(containerEl).setName("Excluded File Prefixes").setDesc("File name prefixes to exclude (comma-separated).").addText((text) => {
      const value = filteredUserFilePrefixes.join(", ");
      console.log("DEBUG - Setting excluded file prefixes field value:", value);
      return text.setPlaceholder("temp, draft").setValue(value).onChange(async (value2) => {
        console.log("DEBUG - File prefixes onChange event value:", value2);
        const userFilePrefixes = value2.split(",").map((s) => s.trim()).filter((s) => s);
        const finalFilePrefixes = userFilePrefixes.filter((prefix) => !systemFilePrefixes.has(prefix));
        console.log("DEBUG - Final file prefixes to save:", finalFilePrefixes);
        this.settings.exclusions.excludedFilePrefixes = finalFilePrefixes;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Excluded file prefixes updated.");
      });
    });
    new import_obsidian9.Setting(containerEl).setName("Excluded Files").setDesc("Specific files to exclude from syncing (comma-separated).").addText((text) => {
      const value = filteredUserFiles.join(", ");
      console.log("DEBUG - Setting excluded files field value:", value);
      return text.setPlaceholder("file1.md, file2.md").setValue(value).onChange(async (value2) => {
        console.log("DEBUG - Files onChange event value:", value2);
        const userFiles = value2.split(",").map((s) => s.trim()).filter((s) => s);
        const finalFiles = userFiles.filter((file) => !systemFiles.has(file));
        console.log("DEBUG - Final files to save:", finalFiles);
        this.settings.exclusions.excludedFiles = finalFiles;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Excluded files updated.");
      });
    });
    const infoDiv = containerEl.createEl("div", { cls: "setting-item-description" });
    infoDiv.innerHTML = `
			<p><strong>Note:</strong> The following items are automatically excluded by the system:</p>
			<p><strong>Folders:</strong> ${SYSTEM_EXCLUSIONS.folders.join(", ")}</p>
			<p><strong>File Types:</strong> ${SYSTEM_EXCLUSIONS.fileTypes.join(", ")}</p>
			<p><strong>File Prefixes:</strong> ${SYSTEM_EXCLUSIONS.filePrefixes.join(", ")}</p>
			<p><strong>Files:</strong> ${SYSTEM_EXCLUSIONS.files.join(", ")}</p>
		`;
    containerEl.createEl("h2", { text: "Queue & Sync Settings" });
    new import_obsidian9.Setting(containerEl).setName("Auto Sync").setDesc("Automatically sync changes to the database when files are modified.").addToggle(
      (toggle) => toggle.setValue(this.settings.enableAutoSync).onChange(async (value) => {
        this.settings.enableAutoSync = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Auto sync updated.");
      })
    );
    new import_obsidian9.Setting(containerEl).setName("Sync File Path").setDesc("The path for the dedicated sync file.").addText(
      (text) => text.setValue(this.settings.sync.syncFilePath).onChange(async (value) => {
        this.settings.sync.syncFilePath = value;
        const systemFiles2 = this.settings.exclusions.systemExcludedFiles;
        const oldSyncFileIndex = systemFiles2.findIndex((f) => f === "_mindmatrixsync.md");
        const oldSyncBackupIndex = systemFiles2.findIndex((f) => f === "_mindmatrixsync.md.backup");
        if (oldSyncFileIndex !== -1)
          systemFiles2.splice(oldSyncFileIndex, 1);
        if (oldSyncBackupIndex !== -1)
          systemFiles2.splice(oldSyncBackupIndex, 1);
        systemFiles2.push(value);
        systemFiles2.push(value + ".backup");
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Sync file path updated.");
      })
    );
    containerEl.createEl("h2", { text: "Debug Settings" });
    new import_obsidian9.Setting(containerEl).setName("Enable Debug Logs").setDesc("Enable detailed debug logs in the console.").addToggle(
      (toggle) => toggle.setValue(this.settings.debug.enableDebugLogs).onChange(async (value) => {
        this.settings.debug.enableDebugLogs = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Debug logs setting updated.");
      })
    );
    new import_obsidian9.Setting(containerEl).setName("Log Level").setDesc("Select the level of detail for debug logging.").addDropdown(
      (dropdown) => dropdown.addOption("error", "Error").addOption("warn", "Warning").addOption("info", "Info").addOption("debug", "Debug").setValue(this.settings.debug.logLevel).onChange(async (value) => {
        this.settings.debug.logLevel = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Log level updated.");
      })
    );
    new import_obsidian9.Setting(containerEl).setName("Log to File").setDesc("Save debug logs to a file in your vault.").addToggle(
      (toggle) => toggle.setValue(this.settings.debug.logToFile).onChange(async (value) => {
        this.settings.debug.logToFile = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Log to file setting updated.");
      })
    );
  }
  async showResetConfirmation() {
    return new Promise((resolve) => {
      const modal = this.app.modal;
      modal.open((modal2) => {
        modal2.titleEl.setText("Reset Vault ID");
        modal2.contentEl.setText(
          "Warning: Resetting the vault ID will disconnect this vault from its existing database entries. This operation cannot be undone. Are you sure you want to continue?"
        );
        modal2.addButton((btn) => {
          btn.setButtonText("Cancel").onClick(() => {
            resolve(false);
            modal2.close();
          });
        });
        modal2.addButton((btn) => {
          btn.setButtonText("Reset").setWarning().onClick(() => {
            resolve(true);
            modal2.close();
          });
        });
      });
    });
  }
};

// services/InitialSyncManager.ts
var import_obsidian10 = require("obsidian");
var InitialSyncManager = class {
  constructor(vault, queueService, syncFileManager, metadataExtractor, errorHandler, notificationManager, supabaseService, options = {}) {
    this.vault = vault;
    this.queueService = queueService;
    this.syncFileManager = syncFileManager;
    this.metadataExtractor = metadataExtractor;
    this.errorHandler = errorHandler;
    this.notificationManager = notificationManager;
    this.batches = [];
    this.isRunning = false;
    this.lastProcessedIndex = 0;
    // For resuming interrupted syncs
    this.processingTimeout = null;
    this.resumeFileList = [];
    this.options = {
      batchSize: 50,
      maxConcurrentBatches: 3,
      enableAutoInitialSync: true,
      priorityRules: [],
      syncFilePath: "_mindmatrixsync.md",
      exclusions: {
        excludedFolders: [],
        excludedFileTypes: [],
        excludedFilePrefixes: [],
        excludedFiles: []
      },
      ...options
    };
    this.progress = {
      totalFiles: 0,
      processedFiles: 0,
      currentBatch: 0,
      totalBatches: 0,
      startTime: 0
    };
    this.supabaseService = supabaseService;
  }
  /**
   * Filter files based on exclusion rules
   */
  filterExcludedFiles(files) {
    const syncFilePath = this.options.syncFilePath || "_mindmatrixsync.md";
    const exclusions = this.options.exclusions || {
      excludedFolders: [],
      excludedFileTypes: [],
      excludedFilePrefixes: [],
      excludedFiles: []
    };
    return files.filter((file) => {
      const filePath = file.path;
      const fileName = file.name;
      if (filePath === syncFilePath || filePath === "_mindmatrixsync.md" || filePath === "_mindmatrixsync.md.backup") {
        return false;
      }
      if (exclusions.excludedFiles && exclusions.excludedFiles.includes(fileName)) {
        return false;
      }
      if (exclusions.excludedFolders) {
        for (const folder of exclusions.excludedFolders) {
          const normalizedFolder = folder.endsWith("/") ? folder : folder + "/";
          if (filePath.startsWith(normalizedFolder)) {
            console.log(`[InitialSyncManager.filterExcludedFiles] Excluding file in excluded folder: ${filePath}`);
            return false;
          }
        }
      }
      if (exclusions.excludedFileTypes) {
        for (const fileType of exclusions.excludedFileTypes) {
          if (filePath.toLowerCase().endsWith(fileType.toLowerCase())) {
            return false;
          }
        }
      }
      if (exclusions.excludedFilePrefixes) {
        for (const prefix of exclusions.excludedFilePrefixes) {
          if (fileName.startsWith(prefix)) {
            return false;
          }
        }
      }
      return true;
    });
  }
  /**
   * Start the initial sync process.
   * Scans all markdown files in the vault and updates their status in the database.
   * If interrupted, resumes from the last processed file.
   */
  async startSync() {
    if (this.isRunning) {
      console.log("Initial sync already running");
      return;
    }
    try {
      this.isRunning = true;
      this.progress.startTime = Date.now();
      const allFiles = this.vault.getMarkdownFiles();
      const files = this.filterExcludedFiles(allFiles);
      const syncFilePath = this.options.syncFilePath || "_mindmatrixsync.md";
      const syncFileIncluded = files.some(
        (file) => file.path === syncFilePath || file.path === "_mindmatrixsync.md" || file.path === "_mindmatrixsync.md.backup"
      );
      this.resumeFileList = await this.sortFilesByPriority(files);
      this.progress.totalFiles = this.resumeFileList.length;
      this.batches = this.createBatches(this.resumeFileList.slice(this.lastProcessedIndex));
      this.progress.totalBatches = this.batches.length;
      await this.processBatches();
      new import_obsidian10.Notice("Initial sync completed successfully");
      this.lastProcessedIndex = 0;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "InitialSyncManager.startSync" });
      new import_obsidian10.Notice("Initial sync failed. Check console for details.");
    } finally {
      this.isRunning = false;
    }
  }
  /**
   * Sort files by priority based on rules.
   */
  async sortFilesByPriority(files) {
    return files.sort((a, b) => {
      const priorityA = this.getFilePriority(a.path);
      const priorityB = this.getFilePriority(b.path);
      return priorityB - priorityA;
    });
  }
  /**
   * Determine the processing priority for a file.
   */
  getFilePriority(path) {
    for (const rule of this.options.priorityRules) {
      if (path.includes(rule.pattern)) {
        return rule.priority;
      }
    }
    return 1;
  }
  /**
   * Create batches of files for processing.
   */
  createBatches(files) {
    const syncFilePath = this.options.syncFilePath || "_mindmatrixsync.md";
    const syncFileIncluded = files.some(
      (file) => file.path === syncFilePath || file.path === "_mindmatrixsync.md" || file.path === "_mindmatrixsync.md.backup"
    );
    if (syncFileIncluded) {
      files = files.filter(
        (file) => file.path !== syncFilePath && file.path !== "_mindmatrixsync.md" && file.path !== "_mindmatrixsync.md.backup"
      );
    }
    const batches = [];
    for (let i = 0; i < files.length; i += this.options.batchSize) {
      const batchFiles = files.slice(i, i + this.options.batchSize);
      batches.push({
        id: `batch-${Math.floor(i / this.options.batchSize)}`,
        files: batchFiles,
        status: "pending",
        progress: 0
      });
    }
    return batches;
  }
  /**
   * Process batches concurrently with a limit.
   * Also updates resume progress in case of interruption.
   */
  async processBatches() {
    const activeBatches = /* @__PURE__ */ new Set();
    for (const batch of this.batches) {
      while (activeBatches.size >= this.options.maxConcurrentBatches) {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
      activeBatches.add(batch.id);
      this.processBatch(batch).then(() => {
        activeBatches.delete(batch.id);
        this.lastProcessedIndex += batch.files.length;
      }).catch((error) => {
        this.errorHandler.handleError(error, {
          context: "InitialSyncManager.processBatch",
          metadata: { batchId: batch.id }
        });
        activeBatches.delete(batch.id);
      });
    }
    while (activeBatches.size > 0) {
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }
  /**
   * Process a single batch of files.
   */
  async processBatch(batch) {
    try {
      batch.status = "processing";
      batch.startTime = Date.now();
      for (const file of batch.files) {
        try {
          await this.processFile(file);
          this.progress.processedFiles++;
          batch.progress = this.progress.processedFiles / this.progress.totalFiles * 100;
          this.updateProgressNotification();
        } catch (error) {
          this.errorHandler.handleError(error, {
            context: "InitialSyncManager.processFile",
            metadata: { filePath: file.path }
          });
        }
      }
      batch.status = "completed";
      batch.endTime = Date.now();
    } catch (error) {
      batch.status = "failed";
      throw error;
    }
  }
  /**
   * Process a single file.
   * Extracts metadata, calculates file hash, and updates its status.
   */
  async processFile(file) {
    try {
      const syncFilePath = this.options.syncFilePath || "_mindmatrixsync.md";
      if (file.path === syncFilePath || file.path === "_mindmatrixsync.md" || file.path === "_mindmatrixsync.md.backup") {
        return;
      }
      const metadata = await this.metadataExtractor.extractMetadata(file);
      const fileHash = await this.calculateFileHash(file);
      if (this.supabaseService) {
        await this.supabaseService.updateFileVectorizationStatus(metadata);
      } else {
        await this.syncFileManager.updateSyncStatus(file.path, "PENDING", {
          lastModified: file.stat.mtime,
          hash: fileHash
        });
      }
      await new Promise((resolve, reject) => {
        this.queueService.addTask({
          id: file.path,
          type: "CREATE",
          priority: this.getFilePriority(file.path),
          maxRetries: 3,
          retryCount: 0,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          status: "PENDING",
          metadata,
          data: {}
        }).then(async () => {
          if (this.supabaseService) {
            await this.supabaseService.updateFileVectorizationStatus(metadata);
          } else {
            await this.syncFileManager.updateSyncStatus(file.path, "OK", {
              lastModified: file.stat.mtime,
              hash: fileHash
            });
          }
          resolve();
        }).catch(reject);
      });
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "InitialSyncManager.processFile",
        metadata: { filePath: file.path }
      });
      throw error;
    }
  }
  /**
   * Calculate SHA-256 hash of a file's content.
   */
  async calculateFileHash(file) {
    const content = await this.vault.read(file);
    const encoder = new TextEncoder();
    const data = encoder.encode(content);
    const buffer = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(buffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  /**
   * Update progress notifications.
   */
  updateProgressNotification() {
    const progressPercentage = this.progress.processedFiles / this.progress.totalFiles * 100;
    this.notificationManager.updateProgress({
      taskId: "initial-sync",
      progress: progressPercentage,
      currentStep: `Processing files (${this.progress.processedFiles}/${this.progress.totalFiles})`,
      totalSteps: this.progress.totalBatches,
      currentStepNumber: this.progress.currentBatch + 1,
      estimatedTimeRemaining: this.calculateEstimatedTimeRemaining(),
      details: {
        processedFiles: this.progress.processedFiles,
        totalFiles: this.progress.totalFiles
      }
    });
  }
  /**
   * Calculate estimated time remaining based on progress.
   */
  calculateEstimatedTimeRemaining() {
    const elapsed = Date.now() - this.progress.startTime;
    const filesPerMs = this.progress.processedFiles / elapsed;
    const remainingFiles = this.progress.totalFiles - this.progress.processedFiles;
    return filesPerMs > 0 ? remainingFiles / filesPerMs : 0;
  }
  /**
   * Update sync progress notifications.
   */
  updateProgressNotificationBatch() {
    this.updateProgressNotification();
  }
  /**
   * Stop the initial sync process.
   */
  stop() {
    this.isRunning = false;
    if (this.processingTimeout) {
      clearTimeout(this.processingTimeout);
      this.processingTimeout = null;
    }
  }
  /**
   * Get current sync progress.
   */
  getProgress() {
    return { ...this.progress };
  }
  /**
   * Update sync options.
   */
  updateOptions(options) {
    Object.assign(this.options, options);
  }
};

// services/StatusManager.ts
var import_obsidian11 = require("obsidian");
var StatusManager = class {
  constructor(statusBarItem) {
    this.statusBarItem = statusBarItem;
    this.currentStatus = "initializing" /* INITIALIZING */;
    this.statusDetails = {
      message: "Initializing plugin...",
      timestamp: Date.now(),
      connectivityStatus: "unknown"
    };
    this.subscribers = /* @__PURE__ */ new Set();
    this.updateStatusBar();
  }
  /**
   * Update the current status with new details.
   */
  setStatus(status, details = {}) {
    const oldStatus = this.currentStatus;
    this.currentStatus = status;
    this.statusDetails = {
      ...this.statusDetails,
      ...details,
      timestamp: Date.now()
    };
    this.updateStatusBar();
    if (oldStatus !== status) {
      this.notifySubscribers();
    }
    if (status === "error" /* ERROR */ && details.message) {
      new import_obsidian11.Notice(`Mind Matrix: ${details.message}`);
    }
  }
  /**
   * Get the current status and details.
   */
  getStatus() {
    return { status: this.currentStatus, details: { ...this.statusDetails } };
  }
  /**
   * Subscribe to status changes.
   */
  subscribe(callback) {
    this.subscribers.add(callback);
    return () => {
      this.subscribers.delete(callback);
    };
  }
  /**
   * Update the status bar UI.
   */
  updateStatusBar() {
    this.statusBarItem.innerHTML = "";
    const statusIcon = this.createStatusIcon();
    this.statusBarItem.appendChild(statusIcon);
    const detailsText = document.createElement("span");
    detailsText.addClass("mind-matrix-status-details");
    detailsText.textContent = this.statusDetails.message;
    this.statusBarItem.appendChild(detailsText);
    let tooltip = this.statusDetails.message;
    if (this.statusDetails.connectivityStatus) {
      tooltip += ` | Connectivity: ${this.statusDetails.connectivityStatus}`;
    }
    if (this.statusDetails.lastDatabaseCheck) {
      tooltip += ` | Last DB Check: ${new Date(this.statusDetails.lastDatabaseCheck).toLocaleTimeString()}`;
    }
    this.statusBarItem.setAttribute("aria-label", tooltip);
    this.statusBarItem.onclick = () => {
      new import_obsidian11.Notice(tooltip);
    };
  }
  /**
   * Create status icon element based on current status.
   */
  createStatusIcon() {
    const icon = document.createElement("span");
    icon.addClass("mind-matrix-status-icon");
    switch (this.currentStatus) {
      case "ready" /* READY */:
        icon.addClass("is-ready");
        icon.innerHTML = "\u25CF";
        break;
      case "error" /* ERROR */:
        icon.addClass("is-error");
        icon.innerHTML = "\u26A0";
        break;
      case "waiting_sync" /* WAITING_FOR_SYNC */:
      case "checking_file" /* CHECKING_FILE */:
        icon.addClass("is-working");
        icon.innerHTML = "\u21BB";
        break;
      default:
        icon.addClass("is-initializing");
        icon.innerHTML = "\u25CB";
    }
    return icon;
  }
  /**
   * Notify all subscribers of a status change.
   */
  notifySubscribers() {
    this.subscribers.forEach((callback) => {
      try {
        callback(this.currentStatus, this.statusDetails);
      } catch (error) {
        console.error("Error in status change subscriber:", error);
      }
    });
  }
  /**
   * Check if the plugin is currently in a specific status.
   */
  isInStatus(status) {
    return this.currentStatus === status;
  }
  /**
   * Update progress for the current task.
   */
  updateProgress(progress) {
    this.statusDetails.progress = progress;
    this.updateStatusBar();
  }
};

// services/SyncDetectionManager.ts
var SyncDetectionManager = class {
  // 5 seconds
  constructor(plugin, statusManager, onQuietPeriodReached) {
    this.plugin = plugin;
    this.statusManager = statusManager;
    this.onQuietPeriodReached = onQuietPeriodReached;
    this.lastSyncActivity = 0;
    this.syncCheckInterval = null;
    this.quietPeriodReached = false;
    this.isWaitingForQuietPeriod = false;
    this.QUIET_PERIOD_MS = 5e3;
  }
  /**
   * Start monitoring for sync activity
   */
  startMonitoring() {
    this.plugin.registerEvent(
      this.plugin.app.vault.on("modify", () => this.recordSyncActivity())
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("create", () => this.recordSyncActivity())
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("delete", () => this.recordSyncActivity())
    );
    this.startQuietPeriodCheck();
  }
  /**
   * Record sync activity and reset quiet period
   */
  recordSyncActivity() {
    this.lastSyncActivity = Date.now();
    this.quietPeriodReached = false;
    if (this.isWaitingForQuietPeriod) {
      this.statusManager.setStatus("waiting_sync" /* WAITING_FOR_SYNC */, {
        message: "Waiting for Obsidian sync to settle..."
      });
    }
  }
  /**
   * Start checking for quiet period
   */
  startQuietPeriodCheck() {
    if (this.syncCheckInterval) {
      clearInterval(this.syncCheckInterval);
    }
    this.isWaitingForQuietPeriod = true;
    this.syncCheckInterval = setInterval(() => {
      const timeSinceLastSync = Date.now() - this.lastSyncActivity;
      if (timeSinceLastSync >= this.QUIET_PERIOD_MS && !this.quietPeriodReached) {
        this.quietPeriodReached = true;
        this.isWaitingForQuietPeriod = false;
        if (this.syncCheckInterval) {
          clearInterval(this.syncCheckInterval);
          this.syncCheckInterval = null;
        }
        this.onQuietPeriodReached();
      }
    }, 1e3);
  }
  /**
   * Stop monitoring for sync activity
   */
  stopMonitoring() {
    if (this.syncCheckInterval) {
      clearInterval(this.syncCheckInterval);
      this.syncCheckInterval = null;
    }
    this.isWaitingForQuietPeriod = false;
  }
  /**
   * Check if currently waiting for quiet period
   */
  isWaiting() {
    return this.isWaitingForQuietPeriod;
  }
  /**
   * Get time since last sync activity
   */
  getTimeSinceLastSync() {
    return Date.now() - this.lastSyncActivity;
  }
};

// main.ts
var MindMatrixPlugin = class extends import_obsidian12.Plugin {
  constructor() {
    super(...arguments);
    this.supabaseService = null;
    this.openAIService = null;
    this.queueService = null;
    this.fileTracker = null;
    this.errorHandler = null;
    this.notificationManager = null;
    this.isInitializing = false;
    this.syncManager = null;
    this.syncCheckInterval = null;
    this.initializationTimeout = null;
    this.syncCheckAttempts = 0;
    this.initialSyncManager = null;
    this.metadataExtractor = null;
    this.statusManager = null;
    this.syncDetectionManager = null;
  }
  async onload() {
    var _a2;
    console.log("Loading Mind Matrix Plugin...");
    try {
      this.statusManager = new StatusManager(this.addStatusBarItem());
      this.statusManager.setStatus("initializing" /* INITIALIZING */, {
        message: "Loading Mind Matrix Plugin..."
      });
      await this.loadSettings();
      await this.initializeCoreServices();
      await this.initializeVaultIfNeeded();
      this.addSettingTab(new MindMatrixSettingsTab(this.app, this));
      if (isVaultInitialized(this.settings)) {
        this.statusManager.setStatus("waiting_sync" /* WAITING_FOR_SYNC */, {
          message: "Waiting for Obsidian sync to settle..."
        });
        this.syncDetectionManager = new SyncDetectionManager(
          this,
          this.statusManager,
          this.onSyncQuietPeriodReached.bind(this)
        );
        this.syncDetectionManager.startMonitoring();
      } else {
        await this.completeInitialization();
      }
    } catch (error) {
      console.error("Failed to initialize Mind Matrix Plugin:", error);
      (_a2 = this.statusManager) == null ? void 0 : _a2.setStatus("error" /* ERROR */, {
        message: "Failed to initialize plugin. Check console for details.",
        error
      });
    }
  }
  async onSyncQuietPeriodReached() {
    var _a2, _b, _c;
    try {
      (_a2 = this.syncDetectionManager) == null ? void 0 : _a2.stopMonitoring();
      (_b = this.statusManager) == null ? void 0 : _b.setStatus("checking_file" /* CHECKING_FILE */, {
        message: "Initializing sync manager with updated sync file format..."
      });
      await this.initializeSyncManager();
      await this.startSyncProcess();
      await this.completeInitialization();
    } catch (error) {
      console.error("Error during quiet period initialization:", error);
      (_c = this.statusManager) == null ? void 0 : _c.setStatus("error" /* ERROR */, {
        message: "Failed to initialize after sync quiet period",
        error
      });
    }
  }
  async completeInitialization() {
    var _a2, _b;
    try {
      this.registerEventHandlers();
      this.addCommands();
      (_a2 = this.statusManager) == null ? void 0 : _a2.setStatus("ready" /* READY */, {
        message: "Mind Matrix is ready"
      });
    } catch (error) {
      console.error("Error completing initialization:", error);
      (_b = this.statusManager) == null ? void 0 : _b.setStatus("error" /* ERROR */, {
        message: "Failed to complete initialization",
        error
      });
    }
  }
  async onunload() {
    var _a2, _b, _c, _d;
    console.log("Unloading Mind Matrix Plugin...");
    (_a2 = this.syncDetectionManager) == null ? void 0 : _a2.stopMonitoring();
    if (this.initializationTimeout) {
      clearTimeout(this.initializationTimeout);
    }
    if (this.syncCheckInterval) {
      clearInterval(this.syncCheckInterval);
    }
    (_b = this.queueService) == null ? void 0 : _b.stop();
    (_c = this.notificationManager) == null ? void 0 : _c.clear();
    (_d = this.initialSyncManager) == null ? void 0 : _d.stop();
  }
  async startSyncProcess() {
    var _a2, _b, _c, _d, _e, _f;
    if (!this.syncManager) {
      throw new Error("Sync manager not initialized");
    }
    try {
      (_a2 = this.statusManager) == null ? void 0 : _a2.setStatus("checking_file" /* CHECKING_FILE */, {
        message: "Checking sync file status with new structure..."
      });
      const syncStatus = await this.syncManager.validateSyncState();
      if (!syncStatus.isValid) {
        if (this.settings.sync.requireSync) {
          (_b = this.statusManager) == null ? void 0 : _b.setStatus("error" /* ERROR */, {
            message: `Sync validation failed: ${syncStatus.error}`
          });
          throw new Error(`Sync validation failed: ${syncStatus.error}`);
        } else {
          console.warn(`Sync validation warning: ${syncStatus.error}`);
          new import_obsidian12.Notice(`Sync warning: ${syncStatus.error}`);
        }
      }
      (_c = this.statusManager) == null ? void 0 : _c.setStatus("initializing" /* INITIALIZING */, {
        message: "Initializing services..."
      });
      await this.initializeServices();
      this.startPeriodicSyncChecks();
      if (this.settings.initialSync.enableAutoInitialSync && this.initialSyncManager) {
        (_d = this.statusManager) == null ? void 0 : _d.setStatus("initializing" /* INITIALIZING */, {
          message: "Starting initial vault sync..."
        });
        await this.initialSyncManager.startSync();
      }
      (_e = this.statusManager) == null ? void 0 : _e.setStatus("ready" /* READY */, {
        message: "Sync process completed"
      });
    } catch (error) {
      if (this.settings.sync.requireSync) {
        (_f = this.statusManager) == null ? void 0 : _f.setStatus("error" /* ERROR */, {
          message: "Sync process failed",
          error
        });
        throw error;
      } else {
        console.error("Sync process error:", error);
        new import_obsidian12.Notice("Sync process error. Continuing with limited functionality.");
        await this.initializeServices();
      }
    }
  }
  async initializeSyncManager() {
    if (!this.errorHandler) {
      throw new Error("Error handler must be initialized before sync manager");
    }
    if (!this.settings.vaultId) {
      this.settings.vaultId = generateVaultId();
      await this.saveSettings();
    }
    try {
      this.syncManager = new SyncFileManager(
        this.app.vault,
        this.errorHandler,
        this.settings.sync.syncFilePath,
        this.settings.sync.backupInterval,
        this.settings.vaultId,
        // Now guaranteed to be defined
        this.settings.sync.deviceId,
        this.settings.sync.deviceName,
        this.manifest.version
      );
      await this.syncManager.initialize();
      console.log("Sync manager initialized successfully with new sync file format");
    } catch (error) {
      console.error("Failed to initialize sync manager:", error);
      if (this.settings.enableNotifications) {
        new import_obsidian12.Notice("Failed to initialize sync system. Some features may be unavailable.");
      }
      throw error;
    }
  }
  async initializeCoreServices() {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    (_a2 = this.statusManager) == null ? void 0 : _a2.setStatus("initializing" /* INITIALIZING */, {
      message: "Initializing core services..."
    });
    this.errorHandler = new ErrorHandler(
      (_c = (_b = this.settings) == null ? void 0 : _b.debug) != null ? _c : DEFAULT_SETTINGS.debug,
      this.app.vault.adapter.getBasePath()
    );
    this.notificationManager = new NotificationManager(
      this.addStatusBarItem(),
      (_e = (_d = this.settings) == null ? void 0 : _d.enableNotifications) != null ? _e : true,
      (_g = (_f = this.settings) == null ? void 0 : _f.enableProgressBar) != null ? _g : true
    );
    (_h = this.statusManager) == null ? void 0 : _h.setStatus("initializing" /* INITIALIZING */, {
      message: "Core services initialized"
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (!this.settings.exclusions) {
      this.settings.exclusions = { ...DEFAULT_SETTINGS.exclusions };
    }
    if (!this.settings.exclusions.excludedFolders) {
      this.settings.exclusions.excludedFolders = [];
    }
    if (!this.settings.exclusions.excludedFileTypes) {
      this.settings.exclusions.excludedFileTypes = [];
    }
    if (!this.settings.exclusions.excludedFilePrefixes) {
      this.settings.exclusions.excludedFilePrefixes = [];
    }
    if (!this.settings.exclusions.excludedFiles) {
      this.settings.exclusions.excludedFiles = [];
    }
    if (!this.settings.exclusions.systemExcludedFolders) {
      this.settings.exclusions.systemExcludedFolders = [...SYSTEM_EXCLUSIONS.folders];
    }
    if (!this.settings.exclusions.systemExcludedFileTypes) {
      this.settings.exclusions.systemExcludedFileTypes = [...SYSTEM_EXCLUSIONS.fileTypes];
    }
    if (!this.settings.exclusions.systemExcludedFilePrefixes) {
      this.settings.exclusions.systemExcludedFilePrefixes = [...SYSTEM_EXCLUSIONS.filePrefixes];
    }
    if (!this.settings.exclusions.systemExcludedFiles) {
      this.settings.exclusions.systemExcludedFiles = [...SYSTEM_EXCLUSIONS.files];
    }
  }
  async saveSettings() {
    var _a2, _b;
    await this.saveData(this.settings);
    (_a2 = this.notificationManager) == null ? void 0 : _a2.updateSettings(
      this.settings.enableNotifications,
      this.settings.enableProgressBar
    );
    (_b = this.errorHandler) == null ? void 0 : _b.updateSettings(this.settings.debug);
    if (isVaultInitialized(this.settings)) {
      await this.initializeServices();
    }
  }
  startPeriodicSyncChecks() {
    if (this.syncCheckInterval) {
      clearInterval(this.syncCheckInterval);
    }
    this.syncCheckInterval = setInterval(async () => {
      await this.performSyncCheck();
    }, this.settings.sync.checkInterval);
  }
  async performSyncCheck() {
    var _a2;
    if (!this.syncManager)
      return;
    try {
      const syncStatus = await this.syncManager.validateSyncState();
      if (!syncStatus.isValid) {
        console.warn(`Sync check failed: ${syncStatus.error}`);
        if (this.settings.enableNotifications) {
          new import_obsidian12.Notice(`Sync issue detected: ${syncStatus.error}`);
        }
        const recovered = await this.syncManager.attemptRecovery();
        if (!recovered && this.settings.sync.requireSync) {
          await this.restartServices();
        }
      }
      await this.syncManager.updateLastSync();
    } catch (error) {
      (_a2 = this.errorHandler) == null ? void 0 : _a2.handleError(error, {
        context: "performSyncCheck",
        metadata: { timestamp: Date.now() }
      });
    }
  }
  async restartServices() {
    var _a2;
    (_a2 = this.queueService) == null ? void 0 : _a2.stop();
    if (this.syncCheckInterval) {
      clearInterval(this.syncCheckInterval);
    }
    try {
      await this.initializeSyncManager();
      await this.startSyncProcess();
    } catch (error) {
      console.error("Failed to restart services:", error);
      if (this.settings.enableNotifications) {
        new import_obsidian12.Notice("Failed to restart services after sync error");
      }
    }
  }
  async initializeVaultIfNeeded() {
    if (this.isInitializing)
      return;
    this.isInitializing = true;
    try {
      if (!isVaultInitialized(this.settings)) {
        this.settings.vaultId = generateVaultId();
        this.settings.lastKnownVaultName = this.app.vault.getName();
        await this.saveSettings();
        if (this.settings.enableNotifications) {
          new import_obsidian12.Notice("Vault initialized with new ID");
        }
      } else if (this.settings.lastKnownVaultName !== this.app.vault.getName()) {
        this.settings.lastKnownVaultName = this.app.vault.getName();
        await this.saveSettings();
      }
    } finally {
      this.isInitializing = false;
    }
  }
  async initializeServices() {
    console.log("Initializing services...", {
      hasVault: !!this.app.vault,
      hasErrorHandler: !!this.errorHandler
    });
    if (!this.errorHandler) {
      throw new Error("Core services not initialized");
    }
    try {
      this.fileTracker = new FileTracker(this.app.vault, this.errorHandler, this.settings.sync.syncFilePath);
      await this.fileTracker.initialize();
      console.log("FileTracker initialized.");
      try {
        this.supabaseService = await SupabaseService.getInstance(this.settings);
        if (!this.supabaseService) {
          new import_obsidian12.Notice("Supabase service not initialized. Please configure your API settings.");
          console.error("Supabase service initialization failed: Missing configuration.");
          return;
        }
        console.log("Supabase service initialized.");
      } catch (error) {
        console.error("Supabase initialization error:", error);
        new import_obsidian12.Notice(`Failed to initialize Supabase service: ${error.message}`);
        return;
      }
      this.openAIService = new OpenAIService(this.settings.openai, this.errorHandler);
      console.log("OpenAI service initialized.");
      if (!this.app.vault) {
        throw new Error("Vault is not available");
      }
      if (this.notificationManager && this.supabaseService && this.openAIService) {
        try {
          this.queueService = new QueueService(
            this.settings.queue.maxConcurrent,
            this.settings.queue.retryAttempts,
            this.supabaseService,
            this.openAIService,
            this.errorHandler,
            this.notificationManager,
            this.app.vault,
            this.settings.chunking
          );
          this.queueService.start();
          console.log("Queue service initialized and started.");
        } catch (error) {
          console.error("Failed to initialize QueueService:", error);
          new import_obsidian12.Notice(`Failed to initialize queue service: ${error.message}`);
          throw error;
        }
      } else {
        throw new Error("Required services not available for QueueService initialization");
      }
      this.metadataExtractor = new MetadataExtractor();
      console.log("MetadataExtractor initialized.");
      if (this.queueService && this.syncManager && this.metadataExtractor) {
        const initialSyncOptions = {
          ...this.settings.initialSync,
          syncFilePath: this.settings.sync.syncFilePath,
          exclusions: getAllExclusions(this.settings)
        };
        this.initialSyncManager = new InitialSyncManager(
          this.app.vault,
          this.queueService,
          this.syncManager,
          this.metadataExtractor,
          this.errorHandler,
          this.notificationManager,
          this.supabaseService,
          initialSyncOptions
        );
        console.log("InitialSyncManager initialized.");
      }
    } catch (error) {
      console.error("Failed to initialize services:", error);
      throw error;
    }
  }
  checkRequiredConfigurations() {
    if (!this.settings.openai.apiKey) {
      new import_obsidian12.Notice("OpenAI API key is missing. AI features are disabled. Configure it in the settings.");
    }
    if (!this.settings.supabase.url || !this.settings.supabase.apiKey) {
      new import_obsidian12.Notice("Supabase configuration is incomplete. Database features are disabled. Configure it in the settings.");
    }
  }
  registerEventHandlers() {
    this.registerEvent(
      this.app.vault.on("create", async (file) => {
        var _a2;
        if (!(file instanceof import_obsidian12.TFile))
          return;
        if (!await this.ensureSyncFileExists()) {
          new import_obsidian12.Notice("Failed to create sync file. Plugin functionality limited.");
          return;
        }
        if (!this.shouldProcessFile(file))
          return;
        await ((_a2 = this.fileTracker) == null ? void 0 : _a2.handleCreate(file));
        await this.queueFileProcessing(file, "CREATE");
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", async (file) => {
        var _a2;
        if (!(file instanceof import_obsidian12.TFile))
          return;
        if (!await this.ensureSyncFileExists()) {
          new import_obsidian12.Notice("Failed to create sync file. Plugin functionality limited.");
          return;
        }
        if (!this.shouldProcessFile(file))
          return;
        await ((_a2 = this.fileTracker) == null ? void 0 : _a2.handleModify(file));
        await this.queueFileProcessing(file, "UPDATE");
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", async (file) => {
        var _a2;
        if (!(file instanceof import_obsidian12.TFile))
          return;
        if (file.path === this.settings.sync.syncFilePath) {
          console.log("Sync file was deleted, will recreate on next operation");
          return;
        }
        if (!await this.ensureSyncFileExists()) {
          new import_obsidian12.Notice("Failed to create sync file. Plugin functionality limited.");
          return;
        }
        if (!this.shouldProcessFile(file))
          return;
        await ((_a2 = this.fileTracker) == null ? void 0 : _a2.handleDelete(file));
        await this.queueFileProcessing(file, "DELETE");
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", async (file, oldPath) => {
        var _a2;
        if (!(file instanceof import_obsidian12.TFile))
          return;
        if (!await this.ensureSyncFileExists()) {
          new import_obsidian12.Notice("Failed to create sync file. Plugin functionality limited.");
          return;
        }
        if (!this.shouldProcessFile(file))
          return;
        await ((_a2 = this.fileTracker) == null ? void 0 : _a2.handleRename(file, oldPath));
        await this.handleFileRename(file, oldPath);
      })
    );
  }
  shouldProcessFile(file) {
    if (!this.queueService || !isVaultInitialized(this.settings)) {
      return false;
    }
    if (!this.settings.enableAutoSync) {
      return false;
    }
    const allExclusions = getAllExclusions(this.settings);
    const filePath = file.path;
    const fileName = file.name;
    if (filePath === this.settings.sync.syncFilePath || filePath === this.settings.sync.syncFilePath + ".backup") {
      console.log(`Explicitly skipping sync file: ${filePath}`);
      return false;
    }
    if (Array.isArray(allExclusions.excludedFiles) && allExclusions.excludedFiles.includes(fileName)) {
      console.log("Skipping excluded file:", fileName);
      return false;
    }
    if (Array.isArray(allExclusions.excludedFolders)) {
      const isExcludedFolder = allExclusions.excludedFolders.some((folder) => {
        const normalizedFolder = folder.endsWith("/") ? folder : folder + "/";
        return filePath.startsWith(normalizedFolder);
      });
      if (isExcludedFolder) {
        console.log("Skipping file in excluded folder:", filePath);
        return false;
      }
    }
    if (Array.isArray(allExclusions.excludedFileTypes)) {
      const isExcludedType = allExclusions.excludedFileTypes.some(
        (ext) => filePath.toLowerCase().endsWith(ext.toLowerCase())
      );
      if (isExcludedType) {
        console.log("Skipping excluded file type:", filePath);
        return false;
      }
    }
    if (Array.isArray(allExclusions.excludedFilePrefixes)) {
      const isExcludedPrefix = allExclusions.excludedFilePrefixes.some(
        (prefix) => fileName.startsWith(prefix)
      );
      if (isExcludedPrefix) {
        console.log("Skipping file with excluded prefix:", fileName);
        return false;
      }
    }
    return true;
  }
  async ensureSyncFileExists() {
    if (!this.syncManager) {
      console.error("Sync manager not initialized");
      return false;
    }
    try {
      const syncFile = this.app.vault.getAbstractFileByPath(this.settings.sync.syncFilePath);
      if (!syncFile) {
        console.log("Sync file missing, recreating...");
        await this.syncManager.initialize();
        new import_obsidian12.Notice("Recreated sync file");
        return true;
      }
      return true;
    } catch (error) {
      console.error("Error ensuring sync file exists:", error);
      return false;
    }
  }
  async queueFileProcessing(file, type) {
    var _a2;
    try {
      if (!this.queueService || !this.fileTracker) {
        console.error("Required services not initialized:", {
          queueService: !!this.queueService,
          fileTracker: !!this.fileTracker
        });
        return;
      }
      console.log("Starting file processing:", {
        fileName: file.name,
        type,
        path: file.path
      });
      const metadata = await this.fileTracker.createFileMetadata(file);
      console.log("Created metadata:", metadata);
      const task = {
        id: file.path,
        type,
        priority: type === "DELETE" ? 2 : 1,
        maxRetries: this.settings.queue.retryAttempts,
        retryCount: 0,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        status: "PENDING",
        metadata,
        data: {}
      };
      console.log("Created task:", task);
      await this.queueService.addTask(task);
      console.log("Task added to queue");
      if (this.settings.enableNotifications) {
        const action = type.toLowerCase();
        new import_obsidian12.Notice(`Queued ${action} for processing: ${file.name}`);
      }
    } catch (error) {
      console.error("Error in queueFileProcessing:", error);
      (_a2 = this.errorHandler) == null ? void 0 : _a2.handleError(error, {
        context: "queueFileProcessing",
        metadata: { filePath: file.path, type }
      });
      if (this.settings.enableNotifications) {
        new import_obsidian12.Notice(`Failed to queue ${file.name} for processing`);
      }
    }
  }
  async handleFileRename(file, oldPath) {
    var _a2;
    try {
      if (!this.supabaseService)
        return;
      const chunks = await this.supabaseService.getDocumentChunks(oldPath);
      if (chunks.length > 0) {
        const updatedChunks = chunks.map((chunk) => ({
          ...chunk,
          metadata: {
            ...chunk.metadata,
            obsidianId: file.path,
            path: file.path
          }
        }));
        await this.supabaseService.deleteDocumentChunks(oldPath);
        await this.supabaseService.upsertChunks(updatedChunks);
        if (this.settings.enableNotifications) {
          new import_obsidian12.Notice(`Updated database entries for renamed file: ${file.name}`);
        }
      }
    } catch (error) {
      (_a2 = this.errorHandler) == null ? void 0 : _a2.handleError(error, {
        context: "handleFileRename",
        metadata: { filePath: file.path, oldPath }
      });
      if (this.settings.enableNotifications) {
        new import_obsidian12.Notice(`Failed to update database for renamed file: ${file.name}`);
      }
    }
  }
  addCommands() {
    this.addCommand({
      id: "force-sync-current-file",
      name: "Force sync current file",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          if (!checking) {
            this.queueFileProcessing(file, "UPDATE");
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "force-sync-all-files",
      name: "Force sync all files",
      callback: async () => {
        const files = this.app.vault.getMarkdownFiles();
        for (const file of files) {
          if (this.shouldProcessFile(file)) {
            await this.queueFileProcessing(file, "UPDATE");
          }
        }
      }
    });
    this.addCommand({
      id: "clear-sync-queue",
      name: "Clear sync queue",
      callback: () => {
        var _a2;
        (_a2 = this.queueService) == null ? void 0 : _a2.clear();
        if (this.settings.enableNotifications) {
          new import_obsidian12.Notice("Sync queue cleared");
        }
      }
    });
    this.addCommand({
      id: "reset-file-tracker",
      name: "Reset file tracker cache",
      callback: async () => {
        var _a2, _b;
        (_a2 = this.fileTracker) == null ? void 0 : _a2.clearQueue();
        await ((_b = this.fileTracker) == null ? void 0 : _b.initialize());
        if (this.settings.enableNotifications) {
          new import_obsidian12.Notice("File tracker cache reset");
        }
      }
    });
    this.addCommand({
      id: "start-initial-sync",
      name: "Start initial vault sync",
      callback: async () => {
        if (this.initialSyncManager) {
          await this.initialSyncManager.startSync();
        } else {
          new import_obsidian12.Notice("Initial sync manager not initialized");
        }
      }
    });
    this.addCommand({
      id: "stop-initial-sync",
      name: "Stop initial vault sync",
      callback: () => {
        var _a2;
        (_a2 = this.initialSyncManager) == null ? void 0 : _a2.stop();
        new import_obsidian12.Notice("Initial sync stopped");
      }
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9ub2RlLWZldGNoL2Jyb3dzZXIuanMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL1Bvc3RncmVzdEVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RCdWlsZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9zcmMvUG9zdGdyZXN0Q2xpZW50LnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9pbmRleC50cyIsICJub2RlX21vZHVsZXMvd3MvYnJvd3Nlci5qcyIsICJtYWluLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL3NyYy9oZWxwZXIudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9mdW5jdGlvbnMtanMvc3JjL3R5cGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL3NyYy9GdW5jdGlvbnNDbGllbnQudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9lc20vd3JhcHBlci5tanMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvc2VyaWFsaXplci50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvdGltZXIudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL3RyYW5zZm9ybWVycy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvcHVzaC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9SZWFsdGltZVByZXNlbmNlLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvc3JjL1JlYWx0aW1lQ2hhbm5lbC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9SZWFsdGltZUNsaWVudC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL2xpYi9lcnJvcnMudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL3NyYy9saWIvaGVscGVycy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL2xpYi9mZXRjaC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL3BhY2thZ2VzL1N0b3JhZ2VGaWxlQXBpLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL3NyYy9saWIvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9zcmMvcGFja2FnZXMvU3RvcmFnZUJ1Y2tldEFwaS50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL1N0b3JhZ2VDbGllbnQudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9saWIvZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL2hlbHBlcnMudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvdmVyc2lvbi50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvaGVscGVycy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9lcnJvcnMudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9Hb1RydWVBZG1pbkFwaS50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9sb2NhbC1zdG9yYWdlLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9zcmMvbGliL3BvbHlmaWxscy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9sb2Nrcy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL0dvVHJ1ZUNsaWVudC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL0F1dGhDbGllbnQudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL1N1cGFiYXNlQXV0aENsaWVudC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9TdXBhYmFzZUNsaWVudC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9pbmRleC50cyIsICJzZXR0aW5ncy9TZXR0aW5ncy50cyIsICJzZXJ2aWNlcy9TdXBhYmFzZVNlcnZpY2UudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvaW50ZXJuYWwvcXMvZm9ybWF0cy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9pbnRlcm5hbC9xcy91dGlscy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9pbnRlcm5hbC9xcy9zdHJpbmdpZnkudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvdmVyc2lvbi50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9fc2hpbXMvcmVnaXN0cnkudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvX3NoaW1zL011bHRpcGFydEJvZHkudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvX3NoaW1zL3dlYi1ydW50aW1lLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvX3NoaW1zL2luZGV4Lm1qcyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9lcnJvci50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9pbnRlcm5hbC9kZWNvZGVycy9saW5lLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3N0cmVhbWluZy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy91cGxvYWRzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2NvcmUudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcGFnaW5hdGlvbi50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZS50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvY2hhdC9jaGF0LnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9hdWRpby9zcGVlY2gudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2F1ZGlvL3RyYW5zY3JpcHRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9hdWRpby90cmFuc2xhdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2F1ZGlvL2F1ZGlvLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iYXRjaGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL2Fzc2lzdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL1J1bm5hYmxlRnVuY3Rpb24udHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL2NoYXRDb21wbGV0aW9uVXRpbHMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0V2ZW50U3RyZWFtLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2xpYi9wYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXIudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0NoYXRDb21wbGV0aW9uUnVubmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL192ZW5kb3IvcGFydGlhbC1qc29uLXBhcnNlci9wYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2xpYi9DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lci50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9jaGF0L2NvbXBsZXRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL2NoYXQvY2hhdC50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9yZWFsdGltZS9zZXNzaW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9yZWFsdGltZS9yZWFsdGltZS50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9saWIvQXNzaXN0YW50U3RyZWFtLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvbWVzc2FnZXMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2JldGEvdGhyZWFkcy9ydW5zL3N0ZXBzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvcnVucy9ydW5zLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvdGhyZWFkcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9saWIvVXRpbC50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS92ZWN0b3Itc3RvcmVzL2ZpbGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3ZlY3Rvci1zdG9yZXMvZmlsZS1iYXRjaGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3ZlY3Rvci1zdG9yZXMvdmVjdG9yLXN0b3Jlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9iZXRhLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9jb21wbGV0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZW1iZWRkaW5ncy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmlsZXMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ZpbmUtdHVuaW5nL2pvYnMvY2hlY2twb2ludHMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ZpbmUtdHVuaW5nL2pvYnMvam9icy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmluZS10dW5pbmcvZmluZS10dW5pbmcudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ltYWdlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvbW9kZWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9tb2RlcmF0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvdXBsb2Fkcy9wYXJ0cy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvdXBsb2Fkcy91cGxvYWRzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2luZGV4LnRzIiwgInNlcnZpY2VzL09wZW5BSVNlcnZpY2UudHMiLCAic2VydmljZXMvUXVldWVTZXJ2aWNlLnRzIiwgInNlcnZpY2VzL01ldGFkYXRhRXh0cmFjdG9yLnRzIiwgInV0aWxzL1RleHRTcGxpdHRlci50cyIsICJzZXJ2aWNlcy9FdmVudEVtaXR0ZXIudHMiLCAidXRpbHMvRmlsZVRyYWNrZXIudHMiLCAic2VydmljZXMvU3luY0ZpbGVNYW5hZ2VyLnRzIiwgIm1vZGVscy9TeW5jTW9kZWxzLnRzIiwgInV0aWxzL0Vycm9ySGFuZGxlci50cyIsICJ1dGlscy9Ob3RpZmljYXRpb25NYW5hZ2VyLnRzIiwgInNldHRpbmdzL1NldHRpbmdzVGFiLnRzIiwgInNlcnZpY2VzL0luaXRpYWxTeW5jTWFuYWdlci50cyIsICJzZXJ2aWNlcy9TdGF0dXNNYW5hZ2VyLnRzIiwgInNlcnZpY2VzL1N5bmNEZXRlY3Rpb25NYW5hZ2VyLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJcInVzZSBzdHJpY3RcIjtcblxuLy8gcmVmOiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciBnZXRHbG9iYWwgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB0aGUgb25seSByZWxpYWJsZSBtZWFucyB0byBnZXQgdGhlIGdsb2JhbCBvYmplY3QgaXNcbiAgICAvLyBgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKWBcbiAgICAvLyBIb3dldmVyLCB0aGlzIGNhdXNlcyBDU1AgdmlvbGF0aW9ucyBpbiBDaHJvbWUgYXBwcy5cbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBzZWxmOyB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiB3aW5kb3c7IH1cbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGdsb2JhbDsgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jyk7XG59XG5cbnZhciBnbG9iYWxPYmplY3QgPSBnZXRHbG9iYWwoKTtcblxuZXhwb3J0IGNvbnN0IGZldGNoID0gZ2xvYmFsT2JqZWN0LmZldGNoO1xuXG5leHBvcnQgZGVmYXVsdCBnbG9iYWxPYmplY3QuZmV0Y2guYmluZChnbG9iYWxPYmplY3QpO1xuXG5leHBvcnQgY29uc3QgSGVhZGVycyA9IGdsb2JhbE9iamVjdC5IZWFkZXJzO1xuZXhwb3J0IGNvbnN0IFJlcXVlc3QgPSBnbG9iYWxPYmplY3QuUmVxdWVzdDtcbmV4cG9ydCBjb25zdCBSZXNwb25zZSA9IGdsb2JhbE9iamVjdC5SZXNwb25zZTtcbiIsICIvKipcbiAqIEVycm9yIGZvcm1hdFxuICpcbiAqIHtAbGluayBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sP2hpZ2hsaWdodD1vcHRpb25zI2Vycm9ycy1hbmQtaHR0cC1zdGF0dXMtY29kZXN9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBkZXRhaWxzOiBzdHJpbmdcbiAgaGludDogc3RyaW5nXG4gIGNvZGU6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IHsgbWVzc2FnZTogc3RyaW5nOyBkZXRhaWxzOiBzdHJpbmc7IGhpbnQ6IHN0cmluZzsgY29kZTogc3RyaW5nIH0pIHtcbiAgICBzdXBlcihjb250ZXh0Lm1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1Bvc3RncmVzdEVycm9yJ1xuICAgIHRoaXMuZGV0YWlscyA9IGNvbnRleHQuZGV0YWlsc1xuICAgIHRoaXMuaGludCA9IGNvbnRleHQuaGludFxuICAgIHRoaXMuY29kZSA9IGNvbnRleHQuY29kZVxuICB9XG59XG4iLCAiLy8gQHRzLWlnbm9yZVxuaW1wb3J0IG5vZGVGZXRjaCBmcm9tICdAc3VwYWJhc2Uvbm9kZS1mZXRjaCdcblxuaW1wb3J0IHR5cGUgeyBGZXRjaCwgUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2UsIFBvc3RncmVzdFJlc3BvbnNlU3VjY2VzcyB9IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQgUG9zdGdyZXN0RXJyb3IgZnJvbSAnLi9Qb3N0Z3Jlc3RFcnJvcidcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUG9zdGdyZXN0QnVpbGRlcjxSZXN1bHQsIFRocm93T25FcnJvciBleHRlbmRzIGJvb2xlYW4gPSBmYWxzZT5cbiAgaW1wbGVtZW50c1xuICAgIFByb21pc2VMaWtlPFxuICAgICAgVGhyb3dPbkVycm9yIGV4dGVuZHMgdHJ1ZSA/IFBvc3RncmVzdFJlc3BvbnNlU3VjY2VzczxSZXN1bHQ+IDogUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2U8UmVzdWx0PlxuICAgID5cbntcbiAgcHJvdGVjdGVkIG1ldGhvZDogJ0dFVCcgfCAnSEVBRCcgfCAnUE9TVCcgfCAnUEFUQ0gnIHwgJ0RFTEVURSdcbiAgcHJvdGVjdGVkIHVybDogVVJMXG4gIHByb3RlY3RlZCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIHByb3RlY3RlZCBzY2hlbWE/OiBzdHJpbmdcbiAgcHJvdGVjdGVkIGJvZHk/OiB1bmtub3duXG4gIHByb3RlY3RlZCBzaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZVxuICBwcm90ZWN0ZWQgc2lnbmFsPzogQWJvcnRTaWduYWxcbiAgcHJvdGVjdGVkIGZldGNoOiBGZXRjaFxuICBwcm90ZWN0ZWQgaXNNYXliZVNpbmdsZTogYm9vbGVhblxuXG4gIGNvbnN0cnVjdG9yKGJ1aWxkZXI6IFBvc3RncmVzdEJ1aWxkZXI8UmVzdWx0Pikge1xuICAgIHRoaXMubWV0aG9kID0gYnVpbGRlci5tZXRob2RcbiAgICB0aGlzLnVybCA9IGJ1aWxkZXIudXJsXG4gICAgdGhpcy5oZWFkZXJzID0gYnVpbGRlci5oZWFkZXJzXG4gICAgdGhpcy5zY2hlbWEgPSBidWlsZGVyLnNjaGVtYVxuICAgIHRoaXMuYm9keSA9IGJ1aWxkZXIuYm9keVxuICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gYnVpbGRlci5zaG91bGRUaHJvd09uRXJyb3JcbiAgICB0aGlzLnNpZ25hbCA9IGJ1aWxkZXIuc2lnbmFsXG4gICAgdGhpcy5pc01heWJlU2luZ2xlID0gYnVpbGRlci5pc01heWJlU2luZ2xlXG5cbiAgICBpZiAoYnVpbGRlci5mZXRjaCkge1xuICAgICAgdGhpcy5mZXRjaCA9IGJ1aWxkZXIuZmV0Y2hcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuZmV0Y2ggPSBub2RlRmV0Y2hcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mZXRjaCA9IGZldGNoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZXJlJ3MgYW4gZXJyb3Igd2l0aCB0aGUgcXVlcnksIHRocm93T25FcnJvciB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZSBieVxuICAgKiB0aHJvd2luZyB0aGUgZXJyb3IgaW5zdGVhZCBvZiByZXR1cm5pbmcgaXQgYXMgcGFydCBvZiBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gICAqXG4gICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2Uvc3VwYWJhc2UtanMvaXNzdWVzLzkyfVxuICAgKi9cbiAgdGhyb3dPbkVycm9yKCk6IHRoaXMgJiBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdCwgdHJ1ZT4ge1xuICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZVxuICAgIHJldHVybiB0aGlzIGFzIHRoaXMgJiBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdCwgdHJ1ZT5cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYW4gSFRUUCBoZWFkZXIgZm9yIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgc2V0SGVhZGVyKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMuaGVhZGVycyA9IHsgLi4udGhpcy5oZWFkZXJzIH1cbiAgICB0aGlzLmhlYWRlcnNbbmFtZV0gPSB2YWx1ZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0aGVuPFxuICAgIFRSZXN1bHQxID0gVGhyb3dPbkVycm9yIGV4dGVuZHMgdHJ1ZVxuICAgICAgPyBQb3N0Z3Jlc3RSZXNwb25zZVN1Y2Nlc3M8UmVzdWx0PlxuICAgICAgOiBQb3N0Z3Jlc3RTaW5nbGVSZXNwb25zZTxSZXN1bHQ+LFxuICAgIFRSZXN1bHQyID0gbmV2ZXJcbiAgPihcbiAgICBvbmZ1bGZpbGxlZD86XG4gICAgICB8ICgoXG4gICAgICAgICAgdmFsdWU6IFRocm93T25FcnJvciBleHRlbmRzIHRydWVcbiAgICAgICAgICAgID8gUG9zdGdyZXN0UmVzcG9uc2VTdWNjZXNzPFJlc3VsdD5cbiAgICAgICAgICAgIDogUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2U8UmVzdWx0PlxuICAgICAgICApID0+IFRSZXN1bHQxIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDE+KVxuICAgICAgfCB1bmRlZmluZWRcbiAgICAgIHwgbnVsbCxcbiAgICBvbnJlamVjdGVkPzogKChyZWFzb246IGFueSkgPT4gVFJlc3VsdDIgfCBQcm9taXNlTGlrZTxUUmVzdWx0Mj4pIHwgdW5kZWZpbmVkIHwgbnVsbFxuICApOiBQcm9taXNlTGlrZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiB7XG4gICAgLy8gaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNzd2l0Y2hpbmctc2NoZW1hc1xuICAgIGlmICh0aGlzLnNjaGVtYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBza2lwXG4gICAgfSBlbHNlIGlmIChbJ0dFVCcsICdIRUFEJ10uaW5jbHVkZXModGhpcy5tZXRob2QpKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdC1Qcm9maWxlJ10gPSB0aGlzLnNjaGVtYVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ0NvbnRlbnQtUHJvZmlsZSddID0gdGhpcy5zY2hlbWFcbiAgICB9XG4gICAgaWYgKHRoaXMubWV0aG9kICE9PSAnR0VUJyAmJiB0aGlzLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgfVxuXG4gICAgLy8gTk9URTogSW52b2tlIHcvbyBgdGhpc2AgdG8gYXZvaWQgaWxsZWdhbCBpbnZvY2F0aW9uIGVycm9yLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvcHVsbC8yNDdcbiAgICBjb25zdCBfZmV0Y2ggPSB0aGlzLmZldGNoXG4gICAgbGV0IHJlcyA9IF9mZXRjaCh0aGlzLnVybC50b1N0cmluZygpLCB7XG4gICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodGhpcy5ib2R5KSxcbiAgICAgIHNpZ25hbDogdGhpcy5zaWduYWwsXG4gICAgfSkudGhlbihhc3luYyAocmVzKSA9PiB7XG4gICAgICBsZXQgZXJyb3IgPSBudWxsXG4gICAgICBsZXQgZGF0YSA9IG51bGxcbiAgICAgIGxldCBjb3VudDogbnVtYmVyIHwgbnVsbCA9IG51bGxcbiAgICAgIGxldCBzdGF0dXMgPSByZXMuc3RhdHVzXG4gICAgICBsZXQgc3RhdHVzVGV4dCA9IHJlcy5zdGF0dXNUZXh0XG5cbiAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgaWYgKHRoaXMubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzLnRleHQoKVxuICAgICAgICAgIGlmIChib2R5ID09PSAnJykge1xuICAgICAgICAgICAgLy8gUHJlZmVyOiByZXR1cm49bWluaW1hbFxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9PT0gJ3RleHQvY3N2Jykge1xuICAgICAgICAgICAgZGF0YSA9IGJvZHlcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSAmJlxuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXS5pbmNsdWRlcygnYXBwbGljYXRpb24vdm5kLnBncnN0LnBsYW4rdGV4dCcpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkYXRhID0gYm9keVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShib2R5KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvdW50SGVhZGVyID0gdGhpcy5oZWFkZXJzWydQcmVmZXInXT8ubWF0Y2goL2NvdW50PShleGFjdHxwbGFubmVkfGVzdGltYXRlZCkvKVxuICAgICAgICBjb25zdCBjb250ZW50UmFuZ2UgPSByZXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtcmFuZ2UnKT8uc3BsaXQoJy8nKVxuICAgICAgICBpZiAoY291bnRIZWFkZXIgJiYgY29udGVudFJhbmdlICYmIGNvbnRlbnRSYW5nZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgY291bnQgPSBwYXJzZUludChjb250ZW50UmFuZ2VbMV0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZW1wb3JhcnkgcGFydGlhbCBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzM2MVxuICAgICAgICAvLyBJc3N1ZSBwZXJzaXN0cyBlLmcuIGZvciBgLmluc2VydChbLi4uXSkuc2VsZWN0KCkubWF5YmVTaW5nbGUoKWBcbiAgICAgICAgaWYgKHRoaXMuaXNNYXliZVNpbmdsZSAmJiB0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgJiYgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vUG9zdGdSRVNUL3Bvc3RncmVzdC9ibG9iL2E4NjdkNzljNDI0MTlhZjE2YzE4YzNmYjAxOWViYThkZjk5MjYyNmYvc3JjL1Bvc3RnUkVTVC9FcnJvci5ocyNMNTUzXG4gICAgICAgICAgICAgIGNvZGU6ICdQR1JTVDExNicsXG4gICAgICAgICAgICAgIGRldGFpbHM6IGBSZXN1bHRzIGNvbnRhaW4gJHtkYXRhLmxlbmd0aH0gcm93cywgYXBwbGljYXRpb24vdm5kLnBncnN0Lm9iamVjdCtqc29uIHJlcXVpcmVzIDEgcm93YCxcbiAgICAgICAgICAgICAgaGludDogbnVsbCxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ0pTT04gb2JqZWN0IHJlcXVlc3RlZCwgbXVsdGlwbGUgKG9yIG5vKSByb3dzIHJldHVybmVkJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBudWxsXG4gICAgICAgICAgICBjb3VudCA9IG51bGxcbiAgICAgICAgICAgIHN0YXR1cyA9IDQwNlxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdOb3QgQWNjZXB0YWJsZSdcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBkYXRhID0gZGF0YVswXVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcy50ZXh0KClcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGVycm9yID0gSlNPTi5wYXJzZShib2R5KVxuXG4gICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9pc3N1ZXMvMjk1XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXJyb3IpICYmIHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgZGF0YSA9IFtdXG4gICAgICAgICAgICBlcnJvciA9IG51bGxcbiAgICAgICAgICAgIHN0YXR1cyA9IDIwMFxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdPSydcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzI5NVxuICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQgJiYgYm9keSA9PT0gJycpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9IDIwNFxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdObyBDb250ZW50J1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYm9keSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IgJiYgdGhpcy5pc01heWJlU2luZ2xlICYmIGVycm9yPy5kZXRhaWxzPy5pbmNsdWRlcygnMCByb3dzJykpIHtcbiAgICAgICAgICBlcnJvciA9IG51bGxcbiAgICAgICAgICBzdGF0dXMgPSAyMDBcbiAgICAgICAgICBzdGF0dXNUZXh0ID0gJ09LJ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yICYmIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBvc3RncmVzdEVycm9yKGVycm9yKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvc3RncmVzdFJlc3BvbnNlID0ge1xuICAgICAgICBlcnJvcixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY291bnQsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dCxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvc3RncmVzdFJlc3BvbnNlXG4gICAgfSlcbiAgICBpZiAoIXRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICByZXMgPSByZXMuY2F0Y2goKGZldGNoRXJyb3IpID0+ICh7XG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgbWVzc2FnZTogYCR7ZmV0Y2hFcnJvcj8ubmFtZSA/PyAnRmV0Y2hFcnJvcid9OiAke2ZldGNoRXJyb3I/Lm1lc3NhZ2V9YCxcbiAgICAgICAgICBkZXRhaWxzOiBgJHtmZXRjaEVycm9yPy5zdGFjayA/PyAnJ31gLFxuICAgICAgICAgIGhpbnQ6ICcnLFxuICAgICAgICAgIGNvZGU6IGAke2ZldGNoRXJyb3I/LmNvZGUgPz8gJyd9YCxcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgY291bnQ6IG51bGwsXG4gICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgc3RhdHVzVGV4dDogJycsXG4gICAgICB9KSlcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpXG4gIH1cbn1cbiIsICJpbXBvcnQgUG9zdGdyZXN0QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEJ1aWxkZXInXG5pbXBvcnQgeyBHZXRSZXN1bHQgfSBmcm9tICcuL3NlbGVjdC1xdWVyeS1wYXJzZXIvcmVzdWx0J1xuaW1wb3J0IHsgR2VuZXJpY1NjaGVtYSB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXI8XG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEsXG4gIFJvdyBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBSZXN1bHQsXG4gIFJlbGF0aW9uTmFtZSA9IHVua25vd24sXG4gIFJlbGF0aW9uc2hpcHMgPSB1bmtub3duXG4+IGV4dGVuZHMgUG9zdGdyZXN0QnVpbGRlcjxSZXN1bHQ+IHtcbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBTRUxFQ1Qgb24gdGhlIHF1ZXJ5IHJlc3VsdC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYC5pbnNlcnQoKWAsIGAudXBkYXRlKClgLCBgLnVwc2VydCgpYCwgYW5kIGAuZGVsZXRlKClgIGRvIG5vdFxuICAgKiByZXR1cm4gbW9kaWZpZWQgcm93cy4gQnkgY2FsbGluZyB0aGlzIG1ldGhvZCwgbW9kaWZpZWQgcm93cyBhcmUgcmV0dXJuZWQgaW5cbiAgICogYGRhdGFgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1ucyAtIFRoZSBjb2x1bW5zIHRvIHJldHJpZXZlLCBzZXBhcmF0ZWQgYnkgY29tbWFzXG4gICAqL1xuICBzZWxlY3Q8XG4gICAgUXVlcnkgZXh0ZW5kcyBzdHJpbmcgPSAnKicsXG4gICAgTmV3UmVzdWx0T25lID0gR2V0UmVzdWx0PFNjaGVtYSwgUm93LCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHMsIFF1ZXJ5PlxuICA+KFxuICAgIGNvbHVtbnM/OiBRdWVyeVxuICApOiBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyPFNjaGVtYSwgUm93LCBOZXdSZXN1bHRPbmVbXSwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2VzIGV4Y2VwdCB3aGVuIHF1b3RlZFxuICAgIGxldCBxdW90ZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNsZWFuZWRDb2x1bW5zID0gKGNvbHVtbnMgPz8gJyonKVxuICAgICAgLnNwbGl0KCcnKVxuICAgICAgLm1hcCgoYykgPT4ge1xuICAgICAgICBpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSB7XG4gICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICBxdW90ZWQgPSAhcXVvdGVkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH0pXG4gICAgICAuam9pbignJylcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZWxlY3QnLCBjbGVhbmVkQ29sdW1ucylcbiAgICBpZiAodGhpcy5oZWFkZXJzWydQcmVmZXInXSkge1xuICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSArPSAnLCdcbiAgICB9XG4gICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSArPSAncmV0dXJuPXJlcHJlc2VudGF0aW9uJ1xuICAgIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcjxcbiAgICAgIFNjaGVtYSxcbiAgICAgIFJvdyxcbiAgICAgIE5ld1Jlc3VsdE9uZVtdLFxuICAgICAgUmVsYXRpb25OYW1lLFxuICAgICAgUmVsYXRpb25zaGlwc1xuICAgID5cbiAgfVxuXG4gIG9yZGVyPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBvcHRpb25zPzogeyBhc2NlbmRpbmc/OiBib29sZWFuOyBudWxsc0ZpcnN0PzogYm9vbGVhbjsgcmVmZXJlbmNlZFRhYmxlPzogdW5kZWZpbmVkIH1cbiAgKTogdGhpc1xuICBvcmRlcihcbiAgICBjb2x1bW46IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyBhc2NlbmRpbmc/OiBib29sZWFuOyBudWxsc0ZpcnN0PzogYm9vbGVhbjsgcmVmZXJlbmNlZFRhYmxlPzogc3RyaW5nIH1cbiAgKTogdGhpc1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWAgaW5zdGVhZCBvZiBgb3B0aW9ucy5mb3JlaWduVGFibGVgXG4gICAqL1xuICBvcmRlcjxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgb3B0aW9ucz86IHsgYXNjZW5kaW5nPzogYm9vbGVhbjsgbnVsbHNGaXJzdD86IGJvb2xlYW47IGZvcmVpZ25UYWJsZT86IHVuZGVmaW5lZCB9XG4gICk6IHRoaXNcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgIGluc3RlYWQgb2YgYG9wdGlvbnMuZm9yZWlnblRhYmxlYFxuICAgKi9cbiAgb3JkZXIoXG4gICAgY29sdW1uOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgYXNjZW5kaW5nPzogYm9vbGVhbjsgbnVsbHNGaXJzdD86IGJvb2xlYW47IGZvcmVpZ25UYWJsZT86IHN0cmluZyB9XG4gICk6IHRoaXNcbiAgLyoqXG4gICAqIE9yZGVyIHRoZSBxdWVyeSByZXN1bHQgYnkgYGNvbHVtbmAuXG4gICAqXG4gICAqIFlvdSBjYW4gY2FsbCB0aGlzIG1ldGhvZCBtdWx0aXBsZSB0aW1lcyB0byBvcmRlciBieSBtdWx0aXBsZSBjb2x1bW5zLlxuICAgKlxuICAgKiBZb3UgY2FuIG9yZGVyIHJlZmVyZW5jZWQgdGFibGVzLCBidXQgaXQgb25seSBhZmZlY3RzIHRoZSBvcmRlcmluZyBvZiB0aGVcbiAgICogcGFyZW50IHRhYmxlIGlmIHlvdSB1c2UgYCFpbm5lcmAgaW4gdGhlIHF1ZXJ5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBvcmRlciBieVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMuYXNjZW5kaW5nIC0gSWYgYHRydWVgLCB0aGUgcmVzdWx0IHdpbGwgYmUgaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAqIEBwYXJhbSBvcHRpb25zLm51bGxzRmlyc3QgLSBJZiBgdHJ1ZWAsIGBudWxsYHMgYXBwZWFyIGZpcnN0LiBJZiBgZmFsc2VgLFxuICAgKiBgbnVsbGBzIGFwcGVhciBsYXN0LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBvcmRlciBhIHJlZmVyZW5jZWQgdGFibGUgYnlcbiAgICogaXRzIGNvbHVtbnNcbiAgICogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWBcbiAgICogaW5zdGVhZFxuICAgKi9cbiAgb3JkZXIoXG4gICAgY29sdW1uOiBzdHJpbmcsXG4gICAge1xuICAgICAgYXNjZW5kaW5nID0gdHJ1ZSxcbiAgICAgIG51bGxzRmlyc3QsXG4gICAgICBmb3JlaWduVGFibGUsXG4gICAgICByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUsXG4gICAgfToge1xuICAgICAgYXNjZW5kaW5nPzogYm9vbGVhblxuICAgICAgbnVsbHNGaXJzdD86IGJvb2xlYW5cbiAgICAgIGZvcmVpZ25UYWJsZT86IHN0cmluZ1xuICAgICAgcmVmZXJlbmNlZFRhYmxlPzogc3RyaW5nXG4gICAgfSA9IHt9XG4gICk6IHRoaXMge1xuICAgIGNvbnN0IGtleSA9IHJlZmVyZW5jZWRUYWJsZSA/IGAke3JlZmVyZW5jZWRUYWJsZX0ub3JkZXJgIDogJ29yZGVyJ1xuICAgIGNvbnN0IGV4aXN0aW5nT3JkZXIgPSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuZ2V0KGtleSlcblxuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoXG4gICAgICBrZXksXG4gICAgICBgJHtleGlzdGluZ09yZGVyID8gYCR7ZXhpc3RpbmdPcmRlcn0sYCA6ICcnfSR7Y29sdW1ufS4ke2FzY2VuZGluZyA/ICdhc2MnIDogJ2Rlc2MnfSR7XG4gICAgICAgIG51bGxzRmlyc3QgPT09IHVuZGVmaW5lZCA/ICcnIDogbnVsbHNGaXJzdCA/ICcubnVsbHNmaXJzdCcgOiAnLm51bGxzbGFzdCdcbiAgICAgIH1gXG4gICAgKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogTGltaXQgdGhlIHF1ZXJ5IHJlc3VsdCBieSBgY291bnRgLlxuICAgKlxuICAgKiBAcGFyYW0gY291bnQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0byByZXR1cm5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGxpbWl0IHJvd3Mgb2YgcmVmZXJlbmNlZFxuICAgKiB0YWJsZXMgaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG4gICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgXG4gICAqIGluc3RlYWRcbiAgICovXG4gIGxpbWl0KFxuICAgIGNvdW50OiBudW1iZXIsXG4gICAge1xuICAgICAgZm9yZWlnblRhYmxlLFxuICAgICAgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlLFxuICAgIH06IHsgZm9yZWlnblRhYmxlPzogc3RyaW5nOyByZWZlcmVuY2VkVGFibGU/OiBzdHJpbmcgfSA9IHt9XG4gICk6IHRoaXMge1xuICAgIGNvbnN0IGtleSA9IHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09ICd1bmRlZmluZWQnID8gJ2xpbWl0JyA6IGAke3JlZmVyZW5jZWRUYWJsZX0ubGltaXRgXG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIGAke2NvdW50fWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBMaW1pdCB0aGUgcXVlcnkgcmVzdWx0IGJ5IHN0YXJ0aW5nIGF0IGFuIG9mZnNldCBgZnJvbWAgYW5kIGVuZGluZyBhdCB0aGUgb2Zmc2V0IGB0b2AuXG4gICAqIE9ubHkgcmVjb3JkcyB3aXRoaW4gdGhpcyByYW5nZSBhcmUgcmV0dXJuZWQuXG4gICAqIFRoaXMgcmVzcGVjdHMgdGhlIHF1ZXJ5IG9yZGVyIGFuZCBpZiB0aGVyZSBpcyBubyBvcmRlciBjbGF1c2UgdGhlIHJhbmdlIGNvdWxkIGJlaGF2ZSB1bmV4cGVjdGVkbHkuXG4gICAqIFRoZSBgZnJvbWAgYW5kIGB0b2AgdmFsdWVzIGFyZSAwLWJhc2VkIGFuZCBpbmNsdXNpdmU6IGByYW5nZSgxLCAzKWAgd2lsbCBpbmNsdWRlIHRoZSBzZWNvbmQsIHRoaXJkXG4gICAqIGFuZCBmb3VydGggcm93cyBvZiB0aGUgcXVlcnkuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHN0YXJ0aW5nIGluZGV4IGZyb20gd2hpY2ggdG8gbGltaXQgdGhlIHJlc3VsdFxuICAgKiBAcGFyYW0gdG8gLSBUaGUgbGFzdCBpbmRleCB0byB3aGljaCB0byBsaW1pdCB0aGUgcmVzdWx0XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBsaW1pdCByb3dzIG9mIHJlZmVyZW5jZWRcbiAgICogdGFibGVzIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuICAgKiBpbnN0ZWFkXG4gICAqL1xuICByYW5nZShcbiAgICBmcm9tOiBudW1iZXIsXG4gICAgdG86IG51bWJlcixcbiAgICB7XG4gICAgICBmb3JlaWduVGFibGUsXG4gICAgICByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUsXG4gICAgfTogeyBmb3JlaWduVGFibGU/OiBzdHJpbmc7IHJlZmVyZW5jZWRUYWJsZT86IHN0cmluZyB9ID0ge31cbiAgKTogdGhpcyB7XG4gICAgY29uc3Qga2V5T2Zmc2V0ID1cbiAgICAgIHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09ICd1bmRlZmluZWQnID8gJ29mZnNldCcgOiBgJHtyZWZlcmVuY2VkVGFibGV9Lm9mZnNldGBcbiAgICBjb25zdCBrZXlMaW1pdCA9IHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09ICd1bmRlZmluZWQnID8gJ2xpbWl0JyA6IGAke3JlZmVyZW5jZWRUYWJsZX0ubGltaXRgXG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXlPZmZzZXQsIGAke2Zyb219YClcbiAgICAvLyBSYW5nZSBpcyBpbmNsdXNpdmUsIHNvIGFkZCAxXG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXlMaW1pdCwgYCR7dG8gLSBmcm9tICsgMX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBBYm9ydFNpZ25hbCBmb3IgdGhlIGZldGNoIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBzaWduYWwgLSBUaGUgQWJvcnRTaWduYWwgdG8gdXNlIGZvciB0aGUgZmV0Y2ggcmVxdWVzdFxuICAgKi9cbiAgYWJvcnRTaWduYWwoc2lnbmFsOiBBYm9ydFNpZ25hbCk6IHRoaXMge1xuICAgIHRoaXMuc2lnbmFsID0gc2lnbmFsXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYGRhdGFgIGFzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gICAqXG4gICAqIFF1ZXJ5IHJlc3VsdCBtdXN0IGJlIG9uZSByb3cgKGUuZy4gdXNpbmcgYC5saW1pdCgxKWApLCBvdGhlcndpc2UgdGhpc1xuICAgKiByZXR1cm5zIGFuIGVycm9yLlxuICAgKi9cbiAgc2luZ2xlPFxuICAgIFJlc3VsdE9uZSA9IFJlc3VsdCBleHRlbmRzIChpbmZlciBSZXN1bHRPbmUpW10gPyBSZXN1bHRPbmUgOiBuZXZlclxuICA+KCk6IFBvc3RncmVzdEJ1aWxkZXI8UmVzdWx0T25lPiB7XG4gICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24nXG4gICAgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdE9uZT5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYGRhdGFgIGFzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gICAqXG4gICAqIFF1ZXJ5IHJlc3VsdCBtdXN0IGJlIHplcm8gb3Igb25lIHJvdyAoZS5nLiB1c2luZyBgLmxpbWl0KDEpYCksIG90aGVyd2lzZVxuICAgKiB0aGlzIHJldHVybnMgYW4gZXJyb3IuXG4gICAqL1xuICBtYXliZVNpbmdsZTxcbiAgICBSZXN1bHRPbmUgPSBSZXN1bHQgZXh0ZW5kcyAoaW5mZXIgUmVzdWx0T25lKVtdID8gUmVzdWx0T25lIDogbmV2ZXJcbiAgPigpOiBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdE9uZSB8IG51bGw+IHtcbiAgICAvLyBUZW1wb3JhcnkgcGFydGlhbCBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzM2MVxuICAgIC8vIElzc3VlIHBlcnNpc3RzIGUuZy4gZm9yIGAuaW5zZXJ0KFsuLi5dKS5zZWxlY3QoKS5tYXliZVNpbmdsZSgpYFxuICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vanNvbidcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24nXG4gICAgfVxuICAgIHRoaXMuaXNNYXliZVNpbmdsZSA9IHRydWVcbiAgICByZXR1cm4gdGhpcyBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8UmVzdWx0T25lIHwgbnVsbD5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYGRhdGFgIGFzIGEgc3RyaW5nIGluIENTViBmb3JtYXQuXG4gICAqL1xuICBjc3YoKTogUG9zdGdyZXN0QnVpbGRlcjxzdHJpbmc+IHtcbiAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID0gJ3RleHQvY3N2J1xuICAgIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxzdHJpbmc+XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGBkYXRhYCBhcyBhbiBvYmplY3QgaW4gW0dlb0pTT05dKGh0dHBzOi8vZ2VvanNvbi5vcmcpIGZvcm1hdC5cbiAgICovXG4gIGdlb2pzb24oKTogUG9zdGdyZXN0QnVpbGRlcjxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4ge1xuICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vZ2VvK2pzb24nXG4gICAgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPFJlY29yZDxzdHJpbmcsIHVua25vd24+PlxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBgZGF0YWAgYXMgdGhlIEVYUExBSU4gcGxhbiBmb3IgdGhlIHF1ZXJ5LlxuICAgKlxuICAgKiBZb3UgbmVlZCB0byBlbmFibGUgdGhlXG4gICAqIFtkYl9wbGFuX2VuYWJsZWRdKGh0dHBzOi8vc3VwYWJhc2UuY29tL2RvY3MvZ3VpZGVzL2RhdGFiYXNlL2RlYnVnZ2luZy1wZXJmb3JtYW5jZSNlbmFibGluZy1leHBsYWluKVxuICAgKiBzZXR0aW5nIGJlZm9yZSB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmFuYWx5emUgLSBJZiBgdHJ1ZWAsIHRoZSBxdWVyeSB3aWxsIGJlIGV4ZWN1dGVkIGFuZCB0aGVcbiAgICogYWN0dWFsIHJ1biB0aW1lIHdpbGwgYmUgcmV0dXJuZWRcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMudmVyYm9zZSAtIElmIGB0cnVlYCwgdGhlIHF1ZXJ5IGlkZW50aWZpZXIgd2lsbCBiZSByZXR1cm5lZFxuICAgKiBhbmQgYGRhdGFgIHdpbGwgaW5jbHVkZSB0aGUgb3V0cHV0IGNvbHVtbnMgb2YgdGhlIHF1ZXJ5XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLnNldHRpbmdzIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIGNvbmZpZ3VyYXRpb25cbiAgICogcGFyYW1ldGVycyB0aGF0IGFmZmVjdCBxdWVyeSBwbGFubmluZ1xuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5idWZmZXJzIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIGJ1ZmZlciB1c2FnZVxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy53YWwgLSBJZiBgdHJ1ZWAsIGluY2x1ZGUgaW5mb3JtYXRpb24gb24gV0FMIHJlY29yZCBnZW5lcmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmZvcm1hdCAtIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCwgY2FuIGJlIGBcInRleHRcImAgKGRlZmF1bHQpXG4gICAqIG9yIGBcImpzb25cImBcbiAgICovXG4gIGV4cGxhaW4oe1xuICAgIGFuYWx5emUgPSBmYWxzZSxcbiAgICB2ZXJib3NlID0gZmFsc2UsXG4gICAgc2V0dGluZ3MgPSBmYWxzZSxcbiAgICBidWZmZXJzID0gZmFsc2UsXG4gICAgd2FsID0gZmFsc2UsXG4gICAgZm9ybWF0ID0gJ3RleHQnLFxuICB9OiB7XG4gICAgYW5hbHl6ZT86IGJvb2xlYW5cbiAgICB2ZXJib3NlPzogYm9vbGVhblxuICAgIHNldHRpbmdzPzogYm9vbGVhblxuICAgIGJ1ZmZlcnM/OiBib29sZWFuXG4gICAgd2FsPzogYm9vbGVhblxuICAgIGZvcm1hdD86ICdqc29uJyB8ICd0ZXh0J1xuICB9ID0ge30pOiBQb3N0Z3Jlc3RCdWlsZGVyPFJlY29yZDxzdHJpbmcsIHVua25vd24+W10+IHwgUG9zdGdyZXN0QnVpbGRlcjxzdHJpbmc+IHtcbiAgICBjb25zdCBvcHRpb25zID0gW1xuICAgICAgYW5hbHl6ZSA/ICdhbmFseXplJyA6IG51bGwsXG4gICAgICB2ZXJib3NlID8gJ3ZlcmJvc2UnIDogbnVsbCxcbiAgICAgIHNldHRpbmdzID8gJ3NldHRpbmdzJyA6IG51bGwsXG4gICAgICBidWZmZXJzID8gJ2J1ZmZlcnMnIDogbnVsbCxcbiAgICAgIHdhbCA/ICd3YWwnIDogbnVsbCxcbiAgICBdXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAuam9pbignfCcpXG4gICAgLy8gQW4gQWNjZXB0IGhlYWRlciBjYW4gY2FycnkgbXVsdGlwbGUgbWVkaWEgdHlwZXMgYnV0IHBvc3RncmVzdC1qcyBhbHdheXMgc2VuZHMgb25lXG4gICAgY29uc3QgZm9yTWVkaWF0eXBlID0gdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA/PyAnYXBwbGljYXRpb24vanNvbidcbiAgICB0aGlzLmhlYWRlcnNbXG4gICAgICAnQWNjZXB0J1xuICAgIF0gPSBgYXBwbGljYXRpb24vdm5kLnBncnN0LnBsYW4rJHtmb3JtYXR9OyBmb3I9XCIke2Zvck1lZGlhdHlwZX1cIjsgb3B0aW9ucz0ke29wdGlvbnN9O2BcbiAgICBpZiAoZm9ybWF0ID09PSAnanNvbicpIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdPlxuICAgIGVsc2UgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPHN0cmluZz5cbiAgfVxuXG4gIC8qKlxuICAgKiBSb2xsYmFjayB0aGUgcXVlcnkuXG4gICAqXG4gICAqIGBkYXRhYCB3aWxsIHN0aWxsIGJlIHJldHVybmVkLCBidXQgdGhlIHF1ZXJ5IGlzIG5vdCBjb21taXR0ZWQuXG4gICAqL1xuICByb2xsYmFjaygpOiB0aGlzIHtcbiAgICBpZiAoKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPz8gJycpLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ1ByZWZlciddICs9ICcsdHg9cm9sbGJhY2snXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSAndHg9cm9sbGJhY2snXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGBkYXRhYC5cbiAgICpcbiAgICogQHR5cGVQYXJhbSBOZXdSZXN1bHQgLSBUaGUgbmV3IHJlc3VsdCB0eXBlIHRvIG92ZXJyaWRlIHdpdGhcbiAgICovXG4gIHJldHVybnM8TmV3UmVzdWx0PigpOiBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyPFxuICAgIFNjaGVtYSxcbiAgICBSb3csXG4gICAgTmV3UmVzdWx0LFxuICAgIFJlbGF0aW9uTmFtZSxcbiAgICBSZWxhdGlvbnNoaXBzXG4gID4ge1xuICAgIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcjxcbiAgICAgIFNjaGVtYSxcbiAgICAgIFJvdyxcbiAgICAgIE5ld1Jlc3VsdCxcbiAgICAgIFJlbGF0aW9uTmFtZSxcbiAgICAgIFJlbGF0aW9uc2hpcHNcbiAgICA+XG4gIH1cbn1cbiIsICJpbXBvcnQgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXInXG5pbXBvcnQgeyBHZW5lcmljU2NoZW1hIH0gZnJvbSAnLi90eXBlcydcblxudHlwZSBGaWx0ZXJPcGVyYXRvciA9XG4gIHwgJ2VxJ1xuICB8ICduZXEnXG4gIHwgJ2d0J1xuICB8ICdndGUnXG4gIHwgJ2x0J1xuICB8ICdsdGUnXG4gIHwgJ2xpa2UnXG4gIHwgJ2lsaWtlJ1xuICB8ICdpcydcbiAgfCAnaW4nXG4gIHwgJ2NzJ1xuICB8ICdjZCdcbiAgfCAnc2wnXG4gIHwgJ3NyJ1xuICB8ICdueGwnXG4gIHwgJ254cidcbiAgfCAnYWRqJ1xuICB8ICdvdidcbiAgfCAnZnRzJ1xuICB8ICdwbGZ0cydcbiAgfCAncGhmdHMnXG4gIHwgJ3dmdHMnXG5cbi8vIE1hdGNoIHJlbGF0aW9uc2hpcCBmaWx0ZXJzIHdpdGggYHRhYmxlLmNvbHVtbmAgc3ludGF4IGFuZCByZXNvbHZlIHVuZGVybHlpbmdcbi8vIGNvbHVtbiB2YWx1ZS4gSWYgbm90IG1hdGNoZWQsIGZhbGxiYWNrIHRvIGdlbmVyaWMgdHlwZS5cbi8vIFRPRE86IFZhbGlkYXRlIHRoZSByZWxhdGlvbnNoaXAgaXRzZWxmIGFsYSBzZWxlY3QtcXVlcnktcGFyc2VyLiBDdXJyZW50bHkgd2Vcbi8vIGFzc3VtZSB0aGF0IGFsbCB0YWJsZXMgaGF2ZSB2YWxpZCByZWxhdGlvbnNoaXBzIHRvIGVhY2ggb3RoZXIsIGRlc3BpdGVcbi8vIG5vbmV4aXN0ZW50IGZvcmVpZ24ga2V5cy5cbnR5cGUgUmVzb2x2ZUZpbHRlclZhbHVlPFxuICBTY2hlbWEgZXh0ZW5kcyBHZW5lcmljU2NoZW1hLFxuICBSb3cgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgQ29sdW1uTmFtZSBleHRlbmRzIHN0cmluZ1xuPiA9IENvbHVtbk5hbWUgZXh0ZW5kcyBgJHtpbmZlciBSZWxhdGlvbnNoaXBUYWJsZX0uJHtpbmZlciBSZW1haW5kZXJ9YFxuICA/IFJlbWFpbmRlciBleHRlbmRzIGAke2luZmVyIF99LiR7aW5mZXIgX31gXG4gICAgPyBSZXNvbHZlRmlsdGVyVmFsdWU8U2NoZW1hLCBSb3csIFJlbWFpbmRlcj5cbiAgICA6IFJlc29sdmVGaWx0ZXJSZWxhdGlvbnNoaXBWYWx1ZTxTY2hlbWEsIFJlbGF0aW9uc2hpcFRhYmxlLCBSZW1haW5kZXI+XG4gIDogQ29sdW1uTmFtZSBleHRlbmRzIGtleW9mIFJvd1xuICA/IFJvd1tDb2x1bW5OYW1lXVxuICA6IG5ldmVyXG5cbnR5cGUgUmVzb2x2ZUZpbHRlclJlbGF0aW9uc2hpcFZhbHVlPFxuICBTY2hlbWEgZXh0ZW5kcyBHZW5lcmljU2NoZW1hLFxuICBSZWxhdGlvbnNoaXBUYWJsZSBleHRlbmRzIHN0cmluZyxcbiAgUmVsYXRpb25zaGlwQ29sdW1uIGV4dGVuZHMgc3RyaW5nXG4+ID0gU2NoZW1hWydUYWJsZXMnXSAmIFNjaGVtYVsnVmlld3MnXSBleHRlbmRzIGluZmVyIFRhYmxlc0FuZFZpZXdzXG4gID8gUmVsYXRpb25zaGlwVGFibGUgZXh0ZW5kcyBrZXlvZiBUYWJsZXNBbmRWaWV3c1xuICAgID8gJ1JvdycgZXh0ZW5kcyBrZXlvZiBUYWJsZXNBbmRWaWV3c1tSZWxhdGlvbnNoaXBUYWJsZV1cbiAgICAgID8gUmVsYXRpb25zaGlwQ29sdW1uIGV4dGVuZHMga2V5b2YgVGFibGVzQW5kVmlld3NbUmVsYXRpb25zaGlwVGFibGVdWydSb3cnXVxuICAgICAgICA/IFRhYmxlc0FuZFZpZXdzW1JlbGF0aW9uc2hpcFRhYmxlXVsnUm93J11bUmVsYXRpb25zaGlwQ29sdW1uXVxuICAgICAgICA6IHVua25vd25cbiAgICAgIDogdW5rbm93blxuICAgIDogdW5rbm93blxuICA6IG5ldmVyXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8XG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEsXG4gIFJvdyBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBSZXN1bHQsXG4gIFJlbGF0aW9uTmFtZSA9IHVua25vd24sXG4gIFJlbGF0aW9uc2hpcHMgPSB1bmtub3duXG4+IGV4dGVuZHMgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcjxTY2hlbWEsIFJvdywgUmVzdWx0LCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+IHtcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBUbyBjaGVjayBpZiB0aGUgdmFsdWUgb2YgYGNvbHVtbmAgaXMgTlVMTCwgeW91IHNob3VsZCB1c2UgYC5pcygpYCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBlcTxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nPihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgdmFsdWU6IFJlc29sdmVGaWx0ZXJWYWx1ZTxTY2hlbWEsIFJvdywgQ29sdW1uTmFtZT4gZXh0ZW5kcyBuZXZlclxuICAgICAgPyBOb25OdWxsYWJsZTx1bmtub3duPlxuICAgICAgOiBOb25OdWxsYWJsZTxSZXNvbHZlRmlsdGVyVmFsdWU8U2NoZW1hLCBSb3csIENvbHVtbk5hbWU+PlxuICApOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGVxLiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBub3QgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgbmVxPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmc+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZTogUmVzb2x2ZUZpbHRlclZhbHVlPFNjaGVtYSwgUm93LCBDb2x1bW5OYW1lPiBleHRlbmRzIG5ldmVyXG4gICAgICA/IHVua25vd25cbiAgICAgIDogUmVzb2x2ZUZpbHRlclZhbHVlPFNjaGVtYSwgUm93LCBDb2x1bW5OYW1lPlxuICApOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5lcS4ke3ZhbHVlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGd0PENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgdmFsdWU6IFJvd1tDb2x1bW5OYW1lXSk6IHRoaXNcbiAgZ3QoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBndChjb2x1bW46IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGd0LiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ3RlPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgdmFsdWU6IFJvd1tDb2x1bW5OYW1lXSk6IHRoaXNcbiAgZ3RlKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgZ3RlKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZ3RlLiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbHQ8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCB2YWx1ZTogUm93W0NvbHVtbk5hbWVdKTogdGhpc1xuICBsdChjb2x1bW46IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbGVzcyB0aGFuIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGx0KGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbHQuJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsdGU8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCB2YWx1ZTogUm93W0NvbHVtbk5hbWVdKTogdGhpc1xuICBsdGUoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBsdGUoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsdGUuJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsaWtlPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgcGF0dGVybjogc3RyaW5nKTogdGhpc1xuICBsaWtlKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuOiBzdHJpbmcpOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBgcGF0dGVybmAgY2FzZS1zZW5zaXRpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuICAgKi9cbiAgbGlrZShjb2x1bW46IHN0cmluZywgcGF0dGVybjogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsaWtlLiR7cGF0dGVybn1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsaWtlQWxsT2Y8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXVxuICApOiB0aGlzXG4gIGxpa2VBbGxPZihjb2x1bW46IHN0cmluZywgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYWxsIG9mIGBwYXR0ZXJuc2AgY2FzZS1zZW5zaXRpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG4gICAqL1xuICBsaWtlQWxsT2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZShhbGwpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbGlrZUFueU9mPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW11cbiAgKTogdGhpc1xuICBsaWtlQW55T2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFueSBvZiBgcGF0dGVybnNgIGNhc2Utc2Vuc2l0aXZlbHkuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuICAgKi9cbiAgbGlrZUFueU9mKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW10pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGxpa2UoYW55KS57JHtwYXR0ZXJucy5qb2luKCcsJyl9fWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlsaWtlPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgcGF0dGVybjogc3RyaW5nKTogdGhpc1xuICBpbGlrZShjb2x1bW46IHN0cmluZywgcGF0dGVybjogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYHBhdHRlcm5gIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuICAgKi9cbiAgaWxpa2UoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm46IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UuJHtwYXR0ZXJufWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlsaWtlQWxsT2Y8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXVxuICApOiB0aGlzXG4gIGlsaWtlQWxsT2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFsbCBvZiBgcGF0dGVybnNgIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG4gICAqL1xuICBpbGlrZUFsbE9mKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW10pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlsaWtlKGFsbCkueyR7cGF0dGVybnMuam9pbignLCcpfX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBpbGlrZUFueU9mPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW11cbiAgKTogdGhpc1xuICBpbGlrZUFueU9mKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW10pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbnkgb2YgYHBhdHRlcm5zYCBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuICAgKi9cbiAgaWxpa2VBbnlPZihjb2x1bW46IHN0cmluZywgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbGlrZShhbnkpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaXM8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHZhbHVlOiBSb3dbQ29sdW1uTmFtZV0gJiAoYm9vbGVhbiB8IG51bGwpXG4gICk6IHRoaXNcbiAgaXMoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBib29sZWFuIHwgbnVsbCk6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBJUyBgdmFsdWVgLlxuICAgKlxuICAgKiBGb3Igbm9uLWJvb2xlYW4gY29sdW1ucywgdGhpcyBpcyBvbmx5IHJlbGV2YW50IGZvciBjaGVja2luZyBpZiB0aGUgdmFsdWUgb2ZcbiAgICogYGNvbHVtbmAgaXMgTlVMTCBieSBzZXR0aW5nIGB2YWx1ZWAgdG8gYG51bGxgLlxuICAgKlxuICAgKiBGb3IgYm9vbGVhbiBjb2x1bW5zLCB5b3UgY2FuIGFsc28gc2V0IGB2YWx1ZWAgdG8gYHRydWVgIG9yIGBmYWxzZWAgYW5kIGl0XG4gICAqIHdpbGwgYmVoYXZlIHRoZSBzYW1lIHdheSBhcyBgLmVxKClgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBpcyhjb2x1bW46IHN0cmluZywgdmFsdWU6IGJvb2xlYW4gfCBudWxsKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpcy4ke3ZhbHVlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgaW5jbHVkZWQgaW4gdGhlIGB2YWx1ZXNgIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgYXJyYXkgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGluPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmc+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZXM6IFJlc29sdmVGaWx0ZXJWYWx1ZTxTY2hlbWEsIFJvdywgQ29sdW1uTmFtZT4gZXh0ZW5kcyBuZXZlclxuICAgICAgPyB1bmtub3duW11cbiAgICAgIDogUmVhZG9ubHlBcnJheTxSZXNvbHZlRmlsdGVyVmFsdWU8U2NoZW1hLCBSb3csIENvbHVtbk5hbWU+PlxuICApOiB0aGlzIHtcbiAgICBjb25zdCBjbGVhbmVkVmFsdWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KHZhbHVlcykpXG4gICAgICAubWFwKChzKSA9PiB7XG4gICAgICAgIC8vIGhhbmRsZSBwb3N0Z3Jlc3QgcmVzZXJ2ZWQgY2hhcmFjdGVyc1xuICAgICAgICAvLyBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vdjcuMC4wL2FwaS5odG1sI3Jlc2VydmVkLWNoYXJhY3RlcnNcbiAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJyAmJiBuZXcgUmVnRXhwKCdbLCgpXScpLnRlc3QocykpIHJldHVybiBgXCIke3N9XCJgXG4gICAgICAgIGVsc2UgcmV0dXJuIGAke3N9YFxuICAgICAgfSlcbiAgICAgIC5qb2luKCcsJylcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGluLigke2NsZWFuZWRWYWx1ZXN9KWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGNvbnRhaW5zPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZTogc3RyaW5nIHwgUmVhZG9ubHlBcnJheTxSb3dbQ29sdW1uTmFtZV0+IHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgKTogdGhpc1xuICBjb250YWlucyhjb2x1bW46IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHJlYWRvbmx5IHVua25vd25bXSB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IganNvbmIsIGFycmF5LCBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAqIGBjb2x1bW5gIGNvbnRhaW5zIGV2ZXJ5IGVsZW1lbnQgYXBwZWFyaW5nIGluIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBjb250YWlucyhjb2x1bW46IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHJlYWRvbmx5IHVua25vd25bXSB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdGhpcyB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIHJhbmdlIHR5cGVzIGNhbiBiZSBpbmNsdXNpdmUgJ1snLCAnXScgb3IgZXhjbHVzaXZlICcoJywgJyknIHNvIGp1c3RcbiAgICAgIC8vIGtlZXAgaXQgc2ltcGxlIGFuZCBhY2NlcHQgYSBzdHJpbmdcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MuJHt2YWx1ZX1gKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIC8vIGFycmF5XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNzLnske3ZhbHVlLmpvaW4oJywnKX19YClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganNvblxuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjcy4ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgY29udGFpbmVkQnk8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBSZWFkb25seUFycmF5PFJvd1tDb2x1bW5OYW1lXT4gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICApOiB0aGlzXG4gIGNvbnRhaW5lZEJ5KGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgcmVhZG9ubHkgdW5rbm93bltdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB0aGlzXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGZvciBqc29uYiwgYXJyYXksIGFuZCByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcbiAgICogZXZlcnkgZWxlbWVudCBhcHBlYXJpbmcgaW4gYGNvbHVtbmAgaXMgY29udGFpbmVkIGJ5IGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBjb250YWluZWRCeShjb2x1bW46IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHJlYWRvbmx5IHVua25vd25bXSB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdGhpcyB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIHJhbmdlXG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLiR7dmFsdWV9YClcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAvLyBhcnJheVxuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjZC57JHt2YWx1ZS5qb2luKCcsJyl9fWApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGpzb25cbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY2QuJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJhbmdlR3Q8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICByYW5nZUd0KGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICogYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIGFueSBlbGVtZW50IGluIGByYW5nZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIHJhbmdlR3QoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYHNyLiR7cmFuZ2V9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmFuZ2VHdGU8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICByYW5nZUd0ZShjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXNcbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAqIGBjb2x1bW5gIGlzIGVpdGhlciBjb250YWluZWQgaW4gYHJhbmdlYCBvciBncmVhdGVyIHRoYW4gYW55IGVsZW1lbnQgaW5cbiAgICogYHJhbmdlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgcmFuZ2VHdGUoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG54bC4ke3JhbmdlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJhbmdlTHQ8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICByYW5nZUx0KGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICogYGNvbHVtbmAgaXMgbGVzcyB0aGFuIGFueSBlbGVtZW50IGluIGByYW5nZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIHJhbmdlTHQoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYHNsLiR7cmFuZ2V9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmFuZ2VMdGU8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICByYW5nZUx0ZShjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXNcbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAqIGBjb2x1bW5gIGlzIGVpdGhlciBjb250YWluZWQgaW4gYHJhbmdlYCBvciBsZXNzIHRoYW4gYW55IGVsZW1lbnQgaW5cbiAgICogYHJhbmdlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgcmFuZ2VMdGUoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG54ci4ke3JhbmdlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJhbmdlQWRqYWNlbnQ8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICByYW5nZUFkamFjZW50KGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzXG4gICAqIG11dHVhbGx5IGV4Y2x1c2l2ZSB0byBgcmFuZ2VgIGFuZCB0aGVyZSBjYW4gYmUgbm8gZWxlbWVudCBiZXR3ZWVuIHRoZSB0d29cbiAgICogcmFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICByYW5nZUFkamFjZW50KGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBhZGouJHtyYW5nZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBvdmVybGFwczxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgdmFsdWU6IHN0cmluZyB8IFJlYWRvbmx5QXJyYXk8Um93W0NvbHVtbk5hbWVdPlxuICApOiB0aGlzXG4gIG92ZXJsYXBzKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgcmVhZG9ubHkgdW5rbm93bltdKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgYXJyYXkgYW5kIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuICAgKiBgY29sdW1uYCBhbmQgYHZhbHVlYCBoYXZlIGFuIGVsZW1lbnQgaW4gY29tbW9uLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGFycmF5IG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGFycmF5IG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBvdmVybGFwcyhjb2x1bW46IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHJlYWRvbmx5IHVua25vd25bXSk6IHRoaXMge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyByYW5nZVxuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBvdi4ke3ZhbHVlfWApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFycmF5XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG92Lnske3ZhbHVlLmpvaW4oJywnKX19YClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRleHRTZWFyY2g8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHF1ZXJ5OiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgY29uZmlnPzogc3RyaW5nOyB0eXBlPzogJ3BsYWluJyB8ICdwaHJhc2UnIHwgJ3dlYnNlYXJjaCcgfVxuICApOiB0aGlzXG4gIHRleHRTZWFyY2goXG4gICAgY29sdW1uOiBzdHJpbmcsXG4gICAgcXVlcnk6IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyBjb25maWc/OiBzdHJpbmc7IHR5cGU/OiAncGxhaW4nIHwgJ3BocmFzZScgfCAnd2Vic2VhcmNoJyB9XG4gICk6IHRoaXNcbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgZm9yIHRleHQgYW5kIHRzdmVjdG9yIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuICAgKiBgY29sdW1uYCBtYXRjaGVzIHRoZSBxdWVyeSBzdHJpbmcgaW4gYHF1ZXJ5YC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSB0ZXh0IG9yIHRzdmVjdG9yIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRleHQgdG8gbWF0Y2ggd2l0aFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMuY29uZmlnIC0gVGhlIHRleHQgc2VhcmNoIGNvbmZpZ3VyYXRpb24gdG8gdXNlXG4gICAqIEBwYXJhbSBvcHRpb25zLnR5cGUgLSBDaGFuZ2UgaG93IHRoZSBgcXVlcnlgIHRleHQgaXMgaW50ZXJwcmV0ZWRcbiAgICovXG4gIHRleHRTZWFyY2goXG4gICAgY29sdW1uOiBzdHJpbmcsXG4gICAgcXVlcnk6IHN0cmluZyxcbiAgICB7IGNvbmZpZywgdHlwZSB9OiB7IGNvbmZpZz86IHN0cmluZzsgdHlwZT86ICdwbGFpbicgfCAncGhyYXNlJyB8ICd3ZWJzZWFyY2gnIH0gPSB7fVxuICApOiB0aGlzIHtcbiAgICBsZXQgdHlwZVBhcnQgPSAnJ1xuICAgIGlmICh0eXBlID09PSAncGxhaW4nKSB7XG4gICAgICB0eXBlUGFydCA9ICdwbCdcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdwaHJhc2UnKSB7XG4gICAgICB0eXBlUGFydCA9ICdwaCdcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd3ZWJzZWFyY2gnKSB7XG4gICAgICB0eXBlUGFydCA9ICd3J1xuICAgIH1cbiAgICBjb25zdCBjb25maWdQYXJ0ID0gY29uZmlnID09PSB1bmRlZmluZWQgPyAnJyA6IGAoJHtjb25maWd9KWBcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYCR7dHlwZVBhcnR9ZnRzJHtjb25maWdQYXJ0fS4ke3F1ZXJ5fWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG1hdGNoPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KHF1ZXJ5OiBSZWNvcmQ8Q29sdW1uTmFtZSwgUm93W0NvbHVtbk5hbWVdPik6IHRoaXNcbiAgbWF0Y2gocXVlcnk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGVhY2ggY29sdW1uIGluIGBxdWVyeWAga2V5cyBpcyBlcXVhbCB0byBpdHNcbiAgICogYXNzb2NpYXRlZCB2YWx1ZS4gU2hvcnRoYW5kIGZvciBtdWx0aXBsZSBgLmVxKClgcy5cbiAgICpcbiAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIG9iamVjdCB0byBmaWx0ZXIgd2l0aCwgd2l0aCBjb2x1bW4gbmFtZXMgYXMga2V5cyBtYXBwZWRcbiAgICogdG8gdGhlaXIgZmlsdGVyIHZhbHVlc1xuICAgKi9cbiAgbWF0Y2gocXVlcnk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdGhpcyB7XG4gICAgT2JqZWN0LmVudHJpZXMocXVlcnkpLmZvckVhY2goKFtjb2x1bW4sIHZhbHVlXSkgPT4ge1xuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBlcS4ke3ZhbHVlfWApXG4gICAgfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbm90PENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBvcGVyYXRvcjogRmlsdGVyT3BlcmF0b3IsXG4gICAgdmFsdWU6IFJvd1tDb2x1bW5OYW1lXVxuICApOiB0aGlzXG4gIG5vdChjb2x1bW46IHN0cmluZywgb3BlcmF0b3I6IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hpY2ggZG9lc24ndCBzYXRpc2Z5IHRoZSBmaWx0ZXIuXG4gICAqXG4gICAqIFVubGlrZSBtb3N0IGZpbHRlcnMsIGBvcGVhcmF0b3JgIGFuZCBgdmFsdWVgIGFyZSB1c2VkIGFzLWlzIGFuZCBuZWVkIHRvXG4gICAqIGZvbGxvdyBbUG9zdGdSRVNUXG4gICAqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG4gICAqIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBwcm9wZXJseSBzYW5pdGl6ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gb3BlcmF0b3IgLSBUaGUgb3BlcmF0b3IgdG8gYmUgbmVnYXRlZCB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nXG4gICAqIFBvc3RnUkVTVCBzeW50YXhcbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgKi9cbiAgbm90KGNvbHVtbjogc3RyaW5nLCBvcGVyYXRvcjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbm90LiR7b3BlcmF0b3J9LiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBzYXRpc2Z5IGF0IGxlYXN0IG9uZSBvZiB0aGUgZmlsdGVycy5cbiAgICpcbiAgICogVW5saWtlIG1vc3QgZmlsdGVycywgYGZpbHRlcnNgIGlzIHVzZWQgYXMtaXMgYW5kIG5lZWRzIHRvIGZvbGxvdyBbUG9zdGdSRVNUXG4gICAqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG4gICAqIHRvIG1ha2Ugc3VyZSBpdCdzIHByb3Blcmx5IHNhbml0aXplZC5cbiAgICpcbiAgICogSXQncyBjdXJyZW50bHkgbm90IHBvc3NpYmxlIHRvIGRvIGFuIGAub3IoKWAgZmlsdGVyIGFjcm9zcyBtdWx0aXBsZSB0YWJsZXMuXG4gICAqXG4gICAqIEBwYXJhbSBmaWx0ZXJzIC0gVGhlIGZpbHRlcnMgdG8gdXNlLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gZmlsdGVyIG9uIHJlZmVyZW5jZWQgdGFibGVzXG4gICAqIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYHJlZmVyZW5jZWRUYWJsZWAgaW5zdGVhZFxuICAgKi9cbiAgb3IoXG4gICAgZmlsdGVyczogc3RyaW5nLFxuICAgIHtcbiAgICAgIGZvcmVpZ25UYWJsZSxcbiAgICAgIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSxcbiAgICB9OiB7IGZvcmVpZ25UYWJsZT86IHN0cmluZzsgcmVmZXJlbmNlZFRhYmxlPzogc3RyaW5nIH0gPSB7fVxuICApOiB0aGlzIHtcbiAgICBjb25zdCBrZXkgPSByZWZlcmVuY2VkVGFibGUgPyBgJHtyZWZlcmVuY2VkVGFibGV9Lm9yYCA6ICdvcidcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgYCgke2ZpbHRlcnN9KWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGZpbHRlcjxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgb3BlcmF0b3I6IGAkeycnIHwgJ25vdC4nfSR7RmlsdGVyT3BlcmF0b3J9YCxcbiAgICB2YWx1ZTogdW5rbm93blxuICApOiB0aGlzXG4gIGZpbHRlcihjb2x1bW46IHN0cmluZywgb3BlcmF0b3I6IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hpY2ggc2F0aXNmeSB0aGUgZmlsdGVyLiBUaGlzIGlzIGFuIGVzY2FwZSBoYXRjaCAtIHlvdVxuICAgKiBzaG91bGQgdXNlIHRoZSBzcGVjaWZpYyBmaWx0ZXIgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZS5cbiAgICpcbiAgICogVW5saWtlIG1vc3QgZmlsdGVycywgYG9wZWFyYXRvcmAgYW5kIGB2YWx1ZWAgYXJlIHVzZWQgYXMtaXMgYW5kIG5lZWQgdG9cbiAgICogZm9sbG93IFtQb3N0Z1JFU1RcbiAgICogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcbiAgICogdG8gbWFrZSBzdXJlIHRoZXkgYXJlIHByb3Blcmx5IHNhbml0aXplZC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBvcGVyYXRvciAtIFRoZSBvcGVyYXRvciB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgKi9cbiAgZmlsdGVyKGNvbHVtbjogc3RyaW5nLCBvcGVyYXRvcjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgJHtvcGVyYXRvcn0uJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cbiIsICJpbXBvcnQgUG9zdGdyZXN0QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0RmlsdGVyQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXInXG5pbXBvcnQgeyBHZXRSZXN1bHQgfSBmcm9tICcuL3NlbGVjdC1xdWVyeS1wYXJzZXIvcmVzdWx0J1xuaW1wb3J0IHsgRmV0Y2gsIEdlbmVyaWNTY2hlbWEsIEdlbmVyaWNUYWJsZSwgR2VuZXJpY1ZpZXcgfSBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8XG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEsXG4gIFJlbGF0aW9uIGV4dGVuZHMgR2VuZXJpY1RhYmxlIHwgR2VuZXJpY1ZpZXcsXG4gIFJlbGF0aW9uTmFtZSA9IHVua25vd24sXG4gIFJlbGF0aW9uc2hpcHMgPSBSZWxhdGlvbiBleHRlbmRzIHsgUmVsYXRpb25zaGlwczogaW5mZXIgUiB9ID8gUiA6IHVua25vd25cbj4ge1xuICB1cmw6IFVSTFxuICBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIHNjaGVtYT86IHN0cmluZ1xuICBzaWduYWw/OiBBYm9ydFNpZ25hbFxuICBmZXRjaD86IEZldGNoXG5cbiAgY29uc3RydWN0b3IoXG4gICAgdXJsOiBVUkwsXG4gICAge1xuICAgICAgaGVhZGVycyA9IHt9LFxuICAgICAgc2NoZW1hLFxuICAgICAgZmV0Y2gsXG4gICAgfToge1xuICAgICAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICAgIHNjaGVtYT86IHN0cmluZ1xuICAgICAgZmV0Y2g/OiBGZXRjaFxuICAgIH1cbiAgKSB7XG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWFcbiAgICB0aGlzLmZldGNoID0gZmV0Y2hcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgU0VMRUNUIHF1ZXJ5IG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1ucyAtIFRoZSBjb2x1bW5zIHRvIHJldHJpZXZlLCBzZXBhcmF0ZWQgYnkgY29tbWFzLiBDb2x1bW5zIGNhbiBiZSByZW5hbWVkIHdoZW4gcmV0dXJuZWQgd2l0aCBgY3VzdG9tTmFtZTpjb2x1bW5OYW1lYFxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgKiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIGluIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgKlxuICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAqIGhvb2QuXG4gICAqXG4gICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAqXG4gICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICogbnVtYmVycy5cbiAgICovXG4gIHNlbGVjdDxcbiAgICBRdWVyeSBleHRlbmRzIHN0cmluZyA9ICcqJyxcbiAgICBSZXN1bHRPbmUgPSBHZXRSZXN1bHQ8U2NoZW1hLCBSZWxhdGlvblsnUm93J10sIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcywgUXVlcnk+XG4gID4oXG4gICAgY29sdW1ucz86IFF1ZXJ5LFxuICAgIHtcbiAgICAgIGhlYWQgPSBmYWxzZSxcbiAgICAgIGNvdW50LFxuICAgIH06IHtcbiAgICAgIGhlYWQ/OiBib29sZWFuXG4gICAgICBjb3VudD86ICdleGFjdCcgfCAncGxhbm5lZCcgfCAnZXN0aW1hdGVkJ1xuICAgIH0gPSB7fVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBSZXN1bHRPbmVbXSwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgY29uc3QgbWV0aG9kID0gaGVhZCA/ICdIRUFEJyA6ICdHRVQnXG4gICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2VzIGV4Y2VwdCB3aGVuIHF1b3RlZFxuICAgIGxldCBxdW90ZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNsZWFuZWRDb2x1bW5zID0gKGNvbHVtbnMgPz8gJyonKVxuICAgICAgLnNwbGl0KCcnKVxuICAgICAgLm1hcCgoYykgPT4ge1xuICAgICAgICBpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSB7XG4gICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICBxdW90ZWQgPSAhcXVvdGVkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH0pXG4gICAgICAuam9pbignJylcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZWxlY3QnLCBjbGVhbmVkQ29sdW1ucylcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBgY291bnQ9JHtjb3VudH1gXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICB9IGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxSZXN1bHRPbmVbXT4pXG4gIH1cblxuICAvLyBUT0RPKHYzKTogTWFrZSBgZGVmYXVsdFRvTnVsbGAgY29uc2lzdGVudCBmb3IgYm90aCBzaW5nbGUgJiBidWxrIGluc2VydHMuXG4gIGluc2VydDxSb3cgZXh0ZW5kcyBSZWxhdGlvbiBleHRlbmRzIHsgSW5zZXJ0OiB1bmtub3duIH0gPyBSZWxhdGlvblsnSW5zZXJ0J10gOiBuZXZlcj4oXG4gICAgdmFsdWVzOiBSb3csXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBudWxsLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+XG4gIGluc2VydDxSb3cgZXh0ZW5kcyBSZWxhdGlvbiBleHRlbmRzIHsgSW5zZXJ0OiB1bmtub3duIH0gPyBSZWxhdGlvblsnSW5zZXJ0J10gOiBuZXZlcj4oXG4gICAgdmFsdWVzOiBSb3dbXSxcbiAgICBvcHRpb25zPzoge1xuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICAgIGRlZmF1bHRUb051bGw/OiBib29sZWFuXG4gICAgfVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBudWxsLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+XG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIElOU0VSVCBpbnRvIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBpbnNlcnRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcbiAgICogd2l0aCBgLnNlbGVjdCgpYC5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gaW5zZXJ0LiBQYXNzIGFuIG9iamVjdCB0byBpbnNlcnQgYSBzaW5nbGUgcm93XG4gICAqIG9yIGFuIGFycmF5IHRvIGluc2VydCBtdWx0aXBsZSByb3dzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGluc2VydGVkIHJvd3MuXG4gICAqXG4gICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICogaG9vZC5cbiAgICpcbiAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICpcbiAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgKiBudW1iZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cbiAgICogT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIE9ubHkgYXBwbGllcyBmb3IgYnVsa1xuICAgKiBpbnNlcnRzLlxuICAgKi9cbiAgaW5zZXJ0PFJvdyBleHRlbmRzIFJlbGF0aW9uIGV4dGVuZHMgeyBJbnNlcnQ6IHVua25vd24gfSA/IFJlbGF0aW9uWydJbnNlcnQnXSA6IG5ldmVyPihcbiAgICB2YWx1ZXM6IFJvdyB8IFJvd1tdLFxuICAgIHtcbiAgICAgIGNvdW50LFxuICAgICAgZGVmYXVsdFRvTnVsbCA9IHRydWUsXG4gICAgfToge1xuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICAgIGRlZmF1bHRUb051bGw/OiBib29sZWFuXG4gICAgfSA9IHt9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8U2NoZW1hLCBSZWxhdGlvblsnUm93J10sIG51bGwsIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcz4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJ1xuXG4gICAgY29uc3QgcHJlZmVyc0hlYWRlcnMgPSBbXVxuICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pXG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaChgY291bnQ9JHtjb3VudH1gKVxuICAgIH1cbiAgICBpZiAoIWRlZmF1bHRUb051bGwpIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2goJ21pc3Npbmc9ZGVmYXVsdCcpXG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJylcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYy5jb25jYXQoT2JqZWN0LmtleXMoeCkpLCBbXSBhcyBzdHJpbmdbXSlcbiAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdW5pcXVlQ29sdW1ucyA9IFsuLi5uZXcgU2V0KGNvbHVtbnMpXS5tYXAoKGNvbHVtbikgPT4gYFwiJHtjb2x1bW59XCJgKVxuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdjb2x1bW5zJywgdW5pcXVlQ29sdW1ucy5qb2luKCcsJykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgYm9keTogdmFsdWVzLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICB9IGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxudWxsPilcbiAgfVxuXG4gIC8vIFRPRE8odjMpOiBNYWtlIGBkZWZhdWx0VG9OdWxsYCBjb25zaXN0ZW50IGZvciBib3RoIHNpbmdsZSAmIGJ1bGsgdXBzZXJ0cy5cbiAgdXBzZXJ0PFJvdyBleHRlbmRzIFJlbGF0aW9uIGV4dGVuZHMgeyBJbnNlcnQ6IHVua25vd24gfSA/IFJlbGF0aW9uWydJbnNlcnQnXSA6IG5ldmVyPihcbiAgICB2YWx1ZXM6IFJvdyxcbiAgICBvcHRpb25zPzoge1xuICAgICAgb25Db25mbGljdD86IHN0cmluZ1xuICAgICAgaWdub3JlRHVwbGljYXRlcz86IGJvb2xlYW5cbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBudWxsLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+XG4gIHVwc2VydDxSb3cgZXh0ZW5kcyBSZWxhdGlvbiBleHRlbmRzIHsgSW5zZXJ0OiB1bmtub3duIH0gPyBSZWxhdGlvblsnSW5zZXJ0J10gOiBuZXZlcj4oXG4gICAgdmFsdWVzOiBSb3dbXSxcbiAgICBvcHRpb25zPzoge1xuICAgICAgb25Db25mbGljdD86IHN0cmluZ1xuICAgICAgaWdub3JlRHVwbGljYXRlcz86IGJvb2xlYW5cbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgICBkZWZhdWx0VG9OdWxsPzogYm9vbGVhblxuICAgIH1cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxTY2hlbWEsIFJlbGF0aW9uWydSb3cnXSwgbnVsbCwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPlxuICAvKipcbiAgICogUGVyZm9ybSBhbiBVUFNFUlQgb24gdGhlIHRhYmxlIG9yIHZpZXcuIERlcGVuZGluZyBvbiB0aGUgY29sdW1uKHMpIHBhc3NlZFxuICAgKiB0byBgb25Db25mbGljdGAsIGAudXBzZXJ0KClgIGFsbG93cyB5b3UgdG8gcGVyZm9ybSB0aGUgZXF1aXZhbGVudCBvZlxuICAgKiBgLmluc2VydCgpYCBpZiBhIHJvdyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGBvbkNvbmZsaWN0YCBjb2x1bW5zIGRvZXNuJ3RcbiAgICogZXhpc3QsIG9yIGlmIGl0IGRvZXMgZXhpc3QsIHBlcmZvcm0gYW4gYWx0ZXJuYXRpdmUgYWN0aW9uIGRlcGVuZGluZyBvblxuICAgKiBgaWdub3JlRHVwbGljYXRlc2AuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHVwc2VydGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuICAgKiB3aXRoIGAuc2VsZWN0KClgLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cHNlcnQgd2l0aC4gUGFzcyBhbiBvYmplY3QgdG8gdXBzZXJ0IGFcbiAgICogc2luZ2xlIHJvdyBvciBhbiBhcnJheSB0byB1cHNlcnQgbXVsdGlwbGUgcm93cy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLm9uQ29uZmxpY3QgLSBDb21tYS1zZXBhcmF0ZWQgVU5JUVVFIGNvbHVtbihzKSB0byBzcGVjaWZ5IGhvd1xuICAgKiBkdXBsaWNhdGUgcm93cyBhcmUgZGV0ZXJtaW5lZC4gVHdvIHJvd3MgYXJlIGR1cGxpY2F0ZXMgaWYgYWxsIHRoZVxuICAgKiBgb25Db25mbGljdGAgY29sdW1ucyBhcmUgZXF1YWwuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgLSBJZiBgdHJ1ZWAsIGR1cGxpY2F0ZSByb3dzIGFyZSBpZ25vcmVkLiBJZlxuICAgKiBgZmFsc2VgLCBkdXBsaWNhdGUgcm93cyBhcmUgbWVyZ2VkIHdpdGggZXhpc3Rpbmcgcm93cy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwc2VydGVkIHJvd3MuXG4gICAqXG4gICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICogaG9vZC5cbiAgICpcbiAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICpcbiAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgKiBudW1iZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cbiAgICogT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIFRoaXMgb25seSBhcHBsaWVzIHdoZW5cbiAgICogaW5zZXJ0aW5nIG5ldyByb3dzLCBub3Qgd2hlbiBtZXJnaW5nIHdpdGggZXhpc3Rpbmcgcm93cyB1bmRlclxuICAgKiBgaWdub3JlRHVwbGljYXRlczogZmFsc2VgLiBUaGlzIGFsc28gb25seSBhcHBsaWVzIHdoZW4gZG9pbmcgYnVsayB1cHNlcnRzLlxuICAgKi9cbiAgdXBzZXJ0PFJvdyBleHRlbmRzIFJlbGF0aW9uIGV4dGVuZHMgeyBJbnNlcnQ6IHVua25vd24gfSA/IFJlbGF0aW9uWydJbnNlcnQnXSA6IG5ldmVyPihcbiAgICB2YWx1ZXM6IFJvdyB8IFJvd1tdLFxuICAgIHtcbiAgICAgIG9uQ29uZmxpY3QsXG4gICAgICBpZ25vcmVEdXBsaWNhdGVzID0gZmFsc2UsXG4gICAgICBjb3VudCxcbiAgICAgIGRlZmF1bHRUb051bGwgPSB0cnVlLFxuICAgIH06IHtcbiAgICAgIG9uQ29uZmxpY3Q/OiBzdHJpbmdcbiAgICAgIGlnbm9yZUR1cGxpY2F0ZXM/OiBib29sZWFuXG4gICAgICBjb3VudD86ICdleGFjdCcgfCAncGxhbm5lZCcgfCAnZXN0aW1hdGVkJ1xuICAgICAgZGVmYXVsdFRvTnVsbD86IGJvb2xlYW5cbiAgICB9ID0ge31cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxTY2hlbWEsIFJlbGF0aW9uWydSb3cnXSwgbnVsbCwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnXG5cbiAgICBjb25zdCBwcmVmZXJzSGVhZGVycyA9IFtgcmVzb2x1dGlvbj0ke2lnbm9yZUR1cGxpY2F0ZXMgPyAnaWdub3JlJyA6ICdtZXJnZSd9LWR1cGxpY2F0ZXNgXVxuXG4gICAgaWYgKG9uQ29uZmxpY3QgIT09IHVuZGVmaW5lZCkgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldCgnb25fY29uZmxpY3QnLCBvbkNvbmZsaWN0KVxuICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pXG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaChgY291bnQ9JHtjb3VudH1gKVxuICAgIH1cbiAgICBpZiAoIWRlZmF1bHRUb051bGwpIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2goJ21pc3Npbmc9ZGVmYXVsdCcpXG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJylcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYy5jb25jYXQoT2JqZWN0LmtleXMoeCkpLCBbXSBhcyBzdHJpbmdbXSlcbiAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdW5pcXVlQ29sdW1ucyA9IFsuLi5uZXcgU2V0KGNvbHVtbnMpXS5tYXAoKGNvbHVtbikgPT4gYFwiJHtjb2x1bW59XCJgKVxuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdjb2x1bW5zJywgdW5pcXVlQ29sdW1ucy5qb2luKCcsJykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgYm9keTogdmFsdWVzLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICB9IGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxudWxsPilcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIFVQREFURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdXBkYXRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcbiAgICogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cGRhdGUgd2l0aFxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwZGF0ZWQgcm93cy5cbiAgICpcbiAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgKiBob29kLlxuICAgKlxuICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgKlxuICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAqIG51bWJlcnMuXG4gICAqL1xuICB1cGRhdGU8Um93IGV4dGVuZHMgUmVsYXRpb24gZXh0ZW5kcyB7IFVwZGF0ZTogdW5rbm93biB9ID8gUmVsYXRpb25bJ1VwZGF0ZSddIDogbmV2ZXI+KFxuICAgIHZhbHVlczogUm93LFxuICAgIHtcbiAgICAgIGNvdW50LFxuICAgIH06IHtcbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfSA9IHt9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8U2NoZW1hLCBSZWxhdGlvblsnUm93J10sIG51bGwsIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcz4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdQQVRDSCdcbiAgICBjb25zdCBwcmVmZXJzSGVhZGVycyA9IFtdXG4gICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2godGhpcy5oZWFkZXJzWydQcmVmZXInXSlcbiAgICB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApXG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJylcblxuICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgIGJvZHk6IHZhbHVlcyxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgfSBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8bnVsbD4pXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhIERFTEVURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgZGVsZXRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcbiAgICogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGRlbGV0ZWQgcm93cy5cbiAgICpcbiAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgKiBob29kLlxuICAgKlxuICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgKlxuICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAqIG51bWJlcnMuXG4gICAqL1xuICBkZWxldGUoe1xuICAgIGNvdW50LFxuICB9OiB7XG4gICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgfSA9IHt9KTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxTY2hlbWEsIFJlbGF0aW9uWydSb3cnXSwgbnVsbCwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSdcbiAgICBjb25zdCBwcmVmZXJzSGVhZGVycyA9IFtdXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApXG4gICAgfVxuICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy51bnNoaWZ0KHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pXG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJylcblxuICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgfSBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8bnVsbD4pXG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcxLjE3LjExJ1xuIiwgImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nXG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBwb3N0Z3Jlc3QtanMvJHt2ZXJzaW9ufWAgfVxuIiwgImltcG9ydCBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgZnJvbSAnLi9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0RmlsdGVyQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEJ1aWxkZXInXG5pbXBvcnQgeyBERUZBVUxUX0hFQURFUlMgfSBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB7IEZldGNoLCBHZW5lcmljU2NoZW1hIH0gZnJvbSAnLi90eXBlcydcblxuLyoqXG4gKiBQb3N0Z1JFU1QgY2xpZW50LlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0YWJhc2UgLSBUeXBlcyBmb3IgdGhlIHNjaGVtYSBmcm9tIHRoZSBbdHlwZVxuICogZ2VuZXJhdG9yXShodHRwczovL3N1cGFiYXNlLmNvbS9kb2NzL3JlZmVyZW5jZS9qYXZhc2NyaXB0L25leHQvdHlwZXNjcmlwdC1zdXBwb3J0KVxuICpcbiAqIEB0eXBlUGFyYW0gU2NoZW1hTmFtZSAtIFBvc3RncmVzIHNjaGVtYSB0byBzd2l0Y2ggdG8uIE11c3QgYmUgYSBzdHJpbmdcbiAqIGxpdGVyYWwsIHRoZSBzYW1lIG9uZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiBJZiB0aGUgc2NoZW1hIGlzIG5vdFxuICogYFwicHVibGljXCJgLCB0aGlzIG11c3QgYmUgc3VwcGxpZWQgbWFudWFsbHkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdENsaWVudDxcbiAgRGF0YWJhc2UgPSBhbnksXG4gIFNjaGVtYU5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSA9ICdwdWJsaWMnIGV4dGVuZHMga2V5b2YgRGF0YWJhc2VcbiAgICA/ICdwdWJsaWMnXG4gICAgOiBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSxcbiAgU2NoZW1hIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSA9IERhdGFiYXNlW1NjaGVtYU5hbWVdIGV4dGVuZHMgR2VuZXJpY1NjaGVtYVxuICAgID8gRGF0YWJhc2VbU2NoZW1hTmFtZV1cbiAgICA6IGFueVxuPiB7XG4gIHVybDogc3RyaW5nXG4gIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgc2NoZW1hTmFtZT86IFNjaGVtYU5hbWVcbiAgZmV0Y2g/OiBGZXRjaFxuXG4gIC8vIFRPRE86IEFkZCBiYWNrIHNob3VsZFRocm93T25FcnJvciBvbmNlIHdlIGZpZ3VyZSBvdXQgdGhlIHR5cGluZ3NcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQb3N0Z1JFU1QgY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0gdXJsIC0gVVJMIG9mIHRoZSBQb3N0Z1JFU1QgZW5kcG9pbnRcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgLSBDdXN0b20gaGVhZGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5zY2hlbWEgLSBQb3N0Z3JlcyBzY2hlbWEgdG8gc3dpdGNoIHRvXG4gICAqIEBwYXJhbSBvcHRpb25zLmZldGNoIC0gQ3VzdG9tIGZldGNoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICB1cmw6IHN0cmluZyxcbiAgICB7XG4gICAgICBoZWFkZXJzID0ge30sXG4gICAgICBzY2hlbWEsXG4gICAgICBmZXRjaCxcbiAgICB9OiB7XG4gICAgICBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgICAgc2NoZW1hPzogU2NoZW1hTmFtZVxuICAgICAgZmV0Y2g/OiBGZXRjaFxuICAgIH0gPSB7fVxuICApIHtcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMuaGVhZGVycyA9IHsgLi4uREVGQVVMVF9IRUFERVJTLCAuLi5oZWFkZXJzIH1cbiAgICB0aGlzLnNjaGVtYU5hbWUgPSBzY2hlbWFcbiAgICB0aGlzLmZldGNoID0gZmV0Y2hcbiAgfVxuXG4gIGZyb208XG4gICAgVGFibGVOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgU2NoZW1hWydUYWJsZXMnXSxcbiAgICBUYWJsZSBleHRlbmRzIFNjaGVtYVsnVGFibGVzJ11bVGFibGVOYW1lXVxuICA+KHJlbGF0aW9uOiBUYWJsZU5hbWUpOiBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8U2NoZW1hLCBUYWJsZSwgVGFibGVOYW1lPlxuICBmcm9tPFZpZXdOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgU2NoZW1hWydWaWV3cyddLCBWaWV3IGV4dGVuZHMgU2NoZW1hWydWaWV3cyddW1ZpZXdOYW1lXT4oXG4gICAgcmVsYXRpb246IFZpZXdOYW1lXG4gICk6IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjxTY2hlbWEsIFZpZXcsIFZpZXdOYW1lPlxuICAvKipcbiAgICogUGVyZm9ybSBhIHF1ZXJ5IG9uIGEgdGFibGUgb3IgYSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gcmVsYXRpb24gLSBUaGUgdGFibGUgb3IgdmlldyBuYW1lIHRvIHF1ZXJ5XG4gICAqL1xuICBmcm9tKHJlbGF0aW9uOiBzdHJpbmcpOiBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8U2NoZW1hLCBhbnksIGFueT4ge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9LyR7cmVsYXRpb259YClcbiAgICByZXR1cm4gbmV3IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcih1cmwsIHtcbiAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzIH0sXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hTmFtZSxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGEgc2NoZW1hIHRvIHF1ZXJ5IG9yIHBlcmZvcm0gYW4gZnVuY3Rpb24gKHJwYykgY2FsbC5cbiAgICpcbiAgICogVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuICAgKlxuICAgKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSB0byBxdWVyeVxuICAgKi9cbiAgc2NoZW1hPER5bmFtaWNTY2hlbWEgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZT4oXG4gICAgc2NoZW1hOiBEeW5hbWljU2NoZW1hXG4gICk6IFBvc3RncmVzdENsaWVudDxcbiAgICBEYXRhYmFzZSxcbiAgICBEeW5hbWljU2NoZW1hLFxuICAgIERhdGFiYXNlW0R5bmFtaWNTY2hlbWFdIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSA/IERhdGFiYXNlW0R5bmFtaWNTY2hlbWFdIDogYW55XG4gID4ge1xuICAgIHJldHVybiBuZXcgUG9zdGdyZXN0Q2xpZW50KHRoaXMudXJsLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWEsXG4gICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBmdW5jdGlvbiBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gbmFtZSB0byBjYWxsXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBjYWxsXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG4gICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICogQHBhcmFtIG9wdGlvbnMuZ2V0IC0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aFxuICAgKiByZWFkLW9ubHkgYWNjZXNzIG1vZGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIHJldHVybmVkIGJ5IHRoZVxuICAgKiBmdW5jdGlvbi4gT25seSBhcHBsaWNhYmxlIGZvciBbc2V0LXJldHVybmluZ1xuICAgKiBmdW5jdGlvbnNdKGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9mdW5jdGlvbnMtc3JmLmh0bWwpLlxuICAgKlxuICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAqIGhvb2QuXG4gICAqXG4gICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAqXG4gICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICogbnVtYmVycy5cbiAgICovXG4gIHJwYzxGbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBTY2hlbWFbJ0Z1bmN0aW9ucyddLCBGbiBleHRlbmRzIFNjaGVtYVsnRnVuY3Rpb25zJ11bRm5OYW1lXT4oXG4gICAgZm46IEZuTmFtZSxcbiAgICBhcmdzOiBGblsnQXJncyddID0ge30sXG4gICAge1xuICAgICAgaGVhZCA9IGZhbHNlLFxuICAgICAgZ2V0ID0gZmFsc2UsXG4gICAgICBjb3VudCxcbiAgICB9OiB7XG4gICAgICBoZWFkPzogYm9vbGVhblxuICAgICAgZ2V0PzogYm9vbGVhblxuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICB9ID0ge31cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxcbiAgICBTY2hlbWEsXG4gICAgRm5bJ1JldHVybnMnXSBleHRlbmRzIGFueVtdXG4gICAgICA/IEZuWydSZXR1cm5zJ11bbnVtYmVyXSBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gICAgICAgID8gRm5bJ1JldHVybnMnXVtudW1iZXJdXG4gICAgICAgIDogbmV2ZXJcbiAgICAgIDogbmV2ZXIsXG4gICAgRm5bJ1JldHVybnMnXSxcbiAgICBGbk5hbWUsXG4gICAgbnVsbFxuICA+IHtcbiAgICBsZXQgbWV0aG9kOiAnSEVBRCcgfCAnR0VUJyB8ICdQT1NUJ1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9L3JwYy8ke2ZufWApXG4gICAgbGV0IGJvZHk6IHVua25vd24gfCB1bmRlZmluZWRcbiAgICBpZiAoaGVhZCB8fCBnZXQpIHtcbiAgICAgIG1ldGhvZCA9IGhlYWQgPyAnSEVBRCcgOiAnR0VUJ1xuICAgICAgT2JqZWN0LmVudHJpZXMoYXJncylcbiAgICAgICAgLy8gcGFyYW1zIHdpdGggdW5kZWZpbmVkIHZhbHVlIG5lZWRzIHRvIGJlIGZpbHRlcmVkIG91dCwgb3RoZXJ3aXNlIGl0J2xsXG4gICAgICAgIC8vIHNob3cgdXAgYXMgYD9wYXJhbT11bmRlZmluZWRgXG4gICAgICAgIC5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIC8vIGFycmF5IHZhbHVlcyBuZWVkIHNwZWNpYWwgc3ludGF4XG4gICAgICAgIC5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IFtuYW1lLCBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGB7JHt2YWx1ZS5qb2luKCcsJyl9fWAgOiBgJHt2YWx1ZX1gXSlcbiAgICAgICAgLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbWV0aG9kID0gJ1BPU1QnXG4gICAgICBib2R5ID0gYXJnc1xuICAgIH1cblxuICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXMuaGVhZGVycyB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBoZWFkZXJzWydQcmVmZXInXSA9IGBjb3VudD0ke2NvdW50fWBcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuICAgICAgbWV0aG9kLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWFOYW1lLFxuICAgICAgYm9keSxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgfSBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8Rm5bJ1JldHVybnMnXT4pXG4gIH1cbn1cbiIsICIvLyBBbHdheXMgdXBkYXRlIHdyYXBwZXIubWpzIHdoZW4gdXBkYXRpbmcgdGhpcyBmaWxlLlxuaW1wb3J0IFBvc3RncmVzdENsaWVudCBmcm9tICcuL1Bvc3RncmVzdENsaWVudCdcbmltcG9ydCBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgZnJvbSAnLi9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0RmlsdGVyQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0RXJyb3IgZnJvbSAnLi9Qb3N0Z3Jlc3RFcnJvcidcblxuZXhwb3J0IHtcbiAgUG9zdGdyZXN0Q2xpZW50LFxuICBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIsXG4gIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsXG4gIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIsXG4gIFBvc3RncmVzdEJ1aWxkZXIsXG4gIFBvc3RncmVzdEVycm9yLFxufVxuZXhwb3J0IGRlZmF1bHQge1xuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbiAgUG9zdGdyZXN0QnVpbGRlcixcbiAgUG9zdGdyZXN0RXJyb3IsXG59XG5leHBvcnQgdHlwZSB7XG4gIFBvc3RncmVzdFJlc3BvbnNlLFxuICBQb3N0Z3Jlc3RSZXNwb25zZUZhaWx1cmUsXG4gIFBvc3RncmVzdFJlc3BvbnNlU3VjY2VzcyxcbiAgUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2UsXG4gIFBvc3RncmVzdE1heWJlU2luZ2xlUmVzcG9uc2UsXG59IGZyb20gJy4vdHlwZXMnXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy81NTFcbi8vIFRvIGJlIHJlcGxhY2VkIHdpdGggYSBoZWxwZXIgdHlwZSB0aGF0IG9ubHkgdXNlcyBwdWJsaWMgdHlwZXNcbmV4cG9ydCB0eXBlIHsgR2V0UmVzdWx0IGFzIFVuc3RhYmxlR2V0UmVzdWx0IH0gZnJvbSAnLi9zZWxlY3QtcXVlcnktcGFyc2VyL3Jlc3VsdCdcbiIsICIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3dzIGRvZXMgbm90IHdvcmsgaW4gdGhlIGJyb3dzZXIuIEJyb3dzZXIgY2xpZW50cyBtdXN0IHVzZSB0aGUgbmF0aXZlICcgK1xuICAgICAgJ1dlYlNvY2tldCBvYmplY3QnXG4gICk7XG59O1xuIiwgIi8vIHNyYy9tYWluLnRzXG5pbXBvcnQgeyBQbHVnaW4sIFRGaWxlLCBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBTdXBhYmFzZVNlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL1N1cGFiYXNlU2VydmljZSc7XG5pbXBvcnQgeyBPcGVuQUlTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy9PcGVuQUlTZXJ2aWNlJztcbmltcG9ydCB7IFF1ZXVlU2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvUXVldWVTZXJ2aWNlJztcbmltcG9ydCB7IEZpbGVUcmFja2VyIH0gZnJvbSAnLi91dGlscy9GaWxlVHJhY2tlcic7XG5pbXBvcnQgeyBFcnJvckhhbmRsZXIgfSBmcm9tICcuL3V0aWxzL0Vycm9ySGFuZGxlcic7XG5pbXBvcnQgeyBOb3RpZmljYXRpb25NYW5hZ2VyIH0gZnJvbSAnLi91dGlscy9Ob3RpZmljYXRpb25NYW5hZ2VyJztcbmltcG9ydCB7IE1pbmRNYXRyaXhTZXR0aW5nc1RhYiB9IGZyb20gJy4vc2V0dGluZ3MvU2V0dGluZ3NUYWInO1xuaW1wb3J0IHsgU3luY0ZpbGVNYW5hZ2VyIH0gZnJvbSAnLi9zZXJ2aWNlcy9TeW5jRmlsZU1hbmFnZXInO1xuaW1wb3J0IHsgSW5pdGlhbFN5bmNNYW5hZ2VyIH0gZnJvbSAnLi9zZXJ2aWNlcy9Jbml0aWFsU3luY01hbmFnZXInO1xuaW1wb3J0IHsgTWV0YWRhdGFFeHRyYWN0b3IgfSBmcm9tICcuL3NlcnZpY2VzL01ldGFkYXRhRXh0cmFjdG9yJztcbmltcG9ydCB7IFN0YXR1c01hbmFnZXIsIFBsdWdpblN0YXR1cyB9IGZyb20gJy4vc2VydmljZXMvU3RhdHVzTWFuYWdlcic7XG5pbXBvcnQgeyBTeW5jRGV0ZWN0aW9uTWFuYWdlciB9IGZyb20gJy4vc2VydmljZXMvU3luY0RldGVjdGlvbk1hbmFnZXInO1xuXG5pbXBvcnQge1xuICAgIE1pbmRNYXRyaXhTZXR0aW5ncyxcbiAgICBERUZBVUxUX1NFVFRJTkdTLFxuICAgIGlzVmF1bHRJbml0aWFsaXplZCxcbiAgICBnZW5lcmF0ZVZhdWx0SWQsXG4gICAgZ2V0QWxsRXhjbHVzaW9ucyxcbiAgICBTWVNURU1fRVhDTFVTSU9OU1xufSBmcm9tICcuL3NldHRpbmdzL1NldHRpbmdzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWluZE1hdHJpeFBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG5cdHNldHRpbmdzOiBNaW5kTWF0cml4U2V0dGluZ3M7XG5cdHByaXZhdGUgc3VwYWJhc2VTZXJ2aWNlOiBTdXBhYmFzZVNlcnZpY2UgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBvcGVuQUlTZXJ2aWNlOiBPcGVuQUlTZXJ2aWNlIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgcXVldWVTZXJ2aWNlOiBRdWV1ZVNlcnZpY2UgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBmaWxlVHJhY2tlcjogRmlsZVRyYWNrZXIgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBlcnJvckhhbmRsZXI6IEVycm9ySGFuZGxlciB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIG5vdGlmaWNhdGlvbk1hbmFnZXI6IE5vdGlmaWNhdGlvbk1hbmFnZXIgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBpc0luaXRpYWxpemluZyA9IGZhbHNlO1xuXHRwcml2YXRlIHN5bmNNYW5hZ2VyOiBTeW5jRmlsZU1hbmFnZXIgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBzeW5jQ2hlY2tJbnRlcnZhbDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBpbml0aWFsaXphdGlvblRpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgc3luY0NoZWNrQXR0ZW1wdHMgPSAwO1xuXHRwcml2YXRlIGluaXRpYWxTeW5jTWFuYWdlcjogSW5pdGlhbFN5bmNNYW5hZ2VyIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgbWV0YWRhdGFFeHRyYWN0b3I6IE1ldGFkYXRhRXh0cmFjdG9yIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgc3RhdHVzTWFuYWdlcjogU3RhdHVzTWFuYWdlciB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIHN5bmNEZXRlY3Rpb25NYW5hZ2VyOiBTeW5jRGV0ZWN0aW9uTWFuYWdlciB8IG51bGwgPSBudWxsO1xuXG5cdGFzeW5jIG9ubG9hZCgpIHtcblx0XHRjb25zb2xlLmxvZygnTG9hZGluZyBNaW5kIE1hdHJpeCBQbHVnaW4uLi4nKTtcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBJbml0aWFsaXplIHN0YXR1cyBtYW5hZ2VyIGZpcnN0XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXIgPSBuZXcgU3RhdHVzTWFuYWdlcih0aGlzLmFkZFN0YXR1c0Jhckl0ZW0oKSk7XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXIuc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5JTklUSUFMSVpJTkcsIHtcblx0XHRcdFx0bWVzc2FnZTogJ0xvYWRpbmcgTWluZCBNYXRyaXggUGx1Z2luLi4uJ1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIExvYWQgc2V0dGluZ3Ncblx0XHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cblx0XHRcdC8vIEluaXRpYWxpemUgY29yZSBzZXJ2aWNlc1xuXHRcdFx0YXdhaXQgdGhpcy5pbml0aWFsaXplQ29yZVNlcnZpY2VzKCk7XG5cblx0XHRcdC8vIEluaXRpYWxpemUgdmF1bHQgaWYgbmVlZGVkXG5cdFx0XHRhd2FpdCB0aGlzLmluaXRpYWxpemVWYXVsdElmTmVlZGVkKCk7XG5cblx0XHRcdC8vIEFkZCBzZXR0aW5ncyB0YWJcblx0XHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgTWluZE1hdHJpeFNldHRpbmdzVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cblx0XHRcdGlmIChpc1ZhdWx0SW5pdGlhbGl6ZWQodGhpcy5zZXR0aW5ncykpIHtcblx0XHRcdFx0Ly8gSW5pdGlhbGl6ZSBzeW5jIGRldGVjdGlvbiB1c2luZyBuZXcgc3luYyBmaWxlIGZvcm1hdCBpbnRlZ3JhdGlvblxuXHRcdFx0XHR0aGlzLnN0YXR1c01hbmFnZXIuc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5XQUlUSU5HX0ZPUl9TWU5DLCB7XG5cdFx0XHRcdFx0bWVzc2FnZTogJ1dhaXRpbmcgZm9yIE9ic2lkaWFuIHN5bmMgdG8gc2V0dGxlLi4uJ1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBDcmVhdGUgYW5kIHN0YXJ0IHN5bmMgZGV0ZWN0aW9uXG5cdFx0XHRcdHRoaXMuc3luY0RldGVjdGlvbk1hbmFnZXIgPSBuZXcgU3luY0RldGVjdGlvbk1hbmFnZXIoXG5cdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHR0aGlzLnN0YXR1c01hbmFnZXIsXG5cdFx0XHRcdFx0dGhpcy5vblN5bmNRdWlldFBlcmlvZFJlYWNoZWQuYmluZCh0aGlzKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHR0aGlzLnN5bmNEZXRlY3Rpb25NYW5hZ2VyLnN0YXJ0TW9uaXRvcmluZygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSWYgdmF1bHQgaXNuJ3QgaW5pdGlhbGl6ZWQsIHByb2NlZWQgbm9ybWFsbHlcblx0XHRcdFx0YXdhaXQgdGhpcy5jb21wbGV0ZUluaXRpYWxpemF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIE1pbmQgTWF0cml4IFBsdWdpbjonLCBlcnJvcik7XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuRVJST1IsIHtcblx0XHRcdFx0bWVzc2FnZTogJ0ZhaWxlZCB0byBpbml0aWFsaXplIHBsdWdpbi4gQ2hlY2sgY29uc29sZSBmb3IgZGV0YWlscy4nLFxuXHRcdFx0XHRlcnJvcjogZXJyb3IgYXMgRXJyb3Jcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgb25TeW5jUXVpZXRQZXJpb2RSZWFjaGVkKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBTdG9wIG1vbml0b3JpbmcgYXMgd2UndmUgcmVhY2hlZCBxdWlldCBwZXJpb2Rcblx0XHRcdHRoaXMuc3luY0RldGVjdGlvbk1hbmFnZXI/LnN0b3BNb25pdG9yaW5nKCk7XG5cblx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlcj8uc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5DSEVDS0lOR19GSUxFLCB7XG5cdFx0XHRcdG1lc3NhZ2U6ICdJbml0aWFsaXppbmcgc3luYyBtYW5hZ2VyIHdpdGggdXBkYXRlZCBzeW5jIGZpbGUgZm9ybWF0Li4uJ1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEluaXRpYWxpemUgc3luYyBtYW5hZ2VyIHdpdGggbmV3IHN5bmMgZmlsZSBwYXJhbWV0ZXJzXG5cdFx0XHRhd2FpdCB0aGlzLmluaXRpYWxpemVTeW5jTWFuYWdlcigpO1xuXG5cdFx0XHQvLyBTdGFydCBzeW5jIHByb2Nlc3MgdXNpbmcgbmV3IHN5bmMgZmlsZSBhcmNoaXRlY3R1cmVcblx0XHRcdGF3YWl0IHRoaXMuc3RhcnRTeW5jUHJvY2VzcygpO1xuXG5cdFx0XHQvLyBDb21wbGV0ZSByZW1haW5pbmcgaW5pdGlhbGl6YXRpb25cblx0XHRcdGF3YWl0IHRoaXMuY29tcGxldGVJbml0aWFsaXphdGlvbigpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgcXVpZXQgcGVyaW9kIGluaXRpYWxpemF0aW9uOicsIGVycm9yKTtcblx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlcj8uc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5FUlJPUiwge1xuXHRcdFx0XHRtZXNzYWdlOiAnRmFpbGVkIHRvIGluaXRpYWxpemUgYWZ0ZXIgc3luYyBxdWlldCBwZXJpb2QnLFxuXHRcdFx0XHRlcnJvcjogZXJyb3IgYXMgRXJyb3Jcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgY29tcGxldGVJbml0aWFsaXphdGlvbigpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gUmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnMgYW5kIGNvbW1hbmRzXG5cdFx0XHR0aGlzLnJlZ2lzdGVyRXZlbnRIYW5kbGVycygpO1xuXHRcdFx0dGhpcy5hZGRDb21tYW5kcygpO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3RhdHVzIHRvIHJlYWR5XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuUkVBRFksIHtcblx0XHRcdFx0bWVzc2FnZTogJ01pbmQgTWF0cml4IGlzIHJlYWR5J1xuXHRcdFx0fSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvbXBsZXRpbmcgaW5pdGlhbGl6YXRpb246JywgZXJyb3IpO1xuXHRcdFx0dGhpcy5zdGF0dXNNYW5hZ2VyPy5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLkVSUk9SLCB7XG5cdFx0XHRcdG1lc3NhZ2U6ICdGYWlsZWQgdG8gY29tcGxldGUgaW5pdGlhbGl6YXRpb24nLFxuXHRcdFx0XHRlcnJvcjogZXJyb3IgYXMgRXJyb3Jcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIG9udW5sb2FkKCkge1xuXHRcdGNvbnNvbGUubG9nKCdVbmxvYWRpbmcgTWluZCBNYXRyaXggUGx1Z2luLi4uJyk7XG5cblx0XHQvLyBTdG9wIHN5bmMgZGV0ZWN0aW9uXG5cdFx0dGhpcy5zeW5jRGV0ZWN0aW9uTWFuYWdlcj8uc3RvcE1vbml0b3JpbmcoKTtcblxuXHRcdGlmICh0aGlzLmluaXRpYWxpemF0aW9uVGltZW91dCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuaW5pdGlhbGl6YXRpb25UaW1lb3V0KTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwpIHtcblx0XHRcdGNsZWFySW50ZXJ2YWwodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5xdWV1ZVNlcnZpY2U/LnN0b3AoKTtcblx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXI/LmNsZWFyKCk7XG5cdFx0dGhpcy5pbml0aWFsU3luY01hbmFnZXI/LnN0b3AoKTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgc3RhcnRTeW5jUHJvY2VzcygpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuc3luY01hbmFnZXIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignU3luYyBtYW5hZ2VyIG5vdCBpbml0aWFsaXplZCcpO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuQ0hFQ0tJTkdfRklMRSwge1xuXHRcdFx0XHRtZXNzYWdlOiAnQ2hlY2tpbmcgc3luYyBmaWxlIHN0YXR1cyB3aXRoIG5ldyBzdHJ1Y3R1cmUuLi4nXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gVmFsaWRhdGUgc3luYyBmaWxlIHN0YXRlIHVzaW5nIG5ldyBhcmNoaXRlY3R1cmVcblx0XHRcdGNvbnN0IHN5bmNTdGF0dXMgPSBhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLnZhbGlkYXRlU3luY1N0YXRlKCk7XG5cblx0XHRcdGlmICghc3luY1N0YXR1cy5pc1ZhbGlkKSB7XG5cdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLnN5bmMucmVxdWlyZVN5bmMpIHtcblx0XHRcdFx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuRVJST1IsIHtcblx0XHRcdFx0XHRcdG1lc3NhZ2U6IGBTeW5jIHZhbGlkYXRpb24gZmFpbGVkOiAke3N5bmNTdGF0dXMuZXJyb3J9YFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgU3luYyB2YWxpZGF0aW9uIGZhaWxlZDogJHtzeW5jU3RhdHVzLmVycm9yfWApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybihgU3luYyB2YWxpZGF0aW9uIHdhcm5pbmc6ICR7c3luY1N0YXR1cy5lcnJvcn1gKTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBTeW5jIHdhcm5pbmc6ICR7c3luY1N0YXR1cy5lcnJvcn1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuSU5JVElBTElaSU5HLCB7XG5cdFx0XHRcdG1lc3NhZ2U6ICdJbml0aWFsaXppbmcgc2VydmljZXMuLi4nXG5cdFx0XHR9KTtcblx0XHRcdGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVNlcnZpY2VzKCk7XG5cblx0XHRcdC8vIFN0YXJ0IHBlcmlvZGljIHN5bmMgY2hlY2tzIHVzaW5nIHVwZGF0ZWQgcGFyYW1ldGVyc1xuXHRcdFx0dGhpcy5zdGFydFBlcmlvZGljU3luY0NoZWNrcygpO1xuXG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5pbml0aWFsU3luYy5lbmFibGVBdXRvSW5pdGlhbFN5bmMgJiYgdGhpcy5pbml0aWFsU3luY01hbmFnZXIpIHtcblx0XHRcdFx0dGhpcy5zdGF0dXNNYW5hZ2VyPy5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLklOSVRJQUxJWklORywge1xuXHRcdFx0XHRcdG1lc3NhZ2U6ICdTdGFydGluZyBpbml0aWFsIHZhdWx0IHN5bmMuLi4nXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRhd2FpdCB0aGlzLmluaXRpYWxTeW5jTWFuYWdlci5zdGFydFN5bmMoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zdGF0dXNNYW5hZ2VyPy5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLlJFQURZLCB7XG5cdFx0XHRcdG1lc3NhZ2U6ICdTeW5jIHByb2Nlc3MgY29tcGxldGVkJ1xuXHRcdFx0fSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLnN5bmMucmVxdWlyZVN5bmMpIHtcblx0XHRcdFx0dGhpcy5zdGF0dXNNYW5hZ2VyPy5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLkVSUk9SLCB7XG5cdFx0XHRcdFx0bWVzc2FnZTogJ1N5bmMgcHJvY2VzcyBmYWlsZWQnLFxuXHRcdFx0XHRcdGVycm9yOiBlcnJvciBhcyBFcnJvclxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdTeW5jIHByb2Nlc3MgZXJyb3I6JywgZXJyb3IpO1xuXHRcdFx0XHRuZXcgTm90aWNlKCdTeW5jIHByb2Nlc3MgZXJyb3IuIENvbnRpbnVpbmcgd2l0aCBsaW1pdGVkIGZ1bmN0aW9uYWxpdHkuJyk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVNlcnZpY2VzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBpbml0aWFsaXplU3luY01hbmFnZXIoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCF0aGlzLmVycm9ySGFuZGxlcikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFcnJvciBoYW5kbGVyIG11c3QgYmUgaW5pdGlhbGl6ZWQgYmVmb3JlIHN5bmMgbWFuYWdlcicpO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGEgdmF1bHQgSUQgaXMgZGVmaW5lZCBiZWZvcmUgY3JlYXRpbmcgdGhlIHN5bmMgbWFuYWdlci5cblx0XHRpZiAoIXRoaXMuc2V0dGluZ3MudmF1bHRJZCkge1xuXHRcdFx0dGhpcy5zZXR0aW5ncy52YXVsdElkID0gZ2VuZXJhdGVWYXVsdElkKCk7XG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBQYXNzIHZhdWx0SWQsIGRldmljZUlkLCBkZXZpY2VOYW1lLCBhbmQgcGx1Z2luIHZlcnNpb24gdG8gdGhlIG5ldyBTeW5jRmlsZU1hbmFnZXJcblx0XHRcdHRoaXMuc3luY01hbmFnZXIgPSBuZXcgU3luY0ZpbGVNYW5hZ2VyKFxuXHRcdFx0XHR0aGlzLmFwcC52YXVsdCxcblx0XHRcdFx0dGhpcy5lcnJvckhhbmRsZXIsXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3luYy5zeW5jRmlsZVBhdGgsXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3luYy5iYWNrdXBJbnRlcnZhbCxcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy52YXVsdElkLCAvLyBOb3cgZ3VhcmFudGVlZCB0byBiZSBkZWZpbmVkXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3luYy5kZXZpY2VJZCxcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5zeW5jLmRldmljZU5hbWUsXG5cdFx0XHRcdHRoaXMubWFuaWZlc3QudmVyc2lvblxuXHRcdFx0KTtcblxuXHRcdFx0YXdhaXQgdGhpcy5zeW5jTWFuYWdlci5pbml0aWFsaXplKCk7XG5cdFx0XHRjb25zb2xlLmxvZygnU3luYyBtYW5hZ2VyIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSB3aXRoIG5ldyBzeW5jIGZpbGUgZm9ybWF0Jyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIHN5bmMgbWFuYWdlcjonLCBlcnJvcik7XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoJ0ZhaWxlZCB0byBpbml0aWFsaXplIHN5bmMgc3lzdGVtLiBTb21lIGZlYXR1cmVzIG1heSBiZSB1bmF2YWlsYWJsZS4nKTtcblx0XHRcdH1cblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZUNvcmVTZXJ2aWNlcygpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuSU5JVElBTElaSU5HLCB7XG5cdFx0XHRtZXNzYWdlOiAnSW5pdGlhbGl6aW5nIGNvcmUgc2VydmljZXMuLi4nXG5cdFx0fSk7XG5cblx0XHQvLyBJbml0aWFsaXplIGVycm9yIGhhbmRsZXJcblx0XHR0aGlzLmVycm9ySGFuZGxlciA9IG5ldyBFcnJvckhhbmRsZXIoXG5cdFx0XHR0aGlzLnNldHRpbmdzPy5kZWJ1ZyA/PyBERUZBVUxUX1NFVFRJTkdTLmRlYnVnLFxuXHRcdFx0dGhpcy5hcHAudmF1bHQuYWRhcHRlci5nZXRCYXNlUGF0aCgpXG5cdFx0KTtcblxuXHRcdC8vIEluaXRpYWxpemUgbm90aWZpY2F0aW9uIG1hbmFnZXJcblx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIgPSBuZXcgTm90aWZpY2F0aW9uTWFuYWdlcihcblx0XHRcdHRoaXMuYWRkU3RhdHVzQmFySXRlbSgpLFxuXHRcdFx0dGhpcy5zZXR0aW5ncz8uZW5hYmxlTm90aWZpY2F0aW9ucyA/PyB0cnVlLFxuXHRcdFx0dGhpcy5zZXR0aW5ncz8uZW5hYmxlUHJvZ3Jlc3NCYXIgPz8gdHJ1ZVxuXHRcdCk7XG5cblx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuSU5JVElBTElaSU5HLCB7XG5cdFx0XHRtZXNzYWdlOiAnQ29yZSBzZXJ2aWNlcyBpbml0aWFsaXplZCdcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuXG5cdFx0Ly8gRW5zdXJlIGV4Y2x1c2lvbnMgaGF2ZSB0aGUgZXhwZWN0ZWQgc3RydWN0dXJlXG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMpIHtcblx0XHRcdHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucyA9IHsgLi4uREVGQVVMVF9TRVRUSU5HUy5leGNsdXNpb25zIH07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIGFsbCBwcm9wZXJ0aWVzIGV4aXN0IGFuZCBhcmUgYXJyYXlzXG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuZXhjbHVkZWRGb2xkZXJzKSB7XG5cdFx0XHR0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuZXhjbHVkZWRGb2xkZXJzID0gW107XG5cdFx0fVxuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVR5cGVzKSB7XG5cdFx0XHR0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlVHlwZXMgPSBbXTtcblx0XHR9XG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlUHJlZml4ZXMpIHtcblx0XHRcdHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVQcmVmaXhlcyA9IFtdO1xuXHRcdH1cblx0XHRpZiAoIXRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVzKSB7XG5cdFx0XHR0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlcyA9IFtdO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSBzeXN0ZW0gZXhjbHVzaW9ucyBleGlzdFxuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLnN5c3RlbUV4Y2x1ZGVkRm9sZGVycykge1xuXHRcdFx0dGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLnN5c3RlbUV4Y2x1ZGVkRm9sZGVycyA9IFsuLi5TWVNURU1fRVhDTFVTSU9OUy5mb2xkZXJzXTtcblx0XHR9XG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuc3lzdGVtRXhjbHVkZWRGaWxlVHlwZXMpIHtcblx0XHRcdHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5zeXN0ZW1FeGNsdWRlZEZpbGVUeXBlcyA9IFsuLi5TWVNURU1fRVhDTFVTSU9OUy5maWxlVHlwZXNdO1xuXHRcdH1cblx0XHRpZiAoIXRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5zeXN0ZW1FeGNsdWRlZEZpbGVQcmVmaXhlcykge1xuXHRcdFx0dGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLnN5c3RlbUV4Y2x1ZGVkRmlsZVByZWZpeGVzID0gWy4uLlNZU1RFTV9FWENMVVNJT05TLmZpbGVQcmVmaXhlc107XG5cdFx0fVxuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLnN5c3RlbUV4Y2x1ZGVkRmlsZXMpIHtcblx0XHRcdHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5zeXN0ZW1FeGNsdWRlZEZpbGVzID0gWy4uLlNZU1RFTV9FWENMVVNJT05TLmZpbGVzXTtcblx0XHR9XG5cdH1cblxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG5cdFx0YXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcblxuXHRcdC8vIFVwZGF0ZSBzZXJ2aWNlIHNldHRpbmdzXG5cdFx0dGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyPy51cGRhdGVTZXR0aW5ncyhcblx0XHRcdHRoaXMuc2V0dGluZ3MuZW5hYmxlTm90aWZpY2F0aW9ucyxcblx0XHRcdHRoaXMuc2V0dGluZ3MuZW5hYmxlUHJvZ3Jlc3NCYXJcblx0XHQpO1xuXHRcdHRoaXMuZXJyb3JIYW5kbGVyPy51cGRhdGVTZXR0aW5ncyh0aGlzLnNldHRpbmdzLmRlYnVnKTtcblxuXHRcdC8vIFJlaW5pdGlhbGl6ZSBzZXJ2aWNlcyBpZiBzZXR0aW5ncyBoYXZlIGNoYW5nZWRcblx0XHRpZiAoaXNWYXVsdEluaXRpYWxpemVkKHRoaXMuc2V0dGluZ3MpKSB7XG5cdFx0XHRhd2FpdCB0aGlzLmluaXRpYWxpemVTZXJ2aWNlcygpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgc3RhcnRQZXJpb2RpY1N5bmNDaGVja3MoKTogdm9pZCB7XG5cdFx0aWYgKHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwpIHtcblx0XHRcdGNsZWFySW50ZXJ2YWwodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcblx0XHRcdGF3YWl0IHRoaXMucGVyZm9ybVN5bmNDaGVjaygpO1xuXHRcdH0sIHRoaXMuc2V0dGluZ3Muc3luYy5jaGVja0ludGVydmFsKTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcGVyZm9ybVN5bmNDaGVjaygpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuc3luY01hbmFnZXIpIHJldHVybjtcblxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBzeW5jU3RhdHVzID0gYXdhaXQgdGhpcy5zeW5jTWFuYWdlci52YWxpZGF0ZVN5bmNTdGF0ZSgpO1xuXG5cdFx0XHRpZiAoIXN5bmNTdGF0dXMuaXNWYWxpZCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oYFN5bmMgY2hlY2sgZmFpbGVkOiAke3N5bmNTdGF0dXMuZXJyb3J9YCk7XG5cblx0XHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuZW5hYmxlTm90aWZpY2F0aW9ucykge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYFN5bmMgaXNzdWUgZGV0ZWN0ZWQ6ICR7c3luY1N0YXR1cy5lcnJvcn1gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgcmVjb3Zlcnlcblx0XHRcdFx0Y29uc3QgcmVjb3ZlcmVkID0gYXdhaXQgdGhpcy5zeW5jTWFuYWdlci5hdHRlbXB0UmVjb3ZlcnkoKTtcblx0XHRcdFx0aWYgKCFyZWNvdmVyZWQgJiYgdGhpcy5zZXR0aW5ncy5zeW5jLnJlcXVpcmVTeW5jKSB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5yZXN0YXJ0U2VydmljZXMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgbGFzdCBzeW5jIHRpbWVzdGFtcFxuXHRcdFx0YXdhaXQgdGhpcy5zeW5jTWFuYWdlci51cGRhdGVMYXN0U3luYygpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlcj8uaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ3BlcmZvcm1TeW5jQ2hlY2snLFxuXHRcdFx0XHRtZXRhZGF0YTogeyB0aW1lc3RhbXA6IERhdGUubm93KCkgfVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyByZXN0YXJ0U2VydmljZXMoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Ly8gU3RvcCBleGlzdGluZyBzZXJ2aWNlc1xuXHRcdHRoaXMucXVldWVTZXJ2aWNlPy5zdG9wKCk7XG5cblx0XHQvLyBDbGVhciBpbnRlcnZhbHNcblx0XHRpZiAodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCkge1xuXHRcdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLnN5bmNDaGVja0ludGVydmFsKTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gUmVpbml0aWFsaXplIGV2ZXJ5dGhpbmdcblx0XHRcdGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVN5bmNNYW5hZ2VyKCk7XG5cdFx0XHRhd2FpdCB0aGlzLnN0YXJ0U3luY1Byb2Nlc3MoKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlc3RhcnQgc2VydmljZXM6JywgZXJyb3IpO1xuXHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuZW5hYmxlTm90aWZpY2F0aW9ucykge1xuXHRcdFx0XHRuZXcgTm90aWNlKCdGYWlsZWQgdG8gcmVzdGFydCBzZXJ2aWNlcyBhZnRlciBzeW5jIGVycm9yJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBpbml0aWFsaXplVmF1bHRJZk5lZWRlZCgpIHtcblx0XHRpZiAodGhpcy5pc0luaXRpYWxpemluZykgcmV0dXJuO1xuXHRcdHRoaXMuaXNJbml0aWFsaXppbmcgPSB0cnVlO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGlmICghaXNWYXVsdEluaXRpYWxpemVkKHRoaXMuc2V0dGluZ3MpKSB7XG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MudmF1bHRJZCA9IGdlbmVyYXRlVmF1bHRJZCgpO1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmxhc3RLbm93blZhdWx0TmFtZSA9IHRoaXMuYXBwLnZhdWx0LmdldE5hbWUoKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTtcblxuXHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnVmF1bHQgaW5pdGlhbGl6ZWQgd2l0aCBuZXcgSUQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLmxhc3RLbm93blZhdWx0TmFtZSAhPT0gdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpKSB7XG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MubGFzdEtub3duVmF1bHROYW1lID0gdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0fVxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0aGlzLmlzSW5pdGlhbGl6aW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBpbml0aWFsaXplU2VydmljZXMoKSB7XG5cdFx0Y29uc29sZS5sb2coJ0luaXRpYWxpemluZyBzZXJ2aWNlcy4uLicsIHtcblx0XHRcdGhhc1ZhdWx0OiAhIXRoaXMuYXBwLnZhdWx0LFxuXHRcdFx0aGFzRXJyb3JIYW5kbGVyOiAhIXRoaXMuZXJyb3JIYW5kbGVyXG5cdFx0fSk7XG5cblx0XHRpZiAoIXRoaXMuZXJyb3JIYW5kbGVyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvcmUgc2VydmljZXMgbm90IGluaXRpYWxpemVkJyk7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIEluaXRpYWxpemUgRmlsZVRyYWNrZXJcblx0XHRcdHRoaXMuZmlsZVRyYWNrZXIgPSBuZXcgRmlsZVRyYWNrZXIodGhpcy5hcHAudmF1bHQsIHRoaXMuZXJyb3JIYW5kbGVyLCB0aGlzLnNldHRpbmdzLnN5bmMuc3luY0ZpbGVQYXRoKTtcblx0XHRcdGF3YWl0IHRoaXMuZmlsZVRyYWNrZXIuaW5pdGlhbGl6ZSgpO1xuXHRcdFx0Y29uc29sZS5sb2coJ0ZpbGVUcmFja2VyIGluaXRpYWxpemVkLicpO1xuXG5cdFx0XHQvLyBJbml0aWFsaXplIFN1cGFiYXNlIHNlcnZpY2Vcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuc3VwYWJhc2VTZXJ2aWNlID0gYXdhaXQgU3VwYWJhc2VTZXJ2aWNlLmdldEluc3RhbmNlKHRoaXMuc2V0dGluZ3MpO1xuXHRcdFx0XHRpZiAoIXRoaXMuc3VwYWJhc2VTZXJ2aWNlKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnU3VwYWJhc2Ugc2VydmljZSBub3QgaW5pdGlhbGl6ZWQuIFBsZWFzZSBjb25maWd1cmUgeW91ciBBUEkgc2V0dGluZ3MuJyk7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignU3VwYWJhc2Ugc2VydmljZSBpbml0aWFsaXphdGlvbiBmYWlsZWQ6IE1pc3NpbmcgY29uZmlndXJhdGlvbi4nKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc29sZS5sb2coJ1N1cGFiYXNlIHNlcnZpY2UgaW5pdGlhbGl6ZWQuJyk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBpbml0aWFsaXphdGlvbiBlcnJvcjonLCBlcnJvcik7XG5cdFx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byBpbml0aWFsaXplIFN1cGFiYXNlIHNlcnZpY2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbml0aWFsaXplIE9wZW5BSSBzZXJ2aWNlXG5cdFx0XHR0aGlzLm9wZW5BSVNlcnZpY2UgPSBuZXcgT3BlbkFJU2VydmljZSh0aGlzLnNldHRpbmdzLm9wZW5haSwgdGhpcy5lcnJvckhhbmRsZXIpO1xuXHRcdFx0Y29uc29sZS5sb2coJ09wZW5BSSBzZXJ2aWNlIGluaXRpYWxpemVkLicpO1xuXG5cdFx0XHRpZiAoIXRoaXMuYXBwLnZhdWx0KSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVmF1bHQgaXMgbm90IGF2YWlsYWJsZScpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbml0aWFsaXplIHF1ZXVlIHNlcnZpY2Vcblx0XHRcdGlmICh0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIgJiYgdGhpcy5zdXBhYmFzZVNlcnZpY2UgJiYgdGhpcy5vcGVuQUlTZXJ2aWNlKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dGhpcy5xdWV1ZVNlcnZpY2UgPSBuZXcgUXVldWVTZXJ2aWNlKFxuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5xdWV1ZS5tYXhDb25jdXJyZW50LFxuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5xdWV1ZS5yZXRyeUF0dGVtcHRzLFxuXHRcdFx0XHRcdFx0dGhpcy5zdXBhYmFzZVNlcnZpY2UsXG5cdFx0XHRcdFx0XHR0aGlzLm9wZW5BSVNlcnZpY2UsXG5cdFx0XHRcdFx0XHR0aGlzLmVycm9ySGFuZGxlcixcblx0XHRcdFx0XHRcdHRoaXMubm90aWZpY2F0aW9uTWFuYWdlcixcblx0XHRcdFx0XHRcdHRoaXMuYXBwLnZhdWx0LFxuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jaHVua2luZ1xuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBTdGFydCB0aGUgcXVldWUgc2VydmljZVxuXHRcdFx0XHRcdHRoaXMucXVldWVTZXJ2aWNlLnN0YXJ0KCk7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ1F1ZXVlIHNlcnZpY2UgaW5pdGlhbGl6ZWQgYW5kIHN0YXJ0ZWQuJyk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgUXVldWVTZXJ2aWNlOicsIGVycm9yKTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBxdWV1ZSBzZXJ2aWNlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgc2VydmljZXMgbm90IGF2YWlsYWJsZSBmb3IgUXVldWVTZXJ2aWNlIGluaXRpYWxpemF0aW9uJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWV0YWRhdGFFeHRyYWN0b3IgPSBuZXcgTWV0YWRhdGFFeHRyYWN0b3IoKTtcblx0XHRcdGNvbnNvbGUubG9nKCdNZXRhZGF0YUV4dHJhY3RvciBpbml0aWFsaXplZC4nKTtcblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBJbml0aWFsU3luY01hbmFnZXIgd2l0aCBwcm9wZXIgcGFyYW1ldGVyc1xuXHRcdFx0aWYgKHRoaXMucXVldWVTZXJ2aWNlICYmIHRoaXMuc3luY01hbmFnZXIgJiYgdGhpcy5tZXRhZGF0YUV4dHJhY3Rvcikge1xuXHRcdFx0XHQvLyBQYXNzIHRoZSBjb21iaW5lZCBleGNsdXNpb24gc2V0dGluZ3MgdG8gSW5pdGlhbFN5bmNNYW5hZ2VyXG5cdFx0XHRcdGNvbnN0IGluaXRpYWxTeW5jT3B0aW9ucyA9IHtcblx0XHRcdFx0XHQuLi50aGlzLnNldHRpbmdzLmluaXRpYWxTeW5jLFxuXHRcdFx0XHRcdHN5bmNGaWxlUGF0aDogdGhpcy5zZXR0aW5ncy5zeW5jLnN5bmNGaWxlUGF0aCxcblx0XHRcdFx0XHRleGNsdXNpb25zOiBnZXRBbGxFeGNsdXNpb25zKHRoaXMuc2V0dGluZ3MpXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy5pbml0aWFsU3luY01hbmFnZXIgPSBuZXcgSW5pdGlhbFN5bmNNYW5hZ2VyKFxuXHRcdFx0XHRcdHRoaXMuYXBwLnZhdWx0LFxuXHRcdFx0XHRcdHRoaXMucXVldWVTZXJ2aWNlLFxuXHRcdFx0XHRcdHRoaXMuc3luY01hbmFnZXIsXG5cdFx0XHRcdFx0dGhpcy5tZXRhZGF0YUV4dHJhY3Rvcixcblx0XHRcdFx0XHR0aGlzLmVycm9ySGFuZGxlcixcblx0XHRcdFx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIsXG5cdFx0XHRcdFx0dGhpcy5zdXBhYmFzZVNlcnZpY2UsXG5cdFx0XHRcdFx0aW5pdGlhbFN5bmNPcHRpb25zXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdJbml0aWFsU3luY01hbmFnZXIgaW5pdGlhbGl6ZWQuJyk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIHNlcnZpY2VzOicsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgY2hlY2tSZXF1aXJlZENvbmZpZ3VyYXRpb25zKCk6IHZvaWQge1xuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5vcGVuYWkuYXBpS2V5KSB7XG5cdFx0XHRuZXcgTm90aWNlKCdPcGVuQUkgQVBJIGtleSBpcyBtaXNzaW5nLiBBSSBmZWF0dXJlcyBhcmUgZGlzYWJsZWQuIENvbmZpZ3VyZSBpdCBpbiB0aGUgc2V0dGluZ3MuJyk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLnN1cGFiYXNlLnVybCB8fCAhdGhpcy5zZXR0aW5ncy5zdXBhYmFzZS5hcGlLZXkpIHtcblx0XHRcdG5ldyBOb3RpY2UoJ1N1cGFiYXNlIGNvbmZpZ3VyYXRpb24gaXMgaW5jb21wbGV0ZS4gRGF0YWJhc2UgZmVhdHVyZXMgYXJlIGRpc2FibGVkLiBDb25maWd1cmUgaXQgaW4gdGhlIHNldHRpbmdzLicpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgcmVnaXN0ZXJFdmVudEhhbmRsZXJzKCkge1xuXHRcdHRoaXMucmVnaXN0ZXJFdmVudChcblx0XHRcdHRoaXMuYXBwLnZhdWx0Lm9uKCdjcmVhdGUnLCBhc3luYyAoZmlsZSkgPT4ge1xuXHRcdFx0XHRpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSByZXR1cm47XG5cblx0XHRcdFx0aWYgKCFhd2FpdCB0aGlzLmVuc3VyZVN5bmNGaWxlRXhpc3RzKCkpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKCdGYWlsZWQgdG8gY3JlYXRlIHN5bmMgZmlsZS4gUGx1Z2luIGZ1bmN0aW9uYWxpdHkgbGltaXRlZC4nKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIXRoaXMuc2hvdWxkUHJvY2Vzc0ZpbGUoZmlsZSkpIHJldHVybjtcblxuXHRcdFx0XHRhd2FpdCB0aGlzLmZpbGVUcmFja2VyPy5oYW5kbGVDcmVhdGUoZmlsZSk7XG5cdFx0XHRcdGF3YWl0IHRoaXMucXVldWVGaWxlUHJvY2Vzc2luZyhmaWxlLCAnQ1JFQVRFJyk7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQoXG5cdFx0XHR0aGlzLmFwcC52YXVsdC5vbignbW9kaWZ5JywgYXN5bmMgKGZpbGUpID0+IHtcblx0XHRcdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkgcmV0dXJuO1xuXG5cdFx0XHRcdGlmICghYXdhaXQgdGhpcy5lbnN1cmVTeW5jRmlsZUV4aXN0cygpKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnRmFpbGVkIHRvIGNyZWF0ZSBzeW5jIGZpbGUuIFBsdWdpbiBmdW5jdGlvbmFsaXR5IGxpbWl0ZWQuJyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCF0aGlzLnNob3VsZFByb2Nlc3NGaWxlKGZpbGUpKSByZXR1cm47XG5cblx0XHRcdFx0YXdhaXQgdGhpcy5maWxlVHJhY2tlcj8uaGFuZGxlTW9kaWZ5KGZpbGUpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnF1ZXVlRmlsZVByb2Nlc3NpbmcoZmlsZSwgJ1VQREFURScpO1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50KFxuXHRcdFx0dGhpcy5hcHAudmF1bHQub24oJ2RlbGV0ZScsIGFzeW5jIChmaWxlKSA9PiB7XG5cdFx0XHRcdGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHJldHVybjtcblxuXHRcdFx0XHRpZiAoZmlsZS5wYXRoID09PSB0aGlzLnNldHRpbmdzLnN5bmMuc3luY0ZpbGVQYXRoKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ1N5bmMgZmlsZSB3YXMgZGVsZXRlZCwgd2lsbCByZWNyZWF0ZSBvbiBuZXh0IG9wZXJhdGlvbicpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghYXdhaXQgdGhpcy5lbnN1cmVTeW5jRmlsZUV4aXN0cygpKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnRmFpbGVkIHRvIGNyZWF0ZSBzeW5jIGZpbGUuIFBsdWdpbiBmdW5jdGlvbmFsaXR5IGxpbWl0ZWQuJyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCF0aGlzLnNob3VsZFByb2Nlc3NGaWxlKGZpbGUpKSByZXR1cm47XG5cblx0XHRcdFx0YXdhaXQgdGhpcy5maWxlVHJhY2tlcj8uaGFuZGxlRGVsZXRlKGZpbGUpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnF1ZXVlRmlsZVByb2Nlc3NpbmcoZmlsZSwgJ0RFTEVURScpO1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50KFxuXHRcdFx0dGhpcy5hcHAudmF1bHQub24oJ3JlbmFtZScsIGFzeW5jIChmaWxlLCBvbGRQYXRoKSA9PiB7XG5cdFx0XHRcdGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHJldHVybjtcblxuXHRcdFx0XHRpZiAoIWF3YWl0IHRoaXMuZW5zdXJlU3luY0ZpbGVFeGlzdHMoKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0ZhaWxlZCB0byBjcmVhdGUgc3luYyBmaWxlLiBQbHVnaW4gZnVuY3Rpb25hbGl0eSBsaW1pdGVkLicpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghdGhpcy5zaG91bGRQcm9jZXNzRmlsZShmaWxlKSkgcmV0dXJuO1xuXG5cdFx0XHRcdGF3YWl0IHRoaXMuZmlsZVRyYWNrZXI/LmhhbmRsZVJlbmFtZShmaWxlLCBvbGRQYXRoKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5oYW5kbGVGaWxlUmVuYW1lKGZpbGUsIG9sZFBhdGgpO1xuXHRcdFx0fSlcblx0XHQpO1xuXHR9XG5cblx0cHJpdmF0ZSBzaG91bGRQcm9jZXNzRmlsZShmaWxlOiBURmlsZSk6IGJvb2xlYW4ge1xuXHRcdGlmICghdGhpcy5xdWV1ZVNlcnZpY2UgfHwgIWlzVmF1bHRJbml0aWFsaXplZCh0aGlzLnNldHRpbmdzKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5lbmFibGVBdXRvU3luYykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIEdldCBjb21iaW5lZCBleGNsdXNpb25zIChzeXN0ZW0gKyB1c2VyKVxuXHRcdGNvbnN0IGFsbEV4Y2x1c2lvbnMgPSBnZXRBbGxFeGNsdXNpb25zKHRoaXMuc2V0dGluZ3MpO1xuXG5cdFx0Y29uc3QgZmlsZVBhdGggPSBmaWxlLnBhdGg7XG5cdFx0Y29uc3QgZmlsZU5hbWUgPSBmaWxlLm5hbWU7XG5cblx0XHQvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSBzeW5jIGZpbGUgZGlyZWN0bHlcblx0XHRpZiAoZmlsZVBhdGggPT09IHRoaXMuc2V0dGluZ3Muc3luYy5zeW5jRmlsZVBhdGggfHxcblx0XHRcdGZpbGVQYXRoID09PSB0aGlzLnNldHRpbmdzLnN5bmMuc3luY0ZpbGVQYXRoICsgJy5iYWNrdXAnKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhgRXhwbGljaXRseSBza2lwcGluZyBzeW5jIGZpbGU6ICR7ZmlsZVBhdGh9YCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZXhjbHVkZWQgZmlsZXNcblx0XHRpZiAoQXJyYXkuaXNBcnJheShhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMpICYmXG5cdFx0XHRhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMuaW5jbHVkZXMoZmlsZU5hbWUpKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnU2tpcHBpbmcgZXhjbHVkZWQgZmlsZTonLCBmaWxlTmFtZSk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZXhjbHVkZWQgZm9sZGVyc1xuXHRcdGlmIChBcnJheS5pc0FycmF5KGFsbEV4Y2x1c2lvbnMuZXhjbHVkZWRGb2xkZXJzKSkge1xuXHRcdFx0Y29uc3QgaXNFeGNsdWRlZEZvbGRlciA9IGFsbEV4Y2x1c2lvbnMuZXhjbHVkZWRGb2xkZXJzLnNvbWUoZm9sZGVyID0+IHtcblx0XHRcdFx0Y29uc3Qgbm9ybWFsaXplZEZvbGRlciA9IGZvbGRlci5lbmRzV2l0aCgnLycpID8gZm9sZGVyIDogZm9sZGVyICsgJy8nO1xuXHRcdFx0XHRyZXR1cm4gZmlsZVBhdGguc3RhcnRzV2l0aChub3JtYWxpemVkRm9sZGVyKTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKGlzRXhjbHVkZWRGb2xkZXIpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ1NraXBwaW5nIGZpbGUgaW4gZXhjbHVkZWQgZm9sZGVyOicsIGZpbGVQYXRoKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENoZWNrIGV4Y2x1ZGVkIGZpbGUgdHlwZXNcblx0XHRpZiAoQXJyYXkuaXNBcnJheShhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVR5cGVzKSkge1xuXHRcdFx0Y29uc3QgaXNFeGNsdWRlZFR5cGUgPSBhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVR5cGVzLnNvbWUoXG5cdFx0XHRcdGV4dCA9PiBmaWxlUGF0aC50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dC50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0KTtcblx0XHRcdGlmIChpc0V4Y2x1ZGVkVHlwZSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnU2tpcHBpbmcgZXhjbHVkZWQgZmlsZSB0eXBlOicsIGZpbGVQYXRoKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENoZWNrIGV4Y2x1ZGVkIGZpbGUgcHJlZml4ZXNcblx0XHRpZiAoQXJyYXkuaXNBcnJheShhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVByZWZpeGVzKSkge1xuXHRcdFx0Y29uc3QgaXNFeGNsdWRlZFByZWZpeCA9IGFsbEV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlUHJlZml4ZXMuc29tZShcblx0XHRcdFx0cHJlZml4ID0+IGZpbGVOYW1lLnN0YXJ0c1dpdGgocHJlZml4KVxuXHRcdFx0KTtcblx0XHRcdGlmIChpc0V4Y2x1ZGVkUHJlZml4KSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdTa2lwcGluZyBmaWxlIHdpdGggZXhjbHVkZWQgcHJlZml4OicsIGZpbGVOYW1lKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBlbnN1cmVTeW5jRmlsZUV4aXN0cygpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRpZiAoIXRoaXMuc3luY01hbmFnZXIpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1N5bmMgbWFuYWdlciBub3QgaW5pdGlhbGl6ZWQnKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3Qgc3luY0ZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5zZXR0aW5ncy5zeW5jLnN5bmNGaWxlUGF0aCk7XG5cdFx0XHRpZiAoIXN5bmNGaWxlKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdTeW5jIGZpbGUgbWlzc2luZywgcmVjcmVhdGluZy4uLicpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLmluaXRpYWxpemUoKTtcblx0XHRcdFx0bmV3IE5vdGljZSgnUmVjcmVhdGVkIHN5bmMgZmlsZScpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBlbnN1cmluZyBzeW5jIGZpbGUgZXhpc3RzOicsIGVycm9yKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIHF1ZXVlRmlsZVByb2Nlc3NpbmcoZmlsZTogVEZpbGUsIHR5cGU6ICdDUkVBVEUnIHwgJ1VQREFURScgfCAnREVMRVRFJykge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXRoaXMucXVldWVTZXJ2aWNlIHx8ICF0aGlzLmZpbGVUcmFja2VyKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1JlcXVpcmVkIHNlcnZpY2VzIG5vdCBpbml0aWFsaXplZDonLCB7XG5cdFx0XHRcdFx0cXVldWVTZXJ2aWNlOiAhIXRoaXMucXVldWVTZXJ2aWNlLFxuXHRcdFx0XHRcdGZpbGVUcmFja2VyOiAhIXRoaXMuZmlsZVRyYWNrZXJcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc29sZS5sb2coJ1N0YXJ0aW5nIGZpbGUgcHJvY2Vzc2luZzonLCB7XG5cdFx0XHRcdGZpbGVOYW1lOiBmaWxlLm5hbWUsXG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdHBhdGg6IGZpbGUucGF0aFxuXHRcdFx0fSk7XG5cblx0XHRcdGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5maWxlVHJhY2tlci5jcmVhdGVGaWxlTWV0YWRhdGEoZmlsZSk7XG5cdFx0XHRjb25zb2xlLmxvZygnQ3JlYXRlZCBtZXRhZGF0YTonLCBtZXRhZGF0YSk7XG5cblx0XHRcdGNvbnN0IHRhc2sgPSB7XG5cdFx0XHRcdGlkOiBmaWxlLnBhdGgsXG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdHByaW9yaXR5OiB0eXBlID09PSAnREVMRVRFJyA/IDIgOiAxLFxuXHRcdFx0XHRtYXhSZXRyaWVzOiB0aGlzLnNldHRpbmdzLnF1ZXVlLnJldHJ5QXR0ZW1wdHMsXG5cdFx0XHRcdHJldHJ5Q291bnQ6IDAsXG5cdFx0XHRcdGNyZWF0ZWRBdDogRGF0ZS5ub3coKSxcblx0XHRcdFx0dXBkYXRlZEF0OiBEYXRlLm5vdygpLFxuXHRcdFx0XHRzdGF0dXM6ICdQRU5ESU5HJyxcblx0XHRcdFx0bWV0YWRhdGEsXG5cdFx0XHRcdGRhdGE6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zb2xlLmxvZygnQ3JlYXRlZCB0YXNrOicsIHRhc2spO1xuXHRcdFx0YXdhaXQgdGhpcy5xdWV1ZVNlcnZpY2UuYWRkVGFzayh0YXNrKTtcblx0XHRcdGNvbnNvbGUubG9nKCdUYXNrIGFkZGVkIHRvIHF1ZXVlJyk7XG5cblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMpIHtcblx0XHRcdFx0Y29uc3QgYWN0aW9uID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRuZXcgTm90aWNlKGBRdWV1ZWQgJHthY3Rpb259IGZvciBwcm9jZXNzaW5nOiAke2ZpbGUubmFtZX1gKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgaW4gcXVldWVGaWxlUHJvY2Vzc2luZzonLCBlcnJvcik7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlcj8uaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ3F1ZXVlRmlsZVByb2Nlc3NpbmcnLFxuXHRcdFx0XHRtZXRhZGF0YTogeyBmaWxlUGF0aDogZmlsZS5wYXRoLCB0eXBlIH1cblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byBxdWV1ZSAke2ZpbGUubmFtZX0gZm9yIHByb2Nlc3NpbmdgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGhhbmRsZUZpbGVSZW5hbWUoZmlsZTogVEZpbGUsIG9sZFBhdGg6IHN0cmluZykge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXRoaXMuc3VwYWJhc2VTZXJ2aWNlKSByZXR1cm47XG5cblx0XHRcdGNvbnN0IGNodW5rcyA9IGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLmdldERvY3VtZW50Q2h1bmtzKG9sZFBhdGgpO1xuXHRcdFx0aWYgKGNodW5rcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWRDaHVua3MgPSBjaHVua3MubWFwKGNodW5rID0+ICh7XG5cdFx0XHRcdFx0Li4uY2h1bmssXG5cdFx0XHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0XHRcdC4uLmNodW5rLm1ldGFkYXRhLFxuXHRcdFx0XHRcdFx0b2JzaWRpYW5JZDogZmlsZS5wYXRoLFxuXHRcdFx0XHRcdFx0cGF0aDogZmlsZS5wYXRoXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSk7XG5cblx0XHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UuZGVsZXRlRG9jdW1lbnRDaHVua3Mob2xkUGF0aCk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLnVwc2VydENodW5rcyh1cGRhdGVkQ2h1bmtzKTtcblxuXHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgVXBkYXRlZCBkYXRhYmFzZSBlbnRyaWVzIGZvciByZW5hbWVkIGZpbGU6ICR7ZmlsZS5uYW1lfWApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyPy5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0XHRjb250ZXh0OiAnaGFuZGxlRmlsZVJlbmFtZScsXG5cdFx0XHRcdG1ldGFkYXRhOiB7IGZpbGVQYXRoOiBmaWxlLnBhdGgsIG9sZFBhdGggfVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMpIHtcblx0XHRcdFx0bmV3IE5vdGljZShgRmFpbGVkIHRvIHVwZGF0ZSBkYXRhYmFzZSBmb3IgcmVuYW1lZCBmaWxlOiAke2ZpbGUubmFtZX1gKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFkZENvbW1hbmRzKCkge1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ2ZvcmNlLXN5bmMtY3VycmVudC1maWxlJyxcblx0XHRcdG5hbWU6ICdGb3JjZSBzeW5jIGN1cnJlbnQgZmlsZScsXG5cdFx0XHRjaGVja0NhbGxiYWNrOiAoY2hlY2tpbmc6IGJvb2xlYW4pID0+IHtcblx0XHRcdFx0Y29uc3QgZmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG5cdFx0XHRcdGlmIChmaWxlKSB7XG5cdFx0XHRcdFx0aWYgKCFjaGVja2luZykge1xuXHRcdFx0XHRcdFx0dGhpcy5xdWV1ZUZpbGVQcm9jZXNzaW5nKGZpbGUsICdVUERBVEUnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAnZm9yY2Utc3luYy1hbGwtZmlsZXMnLFxuXHRcdFx0bmFtZTogJ0ZvcmNlIHN5bmMgYWxsIGZpbGVzJyxcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuXHRcdFx0XHRmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5zaG91bGRQcm9jZXNzRmlsZShmaWxlKSkge1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5xdWV1ZUZpbGVQcm9jZXNzaW5nKGZpbGUsICdVUERBVEUnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ2NsZWFyLXN5bmMtcXVldWUnLFxuXHRcdFx0bmFtZTogJ0NsZWFyIHN5bmMgcXVldWUnLFxuXHRcdFx0Y2FsbGJhY2s6ICgpID0+IHtcblx0XHRcdFx0dGhpcy5xdWV1ZVNlcnZpY2U/LmNsZWFyKCk7XG5cdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKCdTeW5jIHF1ZXVlIGNsZWFyZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAncmVzZXQtZmlsZS10cmFja2VyJyxcblx0XHRcdG5hbWU6ICdSZXNldCBmaWxlIHRyYWNrZXIgY2FjaGUnLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0dGhpcy5maWxlVHJhY2tlcj8uY2xlYXJRdWV1ZSgpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLmZpbGVUcmFja2VyPy5pbml0aWFsaXplKCk7XG5cdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKCdGaWxlIHRyYWNrZXIgY2FjaGUgcmVzZXQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAnc3RhcnQtaW5pdGlhbC1zeW5jJyxcblx0XHRcdG5hbWU6ICdTdGFydCBpbml0aWFsIHZhdWx0IHN5bmMnLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0aWYgKHRoaXMuaW5pdGlhbFN5bmNNYW5hZ2VyKSB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5pbml0aWFsU3luY01hbmFnZXIuc3RhcnRTeW5jKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnSW5pdGlhbCBzeW5jIG1hbmFnZXIgbm90IGluaXRpYWxpemVkJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ3N0b3AtaW5pdGlhbC1zeW5jJyxcblx0XHRcdG5hbWU6ICdTdG9wIGluaXRpYWwgdmF1bHQgc3luYycsXG5cdFx0XHRjYWxsYmFjazogKCkgPT4ge1xuXHRcdFx0XHR0aGlzLmluaXRpYWxTeW5jTWFuYWdlcj8uc3RvcCgpO1xuXHRcdFx0XHRuZXcgTm90aWNlKCdJbml0aWFsIHN5bmMgc3RvcHBlZCcpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgRmV0Y2ggfSBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgY29uc3QgcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoPzogRmV0Y2gpOiBGZXRjaCA9PiB7XG4gIGxldCBfZmV0Y2g6IEZldGNoXG4gIGlmIChjdXN0b21GZXRjaCkge1xuICAgIF9mZXRjaCA9IGN1c3RvbUZldGNoXG4gIH0gZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgIF9mZXRjaCA9ICguLi5hcmdzKSA9PlxuICAgICAgaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcgYXMgYW55KS50aGVuKCh7IGRlZmF1bHQ6IGZldGNoIH0pID0+IGZldGNoKC4uLmFyZ3MpKVxuICB9IGVsc2Uge1xuICAgIF9mZXRjaCA9IGZldGNoXG4gIH1cbiAgcmV0dXJuICguLi5hcmdzKSA9PiBfZmV0Y2goLi4uYXJncylcbn1cbiIsICJleHBvcnQgdHlwZSBGZXRjaCA9IHR5cGVvZiBmZXRjaFxuXG4vKipcbiAqIFJlc3BvbnNlIGZvcm1hdFxuICpcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbnNSZXNwb25zZVN1Y2Nlc3M8VD4ge1xuICBkYXRhOiBUXG4gIGVycm9yOiBudWxsXG59XG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uc1Jlc3BvbnNlRmFpbHVyZSB7XG4gIGRhdGE6IG51bGxcbiAgZXJyb3I6IGFueVxufVxuZXhwb3J0IHR5cGUgRnVuY3Rpb25zUmVzcG9uc2U8VD4gPSBGdW5jdGlvbnNSZXNwb25zZVN1Y2Nlc3M8VD4gfCBGdW5jdGlvbnNSZXNwb25zZUZhaWx1cmVcblxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb250ZXh0OiBhbnlcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBuYW1lID0gJ0Z1bmN0aW9uc0Vycm9yJywgY29udGV4dD86IGFueSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zRmV0Y2hFcnJvciBleHRlbmRzIEZ1bmN0aW9uc0Vycm9yIHtcbiAgY29uc3RydWN0b3IoY29udGV4dDogYW55KSB7XG4gICAgc3VwZXIoJ0ZhaWxlZCB0byBzZW5kIGEgcmVxdWVzdCB0byB0aGUgRWRnZSBGdW5jdGlvbicsICdGdW5jdGlvbnNGZXRjaEVycm9yJywgY29udGV4dClcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zUmVsYXlFcnJvciBleHRlbmRzIEZ1bmN0aW9uc0Vycm9yIHtcbiAgY29uc3RydWN0b3IoY29udGV4dDogYW55KSB7XG4gICAgc3VwZXIoJ1JlbGF5IEVycm9yIGludm9raW5nIHRoZSBFZGdlIEZ1bmN0aW9uJywgJ0Z1bmN0aW9uc1JlbGF5RXJyb3InLCBjb250ZXh0KVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNIdHRwRXJyb3IgZXh0ZW5kcyBGdW5jdGlvbnNFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IGFueSkge1xuICAgIHN1cGVyKCdFZGdlIEZ1bmN0aW9uIHJldHVybmVkIGEgbm9uLTJ4eCBzdGF0dXMgY29kZScsICdGdW5jdGlvbnNIdHRwRXJyb3InLCBjb250ZXh0KVxuICB9XG59XG4vLyBEZWZpbmUgdGhlIGVudW0gZm9yIHRoZSAncmVnaW9uJyBwcm9wZXJ0eVxuZXhwb3J0IGVudW0gRnVuY3Rpb25SZWdpb24ge1xuICBBbnkgPSAnYW55JyxcbiAgQXBOb3J0aGVhc3QxID0gJ2FwLW5vcnRoZWFzdC0xJyxcbiAgQXBOb3J0aGVhc3QyID0gJ2FwLW5vcnRoZWFzdC0yJyxcbiAgQXBTb3V0aDEgPSAnYXAtc291dGgtMScsXG4gIEFwU291dGhlYXN0MSA9ICdhcC1zb3V0aGVhc3QtMScsXG4gIEFwU291dGhlYXN0MiA9ICdhcC1zb3V0aGVhc3QtMicsXG4gIENhQ2VudHJhbDEgPSAnY2EtY2VudHJhbC0xJyxcbiAgRXVDZW50cmFsMSA9ICdldS1jZW50cmFsLTEnLFxuICBFdVdlc3QxID0gJ2V1LXdlc3QtMScsXG4gIEV1V2VzdDIgPSAnZXUtd2VzdC0yJyxcbiAgRXVXZXN0MyA9ICdldS13ZXN0LTMnLFxuICBTYUVhc3QxID0gJ3NhLWVhc3QtMScsXG4gIFVzRWFzdDEgPSAndXMtZWFzdC0xJyxcbiAgVXNXZXN0MSA9ICd1cy13ZXN0LTEnLFxuICBVc1dlc3QyID0gJ3VzLXdlc3QtMicsXG59XG5cbmV4cG9ydCB0eXBlIEZ1bmN0aW9uSW52b2tlT3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIE9iamVjdCByZXByZXNlbnRpbmcgdGhlIGhlYWRlcnMgdG8gc2VuZCB3aXRoIHRoZSByZXF1ZXN0LlxuICAgKiAqL1xuICBoZWFkZXJzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxuICAvKipcbiAgICogVGhlIEhUVFAgdmVyYiBvZiB0aGUgcmVxdWVzdFxuICAgKi9cbiAgbWV0aG9kPzogJ1BPU1QnIHwgJ0dFVCcgfCAnUFVUJyB8ICdQQVRDSCcgfCAnREVMRVRFJ1xuICAvKipcbiAgICogVGhlIFJlZ2lvbiB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIGluLlxuICAgKi9cbiAgcmVnaW9uPzogRnVuY3Rpb25SZWdpb25cbiAgLyoqXG4gICAqIFRoZSBib2R5IG9mIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgYm9keT86XG4gICAgfCBGaWxlXG4gICAgfCBCbG9iXG4gICAgfCBBcnJheUJ1ZmZlclxuICAgIHwgRm9ybURhdGFcbiAgICB8IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+XG4gICAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgfCBzdHJpbmdcbn1cbiIsICJpbXBvcnQgeyByZXNvbHZlRmV0Y2ggfSBmcm9tICcuL2hlbHBlcidcbmltcG9ydCB7XG4gIEZldGNoLFxuICBGdW5jdGlvbnNGZXRjaEVycm9yLFxuICBGdW5jdGlvbnNIdHRwRXJyb3IsXG4gIEZ1bmN0aW9uc1JlbGF5RXJyb3IsXG4gIEZ1bmN0aW9uc1Jlc3BvbnNlLFxuICBGdW5jdGlvbkludm9rZU9wdGlvbnMsXG4gIEZ1bmN0aW9uUmVnaW9uLFxufSBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zQ2xpZW50IHtcbiAgcHJvdGVjdGVkIHVybDogc3RyaW5nXG4gIHByb3RlY3RlZCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIHByb3RlY3RlZCByZWdpb246IEZ1bmN0aW9uUmVnaW9uXG4gIHByb3RlY3RlZCBmZXRjaDogRmV0Y2hcblxuICBjb25zdHJ1Y3RvcihcbiAgICB1cmw6IHN0cmluZyxcbiAgICB7XG4gICAgICBoZWFkZXJzID0ge30sXG4gICAgICBjdXN0b21GZXRjaCxcbiAgICAgIHJlZ2lvbiA9IEZ1bmN0aW9uUmVnaW9uLkFueSxcbiAgICB9OiB7XG4gICAgICBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgICAgY3VzdG9tRmV0Y2g/OiBGZXRjaFxuICAgICAgcmVnaW9uPzogRnVuY3Rpb25SZWdpb25cbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gICAgdGhpcy5yZWdpb24gPSByZWdpb25cbiAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGN1c3RvbUZldGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAqIEBwYXJhbSB0b2tlbiAtIHRoZSBuZXcgand0IHRva2VuIHNlbnQgaW4gdGhlIGF1dGhvcmlzYXRpb24gaGVhZGVyXG4gICAqL1xuICBzZXRBdXRoKHRva2VuOiBzdHJpbmcpIHtcbiAgICB0aGlzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0b2tlbn1gXG4gIH1cblxuICAvKipcbiAgICogSW52b2tlcyBhIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSBmdW5jdGlvbk5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgRnVuY3Rpb24gdG8gaW52b2tlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGludm9raW5nIHRoZSBGdW5jdGlvbi5cbiAgICovXG4gIGFzeW5jIGludm9rZTxUID0gYW55PihcbiAgICBmdW5jdGlvbk5hbWU6IHN0cmluZyxcbiAgICBvcHRpb25zOiBGdW5jdGlvbkludm9rZU9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPEZ1bmN0aW9uc1Jlc3BvbnNlPFQ+PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgaGVhZGVycywgbWV0aG9kLCBib2R5OiBmdW5jdGlvbkFyZ3MgfSA9IG9wdGlvbnNcbiAgICAgIGxldCBfaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9XG4gICAgICBsZXQgeyByZWdpb24gfSA9IG9wdGlvbnNcbiAgICAgIGlmICghcmVnaW9uKSB7XG4gICAgICAgIHJlZ2lvbiA9IHRoaXMucmVnaW9uXG4gICAgICB9XG4gICAgICBpZiAocmVnaW9uICYmIHJlZ2lvbiAhPT0gJ2FueScpIHtcbiAgICAgICAgX2hlYWRlcnNbJ3gtcmVnaW9uJ10gPSByZWdpb25cbiAgICAgIH1cbiAgICAgIGxldCBib2R5OiBhbnlcbiAgICAgIGlmIChcbiAgICAgICAgZnVuY3Rpb25BcmdzICYmXG4gICAgICAgICgoaGVhZGVycyAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKSkgfHwgIWhlYWRlcnMpXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgZnVuY3Rpb25BcmdzIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgICBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclxuICAgICAgICApIHtcbiAgICAgICAgICAvLyB3aWxsIHdvcmsgZm9yIEZpbGUgYXMgRmlsZSBpbmhlcml0cyBCbG9iXG4gICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgQXJyYXlCdWZmZXIgYXMgaXQgaXMgdGhlIHNhbWUgdW5kZXJseWluZyBzdHJ1Y3R1cmUgYXMgYSBCbG9iXG4gICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSdcbiAgICAgICAgICBib2R5ID0gZnVuY3Rpb25BcmdzXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uQXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBwbGFpbiBzdHJpbmdcbiAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAndGV4dC9wbGFpbidcbiAgICAgICAgICBib2R5ID0gZnVuY3Rpb25BcmdzXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICAgIC8vIGRvbid0IHNldCBjb250ZW50LXR5cGUgaGVhZGVyc1xuICAgICAgICAgIC8vIFJlcXVlc3Qgd2lsbCBhdXRvbWF0aWNhbGx5IGFkZCB0aGUgcmlnaHQgYm91bmRhcnkgdmFsdWVcbiAgICAgICAgICBib2R5ID0gZnVuY3Rpb25BcmdzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVmYXVsdCwgYXNzdW1lIHRoaXMgaXMgSlNPTlxuICAgICAgICAgIF9oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShmdW5jdGlvbkFyZ3MpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKGAke3RoaXMudXJsfS8ke2Z1bmN0aW9uTmFtZX1gLCB7XG4gICAgICAgIG1ldGhvZDogbWV0aG9kIHx8ICdQT1NUJyxcbiAgICAgICAgLy8gaGVhZGVycyBwcmlvcml0eSBpcyAoaGlnaCB0byBsb3cpOlxuICAgICAgICAvLyAxLiBpbnZva2UtbGV2ZWwgaGVhZGVyc1xuICAgICAgICAvLyAyLiBjbGllbnQtbGV2ZWwgaGVhZGVyc1xuICAgICAgICAvLyAzLiBkZWZhdWx0IENvbnRlbnQtVHlwZSBoZWFkZXJcbiAgICAgICAgaGVhZGVyczogeyAuLi5faGVhZGVycywgLi4udGhpcy5oZWFkZXJzLCAuLi5oZWFkZXJzIH0sXG4gICAgICAgIGJvZHksXG4gICAgICB9KS5jYXRjaCgoZmV0Y2hFcnJvcikgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRnVuY3Rpb25zRmV0Y2hFcnJvcihmZXRjaEVycm9yKVxuICAgICAgfSlcblxuICAgICAgY29uc3QgaXNSZWxheUVycm9yID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtcmVsYXktZXJyb3InKVxuICAgICAgaWYgKGlzUmVsYXlFcnJvciAmJiBpc1JlbGF5RXJyb3IgPT09ICd0cnVlJykge1xuICAgICAgICB0aHJvdyBuZXcgRnVuY3Rpb25zUmVsYXlFcnJvcihyZXNwb25zZSlcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRnVuY3Rpb25zSHR0cEVycm9yKHJlc3BvbnNlKVxuICAgICAgfVxuXG4gICAgICBsZXQgcmVzcG9uc2VUeXBlID0gKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSA/PyAndGV4dC9wbGFpbicpLnNwbGl0KCc7JylbMF0udHJpbSgpXG4gICAgICBsZXQgZGF0YTogYW55XG4gICAgICBpZiAocmVzcG9uc2VUeXBlID09PSAnYXBwbGljYXRpb24vanNvbicpIHtcbiAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5ibG9iKClcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAndGV4dC9ldmVudC1zdHJlYW0nKSB7XG4gICAgICAgIGRhdGEgPSByZXNwb25zZVxuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICdtdWx0aXBhcnQvZm9ybS1kYXRhJykge1xuICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuZm9ybURhdGEoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCB0byB0ZXh0XG4gICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IGluZGV4IGZyb20gJy4uL2Nqcy9pbmRleC5qcydcbmNvbnN0IHtcbiAgUG9zdGdyZXN0Q2xpZW50LFxuICBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIsXG4gIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsXG4gIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIsXG4gIFBvc3RncmVzdEJ1aWxkZXIsXG4gIFBvc3RncmVzdEVycm9yLFxufSA9IGluZGV4XG5cbmV4cG9ydCB7XG4gIFBvc3RncmVzdEJ1aWxkZXIsXG4gIFBvc3RncmVzdENsaWVudCxcbiAgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcbiAgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxuICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLFxuICBQb3N0Z3Jlc3RFcnJvcixcbn1cblxuLy8gY29tcGF0aWJpbGl0eSB3aXRoIENKUyBvdXRwdXRcbmV4cG9ydCBkZWZhdWx0IHtcbiAgUG9zdGdyZXN0Q2xpZW50LFxuICBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIsXG4gIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsXG4gIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIsXG4gIFBvc3RncmVzdEJ1aWxkZXIsXG4gIFBvc3RncmVzdEVycm9yLFxufVxuIiwgImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuMTEuMidcbiIsICJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJ1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGByZWFsdGltZS1qcy8ke3ZlcnNpb259YCB9XG5cbmV4cG9ydCBjb25zdCBWU046IHN0cmluZyA9ICcxLjAuMCdcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDEwMDAwXG5cbmV4cG9ydCBjb25zdCBXU19DTE9TRV9OT1JNQUwgPSAxMDAwXG5cbmV4cG9ydCBlbnVtIFNPQ0tFVF9TVEFURVMge1xuICBjb25uZWN0aW5nID0gMCxcbiAgb3BlbiA9IDEsXG4gIGNsb3NpbmcgPSAyLFxuICBjbG9zZWQgPSAzLFxufVxuXG5leHBvcnQgZW51bSBDSEFOTkVMX1NUQVRFUyB7XG4gIGNsb3NlZCA9ICdjbG9zZWQnLFxuICBlcnJvcmVkID0gJ2Vycm9yZWQnLFxuICBqb2luZWQgPSAnam9pbmVkJyxcbiAgam9pbmluZyA9ICdqb2luaW5nJyxcbiAgbGVhdmluZyA9ICdsZWF2aW5nJyxcbn1cblxuZXhwb3J0IGVudW0gQ0hBTk5FTF9FVkVOVFMge1xuICBjbG9zZSA9ICdwaHhfY2xvc2UnLFxuICBlcnJvciA9ICdwaHhfZXJyb3InLFxuICBqb2luID0gJ3BoeF9qb2luJyxcbiAgcmVwbHkgPSAncGh4X3JlcGx5JyxcbiAgbGVhdmUgPSAncGh4X2xlYXZlJyxcbiAgYWNjZXNzX3Rva2VuID0gJ2FjY2Vzc190b2tlbicsXG59XG5cbmV4cG9ydCBlbnVtIFRSQU5TUE9SVFMge1xuICB3ZWJzb2NrZXQgPSAnd2Vic29ja2V0Jyxcbn1cblxuZXhwb3J0IGVudW0gQ09OTkVDVElPTl9TVEFURSB7XG4gIENvbm5lY3RpbmcgPSAnY29ubmVjdGluZycsXG4gIE9wZW4gPSAnb3BlbicsXG4gIENsb3NpbmcgPSAnY2xvc2luZycsXG4gIENsb3NlZCA9ICdjbG9zZWQnLFxufVxuIiwgIi8vIFRoaXMgZmlsZSBkcmF3cyBoZWF2aWx5IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peC9jb21taXQvY2YwOThlOWNmN2E0NGVlNjQ3OWQzMWQ5MTFhOTdkM2M3NDMwYzZmZVxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlcmlhbGl6ZXIge1xuICBIRUFERVJfTEVOR1RIID0gMVxuXG4gIGRlY29kZShyYXdQYXlsb2FkOiBBcnJheUJ1ZmZlciB8IHN0cmluZywgY2FsbGJhY2s6IEZ1bmN0aW9uKSB7XG4gICAgaWYgKHJhd1BheWxvYWQuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fYmluYXJ5RGVjb2RlKHJhd1BheWxvYWQpKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmF3UGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnBhcnNlKHJhd1BheWxvYWQpKVxuICAgIH1cblxuICAgIHJldHVybiBjYWxsYmFjayh7fSlcbiAgfVxuXG4gIHByaXZhdGUgX2JpbmFyeURlY29kZShidWZmZXI6IEFycmF5QnVmZmVyKSB7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpXG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG5cbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgfVxuXG4gIHByaXZhdGUgX2RlY29kZUJyb2FkY2FzdChcbiAgICBidWZmZXI6IEFycmF5QnVmZmVyLFxuICAgIHZpZXc6IERhdGFWaWV3LFxuICAgIGRlY29kZXI6IFRleHREZWNvZGVyXG4gICk6IHtcbiAgICByZWY6IG51bGxcbiAgICB0b3BpYzogc3RyaW5nXG4gICAgZXZlbnQ6IHN0cmluZ1xuICAgIHBheWxvYWQ6IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgfSB7XG4gICAgY29uc3QgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgxKVxuICAgIGNvbnN0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoMilcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgMlxuICAgIGNvbnN0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemVcbiAgICBjb25zdCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplXG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoXG4gICAgICBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCkpXG4gICAgKVxuXG4gICAgcmV0dXJuIHsgcmVmOiBudWxsLCB0b3BpYzogdG9waWMsIGV2ZW50OiBldmVudCwgcGF5bG9hZDogZGF0YSB9XG4gIH1cbn1cbiIsICIvKipcbiAqIENyZWF0ZXMgYSB0aW1lciB0aGF0IGFjY2VwdHMgYSBgdGltZXJDYWxjYCBmdW5jdGlvbiB0byBwZXJmb3JtIGNhbGN1bGF0ZWQgdGltZW91dCByZXRyaWVzLCBzdWNoIGFzIGV4cG9uZW50aWFsIGJhY2tvZmYuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIGxldCByZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB0aGlzLmNvbm5lY3QoKSwgZnVuY3Rpb24odHJpZXMpe1xuICogICAgICByZXR1cm4gWzEwMDAsIDUwMDAsIDEwMDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiAgICB9KVxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgNTAwMFxuICogICAgcmVjb25uZWN0VGltZXIucmVzZXQoKVxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciB7XG4gIHRpbWVyOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgdHJpZXM6IG51bWJlciA9IDBcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgY2FsbGJhY2s6IEZ1bmN0aW9uLCBwdWJsaWMgdGltZXJDYWxjOiBGdW5jdGlvbikge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMudGltZXJDYWxjID0gdGltZXJDYWxjXG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLnRyaWVzID0gMFxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuICB9XG5cbiAgLy8gQ2FuY2VscyBhbnkgcHJldmlvdXMgc2NoZWR1bGVUaW1lb3V0IGFuZCBzY2hlZHVsZXMgY2FsbGJhY2tcbiAgc2NoZWR1bGVUaW1lb3V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuXG4gICAgdGhpcy50aW1lciA9IDxhbnk+c2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyaWVzID0gdGhpcy50cmllcyArIDFcbiAgICAgIHRoaXMuY2FsbGJhY2soKVxuICAgIH0sIHRoaXMudGltZXJDYWxjKHRoaXMudHJpZXMgKyAxKSlcbiAgfVxufVxuIiwgIi8qKlxuICogSGVscGVycyB0byBjb252ZXJ0IHRoZSBjaGFuZ2UgUGF5bG9hZCBpbnRvIG5hdGl2ZSBKUyB0eXBlcy5cbiAqL1xuXG4vLyBBZGFwdGVkIGZyb20gZXBnc3FsIChzcmMvZXBnc3FsX2JpbmFyeS5lcmwpLCB0aGlzIG1vZHVsZSBsaWNlbnNlZCB1bmRlclxuLy8gMy1jbGF1c2UgQlNEIGZvdW5kIGhlcmU6IGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9lcGdzcWwvZXBnc3FsL2RldmVsL0xJQ0VOU0VcblxuZXhwb3J0IGVudW0gUG9zdGdyZXNUeXBlcyB7XG4gIGFic3RpbWUgPSAnYWJzdGltZScsXG4gIGJvb2wgPSAnYm9vbCcsXG4gIGRhdGUgPSAnZGF0ZScsXG4gIGRhdGVyYW5nZSA9ICdkYXRlcmFuZ2UnLFxuICBmbG9hdDQgPSAnZmxvYXQ0JyxcbiAgZmxvYXQ4ID0gJ2Zsb2F0OCcsXG4gIGludDIgPSAnaW50MicsXG4gIGludDQgPSAnaW50NCcsXG4gIGludDRyYW5nZSA9ICdpbnQ0cmFuZ2UnLFxuICBpbnQ4ID0gJ2ludDgnLFxuICBpbnQ4cmFuZ2UgPSAnaW50OHJhbmdlJyxcbiAganNvbiA9ICdqc29uJyxcbiAganNvbmIgPSAnanNvbmInLFxuICBtb25leSA9ICdtb25leScsXG4gIG51bWVyaWMgPSAnbnVtZXJpYycsXG4gIG9pZCA9ICdvaWQnLFxuICByZWx0aW1lID0gJ3JlbHRpbWUnLFxuICB0ZXh0ID0gJ3RleHQnLFxuICB0aW1lID0gJ3RpbWUnLFxuICB0aW1lc3RhbXAgPSAndGltZXN0YW1wJyxcbiAgdGltZXN0YW1wdHogPSAndGltZXN0YW1wdHonLFxuICB0aW1ldHogPSAndGltZXR6JyxcbiAgdHNyYW5nZSA9ICd0c3JhbmdlJyxcbiAgdHN0enJhbmdlID0gJ3RzdHpyYW5nZScsXG59XG5cbnR5cGUgQ29sdW1ucyA9IHtcbiAgbmFtZTogc3RyaW5nIC8vIHRoZSBjb2x1bW4gbmFtZS4gZWc6IFwidXNlcl9pZFwiXG4gIHR5cGU6IHN0cmluZyAvLyB0aGUgY29sdW1uIHR5cGUuIGVnOiBcInV1aWRcIlxuICBmbGFncz86IHN0cmluZ1tdIC8vIGFueSBzcGVjaWFsIGZsYWdzIGZvciB0aGUgY29sdW1uLiBlZzogW1wia2V5XCJdXG4gIHR5cGVfbW9kaWZpZXI/OiBudW1iZXIgLy8gdGhlIHR5cGUgbW9kaWZpZXIuIGVnOiA0Mjk0OTY3Mjk1XG59W11cblxudHlwZSBCYXNlVmFsdWUgPSBudWxsIHwgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhblxudHlwZSBSZWNvcmRWYWx1ZSA9IEJhc2VWYWx1ZSB8IEJhc2VWYWx1ZVtdXG5cbnR5cGUgUmVjb3JkID0ge1xuICBba2V5OiBzdHJpbmddOiBSZWNvcmRWYWx1ZVxufVxuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIGNvbHVtbnMgYW5kIGFuIG9iamVjdCBvZiBzdHJpbmcgdmFsdWVzIHRoZW4gY29udmVydHMgZWFjaCBzdHJpbmcgdmFsdWVcbiAqIHRvIGl0cyBtYXBwZWQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge3tuYW1lOiBTdHJpbmcsIHR5cGU6IFN0cmluZ31bXX0gY29sdW1uc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG1hcCBvZiB2YXJpb3VzIG9wdGlvbnMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byB0aGUgbWFwcGVyXG4gKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLnNraXBUeXBlcyBUaGUgYXJyYXkgb2YgdHlwZXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbnZlcnRlZFxuICpcbiAqIEBleGFtcGxlIGNvbnZlcnRDaGFuZ2VEYXRhKFt7bmFtZTogJ2ZpcnN0X25hbWUnLCB0eXBlOiAndGV4dCd9LCB7bmFtZTogJ2FnZScsIHR5cGU6ICdpbnQ0J31dLCB7Zmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6JzMzJ30sIHt9KVxuICogLy89PnsgZmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6IDMzIH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRDaGFuZ2VEYXRhID0gKFxuICBjb2x1bW5zOiBDb2x1bW5zLFxuICByZWNvcmQ6IFJlY29yZCxcbiAgb3B0aW9uczogeyBza2lwVHlwZXM/OiBzdHJpbmdbXSB9ID0ge31cbik6IFJlY29yZCA9PiB7XG4gIGNvbnN0IHNraXBUeXBlcyA9IG9wdGlvbnMuc2tpcFR5cGVzID8/IFtdXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHJlY29yZCkucmVkdWNlKChhY2MsIHJlY19rZXkpID0+IHtcbiAgICBhY2NbcmVjX2tleV0gPSBjb252ZXJ0Q29sdW1uKHJlY19rZXksIGNvbHVtbnMsIHJlY29yZCwgc2tpcFR5cGVzKVxuICAgIHJldHVybiBhY2NcbiAgfSwge30gYXMgUmVjb3JkKVxufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSB2YWx1ZSBvZiBhbiBpbmRpdmlkdWFsIGNvbHVtbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sdW1uTmFtZSBUaGUgY29sdW1uIHRoYXQgeW91IHdhbnQgdG8gY29udmVydFxuICogQHBhcmFtIHt7bmFtZTogU3RyaW5nLCB0eXBlOiBTdHJpbmd9W119IGNvbHVtbnMgQWxsIG9mIHRoZSBjb2x1bW5zXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkIFRoZSBtYXAgb2Ygc3RyaW5nIHZhbHVlc1xuICogQHBhcmFtIHtBcnJheX0gc2tpcFR5cGVzIEFuIGFycmF5IG9mIHR5cGVzIHRoYXQgc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWRcbiAqIEByZXR1cm4ge29iamVjdH0gVXNlbGVzcyBpbmZvcm1hdGlvblxuICpcbiAqIEBleGFtcGxlIGNvbnZlcnRDb2x1bW4oJ2FnZScsIFt7bmFtZTogJ2ZpcnN0X25hbWUnLCB0eXBlOiAndGV4dCd9LCB7bmFtZTogJ2FnZScsIHR5cGU6ICdpbnQ0J31dLCB7Zmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6ICczMyd9LCBbXSlcbiAqIC8vPT4gMzNcbiAqIEBleGFtcGxlIGNvbnZlcnRDb2x1bW4oJ2FnZScsIFt7bmFtZTogJ2ZpcnN0X25hbWUnLCB0eXBlOiAndGV4dCd9LCB7bmFtZTogJ2FnZScsIHR5cGU6ICdpbnQ0J31dLCB7Zmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6ICczMyd9LCBbJ2ludDQnXSlcbiAqIC8vPT4gXCIzM1wiXG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0Q29sdW1uID0gKFxuICBjb2x1bW5OYW1lOiBzdHJpbmcsXG4gIGNvbHVtbnM6IENvbHVtbnMsXG4gIHJlY29yZDogUmVjb3JkLFxuICBza2lwVHlwZXM6IHN0cmluZ1tdXG4pOiBSZWNvcmRWYWx1ZSA9PiB7XG4gIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnMuZmluZCgoeCkgPT4geC5uYW1lID09PSBjb2x1bW5OYW1lKVxuICBjb25zdCBjb2xUeXBlID0gY29sdW1uPy50eXBlXG4gIGNvbnN0IHZhbHVlID0gcmVjb3JkW2NvbHVtbk5hbWVdXG5cbiAgaWYgKGNvbFR5cGUgJiYgIXNraXBUeXBlcy5pbmNsdWRlcyhjb2xUeXBlKSkge1xuICAgIHJldHVybiBjb252ZXJ0Q2VsbChjb2xUeXBlLCB2YWx1ZSlcbiAgfVxuXG4gIHJldHVybiBub29wKHZhbHVlKVxufVxuXG4vKipcbiAqIElmIHRoZSB2YWx1ZSBvZiB0aGUgY2VsbCBpcyBgbnVsbGAsIHJldHVybnMgbnVsbC5cbiAqIE90aGVyd2lzZSBjb252ZXJ0cyB0aGUgc3RyaW5nIHZhbHVlIHRvIHRoZSBjb3JyZWN0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHBvc3RncmVzIGNvbHVtbiB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGNlbGwgdmFsdWVcbiAqXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnYm9vbCcsICd0JylcbiAqIC8vPT4gdHJ1ZVxuICogQGV4YW1wbGUgY29udmVydENlbGwoJ2ludDgnLCAnMTAnKVxuICogLy89PiAxMFxuICogQGV4YW1wbGUgY29udmVydENlbGwoJ19pbnQ0JywgJ3sxLDIsMyw0fScpXG4gKiAvLz0+IFsxLDIsMyw0XVxuICovXG5leHBvcnQgY29uc3QgY29udmVydENlbGwgPSAodHlwZTogc3RyaW5nLCB2YWx1ZTogUmVjb3JkVmFsdWUpOiBSZWNvcmRWYWx1ZSA9PiB7XG4gIC8vIGlmIGRhdGEgdHlwZSBpcyBhbiBhcnJheVxuICBpZiAodHlwZS5jaGFyQXQoMCkgPT09ICdfJykge1xuICAgIGNvbnN0IGRhdGFUeXBlID0gdHlwZS5zbGljZSgxLCB0eXBlLmxlbmd0aClcbiAgICByZXR1cm4gdG9BcnJheSh2YWx1ZSwgZGF0YVR5cGUpXG4gIH1cblxuICAvLyBJZiBub3QgbnVsbCwgY29udmVydCB0byBjb3JyZWN0IHR5cGUuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5ib29sOlxuICAgICAgcmV0dXJuIHRvQm9vbGVhbih2YWx1ZSlcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuZmxvYXQ0OlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5mbG9hdDg6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDI6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDQ6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDg6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLm51bWVyaWM6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLm9pZDpcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSlcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuanNvbjpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuanNvbmI6XG4gICAgICByZXR1cm4gdG9Kc29uKHZhbHVlKVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1lc3RhbXA6XG4gICAgICByZXR1cm4gdG9UaW1lc3RhbXBTdHJpbmcodmFsdWUpIC8vIEZvcm1hdCB0byBiZSBjb25zaXN0ZW50IHdpdGggUG9zdGdSRVNUXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmFic3RpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuZGF0ZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5kYXRlcmFuZ2U6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDRyYW5nZTpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50OHJhbmdlOlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5tb25leTpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMucmVsdGltZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50ZXh0OlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1lOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWVzdGFtcHR6OiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWV0ejogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50c3JhbmdlOlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50c3R6cmFuZ2U6XG4gICAgICByZXR1cm4gbm9vcCh2YWx1ZSlcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgcmVtYWluaW5nIHR5cGVzXG4gICAgICByZXR1cm4gbm9vcCh2YWx1ZSlcbiAgfVxufVxuXG5jb25zdCBub29wID0gKHZhbHVlOiBSZWNvcmRWYWx1ZSk6IFJlY29yZFZhbHVlID0+IHtcbiAgcmV0dXJuIHZhbHVlXG59XG5leHBvcnQgY29uc3QgdG9Cb29sZWFuID0gKHZhbHVlOiBSZWNvcmRWYWx1ZSk6IFJlY29yZFZhbHVlID0+IHtcbiAgc3dpdGNoICh2YWx1ZSkge1xuICAgIGNhc2UgJ3QnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBjYXNlICdmJzpcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdmFsdWVcbiAgfVxufVxuZXhwb3J0IGNvbnN0IHRvTnVtYmVyID0gKHZhbHVlOiBSZWNvcmRWYWx1ZSk6IFJlY29yZFZhbHVlID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpXG4gICAgaWYgKCFOdW1iZXIuaXNOYU4ocGFyc2VkVmFsdWUpKSB7XG4gICAgICByZXR1cm4gcGFyc2VkVmFsdWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5leHBvcnQgY29uc3QgdG9Kc29uID0gKHZhbHVlOiBSZWNvcmRWYWx1ZSk6IFJlY29yZFZhbHVlID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBKU09OIHBhcnNlIGVycm9yOiAke2Vycm9yfWApXG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogQ29udmVydHMgYSBQb3N0Z3JlcyBBcnJheSBpbnRvIGEgbmF0aXZlIEpTIGFycmF5XG4gKlxuICogQGV4YW1wbGUgdG9BcnJheSgne30nLCAnaW50NCcpXG4gKiAvLz0+IFtdXG4gKiBAZXhhbXBsZSB0b0FycmF5KCd7XCJbMjAyMS0wMS0wMSwyMDIxLTEyLTMxKVwiLFwiKDIwMjEtMDEtMDEsMjAyMS0xMi0zMl1cIn0nLCAnZGF0ZXJhbmdlJylcbiAqIC8vPT4gWydbMjAyMS0wMS0wMSwyMDIxLTEyLTMxKScsICcoMjAyMS0wMS0wMSwyMDIxLTEyLTMyXSddXG4gKiBAZXhhbXBsZSB0b0FycmF5KFsxLDIsMyw0XSwgJ2ludDQnKVxuICogLy89PiBbMSwyLDMsNF1cbiAqL1xuZXhwb3J0IGNvbnN0IHRvQXJyYXkgPSAodmFsdWU6IFJlY29yZFZhbHVlLCB0eXBlOiBzdHJpbmcpOiBSZWNvcmRWYWx1ZSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBjb25zdCBsYXN0SWR4ID0gdmFsdWUubGVuZ3RoIC0gMVxuICBjb25zdCBjbG9zZUJyYWNlID0gdmFsdWVbbGFzdElkeF1cbiAgY29uc3Qgb3BlbkJyYWNlID0gdmFsdWVbMF1cblxuICAvLyBDb25maXJtIHZhbHVlIGlzIGEgUG9zdGdyZXMgYXJyYXkgYnkgY2hlY2tpbmcgY3VybHkgYnJhY2tldHNcbiAgaWYgKG9wZW5CcmFjZSA9PT0gJ3snICYmIGNsb3NlQnJhY2UgPT09ICd9Jykge1xuICAgIGxldCBhcnJcbiAgICBjb25zdCB2YWxUcmltID0gdmFsdWUuc2xpY2UoMSwgbGFzdElkeClcblxuICAgIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgc29sdXRpb24gdG8gc2VwYXJhdGUgUG9zdGdyZXMgYXJyYXkgZGF0YVxuICAgIHRyeSB7XG4gICAgICBhcnIgPSBKU09OLnBhcnNlKCdbJyArIHZhbFRyaW0gKyAnXScpXG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgLy8gV0FSTklORzogc3BsaXR0aW5nIG9uIGNvbW1hIGRvZXMgbm90IGNvdmVyIGFsbCBlZGdlIGNhc2VzXG4gICAgICBhcnIgPSB2YWxUcmltID8gdmFsVHJpbS5zcGxpdCgnLCcpIDogW11cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyLm1hcCgodmFsOiBCYXNlVmFsdWUpID0+IGNvbnZlcnRDZWxsKHR5cGUsIHZhbCkpXG4gIH1cblxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBGaXhlcyB0aW1lc3RhbXAgdG8gYmUgSVNPLTg2MDEuIFN3YXBzIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSBkYXRlIGFuZCB0aW1lIGZvciBhICdUJ1xuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9zdXBhYmFzZS9pc3N1ZXMvMThcbiAqXG4gKiBAZXhhbXBsZSB0b1RpbWVzdGFtcFN0cmluZygnMjAxOS0wOS0xMCAwMDowMDowMCcpXG4gKiAvLz0+ICcyMDE5LTA5LTEwVDAwOjAwOjAwJ1xuICovXG5leHBvcnQgY29uc3QgdG9UaW1lc3RhbXBTdHJpbmcgPSAodmFsdWU6IFJlY29yZFZhbHVlKTogUmVjb3JkVmFsdWUgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKCcgJywgJ1QnKVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlXG59XG5cbmV4cG9ydCBjb25zdCBodHRwRW5kcG9pbnRVUkwgPSAoc29ja2V0VXJsOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBsZXQgdXJsID0gc29ja2V0VXJsXG4gIHVybCA9IHVybC5yZXBsYWNlKC9ed3MvaSwgJ2h0dHAnKVxuICB1cmwgPSB1cmwucmVwbGFjZSgvKFxcL3NvY2tldFxcL3dlYnNvY2tldHxcXC9zb2NrZXR8XFwvd2Vic29ja2V0KVxcLz8kL2ksICcnKVxuICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcLyskLywgJycpXG59XG4iLCAiaW1wb3J0IHsgREVGQVVMVF9USU1FT1VUIH0gZnJvbSAnLi4vbGliL2NvbnN0YW50cydcbmltcG9ydCB0eXBlIFJlYWx0aW1lQ2hhbm5lbCBmcm9tICcuLi9SZWFsdGltZUNoYW5uZWwnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1c2gge1xuICBzZW50OiBib29sZWFuID0gZmFsc2VcbiAgdGltZW91dFRpbWVyOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgcmVmOiBzdHJpbmcgPSAnJ1xuICByZWNlaXZlZFJlc3A6IHtcbiAgICBzdGF0dXM6IHN0cmluZ1xuICAgIHJlc3BvbnNlOiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIH0gfCBudWxsID0gbnVsbFxuICByZWNIb29rczoge1xuICAgIHN0YXR1czogc3RyaW5nXG4gICAgY2FsbGJhY2s6IEZ1bmN0aW9uXG4gIH1bXSA9IFtdXG4gIHJlZkV2ZW50OiBzdHJpbmcgfCBudWxsID0gbnVsbFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgUHVzaFxuICAgKlxuICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgQ2hhbm5lbFxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50LCBmb3IgZXhhbXBsZSBgXCJwaHhfam9pblwiYFxuICAgKiBAcGFyYW0gcGF5bG9hZCBUaGUgcGF5bG9hZCwgZm9yIGV4YW1wbGUgYHt1c2VyX2lkOiAxMjN9YFxuICAgKiBAcGFyYW0gdGltZW91dCBUaGUgcHVzaCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCxcbiAgICBwdWJsaWMgZXZlbnQ6IHN0cmluZyxcbiAgICBwdWJsaWMgcGF5bG9hZDogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9LFxuICAgIHB1YmxpYyB0aW1lb3V0OiBudW1iZXIgPSBERUZBVUxUX1RJTUVPVVRcbiAgKSB7fVxuXG4gIHJlc2VuZCh0aW1lb3V0OiBudW1iZXIpIHtcbiAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgdGhpcy5fY2FuY2VsUmVmRXZlbnQoKVxuICAgIHRoaXMucmVmID0gJydcbiAgICB0aGlzLnJlZkV2ZW50ID0gbnVsbFxuICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbFxuICAgIHRoaXMuc2VudCA9IGZhbHNlXG4gICAgdGhpcy5zZW5kKClcbiAgfVxuXG4gIHNlbmQoKSB7XG4gICAgaWYgKHRoaXMuX2hhc1JlY2VpdmVkKCd0aW1lb3V0JykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLnN0YXJ0VGltZW91dCgpXG4gICAgdGhpcy5zZW50ID0gdHJ1ZVxuICAgIHRoaXMuY2hhbm5lbC5zb2NrZXQucHVzaCh7XG4gICAgICB0b3BpYzogdGhpcy5jaGFubmVsLnRvcGljLFxuICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICBwYXlsb2FkOiB0aGlzLnBheWxvYWQsXG4gICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgam9pbl9yZWY6IHRoaXMuY2hhbm5lbC5fam9pblJlZigpLFxuICAgIH0pXG4gIH1cblxuICB1cGRhdGVQYXlsb2FkKHBheWxvYWQ6IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiB2b2lkIHtcbiAgICB0aGlzLnBheWxvYWQgPSB7IC4uLnRoaXMucGF5bG9hZCwgLi4ucGF5bG9hZCB9XG4gIH1cblxuICByZWNlaXZlKHN0YXR1czogc3RyaW5nLCBjYWxsYmFjazogRnVuY3Rpb24pIHtcbiAgICBpZiAodGhpcy5faGFzUmVjZWl2ZWQoc3RhdHVzKSkge1xuICAgICAgY2FsbGJhY2sodGhpcy5yZWNlaXZlZFJlc3A/LnJlc3BvbnNlKVxuICAgIH1cblxuICAgIHRoaXMucmVjSG9va3MucHVzaCh7IHN0YXR1cywgY2FsbGJhY2sgfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnRUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLnRpbWVvdXRUaW1lcikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMucmVmID0gdGhpcy5jaGFubmVsLnNvY2tldC5fbWFrZVJlZigpXG4gICAgdGhpcy5yZWZFdmVudCA9IHRoaXMuY2hhbm5lbC5fcmVwbHlFdmVudE5hbWUodGhpcy5yZWYpXG5cbiAgICBjb25zdCBjYWxsYmFjayA9IChwYXlsb2FkOiBhbnkpID0+IHtcbiAgICAgIHRoaXMuX2NhbmNlbFJlZkV2ZW50KClcbiAgICAgIHRoaXMuX2NhbmNlbFRpbWVvdXQoKVxuICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBwYXlsb2FkXG4gICAgICB0aGlzLl9tYXRjaFJlY2VpdmUocGF5bG9hZClcbiAgICB9XG5cbiAgICB0aGlzLmNoYW5uZWwuX29uKHRoaXMucmVmRXZlbnQsIHt9LCBjYWxsYmFjaylcblxuICAgIHRoaXMudGltZW91dFRpbWVyID0gPGFueT5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcigndGltZW91dCcsIHt9KVxuICAgIH0sIHRoaXMudGltZW91dClcbiAgfVxuXG4gIHRyaWdnZXIoc3RhdHVzOiBzdHJpbmcsIHJlc3BvbnNlOiBhbnkpIHtcbiAgICBpZiAodGhpcy5yZWZFdmVudClcbiAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcih0aGlzLnJlZkV2ZW50LCB7IHN0YXR1cywgcmVzcG9uc2UgfSlcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fY2FuY2VsUmVmRXZlbnQoKVxuICAgIHRoaXMuX2NhbmNlbFRpbWVvdXQoKVxuICB9XG5cbiAgcHJpdmF0ZSBfY2FuY2VsUmVmRXZlbnQoKSB7XG4gICAgaWYgKCF0aGlzLnJlZkV2ZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmNoYW5uZWwuX29mZih0aGlzLnJlZkV2ZW50LCB7fSlcbiAgfVxuXG4gIHByaXZhdGUgX2NhbmNlbFRpbWVvdXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFRpbWVyKVxuICAgIHRoaXMudGltZW91dFRpbWVyID0gdW5kZWZpbmVkXG4gIH1cblxuICBwcml2YXRlIF9tYXRjaFJlY2VpdmUoe1xuICAgIHN0YXR1cyxcbiAgICByZXNwb25zZSxcbiAgfToge1xuICAgIHN0YXR1czogc3RyaW5nXG4gICAgcmVzcG9uc2U6IEZ1bmN0aW9uXG4gIH0pIHtcbiAgICB0aGlzLnJlY0hvb2tzXG4gICAgICAuZmlsdGVyKChoKSA9PiBoLnN0YXR1cyA9PT0gc3RhdHVzKVxuICAgICAgLmZvckVhY2goKGgpID0+IGguY2FsbGJhY2socmVzcG9uc2UpKVxuICB9XG5cbiAgcHJpdmF0ZSBfaGFzUmVjZWl2ZWQoc3RhdHVzOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNlaXZlZFJlc3AgJiYgdGhpcy5yZWNlaXZlZFJlc3Auc3RhdHVzID09PSBzdGF0dXNcbiAgfVxufVxuIiwgIi8qXG4gIFRoaXMgZmlsZSBkcmF3cyBoZWF2aWx5IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peC9ibG9iL2QzNDRlYzBhNzMyYWI0ZWUyMDQyMTViMzFkZTY5Y2Y0YmU3MmUzYmYvYXNzZXRzL2pzL3Bob2VuaXgvcHJlc2VuY2UuanNcbiAgTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peC9ibG9iL2QzNDRlYzBhNzMyYWI0ZWUyMDQyMTViMzFkZTY5Y2Y0YmU3MmUzYmYvTElDRU5TRS5tZFxuKi9cblxuaW1wb3J0IHR5cGUge1xuICBQcmVzZW5jZU9wdHMsXG4gIFByZXNlbmNlT25Kb2luQ2FsbGJhY2ssXG4gIFByZXNlbmNlT25MZWF2ZUNhbGxiYWNrLFxufSBmcm9tICdwaG9lbml4J1xuaW1wb3J0IHR5cGUgUmVhbHRpbWVDaGFubmVsIGZyb20gJy4vUmVhbHRpbWVDaGFubmVsJ1xuXG50eXBlIFByZXNlbmNlPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge30+ID0ge1xuICBwcmVzZW5jZV9yZWY6IHN0cmluZ1xufSAmIFRcblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVQcmVzZW5jZVN0YXRlPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge30+ID0ge1xuICBba2V5OiBzdHJpbmddOiBQcmVzZW5jZTxUPltdXG59XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUHJlc2VuY2VKb2luUGF5bG9hZDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4gPSB7XG4gIGV2ZW50OiBgJHtSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLkpPSU59YFxuICBrZXk6IHN0cmluZ1xuICBjdXJyZW50UHJlc2VuY2VzOiBQcmVzZW5jZTxUPltdXG4gIG5ld1ByZXNlbmNlczogUHJlc2VuY2U8VD5bXVxufVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVByZXNlbmNlTGVhdmVQYXlsb2FkPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PiA9IHtcbiAgZXZlbnQ6IGAke1JFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMuTEVBVkV9YFxuICBrZXk6IHN0cmluZ1xuICBjdXJyZW50UHJlc2VuY2VzOiBQcmVzZW5jZTxUPltdXG4gIGxlZnRQcmVzZW5jZXM6IFByZXNlbmNlPFQ+W11cbn1cblxuZXhwb3J0IGVudW0gUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyB7XG4gIFNZTkMgPSAnc3luYycsXG4gIEpPSU4gPSAnam9pbicsXG4gIExFQVZFID0gJ2xlYXZlJyxcbn1cblxudHlwZSBQcmVzZW5jZURpZmYgPSB7XG4gIGpvaW5zOiBSZWFsdGltZVByZXNlbmNlU3RhdGVcbiAgbGVhdmVzOiBSZWFsdGltZVByZXNlbmNlU3RhdGVcbn1cblxudHlwZSBSYXdQcmVzZW5jZVN0YXRlID0ge1xuICBba2V5OiBzdHJpbmddOiB7XG4gICAgbWV0YXM6IHtcbiAgICAgIHBoeF9yZWY/OiBzdHJpbmdcbiAgICAgIHBoeF9yZWZfcHJldj86IHN0cmluZ1xuICAgICAgW2tleTogc3RyaW5nXTogYW55XG4gICAgfVtdXG4gIH1cbn1cblxudHlwZSBSYXdQcmVzZW5jZURpZmYgPSB7XG4gIGpvaW5zOiBSYXdQcmVzZW5jZVN0YXRlXG4gIGxlYXZlczogUmF3UHJlc2VuY2VTdGF0ZVxufVxuXG50eXBlIFByZXNlbmNlQ2hvb3NlcjxUPiA9IChrZXk6IHN0cmluZywgcHJlc2VuY2VzOiBQcmVzZW5jZVtdKSA9PiBUXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWx0aW1lUHJlc2VuY2Uge1xuICBzdGF0ZTogUmVhbHRpbWVQcmVzZW5jZVN0YXRlID0ge31cbiAgcGVuZGluZ0RpZmZzOiBSYXdQcmVzZW5jZURpZmZbXSA9IFtdXG4gIGpvaW5SZWY6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gIGNhbGxlcjoge1xuICAgIG9uSm9pbjogUHJlc2VuY2VPbkpvaW5DYWxsYmFja1xuICAgIG9uTGVhdmU6IFByZXNlbmNlT25MZWF2ZUNhbGxiYWNrXG4gICAgb25TeW5jOiAoKSA9PiB2b2lkXG4gIH0gPSB7XG4gICAgb25Kb2luOiAoKSA9PiB7fSxcbiAgICBvbkxlYXZlOiAoKSA9PiB7fSxcbiAgICBvblN5bmM6ICgpID0+IHt9LFxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBQcmVzZW5jZS5cbiAgICpcbiAgICogQHBhcmFtIGNoYW5uZWwgLSBUaGUgUmVhbHRpbWVDaGFubmVsXG4gICAqIEBwYXJhbSBvcHRzIC0gVGhlIG9wdGlvbnMsXG4gICAqICAgICAgICBmb3IgZXhhbXBsZSBge2V2ZW50czoge3N0YXRlOiAnc3RhdGUnLCBkaWZmOiAnZGlmZid9fWBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwsIG9wdHM/OiBQcmVzZW5jZU9wdHMpIHtcbiAgICBjb25zdCBldmVudHMgPSBvcHRzPy5ldmVudHMgfHwge1xuICAgICAgc3RhdGU6ICdwcmVzZW5jZV9zdGF0ZScsXG4gICAgICBkaWZmOiAncHJlc2VuY2VfZGlmZicsXG4gICAgfVxuXG4gICAgdGhpcy5jaGFubmVsLl9vbihldmVudHMuc3RhdGUsIHt9LCAobmV3U3RhdGU6IFJhd1ByZXNlbmNlU3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IHsgb25Kb2luLCBvbkxlYXZlLCBvblN5bmMgfSA9IHRoaXMuY2FsbGVyXG5cbiAgICAgIHRoaXMuam9pblJlZiA9IHRoaXMuY2hhbm5lbC5fam9pblJlZigpXG5cbiAgICAgIHRoaXMuc3RhdGUgPSBSZWFsdGltZVByZXNlbmNlLnN5bmNTdGF0ZShcbiAgICAgICAgdGhpcy5zdGF0ZSxcbiAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgIG9uSm9pbixcbiAgICAgICAgb25MZWF2ZVxuICAgICAgKVxuXG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKChkaWZmKSA9PiB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBSZWFsdGltZVByZXNlbmNlLnN5bmNEaWZmKFxuICAgICAgICAgIHRoaXMuc3RhdGUsXG4gICAgICAgICAgZGlmZixcbiAgICAgICAgICBvbkpvaW4sXG4gICAgICAgICAgb25MZWF2ZVxuICAgICAgICApXG4gICAgICB9KVxuXG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdXG5cbiAgICAgIG9uU3luYygpXG4gICAgfSlcblxuICAgIHRoaXMuY2hhbm5lbC5fb24oZXZlbnRzLmRpZmYsIHt9LCAoZGlmZjogUmF3UHJlc2VuY2VEaWZmKSA9PiB7XG4gICAgICBjb25zdCB7IG9uSm9pbiwgb25MZWF2ZSwgb25TeW5jIH0gPSB0aGlzLmNhbGxlclxuXG4gICAgICBpZiAodGhpcy5pblBlbmRpbmdTeW5jU3RhdGUoKSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcy5wdXNoKGRpZmYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gUmVhbHRpbWVQcmVzZW5jZS5zeW5jRGlmZihcbiAgICAgICAgICB0aGlzLnN0YXRlLFxuICAgICAgICAgIGRpZmYsXG4gICAgICAgICAgb25Kb2luLFxuICAgICAgICAgIG9uTGVhdmVcbiAgICAgICAgKVxuXG4gICAgICAgIG9uU3luYygpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMub25Kb2luKChrZXksIGN1cnJlbnRQcmVzZW5jZXMsIG5ld1ByZXNlbmNlcykgPT4ge1xuICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHtcbiAgICAgICAgZXZlbnQ6ICdqb2luJyxcbiAgICAgICAga2V5LFxuICAgICAgICBjdXJyZW50UHJlc2VuY2VzLFxuICAgICAgICBuZXdQcmVzZW5jZXMsXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uTGVhdmUoKGtleSwgY3VycmVudFByZXNlbmNlcywgbGVmdFByZXNlbmNlcykgPT4ge1xuICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHtcbiAgICAgICAgZXZlbnQ6ICdsZWF2ZScsXG4gICAgICAgIGtleSxcbiAgICAgICAgY3VycmVudFByZXNlbmNlcyxcbiAgICAgICAgbGVmdFByZXNlbmNlcyxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMub25TeW5jKCgpID0+IHtcbiAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcigncHJlc2VuY2UnLCB7IGV2ZW50OiAnc3luYycgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gc3luYyB0aGUgbGlzdCBvZiBwcmVzZW5jZXMgb24gdGhlIHNlcnZlciB3aXRoIHRoZVxuICAgKiBjbGllbnQncyBzdGF0ZS5cbiAgICpcbiAgICogQW4gb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFjayBjYW4gYmUgcHJvdmlkZWQgdG9cbiAgICogcmVhY3QgdG8gY2hhbmdlcyBpbiB0aGUgY2xpZW50J3MgbG9jYWwgcHJlc2VuY2VzIGFjcm9zc1xuICAgKiBkaXNjb25uZWN0cyBhbmQgcmVjb25uZWN0cyB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgc3luY1N0YXRlKFxuICAgIGN1cnJlbnRTdGF0ZTogUmVhbHRpbWVQcmVzZW5jZVN0YXRlLFxuICAgIG5ld1N0YXRlOiBSYXdQcmVzZW5jZVN0YXRlIHwgUmVhbHRpbWVQcmVzZW5jZVN0YXRlLFxuICAgIG9uSm9pbjogUHJlc2VuY2VPbkpvaW5DYWxsYmFjayxcbiAgICBvbkxlYXZlOiBQcmVzZW5jZU9uTGVhdmVDYWxsYmFja1xuICApOiBSZWFsdGltZVByZXNlbmNlU3RhdGUge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5jbG9uZURlZXAoY3VycmVudFN0YXRlKVxuICAgIGNvbnN0IHRyYW5zZm9ybWVkU3RhdGUgPSB0aGlzLnRyYW5zZm9ybVN0YXRlKG5ld1N0YXRlKVxuICAgIGNvbnN0IGpvaW5zOiBSZWFsdGltZVByZXNlbmNlU3RhdGUgPSB7fVxuICAgIGNvbnN0IGxlYXZlczogUmVhbHRpbWVQcmVzZW5jZVN0YXRlID0ge31cblxuICAgIHRoaXMubWFwKHN0YXRlLCAoa2V5OiBzdHJpbmcsIHByZXNlbmNlczogUHJlc2VuY2VbXSkgPT4ge1xuICAgICAgaWYgKCF0cmFuc2Zvcm1lZFN0YXRlW2tleV0pIHtcbiAgICAgICAgbGVhdmVzW2tleV0gPSBwcmVzZW5jZXNcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5tYXAodHJhbnNmb3JtZWRTdGF0ZSwgKGtleSwgbmV3UHJlc2VuY2VzOiBQcmVzZW5jZVtdKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50UHJlc2VuY2VzOiBQcmVzZW5jZVtdID0gc3RhdGVba2V5XVxuXG4gICAgICBpZiAoY3VycmVudFByZXNlbmNlcykge1xuICAgICAgICBjb25zdCBuZXdQcmVzZW5jZVJlZnMgPSBuZXdQcmVzZW5jZXMubWFwKFxuICAgICAgICAgIChtOiBQcmVzZW5jZSkgPT4gbS5wcmVzZW5jZV9yZWZcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBjdXJQcmVzZW5jZVJlZnMgPSBjdXJyZW50UHJlc2VuY2VzLm1hcChcbiAgICAgICAgICAobTogUHJlc2VuY2UpID0+IG0ucHJlc2VuY2VfcmVmXG4gICAgICAgIClcbiAgICAgICAgY29uc3Qgam9pbmVkUHJlc2VuY2VzOiBQcmVzZW5jZVtdID0gbmV3UHJlc2VuY2VzLmZpbHRlcihcbiAgICAgICAgICAobTogUHJlc2VuY2UpID0+IGN1clByZXNlbmNlUmVmcy5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDBcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBsZWZ0UHJlc2VuY2VzOiBQcmVzZW5jZVtdID0gY3VycmVudFByZXNlbmNlcy5maWx0ZXIoXG4gICAgICAgICAgKG06IFByZXNlbmNlKSA9PiBuZXdQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwXG4gICAgICAgIClcblxuICAgICAgICBpZiAoam9pbmVkUHJlc2VuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBqb2luc1trZXldID0gam9pbmVkUHJlc2VuY2VzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVmdFByZXNlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGVhdmVzW2tleV0gPSBsZWZ0UHJlc2VuY2VzXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZXNcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHRoaXMuc3luY0RpZmYoc3RhdGUsIHsgam9pbnMsIGxlYXZlcyB9LCBvbkpvaW4sIG9uTGVhdmUpXG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBzeW5jIGEgZGlmZiBvZiBwcmVzZW5jZSBqb2luIGFuZCBsZWF2ZSBldmVudHMgZnJvbSB0aGVcbiAgICogc2VydmVyLCBhcyB0aGV5IGhhcHBlbi5cbiAgICpcbiAgICogTGlrZSBgc3luY1N0YXRlYCwgYHN5bmNEaWZmYCBhY2NlcHRzIG9wdGlvbmFsIGBvbkpvaW5gIGFuZFxuICAgKiBgb25MZWF2ZWAgY2FsbGJhY2tzIHRvIHJlYWN0IHRvIGEgdXNlciBqb2luaW5nIG9yIGxlYXZpbmcgZnJvbSBhXG4gICAqIGRldmljZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBzeW5jRGlmZihcbiAgICBzdGF0ZTogUmVhbHRpbWVQcmVzZW5jZVN0YXRlLFxuICAgIGRpZmY6IFJhd1ByZXNlbmNlRGlmZiB8IFByZXNlbmNlRGlmZixcbiAgICBvbkpvaW46IFByZXNlbmNlT25Kb2luQ2FsbGJhY2ssXG4gICAgb25MZWF2ZTogUHJlc2VuY2VPbkxlYXZlQ2FsbGJhY2tcbiAgKTogUmVhbHRpbWVQcmVzZW5jZVN0YXRlIHtcbiAgICBjb25zdCB7IGpvaW5zLCBsZWF2ZXMgfSA9IHtcbiAgICAgIGpvaW5zOiB0aGlzLnRyYW5zZm9ybVN0YXRlKGRpZmYuam9pbnMpLFxuICAgICAgbGVhdmVzOiB0aGlzLnRyYW5zZm9ybVN0YXRlKGRpZmYubGVhdmVzKSxcbiAgICB9XG5cbiAgICBpZiAoIW9uSm9pbikge1xuICAgICAgb25Kb2luID0gKCkgPT4ge31cbiAgICB9XG5cbiAgICBpZiAoIW9uTGVhdmUpIHtcbiAgICAgIG9uTGVhdmUgPSAoKSA9PiB7fVxuICAgIH1cblxuICAgIHRoaXMubWFwKGpvaW5zLCAoa2V5LCBuZXdQcmVzZW5jZXM6IFByZXNlbmNlW10pID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRQcmVzZW5jZXM6IFByZXNlbmNlW10gPSBzdGF0ZVtrZXldID8/IFtdXG4gICAgICBzdGF0ZVtrZXldID0gdGhpcy5jbG9uZURlZXAobmV3UHJlc2VuY2VzKVxuXG4gICAgICBpZiAoY3VycmVudFByZXNlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGpvaW5lZFByZXNlbmNlUmVmcyA9IHN0YXRlW2tleV0ubWFwKFxuICAgICAgICAgIChtOiBQcmVzZW5jZSkgPT4gbS5wcmVzZW5jZV9yZWZcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBjdXJQcmVzZW5jZXM6IFByZXNlbmNlW10gPSBjdXJyZW50UHJlc2VuY2VzLmZpbHRlcihcbiAgICAgICAgICAobTogUHJlc2VuY2UpID0+IGpvaW5lZFByZXNlbmNlUmVmcy5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDBcbiAgICAgICAgKVxuXG4gICAgICAgIHN0YXRlW2tleV0udW5zaGlmdCguLi5jdXJQcmVzZW5jZXMpXG4gICAgICB9XG5cbiAgICAgIG9uSm9pbihrZXksIGN1cnJlbnRQcmVzZW5jZXMsIG5ld1ByZXNlbmNlcylcbiAgICB9KVxuXG4gICAgdGhpcy5tYXAobGVhdmVzLCAoa2V5LCBsZWZ0UHJlc2VuY2VzOiBQcmVzZW5jZVtdKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFByZXNlbmNlczogUHJlc2VuY2VbXSA9IHN0YXRlW2tleV1cblxuICAgICAgaWYgKCFjdXJyZW50UHJlc2VuY2VzKSByZXR1cm5cblxuICAgICAgY29uc3QgcHJlc2VuY2VSZWZzVG9SZW1vdmUgPSBsZWZ0UHJlc2VuY2VzLm1hcChcbiAgICAgICAgKG06IFByZXNlbmNlKSA9PiBtLnByZXNlbmNlX3JlZlxuICAgICAgKVxuICAgICAgY3VycmVudFByZXNlbmNlcyA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKFxuICAgICAgICAobTogUHJlc2VuY2UpID0+IHByZXNlbmNlUmVmc1RvUmVtb3ZlLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMFxuICAgICAgKVxuXG4gICAgICBzdGF0ZVtrZXldID0gY3VycmVudFByZXNlbmNlc1xuXG4gICAgICBvbkxlYXZlKGtleSwgY3VycmVudFByZXNlbmNlcywgbGVmdFByZXNlbmNlcylcblxuICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZXMubGVuZ3RoID09PSAwKSBkZWxldGUgc3RhdGVba2V5XVxuICAgIH0pXG5cbiAgICByZXR1cm4gc3RhdGVcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgbWFwPFQgPSBhbnk+KFxuICAgIG9iajogUmVhbHRpbWVQcmVzZW5jZVN0YXRlLFxuICAgIGZ1bmM6IFByZXNlbmNlQ2hvb3NlcjxUPlxuICApOiBUW10ge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLm1hcCgoa2V5KSA9PiBmdW5jKGtleSwgb2JqW2tleV0pKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSAnbWV0YXMnIGtleVxuICAgKiBDaGFuZ2UgJ3BoeF9yZWYnIHRvICdwcmVzZW5jZV9yZWYnXG4gICAqIFJlbW92ZSAncGh4X3JlZicgYW5kICdwaHhfcmVmX3ByZXYnXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIHJldHVybnMge1xuICAgKiAgYWJjMTIzOiBbXG4gICAqICAgIHsgcHJlc2VuY2VfcmVmOiAnMicsIHVzZXJfaWQ6IDEgfSxcbiAgICogICAgeyBwcmVzZW5jZV9yZWY6ICczJywgdXNlcl9pZDogMiB9XG4gICAqICBdXG4gICAqIH1cbiAgICogUmVhbHRpbWVQcmVzZW5jZS50cmFuc2Zvcm1TdGF0ZSh7XG4gICAqICBhYmMxMjM6IHtcbiAgICogICAgbWV0YXM6IFtcbiAgICogICAgICB7IHBoeF9yZWY6ICcyJywgcGh4X3JlZl9wcmV2OiAnMScgdXNlcl9pZDogMSB9LFxuICAgKiAgICAgIHsgcGh4X3JlZjogJzMnLCB1c2VyX2lkOiAyIH1cbiAgICogICAgXVxuICAgKiAgfVxuICAgKiB9KVxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHRyYW5zZm9ybVN0YXRlKFxuICAgIHN0YXRlOiBSYXdQcmVzZW5jZVN0YXRlIHwgUmVhbHRpbWVQcmVzZW5jZVN0YXRlXG4gICk6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSB7XG4gICAgc3RhdGUgPSB0aGlzLmNsb25lRGVlcChzdGF0ZSlcblxuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdGF0ZSkucmVkdWNlKChuZXdTdGF0ZSwga2V5KSA9PiB7XG4gICAgICBjb25zdCBwcmVzZW5jZXMgPSBzdGF0ZVtrZXldXG5cbiAgICAgIGlmICgnbWV0YXMnIGluIHByZXNlbmNlcykge1xuICAgICAgICBuZXdTdGF0ZVtrZXldID0gcHJlc2VuY2VzLm1ldGFzLm1hcCgocHJlc2VuY2UpID0+IHtcbiAgICAgICAgICBwcmVzZW5jZVsncHJlc2VuY2VfcmVmJ10gPSBwcmVzZW5jZVsncGh4X3JlZiddXG5cbiAgICAgICAgICBkZWxldGUgcHJlc2VuY2VbJ3BoeF9yZWYnXVxuICAgICAgICAgIGRlbGV0ZSBwcmVzZW5jZVsncGh4X3JlZl9wcmV2J11cblxuICAgICAgICAgIHJldHVybiBwcmVzZW5jZVxuICAgICAgICB9KSBhcyBQcmVzZW5jZVtdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdTdGF0ZVtrZXldID0gcHJlc2VuY2VzXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdTdGF0ZVxuICAgIH0sIHt9IGFzIFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSlcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgY2xvbmVEZWVwKG9iajogeyBba2V5OiBzdHJpbmddOiBhbnkgfSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgb25Kb2luKGNhbGxiYWNrOiBQcmVzZW5jZU9uSm9pbkNhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5jYWxsZXIub25Kb2luID0gY2FsbGJhY2tcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBvbkxlYXZlKGNhbGxiYWNrOiBQcmVzZW5jZU9uTGVhdmVDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFja1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIG9uU3luYyhjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuY2FsbGVyLm9uU3luYyA9IGNhbGxiYWNrXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgaW5QZW5kaW5nU3luY1N0YXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5qb2luUmVmIHx8IHRoaXMuam9pblJlZiAhPT0gdGhpcy5jaGFubmVsLl9qb2luUmVmKClcbiAgfVxufVxuIiwgImltcG9ydCB7IENIQU5ORUxfRVZFTlRTLCBDSEFOTkVMX1NUQVRFUyB9IGZyb20gJy4vbGliL2NvbnN0YW50cydcbmltcG9ydCBQdXNoIGZyb20gJy4vbGliL3B1c2gnXG5pbXBvcnQgdHlwZSBSZWFsdGltZUNsaWVudCBmcm9tICcuL1JlYWx0aW1lQ2xpZW50J1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vbGliL3RpbWVyJ1xuaW1wb3J0IFJlYWx0aW1lUHJlc2VuY2UsIHtcbiAgUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyxcbn0gZnJvbSAnLi9SZWFsdGltZVByZXNlbmNlJ1xuaW1wb3J0IHR5cGUge1xuICBSZWFsdGltZVByZXNlbmNlSm9pblBheWxvYWQsXG4gIFJlYWx0aW1lUHJlc2VuY2VMZWF2ZVBheWxvYWQsXG4gIFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSxcbn0gZnJvbSAnLi9SZWFsdGltZVByZXNlbmNlJ1xuaW1wb3J0ICogYXMgVHJhbnNmb3JtZXJzIGZyb20gJy4vbGliL3RyYW5zZm9ybWVycydcbmltcG9ydCB7IGh0dHBFbmRwb2ludFVSTCB9IGZyb20gJy4vbGliL3RyYW5zZm9ybWVycydcblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVDaGFubmVsT3B0aW9ucyA9IHtcbiAgY29uZmlnOiB7XG4gICAgLyoqXG4gICAgICogc2VsZiBvcHRpb24gZW5hYmxlcyBjbGllbnQgdG8gcmVjZWl2ZSBtZXNzYWdlIGl0IGJyb2FkY2FzdFxuICAgICAqIGFjayBvcHRpb24gaW5zdHJ1Y3RzIHNlcnZlciB0byBhY2tub3dsZWRnZSB0aGF0IGJyb2FkY2FzdCBtZXNzYWdlIHdhcyByZWNlaXZlZFxuICAgICAqL1xuICAgIGJyb2FkY2FzdD86IHsgc2VsZj86IGJvb2xlYW47IGFjaz86IGJvb2xlYW4gfVxuICAgIC8qKlxuICAgICAqIGtleSBvcHRpb24gaXMgdXNlZCB0byB0cmFjayBwcmVzZW5jZSBwYXlsb2FkIGFjcm9zcyBjbGllbnRzXG4gICAgICovXG4gICAgcHJlc2VuY2U/OiB7IGtleT86IHN0cmluZyB9XG4gICAgLyoqXG4gICAgICogZGVmaW5lcyBpZiB0aGUgY2hhbm5lbCBpcyBwcml2YXRlIG9yIG5vdCBhbmQgaWYgUkxTIHBvbGljaWVzIHdpbGwgYmUgdXNlZCB0byBjaGVjayBkYXRhXG4gICAgICovXG4gICAgcHJpdmF0ZT86IGJvb2xlYW5cbiAgfVxufVxuXG50eXBlIFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZEJhc2UgPSB7XG4gIHNjaGVtYTogc3RyaW5nXG4gIHRhYmxlOiBzdHJpbmdcbiAgY29tbWl0X3RpbWVzdGFtcDogc3RyaW5nXG4gIGVycm9yczogc3RyaW5nW11cbn1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVQb3N0Z3Jlc0luc2VydFBheWxvYWQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+ID1cbiAgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkQmFzZSAmIHtcbiAgICBldmVudFR5cGU6IGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULklOU0VSVH1gXG4gICAgbmV3OiBUXG4gICAgb2xkOiB7fVxuICB9XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUG9zdGdyZXNVcGRhdGVQYXlsb2FkPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PiA9XG4gIFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZEJhc2UgJiB7XG4gICAgZXZlbnRUeXBlOiBgJHtSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVC5VUERBVEV9YFxuICAgIG5ldzogVFxuICAgIG9sZDogUGFydGlhbDxUPlxuICB9XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUG9zdGdyZXNEZWxldGVQYXlsb2FkPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PiA9XG4gIFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZEJhc2UgJiB7XG4gICAgZXZlbnRUeXBlOiBgJHtSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVC5ERUxFVEV9YFxuICAgIG5ldzoge31cbiAgICBvbGQ6IFBhcnRpYWw8VD5cbiAgfVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc1BheWxvYWQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+ID1cbiAgfCBSZWFsdGltZVBvc3RncmVzSW5zZXJ0UGF5bG9hZDxUPlxuICB8IFJlYWx0aW1lUG9zdGdyZXNVcGRhdGVQYXlsb2FkPFQ+XG4gIHwgUmVhbHRpbWVQb3N0Z3Jlc0RlbGV0ZVBheWxvYWQ8VD5cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNGaWx0ZXI8XG4gIFQgZXh0ZW5kcyBgJHtSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVH1gXG4+ID0ge1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZGF0YWJhc2UgY2hhbmdlIHRvIGxpc3RlbiB0by5cbiAgICovXG4gIGV2ZW50OiBUXG4gIC8qKlxuICAgKiBUaGUgZGF0YWJhc2Ugc2NoZW1hIHRvIGxpc3RlbiB0by5cbiAgICovXG4gIHNjaGVtYTogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgZGF0YWJhc2UgdGFibGUgdG8gbGlzdGVuIHRvLlxuICAgKi9cbiAgdGFibGU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFJlY2VpdmUgZGF0YWJhc2UgY2hhbmdlcyB3aGVuIGZpbHRlciBpcyBtYXRjaGVkLlxuICAgKi9cbiAgZmlsdGVyPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lQ2hhbm5lbFNlbmRSZXNwb25zZSA9ICdvaycgfCAndGltZWQgb3V0JyB8ICdlcnJvcidcblxuZXhwb3J0IGVudW0gUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQge1xuICBBTEwgPSAnKicsXG4gIElOU0VSVCA9ICdJTlNFUlQnLFxuICBVUERBVEUgPSAnVVBEQVRFJyxcbiAgREVMRVRFID0gJ0RFTEVURScsXG59XG5cbmV4cG9ydCBlbnVtIFJFQUxUSU1FX0xJU1RFTl9UWVBFUyB7XG4gIEJST0FEQ0FTVCA9ICdicm9hZGNhc3QnLFxuICBQUkVTRU5DRSA9ICdwcmVzZW5jZScsXG4gIFBPU1RHUkVTX0NIQU5HRVMgPSAncG9zdGdyZXNfY2hhbmdlcycsXG4gIFNZU1RFTSA9ICdzeXN0ZW0nLFxufVxuXG5leHBvcnQgZW51bSBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTIHtcbiAgU1VCU0NSSUJFRCA9ICdTVUJTQ1JJQkVEJyxcbiAgVElNRURfT1VUID0gJ1RJTUVEX09VVCcsXG4gIENMT1NFRCA9ICdDTE9TRUQnLFxuICBDSEFOTkVMX0VSUk9SID0gJ0NIQU5ORUxfRVJST1InLFxufVxuXG5leHBvcnQgY29uc3QgUkVBTFRJTUVfQ0hBTk5FTF9TVEFURVMgPSBDSEFOTkVMX1NUQVRFU1xuXG5pbnRlcmZhY2UgUG9zdGdyZXNDaGFuZ2VzRmlsdGVycyB7XG4gIHBvc3RncmVzX2NoYW5nZXM6IHtcbiAgICBpZDogc3RyaW5nXG4gICAgZXZlbnQ6IHN0cmluZ1xuICAgIHNjaGVtYT86IHN0cmluZ1xuICAgIHRhYmxlPzogc3RyaW5nXG4gICAgZmlsdGVyPzogc3RyaW5nXG4gIH1bXVxufVxuLyoqIEEgY2hhbm5lbCBpcyB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2sgb2YgUmVhbHRpbWVcbiAqIGFuZCBuYXJyb3dzIHRoZSBzY29wZSBvZiBkYXRhIGZsb3cgdG8gc3Vic2NyaWJlZCBjbGllbnRzLlxuICogWW91IGNhbiB0aGluayBvZiBhIGNoYW5uZWwgYXMgYSBjaGF0cm9vbSB3aGVyZSBwYXJ0aWNpcGFudHMgYXJlIGFibGUgdG8gc2VlIHdobydzIG9ubGluZVxuICogYW5kIHNlbmQgYW5kIHJlY2VpdmUgbWVzc2FnZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWx0aW1lQ2hhbm5lbCB7XG4gIGJpbmRpbmdzOiB7XG4gICAgW2tleTogc3RyaW5nXToge1xuICAgICAgdHlwZTogc3RyaW5nXG4gICAgICBmaWx0ZXI6IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgICAgIGNhbGxiYWNrOiBGdW5jdGlvblxuICAgICAgaWQ/OiBzdHJpbmdcbiAgICB9W11cbiAgfSA9IHt9XG4gIHRpbWVvdXQ6IG51bWJlclxuICBzdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICBqb2luZWRPbmNlID0gZmFsc2VcbiAgam9pblB1c2g6IFB1c2hcbiAgcmVqb2luVGltZXI6IFRpbWVyXG4gIHB1c2hCdWZmZXI6IFB1c2hbXSA9IFtdXG4gIHByZXNlbmNlOiBSZWFsdGltZVByZXNlbmNlXG4gIGJyb2FkY2FzdEVuZHBvaW50VVJMOiBzdHJpbmdcbiAgc3ViVG9waWM6IHN0cmluZ1xuICBwcml2YXRlOiBib29sZWFuXG5cbiAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRvcGljIG5hbWUgY2FuIGJlIGFueSBzdHJpbmcuICovXG4gICAgcHVibGljIHRvcGljOiBzdHJpbmcsXG4gICAgcHVibGljIHBhcmFtczogUmVhbHRpbWVDaGFubmVsT3B0aW9ucyA9IHsgY29uZmlnOiB7fSB9LFxuICAgIHB1YmxpYyBzb2NrZXQ6IFJlYWx0aW1lQ2xpZW50XG4gICkge1xuICAgIHRoaXMuc3ViVG9waWMgPSB0b3BpYy5yZXBsYWNlKC9ecmVhbHRpbWU6L2ksICcnKVxuICAgIHRoaXMucGFyYW1zLmNvbmZpZyA9IHtcbiAgICAgIC4uLntcbiAgICAgICAgYnJvYWRjYXN0OiB7IGFjazogZmFsc2UsIHNlbGY6IGZhbHNlIH0sXG4gICAgICAgIHByZXNlbmNlOiB7IGtleTogJycgfSxcbiAgICAgICAgcHJpdmF0ZTogZmFsc2UsXG4gICAgICB9LFxuICAgICAgLi4ucGFyYW1zLmNvbmZpZyxcbiAgICB9XG4gICAgdGhpcy50aW1lb3V0ID0gdGhpcy5zb2NrZXQudGltZW91dFxuICAgIHRoaXMuam9pblB1c2ggPSBuZXcgUHVzaChcbiAgICAgIHRoaXMsXG4gICAgICBDSEFOTkVMX0VWRU5UUy5qb2luLFxuICAgICAgdGhpcy5wYXJhbXMsXG4gICAgICB0aGlzLnRpbWVvdXRcbiAgICApXG4gICAgdGhpcy5yZWpvaW5UaW1lciA9IG5ldyBUaW1lcihcbiAgICAgICgpID0+IHRoaXMuX3Jlam9pblVudGlsQ29ubmVjdGVkKCksXG4gICAgICB0aGlzLnNvY2tldC5yZWNvbm5lY3RBZnRlck1zXG4gICAgKVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZSgnb2snLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmVkXG4gICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICAgIHRoaXMucHVzaEJ1ZmZlci5mb3JFYWNoKChwdXNoRXZlbnQ6IFB1c2gpID0+IHB1c2hFdmVudC5zZW5kKCkpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXVxuICAgIH0pXG4gICAgdGhpcy5fb25DbG9zZSgoKSA9PiB7XG4gICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBjbG9zZSAke3RoaXMudG9waWN9ICR7dGhpcy5fam9pblJlZigpfWApXG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkXG4gICAgICB0aGlzLnNvY2tldC5fcmVtb3ZlKHRoaXMpXG4gICAgfSlcbiAgICB0aGlzLl9vbkVycm9yKChyZWFzb246IHN0cmluZykgPT4ge1xuICAgICAgaWYgKHRoaXMuX2lzTGVhdmluZygpIHx8IHRoaXMuX2lzQ2xvc2VkKCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgZXJyb3IgJHt0aGlzLnRvcGljfWAsIHJlYXNvbilcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkXG4gICAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpXG4gICAgfSlcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2lzSm9pbmluZygpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYHRpbWVvdXQgJHt0aGlzLnRvcGljfWAsIHRoaXMuam9pblB1c2gudGltZW91dClcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkXG4gICAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpXG4gICAgfSlcbiAgICB0aGlzLl9vbihDSEFOTkVMX0VWRU5UUy5yZXBseSwge30sIChwYXlsb2FkOiBhbnksIHJlZjogc3RyaW5nKSA9PiB7XG4gICAgICB0aGlzLl90cmlnZ2VyKHRoaXMuX3JlcGx5RXZlbnROYW1lKHJlZiksIHBheWxvYWQpXG4gICAgfSlcblxuICAgIHRoaXMucHJlc2VuY2UgPSBuZXcgUmVhbHRpbWVQcmVzZW5jZSh0aGlzKVxuXG4gICAgdGhpcy5icm9hZGNhc3RFbmRwb2ludFVSTCA9XG4gICAgICBodHRwRW5kcG9pbnRVUkwodGhpcy5zb2NrZXQuZW5kUG9pbnQpICsgJy9hcGkvYnJvYWRjYXN0J1xuICAgIHRoaXMucHJpdmF0ZSA9IHRoaXMucGFyYW1zLmNvbmZpZy5wcml2YXRlIHx8IGZhbHNlXG4gIH1cblxuICAvKiogU3Vic2NyaWJlIHJlZ2lzdGVycyB5b3VyIGNsaWVudCB3aXRoIHRoZSBzZXJ2ZXIgKi9cbiAgc3Vic2NyaWJlKFxuICAgIGNhbGxiYWNrPzogKHN0YXR1czogUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUywgZXJyPzogRXJyb3IpID0+IHZvaWQsXG4gICAgdGltZW91dCA9IHRoaXMudGltZW91dFxuICApOiBSZWFsdGltZUNoYW5uZWwge1xuICAgIGlmICghdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgdGhpcy5zb2NrZXQuY29ubmVjdCgpXG4gICAgfVxuICAgIGlmICh0aGlzLmpvaW5lZE9uY2UpIHtcbiAgICAgIHRocm93IGB0cmllZCB0byBzdWJzY3JpYmUgbXVsdGlwbGUgdGltZXMuICdzdWJzY3JpYmUnIGNhbiBvbmx5IGJlIGNhbGxlZCBhIHNpbmdsZSB0aW1lIHBlciBjaGFubmVsIGluc3RhbmNlYFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbmZpZzogeyBicm9hZGNhc3QsIHByZXNlbmNlLCBwcml2YXRlOiBpc1ByaXZhdGUgfSxcbiAgICAgIH0gPSB0aGlzLnBhcmFtc1xuXG4gICAgICB0aGlzLl9vbkVycm9yKChlOiBFcnJvcikgPT5cbiAgICAgICAgY2FsbGJhY2s/LihSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNIQU5ORUxfRVJST1IsIGUpXG4gICAgICApXG4gICAgICB0aGlzLl9vbkNsb3NlKCgpID0+IGNhbGxiYWNrPy4oUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DTE9TRUQpKVxuXG4gICAgICBjb25zdCBhY2Nlc3NUb2tlblBheWxvYWQ6IHsgYWNjZXNzX3Rva2VuPzogc3RyaW5nIH0gPSB7fVxuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICBicm9hZGNhc3QsXG4gICAgICAgIHByZXNlbmNlLFxuICAgICAgICBwb3N0Z3Jlc19jaGFuZ2VzOlxuICAgICAgICAgIHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcz8ubWFwKChyKSA9PiByLmZpbHRlcikgPz8gW10sXG4gICAgICAgIHByaXZhdGU6IGlzUHJpdmF0ZSxcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWUpIHtcbiAgICAgICAgYWNjZXNzVG9rZW5QYXlsb2FkLmFjY2Vzc190b2tlbiA9IHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWVcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVKb2luUGF5bG9hZCh7IC4uLnsgY29uZmlnIH0sIC4uLmFjY2Vzc1Rva2VuUGF5bG9hZCB9KVxuXG4gICAgICB0aGlzLmpvaW5lZE9uY2UgPSB0cnVlXG4gICAgICB0aGlzLl9yZWpvaW4odGltZW91dClcblxuICAgICAgdGhpcy5qb2luUHVzaFxuICAgICAgICAucmVjZWl2ZSgnb2snLCBhc3luYyAoeyBwb3N0Z3Jlc19jaGFuZ2VzIH06IFBvc3RncmVzQ2hhbmdlc0ZpbHRlcnMpID0+IHtcbiAgICAgICAgICB0aGlzLnNvY2tldC5zZXRBdXRoKClcbiAgICAgICAgICBpZiAocG9zdGdyZXNfY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjaz8uKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuU1VCU0NSSUJFRClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzXG4gICAgICAgICAgICBjb25zdCBiaW5kaW5nc0xlbiA9IGNsaWVudFBvc3RncmVzQmluZGluZ3M/Lmxlbmd0aCA/PyAwXG4gICAgICAgICAgICBjb25zdCBuZXdQb3N0Z3Jlc0JpbmRpbmdzID0gW11cblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5kaW5nc0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNsaWVudFBvc3RncmVzQmluZGluZyA9IGNsaWVudFBvc3RncmVzQmluZGluZ3NbaV1cbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGZpbHRlcjogeyBldmVudCwgc2NoZW1hLCB0YWJsZSwgZmlsdGVyIH0sXG4gICAgICAgICAgICAgIH0gPSBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdcbiAgICAgICAgICAgICAgY29uc3Qgc2VydmVyUG9zdGdyZXNGaWx0ZXIgPVxuICAgICAgICAgICAgICAgIHBvc3RncmVzX2NoYW5nZXMgJiYgcG9zdGdyZXNfY2hhbmdlc1tpXVxuXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlciAmJlxuICAgICAgICAgICAgICAgIHNlcnZlclBvc3RncmVzRmlsdGVyLmV2ZW50ID09PSBldmVudCAmJlxuICAgICAgICAgICAgICAgIHNlcnZlclBvc3RncmVzRmlsdGVyLnNjaGVtYSA9PT0gc2NoZW1hICYmXG4gICAgICAgICAgICAgICAgc2VydmVyUG9zdGdyZXNGaWx0ZXIudGFibGUgPT09IHRhYmxlICYmXG4gICAgICAgICAgICAgICAgc2VydmVyUG9zdGdyZXNGaWx0ZXIuZmlsdGVyID09PSBmaWx0ZXJcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbmV3UG9zdGdyZXNCaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIC4uLmNsaWVudFBvc3RncmVzQmluZGluZyxcbiAgICAgICAgICAgICAgICAgIGlkOiBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5pZCxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrPy4oXG4gICAgICAgICAgICAgICAgICBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNIQU5ORUxfRVJST1IsXG4gICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdtaXNtYXRjaCBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IGJpbmRpbmdzIGZvciBwb3N0Z3JlcyBjaGFuZ2VzJ1xuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXMgPSBuZXdQb3N0Z3Jlc0JpbmRpbmdzXG5cbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuU1VCU0NSSUJFRClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnJlY2VpdmUoJ2Vycm9yJywgKGVycm9yOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2s/LihcbiAgICAgICAgICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0hBTk5FTF9FUlJPUixcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LnZhbHVlcyhlcnJvcikuam9pbignLCAnKSB8fCAnZXJyb3InKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSlcbiAgICAgICAgLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2s/LihSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLlRJTUVEX09VVClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByZXNlbmNlU3RhdGU8XG4gICAgVCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fVxuICA+KCk6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZTxUPiB7XG4gICAgcmV0dXJuIHRoaXMucHJlc2VuY2Uuc3RhdGUgYXMgUmVhbHRpbWVQcmVzZW5jZVN0YXRlPFQ+XG4gIH1cblxuICBhc3luYyB0cmFjayhcbiAgICBwYXlsb2FkOiB7IFtrZXk6IHN0cmluZ106IGFueSB9LFxuICAgIG9wdHM6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fVxuICApOiBQcm9taXNlPFJlYWx0aW1lQ2hhbm5lbFNlbmRSZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmQoXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdwcmVzZW5jZScsXG4gICAgICAgIGV2ZW50OiAndHJhY2snLFxuICAgICAgICBwYXlsb2FkLFxuICAgICAgfSxcbiAgICAgIG9wdHMudGltZW91dCB8fCB0aGlzLnRpbWVvdXRcbiAgICApXG4gIH1cblxuICBhc3luYyB1bnRyYWNrKFxuICAgIG9wdHM6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fVxuICApOiBQcm9taXNlPFJlYWx0aW1lQ2hhbm5lbFNlbmRSZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmQoXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdwcmVzZW5jZScsXG4gICAgICAgIGV2ZW50OiAndW50cmFjaycsXG4gICAgICB9LFxuICAgICAgb3B0c1xuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGV2ZW50IGhhbmRsZXIgdGhhdCBsaXN0ZW5zIHRvIGNoYW5nZXMuXG4gICAqL1xuICBvbihcbiAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuUFJFU0VOQ0V9YCxcbiAgICBmaWx0ZXI6IHsgZXZlbnQ6IGAke1JFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMuU1lOQ31gIH0sXG4gICAgY2FsbGJhY2s6ICgpID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsXG4gIG9uPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PihcbiAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuUFJFU0VOQ0V9YCxcbiAgICBmaWx0ZXI6IHsgZXZlbnQ6IGAke1JFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMuSk9JTn1gIH0sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiBSZWFsdGltZVByZXNlbmNlSm9pblBheWxvYWQ8VD4pID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsXG4gIG9uPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PihcbiAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuUFJFU0VOQ0V9YCxcbiAgICBmaWx0ZXI6IHsgZXZlbnQ6IGAke1JFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMuTEVBVkV9YCB9LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDogUmVhbHRpbWVQcmVzZW5jZUxlYXZlUGF5bG9hZDxUPikgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb248VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QT1NUR1JFU19DSEFOR0VTfWAsXG4gICAgZmlsdGVyOiBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc0ZpbHRlcjxgJHtSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVC5BTEx9YD4sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc1BheWxvYWQ8VD4pID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsXG4gIG9uPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PihcbiAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuUE9TVEdSRVNfQ0hBTkdFU31gLFxuICAgIGZpbHRlcjogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNGaWx0ZXI8YCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuSU5TRVJUfWA+LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDogUmVhbHRpbWVQb3N0Z3Jlc0luc2VydFBheWxvYWQ8VD4pID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsXG4gIG9uPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PihcbiAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuUE9TVEdSRVNfQ0hBTkdFU31gLFxuICAgIGZpbHRlcjogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNGaWx0ZXI8YCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuVVBEQVRFfWA+LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDogUmVhbHRpbWVQb3N0Z3Jlc1VwZGF0ZVBheWxvYWQ8VD4pID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsXG4gIG9uPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PihcbiAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuUE9TVEdSRVNfQ0hBTkdFU31gLFxuICAgIGZpbHRlcjogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNGaWx0ZXI8YCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuREVMRVRFfWA+LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDogUmVhbHRpbWVQb3N0Z3Jlc0RlbGV0ZVBheWxvYWQ8VD4pID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsXG4gIC8qKlxuICAgKiBUaGUgZm9sbG93aW5nIGlzIHBsYWNlZCBoZXJlIHRvIGRpc3BsYXkgb24gc3VwYWJhc2UuY29tL2RvY3MvcmVmZXJlbmNlL2phdmFzY3JpcHQvc3Vic2NyaWJlLlxuICAgKiBAcGFyYW0gdHlwZSBPbmUgb2YgXCJicm9hZGNhc3RcIiwgXCJwcmVzZW5jZVwiLCBvciBcInBvc3RncmVzX2NoYW5nZXNcIi5cbiAgICogQHBhcmFtIGZpbHRlciBDdXN0b20gb2JqZWN0IHNwZWNpZmljIHRvIHRoZSBSZWFsdGltZSBmZWF0dXJlIGRldGFpbGluZyB3aGljaCBwYXlsb2FkcyB0byByZWNlaXZlLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIGV2ZW50IGhhbmRsZXIgaXMgdHJpZ2dlcmVkLlxuICAgKi9cbiAgb24oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLkJST0FEQ0FTVH1gLFxuICAgIGZpbHRlcjogeyBldmVudDogc3RyaW5nIH0sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiB7XG4gICAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuQlJPQURDQVNUfWBcbiAgICAgIGV2ZW50OiBzdHJpbmdcbiAgICAgIFtrZXk6IHN0cmluZ106IGFueVxuICAgIH0pID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsXG4gIG9uPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PihcbiAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuQlJPQURDQVNUfWAsXG4gICAgZmlsdGVyOiB7IGV2ZW50OiBzdHJpbmcgfSxcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IHtcbiAgICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5CUk9BRENBU1R9YFxuICAgICAgZXZlbnQ6IHN0cmluZ1xuICAgICAgcGF5bG9hZDogVFxuICAgIH0pID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsXG4gIG9uPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PihcbiAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuU1lTVEVNfWAsXG4gICAgZmlsdGVyOiB7fSxcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IGFueSkgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb24oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTfWAsXG4gICAgZmlsdGVyOiB7IGV2ZW50OiBzdHJpbmc7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDogYW55KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbCB7XG4gICAgcmV0dXJuIHRoaXMuX29uKHR5cGUsIGZpbHRlciwgY2FsbGJhY2spXG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgbWVzc2FnZSBpbnRvIHRoZSBjaGFubmVsLlxuICAgKlxuICAgKiBAcGFyYW0gYXJncyBBcmd1bWVudHMgdG8gc2VuZCB0byBjaGFubmVsXG4gICAqIEBwYXJhbSBhcmdzLnR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gc2VuZFxuICAgKiBAcGFyYW0gYXJncy5ldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgYmVpbmcgc2VudFxuICAgKiBAcGFyYW0gYXJncy5wYXlsb2FkIFBheWxvYWQgdG8gYmUgc2VudFxuICAgKiBAcGFyYW0gb3B0cyBPcHRpb25zIHRvIGJlIHVzZWQgZHVyaW5nIHRoZSBzZW5kIHByb2Nlc3NcbiAgICovXG4gIGFzeW5jIHNlbmQoXG4gICAgYXJnczoge1xuICAgICAgdHlwZTogJ2Jyb2FkY2FzdCcgfCAncHJlc2VuY2UnIHwgJ3Bvc3RncmVzX2NoYW5nZXMnXG4gICAgICBldmVudDogc3RyaW5nXG4gICAgICBwYXlsb2FkPzogYW55XG4gICAgICBba2V5OiBzdHJpbmddOiBhbnlcbiAgICB9LFxuICAgIG9wdHM6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fVxuICApOiBQcm9taXNlPFJlYWx0aW1lQ2hhbm5lbFNlbmRSZXNwb25zZT4ge1xuICAgIGlmICghdGhpcy5fY2FuUHVzaCgpICYmIGFyZ3MudHlwZSA9PT0gJ2Jyb2FkY2FzdCcpIHtcbiAgICAgIGNvbnN0IHsgZXZlbnQsIHBheWxvYWQ6IGVuZHBvaW50X3BheWxvYWQgfSA9IGFyZ3NcbiAgICAgIGNvbnN0IGF1dGhvcml6YXRpb24gPSB0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlXG4gICAgICAgID8gYEJlYXJlciAke3RoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWV9YFxuICAgICAgICA6ICcnXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEF1dGhvcml6YXRpb246IGF1dGhvcml6YXRpb24sXG4gICAgICAgICAgYXBpa2V5OiB0aGlzLnNvY2tldC5hcGlLZXkgPyB0aGlzLnNvY2tldC5hcGlLZXkgOiAnJyxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdG9waWM6IHRoaXMuc3ViVG9waWMsXG4gICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICBwYXlsb2FkOiBlbmRwb2ludF9wYXlsb2FkLFxuICAgICAgICAgICAgICBwcml2YXRlOiB0aGlzLnByaXZhdGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH0pLFxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ZldGNoV2l0aFRpbWVvdXQoXG4gICAgICAgICAgdGhpcy5icm9hZGNhc3RFbmRwb2ludFVSTCxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIG9wdHMudGltZW91dCA/PyB0aGlzLnRpbWVvdXRcbiAgICAgICAgKVxuXG4gICAgICAgIGF3YWl0IHJlc3BvbnNlLmJvZHk/LmNhbmNlbCgpXG4gICAgICAgIHJldHVybiByZXNwb25zZS5vayA/ICdvaycgOiAnZXJyb3InXG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICByZXR1cm4gJ3RpbWVkIG91dCdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJ2Vycm9yJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCBwdXNoID0gdGhpcy5fcHVzaChhcmdzLnR5cGUsIGFyZ3MsIG9wdHMudGltZW91dCB8fCB0aGlzLnRpbWVvdXQpXG5cbiAgICAgICAgaWYgKGFyZ3MudHlwZSA9PT0gJ2Jyb2FkY2FzdCcgJiYgIXRoaXMucGFyYW1zPy5jb25maWc/LmJyb2FkY2FzdD8uYWNrKSB7XG4gICAgICAgICAgcmVzb2x2ZSgnb2snKVxuICAgICAgICB9XG5cbiAgICAgICAgcHVzaC5yZWNlaXZlKCdvaycsICgpID0+IHJlc29sdmUoJ29rJykpXG4gICAgICAgIHB1c2gucmVjZWl2ZSgnZXJyb3InLCAoKSA9PiByZXNvbHZlKCdlcnJvcicpKVxuICAgICAgICBwdXNoLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiByZXNvbHZlKCd0aW1lZCBvdXQnKSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlSm9pblBheWxvYWQocGF5bG9hZDogeyBba2V5OiBzdHJpbmddOiBhbnkgfSk6IHZvaWQge1xuICAgIHRoaXMuam9pblB1c2gudXBkYXRlUGF5bG9hZChwYXlsb2FkKVxuICB9XG5cbiAgLyoqXG4gICAqIExlYXZlcyB0aGUgY2hhbm5lbC5cbiAgICpcbiAgICogVW5zdWJzY3JpYmVzIGZyb20gc2VydmVyIGV2ZW50cywgYW5kIGluc3RydWN0cyBjaGFubmVsIHRvIHRlcm1pbmF0ZSBvbiBzZXJ2ZXIuXG4gICAqIFRyaWdnZXJzIG9uQ2xvc2UoKSBob29rcy5cbiAgICpcbiAgICogVG8gcmVjZWl2ZSBsZWF2ZSBhY2tub3dsZWRnZW1lbnRzLCB1c2UgdGhlIGEgYHJlY2VpdmVgIGhvb2sgdG8gYmluZCB0byB0aGUgc2VydmVyIGFjaywgaWU6XG4gICAqIGNoYW5uZWwudW5zdWJzY3JpYmUoKS5yZWNlaXZlKFwib2tcIiwgKCkgPT4gYWxlcnQoXCJsZWZ0IVwiKSApXG4gICAqL1xuICB1bnN1YnNjcmliZSh0aW1lb3V0ID0gdGhpcy50aW1lb3V0KTogUHJvbWlzZTwnb2snIHwgJ3RpbWVkIG91dCcgfCAnZXJyb3InPiB7XG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmxlYXZpbmdcbiAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGxlYXZlICR7dGhpcy50b3BpY31gKVxuICAgICAgdGhpcy5fdHJpZ2dlcihDSEFOTkVMX0VWRU5UUy5jbG9zZSwgJ2xlYXZlJywgdGhpcy5fam9pblJlZigpKVxuICAgIH1cblxuICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgIC8vIERlc3Ryb3kgam9pblB1c2ggdG8gYXZvaWQgY29ubmVjdGlvbiB0aW1lb3V0cyBkdXJpbmcgdW5zY3JpcHRpb24gcGhhc2VcbiAgICB0aGlzLmpvaW5QdXNoLmRlc3Ryb3koKVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBsZWF2ZVB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5sZWF2ZSwge30sIHRpbWVvdXQpXG4gICAgICBsZWF2ZVB1c2hcbiAgICAgICAgLnJlY2VpdmUoJ29rJywgKCkgPT4ge1xuICAgICAgICAgIG9uQ2xvc2UoKVxuICAgICAgICAgIHJlc29sdmUoJ29rJylcbiAgICAgICAgfSlcbiAgICAgICAgLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgb25DbG9zZSgpXG4gICAgICAgICAgcmVzb2x2ZSgndGltZWQgb3V0JylcbiAgICAgICAgfSlcbiAgICAgICAgLnJlY2VpdmUoJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoJ2Vycm9yJylcbiAgICAgICAgfSlcblxuICAgICAgbGVhdmVQdXNoLnNlbmQoKVxuICAgICAgaWYgKCF0aGlzLl9jYW5QdXNoKCkpIHtcbiAgICAgICAgbGVhdmVQdXNoLnRyaWdnZXIoJ29rJywge30pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBhc3luYyBfZmV0Y2hXaXRoVGltZW91dChcbiAgICB1cmw6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7IFtrZXk6IHN0cmluZ106IGFueSB9LFxuICAgIHRpbWVvdXQ6IG51bWJlclxuICApIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgY29uc3QgaWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dClcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zb2NrZXQuZmV0Y2godXJsLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICB9KVxuXG4gICAgY2xlYXJUaW1lb3V0KGlkKVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9wdXNoKFxuICAgIGV2ZW50OiBzdHJpbmcsXG4gICAgcGF5bG9hZDogeyBba2V5OiBzdHJpbmddOiBhbnkgfSxcbiAgICB0aW1lb3V0ID0gdGhpcy50aW1lb3V0XG4gICkge1xuICAgIGlmICghdGhpcy5qb2luZWRPbmNlKSB7XG4gICAgICB0aHJvdyBgdHJpZWQgdG8gcHVzaCAnJHtldmVudH0nIHRvICcke3RoaXMudG9waWN9JyBiZWZvcmUgam9pbmluZy4gVXNlIGNoYW5uZWwuc3Vic2NyaWJlKCkgYmVmb3JlIHB1c2hpbmcgZXZlbnRzYFxuICAgIH1cbiAgICBsZXQgcHVzaEV2ZW50ID0gbmV3IFB1c2godGhpcywgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpXG4gICAgaWYgKHRoaXMuX2NhblB1c2goKSkge1xuICAgICAgcHVzaEV2ZW50LnNlbmQoKVxuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoRXZlbnQuc3RhcnRUaW1lb3V0KClcbiAgICAgIHRoaXMucHVzaEJ1ZmZlci5wdXNoKHB1c2hFdmVudClcbiAgICB9XG5cbiAgICByZXR1cm4gcHVzaEV2ZW50XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGFibGUgbWVzc2FnZSBob29rXG4gICAqXG4gICAqIFJlY2VpdmVzIGFsbCBldmVudHMgZm9yIHNwZWNpYWxpemVkIG1lc3NhZ2UgaGFuZGxpbmcgYmVmb3JlIGRpc3BhdGNoaW5nIHRvIHRoZSBjaGFubmVsIGNhbGxiYWNrcy5cbiAgICogTXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX29uTWVzc2FnZShfZXZlbnQ6IHN0cmluZywgcGF5bG9hZDogYW55LCBfcmVmPzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHBheWxvYWRcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2lzTWVtYmVyKHRvcGljOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy50b3BpYyA9PT0gdG9waWNcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2pvaW5SZWYoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5qb2luUHVzaC5yZWZcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RyaWdnZXIodHlwZTogc3RyaW5nLCBwYXlsb2FkPzogYW55LCByZWY/OiBzdHJpbmcpIHtcbiAgICBjb25zdCB0eXBlTG93ZXIgPSB0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKClcbiAgICBjb25zdCB7IGNsb3NlLCBlcnJvciwgbGVhdmUsIGpvaW4gfSA9IENIQU5ORUxfRVZFTlRTXG4gICAgY29uc3QgZXZlbnRzOiBzdHJpbmdbXSA9IFtjbG9zZSwgZXJyb3IsIGxlYXZlLCBqb2luXVxuICAgIGlmIChyZWYgJiYgZXZlbnRzLmluZGV4T2YodHlwZUxvd2VyKSA+PSAwICYmIHJlZiAhPT0gdGhpcy5fam9pblJlZigpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbGV0IGhhbmRsZWRQYXlsb2FkID0gdGhpcy5fb25NZXNzYWdlKHR5cGVMb3dlciwgcGF5bG9hZCwgcmVmKVxuICAgIGlmIChwYXlsb2FkICYmICFoYW5kbGVkUGF5bG9hZCkge1xuICAgICAgdGhyb3cgJ2NoYW5uZWwgb25NZXNzYWdlIGNhbGxiYWNrcyBtdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZCdcbiAgICB9XG5cbiAgICBpZiAoWydpbnNlcnQnLCAndXBkYXRlJywgJ2RlbGV0ZSddLmluY2x1ZGVzKHR5cGVMb3dlcikpIHtcbiAgICAgIHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlc1xuICAgICAgICA/LmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBiaW5kLmZpbHRlcj8uZXZlbnQgPT09ICcqJyB8fFxuICAgICAgICAgICAgYmluZC5maWx0ZXI/LmV2ZW50Py50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSB0eXBlTG93ZXJcbiAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICAgIC5tYXAoKGJpbmQpID0+IGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZikpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXVxuICAgICAgICA/LmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFsnYnJvYWRjYXN0JywgJ3ByZXNlbmNlJywgJ3Bvc3RncmVzX2NoYW5nZXMnXS5pbmNsdWRlcyh0eXBlTG93ZXIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoJ2lkJyBpbiBiaW5kKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGJpbmRJZCA9IGJpbmQuaWRcbiAgICAgICAgICAgICAgY29uc3QgYmluZEV2ZW50ID0gYmluZC5maWx0ZXI/LmV2ZW50XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgYmluZElkICYmXG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pZHM/LmluY2x1ZGVzKGJpbmRJZCkgJiZcbiAgICAgICAgICAgICAgICAoYmluZEV2ZW50ID09PSAnKicgfHxcbiAgICAgICAgICAgICAgICAgIGJpbmRFdmVudD8udG9Mb2NhbGVMb3dlckNhc2UoKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5kYXRhPy50eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGJpbmRFdmVudCA9IGJpbmQ/LmZpbHRlcj8uZXZlbnQ/LnRvTG9jYWxlTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBiaW5kRXZlbnQgPT09ICcqJyB8fFxuICAgICAgICAgICAgICAgIGJpbmRFdmVudCA9PT0gcGF5bG9hZD8uZXZlbnQ/LnRvTG9jYWxlTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZC50eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IHR5cGVMb3dlclxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm1hcCgoYmluZCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlZFBheWxvYWQgPT09ICdvYmplY3QnICYmICdpZHMnIGluIGhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICAgICAgICBjb25zdCBwb3N0Z3Jlc0NoYW5nZXMgPSBoYW5kbGVkUGF5bG9hZC5kYXRhXG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYSwgdGFibGUsIGNvbW1pdF90aW1lc3RhbXAsIHR5cGUsIGVycm9ycyB9ID1cbiAgICAgICAgICAgICAgcG9zdGdyZXNDaGFuZ2VzXG4gICAgICAgICAgICBjb25zdCBlbnJpY2hlZFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLFxuICAgICAgICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgICAgICAgIGNvbW1pdF90aW1lc3RhbXA6IGNvbW1pdF90aW1lc3RhbXAsXG4gICAgICAgICAgICAgIGV2ZW50VHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgbmV3OiB7fSxcbiAgICAgICAgICAgICAgb2xkOiB7fSxcbiAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVkUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgLi4uZW5yaWNoZWRQYXlsb2FkLFxuICAgICAgICAgICAgICAuLi50aGlzLl9nZXRQYXlsb2FkUmVjb3Jkcyhwb3N0Z3Jlc0NoYW5nZXMpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBiaW5kLmNhbGxiYWNrKGhhbmRsZWRQYXlsb2FkLCByZWYpXG4gICAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaXNDbG9zZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaXNKb2luZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5lZFxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaXNKb2luaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9pc0xlYXZpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmxlYXZpbmdcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3JlcGx5RXZlbnROYW1lKHJlZjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYGNoYW5fcmVwbHlfJHtyZWZ9YFxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfb24odHlwZTogc3RyaW5nLCBmaWx0ZXI6IHsgW2tleTogc3RyaW5nXTogYW55IH0sIGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKVxuXG4gICAgY29uc3QgYmluZGluZyA9IHtcbiAgICAgIHR5cGU6IHR5cGVMb3dlcixcbiAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIH1cblxuICAgIGlmICh0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0pIHtcbiAgICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXS5wdXNoKGJpbmRpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSA9IFtiaW5kaW5nXVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9vZmYodHlwZTogc3RyaW5nLCBmaWx0ZXI6IHsgW2tleTogc3RyaW5nXTogYW55IH0pIHtcbiAgICBjb25zdCB0eXBlTG93ZXIgPSB0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKClcblxuICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSA9IHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXS5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgIHJldHVybiAhKFxuICAgICAgICBiaW5kLnR5cGU/LnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IHR5cGVMb3dlciAmJlxuICAgICAgICBSZWFsdGltZUNoYW5uZWwuaXNFcXVhbChiaW5kLmZpbHRlciwgZmlsdGVyKVxuICAgICAgKVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgaXNFcXVhbChcbiAgICBvYmoxOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LFxuICAgIG9iajI6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGsgaW4gb2JqMSkge1xuICAgICAgaWYgKG9iajFba10gIT09IG9iajJba10pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfcmVqb2luVW50aWxDb25uZWN0ZWQoKSB7XG4gICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKVxuICAgIGlmICh0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICB0aGlzLl9yZWpvaW4oKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2hhbm5lbCBjbG9zZXMuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBfb25DbG9zZShjYWxsYmFjazogRnVuY3Rpb24pIHtcbiAgICB0aGlzLl9vbihDSEFOTkVMX0VWRU5UUy5jbG9zZSwge30sIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjaGFubmVsIGVuY291bnRlcmVzIGFuIGVycm9yLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgX29uRXJyb3IoY2FsbGJhY2s6IEZ1bmN0aW9uKSB7XG4gICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIHt9LCAocmVhc29uOiBzdHJpbmcpID0+IGNhbGxiYWNrKHJlYXNvbikpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQgYW5kIHRoZSBjaGFubmVsIGhhcyBiZWVuIGpvaW5lZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIF9jYW5QdXNoKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuX2lzSm9pbmVkKClcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfcmVqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5faXNMZWF2aW5nKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLnNvY2tldC5fbGVhdmVPcGVuVG9waWModGhpcy50b3BpYylcbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmluZ1xuICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX2dldFBheWxvYWRSZWNvcmRzKHBheWxvYWQ6IGFueSkge1xuICAgIGNvbnN0IHJlY29yZHMgPSB7XG4gICAgICBuZXc6IHt9LFxuICAgICAgb2xkOiB7fSxcbiAgICB9XG5cbiAgICBpZiAocGF5bG9hZC50eXBlID09PSAnSU5TRVJUJyB8fCBwYXlsb2FkLnR5cGUgPT09ICdVUERBVEUnKSB7XG4gICAgICByZWNvcmRzLm5ldyA9IFRyYW5zZm9ybWVycy5jb252ZXJ0Q2hhbmdlRGF0YShcbiAgICAgICAgcGF5bG9hZC5jb2x1bW5zLFxuICAgICAgICBwYXlsb2FkLnJlY29yZFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChwYXlsb2FkLnR5cGUgPT09ICdVUERBVEUnIHx8IHBheWxvYWQudHlwZSA9PT0gJ0RFTEVURScpIHtcbiAgICAgIHJlY29yZHMub2xkID0gVHJhbnNmb3JtZXJzLmNvbnZlcnRDaGFuZ2VEYXRhKFxuICAgICAgICBwYXlsb2FkLmNvbHVtbnMsXG4gICAgICAgIHBheWxvYWQub2xkX3JlY29yZFxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiByZWNvcmRzXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IFdlYlNvY2tldCBhcyBXU1dlYlNvY2tldCB9IGZyb20gJ3dzJ1xuXG5pbXBvcnQge1xuICBDSEFOTkVMX0VWRU5UUyxcbiAgQ09OTkVDVElPTl9TVEFURSxcbiAgREVGQVVMVF9IRUFERVJTLFxuICBERUZBVUxUX1RJTUVPVVQsXG4gIFNPQ0tFVF9TVEFURVMsXG4gIFRSQU5TUE9SVFMsXG4gIFZTTixcbiAgV1NfQ0xPU0VfTk9STUFMLFxufSBmcm9tICcuL2xpYi9jb25zdGFudHMnXG5pbXBvcnQgU2VyaWFsaXplciBmcm9tICcuL2xpYi9zZXJpYWxpemVyJ1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vbGliL3RpbWVyJ1xuXG5pbXBvcnQgeyBodHRwRW5kcG9pbnRVUkwgfSBmcm9tICcuL2xpYi90cmFuc2Zvcm1lcnMnXG5pbXBvcnQgUmVhbHRpbWVDaGFubmVsIGZyb20gJy4vUmVhbHRpbWVDaGFubmVsJ1xuaW1wb3J0IHR5cGUgeyBSZWFsdGltZUNoYW5uZWxPcHRpb25zIH0gZnJvbSAnLi9SZWFsdGltZUNoYW5uZWwnXG5cbnR5cGUgRmV0Y2ggPSB0eXBlb2YgZmV0Y2hcblxuZXhwb3J0IHR5cGUgQ2hhbm5lbCA9IHtcbiAgbmFtZTogc3RyaW5nXG4gIGluc2VydGVkX2F0OiBzdHJpbmdcbiAgdXBkYXRlZF9hdDogc3RyaW5nXG4gIGlkOiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVDbGllbnRPcHRpb25zID0ge1xuICB0cmFuc3BvcnQ/OiBXZWJTb2NrZXRMaWtlQ29uc3RydWN0b3JcbiAgdGltZW91dD86IG51bWJlclxuICBoZWFydGJlYXRJbnRlcnZhbE1zPzogbnVtYmVyXG4gIGxvZ2dlcj86IEZ1bmN0aW9uXG4gIGVuY29kZT86IEZ1bmN0aW9uXG4gIGRlY29kZT86IEZ1bmN0aW9uXG4gIHJlY29ubmVjdEFmdGVyTXM/OiBGdW5jdGlvblxuICBoZWFkZXJzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxuICBwYXJhbXM/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIGxvZ19sZXZlbD86ICdpbmZvJyB8ICdkZWJ1ZycgfCAnd2FybicgfCAnZXJyb3InXG4gIGZldGNoPzogRmV0Y2hcbiAgd29ya2VyPzogYm9vbGVhblxuICB3b3JrZXJVcmw/OiBzdHJpbmdcbiAgYWNjZXNzVG9rZW4/OiAoKSA9PiBQcm9taXNlPHN0cmluZyB8IG51bGw+XG59XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lTWVzc2FnZSA9IHtcbiAgdG9waWM6IHN0cmluZ1xuICBldmVudDogc3RyaW5nXG4gIHBheWxvYWQ6IGFueVxuICByZWY6IHN0cmluZ1xuICBqb2luX3JlZj86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVJlbW92ZUNoYW5uZWxSZXNwb25zZSA9ICdvaycgfCAndGltZWQgb3V0JyB8ICdlcnJvcidcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2ViU29ja2V0TGlrZUNvbnN0cnVjdG9yIHtcbiAgbmV3IChcbiAgICBhZGRyZXNzOiBzdHJpbmcgfCBVUkwsXG4gICAgX2lnbm9yZWQ/OiBhbnksXG4gICAgb3B0aW9ucz86IHsgaGVhZGVyczogT2JqZWN0IHwgdW5kZWZpbmVkIH1cbiAgKTogV2ViU29ja2V0TGlrZVxufVxuXG5leHBvcnQgdHlwZSBXZWJTb2NrZXRMaWtlID0gV2ViU29ja2V0IHwgV1NXZWJTb2NrZXQgfCBXU1dlYlNvY2tldER1bW15XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2ViU29ja2V0TGlrZUVycm9yIHtcbiAgZXJyb3I6IGFueVxuICBtZXNzYWdlOiBzdHJpbmdcbiAgdHlwZTogc3RyaW5nXG59XG5cbmNvbnN0IE5BVElWRV9XRUJTT0NLRVRfQVZBSUxBQkxFID0gdHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCdcbmNvbnN0IFdPUktFUl9TQ1JJUFQgPSBgXG4gIGFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChlKSA9PiB7XG4gICAgaWYgKGUuZGF0YS5ldmVudCA9PT0gXCJzdGFydFwiKSB7XG4gICAgICBzZXRJbnRlcnZhbCgoKSA9PiBwb3N0TWVzc2FnZSh7IGV2ZW50OiBcImtlZXBBbGl2ZVwiIH0pLCBlLmRhdGEuaW50ZXJ2YWwpO1xuICAgIH1cbiAgfSk7YFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhbHRpbWVDbGllbnQge1xuICBhY2Nlc3NUb2tlblZhbHVlOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICBhcGlLZXk6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gIGNoYW5uZWxzOiBSZWFsdGltZUNoYW5uZWxbXSA9IFtdXG4gIGVuZFBvaW50OiBzdHJpbmcgPSAnJ1xuICBodHRwRW5kcG9pbnQ6IHN0cmluZyA9ICcnXG4gIGhlYWRlcnM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0gREVGQVVMVF9IRUFERVJTXG4gIHBhcmFtcz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fVxuICB0aW1lb3V0OiBudW1iZXIgPSBERUZBVUxUX1RJTUVPVVRcbiAgdHJhbnNwb3J0OiBXZWJTb2NrZXRMaWtlQ29uc3RydWN0b3IgfCBudWxsXG4gIGhlYXJ0YmVhdEludGVydmFsTXM6IG51bWJlciA9IDMwMDAwXG4gIGhlYXJ0YmVhdFRpbWVyOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRJbnRlcnZhbD4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgcGVuZGluZ0hlYXJ0YmVhdFJlZjogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgcmVmOiBudW1iZXIgPSAwXG4gIHJlY29ubmVjdFRpbWVyOiBUaW1lclxuICBsb2dnZXI6IEZ1bmN0aW9uID0gbm9vcFxuICBlbmNvZGU6IEZ1bmN0aW9uXG4gIGRlY29kZTogRnVuY3Rpb25cbiAgcmVjb25uZWN0QWZ0ZXJNczogRnVuY3Rpb25cbiAgY29ubjogV2ViU29ja2V0TGlrZSB8IG51bGwgPSBudWxsXG4gIHNlbmRCdWZmZXI6IEZ1bmN0aW9uW10gPSBbXVxuICBzZXJpYWxpemVyOiBTZXJpYWxpemVyID0gbmV3IFNlcmlhbGl6ZXIoKVxuICBzdGF0ZUNoYW5nZUNhbGxiYWNrczoge1xuICAgIG9wZW46IEZ1bmN0aW9uW11cbiAgICBjbG9zZTogRnVuY3Rpb25bXVxuICAgIGVycm9yOiBGdW5jdGlvbltdXG4gICAgbWVzc2FnZTogRnVuY3Rpb25bXVxuICB9ID0ge1xuICAgIG9wZW46IFtdLFxuICAgIGNsb3NlOiBbXSxcbiAgICBlcnJvcjogW10sXG4gICAgbWVzc2FnZTogW10sXG4gIH1cbiAgZmV0Y2g6IEZldGNoXG4gIGFjY2Vzc1Rva2VuOiAoKCkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsPikgfCBudWxsID0gbnVsbFxuICB3b3JrZXI/OiBib29sZWFuXG4gIHdvcmtlclVybD86IHN0cmluZ1xuICB3b3JrZXJSZWY/OiBXb3JrZXJcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIFNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIGVuZFBvaW50IFRoZSBzdHJpbmcgV2ViU29ja2V0IGVuZHBvaW50LCBpZSwgXCJ3czovL2V4YW1wbGUuY29tL3NvY2tldFwiLCBcIndzczovL2V4YW1wbGUuY29tXCIsIFwiL3NvY2tldFwiIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICAgKiBAcGFyYW0gaHR0cEVuZHBvaW50IFRoZSBzdHJpbmcgSFRUUCBlbmRwb2ludCwgaWUsIFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiLCBcIi9cIiAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNwb3J0IFRoZSBXZWJzb2NrZXQgVHJhbnNwb3J0LCBmb3IgZXhhbXBsZSBXZWJTb2NrZXQuXG4gICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXQgVGhlIGRlZmF1bHQgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gdHJpZ2dlciBwdXNoIHRpbWVvdXRzLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5wYXJhbXMgVGhlIG9wdGlvbmFsIHBhcmFtcyB0byBwYXNzIHdoZW4gY29ubmVjdGluZy5cbiAgICogQHBhcmFtIG9wdGlvbnMuaGVhZGVycyBUaGUgb3B0aW9uYWwgaGVhZGVycyB0byBwYXNzIHdoZW4gY29ubmVjdGluZy5cbiAgICogQHBhcmFtIG9wdGlvbnMuaGVhcnRiZWF0SW50ZXJ2YWxNcyBUaGUgbWlsbGlzZWMgaW50ZXJ2YWwgdG8gc2VuZCBhIGhlYXJ0YmVhdCBtZXNzYWdlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5sb2dnZXIgVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLCBpZTogbG9nZ2VyOiAoa2luZCwgbXNnLCBkYXRhKSA9PiB7IGNvbnNvbGUubG9nKGAke2tpbmR9OiAke21zZ31gLCBkYXRhKSB9XG4gICAqIEBwYXJhbSBvcHRpb25zLmVuY29kZSBUaGUgZnVuY3Rpb24gdG8gZW5jb2RlIG91dGdvaW5nIG1lc3NhZ2VzLiBEZWZhdWx0cyB0byBKU09OOiAocGF5bG9hZCwgY2FsbGJhY2spID0+IGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKVxuICAgKiBAcGFyYW0gb3B0aW9ucy5kZWNvZGUgVGhlIGZ1bmN0aW9uIHRvIGRlY29kZSBpbmNvbWluZyBtZXNzYWdlcy4gRGVmYXVsdHMgdG8gU2VyaWFsaXplcidzIGRlY29kZS5cbiAgICogQHBhcmFtIG9wdGlvbnMucmVjb25uZWN0QWZ0ZXJNcyBoZSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG1pbGxzZWMgcmVjb25uZWN0IGludGVydmFsLiBEZWZhdWx0cyB0byBzdGVwcGVkIGJhY2tvZmYgb2ZmLlxuICAgKiBAcGFyYW0gb3B0aW9ucy53b3JrZXIgVXNlIFdlYiBXb3JrZXIgdG8gc2V0IGEgc2lkZSBmbG93LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICogQHBhcmFtIG9wdGlvbnMud29ya2VyVXJsIFRoZSBVUkwgb2YgdGhlIHdvcmtlciBzY3JpcHQuIERlZmF1bHRzIHRvIGh0dHBzOi8vcmVhbHRpbWUuc3VwYWJhc2UuY29tL3dvcmtlci5qcyB0aGF0IGluY2x1ZGVzIGEgaGVhcnRiZWF0IGV2ZW50IGNhbGwgdG8ga2VlcCB0aGUgY29ubmVjdGlvbiBhbGl2ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVuZFBvaW50OiBzdHJpbmcsIG9wdGlvbnM/OiBSZWFsdGltZUNsaWVudE9wdGlvbnMpIHtcbiAgICB0aGlzLmVuZFBvaW50ID0gYCR7ZW5kUG9pbnR9LyR7VFJBTlNQT1JUUy53ZWJzb2NrZXR9YFxuICAgIHRoaXMuaHR0cEVuZHBvaW50ID0gaHR0cEVuZHBvaW50VVJMKGVuZFBvaW50KVxuICAgIGlmIChvcHRpb25zPy50cmFuc3BvcnQpIHtcbiAgICAgIHRoaXMudHJhbnNwb3J0ID0gb3B0aW9ucy50cmFuc3BvcnRcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc3BvcnQgPSBudWxsXG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5wYXJhbXMpIHRoaXMucGFyYW1zID0gb3B0aW9ucy5wYXJhbXNcbiAgICBpZiAob3B0aW9ucz8uaGVhZGVycykgdGhpcy5oZWFkZXJzID0geyAuLi50aGlzLmhlYWRlcnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9XG4gICAgaWYgKG9wdGlvbnM/LnRpbWVvdXQpIHRoaXMudGltZW91dCA9IG9wdGlvbnMudGltZW91dFxuICAgIGlmIChvcHRpb25zPy5sb2dnZXIpIHRoaXMubG9nZ2VyID0gb3B0aW9ucy5sb2dnZXJcbiAgICBpZiAob3B0aW9ucz8uaGVhcnRiZWF0SW50ZXJ2YWxNcylcbiAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9IG9wdGlvbnMuaGVhcnRiZWF0SW50ZXJ2YWxNc1xuXG4gICAgY29uc3QgYWNjZXNzVG9rZW5WYWx1ZSA9IG9wdGlvbnM/LnBhcmFtcz8uYXBpa2V5XG4gICAgaWYgKGFjY2Vzc1Rva2VuVmFsdWUpIHtcbiAgICAgIHRoaXMuYWNjZXNzVG9rZW5WYWx1ZSA9IGFjY2Vzc1Rva2VuVmFsdWVcbiAgICAgIHRoaXMuYXBpS2V5ID0gYWNjZXNzVG9rZW5WYWx1ZVxuICAgIH1cblxuICAgIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyA9IG9wdGlvbnM/LnJlY29ubmVjdEFmdGVyTXNcbiAgICAgID8gb3B0aW9ucy5yZWNvbm5lY3RBZnRlck1zXG4gICAgICA6ICh0cmllczogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFsxMDAwLCAyMDAwLCA1MDAwLCAxMDAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICAgICAgICB9XG4gICAgdGhpcy5lbmNvZGUgPSBvcHRpb25zPy5lbmNvZGVcbiAgICAgID8gb3B0aW9ucy5lbmNvZGVcbiAgICAgIDogKHBheWxvYWQ6IEpTT04sIGNhbGxiYWNrOiBGdW5jdGlvbikgPT4ge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSlcbiAgICAgICAgfVxuICAgIHRoaXMuZGVjb2RlID0gb3B0aW9ucz8uZGVjb2RlXG4gICAgICA/IG9wdGlvbnMuZGVjb2RlXG4gICAgICA6IHRoaXMuc2VyaWFsaXplci5kZWNvZGUuYmluZCh0aGlzLnNlcmlhbGl6ZXIpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcihhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgICAgdGhpcy5jb25uZWN0KClcbiAgICB9LCB0aGlzLnJlY29ubmVjdEFmdGVyTXMpXG5cbiAgICB0aGlzLmZldGNoID0gdGhpcy5fcmVzb2x2ZUZldGNoKG9wdGlvbnM/LmZldGNoKVxuICAgIGlmIChvcHRpb25zPy53b3JrZXIpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93Lldvcmtlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYiBXb3JrZXIgaXMgbm90IHN1cHBvcnRlZCcpXG4gICAgICB9XG4gICAgICB0aGlzLndvcmtlciA9IG9wdGlvbnM/LndvcmtlciB8fCBmYWxzZVxuICAgICAgdGhpcy53b3JrZXJVcmwgPSBvcHRpb25zPy53b3JrZXJVcmxcbiAgICB9XG4gICAgdGhpcy5hY2Nlc3NUb2tlbiA9IG9wdGlvbnM/LmFjY2Vzc1Rva2VuIHx8IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0aGUgc29ja2V0LCB1bmxlc3MgYWxyZWFkeSBjb25uZWN0ZWQuXG4gICAqL1xuICBjb25uZWN0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgdGhpcy5jb25uID0gbmV3IHRoaXMudHJhbnNwb3J0KHRoaXMuZW5kcG9pbnRVUkwoKSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoTkFUSVZFX1dFQlNPQ0tFVF9BVkFJTEFCTEUpIHtcbiAgICAgIHRoaXMuY29ubiA9IG5ldyBXZWJTb2NrZXQodGhpcy5lbmRwb2ludFVSTCgpKVxuICAgICAgdGhpcy5zZXR1cENvbm5lY3Rpb24oKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jb25uID0gbmV3IFdTV2ViU29ja2V0RHVtbXkodGhpcy5lbmRwb2ludFVSTCgpLCB1bmRlZmluZWQsIHtcbiAgICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuY29ubiA9IG51bGxcbiAgICAgIH0sXG4gICAgfSlcblxuICAgIGltcG9ydCgnd3MnKS50aGVuKCh7IGRlZmF1bHQ6IFdTIH0pID0+IHtcbiAgICAgIHRoaXMuY29ubiA9IG5ldyBXUyh0aGlzLmVuZHBvaW50VVJMKCksIHVuZGVmaW5lZCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICB9KVxuICAgICAgdGhpcy5zZXR1cENvbm5lY3Rpb24oKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVVJMIG9mIHRoZSB3ZWJzb2NrZXQuXG4gICAqIEByZXR1cm5zIHN0cmluZyBUaGUgVVJMIG9mIHRoZSB3ZWJzb2NrZXQuXG4gICAqL1xuICBlbmRwb2ludFVSTCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9hcHBlbmRQYXJhbXMoXG4gICAgICB0aGlzLmVuZFBvaW50LFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXJhbXMsIHsgdnNuOiBWU04gfSlcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogRGlzY29ubmVjdHMgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIGNvZGUgQSBudW1lcmljIHN0YXR1cyBjb2RlIHRvIHNlbmQgb24gZGlzY29ubmVjdC5cbiAgICogQHBhcmFtIHJlYXNvbiBBIGN1c3RvbSByZWFzb24gZm9yIHRoZSBkaXNjb25uZWN0LlxuICAgKi9cbiAgZGlzY29ubmVjdChjb2RlPzogbnVtYmVyLCByZWFzb24/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IGZ1bmN0aW9uICgpIHt9IC8vIG5vb3BcbiAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgIHRoaXMuY29ubi5jbG9zZShjb2RlLCByZWFzb24gPz8gJycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKVxuICAgICAgfVxuICAgICAgdGhpcy5jb25uID0gbnVsbFxuICAgICAgLy8gcmVtb3ZlIG9wZW4gaGFuZGxlc1xuICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciAmJiBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgY3JlYXRlZCBjaGFubmVsc1xuICAgKi9cbiAgZ2V0Q2hhbm5lbHMoKTogUmVhbHRpbWVDaGFubmVsW10ge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWxzXG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIGEgc2luZ2xlIGNoYW5uZWxcbiAgICogQHBhcmFtIGNoYW5uZWwgQSBSZWFsdGltZUNoYW5uZWwgaW5zdGFuY2VcbiAgICovXG4gIGFzeW5jIHJlbW92ZUNoYW5uZWwoXG4gICAgY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsXG4gICk6IFByb21pc2U8UmVhbHRpbWVSZW1vdmVDaGFubmVsUmVzcG9uc2U+IHtcbiAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCBjaGFubmVsLnVuc3Vic2NyaWJlKClcbiAgICBpZiAodGhpcy5jaGFubmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgfVxuICAgIHJldHVybiBzdGF0dXNcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgYWxsIGNoYW5uZWxzXG4gICAqL1xuICBhc3luYyByZW1vdmVBbGxDaGFubmVscygpOiBQcm9taXNlPFJlYWx0aW1lUmVtb3ZlQ2hhbm5lbFJlc3BvbnNlW10+IHtcbiAgICBjb25zdCB2YWx1ZXNfMSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5jaGFubmVscy5tYXAoKGNoYW5uZWwpID0+IGNoYW5uZWwudW5zdWJzY3JpYmUoKSlcbiAgICApXG4gICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICByZXR1cm4gdmFsdWVzXzFcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIHRoZSBtZXNzYWdlLlxuICAgKlxuICAgKiBGb3IgY3VzdG9taXplZCBsb2dnaW5nLCBgdGhpcy5sb2dnZXJgIGNhbiBiZSBvdmVycmlkZGVuLlxuICAgKi9cbiAgbG9nKGtpbmQ6IHN0cmluZywgbXNnOiBzdHJpbmcsIGRhdGE/OiBhbnkpIHtcbiAgICB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc29ja2V0LlxuICAgKi9cbiAgY29ubmVjdGlvblN0YXRlKCk6IENPTk5FQ1RJT05fU1RBVEUge1xuICAgIHN3aXRjaCAodGhpcy5jb25uICYmIHRoaXMuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzpcbiAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuQ29ubmVjdGluZ1xuICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLm9wZW46XG4gICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLk9wZW5cbiAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jbG9zaW5nOlxuICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5DbG9zaW5nXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5DbG9zZWRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaXMgdGhlIGNvbm5lY3Rpb24gaXMgb3Blbi5cbiAgICovXG4gIGlzQ29ubmVjdGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25TdGF0ZSgpID09PSBDT05ORUNUSU9OX1NUQVRFLk9wZW5cbiAgfVxuXG4gIGNoYW5uZWwoXG4gICAgdG9waWM6IHN0cmluZyxcbiAgICBwYXJhbXM6IFJlYWx0aW1lQ2hhbm5lbE9wdGlvbnMgPSB7IGNvbmZpZzoge30gfVxuICApOiBSZWFsdGltZUNoYW5uZWwge1xuICAgIGNvbnN0IGNoYW4gPSBuZXcgUmVhbHRpbWVDaGFubmVsKGByZWFsdGltZToke3RvcGljfWAsIHBhcmFtcywgdGhpcylcbiAgICB0aGlzLmNoYW5uZWxzLnB1c2goY2hhbilcbiAgICByZXR1cm4gY2hhblxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggb3V0IGEgbWVzc2FnZSBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZC5cbiAgICpcbiAgICogSWYgdGhlIHNvY2tldCBpcyBub3QgY29ubmVjdGVkLCB0aGUgbWVzc2FnZSBnZXRzIGVucXVldWVkIHdpdGhpbiBhIGxvY2FsIGJ1ZmZlciwgYW5kIHNlbnQgb3V0IHdoZW4gYSBjb25uZWN0aW9uIGlzIG5leHQgZXN0YWJsaXNoZWQuXG4gICAqL1xuICBwdXNoKGRhdGE6IFJlYWx0aW1lTWVzc2FnZSk6IHZvaWQge1xuICAgIGNvbnN0IHsgdG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYgfSA9IGRhdGFcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHRoaXMuZW5jb2RlKGRhdGEsIChyZXN1bHQ6IGFueSkgPT4ge1xuICAgICAgICB0aGlzLmNvbm4/LnNlbmQocmVzdWx0KVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy5sb2coJ3B1c2gnLCBgJHt0b3BpY30gJHtldmVudH0gKCR7cmVmfSlgLCBwYXlsb2FkKVxuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2goY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIEpXVCBhY2Nlc3MgdG9rZW4gdXNlZCBmb3IgY2hhbm5lbCBzdWJzY3JpcHRpb24gYXV0aG9yaXphdGlvbiBhbmQgUmVhbHRpbWUgUkxTLlxuICAgKlxuICAgKiBJZiBwYXJhbSBpcyBudWxsIGl0IHdpbGwgdXNlIHRoZSBgYWNjZXNzVG9rZW5gIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIHRoZSB0b2tlbiBzZXQgb24gdGhlIGNsaWVudC5cbiAgICpcbiAgICogT24gY2FsbGJhY2sgdXNlZCwgaXQgd2lsbCBzZXQgdGhlIHZhbHVlIG9mIHRoZSB0b2tlbiBpbnRlcm5hbCB0byB0aGUgY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0gdG9rZW4gQSBKV1Qgc3RyaW5nIHRvIG92ZXJyaWRlIHRoZSB0b2tlbiBzZXQgb24gdGhlIGNsaWVudC5cbiAgICovXG4gIGFzeW5jIHNldEF1dGgodG9rZW46IHN0cmluZyB8IG51bGwgPSBudWxsKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbGV0IHRva2VuVG9TZW5kID1cbiAgICAgIHRva2VuIHx8XG4gICAgICAodGhpcy5hY2Nlc3NUb2tlbiAmJiAoYXdhaXQgdGhpcy5hY2Nlc3NUb2tlbigpKSkgfHxcbiAgICAgIHRoaXMuYWNjZXNzVG9rZW5WYWx1ZVxuXG4gICAgaWYgKHRva2VuVG9TZW5kKSB7XG4gICAgICBsZXQgcGFyc2VkID0gbnVsbFxuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShhdG9iKHRva2VuVG9TZW5kLnNwbGl0KCcuJylbMV0pKVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgaWYgKHBhcnNlZCAmJiBwYXJzZWQuZXhwKSB7XG4gICAgICAgIGxldCBub3cgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKVxuICAgICAgICBsZXQgdmFsaWQgPSBub3cgLSBwYXJzZWQuZXhwIDwgMFxuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgICAnYXV0aCcsXG4gICAgICAgICAgICBgSW52YWxpZEpXVFRva2VuOiBJbnZhbGlkIHZhbHVlIGZvciBKV1QgY2xhaW0gXCJleHBcIiB3aXRoIHZhbHVlICR7cGFyc2VkLmV4cH1gXG4gICAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgIGBJbnZhbGlkSldUVG9rZW46IEludmFsaWQgdmFsdWUgZm9yIEpXVCBjbGFpbSBcImV4cFwiIHdpdGggdmFsdWUgJHtwYXJzZWQuZXhwfWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hY2Nlc3NUb2tlblZhbHVlID0gdG9rZW5Ub1NlbmRcbiAgICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbCkgPT4ge1xuICAgICAgICB0b2tlblRvU2VuZCAmJiBjaGFubmVsLnVwZGF0ZUpvaW5QYXlsb2FkKHsgYWNjZXNzX3Rva2VuOiB0b2tlblRvU2VuZCB9KVxuXG4gICAgICAgIGlmIChjaGFubmVsLmpvaW5lZE9uY2UgJiYgY2hhbm5lbC5faXNKb2luZWQoKSkge1xuICAgICAgICAgIGNoYW5uZWwuX3B1c2goQ0hBTk5FTF9FVkVOVFMuYWNjZXNzX3Rva2VuLCB7XG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHRva2VuVG9TZW5kLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIGhlYXJ0YmVhdCBtZXNzYWdlIGlmIHRoZSBzb2NrZXQgaXMgY29ubmVjdGVkLlxuICAgKi9cbiAgYXN5bmMgc2VuZEhlYXJ0YmVhdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpIHtcbiAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICAgIHRoaXMubG9nKFxuICAgICAgICAndHJhbnNwb3J0JyxcbiAgICAgICAgJ2hlYXJ0YmVhdCB0aW1lb3V0LiBBdHRlbXB0aW5nIHRvIHJlLWVzdGFibGlzaCBjb25uZWN0aW9uJ1xuICAgICAgKVxuICAgICAgdGhpcy5jb25uPy5jbG9zZShXU19DTE9TRV9OT1JNQUwsICdoZWFyYmVhdCB0aW1lb3V0JylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSB0aGlzLl9tYWtlUmVmKClcbiAgICB0aGlzLnB1c2goe1xuICAgICAgdG9waWM6ICdwaG9lbml4JyxcbiAgICAgIGV2ZW50OiAnaGVhcnRiZWF0JyxcbiAgICAgIHBheWxvYWQ6IHt9LFxuICAgICAgcmVmOiB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYsXG4gICAgfSlcbiAgICB0aGlzLnNldEF1dGgoKVxuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoZXMgc2VuZCBidWZmZXJcbiAgICovXG4gIGZsdXNoU2VuZEJ1ZmZlcigpIHtcbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKCkpXG4gICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgZWl0aGVyIGN1c3RvbSBmZXRjaCwgaWYgcHJvdmlkZWQsIG9yIGRlZmF1bHQgZmV0Y2ggdG8gbWFrZSBIVFRQIHJlcXVlc3RzXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3Jlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaD86IEZldGNoKTogRmV0Y2ggPT4ge1xuICAgIGxldCBfZmV0Y2g6IEZldGNoXG4gICAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgX2ZldGNoID0gKC4uLmFyZ3MpID0+XG4gICAgICAgIGltcG9ydCgnQHN1cGFiYXNlL25vZGUtZmV0Y2gnIGFzIGFueSkudGhlbigoeyBkZWZhdWx0OiBmZXRjaCB9KSA9PlxuICAgICAgICAgIGZldGNoKC4uLmFyZ3MpXG4gICAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgX2ZldGNoID0gZmV0Y2hcbiAgICB9XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBfZmV0Y2goLi4uYXJncylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5leHQgbWVzc2FnZSByZWYsIGFjY291bnRpbmcgZm9yIG92ZXJmbG93c1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9tYWtlUmVmKCk6IHN0cmluZyB7XG4gICAgbGV0IG5ld1JlZiA9IHRoaXMucmVmICsgMVxuICAgIGlmIChuZXdSZWYgPT09IHRoaXMucmVmKSB7XG4gICAgICB0aGlzLnJlZiA9IDBcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWYgPSBuZXdSZWZcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWYudG9TdHJpbmcoKVxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gY2hhbm5lbHMgd2l0aCB0aGUgc3BlY2lmaWVkIHRvcGljLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9sZWF2ZU9wZW5Ub3BpYyh0b3BpYzogc3RyaW5nKTogdm9pZCB7XG4gICAgbGV0IGR1cENoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmZpbmQoXG4gICAgICAoYykgPT4gYy50b3BpYyA9PT0gdG9waWMgJiYgKGMuX2lzSm9pbmVkKCkgfHwgYy5faXNKb2luaW5nKCkpXG4gICAgKVxuICAgIGlmIChkdXBDaGFubmVsKSB7XG4gICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgYGxlYXZpbmcgZHVwbGljYXRlIHRvcGljIFwiJHt0b3BpY31cImApXG4gICAgICBkdXBDaGFubmVsLnVuc3Vic2NyaWJlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHN1YnNjcmlwdGlvbiBmcm9tIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBjaGFubmVsIEFuIG9wZW4gc3Vic2NyaXB0aW9uLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9yZW1vdmUoY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsKSB7XG4gICAgdGhpcy5jaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZmlsdGVyKFxuICAgICAgKGM6IFJlYWx0aW1lQ2hhbm5lbCkgPT4gYy5fam9pblJlZigpICE9PSBjaGFubmVsLl9qb2luUmVmKClcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCBjb25uZWN0aW9uIGhhbmRsZXJzLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgc2V0dXBDb25uZWN0aW9uKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgIHRoaXMuY29ubi5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICAgICAgdGhpcy5jb25uLm9ub3BlbiA9ICgpID0+IHRoaXMuX29uQ29ubk9wZW4oKVxuICAgICAgdGhpcy5jb25uLm9uZXJyb3IgPSAoZXJyb3I6IFdlYlNvY2tldExpa2VFcnJvcikgPT5cbiAgICAgICAgdGhpcy5fb25Db25uRXJyb3IoZXJyb3IgYXMgV2ViU29ja2V0TGlrZUVycm9yKVxuICAgICAgdGhpcy5jb25uLm9ubWVzc2FnZSA9IChldmVudDogYW55KSA9PiB0aGlzLl9vbkNvbm5NZXNzYWdlKGV2ZW50KVxuICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSAoZXZlbnQ6IGFueSkgPT4gdGhpcy5fb25Db25uQ2xvc2UoZXZlbnQpXG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9vbkNvbm5NZXNzYWdlKHJhd01lc3NhZ2U6IHsgZGF0YTogYW55IH0pIHtcbiAgICB0aGlzLmRlY29kZShyYXdNZXNzYWdlLmRhdGEsIChtc2c6IFJlYWx0aW1lTWVzc2FnZSkgPT4ge1xuICAgICAgbGV0IHsgdG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYgfSA9IG1zZ1xuXG4gICAgICBpZiAocmVmICYmIHJlZiA9PT0gdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2coXG4gICAgICAgICdyZWNlaXZlJyxcbiAgICAgICAgYCR7cGF5bG9hZC5zdGF0dXMgfHwgJyd9ICR7dG9waWN9ICR7ZXZlbnR9ICR7XG4gICAgICAgICAgKHJlZiAmJiAnKCcgKyByZWYgKyAnKScpIHx8ICcnXG4gICAgICAgIH1gLFxuICAgICAgICBwYXlsb2FkXG4gICAgICApXG4gICAgICB0aGlzLmNoYW5uZWxzXG4gICAgICAgIC5maWx0ZXIoKGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCkgPT4gY2hhbm5lbC5faXNNZW1iZXIodG9waWMpKVxuICAgICAgICAuZm9yRWFjaCgoY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsKSA9PlxuICAgICAgICAgIGNoYW5uZWwuX3RyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZilcbiAgICAgICAgKVxuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhtc2cpKVxuICAgIH0pXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgYXN5bmMgX29uQ29ubk9wZW4oKSB7XG4gICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIGBjb25uZWN0ZWQgdG8gJHt0aGlzLmVuZHBvaW50VVJMKCl9YClcbiAgICB0aGlzLmZsdXNoU2VuZEJ1ZmZlcigpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciAmJiBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gc2V0SW50ZXJ2YWwoXG4gICAgICAgICgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLFxuICAgICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXNcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMud29ya2VyVXJsKSB7XG4gICAgICAgIHRoaXMubG9nKCd3b3JrZXInLCBgc3RhcnRpbmcgd29ya2VyIGZvciBmcm9tICR7dGhpcy53b3JrZXJVcmx9YClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nKCd3b3JrZXInLCBgc3RhcnRpbmcgZGVmYXVsdCB3b3JrZXJgKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvYmplY3RVcmwgPSB0aGlzLl93b3JrZXJPYmplY3RVcmwodGhpcy53b3JrZXJVcmwhKVxuICAgICAgdGhpcy53b3JrZXJSZWYgPSBuZXcgV29ya2VyKG9iamVjdFVybClcbiAgICAgIHRoaXMud29ya2VyUmVmLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5sb2coJ3dvcmtlcicsICd3b3JrZXIgZXJyb3InLCBlcnJvci5tZXNzYWdlKVxuICAgICAgICB0aGlzLndvcmtlclJlZiEudGVybWluYXRlKClcbiAgICAgIH1cbiAgICAgIHRoaXMud29ya2VyUmVmLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS5ldmVudCA9PT0gJ2tlZXBBbGl2ZScpIHtcbiAgICAgICAgICB0aGlzLnNlbmRIZWFydGJlYXQoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLndvcmtlclJlZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGV2ZW50OiAnc3RhcnQnLFxuICAgICAgICBpbnRlcnZhbDogdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm9wZW4uZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKCkpIVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIHByaXZhdGUgX29uQ29ubkNsb3NlKGV2ZW50OiBhbnkpIHtcbiAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgJ2Nsb3NlJywgZXZlbnQpXG4gICAgdGhpcy5fdHJpZ2dlckNoYW5FcnJvcigpXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciAmJiBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGV2ZW50KSlcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfb25Db25uRXJyb3IoZXJyb3I6IFdlYlNvY2tldExpa2VFcnJvcikge1xuICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCBlcnJvci5tZXNzYWdlKVxuICAgIHRoaXMuX3RyaWdnZXJDaGFuRXJyb3IoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuZXJyb3IuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGVycm9yKSlcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfdHJpZ2dlckNoYW5FcnJvcigpIHtcbiAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCkgPT5cbiAgICAgIGNoYW5uZWwuX3RyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuZXJyb3IpXG4gICAgKVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9hcHBlbmRQYXJhbXMoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgcGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gICk6IHN0cmluZyB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdXJsXG4gICAgfVxuICAgIGNvbnN0IHByZWZpeCA9IHVybC5tYXRjaCgvXFw/LykgPyAnJicgOiAnPydcbiAgICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKVxuXG4gICAgcmV0dXJuIGAke3VybH0ke3ByZWZpeH0ke3F1ZXJ5fWBcbiAgfVxuXG4gIHByaXZhdGUgX3dvcmtlck9iamVjdFVybCh1cmw6IHN0cmluZyB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG4gICAgbGV0IHJlc3VsdF91cmw6IHN0cmluZ1xuICAgIGlmICh1cmwpIHtcbiAgICAgIHJlc3VsdF91cmwgPSB1cmxcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtXT1JLRVJfU0NSSVBUXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSlcbiAgICAgIHJlc3VsdF91cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRfdXJsXG4gIH1cbn1cblxuY2xhc3MgV1NXZWJTb2NrZXREdW1teSB7XG4gIGJpbmFyeVR5cGU6IHN0cmluZyA9ICdhcnJheWJ1ZmZlcidcbiAgY2xvc2U6IEZ1bmN0aW9uXG4gIG9uY2xvc2U6IEZ1bmN0aW9uID0gKCkgPT4ge31cbiAgb25lcnJvcjogRnVuY3Rpb24gPSAoKSA9PiB7fVxuICBvbm1lc3NhZ2U6IEZ1bmN0aW9uID0gKCkgPT4ge31cbiAgb25vcGVuOiBGdW5jdGlvbiA9ICgpID0+IHt9XG4gIHJlYWR5U3RhdGU6IG51bWJlciA9IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZ1xuICBzZW5kOiBGdW5jdGlvbiA9ICgpID0+IHt9XG4gIHVybDogc3RyaW5nIHwgVVJMIHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3RvcihcbiAgICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgX3Byb3RvY29sczogdW5kZWZpbmVkLFxuICAgIG9wdGlvbnM6IHsgY2xvc2U6IEZ1bmN0aW9uIH1cbiAgKSB7XG4gICAgdGhpcy51cmwgPSBhZGRyZXNzXG4gICAgdGhpcy5jbG9zZSA9IG9wdGlvbnMuY2xvc2VcbiAgfVxufVxuIiwgImV4cG9ydCBjbGFzcyBTdG9yYWdlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHByb3RlY3RlZCBfX2lzU3RvcmFnZUVycm9yID0gdHJ1ZVxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1N0b3JhZ2VFcnJvcidcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdG9yYWdlRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBTdG9yYWdlRXJyb3Ige1xuICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnX19pc1N0b3JhZ2VFcnJvcicgaW4gZXJyb3Jcbn1cblxuZXhwb3J0IGNsYXNzIFN0b3JhZ2VBcGlFcnJvciBleHRlbmRzIFN0b3JhZ2VFcnJvciB7XG4gIHN0YXR1czogbnVtYmVyXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBzdGF0dXM6IG51bWJlcikge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1N0b3JhZ2VBcGlFcnJvcidcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3RvcmFnZVVua25vd25FcnJvciBleHRlbmRzIFN0b3JhZ2VFcnJvciB7XG4gIG9yaWdpbmFsRXJyb3I6IHVua25vd25cblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIG9yaWdpbmFsRXJyb3I6IHVua25vd24pIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdTdG9yYWdlVW5rbm93bkVycm9yJ1xuICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3JcbiAgfVxufVxuIiwgInR5cGUgRmV0Y2ggPSB0eXBlb2YgZmV0Y2hcblxuZXhwb3J0IGNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaD86IEZldGNoKTogRmV0Y2ggPT4ge1xuICBsZXQgX2ZldGNoOiBGZXRjaFxuICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaFxuICB9IGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT5cbiAgICAgIGltcG9ydCgnQHN1cGFiYXNlL25vZGUtZmV0Y2gnIGFzIGFueSkudGhlbigoeyBkZWZhdWx0OiBmZXRjaCB9KSA9PiBmZXRjaCguLi5hcmdzKSlcbiAgfSBlbHNlIHtcbiAgICBfZmV0Y2ggPSBmZXRjaFxuICB9XG4gIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpXG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlUmVzcG9uc2UgPSBhc3luYyAoKTogUHJvbWlzZTx0eXBlb2YgUmVzcG9uc2U+ID0+IHtcbiAgaWYgKHR5cGVvZiBSZXNwb25zZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIChhd2FpdCBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJyBhcyBhbnkpKS5SZXNwb25zZVxuICB9XG5cbiAgcmV0dXJuIFJlc3BvbnNlXG59XG5cbmV4cG9ydCBjb25zdCByZWN1cnNpdmVUb0NhbWVsID0gKGl0ZW06IFJlY29yZDxzdHJpbmcsIGFueT4pOiB1bmtub3duID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICByZXR1cm4gaXRlbS5tYXAoKGVsKSA9PiByZWN1cnNpdmVUb0NhbWVsKGVsKSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ2Z1bmN0aW9uJyB8fCBpdGVtICE9PSBPYmplY3QoaXRlbSkpIHtcbiAgICByZXR1cm4gaXRlbVxuICB9XG5cbiAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge31cbiAgT2JqZWN0LmVudHJpZXMoaXRlbSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgbmV3S2V5ID0ga2V5LnJlcGxhY2UoLyhbLV9dW2Etel0pL2dpLCAoYykgPT4gYy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL1stX10vZywgJycpKVxuICAgIHJlc3VsdFtuZXdLZXldID0gcmVjdXJzaXZlVG9DYW1lbCh2YWx1ZSlcbiAgfSlcblxuICByZXR1cm4gcmVzdWx0XG59XG4iLCAiaW1wb3J0IHsgU3RvcmFnZUFwaUVycm9yLCBTdG9yYWdlVW5rbm93bkVycm9yIH0gZnJvbSAnLi9lcnJvcnMnXG5pbXBvcnQgeyByZXNvbHZlUmVzcG9uc2UgfSBmcm9tICcuL2hlbHBlcnMnXG5pbXBvcnQgeyBGZXRjaFBhcmFtZXRlcnMgfSBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgdHlwZSBGZXRjaCA9IHR5cGVvZiBmZXRjaFxuXG5leHBvcnQgaW50ZXJmYWNlIEZldGNoT3B0aW9ucyB7XG4gIGhlYWRlcnM/OiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gIH1cbiAgbm9SZXNvbHZlSnNvbj86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgUmVxdWVzdE1ldGhvZFR5cGUgPSAnR0VUJyB8ICdQT1NUJyB8ICdQVVQnIHwgJ0RFTEVURScgfCAnSEVBRCdcblxuY29uc3QgX2dldEVycm9yTWVzc2FnZSA9IChlcnI6IGFueSk6IHN0cmluZyA9PlxuICBlcnIubXNnIHx8IGVyci5tZXNzYWdlIHx8IGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fCBlcnIuZXJyb3IgfHwgSlNPTi5zdHJpbmdpZnkoZXJyKVxuXG5jb25zdCBoYW5kbGVFcnJvciA9IGFzeW5jIChcbiAgZXJyb3I6IHVua25vd24sXG4gIHJlamVjdDogKHJlYXNvbj86IGFueSkgPT4gdm9pZCxcbiAgb3B0aW9ucz86IEZldGNoT3B0aW9uc1xuKSA9PiB7XG4gIGNvbnN0IFJlcyA9IGF3YWl0IHJlc29sdmVSZXNwb25zZSgpXG5cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgUmVzICYmICFvcHRpb25zPy5ub1Jlc29sdmVKc29uKSB7XG4gICAgZXJyb3JcbiAgICAgIC5qc29uKClcbiAgICAgIC50aGVuKChlcnIpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBTdG9yYWdlQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnIpLCBlcnJvci5zdGF0dXMgfHwgNTAwKSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICByZWplY3QobmV3IFN0b3JhZ2VVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnIpLCBlcnIpKVxuICAgICAgfSlcbiAgfSBlbHNlIHtcbiAgICByZWplY3QobmV3IFN0b3JhZ2VVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yKSlcbiAgfVxufVxuXG5jb25zdCBfZ2V0UmVxdWVzdFBhcmFtcyA9IChcbiAgbWV0aG9kOiBSZXF1ZXN0TWV0aG9kVHlwZSxcbiAgb3B0aW9ucz86IEZldGNoT3B0aW9ucyxcbiAgcGFyYW1ldGVycz86IEZldGNoUGFyYW1ldGVycyxcbiAgYm9keT86IG9iamVjdFxuKSA9PiB7XG4gIGNvbnN0IHBhcmFtczogeyBbazogc3RyaW5nXTogYW55IH0gPSB7IG1ldGhvZCwgaGVhZGVyczogb3B0aW9ucz8uaGVhZGVycyB8fCB7fSB9XG5cbiAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICByZXR1cm4gcGFyYW1zXG4gIH1cblxuICBwYXJhbXMuaGVhZGVycyA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9XG5cbiAgaWYgKGJvZHkpIHtcbiAgICBwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gIH1cbiAgcmV0dXJuIHsgLi4ucGFyYW1zLCAuLi5wYXJhbWV0ZXJzIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QoXG4gIGZldGNoZXI6IEZldGNoLFxuICBtZXRob2Q6IFJlcXVlc3RNZXRob2RUeXBlLFxuICB1cmw6IHN0cmluZyxcbiAgb3B0aW9ucz86IEZldGNoT3B0aW9ucyxcbiAgcGFyYW1ldGVycz86IEZldGNoUGFyYW1ldGVycyxcbiAgYm9keT86IG9iamVjdFxuKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmZXRjaGVyKHVybCwgX2dldFJlcXVlc3RQYXJhbXMobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSlcbiAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKCFyZXN1bHQub2spIHRocm93IHJlc3VsdFxuICAgICAgICBpZiAob3B0aW9ucz8ubm9SZXNvbHZlSnNvbikgcmV0dXJuIHJlc3VsdFxuICAgICAgICByZXR1cm4gcmVzdWx0Lmpzb24oKVxuICAgICAgfSlcbiAgICAgIC50aGVuKChkYXRhKSA9PiByZXNvbHZlKGRhdGEpKVxuICAgICAgLmNhdGNoKChlcnJvcikgPT4gaGFuZGxlRXJyb3IoZXJyb3IsIHJlamVjdCwgb3B0aW9ucykpXG4gIH0pXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXQoXG4gIGZldGNoZXI6IEZldGNoLFxuICB1cmw6IHN0cmluZyxcbiAgb3B0aW9ucz86IEZldGNoT3B0aW9ucyxcbiAgcGFyYW1ldGVycz86IEZldGNoUGFyYW1ldGVyc1xuKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdHRVQnLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwb3N0KFxuICBmZXRjaGVyOiBGZXRjaCxcbiAgdXJsOiBzdHJpbmcsXG4gIGJvZHk6IG9iamVjdCxcbiAgb3B0aW9ucz86IEZldGNoT3B0aW9ucyxcbiAgcGFyYW1ldGVycz86IEZldGNoUGFyYW1ldGVyc1xuKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdQT1NUJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHV0KFxuICBmZXRjaGVyOiBGZXRjaCxcbiAgdXJsOiBzdHJpbmcsXG4gIGJvZHk6IG9iamVjdCxcbiAgb3B0aW9ucz86IEZldGNoT3B0aW9ucyxcbiAgcGFyYW1ldGVycz86IEZldGNoUGFyYW1ldGVyc1xuKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdQVVQnLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoZWFkKFxuICBmZXRjaGVyOiBGZXRjaCxcbiAgdXJsOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnNcbik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBfaGFuZGxlUmVxdWVzdChcbiAgICBmZXRjaGVyLFxuICAgICdIRUFEJyxcbiAgICB1cmwsXG4gICAge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgfSxcbiAgICBwYXJhbWV0ZXJzXG4gIClcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbW92ZShcbiAgZmV0Y2hlcjogRmV0Y2gsXG4gIHVybDogc3RyaW5nLFxuICBib2R5OiBvYmplY3QsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnNcbik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCAnREVMRVRFJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KVxufVxuIiwgImltcG9ydCB7IGlzU3RvcmFnZUVycm9yLCBTdG9yYWdlRXJyb3IsIFN0b3JhZ2VVbmtub3duRXJyb3IgfSBmcm9tICcuLi9saWIvZXJyb3JzJ1xuaW1wb3J0IHsgRmV0Y2gsIGdldCwgaGVhZCwgcG9zdCwgcmVtb3ZlIH0gZnJvbSAnLi4vbGliL2ZldGNoJ1xuaW1wb3J0IHsgcmVjdXJzaXZlVG9DYW1lbCwgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi4vbGliL2hlbHBlcnMnXG5pbXBvcnQge1xuICBGaWxlT2JqZWN0LFxuICBGaWxlT3B0aW9ucyxcbiAgU2VhcmNoT3B0aW9ucyxcbiAgRmV0Y2hQYXJhbWV0ZXJzLFxuICBUcmFuc2Zvcm1PcHRpb25zLFxuICBEZXN0aW5hdGlvbk9wdGlvbnMsXG4gIEZpbGVPYmplY3RWMixcbiAgQ2FtZWxpemUsXG59IGZyb20gJy4uL2xpYi90eXBlcydcblxuY29uc3QgREVGQVVMVF9TRUFSQ0hfT1BUSU9OUyA9IHtcbiAgbGltaXQ6IDEwMCxcbiAgb2Zmc2V0OiAwLFxuICBzb3J0Qnk6IHtcbiAgICBjb2x1bW46ICduYW1lJyxcbiAgICBvcmRlcjogJ2FzYycsXG4gIH0sXG59XG5cbmNvbnN0IERFRkFVTFRfRklMRV9PUFRJT05TOiBGaWxlT3B0aW9ucyA9IHtcbiAgY2FjaGVDb250cm9sOiAnMzYwMCcsXG4gIGNvbnRlbnRUeXBlOiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JyxcbiAgdXBzZXJ0OiBmYWxzZSxcbn1cblxudHlwZSBGaWxlQm9keSA9XG4gIHwgQXJyYXlCdWZmZXJcbiAgfCBBcnJheUJ1ZmZlclZpZXdcbiAgfCBCbG9iXG4gIHwgQnVmZmVyXG4gIHwgRmlsZVxuICB8IEZvcm1EYXRhXG4gIHwgTm9kZUpTLlJlYWRhYmxlU3RyZWFtXG4gIHwgUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbiAgfCBVUkxTZWFyY2hQYXJhbXNcbiAgfCBzdHJpbmdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RvcmFnZUZpbGVBcGkge1xuICBwcm90ZWN0ZWQgdXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgcHJvdGVjdGVkIGJ1Y2tldElkPzogc3RyaW5nXG4gIHByb3RlY3RlZCBmZXRjaDogRmV0Y2hcblxuICBjb25zdHJ1Y3RvcihcbiAgICB1cmw6IHN0cmluZyxcbiAgICBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge30sXG4gICAgYnVja2V0SWQ/OiBzdHJpbmcsXG4gICAgZmV0Y2g/OiBGZXRjaFxuICApIHtcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnNcbiAgICB0aGlzLmJ1Y2tldElkID0gYnVja2V0SWRcbiAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwbG9hZHMgYSBmaWxlIHRvIGFuIGV4aXN0aW5nIGJ1Y2tldCBvciByZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cbiAgICpcbiAgICogQHBhcmFtIG1ldGhvZCBIVFRQIG1ldGhvZC5cbiAgICogQHBhcmFtIHBhdGggVGhlIHJlbGF0aXZlIGZpbGUgcGF0aC4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHVwbG9hZE9yVXBkYXRlKFxuICAgIG1ldGhvZDogJ1BPU1QnIHwgJ1BVVCcsXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGZpbGVCb2R5OiBGaWxlQm9keSxcbiAgICBmaWxlT3B0aW9ucz86IEZpbGVPcHRpb25zXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgaWQ6IHN0cmluZzsgcGF0aDogc3RyaW5nOyBmdWxsUGF0aDogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgYm9keVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgLi4uREVGQVVMVF9GSUxFX09QVElPTlMsIC4uLmZpbGVPcHRpb25zIH1cbiAgICAgIGxldCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgIC4uLihtZXRob2QgPT09ICdQT1NUJyAmJiB7ICd4LXVwc2VydCc6IFN0cmluZyhvcHRpb25zLnVwc2VydCBhcyBib29sZWFuKSB9KSxcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWV0YWRhdGEgPSBvcHRpb25zLm1ldGFkYXRhXG5cbiAgICAgIGlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGJvZHkgPSBuZXcgRm9ybURhdGEoKVxuICAgICAgICBib2R5LmFwcGVuZCgnY2FjaGVDb250cm9sJywgb3B0aW9ucy5jYWNoZUNvbnRyb2wgYXMgc3RyaW5nKVxuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICBib2R5LmFwcGVuZCgnbWV0YWRhdGEnLCB0aGlzLmVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSlcbiAgICAgICAgfVxuICAgICAgICBib2R5LmFwcGVuZCgnJywgZmlsZUJvZHkpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICBib2R5ID0gZmlsZUJvZHlcbiAgICAgICAgYm9keS5hcHBlbmQoJ2NhY2hlQ29udHJvbCcsIG9wdGlvbnMuY2FjaGVDb250cm9sIGFzIHN0cmluZylcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgYm9keS5hcHBlbmQoJ21ldGFkYXRhJywgdGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvZHkgPSBmaWxlQm9keVxuICAgICAgICBoZWFkZXJzWydjYWNoZS1jb250cm9sJ10gPSBgbWF4LWFnZT0ke29wdGlvbnMuY2FjaGVDb250cm9sfWBcbiAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBvcHRpb25zLmNvbnRlbnRUeXBlIGFzIHN0cmluZ1xuXG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgIGhlYWRlcnNbJ3gtbWV0YWRhdGEnXSA9IHRoaXMudG9CYXNlNjQodGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGVPcHRpb25zPy5oZWFkZXJzKSB7XG4gICAgICAgIGhlYWRlcnMgPSB7IC4uLmhlYWRlcnMsIC4uLmZpbGVPcHRpb25zLmhlYWRlcnMgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjbGVhblBhdGggPSB0aGlzLl9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aClcbiAgICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKGNsZWFuUGF0aClcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZmV0Y2goYCR7dGhpcy51cmx9L29iamVjdC8ke19wYXRofWAsIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBib2R5OiBib2R5IGFzIEJvZHlJbml0LFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICAuLi4ob3B0aW9ucz8uZHVwbGV4ID8geyBkdXBsZXg6IG9wdGlvbnMuZHVwbGV4IH0gOiB7fSksXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKVxuXG4gICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogeyBwYXRoOiBjbGVhblBhdGgsIGlkOiBkYXRhLklkLCBmdWxsUGF0aDogZGF0YS5LZXkgfSxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBkYXRhXG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwbG9hZHMgYSBmaWxlIHRvIGFuIGV4aXN0aW5nIGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBmaWxlIG5hbWUuIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwbG9hZC5cbiAgICogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuICAgKi9cbiAgYXN5bmMgdXBsb2FkKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBmaWxlQm9keTogRmlsZUJvZHksXG4gICAgZmlsZU9wdGlvbnM/OiBGaWxlT3B0aW9uc1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IGlkOiBzdHJpbmc7IHBhdGg6IHN0cmluZzsgZnVsbFBhdGg6IHN0cmluZyB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICByZXR1cm4gdGhpcy51cGxvYWRPclVwZGF0ZSgnUE9TVCcsIHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGxvYWQgYSBmaWxlIHdpdGggYSB0b2tlbiBnZW5lcmF0ZWQgZnJvbSBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsYC5cbiAgICogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBmaWxlIG5hbWUuIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwbG9hZC5cbiAgICogQHBhcmFtIHRva2VuIFRoZSB0b2tlbiBnZW5lcmF0ZWQgZnJvbSBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsYFxuICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAqL1xuICBhc3luYyB1cGxvYWRUb1NpZ25lZFVybChcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgdG9rZW46IHN0cmluZyxcbiAgICBmaWxlQm9keTogRmlsZUJvZHksXG4gICAgZmlsZU9wdGlvbnM/OiBGaWxlT3B0aW9uc1xuICApIHtcbiAgICBjb25zdCBjbGVhblBhdGggPSB0aGlzLl9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aClcbiAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChjbGVhblBhdGgpXG5cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHRoaXMudXJsICsgYC9vYmplY3QvdXBsb2FkL3NpZ24vJHtfcGF0aH1gKVxuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCd0b2tlbicsIHRva2VuKVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBib2R5XG4gICAgICBjb25zdCBvcHRpb25zID0geyB1cHNlcnQ6IERFRkFVTFRfRklMRV9PUFRJT05TLnVwc2VydCwgLi4uZmlsZU9wdGlvbnMgfVxuICAgICAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICAgLi4udGhpcy5oZWFkZXJzLFxuICAgICAgICAuLi57ICd4LXVwc2VydCc6IFN0cmluZyhvcHRpb25zLnVwc2VydCBhcyBib29sZWFuKSB9LFxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBib2R5ID0gbmV3IEZvcm1EYXRhKClcbiAgICAgICAgYm9keS5hcHBlbmQoJ2NhY2hlQ29udHJvbCcsIG9wdGlvbnMuY2FjaGVDb250cm9sIGFzIHN0cmluZylcbiAgICAgICAgYm9keS5hcHBlbmQoJycsIGZpbGVCb2R5KVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgYm9keSA9IGZpbGVCb2R5XG4gICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCBhcyBzdHJpbmcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib2R5ID0gZmlsZUJvZHlcbiAgICAgICAgaGVhZGVyc1snY2FjaGUtY29udHJvbCddID0gYG1heC1hZ2U9JHtvcHRpb25zLmNhY2hlQ29udHJvbH1gXG4gICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gb3B0aW9ucy5jb250ZW50VHlwZSBhcyBzdHJpbmdcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5mZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICBib2R5OiBib2R5IGFzIEJvZHlJbml0LFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHsgcGF0aDogY2xlYW5QYXRoLCBmdWxsUGF0aDogZGF0YS5LZXkgfSxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBkYXRhXG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaWduZWQgdXBsb2FkIFVSTC5cbiAgICogU2lnbmVkIHVwbG9hZCBVUkxzIGNhbiBiZSB1c2VkIHRvIHVwbG9hZCBmaWxlcyB0byB0aGUgYnVja2V0IHdpdGhvdXQgZnVydGhlciBhdXRoZW50aWNhdGlvbi5cbiAgICogVGhleSBhcmUgdmFsaWQgZm9yIDIgaG91cnMuXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICogQHBhcmFtIG9wdGlvbnMudXBzZXJ0IElmIHNldCB0byB0cnVlLCBhbGxvd3MgdGhlIGZpbGUgdG8gYmUgb3ZlcndyaXR0ZW4gaWYgaXQgYWxyZWFkeSBleGlzdHMuXG4gICAqL1xuICBhc3luYyBjcmVhdGVTaWduZWRVcGxvYWRVcmwoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IHVwc2VydDogYm9vbGVhbiB9XG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgc2lnbmVkVXJsOiBzdHJpbmc7IHRva2VuOiBzdHJpbmc7IHBhdGg6IHN0cmluZyB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpXG5cbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXMuaGVhZGVycyB9XG5cbiAgICAgIGlmIChvcHRpb25zPy51cHNlcnQpIHtcbiAgICAgICAgaGVhZGVyc1sneC11cHNlcnQnXSA9ICd0cnVlJ1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L29iamVjdC91cGxvYWQvc2lnbi8ke19wYXRofWAsXG4gICAgICAgIHt9LFxuICAgICAgICB7IGhlYWRlcnMgfVxuICAgICAgKVxuXG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHRoaXMudXJsICsgZGF0YS51cmwpXG5cbiAgICAgIGNvbnN0IHRva2VuID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ3Rva2VuJylcblxuICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgU3RvcmFnZUVycm9yKCdObyB0b2tlbiByZXR1cm5lZCBieSBBUEknKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBkYXRhOiB7IHNpZ25lZFVybDogdXJsLnRvU3RyaW5nKCksIHBhdGgsIHRva2VuIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFuIGV4aXN0aW5nIGZpbGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoIHdpdGggYSBuZXcgb25lLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgcmVsYXRpdmUgZmlsZSBwYXRoLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZShcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgZmlsZUJvZHk6XG4gICAgICB8IEFycmF5QnVmZmVyXG4gICAgICB8IEFycmF5QnVmZmVyVmlld1xuICAgICAgfCBCbG9iXG4gICAgICB8IEJ1ZmZlclxuICAgICAgfCBGaWxlXG4gICAgICB8IEZvcm1EYXRhXG4gICAgICB8IE5vZGVKUy5SZWFkYWJsZVN0cmVhbVxuICAgICAgfCBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxuICAgICAgfCBVUkxTZWFyY2hQYXJhbXNcbiAgICAgIHwgc3RyaW5nLFxuICAgIGZpbGVPcHRpb25zPzogRmlsZU9wdGlvbnNcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBpZDogc3RyaW5nOyBwYXRoOiBzdHJpbmc7IGZ1bGxQYXRoOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMudXBsb2FkT3JVcGRhdGUoJ1BVVCcsIHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBleGlzdGluZyBmaWxlIHRvIGEgbmV3IHBhdGggaW4gdGhlIHNhbWUgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbVBhdGggVGhlIG9yaWdpbmFsIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgKiBAcGFyYW0gdG9QYXRoIFRoZSBuZXcgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIG5ldyBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UtbmV3LnBuZ2AuXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBkZXN0aW5hdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgYXN5bmMgbW92ZShcbiAgICBmcm9tUGF0aDogc3RyaW5nLFxuICAgIHRvUGF0aDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBEZXN0aW5hdGlvbk9wdGlvbnNcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBtZXNzYWdlOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vb2JqZWN0L21vdmVgLFxuICAgICAgICB7XG4gICAgICAgICAgYnVja2V0SWQ6IHRoaXMuYnVja2V0SWQsXG4gICAgICAgICAgc291cmNlS2V5OiBmcm9tUGF0aCxcbiAgICAgICAgICBkZXN0aW5hdGlvbktleTogdG9QYXRoLFxuICAgICAgICAgIGRlc3RpbmF0aW9uQnVja2V0OiBvcHRpb25zPy5kZXN0aW5hdGlvbkJ1Y2tldCxcbiAgICAgICAgfSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIGFuIGV4aXN0aW5nIGZpbGUgdG8gYSBuZXcgcGF0aCBpbiB0aGUgc2FtZSBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tUGF0aCBUaGUgb3JpZ2luYWwgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAqIEBwYXJhbSB0b1BhdGggVGhlIG5ldyBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgbmV3IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS1jb3B5LnBuZ2AuXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBkZXN0aW5hdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgYXN5bmMgY29weShcbiAgICBmcm9tUGF0aDogc3RyaW5nLFxuICAgIHRvUGF0aDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBEZXN0aW5hdGlvbk9wdGlvbnNcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBwYXRoOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vb2JqZWN0L2NvcHlgLFxuICAgICAgICB7XG4gICAgICAgICAgYnVja2V0SWQ6IHRoaXMuYnVja2V0SWQsXG4gICAgICAgICAgc291cmNlS2V5OiBmcm9tUGF0aCxcbiAgICAgICAgICBkZXN0aW5hdGlvbktleTogdG9QYXRoLFxuICAgICAgICAgIGRlc3RpbmF0aW9uQnVja2V0OiBvcHRpb25zPy5kZXN0aW5hdGlvbkJ1Y2tldCxcbiAgICAgICAgfSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuICAgICAgcmV0dXJuIHsgZGF0YTogeyBwYXRoOiBkYXRhLktleSB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2lnbmVkIFVSTC4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICogQHBhcmFtIGV4cGlyZXNJbiBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdW50aWwgdGhlIHNpZ25lZCBVUkwgZXhwaXJlcy4gRm9yIGV4YW1wbGUsIGA2MGAgZm9yIGEgVVJMIHdoaWNoIGlzIHZhbGlkIGZvciBvbmUgbWludXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCB0cmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cbiAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNpZ25lZFVybChcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgZXhwaXJlc0luOiBudW1iZXIsXG4gICAgb3B0aW9ucz86IHsgZG93bmxvYWQ/OiBzdHJpbmcgfCBib29sZWFuOyB0cmFuc2Zvcm0/OiBUcmFuc2Zvcm1PcHRpb25zIH1cbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBzaWduZWRVcmw6IHN0cmluZyB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpXG5cbiAgICAgIGxldCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L29iamVjdC9zaWduLyR7X3BhdGh9YCxcbiAgICAgICAgeyBleHBpcmVzSW4sIC4uLihvcHRpb25zPy50cmFuc2Zvcm0gPyB7IHRyYW5zZm9ybTogb3B0aW9ucy50cmFuc2Zvcm0gfSA6IHt9KSB9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG4gICAgICBjb25zdCBkb3dubG9hZFF1ZXJ5UGFyYW0gPSBvcHRpb25zPy5kb3dubG9hZFxuICAgICAgICA/IGAmZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gJycgOiBvcHRpb25zLmRvd25sb2FkfWBcbiAgICAgICAgOiAnJ1xuICAgICAgY29uc3Qgc2lnbmVkVXJsID0gZW5jb2RlVVJJKGAke3RoaXMudXJsfSR7ZGF0YS5zaWduZWRVUkx9JHtkb3dubG9hZFF1ZXJ5UGFyYW19YClcbiAgICAgIGRhdGEgPSB7IHNpZ25lZFVybCB9XG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG11bHRpcGxlIHNpZ25lZCBVUkxzLiBVc2UgYSBzaWduZWQgVVJMIHRvIHNoYXJlIGEgZmlsZSBmb3IgYSBmaXhlZCBhbW91bnQgb2YgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHBhdGhzIFRoZSBmaWxlIHBhdGhzIHRvIGJlIGRvd25sb2FkZWQsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWVzLiBGb3IgZXhhbXBsZSBgWydmb2xkZXIvaW1hZ2UucG5nJywgJ2ZvbGRlcjIvaW1hZ2UyLnBuZyddYC5cbiAgICogQHBhcmFtIGV4cGlyZXNJbiBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdW50aWwgdGhlIHNpZ25lZCBVUkxzIGV4cGlyZS4gRm9yIGV4YW1wbGUsIGA2MGAgZm9yIFVSTHMgd2hpY2ggYXJlIHZhbGlkIGZvciBvbmUgbWludXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCB0cmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNpZ25lZFVybHMoXG4gICAgcGF0aHM6IHN0cmluZ1tdLFxuICAgIGV4cGlyZXNJbjogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiB7IGRvd25sb2FkOiBzdHJpbmcgfCBib29sZWFuIH1cbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBlcnJvcjogc3RyaW5nIHwgbnVsbDsgcGF0aDogc3RyaW5nIHwgbnVsbDsgc2lnbmVkVXJsOiBzdHJpbmcgfVtdXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9vYmplY3Qvc2lnbi8ke3RoaXMuYnVja2V0SWR9YCxcbiAgICAgICAgeyBleHBpcmVzSW4sIHBhdGhzIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcblxuICAgICAgY29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gb3B0aW9ucz8uZG93bmxvYWRcbiAgICAgICAgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/ICcnIDogb3B0aW9ucy5kb3dubG9hZH1gXG4gICAgICAgIDogJydcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGRhdGEubWFwKChkYXR1bTogeyBzaWduZWRVUkw6IHN0cmluZyB9KSA9PiAoe1xuICAgICAgICAgIC4uLmRhdHVtLFxuICAgICAgICAgIHNpZ25lZFVybDogZGF0dW0uc2lnbmVkVVJMXG4gICAgICAgICAgICA/IGVuY29kZVVSSShgJHt0aGlzLnVybH0ke2RhdHVtLnNpZ25lZFVSTH0ke2Rvd25sb2FkUXVlcnlQYXJhbX1gKVxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICB9KSksXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRG93bmxvYWRzIGEgZmlsZSBmcm9tIGEgcHJpdmF0ZSBidWNrZXQuIEZvciBwdWJsaWMgYnVja2V0cywgbWFrZSBhIHJlcXVlc3QgdG8gdGhlIFVSTCByZXR1cm5lZCBmcm9tIGBnZXRQdWJsaWNVcmxgIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBmdWxsIHBhdGggYW5kIGZpbGUgbmFtZSBvZiB0aGUgZmlsZSB0byBiZSBkb3dubG9hZGVkLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG4gICAqL1xuICBhc3luYyBkb3dubG9hZChcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgdHJhbnNmb3JtPzogVHJhbnNmb3JtT3B0aW9ucyB9XG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IEJsb2JcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIGNvbnN0IHdhbnRzVHJhbnNmb3JtYXRpb24gPSB0eXBlb2Ygb3B0aW9ucz8udHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJ1xuICAgIGNvbnN0IHJlbmRlclBhdGggPSB3YW50c1RyYW5zZm9ybWF0aW9uID8gJ3JlbmRlci9pbWFnZS9hdXRoZW50aWNhdGVkJyA6ICdvYmplY3QnXG4gICAgY29uc3QgdHJhbnNmb3JtYXRpb25RdWVyeSA9IHRoaXMudHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcob3B0aW9ucz8udHJhbnNmb3JtIHx8IHt9KVxuICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gdHJhbnNmb3JtYXRpb25RdWVyeSA/IGA/JHt0cmFuc2Zvcm1hdGlvblF1ZXJ5fWAgOiAnJ1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9LyR7cmVuZGVyUGF0aH0vJHtfcGF0aH0ke3F1ZXJ5U3RyaW5nfWAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgICAgfSlcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuYmxvYigpXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgZmlsZS5cbiAgICogQHBhcmFtIHBhdGhcbiAgICovXG4gIGFzeW5jIGluZm8oXG4gICAgcGF0aDogc3RyaW5nXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IENhbWVsaXplPEZpbGVPYmplY3RWMj5cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vb2JqZWN0L2luZm8vJHtfcGF0aH1gLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiB7IGRhdGE6IHJlY3Vyc2l2ZVRvQ2FtZWwoZGF0YSkgYXMgQ2FtZWxpemU8RmlsZU9iamVjdFYyPiwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHRoZSBleGlzdGVuY2Ugb2YgYSBmaWxlLlxuICAgKiBAcGFyYW0gcGF0aFxuICAgKi9cbiAgYXN5bmMgZXhpc3RzKFxuICAgIHBhdGg6IHN0cmluZ1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBib29sZWFuXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IGJvb2xlYW5cbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGhlYWQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC8ke19wYXRofWAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHsgZGF0YTogdHJ1ZSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpICYmIGVycm9yIGluc3RhbmNlb2YgU3RvcmFnZVVua25vd25FcnJvcikge1xuICAgICAgICBjb25zdCBvcmlnaW5hbEVycm9yID0gKGVycm9yLm9yaWdpbmFsRXJyb3IgYXMgdW5rbm93bikgYXMgeyBzdGF0dXM6IG51bWJlciB9XG5cbiAgICAgICAgaWYgKFs0MDAsIDQwNF0uaW5jbHVkZXMob3JpZ2luYWxFcnJvcj8uc3RhdHVzKSkge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IGZhbHNlLCBlcnJvciB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBzaW1wbGUgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldC4gSWYgeW91IGRvIG5vdCB3YW50IHRvIHVzZSB0aGlzIGZ1bmN0aW9uLCB5b3UgY2FuIGNvbnN0cnVjdCB0aGUgcHVibGljIFVSTCBieSBjb25jYXRlbmF0aW5nIHRoZSBidWNrZXQgVVJMIHdpdGggdGhlIHBhdGggdG8gdGhlIGFzc2V0LlxuICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHZlcmlmeSBpZiB0aGUgYnVja2V0IGlzIHB1YmxpYy4gSWYgYSBwdWJsaWMgVVJMIGlzIGNyZWF0ZWQgZm9yIGEgYnVja2V0IHdoaWNoIGlzIG5vdCBwdWJsaWMsIHlvdSB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkIHRoZSBhc3NldC5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggYW5kIG5hbWUgb2YgdGhlIGZpbGUgdG8gZ2VuZXJhdGUgdGhlIHB1YmxpYyBVUkwgZm9yLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAqIEBwYXJhbSBvcHRpb25zLmRvd25sb2FkIFRyaWdnZXJzIHRoZSBmaWxlIGFzIGEgZG93bmxvYWQgaWYgc2V0IHRvIHRydWUuIFNldCB0aGlzIHBhcmFtZXRlciBhcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBpZiB5b3Ugd2FudCB0byB0cmlnZ2VyIHRoZSBkb3dubG9hZCB3aXRoIGEgZGlmZmVyZW50IGZpbGVuYW1lLlxuICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuICAgKi9cbiAgZ2V0UHVibGljVXJsKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyBkb3dubG9hZD86IHN0cmluZyB8IGJvb2xlYW47IHRyYW5zZm9ybT86IFRyYW5zZm9ybU9wdGlvbnMgfVxuICApOiB7IGRhdGE6IHsgcHVibGljVXJsOiBzdHJpbmcgfSB9IHtcbiAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKVxuICAgIGNvbnN0IF9xdWVyeVN0cmluZyA9IFtdXG5cbiAgICBjb25zdCBkb3dubG9hZFF1ZXJ5UGFyYW0gPSBvcHRpb25zPy5kb3dubG9hZFxuICAgICAgPyBgZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gJycgOiBvcHRpb25zLmRvd25sb2FkfWBcbiAgICAgIDogJydcblxuICAgIGlmIChkb3dubG9hZFF1ZXJ5UGFyYW0gIT09ICcnKSB7XG4gICAgICBfcXVlcnlTdHJpbmcucHVzaChkb3dubG9hZFF1ZXJ5UGFyYW0pXG4gICAgfVxuXG4gICAgY29uc3Qgd2FudHNUcmFuc2Zvcm1hdGlvbiA9IHR5cGVvZiBvcHRpb25zPy50cmFuc2Zvcm0gIT09ICd1bmRlZmluZWQnXG4gICAgY29uc3QgcmVuZGVyUGF0aCA9IHdhbnRzVHJhbnNmb3JtYXRpb24gPyAncmVuZGVyL2ltYWdlJyA6ICdvYmplY3QnXG4gICAgY29uc3QgdHJhbnNmb3JtYXRpb25RdWVyeSA9IHRoaXMudHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcob3B0aW9ucz8udHJhbnNmb3JtIHx8IHt9KVxuXG4gICAgaWYgKHRyYW5zZm9ybWF0aW9uUXVlcnkgIT09ICcnKSB7XG4gICAgICBfcXVlcnlTdHJpbmcucHVzaCh0cmFuc2Zvcm1hdGlvblF1ZXJ5KVxuICAgIH1cblxuICAgIGxldCBxdWVyeVN0cmluZyA9IF9xdWVyeVN0cmluZy5qb2luKCcmJylcbiAgICBpZiAocXVlcnlTdHJpbmcgIT09ICcnKSB7XG4gICAgICBxdWVyeVN0cmluZyA9IGA/JHtxdWVyeVN0cmluZ31gXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHsgcHVibGljVXJsOiBlbmNvZGVVUkkoYCR7dGhpcy51cmx9LyR7cmVuZGVyUGF0aH0vcHVibGljLyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gKSB9LFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGZpbGVzIHdpdGhpbiB0aGUgc2FtZSBidWNrZXRcbiAgICpcbiAgICogQHBhcmFtIHBhdGhzIEFuIGFycmF5IG9mIGZpbGVzIHRvIGRlbGV0ZSwgaW5jbHVkaW5nIHRoZSBwYXRoIGFuZCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIFtgJ2ZvbGRlci9pbWFnZS5wbmcnYF0uXG4gICAqL1xuICBhc3luYyByZW1vdmUoXG4gICAgcGF0aHM6IHN0cmluZ1tdXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IEZpbGVPYmplY3RbXVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZW1vdmUoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9vYmplY3QvJHt0aGlzLmJ1Y2tldElkfWAsXG4gICAgICAgIHsgcHJlZml4ZXM6IHBhdGhzIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBmaWxlIG1ldGFkYXRhXG4gICAqIEBwYXJhbSBpZCB0aGUgZmlsZSBpZCB0byByZXRyaWV2ZSBtZXRhZGF0YVxuICAgKi9cbiAgLy8gYXN5bmMgZ2V0TWV0YWRhdGEoXG4gIC8vICAgaWQ6IHN0cmluZ1xuICAvLyApOiBQcm9taXNlPFxuICAvLyAgIHwge1xuICAvLyAgICAgICBkYXRhOiBNZXRhZGF0YVxuICAvLyAgICAgICBlcnJvcjogbnVsbFxuICAvLyAgICAgfVxuICAvLyAgIHwge1xuICAvLyAgICAgICBkYXRhOiBudWxsXG4gIC8vICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgLy8gICAgIH1cbiAgLy8gPiB7XG4gIC8vICAgdHJ5IHtcbiAgLy8gICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L21ldGFkYXRhLyR7aWR9YCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSlcbiAgLy8gICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgLy8gICB9IGNhdGNoIChlcnJvcikge1xuICAvLyAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAvLyAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gIC8vICAgICB9XG5cbiAgLy8gICAgIHRocm93IGVycm9yXG4gIC8vICAgfVxuICAvLyB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBmaWxlIG1ldGFkYXRhXG4gICAqIEBwYXJhbSBpZCB0aGUgZmlsZSBpZCB0byB1cGRhdGUgbWV0YWRhdGFcbiAgICogQHBhcmFtIG1ldGEgdGhlIG5ldyBmaWxlIG1ldGFkYXRhXG4gICAqL1xuICAvLyBhc3luYyB1cGRhdGVNZXRhZGF0YShcbiAgLy8gICBpZDogc3RyaW5nLFxuICAvLyAgIG1ldGE6IE1ldGFkYXRhXG4gIC8vICk6IFByb21pc2U8XG4gIC8vICAgfCB7XG4gIC8vICAgICAgIGRhdGE6IE1ldGFkYXRhXG4gIC8vICAgICAgIGVycm9yOiBudWxsXG4gIC8vICAgICB9XG4gIC8vICAgfCB7XG4gIC8vICAgICAgIGRhdGE6IG51bGxcbiAgLy8gICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAvLyAgICAgfVxuICAvLyA+IHtcbiAgLy8gICB0cnkge1xuICAvLyAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoXG4gIC8vICAgICAgIHRoaXMuZmV0Y2gsXG4gIC8vICAgICAgIGAke3RoaXMudXJsfS9tZXRhZGF0YS8ke2lkfWAsXG4gIC8vICAgICAgIHsgLi4ubWV0YSB9LFxuICAvLyAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gIC8vICAgICApXG4gIC8vICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gIC8vICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgLy8gICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgLy8gICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAvLyAgICAgfVxuXG4gIC8vICAgICB0aHJvdyBlcnJvclxuICAvLyAgIH1cbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgdGhlIGZpbGVzIHdpdGhpbiBhIGJ1Y2tldC5cbiAgICogQHBhcmFtIHBhdGggVGhlIGZvbGRlciBwYXRoLlxuICAgKi9cbiAgYXN5bmMgbGlzdChcbiAgICBwYXRoPzogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBTZWFyY2hPcHRpb25zLFxuICAgIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnNcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogRmlsZU9iamVjdFtdXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYm9keSA9IHsgLi4uREVGQVVMVF9TRUFSQ0hfT1BUSU9OUywgLi4ub3B0aW9ucywgcHJlZml4OiBwYXRoIHx8ICcnIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vb2JqZWN0L2xpc3QvJHt0aGlzLmJ1Y2tldElkfWAsXG4gICAgICAgIGJvZHksXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0sXG4gICAgICAgIHBhcmFtZXRlcnNcbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGVuY29kZU1ldGFkYXRhKG1ldGFkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKVxuICB9XG5cbiAgdG9CYXNlNjQoZGF0YTogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oZGF0YSkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgfVxuICAgIHJldHVybiBidG9hKGRhdGEpXG4gIH1cblxuICBwcml2YXRlIF9nZXRGaW5hbFBhdGgocGF0aDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuYnVja2V0SWR9LyR7cGF0aH1gXG4gIH1cblxuICBwcml2YXRlIF9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXlxcL3xcXC8kL2csICcnKS5yZXBsYWNlKC9cXC8rL2csICcvJylcbiAgfVxuXG4gIHByaXZhdGUgdHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcodHJhbnNmb3JtOiBUcmFuc2Zvcm1PcHRpb25zKSB7XG4gICAgY29uc3QgcGFyYW1zID0gW11cbiAgICBpZiAodHJhbnNmb3JtLndpZHRoKSB7XG4gICAgICBwYXJhbXMucHVzaChgd2lkdGg9JHt0cmFuc2Zvcm0ud2lkdGh9YClcbiAgICB9XG5cbiAgICBpZiAodHJhbnNmb3JtLmhlaWdodCkge1xuICAgICAgcGFyYW1zLnB1c2goYGhlaWdodD0ke3RyYW5zZm9ybS5oZWlnaHR9YClcbiAgICB9XG5cbiAgICBpZiAodHJhbnNmb3JtLnJlc2l6ZSkge1xuICAgICAgcGFyYW1zLnB1c2goYHJlc2l6ZT0ke3RyYW5zZm9ybS5yZXNpemV9YClcbiAgICB9XG5cbiAgICBpZiAodHJhbnNmb3JtLmZvcm1hdCkge1xuICAgICAgcGFyYW1zLnB1c2goYGZvcm1hdD0ke3RyYW5zZm9ybS5mb3JtYXR9YClcbiAgICB9XG5cbiAgICBpZiAodHJhbnNmb3JtLnF1YWxpdHkpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGBxdWFsaXR5PSR7dHJhbnNmb3JtLnF1YWxpdHl9YClcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zLmpvaW4oJyYnKVxuICB9XG59XG4iLCAiLy8gZ2VuZXJhdGVkIGJ5IGdlbnZlcnNpb25cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuNy4xJ1xuIiwgImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nXG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBzdG9yYWdlLWpzLyR7dmVyc2lvbn1gIH1cbiIsICJpbXBvcnQgeyBERUZBVUxUX0hFQURFUlMgfSBmcm9tICcuLi9saWIvY29uc3RhbnRzJ1xuaW1wb3J0IHsgaXNTdG9yYWdlRXJyb3IsIFN0b3JhZ2VFcnJvciB9IGZyb20gJy4uL2xpYi9lcnJvcnMnXG5pbXBvcnQgeyBGZXRjaCwgZ2V0LCBwb3N0LCBwdXQsIHJlbW92ZSB9IGZyb20gJy4uL2xpYi9mZXRjaCdcbmltcG9ydCB7IHJlc29sdmVGZXRjaCB9IGZyb20gJy4uL2xpYi9oZWxwZXJzJ1xuaW1wb3J0IHsgQnVja2V0IH0gZnJvbSAnLi4vbGliL3R5cGVzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdG9yYWdlQnVja2V0QXBpIHtcbiAgcHJvdGVjdGVkIHVybDogc3RyaW5nXG4gIHByb3RlY3RlZCBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gIHByb3RlY3RlZCBmZXRjaDogRmV0Y2hcblxuICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZywgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9LCBmZXRjaD86IEZldGNoKSB7XG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICB0aGlzLmhlYWRlcnMgPSB7IC4uLkRFRkFVTFRfSEVBREVSUywgLi4uaGVhZGVycyB9XG4gICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYWxsIFN0b3JhZ2UgYnVja2V0cyB3aXRoaW4gYW4gZXhpc3RpbmcgcHJvamVjdC5cbiAgICovXG4gIGFzeW5jIGxpc3RCdWNrZXRzKCk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IEJ1Y2tldFtdXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0YCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSlcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbiBleGlzdGluZyBTdG9yYWdlIGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIHJldHJpZXZlLlxuICAgKi9cbiAgYXN5bmMgZ2V0QnVja2V0KFxuICAgIGlkOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogQnVja2V0XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9YCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSlcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU3RvcmFnZSBidWNrZXRcbiAgICpcbiAgICogQHBhcmFtIGlkIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBidWNrZXQgeW91IGFyZSBjcmVhdGluZy5cbiAgICogQHBhcmFtIG9wdGlvbnMucHVibGljIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidWNrZXQuIFB1YmxpYyBidWNrZXRzIGRvbid0IHJlcXVpcmUgYW4gYXV0aG9yaXphdGlvbiB0b2tlbiB0byBkb3dubG9hZCBvYmplY3RzLCBidXQgc3RpbGwgcmVxdWlyZSBhIHZhbGlkIHRva2VuIGZvciBhbGwgb3RoZXIgb3BlcmF0aW9ucy4gQnkgZGVmYXVsdCwgYnVja2V0cyBhcmUgcHJpdmF0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuZmlsZVNpemVMaW1pdCBzcGVjaWZpZXMgdGhlIG1heCBmaWxlIHNpemUgaW4gYnl0ZXMgdGhhdCBjYW4gYmUgdXBsb2FkZWQgdG8gdGhpcyBidWNrZXQuXG4gICAqIFRoZSBnbG9iYWwgZmlsZSBzaXplIGxpbWl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHZhbHVlLlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBkb2Vzbid0IHNldCBhIHBlciBidWNrZXQgZmlsZSBzaXplIGxpbWl0LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzIHNwZWNpZmllcyB0aGUgYWxsb3dlZCBtaW1lIHR5cGVzIHRoYXQgdGhpcyBidWNrZXQgY2FuIGFjY2VwdCBkdXJpbmcgdXBsb2FkLlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBhbGxvd3MgZmlsZXMgd2l0aCBhbGwgbWltZSB0eXBlcyB0byBiZSB1cGxvYWRlZC5cbiAgICogRWFjaCBtaW1lIHR5cGUgc3BlY2lmaWVkIGNhbiBiZSBhIHdpbGRjYXJkLCBlLmcuIGltYWdlLyosIG9yIGEgc3BlY2lmaWMgbWltZSB0eXBlLCBlLmcuIGltYWdlL3BuZy5cbiAgICogQHJldHVybnMgbmV3bHkgY3JlYXRlZCBidWNrZXQgaWRcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUJ1Y2tldChcbiAgICBpZDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHB1YmxpYzogYm9vbGVhblxuICAgICAgZmlsZVNpemVMaW1pdD86IG51bWJlciB8IHN0cmluZyB8IG51bGxcbiAgICAgIGFsbG93ZWRNaW1lVHlwZXM/OiBzdHJpbmdbXSB8IG51bGxcbiAgICB9ID0ge1xuICAgICAgcHVibGljOiBmYWxzZSxcbiAgICB9XG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IFBpY2s8QnVja2V0LCAnbmFtZSc+XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9idWNrZXRgLFxuICAgICAgICB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgbmFtZTogaWQsXG4gICAgICAgICAgcHVibGljOiBvcHRpb25zLnB1YmxpYyxcbiAgICAgICAgICBmaWxlX3NpemVfbGltaXQ6IG9wdGlvbnMuZmlsZVNpemVMaW1pdCxcbiAgICAgICAgICBhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyxcbiAgICAgICAgfSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBhIFN0b3JhZ2UgYnVja2V0XG4gICAqXG4gICAqIEBwYXJhbSBpZCBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYnVja2V0IHlvdSBhcmUgdXBkYXRpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zLnB1YmxpYyBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgYnVja2V0LiBQdWJsaWMgYnVja2V0cyBkb24ndCByZXF1aXJlIGFuIGF1dGhvcml6YXRpb24gdG9rZW4gdG8gZG93bmxvYWQgb2JqZWN0cywgYnV0IHN0aWxsIHJlcXVpcmUgYSB2YWxpZCB0b2tlbiBmb3IgYWxsIG90aGVyIG9wZXJhdGlvbnMuXG4gICAqIEBwYXJhbSBvcHRpb25zLmZpbGVTaXplTGltaXQgc3BlY2lmaWVzIHRoZSBtYXggZmlsZSBzaXplIGluIGJ5dGVzIHRoYXQgY2FuIGJlIHVwbG9hZGVkIHRvIHRoaXMgYnVja2V0LlxuICAgKiBUaGUgZ2xvYmFsIGZpbGUgc2l6ZSBsaW1pdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhpcyB2YWx1ZS5cbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggZG9lc24ndCBzZXQgYSBwZXIgYnVja2V0IGZpbGUgc2l6ZSBsaW1pdC5cbiAgICogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyBzcGVjaWZpZXMgdGhlIGFsbG93ZWQgbWltZSB0eXBlcyB0aGF0IHRoaXMgYnVja2V0IGNhbiBhY2NlcHQgZHVyaW5nIHVwbG9hZC5cbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggYWxsb3dzIGZpbGVzIHdpdGggYWxsIG1pbWUgdHlwZXMgdG8gYmUgdXBsb2FkZWQuXG4gICAqIEVhY2ggbWltZSB0eXBlIHNwZWNpZmllZCBjYW4gYmUgYSB3aWxkY2FyZCwgZS5nLiBpbWFnZS8qLCBvciBhIHNwZWNpZmljIG1pbWUgdHlwZSwgZS5nLiBpbWFnZS9wbmcuXG4gICAqL1xuICBhc3luYyB1cGRhdGVCdWNrZXQoXG4gICAgaWQ6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwdWJsaWM6IGJvb2xlYW5cbiAgICAgIGZpbGVTaXplTGltaXQ/OiBudW1iZXIgfCBzdHJpbmcgfCBudWxsXG4gICAgICBhbGxvd2VkTWltZVR5cGVzPzogc3RyaW5nW10gfCBudWxsXG4gICAgfVxuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IG1lc3NhZ2U6IHN0cmluZyB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHB1dChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L2J1Y2tldC8ke2lkfWAsXG4gICAgICAgIHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBuYW1lOiBpZCxcbiAgICAgICAgICBwdWJsaWM6IG9wdGlvbnMucHVibGljLFxuICAgICAgICAgIGZpbGVfc2l6ZV9saW1pdDogb3B0aW9ucy5maWxlU2l6ZUxpbWl0LFxuICAgICAgICAgIGFsbG93ZWRfbWltZV90eXBlczogb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzLFxuICAgICAgICB9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBvYmplY3RzIGluc2lkZSBhIHNpbmdsZSBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byBlbXB0eS5cbiAgICovXG4gIGFzeW5jIGVtcHR5QnVja2V0KFxuICAgIGlkOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBtZXNzYWdlOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9L2VtcHR5YCxcbiAgICAgICAge30sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gZXhpc3RpbmcgYnVja2V0LiBBIGJ1Y2tldCBjYW4ndCBiZSBkZWxldGVkIHdpdGggZXhpc3Rpbmcgb2JqZWN0cyBpbnNpZGUgaXQuXG4gICAqIFlvdSBtdXN0IGZpcnN0IGBlbXB0eSgpYCB0aGUgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gZGVsZXRlLlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlQnVja2V0KFxuICAgIGlkOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBtZXNzYWdlOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZW1vdmUoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH1gLFxuICAgICAgICB7fSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgU3RvcmFnZUZpbGVBcGkgZnJvbSAnLi9wYWNrYWdlcy9TdG9yYWdlRmlsZUFwaSdcbmltcG9ydCBTdG9yYWdlQnVja2V0QXBpIGZyb20gJy4vcGFja2FnZXMvU3RvcmFnZUJ1Y2tldEFwaSdcbmltcG9ydCB7IEZldGNoIH0gZnJvbSAnLi9saWIvZmV0Y2gnXG5cbmV4cG9ydCBjbGFzcyBTdG9yYWdlQ2xpZW50IGV4dGVuZHMgU3RvcmFnZUJ1Y2tldEFwaSB7XG4gIGNvbnN0cnVjdG9yKHVybDogc3RyaW5nLCBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge30sIGZldGNoPzogRmV0Y2gpIHtcbiAgICBzdXBlcih1cmwsIGhlYWRlcnMsIGZldGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gZmlsZSBvcGVyYXRpb24gaW4gYSBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCBUaGUgYnVja2V0IGlkIHRvIG9wZXJhdGUgb24uXG4gICAqL1xuICBmcm9tKGlkOiBzdHJpbmcpOiBTdG9yYWdlRmlsZUFwaSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRmlsZUFwaSh0aGlzLnVybCwgdGhpcy5oZWFkZXJzLCBpZCwgdGhpcy5mZXRjaClcbiAgfVxufVxuIiwgImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuNDcuMTYnXG4iLCAiLy8gY29uc3RhbnRzLnRzXG5pbXBvcnQgeyBSZWFsdGltZUNsaWVudE9wdGlvbnMgfSBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnXG5pbXBvcnQgeyBTdXBhYmFzZUF1dGhDbGllbnRPcHRpb25zIH0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nXG5cbmxldCBKU19FTlYgPSAnJ1xuLy8gQHRzLWlnbm9yZVxuaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJykge1xuICBKU19FTlYgPSAnZGVubydcbn0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICBKU19FTlYgPSAnd2ViJ1xufSBlbHNlIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICBKU19FTlYgPSAncmVhY3QtbmF0aXZlJ1xufSBlbHNlIHtcbiAgSlNfRU5WID0gJ25vZGUnXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYHN1cGFiYXNlLWpzLSR7SlNfRU5WfS8ke3ZlcnNpb259YCB9XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0dMT0JBTF9PUFRJT05TID0ge1xuICBoZWFkZXJzOiBERUZBVUxUX0hFQURFUlMsXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0RCX09QVElPTlMgPSB7XG4gIHNjaGVtYTogJ3B1YmxpYycsXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0FVVEhfT1BUSU9OUzogU3VwYWJhc2VBdXRoQ2xpZW50T3B0aW9ucyA9IHtcbiAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcbiAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gIGRldGVjdFNlc3Npb25JblVybDogdHJ1ZSxcbiAgZmxvd1R5cGU6ICdpbXBsaWNpdCcsXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1JFQUxUSU1FX09QVElPTlM6IFJlYWx0aW1lQ2xpZW50T3B0aW9ucyA9IHt9XG4iLCAiLy8gQHRzLWlnbm9yZVxuaW1wb3J0IG5vZGVGZXRjaCwgeyBIZWFkZXJzIGFzIE5vZGVGZXRjaEhlYWRlcnMgfSBmcm9tICdAc3VwYWJhc2Uvbm9kZS1mZXRjaCdcblxudHlwZSBGZXRjaCA9IHR5cGVvZiBmZXRjaFxuXG5leHBvcnQgY29uc3QgcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoPzogRmV0Y2gpOiBGZXRjaCA9PiB7XG4gIGxldCBfZmV0Y2g6IEZldGNoXG4gIGlmIChjdXN0b21GZXRjaCkge1xuICAgIF9mZXRjaCA9IGN1c3RvbUZldGNoXG4gIH0gZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgIF9mZXRjaCA9IG5vZGVGZXRjaCBhcyB1bmtub3duIGFzIEZldGNoXG4gIH0gZWxzZSB7XG4gICAgX2ZldGNoID0gZmV0Y2hcbiAgfVxuICByZXR1cm4gKC4uLmFyZ3M6IFBhcmFtZXRlcnM8RmV0Y2g+KSA9PiBfZmV0Y2goLi4uYXJncylcbn1cblxuZXhwb3J0IGNvbnN0IHJlc29sdmVIZWFkZXJzQ29uc3RydWN0b3IgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgSGVhZGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gTm9kZUZldGNoSGVhZGVyc1xuICB9XG5cbiAgcmV0dXJuIEhlYWRlcnNcbn1cblxuZXhwb3J0IGNvbnN0IGZldGNoV2l0aEF1dGggPSAoXG4gIHN1cGFiYXNlS2V5OiBzdHJpbmcsXG4gIGdldEFjY2Vzc1Rva2VuOiAoKSA9PiBQcm9taXNlPHN0cmluZyB8IG51bGw+LFxuICBjdXN0b21GZXRjaD86IEZldGNoXG4pOiBGZXRjaCA9PiB7XG4gIGNvbnN0IGZldGNoID0gcmVzb2x2ZUZldGNoKGN1c3RvbUZldGNoKVxuICBjb25zdCBIZWFkZXJzQ29uc3RydWN0b3IgPSByZXNvbHZlSGVhZGVyc0NvbnN0cnVjdG9yKClcblxuICByZXR1cm4gYXN5bmMgKGlucHV0LCBpbml0KSA9PiB7XG4gICAgY29uc3QgYWNjZXNzVG9rZW4gPSAoYXdhaXQgZ2V0QWNjZXNzVG9rZW4oKSkgPz8gc3VwYWJhc2VLZXlcbiAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzQ29uc3RydWN0b3IoaW5pdD8uaGVhZGVycylcblxuICAgIGlmICghaGVhZGVycy5oYXMoJ2FwaWtleScpKSB7XG4gICAgICBoZWFkZXJzLnNldCgnYXBpa2V5Jywgc3VwYWJhc2VLZXkpXG4gICAgfVxuXG4gICAgaWYgKCFoZWFkZXJzLmhhcygnQXV0aG9yaXphdGlvbicpKSB7XG4gICAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gKVxuICAgIH1cblxuICAgIHJldHVybiBmZXRjaChpbnB1dCwgeyAuLi5pbml0LCBoZWFkZXJzIH0pXG4gIH1cbn1cbiIsICIvLyBoZWxwZXJzLnRzXG5pbXBvcnQgeyBTdXBhYmFzZUNsaWVudE9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXVpZCgpIHtcbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCxcbiAgICAgIHYgPSBjID09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDhcbiAgICByZXR1cm4gdi50b1N0cmluZygxNilcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdTbGFzaCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiB1cmwucmVwbGFjZSgvXFwvJC8sICcnKVxufVxuXG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U2V0dGluZ0RlZmF1bHRzPFxuICBEYXRhYmFzZSA9IGFueSxcbiAgU2NoZW1hTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIERhdGFiYXNlID0gJ3B1YmxpYycgZXh0ZW5kcyBrZXlvZiBEYXRhYmFzZVxuICAgID8gJ3B1YmxpYydcbiAgICA6IHN0cmluZyAmIGtleW9mIERhdGFiYXNlXG4+KFxuICBvcHRpb25zOiBTdXBhYmFzZUNsaWVudE9wdGlvbnM8U2NoZW1hTmFtZT4sXG4gIGRlZmF1bHRzOiBTdXBhYmFzZUNsaWVudE9wdGlvbnM8YW55PlxuKTogUmVxdWlyZWQ8U3VwYWJhc2VDbGllbnRPcHRpb25zPFNjaGVtYU5hbWU+PiB7XG4gIGNvbnN0IHtcbiAgICBkYjogZGJPcHRpb25zLFxuICAgIGF1dGg6IGF1dGhPcHRpb25zLFxuICAgIHJlYWx0aW1lOiByZWFsdGltZU9wdGlvbnMsXG4gICAgZ2xvYmFsOiBnbG9iYWxPcHRpb25zLFxuICB9ID0gb3B0aW9uc1xuICBjb25zdCB7XG4gICAgZGI6IERFRkFVTFRfREJfT1BUSU9OUyxcbiAgICBhdXRoOiBERUZBVUxUX0FVVEhfT1BUSU9OUyxcbiAgICByZWFsdGltZTogREVGQVVMVF9SRUFMVElNRV9PUFRJT05TLFxuICAgIGdsb2JhbDogREVGQVVMVF9HTE9CQUxfT1BUSU9OUyxcbiAgfSA9IGRlZmF1bHRzXG5cbiAgY29uc3QgcmVzdWx0OiBSZXF1aXJlZDxTdXBhYmFzZUNsaWVudE9wdGlvbnM8U2NoZW1hTmFtZT4+ID0ge1xuICAgIGRiOiB7XG4gICAgICAuLi5ERUZBVUxUX0RCX09QVElPTlMsXG4gICAgICAuLi5kYk9wdGlvbnMsXG4gICAgfSxcbiAgICBhdXRoOiB7XG4gICAgICAuLi5ERUZBVUxUX0FVVEhfT1BUSU9OUyxcbiAgICAgIC4uLmF1dGhPcHRpb25zLFxuICAgIH0sXG4gICAgcmVhbHRpbWU6IHtcbiAgICAgIC4uLkRFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyxcbiAgICAgIC4uLnJlYWx0aW1lT3B0aW9ucyxcbiAgICB9LFxuICAgIGdsb2JhbDoge1xuICAgICAgLi4uREVGQVVMVF9HTE9CQUxfT1BUSU9OUyxcbiAgICAgIC4uLmdsb2JhbE9wdGlvbnMsXG4gICAgfSxcbiAgICBhY2Nlc3NUb2tlbjogYXN5bmMgKCkgPT4gJycsXG4gIH1cblxuICBpZiAob3B0aW9ucy5hY2Nlc3NUb2tlbikge1xuICAgIHJlc3VsdC5hY2Nlc3NUb2tlbiA9IG9wdGlvbnMuYWNjZXNzVG9rZW5cbiAgfSBlbHNlIHtcbiAgICAvLyBoYWNrIGFyb3VuZCBSZXF1aXJlZDw+XG4gICAgZGVsZXRlIChyZXN1bHQgYXMgYW55KS5hY2Nlc3NUb2tlblxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwgImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuNjcuMydcbiIsICJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJ1xuZXhwb3J0IGNvbnN0IEdPVFJVRV9VUkwgPSAnaHR0cDovL2xvY2FsaG9zdDo5OTk5J1xuZXhwb3J0IGNvbnN0IFNUT1JBR0VfS0VZID0gJ3N1cGFiYXNlLmF1dGgudG9rZW4nXG5leHBvcnQgY29uc3QgQVVESUVOQ0UgPSAnJ1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfSEVBREVSUyA9IHsgJ1gtQ2xpZW50LUluZm8nOiBgZ290cnVlLWpzLyR7dmVyc2lvbn1gIH1cbmV4cG9ydCBjb25zdCBFWFBJUllfTUFSR0lOID0gMTAgLy8gaW4gc2Vjb25kc1xuZXhwb3J0IGNvbnN0IE5FVFdPUktfRkFJTFVSRSA9IHtcbiAgTUFYX1JFVFJJRVM6IDEwLFxuICBSRVRSWV9JTlRFUlZBTDogMiwgLy8gaW4gZGVjaXNlY29uZHNcbn1cblxuZXhwb3J0IGNvbnN0IEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FID0gJ1gtU3VwYWJhc2UtQXBpLVZlcnNpb24nXG5leHBvcnQgY29uc3QgQVBJX1ZFUlNJT05TID0ge1xuICAnMjAyNC0wMS0wMSc6IHtcbiAgICB0aW1lc3RhbXA6IERhdGUucGFyc2UoJzIwMjQtMDEtMDFUMDA6MDA6MDAuMFonKSxcbiAgICBuYW1lOiAnMjAyNC0wMS0wMScsXG4gIH0sXG59XG4iLCAiaW1wb3J0IHsgQVBJX1ZFUlNJT05fSEVBREVSX05BTUUgfSBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB7IFN1cHBvcnRlZFN0b3JhZ2UgfSBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZXhwaXJlc0F0KGV4cGlyZXNJbjogbnVtYmVyKSB7XG4gIGNvbnN0IHRpbWVOb3cgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKVxuICByZXR1cm4gdGltZU5vdyArIGV4cGlyZXNJblxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXVpZCgpIHtcbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLFxuICAgICAgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4OFxuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KVxuICB9KVxufVxuXG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuXG5jb25zdCBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzID0ge1xuICB0ZXN0ZWQ6IGZhbHNlLFxuICB3cml0YWJsZTogZmFsc2UsXG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgbG9jYWxTdG9yYWdlIGlzIHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBzdXBwb3J0c0xvY2FsU3RvcmFnZSA9ICgpID0+IHtcbiAgaWYgKCFpc0Jyb3dzZXIoKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gRE9NIGV4Y2VwdGlvbiB3aGVuIGFjY2Vzc2luZyBgbG9jYWxTdG9yYWdlYFxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMudGVzdGVkKSB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGVcbiAgfVxuXG4gIGNvbnN0IHJhbmRvbUtleSA9IGBsc3d0LSR7TWF0aC5yYW5kb20oKX0ke01hdGgucmFuZG9tKCl9YFxuXG4gIHRyeSB7XG4gICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShyYW5kb21LZXksIHJhbmRvbUtleSlcbiAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHJhbmRvbUtleSlcblxuICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMudGVzdGVkID0gdHJ1ZVxuICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGUgPSB0cnVlXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBsb2NhbFN0b3JhZ2UgY2FuJ3QgYmUgd3JpdHRlbiB0b1xuICAgIC8vIGh0dHBzOi8vd3d3LmNocm9taXVtLm9yZy9mb3ItdGVzdGVycy9idWctcmVwb3J0aW5nLWd1aWRlbGluZXMvdW5jYXVnaHQtc2VjdXJpdHllcnJvci1mYWlsZWQtdG8tcmVhZC10aGUtbG9jYWxzdG9yYWdlLXByb3BlcnR5LWZyb20td2luZG93LWFjY2Vzcy1pcy1kZW5pZWQtZm9yLXRoaXMtZG9jdW1lbnRcblxuICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMudGVzdGVkID0gdHJ1ZVxuICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGUgPSBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGVcbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBwYXJhbWV0ZXJzIGVuY29kZWQgaW4gdGhlIFVSTCBib3RoIGluIHRoZSBxdWVyeSBhbmQgZnJhZ21lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMKGhyZWY6IHN0cmluZykge1xuICBjb25zdCByZXN1bHQ6IHsgW3BhcmFtZXRlcjogc3RyaW5nXTogc3RyaW5nIH0gPSB7fVxuXG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoaHJlZilcblxuICBpZiAodXJsLmhhc2ggJiYgdXJsLmhhc2hbMF0gPT09ICcjJykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoYXNoU2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh1cmwuaGFzaC5zdWJzdHJpbmcoMSkpXG4gICAgICBoYXNoU2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIC8vIGhhc2ggaXMgbm90IGEgcXVlcnkgc3RyaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gc2VhcmNoIHBhcmFtZXRlcnMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgaGFzaCBwYXJhbWV0ZXJzXG4gIHVybC5zZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgfSlcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbnR5cGUgRmV0Y2ggPSB0eXBlb2YgZmV0Y2hcblxuZXhwb3J0IGNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaD86IEZldGNoKTogRmV0Y2ggPT4ge1xuICBsZXQgX2ZldGNoOiBGZXRjaFxuICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaFxuICB9IGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT5cbiAgICAgIGltcG9ydCgnQHN1cGFiYXNlL25vZGUtZmV0Y2gnIGFzIGFueSkudGhlbigoeyBkZWZhdWx0OiBmZXRjaCB9KSA9PiBmZXRjaCguLi5hcmdzKSlcbiAgfSBlbHNlIHtcbiAgICBfZmV0Y2ggPSBmZXRjaFxuICB9XG4gIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpXG59XG5cbmV4cG9ydCBjb25zdCBsb29rc0xpa2VGZXRjaFJlc3BvbnNlID0gKG1heWJlUmVzcG9uc2U6IHVua25vd24pOiBtYXliZVJlc3BvbnNlIGlzIFJlc3BvbnNlID0+IHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgbWF5YmVSZXNwb25zZSA9PT0gJ29iamVjdCcgJiZcbiAgICBtYXliZVJlc3BvbnNlICE9PSBudWxsICYmXG4gICAgJ3N0YXR1cycgaW4gbWF5YmVSZXNwb25zZSAmJlxuICAgICdvaycgaW4gbWF5YmVSZXNwb25zZSAmJlxuICAgICdqc29uJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgdHlwZW9mIChtYXliZVJlc3BvbnNlIGFzIGFueSkuanNvbiA9PT0gJ2Z1bmN0aW9uJ1xuICApXG59XG5cbi8vIFN0b3JhZ2UgaGVscGVyc1xuZXhwb3J0IGNvbnN0IHNldEl0ZW1Bc3luYyA9IGFzeW5jIChcbiAgc3RvcmFnZTogU3VwcG9ydGVkU3RvcmFnZSxcbiAga2V5OiBzdHJpbmcsXG4gIGRhdGE6IGFueVxuKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGF3YWl0IHN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KGRhdGEpKVxufVxuXG5leHBvcnQgY29uc3QgZ2V0SXRlbUFzeW5jID0gYXN5bmMgKHN0b3JhZ2U6IFN1cHBvcnRlZFN0b3JhZ2UsIGtleTogc3RyaW5nKTogUHJvbWlzZTx1bmtub3duPiA9PiB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgc3RvcmFnZS5nZXRJdGVtKGtleSlcblxuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZW1vdmVJdGVtQXN5bmMgPSBhc3luYyAoc3RvcmFnZTogU3VwcG9ydGVkU3RvcmFnZSwga2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgYXdhaXQgc3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJhc2U2NFVSTCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3Qga2V5ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89J1xuICBsZXQgYmFzZTY0ID0gJydcbiAgbGV0IGNocjEsIGNocjIsIGNocjNcbiAgbGV0IGVuYzEsIGVuYzIsIGVuYzMsIGVuYzRcbiAgbGV0IGkgPSAwXG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZSgnLScsICcrJykucmVwbGFjZSgnXycsICcvJylcblxuICB3aGlsZSAoaSA8IHZhbHVlLmxlbmd0aCkge1xuICAgIGVuYzEgPSBrZXkuaW5kZXhPZih2YWx1ZS5jaGFyQXQoaSsrKSlcbiAgICBlbmMyID0ga2V5LmluZGV4T2YodmFsdWUuY2hhckF0KGkrKykpXG4gICAgZW5jMyA9IGtleS5pbmRleE9mKHZhbHVlLmNoYXJBdChpKyspKVxuICAgIGVuYzQgPSBrZXkuaW5kZXhPZih2YWx1ZS5jaGFyQXQoaSsrKSlcbiAgICBjaHIxID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KVxuICAgIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKVxuICAgIGNocjMgPSAoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzRcbiAgICBiYXNlNjQgPSBiYXNlNjQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjEpXG5cbiAgICBpZiAoZW5jMyAhPSA2NCAmJiBjaHIyICE9IDApIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMilcbiAgICB9XG4gICAgaWYgKGVuYzQgIT0gNjQgJiYgY2hyMyAhPSAwKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjMpXG4gICAgfVxuICB9XG4gIHJldHVybiBiYXNlNjRcbn1cblxuLyoqXG4gKiBBIGRlZmVycmVkIHJlcHJlc2VudHMgc29tZSBhc3luY2hyb25vdXMgd29yayB0aGF0IGlzIG5vdCB5ZXQgZmluaXNoZWQsIHdoaWNoXG4gKiBtYXkgb3IgbWF5IG5vdCBjdWxtaW5hdGUgaW4gYSB2YWx1ZS5cbiAqIFRha2VuIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9taWtlLW5vcnRoL3R5cGVzL2Jsb2IvbWFzdGVyL3NyYy9hc3luYy50c1xuICovXG5leHBvcnQgY2xhc3MgRGVmZXJyZWQ8VCA9IGFueT4ge1xuICBwdWJsaWMgc3RhdGljIHByb21pc2VDb25zdHJ1Y3RvcjogUHJvbWlzZUNvbnN0cnVjdG9yID0gUHJvbWlzZVxuXG4gIHB1YmxpYyByZWFkb25seSBwcm9taXNlITogUHJvbWlzZUxpa2U8VD5cblxuICBwdWJsaWMgcmVhZG9ubHkgcmVzb2x2ZSE6ICh2YWx1ZT86IFQgfCBQcm9taXNlTGlrZTxUPikgPT4gdm9pZFxuXG4gIHB1YmxpYyByZWFkb25seSByZWplY3QhOiAocmVhc29uPzogYW55KSA9PiBhbnlcblxuICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gICAgOyh0aGlzIGFzIGFueSkucHJvbWlzZSA9IG5ldyBEZWZlcnJlZC5wcm9taXNlQ29uc3RydWN0b3IoKHJlcywgcmVqKSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgIDsodGhpcyBhcyBhbnkpLnJlc29sdmUgPSByZXNcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgICAgOyh0aGlzIGFzIGFueSkucmVqZWN0ID0gcmVqXG4gICAgfSlcbiAgfVxufVxuXG4vLyBUYWtlbiBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zODU1MjAwMy9ob3ctdG8tZGVjb2RlLWp3dC10b2tlbi1pbi1qYXZhc2NyaXB0LXdpdGhvdXQtdXNpbmctYS1saWJyYXJ5XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlSldUUGF5bG9hZCh0b2tlbjogc3RyaW5nKSB7XG4gIC8vIFJlZ2V4IGNoZWNrcyBmb3IgYmFzZTY0dXJsIGZvcm1hdFxuICBjb25zdCBiYXNlNjRVcmxSZWdleCA9IC9eKFthLXowLTlfLV17NH0pKigkfFthLXowLTlfLV17M309PyR8W2EtejAtOV8tXXsyfSg9PSk/JCkkL2lcblxuICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJylcblxuICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdKV1QgaXMgbm90IHZhbGlkOiBub3QgYSBKV1Qgc3RydWN0dXJlJylcbiAgfVxuXG4gIGlmICghYmFzZTY0VXJsUmVnZXgudGVzdChwYXJ0c1sxXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVCBpcyBub3QgdmFsaWQ6IHBheWxvYWQgaXMgbm90IGluIGJhc2U2NHVybCBmb3JtYXQnKVxuICB9XG5cbiAgY29uc3QgYmFzZTY0VXJsID0gcGFydHNbMV1cbiAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlQmFzZTY0VVJMKGJhc2U2NFVybCkpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBudWxsIGFmdGVyIHNvbWUgdGltZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNsZWVwKHRpbWU6IG51bWJlcik6IFByb21pc2U8bnVsbD4ge1xuICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKGFjY2VwdCkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4gYWNjZXB0KG51bGwpLCB0aW1lKVxuICB9KVxufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBwcm92aWRlZCBhc3luYyBmdW5jdGlvbiBpbnRvIGEgcmV0cnlhYmxlIGZ1bmN0aW9uLiBFYWNoIHJlc3VsdFxuICogb3IgdGhyb3duIGVycm9yIGlzIHNlbnQgdG8gdGhlIGlzUmV0cnlhYmxlIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCByZXR1cm4gdHJ1ZVxuICogaWYgdGhlIGZ1bmN0aW9uIHNob3VsZCBydW4gYWdhaW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXRyeWFibGU8VD4oXG4gIGZuOiAoYXR0ZW1wdDogbnVtYmVyKSA9PiBQcm9taXNlPFQ+LFxuICBpc1JldHJ5YWJsZTogKGF0dGVtcHQ6IG51bWJlciwgZXJyb3I6IGFueSB8IG51bGwsIHJlc3VsdD86IFQpID0+IGJvb2xlYW5cbik6IFByb21pc2U8VD4ge1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8VD4oKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gICAgOyhhc3luYyAoKSA9PiB7XG4gICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IEluZmluaXR5OyBhdHRlbXB0KyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmbihhdHRlbXB0KVxuXG4gICAgICAgICAgaWYgKCFpc1JldHJ5YWJsZShhdHRlbXB0LCBudWxsLCByZXN1bHQpKSB7XG4gICAgICAgICAgICBhY2NlcHQocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICBpZiAoIWlzUmV0cnlhYmxlKGF0dGVtcHQsIGUpKSB7XG4gICAgICAgICAgICByZWplY3QoZSlcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKClcbiAgfSlcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiBkZWMyaGV4KGRlYzogbnVtYmVyKSB7XG4gIHJldHVybiAoJzAnICsgZGVjLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC0yKVxufVxuXG4vLyBGdW5jdGlvbnMgYmVsb3cgdGFrZW4gZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjMzMDk0MDkvY3JlYXRpbmctYS1jb2RlLXZlcmlmaWVyLWFuZC1jaGFsbGVuZ2UtZm9yLXBrY2UtYXV0aC1vbi1zcG90aWZ5LWFwaS1pbi1yZWFjdGpzXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQS0NFVmVyaWZpZXIoKSB7XG4gIGNvbnN0IHZlcmlmaWVyTGVuZ3RoID0gNTZcbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkodmVyaWZpZXJMZW5ndGgpXG4gIGlmICh0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IGNoYXJTZXQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktLl9+J1xuICAgIGNvbnN0IGNoYXJTZXRMZW4gPSBjaGFyU2V0Lmxlbmd0aFxuICAgIGxldCB2ZXJpZmllciA9ICcnXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJpZmllckxlbmd0aDsgaSsrKSB7XG4gICAgICB2ZXJpZmllciArPSBjaGFyU2V0LmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyU2V0TGVuKSlcbiAgICB9XG4gICAgcmV0dXJuIHZlcmlmaWVyXG4gIH1cbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSlcbiAgcmV0dXJuIEFycmF5LmZyb20oYXJyYXksIGRlYzJoZXgpLmpvaW4oJycpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNoYTI1NihyYW5kb21TdHJpbmc6IHN0cmluZykge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcbiAgY29uc3QgZW5jb2RlZERhdGEgPSBlbmNvZGVyLmVuY29kZShyYW5kb21TdHJpbmcpXG4gIGNvbnN0IGhhc2ggPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGVuY29kZWREYXRhKVxuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGhhc2gpXG5cbiAgcmV0dXJuIEFycmF5LmZyb20oYnl0ZXMpXG4gICAgLm1hcCgoYykgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShjKSlcbiAgICAuam9pbignJylcbn1cblxuZnVuY3Rpb24gYmFzZTY0dXJsZW5jb2RlKHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBidG9hKHN0cikucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJykucmVwbGFjZSgvPSskLywgJycpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVBLQ0VDaGFsbGVuZ2UodmVyaWZpZXI6IHN0cmluZykge1xuICBjb25zdCBoYXNDcnlwdG9TdXBwb3J0ID1cbiAgICB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjcnlwdG8uc3VidGxlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCdcblxuICBpZiAoIWhhc0NyeXB0b1N1cHBvcnQpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnV2ViQ3J5cHRvIEFQSSBpcyBub3Qgc3VwcG9ydGVkLiBDb2RlIGNoYWxsZW5nZSBtZXRob2Qgd2lsbCBkZWZhdWx0IHRvIHVzZSBwbGFpbiBpbnN0ZWFkIG9mIHNoYTI1Ni4nXG4gICAgKVxuICAgIHJldHVybiB2ZXJpZmllclxuICB9XG4gIGNvbnN0IGhhc2hlZCA9IGF3YWl0IHNoYTI1Nih2ZXJpZmllcilcbiAgcmV0dXJuIGJhc2U2NHVybGVuY29kZShoYXNoZWQpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKFxuICBzdG9yYWdlOiBTdXBwb3J0ZWRTdG9yYWdlLFxuICBzdG9yYWdlS2V5OiBzdHJpbmcsXG4gIGlzUGFzc3dvcmRSZWNvdmVyeSA9IGZhbHNlXG4pIHtcbiAgY29uc3QgY29kZVZlcmlmaWVyID0gZ2VuZXJhdGVQS0NFVmVyaWZpZXIoKVxuICBsZXQgc3RvcmVkQ29kZVZlcmlmaWVyID0gY29kZVZlcmlmaWVyXG4gIGlmIChpc1Bhc3N3b3JkUmVjb3ZlcnkpIHtcbiAgICBzdG9yZWRDb2RlVmVyaWZpZXIgKz0gJy9QQVNTV09SRF9SRUNPVkVSWSdcbiAgfVxuICBhd2FpdCBzZXRJdGVtQXN5bmMoc3RvcmFnZSwgYCR7c3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmAsIHN0b3JlZENvZGVWZXJpZmllcilcbiAgY29uc3QgY29kZUNoYWxsZW5nZSA9IGF3YWl0IGdlbmVyYXRlUEtDRUNoYWxsZW5nZShjb2RlVmVyaWZpZXIpXG4gIGNvbnN0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBjb2RlVmVyaWZpZXIgPT09IGNvZGVDaGFsbGVuZ2UgPyAncGxhaW4nIDogJ3MyNTYnXG4gIHJldHVybiBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF1cbn1cblxuLyoqIFBhcnNlcyB0aGUgQVBJIHZlcnNpb24gd2hpY2ggaXMgMllZWS1NTS1ERC4gKi9cbmNvbnN0IEFQSV9WRVJTSU9OX1JFR0VYID0gL14yWzAtOV17M30tKDBbMS05XXwxWzAtMl0pLSgwWzEtOV18MVswLTldfDJbMC05XXwzWzAtMV0pJC9pXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbihyZXNwb25zZTogUmVzcG9uc2UpIHtcbiAgY29uc3QgYXBpVmVyc2lvbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FKVxuXG4gIGlmICghYXBpVmVyc2lvbikge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAoIWFwaVZlcnNpb24ubWF0Y2goQVBJX1ZFUlNJT05fUkVHRVgpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke2FwaVZlcnNpb259VDAwOjAwOjAwLjBaYClcbiAgICByZXR1cm4gZGF0ZVxuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG4iLCAiaW1wb3J0IHsgV2Vha1Bhc3N3b3JkUmVhc29ucyB9IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQgeyBFcnJvckNvZGUgfSBmcm9tICcuL2Vycm9yLWNvZGVzJ1xuXG5leHBvcnQgY2xhc3MgQXV0aEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogRXJyb3IgY29kZSBhc3NvY2lhdGVkIHdpdGggdGhlIGVycm9yLiBNb3N0IGVycm9ycyBjb21pbmcgZnJvbVxuICAgKiBIVFRQIHJlc3BvbnNlcyB3aWxsIGhhdmUgYSBjb2RlLCB0aG91Z2ggc29tZSBlcnJvcnMgdGhhdCBvY2N1clxuICAgKiBiZWZvcmUgYSByZXNwb25zZSBpcyByZWNlaXZlZCB3aWxsIG5vdCBoYXZlIG9uZSBwcmVzZW50LiBJbiB0aGF0XG4gICAqIGNhc2Uge0BsaW5rICNzdGF0dXN9IHdpbGwgYWxzbyBiZSB1bmRlZmluZWQuXG4gICAqL1xuICBjb2RlOiBFcnJvckNvZGUgfCAoc3RyaW5nICYge30pIHwgdW5kZWZpbmVkXG5cbiAgLyoqIEhUVFAgc3RhdHVzIGNvZGUgdGhhdCBjYXVzZWQgdGhlIGVycm9yLiAqL1xuICBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZFxuXG4gIHByb3RlY3RlZCBfX2lzQXV0aEVycm9yID0gdHJ1ZVxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgc3RhdHVzPzogbnVtYmVyLCBjb2RlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQXV0aEVycm9yJ1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzXG4gICAgdGhpcy5jb2RlID0gY29kZVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEF1dGhFcnJvciB7XG4gIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdfX2lzQXV0aEVycm9yJyBpbiBlcnJvclxufVxuXG5leHBvcnQgY2xhc3MgQXV0aEFwaUVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgc3RhdHVzOiBudW1iZXJcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyLCBjb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBzdGF0dXMsIGNvZGUpXG4gICAgdGhpcy5uYW1lID0gJ0F1dGhBcGlFcnJvcidcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c1xuICAgIHRoaXMuY29kZSA9IGNvZGVcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoQXBpRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBBdXRoQXBpRXJyb3Ige1xuICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoQXBpRXJyb3InXG59XG5cbmV4cG9ydCBjbGFzcyBBdXRoVW5rbm93bkVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgb3JpZ2luYWxFcnJvcjogdW5rbm93blxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgb3JpZ2luYWxFcnJvcjogdW5rbm93bikge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0F1dGhVbmtub3duRXJyb3InXG4gICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvclxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDdXN0b21BdXRoRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xuICBuYW1lOiBzdHJpbmdcbiAgc3RhdHVzOiBudW1iZXJcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgc3RhdHVzOiBudW1iZXIsIGNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHN0YXR1cywgY29kZSlcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXNcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignQXV0aCBzZXNzaW9uIG1pc3NpbmchJywgJ0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yJywgNDAwLCB1bmRlZmluZWQpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoZXJyb3I6IGFueSk6IGVycm9yIGlzIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIHtcbiAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aFNlc3Npb25NaXNzaW5nRXJyb3InXG59XG5cbmV4cG9ydCBjbGFzcyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdBdXRoIHNlc3Npb24gb3IgdXNlciBtaXNzaW5nJywgJ0F1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yJywgNTAwLCB1bmRlZmluZWQpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3InLCA0MDAsIHVuZGVmaW5lZClcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgZGV0YWlsczogeyBlcnJvcjogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgZGV0YWlsczogeyBlcnJvcjogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcicsIDUwMCwgdW5kZWZpbmVkKVxuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHNcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIGRldGFpbHM6IHRoaXMuZGV0YWlscyxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKFxuICBlcnJvcjogYW55XG4pOiBlcnJvciBpcyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3Ige1xuICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3InXG59XG5cbmV4cG9ydCBjbGFzcyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICBkZXRhaWxzOiB7IGVycm9yOiBzdHJpbmc7IGNvZGU6IHN0cmluZyB9IHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGRldGFpbHM6IHsgZXJyb3I6IHN0cmluZzsgY29kZTogc3RyaW5nIH0gfCBudWxsID0gbnVsbCkge1xuICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3InLCA1MDAsIHVuZGVmaW5lZClcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzXG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBkZXRhaWxzOiB0aGlzLmRldGFpbHMsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgc3RhdHVzOiBudW1iZXIpIHtcbiAgICBzdXBlcihtZXNzYWdlLCAnQXV0aFJldHJ5YWJsZUZldGNoRXJyb3InLCBzdGF0dXMsIHVuZGVmaW5lZClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEF1dGhSZXRyeWFibGVGZXRjaEVycm9yIHtcbiAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aFJldHJ5YWJsZUZldGNoRXJyb3InXG59XG5cbi8qKlxuICogVGhpcyBlcnJvciBpcyB0aHJvd24gb24gY2VydGFpbiBtZXRob2RzIHdoZW4gdGhlIHBhc3N3b3JkIHVzZWQgaXMgZGVlbWVkXG4gKiB3ZWFrLiBJbnNwZWN0IHRoZSByZWFzb25zIHRvIGlkZW50aWZ5IHdoYXQgcGFzc3dvcmQgc3RyZW5ndGggcnVsZXMgYXJlXG4gKiBpbmFkZXF1YXRlLlxuICovXG5leHBvcnQgY2xhc3MgQXV0aFdlYWtQYXNzd29yZEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgLyoqXG4gICAqIFJlYXNvbnMgd2h5IHRoZSBwYXNzd29yZCBpcyBkZWVtZWQgd2Vhay5cbiAgICovXG4gIHJlYXNvbnM6IFdlYWtQYXNzd29yZFJlYXNvbnNbXVxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgc3RhdHVzOiBudW1iZXIsIHJlYXNvbnM6IHN0cmluZ1tdKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhXZWFrUGFzc3dvcmRFcnJvcicsIHN0YXR1cywgJ3dlYWtfcGFzc3dvcmQnKVxuXG4gICAgdGhpcy5yZWFzb25zID0gcmVhc29uc1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhXZWFrUGFzc3dvcmRFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEF1dGhXZWFrUGFzc3dvcmRFcnJvciB7XG4gIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhXZWFrUGFzc3dvcmRFcnJvcidcbn1cbiIsICJpbXBvcnQgeyBBUElfVkVSU0lPTlMsIEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FIH0gZnJvbSAnLi9jb25zdGFudHMnXG5pbXBvcnQgeyBleHBpcmVzQXQsIGxvb2tzTGlrZUZldGNoUmVzcG9uc2UsIHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uIH0gZnJvbSAnLi9oZWxwZXJzJ1xuaW1wb3J0IHtcbiAgQXV0aFJlc3BvbnNlLFxuICBBdXRoUmVzcG9uc2VQYXNzd29yZCxcbiAgU1NPUmVzcG9uc2UsXG4gIEdlbmVyYXRlTGlua1Byb3BlcnRpZXMsXG4gIEdlbmVyYXRlTGlua1Jlc3BvbnNlLFxuICBVc2VyLFxuICBVc2VyUmVzcG9uc2UsXG59IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQge1xuICBBdXRoQXBpRXJyb3IsXG4gIEF1dGhSZXRyeWFibGVGZXRjaEVycm9yLFxuICBBdXRoV2Vha1Bhc3N3b3JkRXJyb3IsXG4gIEF1dGhVbmtub3duRXJyb3IsXG4gIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yLFxufSBmcm9tICcuL2Vycm9ycydcblxuZXhwb3J0IHR5cGUgRmV0Y2ggPSB0eXBlb2YgZmV0Y2hcblxuZXhwb3J0IGludGVyZmFjZSBGZXRjaE9wdGlvbnMge1xuICBoZWFkZXJzPzoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9XG4gIG5vUmVzb2x2ZUpzb24/OiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hQYXJhbWV0ZXJzIHtcbiAgc2lnbmFsPzogQWJvcnRTaWduYWxcbn1cblxuZXhwb3J0IHR5cGUgUmVxdWVzdE1ldGhvZFR5cGUgPSAnR0VUJyB8ICdQT1NUJyB8ICdQVVQnIHwgJ0RFTEVURSdcblxuY29uc3QgX2dldEVycm9yTWVzc2FnZSA9IChlcnI6IGFueSk6IHN0cmluZyA9PlxuICBlcnIubXNnIHx8IGVyci5tZXNzYWdlIHx8IGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fCBlcnIuZXJyb3IgfHwgSlNPTi5zdHJpbmdpZnkoZXJyKVxuXG5jb25zdCBORVRXT1JLX0VSUk9SX0NPREVTID0gWzUwMiwgNTAzLCA1MDRdXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcjogdW5rbm93bikge1xuICBpZiAoIWxvb2tzTGlrZUZldGNoUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCAwKVxuICB9XG5cbiAgaWYgKE5FVFdPUktfRVJST1JfQ09ERVMuaW5jbHVkZXMoZXJyb3Iuc3RhdHVzKSkge1xuICAgIC8vIHN0YXR1cyBpbiA1MDAuLi41OTkgcmFuZ2UgLSBzZXJ2ZXIgaGFkIGFuIGVycm9yLCByZXF1ZXN0IG1pZ2h0IGJlIHJldHJ5ZWQuXG4gICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCBlcnJvci5zdGF0dXMpXG4gIH1cblxuICBsZXQgZGF0YTogYW55XG4gIHRyeSB7XG4gICAgZGF0YSA9IGF3YWl0IGVycm9yLmpzb24oKVxuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICB0aHJvdyBuZXcgQXV0aFVua25vd25FcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGUpLCBlKVxuICB9XG5cbiAgbGV0IGVycm9yQ29kZTogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG5cbiAgY29uc3QgcmVzcG9uc2VBUElWZXJzaW9uID0gcGFyc2VSZXNwb25zZUFQSVZlcnNpb24oZXJyb3IpXG4gIGlmIChcbiAgICByZXNwb25zZUFQSVZlcnNpb24gJiZcbiAgICByZXNwb25zZUFQSVZlcnNpb24uZ2V0VGltZSgpID49IEFQSV9WRVJTSU9OU1snMjAyNC0wMS0wMSddLnRpbWVzdGFtcCAmJlxuICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgIGRhdGEgJiZcbiAgICB0eXBlb2YgZGF0YS5jb2RlID09PSAnc3RyaW5nJ1xuICApIHtcbiAgICBlcnJvckNvZGUgPSBkYXRhLmNvZGVcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YSAmJiB0eXBlb2YgZGF0YS5lcnJvcl9jb2RlID09PSAnc3RyaW5nJykge1xuICAgIGVycm9yQ29kZSA9IGRhdGEuZXJyb3JfY29kZVxuICB9XG5cbiAgaWYgKCFlcnJvckNvZGUpIHtcbiAgICAvLyBMZWdhY3kgc3VwcG9ydCBmb3Igd2VhayBwYXNzd29yZCBlcnJvcnMsIHdoZW4gdGhlcmUgd2VyZSBubyBlcnJvciBjb2Rlc1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgZGF0YSAmJlxuICAgICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIGRhdGEud2Vha19wYXNzd29yZCAmJlxuICAgICAgQXJyYXkuaXNBcnJheShkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucykgJiZcbiAgICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zLmxlbmd0aCAmJlxuICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMucmVkdWNlKChhOiBib29sZWFuLCBpOiBhbnkpID0+IGEgJiYgdHlwZW9mIGkgPT09ICdzdHJpbmcnLCB0cnVlKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEF1dGhXZWFrUGFzc3dvcmRFcnJvcihcbiAgICAgICAgX2dldEVycm9yTWVzc2FnZShkYXRhKSxcbiAgICAgICAgZXJyb3Iuc3RhdHVzLFxuICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29uc1xuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChlcnJvckNvZGUgPT09ICd3ZWFrX3Bhc3N3b3JkJykge1xuICAgIHRocm93IG5ldyBBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoXG4gICAgICBfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLFxuICAgICAgZXJyb3Iuc3RhdHVzLFxuICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkPy5yZWFzb25zIHx8IFtdXG4gICAgKVxuICB9IGVsc2UgaWYgKGVycm9yQ29kZSA9PT0gJ3Nlc3Npb25fbm90X2ZvdW5kJykge1xuICAgIC8vIFRoZSBgc2Vzc2lvbl9pZGAgaW5zaWRlIHRoZSBKV1QgZG9lcyBub3QgY29ycmVzcG9uZCB0byBhIHJvdyBpbiB0aGVcbiAgICAvLyBgc2Vzc2lvbnNgIHRhYmxlLiBUaGlzIHVzdWFsbHkgbWVhbnMgdGhlIHVzZXIgaGFzIHNpZ25lZCBvdXQsIGhhcyBiZWVuXG4gICAgLy8gZGVsZXRlZCwgb3IgdGhlaXIgc2Vzc2lvbiBoYXMgc29tZWhvdyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcbiAgfVxuXG4gIHRocm93IG5ldyBBdXRoQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZShkYXRhKSwgZXJyb3Iuc3RhdHVzIHx8IDUwMCwgZXJyb3JDb2RlKVxufVxuXG5jb25zdCBfZ2V0UmVxdWVzdFBhcmFtcyA9IChcbiAgbWV0aG9kOiBSZXF1ZXN0TWV0aG9kVHlwZSxcbiAgb3B0aW9ucz86IEZldGNoT3B0aW9ucyxcbiAgcGFyYW1ldGVycz86IEZldGNoUGFyYW1ldGVycyxcbiAgYm9keT86IG9iamVjdFxuKSA9PiB7XG4gIGNvbnN0IHBhcmFtczogeyBbazogc3RyaW5nXTogYW55IH0gPSB7IG1ldGhvZCwgaGVhZGVyczogb3B0aW9ucz8uaGVhZGVycyB8fCB7fSB9XG5cbiAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICByZXR1cm4gcGFyYW1zXG4gIH1cblxuICBwYXJhbXMuaGVhZGVycyA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9VVRGLTgnLCAuLi5vcHRpb25zPy5oZWFkZXJzIH1cbiAgcGFyYW1zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KVxuICByZXR1cm4geyAuLi5wYXJhbXMsIC4uLnBhcmFtZXRlcnMgfVxufVxuXG5pbnRlcmZhY2UgR290cnVlUmVxdWVzdE9wdGlvbnMgZXh0ZW5kcyBGZXRjaE9wdGlvbnMge1xuICBqd3Q/OiBzdHJpbmdcbiAgcmVkaXJlY3RUbz86IHN0cmluZ1xuICBib2R5Pzogb2JqZWN0XG4gIHF1ZXJ5PzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIGFwaSByZXNwb25zZSBmcm9tIGdvdHJ1ZSBpbnRvIGEgZGVzaXJhYmxlIC8gc3RhbmRhcmRpc2VkIGZvcm1hdFxuICAgKi9cbiAgeGZvcm0/OiAoZGF0YTogYW55KSA9PiBhbnlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9yZXF1ZXN0KFxuICBmZXRjaGVyOiBGZXRjaCxcbiAgbWV0aG9kOiBSZXF1ZXN0TWV0aG9kVHlwZSxcbiAgdXJsOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBHb3RydWVSZXF1ZXN0T3B0aW9uc1xuKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgLi4ub3B0aW9ucz8uaGVhZGVycyxcbiAgfVxuXG4gIGlmICghaGVhZGVyc1tBUElfVkVSU0lPTl9IRUFERVJfTkFNRV0pIHtcbiAgICBoZWFkZXJzW0FQSV9WRVJTSU9OX0hFQURFUl9OQU1FXSA9IEFQSV9WRVJTSU9OU1snMjAyNC0wMS0wMSddLm5hbWVcbiAgfVxuXG4gIGlmIChvcHRpb25zPy5qd3QpIHtcbiAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7b3B0aW9ucy5qd3R9YFxuICB9XG5cbiAgY29uc3QgcXMgPSBvcHRpb25zPy5xdWVyeSA/PyB7fVxuICBpZiAob3B0aW9ucz8ucmVkaXJlY3RUbykge1xuICAgIHFzWydyZWRpcmVjdF90byddID0gb3B0aW9ucy5yZWRpcmVjdFRvXG4gIH1cblxuICBjb25zdCBxdWVyeVN0cmluZyA9IE9iamVjdC5rZXlzKHFzKS5sZW5ndGggPyAnPycgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHFzKS50b1N0cmluZygpIDogJydcbiAgY29uc3QgZGF0YSA9IGF3YWl0IF9oYW5kbGVSZXF1ZXN0KFxuICAgIGZldGNoZXIsXG4gICAgbWV0aG9kLFxuICAgIHVybCArIHF1ZXJ5U3RyaW5nLFxuICAgIHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICBub1Jlc29sdmVKc29uOiBvcHRpb25zPy5ub1Jlc29sdmVKc29uLFxuICAgIH0sXG4gICAge30sXG4gICAgb3B0aW9ucz8uYm9keVxuICApXG4gIHJldHVybiBvcHRpb25zPy54Zm9ybSA/IG9wdGlvbnM/Lnhmb3JtKGRhdGEpIDogeyBkYXRhOiB7IC4uLmRhdGEgfSwgZXJyb3I6IG51bGwgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBfaGFuZGxlUmVxdWVzdChcbiAgZmV0Y2hlcjogRmV0Y2gsXG4gIG1ldGhvZDogUmVxdWVzdE1ldGhvZFR5cGUsXG4gIHVybDogc3RyaW5nLFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzLFxuICBib2R5Pzogb2JqZWN0XG4pOiBQcm9taXNlPGFueT4ge1xuICBjb25zdCByZXF1ZXN0UGFyYW1zID0gX2dldFJlcXVlc3RQYXJhbXMobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KVxuXG4gIGxldCByZXN1bHQ6IGFueVxuXG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgZmV0Y2hlcih1cmwsIHtcbiAgICAgIC4uLnJlcXVlc3RQYXJhbXMsXG4gICAgfSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoZSlcblxuICAgIC8vIGZldGNoIGZhaWxlZCwgbGlrZWx5IGR1ZSB0byBhIG5ldHdvcmsgb3IgQ09SUyBlcnJvclxuICAgIHRocm93IG5ldyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGUpLCAwKVxuICB9XG5cbiAgaWYgKCFyZXN1bHQub2spIHtcbiAgICBhd2FpdCBoYW5kbGVFcnJvcihyZXN1bHQpXG4gIH1cblxuICBpZiAob3B0aW9ucz8ubm9SZXNvbHZlSnNvbikge1xuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3VsdC5qc29uKClcbiAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgYXdhaXQgaGFuZGxlRXJyb3IoZSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX3Nlc3Npb25SZXNwb25zZShkYXRhOiBhbnkpOiBBdXRoUmVzcG9uc2Uge1xuICBsZXQgc2Vzc2lvbiA9IG51bGxcbiAgaWYgKGhhc1Nlc3Npb24oZGF0YSkpIHtcbiAgICBzZXNzaW9uID0geyAuLi5kYXRhIH1cblxuICAgIGlmICghZGF0YS5leHBpcmVzX2F0KSB7XG4gICAgICBzZXNzaW9uLmV4cGlyZXNfYXQgPSBleHBpcmVzQXQoZGF0YS5leHBpcmVzX2luKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVzZXI6IFVzZXIgPSBkYXRhLnVzZXIgPz8gKGRhdGEgYXMgVXNlcilcbiAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uLCB1c2VyIH0sIGVycm9yOiBudWxsIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZChkYXRhOiBhbnkpOiBBdXRoUmVzcG9uc2VQYXNzd29yZCB7XG4gIGNvbnN0IHJlc3BvbnNlID0gX3Nlc3Npb25SZXNwb25zZShkYXRhKSBhcyBBdXRoUmVzcG9uc2VQYXNzd29yZFxuXG4gIGlmIChcbiAgICAhcmVzcG9uc2UuZXJyb3IgJiZcbiAgICBkYXRhLndlYWtfcGFzc3dvcmQgJiZcbiAgICB0eXBlb2YgZGF0YS53ZWFrX3Bhc3N3b3JkID09PSAnb2JqZWN0JyAmJlxuICAgIEFycmF5LmlzQXJyYXkoZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMpICYmXG4gICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMubGVuZ3RoICYmXG4gICAgZGF0YS53ZWFrX3Bhc3N3b3JkLm1lc3NhZ2UgJiZcbiAgICB0eXBlb2YgZGF0YS53ZWFrX3Bhc3N3b3JkLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmXG4gICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMucmVkdWNlKChhOiBib29sZWFuLCBpOiBhbnkpID0+IGEgJiYgdHlwZW9mIGkgPT09ICdzdHJpbmcnLCB0cnVlKVxuICApIHtcbiAgICByZXNwb25zZS5kYXRhLndlYWtfcGFzc3dvcmQgPSBkYXRhLndlYWtfcGFzc3dvcmRcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX3VzZXJSZXNwb25zZShkYXRhOiBhbnkpOiBVc2VyUmVzcG9uc2Uge1xuICBjb25zdCB1c2VyOiBVc2VyID0gZGF0YS51c2VyID8/IChkYXRhIGFzIFVzZXIpXG4gIHJldHVybiB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogbnVsbCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfc3NvUmVzcG9uc2UoZGF0YTogYW55KTogU1NPUmVzcG9uc2Uge1xuICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2VuZXJhdGVMaW5rUmVzcG9uc2UoZGF0YTogYW55KTogR2VuZXJhdGVMaW5rUmVzcG9uc2Uge1xuICBjb25zdCB7IGFjdGlvbl9saW5rLCBlbWFpbF9vdHAsIGhhc2hlZF90b2tlbiwgcmVkaXJlY3RfdG8sIHZlcmlmaWNhdGlvbl90eXBlLCAuLi5yZXN0IH0gPSBkYXRhXG5cbiAgY29uc3QgcHJvcGVydGllczogR2VuZXJhdGVMaW5rUHJvcGVydGllcyA9IHtcbiAgICBhY3Rpb25fbGluayxcbiAgICBlbWFpbF9vdHAsXG4gICAgaGFzaGVkX3Rva2VuLFxuICAgIHJlZGlyZWN0X3RvLFxuICAgIHZlcmlmaWNhdGlvbl90eXBlLFxuICB9XG5cbiAgY29uc3QgdXNlcjogVXNlciA9IHsgLi4ucmVzdCB9XG4gIHJldHVybiB7XG4gICAgZGF0YToge1xuICAgICAgcHJvcGVydGllcyxcbiAgICAgIHVzZXIsXG4gICAgfSxcbiAgICBlcnJvcjogbnVsbCxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX25vUmVzb2x2ZUpzb25SZXNwb25zZShkYXRhOiBhbnkpOiBSZXNwb25zZSB7XG4gIHJldHVybiBkYXRhXG59XG5cbi8qKlxuICogaGFzU2Vzc2lvbiBjaGVja3MgaWYgdGhlIHJlc3BvbnNlIG9iamVjdCBjb250YWlucyBhIHZhbGlkIHNlc3Npb25cbiAqIEBwYXJhbSBkYXRhIEEgcmVzcG9uc2Ugb2JqZWN0XG4gKiBAcmV0dXJucyB0cnVlIGlmIGEgc2Vzc2lvbiBpcyBpbiB0aGUgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gaGFzU2Vzc2lvbihkYXRhOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIGRhdGEuYWNjZXNzX3Rva2VuICYmIGRhdGEucmVmcmVzaF90b2tlbiAmJiBkYXRhLmV4cGlyZXNfaW5cbn1cbiIsICJpbXBvcnQge1xuICBGZXRjaCxcbiAgX2dlbmVyYXRlTGlua1Jlc3BvbnNlLFxuICBfbm9SZXNvbHZlSnNvblJlc3BvbnNlLFxuICBfcmVxdWVzdCxcbiAgX3VzZXJSZXNwb25zZSxcbn0gZnJvbSAnLi9saWIvZmV0Y2gnXG5pbXBvcnQgeyByZXNvbHZlRmV0Y2ggfSBmcm9tICcuL2xpYi9oZWxwZXJzJ1xuaW1wb3J0IHtcbiAgQWRtaW5Vc2VyQXR0cmlidXRlcyxcbiAgR2VuZXJhdGVMaW5rUGFyYW1zLFxuICBHZW5lcmF0ZUxpbmtSZXNwb25zZSxcbiAgUGFnaW5hdGlvbixcbiAgVXNlcixcbiAgVXNlclJlc3BvbnNlLFxuICBHb1RydWVBZG1pbk1GQUFwaSxcbiAgQXV0aE1GQUFkbWluRGVsZXRlRmFjdG9yUGFyYW1zLFxuICBBdXRoTUZBQWRtaW5EZWxldGVGYWN0b3JSZXNwb25zZSxcbiAgQXV0aE1GQUFkbWluTGlzdEZhY3RvcnNQYXJhbXMsXG4gIEF1dGhNRkFBZG1pbkxpc3RGYWN0b3JzUmVzcG9uc2UsXG4gIFBhZ2VQYXJhbXMsXG59IGZyb20gJy4vbGliL3R5cGVzJ1xuaW1wb3J0IHsgQXV0aEVycm9yLCBpc0F1dGhFcnJvciB9IGZyb20gJy4vbGliL2Vycm9ycydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR29UcnVlQWRtaW5BcGkge1xuICAvKiogQ29udGFpbnMgYWxsIE1GQSBhZG1pbmlzdHJhdGlvbiBtZXRob2RzLiAqL1xuICBtZmE6IEdvVHJ1ZUFkbWluTUZBQXBpXG5cbiAgcHJvdGVjdGVkIHVybDogc3RyaW5nXG4gIHByb3RlY3RlZCBoZWFkZXJzOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gIH1cbiAgcHJvdGVjdGVkIGZldGNoOiBGZXRjaFxuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwgPSAnJyxcbiAgICBoZWFkZXJzID0ge30sXG4gICAgZmV0Y2gsXG4gIH06IHtcbiAgICB1cmw6IHN0cmluZ1xuICAgIGhlYWRlcnM/OiB7XG4gICAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgICB9XG4gICAgZmV0Y2g/OiBGZXRjaFxuICB9KSB7XG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaClcbiAgICB0aGlzLm1mYSA9IHtcbiAgICAgIGxpc3RGYWN0b3JzOiB0aGlzLl9saXN0RmFjdG9ycy5iaW5kKHRoaXMpLFxuICAgICAgZGVsZXRlRmFjdG9yOiB0aGlzLl9kZWxldGVGYWN0b3IuYmluZCh0aGlzKSxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGxvZ2dlZC1pbiBzZXNzaW9uLlxuICAgKiBAcGFyYW0gand0IEEgdmFsaWQsIGxvZ2dlZC1pbiBKV1QuXG4gICAqIEBwYXJhbSBzY29wZSBUaGUgbG9nb3V0IHNvcGUuXG4gICAqL1xuICBhc3luYyBzaWduT3V0KFxuICAgIGp3dDogc3RyaW5nLFxuICAgIHNjb3BlOiAnZ2xvYmFsJyB8ICdsb2NhbCcgfCAnb3RoZXJzJyA9ICdnbG9iYWwnXG4gICk6IFByb21pc2U8eyBkYXRhOiBudWxsOyBlcnJvcjogQXV0aEVycm9yIHwgbnVsbCB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2xvZ291dD9zY29wZT0ke3Njb3BlfWAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBqd3QsXG4gICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYW4gaW52aXRlIGxpbmsgdG8gYW4gZW1haWwgYWRkcmVzcy5cbiAgICogQHBhcmFtIGVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSB1c2VyLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gYmUgaW5jbHVkZWQgd2hlbiBpbnZpdGluZy5cbiAgICovXG4gIGFzeW5jIGludml0ZVVzZXJCeUVtYWlsKFxuICAgIGVtYWlsOiBzdHJpbmcsXG4gICAgb3B0aW9uczoge1xuICAgICAgLyoqIEEgY3VzdG9tIGRhdGEgb2JqZWN0IHRvIHN0b3JlIGFkZGl0aW9uYWwgbWV0YWRhdGEgYWJvdXQgdGhlIHVzZXIuIFRoaXMgbWFwcyB0byB0aGUgYGF1dGgudXNlcnMudXNlcl9tZXRhZGF0YWAgY29sdW1uLiAqL1xuICAgICAgZGF0YT86IG9iamVjdFxuXG4gICAgICAvKiogVGhlIFVSTCB3aGljaCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBlbWFpbCBsaW5rIHNlbnQgdG8gdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLiBPbmNlIGNsaWNrZWQgdGhlIHVzZXIgd2lsbCBlbmQgdXAgb24gdGhpcyBVUkwuICovXG4gICAgICByZWRpcmVjdFRvPzogc3RyaW5nXG4gICAgfSA9IHt9XG4gICk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9pbnZpdGVgLCB7XG4gICAgICAgIGJvZHk6IHsgZW1haWwsIGRhdGE6IG9wdGlvbnMuZGF0YSB9LFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMucmVkaXJlY3RUbyxcbiAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBlbWFpbCBsaW5rcyBhbmQgT1RQcyB0byBiZSBzZW50IHZpYSBhIGN1c3RvbSBlbWFpbCBwcm92aWRlci5cbiAgICogQHBhcmFtIGVtYWlsIFRoZSB1c2VyJ3MgZW1haWwuXG4gICAqIEBwYXJhbSBvcHRpb25zLnBhc3N3b3JkIFVzZXIgcGFzc3dvcmQuIEZvciBzaWdudXAgb25seS5cbiAgICogQHBhcmFtIG9wdGlvbnMuZGF0YSBPcHRpb25hbCB1c2VyIG1ldGFkYXRhLiBGb3Igc2lnbnVwIG9ubHkuXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gVGhlIHJlZGlyZWN0IHVybCB3aGljaCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGdlbmVyYXRlZCBsaW5rXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZUxpbmsocGFyYW1zOiBHZW5lcmF0ZUxpbmtQYXJhbXMpOiBQcm9taXNlPEdlbmVyYXRlTGlua1Jlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgb3B0aW9ucywgLi4ucmVzdCB9ID0gcGFyYW1zXG4gICAgICBjb25zdCBib2R5OiBhbnkgPSB7IC4uLnJlc3QsIC4uLm9wdGlvbnMgfVxuICAgICAgaWYgKCduZXdFbWFpbCcgaW4gcmVzdCkge1xuICAgICAgICAvLyByZXBsYWNlIG5ld0VtYWlsIHdpdGggbmV3X2VtYWlsIGluIHJlcXVlc3QgYm9keVxuICAgICAgICBib2R5Lm5ld19lbWFpbCA9IHJlc3Q/Lm5ld0VtYWlsXG4gICAgICAgIGRlbGV0ZSBib2R5WyduZXdFbWFpbCddXG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vYWRtaW4vZ2VuZXJhdGVfbGlua2AsIHtcbiAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICB4Zm9ybTogX2dlbmVyYXRlTGlua1Jlc3BvbnNlLFxuICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zPy5yZWRpcmVjdFRvLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICAgICAgICB1c2VyOiBudWxsLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLy8gVXNlciBBZG1pbiBBUElcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdXNlci5cbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVVzZXIoYXR0cmlidXRlczogQWRtaW5Vc2VyQXR0cmlidXRlcyk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vyc2AsIHtcbiAgICAgICAgYm9keTogYXR0cmlidXRlcyxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiB1c2Vycy5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICogQHBhcmFtIHBhcmFtcyBBbiBvYmplY3Qgd2hpY2ggc3VwcG9ydHMgYHBhZ2VgIGFuZCBgcGVyUGFnZWAgYXMgbnVtYmVycywgdG8gYWx0ZXIgdGhlIHBhZ2luYXRlZCByZXN1bHRzLlxuICAgKi9cbiAgYXN5bmMgbGlzdFVzZXJzKFxuICAgIHBhcmFtcz86IFBhZ2VQYXJhbXNcbiAgKTogUHJvbWlzZTxcbiAgICB8IHsgZGF0YTogeyB1c2VyczogVXNlcltdOyBhdWQ6IHN0cmluZyB9ICYgUGFnaW5hdGlvbjsgZXJyb3I6IG51bGwgfVxuICAgIHwgeyBkYXRhOiB7IHVzZXJzOiBbXSB9OyBlcnJvcjogQXV0aEVycm9yIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhZ2luYXRpb246IFBhZ2luYXRpb24gPSB7IG5leHRQYWdlOiBudWxsLCBsYXN0UGFnZTogMCwgdG90YWw6IDAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzYCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgcGFnZTogcGFyYW1zPy5wYWdlPy50b1N0cmluZygpID8/ICcnLFxuICAgICAgICAgIHBlcl9wYWdlOiBwYXJhbXM/LnBlclBhZ2U/LnRvU3RyaW5nKCkgPz8gJycsXG4gICAgICAgIH0sXG4gICAgICAgIHhmb3JtOiBfbm9SZXNvbHZlSnNvblJlc3BvbnNlLFxuICAgICAgfSlcbiAgICAgIGlmIChyZXNwb25zZS5lcnJvcikgdGhyb3cgcmVzcG9uc2UuZXJyb3JcblxuICAgICAgY29uc3QgdXNlcnMgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIGNvbnN0IHRvdGFsID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtdG90YWwtY291bnQnKSA/PyAwXG4gICAgICBjb25zdCBsaW5rcyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdsaW5rJyk/LnNwbGl0KCcsJykgPz8gW11cbiAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxpbmtzLmZvckVhY2goKGxpbms6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhZ2UgPSBwYXJzZUludChsaW5rLnNwbGl0KCc7JylbMF0uc3BsaXQoJz0nKVsxXS5zdWJzdHJpbmcoMCwgMSkpXG4gICAgICAgICAgY29uc3QgcmVsID0gSlNPTi5wYXJzZShsaW5rLnNwbGl0KCc7JylbMV0uc3BsaXQoJz0nKVsxXSlcbiAgICAgICAgICBwYWdpbmF0aW9uW2Ake3JlbH1QYWdlYF0gPSBwYWdlXG4gICAgICAgIH0pXG5cbiAgICAgICAgcGFnaW5hdGlvbi50b3RhbCA9IHBhcnNlSW50KHRvdGFsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0YTogeyAuLi51c2VycywgLi4ucGFnaW5hdGlvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyczogW10gfSwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHVzZXIgYnkgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB1aWQgVGhlIHVzZXIncyB1bmlxdWUgaWRlbnRpZmllclxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlckJ5SWQodWlkOiBzdHJpbmcpOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3VpZH1gLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHVzZXIgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIGF0dHJpYnV0ZXMgVGhlIGRhdGEgeW91IHdhbnQgdG8gdXBkYXRlLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlVXNlckJ5SWQodWlkOiBzdHJpbmcsIGF0dHJpYnV0ZXM6IEFkbWluVXNlckF0dHJpYnV0ZXMpOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BVVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3VpZH1gLCB7XG4gICAgICAgIGJvZHk6IGF0dHJpYnV0ZXMsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHVzZXIuIFJlcXVpcmVzIGEgYHNlcnZpY2Vfcm9sZWAga2V5LlxuICAgKlxuICAgKiBAcGFyYW0gaWQgVGhlIHVzZXIgaWQgeW91IHdhbnQgdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0gc2hvdWxkU29mdERlbGV0ZSBJZiB0cnVlLCB0aGVuIHRoZSB1c2VyIHdpbGwgYmUgc29mdC1kZWxldGVkIGZyb20gdGhlIGF1dGggc2NoZW1hLiBTb2Z0IGRlbGV0aW9uIGFsbG93cyB1c2VyIGlkZW50aWZpY2F0aW9uIGZyb20gdGhlIGhhc2hlZCB1c2VyIElEIGJ1dCBpcyBub3QgcmV2ZXJzaWJsZS5cbiAgICogRGVmYXVsdHMgdG8gZmFsc2UgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAqL1xuICBhc3luYyBkZWxldGVVc2VyKGlkOiBzdHJpbmcsIHNob3VsZFNvZnREZWxldGUgPSBmYWxzZSk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7aWR9YCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBzaG91bGRfc29mdF9kZWxldGU6IHNob3VsZFNvZnREZWxldGUsXG4gICAgICAgIH0sXG4gICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2xpc3RGYWN0b3JzKFxuICAgIHBhcmFtczogQXV0aE1GQUFkbWluTGlzdEZhY3RvcnNQYXJhbXNcbiAgKTogUHJvbWlzZTxBdXRoTUZBQWRtaW5MaXN0RmFjdG9yc1Jlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICAnR0VUJyxcbiAgICAgICAgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7cGFyYW1zLnVzZXJJZH0vZmFjdG9yc2AsXG4gICAgICAgIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgeGZvcm06IChmYWN0b3JzOiBhbnkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgZmFjdG9ycyB9LCBlcnJvcjogbnVsbCB9XG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9kZWxldGVGYWN0b3IoXG4gICAgcGFyYW1zOiBBdXRoTUZBQWRtaW5EZWxldGVGYWN0b3JQYXJhbXNcbiAgKTogUHJvbWlzZTxBdXRoTUZBQWRtaW5EZWxldGVGYWN0b3JSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgX3JlcXVlc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgICdERUxFVEUnLFxuICAgICAgICBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHtwYXJhbXMudXNlcklkfS9mYWN0b3JzLyR7cGFyYW1zLmlkfWAsXG4gICAgICAgIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIH1cbiAgICAgIClcblxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBzdXBwb3J0c0xvY2FsU3RvcmFnZSB9IGZyb20gJy4vaGVscGVycydcbmltcG9ydCB7IFN1cHBvcnRlZFN0b3JhZ2UgfSBmcm9tICcuL3R5cGVzJ1xuXG4vKipcbiAqIFByb3ZpZGVzIHNhZmUgYWNjZXNzIHRvIHRoZSBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSBwcm9wZXJ0eS5cbiAqL1xuZXhwb3J0IGNvbnN0IGxvY2FsU3RvcmFnZUFkYXB0ZXI6IFN1cHBvcnRlZFN0b3JhZ2UgPSB7XG4gIGdldEl0ZW06IChrZXkpID0+IHtcbiAgICBpZiAoIXN1cHBvcnRzTG9jYWxTdG9yYWdlKCkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KVxuICB9LFxuICBzZXRJdGVtOiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICghc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKVxuICB9LFxuICByZW1vdmVJdGVtOiAoa2V5KSA9PiB7XG4gICAgaWYgKCFzdXBwb3J0c0xvY2FsU3RvcmFnZSgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcbiAgfSxcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbG9jYWxTdG9yYWdlLWxpa2Ugb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSBrZXktdmFsdWUgcGFpcnMgaW5cbiAqIG1lbW9yeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIoc3RvcmU6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fSk6IFN1cHBvcnRlZFN0b3JhZ2Uge1xuICByZXR1cm4ge1xuICAgIGdldEl0ZW06IChrZXkpID0+IHtcbiAgICAgIHJldHVybiBzdG9yZVtrZXldIHx8IG51bGxcbiAgICB9LFxuXG4gICAgc2V0SXRlbTogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgIHN0b3JlW2tleV0gPSB2YWx1ZVxuICAgIH0sXG5cbiAgICByZW1vdmVJdGVtOiAoa2V5KSA9PiB7XG4gICAgICBkZWxldGUgc3RvcmVba2V5XVxuICAgIH0sXG4gIH1cbn1cbiIsICIvKipcbiAqIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9nbG9iYWx0aGlzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2x5ZmlsbEdsb2JhbFRoaXMoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVyblxuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCAnX19tYWdpY19fJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIH0pXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAnQWxsb3cgYWNjZXNzIHRvIG1hZ2ljJ1xuICAgIF9fbWFnaWNfXy5nbG9iYWxUaGlzID0gX19tYWdpY19fXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAnQWxsb3cgYWNjZXNzIHRvIG1hZ2ljJ1xuICAgIGRlbGV0ZSBPYmplY3QucHJvdG90eXBlLl9fbWFnaWNfX1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAnQWxsb3cgYWNjZXNzIHRvIGdsb2JhbHMnXG4gICAgICBzZWxmLmdsb2JhbFRoaXMgPSBzZWxmXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHsgc3VwcG9ydHNMb2NhbFN0b3JhZ2UgfSBmcm9tICcuL2hlbHBlcnMnXG5cbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgY29uc3QgaW50ZXJuYWxzID0ge1xuICAvKipcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgZGVidWc6ICEhKFxuICAgIGdsb2JhbFRoaXMgJiZcbiAgICBzdXBwb3J0c0xvY2FsU3RvcmFnZSgpICYmXG4gICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UgJiZcbiAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzdXBhYmFzZS5nb3RydWUtanMubG9ja3MuZGVidWcnKSA9PT0gJ3RydWUnXG4gICksXG59XG5cbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gYSBsb2NrIGNhbm5vdCBiZSBhY3F1aXJlZCBhZnRlciBzb21lIGFtb3VudCBvZiB0aW1lLlxuICpcbiAqIFVzZSB0aGUge0BsaW5rICNpc0FjcXVpcmVUaW1lb3V0fSBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGNoZWNraW5nIHdpdGggYGluc3RhbmNlb2ZgLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBpc0FjcXVpcmVUaW1lb3V0ID0gdHJ1ZVxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yIGV4dGVuZHMgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3Ige31cbmV4cG9ydCBjbGFzcyBQcm9jZXNzTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgZXh0ZW5kcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciB7fVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSBnbG9iYWwgZXhjbHVzaXZlIGxvY2sgdXNpbmcgdGhlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBBUEkuIEl0XG4gKiBpcyBhdmFpbGFibGUgb24gYWxsIGJyb3dzZXJzIHJlbGVhc2VkIGFmdGVyIDIwMjItMDMtMTUgd2l0aCBTYWZhcmkgYmVpbmcgdGhlXG4gKiBsYXN0IG9uZSB0byByZWxlYXNlIHN1cHBvcnQuIElmIHRoZSBBUEkgaXMgbm90IGF2YWlsYWJsZSwgdGhpcyBmdW5jdGlvbiB3aWxsXG4gKiB0aHJvdy4gTWFrZSBzdXJlIHlvdSBjaGVjayBhdmFpbGFibGlsaXR5IGJlZm9yZSBjb25maWd1cmluZyB7QGxpbmtcbiAqIEdvVHJ1ZUNsaWVudH0uXG4gKlxuICogWW91IGNhbiB0dXJuIG9uIGRlYnVnZ2luZyBieSBzZXR0aW5nIHRoZSBgc3VwYWJhc2UuZ290cnVlLWpzLmxvY2tzLmRlYnVnYFxuICogbG9jYWwgc3RvcmFnZSBpdGVtIHRvIGB0cnVlYC5cbiAqXG4gKiBJbnRlcm5hbHM6XG4gKlxuICogU2luY2UgdGhlIExvY2tNYW5hZ2VyIEFQSSBkb2VzIG5vdCBwcmVzZXJ2ZSBzdGFjayB0cmFjZXMgZm9yIHRoZSBhc3luY1xuICogZnVuY3Rpb24gcGFzc2VkIGluIHRoZSBgcmVxdWVzdGAgbWV0aG9kLCBhIHRyaWNrIGlzIHVzZWQgd2hlcmUgYWNxdWlyaW5nIHRoZVxuICogbG9jayByZWxlYXNlcyBhIHByZXZpb3VzbHkgc3RhcnRlZCBwcm9taXNlIHRvIHJ1biB0aGUgb3BlcmF0aW9uIGluIHRoZSBgZm5gXG4gKiBmdW5jdGlvbi4gVGhlIGxvY2sgd2FpdHMgZm9yIHRoYXQgcHJvbWlzZSB0byBmaW5pc2ggKHdpdGggb3Igd2l0aG91dCBlcnJvciksXG4gKiB3aGlsZSB0aGUgZnVuY3Rpb24gd2lsbCBmaW5hbGx5IHdhaXQgZm9yIHRoZSByZXN1bHQgYW55d2F5LlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGxvY2sgdG8gYmUgYWNxdWlyZWQuXG4gKiBAcGFyYW0gYWNxdWlyZVRpbWVvdXQgSWYgbmVnYXRpdmUsIG5vIHRpbWVvdXQuIElmIDAgYW4gZXJyb3IgaXMgdGhyb3duIGlmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdGhlIGxvY2sgY2FuJ3QgYmUgYWNxdWlyZWQgd2l0aG91dCB3YWl0aW5nLiBJZiBwb3NpdGl2ZSwgdGhlIGxvY2sgYWNxdWlyZVxuICogICAgICAgICAgICAgICAgICAgICAgIHdpbGwgdGltZSBvdXQgYWZ0ZXIgc28gbWFueSBtaWxsaXNlY29uZHMuIEFuIGVycm9yIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYSB0aW1lb3V0IGlmIGl0IGhhcyBgaXNBY3F1aXJlVGltZW91dGAgc2V0IHRvIHRydWUuXG4gKiBAcGFyYW0gZm4gVGhlIG9wZXJhdGlvbiB0byBydW4gb25jZSB0aGUgbG9jayBpcyBhY3F1aXJlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRvckxvY2s8Uj4oXG4gIG5hbWU6IHN0cmluZyxcbiAgYWNxdWlyZVRpbWVvdXQ6IG51bWJlcixcbiAgZm46ICgpID0+IFByb21pc2U8Uj5cbik6IFByb21pc2U8Uj4ge1xuICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IGFjcXVpcmUgbG9jaycsIG5hbWUsIGFjcXVpcmVUaW1lb3V0KVxuICB9XG5cbiAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyKClcblxuICBpZiAoYWNxdWlyZVRpbWVvdXQgPiAwKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jayBhY3F1aXJlIHRpbWVkIG91dCcsIG5hbWUpXG4gICAgICB9XG4gICAgfSwgYWNxdWlyZVRpbWVvdXQpXG4gIH1cblxuICAvLyBNRE4gYXJ0aWNsZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0xvY2tNYW5hZ2VyL3JlcXVlc3RcblxuICAvLyBXcmFwcGluZyBuYXZpZ2F0b3IubG9ja3MucmVxdWVzdCgpIHdpdGggYSBwbGFpbiBQcm9taXNlIGlzIGRvbmUgYXMgc29tZVxuICAvLyBsaWJyYXJpZXMgbGlrZSB6b25lLmpzIHBhdGNoIHRoZSBQcm9taXNlIG9iamVjdCB0byB0cmFjayB0aGUgZXhlY3V0aW9uXG4gIC8vIGNvbnRleHQuIEhvd2V2ZXIsIGl0IGFwcGVhcnMgdGhhdCBtb3N0IGJyb3dzZXJzIHVzZSBhbiBpbnRlcm5hbCBwcm9taXNlXG4gIC8vIGltcGxlbWVudGF0aW9uIHdoZW4gdXNpbmcgdGhlIG5hdmlnYXRvci5sb2Nrcy5yZXF1ZXN0KCkgQVBJIGNhdXNpbmcgdGhlbVxuICAvLyB0byBsb3NlIGNvbnRleHQgYW5kIGVtaXQgY29uZnVzaW5nIGxvZyBtZXNzYWdlcyBvciBicmVhayBjZXJ0YWluIGZlYXR1cmVzLlxuICAvLyBUaGlzIHdyYXBwaW5nIGlzIGJlbGlldmVkIHRvIGhlbHAgem9uZS5qcyB0cmFjayB0aGUgZXhlY3V0aW9uIGNvbnRleHRcbiAgLy8gYmV0dGVyLlxuICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PlxuICAgIGdsb2JhbFRoaXMubmF2aWdhdG9yLmxvY2tzLnJlcXVlc3QoXG4gICAgICBuYW1lLFxuICAgICAgYWNxdWlyZVRpbWVvdXQgPT09IDBcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBtb2RlOiAnZXhjbHVzaXZlJyxcbiAgICAgICAgICAgIGlmQXZhaWxhYmxlOiB0cnVlLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBtb2RlOiAnZXhjbHVzaXZlJyxcbiAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICB9LFxuICAgICAgYXN5bmMgKGxvY2spID0+IHtcbiAgICAgICAgaWYgKGxvY2spIHtcbiAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogYWNxdWlyZWQnLCBuYW1lLCBsb2NrLm5hbWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpXG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IHJlbGVhc2VkJywgbmFtZSwgbG9jay5uYW1lKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYWNxdWlyZVRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IG5vdCBpbW1lZGlhdGVseSBhdmFpbGFibGUnLCBuYW1lKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IoXG4gICAgICAgICAgICAgIGBBY3F1aXJpbmcgYW4gZXhjbHVzaXZlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBsb2NrIFwiJHtuYW1lfVwiIGltbWVkaWF0ZWx5IGZhaWxlZGBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdsb2JhbFRoaXMubmF2aWdhdG9yLmxvY2tzLnF1ZXJ5KClcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgJ0BzdXBhYmFzZS9nb3RydWUtanM6IE5hdmlnYXRvciBMb2NrTWFuYWdlciBzdGF0ZScsXG4gICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsICcgICcpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAnQHN1cGFiYXNlL2dvdHJ1ZS1qczogRXJyb3Igd2hlbiBxdWVyeWluZyBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgc3RhdGUnLFxuICAgICAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCcm93c2VyIGlzIG5vdCBmb2xsb3dpbmcgdGhlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBzcGVjLCBpdFxuICAgICAgICAgICAgLy8gcmV0dXJuZWQgYSBudWxsIGxvY2sgd2hlbiB3ZSBkaWRuJ3QgdXNlIGlmQXZhaWxhYmxlLiBTbyB3ZSBjYW5cbiAgICAgICAgICAgIC8vIHByZXRlbmQgdGhlIGxvY2sgaXMgYWNxdWlyZWQgaW4gdGhlIG5hbWUgb2YgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgLy8gYW5kIHVzZXIgZXhwZXJpZW5jZSBhbmQganVzdCBydW4gdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAnQHN1cGFiYXNlL2dvdHJ1ZS1qczogTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHJldHVybmVkIGEgbnVsbCBsb2NrIHdoZW4gdXNpbmcgI3JlcXVlc3Qgd2l0aG91dCBpZkF2YWlsYWJsZSBzZXQgdG8gdHJ1ZSwgaXQgYXBwZWFycyB0aGlzIGJyb3dzZXIgaXMgbm90IGZvbGxvd2luZyB0aGUgTG9ja01hbmFnZXIgc3BlYyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTG9ja01hbmFnZXIvcmVxdWVzdCdcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG4gIClcbn1cblxuY29uc3QgUFJPQ0VTU19MT0NLUzogeyBbbmFtZTogc3RyaW5nXTogUHJvbWlzZTxhbnk+IH0gPSB7fVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSBnbG9iYWwgZXhjbHVzaXZlIGxvY2sgdGhhdCB3b3JrcyBvbmx5IGluIHRoZSBjdXJyZW50IHByb2Nlc3MuXG4gKiBVc2VmdWwgZm9yIGVudmlyb25tZW50cyBsaWtlIFJlYWN0IE5hdGl2ZSBvciBvdGhlciBub24tYnJvd3NlclxuICogc2luZ2xlLXByb2Nlc3MgKGkuZS4gbm8gY29uY2VwdCBvZiBcInRhYnNcIikgZW52aXJvbm1lbnRzLlxuICpcbiAqIFVzZSB7QGxpbmsgI25hdmlnYXRvckxvY2t9IGluIGJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGxvY2sgdG8gYmUgYWNxdWlyZWQuXG4gKiBAcGFyYW0gYWNxdWlyZVRpbWVvdXQgSWYgbmVnYXRpdmUsIG5vIHRpbWVvdXQuIElmIDAgYW4gZXJyb3IgaXMgdGhyb3duIGlmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdGhlIGxvY2sgY2FuJ3QgYmUgYWNxdWlyZWQgd2l0aG91dCB3YWl0aW5nLiBJZiBwb3NpdGl2ZSwgdGhlIGxvY2sgYWNxdWlyZVxuICogICAgICAgICAgICAgICAgICAgICAgIHdpbGwgdGltZSBvdXQgYWZ0ZXIgc28gbWFueSBtaWxsaXNlY29uZHMuIEFuIGVycm9yIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYSB0aW1lb3V0IGlmIGl0IGhhcyBgaXNBY3F1aXJlVGltZW91dGAgc2V0IHRvIHRydWUuXG4gKiBAcGFyYW0gZm4gVGhlIG9wZXJhdGlvbiB0byBydW4gb25jZSB0aGUgbG9jayBpcyBhY3F1aXJlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NMb2NrPFI+KFxuICBuYW1lOiBzdHJpbmcsXG4gIGFjcXVpcmVUaW1lb3V0OiBudW1iZXIsXG4gIGZuOiAoKSA9PiBQcm9taXNlPFI+XG4pOiBQcm9taXNlPFI+IHtcbiAgY29uc3QgcHJldmlvdXNPcGVyYXRpb24gPSBQUk9DRVNTX0xPQ0tTW25hbWVdID8/IFByb21pc2UucmVzb2x2ZSgpXG5cbiAgY29uc3QgY3VycmVudE9wZXJhdGlvbiA9IFByb21pc2UucmFjZShcbiAgICBbXG4gICAgICBwcmV2aW91c09wZXJhdGlvbi5jYXRjaCgoKSA9PiB7XG4gICAgICAgIC8vIGlnbm9yZSBlcnJvciBvZiBwcmV2aW91cyBvcGVyYXRpb24gdGhhdCB3ZSdyZSB3YWl0aW5nIHRvIGZpbmlzaFxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfSksXG4gICAgICBhY3F1aXJlVGltZW91dCA+PSAwXG4gICAgICAgID8gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBuZXcgUHJvY2Vzc0xvY2tBY3F1aXJlVGltZW91dEVycm9yKFxuICAgICAgICAgICAgICAgICAgYEFjcXVyaW5nIHByb2Nlc3MgbG9jayB3aXRoIG5hbWUgXCIke25hbWV9XCIgdGltZWQgb3V0YFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSwgYWNxdWlyZVRpbWVvdXQpXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBudWxsLFxuICAgIF0uZmlsdGVyKCh4KSA9PiB4KVxuICApXG4gICAgLmNhdGNoKChlOiBhbnkpID0+IHtcbiAgICAgIGlmIChlICYmIGUuaXNBY3F1aXJlVGltZW91dCkge1xuICAgICAgICB0aHJvdyBlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsXG4gICAgfSlcbiAgICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAvLyBwcmV2aW91cyBvcGVyYXRpb25zIGZpbmlzaGVkIGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmFjZSBvbiB0aGUgYWNxdWlyZVxuICAgICAgLy8gdGltZW91dCwgc28gdGhlIGN1cnJlbnQgb3BlcmF0aW9uIGNhbiBmaW5hbGx5IHN0YXJ0XG4gICAgICByZXR1cm4gYXdhaXQgZm4oKVxuICAgIH0pXG5cbiAgUFJPQ0VTU19MT0NLU1tuYW1lXSA9IGN1cnJlbnRPcGVyYXRpb24uY2F0Y2goYXN5bmMgKGU6IGFueSkgPT4ge1xuICAgIGlmIChlICYmIGUuaXNBY3F1aXJlVGltZW91dCkge1xuICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIHRpbWVkIG91dCwgaXQgZG9lc24ndCBtZWFuIHRoYXQgdGhlIHByZXZpb3VzXG4gICAgICAvLyBvcGVyYXRpb24gZmluaXNoZWQsIHNvIHdlIG5lZWQgY29udG51ZSB3YWl0aW5nIGZvciBpdCB0byBmaW5pc2hcbiAgICAgIGF3YWl0IHByZXZpb3VzT3BlcmF0aW9uXG5cbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdGhyb3cgZVxuICB9KVxuXG4gIC8vIGZpbmFsbHkgd2FpdCBmb3IgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIHRvIGZpbmlzaCBzdWNjZXNzZnVsbHksIHdpdGggYW5cbiAgLy8gZXJyb3Igb3Igd2l0aCBhbiBhY3F1aXJlIHRpbWVvdXQgZXJyb3JcbiAgcmV0dXJuIGF3YWl0IGN1cnJlbnRPcGVyYXRpb25cbn1cbiIsICJpbXBvcnQgR29UcnVlQWRtaW5BcGkgZnJvbSAnLi9Hb1RydWVBZG1pbkFwaSdcbmltcG9ydCB7IERFRkFVTFRfSEVBREVSUywgRVhQSVJZX01BUkdJTiwgR09UUlVFX1VSTCwgU1RPUkFHRV9LRVkgfSBmcm9tICcuL2xpYi9jb25zdGFudHMnXG5pbXBvcnQge1xuICBBdXRoRXJyb3IsXG4gIEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcixcbiAgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yLFxuICBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IsXG4gIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yLFxuICBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcixcbiAgQXV0aFVua25vd25FcnJvcixcbiAgaXNBdXRoQXBpRXJyb3IsXG4gIGlzQXV0aEVycm9yLFxuICBpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yLFxuICBpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yLFxuICBpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcixcbn0gZnJvbSAnLi9saWIvZXJyb3JzJ1xuaW1wb3J0IHtcbiAgRmV0Y2gsXG4gIF9yZXF1ZXN0LFxuICBfc2Vzc2lvblJlc3BvbnNlLFxuICBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gIF91c2VyUmVzcG9uc2UsXG4gIF9zc29SZXNwb25zZSxcbn0gZnJvbSAnLi9saWIvZmV0Y2gnXG5pbXBvcnQge1xuICBkZWNvZGVKV1RQYXlsb2FkLFxuICBEZWZlcnJlZCxcbiAgZ2V0SXRlbUFzeW5jLFxuICBpc0Jyb3dzZXIsXG4gIHJlbW92ZUl0ZW1Bc3luYyxcbiAgcmVzb2x2ZUZldGNoLFxuICBzZXRJdGVtQXN5bmMsXG4gIHV1aWQsXG4gIHJldHJ5YWJsZSxcbiAgc2xlZXAsXG4gIHN1cHBvcnRzTG9jYWxTdG9yYWdlLFxuICBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMLFxuICBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kLFxufSBmcm9tICcuL2xpYi9oZWxwZXJzJ1xuaW1wb3J0IHsgbG9jYWxTdG9yYWdlQWRhcHRlciwgbWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlciB9IGZyb20gJy4vbGliL2xvY2FsLXN0b3JhZ2UnXG5pbXBvcnQgeyBwb2x5ZmlsbEdsb2JhbFRoaXMgfSBmcm9tICcuL2xpYi9wb2x5ZmlsbHMnXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi9saWIvdmVyc2lvbidcbmltcG9ydCB7IExvY2tBY3F1aXJlVGltZW91dEVycm9yLCBuYXZpZ2F0b3JMb2NrIH0gZnJvbSAnLi9saWIvbG9ja3MnXG5cbmltcG9ydCB0eXBlIHtcbiAgQXV0aENoYW5nZUV2ZW50LFxuICBBdXRoUmVzcG9uc2UsXG4gIEF1dGhSZXNwb25zZVBhc3N3b3JkLFxuICBBdXRoVG9rZW5SZXNwb25zZSxcbiAgQXV0aFRva2VuUmVzcG9uc2VQYXNzd29yZCxcbiAgQXV0aE90cFJlc3BvbnNlLFxuICBDYWxsUmVmcmVzaFRva2VuUmVzdWx0LFxuICBHb1RydWVDbGllbnRPcHRpb25zLFxuICBJbml0aWFsaXplUmVzdWx0LFxuICBPQXV0aFJlc3BvbnNlLFxuICBTU09SZXNwb25zZSxcbiAgUHJvdmlkZXIsXG4gIFNlc3Npb24sXG4gIFNpZ25JbldpdGhJZFRva2VuQ3JlZGVudGlhbHMsXG4gIFNpZ25JbldpdGhPQXV0aENyZWRlbnRpYWxzLFxuICBTaWduSW5XaXRoUGFzc3dvcmRDcmVkZW50aWFscyxcbiAgU2lnbkluV2l0aFBhc3N3b3JkbGVzc0NyZWRlbnRpYWxzLFxuICBTaWduVXBXaXRoUGFzc3dvcmRDcmVkZW50aWFscyxcbiAgU2lnbkluV2l0aFNTTyxcbiAgU2lnbk91dCxcbiAgU3Vic2NyaXB0aW9uLFxuICBTdXBwb3J0ZWRTdG9yYWdlLFxuICBVc2VyLFxuICBVc2VyQXR0cmlidXRlcyxcbiAgVXNlclJlc3BvbnNlLFxuICBWZXJpZnlPdHBQYXJhbXMsXG4gIEdvVHJ1ZU1GQUFwaSxcbiAgTUZBRW5yb2xsUGFyYW1zLFxuICBBdXRoTUZBRW5yb2xsUmVzcG9uc2UsXG4gIE1GQUNoYWxsZW5nZVBhcmFtcyxcbiAgQXV0aE1GQUNoYWxsZW5nZVJlc3BvbnNlLFxuICBNRkFVbmVucm9sbFBhcmFtcyxcbiAgQXV0aE1GQVVuZW5yb2xsUmVzcG9uc2UsXG4gIE1GQVZlcmlmeVBhcmFtcyxcbiAgQXV0aE1GQVZlcmlmeVJlc3BvbnNlLFxuICBBdXRoTUZBTGlzdEZhY3RvcnNSZXNwb25zZSxcbiAgQU1SRW50cnksXG4gIEF1dGhNRkFHZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWxSZXNwb25zZSxcbiAgQXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVscyxcbiAgRmFjdG9yLFxuICBNRkFDaGFsbGVuZ2VBbmRWZXJpZnlQYXJhbXMsXG4gIFJlc2VuZFBhcmFtcyxcbiAgQXV0aEZsb3dUeXBlLFxuICBMb2NrRnVuYyxcbiAgVXNlcklkZW50aXR5LFxuICBTaWduSW5Bbm9ueW1vdXNseUNyZWRlbnRpYWxzLFxufSBmcm9tICcuL2xpYi90eXBlcydcbmltcG9ydCB7XG4gIE1GQUVucm9sbFRPVFBQYXJhbXMsXG4gIE1GQUVucm9sbFBob25lUGFyYW1zLFxuICBBdXRoTUZBRW5yb2xsVE9UUFJlc3BvbnNlLFxuICBBdXRoTUZBRW5yb2xsUGhvbmVSZXNwb25zZSxcbn0gZnJvbSAnLi9saWIvaW50ZXJuYWwtdHlwZXMnXG5cbnBvbHlmaWxsR2xvYmFsVGhpcygpIC8vIE1ha2UgXCJnbG9iYWxUaGlzXCIgYXZhaWxhYmxlXG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUzogT21pdDxSZXF1aXJlZDxHb1RydWVDbGllbnRPcHRpb25zPiwgJ2ZldGNoJyB8ICdzdG9yYWdlJyB8ICdsb2NrJz4gPSB7XG4gIHVybDogR09UUlVFX1VSTCxcbiAgc3RvcmFnZUtleTogU1RPUkFHRV9LRVksXG4gIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuICBkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWUsXG4gIGhlYWRlcnM6IERFRkFVTFRfSEVBREVSUyxcbiAgZmxvd1R5cGU6ICdpbXBsaWNpdCcsXG4gIGRlYnVnOiBmYWxzZSxcbiAgaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcjogZmFsc2UsXG59XG5cbi8qKiBDdXJyZW50IHNlc3Npb24gd2lsbCBiZSBjaGVja2VkIGZvciByZWZyZXNoIGF0IHRoaXMgaW50ZXJ2YWwuICovXG5jb25zdCBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTiA9IDMwICogMTAwMFxuXG4vKipcbiAqIEEgdG9rZW4gcmVmcmVzaCB3aWxsIGJlIGF0dGVtcHRlZCB0aGlzIG1hbnkgdGlja3MgYmVmb3JlIHRoZSBjdXJyZW50IHNlc3Npb24gZXhwaXJlcy4gKi9cbmNvbnN0IEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCA9IDNcblxuYXN5bmMgZnVuY3Rpb24gbG9ja05vT3A8Uj4obmFtZTogc3RyaW5nLCBhY3F1aXJlVGltZW91dDogbnVtYmVyLCBmbjogKCkgPT4gUHJvbWlzZTxSPik6IFByb21pc2U8Uj4ge1xuICByZXR1cm4gYXdhaXQgZm4oKVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHb1RydWVDbGllbnQge1xuICBwcml2YXRlIHN0YXRpYyBuZXh0SW5zdGFuY2VJRCA9IDBcblxuICBwcml2YXRlIGluc3RhbmNlSUQ6IG51bWJlclxuXG4gIC8qKlxuICAgKiBOYW1lc3BhY2UgZm9yIHRoZSBHb1RydWUgYWRtaW4gbWV0aG9kcy5cbiAgICogVGhlc2UgbWV0aG9kcyBzaG91bGQgb25seSBiZSB1c2VkIGluIGEgdHJ1c3RlZCBzZXJ2ZXItc2lkZSBlbnZpcm9ubWVudC5cbiAgICovXG4gIGFkbWluOiBHb1RydWVBZG1pbkFwaVxuICAvKipcbiAgICogTmFtZXNwYWNlIGZvciB0aGUgTUZBIG1ldGhvZHMuXG4gICAqL1xuICBtZmE6IEdvVHJ1ZU1GQUFwaVxuICAvKipcbiAgICogVGhlIHN0b3JhZ2Uga2V5IHVzZWQgdG8gaWRlbnRpZnkgdGhlIHZhbHVlcyBzYXZlZCBpbiBsb2NhbFN0b3JhZ2VcbiAgICovXG4gIHByb3RlY3RlZCBzdG9yYWdlS2V5OiBzdHJpbmdcblxuICBwcm90ZWN0ZWQgZmxvd1R5cGU6IEF1dGhGbG93VHlwZVxuXG4gIHByb3RlY3RlZCBhdXRvUmVmcmVzaFRva2VuOiBib29sZWFuXG4gIHByb3RlY3RlZCBwZXJzaXN0U2Vzc2lvbjogYm9vbGVhblxuICBwcm90ZWN0ZWQgc3RvcmFnZTogU3VwcG9ydGVkU3RvcmFnZVxuICBwcm90ZWN0ZWQgbWVtb3J5U3RvcmFnZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsXG4gIHByb3RlY3RlZCBzdGF0ZUNoYW5nZUVtaXR0ZXJzOiBNYXA8c3RyaW5nLCBTdWJzY3JpcHRpb24+ID0gbmV3IE1hcCgpXG4gIHByb3RlY3RlZCBhdXRvUmVmcmVzaFRpY2tlcjogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+IHwgbnVsbCA9IG51bGxcbiAgcHJvdGVjdGVkIHZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2s6ICgoKSA9PiBQcm9taXNlPGFueT4pIHwgbnVsbCA9IG51bGxcbiAgcHJvdGVjdGVkIHJlZnJlc2hpbmdEZWZlcnJlZDogRGVmZXJyZWQ8Q2FsbFJlZnJlc2hUb2tlblJlc3VsdD4gfCBudWxsID0gbnVsbFxuICAvKipcbiAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGFzeW5jIGNsaWVudCBpbml0aWFsaXphdGlvbi5cbiAgICogV2hlbiBudWxsIG9yIG5vdCB5ZXQgcmVzb2x2ZWQgdGhlIGF1dGggc3RhdGUgaXMgYHVua25vd25gXG4gICAqIE9uY2UgcmVzb2x2ZWQgdGhlIHRoZSBhdXRoIHN0YXRlIGlzIGtub3duIGFuZCBpdCdzIHNhdmUgdG8gY2FsbCBhbnkgZnVydGhlciBjbGllbnQgbWV0aG9kcy5cbiAgICogS2VlcCBleHRyYSBjYXJlIHRvIG5ldmVyIHJlamVjdCBvciB0aHJvdyB1bmNhdWdodCBlcnJvcnNcbiAgICovXG4gIHByb3RlY3RlZCBpbml0aWFsaXplUHJvbWlzZTogUHJvbWlzZTxJbml0aWFsaXplUmVzdWx0PiB8IG51bGwgPSBudWxsXG4gIHByb3RlY3RlZCBkZXRlY3RTZXNzaW9uSW5VcmwgPSB0cnVlXG4gIHByb3RlY3RlZCB1cmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgaGVhZGVyczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9XG4gIHByb3RlY3RlZCBoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyID0gZmFsc2VcbiAgcHJvdGVjdGVkIHN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSBmYWxzZVxuICBwcm90ZWN0ZWQgZmV0Y2g6IEZldGNoXG4gIHByb3RlY3RlZCBsb2NrOiBMb2NrRnVuY1xuICBwcm90ZWN0ZWQgbG9ja0FjcXVpcmVkID0gZmFsc2VcbiAgcHJvdGVjdGVkIHBlbmRpbmdJbkxvY2s6IFByb21pc2U8YW55PltdID0gW11cblxuICAvKipcbiAgICogVXNlZCB0byBicm9hZGNhc3Qgc3RhdGUgY2hhbmdlIGV2ZW50cyB0byBvdGhlciB0YWJzIGxpc3RlbmluZy5cbiAgICovXG4gIHByb3RlY3RlZCBicm9hZGNhc3RDaGFubmVsOiBCcm9hZGNhc3RDaGFubmVsIHwgbnVsbCA9IG51bGxcblxuICBwcm90ZWN0ZWQgbG9nRGVidWdNZXNzYWdlczogYm9vbGVhblxuICBwcm90ZWN0ZWQgbG9nZ2VyOiAobWVzc2FnZTogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCA9IGNvbnNvbGUubG9nXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBjbGllbnQgZm9yIHVzZSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEdvVHJ1ZUNsaWVudE9wdGlvbnMpIHtcbiAgICB0aGlzLmluc3RhbmNlSUQgPSBHb1RydWVDbGllbnQubmV4dEluc3RhbmNlSURcbiAgICBHb1RydWVDbGllbnQubmV4dEluc3RhbmNlSUQgKz0gMVxuXG4gICAgaWYgKHRoaXMuaW5zdGFuY2VJRCA+IDAgJiYgaXNCcm93c2VyKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ011bHRpcGxlIEdvVHJ1ZUNsaWVudCBpbnN0YW5jZXMgZGV0ZWN0ZWQgaW4gdGhlIHNhbWUgYnJvd3NlciBjb250ZXh0LiBJdCBpcyBub3QgYW4gZXJyb3IsIGJ1dCB0aGlzIHNob3VsZCBiZSBhdm9pZGVkIGFzIGl0IG1heSBwcm9kdWNlIHVuZGVmaW5lZCBiZWhhdmlvciB3aGVuIHVzZWQgY29uY3VycmVudGx5IHVuZGVyIHRoZSBzYW1lIHN0b3JhZ2Uga2V5LidcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBzZXR0aW5ncyA9IHsgLi4uREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH1cblxuICAgIHRoaXMubG9nRGVidWdNZXNzYWdlcyA9ICEhc2V0dGluZ3MuZGVidWdcbiAgICBpZiAodHlwZW9mIHNldHRpbmdzLmRlYnVnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmxvZ2dlciA9IHNldHRpbmdzLmRlYnVnXG4gICAgfVxuXG4gICAgdGhpcy5wZXJzaXN0U2Vzc2lvbiA9IHNldHRpbmdzLnBlcnNpc3RTZXNzaW9uXG4gICAgdGhpcy5zdG9yYWdlS2V5ID0gc2V0dGluZ3Muc3RvcmFnZUtleVxuICAgIHRoaXMuYXV0b1JlZnJlc2hUb2tlbiA9IHNldHRpbmdzLmF1dG9SZWZyZXNoVG9rZW5cbiAgICB0aGlzLmFkbWluID0gbmV3IEdvVHJ1ZUFkbWluQXBpKHtcbiAgICAgIHVybDogc2V0dGluZ3MudXJsLFxuICAgICAgaGVhZGVyczogc2V0dGluZ3MuaGVhZGVycyxcbiAgICAgIGZldGNoOiBzZXR0aW5ncy5mZXRjaCxcbiAgICB9KVxuXG4gICAgdGhpcy51cmwgPSBzZXR0aW5ncy51cmxcbiAgICB0aGlzLmhlYWRlcnMgPSBzZXR0aW5ncy5oZWFkZXJzXG4gICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChzZXR0aW5ncy5mZXRjaClcbiAgICB0aGlzLmxvY2sgPSBzZXR0aW5ncy5sb2NrIHx8IGxvY2tOb09wXG4gICAgdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgPSBzZXR0aW5ncy5kZXRlY3RTZXNzaW9uSW5VcmxcbiAgICB0aGlzLmZsb3dUeXBlID0gc2V0dGluZ3MuZmxvd1R5cGVcbiAgICB0aGlzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIgPSBzZXR0aW5ncy5oYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyXG5cbiAgICBpZiAoc2V0dGluZ3MubG9jaykge1xuICAgICAgdGhpcy5sb2NrID0gc2V0dGluZ3MubG9ja1xuICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKCkgJiYgZ2xvYmFsVGhpcz8ubmF2aWdhdG9yPy5sb2Nrcykge1xuICAgICAgdGhpcy5sb2NrID0gbmF2aWdhdG9yTG9ja1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvY2sgPSBsb2NrTm9PcFxuICAgIH1cblxuICAgIHRoaXMubWZhID0ge1xuICAgICAgdmVyaWZ5OiB0aGlzLl92ZXJpZnkuYmluZCh0aGlzKSxcbiAgICAgIGVucm9sbDogdGhpcy5fZW5yb2xsLmJpbmQodGhpcyksXG4gICAgICB1bmVucm9sbDogdGhpcy5fdW5lbnJvbGwuYmluZCh0aGlzKSxcbiAgICAgIGNoYWxsZW5nZTogdGhpcy5fY2hhbGxlbmdlLmJpbmQodGhpcyksXG4gICAgICBsaXN0RmFjdG9yczogdGhpcy5fbGlzdEZhY3RvcnMuYmluZCh0aGlzKSxcbiAgICAgIGNoYWxsZW5nZUFuZFZlcmlmeTogdGhpcy5fY2hhbGxlbmdlQW5kVmVyaWZ5LmJpbmQodGhpcyksXG4gICAgICBnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWw6IHRoaXMuX2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbC5iaW5kKHRoaXMpLFxuICAgIH1cblxuICAgIGlmICh0aGlzLnBlcnNpc3RTZXNzaW9uKSB7XG4gICAgICBpZiAoc2V0dGluZ3Muc3RvcmFnZSkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzZXR0aW5ncy5zdG9yYWdlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IGxvY2FsU3RvcmFnZUFkYXB0ZXJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1lbW9yeVN0b3JhZ2UgPSB7fVxuICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIodGhpcy5tZW1vcnlTdG9yYWdlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVtb3J5U3RvcmFnZSA9IHt9XG4gICAgICB0aGlzLnN0b3JhZ2UgPSBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHRoaXMubWVtb3J5U3RvcmFnZSlcbiAgICB9XG5cbiAgICBpZiAoaXNCcm93c2VyKCkgJiYgZ2xvYmFsVGhpcy5Ccm9hZGNhc3RDaGFubmVsICYmIHRoaXMucGVyc2lzdFNlc3Npb24gJiYgdGhpcy5zdG9yYWdlS2V5KSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwgPSBuZXcgZ2xvYmFsVGhpcy5Ccm9hZGNhc3RDaGFubmVsKHRoaXMuc3RvcmFnZUtleSlcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdGYWlsZWQgdG8gY3JlYXRlIGEgbmV3IEJyb2FkY2FzdENoYW5uZWwsIG11bHRpLXRhYiBzdGF0ZSBjaGFuZ2VzIHdpbGwgbm90IGJlIGF2YWlsYWJsZScsXG4gICAgICAgICAgZVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbD8uYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLl9kZWJ1ZygncmVjZWl2ZWQgYnJvYWRjYXN0IG5vdGlmaWNhdGlvbiBmcm9tIG90aGVyIHRhYiBvciBjbGllbnQnLCBldmVudClcblxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycyhldmVudC5kYXRhLmV2ZW50LCBldmVudC5kYXRhLnNlc3Npb24sIGZhbHNlKSAvLyBicm9hZGNhc3QgPSBmYWxzZSBzbyB3ZSBkb24ndCBnZXQgYW4gZW5kbGVzcyBsb29wIG9mIG1lc3NhZ2VzXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpXG4gIH1cblxuICBwcml2YXRlIF9kZWJ1ZyguLi5hcmdzOiBhbnlbXSk6IEdvVHJ1ZUNsaWVudCB7XG4gICAgaWYgKHRoaXMubG9nRGVidWdNZXNzYWdlcykge1xuICAgICAgdGhpcy5sb2dnZXIoXG4gICAgICAgIGBHb1RydWVDbGllbnRAJHt0aGlzLmluc3RhbmNlSUR9ICgke3ZlcnNpb259KSAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1gLFxuICAgICAgICAuLi5hcmdzXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY2xpZW50IHNlc3Npb24gZWl0aGVyIGZyb20gdGhlIHVybCBvciBmcm9tIHN0b3JhZ2UuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIHdoZW4gaW5zdGFudGlhdGluZyB0aGUgY2xpZW50LCBidXQgc2hvdWxkIGFsc28gYmUgY2FsbGVkXG4gICAqIG1hbnVhbGx5IHdoZW4gY2hlY2tpbmcgZm9yIGFuIGVycm9yIGZyb20gYW4gYXV0aCByZWRpcmVjdCAob2F1dGgsIG1hZ2ljbGluaywgcGFzc3dvcmQgcmVjb3ZlcnksIGV0YykuXG4gICAqL1xuICBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8SW5pdGlhbGl6ZVJlc3VsdD4ge1xuICAgIGlmICh0aGlzLmluaXRpYWxpemVQcm9taXNlKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuICAgIH1cblxuICAgIHRoaXMuaW5pdGlhbGl6ZVByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9pbml0aWFsaXplKClcbiAgICAgIH0pXG4gICAgfSkoKVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBJTVBPUlRBTlQ6XG4gICAqIDEuIE5ldmVyIHRocm93IGluIHRoaXMgbWV0aG9kLCBhcyBpdCBpcyBjYWxsZWQgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAgICogMi4gTmV2ZXIgcmV0dXJuIGEgc2Vzc2lvbiBmcm9tIHRoaXMgbWV0aG9kIGFzIGl0IHdvdWxkIGJlIGNhY2hlZCBvdmVyXG4gICAqICAgIHRoZSB3aG9sZSBsaWZldGltZSBvZiB0aGUgY2xpZW50XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9pbml0aWFsaXplKCk6IFByb21pc2U8SW5pdGlhbGl6ZVJlc3VsdD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgICAgbGV0IGNhbGxiYWNrVXJsVHlwZSA9ICdub25lJ1xuICAgICAgaWYgKHRoaXMuX2lzSW1wbGljaXRHcmFudENhbGxiYWNrKHBhcmFtcykpIHtcbiAgICAgICAgY2FsbGJhY2tVcmxUeXBlID0gJ2ltcGxpY2l0J1xuICAgICAgfSBlbHNlIGlmIChhd2FpdCB0aGlzLl9pc1BLQ0VDYWxsYmFjayhwYXJhbXMpKSB7XG4gICAgICAgIGNhbGxiYWNrVXJsVHlwZSA9ICdwa2NlJ1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEF0dGVtcHQgdG8gZ2V0IHRoZSBzZXNzaW9uIGZyb20gdGhlIFVSTCBvbmx5IGlmIHRoZXNlIGNvbmRpdGlvbnMgYXJlIGZ1bGZpbGxlZFxuICAgICAgICpcbiAgICAgICAqIE5vdGU6IElmIHRoZSBVUkwgaXNuJ3Qgb25lIG9mIHRoZSBjYWxsYmFjayB1cmwgdHlwZXMgKGltcGxpY2l0IG9yIHBrY2UpLFxuICAgICAgICogdGhlbiB0aGVyZSBjb3VsZCBiZSBhbiBleGlzdGluZyBzZXNzaW9uIHNvIHdlIGRvbid0IHdhbnQgdG8gcHJlbWF0dXJlbHkgcmVtb3ZlIGl0XG4gICAgICAgKi9cbiAgICAgIGlmIChpc0Jyb3dzZXIoKSAmJiB0aGlzLmRldGVjdFNlc3Npb25JblVybCAmJiBjYWxsYmFja1VybFR5cGUgIT09ICdub25lJykge1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9nZXRTZXNzaW9uRnJvbVVSTChwYXJhbXMsIGNhbGxiYWNrVXJsVHlwZSlcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5fZGVidWcoJyNfaW5pdGlhbGl6ZSgpJywgJ2Vycm9yIGRldGVjdGluZyBzZXNzaW9uIGZyb20gVVJMJywgZXJyb3IpXG5cbiAgICAgICAgICBpZiAoaXNBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBlcnJvci5kZXRhaWxzPy5jb2RlXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gJ2lkZW50aXR5X2FscmVhZHlfZXhpc3RzJyB8fFxuICAgICAgICAgICAgICBlcnJvckNvZGUgPT09ICdpZGVudGl0eV9ub3RfZm91bmQnIHx8XG4gICAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gJ3NpbmdsZV9pZGVudGl0eV9ub3RfZGVsZXRhYmxlJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGVycm9yIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBmYWlsZWQgbG9naW4gYXR0ZW1wdCB2aWEgdXJsLFxuICAgICAgICAgIC8vIHJlbW92ZSBvbGQgc2Vzc2lvbiBhcyBpbiB2ZXJpZnlPdHAsIHNpZ25VcCBhbmQgc2lnbkluV2l0aCpcbiAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKClcblxuICAgICAgICAgIHJldHVybiB7IGVycm9yIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc2Vzc2lvbiwgcmVkaXJlY3RUeXBlIH0gPSBkYXRhXG5cbiAgICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgICAgJyNfaW5pdGlhbGl6ZSgpJyxcbiAgICAgICAgICAnZGV0ZWN0ZWQgc2Vzc2lvbiBpbiBVUkwnLFxuICAgICAgICAgIHNlc3Npb24sXG4gICAgICAgICAgJ3JlZGlyZWN0IHR5cGUnLFxuICAgICAgICAgIHJlZGlyZWN0VHlwZVxuICAgICAgICApXG5cbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbilcblxuICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICBpZiAocmVkaXJlY3RUeXBlID09PSAncmVjb3ZlcnknKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnUEFTU1dPUkRfUkVDT1ZFUlknLCBzZXNzaW9uKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbilcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApXG5cbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfVxuICAgICAgfVxuICAgICAgLy8gbm8gbG9naW4gYXR0ZW1wdCB2aWEgY2FsbGJhY2sgdXJsIHRyeSB0byByZWNvdmVyIHNlc3Npb24gZnJvbSBzdG9yYWdlXG4gICAgICBhd2FpdCB0aGlzLl9yZWNvdmVyQW5kUmVmcmVzaCgpXG4gICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogbmV3IEF1dGhVbmtub3duRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgZHVyaW5nIGluaXRpYWxpemF0aW9uJywgZXJyb3IpLFxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCB0aGlzLl9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKClcbiAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGFub255bW91cyB1c2VyLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHNlc3Npb24gd2hlcmUgdGhlIGlzX2Fub255bW91cyBjbGFpbSBpbiB0aGUgYWNjZXNzIHRva2VuIEpXVCBzZXQgdG8gdHJ1ZVxuICAgKi9cbiAgYXN5bmMgc2lnbkluQW5vbnltb3VzbHkoY3JlZGVudGlhbHM/OiBTaWduSW5Bbm9ueW1vdXNseUNyZWRlbnRpYWxzKTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc2lnbnVwYCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBkYXRhOiBjcmVkZW50aWFscz8ub3B0aW9ucz8uZGF0YSA/PyB7fSxcbiAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBjcmVkZW50aWFscz8ub3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgfSlcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc1xuXG4gICAgICBpZiAoZXJyb3IgfHwgIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9XG4gICAgICB9XG4gICAgICBjb25zdCBzZXNzaW9uOiBTZXNzaW9uIHwgbnVsbCA9IGRhdGEuc2Vzc2lvblxuICAgICAgY29uc3QgdXNlcjogVXNlciB8IG51bGwgPSBkYXRhLnVzZXJcblxuICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBzZXNzaW9uKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdXNlci5cbiAgICpcbiAgICogQmUgYXdhcmUgdGhhdCBpZiBhIHVzZXIgYWNjb3VudCBleGlzdHMgaW4gdGhlIHN5c3RlbSB5b3UgbWF5IGdldCBiYWNrIGFuXG4gICAqIGVycm9yIG1lc3NhZ2UgdGhhdCBhdHRlbXB0cyB0byBoaWRlIHRoaXMgaW5mb3JtYXRpb24gZnJvbSB0aGUgdXNlci5cbiAgICogVGhpcyBtZXRob2QgaGFzIHN1cHBvcnQgZm9yIFBLQ0UgdmlhIGVtYWlsIHNpZ251cHMuIFRoZSBQS0NFIGZsb3cgY2Fubm90IGJlIHVzZWQgd2hlbiBhdXRvY29uZmlybSBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIGxvZ2dlZC1pbiBzZXNzaW9uIGlmIHRoZSBzZXJ2ZXIgaGFzIFwiYXV0b2NvbmZpcm1cIiBPTlxuICAgKiBAcmV0dXJucyBBIHVzZXIgaWYgdGhlIHNlcnZlciBoYXMgXCJhdXRvY29uZmlybVwiIE9GRlxuICAgKi9cbiAgYXN5bmMgc2lnblVwKGNyZWRlbnRpYWxzOiBTaWduVXBXaXRoUGFzc3dvcmRDcmVkZW50aWFscyk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXM6IEF1dGhSZXNwb25zZVxuICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBlbWFpbCwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZDogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgIDtbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlS2V5XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucz8uZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICBkYXRhOiBvcHRpb25zPy5kYXRhID8/IHt9LFxuICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgcGhvbmUsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFsc1xuICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICBkYXRhOiBvcHRpb25zPy5kYXRhID8/IHt9LFxuICAgICAgICAgICAgY2hhbm5lbDogb3B0aW9ucz8uY2hhbm5lbCA/PyAnc21zJyxcbiAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKFxuICAgICAgICAgICdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzXG5cbiAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwgPSBkYXRhLnNlc3Npb25cbiAgICAgIGNvbnN0IHVzZXI6IFVzZXIgfCBudWxsID0gZGF0YS51c2VyXG5cbiAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbilcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgaW4gYW4gZXhpc3RpbmcgdXNlciB3aXRoIGFuIGVtYWlsIGFuZCBwYXNzd29yZCBvciBwaG9uZSBhbmQgcGFzc3dvcmQuXG4gICAqXG4gICAqIEJlIGF3YXJlIHRoYXQgeW91IG1heSBnZXQgYmFjayBhbiBlcnJvciBtZXNzYWdlIHRoYXQgd2lsbCBub3QgZGlzdGluZ3Vpc2hcbiAgICogYmV0d2VlbiB0aGUgY2FzZXMgd2hlcmUgdGhlIGFjY291bnQgZG9lcyBub3QgZXhpc3Qgb3IgdGhhdCB0aGVcbiAgICogZW1haWwvcGhvbmUgYW5kIHBhc3N3b3JkIGNvbWJpbmF0aW9uIGlzIHdyb25nIG9yIHRoYXQgdGhlIGFjY291bnQgY2FuIG9ubHlcbiAgICogYmUgYWNjZXNzZWQgdmlhIHNvY2lhbCBsb2dpbi5cbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhQYXNzd29yZChcbiAgICBjcmVkZW50aWFsczogU2lnbkluV2l0aFBhc3N3b3JkQ3JlZGVudGlhbHNcbiAgKTogUHJvbWlzZTxBdXRoVG9rZW5SZXNwb25zZVBhc3N3b3JkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXM6IEF1dGhSZXNwb25zZVBhc3N3b3JkXG4gICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCB7IGVtYWlsLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHNcbiAgICAgICAgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1wYXNzd29yZGAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZCxcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCB7IHBob25lLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHNcbiAgICAgICAgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1wYXNzd29yZGAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZCxcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoXG4gICAgICAgICAgJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlciBhbmQgYSBwYXNzd29yZCdcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfSBlbHNlIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBuZXcgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKSB9XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbilcbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGRhdGEuc2Vzc2lvbilcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB1c2VyOiBkYXRhLnVzZXIsXG4gICAgICAgICAgc2Vzc2lvbjogZGF0YS5zZXNzaW9uLFxuICAgICAgICAgIC4uLihkYXRhLndlYWtfcGFzc3dvcmQgPyB7IHdlYWtQYXNzd29yZDogZGF0YS53ZWFrX3Bhc3N3b3JkIH0gOiBudWxsKSxcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IsXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIHZpYSBhIHRoaXJkLXBhcnR5IHByb3ZpZGVyLlxuICAgKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0aGUgUEtDRSBmbG93LlxuICAgKi9cbiAgYXN5bmMgc2lnbkluV2l0aE9BdXRoKGNyZWRlbnRpYWxzOiBTaWduSW5XaXRoT0F1dGhDcmVkZW50aWFscyk6IFByb21pc2U8T0F1dGhSZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9oYW5kbGVQcm92aWRlclNpZ25JbihjcmVkZW50aWFscy5wcm92aWRlciwge1xuICAgICAgcmVkaXJlY3RUbzogY3JlZGVudGlhbHMub3B0aW9ucz8ucmVkaXJlY3RUbyxcbiAgICAgIHNjb3BlczogY3JlZGVudGlhbHMub3B0aW9ucz8uc2NvcGVzLFxuICAgICAgcXVlcnlQYXJhbXM6IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnF1ZXJ5UGFyYW1zLFxuICAgICAgc2tpcEJyb3dzZXJSZWRpcmVjdDogY3JlZGVudGlhbHMub3B0aW9ucz8uc2tpcEJyb3dzZXJSZWRpcmVjdCxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIGJ5IGV4Y2hhbmdpbmcgYW4gQXV0aCBDb2RlIGlzc3VlZCBkdXJpbmcgdGhlIFBLQ0UgZmxvdy5cbiAgICovXG4gIGFzeW5jIGV4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGU6IHN0cmluZyk6IFByb21pc2U8QXV0aFRva2VuUmVzcG9uc2U+IHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9leGNoYW5nZUNvZGVGb3JTZXNzaW9uKGF1dGhDb2RlKVxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9leGNoYW5nZUNvZGVGb3JTZXNzaW9uKGF1dGhDb2RlOiBzdHJpbmcpOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IHNlc3Npb246IFNlc3Npb247IHVzZXI6IFVzZXI7IHJlZGlyZWN0VHlwZTogc3RyaW5nIHwgbnVsbCB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbDsgdXNlcjogbnVsbDsgcmVkaXJlY3RUeXBlOiBudWxsIH07IGVycm9yOiBBdXRoRXJyb3IgfVxuICA+IHtcbiAgICBjb25zdCBzdG9yYWdlSXRlbSA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApXG4gICAgY29uc3QgW2NvZGVWZXJpZmllciwgcmVkaXJlY3RUeXBlXSA9ICgoc3RvcmFnZUl0ZW0gPz8gJycpIGFzIHN0cmluZykuc3BsaXQoJy8nKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICAnUE9TVCcsXG4gICAgICAgIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXBrY2VgLFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGF1dGhfY29kZTogYXV0aENvZGUsXG4gICAgICAgICAgICBjb2RlX3ZlcmlmaWVyOiBjb2RlVmVyaWZpZXIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYClcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgcmVkaXJlY3RUeXBlOiBudWxsIH0sXG4gICAgICAgICAgZXJyb3I6IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbilcbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGRhdGEuc2Vzc2lvbilcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgLi4uZGF0YSwgcmVkaXJlY3RUeXBlOiByZWRpcmVjdFR5cGUgPz8gbnVsbCB9LCBlcnJvciB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3Mgc2lnbmluZyBpbiB3aXRoIGFuIE9JREMgSUQgdG9rZW4uIFRoZSBhdXRoZW50aWNhdGlvbiBwcm92aWRlciB1c2VkXG4gICAqIHNob3VsZCBiZSBlbmFibGVkIGFuZCBjb25maWd1cmVkLlxuICAgKi9cbiAgYXN5bmMgc2lnbkluV2l0aElkVG9rZW4oY3JlZGVudGlhbHM6IFNpZ25JbldpdGhJZFRva2VuQ3JlZGVudGlhbHMpOiBQcm9taXNlPEF1dGhUb2tlblJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgb3B0aW9ucywgcHJvdmlkZXIsIHRva2VuLCBhY2Nlc3NfdG9rZW4sIG5vbmNlIH0gPSBjcmVkZW50aWFsc1xuXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPWlkX3Rva2VuYCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICBpZF90b2tlbjogdG9rZW4sXG4gICAgICAgICAgYWNjZXNzX3Rva2VuLFxuICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICB9LFxuICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9IGVsc2UgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LFxuICAgICAgICAgIGVycm9yOiBuZXcgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKSxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pXG4gICAgICB9XG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvciB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgbWFnaWNsaW5rIG9yIGEgb25lLXRpbWUgcGFzc3dvcmQgKE9UUCkuXG4gICAqXG4gICAqIElmIHRoZSBge3sgLkNvbmZpcm1hdGlvblVSTCB9fWAgdmFyaWFibGUgaXMgc3BlY2lmaWVkIGluIHRoZSBlbWFpbCB0ZW1wbGF0ZSwgYSBtYWdpY2xpbmsgd2lsbCBiZSBzZW50LlxuICAgKiBJZiB0aGUgYHt7IC5Ub2tlbiB9fWAgdmFyaWFibGUgaXMgc3BlY2lmaWVkIGluIHRoZSBlbWFpbCB0ZW1wbGF0ZSwgYW4gT1RQIHdpbGwgYmUgc2VudC5cbiAgICogSWYgeW91J3JlIHVzaW5nIHBob25lIHNpZ24taW5zLCBvbmx5IGFuIE9UUCB3aWxsIGJlIHNlbnQuIFlvdSB3b24ndCBiZSBhYmxlIHRvIHNlbmQgYSBtYWdpY2xpbmsgZm9yIHBob25lIHNpZ24taW5zLlxuICAgKlxuICAgKiBCZSBhd2FyZSB0aGF0IHlvdSBtYXkgZ2V0IGJhY2sgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IHdpbGwgbm90IGRpc3Rpbmd1aXNoXG4gICAqIGJldHdlZW4gdGhlIGNhc2VzIHdoZXJlIHRoZSBhY2NvdW50IGRvZXMgbm90IGV4aXN0IG9yLCB0aGF0IHRoZSBhY2NvdW50XG4gICAqIGNhbiBvbmx5IGJlIGFjY2Vzc2VkIHZpYSBzb2NpYWwgbG9naW4uXG4gICAqXG4gICAqIERvIG5vdGUgdGhhdCB5b3Ugd2lsbCBuZWVkIHRvIGNvbmZpZ3VyZSBhIFdoYXRzYXBwIHNlbmRlciBvbiBUd2lsaW9cbiAgICogaWYgeW91IGFyZSB1c2luZyBwaG9uZSBzaWduIGluIHdpdGggdGhlICd3aGF0c2FwcCcgY2hhbm5lbC4gVGhlIHdoYXRzYXBwXG4gICAqIGNoYW5uZWwgaXMgbm90IHN1cHBvcnRlZCBvbiBvdGhlciBwcm92aWRlcnNcbiAgICogYXQgdGhpcyB0aW1lLlxuICAgKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBQS0NFIHdoZW4gYW4gZW1haWwgaXMgcGFzc2VkLlxuICAgKi9cbiAgYXN5bmMgc2lnbkluV2l0aE90cChjcmVkZW50aWFsczogU2lnbkluV2l0aFBhc3N3b3JkbGVzc0NyZWRlbnRpYWxzKTogUHJvbWlzZTxBdXRoT3RwUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBlbWFpbCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHNcbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2U6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgO1tjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QoXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UsXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2VLZXlcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vb3RwYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgIGRhdGE6IG9wdGlvbnM/LmRhdGEgPz8ge30sXG4gICAgICAgICAgICBjcmVhdGVfdXNlcjogb3B0aW9ucz8uc2hvdWxkQ3JlYXRlVXNlciA/PyB0cnVlLFxuICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnM/LmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgcGhvbmUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L290cGAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICBkYXRhOiBvcHRpb25zPy5kYXRhID8/IHt9LFxuICAgICAgICAgICAgY3JlYXRlX3VzZXI6IG9wdGlvbnM/LnNob3VsZENyZWF0ZVVzZXIgPz8gdHJ1ZSxcbiAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgY2hhbm5lbDogb3B0aW9ucz8uY2hhbm5lbCA/PyAnc21zJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIG1lc3NhZ2VJZDogZGF0YT8ubWVzc2FnZV9pZCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIuJylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgaW4gYSB1c2VyIGdpdmVuIGEgVXNlciBzdXBwbGllZCBPVFAgb3IgVG9rZW5IYXNoIHJlY2VpdmVkIHRocm91Z2ggbW9iaWxlIG9yIGVtYWlsLlxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5T3RwKHBhcmFtczogVmVyaWZ5T3RwUGFyYW1zKTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IHJlZGlyZWN0VG86IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICAgICAgbGV0IGNhcHRjaGFUb2tlbjogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gICAgICBpZiAoJ29wdGlvbnMnIGluIHBhcmFtcykge1xuICAgICAgICByZWRpcmVjdFRvID0gcGFyYW1zLm9wdGlvbnM/LnJlZGlyZWN0VG9cbiAgICAgICAgY2FwdGNoYVRva2VuID0gcGFyYW1zLm9wdGlvbnM/LmNhcHRjaGFUb2tlblxuICAgICAgfVxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdmVyaWZ5YCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogY2FwdGNoYVRva2VuIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHJlZGlyZWN0VG8sXG4gICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgfSlcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkIG9uIHRva2VuIHZlcmlmaWNhdGlvbi4nKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXNzaW9uOiBTZXNzaW9uIHwgbnVsbCA9IGRhdGEuc2Vzc2lvblxuICAgICAgY29uc3QgdXNlcjogVXNlciA9IGRhdGEudXNlclxuXG4gICAgICBpZiAoc2Vzc2lvbj8uYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24gYXMgU2Vzc2lvbilcbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoXG4gICAgICAgICAgcGFyYW1zLnR5cGUgPT0gJ3JlY292ZXJ5JyA/ICdQQVNTV09SRF9SRUNPVkVSWScgOiAnU0lHTkVEX0lOJyxcbiAgICAgICAgICBzZXNzaW9uXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyBhIHNpbmdsZS1zaWduIG9uIHVzaW5nIGFuIGVudGVycHJpc2UgSWRlbnRpdHkgUHJvdmlkZXIuIEFcbiAgICogc3VjY2Vzc2Z1bCBTU08gYXR0ZW1wdCB3aWxsIHJlZGlyZWN0IHRoZSBjdXJyZW50IHBhZ2UgdG8gdGhlIGlkZW50aXR5XG4gICAqIHByb3ZpZGVyIGF1dGhvcml6YXRpb24gcGFnZS4gVGhlIHJlZGlyZWN0IFVSTCBpcyBpbXBsZW1lbnRhdGlvbiBhbmQgU1NPXG4gICAqIHByb3RvY29sIHNwZWNpZmljLlxuICAgKlxuICAgKiBZb3UgY2FuIHVzZSBpdCBieSBwcm92aWRpbmcgYSBTU08gZG9tYWluLiBUeXBpY2FsbHkgeW91IGNhbiBleHRyYWN0IHRoaXNcbiAgICogZG9tYWluIGJ5IGFza2luZyB1c2VycyBmb3IgdGhlaXIgZW1haWwgYWRkcmVzcy4gSWYgdGhpcyBkb21haW4gaXNcbiAgICogcmVnaXN0ZXJlZCBvbiB0aGUgQXV0aCBpbnN0YW5jZSB0aGUgcmVkaXJlY3Qgd2lsbCB1c2UgdGhhdCBvcmdhbml6YXRpb24nc1xuICAgKiBjdXJyZW50bHkgYWN0aXZlIFNTTyBJZGVudGl0eSBQcm92aWRlciBmb3IgdGhlIGxvZ2luLlxuICAgKlxuICAgKiBJZiB5b3UgaGF2ZSBidWlsdCBhbiBvcmdhbml6YXRpb24tc3BlY2lmaWMgbG9naW4gcGFnZSwgeW91IGNhbiB1c2UgdGhlXG4gICAqIG9yZ2FuaXphdGlvbidzIFNTTyBJZGVudGl0eSBQcm92aWRlciBVVUlEIGRpcmVjdGx5IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBzaWduSW5XaXRoU1NPKHBhcmFtczogU2lnbkluV2l0aFNTTyk6IFByb21pc2U8U1NPUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IGNvZGVDaGFsbGVuZ2U6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZDogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgO1tjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QoXG4gICAgICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgICAgIHRoaXMuc3RvcmFnZUtleVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zc29gLCB7XG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAuLi4oJ3Byb3ZpZGVySWQnIGluIHBhcmFtcyA/IHsgcHJvdmlkZXJfaWQ6IHBhcmFtcy5wcm92aWRlcklkIH0gOiBudWxsKSxcbiAgICAgICAgICAuLi4oJ2RvbWFpbicgaW4gcGFyYW1zID8geyBkb21haW46IHBhcmFtcy5kb21haW4gfSA6IG51bGwpLFxuICAgICAgICAgIHJlZGlyZWN0X3RvOiBwYXJhbXMub3B0aW9ucz8ucmVkaXJlY3RUbyA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgLi4uKHBhcmFtcz8ub3B0aW9ucz8uY2FwdGNoYVRva2VuXG4gICAgICAgICAgICA/IHsgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogcGFyYW1zLm9wdGlvbnMuY2FwdGNoYVRva2VuIH0gfVxuICAgICAgICAgICAgOiBudWxsKSxcbiAgICAgICAgICBza2lwX2h0dHBfcmVkaXJlY3Q6IHRydWUsIC8vIGZldGNoIGRvZXMgbm90IGhhbmRsZSByZWRpcmVjdHNcbiAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgeGZvcm06IF9zc29SZXNwb25zZSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSByZWF1dGhlbnRpY2F0aW9uIE9UUCB0byB0aGUgdXNlcidzIGVtYWlsIG9yIHBob25lIG51bWJlci5cbiAgICogUmVxdWlyZXMgdGhlIHVzZXIgdG8gYmUgc2lnbmVkLWluLlxuICAgKi9cbiAgYXN5bmMgcmVhdXRoZW50aWNhdGUoKTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZWF1dGhlbnRpY2F0ZSgpXG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX3JlYXV0aGVudGljYXRlKCk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRhdGE6IHsgc2Vzc2lvbiB9LFxuICAgICAgICAgIGVycm9yOiBzZXNzaW9uRXJyb3IsXG4gICAgICAgIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKHNlc3Npb25FcnJvcikgdGhyb3cgc2Vzc2lvbkVycm9yXG4gICAgICAgIGlmICghc2Vzc2lvbikgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcblxuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L3JlYXV0aGVudGljYXRlYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzZW5kcyBhbiBleGlzdGluZyBzaWdudXAgY29uZmlybWF0aW9uIGVtYWlsLCBlbWFpbCBjaGFuZ2UgZW1haWwsIFNNUyBPVFAgb3IgcGhvbmUgY2hhbmdlIE9UUC5cbiAgICovXG4gIGFzeW5jIHJlc2VuZChjcmVkZW50aWFsczogUmVzZW5kUGFyYW1zKTogUHJvbWlzZTxBdXRoT3RwUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLnVybH0vcmVzZW5kYFxuICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBlbWFpbCwgdHlwZSwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHNcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBlbmRwb2ludCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnM/LmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH0gZWxzZSBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCB7IHBob25lLCB0eXBlLCBvcHRpb25zIH0gPSBjcmVkZW50aWFsc1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGVuZHBvaW50LCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgbWVzc2FnZUlkOiBkYXRhPy5tZXNzYWdlX2lkIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoXG4gICAgICAgICdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgdHlwZSdcbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2Vzc2lvbiwgcmVmcmVzaGluZyBpdCBpZiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIFRoZSBzZXNzaW9uIHJldHVybmVkIGNhbiBiZSBudWxsIGlmIHRoZSBzZXNzaW9uIGlzIG5vdCBkZXRlY3RlZCB3aGljaCBjYW4gaGFwcGVuIGluIHRoZSBldmVudCBhIHVzZXIgaXMgbm90IHNpZ25lZC1pbiBvciBoYXMgbG9nZ2VkIG91dC5cbiAgICpcbiAgICogKipJTVBPUlRBTlQ6KiogVGhpcyBtZXRob2QgbG9hZHMgdmFsdWVzIGRpcmVjdGx5IGZyb20gdGhlIHN0b3JhZ2UgYXR0YWNoZWRcbiAgICogdG8gdGhlIGNsaWVudC4gSWYgdGhhdCBzdG9yYWdlIGlzIGJhc2VkIG9uIHJlcXVlc3QgY29va2llcyBmb3IgZXhhbXBsZSxcbiAgICogdGhlIHZhbHVlcyBpbiBpdCBtYXkgbm90IGJlIGF1dGhlbnRpYyBhbmQgdGhlcmVmb3JlIGl0J3Mgc3Ryb25nbHkgYWR2aXNlZFxuICAgKiBhZ2FpbnN0IHVzaW5nIHRoaXMgbWV0aG9kIGFuZCBpdHMgcmVzdWx0cyBpbiBzdWNoIGNpcmN1bXN0YW5jZXMuIEEgd2FybmluZ1xuICAgKiB3aWxsIGJlIGVtaXR0ZWQgaWYgdGhpcyBpcyBkZXRlY3RlZC4gVXNlIHtAbGluayAjZ2V0VXNlcigpfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0U2Vzc2lvbigpIHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKipcbiAgICogQWNxdWlyZXMgYSBnbG9iYWwgbG9jayBiYXNlZCBvbiB0aGUgc3RvcmFnZSBrZXkuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9hY3F1aXJlTG9jazxSPihhY3F1aXJlVGltZW91dDogbnVtYmVyLCBmbjogKCkgPT4gUHJvbWlzZTxSPik6IFByb21pc2U8Uj4ge1xuICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2JlZ2luJywgYWNxdWlyZVRpbWVvdXQpXG5cbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMubG9ja0FjcXVpcmVkKSB7XG4gICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoXG4gICAgICAgICAgPyB0aGlzLnBlbmRpbmdJbkxvY2tbdGhpcy5wZW5kaW5nSW5Mb2NrLmxlbmd0aCAtIDFdXG4gICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoKVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgbGFzdFxuICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpXG4gICAgICAgIH0pKClcblxuICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2sucHVzaChcbiAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgcmVzdWx0XG4gICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgICAgLy8gd2UganVzdCBjYXJlIGlmIGl0IGZpbmlzaGVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKVxuICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2NrKGBsb2NrOiR7dGhpcy5zdG9yYWdlS2V5fWAsIGFjcXVpcmVUaW1lb3V0LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2xvY2sgYWNxdWlyZWQgZm9yIHN0b3JhZ2Uga2V5JywgdGhpcy5zdG9yYWdlS2V5KVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5sb2NrQWNxdWlyZWQgPSB0cnVlXG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBmbigpXG5cbiAgICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2sucHVzaChcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmVzdWx0XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGp1c3QgY2FyZSBpZiBpdCBmaW5pc2hlZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgYXdhaXQgcmVzdWx0XG5cbiAgICAgICAgICAvLyBrZWVwIGRyYWluaW5nIHRoZSBxdWV1ZSB1bnRpbCB0aGVyZSdzIG5vdGhpbmcgdG8gd2FpdCBvblxuICAgICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB3YWl0T24gPSBbLi4udGhpcy5wZW5kaW5nSW5Mb2NrXVxuXG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh3YWl0T24pXG5cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0luTG9jay5zcGxpY2UoMCwgd2FpdE9uLmxlbmd0aClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzdWx0XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5fZGVidWcoJyNfYWNxdWlyZUxvY2snLCAnbG9jayByZWxlYXNlZCBmb3Igc3RvcmFnZSBrZXknLCB0aGlzLnN0b3JhZ2VLZXkpXG5cbiAgICAgICAgICB0aGlzLmxvY2tBY3F1aXJlZCA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZSBpbnN0ZWFkIG9mIHtAbGluayAjZ2V0U2Vzc2lvbn0gaW5zaWRlIHRoZSBsaWJyYXJ5LiBJdCBpc1xuICAgKiBzZW1hbnRpY2FsbHkgdXN1YWxseSB3aGF0IHlvdSB3YW50LCBhcyBnZXR0aW5nIGEgc2Vzc2lvbiBpbnZvbHZlcyBzb21lXG4gICAqIHByb2Nlc3NpbmcgYWZ0ZXJ3YXJkcyB0aGF0IHJlcXVpcmVzIG9ubHkgb25lIGNsaWVudCBvcGVyYXRpbmcgb24gdGhlXG4gICAqIHNlc3Npb24gYXQgb25jZSBhY3Jvc3MgbXVsdGlwbGUgdGFicyBvciBwcm9jZXNzZXMuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF91c2VTZXNzaW9uPFI+KFxuICAgIGZuOiAoXG4gICAgICByZXN1bHQ6XG4gICAgICAgIHwge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBzZXNzaW9uOiBTZXNzaW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfCB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yOiBBdXRoRXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIHwge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBzZXNzaW9uOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgIH1cbiAgICApID0+IFByb21pc2U8Uj5cbiAgKTogUHJvbWlzZTxSPiB7XG4gICAgdGhpcy5fZGVidWcoJyNfdXNlU2Vzc2lvbicsICdiZWdpbicpXG5cbiAgICB0cnkge1xuICAgICAgLy8gdGhlIHVzZSBvZiBfX2xvYWRTZXNzaW9uIGhlcmUgaXMgdGhlIG9ubHkgY29ycmVjdCB1c2Ugb2YgdGhlIGZ1bmN0aW9uIVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fX2xvYWRTZXNzaW9uKClcblxuICAgICAgcmV0dXJuIGF3YWl0IGZuKHJlc3VsdClcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fZGVidWcoJyNfdXNlU2Vzc2lvbicsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBORVZFUiBVU0UgRElSRUNUTFkhXG4gICAqXG4gICAqIEFsd2F5cyB1c2Uge0BsaW5rICNfdXNlU2Vzc2lvbn0uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9fbG9hZFNlc3Npb24oKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHNlc3Npb246IFNlc3Npb25cbiAgICAgICAgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc2Vzc2lvbjogbnVsbFxuICAgICAgICB9XG4gICAgICAgIGVycm9yOiBBdXRoRXJyb3JcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgICAgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICA+IHtcbiAgICB0aGlzLl9kZWJ1ZygnI19fbG9hZFNlc3Npb24oKScsICdiZWdpbicpXG5cbiAgICBpZiAoIXRoaXMubG9ja0FjcXVpcmVkKSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnI19fbG9hZFNlc3Npb24oKScsICd1c2VkIG91dHNpZGUgb2YgYW4gYWNxdWlyZWQgbG9jayEnLCBuZXcgRXJyb3IoKS5zdGFjaylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgbGV0IGN1cnJlbnRTZXNzaW9uOiBTZXNzaW9uIHwgbnVsbCA9IG51bGxcblxuICAgICAgY29uc3QgbWF5YmVTZXNzaW9uID0gYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KVxuXG4gICAgICB0aGlzLl9kZWJ1ZygnI2dldFNlc3Npb24oKScsICdzZXNzaW9uIGZyb20gc3RvcmFnZScsIG1heWJlU2Vzc2lvbilcblxuICAgICAgaWYgKG1heWJlU2Vzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5faXNWYWxpZFNlc3Npb24obWF5YmVTZXNzaW9uKSkge1xuICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gbWF5YmVTZXNzaW9uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZGVidWcoJyNnZXRTZXNzaW9uKCknLCAnc2Vzc2lvbiBmcm9tIHN0b3JhZ2UgaXMgbm90IHZhbGlkJylcbiAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhhc0V4cGlyZWQgPSBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0XG4gICAgICAgID8gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdCA8PSBEYXRlLm5vdygpIC8gMTAwMFxuICAgICAgICA6IGZhbHNlXG5cbiAgICAgIHRoaXMuX2RlYnVnKFxuICAgICAgICAnI19fbG9hZFNlc3Npb24oKScsXG4gICAgICAgIGBzZXNzaW9uIGhhcyR7aGFzRXhwaXJlZCA/ICcnIDogJyBub3QnfSBleHBpcmVkYCxcbiAgICAgICAgJ2V4cGlyZXNfYXQnLFxuICAgICAgICBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0XG4gICAgICApXG5cbiAgICAgIGlmICghaGFzRXhwaXJlZCkge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlLmlzU2VydmVyKSB7XG4gICAgICAgICAgbGV0IHN1cHByZXNzV2FybmluZyA9IHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZ1xuICAgICAgICAgIGNvbnN0IHByb3h5U2Vzc2lvbjogU2Vzc2lvbiA9IG5ldyBQcm94eShjdXJyZW50U2Vzc2lvbiwge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0OiBhbnksIHByb3A6IHN0cmluZywgcmVjZWl2ZXI6IGFueSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXN1cHByZXNzV2FybmluZyAmJiBwcm9wID09PSAndXNlcicpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHNob3cgd2FybmluZyB3aGVuIHRoZSB1c2VyIG9iamVjdCBpcyBiZWluZyBhY2Nlc3NlZCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAnVXNpbmcgdGhlIHVzZXIgb2JqZWN0IGFzIHJldHVybmVkIGZyb20gc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKCkgb3IgZnJvbSBzb21lIHN1cGFiYXNlLmF1dGgub25BdXRoU3RhdGVDaGFuZ2UoKSBldmVudHMgY291bGQgYmUgaW5zZWN1cmUhIFRoaXMgdmFsdWUgY29tZXMgZGlyZWN0bHkgZnJvbSB0aGUgc3RvcmFnZSBtZWRpdW0gKHVzdWFsbHkgY29va2llcyBvbiB0aGUgc2VydmVyKSBhbmQgbWF5IG5vdCBiZSBhdXRoZW50aWMuIFVzZSBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKSBpbnN0ZWFkIHdoaWNoIGF1dGhlbnRpY2F0ZXMgdGhlIGRhdGEgYnkgY29udGFjdGluZyB0aGUgU3VwYWJhc2UgQXV0aCBzZXJ2ZXIuJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBzdXBwcmVzc1dhcm5pbmcgPSB0cnVlIC8vIGtlZXBzIHRoaXMgcHJveHkgaW5zdGFuY2UgZnJvbSBsb2dnaW5nIGFkZGl0aW9uYWwgd2FybmluZ3NcbiAgICAgICAgICAgICAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSB0cnVlIC8vIGtlZXBzIHRoaXMgY2xpZW50J3MgZnV0dXJlIHByb3h5IGluc3RhbmNlcyBmcm9tIHdhcm5pbmdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSlcbiAgICAgICAgICBjdXJyZW50U2Vzc2lvbiA9IHByb3h5U2Vzc2lvblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBjdXJyZW50U2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgc2Vzc2lvbiwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbilcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnI19fbG9hZFNlc3Npb24oKScsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHVzZXIgZGV0YWlscyBpZiB0aGVyZSBpcyBhbiBleGlzdGluZyBzZXNzaW9uLiBUaGlzIG1ldGhvZFxuICAgKiBwZXJmb3JtcyBhIG5ldHdvcmsgcmVxdWVzdCB0byB0aGUgU3VwYWJhc2UgQXV0aCBzZXJ2ZXIsIHNvIHRoZSByZXR1cm5lZFxuICAgKiB2YWx1ZSBpcyBhdXRoZW50aWMgYW5kIGNhbiBiZSB1c2VkIHRvIGJhc2UgYXV0aG9yaXphdGlvbiBydWxlcyBvbi5cbiAgICpcbiAgICogQHBhcmFtIGp3dCBUYWtlcyBpbiBhbiBvcHRpb25hbCBhY2Nlc3MgdG9rZW4gSldULiBJZiBubyBKV1QgaXMgcHJvdmlkZWQsIHRoZSBKV1QgZnJvbSB0aGUgY3VycmVudCBzZXNzaW9uIGlzIHVzZWQuXG4gICAqL1xuICBhc3luYyBnZXRVc2VyKGp3dD86IHN0cmluZyk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgaWYgKGp3dCkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldFVzZXIoand0KVxuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZ2V0VXNlcigpXG4gICAgfSlcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2dldFVzZXIoand0Pzogc3RyaW5nKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKGp3dCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBqd3Q6IGp3dCxcbiAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybnMgYW4gZXJyb3IgaWYgdGhlcmUgaXMgbm8gYWNjZXNzX3Rva2VuIG9yIGN1c3RvbSBhdXRob3JpemF0aW9uIGhlYWRlclxuICAgICAgICBpZiAoIWRhdGEuc2Vzc2lvbj8uYWNjZXNzX3Rva2VuICYmICF0aGlzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3I6IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGp3dDogZGF0YS5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4gPz8gdW5kZWZpbmVkLFxuICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICBpZiAoaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAvLyBKV1QgY29udGFpbnMgYSBgc2Vzc2lvbl9pZGAgd2hpY2ggZG9lcyBub3QgY29ycmVzcG9uZCB0byBhbiBhY3RpdmVcbiAgICAgICAgICAvLyBzZXNzaW9uIGluIHRoZSBkYXRhYmFzZSwgaW5kaWNhdGluZyB0aGUgdXNlciBpcyBzaWduZWQgb3V0LlxuXG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG4gICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdXNlciBkYXRhIGZvciBhIGxvZ2dlZCBpbiB1c2VyLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlVXNlcihcbiAgICBhdHRyaWJ1dGVzOiBVc2VyQXR0cmlidXRlcyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBlbWFpbFJlZGlyZWN0VG8/OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICB9ID0ge31cbiAgKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91cGRhdGVVc2VyKGF0dHJpYnV0ZXMsIG9wdGlvbnMpXG4gICAgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfdXBkYXRlVXNlcihcbiAgICBhdHRyaWJ1dGVzOiBVc2VyQXR0cmlidXRlcyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBlbWFpbFJlZGlyZWN0VG8/OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICB9ID0ge31cbiAgKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgIHRocm93IHNlc3Npb25FcnJvclxuICAgICAgICB9XG4gICAgICAgIGlmICghc2Vzc2lvbkRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Vzc2lvbjogU2Vzc2lvbiA9IHNlc3Npb25EYXRhLnNlc3Npb25cbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2U6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnICYmIGF0dHJpYnV0ZXMuZW1haWwgIT0gbnVsbCkge1xuICAgICAgICAgIDtbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlS2V5XG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogdXNlckVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUFVUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnM/LmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICB9KVxuICAgICAgICBpZiAodXNlckVycm9yKSB0aHJvdyB1c2VyRXJyb3JcbiAgICAgICAgc2Vzc2lvbi51c2VyID0gZGF0YS51c2VyIGFzIFVzZXJcbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbilcbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1VTRVJfVVBEQVRFRCcsIHNlc3Npb24pXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyIH0sIGVycm9yOiBudWxsIH1cbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlcyBhIEpXVCAod2l0aG91dCBwZXJmb3JtaW5nIGFueSB2YWxpZGF0aW9uKS5cbiAgICovXG4gIHByaXZhdGUgX2RlY29kZUpXVChqd3Q6IHN0cmluZyk6IHtcbiAgICBleHA/OiBudW1iZXJcbiAgICBhYWw/OiBBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWxzIHwgbnVsbFxuICAgIGFtcj86IEFNUkVudHJ5W10gfCBudWxsXG4gIH0ge1xuICAgIHJldHVybiBkZWNvZGVKV1RQYXlsb2FkKGp3dClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZXNzaW9uIGRhdGEgZnJvbSB0aGUgY3VycmVudCBzZXNzaW9uLiBJZiB0aGUgY3VycmVudCBzZXNzaW9uIGlzIGV4cGlyZWQsIHNldFNlc3Npb24gd2lsbCB0YWtlIGNhcmUgb2YgcmVmcmVzaGluZyBpdCB0byBvYnRhaW4gYSBuZXcgc2Vzc2lvbi5cbiAgICogSWYgdGhlIHJlZnJlc2ggdG9rZW4gb3IgYWNjZXNzIHRva2VuIGluIHRoZSBjdXJyZW50IHNlc3Npb24gaXMgaW52YWxpZCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqIEBwYXJhbSBjdXJyZW50U2Vzc2lvbiBUaGUgY3VycmVudCBzZXNzaW9uIHRoYXQgbWluaW1hbGx5IGNvbnRhaW5zIGFuIGFjY2VzcyB0b2tlbiBhbmQgcmVmcmVzaCB0b2tlbi5cbiAgICovXG4gIGFzeW5jIHNldFNlc3Npb24oY3VycmVudFNlc3Npb246IHtcbiAgICBhY2Nlc3NfdG9rZW46IHN0cmluZ1xuICAgIHJlZnJlc2hfdG9rZW46IHN0cmluZ1xuICB9KTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9zZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKVxuICAgIH0pXG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX3NldFNlc3Npb24oY3VycmVudFNlc3Npb246IHtcbiAgICBhY2Nlc3NfdG9rZW46IHN0cmluZ1xuICAgIHJlZnJlc2hfdG9rZW46IHN0cmluZ1xuICB9KTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4gfHwgIWN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGltZU5vdyA9IERhdGUubm93KCkgLyAxMDAwXG4gICAgICBsZXQgZXhwaXJlc0F0ID0gdGltZU5vd1xuICAgICAgbGV0IGhhc0V4cGlyZWQgPSB0cnVlXG4gICAgICBsZXQgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwgPSBudWxsXG4gICAgICBjb25zdCBwYXlsb2FkID0gZGVjb2RlSldUUGF5bG9hZChjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4pXG4gICAgICBpZiAocGF5bG9hZC5leHApIHtcbiAgICAgICAgZXhwaXJlc0F0ID0gcGF5bG9hZC5leHBcbiAgICAgICAgaGFzRXhwaXJlZCA9IGV4cGlyZXNBdCA8PSB0aW1lTm93XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNFeHBpcmVkKSB7XG4gICAgICAgIGNvbnN0IHsgc2Vzc2lvbjogcmVmcmVzaGVkU2Vzc2lvbiwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oXG4gICAgICAgICAgY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlblxuICAgICAgICApXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWZyZXNoZWRTZXNzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBudWxsIH1cbiAgICAgICAgfVxuICAgICAgICBzZXNzaW9uID0gcmVmcmVzaGVkU2Vzc2lvblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0VXNlcihjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4pXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH1cbiAgICAgICAgc2Vzc2lvbiA9IHtcbiAgICAgICAgICBhY2Nlc3NfdG9rZW46IGN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICByZWZyZXNoX3Rva2VuOiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuLFxuICAgICAgICAgIHVzZXI6IGRhdGEudXNlcixcbiAgICAgICAgICB0b2tlbl90eXBlOiAnYmVhcmVyJyxcbiAgICAgICAgICBleHBpcmVzX2luOiBleHBpcmVzQXQgLSB0aW1lTm93LFxuICAgICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCxcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbilcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBzZXNzaW9uLnVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgc2Vzc2lvbiwgcmVnYXJkbGVzcyBvZiBleHBpcnkgc3RhdHVzLlxuICAgKiBUYWtlcyBpbiBhbiBvcHRpb25hbCBjdXJyZW50IHNlc3Npb24uIElmIG5vdCBwYXNzZWQgaW4sIHRoZW4gcmVmcmVzaFNlc3Npb24oKSB3aWxsIGF0dGVtcHQgdG8gcmV0cmlldmUgaXQgZnJvbSBnZXRTZXNzaW9uKCkuXG4gICAqIElmIHRoZSBjdXJyZW50IHNlc3Npb24ncyByZWZyZXNoIHRva2VuIGlzIGludmFsaWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgKiBAcGFyYW0gY3VycmVudFNlc3Npb24gVGhlIGN1cnJlbnQgc2Vzc2lvbi4gSWYgcGFzc2VkIGluLCBpdCBtdXN0IGNvbnRhaW4gYSByZWZyZXNoIHRva2VuLlxuICAgKi9cbiAgYXN5bmMgcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24/OiB7IHJlZnJlc2hfdG9rZW46IHN0cmluZyB9KTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZWZyZXNoU2Vzc2lvbihjdXJyZW50U2Vzc2lvbilcbiAgICB9KVxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9yZWZyZXNoU2Vzc2lvbihjdXJyZW50U2Vzc2lvbj86IHtcbiAgICByZWZyZXNoX3Rva2VuOiBzdHJpbmdcbiAgfSk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50U2Vzc2lvbiA9IGRhdGEuc2Vzc2lvbiA/PyB1bmRlZmluZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY3VycmVudFNlc3Npb24/LnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBzZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IHNlc3Npb24udXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNlc3Npb24gZGF0YSBmcm9tIGEgVVJMIHN0cmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0U2Vzc2lvbkZyb21VUkwoXG4gICAgcGFyYW1zOiB7IFtwYXJhbWV0ZXI6IHN0cmluZ106IHN0cmluZyB9LFxuICAgIGNhbGxiYWNrVXJsVHlwZTogc3RyaW5nXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgc2Vzc2lvbjogU2Vzc2lvbjsgcmVkaXJlY3RUeXBlOiBzdHJpbmcgfCBudWxsIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHsgZGF0YTogeyBzZXNzaW9uOiBudWxsOyByZWRpcmVjdFR5cGU6IG51bGwgfTsgZXJyb3I6IEF1dGhFcnJvciB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWlzQnJvd3NlcigpKSB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdObyBicm93c2VyIGRldGVjdGVkLicpXG5cbiAgICAgIC8vIElmIHRoZXJlJ3MgYW4gZXJyb3IgaW4gdGhlIFVSTCwgaXQgZG9lc24ndCBtYXR0ZXIgd2hhdCBmbG93IGl0IGlzLCB3ZSBqdXN0IHJldHVybiB0aGUgZXJyb3IuXG4gICAgICBpZiAocGFyYW1zLmVycm9yIHx8IHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbiB8fCBwYXJhbXMuZXJyb3JfY29kZSkge1xuICAgICAgICAvLyBUaGUgZXJyb3IgY2xhc3MgcmV0dXJuZWQgaW1wbGllcyB0aGF0IHRoZSByZWRpcmVjdCBpcyBmcm9tIGFuIGltcGxpY2l0IGdyYW50IGZsb3dcbiAgICAgICAgLy8gYnV0IGl0IGNvdWxkIGFsc28gYmUgZnJvbSBhIHJlZGlyZWN0IGVycm9yIGZyb20gYSBQS0NFIGZsb3cuXG4gICAgICAgIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoXG4gICAgICAgICAgcGFyYW1zLmVycm9yX2Rlc2NyaXB0aW9uIHx8ICdFcnJvciBpbiBVUkwgd2l0aCB1bnNwZWNpZmllZCBlcnJvcl9kZXNjcmlwdGlvbicsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZXJyb3I6IHBhcmFtcy5lcnJvciB8fCAndW5zcGVjaWZpZWRfZXJyb3InLFxuICAgICAgICAgICAgY29kZTogcGFyYW1zLmVycm9yX2NvZGUgfHwgJ3Vuc3BlY2lmaWVkX2NvZGUnLFxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVja3MgZm9yIG1pc21hdGNoZXMgYmV0d2VlbiB0aGUgZmxvd1R5cGUgaW5pdGlhbGlzZWQgaW4gdGhlIGNsaWVudCBhbmQgdGhlIFVSTCBwYXJhbWV0ZXJzXG4gICAgICBzd2l0Y2ggKGNhbGxiYWNrVXJsVHlwZSkge1xuICAgICAgICBjYXNlICdpbXBsaWNpdCc6XG4gICAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcignTm90IGEgdmFsaWQgUEtDRSBmbG93IHVybC4nKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdwa2NlJzpcbiAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ2ltcGxpY2l0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm90IGEgdmFsaWQgaW1wbGljaXQgZ3JhbnQgZmxvdyB1cmwuJylcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gdGhlcmUncyBubyBtaXNtYXRjaCBzbyB3ZSBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgcmVkaXJlY3QgZm9yIFBLQ0UsIHdlIGF0dGVtcHQgdG8gcmV0cmlldmUgdGhlIGNvZGUgZnJvbSB0aGUgVVJMIGZvciB0aGUgY29kZSBleGNoYW5nZVxuICAgICAgaWYgKGNhbGxiYWNrVXJsVHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdiZWdpbicsICdpcyBQS0NFIGZsb3cnLCB0cnVlKVxuICAgICAgICBpZiAoIXBhcmFtcy5jb2RlKSB0aHJvdyBuZXcgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yKCdObyBjb2RlIGRldGVjdGVkLicpXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24ocGFyYW1zLmNvZGUpXG4gICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZSgnY29kZScpXG5cbiAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHdpbmRvdy5oaXN0b3J5LnN0YXRlLCAnJywgdXJsLnRvU3RyaW5nKCkpXG5cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBkYXRhLnNlc3Npb24sIHJlZGlyZWN0VHlwZTogbnVsbCB9LCBlcnJvcjogbnVsbCB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcHJvdmlkZXJfdG9rZW4sXG4gICAgICAgIHByb3ZpZGVyX3JlZnJlc2hfdG9rZW4sXG4gICAgICAgIGFjY2Vzc190b2tlbixcbiAgICAgICAgcmVmcmVzaF90b2tlbixcbiAgICAgICAgZXhwaXJlc19pbixcbiAgICAgICAgZXhwaXJlc19hdCxcbiAgICAgICAgdG9rZW5fdHlwZSxcbiAgICAgIH0gPSBwYXJhbXNcblxuICAgICAgaWYgKCFhY2Nlc3NfdG9rZW4gfHwgIWV4cGlyZXNfaW4gfHwgIXJlZnJlc2hfdG9rZW4gfHwgIXRva2VuX3R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm8gc2Vzc2lvbiBkZWZpbmVkIGluIFVSTCcpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRpbWVOb3cgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKVxuICAgICAgY29uc3QgZXhwaXJlc0luID0gcGFyc2VJbnQoZXhwaXJlc19pbilcbiAgICAgIGxldCBleHBpcmVzQXQgPSB0aW1lTm93ICsgZXhwaXJlc0luXG5cbiAgICAgIGlmIChleHBpcmVzX2F0KSB7XG4gICAgICAgIGV4cGlyZXNBdCA9IHBhcnNlSW50KGV4cGlyZXNfYXQpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjdHVhbGx5RXhwaXJlc0luID0gZXhwaXJlc0F0IC0gdGltZU5vd1xuICAgICAgaWYgKGFjdHVhbGx5RXhwaXJlc0luICogMTAwMCA8PSBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTikge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYEBzdXBhYmFzZS9nb3RydWUtanM6IFNlc3Npb24gYXMgcmV0cmlldmVkIGZyb20gVVJMIGV4cGlyZXMgaW4gJHthY3R1YWxseUV4cGlyZXNJbn1zLCBzaG91bGQgaGF2ZSBiZWVuIGNsb3NlciB0byAke2V4cGlyZXNJbn1zYFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzc3VlZEF0ID0gZXhwaXJlc0F0IC0gZXhwaXJlc0luXG4gICAgICBpZiAodGltZU5vdyAtIGlzc3VlZEF0ID49IDEyMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ0BzdXBhYmFzZS9nb3RydWUtanM6IFNlc3Npb24gYXMgcmV0cmlldmVkIGZyb20gVVJMIHdhcyBpc3N1ZWQgb3ZlciAxMjBzIGFnbywgVVJMIGNvdWxkIGJlIHN0YWxlJyxcbiAgICAgICAgICBpc3N1ZWRBdCxcbiAgICAgICAgICBleHBpcmVzQXQsXG4gICAgICAgICAgdGltZU5vd1xuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKHRpbWVOb3cgLSBpc3N1ZWRBdCA8IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdAc3VwYWJhc2UvZ290cnVlLWpzOiBTZXNzaW9uIGFzIHJldHJpZXZlZCBmcm9tIFVSTCB3YXMgaXNzdWVkIGluIHRoZSBmdXR1cmU/IENoZWNrIHRoZSBkZXZpY2UgY2xvY2sgZm9yIHNrZXcnLFxuICAgICAgICAgIGlzc3VlZEF0LFxuICAgICAgICAgIGV4cGlyZXNBdCxcbiAgICAgICAgICB0aW1lTm93XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0VXNlcihhY2Nlc3NfdG9rZW4pXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIGNvbnN0IHNlc3Npb246IFNlc3Npb24gPSB7XG4gICAgICAgIHByb3ZpZGVyX3Rva2VuLFxuICAgICAgICBwcm92aWRlcl9yZWZyZXNoX3Rva2VuLFxuICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgIGV4cGlyZXNfaW46IGV4cGlyZXNJbixcbiAgICAgICAgZXhwaXJlc19hdDogZXhwaXJlc0F0LFxuICAgICAgICByZWZyZXNoX3Rva2VuLFxuICAgICAgICB0b2tlbl90eXBlLFxuICAgICAgICB1c2VyOiBkYXRhLnVzZXIsXG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0b2tlbnMgZnJvbSBVUkxcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJydcbiAgICAgIHRoaXMuX2RlYnVnKCcjX2dldFNlc3Npb25Gcm9tVVJMKCknLCAnY2xlYXJpbmcgd2luZG93LmxvY2F0aW9uLmhhc2gnKVxuXG4gICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb24sIHJlZGlyZWN0VHlwZTogcGFyYW1zLnR5cGUgfSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgcmVkaXJlY3RUeXBlOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IFVSTCBjb250YWlucyBwYXJhbWV0ZXJzIGdpdmVuIGJ5IGFuIGltcGxpY2l0IG9hdXRoIGdyYW50IGZsb3cgKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2NzQ5Lmh0bWwjc2VjdGlvbi00LjIpXG4gICAqL1xuICBwcml2YXRlIF9pc0ltcGxpY2l0R3JhbnRDYWxsYmFjayhwYXJhbXM6IHsgW3BhcmFtZXRlcjogc3RyaW5nXTogc3RyaW5nIH0pOiBib29sZWFuIHtcbiAgICByZXR1cm4gQm9vbGVhbihwYXJhbXMuYWNjZXNzX3Rva2VuIHx8IHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbilcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgVVJMIGFuZCBiYWNraW5nIHN0b3JhZ2UgY29udGFpbiBwYXJhbWV0ZXJzIGdpdmVuIGJ5IGEgUEtDRSBmbG93XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9pc1BLQ0VDYWxsYmFjayhwYXJhbXM6IHsgW3BhcmFtZXRlcjogc3RyaW5nXTogc3RyaW5nIH0pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBjdXJyZW50U3RvcmFnZUNvbnRlbnQgPSBhd2FpdCBnZXRJdGVtQXN5bmMoXG4gICAgICB0aGlzLnN0b3JhZ2UsXG4gICAgICBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgXG4gICAgKVxuXG4gICAgcmV0dXJuICEhKHBhcmFtcy5jb2RlICYmIGN1cnJlbnRTdG9yYWdlQ29udGVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNpZGUgYSBicm93c2VyIGNvbnRleHQsIGBzaWduT3V0KClgIHdpbGwgcmVtb3ZlIHRoZSBsb2dnZWQgaW4gdXNlciBmcm9tIHRoZSBicm93c2VyIHNlc3Npb24gYW5kIGxvZyB0aGVtIG91dCAtIHJlbW92aW5nIGFsbCBpdGVtcyBmcm9tIGxvY2Fsc3RvcmFnZSBhbmQgdGhlbiB0cmlnZ2VyIGEgYFwiU0lHTkVEX09VVFwiYCBldmVudC5cbiAgICpcbiAgICogRm9yIHNlcnZlci1zaWRlIG1hbmFnZW1lbnQsIHlvdSBjYW4gcmV2b2tlIGFsbCByZWZyZXNoIHRva2VucyBmb3IgYSB1c2VyIGJ5IHBhc3NpbmcgYSB1c2VyJ3MgSldUIHRocm91Z2ggdG8gYGF1dGguYXBpLnNpZ25PdXQoSldUOiBzdHJpbmcpYC5cbiAgICogVGhlcmUgaXMgbm8gd2F5IHRvIHJldm9rZSBhIHVzZXIncyBhY2Nlc3MgdG9rZW4gand0IHVudGlsIGl0IGV4cGlyZXMuIEl0IGlzIHJlY29tbWVuZGVkIHRvIHNldCBhIHNob3J0ZXIgZXhwaXJ5IG9uIHRoZSBqd3QgZm9yIHRoaXMgcmVhc29uLlxuICAgKlxuICAgKiBJZiB1c2luZyBgb3RoZXJzYCBzY29wZSwgbm8gYFNJR05FRF9PVVRgIGV2ZW50IGlzIGZpcmVkIVxuICAgKi9cbiAgYXN5bmMgc2lnbk91dChvcHRpb25zOiBTaWduT3V0ID0geyBzY29wZTogJ2dsb2JhbCcgfSk6IFByb21pc2U8eyBlcnJvcjogQXV0aEVycm9yIHwgbnVsbCB9PiB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2lnbk91dChvcHRpb25zKVxuICAgIH0pXG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX3NpZ25PdXQoXG4gICAgeyBzY29wZSB9OiBTaWduT3V0ID0geyBzY29wZTogJ2dsb2JhbCcgfVxuICApOiBQcm9taXNlPHsgZXJyb3I6IEF1dGhFcnJvciB8IG51bGwgfT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0XG4gICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiBzZXNzaW9uRXJyb3IgfVxuICAgICAgfVxuICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSBkYXRhLnNlc3Npb24/LmFjY2Vzc190b2tlblxuICAgICAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuYWRtaW4uc2lnbk91dChhY2Nlc3NUb2tlbiwgc2NvcGUpXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIC8vIGlnbm9yZSA0MDRzIHNpbmNlIHVzZXIgbWlnaHQgbm90IGV4aXN0IGFueW1vcmVcbiAgICAgICAgICAvLyBpZ25vcmUgNDAxcyBzaW5jZSBhbiBpbnZhbGlkIG9yIGV4cGlyZWQgSldUIHNob3VsZCBzaWduIG91dCB0aGUgY3VycmVudCBzZXNzaW9uXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgaXNBdXRoQXBpRXJyb3IoZXJyb3IpICYmXG4gICAgICAgICAgICAgIChlcnJvci5zdGF0dXMgPT09IDQwNCB8fCBlcnJvci5zdGF0dXMgPT09IDQwMSB8fCBlcnJvci5zdGF0dXMgPT09IDQwMylcbiAgICAgICAgICAgIClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzY29wZSAhPT0gJ290aGVycycpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG4gICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApXG4gICAgICB9XG4gICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNlaXZlIGEgbm90aWZpY2F0aW9uIGV2ZXJ5IHRpbWUgYW4gYXV0aCBldmVudCBoYXBwZW5zLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgQSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gYW4gYXV0aCBldmVudCBoYXBwZW5zLlxuICAgKi9cbiAgb25BdXRoU3RhdGVDaGFuZ2UoXG4gICAgY2FsbGJhY2s6IChldmVudDogQXV0aENoYW5nZUV2ZW50LCBzZXNzaW9uOiBTZXNzaW9uIHwgbnVsbCkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD5cbiAgKToge1xuICAgIGRhdGE6IHsgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gfVxuICB9IHtcbiAgICBjb25zdCBpZDogc3RyaW5nID0gdXVpZCgpXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gPSB7XG4gICAgICBpZCxcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyN1bnN1YnNjcmliZSgpJywgJ3N0YXRlIGNoYW5nZSBjYWxsYmFjayB3aXRoIGlkIHJlbW92ZWQnLCBpZClcblxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZGVsZXRlKGlkKVxuICAgICAgfSxcbiAgICB9XG5cbiAgICB0aGlzLl9kZWJ1ZygnI29uQXV0aFN0YXRlQ2hhbmdlKCknLCAncmVnaXN0ZXJlZCBjYWxsYmFjayB3aXRoIGlkJywgaWQpXG5cbiAgICB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuc2V0KGlkLCBzdWJzY3JpcHRpb24pXG4gICAgOyhhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICAgIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VtaXRJbml0aWFsU2Vzc2lvbihpZClcbiAgICAgIH0pXG4gICAgfSkoKVxuXG4gICAgcmV0dXJuIHsgZGF0YTogeyBzdWJzY3JpcHRpb24gfSB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9lbWl0SW5pdGlhbFNlc3Npb24oaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkYXRhOiB7IHNlc3Npb24gfSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgICAgYXdhaXQgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLmdldChpZCk/LmNhbGxiYWNrKCdJTklUSUFMX1NFU1NJT04nLCBzZXNzaW9uKVxuICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdzZXNzaW9uJywgc2Vzc2lvbilcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBhd2FpdCB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZ2V0KGlkKT8uY2FsbGJhY2soJ0lOSVRJQUxfU0VTU0lPTicsIG51bGwpXG4gICAgICAgIHRoaXMuX2RlYnVnKCdJTklUSUFMX1NFU1NJT04nLCAnY2FsbGJhY2sgaWQnLCBpZCwgJ2Vycm9yJywgZXJyKVxuICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcGFzc3dvcmQgcmVzZXQgcmVxdWVzdCB0byBhbiBlbWFpbCBhZGRyZXNzLiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0aGUgUEtDRSBmbG93LlxuICAgKlxuICAgKiBAcGFyYW0gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gVGhlIFVSTCB0byBzZW5kIHRoZSB1c2VyIHRvIGFmdGVyIHRoZXkgY2xpY2sgdGhlIHBhc3N3b3JkIHJlc2V0IGxpbmsuXG4gICAqIEBwYXJhbSBvcHRpb25zLmNhcHRjaGFUb2tlbiBWZXJpZmljYXRpb24gdG9rZW4gcmVjZWl2ZWQgd2hlbiB0aGUgdXNlciBjb21wbGV0ZXMgdGhlIGNhcHRjaGEgb24gdGhlIHNpdGUuXG4gICAqL1xuICBhc3luYyByZXNldFBhc3N3b3JkRm9yRW1haWwoXG4gICAgZW1haWw6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7XG4gICAgICByZWRpcmVjdFRvPzogc3RyaW5nXG4gICAgICBjYXB0Y2hhVG9rZW4/OiBzdHJpbmdcbiAgICB9ID0ge31cbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YToge31cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHsgZGF0YTogbnVsbDsgZXJyb3I6IEF1dGhFcnJvciB9XG4gID4ge1xuICAgIGxldCBjb2RlQ2hhbGxlbmdlOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuXG4gICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgO1tjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QoXG4gICAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgICAgdGhpcy5zdG9yYWdlS2V5LFxuICAgICAgICB0cnVlIC8vIGlzUGFzc3dvcmRSZWNvdmVyeVxuICAgICAgKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3JlY292ZXJgLCB7XG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgdGhlIGlkZW50aXRpZXMgbGlua2VkIHRvIGEgdXNlci5cbiAgICovXG4gIGFzeW5jIGdldFVzZXJJZGVudGl0aWVzKCk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZGVudGl0aWVzOiBVc2VySWRlbnRpdHlbXVxuICAgICAgICB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7IGRhdGE6IG51bGw7IGVycm9yOiBBdXRoRXJyb3IgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKClcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIHJldHVybiB7IGRhdGE6IHsgaWRlbnRpdGllczogZGF0YS51c2VyLmlkZW50aXRpZXMgPz8gW10gfSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBMaW5rcyBhbiBvYXV0aCBpZGVudGl0eSB0byBhbiBleGlzdGluZyB1c2VyLlxuICAgKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0aGUgUEtDRSBmbG93LlxuICAgKi9cbiAgYXN5bmMgbGlua0lkZW50aXR5KGNyZWRlbnRpYWxzOiBTaWduSW5XaXRoT0F1dGhDcmVkZW50aWFscyk6IFByb21pc2U8T0F1dGhSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgICAgY29uc3QgdXJsOiBzdHJpbmcgPSBhd2FpdCB0aGlzLl9nZXRVcmxGb3JQcm92aWRlcihcbiAgICAgICAgICBgJHt0aGlzLnVybH0vdXNlci9pZGVudGl0aWVzL2F1dGhvcml6ZWAsXG4gICAgICAgICAgY3JlZGVudGlhbHMucHJvdmlkZXIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVkaXJlY3RUbzogY3JlZGVudGlhbHMub3B0aW9ucz8ucmVkaXJlY3RUbyxcbiAgICAgICAgICAgIHNjb3BlczogY3JlZGVudGlhbHMub3B0aW9ucz8uc2NvcGVzLFxuICAgICAgICAgICAgcXVlcnlQYXJhbXM6IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgc2tpcEJyb3dzZXJSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCB1cmwsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgand0OiBkYXRhLnNlc3Npb24/LmFjY2Vzc190b2tlbiA/PyB1bmRlZmluZWQsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgaWYgKGlzQnJvd3NlcigpICYmICFjcmVkZW50aWFscy5vcHRpb25zPy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oZGF0YT8udXJsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0YTogeyBwcm92aWRlcjogY3JlZGVudGlhbHMucHJvdmlkZXIsIHVybDogZGF0YT8udXJsIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHByb3ZpZGVyOiBjcmVkZW50aWFscy5wcm92aWRlciwgdXJsOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVubGlua3MgYW4gaWRlbnRpdHkgZnJvbSBhIHVzZXIgYnkgZGVsZXRpbmcgaXQuIFRoZSB1c2VyIHdpbGwgbm8gbG9uZ2VyIGJlIGFibGUgdG8gc2lnbiBpbiB3aXRoIHRoYXQgaWRlbnRpdHkgb25jZSBpdCdzIHVubGlua2VkLlxuICAgKi9cbiAgYXN5bmMgdW5saW5rSWRlbnRpdHkoaWRlbnRpdHk6IFVzZXJJZGVudGl0eSk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHt9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7IGRhdGE6IG51bGw7IGVycm9yOiBBdXRoRXJyb3IgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QoXG4gICAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgICAnREVMRVRFJyxcbiAgICAgICAgICBgJHt0aGlzLnVybH0vdXNlci9pZGVudGl0aWVzLyR7aWRlbnRpdHkuaWRlbnRpdHlfaWR9YCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBqd3Q6IGRhdGEuc2Vzc2lvbj8uYWNjZXNzX3Rva2VuID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgbmV3IEpXVC5cbiAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBBIHZhbGlkIHJlZnJlc2ggdG9rZW4gdGhhdCB3YXMgcmV0dXJuZWQgb24gbG9naW4uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9yZWZyZXNoQWNjZXNzVG9rZW4ocmVmcmVzaFRva2VuOiBzdHJpbmcpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIGNvbnN0IGRlYnVnTmFtZSA9IGAjX3JlZnJlc2hBY2Nlc3NUb2tlbigke3JlZnJlc2hUb2tlbi5zdWJzdHJpbmcoMCwgNSl9Li4uKWBcbiAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhcnRlZEF0ID0gRGF0ZS5ub3coKVxuXG4gICAgICAvLyB3aWxsIGF0dGVtcHQgdG8gcmVmcmVzaCB0aGUgdG9rZW4gd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICByZXR1cm4gYXdhaXQgcmV0cnlhYmxlKFxuICAgICAgICBhc3luYyAoYXR0ZW1wdCkgPT4ge1xuICAgICAgICAgIGlmIChhdHRlbXB0ID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoMjAwICogTWF0aC5wb3coMiwgYXR0ZW1wdCAtIDEpKSAvLyAyMDAsIDQwMCwgODAwLCAuLi5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdyZWZyZXNoaW5nIGF0dGVtcHQnLCBhdHRlbXB0KVxuXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cmVmcmVzaF90b2tlbmAsIHtcbiAgICAgICAgICAgIGJvZHk6IHsgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuIH0sXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAoYXR0ZW1wdCwgZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25zdCBuZXh0QmFja09mZkludGVydmFsID0gMjAwICogTWF0aC5wb3coMiwgYXR0ZW1wdClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZXJyb3IgJiZcbiAgICAgICAgICAgIGlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpICYmXG4gICAgICAgICAgICAvLyByZXRyeWFibGUgb25seSBpZiB0aGUgcmVxdWVzdCBjYW4gYmUgc2VudCBiZWZvcmUgdGhlIGJhY2tvZmYgb3ZlcmZsb3dzIHRoZSB0aWNrIGR1cmF0aW9uXG4gICAgICAgICAgICBEYXRlLm5vdygpICsgbmV4dEJhY2tPZmZJbnRlcnZhbCAtIHN0YXJ0ZWRBdCA8IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2Vycm9yJywgZXJyb3IpXG5cbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsLCB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaXNWYWxpZFNlc3Npb24obWF5YmVTZXNzaW9uOiB1bmtub3duKTogbWF5YmVTZXNzaW9uIGlzIFNlc3Npb24ge1xuICAgIGNvbnN0IGlzVmFsaWRTZXNzaW9uID1cbiAgICAgIHR5cGVvZiBtYXliZVNlc3Npb24gPT09ICdvYmplY3QnICYmXG4gICAgICBtYXliZVNlc3Npb24gIT09IG51bGwgJiZcbiAgICAgICdhY2Nlc3NfdG9rZW4nIGluIG1heWJlU2Vzc2lvbiAmJlxuICAgICAgJ3JlZnJlc2hfdG9rZW4nIGluIG1heWJlU2Vzc2lvbiAmJlxuICAgICAgJ2V4cGlyZXNfYXQnIGluIG1heWJlU2Vzc2lvblxuXG4gICAgcmV0dXJuIGlzVmFsaWRTZXNzaW9uXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9oYW5kbGVQcm92aWRlclNpZ25JbihcbiAgICBwcm92aWRlcjogUHJvdmlkZXIsXG4gICAgb3B0aW9uczoge1xuICAgICAgcmVkaXJlY3RUbz86IHN0cmluZ1xuICAgICAgc2NvcGVzPzogc3RyaW5nXG4gICAgICBxdWVyeVBhcmFtcz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgICAgIHNraXBCcm93c2VyUmVkaXJlY3Q/OiBib29sZWFuXG4gICAgfVxuICApIHtcbiAgICBjb25zdCB1cmw6IHN0cmluZyA9IGF3YWl0IHRoaXMuX2dldFVybEZvclByb3ZpZGVyKGAke3RoaXMudXJsfS9hdXRob3JpemVgLCBwcm92aWRlciwge1xuICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgc2NvcGVzOiBvcHRpb25zLnNjb3BlcyxcbiAgICAgIHF1ZXJ5UGFyYW1zOiBvcHRpb25zLnF1ZXJ5UGFyYW1zLFxuICAgIH0pXG5cbiAgICB0aGlzLl9kZWJ1ZygnI19oYW5kbGVQcm92aWRlclNpZ25JbigpJywgJ3Byb3ZpZGVyJywgcHJvdmlkZXIsICdvcHRpb25zJywgb3B0aW9ucywgJ3VybCcsIHVybClcblxuICAgIC8vIHRyeSB0byBvcGVuIG9uIHRoZSBicm93c2VyXG4gICAgaWYgKGlzQnJvd3NlcigpICYmICFvcHRpb25zLnNraXBCcm93c2VyUmVkaXJlY3QpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24odXJsKVxuICAgIH1cblxuICAgIHJldHVybiB7IGRhdGE6IHsgcHJvdmlkZXIsIHVybCB9LCBlcnJvcjogbnVsbCB9XG4gIH1cblxuICAvKipcbiAgICogUmVjb3ZlcnMgdGhlIHNlc3Npb24gZnJvbSBMb2NhbFN0b3JhZ2UgYW5kIHJlZnJlc2hlcyB0aGUgdG9rZW5cbiAgICogTm90ZTogdGhpcyBtZXRob2QgaXMgYXN5bmMgdG8gYWNjb21tb2RhdGUgZm9yIEFzeW5jU3RvcmFnZSBlLmcuIGluIFJlYWN0IG5hdGl2ZS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3JlY292ZXJBbmRSZWZyZXNoKCkge1xuICAgIGNvbnN0IGRlYnVnTmFtZSA9ICcjX3JlY292ZXJBbmRSZWZyZXNoKCknXG4gICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTZXNzaW9uID0gYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KVxuICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnc2Vzc2lvbiBmcm9tIHN0b3JhZ2UnLCBjdXJyZW50U2Vzc2lvbilcblxuICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkU2Vzc2lvbihjdXJyZW50U2Vzc2lvbikpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnc2Vzc2lvbiBpcyBub3QgdmFsaWQnKVxuICAgICAgICBpZiAoY3VycmVudFNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB0aW1lTm93ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMClcbiAgICAgIGNvbnN0IGV4cGlyZXNXaXRoTWFyZ2luID0gKGN1cnJlbnRTZXNzaW9uLmV4cGlyZXNfYXQgPz8gSW5maW5pdHkpIDwgdGltZU5vdyArIEVYUElSWV9NQVJHSU5cblxuICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgIGRlYnVnTmFtZSxcbiAgICAgICAgYHNlc3Npb24gaGFzJHtleHBpcmVzV2l0aE1hcmdpbiA/ICcnIDogJyBub3QnfSBleHBpcmVkIHdpdGggbWFyZ2luIG9mICR7RVhQSVJZX01BUkdJTn1zYFxuICAgICAgKVxuXG4gICAgICBpZiAoZXhwaXJlc1dpdGhNYXJnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbiAmJiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKVxuXG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKVxuXG4gICAgICAgICAgICBpZiAoIWlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RlYnVnKFxuICAgICAgICAgICAgICAgIGRlYnVnTmFtZSxcbiAgICAgICAgICAgICAgICAncmVmcmVzaCBmYWlsZWQgd2l0aCBhIG5vbi1yZXRyeWFibGUgZXJyb3IsIHJlbW92aW5nIHRoZSBzZXNzaW9uJyxcbiAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBwZXJzaXN0IGN1cnJlbnRTZXNzaW9uIGFnYWluLCBhcyB3ZSBqdXN0IGxvYWRlZCBpdCBmcm9tXG4gICAgICAgIC8vIGxvY2FsIHN0b3JhZ2U7IHBlcnNpc3RpbmcgaXQgYWdhaW4gbWF5IG92ZXJ3cml0ZSBhIHZhbHVlIHNhdmVkIGJ5XG4gICAgICAgIC8vIGFub3RoZXIgY2xpZW50IHdpdGggYWNjZXNzIHRvIHRoZSBzYW1lIGxvY2FsIHN0b3JhZ2VcbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGN1cnJlbnRTZXNzaW9uKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnIpXG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfY2FsbFJlZnJlc2hUb2tlbihyZWZyZXNoVG9rZW46IHN0cmluZyk6IFByb21pc2U8Q2FsbFJlZnJlc2hUb2tlblJlc3VsdD4ge1xuICAgIGlmICghcmVmcmVzaFRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKVxuICAgIH1cblxuICAgIC8vIHJlZnJlc2hpbmcgaXMgYWxyZWFkeSBpbiBwcm9ncmVzc1xuICAgIGlmICh0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkLnByb21pc2VcbiAgICB9XG5cbiAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19jYWxsUmVmcmVzaFRva2VuKCR7cmVmcmVzaFRva2VuLnN1YnN0cmluZygwLCA1KX0uLi4pYFxuXG4gICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nKVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkID0gbmV3IERlZmVycmVkPENhbGxSZWZyZXNoVG9rZW5SZXN1bHQ+KClcblxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fcmVmcmVzaEFjY2Vzc1Rva2VuKHJlZnJlc2hUb2tlbilcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIGlmICghZGF0YS5zZXNzaW9uKSB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKVxuXG4gICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pXG4gICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnVE9LRU5fUkVGUkVTSEVEJywgZGF0YS5zZXNzaW9uKVxuXG4gICAgICBjb25zdCByZXN1bHQgPSB7IHNlc3Npb246IGRhdGEuc2Vzc2lvbiwgZXJyb3I6IG51bGwgfVxuXG4gICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZC5yZXNvbHZlKHJlc3VsdClcblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycm9yKVxuXG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgc2Vzc2lvbjogbnVsbCwgZXJyb3IgfVxuXG4gICAgICAgIGlmICghaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkPy5yZXNvbHZlKHJlc3VsdClcblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkPy5yZWplY3QoZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCA9IG51bGxcbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfbm90aWZ5QWxsU3Vic2NyaWJlcnMoXG4gICAgZXZlbnQ6IEF1dGhDaGFuZ2VFdmVudCxcbiAgICBzZXNzaW9uOiBTZXNzaW9uIHwgbnVsbCxcbiAgICBicm9hZGNhc3QgPSB0cnVlXG4gICkge1xuICAgIGNvbnN0IGRlYnVnTmFtZSA9IGAjX25vdGlmeUFsbFN1YnNjcmliZXJzKCR7ZXZlbnR9KWBcbiAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicsIHNlc3Npb24sIGBicm9hZGNhc3QgPSAke2Jyb2FkY2FzdH1gKVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmJyb2FkY2FzdENoYW5uZWwgJiYgYnJvYWRjYXN0KSB7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7IGV2ZW50LCBzZXNzaW9uIH0pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVycm9yczogYW55W10gPSBbXVxuICAgICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheS5mcm9tKHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy52YWx1ZXMoKSkubWFwKGFzeW5jICh4KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgeC5jYWxsYmFjayhldmVudCwgc2Vzc2lvbilcbiAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpXG5cbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzW2ldKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyb3JzWzBdXG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHNldCBjdXJyZW50U2Vzc2lvbiBhbmQgY3VycmVudFVzZXJcbiAgICogcHJvY2VzcyB0byBfc3RhcnRBdXRvUmVmcmVzaFRva2VuIGlmIHBvc3NpYmxlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9zYXZlU2Vzc2lvbihzZXNzaW9uOiBTZXNzaW9uKSB7XG4gICAgdGhpcy5fZGVidWcoJyNfc2F2ZVNlc3Npb24oKScsIHNlc3Npb24pXG4gICAgLy8gX3NhdmVTZXNzaW9uIGlzIGFsd2F5cyBjYWxsZWQgd2hlbmV2ZXIgYSBuZXcgc2Vzc2lvbiBoYXMgYmVlbiBhY3F1aXJlZFxuICAgIC8vIHNvIHdlIGNhbiBzYWZlbHkgc3VwcHJlc3MgdGhlIHdhcm5pbmcgcmV0dXJuZWQgYnkgZnV0dXJlIGdldFNlc3Npb24gY2FsbHNcbiAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSB0cnVlXG4gICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCBzZXNzaW9uKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfcmVtb3ZlU2Vzc2lvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygnI19yZW1vdmVTZXNzaW9uKCknKVxuXG4gICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KVxuICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfT1VUJywgbnVsbClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFueSByZWdpc3RlcmVkIHZpc2liaWxpdHljaGFuZ2UgY2FsbGJhY2suXG4gICAqXG4gICAqIHtAc2VlICNzdGFydEF1dG9SZWZyZXNofVxuICAgKiB7QHNlZSAjc3RvcEF1dG9SZWZyZXNofVxuICAgKi9cbiAgcHJpdmF0ZSBfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9kZWJ1ZygnI19yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKCknKVxuXG4gICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2tcbiAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2sgPSBudWxsXG5cbiAgICB0cnkge1xuICAgICAgaWYgKGNhbGxiYWNrICYmIGlzQnJvd3NlcigpICYmIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3JlbW92aW5nIHZpc2liaWxpdHljaGFuZ2UgY2FsbGJhY2sgZmFpbGVkJywgZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgcHJpdmF0ZSBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgI3N0YXJ0QXV0b1JlZnJlc2h9LiBVc2UgdGhpc1xuICAgKiB3aXRoaW4gdGhlIGxpYnJhcnkuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9zdGFydEF1dG9SZWZyZXNoKCkge1xuICAgIGF3YWl0IHRoaXMuX3N0b3BBdXRvUmVmcmVzaCgpXG5cbiAgICB0aGlzLl9kZWJ1ZygnI19zdGFydEF1dG9SZWZyZXNoKCknKVxuXG4gICAgY29uc3QgdGlja2VyID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5fYXV0b1JlZnJlc2hUb2tlblRpY2soKSwgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT04pXG4gICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tlciA9IHRpY2tlclxuXG4gICAgaWYgKHRpY2tlciAmJiB0eXBlb2YgdGlja2VyID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGlja2VyLnVucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyB0aWNrZXIgaXMgYSBOb2RlSlMgVGltZW91dCBvYmplY3QgdGhhdCBoYXMgYW4gYHVucmVmYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGltZXJzLmh0bWwjdGltZW91dHVucmVmXG4gICAgICAvLyBXaGVuIGF1dG8gcmVmcmVzaCBpcyB1c2VkIGluIE5vZGVKUyAobGlrZSBmb3IgdGVzdGluZykgdGhlXG4gICAgICAvLyBgc2V0SW50ZXJ2YWxgIGlzIHByZXZlbnRpbmcgdGhlIHByb2Nlc3MgZnJvbSBiZWluZyBtYXJrZWQgYXNcbiAgICAgIC8vIGZpbmlzaGVkIGFuZCB0ZXN0cyBydW4gZW5kbGVzc2x5LiBUaGlzIGNhbiBiZSBwcmV2ZW50ZWQgYnkgY2FsbGluZ1xuICAgICAgLy8gYHVucmVmKClgIG9uIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gICAgICB0aWNrZXIudW5yZWYoKVxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBoYXMgbm8gY29udGV4dCBvZiBEZW5vXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIERlbm8udW5yZWZUaW1lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gc2ltaWxhciBsaWtlIGZvciBOb2RlSlMsIGJ1dCB3aXRoIHRoZSBEZW5vIEFQSVxuICAgICAgLy8gaHR0cHM6Ly9kZW5vLmxhbmQvYXBpQGxhdGVzdD91bnN0YWJsZSZzPURlbm8udW5yZWZUaW1lclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBoYXMgbm8gY29udGV4dCBvZiBEZW5vXG4gICAgICBEZW5vLnVucmVmVGltZXIodGlja2VyKVxuICAgIH1cblxuICAgIC8vIHJ1biB0aGUgdGljayBpbW1lZGlhdGVseSwgYnV0IGluIHRoZSBuZXh0IHBhc3Mgb2YgdGhlIGV2ZW50IGxvb3Agc28gdGhhdFxuICAgIC8vICNfaW5pdGlhbGl6ZSBjYW4gYmUgYWxsb3dlZCB0byBjb21wbGV0ZSB3aXRob3V0IHJlY3Vyc2l2ZWx5IHdhaXRpbmcgb25cbiAgICAvLyBpdHNlbGZcbiAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcbiAgICAgIGF3YWl0IHRoaXMuX2F1dG9SZWZyZXNoVG9rZW5UaWNrKClcbiAgICB9LCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIHByaXZhdGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rICNzdG9wQXV0b1JlZnJlc2h9LiBVc2UgdGhpc1xuICAgKiB3aXRoaW4gdGhlIGxpYnJhcnkuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9zdG9wQXV0b1JlZnJlc2goKSB7XG4gICAgdGhpcy5fZGVidWcoJyNfc3RvcEF1dG9SZWZyZXNoKCknKVxuXG4gICAgY29uc3QgdGlja2VyID0gdGhpcy5hdXRvUmVmcmVzaFRpY2tlclxuICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrZXIgPSBudWxsXG5cbiAgICBpZiAodGlja2VyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRpY2tlcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIGFuIGF1dG8tcmVmcmVzaCBwcm9jZXNzIGluIHRoZSBiYWNrZ3JvdW5kLiBUaGUgc2Vzc2lvbiBpcyBjaGVja2VkXG4gICAqIGV2ZXJ5IGZldyBzZWNvbmRzLiBDbG9zZSB0byB0aGUgdGltZSBvZiBleHBpcmF0aW9uIGEgcHJvY2VzcyBpcyBzdGFydGVkIHRvXG4gICAqIHJlZnJlc2ggdGhlIHNlc3Npb24uIElmIHJlZnJlc2hpbmcgZmFpbHMgaXQgd2lsbCBiZSByZXRyaWVkIGZvciBhcyBsb25nIGFzXG4gICAqIG5lY2Vzc2FyeS5cbiAgICpcbiAgICogSWYgeW91IHNldCB0aGUge0BsaW5rIEdvVHJ1ZUNsaWVudE9wdGlvbnMjYXV0b1JlZnJlc2hUb2tlbn0geW91IGRvbid0IG5lZWRcbiAgICogdG8gY2FsbCB0aGlzIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCBmb3IgeW91LlxuICAgKlxuICAgKiBPbiBicm93c2VycyB0aGUgcmVmcmVzaCBwcm9jZXNzIHdvcmtzIG9ubHkgd2hlbiB0aGUgdGFiL3dpbmRvdyBpcyBpbiB0aGVcbiAgICogZm9yZWdyb3VuZCB0byBjb25zZXJ2ZSByZXNvdXJjZXMgYXMgd2VsbCBhcyBwcmV2ZW50IHJhY2UgY29uZGl0aW9ucyBhbmRcbiAgICogZmxvb2RpbmcgYXV0aCB3aXRoIHJlcXVlc3RzLiBJZiB5b3UgY2FsbCB0aGlzIG1ldGhvZCBhbnkgbWFuYWdlZFxuICAgKiB2aXNpYmlsaXR5IGNoYW5nZSBjYWxsYmFjayB3aWxsIGJlIHJlbW92ZWQgYW5kIHlvdSBtdXN0IG1hbmFnZSB2aXNpYmlsaXR5XG4gICAqIGNoYW5nZXMgb24geW91ciBvd24uXG4gICAqXG4gICAqIE9uIG5vbi1icm93c2VyIHBsYXRmb3JtcyB0aGUgcmVmcmVzaCBwcm9jZXNzIHdvcmtzICpjb250aW51b3VzbHkqIGluIHRoZVxuICAgKiBiYWNrZ3JvdW5kLCB3aGljaCBtYXkgbm90IGJlIGRlc2lyYWJsZS4gWW91IHNob3VsZCBob29rIGludG8geW91clxuICAgKiBwbGF0Zm9ybSdzIGZvcmVncm91bmQgaW5kaWNhdGlvbiBtZWNoYW5pc20gYW5kIGNhbGwgdGhlc2UgbWV0aG9kc1xuICAgKiBhcHByb3ByaWF0ZWx5IHRvIGNvbnNlcnZlIHJlc291cmNlcy5cbiAgICpcbiAgICoge0BzZWUgI3N0b3BBdXRvUmVmcmVzaH1cbiAgICovXG4gIGFzeW5jIHN0YXJ0QXV0b1JlZnJlc2goKSB7XG4gICAgdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpXG4gICAgYXdhaXQgdGhpcy5fc3RhcnRBdXRvUmVmcmVzaCgpXG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgYW4gYWN0aXZlIGF1dG8gcmVmcmVzaCBwcm9jZXNzIHJ1bm5pbmcgaW4gdGhlIGJhY2tncm91bmQgKGlmIGFueSkuXG4gICAqXG4gICAqIElmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIGFueSBtYW5hZ2VkIHZpc2liaWxpdHkgY2hhbmdlIGNhbGxiYWNrIHdpbGwgYmVcbiAgICogcmVtb3ZlZCBhbmQgeW91IG11c3QgbWFuYWdlIHZpc2liaWxpdHkgY2hhbmdlcyBvbiB5b3VyIG93bi5cbiAgICpcbiAgICogU2VlIHtAbGluayAjc3RhcnRBdXRvUmVmcmVzaH0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGFzeW5jIHN0b3BBdXRvUmVmcmVzaCgpIHtcbiAgICB0aGlzLl9yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKClcbiAgICBhd2FpdCB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgdGhlIGF1dG8gcmVmcmVzaCB0b2tlbiB0aWNrLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfYXV0b1JlZnJlc2hUb2tlblRpY2soKSB7XG4gICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdiZWdpbicpXG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7IHNlc3Npb24gfSxcbiAgICAgICAgICAgICAgfSA9IHJlc3VsdFxuXG4gICAgICAgICAgICAgIGlmICghc2Vzc2lvbiB8fCAhc2Vzc2lvbi5yZWZyZXNoX3Rva2VuIHx8ICFzZXNzaW9uLmV4cGlyZXNfYXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgJ25vIHNlc3Npb24nKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gc2Vzc2lvbiB3aWxsIGV4cGlyZSBpbiB0aGlzIG1hbnkgdGlja3MgKG9yIGhhcyBhbHJlYWR5IGV4cGlyZWQgaWYgPD0gMClcbiAgICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luVGlja3MgPSBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICAgIChzZXNzaW9uLmV4cGlyZXNfYXQgKiAxMDAwIC0gbm93KSAvIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgICAgICAgICAnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJyxcbiAgICAgICAgICAgICAgICBgYWNjZXNzIHRva2VuIGV4cGlyZXMgaW4gJHtleHBpcmVzSW5UaWNrc30gdGlja3MsIGEgdGljayBsYXN0cyAke0FVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OfW1zLCByZWZyZXNoIHRocmVzaG9sZCBpcyAke0FVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRH0gdGlja3NgXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICBpZiAoZXhwaXJlc0luVGlja3MgPD0gQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihzZXNzaW9uLnJlZnJlc2hfdG9rZW4pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnQXV0byByZWZyZXNoIHRpY2sgZmFpbGVkIHdpdGggZXJyb3IuIFRoaXMgaXMgbGlrZWx5IGEgdHJhbnNpZW50IGVycm9yLicsXG4gICAgICAgICAgICAgIGVcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdlbmQnKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgaWYgKGUuaXNBY3F1aXJlVGltZW91dCB8fCBlIGluc3RhbmNlb2YgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ2F1dG8gcmVmcmVzaCB0b2tlbiB0aWNrIGxvY2sgbm90IGF2YWlsYWJsZScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3Mgb24gdGhlIGJyb3dzZXIgLyBwbGF0Zm9ybSwgd2hpY2ggaW4tdHVybiBydW5cbiAgICogYWxnb3JpdGhtcyB3aGVuIHRoZSBicm93c2VyIHdpbmRvdy90YWIgYXJlIGluIGZvcmVncm91bmQuIE9uIG5vbi1icm93c2VyXG4gICAqIHBsYXRmb3JtcyBpdCBhc3N1bWVzIGFsd2F5cyBmb3JlZ3JvdW5kLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICB0aGlzLl9kZWJ1ZygnI19oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCknKVxuXG4gICAgaWYgKCFpc0Jyb3dzZXIoKSB8fCAhd2luZG93Py5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuKSB7XG4gICAgICAgIC8vIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cyB0aGUgcmVmcmVzaCB0b2tlbiB0aWNrZXIgcnVucyBhbHdheXNcbiAgICAgICAgdGhpcy5zdGFydEF1dG9SZWZyZXNoKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IGFzeW5jICgpID0+IGF3YWl0IHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZWQoZmFsc2UpXG5cbiAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaylcblxuICAgICAgLy8gbm93IGltbWVkaWF0ZWx5IGNhbGwgdGhlIHZpc2JpbGl0eSBjaGFuZ2VkIGNhbGxiYWNrIHRvIHNldHVwIHdpdGggdGhlXG4gICAgICAvLyBjdXJyZW50IHZpc2JpbGl0eSBzdGF0ZVxuICAgICAgYXdhaXQgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlZCh0cnVlKSAvLyBpbml0aWFsIGNhbGxcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UnLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgcmVnaXN0ZXJlZCB3aXRoIGB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScpYC5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX29uVmlzaWJpbGl0eUNoYW5nZWQoY2FsbGVkRnJvbUluaXRpYWxpemU6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBtZXRob2ROYW1lID0gYCNfb25WaXNpYmlsaXR5Q2hhbmdlZCgke2NhbGxlZEZyb21Jbml0aWFsaXplfSlgXG4gICAgdGhpcy5fZGVidWcobWV0aG9kTmFtZSwgJ3Zpc2liaWxpdHlTdGF0ZScsIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSlcblxuICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJykge1xuICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbikge1xuICAgICAgICAvLyBpbiBicm93c2VyIGVudmlyb25tZW50cyB0aGUgcmVmcmVzaCB0b2tlbiB0aWNrZXIgcnVucyBvbmx5IG9uIGZvY3VzZWQgdGFic1xuICAgICAgICAvLyB3aGljaCBwcmV2ZW50cyByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgdGhpcy5fc3RhcnRBdXRvUmVmcmVzaCgpXG4gICAgICB9XG5cbiAgICAgIGlmICghY2FsbGVkRnJvbUluaXRpYWxpemUpIHtcbiAgICAgICAgLy8gY2FsbGVkIHdoZW4gdGhlIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQsIGkuZS4gdGhlIGJyb3dzZXJcbiAgICAgICAgLy8gdHJhbnNpdGlvbmVkIGZyb20gaGlkZGVuIC0+IHZpc2libGUgc28gd2UgbmVlZCB0byBzZWUgaWYgdGhlIHNlc3Npb25cbiAgICAgICAgLy8gc2hvdWxkIGJlIHJlY292ZXJlZCBpbW1lZGlhdGVseS4uLiBidXQgdG8gZG8gdGhhdCB3ZSBuZWVkIHRvIGFjcXVpcmVcbiAgICAgICAgLy8gdGhlIGxvY2sgZmlyc3QgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgICAgIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSAhPT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgJ2FjcXVpcmVkIHRoZSBsb2NrIHRvIHJlY292ZXIgdGhlIHNlc3Npb24sIGJ1dCB0aGUgYnJvd3NlciB2aXNpYmlsaXR5U3RhdGUgaXMgbm8gbG9uZ2VyIHZpc2libGUsIGFib3J0aW5nJ1xuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAvLyB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBsb2NrLCBhYm9ydFxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVjb3ZlciB0aGUgc2Vzc2lvblxuICAgICAgICAgIGF3YWl0IHRoaXMuX3JlY292ZXJBbmRSZWZyZXNoKClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSByZWxldmFudCBsb2dpbiBVUkwgZm9yIGEgdGhpcmQtcGFydHkgcHJvdmlkZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gQSBVUkwgb3IgbW9iaWxlIGFkZHJlc3MgdG8gc2VuZCB0aGUgdXNlciB0byBhZnRlciB0aGV5IGFyZSBjb25maXJtZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNjb3BlcyBBIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHNjb3BlcyBncmFudGVkIHRvIHRoZSBPQXV0aCBhcHBsaWNhdGlvbi5cbiAgICogQHBhcmFtIG9wdGlvbnMucXVlcnlQYXJhbXMgQW4gb2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyBjb250YWluaW5nIHF1ZXJ5IHBhcmFtZXRlcnMgZ3JhbnRlZCB0byB0aGUgT0F1dGggYXBwbGljYXRpb24uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9nZXRVcmxGb3JQcm92aWRlcihcbiAgICB1cmw6IHN0cmluZyxcbiAgICBwcm92aWRlcjogUHJvdmlkZXIsXG4gICAgb3B0aW9uczoge1xuICAgICAgcmVkaXJlY3RUbz86IHN0cmluZ1xuICAgICAgc2NvcGVzPzogc3RyaW5nXG4gICAgICBxdWVyeVBhcmFtcz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgICAgIHNraXBCcm93c2VyUmVkaXJlY3Q/OiBib29sZWFuXG4gICAgfVxuICApIHtcbiAgICBjb25zdCB1cmxQYXJhbXM6IHN0cmluZ1tdID0gW2Bwcm92aWRlcj0ke2VuY29kZVVSSUNvbXBvbmVudChwcm92aWRlcil9YF1cbiAgICBpZiAob3B0aW9ucz8ucmVkaXJlY3RUbykge1xuICAgICAgdXJsUGFyYW1zLnB1c2goYHJlZGlyZWN0X3RvPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMucmVkaXJlY3RUbyl9YClcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LnNjb3Blcykge1xuICAgICAgdXJsUGFyYW1zLnB1c2goYHNjb3Blcz0ke2VuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLnNjb3Blcyl9YClcbiAgICB9XG4gICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgY29uc3QgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChcbiAgICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgICB0aGlzLnN0b3JhZ2VLZXlcbiAgICAgIClcblxuICAgICAgY29uc3QgZmxvd1BhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBjb2RlX2NoYWxsZW5nZTogYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvZGVDaGFsbGVuZ2UpfWAsXG4gICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvZGVDaGFsbGVuZ2VNZXRob2QpfWAsXG4gICAgICB9KVxuICAgICAgdXJsUGFyYW1zLnB1c2goZmxvd1BhcmFtcy50b1N0cmluZygpKVxuICAgIH1cbiAgICBpZiAob3B0aW9ucz8ucXVlcnlQYXJhbXMpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRpb25zLnF1ZXJ5UGFyYW1zKVxuICAgICAgdXJsUGFyYW1zLnB1c2gocXVlcnkudG9TdHJpbmcoKSlcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LnNraXBCcm93c2VyUmVkaXJlY3QpIHtcbiAgICAgIHVybFBhcmFtcy5wdXNoKGBza2lwX2h0dHBfcmVkaXJlY3Q9JHtvcHRpb25zLnNraXBCcm93c2VyUmVkaXJlY3R9YClcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7dXJsfT8ke3VybFBhcmFtcy5qb2luKCcmJyl9YFxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfdW5lbnJvbGwocGFyYW1zOiBNRkFVbmVucm9sbFBhcmFtcyk6IFByb21pc2U8QXV0aE1GQVVuZW5yb2xsUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vZmFjdG9ycy8ke3BhcmFtcy5mYWN0b3JJZH1gLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGp3dDogc2Vzc2lvbkRhdGE/LnNlc3Npb24/LmFjY2Vzc190b2tlbixcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgR29UcnVlTUZBQXBpI2Vucm9sbH1cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2Vucm9sbChwYXJhbXM6IE1GQUVucm9sbFRPVFBQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFFbnJvbGxUT1RQUmVzcG9uc2U+XG4gIHByaXZhdGUgYXN5bmMgX2Vucm9sbChwYXJhbXM6IE1GQUVucm9sbFBob25lUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBRW5yb2xsUGhvbmVSZXNwb25zZT5cbiAgcHJpdmF0ZSBhc3luYyBfZW5yb2xsKHBhcmFtczogTUZBRW5yb2xsUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBRW5yb2xsUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICBmcmllbmRseV9uYW1lOiBwYXJhbXMuZnJpZW5kbHlOYW1lLFxuICAgICAgICAgIGZhY3Rvcl90eXBlOiBwYXJhbXMuZmFjdG9yVHlwZSxcbiAgICAgICAgICAuLi4ocGFyYW1zLmZhY3RvclR5cGUgPT09ICdwaG9uZScgPyB7IHBob25lOiBwYXJhbXMucGhvbmUgfSA6IHsgaXNzdWVyOiBwYXJhbXMuaXNzdWVyIH0pLFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vZmFjdG9yc2AsIHtcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBqd3Q6IHNlc3Npb25EYXRhPy5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5mYWN0b3JUeXBlID09PSAndG90cCcgJiYgZGF0YT8udG90cD8ucXJfY29kZSkge1xuICAgICAgICAgIGRhdGEudG90cC5xcl9jb2RlID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGYtOCwke2RhdGEudG90cC5xcl9jb2RlfWBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgR29UcnVlTUZBQXBpI3ZlcmlmeX1cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3ZlcmlmeShwYXJhbXM6IE1GQVZlcmlmeVBhcmFtcyk6IFByb21pc2U8QXV0aE1GQVZlcmlmeVJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0XG4gICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QoXG4gICAgICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICAgICAgJ1BPU1QnLFxuICAgICAgICAgICAgYCR7dGhpcy51cmx9L2ZhY3RvcnMvJHtwYXJhbXMuZmFjdG9ySWR9L3ZlcmlmeWAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJvZHk6IHsgY29kZTogcGFyYW1zLmNvZGUsIGNoYWxsZW5nZV9pZDogcGFyYW1zLmNoYWxsZW5nZUlkIH0sXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgand0OiBzZXNzaW9uRGF0YT8uc2Vzc2lvbj8uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbih7XG4gICAgICAgICAgICBleHBpcmVzX2F0OiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKSArIGRhdGEuZXhwaXJlc19pbixcbiAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgfSlcbiAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnTUZBX0NIQUxMRU5HRV9WRVJJRklFRCcsIGRhdGEpXG5cbiAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvciB9XG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjY2hhbGxlbmdlfVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfY2hhbGxlbmdlKHBhcmFtczogTUZBQ2hhbGxlbmdlUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBQ2hhbGxlbmdlUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QoXG4gICAgICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICAgICAgJ1BPU1QnLFxuICAgICAgICAgICAgYCR7dGhpcy51cmx9L2ZhY3RvcnMvJHtwYXJhbXMuZmFjdG9ySWR9L2NoYWxsZW5nZWAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJvZHk6IHsgY2hhbm5lbDogcGFyYW1zLmNoYW5uZWwgfSxcbiAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICBqd3Q6IHNlc3Npb25EYXRhPy5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgR29UcnVlTUZBQXBpI2NoYWxsZW5nZUFuZFZlcmlmeX1cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2NoYWxsZW5nZUFuZFZlcmlmeShcbiAgICBwYXJhbXM6IE1GQUNoYWxsZW5nZUFuZFZlcmlmeVBhcmFtc1xuICApOiBQcm9taXNlPEF1dGhNRkFWZXJpZnlSZXNwb25zZT4ge1xuICAgIC8vIGJvdGggX2NoYWxsZW5nZSBhbmQgX3ZlcmlmeSBpbmRlcGVuZGVudGx5IGFjcXVpcmUgdGhlIGxvY2ssIHNvIG5vIG5lZWRcbiAgICAvLyB0byBhY3F1aXJlIGl0IGhlcmVcblxuICAgIGNvbnN0IHsgZGF0YTogY2hhbGxlbmdlRGF0YSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCB0aGlzLl9jaGFsbGVuZ2Uoe1xuICAgICAgZmFjdG9ySWQ6IHBhcmFtcy5mYWN0b3JJZCxcbiAgICB9KVxuICAgIGlmIChjaGFsbGVuZ2VFcnJvcikge1xuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fdmVyaWZ5KHtcbiAgICAgIGZhY3RvcklkOiBwYXJhbXMuZmFjdG9ySWQsXG4gICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlRGF0YS5pZCxcbiAgICAgIGNvZGU6IHBhcmFtcy5jb2RlLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgR29UcnVlTUZBQXBpI2xpc3RGYWN0b3JzfVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfbGlzdEZhY3RvcnMoKTogUHJvbWlzZTxBdXRoTUZBTGlzdEZhY3RvcnNSZXNwb25zZT4ge1xuICAgIC8vIHVzZSAjZ2V0VXNlciBpbnN0ZWFkIG9mICNfZ2V0VXNlciBhcyB0aGUgZm9ybWVyIGFjcXVpcmVzIGEgbG9ja1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHsgdXNlciB9LFxuICAgICAgZXJyb3I6IHVzZXJFcnJvcixcbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKClcbiAgICBpZiAodXNlckVycm9yKSB7XG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogdXNlckVycm9yIH1cbiAgICB9XG5cbiAgICBjb25zdCBmYWN0b3JzID0gdXNlcj8uZmFjdG9ycyB8fCBbXVxuICAgIGNvbnN0IHRvdHAgPSBmYWN0b3JzLmZpbHRlcihcbiAgICAgIChmYWN0b3IpID0+IGZhY3Rvci5mYWN0b3JfdHlwZSA9PT0gJ3RvdHAnICYmIGZhY3Rvci5zdGF0dXMgPT09ICd2ZXJpZmllZCdcbiAgICApXG4gICAgY29uc3QgcGhvbmUgPSBmYWN0b3JzLmZpbHRlcihcbiAgICAgIChmYWN0b3IpID0+IGZhY3Rvci5mYWN0b3JfdHlwZSA9PT0gJ3Bob25lJyAmJiBmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnXG4gICAgKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgYWxsOiBmYWN0b3JzLFxuICAgICAgICB0b3RwLFxuICAgICAgICBwaG9uZSxcbiAgICAgIH0sXG4gICAgICBlcnJvcjogbnVsbCxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgR29UcnVlTUZBQXBpI2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbH1cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbCgpOiBQcm9taXNlPEF1dGhNRkFHZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWxSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGF0YTogeyBzZXNzaW9uIH0sXG4gICAgICAgICAgZXJyb3I6IHNlc3Npb25FcnJvcixcbiAgICAgICAgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHsgY3VycmVudExldmVsOiBudWxsLCBuZXh0TGV2ZWw6IG51bGwsIGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHM6IFtdIH0sXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5fZGVjb2RlSldUKHNlc3Npb24uYWNjZXNzX3Rva2VuKVxuXG4gICAgICAgIGxldCBjdXJyZW50TGV2ZWw6IEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbHMgfCBudWxsID0gbnVsbFxuXG4gICAgICAgIGlmIChwYXlsb2FkLmFhbCkge1xuICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IHBheWxvYWQuYWFsXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmV4dExldmVsOiBBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWxzIHwgbnVsbCA9IGN1cnJlbnRMZXZlbFxuXG4gICAgICAgIGNvbnN0IHZlcmlmaWVkRmFjdG9ycyA9XG4gICAgICAgICAgc2Vzc2lvbi51c2VyLmZhY3RvcnM/LmZpbHRlcigoZmFjdG9yOiBGYWN0b3IpID0+IGZhY3Rvci5zdGF0dXMgPT09ICd2ZXJpZmllZCcpID8/IFtdXG5cbiAgICAgICAgaWYgKHZlcmlmaWVkRmFjdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbmV4dExldmVsID0gJ2FhbDInXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzID0gcGF5bG9hZC5hbXIgfHwgW11cblxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IGN1cnJlbnRMZXZlbCwgbmV4dExldmVsLCBjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzIH0sIGVycm9yOiBudWxsIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuIiwgImltcG9ydCBHb1RydWVDbGllbnQgZnJvbSAnLi9Hb1RydWVDbGllbnQnXG5cbmNvbnN0IEF1dGhDbGllbnQgPSBHb1RydWVDbGllbnRcblxuZXhwb3J0IGRlZmF1bHQgQXV0aENsaWVudFxuIiwgImltcG9ydCB7IEF1dGhDbGllbnQgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbmltcG9ydCB7IFN1cGFiYXNlQXV0aENsaWVudE9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgY2xhc3MgU3VwYWJhc2VBdXRoQ2xpZW50IGV4dGVuZHMgQXV0aENsaWVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFN1cGFiYXNlQXV0aENsaWVudE9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKVxuICB9XG59XG4iLCAiaW1wb3J0IHsgRnVuY3Rpb25zQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcydcbmltcG9ydCB7IEF1dGhDaGFuZ2VFdmVudCB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuaW1wb3J0IHtcbiAgUG9zdGdyZXN0Q2xpZW50LFxuICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuICBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIsXG59IGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnXG5pbXBvcnQge1xuICBSZWFsdGltZUNoYW5uZWwsXG4gIFJlYWx0aW1lQ2hhbm5lbE9wdGlvbnMsXG4gIFJlYWx0aW1lQ2xpZW50LFxuICBSZWFsdGltZUNsaWVudE9wdGlvbnMsXG59IGZyb20gJ0BzdXBhYmFzZS9yZWFsdGltZS1qcydcbmltcG9ydCB7IFN0b3JhZ2VDbGllbnQgYXMgU3VwYWJhc2VTdG9yYWdlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N0b3JhZ2UtanMnXG5pbXBvcnQge1xuICBERUZBVUxUX0dMT0JBTF9PUFRJT05TLFxuICBERUZBVUxUX0RCX09QVElPTlMsXG4gIERFRkFVTFRfQVVUSF9PUFRJT05TLFxuICBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsXG59IGZyb20gJy4vbGliL2NvbnN0YW50cydcbmltcG9ydCB7IGZldGNoV2l0aEF1dGggfSBmcm9tICcuL2xpYi9mZXRjaCdcbmltcG9ydCB7IHN0cmlwVHJhaWxpbmdTbGFzaCwgYXBwbHlTZXR0aW5nRGVmYXVsdHMgfSBmcm9tICcuL2xpYi9oZWxwZXJzJ1xuaW1wb3J0IHsgU3VwYWJhc2VBdXRoQ2xpZW50IH0gZnJvbSAnLi9saWIvU3VwYWJhc2VBdXRoQ2xpZW50J1xuaW1wb3J0IHsgRmV0Y2gsIEdlbmVyaWNTY2hlbWEsIFN1cGFiYXNlQ2xpZW50T3B0aW9ucywgU3VwYWJhc2VBdXRoQ2xpZW50T3B0aW9ucyB9IGZyb20gJy4vbGliL3R5cGVzJ1xuXG4vKipcbiAqIFN1cGFiYXNlIENsaWVudC5cbiAqXG4gKiBBbiBpc29tb3JwaGljIEphdmFzY3JpcHQgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIFBvc3RncmVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdXBhYmFzZUNsaWVudDxcbiAgRGF0YWJhc2UgPSBhbnksXG4gIFNjaGVtYU5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSA9ICdwdWJsaWMnIGV4dGVuZHMga2V5b2YgRGF0YWJhc2VcbiAgICA/ICdwdWJsaWMnXG4gICAgOiBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSxcbiAgU2NoZW1hIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSA9IERhdGFiYXNlW1NjaGVtYU5hbWVdIGV4dGVuZHMgR2VuZXJpY1NjaGVtYVxuICAgID8gRGF0YWJhc2VbU2NoZW1hTmFtZV1cbiAgICA6IGFueVxuPiB7XG4gIC8qKlxuICAgKiBTdXBhYmFzZSBBdXRoIGFsbG93cyB5b3UgdG8gY3JlYXRlIGFuZCBtYW5hZ2UgdXNlciBzZXNzaW9ucyBmb3IgYWNjZXNzIHRvIGRhdGEgdGhhdCBpcyBzZWN1cmVkIGJ5IGFjY2VzcyBwb2xpY2llcy5cbiAgICovXG4gIGF1dGg6IFN1cGFiYXNlQXV0aENsaWVudFxuICByZWFsdGltZTogUmVhbHRpbWVDbGllbnRcblxuICBwcm90ZWN0ZWQgcmVhbHRpbWVVcmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgYXV0aFVybDogc3RyaW5nXG4gIHByb3RlY3RlZCBzdG9yYWdlVXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIGZ1bmN0aW9uc1VybDogc3RyaW5nXG4gIHByb3RlY3RlZCByZXN0OiBQb3N0Z3Jlc3RDbGllbnQ8RGF0YWJhc2UsIFNjaGVtYU5hbWUsIFNjaGVtYT5cbiAgcHJvdGVjdGVkIHN0b3JhZ2VLZXk6IHN0cmluZ1xuICBwcm90ZWN0ZWQgZmV0Y2g/OiBGZXRjaFxuICBwcm90ZWN0ZWQgY2hhbmdlZEFjY2Vzc1Rva2VuPzogc3RyaW5nXG4gIHByb3RlY3RlZCBhY2Nlc3NUb2tlbj86ICgpID0+IFByb21pc2U8c3RyaW5nIHwgbnVsbD5cblxuICBwcm90ZWN0ZWQgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgY2xpZW50IGZvciB1c2UgaW4gdGhlIGJyb3dzZXIuXG4gICAqIEBwYXJhbSBzdXBhYmFzZVVybCBUaGUgdW5pcXVlIFN1cGFiYXNlIFVSTCB3aGljaCBpcyBzdXBwbGllZCB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgcHJvamVjdCBpbiB5b3VyIHByb2plY3QgZGFzaGJvYXJkLlxuICAgKiBAcGFyYW0gc3VwYWJhc2VLZXkgVGhlIHVuaXF1ZSBTdXBhYmFzZSBLZXkgd2hpY2ggaXMgc3VwcGxpZWQgd2hlbiB5b3UgY3JlYXRlIGEgbmV3IHByb2plY3QgaW4geW91ciBwcm9qZWN0IGRhc2hib2FyZC5cbiAgICogQHBhcmFtIG9wdGlvbnMuZGIuc2NoZW1hIFlvdSBjYW4gc3dpdGNoIGluIGJldHdlZW4gc2NoZW1hcy4gVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5hdXRoLmF1dG9SZWZyZXNoVG9rZW4gU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVmcmVzaCB0aGUgdG9rZW4gYmVmb3JlIGV4cGlyaW5nLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5hdXRoLnBlcnNpc3RTZXNzaW9uIFNldCB0byBcInRydWVcIiBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHNhdmUgdGhlIHVzZXIgc2Vzc2lvbiBpbnRvIGxvY2FsIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSBvcHRpb25zLmF1dGguZGV0ZWN0U2Vzc2lvbkluVXJsIFNldCB0byBcInRydWVcIiBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IGRldGVjdHMgT0F1dGggZ3JhbnRzIGluIHRoZSBVUkwgYW5kIHNpZ25zIGluIHRoZSB1c2VyLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWFsdGltZSBPcHRpb25zIHBhc3NlZCBhbG9uZyB0byByZWFsdGltZS1qcyBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIG9wdGlvbnMuZ2xvYmFsLmZldGNoIEEgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5nbG9iYWwuaGVhZGVycyBBbnkgYWRkaXRpb25hbCBoZWFkZXJzIHRvIHNlbmQgd2l0aCBlYWNoIG5ldHdvcmsgcmVxdWVzdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBzdXBhYmFzZVVybDogc3RyaW5nLFxuICAgIHByb3RlY3RlZCBzdXBhYmFzZUtleTogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBTdXBhYmFzZUNsaWVudE9wdGlvbnM8U2NoZW1hTmFtZT5cbiAgKSB7XG4gICAgaWYgKCFzdXBhYmFzZVVybCkgdGhyb3cgbmV3IEVycm9yKCdzdXBhYmFzZVVybCBpcyByZXF1aXJlZC4nKVxuICAgIGlmICghc3VwYWJhc2VLZXkpIHRocm93IG5ldyBFcnJvcignc3VwYWJhc2VLZXkgaXMgcmVxdWlyZWQuJylcblxuICAgIGNvbnN0IF9zdXBhYmFzZVVybCA9IHN0cmlwVHJhaWxpbmdTbGFzaChzdXBhYmFzZVVybClcblxuICAgIHRoaXMucmVhbHRpbWVVcmwgPSBgJHtfc3VwYWJhc2VVcmx9L3JlYWx0aW1lL3YxYC5yZXBsYWNlKC9eaHR0cC9pLCAnd3MnKVxuICAgIHRoaXMuYXV0aFVybCA9IGAke19zdXBhYmFzZVVybH0vYXV0aC92MWBcbiAgICB0aGlzLnN0b3JhZ2VVcmwgPSBgJHtfc3VwYWJhc2VVcmx9L3N0b3JhZ2UvdjFgXG4gICAgdGhpcy5mdW5jdGlvbnNVcmwgPSBgJHtfc3VwYWJhc2VVcmx9L2Z1bmN0aW9ucy92MWBcblxuICAgIC8vIGRlZmF1bHQgc3RvcmFnZSBrZXkgdXNlcyB0aGUgc3VwYWJhc2UgcHJvamVjdCByZWYgYXMgYSBuYW1lc3BhY2VcbiAgICBjb25zdCBkZWZhdWx0U3RvcmFnZUtleSA9IGBzYi0ke25ldyBVUkwodGhpcy5hdXRoVXJsKS5ob3N0bmFtZS5zcGxpdCgnLicpWzBdfS1hdXRoLXRva2VuYFxuICAgIGNvbnN0IERFRkFVTFRTID0ge1xuICAgICAgZGI6IERFRkFVTFRfREJfT1BUSU9OUyxcbiAgICAgIHJlYWx0aW1lOiBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsXG4gICAgICBhdXRoOiB7IC4uLkRFRkFVTFRfQVVUSF9PUFRJT05TLCBzdG9yYWdlS2V5OiBkZWZhdWx0U3RvcmFnZUtleSB9LFxuICAgICAgZ2xvYmFsOiBERUZBVUxUX0dMT0JBTF9PUFRJT05TLFxuICAgIH1cblxuICAgIGNvbnN0IHNldHRpbmdzID0gYXBwbHlTZXR0aW5nRGVmYXVsdHMob3B0aW9ucyA/PyB7fSwgREVGQVVMVFMpXG5cbiAgICB0aGlzLnN0b3JhZ2VLZXkgPSBzZXR0aW5ncy5hdXRoLnN0b3JhZ2VLZXkgPz8gJydcbiAgICB0aGlzLmhlYWRlcnMgPSBzZXR0aW5ncy5nbG9iYWwuaGVhZGVycyA/PyB7fVxuXG4gICAgaWYgKCFzZXR0aW5ncy5hY2Nlc3NUb2tlbikge1xuICAgICAgdGhpcy5hdXRoID0gdGhpcy5faW5pdFN1cGFiYXNlQXV0aENsaWVudChcbiAgICAgICAgc2V0dGluZ3MuYXV0aCA/PyB7fSxcbiAgICAgICAgdGhpcy5oZWFkZXJzLFxuICAgICAgICBzZXR0aW5ncy5nbG9iYWwuZmV0Y2hcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHNldHRpbmdzLmFjY2Vzc1Rva2VuXG5cbiAgICAgIHRoaXMuYXV0aCA9IG5ldyBQcm94eTxTdXBhYmFzZUF1dGhDbGllbnQ+KHt9IGFzIGFueSwge1xuICAgICAgICBnZXQ6IChfLCBwcm9wKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEBzdXBhYmFzZS9zdXBhYmFzZS1qczogU3VwYWJhc2UgQ2xpZW50IGlzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgYWNjZXNzVG9rZW4gb3B0aW9uLCBhY2Nlc3Npbmcgc3VwYWJhc2UuYXV0aC4ke1N0cmluZyhcbiAgICAgICAgICAgICAgcHJvcFxuICAgICAgICAgICAgKX0gaXMgbm90IHBvc3NpYmxlYFxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5mZXRjaCA9IGZldGNoV2l0aEF1dGgoc3VwYWJhc2VLZXksIHRoaXMuX2dldEFjY2Vzc1Rva2VuLmJpbmQodGhpcyksIHNldHRpbmdzLmdsb2JhbC5mZXRjaClcbiAgICB0aGlzLnJlYWx0aW1lID0gdGhpcy5faW5pdFJlYWx0aW1lQ2xpZW50KHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLl9nZXRBY2Nlc3NUb2tlbi5iaW5kKHRoaXMpLFxuICAgICAgLi4uc2V0dGluZ3MucmVhbHRpbWUsXG4gICAgfSlcbiAgICB0aGlzLnJlc3QgPSBuZXcgUG9zdGdyZXN0Q2xpZW50KGAke19zdXBhYmFzZVVybH0vcmVzdC92MWAsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIHNjaGVtYTogc2V0dGluZ3MuZGIuc2NoZW1hLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgfSlcblxuICAgIGlmICghc2V0dGluZ3MuYWNjZXNzVG9rZW4pIHtcbiAgICAgIHRoaXMuX2xpc3RlbkZvckF1dGhFdmVudHMoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdXBhYmFzZSBGdW5jdGlvbnMgYWxsb3dzIHlvdSB0byBkZXBsb3kgYW5kIGludm9rZSBlZGdlIGZ1bmN0aW9ucy5cbiAgICovXG4gIGdldCBmdW5jdGlvbnMoKTogRnVuY3Rpb25zQ2xpZW50IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uc0NsaWVudCh0aGlzLmZ1bmN0aW9uc1VybCwge1xuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgY3VzdG9tRmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTdXBhYmFzZSBTdG9yYWdlIGFsbG93cyB5b3UgdG8gbWFuYWdlIHVzZXItZ2VuZXJhdGVkIGNvbnRlbnQsIHN1Y2ggYXMgcGhvdG9zIG9yIHZpZGVvcy5cbiAgICovXG4gIGdldCBzdG9yYWdlKCk6IFN1cGFiYXNlU3RvcmFnZUNsaWVudCB7XG4gICAgcmV0dXJuIG5ldyBTdXBhYmFzZVN0b3JhZ2VDbGllbnQodGhpcy5zdG9yYWdlVXJsLCB0aGlzLmhlYWRlcnMsIHRoaXMuZmV0Y2gpXG4gIH1cblxuICAvLyBOT1RFOiBzaWduYXR1cmVzIG11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggUG9zdGdyZXN0Q2xpZW50LmZyb21cbiAgZnJvbTxcbiAgICBUYWJsZU5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBTY2hlbWFbJ1RhYmxlcyddLFxuICAgIFRhYmxlIGV4dGVuZHMgU2NoZW1hWydUYWJsZXMnXVtUYWJsZU5hbWVdXG4gID4ocmVsYXRpb246IFRhYmxlTmFtZSk6IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjxTY2hlbWEsIFRhYmxlLCBUYWJsZU5hbWU+XG4gIGZyb208Vmlld05hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBTY2hlbWFbJ1ZpZXdzJ10sIFZpZXcgZXh0ZW5kcyBTY2hlbWFbJ1ZpZXdzJ11bVmlld05hbWVdPihcbiAgICByZWxhdGlvbjogVmlld05hbWVcbiAgKTogUG9zdGdyZXN0UXVlcnlCdWlsZGVyPFNjaGVtYSwgVmlldywgVmlld05hbWU+XG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgcXVlcnkgb24gYSB0YWJsZSBvciBhIHZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSByZWxhdGlvbiAtIFRoZSB0YWJsZSBvciB2aWV3IG5hbWUgdG8gcXVlcnlcbiAgICovXG4gIGZyb20ocmVsYXRpb246IHN0cmluZyk6IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjxTY2hlbWEsIGFueSwgYW55PiB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5mcm9tKHJlbGF0aW9uKVxuICB9XG5cbiAgLy8gTk9URTogc2lnbmF0dXJlcyBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIFBvc3RncmVzdENsaWVudC5zY2hlbWFcbiAgLyoqXG4gICAqIFNlbGVjdCBhIHNjaGVtYSB0byBxdWVyeSBvciBwZXJmb3JtIGFuIGZ1bmN0aW9uIChycGMpIGNhbGwuXG4gICAqXG4gICAqIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cbiAgICpcbiAgICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgdG8gcXVlcnlcbiAgICovXG4gIHNjaGVtYTxEeW5hbWljU2NoZW1hIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgRGF0YWJhc2U+KFxuICAgIHNjaGVtYTogRHluYW1pY1NjaGVtYVxuICApOiBQb3N0Z3Jlc3RDbGllbnQ8XG4gICAgRGF0YWJhc2UsXG4gICAgRHluYW1pY1NjaGVtYSxcbiAgICBEYXRhYmFzZVtEeW5hbWljU2NoZW1hXSBleHRlbmRzIEdlbmVyaWNTY2hlbWEgPyBEYXRhYmFzZVtEeW5hbWljU2NoZW1hXSA6IGFueVxuICA+IHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LnNjaGVtYTxEeW5hbWljU2NoZW1hPihzY2hlbWEpXG4gIH1cblxuICAvLyBOT1RFOiBzaWduYXR1cmVzIG11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggUG9zdGdyZXN0Q2xpZW50LnJwY1xuICAvKipcbiAgICogUGVyZm9ybSBhIGZ1bmN0aW9uIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiBuYW1lIHRvIGNhbGxcbiAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9uIGNhbGxcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLmhlYWQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIGBkYXRhYCB3aWxsIG5vdCBiZSByZXR1cm5lZC5cbiAgICogVXNlZnVsIGlmIHlvdSBvbmx5IG5lZWQgdGhlIGNvdW50LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5nZXQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoXG4gICAqIHJlYWQtb25seSBhY2Nlc3MgbW9kZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHJvd3MgcmV0dXJuZWQgYnkgdGhlXG4gICAqIGZ1bmN0aW9uLiBPbmx5IGFwcGxpY2FibGUgZm9yIFtzZXQtcmV0dXJuaW5nXG4gICAqIGZ1bmN0aW9uc10oaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9jdXJyZW50L2Z1bmN0aW9ucy1zcmYuaHRtbCkuXG4gICAqXG4gICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICogaG9vZC5cbiAgICpcbiAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICpcbiAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgKiBudW1iZXJzLlxuICAgKi9cbiAgcnBjPEZuTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFNjaGVtYVsnRnVuY3Rpb25zJ10sIEZuIGV4dGVuZHMgU2NoZW1hWydGdW5jdGlvbnMnXVtGbk5hbWVdPihcbiAgICBmbjogRm5OYW1lLFxuICAgIGFyZ3M6IEZuWydBcmdzJ10gPSB7fSxcbiAgICBvcHRpb25zOiB7XG4gICAgICBoZWFkPzogYm9vbGVhblxuICAgICAgZ2V0PzogYm9vbGVhblxuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICB9ID0ge31cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxcbiAgICBTY2hlbWEsXG4gICAgRm5bJ1JldHVybnMnXSBleHRlbmRzIGFueVtdXG4gICAgICA/IEZuWydSZXR1cm5zJ11bbnVtYmVyXSBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gICAgICAgID8gRm5bJ1JldHVybnMnXVtudW1iZXJdXG4gICAgICAgIDogbmV2ZXJcbiAgICAgIDogbmV2ZXIsXG4gICAgRm5bJ1JldHVybnMnXSxcbiAgICBGbk5hbWUsXG4gICAgbnVsbFxuICA+IHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LnJwYyhmbiwgYXJncywgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVhbHRpbWUgY2hhbm5lbCB3aXRoIEJyb2FkY2FzdCwgUHJlc2VuY2UsIGFuZCBQb3N0Z3JlcyBDaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBSZWFsdGltZSBjaGFubmVsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG4gICAqXG4gICAqL1xuICBjaGFubmVsKG5hbWU6IHN0cmluZywgb3B0czogUmVhbHRpbWVDaGFubmVsT3B0aW9ucyA9IHsgY29uZmlnOiB7fSB9KTogUmVhbHRpbWVDaGFubmVsIHtcbiAgICByZXR1cm4gdGhpcy5yZWFsdGltZS5jaGFubmVsKG5hbWUsIG9wdHMpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgUmVhbHRpbWUgY2hhbm5lbHMuXG4gICAqL1xuICBnZXRDaGFubmVscygpOiBSZWFsdGltZUNoYW5uZWxbXSB7XG4gICAgcmV0dXJuIHRoaXMucmVhbHRpbWUuZ2V0Q2hhbm5lbHMoKVxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBSZWFsdGltZSBjaGFubmVsIGZyb20gUmVhbHRpbWUgY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWx0aW1lQ2hhbm5lbH0gY2hhbm5lbCAtIFRoZSBuYW1lIG9mIHRoZSBSZWFsdGltZSBjaGFubmVsLlxuICAgKlxuICAgKi9cbiAgcmVtb3ZlQ2hhbm5lbChjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwpOiBQcm9taXNlPCdvaycgfCAndGltZWQgb3V0JyB8ICdlcnJvcic+IHtcbiAgICByZXR1cm4gdGhpcy5yZWFsdGltZS5yZW1vdmVDaGFubmVsKGNoYW5uZWwpXG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIGFsbCBSZWFsdGltZSBjaGFubmVscyBmcm9tIFJlYWx0aW1lIGNsaWVudC5cbiAgICovXG4gIHJlbW92ZUFsbENoYW5uZWxzKCk6IFByb21pc2U8KCdvaycgfCAndGltZWQgb3V0JyB8ICdlcnJvcicpW10+IHtcbiAgICByZXR1cm4gdGhpcy5yZWFsdGltZS5yZW1vdmVBbGxDaGFubmVscygpXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9nZXRBY2Nlc3NUb2tlbigpIHtcbiAgICBpZiAodGhpcy5hY2Nlc3NUb2tlbikge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYWNjZXNzVG9rZW4oKVxuICAgIH1cblxuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgdGhpcy5hdXRoLmdldFNlc3Npb24oKVxuXG4gICAgcmV0dXJuIGRhdGEuc2Vzc2lvbj8uYWNjZXNzX3Rva2VuID8/IG51bGxcbiAgfVxuXG4gIHByaXZhdGUgX2luaXRTdXBhYmFzZUF1dGhDbGllbnQoXG4gICAge1xuICAgICAgYXV0b1JlZnJlc2hUb2tlbixcbiAgICAgIHBlcnNpc3RTZXNzaW9uLFxuICAgICAgZGV0ZWN0U2Vzc2lvbkluVXJsLFxuICAgICAgc3RvcmFnZSxcbiAgICAgIHN0b3JhZ2VLZXksXG4gICAgICBmbG93VHlwZSxcbiAgICAgIGxvY2ssXG4gICAgICBkZWJ1ZyxcbiAgICB9OiBTdXBhYmFzZUF1dGhDbGllbnRPcHRpb25zLFxuICAgIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGZldGNoPzogRmV0Y2hcbiAgKSB7XG4gICAgY29uc3QgYXV0aEhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5zdXBhYmFzZUtleX1gLFxuICAgICAgYXBpa2V5OiBgJHt0aGlzLnN1cGFiYXNlS2V5fWAsXG4gICAgfVxuICAgIHJldHVybiBuZXcgU3VwYWJhc2VBdXRoQ2xpZW50KHtcbiAgICAgIHVybDogdGhpcy5hdXRoVXJsLFxuICAgICAgaGVhZGVyczogeyAuLi5hdXRoSGVhZGVycywgLi4uaGVhZGVycyB9LFxuICAgICAgc3RvcmFnZUtleTogc3RvcmFnZUtleSxcbiAgICAgIGF1dG9SZWZyZXNoVG9rZW4sXG4gICAgICBwZXJzaXN0U2Vzc2lvbixcbiAgICAgIGRldGVjdFNlc3Npb25JblVybCxcbiAgICAgIHN0b3JhZ2UsXG4gICAgICBmbG93VHlwZSxcbiAgICAgIGxvY2ssXG4gICAgICBkZWJ1ZyxcbiAgICAgIGZldGNoLFxuICAgICAgLy8gYXV0aCBjaGVja3MgaWYgdGhlcmUgaXMgYSBjdXN0b20gYXV0aG9yaXphaXRvbiBoZWFkZXIgdXNpbmcgdGhpcyBmbGFnXG4gICAgICAvLyBzbyBpdCBrbm93cyB3aGV0aGVyIHRvIHJldHVybiBhbiBlcnJvciB3aGVuIGdldFVzZXIgaXMgY2FsbGVkIHdpdGggbm8gc2Vzc2lvblxuICAgICAgaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcjogJ0F1dGhvcml6YXRpb24nIGluIHRoaXMuaGVhZGVycyxcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBfaW5pdFJlYWx0aW1lQ2xpZW50KG9wdGlvbnM6IFJlYWx0aW1lQ2xpZW50T3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUmVhbHRpbWVDbGllbnQodGhpcy5yZWFsdGltZVVybCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHBhcmFtczogeyAuLi57IGFwaWtleTogdGhpcy5zdXBhYmFzZUtleSB9LCAuLi5vcHRpb25zPy5wYXJhbXMgfSxcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBfbGlzdGVuRm9yQXV0aEV2ZW50cygpIHtcbiAgICBsZXQgZGF0YSA9IHRoaXMuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZSgoZXZlbnQsIHNlc3Npb24pID0+IHtcbiAgICAgIHRoaXMuX2hhbmRsZVRva2VuQ2hhbmdlZChldmVudCwgJ0NMSUVOVCcsIHNlc3Npb24/LmFjY2Vzc190b2tlbilcbiAgICB9KVxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICBwcml2YXRlIF9oYW5kbGVUb2tlbkNoYW5nZWQoXG4gICAgZXZlbnQ6IEF1dGhDaGFuZ2VFdmVudCxcbiAgICBzb3VyY2U6ICdDTElFTlQnIHwgJ1NUT1JBR0UnLFxuICAgIHRva2VuPzogc3RyaW5nXG4gICkge1xuICAgIGlmIChcbiAgICAgIChldmVudCA9PT0gJ1RPS0VOX1JFRlJFU0hFRCcgfHwgZXZlbnQgPT09ICdTSUdORURfSU4nKSAmJlxuICAgICAgdGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gIT09IHRva2VuXG4gICAgKSB7XG4gICAgICB0aGlzLmNoYW5nZWRBY2Nlc3NUb2tlbiA9IHRva2VuXG4gICAgfSBlbHNlIGlmIChldmVudCA9PT0gJ1NJR05FRF9PVVQnKSB7XG4gICAgICB0aGlzLnJlYWx0aW1lLnNldEF1dGgoKVxuICAgICAgaWYgKHNvdXJjZSA9PSAnU1RPUkFHRScpIHRoaXMuYXV0aC5zaWduT3V0KClcbiAgICAgIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IFN1cGFiYXNlQ2xpZW50IGZyb20gJy4vU3VwYWJhc2VDbGllbnQnXG5pbXBvcnQgdHlwZSB7IEdlbmVyaWNTY2hlbWEsIFN1cGFiYXNlQ2xpZW50T3B0aW9ucyB9IGZyb20gJy4vbGliL3R5cGVzJ1xuXG5leHBvcnQgKiBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbmV4cG9ydCB0eXBlIHsgVXNlciBhcyBBdXRoVXNlciwgU2Vzc2lvbiBhcyBBdXRoU2Vzc2lvbiB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuZXhwb3J0IHtcbiAgdHlwZSBQb3N0Z3Jlc3RSZXNwb25zZSxcbiAgdHlwZSBQb3N0Z3Jlc3RTaW5nbGVSZXNwb25zZSxcbiAgdHlwZSBQb3N0Z3Jlc3RNYXliZVNpbmdsZVJlc3BvbnNlLFxuICBQb3N0Z3Jlc3RFcnJvcixcbn0gZnJvbSAnQHN1cGFiYXNlL3Bvc3RncmVzdC1qcydcbmV4cG9ydCB7XG4gIEZ1bmN0aW9uc0h0dHBFcnJvcixcbiAgRnVuY3Rpb25zRmV0Y2hFcnJvcixcbiAgRnVuY3Rpb25zUmVsYXlFcnJvcixcbiAgRnVuY3Rpb25zRXJyb3IsXG4gIHR5cGUgRnVuY3Rpb25JbnZva2VPcHRpb25zLFxuICBGdW5jdGlvblJlZ2lvbixcbn0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcydcbmV4cG9ydCAqIGZyb20gJ0BzdXBhYmFzZS9yZWFsdGltZS1qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3VwYWJhc2VDbGllbnQgfSBmcm9tICcuL1N1cGFiYXNlQ2xpZW50J1xuZXhwb3J0IHR5cGUgeyBTdXBhYmFzZUNsaWVudE9wdGlvbnMsIFF1ZXJ5UmVzdWx0LCBRdWVyeURhdGEsIFF1ZXJ5RXJyb3IgfSBmcm9tICcuL2xpYi90eXBlcydcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFN1cGFiYXNlIENsaWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNsaWVudCA9IDxcbiAgRGF0YWJhc2UgPSBhbnksXG4gIFNjaGVtYU5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSA9ICdwdWJsaWMnIGV4dGVuZHMga2V5b2YgRGF0YWJhc2VcbiAgICA/ICdwdWJsaWMnXG4gICAgOiBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSxcbiAgU2NoZW1hIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSA9IERhdGFiYXNlW1NjaGVtYU5hbWVdIGV4dGVuZHMgR2VuZXJpY1NjaGVtYVxuICAgID8gRGF0YWJhc2VbU2NoZW1hTmFtZV1cbiAgICA6IGFueVxuPihcbiAgc3VwYWJhc2VVcmw6IHN0cmluZyxcbiAgc3VwYWJhc2VLZXk6IHN0cmluZyxcbiAgb3B0aW9ucz86IFN1cGFiYXNlQ2xpZW50T3B0aW9uczxTY2hlbWFOYW1lPlxuKTogU3VwYWJhc2VDbGllbnQ8RGF0YWJhc2UsIFNjaGVtYU5hbWUsIFNjaGVtYT4gPT4ge1xuICByZXR1cm4gbmV3IFN1cGFiYXNlQ2xpZW50PERhdGFiYXNlLCBTY2hlbWFOYW1lLCBTY2hlbWE+KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwgb3B0aW9ucylcbn1cbiIsICIvKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgY2h1bmtpbmcgdGV4dFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENodW5rU2V0dGluZ3Mge1xuXHRjaHVua1NpemU6IG51bWJlcjsgICAgICAgLy8gU2l6ZSBvZiBlYWNoIGNodW5rIGluIGNoYXJhY3RlcnNcblx0Y2h1bmtPdmVybGFwOiBudW1iZXI7ICAgIC8vIE92ZXJsYXAgYmV0d2VlbiBjaHVua3Ncblx0bWluQ2h1bmtTaXplOiBudW1iZXI7ICAgIC8vIE1pbmltdW0gc2l6ZSBvZiBhIGNodW5rXG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgZXhjbHVkZWQgcGF0aHNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFeGNsdXNpb25TZXR0aW5ncyB7XG5cdGV4Y2x1ZGVkRm9sZGVyczogc3RyaW5nW107ICAgICAgLy8gVXNlci1kZWZpbmVkIGZvbGRlcnMgdG8gZXhjbHVkZSBmcm9tIHByb2Nlc3Npbmdcblx0ZXhjbHVkZWRGaWxlVHlwZXM6IHN0cmluZ1tdOyAgICAvLyBVc2VyLWRlZmluZWQgZmlsZSBleHRlbnNpb25zIHRvIGV4Y2x1ZGVcblx0ZXhjbHVkZWRGaWxlUHJlZml4ZXM6IHN0cmluZ1tdOyAvLyBVc2VyLWRlZmluZWQgZmlsZSBuYW1lIHByZWZpeGVzIHRvIGV4Y2x1ZGVcblx0ZXhjbHVkZWRGaWxlczogc3RyaW5nW107ICAgICAgICAvLyBVc2VyLWRlZmluZWQgc3BlY2lmaWMgZmlsZXMgdG8gZXhjbHVkZVxuXHQvLyBTeXN0ZW0tbGV2ZWwgZXhjbHVzaW9ucyB0aGF0IGFyZSBhbHdheXMgYXBwbGllZCBidXQgbm90IHNob3duIGluIFVJXG5cdHN5c3RlbUV4Y2x1ZGVkRm9sZGVyczogc3RyaW5nW107XG5cdHN5c3RlbUV4Y2x1ZGVkRmlsZVR5cGVzOiBzdHJpbmdbXTtcblx0c3lzdGVtRXhjbHVkZWRGaWxlUHJlZml4ZXM6IHN0cmluZ1tdO1xuXHRzeXN0ZW1FeGNsdWRlZEZpbGVzOiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBPcGVuQUkgQVBJIHNldHRpbmdzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3BlbkFJU2V0dGluZ3Mge1xuXHRhcGlLZXk6IHN0cmluZzsgICAgICAgICAvLyBBUEkga2V5IGZvciBPcGVuQUlcblx0bW9kZWw6IHN0cmluZzsgICAgICAgICAgLy8gTW9kZWwgdG8gdXNlIGZvciBlbWJlZGRpbmdzXG5cdG1heFRva2VuczogbnVtYmVyOyAgICAgIC8vIE1heGltdW0gdG9rZW5zIGZvciBhIHNpbmdsZSByZXF1ZXN0XG5cdHRlbXBlcmF0dXJlOiBudW1iZXI7ICAgIC8vIFNhbXBsaW5nIHRlbXBlcmF0dXJlIGZvciBnZW5lcmF0aW9uXG59XG5cbi8qKlxuICogU3VwYWJhc2UgY29ubmVjdGlvbiBzZXR0aW5nc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFN1cGFiYXNlU2V0dGluZ3Mge1xuXHR1cmw6IHN0cmluZzsgICAgICAgICAgICAgIC8vIFN1cGFiYXNlIHByb2plY3QgVVJMXG5cdGFwaUtleTogc3RyaW5nOyAgICAgICAgICAvLyBTdXBhYmFzZSBBUEkga2V5XG5cdGluaXRpYWxpemVkPzogYm9vbGVhbjsgICAgLy8gV2hldGhlciBkYXRhYmFzZSBpcyBpbml0aWFsaXplZFxuXHRsYXN0U2V0dXBBdHRlbXB0PzogbnVtYmVyOyAvLyBUaW1lc3RhbXAgb2YgbGFzdCBzZXR1cCBhdHRlbXB0XG5cdHNldHVwUmV0cmllcz86IG51bWJlcjsgICAgLy8gTnVtYmVyIG9mIHNldHVwIGF0dGVtcHRzXG59XG5cbi8qKlxuICogUHJvY2Vzc2luZyBxdWV1ZSBzZXR0aW5nc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXVlU2V0dGluZ3Mge1xuXHRtYXhDb25jdXJyZW50OiBudW1iZXI7ICAvLyBNYXhpbXVtIGNvbmN1cnJlbnQgdGFza3Ncblx0cmV0cnlBdHRlbXB0czogbnVtYmVyOyAgLy8gTnVtYmVyIG9mIHJldHJ5IGF0dGVtcHRzXG5cdHJldHJ5RGVsYXk6IG51bWJlcjsgICAgIC8vIERlbGF5IGJldHdlZW4gcmV0cmllcyBpbiBtaWxsaXNlY29uZHNcbn1cblxuLyoqXG4gKiBEZWJ1ZyBhbmQgbG9nZ2luZyBzZXR0aW5nc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIERlYnVnU2V0dGluZ3Mge1xuXHRlbmFibGVEZWJ1Z0xvZ3M6IGJvb2xlYW47ICAvLyBFbmFibGUgZGV0YWlsZWQgZGVidWcgbG9nc1xuXHRsb2dMZXZlbDogJ2Vycm9yJyB8ICd3YXJuJyB8ICdpbmZvJyB8ICdkZWJ1Zyc7ICAvLyBMb2dnaW5nIGxldmVsXG5cdGxvZ1RvRmlsZTogYm9vbGVhbjsgICAgICAgIC8vIFdoZXRoZXIgdG8gbG9nIHRvIGEgZmlsZVxufVxuXG4vKipcbiAqIERldmljZSBpbmZvcm1hdGlvbiBmb3IgY3Jvc3MtZGV2aWNlIGNvb3JkaW5hdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIERldmljZUluZm8ge1xuXHRkZXZpY2VJZDogc3RyaW5nOyAgICAgICAgIC8vIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZGV2aWNlXG5cdG5hbWU6IHN0cmluZzsgICAgICAgICAgICAgLy8gVXNlci1mcmllbmRseSBuYW1lIGZvciB0aGUgZGV2aWNlXG5cdHBsYXRmb3JtOiBzdHJpbmc7ICAgICAgICAgLy8gT3BlcmF0aW5nIHN5c3RlbS9wbGF0Zm9ybVxuXHRsYXN0U2VlbjogbnVtYmVyOyAgICAgICAgIC8vIFRpbWVzdGFtcCB3aGVuIGRldmljZSB3YXMgbGFzdCBhY3RpdmVcblx0bGFzdFN5bmNUaW1lOiBudW1iZXI7ICAgICAvLyBUaW1lc3RhbXAgb2YgbGFzdCBzdWNjZXNzZnVsIHN5bmNcbn1cblxuLyoqXG4gKiBFbmhhbmNlZCBzeW5jIHNldHRpbmdzIHdpdGggY3Jvc3MtZGV2aWNlIGNvb3JkaW5hdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNTZXR0aW5ncyB7XG5cdHN5bmNGaWxlUGF0aDogc3RyaW5nOyAgICAgICAgICAgLy8gUGF0aCB0byB0aGUgc3luYyBmaWxlXG5cdGJhY2t1cEludGVydmFsOiBudW1iZXI7ICAgICAgICAgLy8gVGltZSBiZXR3ZWVuIGJhY2t1cHMgKG1zKVxuXHRjaGVja0ludGVydmFsOiBudW1iZXI7ICAgICAgICAgIC8vIFRpbWUgYmV0d2VlbiBzeW5jIGNoZWNrcyAobXMpXG5cdGNoZWNrQXR0ZW1wdHM6IG51bWJlcjsgICAgICAgICAgLy8gTnVtYmVyIG9mIHN5bmMgY2hlY2sgYXR0ZW1wdHNcblx0dGltZW91dDogbnVtYmVyOyAgICAgICAgICAgICAgICAvLyBUaW1lb3V0IGZvciBzeW5jIG9wZXJhdGlvbnMgKG1zKVxuXHRyZXF1aXJlU3luYzogYm9vbGVhbjsgICAgICAgICAgIC8vIFdoZXRoZXIgc3luYyBpcyByZXF1aXJlZCBiZWZvcmUgc3RhcnR1cFxuXHQvLyBOZXcgY3Jvc3MtZGV2aWNlIHNldHRpbmdzXG5cdGRldmljZUlkOiBzdHJpbmc7ICAgICAgICAgICAgICAgLy8gVW5pcXVlIGlkZW50aWZpZXIgZm9yIGN1cnJlbnQgZGV2aWNlXG5cdGRldmljZU5hbWU6IHN0cmluZzsgICAgICAgICAgICAgLy8gVXNlci1jb25maWd1cmFibGUgZGV2aWNlIG5hbWVcblx0a25vd25EZXZpY2VzOiBEZXZpY2VJbmZvW107ICAgICAvLyBJbmZvcm1hdGlvbiBhYm91dCBhbGwga25vd24gZGV2aWNlc1xuXHRjb25uZWN0aW9uQ2hlY2tJbnRlcnZhbDogbnVtYmVyOyAvLyBIb3cgb2Z0ZW4gdG8gY2hlY2sgZGF0YWJhc2UgY29ubmVjdGlvblxuXHRvZmZsaW5lUXVldWVFbmFibGVkOiBib29sZWFuOyAgIC8vIFdoZXRoZXIgdG8gcXVldWUgb3BlcmF0aW9ucyB3aGVuIG9mZmxpbmVcblx0Y29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3k6ICduZXdlc3Qtd2lucycgfCAnbWFudWFsJyB8ICdrZWVwLWJvdGgnOyAvLyBIb3cgdG8gaGFuZGxlIGNvbmZsaWN0c1xufVxuXG4vKipcbiAqIEluaXRpYWwgc3luYyBzZXR0aW5nc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEluaXRpYWxTeW5jU2V0dGluZ3Mge1xuXHRiYXRjaFNpemU6IG51bWJlcjsgICAgICAgICAgICAgLy8gTnVtYmVyIG9mIGZpbGVzIHBlciBiYXRjaFxuXHRtYXhDb25jdXJyZW50QmF0Y2hlczogbnVtYmVyOyAgLy8gTWF4aW11bSBjb25jdXJyZW50IGJhdGNoIHByb2Nlc3Npbmdcblx0ZW5hYmxlQXV0b0luaXRpYWxTeW5jOiBib29sZWFuOyAvLyBBdXRvLXN0YXJ0IGluaXRpYWwgc3luY1xuXHRwcmlvcml0eVJ1bGVzOiBQcmlvcml0eVJ1bGVbXTsgLy8gUnVsZXMgZm9yIGZpbGUgcHJvY2Vzc2luZyBwcmlvcml0eVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByaW9yaXR5UnVsZSB7XG5cdHBhdHRlcm46IHN0cmluZzsgICAvLyBQYXR0ZXJuIHRvIG1hdGNoIGluIGZpbGUgcGF0aFxuXHRwcmlvcml0eTogbnVtYmVyOyAgLy8gUHJpb3JpdHkgbGV2ZWwgKGhpZ2hlciA9IHByb2Nlc3NlZCBmaXJzdClcbn1cblxuLyoqXG4gKiBNYWluIHNldHRpbmdzIGludGVyZmFjZSBmb3IgdGhlIHBsdWdpblxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1pbmRNYXRyaXhTZXR0aW5ncyB7XG5cdC8vIFZhdWx0IGlkZW50aWZpY2F0aW9uXG5cdHZhdWx0SWQ6IHN0cmluZyB8IG51bGw7ICAgICAgLy8gVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB2YXVsdFxuXHRsYXN0S25vd25WYXVsdE5hbWU6IHN0cmluZzsgIC8vIExhc3Qga25vd24gbmFtZSBvZiB0aGUgdmF1bHRcblx0Ly8gQVBJIENvbmZpZ3VyYXRpb25cblx0c3VwYWJhc2U6IFN1cGFiYXNlU2V0dGluZ3M7ICAvLyBTdXBhYmFzZSBjb25maWd1cmF0aW9uXG5cdG9wZW5haTogT3BlbkFJU2V0dGluZ3M7ICAgICAgLy8gT3BlbkFJIGNvbmZpZ3VyYXRpb25cblx0Ly8gUHJvY2Vzc2luZyBzZXR0aW5nc1xuXHRjaHVua2luZzogQ2h1bmtTZXR0aW5nczsgICAgIC8vIFRleHQgY2h1bmtpbmcgc2V0dGluZ3Ncblx0cXVldWU6IFF1ZXVlU2V0dGluZ3M7ICAgICAgICAvLyBRdWV1ZSBwcm9jZXNzaW5nIHNldHRpbmdzXG5cdC8vIEV4Y2x1c2lvbiBwYXR0ZXJuc1xuXHRleGNsdXNpb25zOiBFeGNsdXNpb25TZXR0aW5nczsgIC8vIFBhdGhzIGFuZCBmaWxlIHR5cGVzIHRvIGV4Y2x1ZGVcblx0Ly8gRGVidWcgc2V0dGluZ3Ncblx0ZGVidWc6IERlYnVnU2V0dGluZ3M7ICAgICAgICAvLyBEZWJ1Z2dpbmcgYW5kIGxvZ2dpbmcgY29uZmlndXJhdGlvblxuXHQvLyBGZWF0dXJlIGZsYWdzXG5cdGVuYWJsZUF1dG9TeW5jOiBib29sZWFuOyAgICAgIC8vIEVuYWJsZSBhdXRvbWF0aWMgc3luY2hyb25pemF0aW9uXG5cdGVuYWJsZU5vdGlmaWNhdGlvbnM6IGJvb2xlYW47IC8vIFNob3cgbm90aWZpY2F0aW9ucyBmb3IgYWN0aW9uc1xuXHRlbmFibGVQcm9ncmVzc0JhcjogYm9vbGVhbjsgICAvLyBTaG93IGEgcHJvZ3Jlc3MgYmFyIGR1cmluZyB0YXNrc1xuXHQvLyBTeW5jIHNldHRpbmdzXG5cdHN5bmM6IFN5bmNTZXR0aW5ncztcblx0Ly8gSW5pdGlhbCBzeW5jIHNldHRpbmdzXG5cdGluaXRpYWxTeW5jOiBJbml0aWFsU3luY1NldHRpbmdzO1xufVxuXG4vKipcbiAqIERlZmF1bHQgY2h1bmtpbmcgb3B0aW9ucyBmb3IgdGV4dCBwcm9jZXNzaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX0NIVU5LSU5HX09QVElPTlM6IENodW5rU2V0dGluZ3MgPSB7XG5cdGNodW5rU2l6ZTogMTAwMCwgICAgICAgLy8gRGVmYXVsdCBzaXplIG9mIGVhY2ggY2h1bmsgaW4gY2hhcmFjdGVyc1xuXHRjaHVua092ZXJsYXA6IDIwMCwgICAgIC8vIERlZmF1bHQgb3ZlcmxhcCBiZXR3ZWVuIGNodW5rc1xuXHRtaW5DaHVua1NpemU6IDEwMCwgICAgIC8vIE1pbmltdW0gY2h1bmsgc2l6ZSB0byBlbnN1cmUgdXNhYmlsaXR5XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgdW5pcXVlIGRldmljZSBpZGVudGlmaWVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZURldmljZUlkKCk6IHN0cmluZyB7XG5cdHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpO1xufVxuXG4vKipcbiAqIEdldCBwbGF0Zm9ybSBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGxhdGZvcm1JbmZvKCk6IHN0cmluZyB7XG5cdGNvbnN0IHVzZXJBZ2VudCA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXHRpZiAodXNlckFnZW50LmluZGV4T2YoJ1dpbicpICE9PSAtMSkgcmV0dXJuICdXaW5kb3dzJztcblx0aWYgKHVzZXJBZ2VudC5pbmRleE9mKCdNYWMnKSAhPT0gLTEpIHJldHVybiAnbWFjT1MnO1xuXHRpZiAodXNlckFnZW50LmluZGV4T2YoJ2lQaG9uZScpICE9PSAtMSB8fCB1c2VyQWdlbnQuaW5kZXhPZignaVBhZCcpICE9PSAtMSkgcmV0dXJuICdpT1MnO1xuXHRpZiAodXNlckFnZW50LmluZGV4T2YoJ0FuZHJvaWQnKSAhPT0gLTEpIHJldHVybiAnQW5kcm9pZCc7XG5cdGlmICh1c2VyQWdlbnQuaW5kZXhPZignTGludXgnKSAhPT0gLTEpIHJldHVybiAnTGludXgnO1xuXHRyZXR1cm4gJ1Vua25vd24nO1xufVxuXG4vKipcbiAqIFN5c3RlbS1sZXZlbCBleGNsdXNpb25zIHRoYXQgYXJlIGFsd2F5cyBhcHBsaWVkIGJ1dCBub3Qgc2hvd24gaW4gVUlcbiAqL1xuZXhwb3J0IGNvbnN0IFNZU1RFTV9FWENMVVNJT05TID0ge1xuXHRmb2xkZXJzOiBbXG5cdFx0Jy5vYnNpZGlhbicsICAgICAgICAgICAvLyBPYnNpZGlhbiBjb25maWcgZm9sZGVyXG5cdFx0Jy50cmFzaCcsICAgICAgICAgICAgICAvLyBPYnNpZGlhbiB0cmFzaCBmb2xkZXJcblx0XHQnLmdpdCcsICAgICAgICAgICAgICAgIC8vIEdpdCBmb2xkZXIgaWYgdXNlZFxuXHRcdCdub2RlX21vZHVsZXMnICAgICAgICAgLy8gTm9kZSBtb2R1bGVzIGlmIHVzZWRcblx0XSxcblx0ZmlsZVR5cGVzOiBbXG5cdFx0Jy5tcDMnLCAnLmpwZycsICcucG5nJywgJy5wZGYnLCAvLyBOb24tbWFya2Rvd24gZmlsZXNcblx0XHQnLmV4Y2FsaWRyYXcnICAgICAgICAgICAgICAgICAgICAvLyBFeGNhbGlkcmF3IGZpbGVzXG5cdF0sXG5cdGZpbGVQcmVmaXhlczogWydfJywgJy4nXSwgICAvLyBIaWRkZW4gYW5kIHNwZWNpYWwgZmlsZXNcblx0ZmlsZXM6IFtcblx0XHQnX21pbmRtYXRyaXhzeW5jLm1kJywgICAgICAgICAgIC8vIFN5bmMgZmlsZVxuXHRcdCdfbWluZG1hdHJpeHN5bmMubWQuYmFja3VwJyAgICAgLy8gU3luYyBiYWNrdXAgZmlsZVxuXHRdXG59O1xuXG4vKipcbiAqIERlZmF1bHQgc2V0dGluZ3Mgd2hlbiBwbHVnaW4gaXMgZmlyc3QgaW5pdGlhbGl6ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IE1pbmRNYXRyaXhTZXR0aW5ncyA9IHtcblx0dmF1bHRJZDogbnVsbCxcblx0bGFzdEtub3duVmF1bHROYW1lOiAnJyxcblxuXHRzdXBhYmFzZToge1xuXHRcdHVybDogJycsXG5cdFx0YXBpS2V5OiAnJyxcblx0XHRpbml0aWFsaXplZDogZmFsc2UsXG5cdFx0bGFzdFNldHVwQXR0ZW1wdDogMCxcblx0XHRzZXR1cFJldHJpZXM6IDAsXG5cdH0sXG5cblx0b3BlbmFpOiB7XG5cdFx0YXBpS2V5OiAnJyxcblx0XHRtb2RlbDogJ3RleHQtZW1iZWRkaW5nLWFkYS0wMDInLFxuXHRcdG1heFRva2VuczogODAwMCxcblx0XHR0ZW1wZXJhdHVyZTogMC4wLFxuXHR9LFxuXG5cdGNodW5raW5nOiB7IC4uLkRFRkFVTFRfQ0hVTktJTkdfT1BUSU9OUyB9LCAvLyBVc2UgZGVmYXVsdCBjaHVua2luZyBvcHRpb25zXG5cblx0cXVldWU6IHtcblx0XHRtYXhDb25jdXJyZW50OiAzLFxuXHRcdHJldHJ5QXR0ZW1wdHM6IDMsXG5cdFx0cmV0cnlEZWxheTogMTAwMCxcblx0fSxcblxuXHRleGNsdXNpb25zOiB7XG5cdFx0Ly8gVXNlci1mYWNpbmcgZXhjbHVzaW9ucyAoaW5pdGlhbGx5IGVtcHR5KVxuXHRcdGV4Y2x1ZGVkRm9sZGVyczogW10sXG5cdFx0ZXhjbHVkZWRGaWxlVHlwZXM6IFtdLFxuXHRcdGV4Y2x1ZGVkRmlsZVByZWZpeGVzOiBbXSxcblx0XHRleGNsdWRlZEZpbGVzOiBbXSxcblx0XHQvLyBTeXN0ZW0gZXhjbHVzaW9ucyAoaGlkZGVuIGZyb20gVUkpXG5cdFx0c3lzdGVtRXhjbHVkZWRGb2xkZXJzOiBbLi4uU1lTVEVNX0VYQ0xVU0lPTlMuZm9sZGVyc10sXG5cdFx0c3lzdGVtRXhjbHVkZWRGaWxlVHlwZXM6IFsuLi5TWVNURU1fRVhDTFVTSU9OUy5maWxlVHlwZXNdLFxuXHRcdHN5c3RlbUV4Y2x1ZGVkRmlsZVByZWZpeGVzOiBbLi4uU1lTVEVNX0VYQ0xVU0lPTlMuZmlsZVByZWZpeGVzXSxcblx0XHRzeXN0ZW1FeGNsdWRlZEZpbGVzOiBbLi4uU1lTVEVNX0VYQ0xVU0lPTlMuZmlsZXNdXG5cdH0sXG5cblx0ZGVidWc6IHtcblx0XHRlbmFibGVEZWJ1Z0xvZ3M6IGZhbHNlLFxuXHRcdGxvZ0xldmVsOiAnaW5mbycsXG5cdFx0bG9nVG9GaWxlOiBmYWxzZSxcblx0fSxcblxuXHRlbmFibGVBdXRvU3luYzogdHJ1ZSxcblx0ZW5hYmxlTm90aWZpY2F0aW9uczogdHJ1ZSxcblx0ZW5hYmxlUHJvZ3Jlc3NCYXI6IHRydWUsXG5cblx0c3luYzoge1xuXHRcdHN5bmNGaWxlUGF0aDogJ19taW5kbWF0cml4c3luYy5tZCcsXG5cdFx0YmFja3VwSW50ZXJ2YWw6IDM2MDAwMDAsICAvLyAxIGhvdXIgaW4gbWlsbGlzZWNvbmRzXG5cdFx0Y2hlY2tJbnRlcnZhbDogMzAwMDAwLCAgICAvLyA1IG1pbnV0ZXMgaW4gbWlsbGlzZWNvbmRzXG5cdFx0Y2hlY2tBdHRlbXB0czogMyxcblx0XHR0aW1lb3V0OiA0MDAwMCxcblx0XHRyZXF1aXJlU3luYzogdHJ1ZSxcblx0XHQvLyBOZXcgY3Jvc3MtZGV2aWNlIHNldHRpbmdzXG5cdFx0ZGV2aWNlSWQ6IGdlbmVyYXRlRGV2aWNlSWQoKSxcblx0XHRkZXZpY2VOYW1lOiBgRGV2aWNlLSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCl9YCxcblx0XHRrbm93bkRldmljZXM6IFtdLFxuXHRcdGNvbm5lY3Rpb25DaGVja0ludGVydmFsOiA2MDAwMCwgLy8gMSBtaW51dGVcblx0XHRvZmZsaW5lUXVldWVFbmFibGVkOiB0cnVlLFxuXHRcdGNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5OiAnbmV3ZXN0LXdpbnMnXG5cdH0sXG5cblx0aW5pdGlhbFN5bmM6IHtcblx0XHRiYXRjaFNpemU6IDUwLFxuXHRcdG1heENvbmN1cnJlbnRCYXRjaGVzOiAzLFxuXHRcdGVuYWJsZUF1dG9Jbml0aWFsU3luYzogdHJ1ZSxcblx0XHRwcmlvcml0eVJ1bGVzOiBbXG5cdFx0XHR7IHBhdHRlcm46ICdkYWlseS8nLCBwcmlvcml0eTogMyB9LFxuXHRcdFx0eyBwYXR0ZXJuOiAncHJvamVjdHMvJywgcHJpb3JpdHk6IDIgfSxcblx0XHRcdHsgcGF0dGVybjogJ2FyY2hpdmUvJywgcHJpb3JpdHk6IDEgfVxuXHRcdF1cblx0fVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgY29tYmluZWQgbGlzdCBvZiBhbGwgZXhjbHVzaW9ucyAoc3lzdGVtICsgdXNlcikgdXNlZCBmb3IgcHJvY2Vzc2luZy5cbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbnRlcm5hbGx5IGZvciBmaWxlIHByb2Nlc3NpbmcgYW5kIGNvbWJpbmVzIGJvdGggdXNlci1kZWZpbmVkIGFuZCBzeXN0ZW0tbGV2ZWwgZXhjbHVzaW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbEV4Y2x1c2lvbnMoc2V0dGluZ3M6IE1pbmRNYXRyaXhTZXR0aW5ncyk6IHtcblx0ZXhjbHVkZWRGb2xkZXJzOiBzdHJpbmdbXSxcblx0ZXhjbHVkZWRGaWxlVHlwZXM6IHN0cmluZ1tdLFxuXHRleGNsdWRlZEZpbGVQcmVmaXhlczogc3RyaW5nW10sXG5cdGV4Y2x1ZGVkRmlsZXM6IHN0cmluZ1tdXG59IHtcblx0Y29uc3QgZXhjbHVzaW9ucyA9IHNldHRpbmdzLmV4Y2x1c2lvbnM7XG5cdHJldHVybiB7XG5cdFx0ZXhjbHVkZWRGb2xkZXJzOiBbXG5cdFx0XHQuLi5leGNsdXNpb25zLnN5c3RlbUV4Y2x1ZGVkRm9sZGVycyB8fCBTWVNURU1fRVhDTFVTSU9OUy5mb2xkZXJzLFxuXHRcdFx0Li4uZXhjbHVzaW9ucy5leGNsdWRlZEZvbGRlcnMgfHwgW11cblx0XHRdLFxuXHRcdGV4Y2x1ZGVkRmlsZVR5cGVzOiBbXG5cdFx0XHQuLi5leGNsdXNpb25zLnN5c3RlbUV4Y2x1ZGVkRmlsZVR5cGVzIHx8IFNZU1RFTV9FWENMVVNJT05TLmZpbGVUeXBlcyxcblx0XHRcdC4uLmV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlVHlwZXMgfHwgW11cblx0XHRdLFxuXHRcdGV4Y2x1ZGVkRmlsZVByZWZpeGVzOiBbXG5cdFx0XHQuLi5leGNsdXNpb25zLnN5c3RlbUV4Y2x1ZGVkRmlsZVByZWZpeGVzIHx8IFNZU1RFTV9FWENMVVNJT05TLmZpbGVQcmVmaXhlcyxcblx0XHRcdC4uLmV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlUHJlZml4ZXMgfHwgW11cblx0XHRdLFxuXHRcdGV4Y2x1ZGVkRmlsZXM6IFtcblx0XHRcdC4uLmV4Y2x1c2lvbnMuc3lzdGVtRXhjbHVkZWRGaWxlcyB8fCBTWVNURU1fRVhDTFVTSU9OUy5maWxlcyxcblx0XHRcdC4uLmV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlcyB8fCBbXVxuXHRcdF1cblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIG9ubHkgdGhlIHVzZXItZGVmaW5lZCBleGNsdXNpb25zICh3aXRob3V0IHN5c3RlbS1sZXZlbCBkZWZhdWx0cykuXG4gKiBUaGlzIGhlbHBlciBjYW4gYmUgdXNlZCBpbiBVSSBjb21wb25lbnRzIHRvIGVuc3VyZSB0aGF0IHN5c3RlbSBleGNsdXNpb25zIHJlbWFpbiBoaWRkZW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyRXhjbHVzaW9ucyhzZXR0aW5nczogTWluZE1hdHJpeFNldHRpbmdzKToge1xuXHRleGNsdWRlZEZvbGRlcnM6IHN0cmluZ1tdLFxuXHRleGNsdWRlZEZpbGVUeXBlczogc3RyaW5nW10sXG5cdGV4Y2x1ZGVkRmlsZVByZWZpeGVzOiBzdHJpbmdbXSxcblx0ZXhjbHVkZWRGaWxlczogc3RyaW5nW11cbn0ge1xuXHRjb25zdCBleGNsdXNpb25zID0gc2V0dGluZ3MuZXhjbHVzaW9ucztcblx0cmV0dXJuIHtcblx0XHRleGNsdWRlZEZvbGRlcnM6IGV4Y2x1c2lvbnMuZXhjbHVkZWRGb2xkZXJzIHx8IFtdLFxuXHRcdGV4Y2x1ZGVkRmlsZVR5cGVzOiBleGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVR5cGVzIHx8IFtdLFxuXHRcdGV4Y2x1ZGVkRmlsZVByZWZpeGVzOiBleGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVByZWZpeGVzIHx8IFtdLFxuXHRcdGV4Y2x1ZGVkRmlsZXM6IGV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlcyB8fCBbXVxuXHR9O1xufVxuXG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YXVsdCBpcyBpbml0aWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmF1bHRJbml0aWFsaXplZChzZXR0aW5nczogTWluZE1hdHJpeFNldHRpbmdzKTogYm9vbGVhbiB7XG5cdHJldHVybiBzZXR0aW5ncy52YXVsdElkICE9PSBudWxsICYmIHNldHRpbmdzLnZhdWx0SWQgIT09IHVuZGVmaW5lZCAmJiBzZXR0aW5ncy52YXVsdElkICE9PSAnJztcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gY3JlYXRlIGEgbmV3IHZhdWx0IElELlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVWYXVsdElkKCk6IHN0cmluZyB7XG5cdHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpO1xufVxuIiwgIi8vIHNyYy9zZXJ2aWNlcy9TdXBhYmFzZVNlcnZpY2UudHNcbmltcG9ydCB7IGNyZWF0ZUNsaWVudCwgU3VwYWJhc2VDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuaW1wb3J0IHsgRG9jdW1lbnRDaHVuaywgRG9jdW1lbnRNZXRhZGF0YSB9IGZyb20gJy4uL21vZGVscy9Eb2N1bWVudENodW5rJztcbmltcG9ydCB7IE1pbmRNYXRyaXhTZXR0aW5ncywgaXNWYXVsdEluaXRpYWxpemVkIH0gZnJvbSAnLi4vc2V0dGluZ3MvU2V0dGluZ3MnO1xuaW1wb3J0IHsgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSByZWNvcmQgZnJvbSBvYnNpZGlhbl9maWxlX3N0YXR1cy5cbiAqL1xuaW50ZXJmYWNlIEZpbGVTdGF0dXNSZWNvcmQge1xuXHR2YXVsdF9pZDogc3RyaW5nO1xuXHRmaWxlX3BhdGg6IHN0cmluZztcblx0bGFzdF9tb2RpZmllZDogbnVtYmVyO1xuXHRsYXN0X3ZlY3Rvcml6ZWQ/OiBzdHJpbmc7XG5cdGNvbnRlbnRfaGFzaD86IHN0cmluZztcblx0c3RhdHVzPzogc3RyaW5nO1xuXHR0YWdzPzogc3RyaW5nW107XG5cdGFsaWFzZXM/OiBzdHJpbmdbXTtcblx0bGlua3M/OiBzdHJpbmdbXTtcblx0Y3JlYXRlZF9hdD86IHN0cmluZztcblx0dXBkYXRlZF9hdD86IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIFN1cGFiYXNlU2VydmljZSB7XG5cdHByaXZhdGUgY2xpZW50OiBTdXBhYmFzZUNsaWVudCB8IG51bGw7XG5cdHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBTdXBhYmFzZVNlcnZpY2UgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBzZXR0aW5nczogTWluZE1hdHJpeFNldHRpbmdzO1xuXHRwcml2YXRlIHJlYWRvbmx5IFRBQkxFX05BTUUgPSAnb2JzaWRpYW5fZG9jdW1lbnRzJztcblx0cHJpdmF0ZSByZWFkb25seSBGSUxFX1NUQVRVU19UQUJMRSA9ICdvYnNpZGlhbl9maWxlX3N0YXR1cyc7IC8vIFRhYmxlIGZvciB0cmFja2luZyBmaWxlIHN0YXR1c1xuXG5cdHByaXZhdGUgY29uc3RydWN0b3Ioc2V0dGluZ3M6IE1pbmRNYXRyaXhTZXR0aW5ncykge1xuXHRcdGlmICghc2V0dGluZ3Muc3VwYWJhc2UudXJsIHx8ICFzZXR0aW5ncy5zdXBhYmFzZS5hcGlLZXkpIHtcblx0XHRcdGNvbnNvbGUud2FybignU3VwYWJhc2UgY29uZmlndXJhdGlvbiBpcyBpbmNvbXBsZXRlLiBTdXBhYmFzZSBzZXJ2aWNlIHdpbGwgbm90IGJlIGluaXRpYWxpemVkLicpO1xuXHRcdFx0dGhpcy5jbGllbnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIWlzVmF1bHRJbml0aWFsaXplZChzZXR0aW5ncykpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVmF1bHQgaXMgbm90IGluaXRpYWxpemVkJyk7XG5cdFx0fVxuXHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcblx0XHR0aGlzLmNsaWVudCA9IGNyZWF0ZUNsaWVudChzZXR0aW5ncy5zdXBhYmFzZS51cmwsIHNldHRpbmdzLnN1cGFiYXNlLmFwaUtleSk7XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljIGFzeW5jIGdldEluc3RhbmNlKHNldHRpbmdzOiBNaW5kTWF0cml4U2V0dGluZ3MpOiBQcm9taXNlPFN1cGFiYXNlU2VydmljZSB8IG51bGw+IHtcblx0XHRpZiAoIXNldHRpbmdzLnN1cGFiYXNlLnVybCB8fCAhc2V0dGluZ3Muc3VwYWJhc2UuYXBpS2V5KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNvbmZpZ3VyYXRpb24gaXMgaW5jb21wbGV0ZS4gUmV0dXJuaW5nIG51bGwuJyk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0aWYgKCFTdXBhYmFzZVNlcnZpY2UuaW5zdGFuY2UpIHtcblx0XHRcdFN1cGFiYXNlU2VydmljZS5pbnN0YW5jZSA9IG5ldyBTdXBhYmFzZVNlcnZpY2Uoc2V0dGluZ3MpO1xuXHRcdFx0YXdhaXQgU3VwYWJhc2VTZXJ2aWNlLmluc3RhbmNlLmluaXRpYWxpemVEYXRhYmFzZSgpO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRTdXBhYmFzZVNlcnZpY2UuaW5zdGFuY2Uuc2V0dGluZ3Muc3VwYWJhc2UudXJsICE9PSBzZXR0aW5ncy5zdXBhYmFzZS51cmwgfHxcblx0XHRcdFN1cGFiYXNlU2VydmljZS5pbnN0YW5jZS5zZXR0aW5ncy5zdXBhYmFzZS5hcGlLZXkgIT09IHNldHRpbmdzLnN1cGFiYXNlLmFwaUtleSB8fFxuXHRcdFx0U3VwYWJhc2VTZXJ2aWNlLmluc3RhbmNlLnNldHRpbmdzLnZhdWx0SWQgIT09IHNldHRpbmdzLnZhdWx0SWRcblx0XHQpIHtcblx0XHRcdFN1cGFiYXNlU2VydmljZS5pbnN0YW5jZSA9IG5ldyBTdXBhYmFzZVNlcnZpY2Uoc2V0dGluZ3MpO1xuXHRcdFx0YXdhaXQgU3VwYWJhc2VTZXJ2aWNlLmluc3RhbmNlLmluaXRpYWxpemVEYXRhYmFzZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gU3VwYWJhc2VTZXJ2aWNlLmluc3RhbmNlO1xuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBpbml0aWFsaXplRGF0YWJhc2UoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdTdXBhYmFzZSBjbGllbnQgaXMgbm90IGluaXRpYWxpemVkLiBTa2lwcGluZyBkYXRhYmFzZSBpbml0aWFsaXphdGlvbi4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdG5ldyBOb3RpY2UoJ0NoZWNraW5nIGRhdGFiYXNlIGNvbm5lY3Rpb24uLi4nKTtcblx0XHRcdC8vIFZlcmlmeSBjb25uZWN0aW9uIGJ5IHNlbGVjdGluZyBmcm9tIG9ic2lkaWFuX2RvY3VtZW50c1xuXHRcdFx0Y29uc3QgeyBlcnJvcjogdGVzdEVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLlRBQkxFX05BTUUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJylcblx0XHRcdFx0LmxpbWl0KDEpO1xuXHRcdFx0aWYgKHRlc3RFcnJvciAmJiAhdGVzdEVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZDogJHt0ZXN0RXJyb3IubWVzc2FnZX1gKTtcblx0XHRcdH1cblx0XHRcdC8vIEVuc3VyZSB0aGUgZmlsZSBzdGF0dXMgdGFibGUgZXhpc3RzXG5cdFx0XHRhd2FpdCB0aGlzLmluaXRpYWxpemVGaWxlU3RhdHVzVGFibGUoKTtcblx0XHRcdG5ldyBOb3RpY2UoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gdmVyaWZpZWQnKTtcblx0XHRcdHRoaXMuc2V0dGluZ3Muc3VwYWJhc2UuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdEYXRhYmFzZSBpbml0aWFsaXphdGlvbiBlcnJvcjonLCBlcnJvcik7XG5cdFx0XHRuZXcgTm90aWNlKGBEYXRhYmFzZSBlcnJvcjogJHsoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2V9YCk7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRW5zdXJlcyB0aGF0IG9ic2lkaWFuX2ZpbGVfc3RhdHVzIHRhYmxlIGV4aXN0cy5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZUZpbGVTdGF0dXNUYWJsZSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSByZXR1cm47XG5cdFx0dHJ5IHtcblx0XHRcdC8vIENoZWNrIGlmIGZpbGUgc3RhdHVzIHRhYmxlIGV4aXN0c1xuXHRcdFx0Y29uc3QgeyBlcnJvcjogY2hlY2tFcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5GSUxFX1NUQVRVU19UQUJMRSlcblx0XHRcdFx0LnNlbGVjdCgnaWQnKVxuXHRcdFx0XHQubGltaXQoMSk7XG5cdFx0XHRpZiAoY2hlY2tFcnJvciAmJiBjaGVja0Vycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0ZpbGUgc3RhdHVzIHRhYmxlIG1pc3NpbmcuIFBsZWFzZSBjcmVhdGUgaXQgbWFudWFsbHkgb3IgcnVuIHNldHVwIFNRTC4nKTtcblx0XHRcdFx0bmV3IE5vdGljZSgnU29tZSBkYXRhYmFzZSB0YWJsZXMgYXJlIG1pc3NpbmcuIFBsdWdpbiB3aWxsIHdvcmsgd2l0aCBsaW1pdGVkIGZ1bmN0aW9uYWxpdHkuJywgNTAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnRmlsZSBzdGF0dXMgdGFibGUgZXhpc3RzIGFuZCBpcyBhY2Nlc3NpYmxlJyk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBmaWxlIHN0YXR1cyB0YWJsZTonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBpbml0aWFsaXplIGZpbGUgc3RhdHVzIHRhYmxlOiAkeyhlcnJvciBhcyBFcnJvcikubWVzc2FnZX1gKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSW5zZXJ0cyBvciB1cGRhdGVzIGRvY3VtZW50IGNodW5rcyBpbiB0aGUgb2JzaWRpYW5fZG9jdW1lbnRzIHRhYmxlLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIHVwc2VydENodW5rcyhjaHVua3M6IERvY3VtZW50Q2h1bmtbXSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHtcblx0XHRcdGNvbnNvbGUud2FybignU3VwYWJhc2UgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZC4gU2tpcHBpbmcgdXBzZXJ0Q2h1bmtzLicpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0aWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ05vIGNodW5rcyB0byB1cHNlcnQnKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRGV0ZXJtaW5lIHRoZSBvYnNpZGlhbklkIGZyb20gdGhlIGZpcnN0IGNodW5rXG5cdFx0XHRjb25zdCBvYnNpZGlhbklkID0gY2h1bmtzWzBdLm1ldGFkYXRhLm9ic2lkaWFuSWQ7XG5cdFx0XHQvLyBEZWxldGUgZXhpc3RpbmcgY2h1bmtzIGZvciB0aGlzIGZpbGUgZmlyc3Rcblx0XHRcdGNvbnN0IHsgZXJyb3I6IGRlbGV0ZUVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLlRBQkxFX05BTUUpXG5cdFx0XHRcdC5kZWxldGUoKVxuXHRcdFx0XHQuZXEoJ3ZhdWx0X2lkJywgdGhpcy5zZXR0aW5ncy52YXVsdElkKVxuXHRcdFx0XHQuZXEoJ29ic2lkaWFuX2lkJywgb2JzaWRpYW5JZCk7XG5cdFx0XHRpZiAoZGVsZXRlRXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgZXhpc3RpbmcgY2h1bmtzOicsIGRlbGV0ZUVycm9yKTtcblx0XHRcdFx0dGhyb3cgZGVsZXRlRXJyb3I7XG5cdFx0XHR9XG5cdFx0XHQvLyBQcmVwYXJlIG5ldyBjaHVuayBkYXRhIGZvciBpbnNlcnRpb25cblx0XHRcdGNvbnN0IGNodW5rc1RvSW5zZXJ0ID0gY2h1bmtzLm1hcChjaHVuayA9PiAoe1xuXHRcdFx0XHR2YXVsdF9pZDogdGhpcy5zZXR0aW5ncy52YXVsdElkLFxuXHRcdFx0XHRvYnNpZGlhbl9pZDogY2h1bmsubWV0YWRhdGEub2JzaWRpYW5JZCxcblx0XHRcdFx0Y2h1bmtfaW5kZXg6IGNodW5rLmNodW5rSW5kZXgsXG5cdFx0XHRcdGNvbnRlbnQ6IGNodW5rLmNvbnRlbnQsXG5cdFx0XHRcdG1ldGFkYXRhOiBjaHVuay5tZXRhZGF0YSxcblx0XHRcdFx0ZW1iZWRkaW5nOiBjaHVuay5lbWJlZGRpbmcsXG5cdFx0XHRcdGxhc3RfdXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuXHRcdFx0XHR2ZWN0b3JpemVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcblx0XHRcdH0pKTtcblx0XHRcdC8vIEluc2VydCBuZXcgY2h1bmtzXG5cdFx0XHRjb25zdCB7IGVycm9yOiBpbnNlcnRFcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5UQUJMRV9OQU1FKVxuXHRcdFx0XHQuaW5zZXJ0KGNodW5rc1RvSW5zZXJ0KTtcblx0XHRcdGlmIChpbnNlcnRFcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBpbnNlcnRpbmcgbmV3IGNodW5rczonLCBpbnNlcnRFcnJvcik7XG5cdFx0XHRcdHRocm93IGluc2VydEVycm9yO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVXBkYXRlIGZpbGUgc3RhdHVzIHRvIHRyYWNrIHZlY3Rvcml6YXRpb25cblx0XHRcdGF3YWl0IHRoaXMudXBkYXRlRmlsZVZlY3Rvcml6YXRpb25TdGF0dXMoY2h1bmtzWzBdLm1ldGFkYXRhKTtcblx0XHRcdGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgdXBkYXRlZCBjaHVua3M6Jywge1xuXHRcdFx0XHRudW1iZXJPZkNodW5rczogY2h1bmtzLmxlbmd0aCxcblx0XHRcdFx0dmF1bHRJZDogdGhpcy5zZXR0aW5ncy52YXVsdElkLFxuXHRcdFx0XHRvYnNpZGlhbklkXG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHVwc2VydCBjaHVua3M6JywgZXJyb3IpO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEJ1bGsgdXBzZXJ0IG1ldGhvZCBmb3IgZmlsZSBzdGF0dXMgcmVjb3Jkcy5cblx0ICogSW1wcm92ZXMgcGVyZm9ybWFuY2UgZm9yIGxhcmdlIHZhdWx0cy5cblx0ICovXG5cdHB1YmxpYyBhc3luYyBidWxrVXBzZXJ0RmlsZVN0YXR1c2VzKHN0YXR1c2VzOiBGaWxlU3RhdHVzUmVjb3JkW10pOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNsaWVudCBpcyBub3QgaW5pdGlhbGl6ZWQuIFNraXBwaW5nIGJ1bGtVcHNlcnRGaWxlU3RhdHVzZXMuJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRpZiAoc3RhdHVzZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cdFx0XHRjb25zdCB7IGVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLkZJTEVfU1RBVFVTX1RBQkxFKVxuXHRcdFx0XHQudXBzZXJ0KHN0YXR1c2VzLCB7IG9uQ29uZmxpY3Q6ICd2YXVsdF9pZCxmaWxlX3BhdGgnIH0pO1xuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBidWxrIHVwc2VydCBvZiBmaWxlIHN0YXR1c2VzOicsIGVycm9yKTtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cdFx0XHRjb25zb2xlLmxvZyhgQnVsayB1cHNlcnQgb2YgJHtzdGF0dXNlcy5sZW5ndGh9IGZpbGUgc3RhdHVzZXMgc3VjY2Vzc2Z1bC5gKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIGJ1bGsgdXBzZXJ0IGZpbGUgc3RhdHVzZXM6JywgZXJyb3IpO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgb3IgdXBkYXRlcyBhIHJlY29yZCBpbiB0aGUgb2JzaWRpYW5fZmlsZV9zdGF0dXMgdGFibGVcblx0ICogdG8gcmVmbGVjdCB0aGUgbGF0ZXN0IGZpbGUgc3RhdHVzIHVzaW5nIHByb3ZpZGVkIG1ldGFkYXRhLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIHVwZGF0ZUZpbGVWZWN0b3JpemF0aW9uU3RhdHVzKG1ldGFkYXRhOiBEb2N1bWVudE1ldGFkYXRhKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdTdXBhYmFzZSBjbGllbnQgaXMgbm90IGluaXRpYWxpemVkLiBTa2lwcGluZyB1cGRhdGVGaWxlVmVjdG9yaXphdGlvblN0YXR1cy4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdC8vIENoZWNrIGlmIGZpbGUgc3RhdHVzIHRhYmxlIGV4aXN0c1xuXHRcdFx0Y29uc3QgeyBlcnJvcjogY2hlY2tFcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5GSUxFX1NUQVRVU19UQUJMRSlcblx0XHRcdFx0LnNlbGVjdCgnaWQnKVxuXHRcdFx0XHQubGltaXQoMSk7XG5cdFx0XHRpZiAoY2hlY2tFcnJvciAmJiBjaGVja0Vycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdGaWxlIHN0YXR1cyB0YWJsZSBkb2VzIG5vdCBleGlzdC4gU2tpcHBpbmcgc3RhdHVzIHVwZGF0ZS4nKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ29uc3RydWN0IGEgRmlsZVN0YXR1c1JlY29yZFxuXHRcdFx0Y29uc3QgZmlsZVN0YXR1czogRmlsZVN0YXR1c1JlY29yZCA9IHtcblx0XHRcdFx0dmF1bHRfaWQ6IHRoaXMuc2V0dGluZ3MudmF1bHRJZCEsXG5cdFx0XHRcdGZpbGVfcGF0aDogbWV0YWRhdGEub2JzaWRpYW5JZCxcblx0XHRcdFx0bGFzdF9tb2RpZmllZDogbWV0YWRhdGEubGFzdE1vZGlmaWVkLFxuXHRcdFx0XHRsYXN0X3ZlY3Rvcml6ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcblx0XHRcdFx0Y29udGVudF9oYXNoOiBtZXRhZGF0YS5jdXN0b21NZXRhZGF0YT8uY29udGVudEhhc2ggfHwgJycsXG5cdFx0XHRcdHN0YXR1czogJ1BFTkRJTkcnLFxuXHRcdFx0XHR0YWdzOiBtZXRhZGF0YS50YWdzIHx8IFtdLFxuXHRcdFx0XHRhbGlhc2VzOiBtZXRhZGF0YS5jdXN0b21NZXRhZGF0YT8uYWxpYXNlcyB8fCBbXSxcblx0XHRcdFx0bGlua3M6IG1ldGFkYXRhLmxpbmtzIHx8IFtdLFxuXHRcdFx0XHR1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcblx0XHRcdH07XG5cdFx0XHQvLyBVcHNlcnQgdGhlIHJlY29yZCBpbnRvIHRoZSBmaWxlIHN0YXR1cyB0YWJsZVxuXHRcdFx0Y29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5GSUxFX1NUQVRVU19UQUJMRSlcblx0XHRcdFx0LnVwc2VydChmaWxlU3RhdHVzLCB7IG9uQ29uZmxpY3Q6ICd2YXVsdF9pZCxmaWxlX3BhdGgnIH0pO1xuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGZpbGUgdmVjdG9yaXphdGlvbiBzdGF0dXM6JywgZXJyb3IpO1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH1cblx0XHRcdGNvbnNvbGUubG9nKCdGaWxlIHZlY3Rvcml6YXRpb24gc3RhdHVzIHVwZGF0ZWQ6JywgbWV0YWRhdGEub2JzaWRpYW5JZCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgZmlsZSB2ZWN0b3JpemF0aW9uIHN0YXR1czonLCBlcnJvcik7XG5cdFx0XHQvLyBOb24tY3JpdGljYWwsIHNvIGp1c3QgbG9nIHRoZSBlcnJvclxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBNYXJrcyBhIGZpbGUgYXMgZGVsZXRlZCBpbiB0aGUgb2JzaWRpYW5fZmlsZV9zdGF0dXMgdGFibGUuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgdXBkYXRlRmlsZVN0YXR1c09uRGVsZXRlKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSByZXR1cm47XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZXJyb3I6IGNoZWNrRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJylcblx0XHRcdFx0LmxpbWl0KDEpO1xuXHRcdFx0aWYgKGNoZWNrRXJyb3IgJiYgY2hlY2tFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdkb2VzIG5vdCBleGlzdCcpKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignRmlsZSBzdGF0dXMgdGFibGUgZG9lcyBub3QgZXhpc3QuIFNraXBwaW5nIHN0YXR1cyB1cGRhdGUgb24gZGVsZXRlLicpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjb25zdCB7IGVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLkZJTEVfU1RBVFVTX1RBQkxFKVxuXHRcdFx0XHQudXBkYXRlKHtcblx0XHRcdFx0XHRzdGF0dXM6ICdkZWxldGVkJyxcblx0XHRcdFx0XHR1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcblx0XHRcdFx0fSlcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmVxKCdmaWxlX3BhdGgnLCBmaWxlUGF0aCk7XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgZmlsZSBzdGF0dXMgb24gZGVsZXRlOicsIGVycm9yKTtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgZmlsZSBzdGF0dXMgb24gZGVsZXRlOicsIGVycm9yKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRGVsZXRlcyBkb2N1bWVudCBjaHVua3MgZm9yIGEgZ2l2ZW4gb2JzaWRpYW5JZCBmcm9tIHRoZSBvYnNpZGlhbl9kb2N1bWVudHMgdGFibGUuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgZGVsZXRlRG9jdW1lbnRDaHVua3Mob2JzaWRpYW5JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdTdXBhYmFzZSBjbGllbnQgaXMgbm90IGluaXRpYWxpemVkLiBTa2lwcGluZyBkZWxldGVEb2N1bWVudENodW5rcy4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuVEFCTEVfTkFNRSlcblx0XHRcdFx0LmRlbGV0ZSgpXG5cdFx0XHRcdC5lcSgndmF1bHRfaWQnLCB0aGlzLnNldHRpbmdzLnZhdWx0SWQpXG5cdFx0XHRcdC5lcSgnb2JzaWRpYW5faWQnLCBvYnNpZGlhbklkKTtcblx0XHRcdGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHQvLyBBbHNvIG1hcmsgZmlsZSBhcyBkZWxldGVkIGluIHRoZSBmaWxlIHN0YXR1cyB0YWJsZVxuXHRcdFx0YXdhaXQgdGhpcy51cGRhdGVGaWxlU3RhdHVzT25EZWxldGUob2JzaWRpYW5JZCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgY2h1bmtzOicsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgZG9jdW1lbnQgY2h1bmtzIGZvciBhIGdpdmVuIG9ic2lkaWFuSWQuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgZ2V0RG9jdW1lbnRDaHVua3Mob2JzaWRpYW5JZDogc3RyaW5nKTogUHJvbWlzZTxEb2N1bWVudENodW5rW10+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNsaWVudCBpcyBub3QgaW5pdGlhbGl6ZWQuIFNraXBwaW5nIGdldERvY3VtZW50Q2h1bmtzLicpO1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5UQUJMRV9OQU1FKVxuXHRcdFx0XHQuc2VsZWN0KCcqJylcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmVxKCdvYnNpZGlhbl9pZCcsIG9ic2lkaWFuSWQpXG5cdFx0XHRcdC5vcmRlcignY2h1bmtfaW5kZXgnKTtcblx0XHRcdGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRyZXR1cm4gZGF0YS5tYXAocm93ID0+ICh7XG5cdFx0XHRcdGNvbnRlbnQ6IHJvdy5jb250ZW50LFxuXHRcdFx0XHRjaHVua0luZGV4OiByb3cuY2h1bmtfaW5kZXgsXG5cdFx0XHRcdG1ldGFkYXRhOiByb3cubWV0YWRhdGEgYXMgRG9jdW1lbnRNZXRhZGF0YSxcblx0XHRcdFx0ZW1iZWRkaW5nOiByb3cuZW1iZWRkaW5nLFxuXHRcdFx0XHR2ZWN0b3JpemVkX2F0OiByb3cudmVjdG9yaXplZF9hdFxuXHRcdFx0fSkpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGNodW5rczonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGEgZmlsZSBoYXMgYmVlbiB2ZWN0b3JpemVkIGJhc2VkIG9uIHRoZSBvYnNpZGlhbl9maWxlX3N0YXR1cyB0YWJsZS5cblx0ICovXG5cdHB1YmxpYyBhc3luYyBpc0ZpbGVWZWN0b3JpemVkKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSByZXR1cm4gZmFsc2U7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZXJyb3I6IGNoZWNrRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJylcblx0XHRcdFx0LmxpbWl0KDEpO1xuXHRcdFx0aWYgKGNoZWNrRXJyb3IgJiYgY2hlY2tFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdkb2VzIG5vdCBleGlzdCcpKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignRmlsZSBzdGF0dXMgdGFibGUgZG9lcyBub3QgZXhpc3QuIEFzc3VtaW5nIGZpbGUgaXMgbm90IHZlY3Rvcml6ZWQuJyk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJ3N0YXR1cywgbGFzdF92ZWN0b3JpemVkJylcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmVxKCdmaWxlX3BhdGgnLCBmaWxlUGF0aClcblx0XHRcdFx0LnNpbmdsZSgpO1xuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdGlmIChlcnJvci5jb2RlID09PSAnUEdSU1QxMTYnKSB7XG5cdFx0XHRcdFx0Ly8gUm93IG5vdCBmb3VuZFxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkYXRhICYmIGRhdGEuc3RhdHVzID09PSAndmVjdG9yaXplZCcgJiYgISFkYXRhLmxhc3RfdmVjdG9yaXplZDtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNoZWNrIGlmIGZpbGUgaXMgdmVjdG9yaXplZDonLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgdmVjdG9yaXphdGlvbiBzdGF0dXMgb2YgYSBmaWxlIGZyb20gdGhlIGRhdGFiYXNlLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGdldEZpbGVWZWN0b3JpemF0aW9uU3RhdHVzKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHtcblx0XHRpc1ZlY3Rvcml6ZWQ6IGJvb2xlYW47XG5cdFx0bGFzdE1vZGlmaWVkOiBudW1iZXI7XG5cdFx0bGFzdFZlY3Rvcml6ZWQ6IHN0cmluZyB8IG51bGw7XG5cdFx0Y29udGVudEhhc2g6IHN0cmluZyB8IG51bGw7XG5cdFx0c3RhdHVzOiBzdHJpbmcgfCBudWxsO1xuXHR9PiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aXNWZWN0b3JpemVkOiBmYWxzZSxcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiAwLFxuXHRcdFx0XHRsYXN0VmVjdG9yaXplZDogbnVsbCxcblx0XHRcdFx0Y29udGVudEhhc2g6IG51bGwsXG5cdFx0XHRcdHN0YXR1czogbnVsbFxuXHRcdFx0fTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZXJyb3I6IGNoZWNrRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJylcblx0XHRcdFx0LmxpbWl0KDEpO1xuXHRcdFx0aWYgKGNoZWNrRXJyb3IgJiYgY2hlY2tFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdkb2VzIG5vdCBleGlzdCcpKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignRmlsZSBzdGF0dXMgdGFibGUgZG9lcyBub3QgZXhpc3QuIFJldHVybmluZyBkZWZhdWx0IHN0YXR1cy4nKTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpc1ZlY3Rvcml6ZWQ6IGZhbHNlLFxuXHRcdFx0XHRcdGxhc3RNb2RpZmllZDogMCxcblx0XHRcdFx0XHRsYXN0VmVjdG9yaXplZDogbnVsbCxcblx0XHRcdFx0XHRjb250ZW50SGFzaDogbnVsbCxcblx0XHRcdFx0XHRzdGF0dXM6IG51bGxcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJyonKVxuXHRcdFx0XHQuZXEoJ3ZhdWx0X2lkJywgdGhpcy5zZXR0aW5ncy52YXVsdElkKVxuXHRcdFx0XHQuZXEoJ2ZpbGVfcGF0aCcsIGZpbGVQYXRoKVxuXHRcdFx0XHQuc2luZ2xlKCk7XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0aWYgKGVycm9yLmNvZGUgPT09ICdQR1JTVDExNicpIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0aXNWZWN0b3JpemVkOiBmYWxzZSxcblx0XHRcdFx0XHRcdGxhc3RNb2RpZmllZDogMCxcblx0XHRcdFx0XHRcdGxhc3RWZWN0b3JpemVkOiBudWxsLFxuXHRcdFx0XHRcdFx0Y29udGVudEhhc2g6IG51bGwsXG5cdFx0XHRcdFx0XHRzdGF0dXM6IG51bGxcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aXNWZWN0b3JpemVkOiBkYXRhLnN0YXR1cyA9PT0gJ3ZlY3Rvcml6ZWQnLFxuXHRcdFx0XHRsYXN0TW9kaWZpZWQ6IGRhdGEubGFzdF9tb2RpZmllZCxcblx0XHRcdFx0bGFzdFZlY3Rvcml6ZWQ6IGRhdGEubGFzdF92ZWN0b3JpemVkLFxuXHRcdFx0XHRjb250ZW50SGFzaDogZGF0YS5jb250ZW50X2hhc2gsXG5cdFx0XHRcdHN0YXR1czogZGF0YS5zdGF0dXNcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgZmlsZSB2ZWN0b3JpemF0aW9uIHN0YXR1czonLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRpc1ZlY3Rvcml6ZWQ6IGZhbHNlLFxuXHRcdFx0XHRsYXN0TW9kaWZpZWQ6IDAsXG5cdFx0XHRcdGxhc3RWZWN0b3JpemVkOiBudWxsLFxuXHRcdFx0XHRjb250ZW50SGFzaDogbnVsbCxcblx0XHRcdFx0c3RhdHVzOiBudWxsXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIGEgZmlsZSBuZWVkcyB2ZWN0b3JpemluZyBiYXNlZCBvbiBsYXN0X21vZGlmaWVkIGFuZCBjb250ZW50X2hhc2guXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgbmVlZHNWZWN0b3JpemluZyhcblx0XHRmaWxlUGF0aDogc3RyaW5nLFxuXHRcdGxhc3RNb2RpZmllZDogbnVtYmVyLFxuXHRcdGNvbnRlbnRIYXNoOiBzdHJpbmdcblx0KTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkgcmV0dXJuIHRydWU7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZXJyb3I6IGNoZWNrRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJylcblx0XHRcdFx0LmxpbWl0KDEpO1xuXHRcdFx0aWYgKGNoZWNrRXJyb3IgJiYgY2hlY2tFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdkb2VzIG5vdCBleGlzdCcpKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignRmlsZSBzdGF0dXMgdGFibGUgZG9lcyBub3QgZXhpc3QuIEFzc3VtaW5nIGZpbGUgbmVlZHMgdmVjdG9yaXppbmcuJyk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy5nZXRGaWxlVmVjdG9yaXphdGlvblN0YXR1cyhmaWxlUGF0aCk7XG5cdFx0XHRpZiAoIXN0YXR1cy5zdGF0dXMpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7IC8vIE5vIHJlY29yZCBtZWFucyBpdCBuZWVkcyB2ZWN0b3JpemluZ1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN0YXR1cy5jb250ZW50SGFzaCAhPT0gY29udGVudEhhc2gpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7IC8vIENvbnRlbnQgaGFzIGNoYW5nZWRcblx0XHRcdH1cblx0XHRcdGlmIChsYXN0TW9kaWZpZWQgPiBzdGF0dXMubGFzdE1vZGlmaWVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlOyAvLyBGaWxlIG1vZGlmaWVkIHNpbmNlIGxhc3QgdmVjdG9yaXphdGlvblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2hlY2sgaWYgZmlsZSBuZWVkcyB2ZWN0b3JpemluZzonLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gRGVmYXVsdCB0byBuZWVkaW5nIHZlY3Rvcml6YXRpb24gb24gZXJyb3JzXG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyBhbGwgZmlsZXMgdGhhdCBkbyBub3QgaGF2ZSBhIHN0YXR1cyBvZiAndmVjdG9yaXplZCcgaW4gdGhlIGRhdGFiYXNlLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGdldEZpbGVzTmVlZGluZ1ZlY3Rvcml6YXRpb24oKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHJldHVybiBbXTtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgeyBlcnJvcjogY2hlY2tFcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5GSUxFX1NUQVRVU19UQUJMRSlcblx0XHRcdFx0LnNlbGVjdCgnaWQnKVxuXHRcdFx0XHQubGltaXQoMSk7XG5cdFx0XHRpZiAoY2hlY2tFcnJvciAmJiBjaGVja0Vycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdGaWxlIHN0YXR1cyB0YWJsZSBkb2VzIG5vdCBleGlzdC4gVW5hYmxlIHRvIGRldGVybWluZSBmaWxlcyBuZWVkaW5nIHZlY3Rvcml6YXRpb24uJyk7XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJ2ZpbGVfcGF0aCcpXG5cdFx0XHRcdC5lcSgndmF1bHRfaWQnLCB0aGlzLnNldHRpbmdzLnZhdWx0SWQpXG5cdFx0XHRcdC5ub3QoJ3N0YXR1cycsICdlcScsICd2ZWN0b3JpemVkJyk7XG5cdFx0XHRpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0cmV0dXJuIGRhdGEubWFwKChyb3c6IHsgZmlsZV9wYXRoOiBzdHJpbmcgfSkgPT4gcm93LmZpbGVfcGF0aCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgZmlsZXMgbmVlZGluZyB2ZWN0b3JpemF0aW9uOicsIGVycm9yKTtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUGVyZm9ybXMgYSBzZW1hbnRpYyBzZWFyY2ggdXNpbmcgdGhlIG1hdGNoX2RvY3VtZW50cyBmdW5jdGlvbi5cblx0ICovXG5cdHB1YmxpYyBhc3luYyBzZW1hbnRpY1NlYXJjaChlbWJlZGRpbmc6IG51bWJlcltdLCBsaW1pdDogbnVtYmVyID0gNSk6IFByb21pc2U8QXJyYXk8e1xuXHRcdGNvbnRlbnQ6IHN0cmluZztcblx0XHRtZXRhZGF0YTogRG9jdW1lbnRNZXRhZGF0YTtcblx0XHRzaW1pbGFyaXR5OiBudW1iZXI7XG5cdH0+PiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdTdXBhYmFzZSBjbGllbnQgaXMgbm90IGluaXRpYWxpemVkLiBTa2lwcGluZyBzZW1hbnRpY1NlYXJjaC4nKTtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50LnJwYygnbWF0Y2hfZG9jdW1lbnRzJywge1xuXHRcdFx0XHRxdWVyeV9lbWJlZGRpbmc6IGVtYmVkZGluZyxcblx0XHRcdFx0c2VhcmNoX3ZhdWx0X2lkOiB0aGlzLnNldHRpbmdzLnZhdWx0SWQsXG5cdFx0XHRcdG1hdGNoX2NvdW50OiBsaW1pdFxuXHRcdFx0fSk7XG5cdFx0XHRpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0cmV0dXJuIGRhdGEubWFwKChyb3c6IGFueSkgPT4gKHtcblx0XHRcdFx0Y29udGVudDogcm93LmNvbnRlbnQsXG5cdFx0XHRcdG1ldGFkYXRhOiByb3cubWV0YWRhdGEgYXMgRG9jdW1lbnRNZXRhZGF0YSxcblx0XHRcdFx0c2ltaWxhcml0eTogcm93LnNpbWlsYXJpdHlcblx0XHRcdH0pKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBlcmZvcm0gc2VtYW50aWMgc2VhcmNoOicsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUZXN0cyB0aGUgY29ubmVjdGlvbiBieSBzZWxlY3RpbmcgZnJvbSB0aGUgb2JzaWRpYW5fZG9jdW1lbnRzIHRhYmxlLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIHRlc3RDb25uZWN0aW9uKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHJldHVybiBmYWxzZTtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5UQUJMRV9OQU1FKVxuXHRcdFx0XHQuc2VsZWN0KCdpZCcpXG5cdFx0XHRcdC5saW1pdCgxKTtcblx0XHRcdC8vIENvbnNpZGVyIGNvbm5lY3RlZCBldmVuIGlmIHRhYmxlIGRvZXNuJ3QgZXhpc3Rcblx0XHRcdGlmIChlcnJvciAmJiBlcnJvci5tZXNzYWdlICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gIWVycm9yO1xuXHRcdH0gY2F0Y2gge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFsbCB1bmlxdWUgb2JzaWRpYW5faWRzIGZyb20gdGhlIG9ic2lkaWFuX2RvY3VtZW50cyB0YWJsZSBmb3IgdGhlIGN1cnJlbnQgdmF1bHQuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgZ2V0QWxsRG9jdW1lbnRJZHMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHtcblx0XHRcdGNvbnNvbGUud2FybignU3VwYWJhc2UgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZC4gU2tpcHBpbmcgZ2V0QWxsRG9jdW1lbnRJZHMuJyk7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLlRBQkxFX05BTUUpXG5cdFx0XHRcdC5zZWxlY3QoJ29ic2lkaWFuX2lkJylcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmRpc3RpbmN0KCk7XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0aWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGF0YS5tYXAoKHJvdzogYW55KSA9PiByb3cub2JzaWRpYW5faWQpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGRvY3VtZW50IElEczonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyB0aGUgcmVxdWlyZWQgZGF0YWJhc2UgdGFibGVzIGlmIG5lZWRlZCAobWFudWFsIGludm9jYXRpb24pLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGNyZWF0ZVJlcXVpcmVkVGFibGVzKCk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHN1Y2Nlc3M6IGZhbHNlLFxuXHRcdFx0XHRtZXNzYWdlOiAnU3VwYWJhc2UgY2xpZW50IG5vdCBpbml0aWFsaXplZCdcblx0XHRcdH07XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHQvLyBBdHRlbXB0IHRvIGNyZWF0ZSB0aGUgZmlsZSBzdGF0dXMgdGFibGVcblx0XHRcdGNvbnN0IGNyZWF0ZUZpbGVTdGF0dXNUYWJsZVNRTCA9IGBcblx0XHRcdFx0Q1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgJHt0aGlzLkZJTEVfU1RBVFVTX1RBQkxFfSAoXG5cdFx0XHRcdFx0aWQgQklHU0VSSUFMIFBSSU1BUlkgS0VZLFxuXHRcdFx0XHRcdHZhdWx0X2lkIFRFWFQgTk9UIE5VTEwsXG5cdFx0XHRcdFx0ZmlsZV9wYXRoIFRFWFQgTk9UIE5VTEwsXG5cdFx0XHRcdFx0bGFzdF9tb2RpZmllZCBCSUdJTlQgTk9UIE5VTEwsXG5cdFx0XHRcdFx0bGFzdF92ZWN0b3JpemVkIFRJTUVTVEFNUFRaLFxuXHRcdFx0XHRcdGNvbnRlbnRfaGFzaCBURVhULFxuXHRcdFx0XHRcdHN0YXR1cyBURVhULFxuXHRcdFx0XHRcdHRhZ3MgVEVYVFtdLFxuXHRcdFx0XHRcdGFsaWFzZXMgVEVYVFtdLFxuXHRcdFx0XHRcdGxpbmtzIFRFWFRbXSxcblx0XHRcdFx0XHRjcmVhdGVkX2F0IFRJTUVTVEFNUFRaIERFRkFVTFQgQ1VSUkVOVF9USU1FU1RBTVAsXG5cdFx0XHRcdFx0dXBkYXRlZF9hdCBUSU1FU1RBTVBUWiBERUZBVUxUIENVUlJFTlRfVElNRVNUQU1QLFxuXHRcdFx0XHRcdFVOSVFVRSh2YXVsdF9pZCwgZmlsZV9wYXRoKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRDUkVBVEUgSU5ERVggSUYgTk9UIEVYSVNUUyBpZHhfZmlsZV9zdGF0dXNfdmF1bHRfcGF0aCBPTiAke3RoaXMuRklMRV9TVEFUVVNfVEFCTEV9KHZhdWx0X2lkLCBmaWxlX3BhdGgpO1xuXHRcdFx0YDtcblx0XHRcdC8vIEV4ZWN1dGUgdmlhIGEgUG9zdGdyZXMgUlBDOyBub3RlIHRoYXQgdGhpcyBtYXkgcmVxdWlyZSBlbGV2YXRlZCBwcml2aWxlZ2VzLlxuXHRcdFx0Y29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnQucnBjKCdydW5fc3FsJywgeyBzcWw6IGNyZWF0ZUZpbGVTdGF0dXNUYWJsZVNRTCB9KTtcblx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRyZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogYENvdWxkIG5vdCBjcmVhdGUgdGFibGVzOiAke2Vycm9yLm1lc3NhZ2V9YCB9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZTogJ1RhYmxlcyBjcmVhdGVkIHN1Y2Nlc3NmdWxseScgfTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0cmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6IGBFcnJvciBjcmVhdGluZyB0YWJsZXM6ICR7KGVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWAgfTtcblx0XHR9XG5cdH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEZvcm1hdCB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdF9mb3JtYXQ6IEZvcm1hdCA9ICdSRkMzOTg2JztcbmV4cG9ydCBjb25zdCBmb3JtYXR0ZXJzOiBSZWNvcmQ8Rm9ybWF0LCAoc3RyOiBQcm9wZXJ0eUtleSkgPT4gc3RyaW5nPiA9IHtcbiAgUkZDMTczODogKHY6IFByb3BlcnR5S2V5KSA9PiBTdHJpbmcodikucmVwbGFjZSgvJTIwL2csICcrJyksXG4gIFJGQzM5ODY6ICh2OiBQcm9wZXJ0eUtleSkgPT4gU3RyaW5nKHYpLFxufTtcbmV4cG9ydCBjb25zdCBSRkMxNzM4ID0gJ1JGQzE3MzgnO1xuZXhwb3J0IGNvbnN0IFJGQzM5ODYgPSAnUkZDMzk4Nic7XG4iLCAiaW1wb3J0IHsgUkZDMTczOCB9IGZyb20gJy4vZm9ybWF0cyc7XG5pbXBvcnQgdHlwZSB7IERlZmF1bHRFbmNvZGVyLCBGb3JtYXQgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGlzX2FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuY29uc3QgaGV4X3RhYmxlID0gKCgpID0+IHtcbiAgY29uc3QgYXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgIGFycmF5LnB1c2goJyUnICsgKChpIDwgMTYgPyAnMCcgOiAnJykgKyBpLnRvU3RyaW5nKDE2KSkudG9VcHBlckNhc2UoKSk7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59KSgpO1xuXG5mdW5jdGlvbiBjb21wYWN0X3F1ZXVlPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PihxdWV1ZTogQXJyYXk8eyBvYmo6IFQ7IHByb3A6IHN0cmluZyB9Pikge1xuICB3aGlsZSAocXVldWUubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IGl0ZW0gPSBxdWV1ZS5wb3AoKTtcbiAgICBpZiAoIWl0ZW0pIGNvbnRpbnVlO1xuXG4gICAgY29uc3Qgb2JqID0gaXRlbS5vYmpbaXRlbS5wcm9wXTtcblxuICAgIGlmIChpc19hcnJheShvYmopKSB7XG4gICAgICBjb25zdCBjb21wYWN0ZWQ6IHVua25vd25bXSA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG9iai5sZW5ndGg7ICsraikge1xuICAgICAgICBpZiAodHlwZW9mIG9ialtqXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb21wYWN0ZWQucHVzaChvYmpbal0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGl0ZW0ub2JqW2l0ZW0ucHJvcF0gPSBjb21wYWN0ZWQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFycmF5X3RvX29iamVjdChzb3VyY2U6IGFueVtdLCBvcHRpb25zOiB7IHBsYWluT2JqZWN0czogYm9vbGVhbiB9KSB7XG4gIGNvbnN0IG9iaiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvYmpbaV0gPSBzb3VyY2VbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlKFxuICB0YXJnZXQ6IGFueSxcbiAgc291cmNlOiBhbnksXG4gIG9wdGlvbnM6IHsgcGxhaW5PYmplY3RzPzogYm9vbGVhbjsgYWxsb3dQcm90b3R5cGVzPzogYm9vbGVhbiB9ID0ge30sXG4pIHtcbiAgaWYgKCFzb3VyY2UpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgaWYgKGlzX2FycmF5KHRhcmdldCkpIHtcbiAgICAgIHRhcmdldC5wdXNoKHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKG9wdGlvbnMgJiYgKG9wdGlvbnMucGxhaW5PYmplY3RzIHx8IG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSkgfHxcbiAgICAgICAgIWhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNvdXJjZSlcbiAgICAgICkge1xuICAgICAgICB0YXJnZXRbc291cmNlXSA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbdGFyZ2V0LCBzb3VyY2VdO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBpZiAoIXRhcmdldCB8fCB0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBbdGFyZ2V0XS5jb25jYXQoc291cmNlKTtcbiAgfVxuXG4gIGxldCBtZXJnZVRhcmdldCA9IHRhcmdldDtcbiAgaWYgKGlzX2FycmF5KHRhcmdldCkgJiYgIWlzX2FycmF5KHNvdXJjZSkpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbWVyZ2VUYXJnZXQgPSBhcnJheV90b19vYmplY3QodGFyZ2V0LCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChpc19hcnJheSh0YXJnZXQpICYmIGlzX2FycmF5KHNvdXJjZSkpIHtcbiAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgaWYgKGhhcy5jYWxsKHRhcmdldCwgaSkpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0SXRlbSA9IHRhcmdldFtpXTtcbiAgICAgICAgaWYgKHRhcmdldEl0ZW0gJiYgdHlwZW9mIHRhcmdldEl0ZW0gPT09ICdvYmplY3QnICYmIGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGFyZ2V0W2ldID0gbWVyZ2UodGFyZ2V0SXRlbSwgaXRlbSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtpXSA9IGl0ZW07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgaWYgKGhhcy5jYWxsKGFjYywga2V5KSkge1xuICAgICAgYWNjW2tleV0gPSBtZXJnZShhY2Nba2V5XSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCBtZXJnZVRhcmdldCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25fc2luZ2xlX3NvdXJjZSh0YXJnZXQ6IGFueSwgc291cmNlOiBhbnkpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgIGFjY1trZXldID0gc291cmNlW2tleV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgdGFyZ2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShzdHI6IHN0cmluZywgXzogYW55LCBjaGFyc2V0OiBzdHJpbmcpIHtcbiAgY29uc3Qgc3RyV2l0aG91dFBsdXMgPSBzdHIucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gIGlmIChjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAvLyB1bmVzY2FwZSBuZXZlciB0aHJvd3MsIG5vIHRyeS4uLmNhdGNoIG5lZWRlZDpcbiAgICByZXR1cm4gc3RyV2l0aG91dFBsdXMucmVwbGFjZSgvJVswLTlhLWZdezJ9L2dpLCB1bmVzY2FwZSk7XG4gIH1cbiAgLy8gdXRmLThcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cldpdGhvdXRQbHVzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBzdHJXaXRob3V0UGx1cztcbiAgfVxufVxuXG5jb25zdCBsaW1pdCA9IDEwMjQ7XG5cbmV4cG9ydCBjb25zdCBlbmNvZGU6IChcbiAgc3RyOiBhbnksXG4gIGRlZmF1bHRFbmNvZGVyOiBEZWZhdWx0RW5jb2RlcixcbiAgY2hhcnNldDogc3RyaW5nLFxuICB0eXBlOiAna2V5JyB8ICd2YWx1ZScsXG4gIGZvcm1hdDogRm9ybWF0LFxuKSA9PiBzdHJpbmcgPSAoc3RyLCBfZGVmYXVsdEVuY29kZXIsIGNoYXJzZXQsIF9raW5kLCBmb3JtYXQ6IEZvcm1hdCkgPT4ge1xuICAvLyBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBieSBCcmlhbiBXaGl0ZSBmb3IgdGhlIGlvLmpzIGNvcmUgcXVlcnlzdHJpbmcgbGlicmFyeS5cbiAgLy8gSXQgaGFzIGJlZW4gYWRhcHRlZCBoZXJlIGZvciBzdHJpY3RlciBhZGhlcmVuY2UgdG8gUkZDIDM5ODZcbiAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgbGV0IHN0cmluZyA9IHN0cjtcbiAgaWYgKHR5cGVvZiBzdHIgPT09ICdzeW1ib2wnKSB7XG4gICAgc3RyaW5nID0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN0cik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSBTdHJpbmcoc3RyKTtcbiAgfVxuXG4gIGlmIChjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICByZXR1cm4gZXNjYXBlKHN0cmluZykucmVwbGFjZSgvJXVbMC05YS1mXXs0fS9naSwgZnVuY3Rpb24gKCQwKSB7XG4gICAgICByZXR1cm4gJyUyNiUyMycgKyBwYXJzZUludCgkMC5zbGljZSgyKSwgMTYpICsgJyUzQic7XG4gICAgfSk7XG4gIH1cblxuICBsZXQgb3V0ID0gJyc7XG4gIGZvciAobGV0IGogPSAwOyBqIDwgc3RyaW5nLmxlbmd0aDsgaiArPSBsaW1pdCkge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzdHJpbmcubGVuZ3RoID49IGxpbWl0ID8gc3RyaW5nLnNsaWNlKGosIGogKyBsaW1pdCkgOiBzdHJpbmc7XG4gICAgY29uc3QgYXJyID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnQubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxldCBjID0gc2VnbWVudC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKFxuICAgICAgICBjID09PSAweDJkIHx8IC8vIC1cbiAgICAgICAgYyA9PT0gMHgyZSB8fCAvLyAuXG4gICAgICAgIGMgPT09IDB4NWYgfHwgLy8gX1xuICAgICAgICBjID09PSAweDdlIHx8IC8vIH5cbiAgICAgICAgKGMgPj0gMHgzMCAmJiBjIDw9IDB4MzkpIHx8IC8vIDAtOVxuICAgICAgICAoYyA+PSAweDQxICYmIGMgPD0gMHg1YSkgfHwgLy8gYS16XG4gICAgICAgIChjID49IDB4NjEgJiYgYyA8PSAweDdhKSB8fCAvLyBBLVpcbiAgICAgICAgKGZvcm1hdCA9PT0gUkZDMTczOCAmJiAoYyA9PT0gMHgyOCB8fCBjID09PSAweDI5KSkgLy8gKCApXG4gICAgICApIHtcbiAgICAgICAgYXJyW2Fyci5sZW5ndGhdID0gc2VnbWVudC5jaGFyQXQoaSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgYXJyW2Fyci5sZW5ndGhdID0gaGV4X3RhYmxlW2NdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICBhcnJbYXJyLmxlbmd0aF0gPSBoZXhfdGFibGVbMHhjMCB8IChjID4+IDYpXSEgKyBoZXhfdGFibGVbMHg4MCB8IChjICYgMHgzZildO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGMgPCAweGQ4MDAgfHwgYyA+PSAweGUwMDApIHtcbiAgICAgICAgYXJyW2Fyci5sZW5ndGhdID1cbiAgICAgICAgICBoZXhfdGFibGVbMHhlMCB8IChjID4+IDEyKV0hICsgaGV4X3RhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNmKV0gKyBoZXhfdGFibGVbMHg4MCB8IChjICYgMHgzZildO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgICAgYyA9IDB4MTAwMDAgKyAoKChjICYgMHgzZmYpIDw8IDEwKSB8IChzZWdtZW50LmNoYXJDb2RlQXQoaSkgJiAweDNmZikpO1xuXG4gICAgICBhcnJbYXJyLmxlbmd0aF0gPVxuICAgICAgICBoZXhfdGFibGVbMHhmMCB8IChjID4+IDE4KV0hICtcbiAgICAgICAgaGV4X3RhYmxlWzB4ODAgfCAoKGMgPj4gMTIpICYgMHgzZildICtcbiAgICAgICAgaGV4X3RhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNmKV0gK1xuICAgICAgICBoZXhfdGFibGVbMHg4MCB8IChjICYgMHgzZildO1xuICAgIH1cblxuICAgIG91dCArPSBhcnIuam9pbignJyk7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhY3QodmFsdWU6IGFueSkge1xuICBjb25zdCBxdWV1ZSA9IFt7IG9iajogeyBvOiB2YWx1ZSB9LCBwcm9wOiAnbycgfV07XG4gIGNvbnN0IHJlZnMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgaXRlbSA9IHF1ZXVlW2ldO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBvYmogPSBpdGVtLm9ialtpdGVtLnByb3BdO1xuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2pdITtcbiAgICAgIGNvbnN0IHZhbCA9IG9ialtrZXldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiByZWZzLmluZGV4T2YodmFsKSA9PT0gLTEpIHtcbiAgICAgICAgcXVldWUucHVzaCh7IG9iajogb2JqLCBwcm9wOiBrZXkgfSk7XG4gICAgICAgIHJlZnMucHVzaCh2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbXBhY3RfcXVldWUocXVldWUpO1xuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzX3JlZ2V4cChvYmo6IGFueSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNfYnVmZmVyKG9iajogYW55KSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhKG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZShhOiBhbnksIGI6IGFueSkge1xuICByZXR1cm4gW10uY29uY2F0KGEsIGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVfbWFwPFQ+KHZhbDogVFtdLCBmbjogKHY6IFQpID0+IFQpIHtcbiAgaWYgKGlzX2FycmF5KHZhbCkpIHtcbiAgICBjb25zdCBtYXBwZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbWFwcGVkLnB1c2goZm4odmFsW2ldISkpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwcGVkO1xuICB9XG4gIHJldHVybiBmbih2YWwpO1xufVxuIiwgImltcG9ydCB7IGVuY29kZSwgaXNfYnVmZmVyLCBtYXliZV9tYXAgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGRlZmF1bHRfZm9ybWF0LCBmb3JtYXR0ZXJzIH0gZnJvbSAnLi9mb3JtYXRzJztcbmltcG9ydCB0eXBlIHsgTm9uTnVsbGFibGVQcm9wZXJ0aWVzLCBTdHJpbmdpZnlPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmNvbnN0IGFycmF5X3ByZWZpeF9nZW5lcmF0b3JzID0ge1xuICBicmFja2V0cyhwcmVmaXg6IFByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIFN0cmluZyhwcmVmaXgpICsgJ1tdJztcbiAgfSxcbiAgY29tbWE6ICdjb21tYScsXG4gIGluZGljZXMocHJlZml4OiBQcm9wZXJ0eUtleSwga2V5OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gU3RyaW5nKHByZWZpeCkgKyAnWycgKyBrZXkgKyAnXSc7XG4gIH0sXG4gIHJlcGVhdChwcmVmaXg6IFByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIFN0cmluZyhwcmVmaXgpO1xuICB9LFxufTtcblxuY29uc3QgaXNfYXJyYXkgPSBBcnJheS5pc0FycmF5O1xuY29uc3QgcHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xuY29uc3QgcHVzaF90b19hcnJheSA9IGZ1bmN0aW9uIChhcnI6IGFueVtdLCB2YWx1ZV9vcl9hcnJheTogYW55KSB7XG4gIHB1c2guYXBwbHkoYXJyLCBpc19hcnJheSh2YWx1ZV9vcl9hcnJheSkgPyB2YWx1ZV9vcl9hcnJheSA6IFt2YWx1ZV9vcl9hcnJheV0pO1xufTtcblxuY29uc3QgdG9fSVNPID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmc7XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBhZGRRdWVyeVByZWZpeDogZmFsc2UsXG4gIGFsbG93RG90czogZmFsc2UsXG4gIGFsbG93RW1wdHlBcnJheXM6IGZhbHNlLFxuICBhcnJheUZvcm1hdDogJ2luZGljZXMnLFxuICBjaGFyc2V0OiAndXRmLTgnLFxuICBjaGFyc2V0U2VudGluZWw6IGZhbHNlLFxuICBkZWxpbWl0ZXI6ICcmJyxcbiAgZW5jb2RlOiB0cnVlLFxuICBlbmNvZGVEb3RJbktleXM6IGZhbHNlLFxuICBlbmNvZGVyOiBlbmNvZGUsXG4gIGVuY29kZVZhbHVlc09ubHk6IGZhbHNlLFxuICBmb3JtYXQ6IGRlZmF1bHRfZm9ybWF0LFxuICBmb3JtYXR0ZXI6IGZvcm1hdHRlcnNbZGVmYXVsdF9mb3JtYXRdLFxuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgaW5kaWNlczogZmFsc2UsXG4gIHNlcmlhbGl6ZURhdGUoZGF0ZSkge1xuICAgIHJldHVybiB0b19JU08uY2FsbChkYXRlKTtcbiAgfSxcbiAgc2tpcE51bGxzOiBmYWxzZSxcbiAgc3RyaWN0TnVsbEhhbmRsaW5nOiBmYWxzZSxcbn0gYXMgTm9uTnVsbGFibGVQcm9wZXJ0aWVzPFN0cmluZ2lmeU9wdGlvbnMgJiB7IGZvcm1hdHRlcjogKHR5cGVvZiBmb3JtYXR0ZXJzKVsnUkZDMTczOCddIH0+O1xuXG5mdW5jdGlvbiBpc19ub25fbnVsbGlzaF9wcmltaXRpdmUodjogdW5rbm93bik6IHYgaXMgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IHN5bWJvbCB8IGJpZ2ludCB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHYgPT09ICdudW1iZXInIHx8XG4gICAgdHlwZW9mIHYgPT09ICdib29sZWFuJyB8fFxuICAgIHR5cGVvZiB2ID09PSAnc3ltYm9sJyB8fFxuICAgIHR5cGVvZiB2ID09PSAnYmlnaW50J1xuICApO1xufVxuXG5jb25zdCBzZW50aW5lbCA9IHt9O1xuXG5mdW5jdGlvbiBpbm5lcl9zdHJpbmdpZnkoXG4gIG9iamVjdDogYW55LFxuICBwcmVmaXg6IFByb3BlcnR5S2V5LFxuICBnZW5lcmF0ZUFycmF5UHJlZml4OiBTdHJpbmdpZnlPcHRpb25zWydhcnJheUZvcm1hdCddIHwgKChwcmVmaXg6IHN0cmluZywga2V5OiBzdHJpbmcpID0+IHN0cmluZyksXG4gIGNvbW1hUm91bmRUcmlwOiBib29sZWFuLFxuICBhbGxvd0VtcHR5QXJyYXlzOiBib29sZWFuLFxuICBzdHJpY3ROdWxsSGFuZGxpbmc6IGJvb2xlYW4sXG4gIHNraXBOdWxsczogYm9vbGVhbixcbiAgZW5jb2RlRG90SW5LZXlzOiBib29sZWFuLFxuICBlbmNvZGVyOiBTdHJpbmdpZnlPcHRpb25zWydlbmNvZGVyJ10sXG4gIGZpbHRlcjogU3RyaW5naWZ5T3B0aW9uc1snZmlsdGVyJ10sXG4gIHNvcnQ6IFN0cmluZ2lmeU9wdGlvbnNbJ3NvcnQnXSxcbiAgYWxsb3dEb3RzOiBTdHJpbmdpZnlPcHRpb25zWydhbGxvd0RvdHMnXSxcbiAgc2VyaWFsaXplRGF0ZTogU3RyaW5naWZ5T3B0aW9uc1snc2VyaWFsaXplRGF0ZSddLFxuICBmb3JtYXQ6IFN0cmluZ2lmeU9wdGlvbnNbJ2Zvcm1hdCddLFxuICBmb3JtYXR0ZXI6IFN0cmluZ2lmeU9wdGlvbnNbJ2Zvcm1hdHRlciddLFxuICBlbmNvZGVWYWx1ZXNPbmx5OiBib29sZWFuLFxuICBjaGFyc2V0OiBTdHJpbmdpZnlPcHRpb25zWydjaGFyc2V0J10sXG4gIHNpZGVDaGFubmVsOiBXZWFrTWFwPGFueSwgYW55Pixcbikge1xuICBsZXQgb2JqID0gb2JqZWN0O1xuXG4gIGxldCB0bXBfc2MgPSBzaWRlQ2hhbm5lbDtcbiAgbGV0IHN0ZXAgPSAwO1xuICBsZXQgZmluZF9mbGFnID0gZmFsc2U7XG4gIHdoaWxlICgodG1wX3NjID0gdG1wX3NjLmdldChzZW50aW5lbCkpICE9PSB2b2lkIHVuZGVmaW5lZCAmJiAhZmluZF9mbGFnKSB7XG4gICAgLy8gV2hlcmUgb2JqZWN0IGxhc3QgYXBwZWFyZWQgaW4gdGhlIHJlZiB0cmVlXG4gICAgY29uc3QgcG9zID0gdG1wX3NjLmdldChvYmplY3QpO1xuICAgIHN0ZXAgKz0gMTtcbiAgICBpZiAodHlwZW9mIHBvcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChwb3MgPT09IHN0ZXApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0N5Y2xpYyBvYmplY3QgdmFsdWUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmRfZmxhZyA9IHRydWU7IC8vIEJyZWFrIHdoaWxlXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdG1wX3NjLmdldChzZW50aW5lbCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzdGVwID0gMDtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9iaiA9IGZpbHRlcihwcmVmaXgsIG9iaik7XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIG9iaiA9IHNlcmlhbGl6ZURhdGU/LihvYmopO1xuICB9IGVsc2UgaWYgKGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgaXNfYXJyYXkob2JqKSkge1xuICAgIG9iaiA9IG1heWJlX21hcChvYmosIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplRGF0ZT8uKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBpZiAoc3RyaWN0TnVsbEhhbmRsaW5nKSB7XG4gICAgICByZXR1cm4gZW5jb2RlciAmJiAhZW5jb2RlVmFsdWVzT25seSA/XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGVuY29kZXIocHJlZml4LCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAna2V5JywgZm9ybWF0KVxuICAgICAgICA6IHByZWZpeDtcbiAgICB9XG5cbiAgICBvYmogPSAnJztcbiAgfVxuXG4gIGlmIChpc19ub25fbnVsbGlzaF9wcmltaXRpdmUob2JqKSB8fCBpc19idWZmZXIob2JqKSkge1xuICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICBjb25zdCBrZXlfdmFsdWUgPVxuICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5ID8gcHJlZml4XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICA6IGVuY29kZXIocHJlZml4LCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAna2V5JywgZm9ybWF0KTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGZvcm1hdHRlcj8uKGtleV92YWx1ZSkgK1xuICAgICAgICAgICc9JyArXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGZvcm1hdHRlcj8uKGVuY29kZXIob2JqLCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAndmFsdWUnLCBmb3JtYXQpKSxcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbZm9ybWF0dGVyPy4ocHJlZml4KSArICc9JyArIGZvcm1hdHRlcj8uKFN0cmluZyhvYmopKV07XG4gIH1cblxuICBjb25zdCB2YWx1ZXM6IHN0cmluZ1tdID0gW107XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIGxldCBvYmpfa2V5cztcbiAgaWYgKGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgaXNfYXJyYXkob2JqKSkge1xuICAgIC8vIHdlIG5lZWQgdG8gam9pbiBlbGVtZW50cyBpblxuICAgIGlmIChlbmNvZGVWYWx1ZXNPbmx5ICYmIGVuY29kZXIpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdmFsdWVzIG9ubHlcbiAgICAgIG9iaiA9IG1heWJlX21hcChvYmosIGVuY29kZXIpO1xuICAgIH1cbiAgICBvYmpfa2V5cyA9IFt7IHZhbHVlOiBvYmoubGVuZ3RoID4gMCA/IG9iai5qb2luKCcsJykgfHwgbnVsbCA6IHZvaWQgdW5kZWZpbmVkIH1dO1xuICB9IGVsc2UgaWYgKGlzX2FycmF5KGZpbHRlcikpIHtcbiAgICBvYmpfa2V5cyA9IGZpbHRlcjtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBvYmpfa2V5cyA9IHNvcnQgPyBrZXlzLnNvcnQoc29ydCkgOiBrZXlzO1xuICB9XG5cbiAgY29uc3QgZW5jb2RlZF9wcmVmaXggPSBlbmNvZGVEb3RJbktleXMgPyBTdHJpbmcocHJlZml4KS5yZXBsYWNlKC9cXC4vZywgJyUyRScpIDogU3RyaW5nKHByZWZpeCk7XG5cbiAgY29uc3QgYWRqdXN0ZWRfcHJlZml4ID1cbiAgICBjb21tYVJvdW5kVHJpcCAmJiBpc19hcnJheShvYmopICYmIG9iai5sZW5ndGggPT09IDEgPyBlbmNvZGVkX3ByZWZpeCArICdbXScgOiBlbmNvZGVkX3ByZWZpeDtcblxuICBpZiAoYWxsb3dFbXB0eUFycmF5cyAmJiBpc19hcnJheShvYmopICYmIG9iai5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYWRqdXN0ZWRfcHJlZml4ICsgJ1tdJztcbiAgfVxuXG4gIGZvciAobGV0IGogPSAwOyBqIDwgb2JqX2tleXMubGVuZ3RoOyArK2opIHtcbiAgICBjb25zdCBrZXkgPSBvYmpfa2V5c1tqXTtcbiAgICBjb25zdCB2YWx1ZSA9XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Yga2V5LnZhbHVlICE9PSAndW5kZWZpbmVkJyA/IGtleS52YWx1ZSA6IG9ialtrZXkgYXMgYW55XTtcblxuICAgIGlmIChza2lwTnVsbHMgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBlbmNvZGVkX2tleSA9IGFsbG93RG90cyAmJiBlbmNvZGVEb3RJbktleXMgPyAoa2V5IGFzIGFueSkucmVwbGFjZSgvXFwuL2csICclMkUnKSA6IGtleTtcbiAgICBjb25zdCBrZXlfcHJlZml4ID1cbiAgICAgIGlzX2FycmF5KG9iaikgP1xuICAgICAgICB0eXBlb2YgZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeChhZGp1c3RlZF9wcmVmaXgsIGVuY29kZWRfa2V5KVxuICAgICAgICA6IGFkanVzdGVkX3ByZWZpeFxuICAgICAgOiBhZGp1c3RlZF9wcmVmaXggKyAoYWxsb3dEb3RzID8gJy4nICsgZW5jb2RlZF9rZXkgOiAnWycgKyBlbmNvZGVkX2tleSArICddJyk7XG5cbiAgICBzaWRlQ2hhbm5lbC5zZXQob2JqZWN0LCBzdGVwKTtcbiAgICBjb25zdCB2YWx1ZVNpZGVDaGFubmVsID0gbmV3IFdlYWtNYXAoKTtcbiAgICB2YWx1ZVNpZGVDaGFubmVsLnNldChzZW50aW5lbCwgc2lkZUNoYW5uZWwpO1xuICAgIHB1c2hfdG9fYXJyYXkoXG4gICAgICB2YWx1ZXMsXG4gICAgICBpbm5lcl9zdHJpbmdpZnkoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBrZXlfcHJlZml4LFxuICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICBjb21tYVJvdW5kVHJpcCxcbiAgICAgICAgYWxsb3dFbXB0eUFycmF5cyxcbiAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgIGVuY29kZURvdEluS2V5cyxcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIGVuY29kZVZhbHVlc09ubHkgJiYgaXNfYXJyYXkob2JqKSA/IG51bGwgOiBlbmNvZGVyLFxuICAgICAgICBmaWx0ZXIsXG4gICAgICAgIHNvcnQsXG4gICAgICAgIGFsbG93RG90cyxcbiAgICAgICAgc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgZm9ybWF0LFxuICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgIGVuY29kZVZhbHVlc09ubHksXG4gICAgICAgIGNoYXJzZXQsXG4gICAgICAgIHZhbHVlU2lkZUNoYW5uZWwsXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gdmFsdWVzO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVfc3RyaW5naWZ5X29wdGlvbnMoXG4gIG9wdHM6IFN0cmluZ2lmeU9wdGlvbnMgPSBkZWZhdWx0cyxcbik6IE5vbk51bGxhYmxlUHJvcGVydGllczxPbWl0PFN0cmluZ2lmeU9wdGlvbnMsICdpbmRpY2VzJz4+ICYgeyBpbmRpY2VzPzogYm9vbGVhbiB9IHtcbiAgaWYgKHR5cGVvZiBvcHRzLmFsbG93RW1wdHlBcnJheXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmFsbG93RW1wdHlBcnJheXMgIT09ICdib29sZWFuJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BhbGxvd0VtcHR5QXJyYXlzYCBvcHRpb24gY2FuIG9ubHkgYmUgYHRydWVgIG9yIGBmYWxzZWAsIHdoZW4gcHJvdmlkZWQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0cy5lbmNvZGVEb3RJbktleXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmVuY29kZURvdEluS2V5cyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYGVuY29kZURvdEluS2V5c2Agb3B0aW9uIGNhbiBvbmx5IGJlIGB0cnVlYCBvciBgZmFsc2VgLCB3aGVuIHByb3ZpZGVkJyk7XG4gIH1cblxuICBpZiAob3B0cy5lbmNvZGVyICE9PSBudWxsICYmIHR5cGVvZiBvcHRzLmVuY29kZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmVuY29kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgY29uc3QgY2hhcnNldCA9IG9wdHMuY2hhcnNldCB8fCBkZWZhdWx0cy5jaGFyc2V0O1xuICBpZiAodHlwZW9mIG9wdHMuY2hhcnNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAndXRmLTgnICYmIG9wdHMuY2hhcnNldCAhPT0gJ2lzby04ODU5LTEnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNoYXJzZXQgb3B0aW9uIG11c3QgYmUgZWl0aGVyIHV0Zi04LCBpc28tODg1OS0xLCBvciB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIGxldCBmb3JtYXQgPSBkZWZhdWx0X2Zvcm1hdDtcbiAgaWYgKHR5cGVvZiBvcHRzLmZvcm1hdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoIWhhcy5jYWxsKGZvcm1hdHRlcnMsIG9wdHMuZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBmb3JtYXQgb3B0aW9uIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICBmb3JtYXQgPSBvcHRzLmZvcm1hdDtcbiAgfVxuICBjb25zdCBmb3JtYXR0ZXIgPSBmb3JtYXR0ZXJzW2Zvcm1hdF07XG5cbiAgbGV0IGZpbHRlciA9IGRlZmF1bHRzLmZpbHRlcjtcbiAgaWYgKHR5cGVvZiBvcHRzLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyB8fCBpc19hcnJheShvcHRzLmZpbHRlcikpIHtcbiAgICBmaWx0ZXIgPSBvcHRzLmZpbHRlcjtcbiAgfVxuXG4gIGxldCBhcnJheUZvcm1hdDogU3RyaW5naWZ5T3B0aW9uc1snYXJyYXlGb3JtYXQnXTtcbiAgaWYgKG9wdHMuYXJyYXlGb3JtYXQgJiYgb3B0cy5hcnJheUZvcm1hdCBpbiBhcnJheV9wcmVmaXhfZ2VuZXJhdG9ycykge1xuICAgIGFycmF5Rm9ybWF0ID0gb3B0cy5hcnJheUZvcm1hdDtcbiAgfSBlbHNlIGlmICgnaW5kaWNlcycgaW4gb3B0cykge1xuICAgIGFycmF5Rm9ybWF0ID0gb3B0cy5pbmRpY2VzID8gJ2luZGljZXMnIDogJ3JlcGVhdCc7XG4gIH0gZWxzZSB7XG4gICAgYXJyYXlGb3JtYXQgPSBkZWZhdWx0cy5hcnJheUZvcm1hdDtcbiAgfVxuXG4gIGlmICgnY29tbWFSb3VuZFRyaXAnIGluIG9wdHMgJiYgdHlwZW9mIG9wdHMuY29tbWFSb3VuZFRyaXAgIT09ICdib29sZWFuJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Bjb21tYVJvdW5kVHJpcGAgbXVzdCBiZSBhIGJvb2xlYW4sIG9yIGFic2VudCcpO1xuICB9XG5cbiAgY29uc3QgYWxsb3dEb3RzID1cbiAgICB0eXBlb2Ygb3B0cy5hbGxvd0RvdHMgPT09ICd1bmRlZmluZWQnID9cbiAgICAgICEhb3B0cy5lbmNvZGVEb3RJbktleXMgPT09IHRydWUgP1xuICAgICAgICB0cnVlXG4gICAgICA6IGRlZmF1bHRzLmFsbG93RG90c1xuICAgIDogISFvcHRzLmFsbG93RG90cztcblxuICByZXR1cm4ge1xuICAgIGFkZFF1ZXJ5UHJlZml4OiB0eXBlb2Ygb3B0cy5hZGRRdWVyeVByZWZpeCA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5hZGRRdWVyeVByZWZpeCA6IGRlZmF1bHRzLmFkZFF1ZXJ5UHJlZml4LFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBhbGxvd0RvdHM6IGFsbG93RG90cyxcbiAgICBhbGxvd0VtcHR5QXJyYXlzOlxuICAgICAgdHlwZW9mIG9wdHMuYWxsb3dFbXB0eUFycmF5cyA9PT0gJ2Jvb2xlYW4nID8gISFvcHRzLmFsbG93RW1wdHlBcnJheXMgOiBkZWZhdWx0cy5hbGxvd0VtcHR5QXJyYXlzLFxuICAgIGFycmF5Rm9ybWF0OiBhcnJheUZvcm1hdCxcbiAgICBjaGFyc2V0OiBjaGFyc2V0LFxuICAgIGNoYXJzZXRTZW50aW5lbDpcbiAgICAgIHR5cGVvZiBvcHRzLmNoYXJzZXRTZW50aW5lbCA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5jaGFyc2V0U2VudGluZWwgOiBkZWZhdWx0cy5jaGFyc2V0U2VudGluZWwsXG4gICAgY29tbWFSb3VuZFRyaXA6ICEhb3B0cy5jb21tYVJvdW5kVHJpcCxcbiAgICBkZWxpbWl0ZXI6IHR5cGVvZiBvcHRzLmRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5kZWxpbWl0ZXIgOiBvcHRzLmRlbGltaXRlcixcbiAgICBlbmNvZGU6IHR5cGVvZiBvcHRzLmVuY29kZSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5lbmNvZGUgOiBkZWZhdWx0cy5lbmNvZGUsXG4gICAgZW5jb2RlRG90SW5LZXlzOlxuICAgICAgdHlwZW9mIG9wdHMuZW5jb2RlRG90SW5LZXlzID09PSAnYm9vbGVhbicgPyBvcHRzLmVuY29kZURvdEluS2V5cyA6IGRlZmF1bHRzLmVuY29kZURvdEluS2V5cyxcbiAgICBlbmNvZGVyOiB0eXBlb2Ygb3B0cy5lbmNvZGVyID09PSAnZnVuY3Rpb24nID8gb3B0cy5lbmNvZGVyIDogZGVmYXVsdHMuZW5jb2RlcixcbiAgICBlbmNvZGVWYWx1ZXNPbmx5OlxuICAgICAgdHlwZW9mIG9wdHMuZW5jb2RlVmFsdWVzT25seSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5lbmNvZGVWYWx1ZXNPbmx5IDogZGVmYXVsdHMuZW5jb2RlVmFsdWVzT25seSxcbiAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcbiAgICBzZXJpYWxpemVEYXRlOiB0eXBlb2Ygb3B0cy5zZXJpYWxpemVEYXRlID09PSAnZnVuY3Rpb24nID8gb3B0cy5zZXJpYWxpemVEYXRlIDogZGVmYXVsdHMuc2VyaWFsaXplRGF0ZSxcbiAgICBza2lwTnVsbHM6IHR5cGVvZiBvcHRzLnNraXBOdWxscyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5za2lwTnVsbHMgOiBkZWZhdWx0cy5za2lwTnVsbHMsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHNvcnQ6IHR5cGVvZiBvcHRzLnNvcnQgPT09ICdmdW5jdGlvbicgPyBvcHRzLnNvcnQgOiBudWxsLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzpcbiAgICAgIHR5cGVvZiBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgOiBkZWZhdWx0cy5zdHJpY3ROdWxsSGFuZGxpbmcsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkob2JqZWN0OiBhbnksIG9wdHM6IFN0cmluZ2lmeU9wdGlvbnMgPSB7fSkge1xuICBsZXQgb2JqID0gb2JqZWN0O1xuICBjb25zdCBvcHRpb25zID0gbm9ybWFsaXplX3N0cmluZ2lmeV9vcHRpb25zKG9wdHMpO1xuXG4gIGxldCBvYmpfa2V5czogUHJvcGVydHlLZXlbXSB8IHVuZGVmaW5lZDtcbiAgbGV0IGZpbHRlcjtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgb2JqID0gZmlsdGVyKCcnLCBvYmopO1xuICB9IGVsc2UgaWYgKGlzX2FycmF5KG9wdGlvbnMuZmlsdGVyKSkge1xuICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgIG9ial9rZXlzID0gZmlsdGVyO1xuICB9XG5cbiAgY29uc3Qga2V5czogc3RyaW5nW10gPSBbXTtcblxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgY29uc3QgZ2VuZXJhdGVBcnJheVByZWZpeCA9IGFycmF5X3ByZWZpeF9nZW5lcmF0b3JzW29wdGlvbnMuYXJyYXlGb3JtYXRdO1xuICBjb25zdCBjb21tYVJvdW5kVHJpcCA9IGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgb3B0aW9ucy5jb21tYVJvdW5kVHJpcDtcblxuICBpZiAoIW9ial9rZXlzKSB7XG4gICAgb2JqX2tleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgIG9ial9rZXlzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgfVxuXG4gIGNvbnN0IHNpZGVDaGFubmVsID0gbmV3IFdlYWtNYXAoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmpfa2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGtleSA9IG9ial9rZXlzW2ldITtcblxuICAgIGlmIChvcHRpb25zLnNraXBOdWxscyAmJiBvYmpba2V5XSA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHB1c2hfdG9fYXJyYXkoXG4gICAgICBrZXlzLFxuICAgICAgaW5uZXJfc3RyaW5naWZ5KFxuICAgICAgICBvYmpba2V5XSxcbiAgICAgICAga2V5LFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgICAgIGNvbW1hUm91bmRUcmlwLFxuICAgICAgICBvcHRpb25zLmFsbG93RW1wdHlBcnJheXMsXG4gICAgICAgIG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICBvcHRpb25zLnNraXBOdWxscyxcbiAgICAgICAgb3B0aW9ucy5lbmNvZGVEb3RJbktleXMsXG4gICAgICAgIG9wdGlvbnMuZW5jb2RlID8gb3B0aW9ucy5lbmNvZGVyIDogbnVsbCxcbiAgICAgICAgb3B0aW9ucy5maWx0ZXIsXG4gICAgICAgIG9wdGlvbnMuc29ydCxcbiAgICAgICAgb3B0aW9ucy5hbGxvd0RvdHMsXG4gICAgICAgIG9wdGlvbnMuc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgb3B0aW9ucy5mb3JtYXQsXG4gICAgICAgIG9wdGlvbnMuZm9ybWF0dGVyLFxuICAgICAgICBvcHRpb25zLmVuY29kZVZhbHVlc09ubHksXG4gICAgICAgIG9wdGlvbnMuY2hhcnNldCxcbiAgICAgICAgc2lkZUNoYW5uZWwsXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBqb2luZWQgPSBrZXlzLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIpO1xuICBsZXQgcHJlZml4ID0gb3B0aW9ucy5hZGRRdWVyeVByZWZpeCA9PT0gdHJ1ZSA/ICc/JyA6ICcnO1xuXG4gIGlmIChvcHRpb25zLmNoYXJzZXRTZW50aW5lbCkge1xuICAgIGlmIChvcHRpb25zLmNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCcmIzEwMDAzOycpLCB0aGUgXCJudW1lcmljIGVudGl0eVwiIHJlcHJlc2VudGF0aW9uIG9mIGEgY2hlY2ttYXJrXG4gICAgICBwcmVmaXggKz0gJ3V0Zjg9JTI2JTIzMTAwMDMlM0ImJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCdcdTI3MTMnKVxuICAgICAgcHJlZml4ICs9ICd1dGY4PSVFMiU5QyU5MyYnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBqb2luZWQubGVuZ3RoID4gMCA/IHByZWZpeCArIGpvaW5lZCA6ICcnO1xufVxuIiwgImV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzQuNzkuMSc7IC8vIHgtcmVsZWFzZS1wbGVhc2UtdmVyc2lvblxuIiwgIi8qKlxuICogRGlzY2xhaW1lcjogbW9kdWxlcyBpbiBfc2hpbXMgYXJlbid0IGludGVuZGVkIHRvIGJlIGltcG9ydGVkIGJ5IFNESyB1c2Vycy5cbiAqL1xuaW1wb3J0IHsgdHlwZSBSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uL2NvcmUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNoaW1zIHtcbiAga2luZDogc3RyaW5nO1xuICBmZXRjaDogYW55O1xuICBSZXF1ZXN0OiBhbnk7XG4gIFJlc3BvbnNlOiBhbnk7XG4gIEhlYWRlcnM6IGFueTtcbiAgRm9ybURhdGE6IGFueTtcbiAgQmxvYjogYW55O1xuICBGaWxlOiBhbnk7XG4gIFJlYWRhYmxlU3RyZWFtOiBhbnk7XG4gIGdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zOiA8VCA9IFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgICBmb3JtOiBTaGltc1snRm9ybURhdGEnXSxcbiAgICBvcHRzOiBSZXF1ZXN0T3B0aW9uczxUPixcbiAgKSA9PiBQcm9taXNlPFJlcXVlc3RPcHRpb25zPFQ+PjtcbiAgZ2V0RGVmYXVsdEFnZW50OiAodXJsOiBzdHJpbmcpID0+IGFueTtcbiAgZmlsZUZyb21QYXRoOlxuICAgIHwgKChwYXRoOiBzdHJpbmcsIGZpbGVuYW1lPzogc3RyaW5nLCBvcHRpb25zPzoge30pID0+IFByb21pc2U8U2hpbXNbJ0ZpbGUnXT4pXG4gICAgfCAoKHBhdGg6IHN0cmluZywgb3B0aW9ucz86IHt9KSA9PiBQcm9taXNlPFNoaW1zWydGaWxlJ10+KTtcbiAgaXNGc1JlYWRTdHJlYW06ICh2YWx1ZTogYW55KSA9PiBib29sZWFuO1xufVxuXG5leHBvcnQgbGV0IGF1dG8gPSBmYWxzZTtcbmV4cG9ydCBsZXQga2luZDogU2hpbXNbJ2tpbmQnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgZmV0Y2g6IFNoaW1zWydmZXRjaCddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBSZXF1ZXN0OiBTaGltc1snUmVxdWVzdCddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBSZXNwb25zZTogU2hpbXNbJ1Jlc3BvbnNlJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IEhlYWRlcnM6IFNoaW1zWydIZWFkZXJzJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IEZvcm1EYXRhOiBTaGltc1snRm9ybURhdGEnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgQmxvYjogU2hpbXNbJ0Jsb2InXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgRmlsZTogU2hpbXNbJ0ZpbGUnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgUmVhZGFibGVTdHJlYW06IFNoaW1zWydSZWFkYWJsZVN0cmVhbSddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9uczogU2hpbXNbJ2dldE11bHRpcGFydFJlcXVlc3RPcHRpb25zJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGdldERlZmF1bHRBZ2VudDogU2hpbXNbJ2dldERlZmF1bHRBZ2VudCddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBmaWxlRnJvbVBhdGg6IFNoaW1zWydmaWxlRnJvbVBhdGgnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgaXNGc1JlYWRTdHJlYW06IFNoaW1zWydpc0ZzUmVhZFN0cmVhbSddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0U2hpbXMoc2hpbXM6IFNoaW1zLCBvcHRpb25zOiB7IGF1dG86IGJvb2xlYW4gfSA9IHsgYXV0bzogZmFsc2UgfSkge1xuICBpZiAoYXV0bykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGB5b3UgbXVzdCBcXGBpbXBvcnQgJ29wZW5haS9zaGltcy8ke3NoaW1zLmtpbmR9J1xcYCBiZWZvcmUgaW1wb3J0aW5nIGFueXRoaW5nIGVsc2UgZnJvbSBvcGVuYWlgLFxuICAgICk7XG4gIH1cbiAgaWYgKGtpbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbid0IFxcYGltcG9ydCAnb3BlbmFpL3NoaW1zLyR7c2hpbXMua2luZH0nXFxgIGFmdGVyIFxcYGltcG9ydCAnb3BlbmFpL3NoaW1zLyR7a2luZH0nXFxgYCk7XG4gIH1cbiAgYXV0byA9IG9wdGlvbnMuYXV0bztcbiAga2luZCA9IHNoaW1zLmtpbmQ7XG4gIGZldGNoID0gc2hpbXMuZmV0Y2g7XG4gIFJlcXVlc3QgPSBzaGltcy5SZXF1ZXN0O1xuICBSZXNwb25zZSA9IHNoaW1zLlJlc3BvbnNlO1xuICBIZWFkZXJzID0gc2hpbXMuSGVhZGVycztcbiAgRm9ybURhdGEgPSBzaGltcy5Gb3JtRGF0YTtcbiAgQmxvYiA9IHNoaW1zLkJsb2I7XG4gIEZpbGUgPSBzaGltcy5GaWxlO1xuICBSZWFkYWJsZVN0cmVhbSA9IHNoaW1zLlJlYWRhYmxlU3RyZWFtO1xuICBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucyA9IHNoaW1zLmdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zO1xuICBnZXREZWZhdWx0QWdlbnQgPSBzaGltcy5nZXREZWZhdWx0QWdlbnQ7XG4gIGZpbGVGcm9tUGF0aCA9IHNoaW1zLmZpbGVGcm9tUGF0aDtcbiAgaXNGc1JlYWRTdHJlYW0gPSBzaGltcy5pc0ZzUmVhZFN0cmVhbTtcbn1cbiIsICIvKipcbiAqIERpc2NsYWltZXI6IG1vZHVsZXMgaW4gX3NoaW1zIGFyZW4ndCBpbnRlbmRlZCB0byBiZSBpbXBvcnRlZCBieSBTREsgdXNlcnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNdWx0aXBhcnRCb2R5IHtcbiAgY29uc3RydWN0b3IocHVibGljIGJvZHk6IGFueSkge31cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdNdWx0aXBhcnRCb2R5JztcbiAgfVxufVxuIiwgIi8qKlxuICogRGlzY2xhaW1lcjogbW9kdWxlcyBpbiBfc2hpbXMgYXJlbid0IGludGVuZGVkIHRvIGJlIGltcG9ydGVkIGJ5IFNESyB1c2Vycy5cbiAqL1xuaW1wb3J0IHsgTXVsdGlwYXJ0Qm9keSB9IGZyb20gJy4vTXVsdGlwYXJ0Qm9keSc7XG5pbXBvcnQgeyB0eXBlIFJlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgeyB0eXBlIFNoaW1zIH0gZnJvbSAnLi9yZWdpc3RyeSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdW50aW1lKHsgbWFudWFsbHlJbXBvcnRlZCB9OiB7IG1hbnVhbGx5SW1wb3J0ZWQ/OiBib29sZWFuIH0gPSB7fSk6IFNoaW1zIHtcbiAgY29uc3QgcmVjb21tZW5kYXRpb24gPVxuICAgIG1hbnVhbGx5SW1wb3J0ZWQgP1xuICAgICAgYFlvdSBtYXkgbmVlZCB0byB1c2UgcG9seWZpbGxzYFxuICAgIDogYEFkZCBvbmUgb2YgdGhlc2UgaW1wb3J0cyBiZWZvcmUgeW91ciBmaXJzdCBcXGBpbXBvcnQgXHUyMDI2IGZyb20gJ29wZW5haSdcXGA6XG4tIFxcYGltcG9ydCAnb3BlbmFpL3NoaW1zL25vZGUnXFxgIChpZiB5b3UncmUgcnVubmluZyBvbiBOb2RlKVxuLSBcXGBpbXBvcnQgJ29wZW5haS9zaGltcy93ZWInXFxgIChvdGhlcndpc2UpXG5gO1xuXG4gIGxldCBfZmV0Y2gsIF9SZXF1ZXN0LCBfUmVzcG9uc2UsIF9IZWFkZXJzO1xuICB0cnkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBfZmV0Y2ggPSBmZXRjaDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgX1JlcXVlc3QgPSBSZXF1ZXN0O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBfUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgX0hlYWRlcnMgPSBIZWFkZXJzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGB0aGlzIGVudmlyb25tZW50IGlzIG1pc3NpbmcgdGhlIGZvbGxvd2luZyBXZWIgRmV0Y2ggQVBJIHR5cGU6ICR7XG4gICAgICAgIChlcnJvciBhcyBhbnkpLm1lc3NhZ2VcbiAgICAgIH0uICR7cmVjb21tZW5kYXRpb259YCxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnd2ViJyxcbiAgICBmZXRjaDogX2ZldGNoLFxuICAgIFJlcXVlc3Q6IF9SZXF1ZXN0LFxuICAgIFJlc3BvbnNlOiBfUmVzcG9uc2UsXG4gICAgSGVhZGVyczogX0hlYWRlcnMsXG4gICAgRm9ybURhdGE6XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnID8gRm9ybURhdGEgOiAoXG4gICAgICAgIGNsYXNzIEZvcm1EYXRhIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBmaWxlIHVwbG9hZHMgYXJlbid0IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50IHlldCBhcyAnRm9ybURhdGEnIGlzIHVuZGVmaW5lZC4gJHtyZWNvbW1lbmRhdGlvbn1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgQmxvYjpcbiAgICAgIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyA/IEJsb2IgOiAoXG4gICAgICAgIGNsYXNzIEJsb2Ige1xuICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgZmlsZSB1cGxvYWRzIGFyZW4ndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCB5ZXQgYXMgJ0Jsb2InIGlzIHVuZGVmaW5lZC4gJHtyZWNvbW1lbmRhdGlvbn1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgRmlsZTpcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyA/IEZpbGUgOiAoXG4gICAgICAgIGNsYXNzIEZpbGUge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYGZpbGUgdXBsb2FkcyBhcmVuJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQgeWV0IGFzICdGaWxlJyBpcyB1bmRlZmluZWQuICR7cmVjb21tZW5kYXRpb259YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgIFJlYWRhYmxlU3RyZWFtOlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdHlwZW9mIFJlYWRhYmxlU3RyZWFtICE9PSAndW5kZWZpbmVkJyA/IFJlYWRhYmxlU3RyZWFtIDogKFxuICAgICAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgc3RyZWFtaW5nIGlzbid0IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50IHlldCBhcyAnUmVhZGFibGVTdHJlYW0nIGlzIHVuZGVmaW5lZC4gJHtyZWNvbW1lbmRhdGlvbn1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnM6IGFzeW5jIDxUID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZm9ybTogRm9ybURhdGEsXG4gICAgICBvcHRzOiBSZXF1ZXN0T3B0aW9uczxUPixcbiAgICApOiBQcm9taXNlPFJlcXVlc3RPcHRpb25zPFQ+PiA9PiAoe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGJvZHk6IG5ldyBNdWx0aXBhcnRCb2R5KGZvcm0pIGFzIGFueSxcbiAgICB9KSxcbiAgICBnZXREZWZhdWx0QWdlbnQ6ICh1cmw6IHN0cmluZykgPT4gdW5kZWZpbmVkLFxuICAgIGZpbGVGcm9tUGF0aDogKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIGBmaWxlRnJvbVBhdGhgIGZ1bmN0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGluIE5vZGUuIFNlZSB0aGUgUkVBRE1FIGZvciBtb3JlIGRldGFpbHM6IGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlI2ZpbGUtdXBsb2FkcycsXG4gICAgICApO1xuICAgIH0sXG4gICAgaXNGc1JlYWRTdHJlYW06ICh2YWx1ZTogYW55KSA9PiBmYWxzZSxcbiAgfTtcbn1cbiIsICIvKipcbiAqIERpc2NsYWltZXI6IG1vZHVsZXMgaW4gX3NoaW1zIGFyZW4ndCBpbnRlbmRlZCB0byBiZSBpbXBvcnRlZCBieSBTREsgdXNlcnMuXG4gKi9cbmltcG9ydCAqIGFzIHNoaW1zIGZyb20gJy4vcmVnaXN0cnkubWpzJztcbmltcG9ydCAqIGFzIGF1dG8gZnJvbSAnb3BlbmFpL19zaGltcy9hdXRvL3J1bnRpbWUnO1xuaWYgKCFzaGltcy5raW5kKSBzaGltcy5zZXRTaGltcyhhdXRvLmdldFJ1bnRpbWUoKSwgeyBhdXRvOiB0cnVlIH0pO1xuZXhwb3J0ICogZnJvbSAnLi9yZWdpc3RyeS5tanMnO1xuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IGNhc3RUb0Vycm9yLCBIZWFkZXJzIH0gZnJvbSAnLi9jb3JlJztcblxuZXhwb3J0IGNsYXNzIE9wZW5BSUVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuZXhwb3J0IGNsYXNzIEFQSUVycm9yPFxuICBUU3RhdHVzIGV4dGVuZHMgbnVtYmVyIHwgdW5kZWZpbmVkID0gbnVtYmVyIHwgdW5kZWZpbmVkLFxuICBUSGVhZGVycyBleHRlbmRzIEhlYWRlcnMgfCB1bmRlZmluZWQgPSBIZWFkZXJzIHwgdW5kZWZpbmVkLFxuICBURXJyb3IgZXh0ZW5kcyBPYmplY3QgfCB1bmRlZmluZWQgPSBPYmplY3QgfCB1bmRlZmluZWQsXG4+IGV4dGVuZHMgT3BlbkFJRXJyb3Ige1xuICAvKiogSFRUUCBzdGF0dXMgZm9yIHRoZSByZXNwb25zZSB0aGF0IGNhdXNlZCB0aGUgZXJyb3IgKi9cbiAgcmVhZG9ubHkgc3RhdHVzOiBUU3RhdHVzO1xuICAvKiogSFRUUCBoZWFkZXJzIGZvciB0aGUgcmVzcG9uc2UgdGhhdCBjYXVzZWQgdGhlIGVycm9yICovXG4gIHJlYWRvbmx5IGhlYWRlcnM6IFRIZWFkZXJzO1xuICAvKiogSlNPTiBib2R5IG9mIHRoZSByZXNwb25zZSB0aGF0IGNhdXNlZCB0aGUgZXJyb3IgKi9cbiAgcmVhZG9ubHkgZXJyb3I6IFRFcnJvcjtcblxuICByZWFkb25seSBjb2RlOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xuICByZWFkb25seSBwYXJhbTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIHJlYWRvbmx5IHJlcXVlc3RfaWQ6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3Ioc3RhdHVzOiBUU3RhdHVzLCBlcnJvcjogVEVycm9yLCBtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGhlYWRlcnM6IFRIZWFkZXJzKSB7XG4gICAgc3VwZXIoYCR7QVBJRXJyb3IubWFrZU1lc3NhZ2Uoc3RhdHVzLCBlcnJvciwgbWVzc2FnZSl9YCk7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLnJlcXVlc3RfaWQgPSBoZWFkZXJzPy5bJ3gtcmVxdWVzdC1pZCddO1xuICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcblxuICAgIGNvbnN0IGRhdGEgPSBlcnJvciBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIHRoaXMuY29kZSA9IGRhdGE/LlsnY29kZSddO1xuICAgIHRoaXMucGFyYW0gPSBkYXRhPy5bJ3BhcmFtJ107XG4gICAgdGhpcy50eXBlID0gZGF0YT8uWyd0eXBlJ107XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBtYWtlTWVzc2FnZShzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZCwgZXJyb3I6IGFueSwgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbXNnID1cbiAgICAgIGVycm9yPy5tZXNzYWdlID9cbiAgICAgICAgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnID9cbiAgICAgICAgICBlcnJvci5tZXNzYWdlXG4gICAgICAgIDogSlNPTi5zdHJpbmdpZnkoZXJyb3IubWVzc2FnZSlcbiAgICAgIDogZXJyb3IgPyBKU09OLnN0cmluZ2lmeShlcnJvcilcbiAgICAgIDogbWVzc2FnZTtcblxuICAgIGlmIChzdGF0dXMgJiYgbXNnKSB7XG4gICAgICByZXR1cm4gYCR7c3RhdHVzfSAke21zZ31gO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzKSB7XG4gICAgICByZXR1cm4gYCR7c3RhdHVzfSBzdGF0dXMgY29kZSAobm8gYm9keSlgO1xuICAgIH1cbiAgICBpZiAobXNnKSB7XG4gICAgICByZXR1cm4gbXNnO1xuICAgIH1cbiAgICByZXR1cm4gJyhubyBzdGF0dXMgY29kZSBvciBib2R5KSc7XG4gIH1cblxuICBzdGF0aWMgZ2VuZXJhdGUoXG4gICAgc3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gICAgZXJyb3JSZXNwb25zZTogT2JqZWN0IHwgdW5kZWZpbmVkLFxuICAgIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBoZWFkZXJzOiBIZWFkZXJzIHwgdW5kZWZpbmVkLFxuICApOiBBUElFcnJvciB7XG4gICAgaWYgKCFzdGF0dXMgfHwgIWhlYWRlcnMpIHtcbiAgICAgIHJldHVybiBuZXcgQVBJQ29ubmVjdGlvbkVycm9yKHsgbWVzc2FnZSwgY2F1c2U6IGNhc3RUb0Vycm9yKGVycm9yUmVzcG9uc2UpIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGVycm9yID0gKGVycm9yUmVzcG9uc2UgYXMgUmVjb3JkPHN0cmluZywgYW55Pik/LlsnZXJyb3InXTtcblxuICAgIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgICAgcmV0dXJuIG5ldyBCYWRSZXF1ZXN0RXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICByZXR1cm4gbmV3IFBlcm1pc3Npb25EZW5pZWRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIHJldHVybiBuZXcgTm90Rm91bmRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MDkpIHtcbiAgICAgIHJldHVybiBuZXcgQ29uZmxpY3RFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MjIpIHtcbiAgICAgIHJldHVybiBuZXcgVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IDQyOSkge1xuICAgICAgcmV0dXJuIG5ldyBSYXRlTGltaXRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID49IDUwMCkge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbFNlcnZlckVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQVBJRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFQSVVzZXJBYm9ydEVycm9yIGV4dGVuZHMgQVBJRXJyb3I8dW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZD4ge1xuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfTogeyBtZXNzYWdlPzogc3RyaW5nIH0gPSB7fSkge1xuICAgIHN1cGVyKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBtZXNzYWdlIHx8ICdSZXF1ZXN0IHdhcyBhYm9ydGVkLicsIHVuZGVmaW5lZCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFQSUNvbm5lY3Rpb25FcnJvciBleHRlbmRzIEFQSUVycm9yPHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQ+IHtcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlLCBjYXVzZSB9OiB7IG1lc3NhZ2U/OiBzdHJpbmcgfCB1bmRlZmluZWQ7IGNhdXNlPzogRXJyb3IgfCB1bmRlZmluZWQgfSkge1xuICAgIHN1cGVyKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBtZXNzYWdlIHx8ICdDb25uZWN0aW9uIGVycm9yLicsIHVuZGVmaW5lZCk7XG4gICAgLy8gaW4gc29tZSBlbnZpcm9ubWVudHMgdGhlICdjYXVzZScgcHJvcGVydHkgaXMgYWxyZWFkeSBkZWNsYXJlZFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoY2F1c2UpIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvciBleHRlbmRzIEFQSUNvbm5lY3Rpb25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9OiB7IG1lc3NhZ2U/OiBzdHJpbmcgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBtZXNzYWdlOiBtZXNzYWdlID8/ICdSZXF1ZXN0IHRpbWVkIG91dC4nIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCYWRSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBBUElFcnJvcjw0MDAsIEhlYWRlcnM+IHt9XG5cbmV4cG9ydCBjbGFzcyBBdXRoZW50aWNhdGlvbkVycm9yIGV4dGVuZHMgQVBJRXJyb3I8NDAxLCBIZWFkZXJzPiB7fVxuXG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbkRlbmllZEVycm9yIGV4dGVuZHMgQVBJRXJyb3I8NDAzLCBIZWFkZXJzPiB7fVxuXG5leHBvcnQgY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIEFQSUVycm9yPDQwNCwgSGVhZGVycz4ge31cblxuZXhwb3J0IGNsYXNzIENvbmZsaWN0RXJyb3IgZXh0ZW5kcyBBUElFcnJvcjw0MDksIEhlYWRlcnM+IHt9XG5cbmV4cG9ydCBjbGFzcyBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IgZXh0ZW5kcyBBUElFcnJvcjw0MjIsIEhlYWRlcnM+IHt9XG5cbmV4cG9ydCBjbGFzcyBSYXRlTGltaXRFcnJvciBleHRlbmRzIEFQSUVycm9yPDQyOSwgSGVhZGVycz4ge31cblxuZXhwb3J0IGNsYXNzIEludGVybmFsU2VydmVyRXJyb3IgZXh0ZW5kcyBBUElFcnJvcjxudW1iZXIsIEhlYWRlcnM+IHt9XG5cbmV4cG9ydCBjbGFzcyBMZW5ndGhGaW5pc2hSZWFzb25FcnJvciBleHRlbmRzIE9wZW5BSUVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYENvdWxkIG5vdCBwYXJzZSByZXNwb25zZSBjb250ZW50IGFzIHRoZSBsZW5ndGggbGltaXQgd2FzIHJlYWNoZWRgKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ29udGVudEZpbHRlckZpbmlzaFJlYXNvbkVycm9yIGV4dGVuZHMgT3BlbkFJRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihgQ291bGQgbm90IHBhcnNlIHJlc3BvbnNlIGNvbnRlbnQgYXMgdGhlIHJlcXVlc3Qgd2FzIHJlamVjdGVkIGJ5IHRoZSBjb250ZW50IGZpbHRlcmApO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgT3BlbkFJRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcic7XG5cbnR5cGUgQnl0ZXMgPSBzdHJpbmcgfCBBcnJheUJ1ZmZlciB8IFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgcmUtaW1wbGVtZW50YXRpb24gb2YgaHR0cHgncyBgTGluZURlY29kZXJgIGluIFB5dGhvbiB0aGF0IGhhbmRsZXMgaW5jcmVtZW50YWxseVxuICogcmVhZGluZyBsaW5lcyBmcm9tIHRleHQuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2VuY29kZS9odHRweC9ibG9iLzkyMDMzM2VhOTgxMThlOWNmNjE3ZjI0NjkwNWQ3YjIwMjUxMDk0MWMvaHR0cHgvX2RlY29kZXJzLnB5I0wyNThcbiAqL1xuZXhwb3J0IGNsYXNzIExpbmVEZWNvZGVyIHtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHN0YXRpYyBORVdMSU5FX0NIQVJTID0gbmV3IFNldChbJ1xcbicsICdcXHInXSk7XG4gIHN0YXRpYyBORVdMSU5FX1JFR0VYUCA9IC9cXHJcXG58W1xcblxccl0vZztcblxuICBidWZmZXI6IHN0cmluZ1tdO1xuICB0cmFpbGluZ0NSOiBib29sZWFuO1xuICB0ZXh0RGVjb2RlcjogYW55OyAvLyBUZXh0RGVjb2RlciBmb3VuZCBpbiBicm93c2Vyczsgbm90IHR5cGVkIHRvIGF2b2lkIHB1bGxpbmcgaW4gZWl0aGVyIFwiZG9tXCIgb3IgXCJub2RlXCIgdHlwZXMuXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB0aGlzLnRyYWlsaW5nQ1IgPSBmYWxzZTtcbiAgfVxuXG4gIGRlY29kZShjaHVuazogQnl0ZXMpOiBzdHJpbmdbXSB7XG4gICAgbGV0IHRleHQgPSB0aGlzLmRlY29kZVRleHQoY2h1bmspO1xuXG4gICAgaWYgKHRoaXMudHJhaWxpbmdDUikge1xuICAgICAgdGV4dCA9ICdcXHInICsgdGV4dDtcbiAgICAgIHRoaXMudHJhaWxpbmdDUiA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGV4dC5lbmRzV2l0aCgnXFxyJykpIHtcbiAgICAgIHRoaXMudHJhaWxpbmdDUiA9IHRydWU7XG4gICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgfVxuXG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgdHJhaWxpbmdOZXdsaW5lID0gTGluZURlY29kZXIuTkVXTElORV9DSEFSUy5oYXModGV4dFt0ZXh0Lmxlbmd0aCAtIDFdIHx8ICcnKTtcbiAgICBsZXQgbGluZXMgPSB0ZXh0LnNwbGl0KExpbmVEZWNvZGVyLk5FV0xJTkVfUkVHRVhQKTtcblxuICAgIC8vIGlmIHRoZXJlIGlzIGEgdHJhaWxpbmcgbmV3IGxpbmUgdGhlbiB0aGUgbGFzdCBlbnRyeSB3aWxsIGJlIGFuIGVtcHR5XG4gICAgLy8gc3RyaW5nIHdoaWNoIHdlIGRvbid0IGNhcmUgYWJvdXRcbiAgICBpZiAodHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICBsaW5lcy5wb3AoKTtcbiAgICB9XG5cbiAgICBpZiAobGluZXMubGVuZ3RoID09PSAxICYmICF0cmFpbGluZ05ld2xpbmUpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2gobGluZXNbMF0hKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgbGluZXMgPSBbdGhpcy5idWZmZXIuam9pbignJykgKyBsaW5lc1swXSwgLi4ubGluZXMuc2xpY2UoMSldO1xuICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoIXRyYWlsaW5nTmV3bGluZSkge1xuICAgICAgdGhpcy5idWZmZXIgPSBbbGluZXMucG9wKCkgfHwgJyddO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuXG4gIGRlY29kZVRleHQoYnl0ZXM6IEJ5dGVzKTogc3RyaW5nIHtcbiAgICBpZiAoYnl0ZXMgPT0gbnVsbCkgcmV0dXJuICcnO1xuICAgIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSByZXR1cm4gYnl0ZXM7XG5cbiAgICAvLyBOb2RlOlxuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBieXRlcy50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMpLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihcbiAgICAgICAgYFVuZXhwZWN0ZWQ6IHJlY2VpdmVkIG5vbi1VaW50OEFycmF5ICgke2J5dGVzLmNvbnN0cnVjdG9yLm5hbWV9KSBzdHJlYW0gY2h1bmsgaW4gYW4gZW52aXJvbm1lbnQgd2l0aCBhIGdsb2JhbCBcIkJ1ZmZlclwiIGRlZmluZWQsIHdoaWNoIHRoaXMgbGlicmFyeSBhc3N1bWVzIHRvIGJlIE5vZGUuIFBsZWFzZSByZXBvcnQgdGhpcyBlcnJvci5gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBCcm93c2VyXG4gICAgaWYgKHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgYnl0ZXMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICB0aGlzLnRleHREZWNvZGVyID8/PSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dERlY29kZXIuZGVjb2RlKGJ5dGVzKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZDogcmVjZWl2ZWQgbm9uLVVpbnQ4QXJyYXkvQXJyYXlCdWZmZXIgKCR7XG4gICAgICAgICAgKGJ5dGVzIGFzIGFueSkuY29uc3RydWN0b3IubmFtZVxuICAgICAgICB9KSBpbiBhIHdlYiBwbGF0Zm9ybS4gUGxlYXNlIHJlcG9ydCB0aGlzIGVycm9yLmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihcbiAgICAgIGBVbmV4cGVjdGVkOiBuZWl0aGVyIEJ1ZmZlciBub3IgVGV4dERlY29kZXIgYXJlIGF2YWlsYWJsZSBhcyBnbG9iYWxzLiBQbGVhc2UgcmVwb3J0IHRoaXMgZXJyb3IuYCxcbiAgICApO1xuICB9XG5cbiAgZmx1c2goKTogc3RyaW5nW10ge1xuICAgIGlmICghdGhpcy5idWZmZXIubGVuZ3RoICYmICF0aGlzLnRyYWlsaW5nQ1IpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBsaW5lcyA9IFt0aGlzLmJ1ZmZlci5qb2luKCcnKV07XG4gICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB0aGlzLnRyYWlsaW5nQ1IgPSBmYWxzZTtcbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBSZWFkYWJsZVN0cmVhbSwgdHlwZSBSZXNwb25zZSB9IGZyb20gJy4vX3NoaW1zL2luZGV4JztcbmltcG9ydCB7IE9wZW5BSUVycm9yIH0gZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQgeyBMaW5lRGVjb2RlciB9IGZyb20gJy4vaW50ZXJuYWwvZGVjb2RlcnMvbGluZSc7XG5cbmltcG9ydCB7IEFQSUVycm9yIH0gZnJvbSAnLi9lcnJvcic7XG5cbnR5cGUgQnl0ZXMgPSBzdHJpbmcgfCBBcnJheUJ1ZmZlciB8IFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG5leHBvcnQgdHlwZSBTZXJ2ZXJTZW50RXZlbnQgPSB7XG4gIGV2ZW50OiBzdHJpbmcgfCBudWxsO1xuICBkYXRhOiBzdHJpbmc7XG4gIHJhdzogc3RyaW5nW107XG59O1xuXG5leHBvcnQgY2xhc3MgU3RyZWFtPEl0ZW0+IGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZTxJdGVtPiB7XG4gIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGl0ZXJhdG9yOiAoKSA9PiBBc3luY0l0ZXJhdG9yPEl0ZW0+LFxuICAgIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcixcbiAgKSB7XG4gICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU1NFUmVzcG9uc2U8SXRlbT4ocmVzcG9uc2U6IFJlc3BvbnNlLCBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIpOiBTdHJlYW08SXRlbT4ge1xuICAgIGxldCBjb25zdW1lZCA9IGZhbHNlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24qIGl0ZXJhdG9yKCk6IEFzeW5jSXRlcmF0b3I8SXRlbSwgYW55LCB1bmRlZmluZWQ+IHtcbiAgICAgIGlmIChjb25zdW1lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpdGVyYXRlIG92ZXIgYSBjb25zdW1lZCBzdHJlYW0sIHVzZSBgLnRlZSgpYCB0byBzcGxpdCB0aGUgc3RyZWFtLicpO1xuICAgICAgfVxuICAgICAgY29uc3VtZWQgPSB0cnVlO1xuICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3Qgc3NlIG9mIF9pdGVyU1NFTWVzc2FnZXMocmVzcG9uc2UsIGNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgaWYgKGRvbmUpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgaWYgKHNzZS5kYXRhLnN0YXJ0c1dpdGgoJ1tET05FXScpKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzc2UuZXZlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShzc2UuZGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBwYXJzZSBtZXNzYWdlIGludG8gSlNPTjpgLCBzc2UuZGF0YSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZyb20gY2h1bms6YCwgc3NlLnJhdyk7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKHVuZGVmaW5lZCwgZGF0YS5lcnJvciwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB5aWVsZCBkYXRhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHNzZS5kYXRhKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IHBhcnNlIG1lc3NhZ2UgaW50byBKU09OOmAsIHNzZS5kYXRhKTtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRnJvbSBjaHVuazpgLCBzc2UucmF3KTtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IElzIHRoaXMgd2hlcmUgdGhlIGVycm9yIHNob3VsZCBiZSB0aHJvd24/XG4gICAgICAgICAgICBpZiAoc3NlLmV2ZW50ID09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKHVuZGVmaW5lZCwgZGF0YS5lcnJvciwgZGF0YS5tZXNzYWdlLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgeyBldmVudDogc3NlLmV2ZW50LCBkYXRhOiBkYXRhIH0gYXMgYW55O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgY2FsbHMgYHN0cmVhbS5jb250cm9sbGVyLmFib3J0KClgLCB3ZSBzaG91bGQgZXhpdCB3aXRob3V0IHRocm93aW5nLlxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSByZXR1cm47XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBgYnJlYWtgcywgYWJvcnQgdGhlIG9uZ29pbmcgcmVxdWVzdC5cbiAgICAgICAgaWYgKCFkb25lKSBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTdHJlYW0oaXRlcmF0b3IsIGNvbnRyb2xsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIFN0cmVhbSBmcm9tIGEgbmV3bGluZS1zZXBhcmF0ZWQgUmVhZGFibGVTdHJlYW1cbiAgICogd2hlcmUgZWFjaCBpdGVtIGlzIGEgSlNPTiB2YWx1ZS5cbiAgICovXG4gIHN0YXRpYyBmcm9tUmVhZGFibGVTdHJlYW08SXRlbT4ocmVhZGFibGVTdHJlYW06IFJlYWRhYmxlU3RyZWFtLCBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIpOiBTdHJlYW08SXRlbT4ge1xuICAgIGxldCBjb25zdW1lZCA9IGZhbHNlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24qIGl0ZXJMaW5lcygpOiBBc3luY0dlbmVyYXRvcjxzdHJpbmcsIHZvaWQsIHVua25vd24+IHtcbiAgICAgIGNvbnN0IGxpbmVEZWNvZGVyID0gbmV3IExpbmVEZWNvZGVyKCk7XG5cbiAgICAgIGNvbnN0IGl0ZXIgPSByZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmFibGU8Qnl0ZXM+KHJlYWRhYmxlU3RyZWFtKTtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaXRlcikge1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZGVjb2RlKGNodW5rKSkge1xuICAgICAgICAgIHlpZWxkIGxpbmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVEZWNvZGVyLmZsdXNoKCkpIHtcbiAgICAgICAgeWllbGQgbGluZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiogaXRlcmF0b3IoKTogQXN5bmNJdGVyYXRvcjxJdGVtLCBhbnksIHVuZGVmaW5lZD4ge1xuICAgICAgaWYgKGNvbnN1bWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGl0ZXJhdGUgb3ZlciBhIGNvbnN1bWVkIHN0cmVhbSwgdXNlIGAudGVlKClgIHRvIHNwbGl0IHRoZSBzdHJlYW0uJyk7XG4gICAgICB9XG4gICAgICBjb25zdW1lZCA9IHRydWU7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBsaW5lIG9mIGl0ZXJMaW5lcygpKSB7XG4gICAgICAgICAgaWYgKGRvbmUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChsaW5lKSB5aWVsZCBKU09OLnBhcnNlKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBjYWxscyBgc3RyZWFtLmNvbnRyb2xsZXIuYWJvcnQoKWAsIHdlIHNob3VsZCBleGl0IHdpdGhvdXQgdGhyb3dpbmcuXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHJldHVybjtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGBicmVha2BzLCBhYm9ydCB0aGUgb25nb2luZyByZXF1ZXN0LlxuICAgICAgICBpZiAoIWRvbmUpIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFN0cmVhbShpdGVyYXRvciwgY29udHJvbGxlcik7XG4gIH1cblxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk6IEFzeW5jSXRlcmF0b3I8SXRlbT4ge1xuICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIHRoZSBzdHJlYW0gaW50byB0d28gc3RyZWFtcyB3aGljaCBjYW4gYmVcbiAgICogaW5kZXBlbmRlbnRseSByZWFkIGZyb20gYXQgZGlmZmVyZW50IHNwZWVkcy5cbiAgICovXG4gIHRlZSgpOiBbU3RyZWFtPEl0ZW0+LCBTdHJlYW08SXRlbT5dIHtcbiAgICBjb25zdCBsZWZ0OiBBcnJheTxQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PEl0ZW0+Pj4gPSBbXTtcbiAgICBjb25zdCByaWdodDogQXJyYXk8UHJvbWlzZTxJdGVyYXRvclJlc3VsdDxJdGVtPj4+ID0gW107XG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yKCk7XG5cbiAgICBjb25zdCB0ZWVJdGVyYXRvciA9IChxdWV1ZTogQXJyYXk8UHJvbWlzZTxJdGVyYXRvclJlc3VsdDxJdGVtPj4+KTogQXN5bmNJdGVyYXRvcjxJdGVtPiA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgbGVmdC5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICByaWdodC5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBxdWV1ZS5zaGlmdCgpITtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHJldHVybiBbXG4gICAgICBuZXcgU3RyZWFtKCgpID0+IHRlZUl0ZXJhdG9yKGxlZnQpLCB0aGlzLmNvbnRyb2xsZXIpLFxuICAgICAgbmV3IFN0cmVhbSgoKSA9PiB0ZWVJdGVyYXRvcihyaWdodCksIHRoaXMuY29udHJvbGxlciksXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIHN0cmVhbSB0byBhIG5ld2xpbmUtc2VwYXJhdGVkIFJlYWRhYmxlU3RyZWFtIG9mXG4gICAqIEpTT04gc3RyaW5naWZpZWQgdmFsdWVzIGluIHRoZSBzdHJlYW1cbiAgICogd2hpY2ggY2FuIGJlIHR1cm5lZCBiYWNrIGludG8gYSBTdHJlYW0gd2l0aCBgU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbSgpYC5cbiAgICovXG4gIHRvUmVhZGFibGVTdHJlYW0oKTogUmVhZGFibGVTdHJlYW0ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBpdGVyOiBBc3luY0l0ZXJhdG9yPEl0ZW0+O1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIGl0ZXIgPSBzZWxmW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHB1bGwoY3RybDogYW55KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlci5uZXh0KCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybiBjdHJsLmNsb3NlKCk7XG5cbiAgICAgICAgICBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdcXG4nKTtcblxuICAgICAgICAgIGN0cmwuZW5xdWV1ZShieXRlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGN0cmwuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGNhbmNlbCgpIHtcbiAgICAgICAgYXdhaXQgaXRlci5yZXR1cm4/LigpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIF9pdGVyU1NFTWVzc2FnZXMoXG4gIHJlc3BvbnNlOiBSZXNwb25zZSxcbiAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyLFxuKTogQXN5bmNHZW5lcmF0b3I8U2VydmVyU2VudEV2ZW50LCB2b2lkLCB1bmtub3duPiB7XG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYEF0dGVtcHRlZCB0byBpdGVyYXRlIG92ZXIgYSByZXNwb25zZSB3aXRoIG5vIGJvZHlgKTtcbiAgfVxuXG4gIGNvbnN0IHNzZURlY29kZXIgPSBuZXcgU1NFRGVjb2RlcigpO1xuICBjb25zdCBsaW5lRGVjb2RlciA9IG5ldyBMaW5lRGVjb2RlcigpO1xuXG4gIGNvbnN0IGl0ZXIgPSByZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmFibGU8Qnl0ZXM+KHJlc3BvbnNlLmJvZHkpO1xuICBmb3IgYXdhaXQgKGNvbnN0IHNzZUNodW5rIG9mIGl0ZXJTU0VDaHVua3MoaXRlcikpIHtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZGVjb2RlKHNzZUNodW5rKSkge1xuICAgICAgY29uc3Qgc3NlID0gc3NlRGVjb2Rlci5kZWNvZGUobGluZSk7XG4gICAgICBpZiAoc3NlKSB5aWVsZCBzc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVEZWNvZGVyLmZsdXNoKCkpIHtcbiAgICBjb25zdCBzc2UgPSBzc2VEZWNvZGVyLmRlY29kZShsaW5lKTtcbiAgICBpZiAoc3NlKSB5aWVsZCBzc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBhc3luYyBpdGVyYWJsZSBpdGVyYXRvciwgaXRlcmF0ZXMgb3ZlciBpdCBhbmQgeWllbGRzIGZ1bGxcbiAqIFNTRSBjaHVua3MsIGkuZS4geWllbGRzIHdoZW4gYSBkb3VibGUgbmV3LWxpbmUgaXMgZW5jb3VudGVyZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uKiBpdGVyU1NFQ2h1bmtzKGl0ZXJhdG9yOiBBc3luY0l0ZXJhYmxlSXRlcmF0b3I8Qnl0ZXM+KTogQXN5bmNHZW5lcmF0b3I8VWludDhBcnJheT4ge1xuICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KCk7XG5cbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpdGVyYXRvcikge1xuICAgIGlmIChjaHVuayA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBiaW5hcnlDaHVuayA9XG4gICAgICBjaHVuayBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoY2h1bmspXG4gICAgICA6IHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgPyBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoY2h1bmspXG4gICAgICA6IGNodW5rO1xuXG4gICAgbGV0IG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIGJpbmFyeUNodW5rLmxlbmd0aCk7XG4gICAgbmV3RGF0YS5zZXQoZGF0YSk7XG4gICAgbmV3RGF0YS5zZXQoYmluYXJ5Q2h1bmssIGRhdGEubGVuZ3RoKTtcbiAgICBkYXRhID0gbmV3RGF0YTtcblxuICAgIGxldCBwYXR0ZXJuSW5kZXg7XG4gICAgd2hpbGUgKChwYXR0ZXJuSW5kZXggPSBmaW5kRG91YmxlTmV3bGluZUluZGV4KGRhdGEpKSAhPT0gLTEpIHtcbiAgICAgIHlpZWxkIGRhdGEuc2xpY2UoMCwgcGF0dGVybkluZGV4KTtcbiAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKHBhdHRlcm5JbmRleCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgIHlpZWxkIGRhdGE7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZERvdWJsZU5ld2xpbmVJbmRleChidWZmZXI6IFVpbnQ4QXJyYXkpOiBudW1iZXIge1xuICAvLyBUaGlzIGZ1bmN0aW9uIHNlYXJjaGVzIHRoZSBidWZmZXIgZm9yIHRoZSBlbmQgcGF0dGVybnMgKFxcclxcciwgXFxuXFxuLCBcXHJcXG5cXHJcXG4pXG4gIC8vIGFuZCByZXR1cm5zIHRoZSBpbmRleCByaWdodCBhZnRlciB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbnkgcGF0dGVybixcbiAgLy8gb3IgLTEgaWYgbm9uZSBvZiB0aGUgcGF0dGVybnMgYXJlIGZvdW5kLlxuICBjb25zdCBuZXdsaW5lID0gMHgwYTsgLy8gXFxuXG4gIGNvbnN0IGNhcnJpYWdlID0gMHgwZDsgLy8gXFxyXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgaWYgKGJ1ZmZlcltpXSA9PT0gbmV3bGluZSAmJiBidWZmZXJbaSArIDFdID09PSBuZXdsaW5lKSB7XG4gICAgICAvLyBcXG5cXG5cbiAgICAgIHJldHVybiBpICsgMjtcbiAgICB9XG4gICAgaWYgKGJ1ZmZlcltpXSA9PT0gY2FycmlhZ2UgJiYgYnVmZmVyW2kgKyAxXSA9PT0gY2FycmlhZ2UpIHtcbiAgICAgIC8vIFxcclxcclxuICAgICAgcmV0dXJuIGkgKyAyO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBidWZmZXJbaV0gPT09IGNhcnJpYWdlICYmXG4gICAgICBidWZmZXJbaSArIDFdID09PSBuZXdsaW5lICYmXG4gICAgICBpICsgMyA8IGJ1ZmZlci5sZW5ndGggJiZcbiAgICAgIGJ1ZmZlcltpICsgMl0gPT09IGNhcnJpYWdlICYmXG4gICAgICBidWZmZXJbaSArIDNdID09PSBuZXdsaW5lXG4gICAgKSB7XG4gICAgICAvLyBcXHJcXG5cXHJcXG5cbiAgICAgIHJldHVybiBpICsgNDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmNsYXNzIFNTRURlY29kZXIge1xuICBwcml2YXRlIGRhdGE6IHN0cmluZ1tdO1xuICBwcml2YXRlIGV2ZW50OiBzdHJpbmcgfCBudWxsO1xuICBwcml2YXRlIGNodW5rczogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ldmVudCA9IG51bGw7XG4gICAgdGhpcy5kYXRhID0gW107XG4gICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgfVxuXG4gIGRlY29kZShsaW5lOiBzdHJpbmcpIHtcbiAgICBpZiAobGluZS5lbmRzV2l0aCgnXFxyJykpIHtcbiAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cmluZygwLCBsaW5lLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIGlmICghbGluZSkge1xuICAgICAgLy8gZW1wdHkgbGluZSBhbmQgd2UgZGlkbid0IHByZXZpb3VzbHkgZW5jb3VudGVyIGFueSBtZXNzYWdlc1xuICAgICAgaWYgKCF0aGlzLmV2ZW50ICYmICF0aGlzLmRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgICAgY29uc3Qgc3NlOiBTZXJ2ZXJTZW50RXZlbnQgPSB7XG4gICAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgICBkYXRhOiB0aGlzLmRhdGEuam9pbignXFxuJyksXG4gICAgICAgIHJhdzogdGhpcy5jaHVua3MsXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmV2ZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgdGhpcy5jaHVua3MgPSBbXTtcblxuICAgICAgcmV0dXJuIHNzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNodW5rcy5wdXNoKGxpbmUpO1xuXG4gICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnOicpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgW2ZpZWxkbmFtZSwgXywgdmFsdWVdID0gcGFydGl0aW9uKGxpbmUsICc6Jyk7XG5cbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnICcpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxKTtcbiAgICB9XG5cbiAgICBpZiAoZmllbGRuYW1lID09PSAnZXZlbnQnKSB7XG4gICAgICB0aGlzLmV2ZW50ID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChmaWVsZG5hbWUgPT09ICdkYXRhJykge1xuICAgICAgdGhpcy5kYXRhLnB1c2godmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKiBUaGlzIGlzIGFuIGludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0aGF0J3MganVzdCB1c2VkIGZvciB0ZXN0aW5nICovXG5leHBvcnQgZnVuY3Rpb24gX2RlY29kZUNodW5rcyhjaHVua3M6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IExpbmVEZWNvZGVyKCk7XG4gIGNvbnN0IGxpbmVzOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgIGxpbmVzLnB1c2goLi4uZGVjb2Rlci5kZWNvZGUoY2h1bmspKTtcbiAgfVxuXG4gIHJldHVybiBsaW5lcztcbn1cblxuZnVuY3Rpb24gcGFydGl0aW9uKHN0cjogc3RyaW5nLCBkZWxpbWl0ZXI6IHN0cmluZyk6IFtzdHJpbmcsIHN0cmluZywgc3RyaW5nXSB7XG4gIGNvbnN0IGluZGV4ID0gc3RyLmluZGV4T2YoZGVsaW1pdGVyKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIHJldHVybiBbc3RyLnN1YnN0cmluZygwLCBpbmRleCksIGRlbGltaXRlciwgc3RyLnN1YnN0cmluZyhpbmRleCArIGRlbGltaXRlci5sZW5ndGgpXTtcbiAgfVxuXG4gIHJldHVybiBbc3RyLCAnJywgJyddO1xufVxuXG4vKipcbiAqIE1vc3QgYnJvd3NlcnMgZG9uJ3QgeWV0IGhhdmUgYXN5bmMgaXRlcmFibGUgc3VwcG9ydCBmb3IgUmVhZGFibGVTdHJlYW0sXG4gKiBhbmQgTm9kZSBoYXMgYSB2ZXJ5IGRpZmZlcmVudCB3YXkgb2YgcmVhZGluZyBieXRlcyBmcm9tIGl0cyBcIlJlYWRhYmxlU3RyZWFtXCIuXG4gKlxuICogVGhpcyBwb2x5ZmlsbCB3YXMgcHVsbGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL01hdHRpYXNCdWVsZW5zL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3B1bGwvMTIyI2lzc3VlY29tbWVudC0xNjI3MzU0NDkwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmFibGU8VD4oc3RyZWFtOiBhbnkpOiBBc3luY0l0ZXJhYmxlSXRlcmF0b3I8VD4ge1xuICBpZiAoc3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkgcmV0dXJuIHN0cmVhbTtcblxuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIHJldHVybiB7XG4gICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChyZXN1bHQ/LmRvbmUpIHJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgd2hlbiBzdHJlYW0gYmVjb21lcyBjbG9zZWRcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayB3aGVuIHN0cmVhbSBiZWNvbWVzIGVycm9yZWRcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIHJldHVybigpIHtcbiAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSByZWFkZXIuY2FuY2VsKCk7XG4gICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIGF3YWl0IGNhbmNlbFByb21pc2U7XG4gICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgfSxcbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyB0eXBlIFJlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi9jb3JlJztcbmltcG9ydCB7XG4gIEZvcm1EYXRhLFxuICBGaWxlLFxuICB0eXBlIEJsb2IsXG4gIHR5cGUgRmlsZVByb3BlcnR5QmFnLFxuICBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucyxcbiAgdHlwZSBGc1JlYWRTdHJlYW0sXG4gIGlzRnNSZWFkU3RyZWFtLFxufSBmcm9tICcuL19zaGltcy9pbmRleCc7XG5pbXBvcnQgeyBNdWx0aXBhcnRCb2R5IH0gZnJvbSAnLi9fc2hpbXMvTXVsdGlwYXJ0Qm9keSc7XG5leHBvcnQgeyBmaWxlRnJvbVBhdGggfSBmcm9tICcuL19zaGltcy9pbmRleCc7XG5cbnR5cGUgQmxvYkxpa2VQYXJ0ID0gc3RyaW5nIHwgQXJyYXlCdWZmZXIgfCBBcnJheUJ1ZmZlclZpZXcgfCBCbG9iTGlrZSB8IFVpbnQ4QXJyYXkgfCBEYXRhVmlldztcbmV4cG9ydCB0eXBlIEJsb2JQYXJ0ID0gc3RyaW5nIHwgQXJyYXlCdWZmZXIgfCBBcnJheUJ1ZmZlclZpZXcgfCBCbG9iIHwgVWludDhBcnJheSB8IERhdGFWaWV3O1xuXG4vKipcbiAqIFR5cGljYWxseSwgdGhpcyBpcyBhIG5hdGl2ZSBcIkZpbGVcIiBjbGFzcy5cbiAqXG4gKiBXZSBwcm92aWRlIHRoZSB7QGxpbmsgdG9GaWxlfSB1dGlsaXR5IHRvIGNvbnZlcnQgYSB2YXJpZXR5IG9mIG9iamVjdHNcbiAqIGludG8gdGhlIEZpbGUgY2xhc3MuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhIGZldGNoIFJlc3BvbnNlLCBvciBpbiBOb2RlLFxuICogdGhlIHJlc3VsdCBvZiBmcy5jcmVhdGVSZWFkU3RyZWFtKCkuXG4gKi9cbmV4cG9ydCB0eXBlIFVwbG9hZGFibGUgPSBGaWxlTGlrZSB8IFJlc3BvbnNlTGlrZSB8IEZzUmVhZFN0cmVhbTtcblxuLyoqXG4gKiBJbnRlbmRlZCB0byBtYXRjaCB3ZWIuQmxvYiwgbm9kZS5CbG9iLCBub2RlLWZldGNoLkJsb2IsIGV0Yy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCbG9iTGlrZSB7XG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0Jsb2Ivc2l6ZSkgKi9cbiAgcmVhZG9ubHkgc2l6ZTogbnVtYmVyO1xuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9CbG9iL3R5cGUpICovXG4gIHJlYWRvbmx5IHR5cGU6IHN0cmluZztcbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQmxvYi90ZXh0KSAqL1xuICB0ZXh0KCk6IFByb21pc2U8c3RyaW5nPjtcbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQmxvYi9zbGljZSkgKi9cbiAgc2xpY2Uoc3RhcnQ/OiBudW1iZXIsIGVuZD86IG51bWJlcik6IEJsb2JMaWtlO1xuICAvLyB1bmZvcnR1bmF0ZWx5IEB0eXBlcy9ub2RlLWZldGNoQF4yLjYuNCBkb2Vzbid0IHR5cGUgdGhlIGFycmF5QnVmZmVyIG1ldGhvZFxufVxuXG4vKipcbiAqIEludGVuZGVkIHRvIG1hdGNoIHdlYi5GaWxlLCBub2RlLkZpbGUsIG5vZGUtZmV0Y2guRmlsZSwgZXRjLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVMaWtlIGV4dGVuZHMgQmxvYkxpa2Uge1xuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9GaWxlL2xhc3RNb2RpZmllZCkgKi9cbiAgcmVhZG9ubHkgbGFzdE1vZGlmaWVkOiBudW1iZXI7XG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0ZpbGUvbmFtZSkgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEludGVuZGVkIHRvIG1hdGNoIHdlYi5SZXNwb25zZSwgbm9kZS5SZXNwb25zZSwgbm9kZS1mZXRjaC5SZXNwb25zZSwgZXRjLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlTGlrZSB7XG4gIHVybDogc3RyaW5nO1xuICBibG9iKCk6IFByb21pc2U8QmxvYkxpa2U+O1xufVxuXG5leHBvcnQgY29uc3QgaXNSZXNwb25zZUxpa2UgPSAodmFsdWU6IGFueSk6IHZhbHVlIGlzIFJlc3BvbnNlTGlrZSA9PlxuICB2YWx1ZSAhPSBudWxsICYmXG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgdHlwZW9mIHZhbHVlLnVybCA9PT0gJ3N0cmluZycgJiZcbiAgdHlwZW9mIHZhbHVlLmJsb2IgPT09ICdmdW5jdGlvbic7XG5cbmV4cG9ydCBjb25zdCBpc0ZpbGVMaWtlID0gKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBGaWxlTGlrZSA9PlxuICB2YWx1ZSAhPSBudWxsICYmXG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgdHlwZW9mIHZhbHVlLm5hbWUgPT09ICdzdHJpbmcnICYmXG4gIHR5cGVvZiB2YWx1ZS5sYXN0TW9kaWZpZWQgPT09ICdudW1iZXInICYmXG4gIGlzQmxvYkxpa2UodmFsdWUpO1xuXG4vKipcbiAqIFRoZSBCbG9iTGlrZSB0eXBlIG9taXRzIGFycmF5QnVmZmVyKCkgYmVjYXVzZSBAdHlwZXMvbm9kZS1mZXRjaEBeMi42LjQgbGFja3MgaXQ7IGJ1dCB0aGlzIGNoZWNrXG4gKiBhZGRzIHRoZSBhcnJheUJ1ZmZlcigpIG1ldGhvZCB0eXBlIGJlY2F1c2UgaXQgaXMgYXZhaWxhYmxlIGFuZCB1c2VkIGF0IHJ1bnRpbWVcbiAqL1xuZXhwb3J0IGNvbnN0IGlzQmxvYkxpa2UgPSAodmFsdWU6IGFueSk6IHZhbHVlIGlzIEJsb2JMaWtlICYgeyBhcnJheUJ1ZmZlcigpOiBQcm9taXNlPEFycmF5QnVmZmVyPiB9ID0+XG4gIHZhbHVlICE9IG51bGwgJiZcbiAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICB0eXBlb2YgdmFsdWUuc2l6ZSA9PT0gJ251bWJlcicgJiZcbiAgdHlwZW9mIHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnICYmXG4gIHR5cGVvZiB2YWx1ZS50ZXh0ID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiB2YWx1ZS5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgdmFsdWUuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbic7XG5cbmV4cG9ydCBjb25zdCBpc1VwbG9hZGFibGUgPSAodmFsdWU6IGFueSk6IHZhbHVlIGlzIFVwbG9hZGFibGUgPT4ge1xuICByZXR1cm4gaXNGaWxlTGlrZSh2YWx1ZSkgfHwgaXNSZXNwb25zZUxpa2UodmFsdWUpIHx8IGlzRnNSZWFkU3RyZWFtKHZhbHVlKTtcbn07XG5cbmV4cG9ydCB0eXBlIFRvRmlsZUlucHV0ID0gVXBsb2FkYWJsZSB8IEV4Y2x1ZGU8QmxvYkxpa2VQYXJ0LCBzdHJpbmc+IHwgQXN5bmNJdGVyYWJsZTxCbG9iTGlrZVBhcnQ+O1xuXG4vKipcbiAqIEhlbHBlciBmb3IgY3JlYXRpbmcgYSB7QGxpbmsgRmlsZX0gdG8gcGFzcyB0byBhbiBTREsgdXBsb2FkIG1ldGhvZCBmcm9tIGEgdmFyaWV0eSBvZiBkaWZmZXJlbnQgZGF0YSBmb3JtYXRzXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHJhdyBjb250ZW50IG9mIHRoZSBmaWxlLiAgQ2FuIGJlIGFuIHtAbGluayBVcGxvYWRhYmxlfSwge0BsaW5rIEJsb2JMaWtlUGFydH0sIG9yIHtAbGluayBBc3luY0l0ZXJhYmxlfSBvZiB7QGxpbmsgQmxvYkxpa2VQYXJ0fXNcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZS4gSWYgb21pdHRlZCwgdG9GaWxlIHdpbGwgdHJ5IHRvIGRldGVybWluZSBhIGZpbGUgbmFtZSBmcm9tIGJpdHMgaWYgcG9zc2libGVcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy50eXBlIHRoZSBNSU1FIHR5cGUgb2YgdGhlIGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0aW9ucy5sYXN0TW9kaWZpZWQgdGhlIGxhc3QgbW9kaWZpZWQgdGltZXN0YW1wXG4gKiBAcmV0dXJucyBhIHtAbGluayBGaWxlfSB3aXRoIHRoZSBnaXZlbiBwcm9wZXJ0aWVzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0b0ZpbGUoXG4gIHZhbHVlOiBUb0ZpbGVJbnB1dCB8IFByb21pc2VMaWtlPFRvRmlsZUlucHV0PixcbiAgbmFtZT86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQsXG4gIG9wdGlvbnM/OiBGaWxlUHJvcGVydHlCYWcgfCB1bmRlZmluZWQsXG4pOiBQcm9taXNlPEZpbGVMaWtlPiB7XG4gIC8vIElmIGl0J3MgYSBwcm9taXNlLCByZXNvbHZlIGl0LlxuICB2YWx1ZSA9IGF3YWl0IHZhbHVlO1xuXG4gIC8vIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYSBgRmlsZWAgd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICBpZiAoaXNGaWxlTGlrZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNSZXNwb25zZUxpa2UodmFsdWUpKSB7XG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IHZhbHVlLmJsb2IoKTtcbiAgICBuYW1lIHx8PSBuZXcgVVJMKHZhbHVlLnVybCkucGF0aG5hbWUuc3BsaXQoL1tcXFxcL10vKS5wb3AoKSA/PyAndW5rbm93bl9maWxlJztcblxuICAgIC8vIHdlIG5lZWQgdG8gY29udmVydCB0aGUgYEJsb2JgIGludG8gYW4gYXJyYXkgYnVmZmVyIGJlY2F1c2UgdGhlIGBCbG9iYCBjbGFzc1xuICAgIC8vIHRoYXQgYG5vZGUtZmV0Y2hgIGRlZmluZXMgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIHdlYiBzdGFuZGFyZCB3aGljaCByZXN1bHRzXG4gICAgLy8gaW4gYG5ldyBGaWxlYCBpbnRlcnByZXRpbmcgaXQgYXMgYSBzdHJpbmcgaW5zdGVhZCBvZiBiaW5hcnkgZGF0YS5cbiAgICBjb25zdCBkYXRhID0gaXNCbG9iTGlrZShibG9iKSA/IFsoYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpKSBhcyBhbnldIDogW2Jsb2JdO1xuXG4gICAgcmV0dXJuIG5ldyBGaWxlKGRhdGEsIG5hbWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3QgYml0cyA9IGF3YWl0IGdldEJ5dGVzKHZhbHVlKTtcblxuICBuYW1lIHx8PSBnZXROYW1lKHZhbHVlKSA/PyAndW5rbm93bl9maWxlJztcblxuICBpZiAoIW9wdGlvbnM/LnR5cGUpIHtcbiAgICBjb25zdCB0eXBlID0gKGJpdHNbMF0gYXMgYW55KT8udHlwZTtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB0eXBlIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBGaWxlKGJpdHMsIG5hbWUsIG9wdGlvbnMpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRCeXRlcyh2YWx1ZTogVG9GaWxlSW5wdXQpOiBQcm9taXNlPEFycmF5PEJsb2JQYXJ0Pj4ge1xuICBsZXQgcGFydHM6IEFycmF5PEJsb2JQYXJ0PiA9IFtdO1xuICBpZiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkgfHwgLy8gaW5jbHVkZXMgVWludDhBcnJheSwgQnVmZmVyLCBldGMuXG4gICAgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclxuICApIHtcbiAgICBwYXJ0cy5wdXNoKHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKHZhbHVlKSkge1xuICAgIHBhcnRzLnB1c2goYXdhaXQgdmFsdWUuYXJyYXlCdWZmZXIoKSk7XG4gIH0gZWxzZSBpZiAoXG4gICAgaXNBc3luY0l0ZXJhYmxlSXRlcmF0b3IodmFsdWUpIC8vIGluY2x1ZGVzIFJlYWRhYmxlLCBSZWFkYWJsZVN0cmVhbSwgZXRjLlxuICApIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHZhbHVlKSB7XG4gICAgICBwYXJ0cy5wdXNoKGNodW5rIGFzIEJsb2JQYXJ0KTsgLy8gVE9ETywgY29uc2lkZXIgdmFsaWRhdGluZz9cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFVuZXhwZWN0ZWQgZGF0YSB0eXBlOiAke3R5cGVvZiB2YWx1ZX07IGNvbnN0cnVjdG9yOiAke3ZhbHVlPy5jb25zdHJ1Y3RvclxuICAgICAgICA/Lm5hbWV9OyBwcm9wczogJHtwcm9wc0ZvckVycm9yKHZhbHVlKX1gLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbmZ1bmN0aW9uIHByb3BzRm9yRXJyb3IodmFsdWU6IGFueSk6IHN0cmluZyB7XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICByZXR1cm4gYFske3Byb3BzLm1hcCgocCkgPT4gYFwiJHtwfVwiYCkuam9pbignLCAnKX1dYDtcbn1cblxuZnVuY3Rpb24gZ2V0TmFtZSh2YWx1ZTogYW55KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIChcbiAgICBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIodmFsdWUubmFtZSkgfHxcbiAgICBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIodmFsdWUuZmlsZW5hbWUpIHx8XG4gICAgLy8gRm9yIGZzLlJlYWRTdHJlYW1cbiAgICBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIodmFsdWUucGF0aCk/LnNwbGl0KC9bXFxcXC9dLykucG9wKClcbiAgKTtcbn1cblxuY29uc3QgZ2V0U3RyaW5nRnJvbU1heWJlQnVmZmVyID0gKHg6IHN0cmluZyB8IEJ1ZmZlciB8IHVua25vd24pOiBzdHJpbmcgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSByZXR1cm4geDtcbiAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBCdWZmZXIpIHJldHVybiBTdHJpbmcoeCk7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5jb25zdCBpc0FzeW5jSXRlcmFibGVJdGVyYXRvciA9ICh2YWx1ZTogYW55KTogdmFsdWUgaXMgQXN5bmNJdGVyYWJsZUl0ZXJhdG9yPHVua25vd24+ID0+XG4gIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgaXNNdWx0aXBhcnRCb2R5ID0gKGJvZHk6IGFueSk6IGJvZHkgaXMgTXVsdGlwYXJ0Qm9keSA9PlxuICBib2R5ICYmIHR5cGVvZiBib2R5ID09PSAnb2JqZWN0JyAmJiBib2R5LmJvZHkgJiYgYm9keVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTXVsdGlwYXJ0Qm9keSc7XG5cbi8qKlxuICogUmV0dXJucyBhIG11bHRpcGFydC9mb3JtLWRhdGEgcmVxdWVzdCBpZiBhbnkgcGFydCBvZiB0aGUgZ2l2ZW4gcmVxdWVzdCBib2R5IGNvbnRhaW5zIGEgRmlsZSAvIEJsb2IgdmFsdWUuXG4gKiBPdGhlcndpc2UgcmV0dXJucyB0aGUgcmVxdWVzdCBhcyBpcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG1heWJlTXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zID0gYXN5bmMgPFQgPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gIG9wdHM6IFJlcXVlc3RPcHRpb25zPFQ+LFxuKTogUHJvbWlzZTxSZXF1ZXN0T3B0aW9uczxUIHwgTXVsdGlwYXJ0Qm9keT4+ID0+IHtcbiAgaWYgKCFoYXNVcGxvYWRhYmxlVmFsdWUob3B0cy5ib2R5KSkgcmV0dXJuIG9wdHM7XG5cbiAgY29uc3QgZm9ybSA9IGF3YWl0IGNyZWF0ZUZvcm0ob3B0cy5ib2R5KTtcbiAgcmV0dXJuIGdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zKGZvcm0sIG9wdHMpO1xufTtcblxuZXhwb3J0IGNvbnN0IG11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyA9IGFzeW5jIDxUID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KFxuICBvcHRzOiBSZXF1ZXN0T3B0aW9uczxUPixcbik6IFByb21pc2U8UmVxdWVzdE9wdGlvbnM8VCB8IE11bHRpcGFydEJvZHk+PiA9PiB7XG4gIGNvbnN0IGZvcm0gPSBhd2FpdCBjcmVhdGVGb3JtKG9wdHMuYm9keSk7XG4gIHJldHVybiBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucyhmb3JtLCBvcHRzKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVGb3JtID0gYXN5bmMgPFQgPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oYm9keTogVCB8IHVuZGVmaW5lZCk6IFByb21pc2U8Rm9ybURhdGE+ID0+IHtcbiAgY29uc3QgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyhib2R5IHx8IHt9KS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYWRkRm9ybVZhbHVlKGZvcm0sIGtleSwgdmFsdWUpKSk7XG4gIHJldHVybiBmb3JtO1xufTtcblxuY29uc3QgaGFzVXBsb2FkYWJsZVZhbHVlID0gKHZhbHVlOiB1bmtub3duKTogYm9vbGVhbiA9PiB7XG4gIGlmIChpc1VwbG9hZGFibGUodmFsdWUpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWUuc29tZShoYXNVcGxvYWRhYmxlVmFsdWUpO1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgaWYgKGhhc1VwbG9hZGFibGVWYWx1ZSgodmFsdWUgYXMgYW55KVtrXSkpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBhZGRGb3JtVmFsdWUgPSBhc3luYyAoZm9ybTogRm9ybURhdGEsIGtleTogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBgUmVjZWl2ZWQgbnVsbCBmb3IgXCIke2tleX1cIjsgdG8gcGFzcyBudWxsIGluIEZvcm1EYXRhLCB5b3UgbXVzdCB1c2UgdGhlIHN0cmluZyAnbnVsbCdgLFxuICAgICk7XG4gIH1cblxuICAvLyBUT0RPOiBtYWtlIG5lc3RlZCBmb3JtYXRzIGNvbmZpZ3VyYWJsZVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgZm9ybS5hcHBlbmQoa2V5LCBTdHJpbmcodmFsdWUpKTtcbiAgfSBlbHNlIGlmIChpc1VwbG9hZGFibGUodmFsdWUpKSB7XG4gICAgY29uc3QgZmlsZSA9IGF3YWl0IHRvRmlsZSh2YWx1ZSk7XG4gICAgZm9ybS5hcHBlbmQoa2V5LCBmaWxlIGFzIEZpbGUpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwodmFsdWUubWFwKChlbnRyeSkgPT4gYWRkRm9ybVZhbHVlKGZvcm0sIGtleSArICdbXScsIGVudHJ5KSkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5tYXAoKFtuYW1lLCBwcm9wXSkgPT4gYWRkRm9ybVZhbHVlKGZvcm0sIGAke2tleX1bJHtuYW1lfV1gLCBwcm9wKSksXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYEludmFsaWQgdmFsdWUgZ2l2ZW4gdG8gZm9ybSwgZXhwZWN0ZWQgYSBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb2JqZWN0LCBBcnJheSwgRmlsZSBvciBCbG9iIGJ1dCBnb3QgJHt2YWx1ZX0gaW5zdGVhZGAsXG4gICAgKTtcbiAgfVxufTtcbiIsICJpbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSAnLi92ZXJzaW9uJztcbmltcG9ydCB7IFN0cmVhbSB9IGZyb20gJy4vc3RyZWFtaW5nJztcbmltcG9ydCB7XG4gIE9wZW5BSUVycm9yLFxuICBBUElFcnJvcixcbiAgQVBJQ29ubmVjdGlvbkVycm9yLFxuICBBUElDb25uZWN0aW9uVGltZW91dEVycm9yLFxuICBBUElVc2VyQWJvcnRFcnJvcixcbn0gZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQge1xuICBraW5kIGFzIHNoaW1zS2luZCxcbiAgdHlwZSBSZWFkYWJsZSxcbiAgZ2V0RGVmYXVsdEFnZW50LFxuICB0eXBlIEFnZW50LFxuICBmZXRjaCxcbiAgdHlwZSBSZXF1ZXN0SW5mbyxcbiAgdHlwZSBSZXF1ZXN0SW5pdCxcbiAgdHlwZSBSZXNwb25zZSxcbiAgdHlwZSBIZWFkZXJzSW5pdCxcbn0gZnJvbSAnLi9fc2hpbXMvaW5kZXgnO1xuZXhwb3J0IHsgdHlwZSBSZXNwb25zZSB9O1xuaW1wb3J0IHsgQmxvYkxpa2UsIGlzQmxvYkxpa2UsIGlzTXVsdGlwYXJ0Qm9keSB9IGZyb20gJy4vdXBsb2Fkcyc7XG5leHBvcnQge1xuICBtYXliZU11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyxcbiAgbXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zLFxuICBjcmVhdGVGb3JtLFxuICB0eXBlIFVwbG9hZGFibGUsXG59IGZyb20gJy4vdXBsb2Fkcyc7XG5cbmV4cG9ydCB0eXBlIEZldGNoID0gKHVybDogUmVxdWVzdEluZm8sIGluaXQ/OiBSZXF1ZXN0SW5pdCkgPT4gUHJvbWlzZTxSZXNwb25zZT47XG5cbnR5cGUgUHJvbWlzZU9yVmFsdWU8VD4gPSBUIHwgUHJvbWlzZTxUPjtcblxudHlwZSBBUElSZXNwb25zZVByb3BzID0ge1xuICByZXNwb25zZTogUmVzcG9uc2U7XG4gIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnM7XG4gIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcjtcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGRlZmF1bHRQYXJzZVJlc3BvbnNlPFQ+KHByb3BzOiBBUElSZXNwb25zZVByb3BzKTogUHJvbWlzZTxXaXRoUmVxdWVzdElEPFQ+PiB7XG4gIGNvbnN0IHsgcmVzcG9uc2UgfSA9IHByb3BzO1xuICBpZiAocHJvcHMub3B0aW9ucy5zdHJlYW0pIHtcbiAgICBkZWJ1ZygncmVzcG9uc2UnLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnVybCwgcmVzcG9uc2UuaGVhZGVycywgcmVzcG9uc2UuYm9keSk7XG5cbiAgICAvLyBOb3RlOiB0aGVyZSBpcyBhbiBpbnZhcmlhbnQgaGVyZSB0aGF0IGlzbid0IHJlcHJlc2VudGVkIGluIHRoZSB0eXBlIHN5c3RlbVxuICAgIC8vIHRoYXQgaWYgeW91IHNldCBgc3RyZWFtOiB0cnVlYCB0aGUgcmVzcG9uc2UgdHlwZSBtdXN0IGFsc28gYmUgYFN0cmVhbTxUPmBcblxuICAgIGlmIChwcm9wcy5vcHRpb25zLl9fc3RyZWFtQ2xhc3MpIHtcbiAgICAgIHJldHVybiBwcm9wcy5vcHRpb25zLl9fc3RyZWFtQ2xhc3MuZnJvbVNTRVJlc3BvbnNlKHJlc3BvbnNlLCBwcm9wcy5jb250cm9sbGVyKSBhcyBhbnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmVhbS5mcm9tU1NFUmVzcG9uc2UocmVzcG9uc2UsIHByb3BzLmNvbnRyb2xsZXIpIGFzIGFueTtcbiAgfVxuXG4gIC8vIGZldGNoIHJlZnVzZXMgdG8gcmVhZCB0aGUgYm9keSB3aGVuIHRoZSBzdGF0dXMgY29kZSBpcyAyMDQuXG4gIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNCkge1xuICAgIHJldHVybiBudWxsIGFzIFdpdGhSZXF1ZXN0SUQ8VD47XG4gIH1cblxuICBpZiAocHJvcHMub3B0aW9ucy5fX2JpbmFyeVJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlIGFzIHVua25vd24gYXMgV2l0aFJlcXVlc3RJRDxUPjtcbiAgfVxuXG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICBjb25zdCBpc0pTT04gPVxuICAgIGNvbnRlbnRUeXBlPy5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpIHx8IGNvbnRlbnRUeXBlPy5pbmNsdWRlcygnYXBwbGljYXRpb24vdm5kLmFwaStqc29uJyk7XG4gIGlmIChpc0pTT04pIHtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgZGVidWcoJ3Jlc3BvbnNlJywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS51cmwsIHJlc3BvbnNlLmhlYWRlcnMsIGpzb24pO1xuXG4gICAgcmV0dXJuIF9hZGRSZXF1ZXN0SUQoanNvbiwgcmVzcG9uc2UpO1xuICB9XG5cbiAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgZGVidWcoJ3Jlc3BvbnNlJywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS51cmwsIHJlc3BvbnNlLmhlYWRlcnMsIHRleHQpO1xuXG4gIC8vIFRPRE8gaGFuZGxlIGJsb2IsIGFycmF5YnVmZmVyLCBvdGhlciBjb250ZW50IHR5cGVzLCBldGMuXG4gIHJldHVybiB0ZXh0IGFzIHVua25vd24gYXMgV2l0aFJlcXVlc3RJRDxUPjtcbn1cblxudHlwZSBXaXRoUmVxdWVzdElEPFQ+ID1cbiAgVCBleHRlbmRzIEFycmF5PGFueT4gfCBSZXNwb25zZSB8IEFic3RyYWN0UGFnZTxhbnk+ID8gVFxuICA6IFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+ID8gVCAmIHsgX3JlcXVlc3RfaWQ/OiBzdHJpbmcgfCBudWxsIH1cbiAgOiBUO1xuXG5mdW5jdGlvbiBfYWRkUmVxdWVzdElEPFQ+KHZhbHVlOiBULCByZXNwb25zZTogUmVzcG9uc2UpOiBXaXRoUmVxdWVzdElEPFQ+IHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlIGFzIFdpdGhSZXF1ZXN0SUQ8VD47XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlLCAnX3JlcXVlc3RfaWQnLCB7XG4gICAgdmFsdWU6IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXJlcXVlc3QtaWQnKSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgfSkgYXMgV2l0aFJlcXVlc3RJRDxUPjtcbn1cblxuLyoqXG4gKiBBIHN1YmNsYXNzIG9mIGBQcm9taXNlYCBwcm92aWRpbmcgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kc1xuICogZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIFNESy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFQSVByb21pc2U8VD4gZXh0ZW5kcyBQcm9taXNlPFdpdGhSZXF1ZXN0SUQ8VD4+IHtcbiAgcHJpdmF0ZSBwYXJzZWRQcm9taXNlOiBQcm9taXNlPFdpdGhSZXF1ZXN0SUQ8VD4+IHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVzcG9uc2VQcm9taXNlOiBQcm9taXNlPEFQSVJlc3BvbnNlUHJvcHM+LFxuICAgIHByaXZhdGUgcGFyc2VSZXNwb25zZTogKFxuICAgICAgcHJvcHM6IEFQSVJlc3BvbnNlUHJvcHMsXG4gICAgKSA9PiBQcm9taXNlT3JWYWx1ZTxXaXRoUmVxdWVzdElEPFQ+PiA9IGRlZmF1bHRQYXJzZVJlc3BvbnNlLFxuICApIHtcbiAgICBzdXBlcigocmVzb2x2ZSkgPT4ge1xuICAgICAgLy8gdGhpcyBpcyBtYXliZSBhIGJpdCB3ZWlyZCBidXQgdGhpcyBoYXMgdG8gYmUgYSBuby1vcCB0byBub3QgaW1wbGljaXRseVxuICAgICAgLy8gcGFyc2UgdGhlIHJlc3BvbnNlIGJvZHk7IGluc3RlYWQgLnRoZW4sIC5jYXRjaCwgLmZpbmFsbHkgYXJlIG92ZXJyaWRkZW5cbiAgICAgIC8vIHRvIHBhcnNlIHRoZSByZXNwb25zZVxuICAgICAgcmVzb2x2ZShudWxsIGFzIGFueSk7XG4gICAgfSk7XG4gIH1cblxuICBfdGhlblVud3JhcDxVPih0cmFuc2Zvcm06IChkYXRhOiBULCBwcm9wczogQVBJUmVzcG9uc2VQcm9wcykgPT4gVSk6IEFQSVByb21pc2U8VT4ge1xuICAgIHJldHVybiBuZXcgQVBJUHJvbWlzZSh0aGlzLnJlc3BvbnNlUHJvbWlzZSwgYXN5bmMgKHByb3BzKSA9PlxuICAgICAgX2FkZFJlcXVlc3RJRCh0cmFuc2Zvcm0oYXdhaXQgdGhpcy5wYXJzZVJlc3BvbnNlKHByb3BzKSwgcHJvcHMpLCBwcm9wcy5yZXNwb25zZSksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByYXcgYFJlc3BvbnNlYCBpbnN0YW5jZSBpbnN0ZWFkIG9mIHBhcnNpbmcgdGhlIHJlc3BvbnNlXG4gICAqIGRhdGEuXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIHBhcnNlIHRoZSByZXNwb25zZSBib2R5IGJ1dCBzdGlsbCBnZXQgdGhlIGBSZXNwb25zZWBcbiAgICogaW5zdGFuY2UsIHlvdSBjYW4gdXNlIHtAbGluayB3aXRoUmVzcG9uc2UoKX0uXG4gICAqXG4gICAqIFx1RDgzRFx1REM0QiBHZXR0aW5nIHRoZSB3cm9uZyBUeXBlU2NyaXB0IHR5cGUgZm9yIGBSZXNwb25zZWA/XG4gICAqIFRyeSBzZXR0aW5nIGBcIm1vZHVsZVJlc29sdXRpb25cIjogXCJOb2RlTmV4dFwiYCBpZiB5b3UgY2FuLFxuICAgKiBvciBhZGQgb25lIG9mIHRoZXNlIGltcG9ydHMgYmVmb3JlIHlvdXIgZmlyc3QgYGltcG9ydCBcdTIwMjYgZnJvbSAnb3BlbmFpJ2A6XG4gICAqIC0gYGltcG9ydCAnb3BlbmFpL3NoaW1zL25vZGUnYCAoaWYgeW91J3JlIHJ1bm5pbmcgb24gTm9kZSlcbiAgICogLSBgaW1wb3J0ICdvcGVuYWkvc2hpbXMvd2ViJ2AgKG90aGVyd2lzZSlcbiAgICovXG4gIGFzUmVzcG9uc2UoKTogUHJvbWlzZTxSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUHJvbWlzZS50aGVuKChwKSA9PiBwLnJlc3BvbnNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwYXJzZWQgcmVzcG9uc2UgZGF0YSwgdGhlIHJhdyBgUmVzcG9uc2VgIGluc3RhbmNlIGFuZCB0aGUgSUQgb2YgdGhlIHJlcXVlc3QsXG4gICAqIHJldHVybmVkIHZpYSB0aGUgWC1SZXF1ZXN0LUlEIGhlYWRlciB3aGljaCBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZyByZXF1ZXN0cyBhbmQgcmVwb3J0aW5nXG4gICAqIGlzc3VlcyB0byBPcGVuQUkuXG4gICAqXG4gICAqIElmIHlvdSBqdXN0IHdhbnQgdG8gZ2V0IHRoZSByYXcgYFJlc3BvbnNlYCBpbnN0YW5jZSB3aXRob3V0IHBhcnNpbmcgaXQsXG4gICAqIHlvdSBjYW4gdXNlIHtAbGluayBhc1Jlc3BvbnNlKCl9LlxuICAgKlxuICAgKlxuICAgKiBcdUQ4M0RcdURDNEIgR2V0dGluZyB0aGUgd3JvbmcgVHlwZVNjcmlwdCB0eXBlIGZvciBgUmVzcG9uc2VgP1xuICAgKiBUcnkgc2V0dGluZyBgXCJtb2R1bGVSZXNvbHV0aW9uXCI6IFwiTm9kZU5leHRcImAgaWYgeW91IGNhbixcbiAgICogb3IgYWRkIG9uZSBvZiB0aGVzZSBpbXBvcnRzIGJlZm9yZSB5b3VyIGZpcnN0IGBpbXBvcnQgXHUyMDI2IGZyb20gJ29wZW5haSdgOlxuICAgKiAtIGBpbXBvcnQgJ29wZW5haS9zaGltcy9ub2RlJ2AgKGlmIHlvdSdyZSBydW5uaW5nIG9uIE5vZGUpXG4gICAqIC0gYGltcG9ydCAnb3BlbmFpL3NoaW1zL3dlYidgIChvdGhlcndpc2UpXG4gICAqL1xuICBhc3luYyB3aXRoUmVzcG9uc2UoKTogUHJvbWlzZTx7IGRhdGE6IFQ7IHJlc3BvbnNlOiBSZXNwb25zZTsgcmVxdWVzdF9pZDogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCB9PiB7XG4gICAgY29uc3QgW2RhdGEsIHJlc3BvbnNlXSA9IGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLnBhcnNlKCksIHRoaXMuYXNSZXNwb25zZSgpXSk7XG4gICAgcmV0dXJuIHsgZGF0YSwgcmVzcG9uc2UsIHJlcXVlc3RfaWQ6IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXJlcXVlc3QtaWQnKSB9O1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZSgpOiBQcm9taXNlPFdpdGhSZXF1ZXN0SUQ8VD4+IHtcbiAgICBpZiAoIXRoaXMucGFyc2VkUHJvbWlzZSkge1xuICAgICAgdGhpcy5wYXJzZWRQcm9taXNlID0gdGhpcy5yZXNwb25zZVByb21pc2UudGhlbih0aGlzLnBhcnNlUmVzcG9uc2UpIGFzIGFueSBhcyBQcm9taXNlPFdpdGhSZXF1ZXN0SUQ8VD4+O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZWRQcm9taXNlO1xuICB9XG5cbiAgb3ZlcnJpZGUgdGhlbjxUUmVzdWx0MSA9IFdpdGhSZXF1ZXN0SUQ8VD4sIFRSZXN1bHQyID0gbmV2ZXI+KFxuICAgIG9uZnVsZmlsbGVkPzogKCh2YWx1ZTogV2l0aFJlcXVlc3RJRDxUPikgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4pIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBvbnJlamVjdGVkPzogKChyZWFzb246IGFueSkgPT4gVFJlc3VsdDIgfCBQcm9taXNlTGlrZTxUUmVzdWx0Mj4pIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgKTogUHJvbWlzZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2UoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcbiAgfVxuXG4gIG92ZXJyaWRlIGNhdGNoPFRSZXN1bHQgPSBuZXZlcj4oXG4gICAgb25yZWplY3RlZD86ICgocmVhc29uOiBhbnkpID0+IFRSZXN1bHQgfCBQcm9taXNlTGlrZTxUUmVzdWx0PikgfCB1bmRlZmluZWQgfCBudWxsLFxuICApOiBQcm9taXNlPFdpdGhSZXF1ZXN0SUQ8VD4gfCBUUmVzdWx0PiB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2UoKS5jYXRjaChvbnJlamVjdGVkKTtcbiAgfVxuXG4gIG92ZXJyaWRlIGZpbmFsbHkob25maW5hbGx5PzogKCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkIHwgbnVsbCk6IFByb21pc2U8V2l0aFJlcXVlc3RJRDxUPj4ge1xuICAgIHJldHVybiB0aGlzLnBhcnNlKCkuZmluYWxseShvbmZpbmFsbHkpO1xuICB9XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBUElDbGllbnQge1xuICBiYXNlVVJMOiBzdHJpbmc7XG4gIG1heFJldHJpZXM6IG51bWJlcjtcbiAgdGltZW91dDogbnVtYmVyO1xuICBodHRwQWdlbnQ6IEFnZW50IHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgZmV0Y2g6IEZldGNoO1xuICBwcm90ZWN0ZWQgaWRlbXBvdGVuY3lIZWFkZXI/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVUkwsXG4gICAgbWF4UmV0cmllcyA9IDIsXG4gICAgdGltZW91dCA9IDYwMDAwMCwgLy8gMTAgbWludXRlc1xuICAgIGh0dHBBZ2VudCxcbiAgICBmZXRjaDogb3ZlcnJpZGRlbkZldGNoLFxuICB9OiB7XG4gICAgYmFzZVVSTDogc3RyaW5nO1xuICAgIG1heFJldHJpZXM/OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgdGltZW91dDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGh0dHBBZ2VudDogQWdlbnQgfCB1bmRlZmluZWQ7XG4gICAgZmV0Y2g6IEZldGNoIHwgdW5kZWZpbmVkO1xuICB9KSB7XG4gICAgdGhpcy5iYXNlVVJMID0gYmFzZVVSTDtcbiAgICB0aGlzLm1heFJldHJpZXMgPSB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcignbWF4UmV0cmllcycsIG1heFJldHJpZXMpO1xuICAgIHRoaXMudGltZW91dCA9IHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKCd0aW1lb3V0JywgdGltZW91dCk7XG4gICAgdGhpcy5odHRwQWdlbnQgPSBodHRwQWdlbnQ7XG5cbiAgICB0aGlzLmZldGNoID0gb3ZlcnJpZGRlbkZldGNoID8/IGZldGNoO1xuICB9XG5cbiAgcHJvdGVjdGVkIGF1dGhIZWFkZXJzKG9wdHM6IEZpbmFsUmVxdWVzdE9wdGlvbnMpOiBIZWFkZXJzIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhpcyB0byBhZGQgeW91ciBvd24gZGVmYXVsdCBoZWFkZXJzLCBmb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHtcbiAgICogICAgLi4uc3VwZXIuZGVmYXVsdEhlYWRlcnMoKSxcbiAgICogICAgQXV0aG9yaXphdGlvbjogJ0JlYXJlciAxMjMnLFxuICAgKiAgfVxuICAgKi9cbiAgcHJvdGVjdGVkIGRlZmF1bHRIZWFkZXJzKG9wdHM6IEZpbmFsUmVxdWVzdE9wdGlvbnMpOiBIZWFkZXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ1VzZXItQWdlbnQnOiB0aGlzLmdldFVzZXJBZ2VudCgpLFxuICAgICAgLi4uZ2V0UGxhdGZvcm1IZWFkZXJzKCksXG4gICAgICAuLi50aGlzLmF1dGhIZWFkZXJzKG9wdHMpLFxuICAgIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZGVmYXVsdFF1ZXJ5KCk6IERlZmF1bHRRdWVyeSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhpcyB0byBhZGQgeW91ciBvd24gaGVhZGVycyB2YWxpZGF0aW9uOlxuICAgKi9cbiAgcHJvdGVjdGVkIHZhbGlkYXRlSGVhZGVycyhoZWFkZXJzOiBIZWFkZXJzLCBjdXN0b21IZWFkZXJzOiBIZWFkZXJzKSB7fVxuXG4gIHByb3RlY3RlZCBkZWZhdWx0SWRlbXBvdGVuY3lLZXkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYHN0YWlubGVzcy1ub2RlLXJldHJ5LSR7dXVpZDQoKX1gO1xuICB9XG5cbiAgZ2V0PFJlcSwgUnNwPihwYXRoOiBzdHJpbmcsIG9wdHM/OiBQcm9taXNlT3JWYWx1ZTxSZXF1ZXN0T3B0aW9uczxSZXE+Pik6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kUmVxdWVzdCgnZ2V0JywgcGF0aCwgb3B0cyk7XG4gIH1cblxuICBwb3N0PFJlcSwgUnNwPihwYXRoOiBzdHJpbmcsIG9wdHM/OiBQcm9taXNlT3JWYWx1ZTxSZXF1ZXN0T3B0aW9uczxSZXE+Pik6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kUmVxdWVzdCgncG9zdCcsIHBhdGgsIG9wdHMpO1xuICB9XG5cbiAgcGF0Y2g8UmVxLCBSc3A+KHBhdGg6IHN0cmluZywgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+KTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwYXRjaCcsIHBhdGgsIG9wdHMpO1xuICB9XG5cbiAgcHV0PFJlcSwgUnNwPihwYXRoOiBzdHJpbmcsIG9wdHM/OiBQcm9taXNlT3JWYWx1ZTxSZXF1ZXN0T3B0aW9uczxSZXE+Pik6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kUmVxdWVzdCgncHV0JywgcGF0aCwgb3B0cyk7XG4gIH1cblxuICBkZWxldGU8UmVxLCBSc3A+KHBhdGg6IHN0cmluZywgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+KTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdkZWxldGUnLCBwYXRoLCBvcHRzKTtcbiAgfVxuXG4gIHByaXZhdGUgbWV0aG9kUmVxdWVzdDxSZXEsIFJzcD4oXG4gICAgbWV0aG9kOiBIVFRQTWV0aG9kLFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRzPzogUHJvbWlzZU9yVmFsdWU8UmVxdWVzdE9wdGlvbnM8UmVxPj4sXG4gICk6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcbiAgICAgIFByb21pc2UucmVzb2x2ZShvcHRzKS50aGVuKGFzeW5jIChvcHRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPVxuICAgICAgICAgIG9wdHMgJiYgaXNCbG9iTGlrZShvcHRzPy5ib2R5KSA/IG5ldyBEYXRhVmlldyhhd2FpdCBvcHRzLmJvZHkuYXJyYXlCdWZmZXIoKSlcbiAgICAgICAgICA6IG9wdHM/LmJvZHkgaW5zdGFuY2VvZiBEYXRhVmlldyA/IG9wdHMuYm9keVxuICAgICAgICAgIDogb3B0cz8uYm9keSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IERhdGFWaWV3KG9wdHMuYm9keSlcbiAgICAgICAgICA6IG9wdHMgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KG9wdHM/LmJvZHkpID8gbmV3IERhdGFWaWV3KG9wdHMuYm9keS5idWZmZXIpXG4gICAgICAgICAgOiBvcHRzPy5ib2R5O1xuICAgICAgICByZXR1cm4geyBtZXRob2QsIHBhdGgsIC4uLm9wdHMsIGJvZHkgfTtcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBnZXRBUElMaXN0PEl0ZW0sIFBhZ2VDbGFzcyBleHRlbmRzIEFic3RyYWN0UGFnZTxJdGVtPiA9IEFic3RyYWN0UGFnZTxJdGVtPj4oXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIFBhZ2U6IG5ldyAoLi4uYXJnczogYW55W10pID0+IFBhZ2VDbGFzcyxcbiAgICBvcHRzPzogUmVxdWVzdE9wdGlvbnM8YW55PixcbiAgKTogUGFnZVByb21pc2U8UGFnZUNsYXNzLCBJdGVtPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdEFQSUxpc3QoUGFnZSwgeyBtZXRob2Q6ICdnZXQnLCBwYXRoLCAuLi5vcHRzIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVDb250ZW50TGVuZ3RoKGJvZHk6IHVua25vd24pOiBzdHJpbmcgfCBudWxsIHtcbiAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKGJvZHksICd1dGY4JykudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICBjb25zdCBlbmNvZGVkID0gZW5jb2Rlci5lbmNvZGUoYm9keSk7XG4gICAgICAgIHJldHVybiBlbmNvZGVkLmxlbmd0aC50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpKSB7XG4gICAgICByZXR1cm4gYm9keS5ieXRlTGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBidWlsZFJlcXVlc3Q8UmVxPihcbiAgICBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zPFJlcT4sXG4gICAgeyByZXRyeUNvdW50ID0gMCB9OiB7IHJldHJ5Q291bnQ/OiBudW1iZXIgfSA9IHt9LFxuICApOiB7IHJlcTogUmVxdWVzdEluaXQ7IHVybDogc3RyaW5nOyB0aW1lb3V0OiBudW1iZXIgfSB7XG4gICAgY29uc3QgeyBtZXRob2QsIHBhdGgsIHF1ZXJ5LCBoZWFkZXJzOiBoZWFkZXJzID0ge30gfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBib2R5ID1cbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyhvcHRpb25zLmJvZHkpIHx8IChvcHRpb25zLl9fYmluYXJ5UmVxdWVzdCAmJiB0eXBlb2Ygb3B0aW9ucy5ib2R5ID09PSAnc3RyaW5nJykgP1xuICAgICAgICBvcHRpb25zLmJvZHlcbiAgICAgIDogaXNNdWx0aXBhcnRCb2R5KG9wdGlvbnMuYm9keSkgPyBvcHRpb25zLmJvZHkuYm9keVxuICAgICAgOiBvcHRpb25zLmJvZHkgPyBKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvZHksIG51bGwsIDIpXG4gICAgICA6IG51bGw7XG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IHRoaXMuY2FsY3VsYXRlQ29udGVudExlbmd0aChib2R5KTtcblxuICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRVUkwocGF0aCEsIHF1ZXJ5KTtcbiAgICBpZiAoJ3RpbWVvdXQnIGluIG9wdGlvbnMpIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKCd0aW1lb3V0Jywgb3B0aW9ucy50aW1lb3V0KTtcbiAgICBjb25zdCB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0ID8/IHRoaXMudGltZW91dDtcbiAgICBjb25zdCBodHRwQWdlbnQgPSBvcHRpb25zLmh0dHBBZ2VudCA/PyB0aGlzLmh0dHBBZ2VudCA/PyBnZXREZWZhdWx0QWdlbnQodXJsKTtcbiAgICBjb25zdCBtaW5BZ2VudFRpbWVvdXQgPSB0aW1lb3V0ICsgMTAwMDtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgKGh0dHBBZ2VudCBhcyBhbnkpPy5vcHRpb25zPy50aW1lb3V0ID09PSAnbnVtYmVyJyAmJlxuICAgICAgbWluQWdlbnRUaW1lb3V0ID4gKChodHRwQWdlbnQgYXMgYW55KS5vcHRpb25zLnRpbWVvdXQgPz8gMClcbiAgICApIHtcbiAgICAgIC8vIEFsbG93IGFueSBnaXZlbiByZXF1ZXN0IHRvIGJ1bXAgb3VyIGFnZW50IGFjdGl2ZSBzb2NrZXQgdGltZW91dC5cbiAgICAgIC8vIFRoaXMgbWF5IHNlZW0gc3RyYW5nZSwgYnV0IGxlYWtpbmcgYWN0aXZlIHNvY2tldHMgc2hvdWxkIGJlIHJhcmUgYW5kIG5vdCBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMsXG4gICAgICAvLyBhbmQgd2l0aG91dCBtdXRhdGluZyBhZ2VudCB3ZSB3b3VsZCBuZWVkIHRvIGNyZWF0ZSBtb3JlIG9mIHRoZW0uXG4gICAgICAvLyBUaGlzIHRyYWRlb2ZmIG9wdGltaXplcyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAoaHR0cEFnZW50IGFzIGFueSkub3B0aW9ucy50aW1lb3V0ID0gbWluQWdlbnRUaW1lb3V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlkZW1wb3RlbmN5SGVhZGVyICYmIG1ldGhvZCAhPT0gJ2dldCcpIHtcbiAgICAgIGlmICghb3B0aW9ucy5pZGVtcG90ZW5jeUtleSkgb3B0aW9ucy5pZGVtcG90ZW5jeUtleSA9IHRoaXMuZGVmYXVsdElkZW1wb3RlbmN5S2V5KCk7XG4gICAgICBoZWFkZXJzW3RoaXMuaWRlbXBvdGVuY3lIZWFkZXJdID0gb3B0aW9ucy5pZGVtcG90ZW5jeUtleTtcbiAgICB9XG5cbiAgICBjb25zdCByZXFIZWFkZXJzID0gdGhpcy5idWlsZEhlYWRlcnMoeyBvcHRpb25zLCBoZWFkZXJzLCBjb250ZW50TGVuZ3RoLCByZXRyeUNvdW50IH0pO1xuXG4gICAgY29uc3QgcmVxOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIC4uLihib2R5ICYmIHsgYm9keTogYm9keSBhcyBhbnkgfSksXG4gICAgICBoZWFkZXJzOiByZXFIZWFkZXJzLFxuICAgICAgLi4uKGh0dHBBZ2VudCAmJiB7IGFnZW50OiBodHRwQWdlbnQgfSksXG4gICAgICAvLyBAdHMtaWdub3JlIG5vZGUtZmV0Y2ggdXNlcyBhIGN1c3RvbSBBYm9ydFNpZ25hbCB0eXBlIHRoYXQgaXNcbiAgICAgIC8vIG5vdCBjb21wYXRpYmxlIHdpdGggc3RhbmRhcmQgd2ViIHR5cGVzXG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsID8/IG51bGwsXG4gICAgfTtcblxuICAgIHJldHVybiB7IHJlcSwgdXJsLCB0aW1lb3V0IH07XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkSGVhZGVycyh7XG4gICAgb3B0aW9ucyxcbiAgICBoZWFkZXJzLFxuICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgcmV0cnlDb3VudCxcbiAgfToge1xuICAgIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnM7XG4gICAgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZD47XG4gICAgY29udGVudExlbmd0aDogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgICByZXRyeUNvdW50OiBudW1iZXI7XG4gIH0pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICBjb25zdCByZXFIZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgaWYgKGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIHJlcUhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPSBjb250ZW50TGVuZ3RoO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRIZWFkZXJzID0gdGhpcy5kZWZhdWx0SGVhZGVycyhvcHRpb25zKTtcbiAgICBhcHBseUhlYWRlcnNNdXQocmVxSGVhZGVycywgZGVmYXVsdEhlYWRlcnMpO1xuICAgIGFwcGx5SGVhZGVyc011dChyZXFIZWFkZXJzLCBoZWFkZXJzKTtcblxuICAgIC8vIGxldCBidWlsdGluIGZldGNoIHNldCB0aGUgQ29udGVudC1UeXBlIGZvciBtdWx0aXBhcnQgYm9kaWVzXG4gICAgaWYgKGlzTXVsdGlwYXJ0Qm9keShvcHRpb25zLmJvZHkpICYmIHNoaW1zS2luZCAhPT0gJ25vZGUnKSB7XG4gICAgICBkZWxldGUgcmVxSGVhZGVyc1snY29udGVudC10eXBlJ107XG4gICAgfVxuXG4gICAgLy8gRG9uJ3Qgc2V0IHRoZSByZXRyeSBjb3VudCBoZWFkZXIgaWYgaXQgd2FzIGFscmVhZHkgc2V0IG9yIHJlbW92ZWQgdGhyb3VnaCBkZWZhdWx0IGhlYWRlcnMgb3IgYnkgdGhlXG4gICAgLy8gY2FsbGVyLiBXZSBjaGVjayBgZGVmYXVsdEhlYWRlcnNgIGFuZCBgaGVhZGVyc2AsIHdoaWNoIGNhbiBjb250YWluIG51bGxzLCBpbnN0ZWFkIG9mIGByZXFIZWFkZXJzYCB0b1xuICAgIC8vIGFjY291bnQgZm9yIHRoZSByZW1vdmFsIGNhc2UuXG4gICAgaWYgKFxuICAgICAgZ2V0SGVhZGVyKGRlZmF1bHRIZWFkZXJzLCAneC1zdGFpbmxlc3MtcmV0cnktY291bnQnKSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICBnZXRIZWFkZXIoaGVhZGVycywgJ3gtc3RhaW5sZXNzLXJldHJ5LWNvdW50JykgPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgcmVxSGVhZGVyc1sneC1zdGFpbmxlc3MtcmV0cnktY291bnQnXSA9IFN0cmluZyhyZXRyeUNvdW50KTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbGlkYXRlSGVhZGVycyhyZXFIZWFkZXJzLCBoZWFkZXJzKTtcblxuICAgIHJldHVybiByZXFIZWFkZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYXMgYSBjYWxsYmFjayBmb3IgbXV0YXRpbmcgdGhlIGdpdmVuIGBGaW5hbFJlcXVlc3RPcHRpb25zYCBvYmplY3QuXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgcHJlcGFyZU9wdGlvbnMob3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge31cblxuICAvKipcbiAgICogVXNlZCBhcyBhIGNhbGxiYWNrIGZvciBtdXRhdGluZyB0aGUgZ2l2ZW4gYFJlcXVlc3RJbml0YCBvYmplY3QuXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlcyB3aGVyZSB5b3Ugd2FudCB0byBhZGQgY2VydGFpbiBoZWFkZXJzIGJhc2VkIG9mZiBvZlxuICAgKiB0aGUgcmVxdWVzdCBwcm9wZXJ0aWVzLCBlLmcuIGBtZXRob2RgIG9yIGB1cmxgLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIHByZXBhcmVSZXF1ZXN0KFxuICAgIHJlcXVlc3Q6IFJlcXVlc3RJbml0LFxuICAgIHsgdXJsLCBvcHRpb25zIH06IHsgdXJsOiBzdHJpbmc7IG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnMgfSxcbiAgKTogUHJvbWlzZTx2b2lkPiB7fVxuXG4gIHByb3RlY3RlZCBwYXJzZUhlYWRlcnMoaGVhZGVyczogSGVhZGVyc0luaXQgfCBudWxsIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIChcbiAgICAgICFoZWFkZXJzID8ge31cbiAgICAgIDogU3ltYm9sLml0ZXJhdG9yIGluIGhlYWRlcnMgP1xuICAgICAgICBPYmplY3QuZnJvbUVudHJpZXMoQXJyYXkuZnJvbShoZWFkZXJzIGFzIEl0ZXJhYmxlPHN0cmluZ1tdPikubWFwKChoZWFkZXIpID0+IFsuLi5oZWFkZXJdKSlcbiAgICAgIDogeyAuLi5oZWFkZXJzIH1cbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG1ha2VTdGF0dXNFcnJvcihcbiAgICBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgICBlcnJvcjogT2JqZWN0IHwgdW5kZWZpbmVkLFxuICAgIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBoZWFkZXJzOiBIZWFkZXJzIHwgdW5kZWZpbmVkLFxuICApOiBBUElFcnJvciB7XG4gICAgcmV0dXJuIEFQSUVycm9yLmdlbmVyYXRlKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICB9XG5cbiAgcmVxdWVzdDxSZXEsIFJzcD4oXG4gICAgb3B0aW9uczogUHJvbWlzZU9yVmFsdWU8RmluYWxSZXF1ZXN0T3B0aW9uczxSZXE+PixcbiAgICByZW1haW5pbmdSZXRyaWVzOiBudW1iZXIgfCBudWxsID0gbnVsbCxcbiAgKTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gbmV3IEFQSVByb21pc2UodGhpcy5tYWtlUmVxdWVzdChvcHRpb25zLCByZW1haW5pbmdSZXRyaWVzKSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIG1ha2VSZXF1ZXN0PFJlcT4oXG4gICAgb3B0aW9uc0lucHV0OiBQcm9taXNlT3JWYWx1ZTxGaW5hbFJlcXVlc3RPcHRpb25zPFJlcT4+LFxuICAgIHJldHJpZXNSZW1haW5pbmc6IG51bWJlciB8IG51bGwsXG4gICk6IFByb21pc2U8QVBJUmVzcG9uc2VQcm9wcz4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBvcHRpb25zSW5wdXQ7XG4gICAgY29uc3QgbWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcyA/PyB0aGlzLm1heFJldHJpZXM7XG4gICAgaWYgKHJldHJpZXNSZW1haW5pbmcgPT0gbnVsbCkge1xuICAgICAgcmV0cmllc1JlbWFpbmluZyA9IG1heFJldHJpZXM7XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5wcmVwYXJlT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIGNvbnN0IHsgcmVxLCB1cmwsIHRpbWVvdXQgfSA9IHRoaXMuYnVpbGRSZXF1ZXN0KG9wdGlvbnMsIHsgcmV0cnlDb3VudDogbWF4UmV0cmllcyAtIHJldHJpZXNSZW1haW5pbmcgfSk7XG5cbiAgICBhd2FpdCB0aGlzLnByZXBhcmVSZXF1ZXN0KHJlcSwgeyB1cmwsIG9wdGlvbnMgfSk7XG5cbiAgICBkZWJ1ZygncmVxdWVzdCcsIHVybCwgb3B0aW9ucywgcmVxLmhlYWRlcnMpO1xuXG4gICAgaWYgKG9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaFdpdGhUaW1lb3V0KHVybCwgcmVxLCB0aW1lb3V0LCBjb250cm9sbGVyKS5jYXRjaChjYXN0VG9FcnJvcik7XG5cbiAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgICAgfVxuICAgICAgaWYgKHJldHJpZXNSZW1haW5pbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KG9wdGlvbnMsIHJldHJpZXNSZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3BvbnNlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICB0aHJvdyBuZXcgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcigpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEFQSUNvbm5lY3Rpb25FcnJvcih7IGNhdXNlOiByZXNwb25zZSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBjcmVhdGVSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmV0cmllc1JlbWFpbmluZyAmJiB0aGlzLnNob3VsZFJldHJ5KHJlc3BvbnNlKSkge1xuICAgICAgICBjb25zdCByZXRyeU1lc3NhZ2UgPSBgcmV0cnlpbmcsICR7cmV0cmllc1JlbWFpbmluZ30gYXR0ZW1wdHMgcmVtYWluaW5nYDtcbiAgICAgICAgZGVidWcoYHJlc3BvbnNlIChlcnJvcjsgJHtyZXRyeU1lc3NhZ2V9KWAsIHJlc3BvbnNlLnN0YXR1cywgdXJsLCByZXNwb25zZUhlYWRlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3Qob3B0aW9ucywgcmV0cmllc1JlbWFpbmluZywgcmVzcG9uc2VIZWFkZXJzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXJyVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoZSkgPT4gY2FzdFRvRXJyb3IoZSkubWVzc2FnZSk7XG4gICAgICBjb25zdCBlcnJKU09OID0gc2FmZUpTT04oZXJyVGV4dCk7XG4gICAgICBjb25zdCBlcnJNZXNzYWdlID0gZXJySlNPTiA/IHVuZGVmaW5lZCA6IGVyclRleHQ7XG4gICAgICBjb25zdCByZXRyeU1lc3NhZ2UgPSByZXRyaWVzUmVtYWluaW5nID8gYChlcnJvcjsgbm8gbW9yZSByZXRyaWVzIGxlZnQpYCA6IGAoZXJyb3I7IG5vdCByZXRyeWFibGUpYDtcblxuICAgICAgZGVidWcoYHJlc3BvbnNlIChlcnJvcjsgJHtyZXRyeU1lc3NhZ2V9KWAsIHJlc3BvbnNlLnN0YXR1cywgdXJsLCByZXNwb25zZUhlYWRlcnMsIGVyck1lc3NhZ2UpO1xuXG4gICAgICBjb25zdCBlcnIgPSB0aGlzLm1ha2VTdGF0dXNFcnJvcihyZXNwb25zZS5zdGF0dXMsIGVyckpTT04sIGVyck1lc3NhZ2UsIHJlc3BvbnNlSGVhZGVycyk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcmVzcG9uc2UsIG9wdGlvbnMsIGNvbnRyb2xsZXIgfTtcbiAgfVxuXG4gIHJlcXVlc3RBUElMaXN0PEl0ZW0gPSB1bmtub3duLCBQYWdlQ2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFBhZ2U8SXRlbT4gPSBBYnN0cmFjdFBhZ2U8SXRlbT4+KFxuICAgIFBhZ2U6IG5ldyAoLi4uYXJnczogQ29uc3RydWN0b3JQYXJhbWV0ZXJzPHR5cGVvZiBBYnN0cmFjdFBhZ2U+KSA9PiBQYWdlQ2xhc3MsXG4gICAgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucyxcbiAgKTogUGFnZVByb21pc2U8UGFnZUNsYXNzLCBJdGVtPiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHRoaXMubWFrZVJlcXVlc3Qob3B0aW9ucywgbnVsbCk7XG4gICAgcmV0dXJuIG5ldyBQYWdlUHJvbWlzZTxQYWdlQ2xhc3MsIEl0ZW0+KHRoaXMsIHJlcXVlc3QsIFBhZ2UpO1xuICB9XG5cbiAgYnVpbGRVUkw8UmVxPihwYXRoOiBzdHJpbmcsIHF1ZXJ5OiBSZXEgfCBudWxsIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgICBjb25zdCB1cmwgPVxuICAgICAgaXNBYnNvbHV0ZVVSTChwYXRoKSA/XG4gICAgICAgIG5ldyBVUkwocGF0aClcbiAgICAgIDogbmV3IFVSTCh0aGlzLmJhc2VVUkwgKyAodGhpcy5iYXNlVVJMLmVuZHNXaXRoKCcvJykgJiYgcGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoLnNsaWNlKDEpIDogcGF0aCkpO1xuXG4gICAgY29uc3QgZGVmYXVsdFF1ZXJ5ID0gdGhpcy5kZWZhdWx0UXVlcnkoKTtcbiAgICBpZiAoIWlzRW1wdHlPYmooZGVmYXVsdFF1ZXJ5KSkge1xuICAgICAgcXVlcnkgPSB7IC4uLmRlZmF1bHRRdWVyeSwgLi4ucXVlcnkgfSBhcyBSZXE7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcgJiYgcXVlcnkgJiYgIUFycmF5LmlzQXJyYXkocXVlcnkpKSB7XG4gICAgICB1cmwuc2VhcmNoID0gdGhpcy5zdHJpbmdpZnlRdWVyeShxdWVyeSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHN0cmluZyB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHF1ZXJ5KVxuICAgICAgLmZpbHRlcigoW18sIHZhbHVlXSkgPT4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJylcbiAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICAgIGBDYW5ub3Qgc3RyaW5naWZ5IHR5cGUgJHt0eXBlb2YgdmFsdWV9OyBFeHBlY3RlZCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgbnVsbC4gSWYgeW91IG5lZWQgdG8gcGFzcyBuZXN0ZWQgcXVlcnkgcGFyYW1ldGVycywgeW91IGNhbiBtYW51YWxseSBlbmNvZGUgdGhlbSwgZS5nLiB7IHF1ZXJ5OiB7ICdmb29ba2V5MV0nOiB2YWx1ZTEsICdmb29ba2V5Ml0nOiB2YWx1ZTIgfSB9LCBhbmQgcGxlYXNlIG9wZW4gYSBHaXRIdWIgaXNzdWUgcmVxdWVzdGluZyBiZXR0ZXIgc3VwcG9ydCBmb3IgeW91ciB1c2UgY2FzZS5gLFxuICAgICAgICApO1xuICAgICAgfSlcbiAgICAgIC5qb2luKCcmJyk7XG4gIH1cblxuICBhc3luYyBmZXRjaFdpdGhUaW1lb3V0KFxuICAgIHVybDogUmVxdWVzdEluZm8sXG4gICAgaW5pdDogUmVxdWVzdEluaXQgfCB1bmRlZmluZWQsXG4gICAgbXM6IG51bWJlcixcbiAgICBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIsXG4gICk6IFByb21pc2U8UmVzcG9uc2U+IHtcbiAgICBjb25zdCB7IHNpZ25hbCwgLi4ub3B0aW9ucyB9ID0gaW5pdCB8fCB7fTtcbiAgICBpZiAoc2lnbmFsKSBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiBjb250cm9sbGVyLmFib3J0KCkpO1xuXG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCBtcyk7XG5cbiAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIGFzIGFueSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcbiAgICBpZiAoZmV0Y2hPcHRpb25zLm1ldGhvZCkge1xuICAgICAgLy8gQ3VzdG9tIG1ldGhvZHMgbGlrZSAncGF0Y2gnIG5lZWQgdG8gYmUgdXBwZXJjYXNlZFxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMjk0XG4gICAgICBmZXRjaE9wdGlvbnMubWV0aG9kID0gZmV0Y2hPcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAvLyB1c2UgdW5kZWZpbmVkIHRoaXMgYmluZGluZzsgZmV0Y2ggZXJyb3JzIGlmIGJvdW5kIHRvIHNvbWV0aGluZyBlbHNlIGluIGJyb3dzZXIvY2xvdWRmbGFyZVxuICAgICAgdGhpcy5mZXRjaC5jYWxsKHVuZGVmaW5lZCwgdXJsLCBmZXRjaE9wdGlvbnMpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHNob3VsZFJldHJ5KHJlc3BvbnNlOiBSZXNwb25zZSk6IGJvb2xlYW4ge1xuICAgIC8vIE5vdGUgdGhpcyBpcyBub3QgYSBzdGFuZGFyZCBoZWFkZXIuXG4gICAgY29uc3Qgc2hvdWxkUmV0cnlIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1zaG91bGQtcmV0cnknKTtcblxuICAgIC8vIElmIHRoZSBzZXJ2ZXIgZXhwbGljaXRseSBzYXlzIHdoZXRoZXIgb3Igbm90IHRvIHJldHJ5LCBvYmV5LlxuICAgIGlmIChzaG91bGRSZXRyeUhlYWRlciA9PT0gJ3RydWUnKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoc2hvdWxkUmV0cnlIZWFkZXIgPT09ICdmYWxzZScpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIFJldHJ5IG9uIHJlcXVlc3QgdGltZW91dHMuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA4KSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIFJldHJ5IG9uIGxvY2sgdGltZW91dHMuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA5KSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIFJldHJ5IG9uIHJhdGUgbGltaXRzLlxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBSZXRyeSBpbnRlcm5hbCBlcnJvcnMuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA1MDApIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZXRyeVJlcXVlc3QoXG4gICAgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucyxcbiAgICByZXRyaWVzUmVtYWluaW5nOiBudW1iZXIsXG4gICAgcmVzcG9uc2VIZWFkZXJzPzogSGVhZGVycyB8IHVuZGVmaW5lZCxcbiAgKTogUHJvbWlzZTxBUElSZXNwb25zZVByb3BzPiB7XG4gICAgbGV0IHRpbWVvdXRNaWxsaXM6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICAgIC8vIE5vdGUgdGhlIGByZXRyeS1hZnRlci1tc2AgaGVhZGVyIG1heSBub3QgYmUgc3RhbmRhcmQsIGJ1dCBpcyBhIGdvb2QgaWRlYSBhbmQgd2UnZCBsaWtlIHByb2FjdGl2ZSBzdXBwb3J0IGZvciBpdC5cbiAgICBjb25zdCByZXRyeUFmdGVyTWlsbGlzSGVhZGVyID0gcmVzcG9uc2VIZWFkZXJzPy5bJ3JldHJ5LWFmdGVyLW1zJ107XG4gICAgaWYgKHJldHJ5QWZ0ZXJNaWxsaXNIZWFkZXIpIHtcbiAgICAgIGNvbnN0IHRpbWVvdXRNcyA9IHBhcnNlRmxvYXQocmV0cnlBZnRlck1pbGxpc0hlYWRlcik7XG4gICAgICBpZiAoIU51bWJlci5pc05hTih0aW1lb3V0TXMpKSB7XG4gICAgICAgIHRpbWVvdXRNaWxsaXMgPSB0aW1lb3V0TXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWJvdXQgdGhlIFJldHJ5LUFmdGVyIGhlYWRlcjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1JldHJ5LUFmdGVyXG4gICAgY29uc3QgcmV0cnlBZnRlckhlYWRlciA9IHJlc3BvbnNlSGVhZGVycz8uWydyZXRyeS1hZnRlciddO1xuICAgIGlmIChyZXRyeUFmdGVySGVhZGVyICYmICF0aW1lb3V0TWlsbGlzKSB7XG4gICAgICBjb25zdCB0aW1lb3V0U2Vjb25kcyA9IHBhcnNlRmxvYXQocmV0cnlBZnRlckhlYWRlcik7XG4gICAgICBpZiAoIU51bWJlci5pc05hTih0aW1lb3V0U2Vjb25kcykpIHtcbiAgICAgICAgdGltZW91dE1pbGxpcyA9IHRpbWVvdXRTZWNvbmRzICogMTAwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXRNaWxsaXMgPSBEYXRlLnBhcnNlKHJldHJ5QWZ0ZXJIZWFkZXIpIC0gRGF0ZS5ub3coKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgQVBJIGFza3MgdXMgdG8gd2FpdCBhIGNlcnRhaW4gYW1vdW50IG9mIHRpbWUgKGFuZCBpdCdzIGEgcmVhc29uYWJsZSBhbW91bnQpLFxuICAgIC8vIGp1c3QgZG8gd2hhdCBpdCBzYXlzLCBidXQgb3RoZXJ3aXNlIGNhbGN1bGF0ZSBhIGRlZmF1bHRcbiAgICBpZiAoISh0aW1lb3V0TWlsbGlzICYmIDAgPD0gdGltZW91dE1pbGxpcyAmJiB0aW1lb3V0TWlsbGlzIDwgNjAgKiAxMDAwKSkge1xuICAgICAgY29uc3QgbWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcyA/PyB0aGlzLm1heFJldHJpZXM7XG4gICAgICB0aW1lb3V0TWlsbGlzID0gdGhpcy5jYWxjdWxhdGVEZWZhdWx0UmV0cnlUaW1lb3V0TWlsbGlzKHJldHJpZXNSZW1haW5pbmcsIG1heFJldHJpZXMpO1xuICAgIH1cbiAgICBhd2FpdCBzbGVlcCh0aW1lb3V0TWlsbGlzKTtcblxuICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KG9wdGlvbnMsIHJldHJpZXNSZW1haW5pbmcgLSAxKTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlRGVmYXVsdFJldHJ5VGltZW91dE1pbGxpcyhyZXRyaWVzUmVtYWluaW5nOiBudW1iZXIsIG1heFJldHJpZXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgaW5pdGlhbFJldHJ5RGVsYXkgPSAwLjU7XG4gICAgY29uc3QgbWF4UmV0cnlEZWxheSA9IDguMDtcblxuICAgIGNvbnN0IG51bVJldHJpZXMgPSBtYXhSZXRyaWVzIC0gcmV0cmllc1JlbWFpbmluZztcblxuICAgIC8vIEFwcGx5IGV4cG9uZW50aWFsIGJhY2tvZmYsIGJ1dCBub3QgbW9yZSB0aGFuIHRoZSBtYXguXG4gICAgY29uc3Qgc2xlZXBTZWNvbmRzID0gTWF0aC5taW4oaW5pdGlhbFJldHJ5RGVsYXkgKiBNYXRoLnBvdygyLCBudW1SZXRyaWVzKSwgbWF4UmV0cnlEZWxheSk7XG5cbiAgICAvLyBBcHBseSBzb21lIGppdHRlciwgdGFrZSB1cCB0byBhdCBtb3N0IDI1IHBlcmNlbnQgb2YgdGhlIHJldHJ5IHRpbWUuXG4gICAgY29uc3Qgaml0dGVyID0gMSAtIE1hdGgucmFuZG9tKCkgKiAwLjI1O1xuXG4gICAgcmV0dXJuIHNsZWVwU2Vjb25kcyAqIGppdHRlciAqIDEwMDA7XG4gIH1cblxuICBwcml2YXRlIGdldFVzZXJBZ2VudCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9L0pTICR7VkVSU0lPTn1gO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFBhZ2VJbmZvID0geyB1cmw6IFVSTCB9IHwgeyBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgbnVsbCB9O1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RQYWdlPEl0ZW0+IGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZTxJdGVtPiB7XG4gICNjbGllbnQ6IEFQSUNsaWVudDtcbiAgcHJvdGVjdGVkIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnM7XG5cbiAgcHJvdGVjdGVkIHJlc3BvbnNlOiBSZXNwb25zZTtcbiAgcHJvdGVjdGVkIGJvZHk6IHVua25vd247XG5cbiAgY29uc3RydWN0b3IoY2xpZW50OiBBUElDbGllbnQsIHJlc3BvbnNlOiBSZXNwb25zZSwgYm9keTogdW5rbm93biwgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucykge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBuZXh0UGFnZUluZm8gaW5zdGVhZFxuICAgKi9cbiAgYWJzdHJhY3QgbmV4dFBhZ2VQYXJhbXMoKTogUGFydGlhbDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4gfCBudWxsO1xuICBhYnN0cmFjdCBuZXh0UGFnZUluZm8oKTogUGFnZUluZm8gfCBudWxsO1xuXG4gIGFic3RyYWN0IGdldFBhZ2luYXRlZEl0ZW1zKCk6IEl0ZW1bXTtcblxuICBoYXNOZXh0UGFnZSgpOiBib29sZWFuIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuZ2V0UGFnaW5hdGVkSXRlbXMoKTtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLm5leHRQYWdlSW5mbygpICE9IG51bGw7XG4gIH1cblxuICBhc3luYyBnZXROZXh0UGFnZSgpOiBQcm9taXNlPHRoaXM+IHtcbiAgICBjb25zdCBuZXh0SW5mbyA9IHRoaXMubmV4dFBhZ2VJbmZvKCk7XG4gICAgaWYgKCFuZXh0SW5mbykge1xuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICAnTm8gbmV4dCBwYWdlIGV4cGVjdGVkOyBwbGVhc2UgY2hlY2sgYC5oYXNOZXh0UGFnZSgpYCBiZWZvcmUgY2FsbGluZyBgLmdldE5leHRQYWdlKClgLicsXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBuZXh0T3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zIH07XG4gICAgaWYgKCdwYXJhbXMnIGluIG5leHRJbmZvICYmIHR5cGVvZiBuZXh0T3B0aW9ucy5xdWVyeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG5leHRPcHRpb25zLnF1ZXJ5ID0geyAuLi5uZXh0T3B0aW9ucy5xdWVyeSwgLi4ubmV4dEluZm8ucGFyYW1zIH07XG4gICAgfSBlbHNlIGlmICgndXJsJyBpbiBuZXh0SW5mbykge1xuICAgICAgY29uc3QgcGFyYW1zID0gWy4uLk9iamVjdC5lbnRyaWVzKG5leHRPcHRpb25zLnF1ZXJ5IHx8IHt9KSwgLi4ubmV4dEluZm8udXJsLnNlYXJjaFBhcmFtcy5lbnRyaWVzKCldO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcGFyYW1zKSB7XG4gICAgICAgIG5leHRJbmZvLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgdmFsdWUgYXMgYW55KTtcbiAgICAgIH1cbiAgICAgIG5leHRPcHRpb25zLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgbmV4dE9wdGlvbnMucGF0aCA9IG5leHRJbmZvLnVybC50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2xpZW50LnJlcXVlc3RBUElMaXN0KHRoaXMuY29uc3RydWN0b3IgYXMgYW55LCBuZXh0T3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyAqaXRlclBhZ2VzKCk6IEFzeW5jR2VuZXJhdG9yPHRoaXM+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICBsZXQgcGFnZTogdGhpcyA9IHRoaXM7XG4gICAgeWllbGQgcGFnZTtcbiAgICB3aGlsZSAocGFnZS5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICBwYWdlID0gYXdhaXQgcGFnZS5nZXROZXh0UGFnZSgpO1xuICAgICAgeWllbGQgcGFnZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpOiBBc3luY0dlbmVyYXRvcjxJdGVtPiB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBwYWdlIG9mIHRoaXMuaXRlclBhZ2VzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBwYWdlLmdldFBhZ2luYXRlZEl0ZW1zKCkpIHtcbiAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHN1YmNsYXNzIG9mIFByb21pc2Ugd2lsbCByZXNvbHZlIHRvIGFuIGluc3RhbnRpYXRlZCBQYWdlIG9uY2UgdGhlIHJlcXVlc3QgY29tcGxldGVzLlxuICpcbiAqIEl0IGFsc28gaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlIHRvIGFsbG93IGF1dG8tcGFnaW5hdGluZyBpdGVyYXRpb24gb24gYW4gdW5hd2FpdGVkIGxpc3QgY2FsbCwgZWc6XG4gKlxuICogICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGNsaWVudC5pdGVtcy5saXN0KCkpIHtcbiAqICAgICAgY29uc29sZS5sb2coaXRlbSlcbiAqICAgIH1cbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2VQcm9taXNlPFxuICAgIFBhZ2VDbGFzcyBleHRlbmRzIEFic3RyYWN0UGFnZTxJdGVtPixcbiAgICBJdGVtID0gUmV0dXJuVHlwZTxQYWdlQ2xhc3NbJ2dldFBhZ2luYXRlZEl0ZW1zJ10+W251bWJlcl0sXG4gID5cbiAgZXh0ZW5kcyBBUElQcm9taXNlPFBhZ2VDbGFzcz5cbiAgaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPEl0ZW0+XG57XG4gIGNvbnN0cnVjdG9yKFxuICAgIGNsaWVudDogQVBJQ2xpZW50LFxuICAgIHJlcXVlc3Q6IFByb21pc2U8QVBJUmVzcG9uc2VQcm9wcz4sXG4gICAgUGFnZTogbmV3ICguLi5hcmdzOiBDb25zdHJ1Y3RvclBhcmFtZXRlcnM8dHlwZW9mIEFic3RyYWN0UGFnZT4pID0+IFBhZ2VDbGFzcyxcbiAgKSB7XG4gICAgc3VwZXIoXG4gICAgICByZXF1ZXN0LFxuICAgICAgYXN5bmMgKHByb3BzKSA9PlxuICAgICAgICBuZXcgUGFnZShcbiAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgcHJvcHMucmVzcG9uc2UsXG4gICAgICAgICAgYXdhaXQgZGVmYXVsdFBhcnNlUmVzcG9uc2UocHJvcHMpLFxuICAgICAgICAgIHByb3BzLm9wdGlvbnMsXG4gICAgICAgICkgYXMgV2l0aFJlcXVlc3RJRDxQYWdlQ2xhc3M+LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgYXV0by1wYWdpbmF0aW5nIGl0ZXJhdGlvbiBvbiBhbiB1bmF3YWl0ZWQgbGlzdCBjYWxsLCBlZzpcbiAgICpcbiAgICogICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGNsaWVudC5pdGVtcy5saXN0KCkpIHtcbiAgICogICAgICBjb25zb2xlLmxvZyhpdGVtKVxuICAgKiAgICB9XG4gICAqL1xuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpOiBBc3luY0dlbmVyYXRvcjxJdGVtPiB7XG4gICAgY29uc3QgcGFnZSA9IGF3YWl0IHRoaXM7XG4gICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIHBhZ2UpIHtcbiAgICAgIHlpZWxkIGl0ZW07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSZXNwb25zZUhlYWRlcnMgPSAoXG4gIGhlYWRlcnM6IEF3YWl0ZWQ8UmV0dXJuVHlwZTxGZXRjaD4+WydoZWFkZXJzJ10sXG4pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0+IHtcbiAgcmV0dXJuIG5ldyBQcm94eShcbiAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBoZWFkZXJzLmVudHJpZXMoKSxcbiAgICApLFxuICAgIHtcbiAgICAgIGdldCh0YXJnZXQsIG5hbWUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbmFtZS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2tleS50b0xvd2VyQ2FzZSgpXSB8fCB0YXJnZXRba2V5XTtcbiAgICAgIH0sXG4gICAgfSxcbiAgKTtcbn07XG5cbnR5cGUgSFRUUE1ldGhvZCA9ICdnZXQnIHwgJ3Bvc3QnIHwgJ3B1dCcgfCAncGF0Y2gnIHwgJ2RlbGV0ZSc7XG5cbmV4cG9ydCB0eXBlIFJlcXVlc3RDbGllbnQgPSB7IGZldGNoOiBGZXRjaCB9O1xuZXhwb3J0IHR5cGUgSGVhZGVycyA9IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ+O1xuZXhwb3J0IHR5cGUgRGVmYXVsdFF1ZXJ5ID0gUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPjtcbmV4cG9ydCB0eXBlIEtleXNFbnVtPFQ+ID0geyBbUCBpbiBrZXlvZiBSZXF1aXJlZDxUPl06IHRydWUgfTtcblxuZXhwb3J0IHR5cGUgUmVxdWVzdE9wdGlvbnM8XG4gIFJlcSA9IHVua25vd24gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IFJlYWRhYmxlIHwgQmxvYkxpa2UgfCBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlcixcbj4gPSB7XG4gIG1ldGhvZD86IEhUVFBNZXRob2Q7XG4gIHBhdGg/OiBzdHJpbmc7XG4gIHF1ZXJ5PzogUmVxIHwgdW5kZWZpbmVkO1xuICBib2R5PzogUmVxIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgaGVhZGVycz86IEhlYWRlcnMgfCB1bmRlZmluZWQ7XG5cbiAgbWF4UmV0cmllcz86IG51bWJlcjtcbiAgc3RyZWFtPzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgdGltZW91dD86IG51bWJlcjtcbiAgaHR0cEFnZW50PzogQWdlbnQ7XG4gIHNpZ25hbD86IEFib3J0U2lnbmFsIHwgdW5kZWZpbmVkIHwgbnVsbDtcbiAgaWRlbXBvdGVuY3lLZXk/OiBzdHJpbmc7XG5cbiAgX19iaW5hcnlSZXF1ZXN0PzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgX19iaW5hcnlSZXNwb25zZT86IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gIF9fc3RyZWFtQ2xhc3M/OiB0eXBlb2YgU3RyZWFtO1xufTtcblxuLy8gVGhpcyBpcyByZXF1aXJlZCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgaWYgYSBnaXZlbiBvYmplY3QgbWF0Y2hlcyB0aGUgUmVxdWVzdE9wdGlvbnNcbi8vIHR5cGUgYXQgcnVudGltZS4gV2hpbGUgdGhpcyByZXF1aXJlcyBkdXBsaWNhdGlvbiwgaXQgaXMgZW5mb3JjZWQgYnkgdGhlIFR5cGVTY3JpcHRcbi8vIGNvbXBpbGVyIHN1Y2ggdGhhdCBhbnkgbWlzc2luZyAvIGV4dHJhbmVvdXMga2V5cyB3aWxsIGNhdXNlIGFuIGVycm9yLlxuY29uc3QgcmVxdWVzdE9wdGlvbnNLZXlzOiBLZXlzRW51bTxSZXF1ZXN0T3B0aW9ucz4gPSB7XG4gIG1ldGhvZDogdHJ1ZSxcbiAgcGF0aDogdHJ1ZSxcbiAgcXVlcnk6IHRydWUsXG4gIGJvZHk6IHRydWUsXG4gIGhlYWRlcnM6IHRydWUsXG5cbiAgbWF4UmV0cmllczogdHJ1ZSxcbiAgc3RyZWFtOiB0cnVlLFxuICB0aW1lb3V0OiB0cnVlLFxuICBodHRwQWdlbnQ6IHRydWUsXG4gIHNpZ25hbDogdHJ1ZSxcbiAgaWRlbXBvdGVuY3lLZXk6IHRydWUsXG5cbiAgX19iaW5hcnlSZXF1ZXN0OiB0cnVlLFxuICBfX2JpbmFyeVJlc3BvbnNlOiB0cnVlLFxuICBfX3N0cmVhbUNsYXNzOiB0cnVlLFxufTtcblxuZXhwb3J0IGNvbnN0IGlzUmVxdWVzdE9wdGlvbnMgPSAob2JqOiB1bmtub3duKTogb2JqIGlzIFJlcXVlc3RPcHRpb25zID0+IHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJlxuICAgIG9iaiAhPT0gbnVsbCAmJlxuICAgICFpc0VtcHR5T2JqKG9iaikgJiZcbiAgICBPYmplY3Qua2V5cyhvYmopLmV2ZXJ5KChrKSA9PiBoYXNPd24ocmVxdWVzdE9wdGlvbnNLZXlzLCBrKSlcbiAgKTtcbn07XG5cbmV4cG9ydCB0eXBlIEZpbmFsUmVxdWVzdE9wdGlvbnM8UmVxID0gdW5rbm93biB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgUmVhZGFibGUgfCBEYXRhVmlldz4gPVxuICBSZXF1ZXN0T3B0aW9uczxSZXE+ICYge1xuICAgIG1ldGhvZDogSFRUUE1ldGhvZDtcbiAgICBwYXRoOiBzdHJpbmc7XG4gIH07XG5cbmRlY2xhcmUgY29uc3QgRGVubzogYW55O1xuZGVjbGFyZSBjb25zdCBFZGdlUnVudGltZTogYW55O1xudHlwZSBBcmNoID0gJ3gzMicgfCAneDY0JyB8ICdhcm0nIHwgJ2FybTY0JyB8IGBvdGhlcjoke3N0cmluZ31gIHwgJ3Vua25vd24nO1xudHlwZSBQbGF0Zm9ybU5hbWUgPVxuICB8ICdNYWNPUydcbiAgfCAnTGludXgnXG4gIHwgJ1dpbmRvd3MnXG4gIHwgJ0ZyZWVCU0QnXG4gIHwgJ09wZW5CU0QnXG4gIHwgJ2lPUydcbiAgfCAnQW5kcm9pZCdcbiAgfCBgT3RoZXI6JHtzdHJpbmd9YFxuICB8ICdVbmtub3duJztcbnR5cGUgQnJvd3NlciA9ICdpZScgfCAnZWRnZScgfCAnY2hyb21lJyB8ICdmaXJlZm94JyB8ICdzYWZhcmknO1xudHlwZSBQbGF0Zm9ybVByb3BlcnRpZXMgPSB7XG4gICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJztcbiAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IHN0cmluZztcbiAgJ1gtU3RhaW5sZXNzLU9TJzogUGxhdGZvcm1OYW1lO1xuICAnWC1TdGFpbmxlc3MtQXJjaCc6IEFyY2g7XG4gICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ25vZGUnIHwgJ2Rlbm8nIHwgJ2VkZ2UnIHwgYGJyb3dzZXI6JHtCcm93c2VyfWAgfCAndW5rbm93bic7XG4gICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiBzdHJpbmc7XG59O1xuY29uc3QgZ2V0UGxhdGZvcm1Qcm9wZXJ0aWVzID0gKCk6IFBsYXRmb3JtUHJvcGVydGllcyA9PiB7XG4gIGlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcgJiYgRGVuby5idWlsZCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJyxcbiAgICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICAgJ1gtU3RhaW5sZXNzLU9TJzogbm9ybWFsaXplUGxhdGZvcm0oRGVuby5idWlsZC5vcyksXG4gICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6IG5vcm1hbGl6ZUFyY2goRGVuby5idWlsZC5hcmNoKSxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ2Rlbm8nLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6XG4gICAgICAgIHR5cGVvZiBEZW5vLnZlcnNpb24gPT09ICdzdHJpbmcnID8gRGVuby52ZXJzaW9uIDogRGVuby52ZXJzaW9uPy5kZW5vID8/ICd1bmtub3duJyxcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgRWRnZVJ1bnRpbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJyxcbiAgICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICAgJ1gtU3RhaW5sZXNzLU9TJzogJ1Vua25vd24nLFxuICAgICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiBgb3RoZXI6JHtFZGdlUnVudGltZX1gLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAnZWRnZScsXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogcHJvY2Vzcy52ZXJzaW9uLFxuICAgIH07XG4gIH1cbiAgLy8gQ2hlY2sgaWYgTm9kZS5qc1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyA/IHByb2Nlc3MgOiAwKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJyxcbiAgICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICAgJ1gtU3RhaW5sZXNzLU9TJzogbm9ybWFsaXplUGxhdGZvcm0ocHJvY2Vzcy5wbGF0Zm9ybSksXG4gICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6IG5vcm1hbGl6ZUFyY2gocHJvY2Vzcy5hcmNoKSxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ25vZGUnLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IHByb2Nlc3MudmVyc2lvbixcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgYnJvd3NlckluZm8gPSBnZXRCcm93c2VySW5mbygpO1xuICBpZiAoYnJvd3NlckluZm8pIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAnWC1TdGFpbmxlc3MtT1MnOiAnVW5rbm93bicsXG4gICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6ICd1bmtub3duJyxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogYGJyb3dzZXI6JHticm93c2VySW5mby5icm93c2VyfWAsXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogYnJvd3NlckluZm8udmVyc2lvbixcbiAgICB9O1xuICB9XG5cbiAgLy8gVE9ETyBhZGQgc3VwcG9ydCBmb3IgQ2xvdWRmbGFyZSB3b3JrZXJzLCBldGMuXG4gIHJldHVybiB7XG4gICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICdYLVN0YWlubGVzcy1PUyc6ICdVbmtub3duJyxcbiAgICAnWC1TdGFpbmxlc3MtQXJjaCc6ICd1bmtub3duJyxcbiAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICd1bmtub3duJyxcbiAgICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogJ3Vua25vd24nLFxuICB9O1xufTtcblxudHlwZSBCcm93c2VySW5mbyA9IHtcbiAgYnJvd3NlcjogQnJvd3NlcjtcbiAgdmVyc2lvbjogc3RyaW5nO1xufTtcblxuZGVjbGFyZSBjb25zdCBuYXZpZ2F0b3I6IHsgdXNlckFnZW50OiBzdHJpbmcgfSB8IHVuZGVmaW5lZDtcblxuLy8gTm90ZTogbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vSlMtRGV2VG9vbHMvaG9zdC1lbnZpcm9ubWVudC9ibG9iL2IxYWI3OWVjZGUzN2RiNWQ2ZTE2M2MwNTBlNTRmZTdkMjg3ZDdjOTIvc3JjL2lzb21vcnBoaWMuYnJvd3Nlci50c1xuZnVuY3Rpb24gZ2V0QnJvd3NlckluZm8oKTogQnJvd3NlckluZm8gfCBudWxsIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICFuYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE5PVEU6IFRoZSBvcmRlciBtYXR0ZXJzIGhlcmUhXG4gIGNvbnN0IGJyb3dzZXJQYXR0ZXJucyA9IFtcbiAgICB7IGtleTogJ2VkZ2UnIGFzIGNvbnN0LCBwYXR0ZXJuOiAvRWRnZSg/OlxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgIHsga2V5OiAnaWUnIGFzIGNvbnN0LCBwYXR0ZXJuOiAvTVNJRSg/OlxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgIHsga2V5OiAnaWUnIGFzIGNvbnN0LCBwYXR0ZXJuOiAvVHJpZGVudCg/Oi4qcnZcXDooXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgIHsga2V5OiAnY2hyb21lJyBhcyBjb25zdCwgcGF0dGVybjogL0Nocm9tZSg/OlxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgIHsga2V5OiAnZmlyZWZveCcgYXMgY29uc3QsIHBhdHRlcm46IC9GaXJlZm94KD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgeyBrZXk6ICdzYWZhcmknIGFzIGNvbnN0LCBwYXR0ZXJuOiAvKD86VmVyc2lvblxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/KD86XFxXK01vYmlsZVxcUyopP1xcVytTYWZhcmkvIH0sXG4gIF07XG5cbiAgLy8gRmluZCB0aGUgRklSU1QgbWF0Y2hpbmcgYnJvd3NlclxuICBmb3IgKGNvbnN0IHsga2V5LCBwYXR0ZXJuIH0gb2YgYnJvd3NlclBhdHRlcm5zKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBjb25zdCBtYWpvciA9IG1hdGNoWzFdIHx8IDA7XG4gICAgICBjb25zdCBtaW5vciA9IG1hdGNoWzJdIHx8IDA7XG4gICAgICBjb25zdCBwYXRjaCA9IG1hdGNoWzNdIHx8IDA7XG5cbiAgICAgIHJldHVybiB7IGJyb3dzZXI6IGtleSwgdmVyc2lvbjogYCR7bWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9YCB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBub3JtYWxpemVBcmNoID0gKGFyY2g6IHN0cmluZyk6IEFyY2ggPT4ge1xuICAvLyBOb2RlIGRvY3M6XG4gIC8vIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc2FyY2hcbiAgLy8gRGVubyBkb2NzOlxuICAvLyAtIGh0dHBzOi8vZG9jLmRlbm8ubGFuZC9kZW5vL3N0YWJsZS9+L0Rlbm8uYnVpbGRcbiAgaWYgKGFyY2ggPT09ICd4MzInKSByZXR1cm4gJ3gzMic7XG4gIGlmIChhcmNoID09PSAneDg2XzY0JyB8fCBhcmNoID09PSAneDY0JykgcmV0dXJuICd4NjQnO1xuICBpZiAoYXJjaCA9PT0gJ2FybScpIHJldHVybiAnYXJtJztcbiAgaWYgKGFyY2ggPT09ICdhYXJjaDY0JyB8fCBhcmNoID09PSAnYXJtNjQnKSByZXR1cm4gJ2FybTY0JztcbiAgaWYgKGFyY2gpIHJldHVybiBgb3RoZXI6JHthcmNofWA7XG4gIHJldHVybiAndW5rbm93bic7XG59O1xuXG5jb25zdCBub3JtYWxpemVQbGF0Zm9ybSA9IChwbGF0Zm9ybTogc3RyaW5nKTogUGxhdGZvcm1OYW1lID0+IHtcbiAgLy8gTm9kZSBwbGF0Zm9ybXM6XG4gIC8vIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc3BsYXRmb3JtXG4gIC8vIERlbm8gcGxhdGZvcm1zOlxuICAvLyAtIGh0dHBzOi8vZG9jLmRlbm8ubGFuZC9kZW5vL3N0YWJsZS9+L0Rlbm8uYnVpbGRcbiAgLy8gLSBodHRwczovL2dpdGh1Yi5jb20vZGVub2xhbmQvZGVuby9pc3N1ZXMvMTQ3OTlcblxuICBwbGF0Zm9ybSA9IHBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gTk9URTogdGhpcyBpT1MgY2hlY2sgaXMgdW50ZXN0ZWQgYW5kIG1heSBub3Qgd29ya1xuICAvLyBOb2RlIGRvZXMgbm90IHdvcmsgbmF0aXZlbHkgb24gSU9TLCB0aGVyZSBpcyBhIGZvcmsgYXRcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy1tb2JpbGUvbm9kZWpzLW1vYmlsZVxuICAvLyBob3dldmVyIGl0IGlzIHVua25vd24gYXQgdGhlIHRpbWUgb2Ygd3JpdGluZyBob3cgdG8gZGV0ZWN0IGlmIGl0IGlzIHJ1bm5pbmdcbiAgaWYgKHBsYXRmb3JtLmluY2x1ZGVzKCdpb3MnKSkgcmV0dXJuICdpT1MnO1xuICBpZiAocGxhdGZvcm0gPT09ICdhbmRyb2lkJykgcmV0dXJuICdBbmRyb2lkJztcbiAgaWYgKHBsYXRmb3JtID09PSAnZGFyd2luJykgcmV0dXJuICdNYWNPUyc7XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ3dpbjMyJykgcmV0dXJuICdXaW5kb3dzJztcbiAgaWYgKHBsYXRmb3JtID09PSAnZnJlZWJzZCcpIHJldHVybiAnRnJlZUJTRCc7XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKSByZXR1cm4gJ09wZW5CU0QnO1xuICBpZiAocGxhdGZvcm0gPT09ICdsaW51eCcpIHJldHVybiAnTGludXgnO1xuICBpZiAocGxhdGZvcm0pIHJldHVybiBgT3RoZXI6JHtwbGF0Zm9ybX1gO1xuICByZXR1cm4gJ1Vua25vd24nO1xufTtcblxubGV0IF9wbGF0Zm9ybUhlYWRlcnM6IFBsYXRmb3JtUHJvcGVydGllcztcbmNvbnN0IGdldFBsYXRmb3JtSGVhZGVycyA9ICgpID0+IHtcbiAgcmV0dXJuIChfcGxhdGZvcm1IZWFkZXJzID8/PSBnZXRQbGF0Zm9ybVByb3BlcnRpZXMoKSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2FmZUpTT04gPSAodGV4dDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLXNjaGVtZS1zdHJpbmdcbmNvbnN0IHN0YXJ0c1dpdGhTY2hlbWVSZWdleHAgPSAvXlthLXpdW2EtejAtOSsuLV0qOi9pO1xuY29uc3QgaXNBYnNvbHV0ZVVSTCA9ICh1cmw6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gc3RhcnRzV2l0aFNjaGVtZVJlZ2V4cC50ZXN0KHVybCk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2xlZXAgPSAobXM6IG51bWJlcikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcblxuY29uc3QgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIgPSAobmFtZTogc3RyaW5nLCBuOiB1bmtub3duKTogbnVtYmVyID0+IHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihuKSkge1xuICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgJHtuYW1lfSBtdXN0IGJlIGFuIGludGVnZXJgKTtcbiAgfVxuICBpZiAobiA8IDApIHtcbiAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJgKTtcbiAgfVxuICByZXR1cm4gbjtcbn07XG5cbmV4cG9ydCBjb25zdCBjYXN0VG9FcnJvciA9IChlcnI6IGFueSk6IEVycm9yID0+IHtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gZXJyO1xuICBpZiAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiYgZXJyICE9PSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoZXJyKSk7XG4gICAgfSBjYXRjaCB7fVxuICB9XG4gIHJldHVybiBuZXcgRXJyb3IoZXJyKTtcbn07XG5cbmV4cG9ydCBjb25zdCBlbnN1cmVQcmVzZW50ID0gPFQ+KHZhbHVlOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFQgPT4ge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBFeHBlY3RlZCBhIHZhbHVlIHRvIGJlIGdpdmVuIGJ1dCByZWNlaXZlZCAke3ZhbHVlfSBpbnN0ZWFkLmApO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJlYWQgYW4gZW52aXJvbm1lbnQgdmFyaWFibGUuXG4gKlxuICogVHJpbXMgYmVnaW5uaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICpcbiAqIFdpbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgZG9lc24ndCBleGlzdCBvciBjYW5ub3QgYmUgYWNjZXNzZWQuXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkRW52ID0gKGVudjogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBwcm9jZXNzLmVudj8uW2Vudl0/LnRyaW0oKSA/PyB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBEZW5vLmVudj8uZ2V0Py4oZW52KT8udHJpbSgpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgY29uc3QgY29lcmNlSW50ZWdlciA9ICh2YWx1ZTogdW5rbm93bik6IG51bWJlciA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcblxuICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYENvdWxkIG5vdCBjb2VyY2UgJHt2YWx1ZX0gKHR5cGU6ICR7dHlwZW9mIHZhbHVlfSkgaW50byBhIG51bWJlcmApO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvZXJjZUZsb2F0ID0gKHZhbHVlOiB1bmtub3duKTogbnVtYmVyID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB2YWx1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcblxuICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYENvdWxkIG5vdCBjb2VyY2UgJHt2YWx1ZX0gKHR5cGU6ICR7dHlwZW9mIHZhbHVlfSkgaW50byBhIG51bWJlcmApO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvZXJjZUJvb2xlYW4gPSAodmFsdWU6IHVua25vd24pOiBib29sZWFuID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gdmFsdWU7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSByZXR1cm4gdmFsdWUgPT09ICd0cnVlJztcbiAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xufTtcblxuZXhwb3J0IGNvbnN0IG1heWJlQ29lcmNlSW50ZWdlciA9ICh2YWx1ZTogdW5rbm93bik6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gY29lcmNlSW50ZWdlcih2YWx1ZSk7XG59O1xuXG5leHBvcnQgY29uc3QgbWF5YmVDb2VyY2VGbG9hdCA9ICh2YWx1ZTogdW5rbm93bik6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gY29lcmNlRmxvYXQodmFsdWUpO1xufTtcblxuZXhwb3J0IGNvbnN0IG1heWJlQ29lcmNlQm9vbGVhbiA9ICh2YWx1ZTogdW5rbm93bik6IGJvb2xlYW4gfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGNvZXJjZUJvb2xlYW4odmFsdWUpO1xufTtcblxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM0NDkxMjg3XG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eU9iaihvYmo6IE9iamVjdCB8IG51bGwgfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgaWYgKCFvYmopIHJldHVybiB0cnVlO1xuICBmb3IgKGNvbnN0IF9rIGluIG9iaikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gaHR0cHM6Ly9lc2xpbnQub3JnL2RvY3MvbGF0ZXN0L3J1bGVzL25vLXByb3RvdHlwZS1idWlsdGluc1xuZXhwb3J0IGZ1bmN0aW9uIGhhc093bihvYmo6IE9iamVjdCwga2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbi8qKlxuICogQ29waWVzIGhlYWRlcnMgZnJvbSBcIm5ld0hlYWRlcnNcIiBvbnRvIFwidGFyZ2V0SGVhZGVyc1wiLFxuICogdXNpbmcgbG93ZXItY2FzZSBmb3IgYWxsIHByb3BlcnRpZXMsXG4gKiBpZ25vcmluZyBhbnkga2V5cyB3aXRoIHVuZGVmaW5lZCB2YWx1ZXMsXG4gKiBhbmQgZGVsZXRpbmcgYW55IGtleXMgd2l0aCBudWxsIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlIZWFkZXJzTXV0KHRhcmdldEhlYWRlcnM6IEhlYWRlcnMsIG5ld0hlYWRlcnM6IEhlYWRlcnMpOiB2b2lkIHtcbiAgZm9yIChjb25zdCBrIGluIG5ld0hlYWRlcnMpIHtcbiAgICBpZiAoIWhhc093bihuZXdIZWFkZXJzLCBrKSkgY29udGludWU7XG4gICAgY29uc3QgbG93ZXJLZXkgPSBrLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCFsb3dlcktleSkgY29udGludWU7XG5cbiAgICBjb25zdCB2YWwgPSBuZXdIZWFkZXJzW2tdO1xuXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgZGVsZXRlIHRhcmdldEhlYWRlcnNbbG93ZXJLZXldO1xuICAgIH0gZWxzZSBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldEhlYWRlcnNbbG93ZXJLZXldID0gdmFsO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBTRU5TSVRJVkVfSEVBREVSUyA9IG5ldyBTZXQoWydhdXRob3JpemF0aW9uJywgJ2FwaS1rZXknXSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJ1ZyhhY3Rpb246IHN0cmluZywgLi4uYXJnczogYW55W10pIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzPy5lbnY/LlsnREVCVUcnXSA9PT0gJ3RydWUnKSB7XG4gICAgY29uc3QgbW9kaWZpZWRBcmdzID0gYXJncy5tYXAoKGFyZykgPT4ge1xuICAgICAgaWYgKCFhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIHNlbnNpdGl2ZSBoZWFkZXJzIGluIHJlcXVlc3QgYm9keSAnaGVhZGVycycgb2JqZWN0XG4gICAgICBpZiAoYXJnWydoZWFkZXJzJ10pIHtcbiAgICAgICAgLy8gY2xvbmUgc28gd2UgZG9uJ3QgbXV0YXRlXG4gICAgICAgIGNvbnN0IG1vZGlmaWVkQXJnID0geyAuLi5hcmcsIGhlYWRlcnM6IHsgLi4uYXJnWydoZWFkZXJzJ10gfSB9O1xuXG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIGluIGFyZ1snaGVhZGVycyddKSB7XG4gICAgICAgICAgaWYgKFNFTlNJVElWRV9IRUFERVJTLmhhcyhoZWFkZXIudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIG1vZGlmaWVkQXJnWydoZWFkZXJzJ11baGVhZGVyXSA9ICdSRURBQ1RFRCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vZGlmaWVkQXJnO1xuICAgICAgfVxuXG4gICAgICBsZXQgbW9kaWZpZWRBcmcgPSBudWxsO1xuXG4gICAgICAvLyBDaGVjayBmb3Igc2Vuc2l0aXZlIGhlYWRlcnMgaW4gaGVhZGVycyBvYmplY3RcbiAgICAgIGZvciAoY29uc3QgaGVhZGVyIGluIGFyZykge1xuICAgICAgICBpZiAoU0VOU0lUSVZFX0hFQURFUlMuaGFzKGhlYWRlci50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgIC8vIGF2b2lkIG1ha2luZyBhIGNvcHkgdW50aWwgd2UgbmVlZCB0b1xuICAgICAgICAgIG1vZGlmaWVkQXJnID8/PSB7IC4uLmFyZyB9O1xuICAgICAgICAgIG1vZGlmaWVkQXJnW2hlYWRlcl0gPSAnUkVEQUNURUQnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb2RpZmllZEFyZyA/PyBhcmc7XG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coYE9wZW5BSTpERUJVRzoke2FjdGlvbn1gLCAuLi5tb2RpZmllZEFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxMTc1MjNcbiAqL1xuY29uc3QgdXVpZDQgPSAoKSA9PiB7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMDtcbiAgICBjb25zdCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcbiAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzUnVubmluZ0luQnJvd3NlciA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGVhZGVyc1Byb3RvY29sIHtcbiAgZ2V0OiAoaGVhZGVyOiBzdHJpbmcpID0+IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG59XG5leHBvcnQgdHlwZSBIZWFkZXJzTGlrZSA9IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkPiB8IEhlYWRlcnNQcm90b2NvbDtcblxuZXhwb3J0IGNvbnN0IGlzSGVhZGVyc1Byb3RvY29sID0gKGhlYWRlcnM6IGFueSk6IGhlYWRlcnMgaXMgSGVhZGVyc1Byb3RvY29sID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBoZWFkZXJzPy5nZXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0UmVxdWlyZWRIZWFkZXIgPSAoaGVhZGVyczogSGVhZGVyc0xpa2UgfCBIZWFkZXJzLCBoZWFkZXI6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGZvdW5kSGVhZGVyID0gZ2V0SGVhZGVyKGhlYWRlcnMsIGhlYWRlcik7XG4gIGlmIChmb3VuZEhlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCAke2hlYWRlcn0gaGVhZGVyYCk7XG4gIH1cbiAgcmV0dXJuIGZvdW5kSGVhZGVyO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEhlYWRlciA9IChoZWFkZXJzOiBIZWFkZXJzTGlrZSB8IEhlYWRlcnMsIGhlYWRlcjogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgY29uc3QgbG93ZXJDYXNlZEhlYWRlciA9IGhlYWRlci50b0xvd2VyQ2FzZSgpO1xuICBpZiAoaXNIZWFkZXJzUHJvdG9jb2woaGVhZGVycykpIHtcbiAgICAvLyB0byBkZWFsIHdpdGggdGhlIGNhc2Ugd2hlcmUgdGhlIGhlYWRlciBsb29rcyBsaWtlIFN0YWlubGVzcy1FdmVudC1JZFxuICAgIGNvbnN0IGludGVyY2Fwc0hlYWRlciA9XG4gICAgICBoZWFkZXJbMF0/LnRvVXBwZXJDYXNlKCkgK1xuICAgICAgaGVhZGVyLnN1YnN0cmluZygxKS5yZXBsYWNlKC8oW15cXHddKShcXHcpL2csIChfbSwgZzEsIGcyKSA9PiBnMSArIGcyLnRvVXBwZXJDYXNlKCkpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFtoZWFkZXIsIGxvd2VyQ2FzZWRIZWFkZXIsIGhlYWRlci50b1VwcGVyQ2FzZSgpLCBpbnRlcmNhcHNIZWFkZXJdKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlcnMuZ2V0KGtleSk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSBsb3dlckNhc2VkSGVhZGVyKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSAxKSByZXR1cm4gdmFsdWVbMF07XG4gICAgICAgIGNvbnNvbGUud2FybihgUmVjZWl2ZWQgJHt2YWx1ZS5sZW5ndGh9IGVudHJpZXMgZm9yIHRoZSAke2hlYWRlcn0gaGVhZGVyLCB1c2luZyB0aGUgZmlyc3QgZW50cnkuYCk7XG4gICAgICAgIHJldHVybiB2YWx1ZVswXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgc3RyaW5nIHRvIEJhc2U2NCBmb3JtYXQuXG4gKi9cbmV4cG9ydCBjb25zdCB0b0Jhc2U2NCA9IChzdHI6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpOiBzdHJpbmcgPT4ge1xuICBpZiAoIXN0cikgcmV0dXJuICcnO1xuICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGJ0b2Eoc3RyKTtcbiAgfVxuXG4gIHRocm93IG5ldyBPcGVuQUlFcnJvcignQ2Fubm90IGdlbmVyYXRlIGI2NCBzdHJpbmc7IEV4cGVjdGVkIGBCdWZmZXJgIG9yIGBidG9hYCB0byBiZSBkZWZpbmVkJyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmoob2JqOiB1bmtub3duKTogb2JqIGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9iaik7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQWJzdHJhY3RQYWdlLCBSZXNwb25zZSwgQVBJQ2xpZW50LCBGaW5hbFJlcXVlc3RPcHRpb25zLCBQYWdlSW5mbyB9IGZyb20gJy4vY29yZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnZVJlc3BvbnNlPEl0ZW0+IHtcbiAgZGF0YTogQXJyYXk8SXRlbT47XG5cbiAgb2JqZWN0OiBzdHJpbmc7XG59XG5cbi8qKlxuICogTm90ZTogbm8gcGFnaW5hdGlvbiBhY3R1YWxseSBvY2N1cnMgeWV0LCB0aGlzIGlzIGZvciBmb3J3YXJkcy1jb21wYXRpYmlsaXR5LlxuICovXG5leHBvcnQgY2xhc3MgUGFnZTxJdGVtPiBleHRlbmRzIEFic3RyYWN0UGFnZTxJdGVtPiBpbXBsZW1lbnRzIFBhZ2VSZXNwb25zZTxJdGVtPiB7XG4gIGRhdGE6IEFycmF5PEl0ZW0+O1xuXG4gIG9iamVjdDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGNsaWVudDogQVBJQ2xpZW50LCByZXNwb25zZTogUmVzcG9uc2UsIGJvZHk6IFBhZ2VSZXNwb25zZTxJdGVtPiwgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucykge1xuICAgIHN1cGVyKGNsaWVudCwgcmVzcG9uc2UsIGJvZHksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5kYXRhID0gYm9keS5kYXRhIHx8IFtdO1xuICAgIHRoaXMub2JqZWN0ID0gYm9keS5vYmplY3Q7XG4gIH1cblxuICBnZXRQYWdpbmF0ZWRJdGVtcygpOiBJdGVtW10ge1xuICAgIHJldHVybiB0aGlzLmRhdGEgPz8gW107XG4gIH1cblxuICAvLyBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGBuZXh0UGFnZUluZm8oKWAgaW5zdGVhZFxuICAvKipcbiAgICogVGhpcyBwYWdlIHJlcHJlc2VudHMgYSByZXNwb25zZSB0aGF0IGlzbid0IGFjdHVhbGx5IHBhZ2luYXRlZCBhdCB0aGUgQVBJIGxldmVsXG4gICAqIHNvIHRoZXJlIHdpbGwgbmV2ZXIgYmUgYW55IG5leHQgcGFnZSBwYXJhbXMuXG4gICAqL1xuICBuZXh0UGFnZVBhcmFtcygpOiBudWxsIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG5leHRQYWdlSW5mbygpOiBudWxsIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEN1cnNvclBhZ2VSZXNwb25zZTxJdGVtPiB7XG4gIGRhdGE6IEFycmF5PEl0ZW0+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEN1cnNvclBhZ2VQYXJhbXMge1xuICBhZnRlcj86IHN0cmluZztcblxuICBsaW1pdD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEN1cnNvclBhZ2U8SXRlbSBleHRlbmRzIHsgaWQ6IHN0cmluZyB9PlxuICBleHRlbmRzIEFic3RyYWN0UGFnZTxJdGVtPlxuICBpbXBsZW1lbnRzIEN1cnNvclBhZ2VSZXNwb25zZTxJdGVtPlxue1xuICBkYXRhOiBBcnJheTxJdGVtPjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBjbGllbnQ6IEFQSUNsaWVudCxcbiAgICByZXNwb25zZTogUmVzcG9uc2UsXG4gICAgYm9keTogQ3Vyc29yUGFnZVJlc3BvbnNlPEl0ZW0+LFxuICAgIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnMsXG4gICkge1xuICAgIHN1cGVyKGNsaWVudCwgcmVzcG9uc2UsIGJvZHksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5kYXRhID0gYm9keS5kYXRhIHx8IFtdO1xuICB9XG5cbiAgZ2V0UGFnaW5hdGVkSXRlbXMoKTogSXRlbVtdIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhID8/IFtdO1xuICB9XG5cbiAgLy8gQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBgbmV4dFBhZ2VJbmZvKClgIGluc3RlYWRcbiAgbmV4dFBhZ2VQYXJhbXMoKTogUGFydGlhbDxDdXJzb3JQYWdlUGFyYW1zPiB8IG51bGwge1xuICAgIGNvbnN0IGluZm8gPSB0aGlzLm5leHRQYWdlSW5mbygpO1xuICAgIGlmICghaW5mbykgcmV0dXJuIG51bGw7XG4gICAgaWYgKCdwYXJhbXMnIGluIGluZm8pIHJldHVybiBpbmZvLnBhcmFtcztcbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuZnJvbUVudHJpZXMoaW5mby51cmwuc2VhcmNoUGFyYW1zKTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgbmV4dFBhZ2VJbmZvKCk6IFBhZ2VJbmZvIHwgbnVsbCB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0UGFnaW5hdGVkSXRlbXMoKTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXT8uaWQ7XG4gICAgaWYgKCFpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcGFyYW1zOiB7IGFmdGVyOiBpZCB9IH07XG4gIH1cbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgdHlwZSB7IE9wZW5BSSB9IGZyb20gJy4vaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgQVBJUmVzb3VyY2Uge1xuICBwcm90ZWN0ZWQgX2NsaWVudDogT3BlbkFJO1xuXG4gIGNvbnN0cnVjdG9yKGNsaWVudDogT3BlbkFJKSB7XG4gICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICB9XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBBUElQcm9taXNlIH0gZnJvbSAnLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ2hhdENvbXBsZXRpb25zQVBJIGZyb20gJy4vY29tcGxldGlvbnMnO1xuaW1wb3J0ICogYXMgQ29tcGxldGlvbnNBUEkgZnJvbSAnLi4vY29tcGxldGlvbnMnO1xuaW1wb3J0ICogYXMgU2hhcmVkIGZyb20gJy4uL3NoYXJlZCc7XG5pbXBvcnQgKiBhcyBDaGF0QVBJIGZyb20gJy4vY2hhdCc7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tICcuLi8uLi9zdHJlYW1pbmcnO1xuXG5leHBvcnQgY2xhc3MgQ29tcGxldGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbW9kZWwgcmVzcG9uc2UgZm9yIHRoZSBnaXZlbiBjaGF0IGNvbnZlcnNhdGlvbi4gTGVhcm4gbW9yZSBpbiB0aGVcbiAgICogW3RleHQgZ2VuZXJhdGlvbl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3RleHQtZ2VuZXJhdGlvbiksXG4gICAqIFt2aXNpb25dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy92aXNpb24pLCBhbmRcbiAgICogW2F1ZGlvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYXVkaW8pIGd1aWRlcy5cbiAgICpcbiAgICogUGFyYW1ldGVyIHN1cHBvcnQgY2FuIGRpZmZlciBkZXBlbmRpbmcgb24gdGhlIG1vZGVsIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqIHJlc3BvbnNlLCBwYXJ0aWN1bGFybHkgZm9yIG5ld2VyIHJlYXNvbmluZyBtb2RlbHMuIFBhcmFtZXRlcnMgdGhhdCBhcmUgb25seVxuICAgKiBzdXBwb3J0ZWQgZm9yIHJlYXNvbmluZyBtb2RlbHMgYXJlIG5vdGVkIGJlbG93LiBGb3IgdGhlIGN1cnJlbnQgc3RhdGUgb2ZcbiAgICogdW5zdXBwb3J0ZWQgcGFyYW1ldGVycyBpbiByZWFzb25pbmcgbW9kZWxzLFxuICAgKiBbcmVmZXIgdG8gdGhlIHJlYXNvbmluZyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3JlYXNvbmluZykuXG4gICAqL1xuICBjcmVhdGUoXG4gICAgYm9keTogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8Q2hhdENvbXBsZXRpb24+O1xuICBjcmVhdGUoXG4gICAgYm9keTogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8U3RyZWFtPENoYXRDb21wbGV0aW9uQ2h1bms+PjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08Q2hhdENvbXBsZXRpb25DaHVuaz4gfCBDaGF0Q29tcGxldGlvbj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxDaGF0Q29tcGxldGlvbj4gfCBBUElQcm9taXNlPFN0cmVhbTxDaGF0Q29tcGxldGlvbkNodW5rPj4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2NoYXQvY29tcGxldGlvbnMnLCB7IGJvZHksIC4uLm9wdGlvbnMsIHN0cmVhbTogYm9keS5zdHJlYW0gPz8gZmFsc2UgfSkgYXNcbiAgICAgIHwgQVBJUHJvbWlzZTxDaGF0Q29tcGxldGlvbj5cbiAgICAgIHwgQVBJUHJvbWlzZTxTdHJlYW08Q2hhdENvbXBsZXRpb25DaHVuaz4+O1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNoYXQgY29tcGxldGlvbiByZXNwb25zZSByZXR1cm5lZCBieSBtb2RlbCwgYmFzZWQgb24gdGhlIHByb3ZpZGVkXG4gKiBpbnB1dC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbiB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY2hhdCBjb21wbGV0aW9uLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGNoYXQgY29tcGxldGlvbiBjaG9pY2VzLiBDYW4gYmUgbW9yZSB0aGFuIG9uZSBpZiBgbmAgaXMgZ3JlYXRlclxuICAgKiB0aGFuIDEuXG4gICAqL1xuICBjaG9pY2VzOiBBcnJheTxDaGF0Q29tcGxldGlvbi5DaG9pY2U+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIG9mIHdoZW4gdGhlIGNoYXQgY29tcGxldGlvbiB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHVzZWQgZm9yIHRoZSBjaGF0IGNvbXBsZXRpb24uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgY2hhdC5jb21wbGV0aW9uYC5cbiAgICovXG4gIG9iamVjdDogJ2NoYXQuY29tcGxldGlvbic7XG5cbiAgLyoqXG4gICAqIFRoZSBzZXJ2aWNlIHRpZXIgdXNlZCBmb3IgcHJvY2Vzc2luZyB0aGUgcmVxdWVzdC4gVGhpcyBmaWVsZCBpcyBvbmx5IGluY2x1ZGVkIGlmXG4gICAqIHRoZSBgc2VydmljZV90aWVyYCBwYXJhbWV0ZXIgaXMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgc2VydmljZV90aWVyPzogJ3NjYWxlJyB8ICdkZWZhdWx0JyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoaXMgZmluZ2VycHJpbnQgcmVwcmVzZW50cyB0aGUgYmFja2VuZCBjb25maWd1cmF0aW9uIHRoYXQgdGhlIG1vZGVsIHJ1bnMgd2l0aC5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgYHNlZWRgIHJlcXVlc3QgcGFyYW1ldGVyIHRvIHVuZGVyc3RhbmQgd2hlblxuICAgKiBiYWNrZW5kIGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUgdGhhdCBtaWdodCBpbXBhY3QgZGV0ZXJtaW5pc20uXG4gICAqL1xuICBzeXN0ZW1fZmluZ2VycHJpbnQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBjb21wbGV0aW9uIHJlcXVlc3QuXG4gICAqL1xuICB1c2FnZT86IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25Vc2FnZTtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0Q29tcGxldGlvbiB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ2hvaWNlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVhc29uIHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLiBUaGlzIHdpbGwgYmUgYHN0b3BgIGlmIHRoZSBtb2RlbFxuICAgICAqIGhpdCBhIG5hdHVyYWwgc3RvcCBwb2ludCBvciBhIHByb3ZpZGVkIHN0b3Agc2VxdWVuY2UsIGBsZW5ndGhgIGlmIHRoZSBtYXhpbXVtXG4gICAgICogbnVtYmVyIG9mIHRva2VucyBzcGVjaWZpZWQgaW4gdGhlIHJlcXVlc3Qgd2FzIHJlYWNoZWQsIGBjb250ZW50X2ZpbHRlcmAgaWZcbiAgICAgKiBjb250ZW50IHdhcyBvbWl0dGVkIGR1ZSB0byBhIGZsYWcgZnJvbSBvdXIgY29udGVudCBmaWx0ZXJzLCBgdG9vbF9jYWxsc2AgaWYgdGhlXG4gICAgICogbW9kZWwgY2FsbGVkIGEgdG9vbCwgb3IgYGZ1bmN0aW9uX2NhbGxgIChkZXByZWNhdGVkKSBpZiB0aGUgbW9kZWwgY2FsbGVkIGFcbiAgICAgKiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmaW5pc2hfcmVhc29uOiAnc3RvcCcgfCAnbGVuZ3RoJyB8ICd0b29sX2NhbGxzJyB8ICdjb250ZW50X2ZpbHRlcicgfCAnZnVuY3Rpb25fY2FsbCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGNob2ljZSBpbiB0aGUgbGlzdCBvZiBjaG9pY2VzLlxuICAgICAqL1xuICAgIGluZGV4OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBMb2cgcHJvYmFiaWxpdHkgaW5mb3JtYXRpb24gZm9yIHRoZSBjaG9pY2UuXG4gICAgICovXG4gICAgbG9ncHJvYnM6IENob2ljZS5Mb2dwcm9icyB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIGNoYXQgY29tcGxldGlvbiBtZXNzYWdlIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgbWVzc2FnZTogQ2hhdENvbXBsZXRpb25zQVBJLkNoYXRDb21wbGV0aW9uTWVzc2FnZTtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgQ2hvaWNlIHtcbiAgICAvKipcbiAgICAgKiBMb2cgcHJvYmFiaWxpdHkgaW5mb3JtYXRpb24gZm9yIHRoZSBjaG9pY2UuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBMb2dwcm9icyB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBtZXNzYWdlIGNvbnRlbnQgdG9rZW5zIHdpdGggbG9nIHByb2JhYmlsaXR5IGluZm9ybWF0aW9uLlxuICAgICAgICovXG4gICAgICBjb250ZW50OiBBcnJheTxDaGF0Q29tcGxldGlvbnNBUEkuQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2I+IHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgbWVzc2FnZSByZWZ1c2FsIHRva2VucyB3aXRoIGxvZyBwcm9iYWJpbGl0eSBpbmZvcm1hdGlvbi5cbiAgICAgICAqL1xuICAgICAgcmVmdXNhbDogQXJyYXk8Q2hhdENvbXBsZXRpb25zQVBJLkNoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iPiB8IG51bGw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVzc2FnZXMgc2VudCBieSB0aGUgbW9kZWwgaW4gcmVzcG9uc2UgdG8gdXNlciBtZXNzYWdlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSB7XG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgbWVzc2FnZXMgYXV0aG9yLCBpbiB0aGlzIGNhc2UgYGFzc2lzdGFudGAuXG4gICAqL1xuICByb2xlOiAnYXNzaXN0YW50JztcblxuICAvKipcbiAgICogRGF0YSBhYm91dCBhIHByZXZpb3VzIGF1ZGlvIHJlc3BvbnNlIGZyb20gdGhlIG1vZGVsLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2F1ZGlvKS5cbiAgICovXG4gIGF1ZGlvPzogQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0uQXVkaW8gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGFzc2lzdGFudCBtZXNzYWdlLiBSZXF1aXJlZCB1bmxlc3MgYHRvb2xfY2FsbHNgIG9yXG4gICAqIGBmdW5jdGlvbl9jYWxsYCBpcyBzcGVjaWZpZWQuXG4gICAqL1xuICBjb250ZW50Pzogc3RyaW5nIHwgQXJyYXk8Q2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQgfCBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0UmVmdXNhbD4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZDogRGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgYnkgYHRvb2xfY2FsbHNgLiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mXG4gICAqIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgZnVuY3Rpb25fY2FsbD86IENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtLkZ1bmN0aW9uQ2FsbCB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIG5hbWUgZm9yIHRoZSBwYXJ0aWNpcGFudC4gUHJvdmlkZXMgdGhlIG1vZGVsIGluZm9ybWF0aW9uIHRvXG4gICAqIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBwYXJ0aWNpcGFudHMgb2YgdGhlIHNhbWUgcm9sZS5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSByZWZ1c2FsIG1lc3NhZ2UgYnkgdGhlIGFzc2lzdGFudC5cbiAgICovXG4gIHJlZnVzYWw/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgdG9vbCBjYWxscyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLCBzdWNoIGFzIGZ1bmN0aW9uIGNhbGxzLlxuICAgKi9cbiAgdG9vbF9jYWxscz86IEFycmF5PENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsPjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSB7XG4gIC8qKlxuICAgKiBEYXRhIGFib3V0IGEgcHJldmlvdXMgYXVkaW8gcmVzcG9uc2UgZnJvbSB0aGUgbW9kZWwuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYXVkaW8pLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBBdWRpbyB7XG4gICAgLyoqXG4gICAgICogVW5pcXVlIGlkZW50aWZpZXIgZm9yIGEgcHJldmlvdXMgYXVkaW8gcmVzcG9uc2UgZnJvbSB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgaWQ6IHN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZDogRGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgYnkgYHRvb2xfY2FsbHNgLiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mXG4gICAqIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkNhbGwge1xuICAgIC8qKlxuICAgICAqIFRoZSBhcmd1bWVudHMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpbiBKU09OXG4gICAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAgICogaGFsbHVjaW5hdGUgcGFyYW1ldGVycyBub3QgZGVmaW5lZCBieSB5b3VyIGZ1bmN0aW9uIHNjaGVtYS4gVmFsaWRhdGUgdGhlXG4gICAgICogYXJndW1lbnRzIGluIHlvdXIgY29kZSBiZWZvcmUgY2FsbGluZyB5b3VyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGFyZ3VtZW50czogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogSWYgdGhlIGF1ZGlvIG91dHB1dCBtb2RhbGl0eSBpcyByZXF1ZXN0ZWQsIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGRhdGEgYWJvdXQgdGhlXG4gKiBhdWRpbyByZXNwb25zZSBmcm9tIHRoZSBtb2RlbC5cbiAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYXVkaW8pLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQXVkaW8ge1xuICAvKipcbiAgICogVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYXVkaW8gcmVzcG9uc2UuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBCYXNlNjQgZW5jb2RlZCBhdWRpbyBieXRlcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBpblxuICAgKiB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGRhdGE6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGlzIGF1ZGlvIHJlc3BvbnNlIHdpbGwgbm8gbG9uZ2VyIGJlXG4gICAqIGFjY2Vzc2libGUgb24gdGhlIHNlcnZlciBmb3IgdXNlIGluIG11bHRpLXR1cm4gY29udmVyc2F0aW9ucy5cbiAgICovXG4gIGV4cGlyZXNfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVHJhbnNjcmlwdCBvZiB0aGUgYXVkaW8gZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIHRyYW5zY3JpcHQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBQYXJhbWV0ZXJzIGZvciBhdWRpbyBvdXRwdXQuIFJlcXVpcmVkIHdoZW4gYXVkaW8gb3V0cHV0IGlzIHJlcXVlc3RlZCB3aXRoXG4gKiBgbW9kYWxpdGllczogW1wiYXVkaW9cIl1gLlxuICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9hdWRpbykuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25BdWRpb1BhcmFtIHtcbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgb3V0cHV0IGF1ZGlvIGZvcm1hdC4gTXVzdCBiZSBvbmUgb2YgYHdhdmAsIGBtcDNgLCBgZmxhY2AsIGBvcHVzYCxcbiAgICogb3IgYHBjbTE2YC5cbiAgICovXG4gIGZvcm1hdDogJ3dhdicgfCAnbXAzJyB8ICdmbGFjJyB8ICdvcHVzJyB8ICdwY20xNic7XG5cbiAgLyoqXG4gICAqIFRoZSB2b2ljZSB0aGUgbW9kZWwgdXNlcyB0byByZXNwb25kLiBTdXBwb3J0ZWQgdm9pY2VzIGFyZSBgYXNoYCwgYGJhbGxhZGAsXG4gICAqIGBjb3JhbGAsIGBzYWdlYCwgYW5kIGB2ZXJzZWAgKGFsc28gc3VwcG9ydGVkIGJ1dCBub3QgcmVjb21tZW5kZWQgYXJlIGBhbGxveWAsXG4gICAqIGBlY2hvYCwgYW5kIGBzaGltbWVyYDsgdGhlc2Ugdm9pY2VzIGFyZSBsZXNzIGV4cHJlc3NpdmUpLlxuICAgKi9cbiAgdm9pY2U6ICdhbGxveScgfCAnYXNoJyB8ICdiYWxsYWQnIHwgJ2NvcmFsJyB8ICdlY2hvJyB8ICdzYWdlJyB8ICdzaGltbWVyJyB8ICd2ZXJzZSc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHN0cmVhbWVkIGNodW5rIG9mIGEgY2hhdCBjb21wbGV0aW9uIHJlc3BvbnNlIHJldHVybmVkIGJ5IG1vZGVsLFxuICogYmFzZWQgb24gdGhlIHByb3ZpZGVkIGlucHV0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ2h1bmsge1xuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNoYXQgY29tcGxldGlvbi4gRWFjaCBjaHVuayBoYXMgdGhlIHNhbWUgSUQuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgY2hhdCBjb21wbGV0aW9uIGNob2ljZXMuIENhbiBjb250YWluIG1vcmUgdGhhbiBvbmUgZWxlbWVudHMgaWYgYG5gIGlzXG4gICAqIGdyZWF0ZXIgdGhhbiAxLiBDYW4gYWxzbyBiZSBlbXB0eSBmb3IgdGhlIGxhc3QgY2h1bmsgaWYgeW91IHNldFxuICAgKiBgc3RyZWFtX29wdGlvbnM6IHtcImluY2x1ZGVfdXNhZ2VcIjogdHJ1ZX1gLlxuICAgKi9cbiAgY2hvaWNlczogQXJyYXk8Q2hhdENvbXBsZXRpb25DaHVuay5DaG9pY2U+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIG9mIHdoZW4gdGhlIGNoYXQgY29tcGxldGlvbiB3YXMgY3JlYXRlZC4gRWFjaFxuICAgKiBjaHVuayBoYXMgdGhlIHNhbWUgdGltZXN0YW1wLlxuICAgKi9cbiAgY3JlYXRlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdG8gZ2VuZXJhdGUgdGhlIGNvbXBsZXRpb24uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgY2hhdC5jb21wbGV0aW9uLmNodW5rYC5cbiAgICovXG4gIG9iamVjdDogJ2NoYXQuY29tcGxldGlvbi5jaHVuayc7XG5cbiAgLyoqXG4gICAqIFRoZSBzZXJ2aWNlIHRpZXIgdXNlZCBmb3IgcHJvY2Vzc2luZyB0aGUgcmVxdWVzdC4gVGhpcyBmaWVsZCBpcyBvbmx5IGluY2x1ZGVkIGlmXG4gICAqIHRoZSBgc2VydmljZV90aWVyYCBwYXJhbWV0ZXIgaXMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgc2VydmljZV90aWVyPzogJ3NjYWxlJyB8ICdkZWZhdWx0JyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoaXMgZmluZ2VycHJpbnQgcmVwcmVzZW50cyB0aGUgYmFja2VuZCBjb25maWd1cmF0aW9uIHRoYXQgdGhlIG1vZGVsIHJ1bnMgd2l0aC5cbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgYHNlZWRgIHJlcXVlc3QgcGFyYW1ldGVyIHRvIHVuZGVyc3RhbmQgd2hlblxuICAgKiBiYWNrZW5kIGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUgdGhhdCBtaWdodCBpbXBhY3QgZGV0ZXJtaW5pc20uXG4gICAqL1xuICBzeXN0ZW1fZmluZ2VycHJpbnQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIGZpZWxkIHRoYXQgd2lsbCBvbmx5IGJlIHByZXNlbnQgd2hlbiB5b3Ugc2V0XG4gICAqIGBzdHJlYW1fb3B0aW9uczoge1wiaW5jbHVkZV91c2FnZVwiOiB0cnVlfWAgaW4geW91ciByZXF1ZXN0LiBXaGVuIHByZXNlbnQsIGl0XG4gICAqIGNvbnRhaW5zIGEgbnVsbCB2YWx1ZSBleGNlcHQgZm9yIHRoZSBsYXN0IGNodW5rIHdoaWNoIGNvbnRhaW5zIHRoZSB0b2tlbiB1c2FnZVxuICAgKiBzdGF0aXN0aWNzIGZvciB0aGUgZW50aXJlIHJlcXVlc3QuXG4gICAqL1xuICB1c2FnZT86IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25Vc2FnZSB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdENvbXBsZXRpb25DaHVuayB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ2hvaWNlIHtcbiAgICAvKipcbiAgICAgKiBBIGNoYXQgY29tcGxldGlvbiBkZWx0YSBnZW5lcmF0ZWQgYnkgc3RyZWFtZWQgbW9kZWwgcmVzcG9uc2VzLlxuICAgICAqL1xuICAgIGRlbHRhOiBDaG9pY2UuRGVsdGE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVhc29uIHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLiBUaGlzIHdpbGwgYmUgYHN0b3BgIGlmIHRoZSBtb2RlbFxuICAgICAqIGhpdCBhIG5hdHVyYWwgc3RvcCBwb2ludCBvciBhIHByb3ZpZGVkIHN0b3Agc2VxdWVuY2UsIGBsZW5ndGhgIGlmIHRoZSBtYXhpbXVtXG4gICAgICogbnVtYmVyIG9mIHRva2VucyBzcGVjaWZpZWQgaW4gdGhlIHJlcXVlc3Qgd2FzIHJlYWNoZWQsIGBjb250ZW50X2ZpbHRlcmAgaWZcbiAgICAgKiBjb250ZW50IHdhcyBvbWl0dGVkIGR1ZSB0byBhIGZsYWcgZnJvbSBvdXIgY29udGVudCBmaWx0ZXJzLCBgdG9vbF9jYWxsc2AgaWYgdGhlXG4gICAgICogbW9kZWwgY2FsbGVkIGEgdG9vbCwgb3IgYGZ1bmN0aW9uX2NhbGxgIChkZXByZWNhdGVkKSBpZiB0aGUgbW9kZWwgY2FsbGVkIGFcbiAgICAgKiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmaW5pc2hfcmVhc29uOiAnc3RvcCcgfCAnbGVuZ3RoJyB8ICd0b29sX2NhbGxzJyB8ICdjb250ZW50X2ZpbHRlcicgfCAnZnVuY3Rpb25fY2FsbCcgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBjaG9pY2UgaW4gdGhlIGxpc3Qgb2YgY2hvaWNlcy5cbiAgICAgKi9cbiAgICBpbmRleDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogTG9nIHByb2JhYmlsaXR5IGluZm9ybWF0aW9uIGZvciB0aGUgY2hvaWNlLlxuICAgICAqL1xuICAgIGxvZ3Byb2JzPzogQ2hvaWNlLkxvZ3Byb2JzIHwgbnVsbDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgQ2hvaWNlIHtcbiAgICAvKipcbiAgICAgKiBBIGNoYXQgY29tcGxldGlvbiBkZWx0YSBnZW5lcmF0ZWQgYnkgc3RyZWFtZWQgbW9kZWwgcmVzcG9uc2VzLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgRGVsdGEge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGNodW5rIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ/OiBzdHJpbmcgfCBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBkZXByZWNhdGVkOiBEZXByZWNhdGVkIGFuZCByZXBsYWNlZCBieSBgdG9vbF9jYWxsc2AuIFRoZSBuYW1lIGFuZCBhcmd1bWVudHMgb2ZcbiAgICAgICAqIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbl9jYWxsPzogRGVsdGEuRnVuY3Rpb25DYWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSByZWZ1c2FsIG1lc3NhZ2UgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICAgICAqL1xuICAgICAgcmVmdXNhbD86IHN0cmluZyB8IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHJvbGUgb2YgdGhlIGF1dGhvciBvZiB0aGlzIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIHJvbGU/OiAnc3lzdGVtJyB8ICd1c2VyJyB8ICdhc3Npc3RhbnQnIHwgJ3Rvb2wnO1xuXG4gICAgICB0b29sX2NhbGxzPzogQXJyYXk8RGVsdGEuVG9vbENhbGw+O1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgRGVsdGEge1xuICAgICAgLyoqXG4gICAgICAgKiBAZGVwcmVjYXRlZDogRGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgYnkgYHRvb2xfY2FsbHNgLiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mXG4gICAgICAgKiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICAgICAqL1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkNhbGwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICAgICAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAgICAgICAqIGhhbGx1Y2luYXRlIHBhcmFtZXRlcnMgbm90IGRlZmluZWQgYnkgeW91ciBmdW5jdGlvbiBzY2hlbWEuIFZhbGlkYXRlIHRoZVxuICAgICAgICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBhcmd1bWVudHM/OiBzdHJpbmc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgbmFtZT86IHN0cmluZztcbiAgICAgIH1cblxuICAgICAgZXhwb3J0IGludGVyZmFjZSBUb29sQ2FsbCB7XG4gICAgICAgIGluZGV4OiBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgaWQ/OiBzdHJpbmc7XG5cbiAgICAgICAgZnVuY3Rpb24/OiBUb29sQ2FsbC5GdW5jdGlvbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wuIEN1cnJlbnRseSwgb25seSBgZnVuY3Rpb25gIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHR5cGU/OiAnZnVuY3Rpb24nO1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgbmFtZXNwYWNlIFRvb2xDYWxsIHtcbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICAgICAgICAgKiBmb3JtYXQuIE5vdGUgdGhhdCB0aGUgbW9kZWwgZG9lcyBub3QgYWx3YXlzIGdlbmVyYXRlIHZhbGlkIEpTT04sIGFuZCBtYXlcbiAgICAgICAgICAgKiBoYWxsdWNpbmF0ZSBwYXJhbWV0ZXJzIG5vdCBkZWZpbmVkIGJ5IHlvdXIgZnVuY3Rpb24gc2NoZW1hLiBWYWxpZGF0ZSB0aGVcbiAgICAgICAgICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAgICAgICAgICovXG4gICAgICAgICAgYXJndW1lbnRzPzogc3RyaW5nO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICAgICAgICovXG4gICAgICAgICAgbmFtZT86IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvZyBwcm9iYWJpbGl0eSBpbmZvcm1hdGlvbiBmb3IgdGhlIGNob2ljZS5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIExvZ3Byb2JzIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIG1lc3NhZ2UgY29udGVudCB0b2tlbnMgd2l0aCBsb2cgcHJvYmFiaWxpdHkgaW5mb3JtYXRpb24uXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ6IEFycmF5PENoYXRDb21wbGV0aW9uc0FQSS5DaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYj4gfCBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBtZXNzYWdlIHJlZnVzYWwgdG9rZW5zIHdpdGggbG9nIHByb2JhYmlsaXR5IGluZm9ybWF0aW9uLlxuICAgICAgICovXG4gICAgICByZWZ1c2FsOiBBcnJheTxDaGF0Q29tcGxldGlvbnNBUEkuQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2I+IHwgbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBMZWFybiBhYm91dFxuICogW3RleHQgaW5wdXRzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvdGV4dC1nZW5lcmF0aW9uKS5cbiAqL1xuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydCA9XG4gIHwgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHRcbiAgfCBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2VcbiAgfCBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW5wdXRBdWRpbztcblxuLyoqXG4gKiBMZWFybiBhYm91dCBbaW1hZ2UgaW5wdXRzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvdmlzaW9uKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2Uge1xuICBpbWFnZV91cmw6IENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbWFnZS5JbWFnZVVSTDtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIGNvbnRlbnQgcGFydC5cbiAgICovXG4gIHR5cGU6ICdpbWFnZV91cmwnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbWFnZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VVUkwge1xuICAgIC8qKlxuICAgICAqIEVpdGhlciBhIFVSTCBvZiB0aGUgaW1hZ2Ugb3IgdGhlIGJhc2U2NCBlbmNvZGVkIGltYWdlIGRhdGEuXG4gICAgICovXG4gICAgdXJsOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGRldGFpbCBsZXZlbCBvZiB0aGUgaW1hZ2UuIExlYXJuIG1vcmUgaW4gdGhlXG4gICAgICogW1Zpc2lvbiBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3Zpc2lvbiNsb3ctb3ItaGlnaC1maWRlbGl0eS1pbWFnZS11bmRlcnN0YW5kaW5nKS5cbiAgICAgKi9cbiAgICBkZXRhaWw/OiAnYXV0bycgfCAnbG93JyB8ICdoaWdoJztcbiAgfVxufVxuXG4vKipcbiAqIExlYXJuIGFib3V0IFthdWRpbyBpbnB1dHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9hdWRpbykuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydElucHV0QXVkaW8ge1xuICBpbnB1dF9hdWRpbzogQ2hhdENvbXBsZXRpb25Db250ZW50UGFydElucHV0QXVkaW8uSW5wdXRBdWRpbztcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIGNvbnRlbnQgcGFydC4gQWx3YXlzIGBpbnB1dF9hdWRpb2AuXG4gICAqL1xuICB0eXBlOiAnaW5wdXRfYXVkaW8nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbnB1dEF1ZGlvIHtcbiAgZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvIHtcbiAgICAvKipcbiAgICAgKiBCYXNlNjQgZW5jb2RlZCBhdWRpbyBkYXRhLlxuICAgICAqL1xuICAgIGRhdGE6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb3JtYXQgb2YgdGhlIGVuY29kZWQgYXVkaW8gZGF0YS4gQ3VycmVudGx5IHN1cHBvcnRzIFwid2F2XCIgYW5kIFwibXAzXCIuXG4gICAgICovXG4gICAgZm9ybWF0OiAnd2F2JyB8ICdtcDMnO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFJlZnVzYWwge1xuICAvKipcbiAgICogVGhlIHJlZnVzYWwgbWVzc2FnZSBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgcmVmdXNhbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgY29udGVudCBwYXJ0LlxuICAgKi9cbiAgdHlwZTogJ3JlZnVzYWwnO1xufVxuXG4vKipcbiAqIExlYXJuIGFib3V0XG4gKiBbdGV4dCBpbnB1dHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy90ZXh0LWdlbmVyYXRpb24pLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0IHtcbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGNvbnRlbnQuXG4gICAqL1xuICB0ZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBjb250ZW50IHBhcnQuXG4gICAqL1xuICB0eXBlOiAndGV4dCc7XG59XG5cbi8qKlxuICogRGV2ZWxvcGVyLXByb3ZpZGVkIGluc3RydWN0aW9ucyB0aGF0IHRoZSBtb2RlbCBzaG91bGQgZm9sbG93LCByZWdhcmRsZXNzIG9mXG4gKiBtZXNzYWdlcyBzZW50IGJ5IHRoZSB1c2VyLiBXaXRoIG8xIG1vZGVscyBhbmQgbmV3ZXIsIGBkZXZlbG9wZXJgIG1lc3NhZ2VzXG4gKiByZXBsYWNlIHRoZSBwcmV2aW91cyBgc3lzdGVtYCBtZXNzYWdlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkRldmVsb3Blck1lc3NhZ2VQYXJhbSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGRldmVsb3BlciBtZXNzYWdlLlxuICAgKi9cbiAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8Q2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgbWVzc2FnZXMgYXV0aG9yLCBpbiB0aGlzIGNhc2UgYGRldmVsb3BlcmAuXG4gICAqL1xuICByb2xlOiAnZGV2ZWxvcGVyJztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIHBhcnRpY2lwYW50LiBQcm92aWRlcyB0aGUgbW9kZWwgaW5mb3JtYXRpb24gdG9cbiAgICogZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHBhcnRpY2lwYW50cyBvZiB0aGUgc2FtZSByb2xlLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciBmdW5jdGlvbiB2aWEgYHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifWAgZm9yY2VzIHRoZSBtb2RlbFxuICogdG8gY2FsbCB0aGF0IGZ1bmN0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uRnVuY3Rpb25DYWxsT3B0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25GdW5jdGlvbk1lc3NhZ2VQYXJhbSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGZ1bmN0aW9uIG1lc3NhZ2UuXG4gICAqL1xuICBjb250ZW50OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICovXG4gIG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIG1lc3NhZ2VzIGF1dGhvciwgaW4gdGhpcyBjYXNlIGBmdW5jdGlvbmAuXG4gICAqL1xuICByb2xlOiAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEEgY2hhdCBjb21wbGV0aW9uIG1lc3NhZ2UgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2Uge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgY29udGVudDogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHJlZnVzYWwgbWVzc2FnZSBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgcmVmdXNhbDogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIGF1dGhvciBvZiB0aGlzIG1lc3NhZ2UuXG4gICAqL1xuICByb2xlOiAnYXNzaXN0YW50JztcblxuICAvKipcbiAgICogSWYgdGhlIGF1ZGlvIG91dHB1dCBtb2RhbGl0eSBpcyByZXF1ZXN0ZWQsIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGRhdGEgYWJvdXQgdGhlXG4gICAqIGF1ZGlvIHJlc3BvbnNlIGZyb20gdGhlIG1vZGVsLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2F1ZGlvKS5cbiAgICovXG4gIGF1ZGlvPzogQ2hhdENvbXBsZXRpb25BdWRpbyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkOiBEZXByZWNhdGVkIGFuZCByZXBsYWNlZCBieSBgdG9vbF9jYWxsc2AuIFRoZSBuYW1lIGFuZCBhcmd1bWVudHMgb2ZcbiAgICogYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQsIGFzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICBmdW5jdGlvbl9jYWxsPzogQ2hhdENvbXBsZXRpb25NZXNzYWdlLkZ1bmN0aW9uQ2FsbCB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSB0b29sIGNhbGxzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwsIHN1Y2ggYXMgZnVuY3Rpb24gY2FsbHMuXG4gICAqL1xuICB0b29sX2NhbGxzPzogQXJyYXk8Q2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGw+O1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZDogRGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgYnkgYHRvb2xfY2FsbHNgLiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mXG4gICAqIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkNhbGwge1xuICAgIC8qKlxuICAgICAqIFRoZSBhcmd1bWVudHMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpbiBKU09OXG4gICAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAgICogaGFsbHVjaW5hdGUgcGFyYW1ldGVycyBub3QgZGVmaW5lZCBieSB5b3VyIGZ1bmN0aW9uIHNjaGVtYS4gVmFsaWRhdGUgdGhlXG4gICAgICogYXJndW1lbnRzIGluIHlvdXIgY29kZSBiZWZvcmUgY2FsbGluZyB5b3VyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGFyZ3VtZW50czogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogRGV2ZWxvcGVyLXByb3ZpZGVkIGluc3RydWN0aW9ucyB0aGF0IHRoZSBtb2RlbCBzaG91bGQgZm9sbG93LCByZWdhcmRsZXNzIG9mXG4gKiBtZXNzYWdlcyBzZW50IGJ5IHRoZSB1c2VyLiBXaXRoIG8xIG1vZGVscyBhbmQgbmV3ZXIsIGBkZXZlbG9wZXJgIG1lc3NhZ2VzXG4gKiByZXBsYWNlIHRoZSBwcmV2aW91cyBgc3lzdGVtYCBtZXNzYWdlcy5cbiAqL1xuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0gPVxuICB8IENoYXRDb21wbGV0aW9uRGV2ZWxvcGVyTWVzc2FnZVBhcmFtXG4gIHwgQ2hhdENvbXBsZXRpb25TeXN0ZW1NZXNzYWdlUGFyYW1cbiAgfCBDaGF0Q29tcGxldGlvblVzZXJNZXNzYWdlUGFyYW1cbiAgfCBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbVxuICB8IENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbVxuICB8IENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gdGhhdCB0aGUgbW9kZWwgY2FsbGVkLlxuICAgKi9cbiAgZnVuY3Rpb246IENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsLkZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbC4gQ3VycmVudGx5LCBvbmx5IGBmdW5jdGlvbmAgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgdHlwZTogJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCB7XG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gdGhhdCB0aGUgbW9kZWwgY2FsbGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICAgKiBmb3JtYXQuIE5vdGUgdGhhdCB0aGUgbW9kZWwgZG9lcyBub3QgYWx3YXlzIGdlbmVyYXRlIHZhbGlkIEpTT04sIGFuZCBtYXlcbiAgICAgKiBoYWxsdWNpbmF0ZSBwYXJhbWV0ZXJzIG5vdCBkZWZpbmVkIGJ5IHlvdXIgZnVuY3Rpb24gc2NoZW1hLiBWYWxpZGF0ZSB0aGVcbiAgICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXJndW1lbnRzOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmc7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25Nb2RhbGl0eSA9ICd0ZXh0JyB8ICdhdWRpbyc7XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgdG9vbCB0aGUgbW9kZWwgc2hvdWxkIHVzZS4gVXNlIHRvIGZvcmNlIHRoZSBtb2RlbCB0byBjYWxsIGEgc3BlY2lmaWNcbiAqIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlIHtcbiAgZnVuY3Rpb246IENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlLkZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbC4gQ3VycmVudGx5LCBvbmx5IGBmdW5jdGlvbmAgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgdHlwZTogJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0Q29tcGxldGlvbk5hbWVkVG9vbENob2ljZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIFN0YXRpYyBwcmVkaWN0ZWQgb3V0cHV0IGNvbnRlbnQsIHN1Y2ggYXMgdGhlIGNvbnRlbnQgb2YgYSB0ZXh0IGZpbGUgdGhhdCBpc1xuICogYmVpbmcgcmVnZW5lcmF0ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25QcmVkaWN0aW9uQ29udGVudCB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudCB0aGF0IHNob3VsZCBiZSBtYXRjaGVkIHdoZW4gZ2VuZXJhdGluZyBhIG1vZGVsIHJlc3BvbnNlLiBJZlxuICAgKiBnZW5lcmF0ZWQgdG9rZW5zIHdvdWxkIG1hdGNoIHRoaXMgY29udGVudCwgdGhlIGVudGlyZSBtb2RlbCByZXNwb25zZSBjYW4gYmVcbiAgICogcmV0dXJuZWQgbXVjaCBtb3JlIHF1aWNrbHkuXG4gICAqL1xuICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dD47XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBwcmVkaWN0ZWQgY29udGVudCB5b3Ugd2FudCB0byBwcm92aWRlLiBUaGlzIHR5cGUgaXMgY3VycmVudGx5XG4gICAqIGFsd2F5cyBgY29udGVudGAuXG4gICAqL1xuICB0eXBlOiAnY29udGVudCc7XG59XG5cbi8qKlxuICogKipvMSBtb2RlbHMgb25seSoqXG4gKlxuICogQ29uc3RyYWlucyBlZmZvcnQgb24gcmVhc29uaW5nIGZvclxuICogW3JlYXNvbmluZyBtb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9yZWFzb25pbmcpLiBDdXJyZW50bHlcbiAqIHN1cHBvcnRlZCB2YWx1ZXMgYXJlIGBsb3dgLCBgbWVkaXVtYCwgYW5kIGBoaWdoYC4gUmVkdWNpbmcgcmVhc29uaW5nIGVmZm9ydCBjYW5cbiAqIHJlc3VsdCBpbiBmYXN0ZXIgcmVzcG9uc2VzIGFuZCBmZXdlciB0b2tlbnMgdXNlZCBvbiByZWFzb25pbmcgaW4gYSByZXNwb25zZS5cbiAqL1xuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25SZWFzb25pbmdFZmZvcnQgPSAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnO1xuXG4vKipcbiAqIFRoZSByb2xlIG9mIHRoZSBhdXRob3Igb2YgYSBtZXNzYWdlXG4gKi9cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uUm9sZSA9ICdzeXN0ZW0nIHwgJ3VzZXInIHwgJ2Fzc2lzdGFudCcgfCAndG9vbCcgfCAnZnVuY3Rpb24nO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHN0cmVhbWluZyByZXNwb25zZS4gT25seSBzZXQgdGhpcyB3aGVuIHlvdSBzZXQgYHN0cmVhbTogdHJ1ZWAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25TdHJlYW1PcHRpb25zIHtcbiAgLyoqXG4gICAqIElmIHNldCwgYW4gYWRkaXRpb25hbCBjaHVuayB3aWxsIGJlIHN0cmVhbWVkIGJlZm9yZSB0aGUgYGRhdGE6IFtET05FXWAgbWVzc2FnZS5cbiAgICogVGhlIGB1c2FnZWAgZmllbGQgb24gdGhpcyBjaHVuayBzaG93cyB0aGUgdG9rZW4gdXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIGVudGlyZVxuICAgKiByZXF1ZXN0LCBhbmQgdGhlIGBjaG9pY2VzYCBmaWVsZCB3aWxsIGFsd2F5cyBiZSBhbiBlbXB0eSBhcnJheS4gQWxsIG90aGVyIGNodW5rc1xuICAgKiB3aWxsIGFsc28gaW5jbHVkZSBhIGB1c2FnZWAgZmllbGQsIGJ1dCB3aXRoIGEgbnVsbCB2YWx1ZS5cbiAgICovXG4gIGluY2x1ZGVfdXNhZ2U/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIERldmVsb3Blci1wcm92aWRlZCBpbnN0cnVjdGlvbnMgdGhhdCB0aGUgbW9kZWwgc2hvdWxkIGZvbGxvdywgcmVnYXJkbGVzcyBvZlxuICogbWVzc2FnZXMgc2VudCBieSB0aGUgdXNlci4gV2l0aCBvMSBtb2RlbHMgYW5kIG5ld2VyLCB1c2UgYGRldmVsb3BlcmAgbWVzc2FnZXNcbiAqIGZvciB0aGlzIHB1cnBvc2UgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvblN5c3RlbU1lc3NhZ2VQYXJhbSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIHN5c3RlbSBtZXNzYWdlLlxuICAgKi9cbiAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8Q2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgbWVzc2FnZXMgYXV0aG9yLCBpbiB0aGlzIGNhc2UgYHN5c3RlbWAuXG4gICAqL1xuICByb2xlOiAnc3lzdGVtJztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIHBhcnRpY2lwYW50LiBQcm92aWRlcyB0aGUgbW9kZWwgaW5mb3JtYXRpb24gdG9cbiAgICogZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHBhcnRpY2lwYW50cyBvZiB0aGUgc2FtZSByb2xlLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYiB7XG4gIC8qKlxuICAgKiBUaGUgdG9rZW4uXG4gICAqL1xuICB0b2tlbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgaW50ZWdlcnMgcmVwcmVzZW50aW5nIHRoZSBVVEYtOCBieXRlcyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdG9rZW4uXG4gICAqIFVzZWZ1bCBpbiBpbnN0YW5jZXMgd2hlcmUgY2hhcmFjdGVycyBhcmUgcmVwcmVzZW50ZWQgYnkgbXVsdGlwbGUgdG9rZW5zIGFuZFxuICAgKiB0aGVpciBieXRlIHJlcHJlc2VudGF0aW9ucyBtdXN0IGJlIGNvbWJpbmVkIHRvIGdlbmVyYXRlIHRoZSBjb3JyZWN0IHRleHRcbiAgICogcmVwcmVzZW50YXRpb24uIENhbiBiZSBgbnVsbGAgaWYgdGhlcmUgaXMgbm8gYnl0ZXMgcmVwcmVzZW50YXRpb24gZm9yIHRoZSB0b2tlbi5cbiAgICovXG4gIGJ5dGVzOiBBcnJheTxudW1iZXI+IHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGxvZyBwcm9iYWJpbGl0eSBvZiB0aGlzIHRva2VuLCBpZiBpdCBpcyB3aXRoaW4gdGhlIHRvcCAyMCBtb3N0IGxpa2VseVxuICAgKiB0b2tlbnMuIE90aGVyd2lzZSwgdGhlIHZhbHVlIGAtOTk5OS4wYCBpcyB1c2VkIHRvIHNpZ25pZnkgdGhhdCB0aGUgdG9rZW4gaXMgdmVyeVxuICAgKiB1bmxpa2VseS5cbiAgICovXG4gIGxvZ3Byb2I6IG51bWJlcjtcblxuICAvKipcbiAgICogTGlzdCBvZiB0aGUgbW9zdCBsaWtlbHkgdG9rZW5zIGFuZCB0aGVpciBsb2cgcHJvYmFiaWxpdHksIGF0IHRoaXMgdG9rZW5cbiAgICogcG9zaXRpb24uIEluIHJhcmUgY2FzZXMsIHRoZXJlIG1heSBiZSBmZXdlciB0aGFuIHRoZSBudW1iZXIgb2YgcmVxdWVzdGVkXG4gICAqIGB0b3BfbG9ncHJvYnNgIHJldHVybmVkLlxuICAgKi9cbiAgdG9wX2xvZ3Byb2JzOiBBcnJheTxDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYi5Ub3BMb2dwcm9iPjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYiB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9wTG9ncHJvYiB7XG4gICAgLyoqXG4gICAgICogVGhlIHRva2VuLlxuICAgICAqL1xuICAgIHRva2VuOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgaW50ZWdlcnMgcmVwcmVzZW50aW5nIHRoZSBVVEYtOCBieXRlcyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdG9rZW4uXG4gICAgICogVXNlZnVsIGluIGluc3RhbmNlcyB3aGVyZSBjaGFyYWN0ZXJzIGFyZSByZXByZXNlbnRlZCBieSBtdWx0aXBsZSB0b2tlbnMgYW5kXG4gICAgICogdGhlaXIgYnl0ZSByZXByZXNlbnRhdGlvbnMgbXVzdCBiZSBjb21iaW5lZCB0byBnZW5lcmF0ZSB0aGUgY29ycmVjdCB0ZXh0XG4gICAgICogcmVwcmVzZW50YXRpb24uIENhbiBiZSBgbnVsbGAgaWYgdGhlcmUgaXMgbm8gYnl0ZXMgcmVwcmVzZW50YXRpb24gZm9yIHRoZSB0b2tlbi5cbiAgICAgKi9cbiAgICBieXRlczogQXJyYXk8bnVtYmVyPiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9nIHByb2JhYmlsaXR5IG9mIHRoaXMgdG9rZW4sIGlmIGl0IGlzIHdpdGhpbiB0aGUgdG9wIDIwIG1vc3QgbGlrZWx5XG4gICAgICogdG9rZW5zLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBgLTk5OTkuMGAgaXMgdXNlZCB0byBzaWduaWZ5IHRoYXQgdGhlIHRva2VuIGlzIHZlcnlcbiAgICAgKiB1bmxpa2VseS5cbiAgICAgKi9cbiAgICBsb2dwcm9iOiBudW1iZXI7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvblRvb2wge1xuICBmdW5jdGlvbjogU2hhcmVkLkZ1bmN0aW9uRGVmaW5pdGlvbjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wuIEN1cnJlbnRseSwgb25seSBgZnVuY3Rpb25gIGlzIHN1cHBvcnRlZC5cbiAgICovXG4gIHR5cGU6ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgdG9vbCBpcyBjYWxsZWQgYnkgdGhlIG1vZGVsLiBgbm9uZWAgbWVhbnMgdGhlIG1vZGVsIHdpbGxcbiAqIG5vdCBjYWxsIGFueSB0b29sIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBtZWFucyB0aGUgbW9kZWwgY2FuXG4gKiBwaWNrIGJldHdlZW4gZ2VuZXJhdGluZyBhIG1lc3NhZ2Ugb3IgY2FsbGluZyBvbmUgb3IgbW9yZSB0b29scy4gYHJlcXVpcmVkYCBtZWFuc1xuICogdGhlIG1vZGVsIG11c3QgY2FsbCBvbmUgb3IgbW9yZSB0b29scy4gU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgdG9vbCB2aWFcbiAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gKiBjYWxsIHRoYXQgdG9vbC5cbiAqXG4gKiBgbm9uZWAgaXMgdGhlIGRlZmF1bHQgd2hlbiBubyB0b29scyBhcmUgcHJlc2VudC4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IGlmIHRvb2xzXG4gKiBhcmUgcHJlc2VudC5cbiAqL1xuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sQ2hvaWNlT3B0aW9uID0gJ25vbmUnIHwgJ2F1dG8nIHwgJ3JlcXVpcmVkJyB8IENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIHRvb2wgbWVzc2FnZS5cbiAgICovXG4gIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0PjtcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIG1lc3NhZ2VzIGF1dGhvciwgaW4gdGhpcyBjYXNlIGB0b29sYC5cbiAgICovXG4gIHJvbGU6ICd0b29sJztcblxuICAvKipcbiAgICogVG9vbCBjYWxsIHRoYXQgdGhpcyBtZXNzYWdlIGlzIHJlc3BvbmRpbmcgdG8uXG4gICAqL1xuICB0b29sX2NhbGxfaWQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBNZXNzYWdlcyBzZW50IGJ5IGFuIGVuZCB1c2VyLCBjb250YWluaW5nIHByb21wdHMgb3IgYWRkaXRpb25hbCBjb250ZXh0XG4gKiBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvblVzZXJNZXNzYWdlUGFyYW0ge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSB1c2VyIG1lc3NhZ2UuXG4gICAqL1xuICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0PjtcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIG1lc3NhZ2VzIGF1dGhvciwgaW4gdGhpcyBjYXNlIGB1c2VyYC5cbiAgICovXG4gIHJvbGU6ICd1c2VyJztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIHBhcnRpY2lwYW50LiBQcm92aWRlcyB0aGUgbW9kZWwgaW5mb3JtYXRpb24gdG9cbiAgICogZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHBhcnRpY2lwYW50cyBvZiB0aGUgc2FtZSByb2xlLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkXG4gKi9cbmV4cG9ydCB0eXBlIENyZWF0ZUNoYXRDb21wbGV0aW9uUmVxdWVzdE1lc3NhZ2UgPSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbTtcblxuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMgPVxuICB8IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nXG4gIHwgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBtZXNzYWdlcyBjb21wcmlzaW5nIHRoZSBjb252ZXJzYXRpb24gc28gZmFyLiBEZXBlbmRpbmcgb24gdGhlXG4gICAqIFttb2RlbF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzKSB5b3UgdXNlLCBkaWZmZXJlbnQgbWVzc2FnZVxuICAgKiB0eXBlcyAobW9kYWxpdGllcykgYXJlIHN1cHBvcnRlZCwgbGlrZVxuICAgKiBbdGV4dF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3RleHQtZ2VuZXJhdGlvbiksXG4gICAqIFtpbWFnZXNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy92aXNpb24pLCBhbmRcbiAgICogW2F1ZGlvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYXVkaW8pLlxuICAgKi9cbiAgbWVzc2FnZXM6IEFycmF5PENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtPjtcblxuICAvKipcbiAgICogSUQgb2YgdGhlIG1vZGVsIHRvIHVzZS4gU2VlIHRoZVxuICAgKiBbbW9kZWwgZW5kcG9pbnQgY29tcGF0aWJpbGl0eV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI21vZGVsLWVuZHBvaW50LWNvbXBhdGliaWxpdHkpXG4gICAqIHRhYmxlIGZvciBkZXRhaWxzIG9uIHdoaWNoIG1vZGVscyB3b3JrIHdpdGggdGhlIENoYXQgQVBJLlxuICAgKi9cbiAgbW9kZWw6IChzdHJpbmcgJiB7fSkgfCBDaGF0QVBJLkNoYXRNb2RlbDtcblxuICAvKipcbiAgICogUGFyYW1ldGVycyBmb3IgYXVkaW8gb3V0cHV0LiBSZXF1aXJlZCB3aGVuIGF1ZGlvIG91dHB1dCBpcyByZXF1ZXN0ZWQgd2l0aFxuICAgKiBgbW9kYWxpdGllczogW1wiYXVkaW9cIl1gLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2F1ZGlvKS5cbiAgICovXG4gIGF1ZGlvPzogQ2hhdENvbXBsZXRpb25BdWRpb1BhcmFtIHwgbnVsbDtcblxuICAvKipcbiAgICogTnVtYmVyIGJldHdlZW4gLTIuMCBhbmQgMi4wLiBQb3NpdGl2ZSB2YWx1ZXMgcGVuYWxpemUgbmV3IHRva2VucyBiYXNlZCBvbiB0aGVpclxuICAgKiBleGlzdGluZyBmcmVxdWVuY3kgaW4gdGhlIHRleHQgc28gZmFyLCBkZWNyZWFzaW5nIHRoZSBtb2RlbCdzIGxpa2VsaWhvb2QgdG9cbiAgICogcmVwZWF0IHRoZSBzYW1lIGxpbmUgdmVyYmF0aW0uXG4gICAqL1xuICBmcmVxdWVuY3lfcGVuYWx0eT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgYHRvb2xfY2hvaWNlYC5cbiAgICpcbiAgICogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC5cbiAgICpcbiAgICogYG5vbmVgIG1lYW5zIHRoZSBtb2RlbCB3aWxsIG5vdCBjYWxsIGEgZnVuY3Rpb24gYW5kIGluc3RlYWQgZ2VuZXJhdGVzIGEgbWVzc2FnZS5cbiAgICpcbiAgICogYGF1dG9gIG1lYW5zIHRoZSBtb2RlbCBjYW4gcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yIGNhbGxpbmcgYVxuICAgKiBmdW5jdGlvbi5cbiAgICpcbiAgICogU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgZnVuY3Rpb24gdmlhIGB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn1gIGZvcmNlcyB0aGUgbW9kZWxcbiAgICogdG8gY2FsbCB0aGF0IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBgbm9uZWAgaXMgdGhlIGRlZmF1bHQgd2hlbiBubyBmdW5jdGlvbnMgYXJlIHByZXNlbnQuIGBhdXRvYCBpcyB0aGUgZGVmYXVsdCBpZlxuICAgKiBmdW5jdGlvbnMgYXJlIHByZXNlbnQuXG4gICAqL1xuICBmdW5jdGlvbl9jYWxsPzogJ25vbmUnIHwgJ2F1dG8nIHwgQ2hhdENvbXBsZXRpb25GdW5jdGlvbkNhbGxPcHRpb247XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgYHRvb2xzYC5cbiAgICpcbiAgICogQSBsaXN0IG9mIGZ1bmN0aW9ucyB0aGUgbW9kZWwgbWF5IGdlbmVyYXRlIEpTT04gaW5wdXRzIGZvci5cbiAgICovXG4gIGZ1bmN0aW9ucz86IEFycmF5PENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLkZ1bmN0aW9uPjtcblxuICAvKipcbiAgICogTW9kaWZ5IHRoZSBsaWtlbGlob29kIG9mIHNwZWNpZmllZCB0b2tlbnMgYXBwZWFyaW5nIGluIHRoZSBjb21wbGV0aW9uLlxuICAgKlxuICAgKiBBY2NlcHRzIGEgSlNPTiBvYmplY3QgdGhhdCBtYXBzIHRva2VucyAoc3BlY2lmaWVkIGJ5IHRoZWlyIHRva2VuIElEIGluIHRoZVxuICAgKiB0b2tlbml6ZXIpIHRvIGFuIGFzc29jaWF0ZWQgYmlhcyB2YWx1ZSBmcm9tIC0xMDAgdG8gMTAwLiBNYXRoZW1hdGljYWxseSwgdGhlXG4gICAqIGJpYXMgaXMgYWRkZWQgdG8gdGhlIGxvZ2l0cyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIHByaW9yIHRvIHNhbXBsaW5nLiBUaGUgZXhhY3RcbiAgICogZWZmZWN0IHdpbGwgdmFyeSBwZXIgbW9kZWwsIGJ1dCB2YWx1ZXMgYmV0d2VlbiAtMSBhbmQgMSBzaG91bGQgZGVjcmVhc2Ugb3JcbiAgICogaW5jcmVhc2UgbGlrZWxpaG9vZCBvZiBzZWxlY3Rpb247IHZhbHVlcyBsaWtlIC0xMDAgb3IgMTAwIHNob3VsZCByZXN1bHQgaW4gYSBiYW5cbiAgICogb3IgZXhjbHVzaXZlIHNlbGVjdGlvbiBvZiB0aGUgcmVsZXZhbnQgdG9rZW4uXG4gICAqL1xuICBsb2dpdF9iaWFzPzogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmV0dXJuIGxvZyBwcm9iYWJpbGl0aWVzIG9mIHRoZSBvdXRwdXQgdG9rZW5zIG9yIG5vdC4gSWYgdHJ1ZSxcbiAgICogcmV0dXJucyB0aGUgbG9nIHByb2JhYmlsaXRpZXMgb2YgZWFjaCBvdXRwdXQgdG9rZW4gcmV0dXJuZWQgaW4gdGhlIGBjb250ZW50YCBvZlxuICAgKiBgbWVzc2FnZWAuXG4gICAqL1xuICBsb2dwcm9icz86IGJvb2xlYW4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiB1cHBlciBib3VuZCBmb3IgdGhlIG51bWJlciBvZiB0b2tlbnMgdGhhdCBjYW4gYmUgZ2VuZXJhdGVkIGZvciBhIGNvbXBsZXRpb24sXG4gICAqIGluY2x1ZGluZyB2aXNpYmxlIG91dHB1dCB0b2tlbnMgYW5kXG4gICAqIFtyZWFzb25pbmcgdG9rZW5zXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvcmVhc29uaW5nKS5cbiAgICovXG4gIG1heF9jb21wbGV0aW9uX3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBbdG9rZW5zXSgvdG9rZW5pemVyKSB0aGF0IGNhbiBiZSBnZW5lcmF0ZWQgaW4gdGhlIGNoYXRcbiAgICogY29tcGxldGlvbi4gVGhpcyB2YWx1ZSBjYW4gYmUgdXNlZCB0byBjb250cm9sXG4gICAqIFtjb3N0c10oaHR0cHM6Ly9vcGVuYWkuY29tL2FwaS9wcmljaW5nLykgZm9yIHRleHQgZ2VuZXJhdGVkIHZpYSBBUEkuXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgaXMgbm93IGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgYG1heF9jb21wbGV0aW9uX3Rva2Vuc2AsIGFuZCBpcyBub3RcbiAgICogY29tcGF0aWJsZSB3aXRoXG4gICAqIFtvMSBzZXJpZXMgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvcmVhc29uaW5nKS5cbiAgICovXG4gIG1heF90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBEZXZlbG9wZXItZGVmaW5lZCB0YWdzIGFuZCB2YWx1ZXMgdXNlZCBmb3IgZmlsdGVyaW5nIGNvbXBsZXRpb25zIGluIHRoZVxuICAgKiBbZGFzaGJvYXJkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vY2hhdC1jb21wbGV0aW9ucykuXG4gICAqL1xuICBtZXRhZGF0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPdXRwdXQgdHlwZXMgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgbW9kZWwgdG8gZ2VuZXJhdGUgZm9yIHRoaXMgcmVxdWVzdC4gTW9zdFxuICAgKiBtb2RlbHMgYXJlIGNhcGFibGUgb2YgZ2VuZXJhdGluZyB0ZXh0LCB3aGljaCBpcyB0aGUgZGVmYXVsdDpcbiAgICpcbiAgICogYFtcInRleHRcIl1gXG4gICAqXG4gICAqIFRoZSBgZ3B0LTRvLWF1ZGlvLXByZXZpZXdgIG1vZGVsIGNhbiBhbHNvIGJlIHVzZWQgdG9cbiAgICogW2dlbmVyYXRlIGF1ZGlvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYXVkaW8pLiBUbyByZXF1ZXN0IHRoYXRcbiAgICogdGhpcyBtb2RlbCBnZW5lcmF0ZSBib3RoIHRleHQgYW5kIGF1ZGlvIHJlc3BvbnNlcywgeW91IGNhbiB1c2U6XG4gICAqXG4gICAqIGBbXCJ0ZXh0XCIsIFwiYXVkaW9cIl1gXG4gICAqL1xuICBtb2RhbGl0aWVzPzogQXJyYXk8Q2hhdENvbXBsZXRpb25Nb2RhbGl0eT4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBIb3cgbWFueSBjaGF0IGNvbXBsZXRpb24gY2hvaWNlcyB0byBnZW5lcmF0ZSBmb3IgZWFjaCBpbnB1dCBtZXNzYWdlLiBOb3RlIHRoYXRcbiAgICogeW91IHdpbGwgYmUgY2hhcmdlZCBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIGdlbmVyYXRlZCB0b2tlbnMgYWNyb3NzIGFsbCBvZiB0aGVcbiAgICogY2hvaWNlcy4gS2VlcCBgbmAgYXMgYDFgIHRvIG1pbmltaXplIGNvc3RzLlxuICAgKi9cbiAgbj86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlXG4gICAqIFtwYXJhbGxlbCBmdW5jdGlvbiBjYWxsaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZnVuY3Rpb24tY2FsbGluZyNjb25maWd1cmluZy1wYXJhbGxlbC1mdW5jdGlvbi1jYWxsaW5nKVxuICAgKiBkdXJpbmcgdG9vbCB1c2UuXG4gICAqL1xuICBwYXJhbGxlbF90b29sX2NhbGxzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogU3RhdGljIHByZWRpY3RlZCBvdXRwdXQgY29udGVudCwgc3VjaCBhcyB0aGUgY29udGVudCBvZiBhIHRleHQgZmlsZSB0aGF0IGlzXG4gICAqIGJlaW5nIHJlZ2VuZXJhdGVkLlxuICAgKi9cbiAgcHJlZGljdGlvbj86IENoYXRDb21wbGV0aW9uUHJlZGljdGlvbkNvbnRlbnQgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgYmV0d2VlbiAtMi4wIGFuZCAyLjAuIFBvc2l0aXZlIHZhbHVlcyBwZW5hbGl6ZSBuZXcgdG9rZW5zIGJhc2VkIG9uXG4gICAqIHdoZXRoZXIgdGhleSBhcHBlYXIgaW4gdGhlIHRleHQgc28gZmFyLCBpbmNyZWFzaW5nIHRoZSBtb2RlbCdzIGxpa2VsaWhvb2QgdG9cbiAgICogdGFsayBhYm91dCBuZXcgdG9waWNzLlxuICAgKi9cbiAgcHJlc2VuY2VfcGVuYWx0eT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqICoqbzEgbW9kZWxzIG9ubHkqKlxuICAgKlxuICAgKiBDb25zdHJhaW5zIGVmZm9ydCBvbiByZWFzb25pbmcgZm9yXG4gICAqIFtyZWFzb25pbmcgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvcmVhc29uaW5nKS4gQ3VycmVudGx5XG4gICAqIHN1cHBvcnRlZCB2YWx1ZXMgYXJlIGBsb3dgLCBgbWVkaXVtYCwgYW5kIGBoaWdoYC4gUmVkdWNpbmcgcmVhc29uaW5nIGVmZm9ydCBjYW5cbiAgICogcmVzdWx0IGluIGZhc3RlciByZXNwb25zZXMgYW5kIGZld2VyIHRva2VucyB1c2VkIG9uIHJlYXNvbmluZyBpbiBhIHJlc3BvbnNlLlxuICAgKi9cbiAgcmVhc29uaW5nX2VmZm9ydD86IENoYXRDb21wbGV0aW9uUmVhc29uaW5nRWZmb3J0O1xuXG4gIC8qKlxuICAgKiBBbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fc2NoZW1hXCIsIFwianNvbl9zY2hlbWFcIjogey4uLn0gfWAgZW5hYmxlcyBTdHJ1Y3R1cmVkXG4gICAqIE91dHB1dHMgd2hpY2ggZW5zdXJlcyB0aGUgbW9kZWwgd2lsbCBtYXRjaCB5b3VyIHN1cHBsaWVkIEpTT04gc2NoZW1hLiBMZWFybiBtb3JlXG4gICAqIGluIHRoZVxuICAgKiBbU3RydWN0dXJlZCBPdXRwdXRzIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc3RydWN0dXJlZC1vdXRwdXRzKS5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBlbnN1cmVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzpcbiAgICB8IFNoYXJlZC5SZXNwb25zZUZvcm1hdFRleHRcbiAgICB8IFNoYXJlZC5SZXNwb25zZUZvcm1hdEpTT05PYmplY3RcbiAgICB8IFNoYXJlZC5SZXNwb25zZUZvcm1hdEpTT05TY2hlbWE7XG5cbiAgLyoqXG4gICAqIFRoaXMgZmVhdHVyZSBpcyBpbiBCZXRhLiBJZiBzcGVjaWZpZWQsIG91ciBzeXN0ZW0gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG9cbiAgICogc2FtcGxlIGRldGVybWluaXN0aWNhbGx5LCBzdWNoIHRoYXQgcmVwZWF0ZWQgcmVxdWVzdHMgd2l0aCB0aGUgc2FtZSBgc2VlZGAgYW5kXG4gICAqIHBhcmFtZXRlcnMgc2hvdWxkIHJldHVybiB0aGUgc2FtZSByZXN1bHQuIERldGVybWluaXNtIGlzIG5vdCBndWFyYW50ZWVkLCBhbmQgeW91XG4gICAqIHNob3VsZCByZWZlciB0byB0aGUgYHN5c3RlbV9maW5nZXJwcmludGAgcmVzcG9uc2UgcGFyYW1ldGVyIHRvIG1vbml0b3IgY2hhbmdlc1xuICAgKiBpbiB0aGUgYmFja2VuZC5cbiAgICovXG4gIHNlZWQ/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGxhdGVuY3kgdGllciB0byB1c2UgZm9yIHByb2Nlc3NpbmcgdGhlIHJlcXVlc3QuIFRoaXMgcGFyYW1ldGVyIGlzXG4gICAqIHJlbGV2YW50IGZvciBjdXN0b21lcnMgc3Vic2NyaWJlZCB0byB0aGUgc2NhbGUgdGllciBzZXJ2aWNlOlxuICAgKlxuICAgKiAtIElmIHNldCB0byAnYXV0bycsIGFuZCB0aGUgUHJvamVjdCBpcyBTY2FsZSB0aWVyIGVuYWJsZWQsIHRoZSBzeXN0ZW0gd2lsbFxuICAgKiAgIHV0aWxpemUgc2NhbGUgdGllciBjcmVkaXRzIHVudGlsIHRoZXkgYXJlIGV4aGF1c3RlZC5cbiAgICogLSBJZiBzZXQgdG8gJ2F1dG8nLCBhbmQgdGhlIFByb2plY3QgaXMgbm90IFNjYWxlIHRpZXIgZW5hYmxlZCwgdGhlIHJlcXVlc3Qgd2lsbFxuICAgKiAgIGJlIHByb2Nlc3NlZCB1c2luZyB0aGUgZGVmYXVsdCBzZXJ2aWNlIHRpZXIgd2l0aCBhIGxvd2VyIHVwdGltZSBTTEEgYW5kIG5vXG4gICAqICAgbGF0ZW5jeSBndWFyZW50ZWUuXG4gICAqIC0gSWYgc2V0IHRvICdkZWZhdWx0JywgdGhlIHJlcXVlc3Qgd2lsbCBiZSBwcm9jZXNzZWQgdXNpbmcgdGhlIGRlZmF1bHQgc2VydmljZVxuICAgKiAgIHRpZXIgd2l0aCBhIGxvd2VyIHVwdGltZSBTTEEgYW5kIG5vIGxhdGVuY3kgZ3VhcmVudGVlLlxuICAgKiAtIFdoZW4gbm90IHNldCwgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgJ2F1dG8nLlxuICAgKlxuICAgKiBXaGVuIHRoaXMgcGFyYW1ldGVyIGlzIHNldCwgdGhlIHJlc3BvbnNlIGJvZHkgd2lsbCBpbmNsdWRlIHRoZSBgc2VydmljZV90aWVyYFxuICAgKiB1dGlsaXplZC5cbiAgICovXG4gIHNlcnZpY2VfdGllcj86ICdhdXRvJyB8ICdkZWZhdWx0JyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFVwIHRvIDQgc2VxdWVuY2VzIHdoZXJlIHRoZSBBUEkgd2lsbCBzdG9wIGdlbmVyYXRpbmcgZnVydGhlciB0b2tlbnMuXG4gICAqL1xuICBzdG9wPzogc3RyaW5nIHwgbnVsbCB8IEFycmF5PHN0cmluZz47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRvIHN0b3JlIHRoZSBvdXRwdXQgb2YgdGhpcyBjaGF0IGNvbXBsZXRpb24gcmVxdWVzdCBmb3IgdXNlIGluXG4gICAqIG91ciBbbW9kZWwgZGlzdGlsbGF0aW9uXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZGlzdGlsbGF0aW9uKVxuICAgKiBvciBbZXZhbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9ldmFscykgcHJvZHVjdHMuXG4gICAqL1xuICBzdG9yZT86IGJvb2xlYW4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJZiBzZXQsIHBhcnRpYWwgbWVzc2FnZSBkZWx0YXMgd2lsbCBiZSBzZW50LCBsaWtlIGluIENoYXRHUFQuIFRva2VucyB3aWxsIGJlXG4gICAqIHNlbnQgYXMgZGF0YS1vbmx5XG4gICAqIFtzZXJ2ZXItc2VudCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2ZXItc2VudF9ldmVudHMvVXNpbmdfc2VydmVyLXNlbnRfZXZlbnRzI0V2ZW50X3N0cmVhbV9mb3JtYXQpXG4gICAqIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSwgd2l0aCB0aGUgc3RyZWFtIHRlcm1pbmF0ZWQgYnkgYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9jb29rYm9vay5vcGVuYWkuY29tL2V4YW1wbGVzL2hvd190b19zdHJlYW1fY29tcGxldGlvbnMpLlxuICAgKi9cbiAgc3RyZWFtPzogYm9vbGVhbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgZm9yIHN0cmVhbWluZyByZXNwb25zZS4gT25seSBzZXQgdGhpcyB3aGVuIHlvdSBzZXQgYHN0cmVhbTogdHJ1ZWAuXG4gICAqL1xuICBzdHJlYW1fb3B0aW9ucz86IENoYXRDb21wbGV0aW9uU3RyZWFtT3B0aW9ucyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoYXQgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdG8gdXNlLCBiZXR3ZWVuIDAgYW5kIDIuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbFxuICAgKiBtYWtlIHRoZSBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZVxuICAgKiBmb2N1c2VkIGFuZCBkZXRlcm1pbmlzdGljLiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgYHRvcF9wYCBidXRcbiAgICogbm90IGJvdGguXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIHdoaWNoIChpZiBhbnkpIHRvb2wgaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC4gYG5vbmVgIG1lYW5zIHRoZSBtb2RlbCB3aWxsXG4gICAqIG5vdCBjYWxsIGFueSB0b29sIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBtZWFucyB0aGUgbW9kZWwgY2FuXG4gICAqIHBpY2sgYmV0d2VlbiBnZW5lcmF0aW5nIGEgbWVzc2FnZSBvciBjYWxsaW5nIG9uZSBvciBtb3JlIHRvb2xzLiBgcmVxdWlyZWRgIG1lYW5zXG4gICAqIHRoZSBtb2RlbCBtdXN0IGNhbGwgb25lIG9yIG1vcmUgdG9vbHMuIFNwZWNpZnlpbmcgYSBwYXJ0aWN1bGFyIHRvb2wgdmlhXG4gICAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gICAqIGNhbGwgdGhhdCB0b29sLlxuICAgKlxuICAgKiBgbm9uZWAgaXMgdGhlIGRlZmF1bHQgd2hlbiBubyB0b29scyBhcmUgcHJlc2VudC4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IGlmIHRvb2xzXG4gICAqIGFyZSBwcmVzZW50LlxuICAgKi9cbiAgdG9vbF9jaG9pY2U/OiBDaGF0Q29tcGxldGlvblRvb2xDaG9pY2VPcHRpb247XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0b29scyB0aGUgbW9kZWwgbWF5IGNhbGwuIEN1cnJlbnRseSwgb25seSBmdW5jdGlvbnMgYXJlIHN1cHBvcnRlZCBhcyBhXG4gICAqIHRvb2wuIFVzZSB0aGlzIHRvIHByb3ZpZGUgYSBsaXN0IG9mIGZ1bmN0aW9ucyB0aGUgbW9kZWwgbWF5IGdlbmVyYXRlIEpTT04gaW5wdXRzXG4gICAqIGZvci4gQSBtYXggb2YgMTI4IGZ1bmN0aW9ucyBhcmUgc3VwcG9ydGVkLlxuICAgKi9cbiAgdG9vbHM/OiBBcnJheTxDaGF0Q29tcGxldGlvblRvb2w+O1xuXG4gIC8qKlxuICAgKiBBbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMjAgc3BlY2lmeWluZyB0aGUgbnVtYmVyIG9mIG1vc3QgbGlrZWx5IHRva2VucyB0b1xuICAgKiByZXR1cm4gYXQgZWFjaCB0b2tlbiBwb3NpdGlvbiwgZWFjaCB3aXRoIGFuIGFzc29jaWF0ZWQgbG9nIHByb2JhYmlsaXR5LlxuICAgKiBgbG9ncHJvYnNgIG11c3QgYmUgc2V0IHRvIGB0cnVlYCBpZiB0aGlzIHBhcmFtZXRlciBpcyB1c2VkLlxuICAgKi9cbiAgdG9wX2xvZ3Byb2JzPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgYHRlbXBlcmF0dXJlYCBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgcmVwcmVzZW50aW5nIHlvdXIgZW5kLXVzZXIsIHdoaWNoIGNhbiBoZWxwIE9wZW5BSSB0byBtb25pdG9yXG4gICAqIGFuZCBkZXRlY3QgYWJ1c2UuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc2FmZXR5LWJlc3QtcHJhY3RpY2VzI2VuZC11c2VyLWlkcykuXG4gICAqL1xuICB1c2VyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLiBNdXN0IGJlIGEteiwgQS1aLCAwLTksIG9yIGNvbnRhaW5cbiAgICAgKiB1bmRlcnNjb3JlcyBhbmQgZGFzaGVzLCB3aXRoIGEgbWF4aW11bSBsZW5ndGggb2YgNjQuXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQSBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoZSBmdW5jdGlvbiBkb2VzLCB1c2VkIGJ5IHRoZSBtb2RlbCB0byBjaG9vc2Ugd2hlbiBhbmRcbiAgICAgKiBob3cgdG8gY2FsbCB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGFyYW1ldGVycyB0aGUgZnVuY3Rpb25zIGFjY2VwdHMsIGRlc2NyaWJlZCBhcyBhIEpTT04gU2NoZW1hIG9iamVjdC4gU2VlIHRoZVxuICAgICAqIFtndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2Z1bmN0aW9uLWNhbGxpbmcpIGZvciBleGFtcGxlcyxcbiAgICAgKiBhbmQgdGhlXG4gICAgICogW0pTT04gU2NoZW1hIHJlZmVyZW5jZV0oaHR0cHM6Ly9qc29uLXNjaGVtYS5vcmcvdW5kZXJzdGFuZGluZy1qc29uLXNjaGVtYS8pIGZvclxuICAgICAqIGRvY3VtZW50YXRpb24gYWJvdXQgdGhlIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIE9taXR0aW5nIGBwYXJhbWV0ZXJzYCBkZWZpbmVzIGEgZnVuY3Rpb24gd2l0aCBhbiBlbXB0eSBwYXJhbWV0ZXIgbGlzdC5cbiAgICAgKi9cbiAgICBwYXJhbWV0ZXJzPzogU2hhcmVkLkZ1bmN0aW9uUGFyYW1ldGVycztcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nID1cbiAgICBDaGF0Q29tcGxldGlvbnNBUEkuQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmc7XG4gIGV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nID0gQ2hhdENvbXBsZXRpb25zQVBJLkNoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyBpbnN0ZWFkXG4gKi9cbmV4cG9ydCB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXMgPSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcztcblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBleHRlbmRzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBJZiBzZXQsIHBhcnRpYWwgbWVzc2FnZSBkZWx0YXMgd2lsbCBiZSBzZW50LCBsaWtlIGluIENoYXRHUFQuIFRva2VucyB3aWxsIGJlXG4gICAqIHNlbnQgYXMgZGF0YS1vbmx5XG4gICAqIFtzZXJ2ZXItc2VudCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2ZXItc2VudF9ldmVudHMvVXNpbmdfc2VydmVyLXNlbnRfZXZlbnRzI0V2ZW50X3N0cmVhbV9mb3JtYXQpXG4gICAqIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSwgd2l0aCB0aGUgc3RyZWFtIHRlcm1pbmF0ZWQgYnkgYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9jb29rYm9vay5vcGVuYWkuY29tL2V4YW1wbGVzL2hvd190b19zdHJlYW1fY29tcGxldGlvbnMpLlxuICAgKi9cbiAgc3RyZWFtPzogZmFsc2UgfCBudWxsO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBpbnN0ZWFkXG4gKi9cbmV4cG9ydCB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgPSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZztcblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBleHRlbmRzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBJZiBzZXQsIHBhcnRpYWwgbWVzc2FnZSBkZWx0YXMgd2lsbCBiZSBzZW50LCBsaWtlIGluIENoYXRHUFQuIFRva2VucyB3aWxsIGJlXG4gICAqIHNlbnQgYXMgZGF0YS1vbmx5XG4gICAqIFtzZXJ2ZXItc2VudCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2ZXItc2VudF9ldmVudHMvVXNpbmdfc2VydmVyLXNlbnRfZXZlbnRzI0V2ZW50X3N0cmVhbV9mb3JtYXQpXG4gICAqIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSwgd2l0aCB0aGUgc3RyZWFtIHRlcm1pbmF0ZWQgYnkgYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9jb29rYm9vay5vcGVuYWkuY29tL2V4YW1wbGVzL2hvd190b19zdHJlYW1fY29tcGxldGlvbnMpLlxuICAgKi9cbiAgc3RyZWFtOiB0cnVlO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBpbnN0ZWFkXG4gKi9cbmV4cG9ydCB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIENvbXBsZXRpb25zIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uIGFzIENoYXRDb21wbGV0aW9uLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkF1ZGlvIGFzIENoYXRDb21wbGV0aW9uQXVkaW8sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkF1ZGlvUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25BdWRpb1BhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25DaHVuayBhcyBDaGF0Q29tcGxldGlvbkNodW5rLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydCBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydEltYWdlIGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbWFnZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbnB1dEF1ZGlvIGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbnB1dEF1ZGlvLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFJlZnVzYWwgYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFJlZnVzYWwsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dCBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uRGV2ZWxvcGVyTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uRGV2ZWxvcGVyTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25GdW5jdGlvbkNhbGxPcHRpb24gYXMgQ2hhdENvbXBsZXRpb25GdW5jdGlvbkNhbGxPcHRpb24sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2UgYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCBhcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTW9kYWxpdHkgYXMgQ2hhdENvbXBsZXRpb25Nb2RhbGl0eSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlIGFzIENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25QcmVkaWN0aW9uQ29udGVudCBhcyBDaGF0Q29tcGxldGlvblByZWRpY3Rpb25Db250ZW50LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25SZWFzb25pbmdFZmZvcnQgYXMgQ2hhdENvbXBsZXRpb25SZWFzb25pbmdFZmZvcnQsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblJvbGUgYXMgQ2hhdENvbXBsZXRpb25Sb2xlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25TdHJlYW1PcHRpb25zIGFzIENoYXRDb21wbGV0aW9uU3RyZWFtT3B0aW9ucyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uU3lzdGVtTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uU3lzdGVtTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2IgYXMgQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2IsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblRvb2wgYXMgQ2hhdENvbXBsZXRpb25Ub29sLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sQ2hvaWNlT3B0aW9uIGFzIENoYXRDb21wbGV0aW9uVG9vbENob2ljZU9wdGlvbixcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvblRvb2xNZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblVzZXJNZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25Vc2VyTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ3JlYXRlQ2hhdENvbXBsZXRpb25SZXF1ZXN0TWVzc2FnZSBhcyBDcmVhdGVDaGF0Q29tcGxldGlvblJlcXVlc3RNZXNzYWdlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMgYXMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIGFzIENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBhcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGFzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICAgIHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBhcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgQ29tcGxldGlvbnNBUEkgZnJvbSAnLi9jb21wbGV0aW9ucyc7XG5pbXBvcnQge1xuICBDaGF0Q29tcGxldGlvbixcbiAgQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uQXVkaW8sXG4gIENoYXRDb21wbGV0aW9uQXVkaW9QYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25DaHVuayxcbiAgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydCxcbiAgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydEltYWdlLFxuICBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW5wdXRBdWRpbyxcbiAgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFJlZnVzYWwsXG4gIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0LFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICBDaGF0Q29tcGxldGlvbkRldmVsb3Blck1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25GdW5jdGlvbkNhbGxPcHRpb24sXG4gIENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uTWVzc2FnZSxcbiAgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsLFxuICBDaGF0Q29tcGxldGlvbk1vZGFsaXR5LFxuICBDaGF0Q29tcGxldGlvbk5hbWVkVG9vbENob2ljZSxcbiAgQ2hhdENvbXBsZXRpb25QcmVkaWN0aW9uQ29udGVudCxcbiAgQ2hhdENvbXBsZXRpb25SZWFzb25pbmdFZmZvcnQsXG4gIENoYXRDb21wbGV0aW9uUm9sZSxcbiAgQ2hhdENvbXBsZXRpb25TdHJlYW1PcHRpb25zLFxuICBDaGF0Q29tcGxldGlvblN5c3RlbU1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2IsXG4gIENoYXRDb21wbGV0aW9uVG9vbCxcbiAgQ2hhdENvbXBsZXRpb25Ub29sQ2hvaWNlT3B0aW9uLFxuICBDaGF0Q29tcGxldGlvblRvb2xNZXNzYWdlUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uVXNlck1lc3NhZ2VQYXJhbSxcbiAgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgQ29tcGxldGlvbnMsXG4gIENyZWF0ZUNoYXRDb21wbGV0aW9uUmVxdWVzdE1lc3NhZ2UsXG59IGZyb20gJy4vY29tcGxldGlvbnMnO1xuXG5leHBvcnQgY2xhc3MgQ2hhdCBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgY29tcGxldGlvbnM6IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zID0gbmV3IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zKHRoaXMuX2NsaWVudCk7XG59XG5cbmV4cG9ydCB0eXBlIENoYXRNb2RlbCA9XG4gIHwgJ28xJ1xuICB8ICdvMS0yMDI0LTEyLTE3J1xuICB8ICdvMS1wcmV2aWV3J1xuICB8ICdvMS1wcmV2aWV3LTIwMjQtMDktMTInXG4gIHwgJ28xLW1pbmknXG4gIHwgJ28xLW1pbmktMjAyNC0wOS0xMidcbiAgfCAnZ3B0LTRvJ1xuICB8ICdncHQtNG8tMjAyNC0xMS0yMCdcbiAgfCAnZ3B0LTRvLTIwMjQtMDgtMDYnXG4gIHwgJ2dwdC00by0yMDI0LTA1LTEzJ1xuICB8ICdncHQtNG8tYXVkaW8tcHJldmlldydcbiAgfCAnZ3B0LTRvLWF1ZGlvLXByZXZpZXctMjAyNC0xMC0wMSdcbiAgfCAnZ3B0LTRvLWF1ZGlvLXByZXZpZXctMjAyNC0xMi0xNydcbiAgfCAnZ3B0LTRvLW1pbmktYXVkaW8tcHJldmlldydcbiAgfCAnZ3B0LTRvLW1pbmktYXVkaW8tcHJldmlldy0yMDI0LTEyLTE3J1xuICB8ICdjaGF0Z3B0LTRvLWxhdGVzdCdcbiAgfCAnZ3B0LTRvLW1pbmknXG4gIHwgJ2dwdC00by1taW5pLTIwMjQtMDctMTgnXG4gIHwgJ2dwdC00LXR1cmJvJ1xuICB8ICdncHQtNC10dXJiby0yMDI0LTA0LTA5J1xuICB8ICdncHQtNC0wMTI1LXByZXZpZXcnXG4gIHwgJ2dwdC00LXR1cmJvLXByZXZpZXcnXG4gIHwgJ2dwdC00LTExMDYtcHJldmlldydcbiAgfCAnZ3B0LTQtdmlzaW9uLXByZXZpZXcnXG4gIHwgJ2dwdC00J1xuICB8ICdncHQtNC0wMzE0J1xuICB8ICdncHQtNC0wNjEzJ1xuICB8ICdncHQtNC0zMmsnXG4gIHwgJ2dwdC00LTMyay0wMzE0J1xuICB8ICdncHQtNC0zMmstMDYxMydcbiAgfCAnZ3B0LTMuNS10dXJibydcbiAgfCAnZ3B0LTMuNS10dXJiby0xNmsnXG4gIHwgJ2dwdC0zLjUtdHVyYm8tMDMwMSdcbiAgfCAnZ3B0LTMuNS10dXJiby0wNjEzJ1xuICB8ICdncHQtMy41LXR1cmJvLTExMDYnXG4gIHwgJ2dwdC0zLjUtdHVyYm8tMDEyNSdcbiAgfCAnZ3B0LTMuNS10dXJiby0xNmstMDYxMyc7XG5cbkNoYXQuQ29tcGxldGlvbnMgPSBDb21wbGV0aW9ucztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIENoYXQge1xuICBleHBvcnQgeyB0eXBlIENoYXRNb2RlbCBhcyBDaGF0TW9kZWwgfTtcblxuICBleHBvcnQge1xuICAgIENvbXBsZXRpb25zIGFzIENvbXBsZXRpb25zLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb24gYXMgQ2hhdENvbXBsZXRpb24sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQXVkaW8gYXMgQ2hhdENvbXBsZXRpb25BdWRpbyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQXVkaW9QYXJhbSBhcyBDaGF0Q29tcGxldGlvbkF1ZGlvUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNodW5rIGFzIENoYXRDb21wbGV0aW9uQ2h1bmssXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0IGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnQsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2UgYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydEltYWdlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydElucHV0QXVkaW8gYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydElucHV0QXVkaW8sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0UmVmdXNhbCBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0UmVmdXNhbCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0IGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25EZXZlbG9wZXJNZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25EZXZlbG9wZXJNZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uQ2FsbE9wdGlvbiBhcyBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uQ2FsbE9wdGlvbixcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25GdW5jdGlvbk1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZSBhcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2UsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsIGFzIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Nb2RhbGl0eSBhcyBDaGF0Q29tcGxldGlvbk1vZGFsaXR5LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25OYW1lZFRvb2xDaG9pY2UgYXMgQ2hhdENvbXBsZXRpb25OYW1lZFRvb2xDaG9pY2UsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblByZWRpY3Rpb25Db250ZW50IGFzIENoYXRDb21wbGV0aW9uUHJlZGljdGlvbkNvbnRlbnQsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblJlYXNvbmluZ0VmZm9ydCBhcyBDaGF0Q29tcGxldGlvblJlYXNvbmluZ0VmZm9ydCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uUm9sZSBhcyBDaGF0Q29tcGxldGlvblJvbGUsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblN0cmVhbU9wdGlvbnMgYXMgQ2hhdENvbXBsZXRpb25TdHJlYW1PcHRpb25zLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25TeXN0ZW1NZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25TeXN0ZW1NZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYiBhcyBDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYixcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVG9vbCBhcyBDaGF0Q29tcGxldGlvblRvb2wsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblRvb2xDaG9pY2VPcHRpb24gYXMgQ2hhdENvbXBsZXRpb25Ub29sQ2hvaWNlT3B0aW9uLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVXNlck1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvblVzZXJNZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDcmVhdGVDaGF0Q29tcGxldGlvblJlcXVlc3RNZXNzYWdlIGFzIENyZWF0ZUNoYXRDb21wbGV0aW9uUmVxdWVzdE1lc3NhZ2UsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyBhcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXMgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGFzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBhcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgYXMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gICAgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGFzIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uL2NvcmUnO1xuaW1wb3J0IHsgdHlwZSBSZXNwb25zZSB9IGZyb20gJy4uLy4uL19zaGltcy9pbmRleCc7XG5cbmV4cG9ydCBjbGFzcyBTcGVlY2ggZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYXVkaW8gZnJvbSB0aGUgaW5wdXQgdGV4dC5cbiAgICovXG4gIGNyZWF0ZShib2R5OiBTcGVlY2hDcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvYXVkaW8vc3BlZWNoJywge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgIF9fYmluYXJ5UmVzcG9uc2U6IHRydWUsXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgU3BlZWNoTW9kZWwgPSAndHRzLTEnIHwgJ3R0cy0xLWhkJztcblxuZXhwb3J0IGludGVyZmFjZSBTcGVlY2hDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIHRleHQgdG8gZ2VuZXJhdGUgYXVkaW8gZm9yLiBUaGUgbWF4aW11bSBsZW5ndGggaXMgNDA5NiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgaW5wdXQ6IHN0cmluZztcblxuICAvKipcbiAgICogT25lIG9mIHRoZSBhdmFpbGFibGUgW1RUUyBtb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyN0dHMpOlxuICAgKiBgdHRzLTFgIG9yIGB0dHMtMS1oZGBcbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgU3BlZWNoTW9kZWw7XG5cbiAgLyoqXG4gICAqIFRoZSB2b2ljZSB0byB1c2Ugd2hlbiBnZW5lcmF0aW5nIHRoZSBhdWRpby4gU3VwcG9ydGVkIHZvaWNlcyBhcmUgYGFsbG95YCxcbiAgICogYGVjaG9gLCBgZmFibGVgLCBgb255eGAsIGBub3ZhYCwgYW5kIGBzaGltbWVyYC4gUHJldmlld3Mgb2YgdGhlIHZvaWNlcyBhcmVcbiAgICogYXZhaWxhYmxlIGluIHRoZVxuICAgKiBbVGV4dCB0byBzcGVlY2ggZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy90ZXh0LXRvLXNwZWVjaCN2b2ljZS1vcHRpb25zKS5cbiAgICovXG4gIHZvaWNlOiAnYWxsb3knIHwgJ2VjaG8nIHwgJ2ZhYmxlJyB8ICdvbnl4JyB8ICdub3ZhJyB8ICdzaGltbWVyJztcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCB0byBhdWRpbyBpbi4gU3VwcG9ydGVkIGZvcm1hdHMgYXJlIGBtcDNgLCBgb3B1c2AsIGBhYWNgLCBgZmxhY2AsXG4gICAqIGB3YXZgLCBhbmQgYHBjbWAuXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiAnbXAzJyB8ICdvcHVzJyB8ICdhYWMnIHwgJ2ZsYWMnIHwgJ3dhdicgfCAncGNtJztcblxuICAvKipcbiAgICogVGhlIHNwZWVkIG9mIHRoZSBnZW5lcmF0ZWQgYXVkaW8uIFNlbGVjdCBhIHZhbHVlIGZyb20gYDAuMjVgIHRvIGA0LjBgLiBgMS4wYCBpc1xuICAgKiB0aGUgZGVmYXVsdC5cbiAgICovXG4gIHNwZWVkPzogbnVtYmVyO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgU3BlZWNoIHtcbiAgZXhwb3J0IHsgdHlwZSBTcGVlY2hNb2RlbCBhcyBTcGVlY2hNb2RlbCwgdHlwZSBTcGVlY2hDcmVhdGVQYXJhbXMgYXMgU3BlZWNoQ3JlYXRlUGFyYW1zIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQXVkaW9BUEkgZnJvbSAnLi9hdWRpbyc7XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2NyaXB0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFRyYW5zY3JpYmVzIGF1ZGlvIGludG8gdGhlIGlucHV0IGxhbmd1YWdlLlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIGJvZHk6IFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXM8J2pzb24nIHwgdW5kZWZpbmVkPixcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFRyYW5zY3JpcHRpb24+O1xuICBjcmVhdGUoXG4gICAgYm9keTogVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtczwndmVyYm9zZV9qc29uJz4sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxUcmFuc2NyaXB0aW9uVmVyYm9zZT47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zPCdzcnQnIHwgJ3Z0dCcgfCAndGV4dCc+LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8c3RyaW5nPjtcbiAgY3JlYXRlKGJvZHk6IFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFRyYW5zY3JpcHRpb24+O1xuICBjcmVhdGUoXG4gICAgYm9keTogVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFRyYW5zY3JpcHRpb25DcmVhdGVSZXNwb25zZSB8IHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2F1ZGlvL3RyYW5zY3JpcHRpb25zJywgQ29yZS5tdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0cmFuc2NyaXB0aW9uIHJlc3BvbnNlIHJldHVybmVkIGJ5IG1vZGVsLCBiYXNlZCBvbiB0aGUgcHJvdmlkZWRcbiAqIGlucHV0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zY3JpcHRpb24ge1xuICAvKipcbiAgICogVGhlIHRyYW5zY3JpYmVkIHRleHQuXG4gICAqL1xuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNjcmlwdGlvblNlZ21lbnQge1xuICAvKipcbiAgICogVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHNlZ21lbnQuXG4gICAqL1xuICBpZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBdmVyYWdlIGxvZ3Byb2Igb2YgdGhlIHNlZ21lbnQuIElmIHRoZSB2YWx1ZSBpcyBsb3dlciB0aGFuIC0xLCBjb25zaWRlciB0aGVcbiAgICogbG9ncHJvYnMgZmFpbGVkLlxuICAgKi9cbiAgYXZnX2xvZ3Byb2I6IG51bWJlcjtcblxuICAvKipcbiAgICogQ29tcHJlc3Npb24gcmF0aW8gb2YgdGhlIHNlZ21lbnQuIElmIHRoZSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gMi40LCBjb25zaWRlciB0aGVcbiAgICogY29tcHJlc3Npb24gZmFpbGVkLlxuICAgKi9cbiAgY29tcHJlc3Npb25fcmF0aW86IG51bWJlcjtcblxuICAvKipcbiAgICogRW5kIHRpbWUgb2YgdGhlIHNlZ21lbnQgaW4gc2Vjb25kcy5cbiAgICovXG4gIGVuZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBQcm9iYWJpbGl0eSBvZiBubyBzcGVlY2ggaW4gdGhlIHNlZ21lbnQuIElmIHRoZSB2YWx1ZSBpcyBoaWdoZXIgdGhhbiAxLjAgYW5kIHRoZVxuICAgKiBgYXZnX2xvZ3Byb2JgIGlzIGJlbG93IC0xLCBjb25zaWRlciB0aGlzIHNlZ21lbnQgc2lsZW50LlxuICAgKi9cbiAgbm9fc3BlZWNoX3Byb2I6IG51bWJlcjtcblxuICAvKipcbiAgICogU2VlayBvZmZzZXQgb2YgdGhlIHNlZ21lbnQuXG4gICAqL1xuICBzZWVrOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRpbWUgb2YgdGhlIHNlZ21lbnQgaW4gc2Vjb25kcy5cbiAgICovXG4gIHN0YXJ0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRlbXBlcmF0dXJlIHBhcmFtZXRlciB1c2VkIGZvciBnZW5lcmF0aW5nIHRoZSBzZWdtZW50LlxuICAgKi9cbiAgdGVtcGVyYXR1cmU6IG51bWJlcjtcblxuICAvKipcbiAgICogVGV4dCBjb250ZW50IG9mIHRoZSBzZWdtZW50LlxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBcnJheSBvZiB0b2tlbiBJRHMgZm9yIHRoZSB0ZXh0IGNvbnRlbnQuXG4gICAqL1xuICB0b2tlbnM6IEFycmF5PG51bWJlcj47XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHZlcmJvc2UganNvbiB0cmFuc2NyaXB0aW9uIHJlc3BvbnNlIHJldHVybmVkIGJ5IG1vZGVsLCBiYXNlZCBvbiB0aGVcbiAqIHByb3ZpZGVkIGlucHV0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zY3JpcHRpb25WZXJib3NlIHtcbiAgLyoqXG4gICAqIFRoZSBkdXJhdGlvbiBvZiB0aGUgaW5wdXQgYXVkaW8uXG4gICAqL1xuICBkdXJhdGlvbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbGFuZ3VhZ2Ugb2YgdGhlIGlucHV0IGF1ZGlvLlxuICAgKi9cbiAgbGFuZ3VhZ2U6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHRyYW5zY3JpYmVkIHRleHQuXG4gICAqL1xuICB0ZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNlZ21lbnRzIG9mIHRoZSB0cmFuc2NyaWJlZCB0ZXh0IGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIGRldGFpbHMuXG4gICAqL1xuICBzZWdtZW50cz86IEFycmF5PFRyYW5zY3JpcHRpb25TZWdtZW50PjtcblxuICAvKipcbiAgICogRXh0cmFjdGVkIHdvcmRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHRpbWVzdGFtcHMuXG4gICAqL1xuICB3b3Jkcz86IEFycmF5PFRyYW5zY3JpcHRpb25Xb3JkPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2NyaXB0aW9uV29yZCB7XG4gIC8qKlxuICAgKiBFbmQgdGltZSBvZiB0aGUgd29yZCBpbiBzZWNvbmRzLlxuICAgKi9cbiAgZW5kOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRpbWUgb2YgdGhlIHdvcmQgaW4gc2Vjb25kcy5cbiAgICovXG4gIHN0YXJ0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIHdvcmQuXG4gICAqL1xuICB3b3JkOiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRyYW5zY3JpcHRpb24gcmVzcG9uc2UgcmV0dXJuZWQgYnkgbW9kZWwsIGJhc2VkIG9uIHRoZSBwcm92aWRlZFxuICogaW5wdXQuXG4gKi9cbmV4cG9ydCB0eXBlIFRyYW5zY3JpcHRpb25DcmVhdGVSZXNwb25zZSA9IFRyYW5zY3JpcHRpb24gfCBUcmFuc2NyaXB0aW9uVmVyYm9zZTtcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zPFxuICBSZXNwb25zZUZvcm1hdCBleHRlbmRzIEF1ZGlvQVBJLkF1ZGlvUmVzcG9uc2VGb3JtYXQgfCB1bmRlZmluZWQgPSBBdWRpb0FQSS5BdWRpb1Jlc3BvbnNlRm9ybWF0IHwgdW5kZWZpbmVkLFxuPiB7XG4gIC8qKlxuICAgKiBUaGUgYXVkaW8gZmlsZSBvYmplY3QgKG5vdCBmaWxlIG5hbWUpIHRvIHRyYW5zY3JpYmUsIGluIG9uZSBvZiB0aGVzZSBmb3JtYXRzOlxuICAgKiBmbGFjLCBtcDMsIG1wNCwgbXBlZywgbXBnYSwgbTRhLCBvZ2csIHdhdiwgb3Igd2VibS5cbiAgICovXG4gIGZpbGU6IENvcmUuVXBsb2FkYWJsZTtcblxuICAvKipcbiAgICogSUQgb2YgdGhlIG1vZGVsIHRvIHVzZS4gT25seSBgd2hpc3Blci0xYCAod2hpY2ggaXMgcG93ZXJlZCBieSBvdXIgb3BlbiBzb3VyY2VcbiAgICogV2hpc3BlciBWMiBtb2RlbCkgaXMgY3VycmVudGx5IGF2YWlsYWJsZS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgQXVkaW9BUEkuQXVkaW9Nb2RlbDtcblxuICAvKipcbiAgICogVGhlIGxhbmd1YWdlIG9mIHRoZSBpbnB1dCBhdWRpby4gU3VwcGx5aW5nIHRoZSBpbnB1dCBsYW5ndWFnZSBpblxuICAgKiBbSVNPLTYzOS0xXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX0lTT182MzktMV9jb2RlcykgZm9ybWF0IHdpbGxcbiAgICogaW1wcm92ZSBhY2N1cmFjeSBhbmQgbGF0ZW5jeS5cbiAgICovXG4gIGxhbmd1YWdlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCB0ZXh0IHRvIGd1aWRlIHRoZSBtb2RlbCdzIHN0eWxlIG9yIGNvbnRpbnVlIGEgcHJldmlvdXMgYXVkaW9cbiAgICogc2VnbWVudC4gVGhlXG4gICAqIFtwcm9tcHRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zcGVlY2gtdG8tdGV4dCNwcm9tcHRpbmcpXG4gICAqIHNob3VsZCBtYXRjaCB0aGUgYXVkaW8gbGFuZ3VhZ2UuXG4gICAqL1xuICBwcm9tcHQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCwgaW4gb25lIG9mIHRoZXNlIG9wdGlvbnM6IGBqc29uYCwgYHRleHRgLCBgc3J0YCxcbiAgICogYHZlcmJvc2VfanNvbmAsIG9yIGB2dHRgLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogUmVzcG9uc2VGb3JtYXQ7XG5cbiAgLyoqXG4gICAqIFRoZSBzYW1wbGluZyB0ZW1wZXJhdHVyZSwgYmV0d2VlbiAwIGFuZCAxLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGwgbWFrZSB0aGVcbiAgICogb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmUgZm9jdXNlZCBhbmRcbiAgICogZGV0ZXJtaW5pc3RpYy4gSWYgc2V0IHRvIDAsIHRoZSBtb2RlbCB3aWxsIHVzZVxuICAgKiBbbG9nIHByb2JhYmlsaXR5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Mb2dfcHJvYmFiaWxpdHkpIHRvXG4gICAqIGF1dG9tYXRpY2FsbHkgaW5jcmVhc2UgdGhlIHRlbXBlcmF0dXJlIHVudGlsIGNlcnRhaW4gdGhyZXNob2xkcyBhcmUgaGl0LlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lc3RhbXAgZ3JhbnVsYXJpdGllcyB0byBwb3B1bGF0ZSBmb3IgdGhpcyB0cmFuc2NyaXB0aW9uLlxuICAgKiBgcmVzcG9uc2VfZm9ybWF0YCBtdXN0IGJlIHNldCBgdmVyYm9zZV9qc29uYCB0byB1c2UgdGltZXN0YW1wIGdyYW51bGFyaXRpZXMuXG4gICAqIEVpdGhlciBvciBib3RoIG9mIHRoZXNlIG9wdGlvbnMgYXJlIHN1cHBvcnRlZDogYHdvcmRgLCBvciBgc2VnbWVudGAuIE5vdGU6IFRoZXJlXG4gICAqIGlzIG5vIGFkZGl0aW9uYWwgbGF0ZW5jeSBmb3Igc2VnbWVudCB0aW1lc3RhbXBzLCBidXQgZ2VuZXJhdGluZyB3b3JkIHRpbWVzdGFtcHNcbiAgICogaW5jdXJzIGFkZGl0aW9uYWwgbGF0ZW5jeS5cbiAgICovXG4gIHRpbWVzdGFtcF9ncmFudWxhcml0aWVzPzogQXJyYXk8J3dvcmQnIHwgJ3NlZ21lbnQnPjtcbn1cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFRyYW5zY3JpcHRpb25zIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIFRyYW5zY3JpcHRpb24gYXMgVHJhbnNjcmlwdGlvbixcbiAgICB0eXBlIFRyYW5zY3JpcHRpb25TZWdtZW50IGFzIFRyYW5zY3JpcHRpb25TZWdtZW50LFxuICAgIHR5cGUgVHJhbnNjcmlwdGlvblZlcmJvc2UgYXMgVHJhbnNjcmlwdGlvblZlcmJvc2UsXG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uV29yZCBhcyBUcmFuc2NyaXB0aW9uV29yZCxcbiAgICB0eXBlIFRyYW5zY3JpcHRpb25DcmVhdGVSZXNwb25zZSBhcyBUcmFuc2NyaXB0aW9uQ3JlYXRlUmVzcG9uc2UsXG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zIGFzIFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQXVkaW9BUEkgZnJvbSAnLi9hdWRpbyc7XG5pbXBvcnQgKiBhcyBUcmFuc2NyaXB0aW9uc0FQSSBmcm9tICcuL3RyYW5zY3JpcHRpb25zJztcblxuZXhwb3J0IGNsYXNzIFRyYW5zbGF0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFRyYW5zbGF0ZXMgYXVkaW8gaW50byBFbmdsaXNoLlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIGJvZHk6IFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zPCdqc29uJyB8IHVuZGVmaW5lZD4sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxUcmFuc2xhdGlvbj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtczwndmVyYm9zZV9qc29uJz4sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxUcmFuc2xhdGlvblZlcmJvc2U+O1xuICBjcmVhdGUoXG4gICAgYm9keTogVHJhbnNsYXRpb25DcmVhdGVQYXJhbXM8J3RleHQnIHwgJ3NydCcgfCAndnR0Jz4sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxzdHJpbmc+O1xuICBjcmVhdGUoYm9keTogVHJhbnNsYXRpb25DcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFRyYW5zbGF0aW9uPjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VHJhbnNsYXRpb25DcmVhdGVSZXNwb25zZSB8IHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2F1ZGlvL3RyYW5zbGF0aW9ucycsIENvcmUubXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zKHsgYm9keSwgLi4ub3B0aW9ucyB9KSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xhdGlvbiB7XG4gIHRleHQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xhdGlvblZlcmJvc2Uge1xuICAvKipcbiAgICogVGhlIGR1cmF0aW9uIG9mIHRoZSBpbnB1dCBhdWRpby5cbiAgICovXG4gIGR1cmF0aW9uOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBsYW5ndWFnZSBvZiB0aGUgb3V0cHV0IHRyYW5zbGF0aW9uIChhbHdheXMgYGVuZ2xpc2hgKS5cbiAgICovXG4gIGxhbmd1YWdlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0cmFuc2xhdGVkIHRleHQuXG4gICAqL1xuICB0ZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNlZ21lbnRzIG9mIHRoZSB0cmFuc2xhdGVkIHRleHQgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgZGV0YWlscy5cbiAgICovXG4gIHNlZ21lbnRzPzogQXJyYXk8VHJhbnNjcmlwdGlvbnNBUEkuVHJhbnNjcmlwdGlvblNlZ21lbnQ+O1xufVxuXG5leHBvcnQgdHlwZSBUcmFuc2xhdGlvbkNyZWF0ZVJlc3BvbnNlID0gVHJhbnNsYXRpb24gfCBUcmFuc2xhdGlvblZlcmJvc2U7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNsYXRpb25DcmVhdGVQYXJhbXM8XG4gIFJlc3BvbnNlRm9ybWF0IGV4dGVuZHMgQXVkaW9BUEkuQXVkaW9SZXNwb25zZUZvcm1hdCB8IHVuZGVmaW5lZCA9IEF1ZGlvQVBJLkF1ZGlvUmVzcG9uc2VGb3JtYXQgfCB1bmRlZmluZWQsXG4+IHtcbiAgLyoqXG4gICAqIFRoZSBhdWRpbyBmaWxlIG9iamVjdCAobm90IGZpbGUgbmFtZSkgdHJhbnNsYXRlLCBpbiBvbmUgb2YgdGhlc2UgZm9ybWF0czogZmxhYyxcbiAgICogbXAzLCBtcDQsIG1wZWcsIG1wZ2EsIG00YSwgb2dnLCB3YXYsIG9yIHdlYm0uXG4gICAqL1xuICBmaWxlOiBDb3JlLlVwbG9hZGFibGU7XG5cbiAgLyoqXG4gICAqIElEIG9mIHRoZSBtb2RlbCB0byB1c2UuIE9ubHkgYHdoaXNwZXItMWAgKHdoaWNoIGlzIHBvd2VyZWQgYnkgb3VyIG9wZW4gc291cmNlXG4gICAqIFdoaXNwZXIgVjIgbW9kZWwpIGlzIGN1cnJlbnRseSBhdmFpbGFibGUuXG4gICAqL1xuICBtb2RlbDogKHN0cmluZyAmIHt9KSB8IEF1ZGlvQVBJLkF1ZGlvTW9kZWw7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIHRleHQgdG8gZ3VpZGUgdGhlIG1vZGVsJ3Mgc3R5bGUgb3IgY29udGludWUgYSBwcmV2aW91cyBhdWRpb1xuICAgKiBzZWdtZW50LiBUaGVcbiAgICogW3Byb21wdF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3NwZWVjaC10by10ZXh0I3Byb21wdGluZylcbiAgICogc2hvdWxkIGJlIGluIEVuZ2xpc2guXG4gICAqL1xuICBwcm9tcHQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCwgaW4gb25lIG9mIHRoZXNlIG9wdGlvbnM6IGBqc29uYCwgYHRleHRgLCBgc3J0YCxcbiAgICogYHZlcmJvc2VfanNvbmAsIG9yIGB2dHRgLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogUmVzcG9uc2VGb3JtYXQ7XG5cbiAgLyoqXG4gICAqIFRoZSBzYW1wbGluZyB0ZW1wZXJhdHVyZSwgYmV0d2VlbiAwIGFuZCAxLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGwgbWFrZSB0aGVcbiAgICogb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmUgZm9jdXNlZCBhbmRcbiAgICogZGV0ZXJtaW5pc3RpYy4gSWYgc2V0IHRvIDAsIHRoZSBtb2RlbCB3aWxsIHVzZVxuICAgKiBbbG9nIHByb2JhYmlsaXR5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Mb2dfcHJvYmFiaWxpdHkpIHRvXG4gICAqIGF1dG9tYXRpY2FsbHkgaW5jcmVhc2UgdGhlIHRlbXBlcmF0dXJlIHVudGlsIGNlcnRhaW4gdGhyZXNob2xkcyBhcmUgaGl0LlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBUcmFuc2xhdGlvbnMge1xuICBleHBvcnQge1xuICAgIHR5cGUgVHJhbnNsYXRpb24gYXMgVHJhbnNsYXRpb24sXG4gICAgdHlwZSBUcmFuc2xhdGlvblZlcmJvc2UgYXMgVHJhbnNsYXRpb25WZXJib3NlLFxuICAgIHR5cGUgVHJhbnNsYXRpb25DcmVhdGVSZXNwb25zZSBhcyBUcmFuc2xhdGlvbkNyZWF0ZVJlc3BvbnNlLFxuICAgIHR5cGUgVHJhbnNsYXRpb25DcmVhdGVQYXJhbXMgYXMgVHJhbnNsYXRpb25DcmVhdGVQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBTcGVlY2hBUEkgZnJvbSAnLi9zcGVlY2gnO1xuaW1wb3J0IHsgU3BlZWNoLCBTcGVlY2hDcmVhdGVQYXJhbXMsIFNwZWVjaE1vZGVsIH0gZnJvbSAnLi9zcGVlY2gnO1xuaW1wb3J0ICogYXMgVHJhbnNjcmlwdGlvbnNBUEkgZnJvbSAnLi90cmFuc2NyaXB0aW9ucyc7XG5pbXBvcnQge1xuICBUcmFuc2NyaXB0aW9uLFxuICBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zLFxuICBUcmFuc2NyaXB0aW9uQ3JlYXRlUmVzcG9uc2UsXG4gIFRyYW5zY3JpcHRpb25TZWdtZW50LFxuICBUcmFuc2NyaXB0aW9uVmVyYm9zZSxcbiAgVHJhbnNjcmlwdGlvbldvcmQsXG4gIFRyYW5zY3JpcHRpb25zLFxufSBmcm9tICcuL3RyYW5zY3JpcHRpb25zJztcbmltcG9ydCAqIGFzIFRyYW5zbGF0aW9uc0FQSSBmcm9tICcuL3RyYW5zbGF0aW9ucyc7XG5pbXBvcnQge1xuICBUcmFuc2xhdGlvbixcbiAgVHJhbnNsYXRpb25DcmVhdGVQYXJhbXMsXG4gIFRyYW5zbGF0aW9uQ3JlYXRlUmVzcG9uc2UsXG4gIFRyYW5zbGF0aW9uVmVyYm9zZSxcbiAgVHJhbnNsYXRpb25zLFxufSBmcm9tICcuL3RyYW5zbGF0aW9ucyc7XG5cbmV4cG9ydCBjbGFzcyBBdWRpbyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgdHJhbnNjcmlwdGlvbnM6IFRyYW5zY3JpcHRpb25zQVBJLlRyYW5zY3JpcHRpb25zID0gbmV3IFRyYW5zY3JpcHRpb25zQVBJLlRyYW5zY3JpcHRpb25zKHRoaXMuX2NsaWVudCk7XG4gIHRyYW5zbGF0aW9uczogVHJhbnNsYXRpb25zQVBJLlRyYW5zbGF0aW9ucyA9IG5ldyBUcmFuc2xhdGlvbnNBUEkuVHJhbnNsYXRpb25zKHRoaXMuX2NsaWVudCk7XG4gIHNwZWVjaDogU3BlZWNoQVBJLlNwZWVjaCA9IG5ldyBTcGVlY2hBUEkuU3BlZWNoKHRoaXMuX2NsaWVudCk7XG59XG5cbmV4cG9ydCB0eXBlIEF1ZGlvTW9kZWwgPSAnd2hpc3Blci0xJztcblxuLyoqXG4gKiBUaGUgZm9ybWF0IG9mIHRoZSBvdXRwdXQsIGluIG9uZSBvZiB0aGVzZSBvcHRpb25zOiBganNvbmAsIGB0ZXh0YCwgYHNydGAsXG4gKiBgdmVyYm9zZV9qc29uYCwgb3IgYHZ0dGAuXG4gKi9cbmV4cG9ydCB0eXBlIEF1ZGlvUmVzcG9uc2VGb3JtYXQgPSAnanNvbicgfCAndGV4dCcgfCAnc3J0JyB8ICd2ZXJib3NlX2pzb24nIHwgJ3Z0dCc7XG5cbkF1ZGlvLlRyYW5zY3JpcHRpb25zID0gVHJhbnNjcmlwdGlvbnM7XG5BdWRpby5UcmFuc2xhdGlvbnMgPSBUcmFuc2xhdGlvbnM7XG5BdWRpby5TcGVlY2ggPSBTcGVlY2g7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBBdWRpbyB7XG4gIGV4cG9ydCB7IHR5cGUgQXVkaW9Nb2RlbCBhcyBBdWRpb01vZGVsLCB0eXBlIEF1ZGlvUmVzcG9uc2VGb3JtYXQgYXMgQXVkaW9SZXNwb25zZUZvcm1hdCB9O1xuXG4gIGV4cG9ydCB7XG4gICAgVHJhbnNjcmlwdGlvbnMgYXMgVHJhbnNjcmlwdGlvbnMsXG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uIGFzIFRyYW5zY3JpcHRpb24sXG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uU2VnbWVudCBhcyBUcmFuc2NyaXB0aW9uU2VnbWVudCxcbiAgICB0eXBlIFRyYW5zY3JpcHRpb25WZXJib3NlIGFzIFRyYW5zY3JpcHRpb25WZXJib3NlLFxuICAgIHR5cGUgVHJhbnNjcmlwdGlvbldvcmQgYXMgVHJhbnNjcmlwdGlvbldvcmQsXG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uQ3JlYXRlUmVzcG9uc2UgYXMgVHJhbnNjcmlwdGlvbkNyZWF0ZVJlc3BvbnNlLFxuICAgIHR5cGUgVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtcyBhcyBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgVHJhbnNsYXRpb25zIGFzIFRyYW5zbGF0aW9ucyxcbiAgICB0eXBlIFRyYW5zbGF0aW9uIGFzIFRyYW5zbGF0aW9uLFxuICAgIHR5cGUgVHJhbnNsYXRpb25WZXJib3NlIGFzIFRyYW5zbGF0aW9uVmVyYm9zZSxcbiAgICB0eXBlIFRyYW5zbGF0aW9uQ3JlYXRlUmVzcG9uc2UgYXMgVHJhbnNsYXRpb25DcmVhdGVSZXNwb25zZSxcbiAgICB0eXBlIFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zIGFzIFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7IFNwZWVjaCBhcyBTcGVlY2gsIHR5cGUgU3BlZWNoTW9kZWwgYXMgU3BlZWNoTW9kZWwsIHR5cGUgU3BlZWNoQ3JlYXRlUGFyYW1zIGFzIFNwZWVjaENyZWF0ZVBhcmFtcyB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCAqIGFzIEJhdGNoZXNBUEkgZnJvbSAnLi9iYXRjaGVzJztcbmltcG9ydCB7IEN1cnNvclBhZ2UsIHR5cGUgQ3Vyc29yUGFnZVBhcmFtcyB9IGZyb20gJy4uL3BhZ2luYXRpb24nO1xuXG5leHBvcnQgY2xhc3MgQmF0Y2hlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGV4ZWN1dGVzIGEgYmF0Y2ggZnJvbSBhbiB1cGxvYWRlZCBmaWxlIG9mIHJlcXVlc3RzXG4gICAqL1xuICBjcmVhdGUoYm9keTogQmF0Y2hDcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEJhdGNoPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvYmF0Y2hlcycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBiYXRjaC5cbiAgICovXG4gIHJldHJpZXZlKGJhdGNoSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8QmF0Y2g+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL2JhdGNoZXMvJHtiYXRjaElkfWAsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgeW91ciBvcmdhbml6YXRpb24ncyBiYXRjaGVzLlxuICAgKi9cbiAgbGlzdChxdWVyeT86IEJhdGNoTGlzdFBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPEJhdGNoZXNQYWdlLCBCYXRjaD47XG4gIGxpc3Qob3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPEJhdGNoZXNQYWdlLCBCYXRjaD47XG4gIGxpc3QoXG4gICAgcXVlcnk6IEJhdGNoTGlzdFBhcmFtcyB8IENvcmUuUmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxCYXRjaGVzUGFnZSwgQmF0Y2g+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3Qoe30sIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KCcvYmF0Y2hlcycsIEJhdGNoZXNQYWdlLCB7IHF1ZXJ5LCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYW4gaW4tcHJvZ3Jlc3MgYmF0Y2guIFRoZSBiYXRjaCB3aWxsIGJlIGluIHN0YXR1cyBgY2FuY2VsbGluZ2AgZm9yIHVwIHRvXG4gICAqIDEwIG1pbnV0ZXMsIGJlZm9yZSBjaGFuZ2luZyB0byBgY2FuY2VsbGVkYCwgd2hlcmUgaXQgd2lsbCBoYXZlIHBhcnRpYWwgcmVzdWx0c1xuICAgKiAoaWYgYW55KSBhdmFpbGFibGUgaW4gdGhlIG91dHB1dCBmaWxlLlxuICAgKi9cbiAgY2FuY2VsKGJhdGNoSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8QmF0Y2g+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC9iYXRjaGVzLyR7YmF0Y2hJZH0vY2FuY2VsYCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJhdGNoZXNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxCYXRjaD4ge31cblxuZXhwb3J0IGludGVyZmFjZSBCYXRjaCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIGZyYW1lIHdpdGhpbiB3aGljaCB0aGUgYmF0Y2ggc2hvdWxkIGJlIHByb2Nlc3NlZC5cbiAgICovXG4gIGNvbXBsZXRpb25fd2luZG93OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGJhdGNoIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgT3BlbkFJIEFQSSBlbmRwb2ludCB1c2VkIGJ5IHRoZSBiYXRjaC5cbiAgICovXG4gIGVuZHBvaW50OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgaW5wdXQgZmlsZSBmb3IgdGhlIGJhdGNoLlxuICAgKi9cbiAgaW5wdXRfZmlsZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgYmF0Y2hgLlxuICAgKi9cbiAgb2JqZWN0OiAnYmF0Y2gnO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIGJhdGNoLlxuICAgKi9cbiAgc3RhdHVzOlxuICAgIHwgJ3ZhbGlkYXRpbmcnXG4gICAgfCAnZmFpbGVkJ1xuICAgIHwgJ2luX3Byb2dyZXNzJ1xuICAgIHwgJ2ZpbmFsaXppbmcnXG4gICAgfCAnY29tcGxldGVkJ1xuICAgIHwgJ2V4cGlyZWQnXG4gICAgfCAnY2FuY2VsbGluZydcbiAgICB8ICdjYW5jZWxsZWQnO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBiYXRjaCB3YXMgY2FuY2VsbGVkLlxuICAgKi9cbiAgY2FuY2VsbGVkX2F0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBiYXRjaCBzdGFydGVkIGNhbmNlbGxpbmcuXG4gICAqL1xuICBjYW5jZWxsaW5nX2F0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBiYXRjaCB3YXMgY29tcGxldGVkLlxuICAgKi9cbiAgY29tcGxldGVkX2F0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgY29udGFpbmluZyB0aGUgb3V0cHV0cyBvZiByZXF1ZXN0cyB3aXRoIGVycm9ycy5cbiAgICovXG4gIGVycm9yX2ZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgZXJyb3JzPzogQmF0Y2guRXJyb3JzO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBiYXRjaCBleHBpcmVkLlxuICAgKi9cbiAgZXhwaXJlZF9hdD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgYmF0Y2ggd2lsbCBleHBpcmUuXG4gICAqL1xuICBleHBpcmVzX2F0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBiYXRjaCBmYWlsZWQuXG4gICAqL1xuICBmYWlsZWRfYXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGJhdGNoIHN0YXJ0ZWQgZmluYWxpemluZy5cbiAgICovXG4gIGZpbmFsaXppbmdfYXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGJhdGNoIHN0YXJ0ZWQgcHJvY2Vzc2luZy5cbiAgICovXG4gIGluX3Byb2dyZXNzX2F0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgY29udGFpbmluZyB0aGUgb3V0cHV0cyBvZiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQgcmVxdWVzdHMuXG4gICAqL1xuICBvdXRwdXRfZmlsZV9pZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJlcXVlc3QgY291bnRzIGZvciBkaWZmZXJlbnQgc3RhdHVzZXMgd2l0aGluIHRoZSBiYXRjaC5cbiAgICovXG4gIHJlcXVlc3RfY291bnRzPzogQmF0Y2hSZXF1ZXN0Q291bnRzO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEJhdGNoIHtcbiAgZXhwb3J0IGludGVyZmFjZSBFcnJvcnMge1xuICAgIGRhdGE/OiBBcnJheTxCYXRjaGVzQVBJLkJhdGNoRXJyb3I+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYGxpc3RgLlxuICAgICAqL1xuICAgIG9iamVjdD86IHN0cmluZztcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhdGNoRXJyb3Ige1xuICAvKipcbiAgICogQW4gZXJyb3IgY29kZSBpZGVudGlmeWluZyB0aGUgZXJyb3IgdHlwZS5cbiAgICovXG4gIGNvZGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBsaW5lIG51bWJlciBvZiB0aGUgaW5wdXQgZmlsZSB3aGVyZSB0aGUgZXJyb3Igb2NjdXJyZWQsIGlmIGFwcGxpY2FibGUuXG4gICAqL1xuICBsaW5lPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBodW1hbi1yZWFkYWJsZSBtZXNzYWdlIHByb3ZpZGluZyBtb3JlIGRldGFpbHMgYWJvdXQgdGhlIGVycm9yLlxuICAgKi9cbiAgbWVzc2FnZT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciB0aGF0IGNhdXNlZCB0aGUgZXJyb3IsIGlmIGFwcGxpY2FibGUuXG4gICAqL1xuICBwYXJhbT86IHN0cmluZyB8IG51bGw7XG59XG5cbi8qKlxuICogVGhlIHJlcXVlc3QgY291bnRzIGZvciBkaWZmZXJlbnQgc3RhdHVzZXMgd2l0aGluIHRoZSBiYXRjaC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCYXRjaFJlcXVlc3RDb3VudHMge1xuICAvKipcbiAgICogTnVtYmVyIG9mIHJlcXVlc3RzIHRoYXQgaGF2ZSBiZWVuIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAqL1xuICBjb21wbGV0ZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHJlcXVlc3RzIHRoYXQgaGF2ZSBmYWlsZWQuXG4gICAqL1xuICBmYWlsZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVG90YWwgbnVtYmVyIG9mIHJlcXVlc3RzIGluIHRoZSBiYXRjaC5cbiAgICovXG4gIHRvdGFsOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmF0Y2hDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIHRpbWUgZnJhbWUgd2l0aGluIHdoaWNoIHRoZSBiYXRjaCBzaG91bGQgYmUgcHJvY2Vzc2VkLiBDdXJyZW50bHkgb25seSBgMjRoYFxuICAgKiBpcyBzdXBwb3J0ZWQuXG4gICAqL1xuICBjb21wbGV0aW9uX3dpbmRvdzogJzI0aCc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbmRwb2ludCB0byBiZSB1c2VkIGZvciBhbGwgcmVxdWVzdHMgaW4gdGhlIGJhdGNoLiBDdXJyZW50bHlcbiAgICogYC92MS9jaGF0L2NvbXBsZXRpb25zYCwgYC92MS9lbWJlZGRpbmdzYCwgYW5kIGAvdjEvY29tcGxldGlvbnNgIGFyZSBzdXBwb3J0ZWQuXG4gICAqIE5vdGUgdGhhdCBgL3YxL2VtYmVkZGluZ3NgIGJhdGNoZXMgYXJlIGFsc28gcmVzdHJpY3RlZCB0byBhIG1heGltdW0gb2YgNTAsMDAwXG4gICAqIGVtYmVkZGluZyBpbnB1dHMgYWNyb3NzIGFsbCByZXF1ZXN0cyBpbiB0aGUgYmF0Y2guXG4gICAqL1xuICBlbmRwb2ludDogJy92MS9jaGF0L2NvbXBsZXRpb25zJyB8ICcvdjEvZW1iZWRkaW5ncycgfCAnL3YxL2NvbXBsZXRpb25zJztcblxuICAvKipcbiAgICogVGhlIElEIG9mIGFuIHVwbG9hZGVkIGZpbGUgdGhhdCBjb250YWlucyByZXF1ZXN0cyBmb3IgdGhlIG5ldyBiYXRjaC5cbiAgICpcbiAgICogU2VlIFt1cGxvYWQgZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9jcmVhdGUpXG4gICAqIGZvciBob3cgdG8gdXBsb2FkIGEgZmlsZS5cbiAgICpcbiAgICogWW91ciBpbnB1dCBmaWxlIG11c3QgYmUgZm9ybWF0dGVkIGFzIGFcbiAgICogW0pTT05MIGZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYmF0Y2gvcmVxdWVzdC1pbnB1dCksXG4gICAqIGFuZCBtdXN0IGJlIHVwbG9hZGVkIHdpdGggdGhlIHB1cnBvc2UgYGJhdGNoYC4gVGhlIGZpbGUgY2FuIGNvbnRhaW4gdXAgdG8gNTAsMDAwXG4gICAqIHJlcXVlc3RzLCBhbmQgY2FuIGJlIHVwIHRvIDIwMCBNQiBpbiBzaXplLlxuICAgKi9cbiAgaW5wdXRfZmlsZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjdXN0b20gbWV0YWRhdGEgZm9yIHRoZSBiYXRjaC5cbiAgICovXG4gIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmF0Y2hMaXN0UGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7fVxuXG5CYXRjaGVzLkJhdGNoZXNQYWdlID0gQmF0Y2hlc1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBCYXRjaGVzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIEJhdGNoIGFzIEJhdGNoLFxuICAgIHR5cGUgQmF0Y2hFcnJvciBhcyBCYXRjaEVycm9yLFxuICAgIHR5cGUgQmF0Y2hSZXF1ZXN0Q291bnRzIGFzIEJhdGNoUmVxdWVzdENvdW50cyxcbiAgICBCYXRjaGVzUGFnZSBhcyBCYXRjaGVzUGFnZSxcbiAgICB0eXBlIEJhdGNoQ3JlYXRlUGFyYW1zIGFzIEJhdGNoQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgQmF0Y2hMaXN0UGFyYW1zIGFzIEJhdGNoTGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBTaGFyZWQgZnJvbSAnLi4vc2hhcmVkJztcbmltcG9ydCAqIGFzIENoYXRBUEkgZnJvbSAnLi4vY2hhdC9jaGF0JztcbmltcG9ydCAqIGFzIE1lc3NhZ2VzQVBJIGZyb20gJy4vdGhyZWFkcy9tZXNzYWdlcyc7XG5pbXBvcnQgKiBhcyBUaHJlYWRzQVBJIGZyb20gJy4vdGhyZWFkcy90aHJlYWRzJztcbmltcG9ydCAqIGFzIFZlY3RvclN0b3Jlc0FQSSBmcm9tICcuL3ZlY3Rvci1zdG9yZXMvdmVjdG9yLXN0b3Jlcyc7XG5pbXBvcnQgKiBhcyBSdW5zQVBJIGZyb20gJy4vdGhyZWFkcy9ydW5zL3J1bnMnO1xuaW1wb3J0ICogYXMgU3RlcHNBUEkgZnJvbSAnLi90aHJlYWRzL3J1bnMvc3RlcHMnO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSwgdHlwZSBDdXJzb3JQYWdlUGFyYW1zIH0gZnJvbSAnLi4vLi4vcGFnaW5hdGlvbic7XG5cbmV4cG9ydCBjbGFzcyBBc3Npc3RhbnRzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlIGFuIGFzc2lzdGFudCB3aXRoIGEgbW9kZWwgYW5kIGluc3RydWN0aW9ucy5cbiAgICovXG4gIGNyZWF0ZShib2R5OiBBc3Npc3RhbnRDcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEFzc2lzdGFudD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2Fzc2lzdGFudHMnLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGFuIGFzc2lzdGFudC5cbiAgICovXG4gIHJldHJpZXZlKGFzc2lzdGFudElkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEFzc2lzdGFudD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvYXNzaXN0YW50cy8ke2Fzc2lzdGFudElkfWAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIGFuIGFzc2lzdGFudC5cbiAgICovXG4gIHVwZGF0ZShcbiAgICBhc3Npc3RhbnRJZDogc3RyaW5nLFxuICAgIGJvZHk6IEFzc2lzdGFudFVwZGF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPEFzc2lzdGFudD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH1gLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgYXNzaXN0YW50cy5cbiAgICovXG4gIGxpc3QoXG4gICAgcXVlcnk/OiBBc3Npc3RhbnRMaXN0UGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEFzc2lzdGFudHNQYWdlLCBBc3Npc3RhbnQ+O1xuICBsaXN0KG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5QYWdlUHJvbWlzZTxBc3Npc3RhbnRzUGFnZSwgQXNzaXN0YW50PjtcbiAgbGlzdChcbiAgICBxdWVyeTogQXNzaXN0YW50TGlzdFBhcmFtcyB8IENvcmUuUmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxBc3Npc3RhbnRzUGFnZSwgQXNzaXN0YW50PiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0KHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdCgnL2Fzc2lzdGFudHMnLCBBc3Npc3RhbnRzUGFnZSwge1xuICAgICAgcXVlcnksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYW4gYXNzaXN0YW50LlxuICAgKi9cbiAgZGVsKGFzc2lzdGFudElkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEFzc2lzdGFudERlbGV0ZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQXNzaXN0YW50c1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlPEFzc2lzdGFudD4ge31cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGBhc3Npc3RhbnRgIHRoYXQgY2FuIGNhbGwgdGhlIG1vZGVsIGFuZCB1c2UgdG9vbHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXNzaXN0YW50IHtcbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgYXNzaXN0YW50IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGFzc2lzdGFudC4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDUxMiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgZGVzY3JpcHRpb246IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzeXN0ZW0gaW5zdHJ1Y3Rpb25zIHRoYXQgdGhlIGFzc2lzdGFudCB1c2VzLiBUaGUgbWF4aW11bSBsZW5ndGggaXMgMjU2LDAwMFxuICAgKiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zOiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YTogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIElEIG9mIHRoZSBtb2RlbCB0byB1c2UuIFlvdSBjYW4gdXNlIHRoZVxuICAgKiBbTGlzdCBtb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzL2xpc3QpIEFQSSB0b1xuICAgKiBzZWUgYWxsIG9mIHlvdXIgYXZhaWxhYmxlIG1vZGVscywgb3Igc2VlIG91clxuICAgKiBbTW9kZWwgb3ZlcnZpZXddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscykgZm9yIGRlc2NyaXB0aW9ucyBvZlxuICAgKiB0aGVtLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGFzc2lzdGFudC4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDI1NiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgbmFtZTogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYGFzc2lzdGFudGAuXG4gICAqL1xuICBvYmplY3Q6ICdhc3Npc3RhbnQnO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdG9vbCBlbmFibGVkIG9uIHRoZSBhc3Npc3RhbnQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMTI4IHRvb2xzIHBlclxuICAgKiBhc3Npc3RhbnQuIFRvb2xzIGNhbiBiZSBvZiB0eXBlcyBgY29kZV9pbnRlcnByZXRlcmAsIGBmaWxlX3NlYXJjaGAsIG9yXG4gICAqIGBmdW5jdGlvbmAuXG4gICAqL1xuICB0b29sczogQXJyYXk8QXNzaXN0YW50VG9vbD47XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAgICogW0dQVC00b10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00byksXG4gICAqIFtHUFQtNCBUdXJib10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00LXR1cmJvLWFuZC1ncHQtNCksXG4gICAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9zY2hlbWFcIiwgXCJqc29uX3NjaGVtYVwiOiB7Li4ufSB9YCBlbmFibGVzIFN0cnVjdHVyZWRcbiAgICogT3V0cHV0cyB3aGljaCBlbnN1cmVzIHRoZSBtb2RlbCB3aWxsIG1hdGNoIHlvdXIgc3VwcGxpZWQgSlNPTiBzY2hlbWEuIExlYXJuIG1vcmVcbiAgICogaW4gdGhlXG4gICAqIFtTdHJ1Y3R1cmVkIE91dHB1dHMgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zdHJ1Y3R1cmVkLW91dHB1dHMpLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGVuc3VyZXMgdGhlXG4gICAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICAgKlxuICAgKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gICAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAgICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAgICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAgICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICAgKiBtYXggY29udGV4dCBsZW5ndGguXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBUaHJlYWRzQVBJLkFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBhc3Npc3RhbnQncyB0b29scy4gVGhlIHJlc291cmNlcyBhcmVcbiAgICogc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlc1xuICAgKiBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZVxuICAgKiBJRHMuXG4gICAqL1xuICB0b29sX3Jlc291cmNlcz86IEFzc2lzdGFudC5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgdGVtcGVyYXR1cmUgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdG9wX3A/OiBudW1iZXIgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEFzc2lzdGFudCB7XG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgdXNlZCBieSB0aGUgYXNzaXN0YW50J3MgdG9vbHMuIFRoZSByZXNvdXJjZXMgYXJlXG4gICAqIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXNcbiAgICogYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVcbiAgICogSURzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYGAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlc1xuICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIElEIG9mIHRoZVxuICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgYXNzaXN0YW50LiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvXG4gICAgICAgKiB0aGUgYXNzaXN0YW50LlxuICAgICAgICovXG4gICAgICB2ZWN0b3Jfc3RvcmVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBc3Npc3RhbnREZWxldGVkIHtcbiAgaWQ6IHN0cmluZztcblxuICBkZWxldGVkOiBib29sZWFuO1xuXG4gIG9iamVjdDogJ2Fzc2lzdGFudC5kZWxldGVkJztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGV2ZW50IGVtaXR0ZWQgd2hlbiBzdHJlYW1pbmcgYSBSdW4uXG4gKlxuICogRWFjaCBldmVudCBpbiBhIHNlcnZlci1zZW50IGV2ZW50cyBzdHJlYW0gaGFzIGFuIGBldmVudGAgYW5kIGBkYXRhYCBwcm9wZXJ0eTpcbiAqXG4gKiBgYGBcbiAqIGV2ZW50OiB0aHJlYWQuY3JlYXRlZFxuICogZGF0YToge1wiaWRcIjogXCJ0aHJlYWRfMTIzXCIsIFwib2JqZWN0XCI6IFwidGhyZWFkXCIsIC4uLn1cbiAqIGBgYFxuICpcbiAqIFdlIGVtaXQgZXZlbnRzIHdoZW5ldmVyIGEgbmV3IG9iamVjdCBpcyBjcmVhdGVkLCB0cmFuc2l0aW9ucyB0byBhIG5ldyBzdGF0ZSwgb3JcbiAqIGlzIGJlaW5nIHN0cmVhbWVkIGluIHBhcnRzIChkZWx0YXMpLiBGb3IgZXhhbXBsZSwgd2UgZW1pdCBgdGhyZWFkLnJ1bi5jcmVhdGVkYFxuICogd2hlbiBhIG5ldyBydW4gaXMgY3JlYXRlZCwgYHRocmVhZC5ydW4uY29tcGxldGVkYCB3aGVuIGEgcnVuIGNvbXBsZXRlcywgYW5kIHNvXG4gKiBvbi4gV2hlbiBhbiBBc3Npc3RhbnQgY2hvb3NlcyB0byBjcmVhdGUgYSBtZXNzYWdlIGR1cmluZyBhIHJ1biwgd2UgZW1pdCBhXG4gKiBgdGhyZWFkLm1lc3NhZ2UuY3JlYXRlZCBldmVudGAsIGEgYHRocmVhZC5tZXNzYWdlLmluX3Byb2dyZXNzYCBldmVudCwgbWFueVxuICogYHRocmVhZC5tZXNzYWdlLmRlbHRhYCBldmVudHMsIGFuZCBmaW5hbGx5IGEgYHRocmVhZC5tZXNzYWdlLmNvbXBsZXRlZGAgZXZlbnQuXG4gKlxuICogV2UgbWF5IGFkZCBhZGRpdGlvbmFsIGV2ZW50cyBvdmVyIHRpbWUsIHNvIHdlIHJlY29tbWVuZCBoYW5kbGluZyB1bmtub3duIGV2ZW50c1xuICogZ3JhY2VmdWxseSBpbiB5b3VyIGNvZGUuIFNlZSB0aGVcbiAqIFtBc3Npc3RhbnRzIEFQSSBxdWlja3N0YXJ0XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL292ZXJ2aWV3KVxuICogdG8gbGVhcm4gaG93IHRvIGludGVncmF0ZSB0aGUgQXNzaXN0YW50cyBBUEkgd2l0aCBzdHJlYW1pbmcuXG4gKi9cbmV4cG9ydCB0eXBlIEFzc2lzdGFudFN0cmVhbUV2ZW50ID1cbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRDcmVhdGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuQ3JlYXRlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1blF1ZXVlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1bkluUHJvZ3Jlc3NcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5SZXF1aXJlc0FjdGlvblxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1bkNvbXBsZXRlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1bkluY29tcGxldGVcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5GYWlsZWRcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5DYW5jZWxsaW5nXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuQ2FuY2VsbGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuRXhwaXJlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBDcmVhdGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcEluUHJvZ3Jlc3NcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwRGVsdGFcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwQ29tcGxldGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcEZhaWxlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBDYW5jZWxsZWRcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwRXhwaXJlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZE1lc3NhZ2VDcmVhdGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkTWVzc2FnZUluUHJvZ3Jlc3NcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRNZXNzYWdlRGVsdGFcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRNZXNzYWdlQ29tcGxldGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkTWVzc2FnZUluY29tcGxldGVcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5FcnJvckV2ZW50O1xuXG5leHBvcnQgbmFtZXNwYWNlIEFzc2lzdGFudFN0cmVhbUV2ZW50IHtcbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgbmV3XG4gICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcy9vYmplY3QpIGlzXG4gICAqIGNyZWF0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZENyZWF0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSB0aHJlYWQgdGhhdCBjb250YWluc1xuICAgICAqIFttZXNzYWdlc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcykuXG4gICAgICovXG4gICAgZGF0YTogVGhyZWFkc0FQSS5UaHJlYWQ7XG5cbiAgICBldmVudDogJ3RocmVhZC5jcmVhdGVkJztcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZW5hYmxlIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24uXG4gICAgICovXG4gICAgZW5hYmxlZD86IGJvb2xlYW47XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBuZXdcbiAgICogW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdCkgaXMgY3JlYXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuQ3JlYXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmNyZWF0ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogbW92ZXMgdG8gYSBgcXVldWVkYCBzdGF0dXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blF1ZXVlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnF1ZXVlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBtb3ZlcyB0byBhbiBgaW5fcHJvZ3Jlc3NgIHN0YXR1cy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuSW5Qcm9ncmVzcyB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmluX3Byb2dyZXNzJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIG1vdmVzIHRvIGEgYHJlcXVpcmVzX2FjdGlvbmAgc3RhdHVzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5SZXF1aXJlc0FjdGlvbiB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnJlcXVpcmVzX2FjdGlvbic7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBpcyBjb21wbGV0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkNvbXBsZXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmNvbXBsZXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBlbmRzIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuSW5jb21wbGV0ZSB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmluY29tcGxldGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogZmFpbHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkZhaWxlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmZhaWxlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBtb3ZlcyB0byBhIGBjYW5jZWxsaW5nYCBzdGF0dXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkNhbmNlbGxpbmcge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5jYW5jZWxsaW5nJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIGlzIGNhbmNlbGxlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuQ2FuY2VsbGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uY2FuY2VsbGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIGV4cGlyZXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkV4cGlyZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5leHBpcmVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIGlzIGNyZWF0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBDcmVhdGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc3RlcCBpbiBleGVjdXRpb24gb2YgYSBydW4uXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmNyZWF0ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogbW92ZXMgdG8gYW4gYGluX3Byb2dyZXNzYCBzdGF0ZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcEluUHJvZ3Jlc3Mge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuaW5fcHJvZ3Jlc3MnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIHBhcnRzIG9mIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogYXJlIGJlaW5nIHN0cmVhbWVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwRGVsdGEge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBydW4gc3RlcCBkZWx0YSBpLmUuIGFueSBjaGFuZ2VkIGZpZWxkcyBvbiBhIHJ1biBzdGVwIGR1cmluZ1xuICAgICAqIHN0cmVhbWluZy5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwRGVsdGFFdmVudDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmRlbHRhJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIGlzIGNvbXBsZXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcENvbXBsZXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5jb21wbGV0ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogZmFpbHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBGYWlsZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuZmFpbGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIGlzIGNhbmNlbGxlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcENhbmNlbGxlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5jYW5jZWxsZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogZXhwaXJlcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcEV4cGlyZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuZXhwaXJlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbbWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcy9vYmplY3QpIGlzXG4gICAqIGNyZWF0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZE1lc3NhZ2VDcmVhdGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgbWVzc2FnZSB3aXRoaW4gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogTWVzc2FnZXNBUEkuTWVzc2FnZTtcblxuICAgIGV2ZW50OiAndGhyZWFkLm1lc3NhZ2UuY3JlYXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbbWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcy9vYmplY3QpIG1vdmVzXG4gICAqIHRvIGFuIGBpbl9wcm9ncmVzc2Agc3RhdGUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZE1lc3NhZ2VJblByb2dyZXNzIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgbWVzc2FnZSB3aXRoaW4gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogTWVzc2FnZXNBUEkuTWVzc2FnZTtcblxuICAgIGV2ZW50OiAndGhyZWFkLm1lc3NhZ2UuaW5fcHJvZ3Jlc3MnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIHBhcnRzIG9mIGFcbiAgICogW01lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMvb2JqZWN0KSBhcmVcbiAgICogYmVpbmcgc3RyZWFtZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZE1lc3NhZ2VEZWx0YSB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIG1lc3NhZ2UgZGVsdGEgaS5lLiBhbnkgY2hhbmdlZCBmaWVsZHMgb24gYSBtZXNzYWdlIGR1cmluZ1xuICAgICAqIHN0cmVhbWluZy5cbiAgICAgKi9cbiAgICBkYXRhOiBNZXNzYWdlc0FQSS5NZXNzYWdlRGVsdGFFdmVudDtcblxuICAgIGV2ZW50OiAndGhyZWFkLm1lc3NhZ2UuZGVsdGEnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW21lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMvb2JqZWN0KSBpc1xuICAgKiBjb21wbGV0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZE1lc3NhZ2VDb21wbGV0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIHdpdGhpbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBNZXNzYWdlc0FQSS5NZXNzYWdlO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQubWVzc2FnZS5jb21wbGV0ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW21lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMvb2JqZWN0KSBlbmRzXG4gICAqIGJlZm9yZSBpdCBpcyBjb21wbGV0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZE1lc3NhZ2VJbmNvbXBsZXRlIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgbWVzc2FnZSB3aXRoaW4gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogTWVzc2FnZXNBUEkuTWVzc2FnZTtcblxuICAgIGV2ZW50OiAndGhyZWFkLm1lc3NhZ2UuaW5jb21wbGV0ZSc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYW5cbiAgICogW2Vycm9yXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZXJyb3ItY29kZXMjYXBpLWVycm9ycykgb2NjdXJzLlxuICAgKiBUaGlzIGNhbiBoYXBwZW4gZHVlIHRvIGFuIGludGVybmFsIHNlcnZlciBlcnJvciBvciBhIHRpbWVvdXQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEVycm9yRXZlbnQge1xuICAgIGRhdGE6IFNoYXJlZC5FcnJvck9iamVjdDtcblxuICAgIGV2ZW50OiAnZXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIEFzc2lzdGFudFRvb2wgPSBDb2RlSW50ZXJwcmV0ZXJUb29sIHwgRmlsZVNlYXJjaFRvb2wgfCBGdW5jdGlvblRvb2w7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyVG9vbCB7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0b29sIGJlaW5nIGRlZmluZWQ6IGBjb2RlX2ludGVycHJldGVyYFxuICAgKi9cbiAgdHlwZTogJ2NvZGVfaW50ZXJwcmV0ZXInO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2hUb29sIHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRvb2wgYmVpbmcgZGVmaW5lZDogYGZpbGVfc2VhcmNoYFxuICAgKi9cbiAgdHlwZTogJ2ZpbGVfc2VhcmNoJztcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIGZvciB0aGUgZmlsZSBzZWFyY2ggdG9vbC5cbiAgICovXG4gIGZpbGVfc2VhcmNoPzogRmlsZVNlYXJjaFRvb2wuRmlsZVNlYXJjaDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaWxlU2VhcmNoVG9vbCB7XG4gIC8qKlxuICAgKiBPdmVycmlkZXMgZm9yIHRoZSBmaWxlIHNlYXJjaCB0b29sLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVzdWx0cyB0aGUgZmlsZSBzZWFyY2ggdG9vbCBzaG91bGQgb3V0cHV0LiBUaGUgZGVmYXVsdCBpc1xuICAgICAqIDIwIGZvciBgZ3B0LTQqYCBtb2RlbHMgYW5kIDUgZm9yIGBncHQtMy41LXR1cmJvYC4gVGhpcyBudW1iZXIgc2hvdWxkIGJlIGJldHdlZW5cbiAgICAgKiAxIGFuZCA1MCBpbmNsdXNpdmUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbGUgc2VhcmNoIHRvb2wgbWF5IG91dHB1dCBmZXdlciB0aGFuIGBtYXhfbnVtX3Jlc3VsdHNgIHJlc3VsdHMuXG4gICAgICogU2VlIHRoZVxuICAgICAqIFtmaWxlIHNlYXJjaCB0b29sIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvdG9vbHMvZmlsZS1zZWFyY2gjY3VzdG9taXppbmctZmlsZS1zZWFyY2gtc2V0dGluZ3MpXG4gICAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgbWF4X251bV9yZXN1bHRzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJhbmtpbmcgb3B0aW9ucyBmb3IgdGhlIGZpbGUgc2VhcmNoLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgZmlsZSBzZWFyY2ggdG9vbFxuICAgICAqIHdpbGwgdXNlIHRoZSBgYXV0b2AgcmFua2VyIGFuZCBhIHNjb3JlX3RocmVzaG9sZCBvZiAwLlxuICAgICAqXG4gICAgICogU2VlIHRoZVxuICAgICAqIFtmaWxlIHNlYXJjaCB0b29sIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvdG9vbHMvZmlsZS1zZWFyY2gjY3VzdG9taXppbmctZmlsZS1zZWFyY2gtc2V0dGluZ3MpXG4gICAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgcmFua2luZ19vcHRpb25zPzogRmlsZVNlYXJjaC5SYW5raW5nT3B0aW9ucztcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgRmlsZVNlYXJjaCB7XG4gICAgLyoqXG4gICAgICogVGhlIHJhbmtpbmcgb3B0aW9ucyBmb3IgdGhlIGZpbGUgc2VhcmNoLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgZmlsZSBzZWFyY2ggdG9vbFxuICAgICAqIHdpbGwgdXNlIHRoZSBgYXV0b2AgcmFua2VyIGFuZCBhIHNjb3JlX3RocmVzaG9sZCBvZiAwLlxuICAgICAqXG4gICAgICogU2VlIHRoZVxuICAgICAqIFtmaWxlIHNlYXJjaCB0b29sIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvdG9vbHMvZmlsZS1zZWFyY2gjY3VzdG9taXppbmctZmlsZS1zZWFyY2gtc2V0dGluZ3MpXG4gICAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBSYW5raW5nT3B0aW9ucyB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBzY29yZSB0aHJlc2hvbGQgZm9yIHRoZSBmaWxlIHNlYXJjaC4gQWxsIHZhbHVlcyBtdXN0IGJlIGEgZmxvYXRpbmcgcG9pbnRcbiAgICAgICAqIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICAgKi9cbiAgICAgIHNjb3JlX3RocmVzaG9sZDogbnVtYmVyO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSByYW5rZXIgdG8gdXNlIGZvciB0aGUgZmlsZSBzZWFyY2guIElmIG5vdCBzcGVjaWZpZWQgd2lsbCB1c2UgdGhlIGBhdXRvYFxuICAgICAgICogcmFua2VyLlxuICAgICAgICovXG4gICAgICByYW5rZXI/OiAnYXV0bycgfCAnZGVmYXVsdF8yMDI0XzA4XzIxJztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvblRvb2wge1xuICBmdW5jdGlvbjogU2hhcmVkLkZ1bmN0aW9uRGVmaW5pdGlvbjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdG9vbCBiZWluZyBkZWZpbmVkOiBgZnVuY3Rpb25gXG4gICAqL1xuICB0eXBlOiAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIE9jY3VycyB3aGVuIGFcbiAqIFttZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzL29iamVjdCkgaXNcbiAqIGNyZWF0ZWQuXG4gKi9cbmV4cG9ydCB0eXBlIE1lc3NhZ2VTdHJlYW1FdmVudCA9XG4gIHwgTWVzc2FnZVN0cmVhbUV2ZW50LlRocmVhZE1lc3NhZ2VDcmVhdGVkXG4gIHwgTWVzc2FnZVN0cmVhbUV2ZW50LlRocmVhZE1lc3NhZ2VJblByb2dyZXNzXG4gIHwgTWVzc2FnZVN0cmVhbUV2ZW50LlRocmVhZE1lc3NhZ2VEZWx0YVxuICB8IE1lc3NhZ2VTdHJlYW1FdmVudC5UaHJlYWRNZXNzYWdlQ29tcGxldGVkXG4gIHwgTWVzc2FnZVN0cmVhbUV2ZW50LlRocmVhZE1lc3NhZ2VJbmNvbXBsZXRlO1xuXG5leHBvcnQgbmFtZXNwYWNlIE1lc3NhZ2VTdHJlYW1FdmVudCB7XG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFttZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzL29iamVjdCkgaXNcbiAgICogY3JlYXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkTWVzc2FnZUNyZWF0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIHdpdGhpbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBNZXNzYWdlc0FQSS5NZXNzYWdlO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQubWVzc2FnZS5jcmVhdGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFttZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzL29iamVjdCkgbW92ZXNcbiAgICogdG8gYW4gYGluX3Byb2dyZXNzYCBzdGF0ZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkTWVzc2FnZUluUHJvZ3Jlc3Mge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIHdpdGhpbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBNZXNzYWdlc0FQSS5NZXNzYWdlO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQubWVzc2FnZS5pbl9wcm9ncmVzcyc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gcGFydHMgb2YgYVxuICAgKiBbTWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcy9vYmplY3QpIGFyZVxuICAgKiBiZWluZyBzdHJlYW1lZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkTWVzc2FnZURlbHRhIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgbWVzc2FnZSBkZWx0YSBpLmUuIGFueSBjaGFuZ2VkIGZpZWxkcyBvbiBhIG1lc3NhZ2UgZHVyaW5nXG4gICAgICogc3RyZWFtaW5nLlxuICAgICAqL1xuICAgIGRhdGE6IE1lc3NhZ2VzQVBJLk1lc3NhZ2VEZWx0YUV2ZW50O1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQubWVzc2FnZS5kZWx0YSc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbbWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcy9vYmplY3QpIGlzXG4gICAqIGNvbXBsZXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkTWVzc2FnZUNvbXBsZXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIG1lc3NhZ2Ugd2l0aGluIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IE1lc3NhZ2VzQVBJLk1lc3NhZ2U7XG5cbiAgICBldmVudDogJ3RocmVhZC5tZXNzYWdlLmNvbXBsZXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbbWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcy9vYmplY3QpIGVuZHNcbiAgICogYmVmb3JlIGl0IGlzIGNvbXBsZXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkTWVzc2FnZUluY29tcGxldGUge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIHdpdGhpbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBNZXNzYWdlc0FQSS5NZXNzYWdlO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQubWVzc2FnZS5pbmNvbXBsZXRlJztcbiAgfVxufVxuXG4vKipcbiAqIE9jY3VycyB3aGVuIGFcbiAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gKiBpcyBjcmVhdGVkLlxuICovXG5leHBvcnQgdHlwZSBSdW5TdGVwU3RyZWFtRXZlbnQgPVxuICB8IFJ1blN0ZXBTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwQ3JlYXRlZFxuICB8IFJ1blN0ZXBTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwSW5Qcm9ncmVzc1xuICB8IFJ1blN0ZXBTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwRGVsdGFcbiAgfCBSdW5TdGVwU3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcENvbXBsZXRlZFxuICB8IFJ1blN0ZXBTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwRmFpbGVkXG4gIHwgUnVuU3RlcFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBDYW5jZWxsZWRcbiAgfCBSdW5TdGVwU3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcEV4cGlyZWQ7XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuU3RlcFN0cmVhbUV2ZW50IHtcbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogaXMgY3JlYXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcENyZWF0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuY3JlYXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBtb3ZlcyB0byBhbiBgaW5fcHJvZ3Jlc3NgIHN0YXRlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwSW5Qcm9ncmVzcyB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5pbl9wcm9ncmVzcyc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gcGFydHMgb2YgYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBhcmUgYmVpbmcgc3RyZWFtZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBEZWx0YSB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHJ1biBzdGVwIGRlbHRhIGkuZS4gYW55IGNoYW5nZWQgZmllbGRzIG9uIGEgcnVuIHN0ZXAgZHVyaW5nXG4gICAgICogc3RyZWFtaW5nLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXBEZWx0YUV2ZW50O1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuZGVsdGEnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogaXMgY29tcGxldGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwQ29tcGxldGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc3RlcCBpbiBleGVjdXRpb24gb2YgYSBydW4uXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmNvbXBsZXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBmYWlscy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcEZhaWxlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5mYWlsZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogaXMgY2FuY2VsbGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwQ2FuY2VsbGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc3RlcCBpbiBleGVjdXRpb24gb2YgYSBydW4uXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmNhbmNlbGxlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBleHBpcmVzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwRXhwaXJlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5leHBpcmVkJztcbiAgfVxufVxuXG4vKipcbiAqIE9jY3VycyB3aGVuIGEgbmV3XG4gKiBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KSBpcyBjcmVhdGVkLlxuICovXG5leHBvcnQgdHlwZSBSdW5TdHJlYW1FdmVudCA9XG4gIHwgUnVuU3RyZWFtRXZlbnQuVGhyZWFkUnVuQ3JlYXRlZFxuICB8IFJ1blN0cmVhbUV2ZW50LlRocmVhZFJ1blF1ZXVlZFxuICB8IFJ1blN0cmVhbUV2ZW50LlRocmVhZFJ1bkluUHJvZ3Jlc3NcbiAgfCBSdW5TdHJlYW1FdmVudC5UaHJlYWRSdW5SZXF1aXJlc0FjdGlvblxuICB8IFJ1blN0cmVhbUV2ZW50LlRocmVhZFJ1bkNvbXBsZXRlZFxuICB8IFJ1blN0cmVhbUV2ZW50LlRocmVhZFJ1bkluY29tcGxldGVcbiAgfCBSdW5TdHJlYW1FdmVudC5UaHJlYWRSdW5GYWlsZWRcbiAgfCBSdW5TdHJlYW1FdmVudC5UaHJlYWRSdW5DYW5jZWxsaW5nXG4gIHwgUnVuU3RyZWFtRXZlbnQuVGhyZWFkUnVuQ2FuY2VsbGVkXG4gIHwgUnVuU3RyZWFtRXZlbnQuVGhyZWFkUnVuRXhwaXJlZDtcblxuZXhwb3J0IG5hbWVzcGFjZSBSdW5TdHJlYW1FdmVudCB7XG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIG5ld1xuICAgKiBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KSBpcyBjcmVhdGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5DcmVhdGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uY3JlYXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBtb3ZlcyB0byBhIGBxdWV1ZWRgIHN0YXR1cy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuUXVldWVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4ucXVldWVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIG1vdmVzIHRvIGFuIGBpbl9wcm9ncmVzc2Agc3RhdHVzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5JblByb2dyZXNzIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uaW5fcHJvZ3Jlc3MnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogbW92ZXMgdG8gYSBgcmVxdWlyZXNfYWN0aW9uYCBzdGF0dXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blJlcXVpcmVzQWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4ucmVxdWlyZXNfYWN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIGlzIGNvbXBsZXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuQ29tcGxldGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uY29tcGxldGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIGVuZHMgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5JbmNvbXBsZXRlIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uaW5jb21wbGV0ZSc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBmYWlscy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuRmFpbGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uZmFpbGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIG1vdmVzIHRvIGEgYGNhbmNlbGxpbmdgIHN0YXR1cy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuQ2FuY2VsbGluZyB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmNhbmNlbGxpbmcnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogaXMgY2FuY2VsbGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5DYW5jZWxsZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5jYW5jZWxsZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogZXhwaXJlcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuRXhwaXJlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmV4cGlyZWQnO1xuICB9XG59XG5cbi8qKlxuICogT2NjdXJzIHdoZW4gYSBuZXdcbiAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcy9vYmplY3QpIGlzXG4gKiBjcmVhdGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRocmVhZFN0cmVhbUV2ZW50IHtcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSB0aHJlYWQgdGhhdCBjb250YWluc1xuICAgKiBbbWVzc2FnZXNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMpLlxuICAgKi9cbiAgZGF0YTogVGhyZWFkc0FQSS5UaHJlYWQ7XG5cbiAgZXZlbnQ6ICd0aHJlYWQuY3JlYXRlZCc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24uXG4gICAqL1xuICBlbmFibGVkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBc3Npc3RhbnRDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogSUQgb2YgdGhlIG1vZGVsIHRvIHVzZS4gWW91IGNhbiB1c2UgdGhlXG4gICAqIFtMaXN0IG1vZGVsc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tb2RlbHMvbGlzdCkgQVBJIHRvXG4gICAqIHNlZSBhbGwgb2YgeW91ciBhdmFpbGFibGUgbW9kZWxzLCBvciBzZWUgb3VyXG4gICAqIFtNb2RlbCBvdmVydmlld10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzKSBmb3IgZGVzY3JpcHRpb25zIG9mXG4gICAqIHRoZW0uXG4gICAqL1xuICBtb2RlbDogKHN0cmluZyAmIHt9KSB8IENoYXRBUEkuQ2hhdE1vZGVsO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGFzc2lzdGFudC4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDUxMiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgZGVzY3JpcHRpb24/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIGluc3RydWN0aW9ucyB0aGF0IHRoZSBhc3Npc3RhbnQgdXNlcy4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDI1NiwwMDBcbiAgICogY2hhcmFjdGVycy5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBhc3Npc3RhbnQuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyAyNTYgY2hhcmFjdGVycy5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gICAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNG8pLFxuICAgKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICAgKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fc2NoZW1hXCIsIFwianNvbl9zY2hlbWFcIjogey4uLn0gfWAgZW5hYmxlcyBTdHJ1Y3R1cmVkXG4gICAqIE91dHB1dHMgd2hpY2ggZW5zdXJlcyB0aGUgbW9kZWwgd2lsbCBtYXRjaCB5b3VyIHN1cHBsaWVkIEpTT04gc2NoZW1hLiBMZWFybiBtb3JlXG4gICAqIGluIHRoZVxuICAgKiBbU3RydWN0dXJlZCBPdXRwdXRzIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc3RydWN0dXJlZC1vdXRwdXRzKS5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBlbnN1cmVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogVGhyZWFkc0FQSS5Bc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoYXQgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdG8gdXNlLCBiZXR3ZWVuIDAgYW5kIDIuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbFxuICAgKiBtYWtlIHRoZSBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZVxuICAgKiBmb2N1c2VkIGFuZCBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgdXNlZCBieSB0aGUgYXNzaXN0YW50J3MgdG9vbHMuIFRoZSByZXNvdXJjZXMgYXJlXG4gICAqIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXNcbiAgICogYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVcbiAgICogSURzLlxuICAgKi9cbiAgdG9vbF9yZXNvdXJjZXM/OiBBc3Npc3RhbnRDcmVhdGVQYXJhbXMuVG9vbFJlc291cmNlcyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0b29sIGVuYWJsZWQgb24gdGhlIGFzc2lzdGFudC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxMjggdG9vbHMgcGVyXG4gICAqIGFzc2lzdGFudC4gVG9vbHMgY2FuIGJlIG9mIHR5cGVzIGBjb2RlX2ludGVycHJldGVyYCwgYGZpbGVfc2VhcmNoYCwgb3JcbiAgICogYGZ1bmN0aW9uYC5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50VG9vbD47XG5cbiAgLyoqXG4gICAqIEFuIGFsdGVybmF0aXZlIHRvIHNhbXBsaW5nIHdpdGggdGVtcGVyYXR1cmUsIGNhbGxlZCBudWNsZXVzIHNhbXBsaW5nLCB3aGVyZSB0aGVcbiAgICogbW9kZWwgY29uc2lkZXJzIHRoZSByZXN1bHRzIG9mIHRoZSB0b2tlbnMgd2l0aCB0b3BfcCBwcm9iYWJpbGl0eSBtYXNzLiBTbyAwLjFcbiAgICogbWVhbnMgb25seSB0aGUgdG9rZW5zIGNvbXByaXNpbmcgdGhlIHRvcCAxMCUgcHJvYmFiaWxpdHkgbWFzcyBhcmUgY29uc2lkZXJlZC5cbiAgICpcbiAgICogV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIHRlbXBlcmF0dXJlIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRvcF9wPzogbnVtYmVyIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBBc3Npc3RhbnRDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIGFzc2lzdGFudCdzIHRvb2xzLiBUaGUgcmVzb3VyY2VzIGFyZVxuICAgKiBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzXG4gICAqIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlXG4gICAqIElEcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgY29kZV9pbnRlcnByZXRlcj86IFRvb2xSZXNvdXJjZXMuQ29kZUludGVycHJldGVyO1xuXG4gICAgZmlsZV9zZWFyY2g/OiBUb29sUmVzb3VyY2VzLkZpbGVTZWFyY2g7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgbWFkZVxuICAgICAgICogYXZhaWxhYmxlIHRvIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlc1xuICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyBhc3Npc3RhbnQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAqIHRoZSBhc3Npc3RhbnQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgaGVscGVyIHRvIGNyZWF0ZSBhXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogd2l0aCBmaWxlX2lkcyBhbmQgYXR0YWNoIGl0IHRvIHRoaXMgYXNzaXN0YW50LiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDFcbiAgICAgICAqIHZlY3RvciBzdG9yZSBhdHRhY2hlZCB0byB0aGUgYXNzaXN0YW50LlxuICAgICAgICovXG4gICAgICB2ZWN0b3Jfc3RvcmVzPzogQXJyYXk8RmlsZVNlYXJjaC5WZWN0b3JTdG9yZT47XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmUge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNodW5raW5nIHN0cmF0ZWd5IHVzZWQgdG8gY2h1bmsgdGhlIGZpbGUocykuIElmIG5vdCBzZXQsIHdpbGwgdXNlIHRoZSBgYXV0b2BcbiAgICAgICAgICogc3RyYXRlZ3kuIE9ubHkgYXBwbGljYWJsZSBpZiBgZmlsZV9pZHNgIGlzIG5vbi1lbXB0eS5cbiAgICAgICAgICovXG4gICAgICAgIGNodW5raW5nX3N0cmF0ZWd5PzogVmVjdG9yU3RvcmVzQVBJLkZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIHRvXG4gICAgICAgICAqIGFkZCB0byB0aGUgdmVjdG9yIHN0b3JlLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEwMDAwIGZpbGVzIGluIGEgdmVjdG9yXG4gICAgICAgICAqIHN0b3JlLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdmVjdG9yIHN0b3JlLiBUaGlzIGNhbiBiZVxuICAgICAgICAgKiB1c2VmdWwgZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdmVjdG9yIHN0b3JlIGluIGEgc3RydWN0dXJlZFxuICAgICAgICAgKiBmb3JtYXQuIEtleXMgY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW1cbiAgICAgICAgICogb2YgNTEyIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgICAgICovXG4gICAgICAgIG1ldGFkYXRhPzogdW5rbm93bjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBc3Npc3RhbnRVcGRhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBhc3Npc3RhbnQuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyA1MTIgY2hhcmFjdGVycy5cbiAgICovXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHN5c3RlbSBpbnN0cnVjdGlvbnMgdGhhdCB0aGUgYXNzaXN0YW50IHVzZXMuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyAyNTYsMDAwXG4gICAqIGNoYXJhY3RlcnMuXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBZb3UgY2FuIHVzZSB0aGVcbiAgICogW0xpc3QgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscy9saXN0KSBBUEkgdG9cbiAgICogc2VlIGFsbCBvZiB5b3VyIGF2YWlsYWJsZSBtb2RlbHMsIG9yIHNlZSBvdXJcbiAgICogW01vZGVsIG92ZXJ2aWV3XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMpIGZvciBkZXNjcmlwdGlvbnMgb2ZcbiAgICogdGhlbS5cbiAgICovXG4gIG1vZGVsPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgYXNzaXN0YW50LiBUaGUgbWF4aW11bSBsZW5ndGggaXMgMjU2IGNoYXJhY3RlcnMuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBmb3JtYXQgdGhhdCB0aGUgbW9kZWwgbXVzdCBvdXRwdXQuIENvbXBhdGlibGUgd2l0aFxuICAgKiBbR1BULTRvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTRvKSxcbiAgICogW0dQVC00IFR1cmJvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTQtdHVyYm8tYW5kLWdwdC00KSxcbiAgICogYW5kIGFsbCBHUFQtMy41IFR1cmJvIG1vZGVscyBzaW5jZSBgZ3B0LTMuNS10dXJiby0xMTA2YC5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX3NjaGVtYVwiLCBcImpzb25fc2NoZW1hXCI6IHsuLi59IH1gIGVuYWJsZXMgU3RydWN0dXJlZFxuICAgKiBPdXRwdXRzIHdoaWNoIGVuc3VyZXMgdGhlIG1vZGVsIHdpbGwgbWF0Y2ggeW91ciBzdXBwbGllZCBKU09OIHNjaGVtYS4gTGVhcm4gbW9yZVxuICAgKiBpbiB0aGVcbiAgICogW1N0cnVjdHVyZWQgT3V0cHV0cyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3N0cnVjdHVyZWQtb3V0cHV0cykuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9vYmplY3RcIiB9YCBlbmFibGVzIEpTT04gbW9kZSwgd2hpY2ggZW5zdXJlcyB0aGVcbiAgICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gICAqXG4gICAqICoqSW1wb3J0YW50OioqIHdoZW4gdXNpbmcgSlNPTiBtb2RlLCB5b3UgKiptdXN0KiogYWxzbyBpbnN0cnVjdCB0aGUgbW9kZWwgdG9cbiAgICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICAgKiBnZW5lcmF0ZSBhbiB1bmVuZGluZyBzdHJlYW0gb2Ygd2hpdGVzcGFjZSB1bnRpbCB0aGUgZ2VuZXJhdGlvbiByZWFjaGVzIHRoZSB0b2tlblxuICAgKiBsaW1pdCwgcmVzdWx0aW5nIGluIGEgbG9uZy1ydW5uaW5nIGFuZCBzZWVtaW5nbHkgXCJzdHVja1wiIHJlcXVlc3QuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICAgKiBpbmRpY2F0ZXMgdGhlIGdlbmVyYXRpb24gZXhjZWVkZWQgYG1heF90b2tlbnNgIG9yIHRoZSBjb252ZXJzYXRpb24gZXhjZWVkZWQgdGhlXG4gICAqIG1heCBjb250ZXh0IGxlbmd0aC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86IFRocmVhZHNBUEkuQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIGFzc2lzdGFudCdzIHRvb2xzLiBUaGUgcmVzb3VyY2VzIGFyZVxuICAgKiBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzXG4gICAqIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlXG4gICAqIElEcy5cbiAgICovXG4gIHRvb2xfcmVzb3VyY2VzPzogQXNzaXN0YW50VXBkYXRlUGFyYW1zLlRvb2xSZXNvdXJjZXMgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdG9vbCBlbmFibGVkIG9uIHRoZSBhc3Npc3RhbnQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMTI4IHRvb2xzIHBlclxuICAgKiBhc3Npc3RhbnQuIFRvb2xzIGNhbiBiZSBvZiB0eXBlcyBgY29kZV9pbnRlcnByZXRlcmAsIGBmaWxlX3NlYXJjaGAsIG9yXG4gICAqIGBmdW5jdGlvbmAuXG4gICAqL1xuICB0b29scz86IEFycmF5PEFzc2lzdGFudFRvb2w+O1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQXNzaXN0YW50VXBkYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBhc3Npc3RhbnQncyB0b29scy4gVGhlIHJlc291cmNlcyBhcmVcbiAgICogc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlc1xuICAgKiBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZVxuICAgKiBJRHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGNvZGVfaW50ZXJwcmV0ZXI/OiBUb29sUmVzb3VyY2VzLkNvZGVJbnRlcnByZXRlcjtcblxuICAgIGZpbGVfc2VhcmNoPzogVG9vbFJlc291cmNlcy5GaWxlU2VhcmNoO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyB0aGUgbGlzdCBvZlxuICAgICAgICogW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlIGF2YWlsYWJsZVxuICAgICAgICogdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzIGFzc29jaWF0ZWRcbiAgICAgICAqIHdpdGggdGhlIHRvb2wuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgdGhlXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyBhc3Npc3RhbnQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAqIHRoZSBhc3Npc3RhbnQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFzc2lzdGFudExpc3RQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgY3Vyc29yIGZvciB1c2UgaW4gcGFnaW5hdGlvbi4gYGJlZm9yZWAgaXMgYW4gb2JqZWN0IElEIHRoYXQgZGVmaW5lcyB5b3VyIHBsYWNlXG4gICAqIGluIHRoZSBsaXN0LiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBtYWtlIGEgbGlzdCByZXF1ZXN0IGFuZCByZWNlaXZlIDEwMCBvYmplY3RzLFxuICAgKiBzdGFydGluZyB3aXRoIG9ial9mb28sIHlvdXIgc3Vic2VxdWVudCBjYWxsIGNhbiBpbmNsdWRlIGJlZm9yZT1vYmpfZm9vIGluIG9yZGVyXG4gICAqIHRvIGZldGNoIHRoZSBwcmV2aW91cyBwYWdlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgYmVmb3JlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTb3J0IG9yZGVyIGJ5IHRoZSBgY3JlYXRlZF9hdGAgdGltZXN0YW1wIG9mIHRoZSBvYmplY3RzLiBgYXNjYCBmb3IgYXNjZW5kaW5nXG4gICAqIG9yZGVyIGFuZCBgZGVzY2AgZm9yIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAqL1xuICBvcmRlcj86ICdhc2MnIHwgJ2Rlc2MnO1xufVxuXG5Bc3Npc3RhbnRzLkFzc2lzdGFudHNQYWdlID0gQXNzaXN0YW50c1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBBc3Npc3RhbnRzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIEFzc2lzdGFudCBhcyBBc3Npc3RhbnQsXG4gICAgdHlwZSBBc3Npc3RhbnREZWxldGVkIGFzIEFzc2lzdGFudERlbGV0ZWQsXG4gICAgdHlwZSBBc3Npc3RhbnRTdHJlYW1FdmVudCBhcyBBc3Npc3RhbnRTdHJlYW1FdmVudCxcbiAgICB0eXBlIEFzc2lzdGFudFRvb2wgYXMgQXNzaXN0YW50VG9vbCxcbiAgICB0eXBlIENvZGVJbnRlcnByZXRlclRvb2wgYXMgQ29kZUludGVycHJldGVyVG9vbCxcbiAgICB0eXBlIEZpbGVTZWFyY2hUb29sIGFzIEZpbGVTZWFyY2hUb29sLFxuICAgIHR5cGUgRnVuY3Rpb25Ub29sIGFzIEZ1bmN0aW9uVG9vbCxcbiAgICB0eXBlIE1lc3NhZ2VTdHJlYW1FdmVudCBhcyBNZXNzYWdlU3RyZWFtRXZlbnQsXG4gICAgdHlwZSBSdW5TdGVwU3RyZWFtRXZlbnQgYXMgUnVuU3RlcFN0cmVhbUV2ZW50LFxuICAgIHR5cGUgUnVuU3RyZWFtRXZlbnQgYXMgUnVuU3RyZWFtRXZlbnQsXG4gICAgdHlwZSBUaHJlYWRTdHJlYW1FdmVudCBhcyBUaHJlYWRTdHJlYW1FdmVudCxcbiAgICBBc3Npc3RhbnRzUGFnZSBhcyBBc3Npc3RhbnRzUGFnZSxcbiAgICB0eXBlIEFzc2lzdGFudENyZWF0ZVBhcmFtcyBhcyBBc3Npc3RhbnRDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBBc3Npc3RhbnRVcGRhdGVQYXJhbXMgYXMgQXNzaXN0YW50VXBkYXRlUGFyYW1zLFxuICAgIHR5cGUgQXNzaXN0YW50TGlzdFBhcmFtcyBhcyBBc3Npc3RhbnRMaXN0UGFyYW1zLFxuICB9O1xufVxuIiwgImltcG9ydCB7IHR5cGUgQ2hhdENvbXBsZXRpb25SdW5uZXIgfSBmcm9tICcuL0NoYXRDb21wbGV0aW9uUnVubmVyJztcbmltcG9ydCB7IHR5cGUgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIgfSBmcm9tICcuL0NoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyJztcbmltcG9ydCB7IEpTT05TY2hlbWEgfSBmcm9tICcuL2pzb25zY2hlbWEnO1xuXG50eXBlIFByb21pc2VPclZhbHVlPFQ+ID0gVCB8IFByb21pc2U8VD47XG5cbmV4cG9ydCB0eXBlIFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncyBleHRlbmRzIG9iamVjdD4gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gYXJncyB0aGUgcmV0dXJuIHZhbHVlIGZyb20gYHBhcnNlYC5cbiAgICogQHBhcmFtIHJ1bm5lciB0aGUgcnVubmVyIGV2YWx1YXRpbmcgdGhpcyBjYWxsYmFjay5cbiAgICogQHJldHVybnMgYSBzdHJpbmcgdG8gc2VuZCBiYWNrIHRvIE9wZW5BSS5cbiAgICovXG4gIGZ1bmN0aW9uOiAoXG4gICAgYXJnczogQXJncyxcbiAgICBydW5uZXI6IENoYXRDb21wbGV0aW9uUnVubmVyPHVua25vd24+IHwgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXI8dW5rbm93bj4sXG4gICkgPT4gUHJvbWlzZU9yVmFsdWU8dW5rbm93bj47XG4gIC8qKlxuICAgKiBAcGFyYW0gaW5wdXQgdGhlIHJhdyBhcmdzIGZyb20gdGhlIE9wZW5BSSBmdW5jdGlvbiBjYWxsLlxuICAgKiBAcmV0dXJucyB0aGUgcGFyc2VkIGFyZ3VtZW50cyB0byBwYXNzIHRvIGBmdW5jdGlvbmBcbiAgICovXG4gIHBhcnNlOiAoaW5wdXQ6IHN0cmluZykgPT4gUHJvbWlzZU9yVmFsdWU8QXJncz47XG4gIC8qKlxuICAgKiBUaGUgcGFyYW1ldGVycyB0aGUgZnVuY3Rpb24gYWNjZXB0cywgZGVzY3JpYmVzIGFzIGEgSlNPTiBTY2hlbWEgb2JqZWN0LlxuICAgKi9cbiAgcGFyYW1ldGVyczogSlNPTlNjaGVtYTtcbiAgLyoqXG4gICAqIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgZnVuY3Rpb24gZG9lcywgdXNlZCBieSB0aGUgbW9kZWwgdG8gY2hvb3NlIHdoZW4gYW5kIGhvdyB0byBjYWxsIHRoZSBmdW5jdGlvbi5cbiAgICovXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLiBXaWxsIGRlZmF1bHQgdG8gZnVuY3Rpb24ubmFtZSBpZiBvbWl0dGVkLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgc3RyaWN0PzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCB0eXBlIFJ1bm5hYmxlRnVuY3Rpb25XaXRob3V0UGFyc2UgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gYXJncyB0aGUgcmF3IGFyZ3MgZnJvbSB0aGUgT3BlbkFJIGZ1bmN0aW9uIGNhbGwuXG4gICAqIEByZXR1cm5zIGEgc3RyaW5nIHRvIHNlbmQgYmFjayB0byBPcGVuQUlcbiAgICovXG4gIGZ1bmN0aW9uOiAoXG4gICAgYXJnczogc3RyaW5nLFxuICAgIHJ1bm5lcjogQ2hhdENvbXBsZXRpb25SdW5uZXI8dW5rbm93bj4gfCBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcjx1bmtub3duPixcbiAgKSA9PiBQcm9taXNlT3JWYWx1ZTx1bmtub3duPjtcbiAgLyoqXG4gICAqIFRoZSBwYXJhbWV0ZXJzIHRoZSBmdW5jdGlvbiBhY2NlcHRzLCBkZXNjcmliZXMgYXMgYSBKU09OIFNjaGVtYSBvYmplY3QuXG4gICAqL1xuICBwYXJhbWV0ZXJzOiBKU09OU2NoZW1hO1xuICAvKipcbiAgICogQSBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoZSBmdW5jdGlvbiBkb2VzLCB1c2VkIGJ5IHRoZSBtb2RlbCB0byBjaG9vc2Ugd2hlbiBhbmQgaG93IHRvIGNhbGwgdGhlIGZ1bmN0aW9uLlxuICAgKi9cbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQuIFdpbGwgZGVmYXVsdCB0byBmdW5jdGlvbi5uYW1lIGlmIG9taXR0ZWQuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBzdHJpY3Q/OiBib29sZWFuIHwgdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IHR5cGUgUnVubmFibGVGdW5jdGlvbjxBcmdzIGV4dGVuZHMgb2JqZWN0IHwgc3RyaW5nPiA9XG4gIEFyZ3MgZXh0ZW5kcyBzdHJpbmcgPyBSdW5uYWJsZUZ1bmN0aW9uV2l0aG91dFBhcnNlXG4gIDogQXJncyBleHRlbmRzIG9iamVjdCA/IFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncz5cbiAgOiBuZXZlcjtcblxuZXhwb3J0IHR5cGUgUnVubmFibGVUb29sRnVuY3Rpb248QXJncyBleHRlbmRzIG9iamVjdCB8IHN0cmluZz4gPVxuICBBcmdzIGV4dGVuZHMgc3RyaW5nID8gUnVubmFibGVUb29sRnVuY3Rpb25XaXRob3V0UGFyc2VcbiAgOiBBcmdzIGV4dGVuZHMgb2JqZWN0ID8gUnVubmFibGVUb29sRnVuY3Rpb25XaXRoUGFyc2U8QXJncz5cbiAgOiBuZXZlcjtcblxuZXhwb3J0IHR5cGUgUnVubmFibGVUb29sRnVuY3Rpb25XaXRob3V0UGFyc2UgPSB7XG4gIHR5cGU6ICdmdW5jdGlvbic7XG4gIGZ1bmN0aW9uOiBSdW5uYWJsZUZ1bmN0aW9uV2l0aG91dFBhcnNlO1xufTtcbmV4cG9ydCB0eXBlIFJ1bm5hYmxlVG9vbEZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3MgZXh0ZW5kcyBvYmplY3Q+ID0ge1xuICB0eXBlOiAnZnVuY3Rpb24nO1xuICBmdW5jdGlvbjogUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzPjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1J1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncyBleHRlbmRzIG9iamVjdD4oXG4gIGZuOiBhbnksXG4pOiBmbiBpcyBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3M+IHtcbiAgcmV0dXJuIHR5cGVvZiAoZm4gYXMgYW55KS5wYXJzZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IHR5cGUgQmFzZUZ1bmN0aW9uc0FyZ3MgPSByZWFkb25seSAob2JqZWN0IHwgc3RyaW5nKVtdO1xuXG5leHBvcnQgdHlwZSBSdW5uYWJsZUZ1bmN0aW9uczxGdW5jdGlvbnNBcmdzIGV4dGVuZHMgQmFzZUZ1bmN0aW9uc0FyZ3M+ID1cbiAgW2FueVtdXSBleHRlbmRzIFtGdW5jdGlvbnNBcmdzXSA/IHJlYWRvbmx5IFJ1bm5hYmxlRnVuY3Rpb248YW55PltdXG4gIDoge1xuICAgICAgW0luZGV4IGluIGtleW9mIEZ1bmN0aW9uc0FyZ3NdOiBJbmRleCBleHRlbmRzIG51bWJlciA/IFJ1bm5hYmxlRnVuY3Rpb248RnVuY3Rpb25zQXJnc1tJbmRleF0+XG4gICAgICA6IEZ1bmN0aW9uc0FyZ3NbSW5kZXhdO1xuICAgIH07XG5cbmV4cG9ydCB0eXBlIFJ1bm5hYmxlVG9vbHM8RnVuY3Rpb25zQXJncyBleHRlbmRzIEJhc2VGdW5jdGlvbnNBcmdzPiA9XG4gIFthbnlbXV0gZXh0ZW5kcyBbRnVuY3Rpb25zQXJnc10gPyByZWFkb25seSBSdW5uYWJsZVRvb2xGdW5jdGlvbjxhbnk+W11cbiAgOiB7XG4gICAgICBbSW5kZXggaW4ga2V5b2YgRnVuY3Rpb25zQXJnc106IEluZGV4IGV4dGVuZHMgbnVtYmVyID8gUnVubmFibGVUb29sRnVuY3Rpb248RnVuY3Rpb25zQXJnc1tJbmRleF0+XG4gICAgICA6IEZ1bmN0aW9uc0FyZ3NbSW5kZXhdO1xuICAgIH07XG5cbi8qKlxuICogVGhpcyBpcyBoZWxwZXIgY2xhc3MgZm9yIHBhc3NpbmcgYSBgZnVuY3Rpb25gIGFuZCBgcGFyc2VgIHdoZXJlIHRoZSBgZnVuY3Rpb25gXG4gKiBhcmd1bWVudCB0eXBlIG1hdGNoZXMgdGhlIGBwYXJzZWAgcmV0dXJuIHR5cGUuXG4gKlxuICogQGRlcHJlY2F0ZWQgLSBwbGVhc2UgdXNlIFBhcnNpbmdUb29sRnVuY3Rpb24gaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnNpbmdGdW5jdGlvbjxBcmdzIGV4dGVuZHMgb2JqZWN0PiB7XG4gIGZ1bmN0aW9uOiBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3M+WydmdW5jdGlvbiddO1xuICBwYXJzZTogUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzPlsncGFyc2UnXTtcbiAgcGFyYW1ldGVyczogUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzPlsncGFyYW1ldGVycyddO1xuICBkZXNjcmlwdGlvbjogUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzPlsnZGVzY3JpcHRpb24nXTtcbiAgbmFtZT86IFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncz5bJ25hbWUnXTtcblxuICBjb25zdHJ1Y3RvcihpbnB1dDogUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzPikge1xuICAgIHRoaXMuZnVuY3Rpb24gPSBpbnB1dC5mdW5jdGlvbjtcbiAgICB0aGlzLnBhcnNlID0gaW5wdXQucGFyc2U7XG4gICAgdGhpcy5wYXJhbWV0ZXJzID0gaW5wdXQucGFyYW1ldGVycztcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gaW5wdXQuZGVzY3JpcHRpb247XG4gICAgdGhpcy5uYW1lID0gaW5wdXQubmFtZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgaGVscGVyIGNsYXNzIGZvciBwYXNzaW5nIGEgYGZ1bmN0aW9uYCBhbmQgYHBhcnNlYCB3aGVyZSB0aGUgYGZ1bmN0aW9uYFxuICogYXJndW1lbnQgdHlwZSBtYXRjaGVzIHRoZSBgcGFyc2VgIHJldHVybiB0eXBlLlxuICovXG5leHBvcnQgY2xhc3MgUGFyc2luZ1Rvb2xGdW5jdGlvbjxBcmdzIGV4dGVuZHMgb2JqZWN0PiB7XG4gIHR5cGU6ICdmdW5jdGlvbic7XG4gIGZ1bmN0aW9uOiBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3M+O1xuXG4gIGNvbnN0cnVjdG9yKGlucHV0OiBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3M+KSB7XG4gICAgdGhpcy50eXBlID0gJ2Z1bmN0aW9uJztcbiAgICB0aGlzLmZ1bmN0aW9uID0gaW5wdXQ7XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICB0eXBlIENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtLFxuICB0eXBlIENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW0sXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0sXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sTWVzc2FnZVBhcmFtLFxufSBmcm9tICcuLi9yZXNvdXJjZXMnO1xuXG5leHBvcnQgY29uc3QgaXNBc3Npc3RhbnRNZXNzYWdlID0gKFxuICBtZXNzYWdlOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSB8IG51bGwgfCB1bmRlZmluZWQsXG4pOiBtZXNzYWdlIGlzIENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtID0+IHtcbiAgcmV0dXJuIG1lc3NhZ2U/LnJvbGUgPT09ICdhc3Npc3RhbnQnO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb25NZXNzYWdlID0gKFxuICBtZXNzYWdlOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSB8IG51bGwgfCB1bmRlZmluZWQsXG4pOiBtZXNzYWdlIGlzIENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW0gPT4ge1xuICByZXR1cm4gbWVzc2FnZT8ucm9sZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbmV4cG9ydCBjb25zdCBpc1Rvb2xNZXNzYWdlID0gKFxuICBtZXNzYWdlOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSB8IG51bGwgfCB1bmRlZmluZWQsXG4pOiBtZXNzYWdlIGlzIENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbSA9PiB7XG4gIHJldHVybiBtZXNzYWdlPy5yb2xlID09PSAndG9vbCc7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNQcmVzZW50PFQ+KG9iajogVCB8IG51bGwgfCB1bmRlZmluZWQpOiBvYmogaXMgVCB7XG4gIHJldHVybiBvYmogIT0gbnVsbDtcbn1cbiIsICJpbXBvcnQgeyBBUElVc2VyQWJvcnRFcnJvciwgT3BlbkFJRXJyb3IgfSBmcm9tICcuLi9lcnJvcic7XG5cbmV4cG9ydCBjbGFzcyBFdmVudFN0cmVhbTxFdmVudFR5cGVzIGV4dGVuZHMgQmFzZUV2ZW50cz4ge1xuICBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cbiAgI2Nvbm5lY3RlZFByb21pc2U6IFByb21pc2U8dm9pZD47XG4gICNyZXNvbHZlQ29ubmVjdGVkUHJvbWlzZTogKCkgPT4gdm9pZCA9ICgpID0+IHt9O1xuICAjcmVqZWN0Q29ubmVjdGVkUHJvbWlzZTogKGVycm9yOiBPcGVuQUlFcnJvcikgPT4gdm9pZCA9ICgpID0+IHt9O1xuXG4gICNlbmRQcm9taXNlOiBQcm9taXNlPHZvaWQ+O1xuICAjcmVzb2x2ZUVuZFByb21pc2U6ICgpID0+IHZvaWQgPSAoKSA9PiB7fTtcbiAgI3JlamVjdEVuZFByb21pc2U6IChlcnJvcjogT3BlbkFJRXJyb3IpID0+IHZvaWQgPSAoKSA9PiB7fTtcblxuICAjbGlzdGVuZXJzOiB7XG4gICAgW0V2ZW50IGluIGtleW9mIEV2ZW50VHlwZXNdPzogRXZlbnRMaXN0ZW5lcnM8RXZlbnRUeXBlcywgRXZlbnQ+O1xuICB9ID0ge307XG5cbiAgI2VuZGVkID0gZmFsc2U7XG4gICNlcnJvcmVkID0gZmFsc2U7XG4gICNhYm9ydGVkID0gZmFsc2U7XG4gICNjYXRjaGluZ1Byb21pc2VDcmVhdGVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy4jY29ubmVjdGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuI3Jlc29sdmVDb25uZWN0ZWRQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMuI3JlamVjdENvbm5lY3RlZFByb21pc2UgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB0aGlzLiNlbmRQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy4jcmVzb2x2ZUVuZFByb21pc2UgPSByZXNvbHZlO1xuICAgICAgdGhpcy4jcmVqZWN0RW5kUHJvbWlzZSA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIC8vIERvbid0IGxldCB0aGVzZSBwcm9taXNlcyBjYXVzZSB1bmhhbmRsZWQgcmVqZWN0aW9uIGVycm9ycy5cbiAgICAvLyB3ZSB3aWxsIG1hbnVhbGx5IGNhdXNlIGFuIHVuaGFuZGxlZCByZWplY3Rpb24gZXJyb3IgbGF0ZXJcbiAgICAvLyBpZiB0aGUgdXNlciBoYXNuJ3QgcmVnaXN0ZXJlZCBhbnkgZXJyb3IgbGlzdGVuZXIgb3IgY2FsbGVkXG4gICAgLy8gYW55IHByb21pc2UtcmV0dXJuaW5nIG1ldGhvZC5cbiAgICB0aGlzLiNjb25uZWN0ZWRQcm9taXNlLmNhdGNoKCgpID0+IHt9KTtcbiAgICB0aGlzLiNlbmRQcm9taXNlLmNhdGNoKCgpID0+IHt9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfcnVuKHRoaXM6IEV2ZW50U3RyZWFtPEV2ZW50VHlwZXM+LCBleGVjdXRvcjogKCkgPT4gUHJvbWlzZTxhbnk+KSB7XG4gICAgLy8gVW5mb3J0dW5hdGVseSBpZiB3ZSBjYWxsIGBleGVjdXRvcigpYCBpbW1lZGlhdGVseSB3ZSBnZXQgcnVudGltZSBlcnJvcnMgYWJvdXRcbiAgICAvLyByZWZlcmVuY2VzIHRvIGB0aGlzYCBiZWZvcmUgdGhlIGBzdXBlcigpYCBjb25zdHJ1Y3RvciBjYWxsIHJldHVybnMuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBleGVjdXRvcigpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbWl0RmluYWwoKTtcbiAgICAgICAgdGhpcy5fZW1pdCgnZW5kJyk7XG4gICAgICB9LCB0aGlzLiNoYW5kbGVFcnJvci5iaW5kKHRoaXMpKTtcbiAgICB9LCAwKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY29ubmVjdGVkKHRoaXM6IEV2ZW50U3RyZWFtPEV2ZW50VHlwZXM+KSB7XG4gICAgaWYgKHRoaXMuZW5kZWQpIHJldHVybjtcbiAgICB0aGlzLiNyZXNvbHZlQ29ubmVjdGVkUHJvbWlzZSgpO1xuICAgIHRoaXMuX2VtaXQoJ2Nvbm5lY3QnKTtcbiAgfVxuXG4gIGdldCBlbmRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy4jZW5kZWQ7XG4gIH1cblxuICBnZXQgZXJyb3JlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy4jZXJyb3JlZDtcbiAgfVxuXG4gIGdldCBhYm9ydGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLiNhYm9ydGVkO1xuICB9XG5cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGZvciB0aGUgZXZlbnQuXG4gICAqIE5vIGNoZWNrcyBhcmUgbWFkZSB0byBzZWUgaWYgdGhlIGxpc3RlbmVyIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQuIE11bHRpcGxlIGNhbGxzIHBhc3NpbmdcbiAgICogdGhlIHNhbWUgY29tYmluYXRpb24gb2YgZXZlbnQgYW5kIGxpc3RlbmVyIHdpbGwgcmVzdWx0IGluIHRoZSBsaXN0ZW5lciBiZWluZyBhZGRlZCwgYW5kXG4gICAqIGNhbGxlZCwgbXVsdGlwbGUgdGltZXMuXG4gICAqIEByZXR1cm5zIHRoaXMgQ2hhdENvbXBsZXRpb25TdHJlYW0sIHNvIHRoYXQgY2FsbHMgY2FuIGJlIGNoYWluZWRcbiAgICovXG4gIG9uPEV2ZW50IGV4dGVuZHMga2V5b2YgRXZlbnRUeXBlcz4oZXZlbnQ6IEV2ZW50LCBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjxFdmVudFR5cGVzLCBFdmVudD4pOiB0aGlzIHtcbiAgICBjb25zdCBsaXN0ZW5lcnM6IEV2ZW50TGlzdGVuZXJzPEV2ZW50VHlwZXMsIEV2ZW50PiA9XG4gICAgICB0aGlzLiNsaXN0ZW5lcnNbZXZlbnRdIHx8ICh0aGlzLiNsaXN0ZW5lcnNbZXZlbnRdID0gW10pO1xuICAgIGxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIGZyb20gdGhlIGxpc3RlbmVyIGFycmF5IGZvciB0aGUgZXZlbnQuXG4gICAqIG9mZigpIHdpbGwgcmVtb3ZlLCBhdCBtb3N0LCBvbmUgaW5zdGFuY2Ugb2YgYSBsaXN0ZW5lciBmcm9tIHRoZSBsaXN0ZW5lciBhcnJheS4gSWYgYW55IHNpbmdsZVxuICAgKiBsaXN0ZW5lciBoYXMgYmVlbiBhZGRlZCBtdWx0aXBsZSB0aW1lcyB0byB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQsIHRoZW5cbiAgICogb2ZmKCkgbXVzdCBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgdG8gcmVtb3ZlIGVhY2ggaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHRoaXMgQ2hhdENvbXBsZXRpb25TdHJlYW0sIHNvIHRoYXQgY2FsbHMgY2FuIGJlIGNoYWluZWRcbiAgICovXG4gIG9mZjxFdmVudCBleHRlbmRzIGtleW9mIEV2ZW50VHlwZXM+KGV2ZW50OiBFdmVudCwgbGlzdGVuZXI6IEV2ZW50TGlzdGVuZXI8RXZlbnRUeXBlcywgRXZlbnQ+KTogdGhpcyB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy4jbGlzdGVuZXJzW2V2ZW50XTtcbiAgICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuZmluZEluZGV4KChsKSA9PiBsLmxpc3RlbmVyID09PSBsaXN0ZW5lcik7XG4gICAgaWYgKGluZGV4ID49IDApIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBvbmUtdGltZSBsaXN0ZW5lciBmdW5jdGlvbiBmb3IgdGhlIGV2ZW50LiBUaGUgbmV4dCB0aW1lIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQsXG4gICAqIHRoaXMgbGlzdGVuZXIgaXMgcmVtb3ZlZCBhbmQgdGhlbiBpbnZva2VkLlxuICAgKiBAcmV0dXJucyB0aGlzIENoYXRDb21wbGV0aW9uU3RyZWFtLCBzbyB0aGF0IGNhbGxzIGNhbiBiZSBjaGFpbmVkXG4gICAqL1xuICBvbmNlPEV2ZW50IGV4dGVuZHMga2V5b2YgRXZlbnRUeXBlcz4oZXZlbnQ6IEV2ZW50LCBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjxFdmVudFR5cGVzLCBFdmVudD4pOiB0aGlzIHtcbiAgICBjb25zdCBsaXN0ZW5lcnM6IEV2ZW50TGlzdGVuZXJzPEV2ZW50VHlwZXMsIEV2ZW50PiA9XG4gICAgICB0aGlzLiNsaXN0ZW5lcnNbZXZlbnRdIHx8ICh0aGlzLiNsaXN0ZW5lcnNbZXZlbnRdID0gW10pO1xuICAgIGxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IHRydWUgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBzaW1pbGFyIHRvIGAub25jZSgpYCwgYnV0IHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdGhlIG5leHQgdGltZVxuICAgKiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLCBpbnN0ZWFkIG9mIGNhbGxpbmcgYSBsaXN0ZW5lciBjYWxsYmFjay5cbiAgICogQHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdGhlIG5leHQgdGltZSBnaXZlbiBldmVudCBpcyB0cmlnZ2VyZWQsXG4gICAqIG9yIHJlamVjdHMgaWYgYW4gZXJyb3IgaXMgZW1pdHRlZC4gIChJZiB5b3UgcmVxdWVzdCB0aGUgJ2Vycm9yJyBldmVudCxcbiAgICogcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBlcnJvcikuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHN0cmVhbS5lbWl0dGVkKCdtZXNzYWdlJykgLy8gcmVqZWN0cyBpZiB0aGUgc3RyZWFtIGVycm9yc1xuICAgKi9cbiAgZW1pdHRlZDxFdmVudCBleHRlbmRzIGtleW9mIEV2ZW50VHlwZXM+KFxuICAgIGV2ZW50OiBFdmVudCxcbiAgKTogUHJvbWlzZTxcbiAgICBFdmVudFBhcmFtZXRlcnM8RXZlbnRUeXBlcywgRXZlbnQ+IGV4dGVuZHMgW2luZmVyIFBhcmFtXSA/IFBhcmFtXG4gICAgOiBFdmVudFBhcmFtZXRlcnM8RXZlbnRUeXBlcywgRXZlbnQ+IGV4dGVuZHMgW10gPyB2b2lkXG4gICAgOiBFdmVudFBhcmFtZXRlcnM8RXZlbnRUeXBlcywgRXZlbnQ+XG4gID4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLiNjYXRjaGluZ1Byb21pc2VDcmVhdGVkID0gdHJ1ZTtcbiAgICAgIGlmIChldmVudCAhPT0gJ2Vycm9yJykgdGhpcy5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICB0aGlzLm9uY2UoZXZlbnQsIHJlc29sdmUgYXMgYW55KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGRvbmUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy4jY2F0Y2hpbmdQcm9taXNlQ3JlYXRlZCA9IHRydWU7XG4gICAgYXdhaXQgdGhpcy4jZW5kUHJvbWlzZTtcbiAgfVxuXG4gICNoYW5kbGVFcnJvcih0aGlzOiBFdmVudFN0cmVhbTxFdmVudFR5cGVzPiwgZXJyb3I6IHVua25vd24pIHtcbiAgICB0aGlzLiNlcnJvcmVkID0gdHJ1ZTtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgIGVycm9yID0gbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFQSVVzZXJBYm9ydEVycm9yKSB7XG4gICAgICB0aGlzLiNhYm9ydGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLl9lbWl0KCdhYm9ydCcsIGVycm9yKTtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgT3BlbkFJRXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGNvbnN0IG9wZW5BSUVycm9yOiBPcGVuQUlFcnJvciA9IG5ldyBPcGVuQUlFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIG9wZW5BSUVycm9yLmNhdXNlID0gZXJyb3I7XG4gICAgICByZXR1cm4gdGhpcy5fZW1pdCgnZXJyb3InLCBvcGVuQUlFcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lbWl0KCdlcnJvcicsIG5ldyBPcGVuQUlFcnJvcihTdHJpbmcoZXJyb3IpKSk7XG4gIH1cblxuICBfZW1pdDxFdmVudCBleHRlbmRzIGtleW9mIEJhc2VFdmVudHM+KGV2ZW50OiBFdmVudCwgLi4uYXJnczogRXZlbnRQYXJhbWV0ZXJzPEJhc2VFdmVudHMsIEV2ZW50Pik6IHZvaWQ7XG4gIF9lbWl0PEV2ZW50IGV4dGVuZHMga2V5b2YgRXZlbnRUeXBlcz4oZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiBFdmVudFBhcmFtZXRlcnM8RXZlbnRUeXBlcywgRXZlbnQ+KTogdm9pZDtcbiAgX2VtaXQ8RXZlbnQgZXh0ZW5kcyBrZXlvZiBFdmVudFR5cGVzPihcbiAgICB0aGlzOiBFdmVudFN0cmVhbTxFdmVudFR5cGVzPixcbiAgICBldmVudDogRXZlbnQsXG4gICAgLi4uYXJnczogRXZlbnRQYXJhbWV0ZXJzPEV2ZW50VHlwZXMsIEV2ZW50PlxuICApIHtcbiAgICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3QgZW1pdCBhbnkgZXZlbnRzIGFmdGVyIGVuZFxuICAgIGlmICh0aGlzLiNlbmRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudCA9PT0gJ2VuZCcpIHtcbiAgICAgIHRoaXMuI2VuZGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuI3Jlc29sdmVFbmRQcm9taXNlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdGVuZXJzOiBFdmVudExpc3RlbmVyczxFdmVudFR5cGVzLCBFdmVudD4gfCB1bmRlZmluZWQgPSB0aGlzLiNsaXN0ZW5lcnNbZXZlbnRdO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuI2xpc3RlbmVyc1tldmVudF0gPSBsaXN0ZW5lcnMuZmlsdGVyKChsKSA9PiAhbC5vbmNlKSBhcyBhbnk7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoeyBsaXN0ZW5lciB9OiBhbnkpID0+IGxpc3RlbmVyKC4uLihhcmdzIGFzIGFueSkpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQgPT09ICdhYm9ydCcpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gYXJnc1swXSBhcyBBUElVc2VyQWJvcnRFcnJvcjtcbiAgICAgIGlmICghdGhpcy4jY2F0Y2hpbmdQcm9taXNlQ3JlYXRlZCAmJiAhbGlzdGVuZXJzPy5sZW5ndGgpIHtcbiAgICAgICAgUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgdGhpcy4jcmVqZWN0Q29ubmVjdGVkUHJvbWlzZShlcnJvcik7XG4gICAgICB0aGlzLiNyZWplY3RFbmRQcm9taXNlKGVycm9yKTtcbiAgICAgIHRoaXMuX2VtaXQoJ2VuZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudCA9PT0gJ2Vycm9yJykge1xuICAgICAgLy8gTk9URTogX2VtaXQoJ2Vycm9yJywgZXJyb3IpIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBmcm9tICNoYW5kbGVFcnJvcigpLlxuXG4gICAgICBjb25zdCBlcnJvciA9IGFyZ3NbMF0gYXMgT3BlbkFJRXJyb3I7XG4gICAgICBpZiAoIXRoaXMuI2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQgJiYgIWxpc3RlbmVycz8ubGVuZ3RoKSB7XG4gICAgICAgIC8vIFRyaWdnZXIgYW4gdW5oYW5kbGVkIHJlamVjdGlvbiBpZiB0aGUgdXNlciBoYXNuJ3QgcmVnaXN0ZXJlZCBhbnkgZXJyb3IgaGFuZGxlcnMuXG4gICAgICAgIC8vIElmIHlvdSBhcmUgc2VlaW5nIHN0YWNrIHRyYWNlcyBoZXJlLCBtYWtlIHN1cmUgdG8gaGFuZGxlIGVycm9ycyB2aWEgZWl0aGVyOlxuICAgICAgICAvLyAtIHJ1bm5lci5vbignZXJyb3InLCAoKSA9PiAuLi4pXG4gICAgICAgIC8vIC0gYXdhaXQgcnVubmVyLmRvbmUoKVxuICAgICAgICAvLyAtIGF3YWl0IHJ1bm5lci5maW5hbENoYXRDb21wbGV0aW9uKClcbiAgICAgICAgLy8gLSBldGMuXG4gICAgICAgIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3JlamVjdENvbm5lY3RlZFByb21pc2UoZXJyb3IpO1xuICAgICAgdGhpcy4jcmVqZWN0RW5kUHJvbWlzZShlcnJvcik7XG4gICAgICB0aGlzLl9lbWl0KCdlbmQnKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2VtaXRGaW5hbCgpOiB2b2lkIHt9XG59XG5cbnR5cGUgRXZlbnRMaXN0ZW5lcjxFdmVudHMsIEV2ZW50VHlwZSBleHRlbmRzIGtleW9mIEV2ZW50cz4gPSBFdmVudHNbRXZlbnRUeXBlXTtcblxudHlwZSBFdmVudExpc3RlbmVyczxFdmVudHMsIEV2ZW50VHlwZSBleHRlbmRzIGtleW9mIEV2ZW50cz4gPSBBcnJheTx7XG4gIGxpc3RlbmVyOiBFdmVudExpc3RlbmVyPEV2ZW50cywgRXZlbnRUeXBlPjtcbiAgb25jZT86IGJvb2xlYW47XG59PjtcblxuZXhwb3J0IHR5cGUgRXZlbnRQYXJhbWV0ZXJzPEV2ZW50cywgRXZlbnRUeXBlIGV4dGVuZHMga2V5b2YgRXZlbnRzPiA9IHtcbiAgW0V2ZW50IGluIEV2ZW50VHlwZV06IEV2ZW50TGlzdGVuZXI8RXZlbnRzLCBFdmVudFR5cGU+IGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFApID0+IGFueSA/IFAgOiBuZXZlcjtcbn1bRXZlbnRUeXBlXTtcblxuZXhwb3J0IGludGVyZmFjZSBCYXNlRXZlbnRzIHtcbiAgY29ubmVjdDogKCkgPT4gdm9pZDtcbiAgZXJyb3I6IChlcnJvcjogT3BlbkFJRXJyb3IpID0+IHZvaWQ7XG4gIGFib3J0OiAoZXJyb3I6IEFQSVVzZXJBYm9ydEVycm9yKSA9PiB2b2lkO1xuICBlbmQ6ICgpID0+IHZvaWQ7XG59XG4iLCAiaW1wb3J0IHtcbiAgQ2hhdENvbXBsZXRpb24sXG4gIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCxcbiAgQ2hhdENvbXBsZXRpb25Ub29sLFxufSBmcm9tICcuLi9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucyc7XG5pbXBvcnQge1xuICBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1Rvb2xSdW5uZXJQYXJhbXMsXG4gIENoYXRDb21wbGV0aW9uU3RyZWFtUGFyYW1zLFxuICBDaGF0Q29tcGxldGlvblRvb2xSdW5uZXJQYXJhbXMsXG4gIFBhcnNlZENoYXRDb21wbGV0aW9uLFxuICBQYXJzZWRDaG9pY2UsXG4gIFBhcnNlZEZ1bmN0aW9uVG9vbENhbGwsXG59IGZyb20gJy4uL3Jlc291cmNlcy9iZXRhL2NoYXQvY29tcGxldGlvbnMnO1xuaW1wb3J0IHsgUmVzcG9uc2VGb3JtYXRKU09OU2NoZW1hIH0gZnJvbSAnLi4vcmVzb3VyY2VzL3NoYXJlZCc7XG5pbXBvcnQgeyBDb250ZW50RmlsdGVyRmluaXNoUmVhc29uRXJyb3IsIExlbmd0aEZpbmlzaFJlYXNvbkVycm9yLCBPcGVuQUlFcnJvciB9IGZyb20gJy4uL2Vycm9yJztcblxudHlwZSBBbnlDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyA9XG4gIHwgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNcbiAgfCBDaGF0Q29tcGxldGlvblRvb2xSdW5uZXJQYXJhbXM8YW55PlxuICB8IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nVG9vbFJ1bm5lclBhcmFtczxhbnk+XG4gIHwgQ2hhdENvbXBsZXRpb25TdHJlYW1QYXJhbXM7XG5cbmV4cG9ydCB0eXBlIEV4dHJhY3RQYXJzZWRDb250ZW50RnJvbVBhcmFtczxQYXJhbXMgZXh0ZW5kcyBBbnlDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcz4gPVxuICBQYXJhbXNbJ3Jlc3BvbnNlX2Zvcm1hdCddIGV4dGVuZHMgQXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0PGluZmVyIFA+ID8gUCA6IG51bGw7XG5cbmV4cG9ydCB0eXBlIEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdDxQYXJzZWRUPiA9IFJlc3BvbnNlRm9ybWF0SlNPTlNjaGVtYSAmIHtcbiAgX19vdXRwdXQ6IFBhcnNlZFQ7IC8vIHR5cGUtbGV2ZWwgb25seVxuXG4gICRicmFuZDogJ2F1dG8tcGFyc2VhYmxlLXJlc3BvbnNlLWZvcm1hdCc7XG4gICRwYXJzZVJhdyhjb250ZW50OiBzdHJpbmcpOiBQYXJzZWRUO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQYXJzZWFibGVSZXNwb25zZUZvcm1hdDxQYXJzZWRUPihcbiAgcmVzcG9uc2VfZm9ybWF0OiBSZXNwb25zZUZvcm1hdEpTT05TY2hlbWEsXG4gIHBhcnNlcjogKGNvbnRlbnQ6IHN0cmluZykgPT4gUGFyc2VkVCxcbik6IEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdDxQYXJzZWRUPiB7XG4gIGNvbnN0IG9iaiA9IHsgLi4ucmVzcG9uc2VfZm9ybWF0IH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqLCB7XG4gICAgJGJyYW5kOiB7XG4gICAgICB2YWx1ZTogJ2F1dG8tcGFyc2VhYmxlLXJlc3BvbnNlLWZvcm1hdCcsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgICRwYXJzZVJhdzoge1xuICAgICAgdmFsdWU6IHBhcnNlcixcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0sXG4gIH0pO1xuXG4gIHJldHVybiBvYmogYXMgQXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0PFBhcnNlZFQ+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRvUGFyc2FibGVSZXNwb25zZUZvcm1hdDxQYXJzZWRUPihcbiAgcmVzcG9uc2VfZm9ybWF0OiBhbnksXG4pOiByZXNwb25zZV9mb3JtYXQgaXMgQXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0PFBhcnNlZFQ+IHtcbiAgcmV0dXJuIHJlc3BvbnNlX2Zvcm1hdD8uWyckYnJhbmQnXSA9PT0gJ2F1dG8tcGFyc2VhYmxlLXJlc3BvbnNlLWZvcm1hdCc7XG59XG5cbnR5cGUgVG9vbE9wdGlvbnMgPSB7XG4gIG5hbWU6IHN0cmluZztcbiAgYXJndW1lbnRzOiBhbnk7XG4gIGZ1bmN0aW9uPzogKChhcmdzOiBhbnkpID0+IGFueSkgfCB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgdHlwZSBBdXRvUGFyc2VhYmxlVG9vbDxcbiAgT3B0aW9uc1QgZXh0ZW5kcyBUb29sT3B0aW9ucyxcbiAgSGFzRnVuY3Rpb24gPSBPcHRpb25zVFsnZnVuY3Rpb24nXSBleHRlbmRzIEZ1bmN0aW9uID8gdHJ1ZSA6IGZhbHNlLFxuPiA9IENoYXRDb21wbGV0aW9uVG9vbCAmIHtcbiAgX19hcmd1bWVudHM6IE9wdGlvbnNUWydhcmd1bWVudHMnXTsgLy8gdHlwZS1sZXZlbCBvbmx5XG4gIF9fbmFtZTogT3B0aW9uc1RbJ25hbWUnXTsgLy8gdHlwZS1sZXZlbCBvbmx5XG4gIF9faGFzRnVuY3Rpb246IEhhc0Z1bmN0aW9uOyAvLyB0eXBlLWxldmVsIG9ubHlcblxuICAkYnJhbmQ6ICdhdXRvLXBhcnNlYWJsZS10b29sJztcbiAgJGNhbGxiYWNrOiAoKGFyZ3M6IE9wdGlvbnNUWydhcmd1bWVudHMnXSkgPT4gYW55KSB8IHVuZGVmaW5lZDtcbiAgJHBhcnNlUmF3KGFyZ3M6IHN0cmluZyk6IE9wdGlvbnNUWydhcmd1bWVudHMnXTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUGFyc2VhYmxlVG9vbDxPcHRpb25zVCBleHRlbmRzIFRvb2xPcHRpb25zPihcbiAgdG9vbDogQ2hhdENvbXBsZXRpb25Ub29sLFxuICB7XG4gICAgcGFyc2VyLFxuICAgIGNhbGxiYWNrLFxuICB9OiB7XG4gICAgcGFyc2VyOiAoY29udGVudDogc3RyaW5nKSA9PiBPcHRpb25zVFsnYXJndW1lbnRzJ107XG4gICAgY2FsbGJhY2s6ICgoYXJnczogYW55KSA9PiBhbnkpIHwgdW5kZWZpbmVkO1xuICB9LFxuKTogQXV0b1BhcnNlYWJsZVRvb2w8T3B0aW9uc1RbJ2FyZ3VtZW50cyddPiB7XG4gIGNvbnN0IG9iaiA9IHsgLi4udG9vbCB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iaiwge1xuICAgICRicmFuZDoge1xuICAgICAgdmFsdWU6ICdhdXRvLXBhcnNlYWJsZS10b29sJyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgJHBhcnNlUmF3OiB7XG4gICAgICB2YWx1ZTogcGFyc2VyLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICAkY2FsbGJhY2s6IHtcbiAgICAgIHZhbHVlOiBjYWxsYmFjayxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0sXG4gIH0pO1xuXG4gIHJldHVybiBvYmogYXMgQXV0b1BhcnNlYWJsZVRvb2w8T3B0aW9uc1RbJ2FyZ3VtZW50cyddPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0b1BhcnNhYmxlVG9vbCh0b29sOiBhbnkpOiB0b29sIGlzIEF1dG9QYXJzZWFibGVUb29sPGFueT4ge1xuICByZXR1cm4gdG9vbD8uWyckYnJhbmQnXSA9PT0gJ2F1dG8tcGFyc2VhYmxlLXRvb2wnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVQYXJzZUNoYXRDb21wbGV0aW9uPFxuICBQYXJhbXMgZXh0ZW5kcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyB8IG51bGwsXG4gIFBhcnNlZFQgPSBQYXJhbXMgZXh0ZW5kcyBudWxsID8gbnVsbCA6IEV4dHJhY3RQYXJzZWRDb250ZW50RnJvbVBhcmFtczxOb25OdWxsYWJsZTxQYXJhbXM+Pixcbj4oY29tcGxldGlvbjogQ2hhdENvbXBsZXRpb24sIHBhcmFtczogUGFyYW1zKTogUGFyc2VkQ2hhdENvbXBsZXRpb248UGFyc2VkVD4ge1xuICBpZiAoIXBhcmFtcyB8fCAhaGFzQXV0b1BhcnNlYWJsZUlucHV0KHBhcmFtcykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29tcGxldGlvbixcbiAgICAgIGNob2ljZXM6IGNvbXBsZXRpb24uY2hvaWNlcy5tYXAoKGNob2ljZSkgPT4gKHtcbiAgICAgICAgLi4uY2hvaWNlLFxuICAgICAgICBtZXNzYWdlOiB7IC4uLmNob2ljZS5tZXNzYWdlLCBwYXJzZWQ6IG51bGwsIHRvb2xfY2FsbHM6IGNob2ljZS5tZXNzYWdlLnRvb2xfY2FsbHMgPz8gW10gfSxcbiAgICAgIH0pKSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlQ2hhdENvbXBsZXRpb24oY29tcGxldGlvbiwgcGFyYW1zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ2hhdENvbXBsZXRpb248XG4gIFBhcmFtcyBleHRlbmRzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICBQYXJzZWRUID0gRXh0cmFjdFBhcnNlZENvbnRlbnRGcm9tUGFyYW1zPFBhcmFtcz4sXG4+KGNvbXBsZXRpb246IENoYXRDb21wbGV0aW9uLCBwYXJhbXM6IFBhcmFtcyk6IFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+IHtcbiAgY29uc3QgY2hvaWNlczogQXJyYXk8UGFyc2VkQ2hvaWNlPFBhcnNlZFQ+PiA9IGNvbXBsZXRpb24uY2hvaWNlcy5tYXAoKGNob2ljZSk6IFBhcnNlZENob2ljZTxQYXJzZWRUPiA9PiB7XG4gICAgaWYgKGNob2ljZS5maW5pc2hfcmVhc29uID09PSAnbGVuZ3RoJykge1xuICAgICAgdGhyb3cgbmV3IExlbmd0aEZpbmlzaFJlYXNvbkVycm9yKCk7XG4gICAgfVxuXG4gICAgaWYgKGNob2ljZS5maW5pc2hfcmVhc29uID09PSAnY29udGVudF9maWx0ZXInKSB7XG4gICAgICB0aHJvdyBuZXcgQ29udGVudEZpbHRlckZpbmlzaFJlYXNvbkVycm9yKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNob2ljZSxcbiAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgLi4uY2hvaWNlLm1lc3NhZ2UsXG4gICAgICAgIHRvb2xfY2FsbHM6IGNob2ljZS5tZXNzYWdlLnRvb2xfY2FsbHM/Lm1hcCgodG9vbENhbGwpID0+IHBhcnNlVG9vbENhbGwocGFyYW1zLCB0b29sQ2FsbCkpID8/IFtdLFxuICAgICAgICBwYXJzZWQ6XG4gICAgICAgICAgY2hvaWNlLm1lc3NhZ2UuY29udGVudCAmJiAhY2hvaWNlLm1lc3NhZ2UucmVmdXNhbCA/XG4gICAgICAgICAgICBwYXJzZVJlc3BvbnNlRm9ybWF0KHBhcmFtcywgY2hvaWNlLm1lc3NhZ2UuY29udGVudClcbiAgICAgICAgICA6IG51bGwsXG4gICAgICB9LFxuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiB7IC4uLmNvbXBsZXRpb24sIGNob2ljZXMgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VSZXNwb25zZUZvcm1hdDxcbiAgUGFyYW1zIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gIFBhcnNlZFQgPSBFeHRyYWN0UGFyc2VkQ29udGVudEZyb21QYXJhbXM8UGFyYW1zPixcbj4ocGFyYW1zOiBQYXJhbXMsIGNvbnRlbnQ6IHN0cmluZyk6IFBhcnNlZFQgfCBudWxsIHtcbiAgaWYgKHBhcmFtcy5yZXNwb25zZV9mb3JtYXQ/LnR5cGUgIT09ICdqc29uX3NjaGVtYScpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChwYXJhbXMucmVzcG9uc2VfZm9ybWF0Py50eXBlID09PSAnanNvbl9zY2hlbWEnKSB7XG4gICAgaWYgKCckcGFyc2VSYXcnIGluIHBhcmFtcy5yZXNwb25zZV9mb3JtYXQpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlX2Zvcm1hdCA9IHBhcmFtcy5yZXNwb25zZV9mb3JtYXQgYXMgQXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0PFBhcnNlZFQ+O1xuXG4gICAgICByZXR1cm4gcmVzcG9uc2VfZm9ybWF0LiRwYXJzZVJhdyhjb250ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gSlNPTi5wYXJzZShjb250ZW50KTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRvb2xDYWxsPFBhcmFtcyBleHRlbmRzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zPihcbiAgcGFyYW1zOiBQYXJhbXMsXG4gIHRvb2xDYWxsOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCxcbik6IFBhcnNlZEZ1bmN0aW9uVG9vbENhbGwge1xuICBjb25zdCBpbnB1dFRvb2wgPSBwYXJhbXMudG9vbHM/LmZpbmQoKGlucHV0VG9vbCkgPT4gaW5wdXRUb29sLmZ1bmN0aW9uPy5uYW1lID09PSB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lKTtcbiAgcmV0dXJuIHtcbiAgICAuLi50b29sQ2FsbCxcbiAgICBmdW5jdGlvbjoge1xuICAgICAgLi4udG9vbENhbGwuZnVuY3Rpb24sXG4gICAgICBwYXJzZWRfYXJndW1lbnRzOlxuICAgICAgICBpc0F1dG9QYXJzYWJsZVRvb2woaW5wdXRUb29sKSA/IGlucHV0VG9vbC4kcGFyc2VSYXcodG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKVxuICAgICAgICA6IGlucHV0VG9vbD8uZnVuY3Rpb24uc3RyaWN0ID8gSlNPTi5wYXJzZSh0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMpXG4gICAgICAgIDogbnVsbCxcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkUGFyc2VUb29sQ2FsbChcbiAgcGFyYW1zOiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyB8IG51bGwgfCB1bmRlZmluZWQsXG4gIHRvb2xDYWxsOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCxcbik6IGJvb2xlYW4ge1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0VG9vbCA9IHBhcmFtcy50b29scz8uZmluZCgoaW5wdXRUb29sKSA9PiBpbnB1dFRvb2wuZnVuY3Rpb24/Lm5hbWUgPT09IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUpO1xuICByZXR1cm4gaXNBdXRvUGFyc2FibGVUb29sKGlucHV0VG9vbCkgfHwgaW5wdXRUb29sPy5mdW5jdGlvbi5zdHJpY3QgfHwgZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNBdXRvUGFyc2VhYmxlSW5wdXQocGFyYW1zOiBBbnlDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyk6IGJvb2xlYW4ge1xuICBpZiAoaXNBdXRvUGFyc2FibGVSZXNwb25zZUZvcm1hdChwYXJhbXMucmVzcG9uc2VfZm9ybWF0KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBwYXJhbXMudG9vbHM/LnNvbWUoXG4gICAgICAodCkgPT4gaXNBdXRvUGFyc2FibGVUb29sKHQpIHx8ICh0LnR5cGUgPT09ICdmdW5jdGlvbicgJiYgdC5mdW5jdGlvbi5zdHJpY3QgPT09IHRydWUpLFxuICAgICkgPz8gZmFsc2VcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlSW5wdXRUb29scyh0b29sczogQ2hhdENvbXBsZXRpb25Ub29sW10gfCB1bmRlZmluZWQpIHtcbiAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xzID8/IFtdKSB7XG4gICAgaWYgKHRvb2wudHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICBgQ3VycmVudGx5IG9ubHkgXFxgZnVuY3Rpb25cXGAgdG9vbCB0eXBlcyBzdXBwb3J0IGF1dG8tcGFyc2luZzsgUmVjZWl2ZWQgXFxgJHt0b29sLnR5cGV9XFxgYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRvb2wuZnVuY3Rpb24uc3RyaWN0ICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoXG4gICAgICAgIGBUaGUgXFxgJHt0b29sLmZ1bmN0aW9uLm5hbWV9XFxgIHRvb2wgaXMgbm90IG1hcmtlZCB3aXRoIFxcYHN0cmljdDogdHJ1ZVxcYC4gT25seSBzdHJpY3QgZnVuY3Rpb24gdG9vbHMgY2FuIGJlIGF1dG8tcGFyc2VkYCxcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7IHR5cGUgQ29tcGxldGlvblVzYWdlIH0gZnJvbSAnLi4vcmVzb3VyY2VzL2NvbXBsZXRpb25zJztcbmltcG9ydCB7XG4gIHR5cGUgQ2hhdENvbXBsZXRpb24sXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlLFxuICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtLFxuICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICB0eXBlIENoYXRDb21wbGV0aW9uVG9vbCxcbn0gZnJvbSAnLi4vcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMnO1xuaW1wb3J0IHsgT3BlbkFJRXJyb3IgfSBmcm9tICcuLi9lcnJvcic7XG5pbXBvcnQge1xuICB0eXBlIFJ1bm5hYmxlRnVuY3Rpb24sXG4gIGlzUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZSxcbiAgdHlwZSBCYXNlRnVuY3Rpb25zQXJncyxcbiAgUnVubmFibGVUb29sRnVuY3Rpb24sXG59IGZyb20gJy4vUnVubmFibGVGdW5jdGlvbic7XG5pbXBvcnQgeyBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uUnVubmVyUGFyYW1zLCBDaGF0Q29tcGxldGlvblRvb2xSdW5uZXJQYXJhbXMgfSBmcm9tICcuL0NoYXRDb21wbGV0aW9uUnVubmVyJztcbmltcG9ydCB7XG4gIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nRnVuY3Rpb25SdW5uZXJQYXJhbXMsXG4gIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nVG9vbFJ1bm5lclBhcmFtcyxcbn0gZnJvbSAnLi9DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcic7XG5pbXBvcnQgeyBpc0Fzc2lzdGFudE1lc3NhZ2UsIGlzRnVuY3Rpb25NZXNzYWdlLCBpc1Rvb2xNZXNzYWdlIH0gZnJvbSAnLi9jaGF0Q29tcGxldGlvblV0aWxzJztcbmltcG9ydCB7IEJhc2VFdmVudHMsIEV2ZW50U3RyZWFtIH0gZnJvbSAnLi9FdmVudFN0cmVhbSc7XG5pbXBvcnQgeyBQYXJzZWRDaGF0Q29tcGxldGlvbiB9IGZyb20gJy4uL3Jlc291cmNlcy9iZXRhL2NoYXQvY29tcGxldGlvbnMnO1xuaW1wb3J0IE9wZW5BSSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyBpc0F1dG9QYXJzYWJsZVRvb2wsIHBhcnNlQ2hhdENvbXBsZXRpb24gfSBmcm9tICcuLi9saWIvcGFyc2VyJztcblxuY29uc3QgREVGQVVMVF9NQVhfQ0hBVF9DT01QTEVUSU9OUyA9IDEwO1xuZXhwb3J0IGludGVyZmFjZSBSdW5uZXJPcHRpb25zIGV4dGVuZHMgQ29yZS5SZXF1ZXN0T3B0aW9ucyB7XG4gIC8qKiBIb3cgbWFueSByZXF1ZXN0cyB0byBtYWtlIGJlZm9yZSBjYW5jZWxpbmcuIERlZmF1bHQgMTAuICovXG4gIG1heENoYXRDb21wbGV0aW9ucz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXI8XG4gIEV2ZW50VHlwZXMgZXh0ZW5kcyBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzLFxuICBQYXJzZWRULFxuPiBleHRlbmRzIEV2ZW50U3RyZWFtPEV2ZW50VHlwZXM+IHtcbiAgcHJvdGVjdGVkIF9jaGF0Q29tcGxldGlvbnM6IFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+W10gPSBbXTtcbiAgbWVzc2FnZXM6IENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtW10gPSBbXTtcblxuICBwcm90ZWN0ZWQgX2FkZENoYXRDb21wbGV0aW9uKFxuICAgIHRoaXM6IEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXI8QWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cywgUGFyc2VkVD4sXG4gICAgY2hhdENvbXBsZXRpb246IFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+LFxuICApOiBQYXJzZWRDaGF0Q29tcGxldGlvbjxQYXJzZWRUPiB7XG4gICAgdGhpcy5fY2hhdENvbXBsZXRpb25zLnB1c2goY2hhdENvbXBsZXRpb24pO1xuICAgIHRoaXMuX2VtaXQoJ2NoYXRDb21wbGV0aW9uJywgY2hhdENvbXBsZXRpb24pO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjaGF0Q29tcGxldGlvbi5jaG9pY2VzWzBdPy5tZXNzYWdlO1xuICAgIGlmIChtZXNzYWdlKSB0aGlzLl9hZGRNZXNzYWdlKG1lc3NhZ2UgYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0pO1xuICAgIHJldHVybiBjaGF0Q29tcGxldGlvbjtcbiAgfVxuXG4gIHByb3RlY3RlZCBfYWRkTWVzc2FnZShcbiAgICB0aGlzOiBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyPEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMsIFBhcnNlZFQ+LFxuICAgIG1lc3NhZ2U6IENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtLFxuICAgIGVtaXQgPSB0cnVlLFxuICApIHtcbiAgICBpZiAoISgnY29udGVudCcgaW4gbWVzc2FnZSkpIG1lc3NhZ2UuY29udGVudCA9IG51bGw7XG5cbiAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG5cbiAgICBpZiAoZW1pdCkge1xuICAgICAgdGhpcy5fZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgaWYgKChpc0Z1bmN0aW9uTWVzc2FnZShtZXNzYWdlKSB8fCBpc1Rvb2xNZXNzYWdlKG1lc3NhZ2UpKSAmJiBtZXNzYWdlLmNvbnRlbnQpIHtcbiAgICAgICAgLy8gTm90ZSwgdGhpcyBhc3N1bWVzIHRoYXQge3JvbGU6ICd0b29sJywgY29udGVudDogXHUyMDI2fSBpcyBhbHdheXMgdGhlIHJlc3VsdCBvZiBhIGNhbGwgb2YgdG9vbCBvZiB0eXBlPWZ1bmN0aW9uLlxuICAgICAgICB0aGlzLl9lbWl0KCdmdW5jdGlvbkNhbGxSZXN1bHQnLCBtZXNzYWdlLmNvbnRlbnQgYXMgc3RyaW5nKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBc3Npc3RhbnRNZXNzYWdlKG1lc3NhZ2UpICYmIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCkge1xuICAgICAgICB0aGlzLl9lbWl0KCdmdW5jdGlvbkNhbGwnLCBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwpO1xuICAgICAgfSBlbHNlIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2UobWVzc2FnZSkgJiYgbWVzc2FnZS50b29sX2NhbGxzKSB7XG4gICAgICAgIGZvciAoY29uc3QgdG9vbF9jYWxsIG9mIG1lc3NhZ2UudG9vbF9jYWxscykge1xuICAgICAgICAgIGlmICh0b29sX2NhbGwudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fZW1pdCgnZnVuY3Rpb25DYWxsJywgdG9vbF9jYWxsLmZ1bmN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZmluYWwgQ2hhdENvbXBsZXRpb24sIG9yIHJlamVjdHNcbiAgICogaWYgYW4gZXJyb3Igb2NjdXJyZWQgb3IgdGhlIHN0cmVhbSBlbmRlZCBwcmVtYXR1cmVseSB3aXRob3V0IHByb2R1Y2luZyBhIENoYXRDb21wbGV0aW9uLlxuICAgKi9cbiAgYXN5bmMgZmluYWxDaGF0Q29tcGxldGlvbigpOiBQcm9taXNlPFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+PiB7XG4gICAgYXdhaXQgdGhpcy5kb25lKCk7XG4gICAgY29uc3QgY29tcGxldGlvbiA9IHRoaXMuX2NoYXRDb21wbGV0aW9uc1t0aGlzLl9jaGF0Q29tcGxldGlvbnMubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFjb21wbGV0aW9uKSB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoJ3N0cmVhbSBlbmRlZCB3aXRob3V0IHByb2R1Y2luZyBhIENoYXRDb21wbGV0aW9uJyk7XG4gICAgcmV0dXJuIGNvbXBsZXRpb247XG4gIH1cblxuICAjZ2V0RmluYWxDb250ZW50KCk6IHN0cmluZyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLiNnZXRGaW5hbE1lc3NhZ2UoKS5jb250ZW50ID8/IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY29udGVudCBvZiB0aGUgZmluYWwgQ2hhdENvbXBsZXRpb25NZXNzYWdlLCBvciByZWplY3RzXG4gICAqIGlmIGFuIGVycm9yIG9jY3VycmVkIG9yIHRoZSBzdHJlYW0gZW5kZWQgcHJlbWF0dXJlbHkgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbk1lc3NhZ2UuXG4gICAqL1xuICBhc3luYyBmaW5hbENvbnRlbnQoKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gICAgYXdhaXQgdGhpcy5kb25lKCk7XG4gICAgcmV0dXJuIHRoaXMuI2dldEZpbmFsQ29udGVudCgpO1xuICB9XG5cbiAgI2dldEZpbmFsTWVzc2FnZSgpOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2Uge1xuICAgIGxldCBpID0gdGhpcy5tZXNzYWdlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW2ldO1xuICAgICAgaWYgKGlzQXNzaXN0YW50TWVzc2FnZShtZXNzYWdlKSkge1xuICAgICAgICBjb25zdCB7IGZ1bmN0aW9uX2NhbGwsIC4uLnJlc3QgfSA9IG1lc3NhZ2U7XG5cbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBhdWRpbyBoZXJlXG4gICAgICAgIGNvbnN0IHJldDogT21pdDxDaGF0Q29tcGxldGlvbk1lc3NhZ2UsICdhdWRpbyc+ID0ge1xuICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgY29udGVudDogKG1lc3NhZ2UgYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlKS5jb250ZW50ID8/IG51bGwsXG4gICAgICAgICAgcmVmdXNhbDogKG1lc3NhZ2UgYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlKS5yZWZ1c2FsID8/IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmdW5jdGlvbl9jYWxsKSB7XG4gICAgICAgICAgcmV0LmZ1bmN0aW9uX2NhbGwgPSBmdW5jdGlvbl9jYWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcignc3RyZWFtIGVuZGVkIHdpdGhvdXQgcHJvZHVjaW5nIGEgQ2hhdENvbXBsZXRpb25NZXNzYWdlIHdpdGggcm9sZT1hc3Npc3RhbnQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSB0aGUgZmluYWwgYXNzaXN0YW50IENoYXRDb21wbGV0aW9uTWVzc2FnZSByZXNwb25zZSxcbiAgICogb3IgcmVqZWN0cyBpZiBhbiBlcnJvciBvY2N1cnJlZCBvciB0aGUgc3RyZWFtIGVuZGVkIHByZW1hdHVyZWx5IHdpdGhvdXQgcHJvZHVjaW5nIGEgQ2hhdENvbXBsZXRpb25NZXNzYWdlLlxuICAgKi9cbiAgYXN5bmMgZmluYWxNZXNzYWdlKCk6IFByb21pc2U8Q2hhdENvbXBsZXRpb25NZXNzYWdlPiB7XG4gICAgYXdhaXQgdGhpcy5kb25lKCk7XG4gICAgcmV0dXJuIHRoaXMuI2dldEZpbmFsTWVzc2FnZSgpO1xuICB9XG5cbiAgI2dldEZpbmFsRnVuY3Rpb25DYWxsKCk6IENoYXRDb21wbGV0aW9uTWVzc2FnZS5GdW5jdGlvbkNhbGwgfCB1bmRlZmluZWQge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLm1lc3NhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlc1tpXTtcbiAgICAgIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2UobWVzc2FnZSkgJiYgbWVzc2FnZT8uZnVuY3Rpb25fY2FsbCkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXNzaXN0YW50TWVzc2FnZShtZXNzYWdlKSAmJiBtZXNzYWdlPy50b29sX2NhbGxzPy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UudG9vbF9jYWxscy5hdCgtMSk/LmZ1bmN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBjb250ZW50IG9mIHRoZSBmaW5hbCBGdW5jdGlvbkNhbGwsIG9yIHJlamVjdHNcbiAgICogaWYgYW4gZXJyb3Igb2NjdXJyZWQgb3IgdGhlIHN0cmVhbSBlbmRlZCBwcmVtYXR1cmVseSB3aXRob3V0IHByb2R1Y2luZyBhIENoYXRDb21wbGV0aW9uTWVzc2FnZS5cbiAgICovXG4gIGFzeW5jIGZpbmFsRnVuY3Rpb25DYWxsKCk6IFByb21pc2U8Q2hhdENvbXBsZXRpb25NZXNzYWdlLkZ1bmN0aW9uQ2FsbCB8IHVuZGVmaW5lZD4ge1xuICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgIHJldHVybiB0aGlzLiNnZXRGaW5hbEZ1bmN0aW9uQ2FsbCgpO1xuICB9XG5cbiAgI2dldEZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0KCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMubWVzc2FnZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW2ldO1xuICAgICAgaWYgKGlzRnVuY3Rpb25NZXNzYWdlKG1lc3NhZ2UpICYmIG1lc3NhZ2UuY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGlzVG9vbE1lc3NhZ2UobWVzc2FnZSkgJiZcbiAgICAgICAgbWVzc2FnZS5jb250ZW50ICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5zb21lKFxuICAgICAgICAgICh4KSA9PlxuICAgICAgICAgICAgeC5yb2xlID09PSAnYXNzaXN0YW50JyAmJlxuICAgICAgICAgICAgeC50b29sX2NhbGxzPy5zb21lKCh5KSA9PiB5LnR5cGUgPT09ICdmdW5jdGlvbicgJiYgeS5pZCA9PT0gbWVzc2FnZS50b29sX2NhbGxfaWQpLFxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UuY29udGVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBhc3luYyBmaW5hbEZ1bmN0aW9uQ2FsbFJlc3VsdCgpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgIHJldHVybiB0aGlzLiNnZXRGaW5hbEZ1bmN0aW9uQ2FsbFJlc3VsdCgpO1xuICB9XG5cbiAgI2NhbGN1bGF0ZVRvdGFsVXNhZ2UoKTogQ29tcGxldGlvblVzYWdlIHtcbiAgICBjb25zdCB0b3RhbDogQ29tcGxldGlvblVzYWdlID0ge1xuICAgICAgY29tcGxldGlvbl90b2tlbnM6IDAsXG4gICAgICBwcm9tcHRfdG9rZW5zOiAwLFxuICAgICAgdG90YWxfdG9rZW5zOiAwLFxuICAgIH07XG4gICAgZm9yIChjb25zdCB7IHVzYWdlIH0gb2YgdGhpcy5fY2hhdENvbXBsZXRpb25zKSB7XG4gICAgICBpZiAodXNhZ2UpIHtcbiAgICAgICAgdG90YWwuY29tcGxldGlvbl90b2tlbnMgKz0gdXNhZ2UuY29tcGxldGlvbl90b2tlbnM7XG4gICAgICAgIHRvdGFsLnByb21wdF90b2tlbnMgKz0gdXNhZ2UucHJvbXB0X3Rva2VucztcbiAgICAgICAgdG90YWwudG90YWxfdG9rZW5zICs9IHVzYWdlLnRvdGFsX3Rva2VucztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG5cbiAgYXN5bmMgdG90YWxVc2FnZSgpOiBQcm9taXNlPENvbXBsZXRpb25Vc2FnZT4ge1xuICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgIHJldHVybiB0aGlzLiNjYWxjdWxhdGVUb3RhbFVzYWdlKCk7XG4gIH1cblxuICBhbGxDaGF0Q29tcGxldGlvbnMoKTogQ2hhdENvbXBsZXRpb25bXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9jaGF0Q29tcGxldGlvbnNdO1xuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIF9lbWl0RmluYWwoXG4gICAgdGhpczogQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcjxBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzLCBQYXJzZWRUPixcbiAgKSB7XG4gICAgY29uc3QgY29tcGxldGlvbiA9IHRoaXMuX2NoYXRDb21wbGV0aW9uc1t0aGlzLl9jaGF0Q29tcGxldGlvbnMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGNvbXBsZXRpb24pIHRoaXMuX2VtaXQoJ2ZpbmFsQ2hhdENvbXBsZXRpb24nLCBjb21wbGV0aW9uKTtcbiAgICBjb25zdCBmaW5hbE1lc3NhZ2UgPSB0aGlzLiNnZXRGaW5hbE1lc3NhZ2UoKTtcbiAgICBpZiAoZmluYWxNZXNzYWdlKSB0aGlzLl9lbWl0KCdmaW5hbE1lc3NhZ2UnLCBmaW5hbE1lc3NhZ2UpO1xuICAgIGNvbnN0IGZpbmFsQ29udGVudCA9IHRoaXMuI2dldEZpbmFsQ29udGVudCgpO1xuICAgIGlmIChmaW5hbENvbnRlbnQpIHRoaXMuX2VtaXQoJ2ZpbmFsQ29udGVudCcsIGZpbmFsQ29udGVudCk7XG5cbiAgICBjb25zdCBmaW5hbEZ1bmN0aW9uQ2FsbCA9IHRoaXMuI2dldEZpbmFsRnVuY3Rpb25DYWxsKCk7XG4gICAgaWYgKGZpbmFsRnVuY3Rpb25DYWxsKSB0aGlzLl9lbWl0KCdmaW5hbEZ1bmN0aW9uQ2FsbCcsIGZpbmFsRnVuY3Rpb25DYWxsKTtcblxuICAgIGNvbnN0IGZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0ID0gdGhpcy4jZ2V0RmluYWxGdW5jdGlvbkNhbGxSZXN1bHQoKTtcbiAgICBpZiAoZmluYWxGdW5jdGlvbkNhbGxSZXN1bHQgIT0gbnVsbCkgdGhpcy5fZW1pdCgnZmluYWxGdW5jdGlvbkNhbGxSZXN1bHQnLCBmaW5hbEZ1bmN0aW9uQ2FsbFJlc3VsdCk7XG5cbiAgICBpZiAodGhpcy5fY2hhdENvbXBsZXRpb25zLnNvbWUoKGMpID0+IGMudXNhZ2UpKSB7XG4gICAgICB0aGlzLl9lbWl0KCd0b3RhbFVzYWdlJywgdGhpcy4jY2FsY3VsYXRlVG90YWxVc2FnZSgpKTtcbiAgICB9XG4gIH1cblxuICAjdmFsaWRhdGVQYXJhbXMocGFyYW1zOiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyk6IHZvaWQge1xuICAgIGlmIChwYXJhbXMubiAhPSBudWxsICYmIHBhcmFtcy5uID4gMSkge1xuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICAnQ2hhdENvbXBsZXRpb24gY29udmVuaWVuY2UgaGVscGVycyBvbmx5IHN1cHBvcnQgbj0xIGF0IHRoaXMgdGltZS4gVG8gdXNlIG4+MSwgcGxlYXNlIHVzZSBjaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSgpIGRpcmVjdGx5LicsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfY3JlYXRlQ2hhdENvbXBsZXRpb24oXG4gICAgY2xpZW50OiBPcGVuQUksXG4gICAgcGFyYW1zOiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxQYXJzZWRDaGF0Q29tcGxldGlvbjxQYXJzZWRUPj4ge1xuICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbDtcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gdGhpcy5jb250cm9sbGVyLmFib3J0KCkpO1xuICAgIH1cbiAgICB0aGlzLiN2YWxpZGF0ZVBhcmFtcyhwYXJhbXMpO1xuXG4gICAgY29uc3QgY2hhdENvbXBsZXRpb24gPSBhd2FpdCBjbGllbnQuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoXG4gICAgICB7IC4uLnBhcmFtcywgc3RyZWFtOiBmYWxzZSB9LFxuICAgICAgeyAuLi5vcHRpb25zLCBzaWduYWw6IHRoaXMuY29udHJvbGxlci5zaWduYWwgfSxcbiAgICApO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCgpO1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGF0Q29tcGxldGlvbihwYXJzZUNoYXRDb21wbGV0aW9uKGNoYXRDb21wbGV0aW9uLCBwYXJhbXMpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfcnVuQ2hhdENvbXBsZXRpb24oXG4gICAgY2xpZW50OiBPcGVuQUksXG4gICAgcGFyYW1zOiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxDaGF0Q29tcGxldGlvbj4ge1xuICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwYXJhbXMubWVzc2FnZXMpIHtcbiAgICAgIHRoaXMuX2FkZE1lc3NhZ2UobWVzc2FnZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fY3JlYXRlQ2hhdENvbXBsZXRpb24oY2xpZW50LCBwYXJhbXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9ydW5GdW5jdGlvbnM8RnVuY3Rpb25zQXJncyBleHRlbmRzIEJhc2VGdW5jdGlvbnNBcmdzPihcbiAgICBjbGllbnQ6IE9wZW5BSSxcbiAgICBwYXJhbXM6XG4gICAgICB8IENoYXRDb21wbGV0aW9uRnVuY3Rpb25SdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncz5cbiAgICAgIHwgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdGdW5jdGlvblJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzPixcbiAgICBvcHRpb25zPzogUnVubmVyT3B0aW9ucyxcbiAgKSB7XG4gICAgY29uc3Qgcm9sZSA9ICdmdW5jdGlvbicgYXMgY29uc3Q7XG4gICAgY29uc3QgeyBmdW5jdGlvbl9jYWxsID0gJ2F1dG8nLCBzdHJlYW0sIC4uLnJlc3RQYXJhbXMgfSA9IHBhcmFtcztcbiAgICBjb25zdCBzaW5nbGVGdW5jdGlvblRvQ2FsbCA9IHR5cGVvZiBmdW5jdGlvbl9jYWxsICE9PSAnc3RyaW5nJyAmJiBmdW5jdGlvbl9jYWxsPy5uYW1lO1xuICAgIGNvbnN0IHsgbWF4Q2hhdENvbXBsZXRpb25zID0gREVGQVVMVF9NQVhfQ0hBVF9DT01QTEVUSU9OUyB9ID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGNvbnN0IGZ1bmN0aW9uc0J5TmFtZTogUmVjb3JkPHN0cmluZywgUnVubmFibGVGdW5jdGlvbjxhbnk+PiA9IHt9O1xuICAgIGZvciAoY29uc3QgZiBvZiBwYXJhbXMuZnVuY3Rpb25zKSB7XG4gICAgICBmdW5jdGlvbnNCeU5hbWVbZi5uYW1lIHx8IGYuZnVuY3Rpb24ubmFtZV0gPSBmO1xuICAgIH1cblxuICAgIGNvbnN0IGZ1bmN0aW9uczogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMuRnVuY3Rpb25bXSA9IHBhcmFtcy5mdW5jdGlvbnMubWFwKFxuICAgICAgKGYpOiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcy5GdW5jdGlvbiA9PiAoe1xuICAgICAgICBuYW1lOiBmLm5hbWUgfHwgZi5mdW5jdGlvbi5uYW1lLFxuICAgICAgICBwYXJhbWV0ZXJzOiBmLnBhcmFtZXRlcnMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBmLmRlc2NyaXB0aW9uLFxuICAgICAgfSksXG4gICAgKTtcblxuICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwYXJhbXMubWVzc2FnZXMpIHtcbiAgICAgIHRoaXMuX2FkZE1lc3NhZ2UobWVzc2FnZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4Q2hhdENvbXBsZXRpb25zOyArK2kpIHtcbiAgICAgIGNvbnN0IGNoYXRDb21wbGV0aW9uOiBDaGF0Q29tcGxldGlvbiA9IGF3YWl0IHRoaXMuX2NyZWF0ZUNoYXRDb21wbGV0aW9uKFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5yZXN0UGFyYW1zLFxuICAgICAgICAgIGZ1bmN0aW9uX2NhbGwsXG4gICAgICAgICAgZnVuY3Rpb25zLFxuICAgICAgICAgIG1lc3NhZ2VzOiBbLi4udGhpcy5tZXNzYWdlc10sXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGNoYXRDb21wbGV0aW9uLmNob2ljZXNbMF0/Lm1lc3NhZ2U7XG4gICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIG1lc3NhZ2UgaW4gQ2hhdENvbXBsZXRpb24gcmVzcG9uc2VgKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWVzc2FnZS5mdW5jdGlvbl9jYWxsKSByZXR1cm47XG4gICAgICBjb25zdCB7IG5hbWUsIGFyZ3VtZW50czogYXJncyB9ID0gbWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgY29uc3QgZm4gPSBmdW5jdGlvbnNCeU5hbWVbbmFtZV07XG4gICAgICBpZiAoIWZuKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBgSW52YWxpZCBmdW5jdGlvbl9jYWxsOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfS4gQXZhaWxhYmxlIG9wdGlvbnMgYXJlOiAke2Z1bmN0aW9uc1xuICAgICAgICAgIC5tYXAoKGYpID0+IEpTT04uc3RyaW5naWZ5KGYubmFtZSkpXG4gICAgICAgICAgLmpvaW4oJywgJyl9LiBQbGVhc2UgdHJ5IGFnYWluYDtcblxuICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgbmFtZSwgY29udGVudCB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHNpbmdsZUZ1bmN0aW9uVG9DYWxsICYmIHNpbmdsZUZ1bmN0aW9uVG9DYWxsICE9PSBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBgSW52YWxpZCBmdW5jdGlvbl9jYWxsOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfS4gJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBzaW5nbGVGdW5jdGlvblRvQ2FsbCxcbiAgICAgICAgKX0gcmVxdWVzdGVkLiBQbGVhc2UgdHJ5IGFnYWluYDtcblxuICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgbmFtZSwgY29udGVudCB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBwYXJzZWQ7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWQgPSBpc1J1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2UoZm4pID8gYXdhaXQgZm4ucGFyc2UoYXJncykgOiBhcmdzO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7XG4gICAgICAgICAgcm9sZSxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGNvbnRlbnQ6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGl0IGNhbid0IHJ1bGUgb3V0IGBuZXZlcmAgdHlwZS5cbiAgICAgIGNvbnN0IHJhd0NvbnRlbnQgPSBhd2FpdCBmbi5mdW5jdGlvbihwYXJzZWQsIHRoaXMpO1xuICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuI3N0cmluZ2lmeUZ1bmN0aW9uQ2FsbFJlc3VsdChyYXdDb250ZW50KTtcblxuICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGUsIG5hbWUsIGNvbnRlbnQgfSk7XG5cbiAgICAgIGlmIChzaW5nbGVGdW5jdGlvblRvQ2FsbCkgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfcnVuVG9vbHM8RnVuY3Rpb25zQXJncyBleHRlbmRzIEJhc2VGdW5jdGlvbnNBcmdzPihcbiAgICBjbGllbnQ6IE9wZW5BSSxcbiAgICBwYXJhbXM6XG4gICAgICB8IENoYXRDb21wbGV0aW9uVG9vbFJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzPlxuICAgICAgfCBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1Rvb2xSdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncz4sXG4gICAgb3B0aW9ucz86IFJ1bm5lck9wdGlvbnMsXG4gICkge1xuICAgIGNvbnN0IHJvbGUgPSAndG9vbCcgYXMgY29uc3Q7XG4gICAgY29uc3QgeyB0b29sX2Nob2ljZSA9ICdhdXRvJywgc3RyZWFtLCAuLi5yZXN0UGFyYW1zIH0gPSBwYXJhbXM7XG4gICAgY29uc3Qgc2luZ2xlRnVuY3Rpb25Ub0NhbGwgPSB0eXBlb2YgdG9vbF9jaG9pY2UgIT09ICdzdHJpbmcnICYmIHRvb2xfY2hvaWNlPy5mdW5jdGlvbj8ubmFtZTtcbiAgICBjb25zdCB7IG1heENoYXRDb21wbGV0aW9ucyA9IERFRkFVTFRfTUFYX0NIQVRfQ09NUExFVElPTlMgfSA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBUT0RPKHNvbWVkYXkpOiBjbGVhbiB0aGlzIGxvZ2ljIHVwXG4gICAgY29uc3QgaW5wdXRUb29scyA9IHBhcmFtcy50b29scy5tYXAoKHRvb2wpOiBSdW5uYWJsZVRvb2xGdW5jdGlvbjxhbnk+ID0+IHtcbiAgICAgIGlmIChpc0F1dG9QYXJzYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgaWYgKCF0b29sLiRjYWxsYmFjaykge1xuICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcignVG9vbCBnaXZlbiB0byBgLnJ1blRvb2xzKClgIHRoYXQgZG9lcyBub3QgaGF2ZSBhbiBhc3NvY2lhdGVkIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uOiB0b29sLiRjYWxsYmFjayxcbiAgICAgICAgICAgIG5hbWU6IHRvb2wuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmZ1bmN0aW9uLmRlc2NyaXB0aW9uIHx8ICcnLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogdG9vbC5mdW5jdGlvbi5wYXJhbWV0ZXJzIGFzIGFueSxcbiAgICAgICAgICAgIHBhcnNlOiB0b29sLiRwYXJzZVJhdyxcbiAgICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9vbCBhcyBhbnkgYXMgUnVubmFibGVUb29sRnVuY3Rpb248YW55PjtcbiAgICB9KTtcblxuICAgIGNvbnN0IGZ1bmN0aW9uc0J5TmFtZTogUmVjb3JkPHN0cmluZywgUnVubmFibGVGdW5jdGlvbjxhbnk+PiA9IHt9O1xuICAgIGZvciAoY29uc3QgZiBvZiBpbnB1dFRvb2xzKSB7XG4gICAgICBpZiAoZi50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZ1bmN0aW9uc0J5TmFtZVtmLmZ1bmN0aW9uLm5hbWUgfHwgZi5mdW5jdGlvbi5mdW5jdGlvbi5uYW1lXSA9IGYuZnVuY3Rpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdG9vbHM6IENoYXRDb21wbGV0aW9uVG9vbFtdID1cbiAgICAgICd0b29scycgaW4gcGFyYW1zID9cbiAgICAgICAgaW5wdXRUb29scy5tYXAoKHQpID0+XG4gICAgICAgICAgdC50eXBlID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0LmZ1bmN0aW9uLm5hbWUgfHwgdC5mdW5jdGlvbi5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHQuZnVuY3Rpb24ucGFyYW1ldGVycyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdC5mdW5jdGlvbi5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzdHJpY3Q6IHQuZnVuY3Rpb24uc3RyaWN0LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogKHQgYXMgdW5rbm93biBhcyBDaGF0Q29tcGxldGlvblRvb2wpLFxuICAgICAgICApXG4gICAgICA6ICh1bmRlZmluZWQgYXMgYW55KTtcblxuICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwYXJhbXMubWVzc2FnZXMpIHtcbiAgICAgIHRoaXMuX2FkZE1lc3NhZ2UobWVzc2FnZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4Q2hhdENvbXBsZXRpb25zOyArK2kpIHtcbiAgICAgIGNvbnN0IGNoYXRDb21wbGV0aW9uOiBDaGF0Q29tcGxldGlvbiA9IGF3YWl0IHRoaXMuX2NyZWF0ZUNoYXRDb21wbGV0aW9uKFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5yZXN0UGFyYW1zLFxuICAgICAgICAgIHRvb2xfY2hvaWNlLFxuICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgIG1lc3NhZ2VzOiBbLi4udGhpcy5tZXNzYWdlc10sXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGNoYXRDb21wbGV0aW9uLmNob2ljZXNbMF0/Lm1lc3NhZ2U7XG4gICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIG1lc3NhZ2UgaW4gQ2hhdENvbXBsZXRpb24gcmVzcG9uc2VgKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWVzc2FnZS50b29sX2NhbGxzPy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHRvb2xfY2FsbCBvZiBtZXNzYWdlLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgaWYgKHRvb2xfY2FsbC50eXBlICE9PSAnZnVuY3Rpb24nKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdG9vbF9jYWxsX2lkID0gdG9vbF9jYWxsLmlkO1xuICAgICAgICBjb25zdCB7IG5hbWUsIGFyZ3VtZW50czogYXJncyB9ID0gdG9vbF9jYWxsLmZ1bmN0aW9uO1xuICAgICAgICBjb25zdCBmbiA9IGZ1bmN0aW9uc0J5TmFtZVtuYW1lXTtcblxuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGBJbnZhbGlkIHRvb2xfY2FsbDogJHtKU09OLnN0cmluZ2lmeShuYW1lKX0uIEF2YWlsYWJsZSBvcHRpb25zIGFyZTogJHtPYmplY3Qua2V5cyhcbiAgICAgICAgICAgIGZ1bmN0aW9uc0J5TmFtZSxcbiAgICAgICAgICApXG4gICAgICAgICAgICAubWFwKChuYW1lKSA9PiBKU09OLnN0cmluZ2lmeShuYW1lKSlcbiAgICAgICAgICAgIC5qb2luKCcsICcpfS4gUGxlYXNlIHRyeSBhZ2FpbmA7XG5cbiAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgdG9vbF9jYWxsX2lkLCBjb250ZW50IH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHNpbmdsZUZ1bmN0aW9uVG9DYWxsICYmIHNpbmdsZUZ1bmN0aW9uVG9DYWxsICE9PSBuYW1lKSB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGBJbnZhbGlkIHRvb2xfY2FsbDogJHtKU09OLnN0cmluZ2lmeShuYW1lKX0uICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBzaW5nbGVGdW5jdGlvblRvQ2FsbCxcbiAgICAgICAgICApfSByZXF1ZXN0ZWQuIFBsZWFzZSB0cnkgYWdhaW5gO1xuXG4gICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGUsIHRvb2xfY2FsbF9pZCwgY29udGVudCB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwYXJzZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFyc2VkID0gaXNSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlKGZuKSA/IGF3YWl0IGZuLnBhcnNlKGFyZ3MpIDogYXJncztcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zdCBjb250ZW50ID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoeyByb2xlLCB0b29sX2NhbGxfaWQsIGNvbnRlbnQgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGl0IGNhbid0IHJ1bGUgb3V0IGBuZXZlcmAgdHlwZS5cbiAgICAgICAgY29uc3QgcmF3Q29udGVudCA9IGF3YWl0IGZuLmZ1bmN0aW9uKHBhcnNlZCwgdGhpcyk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLiNzdHJpbmdpZnlGdW5jdGlvbkNhbGxSZXN1bHQocmF3Q29udGVudCk7XG4gICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoeyByb2xlLCB0b29sX2NhbGxfaWQsIGNvbnRlbnQgfSk7XG5cbiAgICAgICAgaWYgKHNpbmdsZUZ1bmN0aW9uVG9DYWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgI3N0cmluZ2lmeUZ1bmN0aW9uQ2FsbFJlc3VsdChyYXdDb250ZW50OiB1bmtub3duKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIHJhd0NvbnRlbnQgPT09ICdzdHJpbmcnID8gcmF3Q29udGVudFxuICAgICAgOiByYXdDb250ZW50ID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJ1xuICAgICAgOiBKU09OLnN0cmluZ2lmeShyYXdDb250ZW50KVxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzIGV4dGVuZHMgQmFzZUV2ZW50cyB7XG4gIGZ1bmN0aW9uQ2FsbDogKGZ1bmN0aW9uQ2FsbDogQ2hhdENvbXBsZXRpb25NZXNzYWdlLkZ1bmN0aW9uQ2FsbCkgPT4gdm9pZDtcbiAgbWVzc2FnZTogKG1lc3NhZ2U6IENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtKSA9PiB2b2lkO1xuICBjaGF0Q29tcGxldGlvbjogKGNvbXBsZXRpb246IENoYXRDb21wbGV0aW9uKSA9PiB2b2lkO1xuICBmaW5hbENvbnRlbnQ6IChjb250ZW50U25hcHNob3Q6IHN0cmluZykgPT4gdm9pZDtcbiAgZmluYWxNZXNzYWdlOiAobWVzc2FnZTogQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0pID0+IHZvaWQ7XG4gIGZpbmFsQ2hhdENvbXBsZXRpb246IChjb21wbGV0aW9uOiBDaGF0Q29tcGxldGlvbikgPT4gdm9pZDtcbiAgZmluYWxGdW5jdGlvbkNhbGw6IChmdW5jdGlvbkNhbGw6IENoYXRDb21wbGV0aW9uTWVzc2FnZS5GdW5jdGlvbkNhbGwpID0+IHZvaWQ7XG4gIGZ1bmN0aW9uQ2FsbFJlc3VsdDogKGNvbnRlbnQ6IHN0cmluZykgPT4gdm9pZDtcbiAgZmluYWxGdW5jdGlvbkNhbGxSZXN1bHQ6IChjb250ZW50OiBzdHJpbmcpID0+IHZvaWQ7XG4gIHRvdGFsVXNhZ2U6ICh1c2FnZTogQ29tcGxldGlvblVzYWdlKSA9PiB2b2lkO1xufVxuIiwgImltcG9ydCB7XG4gIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0sXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG59IGZyb20gJy4uL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zJztcbmltcG9ydCB7IHR5cGUgUnVubmFibGVGdW5jdGlvbnMsIHR5cGUgQmFzZUZ1bmN0aW9uc0FyZ3MsIFJ1bm5hYmxlVG9vbHMgfSBmcm9tICcuL1J1bm5hYmxlRnVuY3Rpb24nO1xuaW1wb3J0IHtcbiAgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcixcbiAgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cyxcbiAgUnVubmVyT3B0aW9ucyxcbn0gZnJvbSAnLi9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyJztcbmltcG9ydCB7IGlzQXNzaXN0YW50TWVzc2FnZSB9IGZyb20gJy4vY2hhdENvbXBsZXRpb25VdGlscyc7XG5pbXBvcnQgT3BlbkFJIGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IEF1dG9QYXJzZWFibGVUb29sIH0gZnJvbSAnLi4vbGliL3BhcnNlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMgZXh0ZW5kcyBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzIHtcbiAgY29udGVudDogKGNvbnRlbnQ6IHN0cmluZykgPT4gdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25GdW5jdGlvblJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzIGV4dGVuZHMgQmFzZUZ1bmN0aW9uc0FyZ3M+ID0gT21pdDxcbiAgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICdmdW5jdGlvbnMnXG4+ICYge1xuICBmdW5jdGlvbnM6IFJ1bm5hYmxlRnVuY3Rpb25zPEZ1bmN0aW9uc0FyZ3M+O1xufTtcblxuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3MgZXh0ZW5kcyBCYXNlRnVuY3Rpb25zQXJncz4gPSBPbWl0PFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgJ3Rvb2xzJ1xuPiAmIHtcbiAgdG9vbHM6IFJ1bm5hYmxlVG9vbHM8RnVuY3Rpb25zQXJncz4gfCBBdXRvUGFyc2VhYmxlVG9vbDxhbnksIHRydWU+W107XG59O1xuXG5leHBvcnQgY2xhc3MgQ2hhdENvbXBsZXRpb25SdW5uZXI8UGFyc2VkVCA9IG51bGw+IGV4dGVuZHMgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcjxcbiAgQ2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMsXG4gIFBhcnNlZFRcbj4ge1xuICAvKiogQGRlcHJlY2F0ZWQgLSBwbGVhc2UgdXNlIGBydW5Ub29sc2AgaW5zdGVhZC4gKi9cbiAgc3RhdGljIHJ1bkZ1bmN0aW9ucyhcbiAgICBjbGllbnQ6IE9wZW5BSSxcbiAgICBwYXJhbXM6IENoYXRDb21wbGV0aW9uRnVuY3Rpb25SdW5uZXJQYXJhbXM8YW55W10+LFxuICAgIG9wdGlvbnM/OiBSdW5uZXJPcHRpb25zLFxuICApOiBDaGF0Q29tcGxldGlvblJ1bm5lcjxudWxsPiB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IENoYXRDb21wbGV0aW9uUnVubmVyKCk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3J1bkZ1bmN0aW9ucycgfSxcbiAgICB9O1xuICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fcnVuRnVuY3Rpb25zKGNsaWVudCwgcGFyYW1zLCBvcHRzKSk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxuXG4gIHN0YXRpYyBydW5Ub29sczxQYXJzZWRUPihcbiAgICBjbGllbnQ6IE9wZW5BSSxcbiAgICBwYXJhbXM6IENoYXRDb21wbGV0aW9uVG9vbFJ1bm5lclBhcmFtczxhbnlbXT4sXG4gICAgb3B0aW9ucz86IFJ1bm5lck9wdGlvbnMsXG4gICk6IENoYXRDb21wbGV0aW9uUnVubmVyPFBhcnNlZFQ+IHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgQ2hhdENvbXBsZXRpb25SdW5uZXI8UGFyc2VkVD4oKTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAncnVuVG9vbHMnIH0sXG4gICAgfTtcbiAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX3J1blRvb2xzKGNsaWVudCwgcGFyYW1zLCBvcHRzKSk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxuXG4gIG92ZXJyaWRlIF9hZGRNZXNzYWdlKFxuICAgIHRoaXM6IENoYXRDb21wbGV0aW9uUnVubmVyPFBhcnNlZFQ+LFxuICAgIG1lc3NhZ2U6IENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtLFxuICAgIGVtaXQ6IGJvb2xlYW4gPSB0cnVlLFxuICApIHtcbiAgICBzdXBlci5fYWRkTWVzc2FnZShtZXNzYWdlLCBlbWl0KTtcbiAgICBpZiAoaXNBc3Npc3RhbnRNZXNzYWdlKG1lc3NhZ2UpICYmIG1lc3NhZ2UuY29udGVudCkge1xuICAgICAgdGhpcy5fZW1pdCgnY29udGVudCcsIG1lc3NhZ2UuY29udGVudCBhcyBzdHJpbmcpO1xuICAgIH1cbiAgfVxufVxuIiwgImNvbnN0IFNUUiA9IDBiMDAwMDAwMDAxO1xuY29uc3QgTlVNID0gMGIwMDAwMDAwMTA7XG5jb25zdCBBUlIgPSAwYjAwMDAwMDEwMDtcbmNvbnN0IE9CSiA9IDBiMDAwMDAxMDAwO1xuY29uc3QgTlVMTCA9IDBiMDAwMDEwMDAwO1xuY29uc3QgQk9PTCA9IDBiMDAwMTAwMDAwO1xuY29uc3QgTkFOID0gMGIwMDEwMDAwMDA7XG5jb25zdCBJTkZJTklUWSA9IDBiMDEwMDAwMDAwO1xuY29uc3QgTUlOVVNfSU5GSU5JVFkgPSAwYjEwMDAwMDAwMDtcblxuY29uc3QgSU5GID0gSU5GSU5JVFkgfCBNSU5VU19JTkZJTklUWTtcbmNvbnN0IFNQRUNJQUwgPSBOVUxMIHwgQk9PTCB8IElORiB8IE5BTjtcbmNvbnN0IEFUT00gPSBTVFIgfCBOVU0gfCBTUEVDSUFMO1xuY29uc3QgQ09MTEVDVElPTiA9IEFSUiB8IE9CSjtcbmNvbnN0IEFMTCA9IEFUT00gfCBDT0xMRUNUSU9OO1xuXG5jb25zdCBBbGxvdyA9IHtcbiAgU1RSLFxuICBOVU0sXG4gIEFSUixcbiAgT0JKLFxuICBOVUxMLFxuICBCT09MLFxuICBOQU4sXG4gIElORklOSVRZLFxuICBNSU5VU19JTkZJTklUWSxcbiAgSU5GLFxuICBTUEVDSUFMLFxuICBBVE9NLFxuICBDT0xMRUNUSU9OLFxuICBBTEwsXG59O1xuXG4vLyBUaGUgSlNPTiBzdHJpbmcgc2VnbWVudCB3YXMgdW5hYmxlIHRvIGJlIHBhcnNlZCBjb21wbGV0ZWx5XG5jbGFzcyBQYXJ0aWFsSlNPTiBleHRlbmRzIEVycm9yIHt9XG5cbmNsYXNzIE1hbGZvcm1lZEpTT04gZXh0ZW5kcyBFcnJvciB7fVxuXG4vKipcbiAqIFBhcnNlIGluY29tcGxldGUgSlNPTlxuICogQHBhcmFtIHtzdHJpbmd9IGpzb25TdHJpbmcgUGFydGlhbCBKU09OIHRvIGJlIHBhcnNlZFxuICogQHBhcmFtIHtudW1iZXJ9IGFsbG93UGFydGlhbCBTcGVjaWZ5IHdoYXQgdHlwZXMgYXJlIGFsbG93ZWQgdG8gYmUgcGFydGlhbCwgc2VlIHtAbGluayBBbGxvd30gZm9yIGRldGFpbHNcbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgSlNPTlxuICogQHRocm93cyB7UGFydGlhbEpTT059IElmIHRoZSBKU09OIGlzIGluY29tcGxldGUgKHJlbGF0ZWQgdG8gdGhlIGBhbGxvd2AgcGFyYW1ldGVyKVxuICogQHRocm93cyB7TWFsZm9ybWVkSlNPTn0gSWYgdGhlIEpTT04gaXMgbWFsZm9ybWVkXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSlNPTihqc29uU3RyaW5nOiBzdHJpbmcsIGFsbG93UGFydGlhbDogbnVtYmVyID0gQWxsb3cuQUxMKTogYW55IHtcbiAgaWYgKHR5cGVvZiBqc29uU3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGluZyBzdHIsIGdvdCAke3R5cGVvZiBqc29uU3RyaW5nfWApO1xuICB9XG4gIGlmICghanNvblN0cmluZy50cmltKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7anNvblN0cmluZ30gaXMgZW1wdHlgKTtcbiAgfVxuICByZXR1cm4gX3BhcnNlSlNPTihqc29uU3RyaW5nLnRyaW0oKSwgYWxsb3dQYXJ0aWFsKTtcbn1cblxuY29uc3QgX3BhcnNlSlNPTiA9IChqc29uU3RyaW5nOiBzdHJpbmcsIGFsbG93OiBudW1iZXIpID0+IHtcbiAgY29uc3QgbGVuZ3RoID0ganNvblN0cmluZy5sZW5ndGg7XG4gIGxldCBpbmRleCA9IDA7XG5cbiAgY29uc3QgbWFya1BhcnRpYWxKU09OID0gKG1zZzogc3RyaW5nKSA9PiB7XG4gICAgdGhyb3cgbmV3IFBhcnRpYWxKU09OKGAke21zZ30gYXQgcG9zaXRpb24gJHtpbmRleH1gKTtcbiAgfTtcblxuICBjb25zdCB0aHJvd01hbGZvcm1lZEVycm9yID0gKG1zZzogc3RyaW5nKSA9PiB7XG4gICAgdGhyb3cgbmV3IE1hbGZvcm1lZEpTT04oYCR7bXNnfSBhdCBwb3NpdGlvbiAke2luZGV4fWApO1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlQW55OiAoKSA9PiBhbnkgPSAoKSA9PiB7XG4gICAgc2tpcEJsYW5rKCk7XG4gICAgaWYgKGluZGV4ID49IGxlbmd0aCkgbWFya1BhcnRpYWxKU09OKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICAgIGlmIChqc29uU3RyaW5nW2luZGV4XSA9PT0gJ1wiJykgcmV0dXJuIHBhcnNlU3RyKCk7XG4gICAgaWYgKGpzb25TdHJpbmdbaW5kZXhdID09PSAneycpIHJldHVybiBwYXJzZU9iaigpO1xuICAgIGlmIChqc29uU3RyaW5nW2luZGV4XSA9PT0gJ1snKSByZXR1cm4gcGFyc2VBcnIoKTtcbiAgICBpZiAoXG4gICAgICBqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCwgaW5kZXggKyA0KSA9PT0gJ251bGwnIHx8XG4gICAgICAoQWxsb3cuTlVMTCAmIGFsbG93ICYmIGxlbmd0aCAtIGluZGV4IDwgNCAmJiAnbnVsbCcuc3RhcnRzV2l0aChqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCkpKVxuICAgICkge1xuICAgICAgaW5kZXggKz0gNDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCwgaW5kZXggKyA0KSA9PT0gJ3RydWUnIHx8XG4gICAgICAoQWxsb3cuQk9PTCAmIGFsbG93ICYmIGxlbmd0aCAtIGluZGV4IDwgNCAmJiAndHJ1ZScuc3RhcnRzV2l0aChqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCkpKVxuICAgICkge1xuICAgICAgaW5kZXggKz0gNDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCwgaW5kZXggKyA1KSA9PT0gJ2ZhbHNlJyB8fFxuICAgICAgKEFsbG93LkJPT0wgJiBhbGxvdyAmJiBsZW5ndGggLSBpbmRleCA8IDUgJiYgJ2ZhbHNlJy5zdGFydHNXaXRoKGpzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4KSkpXG4gICAgKSB7XG4gICAgICBpbmRleCArPSA1O1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCwgaW5kZXggKyA4KSA9PT0gJ0luZmluaXR5JyB8fFxuICAgICAgKEFsbG93LklORklOSVRZICYgYWxsb3cgJiYgbGVuZ3RoIC0gaW5kZXggPCA4ICYmICdJbmZpbml0eScuc3RhcnRzV2l0aChqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCkpKVxuICAgICkge1xuICAgICAgaW5kZXggKz0gODtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAganNvblN0cmluZy5zdWJzdHJpbmcoaW5kZXgsIGluZGV4ICsgOSkgPT09ICctSW5maW5pdHknIHx8XG4gICAgICAoQWxsb3cuTUlOVVNfSU5GSU5JVFkgJiBhbGxvdyAmJlxuICAgICAgICAxIDwgbGVuZ3RoIC0gaW5kZXggJiZcbiAgICAgICAgbGVuZ3RoIC0gaW5kZXggPCA5ICYmXG4gICAgICAgICctSW5maW5pdHknLnN0YXJ0c1dpdGgoanNvblN0cmluZy5zdWJzdHJpbmcoaW5kZXgpKSlcbiAgICApIHtcbiAgICAgIGluZGV4ICs9IDk7XG4gICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCwgaW5kZXggKyAzKSA9PT0gJ05hTicgfHxcbiAgICAgIChBbGxvdy5OQU4gJiBhbGxvdyAmJiBsZW5ndGggLSBpbmRleCA8IDMgJiYgJ05hTicuc3RhcnRzV2l0aChqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCkpKVxuICAgICkge1xuICAgICAgaW5kZXggKz0gMztcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiBwYXJzZU51bSgpO1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlU3RyOiAoKSA9PiBzdHJpbmcgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RhcnQgPSBpbmRleDtcbiAgICBsZXQgZXNjYXBlID0gZmFsc2U7XG4gICAgaW5kZXgrKzsgLy8gc2tpcCBpbml0aWFsIHF1b3RlXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoICYmIChqc29uU3RyaW5nW2luZGV4XSAhPT0gJ1wiJyB8fCAoZXNjYXBlICYmIGpzb25TdHJpbmdbaW5kZXggLSAxXSA9PT0gJ1xcXFwnKSkpIHtcbiAgICAgIGVzY2FwZSA9IGpzb25TdHJpbmdbaW5kZXhdID09PSAnXFxcXCcgPyAhZXNjYXBlIDogZmFsc2U7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgICBpZiAoanNvblN0cmluZy5jaGFyQXQoaW5kZXgpID09ICdcIicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCArK2luZGV4IC0gTnVtYmVyKGVzY2FwZSkpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3dNYWxmb3JtZWRFcnJvcihTdHJpbmcoZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQWxsb3cuU1RSICYgYWxsb3cpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBpbmRleCAtIE51bWJlcihlc2NhcGUpKSArICdcIicpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBTeW50YXhFcnJvcjogSW52YWxpZCBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGpzb25TdHJpbmcubGFzdEluZGV4T2YoJ1xcXFwnKSkgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFya1BhcnRpYWxKU09OKCdVbnRlcm1pbmF0ZWQgc3RyaW5nIGxpdGVyYWwnKTtcbiAgfTtcblxuICBjb25zdCBwYXJzZU9iaiA9ICgpID0+IHtcbiAgICBpbmRleCsrOyAvLyBza2lwIGluaXRpYWwgYnJhY2VcbiAgICBza2lwQmxhbmsoKTtcbiAgICBjb25zdCBvYmo6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKGpzb25TdHJpbmdbaW5kZXhdICE9PSAnfScpIHtcbiAgICAgICAgc2tpcEJsYW5rKCk7XG4gICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGggJiYgQWxsb3cuT0JKICYgYWxsb3cpIHJldHVybiBvYmo7XG4gICAgICAgIGNvbnN0IGtleSA9IHBhcnNlU3RyKCk7XG4gICAgICAgIHNraXBCbGFuaygpO1xuICAgICAgICBpbmRleCsrOyAvLyBza2lwIGNvbG9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUFueSgpO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZSwgd3JpdGFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChBbGxvdy5PQkogJiBhbGxvdykgcmV0dXJuIG9iajtcbiAgICAgICAgICBlbHNlIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcEJsYW5rKCk7XG4gICAgICAgIGlmIChqc29uU3RyaW5nW2luZGV4XSA9PT0gJywnKSBpbmRleCsrOyAvLyBza2lwIGNvbW1hXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKEFsbG93Lk9CSiAmIGFsbG93KSByZXR1cm4gb2JqO1xuICAgICAgZWxzZSBtYXJrUGFydGlhbEpTT04oXCJFeHBlY3RlZCAnfScgYXQgZW5kIG9mIG9iamVjdFwiKTtcbiAgICB9XG4gICAgaW5kZXgrKzsgLy8gc2tpcCBmaW5hbCBicmFjZVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgY29uc3QgcGFyc2VBcnIgPSAoKSA9PiB7XG4gICAgaW5kZXgrKzsgLy8gc2tpcCBpbml0aWFsIGJyYWNrZXRcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKGpzb25TdHJpbmdbaW5kZXhdICE9PSAnXScpIHtcbiAgICAgICAgYXJyLnB1c2gocGFyc2VBbnkoKSk7XG4gICAgICAgIHNraXBCbGFuaygpO1xuICAgICAgICBpZiAoanNvblN0cmluZ1tpbmRleF0gPT09ICcsJykge1xuICAgICAgICAgIGluZGV4Kys7IC8vIHNraXAgY29tbWFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChBbGxvdy5BUlIgJiBhbGxvdykge1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfVxuICAgICAgbWFya1BhcnRpYWxKU09OKFwiRXhwZWN0ZWQgJ10nIGF0IGVuZCBvZiBhcnJheVwiKTtcbiAgICB9XG4gICAgaW5kZXgrKzsgLy8gc2tpcCBmaW5hbCBicmFja2V0XG4gICAgcmV0dXJuIGFycjtcbiAgfTtcblxuICBjb25zdCBwYXJzZU51bSA9ICgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIGlmIChqc29uU3RyaW5nID09PSAnLScgJiYgQWxsb3cuTlVNICYgYWxsb3cpIG1hcmtQYXJ0aWFsSlNPTihcIk5vdCBzdXJlIHdoYXQgJy0nIGlzXCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChBbGxvdy5OVU0gJiBhbGxvdykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoJy4nID09PSBqc29uU3RyaW5nW2pzb25TdHJpbmcubGVuZ3RoIC0gMV0pXG4gICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcuc3Vic3RyaW5nKDAsIGpzb25TdHJpbmcubGFzdEluZGV4T2YoJy4nKSkpO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZy5zdWJzdHJpbmcoMCwganNvblN0cmluZy5sYXN0SW5kZXhPZignZScpKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgICB0aHJvd01hbGZvcm1lZEVycm9yKFN0cmluZyhlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnQgPSBpbmRleDtcblxuICAgIGlmIChqc29uU3RyaW5nW2luZGV4XSA9PT0gJy0nKSBpbmRleCsrO1xuICAgIHdoaWxlIChqc29uU3RyaW5nW2luZGV4XSAmJiAhJyxdfScuaW5jbHVkZXMoanNvblN0cmluZ1tpbmRleF0hKSkgaW5kZXgrKztcblxuICAgIGlmIChpbmRleCA9PSBsZW5ndGggJiYgIShBbGxvdy5OVU0gJiBhbGxvdykpIG1hcmtQYXJ0aWFsSlNPTignVW50ZXJtaW5hdGVkIG51bWJlciBsaXRlcmFsJyk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGluZGV4KSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGpzb25TdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBpbmRleCkgPT09ICctJyAmJiBBbGxvdy5OVU0gJiBhbGxvdylcbiAgICAgICAgbWFya1BhcnRpYWxKU09OKFwiTm90IHN1cmUgd2hhdCAnLScgaXNcIik7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uU3RyaW5nLnN1YnN0cmluZyhzdGFydCwganNvblN0cmluZy5sYXN0SW5kZXhPZignZScpKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93TWFsZm9ybWVkRXJyb3IoU3RyaW5nKGUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc2tpcEJsYW5rID0gKCkgPT4ge1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCAmJiAnIFxcblxcclxcdCcuaW5jbHVkZXMoanNvblN0cmluZ1tpbmRleF0hKSkge1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHBhcnNlQW55KCk7XG59O1xuXG4vLyB1c2luZyB0aGlzIGZ1bmN0aW9uIHdpdGggbWFsZm9ybWVkIEpTT04gaXMgdW5kZWZpbmVkIGJlaGF2aW9yXG5jb25zdCBwYXJ0aWFsUGFyc2UgPSAoaW5wdXQ6IHN0cmluZykgPT4gcGFyc2VKU09OKGlucHV0LCBBbGxvdy5BTEwgXiBBbGxvdy5OVU0pO1xuXG5leHBvcnQgeyBwYXJ0aWFsUGFyc2UsIFBhcnRpYWxKU09OLCBNYWxmb3JtZWRKU09OIH07XG4iLCAiaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7XG4gIE9wZW5BSUVycm9yLFxuICBBUElVc2VyQWJvcnRFcnJvcixcbiAgTGVuZ3RoRmluaXNoUmVhc29uRXJyb3IsXG4gIENvbnRlbnRGaWx0ZXJGaW5pc2hSZWFzb25FcnJvcixcbn0gZnJvbSAnLi4vZXJyb3InO1xuaW1wb3J0IHtcbiAgQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2IsXG4gIHR5cGUgQ2hhdENvbXBsZXRpb24sXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25DaHVuayxcbiAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2UsXG59IGZyb20gJy4uL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zJztcbmltcG9ydCB7XG4gIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXIsXG4gIHR5cGUgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cyxcbn0gZnJvbSAnLi9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyJztcbmltcG9ydCB7IHR5cGUgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9fc2hpbXMvaW5kZXgnO1xuaW1wb3J0IHsgU3RyZWFtIH0gZnJvbSAnLi4vc3RyZWFtaW5nJztcbmltcG9ydCBPcGVuQUkgZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHsgUGFyc2VkQ2hhdENvbXBsZXRpb24gfSBmcm9tICcuLi9yZXNvdXJjZXMvYmV0YS9jaGF0L2NvbXBsZXRpb25zJztcbmltcG9ydCB7XG4gIEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdCxcbiAgaGFzQXV0b1BhcnNlYWJsZUlucHV0LFxuICBpc0F1dG9QYXJzYWJsZVJlc3BvbnNlRm9ybWF0LFxuICBpc0F1dG9QYXJzYWJsZVRvb2wsXG4gIG1heWJlUGFyc2VDaGF0Q29tcGxldGlvbixcbiAgc2hvdWxkUGFyc2VUb29sQ2FsbCxcbn0gZnJvbSAnLi4vbGliL3BhcnNlcic7XG5pbXBvcnQgeyBwYXJ0aWFsUGFyc2UgfSBmcm9tICcuLi9fdmVuZG9yL3BhcnRpYWwtanNvbi1wYXJzZXIvcGFyc2VyJztcblxuZXhwb3J0IGludGVyZmFjZSBDb250ZW50RGVsdGFFdmVudCB7XG4gIGRlbHRhOiBzdHJpbmc7XG4gIHNuYXBzaG90OiBzdHJpbmc7XG4gIHBhcnNlZDogdW5rbm93biB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGVudERvbmVFdmVudDxQYXJzZWRUID0gbnVsbD4ge1xuICBjb250ZW50OiBzdHJpbmc7XG4gIHBhcnNlZDogUGFyc2VkVCB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVmdXNhbERlbHRhRXZlbnQge1xuICBkZWx0YTogc3RyaW5nO1xuICBzbmFwc2hvdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlZnVzYWxEb25lRXZlbnQge1xuICByZWZ1c2FsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25Ub29sQ2FsbEFyZ3VtZW50c0RlbHRhRXZlbnQge1xuICBuYW1lOiBzdHJpbmc7XG5cbiAgaW5kZXg6IG51bWJlcjtcblxuICBhcmd1bWVudHM6IHN0cmluZztcblxuICBwYXJzZWRfYXJndW1lbnRzOiB1bmtub3duO1xuXG4gIGFyZ3VtZW50c19kZWx0YTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uVG9vbENhbGxBcmd1bWVudHNEb25lRXZlbnQge1xuICBuYW1lOiBzdHJpbmc7XG5cbiAgaW5kZXg6IG51bWJlcjtcblxuICBhcmd1bWVudHM6IHN0cmluZztcblxuICBwYXJzZWRfYXJndW1lbnRzOiB1bmtub3duO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ1Byb2JzQ29udGVudERlbHRhRXZlbnQge1xuICBjb250ZW50OiBBcnJheTxDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYj47XG4gIHNuYXBzaG90OiBBcnJheTxDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9nUHJvYnNDb250ZW50RG9uZUV2ZW50IHtcbiAgY29udGVudDogQXJyYXk8Q2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2I+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ1Byb2JzUmVmdXNhbERlbHRhRXZlbnQge1xuICByZWZ1c2FsOiBBcnJheTxDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYj47XG4gIHNuYXBzaG90OiBBcnJheTxDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9nUHJvYnNSZWZ1c2FsRG9uZUV2ZW50IHtcbiAgcmVmdXNhbDogQXJyYXk8Q2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2I+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uU3RyZWFtRXZlbnRzPFBhcnNlZFQgPSBudWxsPiBleHRlbmRzIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMge1xuICBjb250ZW50OiAoY29udGVudERlbHRhOiBzdHJpbmcsIGNvbnRlbnRTbmFwc2hvdDogc3RyaW5nKSA9PiB2b2lkO1xuICBjaHVuazogKGNodW5rOiBDaGF0Q29tcGxldGlvbkNodW5rLCBzbmFwc2hvdDogQ2hhdENvbXBsZXRpb25TbmFwc2hvdCkgPT4gdm9pZDtcblxuICAnY29udGVudC5kZWx0YSc6IChwcm9wczogQ29udGVudERlbHRhRXZlbnQpID0+IHZvaWQ7XG4gICdjb250ZW50LmRvbmUnOiAocHJvcHM6IENvbnRlbnREb25lRXZlbnQ8UGFyc2VkVD4pID0+IHZvaWQ7XG5cbiAgJ3JlZnVzYWwuZGVsdGEnOiAocHJvcHM6IFJlZnVzYWxEZWx0YUV2ZW50KSA9PiB2b2lkO1xuICAncmVmdXNhbC5kb25lJzogKHByb3BzOiBSZWZ1c2FsRG9uZUV2ZW50KSA9PiB2b2lkO1xuXG4gICd0b29sX2NhbGxzLmZ1bmN0aW9uLmFyZ3VtZW50cy5kZWx0YSc6IChwcm9wczogRnVuY3Rpb25Ub29sQ2FsbEFyZ3VtZW50c0RlbHRhRXZlbnQpID0+IHZvaWQ7XG4gICd0b29sX2NhbGxzLmZ1bmN0aW9uLmFyZ3VtZW50cy5kb25lJzogKHByb3BzOiBGdW5jdGlvblRvb2xDYWxsQXJndW1lbnRzRG9uZUV2ZW50KSA9PiB2b2lkO1xuXG4gICdsb2dwcm9icy5jb250ZW50LmRlbHRhJzogKHByb3BzOiBMb2dQcm9ic0NvbnRlbnREZWx0YUV2ZW50KSA9PiB2b2lkO1xuICAnbG9ncHJvYnMuY29udGVudC5kb25lJzogKHByb3BzOiBMb2dQcm9ic0NvbnRlbnREb25lRXZlbnQpID0+IHZvaWQ7XG5cbiAgJ2xvZ3Byb2JzLnJlZnVzYWwuZGVsdGEnOiAocHJvcHM6IExvZ1Byb2JzUmVmdXNhbERlbHRhRXZlbnQpID0+IHZvaWQ7XG4gICdsb2dwcm9icy5yZWZ1c2FsLmRvbmUnOiAocHJvcHM6IExvZ1Byb2JzUmVmdXNhbERvbmVFdmVudCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25TdHJlYW1QYXJhbXMgPSBPbWl0PENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSwgJ3N0cmVhbSc+ICYge1xuICBzdHJlYW0/OiB0cnVlO1xufTtcblxuaW50ZXJmYWNlIENob2ljZUV2ZW50U3RhdGUge1xuICBjb250ZW50X2RvbmU6IGJvb2xlYW47XG4gIHJlZnVzYWxfZG9uZTogYm9vbGVhbjtcbiAgbG9ncHJvYnNfY29udGVudF9kb25lOiBib29sZWFuO1xuICBsb2dwcm9ic19yZWZ1c2FsX2RvbmU6IGJvb2xlYW47XG4gIGN1cnJlbnRfdG9vbF9jYWxsX2luZGV4OiBudW1iZXIgfCBudWxsO1xuICBkb25lX3Rvb2xfY2FsbHM6IFNldDxudW1iZXI+O1xufVxuXG5leHBvcnQgY2xhc3MgQ2hhdENvbXBsZXRpb25TdHJlYW08UGFyc2VkVCA9IG51bGw+XG4gIGV4dGVuZHMgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcjxDaGF0Q29tcGxldGlvblN0cmVhbUV2ZW50czxQYXJzZWRUPiwgUGFyc2VkVD5cbiAgaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPENoYXRDb21wbGV0aW9uQ2h1bms+XG57XG4gICNwYXJhbXM6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIHwgbnVsbDtcbiAgI2Nob2ljZUV2ZW50U3RhdGVzOiBDaG9pY2VFdmVudFN0YXRlW107XG4gICNjdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdDogQ2hhdENvbXBsZXRpb25TbmFwc2hvdCB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXM6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIHwgbnVsbCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jcGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuI2Nob2ljZUV2ZW50U3RhdGVzID0gW107XG4gIH1cblxuICBnZXQgY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3QoKTogQ2hhdENvbXBsZXRpb25TbmFwc2hvdCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90O1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVuZGVkIGZvciB1c2Ugb24gdGhlIGZyb250ZW5kLCBjb25zdW1pbmcgYSBzdHJlYW0gcHJvZHVjZWQgd2l0aFxuICAgKiBgLnRvUmVhZGFibGVTdHJlYW0oKWAgb24gdGhlIGJhY2tlbmQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBtZXNzYWdlcyBzZW50IHRvIHRoZSBtb2RlbCBkbyBub3QgYXBwZWFyIGluIGAub24oJ21lc3NhZ2UnKWBcbiAgICogaW4gdGhpcyBjb250ZXh0LlxuICAgKi9cbiAgc3RhdGljIGZyb21SZWFkYWJsZVN0cmVhbShzdHJlYW06IFJlYWRhYmxlU3RyZWFtKTogQ2hhdENvbXBsZXRpb25TdHJlYW08bnVsbD4ge1xuICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBDaGF0Q29tcGxldGlvblN0cmVhbShudWxsKTtcbiAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX2Zyb21SZWFkYWJsZVN0cmVhbShzdHJlYW0pKTtcbiAgICByZXR1cm4gcnVubmVyO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUNoYXRDb21wbGV0aW9uPFBhcnNlZFQ+KFxuICAgIGNsaWVudDogT3BlbkFJLFxuICAgIHBhcmFtczogQ2hhdENvbXBsZXRpb25TdHJlYW1QYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENoYXRDb21wbGV0aW9uU3RyZWFtPFBhcnNlZFQ+IHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgQ2hhdENvbXBsZXRpb25TdHJlYW08UGFyc2VkVD4ocGFyYW1zIGFzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nKTtcbiAgICBydW5uZXIuX3J1bigoKSA9PlxuICAgICAgcnVubmVyLl9ydW5DaGF0Q29tcGxldGlvbihcbiAgICAgICAgY2xpZW50LFxuICAgICAgICB7IC4uLnBhcmFtcywgc3RyZWFtOiB0cnVlIH0sXG4gICAgICAgIHsgLi4ub3B0aW9ucywgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtSGVscGVyLU1ldGhvZCc6ICdzdHJlYW0nIH0gfSxcbiAgICAgICksXG4gICAgKTtcbiAgICByZXR1cm4gcnVubmVyO1xuICB9XG5cbiAgI2JlZ2luUmVxdWVzdCgpIHtcbiAgICBpZiAodGhpcy5lbmRlZCkgcmV0dXJuO1xuICAgIHRoaXMuI2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgI2dldENob2ljZUV2ZW50U3RhdGUoY2hvaWNlOiBDaGF0Q29tcGxldGlvblNuYXBzaG90LkNob2ljZSk6IENob2ljZUV2ZW50U3RhdGUge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuI2Nob2ljZUV2ZW50U3RhdGVzW2Nob2ljZS5pbmRleF07XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgc3RhdGUgPSB7XG4gICAgICBjb250ZW50X2RvbmU6IGZhbHNlLFxuICAgICAgcmVmdXNhbF9kb25lOiBmYWxzZSxcbiAgICAgIGxvZ3Byb2JzX2NvbnRlbnRfZG9uZTogZmFsc2UsXG4gICAgICBsb2dwcm9ic19yZWZ1c2FsX2RvbmU6IGZhbHNlLFxuICAgICAgZG9uZV90b29sX2NhbGxzOiBuZXcgU2V0KCksXG4gICAgICBjdXJyZW50X3Rvb2xfY2FsbF9pbmRleDogbnVsbCxcbiAgICB9O1xuICAgIHRoaXMuI2Nob2ljZUV2ZW50U3RhdGVzW2Nob2ljZS5pbmRleF0gPSBzdGF0ZTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICAjYWRkQ2h1bmsodGhpczogQ2hhdENvbXBsZXRpb25TdHJlYW08UGFyc2VkVD4sIGNodW5rOiBDaGF0Q29tcGxldGlvbkNodW5rKSB7XG4gICAgaWYgKHRoaXMuZW5kZWQpIHJldHVybjtcblxuICAgIGNvbnN0IGNvbXBsZXRpb24gPSB0aGlzLiNhY2N1bXVsYXRlQ2hhdENvbXBsZXRpb24oY2h1bmspO1xuICAgIHRoaXMuX2VtaXQoJ2NodW5rJywgY2h1bmssIGNvbXBsZXRpb24pO1xuXG4gICAgZm9yIChjb25zdCBjaG9pY2Ugb2YgY2h1bmsuY2hvaWNlcykge1xuICAgICAgY29uc3QgY2hvaWNlU25hcHNob3QgPSBjb21wbGV0aW9uLmNob2ljZXNbY2hvaWNlLmluZGV4XSE7XG5cbiAgICAgIGlmIChcbiAgICAgICAgY2hvaWNlLmRlbHRhLmNvbnRlbnQgIT0gbnVsbCAmJlxuICAgICAgICBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlPy5yb2xlID09PSAnYXNzaXN0YW50JyAmJlxuICAgICAgICBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlPy5jb250ZW50XG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fZW1pdCgnY29udGVudCcsIGNob2ljZS5kZWx0YS5jb250ZW50LCBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICB0aGlzLl9lbWl0KCdjb250ZW50LmRlbHRhJywge1xuICAgICAgICAgIGRlbHRhOiBjaG9pY2UuZGVsdGEuY29udGVudCxcbiAgICAgICAgICBzbmFwc2hvdDogY2hvaWNlU25hcHNob3QubWVzc2FnZS5jb250ZW50LFxuICAgICAgICAgIHBhcnNlZDogY2hvaWNlU25hcHNob3QubWVzc2FnZS5wYXJzZWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGNob2ljZS5kZWx0YS5yZWZ1c2FsICE9IG51bGwgJiZcbiAgICAgICAgY2hvaWNlU25hcHNob3QubWVzc2FnZT8ucm9sZSA9PT0gJ2Fzc2lzdGFudCcgJiZcbiAgICAgICAgY2hvaWNlU25hcHNob3QubWVzc2FnZT8ucmVmdXNhbFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJ3JlZnVzYWwuZGVsdGEnLCB7XG4gICAgICAgICAgZGVsdGE6IGNob2ljZS5kZWx0YS5yZWZ1c2FsLFxuICAgICAgICAgIHNuYXBzaG90OiBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLnJlZnVzYWwsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hvaWNlLmxvZ3Byb2JzPy5jb250ZW50ICE9IG51bGwgJiYgY2hvaWNlU25hcHNob3QubWVzc2FnZT8ucm9sZSA9PT0gJ2Fzc2lzdGFudCcpIHtcbiAgICAgICAgdGhpcy5fZW1pdCgnbG9ncHJvYnMuY29udGVudC5kZWx0YScsIHtcbiAgICAgICAgICBjb250ZW50OiBjaG9pY2UubG9ncHJvYnM/LmNvbnRlbnQsXG4gICAgICAgICAgc25hcHNob3Q6IGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzPy5jb250ZW50ID8/IFtdLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNob2ljZS5sb2dwcm9icz8ucmVmdXNhbCAhPSBudWxsICYmIGNob2ljZVNuYXBzaG90Lm1lc3NhZ2U/LnJvbGUgPT09ICdhc3Npc3RhbnQnKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJ2xvZ3Byb2JzLnJlZnVzYWwuZGVsdGEnLCB7XG4gICAgICAgICAgcmVmdXNhbDogY2hvaWNlLmxvZ3Byb2JzPy5yZWZ1c2FsLFxuICAgICAgICAgIHNuYXBzaG90OiBjaG9pY2VTbmFwc2hvdC5sb2dwcm9icz8ucmVmdXNhbCA/PyBbXSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jZ2V0Q2hvaWNlRXZlbnRTdGF0ZShjaG9pY2VTbmFwc2hvdCk7XG5cbiAgICAgIGlmIChjaG9pY2VTbmFwc2hvdC5maW5pc2hfcmVhc29uKSB7XG4gICAgICAgIHRoaXMuI2VtaXRDb250ZW50RG9uZUV2ZW50cyhjaG9pY2VTbmFwc2hvdCk7XG5cbiAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRfdG9vbF9jYWxsX2luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLiNlbWl0VG9vbENhbGxEb25lRXZlbnQoY2hvaWNlU25hcHNob3QsIHN0YXRlLmN1cnJlbnRfdG9vbF9jYWxsX2luZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIGNob2ljZS5kZWx0YS50b29sX2NhbGxzID8/IFtdKSB7XG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50X3Rvb2xfY2FsbF9pbmRleCAhPT0gdG9vbENhbGwuaW5kZXgpIHtcbiAgICAgICAgICB0aGlzLiNlbWl0Q29udGVudERvbmVFdmVudHMoY2hvaWNlU25hcHNob3QpO1xuXG4gICAgICAgICAgLy8gbmV3IHRvb2wgY2FsbCBzdGFydGVkLCB0aGUgcHJldmlvdXMgb25lIGlzIGRvbmVcbiAgICAgICAgICBpZiAoc3RhdGUuY3VycmVudF90b29sX2NhbGxfaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jZW1pdFRvb2xDYWxsRG9uZUV2ZW50KGNob2ljZVNuYXBzaG90LCBzdGF0ZS5jdXJyZW50X3Rvb2xfY2FsbF9pbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuY3VycmVudF90b29sX2NhbGxfaW5kZXggPSB0b29sQ2FsbC5pbmRleDtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCB0b29sQ2FsbERlbHRhIG9mIGNob2ljZS5kZWx0YS50b29sX2NhbGxzID8/IFtdKSB7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsU25hcHNob3QgPSBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLnRvb2xfY2FsbHM/Llt0b29sQ2FsbERlbHRhLmluZGV4XTtcbiAgICAgICAgaWYgKCF0b29sQ2FsbFNuYXBzaG90Py50eXBlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9vbENhbGxTbmFwc2hvdD8udHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMuX2VtaXQoJ3Rvb2xfY2FsbHMuZnVuY3Rpb24uYXJndW1lbnRzLmRlbHRhJywge1xuICAgICAgICAgICAgbmFtZTogdG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbj8ubmFtZSxcbiAgICAgICAgICAgIGluZGV4OiB0b29sQ2FsbERlbHRhLmluZGV4LFxuICAgICAgICAgICAgYXJndW1lbnRzOiB0b29sQ2FsbFNuYXBzaG90LmZ1bmN0aW9uLmFyZ3VtZW50cyxcbiAgICAgICAgICAgIHBhcnNlZF9hcmd1bWVudHM6IHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24ucGFyc2VkX2FyZ3VtZW50cyxcbiAgICAgICAgICAgIGFyZ3VtZW50c19kZWx0YTogdG9vbENhbGxEZWx0YS5mdW5jdGlvbj8uYXJndW1lbnRzID8/ICcnLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2VydE5ldmVyKHRvb2xDYWxsU25hcHNob3Q/LnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgI2VtaXRUb29sQ2FsbERvbmVFdmVudChjaG9pY2VTbmFwc2hvdDogQ2hhdENvbXBsZXRpb25TbmFwc2hvdC5DaG9pY2UsIHRvb2xDYWxsSW5kZXg6IG51bWJlcikge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jZ2V0Q2hvaWNlRXZlbnRTdGF0ZShjaG9pY2VTbmFwc2hvdCk7XG4gICAgaWYgKHN0YXRlLmRvbmVfdG9vbF9jYWxscy5oYXModG9vbENhbGxJbmRleCkpIHtcbiAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgZmlyZWQgdGhlIGRvbmUgZXZlbnRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0b29sQ2FsbFNuYXBzaG90ID0gY2hvaWNlU25hcHNob3QubWVzc2FnZS50b29sX2NhbGxzPy5bdG9vbENhbGxJbmRleF07XG4gICAgaWYgKCF0b29sQ2FsbFNuYXBzaG90KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHRvb2wgY2FsbCBzbmFwc2hvdCcpO1xuICAgIH1cbiAgICBpZiAoIXRvb2xDYWxsU25hcHNob3QudHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29sIGNhbGwgc25hcHNob3QgbWlzc2luZyBgdHlwZWAnKTtcbiAgICB9XG5cbiAgICBpZiAodG9vbENhbGxTbmFwc2hvdC50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBpbnB1dFRvb2wgPSB0aGlzLiNwYXJhbXM/LnRvb2xzPy5maW5kKFxuICAgICAgICAodG9vbCkgPT4gdG9vbC50eXBlID09PSAnZnVuY3Rpb24nICYmIHRvb2wuZnVuY3Rpb24ubmFtZSA9PT0gdG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbi5uYW1lLFxuICAgICAgKTtcblxuICAgICAgdGhpcy5fZW1pdCgndG9vbF9jYWxscy5mdW5jdGlvbi5hcmd1bWVudHMuZG9uZScsIHtcbiAgICAgICAgbmFtZTogdG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICBpbmRleDogdG9vbENhbGxJbmRleCxcbiAgICAgICAgYXJndW1lbnRzOiB0b29sQ2FsbFNuYXBzaG90LmZ1bmN0aW9uLmFyZ3VtZW50cyxcbiAgICAgICAgcGFyc2VkX2FyZ3VtZW50czpcbiAgICAgICAgICBpc0F1dG9QYXJzYWJsZVRvb2woaW5wdXRUb29sKSA/IGlucHV0VG9vbC4kcGFyc2VSYXcodG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbi5hcmd1bWVudHMpXG4gICAgICAgICAgOiBpbnB1dFRvb2w/LmZ1bmN0aW9uLnN0cmljdCA/IEpTT04ucGFyc2UodG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbi5hcmd1bWVudHMpXG4gICAgICAgICAgOiBudWxsLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydE5ldmVyKHRvb2xDYWxsU25hcHNob3QudHlwZSk7XG4gICAgfVxuICB9XG5cbiAgI2VtaXRDb250ZW50RG9uZUV2ZW50cyhjaG9pY2VTbmFwc2hvdDogQ2hhdENvbXBsZXRpb25TbmFwc2hvdC5DaG9pY2UpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuI2dldENob2ljZUV2ZW50U3RhdGUoY2hvaWNlU25hcHNob3QpO1xuXG4gICAgaWYgKGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UuY29udGVudCAmJiAhc3RhdGUuY29udGVudF9kb25lKSB7XG4gICAgICBzdGF0ZS5jb250ZW50X2RvbmUgPSB0cnVlO1xuXG4gICAgICBjb25zdCByZXNwb25zZUZvcm1hdCA9IHRoaXMuI2dldEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdCgpO1xuXG4gICAgICB0aGlzLl9lbWl0KCdjb250ZW50LmRvbmUnLCB7XG4gICAgICAgIGNvbnRlbnQ6IGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgcGFyc2VkOiByZXNwb25zZUZvcm1hdCA/IHJlc3BvbnNlRm9ybWF0LiRwYXJzZVJhdyhjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLmNvbnRlbnQpIDogKG51bGwgYXMgYW55KSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLnJlZnVzYWwgJiYgIXN0YXRlLnJlZnVzYWxfZG9uZSkge1xuICAgICAgc3RhdGUucmVmdXNhbF9kb25lID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fZW1pdCgncmVmdXNhbC5kb25lJywgeyByZWZ1c2FsOiBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLnJlZnVzYWwgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzPy5jb250ZW50ICYmICFzdGF0ZS5sb2dwcm9ic19jb250ZW50X2RvbmUpIHtcbiAgICAgIHN0YXRlLmxvZ3Byb2JzX2NvbnRlbnRfZG9uZSA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2VtaXQoJ2xvZ3Byb2JzLmNvbnRlbnQuZG9uZScsIHsgY29udGVudDogY2hvaWNlU25hcHNob3QubG9ncHJvYnMuY29udGVudCB9KTtcbiAgICB9XG5cbiAgICBpZiAoY2hvaWNlU25hcHNob3QubG9ncHJvYnM/LnJlZnVzYWwgJiYgIXN0YXRlLmxvZ3Byb2JzX3JlZnVzYWxfZG9uZSkge1xuICAgICAgc3RhdGUubG9ncHJvYnNfcmVmdXNhbF9kb25lID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fZW1pdCgnbG9ncHJvYnMucmVmdXNhbC5kb25lJywgeyByZWZ1c2FsOiBjaG9pY2VTbmFwc2hvdC5sb2dwcm9icy5yZWZ1c2FsIH0pO1xuICAgIH1cbiAgfVxuXG4gICNlbmRSZXF1ZXN0KCk6IFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+IHtcbiAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBzdHJlYW0gaGFzIGVuZGVkLCB0aGlzIHNob3VsZG4ndCBoYXBwZW5gKTtcbiAgICB9XG4gICAgY29uc3Qgc25hcHNob3QgPSB0aGlzLiNjdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdDtcbiAgICBpZiAoIXNuYXBzaG90KSB7XG4gICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYHJlcXVlc3QgZW5kZWQgd2l0aG91dCBzZW5kaW5nIGFueSBjaHVua3NgKTtcbiAgICB9XG4gICAgdGhpcy4jY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4jY2hvaWNlRXZlbnRTdGF0ZXMgPSBbXTtcbiAgICByZXR1cm4gZmluYWxpemVDaGF0Q29tcGxldGlvbihzbmFwc2hvdCwgdGhpcy4jcGFyYW1zKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBhc3luYyBfY3JlYXRlQ2hhdENvbXBsZXRpb24oXG4gICAgY2xpZW50OiBPcGVuQUksXG4gICAgcGFyYW1zOiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxQYXJzZWRDaGF0Q29tcGxldGlvbjxQYXJzZWRUPj4ge1xuICAgIHN1cGVyLl9jcmVhdGVDaGF0Q29tcGxldGlvbjtcbiAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXMuY29udHJvbGxlci5hYm9ydCgpKTtcbiAgICB9XG4gICAgdGhpcy4jYmVnaW5SZXF1ZXN0KCk7XG5cbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBjbGllbnQuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoXG4gICAgICB7IC4uLnBhcmFtcywgc3RyZWFtOiB0cnVlIH0sXG4gICAgICB7IC4uLm9wdGlvbnMsIHNpZ25hbDogdGhpcy5jb250cm9sbGVyLnNpZ25hbCB9LFxuICAgICk7XG4gICAgdGhpcy5fY29ubmVjdGVkKCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgIHRoaXMuI2FkZENodW5rKGNodW5rKTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5jb250cm9sbGVyLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hZGRDaGF0Q29tcGxldGlvbih0aGlzLiNlbmRSZXF1ZXN0KCkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9mcm9tUmVhZGFibGVTdHJlYW0oXG4gICAgcmVhZGFibGVTdHJlYW06IFJlYWRhYmxlU3RyZWFtLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBQcm9taXNlPENoYXRDb21wbGV0aW9uPiB7XG4gICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgIGlmIChzaWduYWwpIHtcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgfVxuICAgIHRoaXMuI2JlZ2luUmVxdWVzdCgpO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCgpO1xuICAgIGNvbnN0IHN0cmVhbSA9IFN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW08Q2hhdENvbXBsZXRpb25DaHVuaz4ocmVhZGFibGVTdHJlYW0sIHRoaXMuY29udHJvbGxlcik7XG4gICAgbGV0IGNoYXRJZDtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgaWYgKGNoYXRJZCAmJiBjaGF0SWQgIT09IGNodW5rLmlkKSB7XG4gICAgICAgIC8vIEEgbmV3IHJlcXVlc3QgaGFzIGJlZW4gbWFkZS5cbiAgICAgICAgdGhpcy5fYWRkQ2hhdENvbXBsZXRpb24odGhpcy4jZW5kUmVxdWVzdCgpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4jYWRkQ2h1bmsoY2h1bmspO1xuICAgICAgY2hhdElkID0gY2h1bmsuaWQ7XG4gICAgfVxuICAgIGlmIChzdHJlYW0uY29udHJvbGxlci5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hhdENvbXBsZXRpb24odGhpcy4jZW5kUmVxdWVzdCgpKTtcbiAgfVxuXG4gICNnZXRBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQoKTogQXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0PFBhcnNlZFQ+IHwgbnVsbCB7XG4gICAgY29uc3QgcmVzcG9uc2VGb3JtYXQgPSB0aGlzLiNwYXJhbXM/LnJlc3BvbnNlX2Zvcm1hdDtcbiAgICBpZiAoaXNBdXRvUGFyc2FibGVSZXNwb25zZUZvcm1hdDxQYXJzZWRUPihyZXNwb25zZUZvcm1hdCkpIHtcbiAgICAgIHJldHVybiByZXNwb25zZUZvcm1hdDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gICNhY2N1bXVsYXRlQ2hhdENvbXBsZXRpb24oY2h1bms6IENoYXRDb21wbGV0aW9uQ2h1bmspOiBDaGF0Q29tcGxldGlvblNuYXBzaG90IHtcbiAgICBsZXQgc25hcHNob3QgPSB0aGlzLiNjdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdDtcbiAgICBjb25zdCB7IGNob2ljZXMsIC4uLnJlc3QgfSA9IGNodW5rO1xuICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgIHNuYXBzaG90ID0gdGhpcy4jY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3QgPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGNob2ljZXM6IFtdLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmFzc2lnbihzbmFwc2hvdCwgcmVzdCk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB7IGRlbHRhLCBmaW5pc2hfcmVhc29uLCBpbmRleCwgbG9ncHJvYnMgPSBudWxsLCAuLi5vdGhlciB9IG9mIGNodW5rLmNob2ljZXMpIHtcbiAgICAgIGxldCBjaG9pY2UgPSBzbmFwc2hvdC5jaG9pY2VzW2luZGV4XTtcbiAgICAgIGlmICghY2hvaWNlKSB7XG4gICAgICAgIGNob2ljZSA9IHNuYXBzaG90LmNob2ljZXNbaW5kZXhdID0geyBmaW5pc2hfcmVhc29uLCBpbmRleCwgbWVzc2FnZToge30sIGxvZ3Byb2JzLCAuLi5vdGhlciB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobG9ncHJvYnMpIHtcbiAgICAgICAgaWYgKCFjaG9pY2UubG9ncHJvYnMpIHtcbiAgICAgICAgICBjaG9pY2UubG9ncHJvYnMgPSBPYmplY3QuYXNzaWduKHt9LCBsb2dwcm9icyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgeyBjb250ZW50LCByZWZ1c2FsLCAuLi5yZXN0IH0gPSBsb2dwcm9icztcbiAgICAgICAgICBhc3NlcnRJc0VtcHR5KHJlc3QpO1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2hvaWNlLmxvZ3Byb2JzLCByZXN0KTtcblxuICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICBjaG9pY2UubG9ncHJvYnMuY29udGVudCA/Pz0gW107XG4gICAgICAgICAgICBjaG9pY2UubG9ncHJvYnMuY29udGVudC5wdXNoKC4uLmNvbnRlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZWZ1c2FsKSB7XG4gICAgICAgICAgICBjaG9pY2UubG9ncHJvYnMucmVmdXNhbCA/Pz0gW107XG4gICAgICAgICAgICBjaG9pY2UubG9ncHJvYnMucmVmdXNhbC5wdXNoKC4uLnJlZnVzYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluaXNoX3JlYXNvbikge1xuICAgICAgICBjaG9pY2UuZmluaXNoX3JlYXNvbiA9IGZpbmlzaF9yZWFzb247XG5cbiAgICAgICAgaWYgKHRoaXMuI3BhcmFtcyAmJiBoYXNBdXRvUGFyc2VhYmxlSW5wdXQodGhpcy4jcGFyYW1zKSkge1xuICAgICAgICAgIGlmIChmaW5pc2hfcmVhc29uID09PSAnbGVuZ3RoJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IExlbmd0aEZpbmlzaFJlYXNvbkVycm9yKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZpbmlzaF9yZWFzb24gPT09ICdjb250ZW50X2ZpbHRlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb250ZW50RmlsdGVyRmluaXNoUmVhc29uRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihjaG9pY2UsIG90aGVyKTtcblxuICAgICAgaWYgKCFkZWx0YSkgY29udGludWU7IC8vIFNob3VsZG4ndCBoYXBwZW47IGp1c3QgaW4gY2FzZS5cblxuICAgICAgY29uc3QgeyBjb250ZW50LCByZWZ1c2FsLCBmdW5jdGlvbl9jYWxsLCByb2xlLCB0b29sX2NhbGxzLCAuLi5yZXN0IH0gPSBkZWx0YTtcbiAgICAgIGFzc2VydElzRW1wdHkocmVzdCk7XG4gICAgICBPYmplY3QuYXNzaWduKGNob2ljZS5tZXNzYWdlLCByZXN0KTtcblxuICAgICAgaWYgKHJlZnVzYWwpIHtcbiAgICAgICAgY2hvaWNlLm1lc3NhZ2UucmVmdXNhbCA9IChjaG9pY2UubWVzc2FnZS5yZWZ1c2FsIHx8ICcnKSArIHJlZnVzYWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChyb2xlKSBjaG9pY2UubWVzc2FnZS5yb2xlID0gcm9sZTtcbiAgICAgIGlmIChmdW5jdGlvbl9jYWxsKSB7XG4gICAgICAgIGlmICghY2hvaWNlLm1lc3NhZ2UuZnVuY3Rpb25fY2FsbCkge1xuICAgICAgICAgIGNob2ljZS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPSBmdW5jdGlvbl9jYWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmdW5jdGlvbl9jYWxsLm5hbWUpIGNob2ljZS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwubmFtZSA9IGZ1bmN0aW9uX2NhbGwubmFtZTtcbiAgICAgICAgICBpZiAoZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMpIHtcbiAgICAgICAgICAgIGNob2ljZS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzID8/PSAnJztcbiAgICAgICAgICAgIGNob2ljZS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICs9IGZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgY2hvaWNlLm1lc3NhZ2UuY29udGVudCA9IChjaG9pY2UubWVzc2FnZS5jb250ZW50IHx8ICcnKSArIGNvbnRlbnQ7XG5cbiAgICAgICAgaWYgKCFjaG9pY2UubWVzc2FnZS5yZWZ1c2FsICYmIHRoaXMuI2dldEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdCgpKSB7XG4gICAgICAgICAgY2hvaWNlLm1lc3NhZ2UucGFyc2VkID0gcGFydGlhbFBhcnNlKGNob2ljZS5tZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0b29sX2NhbGxzKSB7XG4gICAgICAgIGlmICghY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxscykgY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxscyA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgeyBpbmRleCwgaWQsIHR5cGUsIGZ1bmN0aW9uOiBmbiwgLi4ucmVzdCB9IG9mIHRvb2xfY2FsbHMpIHtcbiAgICAgICAgICBjb25zdCB0b29sX2NhbGwgPSAoY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxsc1tpbmRleF0gPz89XG4gICAgICAgICAgICB7fSBhcyBDaGF0Q29tcGxldGlvblNuYXBzaG90LkNob2ljZS5NZXNzYWdlLlRvb2xDYWxsKTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRvb2xfY2FsbCwgcmVzdCk7XG4gICAgICAgICAgaWYgKGlkKSB0b29sX2NhbGwuaWQgPSBpZDtcbiAgICAgICAgICBpZiAodHlwZSkgdG9vbF9jYWxsLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIGlmIChmbikgdG9vbF9jYWxsLmZ1bmN0aW9uID8/PSB7IG5hbWU6IGZuLm5hbWUgPz8gJycsIGFyZ3VtZW50czogJycgfTtcbiAgICAgICAgICBpZiAoZm4/Lm5hbWUpIHRvb2xfY2FsbC5mdW5jdGlvbiEubmFtZSA9IGZuLm5hbWU7XG4gICAgICAgICAgaWYgKGZuPy5hcmd1bWVudHMpIHtcbiAgICAgICAgICAgIHRvb2xfY2FsbC5mdW5jdGlvbiEuYXJndW1lbnRzICs9IGZuLmFyZ3VtZW50cztcblxuICAgICAgICAgICAgaWYgKHNob3VsZFBhcnNlVG9vbENhbGwodGhpcy4jcGFyYW1zLCB0b29sX2NhbGwpKSB7XG4gICAgICAgICAgICAgIHRvb2xfY2FsbC5mdW5jdGlvbiEucGFyc2VkX2FyZ3VtZW50cyA9IHBhcnRpYWxQYXJzZSh0b29sX2NhbGwuZnVuY3Rpb24hLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbmFwc2hvdDtcbiAgfVxuXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0odGhpczogQ2hhdENvbXBsZXRpb25TdHJlYW08UGFyc2VkVD4pOiBBc3luY0l0ZXJhdG9yPENoYXRDb21wbGV0aW9uQ2h1bms+IHtcbiAgICBjb25zdCBwdXNoUXVldWU6IENoYXRDb21wbGV0aW9uQ2h1bmtbXSA9IFtdO1xuICAgIGNvbnN0IHJlYWRRdWV1ZToge1xuICAgICAgcmVzb2x2ZTogKGNodW5rOiBDaGF0Q29tcGxldGlvbkNodW5rIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuICAgICAgcmVqZWN0OiAoZXJyOiB1bmtub3duKSA9PiB2b2lkO1xuICAgIH1bXSA9IFtdO1xuICAgIGxldCBkb25lID0gZmFsc2U7XG5cbiAgICB0aGlzLm9uKCdjaHVuaycsIChjaHVuaykgPT4ge1xuICAgICAgY29uc3QgcmVhZGVyID0gcmVhZFF1ZXVlLnNoaWZ0KCk7XG4gICAgICBpZiAocmVhZGVyKSB7XG4gICAgICAgIHJlYWRlci5yZXNvbHZlKGNodW5rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hRdWV1ZS5wdXNoKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMub24oJ2VuZCcsICgpID0+IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgcmVhZFF1ZXVlKSB7XG4gICAgICAgIHJlYWRlci5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICB9KTtcblxuICAgIHRoaXMub24oJ2Fib3J0JywgKGVycikgPT4ge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiByZWFkUXVldWUpIHtcbiAgICAgICAgcmVhZGVyLnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVhZFF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgcmVhZFF1ZXVlKSB7XG4gICAgICAgIHJlYWRlci5yZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlYWRRdWV1ZS5sZW5ndGggPSAwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGFzeW5jICgpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PENoYXRDb21wbGV0aW9uQ2h1bms+PiA9PiB7XG4gICAgICAgIGlmICghcHVzaFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxDaGF0Q29tcGxldGlvbkNodW5rIHwgdW5kZWZpbmVkPigocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgICAgICAgcmVhZFF1ZXVlLnB1c2goeyByZXNvbHZlLCByZWplY3QgfSksXG4gICAgICAgICAgKS50aGVuKChjaHVuaykgPT4gKGNodW5rID8geyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0gOiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNodW5rID0gcHVzaFF1ZXVlLnNoaWZ0KCkhO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH07XG4gICAgICB9LFxuICAgICAgcmV0dXJuOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRoaXMuYWJvcnQoKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgdG9SZWFkYWJsZVN0cmVhbSgpOiBSZWFkYWJsZVN0cmVhbSB7XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IFN0cmVhbSh0aGlzW1N5bWJvbC5hc3luY0l0ZXJhdG9yXS5iaW5kKHRoaXMpLCB0aGlzLmNvbnRyb2xsZXIpO1xuICAgIHJldHVybiBzdHJlYW0udG9SZWFkYWJsZVN0cmVhbSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplQ2hhdENvbXBsZXRpb248UGFyc2VkVD4oXG4gIHNuYXBzaG90OiBDaGF0Q29tcGxldGlvblNuYXBzaG90LFxuICBwYXJhbXM6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIHwgbnVsbCxcbik6IFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+IHtcbiAgY29uc3QgeyBpZCwgY2hvaWNlcywgY3JlYXRlZCwgbW9kZWwsIHN5c3RlbV9maW5nZXJwcmludCwgLi4ucmVzdCB9ID0gc25hcHNob3Q7XG4gIGNvbnN0IGNvbXBsZXRpb246IENoYXRDb21wbGV0aW9uID0ge1xuICAgIC4uLnJlc3QsXG4gICAgaWQsXG4gICAgY2hvaWNlczogY2hvaWNlcy5tYXAoXG4gICAgICAoeyBtZXNzYWdlLCBmaW5pc2hfcmVhc29uLCBpbmRleCwgbG9ncHJvYnMsIC4uLmNob2ljZVJlc3QgfSk6IENoYXRDb21wbGV0aW9uLkNob2ljZSA9PiB7XG4gICAgICAgIGlmICghZmluaXNoX3JlYXNvbikge1xuICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBmaW5pc2hfcmVhc29uIGZvciBjaG9pY2UgJHtpbmRleH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgY29udGVudCA9IG51bGwsIGZ1bmN0aW9uX2NhbGwsIHRvb2xfY2FsbHMsIC4uLm1lc3NhZ2VSZXN0IH0gPSBtZXNzYWdlO1xuICAgICAgICBjb25zdCByb2xlID0gbWVzc2FnZS5yb2xlIGFzICdhc3Npc3RhbnQnOyAvLyB0aGlzIGlzIHdoYXQgd2UgZXhwZWN0OyBpbiB0aGVvcnkgaXQgY291bGQgYmUgZGlmZmVyZW50IHdoaWNoIHdvdWxkIG1ha2Ugb3VyIHR5cGVzIGEgc2xpZ2h0IGxpZSBidXQgd291bGQgYmUgZmluZS5cbiAgICAgICAgaWYgKCFyb2xlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIHJvbGUgZm9yIGNob2ljZSAke2luZGV4fWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZ1bmN0aW9uX2NhbGwpIHtcbiAgICAgICAgICBjb25zdCB7IGFyZ3VtZW50czogYXJncywgbmFtZSB9ID0gZnVuY3Rpb25fY2FsbDtcbiAgICAgICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYG1pc3NpbmcgZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgZm9yIGNob2ljZSAke2luZGV4fWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIGZ1bmN0aW9uX2NhbGwubmFtZSBmb3IgY2hvaWNlICR7aW5kZXh9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNob2ljZVJlc3QsXG4gICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IHsgYXJndW1lbnRzOiBhcmdzLCBuYW1lIH0sXG4gICAgICAgICAgICAgIHJvbGUsXG4gICAgICAgICAgICAgIHJlZnVzYWw6IG1lc3NhZ2UucmVmdXNhbCA/PyBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbmlzaF9yZWFzb24sXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIGxvZ3Byb2JzLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9vbF9jYWxscykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jaG9pY2VSZXN0LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBmaW5pc2hfcmVhc29uLFxuICAgICAgICAgICAgbG9ncHJvYnMsXG4gICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgIC4uLm1lc3NhZ2VSZXN0LFxuICAgICAgICAgICAgICByb2xlLFxuICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICByZWZ1c2FsOiBtZXNzYWdlLnJlZnVzYWwgPz8gbnVsbCxcbiAgICAgICAgICAgICAgdG9vbF9jYWxsczogdG9vbF9jYWxscy5tYXAoKHRvb2xfY2FsbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZnVuY3Rpb246IGZuLCB0eXBlLCBpZCwgLi4udG9vbFJlc3QgfSA9IHRvb2xfY2FsbDtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFyZ3VtZW50czogYXJncywgbmFtZSwgLi4uZm5SZXN0IH0gPSBmbiB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIGNob2ljZXNbJHtpbmRleH1dLnRvb2xfY2FsbHNbJHtpfV0uaWRcXG4ke3N0cihzbmFwc2hvdCl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBjaG9pY2VzWyR7aW5kZXh9XS50b29sX2NhbGxzWyR7aX1dLnR5cGVcXG4ke3N0cihzbmFwc2hvdCl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYG1pc3NpbmcgY2hvaWNlc1ske2luZGV4fV0udG9vbF9jYWxsc1ske2l9XS5mdW5jdGlvbi5uYW1lXFxuJHtzdHIoc25hcHNob3QpfWAsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBtaXNzaW5nIGNob2ljZXNbJHtpbmRleH1dLnRvb2xfY2FsbHNbJHtpfV0uZnVuY3Rpb24uYXJndW1lbnRzXFxuJHtzdHIoc25hcHNob3QpfWAsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnRvb2xSZXN0LCBpZCwgdHlwZSwgZnVuY3Rpb246IHsgLi4uZm5SZXN0LCBuYW1lLCBhcmd1bWVudHM6IGFyZ3MgfSB9O1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmNob2ljZVJlc3QsXG4gICAgICAgICAgbWVzc2FnZTogeyAuLi5tZXNzYWdlUmVzdCwgY29udGVudCwgcm9sZSwgcmVmdXNhbDogbWVzc2FnZS5yZWZ1c2FsID8/IG51bGwgfSxcbiAgICAgICAgICBmaW5pc2hfcmVhc29uLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIGxvZ3Byb2JzLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICApLFxuICAgIGNyZWF0ZWQsXG4gICAgbW9kZWwsXG4gICAgb2JqZWN0OiAnY2hhdC5jb21wbGV0aW9uJyxcbiAgICAuLi4oc3lzdGVtX2ZpbmdlcnByaW50ID8geyBzeXN0ZW1fZmluZ2VycHJpbnQgfSA6IHt9KSxcbiAgfTtcblxuICByZXR1cm4gbWF5YmVQYXJzZUNoYXRDb21wbGV0aW9uKGNvbXBsZXRpb24sIHBhcmFtcyk7XG59XG5cbmZ1bmN0aW9uIHN0cih4OiB1bmtub3duKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3RyZWFtZWQgY2h1bmsgb2YgYSBjaGF0IGNvbXBsZXRpb24gcmVzcG9uc2UgcmV0dXJuZWQgYnkgbW9kZWwsXG4gKiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgaW5wdXQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25TbmFwc2hvdCB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY2hhdCBjb21wbGV0aW9uLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGNoYXQgY29tcGxldGlvbiBjaG9pY2VzLiBDYW4gYmUgbW9yZSB0aGFuIG9uZSBpZiBgbmAgaXMgZ3JlYXRlclxuICAgKiB0aGFuIDEuXG4gICAqL1xuICBjaG9pY2VzOiBBcnJheTxDaGF0Q29tcGxldGlvblNuYXBzaG90LkNob2ljZT47XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgb2Ygd2hlbiB0aGUgY2hhdCBjb21wbGV0aW9uIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdG8gZ2VuZXJhdGUgdGhlIGNvbXBsZXRpb24uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8vIE5vdGUgd2UgZG8gbm90IGluY2x1ZGUgYW4gXCJvYmplY3RcIiB0eXBlIG9uIHRoZSBzbmFwc2hvdCxcbiAgLy8gYmVjYXVzZSB0aGUgb2JqZWN0IGlzIG5vdCBhIHZhbGlkIFwiY2hhdC5jb21wbGV0aW9uXCIgdW50aWwgZmluYWxpemVkLlxuICAvLyBvYmplY3Q6ICdjaGF0LmNvbXBsZXRpb24nO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZpbmdlcnByaW50IHJlcHJlc2VudHMgdGhlIGJhY2tlbmQgY29uZmlndXJhdGlvbiB0aGF0IHRoZSBtb2RlbCBydW5zIHdpdGguXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGBzZWVkYCByZXF1ZXN0IHBhcmFtZXRlciB0byB1bmRlcnN0YW5kIHdoZW5cbiAgICogYmFja2VuZCBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlIHRoYXQgbWlnaHQgaW1wYWN0IGRldGVybWluaXNtLlxuICAgKi9cbiAgc3lzdGVtX2ZpbmdlcnByaW50Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uU25hcHNob3Qge1xuICBleHBvcnQgaW50ZXJmYWNlIENob2ljZSB7XG4gICAgLyoqXG4gICAgICogQSBjaGF0IGNvbXBsZXRpb24gZGVsdGEgZ2VuZXJhdGVkIGJ5IHN0cmVhbWVkIG1vZGVsIHJlc3BvbnNlcy5cbiAgICAgKi9cbiAgICBtZXNzYWdlOiBDaG9pY2UuTWVzc2FnZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZWFzb24gdGhlIG1vZGVsIHN0b3BwZWQgZ2VuZXJhdGluZyB0b2tlbnMuIFRoaXMgd2lsbCBiZSBgc3RvcGAgaWYgdGhlIG1vZGVsXG4gICAgICogaGl0IGEgbmF0dXJhbCBzdG9wIHBvaW50IG9yIGEgcHJvdmlkZWQgc3RvcCBzZXF1ZW5jZSwgYGxlbmd0aGAgaWYgdGhlIG1heGltdW1cbiAgICAgKiBudW1iZXIgb2YgdG9rZW5zIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdCB3YXMgcmVhY2hlZCwgYGNvbnRlbnRfZmlsdGVyYCBpZlxuICAgICAqIGNvbnRlbnQgd2FzIG9taXR0ZWQgZHVlIHRvIGEgZmxhZyBmcm9tIG91ciBjb250ZW50IGZpbHRlcnMsIG9yIGBmdW5jdGlvbl9jYWxsYFxuICAgICAqIGlmIHRoZSBtb2RlbCBjYWxsZWQgYSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmaW5pc2hfcmVhc29uOiBDaGF0Q29tcGxldGlvbi5DaG9pY2VbJ2ZpbmlzaF9yZWFzb24nXSB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBMb2cgcHJvYmFiaWxpdHkgaW5mb3JtYXRpb24gZm9yIHRoZSBjaG9pY2UuXG4gICAgICovXG4gICAgbG9ncHJvYnM6IENoYXRDb21wbGV0aW9uLkNob2ljZS5Mb2dwcm9icyB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGNob2ljZSBpbiB0aGUgbGlzdCBvZiBjaG9pY2VzLlxuICAgICAqL1xuICAgIGluZGV4OiBudW1iZXI7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIENob2ljZSB7XG4gICAgLyoqXG4gICAgICogQSBjaGF0IGNvbXBsZXRpb24gZGVsdGEgZ2VuZXJhdGVkIGJ5IHN0cmVhbWVkIG1vZGVsIHJlc3BvbnNlcy5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGNodW5rIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ/OiBzdHJpbmcgfCBudWxsO1xuXG4gICAgICByZWZ1c2FsPzogc3RyaW5nIHwgbnVsbDtcblxuICAgICAgcGFyc2VkPzogdW5rbm93biB8IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgYW5kIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZVxuICAgICAgICogbW9kZWwuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uX2NhbGw/OiBNZXNzYWdlLkZ1bmN0aW9uQ2FsbDtcblxuICAgICAgdG9vbF9jYWxscz86IEFycmF5PE1lc3NhZ2UuVG9vbENhbGw+O1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSByb2xlIG9mIHRoZSBhdXRob3Igb2YgdGhpcyBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICByb2xlPzogJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50JyB8ICdmdW5jdGlvbicgfCAndG9vbCc7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBNZXNzYWdlIHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgVG9vbENhbGwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgICBpZDogc3RyaW5nO1xuXG4gICAgICAgIGZ1bmN0aW9uOiBUb29sQ2FsbC5GdW5jdGlvbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wuXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nO1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgbmFtZXNwYWNlIFRvb2xDYWxsIHtcbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICAgICAgICAgKiBmb3JtYXQuIE5vdGUgdGhhdCB0aGUgbW9kZWwgZG9lcyBub3QgYWx3YXlzIGdlbmVyYXRlIHZhbGlkIEpTT04sIGFuZCBtYXlcbiAgICAgICAgICAgKiBoYWxsdWNpbmF0ZSBwYXJhbWV0ZXJzIG5vdCBkZWZpbmVkIGJ5IHlvdXIgZnVuY3Rpb24gc2NoZW1hLiBWYWxpZGF0ZSB0aGVcbiAgICAgICAgICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAgICAgICAgICovXG4gICAgICAgICAgYXJndW1lbnRzOiBzdHJpbmc7XG5cbiAgICAgICAgICBwYXJzZWRfYXJndW1lbnRzPzogdW5rbm93bjtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuYW1lIGFuZCBhcmd1bWVudHMgb2YgYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQsIGFzIGdlbmVyYXRlZCBieSB0aGVcbiAgICAgICAqIG1vZGVsLlxuICAgICAgICovXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQ2FsbCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGgsIGFzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaW4gSlNPTlxuICAgICAgICAgKiBmb3JtYXQuIE5vdGUgdGhhdCB0aGUgbW9kZWwgZG9lcyBub3QgYWx3YXlzIGdlbmVyYXRlIHZhbGlkIEpTT04sIGFuZCBtYXlcbiAgICAgICAgICogaGFsbHVjaW5hdGUgcGFyYW1ldGVycyBub3QgZGVmaW5lZCBieSB5b3VyIGZ1bmN0aW9uIHNjaGVtYS4gVmFsaWRhdGUgdGhlXG4gICAgICAgICAqIGFyZ3VtZW50cyBpbiB5b3VyIGNvZGUgYmVmb3JlIGNhbGxpbmcgeW91ciBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGFyZ3VtZW50cz86IHN0cmluZztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgICBuYW1lPzogc3RyaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG50eXBlIEFzc2VydElzRW1wdHk8VCBleHRlbmRzIHt9PiA9IGtleW9mIFQgZXh0ZW5kcyBuZXZlciA/IFQgOiBuZXZlcjtcblxuLyoqXG4gKiBFbnN1cmVzIHRoZSBnaXZlbiBhcmd1bWVudCBpcyBhbiBlbXB0eSBvYmplY3QsIHVzZWZ1bCBmb3JcbiAqIGFzc2VydGluZyB0aGF0IGFsbCBrbm93biBwcm9wZXJ0aWVzIG9uIGFuIG9iamVjdCBoYXZlIGJlZW5cbiAqIGRlc3RydWN0dXJlZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNFbXB0eTxUIGV4dGVuZHMge30+KG9iajogQXNzZXJ0SXNFbXB0eTxUPik6IGFzc2VydHMgb2JqIGlzIEFzc2VydElzRW1wdHk8VD4ge1xuICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIGFzc2VydE5ldmVyKF94OiBuZXZlcikge31cbiIsICJpbXBvcnQge1xuICB0eXBlIENoYXRDb21wbGV0aW9uQ2h1bmssXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG59IGZyb20gJy4uL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zJztcbmltcG9ydCB7IFJ1bm5lck9wdGlvbnMsIHR5cGUgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cyB9IGZyb20gJy4vQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcic7XG5pbXBvcnQgeyB0eXBlIFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vX3NoaW1zL2luZGV4JztcbmltcG9ydCB7IFJ1bm5hYmxlVG9vbHMsIHR5cGUgQmFzZUZ1bmN0aW9uc0FyZ3MsIHR5cGUgUnVubmFibGVGdW5jdGlvbnMgfSBmcm9tICcuL1J1bm5hYmxlRnVuY3Rpb24nO1xuaW1wb3J0IHsgQ2hhdENvbXBsZXRpb25TbmFwc2hvdCwgQ2hhdENvbXBsZXRpb25TdHJlYW0gfSBmcm9tICcuL0NoYXRDb21wbGV0aW9uU3RyZWFtJztcbmltcG9ydCBPcGVuQUkgZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHsgQXV0b1BhcnNlYWJsZVRvb2wgfSBmcm9tICcuLi9saWIvcGFyc2VyJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvblN0cmVhbUV2ZW50cyBleHRlbmRzIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMge1xuICBjb250ZW50OiAoY29udGVudERlbHRhOiBzdHJpbmcsIGNvbnRlbnRTbmFwc2hvdDogc3RyaW5nKSA9PiB2b2lkO1xuICBjaHVuazogKGNodW5rOiBDaGF0Q29tcGxldGlvbkNodW5rLCBzbmFwc2hvdDogQ2hhdENvbXBsZXRpb25TbmFwc2hvdCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdGdW5jdGlvblJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzIGV4dGVuZHMgQmFzZUZ1bmN0aW9uc0FyZ3M+ID0gT21pdDxcbiAgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gICdmdW5jdGlvbnMnXG4+ICYge1xuICBmdW5jdGlvbnM6IFJ1bm5hYmxlRnVuY3Rpb25zPEZ1bmN0aW9uc0FyZ3M+O1xufTtcblxuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdUb29sUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3MgZXh0ZW5kcyBCYXNlRnVuY3Rpb25zQXJncz4gPSBPbWl0PFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgJ3Rvb2xzJ1xuPiAmIHtcbiAgdG9vbHM6IFJ1bm5hYmxlVG9vbHM8RnVuY3Rpb25zQXJncz4gfCBBdXRvUGFyc2VhYmxlVG9vbDxhbnksIHRydWU+W107XG59O1xuXG5leHBvcnQgY2xhc3MgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXI8UGFyc2VkVCA9IG51bGw+XG4gIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25TdHJlYW08UGFyc2VkVD5cbiAgaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPENoYXRDb21wbGV0aW9uQ2h1bms+XG57XG4gIHN0YXRpYyBvdmVycmlkZSBmcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSk6IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyPG51bGw+IHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIobnVsbCk7XG4gICAgcnVubmVyLl9ydW4oKCkgPT4gcnVubmVyLl9mcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCAtIHBsZWFzZSB1c2UgYHJ1blRvb2xzYCBpbnN0ZWFkLiAqL1xuICBzdGF0aWMgcnVuRnVuY3Rpb25zPFQgZXh0ZW5kcyAoc3RyaW5nIHwgb2JqZWN0KVtdPihcbiAgICBjbGllbnQ6IE9wZW5BSSxcbiAgICBwYXJhbXM6IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nRnVuY3Rpb25SdW5uZXJQYXJhbXM8VD4sXG4gICAgb3B0aW9ucz86IFJ1bm5lck9wdGlvbnMsXG4gICk6IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyPG51bGw+IHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIobnVsbCk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3J1bkZ1bmN0aW9ucycgfSxcbiAgICB9O1xuICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fcnVuRnVuY3Rpb25zKGNsaWVudCwgcGFyYW1zLCBvcHRzKSk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxuXG4gIHN0YXRpYyBydW5Ub29sczxUIGV4dGVuZHMgKHN0cmluZyB8IG9iamVjdClbXSwgUGFyc2VkVCA9IG51bGw+KFxuICAgIGNsaWVudDogT3BlbkFJLFxuICAgIHBhcmFtczogQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdUb29sUnVubmVyUGFyYW1zPFQ+LFxuICAgIG9wdGlvbnM/OiBSdW5uZXJPcHRpb25zLFxuICApOiBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcjxQYXJzZWRUPiB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyPFBhcnNlZFQ+KFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIHRoZXNlIHR5cGVzIGFyZSBpbmNvbXBhdGlibGVcbiAgICAgIHBhcmFtcyxcbiAgICApO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtSGVscGVyLU1ldGhvZCc6ICdydW5Ub29scycgfSxcbiAgICB9O1xuICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fcnVuVG9vbHMoY2xpZW50LCBwYXJhbXMsIG9wdHMpKTtcbiAgICByZXR1cm4gcnVubmVyO1xuICB9XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgQ2hhdENvbXBsZXRpb25SdW5uZXIsIENoYXRDb21wbGV0aW9uRnVuY3Rpb25SdW5uZXJQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25SdW5uZXInO1xuaW1wb3J0IHtcbiAgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIsXG4gIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nRnVuY3Rpb25SdW5uZXJQYXJhbXMsXG59IGZyb20gJy4uLy4uLy4uL2xpYi9DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcic7XG5pbXBvcnQgeyBCYXNlRnVuY3Rpb25zQXJncyB9IGZyb20gJy4uLy4uLy4uL2xpYi9SdW5uYWJsZUZ1bmN0aW9uJztcbmltcG9ydCB7IFJ1bm5lck9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9saWIvQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcic7XG5pbXBvcnQgeyBDaGF0Q29tcGxldGlvblRvb2xSdW5uZXJQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25SdW5uZXInO1xuaW1wb3J0IHsgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdUb29sUnVubmVyUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyJztcbmltcG9ydCB7IENoYXRDb21wbGV0aW9uU3RyZWFtLCB0eXBlIENoYXRDb21wbGV0aW9uU3RyZWFtUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtJztcbmltcG9ydCB7XG4gIENoYXRDb21wbGV0aW9uLFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgQ2hhdENvbXBsZXRpb25NZXNzYWdlLFxuICBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCxcbn0gZnJvbSAnLi4vLi4vY2hhdC9jb21wbGV0aW9ucyc7XG5pbXBvcnQgeyBFeHRyYWN0UGFyc2VkQ29udGVudEZyb21QYXJhbXMsIHBhcnNlQ2hhdENvbXBsZXRpb24sIHZhbGlkYXRlSW5wdXRUb29scyB9IGZyb20gJy4uLy4uLy4uL2xpYi9wYXJzZXInO1xuXG5leHBvcnQge1xuICBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcixcbiAgdHlwZSBDaGF0Q29tcGxldGlvblN0cmVhbWluZ0Z1bmN0aW9uUnVubmVyUGFyYW1zLFxufSBmcm9tICcuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXInO1xuZXhwb3J0IHtcbiAgdHlwZSBSdW5uYWJsZUZ1bmN0aW9uLFxuICB0eXBlIFJ1bm5hYmxlRnVuY3Rpb25zLFxuICB0eXBlIFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2UsXG4gIHR5cGUgUnVubmFibGVGdW5jdGlvbldpdGhvdXRQYXJzZSxcbiAgUGFyc2luZ0Z1bmN0aW9uLFxuICBQYXJzaW5nVG9vbEZ1bmN0aW9uLFxufSBmcm9tICcuLi8uLi8uLi9saWIvUnVubmFibGVGdW5jdGlvbic7XG5leHBvcnQgeyB0eXBlIENoYXRDb21wbGV0aW9uVG9vbFJ1bm5lclBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL2xpYi9DaGF0Q29tcGxldGlvblJ1bm5lcic7XG5leHBvcnQgeyB0eXBlIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nVG9vbFJ1bm5lclBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL2xpYi9DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcic7XG5leHBvcnQgeyBDaGF0Q29tcGxldGlvblN0cmVhbSwgdHlwZSBDaGF0Q29tcGxldGlvblN0cmVhbVBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL2xpYi9DaGF0Q29tcGxldGlvblN0cmVhbSc7XG5leHBvcnQge1xuICBDaGF0Q29tcGxldGlvblJ1bm5lcixcbiAgdHlwZSBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uUnVubmVyUGFyYW1zLFxufSBmcm9tICcuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25SdW5uZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnNlZEZ1bmN0aW9uIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwuRnVuY3Rpb24ge1xuICBwYXJzZWRfYXJndW1lbnRzPzogdW5rbm93bjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRGdW5jdGlvblRvb2xDYWxsIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwge1xuICBmdW5jdGlvbjogUGFyc2VkRnVuY3Rpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkQ2hhdENvbXBsZXRpb25NZXNzYWdlPFBhcnNlZFQ+IGV4dGVuZHMgQ2hhdENvbXBsZXRpb25NZXNzYWdlIHtcbiAgcGFyc2VkOiBQYXJzZWRUIHwgbnVsbDtcbiAgdG9vbF9jYWxsczogQXJyYXk8UGFyc2VkRnVuY3Rpb25Ub29sQ2FsbD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkQ2hvaWNlPFBhcnNlZFQ+IGV4dGVuZHMgQ2hhdENvbXBsZXRpb24uQ2hvaWNlIHtcbiAgbWVzc2FnZTogUGFyc2VkQ2hhdENvbXBsZXRpb25NZXNzYWdlPFBhcnNlZFQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+IGV4dGVuZHMgQ2hhdENvbXBsZXRpb24ge1xuICBjaG9pY2VzOiBBcnJheTxQYXJzZWRDaG9pY2U8UGFyc2VkVD4+O1xufVxuXG5leHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvblBhcnNlUGFyYW1zID0gQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmc7XG5cbmV4cG9ydCBjbGFzcyBDb21wbGV0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgcGFyc2U8UGFyYW1zIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25QYXJzZVBhcmFtcywgUGFyc2VkVCA9IEV4dHJhY3RQYXJzZWRDb250ZW50RnJvbVBhcmFtczxQYXJhbXM+PihcbiAgICBib2R5OiBQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxQYXJzZWRDaGF0Q29tcGxldGlvbjxQYXJzZWRUPj4ge1xuICAgIHZhbGlkYXRlSW5wdXRUb29scyhib2R5LnRvb2xzKTtcblxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuY2hhdC5jb21wbGV0aW9uc1xuICAgICAgLmNyZWF0ZShib2R5LCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ2JldGEuY2hhdC5jb21wbGV0aW9ucy5wYXJzZScsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgICAgLl90aGVuVW53cmFwKChjb21wbGV0aW9uKSA9PiBwYXJzZUNoYXRDb21wbGV0aW9uKGNvbXBsZXRpb24sIGJvZHkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCAtIHVzZSBgcnVuVG9vbHNgIGluc3RlYWQuXG4gICAqL1xuICBydW5GdW5jdGlvbnM8RnVuY3Rpb25zQXJncyBleHRlbmRzIEJhc2VGdW5jdGlvbnNBcmdzPihcbiAgICBib2R5OiBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3M+LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDaGF0Q29tcGxldGlvblJ1bm5lcjxudWxsPjtcbiAgcnVuRnVuY3Rpb25zPEZ1bmN0aW9uc0FyZ3MgZXh0ZW5kcyBCYXNlRnVuY3Rpb25zQXJncz4oXG4gICAgYm9keTogQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdGdW5jdGlvblJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzPixcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXI8bnVsbD47XG4gIHJ1bkZ1bmN0aW9uczxGdW5jdGlvbnNBcmdzIGV4dGVuZHMgQmFzZUZ1bmN0aW9uc0FyZ3M+KFxuICAgIGJvZHk6XG4gICAgICB8IENoYXRDb21wbGV0aW9uRnVuY3Rpb25SdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncz5cbiAgICAgIHwgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdGdW5jdGlvblJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzPixcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ2hhdENvbXBsZXRpb25SdW5uZXI8bnVsbD4gfCBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcjxudWxsPiB7XG4gICAgaWYgKGJvZHkuc3RyZWFtKSB7XG4gICAgICByZXR1cm4gQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIucnVuRnVuY3Rpb25zKFxuICAgICAgICB0aGlzLl9jbGllbnQsXG4gICAgICAgIGJvZHkgYXMgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdGdW5jdGlvblJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzPixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBDaGF0Q29tcGxldGlvblJ1bm5lci5ydW5GdW5jdGlvbnMoXG4gICAgICB0aGlzLl9jbGllbnQsXG4gICAgICBib2R5IGFzIENoYXRDb21wbGV0aW9uRnVuY3Rpb25SdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncz4sXG4gICAgICBvcHRpb25zLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQSBjb252ZW5pZW5jZSBoZWxwZXIgZm9yIHVzaW5nIHRvb2wgY2FsbHMgd2l0aCB0aGUgL2NoYXQvY29tcGxldGlvbnMgZW5kcG9pbnRcbiAgICogd2hpY2ggYXV0b21hdGljYWxseSBjYWxscyB0aGUgSmF2YVNjcmlwdCBmdW5jdGlvbnMgeW91IHByb3ZpZGUgYW5kIHNlbmRzIHRoZWlyXG4gICAqIHJlc3VsdHMgYmFjayB0byB0aGUgL2NoYXQvY29tcGxldGlvbnMgZW5kcG9pbnQsIGxvb3BpbmcgYXMgbG9uZyBhcyB0aGUgbW9kZWxcbiAgICogcmVxdWVzdHMgZnVuY3Rpb24gY2FsbHMuXG4gICAqXG4gICAqIEZvciBtb3JlIGRldGFpbHMgYW5kIGV4YW1wbGVzLCBzZWVcbiAgICogW3RoZSBkb2NzXShodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlI2F1dG9tYXRlZC1mdW5jdGlvbi1jYWxscylcbiAgICovXG4gIHJ1blRvb2xzPFxuICAgIFBhcmFtcyBleHRlbmRzIENoYXRDb21wbGV0aW9uVG9vbFJ1bm5lclBhcmFtczxhbnk+LFxuICAgIFBhcnNlZFQgPSBFeHRyYWN0UGFyc2VkQ29udGVudEZyb21QYXJhbXM8UGFyYW1zPixcbiAgPihib2R5OiBQYXJhbXMsIG9wdGlvbnM/OiBSdW5uZXJPcHRpb25zKTogQ2hhdENvbXBsZXRpb25SdW5uZXI8UGFyc2VkVD47XG5cbiAgcnVuVG9vbHM8XG4gICAgUGFyYW1zIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdUb29sUnVubmVyUGFyYW1zPGFueT4sXG4gICAgUGFyc2VkVCA9IEV4dHJhY3RQYXJzZWRDb250ZW50RnJvbVBhcmFtczxQYXJhbXM+LFxuICA+KGJvZHk6IFBhcmFtcywgb3B0aW9ucz86IFJ1bm5lck9wdGlvbnMpOiBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcjxQYXJzZWRUPjtcblxuICBydW5Ub29sczxcbiAgICBQYXJhbXMgZXh0ZW5kcyBDaGF0Q29tcGxldGlvblRvb2xSdW5uZXJQYXJhbXM8YW55PiB8IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nVG9vbFJ1bm5lclBhcmFtczxhbnk+LFxuICAgIFBhcnNlZFQgPSBFeHRyYWN0UGFyc2VkQ29udGVudEZyb21QYXJhbXM8UGFyYW1zPixcbiAgPihcbiAgICBib2R5OiBQYXJhbXMsXG4gICAgb3B0aW9ucz86IFJ1bm5lck9wdGlvbnMsXG4gICk6IENoYXRDb21wbGV0aW9uUnVubmVyPFBhcnNlZFQ+IHwgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXI8UGFyc2VkVD4ge1xuICAgIGlmIChib2R5LnN0cmVhbSkge1xuICAgICAgcmV0dXJuIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyLnJ1blRvb2xzKFxuICAgICAgICB0aGlzLl9jbGllbnQsXG4gICAgICAgIGJvZHkgYXMgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdUb29sUnVubmVyUGFyYW1zPGFueT4sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBDaGF0Q29tcGxldGlvblJ1bm5lci5ydW5Ub29scyh0aGlzLl9jbGllbnQsIGJvZHkgYXMgQ2hhdENvbXBsZXRpb25Ub29sUnVubmVyUGFyYW1zPGFueT4sIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjaGF0IGNvbXBsZXRpb24gc3RyZWFtXG4gICAqL1xuICBzdHJlYW08UGFyYW1zIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25TdHJlYW1QYXJhbXMsIFBhcnNlZFQgPSBFeHRyYWN0UGFyc2VkQ29udGVudEZyb21QYXJhbXM8UGFyYW1zPj4oXG4gICAgYm9keTogUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDaGF0Q29tcGxldGlvblN0cmVhbTxQYXJzZWRUPiB7XG4gICAgcmV0dXJuIENoYXRDb21wbGV0aW9uU3RyZWFtLmNyZWF0ZUNoYXRDb21wbGV0aW9uKHRoaXMuX2NsaWVudCwgYm9keSwgb3B0aW9ucyk7XG4gIH1cbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvbXBsZXRpb25zQVBJIGZyb20gJy4vY29tcGxldGlvbnMnO1xuXG5leHBvcnQgY2xhc3MgQ2hhdCBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgY29tcGxldGlvbnM6IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zID0gbmV3IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zKHRoaXMuX2NsaWVudCk7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdCB7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbnMgPSBDb21wbGV0aW9uc0FQSS5Db21wbGV0aW9ucztcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5cbmV4cG9ydCBjbGFzcyBTZXNzaW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlcGhlbWVyYWwgQVBJIHRva2VuIGZvciB1c2UgaW4gY2xpZW50LXNpZGUgYXBwbGljYXRpb25zIHdpdGggdGhlXG4gICAqIFJlYWx0aW1lIEFQSS4gQ2FuIGJlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgc2FtZSBzZXNzaW9uIHBhcmFtZXRlcnMgYXMgdGhlXG4gICAqIGBzZXNzaW9uLnVwZGF0ZWAgY2xpZW50IGV2ZW50LlxuICAgKlxuICAgKiBJdCByZXNwb25kcyB3aXRoIGEgc2Vzc2lvbiBvYmplY3QsIHBsdXMgYSBgY2xpZW50X3NlY3JldGAga2V5IHdoaWNoIGNvbnRhaW5zIGFcbiAgICogdXNhYmxlIGVwaGVtZXJhbCBBUEkgdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB0byBhdXRoZW50aWNhdGUgYnJvd3NlciBjbGllbnRzIGZvclxuICAgKiB0aGUgUmVhbHRpbWUgQVBJLlxuICAgKi9cbiAgY3JlYXRlKGJvZHk6IFNlc3Npb25DcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFNlc3Npb25DcmVhdGVSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL3JlYWx0aW1lL3Nlc3Npb25zJywge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUmVhbHRpbWUgc2Vzc2lvbiBvYmplY3QgY29uZmlndXJhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uIHtcbiAgLyoqXG4gICAqIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgc2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBpZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCBvZiBpbnB1dCBhdWRpby4gT3B0aW9ucyBhcmUgYHBjbTE2YCwgYGc3MTFfdWxhd2AsIG9yIGBnNzExX2FsYXdgLlxuICAgKi9cbiAgaW5wdXRfYXVkaW9fZm9ybWF0PzogJ3BjbTE2JyB8ICdnNzExX3VsYXcnIHwgJ2c3MTFfYWxhdyc7XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gZm9yIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24sIGRlZmF1bHRzIHRvIG9mZiBhbmQgY2FuIGJlIHNldCB0b1xuICAgKiBgbnVsbGAgdG8gdHVybiBvZmYgb25jZSBvbi4gSW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiBpcyBub3QgbmF0aXZlIHRvIHRoZVxuICAgKiBtb2RlbCwgc2luY2UgdGhlIG1vZGVsIGNvbnN1bWVzIGF1ZGlvIGRpcmVjdGx5LiBUcmFuc2NyaXB0aW9uIHJ1bnNcbiAgICogYXN5bmNocm9ub3VzbHkgdGhyb3VnaCBXaGlzcGVyIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyByb3VnaCBndWlkYW5jZSByYXRoZXJcbiAgICogdGhhbiB0aGUgcmVwcmVzZW50YXRpb24gdW5kZXJzdG9vZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICBpbnB1dF9hdWRpb190cmFuc2NyaXB0aW9uPzogU2Vzc2lvbi5JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgc3lzdGVtIGluc3RydWN0aW9ucyAoaS5lLiBzeXN0ZW0gbWVzc2FnZSkgcHJlcGVuZGVkIHRvIG1vZGVsIGNhbGxzLlxuICAgKiBUaGlzIGZpZWxkIGFsbG93cyB0aGUgY2xpZW50IHRvIGd1aWRlIHRoZSBtb2RlbCBvbiBkZXNpcmVkIHJlc3BvbnNlcy4gVGhlIG1vZGVsXG4gICAqIGNhbiBiZSBpbnN0cnVjdGVkIG9uIHJlc3BvbnNlIGNvbnRlbnQgYW5kIGZvcm1hdCwgKGUuZy4gXCJiZSBleHRyZW1lbHkgc3VjY2luY3RcIixcbiAgICogXCJhY3QgZnJpZW5kbHlcIiwgXCJoZXJlIGFyZSBleGFtcGxlcyBvZiBnb29kIHJlc3BvbnNlc1wiKSBhbmQgb24gYXVkaW8gYmVoYXZpb3JcbiAgICogKGUuZy4gXCJ0YWxrIHF1aWNrbHlcIiwgXCJpbmplY3QgZW1vdGlvbiBpbnRvIHlvdXIgdm9pY2VcIiwgXCJsYXVnaCBmcmVxdWVudGx5XCIpLiBUaGVcbiAgICogaW5zdHJ1Y3Rpb25zIGFyZSBub3QgZ3VhcmFudGVlZCB0byBiZSBmb2xsb3dlZCBieSB0aGUgbW9kZWwsIGJ1dCB0aGV5IHByb3ZpZGVcbiAgICogZ3VpZGFuY2UgdG8gdGhlIG1vZGVsIG9uIHRoZSBkZXNpcmVkIGJlaGF2aW9yLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIHNlcnZlciBzZXRzIGRlZmF1bHQgaW5zdHJ1Y3Rpb25zIHdoaWNoIHdpbGwgYmUgdXNlZCBpZiB0aGlzIGZpZWxkXG4gICAqIGlzIG5vdCBzZXQgYW5kIGFyZSB2aXNpYmxlIGluIHRoZSBgc2Vzc2lvbi5jcmVhdGVkYCBldmVudCBhdCB0aGUgc3RhcnQgb2YgdGhlXG4gICAqIHNlc3Npb24uXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIG91dHB1dCB0b2tlbnMgZm9yIGEgc2luZ2xlIGFzc2lzdGFudCByZXNwb25zZSwgaW5jbHVzaXZlIG9mXG4gICAqIHRvb2wgY2FsbHMuIFByb3ZpZGUgYW4gaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDQwOTYgdG8gbGltaXQgb3V0cHV0IHRva2Vucywgb3JcbiAgICogYGluZmAgZm9yIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSB0b2tlbnMgZm9yIGEgZ2l2ZW4gbW9kZWwuIERlZmF1bHRzIHRvIGBpbmZgLlxuICAgKi9cbiAgbWF4X3Jlc3BvbnNlX291dHB1dF90b2tlbnM/OiBudW1iZXIgfCAnaW5mJztcblxuICAvKipcbiAgICogVGhlIHNldCBvZiBtb2RhbGl0aWVzIHRoZSBtb2RlbCBjYW4gcmVzcG9uZCB3aXRoLiBUbyBkaXNhYmxlIGF1ZGlvLCBzZXQgdGhpcyB0b1xuICAgKiBbXCJ0ZXh0XCJdLlxuICAgKi9cbiAgbW9kYWxpdGllcz86IEFycmF5PCd0ZXh0JyB8ICdhdWRpbyc+O1xuXG4gIC8qKlxuICAgKiBUaGUgUmVhbHRpbWUgbW9kZWwgdXNlZCBmb3IgdGhpcyBzZXNzaW9uLlxuICAgKi9cbiAgbW9kZWw/OlxuICAgIHwgKHN0cmluZyAmIHt9KVxuICAgIHwgJ2dwdC00by1yZWFsdGltZS1wcmV2aWV3J1xuICAgIHwgJ2dwdC00by1yZWFsdGltZS1wcmV2aWV3LTIwMjQtMTAtMDEnXG4gICAgfCAnZ3B0LTRvLXJlYWx0aW1lLXByZXZpZXctMjAyNC0xMi0xNydcbiAgICB8ICdncHQtNG8tbWluaS1yZWFsdGltZS1wcmV2aWV3J1xuICAgIHwgJ2dwdC00by1taW5pLXJlYWx0aW1lLXByZXZpZXctMjAyNC0xMi0xNyc7XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgb2Ygb3V0cHV0IGF1ZGlvLiBPcHRpb25zIGFyZSBgcGNtMTZgLCBgZzcxMV91bGF3YCwgb3IgYGc3MTFfYWxhd2AuXG4gICAqL1xuICBvdXRwdXRfYXVkaW9fZm9ybWF0PzogJ3BjbTE2JyB8ICdnNzExX3VsYXcnIHwgJ2c3MTFfYWxhdyc7XG5cbiAgLyoqXG4gICAqIFNhbXBsaW5nIHRlbXBlcmF0dXJlIGZvciB0aGUgbW9kZWwsIGxpbWl0ZWQgdG8gWzAuNiwgMS4yXS4gRGVmYXVsdHMgdG8gMC44LlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEhvdyB0aGUgbW9kZWwgY2hvb3NlcyB0b29scy4gT3B0aW9ucyBhcmUgYGF1dG9gLCBgbm9uZWAsIGByZXF1aXJlZGAsIG9yIHNwZWNpZnlcbiAgICogYSBmdW5jdGlvbi5cbiAgICovXG4gIHRvb2xfY2hvaWNlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUb29scyAoZnVuY3Rpb25zKSBhdmFpbGFibGUgdG8gdGhlIG1vZGVsLlxuICAgKi9cbiAgdG9vbHM/OiBBcnJheTxTZXNzaW9uLlRvb2w+O1xuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciB0dXJuIGRldGVjdGlvbi4gQ2FuIGJlIHNldCB0byBgbnVsbGAgdG8gdHVybiBvZmYuIFNlcnZlciBWQURcbiAgICogbWVhbnMgdGhhdCB0aGUgbW9kZWwgd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IGFuZCBlbmQgb2Ygc3BlZWNoIGJhc2VkIG9uIGF1ZGlvXG4gICAqIHZvbHVtZSBhbmQgcmVzcG9uZCBhdCB0aGUgZW5kIG9mIHVzZXIgc3BlZWNoLlxuICAgKi9cbiAgdHVybl9kZXRlY3Rpb24/OiBTZXNzaW9uLlR1cm5EZXRlY3Rpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgdm9pY2UgdGhlIG1vZGVsIHVzZXMgdG8gcmVzcG9uZC4gVm9pY2UgY2Fubm90IGJlIGNoYW5nZWQgZHVyaW5nIHRoZSBzZXNzaW9uXG4gICAqIG9uY2UgdGhlIG1vZGVsIGhhcyByZXNwb25kZWQgd2l0aCBhdWRpbyBhdCBsZWFzdCBvbmNlLiBDdXJyZW50IHZvaWNlIG9wdGlvbnMgYXJlXG4gICAqIGBhbGxveWAsIGBhc2hgLCBgYmFsbGFkYCwgYGNvcmFsYCwgYGVjaG9gIGBzYWdlYCwgYHNoaW1tZXJgIGFuZCBgdmVyc2VgLlxuICAgKi9cbiAgdm9pY2U/OiAnYWxsb3knIHwgJ2FzaCcgfCAnYmFsbGFkJyB8ICdjb3JhbCcgfCAnZWNobycgfCAnc2FnZScgfCAnc2hpbW1lcicgfCAndmVyc2UnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFNlc3Npb24ge1xuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiwgZGVmYXVsdHMgdG8gb2ZmIGFuZCBjYW4gYmUgc2V0IHRvXG4gICAqIGBudWxsYCB0byB0dXJuIG9mZiBvbmNlIG9uLiBJbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uIGlzIG5vdCBuYXRpdmUgdG8gdGhlXG4gICAqIG1vZGVsLCBzaW5jZSB0aGUgbW9kZWwgY29uc3VtZXMgYXVkaW8gZGlyZWN0bHkuIFRyYW5zY3JpcHRpb24gcnVuc1xuICAgKiBhc3luY2hyb25vdXNseSB0aHJvdWdoIFdoaXNwZXIgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIHJvdWdoIGd1aWRhbmNlIHJhdGhlclxuICAgKiB0aGFuIHRoZSByZXByZXNlbnRhdGlvbiB1bmRlcnN0b29kIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlbCB0byB1c2UgZm9yIHRyYW5zY3JpcHRpb24sIGB3aGlzcGVyLTFgIGlzIHRoZSBvbmx5IGN1cnJlbnRseSBzdXBwb3J0ZWRcbiAgICAgKiBtb2RlbC5cbiAgICAgKi9cbiAgICBtb2RlbD86IHN0cmluZztcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbCB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBmdW5jdGlvbiwgaW5jbHVkaW5nIGd1aWRhbmNlIG9uIHdoZW4gYW5kIGhvdyB0byBjYWxsIGl0LFxuICAgICAqIGFuZCBndWlkYW5jZSBhYm91dCB3aGF0IHRvIHRlbGwgdGhlIHVzZXIgd2hlbiBjYWxsaW5nIChpZiBhbnl0aGluZykuXG4gICAgICovXG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbmFtZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFBhcmFtZXRlcnMgb2YgdGhlIGZ1bmN0aW9uIGluIEpTT04gU2NoZW1hLlxuICAgICAqL1xuICAgIHBhcmFtZXRlcnM/OiB1bmtub3duO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wsIGkuZS4gYGZ1bmN0aW9uYC5cbiAgICAgKi9cbiAgICB0eXBlPzogJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciB0dXJuIGRldGVjdGlvbi4gQ2FuIGJlIHNldCB0byBgbnVsbGAgdG8gdHVybiBvZmYuIFNlcnZlciBWQURcbiAgICogbWVhbnMgdGhhdCB0aGUgbW9kZWwgd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IGFuZCBlbmQgb2Ygc3BlZWNoIGJhc2VkIG9uIGF1ZGlvXG4gICAqIHZvbHVtZSBhbmQgcmVzcG9uZCBhdCB0aGUgZW5kIG9mIHVzZXIgc3BlZWNoLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUdXJuRGV0ZWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgYXVkaW8gdG8gaW5jbHVkZSBiZWZvcmUgdGhlIFZBRCBkZXRlY3RlZCBzcGVlY2ggKGluIG1pbGxpc2Vjb25kcykuXG4gICAgICogRGVmYXVsdHMgdG8gMzAwbXMuXG4gICAgICovXG4gICAgcHJlZml4X3BhZGRpbmdfbXM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBEdXJhdGlvbiBvZiBzaWxlbmNlIHRvIGRldGVjdCBzcGVlY2ggc3RvcCAoaW4gbWlsbGlzZWNvbmRzKS4gRGVmYXVsdHMgdG8gNTAwbXMuXG4gICAgICogV2l0aCBzaG9ydGVyIHZhbHVlcyB0aGUgbW9kZWwgd2lsbCByZXNwb25kIG1vcmUgcXVpY2tseSwgYnV0IG1heSBqdW1wIGluIG9uXG4gICAgICogc2hvcnQgcGF1c2VzIGZyb20gdGhlIHVzZXIuXG4gICAgICovXG4gICAgc2lsZW5jZV9kdXJhdGlvbl9tcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRpb24gdGhyZXNob2xkIGZvciBWQUQgKDAuMCB0byAxLjApLCB0aGlzIGRlZmF1bHRzIHRvIDAuNS4gQSBoaWdoZXJcbiAgICAgKiB0aHJlc2hvbGQgd2lsbCByZXF1aXJlIGxvdWRlciBhdWRpbyB0byBhY3RpdmF0ZSB0aGUgbW9kZWwsIGFuZCB0aHVzIG1pZ2h0XG4gICAgICogcGVyZm9ybSBiZXR0ZXIgaW4gbm9pc3kgZW52aXJvbm1lbnRzLlxuICAgICAqL1xuICAgIHRocmVzaG9sZD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgdHVybiBkZXRlY3Rpb24sIG9ubHkgYHNlcnZlcl92YWRgIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgdHlwZT86ICdzZXJ2ZXJfdmFkJztcbiAgfVxufVxuXG4vKipcbiAqIEEgbmV3IFJlYWx0aW1lIHNlc3Npb24gY29uZmlndXJhdGlvbiwgd2l0aCBhbiBlcGhlcm1lcmFsIGtleS4gRGVmYXVsdCBUVEwgZm9yXG4gKiBrZXlzIGlzIG9uZSBtaW51dGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbkNyZWF0ZVJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIEVwaGVtZXJhbCBrZXkgcmV0dXJuZWQgYnkgdGhlIEFQSS5cbiAgICovXG4gIGNsaWVudF9zZWNyZXQ/OiBTZXNzaW9uQ3JlYXRlUmVzcG9uc2UuQ2xpZW50U2VjcmV0O1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IG9mIGlucHV0IGF1ZGlvLiBPcHRpb25zIGFyZSBgcGNtMTZgLCBgZzcxMV91bGF3YCwgb3IgYGc3MTFfYWxhd2AuXG4gICAqL1xuICBpbnB1dF9hdWRpb19mb3JtYXQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gZm9yIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24sIGRlZmF1bHRzIHRvIG9mZiBhbmQgY2FuIGJlIHNldCB0b1xuICAgKiBgbnVsbGAgdG8gdHVybiBvZmYgb25jZSBvbi4gSW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiBpcyBub3QgbmF0aXZlIHRvIHRoZVxuICAgKiBtb2RlbCwgc2luY2UgdGhlIG1vZGVsIGNvbnN1bWVzIGF1ZGlvIGRpcmVjdGx5LiBUcmFuc2NyaXB0aW9uIHJ1bnNcbiAgICogYXN5bmNocm9ub3VzbHkgdGhyb3VnaCBXaGlzcGVyIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyByb3VnaCBndWlkYW5jZSByYXRoZXJcbiAgICogdGhhbiB0aGUgcmVwcmVzZW50YXRpb24gdW5kZXJzdG9vZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICBpbnB1dF9hdWRpb190cmFuc2NyaXB0aW9uPzogU2Vzc2lvbkNyZWF0ZVJlc3BvbnNlLklucHV0QXVkaW9UcmFuc2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBzeXN0ZW0gaW5zdHJ1Y3Rpb25zIChpLmUuIHN5c3RlbSBtZXNzYWdlKSBwcmVwZW5kZWQgdG8gbW9kZWwgY2FsbHMuXG4gICAqIFRoaXMgZmllbGQgYWxsb3dzIHRoZSBjbGllbnQgdG8gZ3VpZGUgdGhlIG1vZGVsIG9uIGRlc2lyZWQgcmVzcG9uc2VzLiBUaGUgbW9kZWxcbiAgICogY2FuIGJlIGluc3RydWN0ZWQgb24gcmVzcG9uc2UgY29udGVudCBhbmQgZm9ybWF0LCAoZS5nLiBcImJlIGV4dHJlbWVseSBzdWNjaW5jdFwiLFxuICAgKiBcImFjdCBmcmllbmRseVwiLCBcImhlcmUgYXJlIGV4YW1wbGVzIG9mIGdvb2QgcmVzcG9uc2VzXCIpIGFuZCBvbiBhdWRpbyBiZWhhdmlvclxuICAgKiAoZS5nLiBcInRhbGsgcXVpY2tseVwiLCBcImluamVjdCBlbW90aW9uIGludG8geW91ciB2b2ljZVwiLCBcImxhdWdoIGZyZXF1ZW50bHlcIikuIFRoZVxuICAgKiBpbnN0cnVjdGlvbnMgYXJlIG5vdCBndWFyYW50ZWVkIHRvIGJlIGZvbGxvd2VkIGJ5IHRoZSBtb2RlbCwgYnV0IHRoZXkgcHJvdmlkZVxuICAgKiBndWlkYW5jZSB0byB0aGUgbW9kZWwgb24gdGhlIGRlc2lyZWQgYmVoYXZpb3IuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgc2VydmVyIHNldHMgZGVmYXVsdCBpbnN0cnVjdGlvbnMgd2hpY2ggd2lsbCBiZSB1c2VkIGlmIHRoaXMgZmllbGRcbiAgICogaXMgbm90IHNldCBhbmQgYXJlIHZpc2libGUgaW4gdGhlIGBzZXNzaW9uLmNyZWF0ZWRgIGV2ZW50IGF0IHRoZSBzdGFydCBvZiB0aGVcbiAgICogc2Vzc2lvbi5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZztcblxuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2Ygb3V0cHV0IHRva2VucyBmb3IgYSBzaW5nbGUgYXNzaXN0YW50IHJlc3BvbnNlLCBpbmNsdXNpdmUgb2ZcbiAgICogdG9vbCBjYWxscy4gUHJvdmlkZSBhbiBpbnRlZ2VyIGJldHdlZW4gMSBhbmQgNDA5NiB0byBsaW1pdCBvdXRwdXQgdG9rZW5zLCBvclxuICAgKiBgaW5mYCBmb3IgdGhlIG1heGltdW0gYXZhaWxhYmxlIHRva2VucyBmb3IgYSBnaXZlbiBtb2RlbC4gRGVmYXVsdHMgdG8gYGluZmAuXG4gICAqL1xuICBtYXhfcmVzcG9uc2Vfb3V0cHV0X3Rva2Vucz86IG51bWJlciB8ICdpbmYnO1xuXG4gIC8qKlxuICAgKiBUaGUgc2V0IG9mIG1vZGFsaXRpZXMgdGhlIG1vZGVsIGNhbiByZXNwb25kIHdpdGguIFRvIGRpc2FibGUgYXVkaW8sIHNldCB0aGlzIHRvXG4gICAqIFtcInRleHRcIl0uXG4gICAqL1xuICBtb2RhbGl0aWVzPzogQXJyYXk8J3RleHQnIHwgJ2F1ZGlvJz47XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgb2Ygb3V0cHV0IGF1ZGlvLiBPcHRpb25zIGFyZSBgcGNtMTZgLCBgZzcxMV91bGF3YCwgb3IgYGc3MTFfYWxhd2AuXG4gICAqL1xuICBvdXRwdXRfYXVkaW9fZm9ybWF0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTYW1wbGluZyB0ZW1wZXJhdHVyZSBmb3IgdGhlIG1vZGVsLCBsaW1pdGVkIHRvIFswLjYsIDEuMl0uIERlZmF1bHRzIHRvIDAuOC5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBIb3cgdGhlIG1vZGVsIGNob29zZXMgdG9vbHMuIE9wdGlvbnMgYXJlIGBhdXRvYCwgYG5vbmVgLCBgcmVxdWlyZWRgLCBvciBzcGVjaWZ5XG4gICAqIGEgZnVuY3Rpb24uXG4gICAqL1xuICB0b29sX2Nob2ljZT86IHN0cmluZztcblxuICAvKipcbiAgICogVG9vbHMgKGZ1bmN0aW9ucykgYXZhaWxhYmxlIHRvIHRoZSBtb2RlbC5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8U2Vzc2lvbkNyZWF0ZVJlc3BvbnNlLlRvb2w+O1xuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciB0dXJuIGRldGVjdGlvbi4gQ2FuIGJlIHNldCB0byBgbnVsbGAgdG8gdHVybiBvZmYuIFNlcnZlciBWQURcbiAgICogbWVhbnMgdGhhdCB0aGUgbW9kZWwgd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IGFuZCBlbmQgb2Ygc3BlZWNoIGJhc2VkIG9uIGF1ZGlvXG4gICAqIHZvbHVtZSBhbmQgcmVzcG9uZCBhdCB0aGUgZW5kIG9mIHVzZXIgc3BlZWNoLlxuICAgKi9cbiAgdHVybl9kZXRlY3Rpb24/OiBTZXNzaW9uQ3JlYXRlUmVzcG9uc2UuVHVybkRldGVjdGlvbjtcblxuICAvKipcbiAgICogVGhlIHZvaWNlIHRoZSBtb2RlbCB1c2VzIHRvIHJlc3BvbmQuIFZvaWNlIGNhbm5vdCBiZSBjaGFuZ2VkIGR1cmluZyB0aGUgc2Vzc2lvblxuICAgKiBvbmNlIHRoZSBtb2RlbCBoYXMgcmVzcG9uZGVkIHdpdGggYXVkaW8gYXQgbGVhc3Qgb25jZS4gQ3VycmVudCB2b2ljZSBvcHRpb25zIGFyZVxuICAgKiBgYWxsb3lgLCBgYXNoYCwgYGJhbGxhZGAsIGBjb3JhbGAsIGBlY2hvYCBgc2FnZWAsIGBzaGltbWVyYCBhbmQgYHZlcnNlYC5cbiAgICovXG4gIHZvaWNlPzogJ2FsbG95JyB8ICdhc2gnIHwgJ2JhbGxhZCcgfCAnY29yYWwnIHwgJ2VjaG8nIHwgJ3NhZ2UnIHwgJ3NoaW1tZXInIHwgJ3ZlcnNlJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBTZXNzaW9uQ3JlYXRlUmVzcG9uc2Uge1xuICAvKipcbiAgICogRXBoZW1lcmFsIGtleSByZXR1cm5lZCBieSB0aGUgQVBJLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDbGllbnRTZWNyZXQge1xuICAgIC8qKlxuICAgICAqIFRpbWVzdGFtcCBmb3Igd2hlbiB0aGUgdG9rZW4gZXhwaXJlcy4gQ3VycmVudGx5LCBhbGwgdG9rZW5zIGV4cGlyZSBhZnRlciBvbmVcbiAgICAgKiBtaW51dGUuXG4gICAgICovXG4gICAgZXhwaXJlc19hdD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEVwaGVtZXJhbCBrZXkgdXNhYmxlIGluIGNsaWVudCBlbnZpcm9ubWVudHMgdG8gYXV0aGVudGljYXRlIGNvbm5lY3Rpb25zIHRvIHRoZVxuICAgICAqIFJlYWx0aW1lIEFQSS4gVXNlIHRoaXMgaW4gY2xpZW50LXNpZGUgZW52aXJvbm1lbnRzIHJhdGhlciB0aGFuIGEgc3RhbmRhcmQgQVBJXG4gICAgICogdG9rZW4sIHdoaWNoIHNob3VsZCBvbmx5IGJlIHVzZWQgc2VydmVyLXNpZGUuXG4gICAgICovXG4gICAgdmFsdWU/OiBzdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiwgZGVmYXVsdHMgdG8gb2ZmIGFuZCBjYW4gYmUgc2V0IHRvXG4gICAqIGBudWxsYCB0byB0dXJuIG9mZiBvbmNlIG9uLiBJbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uIGlzIG5vdCBuYXRpdmUgdG8gdGhlXG4gICAqIG1vZGVsLCBzaW5jZSB0aGUgbW9kZWwgY29uc3VtZXMgYXVkaW8gZGlyZWN0bHkuIFRyYW5zY3JpcHRpb24gcnVuc1xuICAgKiBhc3luY2hyb25vdXNseSB0aHJvdWdoIFdoaXNwZXIgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIHJvdWdoIGd1aWRhbmNlIHJhdGhlclxuICAgKiB0aGFuIHRoZSByZXByZXNlbnRhdGlvbiB1bmRlcnN0b29kIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlbCB0byB1c2UgZm9yIHRyYW5zY3JpcHRpb24sIGB3aGlzcGVyLTFgIGlzIHRoZSBvbmx5IGN1cnJlbnRseSBzdXBwb3J0ZWRcbiAgICAgKiBtb2RlbC5cbiAgICAgKi9cbiAgICBtb2RlbD86IHN0cmluZztcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbCB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBmdW5jdGlvbiwgaW5jbHVkaW5nIGd1aWRhbmNlIG9uIHdoZW4gYW5kIGhvdyB0byBjYWxsIGl0LFxuICAgICAqIGFuZCBndWlkYW5jZSBhYm91dCB3aGF0IHRvIHRlbGwgdGhlIHVzZXIgd2hlbiBjYWxsaW5nIChpZiBhbnl0aGluZykuXG4gICAgICovXG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbmFtZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFBhcmFtZXRlcnMgb2YgdGhlIGZ1bmN0aW9uIGluIEpTT04gU2NoZW1hLlxuICAgICAqL1xuICAgIHBhcmFtZXRlcnM/OiB1bmtub3duO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wsIGkuZS4gYGZ1bmN0aW9uYC5cbiAgICAgKi9cbiAgICB0eXBlPzogJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciB0dXJuIGRldGVjdGlvbi4gQ2FuIGJlIHNldCB0byBgbnVsbGAgdG8gdHVybiBvZmYuIFNlcnZlciBWQURcbiAgICogbWVhbnMgdGhhdCB0aGUgbW9kZWwgd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IGFuZCBlbmQgb2Ygc3BlZWNoIGJhc2VkIG9uIGF1ZGlvXG4gICAqIHZvbHVtZSBhbmQgcmVzcG9uZCBhdCB0aGUgZW5kIG9mIHVzZXIgc3BlZWNoLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUdXJuRGV0ZWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgYXVkaW8gdG8gaW5jbHVkZSBiZWZvcmUgdGhlIFZBRCBkZXRlY3RlZCBzcGVlY2ggKGluIG1pbGxpc2Vjb25kcykuXG4gICAgICogRGVmYXVsdHMgdG8gMzAwbXMuXG4gICAgICovXG4gICAgcHJlZml4X3BhZGRpbmdfbXM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBEdXJhdGlvbiBvZiBzaWxlbmNlIHRvIGRldGVjdCBzcGVlY2ggc3RvcCAoaW4gbWlsbGlzZWNvbmRzKS4gRGVmYXVsdHMgdG8gNTAwbXMuXG4gICAgICogV2l0aCBzaG9ydGVyIHZhbHVlcyB0aGUgbW9kZWwgd2lsbCByZXNwb25kIG1vcmUgcXVpY2tseSwgYnV0IG1heSBqdW1wIGluIG9uXG4gICAgICogc2hvcnQgcGF1c2VzIGZyb20gdGhlIHVzZXIuXG4gICAgICovXG4gICAgc2lsZW5jZV9kdXJhdGlvbl9tcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRpb24gdGhyZXNob2xkIGZvciBWQUQgKDAuMCB0byAxLjApLCB0aGlzIGRlZmF1bHRzIHRvIDAuNS4gQSBoaWdoZXJcbiAgICAgKiB0aHJlc2hvbGQgd2lsbCByZXF1aXJlIGxvdWRlciBhdWRpbyB0byBhY3RpdmF0ZSB0aGUgbW9kZWwsIGFuZCB0aHVzIG1pZ2h0XG4gICAgICogcGVyZm9ybSBiZXR0ZXIgaW4gbm9pc3kgZW52aXJvbm1lbnRzLlxuICAgICAqL1xuICAgIHRocmVzaG9sZD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgdHVybiBkZXRlY3Rpb24sIG9ubHkgYHNlcnZlcl92YWRgIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgdHlwZT86IHN0cmluZztcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlc3Npb25DcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIFJlYWx0aW1lIG1vZGVsIHVzZWQgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICovXG4gIG1vZGVsOlxuICAgIHwgJ2dwdC00by1yZWFsdGltZS1wcmV2aWV3J1xuICAgIHwgJ2dwdC00by1yZWFsdGltZS1wcmV2aWV3LTIwMjQtMTAtMDEnXG4gICAgfCAnZ3B0LTRvLXJlYWx0aW1lLXByZXZpZXctMjAyNC0xMi0xNydcbiAgICB8ICdncHQtNG8tbWluaS1yZWFsdGltZS1wcmV2aWV3J1xuICAgIHwgJ2dwdC00by1taW5pLXJlYWx0aW1lLXByZXZpZXctMjAyNC0xMi0xNyc7XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgb2YgaW5wdXQgYXVkaW8uIE9wdGlvbnMgYXJlIGBwY20xNmAsIGBnNzExX3VsYXdgLCBvciBgZzcxMV9hbGF3YC5cbiAgICovXG4gIGlucHV0X2F1ZGlvX2Zvcm1hdD86ICdwY20xNicgfCAnZzcxMV91bGF3JyB8ICdnNzExX2FsYXcnO1xuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciBpbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uLCBkZWZhdWx0cyB0byBvZmYgYW5kIGNhbiBiZSBzZXQgdG9cbiAgICogYG51bGxgIHRvIHR1cm4gb2ZmIG9uY2Ugb24uIElucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24gaXMgbm90IG5hdGl2ZSB0byB0aGVcbiAgICogbW9kZWwsIHNpbmNlIHRoZSBtb2RlbCBjb25zdW1lcyBhdWRpbyBkaXJlY3RseS4gVHJhbnNjcmlwdGlvbiBydW5zXG4gICAqIGFzeW5jaHJvbm91c2x5IHRocm91Z2ggV2hpc3BlciBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgcm91Z2ggZ3VpZGFuY2UgcmF0aGVyXG4gICAqIHRoYW4gdGhlIHJlcHJlc2VudGF0aW9uIHVuZGVyc3Rvb2QgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbj86IFNlc3Npb25DcmVhdGVQYXJhbXMuSW5wdXRBdWRpb1RyYW5zY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHN5c3RlbSBpbnN0cnVjdGlvbnMgKGkuZS4gc3lzdGVtIG1lc3NhZ2UpIHByZXBlbmRlZCB0byBtb2RlbCBjYWxscy5cbiAgICogVGhpcyBmaWVsZCBhbGxvd3MgdGhlIGNsaWVudCB0byBndWlkZSB0aGUgbW9kZWwgb24gZGVzaXJlZCByZXNwb25zZXMuIFRoZSBtb2RlbFxuICAgKiBjYW4gYmUgaW5zdHJ1Y3RlZCBvbiByZXNwb25zZSBjb250ZW50IGFuZCBmb3JtYXQsIChlLmcuIFwiYmUgZXh0cmVtZWx5IHN1Y2NpbmN0XCIsXG4gICAqIFwiYWN0IGZyaWVuZGx5XCIsIFwiaGVyZSBhcmUgZXhhbXBsZXMgb2YgZ29vZCByZXNwb25zZXNcIikgYW5kIG9uIGF1ZGlvIGJlaGF2aW9yXG4gICAqIChlLmcuIFwidGFsayBxdWlja2x5XCIsIFwiaW5qZWN0IGVtb3Rpb24gaW50byB5b3VyIHZvaWNlXCIsIFwibGF1Z2ggZnJlcXVlbnRseVwiKS4gVGhlXG4gICAqIGluc3RydWN0aW9ucyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gYmUgZm9sbG93ZWQgYnkgdGhlIG1vZGVsLCBidXQgdGhleSBwcm92aWRlXG4gICAqIGd1aWRhbmNlIHRvIHRoZSBtb2RlbCBvbiB0aGUgZGVzaXJlZCBiZWhhdmlvci5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBzZXJ2ZXIgc2V0cyBkZWZhdWx0IGluc3RydWN0aW9ucyB3aGljaCB3aWxsIGJlIHVzZWQgaWYgdGhpcyBmaWVsZFxuICAgKiBpcyBub3Qgc2V0IGFuZCBhcmUgdmlzaWJsZSBpbiB0aGUgYHNlc3Npb24uY3JlYXRlZGAgZXZlbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZVxuICAgKiBzZXNzaW9uLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiBvdXRwdXQgdG9rZW5zIGZvciBhIHNpbmdsZSBhc3Npc3RhbnQgcmVzcG9uc2UsIGluY2x1c2l2ZSBvZlxuICAgKiB0b29sIGNhbGxzLiBQcm92aWRlIGFuIGludGVnZXIgYmV0d2VlbiAxIGFuZCA0MDk2IHRvIGxpbWl0IG91dHB1dCB0b2tlbnMsIG9yXG4gICAqIGBpbmZgIGZvciB0aGUgbWF4aW11bSBhdmFpbGFibGUgdG9rZW5zIGZvciBhIGdpdmVuIG1vZGVsLiBEZWZhdWx0cyB0byBgaW5mYC5cbiAgICovXG4gIG1heF9yZXNwb25zZV9vdXRwdXRfdG9rZW5zPzogbnVtYmVyIHwgJ2luZic7XG5cbiAgLyoqXG4gICAqIFRoZSBzZXQgb2YgbW9kYWxpdGllcyB0aGUgbW9kZWwgY2FuIHJlc3BvbmQgd2l0aC4gVG8gZGlzYWJsZSBhdWRpbywgc2V0IHRoaXMgdG9cbiAgICogW1widGV4dFwiXS5cbiAgICovXG4gIG1vZGFsaXRpZXM/OiBBcnJheTwndGV4dCcgfCAnYXVkaW8nPjtcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCBvZiBvdXRwdXQgYXVkaW8uIE9wdGlvbnMgYXJlIGBwY20xNmAsIGBnNzExX3VsYXdgLCBvciBgZzcxMV9hbGF3YC5cbiAgICovXG4gIG91dHB1dF9hdWRpb19mb3JtYXQ/OiAncGNtMTYnIHwgJ2c3MTFfdWxhdycgfCAnZzcxMV9hbGF3JztcblxuICAvKipcbiAgICogU2FtcGxpbmcgdGVtcGVyYXR1cmUgZm9yIHRoZSBtb2RlbCwgbGltaXRlZCB0byBbMC42LCAxLjJdLiBEZWZhdWx0cyB0byAwLjguXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcblxuICAvKipcbiAgICogSG93IHRoZSBtb2RlbCBjaG9vc2VzIHRvb2xzLiBPcHRpb25zIGFyZSBgYXV0b2AsIGBub25lYCwgYHJlcXVpcmVkYCwgb3Igc3BlY2lmeVxuICAgKiBhIGZ1bmN0aW9uLlxuICAgKi9cbiAgdG9vbF9jaG9pY2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRvb2xzIChmdW5jdGlvbnMpIGF2YWlsYWJsZSB0byB0aGUgbW9kZWwuXG4gICAqL1xuICB0b29scz86IEFycmF5PFNlc3Npb25DcmVhdGVQYXJhbXMuVG9vbD47XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gZm9yIHR1cm4gZGV0ZWN0aW9uLiBDYW4gYmUgc2V0IHRvIGBudWxsYCB0byB0dXJuIG9mZi4gU2VydmVyIFZBRFxuICAgKiBtZWFucyB0aGF0IHRoZSBtb2RlbCB3aWxsIGRldGVjdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiBzcGVlY2ggYmFzZWQgb24gYXVkaW9cbiAgICogdm9sdW1lIGFuZCByZXNwb25kIGF0IHRoZSBlbmQgb2YgdXNlciBzcGVlY2guXG4gICAqL1xuICB0dXJuX2RldGVjdGlvbj86IFNlc3Npb25DcmVhdGVQYXJhbXMuVHVybkRldGVjdGlvbjtcblxuICAvKipcbiAgICogVGhlIHZvaWNlIHRoZSBtb2RlbCB1c2VzIHRvIHJlc3BvbmQuIFZvaWNlIGNhbm5vdCBiZSBjaGFuZ2VkIGR1cmluZyB0aGUgc2Vzc2lvblxuICAgKiBvbmNlIHRoZSBtb2RlbCBoYXMgcmVzcG9uZGVkIHdpdGggYXVkaW8gYXQgbGVhc3Qgb25jZS4gQ3VycmVudCB2b2ljZSBvcHRpb25zIGFyZVxuICAgKiBgYWxsb3lgLCBgYXNoYCwgYGJhbGxhZGAsIGBjb3JhbGAsIGBlY2hvYCBgc2FnZWAsIGBzaGltbWVyYCBhbmQgYHZlcnNlYC5cbiAgICovXG4gIHZvaWNlPzogJ2FsbG95JyB8ICdhc2gnIHwgJ2JhbGxhZCcgfCAnY29yYWwnIHwgJ2VjaG8nIHwgJ3NhZ2UnIHwgJ3NoaW1tZXInIHwgJ3ZlcnNlJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBTZXNzaW9uQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gZm9yIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24sIGRlZmF1bHRzIHRvIG9mZiBhbmQgY2FuIGJlIHNldCB0b1xuICAgKiBgbnVsbGAgdG8gdHVybiBvZmYgb25jZSBvbi4gSW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiBpcyBub3QgbmF0aXZlIHRvIHRoZVxuICAgKiBtb2RlbCwgc2luY2UgdGhlIG1vZGVsIGNvbnN1bWVzIGF1ZGlvIGRpcmVjdGx5LiBUcmFuc2NyaXB0aW9uIHJ1bnNcbiAgICogYXN5bmNocm9ub3VzbHkgdGhyb3VnaCBXaGlzcGVyIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyByb3VnaCBndWlkYW5jZSByYXRoZXJcbiAgICogdGhhbiB0aGUgcmVwcmVzZW50YXRpb24gdW5kZXJzdG9vZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9UcmFuc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwgdG8gdXNlIGZvciB0cmFuc2NyaXB0aW9uLCBgd2hpc3Blci0xYCBpcyB0aGUgb25seSBjdXJyZW50bHkgc3VwcG9ydGVkXG4gICAgICogbW9kZWwuXG4gICAgICovXG4gICAgbW9kZWw/OiBzdHJpbmc7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFRvb2wge1xuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgZnVuY3Rpb24sIGluY2x1ZGluZyBndWlkYW5jZSBvbiB3aGVuIGFuZCBob3cgdG8gY2FsbCBpdCxcbiAgICAgKiBhbmQgZ3VpZGFuY2UgYWJvdXQgd2hhdCB0byB0ZWxsIHRoZSB1c2VyIHdoZW4gY2FsbGluZyAoaWYgYW55dGhpbmcpLlxuICAgICAqL1xuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG5hbWU/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBQYXJhbWV0ZXJzIG9mIHRoZSBmdW5jdGlvbiBpbiBKU09OIFNjaGVtYS5cbiAgICAgKi9cbiAgICBwYXJhbWV0ZXJzPzogdW5rbm93bjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSB0b29sLCBpLmUuIGBmdW5jdGlvbmAuXG4gICAgICovXG4gICAgdHlwZT86ICdmdW5jdGlvbic7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgdHVybiBkZXRlY3Rpb24uIENhbiBiZSBzZXQgdG8gYG51bGxgIHRvIHR1cm4gb2ZmLiBTZXJ2ZXIgVkFEXG4gICAqIG1lYW5zIHRoYXQgdGhlIG1vZGVsIHdpbGwgZGV0ZWN0IHRoZSBzdGFydCBhbmQgZW5kIG9mIHNwZWVjaCBiYXNlZCBvbiBhdWRpb1xuICAgKiB2b2x1bWUgYW5kIHJlc3BvbmQgYXQgdGhlIGVuZCBvZiB1c2VyIHNwZWVjaC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVHVybkRldGVjdGlvbiB7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdG8gYXV0b21hdGljYWxseSBnZW5lcmF0ZSBhIHJlc3BvbnNlIHdoZW4gVkFEIGlzIGVuYWJsZWQuIGB0cnVlYFxuICAgICAqIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgY3JlYXRlX3Jlc3BvbnNlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEFtb3VudCBvZiBhdWRpbyB0byBpbmNsdWRlIGJlZm9yZSB0aGUgVkFEIGRldGVjdGVkIHNwZWVjaCAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICAgKiBEZWZhdWx0cyB0byAzMDBtcy5cbiAgICAgKi9cbiAgICBwcmVmaXhfcGFkZGluZ19tcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIER1cmF0aW9uIG9mIHNpbGVuY2UgdG8gZGV0ZWN0IHNwZWVjaCBzdG9wIChpbiBtaWxsaXNlY29uZHMpLiBEZWZhdWx0cyB0byA1MDBtcy5cbiAgICAgKiBXaXRoIHNob3J0ZXIgdmFsdWVzIHRoZSBtb2RlbCB3aWxsIHJlc3BvbmQgbW9yZSBxdWlja2x5LCBidXQgbWF5IGp1bXAgaW4gb25cbiAgICAgKiBzaG9ydCBwYXVzZXMgZnJvbSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBzaWxlbmNlX2R1cmF0aW9uX21zPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGlvbiB0aHJlc2hvbGQgZm9yIFZBRCAoMC4wIHRvIDEuMCksIHRoaXMgZGVmYXVsdHMgdG8gMC41LiBBIGhpZ2hlclxuICAgICAqIHRocmVzaG9sZCB3aWxsIHJlcXVpcmUgbG91ZGVyIGF1ZGlvIHRvIGFjdGl2YXRlIHRoZSBtb2RlbCwgYW5kIHRodXMgbWlnaHRcbiAgICAgKiBwZXJmb3JtIGJldHRlciBpbiBub2lzeSBlbnZpcm9ubWVudHMuXG4gICAgICovXG4gICAgdGhyZXNob2xkPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiB0dXJuIGRldGVjdGlvbiwgb25seSBgc2VydmVyX3ZhZGAgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICB0eXBlPzogc3RyaW5nO1xuICB9XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBTZXNzaW9ucyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBTZXNzaW9uIGFzIFNlc3Npb24sXG4gICAgdHlwZSBTZXNzaW9uQ3JlYXRlUmVzcG9uc2UgYXMgU2Vzc2lvbkNyZWF0ZVJlc3BvbnNlLFxuICAgIHR5cGUgU2Vzc2lvbkNyZWF0ZVBhcmFtcyBhcyBTZXNzaW9uQ3JlYXRlUGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgUmVhbHRpbWVBUEkgZnJvbSAnLi9yZWFsdGltZSc7XG5pbXBvcnQgKiBhcyBTZXNzaW9uc0FQSSBmcm9tICcuL3Nlc3Npb25zJztcbmltcG9ydCB7XG4gIFNlc3Npb24gYXMgU2Vzc2lvbnNBUElTZXNzaW9uLFxuICBTZXNzaW9uQ3JlYXRlUGFyYW1zLFxuICBTZXNzaW9uQ3JlYXRlUmVzcG9uc2UsXG4gIFNlc3Npb25zLFxufSBmcm9tICcuL3Nlc3Npb25zJztcblxuZXhwb3J0IGNsYXNzIFJlYWx0aW1lIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICBzZXNzaW9uczogU2Vzc2lvbnNBUEkuU2Vzc2lvbnMgPSBuZXcgU2Vzc2lvbnNBUEkuU2Vzc2lvbnModGhpcy5fY2xpZW50KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGEgY29udmVyc2F0aW9uIGlzIGNyZWF0ZWQuIEVtaXR0ZWQgcmlnaHQgYWZ0ZXIgc2Vzc2lvbiBjcmVhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb25DcmVhdGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIGNvbnZlcnNhdGlvbiByZXNvdXJjZS5cbiAgICovXG4gIGNvbnZlcnNhdGlvbjogQ29udmVyc2F0aW9uQ3JlYXRlZEV2ZW50LkNvbnZlcnNhdGlvbjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGNvbnZlcnNhdGlvbi5jcmVhdGVkYC5cbiAgICovXG4gIHR5cGU6ICdjb252ZXJzYXRpb24uY3JlYXRlZCc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29udmVyc2F0aW9uQ3JlYXRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBjb252ZXJzYXRpb24gcmVzb3VyY2UuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgY29udmVyc2F0aW9uLlxuICAgICAqL1xuICAgIGlkPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCB0eXBlLCBtdXN0IGJlIGByZWFsdGltZS5jb252ZXJzYXRpb25gLlxuICAgICAqL1xuICAgIG9iamVjdD86ICdyZWFsdGltZS5jb252ZXJzYXRpb24nO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGl0ZW0gdG8gYWRkIHRvIHRoZSBjb252ZXJzYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uSXRlbSB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBpdGVtLCB0aGlzIGNhbiBiZSBnZW5lcmF0ZWQgYnkgdGhlIGNsaWVudCB0byBoZWxwIG1hbmFnZVxuICAgKiBzZXJ2ZXItc2lkZSBjb250ZXh0LCBidXQgaXMgbm90IHJlcXVpcmVkIGJlY2F1c2UgdGhlIHNlcnZlciB3aWxsIGdlbmVyYXRlIG9uZSBpZlxuICAgKiBub3QgcHJvdmlkZWQuXG4gICAqL1xuICBpZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGFyZ3VtZW50cyBvZiB0aGUgZnVuY3Rpb24gY2FsbCAoZm9yIGBmdW5jdGlvbl9jYWxsYCBpdGVtcykuXG4gICAqL1xuICBhcmd1bWVudHM/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgZnVuY3Rpb24gY2FsbCAoZm9yIGBmdW5jdGlvbl9jYWxsYCBhbmQgYGZ1bmN0aW9uX2NhbGxfb3V0cHV0YFxuICAgKiBpdGVtcykuIElmIHBhc3NlZCBvbiBhIGBmdW5jdGlvbl9jYWxsX291dHB1dGAgaXRlbSwgdGhlIHNlcnZlciB3aWxsIGNoZWNrIHRoYXQgYVxuICAgKiBgZnVuY3Rpb25fY2FsbGAgaXRlbSB3aXRoIHRoZSBzYW1lIElEIGV4aXN0cyBpbiB0aGUgY29udmVyc2F0aW9uIGhpc3RvcnkuXG4gICAqL1xuICBjYWxsX2lkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZSwgYXBwbGljYWJsZSBmb3IgYG1lc3NhZ2VgIGl0ZW1zLlxuICAgKlxuICAgKiAtIE1lc3NhZ2UgaXRlbXMgb2Ygcm9sZSBgc3lzdGVtYCBzdXBwb3J0IG9ubHkgYGlucHV0X3RleHRgIGNvbnRlbnRcbiAgICogLSBNZXNzYWdlIGl0ZW1zIG9mIHJvbGUgYHVzZXJgIHN1cHBvcnQgYGlucHV0X3RleHRgIGFuZCBgaW5wdXRfYXVkaW9gIGNvbnRlbnRcbiAgICogLSBNZXNzYWdlIGl0ZW1zIG9mIHJvbGUgYGFzc2lzdGFudGAgc3VwcG9ydCBgdGV4dGAgY29udGVudC5cbiAgICovXG4gIGNvbnRlbnQ/OiBBcnJheTxDb252ZXJzYXRpb25JdGVtQ29udGVudD47XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiBiZWluZyBjYWxsZWQgKGZvciBgZnVuY3Rpb25fY2FsbGAgaXRlbXMpLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogSWRlbnRpZmllciBmb3IgdGhlIEFQSSBvYmplY3QgYmVpbmcgcmV0dXJuZWQgLSBhbHdheXMgYHJlYWx0aW1lLml0ZW1gLlxuICAgKi9cbiAgb2JqZWN0PzogJ3JlYWx0aW1lLml0ZW0nO1xuXG4gIC8qKlxuICAgKiBUaGUgb3V0cHV0IG9mIHRoZSBmdW5jdGlvbiBjYWxsIChmb3IgYGZ1bmN0aW9uX2NhbGxfb3V0cHV0YCBpdGVtcykuXG4gICAqL1xuICBvdXRwdXQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSByb2xlIG9mIHRoZSBtZXNzYWdlIHNlbmRlciAoYHVzZXJgLCBgYXNzaXN0YW50YCwgYHN5c3RlbWApLCBvbmx5IGFwcGxpY2FibGVcbiAgICogZm9yIGBtZXNzYWdlYCBpdGVtcy5cbiAgICovXG4gIHJvbGU/OiAndXNlcicgfCAnYXNzaXN0YW50JyB8ICdzeXN0ZW0nO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhdHVzIG9mIHRoZSBpdGVtIChgY29tcGxldGVkYCwgYGluY29tcGxldGVgKS4gVGhlc2UgaGF2ZSBubyBlZmZlY3Qgb24gdGhlXG4gICAqIGNvbnZlcnNhdGlvbiwgYnV0IGFyZSBhY2NlcHRlZCBmb3IgY29uc2lzdGVuY3kgd2l0aCB0aGVcbiAgICogYGNvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZWRgIGV2ZW50LlxuICAgKi9cbiAgc3RhdHVzPzogJ2NvbXBsZXRlZCcgfCAnaW5jb21wbGV0ZSc7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBpdGVtIChgbWVzc2FnZWAsIGBmdW5jdGlvbl9jYWxsYCwgYGZ1bmN0aW9uX2NhbGxfb3V0cHV0YCkuXG4gICAqL1xuICB0eXBlPzogJ21lc3NhZ2UnIHwgJ2Z1bmN0aW9uX2NhbGwnIHwgJ2Z1bmN0aW9uX2NhbGxfb3V0cHV0Jztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb25JdGVtQ29udGVudCB7XG4gIC8qKlxuICAgKiBJRCBvZiBhIHByZXZpb3VzIGNvbnZlcnNhdGlvbiBpdGVtIHRvIHJlZmVyZW5jZSAoZm9yIGBpdGVtX3JlZmVyZW5jZWAgY29udGVudFxuICAgKiB0eXBlcyBpbiBgcmVzcG9uc2UuY3JlYXRlYCBldmVudHMpLiBUaGVzZSBjYW4gcmVmZXJlbmNlIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXJcbiAgICogY3JlYXRlZCBpdGVtcy5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBCYXNlNjQtZW5jb2RlZCBhdWRpbyBieXRlcywgdXNlZCBmb3IgYGlucHV0X2F1ZGlvYCBjb250ZW50IHR5cGUuXG4gICAqL1xuICBhdWRpbz86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHRleHQgY29udGVudCwgdXNlZCBmb3IgYGlucHV0X3RleHRgIGFuZCBgdGV4dGAgY29udGVudCB0eXBlcy5cbiAgICovXG4gIHRleHQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0cmFuc2NyaXB0IG9mIHRoZSBhdWRpbywgdXNlZCBmb3IgYGlucHV0X2F1ZGlvYCBjb250ZW50IHR5cGUuXG4gICAqL1xuICB0cmFuc2NyaXB0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCB0eXBlIChgaW5wdXRfdGV4dGAsIGBpbnB1dF9hdWRpb2AsIGBpdGVtX3JlZmVyZW5jZWAsIGB0ZXh0YCkuXG4gICAqL1xuICB0eXBlPzogJ2lucHV0X3RleHQnIHwgJ2lucHV0X2F1ZGlvJyB8ICdpdGVtX3JlZmVyZW5jZScgfCAndGV4dCc7XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IEl0ZW0gdG8gdGhlIENvbnZlcnNhdGlvbidzIGNvbnRleHQsIGluY2x1ZGluZyBtZXNzYWdlcywgZnVuY3Rpb25cbiAqIGNhbGxzLCBhbmQgZnVuY3Rpb24gY2FsbCByZXNwb25zZXMuIFRoaXMgZXZlbnQgY2FuIGJlIHVzZWQgYm90aCB0byBwb3B1bGF0ZSBhXG4gKiBcImhpc3RvcnlcIiBvZiB0aGUgY29udmVyc2F0aW9uIGFuZCB0byBhZGQgbmV3IGl0ZW1zIG1pZC1zdHJlYW0sIGJ1dCBoYXMgdGhlXG4gKiBjdXJyZW50IGxpbWl0YXRpb24gdGhhdCBpdCBjYW5ub3QgcG9wdWxhdGUgYXNzaXN0YW50IGF1ZGlvIG1lc3NhZ2VzLlxuICpcbiAqIElmIHN1Y2Nlc3NmdWwsIHRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kIHdpdGggYSBgY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlZGAgZXZlbnQsXG4gKiBvdGhlcndpc2UgYW4gYGVycm9yYCBldmVudCB3aWxsIGJlIHNlbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uSXRlbUNyZWF0ZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpdGVtIHRvIGFkZCB0byB0aGUgY29udmVyc2F0aW9uLlxuICAgKi9cbiAgaXRlbTogQ29udmVyc2F0aW9uSXRlbTtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGNvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZWAuXG4gICAqL1xuICB0eXBlOiAnY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlJztcblxuICAvKipcbiAgICogT3B0aW9uYWwgY2xpZW50LWdlbmVyYXRlZCBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBwcmVjZWRpbmcgaXRlbSBhZnRlciB3aGljaCB0aGUgbmV3IGl0ZW0gd2lsbCBiZSBpbnNlcnRlZC4gSWYgbm90XG4gICAqIHNldCwgdGhlIG5ldyBpdGVtIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgY29udmVyc2F0aW9uLiBJZiBzZXQsIGl0XG4gICAqIGFsbG93cyBhbiBpdGVtIHRvIGJlIGluc2VydGVkIG1pZC1jb252ZXJzYXRpb24uIElmIHRoZSBJRCBjYW5ub3QgYmUgZm91bmQsIGFuXG4gICAqIGVycm9yIHdpbGwgYmUgcmV0dXJuZWQgYW5kIHRoZSBpdGVtIHdpbGwgbm90IGJlIGFkZGVkLlxuICAgKi9cbiAgcHJldmlvdXNfaXRlbV9pZD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGEgY29udmVyc2F0aW9uIGl0ZW0gaXMgY3JlYXRlZC4gVGhlcmUgYXJlIHNldmVyYWwgc2NlbmFyaW9zIHRoYXRcbiAqIHByb2R1Y2UgdGhpcyBldmVudDpcbiAqXG4gKiAtIFRoZSBzZXJ2ZXIgaXMgZ2VuZXJhdGluZyBhIFJlc3BvbnNlLCB3aGljaCBpZiBzdWNjZXNzZnVsIHdpbGwgcHJvZHVjZSBlaXRoZXJcbiAqICAgb25lIG9yIHR3byBJdGVtcywgd2hpY2ggd2lsbCBiZSBvZiB0eXBlIGBtZXNzYWdlYCAocm9sZSBgYXNzaXN0YW50YCkgb3IgdHlwZVxuICogICBgZnVuY3Rpb25fY2FsbGAuXG4gKiAtIFRoZSBpbnB1dCBhdWRpbyBidWZmZXIgaGFzIGJlZW4gY29tbWl0dGVkLCBlaXRoZXIgYnkgdGhlIGNsaWVudCBvciB0aGUgc2VydmVyXG4gKiAgIChpbiBgc2VydmVyX3ZhZGAgbW9kZSkuIFRoZSBzZXJ2ZXIgd2lsbCB0YWtlIHRoZSBjb250ZW50IG9mIHRoZSBpbnB1dCBhdWRpb1xuICogICBidWZmZXIgYW5kIGFkZCBpdCB0byBhIG5ldyB1c2VyIG1lc3NhZ2UgSXRlbS5cbiAqIC0gVGhlIGNsaWVudCBoYXMgc2VudCBhIGBjb252ZXJzYXRpb24uaXRlbS5jcmVhdGVgIGV2ZW50IHRvIGFkZCBhIG5ldyBJdGVtIHRvXG4gKiAgIHRoZSBDb252ZXJzYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uSXRlbUNyZWF0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICovXG4gIGl0ZW06IENvbnZlcnNhdGlvbkl0ZW07XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcHJlY2VkaW5nIGl0ZW0gaW4gdGhlIENvbnZlcnNhdGlvbiBjb250ZXh0LCBhbGxvd3MgdGhlIGNsaWVudCB0b1xuICAgKiB1bmRlcnN0YW5kIHRoZSBvcmRlciBvZiB0aGUgY29udmVyc2F0aW9uLlxuICAgKi9cbiAgcHJldmlvdXNfaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlZGAuXG4gICAqL1xuICB0eXBlOiAnY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlZCc7XG59XG5cbi8qKlxuICogU2VuZCB0aGlzIGV2ZW50IHdoZW4geW91IHdhbnQgdG8gcmVtb3ZlIGFueSBpdGVtIGZyb20gdGhlIGNvbnZlcnNhdGlvbiBoaXN0b3J5LlxuICogVGhlIHNlcnZlciB3aWxsIHJlc3BvbmQgd2l0aCBhIGBjb252ZXJzYXRpb24uaXRlbS5kZWxldGVkYCBldmVudCwgdW5sZXNzIHRoZVxuICogaXRlbSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY29udmVyc2F0aW9uIGhpc3RvcnksIGluIHdoaWNoIGNhc2UgdGhlIHNlcnZlciB3aWxsXG4gKiByZXNwb25kIHdpdGggYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uSXRlbURlbGV0ZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgaXRlbSB0byBkZWxldGUuXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBjb252ZXJzYXRpb24uaXRlbS5kZWxldGVgLlxuICAgKi9cbiAgdHlwZTogJ2NvbnZlcnNhdGlvbi5pdGVtLmRlbGV0ZSc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGNsaWVudC1nZW5lcmF0ZWQgSUQgdXNlZCB0byBpZGVudGlmeSB0aGlzIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhbiBpdGVtIGluIHRoZSBjb252ZXJzYXRpb24gaXMgZGVsZXRlZCBieSB0aGUgY2xpZW50IHdpdGggYVxuICogYGNvbnZlcnNhdGlvbi5pdGVtLmRlbGV0ZWAgZXZlbnQuIFRoaXMgZXZlbnQgaXMgdXNlZCB0byBzeW5jaHJvbml6ZSB0aGUgc2VydmVyJ3NcbiAqIHVuZGVyc3RhbmRpbmcgb2YgdGhlIGNvbnZlcnNhdGlvbiBoaXN0b3J5IHdpdGggdGhlIGNsaWVudCdzIHZpZXcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uSXRlbURlbGV0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGl0ZW0gdGhhdCB3YXMgZGVsZXRlZC5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGNvbnZlcnNhdGlvbi5pdGVtLmRlbGV0ZWRgLlxuICAgKi9cbiAgdHlwZTogJ2NvbnZlcnNhdGlvbi5pdGVtLmRlbGV0ZWQnO1xufVxuXG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgdGhlIG91dHB1dCBvZiBhdWRpbyB0cmFuc2NyaXB0aW9uIGZvciB1c2VyIGF1ZGlvIHdyaXR0ZW4gdG8gdGhlXG4gKiB1c2VyIGF1ZGlvIGJ1ZmZlci4gVHJhbnNjcmlwdGlvbiBiZWdpbnMgd2hlbiB0aGUgaW5wdXQgYXVkaW8gYnVmZmVyIGlzIGNvbW1pdHRlZFxuICogYnkgdGhlIGNsaWVudCBvciBzZXJ2ZXIgKGluIGBzZXJ2ZXJfdmFkYCBtb2RlKS4gVHJhbnNjcmlwdGlvbiBydW5zXG4gKiBhc3luY2hyb25vdXNseSB3aXRoIFJlc3BvbnNlIGNyZWF0aW9uLCBzbyB0aGlzIGV2ZW50IG1heSBjb21lIGJlZm9yZSBvciBhZnRlclxuICogdGhlIFJlc3BvbnNlIGV2ZW50cy5cbiAqXG4gKiBSZWFsdGltZSBBUEkgbW9kZWxzIGFjY2VwdCBhdWRpbyBuYXRpdmVseSwgYW5kIHRodXMgaW5wdXQgdHJhbnNjcmlwdGlvbiBpcyBhXG4gKiBzZXBhcmF0ZSBwcm9jZXNzIHJ1biBvbiBhIHNlcGFyYXRlIEFTUiAoQXV0b21hdGljIFNwZWVjaCBSZWNvZ25pdGlvbikgbW9kZWwsXG4gKiBjdXJyZW50bHkgYWx3YXlzIGB3aGlzcGVyLTFgLiBUaHVzIHRoZSB0cmFuc2NyaXB0IG1heSBkaXZlcmdlIHNvbWV3aGF0IGZyb20gdGhlXG4gKiBtb2RlbCdzIGludGVycHJldGF0aW9uLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSByb3VnaCBndWlkZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb25JdGVtSW5wdXRBdWRpb1RyYW5zY3JpcHRpb25Db21wbGV0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCBjb250YWluaW5nIHRoZSBhdWRpby5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB1c2VyIG1lc3NhZ2UgaXRlbSBjb250YWluaW5nIHRoZSBhdWRpby5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHRyYW5zY3JpYmVkIHRleHQuXG4gICAqL1xuICB0cmFuc2NyaXB0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBjb252ZXJzYXRpb24uaXRlbS5pbnB1dF9hdWRpb190cmFuc2NyaXB0aW9uLmNvbXBsZXRlZGAuXG4gICAqL1xuICB0eXBlOiAnY29udmVyc2F0aW9uLml0ZW0uaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbi5jb21wbGV0ZWQnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiBpcyBjb25maWd1cmVkLCBhbmQgYSB0cmFuc2NyaXB0aW9uXG4gKiByZXF1ZXN0IGZvciBhIHVzZXIgbWVzc2FnZSBmYWlsZWQuIFRoZXNlIGV2ZW50cyBhcmUgc2VwYXJhdGUgZnJvbSBvdGhlciBgZXJyb3JgXG4gKiBldmVudHMgc28gdGhhdCB0aGUgY2xpZW50IGNhbiBpZGVudGlmeSB0aGUgcmVsYXRlZCBJdGVtLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbkl0ZW1JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbkZhaWxlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGNvbnRhaW5pbmcgdGhlIGF1ZGlvLlxuICAgKi9cbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBEZXRhaWxzIG9mIHRoZSB0cmFuc2NyaXB0aW9uIGVycm9yLlxuICAgKi9cbiAgZXJyb3I6IENvbnZlcnNhdGlvbkl0ZW1JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbkZhaWxlZEV2ZW50LkVycm9yO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHVzZXIgbWVzc2FnZSBpdGVtLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgY29udmVyc2F0aW9uLml0ZW0uaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbi5mYWlsZWRgLlxuICAgKi9cbiAgdHlwZTogJ2NvbnZlcnNhdGlvbi5pdGVtLmlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24uZmFpbGVkJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDb252ZXJzYXRpb25JdGVtSW5wdXRBdWRpb1RyYW5zY3JpcHRpb25GYWlsZWRFdmVudCB7XG4gIC8qKlxuICAgKiBEZXRhaWxzIG9mIHRoZSB0cmFuc2NyaXB0aW9uIGVycm9yLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBFcnJvciB7XG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSwgaWYgYW55LlxuICAgICAqL1xuICAgIGNvZGU/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgbWVzc2FnZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFBhcmFtZXRlciByZWxhdGVkIHRvIHRoZSBlcnJvciwgaWYgYW55LlxuICAgICAqL1xuICAgIHBhcmFtPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgZXJyb3IuXG4gICAgICovXG4gICAgdHlwZT86IHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIFNlbmQgdGhpcyBldmVudCB0byB0cnVuY2F0ZSBhIHByZXZpb3VzIGFzc2lzdGFudCBtZXNzYWdlXHUyMDE5cyBhdWRpby4gVGhlIHNlcnZlclxuICogd2lsbCBwcm9kdWNlIGF1ZGlvIGZhc3RlciB0aGFuIHJlYWx0aW1lLCBzbyB0aGlzIGV2ZW50IGlzIHVzZWZ1bCB3aGVuIHRoZSB1c2VyXG4gKiBpbnRlcnJ1cHRzIHRvIHRydW5jYXRlIGF1ZGlvIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBzZW50IHRvIHRoZSBjbGllbnQgYnV0IG5vdFxuICogeWV0IHBsYXllZC4gVGhpcyB3aWxsIHN5bmNocm9uaXplIHRoZSBzZXJ2ZXIncyB1bmRlcnN0YW5kaW5nIG9mIHRoZSBhdWRpbyB3aXRoXG4gKiB0aGUgY2xpZW50J3MgcGxheWJhY2suXG4gKlxuICogVHJ1bmNhdGluZyBhdWRpbyB3aWxsIGRlbGV0ZSB0aGUgc2VydmVyLXNpZGUgdGV4dCB0cmFuc2NyaXB0IHRvIGVuc3VyZSB0aGVyZSBpc1xuICogbm90IHRleHQgaW4gdGhlIGNvbnRleHQgdGhhdCBoYXNuJ3QgYmVlbiBoZWFyZCBieSB0aGUgdXNlci5cbiAqXG4gKiBJZiBzdWNjZXNzZnVsLCB0aGUgc2VydmVyIHdpbGwgcmVzcG9uZCB3aXRoIGEgYGNvbnZlcnNhdGlvbi5pdGVtLnRydW5jYXRlZGBcbiAqIGV2ZW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbkl0ZW1UcnVuY2F0ZUV2ZW50IHtcbiAgLyoqXG4gICAqIEluY2x1c2l2ZSBkdXJhdGlvbiB1cCB0byB3aGljaCBhdWRpbyBpcyB0cnVuY2F0ZWQsIGluIG1pbGxpc2Vjb25kcy4gSWYgdGhlXG4gICAqIGF1ZGlvX2VuZF9tcyBpcyBncmVhdGVyIHRoYW4gdGhlIGFjdHVhbCBhdWRpbyBkdXJhdGlvbiwgdGhlIHNlcnZlciB3aWxsIHJlc3BvbmRcbiAgICogd2l0aCBhbiBlcnJvci5cbiAgICovXG4gIGF1ZGlvX2VuZF9tczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCB0byB0cnVuY2F0ZS4gU2V0IHRoaXMgdG8gMC5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBhc3Npc3RhbnQgbWVzc2FnZSBpdGVtIHRvIHRydW5jYXRlLiBPbmx5IGFzc2lzdGFudCBtZXNzYWdlIGl0ZW1zXG4gICAqIGNhbiBiZSB0cnVuY2F0ZWQuXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBjb252ZXJzYXRpb24uaXRlbS50cnVuY2F0ZWAuXG4gICAqL1xuICB0eXBlOiAnY29udmVyc2F0aW9uLml0ZW0udHJ1bmNhdGUnO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjbGllbnQtZ2VuZXJhdGVkIElEIHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYW4gZWFybGllciBhc3Npc3RhbnQgYXVkaW8gbWVzc2FnZSBpdGVtIGlzIHRydW5jYXRlZCBieSB0aGUgY2xpZW50XG4gKiB3aXRoIGEgYGNvbnZlcnNhdGlvbi5pdGVtLnRydW5jYXRlYCBldmVudC4gVGhpcyBldmVudCBpcyB1c2VkIHRvIHN5bmNocm9uaXplIHRoZVxuICogc2VydmVyJ3MgdW5kZXJzdGFuZGluZyBvZiB0aGUgYXVkaW8gd2l0aCB0aGUgY2xpZW50J3MgcGxheWJhY2suXG4gKlxuICogVGhpcyBhY3Rpb24gd2lsbCB0cnVuY2F0ZSB0aGUgYXVkaW8gYW5kIHJlbW92ZSB0aGUgc2VydmVyLXNpZGUgdGV4dCB0cmFuc2NyaXB0XG4gKiB0byBlbnN1cmUgdGhlcmUgaXMgbm8gdGV4dCBpbiB0aGUgY29udGV4dCB0aGF0IGhhc24ndCBiZWVuIGhlYXJkIGJ5IHRoZSB1c2VyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbkl0ZW1UcnVuY2F0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24gdXAgdG8gd2hpY2ggdGhlIGF1ZGlvIHdhcyB0cnVuY2F0ZWQsIGluIG1pbGxpc2Vjb25kcy5cbiAgICovXG4gIGF1ZGlvX2VuZF9tczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCB0aGF0IHdhcyB0cnVuY2F0ZWQuXG4gICAqL1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgYXNzaXN0YW50IG1lc3NhZ2UgaXRlbSB0aGF0IHdhcyB0cnVuY2F0ZWQuXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBjb252ZXJzYXRpb24uaXRlbS50cnVuY2F0ZWRgLlxuICAgKi9cbiAgdHlwZTogJ2NvbnZlcnNhdGlvbi5pdGVtLnRydW5jYXRlZCc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMsIHdoaWNoIGNvdWxkIGJlIGEgY2xpZW50IHByb2JsZW0gb3IgYSBzZXJ2ZXJcbiAqIHByb2JsZW0uIE1vc3QgZXJyb3JzIGFyZSByZWNvdmVyYWJsZSBhbmQgdGhlIHNlc3Npb24gd2lsbCBzdGF5IG9wZW4sIHdlXG4gKiByZWNvbW1lbmQgdG8gaW1wbGVtZW50b3JzIHRvIG1vbml0b3IgYW5kIGxvZyBlcnJvciBtZXNzYWdlcyBieSBkZWZhdWx0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yRXZlbnQge1xuICAvKipcbiAgICogRGV0YWlscyBvZiB0aGUgZXJyb3IuXG4gICAqL1xuICBlcnJvcjogRXJyb3JFdmVudC5FcnJvcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGVycm9yYC5cbiAgICovXG4gIHR5cGU6ICdlcnJvcic7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRXJyb3JFdmVudCB7XG4gIC8qKlxuICAgKiBEZXRhaWxzIG9mIHRoZSBlcnJvci5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEEgaHVtYW4tcmVhZGFibGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBtZXNzYWdlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBlcnJvciAoZS5nLiwgXCJpbnZhbGlkX3JlcXVlc3RfZXJyb3JcIiwgXCJzZXJ2ZXJfZXJyb3JcIikuXG4gICAgICovXG4gICAgdHlwZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSwgaWYgYW55LlxuICAgICAqL1xuICAgIGNvZGU/OiBzdHJpbmcgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50X2lkIG9mIHRoZSBjbGllbnQgZXZlbnQgdGhhdCBjYXVzZWQgdGhlIGVycm9yLCBpZiBhcHBsaWNhYmxlLlxuICAgICAqL1xuICAgIGV2ZW50X2lkPzogc3RyaW5nIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFBhcmFtZXRlciByZWxhdGVkIHRvIHRoZSBlcnJvciwgaWYgYW55LlxuICAgICAqL1xuICAgIHBhcmFtPzogc3RyaW5nIHwgbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFNlbmQgdGhpcyBldmVudCB0byBhcHBlbmQgYXVkaW8gYnl0ZXMgdG8gdGhlIGlucHV0IGF1ZGlvIGJ1ZmZlci4gVGhlIGF1ZGlvXG4gKiBidWZmZXIgaXMgdGVtcG9yYXJ5IHN0b3JhZ2UgeW91IGNhbiB3cml0ZSB0byBhbmQgbGF0ZXIgY29tbWl0LiBJbiBTZXJ2ZXIgVkFEXG4gKiBtb2RlLCB0aGUgYXVkaW8gYnVmZmVyIGlzIHVzZWQgdG8gZGV0ZWN0IHNwZWVjaCBhbmQgdGhlIHNlcnZlciB3aWxsIGRlY2lkZSB3aGVuXG4gKiB0byBjb21taXQuIFdoZW4gU2VydmVyIFZBRCBpcyBkaXNhYmxlZCwgeW91IG11c3QgY29tbWl0IHRoZSBhdWRpbyBidWZmZXJcbiAqIG1hbnVhbGx5LlxuICpcbiAqIFRoZSBjbGllbnQgbWF5IGNob29zZSBob3cgbXVjaCBhdWRpbyB0byBwbGFjZSBpbiBlYWNoIGV2ZW50IHVwIHRvIGEgbWF4aW11bSBvZlxuICogMTUgTWlCLCBmb3IgZXhhbXBsZSBzdHJlYW1pbmcgc21hbGxlciBjaHVua3MgZnJvbSB0aGUgY2xpZW50IG1heSBhbGxvdyB0aGUgVkFEXG4gKiB0byBiZSBtb3JlIHJlc3BvbnNpdmUuIFVubGlrZSBtYWRlIG90aGVyIGNsaWVudCBldmVudHMsIHRoZSBzZXJ2ZXIgd2lsbCBub3Qgc2VuZFxuICogYSBjb25maXJtYXRpb24gcmVzcG9uc2UgdG8gdGhpcyBldmVudC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvQnVmZmVyQXBwZW5kRXZlbnQge1xuICAvKipcbiAgICogQmFzZTY0LWVuY29kZWQgYXVkaW8gYnl0ZXMuIFRoaXMgbXVzdCBiZSBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSB0aGVcbiAgICogYGlucHV0X2F1ZGlvX2Zvcm1hdGAgZmllbGQgaW4gdGhlIHNlc3Npb24gY29uZmlndXJhdGlvbi5cbiAgICovXG4gIGF1ZGlvOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBpbnB1dF9hdWRpb19idWZmZXIuYXBwZW5kYC5cbiAgICovXG4gIHR5cGU6ICdpbnB1dF9hdWRpb19idWZmZXIuYXBwZW5kJztcblxuICAvKipcbiAgICogT3B0aW9uYWwgY2xpZW50LWdlbmVyYXRlZCBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBTZW5kIHRoaXMgZXZlbnQgdG8gY2xlYXIgdGhlIGF1ZGlvIGJ5dGVzIGluIHRoZSBidWZmZXIuIFRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kXG4gKiB3aXRoIGFuIGBpbnB1dF9hdWRpb19idWZmZXIuY2xlYXJlZGAgZXZlbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb0J1ZmZlckNsZWFyRXZlbnQge1xuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGlucHV0X2F1ZGlvX2J1ZmZlci5jbGVhcmAuXG4gICAqL1xuICB0eXBlOiAnaW5wdXRfYXVkaW9fYnVmZmVyLmNsZWFyJztcblxuICAvKipcbiAgICogT3B0aW9uYWwgY2xpZW50LWdlbmVyYXRlZCBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIHRoZSBpbnB1dCBhdWRpbyBidWZmZXIgaXMgY2xlYXJlZCBieSB0aGUgY2xpZW50IHdpdGggYVxuICogYGlucHV0X2F1ZGlvX2J1ZmZlci5jbGVhcmAgZXZlbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb0J1ZmZlckNsZWFyZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgaW5wdXRfYXVkaW9fYnVmZmVyLmNsZWFyZWRgLlxuICAgKi9cbiAgdHlwZTogJ2lucHV0X2F1ZGlvX2J1ZmZlci5jbGVhcmVkJztcbn1cblxuLyoqXG4gKiBTZW5kIHRoaXMgZXZlbnQgdG8gY29tbWl0IHRoZSB1c2VyIGlucHV0IGF1ZGlvIGJ1ZmZlciwgd2hpY2ggd2lsbCBjcmVhdGUgYSBuZXdcbiAqIHVzZXIgbWVzc2FnZSBpdGVtIGluIHRoZSBjb252ZXJzYXRpb24uIFRoaXMgZXZlbnQgd2lsbCBwcm9kdWNlIGFuIGVycm9yIGlmIHRoZVxuICogaW5wdXQgYXVkaW8gYnVmZmVyIGlzIGVtcHR5LiBXaGVuIGluIFNlcnZlciBWQUQgbW9kZSwgdGhlIGNsaWVudCBkb2VzIG5vdCBuZWVkXG4gKiB0byBzZW5kIHRoaXMgZXZlbnQsIHRoZSBzZXJ2ZXIgd2lsbCBjb21taXQgdGhlIGF1ZGlvIGJ1ZmZlciBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIENvbW1pdHRpbmcgdGhlIGlucHV0IGF1ZGlvIGJ1ZmZlciB3aWxsIHRyaWdnZXIgaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiAoaWZcbiAqIGVuYWJsZWQgaW4gc2Vzc2lvbiBjb25maWd1cmF0aW9uKSwgYnV0IGl0IHdpbGwgbm90IGNyZWF0ZSBhIHJlc3BvbnNlIGZyb20gdGhlXG4gKiBtb2RlbC4gVGhlIHNlcnZlciB3aWxsIHJlc3BvbmQgd2l0aCBhbiBgaW5wdXRfYXVkaW9fYnVmZmVyLmNvbW1pdHRlZGAgZXZlbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb0J1ZmZlckNvbW1pdEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBpbnB1dF9hdWRpb19idWZmZXIuY29tbWl0YC5cbiAgICovXG4gIHR5cGU6ICdpbnB1dF9hdWRpb19idWZmZXIuY29tbWl0JztcblxuICAvKipcbiAgICogT3B0aW9uYWwgY2xpZW50LWdlbmVyYXRlZCBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGFuIGlucHV0IGF1ZGlvIGJ1ZmZlciBpcyBjb21taXR0ZWQsIGVpdGhlciBieSB0aGUgY2xpZW50IG9yXG4gKiBhdXRvbWF0aWNhbGx5IGluIHNlcnZlciBWQUQgbW9kZS4gVGhlIGBpdGVtX2lkYCBwcm9wZXJ0eSBpcyB0aGUgSUQgb2YgdGhlIHVzZXJcbiAqIG1lc3NhZ2UgaXRlbSB0aGF0IHdpbGwgYmUgY3JlYXRlZCwgdGh1cyBhIGBjb252ZXJzYXRpb24uaXRlbS5jcmVhdGVkYCBldmVudCB3aWxsXG4gKiBhbHNvIGJlIHNlbnQgdG8gdGhlIGNsaWVudC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvQnVmZmVyQ29tbWl0dGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB1c2VyIG1lc3NhZ2UgaXRlbSB0aGF0IHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBwcmVjZWRpbmcgaXRlbSBhZnRlciB3aGljaCB0aGUgbmV3IGl0ZW0gd2lsbCBiZSBpbnNlcnRlZC5cbiAgICovXG4gIHByZXZpb3VzX2l0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGlucHV0X2F1ZGlvX2J1ZmZlci5jb21taXR0ZWRgLlxuICAgKi9cbiAgdHlwZTogJ2lucHV0X2F1ZGlvX2J1ZmZlci5jb21taXR0ZWQnO1xufVxuXG4vKipcbiAqIFNlbnQgYnkgdGhlIHNlcnZlciB3aGVuIGluIGBzZXJ2ZXJfdmFkYCBtb2RlIHRvIGluZGljYXRlIHRoYXQgc3BlZWNoIGhhcyBiZWVuXG4gKiBkZXRlY3RlZCBpbiB0aGUgYXVkaW8gYnVmZmVyLiBUaGlzIGNhbiBoYXBwZW4gYW55IHRpbWUgYXVkaW8gaXMgYWRkZWQgdG8gdGhlXG4gKiBidWZmZXIgKHVubGVzcyBzcGVlY2ggaXMgYWxyZWFkeSBkZXRlY3RlZCkuIFRoZSBjbGllbnQgbWF5IHdhbnQgdG8gdXNlIHRoaXNcbiAqIGV2ZW50IHRvIGludGVycnVwdCBhdWRpbyBwbGF5YmFjayBvciBwcm92aWRlIHZpc3VhbCBmZWVkYmFjayB0byB0aGUgdXNlci5cbiAqXG4gKiBUaGUgY2xpZW50IHNob3VsZCBleHBlY3QgdG8gcmVjZWl2ZSBhIGBpbnB1dF9hdWRpb19idWZmZXIuc3BlZWNoX3N0b3BwZWRgIGV2ZW50XG4gKiB3aGVuIHNwZWVjaCBzdG9wcy4gVGhlIGBpdGVtX2lkYCBwcm9wZXJ0eSBpcyB0aGUgSUQgb2YgdGhlIHVzZXIgbWVzc2FnZSBpdGVtXG4gKiB0aGF0IHdpbGwgYmUgY3JlYXRlZCB3aGVuIHNwZWVjaCBzdG9wcyBhbmQgd2lsbCBhbHNvIGJlIGluY2x1ZGVkIGluIHRoZVxuICogYGlucHV0X2F1ZGlvX2J1ZmZlci5zcGVlY2hfc3RvcHBlZGAgZXZlbnQgKHVubGVzcyB0aGUgY2xpZW50IG1hbnVhbGx5IGNvbW1pdHNcbiAqIHRoZSBhdWRpbyBidWZmZXIgZHVyaW5nIFZBRCBhY3RpdmF0aW9uKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvQnVmZmVyU3BlZWNoU3RhcnRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIE1pbGxpc2Vjb25kcyBmcm9tIHRoZSBzdGFydCBvZiBhbGwgYXVkaW8gd3JpdHRlbiB0byB0aGUgYnVmZmVyIGR1cmluZyB0aGVcbiAgICogc2Vzc2lvbiB3aGVuIHNwZWVjaCB3YXMgZmlyc3QgZGV0ZWN0ZWQuIFRoaXMgd2lsbCBjb3JyZXNwb25kIHRvIHRoZSBiZWdpbm5pbmcgb2ZcbiAgICogYXVkaW8gc2VudCB0byB0aGUgbW9kZWwsIGFuZCB0aHVzIGluY2x1ZGVzIHRoZSBgcHJlZml4X3BhZGRpbmdfbXNgIGNvbmZpZ3VyZWQgaW5cbiAgICogdGhlIFNlc3Npb24uXG4gICAqL1xuICBhdWRpb19zdGFydF9tczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHVzZXIgbWVzc2FnZSBpdGVtIHRoYXQgd2lsbCBiZSBjcmVhdGVkIHdoZW4gc3BlZWNoIHN0b3BzLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgaW5wdXRfYXVkaW9fYnVmZmVyLnNwZWVjaF9zdGFydGVkYC5cbiAgICovXG4gIHR5cGU6ICdpbnB1dF9hdWRpb19idWZmZXIuc3BlZWNoX3N0YXJ0ZWQnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIGluIGBzZXJ2ZXJfdmFkYCBtb2RlIHdoZW4gdGhlIHNlcnZlciBkZXRlY3RzIHRoZSBlbmQgb2Ygc3BlZWNoIGluIHRoZVxuICogYXVkaW8gYnVmZmVyLiBUaGUgc2VydmVyIHdpbGwgYWxzbyBzZW5kIGFuIGBjb252ZXJzYXRpb24uaXRlbS5jcmVhdGVkYCBldmVudFxuICogd2l0aCB0aGUgdXNlciBtZXNzYWdlIGl0ZW0gdGhhdCBpcyBjcmVhdGVkIGZyb20gdGhlIGF1ZGlvIGJ1ZmZlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvQnVmZmVyU3BlZWNoU3RvcHBlZEV2ZW50IHtcbiAgLyoqXG4gICAqIE1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgc2Vzc2lvbiBzdGFydGVkIHdoZW4gc3BlZWNoIHN0b3BwZWQuIFRoaXMgd2lsbCBjb3JyZXNwb25kXG4gICAqIHRvIHRoZSBlbmQgb2YgYXVkaW8gc2VudCB0byB0aGUgbW9kZWwsIGFuZCB0aHVzIGluY2x1ZGVzIHRoZVxuICAgKiBgbWluX3NpbGVuY2VfZHVyYXRpb25fbXNgIGNvbmZpZ3VyZWQgaW4gdGhlIFNlc3Npb24uXG4gICAqL1xuICBhdWRpb19lbmRfbXM6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB1c2VyIG1lc3NhZ2UgaXRlbSB0aGF0IHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGlucHV0X2F1ZGlvX2J1ZmZlci5zcGVlY2hfc3RvcHBlZGAuXG4gICAqL1xuICB0eXBlOiAnaW5wdXRfYXVkaW9fYnVmZmVyLnNwZWVjaF9zdG9wcGVkJztcbn1cblxuLyoqXG4gKiBFbWl0dGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBSZXNwb25zZSB0byBpbmRpY2F0ZSB0aGUgdXBkYXRlZCByYXRlIGxpbWl0cy4gV2hlblxuICogYSBSZXNwb25zZSBpcyBjcmVhdGVkIHNvbWUgdG9rZW5zIHdpbGwgYmUgXCJyZXNlcnZlZFwiIGZvciB0aGUgb3V0cHV0IHRva2VucywgdGhlXG4gKiByYXRlIGxpbWl0cyBzaG93biBoZXJlIHJlZmxlY3QgdGhhdCByZXNlcnZhdGlvbiwgd2hpY2ggaXMgdGhlbiBhZGp1c3RlZFxuICogYWNjb3JkaW5nbHkgb25jZSB0aGUgUmVzcG9uc2UgaXMgY29tcGxldGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJhdGVMaW1pdHNVcGRhdGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogTGlzdCBvZiByYXRlIGxpbWl0IGluZm9ybWF0aW9uLlxuICAgKi9cbiAgcmF0ZV9saW1pdHM6IEFycmF5PFJhdGVMaW1pdHNVcGRhdGVkRXZlbnQuUmF0ZUxpbWl0PjtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJhdGVfbGltaXRzLnVwZGF0ZWRgLlxuICAgKi9cbiAgdHlwZTogJ3JhdGVfbGltaXRzLnVwZGF0ZWQnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJhdGVMaW1pdHNVcGRhdGVkRXZlbnQge1xuICBleHBvcnQgaW50ZXJmYWNlIFJhdGVMaW1pdCB7XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSBmb3IgdGhlIHJhdGUgbGltaXQuXG4gICAgICovXG4gICAgbGltaXQ/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcmF0ZSBsaW1pdCAoYHJlcXVlc3RzYCwgYHRva2Vuc2ApLlxuICAgICAqL1xuICAgIG5hbWU/OiAncmVxdWVzdHMnIHwgJ3Rva2Vucyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVtYWluaW5nIHZhbHVlIGJlZm9yZSB0aGUgbGltaXQgaXMgcmVhY2hlZC5cbiAgICAgKi9cbiAgICByZW1haW5pbmc/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmRzIHVudGlsIHRoZSByYXRlIGxpbWl0IHJlc2V0cy5cbiAgICAgKi9cbiAgICByZXNldF9zZWNvbmRzPzogbnVtYmVyO1xuICB9XG59XG5cbi8qKlxuICogQWxsIGV2ZW50cyB0aGF0IHRoZSBjbGllbnQgY2FuIHNlbmQgdG8gdGhlIFJlYWx0aW1lIEFQSVxuICovXG5leHBvcnQgdHlwZSBSZWFsdGltZUNsaWVudEV2ZW50ID1cbiAgfCBTZXNzaW9uVXBkYXRlRXZlbnRcbiAgfCBJbnB1dEF1ZGlvQnVmZmVyQXBwZW5kRXZlbnRcbiAgfCBJbnB1dEF1ZGlvQnVmZmVyQ29tbWl0RXZlbnRcbiAgfCBJbnB1dEF1ZGlvQnVmZmVyQ2xlYXJFdmVudFxuICB8IENvbnZlcnNhdGlvbkl0ZW1DcmVhdGVFdmVudFxuICB8IENvbnZlcnNhdGlvbkl0ZW1UcnVuY2F0ZUV2ZW50XG4gIHwgQ29udmVyc2F0aW9uSXRlbURlbGV0ZUV2ZW50XG4gIHwgUmVzcG9uc2VDcmVhdGVFdmVudFxuICB8IFJlc3BvbnNlQ2FuY2VsRXZlbnQ7XG5cbi8qKlxuICogVGhlIHJlc3BvbnNlIHJlc291cmNlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlYWx0aW1lUmVzcG9uc2Uge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBpZD86IHN0cmluZztcblxuICAvKipcbiAgICogRGV2ZWxvcGVyLXByb3ZpZGVkIHN0cmluZyBrZXktdmFsdWUgcGFpcnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmVzcG9uc2UuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIG11c3QgYmUgYHJlYWx0aW1lLnJlc3BvbnNlYC5cbiAgICovXG4gIG9iamVjdD86ICdyZWFsdGltZS5yZXNwb25zZSc7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIG91dHB1dCBpdGVtcyBnZW5lcmF0ZWQgYnkgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0PzogQXJyYXk8Q29udmVyc2F0aW9uSXRlbT47XG5cbiAgLyoqXG4gICAqIFRoZSBmaW5hbCBzdGF0dXMgb2YgdGhlIHJlc3BvbnNlIChgY29tcGxldGVkYCwgYGNhbmNlbGxlZGAsIGBmYWlsZWRgLCBvclxuICAgKiBgaW5jb21wbGV0ZWApLlxuICAgKi9cbiAgc3RhdHVzPzogJ2NvbXBsZXRlZCcgfCAnY2FuY2VsbGVkJyB8ICdmYWlsZWQnIHwgJ2luY29tcGxldGUnO1xuXG4gIC8qKlxuICAgKiBBZGRpdGlvbmFsIGRldGFpbHMgYWJvdXQgdGhlIHN0YXR1cy5cbiAgICovXG4gIHN0YXR1c19kZXRhaWxzPzogUmVhbHRpbWVSZXNwb25zZVN0YXR1cztcblxuICAvKipcbiAgICogVXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIFJlc3BvbnNlLCB0aGlzIHdpbGwgY29ycmVzcG9uZCB0byBiaWxsaW5nLiBBIFJlYWx0aW1lXG4gICAqIEFQSSBzZXNzaW9uIHdpbGwgbWFpbnRhaW4gYSBjb252ZXJzYXRpb24gY29udGV4dCBhbmQgYXBwZW5kIG5ldyBJdGVtcyB0byB0aGVcbiAgICogQ29udmVyc2F0aW9uLCB0aHVzIG91dHB1dCBmcm9tIHByZXZpb3VzIHR1cm5zICh0ZXh0IGFuZCBhdWRpbyB0b2tlbnMpIHdpbGxcbiAgICogYmVjb21lIHRoZSBpbnB1dCBmb3IgbGF0ZXIgdHVybnMuXG4gICAqL1xuICB1c2FnZT86IFJlYWx0aW1lUmVzcG9uc2VVc2FnZTtcbn1cblxuLyoqXG4gKiBBZGRpdGlvbmFsIGRldGFpbHMgYWJvdXQgdGhlIHN0YXR1cy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWFsdGltZVJlc3BvbnNlU3RhdHVzIHtcbiAgLyoqXG4gICAqIEEgZGVzY3JpcHRpb24gb2YgdGhlIGVycm9yIHRoYXQgY2F1c2VkIHRoZSByZXNwb25zZSB0byBmYWlsLCBwb3B1bGF0ZWQgd2hlbiB0aGVcbiAgICogYHN0YXR1c2AgaXMgYGZhaWxlZGAuXG4gICAqL1xuICBlcnJvcj86IFJlYWx0aW1lUmVzcG9uc2VTdGF0dXMuRXJyb3I7XG5cbiAgLyoqXG4gICAqIFRoZSByZWFzb24gdGhlIFJlc3BvbnNlIGRpZCBub3QgY29tcGxldGUuIEZvciBhIGBjYW5jZWxsZWRgIFJlc3BvbnNlLCBvbmUgb2ZcbiAgICogYHR1cm5fZGV0ZWN0ZWRgICh0aGUgc2VydmVyIFZBRCBkZXRlY3RlZCBhIG5ldyBzdGFydCBvZiBzcGVlY2gpIG9yXG4gICAqIGBjbGllbnRfY2FuY2VsbGVkYCAodGhlIGNsaWVudCBzZW50IGEgY2FuY2VsIGV2ZW50KS4gRm9yIGFuIGBpbmNvbXBsZXRlYFxuICAgKiBSZXNwb25zZSwgb25lIG9mIGBtYXhfb3V0cHV0X3Rva2Vuc2Agb3IgYGNvbnRlbnRfZmlsdGVyYCAodGhlIHNlcnZlci1zaWRlIHNhZmV0eVxuICAgKiBmaWx0ZXIgYWN0aXZhdGVkIGFuZCBjdXQgb2ZmIHRoZSByZXNwb25zZSkuXG4gICAqL1xuICByZWFzb24/OiAndHVybl9kZXRlY3RlZCcgfCAnY2xpZW50X2NhbmNlbGxlZCcgfCAnbWF4X291dHB1dF90b2tlbnMnIHwgJ2NvbnRlbnRfZmlsdGVyJztcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXJyb3IgdGhhdCBjYXVzZWQgdGhlIHJlc3BvbnNlIHRvIGZhaWwsIGNvcnJlc3BvbmRpbmcgd2l0aCB0aGVcbiAgICogYHN0YXR1c2AgZmllbGQgKGBjb21wbGV0ZWRgLCBgY2FuY2VsbGVkYCwgYGluY29tcGxldGVgLCBgZmFpbGVkYCkuXG4gICAqL1xuICB0eXBlPzogJ2NvbXBsZXRlZCcgfCAnY2FuY2VsbGVkJyB8ICdpbmNvbXBsZXRlJyB8ICdmYWlsZWQnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJlYWx0aW1lUmVzcG9uc2VTdGF0dXMge1xuICAvKipcbiAgICogQSBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3IgdGhhdCBjYXVzZWQgdGhlIHJlc3BvbnNlIHRvIGZhaWwsIHBvcHVsYXRlZCB3aGVuIHRoZVxuICAgKiBgc3RhdHVzYCBpcyBgZmFpbGVkYC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUsIGlmIGFueS5cbiAgICAgKi9cbiAgICBjb2RlPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgZXJyb3IuXG4gICAgICovXG4gICAgdHlwZT86IHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBSZXNwb25zZSwgdGhpcyB3aWxsIGNvcnJlc3BvbmQgdG8gYmlsbGluZy4gQSBSZWFsdGltZVxuICogQVBJIHNlc3Npb24gd2lsbCBtYWludGFpbiBhIGNvbnZlcnNhdGlvbiBjb250ZXh0IGFuZCBhcHBlbmQgbmV3IEl0ZW1zIHRvIHRoZVxuICogQ29udmVyc2F0aW9uLCB0aHVzIG91dHB1dCBmcm9tIHByZXZpb3VzIHR1cm5zICh0ZXh0IGFuZCBhdWRpbyB0b2tlbnMpIHdpbGxcbiAqIGJlY29tZSB0aGUgaW5wdXQgZm9yIGxhdGVyIHR1cm5zLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlYWx0aW1lUmVzcG9uc2VVc2FnZSB7XG4gIC8qKlxuICAgKiBEZXRhaWxzIGFib3V0IHRoZSBpbnB1dCB0b2tlbnMgdXNlZCBpbiB0aGUgUmVzcG9uc2UuXG4gICAqL1xuICBpbnB1dF90b2tlbl9kZXRhaWxzPzogUmVhbHRpbWVSZXNwb25zZVVzYWdlLklucHV0VG9rZW5EZXRhaWxzO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGlucHV0IHRva2VucyB1c2VkIGluIHRoZSBSZXNwb25zZSwgaW5jbHVkaW5nIHRleHQgYW5kIGF1ZGlvXG4gICAqIHRva2Vucy5cbiAgICovXG4gIGlucHV0X3Rva2Vucz86IG51bWJlcjtcblxuICAvKipcbiAgICogRGV0YWlscyBhYm91dCB0aGUgb3V0cHV0IHRva2VucyB1c2VkIGluIHRoZSBSZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF90b2tlbl9kZXRhaWxzPzogUmVhbHRpbWVSZXNwb25zZVVzYWdlLk91dHB1dFRva2VuRGV0YWlscztcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBvdXRwdXQgdG9rZW5zIHNlbnQgaW4gdGhlIFJlc3BvbnNlLCBpbmNsdWRpbmcgdGV4dCBhbmQgYXVkaW9cbiAgICogdG9rZW5zLlxuICAgKi9cbiAgb3V0cHV0X3Rva2Vucz86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHRvdGFsIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIFJlc3BvbnNlIGluY2x1ZGluZyBpbnB1dCBhbmQgb3V0cHV0IHRleHQgYW5kXG4gICAqIGF1ZGlvIHRva2Vucy5cbiAgICovXG4gIHRvdGFsX3Rva2Vucz86IG51bWJlcjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSZWFsdGltZVJlc3BvbnNlVXNhZ2Uge1xuICAvKipcbiAgICogRGV0YWlscyBhYm91dCB0aGUgaW5wdXQgdG9rZW5zIHVzZWQgaW4gdGhlIFJlc3BvbnNlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBJbnB1dFRva2VuRGV0YWlscyB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBhdWRpbyB0b2tlbnMgdXNlZCBpbiB0aGUgUmVzcG9uc2UuXG4gICAgICovXG4gICAgYXVkaW9fdG9rZW5zPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBjYWNoZWQgdG9rZW5zIHVzZWQgaW4gdGhlIFJlc3BvbnNlLlxuICAgICAqL1xuICAgIGNhY2hlZF90b2tlbnM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRleHQgdG9rZW5zIHVzZWQgaW4gdGhlIFJlc3BvbnNlLlxuICAgICAqL1xuICAgIHRleHRfdG9rZW5zPzogbnVtYmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFpbHMgYWJvdXQgdGhlIG91dHB1dCB0b2tlbnMgdXNlZCBpbiB0aGUgUmVzcG9uc2UuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIE91dHB1dFRva2VuRGV0YWlscyB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBhdWRpbyB0b2tlbnMgdXNlZCBpbiB0aGUgUmVzcG9uc2UuXG4gICAgICovXG4gICAgYXVkaW9fdG9rZW5zPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiB0ZXh0IHRva2VucyB1c2VkIGluIHRoZSBSZXNwb25zZS5cbiAgICAgKi9cbiAgICB0ZXh0X3Rva2Vucz86IG51bWJlcjtcbiAgfVxufVxuXG4vKipcbiAqIEFsbCBldmVudHMgdGhhdCB0aGUgUmVhbHRpbWUgQVBJIGNhbiBzZW5kIGJhY2tcbiAqL1xuZXhwb3J0IHR5cGUgUmVhbHRpbWVTZXJ2ZXJFdmVudCA9XG4gIHwgRXJyb3JFdmVudFxuICB8IFNlc3Npb25DcmVhdGVkRXZlbnRcbiAgfCBTZXNzaW9uVXBkYXRlZEV2ZW50XG4gIHwgQ29udmVyc2F0aW9uQ3JlYXRlZEV2ZW50XG4gIHwgSW5wdXRBdWRpb0J1ZmZlckNvbW1pdHRlZEV2ZW50XG4gIHwgSW5wdXRBdWRpb0J1ZmZlckNsZWFyZWRFdmVudFxuICB8IElucHV0QXVkaW9CdWZmZXJTcGVlY2hTdGFydGVkRXZlbnRcbiAgfCBJbnB1dEF1ZGlvQnVmZmVyU3BlZWNoU3RvcHBlZEV2ZW50XG4gIHwgQ29udmVyc2F0aW9uSXRlbUNyZWF0ZWRFdmVudFxuICB8IENvbnZlcnNhdGlvbkl0ZW1JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbkNvbXBsZXRlZEV2ZW50XG4gIHwgQ29udmVyc2F0aW9uSXRlbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uRmFpbGVkRXZlbnRcbiAgfCBDb252ZXJzYXRpb25JdGVtVHJ1bmNhdGVkRXZlbnRcbiAgfCBDb252ZXJzYXRpb25JdGVtRGVsZXRlZEV2ZW50XG4gIHwgUmVzcG9uc2VDcmVhdGVkRXZlbnRcbiAgfCBSZXNwb25zZURvbmVFdmVudFxuICB8IFJlc3BvbnNlT3V0cHV0SXRlbUFkZGVkRXZlbnRcbiAgfCBSZXNwb25zZU91dHB1dEl0ZW1Eb25lRXZlbnRcbiAgfCBSZXNwb25zZUNvbnRlbnRQYXJ0QWRkZWRFdmVudFxuICB8IFJlc3BvbnNlQ29udGVudFBhcnREb25lRXZlbnRcbiAgfCBSZXNwb25zZVRleHREZWx0YUV2ZW50XG4gIHwgUmVzcG9uc2VUZXh0RG9uZUV2ZW50XG4gIHwgUmVzcG9uc2VBdWRpb1RyYW5zY3JpcHREZWx0YUV2ZW50XG4gIHwgUmVzcG9uc2VBdWRpb1RyYW5zY3JpcHREb25lRXZlbnRcbiAgfCBSZXNwb25zZUF1ZGlvRGVsdGFFdmVudFxuICB8IFJlc3BvbnNlQXVkaW9Eb25lRXZlbnRcbiAgfCBSZXNwb25zZUZ1bmN0aW9uQ2FsbEFyZ3VtZW50c0RlbHRhRXZlbnRcbiAgfCBSZXNwb25zZUZ1bmN0aW9uQ2FsbEFyZ3VtZW50c0RvbmVFdmVudFxuICB8IFJhdGVMaW1pdHNVcGRhdGVkRXZlbnQ7XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiB0aGUgbW9kZWwtZ2VuZXJhdGVkIGF1ZGlvIGlzIHVwZGF0ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VBdWRpb0RlbHRhRXZlbnQge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgaW4gdGhlIGl0ZW0ncyBjb250ZW50IGFycmF5LlxuICAgKi9cbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBCYXNlNjQtZW5jb2RlZCBhdWRpbyBkYXRhIGRlbHRhLlxuICAgKi9cbiAgZGVsdGE6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBpdGVtLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSByZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLmF1ZGlvLmRlbHRhYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5hdWRpby5kZWx0YSc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiB0aGUgbW9kZWwtZ2VuZXJhdGVkIGF1ZGlvIGlzIGRvbmUuIEFsc28gZW1pdHRlZCB3aGVuIGEgUmVzcG9uc2UgaXNcbiAqIGludGVycnVwdGVkLCBpbmNvbXBsZXRlLCBvciBjYW5jZWxsZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VBdWRpb0RvbmVFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCBpbiB0aGUgaXRlbSdzIGNvbnRlbnQgYXJyYXkuXG4gICAqL1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgaXRlbS5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaXRlbSBpbiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSByZXNwb25zZS5cbiAgICovXG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5hdWRpby5kb25lYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5hdWRpby5kb25lJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIHRoZSBtb2RlbC1nZW5lcmF0ZWQgdHJhbnNjcmlwdGlvbiBvZiBhdWRpbyBvdXRwdXQgaXMgdXBkYXRlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUF1ZGlvVHJhbnNjcmlwdERlbHRhRXZlbnQge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgaW4gdGhlIGl0ZW0ncyBjb250ZW50IGFycmF5LlxuICAgKi9cbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNjcmlwdCBkZWx0YS5cbiAgICovXG4gIGRlbHRhOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgaXRlbS5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaXRlbSBpbiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSByZXNwb25zZS5cbiAgICovXG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5hdWRpb190cmFuc2NyaXB0LmRlbHRhYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5hdWRpb190cmFuc2NyaXB0LmRlbHRhJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIHRoZSBtb2RlbC1nZW5lcmF0ZWQgdHJhbnNjcmlwdGlvbiBvZiBhdWRpbyBvdXRwdXQgaXMgZG9uZVxuICogc3RyZWFtaW5nLiBBbHNvIGVtaXR0ZWQgd2hlbiBhIFJlc3BvbnNlIGlzIGludGVycnVwdGVkLCBpbmNvbXBsZXRlLCBvclxuICogY2FuY2VsbGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQXVkaW9UcmFuc2NyaXB0RG9uZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGluIHRoZSBpdGVtJ3MgY29udGVudCBhcnJheS5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBpdGVtLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSByZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGZpbmFsIHRyYW5zY3JpcHQgb2YgdGhlIGF1ZGlvLlxuICAgKi9cbiAgdHJhbnNjcmlwdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UuYXVkaW9fdHJhbnNjcmlwdC5kb25lYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5hdWRpb190cmFuc2NyaXB0LmRvbmUnO1xufVxuXG4vKipcbiAqIFNlbmQgdGhpcyBldmVudCB0byBjYW5jZWwgYW4gaW4tcHJvZ3Jlc3MgcmVzcG9uc2UuIFRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kIHdpdGhcbiAqIGEgYHJlc3BvbnNlLmNhbmNlbGxlZGAgZXZlbnQgb3IgYW4gZXJyb3IgaWYgdGhlcmUgaXMgbm8gcmVzcG9uc2UgdG8gY2FuY2VsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQ2FuY2VsRXZlbnQge1xuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLmNhbmNlbGAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UuY2FuY2VsJztcblxuICAvKipcbiAgICogT3B0aW9uYWwgY2xpZW50LWdlbmVyYXRlZCBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZD86IHN0cmluZztcblxuICAvKipcbiAgICogQSBzcGVjaWZpYyByZXNwb25zZSBJRCB0byBjYW5jZWwgLSBpZiBub3QgcHJvdmlkZWQsIHdpbGwgY2FuY2VsIGFuIGluLXByb2dyZXNzXG4gICAqIHJlc3BvbnNlIGluIHRoZSBkZWZhdWx0IGNvbnZlcnNhdGlvbi5cbiAgICovXG4gIHJlc3BvbnNlX2lkPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBuZXcgY29udGVudCBwYXJ0IGlzIGFkZGVkIHRvIGFuIGFzc2lzdGFudCBtZXNzYWdlIGl0ZW0gZHVyaW5nXG4gKiByZXNwb25zZSBnZW5lcmF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQ29udGVudFBhcnRBZGRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGluIHRoZSBpdGVtJ3MgY29udGVudCBhcnJheS5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBpdGVtIHRvIHdoaWNoIHRoZSBjb250ZW50IHBhcnQgd2FzIGFkZGVkLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSByZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBwYXJ0IHRoYXQgd2FzIGFkZGVkLlxuICAgKi9cbiAgcGFydDogUmVzcG9uc2VDb250ZW50UGFydEFkZGVkRXZlbnQuUGFydDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSByZXNwb25zZS5cbiAgICovXG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5jb250ZW50X3BhcnQuYWRkZWRgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLmNvbnRlbnRfcGFydC5hZGRlZCc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUmVzcG9uc2VDb250ZW50UGFydEFkZGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnQgcGFydCB0aGF0IHdhcyBhZGRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgUGFydCB7XG4gICAgLyoqXG4gICAgICogQmFzZTY0LWVuY29kZWQgYXVkaW8gZGF0YSAoaWYgdHlwZSBpcyBcImF1ZGlvXCIpLlxuICAgICAqL1xuICAgIGF1ZGlvPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgY29udGVudCAoaWYgdHlwZSBpcyBcInRleHRcIikuXG4gICAgICovXG4gICAgdGV4dD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2NyaXB0IG9mIHRoZSBhdWRpbyAoaWYgdHlwZSBpcyBcImF1ZGlvXCIpLlxuICAgICAqL1xuICAgIHRyYW5zY3JpcHQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGVudCB0eXBlIChcInRleHRcIiwgXCJhdWRpb1wiKS5cbiAgICAgKi9cbiAgICB0eXBlPzogJ3RleHQnIHwgJ2F1ZGlvJztcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBjb250ZW50IHBhcnQgaXMgZG9uZSBzdHJlYW1pbmcgaW4gYW4gYXNzaXN0YW50IG1lc3NhZ2UgaXRlbS5cbiAqIEFsc28gZW1pdHRlZCB3aGVuIGEgUmVzcG9uc2UgaXMgaW50ZXJydXB0ZWQsIGluY29tcGxldGUsIG9yIGNhbmNlbGxlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUNvbnRlbnRQYXJ0RG9uZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGluIHRoZSBpdGVtJ3MgY29udGVudCBhcnJheS5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBpdGVtLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSByZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBwYXJ0IHRoYXQgaXMgZG9uZS5cbiAgICovXG4gIHBhcnQ6IFJlc3BvbnNlQ29udGVudFBhcnREb25lRXZlbnQuUGFydDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSByZXNwb25zZS5cbiAgICovXG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5jb250ZW50X3BhcnQuZG9uZWAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UuY29udGVudF9wYXJ0LmRvbmUnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJlc3BvbnNlQ29udGVudFBhcnREb25lRXZlbnQge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnQgcGFydCB0aGF0IGlzIGRvbmUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFBhcnQge1xuICAgIC8qKlxuICAgICAqIEJhc2U2NC1lbmNvZGVkIGF1ZGlvIGRhdGEgKGlmIHR5cGUgaXMgXCJhdWRpb1wiKS5cbiAgICAgKi9cbiAgICBhdWRpbz86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IGNvbnRlbnQgKGlmIHR5cGUgaXMgXCJ0ZXh0XCIpLlxuICAgICAqL1xuICAgIHRleHQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNjcmlwdCBvZiB0aGUgYXVkaW8gKGlmIHR5cGUgaXMgXCJhdWRpb1wiKS5cbiAgICAgKi9cbiAgICB0cmFuc2NyaXB0Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRlbnQgdHlwZSAoXCJ0ZXh0XCIsIFwiYXVkaW9cIikuXG4gICAgICovXG4gICAgdHlwZT86ICd0ZXh0JyB8ICdhdWRpbyc7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGV2ZW50IGluc3RydWN0cyB0aGUgc2VydmVyIHRvIGNyZWF0ZSBhIFJlc3BvbnNlLCB3aGljaCBtZWFucyB0cmlnZ2VyaW5nXG4gKiBtb2RlbCBpbmZlcmVuY2UuIFdoZW4gaW4gU2VydmVyIFZBRCBtb2RlLCB0aGUgc2VydmVyIHdpbGwgY3JlYXRlIFJlc3BvbnNlc1xuICogYXV0b21hdGljYWxseS5cbiAqXG4gKiBBIFJlc3BvbnNlIHdpbGwgaW5jbHVkZSBhdCBsZWFzdCBvbmUgSXRlbSwgYW5kIG1heSBoYXZlIHR3bywgaW4gd2hpY2ggY2FzZSB0aGVcbiAqIHNlY29uZCB3aWxsIGJlIGEgZnVuY3Rpb24gY2FsbC4gVGhlc2UgSXRlbXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgY29udmVyc2F0aW9uXG4gKiBoaXN0b3J5LlxuICpcbiAqIFRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kIHdpdGggYSBgcmVzcG9uc2UuY3JlYXRlZGAgZXZlbnQsIGV2ZW50cyBmb3IgSXRlbXMgYW5kXG4gKiBjb250ZW50IGNyZWF0ZWQsIGFuZCBmaW5hbGx5IGEgYHJlc3BvbnNlLmRvbmVgIGV2ZW50IHRvIGluZGljYXRlIHRoZSBSZXNwb25zZSBpc1xuICogY29tcGxldGUuXG4gKlxuICogVGhlIGByZXNwb25zZS5jcmVhdGVgIGV2ZW50IGluY2x1ZGVzIGluZmVyZW5jZSBjb25maWd1cmF0aW9uIGxpa2VcbiAqIGBpbnN0cnVjdGlvbnNgLCBhbmQgYHRlbXBlcmF0dXJlYC4gVGhlc2UgZmllbGRzIHdpbGwgb3ZlcnJpZGUgdGhlIFNlc3Npb24nc1xuICogY29uZmlndXJhdGlvbiBmb3IgdGhpcyBSZXNwb25zZSBvbmx5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQ3JlYXRlRXZlbnQge1xuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLmNyZWF0ZWAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UuY3JlYXRlJztcblxuICAvKipcbiAgICogT3B0aW9uYWwgY2xpZW50LWdlbmVyYXRlZCBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZD86IHN0cmluZztcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFJlYWx0aW1lIHJlc3BvbnNlIHdpdGggdGhlc2UgcGFyYW1ldGVyc1xuICAgKi9cbiAgcmVzcG9uc2U/OiBSZXNwb25zZUNyZWF0ZUV2ZW50LlJlc3BvbnNlO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJlc3BvbnNlQ3JlYXRlRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFJlYWx0aW1lIHJlc3BvbnNlIHdpdGggdGhlc2UgcGFyYW1ldGVyc1xuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZSB7XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgd2hpY2ggY29udmVyc2F0aW9uIHRoZSByZXNwb25zZSBpcyBhZGRlZCB0by4gQ3VycmVudGx5IHN1cHBvcnRzIGBhdXRvYFxuICAgICAqIGFuZCBgbm9uZWAsIHdpdGggYGF1dG9gIGFzIHRoZSBkZWZhdWx0IHZhbHVlLiBUaGUgYGF1dG9gIHZhbHVlIG1lYW5zIHRoYXQgdGhlXG4gICAgICogY29udGVudHMgb2YgdGhlIHJlc3BvbnNlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGRlZmF1bHQgY29udmVyc2F0aW9uLiBTZXQgdGhpcyB0b1xuICAgICAqIGBub25lYCB0byBjcmVhdGUgYW4gb3V0LW9mLWJhbmQgcmVzcG9uc2Ugd2hpY2ggd2lsbCBub3QgYWRkIGl0ZW1zIHRvIGRlZmF1bHRcbiAgICAgKiBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgY29udmVyc2F0aW9uPzogKHN0cmluZyAmIHt9KSB8ICdhdXRvJyB8ICdub25lJztcblxuICAgIC8qKlxuICAgICAqIElucHV0IGl0ZW1zIHRvIGluY2x1ZGUgaW4gdGhlIHByb21wdCBmb3IgdGhlIG1vZGVsLiBDcmVhdGVzIGEgbmV3IGNvbnRleHQgZm9yXG4gICAgICogdGhpcyByZXNwb25zZSwgd2l0aG91dCBpbmNsdWRpbmcgdGhlIGRlZmF1bHQgY29udmVyc2F0aW9uLiBDYW4gaW5jbHVkZVxuICAgICAqIHJlZmVyZW5jZXMgdG8gaXRlbXMgZnJvbSB0aGUgZGVmYXVsdCBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgaW5wdXQ/OiBBcnJheTxSZWFsdGltZUFQSS5Db252ZXJzYXRpb25JdGVtPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHN5c3RlbSBpbnN0cnVjdGlvbnMgKGkuZS4gc3lzdGVtIG1lc3NhZ2UpIHByZXBlbmRlZCB0byBtb2RlbCBjYWxscy5cbiAgICAgKiBUaGlzIGZpZWxkIGFsbG93cyB0aGUgY2xpZW50IHRvIGd1aWRlIHRoZSBtb2RlbCBvbiBkZXNpcmVkIHJlc3BvbnNlcy4gVGhlIG1vZGVsXG4gICAgICogY2FuIGJlIGluc3RydWN0ZWQgb24gcmVzcG9uc2UgY29udGVudCBhbmQgZm9ybWF0LCAoZS5nLiBcImJlIGV4dHJlbWVseSBzdWNjaW5jdFwiLFxuICAgICAqIFwiYWN0IGZyaWVuZGx5XCIsIFwiaGVyZSBhcmUgZXhhbXBsZXMgb2YgZ29vZCByZXNwb25zZXNcIikgYW5kIG9uIGF1ZGlvIGJlaGF2aW9yXG4gICAgICogKGUuZy4gXCJ0YWxrIHF1aWNrbHlcIiwgXCJpbmplY3QgZW1vdGlvbiBpbnRvIHlvdXIgdm9pY2VcIiwgXCJsYXVnaCBmcmVxdWVudGx5XCIpLiBUaGVcbiAgICAgKiBpbnN0cnVjdGlvbnMgYXJlIG5vdCBndWFyYW50ZWVkIHRvIGJlIGZvbGxvd2VkIGJ5IHRoZSBtb2RlbCwgYnV0IHRoZXkgcHJvdmlkZVxuICAgICAqIGd1aWRhbmNlIHRvIHRoZSBtb2RlbCBvbiB0aGUgZGVzaXJlZCBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGUgc2VydmVyIHNldHMgZGVmYXVsdCBpbnN0cnVjdGlvbnMgd2hpY2ggd2lsbCBiZSB1c2VkIGlmIHRoaXMgZmllbGRcbiAgICAgKiBpcyBub3Qgc2V0IGFuZCBhcmUgdmlzaWJsZSBpbiB0aGUgYHNlc3Npb24uY3JlYXRlZGAgZXZlbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAqIHNlc3Npb24uXG4gICAgICovXG4gICAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBudW1iZXIgb2Ygb3V0cHV0IHRva2VucyBmb3IgYSBzaW5nbGUgYXNzaXN0YW50IHJlc3BvbnNlLCBpbmNsdXNpdmUgb2ZcbiAgICAgKiB0b29sIGNhbGxzLiBQcm92aWRlIGFuIGludGVnZXIgYmV0d2VlbiAxIGFuZCA0MDk2IHRvIGxpbWl0IG91dHB1dCB0b2tlbnMsIG9yXG4gICAgICogYGluZmAgZm9yIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSB0b2tlbnMgZm9yIGEgZ2l2ZW4gbW9kZWwuIERlZmF1bHRzIHRvIGBpbmZgLlxuICAgICAqL1xuICAgIG1heF9yZXNwb25zZV9vdXRwdXRfdG9rZW5zPzogbnVtYmVyIHwgJ2luZic7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGltdW0gb2YgNTEyXG4gICAgICogY2hhcmFjdGVycyBsb25nLlxuICAgICAqL1xuICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2V0IG9mIG1vZGFsaXRpZXMgdGhlIG1vZGVsIGNhbiByZXNwb25kIHdpdGguIFRvIGRpc2FibGUgYXVkaW8sIHNldCB0aGlzIHRvXG4gICAgICogW1widGV4dFwiXS5cbiAgICAgKi9cbiAgICBtb2RhbGl0aWVzPzogQXJyYXk8J3RleHQnIHwgJ2F1ZGlvJz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybWF0IG9mIG91dHB1dCBhdWRpby4gT3B0aW9ucyBhcmUgYHBjbTE2YCwgYGc3MTFfdWxhd2AsIG9yIGBnNzExX2FsYXdgLlxuICAgICAqL1xuICAgIG91dHB1dF9hdWRpb19mb3JtYXQ/OiAncGNtMTYnIHwgJ2c3MTFfdWxhdycgfCAnZzcxMV9hbGF3JztcblxuICAgIC8qKlxuICAgICAqIFNhbXBsaW5nIHRlbXBlcmF0dXJlIGZvciB0aGUgbW9kZWwsIGxpbWl0ZWQgdG8gWzAuNiwgMS4yXS4gRGVmYXVsdHMgdG8gMC44LlxuICAgICAqL1xuICAgIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogSG93IHRoZSBtb2RlbCBjaG9vc2VzIHRvb2xzLiBPcHRpb25zIGFyZSBgYXV0b2AsIGBub25lYCwgYHJlcXVpcmVkYCwgb3Igc3BlY2lmeVxuICAgICAqIGEgZnVuY3Rpb24sIGxpa2UgYHtcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifX1gLlxuICAgICAqL1xuICAgIHRvb2xfY2hvaWNlPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVG9vbHMgKGZ1bmN0aW9ucykgYXZhaWxhYmxlIHRvIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICB0b29scz86IEFycmF5PFJlc3BvbnNlLlRvb2w+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZvaWNlIHRoZSBtb2RlbCB1c2VzIHRvIHJlc3BvbmQuIFZvaWNlIGNhbm5vdCBiZSBjaGFuZ2VkIGR1cmluZyB0aGUgc2Vzc2lvblxuICAgICAqIG9uY2UgdGhlIG1vZGVsIGhhcyByZXNwb25kZWQgd2l0aCBhdWRpbyBhdCBsZWFzdCBvbmNlLiBDdXJyZW50IHZvaWNlIG9wdGlvbnMgYXJlXG4gICAgICogYGFsbG95YCwgYGFzaGAsIGBiYWxsYWRgLCBgY29yYWxgLCBgZWNob2AgYHNhZ2VgLCBgc2hpbW1lcmAgYW5kIGB2ZXJzZWAuXG4gICAgICovXG4gICAgdm9pY2U/OiAnYWxsb3knIHwgJ2FzaCcgfCAnYmFsbGFkJyB8ICdjb3JhbCcgfCAnZWNobycgfCAnc2FnZScgfCAnc2hpbW1lcicgfCAndmVyc2UnO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBSZXNwb25zZSB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBUb29sIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBmdW5jdGlvbiwgaW5jbHVkaW5nIGd1aWRhbmNlIG9uIHdoZW4gYW5kIGhvdyB0byBjYWxsIGl0LFxuICAgICAgICogYW5kIGd1aWRhbmNlIGFib3V0IHdoYXQgdG8gdGVsbCB0aGUgdXNlciB3aGVuIGNhbGxpbmcgKGlmIGFueXRoaW5nKS5cbiAgICAgICAqL1xuICAgICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAgICovXG4gICAgICBuYW1lPzogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFBhcmFtZXRlcnMgb2YgdGhlIGZ1bmN0aW9uIGluIEpTT04gU2NoZW1hLlxuICAgICAgICovXG4gICAgICBwYXJhbWV0ZXJzPzogdW5rbm93bjtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbCwgaS5lLiBgZnVuY3Rpb25gLlxuICAgICAgICovXG4gICAgICB0eXBlPzogJ2Z1bmN0aW9uJztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGEgbmV3IFJlc3BvbnNlIGlzIGNyZWF0ZWQuIFRoZSBmaXJzdCBldmVudCBvZiByZXNwb25zZSBjcmVhdGlvbixcbiAqIHdoZXJlIHRoZSByZXNwb25zZSBpcyBpbiBhbiBpbml0aWFsIHN0YXRlIG9mIGBpbl9wcm9ncmVzc2AuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VDcmVhdGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJlc3BvbnNlIHJlc291cmNlLlxuICAgKi9cbiAgcmVzcG9uc2U6IFJlYWx0aW1lUmVzcG9uc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5jcmVhdGVkYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5jcmVhdGVkJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGEgUmVzcG9uc2UgaXMgZG9uZSBzdHJlYW1pbmcuIEFsd2F5cyBlbWl0dGVkLCBubyBtYXR0ZXIgdGhlIGZpbmFsXG4gKiBzdGF0ZS4gVGhlIFJlc3BvbnNlIG9iamVjdCBpbmNsdWRlZCBpbiB0aGUgYHJlc3BvbnNlLmRvbmVgIGV2ZW50IHdpbGwgaW5jbHVkZVxuICogYWxsIG91dHB1dCBJdGVtcyBpbiB0aGUgUmVzcG9uc2UgYnV0IHdpbGwgb21pdCB0aGUgcmF3IGF1ZGlvIGRhdGEuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VEb25lRXZlbnQge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJlc3BvbnNlIHJlc291cmNlLlxuICAgKi9cbiAgcmVzcG9uc2U6IFJlYWx0aW1lUmVzcG9uc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5kb25lYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5kb25lJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIHRoZSBtb2RlbC1nZW5lcmF0ZWQgZnVuY3Rpb24gY2FsbCBhcmd1bWVudHMgYXJlIHVwZGF0ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VGdW5jdGlvbkNhbGxBcmd1bWVudHNEZWx0YUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgZnVuY3Rpb24gY2FsbC5cbiAgICovXG4gIGNhbGxfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGFyZ3VtZW50cyBkZWx0YSBhcyBhIEpTT04gc3RyaW5nLlxuICAgKi9cbiAgZGVsdGE6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBmdW5jdGlvbiBjYWxsIGl0ZW0uXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGl0ZW0gaW4gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UuZnVuY3Rpb25fY2FsbF9hcmd1bWVudHMuZGVsdGFgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLmZ1bmN0aW9uX2NhbGxfYXJndW1lbnRzLmRlbHRhJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIHRoZSBtb2RlbC1nZW5lcmF0ZWQgZnVuY3Rpb24gY2FsbCBhcmd1bWVudHMgYXJlIGRvbmUgc3RyZWFtaW5nLlxuICogQWxzbyBlbWl0dGVkIHdoZW4gYSBSZXNwb25zZSBpcyBpbnRlcnJ1cHRlZCwgaW5jb21wbGV0ZSwgb3IgY2FuY2VsbGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlRnVuY3Rpb25DYWxsQXJndW1lbnRzRG9uZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBmaW5hbCBhcmd1bWVudHMgYXMgYSBKU09OIHN0cmluZy5cbiAgICovXG4gIGFyZ3VtZW50czogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwuXG4gICAqL1xuICBjYWxsX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgZnVuY3Rpb24gY2FsbCBpdGVtLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSByZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLmZ1bmN0aW9uX2NhbGxfYXJndW1lbnRzLmRvbmVgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLmZ1bmN0aW9uX2NhbGxfYXJndW1lbnRzLmRvbmUnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBuZXcgSXRlbSBpcyBjcmVhdGVkIGR1cmluZyBSZXNwb25zZSBnZW5lcmF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlT3V0cHV0SXRlbUFkZGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGl0ZW0gdG8gYWRkIHRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAqL1xuICBpdGVtOiBDb252ZXJzYXRpb25JdGVtO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSBSZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFJlc3BvbnNlIHRvIHdoaWNoIHRoZSBpdGVtIGJlbG9uZ3MuXG4gICAqL1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2Uub3V0cHV0X2l0ZW0uYWRkZWRgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLm91dHB1dF9pdGVtLmFkZGVkJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGFuIEl0ZW0gaXMgZG9uZSBzdHJlYW1pbmcuIEFsc28gZW1pdHRlZCB3aGVuIGEgUmVzcG9uc2UgaXNcbiAqIGludGVycnVwdGVkLCBpbmNvbXBsZXRlLCBvciBjYW5jZWxsZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VPdXRwdXRJdGVtRG9uZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpdGVtIHRvIGFkZCB0byB0aGUgY29udmVyc2F0aW9uLlxuICAgKi9cbiAgaXRlbTogQ29udmVyc2F0aW9uSXRlbTtcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaXRlbSBpbiB0aGUgUmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBSZXNwb25zZSB0byB3aGljaCB0aGUgaXRlbSBiZWxvbmdzLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLm91dHB1dF9pdGVtLmRvbmVgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLm91dHB1dF9pdGVtLmRvbmUnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gdGhlIHRleHQgdmFsdWUgb2YgYSBcInRleHRcIiBjb250ZW50IHBhcnQgaXMgdXBkYXRlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZVRleHREZWx0YUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGluIHRoZSBpdGVtJ3MgY29udGVudCBhcnJheS5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHRleHQgZGVsdGEuXG4gICAqL1xuICBkZWx0YTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGl0ZW0uXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGl0ZW0gaW4gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UudGV4dC5kZWx0YWAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UudGV4dC5kZWx0YSc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiB0aGUgdGV4dCB2YWx1ZSBvZiBhIFwidGV4dFwiIGNvbnRlbnQgcGFydCBpcyBkb25lIHN0cmVhbWluZy4gQWxzb1xuICogZW1pdHRlZCB3aGVuIGEgUmVzcG9uc2UgaXMgaW50ZXJydXB0ZWQsIGluY29tcGxldGUsIG9yIGNhbmNlbGxlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZVRleHREb25lRXZlbnQge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgaW4gdGhlIGl0ZW0ncyBjb250ZW50IGFycmF5LlxuICAgKi9cbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGl0ZW0uXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGl0ZW0gaW4gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZmluYWwgdGV4dCBjb250ZW50LlxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UudGV4dC5kb25lYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS50ZXh0LmRvbmUnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBTZXNzaW9uIGlzIGNyZWF0ZWQuIEVtaXR0ZWQgYXV0b21hdGljYWxseSB3aGVuIGEgbmV3IGNvbm5lY3Rpb25cbiAqIGlzIGVzdGFibGlzaGVkIGFzIHRoZSBmaXJzdCBzZXJ2ZXIgZXZlbnQuIFRoaXMgZXZlbnQgd2lsbCBjb250YWluIHRoZSBkZWZhdWx0XG4gKiBTZXNzaW9uIGNvbmZpZ3VyYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbkNyZWF0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZWFsdGltZSBzZXNzaW9uIG9iamVjdCBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgc2Vzc2lvbjogU2Vzc2lvbnNBUEkuU2Vzc2lvbjtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHNlc3Npb24uY3JlYXRlZGAuXG4gICAqL1xuICB0eXBlOiAnc2Vzc2lvbi5jcmVhdGVkJztcbn1cblxuLyoqXG4gKiBTZW5kIHRoaXMgZXZlbnQgdG8gdXBkYXRlIHRoZSBzZXNzaW9uXHUyMDE5cyBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uIFRoZSBjbGllbnQgbWF5XG4gKiBzZW5kIHRoaXMgZXZlbnQgYXQgYW55IHRpbWUgdG8gdXBkYXRlIHRoZSBzZXNzaW9uIGNvbmZpZ3VyYXRpb24sIGFuZCBhbnkgZmllbGRcbiAqIG1heSBiZSB1cGRhdGVkIGF0IGFueSB0aW1lLCBleGNlcHQgZm9yIFwidm9pY2VcIi4gVGhlIHNlcnZlciB3aWxsIHJlc3BvbmQgd2l0aCBhXG4gKiBgc2Vzc2lvbi51cGRhdGVkYCBldmVudCB0aGF0IHNob3dzIHRoZSBmdWxsIGVmZmVjdGl2ZSBjb25maWd1cmF0aW9uLiBPbmx5IGZpZWxkc1xuICogdGhhdCBhcmUgcHJlc2VudCBhcmUgdXBkYXRlZCwgdGh1cyB0aGUgY29ycmVjdCB3YXkgdG8gY2xlYXIgYSBmaWVsZCBsaWtlXG4gKiBcImluc3RydWN0aW9uc1wiIGlzIHRvIHBhc3MgYW4gZW1wdHkgc3RyaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlc3Npb25VcGRhdGVFdmVudCB7XG4gIC8qKlxuICAgKiBSZWFsdGltZSBzZXNzaW9uIG9iamVjdCBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgc2Vzc2lvbjogU2Vzc2lvblVwZGF0ZUV2ZW50LlNlc3Npb247XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBzZXNzaW9uLnVwZGF0ZWAuXG4gICAqL1xuICB0eXBlOiAnc2Vzc2lvbi51cGRhdGUnO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjbGllbnQtZ2VuZXJhdGVkIElEIHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFNlc3Npb25VcGRhdGVFdmVudCB7XG4gIC8qKlxuICAgKiBSZWFsdGltZSBzZXNzaW9uIG9iamVjdCBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgUmVhbHRpbWUgbW9kZWwgdXNlZCBmb3IgdGhpcyBzZXNzaW9uLlxuICAgICAqL1xuICAgIG1vZGVsOlxuICAgICAgfCAnZ3B0LTRvLXJlYWx0aW1lLXByZXZpZXcnXG4gICAgICB8ICdncHQtNG8tcmVhbHRpbWUtcHJldmlldy0yMDI0LTEwLTAxJ1xuICAgICAgfCAnZ3B0LTRvLXJlYWx0aW1lLXByZXZpZXctMjAyNC0xMi0xNydcbiAgICAgIHwgJ2dwdC00by1taW5pLXJlYWx0aW1lLXByZXZpZXcnXG4gICAgICB8ICdncHQtNG8tbWluaS1yZWFsdGltZS1wcmV2aWV3LTIwMjQtMTItMTcnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcm1hdCBvZiBpbnB1dCBhdWRpby4gT3B0aW9ucyBhcmUgYHBjbTE2YCwgYGc3MTFfdWxhd2AsIG9yIGBnNzExX2FsYXdgLlxuICAgICAqL1xuICAgIGlucHV0X2F1ZGlvX2Zvcm1hdD86ICdwY20xNicgfCAnZzcxMV91bGF3JyB8ICdnNzExX2FsYXcnO1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiwgZGVmYXVsdHMgdG8gb2ZmIGFuZCBjYW4gYmUgc2V0IHRvXG4gICAgICogYG51bGxgIHRvIHR1cm4gb2ZmIG9uY2Ugb24uIElucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24gaXMgbm90IG5hdGl2ZSB0byB0aGVcbiAgICAgKiBtb2RlbCwgc2luY2UgdGhlIG1vZGVsIGNvbnN1bWVzIGF1ZGlvIGRpcmVjdGx5LiBUcmFuc2NyaXB0aW9uIHJ1bnNcbiAgICAgKiBhc3luY2hyb25vdXNseSB0aHJvdWdoIFdoaXNwZXIgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIHJvdWdoIGd1aWRhbmNlIHJhdGhlclxuICAgICAqIHRoYW4gdGhlIHJlcHJlc2VudGF0aW9uIHVuZGVyc3Rvb2QgYnkgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24/OiBTZXNzaW9uLklucHV0QXVkaW9UcmFuc2NyaXB0aW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgc3lzdGVtIGluc3RydWN0aW9ucyAoaS5lLiBzeXN0ZW0gbWVzc2FnZSkgcHJlcGVuZGVkIHRvIG1vZGVsIGNhbGxzLlxuICAgICAqIFRoaXMgZmllbGQgYWxsb3dzIHRoZSBjbGllbnQgdG8gZ3VpZGUgdGhlIG1vZGVsIG9uIGRlc2lyZWQgcmVzcG9uc2VzLiBUaGUgbW9kZWxcbiAgICAgKiBjYW4gYmUgaW5zdHJ1Y3RlZCBvbiByZXNwb25zZSBjb250ZW50IGFuZCBmb3JtYXQsIChlLmcuIFwiYmUgZXh0cmVtZWx5IHN1Y2NpbmN0XCIsXG4gICAgICogXCJhY3QgZnJpZW5kbHlcIiwgXCJoZXJlIGFyZSBleGFtcGxlcyBvZiBnb29kIHJlc3BvbnNlc1wiKSBhbmQgb24gYXVkaW8gYmVoYXZpb3JcbiAgICAgKiAoZS5nLiBcInRhbGsgcXVpY2tseVwiLCBcImluamVjdCBlbW90aW9uIGludG8geW91ciB2b2ljZVwiLCBcImxhdWdoIGZyZXF1ZW50bHlcIikuIFRoZVxuICAgICAqIGluc3RydWN0aW9ucyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gYmUgZm9sbG93ZWQgYnkgdGhlIG1vZGVsLCBidXQgdGhleSBwcm92aWRlXG4gICAgICogZ3VpZGFuY2UgdG8gdGhlIG1vZGVsIG9uIHRoZSBkZXNpcmVkIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBzZXJ2ZXIgc2V0cyBkZWZhdWx0IGluc3RydWN0aW9ucyB3aGljaCB3aWxsIGJlIHVzZWQgaWYgdGhpcyBmaWVsZFxuICAgICAqIGlzIG5vdCBzZXQgYW5kIGFyZSB2aXNpYmxlIGluIHRoZSBgc2Vzc2lvbi5jcmVhdGVkYCBldmVudCBhdCB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICogc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBpbnN0cnVjdGlvbnM/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBvdXRwdXQgdG9rZW5zIGZvciBhIHNpbmdsZSBhc3Npc3RhbnQgcmVzcG9uc2UsIGluY2x1c2l2ZSBvZlxuICAgICAqIHRvb2wgY2FsbHMuIFByb3ZpZGUgYW4gaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDQwOTYgdG8gbGltaXQgb3V0cHV0IHRva2Vucywgb3JcbiAgICAgKiBgaW5mYCBmb3IgdGhlIG1heGltdW0gYXZhaWxhYmxlIHRva2VucyBmb3IgYSBnaXZlbiBtb2RlbC4gRGVmYXVsdHMgdG8gYGluZmAuXG4gICAgICovXG4gICAgbWF4X3Jlc3BvbnNlX291dHB1dF90b2tlbnM/OiBudW1iZXIgfCAnaW5mJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZXQgb2YgbW9kYWxpdGllcyB0aGUgbW9kZWwgY2FuIHJlc3BvbmQgd2l0aC4gVG8gZGlzYWJsZSBhdWRpbywgc2V0IHRoaXMgdG9cbiAgICAgKiBbXCJ0ZXh0XCJdLlxuICAgICAqL1xuICAgIG1vZGFsaXRpZXM/OiBBcnJheTwndGV4dCcgfCAnYXVkaW8nPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb3JtYXQgb2Ygb3V0cHV0IGF1ZGlvLiBPcHRpb25zIGFyZSBgcGNtMTZgLCBgZzcxMV91bGF3YCwgb3IgYGc3MTFfYWxhd2AuXG4gICAgICovXG4gICAgb3V0cHV0X2F1ZGlvX2Zvcm1hdD86ICdwY20xNicgfCAnZzcxMV91bGF3JyB8ICdnNzExX2FsYXcnO1xuXG4gICAgLyoqXG4gICAgICogU2FtcGxpbmcgdGVtcGVyYXR1cmUgZm9yIHRoZSBtb2RlbCwgbGltaXRlZCB0byBbMC42LCAxLjJdLiBEZWZhdWx0cyB0byAwLjguXG4gICAgICovXG4gICAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBIb3cgdGhlIG1vZGVsIGNob29zZXMgdG9vbHMuIE9wdGlvbnMgYXJlIGBhdXRvYCwgYG5vbmVgLCBgcmVxdWlyZWRgLCBvciBzcGVjaWZ5XG4gICAgICogYSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB0b29sX2Nob2ljZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRvb2xzIChmdW5jdGlvbnMpIGF2YWlsYWJsZSB0byB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgdG9vbHM/OiBBcnJheTxTZXNzaW9uLlRvb2w+O1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgdHVybiBkZXRlY3Rpb24uIENhbiBiZSBzZXQgdG8gYG51bGxgIHRvIHR1cm4gb2ZmLiBTZXJ2ZXIgVkFEXG4gICAgICogbWVhbnMgdGhhdCB0aGUgbW9kZWwgd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IGFuZCBlbmQgb2Ygc3BlZWNoIGJhc2VkIG9uIGF1ZGlvXG4gICAgICogdm9sdW1lIGFuZCByZXNwb25kIGF0IHRoZSBlbmQgb2YgdXNlciBzcGVlY2guXG4gICAgICovXG4gICAgdHVybl9kZXRlY3Rpb24/OiBTZXNzaW9uLlR1cm5EZXRlY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdm9pY2UgdGhlIG1vZGVsIHVzZXMgdG8gcmVzcG9uZC4gVm9pY2UgY2Fubm90IGJlIGNoYW5nZWQgZHVyaW5nIHRoZSBzZXNzaW9uXG4gICAgICogb25jZSB0aGUgbW9kZWwgaGFzIHJlc3BvbmRlZCB3aXRoIGF1ZGlvIGF0IGxlYXN0IG9uY2UuIEN1cnJlbnQgdm9pY2Ugb3B0aW9ucyBhcmVcbiAgICAgKiBgYWxsb3lgLCBgYXNoYCwgYGJhbGxhZGAsIGBjb3JhbGAsIGBlY2hvYCBgc2FnZWAsIGBzaGltbWVyYCBhbmQgYHZlcnNlYC5cbiAgICAgKi9cbiAgICB2b2ljZT86ICdhbGxveScgfCAnYXNoJyB8ICdiYWxsYWQnIHwgJ2NvcmFsJyB8ICdlY2hvJyB8ICdzYWdlJyB8ICdzaGltbWVyJyB8ICd2ZXJzZSc7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFNlc3Npb24ge1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24sIGRlZmF1bHRzIHRvIG9mZiBhbmQgY2FuIGJlIHNldCB0b1xuICAgICAqIGBudWxsYCB0byB0dXJuIG9mZiBvbmNlIG9uLiBJbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uIGlzIG5vdCBuYXRpdmUgdG8gdGhlXG4gICAgICogbW9kZWwsIHNpbmNlIHRoZSBtb2RlbCBjb25zdW1lcyBhdWRpbyBkaXJlY3RseS4gVHJhbnNjcmlwdGlvbiBydW5zXG4gICAgICogYXN5bmNocm9ub3VzbHkgdGhyb3VnaCBXaGlzcGVyIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyByb3VnaCBndWlkYW5jZSByYXRoZXJcbiAgICAgKiB0aGFuIHRoZSByZXByZXNlbnRhdGlvbiB1bmRlcnN0b29kIGJ5IHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9UcmFuc2NyaXB0aW9uIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG1vZGVsIHRvIHVzZSBmb3IgdHJhbnNjcmlwdGlvbiwgYHdoaXNwZXItMWAgaXMgdGhlIG9ubHkgY3VycmVudGx5IHN1cHBvcnRlZFxuICAgICAgICogbW9kZWwuXG4gICAgICAgKi9cbiAgICAgIG1vZGVsPzogc3RyaW5nO1xuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgVG9vbCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgZnVuY3Rpb24sIGluY2x1ZGluZyBndWlkYW5jZSBvbiB3aGVuIGFuZCBob3cgdG8gY2FsbCBpdCxcbiAgICAgICAqIGFuZCBndWlkYW5jZSBhYm91dCB3aGF0IHRvIHRlbGwgdGhlIHVzZXIgd2hlbiBjYWxsaW5nIChpZiBhbnl0aGluZykuXG4gICAgICAgKi9cbiAgICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgICAqL1xuICAgICAgbmFtZT86IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBQYXJhbWV0ZXJzIG9mIHRoZSBmdW5jdGlvbiBpbiBKU09OIFNjaGVtYS5cbiAgICAgICAqL1xuICAgICAgcGFyYW1ldGVycz86IHVua25vd247XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wsIGkuZS4gYGZ1bmN0aW9uYC5cbiAgICAgICAqL1xuICAgICAgdHlwZT86ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgdHVybiBkZXRlY3Rpb24uIENhbiBiZSBzZXQgdG8gYG51bGxgIHRvIHR1cm4gb2ZmLiBTZXJ2ZXIgVkFEXG4gICAgICogbWVhbnMgdGhhdCB0aGUgbW9kZWwgd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IGFuZCBlbmQgb2Ygc3BlZWNoIGJhc2VkIG9uIGF1ZGlvXG4gICAgICogdm9sdW1lIGFuZCByZXNwb25kIGF0IHRoZSBlbmQgb2YgdXNlciBzcGVlY2guXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBUdXJuRGV0ZWN0aW9uIHtcbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciBvciBub3QgdG8gYXV0b21hdGljYWxseSBnZW5lcmF0ZSBhIHJlc3BvbnNlIHdoZW4gVkFEIGlzIGVuYWJsZWQuIGB0cnVlYFxuICAgICAgICogYnkgZGVmYXVsdC5cbiAgICAgICAqL1xuICAgICAgY3JlYXRlX3Jlc3BvbnNlPzogYm9vbGVhbjtcblxuICAgICAgLyoqXG4gICAgICAgKiBBbW91bnQgb2YgYXVkaW8gdG8gaW5jbHVkZSBiZWZvcmUgdGhlIFZBRCBkZXRlY3RlZCBzcGVlY2ggKGluIG1pbGxpc2Vjb25kcykuXG4gICAgICAgKiBEZWZhdWx0cyB0byAzMDBtcy5cbiAgICAgICAqL1xuICAgICAgcHJlZml4X3BhZGRpbmdfbXM/OiBudW1iZXI7XG5cbiAgICAgIC8qKlxuICAgICAgICogRHVyYXRpb24gb2Ygc2lsZW5jZSB0byBkZXRlY3Qgc3BlZWNoIHN0b3AgKGluIG1pbGxpc2Vjb25kcykuIERlZmF1bHRzIHRvIDUwMG1zLlxuICAgICAgICogV2l0aCBzaG9ydGVyIHZhbHVlcyB0aGUgbW9kZWwgd2lsbCByZXNwb25kIG1vcmUgcXVpY2tseSwgYnV0IG1heSBqdW1wIGluIG9uXG4gICAgICAgKiBzaG9ydCBwYXVzZXMgZnJvbSB0aGUgdXNlci5cbiAgICAgICAqL1xuICAgICAgc2lsZW5jZV9kdXJhdGlvbl9tcz86IG51bWJlcjtcblxuICAgICAgLyoqXG4gICAgICAgKiBBY3RpdmF0aW9uIHRocmVzaG9sZCBmb3IgVkFEICgwLjAgdG8gMS4wKSwgdGhpcyBkZWZhdWx0cyB0byAwLjUuIEEgaGlnaGVyXG4gICAgICAgKiB0aHJlc2hvbGQgd2lsbCByZXF1aXJlIGxvdWRlciBhdWRpbyB0byBhY3RpdmF0ZSB0aGUgbW9kZWwsIGFuZCB0aHVzIG1pZ2h0XG4gICAgICAgKiBwZXJmb3JtIGJldHRlciBpbiBub2lzeSBlbnZpcm9ubWVudHMuXG4gICAgICAgKi9cbiAgICAgIHRocmVzaG9sZD86IG51bWJlcjtcblxuICAgICAgLyoqXG4gICAgICAgKiBUeXBlIG9mIHR1cm4gZGV0ZWN0aW9uLCBvbmx5IGBzZXJ2ZXJfdmFkYCBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlxuICAgICAgICovXG4gICAgICB0eXBlPzogc3RyaW5nO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBzZXNzaW9uIGlzIHVwZGF0ZWQgd2l0aCBhIGBzZXNzaW9uLnVwZGF0ZWAgZXZlbnQsIHVubGVzcyB0aGVyZVxuICogaXMgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvblVwZGF0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZWFsdGltZSBzZXNzaW9uIG9iamVjdCBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgc2Vzc2lvbjogU2Vzc2lvbnNBUEkuU2Vzc2lvbjtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHNlc3Npb24udXBkYXRlZGAuXG4gICAqL1xuICB0eXBlOiAnc2Vzc2lvbi51cGRhdGVkJztcbn1cblxuUmVhbHRpbWUuU2Vzc2lvbnMgPSBTZXNzaW9ucztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFJlYWx0aW1lIHtcbiAgZXhwb3J0IHtcbiAgICBTZXNzaW9ucyBhcyBTZXNzaW9ucyxcbiAgICB0eXBlIFNlc3Npb25zQVBJU2Vzc2lvbiBhcyBTZXNzaW9uLFxuICAgIHR5cGUgU2Vzc2lvbkNyZWF0ZVJlc3BvbnNlIGFzIFNlc3Npb25DcmVhdGVSZXNwb25zZSxcbiAgICB0eXBlIFNlc3Npb25DcmVhdGVQYXJhbXMgYXMgU2Vzc2lvbkNyZWF0ZVBhcmFtcyxcbiAgfTtcbn1cbiIsICJpbXBvcnQge1xuICBUZXh0Q29udGVudEJsb2NrLFxuICBJbWFnZUZpbGVDb250ZW50QmxvY2ssXG4gIE1lc3NhZ2UsXG4gIE1lc3NhZ2VDb250ZW50RGVsdGEsXG4gIFRleHQsXG4gIEltYWdlRmlsZSxcbiAgVGV4dERlbHRhLFxuICBNZXNzYWdlRGVsdGEsXG4gIE1lc3NhZ2VDb250ZW50LFxufSBmcm9tICcuLi9yZXNvdXJjZXMvYmV0YS90aHJlYWRzL21lc3NhZ2VzJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgeyBSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0IHtcbiAgUnVuLFxuICBSdW5DcmVhdGVQYXJhbXNCYXNlLFxuICBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gIFJ1bnMsXG4gIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zQmFzZSxcbiAgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmcsXG59IGZyb20gJy4uL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvcnVucy9ydW5zJztcbmltcG9ydCB7IHR5cGUgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9fc2hpbXMvaW5kZXgnO1xuaW1wb3J0IHsgU3RyZWFtIH0gZnJvbSAnLi4vc3RyZWFtaW5nJztcbmltcG9ydCB7IEFQSVVzZXJBYm9ydEVycm9yLCBPcGVuQUlFcnJvciB9IGZyb20gJy4uL2Vycm9yJztcbmltcG9ydCB7XG4gIEFzc2lzdGFudFN0cmVhbUV2ZW50LFxuICBNZXNzYWdlU3RyZWFtRXZlbnQsXG4gIFJ1blN0ZXBTdHJlYW1FdmVudCxcbiAgUnVuU3RyZWFtRXZlbnQsXG59IGZyb20gJy4uL3Jlc291cmNlcy9iZXRhL2Fzc2lzdGFudHMnO1xuaW1wb3J0IHsgUnVuU3RlcCwgUnVuU3RlcERlbHRhLCBUb29sQ2FsbCwgVG9vbENhbGxEZWx0YSB9IGZyb20gJy4uL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvcnVucy9zdGVwcyc7XG5pbXBvcnQgeyBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlLCBUaHJlYWRzIH0gZnJvbSAnLi4vcmVzb3VyY2VzL2JldGEvdGhyZWFkcy90aHJlYWRzJztcbmltcG9ydCB7IEJhc2VFdmVudHMsIEV2ZW50U3RyZWFtIH0gZnJvbSAnLi9FdmVudFN0cmVhbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXNzaXN0YW50U3RyZWFtRXZlbnRzIGV4dGVuZHMgQmFzZUV2ZW50cyB7XG4gIHJ1bjogKHJ1bjogUnVuKSA9PiB2b2lkO1xuXG4gIC8vTmV3IGV2ZW50IHN0cnVjdHVyZVxuICBtZXNzYWdlQ3JlYXRlZDogKG1lc3NhZ2U6IE1lc3NhZ2UpID0+IHZvaWQ7XG4gIG1lc3NhZ2VEZWx0YTogKG1lc3NhZ2U6IE1lc3NhZ2VEZWx0YSwgc25hcHNob3Q6IE1lc3NhZ2UpID0+IHZvaWQ7XG4gIG1lc3NhZ2VEb25lOiAobWVzc2FnZTogTWVzc2FnZSkgPT4gdm9pZDtcblxuICBydW5TdGVwQ3JlYXRlZDogKHJ1blN0ZXA6IFJ1blN0ZXApID0+IHZvaWQ7XG4gIHJ1blN0ZXBEZWx0YTogKGRlbHRhOiBSdW5TdGVwRGVsdGEsIHNuYXBzaG90OiBSdW5zLlJ1blN0ZXApID0+IHZvaWQ7XG4gIHJ1blN0ZXBEb25lOiAocnVuU3RlcDogUnVucy5SdW5TdGVwLCBzbmFwc2hvdDogUnVucy5SdW5TdGVwKSA9PiB2b2lkO1xuXG4gIHRvb2xDYWxsQ3JlYXRlZDogKHRvb2xDYWxsOiBUb29sQ2FsbCkgPT4gdm9pZDtcbiAgdG9vbENhbGxEZWx0YTogKGRlbHRhOiBUb29sQ2FsbERlbHRhLCBzbmFwc2hvdDogVG9vbENhbGwpID0+IHZvaWQ7XG4gIHRvb2xDYWxsRG9uZTogKHRvb2xDYWxsOiBUb29sQ2FsbCkgPT4gdm9pZDtcblxuICB0ZXh0Q3JlYXRlZDogKGNvbnRlbnQ6IFRleHQpID0+IHZvaWQ7XG4gIHRleHREZWx0YTogKGRlbHRhOiBUZXh0RGVsdGEsIHNuYXBzaG90OiBUZXh0KSA9PiB2b2lkO1xuICB0ZXh0RG9uZTogKGNvbnRlbnQ6IFRleHQsIHNuYXBzaG90OiBNZXNzYWdlKSA9PiB2b2lkO1xuXG4gIC8vTm8gY3JlYXRlZCBvciBkZWx0YSBhcyB0aGlzIGlzIG5vdCBzdHJlYW1lZFxuICBpbWFnZUZpbGVEb25lOiAoY29udGVudDogSW1hZ2VGaWxlLCBzbmFwc2hvdDogTWVzc2FnZSkgPT4gdm9pZDtcblxuICBldmVudDogKGV2ZW50OiBBc3Npc3RhbnRTdHJlYW1FdmVudCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zQmFzZVN0cmVhbSA9IE9taXQ8VGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zQmFzZSwgJ3N0cmVhbSc+ICYge1xuICBzdHJlYW0/OiB0cnVlO1xufTtcblxuZXhwb3J0IHR5cGUgUnVuQ3JlYXRlUGFyYW1zQmFzZVN0cmVhbSA9IE9taXQ8UnVuQ3JlYXRlUGFyYW1zQmFzZSwgJ3N0cmVhbSc+ICYge1xuICBzdHJlYW0/OiB0cnVlO1xufTtcblxuZXhwb3J0IHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW0gPSBPbWl0PFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zQmFzZSwgJ3N0cmVhbSc+ICYge1xuICBzdHJlYW0/OiB0cnVlO1xufTtcblxuZXhwb3J0IGNsYXNzIEFzc2lzdGFudFN0cmVhbVxuICBleHRlbmRzIEV2ZW50U3RyZWFtPEFzc2lzdGFudFN0cmVhbUV2ZW50cz5cbiAgaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPEFzc2lzdGFudFN0cmVhbUV2ZW50Plxue1xuICAvL1RyYWNrIGFsbCBldmVudHMgaW4gYSBzaW5nbGUgbGlzdCBmb3IgcmVmZXJlbmNlXG4gICNldmVudHM6IEFzc2lzdGFudFN0cmVhbUV2ZW50W10gPSBbXTtcblxuICAvL1VzZWQgdG8gYWNjdW11bGF0ZSBkZWx0YXNcbiAgLy9XZSBhcmUgYWNjdW11bGF0aW5nIG1hbnkgdHlwZXMgc28gdGhlIHZhbHVlIGhlcmUgaXMgbm90IHN0cmljdFxuICAjcnVuU3RlcFNuYXBzaG90czogeyBbaWQ6IHN0cmluZ106IFJ1bnMuUnVuU3RlcCB9ID0ge307XG4gICNtZXNzYWdlU25hcHNob3RzOiB7IFtpZDogc3RyaW5nXTogTWVzc2FnZSB9ID0ge307XG4gICNtZXNzYWdlU25hcHNob3Q6IE1lc3NhZ2UgfCB1bmRlZmluZWQ7XG4gICNmaW5hbFJ1bjogUnVuIHwgdW5kZWZpbmVkO1xuICAjY3VycmVudENvbnRlbnRJbmRleDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAjY3VycmVudENvbnRlbnQ6IE1lc3NhZ2VDb250ZW50IHwgdW5kZWZpbmVkO1xuICAjY3VycmVudFRvb2xDYWxsSW5kZXg6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgI2N1cnJlbnRUb29sQ2FsbDogVG9vbENhbGwgfCB1bmRlZmluZWQ7XG5cbiAgLy9Gb3IgY3VycmVudCBzbmFwc2hvdCBtZXRob2RzXG4gICNjdXJyZW50RXZlbnQ6IEFzc2lzdGFudFN0cmVhbUV2ZW50IHwgdW5kZWZpbmVkO1xuICAjY3VycmVudFJ1blNuYXBzaG90OiBSdW4gfCB1bmRlZmluZWQ7XG4gICNjdXJyZW50UnVuU3RlcFNuYXBzaG90OiBSdW5zLlJ1blN0ZXAgfCB1bmRlZmluZWQ7XG5cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpOiBBc3luY0l0ZXJhdG9yPEFzc2lzdGFudFN0cmVhbUV2ZW50PiB7XG4gICAgY29uc3QgcHVzaFF1ZXVlOiBBc3Npc3RhbnRTdHJlYW1FdmVudFtdID0gW107XG4gICAgY29uc3QgcmVhZFF1ZXVlOiB7XG4gICAgICByZXNvbHZlOiAoY2h1bms6IEFzc2lzdGFudFN0cmVhbUV2ZW50IHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuICAgICAgcmVqZWN0OiAoZXJyOiB1bmtub3duKSA9PiB2b2lkO1xuICAgIH1bXSA9IFtdO1xuICAgIGxldCBkb25lID0gZmFsc2U7XG5cbiAgICAvL0NhdGNoIGFsbCBmb3IgcGFzc2luZyBhbG9uZyBhbGwgZXZlbnRzXG4gICAgdGhpcy5vbignZXZlbnQnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlYWRRdWV1ZS5zaGlmdCgpO1xuICAgICAgaWYgKHJlYWRlcikge1xuICAgICAgICByZWFkZXIucmVzb2x2ZShldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoUXVldWUucHVzaChldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHJlYWRRdWV1ZSkge1xuICAgICAgICByZWFkZXIucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgcmVhZFF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdhYm9ydCcsIChlcnIpID0+IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgcmVhZFF1ZXVlKSB7XG4gICAgICAgIHJlYWRlci5yZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlYWRRdWV1ZS5sZW5ndGggPSAwO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHJlYWRRdWV1ZSkge1xuICAgICAgICByZWFkZXIucmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBhc3luYyAoKTogUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxBc3Npc3RhbnRTdHJlYW1FdmVudD4+ID0+IHtcbiAgICAgICAgaWYgKCFwdXNoUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPEFzc2lzdGFudFN0cmVhbUV2ZW50IHwgdW5kZWZpbmVkPigocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgICAgICAgcmVhZFF1ZXVlLnB1c2goeyByZXNvbHZlLCByZWplY3QgfSksXG4gICAgICAgICAgKS50aGVuKChjaHVuaykgPT4gKGNodW5rID8geyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0gOiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNodW5rID0gcHVzaFF1ZXVlLnNoaWZ0KCkhO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH07XG4gICAgICB9LFxuICAgICAgcmV0dXJuOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRoaXMuYWJvcnQoKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGZyb21SZWFkYWJsZVN0cmVhbShzdHJlYW06IFJlYWRhYmxlU3RyZWFtKTogQXNzaXN0YW50U3RyZWFtIHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgQXNzaXN0YW50U3RyZWFtKCk7XG4gICAgcnVubmVyLl9ydW4oKCkgPT4gcnVubmVyLl9mcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfZnJvbVJlYWRhYmxlU3RyZWFtKFxuICAgIHJlYWRhYmxlU3RyZWFtOiBSZWFkYWJsZVN0cmVhbSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxSdW4+IHtcbiAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXMuY29udHJvbGxlci5hYm9ydCgpKTtcbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdGVkKCk7XG4gICAgY29uc3Qgc3RyZWFtID0gU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbTxBc3Npc3RhbnRTdHJlYW1FdmVudD4ocmVhZGFibGVTdHJlYW0sIHRoaXMuY29udHJvbGxlcik7XG4gICAgZm9yIGF3YWl0IChjb25zdCBldmVudCBvZiBzdHJlYW0pIHtcbiAgICAgIHRoaXMuI2FkZEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5jb250cm9sbGVyLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hZGRSdW4odGhpcy4jZW5kUmVxdWVzdCgpKTtcbiAgfVxuXG4gIHRvUmVhZGFibGVTdHJlYW0oKTogUmVhZGFibGVTdHJlYW0ge1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBTdHJlYW0odGhpc1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0uYmluZCh0aGlzKSwgdGhpcy5jb250cm9sbGVyKTtcbiAgICByZXR1cm4gc3RyZWFtLnRvUmVhZGFibGVTdHJlYW0oKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVUb29sQXNzaXN0YW50U3RyZWFtKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBydW5zOiBSdW5zLFxuICAgIHBhcmFtczogUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW0sXG4gICAgb3B0aW9uczogUmVxdWVzdE9wdGlvbnMgfCB1bmRlZmluZWQsXG4gICk6IEFzc2lzdGFudFN0cmVhbSB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IEFzc2lzdGFudFN0cmVhbSgpO1xuICAgIHJ1bm5lci5fcnVuKCgpID0+XG4gICAgICBydW5uZXIuX3J1blRvb2xBc3Npc3RhbnRTdHJlYW0odGhyZWFkSWQsIHJ1bklkLCBydW5zLCBwYXJhbXMsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtSGVscGVyLU1ldGhvZCc6ICdzdHJlYW0nIH0sXG4gICAgICB9KSxcbiAgICApO1xuICAgIHJldHVybiBydW5uZXI7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX2NyZWF0ZVRvb2xBc3Npc3RhbnRTdHJlYW0oXG4gICAgcnVuOiBSdW5zLFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBwYXJhbXM6IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBQcm9taXNlPFJ1bj4ge1xuICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbDtcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gdGhpcy5jb250cm9sbGVyLmFib3J0KCkpO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHk6IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtaW5nID0geyAuLi5wYXJhbXMsIHN0cmVhbTogdHJ1ZSB9O1xuICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHJ1bi5zdWJtaXRUb29sT3V0cHV0cyh0aHJlYWRJZCwgcnVuSWQsIGJvZHksIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBzaWduYWw6IHRoaXMuY29udHJvbGxlci5zaWduYWwsXG4gICAgfSk7XG5cbiAgICB0aGlzLl9jb25uZWN0ZWQoKTtcblxuICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2Ygc3RyZWFtKSB7XG4gICAgICB0aGlzLiNhZGRFdmVudChldmVudCk7XG4gICAgfVxuICAgIGlmIChzdHJlYW0uY29udHJvbGxlci5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9hZGRSdW4odGhpcy4jZW5kUmVxdWVzdCgpKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVUaHJlYWRBc3Npc3RhbnRTdHJlYW0oXG4gICAgcGFyYW1zOiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlU3RyZWFtLFxuICAgIHRocmVhZDogVGhyZWFkcyxcbiAgICBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFzc2lzdGFudFN0cmVhbSB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IEFzc2lzdGFudFN0cmVhbSgpO1xuICAgIHJ1bm5lci5fcnVuKCgpID0+XG4gICAgICBydW5uZXIuX3RocmVhZEFzc2lzdGFudFN0cmVhbShwYXJhbXMsIHRocmVhZCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3N0cmVhbScgfSxcbiAgICAgIH0pLFxuICAgICk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVBc3Npc3RhbnRTdHJlYW0oXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5zOiBSdW5zLFxuICAgIHBhcmFtczogUnVuQ3JlYXRlUGFyYW1zQmFzZVN0cmVhbSxcbiAgICBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFzc2lzdGFudFN0cmVhbSB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IEFzc2lzdGFudFN0cmVhbSgpO1xuICAgIHJ1bm5lci5fcnVuKCgpID0+XG4gICAgICBydW5uZXIuX3J1bkFzc2lzdGFudFN0cmVhbSh0aHJlYWRJZCwgcnVucywgcGFyYW1zLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAnc3RyZWFtJyB9LFxuICAgICAgfSksXG4gICAgKTtcbiAgICByZXR1cm4gcnVubmVyO1xuICB9XG5cbiAgY3VycmVudEV2ZW50KCk6IEFzc2lzdGFudFN0cmVhbUV2ZW50IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudEV2ZW50O1xuICB9XG5cbiAgY3VycmVudFJ1bigpOiBSdW4gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50UnVuU25hcHNob3Q7XG4gIH1cblxuICBjdXJyZW50TWVzc2FnZVNuYXBzaG90KCk6IE1lc3NhZ2UgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLiNtZXNzYWdlU25hcHNob3Q7XG4gIH1cblxuICBjdXJyZW50UnVuU3RlcFNuYXBzaG90KCk6IFJ1bnMuUnVuU3RlcCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRSdW5TdGVwU25hcHNob3Q7XG4gIH1cblxuICBhc3luYyBmaW5hbFJ1blN0ZXBzKCk6IFByb21pc2U8UnVucy5SdW5TdGVwW10+IHtcbiAgICBhd2FpdCB0aGlzLmRvbmUoKTtcblxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuI3J1blN0ZXBTbmFwc2hvdHMpO1xuICB9XG5cbiAgYXN5bmMgZmluYWxNZXNzYWdlcygpOiBQcm9taXNlPE1lc3NhZ2VbXT4ge1xuICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy4jbWVzc2FnZVNuYXBzaG90cyk7XG4gIH1cblxuICBhc3luYyBmaW5hbFJ1bigpOiBQcm9taXNlPFJ1bj4ge1xuICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgIGlmICghdGhpcy4jZmluYWxSdW4pIHRocm93IEVycm9yKCdGaW5hbCBydW4gd2FzIG5vdCByZWNlaXZlZC4nKTtcblxuICAgIHJldHVybiB0aGlzLiNmaW5hbFJ1bjtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfY3JlYXRlVGhyZWFkQXNzaXN0YW50U3RyZWFtKFxuICAgIHRocmVhZDogVGhyZWFkcyxcbiAgICBwYXJhbXM6IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc0Jhc2UsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IFByb21pc2U8UnVuPiB7XG4gICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgIGlmIChzaWduYWwpIHtcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keTogUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nID0geyAuLi5wYXJhbXMsIHN0cmVhbTogdHJ1ZSB9O1xuICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHRocmVhZC5jcmVhdGVBbmRSdW4oYm9keSwgeyAuLi5vcHRpb25zLCBzaWduYWw6IHRoaXMuY29udHJvbGxlci5zaWduYWwgfSk7XG5cbiAgICB0aGlzLl9jb25uZWN0ZWQoKTtcblxuICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2Ygc3RyZWFtKSB7XG4gICAgICB0aGlzLiNhZGRFdmVudChldmVudCk7XG4gICAgfVxuICAgIGlmIChzdHJlYW0uY29udHJvbGxlci5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9hZGRSdW4odGhpcy4jZW5kUmVxdWVzdCgpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfY3JlYXRlQXNzaXN0YW50U3RyZWFtKFxuICAgIHJ1bjogUnVucyxcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHBhcmFtczogUnVuQ3JlYXRlUGFyYW1zQmFzZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxSdW4+IHtcbiAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXMuY29udHJvbGxlci5hYm9ydCgpKTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5OiBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSB7IC4uLnBhcmFtcywgc3RyZWFtOiB0cnVlIH07XG4gICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgcnVuLmNyZWF0ZSh0aHJlYWRJZCwgYm9keSwgeyAuLi5vcHRpb25zLCBzaWduYWw6IHRoaXMuY29udHJvbGxlci5zaWduYWwgfSk7XG5cbiAgICB0aGlzLl9jb25uZWN0ZWQoKTtcblxuICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2Ygc3RyZWFtKSB7XG4gICAgICB0aGlzLiNhZGRFdmVudChldmVudCk7XG4gICAgfVxuICAgIGlmIChzdHJlYW0uY29udHJvbGxlci5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9hZGRSdW4odGhpcy4jZW5kUmVxdWVzdCgpKTtcbiAgfVxuXG4gICNhZGRFdmVudChldmVudDogQXNzaXN0YW50U3RyZWFtRXZlbnQpIHtcbiAgICBpZiAodGhpcy5lbmRlZCkgcmV0dXJuO1xuXG4gICAgdGhpcy4jY3VycmVudEV2ZW50ID0gZXZlbnQ7XG5cbiAgICB0aGlzLiNoYW5kbGVFdmVudChldmVudCk7XG5cbiAgICBzd2l0Y2ggKGV2ZW50LmV2ZW50KSB7XG4gICAgICBjYXNlICd0aHJlYWQuY3JlYXRlZCc6XG4gICAgICAgIC8vTm8gYWN0aW9uIG9uIHRoaXMgZXZlbnQuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0aHJlYWQucnVuLmNyZWF0ZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5xdWV1ZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5pbl9wcm9ncmVzcyc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnJlcXVpcmVzX2FjdGlvbic6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmNvbXBsZXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmZhaWxlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmNhbmNlbGxpbmcnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jYW5jZWxsZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5leHBpcmVkJzpcbiAgICAgICAgdGhpcy4jaGFuZGxlUnVuKGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jcmVhdGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5pbl9wcm9ncmVzcyc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZGVsdGEnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmNvbXBsZXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZmFpbGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jYW5jZWxsZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmV4cGlyZWQnOlxuICAgICAgICB0aGlzLiNoYW5kbGVSdW5TdGVwKGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmNyZWF0ZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuaW5fcHJvZ3Jlc3MnOlxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuZGVsdGEnOlxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuY29tcGxldGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmluY29tcGxldGUnOlxuICAgICAgICB0aGlzLiNoYW5kbGVNZXNzYWdlKGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgLy9UaGlzIGlzIGluY2x1ZGVkIGZvciBjb21wbGV0ZW5lc3MsIGJ1dCBlcnJvcnMgYXJlIHByb2Nlc3NlZCBpbiB0aGUgU1NFIGV2ZW50IHByb2Nlc3Npbmcgc28gdGhpcyBzaG91bGQgbm90IG9jY3VyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRW5jb3VudGVyZWQgYW4gZXJyb3IgZXZlbnQgaW4gZXZlbnQgcHJvY2Vzc2luZyAtIGVycm9ycyBzaG91bGQgYmUgcHJvY2Vzc2VkIGVhcmxpZXInLFxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gICNlbmRSZXF1ZXN0KCk6IFJ1biB7XG4gICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgc3RyZWFtIGhhcyBlbmRlZCwgdGhpcyBzaG91bGRuJ3QgaGFwcGVuYCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLiNmaW5hbFJ1bikgdGhyb3cgRXJyb3IoJ0ZpbmFsIHJ1biBoYXMgbm90IGJlZW4gcmVjZWl2ZWQnKTtcblxuICAgIHJldHVybiB0aGlzLiNmaW5hbFJ1bjtcbiAgfVxuXG4gICNoYW5kbGVNZXNzYWdlKHRoaXM6IEFzc2lzdGFudFN0cmVhbSwgZXZlbnQ6IE1lc3NhZ2VTdHJlYW1FdmVudCkge1xuICAgIGNvbnN0IFthY2N1bXVsYXRlZE1lc3NhZ2UsIG5ld0NvbnRlbnRdID0gdGhpcy4jYWNjdW11bGF0ZU1lc3NhZ2UoZXZlbnQsIHRoaXMuI21lc3NhZ2VTbmFwc2hvdCk7XG4gICAgdGhpcy4jbWVzc2FnZVNuYXBzaG90ID0gYWNjdW11bGF0ZWRNZXNzYWdlO1xuICAgIHRoaXMuI21lc3NhZ2VTbmFwc2hvdHNbYWNjdW11bGF0ZWRNZXNzYWdlLmlkXSA9IGFjY3VtdWxhdGVkTWVzc2FnZTtcblxuICAgIGZvciAoY29uc3QgY29udGVudCBvZiBuZXdDb250ZW50KSB7XG4gICAgICBjb25zdCBzbmFwc2hvdENvbnRlbnQgPSBhY2N1bXVsYXRlZE1lc3NhZ2UuY29udGVudFtjb250ZW50LmluZGV4XTtcbiAgICAgIGlmIChzbmFwc2hvdENvbnRlbnQ/LnR5cGUgPT0gJ3RleHQnKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJ3RleHRDcmVhdGVkJywgc25hcHNob3RDb250ZW50LnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAoZXZlbnQuZXZlbnQpIHtcbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmNyZWF0ZWQnOlxuICAgICAgICB0aGlzLl9lbWl0KCdtZXNzYWdlQ3JlYXRlZCcsIGV2ZW50LmRhdGEpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuaW5fcHJvZ3Jlc3MnOlxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuZGVsdGEnOlxuICAgICAgICB0aGlzLl9lbWl0KCdtZXNzYWdlRGVsdGEnLCBldmVudC5kYXRhLmRlbHRhLCBhY2N1bXVsYXRlZE1lc3NhZ2UpO1xuXG4gICAgICAgIGlmIChldmVudC5kYXRhLmRlbHRhLmNvbnRlbnQpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRlbnQgb2YgZXZlbnQuZGF0YS5kZWx0YS5jb250ZW50KSB7XG4gICAgICAgICAgICAvL0lmIGl0IGlzIHRleHQgZGVsdGEsIGVtaXQgYSB0ZXh0IGRlbHRhIGV2ZW50XG4gICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09ICd0ZXh0JyAmJiBjb250ZW50LnRleHQpIHtcbiAgICAgICAgICAgICAgbGV0IHRleHREZWx0YSA9IGNvbnRlbnQudGV4dDtcbiAgICAgICAgICAgICAgbGV0IHNuYXBzaG90ID0gYWNjdW11bGF0ZWRNZXNzYWdlLmNvbnRlbnRbY29udGVudC5pbmRleF07XG4gICAgICAgICAgICAgIGlmIChzbmFwc2hvdCAmJiBzbmFwc2hvdC50eXBlID09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3RleHREZWx0YScsIHRleHREZWx0YSwgc25hcHNob3QudGV4dCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1RoZSBzbmFwc2hvdCBhc3NvY2lhdGVkIHdpdGggdGhpcyB0ZXh0IGRlbHRhIGlzIG5vdCB0ZXh0IG9yIG1pc3NpbmcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29udGVudC5pbmRleCAhPSB0aGlzLiNjdXJyZW50Q29udGVudEluZGV4KSB7XG4gICAgICAgICAgICAgIC8vU2VlIGlmIHdlIGhhdmUgaW4gcHJvZ3Jlc3MgY29udGVudFxuICAgICAgICAgICAgICBpZiAodGhpcy4jY3VycmVudENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuI2N1cnJlbnRDb250ZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCd0ZXh0RG9uZScsIHRoaXMuI2N1cnJlbnRDb250ZW50LnRleHQsIHRoaXMuI21lc3NhZ2VTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnaW1hZ2VfZmlsZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2ltYWdlRmlsZURvbmUnLCB0aGlzLiNjdXJyZW50Q29udGVudC5pbWFnZV9maWxlLCB0aGlzLiNtZXNzYWdlU25hcHNob3QpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLiNjdXJyZW50Q29udGVudEluZGV4ID0gY29udGVudC5pbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy4jY3VycmVudENvbnRlbnQgPSBhY2N1bXVsYXRlZE1lc3NhZ2UuY29udGVudFtjb250ZW50LmluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuY29tcGxldGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmluY29tcGxldGUnOlxuICAgICAgICAvL1dlIGVtaXQgdGhlIGxhdGVzdCBjb250ZW50IHdlIHdlcmUgd29ya2luZyBvbiBvbiBjb21wbGV0aW9uIChpbmNsdWRpbmcgaW5jb21wbGV0ZSlcbiAgICAgICAgaWYgKHRoaXMuI2N1cnJlbnRDb250ZW50SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb250ZW50ID0gZXZlbnQuZGF0YS5jb250ZW50W3RoaXMuI2N1cnJlbnRDb250ZW50SW5kZXhdO1xuICAgICAgICAgIGlmIChjdXJyZW50Q29udGVudCkge1xuICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50Q29udGVudC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2ltYWdlX2ZpbGUnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2ltYWdlRmlsZURvbmUnLCBjdXJyZW50Q29udGVudC5pbWFnZV9maWxlLCB0aGlzLiNtZXNzYWdlU25hcHNob3QpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCd0ZXh0RG9uZScsIGN1cnJlbnRDb250ZW50LnRleHQsIHRoaXMuI21lc3NhZ2VTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuI21lc3NhZ2VTbmFwc2hvdCkge1xuICAgICAgICAgIHRoaXMuX2VtaXQoJ21lc3NhZ2VEb25lJywgZXZlbnQuZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNtZXNzYWdlU25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgI2hhbmRsZVJ1blN0ZXAodGhpczogQXNzaXN0YW50U3RyZWFtLCBldmVudDogUnVuU3RlcFN0cmVhbUV2ZW50KSB7XG4gICAgY29uc3QgYWNjdW11bGF0ZWRSdW5TdGVwID0gdGhpcy4jYWNjdW11bGF0ZVJ1blN0ZXAoZXZlbnQpO1xuICAgIHRoaXMuI2N1cnJlbnRSdW5TdGVwU25hcHNob3QgPSBhY2N1bXVsYXRlZFJ1blN0ZXA7XG5cbiAgICBzd2l0Y2ggKGV2ZW50LmV2ZW50KSB7XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY3JlYXRlZCc6XG4gICAgICAgIHRoaXMuX2VtaXQoJ3J1blN0ZXBDcmVhdGVkJywgZXZlbnQuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmRlbHRhJzpcbiAgICAgICAgY29uc3QgZGVsdGEgPSBldmVudC5kYXRhLmRlbHRhO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZGVsdGEuc3RlcF9kZXRhaWxzICYmXG4gICAgICAgICAgZGVsdGEuc3RlcF9kZXRhaWxzLnR5cGUgPT0gJ3Rvb2xfY2FsbHMnICYmXG4gICAgICAgICAgZGVsdGEuc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHMgJiZcbiAgICAgICAgICBhY2N1bXVsYXRlZFJ1blN0ZXAuc3RlcF9kZXRhaWxzLnR5cGUgPT0gJ3Rvb2xfY2FsbHMnXG4gICAgICAgICkge1xuICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgZGVsdGEuc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgIGlmICh0b29sQ2FsbC5pbmRleCA9PSB0aGlzLiNjdXJyZW50VG9vbENhbGxJbmRleCkge1xuICAgICAgICAgICAgICB0aGlzLl9lbWl0KFxuICAgICAgICAgICAgICAgICd0b29sQ2FsbERlbHRhJyxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbCxcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZFJ1blN0ZXAuc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHNbdG9vbENhbGwuaW5kZXhdIGFzIFRvb2xDYWxsLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuI2N1cnJlbnRUb29sQ2FsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3Rvb2xDYWxsRG9uZScsIHRoaXMuI2N1cnJlbnRUb29sQ2FsbCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLiNjdXJyZW50VG9vbENhbGxJbmRleCA9IHRvb2xDYWxsLmluZGV4O1xuICAgICAgICAgICAgICB0aGlzLiNjdXJyZW50VG9vbENhbGwgPSBhY2N1bXVsYXRlZFJ1blN0ZXAuc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHNbdG9vbENhbGwuaW5kZXhdO1xuICAgICAgICAgICAgICBpZiAodGhpcy4jY3VycmVudFRvb2xDYWxsKSB0aGlzLl9lbWl0KCd0b29sQ2FsbENyZWF0ZWQnLCB0aGlzLiNjdXJyZW50VG9vbENhbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VtaXQoJ3J1blN0ZXBEZWx0YScsIGV2ZW50LmRhdGEuZGVsdGEsIGFjY3VtdWxhdGVkUnVuU3RlcCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmNvbXBsZXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZmFpbGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jYW5jZWxsZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmV4cGlyZWQnOlxuICAgICAgICB0aGlzLiNjdXJyZW50UnVuU3RlcFNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gZXZlbnQuZGF0YS5zdGVwX2RldGFpbHM7XG4gICAgICAgIGlmIChkZXRhaWxzLnR5cGUgPT0gJ3Rvb2xfY2FsbHMnKSB7XG4gICAgICAgICAgaWYgKHRoaXMuI2N1cnJlbnRUb29sQ2FsbCkge1xuICAgICAgICAgICAgdGhpcy5fZW1pdCgndG9vbENhbGxEb25lJywgdGhpcy4jY3VycmVudFRvb2xDYWxsIGFzIFRvb2xDYWxsKTtcbiAgICAgICAgICAgIHRoaXMuI2N1cnJlbnRUb29sQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW1pdCgncnVuU3RlcERvbmUnLCBldmVudC5kYXRhLCBhY2N1bXVsYXRlZFJ1blN0ZXApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5pbl9wcm9ncmVzcyc6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gICNoYW5kbGVFdmVudCh0aGlzOiBBc3Npc3RhbnRTdHJlYW0sIGV2ZW50OiBBc3Npc3RhbnRTdHJlYW1FdmVudCkge1xuICAgIHRoaXMuI2V2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICB0aGlzLl9lbWl0KCdldmVudCcsIGV2ZW50KTtcbiAgfVxuXG4gICNhY2N1bXVsYXRlUnVuU3RlcChldmVudDogUnVuU3RlcFN0cmVhbUV2ZW50KTogUnVucy5SdW5TdGVwIHtcbiAgICBzd2l0Y2ggKGV2ZW50LmV2ZW50KSB7XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY3JlYXRlZCc6XG4gICAgICAgIHRoaXMuI3J1blN0ZXBTbmFwc2hvdHNbZXZlbnQuZGF0YS5pZF0gPSBldmVudC5kYXRhO1xuICAgICAgICByZXR1cm4gZXZlbnQuZGF0YTtcblxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmRlbHRhJzpcbiAgICAgICAgbGV0IHNuYXBzaG90ID0gdGhpcy4jcnVuU3RlcFNuYXBzaG90c1tldmVudC5kYXRhLmlkXSBhcyBSdW5zLlJ1blN0ZXA7XG4gICAgICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignUmVjZWl2ZWQgYSBSdW5TdGVwRGVsdGEgYmVmb3JlIGNyZWF0aW9uIG9mIGEgc25hcHNob3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkYXRhID0gZXZlbnQuZGF0YTtcblxuICAgICAgICBpZiAoZGF0YS5kZWx0YSkge1xuICAgICAgICAgIGNvbnN0IGFjY3VtdWxhdGVkID0gQXNzaXN0YW50U3RyZWFtLmFjY3VtdWxhdGVEZWx0YShzbmFwc2hvdCwgZGF0YS5kZWx0YSkgYXMgUnVucy5SdW5TdGVwO1xuICAgICAgICAgIHRoaXMuI3J1blN0ZXBTbmFwc2hvdHNbZXZlbnQuZGF0YS5pZF0gPSBhY2N1bXVsYXRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLiNydW5TdGVwU25hcHNob3RzW2V2ZW50LmRhdGEuaWRdIGFzIFJ1bnMuUnVuU3RlcDtcblxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmNvbXBsZXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZmFpbGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jYW5jZWxsZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmV4cGlyZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmluX3Byb2dyZXNzJzpcbiAgICAgICAgdGhpcy4jcnVuU3RlcFNuYXBzaG90c1tldmVudC5kYXRhLmlkXSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICh0aGlzLiNydW5TdGVwU25hcHNob3RzW2V2ZW50LmRhdGEuaWRdKSByZXR1cm4gdGhpcy4jcnVuU3RlcFNuYXBzaG90c1tldmVudC5kYXRhLmlkXSBhcyBSdW5zLlJ1blN0ZXA7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBzbmFwc2hvdCBhdmFpbGFibGUnKTtcbiAgfVxuXG4gICNhY2N1bXVsYXRlTWVzc2FnZShcbiAgICBldmVudDogQXNzaXN0YW50U3RyZWFtRXZlbnQsXG4gICAgc25hcHNob3Q6IE1lc3NhZ2UgfCB1bmRlZmluZWQsXG4gICk6IFtNZXNzYWdlLCBNZXNzYWdlQ29udGVudERlbHRhW11dIHtcbiAgICBsZXQgbmV3Q29udGVudDogTWVzc2FnZUNvbnRlbnREZWx0YVtdID0gW107XG5cbiAgICBzd2l0Y2ggKGV2ZW50LmV2ZW50KSB7XG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5jcmVhdGVkJzpcbiAgICAgICAgLy9PbiBjcmVhdGlvbiB0aGUgc25hcHNob3QgaXMganVzdCB0aGUgaW5pdGlhbCBtZXNzYWdlXG4gICAgICAgIHJldHVybiBbZXZlbnQuZGF0YSwgbmV3Q29udGVudF07XG5cbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmRlbHRhJzpcbiAgICAgICAgaWYgKCFzbmFwc2hvdCkge1xuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgJ1JlY2VpdmVkIGEgZGVsdGEgd2l0aCBubyBleGlzdGluZyBzbmFwc2hvdCAodGhlcmUgc2hvdWxkIGJlIG9uZSBmcm9tIG1lc3NhZ2UgY3JlYXRpb24pJyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRhdGEgPSBldmVudC5kYXRhO1xuXG4gICAgICAgIC8vSWYgdGhpcyBkZWx0YSBkb2VzIG5vdCBoYXZlIGNvbnRlbnQsIG5vdGhpbmcgdG8gcHJvY2Vzc1xuICAgICAgICBpZiAoZGF0YS5kZWx0YS5jb250ZW50KSB7XG4gICAgICAgICAgZm9yIChjb25zdCBjb250ZW50RWxlbWVudCBvZiBkYXRhLmRlbHRhLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmIChjb250ZW50RWxlbWVudC5pbmRleCBpbiBzbmFwc2hvdC5jb250ZW50KSB7XG4gICAgICAgICAgICAgIGxldCBjdXJyZW50Q29udGVudCA9IHNuYXBzaG90LmNvbnRlbnRbY29udGVudEVsZW1lbnQuaW5kZXhdO1xuICAgICAgICAgICAgICBzbmFwc2hvdC5jb250ZW50W2NvbnRlbnRFbGVtZW50LmluZGV4XSA9IHRoaXMuI2FjY3VtdWxhdGVDb250ZW50KFxuICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZW50LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc25hcHNob3QuY29udGVudFtjb250ZW50RWxlbWVudC5pbmRleF0gPSBjb250ZW50RWxlbWVudCBhcyBNZXNzYWdlQ29udGVudDtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5ldyBlbGVtZW50XG4gICAgICAgICAgICAgIG5ld0NvbnRlbnQucHVzaChjb250ZW50RWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtzbmFwc2hvdCwgbmV3Q29udGVudF07XG5cbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmluX3Byb2dyZXNzJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmNvbXBsZXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5pbmNvbXBsZXRlJzpcbiAgICAgICAgLy9ObyBjaGFuZ2VzIG9uIG90aGVyIHRocmVhZCBldmVudHNcbiAgICAgICAgaWYgKHNuYXBzaG90KSB7XG4gICAgICAgICAgcmV0dXJuIFtzbmFwc2hvdCwgbmV3Q29udGVudF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlY2VpdmVkIHRocmVhZCBtZXNzYWdlIGV2ZW50IHdpdGggbm8gZXhpc3Rpbmcgc25hcHNob3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBFcnJvcignVHJpZWQgdG8gYWNjdW11bGF0ZSBhIG5vbi1tZXNzYWdlIGV2ZW50Jyk7XG4gIH1cblxuICAjYWNjdW11bGF0ZUNvbnRlbnQoXG4gICAgY29udGVudEVsZW1lbnQ6IE1lc3NhZ2VDb250ZW50RGVsdGEsXG4gICAgY3VycmVudENvbnRlbnQ6IE1lc3NhZ2VDb250ZW50IHwgdW5kZWZpbmVkLFxuICApOiBUZXh0Q29udGVudEJsb2NrIHwgSW1hZ2VGaWxlQ29udGVudEJsb2NrIHtcbiAgICByZXR1cm4gQXNzaXN0YW50U3RyZWFtLmFjY3VtdWxhdGVEZWx0YShjdXJyZW50Q29udGVudCBhcyB1bmtub3duIGFzIFJlY29yZDxhbnksIGFueT4sIGNvbnRlbnRFbGVtZW50KSBhc1xuICAgICAgfCBUZXh0Q29udGVudEJsb2NrXG4gICAgICB8IEltYWdlRmlsZUNvbnRlbnRCbG9jaztcbiAgfVxuXG4gIHN0YXRpYyBhY2N1bXVsYXRlRGVsdGEoYWNjOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBkZWx0YTogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgIGZvciAoY29uc3QgW2tleSwgZGVsdGFWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGVsdGEpKSB7XG4gICAgICBpZiAoIWFjYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGFjY1trZXldID0gZGVsdGFWYWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBhY2NWYWx1ZSA9IGFjY1trZXldO1xuICAgICAgaWYgKGFjY1ZhbHVlID09PSBudWxsIHx8IGFjY1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWNjW2tleV0gPSBkZWx0YVZhbHVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgZG9uJ3QgYWNjdW11bGF0ZSB0aGVzZSBzcGVjaWFsIHByb3BlcnRpZXNcbiAgICAgIGlmIChrZXkgPT09ICdpbmRleCcgfHwga2V5ID09PSAndHlwZScpIHtcbiAgICAgICAgYWNjW2tleV0gPSBkZWx0YVZhbHVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVHlwZS1zcGVjaWZpYyBhY2N1bXVsYXRpb24gbG9naWNcbiAgICAgIGlmICh0eXBlb2YgYWNjVmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBkZWx0YVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBhY2NWYWx1ZSArPSBkZWx0YVZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYWNjVmFsdWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBkZWx0YVZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBhY2NWYWx1ZSArPSBkZWx0YVZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChDb3JlLmlzT2JqKGFjY1ZhbHVlKSAmJiBDb3JlLmlzT2JqKGRlbHRhVmFsdWUpKSB7XG4gICAgICAgIGFjY1ZhbHVlID0gdGhpcy5hY2N1bXVsYXRlRGVsdGEoYWNjVmFsdWUgYXMgUmVjb3JkPHN0cmluZywgYW55PiwgZGVsdGFWYWx1ZSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+KTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhY2NWYWx1ZSkgJiYgQXJyYXkuaXNBcnJheShkZWx0YVZhbHVlKSkge1xuICAgICAgICBpZiAoYWNjVmFsdWUuZXZlcnkoKHgpID0+IHR5cGVvZiB4ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgeCA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgYWNjVmFsdWUucHVzaCguLi5kZWx0YVZhbHVlKTsgLy8gVXNlIHNwcmVhZCBzeW50YXggZm9yIGVmZmljaWVudCBhZGRpdGlvblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBkZWx0YUVudHJ5IG9mIGRlbHRhVmFsdWUpIHtcbiAgICAgICAgICBpZiAoIUNvcmUuaXNPYmooZGVsdGFFbnRyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXJyYXkgZGVsdGEgZW50cnkgdG8gYmUgYW4gb2JqZWN0IGJ1dCBnb3Q6ICR7ZGVsdGFFbnRyeX1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpbmRleCA9IGRlbHRhRW50cnlbJ2luZGV4J107XG4gICAgICAgICAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZGVsdGFFbnRyeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGFycmF5IGRlbHRhIGVudHJ5IHRvIGhhdmUgYW4gYGluZGV4YCBwcm9wZXJ0eScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFycmF5IGRlbHRhIGVudHJ5IFxcYGluZGV4XFxgIHByb3BlcnR5IHRvIGJlIGEgbnVtYmVyIGJ1dCBnb3QgJHtpbmRleH1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBhY2NFbnRyeSA9IGFjY1ZhbHVlW2luZGV4XTtcbiAgICAgICAgICBpZiAoYWNjRW50cnkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYWNjVmFsdWUucHVzaChkZWx0YUVudHJ5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjVmFsdWVbaW5kZXhdID0gdGhpcy5hY2N1bXVsYXRlRGVsdGEoYWNjRW50cnksIGRlbHRhRW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKGBVbmhhbmRsZWQgcmVjb3JkIHR5cGU6ICR7a2V5fSwgZGVsdGFWYWx1ZTogJHtkZWx0YVZhbHVlfSwgYWNjVmFsdWU6ICR7YWNjVmFsdWV9YCk7XG4gICAgICB9XG4gICAgICBhY2Nba2V5XSA9IGFjY1ZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH1cblxuICAjaGFuZGxlUnVuKHRoaXM6IEFzc2lzdGFudFN0cmVhbSwgZXZlbnQ6IFJ1blN0cmVhbUV2ZW50KSB7XG4gICAgdGhpcy4jY3VycmVudFJ1blNuYXBzaG90ID0gZXZlbnQuZGF0YTtcbiAgICBzd2l0Y2ggKGV2ZW50LmV2ZW50KSB7XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmNyZWF0ZWQnOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4ucXVldWVkJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmluX3Byb2dyZXNzJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnJlcXVpcmVzX2FjdGlvbic6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmNhbmNlbGxlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmZhaWxlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmNvbXBsZXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmV4cGlyZWQnOlxuICAgICAgICB0aGlzLiNmaW5hbFJ1biA9IGV2ZW50LmRhdGE7XG4gICAgICAgIGlmICh0aGlzLiNjdXJyZW50VG9vbENhbGwpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0KCd0b29sQ2FsbERvbmUnLCB0aGlzLiNjdXJyZW50VG9vbENhbGwpO1xuICAgICAgICAgIHRoaXMuI2N1cnJlbnRUb29sQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uY2FuY2VsbGluZyc6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfYWRkUnVuKHJ1bjogUnVuKTogUnVuIHtcbiAgICByZXR1cm4gcnVuO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF90aHJlYWRBc3Npc3RhbnRTdHJlYW0oXG4gICAgcGFyYW1zOiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlLFxuICAgIHRocmVhZDogVGhyZWFkcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxSdW4+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fY3JlYXRlVGhyZWFkQXNzaXN0YW50U3RyZWFtKHRocmVhZCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfcnVuQXNzaXN0YW50U3RyZWFtKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuczogUnVucyxcbiAgICBwYXJhbXM6IFJ1bkNyZWF0ZVBhcmFtc0Jhc2UsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IFByb21pc2U8UnVuPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2NyZWF0ZUFzc2lzdGFudFN0cmVhbShydW5zLCB0aHJlYWRJZCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfcnVuVG9vbEFzc2lzdGFudFN0cmVhbShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgcnVuczogUnVucyxcbiAgICBwYXJhbXM6IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBQcm9taXNlPFJ1bj4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9jcmVhdGVUb29sQXNzaXN0YW50U3RyZWFtKHJ1bnMsIHRocmVhZElkLCBydW5JZCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgfVxufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIEFzc2lzdGFudHNBUEkgZnJvbSAnLi4vYXNzaXN0YW50cyc7XG5pbXBvcnQgeyBDdXJzb3JQYWdlLCB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9wYWdpbmF0aW9uJztcblxuZXhwb3J0IGNsYXNzIE1lc3NhZ2VzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbWVzc2FnZS5cbiAgICovXG4gIGNyZWF0ZShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIGJvZHk6IE1lc3NhZ2VDcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxNZXNzYWdlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9tZXNzYWdlc2AsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhIG1lc3NhZ2UuXG4gICAqL1xuICByZXRyaWV2ZSh0aHJlYWRJZDogc3RyaW5nLCBtZXNzYWdlSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8TWVzc2FnZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9tZXNzYWdlcy8ke21lc3NhZ2VJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZmllcyBhIG1lc3NhZ2UuXG4gICAqL1xuICB1cGRhdGUoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBtZXNzYWdlSWQ6IHN0cmluZyxcbiAgICBib2R5OiBNZXNzYWdlVXBkYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8TWVzc2FnZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vbWVzc2FnZXMvJHttZXNzYWdlSWR9YCwge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIG1lc3NhZ2VzIGZvciBhIGdpdmVuIHRocmVhZC5cbiAgICovXG4gIGxpc3QoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBxdWVyeT86IE1lc3NhZ2VMaXN0UGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPE1lc3NhZ2VzUGFnZSwgTWVzc2FnZT47XG4gIGxpc3QodGhyZWFkSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPE1lc3NhZ2VzUGFnZSwgTWVzc2FnZT47XG4gIGxpc3QoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBxdWVyeTogTWVzc2FnZUxpc3RQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8TWVzc2FnZXNQYWdlLCBNZXNzYWdlPiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0KHRocmVhZElkLCB7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L21lc3NhZ2VzYCwgTWVzc2FnZXNQYWdlLCB7XG4gICAgICBxdWVyeSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBtZXNzYWdlLlxuICAgKi9cbiAgZGVsKHRocmVhZElkOiBzdHJpbmcsIG1lc3NhZ2VJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxNZXNzYWdlRGVsZXRlZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZGVsZXRlKGAvdGhyZWFkcy8ke3RocmVhZElkfS9tZXNzYWdlcy8ke21lc3NhZ2VJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWVzc2FnZXNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxNZXNzYWdlPiB7fVxuXG4vKipcbiAqIEEgY2l0YXRpb24gd2l0aGluIHRoZSBtZXNzYWdlIHRoYXQgcG9pbnRzIHRvIGEgc3BlY2lmaWMgcXVvdGUgZnJvbSBhIHNwZWNpZmljXG4gKiBGaWxlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzaXN0YW50IG9yIHRoZSBtZXNzYWdlLiBHZW5lcmF0ZWQgd2hlbiB0aGUgYXNzaXN0YW50XG4gKiB1c2VzIHRoZSBcImZpbGVfc2VhcmNoXCIgdG9vbCB0byBzZWFyY2ggZmlsZXMuXG4gKi9cbmV4cG9ydCB0eXBlIEFubm90YXRpb24gPSBGaWxlQ2l0YXRpb25Bbm5vdGF0aW9uIHwgRmlsZVBhdGhBbm5vdGF0aW9uO1xuXG4vKipcbiAqIEEgY2l0YXRpb24gd2l0aGluIHRoZSBtZXNzYWdlIHRoYXQgcG9pbnRzIHRvIGEgc3BlY2lmaWMgcXVvdGUgZnJvbSBhIHNwZWNpZmljXG4gKiBGaWxlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzaXN0YW50IG9yIHRoZSBtZXNzYWdlLiBHZW5lcmF0ZWQgd2hlbiB0aGUgYXNzaXN0YW50XG4gKiB1c2VzIHRoZSBcImZpbGVfc2VhcmNoXCIgdG9vbCB0byBzZWFyY2ggZmlsZXMuXG4gKi9cbmV4cG9ydCB0eXBlIEFubm90YXRpb25EZWx0YSA9IEZpbGVDaXRhdGlvbkRlbHRhQW5ub3RhdGlvbiB8IEZpbGVQYXRoRGVsdGFBbm5vdGF0aW9uO1xuXG4vKipcbiAqIEEgY2l0YXRpb24gd2l0aGluIHRoZSBtZXNzYWdlIHRoYXQgcG9pbnRzIHRvIGEgc3BlY2lmaWMgcXVvdGUgZnJvbSBhIHNwZWNpZmljXG4gKiBGaWxlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzaXN0YW50IG9yIHRoZSBtZXNzYWdlLiBHZW5lcmF0ZWQgd2hlbiB0aGUgYXNzaXN0YW50XG4gKiB1c2VzIHRoZSBcImZpbGVfc2VhcmNoXCIgdG9vbCB0byBzZWFyY2ggZmlsZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUNpdGF0aW9uQW5ub3RhdGlvbiB7XG4gIGVuZF9pbmRleDogbnVtYmVyO1xuXG4gIGZpbGVfY2l0YXRpb246IEZpbGVDaXRhdGlvbkFubm90YXRpb24uRmlsZUNpdGF0aW9uO1xuXG4gIHN0YXJ0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGluIHRoZSBtZXNzYWdlIGNvbnRlbnQgdGhhdCBuZWVkcyB0byBiZSByZXBsYWNlZC5cbiAgICovXG4gIHRleHQ6IHN0cmluZztcblxuICAvKipcbiAgICogQWx3YXlzIGBmaWxlX2NpdGF0aW9uYC5cbiAgICovXG4gIHR5cGU6ICdmaWxlX2NpdGF0aW9uJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaWxlQ2l0YXRpb25Bbm5vdGF0aW9uIHtcbiAgZXhwb3J0IGludGVyZmFjZSBGaWxlQ2l0YXRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgc3BlY2lmaWMgRmlsZSB0aGUgY2l0YXRpb24gaXMgZnJvbS5cbiAgICAgKi9cbiAgICBmaWxlX2lkOiBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNpdGF0aW9uIHdpdGhpbiB0aGUgbWVzc2FnZSB0aGF0IHBvaW50cyB0byBhIHNwZWNpZmljIHF1b3RlIGZyb20gYSBzcGVjaWZpY1xuICogRmlsZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2lzdGFudCBvciB0aGUgbWVzc2FnZS4gR2VuZXJhdGVkIHdoZW4gdGhlIGFzc2lzdGFudFxuICogdXNlcyB0aGUgXCJmaWxlX3NlYXJjaFwiIHRvb2wgdG8gc2VhcmNoIGZpbGVzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVDaXRhdGlvbkRlbHRhQW5ub3RhdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGFubm90YXRpb24gaW4gdGhlIHRleHQgY29udGVudCBwYXJ0LlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogQWx3YXlzIGBmaWxlX2NpdGF0aW9uYC5cbiAgICovXG4gIHR5cGU6ICdmaWxlX2NpdGF0aW9uJztcblxuICBlbmRfaW5kZXg/OiBudW1iZXI7XG5cbiAgZmlsZV9jaXRhdGlvbj86IEZpbGVDaXRhdGlvbkRlbHRhQW5ub3RhdGlvbi5GaWxlQ2l0YXRpb247XG5cbiAgc3RhcnRfaW5kZXg/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGluIHRoZSBtZXNzYWdlIGNvbnRlbnQgdGhhdCBuZWVkcyB0byBiZSByZXBsYWNlZC5cbiAgICovXG4gIHRleHQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRmlsZUNpdGF0aW9uRGVsdGFBbm5vdGF0aW9uIHtcbiAgZXhwb3J0IGludGVyZmFjZSBGaWxlQ2l0YXRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgc3BlY2lmaWMgRmlsZSB0aGUgY2l0YXRpb24gaXMgZnJvbS5cbiAgICAgKi9cbiAgICBmaWxlX2lkPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNwZWNpZmljIHF1b3RlIGluIHRoZSBmaWxlLlxuICAgICAqL1xuICAgIHF1b3RlPzogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogQSBVUkwgZm9yIHRoZSBmaWxlIHRoYXQncyBnZW5lcmF0ZWQgd2hlbiB0aGUgYXNzaXN0YW50IHVzZWQgdGhlXG4gKiBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCB0byBnZW5lcmF0ZSBhIGZpbGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVBhdGhBbm5vdGF0aW9uIHtcbiAgZW5kX2luZGV4OiBudW1iZXI7XG5cbiAgZmlsZV9wYXRoOiBGaWxlUGF0aEFubm90YXRpb24uRmlsZVBhdGg7XG5cbiAgc3RhcnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHRleHQgaW4gdGhlIG1lc3NhZ2UgY29udGVudCB0aGF0IG5lZWRzIHRvIGJlIHJlcGxhY2VkLlxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYGZpbGVfcGF0aGAuXG4gICAqL1xuICB0eXBlOiAnZmlsZV9wYXRoJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaWxlUGF0aEFubm90YXRpb24ge1xuICBleHBvcnQgaW50ZXJmYWNlIEZpbGVQYXRoIHtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdGhhdCB3YXMgZ2VuZXJhdGVkLlxuICAgICAqL1xuICAgIGZpbGVfaWQ6IHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIEEgVVJMIGZvciB0aGUgZmlsZSB0aGF0J3MgZ2VuZXJhdGVkIHdoZW4gdGhlIGFzc2lzdGFudCB1c2VkIHRoZVxuICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgdG8gZ2VuZXJhdGUgYSBmaWxlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVQYXRoRGVsdGFBbm5vdGF0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgYW5ub3RhdGlvbiBpbiB0aGUgdGV4dCBjb250ZW50IHBhcnQuXG4gICAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYGZpbGVfcGF0aGAuXG4gICAqL1xuICB0eXBlOiAnZmlsZV9wYXRoJztcblxuICBlbmRfaW5kZXg/OiBudW1iZXI7XG5cbiAgZmlsZV9wYXRoPzogRmlsZVBhdGhEZWx0YUFubm90YXRpb24uRmlsZVBhdGg7XG5cbiAgc3RhcnRfaW5kZXg/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGluIHRoZSBtZXNzYWdlIGNvbnRlbnQgdGhhdCBuZWVkcyB0byBiZSByZXBsYWNlZC5cbiAgICovXG4gIHRleHQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRmlsZVBhdGhEZWx0YUFubm90YXRpb24ge1xuICBleHBvcnQgaW50ZXJmYWNlIEZpbGVQYXRoIHtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdGhhdCB3YXMgZ2VuZXJhdGVkLlxuICAgICAqL1xuICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZUZpbGUge1xuICAvKipcbiAgICogVGhlIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRCBvZiB0aGUgaW1hZ2VcbiAgICogaW4gdGhlIG1lc3NhZ2UgY29udGVudC4gU2V0IGBwdXJwb3NlPVwidmlzaW9uXCJgIHdoZW4gdXBsb2FkaW5nIHRoZSBGaWxlIGlmIHlvdVxuICAgKiBuZWVkIHRvIGxhdGVyIGRpc3BsYXkgdGhlIGZpbGUgY29udGVudC5cbiAgICovXG4gIGZpbGVfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkZXRhaWwgbGV2ZWwgb2YgdGhlIGltYWdlIGlmIHNwZWNpZmllZCBieSB0aGUgdXNlci4gYGxvd2AgdXNlc1xuICAgKiBmZXdlciB0b2tlbnMsIHlvdSBjYW4gb3B0IGluIHRvIGhpZ2ggcmVzb2x1dGlvbiB1c2luZyBgaGlnaGAuXG4gICAqL1xuICBkZXRhaWw/OiAnYXV0bycgfCAnbG93JyB8ICdoaWdoJztcbn1cblxuLyoqXG4gKiBSZWZlcmVuY2VzIGFuIGltYWdlIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKVxuICogaW4gdGhlIGNvbnRlbnQgb2YgYSBtZXNzYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlRmlsZUNvbnRlbnRCbG9jayB7XG4gIGltYWdlX2ZpbGU6IEltYWdlRmlsZTtcblxuICAvKipcbiAgICogQWx3YXlzIGBpbWFnZV9maWxlYC5cbiAgICovXG4gIHR5cGU6ICdpbWFnZV9maWxlJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZUZpbGVEZWx0YSB7XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGRldGFpbCBsZXZlbCBvZiB0aGUgaW1hZ2UgaWYgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyLiBgbG93YCB1c2VzXG4gICAqIGZld2VyIHRva2VucywgeW91IGNhbiBvcHQgaW4gdG8gaGlnaCByZXNvbHV0aW9uIHVzaW5nIGBoaWdoYC5cbiAgICovXG4gIGRldGFpbD86ICdhdXRvJyB8ICdsb3cnIHwgJ2hpZ2gnO1xuXG4gIC8qKlxuICAgKiBUaGUgW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEIG9mIHRoZSBpbWFnZVxuICAgKiBpbiB0aGUgbWVzc2FnZSBjb250ZW50LiBTZXQgYHB1cnBvc2U9XCJ2aXNpb25cImAgd2hlbiB1cGxvYWRpbmcgdGhlIEZpbGUgaWYgeW91XG4gICAqIG5lZWQgdG8gbGF0ZXIgZGlzcGxheSB0aGUgZmlsZSBjb250ZW50LlxuICAgKi9cbiAgZmlsZV9pZD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZWZlcmVuY2VzIGFuIGltYWdlIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKVxuICogaW4gdGhlIGNvbnRlbnQgb2YgYSBtZXNzYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlRmlsZURlbHRhQmxvY2sge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgaW4gdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYGltYWdlX2ZpbGVgLlxuICAgKi9cbiAgdHlwZTogJ2ltYWdlX2ZpbGUnO1xuXG4gIGltYWdlX2ZpbGU/OiBJbWFnZUZpbGVEZWx0YTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZVVSTCB7XG4gIC8qKlxuICAgKiBUaGUgZXh0ZXJuYWwgVVJMIG9mIHRoZSBpbWFnZSwgbXVzdCBiZSBhIHN1cHBvcnRlZCBpbWFnZSB0eXBlczoganBlZywganBnLCBwbmcsXG4gICAqIGdpZiwgd2VicC5cbiAgICovXG4gIHVybDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGRldGFpbCBsZXZlbCBvZiB0aGUgaW1hZ2UuIGBsb3dgIHVzZXMgZmV3ZXIgdG9rZW5zLCB5b3UgY2FuIG9wdCBpblxuICAgKiB0byBoaWdoIHJlc29sdXRpb24gdXNpbmcgYGhpZ2hgLiBEZWZhdWx0IHZhbHVlIGlzIGBhdXRvYFxuICAgKi9cbiAgZGV0YWlsPzogJ2F1dG8nIHwgJ2xvdycgfCAnaGlnaCc7XG59XG5cbi8qKlxuICogUmVmZXJlbmNlcyBhbiBpbWFnZSBVUkwgaW4gdGhlIGNvbnRlbnQgb2YgYSBtZXNzYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlVVJMQ29udGVudEJsb2NrIHtcbiAgaW1hZ2VfdXJsOiBJbWFnZVVSTDtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIGNvbnRlbnQgcGFydC5cbiAgICovXG4gIHR5cGU6ICdpbWFnZV91cmwnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlVVJMRGVsdGEge1xuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkZXRhaWwgbGV2ZWwgb2YgdGhlIGltYWdlLiBgbG93YCB1c2VzIGZld2VyIHRva2VucywgeW91IGNhbiBvcHQgaW5cbiAgICogdG8gaGlnaCByZXNvbHV0aW9uIHVzaW5nIGBoaWdoYC5cbiAgICovXG4gIGRldGFpbD86ICdhdXRvJyB8ICdsb3cnIHwgJ2hpZ2gnO1xuXG4gIC8qKlxuICAgKiBUaGUgVVJMIG9mIHRoZSBpbWFnZSwgbXVzdCBiZSBhIHN1cHBvcnRlZCBpbWFnZSB0eXBlczoganBlZywganBnLCBwbmcsIGdpZixcbiAgICogd2VicC5cbiAgICovXG4gIHVybD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZWZlcmVuY2VzIGFuIGltYWdlIFVSTCBpbiB0aGUgY29udGVudCBvZiBhIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VVUkxEZWx0YUJsb2NrIHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGluIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogQWx3YXlzIGBpbWFnZV91cmxgLlxuICAgKi9cbiAgdHlwZTogJ2ltYWdlX3VybCc7XG5cbiAgaW1hZ2VfdXJsPzogSW1hZ2VVUkxEZWx0YTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgbWVzc2FnZSB3aXRoaW4gYVxuICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlIHtcbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogSWYgYXBwbGljYWJsZSwgdGhlIElEIG9mIHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIHRoYXRcbiAgICogYXV0aG9yZWQgdGhpcyBtZXNzYWdlLlxuICAgKi9cbiAgYXNzaXN0YW50X2lkOiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgZmlsZXMgYXR0YWNoZWQgdG8gdGhlIG1lc3NhZ2UsIGFuZCB0aGUgdG9vbHMgdGhleSB3ZXJlIGFkZGVkIHRvLlxuICAgKi9cbiAgYXR0YWNobWVudHM6IEFycmF5PE1lc3NhZ2UuQXR0YWNobWVudD4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBtZXNzYWdlIHdhcyBjb21wbGV0ZWQuXG4gICAqL1xuICBjb21wbGV0ZWRfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBtZXNzYWdlIGluIGFycmF5IG9mIHRleHQgYW5kL29yIGltYWdlcy5cbiAgICovXG4gIGNvbnRlbnQ6IEFycmF5PE1lc3NhZ2VDb250ZW50PjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgbWVzc2FnZSB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgbWVzc2FnZSB3YXMgbWFya2VkIGFzIGluY29tcGxldGUuXG4gICAqL1xuICBpbmNvbXBsZXRlX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPbiBhbiBpbmNvbXBsZXRlIG1lc3NhZ2UsIGRldGFpbHMgYWJvdXQgd2h5IHRoZSBtZXNzYWdlIGlzIGluY29tcGxldGUuXG4gICAqL1xuICBpbmNvbXBsZXRlX2RldGFpbHM6IE1lc3NhZ2UuSW5jb21wbGV0ZURldGFpbHMgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YTogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGB0aHJlYWQubWVzc2FnZWAuXG4gICAqL1xuICBvYmplY3Q6ICd0aHJlYWQubWVzc2FnZSc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbnRpdHkgdGhhdCBwcm9kdWNlZCB0aGUgbWVzc2FnZS4gT25lIG9mIGB1c2VyYCBvciBgYXNzaXN0YW50YC5cbiAgICovXG4gIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucylcbiAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSBjcmVhdGlvbiBvZiB0aGlzIG1lc3NhZ2UuIFZhbHVlIGlzIGBudWxsYCB3aGVuIG1lc3NhZ2VzIGFyZVxuICAgKiBjcmVhdGVkIG1hbnVhbGx5IHVzaW5nIHRoZSBjcmVhdGUgbWVzc2FnZSBvciBjcmVhdGUgdGhyZWFkIGVuZHBvaW50cy5cbiAgICovXG4gIHJ1bl9pZDogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHN0YXR1cyBvZiB0aGUgbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGVpdGhlciBgaW5fcHJvZ3Jlc3NgLCBgaW5jb21wbGV0ZWAsIG9yXG4gICAqIGBjb21wbGV0ZWRgLlxuICAgKi9cbiAgc3RhdHVzOiAnaW5fcHJvZ3Jlc3MnIHwgJ2luY29tcGxldGUnIHwgJ2NvbXBsZXRlZCc7XG5cbiAgLyoqXG4gICAqIFRoZSBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpIElEIHRoYXRcbiAgICogdGhpcyBtZXNzYWdlIGJlbG9uZ3MgdG8uXG4gICAqL1xuICB0aHJlYWRfaWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBNZXNzYWdlIHtcbiAgZXhwb3J0IGludGVyZmFjZSBBdHRhY2htZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gYXR0YWNoIHRvIHRoZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG9vbHMgdG8gYWRkIHRoaXMgZmlsZSB0by5cbiAgICAgKi9cbiAgICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEF0dGFjaG1lbnQuQXNzaXN0YW50VG9vbHNGaWxlU2VhcmNoVHlwZU9ubHk+O1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBBdHRhY2htZW50IHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIEFzc2lzdGFudFRvb2xzRmlsZVNlYXJjaFR5cGVPbmx5IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHR5cGUgb2YgdG9vbCBiZWluZyBkZWZpbmVkOiBgZmlsZV9zZWFyY2hgXG4gICAgICAgKi9cbiAgICAgIHR5cGU6ICdmaWxlX3NlYXJjaCc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGFuIGluY29tcGxldGUgbWVzc2FnZSwgZGV0YWlscyBhYm91dCB3aHkgdGhlIG1lc3NhZ2UgaXMgaW5jb21wbGV0ZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSW5jb21wbGV0ZURldGFpbHMge1xuICAgIC8qKlxuICAgICAqIFRoZSByZWFzb24gdGhlIG1lc3NhZ2UgaXMgaW5jb21wbGV0ZS5cbiAgICAgKi9cbiAgICByZWFzb246ICdjb250ZW50X2ZpbHRlcicgfCAnbWF4X3Rva2VucycgfCAncnVuX2NhbmNlbGxlZCcgfCAncnVuX2V4cGlyZWQnIHwgJ3J1bl9mYWlsZWQnO1xuICB9XG59XG5cbi8qKlxuICogUmVmZXJlbmNlcyBhbiBpbWFnZSBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcylcbiAqIGluIHRoZSBjb250ZW50IG9mIGEgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IHR5cGUgTWVzc2FnZUNvbnRlbnQgPVxuICB8IEltYWdlRmlsZUNvbnRlbnRCbG9ja1xuICB8IEltYWdlVVJMQ29udGVudEJsb2NrXG4gIHwgVGV4dENvbnRlbnRCbG9ja1xuICB8IFJlZnVzYWxDb250ZW50QmxvY2s7XG5cbi8qKlxuICogUmVmZXJlbmNlcyBhbiBpbWFnZSBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcylcbiAqIGluIHRoZSBjb250ZW50IG9mIGEgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IHR5cGUgTWVzc2FnZUNvbnRlbnREZWx0YSA9XG4gIHwgSW1hZ2VGaWxlRGVsdGFCbG9ja1xuICB8IFRleHREZWx0YUJsb2NrXG4gIHwgUmVmdXNhbERlbHRhQmxvY2tcbiAgfCBJbWFnZVVSTERlbHRhQmxvY2s7XG5cbi8qKlxuICogUmVmZXJlbmNlcyBhbiBpbWFnZSBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcylcbiAqIGluIHRoZSBjb250ZW50IG9mIGEgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IHR5cGUgTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0gPSBJbWFnZUZpbGVDb250ZW50QmxvY2sgfCBJbWFnZVVSTENvbnRlbnRCbG9jayB8IFRleHRDb250ZW50QmxvY2tQYXJhbTtcblxuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlRGVsZXRlZCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgZGVsZXRlZDogYm9vbGVhbjtcblxuICBvYmplY3Q6ICd0aHJlYWQubWVzc2FnZS5kZWxldGVkJztcbn1cblxuLyoqXG4gKiBUaGUgZGVsdGEgY29udGFpbmluZyB0aGUgZmllbGRzIHRoYXQgaGF2ZSBjaGFuZ2VkIG9uIHRoZSBNZXNzYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VEZWx0YSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZSBpbiBhcnJheSBvZiB0ZXh0IGFuZC9vciBpbWFnZXMuXG4gICAqL1xuICBjb250ZW50PzogQXJyYXk8TWVzc2FnZUNvbnRlbnREZWx0YT47XG5cbiAgLyoqXG4gICAqIFRoZSBlbnRpdHkgdGhhdCBwcm9kdWNlZCB0aGUgbWVzc2FnZS4gT25lIG9mIGB1c2VyYCBvciBgYXNzaXN0YW50YC5cbiAgICovXG4gIHJvbGU/OiAndXNlcicgfCAnYXNzaXN0YW50Jztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgbWVzc2FnZSBkZWx0YSBpLmUuIGFueSBjaGFuZ2VkIGZpZWxkcyBvbiBhIG1lc3NhZ2UgZHVyaW5nXG4gKiBzdHJlYW1pbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZURlbHRhRXZlbnQge1xuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIgb2YgdGhlIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVsdGEgY29udGFpbmluZyB0aGUgZmllbGRzIHRoYXQgaGF2ZSBjaGFuZ2VkIG9uIHRoZSBNZXNzYWdlLlxuICAgKi9cbiAgZGVsdGE6IE1lc3NhZ2VEZWx0YTtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYHRocmVhZC5tZXNzYWdlLmRlbHRhYC5cbiAgICovXG4gIG9iamVjdDogJ3RocmVhZC5tZXNzYWdlLmRlbHRhJztcbn1cblxuLyoqXG4gKiBUaGUgcmVmdXNhbCBjb250ZW50IGdlbmVyYXRlZCBieSB0aGUgYXNzaXN0YW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlZnVzYWxDb250ZW50QmxvY2sge1xuICByZWZ1c2FsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgcmVmdXNhbGAuXG4gICAqL1xuICB0eXBlOiAncmVmdXNhbCc7XG59XG5cbi8qKlxuICogVGhlIHJlZnVzYWwgY29udGVudCB0aGF0IGlzIHBhcnQgb2YgYSBtZXNzYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlZnVzYWxEZWx0YUJsb2NrIHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgcmVmdXNhbCBwYXJ0IGluIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogQWx3YXlzIGByZWZ1c2FsYC5cbiAgICovXG4gIHR5cGU6ICdyZWZ1c2FsJztcblxuICByZWZ1c2FsPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRleHQge1xuICBhbm5vdGF0aW9uczogQXJyYXk8QW5ub3RhdGlvbj47XG5cbiAgLyoqXG4gICAqIFRoZSBkYXRhIHRoYXQgbWFrZXMgdXAgdGhlIHRleHQuXG4gICAqL1xuICB2YWx1ZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRoZSB0ZXh0IGNvbnRlbnQgdGhhdCBpcyBwYXJ0IG9mIGEgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZXh0Q29udGVudEJsb2NrIHtcbiAgdGV4dDogVGV4dDtcblxuICAvKipcbiAgICogQWx3YXlzIGB0ZXh0YC5cbiAgICovXG4gIHR5cGU6ICd0ZXh0Jztcbn1cblxuLyoqXG4gKiBUaGUgdGV4dCBjb250ZW50IHRoYXQgaXMgcGFydCBvZiBhIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dENvbnRlbnRCbG9ja1BhcmFtIHtcbiAgLyoqXG4gICAqIFRleHQgY29udGVudCB0byBiZSBzZW50IHRvIHRoZSBtb2RlbFxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYHRleHRgLlxuICAgKi9cbiAgdHlwZTogJ3RleHQnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRleHREZWx0YSB7XG4gIGFubm90YXRpb25zPzogQXJyYXk8QW5ub3RhdGlvbkRlbHRhPjtcblxuICAvKipcbiAgICogVGhlIGRhdGEgdGhhdCBtYWtlcyB1cCB0aGUgdGV4dC5cbiAgICovXG4gIHZhbHVlPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRoZSB0ZXh0IGNvbnRlbnQgdGhhdCBpcyBwYXJ0IG9mIGEgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZXh0RGVsdGFCbG9jayB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCBpbiB0aGUgbWVzc2FnZS5cbiAgICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgdGV4dGAuXG4gICAqL1xuICB0eXBlOiAndGV4dCc7XG5cbiAgdGV4dD86IFRleHREZWx0YTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8TWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0+O1xuXG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgZW50aXR5IHRoYXQgaXMgY3JlYXRpbmcgdGhlIG1lc3NhZ2UuIEFsbG93ZWQgdmFsdWVzIGluY2x1ZGU6XG4gICAqXG4gICAqIC0gYHVzZXJgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgc2VudCBieSBhbiBhY3R1YWwgdXNlciBhbmQgc2hvdWxkIGJlIHVzZWQgaW5cbiAgICogICBtb3N0IGNhc2VzIHRvIHJlcHJlc2VudCB1c2VyLWdlbmVyYXRlZCBtZXNzYWdlcy5cbiAgICogLSBgYXNzaXN0YW50YDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGdlbmVyYXRlZCBieSB0aGUgYXNzaXN0YW50LiBVc2UgdGhpc1xuICAgKiAgIHZhbHVlIHRvIGluc2VydCBtZXNzYWdlcyBmcm9tIHRoZSBhc3Npc3RhbnQgaW50byB0aGUgY29udmVyc2F0aW9uLlxuICAgKi9cbiAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byB0aGUgbWVzc2FnZSwgYW5kIHRoZSB0b29scyB0aGV5IHNob3VsZCBiZSBhZGRlZCB0by5cbiAgICovXG4gIGF0dGFjaG1lbnRzPzogQXJyYXk8TWVzc2FnZUNyZWF0ZVBhcmFtcy5BdHRhY2htZW50PiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgTWVzc2FnZUNyZWF0ZVBhcmFtcyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudCB7XG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBmaWxlIHRvIGF0dGFjaCB0byB0aGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBmaWxlX2lkPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvb2xzIHRvIGFkZCB0aGlzIGZpbGUgdG8uXG4gICAgICovXG4gICAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkNvZGVJbnRlcnByZXRlclRvb2wgfCBBdHRhY2htZW50LkZpbGVTZWFyY2g+O1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBBdHRhY2htZW50IHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdHlwZSBvZiB0b29sIGJlaW5nIGRlZmluZWQ6IGBmaWxlX3NlYXJjaGBcbiAgICAgICAqL1xuICAgICAgdHlwZTogJ2ZpbGVfc2VhcmNoJztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlVXBkYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZUxpc3RQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgY3Vyc29yIGZvciB1c2UgaW4gcGFnaW5hdGlvbi4gYGJlZm9yZWAgaXMgYW4gb2JqZWN0IElEIHRoYXQgZGVmaW5lcyB5b3VyIHBsYWNlXG4gICAqIGluIHRoZSBsaXN0LiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBtYWtlIGEgbGlzdCByZXF1ZXN0IGFuZCByZWNlaXZlIDEwMCBvYmplY3RzLFxuICAgKiBzdGFydGluZyB3aXRoIG9ial9mb28sIHlvdXIgc3Vic2VxdWVudCBjYWxsIGNhbiBpbmNsdWRlIGJlZm9yZT1vYmpfZm9vIGluIG9yZGVyXG4gICAqIHRvIGZldGNoIHRoZSBwcmV2aW91cyBwYWdlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgYmVmb3JlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTb3J0IG9yZGVyIGJ5IHRoZSBgY3JlYXRlZF9hdGAgdGltZXN0YW1wIG9mIHRoZSBvYmplY3RzLiBgYXNjYCBmb3IgYXNjZW5kaW5nXG4gICAqIG9yZGVyIGFuZCBgZGVzY2AgZm9yIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAqL1xuICBvcmRlcj86ICdhc2MnIHwgJ2Rlc2MnO1xuXG4gIC8qKlxuICAgKiBGaWx0ZXIgbWVzc2FnZXMgYnkgdGhlIHJ1biBJRCB0aGF0IGdlbmVyYXRlZCB0aGVtLlxuICAgKi9cbiAgcnVuX2lkPzogc3RyaW5nO1xufVxuXG5NZXNzYWdlcy5NZXNzYWdlc1BhZ2UgPSBNZXNzYWdlc1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBNZXNzYWdlcyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBBbm5vdGF0aW9uIGFzIEFubm90YXRpb24sXG4gICAgdHlwZSBBbm5vdGF0aW9uRGVsdGEgYXMgQW5ub3RhdGlvbkRlbHRhLFxuICAgIHR5cGUgRmlsZUNpdGF0aW9uQW5ub3RhdGlvbiBhcyBGaWxlQ2l0YXRpb25Bbm5vdGF0aW9uLFxuICAgIHR5cGUgRmlsZUNpdGF0aW9uRGVsdGFBbm5vdGF0aW9uIGFzIEZpbGVDaXRhdGlvbkRlbHRhQW5ub3RhdGlvbixcbiAgICB0eXBlIEZpbGVQYXRoQW5ub3RhdGlvbiBhcyBGaWxlUGF0aEFubm90YXRpb24sXG4gICAgdHlwZSBGaWxlUGF0aERlbHRhQW5ub3RhdGlvbiBhcyBGaWxlUGF0aERlbHRhQW5ub3RhdGlvbixcbiAgICB0eXBlIEltYWdlRmlsZSBhcyBJbWFnZUZpbGUsXG4gICAgdHlwZSBJbWFnZUZpbGVDb250ZW50QmxvY2sgYXMgSW1hZ2VGaWxlQ29udGVudEJsb2NrLFxuICAgIHR5cGUgSW1hZ2VGaWxlRGVsdGEgYXMgSW1hZ2VGaWxlRGVsdGEsXG4gICAgdHlwZSBJbWFnZUZpbGVEZWx0YUJsb2NrIGFzIEltYWdlRmlsZURlbHRhQmxvY2ssXG4gICAgdHlwZSBJbWFnZVVSTCBhcyBJbWFnZVVSTCxcbiAgICB0eXBlIEltYWdlVVJMQ29udGVudEJsb2NrIGFzIEltYWdlVVJMQ29udGVudEJsb2NrLFxuICAgIHR5cGUgSW1hZ2VVUkxEZWx0YSBhcyBJbWFnZVVSTERlbHRhLFxuICAgIHR5cGUgSW1hZ2VVUkxEZWx0YUJsb2NrIGFzIEltYWdlVVJMRGVsdGFCbG9jayxcbiAgICB0eXBlIE1lc3NhZ2UgYXMgTWVzc2FnZSxcbiAgICB0eXBlIE1lc3NhZ2VDb250ZW50IGFzIE1lc3NhZ2VDb250ZW50LFxuICAgIHR5cGUgTWVzc2FnZUNvbnRlbnREZWx0YSBhcyBNZXNzYWdlQ29udGVudERlbHRhLFxuICAgIHR5cGUgTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0gYXMgTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0sXG4gICAgdHlwZSBNZXNzYWdlRGVsZXRlZCBhcyBNZXNzYWdlRGVsZXRlZCxcbiAgICB0eXBlIE1lc3NhZ2VEZWx0YSBhcyBNZXNzYWdlRGVsdGEsXG4gICAgdHlwZSBNZXNzYWdlRGVsdGFFdmVudCBhcyBNZXNzYWdlRGVsdGFFdmVudCxcbiAgICB0eXBlIFJlZnVzYWxDb250ZW50QmxvY2sgYXMgUmVmdXNhbENvbnRlbnRCbG9jayxcbiAgICB0eXBlIFJlZnVzYWxEZWx0YUJsb2NrIGFzIFJlZnVzYWxEZWx0YUJsb2NrLFxuICAgIHR5cGUgVGV4dCBhcyBUZXh0LFxuICAgIHR5cGUgVGV4dENvbnRlbnRCbG9jayBhcyBUZXh0Q29udGVudEJsb2NrLFxuICAgIHR5cGUgVGV4dENvbnRlbnRCbG9ja1BhcmFtIGFzIFRleHRDb250ZW50QmxvY2tQYXJhbSxcbiAgICB0eXBlIFRleHREZWx0YSBhcyBUZXh0RGVsdGEsXG4gICAgdHlwZSBUZXh0RGVsdGFCbG9jayBhcyBUZXh0RGVsdGFCbG9jayxcbiAgICBNZXNzYWdlc1BhZ2UgYXMgTWVzc2FnZXNQYWdlLFxuICAgIHR5cGUgTWVzc2FnZUNyZWF0ZVBhcmFtcyBhcyBNZXNzYWdlQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgTWVzc2FnZVVwZGF0ZVBhcmFtcyBhcyBNZXNzYWdlVXBkYXRlUGFyYW1zLFxuICAgIHR5cGUgTWVzc2FnZUxpc3RQYXJhbXMgYXMgTWVzc2FnZUxpc3RQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi8uLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgU3RlcHNBUEkgZnJvbSAnLi9zdGVwcyc7XG5pbXBvcnQgeyBDdXJzb3JQYWdlLCB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi8uLi9wYWdpbmF0aW9uJztcblxuZXhwb3J0IGNsYXNzIFN0ZXBzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogUmV0cmlldmVzIGEgcnVuIHN0ZXAuXG4gICAqL1xuICByZXRyaWV2ZShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgc3RlcElkOiBzdHJpbmcsXG4gICAgcXVlcnk/OiBTdGVwUmV0cmlldmVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxSdW5TdGVwPjtcbiAgcmV0cmlldmUoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIHN0ZXBJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8UnVuU3RlcD47XG4gIHJldHJpZXZlKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBzdGVwSWQ6IHN0cmluZyxcbiAgICBxdWVyeTogU3RlcFJldHJpZXZlUGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8UnVuU3RlcD4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmUodGhyZWFkSWQsIHJ1bklkLCBzdGVwSWQsIHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9L3N0ZXBzLyR7c3RlcElkfWAsIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgcnVuIHN0ZXBzIGJlbG9uZ2luZyB0byBhIHJ1bi5cbiAgICovXG4gIGxpc3QoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIHF1ZXJ5PzogU3RlcExpc3RQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8UnVuU3RlcHNQYWdlLCBSdW5TdGVwPjtcbiAgbGlzdChcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8UnVuU3RlcHNQYWdlLCBSdW5TdGVwPjtcbiAgbGlzdChcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgcXVlcnk6IFN0ZXBMaXN0UGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFJ1blN0ZXBzUGFnZSwgUnVuU3RlcD4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdCh0aHJlYWRJZCwgcnVuSWQsIHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfS9zdGVwc2AsIFJ1blN0ZXBzUGFnZSwge1xuICAgICAgcXVlcnksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUnVuU3RlcHNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxSdW5TdGVwPiB7fVxuXG4vKipcbiAqIFRleHQgb3V0cHV0IGZyb20gdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsIGFzIHBhcnQgb2YgYSBydW4gc3RlcC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXJMb2dzIHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGluIHRoZSBvdXRwdXRzIGFycmF5LlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogQWx3YXlzIGBsb2dzYC5cbiAgICovXG4gIHR5cGU6ICdsb2dzJztcblxuICAvKipcbiAgICogVGhlIHRleHQgb3V0cHV0IGZyb20gdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsLlxuICAgKi9cbiAgbG9ncz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXJPdXRwdXRJbWFnZSB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpbiB0aGUgb3V0cHV0cyBhcnJheS5cbiAgICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgaW1hZ2VgLlxuICAgKi9cbiAgdHlwZTogJ2ltYWdlJztcblxuICBpbWFnZT86IENvZGVJbnRlcnByZXRlck91dHB1dEltYWdlLkltYWdlO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENvZGVJbnRlcnByZXRlck91dHB1dEltYWdlIHtcbiAgZXhwb3J0IGludGVyZmFjZSBJbWFnZSB7XG4gICAgLyoqXG4gICAgICogVGhlIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRCBvZiB0aGVcbiAgICAgKiBpbWFnZS5cbiAgICAgKi9cbiAgICBmaWxlX2lkPzogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogRGV0YWlscyBvZiB0aGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwgdGhlIHJ1biBzdGVwIHdhcyBpbnZvbHZlZCBpbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbCB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbC5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbCBkZWZpbml0aW9uLlxuICAgKi9cbiAgY29kZV9pbnRlcnByZXRlcjogQ29kZUludGVycHJldGVyVG9vbENhbGwuQ29kZUludGVycHJldGVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0b29sIGNhbGwuIFRoaXMgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIGBjb2RlX2ludGVycHJldGVyYCBmb3IgdGhpc1xuICAgKiB0eXBlIG9mIHRvb2wgY2FsbC5cbiAgICovXG4gIHR5cGU6ICdjb2RlX2ludGVycHJldGVyJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbCB7XG4gIC8qKlxuICAgKiBUaGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwgZGVmaW5pdGlvbi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5wdXQgdG8gdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsLlxuICAgICAqL1xuICAgIGlucHV0OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0cyBmcm9tIHRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbC4gQ29kZSBJbnRlcnByZXRlciBjYW4gb3V0cHV0IG9uZVxuICAgICAqIG9yIG1vcmUgaXRlbXMsIGluY2x1ZGluZyB0ZXh0IChgbG9nc2ApIG9yIGltYWdlcyAoYGltYWdlYCkuIEVhY2ggb2YgdGhlc2UgYXJlXG4gICAgICogcmVwcmVzZW50ZWQgYnkgYSBkaWZmZXJlbnQgb2JqZWN0IHR5cGUuXG4gICAgICovXG4gICAgb3V0cHV0czogQXJyYXk8Q29kZUludGVycHJldGVyLkxvZ3MgfCBDb2RlSW50ZXJwcmV0ZXIuSW1hZ2U+O1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgIC8qKlxuICAgICAqIFRleHQgb3V0cHV0IGZyb20gdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsIGFzIHBhcnQgb2YgYSBydW4gc3RlcC5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIExvZ3Mge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdGV4dCBvdXRwdXQgZnJvbSB0aGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwuXG4gICAgICAgKi9cbiAgICAgIGxvZ3M6IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBBbHdheXMgYGxvZ3NgLlxuICAgICAgICovXG4gICAgICB0eXBlOiAnbG9ncyc7XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBJbWFnZSB7XG4gICAgICBpbWFnZTogSW1hZ2UuSW1hZ2U7XG5cbiAgICAgIC8qKlxuICAgICAgICogQWx3YXlzIGBpbWFnZWAuXG4gICAgICAgKi9cbiAgICAgIHR5cGU6ICdpbWFnZSc7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBJbWFnZSB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEltYWdlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSUQgb2YgdGhlXG4gICAgICAgICAqIGltYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZV9pZDogc3RyaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERldGFpbHMgb2YgdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsIHRoZSBydW4gc3RlcCB3YXMgaW52b2x2ZWQgaW4uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyVG9vbENhbGxEZWx0YSB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIHRvb2wgY2FsbCBpbiB0aGUgdG9vbCBjYWxscyBhcnJheS5cbiAgICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRvb2wgY2FsbC4gVGhpcyBpcyBhbHdheXMgZ29pbmcgdG8gYmUgYGNvZGVfaW50ZXJwcmV0ZXJgIGZvciB0aGlzXG4gICAqIHR5cGUgb2YgdG9vbCBjYWxsLlxuICAgKi9cbiAgdHlwZTogJ2NvZGVfaW50ZXJwcmV0ZXInO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbC5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwgZGVmaW5pdGlvbi5cbiAgICovXG4gIGNvZGVfaW50ZXJwcmV0ZXI/OiBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbERlbHRhLkNvZGVJbnRlcnByZXRlcjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbERlbHRhIHtcbiAgLyoqXG4gICAqIFRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbCBkZWZpbml0aW9uLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnB1dCB0byB0aGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwuXG4gICAgICovXG4gICAgaW5wdXQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0cyBmcm9tIHRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbC4gQ29kZSBJbnRlcnByZXRlciBjYW4gb3V0cHV0IG9uZVxuICAgICAqIG9yIG1vcmUgaXRlbXMsIGluY2x1ZGluZyB0ZXh0IChgbG9nc2ApIG9yIGltYWdlcyAoYGltYWdlYCkuIEVhY2ggb2YgdGhlc2UgYXJlXG4gICAgICogcmVwcmVzZW50ZWQgYnkgYSBkaWZmZXJlbnQgb2JqZWN0IHR5cGUuXG4gICAgICovXG4gICAgb3V0cHV0cz86IEFycmF5PFN0ZXBzQVBJLkNvZGVJbnRlcnByZXRlckxvZ3MgfCBTdGVwc0FQSS5Db2RlSW50ZXJwcmV0ZXJPdXRwdXRJbWFnZT47XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoVG9vbENhbGwge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwgb2JqZWN0LlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogRm9yIG5vdywgdGhpcyBpcyBhbHdheXMgZ29pbmcgdG8gYmUgYW4gZW1wdHkgb2JqZWN0LlxuICAgKi9cbiAgZmlsZV9zZWFyY2g6IEZpbGVTZWFyY2hUb29sQ2FsbC5GaWxlU2VhcmNoO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0b29sIGNhbGwuIFRoaXMgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIGBmaWxlX3NlYXJjaGAgZm9yIHRoaXMgdHlwZSBvZlxuICAgKiB0b29sIGNhbGwuXG4gICAqL1xuICB0eXBlOiAnZmlsZV9zZWFyY2gnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZpbGVTZWFyY2hUb29sQ2FsbCB7XG4gIC8qKlxuICAgKiBGb3Igbm93LCB0aGlzIGlzIGFsd2F5cyBnb2luZyB0byBiZSBhbiBlbXB0eSBvYmplY3QuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgIC8qKlxuICAgICAqIFRoZSByYW5raW5nIG9wdGlvbnMgZm9yIHRoZSBmaWxlIHNlYXJjaC5cbiAgICAgKi9cbiAgICByYW5raW5nX29wdGlvbnM/OiBGaWxlU2VhcmNoLlJhbmtpbmdPcHRpb25zO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdHMgb2YgdGhlIGZpbGUgc2VhcmNoLlxuICAgICAqL1xuICAgIHJlc3VsdHM/OiBBcnJheTxGaWxlU2VhcmNoLlJlc3VsdD47XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIEZpbGVTZWFyY2gge1xuICAgIC8qKlxuICAgICAqIFRoZSByYW5raW5nIG9wdGlvbnMgZm9yIHRoZSBmaWxlIHNlYXJjaC5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIFJhbmtpbmdPcHRpb25zIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHJhbmtlciB1c2VkIGZvciB0aGUgZmlsZSBzZWFyY2guXG4gICAgICAgKi9cbiAgICAgIHJhbmtlcjogJ2RlZmF1bHRfMjAyNF8wOF8yMSc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHNjb3JlIHRocmVzaG9sZCBmb3IgdGhlIGZpbGUgc2VhcmNoLiBBbGwgdmFsdWVzIG11c3QgYmUgYSBmbG9hdGluZyBwb2ludFxuICAgICAgICogbnVtYmVyIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgICAqL1xuICAgICAgc2NvcmVfdGhyZXNob2xkOiBudW1iZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSByZXN1bHQgaW5zdGFuY2Ugb2YgdGhlIGZpbGUgc2VhcmNoLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgUmVzdWx0IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIElEIG9mIHRoZSBmaWxlIHRoYXQgcmVzdWx0IHdhcyBmb3VuZCBpbi5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZDogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRoYXQgcmVzdWx0IHdhcyBmb3VuZCBpbi5cbiAgICAgICAqL1xuICAgICAgZmlsZV9uYW1lOiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHNjb3JlIG9mIHRoZSByZXN1bHQuIEFsbCB2YWx1ZXMgbXVzdCBiZSBhIGZsb2F0aW5nIHBvaW50IG51bWJlciBiZXR3ZWVuIDBcbiAgICAgICAqIGFuZCAxLlxuICAgICAgICovXG4gICAgICBzY29yZTogbnVtYmVyO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjb250ZW50IG9mIHRoZSByZXN1bHQgdGhhdCB3YXMgZm91bmQuIFRoZSBjb250ZW50IGlzIG9ubHkgaW5jbHVkZWQgaWZcbiAgICAgICAqIHJlcXVlc3RlZCB2aWEgdGhlIGluY2x1ZGUgcXVlcnkgcGFyYW1ldGVyLlxuICAgICAgICovXG4gICAgICBjb250ZW50PzogQXJyYXk8UmVzdWx0LkNvbnRlbnQ+O1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgUmVzdWx0IHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29udGVudCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBjb250ZW50IG9mIHRoZSBmaWxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dD86IHN0cmluZztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIGNvbnRlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlPzogJ3RleHQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2hUb29sQ2FsbERlbHRhIHtcbiAgLyoqXG4gICAqIEZvciBub3csIHRoaXMgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIGFuIGVtcHR5IG9iamVjdC5cbiAgICovXG4gIGZpbGVfc2VhcmNoOiB1bmtub3duO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIHRvb2wgY2FsbCBpbiB0aGUgdG9vbCBjYWxscyBhcnJheS5cbiAgICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRvb2wgY2FsbC4gVGhpcyBpcyBhbHdheXMgZ29pbmcgdG8gYmUgYGZpbGVfc2VhcmNoYCBmb3IgdGhpcyB0eXBlIG9mXG4gICAqIHRvb2wgY2FsbC5cbiAgICovXG4gIHR5cGU6ICdmaWxlX3NlYXJjaCc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsIG9iamVjdC5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uVG9vbENhbGwge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwgb2JqZWN0LlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGRlZmluaXRpb24gb2YgdGhlIGZ1bmN0aW9uIHRoYXQgd2FzIGNhbGxlZC5cbiAgICovXG4gIGZ1bmN0aW9uOiBGdW5jdGlvblRvb2xDYWxsLkZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0b29sIGNhbGwuIFRoaXMgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIGBmdW5jdGlvbmAgZm9yIHRoaXMgdHlwZSBvZlxuICAgKiB0b29sIGNhbGwuXG4gICAqL1xuICB0eXBlOiAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZ1bmN0aW9uVG9vbENhbGwge1xuICAvKipcbiAgICogVGhlIGRlZmluaXRpb24gb2YgdGhlIGZ1bmN0aW9uIHRoYXQgd2FzIGNhbGxlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBhcmd1bWVudHM6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0IG9mIHRoZSBmdW5jdGlvbi4gVGhpcyB3aWxsIGJlIGBudWxsYCBpZiB0aGUgb3V0cHV0cyBoYXZlIG5vdCBiZWVuXG4gICAgICogW3N1Ym1pdHRlZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL3N1Ym1pdFRvb2xPdXRwdXRzKVxuICAgICAqIHlldC5cbiAgICAgKi9cbiAgICBvdXRwdXQ6IHN0cmluZyB8IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvblRvb2xDYWxsRGVsdGEge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSB0b29sIGNhbGwgaW4gdGhlIHRvb2wgY2FsbHMgYXJyYXkuXG4gICAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0b29sIGNhbGwuIFRoaXMgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIGBmdW5jdGlvbmAgZm9yIHRoaXMgdHlwZSBvZlxuICAgKiB0b29sIGNhbGwuXG4gICAqL1xuICB0eXBlOiAnZnVuY3Rpb24nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbCBvYmplY3QuXG4gICAqL1xuICBpZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGRlZmluaXRpb24gb2YgdGhlIGZ1bmN0aW9uIHRoYXQgd2FzIGNhbGxlZC5cbiAgICovXG4gIGZ1bmN0aW9uPzogRnVuY3Rpb25Ub29sQ2FsbERlbHRhLkZ1bmN0aW9uO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZ1bmN0aW9uVG9vbENhbGxEZWx0YSB7XG4gIC8qKlxuICAgKiBUaGUgZGVmaW5pdGlvbiBvZiB0aGUgZnVuY3Rpb24gdGhhdCB3YXMgY2FsbGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGFyZ3VtZW50cz86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBuYW1lPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dCBvZiB0aGUgZnVuY3Rpb24uIFRoaXMgd2lsbCBiZSBgbnVsbGAgaWYgdGhlIG91dHB1dHMgaGF2ZSBub3QgYmVlblxuICAgICAqIFtzdWJtaXR0ZWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9zdWJtaXRUb29sT3V0cHV0cylcbiAgICAgKiB5ZXQuXG4gICAgICovXG4gICAgb3V0cHV0Pzogc3RyaW5nIHwgbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIERldGFpbHMgb2YgdGhlIG1lc3NhZ2UgY3JlYXRpb24gYnkgdGhlIHJ1biBzdGVwLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VDcmVhdGlvblN0ZXBEZXRhaWxzIHtcbiAgbWVzc2FnZV9jcmVhdGlvbjogTWVzc2FnZUNyZWF0aW9uU3RlcERldGFpbHMuTWVzc2FnZUNyZWF0aW9uO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYG1lc3NhZ2VfY3JlYXRpb25gLlxuICAgKi9cbiAgdHlwZTogJ21lc3NhZ2VfY3JlYXRpb24nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIE1lc3NhZ2VDcmVhdGlvblN0ZXBEZXRhaWxzIHtcbiAgZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlQ3JlYXRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgbWVzc2FnZSB0aGF0IHdhcyBjcmVhdGVkIGJ5IHRoaXMgcnVuIHN0ZXAuXG4gICAgICovXG4gICAgbWVzc2FnZV9pZDogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJ1blN0ZXAge1xuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIgb2YgdGhlIHJ1biBzdGVwLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgcnVuIHN0ZXAuXG4gICAqL1xuICBhc3Npc3RhbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHN0ZXAgd2FzIGNhbmNlbGxlZC5cbiAgICovXG4gIGNhbmNlbGxlZF9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHN0ZXAgY29tcGxldGVkLlxuICAgKi9cbiAgY29tcGxldGVkX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBydW4gc3RlcCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHN0ZXAgZXhwaXJlZC4gQSBzdGVwIGlzXG4gICAqIGNvbnNpZGVyZWQgZXhwaXJlZCBpZiB0aGUgcGFyZW50IHJ1biBpcyBleHBpcmVkLlxuICAgKi9cbiAgZXhwaXJlZF9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHN0ZXAgZmFpbGVkLlxuICAgKi9cbiAgZmFpbGVkX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbGFzdCBlcnJvciBhc3NvY2lhdGVkIHdpdGggdGhpcyBydW4gc3RlcC4gV2lsbCBiZSBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4gICAqIGVycm9ycy5cbiAgICovXG4gIGxhc3RfZXJyb3I6IFJ1blN0ZXAuTGFzdEVycm9yIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE6IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgdGhyZWFkLnJ1bi5zdGVwYC5cbiAgICovXG4gIG9iamVjdDogJ3RocmVhZC5ydW4uc3RlcCc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zKSB0aGF0XG4gICAqIHRoaXMgcnVuIHN0ZXAgaXMgYSBwYXJ0IG9mLlxuICAgKi9cbiAgcnVuX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBzdGF0dXMgb2YgdGhlIHJ1biBzdGVwLCB3aGljaCBjYW4gYmUgZWl0aGVyIGBpbl9wcm9ncmVzc2AsIGBjYW5jZWxsZWRgLFxuICAgKiBgZmFpbGVkYCwgYGNvbXBsZXRlZGAsIG9yIGBleHBpcmVkYC5cbiAgICovXG4gIHN0YXR1czogJ2luX3Byb2dyZXNzJyB8ICdjYW5jZWxsZWQnIHwgJ2ZhaWxlZCcgfCAnY29tcGxldGVkJyB8ICdleHBpcmVkJztcblxuICAvKipcbiAgICogVGhlIGRldGFpbHMgb2YgdGhlIHJ1biBzdGVwLlxuICAgKi9cbiAgc3RlcF9kZXRhaWxzOiBNZXNzYWdlQ3JlYXRpb25TdGVwRGV0YWlscyB8IFRvb2xDYWxsc1N0ZXBEZXRhaWxzO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcylcbiAgICogdGhhdCB3YXMgcnVuLlxuICAgKi9cbiAgdGhyZWFkX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHJ1biBzdGVwLCB3aGljaCBjYW4gYmUgZWl0aGVyIGBtZXNzYWdlX2NyZWF0aW9uYCBvciBgdG9vbF9jYWxsc2AuXG4gICAqL1xuICB0eXBlOiAnbWVzc2FnZV9jcmVhdGlvbicgfCAndG9vbF9jYWxscyc7XG5cbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgcmVsYXRlZCB0byB0aGUgcnVuIHN0ZXAuIFRoaXMgdmFsdWUgd2lsbCBiZSBgbnVsbGAgd2hpbGUgdGhlXG4gICAqIHJ1biBzdGVwJ3Mgc3RhdHVzIGlzIGBpbl9wcm9ncmVzc2AuXG4gICAqL1xuICB1c2FnZTogUnVuU3RlcC5Vc2FnZSB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuU3RlcCB7XG4gIC8qKlxuICAgKiBUaGUgbGFzdCBlcnJvciBhc3NvY2lhdGVkIHdpdGggdGhpcyBydW4gc3RlcC4gV2lsbCBiZSBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4gICAqIGVycm9ycy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgTGFzdEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBPbmUgb2YgYHNlcnZlcl9lcnJvcmAgb3IgYHJhdGVfbGltaXRfZXhjZWVkZWRgLlxuICAgICAqL1xuICAgIGNvZGU6ICdzZXJ2ZXJfZXJyb3InIHwgJ3JhdGVfbGltaXRfZXhjZWVkZWQnO1xuXG4gICAgLyoqXG4gICAgICogQSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3IuXG4gICAgICovXG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgcmVsYXRlZCB0byB0aGUgcnVuIHN0ZXAuIFRoaXMgdmFsdWUgd2lsbCBiZSBgbnVsbGAgd2hpbGUgdGhlXG4gICAqIHJ1biBzdGVwJ3Mgc3RhdHVzIGlzIGBpbl9wcm9ncmVzc2AuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFVzYWdlIHtcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1biBzdGVwLlxuICAgICAqL1xuICAgIGNvbXBsZXRpb25fdG9rZW5zOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgcHJvbXB0IHRva2VucyB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgcnVuIHN0ZXAuXG4gICAgICovXG4gICAgcHJvbXB0X3Rva2VuczogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVG90YWwgbnVtYmVyIG9mIHRva2VucyB1c2VkIChwcm9tcHQgKyBjb21wbGV0aW9uKS5cbiAgICAgKi9cbiAgICB0b3RhbF90b2tlbnM6IG51bWJlcjtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBkZWx0YSBjb250YWluaW5nIHRoZSBmaWVsZHMgdGhhdCBoYXZlIGNoYW5nZWQgb24gdGhlIHJ1biBzdGVwLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJ1blN0ZXBEZWx0YSB7XG4gIC8qKlxuICAgKiBUaGUgZGV0YWlscyBvZiB0aGUgcnVuIHN0ZXAuXG4gICAqL1xuICBzdGVwX2RldGFpbHM/OiBSdW5TdGVwRGVsdGFNZXNzYWdlRGVsdGEgfCBUb29sQ2FsbERlbHRhT2JqZWN0O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBydW4gc3RlcCBkZWx0YSBpLmUuIGFueSBjaGFuZ2VkIGZpZWxkcyBvbiBhIHJ1biBzdGVwIGR1cmluZ1xuICogc3RyZWFtaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJ1blN0ZXBEZWx0YUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBydW4gc3RlcCwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWx0YSBjb250YWluaW5nIHRoZSBmaWVsZHMgdGhhdCBoYXZlIGNoYW5nZWQgb24gdGhlIHJ1biBzdGVwLlxuICAgKi9cbiAgZGVsdGE6IFJ1blN0ZXBEZWx0YTtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYHRocmVhZC5ydW4uc3RlcC5kZWx0YWAuXG4gICAqL1xuICBvYmplY3Q6ICd0aHJlYWQucnVuLnN0ZXAuZGVsdGEnO1xufVxuXG4vKipcbiAqIERldGFpbHMgb2YgdGhlIG1lc3NhZ2UgY3JlYXRpb24gYnkgdGhlIHJ1biBzdGVwLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJ1blN0ZXBEZWx0YU1lc3NhZ2VEZWx0YSB7XG4gIC8qKlxuICAgKiBBbHdheXMgYG1lc3NhZ2VfY3JlYXRpb25gLlxuICAgKi9cbiAgdHlwZTogJ21lc3NhZ2VfY3JlYXRpb24nO1xuXG4gIG1lc3NhZ2VfY3JlYXRpb24/OiBSdW5TdGVwRGVsdGFNZXNzYWdlRGVsdGEuTWVzc2FnZUNyZWF0aW9uO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJ1blN0ZXBEZWx0YU1lc3NhZ2VEZWx0YSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZUNyZWF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIG1lc3NhZ2UgdGhhdCB3YXMgY3JlYXRlZCBieSB0aGlzIHJ1biBzdGVwLlxuICAgICAqL1xuICAgIG1lc3NhZ2VfaWQ/OiBzdHJpbmc7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgUnVuU3RlcEluY2x1ZGUgPSAnc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHNbKl0uZmlsZV9zZWFyY2gucmVzdWx0c1sqXS5jb250ZW50JztcblxuLyoqXG4gKiBEZXRhaWxzIG9mIHRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbCB0aGUgcnVuIHN0ZXAgd2FzIGludm9sdmVkIGluLlxuICovXG5leHBvcnQgdHlwZSBUb29sQ2FsbCA9IENvZGVJbnRlcnByZXRlclRvb2xDYWxsIHwgRmlsZVNlYXJjaFRvb2xDYWxsIHwgRnVuY3Rpb25Ub29sQ2FsbDtcblxuLyoqXG4gKiBEZXRhaWxzIG9mIHRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbCB0aGUgcnVuIHN0ZXAgd2FzIGludm9sdmVkIGluLlxuICovXG5leHBvcnQgdHlwZSBUb29sQ2FsbERlbHRhID0gQ29kZUludGVycHJldGVyVG9vbENhbGxEZWx0YSB8IEZpbGVTZWFyY2hUb29sQ2FsbERlbHRhIHwgRnVuY3Rpb25Ub29sQ2FsbERlbHRhO1xuXG4vKipcbiAqIERldGFpbHMgb2YgdGhlIHRvb2wgY2FsbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUb29sQ2FsbERlbHRhT2JqZWN0IHtcbiAgLyoqXG4gICAqIEFsd2F5cyBgdG9vbF9jYWxsc2AuXG4gICAqL1xuICB0eXBlOiAndG9vbF9jYWxscyc7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIHRvb2wgY2FsbHMgdGhlIHJ1biBzdGVwIHdhcyBpbnZvbHZlZCBpbi4gVGhlc2UgY2FuIGJlIGFzc29jaWF0ZWRcbiAgICogd2l0aCBvbmUgb2YgdGhyZWUgdHlwZXMgb2YgdG9vbHM6IGBjb2RlX2ludGVycHJldGVyYCwgYGZpbGVfc2VhcmNoYCwgb3JcbiAgICogYGZ1bmN0aW9uYC5cbiAgICovXG4gIHRvb2xfY2FsbHM/OiBBcnJheTxUb29sQ2FsbERlbHRhPjtcbn1cblxuLyoqXG4gKiBEZXRhaWxzIG9mIHRoZSB0b29sIGNhbGwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbENhbGxzU3RlcERldGFpbHMge1xuICAvKipcbiAgICogQW4gYXJyYXkgb2YgdG9vbCBjYWxscyB0aGUgcnVuIHN0ZXAgd2FzIGludm9sdmVkIGluLiBUaGVzZSBjYW4gYmUgYXNzb2NpYXRlZFxuICAgKiB3aXRoIG9uZSBvZiB0aHJlZSB0eXBlcyBvZiB0b29sczogYGNvZGVfaW50ZXJwcmV0ZXJgLCBgZmlsZV9zZWFyY2hgLCBvclxuICAgKiBgZnVuY3Rpb25gLlxuICAgKi9cbiAgdG9vbF9jYWxsczogQXJyYXk8VG9vbENhbGw+O1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYHRvb2xfY2FsbHNgLlxuICAgKi9cbiAgdHlwZTogJ3Rvb2xfY2FsbHMnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0ZXBSZXRyaWV2ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgYWRkaXRpb25hbCBmaWVsZHMgdG8gaW5jbHVkZSBpbiB0aGUgcmVzcG9uc2UuIEN1cnJlbnRseSB0aGUgb25seVxuICAgKiBzdXBwb3J0ZWQgdmFsdWUgaXMgYHN0ZXBfZGV0YWlscy50b29sX2NhbGxzWypdLmZpbGVfc2VhcmNoLnJlc3VsdHNbKl0uY29udGVudGBcbiAgICogdG8gZmV0Y2ggdGhlIGZpbGUgc2VhcmNoIHJlc3VsdCBjb250ZW50LlxuICAgKlxuICAgKiBTZWUgdGhlXG4gICAqIFtmaWxlIHNlYXJjaCB0b29sIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvdG9vbHMvZmlsZS1zZWFyY2gjY3VzdG9taXppbmctZmlsZS1zZWFyY2gtc2V0dGluZ3MpXG4gICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgaW5jbHVkZT86IEFycmF5PFJ1blN0ZXBJbmNsdWRlPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGVwTGlzdFBhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge1xuICAvKipcbiAgICogQSBjdXJzb3IgZm9yIHVzZSBpbiBwYWdpbmF0aW9uLiBgYmVmb3JlYCBpcyBhbiBvYmplY3QgSUQgdGhhdCBkZWZpbmVzIHlvdXIgcGxhY2VcbiAgICogaW4gdGhlIGxpc3QuIEZvciBpbnN0YW5jZSwgaWYgeW91IG1ha2UgYSBsaXN0IHJlcXVlc3QgYW5kIHJlY2VpdmUgMTAwIG9iamVjdHMsXG4gICAqIHN0YXJ0aW5nIHdpdGggb2JqX2ZvbywgeW91ciBzdWJzZXF1ZW50IGNhbGwgY2FuIGluY2x1ZGUgYmVmb3JlPW9ial9mb28gaW4gb3JkZXJcbiAgICogdG8gZmV0Y2ggdGhlIHByZXZpb3VzIHBhZ2Ugb2YgdGhlIGxpc3QuXG4gICAqL1xuICBiZWZvcmU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBhZGRpdGlvbmFsIGZpZWxkcyB0byBpbmNsdWRlIGluIHRoZSByZXNwb25zZS4gQ3VycmVudGx5IHRoZSBvbmx5XG4gICAqIHN1cHBvcnRlZCB2YWx1ZSBpcyBgc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHNbKl0uZmlsZV9zZWFyY2gucmVzdWx0c1sqXS5jb250ZW50YFxuICAgKiB0byBmZXRjaCB0aGUgZmlsZSBzZWFyY2ggcmVzdWx0IGNvbnRlbnQuXG4gICAqXG4gICAqIFNlZSB0aGVcbiAgICogW2ZpbGUgc2VhcmNoIHRvb2wgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy90b29scy9maWxlLXNlYXJjaCNjdXN0b21pemluZy1maWxlLXNlYXJjaC1zZXR0aW5ncylcbiAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbmNsdWRlPzogQXJyYXk8UnVuU3RlcEluY2x1ZGU+O1xuXG4gIC8qKlxuICAgKiBTb3J0IG9yZGVyIGJ5IHRoZSBgY3JlYXRlZF9hdGAgdGltZXN0YW1wIG9mIHRoZSBvYmplY3RzLiBgYXNjYCBmb3IgYXNjZW5kaW5nXG4gICAqIG9yZGVyIGFuZCBgZGVzY2AgZm9yIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAqL1xuICBvcmRlcj86ICdhc2MnIHwgJ2Rlc2MnO1xufVxuXG5TdGVwcy5SdW5TdGVwc1BhZ2UgPSBSdW5TdGVwc1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBTdGVwcyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBDb2RlSW50ZXJwcmV0ZXJMb2dzIGFzIENvZGVJbnRlcnByZXRlckxvZ3MsXG4gICAgdHlwZSBDb2RlSW50ZXJwcmV0ZXJPdXRwdXRJbWFnZSBhcyBDb2RlSW50ZXJwcmV0ZXJPdXRwdXRJbWFnZSxcbiAgICB0eXBlIENvZGVJbnRlcnByZXRlclRvb2xDYWxsIGFzIENvZGVJbnRlcnByZXRlclRvb2xDYWxsLFxuICAgIHR5cGUgQ29kZUludGVycHJldGVyVG9vbENhbGxEZWx0YSBhcyBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbERlbHRhLFxuICAgIHR5cGUgRmlsZVNlYXJjaFRvb2xDYWxsIGFzIEZpbGVTZWFyY2hUb29sQ2FsbCxcbiAgICB0eXBlIEZpbGVTZWFyY2hUb29sQ2FsbERlbHRhIGFzIEZpbGVTZWFyY2hUb29sQ2FsbERlbHRhLFxuICAgIHR5cGUgRnVuY3Rpb25Ub29sQ2FsbCBhcyBGdW5jdGlvblRvb2xDYWxsLFxuICAgIHR5cGUgRnVuY3Rpb25Ub29sQ2FsbERlbHRhIGFzIEZ1bmN0aW9uVG9vbENhbGxEZWx0YSxcbiAgICB0eXBlIE1lc3NhZ2VDcmVhdGlvblN0ZXBEZXRhaWxzIGFzIE1lc3NhZ2VDcmVhdGlvblN0ZXBEZXRhaWxzLFxuICAgIHR5cGUgUnVuU3RlcCBhcyBSdW5TdGVwLFxuICAgIHR5cGUgUnVuU3RlcERlbHRhIGFzIFJ1blN0ZXBEZWx0YSxcbiAgICB0eXBlIFJ1blN0ZXBEZWx0YUV2ZW50IGFzIFJ1blN0ZXBEZWx0YUV2ZW50LFxuICAgIHR5cGUgUnVuU3RlcERlbHRhTWVzc2FnZURlbHRhIGFzIFJ1blN0ZXBEZWx0YU1lc3NhZ2VEZWx0YSxcbiAgICB0eXBlIFJ1blN0ZXBJbmNsdWRlIGFzIFJ1blN0ZXBJbmNsdWRlLFxuICAgIHR5cGUgVG9vbENhbGwgYXMgVG9vbENhbGwsXG4gICAgdHlwZSBUb29sQ2FsbERlbHRhIGFzIFRvb2xDYWxsRGVsdGEsXG4gICAgdHlwZSBUb29sQ2FsbERlbHRhT2JqZWN0IGFzIFRvb2xDYWxsRGVsdGFPYmplY3QsXG4gICAgdHlwZSBUb29sQ2FsbHNTdGVwRGV0YWlscyBhcyBUb29sQ2FsbHNTdGVwRGV0YWlscyxcbiAgICBSdW5TdGVwc1BhZ2UgYXMgUnVuU3RlcHNQYWdlLFxuICAgIHR5cGUgU3RlcFJldHJpZXZlUGFyYW1zIGFzIFN0ZXBSZXRyaWV2ZVBhcmFtcyxcbiAgICB0eXBlIFN0ZXBMaXN0UGFyYW1zIGFzIFN0ZXBMaXN0UGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0IHsgQVBJUHJvbWlzZSB9IGZyb20gJy4uLy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi8uLi8uLi9jb3JlJztcbmltcG9ydCB7IEFzc2lzdGFudFN0cmVhbSwgUnVuQ3JlYXRlUGFyYW1zQmFzZVN0cmVhbSB9IGZyb20gJy4uLy4uLy4uLy4uL2xpYi9Bc3Npc3RhbnRTdHJlYW0nO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tICcuLi8uLi8uLi8uLi9jb3JlJztcbmltcG9ydCB7IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGliL0Fzc2lzdGFudFN0cmVhbSc7XG5pbXBvcnQgKiBhcyBSdW5zQVBJIGZyb20gJy4vcnVucyc7XG5pbXBvcnQgKiBhcyBBc3Npc3RhbnRzQVBJIGZyb20gJy4uLy4uL2Fzc2lzdGFudHMnO1xuaW1wb3J0ICogYXMgQ2hhdEFQSSBmcm9tICcuLi8uLi8uLi9jaGF0L2NoYXQnO1xuaW1wb3J0ICogYXMgTWVzc2FnZXNBUEkgZnJvbSAnLi4vbWVzc2FnZXMnO1xuaW1wb3J0ICogYXMgVGhyZWFkc0FQSSBmcm9tICcuLi90aHJlYWRzJztcbmltcG9ydCAqIGFzIFN0ZXBzQVBJIGZyb20gJy4vc3RlcHMnO1xuaW1wb3J0IHtcbiAgQ29kZUludGVycHJldGVyTG9ncyxcbiAgQ29kZUludGVycHJldGVyT3V0cHV0SW1hZ2UsXG4gIENvZGVJbnRlcnByZXRlclRvb2xDYWxsLFxuICBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbERlbHRhLFxuICBGaWxlU2VhcmNoVG9vbENhbGwsXG4gIEZpbGVTZWFyY2hUb29sQ2FsbERlbHRhLFxuICBGdW5jdGlvblRvb2xDYWxsLFxuICBGdW5jdGlvblRvb2xDYWxsRGVsdGEsXG4gIE1lc3NhZ2VDcmVhdGlvblN0ZXBEZXRhaWxzLFxuICBSdW5TdGVwLFxuICBSdW5TdGVwRGVsdGEsXG4gIFJ1blN0ZXBEZWx0YUV2ZW50LFxuICBSdW5TdGVwRGVsdGFNZXNzYWdlRGVsdGEsXG4gIFJ1blN0ZXBJbmNsdWRlLFxuICBSdW5TdGVwc1BhZ2UsXG4gIFN0ZXBMaXN0UGFyYW1zLFxuICBTdGVwUmV0cmlldmVQYXJhbXMsXG4gIFN0ZXBzLFxuICBUb29sQ2FsbCxcbiAgVG9vbENhbGxEZWx0YSxcbiAgVG9vbENhbGxEZWx0YU9iamVjdCxcbiAgVG9vbENhbGxzU3RlcERldGFpbHMsXG59IGZyb20gJy4vc3RlcHMnO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSwgdHlwZSBDdXJzb3JQYWdlUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vLi4vcGFnaW5hdGlvbic7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tICcuLi8uLi8uLi8uLi9zdHJlYW1pbmcnO1xuXG5leHBvcnQgY2xhc3MgUnVucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgc3RlcHM6IFN0ZXBzQVBJLlN0ZXBzID0gbmV3IFN0ZXBzQVBJLlN0ZXBzKHRoaXMuX2NsaWVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJ1bi5cbiAgICovXG4gIGNyZWF0ZShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHBhcmFtczogUnVuQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFJ1bj47XG4gIGNyZWF0ZShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHBhcmFtczogUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50Pj47XG4gIGNyZWF0ZShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHBhcmFtczogUnVuQ3JlYXRlUGFyYW1zQmFzZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4gfCBSdW4+O1xuICBjcmVhdGUoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBwYXJhbXM6IFJ1bkNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxSdW4+IHwgQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4+IHtcbiAgICBjb25zdCB7IGluY2x1ZGUsIC4uLmJvZHkgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnNgLCB7XG4gICAgICBxdWVyeTogeyBpbmNsdWRlIH0sXG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICBzdHJlYW06IHBhcmFtcy5zdHJlYW0gPz8gZmFsc2UsXG4gICAgfSkgYXMgQVBJUHJvbWlzZTxSdW4+IHwgQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4+O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIHJ1bi5cbiAgICovXG4gIHJldHJpZXZlKHRocmVhZElkOiBzdHJpbmcsIHJ1bklkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFJ1bj4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZpZXMgYSBydW4uXG4gICAqL1xuICB1cGRhdGUoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIGJvZHk6IFJ1blVwZGF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFJ1bj4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfWAsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBydW5zIGJlbG9uZ2luZyB0byBhIHRocmVhZC5cbiAgICovXG4gIGxpc3QoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBxdWVyeT86IFJ1bkxpc3RQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8UnVuc1BhZ2UsIFJ1bj47XG4gIGxpc3QodGhyZWFkSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPFJ1bnNQYWdlLCBSdW4+O1xuICBsaXN0KFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcXVlcnk6IFJ1bkxpc3RQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8UnVuc1BhZ2UsIFJ1bj4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdCh0aHJlYWRJZCwge30sIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zYCwgUnVuc1BhZ2UsIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyBhIHJ1biB0aGF0IGlzIGBpbl9wcm9ncmVzc2AuXG4gICAqL1xuICBjYW5jZWwodGhyZWFkSWQ6IHN0cmluZywgcnVuSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8UnVuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9L2NhbmNlbGAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIHRvIGNyZWF0ZSBhIHJ1biBhbiBwb2xsIGZvciBhIHRlcm1pbmFsIHN0YXRlLiBNb3JlIGluZm9ybWF0aW9uIG9uIFJ1blxuICAgKiBsaWZlY3ljbGVzIGNhbiBiZSBmb3VuZCBoZXJlOlxuICAgKiBodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL2hvdy1pdC13b3Jrcy9ydW5zLWFuZC1ydW4tc3RlcHNcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUFuZFBvbGwoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBib2R5OiBSdW5DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMgJiB7IHBvbGxJbnRlcnZhbE1zPzogbnVtYmVyIH0sXG4gICk6IFByb21pc2U8UnVuPiB7XG4gICAgY29uc3QgcnVuID0gYXdhaXQgdGhpcy5jcmVhdGUodGhyZWFkSWQsIGJvZHksIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnBvbGwodGhyZWFkSWQsIHJ1bi5pZCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgUnVuIHN0cmVhbVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYHN0cmVhbWAgaW5zdGVhZFxuICAgKi9cbiAgY3JlYXRlQW5kU3RyZWFtKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgYm9keTogUnVuQ3JlYXRlUGFyYW1zQmFzZVN0cmVhbSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQXNzaXN0YW50U3RyZWFtIHtcbiAgICByZXR1cm4gQXNzaXN0YW50U3RyZWFtLmNyZWF0ZUFzc2lzdGFudFN0cmVhbSh0aHJlYWRJZCwgdGhpcy5fY2xpZW50LmJldGEudGhyZWFkcy5ydW5zLCBib2R5LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGhlbHBlciB0byBwb2xsIGEgcnVuIHN0YXR1cyB1bnRpbCBpdCByZWFjaGVzIGEgdGVybWluYWwgc3RhdGUuIE1vcmVcbiAgICogaW5mb3JtYXRpb24gb24gUnVuIGxpZmVjeWNsZXMgY2FuIGJlIGZvdW5kIGhlcmU6XG4gICAqIGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvaG93LWl0LXdvcmtzL3J1bnMtYW5kLXJ1bi1zdGVwc1xuICAgKi9cbiAgYXN5bmMgcG9sbChcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMgJiB7IHBvbGxJbnRlcnZhbE1zPzogbnVtYmVyIH0sXG4gICk6IFByb21pc2U8UnVuPiB7XG4gICAgY29uc3QgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLVBvbGwtSGVscGVyJzogJ3RydWUnIH07XG5cbiAgICBpZiAob3B0aW9ucz8ucG9sbEludGVydmFsTXMpIHtcbiAgICAgIGhlYWRlcnNbJ1gtU3RhaW5sZXNzLUN1c3RvbS1Qb2xsLUludGVydmFsJ10gPSBvcHRpb25zLnBvbGxJbnRlcnZhbE1zLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZGF0YTogcnVuLCByZXNwb25zZSB9ID0gYXdhaXQgdGhpcy5yZXRyaWV2ZSh0aHJlYWRJZCwgcnVuSWQsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAuLi5oZWFkZXJzIH0sXG4gICAgICB9KS53aXRoUmVzcG9uc2UoKTtcblxuICAgICAgc3dpdGNoIChydW4uc3RhdHVzKSB7XG4gICAgICAgIC8vSWYgd2UgYXJlIGluIGFueSBzb3J0IG9mIGludGVybWVkaWF0ZSBzdGF0ZSB3ZSBwb2xsXG4gICAgICAgIGNhc2UgJ3F1ZXVlZCc6XG4gICAgICAgIGNhc2UgJ2luX3Byb2dyZXNzJzpcbiAgICAgICAgY2FzZSAnY2FuY2VsbGluZyc6XG4gICAgICAgICAgbGV0IHNsZWVwSW50ZXJ2YWwgPSA1MDAwO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnM/LnBvbGxJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICBzbGVlcEludGVydmFsID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVySW50ZXJ2YWwgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnb3BlbmFpLXBvbGwtYWZ0ZXItbXMnKTtcbiAgICAgICAgICAgIGlmIChoZWFkZXJJbnRlcnZhbCkge1xuICAgICAgICAgICAgICBjb25zdCBoZWFkZXJJbnRlcnZhbE1zID0gcGFyc2VJbnQoaGVhZGVySW50ZXJ2YWwpO1xuICAgICAgICAgICAgICBpZiAoIWlzTmFOKGhlYWRlckludGVydmFsTXMpKSB7XG4gICAgICAgICAgICAgICAgc2xlZXBJbnRlcnZhbCA9IGhlYWRlckludGVydmFsTXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgc2xlZXAoc2xlZXBJbnRlcnZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vV2UgcmV0dXJuIHRoZSBydW4gaW4gYW55IHRlcm1pbmFsIHN0YXRlLlxuICAgICAgICBjYXNlICdyZXF1aXJlc19hY3Rpb24nOlxuICAgICAgICBjYXNlICdpbmNvbXBsZXRlJzpcbiAgICAgICAgY2FzZSAnY2FuY2VsbGVkJzpcbiAgICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgY2FzZSAnZXhwaXJlZCc6XG4gICAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgUnVuIHN0cmVhbVxuICAgKi9cbiAgc3RyZWFtKHRocmVhZElkOiBzdHJpbmcsIGJvZHk6IFJ1bkNyZWF0ZVBhcmFtc0Jhc2VTdHJlYW0sIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQXNzaXN0YW50U3RyZWFtIHtcbiAgICByZXR1cm4gQXNzaXN0YW50U3RyZWFtLmNyZWF0ZUFzc2lzdGFudFN0cmVhbSh0aHJlYWRJZCwgdGhpcy5fY2xpZW50LmJldGEudGhyZWFkcy5ydW5zLCBib2R5LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGEgcnVuIGhhcyB0aGUgYHN0YXR1czogXCJyZXF1aXJlc19hY3Rpb25cImAgYW5kIGByZXF1aXJlZF9hY3Rpb24udHlwZWAgaXNcbiAgICogYHN1Ym1pdF90b29sX291dHB1dHNgLCB0aGlzIGVuZHBvaW50IGNhbiBiZSB1c2VkIHRvIHN1Ym1pdCB0aGUgb3V0cHV0cyBmcm9tIHRoZVxuICAgKiB0b29sIGNhbGxzIG9uY2UgdGhleSdyZSBhbGwgY29tcGxldGVkLiBBbGwgb3V0cHV0cyBtdXN0IGJlIHN1Ym1pdHRlZCBpbiBhIHNpbmdsZVxuICAgKiByZXF1ZXN0LlxuICAgKi9cbiAgc3VibWl0VG9vbE91dHB1dHMoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIGJvZHk6IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFJ1bj47XG4gIHN1Ym1pdFRvb2xPdXRwdXRzKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBib2R5OiBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbWluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4+O1xuICBzdWJtaXRUb29sT3V0cHV0cyhcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgYm9keTogUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNCYXNlLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50PiB8IFJ1bj47XG4gIHN1Ym1pdFRvb2xPdXRwdXRzKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBib2R5OiBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxSdW4+IHwgQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH0vc3VibWl0X3Rvb2xfb3V0cHV0c2AsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgIHN0cmVhbTogYm9keS5zdHJlYW0gPz8gZmFsc2UsXG4gICAgfSkgYXMgQVBJUHJvbWlzZTxSdW4+IHwgQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4+O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIHRvIHN1Ym1pdCBhIHRvb2wgb3V0cHV0IHRvIGEgcnVuIGFuZCBwb2xsIGZvciBhIHRlcm1pbmFsIHJ1biBzdGF0ZS5cbiAgICogTW9yZSBpbmZvcm1hdGlvbiBvbiBSdW4gbGlmZWN5Y2xlcyBjYW4gYmUgZm91bmQgaGVyZTpcbiAgICogaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy9ob3ctaXQtd29ya3MvcnVucy1hbmQtcnVuLXN0ZXBzXG4gICAqL1xuICBhc3luYyBzdWJtaXRUb29sT3V0cHV0c0FuZFBvbGwoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIGJvZHk6IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zICYgeyBwb2xsSW50ZXJ2YWxNcz86IG51bWJlciB9LFxuICApOiBQcm9taXNlPFJ1bj4ge1xuICAgIGNvbnN0IHJ1biA9IGF3YWl0IHRoaXMuc3VibWl0VG9vbE91dHB1dHModGhyZWFkSWQsIHJ1bklkLCBib2R5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5wb2xsKHRocmVhZElkLCBydW4uaWQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1Ym1pdCB0aGUgdG9vbCBvdXRwdXRzIGZyb20gYSBwcmV2aW91cyBydW4gYW5kIHN0cmVhbSB0aGUgcnVuIHRvIGEgdGVybWluYWxcbiAgICogc3RhdGUuIE1vcmUgaW5mb3JtYXRpb24gb24gUnVuIGxpZmVjeWNsZXMgY2FuIGJlIGZvdW5kIGhlcmU6XG4gICAqIGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvaG93LWl0LXdvcmtzL3J1bnMtYW5kLXJ1bi1zdGVwc1xuICAgKi9cbiAgc3VibWl0VG9vbE91dHB1dHNTdHJlYW0oXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIGJvZHk6IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBc3Npc3RhbnRTdHJlYW0ge1xuICAgIHJldHVybiBBc3Npc3RhbnRTdHJlYW0uY3JlYXRlVG9vbEFzc2lzdGFudFN0cmVhbShcbiAgICAgIHRocmVhZElkLFxuICAgICAgcnVuSWQsXG4gICAgICB0aGlzLl9jbGllbnQuYmV0YS50aHJlYWRzLnJ1bnMsXG4gICAgICBib2R5LFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSdW5zUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8UnVuPiB7fVxuXG4vKipcbiAqIFRvb2wgY2FsbCBvYmplY3RzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVxdWlyZWRBY3Rpb25GdW5jdGlvblRvb2xDYWxsIHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsLiBUaGlzIElEIG11c3QgYmUgcmVmZXJlbmNlZCB3aGVuIHlvdSBzdWJtaXQgdGhlIHRvb2xcbiAgICogb3V0cHV0cyBpbiB1c2luZyB0aGVcbiAgICogW1N1Ym1pdCB0b29sIG91dHB1dHMgdG8gcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvc3VibWl0VG9vbE91dHB1dHMpXG4gICAqIGVuZHBvaW50LlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIGRlZmluaXRpb24uXG4gICAqL1xuICBmdW5jdGlvbjogUmVxdWlyZWRBY3Rpb25GdW5jdGlvblRvb2xDYWxsLkZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0b29sIGNhbGwgdGhlIG91dHB1dCBpcyByZXF1aXJlZCBmb3IuIEZvciBub3csIHRoaXMgaXMgYWx3YXlzXG4gICAqIGBmdW5jdGlvbmAuXG4gICAqL1xuICB0eXBlOiAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJlcXVpcmVkQWN0aW9uRnVuY3Rpb25Ub29sQ2FsbCB7XG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gZGVmaW5pdGlvbi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBhcmd1bWVudHMgdGhhdCB0aGUgbW9kZWwgZXhwZWN0cyB5b3UgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXJndW1lbnRzOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUnVuIHtcbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIHVzZWQgZm9yXG4gICAqIGV4ZWN1dGlvbiBvZiB0aGlzIHJ1bi5cbiAgICovXG4gIGFzc2lzdGFudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBydW4gd2FzIGNhbmNlbGxlZC5cbiAgICovXG4gIGNhbmNlbGxlZF9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHdhcyBjb21wbGV0ZWQuXG4gICAqL1xuICBjb21wbGV0ZWRfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHJ1biB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHdpbGwgZXhwaXJlLlxuICAgKi9cbiAgZXhwaXJlc19hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIGZhaWxlZC5cbiAgICovXG4gIGZhaWxlZF9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogRGV0YWlscyBvbiB3aHkgdGhlIHJ1biBpcyBpbmNvbXBsZXRlLiBXaWxsIGJlIGBudWxsYCBpZiB0aGUgcnVuIGlzIG5vdFxuICAgKiBpbmNvbXBsZXRlLlxuICAgKi9cbiAgaW5jb21wbGV0ZV9kZXRhaWxzOiBSdW4uSW5jb21wbGV0ZURldGFpbHMgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5zdHJ1Y3Rpb25zIHRoYXQgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdXNlZCBmb3JcbiAgICogdGhpcyBydW4uXG4gICAqL1xuICBpbnN0cnVjdGlvbnM6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGxhc3QgZXJyb3IgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcnVuLiBXaWxsIGJlIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gZXJyb3JzLlxuICAgKi9cbiAgbGFzdF9lcnJvcjogUnVuLkxhc3RFcnJvciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2VucyBzcGVjaWZpZWQgdG8gaGF2ZSBiZWVuIHVzZWQgb3ZlciB0aGVcbiAgICogY291cnNlIG9mIHRoZSBydW4uXG4gICAqL1xuICBtYXhfY29tcGxldGlvbl90b2tlbnM6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zIHNwZWNpZmllZCB0byBoYXZlIGJlZW4gdXNlZCBvdmVyIHRoZSBjb3Vyc2VcbiAgICogb2YgdGhlIHJ1bi5cbiAgICovXG4gIG1heF9wcm9tcHRfdG9rZW5zOiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YTogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlbCB0aGF0IHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIHVzZWQgZm9yXG4gICAqIHRoaXMgcnVuLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYHRocmVhZC5ydW5gLlxuICAgKi9cbiAgb2JqZWN0OiAndGhyZWFkLnJ1bic7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlXG4gICAqIFtwYXJhbGxlbCBmdW5jdGlvbiBjYWxsaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZnVuY3Rpb24tY2FsbGluZyNjb25maWd1cmluZy1wYXJhbGxlbC1mdW5jdGlvbi1jYWxsaW5nKVxuICAgKiBkdXJpbmcgdG9vbCB1c2UuXG4gICAqL1xuICBwYXJhbGxlbF90b29sX2NhbGxzOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEZXRhaWxzIG9uIHRoZSBhY3Rpb24gcmVxdWlyZWQgdG8gY29udGludWUgdGhlIHJ1bi4gV2lsbCBiZSBgbnVsbGAgaWYgbm8gYWN0aW9uXG4gICAqIGlzIHJlcXVpcmVkLlxuICAgKi9cbiAgcmVxdWlyZWRfYWN0aW9uOiBSdW4uUmVxdWlyZWRBY3Rpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gICAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNG8pLFxuICAgKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICAgKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fc2NoZW1hXCIsIFwianNvbl9zY2hlbWFcIjogey4uLn0gfWAgZW5hYmxlcyBTdHJ1Y3R1cmVkXG4gICAqIE91dHB1dHMgd2hpY2ggZW5zdXJlcyB0aGUgbW9kZWwgd2lsbCBtYXRjaCB5b3VyIHN1cHBsaWVkIEpTT04gc2NoZW1hLiBMZWFybiBtb3JlXG4gICAqIGluIHRoZVxuICAgKiBbU3RydWN0dXJlZCBPdXRwdXRzIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc3RydWN0dXJlZC1vdXRwdXRzKS5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBlbnN1cmVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0OiBUaHJlYWRzQVBJLkFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHdhcyBzdGFydGVkLlxuICAgKi9cbiAgc3RhcnRlZF9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHN0YXR1cyBvZiB0aGUgcnVuLCB3aGljaCBjYW4gYmUgZWl0aGVyIGBxdWV1ZWRgLCBgaW5fcHJvZ3Jlc3NgLFxuICAgKiBgcmVxdWlyZXNfYWN0aW9uYCwgYGNhbmNlbGxpbmdgLCBgY2FuY2VsbGVkYCwgYGZhaWxlZGAsIGBjb21wbGV0ZWRgLFxuICAgKiBgaW5jb21wbGV0ZWAsIG9yIGBleHBpcmVkYC5cbiAgICovXG4gIHN0YXR1czogUnVuU3RhdHVzO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcylcbiAgICogdGhhdCB3YXMgZXhlY3V0ZWQgb24gYXMgYSBwYXJ0IG9mIHRoaXMgcnVuLlxuICAgKi9cbiAgdGhyZWFkX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIHdoaWNoIChpZiBhbnkpIHRvb2wgaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC4gYG5vbmVgIG1lYW5zIHRoZSBtb2RlbCB3aWxsXG4gICAqIG5vdCBjYWxsIGFueSB0b29scyBhbmQgaW5zdGVhZCBnZW5lcmF0ZXMgYSBtZXNzYWdlLiBgYXV0b2AgaXMgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICogYW5kIG1lYW5zIHRoZSBtb2RlbCBjYW4gcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yIGNhbGxpbmcgb25lIG9yIG1vcmVcbiAgICogdG9vbHMuIGByZXF1aXJlZGAgbWVhbnMgdGhlIG1vZGVsIG11c3QgY2FsbCBvbmUgb3IgbW9yZSB0b29scyBiZWZvcmUgcmVzcG9uZGluZ1xuICAgKiB0byB0aGUgdXNlci4gU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgdG9vbCBsaWtlIGB7XCJ0eXBlXCI6IFwiZmlsZV9zZWFyY2hcIn1gIG9yXG4gICAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gICAqIGNhbGwgdGhhdCB0b29sLlxuICAgKi9cbiAgdG9vbF9jaG9pY2U6IFRocmVhZHNBUEkuQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIHRvb2xzIHRoYXQgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdXNlZCBmb3JcbiAgICogdGhpcyBydW4uXG4gICAqL1xuICB0b29sczogQXJyYXk8QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRUb29sPjtcblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIHRydW5jYXRpb25fc3RyYXRlZ3k6IFJ1bi5UcnVuY2F0aW9uU3RyYXRlZ3kgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBVc2FnZSBzdGF0aXN0aWNzIHJlbGF0ZWQgdG8gdGhlIHJ1bi4gVGhpcyB2YWx1ZSB3aWxsIGJlIGBudWxsYCBpZiB0aGUgcnVuIGlzIG5vdFxuICAgKiBpbiBhIHRlcm1pbmFsIHN0YXRlIChpLmUuIGBpbl9wcm9ncmVzc2AsIGBxdWV1ZWRgLCBldGMuKS5cbiAgICovXG4gIHVzYWdlOiBSdW4uVXNhZ2UgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdXNlZCBmb3IgdGhpcyBydW4uIElmIG5vdCBzZXQsIGRlZmF1bHRzIHRvIDEuXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBudWNsZXVzIHNhbXBsaW5nIHZhbHVlIHVzZWQgZm9yIHRoaXMgcnVuLiBJZiBub3Qgc2V0LCBkZWZhdWx0cyB0byAxLlxuICAgKi9cbiAgdG9wX3A/OiBudW1iZXIgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJ1biB7XG4gIC8qKlxuICAgKiBEZXRhaWxzIG9uIHdoeSB0aGUgcnVuIGlzIGluY29tcGxldGUuIFdpbGwgYmUgYG51bGxgIGlmIHRoZSBydW4gaXMgbm90XG4gICAqIGluY29tcGxldGUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEluY29tcGxldGVEZXRhaWxzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVhc29uIHdoeSB0aGUgcnVuIGlzIGluY29tcGxldGUuIFRoaXMgd2lsbCBwb2ludCB0byB3aGljaCBzcGVjaWZpYyB0b2tlblxuICAgICAqIGxpbWl0IHdhcyByZWFjaGVkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgcnVuLlxuICAgICAqL1xuICAgIHJlYXNvbj86ICdtYXhfY29tcGxldGlvbl90b2tlbnMnIHwgJ21heF9wcm9tcHRfdG9rZW5zJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbGFzdCBlcnJvciBhc3NvY2lhdGVkIHdpdGggdGhpcyBydW4uIFdpbGwgYmUgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBlcnJvcnMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIExhc3RFcnJvciB7XG4gICAgLyoqXG4gICAgICogT25lIG9mIGBzZXJ2ZXJfZXJyb3JgLCBgcmF0ZV9saW1pdF9leGNlZWRlZGAsIG9yIGBpbnZhbGlkX3Byb21wdGAuXG4gICAgICovXG4gICAgY29kZTogJ3NlcnZlcl9lcnJvcicgfCAncmF0ZV9saW1pdF9leGNlZWRlZCcgfCAnaW52YWxpZF9wcm9tcHQnO1xuXG4gICAgLyoqXG4gICAgICogQSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3IuXG4gICAgICovXG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFpbHMgb24gdGhlIGFjdGlvbiByZXF1aXJlZCB0byBjb250aW51ZSB0aGUgcnVuLiBXaWxsIGJlIGBudWxsYCBpZiBubyBhY3Rpb25cbiAgICogaXMgcmVxdWlyZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFJlcXVpcmVkQWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBEZXRhaWxzIG9uIHRoZSB0b29sIG91dHB1dHMgbmVlZGVkIGZvciB0aGlzIHJ1biB0byBjb250aW51ZS5cbiAgICAgKi9cbiAgICBzdWJtaXRfdG9vbF9vdXRwdXRzOiBSZXF1aXJlZEFjdGlvbi5TdWJtaXRUb29sT3V0cHV0cztcblxuICAgIC8qKlxuICAgICAqIEZvciBub3csIHRoaXMgaXMgYWx3YXlzIGBzdWJtaXRfdG9vbF9vdXRwdXRzYC5cbiAgICAgKi9cbiAgICB0eXBlOiAnc3VibWl0X3Rvb2xfb3V0cHV0cyc7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFJlcXVpcmVkQWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBEZXRhaWxzIG9uIHRoZSB0b29sIG91dHB1dHMgbmVlZGVkIGZvciB0aGlzIHJ1biB0byBjb250aW51ZS5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIFN1Ym1pdFRvb2xPdXRwdXRzIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIHRoZSByZWxldmFudCB0b29sIGNhbGxzLlxuICAgICAgICovXG4gICAgICB0b29sX2NhbGxzOiBBcnJheTxSdW5zQVBJLlJlcXVpcmVkQWN0aW9uRnVuY3Rpb25Ub29sQ2FsbD47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRydW5jYXRpb25TdHJhdGVneSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRydW5jYXRpb24gc3RyYXRlZ3kgdG8gdXNlIGZvciB0aGUgdGhyZWFkLiBUaGUgZGVmYXVsdCBpcyBgYXV0b2AuIElmIHNldCB0b1xuICAgICAqIGBsYXN0X21lc3NhZ2VzYCwgdGhlIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCB0byB0aGUgbiBtb3N0IHJlY2VudCBtZXNzYWdlcyBpblxuICAgICAqIHRoZSB0aHJlYWQuIFdoZW4gc2V0IHRvIGBhdXRvYCwgbWVzc2FnZXMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdGhyZWFkIHdpbGwgYmVcbiAgICAgKiBkcm9wcGVkIHRvIGZpdCB0aGUgY29udGV4dCBsZW5ndGggb2YgdGhlIG1vZGVsLCBgbWF4X3Byb21wdF90b2tlbnNgLlxuICAgICAqL1xuICAgIHR5cGU6ICdhdXRvJyB8ICdsYXN0X21lc3NhZ2VzJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbW9zdCByZWNlbnQgbWVzc2FnZXMgZnJvbSB0aGUgdGhyZWFkIHdoZW4gY29uc3RydWN0aW5nIHRoZSBjb250ZXh0XG4gICAgICogZm9yIHRoZSBydW4uXG4gICAgICovXG4gICAgbGFzdF9tZXNzYWdlcz86IG51bWJlciB8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVXNhZ2Ugc3RhdGlzdGljcyByZWxhdGVkIHRvIHRoZSBydW4uIFRoaXMgdmFsdWUgd2lsbCBiZSBgbnVsbGAgaWYgdGhlIHJ1biBpcyBub3RcbiAgICogaW4gYSB0ZXJtaW5hbCBzdGF0ZSAoaS5lLiBgaW5fcHJvZ3Jlc3NgLCBgcXVldWVkYCwgZXRjLikuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFVzYWdlIHtcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBjb21wbGV0aW9uX3Rva2VuczogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHByb21wdCB0b2tlbnMgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBwcm9tcHRfdG9rZW5zOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUb3RhbCBudW1iZXIgb2YgdG9rZW5zIHVzZWQgKHByb21wdCArIGNvbXBsZXRpb24pLlxuICAgICAqL1xuICAgIHRvdGFsX3Rva2VuczogbnVtYmVyO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHN0YXR1cyBvZiB0aGUgcnVuLCB3aGljaCBjYW4gYmUgZWl0aGVyIGBxdWV1ZWRgLCBgaW5fcHJvZ3Jlc3NgLFxuICogYHJlcXVpcmVzX2FjdGlvbmAsIGBjYW5jZWxsaW5nYCwgYGNhbmNlbGxlZGAsIGBmYWlsZWRgLCBgY29tcGxldGVkYCxcbiAqIGBpbmNvbXBsZXRlYCwgb3IgYGV4cGlyZWRgLlxuICovXG5leHBvcnQgdHlwZSBSdW5TdGF0dXMgPVxuICB8ICdxdWV1ZWQnXG4gIHwgJ2luX3Byb2dyZXNzJ1xuICB8ICdyZXF1aXJlc19hY3Rpb24nXG4gIHwgJ2NhbmNlbGxpbmcnXG4gIHwgJ2NhbmNlbGxlZCdcbiAgfCAnZmFpbGVkJ1xuICB8ICdjb21wbGV0ZWQnXG4gIHwgJ2luY29tcGxldGUnXG4gIHwgJ2V4cGlyZWQnO1xuXG5leHBvcnQgdHlwZSBSdW5DcmVhdGVQYXJhbXMgPSBSdW5DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgfCBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBUaGUgSUQgb2YgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdG8gdXNlIHRvXG4gICAqIGV4ZWN1dGUgdGhpcyBydW4uXG4gICAqL1xuICBhc3Npc3RhbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogUXVlcnkgcGFyYW06IEEgbGlzdCBvZiBhZGRpdGlvbmFsIGZpZWxkcyB0byBpbmNsdWRlIGluIHRoZSByZXNwb25zZS4gQ3VycmVudGx5XG4gICAqIHRoZSBvbmx5IHN1cHBvcnRlZCB2YWx1ZSBpc1xuICAgKiBgc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHNbKl0uZmlsZV9zZWFyY2gucmVzdWx0c1sqXS5jb250ZW50YCB0byBmZXRjaCB0aGUgZmlsZVxuICAgKiBzZWFyY2ggcmVzdWx0IGNvbnRlbnQuXG4gICAqXG4gICAqIFNlZSB0aGVcbiAgICogW2ZpbGUgc2VhcmNoIHRvb2wgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy90b29scy9maWxlLXNlYXJjaCNjdXN0b21pemluZy1maWxlLXNlYXJjaC1zZXR0aW5ncylcbiAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbmNsdWRlPzogQXJyYXk8U3RlcHNBUEkuUnVuU3RlcEluY2x1ZGU+O1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBBcHBlbmRzIGFkZGl0aW9uYWwgaW5zdHJ1Y3Rpb25zIGF0IHRoZSBlbmQgb2YgdGhlIGluc3RydWN0aW9ucyBmb3JcbiAgICogdGhlIHJ1bi4gVGhpcyBpcyB1c2VmdWwgZm9yIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzIHdpdGhvdXRcbiAgICogb3ZlcnJpZGluZyBvdGhlciBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICBhZGRpdGlvbmFsX2luc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IEFkZHMgYWRkaXRpb25hbCBtZXNzYWdlcyB0byB0aGUgdGhyZWFkIGJlZm9yZSBjcmVhdGluZyB0aGUgcnVuLlxuICAgKi9cbiAgYWRkaXRpb25hbF9tZXNzYWdlcz86IEFycmF5PFJ1bkNyZWF0ZVBhcmFtcy5BZGRpdGlvbmFsTWVzc2FnZT4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBPdmVycmlkZXMgdGhlXG4gICAqIFtpbnN0cnVjdGlvbnNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cy9jcmVhdGVBc3Npc3RhbnQpXG4gICAqIG9mIHRoZSBhc3Npc3RhbnQuIFRoaXMgaXMgdXNlZnVsIGZvciBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlXG4gICAqIGNvdXJzZSBvZiB0aGUgcnVuLiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2ZcbiAgICogY29tcGxldGlvbiB0b2tlbnMgc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1blxuICAgKiBleGNlZWRzIHRoZSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzXG4gICAqIGBpbmNvbXBsZXRlYC4gU2VlIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfY29tcGxldGlvbl90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcHJvbXB0IHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZVxuICAgKiBvZiB0aGUgcnVuLiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgcHJvbXB0XG4gICAqIHRva2VucyBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlXG4gICAqIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuXG4gICAqIFNlZSBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X3Byb21wdF90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpc1xuICAgKiBjYW4gYmUgdXNlZnVsIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhXG4gICAqIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlXG4gICAqIGEgbWF4aXVtIG9mIDUxMiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBUaGUgSUQgb2YgdGhlXG4gICAqIFtNb2RlbF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tb2RlbHMpIHRvIGJlIHVzZWQgdG9cbiAgICogZXhlY3V0ZSB0aGlzIHJ1bi4gSWYgYSB2YWx1ZSBpcyBwcm92aWRlZCBoZXJlLCBpdCB3aWxsIG92ZXJyaWRlIHRoZSBtb2RlbFxuICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2lzdGFudC4gSWYgbm90LCB0aGUgbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3Npc3RhbnRcbiAgICogd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgbW9kZWw/OiAoc3RyaW5nICYge30pIHwgQ2hhdEFQSS5DaGF0TW9kZWwgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBXaGV0aGVyIHRvIGVuYWJsZVxuICAgKiBbcGFyYWxsZWwgZnVuY3Rpb24gY2FsbGluZ10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2Z1bmN0aW9uLWNhbGxpbmcjY29uZmlndXJpbmctcGFyYWxsZWwtZnVuY3Rpb24tY2FsbGluZylcbiAgICogZHVyaW5nIHRvb2wgdXNlLlxuICAgKi9cbiAgcGFyYWxsZWxfdG9vbF9jYWxscz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAgICogW0dQVC00b10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00byksXG4gICAqIFtHUFQtNCBUdXJib10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00LXR1cmJvLWFuZC1ncHQtNCksXG4gICAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9zY2hlbWFcIiwgXCJqc29uX3NjaGVtYVwiOiB7Li4ufSB9YCBlbmFibGVzIFN0cnVjdHVyZWRcbiAgICogT3V0cHV0cyB3aGljaCBlbnN1cmVzIHRoZSBtb2RlbCB3aWxsIG1hdGNoIHlvdXIgc3VwcGxpZWQgSlNPTiBzY2hlbWEuIExlYXJuIG1vcmVcbiAgICogaW4gdGhlXG4gICAqIFtTdHJ1Y3R1cmVkIE91dHB1dHMgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zdHJ1Y3R1cmVkLW91dHB1dHMpLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGVuc3VyZXMgdGhlXG4gICAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICAgKlxuICAgKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gICAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAgICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAgICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAgICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICAgKiBtYXggY29udGV4dCBsZW5ndGguXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBUaHJlYWRzQVBJLkFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogSWYgYHRydWVgLCByZXR1cm5zIGEgc3RyZWFtIG9mIGV2ZW50cyB0aGF0IGhhcHBlbiBkdXJpbmcgdGhlIFJ1biBhc1xuICAgKiBzZXJ2ZXItc2VudCBldmVudHMsIHRlcm1pbmF0aW5nIHdoZW4gdGhlIFJ1biBlbnRlcnMgYSB0ZXJtaW5hbCBzdGF0ZSB3aXRoIGFcbiAgICogYGRhdGE6IFtET05FXWAgbWVzc2FnZS5cbiAgICovXG4gIHN0cmVhbT86IGJvb2xlYW4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzXG4gICAqIGxpa2UgMC44IHdpbGwgbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlXG4gICAqIGl0IG1vcmUgZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgdG9vbCBpcyBjYWxsZWQgYnkgdGhlIG1vZGVsLiBgbm9uZWAgbWVhbnNcbiAgICogdGhlIG1vZGVsIHdpbGwgbm90IGNhbGwgYW55IHRvb2xzIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBpcyB0aGVcbiAgICogZGVmYXVsdCB2YWx1ZSBhbmQgbWVhbnMgdGhlIG1vZGVsIGNhbiBwaWNrIGJldHdlZW4gZ2VuZXJhdGluZyBhIG1lc3NhZ2Ugb3JcbiAgICogY2FsbGluZyBvbmUgb3IgbW9yZSB0b29scy4gYHJlcXVpcmVkYCBtZWFucyB0aGUgbW9kZWwgbXVzdCBjYWxsIG9uZSBvciBtb3JlXG4gICAqIHRvb2xzIGJlZm9yZSByZXNwb25kaW5nIHRvIHRoZSB1c2VyLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciB0b29sIGxpa2VcbiAgICogYHtcInR5cGVcIjogXCJmaWxlX3NlYXJjaFwifWAgb3JcbiAgICogYHtcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifX1gIGZvcmNlcyB0aGUgbW9kZWwgdG9cbiAgICogY2FsbCB0aGF0IHRvb2wuXG4gICAqL1xuICB0b29sX2Nob2ljZT86IFRocmVhZHNBUEkuQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IE92ZXJyaWRlIHRoZSB0b29scyB0aGUgYXNzaXN0YW50IGNhbiB1c2UgZm9yIHRoaXMgcnVuLiBUaGlzIGlzXG4gICAqIHVzZWZ1bCBmb3IgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQXNzaXN0YW50VG9vbD4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1c1xuICAgKiBzYW1wbGluZywgd2hlcmUgdGhlIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3BcbiAgICogcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlXG4gICAqIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlXG4gICAqIHRoaXMgdG8gY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICB0cnVuY2F0aW9uX3N0cmF0ZWd5PzogUnVuQ3JlYXRlUGFyYW1zLlRydW5jYXRpb25TdHJhdGVneSB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuQ3JlYXRlUGFyYW1zIHtcbiAgZXhwb3J0IGludGVyZmFjZSBBZGRpdGlvbmFsTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8TWVzc2FnZXNBUEkuTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJvbGUgb2YgdGhlIGVudGl0eSB0aGF0IGlzIGNyZWF0aW5nIHRoZSBtZXNzYWdlLiBBbGxvd2VkIHZhbHVlcyBpbmNsdWRlOlxuICAgICAqXG4gICAgICogLSBgdXNlcmA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBzZW50IGJ5IGFuIGFjdHVhbCB1c2VyIGFuZCBzaG91bGQgYmUgdXNlZCBpblxuICAgICAqICAgbW9zdCBjYXNlcyB0byByZXByZXNlbnQgdXNlci1nZW5lcmF0ZWQgbWVzc2FnZXMuXG4gICAgICogLSBgYXNzaXN0YW50YDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGdlbmVyYXRlZCBieSB0aGUgYXNzaXN0YW50LiBVc2UgdGhpc1xuICAgICAqICAgdmFsdWUgdG8gaW5zZXJ0IG1lc3NhZ2VzIGZyb20gdGhlIGFzc2lzdGFudCBpbnRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgZmlsZXMgYXR0YWNoZWQgdG8gdGhlIG1lc3NhZ2UsIGFuZCB0aGUgdG9vbHMgdGhleSBzaG91bGQgYmUgYWRkZWQgdG8uXG4gICAgICovXG4gICAgYXR0YWNobWVudHM/OiBBcnJheTxBZGRpdGlvbmFsTWVzc2FnZS5BdHRhY2htZW50PiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICovXG4gICAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgQWRkaXRpb25hbE1lc3NhZ2Uge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBhdHRhY2ggdG8gdGhlIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRvb2xzIHRvIGFkZCB0aGlzIGZpbGUgdG8uXG4gICAgICAgKi9cbiAgICAgIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXR0YWNobWVudC5GaWxlU2VhcmNoPjtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIEF0dGFjaG1lbnQge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRvb2wgYmVpbmcgZGVmaW5lZDogYGZpbGVfc2VhcmNoYFxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2ZpbGVfc2VhcmNoJztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVHJ1bmNhdGlvblN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJ1bmNhdGlvbiBzdHJhdGVneSB0byB1c2UgZm9yIHRoZSB0aHJlYWQuIFRoZSBkZWZhdWx0IGlzIGBhdXRvYC4gSWYgc2V0IHRvXG4gICAgICogYGxhc3RfbWVzc2FnZXNgLCB0aGUgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHRvIHRoZSBuIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGluXG4gICAgICogdGhlIHRocmVhZC4gV2hlbiBzZXQgdG8gYGF1dG9gLCBtZXNzYWdlcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSB0aHJlYWQgd2lsbCBiZVxuICAgICAqIGRyb3BwZWQgdG8gZml0IHRoZSBjb250ZXh0IGxlbmd0aCBvZiB0aGUgbW9kZWwsIGBtYXhfcHJvbXB0X3Rva2Vuc2AuXG4gICAgICovXG4gICAgdHlwZTogJ2F1dG8nIHwgJ2xhc3RfbWVzc2FnZXMnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtb3N0IHJlY2VudCBtZXNzYWdlcyBmcm9tIHRoZSB0aHJlYWQgd2hlbiBjb25zdHJ1Y3RpbmcgdGhlIGNvbnRleHRcbiAgICAgKiBmb3IgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBsYXN0X21lc3NhZ2VzPzogbnVtYmVyIHwgbnVsbDtcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIFJ1bkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyA9IFJ1bnNBUEkuUnVuQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nO1xuICBleHBvcnQgdHlwZSBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSBSdW5zQVBJLlJ1bkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSdW5DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgZXh0ZW5kcyBSdW5DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IElmIGB0cnVlYCwgcmV0dXJucyBhIHN0cmVhbSBvZiBldmVudHMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoZSBSdW4gYXNcbiAgICogc2VydmVyLXNlbnQgZXZlbnRzLCB0ZXJtaW5hdGluZyB3aGVuIHRoZSBSdW4gZW50ZXJzIGEgdGVybWluYWwgc3RhdGUgd2l0aCBhXG4gICAqIGBkYXRhOiBbRE9ORV1gIG1lc3NhZ2UuXG4gICAqL1xuICBzdHJlYW0/OiBmYWxzZSB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGV4dGVuZHMgUnVuQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBJZiBgdHJ1ZWAsIHJldHVybnMgYSBzdHJlYW0gb2YgZXZlbnRzIHRoYXQgaGFwcGVuIGR1cmluZyB0aGUgUnVuIGFzXG4gICAqIHNlcnZlci1zZW50IGV2ZW50cywgdGVybWluYXRpbmcgd2hlbiB0aGUgUnVuIGVudGVycyBhIHRlcm1pbmFsIHN0YXRlIHdpdGggYVxuICAgKiBgZGF0YTogW0RPTkVdYCBtZXNzYWdlLlxuICAgKi9cbiAgc3RyZWFtOiB0cnVlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1blVwZGF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1bkxpc3RQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgY3Vyc29yIGZvciB1c2UgaW4gcGFnaW5hdGlvbi4gYGJlZm9yZWAgaXMgYW4gb2JqZWN0IElEIHRoYXQgZGVmaW5lcyB5b3VyIHBsYWNlXG4gICAqIGluIHRoZSBsaXN0LiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBtYWtlIGEgbGlzdCByZXF1ZXN0IGFuZCByZWNlaXZlIDEwMCBvYmplY3RzLFxuICAgKiBzdGFydGluZyB3aXRoIG9ial9mb28sIHlvdXIgc3Vic2VxdWVudCBjYWxsIGNhbiBpbmNsdWRlIGJlZm9yZT1vYmpfZm9vIGluIG9yZGVyXG4gICAqIHRvIGZldGNoIHRoZSBwcmV2aW91cyBwYWdlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgYmVmb3JlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTb3J0IG9yZGVyIGJ5IHRoZSBgY3JlYXRlZF9hdGAgdGltZXN0YW1wIG9mIHRoZSBvYmplY3RzLiBgYXNjYCBmb3IgYXNjZW5kaW5nXG4gICAqIG9yZGVyIGFuZCBgZGVzY2AgZm9yIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAqL1xuICBvcmRlcj86ICdhc2MnIHwgJ2Rlc2MnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1bkNyZWF0ZUFuZFBvbGxQYXJhbXMge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIHRvIHVzZSB0b1xuICAgKiBleGVjdXRlIHRoaXMgcnVuLlxuICAgKi9cbiAgYXNzaXN0YW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgYWRkaXRpb25hbCBpbnN0cnVjdGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgaW5zdHJ1Y3Rpb25zIGZvciB0aGUgcnVuLiBUaGlzXG4gICAqIGlzIHVzZWZ1bCBmb3IgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMgd2l0aG91dCBvdmVycmlkaW5nIG90aGVyXG4gICAqIGluc3RydWN0aW9ucy5cbiAgICovXG4gIGFkZGl0aW9uYWxfaW5zdHJ1Y3Rpb25zPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogQWRkcyBhZGRpdGlvbmFsIG1lc3NhZ2VzIHRvIHRoZSB0aHJlYWQgYmVmb3JlIGNyZWF0aW5nIHRoZSBydW4uXG4gICAqL1xuICBhZGRpdGlvbmFsX21lc3NhZ2VzPzogQXJyYXk8UnVuQ3JlYXRlQW5kUG9sbFBhcmFtcy5BZGRpdGlvbmFsTWVzc2FnZT4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgdGhlXG4gICAqIFtpbnN0cnVjdGlvbnNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cy9jcmVhdGVBc3Npc3RhbnQpXG4gICAqIG9mIHRoZSBhc3Npc3RhbnQuIFRoaXMgaXMgdXNlZnVsIGZvciBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGVcbiAgICogcnVuLiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogY29tcGxldGlvbiB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC4gU2VlXG4gICAqIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfY29tcGxldGlvbl90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcHJvbXB0IHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgcnVuLlxuICAgKiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgcHJvbXB0IHRva2Vuc1xuICAgKiBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlIG51bWJlciBvZlxuICAgKiBwcm9tcHQgdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X3Byb21wdF90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFtNb2RlbF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tb2RlbHMpIHRvXG4gICAqIGJlIHVzZWQgdG8gZXhlY3V0ZSB0aGlzIHJ1bi4gSWYgYSB2YWx1ZSBpcyBwcm92aWRlZCBoZXJlLCBpdCB3aWxsIG92ZXJyaWRlIHRoZVxuICAgKiBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2lzdGFudC4gSWYgbm90LCB0aGUgbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgKiBhc3Npc3RhbnQgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgbW9kZWw/OlxuICAgIHwgKHN0cmluZyAmIHt9KVxuICAgIHwgJ2dwdC00bydcbiAgICB8ICdncHQtNG8tMjAyNC0wNS0xMydcbiAgICB8ICdncHQtNC10dXJibydcbiAgICB8ICdncHQtNC10dXJiby0yMDI0LTA0LTA5J1xuICAgIHwgJ2dwdC00LTAxMjUtcHJldmlldydcbiAgICB8ICdncHQtNC10dXJiby1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LTExMDYtcHJldmlldydcbiAgICB8ICdncHQtNC12aXNpb24tcHJldmlldydcbiAgICB8ICdncHQtNCdcbiAgICB8ICdncHQtNC0wMzE0J1xuICAgIHwgJ2dwdC00LTA2MTMnXG4gICAgfCAnZ3B0LTQtMzJrJ1xuICAgIHwgJ2dwdC00LTMyay0wMzE0J1xuICAgIHwgJ2dwdC00LTMyay0wNjEzJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8nXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xNmsnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0wNjEzJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTEwNidcbiAgICB8ICdncHQtMy41LXR1cmJvLTAxMjUnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xNmstMDYxMydcbiAgICB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAgICogW0dQVC00b10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzL2dwdC00byksXG4gICAqIFtHUFQtNCBUdXJib10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzL2dwdC00LXR1cmJvLWFuZC1ncHQtNCksXG4gICAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9vYmplY3RcIiB9YCBlbmFibGVzIEpTT04gbW9kZSwgd2hpY2ggZ3VhcmFudGVlcyB0aGVcbiAgICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gICAqXG4gICAqICoqSW1wb3J0YW50OioqIHdoZW4gdXNpbmcgSlNPTiBtb2RlLCB5b3UgKiptdXN0KiogYWxzbyBpbnN0cnVjdCB0aGUgbW9kZWwgdG9cbiAgICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICAgKiBnZW5lcmF0ZSBhbiB1bmVuZGluZyBzdHJlYW0gb2Ygd2hpdGVzcGFjZSB1bnRpbCB0aGUgZ2VuZXJhdGlvbiByZWFjaGVzIHRoZSB0b2tlblxuICAgKiBsaW1pdCwgcmVzdWx0aW5nIGluIGEgbG9uZy1ydW5uaW5nIGFuZCBzZWVtaW5nbHkgXCJzdHVja1wiIHJlcXVlc3QuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICAgKiBpbmRpY2F0ZXMgdGhlIGdlbmVyYXRpb24gZXhjZWVkZWQgYG1heF90b2tlbnNgIG9yIHRoZSBjb252ZXJzYXRpb24gZXhjZWVkZWQgdGhlXG4gICAqIG1heCBjb250ZXh0IGxlbmd0aC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86IFRocmVhZHNBUEkuQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgdG9vbCBpcyBjYWxsZWQgYnkgdGhlIG1vZGVsLiBgbm9uZWAgbWVhbnMgdGhlIG1vZGVsIHdpbGxcbiAgICogbm90IGNhbGwgYW55IHRvb2xzIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBpcyB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgKiBhbmQgbWVhbnMgdGhlIG1vZGVsIGNhbiBwaWNrIGJldHdlZW4gZ2VuZXJhdGluZyBhIG1lc3NhZ2Ugb3IgY2FsbGluZyBvbmUgb3IgbW9yZVxuICAgKiB0b29scy4gYHJlcXVpcmVkYCBtZWFucyB0aGUgbW9kZWwgbXVzdCBjYWxsIG9uZSBvciBtb3JlIHRvb2xzIGJlZm9yZSByZXNwb25kaW5nXG4gICAqIHRvIHRoZSB1c2VyLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciB0b29sIGxpa2UgYHtcInR5cGVcIjogXCJmaWxlX3NlYXJjaFwifWAgb3JcbiAgICogYHtcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifX1gIGZvcmNlcyB0aGUgbW9kZWwgdG9cbiAgICogY2FsbCB0aGF0IHRvb2wuXG4gICAqL1xuICB0b29sX2Nob2ljZT86IFRocmVhZHNBUEkuQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSB0b29scyB0aGUgYXNzaXN0YW50IGNhbiB1c2UgZm9yIHRoaXMgcnVuLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQXNzaXN0YW50VG9vbD4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICB0cnVuY2F0aW9uX3N0cmF0ZWd5PzogUnVuQ3JlYXRlQW5kUG9sbFBhcmFtcy5UcnVuY2F0aW9uU3RyYXRlZ3kgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJ1bkNyZWF0ZUFuZFBvbGxQYXJhbXMge1xuICBleHBvcnQgaW50ZXJmYWNlIEFkZGl0aW9uYWxNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCBjb250ZW50cyBvZiB0aGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxNZXNzYWdlc0FQSS5NZXNzYWdlQ29udGVudFBhcnRQYXJhbT47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm9sZSBvZiB0aGUgZW50aXR5IHRoYXQgaXMgY3JlYXRpbmcgdGhlIG1lc3NhZ2UuIEFsbG93ZWQgdmFsdWVzIGluY2x1ZGU6XG4gICAgICpcbiAgICAgKiAtIGB1c2VyYDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIHNlbnQgYnkgYW4gYWN0dWFsIHVzZXIgYW5kIHNob3VsZCBiZSB1c2VkIGluXG4gICAgICogICBtb3N0IGNhc2VzIHRvIHJlcHJlc2VudCB1c2VyLWdlbmVyYXRlZCBtZXNzYWdlcy5cbiAgICAgKiAtIGBhc3Npc3RhbnRgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBhc3Npc3RhbnQuIFVzZSB0aGlzXG4gICAgICogICB2YWx1ZSB0byBpbnNlcnQgbWVzc2FnZXMgZnJvbSB0aGUgYXNzaXN0YW50IGludG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgKi9cbiAgICByb2xlOiAndXNlcicgfCAnYXNzaXN0YW50JztcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byB0aGUgbWVzc2FnZSwgYW5kIHRoZSB0b29scyB0aGV5IHNob3VsZCBiZSBhZGRlZCB0by5cbiAgICAgKi9cbiAgICBhdHRhY2htZW50cz86IEFycmF5PEFkZGl0aW9uYWxNZXNzYWdlLkF0dGFjaG1lbnQ+IHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgKi9cbiAgICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBBZGRpdGlvbmFsTWVzc2FnZSB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBBdHRhY2htZW50IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIElEIG9mIHRoZSBmaWxlIHRvIGF0dGFjaCB0byB0aGUgbWVzc2FnZS5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZD86IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdG9vbHMgdG8gYWRkIHRoaXMgZmlsZSB0by5cbiAgICAgICAqL1xuICAgICAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkNvZGVJbnRlcnByZXRlclRvb2wgfCBBc3Npc3RhbnRzQVBJLkZpbGVTZWFyY2hUb29sPjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVHJ1bmNhdGlvblN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJ1bmNhdGlvbiBzdHJhdGVneSB0byB1c2UgZm9yIHRoZSB0aHJlYWQuIFRoZSBkZWZhdWx0IGlzIGBhdXRvYC4gSWYgc2V0IHRvXG4gICAgICogYGxhc3RfbWVzc2FnZXNgLCB0aGUgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHRvIHRoZSBuIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGluXG4gICAgICogdGhlIHRocmVhZC4gV2hlbiBzZXQgdG8gYGF1dG9gLCBtZXNzYWdlcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSB0aHJlYWQgd2lsbCBiZVxuICAgICAqIGRyb3BwZWQgdG8gZml0IHRoZSBjb250ZXh0IGxlbmd0aCBvZiB0aGUgbW9kZWwsIGBtYXhfcHJvbXB0X3Rva2Vuc2AuXG4gICAgICovXG4gICAgdHlwZTogJ2F1dG8nIHwgJ2xhc3RfbWVzc2FnZXMnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtb3N0IHJlY2VudCBtZXNzYWdlcyBmcm9tIHRoZSB0aHJlYWQgd2hlbiBjb25zdHJ1Y3RpbmcgdGhlIGNvbnRleHRcbiAgICAgKiBmb3IgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBsYXN0X21lc3NhZ2VzPzogbnVtYmVyIHwgbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1bkNyZWF0ZUFuZFN0cmVhbVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdG8gdXNlIHRvXG4gICAqIGV4ZWN1dGUgdGhpcyBydW4uXG4gICAqL1xuICBhc3Npc3RhbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQXBwZW5kcyBhZGRpdGlvbmFsIGluc3RydWN0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSBpbnN0cnVjdGlvbnMgZm9yIHRoZSBydW4uIFRoaXNcbiAgICogaXMgdXNlZnVsIGZvciBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcyB3aXRob3V0IG92ZXJyaWRpbmcgb3RoZXJcbiAgICogaW5zdHJ1Y3Rpb25zLlxuICAgKi9cbiAgYWRkaXRpb25hbF9pbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBZGRzIGFkZGl0aW9uYWwgbWVzc2FnZXMgdG8gdGhlIHRocmVhZCBiZWZvcmUgY3JlYXRpbmcgdGhlIHJ1bi5cbiAgICovXG4gIGFkZGl0aW9uYWxfbWVzc2FnZXM/OiBBcnJheTxSdW5DcmVhdGVBbmRTdHJlYW1QYXJhbXMuQWRkaXRpb25hbE1lc3NhZ2U+IHwgbnVsbDtcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIHRoZVxuICAgKiBbaW5zdHJ1Y3Rpb25zXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMvY3JlYXRlQXNzaXN0YW50KVxuICAgKiBvZiB0aGUgYXNzaXN0YW50LiBUaGlzIGlzIHVzZWZ1bCBmb3IgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlXG4gICAqIHJ1bi4gVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zXG4gICAqIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGUgbnVtYmVyIG9mXG4gICAqIGNvbXBsZXRpb24gdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X2NvbXBsZXRpb25fdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHByb21wdCB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1bi5cbiAgICogVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIHByb21wdCB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogcHJvbXB0IHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLiBTZWVcbiAgICogYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9wcm9tcHRfdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBbTW9kZWxdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzKSB0b1xuICAgKiBiZSB1c2VkIHRvIGV4ZWN1dGUgdGhpcyBydW4uIElmIGEgdmFsdWUgaXMgcHJvdmlkZWQgaGVyZSwgaXQgd2lsbCBvdmVycmlkZSB0aGVcbiAgICogbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3Npc3RhbnQuIElmIG5vdCwgdGhlIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICogYXNzaXN0YW50IHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIG1vZGVsPzpcbiAgICB8IChzdHJpbmcgJiB7fSlcbiAgICB8ICdncHQtNG8nXG4gICAgfCAnZ3B0LTRvLTIwMjQtMDUtMTMnXG4gICAgfCAnZ3B0LTQtdHVyYm8nXG4gICAgfCAnZ3B0LTQtdHVyYm8tMjAyNC0wNC0wOSdcbiAgICB8ICdncHQtNC0wMTI1LXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtdHVyYm8tcHJldmlldydcbiAgICB8ICdncHQtNC0xMTA2LXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtdmlzaW9uLXByZXZpZXcnXG4gICAgfCAnZ3B0LTQnXG4gICAgfCAnZ3B0LTQtMDMxNCdcbiAgICB8ICdncHQtNC0wNjEzJ1xuICAgIHwgJ2dwdC00LTMyaydcbiAgICB8ICdncHQtNC0zMmstMDMxNCdcbiAgICB8ICdncHQtNC0zMmstMDYxMydcbiAgICB8ICdncHQtMy41LXR1cmJvJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTZrJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMDYxMydcbiAgICB8ICdncHQtMy41LXR1cmJvLTExMDYnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0wMTI1J1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTZrLTA2MTMnXG4gICAgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gICAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscy9ncHQtNG8pLFxuICAgKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscy9ncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICAgKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGd1YXJhbnRlZXMgdGhlXG4gICAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICAgKlxuICAgKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gICAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAgICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAgICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAgICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICAgKiBtYXggY29udGV4dCBsZW5ndGguXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBUaHJlYWRzQVBJLkFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIHdoaWNoIChpZiBhbnkpIHRvb2wgaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC4gYG5vbmVgIG1lYW5zIHRoZSBtb2RlbCB3aWxsXG4gICAqIG5vdCBjYWxsIGFueSB0b29scyBhbmQgaW5zdGVhZCBnZW5lcmF0ZXMgYSBtZXNzYWdlLiBgYXV0b2AgaXMgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICogYW5kIG1lYW5zIHRoZSBtb2RlbCBjYW4gcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yIGNhbGxpbmcgb25lIG9yIG1vcmVcbiAgICogdG9vbHMuIGByZXF1aXJlZGAgbWVhbnMgdGhlIG1vZGVsIG11c3QgY2FsbCBvbmUgb3IgbW9yZSB0b29scyBiZWZvcmUgcmVzcG9uZGluZ1xuICAgKiB0byB0aGUgdXNlci4gU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgdG9vbCBsaWtlIGB7XCJ0eXBlXCI6IFwiZmlsZV9zZWFyY2hcIn1gIG9yXG4gICAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gICAqIGNhbGwgdGhhdCB0b29sLlxuICAgKi9cbiAgdG9vbF9jaG9pY2U/OiBUaHJlYWRzQVBJLkFzc2lzdGFudFRvb2xDaG9pY2VPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgdG9vbHMgdGhlIGFzc2lzdGFudCBjYW4gdXNlIGZvciB0aGlzIHJ1bi4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzLlxuICAgKi9cbiAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFRvb2w+IHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgdGVtcGVyYXR1cmUgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdG9wX3A/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgdHJ1bmNhdGlvbl9zdHJhdGVneT86IFJ1bkNyZWF0ZUFuZFN0cmVhbVBhcmFtcy5UcnVuY2F0aW9uU3RyYXRlZ3kgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJ1bkNyZWF0ZUFuZFN0cmVhbVBhcmFtcyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQWRkaXRpb25hbE1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PE1lc3NhZ2VzQVBJLk1lc3NhZ2VDb250ZW50UGFydFBhcmFtPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSByb2xlIG9mIHRoZSBlbnRpdHkgdGhhdCBpcyBjcmVhdGluZyB0aGUgbWVzc2FnZS4gQWxsb3dlZCB2YWx1ZXMgaW5jbHVkZTpcbiAgICAgKlxuICAgICAqIC0gYHVzZXJgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgc2VudCBieSBhbiBhY3R1YWwgdXNlciBhbmQgc2hvdWxkIGJlIHVzZWQgaW5cbiAgICAgKiAgIG1vc3QgY2FzZXMgdG8gcmVwcmVzZW50IHVzZXItZ2VuZXJhdGVkIG1lc3NhZ2VzLlxuICAgICAqIC0gYGFzc2lzdGFudGA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBnZW5lcmF0ZWQgYnkgdGhlIGFzc2lzdGFudC4gVXNlIHRoaXNcbiAgICAgKiAgIHZhbHVlIHRvIGluc2VydCBtZXNzYWdlcyBmcm9tIHRoZSBhc3Npc3RhbnQgaW50byB0aGUgY29udmVyc2F0aW9uLlxuICAgICAqL1xuICAgIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xuXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIHRoZSBtZXNzYWdlLCBhbmQgdGhlIHRvb2xzIHRoZXkgc2hvdWxkIGJlIGFkZGVkIHRvLlxuICAgICAqL1xuICAgIGF0dGFjaG1lbnRzPzogQXJyYXk8QWRkaXRpb25hbE1lc3NhZ2UuQXR0YWNobWVudD4gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAgICogY2hhcmFjdGVycyBsb25nLlxuICAgICAqL1xuICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIEFkZGl0aW9uYWxNZXNzYWdlIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIEF0dGFjaG1lbnQge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gYXR0YWNoIHRvIHRoZSBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkPzogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0b29scyB0byBhZGQgdGhpcyBmaWxlIHRvLlxuICAgICAgICovXG4gICAgICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEFzc2lzdGFudHNBUEkuRmlsZVNlYXJjaFRvb2w+O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUcnVuY2F0aW9uU3RyYXRlZ3kge1xuICAgIC8qKlxuICAgICAqIFRoZSB0cnVuY2F0aW9uIHN0cmF0ZWd5IHRvIHVzZSBmb3IgdGhlIHRocmVhZC4gVGhlIGRlZmF1bHQgaXMgYGF1dG9gLiBJZiBzZXQgdG9cbiAgICAgKiBgbGFzdF9tZXNzYWdlc2AsIHRoZSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgdG8gdGhlIG4gbW9zdCByZWNlbnQgbWVzc2FnZXMgaW5cbiAgICAgKiB0aGUgdGhyZWFkLiBXaGVuIHNldCB0byBgYXV0b2AsIG1lc3NhZ2VzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHRocmVhZCB3aWxsIGJlXG4gICAgICogZHJvcHBlZCB0byBmaXQgdGhlIGNvbnRleHQgbGVuZ3RoIG9mIHRoZSBtb2RlbCwgYG1heF9wcm9tcHRfdG9rZW5zYC5cbiAgICAgKi9cbiAgICB0eXBlOiAnYXV0bycgfCAnbGFzdF9tZXNzYWdlcyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGZyb20gdGhlIHRocmVhZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgY29udGV4dFxuICAgICAqIGZvciB0aGUgcnVuLlxuICAgICAqL1xuICAgIGxhc3RfbWVzc2FnZXM/OiBudW1iZXIgfCBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuU3RyZWFtUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGVcbiAgICogW2Fzc2lzdGFudF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSB0byB1c2UgdG9cbiAgICogZXhlY3V0ZSB0aGlzIHJ1bi5cbiAgICovXG4gIGFzc2lzdGFudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBcHBlbmRzIGFkZGl0aW9uYWwgaW5zdHJ1Y3Rpb25zIGF0IHRoZSBlbmQgb2YgdGhlIGluc3RydWN0aW9ucyBmb3IgdGhlIHJ1bi4gVGhpc1xuICAgKiBpcyB1c2VmdWwgZm9yIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzIHdpdGhvdXQgb3ZlcnJpZGluZyBvdGhlclxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICBhZGRpdGlvbmFsX2luc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEFkZHMgYWRkaXRpb25hbCBtZXNzYWdlcyB0byB0aGUgdGhyZWFkIGJlZm9yZSBjcmVhdGluZyB0aGUgcnVuLlxuICAgKi9cbiAgYWRkaXRpb25hbF9tZXNzYWdlcz86IEFycmF5PFJ1blN0cmVhbVBhcmFtcy5BZGRpdGlvbmFsTWVzc2FnZT4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgdGhlXG4gICAqIFtpbnN0cnVjdGlvbnNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cy9jcmVhdGVBc3Npc3RhbnQpXG4gICAqIG9mIHRoZSBhc3Npc3RhbnQuIFRoaXMgaXMgdXNlZnVsIGZvciBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGVcbiAgICogcnVuLiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogY29tcGxldGlvbiB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC4gU2VlXG4gICAqIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfY29tcGxldGlvbl90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcHJvbXB0IHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgcnVuLlxuICAgKiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgcHJvbXB0IHRva2Vuc1xuICAgKiBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlIG51bWJlciBvZlxuICAgKiBwcm9tcHQgdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X3Byb21wdF90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFtNb2RlbF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tb2RlbHMpIHRvXG4gICAqIGJlIHVzZWQgdG8gZXhlY3V0ZSB0aGlzIHJ1bi4gSWYgYSB2YWx1ZSBpcyBwcm92aWRlZCBoZXJlLCBpdCB3aWxsIG92ZXJyaWRlIHRoZVxuICAgKiBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2lzdGFudC4gSWYgbm90LCB0aGUgbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgKiBhc3Npc3RhbnQgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgbW9kZWw/OlxuICAgIHwgKHN0cmluZyAmIHt9KVxuICAgIHwgJ2dwdC00bydcbiAgICB8ICdncHQtNG8tMjAyNC0wNS0xMydcbiAgICB8ICdncHQtNC10dXJibydcbiAgICB8ICdncHQtNC10dXJiby0yMDI0LTA0LTA5J1xuICAgIHwgJ2dwdC00LTAxMjUtcHJldmlldydcbiAgICB8ICdncHQtNC10dXJiby1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LTExMDYtcHJldmlldydcbiAgICB8ICdncHQtNC12aXNpb24tcHJldmlldydcbiAgICB8ICdncHQtNCdcbiAgICB8ICdncHQtNC0wMzE0J1xuICAgIHwgJ2dwdC00LTA2MTMnXG4gICAgfCAnZ3B0LTQtMzJrJ1xuICAgIHwgJ2dwdC00LTMyay0wMzE0J1xuICAgIHwgJ2dwdC00LTMyay0wNjEzJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8nXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xNmsnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0wNjEzJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTEwNidcbiAgICB8ICdncHQtMy41LXR1cmJvLTAxMjUnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xNmstMDYxMydcbiAgICB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAgICogW0dQVC00b10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzL2dwdC00byksXG4gICAqIFtHUFQtNCBUdXJib10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzL2dwdC00LXR1cmJvLWFuZC1ncHQtNCksXG4gICAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9vYmplY3RcIiB9YCBlbmFibGVzIEpTT04gbW9kZSwgd2hpY2ggZ3VhcmFudGVlcyB0aGVcbiAgICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gICAqXG4gICAqICoqSW1wb3J0YW50OioqIHdoZW4gdXNpbmcgSlNPTiBtb2RlLCB5b3UgKiptdXN0KiogYWxzbyBpbnN0cnVjdCB0aGUgbW9kZWwgdG9cbiAgICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICAgKiBnZW5lcmF0ZSBhbiB1bmVuZGluZyBzdHJlYW0gb2Ygd2hpdGVzcGFjZSB1bnRpbCB0aGUgZ2VuZXJhdGlvbiByZWFjaGVzIHRoZSB0b2tlblxuICAgKiBsaW1pdCwgcmVzdWx0aW5nIGluIGEgbG9uZy1ydW5uaW5nIGFuZCBzZWVtaW5nbHkgXCJzdHVja1wiIHJlcXVlc3QuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICAgKiBpbmRpY2F0ZXMgdGhlIGdlbmVyYXRpb24gZXhjZWVkZWQgYG1heF90b2tlbnNgIG9yIHRoZSBjb252ZXJzYXRpb24gZXhjZWVkZWQgdGhlXG4gICAqIG1heCBjb250ZXh0IGxlbmd0aC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86IFRocmVhZHNBUEkuQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgdG9vbCBpcyBjYWxsZWQgYnkgdGhlIG1vZGVsLiBgbm9uZWAgbWVhbnMgdGhlIG1vZGVsIHdpbGxcbiAgICogbm90IGNhbGwgYW55IHRvb2xzIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBpcyB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgKiBhbmQgbWVhbnMgdGhlIG1vZGVsIGNhbiBwaWNrIGJldHdlZW4gZ2VuZXJhdGluZyBhIG1lc3NhZ2Ugb3IgY2FsbGluZyBvbmUgb3IgbW9yZVxuICAgKiB0b29scy4gYHJlcXVpcmVkYCBtZWFucyB0aGUgbW9kZWwgbXVzdCBjYWxsIG9uZSBvciBtb3JlIHRvb2xzIGJlZm9yZSByZXNwb25kaW5nXG4gICAqIHRvIHRoZSB1c2VyLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciB0b29sIGxpa2UgYHtcInR5cGVcIjogXCJmaWxlX3NlYXJjaFwifWAgb3JcbiAgICogYHtcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifX1gIGZvcmNlcyB0aGUgbW9kZWwgdG9cbiAgICogY2FsbCB0aGF0IHRvb2wuXG4gICAqL1xuICB0b29sX2Nob2ljZT86IFRocmVhZHNBUEkuQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSB0b29scyB0aGUgYXNzaXN0YW50IGNhbiB1c2UgZm9yIHRoaXMgcnVuLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQXNzaXN0YW50VG9vbD4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICB0cnVuY2F0aW9uX3N0cmF0ZWd5PzogUnVuU3RyZWFtUGFyYW1zLlRydW5jYXRpb25TdHJhdGVneSB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuU3RyZWFtUGFyYW1zIHtcbiAgZXhwb3J0IGludGVyZmFjZSBBZGRpdGlvbmFsTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8TWVzc2FnZXNBUEkuTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJvbGUgb2YgdGhlIGVudGl0eSB0aGF0IGlzIGNyZWF0aW5nIHRoZSBtZXNzYWdlLiBBbGxvd2VkIHZhbHVlcyBpbmNsdWRlOlxuICAgICAqXG4gICAgICogLSBgdXNlcmA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBzZW50IGJ5IGFuIGFjdHVhbCB1c2VyIGFuZCBzaG91bGQgYmUgdXNlZCBpblxuICAgICAqICAgbW9zdCBjYXNlcyB0byByZXByZXNlbnQgdXNlci1nZW5lcmF0ZWQgbWVzc2FnZXMuXG4gICAgICogLSBgYXNzaXN0YW50YDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGdlbmVyYXRlZCBieSB0aGUgYXNzaXN0YW50LiBVc2UgdGhpc1xuICAgICAqICAgdmFsdWUgdG8gaW5zZXJ0IG1lc3NhZ2VzIGZyb20gdGhlIGFzc2lzdGFudCBpbnRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgZmlsZXMgYXR0YWNoZWQgdG8gdGhlIG1lc3NhZ2UsIGFuZCB0aGUgdG9vbHMgdGhleSBzaG91bGQgYmUgYWRkZWQgdG8uXG4gICAgICovXG4gICAgYXR0YWNobWVudHM/OiBBcnJheTxBZGRpdGlvbmFsTWVzc2FnZS5BdHRhY2htZW50PiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICovXG4gICAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgQWRkaXRpb25hbE1lc3NhZ2Uge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBhdHRhY2ggdG8gdGhlIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRvb2xzIHRvIGFkZCB0aGlzIGZpbGUgdG8uXG4gICAgICAgKi9cbiAgICAgIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXNzaXN0YW50c0FQSS5GaWxlU2VhcmNoVG9vbD47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRydW5jYXRpb25TdHJhdGVneSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRydW5jYXRpb24gc3RyYXRlZ3kgdG8gdXNlIGZvciB0aGUgdGhyZWFkLiBUaGUgZGVmYXVsdCBpcyBgYXV0b2AuIElmIHNldCB0b1xuICAgICAqIGBsYXN0X21lc3NhZ2VzYCwgdGhlIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCB0byB0aGUgbiBtb3N0IHJlY2VudCBtZXNzYWdlcyBpblxuICAgICAqIHRoZSB0aHJlYWQuIFdoZW4gc2V0IHRvIGBhdXRvYCwgbWVzc2FnZXMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdGhyZWFkIHdpbGwgYmVcbiAgICAgKiBkcm9wcGVkIHRvIGZpdCB0aGUgY29udGV4dCBsZW5ndGggb2YgdGhlIG1vZGVsLCBgbWF4X3Byb21wdF90b2tlbnNgLlxuICAgICAqL1xuICAgIHR5cGU6ICdhdXRvJyB8ICdsYXN0X21lc3NhZ2VzJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbW9zdCByZWNlbnQgbWVzc2FnZXMgZnJvbSB0aGUgdGhyZWFkIHdoZW4gY29uc3RydWN0aW5nIHRoZSBjb250ZXh0XG4gICAgICogZm9yIHRoZSBydW4uXG4gICAgICovXG4gICAgbGFzdF9tZXNzYWdlcz86IG51bWJlciB8IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXMgPVxuICB8IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nXG4gIHwgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0b29scyBmb3Igd2hpY2ggdGhlIG91dHB1dHMgYXJlIGJlaW5nIHN1Ym1pdHRlZC5cbiAgICovXG4gIHRvb2xfb3V0cHV0czogQXJyYXk8UnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXMuVG9vbE91dHB1dD47XG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgcmV0dXJucyBhIHN0cmVhbSBvZiBldmVudHMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoZSBSdW4gYXMgc2VydmVyLXNlbnRcbiAgICogZXZlbnRzLCB0ZXJtaW5hdGluZyB3aGVuIHRoZSBSdW4gZW50ZXJzIGEgdGVybWluYWwgc3RhdGUgd2l0aCBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqL1xuICBzdHJlYW0/OiBib29sZWFuIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtcyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbE91dHB1dCB7XG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dCBvZiB0aGUgdG9vbCBjYWxsIHRvIGJlIHN1Ym1pdHRlZCB0byBjb250aW51ZSB0aGUgcnVuLlxuICAgICAqL1xuICAgIG91dHB1dD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsIGluIHRoZSBgcmVxdWlyZWRfYWN0aW9uYCBvYmplY3Qgd2l0aGluIHRoZSBydW4gb2JqZWN0XG4gICAgICogdGhlIG91dHB1dCBpcyBiZWluZyBzdWJtaXR0ZWQgZm9yLlxuICAgICAqL1xuICAgIHRvb2xfY2FsbF9pZD86IHN0cmluZztcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nID0gUnVuc0FQSS5SdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc05vblN0cmVhbWluZztcbiAgZXhwb3J0IHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmcgPSBSdW5zQVBJLlJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nIGV4dGVuZHMgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgcmV0dXJucyBhIHN0cmVhbSBvZiBldmVudHMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoZSBSdW4gYXMgc2VydmVyLXNlbnRcbiAgICogZXZlbnRzLCB0ZXJtaW5hdGluZyB3aGVuIHRoZSBSdW4gZW50ZXJzIGEgdGVybWluYWwgc3RhdGUgd2l0aCBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqL1xuICBzdHJlYW0/OiBmYWxzZSB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmcgZXh0ZW5kcyBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogSWYgYHRydWVgLCByZXR1cm5zIGEgc3RyZWFtIG9mIGV2ZW50cyB0aGF0IGhhcHBlbiBkdXJpbmcgdGhlIFJ1biBhcyBzZXJ2ZXItc2VudFxuICAgKiBldmVudHMsIHRlcm1pbmF0aW5nIHdoZW4gdGhlIFJ1biBlbnRlcnMgYSB0ZXJtaW5hbCBzdGF0ZSB3aXRoIGEgYGRhdGE6IFtET05FXWBcbiAgICogbWVzc2FnZS5cbiAgICovXG4gIHN0cmVhbTogdHJ1ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSdW5TdWJtaXRUb29sT3V0cHV0c0FuZFBvbGxQYXJhbXMge1xuICAvKipcbiAgICogQSBsaXN0IG9mIHRvb2xzIGZvciB3aGljaCB0aGUgb3V0cHV0cyBhcmUgYmVpbmcgc3VibWl0dGVkLlxuICAgKi9cbiAgdG9vbF9vdXRwdXRzOiBBcnJheTxSdW5TdWJtaXRUb29sT3V0cHV0c0FuZFBvbGxQYXJhbXMuVG9vbE91dHB1dD47XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuU3VibWl0VG9vbE91dHB1dHNBbmRQb2xsUGFyYW1zIHtcbiAgZXhwb3J0IGludGVyZmFjZSBUb29sT3V0cHV0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0IG9mIHRoZSB0b29sIGNhbGwgdG8gYmUgc3VibWl0dGVkIHRvIGNvbnRpbnVlIHRoZSBydW4uXG4gICAgICovXG4gICAgb3V0cHV0Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwgaW4gdGhlIGByZXF1aXJlZF9hY3Rpb25gIG9iamVjdCB3aXRoaW4gdGhlIHJ1biBvYmplY3RcbiAgICAgKiB0aGUgb3V0cHV0IGlzIGJlaW5nIHN1Ym1pdHRlZCBmb3IuXG4gICAgICovXG4gICAgdG9vbF9jYWxsX2lkPzogc3RyaW5nO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuU3VibWl0VG9vbE91dHB1dHNTdHJlYW1QYXJhbXMge1xuICAvKipcbiAgICogQSBsaXN0IG9mIHRvb2xzIGZvciB3aGljaCB0aGUgb3V0cHV0cyBhcmUgYmVpbmcgc3VibWl0dGVkLlxuICAgKi9cbiAgdG9vbF9vdXRwdXRzOiBBcnJheTxSdW5TdWJtaXRUb29sT3V0cHV0c1N0cmVhbVBhcmFtcy5Ub29sT3V0cHV0Pjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSdW5TdWJtaXRUb29sT3V0cHV0c1N0cmVhbVBhcmFtcyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbE91dHB1dCB7XG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dCBvZiB0aGUgdG9vbCBjYWxsIHRvIGJlIHN1Ym1pdHRlZCB0byBjb250aW51ZSB0aGUgcnVuLlxuICAgICAqL1xuICAgIG91dHB1dD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsIGluIHRoZSBgcmVxdWlyZWRfYWN0aW9uYCBvYmplY3Qgd2l0aGluIHRoZSBydW4gb2JqZWN0XG4gICAgICogdGhlIG91dHB1dCBpcyBiZWluZyBzdWJtaXR0ZWQgZm9yLlxuICAgICAqL1xuICAgIHRvb2xfY2FsbF9pZD86IHN0cmluZztcbiAgfVxufVxuXG5SdW5zLlJ1bnNQYWdlID0gUnVuc1BhZ2U7XG5SdW5zLlN0ZXBzID0gU3RlcHM7XG5SdW5zLlJ1blN0ZXBzUGFnZSA9IFJ1blN0ZXBzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFJ1bnMge1xuICBleHBvcnQge1xuICAgIHR5cGUgUmVxdWlyZWRBY3Rpb25GdW5jdGlvblRvb2xDYWxsIGFzIFJlcXVpcmVkQWN0aW9uRnVuY3Rpb25Ub29sQ2FsbCxcbiAgICB0eXBlIFJ1biBhcyBSdW4sXG4gICAgdHlwZSBSdW5TdGF0dXMgYXMgUnVuU3RhdHVzLFxuICAgIFJ1bnNQYWdlIGFzIFJ1bnNQYWdlLFxuICAgIHR5cGUgUnVuQ3JlYXRlUGFyYW1zIGFzIFJ1bkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIFJ1bkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBhcyBSdW5DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmcgYXMgUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICAgIHR5cGUgUnVuVXBkYXRlUGFyYW1zIGFzIFJ1blVwZGF0ZVBhcmFtcyxcbiAgICB0eXBlIFJ1bkxpc3RQYXJhbXMgYXMgUnVuTGlzdFBhcmFtcyxcbiAgICB0eXBlIFJ1bkNyZWF0ZUFuZFBvbGxQYXJhbXMsXG4gICAgdHlwZSBSdW5DcmVhdGVBbmRTdHJlYW1QYXJhbXMsXG4gICAgdHlwZSBSdW5TdHJlYW1QYXJhbXMsXG4gICAgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtcyBhcyBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtcyxcbiAgICB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nIGFzIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmcgYXMgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmcsXG4gICAgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c0FuZFBvbGxQYXJhbXMsXG4gICAgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c1N0cmVhbVBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIFN0ZXBzIGFzIFN0ZXBzLFxuICAgIHR5cGUgQ29kZUludGVycHJldGVyTG9ncyBhcyBDb2RlSW50ZXJwcmV0ZXJMb2dzLFxuICAgIHR5cGUgQ29kZUludGVycHJldGVyT3V0cHV0SW1hZ2UgYXMgQ29kZUludGVycHJldGVyT3V0cHV0SW1hZ2UsXG4gICAgdHlwZSBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbCBhcyBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbCxcbiAgICB0eXBlIENvZGVJbnRlcnByZXRlclRvb2xDYWxsRGVsdGEgYXMgQ29kZUludGVycHJldGVyVG9vbENhbGxEZWx0YSxcbiAgICB0eXBlIEZpbGVTZWFyY2hUb29sQ2FsbCBhcyBGaWxlU2VhcmNoVG9vbENhbGwsXG4gICAgdHlwZSBGaWxlU2VhcmNoVG9vbENhbGxEZWx0YSBhcyBGaWxlU2VhcmNoVG9vbENhbGxEZWx0YSxcbiAgICB0eXBlIEZ1bmN0aW9uVG9vbENhbGwgYXMgRnVuY3Rpb25Ub29sQ2FsbCxcbiAgICB0eXBlIEZ1bmN0aW9uVG9vbENhbGxEZWx0YSBhcyBGdW5jdGlvblRvb2xDYWxsRGVsdGEsXG4gICAgdHlwZSBNZXNzYWdlQ3JlYXRpb25TdGVwRGV0YWlscyBhcyBNZXNzYWdlQ3JlYXRpb25TdGVwRGV0YWlscyxcbiAgICB0eXBlIFJ1blN0ZXAgYXMgUnVuU3RlcCxcbiAgICB0eXBlIFJ1blN0ZXBEZWx0YSBhcyBSdW5TdGVwRGVsdGEsXG4gICAgdHlwZSBSdW5TdGVwRGVsdGFFdmVudCBhcyBSdW5TdGVwRGVsdGFFdmVudCxcbiAgICB0eXBlIFJ1blN0ZXBEZWx0YU1lc3NhZ2VEZWx0YSBhcyBSdW5TdGVwRGVsdGFNZXNzYWdlRGVsdGEsXG4gICAgdHlwZSBSdW5TdGVwSW5jbHVkZSBhcyBSdW5TdGVwSW5jbHVkZSxcbiAgICB0eXBlIFRvb2xDYWxsIGFzIFRvb2xDYWxsLFxuICAgIHR5cGUgVG9vbENhbGxEZWx0YSBhcyBUb29sQ2FsbERlbHRhLFxuICAgIHR5cGUgVG9vbENhbGxEZWx0YU9iamVjdCBhcyBUb29sQ2FsbERlbHRhT2JqZWN0LFxuICAgIHR5cGUgVG9vbENhbGxzU3RlcERldGFpbHMgYXMgVG9vbENhbGxzU3RlcERldGFpbHMsXG4gICAgUnVuU3RlcHNQYWdlIGFzIFJ1blN0ZXBzUGFnZSxcbiAgICB0eXBlIFN0ZXBSZXRyaWV2ZVBhcmFtcyBhcyBTdGVwUmV0cmlldmVQYXJhbXMsXG4gICAgdHlwZSBTdGVwTGlzdFBhcmFtcyBhcyBTdGVwTGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCB7IEFzc2lzdGFudFN0cmVhbSwgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zQmFzZVN0cmVhbSB9IGZyb20gJy4uLy4uLy4uL2xpYi9Bc3Npc3RhbnRTdHJlYW0nO1xuaW1wb3J0IHsgQVBJUHJvbWlzZSB9IGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIFRocmVhZHNBUEkgZnJvbSAnLi90aHJlYWRzJztcbmltcG9ydCAqIGFzIFNoYXJlZCBmcm9tICcuLi8uLi9zaGFyZWQnO1xuaW1wb3J0ICogYXMgQXNzaXN0YW50c0FQSSBmcm9tICcuLi9hc3Npc3RhbnRzJztcbmltcG9ydCAqIGFzIENoYXRBUEkgZnJvbSAnLi4vLi4vY2hhdC9jaGF0JztcbmltcG9ydCAqIGFzIE1lc3NhZ2VzQVBJIGZyb20gJy4vbWVzc2FnZXMnO1xuaW1wb3J0IHtcbiAgQW5ub3RhdGlvbixcbiAgQW5ub3RhdGlvbkRlbHRhLFxuICBGaWxlQ2l0YXRpb25Bbm5vdGF0aW9uLFxuICBGaWxlQ2l0YXRpb25EZWx0YUFubm90YXRpb24sXG4gIEZpbGVQYXRoQW5ub3RhdGlvbixcbiAgRmlsZVBhdGhEZWx0YUFubm90YXRpb24sXG4gIEltYWdlRmlsZSxcbiAgSW1hZ2VGaWxlQ29udGVudEJsb2NrLFxuICBJbWFnZUZpbGVEZWx0YSxcbiAgSW1hZ2VGaWxlRGVsdGFCbG9jayxcbiAgSW1hZ2VVUkwsXG4gIEltYWdlVVJMQ29udGVudEJsb2NrLFxuICBJbWFnZVVSTERlbHRhLFxuICBJbWFnZVVSTERlbHRhQmxvY2ssXG4gIE1lc3NhZ2UgYXMgTWVzc2FnZXNBUElNZXNzYWdlLFxuICBNZXNzYWdlQ29udGVudCxcbiAgTWVzc2FnZUNvbnRlbnREZWx0YSxcbiAgTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0sXG4gIE1lc3NhZ2VDcmVhdGVQYXJhbXMsXG4gIE1lc3NhZ2VEZWxldGVkLFxuICBNZXNzYWdlRGVsdGEsXG4gIE1lc3NhZ2VEZWx0YUV2ZW50LFxuICBNZXNzYWdlTGlzdFBhcmFtcyxcbiAgTWVzc2FnZVVwZGF0ZVBhcmFtcyxcbiAgTWVzc2FnZXMsXG4gIE1lc3NhZ2VzUGFnZSxcbiAgUmVmdXNhbENvbnRlbnRCbG9jayxcbiAgUmVmdXNhbERlbHRhQmxvY2ssXG4gIFRleHQsXG4gIFRleHRDb250ZW50QmxvY2ssXG4gIFRleHRDb250ZW50QmxvY2tQYXJhbSxcbiAgVGV4dERlbHRhLFxuICBUZXh0RGVsdGFCbG9jayxcbn0gZnJvbSAnLi9tZXNzYWdlcyc7XG5pbXBvcnQgKiBhcyBWZWN0b3JTdG9yZXNBUEkgZnJvbSAnLi4vdmVjdG9yLXN0b3Jlcy92ZWN0b3Itc3RvcmVzJztcbmltcG9ydCAqIGFzIFJ1bnNBUEkgZnJvbSAnLi9ydW5zL3J1bnMnO1xuaW1wb3J0IHtcbiAgUmVxdWlyZWRBY3Rpb25GdW5jdGlvblRvb2xDYWxsLFxuICBSdW4sXG4gIFJ1bkNyZWF0ZUFuZFBvbGxQYXJhbXMsXG4gIFJ1bkNyZWF0ZUFuZFN0cmVhbVBhcmFtcyxcbiAgUnVuQ3JlYXRlUGFyYW1zLFxuICBSdW5DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gIFJ1bkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgUnVuTGlzdFBhcmFtcyxcbiAgUnVuU3RhdHVzLFxuICBSdW5TdHJlYW1QYXJhbXMsXG4gIFJ1blN1Ym1pdFRvb2xPdXRwdXRzQW5kUG9sbFBhcmFtcyxcbiAgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXMsXG4gIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nLFxuICBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbWluZyxcbiAgUnVuU3VibWl0VG9vbE91dHB1dHNTdHJlYW1QYXJhbXMsXG4gIFJ1blVwZGF0ZVBhcmFtcyxcbiAgUnVucyxcbiAgUnVuc1BhZ2UsXG59IGZyb20gJy4vcnVucy9ydW5zJztcbmltcG9ydCB7IFN0cmVhbSB9IGZyb20gJy4uLy4uLy4uL3N0cmVhbWluZyc7XG5cbmV4cG9ydCBjbGFzcyBUaHJlYWRzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICBydW5zOiBSdW5zQVBJLlJ1bnMgPSBuZXcgUnVuc0FQSS5SdW5zKHRoaXMuX2NsaWVudCk7XG4gIG1lc3NhZ2VzOiBNZXNzYWdlc0FQSS5NZXNzYWdlcyA9IG5ldyBNZXNzYWdlc0FQSS5NZXNzYWdlcyh0aGlzLl9jbGllbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0aHJlYWQuXG4gICAqL1xuICBjcmVhdGUoYm9keT86IFRocmVhZENyZWF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8VGhyZWFkPjtcbiAgY3JlYXRlKG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFRocmVhZD47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBUaHJlYWRDcmVhdGVQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxUaHJlYWQ+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhib2R5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHt9LCBib2R5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvdGhyZWFkcycsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSB0aHJlYWQuXG4gICAqL1xuICByZXRyaWV2ZSh0aHJlYWRJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxUaHJlYWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL3RocmVhZHMvJHt0aHJlYWRJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZmllcyBhIHRocmVhZC5cbiAgICovXG4gIHVwZGF0ZSh0aHJlYWRJZDogc3RyaW5nLCBib2R5OiBUaHJlYWRVcGRhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFRocmVhZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3RocmVhZHMvJHt0aHJlYWRJZH1gLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgdGhyZWFkLlxuICAgKi9cbiAgZGVsKHRocmVhZElkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFRocmVhZERlbGV0ZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL3RocmVhZHMvJHt0aHJlYWRJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0aHJlYWQgYW5kIHJ1biBpdCBpbiBvbmUgcmVxdWVzdC5cbiAgICovXG4gIGNyZWF0ZUFuZFJ1bihcbiAgICBib2R5OiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8UnVuc0FQSS5SdW4+O1xuICBjcmVhdGVBbmRSdW4oXG4gICAgYm9keTogVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50Pj47XG4gIGNyZWF0ZUFuZFJ1bihcbiAgICBib2R5OiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50PiB8IFJ1bnNBUEkuUnVuPjtcbiAgY3JlYXRlQW5kUnVuKFxuICAgIGJvZHk6IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxSdW5zQVBJLlJ1bj4gfCBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50Pj4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL3RocmVhZHMvcnVucycsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgIHN0cmVhbTogYm9keS5zdHJlYW0gPz8gZmFsc2UsXG4gICAgfSkgYXMgQVBJUHJvbWlzZTxSdW5zQVBJLlJ1bj4gfCBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50Pj47XG4gIH1cblxuICAvKipcbiAgICogQSBoZWxwZXIgdG8gY3JlYXRlIGEgdGhyZWFkLCBzdGFydCBhIHJ1biBhbmQgdGhlbiBwb2xsIGZvciBhIHRlcm1pbmFsIHN0YXRlLlxuICAgKiBNb3JlIGluZm9ybWF0aW9uIG9uIFJ1biBsaWZlY3ljbGVzIGNhbiBiZSBmb3VuZCBoZXJlOlxuICAgKiBodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL2hvdy1pdC13b3Jrcy9ydW5zLWFuZC1ydW4tc3RlcHNcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUFuZFJ1blBvbGwoXG4gICAgYm9keTogVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zICYgeyBwb2xsSW50ZXJ2YWxNcz86IG51bWJlciB9LFxuICApOiBQcm9taXNlPFRocmVhZHMuUnVuPiB7XG4gICAgY29uc3QgcnVuID0gYXdhaXQgdGhpcy5jcmVhdGVBbmRSdW4oYm9keSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucnVucy5wb2xsKHJ1bi50aHJlYWRfaWQsIHJ1bi5pZCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGhyZWFkIGFuZCBzdHJlYW0gdGhlIHJ1biBiYWNrXG4gICAqL1xuICBjcmVhdGVBbmRSdW5TdHJlYW0oXG4gICAgYm9keTogVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zQmFzZVN0cmVhbSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQXNzaXN0YW50U3RyZWFtIHtcbiAgICByZXR1cm4gQXNzaXN0YW50U3RyZWFtLmNyZWF0ZVRocmVhZEFzc2lzdGFudFN0cmVhbShib2R5LCB0aGlzLl9jbGllbnQuYmV0YS50aHJlYWRzLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNG8pLFxuICogW0dQVC00IFR1cmJvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTQtdHVyYm8tYW5kLWdwdC00KSxcbiAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gKlxuICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX3NjaGVtYVwiLCBcImpzb25fc2NoZW1hXCI6IHsuLi59IH1gIGVuYWJsZXMgU3RydWN0dXJlZFxuICogT3V0cHV0cyB3aGljaCBlbnN1cmVzIHRoZSBtb2RlbCB3aWxsIG1hdGNoIHlvdXIgc3VwcGxpZWQgSlNPTiBzY2hlbWEuIExlYXJuIG1vcmVcbiAqIGluIHRoZVxuICogW1N0cnVjdHVyZWQgT3V0cHV0cyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3N0cnVjdHVyZWQtb3V0cHV0cykuXG4gKlxuICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBlbnN1cmVzIHRoZVxuICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gKlxuICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICovXG5leHBvcnQgdHlwZSBBc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiA9XG4gIHwgJ2F1dG8nXG4gIHwgU2hhcmVkLlJlc3BvbnNlRm9ybWF0VGV4dFxuICB8IFNoYXJlZC5SZXNwb25zZUZvcm1hdEpTT05PYmplY3RcbiAgfCBTaGFyZWQuUmVzcG9uc2VGb3JtYXRKU09OU2NoZW1hO1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIHRvb2wgdGhlIG1vZGVsIHNob3VsZCB1c2UuIFVzZSB0byBmb3JjZSB0aGUgbW9kZWwgdG8gY2FsbCBhIHNwZWNpZmljXG4gKiB0b29sLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFzc2lzdGFudFRvb2xDaG9pY2Uge1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wuIElmIHR5cGUgaXMgYGZ1bmN0aW9uYCwgdGhlIGZ1bmN0aW9uIG5hbWUgbXVzdCBiZSBzZXRcbiAgICovXG4gIHR5cGU6ICdmdW5jdGlvbicgfCAnY29kZV9pbnRlcnByZXRlcicgfCAnZmlsZV9zZWFyY2gnO1xuXG4gIGZ1bmN0aW9uPzogQXNzaXN0YW50VG9vbENob2ljZUZ1bmN0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFzc2lzdGFudFRvb2xDaG9pY2VGdW5jdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICovXG4gIG5hbWU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBDb250cm9scyB3aGljaCAoaWYgYW55KSB0b29sIGlzIGNhbGxlZCBieSB0aGUgbW9kZWwuIGBub25lYCBtZWFucyB0aGUgbW9kZWwgd2lsbFxuICogbm90IGNhbGwgYW55IHRvb2xzIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBpcyB0aGUgZGVmYXVsdCB2YWx1ZVxuICogYW5kIG1lYW5zIHRoZSBtb2RlbCBjYW4gcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yIGNhbGxpbmcgb25lIG9yIG1vcmVcbiAqIHRvb2xzLiBgcmVxdWlyZWRgIG1lYW5zIHRoZSBtb2RlbCBtdXN0IGNhbGwgb25lIG9yIG1vcmUgdG9vbHMgYmVmb3JlIHJlc3BvbmRpbmdcbiAqIHRvIHRoZSB1c2VyLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciB0b29sIGxpa2UgYHtcInR5cGVcIjogXCJmaWxlX3NlYXJjaFwifWAgb3JcbiAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gKiBjYWxsIHRoYXQgdG9vbC5cbiAqL1xuZXhwb3J0IHR5cGUgQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiA9ICdub25lJyB8ICdhdXRvJyB8ICdyZXF1aXJlZCcgfCBBc3Npc3RhbnRUb29sQ2hvaWNlO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0aHJlYWQgdGhhdCBjb250YWluc1xuICogW21lc3NhZ2VzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUaHJlYWQge1xuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSB0aHJlYWQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhOiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYHRocmVhZGAuXG4gICAqL1xuICBvYmplY3Q6ICd0aHJlYWQnO1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICovXG4gIHRvb2xfcmVzb3VyY2VzOiBUaHJlYWQuVG9vbFJlc291cmNlcyB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVGhyZWFkIHtcbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYXNzaXN0YW50J3MgdG9vbHMgaW4gdGhpc1xuICAgKiB0aHJlYWQuIFRoZSByZXNvdXJjZXMgYXJlIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGVcbiAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgKiB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgSURzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzXG4gICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2wuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGVcbiAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgKiBhdHRhY2hlZCB0byB0aGlzIHRocmVhZC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvciBzdG9yZSBhdHRhY2hlZCB0b1xuICAgICAgICogdGhlIHRocmVhZC5cbiAgICAgICAqL1xuICAgICAgdmVjdG9yX3N0b3JlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkRGVsZXRlZCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgZGVsZXRlZDogYm9vbGVhbjtcblxuICBvYmplY3Q6ICd0aHJlYWQuZGVsZXRlZCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBbbWVzc2FnZXNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMpIHRvXG4gICAqIHN0YXJ0IHRoZSB0aHJlYWQgd2l0aC5cbiAgICovXG4gIG1lc3NhZ2VzPzogQXJyYXk8VGhyZWFkQ3JlYXRlUGFyYW1zLk1lc3NhZ2U+O1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICovXG4gIHRvb2xfcmVzb3VyY2VzPzogVGhyZWFkQ3JlYXRlUGFyYW1zLlRvb2xSZXNvdXJjZXMgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFRocmVhZENyZWF0ZVBhcmFtcyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8TWVzc2FnZXNBUEkuTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJvbGUgb2YgdGhlIGVudGl0eSB0aGF0IGlzIGNyZWF0aW5nIHRoZSBtZXNzYWdlLiBBbGxvd2VkIHZhbHVlcyBpbmNsdWRlOlxuICAgICAqXG4gICAgICogLSBgdXNlcmA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBzZW50IGJ5IGFuIGFjdHVhbCB1c2VyIGFuZCBzaG91bGQgYmUgdXNlZCBpblxuICAgICAqICAgbW9zdCBjYXNlcyB0byByZXByZXNlbnQgdXNlci1nZW5lcmF0ZWQgbWVzc2FnZXMuXG4gICAgICogLSBgYXNzaXN0YW50YDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGdlbmVyYXRlZCBieSB0aGUgYXNzaXN0YW50LiBVc2UgdGhpc1xuICAgICAqICAgdmFsdWUgdG8gaW5zZXJ0IG1lc3NhZ2VzIGZyb20gdGhlIGFzc2lzdGFudCBpbnRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgZmlsZXMgYXR0YWNoZWQgdG8gdGhlIG1lc3NhZ2UsIGFuZCB0aGUgdG9vbHMgdGhleSBzaG91bGQgYmUgYWRkZWQgdG8uXG4gICAgICovXG4gICAgYXR0YWNobWVudHM/OiBBcnJheTxNZXNzYWdlLkF0dGFjaG1lbnQ+IHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgKi9cbiAgICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBNZXNzYWdlIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIEF0dGFjaG1lbnQge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gYXR0YWNoIHRvIHRoZSBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkPzogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0b29scyB0byBhZGQgdGhpcyBmaWxlIHRvLlxuICAgICAgICovXG4gICAgICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEF0dGFjaG1lbnQuRmlsZVNlYXJjaD47XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBBdHRhY2htZW50IHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0b29sIGJlaW5nIGRlZmluZWQ6IGBmaWxlX3NlYXJjaGBcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdmaWxlX3NlYXJjaCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYXNzaXN0YW50J3MgdG9vbHMgaW4gdGhpc1xuICAgKiB0aHJlYWQuIFRoZSByZXNvdXJjZXMgYXJlIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGVcbiAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgKiB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgSURzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzXG4gICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2wuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGVcbiAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgKiBhdHRhY2hlZCB0byB0aGlzIHRocmVhZC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvciBzdG9yZSBhdHRhY2hlZCB0b1xuICAgICAgICogdGhlIHRocmVhZC5cbiAgICAgICAqL1xuICAgICAgdmVjdG9yX3N0b3JlX2lkcz86IEFycmF5PHN0cmluZz47XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBoZWxwZXIgdG8gY3JlYXRlIGFcbiAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgKiB3aXRoIGZpbGVfaWRzIGFuZCBhdHRhY2ggaXQgdG8gdGhpcyB0aHJlYWQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3JcbiAgICAgICAqIHN0b3JlIGF0dGFjaGVkIHRvIHRoZSB0aHJlYWQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZXM/OiBBcnJheTxGaWxlU2VhcmNoLlZlY3RvclN0b3JlPjtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIEZpbGVTZWFyY2gge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2h1bmtpbmcgc3RyYXRlZ3kgdXNlZCB0byBjaHVuayB0aGUgZmlsZShzKS4gSWYgbm90IHNldCwgd2lsbCB1c2UgdGhlIGBhdXRvYFxuICAgICAgICAgKiBzdHJhdGVneS4gT25seSBhcHBsaWNhYmxlIGlmIGBmaWxlX2lkc2AgaXMgbm9uLWVtcHR5LlxuICAgICAgICAgKi9cbiAgICAgICAgY2h1bmtpbmdfc3RyYXRlZ3k/OiBWZWN0b3JTdG9yZXNBUEkuRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgdG9cbiAgICAgICAgICogYWRkIHRvIHRoZSB2ZWN0b3Igc3RvcmUuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMTAwMDAgZmlsZXMgaW4gYSB2ZWN0b3JcbiAgICAgICAgICogc3RvcmUuXG4gICAgICAgICAqL1xuICAgICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB2ZWN0b3Igc3RvcmUuIFRoaXMgY2FuIGJlXG4gICAgICAgICAqIHVzZWZ1bCBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2ZWN0b3Igc3RvcmUgaW4gYSBzdHJ1Y3R1cmVkXG4gICAgICAgICAqIGZvcm1hdC4gS2V5cyBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bVxuICAgICAgICAgKiBvZiA1MTIgY2hhcmFjdGVycyBsb25nLlxuICAgICAgICAgKi9cbiAgICAgICAgbWV0YWRhdGE/OiB1bmtub3duO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRocmVhZFVwZGF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICovXG4gIHRvb2xfcmVzb3VyY2VzPzogVGhyZWFkVXBkYXRlUGFyYW1zLlRvb2xSZXNvdXJjZXMgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFRocmVhZFVwZGF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgY29kZV9pbnRlcnByZXRlcj86IFRvb2xSZXNvdXJjZXMuQ29kZUludGVycHJldGVyO1xuXG4gICAgZmlsZV9zZWFyY2g/OiBUb29sUmVzb3VyY2VzLkZpbGVTZWFyY2g7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgbWFkZVxuICAgICAgICogYXZhaWxhYmxlIHRvIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlc1xuICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyB0aHJlYWQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAqIHRoZSB0aHJlYWQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXMgPVxuICB8IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc05vblN0cmVhbWluZ1xuICB8IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc1N0cmVhbWluZztcblxuZXhwb3J0IGludGVyZmFjZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGVcbiAgICogW2Fzc2lzdGFudF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSB0byB1c2UgdG9cbiAgICogZXhlY3V0ZSB0aGlzIHJ1bi5cbiAgICovXG4gIGFzc2lzdGFudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBzeXN0ZW0gbWVzc2FnZSBvZiB0aGUgYXNzaXN0YW50LiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlXG4gICAqIHJ1bi4gVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zXG4gICAqIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGUgbnVtYmVyIG9mXG4gICAqIGNvbXBsZXRpb24gdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X2NvbXBsZXRpb25fdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHByb21wdCB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1bi5cbiAgICogVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIHByb21wdCB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogcHJvbXB0IHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLiBTZWVcbiAgICogYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9wcm9tcHRfdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBbTW9kZWxdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzKSB0b1xuICAgKiBiZSB1c2VkIHRvIGV4ZWN1dGUgdGhpcyBydW4uIElmIGEgdmFsdWUgaXMgcHJvdmlkZWQgaGVyZSwgaXQgd2lsbCBvdmVycmlkZSB0aGVcbiAgICogbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3Npc3RhbnQuIElmIG5vdCwgdGhlIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICogYXNzaXN0YW50IHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIG1vZGVsPzogKHN0cmluZyAmIHt9KSB8IENoYXRBUEkuQ2hhdE1vZGVsIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGVcbiAgICogW3BhcmFsbGVsIGZ1bmN0aW9uIGNhbGxpbmddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9mdW5jdGlvbi1jYWxsaW5nI2NvbmZpZ3VyaW5nLXBhcmFsbGVsLWZ1bmN0aW9uLWNhbGxpbmcpXG4gICAqIGR1cmluZyB0b29sIHVzZS5cbiAgICovXG4gIHBhcmFsbGVsX3Rvb2xfY2FsbHM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gICAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNG8pLFxuICAgKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICAgKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fc2NoZW1hXCIsIFwianNvbl9zY2hlbWFcIjogey4uLn0gfWAgZW5hYmxlcyBTdHJ1Y3R1cmVkXG4gICAqIE91dHB1dHMgd2hpY2ggZW5zdXJlcyB0aGUgbW9kZWwgd2lsbCBtYXRjaCB5b3VyIHN1cHBsaWVkIEpTT04gc2NoZW1hLiBMZWFybiBtb3JlXG4gICAqIGluIHRoZVxuICAgKiBbU3RydWN0dXJlZCBPdXRwdXRzIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc3RydWN0dXJlZC1vdXRwdXRzKS5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBlbnN1cmVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHJldHVybnMgYSBzdHJlYW0gb2YgZXZlbnRzIHRoYXQgaGFwcGVuIGR1cmluZyB0aGUgUnVuIGFzIHNlcnZlci1zZW50XG4gICAqIGV2ZW50cywgdGVybWluYXRpbmcgd2hlbiB0aGUgUnVuIGVudGVycyBhIHRlcm1pbmFsIHN0YXRlIHdpdGggYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKi9cbiAgc3RyZWFtPzogYm9vbGVhbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoYXQgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdG8gdXNlLCBiZXR3ZWVuIDAgYW5kIDIuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbFxuICAgKiBtYWtlIHRoZSBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZVxuICAgKiBmb2N1c2VkIGFuZCBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJZiBubyB0aHJlYWQgaXMgcHJvdmlkZWQsIGFuIGVtcHR5IHRocmVhZCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqL1xuICB0aHJlYWQ/OiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXMuVGhyZWFkO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyB3aGljaCAoaWYgYW55KSB0b29sIGlzIGNhbGxlZCBieSB0aGUgbW9kZWwuIGBub25lYCBtZWFucyB0aGUgbW9kZWwgd2lsbFxuICAgKiBub3QgY2FsbCBhbnkgdG9vbHMgYW5kIGluc3RlYWQgZ2VuZXJhdGVzIGEgbWVzc2FnZS4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAqIGFuZCBtZWFucyB0aGUgbW9kZWwgY2FuIHBpY2sgYmV0d2VlbiBnZW5lcmF0aW5nIGEgbWVzc2FnZSBvciBjYWxsaW5nIG9uZSBvciBtb3JlXG4gICAqIHRvb2xzLiBgcmVxdWlyZWRgIG1lYW5zIHRoZSBtb2RlbCBtdXN0IGNhbGwgb25lIG9yIG1vcmUgdG9vbHMgYmVmb3JlIHJlc3BvbmRpbmdcbiAgICogdG8gdGhlIHVzZXIuIFNwZWNpZnlpbmcgYSBwYXJ0aWN1bGFyIHRvb2wgbGlrZSBge1widHlwZVwiOiBcImZpbGVfc2VhcmNoXCJ9YCBvclxuICAgKiBge1widHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIm15X2Z1bmN0aW9uXCJ9fWAgZm9yY2VzIHRoZSBtb2RlbCB0b1xuICAgKiBjYWxsIHRoYXQgdG9vbC5cbiAgICovXG4gIHRvb2xfY2hvaWNlPzogQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBhc3Npc3RhbnQncyB0b29scy4gVGhlIHJlc291cmNlcyBhcmVcbiAgICogc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlc1xuICAgKiBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZVxuICAgKiBJRHMuXG4gICAqL1xuICB0b29sX3Jlc291cmNlcz86IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtcy5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHRvb2xzIHRoZSBhc3Npc3RhbnQgY2FuIHVzZSBmb3IgdGhpcyBydW4uIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8XG4gICAgQXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXNzaXN0YW50c0FQSS5GaWxlU2VhcmNoVG9vbCB8IEFzc2lzdGFudHNBUEkuRnVuY3Rpb25Ub29sXG4gID4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICB0cnVuY2F0aW9uX3N0cmF0ZWd5PzogVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zLlRydW5jYXRpb25TdHJhdGVneSB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zIHtcbiAgLyoqXG4gICAqIElmIG5vIHRocmVhZCBpcyBwcm92aWRlZCwgYW4gZW1wdHkgdGhyZWFkIHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkIHtcbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgW21lc3NhZ2VzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzKSB0b1xuICAgICAqIHN0YXJ0IHRoZSB0aHJlYWQgd2l0aC5cbiAgICAgKi9cbiAgICBtZXNzYWdlcz86IEFycmF5PFRocmVhZC5NZXNzYWdlPjtcblxuICAgIC8qKlxuICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgKi9cbiAgICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBhc3Npc3RhbnQncyB0b29scyBpbiB0aGlzXG4gICAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgICAqIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBJRHMuXG4gICAgICovXG4gICAgdG9vbF9yZXNvdXJjZXM/OiBUaHJlYWQuVG9vbFJlc291cmNlcyB8IG51bGw7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRocmVhZCB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRleHQgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PE1lc3NhZ2VzQVBJLk1lc3NhZ2VDb250ZW50UGFydFBhcmFtPjtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcm9sZSBvZiB0aGUgZW50aXR5IHRoYXQgaXMgY3JlYXRpbmcgdGhlIG1lc3NhZ2UuIEFsbG93ZWQgdmFsdWVzIGluY2x1ZGU6XG4gICAgICAgKlxuICAgICAgICogLSBgdXNlcmA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBzZW50IGJ5IGFuIGFjdHVhbCB1c2VyIGFuZCBzaG91bGQgYmUgdXNlZCBpblxuICAgICAgICogICBtb3N0IGNhc2VzIHRvIHJlcHJlc2VudCB1c2VyLWdlbmVyYXRlZCBtZXNzYWdlcy5cbiAgICAgICAqIC0gYGFzc2lzdGFudGA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBnZW5lcmF0ZWQgYnkgdGhlIGFzc2lzdGFudC4gVXNlIHRoaXNcbiAgICAgICAqICAgdmFsdWUgdG8gaW5zZXJ0IG1lc3NhZ2VzIGZyb20gdGhlIGFzc2lzdGFudCBpbnRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICAgKi9cbiAgICAgIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byB0aGUgbWVzc2FnZSwgYW5kIHRoZSB0b29scyB0aGV5IHNob3VsZCBiZSBhZGRlZCB0by5cbiAgICAgICAqL1xuICAgICAgYXR0YWNobWVudHM/OiBBcnJheTxNZXNzYWdlLkF0dGFjaG1lbnQ+IHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAgICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICAgKi9cbiAgICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBNZXNzYWdlIHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gYXR0YWNoIHRvIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZV9pZD86IHN0cmluZztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvb2xzIHRvIGFkZCB0aGlzIGZpbGUgdG8uXG4gICAgICAgICAqL1xuICAgICAgICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEF0dGFjaG1lbnQuRmlsZVNlYXJjaD47XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydCBuYW1lc3BhY2UgQXR0YWNobWVudCB7XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIHR5cGUgb2YgdG9vbCBiZWluZyBkZWZpbmVkOiBgZmlsZV9zZWFyY2hgXG4gICAgICAgICAgICovXG4gICAgICAgICAgdHlwZTogJ2ZpbGVfc2VhcmNoJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYXNzaXN0YW50J3MgdG9vbHMgaW4gdGhpc1xuICAgICAqIHRocmVhZC4gVGhlIHJlc291cmNlcyBhcmUgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZVxuICAgICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICAgKiB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgSURzLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICAgIGZpbGVfc2VhcmNoPzogVG9vbFJlc291cmNlcy5GaWxlU2VhcmNoO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgICAqIGF2YWlsYWJsZSB0byB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMjAgZmlsZXNcbiAgICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlXG4gICAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgdGhyZWFkLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvXG4gICAgICAgICAqIHRoZSB0aHJlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB2ZWN0b3Jfc3RvcmVfaWRzPzogQXJyYXk8c3RyaW5nPjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBoZWxwZXIgdG8gY3JlYXRlIGFcbiAgICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAgICogd2l0aCBmaWxlX2lkcyBhbmQgYXR0YWNoIGl0IHRvIHRoaXMgdGhyZWFkLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yXG4gICAgICAgICAqIHN0b3JlIGF0dGFjaGVkIHRvIHRoZSB0aHJlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB2ZWN0b3Jfc3RvcmVzPzogQXJyYXk8RmlsZVNlYXJjaC5WZWN0b3JTdG9yZT47XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydCBuYW1lc3BhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmUge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBjaHVua2luZyBzdHJhdGVneSB1c2VkIHRvIGNodW5rIHRoZSBmaWxlKHMpLiBJZiBub3Qgc2V0LCB3aWxsIHVzZSB0aGUgYGF1dG9gXG4gICAgICAgICAgICogc3RyYXRlZ3kuIE9ubHkgYXBwbGljYWJsZSBpZiBgZmlsZV9pZHNgIGlzIG5vbi1lbXB0eS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjaHVua2luZ19zdHJhdGVneT86IFZlY3RvclN0b3Jlc0FQSS5GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgdG9cbiAgICAgICAgICAgKiBhZGQgdG8gdGhlIHZlY3RvciBzdG9yZS4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxMDAwMCBmaWxlcyBpbiBhIHZlY3RvclxuICAgICAgICAgICAqIHN0b3JlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB2ZWN0b3Igc3RvcmUuIFRoaXMgY2FuIGJlXG4gICAgICAgICAgICogdXNlZnVsIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZlY3RvciBzdG9yZSBpbiBhIHN0cnVjdHVyZWRcbiAgICAgICAgICAgKiBmb3JtYXQuIEtleXMgY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW1cbiAgICAgICAgICAgKiBvZiA1MTIgY2hhcmFjdGVycyBsb25nLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1ldGFkYXRhPzogdW5rbm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgdXNlZCBieSB0aGUgYXNzaXN0YW50J3MgdG9vbHMuIFRoZSByZXNvdXJjZXMgYXJlXG4gICAqIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXNcbiAgICogYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVcbiAgICogSURzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzXG4gICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2wuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSUQgb2YgdGhlXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyBhc3Npc3RhbnQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAqIHRoZSBhc3Npc3RhbnQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUcnVuY2F0aW9uU3RyYXRlZ3kge1xuICAgIC8qKlxuICAgICAqIFRoZSB0cnVuY2F0aW9uIHN0cmF0ZWd5IHRvIHVzZSBmb3IgdGhlIHRocmVhZC4gVGhlIGRlZmF1bHQgaXMgYGF1dG9gLiBJZiBzZXQgdG9cbiAgICAgKiBgbGFzdF9tZXNzYWdlc2AsIHRoZSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgdG8gdGhlIG4gbW9zdCByZWNlbnQgbWVzc2FnZXMgaW5cbiAgICAgKiB0aGUgdGhyZWFkLiBXaGVuIHNldCB0byBgYXV0b2AsIG1lc3NhZ2VzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHRocmVhZCB3aWxsIGJlXG4gICAgICogZHJvcHBlZCB0byBmaXQgdGhlIGNvbnRleHQgbGVuZ3RoIG9mIHRoZSBtb2RlbCwgYG1heF9wcm9tcHRfdG9rZW5zYC5cbiAgICAgKi9cbiAgICB0eXBlOiAnYXV0bycgfCAnbGFzdF9tZXNzYWdlcyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGZyb20gdGhlIHRocmVhZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgY29udGV4dFxuICAgICAqIGZvciB0aGUgcnVuLlxuICAgICAqL1xuICAgIGxhc3RfbWVzc2FnZXM/OiBudW1iZXIgfCBudWxsO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zTm9uU3RyZWFtaW5nID0gVGhyZWFkc0FQSS5UaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNOb25TdHJlYW1pbmc7XG4gIGV4cG9ydCB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc1N0cmVhbWluZyA9IFRocmVhZHNBUEkuVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zU3RyZWFtaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc05vblN0cmVhbWluZyBleHRlbmRzIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogSWYgYHRydWVgLCByZXR1cm5zIGEgc3RyZWFtIG9mIGV2ZW50cyB0aGF0IGhhcHBlbiBkdXJpbmcgdGhlIFJ1biBhcyBzZXJ2ZXItc2VudFxuICAgKiBldmVudHMsIHRlcm1pbmF0aW5nIHdoZW4gdGhlIFJ1biBlbnRlcnMgYSB0ZXJtaW5hbCBzdGF0ZSB3aXRoIGEgYGRhdGE6IFtET05FXWBcbiAgICogbWVzc2FnZS5cbiAgICovXG4gIHN0cmVhbT86IGZhbHNlIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNTdHJlYW1pbmcgZXh0ZW5kcyBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgcmV0dXJucyBhIHN0cmVhbSBvZiBldmVudHMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoZSBSdW4gYXMgc2VydmVyLXNlbnRcbiAgICogZXZlbnRzLCB0ZXJtaW5hdGluZyB3aGVuIHRoZSBSdW4gZW50ZXJzIGEgdGVybWluYWwgc3RhdGUgd2l0aCBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqL1xuICBzdHJlYW06IHRydWU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkQ3JlYXRlQW5kUnVuUG9sbFBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdG8gdXNlIHRvXG4gICAqIGV4ZWN1dGUgdGhpcyBydW4uXG4gICAqL1xuICBhc3Npc3RhbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgc3lzdGVtIG1lc3NhZ2Ugb2YgdGhlIGFzc2lzdGFudC4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zIHRoYXQgbWF5IGJlIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZVxuICAgKiBydW4uIFRoZSBydW4gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdXNlIG9ubHkgdGhlIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2Vuc1xuICAgKiBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlIG51bWJlciBvZlxuICAgKiBjb21wbGV0aW9uIHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLiBTZWVcbiAgICogYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9jb21wbGV0aW9uX3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zIHRoYXQgbWF5IGJlIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBydW4uXG4gICAqIFRoZSBydW4gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdXNlIG9ubHkgdGhlIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zXG4gICAqIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGUgbnVtYmVyIG9mXG4gICAqIHByb21wdCB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC4gU2VlXG4gICAqIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfcHJvbXB0X3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgW01vZGVsXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscykgdG9cbiAgICogYmUgdXNlZCB0byBleGVjdXRlIHRoaXMgcnVuLiBJZiBhIHZhbHVlIGlzIHByb3ZpZGVkIGhlcmUsIGl0IHdpbGwgb3ZlcnJpZGUgdGhlXG4gICAqIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzaXN0YW50LiBJZiBub3QsIHRoZSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAqIGFzc2lzdGFudCB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICBtb2RlbD86XG4gICAgfCAoc3RyaW5nICYge30pXG4gICAgfCAnZ3B0LTRvJ1xuICAgIHwgJ2dwdC00by0yMDI0LTA1LTEzJ1xuICAgIHwgJ2dwdC00LXR1cmJvJ1xuICAgIHwgJ2dwdC00LXR1cmJvLTIwMjQtMDQtMDknXG4gICAgfCAnZ3B0LTQtMDEyNS1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LXR1cmJvLXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtMTEwNi1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LXZpc2lvbi1wcmV2aWV3J1xuICAgIHwgJ2dwdC00J1xuICAgIHwgJ2dwdC00LTAzMTQnXG4gICAgfCAnZ3B0LTQtMDYxMydcbiAgICB8ICdncHQtNC0zMmsnXG4gICAgfCAnZ3B0LTQtMzJrLTAzMTQnXG4gICAgfCAnZ3B0LTQtMzJrLTA2MTMnXG4gICAgfCAnZ3B0LTMuNS10dXJibydcbiAgICB8ICdncHQtMy41LXR1cmJvLTE2aydcbiAgICB8ICdncHQtMy41LXR1cmJvLTA2MTMnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xMTA2J1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMDEyNSdcbiAgICB8ICdncHQtMy41LXR1cmJvLTE2ay0wNjEzJ1xuICAgIHwgbnVsbDtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBmb3JtYXQgdGhhdCB0aGUgbW9kZWwgbXVzdCBvdXRwdXQuIENvbXBhdGlibGUgd2l0aFxuICAgKiBbR1BULTRvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMvZ3B0LTRvKSxcbiAgICogW0dQVC00IFR1cmJvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMvZ3B0LTQtdHVyYm8tYW5kLWdwdC00KSxcbiAgICogYW5kIGFsbCBHUFQtMy41IFR1cmJvIG1vZGVscyBzaW5jZSBgZ3B0LTMuNS10dXJiby0xMTA2YC5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBndWFyYW50ZWVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogSWYgbm8gdGhyZWFkIGlzIHByb3ZpZGVkLCBhbiBlbXB0eSB0aHJlYWQgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgdGhyZWFkPzogVGhyZWFkQ3JlYXRlQW5kUnVuUG9sbFBhcmFtcy5UaHJlYWQ7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIHdoaWNoIChpZiBhbnkpIHRvb2wgaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC4gYG5vbmVgIG1lYW5zIHRoZSBtb2RlbCB3aWxsXG4gICAqIG5vdCBjYWxsIGFueSB0b29scyBhbmQgaW5zdGVhZCBnZW5lcmF0ZXMgYSBtZXNzYWdlLiBgYXV0b2AgaXMgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICogYW5kIG1lYW5zIHRoZSBtb2RlbCBjYW4gcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yIGNhbGxpbmcgb25lIG9yIG1vcmVcbiAgICogdG9vbHMuIGByZXF1aXJlZGAgbWVhbnMgdGhlIG1vZGVsIG11c3QgY2FsbCBvbmUgb3IgbW9yZSB0b29scyBiZWZvcmUgcmVzcG9uZGluZ1xuICAgKiB0byB0aGUgdXNlci4gU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgdG9vbCBsaWtlIGB7XCJ0eXBlXCI6IFwiZmlsZV9zZWFyY2hcIn1gIG9yXG4gICAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gICAqIGNhbGwgdGhhdCB0b29sLlxuICAgKi9cbiAgdG9vbF9jaG9pY2U/OiBBc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIGFzc2lzdGFudCdzIHRvb2xzLiBUaGUgcmVzb3VyY2VzIGFyZVxuICAgKiBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzXG4gICAqIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlXG4gICAqIElEcy5cbiAgICovXG4gIHRvb2xfcmVzb3VyY2VzPzogVGhyZWFkQ3JlYXRlQW5kUnVuUG9sbFBhcmFtcy5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHRvb2xzIHRoZSBhc3Npc3RhbnQgY2FuIHVzZSBmb3IgdGhpcyBydW4uIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8XG4gICAgQXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXNzaXN0YW50c0FQSS5GaWxlU2VhcmNoVG9vbCB8IEFzc2lzdGFudHNBUEkuRnVuY3Rpb25Ub29sXG4gID4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICB0cnVuY2F0aW9uX3N0cmF0ZWd5PzogVGhyZWFkQ3JlYXRlQW5kUnVuUG9sbFBhcmFtcy5UcnVuY2F0aW9uU3RyYXRlZ3kgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFRocmVhZENyZWF0ZUFuZFJ1blBvbGxQYXJhbXMge1xuICAvKipcbiAgICogSWYgbm8gdGhyZWFkIGlzIHByb3ZpZGVkLCBhbiBlbXB0eSB0aHJlYWQgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWQge1xuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBbbWVzc2FnZXNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMpIHRvXG4gICAgICogc3RhcnQgdGhlIHRocmVhZCB3aXRoLlxuICAgICAqL1xuICAgIG1lc3NhZ2VzPzogQXJyYXk8VGhyZWFkLk1lc3NhZ2U+O1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAgICogY2hhcmFjdGVycyBsb25nLlxuICAgICAqL1xuICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICAgKiB0aHJlYWQuIFRoZSByZXNvdXJjZXMgYXJlIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGVcbiAgICAgKiBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgXG4gICAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICAgKi9cbiAgICB0b29sX3Jlc291cmNlcz86IFRocmVhZC5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVGhyZWFkIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdGV4dCBjb250ZW50cyBvZiB0aGUgbWVzc2FnZS5cbiAgICAgICAqL1xuICAgICAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8TWVzc2FnZXNBUEkuTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0+O1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSByb2xlIG9mIHRoZSBlbnRpdHkgdGhhdCBpcyBjcmVhdGluZyB0aGUgbWVzc2FnZS4gQWxsb3dlZCB2YWx1ZXMgaW5jbHVkZTpcbiAgICAgICAqXG4gICAgICAgKiAtIGB1c2VyYDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIHNlbnQgYnkgYW4gYWN0dWFsIHVzZXIgYW5kIHNob3VsZCBiZSB1c2VkIGluXG4gICAgICAgKiAgIG1vc3QgY2FzZXMgdG8gcmVwcmVzZW50IHVzZXItZ2VuZXJhdGVkIG1lc3NhZ2VzLlxuICAgICAgICogLSBgYXNzaXN0YW50YDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGdlbmVyYXRlZCBieSB0aGUgYXNzaXN0YW50LiBVc2UgdGhpc1xuICAgICAgICogICB2YWx1ZSB0byBpbnNlcnQgbWVzc2FnZXMgZnJvbSB0aGUgYXNzaXN0YW50IGludG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgICAqL1xuICAgICAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIHRoZSBtZXNzYWdlLCBhbmQgdGhlIHRvb2xzIHRoZXkgc2hvdWxkIGJlIGFkZGVkIHRvLlxuICAgICAgICovXG4gICAgICBhdHRhY2htZW50cz86IEFycmF5PE1lc3NhZ2UuQXR0YWNobWVudD4gfCBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAgICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgICAqL1xuICAgICAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIE1lc3NhZ2Uge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBBdHRhY2htZW50IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBhdHRhY2ggdG8gdGhlIG1lc3NhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBmaWxlX2lkPzogc3RyaW5nO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG9vbHMgdG8gYWRkIHRoaXMgZmlsZSB0by5cbiAgICAgICAgICovXG4gICAgICAgIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXNzaXN0YW50c0FQSS5GaWxlU2VhcmNoVG9vbD47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBhc3Npc3RhbnQncyB0b29scyBpbiB0aGlzXG4gICAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgICAqIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBJRHMuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICAgIGNvZGVfaW50ZXJwcmV0ZXI/OiBUb29sUmVzb3VyY2VzLkNvZGVJbnRlcnByZXRlcjtcblxuICAgICAgZmlsZV9zZWFyY2g/OiBUb29sUmVzb3VyY2VzLkZpbGVTZWFyY2g7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIG1hZGVcbiAgICAgICAgICogYXZhaWxhYmxlIHRvIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlc1xuICAgICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2wuXG4gICAgICAgICAqL1xuICAgICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVcbiAgICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyB0aHJlYWQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAgICogdGhlIHRocmVhZC5cbiAgICAgICAgICovXG4gICAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGhlbHBlciB0byBjcmVhdGUgYVxuICAgICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICAgKiB3aXRoIGZpbGVfaWRzIGFuZCBhdHRhY2ggaXQgdG8gdGhpcyB0aHJlYWQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3JcbiAgICAgICAgICogc3RvcmUgYXR0YWNoZWQgdG8gdGhlIHRocmVhZC5cbiAgICAgICAgICovXG4gICAgICAgIHZlY3Rvcl9zdG9yZXM/OiBBcnJheTxGaWxlU2VhcmNoLlZlY3RvclN0b3JlPjtcbiAgICAgIH1cblxuICAgICAgZXhwb3J0IG5hbWVzcGFjZSBGaWxlU2VhcmNoIHtcbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgdG9cbiAgICAgICAgICAgKiBhZGQgdG8gdGhlIHZlY3RvciBzdG9yZS4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxMDAwMCBmaWxlcyBpbiBhIHZlY3RvclxuICAgICAgICAgICAqIHN0b3JlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB2ZWN0b3Igc3RvcmUuIFRoaXMgY2FuIGJlXG4gICAgICAgICAgICogdXNlZnVsIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZlY3RvciBzdG9yZSBpbiBhIHN0cnVjdHVyZWRcbiAgICAgICAgICAgKiBmb3JtYXQuIEtleXMgY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW1cbiAgICAgICAgICAgKiBvZiA1MTIgY2hhcmFjdGVycyBsb25nLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1ldGFkYXRhPzogdW5rbm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgdXNlZCBieSB0aGUgYXNzaXN0YW50J3MgdG9vbHMuIFRoZSByZXNvdXJjZXMgYXJlXG4gICAqIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXNcbiAgICogYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVcbiAgICogSURzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzXG4gICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2wuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSUQgb2YgdGhlXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyBhc3Npc3RhbnQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAqIHRoZSBhc3Npc3RhbnQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUcnVuY2F0aW9uU3RyYXRlZ3kge1xuICAgIC8qKlxuICAgICAqIFRoZSB0cnVuY2F0aW9uIHN0cmF0ZWd5IHRvIHVzZSBmb3IgdGhlIHRocmVhZC4gVGhlIGRlZmF1bHQgaXMgYGF1dG9gLiBJZiBzZXQgdG9cbiAgICAgKiBgbGFzdF9tZXNzYWdlc2AsIHRoZSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgdG8gdGhlIG4gbW9zdCByZWNlbnQgbWVzc2FnZXMgaW5cbiAgICAgKiB0aGUgdGhyZWFkLiBXaGVuIHNldCB0byBgYXV0b2AsIG1lc3NhZ2VzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHRocmVhZCB3aWxsIGJlXG4gICAgICogZHJvcHBlZCB0byBmaXQgdGhlIGNvbnRleHQgbGVuZ3RoIG9mIHRoZSBtb2RlbCwgYG1heF9wcm9tcHRfdG9rZW5zYC5cbiAgICAgKi9cbiAgICB0eXBlOiAnYXV0bycgfCAnbGFzdF9tZXNzYWdlcyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGZyb20gdGhlIHRocmVhZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgY29udGV4dFxuICAgICAqIGZvciB0aGUgcnVuLlxuICAgICAqL1xuICAgIGxhc3RfbWVzc2FnZXM/OiBudW1iZXIgfCBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkQ3JlYXRlQW5kUnVuU3RyZWFtUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGVcbiAgICogW2Fzc2lzdGFudF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSB0byB1c2UgdG9cbiAgICogZXhlY3V0ZSB0aGlzIHJ1bi5cbiAgICovXG4gIGFzc2lzdGFudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBzeXN0ZW0gbWVzc2FnZSBvZiB0aGUgYXNzaXN0YW50LiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlXG4gICAqIHJ1bi4gVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zXG4gICAqIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGUgbnVtYmVyIG9mXG4gICAqIGNvbXBsZXRpb24gdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X2NvbXBsZXRpb25fdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHByb21wdCB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1bi5cbiAgICogVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIHByb21wdCB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogcHJvbXB0IHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLiBTZWVcbiAgICogYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9wcm9tcHRfdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBbTW9kZWxdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzKSB0b1xuICAgKiBiZSB1c2VkIHRvIGV4ZWN1dGUgdGhpcyBydW4uIElmIGEgdmFsdWUgaXMgcHJvdmlkZWQgaGVyZSwgaXQgd2lsbCBvdmVycmlkZSB0aGVcbiAgICogbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3Npc3RhbnQuIElmIG5vdCwgdGhlIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICogYXNzaXN0YW50IHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIG1vZGVsPzpcbiAgICB8IChzdHJpbmcgJiB7fSlcbiAgICB8ICdncHQtNG8nXG4gICAgfCAnZ3B0LTRvLTIwMjQtMDUtMTMnXG4gICAgfCAnZ3B0LTQtdHVyYm8nXG4gICAgfCAnZ3B0LTQtdHVyYm8tMjAyNC0wNC0wOSdcbiAgICB8ICdncHQtNC0wMTI1LXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtdHVyYm8tcHJldmlldydcbiAgICB8ICdncHQtNC0xMTA2LXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtdmlzaW9uLXByZXZpZXcnXG4gICAgfCAnZ3B0LTQnXG4gICAgfCAnZ3B0LTQtMDMxNCdcbiAgICB8ICdncHQtNC0wNjEzJ1xuICAgIHwgJ2dwdC00LTMyaydcbiAgICB8ICdncHQtNC0zMmstMDMxNCdcbiAgICB8ICdncHQtNC0zMmstMDYxMydcbiAgICB8ICdncHQtMy41LXR1cmJvJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTZrJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMDYxMydcbiAgICB8ICdncHQtMy41LXR1cmJvLTExMDYnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0wMTI1J1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTZrLTA2MTMnXG4gICAgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gICAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscy9ncHQtNG8pLFxuICAgKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscy9ncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICAgKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGd1YXJhbnRlZXMgdGhlXG4gICAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICAgKlxuICAgKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gICAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAgICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAgICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAgICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICAgKiBtYXggY29udGV4dCBsZW5ndGguXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBBc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoYXQgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdG8gdXNlLCBiZXR3ZWVuIDAgYW5kIDIuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbFxuICAgKiBtYWtlIHRoZSBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZVxuICAgKiBmb2N1c2VkIGFuZCBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJZiBubyB0aHJlYWQgaXMgcHJvdmlkZWQsIGFuIGVtcHR5IHRocmVhZCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqL1xuICB0aHJlYWQ/OiBUaHJlYWRDcmVhdGVBbmRSdW5TdHJlYW1QYXJhbXMuVGhyZWFkO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyB3aGljaCAoaWYgYW55KSB0b29sIGlzIGNhbGxlZCBieSB0aGUgbW9kZWwuIGBub25lYCBtZWFucyB0aGUgbW9kZWwgd2lsbFxuICAgKiBub3QgY2FsbCBhbnkgdG9vbHMgYW5kIGluc3RlYWQgZ2VuZXJhdGVzIGEgbWVzc2FnZS4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAqIGFuZCBtZWFucyB0aGUgbW9kZWwgY2FuIHBpY2sgYmV0d2VlbiBnZW5lcmF0aW5nIGEgbWVzc2FnZSBvciBjYWxsaW5nIG9uZSBvciBtb3JlXG4gICAqIHRvb2xzLiBgcmVxdWlyZWRgIG1lYW5zIHRoZSBtb2RlbCBtdXN0IGNhbGwgb25lIG9yIG1vcmUgdG9vbHMgYmVmb3JlIHJlc3BvbmRpbmdcbiAgICogdG8gdGhlIHVzZXIuIFNwZWNpZnlpbmcgYSBwYXJ0aWN1bGFyIHRvb2wgbGlrZSBge1widHlwZVwiOiBcImZpbGVfc2VhcmNoXCJ9YCBvclxuICAgKiBge1widHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIm15X2Z1bmN0aW9uXCJ9fWAgZm9yY2VzIHRoZSBtb2RlbCB0b1xuICAgKiBjYWxsIHRoYXQgdG9vbC5cbiAgICovXG4gIHRvb2xfY2hvaWNlPzogQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBhc3Npc3RhbnQncyB0b29scy4gVGhlIHJlc291cmNlcyBhcmVcbiAgICogc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlc1xuICAgKiBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZVxuICAgKiBJRHMuXG4gICAqL1xuICB0b29sX3Jlc291cmNlcz86IFRocmVhZENyZWF0ZUFuZFJ1blN0cmVhbVBhcmFtcy5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHRvb2xzIHRoZSBhc3Npc3RhbnQgY2FuIHVzZSBmb3IgdGhpcyBydW4uIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8XG4gICAgQXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXNzaXN0YW50c0FQSS5GaWxlU2VhcmNoVG9vbCB8IEFzc2lzdGFudHNBUEkuRnVuY3Rpb25Ub29sXG4gID4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICB0cnVuY2F0aW9uX3N0cmF0ZWd5PzogVGhyZWFkQ3JlYXRlQW5kUnVuU3RyZWFtUGFyYW1zLlRydW5jYXRpb25TdHJhdGVneSB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVGhyZWFkQ3JlYXRlQW5kUnVuU3RyZWFtUGFyYW1zIHtcbiAgLyoqXG4gICAqIElmIG5vIHRocmVhZCBpcyBwcm92aWRlZCwgYW4gZW1wdHkgdGhyZWFkIHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkIHtcbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgW21lc3NhZ2VzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzKSB0b1xuICAgICAqIHN0YXJ0IHRoZSB0aHJlYWQgd2l0aC5cbiAgICAgKi9cbiAgICBtZXNzYWdlcz86IEFycmF5PFRocmVhZC5NZXNzYWdlPjtcblxuICAgIC8qKlxuICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgKi9cbiAgICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBhc3Npc3RhbnQncyB0b29scyBpbiB0aGlzXG4gICAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgICAqIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBJRHMuXG4gICAgICovXG4gICAgdG9vbF9yZXNvdXJjZXM/OiBUaHJlYWQuVG9vbFJlc291cmNlcyB8IG51bGw7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRocmVhZCB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRleHQgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PE1lc3NhZ2VzQVBJLk1lc3NhZ2VDb250ZW50UGFydFBhcmFtPjtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcm9sZSBvZiB0aGUgZW50aXR5IHRoYXQgaXMgY3JlYXRpbmcgdGhlIG1lc3NhZ2UuIEFsbG93ZWQgdmFsdWVzIGluY2x1ZGU6XG4gICAgICAgKlxuICAgICAgICogLSBgdXNlcmA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBzZW50IGJ5IGFuIGFjdHVhbCB1c2VyIGFuZCBzaG91bGQgYmUgdXNlZCBpblxuICAgICAgICogICBtb3N0IGNhc2VzIHRvIHJlcHJlc2VudCB1c2VyLWdlbmVyYXRlZCBtZXNzYWdlcy5cbiAgICAgICAqIC0gYGFzc2lzdGFudGA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBnZW5lcmF0ZWQgYnkgdGhlIGFzc2lzdGFudC4gVXNlIHRoaXNcbiAgICAgICAqICAgdmFsdWUgdG8gaW5zZXJ0IG1lc3NhZ2VzIGZyb20gdGhlIGFzc2lzdGFudCBpbnRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICAgKi9cbiAgICAgIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byB0aGUgbWVzc2FnZSwgYW5kIHRoZSB0b29scyB0aGV5IHNob3VsZCBiZSBhZGRlZCB0by5cbiAgICAgICAqL1xuICAgICAgYXR0YWNobWVudHM/OiBBcnJheTxNZXNzYWdlLkF0dGFjaG1lbnQ+IHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAgICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICAgKi9cbiAgICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBNZXNzYWdlIHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gYXR0YWNoIHRvIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZV9pZD86IHN0cmluZztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvb2xzIHRvIGFkZCB0aGlzIGZpbGUgdG8uXG4gICAgICAgICAqL1xuICAgICAgICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEFzc2lzdGFudHNBUEkuRmlsZVNlYXJjaFRvb2w+O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYXNzaXN0YW50J3MgdG9vbHMgaW4gdGhpc1xuICAgICAqIHRocmVhZC4gVGhlIHJlc291cmNlcyBhcmUgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZVxuICAgICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICAgKiB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgSURzLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICAgIGZpbGVfc2VhcmNoPzogVG9vbFJlc291cmNlcy5GaWxlU2VhcmNoO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgICAqIGF2YWlsYWJsZSB0byB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMjAgZmlsZXNcbiAgICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlXG4gICAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgdGhyZWFkLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvXG4gICAgICAgICAqIHRoZSB0aHJlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB2ZWN0b3Jfc3RvcmVfaWRzPzogQXJyYXk8c3RyaW5nPjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBoZWxwZXIgdG8gY3JlYXRlIGFcbiAgICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAgICogd2l0aCBmaWxlX2lkcyBhbmQgYXR0YWNoIGl0IHRvIHRoaXMgdGhyZWFkLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yXG4gICAgICAgICAqIHN0b3JlIGF0dGFjaGVkIHRvIHRoZSB0aHJlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB2ZWN0b3Jfc3RvcmVzPzogQXJyYXk8RmlsZVNlYXJjaC5WZWN0b3JTdG9yZT47XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydCBuYW1lc3BhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmUge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIHRvXG4gICAgICAgICAgICogYWRkIHRvIHRoZSB2ZWN0b3Igc3RvcmUuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMTAwMDAgZmlsZXMgaW4gYSB2ZWN0b3JcbiAgICAgICAgICAgKiBzdG9yZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdmVjdG9yIHN0b3JlLiBUaGlzIGNhbiBiZVxuICAgICAgICAgICAqIHVzZWZ1bCBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2ZWN0b3Igc3RvcmUgaW4gYSBzdHJ1Y3R1cmVkXG4gICAgICAgICAgICogZm9ybWF0LiBLZXlzIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtXG4gICAgICAgICAgICogb2YgNTEyIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBtZXRhZGF0YT86IHVua25vd247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIGFzc2lzdGFudCdzIHRvb2xzLiBUaGUgcmVzb3VyY2VzIGFyZVxuICAgKiBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzXG4gICAqIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlXG4gICAqIElEcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgY29kZV9pbnRlcnByZXRlcj86IFRvb2xSZXNvdXJjZXMuQ29kZUludGVycHJldGVyO1xuXG4gICAgZmlsZV9zZWFyY2g/OiBUb29sUmVzb3VyY2VzLkZpbGVTZWFyY2g7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgbWFkZVxuICAgICAgICogYXZhaWxhYmxlIHRvIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlc1xuICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIElEIG9mIHRoZVxuICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgYXNzaXN0YW50LiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvXG4gICAgICAgKiB0aGUgYXNzaXN0YW50LlxuICAgICAgICovXG4gICAgICB2ZWN0b3Jfc3RvcmVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVHJ1bmNhdGlvblN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJ1bmNhdGlvbiBzdHJhdGVneSB0byB1c2UgZm9yIHRoZSB0aHJlYWQuIFRoZSBkZWZhdWx0IGlzIGBhdXRvYC4gSWYgc2V0IHRvXG4gICAgICogYGxhc3RfbWVzc2FnZXNgLCB0aGUgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHRvIHRoZSBuIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGluXG4gICAgICogdGhlIHRocmVhZC4gV2hlbiBzZXQgdG8gYGF1dG9gLCBtZXNzYWdlcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSB0aHJlYWQgd2lsbCBiZVxuICAgICAqIGRyb3BwZWQgdG8gZml0IHRoZSBjb250ZXh0IGxlbmd0aCBvZiB0aGUgbW9kZWwsIGBtYXhfcHJvbXB0X3Rva2Vuc2AuXG4gICAgICovXG4gICAgdHlwZTogJ2F1dG8nIHwgJ2xhc3RfbWVzc2FnZXMnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtb3N0IHJlY2VudCBtZXNzYWdlcyBmcm9tIHRoZSB0aHJlYWQgd2hlbiBjb25zdHJ1Y3RpbmcgdGhlIGNvbnRleHRcbiAgICAgKiBmb3IgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBsYXN0X21lc3NhZ2VzPzogbnVtYmVyIHwgbnVsbDtcbiAgfVxufVxuXG5UaHJlYWRzLlJ1bnMgPSBSdW5zO1xuVGhyZWFkcy5SdW5zUGFnZSA9IFJ1bnNQYWdlO1xuVGhyZWFkcy5NZXNzYWdlcyA9IE1lc3NhZ2VzO1xuVGhyZWFkcy5NZXNzYWdlc1BhZ2UgPSBNZXNzYWdlc1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBUaHJlYWRzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIEFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIGFzIEFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uLFxuICAgIHR5cGUgQXNzaXN0YW50VG9vbENob2ljZSBhcyBBc3Npc3RhbnRUb29sQ2hvaWNlLFxuICAgIHR5cGUgQXNzaXN0YW50VG9vbENob2ljZUZ1bmN0aW9uIGFzIEFzc2lzdGFudFRvb2xDaG9pY2VGdW5jdGlvbixcbiAgICB0eXBlIEFzc2lzdGFudFRvb2xDaG9pY2VPcHRpb24gYXMgQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbixcbiAgICB0eXBlIFRocmVhZCBhcyBUaHJlYWQsXG4gICAgdHlwZSBUaHJlYWREZWxldGVkIGFzIFRocmVhZERlbGV0ZWQsXG4gICAgdHlwZSBUaHJlYWRDcmVhdGVQYXJhbXMgYXMgVGhyZWFkQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgVGhyZWFkVXBkYXRlUGFyYW1zIGFzIFRocmVhZFVwZGF0ZVBhcmFtcyxcbiAgICB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtcyBhcyBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXMsXG4gICAgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNOb25TdHJlYW1pbmcgYXMgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zU3RyZWFtaW5nIGFzIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc1N0cmVhbWluZyxcbiAgICB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blBvbGxQYXJhbXMsXG4gICAgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5TdHJlYW1QYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHtcbiAgICBSdW5zIGFzIFJ1bnMsXG4gICAgdHlwZSBSZXF1aXJlZEFjdGlvbkZ1bmN0aW9uVG9vbENhbGwgYXMgUmVxdWlyZWRBY3Rpb25GdW5jdGlvblRvb2xDYWxsLFxuICAgIHR5cGUgUnVuIGFzIFJ1bixcbiAgICB0eXBlIFJ1blN0YXR1cyBhcyBSdW5TdGF0dXMsXG4gICAgUnVuc1BhZ2UgYXMgUnVuc1BhZ2UsXG4gICAgdHlwZSBSdW5DcmVhdGVQYXJhbXMgYXMgUnVuQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgUnVuQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGFzIFJ1bkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIFJ1bkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBhcyBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gICAgdHlwZSBSdW5VcGRhdGVQYXJhbXMgYXMgUnVuVXBkYXRlUGFyYW1zLFxuICAgIHR5cGUgUnVuTGlzdFBhcmFtcyBhcyBSdW5MaXN0UGFyYW1zLFxuICAgIHR5cGUgUnVuQ3JlYXRlQW5kUG9sbFBhcmFtcyxcbiAgICB0eXBlIFJ1bkNyZWF0ZUFuZFN0cmVhbVBhcmFtcyxcbiAgICB0eXBlIFJ1blN0cmVhbVBhcmFtcyxcbiAgICB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zIGFzIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zLFxuICAgIHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNOb25TdHJlYW1pbmcgYXMgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbWluZyBhcyBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbWluZyxcbiAgICB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzQW5kUG9sbFBhcmFtcyxcbiAgICB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzU3RyZWFtUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgTWVzc2FnZXMgYXMgTWVzc2FnZXMsXG4gICAgdHlwZSBBbm5vdGF0aW9uIGFzIEFubm90YXRpb24sXG4gICAgdHlwZSBBbm5vdGF0aW9uRGVsdGEgYXMgQW5ub3RhdGlvbkRlbHRhLFxuICAgIHR5cGUgRmlsZUNpdGF0aW9uQW5ub3RhdGlvbiBhcyBGaWxlQ2l0YXRpb25Bbm5vdGF0aW9uLFxuICAgIHR5cGUgRmlsZUNpdGF0aW9uRGVsdGFBbm5vdGF0aW9uIGFzIEZpbGVDaXRhdGlvbkRlbHRhQW5ub3RhdGlvbixcbiAgICB0eXBlIEZpbGVQYXRoQW5ub3RhdGlvbiBhcyBGaWxlUGF0aEFubm90YXRpb24sXG4gICAgdHlwZSBGaWxlUGF0aERlbHRhQW5ub3RhdGlvbiBhcyBGaWxlUGF0aERlbHRhQW5ub3RhdGlvbixcbiAgICB0eXBlIEltYWdlRmlsZSBhcyBJbWFnZUZpbGUsXG4gICAgdHlwZSBJbWFnZUZpbGVDb250ZW50QmxvY2sgYXMgSW1hZ2VGaWxlQ29udGVudEJsb2NrLFxuICAgIHR5cGUgSW1hZ2VGaWxlRGVsdGEgYXMgSW1hZ2VGaWxlRGVsdGEsXG4gICAgdHlwZSBJbWFnZUZpbGVEZWx0YUJsb2NrIGFzIEltYWdlRmlsZURlbHRhQmxvY2ssXG4gICAgdHlwZSBJbWFnZVVSTCBhcyBJbWFnZVVSTCxcbiAgICB0eXBlIEltYWdlVVJMQ29udGVudEJsb2NrIGFzIEltYWdlVVJMQ29udGVudEJsb2NrLFxuICAgIHR5cGUgSW1hZ2VVUkxEZWx0YSBhcyBJbWFnZVVSTERlbHRhLFxuICAgIHR5cGUgSW1hZ2VVUkxEZWx0YUJsb2NrIGFzIEltYWdlVVJMRGVsdGFCbG9jayxcbiAgICB0eXBlIE1lc3NhZ2VzQVBJTWVzc2FnZSBhcyBNZXNzYWdlLFxuICAgIHR5cGUgTWVzc2FnZUNvbnRlbnQgYXMgTWVzc2FnZUNvbnRlbnQsXG4gICAgdHlwZSBNZXNzYWdlQ29udGVudERlbHRhIGFzIE1lc3NhZ2VDb250ZW50RGVsdGEsXG4gICAgdHlwZSBNZXNzYWdlQ29udGVudFBhcnRQYXJhbSBhcyBNZXNzYWdlQ29udGVudFBhcnRQYXJhbSxcbiAgICB0eXBlIE1lc3NhZ2VEZWxldGVkIGFzIE1lc3NhZ2VEZWxldGVkLFxuICAgIHR5cGUgTWVzc2FnZURlbHRhIGFzIE1lc3NhZ2VEZWx0YSxcbiAgICB0eXBlIE1lc3NhZ2VEZWx0YUV2ZW50IGFzIE1lc3NhZ2VEZWx0YUV2ZW50LFxuICAgIHR5cGUgUmVmdXNhbENvbnRlbnRCbG9jayBhcyBSZWZ1c2FsQ29udGVudEJsb2NrLFxuICAgIHR5cGUgUmVmdXNhbERlbHRhQmxvY2sgYXMgUmVmdXNhbERlbHRhQmxvY2ssXG4gICAgdHlwZSBUZXh0IGFzIFRleHQsXG4gICAgdHlwZSBUZXh0Q29udGVudEJsb2NrIGFzIFRleHRDb250ZW50QmxvY2ssXG4gICAgdHlwZSBUZXh0Q29udGVudEJsb2NrUGFyYW0gYXMgVGV4dENvbnRlbnRCbG9ja1BhcmFtLFxuICAgIHR5cGUgVGV4dERlbHRhIGFzIFRleHREZWx0YSxcbiAgICB0eXBlIFRleHREZWx0YUJsb2NrIGFzIFRleHREZWx0YUJsb2NrLFxuICAgIE1lc3NhZ2VzUGFnZSBhcyBNZXNzYWdlc1BhZ2UsXG4gICAgdHlwZSBNZXNzYWdlQ3JlYXRlUGFyYW1zIGFzIE1lc3NhZ2VDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBNZXNzYWdlVXBkYXRlUGFyYW1zIGFzIE1lc3NhZ2VVcGRhdGVQYXJhbXMsXG4gICAgdHlwZSBNZXNzYWdlTGlzdFBhcmFtcyBhcyBNZXNzYWdlTGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICIvKipcbiAqIExpa2UgYFByb21pc2UuYWxsU2V0dGxlZCgpYCBidXQgdGhyb3dzIGFuIGVycm9yIGlmIGFueSBwcm9taXNlcyBhcmUgcmVqZWN0ZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBhbGxTZXR0bGVkV2l0aFRocm93ID0gYXN5bmMgPFI+KHByb21pc2VzOiBQcm9taXNlPFI+W10pOiBQcm9taXNlPFJbXT4gPT4ge1xuICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHByb21pc2VzKTtcbiAgY29uc3QgcmVqZWN0ZWQgPSByZXN1bHRzLmZpbHRlcigocmVzdWx0KTogcmVzdWx0IGlzIFByb21pc2VSZWplY3RlZFJlc3VsdCA9PiByZXN1bHQuc3RhdHVzID09PSAncmVqZWN0ZWQnKTtcbiAgaWYgKHJlamVjdGVkLmxlbmd0aCkge1xuICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlamVjdGVkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKHJlc3VsdC5yZWFzb24pO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihgJHtyZWplY3RlZC5sZW5ndGh9IHByb21pc2UocykgZmFpbGVkIC0gc2VlIHRoZSBhYm92ZSBlcnJvcnNgKTtcbiAgfVxuXG4gIC8vIE5vdGU6IFRTIHdhcyBjb21wbGFpbmluZyBhYm91dCB1c2luZyBgLmZpbHRlcigpLm1hcCgpYCBoZXJlIGZvciBzb21lIHJlYXNvblxuICBjb25zdCB2YWx1ZXM6IFJbXSA9IFtdO1xuICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgICB2YWx1ZXMucHVzaChyZXN1bHQudmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufTtcbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IHNsZWVwLCBVcGxvYWRhYmxlLCBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgVmVjdG9yU3RvcmVzQVBJIGZyb20gJy4vdmVjdG9yLXN0b3Jlcyc7XG5pbXBvcnQgeyBDdXJzb3JQYWdlLCB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9wYWdpbmF0aW9uJztcblxuZXhwb3J0IGNsYXNzIEZpbGVzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlIGEgdmVjdG9yIHN0b3JlIGZpbGUgYnkgYXR0YWNoaW5nIGFcbiAgICogW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIHRvIGFcbiAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdCkuXG4gICAqL1xuICBjcmVhdGUoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGJvZHk6IEZpbGVDcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGU+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH0vZmlsZXNgLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgdmVjdG9yIHN0b3JlIGZpbGUuXG4gICAqL1xuICByZXRyaWV2ZShcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgZmlsZUlkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGU+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlcy8ke2ZpbGVJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgZmlsZXMuXG4gICAqL1xuICBsaXN0KFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBxdWVyeT86IEZpbGVMaXN0UGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFZlY3RvclN0b3JlRmlsZXNQYWdlLCBWZWN0b3JTdG9yZUZpbGU+O1xuICBsaXN0KFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVzUGFnZSwgVmVjdG9yU3RvcmVGaWxlPjtcbiAgbGlzdChcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgcXVlcnk6IEZpbGVMaXN0UGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFZlY3RvclN0b3JlRmlsZXNQYWdlLCBWZWN0b3JTdG9yZUZpbGU+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3QodmVjdG9yU3RvcmVJZCwge30sIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9L2ZpbGVzYCwgVmVjdG9yU3RvcmVGaWxlc1BhZ2UsIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgdmVjdG9yIHN0b3JlIGZpbGUuIFRoaXMgd2lsbCByZW1vdmUgdGhlIGZpbGUgZnJvbSB0aGUgdmVjdG9yIHN0b3JlIGJ1dFxuICAgKiB0aGUgZmlsZSBpdHNlbGYgd2lsbCBub3QgYmUgZGVsZXRlZC4gVG8gZGVsZXRlIHRoZSBmaWxlLCB1c2UgdGhlXG4gICAqIFtkZWxldGUgZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9kZWxldGUpXG4gICAqIGVuZHBvaW50LlxuICAgKi9cbiAgZGVsKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBmaWxlSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFZlY3RvclN0b3JlRmlsZURlbGV0ZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlcy8ke2ZpbGVJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYSBmaWxlIHRvIHRoZSBnaXZlbiB2ZWN0b3Igc3RvcmUgYW5kIHdhaXQgZm9yIGl0IHRvIGJlIHByb2Nlc3NlZC5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZUFuZFBvbGwoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGJvZHk6IEZpbGVDcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMgJiB7IHBvbGxJbnRlcnZhbE1zPzogbnVtYmVyIH0sXG4gICk6IFByb21pc2U8VmVjdG9yU3RvcmVGaWxlPiB7XG4gICAgY29uc3QgZmlsZSA9IGF3YWl0IHRoaXMuY3JlYXRlKHZlY3RvclN0b3JlSWQsIGJvZHksIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnBvbGwodmVjdG9yU3RvcmVJZCwgZmlsZS5pZCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogV2FpdCBmb3IgdGhlIHZlY3RvciBzdG9yZSBmaWxlIHRvIGZpbmlzaCBwcm9jZXNzaW5nLlxuICAgKlxuICAgKiBOb3RlOiB0aGlzIHdpbGwgcmV0dXJuIGV2ZW4gaWYgdGhlIGZpbGUgZmFpbGVkIHRvIHByb2Nlc3MsIHlvdSBuZWVkIHRvIGNoZWNrXG4gICAqIGZpbGUubGFzdF9lcnJvciBhbmQgZmlsZS5zdGF0dXMgdG8gaGFuZGxlIHRoZXNlIGNhc2VzXG4gICAqL1xuICBhc3luYyBwb2xsKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBmaWxlSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyAmIHsgcG9sbEludGVydmFsTXM/OiBudW1iZXIgfSxcbiAgKTogUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGU+IHtcbiAgICBjb25zdCBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0geyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtUG9sbC1IZWxwZXInOiAndHJ1ZScgfTtcbiAgICBpZiAob3B0aW9ucz8ucG9sbEludGVydmFsTXMpIHtcbiAgICAgIGhlYWRlcnNbJ1gtU3RhaW5sZXNzLUN1c3RvbS1Qb2xsLUludGVydmFsJ10gPSBvcHRpb25zLnBvbGxJbnRlcnZhbE1zLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBmaWxlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJldHJpZXZlKHZlY3RvclN0b3JlSWQsIGZpbGVJZCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgfSkud2l0aFJlc3BvbnNlKCk7XG5cbiAgICAgIGNvbnN0IGZpbGUgPSBmaWxlUmVzcG9uc2UuZGF0YTtcblxuICAgICAgc3dpdGNoIChmaWxlLnN0YXR1cykge1xuICAgICAgICBjYXNlICdpbl9wcm9ncmVzcyc6XG4gICAgICAgICAgbGV0IHNsZWVwSW50ZXJ2YWwgPSA1MDAwO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnM/LnBvbGxJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICBzbGVlcEludGVydmFsID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVySW50ZXJ2YWwgPSBmaWxlUmVzcG9uc2UucmVzcG9uc2UuaGVhZGVycy5nZXQoJ29wZW5haS1wb2xsLWFmdGVyLW1zJyk7XG4gICAgICAgICAgICBpZiAoaGVhZGVySW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgY29uc3QgaGVhZGVySW50ZXJ2YWxNcyA9IHBhcnNlSW50KGhlYWRlckludGVydmFsKTtcbiAgICAgICAgICAgICAgaWYgKCFpc05hTihoZWFkZXJJbnRlcnZhbE1zKSkge1xuICAgICAgICAgICAgICAgIHNsZWVwSW50ZXJ2YWwgPSBoZWFkZXJJbnRlcnZhbE1zO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IHNsZWVwKHNsZWVwSW50ZXJ2YWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGxvYWQgYSBmaWxlIHRvIHRoZSBgZmlsZXNgIEFQSSBhbmQgdGhlbiBhdHRhY2ggaXQgdG8gdGhlIGdpdmVuIHZlY3RvciBzdG9yZS5cbiAgICpcbiAgICogTm90ZSB0aGUgZmlsZSB3aWxsIGJlIGFzeW5jaHJvbm91c2x5IHByb2Nlc3NlZCAoeW91IGNhbiB1c2UgdGhlIGFsdGVybmF0aXZlXG4gICAqIHBvbGxpbmcgaGVscGVyIG1ldGhvZCB0byB3YWl0IGZvciBwcm9jZXNzaW5nIHRvIGNvbXBsZXRlKS5cbiAgICovXG4gIGFzeW5jIHVwbG9hZChcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgZmlsZTogVXBsb2FkYWJsZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGU+IHtcbiAgICBjb25zdCBmaWxlSW5mbyA9IGF3YWl0IHRoaXMuX2NsaWVudC5maWxlcy5jcmVhdGUoeyBmaWxlOiBmaWxlLCBwdXJwb3NlOiAnYXNzaXN0YW50cycgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlKHZlY3RvclN0b3JlSWQsIHsgZmlsZV9pZDogZmlsZUluZm8uaWQgfSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgZmlsZSB0byBhIHZlY3RvciBzdG9yZSBhbmQgcG9sbCB1bnRpbCBwcm9jZXNzaW5nIGlzIGNvbXBsZXRlLlxuICAgKi9cbiAgYXN5bmMgdXBsb2FkQW5kUG9sbChcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgZmlsZTogVXBsb2FkYWJsZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyAmIHsgcG9sbEludGVydmFsTXM/OiBudW1iZXIgfSxcbiAgKTogUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGU+IHtcbiAgICBjb25zdCBmaWxlSW5mbyA9IGF3YWl0IHRoaXMudXBsb2FkKHZlY3RvclN0b3JlSWQsIGZpbGUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnBvbGwodmVjdG9yU3RvcmVJZCwgZmlsZUluZm8uaWQsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBWZWN0b3JTdG9yZUZpbGVzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8VmVjdG9yU3RvcmVGaWxlPiB7fVxuXG4vKipcbiAqIEEgbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byBhIHZlY3RvciBzdG9yZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZUZpbGUge1xuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSB2ZWN0b3Igc3RvcmUgZmlsZSB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGxhc3QgZXJyb3IgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdmVjdG9yIHN0b3JlIGZpbGUuIFdpbGwgYmUgYG51bGxgIGlmIHRoZXJlXG4gICAqIGFyZSBubyBlcnJvcnMuXG4gICAqL1xuICBsYXN0X2Vycm9yOiBWZWN0b3JTdG9yZUZpbGUuTGFzdEVycm9yIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYHZlY3Rvcl9zdG9yZS5maWxlYC5cbiAgICovXG4gIG9iamVjdDogJ3ZlY3Rvcl9zdG9yZS5maWxlJztcblxuICAvKipcbiAgICogVGhlIHN0YXR1cyBvZiB0aGUgdmVjdG9yIHN0b3JlIGZpbGUsIHdoaWNoIGNhbiBiZSBlaXRoZXIgYGluX3Byb2dyZXNzYCxcbiAgICogYGNvbXBsZXRlZGAsIGBjYW5jZWxsZWRgLCBvciBgZmFpbGVkYC4gVGhlIHN0YXR1cyBgY29tcGxldGVkYCBpbmRpY2F0ZXMgdGhhdCB0aGVcbiAgICogdmVjdG9yIHN0b3JlIGZpbGUgaXMgcmVhZHkgZm9yIHVzZS5cbiAgICovXG4gIHN0YXR1czogJ2luX3Byb2dyZXNzJyB8ICdjb21wbGV0ZWQnIHwgJ2NhbmNlbGxlZCcgfCAnZmFpbGVkJztcblxuICAvKipcbiAgICogVGhlIHRvdGFsIHZlY3RvciBzdG9yZSB1c2FnZSBpbiBieXRlcy4gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGRpZmZlcmVudCBmcm9tIHRoZVxuICAgKiBvcmlnaW5hbCBmaWxlIHNpemUuXG4gICAqL1xuICB1c2FnZV9ieXRlczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlXG4gICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAqIHRoYXQgdGhlIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBpc1xuICAgKiBhdHRhY2hlZCB0by5cbiAgICovXG4gIHZlY3Rvcl9zdG9yZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RyYXRlZ3kgdXNlZCB0byBjaHVuayB0aGUgZmlsZS5cbiAgICovXG4gIGNodW5raW5nX3N0cmF0ZWd5PzogVmVjdG9yU3RvcmVzQVBJLkZpbGVDaHVua2luZ1N0cmF0ZWd5O1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFZlY3RvclN0b3JlRmlsZSB7XG4gIC8qKlxuICAgKiBUaGUgbGFzdCBlcnJvciBhc3NvY2lhdGVkIHdpdGggdGhpcyB2ZWN0b3Igc3RvcmUgZmlsZS4gV2lsbCBiZSBgbnVsbGAgaWYgdGhlcmVcbiAgICogYXJlIG5vIGVycm9ycy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgTGFzdEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBPbmUgb2YgYHNlcnZlcl9lcnJvcmAgb3IgYHJhdGVfbGltaXRfZXhjZWVkZWRgLlxuICAgICAqL1xuICAgIGNvZGU6ICdzZXJ2ZXJfZXJyb3InIHwgJ3Vuc3VwcG9ydGVkX2ZpbGUnIHwgJ2ludmFsaWRfZmlsZSc7XG5cbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvci5cbiAgICAgKi9cbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZUZpbGVEZWxldGVkIHtcbiAgaWQ6IHN0cmluZztcblxuICBkZWxldGVkOiBib29sZWFuO1xuXG4gIG9iamVjdDogJ3ZlY3Rvcl9zdG9yZS5maWxlLmRlbGV0ZWQnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogQSBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSUQgdGhhdCB0aGVcbiAgICogdmVjdG9yIHN0b3JlIHNob3VsZCB1c2UuIFVzZWZ1bCBmb3IgdG9vbHMgbGlrZSBgZmlsZV9zZWFyY2hgIHRoYXQgY2FuIGFjY2Vzc1xuICAgKiBmaWxlcy5cbiAgICovXG4gIGZpbGVfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGNodW5raW5nIHN0cmF0ZWd5IHVzZWQgdG8gY2h1bmsgdGhlIGZpbGUocykuIElmIG5vdCBzZXQsIHdpbGwgdXNlIHRoZSBgYXV0b2BcbiAgICogc3RyYXRlZ3kuIE9ubHkgYXBwbGljYWJsZSBpZiBgZmlsZV9pZHNgIGlzIG5vbi1lbXB0eS5cbiAgICovXG4gIGNodW5raW5nX3N0cmF0ZWd5PzogVmVjdG9yU3RvcmVzQVBJLkZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUxpc3RQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgY3Vyc29yIGZvciB1c2UgaW4gcGFnaW5hdGlvbi4gYGJlZm9yZWAgaXMgYW4gb2JqZWN0IElEIHRoYXQgZGVmaW5lcyB5b3VyIHBsYWNlXG4gICAqIGluIHRoZSBsaXN0LiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBtYWtlIGEgbGlzdCByZXF1ZXN0IGFuZCByZWNlaXZlIDEwMCBvYmplY3RzLFxuICAgKiBzdGFydGluZyB3aXRoIG9ial9mb28sIHlvdXIgc3Vic2VxdWVudCBjYWxsIGNhbiBpbmNsdWRlIGJlZm9yZT1vYmpfZm9vIGluIG9yZGVyXG4gICAqIHRvIGZldGNoIHRoZSBwcmV2aW91cyBwYWdlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgYmVmb3JlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGaWx0ZXIgYnkgZmlsZSBzdGF0dXMuIE9uZSBvZiBgaW5fcHJvZ3Jlc3NgLCBgY29tcGxldGVkYCwgYGZhaWxlZGAsIGBjYW5jZWxsZWRgLlxuICAgKi9cbiAgZmlsdGVyPzogJ2luX3Byb2dyZXNzJyB8ICdjb21wbGV0ZWQnIHwgJ2ZhaWxlZCcgfCAnY2FuY2VsbGVkJztcblxuICAvKipcbiAgICogU29ydCBvcmRlciBieSB0aGUgYGNyZWF0ZWRfYXRgIHRpbWVzdGFtcCBvZiB0aGUgb2JqZWN0cy4gYGFzY2AgZm9yIGFzY2VuZGluZ1xuICAgKiBvcmRlciBhbmQgYGRlc2NgIGZvciBkZXNjZW5kaW5nIG9yZGVyLlxuICAgKi9cbiAgb3JkZXI/OiAnYXNjJyB8ICdkZXNjJztcbn1cblxuRmlsZXMuVmVjdG9yU3RvcmVGaWxlc1BhZ2UgPSBWZWN0b3JTdG9yZUZpbGVzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEZpbGVzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIFZlY3RvclN0b3JlRmlsZSBhcyBWZWN0b3JTdG9yZUZpbGUsXG4gICAgdHlwZSBWZWN0b3JTdG9yZUZpbGVEZWxldGVkIGFzIFZlY3RvclN0b3JlRmlsZURlbGV0ZWQsXG4gICAgVmVjdG9yU3RvcmVGaWxlc1BhZ2UgYXMgVmVjdG9yU3RvcmVGaWxlc1BhZ2UsXG4gICAgdHlwZSBGaWxlQ3JlYXRlUGFyYW1zIGFzIEZpbGVDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBGaWxlTGlzdFBhcmFtcyBhcyBGaWxlTGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCB7IHNsZWVwIH0gZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgeyBVcGxvYWRhYmxlIH0gZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgeyBhbGxTZXR0bGVkV2l0aFRocm93IH0gZnJvbSAnLi4vLi4vLi4vbGliL1V0aWwnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIEZpbGVzQVBJIGZyb20gJy4vZmlsZXMnO1xuaW1wb3J0IHsgVmVjdG9yU3RvcmVGaWxlc1BhZ2UgfSBmcm9tICcuL2ZpbGVzJztcbmltcG9ydCAqIGFzIFZlY3RvclN0b3Jlc0FQSSBmcm9tICcuL3ZlY3Rvci1zdG9yZXMnO1xuaW1wb3J0IHsgdHlwZSBDdXJzb3JQYWdlUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vcGFnaW5hdGlvbic7XG5cbmV4cG9ydCBjbGFzcyBGaWxlQmF0Y2hlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIHZlY3RvciBzdG9yZSBmaWxlIGJhdGNoLlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBib2R5OiBGaWxlQmF0Y2hDcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVCYXRjaD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlX2JhdGNoZXNgLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgdmVjdG9yIHN0b3JlIGZpbGUgYmF0Y2guXG4gICAqL1xuICByZXRyaWV2ZShcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgYmF0Y2hJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VmVjdG9yU3RvcmVGaWxlQmF0Y2g+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlX2JhdGNoZXMvJHtiYXRjaElkfWAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCBhIHZlY3RvciBzdG9yZSBmaWxlIGJhdGNoLiBUaGlzIGF0dGVtcHRzIHRvIGNhbmNlbCB0aGUgcHJvY2Vzc2luZyBvZlxuICAgKiBmaWxlcyBpbiB0aGlzIGJhdGNoIGFzIHNvb24gYXMgcG9zc2libGUuXG4gICAqL1xuICBjYW5jZWwoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGJhdGNoSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFZlY3RvclN0b3JlRmlsZUJhdGNoPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9L2ZpbGVfYmF0Y2hlcy8ke2JhdGNoSWR9L2NhbmNlbGAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHZlY3RvciBzdG9yZSBiYXRjaCBhbmQgcG9sbCB1bnRpbCBhbGwgZmlsZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZC5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZUFuZFBvbGwoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGJvZHk6IEZpbGVCYXRjaENyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyAmIHsgcG9sbEludGVydmFsTXM/OiBudW1iZXIgfSxcbiAgKTogUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVCYXRjaD4ge1xuICAgIGNvbnN0IGJhdGNoID0gYXdhaXQgdGhpcy5jcmVhdGUodmVjdG9yU3RvcmVJZCwgYm9keSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucG9sbCh2ZWN0b3JTdG9yZUlkLCBiYXRjaC5pZCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIGZpbGVzIGluIGEgYmF0Y2guXG4gICAqL1xuICBsaXN0RmlsZXMoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGJhdGNoSWQ6IHN0cmluZyxcbiAgICBxdWVyeT86IEZpbGVCYXRjaExpc3RGaWxlc1BhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVzUGFnZSwgRmlsZXNBUEkuVmVjdG9yU3RvcmVGaWxlPjtcbiAgbGlzdEZpbGVzKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBiYXRjaElkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8VmVjdG9yU3RvcmVGaWxlc1BhZ2UsIEZpbGVzQVBJLlZlY3RvclN0b3JlRmlsZT47XG4gIGxpc3RGaWxlcyhcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgYmF0Y2hJZDogc3RyaW5nLFxuICAgIHF1ZXJ5OiBGaWxlQmF0Y2hMaXN0RmlsZXNQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8VmVjdG9yU3RvcmVGaWxlc1BhZ2UsIEZpbGVzQVBJLlZlY3RvclN0b3JlRmlsZT4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdEZpbGVzKHZlY3RvclN0b3JlSWQsIGJhdGNoSWQsIHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdChcbiAgICAgIGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9L2ZpbGVfYmF0Y2hlcy8ke2JhdGNoSWR9L2ZpbGVzYCxcbiAgICAgIFZlY3RvclN0b3JlRmlsZXNQYWdlLFxuICAgICAgeyBxdWVyeSwgLi4ub3B0aW9ucywgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSB9LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogV2FpdCBmb3IgdGhlIGdpdmVuIGZpbGUgYmF0Y2ggdG8gYmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBOb3RlOiB0aGlzIHdpbGwgcmV0dXJuIGV2ZW4gaWYgb25lIG9mIHRoZSBmaWxlcyBmYWlsZWQgdG8gcHJvY2VzcywgeW91IG5lZWQgdG9cbiAgICogY2hlY2sgYmF0Y2guZmlsZV9jb3VudHMuZmFpbGVkX2NvdW50IHRvIGhhbmRsZSB0aGlzIGNhc2UuXG4gICAqL1xuICBhc3luYyBwb2xsKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBiYXRjaElkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMgJiB7IHBvbGxJbnRlcnZhbE1zPzogbnVtYmVyIH0sXG4gICk6IFByb21pc2U8VmVjdG9yU3RvcmVGaWxlQmF0Y2g+IHtcbiAgICBjb25zdCBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0geyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtUG9sbC1IZWxwZXInOiAndHJ1ZScgfTtcbiAgICBpZiAob3B0aW9ucz8ucG9sbEludGVydmFsTXMpIHtcbiAgICAgIGhlYWRlcnNbJ1gtU3RhaW5sZXNzLUN1c3RvbS1Qb2xsLUludGVydmFsJ10gPSBvcHRpb25zLnBvbGxJbnRlcnZhbE1zLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZGF0YTogYmF0Y2gsIHJlc3BvbnNlIH0gPSBhd2FpdCB0aGlzLnJldHJpZXZlKHZlY3RvclN0b3JlSWQsIGJhdGNoSWQsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgIH0pLndpdGhSZXNwb25zZSgpO1xuXG4gICAgICBzd2l0Y2ggKGJhdGNoLnN0YXR1cykge1xuICAgICAgICBjYXNlICdpbl9wcm9ncmVzcyc6XG4gICAgICAgICAgbGV0IHNsZWVwSW50ZXJ2YWwgPSA1MDAwO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnM/LnBvbGxJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICBzbGVlcEludGVydmFsID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVySW50ZXJ2YWwgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnb3BlbmFpLXBvbGwtYWZ0ZXItbXMnKTtcbiAgICAgICAgICAgIGlmIChoZWFkZXJJbnRlcnZhbCkge1xuICAgICAgICAgICAgICBjb25zdCBoZWFkZXJJbnRlcnZhbE1zID0gcGFyc2VJbnQoaGVhZGVySW50ZXJ2YWwpO1xuICAgICAgICAgICAgICBpZiAoIWlzTmFOKGhlYWRlckludGVydmFsTXMpKSB7XG4gICAgICAgICAgICAgICAgc2xlZXBJbnRlcnZhbCA9IGhlYWRlckludGVydmFsTXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgc2xlZXAoc2xlZXBJbnRlcnZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgIGNhc2UgJ2NhbmNlbGxlZCc6XG4gICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgICAgcmV0dXJuIGJhdGNoO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGxvYWRzIHRoZSBnaXZlbiBmaWxlcyBjb25jdXJyZW50bHkgYW5kIHRoZW4gY3JlYXRlcyBhIHZlY3RvciBzdG9yZSBmaWxlIGJhdGNoLlxuICAgKlxuICAgKiBUaGUgY29uY3VycmVuY3kgbGltaXQgaXMgY29uZmlndXJhYmxlIHVzaW5nIHRoZSBgbWF4Q29uY3VycmVuY3lgIHBhcmFtZXRlci5cbiAgICovXG4gIGFzeW5jIHVwbG9hZEFuZFBvbGwoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIHsgZmlsZXMsIGZpbGVJZHMgPSBbXSB9OiB7IGZpbGVzOiBVcGxvYWRhYmxlW107IGZpbGVJZHM/OiBzdHJpbmdbXSB9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zICYgeyBwb2xsSW50ZXJ2YWxNcz86IG51bWJlcjsgbWF4Q29uY3VycmVuY3k/OiBudW1iZXIgfSxcbiAgKTogUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVCYXRjaD4ge1xuICAgIGlmIChmaWxlcyA9PSBudWxsIHx8IGZpbGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBObyBcXGBmaWxlc1xcYCBwcm92aWRlZCB0byBwcm9jZXNzLiBJZiB5b3UndmUgYWxyZWFkeSB1cGxvYWRlZCBmaWxlcyB5b3Ugc2hvdWxkIHVzZSBcXGAuY3JlYXRlQW5kUG9sbCgpXFxgIGluc3RlYWRgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25maWd1cmVkQ29uY3VycmVuY3kgPSBvcHRpb25zPy5tYXhDb25jdXJyZW5jeSA/PyA1O1xuXG4gICAgLy8gV2UgY2FwIHRoZSBudW1iZXIgb2Ygd29ya2VycyBhdCB0aGUgbnVtYmVyIG9mIGZpbGVzIChzbyB3ZSBkb24ndCBzdGFydCBhbnkgdW5uZWNlc3Nhcnkgd29ya2VycylcbiAgICBjb25zdCBjb25jdXJyZW5jeUxpbWl0ID0gTWF0aC5taW4oY29uZmlndXJlZENvbmN1cnJlbmN5LCBmaWxlcy5sZW5ndGgpO1xuXG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xuICAgIGNvbnN0IGZpbGVJdGVyYXRvciA9IGZpbGVzLnZhbHVlcygpO1xuICAgIGNvbnN0IGFsbEZpbGVJZHM6IHN0cmluZ1tdID0gWy4uLmZpbGVJZHNdO1xuXG4gICAgLy8gVGhpcyBjb2RlIGlzIGJhc2VkIG9uIHRoaXMgZGVzaWduLiBUaGUgbGlicmFyaWVzIGRvbid0IGFjY29tbW9kYXRlIG91ciBlbnZpcm9ubWVudCBsaW1pdHMuXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDA2Mzk0MzIvd2hhdC1pcy10aGUtYmVzdC13YXktdG8tbGltaXQtY29uY3VycmVuY3ktd2hlbi11c2luZy1lczZzLXByb21pc2UtYWxsXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0ZpbGVzKGl0ZXJhdG9yOiBJdGVyYWJsZUl0ZXJhdG9yPFVwbG9hZGFibGU+KSB7XG4gICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgIGNvbnN0IGZpbGVPYmogPSBhd2FpdCBjbGllbnQuZmlsZXMuY3JlYXRlKHsgZmlsZTogaXRlbSwgcHVycG9zZTogJ2Fzc2lzdGFudHMnIH0sIG9wdGlvbnMpO1xuICAgICAgICBhbGxGaWxlSWRzLnB1c2goZmlsZU9iai5pZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgd29ya2VycyB0byBwcm9jZXNzIHJlc3VsdHNcbiAgICBjb25zdCB3b3JrZXJzID0gQXJyYXkoY29uY3VycmVuY3lMaW1pdCkuZmlsbChmaWxlSXRlcmF0b3IpLm1hcChwcm9jZXNzRmlsZXMpO1xuXG4gICAgLy8gV2FpdCBmb3IgYWxsIHByb2Nlc3NpbmcgdG8gY29tcGxldGUuXG4gICAgYXdhaXQgYWxsU2V0dGxlZFdpdGhUaHJvdyh3b3JrZXJzKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZUFuZFBvbGwodmVjdG9yU3RvcmVJZCwge1xuICAgICAgZmlsZV9pZHM6IGFsbEZpbGVJZHMsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGJhdGNoIG9mIGZpbGVzIGF0dGFjaGVkIHRvIGEgdmVjdG9yIHN0b3JlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlRmlsZUJhdGNoIHtcbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgdmVjdG9yIHN0b3JlIGZpbGVzIGJhdGNoIHdhc1xuICAgKiBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIGZpbGVfY291bnRzOiBWZWN0b3JTdG9yZUZpbGVCYXRjaC5GaWxlQ291bnRzO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgdmVjdG9yX3N0b3JlLmZpbGVfYmF0Y2hgLlxuICAgKi9cbiAgb2JqZWN0OiAndmVjdG9yX3N0b3JlLmZpbGVzX2JhdGNoJztcblxuICAvKipcbiAgICogVGhlIHN0YXR1cyBvZiB0aGUgdmVjdG9yIHN0b3JlIGZpbGVzIGJhdGNoLCB3aGljaCBjYW4gYmUgZWl0aGVyIGBpbl9wcm9ncmVzc2AsXG4gICAqIGBjb21wbGV0ZWRgLCBgY2FuY2VsbGVkYCBvciBgZmFpbGVkYC5cbiAgICovXG4gIHN0YXR1czogJ2luX3Byb2dyZXNzJyB8ICdjb21wbGV0ZWQnIHwgJ2NhbmNlbGxlZCcgfCAnZmFpbGVkJztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZVxuICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgKiB0aGF0IHRoZSBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgaXNcbiAgICogYXR0YWNoZWQgdG8uXG4gICAqL1xuICB2ZWN0b3Jfc3RvcmVfaWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBWZWN0b3JTdG9yZUZpbGVCYXRjaCB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRmlsZUNvdW50cyB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBmaWxlcyB0aGF0IHdoZXJlIGNhbmNlbGxlZC5cbiAgICAgKi9cbiAgICBjYW5jZWxsZWQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZmlsZXMgdGhhdCBoYXZlIGJlZW4gcHJvY2Vzc2VkLlxuICAgICAqL1xuICAgIGNvbXBsZXRlZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBmaWxlcyB0aGF0IGhhdmUgZmFpbGVkIHRvIHByb2Nlc3MuXG4gICAgICovXG4gICAgZmFpbGVkOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGZpbGVzIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQuXG4gICAgICovXG4gICAgaW5fcHJvZ3Jlc3M6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgZmlsZXMuXG4gICAgICovXG4gICAgdG90YWw6IG51bWJlcjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVCYXRjaENyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyB0aGF0XG4gICAqIHRoZSB2ZWN0b3Igc3RvcmUgc2hvdWxkIHVzZS4gVXNlZnVsIGZvciB0b29scyBsaWtlIGBmaWxlX3NlYXJjaGAgdGhhdCBjYW4gYWNjZXNzXG4gICAqIGZpbGVzLlxuICAgKi9cbiAgZmlsZV9pZHM6IEFycmF5PHN0cmluZz47XG5cbiAgLyoqXG4gICAqIFRoZSBjaHVua2luZyBzdHJhdGVneSB1c2VkIHRvIGNodW5rIHRoZSBmaWxlKHMpLiBJZiBub3Qgc2V0LCB3aWxsIHVzZSB0aGUgYGF1dG9gXG4gICAqIHN0cmF0ZWd5LiBPbmx5IGFwcGxpY2FibGUgaWYgYGZpbGVfaWRzYCBpcyBub24tZW1wdHkuXG4gICAqL1xuICBjaHVua2luZ19zdHJhdGVneT86IFZlY3RvclN0b3Jlc0FQSS5GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVCYXRjaExpc3RGaWxlc1BhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge1xuICAvKipcbiAgICogQSBjdXJzb3IgZm9yIHVzZSBpbiBwYWdpbmF0aW9uLiBgYmVmb3JlYCBpcyBhbiBvYmplY3QgSUQgdGhhdCBkZWZpbmVzIHlvdXIgcGxhY2VcbiAgICogaW4gdGhlIGxpc3QuIEZvciBpbnN0YW5jZSwgaWYgeW91IG1ha2UgYSBsaXN0IHJlcXVlc3QgYW5kIHJlY2VpdmUgMTAwIG9iamVjdHMsXG4gICAqIHN0YXJ0aW5nIHdpdGggb2JqX2ZvbywgeW91ciBzdWJzZXF1ZW50IGNhbGwgY2FuIGluY2x1ZGUgYmVmb3JlPW9ial9mb28gaW4gb3JkZXJcbiAgICogdG8gZmV0Y2ggdGhlIHByZXZpb3VzIHBhZ2Ugb2YgdGhlIGxpc3QuXG4gICAqL1xuICBiZWZvcmU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZpbHRlciBieSBmaWxlIHN0YXR1cy4gT25lIG9mIGBpbl9wcm9ncmVzc2AsIGBjb21wbGV0ZWRgLCBgZmFpbGVkYCwgYGNhbmNlbGxlZGAuXG4gICAqL1xuICBmaWx0ZXI/OiAnaW5fcHJvZ3Jlc3MnIHwgJ2NvbXBsZXRlZCcgfCAnZmFpbGVkJyB8ICdjYW5jZWxsZWQnO1xuXG4gIC8qKlxuICAgKiBTb3J0IG9yZGVyIGJ5IHRoZSBgY3JlYXRlZF9hdGAgdGltZXN0YW1wIG9mIHRoZSBvYmplY3RzLiBgYXNjYCBmb3IgYXNjZW5kaW5nXG4gICAqIG9yZGVyIGFuZCBgZGVzY2AgZm9yIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAqL1xuICBvcmRlcj86ICdhc2MnIHwgJ2Rlc2MnO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgRmlsZUJhdGNoZXMge1xuICBleHBvcnQge1xuICAgIHR5cGUgVmVjdG9yU3RvcmVGaWxlQmF0Y2ggYXMgVmVjdG9yU3RvcmVGaWxlQmF0Y2gsXG4gICAgdHlwZSBGaWxlQmF0Y2hDcmVhdGVQYXJhbXMgYXMgRmlsZUJhdGNoQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgRmlsZUJhdGNoTGlzdEZpbGVzUGFyYW1zIGFzIEZpbGVCYXRjaExpc3RGaWxlc1BhcmFtcyxcbiAgfTtcbn1cblxuZXhwb3J0IHsgVmVjdG9yU3RvcmVGaWxlc1BhZ2UgfTtcbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBGaWxlQmF0Y2hlc0FQSSBmcm9tICcuL2ZpbGUtYmF0Y2hlcyc7XG5pbXBvcnQge1xuICBGaWxlQmF0Y2hDcmVhdGVQYXJhbXMsXG4gIEZpbGVCYXRjaExpc3RGaWxlc1BhcmFtcyxcbiAgRmlsZUJhdGNoZXMsXG4gIFZlY3RvclN0b3JlRmlsZUJhdGNoLFxufSBmcm9tICcuL2ZpbGUtYmF0Y2hlcyc7XG5pbXBvcnQgKiBhcyBGaWxlc0FQSSBmcm9tICcuL2ZpbGVzJztcbmltcG9ydCB7XG4gIEZpbGVDcmVhdGVQYXJhbXMsXG4gIEZpbGVMaXN0UGFyYW1zLFxuICBGaWxlcyxcbiAgVmVjdG9yU3RvcmVGaWxlLFxuICBWZWN0b3JTdG9yZUZpbGVEZWxldGVkLFxuICBWZWN0b3JTdG9yZUZpbGVzUGFnZSxcbn0gZnJvbSAnLi9maWxlcyc7XG5pbXBvcnQgeyBDdXJzb3JQYWdlLCB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9wYWdpbmF0aW9uJztcblxuZXhwb3J0IGNsYXNzIFZlY3RvclN0b3JlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgZmlsZXM6IEZpbGVzQVBJLkZpbGVzID0gbmV3IEZpbGVzQVBJLkZpbGVzKHRoaXMuX2NsaWVudCk7XG4gIGZpbGVCYXRjaGVzOiBGaWxlQmF0Y2hlc0FQSS5GaWxlQmF0Y2hlcyA9IG5ldyBGaWxlQmF0Y2hlc0FQSS5GaWxlQmF0Y2hlcyh0aGlzLl9jbGllbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICBjcmVhdGUoYm9keTogVmVjdG9yU3RvcmVDcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFZlY3RvclN0b3JlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvdmVjdG9yX3N0b3JlcycsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICByZXRyaWV2ZSh2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFZlY3RvclN0b3JlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZmllcyBhIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIHVwZGF0ZShcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgYm9keTogVmVjdG9yU3RvcmVVcGRhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxWZWN0b3JTdG9yZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfWAsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVzLlxuICAgKi9cbiAgbGlzdChcbiAgICBxdWVyeT86IFZlY3RvclN0b3JlTGlzdFBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxWZWN0b3JTdG9yZXNQYWdlLCBWZWN0b3JTdG9yZT47XG4gIGxpc3Qob3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPFZlY3RvclN0b3Jlc1BhZ2UsIFZlY3RvclN0b3JlPjtcbiAgbGlzdChcbiAgICBxdWVyeTogVmVjdG9yU3RvcmVMaXN0UGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFZlY3RvclN0b3Jlc1BhZ2UsIFZlY3RvclN0b3JlPiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0KHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdCgnL3ZlY3Rvcl9zdG9yZXMnLCBWZWN0b3JTdG9yZXNQYWdlLCB7XG4gICAgICBxdWVyeSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIGRlbCh2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFZlY3RvclN0b3JlRGVsZXRlZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZGVsZXRlKGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFZlY3RvclN0b3Jlc1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlPFZlY3RvclN0b3JlPiB7fVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHN0cmF0ZWd5LiBUaGlzIHN0cmF0ZWd5IGN1cnJlbnRseSB1c2VzIGEgYG1heF9jaHVua19zaXplX3Rva2Vuc2Agb2ZcbiAqIGA4MDBgIGFuZCBgY2h1bmtfb3ZlcmxhcF90b2tlbnNgIG9mIGA0MDBgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEF1dG9GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtIHtcbiAgLyoqXG4gICAqIEFsd2F5cyBgYXV0b2AuXG4gICAqL1xuICB0eXBlOiAnYXV0byc7XG59XG5cbi8qKlxuICogVGhlIHN0cmF0ZWd5IHVzZWQgdG8gY2h1bmsgdGhlIGZpbGUuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbGVDaHVua2luZ1N0cmF0ZWd5ID0gU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QgfCBPdGhlckZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0O1xuXG4vKipcbiAqIFRoZSBjaHVua2luZyBzdHJhdGVneSB1c2VkIHRvIGNodW5rIHRoZSBmaWxlKHMpLiBJZiBub3Qgc2V0LCB3aWxsIHVzZSB0aGUgYGF1dG9gXG4gKiBzdHJhdGVneS4gT25seSBhcHBsaWNhYmxlIGlmIGBmaWxlX2lkc2AgaXMgbm9uLWVtcHR5LlxuICovXG5leHBvcnQgdHlwZSBGaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtID0gQXV0b0ZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0gfCBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdFBhcmFtO1xuXG4vKipcbiAqIFRoaXMgaXMgcmV0dXJuZWQgd2hlbiB0aGUgY2h1bmtpbmcgc3RyYXRlZ3kgaXMgdW5rbm93bi4gVHlwaWNhbGx5LCB0aGlzIGlzXG4gKiBiZWNhdXNlIHRoZSBmaWxlIHdhcyBpbmRleGVkIGJlZm9yZSB0aGUgYGNodW5raW5nX3N0cmF0ZWd5YCBjb25jZXB0IHdhc1xuICogaW50cm9kdWNlZCBpbiB0aGUgQVBJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE90aGVyRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3Qge1xuICAvKipcbiAgICogQWx3YXlzIGBvdGhlcmAuXG4gICAqL1xuICB0eXBlOiAnb3RoZXInO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5IHtcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgdG9rZW5zIHRoYXQgb3ZlcmxhcCBiZXR3ZWVuIGNodW5rcy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDQwMGAuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgb3ZlcmxhcCBtdXN0IG5vdCBleGNlZWQgaGFsZiBvZiBgbWF4X2NodW5rX3NpemVfdG9rZW5zYC5cbiAgICovXG4gIGNodW5rX292ZXJsYXBfdG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0b2tlbnMgaW4gZWFjaCBjaHVuay4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDgwMGAuIFRoZVxuICAgKiBtaW5pbXVtIHZhbHVlIGlzIGAxMDBgIGFuZCB0aGUgbWF4aW11bSB2YWx1ZSBpcyBgNDA5NmAuXG4gICAqL1xuICBtYXhfY2h1bmtfc2l6ZV90b2tlbnM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdCB7XG4gIHN0YXRpYzogU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3k7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgc3RhdGljYC5cbiAgICovXG4gIHR5cGU6ICdzdGF0aWMnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0UGFyYW0ge1xuICBzdGF0aWM6IFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5O1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYHN0YXRpY2AuXG4gICAqL1xuICB0eXBlOiAnc3RhdGljJztcbn1cblxuLyoqXG4gKiBBIHZlY3RvciBzdG9yZSBpcyBhIGNvbGxlY3Rpb24gb2YgcHJvY2Vzc2VkIGZpbGVzIGNhbiBiZSB1c2VkIGJ5IHRoZVxuICogYGZpbGVfc2VhcmNoYCB0b29sLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlIHtcbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgdmVjdG9yIHN0b3JlIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIGZpbGVfY291bnRzOiBWZWN0b3JTdG9yZS5GaWxlQ291bnRzO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSB2ZWN0b3Igc3RvcmUgd2FzIGxhc3QgYWN0aXZlLlxuICAgKi9cbiAgbGFzdF9hY3RpdmVfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhOiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYHZlY3Rvcl9zdG9yZWAuXG4gICAqL1xuICBvYmplY3Q6ICd2ZWN0b3Jfc3RvcmUnO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhdHVzIG9mIHRoZSB2ZWN0b3Igc3RvcmUsIHdoaWNoIGNhbiBiZSBlaXRoZXIgYGV4cGlyZWRgLCBgaW5fcHJvZ3Jlc3NgLCBvclxuICAgKiBgY29tcGxldGVkYC4gQSBzdGF0dXMgb2YgYGNvbXBsZXRlZGAgaW5kaWNhdGVzIHRoYXQgdGhlIHZlY3RvciBzdG9yZSBpcyByZWFkeVxuICAgKiBmb3IgdXNlLlxuICAgKi9cbiAgc3RhdHVzOiAnZXhwaXJlZCcgfCAnaW5fcHJvZ3Jlc3MnIHwgJ2NvbXBsZXRlZCc7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgdXNlZCBieSB0aGUgZmlsZXMgaW4gdGhlIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIHVzYWdlX2J5dGVzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBleHBpcmF0aW9uIHBvbGljeSBmb3IgYSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICBleHBpcmVzX2FmdGVyPzogVmVjdG9yU3RvcmUuRXhwaXJlc0FmdGVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSB2ZWN0b3Igc3RvcmUgd2lsbCBleHBpcmUuXG4gICAqL1xuICBleHBpcmVzX2F0PzogbnVtYmVyIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBWZWN0b3JTdG9yZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRmlsZUNvdW50cyB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBmaWxlcyB0aGF0IHdlcmUgY2FuY2VsbGVkLlxuICAgICAqL1xuICAgIGNhbmNlbGxlZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBmaWxlcyB0aGF0IGhhdmUgYmVlbiBzdWNjZXNzZnVsbHkgcHJvY2Vzc2VkLlxuICAgICAqL1xuICAgIGNvbXBsZXRlZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBmaWxlcyB0aGF0IGhhdmUgZmFpbGVkIHRvIHByb2Nlc3MuXG4gICAgICovXG4gICAgZmFpbGVkOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGZpbGVzIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQuXG4gICAgICovXG4gICAgaW5fcHJvZ3Jlc3M6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgZmlsZXMuXG4gICAgICovXG4gICAgdG90YWw6IG51bWJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZXhwaXJhdGlvbiBwb2xpY3kgZm9yIGEgdmVjdG9yIHN0b3JlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBFeHBpcmVzQWZ0ZXIge1xuICAgIC8qKlxuICAgICAqIEFuY2hvciB0aW1lc3RhbXAgYWZ0ZXIgd2hpY2ggdGhlIGV4cGlyYXRpb24gcG9saWN5IGFwcGxpZXMuIFN1cHBvcnRlZCBhbmNob3JzOlxuICAgICAqIGBsYXN0X2FjdGl2ZV9hdGAuXG4gICAgICovXG4gICAgYW5jaG9yOiAnbGFzdF9hY3RpdmVfYXQnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBkYXlzIGFmdGVyIHRoZSBhbmNob3IgdGltZSB0aGF0IHRoZSB2ZWN0b3Igc3RvcmUgd2lsbCBleHBpcmUuXG4gICAgICovXG4gICAgZGF5czogbnVtYmVyO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmVEZWxldGVkIHtcbiAgaWQ6IHN0cmluZztcblxuICBkZWxldGVkOiBib29sZWFuO1xuXG4gIG9iamVjdDogJ3ZlY3Rvcl9zdG9yZS5kZWxldGVkJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZUNyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgY2h1bmtpbmcgc3RyYXRlZ3kgdXNlZCB0byBjaHVuayB0aGUgZmlsZShzKS4gSWYgbm90IHNldCwgd2lsbCB1c2UgdGhlIGBhdXRvYFxuICAgKiBzdHJhdGVneS4gT25seSBhcHBsaWNhYmxlIGlmIGBmaWxlX2lkc2AgaXMgbm9uLWVtcHR5LlxuICAgKi9cbiAgY2h1bmtpbmdfc3RyYXRlZ3k/OiBGaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtO1xuXG4gIC8qKlxuICAgKiBUaGUgZXhwaXJhdGlvbiBwb2xpY3kgZm9yIGEgdmVjdG9yIHN0b3JlLlxuICAgKi9cbiAgZXhwaXJlc19hZnRlcj86IFZlY3RvclN0b3JlQ3JlYXRlUGFyYW1zLkV4cGlyZXNBZnRlcjtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgdGhhdFxuICAgKiB0aGUgdmVjdG9yIHN0b3JlIHNob3VsZCB1c2UuIFVzZWZ1bCBmb3IgdG9vbHMgbGlrZSBgZmlsZV9zZWFyY2hgIHRoYXQgY2FuIGFjY2Vzc1xuICAgKiBmaWxlcy5cbiAgICovXG4gIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVmVjdG9yU3RvcmVDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIGV4cGlyYXRpb24gcG9saWN5IGZvciBhIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXhwaXJlc0FmdGVyIHtcbiAgICAvKipcbiAgICAgKiBBbmNob3IgdGltZXN0YW1wIGFmdGVyIHdoaWNoIHRoZSBleHBpcmF0aW9uIHBvbGljeSBhcHBsaWVzLiBTdXBwb3J0ZWQgYW5jaG9yczpcbiAgICAgKiBgbGFzdF9hY3RpdmVfYXRgLlxuICAgICAqL1xuICAgIGFuY2hvcjogJ2xhc3RfYWN0aXZlX2F0JztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZGF5cyBhZnRlciB0aGUgYW5jaG9yIHRpbWUgdGhhdCB0aGUgdmVjdG9yIHN0b3JlIHdpbGwgZXhwaXJlLlxuICAgICAqL1xuICAgIGRheXM6IG51bWJlcjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlVXBkYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBleHBpcmF0aW9uIHBvbGljeSBmb3IgYSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICBleHBpcmVzX2FmdGVyPzogVmVjdG9yU3RvcmVVcGRhdGVQYXJhbXMuRXhwaXJlc0FmdGVyIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFZlY3RvclN0b3JlVXBkYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBleHBpcmF0aW9uIHBvbGljeSBmb3IgYSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEV4cGlyZXNBZnRlciB7XG4gICAgLyoqXG4gICAgICogQW5jaG9yIHRpbWVzdGFtcCBhZnRlciB3aGljaCB0aGUgZXhwaXJhdGlvbiBwb2xpY3kgYXBwbGllcy4gU3VwcG9ydGVkIGFuY2hvcnM6XG4gICAgICogYGxhc3RfYWN0aXZlX2F0YC5cbiAgICAgKi9cbiAgICBhbmNob3I6ICdsYXN0X2FjdGl2ZV9hdCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRheXMgYWZ0ZXIgdGhlIGFuY2hvciB0aW1lIHRoYXQgdGhlIHZlY3RvciBzdG9yZSB3aWxsIGV4cGlyZS5cbiAgICAgKi9cbiAgICBkYXlzOiBudW1iZXI7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZUxpc3RQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgY3Vyc29yIGZvciB1c2UgaW4gcGFnaW5hdGlvbi4gYGJlZm9yZWAgaXMgYW4gb2JqZWN0IElEIHRoYXQgZGVmaW5lcyB5b3VyIHBsYWNlXG4gICAqIGluIHRoZSBsaXN0LiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBtYWtlIGEgbGlzdCByZXF1ZXN0IGFuZCByZWNlaXZlIDEwMCBvYmplY3RzLFxuICAgKiBzdGFydGluZyB3aXRoIG9ial9mb28sIHlvdXIgc3Vic2VxdWVudCBjYWxsIGNhbiBpbmNsdWRlIGJlZm9yZT1vYmpfZm9vIGluIG9yZGVyXG4gICAqIHRvIGZldGNoIHRoZSBwcmV2aW91cyBwYWdlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgYmVmb3JlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTb3J0IG9yZGVyIGJ5IHRoZSBgY3JlYXRlZF9hdGAgdGltZXN0YW1wIG9mIHRoZSBvYmplY3RzLiBgYXNjYCBmb3IgYXNjZW5kaW5nXG4gICAqIG9yZGVyIGFuZCBgZGVzY2AgZm9yIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAqL1xuICBvcmRlcj86ICdhc2MnIHwgJ2Rlc2MnO1xufVxuXG5WZWN0b3JTdG9yZXMuVmVjdG9yU3RvcmVzUGFnZSA9IFZlY3RvclN0b3Jlc1BhZ2U7XG5WZWN0b3JTdG9yZXMuRmlsZXMgPSBGaWxlcztcblZlY3RvclN0b3Jlcy5WZWN0b3JTdG9yZUZpbGVzUGFnZSA9IFZlY3RvclN0b3JlRmlsZXNQYWdlO1xuVmVjdG9yU3RvcmVzLkZpbGVCYXRjaGVzID0gRmlsZUJhdGNoZXM7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBWZWN0b3JTdG9yZXMge1xuICBleHBvcnQge1xuICAgIHR5cGUgQXV0b0ZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0gYXMgQXV0b0ZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0sXG4gICAgdHlwZSBGaWxlQ2h1bmtpbmdTdHJhdGVneSBhcyBGaWxlQ2h1bmtpbmdTdHJhdGVneSxcbiAgICB0eXBlIEZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0gYXMgRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbSxcbiAgICB0eXBlIE90aGVyRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QgYXMgT3RoZXJGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdCxcbiAgICB0eXBlIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5IGFzIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5LFxuICAgIHR5cGUgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QgYXMgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QsXG4gICAgdHlwZSBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdFBhcmFtIGFzIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0UGFyYW0sXG4gICAgdHlwZSBWZWN0b3JTdG9yZSBhcyBWZWN0b3JTdG9yZSxcbiAgICB0eXBlIFZlY3RvclN0b3JlRGVsZXRlZCBhcyBWZWN0b3JTdG9yZURlbGV0ZWQsXG4gICAgVmVjdG9yU3RvcmVzUGFnZSBhcyBWZWN0b3JTdG9yZXNQYWdlLFxuICAgIHR5cGUgVmVjdG9yU3RvcmVDcmVhdGVQYXJhbXMgYXMgVmVjdG9yU3RvcmVDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBWZWN0b3JTdG9yZVVwZGF0ZVBhcmFtcyBhcyBWZWN0b3JTdG9yZVVwZGF0ZVBhcmFtcyxcbiAgICB0eXBlIFZlY3RvclN0b3JlTGlzdFBhcmFtcyBhcyBWZWN0b3JTdG9yZUxpc3RQYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHtcbiAgICBGaWxlcyBhcyBGaWxlcyxcbiAgICB0eXBlIFZlY3RvclN0b3JlRmlsZSBhcyBWZWN0b3JTdG9yZUZpbGUsXG4gICAgdHlwZSBWZWN0b3JTdG9yZUZpbGVEZWxldGVkIGFzIFZlY3RvclN0b3JlRmlsZURlbGV0ZWQsXG4gICAgVmVjdG9yU3RvcmVGaWxlc1BhZ2UgYXMgVmVjdG9yU3RvcmVGaWxlc1BhZ2UsXG4gICAgdHlwZSBGaWxlQ3JlYXRlUGFyYW1zIGFzIEZpbGVDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBGaWxlTGlzdFBhcmFtcyBhcyBGaWxlTGlzdFBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIEZpbGVCYXRjaGVzIGFzIEZpbGVCYXRjaGVzLFxuICAgIHR5cGUgVmVjdG9yU3RvcmVGaWxlQmF0Y2ggYXMgVmVjdG9yU3RvcmVGaWxlQmF0Y2gsXG4gICAgdHlwZSBGaWxlQmF0Y2hDcmVhdGVQYXJhbXMgYXMgRmlsZUJhdGNoQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgRmlsZUJhdGNoTGlzdEZpbGVzUGFyYW1zIGFzIEZpbGVCYXRjaExpc3RGaWxlc1BhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIEFzc2lzdGFudHNBUEkgZnJvbSAnLi9hc3Npc3RhbnRzJztcbmltcG9ydCAqIGFzIENoYXRBUEkgZnJvbSAnLi9jaGF0L2NoYXQnO1xuaW1wb3J0IHtcbiAgQXNzaXN0YW50LFxuICBBc3Npc3RhbnRDcmVhdGVQYXJhbXMsXG4gIEFzc2lzdGFudERlbGV0ZWQsXG4gIEFzc2lzdGFudExpc3RQYXJhbXMsXG4gIEFzc2lzdGFudFN0cmVhbUV2ZW50LFxuICBBc3Npc3RhbnRUb29sLFxuICBBc3Npc3RhbnRVcGRhdGVQYXJhbXMsXG4gIEFzc2lzdGFudHMsXG4gIEFzc2lzdGFudHNQYWdlLFxuICBDb2RlSW50ZXJwcmV0ZXJUb29sLFxuICBGaWxlU2VhcmNoVG9vbCxcbiAgRnVuY3Rpb25Ub29sLFxuICBNZXNzYWdlU3RyZWFtRXZlbnQsXG4gIFJ1blN0ZXBTdHJlYW1FdmVudCxcbiAgUnVuU3RyZWFtRXZlbnQsXG4gIFRocmVhZFN0cmVhbUV2ZW50LFxufSBmcm9tICcuL2Fzc2lzdGFudHMnO1xuaW1wb3J0ICogYXMgUmVhbHRpbWVBUEkgZnJvbSAnLi9yZWFsdGltZS9yZWFsdGltZSc7XG5pbXBvcnQgeyBSZWFsdGltZSB9IGZyb20gJy4vcmVhbHRpbWUvcmVhbHRpbWUnO1xuaW1wb3J0ICogYXMgVGhyZWFkc0FQSSBmcm9tICcuL3RocmVhZHMvdGhyZWFkcyc7XG5pbXBvcnQge1xuICBBc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbixcbiAgQXNzaXN0YW50VG9vbENob2ljZSxcbiAgQXNzaXN0YW50VG9vbENob2ljZUZ1bmN0aW9uLFxuICBBc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uLFxuICBUaHJlYWQsXG4gIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtcyxcbiAgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zTm9uU3RyZWFtaW5nLFxuICBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNTdHJlYW1pbmcsXG4gIFRocmVhZENyZWF0ZUFuZFJ1blBvbGxQYXJhbXMsXG4gIFRocmVhZENyZWF0ZUFuZFJ1blN0cmVhbVBhcmFtcyxcbiAgVGhyZWFkQ3JlYXRlUGFyYW1zLFxuICBUaHJlYWREZWxldGVkLFxuICBUaHJlYWRVcGRhdGVQYXJhbXMsXG4gIFRocmVhZHMsXG59IGZyb20gJy4vdGhyZWFkcy90aHJlYWRzJztcbmltcG9ydCAqIGFzIFZlY3RvclN0b3Jlc0FQSSBmcm9tICcuL3ZlY3Rvci1zdG9yZXMvdmVjdG9yLXN0b3Jlcyc7XG5pbXBvcnQge1xuICBBdXRvRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbSxcbiAgRmlsZUNodW5raW5nU3RyYXRlZ3ksXG4gIEZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0sXG4gIE90aGVyRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QsXG4gIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5LFxuICBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdCxcbiAgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3RQYXJhbSxcbiAgVmVjdG9yU3RvcmUsXG4gIFZlY3RvclN0b3JlQ3JlYXRlUGFyYW1zLFxuICBWZWN0b3JTdG9yZURlbGV0ZWQsXG4gIFZlY3RvclN0b3JlTGlzdFBhcmFtcyxcbiAgVmVjdG9yU3RvcmVVcGRhdGVQYXJhbXMsXG4gIFZlY3RvclN0b3JlcyxcbiAgVmVjdG9yU3RvcmVzUGFnZSxcbn0gZnJvbSAnLi92ZWN0b3Itc3RvcmVzL3ZlY3Rvci1zdG9yZXMnO1xuaW1wb3J0IHsgQ2hhdCB9IGZyb20gJy4vY2hhdC9jaGF0JztcblxuZXhwb3J0IGNsYXNzIEJldGEgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIHJlYWx0aW1lOiBSZWFsdGltZUFQSS5SZWFsdGltZSA9IG5ldyBSZWFsdGltZUFQSS5SZWFsdGltZSh0aGlzLl9jbGllbnQpO1xuICB2ZWN0b3JTdG9yZXM6IFZlY3RvclN0b3Jlc0FQSS5WZWN0b3JTdG9yZXMgPSBuZXcgVmVjdG9yU3RvcmVzQVBJLlZlY3RvclN0b3Jlcyh0aGlzLl9jbGllbnQpO1xuICBjaGF0OiBDaGF0QVBJLkNoYXQgPSBuZXcgQ2hhdEFQSS5DaGF0KHRoaXMuX2NsaWVudCk7XG4gIGFzc2lzdGFudHM6IEFzc2lzdGFudHNBUEkuQXNzaXN0YW50cyA9IG5ldyBBc3Npc3RhbnRzQVBJLkFzc2lzdGFudHModGhpcy5fY2xpZW50KTtcbiAgdGhyZWFkczogVGhyZWFkc0FQSS5UaHJlYWRzID0gbmV3IFRocmVhZHNBUEkuVGhyZWFkcyh0aGlzLl9jbGllbnQpO1xufVxuXG5CZXRhLlJlYWx0aW1lID0gUmVhbHRpbWU7XG5CZXRhLlZlY3RvclN0b3JlcyA9IFZlY3RvclN0b3JlcztcbkJldGEuVmVjdG9yU3RvcmVzUGFnZSA9IFZlY3RvclN0b3Jlc1BhZ2U7XG5CZXRhLkFzc2lzdGFudHMgPSBBc3Npc3RhbnRzO1xuQmV0YS5Bc3Npc3RhbnRzUGFnZSA9IEFzc2lzdGFudHNQYWdlO1xuQmV0YS5UaHJlYWRzID0gVGhyZWFkcztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEJldGEge1xuICBleHBvcnQgeyBSZWFsdGltZSBhcyBSZWFsdGltZSB9O1xuXG4gIGV4cG9ydCB7XG4gICAgVmVjdG9yU3RvcmVzIGFzIFZlY3RvclN0b3JlcyxcbiAgICB0eXBlIEF1dG9GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtIGFzIEF1dG9GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtLFxuICAgIHR5cGUgRmlsZUNodW5raW5nU3RyYXRlZ3kgYXMgRmlsZUNodW5raW5nU3RyYXRlZ3ksXG4gICAgdHlwZSBGaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtIGFzIEZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0sXG4gICAgdHlwZSBPdGhlckZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0IGFzIE90aGVyRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QsXG4gICAgdHlwZSBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneSBhcyBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneSxcbiAgICB0eXBlIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0IGFzIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0LFxuICAgIHR5cGUgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3RQYXJhbSBhcyBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdFBhcmFtLFxuICAgIHR5cGUgVmVjdG9yU3RvcmUgYXMgVmVjdG9yU3RvcmUsXG4gICAgdHlwZSBWZWN0b3JTdG9yZURlbGV0ZWQgYXMgVmVjdG9yU3RvcmVEZWxldGVkLFxuICAgIFZlY3RvclN0b3Jlc1BhZ2UgYXMgVmVjdG9yU3RvcmVzUGFnZSxcbiAgICB0eXBlIFZlY3RvclN0b3JlQ3JlYXRlUGFyYW1zIGFzIFZlY3RvclN0b3JlQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgVmVjdG9yU3RvcmVVcGRhdGVQYXJhbXMgYXMgVmVjdG9yU3RvcmVVcGRhdGVQYXJhbXMsXG4gICAgdHlwZSBWZWN0b3JTdG9yZUxpc3RQYXJhbXMgYXMgVmVjdG9yU3RvcmVMaXN0UGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7IENoYXQgfTtcblxuICBleHBvcnQge1xuICAgIEFzc2lzdGFudHMgYXMgQXNzaXN0YW50cyxcbiAgICB0eXBlIEFzc2lzdGFudCBhcyBBc3Npc3RhbnQsXG4gICAgdHlwZSBBc3Npc3RhbnREZWxldGVkIGFzIEFzc2lzdGFudERlbGV0ZWQsXG4gICAgdHlwZSBBc3Npc3RhbnRTdHJlYW1FdmVudCBhcyBBc3Npc3RhbnRTdHJlYW1FdmVudCxcbiAgICB0eXBlIEFzc2lzdGFudFRvb2wgYXMgQXNzaXN0YW50VG9vbCxcbiAgICB0eXBlIENvZGVJbnRlcnByZXRlclRvb2wgYXMgQ29kZUludGVycHJldGVyVG9vbCxcbiAgICB0eXBlIEZpbGVTZWFyY2hUb29sIGFzIEZpbGVTZWFyY2hUb29sLFxuICAgIHR5cGUgRnVuY3Rpb25Ub29sIGFzIEZ1bmN0aW9uVG9vbCxcbiAgICB0eXBlIE1lc3NhZ2VTdHJlYW1FdmVudCBhcyBNZXNzYWdlU3RyZWFtRXZlbnQsXG4gICAgdHlwZSBSdW5TdGVwU3RyZWFtRXZlbnQgYXMgUnVuU3RlcFN0cmVhbUV2ZW50LFxuICAgIHR5cGUgUnVuU3RyZWFtRXZlbnQgYXMgUnVuU3RyZWFtRXZlbnQsXG4gICAgdHlwZSBUaHJlYWRTdHJlYW1FdmVudCBhcyBUaHJlYWRTdHJlYW1FdmVudCxcbiAgICBBc3Npc3RhbnRzUGFnZSBhcyBBc3Npc3RhbnRzUGFnZSxcbiAgICB0eXBlIEFzc2lzdGFudENyZWF0ZVBhcmFtcyBhcyBBc3Npc3RhbnRDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBBc3Npc3RhbnRVcGRhdGVQYXJhbXMgYXMgQXNzaXN0YW50VXBkYXRlUGFyYW1zLFxuICAgIHR5cGUgQXNzaXN0YW50TGlzdFBhcmFtcyBhcyBBc3Npc3RhbnRMaXN0UGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgVGhyZWFkcyBhcyBUaHJlYWRzLFxuICAgIHR5cGUgQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gYXMgQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24sXG4gICAgdHlwZSBBc3Npc3RhbnRUb29sQ2hvaWNlIGFzIEFzc2lzdGFudFRvb2xDaG9pY2UsXG4gICAgdHlwZSBBc3Npc3RhbnRUb29sQ2hvaWNlRnVuY3Rpb24gYXMgQXNzaXN0YW50VG9vbENob2ljZUZ1bmN0aW9uLFxuICAgIHR5cGUgQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiBhcyBBc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uLFxuICAgIHR5cGUgVGhyZWFkIGFzIFRocmVhZCxcbiAgICB0eXBlIFRocmVhZERlbGV0ZWQgYXMgVGhyZWFkRGVsZXRlZCxcbiAgICB0eXBlIFRocmVhZENyZWF0ZVBhcmFtcyBhcyBUaHJlYWRDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBUaHJlYWRVcGRhdGVQYXJhbXMgYXMgVGhyZWFkVXBkYXRlUGFyYW1zLFxuICAgIHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zIGFzIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtcyxcbiAgICB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc05vblN0cmVhbWluZyBhcyBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNTdHJlYW1pbmcgYXMgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zU3RyZWFtaW5nLFxuICAgIHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUG9sbFBhcmFtcyxcbiAgICB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blN0cmVhbVBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uL3Jlc291cmNlJztcbmltcG9ydCB7IEFQSVByb21pc2UgfSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb21wbGV0aW9uc0FQSSBmcm9tICcuL2NvbXBsZXRpb25zJztcbmltcG9ydCAqIGFzIENoYXRDb21wbGV0aW9uc0FQSSBmcm9tICcuL2NoYXQvY29tcGxldGlvbnMnO1xuaW1wb3J0IHsgU3RyZWFtIH0gZnJvbSAnLi4vc3RyZWFtaW5nJztcblxuZXhwb3J0IGNsYXNzIENvbXBsZXRpb25zIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbXBsZXRpb24gZm9yIHRoZSBwcm92aWRlZCBwcm9tcHQgYW5kIHBhcmFtZXRlcnMuXG4gICAqL1xuICBjcmVhdGUoYm9keTogQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBBUElQcm9taXNlPENvbXBsZXRpb24+O1xuICBjcmVhdGUoXG4gICAgYm9keTogQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08Q29tcGxldGlvbj4+O1xuICBjcmVhdGUoXG4gICAgYm9keTogQ29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2UsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8U3RyZWFtPENvbXBsZXRpb24+IHwgQ29tcGxldGlvbj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPENvbXBsZXRpb24+IHwgQVBJUHJvbWlzZTxTdHJlYW08Q29tcGxldGlvbj4+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9jb21wbGV0aW9ucycsIHsgYm9keSwgLi4ub3B0aW9ucywgc3RyZWFtOiBib2R5LnN0cmVhbSA/PyBmYWxzZSB9KSBhc1xuICAgICAgfCBBUElQcm9taXNlPENvbXBsZXRpb24+XG4gICAgICB8IEFQSVByb21pc2U8U3RyZWFtPENvbXBsZXRpb24+PjtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb21wbGV0aW9uIHJlc3BvbnNlIGZyb20gdGhlIEFQSS4gTm90ZTogYm90aCB0aGUgc3RyZWFtZWQgYW5kXG4gKiBub24tc3RyZWFtZWQgcmVzcG9uc2Ugb2JqZWN0cyBzaGFyZSB0aGUgc2FtZSBzaGFwZSAodW5saWtlIHRoZSBjaGF0IGVuZHBvaW50KS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjb21wbGV0aW9uLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgY29tcGxldGlvbiBjaG9pY2VzIHRoZSBtb2RlbCBnZW5lcmF0ZWQgZm9yIHRoZSBpbnB1dCBwcm9tcHQuXG4gICAqL1xuICBjaG9pY2VzOiBBcnJheTxDb21wbGV0aW9uQ2hvaWNlPjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBvZiB3aGVuIHRoZSBjb21wbGV0aW9uIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdXNlZCBmb3IgY29tcGxldGlvbi5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwidGV4dF9jb21wbGV0aW9uXCJcbiAgICovXG4gIG9iamVjdDogJ3RleHRfY29tcGxldGlvbic7XG5cbiAgLyoqXG4gICAqIFRoaXMgZmluZ2VycHJpbnQgcmVwcmVzZW50cyB0aGUgYmFja2VuZCBjb25maWd1cmF0aW9uIHRoYXQgdGhlIG1vZGVsIHJ1bnMgd2l0aC5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgYHNlZWRgIHJlcXVlc3QgcGFyYW1ldGVyIHRvIHVuZGVyc3RhbmQgd2hlblxuICAgKiBiYWNrZW5kIGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUgdGhhdCBtaWdodCBpbXBhY3QgZGV0ZXJtaW5pc20uXG4gICAqL1xuICBzeXN0ZW1fZmluZ2VycHJpbnQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBjb21wbGV0aW9uIHJlcXVlc3QuXG4gICAqL1xuICB1c2FnZT86IENvbXBsZXRpb25Vc2FnZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uQ2hvaWNlIHtcbiAgLyoqXG4gICAqIFRoZSByZWFzb24gdGhlIG1vZGVsIHN0b3BwZWQgZ2VuZXJhdGluZyB0b2tlbnMuIFRoaXMgd2lsbCBiZSBgc3RvcGAgaWYgdGhlIG1vZGVsXG4gICAqIGhpdCBhIG5hdHVyYWwgc3RvcCBwb2ludCBvciBhIHByb3ZpZGVkIHN0b3Agc2VxdWVuY2UsIGBsZW5ndGhgIGlmIHRoZSBtYXhpbXVtXG4gICAqIG51bWJlciBvZiB0b2tlbnMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0IHdhcyByZWFjaGVkLCBvciBgY29udGVudF9maWx0ZXJgIGlmXG4gICAqIGNvbnRlbnQgd2FzIG9taXR0ZWQgZHVlIHRvIGEgZmxhZyBmcm9tIG91ciBjb250ZW50IGZpbHRlcnMuXG4gICAqL1xuICBmaW5pc2hfcmVhc29uOiAnc3RvcCcgfCAnbGVuZ3RoJyB8ICdjb250ZW50X2ZpbHRlcic7XG5cbiAgaW5kZXg6IG51bWJlcjtcblxuICBsb2dwcm9iczogQ29tcGxldGlvbkNob2ljZS5Mb2dwcm9icyB8IG51bGw7XG5cbiAgdGV4dDogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENvbXBsZXRpb25DaG9pY2Uge1xuICBleHBvcnQgaW50ZXJmYWNlIExvZ3Byb2JzIHtcbiAgICB0ZXh0X29mZnNldD86IEFycmF5PG51bWJlcj47XG5cbiAgICB0b2tlbl9sb2dwcm9icz86IEFycmF5PG51bWJlcj47XG5cbiAgICB0b2tlbnM/OiBBcnJheTxzdHJpbmc+O1xuXG4gICAgdG9wX2xvZ3Byb2JzPzogQXJyYXk8UmVjb3JkPHN0cmluZywgbnVtYmVyPj47XG4gIH1cbn1cblxuLyoqXG4gKiBVc2FnZSBzdGF0aXN0aWNzIGZvciB0aGUgY29tcGxldGlvbiByZXF1ZXN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25Vc2FnZSB7XG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgdG9rZW5zIGluIHRoZSBnZW5lcmF0ZWQgY29tcGxldGlvbi5cbiAgICovXG4gIGNvbXBsZXRpb25fdG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiB0b2tlbnMgaW4gdGhlIHByb21wdC5cbiAgICovXG4gIHByb21wdF90b2tlbnM6IG51bWJlcjtcblxuICAvKipcbiAgICogVG90YWwgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIHRoZSByZXF1ZXN0IChwcm9tcHQgKyBjb21wbGV0aW9uKS5cbiAgICovXG4gIHRvdGFsX3Rva2VuczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBCcmVha2Rvd24gb2YgdG9rZW5zIHVzZWQgaW4gYSBjb21wbGV0aW9uLlxuICAgKi9cbiAgY29tcGxldGlvbl90b2tlbnNfZGV0YWlscz86IENvbXBsZXRpb25Vc2FnZS5Db21wbGV0aW9uVG9rZW5zRGV0YWlscztcblxuICAvKipcbiAgICogQnJlYWtkb3duIG9mIHRva2VucyB1c2VkIGluIHRoZSBwcm9tcHQuXG4gICAqL1xuICBwcm9tcHRfdG9rZW5zX2RldGFpbHM/OiBDb21wbGV0aW9uVXNhZ2UuUHJvbXB0VG9rZW5zRGV0YWlscztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDb21wbGV0aW9uVXNhZ2Uge1xuICAvKipcbiAgICogQnJlYWtkb3duIG9mIHRva2VucyB1c2VkIGluIGEgY29tcGxldGlvbi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvblRva2Vuc0RldGFpbHMge1xuICAgIC8qKlxuICAgICAqIFdoZW4gdXNpbmcgUHJlZGljdGVkIE91dHB1dHMsIHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBwcmVkaWN0aW9uIHRoYXRcbiAgICAgKiBhcHBlYXJlZCBpbiB0aGUgY29tcGxldGlvbi5cbiAgICAgKi9cbiAgICBhY2NlcHRlZF9wcmVkaWN0aW9uX3Rva2Vucz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEF1ZGlvIGlucHV0IHRva2VucyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGF1ZGlvX3Rva2Vucz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRva2VucyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGZvciByZWFzb25pbmcuXG4gICAgICovXG4gICAgcmVhc29uaW5nX3Rva2Vucz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdXNpbmcgUHJlZGljdGVkIE91dHB1dHMsIHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBwcmVkaWN0aW9uIHRoYXQgZGlkXG4gICAgICogbm90IGFwcGVhciBpbiB0aGUgY29tcGxldGlvbi4gSG93ZXZlciwgbGlrZSByZWFzb25pbmcgdG9rZW5zLCB0aGVzZSB0b2tlbnMgYXJlXG4gICAgICogc3RpbGwgY291bnRlZCBpbiB0aGUgdG90YWwgY29tcGxldGlvbiB0b2tlbnMgZm9yIHB1cnBvc2VzIG9mIGJpbGxpbmcsIG91dHB1dCxcbiAgICAgKiBhbmQgY29udGV4dCB3aW5kb3cgbGltaXRzLlxuICAgICAqL1xuICAgIHJlamVjdGVkX3ByZWRpY3Rpb25fdG9rZW5zPzogbnVtYmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEJyZWFrZG93biBvZiB0b2tlbnMgdXNlZCBpbiB0aGUgcHJvbXB0LlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBQcm9tcHRUb2tlbnNEZXRhaWxzIHtcbiAgICAvKipcbiAgICAgKiBBdWRpbyBpbnB1dCB0b2tlbnMgcHJlc2VudCBpbiB0aGUgcHJvbXB0LlxuICAgICAqL1xuICAgIGF1ZGlvX3Rva2Vucz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCB0b2tlbnMgcHJlc2VudCBpbiB0aGUgcHJvbXB0LlxuICAgICAqL1xuICAgIGNhY2hlZF90b2tlbnM/OiBudW1iZXI7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyA9IENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgfCBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIElEIG9mIHRoZSBtb2RlbCB0byB1c2UuIFlvdSBjYW4gdXNlIHRoZVxuICAgKiBbTGlzdCBtb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzL2xpc3QpIEFQSSB0b1xuICAgKiBzZWUgYWxsIG9mIHlvdXIgYXZhaWxhYmxlIG1vZGVscywgb3Igc2VlIG91clxuICAgKiBbTW9kZWwgb3ZlcnZpZXddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscykgZm9yIGRlc2NyaXB0aW9ucyBvZlxuICAgKiB0aGVtLlxuICAgKi9cbiAgbW9kZWw6IChzdHJpbmcgJiB7fSkgfCAnZ3B0LTMuNS10dXJiby1pbnN0cnVjdCcgfCAnZGF2aW5jaS0wMDInIHwgJ2JhYmJhZ2UtMDAyJztcblxuICAvKipcbiAgICogVGhlIHByb21wdChzKSB0byBnZW5lcmF0ZSBjb21wbGV0aW9ucyBmb3IsIGVuY29kZWQgYXMgYSBzdHJpbmcsIGFycmF5IG9mXG4gICAqIHN0cmluZ3MsIGFycmF5IG9mIHRva2Vucywgb3IgYXJyYXkgb2YgdG9rZW4gYXJyYXlzLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgPHxlbmRvZnRleHR8PiBpcyB0aGUgZG9jdW1lbnQgc2VwYXJhdG9yIHRoYXQgdGhlIG1vZGVsIHNlZXMgZHVyaW5nXG4gICAqIHRyYWluaW5nLCBzbyBpZiBhIHByb21wdCBpcyBub3Qgc3BlY2lmaWVkIHRoZSBtb2RlbCB3aWxsIGdlbmVyYXRlIGFzIGlmIGZyb20gdGhlXG4gICAqIGJlZ2lubmluZyBvZiBhIG5ldyBkb2N1bWVudC5cbiAgICovXG4gIHByb21wdDogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPiB8IEFycmF5PG51bWJlcj4gfCBBcnJheTxBcnJheTxudW1iZXI+PiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBgYmVzdF9vZmAgY29tcGxldGlvbnMgc2VydmVyLXNpZGUgYW5kIHJldHVybnMgdGhlIFwiYmVzdFwiICh0aGUgb25lIHdpdGhcbiAgICogdGhlIGhpZ2hlc3QgbG9nIHByb2JhYmlsaXR5IHBlciB0b2tlbikuIFJlc3VsdHMgY2Fubm90IGJlIHN0cmVhbWVkLlxuICAgKlxuICAgKiBXaGVuIHVzZWQgd2l0aCBgbmAsIGBiZXN0X29mYCBjb250cm9scyB0aGUgbnVtYmVyIG9mIGNhbmRpZGF0ZSBjb21wbGV0aW9ucyBhbmRcbiAgICogYG5gIHNwZWNpZmllcyBob3cgbWFueSB0byByZXR1cm4gXHUyMDEzIGBiZXN0X29mYCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBgbmAuXG4gICAqXG4gICAqICoqTm90ZToqKiBCZWNhdXNlIHRoaXMgcGFyYW1ldGVyIGdlbmVyYXRlcyBtYW55IGNvbXBsZXRpb25zLCBpdCBjYW4gcXVpY2tseVxuICAgKiBjb25zdW1lIHlvdXIgdG9rZW4gcXVvdGEuIFVzZSBjYXJlZnVsbHkgYW5kIGVuc3VyZSB0aGF0IHlvdSBoYXZlIHJlYXNvbmFibGVcbiAgICogc2V0dGluZ3MgZm9yIGBtYXhfdG9rZW5zYCBhbmQgYHN0b3BgLlxuICAgKi9cbiAgYmVzdF9vZj86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEVjaG8gYmFjayB0aGUgcHJvbXB0IGluIGFkZGl0aW9uIHRvIHRoZSBjb21wbGV0aW9uXG4gICAqL1xuICBlY2hvPzogYm9vbGVhbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE51bWJlciBiZXR3ZWVuIC0yLjAgYW5kIDIuMC4gUG9zaXRpdmUgdmFsdWVzIHBlbmFsaXplIG5ldyB0b2tlbnMgYmFzZWQgb24gdGhlaXJcbiAgICogZXhpc3RpbmcgZnJlcXVlbmN5IGluIHRoZSB0ZXh0IHNvIGZhciwgZGVjcmVhc2luZyB0aGUgbW9kZWwncyBsaWtlbGlob29kIHRvXG4gICAqIHJlcGVhdCB0aGUgc2FtZSBsaW5lIHZlcmJhdGltLlxuICAgKlxuICAgKiBbU2VlIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgZnJlcXVlbmN5IGFuZCBwcmVzZW5jZSBwZW5hbHRpZXMuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvdGV4dC1nZW5lcmF0aW9uKVxuICAgKi9cbiAgZnJlcXVlbmN5X3BlbmFsdHk/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIGxpa2VsaWhvb2Qgb2Ygc3BlY2lmaWVkIHRva2VucyBhcHBlYXJpbmcgaW4gdGhlIGNvbXBsZXRpb24uXG4gICAqXG4gICAqIEFjY2VwdHMgYSBKU09OIG9iamVjdCB0aGF0IG1hcHMgdG9rZW5zIChzcGVjaWZpZWQgYnkgdGhlaXIgdG9rZW4gSUQgaW4gdGhlIEdQVFxuICAgKiB0b2tlbml6ZXIpIHRvIGFuIGFzc29jaWF0ZWQgYmlhcyB2YWx1ZSBmcm9tIC0xMDAgdG8gMTAwLiBZb3UgY2FuIHVzZSB0aGlzXG4gICAqIFt0b2tlbml6ZXIgdG9vbF0oL3Rva2VuaXplcj92aWV3PWJwZSkgdG8gY29udmVydCB0ZXh0IHRvIHRva2VuIElEcy5cbiAgICogTWF0aGVtYXRpY2FsbHksIHRoZSBiaWFzIGlzIGFkZGVkIHRvIHRoZSBsb2dpdHMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBwcmlvciB0b1xuICAgKiBzYW1wbGluZy4gVGhlIGV4YWN0IGVmZmVjdCB3aWxsIHZhcnkgcGVyIG1vZGVsLCBidXQgdmFsdWVzIGJldHdlZW4gLTEgYW5kIDFcbiAgICogc2hvdWxkIGRlY3JlYXNlIG9yIGluY3JlYXNlIGxpa2VsaWhvb2Qgb2Ygc2VsZWN0aW9uOyB2YWx1ZXMgbGlrZSAtMTAwIG9yIDEwMFxuICAgKiBzaG91bGQgcmVzdWx0IGluIGEgYmFuIG9yIGV4Y2x1c2l2ZSBzZWxlY3Rpb24gb2YgdGhlIHJlbGV2YW50IHRva2VuLlxuICAgKlxuICAgKiBBcyBhbiBleGFtcGxlLCB5b3UgY2FuIHBhc3MgYHtcIjUwMjU2XCI6IC0xMDB9YCB0byBwcmV2ZW50IHRoZSA8fGVuZG9mdGV4dHw+IHRva2VuXG4gICAqIGZyb20gYmVpbmcgZ2VuZXJhdGVkLlxuICAgKi9cbiAgbG9naXRfYmlhcz86IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJbmNsdWRlIHRoZSBsb2cgcHJvYmFiaWxpdGllcyBvbiB0aGUgYGxvZ3Byb2JzYCBtb3N0IGxpa2VseSBvdXRwdXQgdG9rZW5zLCBhc1xuICAgKiB3ZWxsIHRoZSBjaG9zZW4gdG9rZW5zLiBGb3IgZXhhbXBsZSwgaWYgYGxvZ3Byb2JzYCBpcyA1LCB0aGUgQVBJIHdpbGwgcmV0dXJuIGFcbiAgICogbGlzdCBvZiB0aGUgNSBtb3N0IGxpa2VseSB0b2tlbnMuIFRoZSBBUEkgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBgbG9ncHJvYmAgb2ZcbiAgICogdGhlIHNhbXBsZWQgdG9rZW4sIHNvIHRoZXJlIG1heSBiZSB1cCB0byBgbG9ncHJvYnMrMWAgZWxlbWVudHMgaW4gdGhlIHJlc3BvbnNlLlxuICAgKlxuICAgKiBUaGUgbWF4aW11bSB2YWx1ZSBmb3IgYGxvZ3Byb2JzYCBpcyA1LlxuICAgKi9cbiAgbG9ncHJvYnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgW3Rva2Vuc10oL3Rva2VuaXplcikgdGhhdCBjYW4gYmUgZ2VuZXJhdGVkIGluIHRoZVxuICAgKiBjb21wbGV0aW9uLlxuICAgKlxuICAgKiBUaGUgdG9rZW4gY291bnQgb2YgeW91ciBwcm9tcHQgcGx1cyBgbWF4X3Rva2Vuc2AgY2Fubm90IGV4Y2VlZCB0aGUgbW9kZWwnc1xuICAgKiBjb250ZXh0IGxlbmd0aC5cbiAgICogW0V4YW1wbGUgUHl0aG9uIGNvZGVdKGh0dHBzOi8vY29va2Jvb2sub3BlbmFpLmNvbS9leGFtcGxlcy9ob3dfdG9fY291bnRfdG9rZW5zX3dpdGhfdGlrdG9rZW4pXG4gICAqIGZvciBjb3VudGluZyB0b2tlbnMuXG4gICAqL1xuICBtYXhfdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogSG93IG1hbnkgY29tcGxldGlvbnMgdG8gZ2VuZXJhdGUgZm9yIGVhY2ggcHJvbXB0LlxuICAgKlxuICAgKiAqKk5vdGU6KiogQmVjYXVzZSB0aGlzIHBhcmFtZXRlciBnZW5lcmF0ZXMgbWFueSBjb21wbGV0aW9ucywgaXQgY2FuIHF1aWNrbHlcbiAgICogY29uc3VtZSB5b3VyIHRva2VuIHF1b3RhLiBVc2UgY2FyZWZ1bGx5IGFuZCBlbnN1cmUgdGhhdCB5b3UgaGF2ZSByZWFzb25hYmxlXG4gICAqIHNldHRpbmdzIGZvciBgbWF4X3Rva2Vuc2AgYW5kIGBzdG9wYC5cbiAgICovXG4gIG4/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgYmV0d2VlbiAtMi4wIGFuZCAyLjAuIFBvc2l0aXZlIHZhbHVlcyBwZW5hbGl6ZSBuZXcgdG9rZW5zIGJhc2VkIG9uXG4gICAqIHdoZXRoZXIgdGhleSBhcHBlYXIgaW4gdGhlIHRleHQgc28gZmFyLCBpbmNyZWFzaW5nIHRoZSBtb2RlbCdzIGxpa2VsaWhvb2QgdG9cbiAgICogdGFsayBhYm91dCBuZXcgdG9waWNzLlxuICAgKlxuICAgKiBbU2VlIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgZnJlcXVlbmN5IGFuZCBwcmVzZW5jZSBwZW5hbHRpZXMuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvdGV4dC1nZW5lcmF0aW9uKVxuICAgKi9cbiAgcHJlc2VuY2VfcGVuYWx0eT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIElmIHNwZWNpZmllZCwgb3VyIHN5c3RlbSB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byBzYW1wbGUgZGV0ZXJtaW5pc3RpY2FsbHksXG4gICAqIHN1Y2ggdGhhdCByZXBlYXRlZCByZXF1ZXN0cyB3aXRoIHRoZSBzYW1lIGBzZWVkYCBhbmQgcGFyYW1ldGVycyBzaG91bGQgcmV0dXJuXG4gICAqIHRoZSBzYW1lIHJlc3VsdC5cbiAgICpcbiAgICogRGV0ZXJtaW5pc20gaXMgbm90IGd1YXJhbnRlZWQsIGFuZCB5b3Ugc2hvdWxkIHJlZmVyIHRvIHRoZSBgc3lzdGVtX2ZpbmdlcnByaW50YFxuICAgKiByZXNwb25zZSBwYXJhbWV0ZXIgdG8gbW9uaXRvciBjaGFuZ2VzIGluIHRoZSBiYWNrZW5kLlxuICAgKi9cbiAgc2VlZD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFVwIHRvIDQgc2VxdWVuY2VzIHdoZXJlIHRoZSBBUEkgd2lsbCBzdG9wIGdlbmVyYXRpbmcgZnVydGhlciB0b2tlbnMuIFRoZVxuICAgKiByZXR1cm5lZCB0ZXh0IHdpbGwgbm90IGNvbnRhaW4gdGhlIHN0b3Agc2VxdWVuY2UuXG4gICAqL1xuICBzdG9wPzogc3RyaW5nIHwgbnVsbCB8IEFycmF5PHN0cmluZz47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3RyZWFtIGJhY2sgcGFydGlhbCBwcm9ncmVzcy4gSWYgc2V0LCB0b2tlbnMgd2lsbCBiZSBzZW50IGFzXG4gICAqIGRhdGEtb25seVxuICAgKiBbc2VydmVyLXNlbnQgZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmVyLXNlbnRfZXZlbnRzL1VzaW5nX3NlcnZlci1zZW50X2V2ZW50cyNFdmVudF9zdHJlYW1fZm9ybWF0KVxuICAgKiBhcyB0aGV5IGJlY29tZSBhdmFpbGFibGUsIHdpdGggdGhlIHN0cmVhbSB0ZXJtaW5hdGVkIGJ5IGEgYGRhdGE6IFtET05FXWBcbiAgICogbWVzc2FnZS5cbiAgICogW0V4YW1wbGUgUHl0aG9uIGNvZGVdKGh0dHBzOi8vY29va2Jvb2sub3BlbmFpLmNvbS9leGFtcGxlcy9ob3dfdG9fc3RyZWFtX2NvbXBsZXRpb25zKS5cbiAgICovXG4gIHN0cmVhbT86IGJvb2xlYW4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciBzdHJlYW1pbmcgcmVzcG9uc2UuIE9ubHkgc2V0IHRoaXMgd2hlbiB5b3Ugc2V0IGBzdHJlYW06IHRydWVgLlxuICAgKi9cbiAgc3RyZWFtX29wdGlvbnM/OiBDaGF0Q29tcGxldGlvbnNBUEkuQ2hhdENvbXBsZXRpb25TdHJlYW1PcHRpb25zIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHN1ZmZpeCB0aGF0IGNvbWVzIGFmdGVyIGEgY29tcGxldGlvbiBvZiBpbnNlcnRlZCB0ZXh0LlxuICAgKlxuICAgKiBUaGlzIHBhcmFtZXRlciBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgYGdwdC0zLjUtdHVyYm8taW5zdHJ1Y3RgLlxuICAgKi9cbiAgc3VmZml4Pzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciBgdG9wX3BgIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgYHRlbXBlcmF0dXJlYCBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgcmVwcmVzZW50aW5nIHlvdXIgZW5kLXVzZXIsIHdoaWNoIGNhbiBoZWxwIE9wZW5BSSB0byBtb25pdG9yXG4gICAqIGFuZCBkZXRlY3QgYWJ1c2UuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc2FmZXR5LWJlc3QtcHJhY3RpY2VzI2VuZC11c2VyLWlkcykuXG4gICAqL1xuICB1c2VyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENvbXBsZXRpb25DcmVhdGVQYXJhbXMge1xuICBleHBvcnQgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nID0gQ29tcGxldGlvbnNBUEkuQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZztcbiAgZXhwb3J0IHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyA9IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBleHRlbmRzIENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3RyZWFtIGJhY2sgcGFydGlhbCBwcm9ncmVzcy4gSWYgc2V0LCB0b2tlbnMgd2lsbCBiZSBzZW50IGFzXG4gICAqIGRhdGEtb25seVxuICAgKiBbc2VydmVyLXNlbnQgZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmVyLXNlbnRfZXZlbnRzL1VzaW5nX3NlcnZlci1zZW50X2V2ZW50cyNFdmVudF9zdHJlYW1fZm9ybWF0KVxuICAgKiBhcyB0aGV5IGJlY29tZSBhdmFpbGFibGUsIHdpdGggdGhlIHN0cmVhbSB0ZXJtaW5hdGVkIGJ5IGEgYGRhdGE6IFtET05FXWBcbiAgICogbWVzc2FnZS5cbiAgICogW0V4YW1wbGUgUHl0aG9uIGNvZGVdKGh0dHBzOi8vY29va2Jvb2sub3BlbmFpLmNvbS9leGFtcGxlcy9ob3dfdG9fc3RyZWFtX2NvbXBsZXRpb25zKS5cbiAgICovXG4gIHN0cmVhbT86IGZhbHNlIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGV4dGVuZHMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogV2hldGhlciB0byBzdHJlYW0gYmFjayBwYXJ0aWFsIHByb2dyZXNzLiBJZiBzZXQsIHRva2VucyB3aWxsIGJlIHNlbnQgYXNcbiAgICogZGF0YS1vbmx5XG4gICAqIFtzZXJ2ZXItc2VudCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2ZXItc2VudF9ldmVudHMvVXNpbmdfc2VydmVyLXNlbnRfZXZlbnRzI0V2ZW50X3N0cmVhbV9mb3JtYXQpXG4gICAqIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSwgd2l0aCB0aGUgc3RyZWFtIHRlcm1pbmF0ZWQgYnkgYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9jb29rYm9vay5vcGVuYWkuY29tL2V4YW1wbGVzL2hvd190b19zdHJlYW1fY29tcGxldGlvbnMpLlxuICAgKi9cbiAgc3RyZWFtOiB0cnVlO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgQ29tcGxldGlvbnMge1xuICBleHBvcnQge1xuICAgIHR5cGUgQ29tcGxldGlvbiBhcyBDb21wbGV0aW9uLFxuICAgIHR5cGUgQ29tcGxldGlvbkNob2ljZSBhcyBDb21wbGV0aW9uQ2hvaWNlLFxuICAgIHR5cGUgQ29tcGxldGlvblVzYWdlIGFzIENvbXBsZXRpb25Vc2FnZSxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXMgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vY29yZSc7XG5cbmV4cG9ydCBjbGFzcyBFbWJlZGRpbmdzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBlbWJlZGRpbmcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgaW5wdXQgdGV4dC5cbiAgICovXG4gIGNyZWF0ZShcbiAgICBib2R5OiBFbWJlZGRpbmdDcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxDcmVhdGVFbWJlZGRpbmdSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2VtYmVkZGluZ3MnLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVFbWJlZGRpbmdSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBlbWJlZGRpbmdzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICBkYXRhOiBBcnJheTxFbWJlZGRpbmc+O1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgbW9kZWwgdXNlZCB0byBnZW5lcmF0ZSB0aGUgZW1iZWRkaW5nLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgXCJsaXN0XCIuXG4gICAqL1xuICBvYmplY3Q6ICdsaXN0JztcblxuICAvKipcbiAgICogVGhlIHVzYWdlIGluZm9ybWF0aW9uIGZvciB0aGUgcmVxdWVzdC5cbiAgICovXG4gIHVzYWdlOiBDcmVhdGVFbWJlZGRpbmdSZXNwb25zZS5Vc2FnZTtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDcmVhdGVFbWJlZGRpbmdSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBUaGUgdXNhZ2UgaW5mb3JtYXRpb24gZm9yIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBVc2FnZSB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiB0b2tlbnMgdXNlZCBieSB0aGUgcHJvbXB0LlxuICAgICAqL1xuICAgIHByb21wdF90b2tlbnM6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgdG9rZW5zIHVzZWQgYnkgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgdG90YWxfdG9rZW5zOiBudW1iZXI7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGVtYmVkZGluZyB2ZWN0b3IgcmV0dXJuZWQgYnkgZW1iZWRkaW5nIGVuZHBvaW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVtYmVkZGluZyB7XG4gIC8qKlxuICAgKiBUaGUgZW1iZWRkaW5nIHZlY3Rvciwgd2hpY2ggaXMgYSBsaXN0IG9mIGZsb2F0cy4gVGhlIGxlbmd0aCBvZiB2ZWN0b3IgZGVwZW5kcyBvblxuICAgKiB0aGUgbW9kZWwgYXMgbGlzdGVkIGluIHRoZVxuICAgKiBbZW1iZWRkaW5nIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZW1iZWRkaW5ncykuXG4gICAqL1xuICBlbWJlZGRpbmc6IEFycmF5PG51bWJlcj47XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgZW1iZWRkaW5nIGluIHRoZSBsaXN0IG9mIGVtYmVkZGluZ3MuXG4gICAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcImVtYmVkZGluZ1wiLlxuICAgKi9cbiAgb2JqZWN0OiAnZW1iZWRkaW5nJztcbn1cblxuZXhwb3J0IHR5cGUgRW1iZWRkaW5nTW9kZWwgPSAndGV4dC1lbWJlZGRpbmctYWRhLTAwMicgfCAndGV4dC1lbWJlZGRpbmctMy1zbWFsbCcgfCAndGV4dC1lbWJlZGRpbmctMy1sYXJnZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW1iZWRkaW5nQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIElucHV0IHRleHQgdG8gZW1iZWQsIGVuY29kZWQgYXMgYSBzdHJpbmcgb3IgYXJyYXkgb2YgdG9rZW5zLiBUbyBlbWJlZCBtdWx0aXBsZVxuICAgKiBpbnB1dHMgaW4gYSBzaW5nbGUgcmVxdWVzdCwgcGFzcyBhbiBhcnJheSBvZiBzdHJpbmdzIG9yIGFycmF5IG9mIHRva2VuIGFycmF5cy5cbiAgICogVGhlIGlucHV0IG11c3Qgbm90IGV4Y2VlZCB0aGUgbWF4IGlucHV0IHRva2VucyBmb3IgdGhlIG1vZGVsICg4MTkyIHRva2VucyBmb3JcbiAgICogYHRleHQtZW1iZWRkaW5nLWFkYS0wMDJgKSwgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZywgYW5kIGFueSBhcnJheSBtdXN0IGJlIDIwNDhcbiAgICogZGltZW5zaW9ucyBvciBsZXNzLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9jb29rYm9vay5vcGVuYWkuY29tL2V4YW1wbGVzL2hvd190b19jb3VudF90b2tlbnNfd2l0aF90aWt0b2tlbilcbiAgICogZm9yIGNvdW50aW5nIHRva2Vucy5cbiAgICovXG4gIGlucHV0OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+IHwgQXJyYXk8bnVtYmVyPiB8IEFycmF5PEFycmF5PG51bWJlcj4+O1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBZb3UgY2FuIHVzZSB0aGVcbiAgICogW0xpc3QgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscy9saXN0KSBBUEkgdG9cbiAgICogc2VlIGFsbCBvZiB5b3VyIGF2YWlsYWJsZSBtb2RlbHMsIG9yIHNlZSBvdXJcbiAgICogW01vZGVsIG92ZXJ2aWV3XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMpIGZvciBkZXNjcmlwdGlvbnMgb2ZcbiAgICogdGhlbS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgRW1iZWRkaW5nTW9kZWw7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgZGltZW5zaW9ucyB0aGUgcmVzdWx0aW5nIG91dHB1dCBlbWJlZGRpbmdzIHNob3VsZCBoYXZlLiBPbmx5XG4gICAqIHN1cHBvcnRlZCBpbiBgdGV4dC1lbWJlZGRpbmctM2AgYW5kIGxhdGVyIG1vZGVscy5cbiAgICovXG4gIGRpbWVuc2lvbnM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgdG8gcmV0dXJuIHRoZSBlbWJlZGRpbmdzIGluLiBDYW4gYmUgZWl0aGVyIGBmbG9hdGAgb3JcbiAgICogW2BiYXNlNjRgXShodHRwczovL3B5cGkub3JnL3Byb2plY3QvcHliYXNlNjQvKS5cbiAgICovXG4gIGVuY29kaW5nX2Zvcm1hdD86ICdmbG9hdCcgfCAnYmFzZTY0JztcblxuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciByZXByZXNlbnRpbmcgeW91ciBlbmQtdXNlciwgd2hpY2ggY2FuIGhlbHAgT3BlbkFJIHRvIG1vbml0b3JcbiAgICogYW5kIGRldGVjdCBhYnVzZS5cbiAgICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zYWZldHktYmVzdC1wcmFjdGljZXMjZW5kLXVzZXItaWRzKS5cbiAgICovXG4gIHVzZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBFbWJlZGRpbmdzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIENyZWF0ZUVtYmVkZGluZ1Jlc3BvbnNlIGFzIENyZWF0ZUVtYmVkZGluZ1Jlc3BvbnNlLFxuICAgIHR5cGUgRW1iZWRkaW5nIGFzIEVtYmVkZGluZyxcbiAgICB0eXBlIEVtYmVkZGluZ01vZGVsIGFzIEVtYmVkZGluZ01vZGVsLFxuICAgIHR5cGUgRW1iZWRkaW5nQ3JlYXRlUGFyYW1zIGFzIEVtYmVkZGluZ0NyZWF0ZVBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7IHNsZWVwIH0gZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgeyBBUElDb25uZWN0aW9uVGltZW91dEVycm9yIH0gZnJvbSAnLi4vZXJyb3InO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7IEN1cnNvclBhZ2UsIHR5cGUgQ3Vyc29yUGFnZVBhcmFtcyB9IGZyb20gJy4uL3BhZ2luYXRpb24nO1xuaW1wb3J0IHsgdHlwZSBSZXNwb25zZSB9IGZyb20gJy4uL19zaGltcy9pbmRleCc7XG5cbmV4cG9ydCBjbGFzcyBGaWxlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFVwbG9hZCBhIGZpbGUgdGhhdCBjYW4gYmUgdXNlZCBhY3Jvc3MgdmFyaW91cyBlbmRwb2ludHMuIEluZGl2aWR1YWwgZmlsZXMgY2FuIGJlXG4gICAqIHVwIHRvIDUxMiBNQiwgYW5kIHRoZSBzaXplIG9mIGFsbCBmaWxlcyB1cGxvYWRlZCBieSBvbmUgb3JnYW5pemF0aW9uIGNhbiBiZSB1cFxuICAgKiB0byAxMDAgR0IuXG4gICAqXG4gICAqIFRoZSBBc3Npc3RhbnRzIEFQSSBzdXBwb3J0cyBmaWxlcyB1cCB0byAyIG1pbGxpb24gdG9rZW5zIGFuZCBvZiBzcGVjaWZpYyBmaWxlXG4gICAqIHR5cGVzLiBTZWUgdGhlXG4gICAqIFtBc3Npc3RhbnRzIFRvb2xzIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL3Rvb2xzKSBmb3JcbiAgICogZGV0YWlscy5cbiAgICpcbiAgICogVGhlIEZpbmUtdHVuaW5nIEFQSSBvbmx5IHN1cHBvcnRzIGAuanNvbmxgIGZpbGVzLiBUaGUgaW5wdXQgYWxzbyBoYXMgY2VydGFpblxuICAgKiByZXF1aXJlZCBmb3JtYXRzIGZvciBmaW5lLXR1bmluZ1xuICAgKiBbY2hhdF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maW5lLXR1bmluZy9jaGF0LWlucHV0KSBvclxuICAgKiBbY29tcGxldGlvbnNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmluZS10dW5pbmcvY29tcGxldGlvbnMtaW5wdXQpXG4gICAqIG1vZGVscy5cbiAgICpcbiAgICogVGhlIEJhdGNoIEFQSSBvbmx5IHN1cHBvcnRzIGAuanNvbmxgIGZpbGVzIHVwIHRvIDIwMCBNQiBpbiBzaXplLiBUaGUgaW5wdXQgYWxzb1xuICAgKiBoYXMgYSBzcGVjaWZpYyByZXF1aXJlZFxuICAgKiBbZm9ybWF0XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2JhdGNoL3JlcXVlc3QtaW5wdXQpLlxuICAgKlxuICAgKiBQbGVhc2UgW2NvbnRhY3QgdXNdKGh0dHBzOi8vaGVscC5vcGVuYWkuY29tLykgaWYgeW91IG5lZWQgdG8gaW5jcmVhc2UgdGhlc2VcbiAgICogc3RvcmFnZSBsaW1pdHMuXG4gICAqL1xuICBjcmVhdGUoYm9keTogRmlsZUNyZWF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8RmlsZU9iamVjdD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2ZpbGVzJywgQ29yZS5tdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IGEgc3BlY2lmaWMgZmlsZS5cbiAgICovXG4gIHJldHJpZXZlKGZpbGVJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxGaWxlT2JqZWN0PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC9maWxlcy8ke2ZpbGVJZH1gLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmaWxlcy5cbiAgICovXG4gIGxpc3QocXVlcnk/OiBGaWxlTGlzdFBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPEZpbGVPYmplY3RzUGFnZSwgRmlsZU9iamVjdD47XG4gIGxpc3Qob3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPEZpbGVPYmplY3RzUGFnZSwgRmlsZU9iamVjdD47XG4gIGxpc3QoXG4gICAgcXVlcnk6IEZpbGVMaXN0UGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbGVPYmplY3RzUGFnZSwgRmlsZU9iamVjdD4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdCh7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy9maWxlcycsIEZpbGVPYmplY3RzUGFnZSwgeyBxdWVyeSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBmaWxlLlxuICAgKi9cbiAgZGVsKGZpbGVJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxGaWxlRGVsZXRlZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZGVsZXRlKGAvZmlsZXMvJHtmaWxlSWR9YCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIHNwZWNpZmllZCBmaWxlLlxuICAgKi9cbiAgY29udGVudChmaWxlSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8UmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL2ZpbGVzLyR7ZmlsZUlkfS9jb250ZW50YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgQWNjZXB0OiAnYXBwbGljYXRpb24vYmluYXJ5JywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgX19iaW5hcnlSZXNwb25zZTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGUgc3BlY2lmaWVkIGZpbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBgLmNvbnRlbnQoKWAgbWV0aG9kIHNob3VsZCBiZSB1c2VkIGluc3RlYWRcbiAgICovXG4gIHJldHJpZXZlQ29udGVudChmaWxlSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC9maWxlcy8ke2ZpbGVJZH0vY29udGVudGAsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhaXRzIGZvciB0aGUgZ2l2ZW4gZmlsZSB0byBiZSBwcm9jZXNzZWQsIGRlZmF1bHQgdGltZW91dCBpcyAzMCBtaW5zLlxuICAgKi9cbiAgYXN5bmMgd2FpdEZvclByb2Nlc3NpbmcoXG4gICAgaWQ6IHN0cmluZyxcbiAgICB7IHBvbGxJbnRlcnZhbCA9IDUwMDAsIG1heFdhaXQgPSAzMCAqIDYwICogMTAwMCB9OiB7IHBvbGxJbnRlcnZhbD86IG51bWJlcjsgbWF4V2FpdD86IG51bWJlciB9ID0ge30sXG4gICk6IFByb21pc2U8RmlsZU9iamVjdD4ge1xuICAgIGNvbnN0IFRFUk1JTkFMX1NUQVRFUyA9IG5ldyBTZXQoWydwcm9jZXNzZWQnLCAnZXJyb3InLCAnZGVsZXRlZCddKTtcblxuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgZmlsZSA9IGF3YWl0IHRoaXMucmV0cmlldmUoaWQpO1xuXG4gICAgd2hpbGUgKCFmaWxlLnN0YXR1cyB8fCAhVEVSTUlOQUxfU1RBVEVTLmhhcyhmaWxlLnN0YXR1cykpIHtcbiAgICAgIGF3YWl0IHNsZWVwKHBvbGxJbnRlcnZhbCk7XG5cbiAgICAgIGZpbGUgPSBhd2FpdCB0aGlzLnJldHJpZXZlKGlkKTtcbiAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnQgPiBtYXhXYWl0KSB7XG4gICAgICAgIHRocm93IG5ldyBBUElDb25uZWN0aW9uVGltZW91dEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBgR2l2aW5nIHVwIG9uIHdhaXRpbmcgZm9yIGZpbGUgJHtpZH0gdG8gZmluaXNoIHByb2Nlc3NpbmcgYWZ0ZXIgJHttYXhXYWl0fSBtaWxsaXNlY29uZHMuYCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZpbGVPYmplY3RzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8RmlsZU9iamVjdD4ge31cblxuZXhwb3J0IHR5cGUgRmlsZUNvbnRlbnQgPSBzdHJpbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZURlbGV0ZWQge1xuICBpZDogc3RyaW5nO1xuXG4gIGRlbGV0ZWQ6IGJvb2xlYW47XG5cbiAgb2JqZWN0OiAnZmlsZSc7XG59XG5cbi8qKlxuICogVGhlIGBGaWxlYCBvYmplY3QgcmVwcmVzZW50cyBhIGRvY3VtZW50IHRoYXQgaGFzIGJlZW4gdXBsb2FkZWQgdG8gT3BlbkFJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVPYmplY3Qge1xuICAvKipcbiAgICogVGhlIGZpbGUgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gdGhlIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgZmlsZSwgaW4gYnl0ZXMuXG4gICAqL1xuICBieXRlczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBmaWxlIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZmlsZS5cbiAgICovXG4gIGZpbGVuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGBmaWxlYC5cbiAgICovXG4gIG9iamVjdDogJ2ZpbGUnO1xuXG4gIC8qKlxuICAgKiBUaGUgaW50ZW5kZWQgcHVycG9zZSBvZiB0aGUgZmlsZS4gU3VwcG9ydGVkIHZhbHVlcyBhcmUgYGFzc2lzdGFudHNgLFxuICAgKiBgYXNzaXN0YW50c19vdXRwdXRgLCBgYmF0Y2hgLCBgYmF0Y2hfb3V0cHV0YCwgYGZpbmUtdHVuZWAsIGBmaW5lLXR1bmUtcmVzdWx0c2BcbiAgICogYW5kIGB2aXNpb25gLlxuICAgKi9cbiAgcHVycG9zZTpcbiAgICB8ICdhc3Npc3RhbnRzJ1xuICAgIHwgJ2Fzc2lzdGFudHNfb3V0cHV0J1xuICAgIHwgJ2JhdGNoJ1xuICAgIHwgJ2JhdGNoX291dHB1dCdcbiAgICB8ICdmaW5lLXR1bmUnXG4gICAgfCAnZmluZS10dW5lLXJlc3VsdHMnXG4gICAgfCAndmlzaW9uJztcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQ6IERlcHJlY2F0ZWQuIFRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgZmlsZSwgd2hpY2ggY2FuIGJlIGVpdGhlclxuICAgKiBgdXBsb2FkZWRgLCBgcHJvY2Vzc2VkYCwgb3IgYGVycm9yYC5cbiAgICovXG4gIHN0YXR1czogJ3VwbG9hZGVkJyB8ICdwcm9jZXNzZWQnIHwgJ2Vycm9yJztcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQ6IERlcHJlY2F0ZWQuIEZvciBkZXRhaWxzIG9uIHdoeSBhIGZpbmUtdHVuaW5nIHRyYWluaW5nIGZpbGUgZmFpbGVkXG4gICAqIHZhbGlkYXRpb24sIHNlZSB0aGUgYGVycm9yYCBmaWVsZCBvbiBgZmluZV90dW5pbmcuam9iYC5cbiAgICovXG4gIHN0YXR1c19kZXRhaWxzPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRoZSBpbnRlbmRlZCBwdXJwb3NlIG9mIHRoZSB1cGxvYWRlZCBmaWxlLlxuICpcbiAqIFVzZSBcImFzc2lzdGFudHNcIiBmb3JcbiAqIFtBc3Npc3RhbnRzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIGFuZFxuICogW01lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMpIGZpbGVzLFxuICogXCJ2aXNpb25cIiBmb3IgQXNzaXN0YW50cyBpbWFnZSBmaWxlIGlucHV0cywgXCJiYXRjaFwiIGZvclxuICogW0JhdGNoIEFQSV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2JhdGNoKSwgYW5kIFwiZmluZS10dW5lXCIgZm9yXG4gKiBbRmluZS10dW5pbmddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmluZS10dW5pbmcpLlxuICovXG5leHBvcnQgdHlwZSBGaWxlUHVycG9zZSA9ICdhc3Npc3RhbnRzJyB8ICdiYXRjaCcgfCAnZmluZS10dW5lJyB8ICd2aXNpb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIEZpbGUgb2JqZWN0IChub3QgZmlsZSBuYW1lKSB0byBiZSB1cGxvYWRlZC5cbiAgICovXG4gIGZpbGU6IENvcmUuVXBsb2FkYWJsZTtcblxuICAvKipcbiAgICogVGhlIGludGVuZGVkIHB1cnBvc2Ugb2YgdGhlIHVwbG9hZGVkIGZpbGUuXG4gICAqXG4gICAqIFVzZSBcImFzc2lzdGFudHNcIiBmb3JcbiAgICogW0Fzc2lzdGFudHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgYW5kXG4gICAqIFtNZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzKSBmaWxlcyxcbiAgICogXCJ2aXNpb25cIiBmb3IgQXNzaXN0YW50cyBpbWFnZSBmaWxlIGlucHV0cywgXCJiYXRjaFwiIGZvclxuICAgKiBbQmF0Y2ggQVBJXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYmF0Y2gpLCBhbmQgXCJmaW5lLXR1bmVcIiBmb3JcbiAgICogW0ZpbmUtdHVuaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuaW5nKS5cbiAgICovXG4gIHB1cnBvc2U6IEZpbGVQdXJwb3NlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVMaXN0UGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBTb3J0IG9yZGVyIGJ5IHRoZSBgY3JlYXRlZF9hdGAgdGltZXN0YW1wIG9mIHRoZSBvYmplY3RzLiBgYXNjYCBmb3IgYXNjZW5kaW5nXG4gICAqIG9yZGVyIGFuZCBgZGVzY2AgZm9yIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAqL1xuICBvcmRlcj86ICdhc2MnIHwgJ2Rlc2MnO1xuXG4gIC8qKlxuICAgKiBPbmx5IHJldHVybiBmaWxlcyB3aXRoIHRoZSBnaXZlbiBwdXJwb3NlLlxuICAgKi9cbiAgcHVycG9zZT86IHN0cmluZztcbn1cblxuRmlsZXMuRmlsZU9iamVjdHNQYWdlID0gRmlsZU9iamVjdHNQYWdlO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgRmlsZXMge1xuICBleHBvcnQge1xuICAgIHR5cGUgRmlsZUNvbnRlbnQgYXMgRmlsZUNvbnRlbnQsXG4gICAgdHlwZSBGaWxlRGVsZXRlZCBhcyBGaWxlRGVsZXRlZCxcbiAgICB0eXBlIEZpbGVPYmplY3QgYXMgRmlsZU9iamVjdCxcbiAgICB0eXBlIEZpbGVQdXJwb3NlIGFzIEZpbGVQdXJwb3NlLFxuICAgIEZpbGVPYmplY3RzUGFnZSBhcyBGaWxlT2JqZWN0c1BhZ2UsXG4gICAgdHlwZSBGaWxlQ3JlYXRlUGFyYW1zIGFzIEZpbGVDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBGaWxlTGlzdFBhcmFtcyBhcyBGaWxlTGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgeyBDdXJzb3JQYWdlLCB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9wYWdpbmF0aW9uJztcblxuZXhwb3J0IGNsYXNzIENoZWNrcG9pbnRzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogTGlzdCBjaGVja3BvaW50cyBmb3IgYSBmaW5lLXR1bmluZyBqb2IuXG4gICAqL1xuICBsaXN0KFxuICAgIGZpbmVUdW5pbmdKb2JJZDogc3RyaW5nLFxuICAgIHF1ZXJ5PzogQ2hlY2twb2ludExpc3RQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSwgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnQ+O1xuICBsaXN0KFxuICAgIGZpbmVUdW5pbmdKb2JJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UsIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50PjtcbiAgbGlzdChcbiAgICBmaW5lVHVuaW5nSm9iSWQ6IHN0cmluZyxcbiAgICBxdWVyeTogQ2hlY2twb2ludExpc3RQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSwgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnQ+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3QoZmluZVR1bmluZ0pvYklkLCB7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoXG4gICAgICBgL2ZpbmVfdHVuaW5nL2pvYnMvJHtmaW5lVHVuaW5nSm9iSWR9L2NoZWNrcG9pbnRzYCxcbiAgICAgIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UsXG4gICAgICB7IHF1ZXJ5LCAuLi5vcHRpb25zIH0sXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8RmluZVR1bmluZ0pvYkNoZWNrcG9pbnQ+IHt9XG5cbi8qKlxuICogVGhlIGBmaW5lX3R1bmluZy5qb2IuY2hlY2twb2ludGAgb2JqZWN0IHJlcHJlc2VudHMgYSBtb2RlbCBjaGVja3BvaW50IGZvciBhXG4gKiBmaW5lLXR1bmluZyBqb2IgdGhhdCBpcyByZWFkeSB0byB1c2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnQge1xuICAvKipcbiAgICogVGhlIGNoZWNrcG9pbnQgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gdGhlIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBjaGVja3BvaW50IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZmluZS10dW5lZCBjaGVja3BvaW50IG1vZGVsIHRoYXQgaXMgY3JlYXRlZC5cbiAgICovXG4gIGZpbmVfdHVuZWRfbW9kZWxfY2hlY2twb2ludDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZmluZS10dW5pbmcgam9iIHRoYXQgdGhpcyBjaGVja3BvaW50IHdhcyBjcmVhdGVkIGZyb20uXG4gICAqL1xuICBmaW5lX3R1bmluZ19qb2JfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogTWV0cmljcyBhdCB0aGUgc3RlcCBudW1iZXIgZHVyaW5nIHRoZSBmaW5lLXR1bmluZyBqb2IuXG4gICAqL1xuICBtZXRyaWNzOiBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludC5NZXRyaWNzO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcImZpbmVfdHVuaW5nLmpvYi5jaGVja3BvaW50XCIuXG4gICAqL1xuICBvYmplY3Q6ICdmaW5lX3R1bmluZy5qb2IuY2hlY2twb2ludCc7XG5cbiAgLyoqXG4gICAqIFRoZSBzdGVwIG51bWJlciB0aGF0IHRoZSBjaGVja3BvaW50IHdhcyBjcmVhdGVkIGF0LlxuICAgKi9cbiAgc3RlcF9udW1iZXI6IG51bWJlcjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludCB7XG4gIC8qKlxuICAgKiBNZXRyaWNzIGF0IHRoZSBzdGVwIG51bWJlciBkdXJpbmcgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgTWV0cmljcyB7XG4gICAgZnVsbF92YWxpZF9sb3NzPzogbnVtYmVyO1xuXG4gICAgZnVsbF92YWxpZF9tZWFuX3Rva2VuX2FjY3VyYWN5PzogbnVtYmVyO1xuXG4gICAgc3RlcD86IG51bWJlcjtcblxuICAgIHRyYWluX2xvc3M/OiBudW1iZXI7XG5cbiAgICB0cmFpbl9tZWFuX3Rva2VuX2FjY3VyYWN5PzogbnVtYmVyO1xuXG4gICAgdmFsaWRfbG9zcz86IG51bWJlcjtcblxuICAgIHZhbGlkX21lYW5fdG9rZW5fYWNjdXJhY3k/OiBudW1iZXI7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGVja3BvaW50TGlzdFBhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge31cblxuQ2hlY2twb2ludHMuRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSA9IEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBDaGVja3BvaW50cyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludCBhcyBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludCxcbiAgICBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlIGFzIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UsXG4gICAgdHlwZSBDaGVja3BvaW50TGlzdFBhcmFtcyBhcyBDaGVja3BvaW50TGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDaGVja3BvaW50c0FQSSBmcm9tICcuL2NoZWNrcG9pbnRzJztcbmltcG9ydCB7XG4gIENoZWNrcG9pbnRMaXN0UGFyYW1zLFxuICBDaGVja3BvaW50cyxcbiAgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnQsXG4gIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UsXG59IGZyb20gJy4vY2hlY2twb2ludHMnO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSwgdHlwZSBDdXJzb3JQYWdlUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vcGFnaW5hdGlvbic7XG5cbmV4cG9ydCBjbGFzcyBKb2JzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICBjaGVja3BvaW50czogQ2hlY2twb2ludHNBUEkuQ2hlY2twb2ludHMgPSBuZXcgQ2hlY2twb2ludHNBUEkuQ2hlY2twb2ludHModGhpcy5fY2xpZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZpbmUtdHVuaW5nIGpvYiB3aGljaCBiZWdpbnMgdGhlIHByb2Nlc3Mgb2YgY3JlYXRpbmcgYSBuZXcgbW9kZWwgZnJvbVxuICAgKiBhIGdpdmVuIGRhdGFzZXQuXG4gICAqXG4gICAqIFJlc3BvbnNlIGluY2x1ZGVzIGRldGFpbHMgb2YgdGhlIGVucXVldWVkIGpvYiBpbmNsdWRpbmcgam9iIHN0YXR1cyBhbmQgdGhlIG5hbWVcbiAgICogb2YgdGhlIGZpbmUtdHVuZWQgbW9kZWxzIG9uY2UgY29tcGxldGUuXG4gICAqXG4gICAqIFtMZWFybiBtb3JlIGFib3V0IGZpbmUtdHVuaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAqL1xuICBjcmVhdGUoYm9keTogSm9iQ3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxGaW5lVHVuaW5nSm9iPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvZmluZV90dW5pbmcvam9icycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW5mbyBhYm91dCBhIGZpbmUtdHVuaW5nIGpvYi5cbiAgICpcbiAgICogW0xlYXJuIG1vcmUgYWJvdXQgZmluZS10dW5pbmddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9maW5lLXR1bmluZylcbiAgICovXG4gIHJldHJpZXZlKGZpbmVUdW5pbmdKb2JJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxGaW5lVHVuaW5nSm9iPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC9maW5lX3R1bmluZy9qb2JzLyR7ZmluZVR1bmluZ0pvYklkfWAsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgeW91ciBvcmdhbml6YXRpb24ncyBmaW5lLXR1bmluZyBqb2JzXG4gICAqL1xuICBsaXN0KFxuICAgIHF1ZXJ5PzogSm9iTGlzdFBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxGaW5lVHVuaW5nSm9ic1BhZ2UsIEZpbmVUdW5pbmdKb2I+O1xuICBsaXN0KG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5QYWdlUHJvbWlzZTxGaW5lVHVuaW5nSm9ic1BhZ2UsIEZpbmVUdW5pbmdKb2I+O1xuICBsaXN0KFxuICAgIHF1ZXJ5OiBKb2JMaXN0UGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JzUGFnZSwgRmluZVR1bmluZ0pvYj4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdCh7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy9maW5lX3R1bmluZy9qb2JzJywgRmluZVR1bmluZ0pvYnNQYWdlLCB7IHF1ZXJ5LCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEltbWVkaWF0ZWx5IGNhbmNlbCBhIGZpbmUtdHVuZSBqb2IuXG4gICAqL1xuICBjYW5jZWwoZmluZVR1bmluZ0pvYklkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEZpbmVUdW5pbmdKb2I+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC9maW5lX3R1bmluZy9qb2JzLyR7ZmluZVR1bmluZ0pvYklkfS9jYW5jZWxgLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc3RhdHVzIHVwZGF0ZXMgZm9yIGEgZmluZS10dW5pbmcgam9iLlxuICAgKi9cbiAgbGlzdEV2ZW50cyhcbiAgICBmaW5lVHVuaW5nSm9iSWQ6IHN0cmluZyxcbiAgICBxdWVyeT86IEpvYkxpc3RFdmVudHNQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UsIEZpbmVUdW5pbmdKb2JFdmVudD47XG4gIGxpc3RFdmVudHMoXG4gICAgZmluZVR1bmluZ0pvYklkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UsIEZpbmVUdW5pbmdKb2JFdmVudD47XG4gIGxpc3RFdmVudHMoXG4gICAgZmluZVR1bmluZ0pvYklkOiBzdHJpbmcsXG4gICAgcXVlcnk6IEpvYkxpc3RFdmVudHNQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UsIEZpbmVUdW5pbmdKb2JFdmVudD4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdEV2ZW50cyhmaW5lVHVuaW5nSm9iSWQsIHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdChgL2ZpbmVfdHVuaW5nL2pvYnMvJHtmaW5lVHVuaW5nSm9iSWR9L2V2ZW50c2AsIEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlLCB7XG4gICAgICBxdWVyeSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZpbmVUdW5pbmdKb2JzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8RmluZVR1bmluZ0pvYj4ge31cblxuZXhwb3J0IGNsYXNzIEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxGaW5lVHVuaW5nSm9iRXZlbnQ+IHt9XG5cbi8qKlxuICogVGhlIGBmaW5lX3R1bmluZy5qb2JgIG9iamVjdCByZXByZXNlbnRzIGEgZmluZS10dW5pbmcgam9iIHRoYXQgaGFzIGJlZW4gY3JlYXRlZFxuICogdGhyb3VnaCB0aGUgQVBJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbmVUdW5pbmdKb2Ige1xuICAvKipcbiAgICogVGhlIG9iamVjdCBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGZpbmUtdHVuaW5nIGpvYiB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogRm9yIGZpbmUtdHVuaW5nIGpvYnMgdGhhdCBoYXZlIGBmYWlsZWRgLCB0aGlzIHdpbGwgY29udGFpbiBtb3JlIGluZm9ybWF0aW9uIG9uXG4gICAqIHRoZSBjYXVzZSBvZiB0aGUgZmFpbHVyZS5cbiAgICovXG4gIGVycm9yOiBGaW5lVHVuaW5nSm9iLkVycm9yIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZpbmUtdHVuZWQgbW9kZWwgdGhhdCBpcyBiZWluZyBjcmVhdGVkLiBUaGUgdmFsdWUgd2lsbCBiZSBudWxsXG4gICAqIGlmIHRoZSBmaW5lLXR1bmluZyBqb2IgaXMgc3RpbGwgcnVubmluZy5cbiAgICovXG4gIGZpbmVfdHVuZWRfbW9kZWw6IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGZpbmUtdHVuaW5nIGpvYiB3YXMgZmluaXNoZWQuIFRoZVxuICAgKiB2YWx1ZSB3aWxsIGJlIG51bGwgaWYgdGhlIGZpbmUtdHVuaW5nIGpvYiBpcyBzdGlsbCBydW5uaW5nLlxuICAgKi9cbiAgZmluaXNoZWRfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi4gVGhpcyB2YWx1ZSB3aWxsIG9ubHkgYmVcbiAgICogcmV0dXJuZWQgd2hlbiBydW5uaW5nIGBzdXBlcnZpc2VkYCBqb2JzLlxuICAgKi9cbiAgaHlwZXJwYXJhbWV0ZXJzOiBGaW5lVHVuaW5nSm9iLkh5cGVycGFyYW1ldGVycztcblxuICAvKipcbiAgICogVGhlIGJhc2UgbW9kZWwgdGhhdCBpcyBiZWluZyBmaW5lLXR1bmVkLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgXCJmaW5lX3R1bmluZy5qb2JcIi5cbiAgICovXG4gIG9iamVjdDogJ2ZpbmVfdHVuaW5nLmpvYic7XG5cbiAgLyoqXG4gICAqIFRoZSBvcmdhbml6YXRpb24gdGhhdCBvd25zIHRoZSBmaW5lLXR1bmluZyBqb2IuXG4gICAqL1xuICBvcmdhbml6YXRpb25faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGNvbXBpbGVkIHJlc3VsdHMgZmlsZSBJRChzKSBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi4gWW91IGNhbiByZXRyaWV2ZSB0aGVcbiAgICogcmVzdWx0cyB3aXRoIHRoZVxuICAgKiBbRmlsZXMgQVBJXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL3JldHJpZXZlLWNvbnRlbnRzKS5cbiAgICovXG4gIHJlc3VsdF9maWxlczogQXJyYXk8c3RyaW5nPjtcblxuICAvKipcbiAgICogVGhlIHNlZWQgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIHNlZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBmaW5lLXR1bmluZyBqb2IsIHdoaWNoIGNhbiBiZSBlaXRoZXJcbiAgICogYHZhbGlkYXRpbmdfZmlsZXNgLCBgcXVldWVkYCwgYHJ1bm5pbmdgLCBgc3VjY2VlZGVkYCwgYGZhaWxlZGAsIG9yIGBjYW5jZWxsZWRgLlxuICAgKi9cbiAgc3RhdHVzOiAndmFsaWRhdGluZ19maWxlcycgfCAncXVldWVkJyB8ICdydW5uaW5nJyB8ICdzdWNjZWVkZWQnIHwgJ2ZhaWxlZCcgfCAnY2FuY2VsbGVkJztcblxuICAvKipcbiAgICogVGhlIHRvdGFsIG51bWJlciBvZiBiaWxsYWJsZSB0b2tlbnMgcHJvY2Vzc2VkIGJ5IHRoaXMgZmluZS10dW5pbmcgam9iLiBUaGUgdmFsdWVcbiAgICogd2lsbCBiZSBudWxsIGlmIHRoZSBmaW5lLXR1bmluZyBqb2IgaXMgc3RpbGwgcnVubmluZy5cbiAgICovXG4gIHRyYWluZWRfdG9rZW5zOiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgZmlsZSBJRCB1c2VkIGZvciB0cmFpbmluZy4gWW91IGNhbiByZXRyaWV2ZSB0aGUgdHJhaW5pbmcgZGF0YSB3aXRoIHRoZVxuICAgKiBbRmlsZXMgQVBJXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL3JldHJpZXZlLWNvbnRlbnRzKS5cbiAgICovXG4gIHRyYWluaW5nX2ZpbGU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGZpbGUgSUQgdXNlZCBmb3IgdmFsaWRhdGlvbi4gWW91IGNhbiByZXRyaWV2ZSB0aGUgdmFsaWRhdGlvbiByZXN1bHRzIHdpdGhcbiAgICogdGhlXG4gICAqIFtGaWxlcyBBUEldKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMvcmV0cmlldmUtY29udGVudHMpLlxuICAgKi9cbiAgdmFsaWRhdGlvbl9maWxlOiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBmaW5lLXR1bmluZyBqb2IgaXMgZXN0aW1hdGVkIHRvXG4gICAqIGZpbmlzaC4gVGhlIHZhbHVlIHdpbGwgYmUgbnVsbCBpZiB0aGUgZmluZS10dW5pbmcgam9iIGlzIG5vdCBydW5uaW5nLlxuICAgKi9cbiAgZXN0aW1hdGVkX2ZpbmlzaD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBpbnRlZ3JhdGlvbnMgdG8gZW5hYmxlIGZvciB0aGlzIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIGludGVncmF0aW9ucz86IEFycmF5PEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uT2JqZWN0PiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgdXNlZCBmb3IgZmluZS10dW5pbmcuXG4gICAqL1xuICBtZXRob2Q/OiBGaW5lVHVuaW5nSm9iLk1ldGhvZDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaW5lVHVuaW5nSm9iIHtcbiAgLyoqXG4gICAqIEZvciBmaW5lLXR1bmluZyBqb2JzIHRoYXQgaGF2ZSBgZmFpbGVkYCwgdGhpcyB3aWxsIGNvbnRhaW4gbW9yZSBpbmZvcm1hdGlvbiBvblxuICAgKiB0aGUgY2F1c2Ugb2YgdGhlIGZhaWx1cmUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBBIG1hY2hpbmUtcmVhZGFibGUgZXJyb3IgY29kZS5cbiAgICAgKi9cbiAgICBjb2RlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgbWVzc2FnZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcmFtZXRlciB0aGF0IHdhcyBpbnZhbGlkLCB1c3VhbGx5IGB0cmFpbmluZ19maWxlYCBvciBgdmFsaWRhdGlvbl9maWxlYC5cbiAgICAgKiBUaGlzIGZpZWxkIHdpbGwgYmUgbnVsbCBpZiB0aGUgZmFpbHVyZSB3YXMgbm90IHBhcmFtZXRlci1zcGVjaWZpYy5cbiAgICAgKi9cbiAgICBwYXJhbTogc3RyaW5nIHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuIFRoaXMgdmFsdWUgd2lsbCBvbmx5IGJlXG4gICAqIHJldHVybmVkIHdoZW4gcnVubmluZyBgc3VwZXJ2aXNlZGAgam9icy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSHlwZXJwYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgZXhhbXBsZXMgaW4gZWFjaCBiYXRjaC4gQSBsYXJnZXIgYmF0Y2ggc2l6ZSBtZWFucyB0aGF0IG1vZGVsXG4gICAgICogcGFyYW1ldGVycyBhcmUgdXBkYXRlZCBsZXNzIGZyZXF1ZW50bHksIGJ1dCB3aXRoIGxvd2VyIHZhcmlhbmNlLlxuICAgICAqL1xuICAgIGJhdGNoX3NpemU/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBTY2FsaW5nIGZhY3RvciBmb3IgdGhlIGxlYXJuaW5nIHJhdGUuIEEgc21hbGxlciBsZWFybmluZyByYXRlIG1heSBiZSB1c2VmdWwgdG9cbiAgICAgKiBhdm9pZCBvdmVyZml0dGluZy5cbiAgICAgKi9cbiAgICBsZWFybmluZ19yYXRlX211bHRpcGxpZXI/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGVwb2NocyB0byB0cmFpbiB0aGUgbW9kZWwgZm9yLiBBbiBlcG9jaCByZWZlcnMgdG8gb25lIGZ1bGwgY3ljbGVcbiAgICAgKiB0aHJvdWdoIHRoZSB0cmFpbmluZyBkYXRhc2V0LlxuICAgICAqL1xuICAgIG5fZXBvY2hzPzogJ2F1dG8nIHwgbnVtYmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgdXNlZCBmb3IgZmluZS10dW5pbmcuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIE1ldGhvZCB7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIERQTyBmaW5lLXR1bmluZyBtZXRob2QuXG4gICAgICovXG4gICAgZHBvPzogTWV0aG9kLkRwbztcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBlcnZpc2VkIGZpbmUtdHVuaW5nIG1ldGhvZC5cbiAgICAgKi9cbiAgICBzdXBlcnZpc2VkPzogTWV0aG9kLlN1cGVydmlzZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBtZXRob2QuIElzIGVpdGhlciBgc3VwZXJ2aXNlZGAgb3IgYGRwb2AuXG4gICAgICovXG4gICAgdHlwZT86ICdzdXBlcnZpc2VkJyB8ICdkcG8nO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBNZXRob2Qge1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBEUE8gZmluZS10dW5pbmcgbWV0aG9kLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgRHBvIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgICAgICovXG4gICAgICBoeXBlcnBhcmFtZXRlcnM/OiBEcG8uSHlwZXJwYXJhbWV0ZXJzO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgRHBvIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgICAgICovXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEh5cGVycGFyYW1ldGVycyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgZXhhbXBsZXMgaW4gZWFjaCBiYXRjaC4gQSBsYXJnZXIgYmF0Y2ggc2l6ZSBtZWFucyB0aGF0IG1vZGVsXG4gICAgICAgICAqIHBhcmFtZXRlcnMgYXJlIHVwZGF0ZWQgbGVzcyBmcmVxdWVudGx5LCBidXQgd2l0aCBsb3dlciB2YXJpYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIGJhdGNoX3NpemU/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiZXRhIHZhbHVlIGZvciB0aGUgRFBPIG1ldGhvZC4gQSBoaWdoZXIgYmV0YSB2YWx1ZSB3aWxsIGluY3JlYXNlIHRoZSB3ZWlnaHRcbiAgICAgICAgICogb2YgdGhlIHBlbmFsdHkgYmV0d2VlbiB0aGUgcG9saWN5IGFuZCByZWZlcmVuY2UgbW9kZWwuXG4gICAgICAgICAqL1xuICAgICAgICBiZXRhPzogJ2F1dG8nIHwgbnVtYmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY2FsaW5nIGZhY3RvciBmb3IgdGhlIGxlYXJuaW5nIHJhdGUuIEEgc21hbGxlciBsZWFybmluZyByYXRlIG1heSBiZSB1c2VmdWwgdG9cbiAgICAgICAgICogYXZvaWQgb3ZlcmZpdHRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBsZWFybmluZ19yYXRlX211bHRpcGxpZXI/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgZXBvY2hzIHRvIHRyYWluIHRoZSBtb2RlbCBmb3IuIEFuIGVwb2NoIHJlZmVycyB0byBvbmUgZnVsbCBjeWNsZVxuICAgICAgICAgKiB0aHJvdWdoIHRoZSB0cmFpbmluZyBkYXRhc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgbl9lcG9jaHM/OiAnYXV0bycgfCBudW1iZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIHN1cGVydmlzZWQgZmluZS10dW5pbmcgbWV0aG9kLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgU3VwZXJ2aXNlZCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICAgICAqL1xuICAgICAgaHlwZXJwYXJhbWV0ZXJzPzogU3VwZXJ2aXNlZC5IeXBlcnBhcmFtZXRlcnM7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBTdXBlcnZpc2VkIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgICAgICovXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEh5cGVycGFyYW1ldGVycyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgZXhhbXBsZXMgaW4gZWFjaCBiYXRjaC4gQSBsYXJnZXIgYmF0Y2ggc2l6ZSBtZWFucyB0aGF0IG1vZGVsXG4gICAgICAgICAqIHBhcmFtZXRlcnMgYXJlIHVwZGF0ZWQgbGVzcyBmcmVxdWVudGx5LCBidXQgd2l0aCBsb3dlciB2YXJpYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIGJhdGNoX3NpemU/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxpbmcgZmFjdG9yIGZvciB0aGUgbGVhcm5pbmcgcmF0ZS4gQSBzbWFsbGVyIGxlYXJuaW5nIHJhdGUgbWF5IGJlIHVzZWZ1bCB0b1xuICAgICAgICAgKiBhdm9pZCBvdmVyZml0dGluZy5cbiAgICAgICAgICovXG4gICAgICAgIGxlYXJuaW5nX3JhdGVfbXVsdGlwbGllcj86ICdhdXRvJyB8IG51bWJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBlcG9jaHMgdG8gdHJhaW4gdGhlIG1vZGVsIGZvci4gQW4gZXBvY2ggcmVmZXJzIHRvIG9uZSBmdWxsIGN5Y2xlXG4gICAgICAgICAqIHRocm91Z2ggdGhlIHRyYWluaW5nIGRhdGFzZXQuXG4gICAgICAgICAqL1xuICAgICAgICBuX2Vwb2Nocz86ICdhdXRvJyB8IG51bWJlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBGaW5lLXR1bmluZyBqb2IgZXZlbnQgb2JqZWN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmluZVR1bmluZ0pvYkV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgaWRlbnRpZmllci5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGZpbmUtdHVuaW5nIGpvYiB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGxvZyBsZXZlbCBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBsZXZlbDogJ2luZm8nIHwgJ3dhcm4nIHwgJ2Vycm9yJztcblxuICAvKipcbiAgICogVGhlIG1lc3NhZ2Ugb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgbWVzc2FnZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcImZpbmVfdHVuaW5nLmpvYi5ldmVudFwiLlxuICAgKi9cbiAgb2JqZWN0OiAnZmluZV90dW5pbmcuam9iLmV2ZW50JztcblxuICAvKipcbiAgICogVGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cbiAgICovXG4gIGRhdGE/OiB1bmtub3duO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudC5cbiAgICovXG4gIHR5cGU/OiAnbWVzc2FnZScgfCAnbWV0cmljcyc7XG59XG5cbmV4cG9ydCB0eXBlIEZpbmVUdW5pbmdKb2JJbnRlZ3JhdGlvbiA9IEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uT2JqZWN0O1xuXG4vKipcbiAqIFRoZSBzZXR0aW5ncyBmb3IgeW91ciBpbnRlZ3JhdGlvbiB3aXRoIFdlaWdodHMgYW5kIEJpYXNlcy4gVGhpcyBwYXlsb2FkXG4gKiBzcGVjaWZpZXMgdGhlIHByb2plY3QgdGhhdCBtZXRyaWNzIHdpbGwgYmUgc2VudCB0by4gT3B0aW9uYWxseSwgeW91IGNhbiBzZXQgYW5cbiAqIGV4cGxpY2l0IGRpc3BsYXkgbmFtZSBmb3IgeW91ciBydW4sIGFkZCB0YWdzIHRvIHlvdXIgcnVuLCBhbmQgc2V0IGEgZGVmYXVsdFxuICogZW50aXR5ICh0ZWFtLCB1c2VybmFtZSwgZXRjKSB0byBiZSBhc3NvY2lhdGVkIHdpdGggeW91ciBydW4uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb24ge1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHByb2plY3QgdGhhdCB0aGUgbmV3IHJ1biB3aWxsIGJlIGNyZWF0ZWQgdW5kZXIuXG4gICAqL1xuICBwcm9qZWN0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbnRpdHkgdG8gdXNlIGZvciB0aGUgcnVuLiBUaGlzIGFsbG93cyB5b3UgdG8gc2V0IHRoZSB0ZWFtIG9yIHVzZXJuYW1lIG9mXG4gICAqIHRoZSBXYW5kQiB1c2VyIHRoYXQgeW91IHdvdWxkIGxpa2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBydW4uIElmIG5vdCBzZXQsIHRoZVxuICAgKiBkZWZhdWx0IGVudGl0eSBmb3IgdGhlIHJlZ2lzdGVyZWQgV2FuZEIgQVBJIGtleSBpcyB1c2VkLlxuICAgKi9cbiAgZW50aXR5Pzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBkaXNwbGF5IG5hbWUgdG8gc2V0IGZvciB0aGUgcnVuLiBJZiBub3Qgc2V0LCB3ZSB3aWxsIHVzZSB0aGUgSm9iIElEIGFzIHRoZVxuICAgKiBuYW1lLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0YWdzIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBuZXdseSBjcmVhdGVkIHJ1bi4gVGhlc2UgdGFncyBhcmUgcGFzc2VkXG4gICAqIHRocm91Z2ggZGlyZWN0bHkgdG8gV2FuZEIuIFNvbWUgZGVmYXVsdCB0YWdzIGFyZSBnZW5lcmF0ZWQgYnkgT3BlbkFJOlxuICAgKiBcIm9wZW5haS9maW5ldHVuZVwiLCBcIm9wZW5haS97YmFzZS1tb2RlbH1cIiwgXCJvcGVuYWkve2Z0am9iLWFiY2RlZn1cIi5cbiAgICovXG4gIHRhZ3M/OiBBcnJheTxzdHJpbmc+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uT2JqZWN0IHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBpbnRlZ3JhdGlvbiBiZWluZyBlbmFibGVkIGZvciB0aGUgZmluZS10dW5pbmcgam9iXG4gICAqL1xuICB0eXBlOiAnd2FuZGInO1xuXG4gIC8qKlxuICAgKiBUaGUgc2V0dGluZ3MgZm9yIHlvdXIgaW50ZWdyYXRpb24gd2l0aCBXZWlnaHRzIGFuZCBCaWFzZXMuIFRoaXMgcGF5bG9hZFxuICAgKiBzcGVjaWZpZXMgdGhlIHByb2plY3QgdGhhdCBtZXRyaWNzIHdpbGwgYmUgc2VudCB0by4gT3B0aW9uYWxseSwgeW91IGNhbiBzZXQgYW5cbiAgICogZXhwbGljaXQgZGlzcGxheSBuYW1lIGZvciB5b3VyIHJ1biwgYWRkIHRhZ3MgdG8geW91ciBydW4sIGFuZCBzZXQgYSBkZWZhdWx0XG4gICAqIGVudGl0eSAodGVhbSwgdXNlcm5hbWUsIGV0YykgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHlvdXIgcnVuLlxuICAgKi9cbiAgd2FuZGI6IEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEpvYkNyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgbW9kZWwgdG8gZmluZS10dW5lLiBZb3UgY2FuIHNlbGVjdCBvbmUgb2YgdGhlXG4gICAqIFtzdXBwb3J0ZWQgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcjd2hpY2gtbW9kZWxzLWNhbi1iZS1maW5lLXR1bmVkKS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgJ2JhYmJhZ2UtMDAyJyB8ICdkYXZpbmNpLTAwMicgfCAnZ3B0LTMuNS10dXJibycgfCAnZ3B0LTRvLW1pbmknO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgYW4gdXBsb2FkZWQgZmlsZSB0aGF0IGNvbnRhaW5zIHRyYWluaW5nIGRhdGEuXG4gICAqXG4gICAqIFNlZSBbdXBsb2FkIGZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMvY3JlYXRlKVxuICAgKiBmb3IgaG93IHRvIHVwbG9hZCBhIGZpbGUuXG4gICAqXG4gICAqIFlvdXIgZGF0YXNldCBtdXN0IGJlIGZvcm1hdHRlZCBhcyBhIEpTT05MIGZpbGUuIEFkZGl0aW9uYWxseSwgeW91IG11c3QgdXBsb2FkXG4gICAqIHlvdXIgZmlsZSB3aXRoIHRoZSBwdXJwb3NlIGBmaW5lLXR1bmVgLlxuICAgKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGZpbGUgc2hvdWxkIGRpZmZlciBkZXBlbmRpbmcgb24gaWYgdGhlIG1vZGVsIHVzZXMgdGhlXG4gICAqIFtjaGF0XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuaW5nL2NoYXQtaW5wdXQpLFxuICAgKiBbY29tcGxldGlvbnNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmluZS10dW5pbmcvY29tcGxldGlvbnMtaW5wdXQpXG4gICAqIGZvcm1hdCwgb3IgaWYgdGhlIGZpbmUtdHVuaW5nIG1ldGhvZCB1c2VzIHRoZVxuICAgKiBbcHJlZmVyZW5jZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maW5lLXR1bmluZy9wcmVmZXJlbmNlLWlucHV0KVxuICAgKiBmb3JtYXQuXG4gICAqXG4gICAqIFNlZSB0aGUgW2ZpbmUtdHVuaW5nIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICB0cmFpbmluZ19maWxlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi4gVGhpcyB2YWx1ZSBpcyBub3cgZGVwcmVjYXRlZFxuICAgKiBpbiBmYXZvciBvZiBgbWV0aG9kYCwgYW5kIHNob3VsZCBiZSBwYXNzZWQgaW4gdW5kZXIgdGhlIGBtZXRob2RgIHBhcmFtZXRlci5cbiAgICovXG4gIGh5cGVycGFyYW1ldGVycz86IEpvYkNyZWF0ZVBhcmFtcy5IeXBlcnBhcmFtZXRlcnM7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBpbnRlZ3JhdGlvbnMgdG8gZW5hYmxlIGZvciB5b3VyIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIGludGVncmF0aW9ucz86IEFycmF5PEpvYkNyZWF0ZVBhcmFtcy5JbnRlZ3JhdGlvbj4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWV0aG9kIHVzZWQgZm9yIGZpbmUtdHVuaW5nLlxuICAgKi9cbiAgbWV0aG9kPzogSm9iQ3JlYXRlUGFyYW1zLk1ldGhvZDtcblxuICAvKipcbiAgICogVGhlIHNlZWQgY29udHJvbHMgdGhlIHJlcHJvZHVjaWJpbGl0eSBvZiB0aGUgam9iLiBQYXNzaW5nIGluIHRoZSBzYW1lIHNlZWQgYW5kXG4gICAqIGpvYiBwYXJhbWV0ZXJzIHNob3VsZCBwcm9kdWNlIHRoZSBzYW1lIHJlc3VsdHMsIGJ1dCBtYXkgZGlmZmVyIGluIHJhcmUgY2FzZXMuIElmXG4gICAqIGEgc2VlZCBpcyBub3Qgc3BlY2lmaWVkLCBvbmUgd2lsbCBiZSBnZW5lcmF0ZWQgZm9yIHlvdS5cbiAgICovXG4gIHNlZWQ/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHN0cmluZyBvZiB1cCB0byA2NCBjaGFyYWN0ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB5b3VyIGZpbmUtdHVuZWQgbW9kZWxcbiAgICogbmFtZS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGEgYHN1ZmZpeGAgb2YgXCJjdXN0b20tbW9kZWwtbmFtZVwiIHdvdWxkIHByb2R1Y2UgYSBtb2RlbCBuYW1lIGxpa2VcbiAgICogYGZ0OmdwdC00by1taW5pOm9wZW5haTpjdXN0b20tbW9kZWwtbmFtZTo3cDRsVVJlbGAuXG4gICAqL1xuICBzdWZmaXg/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgYW4gdXBsb2FkZWQgZmlsZSB0aGF0IGNvbnRhaW5zIHZhbGlkYXRpb24gZGF0YS5cbiAgICpcbiAgICogSWYgeW91IHByb3ZpZGUgdGhpcyBmaWxlLCB0aGUgZGF0YSBpcyB1c2VkIHRvIGdlbmVyYXRlIHZhbGlkYXRpb24gbWV0cmljc1xuICAgKiBwZXJpb2RpY2FsbHkgZHVyaW5nIGZpbmUtdHVuaW5nLiBUaGVzZSBtZXRyaWNzIGNhbiBiZSB2aWV3ZWQgaW4gdGhlIGZpbmUtdHVuaW5nXG4gICAqIHJlc3VsdHMgZmlsZS4gVGhlIHNhbWUgZGF0YSBzaG91bGQgbm90IGJlIHByZXNlbnQgaW4gYm90aCB0cmFpbiBhbmQgdmFsaWRhdGlvblxuICAgKiBmaWxlcy5cbiAgICpcbiAgICogWW91ciBkYXRhc2V0IG11c3QgYmUgZm9ybWF0dGVkIGFzIGEgSlNPTkwgZmlsZS4gWW91IG11c3QgdXBsb2FkIHlvdXIgZmlsZSB3aXRoXG4gICAqIHRoZSBwdXJwb3NlIGBmaW5lLXR1bmVgLlxuICAgKlxuICAgKiBTZWUgdGhlIFtmaW5lLXR1bmluZyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2ZpbmUtdHVuaW5nKVxuICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgdmFsaWRhdGlvbl9maWxlPzogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBKb2JDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQ6IFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi4gVGhpcyB2YWx1ZSBpcyBub3dcbiAgICogZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBgbWV0aG9kYCwgYW5kIHNob3VsZCBiZSBwYXNzZWQgaW4gdW5kZXIgdGhlIGBtZXRob2RgXG4gICAqIHBhcmFtZXRlci5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSHlwZXJwYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgZXhhbXBsZXMgaW4gZWFjaCBiYXRjaC4gQSBsYXJnZXIgYmF0Y2ggc2l6ZSBtZWFucyB0aGF0IG1vZGVsXG4gICAgICogcGFyYW1ldGVycyBhcmUgdXBkYXRlZCBsZXNzIGZyZXF1ZW50bHksIGJ1dCB3aXRoIGxvd2VyIHZhcmlhbmNlLlxuICAgICAqL1xuICAgIGJhdGNoX3NpemU/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBTY2FsaW5nIGZhY3RvciBmb3IgdGhlIGxlYXJuaW5nIHJhdGUuIEEgc21hbGxlciBsZWFybmluZyByYXRlIG1heSBiZSB1c2VmdWwgdG9cbiAgICAgKiBhdm9pZCBvdmVyZml0dGluZy5cbiAgICAgKi9cbiAgICBsZWFybmluZ19yYXRlX211bHRpcGxpZXI/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGVwb2NocyB0byB0cmFpbiB0aGUgbW9kZWwgZm9yLiBBbiBlcG9jaCByZWZlcnMgdG8gb25lIGZ1bGwgY3ljbGVcbiAgICAgKiB0aHJvdWdoIHRoZSB0cmFpbmluZyBkYXRhc2V0LlxuICAgICAqL1xuICAgIG5fZXBvY2hzPzogJ2F1dG8nIHwgbnVtYmVyO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBJbnRlZ3JhdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgaW50ZWdyYXRpb24gdG8gZW5hYmxlLiBDdXJyZW50bHksIG9ubHkgXCJ3YW5kYlwiIChXZWlnaHRzIGFuZCBCaWFzZXMpXG4gICAgICogaXMgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIHR5cGU6ICd3YW5kYic7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2V0dGluZ3MgZm9yIHlvdXIgaW50ZWdyYXRpb24gd2l0aCBXZWlnaHRzIGFuZCBCaWFzZXMuIFRoaXMgcGF5bG9hZFxuICAgICAqIHNwZWNpZmllcyB0aGUgcHJvamVjdCB0aGF0IG1ldHJpY3Mgd2lsbCBiZSBzZW50IHRvLiBPcHRpb25hbGx5LCB5b3UgY2FuIHNldCBhblxuICAgICAqIGV4cGxpY2l0IGRpc3BsYXkgbmFtZSBmb3IgeW91ciBydW4sIGFkZCB0YWdzIHRvIHlvdXIgcnVuLCBhbmQgc2V0IGEgZGVmYXVsdFxuICAgICAqIGVudGl0eSAodGVhbSwgdXNlcm5hbWUsIGV0YykgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHlvdXIgcnVuLlxuICAgICAqL1xuICAgIHdhbmRiOiBJbnRlZ3JhdGlvbi5XYW5kYjtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgSW50ZWdyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXR0aW5ncyBmb3IgeW91ciBpbnRlZ3JhdGlvbiB3aXRoIFdlaWdodHMgYW5kIEJpYXNlcy4gVGhpcyBwYXlsb2FkXG4gICAgICogc3BlY2lmaWVzIHRoZSBwcm9qZWN0IHRoYXQgbWV0cmljcyB3aWxsIGJlIHNlbnQgdG8uIE9wdGlvbmFsbHksIHlvdSBjYW4gc2V0IGFuXG4gICAgICogZXhwbGljaXQgZGlzcGxheSBuYW1lIGZvciB5b3VyIHJ1biwgYWRkIHRhZ3MgdG8geW91ciBydW4sIGFuZCBzZXQgYSBkZWZhdWx0XG4gICAgICogZW50aXR5ICh0ZWFtLCB1c2VybmFtZSwgZXRjKSB0byBiZSBhc3NvY2lhdGVkIHdpdGggeW91ciBydW4uXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBXYW5kYiB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9qZWN0IHRoYXQgdGhlIG5ldyBydW4gd2lsbCBiZSBjcmVhdGVkIHVuZGVyLlxuICAgICAgICovXG4gICAgICBwcm9qZWN0OiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGVudGl0eSB0byB1c2UgZm9yIHRoZSBydW4uIFRoaXMgYWxsb3dzIHlvdSB0byBzZXQgdGhlIHRlYW0gb3IgdXNlcm5hbWUgb2ZcbiAgICAgICAqIHRoZSBXYW5kQiB1c2VyIHRoYXQgeW91IHdvdWxkIGxpa2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBydW4uIElmIG5vdCBzZXQsIHRoZVxuICAgICAgICogZGVmYXVsdCBlbnRpdHkgZm9yIHRoZSByZWdpc3RlcmVkIFdhbmRCIEFQSSBrZXkgaXMgdXNlZC5cbiAgICAgICAqL1xuICAgICAgZW50aXR5Pzogc3RyaW5nIHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGRpc3BsYXkgbmFtZSB0byBzZXQgZm9yIHRoZSBydW4uIElmIG5vdCBzZXQsIHdlIHdpbGwgdXNlIHRoZSBKb2IgSUQgYXMgdGhlXG4gICAgICAgKiBuYW1lLlxuICAgICAgICovXG4gICAgICBuYW1lPzogc3RyaW5nIHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgdGFncyB0byBiZSBhdHRhY2hlZCB0byB0aGUgbmV3bHkgY3JlYXRlZCBydW4uIFRoZXNlIHRhZ3MgYXJlIHBhc3NlZFxuICAgICAgICogdGhyb3VnaCBkaXJlY3RseSB0byBXYW5kQi4gU29tZSBkZWZhdWx0IHRhZ3MgYXJlIGdlbmVyYXRlZCBieSBPcGVuQUk6XG4gICAgICAgKiBcIm9wZW5haS9maW5ldHVuZVwiLCBcIm9wZW5haS97YmFzZS1tb2RlbH1cIiwgXCJvcGVuYWkve2Z0am9iLWFiY2RlZn1cIi5cbiAgICAgICAqL1xuICAgICAgdGFncz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgdXNlZCBmb3IgZmluZS10dW5pbmcuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIE1ldGhvZCB7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIERQTyBmaW5lLXR1bmluZyBtZXRob2QuXG4gICAgICovXG4gICAgZHBvPzogTWV0aG9kLkRwbztcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBlcnZpc2VkIGZpbmUtdHVuaW5nIG1ldGhvZC5cbiAgICAgKi9cbiAgICBzdXBlcnZpc2VkPzogTWV0aG9kLlN1cGVydmlzZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBtZXRob2QuIElzIGVpdGhlciBgc3VwZXJ2aXNlZGAgb3IgYGRwb2AuXG4gICAgICovXG4gICAgdHlwZT86ICdzdXBlcnZpc2VkJyB8ICdkcG8nO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBNZXRob2Qge1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBEUE8gZmluZS10dW5pbmcgbWV0aG9kLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgRHBvIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgICAgICovXG4gICAgICBoeXBlcnBhcmFtZXRlcnM/OiBEcG8uSHlwZXJwYXJhbWV0ZXJzO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgRHBvIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgICAgICovXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEh5cGVycGFyYW1ldGVycyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgZXhhbXBsZXMgaW4gZWFjaCBiYXRjaC4gQSBsYXJnZXIgYmF0Y2ggc2l6ZSBtZWFucyB0aGF0IG1vZGVsXG4gICAgICAgICAqIHBhcmFtZXRlcnMgYXJlIHVwZGF0ZWQgbGVzcyBmcmVxdWVudGx5LCBidXQgd2l0aCBsb3dlciB2YXJpYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIGJhdGNoX3NpemU/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiZXRhIHZhbHVlIGZvciB0aGUgRFBPIG1ldGhvZC4gQSBoaWdoZXIgYmV0YSB2YWx1ZSB3aWxsIGluY3JlYXNlIHRoZSB3ZWlnaHRcbiAgICAgICAgICogb2YgdGhlIHBlbmFsdHkgYmV0d2VlbiB0aGUgcG9saWN5IGFuZCByZWZlcmVuY2UgbW9kZWwuXG4gICAgICAgICAqL1xuICAgICAgICBiZXRhPzogJ2F1dG8nIHwgbnVtYmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY2FsaW5nIGZhY3RvciBmb3IgdGhlIGxlYXJuaW5nIHJhdGUuIEEgc21hbGxlciBsZWFybmluZyByYXRlIG1heSBiZSB1c2VmdWwgdG9cbiAgICAgICAgICogYXZvaWQgb3ZlcmZpdHRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBsZWFybmluZ19yYXRlX211bHRpcGxpZXI/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgZXBvY2hzIHRvIHRyYWluIHRoZSBtb2RlbCBmb3IuIEFuIGVwb2NoIHJlZmVycyB0byBvbmUgZnVsbCBjeWNsZVxuICAgICAgICAgKiB0aHJvdWdoIHRoZSB0cmFpbmluZyBkYXRhc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgbl9lcG9jaHM/OiAnYXV0bycgfCBudW1iZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIHN1cGVydmlzZWQgZmluZS10dW5pbmcgbWV0aG9kLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgU3VwZXJ2aXNlZCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICAgICAqL1xuICAgICAgaHlwZXJwYXJhbWV0ZXJzPzogU3VwZXJ2aXNlZC5IeXBlcnBhcmFtZXRlcnM7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBTdXBlcnZpc2VkIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgICAgICovXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEh5cGVycGFyYW1ldGVycyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgZXhhbXBsZXMgaW4gZWFjaCBiYXRjaC4gQSBsYXJnZXIgYmF0Y2ggc2l6ZSBtZWFucyB0aGF0IG1vZGVsXG4gICAgICAgICAqIHBhcmFtZXRlcnMgYXJlIHVwZGF0ZWQgbGVzcyBmcmVxdWVudGx5LCBidXQgd2l0aCBsb3dlciB2YXJpYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIGJhdGNoX3NpemU/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxpbmcgZmFjdG9yIGZvciB0aGUgbGVhcm5pbmcgcmF0ZS4gQSBzbWFsbGVyIGxlYXJuaW5nIHJhdGUgbWF5IGJlIHVzZWZ1bCB0b1xuICAgICAgICAgKiBhdm9pZCBvdmVyZml0dGluZy5cbiAgICAgICAgICovXG4gICAgICAgIGxlYXJuaW5nX3JhdGVfbXVsdGlwbGllcj86ICdhdXRvJyB8IG51bWJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBlcG9jaHMgdG8gdHJhaW4gdGhlIG1vZGVsIGZvci4gQW4gZXBvY2ggcmVmZXJzIHRvIG9uZSBmdWxsIGN5Y2xlXG4gICAgICAgICAqIHRocm91Z2ggdGhlIHRyYWluaW5nIGRhdGFzZXQuXG4gICAgICAgICAqL1xuICAgICAgICBuX2Vwb2Nocz86ICdhdXRvJyB8IG51bWJlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBKb2JMaXN0UGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIEpvYkxpc3RFdmVudHNQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHt9XG5cbkpvYnMuRmluZVR1bmluZ0pvYnNQYWdlID0gRmluZVR1bmluZ0pvYnNQYWdlO1xuSm9icy5GaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSA9IEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlO1xuSm9icy5DaGVja3BvaW50cyA9IENoZWNrcG9pbnRzO1xuSm9icy5GaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlID0gRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEpvYnMge1xuICBleHBvcnQge1xuICAgIHR5cGUgRmluZVR1bmluZ0pvYiBhcyBGaW5lVHVuaW5nSm9iLFxuICAgIHR5cGUgRmluZVR1bmluZ0pvYkV2ZW50IGFzIEZpbmVUdW5pbmdKb2JFdmVudCxcbiAgICB0eXBlIEZpbmVUdW5pbmdKb2JJbnRlZ3JhdGlvbiBhcyBGaW5lVHVuaW5nSm9iSW50ZWdyYXRpb24sXG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbiBhcyBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbixcbiAgICB0eXBlIEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uT2JqZWN0IGFzIEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uT2JqZWN0LFxuICAgIEZpbmVUdW5pbmdKb2JzUGFnZSBhcyBGaW5lVHVuaW5nSm9ic1BhZ2UsXG4gICAgRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UgYXMgRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UsXG4gICAgdHlwZSBKb2JDcmVhdGVQYXJhbXMgYXMgSm9iQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgSm9iTGlzdFBhcmFtcyBhcyBKb2JMaXN0UGFyYW1zLFxuICAgIHR5cGUgSm9iTGlzdEV2ZW50c1BhcmFtcyBhcyBKb2JMaXN0RXZlbnRzUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgQ2hlY2twb2ludHMgYXMgQ2hlY2twb2ludHMsXG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludCBhcyBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludCxcbiAgICBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlIGFzIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UsXG4gICAgdHlwZSBDaGVja3BvaW50TGlzdFBhcmFtcyBhcyBDaGVja3BvaW50TGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIEpvYnNBUEkgZnJvbSAnLi9qb2JzL2pvYnMnO1xuaW1wb3J0IHtcbiAgRmluZVR1bmluZ0pvYixcbiAgRmluZVR1bmluZ0pvYkV2ZW50LFxuICBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSxcbiAgRmluZVR1bmluZ0pvYkludGVncmF0aW9uLFxuICBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbixcbiAgRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb25PYmplY3QsXG4gIEZpbmVUdW5pbmdKb2JzUGFnZSxcbiAgSm9iQ3JlYXRlUGFyYW1zLFxuICBKb2JMaXN0RXZlbnRzUGFyYW1zLFxuICBKb2JMaXN0UGFyYW1zLFxuICBKb2JzLFxufSBmcm9tICcuL2pvYnMvam9icyc7XG5cbmV4cG9ydCBjbGFzcyBGaW5lVHVuaW5nIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICBqb2JzOiBKb2JzQVBJLkpvYnMgPSBuZXcgSm9ic0FQSS5Kb2JzKHRoaXMuX2NsaWVudCk7XG59XG5cbkZpbmVUdW5pbmcuSm9icyA9IEpvYnM7XG5GaW5lVHVuaW5nLkZpbmVUdW5pbmdKb2JzUGFnZSA9IEZpbmVUdW5pbmdKb2JzUGFnZTtcbkZpbmVUdW5pbmcuRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UgPSBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEZpbmVUdW5pbmcge1xuICBleHBvcnQge1xuICAgIEpvYnMgYXMgSm9icyxcbiAgICB0eXBlIEZpbmVUdW5pbmdKb2IgYXMgRmluZVR1bmluZ0pvYixcbiAgICB0eXBlIEZpbmVUdW5pbmdKb2JFdmVudCBhcyBGaW5lVHVuaW5nSm9iRXZlbnQsXG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iSW50ZWdyYXRpb24gYXMgRmluZVR1bmluZ0pvYkludGVncmF0aW9uLFxuICAgIHR5cGUgRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb24gYXMgRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb24sXG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbk9iamVjdCBhcyBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbk9iamVjdCxcbiAgICBGaW5lVHVuaW5nSm9ic1BhZ2UgYXMgRmluZVR1bmluZ0pvYnNQYWdlLFxuICAgIEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlIGFzIEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlLFxuICAgIHR5cGUgSm9iQ3JlYXRlUGFyYW1zIGFzIEpvYkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIEpvYkxpc3RQYXJhbXMgYXMgSm9iTGlzdFBhcmFtcyxcbiAgICB0eXBlIEpvYkxpc3RFdmVudHNQYXJhbXMgYXMgSm9iTGlzdEV2ZW50c1BhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vY29yZSc7XG5cbmV4cG9ydCBjbGFzcyBJbWFnZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdmFyaWF0aW9uIG9mIGEgZ2l2ZW4gaW1hZ2UuXG4gICAqL1xuICBjcmVhdGVWYXJpYXRpb24oXG4gICAgYm9keTogSW1hZ2VDcmVhdGVWYXJpYXRpb25QYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxJbWFnZXNSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2ltYWdlcy92YXJpYXRpb25zJywgQ29yZS5tdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGVkaXRlZCBvciBleHRlbmRlZCBpbWFnZSBnaXZlbiBhbiBvcmlnaW5hbCBpbWFnZSBhbmQgYSBwcm9tcHQuXG4gICAqL1xuICBlZGl0KGJvZHk6IEltYWdlRWRpdFBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8SW1hZ2VzUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9pbWFnZXMvZWRpdHMnLCBDb3JlLm11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyh7IGJvZHksIC4uLm9wdGlvbnMgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW1hZ2UgZ2l2ZW4gYSBwcm9tcHQuXG4gICAqL1xuICBnZW5lcmF0ZShib2R5OiBJbWFnZUdlbmVyYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxJbWFnZXNSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2ltYWdlcy9nZW5lcmF0aW9ucycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHVybCBvciB0aGUgY29udGVudCBvZiBhbiBpbWFnZSBnZW5lcmF0ZWQgYnkgdGhlIE9wZW5BSSBBUEkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2Uge1xuICAvKipcbiAgICogVGhlIGJhc2U2NC1lbmNvZGVkIEpTT04gb2YgdGhlIGdlbmVyYXRlZCBpbWFnZSwgaWYgYHJlc3BvbnNlX2Zvcm1hdGAgaXNcbiAgICogYGI2NF9qc29uYC5cbiAgICovXG4gIGI2NF9qc29uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcHJvbXB0IHRoYXQgd2FzIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGltYWdlLCBpZiB0aGVyZSB3YXMgYW55IHJldmlzaW9uIHRvIHRoZVxuICAgKiBwcm9tcHQuXG4gICAqL1xuICByZXZpc2VkX3Byb21wdD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVSTCBvZiB0aGUgZ2VuZXJhdGVkIGltYWdlLCBpZiBgcmVzcG9uc2VfZm9ybWF0YCBpcyBgdXJsYCAoZGVmYXVsdCkuXG4gICAqL1xuICB1cmw/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIEltYWdlTW9kZWwgPSAnZGFsbC1lLTInIHwgJ2RhbGwtZS0zJztcblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZXNSZXNwb25zZSB7XG4gIGNyZWF0ZWQ6IG51bWJlcjtcblxuICBkYXRhOiBBcnJheTxJbWFnZT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VDcmVhdGVWYXJpYXRpb25QYXJhbXMge1xuICAvKipcbiAgICogVGhlIGltYWdlIHRvIHVzZSBhcyB0aGUgYmFzaXMgZm9yIHRoZSB2YXJpYXRpb24ocykuIE11c3QgYmUgYSB2YWxpZCBQTkcgZmlsZSxcbiAgICogbGVzcyB0aGFuIDRNQiwgYW5kIHNxdWFyZS5cbiAgICovXG4gIGltYWdlOiBDb3JlLlVwbG9hZGFibGU7XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlbCB0byB1c2UgZm9yIGltYWdlIGdlbmVyYXRpb24uIE9ubHkgYGRhbGwtZS0yYCBpcyBzdXBwb3J0ZWQgYXQgdGhpc1xuICAgKiB0aW1lLlxuICAgKi9cbiAgbW9kZWw/OiAoc3RyaW5nICYge30pIHwgSW1hZ2VNb2RlbCB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgaW1hZ2VzIHRvIGdlbmVyYXRlLiBNdXN0IGJlIGJldHdlZW4gMSBhbmQgMTAuIEZvciBgZGFsbC1lLTNgLCBvbmx5XG4gICAqIGBuPTFgIGlzIHN1cHBvcnRlZC5cbiAgICovXG4gIG4/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IGluIHdoaWNoIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzIGFyZSByZXR1cm5lZC4gTXVzdCBiZSBvbmUgb2YgYHVybGAgb3JcbiAgICogYGI2NF9qc29uYC4gVVJMcyBhcmUgb25seSB2YWxpZCBmb3IgNjAgbWludXRlcyBhZnRlciB0aGUgaW1hZ2UgaGFzIGJlZW5cbiAgICogZ2VuZXJhdGVkLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogJ3VybCcgfCAnYjY0X2pzb24nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIGdlbmVyYXRlZCBpbWFnZXMuIE11c3QgYmUgb25lIG9mIGAyNTZ4MjU2YCwgYDUxMng1MTJgLCBvclxuICAgKiBgMTAyNHgxMDI0YC5cbiAgICovXG4gIHNpemU/OiAnMjU2eDI1NicgfCAnNTEyeDUxMicgfCAnMTAyNHgxMDI0JyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgcmVwcmVzZW50aW5nIHlvdXIgZW5kLXVzZXIsIHdoaWNoIGNhbiBoZWxwIE9wZW5BSSB0byBtb25pdG9yXG4gICAqIGFuZCBkZXRlY3QgYWJ1c2UuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc2FmZXR5LWJlc3QtcHJhY3RpY2VzI2VuZC11c2VyLWlkcykuXG4gICAqL1xuICB1c2VyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlRWRpdFBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgaW1hZ2UgdG8gZWRpdC4gTXVzdCBiZSBhIHZhbGlkIFBORyBmaWxlLCBsZXNzIHRoYW4gNE1CLCBhbmQgc3F1YXJlLiBJZiBtYXNrXG4gICAqIGlzIG5vdCBwcm92aWRlZCwgaW1hZ2UgbXVzdCBoYXZlIHRyYW5zcGFyZW5jeSwgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIHRoZSBtYXNrLlxuICAgKi9cbiAgaW1hZ2U6IENvcmUuVXBsb2FkYWJsZTtcblxuICAvKipcbiAgICogQSB0ZXh0IGRlc2NyaXB0aW9uIG9mIHRoZSBkZXNpcmVkIGltYWdlKHMpLiBUaGUgbWF4aW11bSBsZW5ndGggaXMgMTAwMFxuICAgKiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgcHJvbXB0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFuIGFkZGl0aW9uYWwgaW1hZ2Ugd2hvc2UgZnVsbHkgdHJhbnNwYXJlbnQgYXJlYXMgKGUuZy4gd2hlcmUgYWxwaGEgaXMgemVybylcbiAgICogaW5kaWNhdGUgd2hlcmUgYGltYWdlYCBzaG91bGQgYmUgZWRpdGVkLiBNdXN0IGJlIGEgdmFsaWQgUE5HIGZpbGUsIGxlc3MgdGhhblxuICAgKiA0TUIsIGFuZCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMgYXMgYGltYWdlYC5cbiAgICovXG4gIG1hc2s/OiBDb3JlLlVwbG9hZGFibGU7XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlbCB0byB1c2UgZm9yIGltYWdlIGdlbmVyYXRpb24uIE9ubHkgYGRhbGwtZS0yYCBpcyBzdXBwb3J0ZWQgYXQgdGhpc1xuICAgKiB0aW1lLlxuICAgKi9cbiAgbW9kZWw/OiAoc3RyaW5nICYge30pIHwgSW1hZ2VNb2RlbCB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgaW1hZ2VzIHRvIGdlbmVyYXRlLiBNdXN0IGJlIGJldHdlZW4gMSBhbmQgMTAuXG4gICAqL1xuICBuPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCBpbiB3aGljaCB0aGUgZ2VuZXJhdGVkIGltYWdlcyBhcmUgcmV0dXJuZWQuIE11c3QgYmUgb25lIG9mIGB1cmxgIG9yXG4gICAqIGBiNjRfanNvbmAuIFVSTHMgYXJlIG9ubHkgdmFsaWQgZm9yIDYwIG1pbnV0ZXMgYWZ0ZXIgdGhlIGltYWdlIGhhcyBiZWVuXG4gICAqIGdlbmVyYXRlZC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86ICd1cmwnIHwgJ2I2NF9qc29uJyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBNdXN0IGJlIG9uZSBvZiBgMjU2eDI1NmAsIGA1MTJ4NTEyYCwgb3JcbiAgICogYDEwMjR4MTAyNGAuXG4gICAqL1xuICBzaXplPzogJzI1NngyNTYnIHwgJzUxMng1MTInIHwgJzEwMjR4MTAyNCcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIHJlcHJlc2VudGluZyB5b3VyIGVuZC11c2VyLCB3aGljaCBjYW4gaGVscCBPcGVuQUkgdG8gbW9uaXRvclxuICAgKiBhbmQgZGV0ZWN0IGFidXNlLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3NhZmV0eS1iZXN0LXByYWN0aWNlcyNlbmQtdXNlci1pZHMpLlxuICAgKi9cbiAgdXNlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZUdlbmVyYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgZGVzaXJlZCBpbWFnZShzKS4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDEwMDBcbiAgICogY2hhcmFjdGVycyBmb3IgYGRhbGwtZS0yYCBhbmQgNDAwMCBjaGFyYWN0ZXJzIGZvciBgZGFsbC1lLTNgLlxuICAgKi9cbiAgcHJvbXB0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlbCB0byB1c2UgZm9yIGltYWdlIGdlbmVyYXRpb24uXG4gICAqL1xuICBtb2RlbD86IChzdHJpbmcgJiB7fSkgfCBJbWFnZU1vZGVsIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBpbWFnZXMgdG8gZ2VuZXJhdGUuIE11c3QgYmUgYmV0d2VlbiAxIGFuZCAxMC4gRm9yIGBkYWxsLWUtM2AsIG9ubHlcbiAgICogYG49MWAgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgbj86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBxdWFsaXR5IG9mIHRoZSBpbWFnZSB0aGF0IHdpbGwgYmUgZ2VuZXJhdGVkLiBgaGRgIGNyZWF0ZXMgaW1hZ2VzIHdpdGggZmluZXJcbiAgICogZGV0YWlscyBhbmQgZ3JlYXRlciBjb25zaXN0ZW5jeSBhY3Jvc3MgdGhlIGltYWdlLiBUaGlzIHBhcmFtIGlzIG9ubHkgc3VwcG9ydGVkXG4gICAqIGZvciBgZGFsbC1lLTNgLlxuICAgKi9cbiAgcXVhbGl0eT86ICdzdGFuZGFyZCcgfCAnaGQnO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IGluIHdoaWNoIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzIGFyZSByZXR1cm5lZC4gTXVzdCBiZSBvbmUgb2YgYHVybGAgb3JcbiAgICogYGI2NF9qc29uYC4gVVJMcyBhcmUgb25seSB2YWxpZCBmb3IgNjAgbWludXRlcyBhZnRlciB0aGUgaW1hZ2UgaGFzIGJlZW5cbiAgICogZ2VuZXJhdGVkLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogJ3VybCcgfCAnYjY0X2pzb24nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIGdlbmVyYXRlZCBpbWFnZXMuIE11c3QgYmUgb25lIG9mIGAyNTZ4MjU2YCwgYDUxMng1MTJgLCBvclxuICAgKiBgMTAyNHgxMDI0YCBmb3IgYGRhbGwtZS0yYC4gTXVzdCBiZSBvbmUgb2YgYDEwMjR4MTAyNGAsIGAxNzkyeDEwMjRgLCBvclxuICAgKiBgMTAyNHgxNzkyYCBmb3IgYGRhbGwtZS0zYCBtb2RlbHMuXG4gICAqL1xuICBzaXplPzogJzI1NngyNTYnIHwgJzUxMng1MTInIHwgJzEwMjR4MTAyNCcgfCAnMTc5MngxMDI0JyB8ICcxMDI0eDE3OTInIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHN0eWxlIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBNdXN0IGJlIG9uZSBvZiBgdml2aWRgIG9yIGBuYXR1cmFsYC4gVml2aWRcbiAgICogY2F1c2VzIHRoZSBtb2RlbCB0byBsZWFuIHRvd2FyZHMgZ2VuZXJhdGluZyBoeXBlci1yZWFsIGFuZCBkcmFtYXRpYyBpbWFnZXMuXG4gICAqIE5hdHVyYWwgY2F1c2VzIHRoZSBtb2RlbCB0byBwcm9kdWNlIG1vcmUgbmF0dXJhbCwgbGVzcyBoeXBlci1yZWFsIGxvb2tpbmdcbiAgICogaW1hZ2VzLiBUaGlzIHBhcmFtIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBgZGFsbC1lLTNgLlxuICAgKi9cbiAgc3R5bGU/OiAndml2aWQnIHwgJ25hdHVyYWwnIHwgbnVsbDtcblxuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciByZXByZXNlbnRpbmcgeW91ciBlbmQtdXNlciwgd2hpY2ggY2FuIGhlbHAgT3BlbkFJIHRvIG1vbml0b3JcbiAgICogYW5kIGRldGVjdCBhYnVzZS5cbiAgICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zYWZldHktYmVzdC1wcmFjdGljZXMjZW5kLXVzZXItaWRzKS5cbiAgICovXG4gIHVzZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBJbWFnZXMge1xuICBleHBvcnQge1xuICAgIHR5cGUgSW1hZ2UgYXMgSW1hZ2UsXG4gICAgdHlwZSBJbWFnZU1vZGVsIGFzIEltYWdlTW9kZWwsXG4gICAgdHlwZSBJbWFnZXNSZXNwb25zZSBhcyBJbWFnZXNSZXNwb25zZSxcbiAgICB0eXBlIEltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zIGFzIEltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zLFxuICAgIHR5cGUgSW1hZ2VFZGl0UGFyYW1zIGFzIEltYWdlRWRpdFBhcmFtcyxcbiAgICB0eXBlIEltYWdlR2VuZXJhdGVQYXJhbXMgYXMgSW1hZ2VHZW5lcmF0ZVBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSAnLi4vcGFnaW5hdGlvbic7XG5cbmV4cG9ydCBjbGFzcyBNb2RlbHMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBtb2RlbCBpbnN0YW5jZSwgcHJvdmlkaW5nIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IHRoZSBtb2RlbCBzdWNoIGFzXG4gICAqIHRoZSBvd25lciBhbmQgcGVybWlzc2lvbmluZy5cbiAgICovXG4gIHJldHJpZXZlKG1vZGVsOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPE1vZGVsPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC9tb2RlbHMvJHttb2RlbH1gLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0cyB0aGUgY3VycmVudGx5IGF2YWlsYWJsZSBtb2RlbHMsIGFuZCBwcm92aWRlcyBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCBlYWNoXG4gICAqIG9uZSBzdWNoIGFzIHRoZSBvd25lciBhbmQgYXZhaWxhYmlsaXR5LlxuICAgKi9cbiAgbGlzdChvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuUGFnZVByb21pc2U8TW9kZWxzUGFnZSwgTW9kZWw+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy9tb2RlbHMnLCBNb2RlbHNQYWdlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBmaW5lLXR1bmVkIG1vZGVsLiBZb3UgbXVzdCBoYXZlIHRoZSBPd25lciByb2xlIGluIHlvdXIgb3JnYW5pemF0aW9uIHRvXG4gICAqIGRlbGV0ZSBhIG1vZGVsLlxuICAgKi9cbiAgZGVsKG1vZGVsOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPE1vZGVsRGVsZXRlZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZGVsZXRlKGAvbW9kZWxzLyR7bW9kZWx9YCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3RlOiBubyBwYWdpbmF0aW9uIGFjdHVhbGx5IG9jY3VycyB5ZXQsIHRoaXMgaXMgZm9yIGZvcndhcmRzLWNvbXBhdGliaWxpdHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2RlbHNQYWdlIGV4dGVuZHMgUGFnZTxNb2RlbD4ge31cblxuLyoqXG4gKiBEZXNjcmliZXMgYW4gT3BlbkFJIG1vZGVsIG9mZmVyaW5nIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgQVBJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVsIHtcbiAgLyoqXG4gICAqIFRoZSBtb2RlbCBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgd2hlbiB0aGUgbW9kZWwgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwibW9kZWxcIi5cbiAgICovXG4gIG9iamVjdDogJ21vZGVsJztcblxuICAvKipcbiAgICogVGhlIG9yZ2FuaXphdGlvbiB0aGF0IG93bnMgdGhlIG1vZGVsLlxuICAgKi9cbiAgb3duZWRfYnk6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb2RlbERlbGV0ZWQge1xuICBpZDogc3RyaW5nO1xuXG4gIGRlbGV0ZWQ6IGJvb2xlYW47XG5cbiAgb2JqZWN0OiBzdHJpbmc7XG59XG5cbk1vZGVscy5Nb2RlbHNQYWdlID0gTW9kZWxzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIE1vZGVscyB7XG4gIGV4cG9ydCB7IHR5cGUgTW9kZWwgYXMgTW9kZWwsIHR5cGUgTW9kZWxEZWxldGVkIGFzIE1vZGVsRGVsZXRlZCwgTW9kZWxzUGFnZSBhcyBNb2RlbHNQYWdlIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uL2NvcmUnO1xuXG5leHBvcnQgY2xhc3MgTW9kZXJhdGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDbGFzc2lmaWVzIGlmIHRleHQgYW5kL29yIGltYWdlIGlucHV0cyBhcmUgcG90ZW50aWFsbHkgaGFybWZ1bC4gTGVhcm4gbW9yZSBpblxuICAgKiB0aGUgW21vZGVyYXRpb24gZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9tb2RlcmF0aW9uKS5cbiAgICovXG4gIGNyZWF0ZShcbiAgICBib2R5OiBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8TW9kZXJhdGlvbkNyZWF0ZVJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvbW9kZXJhdGlvbnMnLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb2RlcmF0aW9uIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0aGUgY2F0ZWdvcmllcywgYW5kIHdoZXRoZXIgdGhleSBhcmUgZmxhZ2dlZCBvciBub3QuXG4gICAqL1xuICBjYXRlZ29yaWVzOiBNb2RlcmF0aW9uLkNhdGVnb3JpZXM7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0aGUgY2F0ZWdvcmllcyBhbG9uZyB3aXRoIHRoZSBpbnB1dCB0eXBlKHMpIHRoYXQgdGhlIHNjb3JlIGFwcGxpZXMgdG8uXG4gICAqL1xuICBjYXRlZ29yeV9hcHBsaWVkX2lucHV0X3R5cGVzOiBNb2RlcmF0aW9uLkNhdGVnb3J5QXBwbGllZElucHV0VHlwZXM7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0aGUgY2F0ZWdvcmllcyBhbG9uZyB3aXRoIHRoZWlyIHNjb3JlcyBhcyBwcmVkaWN0ZWQgYnkgbW9kZWwuXG4gICAqL1xuICBjYXRlZ29yeV9zY29yZXM6IE1vZGVyYXRpb24uQ2F0ZWdvcnlTY29yZXM7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgYW55IG9mIHRoZSBiZWxvdyBjYXRlZ29yaWVzIGFyZSBmbGFnZ2VkLlxuICAgKi9cbiAgZmxhZ2dlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBNb2RlcmF0aW9uIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0aGUgY2F0ZWdvcmllcywgYW5kIHdoZXRoZXIgdGhleSBhcmUgZmxhZ2dlZCBvciBub3QuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIENhdGVnb3JpZXMge1xuICAgIC8qKlxuICAgICAqIENvbnRlbnQgdGhhdCBleHByZXNzZXMsIGluY2l0ZXMsIG9yIHByb21vdGVzIGhhcmFzc2luZyBsYW5ndWFnZSB0b3dhcmRzIGFueVxuICAgICAqIHRhcmdldC5cbiAgICAgKi9cbiAgICBoYXJhc3NtZW50OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogSGFyYXNzbWVudCBjb250ZW50IHRoYXQgYWxzbyBpbmNsdWRlcyB2aW9sZW5jZSBvciBzZXJpb3VzIGhhcm0gdG93YXJkcyBhbnlcbiAgICAgKiB0YXJnZXQuXG4gICAgICovXG4gICAgJ2hhcmFzc21lbnQvdGhyZWF0ZW5pbmcnOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB0aGF0IGV4cHJlc3NlcywgaW5jaXRlcywgb3IgcHJvbW90ZXMgaGF0ZSBiYXNlZCBvbiByYWNlLCBnZW5kZXIsXG4gICAgICogZXRobmljaXR5LCByZWxpZ2lvbiwgbmF0aW9uYWxpdHksIHNleHVhbCBvcmllbnRhdGlvbiwgZGlzYWJpbGl0eSBzdGF0dXMsIG9yXG4gICAgICogY2FzdGUuIEhhdGVmdWwgY29udGVudCBhaW1lZCBhdCBub24tcHJvdGVjdGVkIGdyb3VwcyAoZS5nLiwgY2hlc3MgcGxheWVycykgaXNcbiAgICAgKiBoYXJhc3NtZW50LlxuICAgICAqL1xuICAgIGhhdGU6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBIYXRlZnVsIGNvbnRlbnQgdGhhdCBhbHNvIGluY2x1ZGVzIHZpb2xlbmNlIG9yIHNlcmlvdXMgaGFybSB0b3dhcmRzIHRoZSB0YXJnZXRlZFxuICAgICAqIGdyb3VwIGJhc2VkIG9uIHJhY2UsIGdlbmRlciwgZXRobmljaXR5LCByZWxpZ2lvbiwgbmF0aW9uYWxpdHksIHNleHVhbFxuICAgICAqIG9yaWVudGF0aW9uLCBkaXNhYmlsaXR5IHN0YXR1cywgb3IgY2FzdGUuXG4gICAgICovXG4gICAgJ2hhdGUvdGhyZWF0ZW5pbmcnOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB0aGF0IGluY2x1ZGVzIGluc3RydWN0aW9ucyBvciBhZHZpY2UgdGhhdCBmYWNpbGl0YXRlIHRoZSBwbGFubmluZyBvclxuICAgICAqIGV4ZWN1dGlvbiBvZiB3cm9uZ2RvaW5nLCBvciB0aGF0IGdpdmVzIGFkdmljZSBvciBpbnN0cnVjdGlvbiBvbiBob3cgdG8gY29tbWl0XG4gICAgICogaWxsaWNpdCBhY3RzLiBGb3IgZXhhbXBsZSwgXCJob3cgdG8gc2hvcGxpZnRcIiB3b3VsZCBmaXQgdGhpcyBjYXRlZ29yeS5cbiAgICAgKi9cbiAgICBpbGxpY2l0OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB0aGF0IGluY2x1ZGVzIGluc3RydWN0aW9ucyBvciBhZHZpY2UgdGhhdCBmYWNpbGl0YXRlIHRoZSBwbGFubmluZyBvclxuICAgICAqIGV4ZWN1dGlvbiBvZiB3cm9uZ2RvaW5nIHRoYXQgYWxzbyBpbmNsdWRlcyB2aW9sZW5jZSwgb3IgdGhhdCBnaXZlcyBhZHZpY2Ugb3JcbiAgICAgKiBpbnN0cnVjdGlvbiBvbiB0aGUgcHJvY3VyZW1lbnQgb2YgYW55IHdlYXBvbi5cbiAgICAgKi9cbiAgICAnaWxsaWNpdC92aW9sZW50JzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgdGhhdCBwcm9tb3RlcywgZW5jb3VyYWdlcywgb3IgZGVwaWN0cyBhY3RzIG9mIHNlbGYtaGFybSwgc3VjaCBhc1xuICAgICAqIHN1aWNpZGUsIGN1dHRpbmcsIGFuZCBlYXRpbmcgZGlzb3JkZXJzLlxuICAgICAqL1xuICAgICdzZWxmLWhhcm0nOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB0aGF0IGVuY291cmFnZXMgcGVyZm9ybWluZyBhY3RzIG9mIHNlbGYtaGFybSwgc3VjaCBhcyBzdWljaWRlLCBjdXR0aW5nLFxuICAgICAqIGFuZCBlYXRpbmcgZGlzb3JkZXJzLCBvciB0aGF0IGdpdmVzIGluc3RydWN0aW9ucyBvciBhZHZpY2Ugb24gaG93IHRvIGNvbW1pdCBzdWNoXG4gICAgICogYWN0cy5cbiAgICAgKi9cbiAgICAnc2VsZi1oYXJtL2luc3RydWN0aW9ucyc6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IHdoZXJlIHRoZSBzcGVha2VyIGV4cHJlc3NlcyB0aGF0IHRoZXkgYXJlIGVuZ2FnaW5nIG9yIGludGVuZCB0byBlbmdhZ2VcbiAgICAgKiBpbiBhY3RzIG9mIHNlbGYtaGFybSwgc3VjaCBhcyBzdWljaWRlLCBjdXR0aW5nLCBhbmQgZWF0aW5nIGRpc29yZGVycy5cbiAgICAgKi9cbiAgICAnc2VsZi1oYXJtL2ludGVudCc6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IG1lYW50IHRvIGFyb3VzZSBzZXh1YWwgZXhjaXRlbWVudCwgc3VjaCBhcyB0aGUgZGVzY3JpcHRpb24gb2Ygc2V4dWFsXG4gICAgICogYWN0aXZpdHksIG9yIHRoYXQgcHJvbW90ZXMgc2V4dWFsIHNlcnZpY2VzIChleGNsdWRpbmcgc2V4IGVkdWNhdGlvbiBhbmRcbiAgICAgKiB3ZWxsbmVzcykuXG4gICAgICovXG4gICAgc2V4dWFsOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogU2V4dWFsIGNvbnRlbnQgdGhhdCBpbmNsdWRlcyBhbiBpbmRpdmlkdWFsIHdobyBpcyB1bmRlciAxOCB5ZWFycyBvbGQuXG4gICAgICovXG4gICAgJ3NleHVhbC9taW5vcnMnOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB0aGF0IGRlcGljdHMgZGVhdGgsIHZpb2xlbmNlLCBvciBwaHlzaWNhbCBpbmp1cnkuXG4gICAgICovXG4gICAgdmlvbGVuY2U6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IHRoYXQgZGVwaWN0cyBkZWF0aCwgdmlvbGVuY2UsIG9yIHBoeXNpY2FsIGluanVyeSBpbiBncmFwaGljIGRldGFpbC5cbiAgICAgKi9cbiAgICAndmlvbGVuY2UvZ3JhcGhpYyc6IGJvb2xlYW47XG4gIH1cblxuICAvKipcbiAgICogQSBsaXN0IG9mIHRoZSBjYXRlZ29yaWVzIGFsb25nIHdpdGggdGhlIGlucHV0IHR5cGUocykgdGhhdCB0aGUgc2NvcmUgYXBwbGllcyB0by5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ2F0ZWdvcnlBcHBsaWVkSW5wdXRUeXBlcyB7XG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICdoYXJhc3NtZW50Jy5cbiAgICAgKi9cbiAgICBoYXJhc3NtZW50OiBBcnJheTwndGV4dCc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICdoYXJhc3NtZW50L3RocmVhdGVuaW5nJy5cbiAgICAgKi9cbiAgICAnaGFyYXNzbWVudC90aHJlYXRlbmluZyc6IEFycmF5PCd0ZXh0Jz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ2hhdGUnLlxuICAgICAqL1xuICAgIGhhdGU6IEFycmF5PCd0ZXh0Jz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ2hhdGUvdGhyZWF0ZW5pbmcnLlxuICAgICAqL1xuICAgICdoYXRlL3RocmVhdGVuaW5nJzogQXJyYXk8J3RleHQnPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAnaWxsaWNpdCcuXG4gICAgICovXG4gICAgaWxsaWNpdDogQXJyYXk8J3RleHQnPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAnaWxsaWNpdC92aW9sZW50Jy5cbiAgICAgKi9cbiAgICAnaWxsaWNpdC92aW9sZW50JzogQXJyYXk8J3RleHQnPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAnc2VsZi1oYXJtJy5cbiAgICAgKi9cbiAgICAnc2VsZi1oYXJtJzogQXJyYXk8J3RleHQnIHwgJ2ltYWdlJz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ3NlbGYtaGFybS9pbnN0cnVjdGlvbnMnLlxuICAgICAqL1xuICAgICdzZWxmLWhhcm0vaW5zdHJ1Y3Rpb25zJzogQXJyYXk8J3RleHQnIHwgJ2ltYWdlJz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ3NlbGYtaGFybS9pbnRlbnQnLlxuICAgICAqL1xuICAgICdzZWxmLWhhcm0vaW50ZW50JzogQXJyYXk8J3RleHQnIHwgJ2ltYWdlJz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ3NleHVhbCcuXG4gICAgICovXG4gICAgc2V4dWFsOiBBcnJheTwndGV4dCcgfCAnaW1hZ2UnPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAnc2V4dWFsL21pbm9ycycuXG4gICAgICovXG4gICAgJ3NleHVhbC9taW5vcnMnOiBBcnJheTwndGV4dCc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICd2aW9sZW5jZScuXG4gICAgICovXG4gICAgdmlvbGVuY2U6IEFycmF5PCd0ZXh0JyB8ICdpbWFnZSc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICd2aW9sZW5jZS9ncmFwaGljJy5cbiAgICAgKi9cbiAgICAndmlvbGVuY2UvZ3JhcGhpYyc6IEFycmF5PCd0ZXh0JyB8ICdpbWFnZSc+O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0aGUgY2F0ZWdvcmllcyBhbG9uZyB3aXRoIHRoZWlyIHNjb3JlcyBhcyBwcmVkaWN0ZWQgYnkgbW9kZWwuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIENhdGVnb3J5U2NvcmVzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnaGFyYXNzbWVudCcuXG4gICAgICovXG4gICAgaGFyYXNzbWVudDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ2hhcmFzc21lbnQvdGhyZWF0ZW5pbmcnLlxuICAgICAqL1xuICAgICdoYXJhc3NtZW50L3RocmVhdGVuaW5nJzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ2hhdGUnLlxuICAgICAqL1xuICAgIGhhdGU6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdoYXRlL3RocmVhdGVuaW5nJy5cbiAgICAgKi9cbiAgICAnaGF0ZS90aHJlYXRlbmluZyc6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdpbGxpY2l0Jy5cbiAgICAgKi9cbiAgICBpbGxpY2l0OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnaWxsaWNpdC92aW9sZW50Jy5cbiAgICAgKi9cbiAgICAnaWxsaWNpdC92aW9sZW50JzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ3NlbGYtaGFybScuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybSc6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdzZWxmLWhhcm0vaW5zdHJ1Y3Rpb25zJy5cbiAgICAgKi9cbiAgICAnc2VsZi1oYXJtL2luc3RydWN0aW9ucyc6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdzZWxmLWhhcm0vaW50ZW50Jy5cbiAgICAgKi9cbiAgICAnc2VsZi1oYXJtL2ludGVudCc6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdzZXh1YWwnLlxuICAgICAqL1xuICAgIHNleHVhbDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ3NleHVhbC9taW5vcnMnLlxuICAgICAqL1xuICAgICdzZXh1YWwvbWlub3JzJzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ3Zpb2xlbmNlJy5cbiAgICAgKi9cbiAgICB2aW9sZW5jZTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ3Zpb2xlbmNlL2dyYXBoaWMnLlxuICAgICAqL1xuICAgICd2aW9sZW5jZS9ncmFwaGljJzogbnVtYmVyO1xuICB9XG59XG5cbi8qKlxuICogQW4gb2JqZWN0IGRlc2NyaWJpbmcgYW4gaW1hZ2UgdG8gY2xhc3NpZnkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZXJhdGlvbkltYWdlVVJMSW5wdXQge1xuICAvKipcbiAgICogQ29udGFpbnMgZWl0aGVyIGFuIGltYWdlIFVSTCBvciBhIGRhdGEgVVJMIGZvciBhIGJhc2U2NCBlbmNvZGVkIGltYWdlLlxuICAgKi9cbiAgaW1hZ2VfdXJsOiBNb2RlcmF0aW9uSW1hZ2VVUkxJbnB1dC5JbWFnZVVSTDtcblxuICAvKipcbiAgICogQWx3YXlzIGBpbWFnZV91cmxgLlxuICAgKi9cbiAgdHlwZTogJ2ltYWdlX3VybCc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgTW9kZXJhdGlvbkltYWdlVVJMSW5wdXQge1xuICAvKipcbiAgICogQ29udGFpbnMgZWl0aGVyIGFuIGltYWdlIFVSTCBvciBhIGRhdGEgVVJMIGZvciBhIGJhc2U2NCBlbmNvZGVkIGltYWdlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBJbWFnZVVSTCB7XG4gICAgLyoqXG4gICAgICogRWl0aGVyIGEgVVJMIG9mIHRoZSBpbWFnZSBvciB0aGUgYmFzZTY0IGVuY29kZWQgaW1hZ2UgZGF0YS5cbiAgICAgKi9cbiAgICB1cmw6IHN0cmluZztcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBNb2RlcmF0aW9uTW9kZWwgPVxuICB8ICdvbW5pLW1vZGVyYXRpb24tbGF0ZXN0J1xuICB8ICdvbW5pLW1vZGVyYXRpb24tMjAyNC0wOS0yNidcbiAgfCAndGV4dC1tb2RlcmF0aW9uLWxhdGVzdCdcbiAgfCAndGV4dC1tb2RlcmF0aW9uLXN0YWJsZSc7XG5cbi8qKlxuICogQW4gb2JqZWN0IGRlc2NyaWJpbmcgYW4gaW1hZ2UgdG8gY2xhc3NpZnkuXG4gKi9cbmV4cG9ydCB0eXBlIE1vZGVyYXRpb25NdWx0aU1vZGFsSW5wdXQgPSBNb2RlcmF0aW9uSW1hZ2VVUkxJbnB1dCB8IE1vZGVyYXRpb25UZXh0SW5wdXQ7XG5cbi8qKlxuICogQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGV4dCB0byBjbGFzc2lmeS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNb2RlcmF0aW9uVGV4dElucHV0IHtcbiAgLyoqXG4gICAqIEEgc3RyaW5nIG9mIHRleHQgdG8gY2xhc3NpZnkuXG4gICAqL1xuICB0ZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgdGV4dGAuXG4gICAqL1xuICB0eXBlOiAndGV4dCc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBpZiBhIGdpdmVuIHRleHQgaW5wdXQgaXMgcG90ZW50aWFsbHkgaGFybWZ1bC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNb2RlcmF0aW9uQ3JlYXRlUmVzcG9uc2Uge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgbW9kZXJhdGlvbiByZXF1ZXN0LlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIG1vZGVyYXRpb24gcmVzdWx0cy5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBtb2RlcmF0aW9uIG9iamVjdHMuXG4gICAqL1xuICByZXN1bHRzOiBBcnJheTxNb2RlcmF0aW9uPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIElucHV0IChvciBpbnB1dHMpIHRvIGNsYXNzaWZ5LiBDYW4gYmUgYSBzaW5nbGUgc3RyaW5nLCBhbiBhcnJheSBvZiBzdHJpbmdzLCBvclxuICAgKiBhbiBhcnJheSBvZiBtdWx0aS1tb2RhbCBpbnB1dCBvYmplY3RzIHNpbWlsYXIgdG8gb3RoZXIgbW9kZWxzLlxuICAgKi9cbiAgaW5wdXQ6IHN0cmluZyB8IEFycmF5PHN0cmluZz4gfCBBcnJheTxNb2RlcmF0aW9uTXVsdGlNb2RhbElucHV0PjtcblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgbW9kZXJhdGlvbiBtb2RlbCB5b3Ugd291bGQgbGlrZSB0byB1c2UuIExlYXJuIG1vcmUgaW5cbiAgICogW3RoZSBtb2RlcmF0aW9uIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvbW9kZXJhdGlvbiksIGFuZFxuICAgKiBsZWFybiBhYm91dCBhdmFpbGFibGUgbW9kZWxzXG4gICAqIFtoZXJlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjbW9kZXJhdGlvbikuXG4gICAqL1xuICBtb2RlbD86IChzdHJpbmcgJiB7fSkgfCBNb2RlcmF0aW9uTW9kZWw7XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBNb2RlcmF0aW9ucyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBNb2RlcmF0aW9uIGFzIE1vZGVyYXRpb24sXG4gICAgdHlwZSBNb2RlcmF0aW9uSW1hZ2VVUkxJbnB1dCBhcyBNb2RlcmF0aW9uSW1hZ2VVUkxJbnB1dCxcbiAgICB0eXBlIE1vZGVyYXRpb25Nb2RlbCBhcyBNb2RlcmF0aW9uTW9kZWwsXG4gICAgdHlwZSBNb2RlcmF0aW9uTXVsdGlNb2RhbElucHV0IGFzIE1vZGVyYXRpb25NdWx0aU1vZGFsSW5wdXQsXG4gICAgdHlwZSBNb2RlcmF0aW9uVGV4dElucHV0IGFzIE1vZGVyYXRpb25UZXh0SW5wdXQsXG4gICAgdHlwZSBNb2RlcmF0aW9uQ3JlYXRlUmVzcG9uc2UgYXMgTW9kZXJhdGlvbkNyZWF0ZVJlc3BvbnNlLFxuICAgIHR5cGUgTW9kZXJhdGlvbkNyZWF0ZVBhcmFtcyBhcyBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi9jb3JlJztcblxuZXhwb3J0IGNsYXNzIFBhcnRzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQWRkcyBhXG4gICAqIFtQYXJ0XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3VwbG9hZHMvcGFydC1vYmplY3QpIHRvIGFuXG4gICAqIFtVcGxvYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdXBsb2Fkcy9vYmplY3QpIG9iamVjdC5cbiAgICogQSBQYXJ0IHJlcHJlc2VudHMgYSBjaHVuayBvZiBieXRlcyBmcm9tIHRoZSBmaWxlIHlvdSBhcmUgdHJ5aW5nIHRvIHVwbG9hZC5cbiAgICpcbiAgICogRWFjaCBQYXJ0IGNhbiBiZSBhdCBtb3N0IDY0IE1CLCBhbmQgeW91IGNhbiBhZGQgUGFydHMgdW50aWwgeW91IGhpdCB0aGUgVXBsb2FkXG4gICAqIG1heGltdW0gb2YgOCBHQi5cbiAgICpcbiAgICogSXQgaXMgcG9zc2libGUgdG8gYWRkIG11bHRpcGxlIFBhcnRzIGluIHBhcmFsbGVsLiBZb3UgY2FuIGRlY2lkZSB0aGUgaW50ZW5kZWRcbiAgICogb3JkZXIgb2YgdGhlIFBhcnRzIHdoZW4geW91XG4gICAqIFtjb21wbGV0ZSB0aGUgVXBsb2FkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3VwbG9hZHMvY29tcGxldGUpLlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIHVwbG9hZElkOiBzdHJpbmcsXG4gICAgYm9keTogUGFydENyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFVwbG9hZFBhcnQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoXG4gICAgICBgL3VwbG9hZHMvJHt1cGxvYWRJZH0vcGFydHNgLFxuICAgICAgQ29yZS5tdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pLFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgdXBsb2FkIFBhcnQgcmVwcmVzZW50cyBhIGNodW5rIG9mIGJ5dGVzIHdlIGNhbiBhZGQgdG8gYW4gVXBsb2FkIG9iamVjdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGxvYWRQYXJ0IHtcbiAgLyoqXG4gICAqIFRoZSB1cGxvYWQgUGFydCB1bmlxdWUgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIFBhcnQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGB1cGxvYWQucGFydGAuXG4gICAqL1xuICBvYmplY3Q6ICd1cGxvYWQucGFydCc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgVXBsb2FkIG9iamVjdCB0aGF0IHRoaXMgUGFydCB3YXMgYWRkZWQgdG8uXG4gICAqL1xuICB1cGxvYWRfaWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJ0Q3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBjaHVuayBvZiBieXRlcyBmb3IgdGhpcyBQYXJ0LlxuICAgKi9cbiAgZGF0YTogQ29yZS5VcGxvYWRhYmxlO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgUGFydHMge1xuICBleHBvcnQgeyB0eXBlIFVwbG9hZFBhcnQgYXMgVXBsb2FkUGFydCwgdHlwZSBQYXJ0Q3JlYXRlUGFyYW1zIGFzIFBhcnRDcmVhdGVQYXJhbXMgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBGaWxlc0FQSSBmcm9tICcuLi9maWxlcyc7XG5pbXBvcnQgKiBhcyBQYXJ0c0FQSSBmcm9tICcuL3BhcnRzJztcbmltcG9ydCB7IFBhcnRDcmVhdGVQYXJhbXMsIFBhcnRzLCBVcGxvYWRQYXJ0IH0gZnJvbSAnLi9wYXJ0cyc7XG5cbmV4cG9ydCBjbGFzcyBVcGxvYWRzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICBwYXJ0czogUGFydHNBUEkuUGFydHMgPSBuZXcgUGFydHNBUEkuUGFydHModGhpcy5fY2xpZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnRlcm1lZGlhdGVcbiAgICogW1VwbG9hZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS91cGxvYWRzL29iamVjdCkgb2JqZWN0XG4gICAqIHRoYXQgeW91IGNhbiBhZGRcbiAgICogW1BhcnRzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3VwbG9hZHMvcGFydC1vYmplY3QpIHRvLlxuICAgKiBDdXJyZW50bHksIGFuIFVwbG9hZCBjYW4gYWNjZXB0IGF0IG1vc3QgOCBHQiBpbiB0b3RhbCBhbmQgZXhwaXJlcyBhZnRlciBhbiBob3VyXG4gICAqIGFmdGVyIHlvdSBjcmVhdGUgaXQuXG4gICAqXG4gICAqIE9uY2UgeW91IGNvbXBsZXRlIHRoZSBVcGxvYWQsIHdlIHdpbGwgY3JlYXRlIGFcbiAgICogW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMvb2JqZWN0KSBvYmplY3QgdGhhdFxuICAgKiBjb250YWlucyBhbGwgdGhlIHBhcnRzIHlvdSB1cGxvYWRlZC4gVGhpcyBGaWxlIGlzIHVzYWJsZSBpbiB0aGUgcmVzdCBvZiBvdXJcbiAgICogcGxhdGZvcm0gYXMgYSByZWd1bGFyIEZpbGUgb2JqZWN0LlxuICAgKlxuICAgKiBGb3IgY2VydGFpbiBgcHVycG9zZWBzLCB0aGUgY29ycmVjdCBgbWltZV90eXBlYCBtdXN0IGJlIHNwZWNpZmllZC4gUGxlYXNlIHJlZmVyXG4gICAqIHRvIGRvY3VtZW50YXRpb24gZm9yIHRoZSBzdXBwb3J0ZWQgTUlNRSB0eXBlcyBmb3IgeW91ciB1c2UgY2FzZTpcbiAgICpcbiAgICogLSBbQXNzaXN0YW50c10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy90b29scy9maWxlLXNlYXJjaCNzdXBwb3J0ZWQtZmlsZXMpXG4gICAqXG4gICAqIEZvciBndWlkYW5jZSBvbiB0aGUgcHJvcGVyIGZpbGVuYW1lIGV4dGVuc2lvbnMgZm9yIGVhY2ggcHVycG9zZSwgcGxlYXNlIGZvbGxvd1xuICAgKiB0aGUgZG9jdW1lbnRhdGlvbiBvblxuICAgKiBbY3JlYXRpbmcgYSBGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL2NyZWF0ZSkuXG4gICAqL1xuICBjcmVhdGUoYm9keTogVXBsb2FkQ3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxVcGxvYWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy91cGxvYWRzJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgdGhlIFVwbG9hZC4gTm8gUGFydHMgbWF5IGJlIGFkZGVkIGFmdGVyIGFuIFVwbG9hZCBpcyBjYW5jZWxsZWQuXG4gICAqL1xuICBjYW5jZWwodXBsb2FkSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8VXBsb2FkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdXBsb2Fkcy8ke3VwbG9hZElkfS9jYW5jZWxgLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZXMgdGhlXG4gICAqIFtVcGxvYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdXBsb2Fkcy9vYmplY3QpLlxuICAgKlxuICAgKiBXaXRoaW4gdGhlIHJldHVybmVkIFVwbG9hZCBvYmplY3QsIHRoZXJlIGlzIGEgbmVzdGVkXG4gICAqIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL29iamVjdCkgb2JqZWN0IHRoYXRcbiAgICogaXMgcmVhZHkgdG8gdXNlIGluIHRoZSByZXN0IG9mIHRoZSBwbGF0Zm9ybS5cbiAgICpcbiAgICogWW91IGNhbiBzcGVjaWZ5IHRoZSBvcmRlciBvZiB0aGUgUGFydHMgYnkgcGFzc2luZyBpbiBhbiBvcmRlcmVkIGxpc3Qgb2YgdGhlIFBhcnRcbiAgICogSURzLlxuICAgKlxuICAgKiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHVwbG9hZGVkIHVwb24gY29tcGxldGlvbiBtdXN0IG1hdGNoIHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgICogaW5pdGlhbGx5IHNwZWNpZmllZCB3aGVuIGNyZWF0aW5nIHRoZSBVcGxvYWQgb2JqZWN0LiBObyBQYXJ0cyBtYXkgYmUgYWRkZWQgYWZ0ZXJcbiAgICogYW4gVXBsb2FkIGlzIGNvbXBsZXRlZC5cbiAgICovXG4gIGNvbXBsZXRlKFxuICAgIHVwbG9hZElkOiBzdHJpbmcsXG4gICAgYm9keTogVXBsb2FkQ29tcGxldGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxVcGxvYWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC91cGxvYWRzLyR7dXBsb2FkSWR9L2NvbXBsZXRlYCwgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICB9XG59XG5cbi8qKlxuICogVGhlIFVwbG9hZCBvYmplY3QgY2FuIGFjY2VwdCBieXRlIGNodW5rcyBpbiB0aGUgZm9ybSBvZiBQYXJ0cy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGxvYWQge1xuICAvKipcbiAgICogVGhlIFVwbG9hZCB1bmlxdWUgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbnRlbmRlZCBudW1iZXIgb2YgYnl0ZXMgdG8gYmUgdXBsb2FkZWQuXG4gICAqL1xuICBieXRlczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBVcGxvYWQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIFVwbG9hZCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGV4cGlyZXNfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQuXG4gICAqL1xuICBmaWxlbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcInVwbG9hZFwiLlxuICAgKi9cbiAgb2JqZWN0OiAndXBsb2FkJztcblxuICAvKipcbiAgICogVGhlIGludGVuZGVkIHB1cnBvc2Ugb2YgdGhlIGZpbGUuXG4gICAqIFtQbGVhc2UgcmVmZXIgaGVyZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9vYmplY3QjZmlsZXMvb2JqZWN0LXB1cnBvc2UpXG4gICAqIGZvciBhY2NlcHRhYmxlIHZhbHVlcy5cbiAgICovXG4gIHB1cnBvc2U6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHN0YXR1cyBvZiB0aGUgVXBsb2FkLlxuICAgKi9cbiAgc3RhdHVzOiAncGVuZGluZycgfCAnY29tcGxldGVkJyB8ICdjYW5jZWxsZWQnIHwgJ2V4cGlyZWQnO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVhZHkgRmlsZSBvYmplY3QgYWZ0ZXIgdGhlIFVwbG9hZCBpcyBjb21wbGV0ZWQuXG4gICAqL1xuICBmaWxlPzogRmlsZXNBUEkuRmlsZU9iamVjdCB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBsb2FkQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhlIGZpbGUgeW91IGFyZSB1cGxvYWRpbmcuXG4gICAqL1xuICBieXRlczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byB1cGxvYWQuXG4gICAqL1xuICBmaWxlbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgTUlNRSB0eXBlIG9mIHRoZSBmaWxlLlxuICAgKlxuICAgKiBUaGlzIG11c3QgZmFsbCB3aXRoaW4gdGhlIHN1cHBvcnRlZCBNSU1FIHR5cGVzIGZvciB5b3VyIGZpbGUgcHVycG9zZS4gU2VlIHRoZVxuICAgKiBzdXBwb3J0ZWQgTUlNRSB0eXBlcyBmb3IgYXNzaXN0YW50cyBhbmQgdmlzaW9uLlxuICAgKi9cbiAgbWltZV90eXBlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbnRlbmRlZCBwdXJwb3NlIG9mIHRoZSB1cGxvYWRlZCBmaWxlLlxuICAgKlxuICAgKiBTZWUgdGhlXG4gICAqIFtkb2N1bWVudGF0aW9uIG9uIEZpbGUgcHVycG9zZXNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMvY3JlYXRlI2ZpbGVzLWNyZWF0ZS1wdXJwb3NlKS5cbiAgICovXG4gIHB1cnBvc2U6IEZpbGVzQVBJLkZpbGVQdXJwb3NlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwbG9hZENvbXBsZXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBvcmRlcmVkIGxpc3Qgb2YgUGFydCBJRHMuXG4gICAqL1xuICBwYXJ0X2lkczogQXJyYXk8c3RyaW5nPjtcblxuICAvKipcbiAgICogVGhlIG9wdGlvbmFsIG1kNSBjaGVja3N1bSBmb3IgdGhlIGZpbGUgY29udGVudHMgdG8gdmVyaWZ5IGlmIHRoZSBieXRlcyB1cGxvYWRlZFxuICAgKiBtYXRjaGVzIHdoYXQgeW91IGV4cGVjdC5cbiAgICovXG4gIG1kNT86IHN0cmluZztcbn1cblxuVXBsb2Fkcy5QYXJ0cyA9IFBhcnRzO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVXBsb2FkcyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBVcGxvYWQgYXMgVXBsb2FkLFxuICAgIHR5cGUgVXBsb2FkQ3JlYXRlUGFyYW1zIGFzIFVwbG9hZENyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIFVwbG9hZENvbXBsZXRlUGFyYW1zIGFzIFVwbG9hZENvbXBsZXRlUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7IFBhcnRzIGFzIFBhcnRzLCB0eXBlIFVwbG9hZFBhcnQgYXMgVXBsb2FkUGFydCwgdHlwZSBQYXJ0Q3JlYXRlUGFyYW1zIGFzIFBhcnRDcmVhdGVQYXJhbXMgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyB0eXBlIEFnZW50LCB0eXBlIFJlcXVlc3RJbml0IH0gZnJvbSAnLi9fc2hpbXMvaW5kZXgnO1xuaW1wb3J0ICogYXMgcXMgZnJvbSAnLi9pbnRlcm5hbC9xcyc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4vY29yZSc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQgKiBhcyBQYWdpbmF0aW9uIGZyb20gJy4vcGFnaW5hdGlvbic7XG5pbXBvcnQgeyB0eXBlIEN1cnNvclBhZ2VQYXJhbXMsIEN1cnNvclBhZ2VSZXNwb25zZSwgUGFnZVJlc3BvbnNlIH0gZnJvbSAnLi9wYWdpbmF0aW9uJztcbmltcG9ydCAqIGFzIFVwbG9hZHMgZnJvbSAnLi91cGxvYWRzJztcbmltcG9ydCAqIGFzIEFQSSBmcm9tICcuL3Jlc291cmNlcy9pbmRleCc7XG5pbXBvcnQge1xuICBCYXRjaCxcbiAgQmF0Y2hDcmVhdGVQYXJhbXMsXG4gIEJhdGNoRXJyb3IsXG4gIEJhdGNoTGlzdFBhcmFtcyxcbiAgQmF0Y2hSZXF1ZXN0Q291bnRzLFxuICBCYXRjaGVzLFxuICBCYXRjaGVzUGFnZSxcbn0gZnJvbSAnLi9yZXNvdXJjZXMvYmF0Y2hlcyc7XG5pbXBvcnQge1xuICBDb21wbGV0aW9uLFxuICBDb21wbGV0aW9uQ2hvaWNlLFxuICBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICBDb21wbGV0aW9uVXNhZ2UsXG4gIENvbXBsZXRpb25zLFxufSBmcm9tICcuL3Jlc291cmNlcy9jb21wbGV0aW9ucyc7XG5pbXBvcnQge1xuICBDcmVhdGVFbWJlZGRpbmdSZXNwb25zZSxcbiAgRW1iZWRkaW5nLFxuICBFbWJlZGRpbmdDcmVhdGVQYXJhbXMsXG4gIEVtYmVkZGluZ01vZGVsLFxuICBFbWJlZGRpbmdzLFxufSBmcm9tICcuL3Jlc291cmNlcy9lbWJlZGRpbmdzJztcbmltcG9ydCB7XG4gIEZpbGVDb250ZW50LFxuICBGaWxlQ3JlYXRlUGFyYW1zLFxuICBGaWxlRGVsZXRlZCxcbiAgRmlsZUxpc3RQYXJhbXMsXG4gIEZpbGVPYmplY3QsXG4gIEZpbGVPYmplY3RzUGFnZSxcbiAgRmlsZVB1cnBvc2UsXG4gIEZpbGVzLFxufSBmcm9tICcuL3Jlc291cmNlcy9maWxlcyc7XG5pbXBvcnQge1xuICBJbWFnZSxcbiAgSW1hZ2VDcmVhdGVWYXJpYXRpb25QYXJhbXMsXG4gIEltYWdlRWRpdFBhcmFtcyxcbiAgSW1hZ2VHZW5lcmF0ZVBhcmFtcyxcbiAgSW1hZ2VNb2RlbCxcbiAgSW1hZ2VzLFxuICBJbWFnZXNSZXNwb25zZSxcbn0gZnJvbSAnLi9yZXNvdXJjZXMvaW1hZ2VzJztcbmltcG9ydCB7IE1vZGVsLCBNb2RlbERlbGV0ZWQsIE1vZGVscywgTW9kZWxzUGFnZSB9IGZyb20gJy4vcmVzb3VyY2VzL21vZGVscyc7XG5pbXBvcnQge1xuICBNb2RlcmF0aW9uLFxuICBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zLFxuICBNb2RlcmF0aW9uQ3JlYXRlUmVzcG9uc2UsXG4gIE1vZGVyYXRpb25JbWFnZVVSTElucHV0LFxuICBNb2RlcmF0aW9uTW9kZWwsXG4gIE1vZGVyYXRpb25NdWx0aU1vZGFsSW5wdXQsXG4gIE1vZGVyYXRpb25UZXh0SW5wdXQsXG4gIE1vZGVyYXRpb25zLFxufSBmcm9tICcuL3Jlc291cmNlcy9tb2RlcmF0aW9ucyc7XG5pbXBvcnQgeyBBdWRpbywgQXVkaW9Nb2RlbCwgQXVkaW9SZXNwb25zZUZvcm1hdCB9IGZyb20gJy4vcmVzb3VyY2VzL2F1ZGlvL2F1ZGlvJztcbmltcG9ydCB7IEJldGEgfSBmcm9tICcuL3Jlc291cmNlcy9iZXRhL2JldGEnO1xuaW1wb3J0IHsgQ2hhdCwgQ2hhdE1vZGVsIH0gZnJvbSAnLi9yZXNvdXJjZXMvY2hhdC9jaGF0JztcbmltcG9ydCB7XG4gIENoYXRDb21wbGV0aW9uLFxuICBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25BdWRpbyxcbiAgQ2hhdENvbXBsZXRpb25BdWRpb1BhcmFtLFxuICBDaGF0Q29tcGxldGlvbkNodW5rLFxuICBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0LFxuICBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2UsXG4gIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbnB1dEF1ZGlvLFxuICBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0UmVmdXNhbCxcbiAgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQsXG4gIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gIENoYXRDb21wbGV0aW9uRGV2ZWxvcGVyTWVzc2FnZVBhcmFtLFxuICBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uQ2FsbE9wdGlvbixcbiAgQ2hhdENvbXBsZXRpb25GdW5jdGlvbk1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25NZXNzYWdlLFxuICBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwsXG4gIENoYXRDb21wbGV0aW9uTW9kYWxpdHksXG4gIENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlLFxuICBDaGF0Q29tcGxldGlvblByZWRpY3Rpb25Db250ZW50LFxuICBDaGF0Q29tcGxldGlvblJlYXNvbmluZ0VmZm9ydCxcbiAgQ2hhdENvbXBsZXRpb25Sb2xlLFxuICBDaGF0Q29tcGxldGlvblN0cmVhbU9wdGlvbnMsXG4gIENoYXRDb21wbGV0aW9uU3lzdGVtTWVzc2FnZVBhcmFtLFxuICBDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYixcbiAgQ2hhdENvbXBsZXRpb25Ub29sLFxuICBDaGF0Q29tcGxldGlvblRvb2xDaG9pY2VPcHRpb24sXG4gIENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25Vc2VyTWVzc2FnZVBhcmFtLFxufSBmcm9tICcuL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zJztcbmltcG9ydCB7IEZpbmVUdW5pbmcgfSBmcm9tICcuL3Jlc291cmNlcy9maW5lLXR1bmluZy9maW5lLXR1bmluZyc7XG5pbXBvcnQge1xuICBVcGxvYWQsXG4gIFVwbG9hZENvbXBsZXRlUGFyYW1zLFxuICBVcGxvYWRDcmVhdGVQYXJhbXMsXG4gIFVwbG9hZHMgYXMgVXBsb2Fkc0FQSVVwbG9hZHMsXG59IGZyb20gJy4vcmVzb3VyY2VzL3VwbG9hZHMvdXBsb2Fkcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xpZW50T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBwcm9jZXNzLmVudlsnT1BFTkFJX0FQSV9LRVknXS5cbiAgICovXG4gIGFwaUtleT86IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogRGVmYXVsdHMgdG8gcHJvY2Vzcy5lbnZbJ09QRU5BSV9PUkdfSUQnXS5cbiAgICovXG4gIG9yZ2FuaXphdGlvbj86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIHByb2Nlc3MuZW52WydPUEVOQUlfUFJPSkVDVF9JRCddLlxuICAgKi9cbiAgcHJvamVjdD86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGJhc2UgVVJMIGZvciB0aGUgQVBJLCBlLmcuLCBcImh0dHBzOi8vYXBpLmV4YW1wbGUuY29tL3YyL1wiXG4gICAqXG4gICAqIERlZmF1bHRzIHRvIHByb2Nlc3MuZW52WydPUEVOQUlfQkFTRV9VUkwnXS5cbiAgICovXG4gIGJhc2VVUkw/OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSB0aGF0IHRoZSBjbGllbnQgc2hvdWxkIHdhaXQgZm9yIGEgcmVzcG9uc2VcbiAgICogZnJvbSB0aGUgc2VydmVyIGJlZm9yZSB0aW1pbmcgb3V0IGEgc2luZ2xlIHJlcXVlc3QuXG4gICAqXG4gICAqIE5vdGUgdGhhdCByZXF1ZXN0IHRpbWVvdXRzIGFyZSByZXRyaWVkIGJ5IGRlZmF1bHQsIHNvIGluIGEgd29yc3QtY2FzZSBzY2VuYXJpbyB5b3UgbWF5IHdhaXRcbiAgICogbXVjaCBsb25nZXIgdGhhbiB0aGlzIHRpbWVvdXQgYmVmb3JlIHRoZSBwcm9taXNlIHN1Y2NlZWRzIG9yIGZhaWxzLlxuICAgKi9cbiAgdGltZW91dD86IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQW4gSFRUUCBhZ2VudCB1c2VkIHRvIG1hbmFnZSBIVFRQKFMpIGNvbm5lY3Rpb25zLlxuICAgKlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIGFuIGFnZW50IHdpbGwgYmUgY29uc3RydWN0ZWQgYnkgZGVmYXVsdCBpbiB0aGUgTm9kZS5qcyBlbnZpcm9ubWVudCxcbiAgICogb3RoZXJ3aXNlIG5vIGFnZW50IGlzIHVzZWQuXG4gICAqL1xuICBodHRwQWdlbnQ/OiBBZ2VudCB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogU3BlY2lmeSBhIGN1c3RvbSBgZmV0Y2hgIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIHdlIHVzZSBgbm9kZS1mZXRjaGAgb24gTm9kZS5qcyBhbmQgb3RoZXJ3aXNlIGV4cGVjdCB0aGF0IGBmZXRjaGAgaXNcbiAgICogZGVmaW5lZCBnbG9iYWxseS5cbiAgICovXG4gIGZldGNoPzogQ29yZS5GZXRjaCB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHRoYXQgdGhlIGNsaWVudCB3aWxsIHJldHJ5IGEgcmVxdWVzdCBpbiBjYXNlIG9mIGFcbiAgICogdGVtcG9yYXJ5IGZhaWx1cmUsIGxpa2UgYSBuZXR3b3JrIGVycm9yIG9yIGEgNVhYIGVycm9yIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgbWF4UmV0cmllcz86IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogRGVmYXVsdCBoZWFkZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAqXG4gICAqIFRoZXNlIGNhbiBiZSByZW1vdmVkIGluIGluZGl2aWR1YWwgcmVxdWVzdHMgYnkgZXhwbGljaXRseSBzZXR0aW5nIHRoZVxuICAgKiBoZWFkZXIgdG8gYHVuZGVmaW5lZGAgb3IgYG51bGxgIGluIHJlcXVlc3Qgb3B0aW9ucy5cbiAgICovXG4gIGRlZmF1bHRIZWFkZXJzPzogQ29yZS5IZWFkZXJzIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHF1ZXJ5IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICpcbiAgICogVGhlc2UgY2FuIGJlIHJlbW92ZWQgaW4gaW5kaXZpZHVhbCByZXF1ZXN0cyBieSBleHBsaWNpdGx5IHNldHRpbmcgdGhlXG4gICAqIHBhcmFtIHRvIGB1bmRlZmluZWRgIGluIHJlcXVlc3Qgb3B0aW9ucy5cbiAgICovXG4gIGRlZmF1bHRRdWVyeT86IENvcmUuRGVmYXVsdFF1ZXJ5IHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0LCBjbGllbnQtc2lkZSB1c2Ugb2YgdGhpcyBsaWJyYXJ5IGlzIG5vdCBhbGxvd2VkLCBhcyBpdCByaXNrcyBleHBvc2luZyB5b3VyIHNlY3JldCBBUEkgY3JlZGVudGlhbHMgdG8gYXR0YWNrZXJzLlxuICAgKiBPbmx5IHNldCB0aGlzIG9wdGlvbiB0byBgdHJ1ZWAgaWYgeW91IHVuZGVyc3RhbmQgdGhlIHJpc2tzIGFuZCBoYXZlIGFwcHJvcHJpYXRlIG1pdGlnYXRpb25zIGluIHBsYWNlLlxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI/OiBib29sZWFuIHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEFQSSBDbGllbnQgZm9yIGludGVyZmFjaW5nIHdpdGggdGhlIE9wZW5BSSBBUEkuXG4gKi9cbmV4cG9ydCBjbGFzcyBPcGVuQUkgZXh0ZW5kcyBDb3JlLkFQSUNsaWVudCB7XG4gIGFwaUtleTogc3RyaW5nO1xuICBvcmdhbml6YXRpb246IHN0cmluZyB8IG51bGw7XG4gIHByb2plY3Q6IHN0cmluZyB8IG51bGw7XG5cbiAgcHJpdmF0ZSBfb3B0aW9uczogQ2xpZW50T3B0aW9ucztcblxuICAvKipcbiAgICogQVBJIENsaWVudCBmb3IgaW50ZXJmYWNpbmcgd2l0aCB0aGUgT3BlbkFJIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtvcHRzLmFwaUtleT1wcm9jZXNzLmVudlsnT1BFTkFJX0FQSV9LRVknXSA/PyB1bmRlZmluZWRdXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdHMub3JnYW5pemF0aW9uPXByb2Nlc3MuZW52WydPUEVOQUlfT1JHX0lEJ10gPz8gbnVsbF1cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0cy5wcm9qZWN0PXByb2Nlc3MuZW52WydPUEVOQUlfUFJPSkVDVF9JRCddID8/IG51bGxdXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYXNlVVJMPXByb2Nlc3MuZW52WydPUEVOQUlfQkFTRV9VUkwnXSA/PyBodHRwczovL2FwaS5vcGVuYWkuY29tL3YxXSAtIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGJhc2UgVVJMIGZvciB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZW91dD0xMCBtaW51dGVzXSAtIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRoZSBjbGllbnQgd2lsbCB3YWl0IGZvciBhIHJlc3BvbnNlIGJlZm9yZSB0aW1pbmcgb3V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaHR0cEFnZW50XSAtIEFuIEhUVFAgYWdlbnQgdXNlZCB0byBtYW5hZ2UgSFRUUChzKSBjb25uZWN0aW9ucy5cbiAgICogQHBhcmFtIHtDb3JlLkZldGNofSBbb3B0cy5mZXRjaF0gLSBTcGVjaWZ5IGEgY3VzdG9tIGBmZXRjaGAgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5tYXhSZXRyaWVzPTJdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHRoZSBjbGllbnQgd2lsbCByZXRyeSBhIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7Q29yZS5IZWFkZXJzfSBvcHRzLmRlZmF1bHRIZWFkZXJzIC0gRGVmYXVsdCBoZWFkZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAqIEBwYXJhbSB7Q29yZS5EZWZhdWx0UXVlcnl9IG9wdHMuZGVmYXVsdFF1ZXJ5IC0gRGVmYXVsdCBxdWVyeSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI9ZmFsc2VdIC0gQnkgZGVmYXVsdCwgY2xpZW50LXNpZGUgdXNlIG9mIHRoaXMgbGlicmFyeSBpcyBub3QgYWxsb3dlZCwgYXMgaXQgcmlza3MgZXhwb3NpbmcgeW91ciBzZWNyZXQgQVBJIGNyZWRlbnRpYWxzIHRvIGF0dGFja2Vycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVVJMID0gQ29yZS5yZWFkRW52KCdPUEVOQUlfQkFTRV9VUkwnKSxcbiAgICBhcGlLZXkgPSBDb3JlLnJlYWRFbnYoJ09QRU5BSV9BUElfS0VZJyksXG4gICAgb3JnYW5pemF0aW9uID0gQ29yZS5yZWFkRW52KCdPUEVOQUlfT1JHX0lEJykgPz8gbnVsbCxcbiAgICBwcm9qZWN0ID0gQ29yZS5yZWFkRW52KCdPUEVOQUlfUFJPSkVDVF9JRCcpID8/IG51bGwsXG4gICAgLi4ub3B0c1xuICB9OiBDbGllbnRPcHRpb25zID0ge30pIHtcbiAgICBpZiAoYXBpS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuT3BlbkFJRXJyb3IoXG4gICAgICAgIFwiVGhlIE9QRU5BSV9BUElfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG1pc3Npbmcgb3IgZW1wdHk7IGVpdGhlciBwcm92aWRlIGl0LCBvciBpbnN0YW50aWF0ZSB0aGUgT3BlbkFJIGNsaWVudCB3aXRoIGFuIGFwaUtleSBvcHRpb24sIGxpa2UgbmV3IE9wZW5BSSh7IGFwaUtleTogJ015IEFQSSBLZXknIH0pLlwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zOiBDbGllbnRPcHRpb25zID0ge1xuICAgICAgYXBpS2V5LFxuICAgICAgb3JnYW5pemF0aW9uLFxuICAgICAgcHJvamVjdCxcbiAgICAgIC4uLm9wdHMsXG4gICAgICBiYXNlVVJMOiBiYXNlVVJMIHx8IGBodHRwczovL2FwaS5vcGVuYWkuY29tL3YxYCxcbiAgICB9O1xuXG4gICAgaWYgKCFvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dCcm93c2VyICYmIENvcmUuaXNSdW5uaW5nSW5Ccm93c2VyKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuT3BlbkFJRXJyb3IoXG4gICAgICAgIFwiSXQgbG9va3MgbGlrZSB5b3UncmUgcnVubmluZyBpbiBhIGJyb3dzZXItbGlrZSBlbnZpcm9ubWVudC5cXG5cXG5UaGlzIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGFzIGl0IHJpc2tzIGV4cG9zaW5nIHlvdXIgc2VjcmV0IEFQSSBjcmVkZW50aWFscyB0byBhdHRhY2tlcnMuXFxuSWYgeW91IHVuZGVyc3RhbmQgdGhlIHJpc2tzIGFuZCBoYXZlIGFwcHJvcHJpYXRlIG1pdGlnYXRpb25zIGluIHBsYWNlLFxcbnlvdSBjYW4gc2V0IHRoZSBgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXJgIG9wdGlvbiB0byBgdHJ1ZWAsIGUuZy4sXFxuXFxubmV3IE9wZW5BSSh7IGFwaUtleSwgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI6IHRydWUgfSk7XFxuXFxuaHR0cHM6Ly9oZWxwLm9wZW5haS5jb20vZW4vYXJ0aWNsZXMvNTExMjU5NS1iZXN0LXByYWN0aWNlcy1mb3ItYXBpLWtleS1zYWZldHlcXG5cIixcbiAgICAgICk7XG4gICAgfVxuXG4gICAgc3VwZXIoe1xuICAgICAgYmFzZVVSTDogb3B0aW9ucy5iYXNlVVJMISxcbiAgICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCA/PyA2MDAwMDAgLyogMTAgbWludXRlcyAqLyxcbiAgICAgIGh0dHBBZ2VudDogb3B0aW9ucy5odHRwQWdlbnQsXG4gICAgICBtYXhSZXRyaWVzOiBvcHRpb25zLm1heFJldHJpZXMsXG4gICAgICBmZXRjaDogb3B0aW9ucy5mZXRjaCxcbiAgICB9KTtcblxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgdGhpcy5vcmdhbml6YXRpb24gPSBvcmdhbml6YXRpb247XG4gICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgfVxuXG4gIGNvbXBsZXRpb25zOiBBUEkuQ29tcGxldGlvbnMgPSBuZXcgQVBJLkNvbXBsZXRpb25zKHRoaXMpO1xuICBjaGF0OiBBUEkuQ2hhdCA9IG5ldyBBUEkuQ2hhdCh0aGlzKTtcbiAgZW1iZWRkaW5nczogQVBJLkVtYmVkZGluZ3MgPSBuZXcgQVBJLkVtYmVkZGluZ3ModGhpcyk7XG4gIGZpbGVzOiBBUEkuRmlsZXMgPSBuZXcgQVBJLkZpbGVzKHRoaXMpO1xuICBpbWFnZXM6IEFQSS5JbWFnZXMgPSBuZXcgQVBJLkltYWdlcyh0aGlzKTtcbiAgYXVkaW86IEFQSS5BdWRpbyA9IG5ldyBBUEkuQXVkaW8odGhpcyk7XG4gIG1vZGVyYXRpb25zOiBBUEkuTW9kZXJhdGlvbnMgPSBuZXcgQVBJLk1vZGVyYXRpb25zKHRoaXMpO1xuICBtb2RlbHM6IEFQSS5Nb2RlbHMgPSBuZXcgQVBJLk1vZGVscyh0aGlzKTtcbiAgZmluZVR1bmluZzogQVBJLkZpbmVUdW5pbmcgPSBuZXcgQVBJLkZpbmVUdW5pbmcodGhpcyk7XG4gIGJldGE6IEFQSS5CZXRhID0gbmV3IEFQSS5CZXRhKHRoaXMpO1xuICBiYXRjaGVzOiBBUEkuQmF0Y2hlcyA9IG5ldyBBUEkuQmF0Y2hlcyh0aGlzKTtcbiAgdXBsb2FkczogQVBJLlVwbG9hZHMgPSBuZXcgQVBJLlVwbG9hZHModGhpcyk7XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGRlZmF1bHRRdWVyeSgpOiBDb3JlLkRlZmF1bHRRdWVyeSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZGVmYXVsdFF1ZXJ5O1xuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGRlZmF1bHRIZWFkZXJzKG9wdHM6IENvcmUuRmluYWxSZXF1ZXN0T3B0aW9ucyk6IENvcmUuSGVhZGVycyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmRlZmF1bHRIZWFkZXJzKG9wdHMpLFxuICAgICAgJ09wZW5BSS1Pcmdhbml6YXRpb24nOiB0aGlzLm9yZ2FuaXphdGlvbixcbiAgICAgICdPcGVuQUktUHJvamVjdCc6IHRoaXMucHJvamVjdCxcbiAgICAgIC4uLnRoaXMuX29wdGlvbnMuZGVmYXVsdEhlYWRlcnMsXG4gICAgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBhdXRoSGVhZGVycyhvcHRzOiBDb3JlLkZpbmFsUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkhlYWRlcnMge1xuICAgIHJldHVybiB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLmFwaUtleX1gIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgc3RyaW5naWZ5UXVlcnkocXVlcnk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogc3RyaW5nIHtcbiAgICByZXR1cm4gcXMuc3RyaW5naWZ5KHF1ZXJ5LCB7IGFycmF5Rm9ybWF0OiAnYnJhY2tldHMnIH0pO1xuICB9XG5cbiAgc3RhdGljIE9wZW5BSSA9IHRoaXM7XG4gIHN0YXRpYyBERUZBVUxUX1RJTUVPVVQgPSA2MDAwMDA7IC8vIDEwIG1pbnV0ZXNcblxuICBzdGF0aWMgT3BlbkFJRXJyb3IgPSBFcnJvcnMuT3BlbkFJRXJyb3I7XG4gIHN0YXRpYyBBUElFcnJvciA9IEVycm9ycy5BUElFcnJvcjtcbiAgc3RhdGljIEFQSUNvbm5lY3Rpb25FcnJvciA9IEVycm9ycy5BUElDb25uZWN0aW9uRXJyb3I7XG4gIHN0YXRpYyBBUElDb25uZWN0aW9uVGltZW91dEVycm9yID0gRXJyb3JzLkFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3I7XG4gIHN0YXRpYyBBUElVc2VyQWJvcnRFcnJvciA9IEVycm9ycy5BUElVc2VyQWJvcnRFcnJvcjtcbiAgc3RhdGljIE5vdEZvdW5kRXJyb3IgPSBFcnJvcnMuTm90Rm91bmRFcnJvcjtcbiAgc3RhdGljIENvbmZsaWN0RXJyb3IgPSBFcnJvcnMuQ29uZmxpY3RFcnJvcjtcbiAgc3RhdGljIFJhdGVMaW1pdEVycm9yID0gRXJyb3JzLlJhdGVMaW1pdEVycm9yO1xuICBzdGF0aWMgQmFkUmVxdWVzdEVycm9yID0gRXJyb3JzLkJhZFJlcXVlc3RFcnJvcjtcbiAgc3RhdGljIEF1dGhlbnRpY2F0aW9uRXJyb3IgPSBFcnJvcnMuQXV0aGVudGljYXRpb25FcnJvcjtcbiAgc3RhdGljIEludGVybmFsU2VydmVyRXJyb3IgPSBFcnJvcnMuSW50ZXJuYWxTZXJ2ZXJFcnJvcjtcbiAgc3RhdGljIFBlcm1pc3Npb25EZW5pZWRFcnJvciA9IEVycm9ycy5QZXJtaXNzaW9uRGVuaWVkRXJyb3I7XG4gIHN0YXRpYyBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IgPSBFcnJvcnMuVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yO1xuXG4gIHN0YXRpYyB0b0ZpbGUgPSBVcGxvYWRzLnRvRmlsZTtcbiAgc3RhdGljIGZpbGVGcm9tUGF0aCA9IFVwbG9hZHMuZmlsZUZyb21QYXRoO1xufVxuXG5PcGVuQUkuQ29tcGxldGlvbnMgPSBDb21wbGV0aW9ucztcbk9wZW5BSS5DaGF0ID0gQ2hhdDtcbk9wZW5BSS5FbWJlZGRpbmdzID0gRW1iZWRkaW5ncztcbk9wZW5BSS5GaWxlcyA9IEZpbGVzO1xuT3BlbkFJLkZpbGVPYmplY3RzUGFnZSA9IEZpbGVPYmplY3RzUGFnZTtcbk9wZW5BSS5JbWFnZXMgPSBJbWFnZXM7XG5PcGVuQUkuQXVkaW8gPSBBdWRpbztcbk9wZW5BSS5Nb2RlcmF0aW9ucyA9IE1vZGVyYXRpb25zO1xuT3BlbkFJLk1vZGVscyA9IE1vZGVscztcbk9wZW5BSS5Nb2RlbHNQYWdlID0gTW9kZWxzUGFnZTtcbk9wZW5BSS5GaW5lVHVuaW5nID0gRmluZVR1bmluZztcbk9wZW5BSS5CZXRhID0gQmV0YTtcbk9wZW5BSS5CYXRjaGVzID0gQmF0Y2hlcztcbk9wZW5BSS5CYXRjaGVzUGFnZSA9IEJhdGNoZXNQYWdlO1xuT3BlbkFJLlVwbG9hZHMgPSBVcGxvYWRzQVBJVXBsb2FkcztcbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBPcGVuQUkge1xuICBleHBvcnQgdHlwZSBSZXF1ZXN0T3B0aW9ucyA9IENvcmUuUmVxdWVzdE9wdGlvbnM7XG5cbiAgZXhwb3J0IGltcG9ydCBQYWdlID0gUGFnaW5hdGlvbi5QYWdlO1xuICBleHBvcnQgeyB0eXBlIFBhZ2VSZXNwb25zZSBhcyBQYWdlUmVzcG9uc2UgfTtcblxuICBleHBvcnQgaW1wb3J0IEN1cnNvclBhZ2UgPSBQYWdpbmF0aW9uLkN1cnNvclBhZ2U7XG4gIGV4cG9ydCB7IHR5cGUgQ3Vyc29yUGFnZVBhcmFtcyBhcyBDdXJzb3JQYWdlUGFyYW1zLCB0eXBlIEN1cnNvclBhZ2VSZXNwb25zZSBhcyBDdXJzb3JQYWdlUmVzcG9uc2UgfTtcblxuICBleHBvcnQge1xuICAgIENvbXBsZXRpb25zIGFzIENvbXBsZXRpb25zLFxuICAgIHR5cGUgQ29tcGxldGlvbiBhcyBDb21wbGV0aW9uLFxuICAgIHR5cGUgQ29tcGxldGlvbkNob2ljZSBhcyBDb21wbGV0aW9uQ2hvaWNlLFxuICAgIHR5cGUgQ29tcGxldGlvblVzYWdlIGFzIENvbXBsZXRpb25Vc2FnZSxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXMgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIENoYXQgYXMgQ2hhdCxcbiAgICB0eXBlIENoYXRNb2RlbCBhcyBDaGF0TW9kZWwsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbiBhcyBDaGF0Q29tcGxldGlvbixcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25BdWRpbyBhcyBDaGF0Q29tcGxldGlvbkF1ZGlvLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25BdWRpb1BhcmFtIGFzIENoYXRDb21wbGV0aW9uQXVkaW9QYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ2h1bmsgYXMgQ2hhdENvbXBsZXRpb25DaHVuayxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnQgYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbWFnZSBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2UsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW5wdXRBdWRpbyBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW5wdXRBdWRpbyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRSZWZ1c2FsIGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRSZWZ1c2FsLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQgYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkRldmVsb3Blck1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvbkRldmVsb3Blck1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uRnVuY3Rpb25DYWxsT3B0aW9uIGFzIENoYXRDb21wbGV0aW9uRnVuY3Rpb25DYWxsT3B0aW9uLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25GdW5jdGlvbk1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlIGFzIENoYXRDb21wbGV0aW9uTWVzc2FnZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwgYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk1vZGFsaXR5IGFzIENoYXRDb21wbGV0aW9uTW9kYWxpdHksXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk5hbWVkVG9vbENob2ljZSBhcyBDaGF0Q29tcGxldGlvbk5hbWVkVG9vbENob2ljZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uUHJlZGljdGlvbkNvbnRlbnQgYXMgQ2hhdENvbXBsZXRpb25QcmVkaWN0aW9uQ29udGVudCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uUmVhc29uaW5nRWZmb3J0IGFzIENoYXRDb21wbGV0aW9uUmVhc29uaW5nRWZmb3J0LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Sb2xlIGFzIENoYXRDb21wbGV0aW9uUm9sZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uU3RyZWFtT3B0aW9ucyBhcyBDaGF0Q29tcGxldGlvblN0cmVhbU9wdGlvbnMsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblN5c3RlbU1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvblN5c3RlbU1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iIGFzIENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sIGFzIENoYXRDb21wbGV0aW9uVG9vbCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVG9vbENob2ljZU9wdGlvbiBhcyBDaGF0Q29tcGxldGlvblRvb2xDaG9pY2VPcHRpb24sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblRvb2xNZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25Ub29sTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Vc2VyTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uVXNlck1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIGFzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgYXMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBhcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIEVtYmVkZGluZ3MgYXMgRW1iZWRkaW5ncyxcbiAgICB0eXBlIENyZWF0ZUVtYmVkZGluZ1Jlc3BvbnNlIGFzIENyZWF0ZUVtYmVkZGluZ1Jlc3BvbnNlLFxuICAgIHR5cGUgRW1iZWRkaW5nIGFzIEVtYmVkZGluZyxcbiAgICB0eXBlIEVtYmVkZGluZ01vZGVsIGFzIEVtYmVkZGluZ01vZGVsLFxuICAgIHR5cGUgRW1iZWRkaW5nQ3JlYXRlUGFyYW1zIGFzIEVtYmVkZGluZ0NyZWF0ZVBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIEZpbGVzIGFzIEZpbGVzLFxuICAgIHR5cGUgRmlsZUNvbnRlbnQgYXMgRmlsZUNvbnRlbnQsXG4gICAgdHlwZSBGaWxlRGVsZXRlZCBhcyBGaWxlRGVsZXRlZCxcbiAgICB0eXBlIEZpbGVPYmplY3QgYXMgRmlsZU9iamVjdCxcbiAgICB0eXBlIEZpbGVQdXJwb3NlIGFzIEZpbGVQdXJwb3NlLFxuICAgIEZpbGVPYmplY3RzUGFnZSBhcyBGaWxlT2JqZWN0c1BhZ2UsXG4gICAgdHlwZSBGaWxlQ3JlYXRlUGFyYW1zIGFzIEZpbGVDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBGaWxlTGlzdFBhcmFtcyBhcyBGaWxlTGlzdFBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIEltYWdlcyBhcyBJbWFnZXMsXG4gICAgdHlwZSBJbWFnZSBhcyBJbWFnZSxcbiAgICB0eXBlIEltYWdlTW9kZWwgYXMgSW1hZ2VNb2RlbCxcbiAgICB0eXBlIEltYWdlc1Jlc3BvbnNlIGFzIEltYWdlc1Jlc3BvbnNlLFxuICAgIHR5cGUgSW1hZ2VDcmVhdGVWYXJpYXRpb25QYXJhbXMgYXMgSW1hZ2VDcmVhdGVWYXJpYXRpb25QYXJhbXMsXG4gICAgdHlwZSBJbWFnZUVkaXRQYXJhbXMgYXMgSW1hZ2VFZGl0UGFyYW1zLFxuICAgIHR5cGUgSW1hZ2VHZW5lcmF0ZVBhcmFtcyBhcyBJbWFnZUdlbmVyYXRlUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7IEF1ZGlvIGFzIEF1ZGlvLCB0eXBlIEF1ZGlvTW9kZWwgYXMgQXVkaW9Nb2RlbCwgdHlwZSBBdWRpb1Jlc3BvbnNlRm9ybWF0IGFzIEF1ZGlvUmVzcG9uc2VGb3JtYXQgfTtcblxuICBleHBvcnQge1xuICAgIE1vZGVyYXRpb25zIGFzIE1vZGVyYXRpb25zLFxuICAgIHR5cGUgTW9kZXJhdGlvbiBhcyBNb2RlcmF0aW9uLFxuICAgIHR5cGUgTW9kZXJhdGlvbkltYWdlVVJMSW5wdXQgYXMgTW9kZXJhdGlvbkltYWdlVVJMSW5wdXQsXG4gICAgdHlwZSBNb2RlcmF0aW9uTW9kZWwgYXMgTW9kZXJhdGlvbk1vZGVsLFxuICAgIHR5cGUgTW9kZXJhdGlvbk11bHRpTW9kYWxJbnB1dCBhcyBNb2RlcmF0aW9uTXVsdGlNb2RhbElucHV0LFxuICAgIHR5cGUgTW9kZXJhdGlvblRleHRJbnB1dCBhcyBNb2RlcmF0aW9uVGV4dElucHV0LFxuICAgIHR5cGUgTW9kZXJhdGlvbkNyZWF0ZVJlc3BvbnNlIGFzIE1vZGVyYXRpb25DcmVhdGVSZXNwb25zZSxcbiAgICB0eXBlIE1vZGVyYXRpb25DcmVhdGVQYXJhbXMgYXMgTW9kZXJhdGlvbkNyZWF0ZVBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIE1vZGVscyBhcyBNb2RlbHMsXG4gICAgdHlwZSBNb2RlbCBhcyBNb2RlbCxcbiAgICB0eXBlIE1vZGVsRGVsZXRlZCBhcyBNb2RlbERlbGV0ZWQsXG4gICAgTW9kZWxzUGFnZSBhcyBNb2RlbHNQYWdlLFxuICB9O1xuXG4gIGV4cG9ydCB7IEZpbmVUdW5pbmcgYXMgRmluZVR1bmluZyB9O1xuXG4gIGV4cG9ydCB7IEJldGEgYXMgQmV0YSB9O1xuXG4gIGV4cG9ydCB7XG4gICAgQmF0Y2hlcyBhcyBCYXRjaGVzLFxuICAgIHR5cGUgQmF0Y2ggYXMgQmF0Y2gsXG4gICAgdHlwZSBCYXRjaEVycm9yIGFzIEJhdGNoRXJyb3IsXG4gICAgdHlwZSBCYXRjaFJlcXVlc3RDb3VudHMgYXMgQmF0Y2hSZXF1ZXN0Q291bnRzLFxuICAgIEJhdGNoZXNQYWdlIGFzIEJhdGNoZXNQYWdlLFxuICAgIHR5cGUgQmF0Y2hDcmVhdGVQYXJhbXMgYXMgQmF0Y2hDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBCYXRjaExpc3RQYXJhbXMgYXMgQmF0Y2hMaXN0UGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgVXBsb2Fkc0FQSVVwbG9hZHMgYXMgVXBsb2FkcyxcbiAgICB0eXBlIFVwbG9hZCBhcyBVcGxvYWQsXG4gICAgdHlwZSBVcGxvYWRDcmVhdGVQYXJhbXMgYXMgVXBsb2FkQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgVXBsb2FkQ29tcGxldGVQYXJhbXMgYXMgVXBsb2FkQ29tcGxldGVQYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHR5cGUgRXJyb3JPYmplY3QgPSBBUEkuRXJyb3JPYmplY3Q7XG4gIGV4cG9ydCB0eXBlIEZ1bmN0aW9uRGVmaW5pdGlvbiA9IEFQSS5GdW5jdGlvbkRlZmluaXRpb247XG4gIGV4cG9ydCB0eXBlIEZ1bmN0aW9uUGFyYW1ldGVycyA9IEFQSS5GdW5jdGlvblBhcmFtZXRlcnM7XG4gIGV4cG9ydCB0eXBlIFJlc3BvbnNlRm9ybWF0SlNPTk9iamVjdCA9IEFQSS5SZXNwb25zZUZvcm1hdEpTT05PYmplY3Q7XG4gIGV4cG9ydCB0eXBlIFJlc3BvbnNlRm9ybWF0SlNPTlNjaGVtYSA9IEFQSS5SZXNwb25zZUZvcm1hdEpTT05TY2hlbWE7XG4gIGV4cG9ydCB0eXBlIFJlc3BvbnNlRm9ybWF0VGV4dCA9IEFQSS5SZXNwb25zZUZvcm1hdFRleHQ7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQXp1cmUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKiogQVBJIENsaWVudCBmb3IgaW50ZXJmYWNpbmcgd2l0aCB0aGUgQXp1cmUgT3BlbkFJIEFQSS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXp1cmVDbGllbnRPcHRpb25zIGV4dGVuZHMgQ2xpZW50T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBwcm9jZXNzLmVudlsnT1BFTkFJX0FQSV9WRVJTSU9OJ10uXG4gICAqL1xuICBhcGlWZXJzaW9uPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBZb3VyIEF6dXJlIGVuZHBvaW50LCBpbmNsdWRpbmcgdGhlIHJlc291cmNlLCBlLmcuIGBodHRwczovL2V4YW1wbGUtcmVzb3VyY2UuYXp1cmUub3BlbmFpLmNvbS9gXG4gICAqL1xuICBlbmRwb2ludD86IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQSBtb2RlbCBkZXBsb3ltZW50LCBpZiBnaXZlbiwgc2V0cyB0aGUgYmFzZSBjbGllbnQgVVJMIHRvIGluY2x1ZGUgYC9kZXBsb3ltZW50cy97ZGVwbG95bWVudH1gLlxuICAgKiBOb3RlOiB0aGlzIG1lYW5zIHlvdSB3b24ndCBiZSBhYmxlIHRvIHVzZSBub24tZGVwbG95bWVudCBlbmRwb2ludHMuIE5vdCBzdXBwb3J0ZWQgd2l0aCBBc3Npc3RhbnRzIEFQSXMuXG4gICAqL1xuICBkZXBsb3ltZW50Pzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBwcm9jZXNzLmVudlsnQVpVUkVfT1BFTkFJX0FQSV9LRVknXS5cbiAgICovXG4gIGFwaUtleT86IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gYWNjZXNzIHRva2VuIGZvciBNaWNyb3NvZnQgRW50cmEgKGZvcm1lcmx5IGtub3duIGFzIEF6dXJlIEFjdGl2ZSBEaXJlY3RvcnkpLFxuICAgKiB3aGljaCB3aWxsIGJlIGludm9rZWQgb24gZXZlcnkgcmVxdWVzdC5cbiAgICovXG4gIGF6dXJlQURUb2tlblByb3ZpZGVyPzogKCgpID0+IFByb21pc2U8c3RyaW5nPikgfCB1bmRlZmluZWQ7XG59XG5cbi8qKiBBUEkgQ2xpZW50IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBBenVyZSBPcGVuQUkgQVBJLiAqL1xuZXhwb3J0IGNsYXNzIEF6dXJlT3BlbkFJIGV4dGVuZHMgT3BlbkFJIHtcbiAgcHJpdmF0ZSBfYXp1cmVBRFRva2VuUHJvdmlkZXI6ICgoKSA9PiBQcm9taXNlPHN0cmluZz4pIHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIF9kZXBsb3ltZW50OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGFwaVZlcnNpb246IHN0cmluZyA9ICcnO1xuICAvKipcbiAgICogQVBJIENsaWVudCBmb3IgaW50ZXJmYWNpbmcgd2l0aCB0aGUgQXp1cmUgT3BlbkFJIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtvcHRzLmFwaVZlcnNpb249cHJvY2Vzcy5lbnZbJ09QRU5BSV9BUElfVkVSU0lPTiddID8/IHVuZGVmaW5lZF1cbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtvcHRzLmVuZHBvaW50PXByb2Nlc3MuZW52WydBWlVSRV9PUEVOQUlfRU5EUE9JTlQnXSA/PyB1bmRlZmluZWRdIC0gWW91ciBBenVyZSBlbmRwb2ludCwgaW5jbHVkaW5nIHRoZSByZXNvdXJjZSwgZS5nLiBgaHR0cHM6Ly9leGFtcGxlLXJlc291cmNlLmF6dXJlLm9wZW5haS5jb20vYFxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW29wdHMuYXBpS2V5PXByb2Nlc3MuZW52WydBWlVSRV9PUEVOQUlfQVBJX0tFWSddID8/IHVuZGVmaW5lZF1cbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IG9wdHMuZGVwbG95bWVudCAtIEEgbW9kZWwgZGVwbG95bWVudCwgaWYgZ2l2ZW4sIHNldHMgdGhlIGJhc2UgY2xpZW50IFVSTCB0byBpbmNsdWRlIGAvZGVwbG95bWVudHMve2RlcGxveW1lbnR9YC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0cy5vcmdhbml6YXRpb249cHJvY2Vzcy5lbnZbJ09QRU5BSV9PUkdfSUQnXSA/PyBudWxsXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFzZVVSTD1wcm9jZXNzLmVudlsnT1BFTkFJX0JBU0VfVVJMJ11dIC0gU2V0cyB0aGUgYmFzZSBVUkwgZm9yIHRoZSBBUEksIGUuZy4gYGh0dHBzOi8vZXhhbXBsZS1yZXNvdXJjZS5henVyZS5vcGVuYWkuY29tL29wZW5haS9gLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZW91dD0xMCBtaW51dGVzXSAtIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRoZSBjbGllbnQgd2lsbCB3YWl0IGZvciBhIHJlc3BvbnNlIGJlZm9yZSB0aW1pbmcgb3V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaHR0cEFnZW50XSAtIEFuIEhUVFAgYWdlbnQgdXNlZCB0byBtYW5hZ2UgSFRUUChzKSBjb25uZWN0aW9ucy5cbiAgICogQHBhcmFtIHtDb3JlLkZldGNofSBbb3B0cy5mZXRjaF0gLSBTcGVjaWZ5IGEgY3VzdG9tIGBmZXRjaGAgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5tYXhSZXRyaWVzPTJdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHRoZSBjbGllbnQgd2lsbCByZXRyeSBhIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7Q29yZS5IZWFkZXJzfSBvcHRzLmRlZmF1bHRIZWFkZXJzIC0gRGVmYXVsdCBoZWFkZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAqIEBwYXJhbSB7Q29yZS5EZWZhdWx0UXVlcnl9IG9wdHMuZGVmYXVsdFF1ZXJ5IC0gRGVmYXVsdCBxdWVyeSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI9ZmFsc2VdIC0gQnkgZGVmYXVsdCwgY2xpZW50LXNpZGUgdXNlIG9mIHRoaXMgbGlicmFyeSBpcyBub3QgYWxsb3dlZCwgYXMgaXQgcmlza3MgZXhwb3NpbmcgeW91ciBzZWNyZXQgQVBJIGNyZWRlbnRpYWxzIHRvIGF0dGFja2Vycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVVJMID0gQ29yZS5yZWFkRW52KCdPUEVOQUlfQkFTRV9VUkwnKSxcbiAgICBhcGlLZXkgPSBDb3JlLnJlYWRFbnYoJ0FaVVJFX09QRU5BSV9BUElfS0VZJyksXG4gICAgYXBpVmVyc2lvbiA9IENvcmUucmVhZEVudignT1BFTkFJX0FQSV9WRVJTSU9OJyksXG4gICAgZW5kcG9pbnQsXG4gICAgZGVwbG95bWVudCxcbiAgICBhenVyZUFEVG9rZW5Qcm92aWRlcixcbiAgICBkYW5nZXJvdXNseUFsbG93QnJvd3NlcixcbiAgICAuLi5vcHRzXG4gIH06IEF6dXJlQ2xpZW50T3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFhcGlWZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKFxuICAgICAgICBcIlRoZSBPUEVOQUlfQVBJX1ZFUlNJT04gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbWlzc2luZyBvciBlbXB0eTsgZWl0aGVyIHByb3ZpZGUgaXQsIG9yIGluc3RhbnRpYXRlIHRoZSBBenVyZU9wZW5BSSBjbGllbnQgd2l0aCBhbiBhcGlWZXJzaW9uIG9wdGlvbiwgbGlrZSBuZXcgQXp1cmVPcGVuQUkoeyBhcGlWZXJzaW9uOiAnTXkgQVBJIFZlcnNpb24nIH0pLlwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGF6dXJlQURUb2tlblByb3ZpZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkYW5nZXJvdXNseUFsbG93QnJvd3NlciA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFhenVyZUFEVG9rZW5Qcm92aWRlciAmJiAhYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKFxuICAgICAgICAnTWlzc2luZyBjcmVkZW50aWFscy4gUGxlYXNlIHBhc3Mgb25lIG9mIGBhcGlLZXlgIGFuZCBgYXp1cmVBRFRva2VuUHJvdmlkZXJgLCBvciBzZXQgdGhlIGBBWlVSRV9PUEVOQUlfQVBJX0tFWWAgZW52aXJvbm1lbnQgdmFyaWFibGUuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGF6dXJlQURUb2tlblByb3ZpZGVyICYmIGFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcihcbiAgICAgICAgJ1RoZSBgYXBpS2V5YCBhbmQgYGF6dXJlQURUb2tlblByb3ZpZGVyYCBhcmd1bWVudHMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZTsgb25seSBvbmUgY2FuIGJlIHBhc3NlZCBhdCBhIHRpbWUuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZGVmaW5lIGEgc2VudGluZWwgdmFsdWUgdG8gYXZvaWQgYW55IHR5cGluZyBpc3N1ZXNcbiAgICBhcGlLZXkgPz89IEFQSV9LRVlfU0VOVElORUw7XG5cbiAgICBvcHRzLmRlZmF1bHRRdWVyeSA9IHsgLi4ub3B0cy5kZWZhdWx0UXVlcnksICdhcGktdmVyc2lvbic6IGFwaVZlcnNpb24gfTtcblxuICAgIGlmICghYmFzZVVSTCkge1xuICAgICAgaWYgKCFlbmRwb2ludCkge1xuICAgICAgICBlbmRwb2ludCA9IHByb2Nlc3MuZW52WydBWlVSRV9PUEVOQUlfRU5EUE9JTlQnXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbmRwb2ludCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKFxuICAgICAgICAgICdNdXN0IHByb3ZpZGUgb25lIG9mIHRoZSBgYmFzZVVSTGAgb3IgYGVuZHBvaW50YCBhcmd1bWVudHMsIG9yIHRoZSBgQVpVUkVfT1BFTkFJX0VORFBPSU5UYCBlbnZpcm9ubWVudCB2YXJpYWJsZScsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGJhc2VVUkwgPSBgJHtlbmRwb2ludH0vb3BlbmFpYDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVuZHBvaW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcnMuT3BlbkFJRXJyb3IoJ2Jhc2VVUkwgYW5kIGVuZHBvaW50IGFyZSBtdXR1YWxseSBleGNsdXNpdmUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdXBlcih7XG4gICAgICBhcGlLZXksXG4gICAgICBiYXNlVVJMLFxuICAgICAgLi4ub3B0cyxcbiAgICAgIC4uLihkYW5nZXJvdXNseUFsbG93QnJvd3NlciAhPT0gdW5kZWZpbmVkID8geyBkYW5nZXJvdXNseUFsbG93QnJvd3NlciB9IDoge30pLFxuICAgIH0pO1xuXG4gICAgdGhpcy5fYXp1cmVBRFRva2VuUHJvdmlkZXIgPSBhenVyZUFEVG9rZW5Qcm92aWRlcjtcbiAgICB0aGlzLmFwaVZlcnNpb24gPSBhcGlWZXJzaW9uO1xuICAgIHRoaXMuX2RlcGxveW1lbnQgPSBkZXBsb3ltZW50O1xuICB9XG5cbiAgb3ZlcnJpZGUgYnVpbGRSZXF1ZXN0KG9wdGlvbnM6IENvcmUuRmluYWxSZXF1ZXN0T3B0aW9uczx1bmtub3duPik6IHtcbiAgICByZXE6IFJlcXVlc3RJbml0O1xuICAgIHVybDogc3RyaW5nO1xuICAgIHRpbWVvdXQ6IG51bWJlcjtcbiAgfSB7XG4gICAgaWYgKF9kZXBsb3ltZW50c19lbmRwb2ludHMuaGFzKG9wdGlvbnMucGF0aCkgJiYgb3B0aW9ucy5tZXRob2QgPT09ICdwb3N0JyAmJiBvcHRpb25zLmJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFDb3JlLmlzT2JqKG9wdGlvbnMuYm9keSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZXF1ZXN0IGJvZHkgdG8gYmUgYW4gb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX2RlcGxveW1lbnQgfHwgb3B0aW9ucy5ib2R5Wydtb2RlbCddO1xuICAgICAgaWYgKG1vZGVsICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuYmFzZVVSTC5pbmNsdWRlcygnL2RlcGxveW1lbnRzJykpIHtcbiAgICAgICAgb3B0aW9ucy5wYXRoID0gYC9kZXBsb3ltZW50cy8ke21vZGVsfSR7b3B0aW9ucy5wYXRofWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5idWlsZFJlcXVlc3Qob3B0aW9ucyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9nZXRBenVyZUFEVG9rZW4oKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2F6dXJlQURUb2tlblByb3ZpZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHRoaXMuX2F6dXJlQURUb2tlblByb3ZpZGVyKCk7XG4gICAgICBpZiAoIXRva2VuIHx8IHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgJ2F6dXJlQURUb2tlblByb3ZpZGVyJyBhcmd1bWVudCB0byByZXR1cm4gYSBzdHJpbmcgYnV0IGl0IHJldHVybmVkICR7dG9rZW59YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBhdXRoSGVhZGVycyhvcHRzOiBDb3JlLkZpbmFsUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkhlYWRlcnMge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBhc3luYyBwcmVwYXJlT3B0aW9ucyhvcHRzOiBDb3JlLkZpbmFsUmVxdWVzdE9wdGlvbnM8dW5rbm93bj4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdXNlciBzaG91bGQgcHJvdmlkZSBhIGJlYXJlciB0b2tlbiBwcm92aWRlciBpZiB0aGV5IHdhbnRcbiAgICAgKiB0byB1c2UgQXp1cmUgQUQgYXV0aGVudGljYXRpb24uIFRoZSB1c2VyIHNob3VsZG4ndCBzZXQgdGhlXG4gICAgICogQXV0aG9yaXphdGlvbiBoZWFkZXIgbWFudWFsbHkgYmVjYXVzZSB0aGUgaGVhZGVyIGlzIG92ZXJ3cml0dGVuXG4gICAgICogd2l0aCB0aGUgQXp1cmUgQUQgdG9rZW4gaWYgYSBiZWFyZXIgdG9rZW4gcHJvdmlkZXIgaXMgcHJvdmlkZWQuXG4gICAgICovXG4gICAgaWYgKG9wdHMuaGVhZGVycz8uWydhcGkta2V5J10pIHtcbiAgICAgIHJldHVybiBzdXBlci5wcmVwYXJlT3B0aW9ucyhvcHRzKTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLl9nZXRBenVyZUFEVG9rZW4oKTtcbiAgICBvcHRzLmhlYWRlcnMgPz89IHt9O1xuICAgIGlmICh0b2tlbikge1xuICAgICAgb3B0cy5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dG9rZW59YDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYXBpS2V5ICE9PSBBUElfS0VZX1NFTlRJTkVMKSB7XG4gICAgICBvcHRzLmhlYWRlcnNbJ2FwaS1rZXknXSA9IHRoaXMuYXBpS2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKCdVbmFibGUgdG8gaGFuZGxlIGF1dGgnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnByZXBhcmVPcHRpb25zKG9wdHMpO1xuICB9XG59XG5cbmNvbnN0IF9kZXBsb3ltZW50c19lbmRwb2ludHMgPSBuZXcgU2V0KFtcbiAgJy9jb21wbGV0aW9ucycsXG4gICcvY2hhdC9jb21wbGV0aW9ucycsXG4gICcvZW1iZWRkaW5ncycsXG4gICcvYXVkaW8vdHJhbnNjcmlwdGlvbnMnLFxuICAnL2F1ZGlvL3RyYW5zbGF0aW9ucycsXG4gICcvYXVkaW8vc3BlZWNoJyxcbiAgJy9pbWFnZXMvZ2VuZXJhdGlvbnMnLFxuXSk7XG5cbmNvbnN0IEFQSV9LRVlfU0VOVElORUwgPSAnPE1pc3NpbmcgS2V5Pic7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRW5kIEF6dXJlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IHsgdG9GaWxlLCBmaWxlRnJvbVBhdGggfSBmcm9tICcuL3VwbG9hZHMnO1xuZXhwb3J0IHtcbiAgT3BlbkFJRXJyb3IsXG4gIEFQSUVycm9yLFxuICBBUElDb25uZWN0aW9uRXJyb3IsXG4gIEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IsXG4gIEFQSVVzZXJBYm9ydEVycm9yLFxuICBOb3RGb3VuZEVycm9yLFxuICBDb25mbGljdEVycm9yLFxuICBSYXRlTGltaXRFcnJvcixcbiAgQmFkUmVxdWVzdEVycm9yLFxuICBBdXRoZW50aWNhdGlvbkVycm9yLFxuICBJbnRlcm5hbFNlcnZlckVycm9yLFxuICBQZXJtaXNzaW9uRGVuaWVkRXJyb3IsXG4gIFVucHJvY2Vzc2FibGVFbnRpdHlFcnJvcixcbn0gZnJvbSAnLi9lcnJvcic7XG5cbmV4cG9ydCBkZWZhdWx0IE9wZW5BSTtcbiIsICJpbXBvcnQgT3BlbkFJIGZyb20gJ29wZW5haSc7XG5pbXBvcnQgeyBFbWJlZGRpbmdSZXNwb25zZSB9IGZyb20gJy4uL21vZGVscy9Eb2N1bWVudENodW5rJztcbmltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEVycm9ySGFuZGxlciB9IGZyb20gJy4uL3V0aWxzL0Vycm9ySGFuZGxlcic7XG5pbXBvcnQgeyBPcGVuQUlTZXR0aW5ncyB9IGZyb20gJy4uL3NldHRpbmdzL1NldHRpbmdzJztcblxuZXhwb3J0IGNsYXNzIE9wZW5BSVNlcnZpY2Uge1xuXHRwcml2YXRlIGNsaWVudDogT3BlbkFJIHwgbnVsbDtcblx0cHJpdmF0ZSByYXRlTGltaXREZWxheTogbnVtYmVyID0gMjA7IC8vIG1zIGJldHdlZW4gcmVxdWVzdHNcblx0cHJpdmF0ZSBsYXN0UmVxdWVzdFRpbWU6IG51bWJlciA9IDA7XG5cdHByaXZhdGUgcmVhZG9ubHkgZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXI7XG5cdHByaXZhdGUgc2V0dGluZ3M6IE9wZW5BSVNldHRpbmdzO1xuXG5cdGNvbnN0cnVjdG9yKHNldHRpbmdzOiBPcGVuQUlTZXR0aW5ncywgZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXIpIHtcblx0XHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG5cdFx0dGhpcy5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG5cblx0XHRpZiAoIXNldHRpbmdzLmFwaUtleSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdPcGVuQUkgQVBJIGtleSBpcyBtaXNzaW5nLiBPcGVuQUlTZXJ2aWNlIHdpbGwgbm90IGJlIGluaXRpYWxpemVkLicpO1xuXHRcdFx0dGhpcy5jbGllbnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEluaXRpYWxpemUgT3BlbkFJIGNsaWVudCB3aXRoIGJyb3dzZXIgc3VwcG9ydFxuXHRcdHRoaXMuY2xpZW50ID0gbmV3IE9wZW5BSSh7XG5cdFx0XHRhcGlLZXk6IHNldHRpbmdzLmFwaUtleSxcblx0XHRcdGRhbmdlcm91c2x5QWxsb3dCcm93c2VyOiB0cnVlLCAvLyBFbmFibGUgYnJvd3Nlci1saWtlIGVudmlyb25tZW50IHVzYWdlXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhlIHNlcnZpY2UgaXMgaW5pdGlhbGl6ZWRcblx0ICovXG5cdHB1YmxpYyBpc0luaXRpYWxpemVkKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLmNsaWVudCAhPT0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGVtYmVkZGluZ3MgZm9yIHRoZSBnaXZlbiB0ZXh0IGNodW5rcyB3aXRoIHJhdGUgbGltaXRpbmcgYW5kIHJldHJpZXNcblx0ICovXG5cdGFzeW5jIGNyZWF0ZUVtYmVkZGluZ3MoY2h1bmtzOiBzdHJpbmdbXSk6IFByb21pc2U8RW1iZWRkaW5nUmVzcG9uc2VbXT4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHtcblx0XHRcdGNvbnNvbGUud2FybignT3BlbkFJU2VydmljZSBpcyBub3QgaW5pdGlhbGl6ZWQuIENhbm5vdCBjcmVhdGUgZW1iZWRkaW5ncy4nKTtcblx0XHRcdG5ldyBOb3RpY2UoJ09wZW5BSSBBUEkga2V5IGlzIG1pc3NpbmcuIFBsZWFzZSBzZXQgaXQgaW4gdGhlIHBsdWdpbiBzZXR0aW5ncy4nKTtcblx0XHRcdHJldHVybiBjaHVua3MubWFwKCgpID0+ICh7XG5cdFx0XHRcdGRhdGE6IFtdLFxuXHRcdFx0XHR1c2FnZTogeyBwcm9tcHRfdG9rZW5zOiAwLCB0b3RhbF90b2tlbnM6IDAgfSxcblx0XHRcdFx0bW9kZWw6IFwidGV4dC1lbWJlZGRpbmctYWRhLTAwMlwiLCAvLyBEZWZhdWx0IG1vZGVsIHRvIG1haW50YWluIG91dHB1dCBjb25zaXN0ZW5jeVxuXHRcdFx0fSkpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGVtYmVkZGluZ3M6IEVtYmVkZGluZ1Jlc3BvbnNlW10gPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgdGltZVNpbmNlTGFzdFJlcXVlc3QgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0UmVxdWVzdFRpbWU7XG5cdFx0XHRcdGlmICh0aW1lU2luY2VMYXN0UmVxdWVzdCA8IHRoaXMucmF0ZUxpbWl0RGVsYXkpIHtcblx0XHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KHJlc29sdmUsIHRoaXMucmF0ZUxpbWl0RGVsYXkgLSB0aW1lU2luY2VMYXN0UmVxdWVzdClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRXhwbGljaXRseSBzZXQgdGhlIG1vZGVsIHRvIGB0ZXh0LWVtYmVkZGluZy1hZGEtMDAyYFxuXHRcdFx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LmVtYmVkZGluZ3MuY3JlYXRlKHtcblx0XHRcdFx0XHRtb2RlbDogXCJ0ZXh0LWVtYmVkZGluZy1hZGEtMDAyXCIsIC8vIFVzZSB0aGUgY29ycmVjdCBtb2RlbFxuXHRcdFx0XHRcdGlucHV0OiBjaHVua3NbaV0sXG5cdFx0XHRcdFx0ZW5jb2RpbmdfZm9ybWF0OiBcImZsb2F0XCIsXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRoaXMubGFzdFJlcXVlc3RUaW1lID0gRGF0ZS5ub3coKTtcblxuXHRcdFx0XHRlbWJlZGRpbmdzLnB1c2goe1xuXHRcdFx0XHRcdGRhdGE6IFtcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0ZW1iZWRkaW5nOiByZXNwb25zZS5kYXRhWzBdLmVtYmVkZGluZyxcblx0XHRcdFx0XHRcdFx0aW5kZXg6IGksXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0dXNhZ2U6IHtcblx0XHRcdFx0XHRcdHByb21wdF90b2tlbnM6IHJlc3BvbnNlLnVzYWdlLnByb21wdF90b2tlbnMsXG5cdFx0XHRcdFx0XHR0b3RhbF90b2tlbnM6IHJlc3BvbnNlLnVzYWdlLnRvdGFsX3Rva2Vucyxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG1vZGVsOiByZXNwb25zZS5tb2RlbCxcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHR0aGlzLmhhbmRsZUVtYmVkZGluZ0Vycm9yKGVycm9yLCBjaHVua3NbaV0pO1xuXHRcdFx0XHRlbWJlZGRpbmdzLnB1c2goe1xuXHRcdFx0XHRcdGRhdGE6IFtdLFxuXHRcdFx0XHRcdHVzYWdlOiB7IHByb21wdF90b2tlbnM6IDAsIHRvdGFsX3Rva2VuczogMCB9LFxuXHRcdFx0XHRcdG1vZGVsOiBcInRleHQtZW1iZWRkaW5nLWFkYS0wMDJcIixcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVtYmVkZGluZ3M7XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyB2YXJpb3VzIHR5cGVzIG9mIE9wZW5BSSBBUEkgZXJyb3JzXG5cdCAqL1xuXHRwcml2YXRlIGhhbmRsZUVtYmVkZGluZ0Vycm9yKGVycm9yOiBhbnksIGNodW5rOiBzdHJpbmcpOiB2b2lkIHtcblx0XHRsZXQgZXJyb3JNZXNzYWdlOiBzdHJpbmc7XG5cblx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBPcGVuQUkuQVBJRXJyb3IpIHtcblx0XHRcdHN3aXRjaCAoZXJyb3Iuc3RhdHVzKSB7XG5cdFx0XHRcdGNhc2UgNDI5OlxuXHRcdFx0XHRcdGVycm9yTWVzc2FnZSA9ICdSYXRlIGxpbWl0IGV4Y2VlZGVkLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgNDAxOlxuXHRcdFx0XHRcdGVycm9yTWVzc2FnZSA9ICdJbnZhbGlkIEFQSSBrZXkuIFBsZWFzZSBjaGVjayB5b3VyIHNldHRpbmdzLic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgNDEzOlxuXHRcdFx0XHRcdGVycm9yTWVzc2FnZSA9ICdUZXh0IGNodW5rIHRvbyBsYXJnZSBmb3IgZW1iZWRkaW5nLic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0ZXJyb3JNZXNzYWdlID0gYE9wZW5BSSBBUEkgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRlcnJvck1lc3NhZ2UgPSBgVW5leHBlY3RlZCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWA7XG5cdFx0fVxuXG5cdFx0Ly8gTG9nIHRoZSBlcnJvciB0aHJvdWdoIHRoZSBjZW50cmFsaXplZCBlcnJvciBoYW5kbGVyXG5cdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdGNvbnRleHQ6ICdPcGVuQUlTZXJ2aWNlLmNyZWF0ZUVtYmVkZGluZ3MnLFxuXHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0Y2h1bmtQcmV2aWV3OiBjaHVuay5zdWJzdHJpbmcoMCwgMTAwKSArICcuLi4nIC8vIEZpcnN0IDEwMCBjaGFycyBmb3IgY29udGV4dFxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0bmV3IE5vdGljZShgRXJyb3IgY3JlYXRpbmcgZW1iZWRkaW5nOiAke2Vycm9yTWVzc2FnZX1gKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHNlcnZpY2Ugc2V0dGluZ3Ncblx0ICovXG5cdHVwZGF0ZVNldHRpbmdzKHNldHRpbmdzOiBPcGVuQUlTZXR0aW5ncyk6IHZvaWQge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcblxuXHRcdGlmICghc2V0dGluZ3MuYXBpS2V5KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ09wZW5BSSBBUEkga2V5IGlzIG1pc3NpbmcuIE9wZW5BSVNlcnZpY2Ugd2lsbCBub3QgYmUgaW5pdGlhbGl6ZWQuJyk7XG5cdFx0XHR0aGlzLmNsaWVudCA9IG51bGw7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVpbml0aWFsaXplIHRoZSBPcGVuQUkgY2xpZW50IHdpdGggdXBkYXRlZCBzZXR0aW5nc1xuXHRcdHRoaXMuY2xpZW50ID0gbmV3IE9wZW5BSSh7XG5cdFx0XHRhcGlLZXk6IHNldHRpbmdzLmFwaUtleSxcblx0XHRcdGRhbmdlcm91c2x5QWxsb3dCcm93c2VyOiB0cnVlLCAvLyBFbnN1cmUgdGhpcyByZW1haW5zIGVuYWJsZWRcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHJhdGUgbGltaXRpbmcgcGFyYW1ldGVyc1xuXHQgKi9cblx0dXBkYXRlUmF0ZUxpbWl0KGRlbGF5TXM6IG51bWJlcik6IHZvaWQge1xuXHRcdHRoaXMucmF0ZUxpbWl0RGVsYXkgPSBkZWxheU1zO1xuXHR9XG59XG4iLCAiLy8gc3JjL3NlcnZpY2VzL1F1ZXVlU2VydmljZS50c1xuaW1wb3J0IHsgVmF1bHQsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgVGV4dFNwbGl0dGVyIH0gZnJvbSAnLi4vdXRpbHMvVGV4dFNwbGl0dGVyJztcbmltcG9ydCB7IFByb2Nlc3NpbmdUYXNrLCBUYXNrU3RhdHVzLCBUYXNrVHlwZSwgUXVldWVTdGF0cywgVGFza1Byb2dyZXNzLCBUYXNrUHJvY2Vzc2luZ0Vycm9yIH0gZnJvbSAnLi4vbW9kZWxzL1Byb2Nlc3NpbmdUYXNrJztcbmltcG9ydCB7IEVycm9ySGFuZGxlciB9IGZyb20gJy4uL3V0aWxzL0Vycm9ySGFuZGxlcic7XG5pbXBvcnQgeyBOb3RpZmljYXRpb25NYW5hZ2VyIH0gZnJvbSAnLi4vdXRpbHMvTm90aWZpY2F0aW9uTWFuYWdlcic7XG5pbXBvcnQgeyBTdXBhYmFzZVNlcnZpY2UgfSBmcm9tICcuL1N1cGFiYXNlU2VydmljZSc7XG5pbXBvcnQgeyBPcGVuQUlTZXJ2aWNlIH0gZnJvbSAnLi9PcGVuQUlTZXJ2aWNlJztcbmltcG9ydCB7IERFRkFVTFRfQ0hVTktJTkdfT1BUSU9OUyB9IGZyb20gJy4uL3NldHRpbmdzL1NldHRpbmdzJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4vRXZlbnRFbWl0dGVyJztcblxuZXhwb3J0IGNsYXNzIFF1ZXVlU2VydmljZSB7XG5cdHByaXZhdGUgcXVldWU6IFByb2Nlc3NpbmdUYXNrW10gPSBbXTtcblx0cHJpdmF0ZSBwcm9jZXNzaW5nUXVldWU6IFByb2Nlc3NpbmdUYXNrW10gPSBbXTtcblx0cHJpdmF0ZSBpc1Byb2Nlc3Npbmc6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHJpdmF0ZSBpc1N0b3BwZWQ6IGJvb2xlYW4gPSB0cnVlO1xuXHRwcml2YXRlIHByb2Nlc3NpbmdJbnRlcnZhbDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSB0ZXh0U3BsaXR0ZXI6IFRleHRTcGxpdHRlcjtcblx0cHJpdmF0ZSB2YXVsdDogVmF1bHQ7XG5cdC8vIEV2ZW50IGVtaXR0ZXIgZm9yIHF1ZXVlIGV2ZW50cy5cblx0cHJpdmF0ZSBldmVudEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjtcblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRwcml2YXRlIG1heENvbmN1cnJlbnQ6IG51bWJlcixcblx0XHRwcml2YXRlIG1heFJldHJpZXM6IG51bWJlcixcblx0XHRwcml2YXRlIHN1cGFiYXNlU2VydmljZTogU3VwYWJhc2VTZXJ2aWNlIHwgbnVsbCxcblx0XHRwcml2YXRlIG9wZW5BSVNlcnZpY2U6IE9wZW5BSVNlcnZpY2UgfCBudWxsLFxuXHRcdHByaXZhdGUgZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXIsXG5cdFx0cHJpdmF0ZSBub3RpZmljYXRpb25NYW5hZ2VyOiBOb3RpZmljYXRpb25NYW5hZ2VyLFxuXHRcdHZhdWx0OiBWYXVsdCxcblx0XHRjaHVua1NldHRpbmdzPzogeyBjaHVua1NpemU6IG51bWJlcjsgY2h1bmtPdmVybGFwOiBudW1iZXI7IG1pbkNodW5rU2l6ZTogbnVtYmVyIH1cblx0KSB7XG5cdFx0dGhpcy52YXVsdCA9IHZhdWx0O1xuXHRcdGNvbnN0IHZhbGlkYXRlZENodW5rU2V0dGluZ3MgPSBjaHVua1NldHRpbmdzIHx8IHsgLi4uREVGQVVMVF9DSFVOS0lOR19PUFRJT05TIH07XG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMudGV4dFNwbGl0dGVyID0gbmV3IFRleHRTcGxpdHRlcih2YWxpZGF0ZWRDaHVua1NldHRpbmdzKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ1F1ZXVlU2VydmljZS5jb25zdHJ1Y3RvcicsXG5cdFx0XHRcdG1ldGFkYXRhOiB2YWxpZGF0ZWRDaHVua1NldHRpbmdzLFxuXHRcdFx0fSk7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFRleHRTcGxpdHRlciB3aXRoIHByb3ZpZGVkIHNldHRpbmdzLicpO1xuXHRcdH1cblx0XHR0aGlzLmV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblx0fVxuXG5cdHB1YmxpYyBzdGFydCgpOiB2b2lkIHtcblx0XHRpZiAoIXRoaXMuaXNTdG9wcGVkKSByZXR1cm47XG5cdFx0dGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcblx0XHR0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuXHRcdHRoaXMucHJvY2Vzc2luZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuXHRcdFx0aWYgKCF0aGlzLmlzUHJvY2Vzc2luZykge1xuXHRcdFx0XHR0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuXHRcdFx0fVxuXHRcdH0sIDEwMDApO1xuXHRcdC8vIEVtaXQgZXZlbnQgZm9yIHF1ZXVlIHN0YXJ0ZWQuXG5cdFx0dGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgncXVldWUtc3RhdHVzJywge1xuXHRcdFx0cXVldWVTaXplOiB0aGlzLnF1ZXVlLmxlbmd0aCxcblx0XHRcdHBlbmRpbmdDaGFuZ2VzOiAwLFxuXHRcdFx0cHJvY2Vzc2luZ0NvdW50OiB0aGlzLnByb2Nlc3NpbmdRdWV1ZS5sZW5ndGgsXG5cdFx0XHRzdGF0dXM6ICdwcm9jZXNzaW5nJ1xuXHRcdH0pO1xuXHR9XG5cblx0cHVibGljIHN0b3AoKTogdm9pZCB7XG5cdFx0dGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuXHRcdGlmICh0aGlzLnByb2Nlc3NpbmdJbnRlcnZhbCkge1xuXHRcdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLnByb2Nlc3NpbmdJbnRlcnZhbCk7XG5cdFx0XHR0aGlzLnByb2Nlc3NpbmdJbnRlcnZhbCA9IG51bGw7XG5cdFx0fVxuXHRcdC8vIEVtaXQgZXZlbnQgZm9yIHF1ZXVlIHN0b3BwZWQuXG5cdFx0dGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgncXVldWUtc3RhdHVzJywge1xuXHRcdFx0cXVldWVTaXplOiB0aGlzLnF1ZXVlLmxlbmd0aCxcblx0XHRcdHBlbmRpbmdDaGFuZ2VzOiAwLFxuXHRcdFx0cHJvY2Vzc2luZ0NvdW50OiB0aGlzLnByb2Nlc3NpbmdRdWV1ZS5sZW5ndGgsXG5cdFx0XHRzdGF0dXM6ICdwYXVzZWQnXG5cdFx0fSk7XG5cdH1cblxuXHRhc3luYyBhZGRUYXNrKHRhc2s6IFByb2Nlc3NpbmdUYXNrKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKHRoaXMucXVldWUubGVuZ3RoID49IDEwMDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihUYXNrUHJvY2Vzc2luZ0Vycm9yLlFVRVVFX0ZVTEwpO1xuXHRcdH1cblx0XHRjb25zb2xlLmxvZygnQWRkaW5nIHRhc2sgdG8gcXVldWU6Jywge1xuXHRcdFx0aWQ6IHRhc2suaWQsXG5cdFx0XHR0eXBlOiB0YXNrLnR5cGUsXG5cdFx0XHRwcmlvcml0eTogdGFzay5wcmlvcml0eSxcblx0XHR9KTtcblx0XHRpZiAodGFzay5wcmlvcml0eSA+IDEpIHtcblx0XHRcdHRoaXMucXVldWUudW5zaGlmdCh0YXNrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5xdWV1ZS5wdXNoKHRhc2spO1xuXHRcdH1cblx0XHQvLyBFbWl0IGV2ZW50IGZvciBuZXcgdGFzayBhZGRlZC5cblx0XHR0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdxdWV1ZS1wcm9ncmVzcycsIHtcblx0XHRcdHByb2Nlc3NlZDogMCxcblx0XHRcdHRvdGFsOiB0aGlzLnF1ZXVlLmxlbmd0aCxcblx0XHRcdGN1cnJlbnRUYXNrOiB0YXNrLmlkXG5cdFx0fSk7XG5cdFx0aWYgKCF0aGlzLmlzUHJvY2Vzc2luZyAmJiAhdGhpcy5pc1N0b3BwZWQpIHtcblx0XHRcdHRoaXMucHJvY2Vzc1F1ZXVlKCk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBwcm9jZXNzUXVldWUoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKHRoaXMuaXNQcm9jZXNzaW5nIHx8IHRoaXMuaXNTdG9wcGVkIHx8IHRoaXMucXVldWUubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcblx0XHR0cnkge1xuXHRcdFx0d2hpbGUgKHRoaXMucXVldWUubGVuZ3RoID4gMCAmJiB0aGlzLnByb2Nlc3NpbmdRdWV1ZS5sZW5ndGggPCB0aGlzLm1heENvbmN1cnJlbnQpIHtcblx0XHRcdFx0Y29uc3QgdGFzayA9IHRoaXMucXVldWUuc2hpZnQoKTtcblx0XHRcdFx0aWYgKHRhc2spIHtcblx0XHRcdFx0XHR0aGlzLnByb2Nlc3NpbmdRdWV1ZS5wdXNoKHRhc2spO1xuXHRcdFx0XHRcdHRoaXMucHJvY2Vzc1Rhc2sodGFzaykuY2F0Y2goKGVycm9yKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLmhhbmRsZVRhc2tFcnJvcih0YXNrLCBlcnJvcik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1F1ZXVlU2VydmljZS5wcm9jZXNzUXVldWUnIH0pO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc1Rhc2sodGFzazogUHJvY2Vzc2luZ1Rhc2spOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zb2xlLmxvZygnUHJvY2Vzc2luZyB0YXNrOicsIHtcblx0XHRcdGlkOiB0YXNrLmlkLFxuXHRcdFx0dHlwZTogdGFzay50eXBlLFxuXHRcdFx0c3RhdHVzOiB0YXNrLnN0YXR1cyxcblx0XHR9KTtcblx0XHR0cnkge1xuXHRcdFx0dGFzay5zdGF0dXMgPSBUYXNrU3RhdHVzLlBST0NFU1NJTkc7XG5cdFx0XHR0YXNrLnN0YXJ0ZWRBdCA9IERhdGUubm93KCk7XG5cdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDAsIGBTdGFydGluZyAke3Rhc2sudHlwZS50b0xvd2VyQ2FzZSgpfWApO1xuXHRcdFx0c3dpdGNoICh0YXNrLnR5cGUpIHtcblx0XHRcdFx0Y2FzZSBUYXNrVHlwZS5DUkVBVEU6XG5cdFx0XHRcdGNhc2UgVGFza1R5cGUuVVBEQVRFOlxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucHJvY2Vzc0NyZWF0ZVVwZGF0ZVRhc2sodGFzayk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgVGFza1R5cGUuREVMRVRFOlxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucHJvY2Vzc0RlbGV0ZVRhc2sodGFzayk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0YXNrIHR5cGU6ICR7dGFzay50eXBlfWApO1xuXHRcdFx0fVxuXHRcdFx0dGFzay5zdGF0dXMgPSBUYXNrU3RhdHVzLkNPTVBMRVRFRDtcblx0XHRcdHRhc2suY29tcGxldGVkQXQgPSBEYXRlLm5vdygpO1xuXHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCAxMDAsICdUYXNrIGNvbXBsZXRlZCcpO1xuXHRcdFx0Y29uc29sZS5sb2coJ1Rhc2sgY29tcGxldGVkIHN1Y2Nlc3NmdWxseTonLCB0YXNrLmlkKTtcblx0XHRcdC8vIEVtaXQgZXZlbnQgZm9yIHRhc2sgY29tcGxldGlvbi5cblx0XHRcdHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3F1ZXVlLXByb2dyZXNzJywge1xuXHRcdFx0XHRwcm9jZXNzZWQ6IDEsXG5cdFx0XHRcdHRvdGFsOiB0aGlzLnF1ZXVlLmxlbmd0aCArIDEsXG5cdFx0XHRcdGN1cnJlbnRUYXNrOiB0YXNrLmlkXG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgcHJvY2Vzc2luZyB0YXNrOicsIHtcblx0XHRcdFx0dGFza0lkOiB0YXNrLmlkLFxuXHRcdFx0XHRlcnJvcjogZXJyb3IsXG5cdFx0XHR9KTtcblx0XHRcdGF3YWl0IHRoaXMuaGFuZGxlVGFza0Vycm9yKHRhc2ssIGVycm9yKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dGhpcy5yZW1vdmVGcm9tUHJvY2Vzc2luZ1F1ZXVlKHRhc2spO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc0NyZWF0ZVVwZGF0ZVRhc2sodGFzazogUHJvY2Vzc2luZ1Rhc2spOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuc3VwYWJhc2VTZXJ2aWNlIHx8ICF0aGlzLm9wZW5BSVNlcnZpY2UpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgc2VydmljZXMgbm90IGluaXRpYWxpemVkJyk7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRjb25zb2xlLmxvZygnUmVhZGluZyBmaWxlOicsIHRhc2suaWQpO1xuXHRcdFx0Y29uc3QgZmlsZSA9IHRoaXMudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRhc2suaWQpO1xuXHRcdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZpbGUgbm90IGZvdW5kIG9yIG5vdCBhIFRGaWxlOiAke3Rhc2suaWR9YCk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkKGZpbGUpO1xuXHRcdFx0Y29uc29sZS5sb2coJ0ZpbGUgY29udGVudCByZWFkIHN1Y2Nlc3NmdWxseTonLCB7XG5cdFx0XHRcdGZpbGVJZDogdGFzay5pZCxcblx0XHRcdFx0Y29udGVudExlbmd0aDogY29udGVudC5sZW5ndGgsXG5cdFx0XHRcdGNvbnRlbnRQcmV2aWV3OiBjb250ZW50LnN1YnN0cmluZygwLCAxMDApLFxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDIwLCAnU3BsaXR0aW5nIGNvbnRlbnQnKTtcblx0XHRcdGNvbnN0IGNodW5rcyA9IGF3YWl0IHRoaXMudGV4dFNwbGl0dGVyLnNwbGl0RG9jdW1lbnQoY29udGVudCwgdGFzay5tZXRhZGF0YSk7XG5cdFx0XHRpZiAoIWNodW5rcyB8fCAhQXJyYXkuaXNBcnJheShjaHVua3MpIHx8IGNodW5rcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ05vIHZhbGlkIGNodW5rcyBjcmVhdGVkIGZvciBmaWxlOicsIHtcblx0XHRcdFx0XHRmaWxlSWQ6IHRhc2suaWQsXG5cdFx0XHRcdFx0Y29udGVudExlbmd0aDogY29udGVudC5sZW5ndGgsXG5cdFx0XHRcdFx0c2V0dGluZ3M6IHRoaXMudGV4dFNwbGl0dGVyLmdldFNldHRpbmdzKCksXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjb25zb2xlLmxvZygnQ29udGVudCBzcGxpdCBpbnRvIGNodW5rczonLCB7XG5cdFx0XHRcdG51bWJlck9mQ2h1bmtzOiBjaHVua3MubGVuZ3RoLFxuXHRcdFx0XHRjaHVua1NpemVzOiBjaHVua3MubWFwKGMgPT4gYy5jb250ZW50Lmxlbmd0aCksXG5cdFx0XHRcdGZpcnN0Q2h1bmtQcmV2aWV3OiBjaHVua3NbMF0/LmNvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMCksXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMubm90aWZ5UHJvZ3Jlc3ModGFzay5pZCwgNDAsICdHZW5lcmF0aW5nIGVtYmVkZGluZ3MnKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5vcGVuQUlTZXJ2aWNlLmNyZWF0ZUVtYmVkZGluZ3MoW2NodW5rc1tpXS5jb250ZW50XSk7XG5cdFx0XHRcdGlmIChyZXNwb25zZS5sZW5ndGggPiAwICYmIHJlc3BvbnNlWzBdLmRhdGEubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdGNodW5rc1tpXS5lbWJlZGRpbmcgPSByZXNwb25zZVswXS5kYXRhWzBdLmVtYmVkZGluZztcblx0XHRcdFx0XHRjaHVua3NbaV0udmVjdG9yaXplZF9hdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhgR2VuZXJhdGVkIGVtYmVkZGluZyBmb3IgY2h1bmsgJHtpICsgMX0vJHtjaHVua3MubGVuZ3RofWApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdlbmVyYXRlIGVtYmVkZGluZyBmb3IgY2h1bmsgJHtpICsgMX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDQwICsgTWF0aC5mbG9vcigoaSAvIGNodW5rcy5sZW5ndGgpICogMzApLCBgUHJvY2Vzc2VkICR7aSArIDF9IG9mICR7Y2h1bmtzLmxlbmd0aH0gY2h1bmtzYCk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBlbmhhbmNlZENodW5rcyA9IGNodW5rcy5tYXAoY2h1bmsgPT4gKHtcblx0XHRcdFx0Li4uY2h1bmssXG5cdFx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdFx0Li4uY2h1bmsubWV0YWRhdGEsXG5cdFx0XHRcdFx0YWxpYXNlczogY2h1bmsubWV0YWRhdGEuYWxpYXNlcyB8fCBbXSxcblx0XHRcdFx0XHRsaW5rczogY2h1bmsubWV0YWRhdGEubGlua3MgfHwgW10sXG5cdFx0XHRcdFx0dGFnczogY2h1bmsubWV0YWRhdGEudGFncyB8fCBbXSxcblx0XHRcdFx0fSxcblx0XHRcdH0pKTtcblx0XHRcdHRoaXMubm90aWZ5UHJvZ3Jlc3ModGFzay5pZCwgNzAsICdTYXZpbmcgdG8gZGF0YWJhc2UnKTtcblx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLnVwc2VydENodW5rcyhlbmhhbmNlZENodW5rcyk7XG5cdFx0XHRjb25zb2xlLmxvZygnQ2h1bmtzIHNhdmVkIHRvIGRhdGFiYXNlOicsIHtcblx0XHRcdFx0bnVtYmVyT2ZDaHVua3M6IGVuaGFuY2VkQ2h1bmtzLmxlbmd0aCxcblx0XHRcdFx0ZmlsZUlkOiB0YXNrLmlkLFxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDEwMCwgJ1Byb2Nlc3NpbmcgY29tcGxldGVkJyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHByb2Nlc3NDcmVhdGVVcGRhdGVUYXNrOicsIHtcblx0XHRcdFx0ZXJyb3IsXG5cdFx0XHRcdHRhc2tJZDogdGFzay5pZCxcblx0XHRcdFx0bWV0YWRhdGE6IHRhc2subWV0YWRhdGEsXG5cdFx0XHR9KTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc0RlbGV0ZVRhc2sodGFzazogUHJvY2Vzc2luZ1Rhc2spOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuc3VwYWJhc2VTZXJ2aWNlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1N1cGFiYXNlIHNlcnZpY2Ugbm90IGluaXRpYWxpemVkJyk7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDUwLCAnRGVsZXRpbmcgZnJvbSBkYXRhYmFzZScpO1xuXHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UuZGVsZXRlRG9jdW1lbnRDaHVua3ModGFzay5tZXRhZGF0YS5vYnNpZGlhbklkKTtcblx0XHRcdHRoaXMubm90aWZ5UHJvZ3Jlc3ModGFzay5pZCwgMTAwLCAnRGVsZXRlIGNvbXBsZXRlZCcpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBpbiBwcm9jZXNzRGVsZXRlVGFzazonLCB7XG5cdFx0XHRcdGVycm9yLFxuXHRcdFx0XHR0YXNrSWQ6IHRhc2suaWQsXG5cdFx0XHRcdG1ldGFkYXRhOiB0YXNrLm1ldGFkYXRhLFxuXHRcdFx0fSk7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGhhbmRsZVRhc2tFcnJvcih0YXNrOiBQcm9jZXNzaW5nVGFzaywgZXJyb3I6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRhc2sucmV0cnlDb3VudCA9ICh0YXNrLnJldHJ5Q291bnQgfHwgMCkgKyAxO1xuXHRcdHRhc2sudXBkYXRlZEF0ID0gRGF0ZS5ub3coKTtcblx0XHRpZiAodGFzay5yZXRyeUNvdW50IDwgdGhpcy5tYXhSZXRyaWVzKSB7XG5cdFx0XHR0YXNrLnN0YXR1cyA9IFRhc2tTdGF0dXMuUkVUUllJTkc7XG5cdFx0XHR0aGlzLnF1ZXVlLnVuc2hpZnQodGFzayk7XG5cdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDAsIGBSZXRyeSBhdHRlbXB0ICR7dGFzay5yZXRyeUNvdW50fWApO1xuXHRcdFx0Y29uc29sZS5sb2coJ1Rhc2sgcXVldWVkIGZvciByZXRyeTonLCB7XG5cdFx0XHRcdHRhc2tJZDogdGFzay5pZCxcblx0XHRcdFx0cmV0cnlDb3VudDogdGFzay5yZXRyeUNvdW50LFxuXHRcdFx0XHRtYXhSZXRyaWVzOiB0aGlzLm1heFJldHJpZXMsXG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFzay5zdGF0dXMgPSBUYXNrU3RhdHVzLkZBSUxFRDtcblx0XHRcdHRhc2suZXJyb3IgPSB7XG5cdFx0XHRcdG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG5cdFx0XHRcdGNvZGU6IGVycm9yLmNvZGUgfHwgJ1VOS05PV05fRVJST1InLFxuXHRcdFx0XHRzdGFjazogZXJyb3Iuc3RhY2ssXG5cdFx0XHR9O1xuXHRcdFx0dGFzay5jb21wbGV0ZWRBdCA9IERhdGUubm93KCk7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdUYXNrIGZhaWxlZCBhZnRlciBtYXggcmV0cmllczonLCB7XG5cdFx0XHRcdHRhc2tJZDogdGFzay5pZCxcblx0XHRcdFx0ZXJyb3I6IHRhc2suZXJyb3IsXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdGNvbnRleHQ6ICdRdWV1ZVNlcnZpY2UucHJvY2Vzc1Rhc2snLFxuXHRcdFx0dGFza0lkOiB0YXNrLmlkLFxuXHRcdFx0dGFza1R5cGU6IHRhc2sudHlwZSxcblx0XHR9KTtcblx0XHQvLyBFbWl0IGV2ZW50IGZvciBlcnJvciBvY2N1cnJlbmNlLlxuXHRcdHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3F1ZXVlLXByb2dyZXNzJywge1xuXHRcdFx0cHJvY2Vzc2VkOiAwLFxuXHRcdFx0dG90YWw6IHRoaXMucXVldWUubGVuZ3RoLFxuXHRcdFx0Y3VycmVudFRhc2s6IHRhc2suaWRcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgcmVtb3ZlRnJvbVByb2Nlc3NpbmdRdWV1ZSh0YXNrOiBQcm9jZXNzaW5nVGFzayk6IHZvaWQge1xuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5wcm9jZXNzaW5nUXVldWUuZmluZEluZGV4KHQgPT4gdC5pZCA9PT0gdGFzay5pZCk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0dGhpcy5wcm9jZXNzaW5nUXVldWUuc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIG5vdGlmeVByb2dyZXNzKHRhc2tJZDogc3RyaW5nLCBwcm9ncmVzczogbnVtYmVyLCBtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcblx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIudXBkYXRlUHJvZ3Jlc3Moe1xuXHRcdFx0dGFza0lkLFxuXHRcdFx0cHJvZ3Jlc3MsXG5cdFx0XHRjdXJyZW50U3RlcDogbWVzc2FnZSxcblx0XHRcdHRvdGFsU3RlcHM6IDEsXG5cdFx0XHRjdXJyZW50U3RlcE51bWJlcjogMSxcblx0XHR9KTtcblx0XHQvLyBFbWl0IHByb2dyZXNzIHVwZGF0ZSBldmVudC5cblx0XHR0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdxdWV1ZS1wcm9ncmVzcycsIHtcblx0XHRcdHByb2Nlc3NlZDogcHJvZ3Jlc3MsXG5cdFx0XHR0b3RhbDogMTAwLFxuXHRcdFx0Y3VycmVudFRhc2s6IHRhc2tJZFxuXHRcdH0pO1xuXHR9XG5cblx0cHVibGljIGdldFF1ZXVlU3RhdHMoKTogUXVldWVTdGF0cyB7XG5cdFx0Y29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblx0XHRjb25zdCBvbmVIb3VyID0gNjAgKiA2MCAqIDEwMDA7XG5cdFx0Y29uc3QgdGFza3NCeVN0YXR1cyA9IHRoaXMucXVldWUucmVkdWNlKChhY2MsIHRhc2spID0+IHtcblx0XHRcdGFjY1t0YXNrLnN0YXR1c10gPSAoYWNjW3Rhc2suc3RhdHVzXSB8fCAwKSArIDE7XG5cdFx0XHRyZXR1cm4gYWNjO1xuXHRcdH0sIHt9IGFzIFJlY29yZDxUYXNrU3RhdHVzLCBudW1iZXI+KTtcblx0XHRjb25zdCB0YXNrc0J5VHlwZSA9IHRoaXMucXVldWUucmVkdWNlKChhY2MsIHRhc2spID0+IHtcblx0XHRcdGFjY1t0YXNrLnR5cGVdID0gKGFjY1t0YXNrLnR5cGVdIHx8IDApICsgMTtcblx0XHRcdHJldHVybiBhY2M7XG5cdFx0fSwge30gYXMgUmVjb3JkPFRhc2tUeXBlLCBudW1iZXI+KTtcblx0XHRjb25zdCBjb21wbGV0ZWRUYXNrcyA9IHRoaXMucXVldWUuZmlsdGVyKFxuXHRcdFx0dGFzayA9PiB0YXNrLnN0YXR1cyA9PT0gVGFza1N0YXR1cy5DT01QTEVURUQgJiYgdGFzay5jb21wbGV0ZWRBdFxuXHRcdCk7XG5cdFx0Y29uc3QgYXZlcmFnZVRpbWUgPSBjb21wbGV0ZWRUYXNrcy5sZW5ndGggPiAwXG5cdFx0XHQ/IGNvbXBsZXRlZFRhc2tzLnJlZHVjZSgoc3VtLCB0YXNrKSA9PiBzdW0gKyAodGFzay5jb21wbGV0ZWRBdCEgLSB0YXNrLnN0YXJ0ZWRBdCEpLCAwKSAvIGNvbXBsZXRlZFRhc2tzLmxlbmd0aFxuXHRcdFx0OiAwO1xuXHRcdGNvbnN0IHRhc2tzTGFzdEhvdXIgPSBjb21wbGV0ZWRUYXNrcy5maWx0ZXIoXG5cdFx0XHR0YXNrID0+IHRhc2suY29tcGxldGVkQXQhID4gbm93IC0gb25lSG91clxuXHRcdCkubGVuZ3RoO1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3RhbFRhc2tzOiB0aGlzLnF1ZXVlLmxlbmd0aCxcblx0XHRcdHRhc2tzQnlTdGF0dXMsXG5cdFx0XHR0YXNrc0J5VHlwZSxcblx0XHRcdGF2ZXJhZ2VQcm9jZXNzaW5nVGltZTogYXZlcmFnZVRpbWUsXG5cdFx0XHRmYWlsZWRUYXNrczogdGFza3NCeVN0YXR1c1tUYXNrU3RhdHVzLkZBSUxFRF0gfHwgMCxcblx0XHRcdHJldHJ5aW5nVGFza3M6IHRhc2tzQnlTdGF0dXNbVGFza1N0YXR1cy5SRVRSWUlOR10gfHwgMCxcblx0XHRcdHRhc2tzTGFzdEhvdXIsXG5cdFx0fTtcblx0fVxuXG5cdHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcblx0XHR0aGlzLnF1ZXVlID0gW107XG5cdFx0dGhpcy5wcm9jZXNzaW5nUXVldWUgPSBbXTtcblx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIuY2xlYXIoKTtcblx0fVxuXG5cdHB1YmxpYyB1cGRhdGVTZXR0aW5ncyhzZXR0aW5nczogeyBtYXhDb25jdXJyZW50OiBudW1iZXI7IG1heFJldHJpZXM6IG51bWJlcjsgY2h1bmtTZXR0aW5ncz86IHsgY2h1bmtTaXplOiBudW1iZXI7IGNodW5rT3ZlcmxhcDogbnVtYmVyOyBtaW5DaHVua1NpemU6IG51bWJlciB9IH0pOiB2b2lkIHtcblx0XHR0aGlzLm1heENvbmN1cnJlbnQgPSBzZXR0aW5ncy5tYXhDb25jdXJyZW50O1xuXHRcdHRoaXMubWF4UmV0cmllcyA9IHNldHRpbmdzLm1heFJldHJpZXM7XG5cdFx0aWYgKHNldHRpbmdzLmNodW5rU2V0dGluZ3MpIHtcblx0XHRcdHRoaXMudGV4dFNwbGl0dGVyID0gbmV3IFRleHRTcGxpdHRlcihzZXR0aW5ncy5jaHVua1NldHRpbmdzKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU3Vic2NyaWJlIHRvIHF1ZXVlIGV2ZW50cy5cblx0ICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gc3Vic2NyaWJlIHRvLlxuXHQgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0cHVibGljIG9uPFQgZXh0ZW5kcyBrZXlvZiBhbnk+KGV2ZW50TmFtZTogVCwgY2FsbGJhY2s6IChkYXRhOiBhbnkpID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcblx0XHRyZXR1cm4gdGhpcy5ldmVudEVtaXR0ZXIub24oZXZlbnROYW1lIGFzIGFueSwgY2FsbGJhY2spO1xuXHR9XG59XG4iLCAiLy8gc3JjL3NlcnZpY2VzL01ldGFkYXRhRXh0cmFjdG9yLnRzXG5pbXBvcnQgeyBURmlsZSwgcGFyc2VZYW1sIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgRG9jdW1lbnRNZXRhZGF0YSwgRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IgfSBmcm9tICcuLi9tb2RlbHMvRG9jdW1lbnRDaHVuayc7XG5cbmV4cG9ydCBjbGFzcyBNZXRhZGF0YUV4dHJhY3RvciB7XG5cdC8qKlxuXHQgKiBFeHRyYWN0cyBhbGwgbWV0YWRhdGEgZnJvbSBhbiBPYnNpZGlhbiBmaWxlXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgZXh0cmFjdE1ldGFkYXRhKGZpbGU6IFRGaWxlLCBjb250ZW50Pzogc3RyaW5nKTogUHJvbWlzZTxEb2N1bWVudE1ldGFkYXRhPiB7XG5cdFx0Y29uc3QgZmlsZUNvbnRlbnQgPSBjb250ZW50IHx8IGF3YWl0IGZpbGUudmF1bHQucmVhZChmaWxlKTtcblx0XHRjb25zdCBmcm9udE1hdHRlciA9IHRoaXMuZXh0cmFjdEZyb250TWF0dGVyKGZpbGVDb250ZW50KTtcblx0XHRjb25zdCBtZXRhZGF0YTogRG9jdW1lbnRNZXRhZGF0YSA9IHtcblx0XHRcdG9ic2lkaWFuSWQ6IGZpbGUucGF0aCxcblx0XHRcdHBhdGg6IGZpbGUucGF0aCxcblx0XHRcdGxhc3RNb2RpZmllZDogZmlsZS5zdGF0Lm10aW1lLFxuXHRcdFx0Y3JlYXRlZDogZmlsZS5zdGF0LmN0aW1lLFxuXHRcdFx0c2l6ZTogZmlsZS5zdGF0LnNpemUsXG5cdFx0XHRmcm9udE1hdHRlcjogZnJvbnRNYXR0ZXIsXG5cdFx0XHR0YWdzOiB0aGlzLmV4dHJhY3RUYWdzKGZpbGVDb250ZW50LCBmcm9udE1hdHRlciksXG5cdFx0XHRsaW5rczogdGhpcy5leHRyYWN0TGlua3MoZmlsZUNvbnRlbnQpLFxuXHRcdFx0Y3VzdG9tTWV0YWRhdGE6IHt9XG5cdFx0fTtcblxuXHRcdC8vIEV4dHJhY3Qgb3B0aW9uYWwgYWxpYXNlcyBmcm9tIGZyb250bWF0dGVyXG5cdFx0Y29uc3QgYWxpYXNlcyA9IHRoaXMuZXh0cmFjdEFsaWFzZXMoZnJvbnRNYXR0ZXIpO1xuXHRcdGlmIChhbGlhc2VzLmxlbmd0aCA+IDApIHtcblx0XHRcdG1ldGFkYXRhLmN1c3RvbU1ldGFkYXRhLmFsaWFzZXMgPSBhbGlhc2VzO1xuXHRcdH1cblxuXHRcdC8vIEV4dHJhY3Qgc291cmNlIGxvY2F0aW9uIGlmIGF2YWlsYWJsZVxuXHRcdGNvbnN0IGxvYyA9IHRoaXMuZXh0cmFjdFNvdXJjZUxvY2F0aW9uKGZyb250TWF0dGVyKTtcblx0XHRpZiAobG9jKSB7XG5cdFx0XHRtZXRhZGF0YS5sb2MgPSBsb2M7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIG90aGVyIG9wdGlvbmFsIGZyb250bWF0dGVyIGZpZWxkcyBpZiBwcmVzZW50XG5cdFx0aWYgKGZyb250TWF0dGVyPy5zb3VyY2UpIHtcblx0XHRcdG1ldGFkYXRhLnNvdXJjZSA9IGZyb250TWF0dGVyLnNvdXJjZTtcblx0XHR9XG5cdFx0aWYgKGZyb250TWF0dGVyPy5maWxlX2lkKSB7XG5cdFx0XHRtZXRhZGF0YS5maWxlX2lkID0gZnJvbnRNYXR0ZXIuZmlsZV9pZDtcblx0XHR9XG5cdFx0aWYgKGZyb250TWF0dGVyPy5ibG9iVHlwZSkge1xuXHRcdFx0bWV0YWRhdGEuYmxvYlR5cGUgPSBmcm9udE1hdHRlci5ibG9iVHlwZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWV0YWRhdGE7XG5cdH1cblxuXHQvKipcblx0ICogRXh0cmFjdHMgbWV0YWRhdGEgZnJvbSB0aGUgcHJvdmlkZWQgY29udGVudCBhbmQgbWVyZ2VzIGl0IHdpdGggdGhlIGdpdmVuIGJhc2UgbWV0YWRhdGEgYW5kIGZyb250IG1hdHRlci5cblx0ICogVGhpcyBuZXcgbWV0aG9kIGlzIHVzZWQgYnkgdGhlIFRleHRTcGxpdHRlciB0byBlbmhhbmNlIG1ldGFkYXRhIGJhc2VkIG9uIHBhcnNlZCBmcm9udCBtYXR0ZXIuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgZXh0cmFjdE1ldGFkYXRhRnJvbUNvbnRlbnQoXG5cdFx0Y29udGVudDogc3RyaW5nLFxuXHRcdGJhc2VNZXRhZGF0YTogRG9jdW1lbnRNZXRhZGF0YSxcblx0XHRmcm9udE1hdHRlcjogUmVjb3JkPHN0cmluZywgYW55PiB8IG51bGxcblx0KTogUHJvbWlzZTxEb2N1bWVudE1ldGFkYXRhPiB7XG5cdFx0Y29uc3QgbWVyZ2VkID0geyAuLi5iYXNlTWV0YWRhdGEgfTtcblx0XHRpZiAoZnJvbnRNYXR0ZXIpIHtcblx0XHRcdG1lcmdlZC5mcm9udE1hdHRlciA9IGZyb250TWF0dGVyO1xuXHRcdFx0Ly8gTWVyZ2UgdGFncyBmcm9tIGZyb250IG1hdHRlclxuXHRcdFx0aWYgKGZyb250TWF0dGVyLnRhZ3MpIHtcblx0XHRcdFx0bWVyZ2VkLnRhZ3MgPSBBcnJheS5pc0FycmF5KGZyb250TWF0dGVyLnRhZ3MpID8gZnJvbnRNYXR0ZXIudGFncyA6IFtmcm9udE1hdHRlci50YWdzXTtcblx0XHRcdH1cblx0XHRcdC8vIE1lcmdlIGFsaWFzZXMgaW50byBjdXN0b21NZXRhZGF0YVxuXHRcdFx0aWYgKGZyb250TWF0dGVyLmFsaWFzZXMpIHtcblx0XHRcdFx0bWVyZ2VkLmN1c3RvbU1ldGFkYXRhID0gbWVyZ2VkLmN1c3RvbU1ldGFkYXRhIHx8IHt9O1xuXHRcdFx0XHRtZXJnZWQuY3VzdG9tTWV0YWRhdGEuYWxpYXNlcyA9IEFycmF5LmlzQXJyYXkoZnJvbnRNYXR0ZXIuYWxpYXNlcylcblx0XHRcdFx0XHQ/IGZyb250TWF0dGVyLmFsaWFzZXNcblx0XHRcdFx0XHQ6IFtmcm9udE1hdHRlci5hbGlhc2VzXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1lcmdlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFeHRyYWN0cyBZQU1MIGZyb250IG1hdHRlciBmcm9tIGRvY3VtZW50IGNvbnRlbnRcblx0ICovXG5cdHByaXZhdGUgZXh0cmFjdEZyb250TWF0dGVyKGNvbnRlbnQ6IHN0cmluZyk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBmcm9udE1hdHRlck1hdGNoID0gY29udGVudC5tYXRjaCgvXi0tLVxcbihbXFxzXFxTXSo/KVxcbi0tLS8pO1xuXHRcdFx0aWYgKCFmcm9udE1hdHRlck1hdGNoKSByZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0Y29uc3QgeWFtbCA9IGZyb250TWF0dGVyTWF0Y2hbMV07XG5cdFx0XHRyZXR1cm4gcGFyc2VZYW1sKHlhbWwpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIGZyb250bWF0dGVyOicsIGVycm9yKTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgJHtEb2N1bWVudFByb2Nlc3NpbmdFcnJvci5ZQU1MX1BBUlNFX0VSUk9SfTogJHtlcnJvci5tZXNzYWdlfWApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFeHRyYWN0cyBpbnRlcm5hbCBsaW5rcyBmcm9tIGRvY3VtZW50IGNvbnRlbnQuXG5cdCAqL1xuXHRwcml2YXRlIGV4dHJhY3RMaW5rcyhjb250ZW50OiBzdHJpbmcpOiBzdHJpbmdbXSB7XG5cdFx0Y29uc3QgbGlua1JlZ2V4ID0gL1xcW1xcWyguKj8pKD86XFx8Lio/KT9cXF1cXF0vZztcblx0XHRjb25zdCBsaW5rcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXHRcdGxldCBtYXRjaDtcblx0XHR3aGlsZSAoKG1hdGNoID0gbGlua1JlZ2V4LmV4ZWMoY29udGVudCkpICE9PSBudWxsKSB7XG5cdFx0XHRjb25zdCBsaW5rID0gbWF0Y2hbMV0uc3BsaXQoJ3wnKVswXTtcblx0XHRcdGNvbnN0IGNsZWFuTGluayA9IHRoaXMuY2xlYW5MaW5rKGxpbmspO1xuXHRcdFx0aWYgKGNsZWFuTGluaykge1xuXHRcdFx0XHRsaW5rcy5hZGQoY2xlYW5MaW5rKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIEFycmF5LmZyb20obGlua3MpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFucyBhbmQgbm9ybWFsaXplcyBhIGxpbmsgcGF0aC5cblx0ICovXG5cdHByaXZhdGUgY2xlYW5MaW5rKGxpbms6IHN0cmluZyk6IHN0cmluZyB7XG5cdFx0bGV0IGNsZWFuTGluayA9IGxpbmsuc3BsaXQoJyMnKVswXTtcblx0XHRjbGVhbkxpbmsgPSBjbGVhbkxpbmsuc3BsaXQoJz8nKVswXTtcblx0XHRjbGVhbkxpbmsgPSBjbGVhbkxpbmsudHJpbSgpO1xuXHRcdHJldHVybiBjbGVhbkxpbms7XG5cdH1cblxuXHQvKipcblx0ICogRXh0cmFjdHMgdGFncyBmcm9tIGJvdGggY29udGVudCBhbmQgZnJvbnQgbWF0dGVyLlxuXHQgKi9cblx0cHJpdmF0ZSBleHRyYWN0VGFncyhjb250ZW50OiBzdHJpbmcsIGZyb250TWF0dGVyPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHN0cmluZ1tdIHtcblx0XHRjb25zdCB0YWdzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cdFx0Y29uc3QgdGFnUmVnZXggPSAvIyhbQS1aYS16MC05L18tXSspL2c7XG5cdFx0bGV0IG1hdGNoO1xuXHRcdHdoaWxlICgobWF0Y2ggPSB0YWdSZWdleC5leGVjKGNvbnRlbnQpKSAhPT0gbnVsbCkge1xuXHRcdFx0dGFncy5hZGQobWF0Y2hbMV0pO1xuXHRcdH1cblx0XHRpZiAoZnJvbnRNYXR0ZXI/LnRhZ3MpIHtcblx0XHRcdGNvbnN0IGZyb250TWF0dGVyVGFncyA9IEFycmF5LmlzQXJyYXkoZnJvbnRNYXR0ZXIudGFncylcblx0XHRcdFx0PyBmcm9udE1hdHRlci50YWdzXG5cdFx0XHRcdDogW2Zyb250TWF0dGVyLnRhZ3NdO1xuXHRcdFx0ZnJvbnRNYXR0ZXJUYWdzLmZvckVhY2godGFnID0+IHtcblx0XHRcdFx0aWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0Y29uc3QgY2xlYW5UYWcgPSB0YWcuc3RhcnRzV2l0aCgnIycpID8gdGFnLnNsaWNlKDEpIDogdGFnO1xuXHRcdFx0XHRcdHRhZ3MuYWRkKGNsZWFuVGFnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBBcnJheS5mcm9tKHRhZ3MpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4dHJhY3RzIGFsaWFzZXMgZnJvbSBmcm9udCBtYXR0ZXIuXG5cdCAqL1xuXHRwcml2YXRlIGV4dHJhY3RBbGlhc2VzKGZyb250TWF0dGVyPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHN0cmluZ1tdIHtcblx0XHRpZiAoIWZyb250TWF0dGVyPy5hbGlhc2VzKSByZXR1cm4gW107XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZnJvbnRNYXR0ZXIuYWxpYXNlcykpIHtcblx0XHRcdHJldHVybiBmcm9udE1hdHRlci5hbGlhc2VzLmZpbHRlcihhbGlhcyA9PiB0eXBlb2YgYWxpYXMgPT09ICdzdHJpbmcnKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBmcm9udE1hdHRlci5hbGlhc2VzID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIFtmcm9udE1hdHRlci5hbGlhc2VzXTtcblx0XHR9XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4dHJhY3RzIHNvdXJjZSBsb2NhdGlvbiBpbmZvcm1hdGlvbiBmcm9tIGZyb250IG1hdHRlci5cblx0ICovXG5cdHByaXZhdGUgZXh0cmFjdFNvdXJjZUxvY2F0aW9uKGZyb250TWF0dGVyPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHsgbGluZXM6IHsgZnJvbTogbnVtYmVyOyB0bzogbnVtYmVyIH0gfSB8IHVuZGVmaW5lZCB7XG5cdFx0aWYgKCFmcm9udE1hdHRlcj8ubG9jPy5saW5lcz8uZnJvbSB8fCAhZnJvbnRNYXR0ZXI/LmxvYz8ubGluZXM/LnRvKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0bGluZXM6IHtcblx0XHRcdFx0ZnJvbTogTnVtYmVyKGZyb250TWF0dGVyLmxvYy5saW5lcy5mcm9tKSxcblx0XHRcdFx0dG86IE51bWJlcihmcm9udE1hdHRlci5sb2MubGluZXMudG8pXG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufVxuIiwgIi8vIHNyYy91dGlscy9UZXh0U3BsaXR0ZXIudHNcbmltcG9ydCB7XG5cdERvY3VtZW50Q2h1bmssXG5cdERvY3VtZW50TWV0YWRhdGEsXG5cdERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLFxufSBmcm9tICcuLi9tb2RlbHMvRG9jdW1lbnRDaHVuayc7XG5pbXBvcnQgeyBERUZBVUxUX0NIVU5LSU5HX09QVElPTlMgfSBmcm9tICcuLi9zZXR0aW5ncy9TZXR0aW5ncyc7XG5pbXBvcnQgeyBNZXRhZGF0YUV4dHJhY3RvciB9IGZyb20gJy4uL3NlcnZpY2VzL01ldGFkYXRhRXh0cmFjdG9yJztcblxuZXhwb3J0IGNsYXNzIFRleHRTcGxpdHRlciB7XG5cdHByaXZhdGUgc2V0dGluZ3M6IHtcblx0XHRjaHVua1NpemU6IG51bWJlcjtcblx0XHRjaHVua092ZXJsYXA6IG51bWJlcjtcblx0XHRtaW5DaHVua1NpemU6IG51bWJlcjtcblx0fTtcblx0cHJpdmF0ZSBtZXRhZGF0YUV4dHJhY3RvcjogTWV0YWRhdGFFeHRyYWN0b3I7XG5cdC8vIFJlZ2V4IHBhdHRlcm5zIGZvciBzcGxpdHRpbmdcblx0cHJpdmF0ZSByZWFkb25seSBTRU5URU5DRV9CT1VOREFSWSA9IC9bLiE/XVxccysvO1xuXHRwcml2YXRlIHJlYWRvbmx5IFBBUkFHUkFQSF9CT1VOREFSWSA9IC9cXG5cXHMqXFxuLztcblx0cHJpdmF0ZSByZWFkb25seSBZQU1MX0ZST05UX01BVFRFUiA9IC9eLS0tXFxuKFtcXHNcXFNdKj8pXFxuLS0tLztcblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRzZXR0aW5ncz86IHsgY2h1bmtTaXplOiBudW1iZXI7IGNodW5rT3ZlcmxhcDogbnVtYmVyOyBtaW5DaHVua1NpemU6IG51bWJlciB9LFxuXHRcdG1ldGFkYXRhRXh0cmFjdG9yPzogTWV0YWRhdGFFeHRyYWN0b3Jcblx0KSB7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzIHx8IHsgLi4uREVGQVVMVF9DSFVOS0lOR19PUFRJT05TIH07XG5cdFx0dGhpcy52YWxpZGF0ZVNldHRpbmdzKHRoaXMuc2V0dGluZ3MpO1xuXHRcdHRoaXMubWV0YWRhdGFFeHRyYWN0b3IgPSBtZXRhZGF0YUV4dHJhY3RvciB8fCBuZXcgTWV0YWRhdGFFeHRyYWN0b3IoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNodW5raW5nIHNldHRpbmdzLlxuXHQgKi9cblx0cHVibGljIGdldFNldHRpbmdzKCk6IHsgY2h1bmtTaXplOiBudW1iZXI7IGNodW5rT3ZlcmxhcDogbnVtYmVyOyBtaW5DaHVua1NpemU6IG51bWJlciB9IHtcblx0XHRyZXR1cm4gdGhpcy5zZXR0aW5ncztcblx0fVxuXG5cdHByaXZhdGUgdmFsaWRhdGVTZXR0aW5ncyhzZXR0aW5nczogeyBjaHVua1NpemU6IG51bWJlcjsgY2h1bmtPdmVybGFwOiBudW1iZXI7IG1pbkNodW5rU2l6ZTogbnVtYmVyIH0pOiB2b2lkIHtcblx0XHRpZiAoc2V0dGluZ3MuY2h1bmtTaXplIDw9IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ2h1bmsgc2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLicpO1xuXHRcdH1cblx0XHRpZiAoc2V0dGluZ3MuY2h1bmtPdmVybGFwID49IHNldHRpbmdzLmNodW5rU2l6ZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDaHVuayBvdmVybGFwIG11c3QgYmUgbGVzcyB0aGFuIGNodW5rIHNpemUuJyk7XG5cdFx0fVxuXHRcdGlmIChzZXR0aW5ncy5taW5DaHVua1NpemUgPiBzZXR0aW5ncy5jaHVua1NpemUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWluaW11bSBjaHVuayBzaXplIG11c3Qgbm90IGV4Y2VlZCBjaHVuayBzaXplLicpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTcGxpdHMgYSBkb2N1bWVudCBpbnRvIGNodW5rcyB3aGlsZSBlbmhhbmNpbmcgbWV0YWRhdGEuXG5cdCAqIEV4dHJhY3RzIFlBTUwgZnJvbnQgbWF0dGVyIGlmIHByZXNlbnQsIGFuZCB0aGVuIHVzZXMgdGhlIE1ldGFkYXRhRXh0cmFjdG9yXG5cdCAqIHRvIG1lcmdlIGFkZGl0aW9uYWwgbWV0YWRhdGEgKGUuZy4sIHRhZ3MsIGFsaWFzZXMsIGxpbmtzKSBpbnRvIHRoZSBiYXNlIG1ldGFkYXRhXG5cdCAqIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbCBub3RlIGNvbnRlbnQuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgc3BsaXREb2N1bWVudChjb250ZW50OiBzdHJpbmcsIG1ldGFkYXRhOiBEb2N1bWVudE1ldGFkYXRhKTogUHJvbWlzZTxEb2N1bWVudENodW5rW10+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc29sZS5sb2coJ1N0YXJ0aW5nIGRvY3VtZW50IHNwbGl0OicsIHtcblx0XHRcdFx0Y29udGVudExlbmd0aDogY29udGVudC5sZW5ndGgsXG5cdFx0XHRcdHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLFxuXHRcdFx0fSk7XG5cblx0XHRcdGlmICghY29udGVudD8udHJpbSgpKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdFbXB0eSBjb250ZW50IHJlY2VpdmVkJyk7XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXR0ZW1wdCB0byBleHRyYWN0IFlBTUwgZnJvbnQgbWF0dGVyIHdpdGhvdXQgYWx0ZXJpbmcgdGhlIG9yaWdpbmFsIGNvbnRlbnQuXG5cdFx0XHRsZXQgZnJvbnRNYXR0ZXIgPSBudWxsO1xuXHRcdFx0Y29uc3QgZnJvbnRNYXR0ZXJNYXRjaCA9IHRoaXMuWUFNTF9GUk9OVF9NQVRURVIuZXhlYyhjb250ZW50KTtcblx0XHRcdGlmIChmcm9udE1hdHRlck1hdGNoKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZnJvbnRNYXR0ZXIgPSB0aGlzLnBhcnNlRnJvbnRNYXR0ZXIoZnJvbnRNYXR0ZXJNYXRjaFsxXSk7XG5cdFx0XHRcdFx0Ly8gRW5oYW5jZSBtZXRhZGF0YSB1c2luZyBNZXRhZGF0YUV4dHJhY3RvciB3aXRoIGV4dHJhY3RlZCBmcm9udCBtYXR0ZXIuXG5cdFx0XHRcdFx0Y29uc3QgZW5oYW5jZWRNZXRhZGF0YSA9IGF3YWl0IHRoaXMubWV0YWRhdGFFeHRyYWN0b3IuZXh0cmFjdE1ldGFkYXRhRnJvbUNvbnRlbnQoXG5cdFx0XHRcdFx0XHRjb250ZW50LFxuXHRcdFx0XHRcdFx0bWV0YWRhdGEsXG5cdFx0XHRcdFx0XHRmcm9udE1hdHRlclxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0bWV0YWRhdGEgPSB7IC4uLm1ldGFkYXRhLCAuLi5lbmhhbmNlZE1ldGFkYXRhIH07XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ0Zyb250IG1hdHRlciBleHRyYWN0ZWQgYW5kIG1ldGFkYXRhIGVuaGFuY2VkOicsIHsgZnJvbnRNYXR0ZXIgfSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgZnJvbnQgbWF0dGVyOicsIGVycm9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0cmltbWVkQ29udGVudCA9IGNvbnRlbnQudHJpbSgpO1xuXG5cdFx0XHQvLyBJZiBjb250ZW50IGlzIHNtYWxsZXIgdGhhbiB0aGUgY2h1bmsgc2l6ZSwgcmV0dXJuIGFzIGEgc2luZ2xlIGNodW5rLlxuXHRcdFx0aWYgKHRyaW1tZWRDb250ZW50Lmxlbmd0aCA8PSBNYXRoLm1heCh0aGlzLnNldHRpbmdzLm1pbkNodW5rU2l6ZSwgdGhpcy5zZXR0aW5ncy5jaHVua1NpemUpKSB7XG5cdFx0XHRcdGlmICh0cmltbWVkQ29udGVudC5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygnTm8gY29udGVudCBhZnRlciB0cmltbWluZywgcmV0dXJuaW5nIGVtcHR5IGFycmF5Jyk7XG5cdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdDb250ZW50IGlzIHNtYWxsZXIgdGhhbiBjaHVuayBzaXplLCBjcmVhdGluZyBzaW5nbGUgY2h1bms6Jywge1xuXHRcdFx0XHRcdGNvbnRlbnRMZW5ndGg6IHRyaW1tZWRDb250ZW50Lmxlbmd0aCxcblx0XHRcdFx0XHRjaHVua1NpemU6IHRoaXMuc2V0dGluZ3MuY2h1bmtTaXplLFxuXHRcdFx0XHRcdG1pbkNodW5rU2l6ZTogdGhpcy5zZXR0aW5ncy5taW5DaHVua1NpemUsXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRjb25zdCBzaW5nbGVDaHVuayA9IHRoaXMuY3JlYXRlQ2h1bmsodHJpbW1lZENvbnRlbnQsIDAsIG1ldGFkYXRhKTtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0NyZWF0ZWQgc2luZ2xlIGNodW5rOicsIHtcblx0XHRcdFx0XHRjaHVua1NpemU6IHNpbmdsZUNodW5rLmNvbnRlbnQubGVuZ3RoLFxuXHRcdFx0XHRcdHByZXZpZXc6IHNpbmdsZUNodW5rLmNvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMCksXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gW3NpbmdsZUNodW5rXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3BsaXQgY29udGVudCBpbnRvIHBhcmFncmFwaHMuXG5cdFx0XHRjb25zdCBwYXJhZ3JhcGhzID0gY29udGVudC5zcGxpdCh0aGlzLlBBUkFHUkFQSF9CT1VOREFSWSlcblx0XHRcdFx0Lm1hcChwID0+IHAudHJpbSgpKVxuXHRcdFx0XHQuZmlsdGVyKHAgPT4gcC5sZW5ndGggPiAwKTtcblx0XHRcdGNvbnNvbGUubG9nKCdTcGxpdCBpbnRvIHBhcmFncmFwaHM6Jywge1xuXHRcdFx0XHRwYXJhZ3JhcGhDb3VudDogcGFyYWdyYXBocy5sZW5ndGgsXG5cdFx0XHRcdHBhcmFncmFwaHM6IHBhcmFncmFwaHMubWFwKHAgPT4gcC5zdWJzdHJpbmcoMCwgMTAwKSksXG5cdFx0XHR9KTtcblxuXHRcdFx0bGV0IGNodW5rczogRG9jdW1lbnRDaHVua1tdID0gW107XG5cdFx0XHRsZXQgY3VycmVudENodW5rID0gJyc7XG5cdFx0XHRsZXQgY2h1bmtJbmRleCA9IDA7XG5cdFx0XHRmb3IgKGNvbnN0IHBhcmFncmFwaCBvZiBwYXJhZ3JhcGhzKSB7XG5cdFx0XHRcdC8vIElmIHBhcmFncmFwaCBpcyBsYXJnZXIgdGhhbiB0aGUgY2h1bmsgc2l6ZSwgc3BsaXQgaXQgaW50byBzZW50ZW5jZXMuXG5cdFx0XHRcdGlmIChwYXJhZ3JhcGgubGVuZ3RoID49IHRoaXMuc2V0dGluZ3MuY2h1bmtTaXplKSB7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRDaHVuaykge1xuXHRcdFx0XHRcdFx0Y2h1bmtzLnB1c2godGhpcy5jcmVhdGVDaHVuayhjdXJyZW50Q2h1bmssIGNodW5rSW5kZXgrKywgbWV0YWRhdGEpKTtcblx0XHRcdFx0XHRcdGN1cnJlbnRDaHVuayA9ICcnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBzZW50ZW5jZXMgPSBwYXJhZ3JhcGguc3BsaXQodGhpcy5TRU5URU5DRV9CT1VOREFSWSk7XG5cdFx0XHRcdFx0bGV0IHNlbnRlbmNlQ2h1bmsgPSAnJztcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHNlbnRlbmNlIG9mIHNlbnRlbmNlcykge1xuXHRcdFx0XHRcdFx0Y29uc3QgdHJpbW1lZFNlbnRlbmNlID0gc2VudGVuY2UudHJpbSgpO1xuXHRcdFx0XHRcdFx0aWYgKCF0cmltbWVkU2VudGVuY2UpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0aWYgKChzZW50ZW5jZUNodW5rICsgJyAnICsgdHJpbW1lZFNlbnRlbmNlKS5sZW5ndGggPiB0aGlzLnNldHRpbmdzLmNodW5rU2l6ZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoc2VudGVuY2VDaHVuaykge1xuXHRcdFx0XHRcdFx0XHRcdGNodW5rcy5wdXNoKHRoaXMuY3JlYXRlQ2h1bmsoc2VudGVuY2VDaHVuaywgY2h1bmtJbmRleCsrLCBtZXRhZGF0YSkpO1xuXHRcdFx0XHRcdFx0XHRcdHNlbnRlbmNlQ2h1bmsgPSB0cmltbWVkU2VudGVuY2U7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIHZlcnkgbG9uZyBzZW50ZW5jZXMsIGZvcmNlIHNwbGl0LlxuXHRcdFx0XHRcdFx0XHRcdGxldCBwb3NpdGlvbiA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKHBvc2l0aW9uIDwgdHJpbW1lZFNlbnRlbmNlLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgY2h1bmtUZXh0ID0gdHJpbW1lZFNlbnRlbmNlLnNsaWNlKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbixcblx0XHRcdFx0XHRcdFx0XHRcdFx0TWF0aC5taW4ocG9zaXRpb24gKyB0aGlzLnNldHRpbmdzLmNodW5rU2l6ZSwgdHJpbW1lZFNlbnRlbmNlLmxlbmd0aClcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjaHVua3MucHVzaCh0aGlzLmNyZWF0ZUNodW5rKGNodW5rVGV4dCwgY2h1bmtJbmRleCsrLCBtZXRhZGF0YSkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gdGhpcy5zZXR0aW5ncy5jaHVua1NpemU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHNlbnRlbmNlQ2h1bmsgPSAnJztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c2VudGVuY2VDaHVuayArPSAoc2VudGVuY2VDaHVuayA/ICcgJyA6ICcnKSArIHRyaW1tZWRTZW50ZW5jZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHNlbnRlbmNlQ2h1bmspIHtcblx0XHRcdFx0XHRcdGNodW5rcy5wdXNoKHRoaXMuY3JlYXRlQ2h1bmsoc2VudGVuY2VDaHVuaywgY2h1bmtJbmRleCsrLCBtZXRhZGF0YSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBBY2N1bXVsYXRlIHBhcmFncmFwaHMgdW50aWwgcmVhY2hpbmcgY2h1bmsgc2l6ZS5cblx0XHRcdFx0XHRjb25zdCBwb3RlbnRpYWxDaHVua1NpemUgPSBjdXJyZW50Q2h1bmtcblx0XHRcdFx0XHRcdD8gY3VycmVudENodW5rLmxlbmd0aCArIDIgKyBwYXJhZ3JhcGgubGVuZ3RoXG5cdFx0XHRcdFx0XHQ6IHBhcmFncmFwaC5sZW5ndGg7XG5cdFx0XHRcdFx0aWYgKHBvdGVudGlhbENodW5rU2l6ZSA8PSB0aGlzLnNldHRpbmdzLmNodW5rU2l6ZSkge1xuXHRcdFx0XHRcdFx0Y3VycmVudENodW5rICs9IChjdXJyZW50Q2h1bmsgPyAnXFxuXFxuJyA6ICcnKSArIHBhcmFncmFwaDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRDaHVuaykge1xuXHRcdFx0XHRcdFx0XHRjaHVua3MucHVzaCh0aGlzLmNyZWF0ZUNodW5rKGN1cnJlbnRDaHVuaywgY2h1bmtJbmRleCsrLCBtZXRhZGF0YSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y3VycmVudENodW5rID0gcGFyYWdyYXBoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnJlbnRDaHVuaykge1xuXHRcdFx0XHRjaHVua3MucHVzaCh0aGlzLmNyZWF0ZUNodW5rKGN1cnJlbnRDaHVuaywgY2h1bmtJbmRleCsrLCBtZXRhZGF0YSkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNodW5rcy5sZW5ndGggPT09IDAgJiYgdHJpbW1lZENvbnRlbnQubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnQ3JlYXRpbmcgZmFsbGJhY2sgY2h1bmsgZm9yIGNvbnRlbnQ6JywgeyBjb250ZW50TGVuZ3RoOiB0cmltbWVkQ29udGVudC5sZW5ndGggfSk7XG5cdFx0XHRcdGNodW5rcy5wdXNoKHRoaXMuY3JlYXRlQ2h1bmsodHJpbW1lZENvbnRlbnQsIDAsIG1ldGFkYXRhKSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBBcHBseSBvdmVybGFwIGJldHdlZW4gY2h1bmtzIGlmIGNvbmZpZ3VyZWQuXG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5jaHVua092ZXJsYXAgPiAwICYmIGNodW5rcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdGNodW5rcyA9IHRoaXMuYXBwbHlPdmVybGFwKGNodW5rcyk7XG5cdFx0XHR9XG5cdFx0XHRjb25zb2xlLmxvZygnRmluaXNoZWQgY3JlYXRpbmcgY2h1bmtzOicsIHtcblx0XHRcdFx0Y2h1bmtDb3VudDogY2h1bmtzLmxlbmd0aCxcblx0XHRcdFx0Y2h1bmtTaXplczogY2h1bmtzLm1hcChjID0+IGMuY29udGVudC5sZW5ndGgpLFxuXHRcdFx0XHRjaHVua1ByZXZpZXdzOiBjaHVua3MubWFwKGMgPT4gKHtcblx0XHRcdFx0XHRpbmRleDogYy5jaHVua0luZGV4LFxuXHRcdFx0XHRcdHNpemU6IGMuY29udGVudC5sZW5ndGgsXG5cdFx0XHRcdFx0cHJldmlldzogYy5jb250ZW50LnN1YnN0cmluZygwLCAxMDApLFxuXHRcdFx0XHR9KSksXG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBjaHVua3M7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHNwbGl0RG9jdW1lbnQ6JywgZXJyb3IpO1xuXHRcdFx0dGhyb3cge1xuXHRcdFx0XHR0eXBlOiBEb2N1bWVudFByb2Nlc3NpbmdFcnJvci5DSFVOS0lOR19FUlJPUixcblx0XHRcdFx0bWVzc2FnZTogJ0Vycm9yIG9jY3VycmVkIGR1cmluZyBkb2N1bWVudCBjaHVua2luZycsXG5cdFx0XHRcdGRldGFpbHM6IGVycm9yLm1lc3NhZ2UsXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgY3JlYXRlQ2h1bmsoY29udGVudDogc3RyaW5nLCBpbmRleDogbnVtYmVyLCBtZXRhZGF0YTogRG9jdW1lbnRNZXRhZGF0YSk6IERvY3VtZW50Q2h1bmsge1xuXHRcdGNvbnN0IHRyaW1tZWRDb250ZW50ID0gY29udGVudC50cmltKCk7XG5cdFx0aWYgKHRyaW1tZWRDb250ZW50Lmxlbmd0aCA8IHRoaXMuc2V0dGluZ3MubWluQ2h1bmtTaXplKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0NodW5rIHNtYWxsZXIgdGhhbiBtaW5DaHVua1NpemU6Jywge1xuXHRcdFx0XHRzaXplOiB0cmltbWVkQ29udGVudC5sZW5ndGgsXG5cdFx0XHRcdG1pblNpemU6IHRoaXMuc2V0dGluZ3MubWluQ2h1bmtTaXplLFxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRjb250ZW50OiB0cmltbWVkQ29udGVudCxcblx0XHRcdGNodW5rSW5kZXg6IGluZGV4LFxuXHRcdFx0bWV0YWRhdGE6IHsgLi4ubWV0YWRhdGEgfSxcblx0XHR9O1xuXHR9XG5cblx0cHJpdmF0ZSBhcHBseU92ZXJsYXAoY2h1bmtzOiBEb2N1bWVudENodW5rW10pOiBEb2N1bWVudENodW5rW10ge1xuXHRcdGlmIChjaHVua3MubGVuZ3RoIDw9IDEpIHJldHVybiBjaHVua3M7XG5cdFx0Y29uc3QgY2h1bmtzV2l0aE92ZXJsYXAgPSBbLi4uY2h1bmtzXTtcblx0XHRmb3IgKGxldCBpID0gY2h1bmtzV2l0aE92ZXJsYXAubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuXHRcdFx0Y29uc3QgY3VycmVudENodW5rID0geyAuLi5jaHVua3NXaXRoT3ZlcmxhcFtpXSB9O1xuXHRcdFx0Y29uc3QgcHJldmlvdXNDaHVuayA9IGNodW5rc1dpdGhPdmVybGFwW2kgLSAxXTtcblx0XHRcdGNvbnN0IG92ZXJsYXBUZXh0ID0gcHJldmlvdXNDaHVuay5jb250ZW50LnNsaWNlKC10aGlzLnNldHRpbmdzLmNodW5rT3ZlcmxhcCk7XG5cdFx0XHRpZiAob3ZlcmxhcFRleHQpIHtcblx0XHRcdFx0Y2h1bmtzV2l0aE92ZXJsYXBbaV0gPSB7XG5cdFx0XHRcdFx0Li4uY3VycmVudENodW5rLFxuXHRcdFx0XHRcdGNvbnRlbnQ6IG92ZXJsYXBUZXh0ICsgJ1xcblxcbicgKyBjdXJyZW50Q2h1bmsuY29udGVudCxcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNodW5rc1dpdGhPdmVybGFwO1xuXHR9XG5cblx0cHJpdmF0ZSBwYXJzZUZyb250TWF0dGVyKGZyb250TWF0dGVyOiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG5cdFx0XHRjb25zdCBsaW5lcyA9IGZyb250TWF0dGVyLnNwbGl0KCdcXG4nKTtcblx0XHRcdGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuXHRcdFx0XHRjb25zdCB0cmltbWVkTGluZSA9IGxpbmUudHJpbSgpO1xuXHRcdFx0XHRpZiAoIXRyaW1tZWRMaW5lIHx8IHRyaW1tZWRMaW5lLnN0YXJ0c1dpdGgoJyMnKSkgY29udGludWU7XG5cdFx0XHRcdGNvbnN0IHNlcGFyYXRvckluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG5cdFx0XHRcdGlmIChzZXBhcmF0b3JJbmRleCA9PT0gLTEpIGNvbnRpbnVlO1xuXHRcdFx0XHRjb25zdCBrZXkgPSBsaW5lLnNsaWNlKDAsIHNlcGFyYXRvckluZGV4KS50cmltKCk7XG5cdFx0XHRcdGxldCB2YWx1ZSA9IGxpbmUuc2xpY2Uoc2VwYXJhdG9ySW5kZXggKyAxKS50cmltKCk7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXltcIiddKC4qKVtcIiddJC8sICckMScpO1xuXHRcdFx0XHRpZiAodmFsdWUuc3RhcnRzV2l0aCgnLSAnKSkge1xuXHRcdFx0XHRcdHJlc3VsdFtrZXldID0gdmFsdWVcblx0XHRcdFx0XHRcdC5zcGxpdCgnXFxuJylcblx0XHRcdFx0XHRcdC5tYXAoaXRlbSA9PiBpdGVtLnJlcGxhY2UoJy0gJywgJycpLnRyaW0oKSlcblx0XHRcdFx0XHRcdC5maWx0ZXIoQm9vbGVhbik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdWx0W2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgZnJvbnQgbWF0dGVyOicsIGVycm9yKTtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cdH1cbn1cbiIsICIvLyBzcmMvc2VydmljZXMvRXZlbnRFbWl0dGVyLnRzXG5pbXBvcnQgeyBRdWV1ZUV2ZW50VHlwZXMsIFF1ZXVlRXZlbnRDYWxsYmFjayB9IGZyb20gJy4uL21vZGVscy9RdWV1ZUV2ZW50cyc7XG5cbmV4cG9ydCBjbGFzcyBFdmVudEVtaXR0ZXIge1xuXHRwcml2YXRlIGxpc3RlbmVyczogTWFwPHN0cmluZywgU2V0PEZ1bmN0aW9uPj4gPSBuZXcgTWFwKCk7XG5cblx0LyoqXG5cdCAqIEVtaXQgYW4gZXZlbnQgd2l0aCBhc3NvY2lhdGVkIGRhdGEuXG5cdCAqIExpc3RlbmVycyByZWdpc3RlcmVkIGZvciB0aGlzIGV2ZW50IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGRhdGEuXG5cdCAqL1xuXHRlbWl0PFQgZXh0ZW5kcyBrZXlvZiBRdWV1ZUV2ZW50VHlwZXM+KGV2ZW50OiBULCBkYXRhOiBRdWV1ZUV2ZW50VHlwZXNbVF0pOiB2b2lkIHtcblx0XHRjb25zdCBjYWxsYmFja3MgPSB0aGlzLmxpc3RlbmVycy5nZXQoZXZlbnQpO1xuXHRcdGlmIChjYWxsYmFja3MpIHtcblx0XHRcdGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZGF0YSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihgRXJyb3IgaW4gbGlzdGVuZXIgZm9yIGV2ZW50IFwiJHtldmVudH1cIjpgLCBlcnJvcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIHNwZWNpZmllZCBldmVudCBpcyBlbWl0dGVkLlxuXHQgKiBSZXR1cm5zIGFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLlxuXHQgKi9cblx0b248VCBleHRlbmRzIGtleW9mIFF1ZXVlRXZlbnRUeXBlcz4oZXZlbnQ6IFQsIGNhbGxiYWNrOiBRdWV1ZUV2ZW50Q2FsbGJhY2s8VD4pOiAoKSA9PiB2b2lkIHtcblx0XHRpZiAoIXRoaXMubGlzdGVuZXJzLmhhcyhldmVudCkpIHtcblx0XHRcdHRoaXMubGlzdGVuZXJzLnNldChldmVudCwgbmV3IFNldCgpKTtcblx0XHR9XG5cdFx0dGhpcy5saXN0ZW5lcnMuZ2V0KGV2ZW50KT8uYWRkKGNhbGxiYWNrKTtcblx0XHQvLyBSZXR1cm4gYW4gdW5zdWJzY3JpYmUgZnVuY3Rpb24uXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHRoaXMubGlzdGVuZXJzLmdldChldmVudCk/LmRlbGV0ZShjYWxsYmFjayk7XG5cdFx0fTtcblx0fVxufVxuIiwgIi8vIHNyYy91dGlscy9GaWxlVHJhY2tlci50c1xuaW1wb3J0IHsgVEFic3RyYWN0RmlsZSwgVEZpbGUsIFZhdWx0IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgRXJyb3JIYW5kbGVyIH0gZnJvbSAnLi9FcnJvckhhbmRsZXInO1xuaW1wb3J0IHsgRG9jdW1lbnRNZXRhZGF0YSB9IGZyb20gJy4uL21vZGVscy9Eb2N1bWVudENodW5rJztcbmltcG9ydCB7IFN5bmNGaWxlTWFuYWdlciB9IGZyb20gJy4uL3NlcnZpY2VzL1N5bmNGaWxlTWFuYWdlcic7XG5pbXBvcnQgeyBTdXBhYmFzZVNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9TdXBhYmFzZVNlcnZpY2UnO1xuLy8gT3B0aW9uYWw6IEltcG9ydCBPZmZsaW5lUXVldWVNYW5hZ2VyIGlmIGF2YWlsYWJsZVxuaW1wb3J0IHsgT2ZmbGluZVF1ZXVlTWFuYWdlciB9IGZyb20gJy4uL3NlcnZpY2VzL09mZmxpbmVRdWV1ZU1hbmFnZXInO1xuXG5pbnRlcmZhY2UgRmlsZUV2ZW50IHtcblx0dHlwZTogJ2NyZWF0ZScgfCAnbW9kaWZ5JyB8ICdkZWxldGUnIHwgJ3JlbmFtZSc7XG5cdGZpbGU6IFRGaWxlO1xuXHRvbGRQYXRoPzogc3RyaW5nO1xuXHR0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEZpbGVUcmFja2VyIHtcblx0cHJpdmF0ZSBldmVudFF1ZXVlOiBGaWxlRXZlbnRbXSA9IFtdO1xuXHRwcml2YXRlIGlzUHJvY2Vzc2luZzogYm9vbGVhbiA9IGZhbHNlO1xuXHRwcml2YXRlIHByb2Nlc3NpbmdUaW1lb3V0OiBudW1iZXIgPSAxMDAwOyAvLyBEZWJvdW5jZSB0aW1lIGluIG1zXG5cdHByaXZhdGUgc3luY01hbmFnZXI6IFN5bmNGaWxlTWFuYWdlcjtcblx0cHJpdmF0ZSByZWFkb25seSBzeW5jRmlsZVBhdGg6IHN0cmluZztcblx0Ly8gT3B0aW9uYWwgb2ZmbGluZSBxdWV1ZSBtYW5hZ2VyIGZvciBvZmZsaW5lIG9wZXJhdGlvbnNcblx0cHJpdmF0ZSBvZmZsaW5lUXVldWVNYW5hZ2VyOiBPZmZsaW5lUXVldWVNYW5hZ2VyIHwgbnVsbCA9IG51bGw7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB2YXVsdCBUaGUgT2JzaWRpYW4gdmF1bHQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSBlcnJvckhhbmRsZXIgQ2VudHJhbGl6ZWQgZXJyb3IgaGFuZGxlci5cblx0ICogQHBhcmFtIHN5bmNGaWxlUGF0aCBQYXRoIHRvIHRoZSBzeW5jIGZpbGUuXG5cdCAqIEBwYXJhbSBzdXBhYmFzZVNlcnZpY2UgT3B0aW9uYWwgU3VwYWJhc2Ugc2VydmljZSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIG9mZmxpbmVRdWV1ZU1hbmFnZXIgT3B0aW9uYWwgT2ZmbGluZVF1ZXVlTWFuYWdlciBmb3Igb2ZmbGluZSBtb2RlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoXG5cdFx0cHJpdmF0ZSB2YXVsdDogVmF1bHQsXG5cdFx0cHJpdmF0ZSBlcnJvckhhbmRsZXI6IEVycm9ySGFuZGxlcixcblx0XHRzeW5jRmlsZVBhdGg6IHN0cmluZyA9ICdfbWluZG1hdHJpeHN5bmMubWQnLFxuXHRcdHByaXZhdGUgc3VwYWJhc2VTZXJ2aWNlOiBTdXBhYmFzZVNlcnZpY2UgfCBudWxsID0gbnVsbCxcblx0XHRvZmZsaW5lUXVldWVNYW5hZ2VyPzogT2ZmbGluZVF1ZXVlTWFuYWdlclxuXHQpIHtcblx0XHR0aGlzLnN5bmNGaWxlUGF0aCA9IHN5bmNGaWxlUGF0aDtcblx0XHQvLyBJbml0aWFsaXplIHRoZSBzeW5jIG1hbmFnZXIgdXNpbmcgdGhlIHByb3ZpZGVkIHN5bmMgZmlsZSBwYXRoLlxuXHRcdHRoaXMuc3luY01hbmFnZXIgPSBuZXcgU3luY0ZpbGVNYW5hZ2VyKHZhdWx0LCBlcnJvckhhbmRsZXIsIHN5bmNGaWxlUGF0aCk7XG5cdFx0aWYgKG9mZmxpbmVRdWV1ZU1hbmFnZXIpIHtcblx0XHRcdHRoaXMub2ZmbGluZVF1ZXVlTWFuYWdlciA9IG9mZmxpbmVRdWV1ZU1hbmFnZXI7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIGZpbGUgdHJhY2tlci5cblx0ICogSWYgYSBTdXBhYmFzZSBzZXJ2aWNlIGlzIGF2YWlsYWJsZSwgcmVjb25jaWxlIHRoZSBkYXRhYmFzZSB3aXRoIHRoZSBsb2NhbCBzeW5jIGZpbGUuXG5cdCAqL1xuXHRhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zb2xlLmxvZygnW0ZpbGVUcmFja2VyLmluaXRpYWxpemVdIFN0YXJ0aW5nIEZpbGVUcmFja2VyIGluaXRpYWxpemF0aW9uJyk7XG5cdFx0XHRjb25zb2xlLmxvZyhgW0ZpbGVUcmFja2VyLmluaXRpYWxpemVdIFN5bmMgZmlsZSBwYXRoOiAke3RoaXMuc3luY0ZpbGVQYXRofWApO1xuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBzeW5jIG1hbmFnZXIgKGZhbGxiYWNrIGZvciBvZmZsaW5lIG1vZGUpXG5cdFx0XHRhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLmluaXRpYWxpemUoKTtcblx0XHRcdC8vIElmIFN1cGFiYXNlIHNlcnZpY2UgaXMgYXZhaWxhYmxlLCByZWNvbmNpbGUgREIgc3RhdHVzIHdpdGggbG9jYWwgZmlsZSBzdGF0ZS5cblx0XHRcdGlmICh0aGlzLnN1cGFiYXNlU2VydmljZSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnJlY29uY2lsZURhdGFiYXNlV2l0aFN5bmNGaWxlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnU3VwYWJhc2Ugc2VydmljZSBub3QgYXZhaWxhYmxlLiBVc2luZyBzeW5jIGZpbGUgb25seSBmb3IgdHJhY2tpbmcuJyk7XG5cdFx0XHR9XG5cdFx0XHRjb25zb2xlLmxvZygnRmlsZVRyYWNrZXIgaW5pdGlhbGl6ZWQuJyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdGaWxlVHJhY2tlci5pbml0aWFsaXplJyB9KTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWNvbmNpbGUgZGF0YWJhc2UgcmVjb3JkcyB3aXRoIGxvY2FsIHN5bmMgZmlsZSBlbnRyaWVzLlxuXHQgKiBFbnN1cmVzIHRoYXQgZWFjaCBmaWxlIGluIHRoZSB2YXVsdCBoYXMgYW4gdXAtdG8tZGF0ZSBzdGF0dXMgaW4gdGhlIGRhdGFiYXNlLlxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyByZWNvbmNpbGVEYXRhYmFzZVdpdGhTeW5jRmlsZSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCF0aGlzLnN1cGFiYXNlU2VydmljZSkgcmV0dXJuO1xuXHRcdFx0Ly8gUmV0cmlldmUgYWxsIHN5bmMgZW50cmllcyBmcm9tIHRoZSBsb2NhbCBzeW5jIGZpbGVcblx0XHRcdGNvbnN0IHN5bmNFbnRyaWVzID0gYXdhaXQgdGhpcy5zeW5jTWFuYWdlci5nZXRBbGxTeW5jRW50cmllcygpO1xuXHRcdFx0Y29uc3QgZW50cmllc01hcCA9IG5ldyBNYXAoc3luY0VudHJpZXMubWFwKGVudHJ5ID0+IFtlbnRyeS5maWxlUGF0aCwgZW50cnldKSk7XG5cdFx0XHQvLyBJdGVyYXRlIG92ZXIgYWxsIGZpbGVzIGluIHRoZSB2YXVsdFxuXHRcdFx0Y29uc3QgZmlsZXMgPSB0aGlzLnZhdWx0LmdldEZpbGVzKCk7XG5cdFx0XHRmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcblx0XHRcdFx0Ly8gT25seSBwcm9jZXNzIG1hcmtkb3duIGZpbGVzIHRoYXQgYXJlIG5vdCBleGNsdWRlZFxuXHRcdFx0XHRpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHx8ICF0aGlzLnNob3VsZFRyYWNrRmlsZShmaWxlLnBhdGgpKSBjb250aW51ZTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBHZXQgZmlsZSBzdGF0dXMgZnJvbSB0aGUgZGF0YWJhc2Vcblx0XHRcdFx0XHRjb25zdCBkYlN0YXR1cyA9IGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLmdldEZpbGVWZWN0b3JpemF0aW9uU3RhdHVzKGZpbGUucGF0aCk7XG5cdFx0XHRcdFx0Y29uc3QgY3VycmVudEhhc2ggPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUZpbGVIYXNoKGZpbGUpO1xuXHRcdFx0XHRcdC8vIElmIHRoZSBmaWxlIGlzIG1hcmtlZCBhcyB2ZWN0b3JpemVkIGJ1dCB0aGUgZmlsZSBoYXMgY2hhbmdlZCwgdXBkYXRlIHN0YXR1cyB0byBQRU5ESU5HXG5cdFx0XHRcdFx0aWYgKGRiU3RhdHVzLmlzVmVjdG9yaXplZCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgZmlsZU1vZGlmaWVkU2luY2VEYiA9IGZpbGUuc3RhdC5tdGltZSA+IChkYlN0YXR1cy5sYXN0TW9kaWZpZWQgfHwgMCk7XG5cdFx0XHRcdFx0XHRpZiAoZmlsZU1vZGlmaWVkU2luY2VEYikge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuY3JlYXRlRmlsZU1ldGFkYXRhKGZpbGUpO1xuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS51cGRhdGVGaWxlVmVjdG9yaXphdGlvblN0YXR1cyhtZXRhZGF0YSk7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGBEYXRhYmFzZSByZWNvcmQgdXBkYXRlZCB0byBQRU5ESU5HIGZvciBtb2RpZmllZCBmaWxlOiAke2ZpbGUucGF0aH1gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gTm8gdmFsaWQgcmVjb3JkIG9yIG5vdCB2ZWN0b3JpemVkIHlldFx1MjAxNGNyZWF0ZSBvciB1cGRhdGUgaXQgaW4gdGhlIGRhdGFiYXNlXG5cdFx0XHRcdFx0XHRjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuY3JlYXRlRmlsZU1ldGFkYXRhKGZpbGUpO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UudXBkYXRlRmlsZVZlY3Rvcml6YXRpb25TdGF0dXMobWV0YWRhdGEpO1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coYERhdGFiYXNlIHJlY29yZCBjcmVhdGVkL3VwZGF0ZWQgZm9yIGZpbGU6ICR7ZmlsZS5wYXRofWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0XHRcdFx0Y29udGV4dDogJ0ZpbGVUcmFja2VyLnJlY29uY2lsZURhdGFiYXNlV2l0aFN5bmNGaWxlJyxcblx0XHRcdFx0XHRcdG1ldGFkYXRhOiB7IGZpbGVQYXRoOiBmaWxlLnBhdGggfVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBGb3IgZmlsZXMgdGhhdCBleGlzdCBpbiB0aGUgc3luYyBmaWxlIGJ1dCBhcmUgZGVsZXRlZCBmcm9tIHRoZSB2YXVsdCxcblx0XHRcdC8vIG1hcmsgdGhlbSBhcyBkZWxldGVkIGluIHRoZSBkYXRhYmFzZS5cblx0XHRcdGZvciAoY29uc3QgZW50cnkgb2Ygc3luY0VudHJpZXMpIHtcblx0XHRcdFx0Y29uc3QgZmlsZSA9IHRoaXMudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGVudHJ5LmZpbGVQYXRoKTtcblx0XHRcdFx0aWYgKCFmaWxlICYmIGVudHJ5LnN0YXR1cyAhPT0gJ0VSUk9SJyAmJiB0aGlzLnN1cGFiYXNlU2VydmljZSkge1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLnVwZGF0ZUZpbGVTdGF0dXNPbkRlbGV0ZShlbnRyeS5maWxlUGF0aCk7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coYERhdGFiYXNlIHJlY29yZCBtYXJrZWQgYXMgZGVsZXRlZCBmb3IgZmlsZTogJHtlbnRyeS5maWxlUGF0aH1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciByZWNvbmNpbGluZyBkYXRhYmFzZSB3aXRoIHN5bmMgZmlsZTonLCBlcnJvcik7XG5cdFx0XHQvLyBOb24tY3JpdGljYWw7IGRvIG5vdCB0aHJvdy5cblx0XHR9XG5cdH1cblxuXHRhc3luYyBoYW5kbGVDcmVhdGUoZmlsZTogVEFic3RyYWN0RmlsZSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkgfHwgIXRoaXMuc2hvdWxkVHJhY2tGaWxlKGZpbGUucGF0aCkpIHJldHVybjtcblx0XHRjb25zdCBldmVudDogRmlsZUV2ZW50ID0geyB0eXBlOiAnY3JlYXRlJywgZmlsZSwgdGltZXN0YW1wOiBEYXRlLm5vdygpIH07XG5cdFx0YXdhaXQgdGhpcy5xdWV1ZUV2ZW50KGV2ZW50KTtcblx0fVxuXG5cdGFzeW5jIGhhbmRsZU1vZGlmeShmaWxlOiBUQWJzdHJhY3RGaWxlKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB8fCAhdGhpcy5zaG91bGRUcmFja0ZpbGUoZmlsZS5wYXRoKSkgcmV0dXJuO1xuXHRcdGNvbnN0IGV2ZW50OiBGaWxlRXZlbnQgPSB7IHR5cGU6ICdtb2RpZnknLCBmaWxlLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfTtcblx0XHRhd2FpdCB0aGlzLnF1ZXVlRXZlbnQoZXZlbnQpO1xuXHR9XG5cblx0YXN5bmMgaGFuZGxlRGVsZXRlKGZpbGU6IFRBYnN0cmFjdEZpbGUpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHx8ICF0aGlzLnNob3VsZFRyYWNrRmlsZShmaWxlLnBhdGgpKSByZXR1cm47XG5cdFx0Y29uc3QgZXZlbnQ6IEZpbGVFdmVudCA9IHsgdHlwZTogJ2RlbGV0ZScsIGZpbGUsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9O1xuXHRcdGF3YWl0IHRoaXMucXVldWVFdmVudChldmVudCk7XG5cblx0XHQvLyBJZiBvZmZsaW5lIHF1ZXVlIG1hbmFnZXIgaXMgZW5hYmxlZCwgcXVldWUgdGhlIGRlbGV0aW9uIG9wZXJhdGlvbi5cblx0XHRpZiAodGhpcy5vZmZsaW5lUXVldWVNYW5hZ2VyKSB7XG5cdFx0XHRhd2FpdCB0aGlzLm9mZmxpbmVRdWV1ZU1hbmFnZXIucXVldWVPcGVyYXRpb24oe1xuXHRcdFx0XHRvcGVyYXRpb25UeXBlOiAnZGVsZXRlJyxcblx0XHRcdFx0ZmlsZUlkOiBmaWxlLnBhdGgsXG5cdFx0XHRcdHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnN1cGFiYXNlU2VydmljZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UudXBkYXRlRmlsZVN0YXR1c09uRGVsZXRlKGZpbGUucGF0aCk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBkYXRhYmFzZSBmb3IgZGVsZXRlZCBmaWxlOicsIGVycm9yKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gdXBkYXRpbmcgdGhlIHN5bmMgZmlsZVxuXHRcdFx0YXdhaXQgdGhpcy5zeW5jTWFuYWdlci51cGRhdGVTeW5jU3RhdHVzKGZpbGUucGF0aCwgJ09LJywge1xuXHRcdFx0XHRsYXN0TW9kaWZpZWQ6IERhdGUubm93KCksXG5cdFx0XHRcdGhhc2g6ICcnXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRhc3luYyBoYW5kbGVSZW5hbWUoZmlsZTogVEFic3RyYWN0RmlsZSwgb2xkUGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB8fCAhdGhpcy5zaG91bGRUcmFja0ZpbGUoZmlsZS5wYXRoKSkgcmV0dXJuO1xuXHRcdGNvbnN0IGV2ZW50OiBGaWxlRXZlbnQgPSB7IHR5cGU6ICdyZW5hbWUnLCBmaWxlLCBvbGRQYXRoLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfTtcblx0XHRhd2FpdCB0aGlzLnF1ZXVlRXZlbnQoZXZlbnQpO1xuXHRcdGNvbnN0IG5ld0hhc2ggPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUZpbGVIYXNoKGZpbGUpO1xuXHRcdGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5jcmVhdGVGaWxlTWV0YWRhdGEoZmlsZSk7XG5cblx0XHQvLyBJZiBvZmZsaW5lLCBxdWV1ZSByZW5hbWUgb3BlcmF0aW9uXG5cdFx0aWYgKHRoaXMub2ZmbGluZVF1ZXVlTWFuYWdlcikge1xuXHRcdFx0YXdhaXQgdGhpcy5vZmZsaW5lUXVldWVNYW5hZ2VyLnF1ZXVlT3BlcmF0aW9uKHtcblx0XHRcdFx0b3BlcmF0aW9uVHlwZTogJ3JlbmFtZScsXG5cdFx0XHRcdGZpbGVJZDogZmlsZS5wYXRoLFxuXHRcdFx0XHRtZXRhZGF0YTogeyBvbGRQYXRoIH0sXG5cdFx0XHRcdHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnN1cGFiYXNlU2VydmljZSkge1xuXHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UudXBkYXRlRmlsZVZlY3Rvcml6YXRpb25TdGF0dXMobWV0YWRhdGEpO1xuXHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UudXBkYXRlRmlsZVN0YXR1c09uRGVsZXRlKG9sZFBhdGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLnVwZGF0ZVN5bmNTdGF0dXMoZmlsZS5wYXRoLCAnUEVORElORycsIHtcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiBmaWxlLnN0YXQubXRpbWUsXG5cdFx0XHRcdGhhc2g6IG5ld0hhc2hcblx0XHRcdH0pO1xuXHRcdFx0YXdhaXQgdGhpcy5zeW5jTWFuYWdlci51cGRhdGVTeW5jU3RhdHVzKG9sZFBhdGgsICdPSycsIHtcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiBEYXRlLm5vdygpLFxuXHRcdFx0XHRoYXNoOiAnJ1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBxdWV1ZUV2ZW50KGV2ZW50OiBGaWxlRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0aGlzLmV2ZW50UXVldWUucHVzaChldmVudCk7XG5cdFx0aWYgKCF0aGlzLmlzUHJvY2Vzc2luZykge1xuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB0aGlzLnByb2Nlc3NFdmVudFF1ZXVlKCksIHRoaXMucHJvY2Vzc2luZ1RpbWVvdXQpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc0V2ZW50UXVldWUoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKHRoaXMuaXNQcm9jZXNzaW5nIHx8IHRoaXMuZXZlbnRRdWV1ZS5sZW5ndGggPT09IDApIHJldHVybjtcblx0XHR0aGlzLmlzUHJvY2Vzc2luZyA9IHRydWU7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIEdyb3VwIGV2ZW50cyBieSBmaWxlIHBhdGguXG5cdFx0XHRjb25zdCBldmVudHNCeVBhdGggPSBuZXcgTWFwPHN0cmluZywgRmlsZUV2ZW50W10+KCk7XG5cdFx0XHRmb3IgKGNvbnN0IGV2ZW50IG9mIHRoaXMuZXZlbnRRdWV1ZSkge1xuXHRcdFx0XHRjb25zdCBwYXRoID0gZXZlbnQuZmlsZS5wYXRoO1xuXHRcdFx0XHRpZiAoIWV2ZW50c0J5UGF0aC5oYXMocGF0aCkpIHtcblx0XHRcdFx0XHRldmVudHNCeVBhdGguc2V0KHBhdGgsIFtdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRldmVudHNCeVBhdGguZ2V0KHBhdGgpPy5wdXNoKGV2ZW50KTtcblx0XHRcdH1cblx0XHRcdC8vIFByb2Nlc3MgZXZlbnRzIGZvciBlYWNoIGZpbGUuXG5cdFx0XHRmb3IgKGNvbnN0IFtwYXRoLCBldmVudHNdIG9mIGV2ZW50c0J5UGF0aCkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnByb2Nlc3NGaWxlRXZlbnRzKHBhdGgsIGV2ZW50cyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDbGVhciB0aGUgZXZlbnQgcXVldWUuXG5cdFx0XHR0aGlzLmV2ZW50UXVldWUgPSBbXTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ0ZpbGVUcmFja2VyLnByb2Nlc3NFdmVudFF1ZXVlJyB9KTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dGhpcy5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIHByb2Nlc3NGaWxlRXZlbnRzKHBhdGg6IHN0cmluZywgZXZlbnRzOiBGaWxlRXZlbnRbXSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGV2ZW50cy5zb3J0KChhLCBiKSA9PiBhLnRpbWVzdGFtcCAtIGIudGltZXN0YW1wKTtcblx0XHRjb25zdCBmaW5hbEV2ZW50ID0gZXZlbnRzW2V2ZW50cy5sZW5ndGggLSAxXTtcblx0XHR0cnkge1xuXHRcdFx0aWYgKGZpbmFsRXZlbnQudHlwZSAhPT0gJ2RlbGV0ZScpIHtcblx0XHRcdFx0Y29uc3QgbmV3SGFzaCA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlRmlsZUhhc2goZmluYWxFdmVudC5maWxlKTtcblx0XHRcdFx0bGV0IG5lZWRzVmVjdG9yaXppbmcgPSB0cnVlO1xuXHRcdFx0XHRpZiAodGhpcy5zdXBhYmFzZVNlcnZpY2UpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0bmVlZHNWZWN0b3JpemluZyA9IGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLm5lZWRzVmVjdG9yaXppbmcoXG5cdFx0XHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0XHRcdGZpbmFsRXZlbnQuZmlsZS5zdGF0Lm10aW1lLFxuXHRcdFx0XHRcdFx0XHRuZXdIYXNoXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBpZiBmaWxlIG5lZWRzIHZlY3Rvcml6aW5nOicsIGVycm9yKTtcblx0XHRcdFx0XHRcdG5lZWRzVmVjdG9yaXppbmcgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zdCBzeW5jU3RhdHVzID0gYXdhaXQgdGhpcy5zeW5jTWFuYWdlci5nZXRTeW5jU3RhdHVzKHBhdGgpO1xuXHRcdFx0XHRcdGlmIChzeW5jU3RhdHVzICYmIHN5bmNTdGF0dXMuaGFzaCA9PT0gbmV3SGFzaCAmJiBmaW5hbEV2ZW50LmZpbGUuc3RhdC5tdGltZSA8PSBzeW5jU3RhdHVzLmxhc3RNb2RpZmllZCAmJiBzeW5jU3RhdHVzLnN0YXR1cyAhPT0gJ1BFTkRJTkcnKSB7XG5cdFx0XHRcdFx0XHRuZWVkc1ZlY3Rvcml6aW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuZWVkc1ZlY3Rvcml6aW5nKSB7XG5cdFx0XHRcdFx0Y29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLmNyZWF0ZUZpbGVNZXRhZGF0YShmaW5hbEV2ZW50LmZpbGUpO1xuXHRcdFx0XHRcdGlmICh0aGlzLnN1cGFiYXNlU2VydmljZSkge1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UudXBkYXRlRmlsZVZlY3Rvcml6YXRpb25TdGF0dXMobWV0YWRhdGEpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLnVwZGF0ZVN5bmNTdGF0dXMocGF0aCwgJ1BFTkRJTkcnLCB7XG5cdFx0XHRcdFx0XHRcdGxhc3RNb2RpZmllZDogZmluYWxFdmVudC5maWxlLnN0YXQubXRpbWUsXG5cdFx0XHRcdFx0XHRcdGhhc2g6IG5ld0hhc2hcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnRmlsZVRyYWNrZXIucHJvY2Vzc0ZpbGVFdmVudHMnLCBtZXRhZGF0YTogeyBwYXRoLCBldmVudFR5cGU6IGZpbmFsRXZlbnQudHlwZSB9IH0pO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgY2FsY3VsYXRlRmlsZUhhc2goZmlsZTogVEZpbGUpOiBQcm9taXNlPHN0cmluZz4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkKGZpbGUpO1xuXHRcdFx0cmV0dXJuIGF3YWl0IHRoaXMuaGFzaFN0cmluZyhjb250ZW50KTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ0ZpbGVUcmFja2VyLmNhbGN1bGF0ZUZpbGVIYXNoJywgbWV0YWRhdGE6IHsgZmlsZVBhdGg6IGZpbGUucGF0aCB9IH0pO1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgaGFzaFN0cmluZyhzdHI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG5cdFx0Y29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXHRcdGNvbnN0IGRhdGEgPSBlbmNvZGVyLmVuY29kZShzdHIpO1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgZGF0YSk7XG5cdFx0cmV0dXJuIEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSlcblx0XHRcdC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKVxuXHRcdFx0LmpvaW4oJycpO1xuXHR9XG5cblx0cHVibGljIGFzeW5jIGNyZWF0ZUZpbGVNZXRhZGF0YShmaWxlOiBURmlsZSk6IFByb21pc2U8RG9jdW1lbnRNZXRhZGF0YT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkKGZpbGUpO1xuXHRcdFx0Y29uc3QgbGluZUNvdW50ID0gY29udGVudC5zcGxpdCgnXFxuJykubGVuZ3RoO1xuXHRcdFx0bGV0IGFkZGl0aW9uYWxNZXRhZGF0YSA9IHt9O1xuXHRcdFx0aWYgKHRoaXMuc3VwYWJhc2VTZXJ2aWNlKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UuZ2V0RmlsZVZlY3Rvcml6YXRpb25TdGF0dXMoZmlsZS5wYXRoKTtcblx0XHRcdFx0XHRpZiAoc3RhdHVzLmlzVmVjdG9yaXplZCkge1xuXHRcdFx0XHRcdFx0YWRkaXRpb25hbE1ldGFkYXRhID0ge1xuXHRcdFx0XHRcdFx0XHRsYXN0VmVjdG9yaXplZDogc3RhdHVzLmxhc3RWZWN0b3JpemVkLFxuXHRcdFx0XHRcdFx0XHRjb250ZW50SGFzaDogc3RhdHVzLmNvbnRlbnRIYXNoXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGZpbGUgc3RhdHVzIGZyb20gZGF0YWJhc2U6JywgZXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRvYnNpZGlhbklkOiBmaWxlLnBhdGgsXG5cdFx0XHRcdHBhdGg6IGZpbGUucGF0aCxcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiBmaWxlLnN0YXQubXRpbWUsXG5cdFx0XHRcdGNyZWF0ZWQ6IGZpbGUuc3RhdC5jdGltZSxcblx0XHRcdFx0c2l6ZTogZmlsZS5zdGF0LnNpemUsXG5cdFx0XHRcdGN1c3RvbU1ldGFkYXRhOiB7IC4uLmFkZGl0aW9uYWxNZXRhZGF0YSB9LFxuXHRcdFx0XHRsb2M6IHsgbGluZXM6IHsgZnJvbTogMSwgdG86IGxpbmVDb3VudCB9IH0sXG5cdFx0XHRcdHNvdXJjZTogXCJvYnNpZGlhblwiLFxuXHRcdFx0XHRmaWxlX2lkOiBmaWxlLnBhdGgsXG5cdFx0XHRcdGJsb2JUeXBlOiBcInRleHQvbWFya2Rvd25cIlxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ0ZpbGVUcmFja2VyLmNyZWF0ZUZpbGVNZXRhZGF0YScsIG1ldGFkYXRhOiB7IGZpbGVQYXRoOiBmaWxlLnBhdGggfSB9KTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG9ic2lkaWFuSWQ6IGZpbGUucGF0aCxcblx0XHRcdFx0cGF0aDogZmlsZS5wYXRoLFxuXHRcdFx0XHRsYXN0TW9kaWZpZWQ6IGZpbGUuc3RhdC5tdGltZSxcblx0XHRcdFx0Y3JlYXRlZDogZmlsZS5zdGF0LmN0aW1lLFxuXHRcdFx0XHRzaXplOiBmaWxlLnN0YXQuc2l6ZSxcblx0XHRcdFx0Y3VzdG9tTWV0YWRhdGE6IHt9XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cblx0cHJpdmF0ZSBzaG91bGRUcmFja0ZpbGUoZmlsZVBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRcdC8vIEV4dHJhY3QgdGhlIGZpbGUgbmFtZSBmcm9tIHRoZSBwYXRoXG5cdFx0Y29uc3QgZmlsZU5hbWUgPSBmaWxlUGF0aC5zcGxpdCgnLycpLnBvcCgpPy50b0xvd2VyQ2FzZSgpIHx8IGZpbGVQYXRoLnRvTG93ZXJDYXNlKCk7XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IHRoZSBzeW5jIGZpbGUgbmFtZXNcblx0XHRpZiAoXG5cdFx0XHRmaWxlTmFtZSA9PT0gJ19taW5kbWF0cml4c3luYy5tZCcgfHxcblx0XHRcdGZpbGVOYW1lID09PSAnX21pbmRtYXRyaXhzeW5jLm1kLmJhY2t1cCdcblx0XHQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZSBzeW5jIHN0YXR1cyBmb3IgYSBnaXZlbiBmaWxlIGZyb20gdGhlIHN5bmMgZmlsZS5cblx0ICovXG5cdHB1YmxpYyBhc3luYyBnZXRTeW5jU3RhdHVzKHBhdGg6IHN0cmluZykge1xuXHRcdHJldHVybiBhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLmdldFN5bmNTdGF0dXMocGF0aCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0cmlldmUgYWxsIHN5bmMgc3RhdHVzZXMuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgZ2V0QWxsU3luY1N0YXR1c2VzKCkge1xuXHRcdHJldHVybiBhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLmdldEFsbFN5bmNFbnRyaWVzKCk7XG5cdH1cblxuXHQvKipcblx0ICogQWxsb3dzIGxhdGUgYmluZGluZyBvZiB0aGUgU3VwYWJhc2Ugc2VydmljZS5cblx0ICovXG5cdHB1YmxpYyBzZXRTdXBhYmFzZVNlcnZpY2Uoc2VydmljZTogU3VwYWJhc2VTZXJ2aWNlKTogdm9pZCB7XG5cdFx0dGhpcy5zdXBhYmFzZVNlcnZpY2UgPSBzZXJ2aWNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFyIHRoZSBldmVudCBxdWV1ZS5cblx0ICovXG5cdHB1YmxpYyBjbGVhclF1ZXVlKCk6IHZvaWQge1xuXHRcdHRoaXMuZXZlbnRRdWV1ZSA9IFtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgcHJvY2Vzc2luZyB0aW1lb3V0LlxuXHQgKi9cblx0cHVibGljIHNldFByb2Nlc3NpbmdUaW1lb3V0KHRpbWVvdXQ6IG51bWJlcik6IHZvaWQge1xuXHRcdHRoaXMucHJvY2Vzc2luZ1RpbWVvdXQgPSB0aW1lb3V0O1xuXHR9XG59XG4iLCAiLy8gc3JjL3NlcnZpY2VzL1N5bmNGaWxlTWFuYWdlci50c1xuaW1wb3J0IHsgVEZpbGUsIFZhdWx0LCBwYXJzZVlhbWwsIHN0cmluZ2lmeVlhbWwgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBFcnJvckhhbmRsZXIgfSBmcm9tICcuLi91dGlscy9FcnJvckhhbmRsZXInO1xuaW1wb3J0IHsgRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IgfSBmcm9tICcuLi9tb2RlbHMvRG9jdW1lbnRDaHVuayc7XG5pbXBvcnQge1xuXHRTeW5jRmlsZURhdGEsXG5cdFN5bmNWYWxpZGF0aW9uUmVzdWx0LFxuXHRTeW5jRXJyb3JUeXBlLFxuXHRTeW5jU3RhdGUsXG5cdGNyZWF0ZUVtcHR5U3luY0ZpbGVEYXRhLFxuXHR1cGRhdGVEZXZpY2VJblN5bmNGaWxlLFxuXHRhZGRDb25uZWN0aW9uRXZlbnQsXG5cdHVwZGF0ZURhdGFiYXNlU3RhdHVzLFxuXHR1cGRhdGVEZXZpY2VTeW5jVGltZSxcblx0dHJpbVN5bmNIaXN0b3J5QXJyYXlzLFxuXHRTeW5jQ29uZmxpY3Rcbn0gZnJvbSAnLi4vbW9kZWxzL1N5bmNNb2RlbHMnO1xuXG5leHBvcnQgY2xhc3MgU3luY0ZpbGVNYW5hZ2VyIHtcblx0cHJpdmF0ZSBzeW5jRmlsZVBhdGg6IHN0cmluZztcblx0cHJpdmF0ZSBiYWNrdXBQYXRoOiBzdHJpbmc7XG5cdHByaXZhdGUgbGFzdEJhY2t1cDogbnVtYmVyID0gMDtcblx0cHJpdmF0ZSBiYWNrdXBJbnRlcnZhbDogbnVtYmVyO1xuXHRwcml2YXRlIHN5bmNGaWxlOiBURmlsZSB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIGN1cnJlbnRTeW5jRGF0YTogU3luY0ZpbGVEYXRhIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgdmF1bHRJZDogc3RyaW5nO1xuXHRwcml2YXRlIGRldmljZUlkOiBzdHJpbmc7XG5cdHByaXZhdGUgZGV2aWNlTmFtZTogc3RyaW5nO1xuXHRwcml2YXRlIHBsdWdpblZlcnNpb246IHN0cmluZztcblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRwcml2YXRlIHZhdWx0OiBWYXVsdCxcblx0XHRwcml2YXRlIGVycm9ySGFuZGxlcjogRXJyb3JIYW5kbGVyLFxuXHRcdHN5bmNGaWxlUGF0aDogc3RyaW5nID0gJ19taW5kbWF0cml4c3luYy5tZCcsXG5cdFx0YmFja3VwSW50ZXJ2YWw6IG51bWJlciA9IDM2MDAwMDAsIC8vIDEgaG91ciBpbiBtaWxsaXNlY29uZHNcblx0XHR2YXVsdElkOiBzdHJpbmcsXG5cdFx0ZGV2aWNlSWQ6IHN0cmluZyxcblx0XHRkZXZpY2VOYW1lOiBzdHJpbmcsXG5cdFx0cGx1Z2luVmVyc2lvbjogc3RyaW5nXG5cdCkge1xuXHRcdHRoaXMuc3luY0ZpbGVQYXRoID0gc3luY0ZpbGVQYXRoO1xuXHRcdHRoaXMuYmFja3VwUGF0aCA9IGAke3N5bmNGaWxlUGF0aH0uYmFja3VwYDtcblx0XHR0aGlzLmJhY2t1cEludGVydmFsID0gYmFja3VwSW50ZXJ2YWw7XG5cdFx0dGhpcy52YXVsdElkID0gdmF1bHRJZDtcblx0XHR0aGlzLmRldmljZUlkID0gZGV2aWNlSWQ7XG5cdFx0dGhpcy5kZXZpY2VOYW1lID0gZGV2aWNlTmFtZTtcblx0XHR0aGlzLnBsdWdpblZlcnNpb24gPSBwbHVnaW5WZXJzaW9uO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgb3IgdmFsaWRhdGUgdGhlIHN5bmMgZmlsZVxuXHQgKi9cblx0YXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPFN5bmNWYWxpZGF0aW9uUmVzdWx0PiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIENoZWNrIGlmIHN5bmMgZmlsZSBleGlzdHNcblx0XHRcdGNvbnN0IGV4aXN0aW5nRmlsZSA9IHRoaXMudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMuc3luY0ZpbGVQYXRoKTtcblx0XHRcdGlmIChleGlzdGluZ0ZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0XHR0aGlzLnN5bmNGaWxlID0gZXhpc3RpbmdGaWxlO1xuXHRcdFx0XHQvLyBWYWxpZGF0ZSBleGlzdGluZyBmaWxlIGFuZCBwYXJzZSBpdHMgY29udGVudHNcblx0XHRcdFx0Y29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMudmFsaWRhdGVTeW5jRmlsZSgpO1xuXHRcdFx0XHRpZiAoIXZhbGlkYXRpb25SZXN1bHQuaXNWYWxpZCkge1xuXHRcdFx0XHRcdGNvbnN0IHJlY292ZXJlZCA9IGF3YWl0IHRoaXMucmVwYWlyU3luY0ZpbGUoKTtcblx0XHRcdFx0XHRpZiAoIXJlY292ZXJlZCkge1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVTeW5jRmlsZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQ3JlYXRlIG5ldyBzeW5jIGZpbGVcblx0XHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVTeW5jRmlsZSgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ3JlYXRlIGluaXRpYWwgYmFja3VwXG5cdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZUJhY2t1cCgpO1xuXHRcdFx0cmV0dXJuIGF3YWl0IHRoaXMudmFsaWRhdGVTeW5jRmlsZSgpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0XHRjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLmluaXRpYWxpemUnLFxuXHRcdFx0XHRtZXRhZGF0YTogeyBzeW5jRmlsZVBhdGg6IHRoaXMuc3luY0ZpbGVQYXRoIH1cblx0XHRcdH0pO1xuXHRcdFx0Ly8gVHJ5IHRvIGNyZWF0ZSBhIG5ldyBmaWxlIGFzIGEgbGFzdCByZXNvcnRcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMuY3JlYXRlU3luY0ZpbGUoKTtcblx0XHRcdFx0cmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xuXHRcdFx0fSBjYXRjaCAoY3JlYXRlRXJyb3IpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpc1ZhbGlkOiBmYWxzZSxcblx0XHRcdFx0XHRlcnJvcjogYEZhaWxlZCB0byBpbml0aWFsaXplIHN5bmMgZmlsZTogJHtjcmVhdGVFcnJvci5tZXNzYWdlfWBcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIGEgbmV3IHN5bmMgZmlsZSB3aXRoIHRoZSBuZXcgc3RydWN0dXJlXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIGNyZWF0ZVN5bmNGaWxlKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnNvbGUubG9nKCdTdGFydGluZyBzeW5jIGZpbGUgY3JlYXRpb24gd2l0aCB3YWl0IHBlcmlvZHMuLi4nKTtcblxuXHRcdC8vIEluY3JlYXNlZCBkZWxheSBmb3Igc2FmZXIgZmlsZSBvcGVyYXRpb25zXG5cdFx0Y29uc3QgRklMRV9PUF9ERUxBWSA9IDEwMDA7IC8vIDEgc2Vjb25kXG5cblx0XHQvLyBGaXJzdCBjaGVjayBpZiB0aGUgZmlsZSBleGlzdHNcblx0XHRjb25zdCBleGlzdGluZ0ZpbGUgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLnN5bmNGaWxlUGF0aCk7XG5cblx0XHQvLyBDcmVhdGUgbmV3IHN5bmMgZGF0YVxuXHRcdHRoaXMuY3VycmVudFN5bmNEYXRhID0gY3JlYXRlRW1wdHlTeW5jRmlsZURhdGEoXG5cdFx0XHR0aGlzLnZhdWx0SWQsXG5cdFx0XHR0aGlzLmRldmljZUlkLFxuXHRcdFx0dGhpcy5kZXZpY2VOYW1lLFxuXHRcdFx0dGhpcy5wbHVnaW5WZXJzaW9uXG5cdFx0KTtcblxuXHRcdC8vIEdlbmVyYXRlIGluaXRpYWwgY29udGVudFxuXHRcdGNvbnN0IGluaXRpYWxDb250ZW50ID0gdGhpcy5nZW5lcmF0ZVN5bmNGaWxlQ29udGVudCh0aGlzLmN1cnJlbnRTeW5jRGF0YSk7XG5cblx0XHQvLyBJZiBmaWxlIGV4aXN0cywgcHJpb3JpdGl6ZSBtb2RpZnlpbmcgaXQgaW5zdGVhZCBvZiBkZWxldGluZyBhbmQgcmVjcmVhdGluZ1xuXHRcdGlmIChleGlzdGluZ0ZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0V4aXN0aW5nIHN5bmMgZmlsZSBmb3VuZCwgYXR0ZW1wdGluZyB0byBtb2RpZnkgaXQnKTtcblx0XHRcdFx0dGhpcy5zeW5jRmlsZSA9IGV4aXN0aW5nRmlsZTtcblx0XHRcdFx0YXdhaXQgdGhpcy52YXVsdC5tb2RpZnkoZXhpc3RpbmdGaWxlLCBpbml0aWFsQ29udGVudCk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgbW9kaWZpZWQgZXhpc3Rpbmcgc3luYyBmaWxlJyk7XG5cblx0XHRcdFx0Ly8gV2FpdCBhIGJpdCB0byBlbnN1cmUgZmlsZSBzeXN0ZW0gb3BlcmF0aW9ucyBjb21wbGV0ZVxuXHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgRklMRV9PUF9ERUxBWSkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGNhdGNoIChtb2RpZnlFcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBtb2RpZnkgZXhpc3Rpbmcgc3luYyBmaWxlLCB3aWxsIHRyeSBkZWxldGUgYW5kIHJlY3JlYXRlOicsIG1vZGlmeUVycm9yKTtcblxuXHRcdFx0XHQvLyBJZiBtb2RpZmljYXRpb24gZmFpbHMsIHRyeSBkZWxldGUgYW5kIHJlY3JlYXRlIGFwcHJvYWNoXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy52YXVsdC5kZWxldGUoZXhpc3RpbmdGaWxlKTtcblx0XHRcdFx0XHQvLyBMb25nZXIgZGVsYXkgYWZ0ZXIgZGVsZXRpb25cblx0XHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgRklMRV9PUF9ERUxBWSkpO1xuXHRcdFx0XHR9IGNhdGNoIChkZWxldGVFcnJvcikge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgZXhpc3Rpbmcgc3luYyBmaWxlOicsIGRlbGV0ZUVycm9yKTtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBtb2RpZnkgb3IgZGVsZXRlIHN5bmMgZmlsZTogJHttb2RpZnlFcnJvci5tZXNzYWdlfSwgJHtkZWxldGVFcnJvci5tZXNzYWdlfWApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlsZSBkb2Vzbid0IGV4aXN0IG9yIHdhcyBkZWxldGVkLCBwcm9jZWVkIHdpdGggY3JlYXRpb25cblx0XHRjb25zb2xlLmxvZygnV2FpdGluZyBiZWZvcmUgY3JlYXRpbmcgc3luYyBmaWxlLi4uJyk7XG5cdFx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIEZJTEVfT1BfREVMQVkpKTtcblxuXHRcdC8vIE11bHRpcGxlIGF0dGVtcHRzIGZvciBjcmVhdGlvbiB3aXRoIGluY3JlYXNpbmcgZGVsYXlzXG5cdFx0bGV0IGNyZWF0ZUF0dGVtcHRzID0gMDtcblx0XHRjb25zdCBtYXhBdHRlbXB0cyA9IDM7XG5cblx0XHR3aGlsZSAoY3JlYXRlQXR0ZW1wdHMgPCBtYXhBdHRlbXB0cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpcy5zeW5jRmlsZSA9IGF3YWl0IHRoaXMudmF1bHQuY3JlYXRlKHRoaXMuc3luY0ZpbGVQYXRoLCBpbml0aWFsQ29udGVudCk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdTeW5jIGZpbGUgY3JlYXRlZCBzdWNjZXNzZnVsbHknKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9IGNhdGNoIChjcmVhdGVFcnJvcikge1xuXHRcdFx0XHRjcmVhdGVBdHRlbXB0cysrO1xuXHRcdFx0XHRjb25zb2xlLndhcm4oYENyZWF0ZSBhdHRlbXB0ICR7Y3JlYXRlQXR0ZW1wdHN9IGZhaWxlZDpgLCBjcmVhdGVFcnJvcik7XG5cblx0XHRcdFx0aWYgKGNyZWF0ZUF0dGVtcHRzID49IG1heEF0dGVtcHRzKSB7XG5cdFx0XHRcdFx0Ly8gTGFzdCByZXNvcnQ6IGNoZWNrIGlmIGZpbGUgZXhpc3RzIGRlc3BpdGUgY3JlYXRpb24gZXJyb3Jcblx0XHRcdFx0XHRjb25zdCBmaW5hbENoZWNrID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5zeW5jRmlsZVBhdGgpO1xuXHRcdFx0XHRcdGlmIChmaW5hbENoZWNrIGluc3RhbmNlb2YgVEZpbGUpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCdTeW5jIGZpbGUgZXhpc3RzIGRlc3BpdGUgY3JlYXRpb24gZXJyb3IsIHVzaW5nIGl0Jyk7XG5cdFx0XHRcdFx0XHR0aGlzLnN5bmNGaWxlID0gZmluYWxDaGVjaztcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgc3luYyBmaWxlIGFmdGVyICR7bWF4QXR0ZW1wdHN9IGF0dGVtcHRzOiAke2NyZWF0ZUVycm9yLm1lc3NhZ2V9YCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBFeHBvbmVudGlhbCBiYWNrb2ZmIGZvciByZXRyaWVzXG5cdFx0XHRcdGNvbnN0IHdhaXRUaW1lID0gRklMRV9PUF9ERUxBWSAqIChjcmVhdGVBdHRlbXB0cyArIDEpO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhgV2FpdGluZyAke3dhaXRUaW1lfW1zIGJlZm9yZSByZXRyeS4uLmApO1xuXHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgd2FpdFRpbWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBWZXJpZnkgZmlsZSBleGlzdHMgYW5kIGlzIHJlYWRhYmxlXG5cdFx0Y29uc3QgZmlsZUV4aXN0cyA9IHRoaXMudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMuc3luY0ZpbGVQYXRoKTtcblx0XHRpZiAoIWZpbGVFeGlzdHMpIHtcblx0XHRcdHRocm93IHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZVN5bmNFcnJvcihcblx0XHRcdFx0U3luY0Vycm9yVHlwZS5TWU5DX0ZJTEVfTUlTU0lORyxcblx0XHRcdFx0J1N5bmMgZmlsZSBjcmVhdGlvbiBmYWlsZWQgLSBmaWxlIG5vdCBmb3VuZCBhZnRlciB3YWl0IHBlcmlvZCcsXG5cdFx0XHRcdHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci5jcmVhdGVTeW5jRmlsZScgfSxcblx0XHRcdFx0dW5kZWZpbmVkLFxuXHRcdFx0XHR0aGlzLmRldmljZUlkLFxuXHRcdFx0XHRmYWxzZVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRjb25zb2xlLmxvZygnU3luYyBmaWxlIGNyZWF0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBzeW5jIGZpbGUgY29udGVudCBmcm9tIGRhdGFcblx0ICovXG5cdHByaXZhdGUgZ2VuZXJhdGVTeW5jRmlsZUNvbnRlbnQoZGF0YTogU3luY0ZpbGVEYXRhKTogc3RyaW5nIHtcblx0XHQvLyBDb252ZXJ0IGRhdGEgdG8gWUFNTCB1c2luZyBPYnNpZGlhbidzIGJ1aWx0LWluIGZ1bmN0aW9uXG5cdFx0Y29uc3QgeWFtbENvbnRlbnQgPSBzdHJpbmdpZnlZYW1sKGRhdGEpO1xuXHRcdC8vIFJldHVybiBhcyBtYXJrZG93biB3aXRoIFlBTUwgZnJvbnQgbWF0dGVyXG5cdFx0cmV0dXJuIGAtLS1cXG4ke3lhbWxDb250ZW50fS0tLVxcblxcbiMjIE1pbmQgTWF0cml4IFN5bmMgRmlsZVxcblxcblRoaXMgZmlsZSBtYW5hZ2VzIGNyb3NzLWRldmljZSBjb29yZGluYXRpb24gZm9yIHRoZSBNaW5kIE1hdHJpeCBwbHVnaW4uXFxuRG8gbm90IG1vZGlmeSB0aGlzIGZpbGUgbWFudWFsbHkuXFxuYDtcblx0fVxuXG5cdC8qKlxuXHQgKiBWYWxpZGF0ZSBzeW5jIGZpbGUgc3RydWN0dXJlIGFuZCBjb250ZW50XG5cdCAqL1xuXHRhc3luYyB2YWxpZGF0ZVN5bmNGaWxlKCk6IFByb21pc2U8U3luY1ZhbGlkYXRpb25SZXN1bHQ+IHtcblx0XHRpZiAoIXRoaXMuc3luY0ZpbGUpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGlzVmFsaWQ6IGZhbHNlLFxuXHRcdFx0XHRlcnJvcjogJ1N5bmMgZmlsZSBub3QgaW5pdGlhbGl6ZWQnXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkKHRoaXMuc3luY0ZpbGUpO1xuXHRcdFx0Ly8gRXh0cmFjdCBZQU1MIGZyb250IG1hdHRlclxuXHRcdFx0Y29uc3QgeWFtbE1hdGNoID0gY29udGVudC5tYXRjaCgvXi0tLVxcbihbXFxzXFxTXSo/KVxcbi0tLS8pO1xuXHRcdFx0aWYgKCF5YW1sTWF0Y2gpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0ludmFsaWQgc3luYyBmaWxlIGZvcm1hdDogTWlzc2luZyBZQU1MIGZyb250IG1hdHRlci4gV2lsbCByZWNyZWF0ZSBmaWxlLicpO1xuXHRcdFx0XHQvLyBJbnN0ZWFkIG9mIGp1c3QgcmV0dXJuaW5nIGFuIGVycm9yLCByZWNyZWF0ZSB0aGUgZmlsZVxuXHRcdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZVN5bmNGaWxlKCk7XG5cdFx0XHRcdHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcblx0XHRcdH1cblx0XHRcdC8vIFBhcnNlIFlBTUwgY29udGVudCB1c2luZyBPYnNpZGlhbidzIGJ1aWx0LWluIGZ1bmN0aW9uXG5cdFx0XHRjb25zdCB5YW1sQ29udGVudCA9IHlhbWxNYXRjaFsxXTtcblx0XHRcdGxldCBwYXJzZWREYXRhO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cGFyc2VkRGF0YSA9IHBhcnNlWWFtbCh5YW1sQ29udGVudCk7XG5cdFx0XHR9IGNhdGNoIChwYXJzZUVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gcGFyc2UgWUFNTCBjb250ZW50OicsIHBhcnNlRXJyb3IpO1xuXHRcdFx0XHQvLyBJZiBwYXJzaW5nIGZhaWxzLCByZWNyZWF0ZSB0aGUgZmlsZVxuXHRcdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZVN5bmNGaWxlKCk7XG5cdFx0XHRcdHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcblx0XHRcdH1cblx0XHRcdC8vIFZhbGlkYXRlIGJhc2ljIHN0cnVjdHVyZVxuXHRcdFx0aWYgKCFwYXJzZWREYXRhIHx8IHR5cGVvZiBwYXJzZWREYXRhICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnSW52YWxpZCBzeW5jIGZpbGUgZm9ybWF0OiBDYW5ub3QgcGFyc2UgWUFNTCBjb250ZW50LiBXaWxsIHJlY3JlYXRlIGZpbGUuJyk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuY3JlYXRlU3luY0ZpbGUoKTtcblx0XHRcdFx0cmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ2hlY2sgaWYgdGhpcyBpcyBhbiBvbGQgZm9ybWF0IHN5bmMgZmlsZSAoaGFzIGEgdGFibGUgc3RydWN0dXJlKVxuXHRcdFx0aWYgKGNvbnRlbnQuaW5jbHVkZXMoJ3wgRmlsZSBQYXRoIHwgTGFzdCBNb2RpZmllZCB8JykpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0RldGVjdGVkIG9sZCBmb3JtYXQgc3luYyBmaWxlLiBXaWxsIGNvbnZlcnQgdG8gbmV3IGZvcm1hdC4nKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVTeW5jRmlsZSgpO1xuXHRcdFx0XHRyZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07XG5cdFx0XHR9XG5cdFx0XHQvLyBDaGVjayByZXF1aXJlZCBmaWVsZHNcblx0XHRcdGlmIChcblx0XHRcdFx0IXBhcnNlZERhdGEuaGVhZGVyIHx8XG5cdFx0XHRcdCFwYXJzZWREYXRhLmhlYWRlci52YXVsdElkIHx8XG5cdFx0XHRcdCFwYXJzZWREYXRhLmhlYWRlci5sYXN0R2xvYmFsU3luYyB8fFxuXHRcdFx0XHQhcGFyc2VkRGF0YS5oZWFkZXIuZGV2aWNlc1xuXHRcdFx0KSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdJbnZhbGlkIHN5bmMgZmlsZSBmb3JtYXQ6IE1pc3NpbmcgcmVxdWlyZWQgZmllbGRzLiBXaWxsIHJlY3JlYXRlIGZpbGUuJyk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuY3JlYXRlU3luY0ZpbGUoKTtcblx0XHRcdFx0cmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gVmVyaWZ5IHZhdWx0IElEIG1hdGNoZXNcblx0XHRcdGlmIChwYXJzZWREYXRhLmhlYWRlci52YXVsdElkICE9PSB0aGlzLnZhdWx0SWQpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ1ZhdWx0IElEIG1pc21hdGNoLiBPbGQgSUQ6JywgcGFyc2VkRGF0YS5oZWFkZXIudmF1bHRJZCwgJ05ldyBJRDonLCB0aGlzLnZhdWx0SWQpO1xuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIHZhdWx0IElEIHRvIG1hdGNoIHRoZSBjdXJyZW50IG9uZVxuXHRcdFx0XHRwYXJzZWREYXRhLmhlYWRlci52YXVsdElkID0gdGhpcy52YXVsdElkO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3RvcmUgdGhlIHBhcnNlZCBkYXRhXG5cdFx0XHR0aGlzLmN1cnJlbnRTeW5jRGF0YSA9IHBhcnNlZERhdGEgYXMgU3luY0ZpbGVEYXRhO1xuXHRcdFx0Ly8gRW5zdXJlIGFsbCByZXF1aXJlZCBwcm9wZXJ0aWVzIGV4aXN0IGluIHRoZSBkYXRhIHN0cnVjdHVyZVxuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YS5jb25uZWN0aW9uRXZlbnRzKSB0aGlzLmN1cnJlbnRTeW5jRGF0YS5jb25uZWN0aW9uRXZlbnRzID0gW107XG5cdFx0XHRpZiAoIXRoaXMuY3VycmVudFN5bmNEYXRhLnBlbmRpbmdPcGVyYXRpb25zKSB0aGlzLmN1cnJlbnRTeW5jRGF0YS5wZW5kaW5nT3BlcmF0aW9ucyA9IFtdO1xuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YS5jb25mbGljdHMpIHRoaXMuY3VycmVudFN5bmNEYXRhLmNvbmZsaWN0cyA9IFtdO1xuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YS5sYXN0RGF0YWJhc2VDaGVjaykgdGhpcy5jdXJyZW50U3luY0RhdGEubGFzdERhdGFiYXNlQ2hlY2sgPSBEYXRlLm5vdygpO1xuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YS5kYXRhYmFzZVN0YXR1cykgdGhpcy5jdXJyZW50U3luY0RhdGEuZGF0YWJhc2VTdGF0dXMgPSAndW5rbm93bic7XG5cblx0XHRcdC8vIEluaXRpYWxpemUgZmlsZVN0YXR1c2VzIGlmIGl0IGRvZXNuJ3QgZXhpc3Rcblx0XHRcdGlmICghdGhpcy5jdXJyZW50U3luY0RhdGEuaGVhZGVyLmZpbGVTdGF0dXNlcykgdGhpcy5jdXJyZW50U3luY0RhdGEuaGVhZGVyLmZpbGVTdGF0dXNlcyA9IHt9O1xuXG5cdFx0XHQvLyBVcGRhdGUgZGV2aWNlIGluZm9ybWF0aW9uXG5cdFx0XHR0aGlzLmN1cnJlbnRTeW5jRGF0YSA9IHVwZGF0ZURldmljZUluU3luY0ZpbGUoXG5cdFx0XHRcdHRoaXMuY3VycmVudFN5bmNEYXRhLFxuXHRcdFx0XHR0aGlzLmRldmljZUlkLFxuXHRcdFx0XHR0aGlzLmRldmljZU5hbWUsXG5cdFx0XHRcdHRoaXMucGx1Z2luVmVyc2lvblxuXHRcdFx0KTtcblx0XHRcdC8vIFdyaXRlIGJhY2sgdGhlIHVwZGF0ZWQgZGF0YVxuXHRcdFx0YXdhaXQgdGhpcy53cml0ZVN5bmNGaWxlKHRoaXMuY3VycmVudFN5bmNEYXRhKTtcblx0XHRcdHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci52YWxpZGF0ZVN5bmNGaWxlJyB9KTtcblx0XHRcdGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gdmFsaWRhdGUgc3luYyBmaWxlLCB3aWxsIHJlY3JlYXRlOicsIGVycm9yKTtcblx0XHRcdC8vIFRyeSB0byByZWNyZWF0ZSB0aGUgZmlsZSBhcyBhIGxhc3QgcmVzb3J0XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZVN5bmNGaWxlKCk7XG5cdFx0XHRcdHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcblx0XHRcdH0gY2F0Y2ggKGNyZWF0ZUVycm9yKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aXNWYWxpZDogZmFsc2UsXG5cdFx0XHRcdFx0ZXJyb3I6IGBGYWlsZWQgdG8gdmFsaWRhdGUgYW5kIHJlY3JlYXRlIHN5bmMgZmlsZTogJHtjcmVhdGVFcnJvci5tZXNzYWdlfWBcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQWxpYXMgZm9yIHZhbGlkYXRlU3luY0ZpbGUoKSB0byBzdXBwb3J0IGxlZ2FjeSBjYWxscy5cblx0ICovXG5cdGFzeW5jIHZhbGlkYXRlU3luY1N0YXRlKCk6IFByb21pc2U8U3luY1ZhbGlkYXRpb25SZXN1bHQ+IHtcblx0XHRyZXR1cm4gYXdhaXQgdGhpcy52YWxpZGF0ZVN5bmNGaWxlKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVwYWlyIGNvcnJ1cHRlZCBzeW5jIGZpbGVcblx0ICovXG5cdHByaXZhdGUgYXN5bmMgcmVwYWlyU3luY0ZpbGUoKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFRyeSB0byByZXN0b3JlIGZyb20gYmFja3VwIGZpcnN0XG5cdFx0XHRjb25zdCByZXN0b3JlZCA9IGF3YWl0IHRoaXMucmVzdG9yZUZyb21CYWNrdXAoKTtcblx0XHRcdGlmIChyZXN0b3JlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIElmIHJlc3RvcmF0aW9uIGZhaWxzLCBjcmVhdGUgbmV3IHN5bmMgZmlsZVxuXHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVTeW5jRmlsZSgpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7XG5cdFx0XHRcdGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIucmVwYWlyU3luY0ZpbGUnLFxuXHRcdFx0XHRtZXRhZGF0YTogeyBzeW5jRmlsZVBhdGg6IHRoaXMuc3luY0ZpbGVQYXRoIH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkIGFuZCBwYXJzZSB0aGUgc3luYyBmaWxlXG5cdCAqL1xuXHRhc3luYyByZWFkU3luY0ZpbGUoKTogUHJvbWlzZTxTeW5jRmlsZURhdGEgfCBudWxsPiB7XG5cdFx0aWYgKCF0aGlzLnN5bmNGaWxlKSB7XG5cdFx0XHR0aHJvdyB0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVTeW5jRXJyb3IoXG5cdFx0XHRcdFN5bmNFcnJvclR5cGUuU1lOQ19GSUxFX01JU1NJTkcsXG5cdFx0XHRcdCdTeW5jIGZpbGUgbm90IGluaXRpYWxpemVkJyxcblx0XHRcdFx0eyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLnJlYWRTeW5jRmlsZScgfSxcblx0XHRcdFx0dW5kZWZpbmVkLFxuXHRcdFx0XHR0aGlzLmRldmljZUlkXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkKHRoaXMuc3luY0ZpbGUpO1xuXHRcdFx0Ly8gRXh0cmFjdCBZQU1MIGZyb250IG1hdHRlclxuXHRcdFx0Y29uc3QgeWFtbE1hdGNoID0gY29udGVudC5tYXRjaCgvXi0tLVxcbihbXFxzXFxTXSo/KVxcbi0tLS8pO1xuXHRcdFx0aWYgKCF5YW1sTWF0Y2gpIHtcblx0XHRcdFx0dGhyb3cgdGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlU3luY0Vycm9yKFxuXHRcdFx0XHRcdFN5bmNFcnJvclR5cGUuU1lOQ19GSUxFX0NPUlJVUFQsXG5cdFx0XHRcdFx0J0ludmFsaWQgc3luYyBmaWxlIGZvcm1hdDogTWlzc2luZyBZQU1MIGZyb250IG1hdHRlcicsXG5cdFx0XHRcdFx0eyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLnJlYWRTeW5jRmlsZScgfSxcblx0XHRcdFx0XHR1bmRlZmluZWQsXG5cdFx0XHRcdFx0dGhpcy5kZXZpY2VJZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUGFyc2UgWUFNTCBjb250ZW50IHVzaW5nIE9ic2lkaWFuJ3MgYnVpbHQtaW4gZnVuY3Rpb25cblx0XHRcdGNvbnN0IHlhbWxDb250ZW50ID0geWFtbE1hdGNoWzFdO1xuXHRcdFx0Y29uc3QgcGFyc2VkRGF0YSA9IHBhcnNlWWFtbCh5YW1sQ29udGVudCkgYXMgU3luY0ZpbGVEYXRhO1xuXHRcdFx0aWYgKCFwYXJzZWREYXRhIHx8ICFwYXJzZWREYXRhLmhlYWRlcikge1xuXHRcdFx0XHR0aHJvdyB0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVTeW5jRXJyb3IoXG5cdFx0XHRcdFx0U3luY0Vycm9yVHlwZS5TWU5DX0ZJTEVfQ09SUlVQVCxcblx0XHRcdFx0XHQnSW52YWxpZCBzeW5jIGZpbGUgZm9ybWF0OiBNaXNzaW5nIHJlcXVpcmVkIGZpZWxkcycsXG5cdFx0XHRcdFx0eyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLnJlYWRTeW5jRmlsZScgfSxcblx0XHRcdFx0XHR1bmRlZmluZWQsXG5cdFx0XHRcdFx0dGhpcy5kZXZpY2VJZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHBhcnNlZCBkYXRhXG5cdFx0XHR0aGlzLmN1cnJlbnRTeW5jRGF0YSA9IHBhcnNlZERhdGE7XG5cdFx0XHRyZXR1cm4gcGFyc2VkRGF0YTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKCF0aGlzLmVycm9ySGFuZGxlci5pc1N5bmNFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0dGhyb3cgdGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlU3luY0Vycm9yKFxuXHRcdFx0XHRcdFN5bmNFcnJvclR5cGUuU1lOQ19GSUxFX0NPUlJVUFQsXG5cdFx0XHRcdFx0YEVycm9yIHJlYWRpbmcgc3luYyBmaWxlOiAke2Vycm9yLm1lc3NhZ2V9YCxcblx0XHRcdFx0XHR7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIucmVhZFN5bmNGaWxlJyB9LFxuXHRcdFx0XHRcdHVuZGVmaW5lZCxcblx0XHRcdFx0XHR0aGlzLmRldmljZUlkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogV3JpdGUgc3luYyBkYXRhIHRvIHRoZSBzeW5jIGZpbGVcblx0ICovXG5cdGFzeW5jIHdyaXRlU3luY0ZpbGUoZGF0YTogU3luY0ZpbGVEYXRhKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCF0aGlzLnN5bmNGaWxlKSB7XG5cdFx0XHR0aHJvdyB0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVTeW5jRXJyb3IoXG5cdFx0XHRcdFN5bmNFcnJvclR5cGUuU1lOQ19GSUxFX01JU1NJTkcsXG5cdFx0XHRcdCdTeW5jIGZpbGUgbm90IGluaXRpYWxpemVkJyxcblx0XHRcdFx0eyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLndyaXRlU3luY0ZpbGUnIH0sXG5cdFx0XHRcdHVuZGVmaW5lZCxcblx0XHRcdFx0dGhpcy5kZXZpY2VJZFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gVXBkYXRlIHN5bmMgZmlsZSBjb250ZW50XG5cdFx0XHRjb25zdCBjb250ZW50ID0gdGhpcy5nZW5lcmF0ZVN5bmNGaWxlQ29udGVudChkYXRhKTtcblx0XHRcdGF3YWl0IHRoaXMudmF1bHQubW9kaWZ5KHRoaXMuc3luY0ZpbGUsIGNvbnRlbnQpO1xuXHRcdFx0Ly8gVXBkYXRlIGNhY2hlZCBkYXRhXG5cdFx0XHR0aGlzLmN1cnJlbnRTeW5jRGF0YSA9IGRhdGE7XG5cdFx0XHQvLyBDcmVhdGUgYmFja3VwIGlmIG5lZWRlZFxuXHRcdFx0aWYgKERhdGUubm93KCkgLSB0aGlzLmxhc3RCYWNrdXAgPj0gdGhpcy5iYWNrdXBJbnRlcnZhbCkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZUJhY2t1cCgpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aHJvdyB0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVTeW5jRXJyb3IoXG5cdFx0XHRcdFN5bmNFcnJvclR5cGUuVU5LTk9XTl9FUlJPUixcblx0XHRcdFx0YEZhaWxlZCB0byB3cml0ZSBzeW5jIGZpbGU6ICR7ZXJyb3IubWVzc2FnZX1gLFxuXHRcdFx0XHR7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIud3JpdGVTeW5jRmlsZScgfSxcblx0XHRcdFx0dW5kZWZpbmVkLFxuXHRcdFx0XHR0aGlzLmRldmljZUlkXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBiYWNrdXAgb2YgdGhlIHN5bmMgZmlsZVxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBjcmVhdGVCYWNrdXAoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCF0aGlzLnN5bmNGaWxlKSByZXR1cm47XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHQucmVhZCh0aGlzLnN5bmNGaWxlKTtcblx0XHRcdGNvbnN0IGJhY2t1cEZpbGUgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLmJhY2t1cFBhdGgpO1xuXHRcdFx0aWYgKGJhY2t1cEZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnZhdWx0Lm1vZGlmeShiYWNrdXBGaWxlLCBjb250ZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMudmF1bHQuY3JlYXRlKHRoaXMuYmFja3VwUGF0aCwgY29udGVudCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmxhc3RCYWNrdXAgPSBEYXRlLm5vdygpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLmNyZWF0ZUJhY2t1cCcgfSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlc3RvcmUgc3luYyBmaWxlIGZyb20gYmFja3VwXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIHJlc3RvcmVGcm9tQmFja3VwKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdGNvbnN0IGJhY2t1cEZpbGUgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLmJhY2t1cFBhdGgpO1xuXHRcdGlmICghKGJhY2t1cEZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHQucmVhZChiYWNrdXBGaWxlKTtcblx0XHRcdGlmICh0aGlzLnN5bmNGaWxlKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMudmF1bHQubW9kaWZ5KHRoaXMuc3luY0ZpbGUsIGNvbnRlbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zeW5jRmlsZSA9IGF3YWl0IHRoaXMudmF1bHQuY3JlYXRlKHRoaXMuc3luY0ZpbGVQYXRoLCBjb250ZW50KTtcblx0XHRcdH1cblx0XHRcdC8vIFRyeSB0byBwYXJzZSB0aGUgcmVzdG9yZWQgY29udGVudFxuXHRcdFx0Y29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMudmFsaWRhdGVTeW5jRmlsZSgpO1xuXHRcdFx0cmV0dXJuIHZhbGlkYXRpb25SZXN1bHQuaXNWYWxpZDtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci5yZXN0b3JlRnJvbUJhY2t1cCcgfSk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbiBzdGF0dXNcblx0ICovXG5cdGFzeW5jIHVwZGF0ZURhdGFiYXNlU3RhdHVzKHN0YXR1czogJ2F2YWlsYWJsZScgfCAndW5hdmFpbGFibGUnIHwgJ3Vua25vd24nKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFJlYWQgY3VycmVudCBkYXRhIGlmIG5vdCBjYWNoZWRcblx0XHRcdGlmICghdGhpcy5jdXJyZW50U3luY0RhdGEpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy5yZWFkU3luY0ZpbGUoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHRcdC8vIFVwZGF0ZSBzdGF0dXNcblx0XHRcdFx0Y29uc3QgdXBkYXRlZERhdGEgPSB1cGRhdGVEYXRhYmFzZVN0YXR1cyh0aGlzLmN1cnJlbnRTeW5jRGF0YSwgc3RhdHVzKTtcblx0XHRcdFx0Ly8gSWYgc3RhdHVzIGNoYW5nZWQgdG8gdW5hdmFpbGFibGUsIGFkZCBjb25uZWN0aW9uIGV2ZW50XG5cdFx0XHRcdGlmIChzdGF0dXMgPT09ICd1bmF2YWlsYWJsZScgJiYgdGhpcy5jdXJyZW50U3luY0RhdGEuZGF0YWJhc2VTdGF0dXMgIT09ICd1bmF2YWlsYWJsZScpIHtcblx0XHRcdFx0XHR1cGRhdGVkRGF0YS5jb25uZWN0aW9uRXZlbnRzLnB1c2goe1xuXHRcdFx0XHRcdFx0dGltZXN0YW1wOiBEYXRlLm5vdygpLFxuXHRcdFx0XHRcdFx0ZXZlbnRUeXBlOiAnZGlzY29ubmVjdGVkJyxcblx0XHRcdFx0XHRcdGRldmljZUlkOiB0aGlzLmRldmljZUlkLFxuXHRcdFx0XHRcdFx0ZGV0YWlsczogJ0RhdGFiYXNlIGNvbm5lY3Rpb24gbG9zdCdcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBJZiBzdGF0dXMgY2hhbmdlZCB0byBhdmFpbGFibGUsIGFkZCBjb25uZWN0aW9uIGV2ZW50XG5cdFx0XHRcdGlmIChzdGF0dXMgPT09ICdhdmFpbGFibGUnICYmIHRoaXMuY3VycmVudFN5bmNEYXRhLmRhdGFiYXNlU3RhdHVzICE9PSAnYXZhaWxhYmxlJykge1xuXHRcdFx0XHRcdHVwZGF0ZWREYXRhLmNvbm5lY3Rpb25FdmVudHMucHVzaCh7XG5cdFx0XHRcdFx0XHR0aW1lc3RhbXA6IERhdGUubm93KCksXG5cdFx0XHRcdFx0XHRldmVudFR5cGU6ICdjb25uZWN0ZWQnLFxuXHRcdFx0XHRcdFx0ZGV2aWNlSWQ6IHRoaXMuZGV2aWNlSWQsXG5cdFx0XHRcdFx0XHRkZXRhaWxzOiAnRGF0YWJhc2UgY29ubmVjdGlvbiBlc3RhYmxpc2hlZCdcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBUcmltIGFycmF5cyB0byBwcmV2ZW50IGV4Y2Vzc2l2ZSBncm93dGhcblx0XHRcdFx0Y29uc3QgdHJpbW1lZERhdGEgPSB0cmltU3luY0hpc3RvcnlBcnJheXModXBkYXRlZERhdGEpO1xuXHRcdFx0XHQvLyBXcml0ZSB1cGRhdGVkIGRhdGFcblx0XHRcdFx0YXdhaXQgdGhpcy53cml0ZVN5bmNGaWxlKHRyaW1tZWREYXRhKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci51cGRhdGVEYXRhYmFzZVN0YXR1cycsXG5cdFx0XHRcdG1ldGFkYXRhOiB7IHN0YXR1cyB9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIGRldmljZSBzeW5jIHRpbWVzdGFtcCBhbmQgc3RhdHVzXG5cdCAqL1xuXHRhc3luYyB1cGRhdGVEZXZpY2VTeW5jVGltZXN0YW1wKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBSZWFkIGN1cnJlbnQgZGF0YSBpZiBub3QgY2FjaGVkXG5cdFx0XHRpZiAoIXRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMucmVhZFN5bmNGaWxlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5jdXJyZW50U3luY0RhdGEpIHtcblx0XHRcdFx0Ly8gVXBkYXRlIGRldmljZSBzeW5jIHRpbWVcblx0XHRcdFx0Y29uc3QgdXBkYXRlZERhdGEgPSB1cGRhdGVEZXZpY2VTeW5jVGltZSh0aGlzLmN1cnJlbnRTeW5jRGF0YSwgdGhpcy5kZXZpY2VJZCk7XG5cdFx0XHRcdC8vIFdyaXRlIHVwZGF0ZWQgZGF0YVxuXHRcdFx0XHRhd2FpdCB0aGlzLndyaXRlU3luY0ZpbGUodXBkYXRlZERhdGEpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLnVwZGF0ZURldmljZVN5bmNUaW1lc3RhbXAnIH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiAqKk5ldyBNZXRob2Q6Kipcblx0ICogVXBkYXRlcyB0aGUgc3luYyBzdGF0dXMgZm9yIGEgZ2l2ZW4gZmlsZSBpbiB0aGUgc3luYyBmaWxlLlxuXHQgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGFzIGEgZmFsbGJhY2sgd2hlbiB0aGUgZGF0YWJhc2UgaXNuJ3QgYXZhaWxhYmxlLlxuXHQgKi9cblx0YXN5bmMgdXBkYXRlU3luY1N0YXR1cyhmaWxlUGF0aDogc3RyaW5nLCBzdGF0dXM6IHN0cmluZywgYWRkaXRpb25hbERhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQcm9taXNlPHZvaWQ+IHtcblx0XHQvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgY3VycmVudCBzeW5jIGRhdGFcblx0XHRpZiAoIXRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHRhd2FpdCB0aGlzLnJlYWRTeW5jRmlsZSgpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5jdXJyZW50U3luY0RhdGEpIHtcblx0XHRcdC8vIEFzc3VtaW5nIHlvdXIgc3luYyBmaWxlIGhlYWRlciBjb250YWlucyBhIGZpbGVTdGF0dXNlcyBtYXBcblx0XHRcdHRoaXMuY3VycmVudFN5bmNEYXRhLmhlYWRlci5maWxlU3RhdHVzZXMgPSB0aGlzLmN1cnJlbnRTeW5jRGF0YS5oZWFkZXIuZmlsZVN0YXR1c2VzIHx8IHt9O1xuXHRcdFx0dGhpcy5jdXJyZW50U3luY0RhdGEuaGVhZGVyLmZpbGVTdGF0dXNlc1tmaWxlUGF0aF0gPSB7XG5cdFx0XHRcdHN0YXR1cyxcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiBhZGRpdGlvbmFsRGF0YS5sYXN0TW9kaWZpZWQsXG5cdFx0XHRcdGhhc2g6IGFkZGl0aW9uYWxEYXRhLmhhc2gsXG5cdFx0XHRcdHVwZGF0ZWRBdDogRGF0ZS5ub3coKVxuXHRcdFx0fTtcblx0XHRcdGF3YWl0IHRoaXMud3JpdGVTeW5jRmlsZSh0aGlzLmN1cnJlbnRTeW5jRGF0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlN5bmMgZmlsZSBkYXRhIHVuYXZhaWxhYmxlIGZvciB1cGRhdGVTeW5jU3RhdHVzXCIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBzeW5jIHN0YXR1cyBmb3IgYSBzcGVjaWZpYyBmaWxlIHBhdGguXG5cdCAqL1xuXHRhc3luYyBnZXRTeW5jU3RhdHVzKHBhdGg6IHN0cmluZyk6IFByb21pc2U8eyBzdGF0dXM6IHN0cmluZzsgbGFzdE1vZGlmaWVkOiBudW1iZXI7IGhhc2g6IHN0cmluZyB9IHwgbnVsbD4ge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMucmVhZFN5bmNGaWxlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmN1cnJlbnRTeW5jRGF0YSAmJiB0aGlzLmN1cnJlbnRTeW5jRGF0YS5oZWFkZXIuZmlsZVN0YXR1c2VzKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmN1cnJlbnRTeW5jRGF0YS5oZWFkZXIuZmlsZVN0YXR1c2VzW3BhdGhdIHx8IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLmdldFN5bmNTdGF0dXMnLCBtZXRhZGF0YTogeyBwYXRoIH0gfSk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGFsbCBwZW5kaW5nIG9wZXJhdGlvbnNcblx0ICovXG5cdGFzeW5jIGdldFBlbmRpbmdPcGVyYXRpb25zKCk6IFByb21pc2U8QXJyYXk8e1xuXHRcdGlkOiBzdHJpbmc7XG5cdFx0ZmlsZUlkOiBzdHJpbmc7XG5cdFx0b3BlcmF0aW9uVHlwZTogc3RyaW5nO1xuXHRcdHRpbWVzdGFtcDogbnVtYmVyO1xuXHRcdGRldmljZUlkOiBzdHJpbmc7XG5cdFx0bWV0YWRhdGE/OiBhbnk7XG5cdFx0c3RhdHVzOiBzdHJpbmc7XG5cdH0+PiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFJlYWQgY3VycmVudCBkYXRhIGlmIG5vdCBjYWNoZWRcblx0XHRcdGlmICghdGhpcy5jdXJyZW50U3luY0RhdGEpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy5yZWFkU3luY0ZpbGUoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmN1cnJlbnRTeW5jRGF0YT8ucGVuZGluZ09wZXJhdGlvbnMgfHwgW107XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIuZ2V0UGVuZGluZ09wZXJhdGlvbnMnIH0pO1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgY3VycmVudCBzeW5jIHN0YXRlXG5cdCAqL1xuXHRhc3luYyBnZXRTeW5jU3RhdGUoKTogUHJvbWlzZTxTeW5jU3RhdGU+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gUmVhZCBjdXJyZW50IGRhdGEgaWYgbm90IGNhY2hlZFxuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnJlYWRTeW5jRmlsZSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuY3VycmVudFN5bmNEYXRhPy5oZWFkZXIuc3luY1N0YXRlIHx8IFN5bmNTdGF0ZS5VTktOT1dOO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLmdldFN5bmNTdGF0ZScgfSk7XG5cdFx0XHRyZXR1cm4gU3luY1N0YXRlLlVOS05PV047XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhbGwga25vd24gZGV2aWNlc1xuXHQgKi9cblx0YXN5bmMgZ2V0S25vd25EZXZpY2VzKCk6IFByb21pc2U8UmVjb3JkPHN0cmluZywge1xuXHRcdGRldmljZUlkOiBzdHJpbmc7XG5cdFx0bmFtZTogc3RyaW5nO1xuXHRcdHBsYXRmb3JtOiBzdHJpbmc7XG5cdFx0bGFzdFNlZW46IG51bWJlcjtcblx0XHRsYXN0U3luY1RpbWU6IG51bWJlcjtcblx0fT4+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gUmVhZCBjdXJyZW50IGRhdGEgaWYgbm90IGNhY2hlZFxuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnJlYWRTeW5jRmlsZSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuY3VycmVudFN5bmNEYXRhPy5oZWFkZXIuZGV2aWNlcyB8fCB7fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci5nZXRLbm93bkRldmljZXMnIH0pO1xuXHRcdFx0cmV0dXJuIHt9O1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGVyZSBhcmUgY29uZmxpY3RzIHRoYXQgbmVlZCByZXNvbHV0aW9uXG5cdCAqL1xuXHRhc3luYyBkZXRlY3RDb25mbGljdHMoKTogUHJvbWlzZTxTeW5jQ29uZmxpY3RbXT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMucmVhZFN5bmNGaWxlKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBFbmhhbmNlZDogRmlsdGVyIGZvciBjb25mbGljdHMgd2l0aCBtb3JlIGRldGFpbGVkIG1ldGFkYXRhIChpZiBuZWVkZWQpXG5cdFx0XHRjb25zdCBwZW5kaW5nQ29uZmxpY3RzID0gdGhpcy5jdXJyZW50U3luY0RhdGE/LmNvbmZsaWN0cy5maWx0ZXIoXG5cdFx0XHRcdGNvbmZsaWN0ID0+IGNvbmZsaWN0LnJlc29sdXRpb25TdGF0dXMgPT09ICdwZW5kaW5nJ1xuXHRcdFx0KSB8fCBbXTtcblx0XHRcdHJldHVybiBwZW5kaW5nQ29uZmxpY3RzO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLmRldGVjdENvbmZsaWN0cycgfSk7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEF0dGVtcHQgdG8gcmVzb2x2ZSBhIGNvbmZsaWN0IGJhc2VkIG9uIGEgZ2l2ZW4gcmVzb2x1dGlvbiBzdHJhdGVneS5cblx0ICogU3VwcG9ydHMgc3RyYXRlZ2llczpcblx0ICogLSBcIm5ld2VzdC13aW5zXCI6IEF1dG9tYXRpY2FsbHkgcmVzb2x2ZXMgYnkgZmF2b3JpbmcgdGhlIG1vc3QgcmVjZW50IHVwZGF0ZS5cblx0ICogLSBcImtlZXAtYm90aFwiOiBNYXJrcyBhcyByZXNvbHZlZCBhbmQgbGVhdmVzIGJvdGggdmVyc2lvbnMgaW50YWN0LlxuXHQgKiAtIFwibWFudWFsXCI6IEZsYWdzIHRoZSBjb25mbGljdCBmb3IgbWFudWFsIGludGVydmVudGlvbiAoZG9lcyBub3QgYXV0by1yZXNvbHZlKS5cblx0ICovXG5cdGFzeW5jIHJlc29sdmVDb25mbGljdChjb25mbGljdElkOiBzdHJpbmcsIHJlc29sdXRpb25TdHJhdGVneTogJ25ld2VzdC13aW5zJyB8ICdtYW51YWwnIHwgJ2tlZXAtYm90aCcpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnJlYWRTeW5jRmlsZSgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRmluZCB0aGUgY29uZmxpY3QgYnkgSURcblx0XHRcdGNvbnN0IGNvbmZsaWN0SW5kZXggPSB0aGlzLmN1cnJlbnRTeW5jRGF0YT8uY29uZmxpY3RzLmZpbmRJbmRleChjID0+IGMuaWQgPT09IGNvbmZsaWN0SWQpO1xuXHRcdFx0aWYgKGNvbmZsaWN0SW5kZXggPT09IHVuZGVmaW5lZCB8fCBjb25mbGljdEluZGV4IDwgMCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0NvbmZsaWN0IG5vdCBmb3VuZDonLCBjb25mbGljdElkKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgY29uZmxpY3QgPSB0aGlzLmN1cnJlbnRTeW5jRGF0YSEuY29uZmxpY3RzW2NvbmZsaWN0SW5kZXhdO1xuXHRcdFx0c3dpdGNoIChyZXNvbHV0aW9uU3RyYXRlZ3kpIHtcblx0XHRcdFx0Y2FzZSAnbmV3ZXN0LXdpbnMnOlxuXHRcdFx0XHRcdC8vIEluIGEgcmVhbCBzY2VuYXJpbywgY29tcGFyZSB0aW1lc3RhbXBzIG9yIGNvbnRlbnQgaGFzaGVzIGhlcmUuXG5cdFx0XHRcdFx0Y29uZmxpY3QucmVzb2x1dGlvblN0cmF0ZWd5ID0gJ25ld2VzdC13aW5zJztcblx0XHRcdFx0XHRjb25mbGljdC5yZXNvbHV0aW9uU3RhdHVzID0gJ3Jlc29sdmVkJztcblx0XHRcdFx0XHRjb25mbGljdC5yZXNvbHZlZEF0ID0gRGF0ZS5ub3coKTtcblx0XHRcdFx0XHRjb25mbGljdC5yZXNvbHZlZEJ5ID0gdGhpcy5kZXZpY2VJZDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAna2VlcC1ib3RoJzpcblx0XHRcdFx0XHQvLyBPcHRpb25hbGx5LCBkdXBsaWNhdGUgdGhlIGZpbGUgZW50cnkgaW4gdGhlIGRhdGFiYXNlIGFuZCBtYXJrIGNvbmZsaWN0IGFzIHJlc29sdmVkLlxuXHRcdFx0XHRcdGNvbmZsaWN0LnJlc29sdXRpb25TdHJhdGVneSA9ICdrZWVwLWJvdGgnO1xuXHRcdFx0XHRcdGNvbmZsaWN0LnJlc29sdXRpb25TdGF0dXMgPSAncmVzb2x2ZWQnO1xuXHRcdFx0XHRcdGNvbmZsaWN0LnJlc29sdmVkQXQgPSBEYXRlLm5vdygpO1xuXHRcdFx0XHRcdGNvbmZsaWN0LnJlc29sdmVkQnkgPSB0aGlzLmRldmljZUlkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdtYW51YWwnOlxuXHRcdFx0XHRcdC8vIERvIG5vdCBhdXRvLXJlc29sdmU7IGZsYWcgZm9yIG1hbnVhbCBpbnRlcnZlbnRpb24uXG5cdFx0XHRcdFx0Y29uZmxpY3QucmVzb2x1dGlvblN0cmF0ZWd5ID0gJ21hbnVhbCc7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ01hbnVhbCByZXNvbHV0aW9uIHJlcXVpcmVkIGZvciBjb25mbGljdDonLCBjb25mbGljdElkKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCByZXNvbHV0aW9uIHN0cmF0ZWd5Jyk7XG5cdFx0XHR9XG5cdFx0XHRhd2FpdCB0aGlzLndyaXRlU3luY0ZpbGUodGhpcy5jdXJyZW50U3luY0RhdGEhKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLnJlc29sdmVDb25mbGljdCcsIG1ldGFkYXRhOiB7IGNvbmZsaWN0SWQgfSB9KTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQXR0ZW1wdCB0byByZXNvbHZlIGFsbCBkZXRlY3RlZCBjb25mbGljdHMgdXNpbmcgYSBkZWZhdWx0IHN0cmF0ZWd5LlxuXHQgKi9cblx0YXN5bmMgcmVzb2x2ZUFsbENvbmZsaWN0cyhkZWZhdWx0U3RyYXRlZ3k6ICduZXdlc3Qtd2lucycgfCAnbWFudWFsJyB8ICdrZWVwLWJvdGgnID0gJ25ld2VzdC13aW5zJyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb25mbGljdHMgPSBhd2FpdCB0aGlzLmRldGVjdENvbmZsaWN0cygpO1xuXHRcdFx0Zm9yIChjb25zdCBjb25mbGljdCBvZiBjb25mbGljdHMpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy5yZXNvbHZlQ29uZmxpY3QoY29uZmxpY3QuaWQsIGRlZmF1bHRTdHJhdGVneSk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIucmVzb2x2ZUFsbENvbmZsaWN0cycgfSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgbGFzdCBzeW5jIHRpbWVzdGFtcCBpbiB0aGUgc3luYyBmaWxlIGhlYWRlci5cblx0ICovXG5cdGFzeW5jIHVwZGF0ZUxhc3RTeW5jKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMucmVhZFN5bmNGaWxlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5jdXJyZW50U3luY0RhdGEpIHtcblx0XHRcdFx0dGhpcy5jdXJyZW50U3luY0RhdGEuaGVhZGVyLmxhc3RHbG9iYWxTeW5jID0gRGF0ZS5ub3coKTtcblx0XHRcdFx0YXdhaXQgdGhpcy53cml0ZVN5bmNGaWxlKHRoaXMuY3VycmVudFN5bmNEYXRhKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci51cGRhdGVMYXN0U3luYycgfSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYWxsIHN5bmMgZW50cmllcyBmcm9tIHRoZSBzeW5jIGZpbGUuXG5cdCAqL1xuXHRhc3luYyBnZXRBbGxTeW5jRW50cmllcygpOiBQcm9taXNlPEFycmF5PHsgZmlsZVBhdGg6IHN0cmluZzsgc3RhdHVzOiBzdHJpbmc7IGxhc3RNb2RpZmllZDogbnVtYmVyOyBoYXNoOiBzdHJpbmcgfT4+IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnJlYWRTeW5jRmlsZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5jdXJyZW50U3luY0RhdGEgJiYgdGhpcy5jdXJyZW50U3luY0RhdGEuaGVhZGVyLmZpbGVTdGF0dXNlcykge1xuXHRcdFx0XHRyZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy5jdXJyZW50U3luY0RhdGEuaGVhZGVyLmZpbGVTdGF0dXNlcykubWFwKChbZmlsZVBhdGgsIGRhdGFdKSA9PiAoe1xuXHRcdFx0XHRcdGZpbGVQYXRoLFxuXHRcdFx0XHRcdHN0YXR1czogZGF0YS5zdGF0dXMsXG5cdFx0XHRcdFx0bGFzdE1vZGlmaWVkOiBkYXRhLmxhc3RNb2RpZmllZCxcblx0XHRcdFx0XHRoYXNoOiBkYXRhLmhhc2hcblx0XHRcdFx0fSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIuZ2V0QWxsU3luY0VudHJpZXMnIH0pO1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBdHRlbXB0IHJlY292ZXJ5IG9wZXJhdGlvbnMgd2hlbiBzeW5jIGlzc3VlcyBhcmUgZGV0ZWN0ZWQuXG5cdCAqL1xuXHRhc3luYyBhdHRlbXB0UmVjb3ZlcnkoKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIEF0dGVtcHQgdG8gcmVzdG9yZSBmcm9tIGJhY2t1cFxuXHRcdFx0Y29uc3QgcmVjb3ZlcmVkID0gYXdhaXQgdGhpcy5yZXN0b3JlRnJvbUJhY2t1cCgpO1xuXHRcdFx0aWYgKHJlY292ZXJlZCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IHJlY292ZXJlZCBmcm9tIGJhY2t1cCcpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYmFja3VwIHJlc3RvcmF0aW9uIGZhaWxzLCB0cnkgdG8gcmVjcmVhdGUgdGhlIHN5bmMgZmlsZVxuXHRcdFx0Y29uc29sZS5sb2coJ0JhY2t1cCByZXN0b3JhdGlvbiBmYWlsZWQsIGF0dGVtcHRpbmcgdG8gcmVjcmVhdGUgc3luYyBmaWxlJyk7XG5cdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZVN5bmNGaWxlKCk7XG5cblx0XHRcdC8vIFZlcmlmeSB0aGUgbmV3IGZpbGUgaXMgdmFsaWRcblx0XHRcdGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBhd2FpdCB0aGlzLnZhbGlkYXRlU3luY0ZpbGUoKTtcblx0XHRcdHJldHVybiB2YWxpZGF0aW9uUmVzdWx0LmlzVmFsaWQ7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIuYXR0ZW1wdFJlY292ZXJ5JyB9KTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cbn1cbiIsICIvLyBzcmMvbW9kZWxzL1N5bmNNb2RlbHMudHNcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBzdHJ1Y3R1cmUgYW5kIHR5cGVzIGZvciBzeW5jIGZpbGUgY29vcmRpbmF0aW9uXG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGV2aWNlIGtub3duIGJ5IHRoZSBzeW5jIHN5c3RlbVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNEZXZpY2Uge1xuICAgIGRldmljZUlkOiBzdHJpbmc7ICAgICAgICAgLy8gVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgZGV2aWNlXG4gICAgbmFtZTogc3RyaW5nOyAgICAgICAgICAgICAvLyBVc2VyLWZyaWVuZGx5IGRldmljZSBuYW1lXG4gICAgcGxhdGZvcm06IHN0cmluZzsgICAgICAgICAvLyBPcGVyYXRpbmcgc3lzdGVtL3BsYXRmb3JtXG4gICAgbGFzdFNlZW46IG51bWJlcjsgICAgICAgICAvLyBUaW1lc3RhbXAgd2hlbiBkZXZpY2Ugd2FzIGxhc3QgYWN0aXZlXG4gICAgbGFzdFN5bmNUaW1lOiBudW1iZXI7ICAgICAvLyBMYXN0IHN1Y2Nlc3NmdWwgZGF0YWJhc2Ugc3luYyB0aW1lc3RhbXBcbiAgICBvYnNpZGlhblZlcnNpb24/OiBzdHJpbmc7IC8vIE9ic2lkaWFuIHZlcnNpb24gKG9wdGlvbmFsKVxuICAgIHBsdWdpblZlcnNpb24/OiBzdHJpbmc7ICAgLy8gUGx1Z2luIHZlcnNpb24gKG9wdGlvbmFsKVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIG92ZXJhbGwgc3luYyBzdGF0ZVxuICovXG5leHBvcnQgZW51bSBTeW5jU3RhdGUge1xuICAgIFVOS05PV04gPSAndW5rbm93bicsXG4gICAgSU5JVElBTElaSU5HID0gJ2luaXRpYWxpemluZycsXG4gICAgT05MSU5FID0gJ29ubGluZScsXG4gICAgT0ZGTElORSA9ICdvZmZsaW5lJyxcbiAgICBFUlJPUiA9ICdlcnJvcicsXG4gICAgQ09ORkxJQ1QgPSAnY29uZmxpY3QnXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbm5lY3Rpb24gZXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0aW9uRXZlbnQge1xuICAgIHRpbWVzdGFtcDogbnVtYmVyO1xuICAgIGV2ZW50VHlwZTogJ2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJztcbiAgICBkZXZpY2VJZDogc3RyaW5nO1xuICAgIGRldGFpbHM/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHN5bmMgb3BlcmF0aW9uIHBlcmZvcm1lZCBkdXJpbmcgb2ZmbGluZSBtb2RlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGVuZGluZ09wZXJhdGlvbiB7XG4gICAgaWQ6IHN0cmluZzsgICAgICAgICAgICAgICAvLyBVbmlxdWUgb3BlcmF0aW9uIElEXG4gICAgZmlsZUlkOiBzdHJpbmc7ICAgICAgICAgICAvLyBGaWxlIHBhdGggdGhpcyBvcGVyYXRpb24gYWZmZWN0c1xuICAgIG9wZXJhdGlvblR5cGU6ICdjcmVhdGUnIHwgJ3VwZGF0ZScgfCAnZGVsZXRlJyB8ICdyZW5hbWUnO1xuICAgIHRpbWVzdGFtcDogbnVtYmVyOyAgICAgICAgLy8gV2hlbiB0aGUgb3BlcmF0aW9uIG9jY3VycmVkXG4gICAgZGV2aWNlSWQ6IHN0cmluZzsgICAgICAgICAvLyBEZXZpY2UgdGhhdCBwZXJmb3JtZWQgdGhlIG9wZXJhdGlvblxuICAgIG1ldGFkYXRhPzogeyAgICAgICAgICAgICAgLy8gQWRkaXRpb25hbCBvcGVyYXRpb24gZGF0YVxuICAgICAgICBvbGRQYXRoPzogc3RyaW5nOyAgICAgLy8gRm9yIHJlbmFtZSBvcGVyYXRpb25zXG4gICAgICAgIGNvbnRlbnRIYXNoPzogc3RyaW5nOyAvLyBGb3IgY3JlYXRlL3VwZGF0ZSBvcGVyYXRpb25zXG4gICAgICAgIGxhc3RNb2RpZmllZD86IG51bWJlcjsgLy8gTGFzdCBtb2RpZmllZCB0aW1lc3RhbXBcbiAgICB9O1xuICAgIHN0YXR1czogJ3BlbmRpbmcnIHwgJ3Byb2Nlc3NpbmcnIHwgJ2Vycm9yJztcbiAgICBlcnJvckRldGFpbHM/OiBzdHJpbmc7ICAgIC8vIEVycm9yIGluZm9ybWF0aW9uIGlmIHN0YXR1cyBpcyAnZXJyb3InXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGRldGVjdGVkIGNvbmZsaWN0IGJldHdlZW4gZGV2aWNlc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNDb25mbGljdCB7XG4gICAgaWQ6IHN0cmluZzsgICAgICAgICAgICAgICAgICAgIC8vIFVuaXF1ZSBjb25mbGljdCBJRFxuICAgIGZpbGVJZDogc3RyaW5nOyAgICAgICAgICAgICAgICAvLyBGaWxlIHBhdGggd2l0aCBjb25mbGljdFxuICAgIGRldGVjdGVkQXQ6IG51bWJlcjsgICAgICAgICAgICAvLyBXaGVuIGNvbmZsaWN0IHdhcyBkZXRlY3RlZFxuICAgIGRldmljZXM6IHN0cmluZ1tdOyAgICAgICAgICAgICAvLyBEZXZpY2UgSURzIGludm9sdmVkIGluIGNvbmZsaWN0XG4gICAgcmVzb2x1dGlvblN0YXR1czogJ3BlbmRpbmcnIHwgJ3Jlc29sdmVkJztcbiAgICByZXNvbHV0aW9uU3RyYXRlZ3k/OiAnbmV3ZXN0LXdpbnMnIHwgJ21hbnVhbCcgfCAna2VlcC1ib3RoJztcbiAgICByZXNvbHZlZEF0PzogbnVtYmVyOyAgICAgICAgICAgLy8gV2hlbiBjb25mbGljdCB3YXMgcmVzb2x2ZWRcbiAgICByZXNvbHZlZEJ5Pzogc3RyaW5nOyAgICAgICAgICAgLy8gRGV2aWNlIElEIHRoYXQgcmVzb2x2ZWQgdGhlIGNvbmZsaWN0XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgc3RydWN0dXJlIG9mIHRoZSBzeW5jIGZpbGUgWUFNTCBoZWFkZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTeW5jRmlsZUhlYWRlciB7XG4gICAgbGFzdEdsb2JhbFN5bmM6IG51bWJlcjsgICAgICAgICAgICAgLy8gTGFzdCB0aW1lIGFueSBkZXZpY2Ugc3luY2VkIHN1Y2Nlc3NmdWxseVxuICAgIHN5bmNTdGF0ZTogU3luY1N0YXRlOyAgICAgICAgICAgICAgIC8vIEN1cnJlbnQgc3luYyBzdGF0ZVxuICAgIHZhdWx0SWQ6IHN0cmluZzsgICAgICAgICAgICAgICAgICAgIC8vIFZhdWx0IGlkZW50aWZpZXJcbiAgICBwbHVnaW5WZXJzaW9uOiBzdHJpbmc7ICAgICAgICAgICAgICAvLyBQbHVnaW4gdmVyc2lvbiB0aGF0IGxhc3Qgd3JvdGUgdGhpcyBmaWxlXG4gICAgbGFzdFdyaXRlcjogc3RyaW5nOyAgICAgICAgICAgICAgICAgLy8gRGV2aWNlIElEIHRoYXQgbGFzdCB3cm90ZSB0aGlzIGZpbGVcbiAgICBkZXZpY2VzOiBSZWNvcmQ8c3RyaW5nLCBTeW5jRGV2aWNlPjsgLy8gTWFwIG9mIGRldmljZSBJRHMgdG8gZGV2aWNlIGluZm9cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBmdWxsIHN0cnVjdHVyZSBvZiB0aGUgc3luYyBmaWxlXG4gKiBUaGlzIHdpbGwgYmUgc2VyaWFsaXplZCB0by9mcm9tIFlBTUxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTeW5jRmlsZURhdGEge1xuICAgIGhlYWRlcjogU3luY0ZpbGVIZWFkZXI7XG4gICAgY29ubmVjdGlvbkV2ZW50czogQ29ubmVjdGlvbkV2ZW50W107ICAgLy8gUmVjZW50IGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlc1xuICAgIHBlbmRpbmdPcGVyYXRpb25zOiBQZW5kaW5nT3BlcmF0aW9uW107IC8vIE9wZXJhdGlvbnMgcXVldWVkIGR1cmluZyBvZmZsaW5lIG1vZGVcbiAgICBjb25mbGljdHM6IFN5bmNDb25mbGljdFtdOyAgICAgICAgICAgIC8vIERldGVjdGVkIHN5bmMgY29uZmxpY3RzXG4gICAgbGFzdERhdGFiYXNlQ2hlY2s6IG51bWJlcjsgICAgICAgICAgICAvLyBMYXN0IHRpbWUgZGF0YWJhc2UgY29ubmVjdGl2aXR5IHdhcyBjaGVja2VkXG4gICAgZGF0YWJhc2VTdGF0dXM6ICdhdmFpbGFibGUnIHwgJ3VuYXZhaWxhYmxlJyB8ICd1bmtub3duJztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB2YWxpZGF0aW9uIHN0YXR1cyBvZiB0aGUgc3luYyBmaWxlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3luY1ZhbGlkYXRpb25SZXN1bHQge1xuICAgIGlzVmFsaWQ6IGJvb2xlYW47XG4gICAgZXJyb3I/OiBzdHJpbmc7XG4gICAgZGV0YWlscz86IFJlY29yZDxzdHJpbmcsIGFueT47XG59XG5cbi8qKlxuICogRXJyb3IgdHlwZXMgc3BlY2lmaWMgdG8gc3luYyBvcGVyYXRpb25zXG4gKi9cbmV4cG9ydCBlbnVtIFN5bmNFcnJvclR5cGUge1xuICAgIFNZTkNfRklMRV9NSVNTSU5HID0gJ3N5bmNfZmlsZV9taXNzaW5nJyxcbiAgICBTWU5DX0ZJTEVfQ09SUlVQVCA9ICdzeW5jX2ZpbGVfY29ycnVwdCcsXG4gICAgU1lOQ19GSUxFX09VVERBVEVEID0gJ3N5bmNfZmlsZV9vdXRkYXRlZCcsXG4gICAgREVWSUNFX01JU01BVENIID0gJ2RldmljZV9taXNtYXRjaCcsXG4gICAgQ09ORkxJQ1RfREVURUNURUQgPSAnY29uZmxpY3RfZGV0ZWN0ZWQnLFxuICAgIERBVEFCQVNFX1VOQVZBSUxBQkxFID0gJ2RhdGFiYXNlX3VuYXZhaWxhYmxlJyxcbiAgICBTWU5DX0lOVEVSUlVQVEVEID0gJ3N5bmNfaW50ZXJydXB0ZWQnLFxuICAgIFVOS05PV05fRVJST1IgPSAndW5rbm93bl9lcnJvcidcbn1cblxuLyoqXG4gKiBEZWZhdWx0IG1heGltdW0gaXRlbXMgdG8ga2VlcCBpbiBlYWNoIGhpc3RvcnkgbGlzdFxuICovXG5leHBvcnQgY29uc3QgTUFYX0NPTk5FQ1RJT05fRVZFTlRTID0gMjA7XG5leHBvcnQgY29uc3QgTUFYX1BFTkRJTkdfT1BFUkFUSU9OUyA9IDEwMDtcbmV4cG9ydCBjb25zdCBNQVhfQ09ORkxJQ1RTID0gNTA7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBwbGF0Zm9ybSBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGxhdGZvcm1JbmZvKCk6IHN0cmluZyB7XG4gICAgY29uc3QgdXNlckFnZW50ID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgICBpZiAodXNlckFnZW50LmluZGV4T2YoJ1dpbicpICE9PSAtMSkgcmV0dXJuICdXaW5kb3dzJztcbiAgICBpZiAodXNlckFnZW50LmluZGV4T2YoJ01hYycpICE9PSAtMSkgcmV0dXJuICdtYWNPUyc7XG4gICAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdpUGhvbmUnKSAhPT0gLTEgfHwgdXNlckFnZW50LmluZGV4T2YoJ2lQYWQnKSAhPT0gLTEpIHJldHVybiAnaU9TJztcbiAgICBpZiAodXNlckFnZW50LmluZGV4T2YoJ0FuZHJvaWQnKSAhPT0gLTEpIHJldHVybiAnQW5kcm9pZCc7XG4gICAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdMaW51eCcpICE9PSAtMSkgcmV0dXJuICdMaW51eCc7XG5cbiAgICByZXR1cm4gJ1Vua25vd24nO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZW1wdHkgc3luYyBmaWxlIGRhdGEgc3RydWN0dXJlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbXB0eVN5bmNGaWxlRGF0YShcbiAgICB2YXVsdElkOiBzdHJpbmcsXG4gICAgZGV2aWNlSWQ6IHN0cmluZyxcbiAgICBkZXZpY2VOYW1lOiBzdHJpbmcsXG4gICAgcGx1Z2luVmVyc2lvbjogc3RyaW5nXG4pOiBTeW5jRmlsZURhdGEge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcGxhdGZvcm0gPSBnZXRQbGF0Zm9ybUluZm8oKTtcblxuICAgIGNvbnN0IGRldmljZTogU3luY0RldmljZSA9IHtcbiAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgIG5hbWU6IGRldmljZU5hbWUsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBsYXN0U2Vlbjogbm93LFxuICAgICAgICBsYXN0U3luY1RpbWU6IG5vd1xuICAgIH07XG5cbiAgICBjb25zdCBkZXZpY2VzOiBSZWNvcmQ8c3RyaW5nLCBTeW5jRGV2aWNlPiA9IHt9O1xuICAgIGRldmljZXNbZGV2aWNlSWRdID0gZGV2aWNlO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGVyOiB7XG4gICAgICAgICAgICBsYXN0R2xvYmFsU3luYzogbm93LFxuICAgICAgICAgICAgc3luY1N0YXRlOiBTeW5jU3RhdGUuSU5JVElBTElaSU5HLFxuICAgICAgICAgICAgdmF1bHRJZCxcbiAgICAgICAgICAgIHBsdWdpblZlcnNpb24sXG4gICAgICAgICAgICBsYXN0V3JpdGVyOiBkZXZpY2VJZCxcbiAgICAgICAgICAgIGRldmljZXNcbiAgICAgICAgfSxcbiAgICAgICAgY29ubmVjdGlvbkV2ZW50czogW10sXG4gICAgICAgIHBlbmRpbmdPcGVyYXRpb25zOiBbXSxcbiAgICAgICAgY29uZmxpY3RzOiBbXSxcbiAgICAgICAgbGFzdERhdGFiYXNlQ2hlY2s6IG5vdyxcbiAgICAgICAgZGF0YWJhc2VTdGF0dXM6ICd1bmtub3duJ1xuICAgIH07XG59XG5cbi8qKlxuICogVHJpbXMgaGlzdG9yeSBhcnJheXMgdG8ga2VlcCB0aGVtIGF0IGEgcmVhc29uYWJsZSBzaXplXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltU3luY0hpc3RvcnlBcnJheXMoZGF0YTogU3luY0ZpbGVEYXRhKTogU3luY0ZpbGVEYXRhIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBjb25uZWN0aW9uRXZlbnRzOiBkYXRhLmNvbm5lY3Rpb25FdmVudHMuc2xpY2UoLU1BWF9DT05ORUNUSU9OX0VWRU5UUyksXG4gICAgICAgIHBlbmRpbmdPcGVyYXRpb25zOiBkYXRhLnBlbmRpbmdPcGVyYXRpb25zLnNsaWNlKC1NQVhfUEVORElOR19PUEVSQVRJT05TKSxcbiAgICAgICAgY29uZmxpY3RzOiBkYXRhLmNvbmZsaWN0cy5zbGljZSgtTUFYX0NPTkZMSUNUUylcbiAgICB9O1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgZGV2aWNlIGluZm9ybWF0aW9uIGluIHRoZSBzeW5jIGZpbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZURldmljZUluU3luY0ZpbGUoXG4gICAgZGF0YTogU3luY0ZpbGVEYXRhLFxuICAgIGRldmljZUlkOiBzdHJpbmcsXG4gICAgZGV2aWNlTmFtZTogc3RyaW5nLFxuICAgIHBsdWdpblZlcnNpb24/OiBzdHJpbmdcbik6IFN5bmNGaWxlRGF0YSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBwbGF0Zm9ybSA9IGdldFBsYXRmb3JtSW5mbygpO1xuXG4gICAgLy8gRGVlcCBjbG9uZSB0aGUgZGF0YSB0byBhdm9pZCBtdXRhdGlvbnNcbiAgICBjb25zdCBuZXdEYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSkgYXMgU3luY0ZpbGVEYXRhO1xuXG4gICAgaWYgKCFuZXdEYXRhLmhlYWRlci5kZXZpY2VzKSB7XG4gICAgICAgIG5ld0RhdGEuaGVhZGVyLmRldmljZXMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgb3IgY3JlYXRlIGRldmljZSBlbnRyeVxuICAgIGlmIChuZXdEYXRhLmhlYWRlci5kZXZpY2VzW2RldmljZUlkXSkge1xuICAgICAgICBuZXdEYXRhLmhlYWRlci5kZXZpY2VzW2RldmljZUlkXSA9IHtcbiAgICAgICAgICAgIC4uLm5ld0RhdGEuaGVhZGVyLmRldmljZXNbZGV2aWNlSWRdLFxuICAgICAgICAgICAgbmFtZTogZGV2aWNlTmFtZSxcbiAgICAgICAgICAgIHBsYXRmb3JtLFxuICAgICAgICAgICAgbGFzdFNlZW46IG5vdyxcbiAgICAgICAgICAgIHBsdWdpblZlcnNpb246IHBsdWdpblZlcnNpb24gfHwgbmV3RGF0YS5oZWFkZXIuZGV2aWNlc1tkZXZpY2VJZF0ucGx1Z2luVmVyc2lvblxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0RhdGEuaGVhZGVyLmRldmljZXNbZGV2aWNlSWRdID0ge1xuICAgICAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgICAgICBuYW1lOiBkZXZpY2VOYW1lLFxuICAgICAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgICAgICBsYXN0U2Vlbjogbm93LFxuICAgICAgICAgICAgbGFzdFN5bmNUaW1lOiBub3csXG4gICAgICAgICAgICBwbHVnaW5WZXJzaW9uXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbmV3RGF0YS5oZWFkZXIubGFzdFdyaXRlciA9IGRldmljZUlkO1xuICAgIGlmIChwbHVnaW5WZXJzaW9uKSB7XG4gICAgICAgIG5ld0RhdGEuaGVhZGVyLnBsdWdpblZlcnNpb24gPSBwbHVnaW5WZXJzaW9uO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdEYXRhO1xufVxuXG4vKipcbiAqIEFkZHMgYSBjb25uZWN0aW9uIGV2ZW50IHRvIHRoZSBzeW5jIGZpbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvbm5lY3Rpb25FdmVudChcbiAgICBkYXRhOiBTeW5jRmlsZURhdGEsXG4gICAgZXZlbnRUeXBlOiAnY29ubmVjdGVkJyB8ICdkaXNjb25uZWN0ZWQnLFxuICAgIGRldmljZUlkOiBzdHJpbmcsXG4gICAgZGV0YWlscz86IHN0cmluZ1xuKTogU3luY0ZpbGVEYXRhIHtcbiAgICBjb25zdCBuZXdEYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSkgYXMgU3luY0ZpbGVEYXRhO1xuXG4gICAgbmV3RGF0YS5jb25uZWN0aW9uRXZlbnRzLnB1c2goe1xuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIGV2ZW50VHlwZSxcbiAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgIGRldGFpbHNcbiAgICB9KTtcblxuICAgIC8vIEtlZXAgYXJyYXkgc2l6ZSBtYW5hZ2VhYmxlXG4gICAgaWYgKG5ld0RhdGEuY29ubmVjdGlvbkV2ZW50cy5sZW5ndGggPiBNQVhfQ09OTkVDVElPTl9FVkVOVFMpIHtcbiAgICAgICAgbmV3RGF0YS5jb25uZWN0aW9uRXZlbnRzID0gbmV3RGF0YS5jb25uZWN0aW9uRXZlbnRzLnNsaWNlKC1NQVhfQ09OTkVDVElPTl9FVkVOVFMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdEYXRhO1xufVxuXG4vKipcbiAqIEFkZHMgYSBwZW5kaW5nIG9wZXJhdGlvbiB0byB0aGUgc3luYyBmaWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRQZW5kaW5nT3BlcmF0aW9uKFxuICAgIGRhdGE6IFN5bmNGaWxlRGF0YSxcbiAgICBmaWxlSWQ6IHN0cmluZyxcbiAgICBvcGVyYXRpb25UeXBlOiAnY3JlYXRlJyB8ICd1cGRhdGUnIHwgJ2RlbGV0ZScgfCAncmVuYW1lJyxcbiAgICBkZXZpY2VJZDogc3RyaW5nLFxuICAgIG1ldGFkYXRhPzoge1xuICAgICAgICBvbGRQYXRoPzogc3RyaW5nO1xuICAgICAgICBjb250ZW50SGFzaD86IHN0cmluZztcbiAgICAgICAgbGFzdE1vZGlmaWVkPzogbnVtYmVyO1xuICAgIH1cbik6IFN5bmNGaWxlRGF0YSB7XG4gICAgY29uc3QgbmV3RGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpIGFzIFN5bmNGaWxlRGF0YTtcblxuICAgIG5ld0RhdGEucGVuZGluZ09wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgICBmaWxlSWQsXG4gICAgICAgIG9wZXJhdGlvblR5cGUsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJ1xuICAgIH0pO1xuXG4gICAgLy8gS2VlcCBhcnJheSBzaXplIG1hbmFnZWFibGVcbiAgICBpZiAobmV3RGF0YS5wZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPiBNQVhfUEVORElOR19PUEVSQVRJT05TKSB7XG4gICAgICAgIG5ld0RhdGEucGVuZGluZ09wZXJhdGlvbnMgPSBuZXdEYXRhLnBlbmRpbmdPcGVyYXRpb25zLnNsaWNlKC1NQVhfUEVORElOR19PUEVSQVRJT05TKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RGF0YTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgc3luYyBjb25mbGljdCB0byB0aGUgc3luYyBmaWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRTeW5jQ29uZmxpY3QoXG4gICAgZGF0YTogU3luY0ZpbGVEYXRhLFxuICAgIGZpbGVJZDogc3RyaW5nLFxuICAgIGRldmljZXM6IHN0cmluZ1tdXG4pOiBTeW5jRmlsZURhdGEge1xuICAgIGNvbnN0IG5ld0RhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpKSBhcyBTeW5jRmlsZURhdGE7XG5cbiAgICBuZXdEYXRhLmNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXG4gICAgICAgIGZpbGVJZCxcbiAgICAgICAgZGV0ZWN0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgZGV2aWNlcyxcbiAgICAgICAgcmVzb2x1dGlvblN0YXR1czogJ3BlbmRpbmcnXG4gICAgfSk7XG5cbiAgICAvLyBLZWVwIGFycmF5IHNpemUgbWFuYWdlYWJsZVxuICAgIGlmIChuZXdEYXRhLmNvbmZsaWN0cy5sZW5ndGggPiBNQVhfQ09ORkxJQ1RTKSB7XG4gICAgICAgIG5ld0RhdGEuY29uZmxpY3RzID0gbmV3RGF0YS5jb25mbGljdHMuc2xpY2UoLU1BWF9DT05GTElDVFMpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzeW5jIHN0YXRlIHRvIGluZGljYXRlIGNvbmZsaWN0XG4gICAgbmV3RGF0YS5oZWFkZXIuc3luY1N0YXRlID0gU3luY1N0YXRlLkNPTkZMSUNUO1xuXG4gICAgcmV0dXJuIG5ld0RhdGE7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgZGF0YWJhc2Ugc3RhdHVzIGluIHRoZSBzeW5jIGZpbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZURhdGFiYXNlU3RhdHVzKFxuICAgIGRhdGE6IFN5bmNGaWxlRGF0YSxcbiAgICBzdGF0dXM6ICdhdmFpbGFibGUnIHwgJ3VuYXZhaWxhYmxlJyB8ICd1bmtub3duJ1xuKTogU3luY0ZpbGVEYXRhIHtcbiAgICBjb25zdCBuZXdEYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSkgYXMgU3luY0ZpbGVEYXRhO1xuXG4gICAgbmV3RGF0YS5kYXRhYmFzZVN0YXR1cyA9IHN0YXR1cztcbiAgICBuZXdEYXRhLmxhc3REYXRhYmFzZUNoZWNrID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIFVwZGF0ZSBzeW5jIHN0YXRlIGJhc2VkIG9uIGRhdGFiYXNlIHN0YXR1c1xuICAgIGlmIChzdGF0dXMgPT09ICd1bmF2YWlsYWJsZScpIHtcbiAgICAgICAgbmV3RGF0YS5oZWFkZXIuc3luY1N0YXRlID0gU3luY1N0YXRlLk9GRkxJTkU7XG4gICAgfSBlbHNlIGlmIChzdGF0dXMgPT09ICdhdmFpbGFibGUnKSB7XG4gICAgICAgIG5ld0RhdGEuaGVhZGVyLnN5bmNTdGF0ZSA9IFN5bmNTdGF0ZS5PTkxJTkU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0RhdGE7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgbGFzdCBzeW5jIHRpbWUgZm9yIGEgZGV2aWNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVEZXZpY2VTeW5jVGltZShcbiAgICBkYXRhOiBTeW5jRmlsZURhdGEsXG4gICAgZGV2aWNlSWQ6IHN0cmluZ1xuKTogU3luY0ZpbGVEYXRhIHtcbiAgICBjb25zdCBuZXdEYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSkgYXMgU3luY0ZpbGVEYXRhO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBpZiAobmV3RGF0YS5oZWFkZXIuZGV2aWNlcyAmJiBuZXdEYXRhLmhlYWRlci5kZXZpY2VzW2RldmljZUlkXSkge1xuICAgICAgICBuZXdEYXRhLmhlYWRlci5kZXZpY2VzW2RldmljZUlkXS5sYXN0U3luY1RpbWUgPSBub3c7XG4gICAgICAgIG5ld0RhdGEuaGVhZGVyLmRldmljZXNbZGV2aWNlSWRdLmxhc3RTZWVuID0gbm93O1xuICAgICAgICBuZXdEYXRhLmhlYWRlci5sYXN0R2xvYmFsU3luYyA9IG5vdztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RGF0YTtcbn1cbiIsICIvLyBzcmMvdXRpbHMvRXJyb3JIYW5kbGVyLnRzXG5pbXBvcnQgeyBEb2N1bWVudFByb2Nlc3NpbmdFcnJvciB9IGZyb20gJy4uL21vZGVscy9Eb2N1bWVudENodW5rJztcbmltcG9ydCB7IFRhc2tQcm9jZXNzaW5nRXJyb3IgfSBmcm9tICcuLi9tb2RlbHMvUHJvY2Vzc2luZ1Rhc2snO1xuaW1wb3J0IHsgU3luY0Vycm9yVHlwZSB9IGZyb20gJy4uL21vZGVscy9TeW5jTW9kZWxzJztcbmltcG9ydCB7IERlYnVnU2V0dGluZ3MgfSBmcm9tICcuLi9zZXR0aW5ncy9TZXR0aW5ncyc7XG5pbXBvcnQgeyBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBQb3N0Z3Jlc3RFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JDb250ZXh0IHtcblx0Y29udGV4dDogc3RyaW5nO1xuXHR0YXNrSWQ/OiBzdHJpbmc7XG5cdHRhc2tUeXBlPzogc3RyaW5nO1xuXHRtZXRhZGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JMb2cge1xuXHR0aW1lc3RhbXA6IG51bWJlcjtcblx0ZXJyb3I6IEVycm9yO1xuXHRjb250ZXh0OiBFcnJvckNvbnRleHQ7XG5cdGxldmVsOiAnZXJyb3InIHwgJ3dhcm4nIHwgJ2luZm8nIHwgJ2RlYnVnJztcblx0aGFuZGxlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdXBhYmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb2RlOiBzdHJpbmc7XG5cdGRldGFpbHM6IHN0cmluZztcblx0aGludD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTeW5jRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdHR5cGU6IFN5bmNFcnJvclR5cGU7XG5cdGRldGFpbHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXHRkZXZpY2VJZD86IHN0cmluZztcblx0cmVjb3ZlcmFibGU6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBFcnJvckhhbmRsZXIge1xuXHRwcml2YXRlIGVycm9yTG9nczogRXJyb3JMb2dbXSA9IFtdO1xuXHRwcml2YXRlIHJlYWRvbmx5IG1heExvZ3M6IG51bWJlciA9IDEwMDtcblx0cHJpdmF0ZSBzZXR0aW5nczogRGVidWdTZXR0aW5ncztcblx0cHJpdmF0ZSBsb2dGaWxlUGF0aD86IHN0cmluZztcblxuXHRjb25zdHJ1Y3RvcihzZXR0aW5nczogRGVidWdTZXR0aW5ncywgdmF1bHRQYXRoPzogc3RyaW5nKSB7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuXHRcdGlmIChzZXR0aW5ncy5sb2dUb0ZpbGUgJiYgdmF1bHRQYXRoKSB7XG5cdFx0XHR0aGlzLmxvZ0ZpbGVQYXRoID0gYCR7dmF1bHRQYXRofS8ub2JzaWRpYW4vbWluZC1tYXRyaXgubG9nYDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBlcnJvcnMgd2l0aCBjb250ZXh0IGFuZCBvcHRpb25hbCByZWNvdmVyeS5cblx0ICovXG5cdGhhbmRsZUVycm9yKGVycm9yOiBhbnksIGNvbnRleHQ6IEVycm9yQ29udGV4dCwgbGV2ZWw6ICdlcnJvcicgfCAnd2FybicgfCAnaW5mbycgfCAnZGVidWcnID0gJ2Vycm9yJyk6IHZvaWQge1xuXHRcdGlmICghdGhpcy5zaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGNvbnN0IGVycm9yTG9nOiBFcnJvckxvZyA9IHtcblx0XHRcdHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcblx0XHRcdGVycm9yOiB0aGlzLm5vcm1hbGl6ZUVycm9yKGVycm9yKSxcblx0XHRcdGNvbnRleHQsXG5cdFx0XHRsZXZlbCxcblx0XHRcdGhhbmRsZWQ6IGZhbHNlXG5cdFx0fTtcblx0XHR0aGlzLmVycm9yTG9ncy51bnNoaWZ0KGVycm9yTG9nKTtcblx0XHRpZiAodGhpcy5lcnJvckxvZ3MubGVuZ3RoID4gdGhpcy5tYXhMb2dzKSB7XG5cdFx0XHR0aGlzLmVycm9yTG9ncy5wb3AoKTtcblx0XHR9XG5cdFx0Ly8gU2hvdyBhIG5vdGljZSBmb3IgaW1wb3J0YW50IGVycm9ycy5cblx0XHRpZiAobGV2ZWwgPT09ICdlcnJvcicgfHwgKGxldmVsID09PSAnd2FybicgJiYgdGhpcy5zZXR0aW5ncy5sb2dMZXZlbCA9PT0gJ2RlYnVnJykpIHtcblx0XHRcdG5ldyBOb3RpY2UoYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG5cdFx0fVxuXHRcdC8vIERlYnVnIGxvZ2dpbmcuXG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MuZW5hYmxlRGVidWdMb2dzKSB7XG5cdFx0XHRjb25zb2xlLmdyb3VwKGBbJHtsZXZlbC50b1VwcGVyQ2FzZSgpfV0gJHtjb250ZXh0LmNvbnRleHR9YCk7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhaWxzOicsIGVycm9yKTtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0NvbnRleHQ6JywgY29udGV4dCk7XG5cdFx0XHRpZiAoZXJyb3Iuc3RhY2spIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignU3RhY2sgdHJhY2U6JywgZXJyb3Iuc3RhY2spO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5ncm91cEVuZCgpO1xuXHRcdH1cblx0XHQvLyBGaWxlIGxvZ2dpbmcgaWYgZW5hYmxlZC5cblx0XHRpZiAodGhpcy5zZXR0aW5ncy5sb2dUb0ZpbGUgJiYgdGhpcy5sb2dGaWxlUGF0aCkge1xuXHRcdFx0dGhpcy53cml0ZVRvTG9nRmlsZShlcnJvckxvZyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW5kIGhhbmRsZXMgYSBzeW5jIGVycm9yLlxuXHQgKi9cblx0aGFuZGxlU3luY0Vycm9yKFxuXHRcdHR5cGU6IFN5bmNFcnJvclR5cGUsXG5cdFx0bWVzc2FnZTogc3RyaW5nLFxuXHRcdGNvbnRleHQ6IEVycm9yQ29udGV4dCxcblx0XHRkZXRhaWxzPzogUmVjb3JkPHN0cmluZywgYW55Pixcblx0XHRkZXZpY2VJZD86IHN0cmluZyxcblx0XHRyZWNvdmVyYWJsZTogYm9vbGVhbiA9IHRydWVcblx0KTogU3luY0Vycm9yIHtcblx0XHRjb25zdCBlcnJvcjogU3luY0Vycm9yID0ge1xuXHRcdFx0bmFtZTogJ1N5bmNFcnJvcicsXG5cdFx0XHRtZXNzYWdlLFxuXHRcdFx0dHlwZSxcblx0XHRcdGRldGFpbHMsXG5cdFx0XHRkZXZpY2VJZCxcblx0XHRcdHJlY292ZXJhYmxlLFxuXHRcdFx0c3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrXG5cdFx0fTtcblx0XHR0aGlzLmhhbmRsZUVycm9yKGVycm9yLCBjb250ZXh0LCByZWNvdmVyYWJsZSA/ICd3YXJuJyA6ICdlcnJvcicpO1xuXHRcdHJldHVybiBlcnJvcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGNvbm5lY3Rpb24gZXJyb3JzIHNwZWNpZmljYWxseSBmb3Igc3luYyBvcGVyYXRpb25zLlxuXHQgKi9cblx0aGFuZGxlQ29ubmVjdGlvbkVycm9yKGVycm9yOiBhbnksIGNvbnRleHQ6IHN0cmluZywgZGV2aWNlSWQ/OiBzdHJpbmcpOiB2b2lkIHtcblx0XHRsZXQgc3luY0Vycm9yOiBTeW5jRXJyb3I7XG5cdFx0aWYgKGVycm9yICYmIGVycm9yLnR5cGUgJiYgT2JqZWN0LnZhbHVlcyhTeW5jRXJyb3JUeXBlKS5pbmNsdWRlcyhlcnJvci50eXBlIGFzIFN5bmNFcnJvclR5cGUpKSB7XG5cdFx0XHRzeW5jRXJyb3IgPSBlcnJvciBhcyBTeW5jRXJyb3I7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN5bmNFcnJvciA9IHtcblx0XHRcdFx0bmFtZTogJ1N5bmNFcnJvcicsXG5cdFx0XHRcdG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZXJyb3InLFxuXHRcdFx0XHR0eXBlOiBTeW5jRXJyb3JUeXBlLkRBVEFCQVNFX1VOQVZBSUxBQkxFLFxuXHRcdFx0XHRkZXRhaWxzOiB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH0sXG5cdFx0XHRcdGRldmljZUlkLFxuXHRcdFx0XHRyZWNvdmVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0c3RhY2s6IGVycm9yLnN0YWNrIHx8IG5ldyBFcnJvcigpLnN0YWNrXG5cdFx0XHR9O1xuXHRcdH1cblx0XHR0aGlzLmhhbmRsZUVycm9yKHN5bmNFcnJvciwgeyBjb250ZXh0IH0sICd3YXJuJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBsZXZlbCBzaG91bGQgYmUgbG9nZ2VkLlxuXHQgKi9cblx0cHJpdmF0ZSBzaG91bGRMb2cobGV2ZWw6ICdlcnJvcicgfCAnd2FybicgfCAnaW5mbycgfCAnZGVidWcnKTogYm9vbGVhbiB7XG5cdFx0Y29uc3QgbGV2ZWxzID0geyBlcnJvcjogMCwgd2FybjogMSwgaW5mbzogMiwgZGVidWc6IDMgfTtcblx0XHRyZXR1cm4gbGV2ZWxzW2xldmVsXSA8PSBsZXZlbHNbdGhpcy5zZXR0aW5ncy5sb2dMZXZlbF07XG5cdH1cblxuXHQvKipcblx0ICogTm9ybWFsaXplcyBkaWZmZXJlbnQgZXJyb3IgZm9ybWF0cy5cblx0ICovXG5cdHByaXZhdGUgbm9ybWFsaXplRXJyb3IoZXJyb3I6IGFueSk6IEVycm9yIHtcblx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdH1cblx0XHQvLyBIYW5kbGUgU3luYyBlcnJvcnMuXG5cdFx0aWYgKGVycm9yICYmIGVycm9yLnR5cGUgJiYgT2JqZWN0LnZhbHVlcyhTeW5jRXJyb3JUeXBlKS5pbmNsdWRlcyhlcnJvci50eXBlIGFzIFN5bmNFcnJvclR5cGUpKSB7XG5cdFx0XHRjb25zdCBzeW5jRXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSB8fCAnU3luYyBlcnJvcicpO1xuXHRcdFx0c3luY0Vycm9yLm5hbWUgPSAnU3luY0Vycm9yJztcblx0XHRcdE9iamVjdC5hc3NpZ24oc3luY0Vycm9yLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4gc3luY0Vycm9yO1xuXHRcdH1cblx0XHQvLyBIYW5kbGUgU3VwYWJhc2UgZXJyb3JzLlxuXHRcdGlmICh0aGlzLmlzU3VwYWJhc2VFcnJvcihlcnJvcikpIHtcblx0XHRcdHJldHVybiBuZXcgRXJyb3IoYERhdGFiYXNlIGVycm9yICgke2Vycm9yLmNvZGV9KTogJHtlcnJvci5tZXNzYWdlfSR7ZXJyb3IuaGludCA/IGAgLSAke2Vycm9yLmhpbnR9YCA6ICcnfWApO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIG5ldyBFcnJvcihlcnJvcik7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRjb25zdCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcic7XG5cdFx0XHRjb25zdCBub3JtYWxpemVkRXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG5cdFx0XHRPYmplY3QuYXNzaWduKG5vcm1hbGl6ZWRFcnJvciwgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIG5vcm1hbGl6ZWRFcnJvcjtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBFcnJvcignVW5rbm93biBlcnJvciBvY2N1cnJlZCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFR5cGUgZ3VhcmQgZm9yIFN1cGFiYXNlIGVycm9ycy5cblx0ICovXG5cdHByaXZhdGUgaXNTdXBhYmFzZUVycm9yKGVycm9yOiBhbnkpOiBlcnJvciBpcyBQb3N0Z3Jlc3RFcnJvciB7XG5cdFx0cmV0dXJuIGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgJ2NvZGUnIGluIGVycm9yICYmICdkZXRhaWxzJyBpbiBlcnJvcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBUeXBlIGd1YXJkIGZvciBTeW5jIGVycm9ycy5cblx0ICovXG5cdGlzU3luY0Vycm9yKGVycm9yOiBhbnkpOiBlcnJvciBpcyBTeW5jRXJyb3Ige1xuXHRcdHJldHVybiBlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmICd0eXBlJyBpbiBlcnJvciAmJiBPYmplY3QudmFsdWVzKFN5bmNFcnJvclR5cGUpLmluY2x1ZGVzKGVycm9yLnR5cGUgYXMgU3luY0Vycm9yVHlwZSk7XG5cdH1cblxuXHQvKipcblx0ICogU2hvd3MgYW4gYXBwcm9wcmlhdGUgbm90aWZpY2F0aW9uIGJhc2VkIG9uIGVycm9yIHR5cGUuXG5cdCAqL1xuXHRwcml2YXRlIHNob3dFcnJvck5vdGlmaWNhdGlvbihlcnJvcjogYW55KTogdm9pZCB7XG5cdFx0bGV0IG1lc3NhZ2UgPSAnQW4gZXJyb3Igb2NjdXJyZWQnO1xuXHRcdGxldCBkdXJhdGlvbiA9IDQwMDA7XG5cdFx0aWYgKHRoaXMuaXNTeW5jRXJyb3IoZXJyb3IpKSB7XG5cdFx0XHRzd2l0Y2goZXJyb3IudHlwZSkge1xuXHRcdFx0XHRjYXNlIFN5bmNFcnJvclR5cGUuU1lOQ19GSUxFX01JU1NJTkc6XG5cdFx0XHRcdFx0bWVzc2FnZSA9ICdTeW5jIGZpbGUgaXMgbWlzc2luZy4gV2lsbCBhdHRlbXB0IHRvIHJlY3JlYXRlLic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgU3luY0Vycm9yVHlwZS5TWU5DX0ZJTEVfQ09SUlVQVDpcblx0XHRcdFx0XHRtZXNzYWdlID0gJ1N5bmMgZmlsZSBpcyBjb3JydXB0ZWQuIFdpbGwgYXR0ZW1wdCB0byByZXBhaXIuJztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBTeW5jRXJyb3JUeXBlLkRFVklDRV9NSVNNQVRDSDpcblx0XHRcdFx0XHRtZXNzYWdlID0gJ0RldmljZSBpZGVudGlmaWNhdGlvbiBpc3N1ZS4gQ2hlY2sgcGx1Z2luIHNldHRpbmdzLic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgU3luY0Vycm9yVHlwZS5DT05GTElDVF9ERVRFQ1RFRDpcblx0XHRcdFx0XHRtZXNzYWdlID0gJ1N5bmMgY29uZmxpY3QgZGV0ZWN0ZWQuIENoZWNrIHN5bmMgc3RhdHVzIGZvciBkZXRhaWxzLic7XG5cdFx0XHRcdFx0ZHVyYXRpb24gPSA2MDAwO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFN5bmNFcnJvclR5cGUuREFUQUJBU0VfVU5BVkFJTEFCTEU6XG5cdFx0XHRcdFx0bWVzc2FnZSA9ICdEYXRhYmFzZSBjb25uZWN0aW9uIHVuYXZhaWxhYmxlLiBPcGVyYXRpbmcgaW4gb2ZmbGluZSBtb2RlLic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgU3luY0Vycm9yVHlwZS5TWU5DX0lOVEVSUlVQVEVEOlxuXHRcdFx0XHRcdG1lc3NhZ2UgPSAnU3luYyBvcGVyYXRpb24gd2FzIGludGVycnVwdGVkLiBXaWxsIHJldHJ5Lic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0bWVzc2FnZSA9IGBTeW5jIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRoaXMuaXNTdXBhYmFzZUVycm9yKGVycm9yKSkge1xuXHRcdFx0c3dpdGNoIChlcnJvci5jb2RlKSB7XG5cdFx0XHRcdGNhc2UgJzQyUDAxJzpcblx0XHRcdFx0XHRtZXNzYWdlID0gJ0RhdGFiYXNlIHRhYmxlIG5vdCBmb3VuZC4gUGxlYXNlIHJ1biBzZXR1cCBTUUwuJztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnNDI1MDEnOlxuXHRcdFx0XHRcdG1lc3NhZ2UgPSAnSW5zdWZmaWNpZW50IGRhdGFiYXNlIHBlcm1pc3Npb25zLic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJzIzNTA1Jzpcblx0XHRcdFx0XHRtZXNzYWdlID0gJ0R1cGxpY2F0ZSBlbnRyeSBmb3VuZC4nO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdG1lc3NhZ2UgPSBgRGF0YWJhc2UgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gO1xuXHRcdFx0fVxuXHRcdFx0ZHVyYXRpb24gPSA2MDAwO1xuXHRcdH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IuQ0hVTktJTkdfRVJST1IpIHtcblx0XHRcdG1lc3NhZ2UgPSAnRXJyb3Igc3BsaXR0aW5nIGRvY3VtZW50IGludG8gY2h1bmtzJztcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLkVNQkVERElOR19FUlJPUikge1xuXHRcdFx0bWVzc2FnZSA9ICdFcnJvciBnZW5lcmF0aW5nIGVtYmVkZGluZ3MnO1xuXHRcdH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IuREFUQUJBU0VfRVJST1IpIHtcblx0XHRcdG1lc3NhZ2UgPSAnRGF0YWJhc2Ugb3BlcmF0aW9uIGZhaWxlZCc7XG5cdFx0fSBlbHNlIGlmIChlcnJvci50eXBlID09PSBEb2N1bWVudFByb2Nlc3NpbmdFcnJvci5JTlZBTElEX01FVEFEQVRBKSB7XG5cdFx0XHRtZXNzYWdlID0gJ0ludmFsaWQgZG9jdW1lbnQgbWV0YWRhdGEnO1xuXHRcdH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IuRklMRV9BQ0NFU1NfRVJST1IpIHtcblx0XHRcdG1lc3NhZ2UgPSAnRXJyb3IgYWNjZXNzaW5nIGZpbGUnO1xuXHRcdH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IuWUFNTF9QQVJTRV9FUlJPUikge1xuXHRcdFx0bWVzc2FnZSA9ICdFcnJvciBwYXJzaW5nIFlBTUwgZnJvbnQgbWF0dGVyJztcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLlZFQ1RPUl9FWFRFTlNJT05fRVJST1IpIHtcblx0XHRcdG1lc3NhZ2UgPSAnVmVjdG9yIGV4dGVuc2lvbiBub3QgYXZhaWxhYmxlJztcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLlNZTkNfRVJST1IpIHtcblx0XHRcdG1lc3NhZ2UgPSAnU3luYyBvcGVyYXRpb24gZmFpbGVkJztcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IFRhc2tQcm9jZXNzaW5nRXJyb3IuUVVFVUVfRlVMTCkge1xuXHRcdFx0bWVzc2FnZSA9ICdUYXNrIHF1ZXVlIGlzIGZ1bGwnO1xuXHRcdH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gVGFza1Byb2Nlc3NpbmdFcnJvci5UQVNLX1RJTUVPVVQpIHtcblx0XHRcdG1lc3NhZ2UgPSAnVGFzayB0aW1lZCBvdXQnO1xuXHRcdH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gVGFza1Byb2Nlc3NpbmdFcnJvci5UQVNLX0NBTkNFTExFRCkge1xuXHRcdFx0bWVzc2FnZSA9ICdUYXNrIHdhcyBjYW5jZWxsZWQnO1xuXHRcdH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gVGFza1Byb2Nlc3NpbmdFcnJvci5NQVhfUkVUUklFU19FWENFRURFRCkge1xuXHRcdFx0bWVzc2FnZSA9ICdNYXhpbXVtIHJldHJ5IGF0dGVtcHRzIGV4Y2VlZGVkJztcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IFRhc2tQcm9jZXNzaW5nRXJyb3IuSU5WQUxJRF9UQVNLX1NUQVRFKSB7XG5cdFx0XHRtZXNzYWdlID0gJ0ludmFsaWQgdGFzayBzdGF0ZSc7XG5cdFx0fSBlbHNlIGlmIChlcnJvci50eXBlID09PSBUYXNrUHJvY2Vzc2luZ0Vycm9yLlRBU0tfTk9UX0ZPVU5EKSB7XG5cdFx0XHRtZXNzYWdlID0gJ1Rhc2sgbm90IGZvdW5kJztcblx0XHR9XG5cdFx0aWYgKGVycm9yLm1lc3NhZ2UgJiYgIXRoaXMuaXNTeW5jRXJyb3IoZXJyb3IpKSB7XG5cdFx0XHRtZXNzYWdlID0gYCR7bWVzc2FnZX06ICR7ZXJyb3IubWVzc2FnZX1gO1xuXHRcdH1cblx0XHRuZXcgTm90aWNlKG1lc3NhZ2UsIGR1cmF0aW9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBXcml0ZXMgZXJyb3IgbG9nIHRvIGZpbGUuXG5cdCAqL1xuXHRwcml2YXRlIHdyaXRlVG9Mb2dGaWxlKGxvZzogRXJyb3JMb2cpOiB2b2lkIHtcblx0XHRpZiAoIXRoaXMubG9nRmlsZVBhdGgpIHJldHVybjtcblx0XHRjb25zdCBsb2dFbnRyeSA9IHtcblx0XHRcdHRpbWVzdGFtcDogbmV3IERhdGUobG9nLnRpbWVzdGFtcCkudG9JU09TdHJpbmcoKSxcblx0XHRcdGxldmVsOiBsb2cubGV2ZWwudG9VcHBlckNhc2UoKSxcblx0XHRcdGNvbnRleHQ6IGxvZy5jb250ZXh0LmNvbnRleHQsXG5cdFx0XHRlcnJvcjogbG9nLmVycm9yLm1lc3NhZ2UsXG5cdFx0XHRzdGFjazogbG9nLmVycm9yLnN0YWNrLFxuXHRcdFx0bWV0YWRhdGE6IGxvZy5jb250ZXh0Lm1ldGFkYXRhXG5cdFx0fTtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCh3aW5kb3cgYXMgYW55KS5hcHA/LnZhdWx0Py5hZGFwdGVyPy5hcHBlbmQpIHtcblx0XHRcdFx0KHdpbmRvdyBhcyBhbnkpLmFwcC52YXVsdC5hZGFwdGVyLmFwcGVuZChcblx0XHRcdFx0XHR0aGlzLmxvZ0ZpbGVQYXRoLFxuXHRcdFx0XHRcdEpTT04uc3RyaW5naWZ5KGxvZ0VudHJ5KSArICdcXG4nXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB3cml0ZSB0byBsb2cgZmlsZTonLCBlcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0dXBkYXRlU2V0dGluZ3Moc2V0dGluZ3M6IERlYnVnU2V0dGluZ3MpOiB2b2lkIHtcblx0XHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG5cdH1cblxuXHRnZXRSZWNlbnRMb2dzKGNvdW50OiBudW1iZXIgPSAxMCk6IEVycm9yTG9nW10ge1xuXHRcdHJldHVybiB0aGlzLmVycm9yTG9ncy5zbGljZSgwLCBjb3VudCk7XG5cdH1cblxuXHRjbGVhckxvZ3MoKTogdm9pZCB7XG5cdFx0dGhpcy5lcnJvckxvZ3MgPSBbXTtcblx0fVxuXG5cdGdldEVycm9yU3RhdHMoKTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB7XG5cdFx0cmV0dXJuIHRoaXMuZXJyb3JMb2dzLnJlZHVjZSgoYWNjLCBsb2cpID0+IHtcblx0XHRcdGNvbnN0IGVycm9yVHlwZSA9IGxvZy5lcnJvci5uYW1lIHx8ICdVbmtub3duJztcblx0XHRcdGFjY1tlcnJvclR5cGVdID0gKGFjY1tlcnJvclR5cGVdIHx8IDApICsgMTtcblx0XHRcdHJldHVybiBhY2M7XG5cdFx0fSwge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPik7XG5cdH1cblxuXHRnZXRTeW5jRXJyb3JTdGF0cygpOiBSZWNvcmQ8U3luY0Vycm9yVHlwZSwgbnVtYmVyPiB7XG5cdFx0Y29uc3Qgc3RhdHMgPSB7fSBhcyBSZWNvcmQ8U3luY0Vycm9yVHlwZSwgbnVtYmVyPjtcblx0XHRPYmplY3QudmFsdWVzKFN5bmNFcnJvclR5cGUpLmZvckVhY2godHlwZSA9PiB7XG5cdFx0XHRzdGF0c1t0eXBlIGFzIFN5bmNFcnJvclR5cGVdID0gMDtcblx0XHR9KTtcblx0XHR0aGlzLmVycm9yTG9ncy5mb3JFYWNoKGxvZyA9PiB7XG5cdFx0XHRpZiAodGhpcy5pc1N5bmNFcnJvcihsb2cuZXJyb3IpKSB7XG5cdFx0XHRcdHN0YXRzW2xvZy5lcnJvci50eXBlXSA9IChzdGF0c1tsb2cuZXJyb3IudHlwZV0gfHwgMCkgKyAxO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBzdGF0cztcblx0fVxufVxuIiwgIi8vIHNyYy91dGlscy9Ob3RpZmljYXRpb25NYW5hZ2VyLnRzXG5pbXBvcnQgeyBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBUYXNrUHJvZ3Jlc3MgfSBmcm9tICcuLi9tb2RlbHMvUHJvY2Vzc2luZ1Rhc2snO1xuXG5leHBvcnQgY2xhc3MgTm90aWZpY2F0aW9uTWFuYWdlciB7XG5cdHByaXZhdGUgZml4ZWRQcm9ncmVzc0Jhcjoge1xuXHRcdGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG5cdFx0ZmlsbDogSFRNTEVsZW1lbnQ7XG5cdFx0dGV4dDogSFRNTEVsZW1lbnQ7XG5cdH0gfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBzdGF0dXNCYXJJdGVtOiBIVE1MRWxlbWVudDtcblx0cHJpdmF0ZSBlbmFibGVOb3RpZmljYXRpb25zOiBib29sZWFuO1xuXHRwcml2YXRlIGVuYWJsZVByb2dyZXNzQmFyOiBib29sZWFuO1xuXHRwcml2YXRlIG5vdGlmaWNhdGlvblF1ZXVlOiBzdHJpbmdbXSA9IFtdO1xuXHRwcml2YXRlIGlzUHJvY2Vzc2luZ1F1ZXVlOiBib29sZWFuID0gZmFsc2U7XG5cblx0Y29uc3RydWN0b3IoXG5cdFx0c3RhdHVzQmFyRWw6IEhUTUxFbGVtZW50LFxuXHRcdGVuYWJsZU5vdGlmaWNhdGlvbnM6IGJvb2xlYW4sXG5cdFx0ZW5hYmxlUHJvZ3Jlc3NCYXI6IGJvb2xlYW5cblx0KSB7XG5cdFx0dGhpcy5zdGF0dXNCYXJJdGVtID0gc3RhdHVzQmFyRWw7XG5cdFx0dGhpcy5lbmFibGVOb3RpZmljYXRpb25zID0gZW5hYmxlTm90aWZpY2F0aW9ucztcblx0XHR0aGlzLmVuYWJsZVByb2dyZXNzQmFyID0gZW5hYmxlUHJvZ3Jlc3NCYXI7XG5cdFx0dGhpcy5pbml0aWFsaXplU3RhdHVzQmFyKCk7XG5cdH1cblxuXHQvKipcblx0ICogU2hvd3MgYSBub3RpZmljYXRpb24gbWVzc2FnZS5cblx0ICovXG5cdHNob3dOb3RpZmljYXRpb24obWVzc2FnZTogc3RyaW5nLCBkdXJhdGlvbjogbnVtYmVyID0gNDAwMCk6IHZvaWQge1xuXHRcdGlmICghdGhpcy5lbmFibGVOb3RpZmljYXRpb25zKSByZXR1cm47XG5cdFx0Ly8gUXVldWUgbm90aWZpY2F0aW9uIHRvIGF2b2lkIHNwYW1taW5nIHRoZSBVSS5cblx0XHR0aGlzLm5vdGlmaWNhdGlvblF1ZXVlLnB1c2gobWVzc2FnZSk7XG5cdFx0aWYgKCF0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlKSB7XG5cdFx0XHR0aGlzLnByb2Nlc3NOb3RpZmljYXRpb25RdWV1ZSgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBmaXhlZCBwcm9ncmVzcyBiYXIgd2l0aCB0aGUgY3VycmVudCBwcm9ncmVzcyAoaW4gcGVyY2VudCkgYW5kIHN0YXR1cyBtZXNzYWdlLlxuXHQgKi9cblx0dXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3M6IFRhc2tQcm9ncmVzcyk6IHZvaWQge1xuXHRcdGlmICghdGhpcy5lbmFibGVQcm9ncmVzc0JhcikgcmV0dXJuO1xuXHRcdC8vIENyZWF0ZSB0aGUgZml4ZWQgcHJvZ3Jlc3MgYmFyIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG5cdFx0aWYgKCF0aGlzLmZpeGVkUHJvZ3Jlc3NCYXIpIHtcblx0XHRcdHRoaXMuZml4ZWRQcm9ncmVzc0JhciA9IHRoaXMuY3JlYXRlRml4ZWRQcm9ncmVzc0JhcigpO1xuXHRcdH1cblx0XHRjb25zdCBwcm9ncmVzc1BlcmNlbnRhZ2UgPSBNYXRoLnJvdW5kKHByb2dyZXNzLnByb2dyZXNzKTtcblx0XHR0aGlzLmZpeGVkUHJvZ3Jlc3NCYXIuZmlsbC5zdHlsZS53aWR0aCA9IGAke3Byb2dyZXNzUGVyY2VudGFnZX0lYDtcblx0XHQvLyBEaXNwbGF5IHRoZSBwZXJjZW50YWdlIGFsb25nIHdpdGggYSBjdXN0b20gc3RhdHVzIG1lc3NhZ2UuXG5cdFx0dGhpcy5maXhlZFByb2dyZXNzQmFyLnRleHQudGV4dENvbnRlbnQgPSBgJHtwcm9ncmVzc1BlcmNlbnRhZ2V9JSAtICR7cHJvZ3Jlc3MuY3VycmVudFN0ZXB9ICgke3Byb2dyZXNzLmN1cnJlbnRTdGVwTnVtYmVyfS8ke3Byb2dyZXNzLnRvdGFsU3RlcHN9KWA7XG5cdH1cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgdGhlIHN0YXR1cyBiYXIgY29udGFpbmVyLlxuXHQgKi9cblx0cHJpdmF0ZSBpbml0aWFsaXplU3RhdHVzQmFyKCk6IHZvaWQge1xuXHRcdC8vIENsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuXHRcdHRoaXMuc3RhdHVzQmFySXRlbS5pbm5lckhUTUwgPSAnJztcblx0XHQvLyBDcmVhdGUgYSBjb250YWluZXIgZWxlbWVudCAoaWYgbmVlZGVkKSB0byBob3N0IHRoZSBmaXhlZCBwcm9ncmVzcyBiYXIuXG5cdFx0Y29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0Y29udGFpbmVyLmFkZENsYXNzKCdmaXhlZC1wcm9ncmVzcy1jb250YWluZXInKTtcblx0XHR0aGlzLnN0YXR1c0Jhckl0ZW0uYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgZml4ZWQgcHJvZ3Jlc3MgYmFyIGVsZW1lbnQuXG5cdCAqL1xuXHRwcml2YXRlIGNyZWF0ZUZpeGVkUHJvZ3Jlc3NCYXIoKTogeyBjb250YWluZXI6IEhUTUxFbGVtZW50OyBmaWxsOiBIVE1MRWxlbWVudDsgdGV4dDogSFRNTEVsZW1lbnQgfSB7XG5cdFx0Y29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0Y29udGFpbmVyLmFkZENsYXNzKCdmaXhlZC1wcm9ncmVzcy1iYXItY29udGFpbmVyJyk7XG5cblx0XHRjb25zdCBiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRiYXIuYWRkQ2xhc3MoJ2ZpeGVkLXByb2dyZXNzLWJhcicpO1xuXG5cdFx0Y29uc3QgZmlsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdGZpbGwuYWRkQ2xhc3MoJ2ZpeGVkLXByb2dyZXNzLWZpbGwnKTtcblxuXHRcdGNvbnN0IHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHR0ZXh0LmFkZENsYXNzKCdmaXhlZC1wcm9ncmVzcy10ZXh0Jyk7XG5cblx0XHRiYXIuYXBwZW5kQ2hpbGQoZmlsbCk7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGJhcik7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRleHQpO1xuXHRcdHRoaXMuc3RhdHVzQmFySXRlbS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG5cdFx0cmV0dXJuIHsgY29udGFpbmVyLCBmaWxsLCB0ZXh0IH07XG5cdH1cblxuXHQvKipcblx0ICogUHJvY2Vzc2VzIHRoZSBub3RpZmljYXRpb24gcXVldWUgc2VxdWVudGlhbGx5LlxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBwcm9jZXNzTm90aWZpY2F0aW9uUXVldWUoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKHRoaXMuaXNQcm9jZXNzaW5nUXVldWUgfHwgdGhpcy5ub3RpZmljYXRpb25RdWV1ZS5sZW5ndGggPT09IDApIHJldHVybjtcblx0XHR0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlID0gdHJ1ZTtcblx0XHR0cnkge1xuXHRcdFx0d2hpbGUgKHRoaXMubm90aWZpY2F0aW9uUXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRjb25zdCBtZXNzYWdlID0gdGhpcy5ub3RpZmljYXRpb25RdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHRpZiAobWVzc2FnZSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UobWVzc2FnZSk7XG5cdFx0XHRcdFx0Ly8gV2FpdCBhIGJpdCBiZXR3ZWVuIG5vdGlmaWNhdGlvbnMgdG8gYXZvaWQgc3BhbW1pbmcuXG5cdFx0XHRcdFx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRoaXMuaXNQcm9jZXNzaW5nUXVldWUgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyBub3RpZmljYXRpb24gc2V0dGluZ3MuXG5cdCAqL1xuXHR1cGRhdGVTZXR0aW5ncyhlbmFibGVOb3RpZmljYXRpb25zOiBib29sZWFuLCBlbmFibGVQcm9ncmVzc0JhcjogYm9vbGVhbik6IHZvaWQge1xuXHRcdHRoaXMuZW5hYmxlTm90aWZpY2F0aW9ucyA9IGVuYWJsZU5vdGlmaWNhdGlvbnM7XG5cdFx0dGhpcy5lbmFibGVQcm9ncmVzc0JhciA9IGVuYWJsZVByb2dyZXNzQmFyO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFycyBhbGwgbm90aWZpY2F0aW9ucy5cblx0ICovXG5cdGNsZWFyKCk6IHZvaWQge1xuXHRcdHRoaXMubm90aWZpY2F0aW9uUXVldWUgPSBbXTtcblx0fVxufVxuIiwgIi8vU2V0dGluZ3NUYWIudHNcbmltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IE1pbmRNYXRyaXhQbHVnaW4gZnJvbSAnLi4vbWFpbic7XG5pbXBvcnQgeyBNaW5kTWF0cml4U2V0dGluZ3MsIGdlbmVyYXRlVmF1bHRJZCwgaXNWYXVsdEluaXRpYWxpemVkLCBnZXRVc2VyRXhjbHVzaW9ucywgU1lTVEVNX0VYQ0xVU0lPTlMgfSBmcm9tICcuL1NldHRpbmdzJztcblxuZXhwb3J0IGNsYXNzIE1pbmRNYXRyaXhTZXR0aW5nc1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuXHRwbHVnaW46IE1pbmRNYXRyaXhQbHVnaW47XG5cdHNldHRpbmdzOiBNaW5kTWF0cml4U2V0dGluZ3M7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogTWluZE1hdHJpeFBsdWdpbikge1xuXHRcdHN1cGVyKGFwcCwgcGx1Z2luKTtcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcblx0XHR0aGlzLnNldHRpbmdzID0gcGx1Z2luLnNldHRpbmdzO1xuXHR9XG5cblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHQvLyBEZWJ1Z2dpbmc6IExvZyBhbGwgZXhjbHVzaW9uIHNldHRpbmdzIHRvIGNvbnNvbGVcblx0XHRjb25zb2xlLmxvZyhcIkRFQlVHIC0gQWxsIEV4Y2x1c2lvbiBTZXR0aW5nczpcIiwge1xuXHRcdFx0dXNlclNldHRpbmdzOiB0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMsXG5cdFx0XHRzeXN0ZW1EZWZhdWx0czogU1lTVEVNX0VYQ0xVU0lPTlNcblx0XHR9KTtcblxuXHRcdC8vIFZhdWx0IElkZW50aWZpY2F0aW9uIFNlY3Rpb25cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdWYXVsdCBJZGVudGlmaWNhdGlvbicgfSk7XG5cblx0XHRpZiAoaXNWYXVsdEluaXRpYWxpemVkKHRoaXMuc2V0dGluZ3MpKSB7XG5cdFx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdFx0LnNldE5hbWUoJ1ZhdWx0IElEJylcblx0XHRcdFx0LnNldERlc2MoJ1VuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIHZhdWx0IGluIHRoZSBkYXRhYmFzZS4nKVxuXHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+XG5cdFx0XHRcdFx0dGV4dC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzLnZhdWx0SWQhKVxuXHRcdFx0XHRcdFx0LnNldERpc2FibGVkKHRydWUpXG5cdFx0XHRcdCk7XG5cblx0XHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0XHQuc2V0TmFtZSgnVmF1bHQgTmFtZScpXG5cdFx0XHRcdC5zZXREZXNjKCdUaGUgbmFtZSBvZiB5b3VyIGN1cnJlbnQgdmF1bHQuJylcblx0XHRcdFx0LmFkZFRleHQodGV4dCA9PlxuXHRcdFx0XHRcdHRleHQuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5sYXN0S25vd25WYXVsdE5hbWUpXG5cdFx0XHRcdFx0XHQuc2V0RGlzYWJsZWQodHJ1ZSlcblx0XHRcdFx0KTtcblxuXHRcdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXROYW1lKCdSZXNldCBWYXVsdCBJRCcpXG5cdFx0XHRcdC5zZXREZXNjKCdHZW5lcmF0ZSBhIG5ldyB2YXVsdCBJRCAocmVxdWlyZXMgZnVsbCByZXN5bmMpLicpXG5cdFx0XHRcdC5hZGRCdXR0b24oYnRuID0+XG5cdFx0XHRcdFx0YnRuLnNldEJ1dHRvblRleHQoJ1Jlc2V0Jylcblx0XHRcdFx0XHRcdC5zZXRXYXJuaW5nKClcblx0XHRcdFx0XHRcdC5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgY29uZmlybWVkID0gYXdhaXQgdGhpcy5zaG93UmVzZXRDb25maXJtYXRpb24oKTtcblx0XHRcdFx0XHRcdFx0aWYgKGNvbmZpcm1lZCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MudmF1bHRJZCA9IGdlbmVyYXRlVmF1bHRJZCgpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MubGFzdEtub3duVmF1bHROYW1lID0gdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpO1xuXHRcdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1ZhdWx0IElEIGhhcyBiZWVuIHJlc2V0LiBQbGVhc2UgcmVzeW5jIHlvdXIgdmF1bHQuJyk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5kaXNwbGF5KCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0XHQuc2V0TmFtZSgnSW5pdGlhbGl6ZSBWYXVsdCcpXG5cdFx0XHRcdC5zZXREZXNjKCdHZW5lcmF0ZSBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIHZhdWx0IHRvIGJlZ2luIHN5bmNpbmcuJylcblx0XHRcdFx0LmFkZEJ1dHRvbihidG4gPT5cblx0XHRcdFx0XHRidG4uc2V0QnV0dG9uVGV4dCgnSW5pdGlhbGl6ZScpXG5cdFx0XHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MudmF1bHRJZCA9IGdlbmVyYXRlVmF1bHRJZCgpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmxhc3RLbm93blZhdWx0TmFtZSA9IHRoaXMuYXBwLnZhdWx0LmdldE5hbWUoKTtcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1ZhdWx0IGhhcyBiZWVuIGluaXRpYWxpemVkLicpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmRpc3BsYXkoKTtcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwYWJhc2UgU2V0dGluZ3MgU2VjdGlvblxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1N1cGFiYXNlIENvbmZpZ3VyYXRpb24nIH0pO1xuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ1N1cGFiYXNlIFVSTCcpXG5cdFx0XHQuc2V0RGVzYygnVGhlIFVSTCBvZiB5b3VyIFN1cGFiYXNlIHByb2plY3QgKGUuZy4sIGh0dHBzOi8veW91ci1wcm9qZWN0LnN1cGFiYXNlLmNvKS4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PlxuXHRcdFx0XHR0ZXh0LnNldFBsYWNlaG9sZGVyKCdodHRwczovL3lvdXItcHJvamVjdC5zdXBhYmFzZS5jbycpXG5cdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc2V0dGluZ3Muc3VwYWJhc2UudXJsKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3VwYWJhc2UudXJsID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1N1cGFiYXNlIFVSTCB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHQpO1xuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ1N1cGFiYXNlIEFQSSBLZXknKVxuXHRcdFx0LnNldERlc2MoJ1lvdXIgU3VwYWJhc2UgQVBJIGtleSAoZm91bmQgaW4geW91ciBTdXBhYmFzZSBkYXNoYm9hcmQpLicpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+XG5cdFx0XHRcdHRleHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHlvdXIgQVBJIGtleScpXG5cdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc2V0dGluZ3Muc3VwYWJhc2UuYXBpS2V5KVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3VwYWJhc2UuYXBpS2V5ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1N1cGFiYXNlIEFQSSBrZXkgdXBkYXRlZC4nKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdC8vIE9wZW5BSSBTZXR0aW5ncyBTZWN0aW9uXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnT3BlbkFJIENvbmZpZ3VyYXRpb24nIH0pO1xuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ09wZW5BSSBBUEkgS2V5Jylcblx0XHRcdC5zZXREZXNjKCdZb3VyIE9wZW5BSSBBUEkga2V5IGZvciBnZW5lcmF0aW5nIGVtYmVkZGluZ3MuJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT5cblx0XHRcdFx0dGV4dC5zZXRQbGFjZWhvbGRlcignRW50ZXIgeW91ciBBUEkga2V5Jylcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5vcGVuYWkuYXBpS2V5KVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3Mub3BlbmFpLmFwaUtleSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdPcGVuQUkgQVBJIGtleSB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0Ly8gRG9jdW1lbnQgUHJvY2Vzc2luZyBTZXR0aW5ncyBTZWN0aW9uXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnRG9jdW1lbnQgUHJvY2Vzc2luZycgfSk7XG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnQ2h1bmsgU2l6ZScpXG5cdFx0XHQuc2V0RGVzYygnTWF4aW11bSBzaXplIG9mIHRleHQgY2h1bmtzIChpbiBjaGFyYWN0ZXJzKS4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PlxuXHRcdFx0XHR0ZXh0LnNldFZhbHVlKFN0cmluZyh0aGlzLnNldHRpbmdzLmNodW5raW5nLmNodW5rU2l6ZSkpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgbnVtVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHRcdFx0XHRcdFx0aWYgKCFpc05hTihudW1WYWx1ZSkgJiYgbnVtVmFsdWUgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuY2h1bmtpbmcuY2h1bmtTaXplID0gbnVtVmFsdWU7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdDaHVuayBzaXplIHVwZGF0ZWQuJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSlcblx0XHRcdCk7XG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnQ2h1bmsgT3ZlcmxhcCcpXG5cdFx0XHQuc2V0RGVzYygnT3ZlcmxhcCBiZXR3ZWVuIHRleHQgY2h1bmtzIChpbiBjaGFyYWN0ZXJzKS4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PlxuXHRcdFx0XHR0ZXh0LnNldFZhbHVlKFN0cmluZyh0aGlzLnNldHRpbmdzLmNodW5raW5nLmNodW5rT3ZlcmxhcCkpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgbnVtVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHRcdFx0XHRcdFx0aWYgKCFpc05hTihudW1WYWx1ZSkgJiYgbnVtVmFsdWUgPj0gMCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmNodW5raW5nLmNodW5rT3ZlcmxhcCA9IG51bVZhbHVlO1xuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnQ2h1bmsgb3ZlcmxhcCB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0Ly8gRXhjbHVzaW9uIFNldHRpbmdzIFNlY3Rpb24gLSBPbmx5IHNob3dpbmcgdXNlci1kZWZpbmVkIGV4Y2x1c2lvbnNcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdFeGNsdXNpb25zJyB9KTtcblxuXHRcdC8vIEdldCBvbmx5IHVzZXItZGVmaW5lZCBleGNsdXNpb25zIGZvciBVSSBkaXNwbGF5XG5cdFx0Y29uc3QgdXNlckV4Y2x1c2lvbnMgPSBnZXRVc2VyRXhjbHVzaW9ucyh0aGlzLnNldHRpbmdzKTtcblxuXHRcdC8vIERlYnVnOiBMb2cgdXNlciBleGNsdXNpb25zIGZyb20gdGhlIGZ1bmN0aW9uXG5cdFx0Y29uc29sZS5sb2coXCJERUJVRyAtIFVzZXIgRXhjbHVzaW9ucyBmcm9tIGdldFVzZXJFeGNsdXNpb25zKCk6XCIsIHVzZXJFeGNsdXNpb25zKTtcblxuXHRcdC8vIEZpbHRlciBvdXQgYW55IHN5c3RlbSBleGNsdXNpb25zIHRoYXQgbWlnaHQgaGF2ZSBiZWVuIGFjY2lkZW50YWxseSBzYXZlZCBpbiB1c2VyIGxpc3RzXG5cdFx0Y29uc3Qgc3lzdGVtRm9sZGVycyA9IG5ldyBTZXQoU1lTVEVNX0VYQ0xVU0lPTlMuZm9sZGVycyk7XG5cdFx0Y29uc3Qgc3lzdGVtRmlsZVR5cGVzID0gbmV3IFNldChTWVNURU1fRVhDTFVTSU9OUy5maWxlVHlwZXMpO1xuXHRcdGNvbnN0IHN5c3RlbUZpbGVQcmVmaXhlcyA9IG5ldyBTZXQoU1lTVEVNX0VYQ0xVU0lPTlMuZmlsZVByZWZpeGVzKTtcblx0XHRjb25zdCBzeXN0ZW1GaWxlcyA9IG5ldyBTZXQoU1lTVEVNX0VYQ0xVU0lPTlMuZmlsZXMpO1xuXG5cdFx0Ly8gRGVidWc6IExvZyB0aGUgc3lzdGVtIGV4Y2x1c2lvbiBzZXRzXG5cdFx0Y29uc29sZS5sb2coXCJERUJVRyAtIFN5c3RlbSBFeGNsdXNpb24gU2V0czpcIiwge1xuXHRcdFx0Zm9sZGVyczogQXJyYXkuZnJvbShzeXN0ZW1Gb2xkZXJzKSxcblx0XHRcdGZpbGVUeXBlczogQXJyYXkuZnJvbShzeXN0ZW1GaWxlVHlwZXMpLFxuXHRcdFx0ZmlsZVByZWZpeGVzOiBBcnJheS5mcm9tKHN5c3RlbUZpbGVQcmVmaXhlcyksXG5cdFx0XHRmaWxlczogQXJyYXkuZnJvbShzeXN0ZW1GaWxlcylcblx0XHR9KTtcblxuXHRcdC8vIEZpbHRlciBvdXQgc3lzdGVtIGl0ZW1zIGZyb20gdXNlciBleGNsdXNpb25zXG5cdFx0Y29uc3QgZmlsdGVyZWRVc2VyRm9sZGVycyA9IHVzZXJFeGNsdXNpb25zLmV4Y2x1ZGVkRm9sZGVycy5maWx0ZXIoZm9sZGVyID0+ICFzeXN0ZW1Gb2xkZXJzLmhhcyhmb2xkZXIpKTtcblx0XHRjb25zdCBmaWx0ZXJlZFVzZXJGaWxlVHlwZXMgPSB1c2VyRXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcy5maWx0ZXIodHlwZSA9PiAhc3lzdGVtRmlsZVR5cGVzLmhhcyh0eXBlKSk7XG5cdFx0Y29uc3QgZmlsdGVyZWRVc2VyRmlsZVByZWZpeGVzID0gdXNlckV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlUHJlZml4ZXMuZmlsdGVyKHByZWZpeCA9PiAhc3lzdGVtRmlsZVByZWZpeGVzLmhhcyhwcmVmaXgpKTtcblx0XHRjb25zdCBmaWx0ZXJlZFVzZXJGaWxlcyA9IHVzZXJFeGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMuZmlsdGVyKGZpbGUgPT4gIXN5c3RlbUZpbGVzLmhhcyhmaWxlKSk7XG5cblx0XHQvLyBEZWJ1ZzogTG9nIHRoZSBmaWx0ZXJlZCBleGNsdXNpb25zXG5cdFx0Y29uc29sZS5sb2coXCJERUJVRyAtIEZpbHRlcmVkIFVzZXIgRXhjbHVzaW9uczpcIiwge1xuXHRcdFx0Zm9sZGVyczogZmlsdGVyZWRVc2VyRm9sZGVycyxcblx0XHRcdGZpbGVUeXBlczogZmlsdGVyZWRVc2VyRmlsZVR5cGVzLFxuXHRcdFx0ZmlsZVByZWZpeGVzOiBmaWx0ZXJlZFVzZXJGaWxlUHJlZml4ZXMsXG5cdFx0XHRmaWxlczogZmlsdGVyZWRVc2VyRmlsZXNcblx0XHR9KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0V4Y2x1ZGVkIEZvbGRlcnMnKVxuXHRcdFx0LnNldERlc2MoJ0ZvbGRlcnMgdG8gZXhjbHVkZSBmcm9tIHN5bmNpbmcgKGNvbW1hLXNlcGFyYXRlZCkuJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGZpbHRlcmVkVXNlckZvbGRlcnMuam9pbignLCAnKTtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJERUJVRyAtIFNldHRpbmcgZXhjbHVkZWQgZm9sZGVycyBmaWVsZCB2YWx1ZTpcIiwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gdGV4dC5zZXRQbGFjZWhvbGRlcignZm9sZGVyMSwgZm9sZGVyMicpXG5cdFx0XHRcdFx0LnNldFZhbHVlKHZhbHVlKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiREVCVUcgLSBGb2xkZXJzIG9uQ2hhbmdlIGV2ZW50IHZhbHVlOlwiLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHQvLyBTYXZlIG9ubHkgdXNlci1kZWZpbmVkIGZvbGRlcnMsIGVuc3VyaW5nIHdlIGRvbid0IGR1cGxpY2F0ZSBzeXN0ZW0gZm9sZGVyc1xuXHRcdFx0XHRcdFx0Y29uc3QgdXNlckZvbGRlcnMgPSB2YWx1ZS5zcGxpdCgnLCcpLm1hcChzID0+IHMudHJpbSgpKS5maWx0ZXIocyA9PiBzKTtcblx0XHRcdFx0XHRcdGNvbnN0IGZpbmFsRm9sZGVycyA9IHVzZXJGb2xkZXJzLmZpbHRlcihmb2xkZXIgPT4gIXN5c3RlbUZvbGRlcnMuaGFzKGZvbGRlcikpO1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJERUJVRyAtIEZpbmFsIGZvbGRlcnMgdG8gc2F2ZTpcIiwgZmluYWxGb2xkZXJzKTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZvbGRlcnMgPSBmaW5hbEZvbGRlcnM7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0V4Y2x1ZGVkIGZvbGRlcnMgdXBkYXRlZC4nKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnRXhjbHVkZWQgRmlsZSBUeXBlcycpXG5cdFx0XHQuc2V0RGVzYygnRmlsZSBleHRlbnNpb25zIHRvIGV4Y2x1ZGUgKGNvbW1hLXNlcGFyYXRlZCwgaW5jbHVkZSB0aGUgZG90KS4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gZmlsdGVyZWRVc2VyRmlsZVR5cGVzLmpvaW4oJywgJyk7XG5cblx0XHRcdFx0cmV0dXJuIHRleHQuc2V0UGxhY2Vob2xkZXIoJy50eXBlMSwgLnR5cGUyJylcblx0XHRcdFx0XHQuc2V0VmFsdWUodmFsdWUpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgdXNlckZpbGVUeXBlcyA9IHZhbHVlLnNwbGl0KCcsJykubWFwKHMgPT4gcy50cmltKCkpLmZpbHRlcihzID0+IHMpO1xuXHRcdFx0XHRcdFx0Y29uc3QgZmluYWxGaWxlVHlwZXMgPSB1c2VyRmlsZVR5cGVzLmZpbHRlcih0eXBlID0+ICFzeXN0ZW1GaWxlVHlwZXMuaGFzKHR5cGUpKTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcyA9IGZpbmFsRmlsZVR5cGVzO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdFeGNsdWRlZCBmaWxlIHR5cGVzIHVwZGF0ZWQuJyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0V4Y2x1ZGVkIEZpbGUgUHJlZml4ZXMnKVxuXHRcdFx0LnNldERlc2MoJ0ZpbGUgbmFtZSBwcmVmaXhlcyB0byBleGNsdWRlIChjb21tYS1zZXBhcmF0ZWQpLicpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBmaWx0ZXJlZFVzZXJGaWxlUHJlZml4ZXMuam9pbignLCAnKTtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJERUJVRyAtIFNldHRpbmcgZXhjbHVkZWQgZmlsZSBwcmVmaXhlcyBmaWVsZCB2YWx1ZTpcIiwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gdGV4dC5zZXRQbGFjZWhvbGRlcigndGVtcCwgZHJhZnQnKVxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh2YWx1ZSlcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkRFQlVHIC0gRmlsZSBwcmVmaXhlcyBvbkNoYW5nZSBldmVudCB2YWx1ZTpcIiwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0Ly8gU2F2ZSBvbmx5IHVzZXItZGVmaW5lZCBwcmVmaXhlcywgZW5zdXJpbmcgd2UgZG9uJ3QgZHVwbGljYXRlIHN5c3RlbSBwcmVmaXhlc1xuXHRcdFx0XHRcdFx0Y29uc3QgdXNlckZpbGVQcmVmaXhlcyA9IHZhbHVlLnNwbGl0KCcsJykubWFwKHMgPT4gcy50cmltKCkpLmZpbHRlcihzID0+IHMpO1xuXHRcdFx0XHRcdFx0Y29uc3QgZmluYWxGaWxlUHJlZml4ZXMgPSB1c2VyRmlsZVByZWZpeGVzLmZpbHRlcihwcmVmaXggPT4gIXN5c3RlbUZpbGVQcmVmaXhlcy5oYXMocHJlZml4KSk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkRFQlVHIC0gRmluYWwgZmlsZSBwcmVmaXhlcyB0byBzYXZlOlwiLCBmaW5hbEZpbGVQcmVmaXhlcyk7XG5cdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlUHJlZml4ZXMgPSBmaW5hbEZpbGVQcmVmaXhlcztcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnRXhjbHVkZWQgZmlsZSBwcmVmaXhlcyB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdFeGNsdWRlZCBGaWxlcycpXG5cdFx0XHQuc2V0RGVzYygnU3BlY2lmaWMgZmlsZXMgdG8gZXhjbHVkZSBmcm9tIHN5bmNpbmcgKGNvbW1hLXNlcGFyYXRlZCkuJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGZpbHRlcmVkVXNlckZpbGVzLmpvaW4oJywgJyk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiREVCVUcgLSBTZXR0aW5nIGV4Y2x1ZGVkIGZpbGVzIGZpZWxkIHZhbHVlOlwiLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiB0ZXh0LnNldFBsYWNlaG9sZGVyKCdmaWxlMS5tZCwgZmlsZTIubWQnKVxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh2YWx1ZSlcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkRFQlVHIC0gRmlsZXMgb25DaGFuZ2UgZXZlbnQgdmFsdWU6XCIsIHZhbHVlKTtcblx0XHRcdFx0XHRcdC8vIFNhdmUgb25seSB1c2VyLWRlZmluZWQgZmlsZXMsIGVuc3VyaW5nIHdlIGRvbid0IGR1cGxpY2F0ZSBzeXN0ZW0gZmlsZXNcblx0XHRcdFx0XHRcdGNvbnN0IHVzZXJGaWxlcyA9IHZhbHVlLnNwbGl0KCcsJykubWFwKHMgPT4gcy50cmltKCkpLmZpbHRlcihzID0+IHMpO1xuXHRcdFx0XHRcdFx0Y29uc3QgZmluYWxGaWxlcyA9IHVzZXJGaWxlcy5maWx0ZXIoZmlsZSA9PiAhc3lzdGVtRmlsZXMuaGFzKGZpbGUpKTtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiREVCVUcgLSBGaW5hbCBmaWxlcyB0byBzYXZlOlwiLCBmaW5hbEZpbGVzKTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVzID0gZmluYWxGaWxlcztcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnRXhjbHVkZWQgZmlsZXMgdXBkYXRlZC4nKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0Ly8gSW1wcm92ZWQgaW5mbyB0ZXh0IGFib3V0IHN5c3RlbSBkZWZhdWx0c1xuXHRcdGNvbnN0IGluZm9EaXYgPSBjb250YWluZXJFbC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdzZXR0aW5nLWl0ZW0tZGVzY3JpcHRpb24nIH0pO1xuXHRcdGluZm9EaXYuaW5uZXJIVE1MID0gYFxuXHRcdFx0PHA+PHN0cm9uZz5Ob3RlOjwvc3Ryb25nPiBUaGUgZm9sbG93aW5nIGl0ZW1zIGFyZSBhdXRvbWF0aWNhbGx5IGV4Y2x1ZGVkIGJ5IHRoZSBzeXN0ZW06PC9wPlxuXHRcdFx0PHA+PHN0cm9uZz5Gb2xkZXJzOjwvc3Ryb25nPiAke1NZU1RFTV9FWENMVVNJT05TLmZvbGRlcnMuam9pbignLCAnKX08L3A+XG5cdFx0XHQ8cD48c3Ryb25nPkZpbGUgVHlwZXM6PC9zdHJvbmc+ICR7U1lTVEVNX0VYQ0xVU0lPTlMuZmlsZVR5cGVzLmpvaW4oJywgJyl9PC9wPlxuXHRcdFx0PHA+PHN0cm9uZz5GaWxlIFByZWZpeGVzOjwvc3Ryb25nPiAke1NZU1RFTV9FWENMVVNJT05TLmZpbGVQcmVmaXhlcy5qb2luKCcsICcpfTwvcD5cblx0XHRcdDxwPjxzdHJvbmc+RmlsZXM6PC9zdHJvbmc+ICR7U1lTVEVNX0VYQ0xVU0lPTlMuZmlsZXMuam9pbignLCAnKX08L3A+XG5cdFx0YDtcblxuXHRcdC8vIFF1ZXVlICYgU3luYyBTZXR0aW5ncyBTZWN0aW9uXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnUXVldWUgJiBTeW5jIFNldHRpbmdzJyB9KTtcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdBdXRvIFN5bmMnKVxuXHRcdFx0LnNldERlc2MoJ0F1dG9tYXRpY2FsbHkgc3luYyBjaGFuZ2VzIHRvIHRoZSBkYXRhYmFzZSB3aGVuIGZpbGVzIGFyZSBtb2RpZmllZC4nKVxuXHRcdFx0LmFkZFRvZ2dsZSh0b2dnbGUgPT5cblx0XHRcdFx0dG9nZ2xlLnNldFZhbHVlKHRoaXMuc2V0dGluZ3MuZW5hYmxlQXV0b1N5bmMpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5lbmFibGVBdXRvU3luYyA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdBdXRvIHN5bmMgdXBkYXRlZC4nKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0KTtcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdTeW5jIEZpbGUgUGF0aCcpXG5cdFx0XHQuc2V0RGVzYygnVGhlIHBhdGggZm9yIHRoZSBkZWRpY2F0ZWQgc3luYyBmaWxlLicpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+XG5cdFx0XHRcdHRleHQuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5zeW5jLnN5bmNGaWxlUGF0aClcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLnN5bmMuc3luY0ZpbGVQYXRoID0gdmFsdWU7XG5cdFx0XHRcdFx0XHQvLyBBbHNvIHVwZGF0ZSB0aGUgc3lzdGVtIGV4Y2x1ZGVkIGZpbGVzXG5cdFx0XHRcdFx0XHRjb25zdCBzeXN0ZW1GaWxlcyA9IHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5zeXN0ZW1FeGNsdWRlZEZpbGVzO1xuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIG9sZCBzeW5jIGZpbGUgcmVmZXJlbmNlc1xuXHRcdFx0XHRcdFx0Y29uc3Qgb2xkU3luY0ZpbGVJbmRleCA9IHN5c3RlbUZpbGVzLmZpbmRJbmRleChmID0+IGYgPT09ICdfbWluZG1hdHJpeHN5bmMubWQnKTtcblx0XHRcdFx0XHRcdGNvbnN0IG9sZFN5bmNCYWNrdXBJbmRleCA9IHN5c3RlbUZpbGVzLmZpbmRJbmRleChmID0+IGYgPT09ICdfbWluZG1hdHJpeHN5bmMubWQuYmFja3VwJyk7XG5cdFx0XHRcdFx0XHRpZiAob2xkU3luY0ZpbGVJbmRleCAhPT0gLTEpIHN5c3RlbUZpbGVzLnNwbGljZShvbGRTeW5jRmlsZUluZGV4LCAxKTtcblx0XHRcdFx0XHRcdGlmIChvbGRTeW5jQmFja3VwSW5kZXggIT09IC0xKSBzeXN0ZW1GaWxlcy5zcGxpY2Uob2xkU3luY0JhY2t1cEluZGV4LCAxKTtcblx0XHRcdFx0XHRcdC8vIEFkZCBuZXcgc3luYyBmaWxlIHJlZmVyZW5jZXNcblx0XHRcdFx0XHRcdHN5c3RlbUZpbGVzLnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdFx0c3lzdGVtRmlsZXMucHVzaCh2YWx1ZSArICcuYmFja3VwJyk7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1N5bmMgZmlsZSBwYXRoIHVwZGF0ZWQuJyk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHQvLyBEZWJ1ZyBTZXR0aW5ncyBTZWN0aW9uXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnRGVidWcgU2V0dGluZ3MnIH0pO1xuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0VuYWJsZSBEZWJ1ZyBMb2dzJylcblx0XHRcdC5zZXREZXNjKCdFbmFibGUgZGV0YWlsZWQgZGVidWcgbG9ncyBpbiB0aGUgY29uc29sZS4nKVxuXHRcdFx0LmFkZFRvZ2dsZSh0b2dnbGUgPT5cblx0XHRcdFx0dG9nZ2xlLnNldFZhbHVlKHRoaXMuc2V0dGluZ3MuZGVidWcuZW5hYmxlRGVidWdMb2dzKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuZGVidWcuZW5hYmxlRGVidWdMb2dzID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0RlYnVnIGxvZ3Mgc2V0dGluZyB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHQpO1xuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0xvZyBMZXZlbCcpXG5cdFx0XHQuc2V0RGVzYygnU2VsZWN0IHRoZSBsZXZlbCBvZiBkZXRhaWwgZm9yIGRlYnVnIGxvZ2dpbmcuJylcblx0XHRcdC5hZGREcm9wZG93bihkcm9wZG93biA9PlxuXHRcdFx0XHRkcm9wZG93bi5hZGRPcHRpb24oJ2Vycm9yJywgJ0Vycm9yJylcblx0XHRcdFx0XHQuYWRkT3B0aW9uKCd3YXJuJywgJ1dhcm5pbmcnKVxuXHRcdFx0XHRcdC5hZGRPcHRpb24oJ2luZm8nLCAnSW5mbycpXG5cdFx0XHRcdFx0LmFkZE9wdGlvbignZGVidWcnLCAnRGVidWcnKVxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzLmRlYnVnLmxvZ0xldmVsKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuZGVidWcubG9nTGV2ZWwgPSB2YWx1ZSBhcyAnZXJyb3InIHwgJ3dhcm4nIHwgJ2luZm8nIHwgJ2RlYnVnJztcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnTG9nIGxldmVsIHVwZGF0ZWQuJyk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdCk7XG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnTG9nIHRvIEZpbGUnKVxuXHRcdFx0LnNldERlc2MoJ1NhdmUgZGVidWcgbG9ncyB0byBhIGZpbGUgaW4geW91ciB2YXVsdC4nKVxuXHRcdFx0LmFkZFRvZ2dsZSh0b2dnbGUgPT5cblx0XHRcdFx0dG9nZ2xlLnNldFZhbHVlKHRoaXMuc2V0dGluZ3MuZGVidWcubG9nVG9GaWxlKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuZGVidWcubG9nVG9GaWxlID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0xvZyB0byBmaWxlIHNldHRpbmcgdXBkYXRlZC4nKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0KTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgc2hvd1Jlc2V0Q29uZmlybWF0aW9uKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuXHRcdFx0Y29uc3QgbW9kYWwgPSB0aGlzLmFwcC5tb2RhbDtcblx0XHRcdG1vZGFsLm9wZW4oKG1vZGFsKSA9PiB7XG5cdFx0XHRcdG1vZGFsLnRpdGxlRWwuc2V0VGV4dCgnUmVzZXQgVmF1bHQgSUQnKTtcblx0XHRcdFx0bW9kYWwuY29udGVudEVsLnNldFRleHQoXG5cdFx0XHRcdFx0J1dhcm5pbmc6IFJlc2V0dGluZyB0aGUgdmF1bHQgSUQgd2lsbCBkaXNjb25uZWN0IHRoaXMgdmF1bHQgZnJvbSBpdHMgZXhpc3RpbmcgZGF0YWJhc2UgZW50cmllcy4gVGhpcyBvcGVyYXRpb24gY2Fubm90IGJlIHVuZG9uZS4gQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGNvbnRpbnVlPydcblx0XHRcdFx0KTtcblx0XHRcdFx0bW9kYWwuYWRkQnV0dG9uKChidG4pID0+IHtcblx0XHRcdFx0XHRidG4uc2V0QnV0dG9uVGV4dCgnQ2FuY2VsJykub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKGZhbHNlKTtcblx0XHRcdFx0XHRcdG1vZGFsLmNsb3NlKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRtb2RhbC5hZGRCdXR0b24oKGJ0bikgPT4ge1xuXHRcdFx0XHRcdGJ0bi5zZXRCdXR0b25UZXh0KCdSZXNldCcpLnNldFdhcm5pbmcoKS5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHRcdHJlc29sdmUodHJ1ZSk7XG5cdFx0XHRcdFx0XHRtb2RhbC5jbG9zZSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG59XG4iLCAiLy8gc3JjL3NlcnZpY2VzL0luaXRpYWxTeW5jTWFuYWdlci50c1xuaW1wb3J0IHsgVEZpbGUsIFZhdWx0LCBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBFcnJvckhhbmRsZXIgfSBmcm9tICcuLi91dGlscy9FcnJvckhhbmRsZXInO1xuaW1wb3J0IHsgTm90aWZpY2F0aW9uTWFuYWdlciB9IGZyb20gJy4uL3V0aWxzL05vdGlmaWNhdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgUXVldWVTZXJ2aWNlIH0gZnJvbSAnLi9RdWV1ZVNlcnZpY2UnO1xuaW1wb3J0IHsgU3luY0ZpbGVNYW5hZ2VyIH0gZnJvbSAnLi9TeW5jRmlsZU1hbmFnZXInO1xuaW1wb3J0IHsgTWV0YWRhdGFFeHRyYWN0b3IgfSBmcm9tICcuL01ldGFkYXRhRXh0cmFjdG9yJztcbmltcG9ydCB7IFN1cGFiYXNlU2VydmljZSB9IGZyb20gJy4vU3VwYWJhc2VTZXJ2aWNlJztcblxuaW50ZXJmYWNlIEluaXRpYWxTeW5jT3B0aW9ucyB7XG5cdGJhdGNoU2l6ZTogbnVtYmVyO1xuXHRtYXhDb25jdXJyZW50QmF0Y2hlczogbnVtYmVyO1xuXHRlbmFibGVBdXRvSW5pdGlhbFN5bmM6IGJvb2xlYW47XG5cdHByaW9yaXR5UnVsZXM6IFByaW9yaXR5UnVsZVtdO1xuXHRzeW5jRmlsZVBhdGg/OiBzdHJpbmc7XG5cdGV4Y2x1c2lvbnM/OiB7XG5cdFx0ZXhjbHVkZWRGb2xkZXJzOiBzdHJpbmdbXTtcblx0XHRleGNsdWRlZEZpbGVUeXBlczogc3RyaW5nW107XG5cdFx0ZXhjbHVkZWRGaWxlUHJlZml4ZXM6IHN0cmluZ1tdO1xuXHRcdGV4Y2x1ZGVkRmlsZXM6IHN0cmluZ1tdO1xuXHR9O1xufVxuXG5pbnRlcmZhY2UgUHJpb3JpdHlSdWxlIHtcblx0cGF0dGVybjogc3RyaW5nO1xuXHRwcmlvcml0eTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgU3luY0JhdGNoIHtcblx0aWQ6IHN0cmluZztcblx0ZmlsZXM6IFRGaWxlW107XG5cdHN0YXR1czogJ3BlbmRpbmcnIHwgJ3Byb2Nlc3NpbmcnIHwgJ2NvbXBsZXRlZCcgfCAnZmFpbGVkJztcblx0cHJvZ3Jlc3M6IG51bWJlcjtcblx0c3RhcnRUaW1lPzogbnVtYmVyO1xuXHRlbmRUaW1lPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNQcm9ncmVzcyB7XG5cdHRvdGFsRmlsZXM6IG51bWJlcjtcblx0cHJvY2Vzc2VkRmlsZXM6IG51bWJlcjtcblx0Y3VycmVudEJhdGNoOiBudW1iZXI7XG5cdHRvdGFsQmF0Y2hlczogbnVtYmVyO1xuXHRzdGFydFRpbWU6IG51bWJlcjtcblx0ZXN0aW1hdGVkVGltZVJlbWFpbmluZz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEluaXRpYWxTeW5jTWFuYWdlciB7XG5cdHByaXZhdGUgYmF0Y2hlczogU3luY0JhdGNoW10gPSBbXTtcblx0cHJpdmF0ZSBwcm9ncmVzczogU3luY1Byb2dyZXNzO1xuXHRwcml2YXRlIGlzUnVubmluZzogYm9vbGVhbiA9IGZhbHNlO1xuXHRwcml2YXRlIGxhc3RQcm9jZXNzZWRJbmRleDogbnVtYmVyID0gMDsgLy8gRm9yIHJlc3VtaW5nIGludGVycnVwdGVkIHN5bmNzXG5cdHByaXZhdGUgcHJvY2Vzc2luZ1RpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogSW5pdGlhbFN5bmNPcHRpb25zO1xuXHRwcml2YXRlIHN1cGFiYXNlU2VydmljZTogU3VwYWJhc2VTZXJ2aWNlIHwgbnVsbDtcblx0cHJpdmF0ZSByZXN1bWVGaWxlTGlzdDogVEZpbGVbXSA9IFtdO1xuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByaXZhdGUgdmF1bHQ6IFZhdWx0LFxuXHRcdHByaXZhdGUgcXVldWVTZXJ2aWNlOiBRdWV1ZVNlcnZpY2UsXG5cdFx0cHJpdmF0ZSBzeW5jRmlsZU1hbmFnZXI6IFN5bmNGaWxlTWFuYWdlcixcblx0XHRwcml2YXRlIG1ldGFkYXRhRXh0cmFjdG9yOiBNZXRhZGF0YUV4dHJhY3Rvcixcblx0XHRwcml2YXRlIGVycm9ySGFuZGxlcjogRXJyb3JIYW5kbGVyLFxuXHRcdHByaXZhdGUgbm90aWZpY2F0aW9uTWFuYWdlcjogTm90aWZpY2F0aW9uTWFuYWdlcixcblx0XHRzdXBhYmFzZVNlcnZpY2U6IFN1cGFiYXNlU2VydmljZSB8IG51bGwsXG5cdFx0b3B0aW9uczogUGFydGlhbDxJbml0aWFsU3luY09wdGlvbnM+ID0ge31cblx0KSB7XG5cdFx0dGhpcy5vcHRpb25zID0ge1xuXHRcdFx0YmF0Y2hTaXplOiA1MCxcblx0XHRcdG1heENvbmN1cnJlbnRCYXRjaGVzOiAzLFxuXHRcdFx0ZW5hYmxlQXV0b0luaXRpYWxTeW5jOiB0cnVlLFxuXHRcdFx0cHJpb3JpdHlSdWxlczogW10sXG5cdFx0XHRzeW5jRmlsZVBhdGg6ICdfbWluZG1hdHJpeHN5bmMubWQnLFxuXHRcdFx0ZXhjbHVzaW9uczoge1xuXHRcdFx0XHRleGNsdWRlZEZvbGRlcnM6IFtdLFxuXHRcdFx0XHRleGNsdWRlZEZpbGVUeXBlczogW10sXG5cdFx0XHRcdGV4Y2x1ZGVkRmlsZVByZWZpeGVzOiBbXSxcblx0XHRcdFx0ZXhjbHVkZWRGaWxlczogW11cblx0XHRcdH0sXG5cdFx0XHQuLi5vcHRpb25zXG5cdFx0fTtcblx0XHR0aGlzLnByb2dyZXNzID0ge1xuXHRcdFx0dG90YWxGaWxlczogMCxcblx0XHRcdHByb2Nlc3NlZEZpbGVzOiAwLFxuXHRcdFx0Y3VycmVudEJhdGNoOiAwLFxuXHRcdFx0dG90YWxCYXRjaGVzOiAwLFxuXHRcdFx0c3RhcnRUaW1lOiAwXG5cdFx0fTtcblx0XHR0aGlzLnN1cGFiYXNlU2VydmljZSA9IHN1cGFiYXNlU2VydmljZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGaWx0ZXIgZmlsZXMgYmFzZWQgb24gZXhjbHVzaW9uIHJ1bGVzXG5cdCAqL1xuXHRwcml2YXRlIGZpbHRlckV4Y2x1ZGVkRmlsZXMoZmlsZXM6IFRGaWxlW10pOiBURmlsZVtdIHtcblxuXHRcdGNvbnN0IHN5bmNGaWxlUGF0aCA9IHRoaXMub3B0aW9ucy5zeW5jRmlsZVBhdGggfHwgJ19taW5kbWF0cml4c3luYy5tZCc7XG5cdFx0Y29uc3QgZXhjbHVzaW9ucyA9IHRoaXMub3B0aW9ucy5leGNsdXNpb25zIHx8IHtcblx0XHRcdGV4Y2x1ZGVkRm9sZGVyczogW10sXG5cdFx0XHRleGNsdWRlZEZpbGVUeXBlczogW10sXG5cdFx0XHRleGNsdWRlZEZpbGVQcmVmaXhlczogW10sXG5cdFx0XHRleGNsdWRlZEZpbGVzOiBbXVxuXHRcdH07XG5cblx0XHRyZXR1cm4gZmlsZXMuZmlsdGVyKGZpbGUgPT4ge1xuXHRcdFx0Y29uc3QgZmlsZVBhdGggPSBmaWxlLnBhdGg7XG5cdFx0XHRjb25zdCBmaWxlTmFtZSA9IGZpbGUubmFtZTtcblxuXHRcdFx0Ly8gRmlyc3QgZXhwbGljaXRseSBjaGVjayBmb3Igc3luYyBmaWxlc1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRmaWxlUGF0aCA9PT0gc3luY0ZpbGVQYXRoIHx8XG5cdFx0XHRcdGZpbGVQYXRoID09PSAnX21pbmRtYXRyaXhzeW5jLm1kJyB8fFxuXHRcdFx0XHRmaWxlUGF0aCA9PT0gJ19taW5kbWF0cml4c3luYy5tZC5iYWNrdXAnXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBleGNsdWRlZCBmaWxlc1xuXHRcdFx0aWYgKGV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlcyAmJiBleGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMuaW5jbHVkZXMoZmlsZU5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2sgZXhjbHVkZWQgZm9sZGVyc1xuXHRcdFx0aWYgKGV4Y2x1c2lvbnMuZXhjbHVkZWRGb2xkZXJzKSB7XG5cdFx0XHRcdGZvciAoY29uc3QgZm9sZGVyIG9mIGV4Y2x1c2lvbnMuZXhjbHVkZWRGb2xkZXJzKSB7XG5cdFx0XHRcdFx0Y29uc3Qgbm9ybWFsaXplZEZvbGRlciA9IGZvbGRlci5lbmRzV2l0aCgnLycpID8gZm9sZGVyIDogZm9sZGVyICsgJy8nO1xuXHRcdFx0XHRcdGlmIChmaWxlUGF0aC5zdGFydHNXaXRoKG5vcm1hbGl6ZWRGb2xkZXIpKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhgW0luaXRpYWxTeW5jTWFuYWdlci5maWx0ZXJFeGNsdWRlZEZpbGVzXSBFeGNsdWRpbmcgZmlsZSBpbiBleGNsdWRlZCBmb2xkZXI6ICR7ZmlsZVBhdGh9YCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGV4Y2x1ZGVkIGZpbGUgdHlwZXNcblx0XHRcdGlmIChleGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVR5cGVzKSB7XG5cdFx0XHRcdGZvciAoY29uc3QgZmlsZVR5cGUgb2YgZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcykge1xuXHRcdFx0XHRcdGlmIChmaWxlUGF0aC50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGZpbGVUeXBlLnRvTG93ZXJDYXNlKCkpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGV4Y2x1ZGVkIGZpbGUgcHJlZml4ZXNcblx0XHRcdGlmIChleGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVByZWZpeGVzKSB7XG5cdFx0XHRcdGZvciAoY29uc3QgcHJlZml4IG9mIGV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlUHJlZml4ZXMpIHtcblx0XHRcdFx0XHRpZiAoZmlsZU5hbWUuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXJ0IHRoZSBpbml0aWFsIHN5bmMgcHJvY2Vzcy5cblx0ICogU2NhbnMgYWxsIG1hcmtkb3duIGZpbGVzIGluIHRoZSB2YXVsdCBhbmQgdXBkYXRlcyB0aGVpciBzdGF0dXMgaW4gdGhlIGRhdGFiYXNlLlxuXHQgKiBJZiBpbnRlcnJ1cHRlZCwgcmVzdW1lcyBmcm9tIHRoZSBsYXN0IHByb2Nlc3NlZCBmaWxlLlxuXHQgKi9cblx0YXN5bmMgc3RhcnRTeW5jKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICh0aGlzLmlzUnVubmluZykge1xuXHRcdFx0Y29uc29sZS5sb2coJ0luaXRpYWwgc3luYyBhbHJlYWR5IHJ1bm5pbmcnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcblx0XHRcdHRoaXMucHJvZ3Jlc3Muc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuXHRcdFx0Ly8gR2V0IGFsbCBtYXJrZG93biBmaWxlcyBmcm9tIHRoZSB2YXVsdFxuXHRcdFx0Y29uc3QgYWxsRmlsZXMgPSB0aGlzLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBleGNsdWRlZCBmaWxlc1xuXHRcdFx0Y29uc3QgZmlsZXMgPSB0aGlzLmZpbHRlckV4Y2x1ZGVkRmlsZXMoYWxsRmlsZXMpO1xuXG5cdFx0XHQvLyBBZGRpdGlvbmFsIGxvZ2dpbmcgZm9yIHZlcmlmaWNhdGlvblxuXHRcdFx0Y29uc3Qgc3luY0ZpbGVQYXRoID0gdGhpcy5vcHRpb25zLnN5bmNGaWxlUGF0aCB8fCAnX21pbmRtYXRyaXhzeW5jLm1kJztcblxuXHRcdFx0Ly8gVmVyaWZ5IHN5bmMgZmlsZSBpcyBub3QgaW5jbHVkZWRcblx0XHRcdGNvbnN0IHN5bmNGaWxlSW5jbHVkZWQgPSBmaWxlcy5zb21lKGZpbGUgPT5cblx0XHRcdFx0ZmlsZS5wYXRoID09PSBzeW5jRmlsZVBhdGggfHxcblx0XHRcdFx0ZmlsZS5wYXRoID09PSAnX21pbmRtYXRyaXhzeW5jLm1kJyB8fFxuXHRcdFx0XHRmaWxlLnBhdGggPT09ICdfbWluZG1hdHJpeHN5bmMubWQuYmFja3VwJ1xuXHRcdFx0KTtcblxuXHRcdFx0dGhpcy5yZXN1bWVGaWxlTGlzdCA9IGF3YWl0IHRoaXMuc29ydEZpbGVzQnlQcmlvcml0eShmaWxlcyk7XG5cdFx0XHR0aGlzLnByb2dyZXNzLnRvdGFsRmlsZXMgPSB0aGlzLnJlc3VtZUZpbGVMaXN0Lmxlbmd0aDtcblx0XHRcdC8vIENyZWF0ZSBiYXRjaGVzIGJhc2VkIG9uIHJlc3VtZUZpbGVMaXN0IGFuZCBsYXN0UHJvY2Vzc2VkSW5kZXhcblx0XHRcdHRoaXMuYmF0Y2hlcyA9IHRoaXMuY3JlYXRlQmF0Y2hlcyh0aGlzLnJlc3VtZUZpbGVMaXN0LnNsaWNlKHRoaXMubGFzdFByb2Nlc3NlZEluZGV4KSk7XG5cdFx0XHR0aGlzLnByb2dyZXNzLnRvdGFsQmF0Y2hlcyA9IHRoaXMuYmF0Y2hlcy5sZW5ndGg7XG5cdFx0XHQvLyBQcm9jZXNzIGVhY2ggYmF0Y2ggY29uY3VycmVudGx5IHdpdGggYSBsaW1pdFxuXHRcdFx0YXdhaXQgdGhpcy5wcm9jZXNzQmF0Y2hlcygpO1xuXHRcdFx0bmV3IE5vdGljZSgnSW5pdGlhbCBzeW5jIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKTtcblx0XHRcdC8vIFJlc2V0IHJlc3VtZSBpbmRleCB1cG9uIHN1Y2Nlc3NmdWwgY29tcGxldGlvblxuXHRcdFx0dGhpcy5sYXN0UHJvY2Vzc2VkSW5kZXggPSAwO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnSW5pdGlhbFN5bmNNYW5hZ2VyLnN0YXJ0U3luYycgfSk7XG5cdFx0XHRuZXcgTm90aWNlKCdJbml0aWFsIHN5bmMgZmFpbGVkLiBDaGVjayBjb25zb2xlIGZvciBkZXRhaWxzLicpO1xuXHRcdFx0Ly8gUmV0YWluIGxhc3RQcm9jZXNzZWRJbmRleCBzbyB0aGF0IGEgc3Vic2VxdWVudCBzeW5jIGNhbiByZXN1bWUgZnJvbSB3aGVyZSBpdCBsZWZ0IG9mZi5cblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU29ydCBmaWxlcyBieSBwcmlvcml0eSBiYXNlZCBvbiBydWxlcy5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgc29ydEZpbGVzQnlQcmlvcml0eShmaWxlczogVEZpbGVbXSk6IFByb21pc2U8VEZpbGVbXT4ge1xuXHRcdHJldHVybiBmaWxlcy5zb3J0KChhLCBiKSA9PiB7XG5cdFx0XHRjb25zdCBwcmlvcml0eUEgPSB0aGlzLmdldEZpbGVQcmlvcml0eShhLnBhdGgpO1xuXHRcdFx0Y29uc3QgcHJpb3JpdHlCID0gdGhpcy5nZXRGaWxlUHJpb3JpdHkoYi5wYXRoKTtcblx0XHRcdHJldHVybiBwcmlvcml0eUIgLSBwcmlvcml0eUE7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIHByaW9yaXR5IGZvciBhIGZpbGUuXG5cdCAqL1xuXHRwcml2YXRlIGdldEZpbGVQcmlvcml0eShwYXRoOiBzdHJpbmcpOiBudW1iZXIge1xuXHRcdGZvciAoY29uc3QgcnVsZSBvZiB0aGlzLm9wdGlvbnMucHJpb3JpdHlSdWxlcykge1xuXHRcdFx0aWYgKHBhdGguaW5jbHVkZXMocnVsZS5wYXR0ZXJuKSkge1xuXHRcdFx0XHRyZXR1cm4gcnVsZS5wcmlvcml0eTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIGJhdGNoZXMgb2YgZmlsZXMgZm9yIHByb2Nlc3NpbmcuXG5cdCAqL1xuXHRwcml2YXRlIGNyZWF0ZUJhdGNoZXMoZmlsZXM6IFRGaWxlW10pOiBTeW5jQmF0Y2hbXSB7XG5cblx0XHQvLyBEb3VibGUtY2hlY2sgZm9yIHN5bmMgZmlsZSBhcyBhIHNhZmV0eSBtZWFzdXJlXG5cdFx0Y29uc3Qgc3luY0ZpbGVQYXRoID0gdGhpcy5vcHRpb25zLnN5bmNGaWxlUGF0aCB8fCAnX21pbmRtYXRyaXhzeW5jLm1kJztcblx0XHRjb25zdCBzeW5jRmlsZUluY2x1ZGVkID0gZmlsZXMuc29tZShmaWxlID0+XG5cdFx0XHRmaWxlLnBhdGggPT09IHN5bmNGaWxlUGF0aCB8fFxuXHRcdFx0ZmlsZS5wYXRoID09PSAnX21pbmRtYXRyaXhzeW5jLm1kJyB8fFxuXHRcdFx0ZmlsZS5wYXRoID09PSAnX21pbmRtYXRyaXhzeW5jLm1kLmJhY2t1cCdcblx0XHQpO1xuXG5cdFx0aWYgKHN5bmNGaWxlSW5jbHVkZWQpIHtcblx0XHRcdC8vIEFkZGl0aW9uYWwgc2FmZXR5OiBmaWx0ZXIgaGVyZSB0b29cblx0XHRcdGZpbGVzID0gZmlsZXMuZmlsdGVyKGZpbGUgPT5cblx0XHRcdFx0ZmlsZS5wYXRoICE9PSBzeW5jRmlsZVBhdGggJiZcblx0XHRcdFx0ZmlsZS5wYXRoICE9PSAnX21pbmRtYXRyaXhzeW5jLm1kJyAmJlxuXHRcdFx0XHRmaWxlLnBhdGggIT09ICdfbWluZG1hdHJpeHN5bmMubWQuYmFja3VwJ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRjb25zdCBiYXRjaGVzOiBTeW5jQmF0Y2hbXSA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpICs9IHRoaXMub3B0aW9ucy5iYXRjaFNpemUpIHtcblx0XHRcdGNvbnN0IGJhdGNoRmlsZXMgPSBmaWxlcy5zbGljZShpLCBpICsgdGhpcy5vcHRpb25zLmJhdGNoU2l6ZSk7XG5cdFx0XHRiYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRpZDogYGJhdGNoLSR7TWF0aC5mbG9vcihpIC8gdGhpcy5vcHRpb25zLmJhdGNoU2l6ZSl9YCxcblx0XHRcdFx0ZmlsZXM6IGJhdGNoRmlsZXMsXG5cdFx0XHRcdHN0YXR1czogJ3BlbmRpbmcnLFxuXHRcdFx0XHRwcm9ncmVzczogMFxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBiYXRjaGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgYmF0Y2hlcyBjb25jdXJyZW50bHkgd2l0aCBhIGxpbWl0LlxuXHQgKiBBbHNvIHVwZGF0ZXMgcmVzdW1lIHByb2dyZXNzIGluIGNhc2Ugb2YgaW50ZXJydXB0aW9uLlxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBwcm9jZXNzQmF0Y2hlcygpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBhY3RpdmVCYXRjaGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cdFx0Zm9yIChjb25zdCBiYXRjaCBvZiB0aGlzLmJhdGNoZXMpIHtcblx0XHRcdHdoaWxlIChhY3RpdmVCYXRjaGVzLnNpemUgPj0gdGhpcy5vcHRpb25zLm1heENvbmN1cnJlbnRCYXRjaGVzKSB7XG5cdFx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcblx0XHRcdH1cblx0XHRcdGFjdGl2ZUJhdGNoZXMuYWRkKGJhdGNoLmlkKTtcblx0XHRcdHRoaXMucHJvY2Vzc0JhdGNoKGJhdGNoKVxuXHRcdFx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0YWN0aXZlQmF0Y2hlcy5kZWxldGUoYmF0Y2guaWQpO1xuXHRcdFx0XHRcdC8vIFVwZGF0ZSByZXN1bWUgaW5kZXggYWZ0ZXIgYmF0Y2ggY29tcGxldGVzXG5cdFx0XHRcdFx0dGhpcy5sYXN0UHJvY2Vzc2VkSW5kZXggKz0gYmF0Y2guZmlsZXMubGVuZ3RoO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY2F0Y2goZXJyb3IgPT4ge1xuXHRcdFx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7XG5cdFx0XHRcdFx0XHRjb250ZXh0OiAnSW5pdGlhbFN5bmNNYW5hZ2VyLnByb2Nlc3NCYXRjaCcsXG5cdFx0XHRcdFx0XHRtZXRhZGF0YTogeyBiYXRjaElkOiBiYXRjaC5pZCB9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YWN0aXZlQmF0Y2hlcy5kZWxldGUoYmF0Y2guaWQpO1xuXHRcdFx0XHRcdC8vIE9wdGlvbmFsbHksIG1hcmsgYmF0Y2ggYXMgZmFpbGVkIG9yIHJldHJ5IGxhdGVyXG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0XHQvLyBXYWl0IGZvciBhbGwgYmF0Y2hlcyB0byBjb21wbGV0ZVxuXHRcdHdoaWxlIChhY3RpdmVCYXRjaGVzLnNpemUgPiAwKSB7XG5cdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgYSBzaW5nbGUgYmF0Y2ggb2YgZmlsZXMuXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIHByb2Nlc3NCYXRjaChiYXRjaDogU3luY0JhdGNoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dHJ5IHtcblx0XHRcdGJhdGNoLnN0YXR1cyA9ICdwcm9jZXNzaW5nJztcblx0XHRcdGJhdGNoLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cdFx0XHRmb3IgKGNvbnN0IGZpbGUgb2YgYmF0Y2guZmlsZXMpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnByb2Nlc3NGaWxlKGZpbGUpO1xuXHRcdFx0XHRcdHRoaXMucHJvZ3Jlc3MucHJvY2Vzc2VkRmlsZXMrKztcblx0XHRcdFx0XHRiYXRjaC5wcm9ncmVzcyA9ICh0aGlzLnByb2dyZXNzLnByb2Nlc3NlZEZpbGVzIC8gdGhpcy5wcm9ncmVzcy50b3RhbEZpbGVzKSAqIDEwMDtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZVByb2dyZXNzTm90aWZpY2F0aW9uKCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0XHRcdGNvbnRleHQ6ICdJbml0aWFsU3luY01hbmFnZXIucHJvY2Vzc0ZpbGUnLFxuXHRcdFx0XHRcdFx0bWV0YWRhdGE6IHsgZmlsZVBhdGg6IGZpbGUucGF0aCB9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGJhdGNoLnN0YXR1cyA9ICdjb21wbGV0ZWQnO1xuXHRcdFx0YmF0Y2guZW5kVGltZSA9IERhdGUubm93KCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGJhdGNoLnN0YXR1cyA9ICdmYWlsZWQnO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgYSBzaW5nbGUgZmlsZS5cblx0ICogRXh0cmFjdHMgbWV0YWRhdGEsIGNhbGN1bGF0ZXMgZmlsZSBoYXNoLCBhbmQgdXBkYXRlcyBpdHMgc3RhdHVzLlxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBwcm9jZXNzRmlsZShmaWxlOiBURmlsZSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBGaW5hbCBzYWZldHkgY2hlY2sgYmVmb3JlIHByb2Nlc3Npbmdcblx0XHRcdGNvbnN0IHN5bmNGaWxlUGF0aCA9IHRoaXMub3B0aW9ucy5zeW5jRmlsZVBhdGggfHwgJ19taW5kbWF0cml4c3luYy5tZCc7XG5cdFx0XHRpZiAoZmlsZS5wYXRoID09PSBzeW5jRmlsZVBhdGggfHxcblx0XHRcdFx0ZmlsZS5wYXRoID09PSAnX21pbmRtYXRyaXhzeW5jLm1kJyB8fFxuXHRcdFx0XHRmaWxlLnBhdGggPT09ICdfbWluZG1hdHJpeHN5bmMubWQuYmFja3VwJykge1xuXHRcdFx0XHRyZXR1cm47IC8vIFNraXAgcHJvY2Vzc2luZyBlbnRpcmVseVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBFeHRyYWN0IG1ldGFkYXRhXG5cdFx0XHRjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMubWV0YWRhdGFFeHRyYWN0b3IuZXh0cmFjdE1ldGFkYXRhKGZpbGUpO1xuXHRcdFx0Ly8gQ2FsY3VsYXRlIGZpbGUgaGFzaCBmb3IgY2hhbmdlIGRldGVjdGlvblxuXHRcdFx0Y29uc3QgZmlsZUhhc2ggPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUZpbGVIYXNoKGZpbGUpO1xuXHRcdFx0Ly8gVXBkYXRlIGZpbGUgc3RhdHVzIGluIHRoZSBkYXRhYmFzZSB2aWEgU3VwYWJhc2UgaWYgYXZhaWxhYmxlLCBlbHNlIGZhbGxiYWNrIHRvIHN5bmMgZmlsZVxuXHRcdFx0aWYgKHRoaXMuc3VwYWJhc2VTZXJ2aWNlKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLnVwZGF0ZUZpbGVWZWN0b3JpemF0aW9uU3RhdHVzKG1ldGFkYXRhKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEZhbGxiYWNrOiB1cGRhdGUgc3luYyBmaWxlIHN0YXR1cyAoYXNzdW1pbmcgdXBkYXRlU3luY1N0YXR1cyBtZXRob2QgZXhpc3RzKVxuXHRcdFx0XHRhd2FpdCB0aGlzLnN5bmNGaWxlTWFuYWdlci51cGRhdGVTeW5jU3RhdHVzKGZpbGUucGF0aCwgJ1BFTkRJTkcnLCB7XG5cdFx0XHRcdFx0bGFzdE1vZGlmaWVkOiBmaWxlLnN0YXQubXRpbWUsXG5cdFx0XHRcdFx0aGFzaDogZmlsZUhhc2hcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBRdWV1ZSBmaWxlIHByb2Nlc3NpbmcgKGUuZy4sIGZvciBlbWJlZGRpbmcgZ2VuZXJhdGlvbilcblx0XHRcdGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdFx0dGhpcy5xdWV1ZVNlcnZpY2UuYWRkVGFzayh7XG5cdFx0XHRcdFx0aWQ6IGZpbGUucGF0aCxcblx0XHRcdFx0XHR0eXBlOiAnQ1JFQVRFJyxcblx0XHRcdFx0XHRwcmlvcml0eTogdGhpcy5nZXRGaWxlUHJpb3JpdHkoZmlsZS5wYXRoKSxcblx0XHRcdFx0XHRtYXhSZXRyaWVzOiAzLFxuXHRcdFx0XHRcdHJldHJ5Q291bnQ6IDAsXG5cdFx0XHRcdFx0Y3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuXHRcdFx0XHRcdHVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcblx0XHRcdFx0XHRzdGF0dXM6ICdQRU5ESU5HJyxcblx0XHRcdFx0XHRtZXRhZGF0YSxcblx0XHRcdFx0XHRkYXRhOiB7fVxuXHRcdFx0XHR9KS50aGVuKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHQvLyBBZnRlciBwcm9jZXNzaW5nLCBtYXJrIGZpbGUgYXMgJ09LJyBpbiB0aGUgZGF0YWJhc2Ugb3Igc3luYyBmaWxlLlxuXHRcdFx0XHRcdGlmICh0aGlzLnN1cGFiYXNlU2VydmljZSkge1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UudXBkYXRlRmlsZVZlY3Rvcml6YXRpb25TdGF0dXMobWV0YWRhdGEpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnN5bmNGaWxlTWFuYWdlci51cGRhdGVTeW5jU3RhdHVzKGZpbGUucGF0aCwgJ09LJywge1xuXHRcdFx0XHRcdFx0XHRsYXN0TW9kaWZpZWQ6IGZpbGUuc3RhdC5tdGltZSxcblx0XHRcdFx0XHRcdFx0aGFzaDogZmlsZUhhc2hcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdH0pLmNhdGNoKHJlamVjdCk7XG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ0luaXRpYWxTeW5jTWFuYWdlci5wcm9jZXNzRmlsZScsXG5cdFx0XHRcdG1ldGFkYXRhOiB7IGZpbGVQYXRoOiBmaWxlLnBhdGggfVxuXHRcdFx0fSk7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlIFNIQS0yNTYgaGFzaCBvZiBhIGZpbGUncyBjb250ZW50LlxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBjYWxjdWxhdGVGaWxlSGFzaChmaWxlOiBURmlsZSk6IFByb21pc2U8c3RyaW5nPiB7XG5cdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHQucmVhZChmaWxlKTtcblx0XHRjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5cdFx0Y29uc3QgZGF0YSA9IGVuY29kZXIuZW5jb2RlKGNvbnRlbnQpO1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgZGF0YSk7XG5cdFx0cmV0dXJuIEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSlcblx0XHRcdC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKVxuXHRcdFx0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBwcm9ncmVzcyBub3RpZmljYXRpb25zLlxuXHQgKi9cblx0cHJpdmF0ZSB1cGRhdGVQcm9ncmVzc05vdGlmaWNhdGlvbigpOiB2b2lkIHtcblx0XHRjb25zdCBwcm9ncmVzc1BlcmNlbnRhZ2UgPSAodGhpcy5wcm9ncmVzcy5wcm9jZXNzZWRGaWxlcyAvIHRoaXMucHJvZ3Jlc3MudG90YWxGaWxlcykgKiAxMDA7XG5cdFx0dGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyLnVwZGF0ZVByb2dyZXNzKHtcblx0XHRcdHRhc2tJZDogJ2luaXRpYWwtc3luYycsXG5cdFx0XHRwcm9ncmVzczogcHJvZ3Jlc3NQZXJjZW50YWdlLFxuXHRcdFx0Y3VycmVudFN0ZXA6IGBQcm9jZXNzaW5nIGZpbGVzICgke3RoaXMucHJvZ3Jlc3MucHJvY2Vzc2VkRmlsZXN9LyR7dGhpcy5wcm9ncmVzcy50b3RhbEZpbGVzfSlgLFxuXHRcdFx0dG90YWxTdGVwczogdGhpcy5wcm9ncmVzcy50b3RhbEJhdGNoZXMsXG5cdFx0XHRjdXJyZW50U3RlcE51bWJlcjogdGhpcy5wcm9ncmVzcy5jdXJyZW50QmF0Y2ggKyAxLFxuXHRcdFx0ZXN0aW1hdGVkVGltZVJlbWFpbmluZzogdGhpcy5jYWxjdWxhdGVFc3RpbWF0ZWRUaW1lUmVtYWluaW5nKCksXG5cdFx0XHRkZXRhaWxzOiB7XG5cdFx0XHRcdHByb2Nlc3NlZEZpbGVzOiB0aGlzLnByb2dyZXNzLnByb2Nlc3NlZEZpbGVzLFxuXHRcdFx0XHR0b3RhbEZpbGVzOiB0aGlzLnByb2dyZXNzLnRvdGFsRmlsZXNcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgZXN0aW1hdGVkIHRpbWUgcmVtYWluaW5nIGJhc2VkIG9uIHByb2dyZXNzLlxuXHQgKi9cblx0cHJpdmF0ZSBjYWxjdWxhdGVFc3RpbWF0ZWRUaW1lUmVtYWluaW5nKCk6IG51bWJlciB7XG5cdFx0Y29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSB0aGlzLnByb2dyZXNzLnN0YXJ0VGltZTtcblx0XHRjb25zdCBmaWxlc1Blck1zID0gdGhpcy5wcm9ncmVzcy5wcm9jZXNzZWRGaWxlcyAvIGVsYXBzZWQ7XG5cdFx0Y29uc3QgcmVtYWluaW5nRmlsZXMgPSB0aGlzLnByb2dyZXNzLnRvdGFsRmlsZXMgLSB0aGlzLnByb2dyZXNzLnByb2Nlc3NlZEZpbGVzO1xuXHRcdHJldHVybiBmaWxlc1Blck1zID4gMCA/IHJlbWFpbmluZ0ZpbGVzIC8gZmlsZXNQZXJNcyA6IDA7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHN5bmMgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9ucy5cblx0ICovXG5cdHByaXZhdGUgdXBkYXRlUHJvZ3Jlc3NOb3RpZmljYXRpb25CYXRjaCgpOiB2b2lkIHtcblx0XHR0aGlzLnVwZGF0ZVByb2dyZXNzTm90aWZpY2F0aW9uKCk7XG5cdH1cblxuXHQvKipcblx0ICogU3RvcCB0aGUgaW5pdGlhbCBzeW5jIHByb2Nlc3MuXG5cdCAqL1xuXHRzdG9wKCk6IHZvaWQge1xuXHRcdHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG5cdFx0aWYgKHRoaXMucHJvY2Vzc2luZ1RpbWVvdXQpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnByb2Nlc3NpbmdUaW1lb3V0KTtcblx0XHRcdHRoaXMucHJvY2Vzc2luZ1RpbWVvdXQgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgY3VycmVudCBzeW5jIHByb2dyZXNzLlxuXHQgKi9cblx0Z2V0UHJvZ3Jlc3MoKTogU3luY1Byb2dyZXNzIHtcblx0XHRyZXR1cm4geyAuLi50aGlzLnByb2dyZXNzIH07XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHN5bmMgb3B0aW9ucy5cblx0ICovXG5cdHVwZGF0ZU9wdGlvbnMob3B0aW9uczogUGFydGlhbDxJbml0aWFsU3luY09wdGlvbnM+KTogdm9pZCB7XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXHR9XG59XG4iLCAiLy8gc3JjL3NlcnZpY2VzL1N0YXR1c01hbmFnZXIudHNcbmltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcblxuZXhwb3J0IGVudW0gUGx1Z2luU3RhdHVzIHtcblx0SU5JVElBTElaSU5HID0gJ2luaXRpYWxpemluZycsXG5cdFdBSVRJTkdfRk9SX1NZTkMgPSAnd2FpdGluZ19zeW5jJyxcblx0Q0hFQ0tJTkdfRklMRSA9ICdjaGVja2luZ19maWxlJyxcblx0UkVBRFkgPSAncmVhZHknLFxuXHRFUlJPUiA9ICdlcnJvcicsXG5cdFFVRVVJTkcgPSAncXVldWluZycsIC8vIFdoZW4gdGFza3MgYXJlIGJlaW5nIHF1ZXVlZCBidXQgbm90IHByb2Nlc3NlZFxuXHRQUk9DRVNTSU5HX1FVRVVFID0gJ3Byb2Nlc3NpbmdfcXVldWUnIC8vIFdoZW4gd29ya2luZyB0aHJvdWdoIHF1ZXVlZCB0YXNrc1xufVxuXG5pbnRlcmZhY2UgU3RhdHVzRGV0YWlscyB7XG5cdG1lc3NhZ2U6IHN0cmluZztcblx0dGltZXN0YW1wOiBudW1iZXI7XG5cdGVycm9yPzogRXJyb3I7XG5cdHByb2dyZXNzPzogbnVtYmVyO1xuXHRxdWV1ZVNpemU/OiBudW1iZXI7XG5cdHBlbmRpbmdDaGFuZ2VzPzogbnVtYmVyO1xuXHQvLyBOZXcgY29ubmVjdGl2aXR5IHN0YXR1cyBpbmRpY2F0b3IgZm9yIGRldGFpbGVkIGZlZWRiYWNrXG5cdGNvbm5lY3Rpdml0eVN0YXR1cz86ICdvbmxpbmUnIHwgJ29mZmxpbmUnIHwgJ3Vua25vd24nO1xuXHQvLyBMYXN0IHRpbWUgYSBzdWNjZXNzZnVsIGRhdGFiYXNlIGNoZWNrIG9jY3VycmVkXG5cdGxhc3REYXRhYmFzZUNoZWNrPzogbnVtYmVyO1xufVxuXG50eXBlIFN0YXR1c0NoYW5nZUNhbGxiYWNrID0gKHN0YXR1czogUGx1Z2luU3RhdHVzLCBkZXRhaWxzOiBTdGF0dXNEZXRhaWxzKSA9PiB2b2lkO1xuXG5leHBvcnQgY2xhc3MgU3RhdHVzTWFuYWdlciB7XG5cdHByaXZhdGUgY3VycmVudFN0YXR1czogUGx1Z2luU3RhdHVzO1xuXHRwcml2YXRlIHN0YXR1c0RldGFpbHM6IFN0YXR1c0RldGFpbHM7XG5cdHByaXZhdGUgc3RhdHVzQmFySXRlbTogSFRNTEVsZW1lbnQ7XG5cdHByaXZhdGUgc3Vic2NyaWJlcnM6IFNldDxTdGF0dXNDaGFuZ2VDYWxsYmFjaz47XG5cblx0Y29uc3RydWN0b3Ioc3RhdHVzQmFySXRlbTogSFRNTEVsZW1lbnQpIHtcblx0XHR0aGlzLnN0YXR1c0Jhckl0ZW0gPSBzdGF0dXNCYXJJdGVtO1xuXHRcdHRoaXMuY3VycmVudFN0YXR1cyA9IFBsdWdpblN0YXR1cy5JTklUSUFMSVpJTkc7XG5cdFx0dGhpcy5zdGF0dXNEZXRhaWxzID0ge1xuXHRcdFx0bWVzc2FnZTogJ0luaXRpYWxpemluZyBwbHVnaW4uLi4nLFxuXHRcdFx0dGltZXN0YW1wOiBEYXRlLm5vdygpLFxuXHRcdFx0Y29ubmVjdGl2aXR5U3RhdHVzOiAndW5rbm93bidcblx0XHR9O1xuXHRcdHRoaXMuc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG5cdFx0dGhpcy51cGRhdGVTdGF0dXNCYXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGN1cnJlbnQgc3RhdHVzIHdpdGggbmV3IGRldGFpbHMuXG5cdCAqL1xuXHRwdWJsaWMgc2V0U3RhdHVzKHN0YXR1czogUGx1Z2luU3RhdHVzLCBkZXRhaWxzOiBQYXJ0aWFsPFN0YXR1c0RldGFpbHM+ID0ge30pOiB2b2lkIHtcblx0XHRjb25zdCBvbGRTdGF0dXMgPSB0aGlzLmN1cnJlbnRTdGF0dXM7XG5cdFx0dGhpcy5jdXJyZW50U3RhdHVzID0gc3RhdHVzO1xuXHRcdHRoaXMuc3RhdHVzRGV0YWlscyA9IHtcblx0XHRcdC4uLnRoaXMuc3RhdHVzRGV0YWlscyxcblx0XHRcdC4uLmRldGFpbHMsXG5cdFx0XHR0aW1lc3RhbXA6IERhdGUubm93KClcblx0XHR9O1xuXHRcdC8vIFVwZGF0ZSBVSVxuXHRcdHRoaXMudXBkYXRlU3RhdHVzQmFyKCk7XG5cdFx0Ly8gTm90aWZ5IHN1YnNjcmliZXJzIGlmIHN0YXR1cyBjaGFuZ2VkXG5cdFx0aWYgKG9sZFN0YXR1cyAhPT0gc3RhdHVzKSB7XG5cdFx0XHR0aGlzLm5vdGlmeVN1YnNjcmliZXJzKCk7XG5cdFx0fVxuXHRcdC8vIERpc3BsYXkgZXJyb3Igbm90aWNlIGlmIG5lZWRlZFxuXHRcdGlmIChzdGF0dXMgPT09IFBsdWdpblN0YXR1cy5FUlJPUiAmJiBkZXRhaWxzLm1lc3NhZ2UpIHtcblx0XHRcdG5ldyBOb3RpY2UoYE1pbmQgTWF0cml4OiAke2RldGFpbHMubWVzc2FnZX1gKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBjdXJyZW50IHN0YXR1cyBhbmQgZGV0YWlscy5cblx0ICovXG5cdHB1YmxpYyBnZXRTdGF0dXMoKTogeyBzdGF0dXM6IFBsdWdpblN0YXR1czsgZGV0YWlsczogU3RhdHVzRGV0YWlscyB9IHtcblx0XHRyZXR1cm4geyBzdGF0dXM6IHRoaXMuY3VycmVudFN0YXR1cywgZGV0YWlsczogeyAuLi50aGlzLnN0YXR1c0RldGFpbHMgfSB9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFN1YnNjcmliZSB0byBzdGF0dXMgY2hhbmdlcy5cblx0ICovXG5cdHB1YmxpYyBzdWJzY3JpYmUoY2FsbGJhY2s6IFN0YXR1c0NoYW5nZUNhbGxiYWNrKTogKCkgPT4gdm9pZCB7XG5cdFx0dGhpcy5zdWJzY3JpYmVycy5hZGQoY2FsbGJhY2spO1xuXHRcdC8vIFJldHVybiB1bnN1YnNjcmliZSBmdW5jdGlvblxuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHR0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIHN0YXR1cyBiYXIgVUkuXG5cdCAqL1xuXHRwcml2YXRlIHVwZGF0ZVN0YXR1c0JhcigpOiB2b2lkIHtcblx0XHQvLyBDbGVhciBleGlzdGluZyBjb250ZW50XG5cdFx0dGhpcy5zdGF0dXNCYXJJdGVtLmlubmVySFRNTCA9ICcnO1xuXHRcdC8vIENyZWF0ZSBhbmQgYXBwZW5kIHN0YXR1cyBpY29uXG5cdFx0Y29uc3Qgc3RhdHVzSWNvbiA9IHRoaXMuY3JlYXRlU3RhdHVzSWNvbigpO1xuXHRcdHRoaXMuc3RhdHVzQmFySXRlbS5hcHBlbmRDaGlsZChzdGF0dXNJY29uKTtcblx0XHQvLyBDcmVhdGUgYW5kIGFwcGVuZCBzdGF0dXMgZGV0YWlscyB0ZXh0XG5cdFx0Y29uc3QgZGV0YWlsc1RleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cdFx0ZGV0YWlsc1RleHQuYWRkQ2xhc3MoJ21pbmQtbWF0cml4LXN0YXR1cy1kZXRhaWxzJyk7XG5cdFx0ZGV0YWlsc1RleHQudGV4dENvbnRlbnQgPSB0aGlzLnN0YXR1c0RldGFpbHMubWVzc2FnZTtcblx0XHR0aGlzLnN0YXR1c0Jhckl0ZW0uYXBwZW5kQ2hpbGQoZGV0YWlsc1RleHQpO1xuXG5cdFx0Ly8gQ29tcG9zZSB0b29sdGlwIHdpdGggY29ubmVjdGl2aXR5IGFuZCBkYXRhYmFzZSBpbmZvIGlmIGF2YWlsYWJsZVxuXHRcdGxldCB0b29sdGlwID0gdGhpcy5zdGF0dXNEZXRhaWxzLm1lc3NhZ2U7XG5cdFx0aWYgKHRoaXMuc3RhdHVzRGV0YWlscy5jb25uZWN0aXZpdHlTdGF0dXMpIHtcblx0XHRcdHRvb2x0aXAgKz0gYCB8IENvbm5lY3Rpdml0eTogJHt0aGlzLnN0YXR1c0RldGFpbHMuY29ubmVjdGl2aXR5U3RhdHVzfWA7XG5cdFx0fVxuXHRcdGlmICh0aGlzLnN0YXR1c0RldGFpbHMubGFzdERhdGFiYXNlQ2hlY2spIHtcblx0XHRcdHRvb2x0aXAgKz0gYCB8IExhc3QgREIgQ2hlY2s6ICR7bmV3IERhdGUodGhpcy5zdGF0dXNEZXRhaWxzLmxhc3REYXRhYmFzZUNoZWNrKS50b0xvY2FsZVRpbWVTdHJpbmcoKX1gO1xuXHRcdH1cblx0XHR0aGlzLnN0YXR1c0Jhckl0ZW0uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdG9vbHRpcCk7XG5cdFx0dGhpcy5zdGF0dXNCYXJJdGVtLm9uY2xpY2sgPSAoKSA9PiB7XG5cdFx0XHRuZXcgTm90aWNlKHRvb2x0aXApO1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIHN0YXR1cyBpY29uIGVsZW1lbnQgYmFzZWQgb24gY3VycmVudCBzdGF0dXMuXG5cdCAqL1xuXHRwcml2YXRlIGNyZWF0ZVN0YXR1c0ljb24oKTogSFRNTEVsZW1lbnQge1xuXHRcdGNvbnN0IGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cdFx0aWNvbi5hZGRDbGFzcygnbWluZC1tYXRyaXgtc3RhdHVzLWljb24nKTtcblx0XHRzd2l0Y2ggKHRoaXMuY3VycmVudFN0YXR1cykge1xuXHRcdFx0Y2FzZSBQbHVnaW5TdGF0dXMuUkVBRFk6XG5cdFx0XHRcdGljb24uYWRkQ2xhc3MoJ2lzLXJlYWR5Jyk7XG5cdFx0XHRcdGljb24uaW5uZXJIVE1MID0gJ1x1MjVDRic7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBQbHVnaW5TdGF0dXMuRVJST1I6XG5cdFx0XHRcdGljb24uYWRkQ2xhc3MoJ2lzLWVycm9yJyk7XG5cdFx0XHRcdGljb24uaW5uZXJIVE1MID0gJ1x1MjZBMCc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBQbHVnaW5TdGF0dXMuV0FJVElOR19GT1JfU1lOQzpcblx0XHRcdGNhc2UgUGx1Z2luU3RhdHVzLkNIRUNLSU5HX0ZJTEU6XG5cdFx0XHRcdGljb24uYWRkQ2xhc3MoJ2lzLXdvcmtpbmcnKTtcblx0XHRcdFx0aWNvbi5pbm5lckhUTUwgPSAnXHUyMUJCJztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRpY29uLmFkZENsYXNzKCdpcy1pbml0aWFsaXppbmcnKTtcblx0XHRcdFx0aWNvbi5pbm5lckhUTUwgPSAnXHUyNUNCJztcblx0XHR9XG5cdFx0cmV0dXJuIGljb247XG5cdH1cblxuXHQvKipcblx0ICogTm90aWZ5IGFsbCBzdWJzY3JpYmVycyBvZiBhIHN0YXR1cyBjaGFuZ2UuXG5cdCAqL1xuXHRwcml2YXRlIG5vdGlmeVN1YnNjcmliZXJzKCk6IHZvaWQge1xuXHRcdHRoaXMuc3Vic2NyaWJlcnMuZm9yRWFjaChjYWxsYmFjayA9PiB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjYWxsYmFjayh0aGlzLmN1cnJlbnRTdGF0dXMsIHRoaXMuc3RhdHVzRGV0YWlscyk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBpbiBzdGF0dXMgY2hhbmdlIHN1YnNjcmliZXI6JywgZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoZSBwbHVnaW4gaXMgY3VycmVudGx5IGluIGEgc3BlY2lmaWMgc3RhdHVzLlxuXHQgKi9cblx0cHVibGljIGlzSW5TdGF0dXMoc3RhdHVzOiBQbHVnaW5TdGF0dXMpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5jdXJyZW50U3RhdHVzID09PSBzdGF0dXM7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHByb2dyZXNzIGZvciB0aGUgY3VycmVudCB0YXNrLlxuXHQgKi9cblx0cHVibGljIHVwZGF0ZVByb2dyZXNzKHByb2dyZXNzOiBudW1iZXIpOiB2b2lkIHtcblx0XHR0aGlzLnN0YXR1c0RldGFpbHMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcblx0XHR0aGlzLnVwZGF0ZVN0YXR1c0JhcigpO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBUQWJzdHJhY3RGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgU3RhdHVzTWFuYWdlciwgUGx1Z2luU3RhdHVzIH0gZnJvbSAnLi9TdGF0dXNNYW5hZ2VyJztcblxuZXhwb3J0IGNsYXNzIFN5bmNEZXRlY3Rpb25NYW5hZ2VyIHtcbiAgICBwcml2YXRlIGxhc3RTeW5jQWN0aXZpdHk6IG51bWJlciA9IDA7XG4gICAgcHJpdmF0ZSBzeW5jQ2hlY2tJbnRlcnZhbDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcbiAgICBwcml2YXRlIHF1aWV0UGVyaW9kUmVhY2hlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgaXNXYWl0aW5nRm9yUXVpZXRQZXJpb2Q6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IFFVSUVUX1BFUklPRF9NUyA9IDUwMDA7IC8vIDUgc2Vjb25kc1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgcGx1Z2luOiBQbHVnaW4sXG4gICAgICAgIHByaXZhdGUgc3RhdHVzTWFuYWdlcjogU3RhdHVzTWFuYWdlcixcbiAgICAgICAgcHJpdmF0ZSBvblF1aWV0UGVyaW9kUmVhY2hlZDogKCkgPT4gdm9pZFxuICAgICkge31cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IG1vbml0b3JpbmcgZm9yIHN5bmMgYWN0aXZpdHlcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhcnRNb25pdG9yaW5nKCk6IHZvaWQge1xuICAgICAgICAvLyBUcmFjayBmaWxlIGNoYW5nZXMgYXMgcG90ZW50aWFsIHN5bmMgYWN0aXZpdHlcbiAgICAgICAgdGhpcy5wbHVnaW4ucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLmFwcC52YXVsdC5vbignbW9kaWZ5JywgKCkgPT4gdGhpcy5yZWNvcmRTeW5jQWN0aXZpdHkoKSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wbHVnaW4ucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLmFwcC52YXVsdC5vbignY3JlYXRlJywgKCkgPT4gdGhpcy5yZWNvcmRTeW5jQWN0aXZpdHkoKSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wbHVnaW4ucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLmFwcC52YXVsdC5vbignZGVsZXRlJywgKCkgPT4gdGhpcy5yZWNvcmRTeW5jQWN0aXZpdHkoKSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTdGFydCBjaGVja2luZyBmb3IgcXVpZXQgcGVyaW9kXG4gICAgICAgIHRoaXMuc3RhcnRRdWlldFBlcmlvZENoZWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjb3JkIHN5bmMgYWN0aXZpdHkgYW5kIHJlc2V0IHF1aWV0IHBlcmlvZFxuICAgICAqL1xuICAgIHByaXZhdGUgcmVjb3JkU3luY0FjdGl2aXR5KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmxhc3RTeW5jQWN0aXZpdHkgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnF1aWV0UGVyaW9kUmVhY2hlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLmlzV2FpdGluZ0ZvclF1aWV0UGVyaW9kKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c01hbmFnZXIuc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5XQUlUSU5HX0ZPUl9TWU5DLCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1dhaXRpbmcgZm9yIE9ic2lkaWFuIHN5bmMgdG8gc2V0dGxlLi4uJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBjaGVja2luZyBmb3IgcXVpZXQgcGVyaW9kXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGFydFF1aWV0UGVyaW9kQ2hlY2soKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnN5bmNDaGVja0ludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc1dhaXRpbmdGb3JRdWlldFBlcmlvZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lU2luY2VMYXN0U3luYyA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RTeW5jQWN0aXZpdHk7XG5cbiAgICAgICAgICAgIGlmICh0aW1lU2luY2VMYXN0U3luYyA+PSB0aGlzLlFVSUVUX1BFUklPRF9NUyAmJiAhdGhpcy5xdWlldFBlcmlvZFJlYWNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1aWV0UGVyaW9kUmVhY2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1dhaXRpbmdGb3JRdWlldFBlcmlvZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnN5bmNDaGVja0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5vblF1aWV0UGVyaW9kUmVhY2hlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAxMDAwKTsgLy8gQ2hlY2sgZXZlcnkgc2Vjb25kXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcCBtb25pdG9yaW5nIGZvciBzeW5jIGFjdGl2aXR5XG4gICAgICovXG4gICAgcHVibGljIHN0b3BNb25pdG9yaW5nKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnN5bmNDaGVja0ludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNXYWl0aW5nRm9yUXVpZXRQZXJpb2QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjdXJyZW50bHkgd2FpdGluZyBmb3IgcXVpZXQgcGVyaW9kXG4gICAgICovXG4gICAgcHVibGljIGlzV2FpdGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNXYWl0aW5nRm9yUXVpZXRQZXJpb2Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRpbWUgc2luY2UgbGFzdCBzeW5jIGFjdGl2aXR5XG4gICAgICovXG4gICAgcHVibGljIGdldFRpbWVTaW5jZUxhc3RTeW5jKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5sYXN0U3luY0FjdGl2aXR5O1xuICAgIH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtB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SUFDRCxDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDZixJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixVQUFVLFlBQVk7QUE5eEJ6QixZQUFBQSxLQUFBO0FBK3hCSSxTQUFBQSxNQUFBLEtBQUssZ0JBQUwsZ0JBQUFBLElBQWtCO0FBQ2xCLGdCQUFNLFVBQUssZ0JBQUwsbUJBQWtCO0FBQ3hCLFlBQUksS0FBSyxTQUFTLHFCQUFxQjtBQUN0QyxjQUFJLHlCQUFPLDBCQUEwQjtBQUFBLFFBQ3RDO0FBQUEsTUFDRDtBQUFBLElBQ0QsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2YsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxZQUFZO0FBQ3JCLFlBQUksS0FBSyxvQkFBb0I7QUFDNUIsZ0JBQU0sS0FBSyxtQkFBbUIsVUFBVTtBQUFBLFFBQ3pDLE9BQU87QUFDTixjQUFJLHlCQUFPLHNDQUFzQztBQUFBLFFBQ2xEO0FBQUEsTUFDRDtBQUFBLElBQ0QsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2YsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxNQUFNO0FBdHpCbkIsWUFBQUE7QUF1ekJJLFNBQUFBLE1BQUEsS0FBSyx1QkFBTCxnQkFBQUEsSUFBeUI7QUFDekIsWUFBSSx5QkFBTyxzQkFBc0I7QUFBQSxNQUNsQztBQUFBLElBQ0QsQ0FBQztBQUFBLEVBQ0Y7QUFDRDsiLAogICJuYW1lcyI6IFsiSGVhZGVycyIsICJSZXF1ZXN0IiwgIlJlc3BvbnNlIiwgImZldGNoIiwgIlBvc3RncmVzdEVycm9yIiwgIlBvc3RncmVzdEJ1aWxkZXIiLCAicmVzIiwgIl9hIiwgIlBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIiLCAiX2EiLCAiUG9zdGdyZXN0RmlsdGVyQnVpbGRlciIsICJQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIiLCAiZmV0Y2giLCAiaGVhZCIsICJQb3N0Z3Jlc3RDbGllbnQiLCAiZmV0Y2giLCAiaGVhZCIsICJnZXQiLCAibW9kdWxlIiwgImltcG9ydF9vYnNpZGlhbiIsICJmZXRjaCIsICJGdW5jdGlvblJlZ2lvbiIsICJfYSIsICJpbmRleCIsICJTT0NLRVRfU1RBVEVTIiwgIkNIQU5ORUxfU1RBVEVTIiwgIkNIQU5ORUxfRVZFTlRTIiwgIlRSQU5TUE9SVFMiLCAiQ09OTkVDVElPTl9TVEFURSIsICJQb3N0Z3Jlc1R5cGVzIiwgIl9hIiwgIl9hIiwgIlJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMiLCAiX2EiLCAiUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQiLCAiUkVBTFRJTUVfTElTVEVOX1RZUEVTIiwgIlJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMiLCAiX2EiLCAicHVzaCIsICJfYiIsICJ0eXBlIiwgIm5vb3AiLCAiZmV0Y2giLCAiX2EiLCAia2luZCIsICJyZXNvbHZlRmV0Y2giLCAiZmV0Y2giLCAiX19hd2FpdGVyIiwgIl9fYXdhaXRlciIsICJmZXRjaCIsICJyZXNvbHZlRmV0Y2giLCAidmVyc2lvbiIsICJERUZBVUxUX0hFQURFUlMiLCAidmVyc2lvbiIsICJmZXRjaCIsICJERUZBVUxUX0hFQURFUlMiLCAicmVzb2x2ZUZldGNoIiwgImZldGNoIiwgInZlcnNpb24iLCAiREVGQVVMVF9IRUFERVJTIiwgInZlcnNpb24iLCAicmVzb2x2ZUZldGNoIiwgIkhlYWRlcnMiLCAiZmV0Y2giLCAiX19hd2FpdGVyIiwgIl9hIiwgImRlZmF1bHRzIiwgIkRFRkFVTFRfREJfT1BUSU9OUyIsICJERUZBVUxUX0FVVEhfT1BUSU9OUyIsICJERUZBVUxUX1JFQUxUSU1FX09QVElPTlMiLCAiREVGQVVMVF9HTE9CQUxfT1BUSU9OUyIsICJfX2F3YWl0ZXIiLCAidmVyc2lvbiIsICJERUZBVUxUX0hFQURFUlMiLCAidmVyc2lvbiIsICJyZXNvbHZlRmV0Y2giLCAiZmV0Y2giLCAiX2EiLCAic3RyIiwgIl9nZXRFcnJvck1lc3NhZ2UiLCAiaGFuZGxlRXJyb3IiLCAiX2EiLCAiX2dldFJlcXVlc3RQYXJhbXMiLCAiX2hhbmRsZVJlcXVlc3QiLCAiZmV0Y2giLCAicmVzb2x2ZUZldGNoIiwgIl9fcmVzdCIsICJfYSIsICJERUZBVUxUX0hFQURFUlMiLCAicmVzb2x2ZUZldGNoIiwgIl9hIiwgInZlcnNpb24iLCAicmVzdWx0IiwgImV4cGlyZXNBdCIsICJlcnJvciIsICJkYXRhIiwgIl9hIiwgImRlYnVnIiwgImZldGNoIiwgIl9hIiwgImxpbWl0IiwgInN0ciIsICJpc19hcnJheSIsICJmZXRjaCIsICJSZXF1ZXN0IiwgIlJlc3BvbnNlIiwgIkhlYWRlcnMiLCAiRm9ybURhdGEiLCAiQmxvYiIsICJGaWxlIiwgIlJlYWRhYmxlU3RyZWFtIiwgIl9hIiwgInNlbGYiLCAiUmVhZGFibGVTdHJlYW0iLCAiX2EiLCAic3RyIiwgImluZGV4IiwgIl9hIiwgIkZpbGUiLCAiRm9ybURhdGEiLCAiZmV0Y2giLCAib3B0cyIsICJQYWdlIiwgIl9hIiwgInJldHJ5TWVzc2FnZSIsICJzbGVlcCIsICJfYSIsICJfYSIsICJtb2RpZmllZEFyZyIsICJfYSIsICJfYSIsICJfYSIsICJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IiwgIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCAiaW5kZXgiLCAiX2EiLCAiaW5wdXRUb29sIiwgIl9hIiwgIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCAiY29udGVudCIsICJuYW1lIiwgIl9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsTWVzc2FnZSIsICJfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbEZ1bmN0aW9uQ2FsbCIsICJfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbEZ1bmN0aW9uQ2FsbFJlc3VsdCIsICJfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9jYWxjdWxhdGVUb3RhbFVzYWdlIiwgIl9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX3ZhbGlkYXRlUGFyYW1zIiwgIl9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX3N0cmluZ2lmeUZ1bmN0aW9uQ2FsbFJlc3VsdCIsICJpbmRleCIsICJlc2NhcGUiLCAiZSIsICJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IiwgIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCAiX2EiLCAiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2JlZ2luUmVxdWVzdCIsICJfQ2hhdENvbXBsZXRpb25TdHJlYW1fZ2V0Q2hvaWNlRXZlbnRTdGF0ZSIsICJfQ2hhdENvbXBsZXRpb25TdHJlYW1fYWRkQ2h1bmsiLCAiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRUb29sQ2FsbERvbmVFdmVudCIsICJfQ2hhdENvbXBsZXRpb25TdHJlYW1fZW1pdENvbnRlbnREb25lRXZlbnRzIiwgIl9DaGF0Q29tcGxldGlvblN0cmVhbV9lbmRSZXF1ZXN0IiwgIl9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQiLCAiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2FjY3VtdWxhdGVDaGF0Q29tcGxldGlvbiIsICJpbmRleCIsICJjb250ZW50IiwgInJlZnVzYWwiLCAicmVzdCIsICJfYiIsICJfYyIsICJfZCIsICJjaHVuayIsICJpZCIsICJDb21wbGV0aW9ucyIsICJDaGF0IiwgIkNvbXBsZXRpb25zIiwgImNodW5rIiwgIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCAiX2EiLCAiaW5kZXgiLCAiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsICJfQXNzaXN0YW50U3RyZWFtX2VuZFJlcXVlc3QiLCAiX0Fzc2lzdGFudFN0cmVhbV9oYW5kbGVNZXNzYWdlIiwgIl9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlUnVuU3RlcCIsICJfQXNzaXN0YW50U3RyZWFtX2hhbmRsZUV2ZW50IiwgIl9Bc3Npc3RhbnRTdHJlYW1fYWNjdW11bGF0ZVJ1blN0ZXAiLCAiX0Fzc2lzdGFudFN0cmVhbV9hY2N1bXVsYXRlTWVzc2FnZSIsICJfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVDb250ZW50IiwgIl9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlUnVuIiwgIl9hIiwgInNsZWVwIiwgIl9hIiwgInNsZWVwIiwgInNsZWVwIiwgIl9hIiwgIkNoYXQiLCAiQ29tcGxldGlvbnMiLCAiX2EiLCAiRmlsZXMiLCAic2xlZXAiLCAiX2EiLCAiQ29tcGxldGlvbnMiLCAiRmlsZXMiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiX2EiLCAiaW5kZXgiLCAiX2EiLCAiX2EiLCAiaW5kZXgiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJTeW5jRXJyb3JUeXBlIiwgIl9hIiwgIl9hIiwgInN0ciIsICJpbXBvcnRfb2JzaWRpYW4iLCAiX2EiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJ2YWx1ZSIsICJzeXN0ZW1GaWxlcyIsICJtb2RhbCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgIl9hIl0KfQo=
