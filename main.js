/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the GitHub repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@supabase/node-fetch/browser.js
var browser_exports = {};
__export(browser_exports, {
  Headers: () => Headers2,
  Request: () => Request2,
  Response: () => Response2,
  default: () => browser_default,
  fetch: () => fetch2
});
var getGlobal, globalObject, fetch2, browser_default, Headers2, Request2, Response2;
var init_browser = __esm({
  "node_modules/@supabase/node-fetch/browser.js"() {
    "use strict";
    getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    globalObject = getGlobal();
    fetch2 = globalObject.fetch;
    browser_default = globalObject.fetch.bind(globalObject);
    Headers2 = globalObject.Headers;
    Request2 = globalObject.Request;
    Response2 = globalObject.Response;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js
var require_PostgrestError = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestError2 = class extends Error {
      constructor(context) {
        super(context.message);
        this.name = "PostgrestError";
        this.details = context.details;
        this.hint = context.hint;
        this.code = context.code;
      }
    };
    exports.default = PostgrestError2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js
var require_PostgrestBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var node_fetch_1 = __importDefault((init_browser(), __toCommonJS(browser_exports)));
    var PostgrestError_1 = __importDefault(require_PostgrestError());
    var PostgrestBuilder2 = class {
      constructor(builder) {
        this.shouldThrowOnError = false;
        this.method = builder.method;
        this.url = builder.url;
        this.headers = builder.headers;
        this.schema = builder.schema;
        this.body = builder.body;
        this.shouldThrowOnError = builder.shouldThrowOnError;
        this.signal = builder.signal;
        this.isMaybeSingle = builder.isMaybeSingle;
        if (builder.fetch) {
          this.fetch = builder.fetch;
        } else if (typeof fetch === "undefined") {
          this.fetch = node_fetch_1.default;
        } else {
          this.fetch = fetch;
        }
      }
      /**
       * If there's an error with the query, throwOnError will reject the promise by
       * throwing the error instead of returning it as part of a successful response.
       *
       * {@link https://github.com/supabase/supabase-js/issues/92}
       */
      throwOnError() {
        this.shouldThrowOnError = true;
        return this;
      }
      /**
       * Set an HTTP header for the request.
       */
      setHeader(name, value) {
        this.headers = Object.assign({}, this.headers);
        this.headers[name] = value;
        return this;
      }
      then(onfulfilled, onrejected) {
        if (this.schema === void 0) {
        } else if (["GET", "HEAD"].includes(this.method)) {
          this.headers["Accept-Profile"] = this.schema;
        } else {
          this.headers["Content-Profile"] = this.schema;
        }
        if (this.method !== "GET" && this.method !== "HEAD") {
          this.headers["Content-Type"] = "application/json";
        }
        const _fetch = this.fetch;
        let res = _fetch(this.url.toString(), {
          method: this.method,
          headers: this.headers,
          body: JSON.stringify(this.body),
          signal: this.signal
        }).then(async (res2) => {
          var _a2, _b, _c;
          let error = null;
          let data = null;
          let count = null;
          let status = res2.status;
          let statusText = res2.statusText;
          if (res2.ok) {
            if (this.method !== "HEAD") {
              const body = await res2.text();
              if (body === "") {
              } else if (this.headers["Accept"] === "text/csv") {
                data = body;
              } else if (this.headers["Accept"] && this.headers["Accept"].includes("application/vnd.pgrst.plan+text")) {
                data = body;
              } else {
                data = JSON.parse(body);
              }
            }
            const countHeader = (_a2 = this.headers["Prefer"]) === null || _a2 === void 0 ? void 0 : _a2.match(/count=(exact|planned|estimated)/);
            const contentRange = (_b = res2.headers.get("content-range")) === null || _b === void 0 ? void 0 : _b.split("/");
            if (countHeader && contentRange && contentRange.length > 1) {
              count = parseInt(contentRange[1]);
            }
            if (this.isMaybeSingle && this.method === "GET" && Array.isArray(data)) {
              if (data.length > 1) {
                error = {
                  // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553
                  code: "PGRST116",
                  details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                  hint: null,
                  message: "JSON object requested, multiple (or no) rows returned"
                };
                data = null;
                count = null;
                status = 406;
                statusText = "Not Acceptable";
              } else if (data.length === 1) {
                data = data[0];
              } else {
                data = null;
              }
            }
          } else {
            const body = await res2.text();
            try {
              error = JSON.parse(body);
              if (Array.isArray(error) && res2.status === 404) {
                data = [];
                error = null;
                status = 200;
                statusText = "OK";
              }
            } catch (_d) {
              if (res2.status === 404 && body === "") {
                status = 204;
                statusText = "No Content";
              } else {
                error = {
                  message: body
                };
              }
            }
            if (error && this.isMaybeSingle && ((_c = error === null || error === void 0 ? void 0 : error.details) === null || _c === void 0 ? void 0 : _c.includes("0 rows"))) {
              error = null;
              status = 200;
              statusText = "OK";
            }
            if (error && this.shouldThrowOnError) {
              throw new PostgrestError_1.default(error);
            }
          }
          const postgrestResponse = {
            error,
            data,
            count,
            status,
            statusText
          };
          return postgrestResponse;
        });
        if (!this.shouldThrowOnError) {
          res = res.catch((fetchError) => {
            var _a2, _b, _c;
            return {
              error: {
                message: `${(_a2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _a2 !== void 0 ? _a2 : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,
                details: `${(_b = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _b !== void 0 ? _b : ""}`,
                hint: "",
                code: `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) !== null && _c !== void 0 ? _c : ""}`
              },
              data: null,
              count: null,
              status: 0,
              statusText: ""
            };
          });
        }
        return res.then(onfulfilled, onrejected);
      }
    };
    exports.default = PostgrestBuilder2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js
var require_PostgrestTransformBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestBuilder_1 = __importDefault(require_PostgrestBuilder());
    var PostgrestTransformBuilder2 = class extends PostgrestBuilder_1.default {
      /**
       * Perform a SELECT on the query result.
       *
       * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
       * return modified rows. By calling this method, modified rows are returned in
       * `data`.
       *
       * @param columns - The columns to retrieve, separated by commas
       */
      select(columns) {
        let quoted = false;
        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c) => {
          if (/\s/.test(c) && !quoted) {
            return "";
          }
          if (c === '"') {
            quoted = !quoted;
          }
          return c;
        }).join("");
        this.url.searchParams.set("select", cleanedColumns);
        if (this.headers["Prefer"]) {
          this.headers["Prefer"] += ",";
        }
        this.headers["Prefer"] += "return=representation";
        return this;
      }
      /**
       * Order the query result by `column`.
       *
       * You can call this method multiple times to order by multiple columns.
       *
       * You can order referenced tables, but it only affects the ordering of the
       * parent table if you use `!inner` in the query.
       *
       * @param column - The column to order by
       * @param options - Named parameters
       * @param options.ascending - If `true`, the result will be in ascending order
       * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
       * `null`s appear last.
       * @param options.referencedTable - Set this to order a referenced table by
       * its columns
       * @param options.foreignTable - Deprecated, use `options.referencedTable`
       * instead
       */
      order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {
        const key = referencedTable ? `${referencedTable}.order` : "order";
        const existingOrder = this.url.searchParams.get(key);
        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ""}${column}.${ascending ? "asc" : "desc"}${nullsFirst === void 0 ? "" : nullsFirst ? ".nullsfirst" : ".nullslast"}`);
        return this;
      }
      /**
       * Limit the query result by `count`.
       *
       * @param count - The maximum number of rows to return
       * @param options - Named parameters
       * @param options.referencedTable - Set this to limit rows of referenced
       * tables instead of the parent table
       * @param options.foreignTable - Deprecated, use `options.referencedTable`
       * instead
       */
      limit(count, { foreignTable, referencedTable = foreignTable } = {}) {
        const key = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
        this.url.searchParams.set(key, `${count}`);
        return this;
      }
      /**
       * Limit the query result by starting at an offset `from` and ending at the offset `to`.
       * Only records within this range are returned.
       * This respects the query order and if there is no order clause the range could behave unexpectedly.
       * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
       * and fourth rows of the query.
       *
       * @param from - The starting index from which to limit the result
       * @param to - The last index to which to limit the result
       * @param options - Named parameters
       * @param options.referencedTable - Set this to limit rows of referenced
       * tables instead of the parent table
       * @param options.foreignTable - Deprecated, use `options.referencedTable`
       * instead
       */
      range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {
        const keyOffset = typeof referencedTable === "undefined" ? "offset" : `${referencedTable}.offset`;
        const keyLimit = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
        this.url.searchParams.set(keyOffset, `${from}`);
        this.url.searchParams.set(keyLimit, `${to - from + 1}`);
        return this;
      }
      /**
       * Set the AbortSignal for the fetch request.
       *
       * @param signal - The AbortSignal to use for the fetch request
       */
      abortSignal(signal) {
        this.signal = signal;
        return this;
      }
      /**
       * Return `data` as a single object instead of an array of objects.
       *
       * Query result must be one row (e.g. using `.limit(1)`), otherwise this
       * returns an error.
       */
      single() {
        this.headers["Accept"] = "application/vnd.pgrst.object+json";
        return this;
      }
      /**
       * Return `data` as a single object instead of an array of objects.
       *
       * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
       * this returns an error.
       */
      maybeSingle() {
        if (this.method === "GET") {
          this.headers["Accept"] = "application/json";
        } else {
          this.headers["Accept"] = "application/vnd.pgrst.object+json";
        }
        this.isMaybeSingle = true;
        return this;
      }
      /**
       * Return `data` as a string in CSV format.
       */
      csv() {
        this.headers["Accept"] = "text/csv";
        return this;
      }
      /**
       * Return `data` as an object in [GeoJSON](https://geojson.org) format.
       */
      geojson() {
        this.headers["Accept"] = "application/geo+json";
        return this;
      }
      /**
       * Return `data` as the EXPLAIN plan for the query.
       *
       * You need to enable the
       * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
       * setting before using this method.
       *
       * @param options - Named parameters
       *
       * @param options.analyze - If `true`, the query will be executed and the
       * actual run time will be returned
       *
       * @param options.verbose - If `true`, the query identifier will be returned
       * and `data` will include the output columns of the query
       *
       * @param options.settings - If `true`, include information on configuration
       * parameters that affect query planning
       *
       * @param options.buffers - If `true`, include information on buffer usage
       *
       * @param options.wal - If `true`, include information on WAL record generation
       *
       * @param options.format - The format of the output, can be `"text"` (default)
       * or `"json"`
       */
      explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = "text" } = {}) {
        var _a2;
        const options = [
          analyze ? "analyze" : null,
          verbose ? "verbose" : null,
          settings ? "settings" : null,
          buffers ? "buffers" : null,
          wal ? "wal" : null
        ].filter(Boolean).join("|");
        const forMediatype = (_a2 = this.headers["Accept"]) !== null && _a2 !== void 0 ? _a2 : "application/json";
        this.headers["Accept"] = `application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`;
        if (format === "json")
          return this;
        else
          return this;
      }
      /**
       * Rollback the query.
       *
       * `data` will still be returned, but the query is not committed.
       */
      rollback() {
        var _a2;
        if (((_a2 = this.headers["Prefer"]) !== null && _a2 !== void 0 ? _a2 : "").trim().length > 0) {
          this.headers["Prefer"] += ",tx=rollback";
        } else {
          this.headers["Prefer"] = "tx=rollback";
        }
        return this;
      }
      /**
       * Override the type of the returned `data`.
       *
       * @typeParam NewResult - The new result type to override with
       */
      returns() {
        return this;
      }
    };
    exports.default = PostgrestTransformBuilder2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js
var require_PostgrestFilterBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestTransformBuilder_1 = __importDefault(require_PostgrestTransformBuilder());
    var PostgrestFilterBuilder2 = class extends PostgrestTransformBuilder_1.default {
      /**
       * Match only rows where `column` is equal to `value`.
       *
       * To check if the value of `column` is NULL, you should use `.is()` instead.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      eq(column, value) {
        this.url.searchParams.append(column, `eq.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is not equal to `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      neq(column, value) {
        this.url.searchParams.append(column, `neq.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is greater than `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      gt(column, value) {
        this.url.searchParams.append(column, `gt.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is greater than or equal to `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      gte(column, value) {
        this.url.searchParams.append(column, `gte.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is less than `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      lt(column, value) {
        this.url.searchParams.append(column, `lt.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is less than or equal to `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      lte(column, value) {
        this.url.searchParams.append(column, `lte.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` matches `pattern` case-sensitively.
       *
       * @param column - The column to filter on
       * @param pattern - The pattern to match with
       */
      like(column, pattern) {
        this.url.searchParams.append(column, `like.${pattern}`);
        return this;
      }
      /**
       * Match only rows where `column` matches all of `patterns` case-sensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      likeAllOf(column, patterns) {
        this.url.searchParams.append(column, `like(all).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` matches any of `patterns` case-sensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      likeAnyOf(column, patterns) {
        this.url.searchParams.append(column, `like(any).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` matches `pattern` case-insensitively.
       *
       * @param column - The column to filter on
       * @param pattern - The pattern to match with
       */
      ilike(column, pattern) {
        this.url.searchParams.append(column, `ilike.${pattern}`);
        return this;
      }
      /**
       * Match only rows where `column` matches all of `patterns` case-insensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      ilikeAllOf(column, patterns) {
        this.url.searchParams.append(column, `ilike(all).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` matches any of `patterns` case-insensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      ilikeAnyOf(column, patterns) {
        this.url.searchParams.append(column, `ilike(any).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` IS `value`.
       *
       * For non-boolean columns, this is only relevant for checking if the value of
       * `column` is NULL by setting `value` to `null`.
       *
       * For boolean columns, you can also set `value` to `true` or `false` and it
       * will behave the same way as `.eq()`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      is(column, value) {
        this.url.searchParams.append(column, `is.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is included in the `values` array.
       *
       * @param column - The column to filter on
       * @param values - The values array to filter with
       */
      in(column, values) {
        const cleanedValues = Array.from(new Set(values)).map((s) => {
          if (typeof s === "string" && new RegExp("[,()]").test(s))
            return `"${s}"`;
          else
            return `${s}`;
        }).join(",");
        this.url.searchParams.append(column, `in.(${cleanedValues})`);
        return this;
      }
      /**
       * Only relevant for jsonb, array, and range columns. Match only rows where
       * `column` contains every element appearing in `value`.
       *
       * @param column - The jsonb, array, or range column to filter on
       * @param value - The jsonb, array, or range value to filter with
       */
      contains(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(column, `cs.${value}`);
        } else if (Array.isArray(value)) {
          this.url.searchParams.append(column, `cs.{${value.join(",")}}`);
        } else {
          this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);
        }
        return this;
      }
      /**
       * Only relevant for jsonb, array, and range columns. Match only rows where
       * every element appearing in `column` is contained by `value`.
       *
       * @param column - The jsonb, array, or range column to filter on
       * @param value - The jsonb, array, or range value to filter with
       */
      containedBy(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(column, `cd.${value}`);
        } else if (Array.isArray(value)) {
          this.url.searchParams.append(column, `cd.{${value.join(",")}}`);
        } else {
          this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);
        }
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is greater than any element in `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeGt(column, range) {
        this.url.searchParams.append(column, `sr.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is either contained in `range` or greater than any element in
       * `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeGte(column, range) {
        this.url.searchParams.append(column, `nxl.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is less than any element in `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeLt(column, range) {
        this.url.searchParams.append(column, `sl.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is either contained in `range` or less than any element in
       * `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeLte(column, range) {
        this.url.searchParams.append(column, `nxr.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where `column` is
       * mutually exclusive to `range` and there can be no element between the two
       * ranges.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeAdjacent(column, range) {
        this.url.searchParams.append(column, `adj.${range}`);
        return this;
      }
      /**
       * Only relevant for array and range columns. Match only rows where
       * `column` and `value` have an element in common.
       *
       * @param column - The array or range column to filter on
       * @param value - The array or range value to filter with
       */
      overlaps(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(column, `ov.${value}`);
        } else {
          this.url.searchParams.append(column, `ov.{${value.join(",")}}`);
        }
        return this;
      }
      /**
       * Only relevant for text and tsvector columns. Match only rows where
       * `column` matches the query string in `query`.
       *
       * @param column - The text or tsvector column to filter on
       * @param query - The query text to match with
       * @param options - Named parameters
       * @param options.config - The text search configuration to use
       * @param options.type - Change how the `query` text is interpreted
       */
      textSearch(column, query, { config, type } = {}) {
        let typePart = "";
        if (type === "plain") {
          typePart = "pl";
        } else if (type === "phrase") {
          typePart = "ph";
        } else if (type === "websearch") {
          typePart = "w";
        }
        const configPart = config === void 0 ? "" : `(${config})`;
        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);
        return this;
      }
      /**
       * Match only rows where each column in `query` keys is equal to its
       * associated value. Shorthand for multiple `.eq()`s.
       *
       * @param query - The object to filter with, with column names as keys mapped
       * to their filter values
       */
      match(query) {
        Object.entries(query).forEach(([column, value]) => {
          this.url.searchParams.append(column, `eq.${value}`);
        });
        return this;
      }
      /**
       * Match only rows which doesn't satisfy the filter.
       *
       * Unlike most filters, `opearator` and `value` are used as-is and need to
       * follow [PostgREST
       * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
       * to make sure they are properly sanitized.
       *
       * @param column - The column to filter on
       * @param operator - The operator to be negated to filter with, following
       * PostgREST syntax
       * @param value - The value to filter with, following PostgREST syntax
       */
      not(column, operator, value) {
        this.url.searchParams.append(column, `not.${operator}.${value}`);
        return this;
      }
      /**
       * Match only rows which satisfy at least one of the filters.
       *
       * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
       * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
       * to make sure it's properly sanitized.
       *
       * It's currently not possible to do an `.or()` filter across multiple tables.
       *
       * @param filters - The filters to use, following PostgREST syntax
       * @param options - Named parameters
       * @param options.referencedTable - Set this to filter on referenced tables
       * instead of the parent table
       * @param options.foreignTable - Deprecated, use `referencedTable` instead
       */
      or(filters, { foreignTable, referencedTable = foreignTable } = {}) {
        const key = referencedTable ? `${referencedTable}.or` : "or";
        this.url.searchParams.append(key, `(${filters})`);
        return this;
      }
      /**
       * Match only rows which satisfy the filter. This is an escape hatch - you
       * should use the specific filter methods wherever possible.
       *
       * Unlike most filters, `opearator` and `value` are used as-is and need to
       * follow [PostgREST
       * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
       * to make sure they are properly sanitized.
       *
       * @param column - The column to filter on
       * @param operator - The operator to filter with, following PostgREST syntax
       * @param value - The value to filter with, following PostgREST syntax
       */
      filter(column, operator, value) {
        this.url.searchParams.append(column, `${operator}.${value}`);
        return this;
      }
    };
    exports.default = PostgrestFilterBuilder2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js
var require_PostgrestQueryBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestFilterBuilder_1 = __importDefault(require_PostgrestFilterBuilder());
    var PostgrestQueryBuilder2 = class {
      constructor(url, { headers = {}, schema, fetch: fetch4 }) {
        this.url = url;
        this.headers = headers;
        this.schema = schema;
        this.fetch = fetch4;
      }
      /**
       * Perform a SELECT query on the table or view.
       *
       * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
       *
       * @param options - Named parameters
       *
       * @param options.head - When set to `true`, `data` will not be returned.
       * Useful if you only need the count.
       *
       * @param options.count - Count algorithm to use to count rows in the table or view.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      select(columns, { head: head2 = false, count } = {}) {
        const method = head2 ? "HEAD" : "GET";
        let quoted = false;
        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c) => {
          if (/\s/.test(c) && !quoted) {
            return "";
          }
          if (c === '"') {
            quoted = !quoted;
          }
          return c;
        }).join("");
        this.url.searchParams.set("select", cleanedColumns);
        if (count) {
          this.headers["Prefer"] = `count=${count}`;
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
      /**
       * Perform an INSERT into the table or view.
       *
       * By default, inserted rows are not returned. To return it, chain the call
       * with `.select()`.
       *
       * @param values - The values to insert. Pass an object to insert a single row
       * or an array to insert multiple rows.
       *
       * @param options - Named parameters
       *
       * @param options.count - Count algorithm to use to count inserted rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       *
       * @param options.defaultToNull - Make missing fields default to `null`.
       * Otherwise, use the default value for the column. Only applies for bulk
       * inserts.
       */
      insert(values, { count, defaultToNull = true } = {}) {
        const method = "POST";
        const prefersHeaders = [];
        if (this.headers["Prefer"]) {
          prefersHeaders.push(this.headers["Prefer"]);
        }
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        if (!defaultToNull) {
          prefersHeaders.push("missing=default");
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        if (Array.isArray(values)) {
          const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
          if (columns.length > 0) {
            const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
            this.url.searchParams.set("columns", uniqueColumns.join(","));
          }
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: values,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
      /**
       * Perform an UPSERT on the table or view. Depending on the column(s) passed
       * to `onConflict`, `.upsert()` allows you to perform the equivalent of
       * `.insert()` if a row with the corresponding `onConflict` columns doesn't
       * exist, or if it does exist, perform an alternative action depending on
       * `ignoreDuplicates`.
       *
       * By default, upserted rows are not returned. To return it, chain the call
       * with `.select()`.
       *
       * @param values - The values to upsert with. Pass an object to upsert a
       * single row or an array to upsert multiple rows.
       *
       * @param options - Named parameters
       *
       * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
       * duplicate rows are determined. Two rows are duplicates if all the
       * `onConflict` columns are equal.
       *
       * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
       * `false`, duplicate rows are merged with existing rows.
       *
       * @param options.count - Count algorithm to use to count upserted rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       *
       * @param options.defaultToNull - Make missing fields default to `null`.
       * Otherwise, use the default value for the column. This only applies when
       * inserting new rows, not when merging with existing rows under
       * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
       */
      upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {
        const method = "POST";
        const prefersHeaders = [`resolution=${ignoreDuplicates ? "ignore" : "merge"}-duplicates`];
        if (onConflict !== void 0)
          this.url.searchParams.set("on_conflict", onConflict);
        if (this.headers["Prefer"]) {
          prefersHeaders.push(this.headers["Prefer"]);
        }
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        if (!defaultToNull) {
          prefersHeaders.push("missing=default");
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        if (Array.isArray(values)) {
          const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
          if (columns.length > 0) {
            const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
            this.url.searchParams.set("columns", uniqueColumns.join(","));
          }
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: values,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
      /**
       * Perform an UPDATE on the table or view.
       *
       * By default, updated rows are not returned. To return it, chain the call
       * with `.select()` after filters.
       *
       * @param values - The values to update with
       *
       * @param options - Named parameters
       *
       * @param options.count - Count algorithm to use to count updated rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      update(values, { count } = {}) {
        const method = "PATCH";
        const prefersHeaders = [];
        if (this.headers["Prefer"]) {
          prefersHeaders.push(this.headers["Prefer"]);
        }
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: values,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
      /**
       * Perform a DELETE on the table or view.
       *
       * By default, deleted rows are not returned. To return it, chain the call
       * with `.select()` after filters.
       *
       * @param options - Named parameters
       *
       * @param options.count - Count algorithm to use to count deleted rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      delete({ count } = {}) {
        const method = "DELETE";
        const prefersHeaders = [];
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        if (this.headers["Prefer"]) {
          prefersHeaders.unshift(this.headers["Prefer"]);
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
    };
    exports.default = PostgrestQueryBuilder2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/version.js
var require_version = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "0.0.0-automated";
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/constants.js
var require_constants = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_HEADERS = void 0;
    var version_1 = require_version();
    exports.DEFAULT_HEADERS = { "X-Client-Info": `postgrest-js/${version_1.version}` };
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js
var require_PostgrestClient = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestQueryBuilder_1 = __importDefault(require_PostgrestQueryBuilder());
    var PostgrestFilterBuilder_1 = __importDefault(require_PostgrestFilterBuilder());
    var constants_1 = require_constants();
    var PostgrestClient2 = class {
      // TODO: Add back shouldThrowOnError once we figure out the typings
      /**
       * Creates a PostgREST client.
       *
       * @param url - URL of the PostgREST endpoint
       * @param options - Named parameters
       * @param options.headers - Custom headers
       * @param options.schema - Postgres schema to switch to
       * @param options.fetch - Custom fetch
       */
      constructor(url, { headers = {}, schema, fetch: fetch4 } = {}) {
        this.url = url;
        this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);
        this.schemaName = schema;
        this.fetch = fetch4;
      }
      /**
       * Perform a query on a table or a view.
       *
       * @param relation - The table or view name to query
       */
      from(relation) {
        const url = new URL(`${this.url}/${relation}`);
        return new PostgrestQueryBuilder_1.default(url, {
          headers: Object.assign({}, this.headers),
          schema: this.schemaName,
          fetch: this.fetch
        });
      }
      /**
       * Select a schema to query or perform an function (rpc) call.
       *
       * The schema needs to be on the list of exposed schemas inside Supabase.
       *
       * @param schema - The schema to query
       */
      schema(schema) {
        return new PostgrestClient2(this.url, {
          headers: this.headers,
          schema,
          fetch: this.fetch
        });
      }
      /**
       * Perform a function call.
       *
       * @param fn - The function name to call
       * @param args - The arguments to pass to the function call
       * @param options - Named parameters
       * @param options.head - When set to `true`, `data` will not be returned.
       * Useful if you only need the count.
       * @param options.get - When set to `true`, the function will be called with
       * read-only access mode.
       * @param options.count - Count algorithm to use to count rows returned by the
       * function. Only applicable for [set-returning
       * functions](https://www.postgresql.org/docs/current/functions-srf.html).
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      rpc(fn, args = {}, { head: head2 = false, get: get2 = false, count } = {}) {
        let method;
        const url = new URL(`${this.url}/rpc/${fn}`);
        let body;
        if (head2 || get2) {
          method = head2 ? "HEAD" : "GET";
          Object.entries(args).filter(([_, value]) => value !== void 0).map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(",")}}` : `${value}`]).forEach(([name, value]) => {
            url.searchParams.append(name, value);
          });
        } else {
          method = "POST";
          body = args;
        }
        const headers = Object.assign({}, this.headers);
        if (count) {
          headers["Prefer"] = `count=${count}`;
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url,
          headers,
          schema: this.schemaName,
          body,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
    };
    exports.default = PostgrestClient2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PostgrestError = exports.PostgrestBuilder = exports.PostgrestTransformBuilder = exports.PostgrestFilterBuilder = exports.PostgrestQueryBuilder = exports.PostgrestClient = void 0;
    var PostgrestClient_1 = __importDefault(require_PostgrestClient());
    exports.PostgrestClient = PostgrestClient_1.default;
    var PostgrestQueryBuilder_1 = __importDefault(require_PostgrestQueryBuilder());
    exports.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;
    var PostgrestFilterBuilder_1 = __importDefault(require_PostgrestFilterBuilder());
    exports.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;
    var PostgrestTransformBuilder_1 = __importDefault(require_PostgrestTransformBuilder());
    exports.PostgrestTransformBuilder = PostgrestTransformBuilder_1.default;
    var PostgrestBuilder_1 = __importDefault(require_PostgrestBuilder());
    exports.PostgrestBuilder = PostgrestBuilder_1.default;
    var PostgrestError_1 = __importDefault(require_PostgrestError());
    exports.PostgrestError = PostgrestError_1.default;
    exports.default = {
      PostgrestClient: PostgrestClient_1.default,
      PostgrestQueryBuilder: PostgrestQueryBuilder_1.default,
      PostgrestFilterBuilder: PostgrestFilterBuilder_1.default,
      PostgrestTransformBuilder: PostgrestTransformBuilder_1.default,
      PostgrestBuilder: PostgrestBuilder_1.default,
      PostgrestError: PostgrestError_1.default
    };
  }
});

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MindMatrixPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian12 = require("obsidian");

// node_modules/@supabase/functions-js/dist/module/helper.js
var resolveFetch = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => Promise.resolve().then(() => (init_browser(), browser_exports)).then(({ default: fetch4 }) => fetch4(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};

// node_modules/@supabase/functions-js/dist/module/types.js
var FunctionsError = class extends Error {
  constructor(message, name = "FunctionsError", context) {
    super(message);
    this.name = name;
    this.context = context;
  }
};
var FunctionsFetchError = class extends FunctionsError {
  constructor(context) {
    super("Failed to send a request to the Edge Function", "FunctionsFetchError", context);
  }
};
var FunctionsRelayError = class extends FunctionsError {
  constructor(context) {
    super("Relay Error invoking the Edge Function", "FunctionsRelayError", context);
  }
};
var FunctionsHttpError = class extends FunctionsError {
  constructor(context) {
    super("Edge Function returned a non-2xx status code", "FunctionsHttpError", context);
  }
};
var FunctionRegion;
(function(FunctionRegion2) {
  FunctionRegion2["Any"] = "any";
  FunctionRegion2["ApNortheast1"] = "ap-northeast-1";
  FunctionRegion2["ApNortheast2"] = "ap-northeast-2";
  FunctionRegion2["ApSouth1"] = "ap-south-1";
  FunctionRegion2["ApSoutheast1"] = "ap-southeast-1";
  FunctionRegion2["ApSoutheast2"] = "ap-southeast-2";
  FunctionRegion2["CaCentral1"] = "ca-central-1";
  FunctionRegion2["EuCentral1"] = "eu-central-1";
  FunctionRegion2["EuWest1"] = "eu-west-1";
  FunctionRegion2["EuWest2"] = "eu-west-2";
  FunctionRegion2["EuWest3"] = "eu-west-3";
  FunctionRegion2["SaEast1"] = "sa-east-1";
  FunctionRegion2["UsEast1"] = "us-east-1";
  FunctionRegion2["UsWest1"] = "us-west-1";
  FunctionRegion2["UsWest2"] = "us-west-2";
})(FunctionRegion || (FunctionRegion = {}));

// node_modules/@supabase/functions-js/dist/module/FunctionsClient.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FunctionsClient = class {
  constructor(url, { headers = {}, customFetch, region = FunctionRegion.Any } = {}) {
    this.url = url;
    this.headers = headers;
    this.region = region;
    this.fetch = resolveFetch(customFetch);
  }
  /**
   * Updates the authorization header
   * @param token - the new jwt token sent in the authorisation header
   */
  setAuth(token) {
    this.headers.Authorization = `Bearer ${token}`;
  }
  /**
   * Invokes a function
   * @param functionName - The name of the Function to invoke.
   * @param options - Options for invoking the Function.
   */
  invoke(functionName, options = {}) {
    var _a2;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const { headers, method, body: functionArgs } = options;
        let _headers = {};
        let { region } = options;
        if (!region) {
          region = this.region;
        }
        if (region && region !== "any") {
          _headers["x-region"] = region;
        }
        let body;
        if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, "Content-Type") || !headers)) {
          if (typeof Blob !== "undefined" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
            _headers["Content-Type"] = "application/octet-stream";
            body = functionArgs;
          } else if (typeof functionArgs === "string") {
            _headers["Content-Type"] = "text/plain";
            body = functionArgs;
          } else if (typeof FormData !== "undefined" && functionArgs instanceof FormData) {
            body = functionArgs;
          } else {
            _headers["Content-Type"] = "application/json";
            body = JSON.stringify(functionArgs);
          }
        }
        const response = yield this.fetch(`${this.url}/${functionName}`, {
          method: method || "POST",
          // headers priority is (high to low):
          // 1. invoke-level headers
          // 2. client-level headers
          // 3. default Content-Type header
          headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),
          body
        }).catch((fetchError) => {
          throw new FunctionsFetchError(fetchError);
        });
        const isRelayError = response.headers.get("x-relay-error");
        if (isRelayError && isRelayError === "true") {
          throw new FunctionsRelayError(response);
        }
        if (!response.ok) {
          throw new FunctionsHttpError(response);
        }
        let responseType = ((_a2 = response.headers.get("Content-Type")) !== null && _a2 !== void 0 ? _a2 : "text/plain").split(";")[0].trim();
        let data;
        if (responseType === "application/json") {
          data = yield response.json();
        } else if (responseType === "application/octet-stream") {
          data = yield response.blob();
        } else if (responseType === "text/event-stream") {
          data = response;
        } else if (responseType === "multipart/form-data") {
          data = yield response.formData();
        } else {
          data = yield response.text();
        }
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    });
  }
};

// node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs
var import_cjs = __toESM(require_cjs(), 1);
var {
  PostgrestClient,
  PostgrestQueryBuilder,
  PostgrestFilterBuilder,
  PostgrestTransformBuilder,
  PostgrestBuilder,
  PostgrestError
} = import_cjs.default;

// node_modules/@supabase/realtime-js/dist/module/lib/version.js
var version = "2.11.2";

// node_modules/@supabase/realtime-js/dist/module/lib/constants.js
var DEFAULT_HEADERS = { "X-Client-Info": `realtime-js/${version}` };
var VSN = "1.0.0";
var DEFAULT_TIMEOUT = 1e4;
var WS_CLOSE_NORMAL = 1e3;
var SOCKET_STATES;
(function(SOCKET_STATES2) {
  SOCKET_STATES2[SOCKET_STATES2["connecting"] = 0] = "connecting";
  SOCKET_STATES2[SOCKET_STATES2["open"] = 1] = "open";
  SOCKET_STATES2[SOCKET_STATES2["closing"] = 2] = "closing";
  SOCKET_STATES2[SOCKET_STATES2["closed"] = 3] = "closed";
})(SOCKET_STATES || (SOCKET_STATES = {}));
var CHANNEL_STATES;
(function(CHANNEL_STATES2) {
  CHANNEL_STATES2["closed"] = "closed";
  CHANNEL_STATES2["errored"] = "errored";
  CHANNEL_STATES2["joined"] = "joined";
  CHANNEL_STATES2["joining"] = "joining";
  CHANNEL_STATES2["leaving"] = "leaving";
})(CHANNEL_STATES || (CHANNEL_STATES = {}));
var CHANNEL_EVENTS;
(function(CHANNEL_EVENTS2) {
  CHANNEL_EVENTS2["close"] = "phx_close";
  CHANNEL_EVENTS2["error"] = "phx_error";
  CHANNEL_EVENTS2["join"] = "phx_join";
  CHANNEL_EVENTS2["reply"] = "phx_reply";
  CHANNEL_EVENTS2["leave"] = "phx_leave";
  CHANNEL_EVENTS2["access_token"] = "access_token";
})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));
var TRANSPORTS;
(function(TRANSPORTS2) {
  TRANSPORTS2["websocket"] = "websocket";
})(TRANSPORTS || (TRANSPORTS = {}));
var CONNECTION_STATE;
(function(CONNECTION_STATE2) {
  CONNECTION_STATE2["Connecting"] = "connecting";
  CONNECTION_STATE2["Open"] = "open";
  CONNECTION_STATE2["Closing"] = "closing";
  CONNECTION_STATE2["Closed"] = "closed";
})(CONNECTION_STATE || (CONNECTION_STATE = {}));

// node_modules/@supabase/realtime-js/dist/module/lib/serializer.js
var Serializer = class {
  constructor() {
    this.HEADER_LENGTH = 1;
  }
  decode(rawPayload, callback) {
    if (rawPayload.constructor === ArrayBuffer) {
      return callback(this._binaryDecode(rawPayload));
    }
    if (typeof rawPayload === "string") {
      return callback(JSON.parse(rawPayload));
    }
    return callback({});
  }
  _binaryDecode(buffer) {
    const view = new DataView(buffer);
    const decoder = new TextDecoder();
    return this._decodeBroadcast(buffer, view, decoder);
  }
  _decodeBroadcast(buffer, view, decoder) {
    const topicSize = view.getUint8(1);
    const eventSize = view.getUint8(2);
    let offset = this.HEADER_LENGTH + 2;
    const topic = decoder.decode(buffer.slice(offset, offset + topicSize));
    offset = offset + topicSize;
    const event = decoder.decode(buffer.slice(offset, offset + eventSize));
    offset = offset + eventSize;
    const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));
    return { ref: null, topic, event, payload: data };
  }
};

// node_modules/@supabase/realtime-js/dist/module/lib/timer.js
var Timer = class {
  constructor(callback, timerCalc) {
    this.callback = callback;
    this.timerCalc = timerCalc;
    this.timer = void 0;
    this.tries = 0;
    this.callback = callback;
    this.timerCalc = timerCalc;
  }
  reset() {
    this.tries = 0;
    clearTimeout(this.timer);
  }
  // Cancels any previous scheduleTimeout and schedules callback
  scheduleTimeout() {
    clearTimeout(this.timer);
    this.timer = setTimeout(() => {
      this.tries = this.tries + 1;
      this.callback();
    }, this.timerCalc(this.tries + 1));
  }
};

// node_modules/@supabase/realtime-js/dist/module/lib/transformers.js
var PostgresTypes;
(function(PostgresTypes2) {
  PostgresTypes2["abstime"] = "abstime";
  PostgresTypes2["bool"] = "bool";
  PostgresTypes2["date"] = "date";
  PostgresTypes2["daterange"] = "daterange";
  PostgresTypes2["float4"] = "float4";
  PostgresTypes2["float8"] = "float8";
  PostgresTypes2["int2"] = "int2";
  PostgresTypes2["int4"] = "int4";
  PostgresTypes2["int4range"] = "int4range";
  PostgresTypes2["int8"] = "int8";
  PostgresTypes2["int8range"] = "int8range";
  PostgresTypes2["json"] = "json";
  PostgresTypes2["jsonb"] = "jsonb";
  PostgresTypes2["money"] = "money";
  PostgresTypes2["numeric"] = "numeric";
  PostgresTypes2["oid"] = "oid";
  PostgresTypes2["reltime"] = "reltime";
  PostgresTypes2["text"] = "text";
  PostgresTypes2["time"] = "time";
  PostgresTypes2["timestamp"] = "timestamp";
  PostgresTypes2["timestamptz"] = "timestamptz";
  PostgresTypes2["timetz"] = "timetz";
  PostgresTypes2["tsrange"] = "tsrange";
  PostgresTypes2["tstzrange"] = "tstzrange";
})(PostgresTypes || (PostgresTypes = {}));
var convertChangeData = (columns, record, options = {}) => {
  var _a2;
  const skipTypes = (_a2 = options.skipTypes) !== null && _a2 !== void 0 ? _a2 : [];
  return Object.keys(record).reduce((acc, rec_key) => {
    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
    return acc;
  }, {});
};
var convertColumn = (columnName, columns, record, skipTypes) => {
  const column = columns.find((x) => x.name === columnName);
  const colType = column === null || column === void 0 ? void 0 : column.type;
  const value = record[columnName];
  if (colType && !skipTypes.includes(colType)) {
    return convertCell(colType, value);
  }
  return noop(value);
};
var convertCell = (type, value) => {
  if (type.charAt(0) === "_") {
    const dataType = type.slice(1, type.length);
    return toArray(value, dataType);
  }
  switch (type) {
    case PostgresTypes.bool:
      return toBoolean(value);
    case PostgresTypes.float4:
    case PostgresTypes.float8:
    case PostgresTypes.int2:
    case PostgresTypes.int4:
    case PostgresTypes.int8:
    case PostgresTypes.numeric:
    case PostgresTypes.oid:
      return toNumber(value);
    case PostgresTypes.json:
    case PostgresTypes.jsonb:
      return toJson(value);
    case PostgresTypes.timestamp:
      return toTimestampString(value);
    case PostgresTypes.abstime:
    case PostgresTypes.date:
    case PostgresTypes.daterange:
    case PostgresTypes.int4range:
    case PostgresTypes.int8range:
    case PostgresTypes.money:
    case PostgresTypes.reltime:
    case PostgresTypes.text:
    case PostgresTypes.time:
    case PostgresTypes.timestamptz:
    case PostgresTypes.timetz:
    case PostgresTypes.tsrange:
    case PostgresTypes.tstzrange:
      return noop(value);
    default:
      return noop(value);
  }
};
var noop = (value) => {
  return value;
};
var toBoolean = (value) => {
  switch (value) {
    case "t":
      return true;
    case "f":
      return false;
    default:
      return value;
  }
};
var toNumber = (value) => {
  if (typeof value === "string") {
    const parsedValue = parseFloat(value);
    if (!Number.isNaN(parsedValue)) {
      return parsedValue;
    }
  }
  return value;
};
var toJson = (value) => {
  if (typeof value === "string") {
    try {
      return JSON.parse(value);
    } catch (error) {
      console.log(`JSON parse error: ${error}`);
      return value;
    }
  }
  return value;
};
var toArray = (value, type) => {
  if (typeof value !== "string") {
    return value;
  }
  const lastIdx = value.length - 1;
  const closeBrace = value[lastIdx];
  const openBrace = value[0];
  if (openBrace === "{" && closeBrace === "}") {
    let arr;
    const valTrim = value.slice(1, lastIdx);
    try {
      arr = JSON.parse("[" + valTrim + "]");
    } catch (_) {
      arr = valTrim ? valTrim.split(",") : [];
    }
    return arr.map((val) => convertCell(type, val));
  }
  return value;
};
var toTimestampString = (value) => {
  if (typeof value === "string") {
    return value.replace(" ", "T");
  }
  return value;
};
var httpEndpointURL = (socketUrl) => {
  let url = socketUrl;
  url = url.replace(/^ws/i, "http");
  url = url.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, "");
  return url.replace(/\/+$/, "");
};

// node_modules/@supabase/realtime-js/dist/module/lib/push.js
var Push = class {
  /**
   * Initializes the Push
   *
   * @param channel The Channel
   * @param event The event, for example `"phx_join"`
   * @param payload The payload, for example `{user_id: 123}`
   * @param timeout The push timeout in milliseconds
   */
  constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {
    this.channel = channel;
    this.event = event;
    this.payload = payload;
    this.timeout = timeout;
    this.sent = false;
    this.timeoutTimer = void 0;
    this.ref = "";
    this.receivedResp = null;
    this.recHooks = [];
    this.refEvent = null;
  }
  resend(timeout) {
    this.timeout = timeout;
    this._cancelRefEvent();
    this.ref = "";
    this.refEvent = null;
    this.receivedResp = null;
    this.sent = false;
    this.send();
  }
  send() {
    if (this._hasReceived("timeout")) {
      return;
    }
    this.startTimeout();
    this.sent = true;
    this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload,
      ref: this.ref,
      join_ref: this.channel._joinRef()
    });
  }
  updatePayload(payload) {
    this.payload = Object.assign(Object.assign({}, this.payload), payload);
  }
  receive(status, callback) {
    var _a2;
    if (this._hasReceived(status)) {
      callback((_a2 = this.receivedResp) === null || _a2 === void 0 ? void 0 : _a2.response);
    }
    this.recHooks.push({ status, callback });
    return this;
  }
  startTimeout() {
    if (this.timeoutTimer) {
      return;
    }
    this.ref = this.channel.socket._makeRef();
    this.refEvent = this.channel._replyEventName(this.ref);
    const callback = (payload) => {
      this._cancelRefEvent();
      this._cancelTimeout();
      this.receivedResp = payload;
      this._matchReceive(payload);
    };
    this.channel._on(this.refEvent, {}, callback);
    this.timeoutTimer = setTimeout(() => {
      this.trigger("timeout", {});
    }, this.timeout);
  }
  trigger(status, response) {
    if (this.refEvent)
      this.channel._trigger(this.refEvent, { status, response });
  }
  destroy() {
    this._cancelRefEvent();
    this._cancelTimeout();
  }
  _cancelRefEvent() {
    if (!this.refEvent) {
      return;
    }
    this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer);
    this.timeoutTimer = void 0;
  }
  _matchReceive({ status, response }) {
    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
  }
  _hasReceived(status) {
    return this.receivedResp && this.receivedResp.status === status;
  }
};

// node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js
var REALTIME_PRESENCE_LISTEN_EVENTS;
(function(REALTIME_PRESENCE_LISTEN_EVENTS2) {
  REALTIME_PRESENCE_LISTEN_EVENTS2["SYNC"] = "sync";
  REALTIME_PRESENCE_LISTEN_EVENTS2["JOIN"] = "join";
  REALTIME_PRESENCE_LISTEN_EVENTS2["LEAVE"] = "leave";
})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));
var RealtimePresence = class {
  /**
   * Initializes the Presence.
   *
   * @param channel - The RealtimeChannel
   * @param opts - The options,
   *        for example `{events: {state: 'state', diff: 'diff'}}`
   */
  constructor(channel, opts) {
    this.channel = channel;
    this.state = {};
    this.pendingDiffs = [];
    this.joinRef = null;
    this.caller = {
      onJoin: () => {
      },
      onLeave: () => {
      },
      onSync: () => {
      }
    };
    const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {
      state: "presence_state",
      diff: "presence_diff"
    };
    this.channel._on(events.state, {}, (newState) => {
      const { onJoin, onLeave, onSync } = this.caller;
      this.joinRef = this.channel._joinRef();
      this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);
      this.pendingDiffs.forEach((diff) => {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
      });
      this.pendingDiffs = [];
      onSync();
    });
    this.channel._on(events.diff, {}, (diff) => {
      const { onJoin, onLeave, onSync } = this.caller;
      if (this.inPendingSyncState()) {
        this.pendingDiffs.push(diff);
      } else {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
        onSync();
      }
    });
    this.onJoin((key, currentPresences, newPresences) => {
      this.channel._trigger("presence", {
        event: "join",
        key,
        currentPresences,
        newPresences
      });
    });
    this.onLeave((key, currentPresences, leftPresences) => {
      this.channel._trigger("presence", {
        event: "leave",
        key,
        currentPresences,
        leftPresences
      });
    });
    this.onSync(() => {
      this.channel._trigger("presence", { event: "sync" });
    });
  }
  /**
   * Used to sync the list of presences on the server with the
   * client's state.
   *
   * An optional `onJoin` and `onLeave` callback can be provided to
   * react to changes in the client's local presences across
   * disconnects and reconnects with the server.
   *
   * @internal
   */
  static syncState(currentState, newState, onJoin, onLeave) {
    const state = this.cloneDeep(currentState);
    const transformedState = this.transformState(newState);
    const joins = {};
    const leaves = {};
    this.map(state, (key, presences) => {
      if (!transformedState[key]) {
        leaves[key] = presences;
      }
    });
    this.map(transformedState, (key, newPresences) => {
      const currentPresences = state[key];
      if (currentPresences) {
        const newPresenceRefs = newPresences.map((m) => m.presence_ref);
        const curPresenceRefs = currentPresences.map((m) => m.presence_ref);
        const joinedPresences = newPresences.filter((m) => curPresenceRefs.indexOf(m.presence_ref) < 0);
        const leftPresences = currentPresences.filter((m) => newPresenceRefs.indexOf(m.presence_ref) < 0);
        if (joinedPresences.length > 0) {
          joins[key] = joinedPresences;
        }
        if (leftPresences.length > 0) {
          leaves[key] = leftPresences;
        }
      } else {
        joins[key] = newPresences;
      }
    });
    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);
  }
  /**
   * Used to sync a diff of presence join and leave events from the
   * server, as they happen.
   *
   * Like `syncState`, `syncDiff` accepts optional `onJoin` and
   * `onLeave` callbacks to react to a user joining or leaving from a
   * device.
   *
   * @internal
   */
  static syncDiff(state, diff, onJoin, onLeave) {
    const { joins, leaves } = {
      joins: this.transformState(diff.joins),
      leaves: this.transformState(diff.leaves)
    };
    if (!onJoin) {
      onJoin = () => {
      };
    }
    if (!onLeave) {
      onLeave = () => {
      };
    }
    this.map(joins, (key, newPresences) => {
      var _a2;
      const currentPresences = (_a2 = state[key]) !== null && _a2 !== void 0 ? _a2 : [];
      state[key] = this.cloneDeep(newPresences);
      if (currentPresences.length > 0) {
        const joinedPresenceRefs = state[key].map((m) => m.presence_ref);
        const curPresences = currentPresences.filter((m) => joinedPresenceRefs.indexOf(m.presence_ref) < 0);
        state[key].unshift(...curPresences);
      }
      onJoin(key, currentPresences, newPresences);
    });
    this.map(leaves, (key, leftPresences) => {
      let currentPresences = state[key];
      if (!currentPresences)
        return;
      const presenceRefsToRemove = leftPresences.map((m) => m.presence_ref);
      currentPresences = currentPresences.filter((m) => presenceRefsToRemove.indexOf(m.presence_ref) < 0);
      state[key] = currentPresences;
      onLeave(key, currentPresences, leftPresences);
      if (currentPresences.length === 0)
        delete state[key];
    });
    return state;
  }
  /** @internal */
  static map(obj, func) {
    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));
  }
  /**
   * Remove 'metas' key
   * Change 'phx_ref' to 'presence_ref'
   * Remove 'phx_ref' and 'phx_ref_prev'
   *
   * @example
   * // returns {
   *  abc123: [
   *    { presence_ref: '2', user_id: 1 },
   *    { presence_ref: '3', user_id: 2 }
   *  ]
   * }
   * RealtimePresence.transformState({
   *  abc123: {
   *    metas: [
   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
   *      { phx_ref: '3', user_id: 2 }
   *    ]
   *  }
   * })
   *
   * @internal
   */
  static transformState(state) {
    state = this.cloneDeep(state);
    return Object.getOwnPropertyNames(state).reduce((newState, key) => {
      const presences = state[key];
      if ("metas" in presences) {
        newState[key] = presences.metas.map((presence) => {
          presence["presence_ref"] = presence["phx_ref"];
          delete presence["phx_ref"];
          delete presence["phx_ref_prev"];
          return presence;
        });
      } else {
        newState[key] = presences;
      }
      return newState;
    }, {});
  }
  /** @internal */
  static cloneDeep(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  /** @internal */
  onJoin(callback) {
    this.caller.onJoin = callback;
  }
  /** @internal */
  onLeave(callback) {
    this.caller.onLeave = callback;
  }
  /** @internal */
  onSync(callback) {
    this.caller.onSync = callback;
  }
  /** @internal */
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
};

// node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js
var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2) {
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["ALL"] = "*";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["INSERT"] = "INSERT";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["UPDATE"] = "UPDATE";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["DELETE"] = "DELETE";
})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
var REALTIME_LISTEN_TYPES;
(function(REALTIME_LISTEN_TYPES2) {
  REALTIME_LISTEN_TYPES2["BROADCAST"] = "broadcast";
  REALTIME_LISTEN_TYPES2["PRESENCE"] = "presence";
  REALTIME_LISTEN_TYPES2["POSTGRES_CHANGES"] = "postgres_changes";
  REALTIME_LISTEN_TYPES2["SYSTEM"] = "system";
})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));
var REALTIME_SUBSCRIBE_STATES;
(function(REALTIME_SUBSCRIBE_STATES2) {
  REALTIME_SUBSCRIBE_STATES2["SUBSCRIBED"] = "SUBSCRIBED";
  REALTIME_SUBSCRIBE_STATES2["TIMED_OUT"] = "TIMED_OUT";
  REALTIME_SUBSCRIBE_STATES2["CLOSED"] = "CLOSED";
  REALTIME_SUBSCRIBE_STATES2["CHANNEL_ERROR"] = "CHANNEL_ERROR";
})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));
var RealtimeChannel = class {
  constructor(topic, params = { config: {} }, socket) {
    this.topic = topic;
    this.params = params;
    this.socket = socket;
    this.bindings = {};
    this.state = CHANNEL_STATES.closed;
    this.joinedOnce = false;
    this.pushBuffer = [];
    this.subTopic = topic.replace(/^realtime:/i, "");
    this.params.config = Object.assign({
      broadcast: { ack: false, self: false },
      presence: { key: "" },
      private: false
    }, params.config);
    this.timeout = this.socket.timeout;
    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
    this.joinPush.receive("ok", () => {
      this.state = CHANNEL_STATES.joined;
      this.rejoinTimer.reset();
      this.pushBuffer.forEach((pushEvent) => pushEvent.send());
      this.pushBuffer = [];
    });
    this._onClose(() => {
      this.rejoinTimer.reset();
      this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`);
      this.state = CHANNEL_STATES.closed;
      this.socket._remove(this);
    });
    this._onError((reason) => {
      if (this._isLeaving() || this._isClosed()) {
        return;
      }
      this.socket.log("channel", `error ${this.topic}`, reason);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this.joinPush.receive("timeout", () => {
      if (!this._isJoining()) {
        return;
      }
      this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {
      this._trigger(this._replyEventName(ref), payload);
    });
    this.presence = new RealtimePresence(this);
    this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint) + "/api/broadcast";
    this.private = this.params.config.private || false;
  }
  /** Subscribe registers your client with the server */
  subscribe(callback, timeout = this.timeout) {
    var _a2, _b;
    if (!this.socket.isConnected()) {
      this.socket.connect();
    }
    if (this.joinedOnce) {
      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;
    } else {
      const { config: { broadcast, presence, private: isPrivate } } = this.params;
      this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));
      this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));
      const accessTokenPayload = {};
      const config = {
        broadcast,
        presence,
        postgres_changes: (_b = (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [],
        private: isPrivate
      };
      if (this.socket.accessTokenValue) {
        accessTokenPayload.access_token = this.socket.accessTokenValue;
      }
      this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));
      this.joinedOnce = true;
      this._rejoin(timeout);
      this.joinPush.receive("ok", async ({ postgres_changes }) => {
        var _a3;
        this.socket.setAuth();
        if (postgres_changes === void 0) {
          callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          return;
        } else {
          const clientPostgresBindings = this.bindings.postgres_changes;
          const bindingsLen = (_a3 = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a3 !== void 0 ? _a3 : 0;
          const newPostgresBindings = [];
          for (let i = 0; i < bindingsLen; i++) {
            const clientPostgresBinding = clientPostgresBindings[i];
            const { filter: { event, schema, table, filter } } = clientPostgresBinding;
            const serverPostgresFilter = postgres_changes && postgres_changes[i];
            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {
              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));
            } else {
              this.unsubscribe();
              callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
              return;
            }
          }
          this.bindings.postgres_changes = newPostgresBindings;
          callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          return;
        }
      }).receive("error", (error) => {
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(", ") || "error")));
        return;
      }).receive("timeout", () => {
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);
        return;
      });
    }
    return this;
  }
  presenceState() {
    return this.presence.state;
  }
  async track(payload, opts = {}) {
    return await this.send({
      type: "presence",
      event: "track",
      payload
    }, opts.timeout || this.timeout);
  }
  async untrack(opts = {}) {
    return await this.send({
      type: "presence",
      event: "untrack"
    }, opts);
  }
  on(type, filter, callback) {
    return this._on(type, filter, callback);
  }
  /**
   * Sends a message into the channel.
   *
   * @param args Arguments to send to channel
   * @param args.type The type of event to send
   * @param args.event The name of the event being sent
   * @param args.payload Payload to be sent
   * @param opts Options to be used during the send process
   */
  async send(args, opts = {}) {
    var _a2, _b;
    if (!this._canPush() && args.type === "broadcast") {
      const { event, payload: endpoint_payload } = args;
      const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
      const options = {
        method: "POST",
        headers: {
          Authorization: authorization,
          apikey: this.socket.apiKey ? this.socket.apiKey : "",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: [
            {
              topic: this.subTopic,
              event,
              payload: endpoint_payload,
              private: this.private
            }
          ]
        })
      };
      try {
        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a2 = opts.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout);
        await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());
        return response.ok ? "ok" : "error";
      } catch (error) {
        if (error.name === "AbortError") {
          return "timed out";
        } else {
          return "error";
        }
      }
    } else {
      return new Promise((resolve) => {
        var _a3, _b2, _c;
        const push2 = this._push(args.type, args, opts.timeout || this.timeout);
        if (args.type === "broadcast" && !((_c = (_b2 = (_a3 = this.params) === null || _a3 === void 0 ? void 0 : _a3.config) === null || _b2 === void 0 ? void 0 : _b2.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {
          resolve("ok");
        }
        push2.receive("ok", () => resolve("ok"));
        push2.receive("error", () => resolve("error"));
        push2.receive("timeout", () => resolve("timed out"));
      });
    }
  }
  updateJoinPayload(payload) {
    this.joinPush.updatePayload(payload);
  }
  /**
   * Leaves the channel.
   *
   * Unsubscribes from server events, and instructs channel to terminate on server.
   * Triggers onClose() hooks.
   *
   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
   * channel.unsubscribe().receive("ok", () => alert("left!") )
   */
  unsubscribe(timeout = this.timeout) {
    this.state = CHANNEL_STATES.leaving;
    const onClose = () => {
      this.socket.log("channel", `leave ${this.topic}`);
      this._trigger(CHANNEL_EVENTS.close, "leave", this._joinRef());
    };
    this.rejoinTimer.reset();
    this.joinPush.destroy();
    return new Promise((resolve) => {
      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);
      leavePush.receive("ok", () => {
        onClose();
        resolve("ok");
      }).receive("timeout", () => {
        onClose();
        resolve("timed out");
      }).receive("error", () => {
        resolve("error");
      });
      leavePush.send();
      if (!this._canPush()) {
        leavePush.trigger("ok", {});
      }
    });
  }
  /** @internal */
  async _fetchWithTimeout(url, options, timeout) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));
    clearTimeout(id);
    return response;
  }
  /** @internal */
  _push(event, payload, timeout = this.timeout) {
    if (!this.joinedOnce) {
      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    }
    let pushEvent = new Push(this, event, payload, timeout);
    if (this._canPush()) {
      pushEvent.send();
    } else {
      pushEvent.startTimeout();
      this.pushBuffer.push(pushEvent);
    }
    return pushEvent;
  }
  /**
   * Overridable message hook
   *
   * Receives all events for specialized message handling before dispatching to the channel callbacks.
   * Must return the payload, modified or unmodified.
   *
   * @internal
   */
  _onMessage(_event, payload, _ref) {
    return payload;
  }
  /** @internal */
  _isMember(topic) {
    return this.topic === topic;
  }
  /** @internal */
  _joinRef() {
    return this.joinPush.ref;
  }
  /** @internal */
  _trigger(type, payload, ref) {
    var _a2, _b;
    const typeLower = type.toLocaleLowerCase();
    const { close, error, leave, join } = CHANNEL_EVENTS;
    const events = [close, error, leave, join];
    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
      return;
    }
    let handledPayload = this._onMessage(typeLower, payload, ref);
    if (payload && !handledPayload) {
      throw "channel onMessage callbacks must return the payload, modified or unmodified";
    }
    if (["insert", "update", "delete"].includes(typeLower)) {
      (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.filter((bind) => {
        var _a3, _b2, _c;
        return ((_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event) === "*" || ((_c = (_b2 = bind.filter) === null || _b2 === void 0 ? void 0 : _b2.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
      }).map((bind) => bind.callback(handledPayload, ref));
    } else {
      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {
        var _a3, _b2, _c, _d, _e, _f;
        if (["broadcast", "presence", "postgres_changes"].includes(typeLower)) {
          if ("id" in bind) {
            const bindId = bind.id;
            const bindEvent = (_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event;
            return bindId && ((_b2 = payload.ids) === null || _b2 === void 0 ? void 0 : _b2.includes(bindId)) && (bindEvent === "*" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));
          } else {
            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();
            return bindEvent === "*" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());
          }
        } else {
          return bind.type.toLocaleLowerCase() === typeLower;
        }
      }).map((bind) => {
        if (typeof handledPayload === "object" && "ids" in handledPayload) {
          const postgresChanges = handledPayload.data;
          const { schema, table, commit_timestamp, type: type2, errors } = postgresChanges;
          const enrichedPayload = {
            schema,
            table,
            commit_timestamp,
            eventType: type2,
            new: {},
            old: {},
            errors
          };
          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));
        }
        bind.callback(handledPayload, ref);
      });
    }
  }
  /** @internal */
  _isClosed() {
    return this.state === CHANNEL_STATES.closed;
  }
  /** @internal */
  _isJoined() {
    return this.state === CHANNEL_STATES.joined;
  }
  /** @internal */
  _isJoining() {
    return this.state === CHANNEL_STATES.joining;
  }
  /** @internal */
  _isLeaving() {
    return this.state === CHANNEL_STATES.leaving;
  }
  /** @internal */
  _replyEventName(ref) {
    return `chan_reply_${ref}`;
  }
  /** @internal */
  _on(type, filter, callback) {
    const typeLower = type.toLocaleLowerCase();
    const binding = {
      type: typeLower,
      filter,
      callback
    };
    if (this.bindings[typeLower]) {
      this.bindings[typeLower].push(binding);
    } else {
      this.bindings[typeLower] = [binding];
    }
    return this;
  }
  /** @internal */
  _off(type, filter) {
    const typeLower = type.toLocaleLowerCase();
    this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {
      var _a2;
      return !(((_a2 = bind.type) === null || _a2 === void 0 ? void 0 : _a2.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
    });
    return this;
  }
  /** @internal */
  static isEqual(obj1, obj2) {
    if (Object.keys(obj1).length !== Object.keys(obj2).length) {
      return false;
    }
    for (const k in obj1) {
      if (obj1[k] !== obj2[k]) {
        return false;
      }
    }
    return true;
  }
  /** @internal */
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout();
    if (this.socket.isConnected()) {
      this._rejoin();
    }
  }
  /**
   * Registers a callback that will be executed when the channel closes.
   *
   * @internal
   */
  _onClose(callback) {
    this._on(CHANNEL_EVENTS.close, {}, callback);
  }
  /**
   * Registers a callback that will be executed when the channel encounteres an error.
   *
   * @internal
   */
  _onError(callback) {
    this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));
  }
  /**
   * Returns `true` if the socket is connected and the channel has been joined.
   *
   * @internal
   */
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  /** @internal */
  _rejoin(timeout = this.timeout) {
    if (this._isLeaving()) {
      return;
    }
    this.socket._leaveOpenTopic(this.topic);
    this.state = CHANNEL_STATES.joining;
    this.joinPush.resend(timeout);
  }
  /** @internal */
  _getPayloadRecords(payload) {
    const records = {
      new: {},
      old: {}
    };
    if (payload.type === "INSERT" || payload.type === "UPDATE") {
      records.new = convertChangeData(payload.columns, payload.record);
    }
    if (payload.type === "UPDATE" || payload.type === "DELETE") {
      records.old = convertChangeData(payload.columns, payload.old_record);
    }
    return records;
  }
};

// node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js
var noop2 = () => {
};
var NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket !== "undefined";
var WORKER_SCRIPT = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
var RealtimeClient = class {
  /**
   * Initializes the Socket.
   *
   * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
   * @param httpEndpoint The string HTTP endpoint, ie, "https://example.com", "/" (inherited host & protocol)
   * @param options.transport The Websocket Transport, for example WebSocket.
   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
   * @param options.params The optional params to pass when connecting.
   * @param options.headers The optional headers to pass when connecting.
   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
   * @param options.worker Use Web Worker to set a side flow. Defaults to false.
   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.
   */
  constructor(endPoint, options) {
    var _a2;
    this.accessTokenValue = null;
    this.apiKey = null;
    this.channels = [];
    this.endPoint = "";
    this.httpEndpoint = "";
    this.headers = DEFAULT_HEADERS;
    this.params = {};
    this.timeout = DEFAULT_TIMEOUT;
    this.heartbeatIntervalMs = 3e4;
    this.heartbeatTimer = void 0;
    this.pendingHeartbeatRef = null;
    this.ref = 0;
    this.logger = noop2;
    this.conn = null;
    this.sendBuffer = [];
    this.serializer = new Serializer();
    this.stateChangeCallbacks = {
      open: [],
      close: [],
      error: [],
      message: []
    };
    this.accessToken = null;
    this._resolveFetch = (customFetch) => {
      let _fetch;
      if (customFetch) {
        _fetch = customFetch;
      } else if (typeof fetch === "undefined") {
        _fetch = (...args) => Promise.resolve().then(() => (init_browser(), browser_exports)).then(({ default: fetch4 }) => fetch4(...args));
      } else {
        _fetch = fetch;
      }
      return (...args) => _fetch(...args);
    };
    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
    this.httpEndpoint = httpEndpointURL(endPoint);
    if (options === null || options === void 0 ? void 0 : options.transport) {
      this.transport = options.transport;
    } else {
      this.transport = null;
    }
    if (options === null || options === void 0 ? void 0 : options.params)
      this.params = options.params;
    if (options === null || options === void 0 ? void 0 : options.headers)
      this.headers = Object.assign(Object.assign({}, this.headers), options.headers);
    if (options === null || options === void 0 ? void 0 : options.timeout)
      this.timeout = options.timeout;
    if (options === null || options === void 0 ? void 0 : options.logger)
      this.logger = options.logger;
    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)
      this.heartbeatIntervalMs = options.heartbeatIntervalMs;
    const accessTokenValue = (_a2 = options === null || options === void 0 ? void 0 : options.params) === null || _a2 === void 0 ? void 0 : _a2.apikey;
    if (accessTokenValue) {
      this.accessTokenValue = accessTokenValue;
      this.apiKey = accessTokenValue;
    }
    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : (tries) => {
      return [1e3, 2e3, 5e3, 1e4][tries - 1] || 1e4;
    };
    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {
      return callback(JSON.stringify(payload));
    };
    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);
    this.reconnectTimer = new Timer(async () => {
      this.disconnect();
      this.connect();
    }, this.reconnectAfterMs);
    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);
    if (options === null || options === void 0 ? void 0 : options.worker) {
      if (typeof window !== "undefined" && !window.Worker) {
        throw new Error("Web Worker is not supported");
      }
      this.worker = (options === null || options === void 0 ? void 0 : options.worker) || false;
      this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;
    }
    this.accessToken = (options === null || options === void 0 ? void 0 : options.accessToken) || null;
  }
  /**
   * Connects the socket, unless already connected.
   */
  connect() {
    if (this.conn) {
      return;
    }
    if (this.transport) {
      this.conn = new this.transport(this.endpointURL(), void 0, {
        headers: this.headers
      });
      return;
    }
    if (NATIVE_WEBSOCKET_AVAILABLE) {
      this.conn = new WebSocket(this.endpointURL());
      this.setupConnection();
      return;
    }
    this.conn = new WSWebSocketDummy(this.endpointURL(), void 0, {
      close: () => {
        this.conn = null;
      }
    });
    Promise.resolve().then(() => __toESM(require_browser())).then(({ default: WS }) => {
      this.conn = new WS(this.endpointURL(), void 0, {
        headers: this.headers
      });
      this.setupConnection();
    });
  }
  /**
   * Returns the URL of the websocket.
   * @returns string The URL of the websocket.
   */
  endpointURL() {
    return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));
  }
  /**
   * Disconnects the socket.
   *
   * @param code A numeric status code to send on disconnect.
   * @param reason A custom reason for the disconnect.
   */
  disconnect(code, reason) {
    if (this.conn) {
      this.conn.onclose = function() {
      };
      if (code) {
        this.conn.close(code, reason !== null && reason !== void 0 ? reason : "");
      } else {
        this.conn.close();
      }
      this.conn = null;
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.reconnectTimer.reset();
    }
  }
  /**
   * Returns all created channels
   */
  getChannels() {
    return this.channels;
  }
  /**
   * Unsubscribes and removes a single channel
   * @param channel A RealtimeChannel instance
   */
  async removeChannel(channel) {
    const status = await channel.unsubscribe();
    if (this.channels.length === 0) {
      this.disconnect();
    }
    return status;
  }
  /**
   * Unsubscribes and removes all channels
   */
  async removeAllChannels() {
    const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));
    this.disconnect();
    return values_1;
  }
  /**
   * Logs the message.
   *
   * For customized logging, `this.logger` can be overridden.
   */
  log(kind2, msg, data) {
    this.logger(kind2, msg, data);
  }
  /**
   * Returns the current state of the socket.
   */
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case SOCKET_STATES.connecting:
        return CONNECTION_STATE.Connecting;
      case SOCKET_STATES.open:
        return CONNECTION_STATE.Open;
      case SOCKET_STATES.closing:
        return CONNECTION_STATE.Closing;
      default:
        return CONNECTION_STATE.Closed;
    }
  }
  /**
   * Returns `true` is the connection is open.
   */
  isConnected() {
    return this.connectionState() === CONNECTION_STATE.Open;
  }
  channel(topic, params = { config: {} }) {
    const chan = new RealtimeChannel(`realtime:${topic}`, params, this);
    this.channels.push(chan);
    return chan;
  }
  /**
   * Push out a message if the socket is connected.
   *
   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
   */
  push(data) {
    const { topic, event, payload, ref } = data;
    const callback = () => {
      this.encode(data, (result) => {
        var _a2;
        (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.send(result);
      });
    };
    this.log("push", `${topic} ${event} (${ref})`, payload);
    if (this.isConnected()) {
      callback();
    } else {
      this.sendBuffer.push(callback);
    }
  }
  /**
   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
   *
   * If param is null it will use the `accessToken` callback function or the token set on the client.
   *
   * On callback used, it will set the value of the token internal to the client.
   *
   * @param token A JWT string to override the token set on the client.
   */
  async setAuth(token = null) {
    let tokenToSend = token || this.accessToken && await this.accessToken() || this.accessTokenValue;
    if (tokenToSend) {
      let parsed = null;
      try {
        parsed = JSON.parse(atob(tokenToSend.split(".")[1]));
      } catch (_error) {
      }
      if (parsed && parsed.exp) {
        let now = Math.floor(Date.now() / 1e3);
        let valid = now - parsed.exp < 0;
        if (!valid) {
          this.log("auth", `InvalidJWTToken: Invalid value for JWT claim "exp" with value ${parsed.exp}`);
          return Promise.reject(`InvalidJWTToken: Invalid value for JWT claim "exp" with value ${parsed.exp}`);
        }
      }
      this.accessTokenValue = tokenToSend;
      this.channels.forEach((channel) => {
        tokenToSend && channel.updateJoinPayload({ access_token: tokenToSend });
        if (channel.joinedOnce && channel._isJoined()) {
          channel._push(CHANNEL_EVENTS.access_token, {
            access_token: tokenToSend
          });
        }
      });
    }
  }
  /**
   * Sends a heartbeat message if the socket is connected.
   */
  async sendHeartbeat() {
    var _a2;
    if (!this.isConnected()) {
      return;
    }
    if (this.pendingHeartbeatRef) {
      this.pendingHeartbeatRef = null;
      this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
      (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.close(WS_CLOSE_NORMAL, "hearbeat timeout");
      return;
    }
    this.pendingHeartbeatRef = this._makeRef();
    this.push({
      topic: "phoenix",
      event: "heartbeat",
      payload: {},
      ref: this.pendingHeartbeatRef
    });
    this.setAuth();
  }
  /**
   * Flushes send buffer
   */
  flushSendBuffer() {
    if (this.isConnected() && this.sendBuffer.length > 0) {
      this.sendBuffer.forEach((callback) => callback());
      this.sendBuffer = [];
    }
  }
  /**
   * Return the next message ref, accounting for overflows
   *
   * @internal
   */
  _makeRef() {
    let newRef = this.ref + 1;
    if (newRef === this.ref) {
      this.ref = 0;
    } else {
      this.ref = newRef;
    }
    return this.ref.toString();
  }
  /**
   * Unsubscribe from channels with the specified topic.
   *
   * @internal
   */
  _leaveOpenTopic(topic) {
    let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));
    if (dupChannel) {
      this.log("transport", `leaving duplicate topic "${topic}"`);
      dupChannel.unsubscribe();
    }
  }
  /**
   * Removes a subscription from the socket.
   *
   * @param channel An open subscription.
   *
   * @internal
   */
  _remove(channel) {
    this.channels = this.channels.filter((c) => c._joinRef() !== channel._joinRef());
  }
  /**
   * Sets up connection handlers.
   *
   * @internal
   */
  setupConnection() {
    if (this.conn) {
      this.conn.binaryType = "arraybuffer";
      this.conn.onopen = () => this._onConnOpen();
      this.conn.onerror = (error) => this._onConnError(error);
      this.conn.onmessage = (event) => this._onConnMessage(event);
      this.conn.onclose = (event) => this._onConnClose(event);
    }
  }
  /** @internal */
  _onConnMessage(rawMessage) {
    this.decode(rawMessage.data, (msg) => {
      let { topic, event, payload, ref } = msg;
      if (ref && ref === this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
      }
      this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
      this.channels.filter((channel) => channel._isMember(topic)).forEach((channel) => channel._trigger(event, payload, ref));
      this.stateChangeCallbacks.message.forEach((callback) => callback(msg));
    });
  }
  /** @internal */
  async _onConnOpen() {
    this.log("transport", `connected to ${this.endpointURL()}`);
    this.flushSendBuffer();
    this.reconnectTimer.reset();
    if (!this.worker) {
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    } else {
      if (this.workerUrl) {
        this.log("worker", `starting worker for from ${this.workerUrl}`);
      } else {
        this.log("worker", `starting default worker`);
      }
      const objectUrl = this._workerObjectUrl(this.workerUrl);
      this.workerRef = new Worker(objectUrl);
      this.workerRef.onerror = (error) => {
        this.log("worker", "worker error", error.message);
        this.workerRef.terminate();
      };
      this.workerRef.onmessage = (event) => {
        if (event.data.event === "keepAlive") {
          this.sendHeartbeat();
        }
      };
      this.workerRef.postMessage({
        event: "start",
        interval: this.heartbeatIntervalMs
      });
    }
    this.stateChangeCallbacks.open.forEach((callback) => callback());
  }
  /** @internal */
  _onConnClose(event) {
    this.log("transport", "close", event);
    this._triggerChanError();
    this.heartbeatTimer && clearInterval(this.heartbeatTimer);
    this.reconnectTimer.scheduleTimeout();
    this.stateChangeCallbacks.close.forEach((callback) => callback(event));
  }
  /** @internal */
  _onConnError(error) {
    this.log("transport", error.message);
    this._triggerChanError();
    this.stateChangeCallbacks.error.forEach((callback) => callback(error));
  }
  /** @internal */
  _triggerChanError() {
    this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));
  }
  /** @internal */
  _appendParams(url, params) {
    if (Object.keys(params).length === 0) {
      return url;
    }
    const prefix = url.match(/\?/) ? "&" : "?";
    const query = new URLSearchParams(params);
    return `${url}${prefix}${query}`;
  }
  _workerObjectUrl(url) {
    let result_url;
    if (url) {
      result_url = url;
    } else {
      const blob = new Blob([WORKER_SCRIPT], { type: "application/javascript" });
      result_url = URL.createObjectURL(blob);
    }
    return result_url;
  }
};
var WSWebSocketDummy = class {
  constructor(address, _protocols, options) {
    this.binaryType = "arraybuffer";
    this.onclose = () => {
    };
    this.onerror = () => {
    };
    this.onmessage = () => {
    };
    this.onopen = () => {
    };
    this.readyState = SOCKET_STATES.connecting;
    this.send = () => {
    };
    this.url = null;
    this.url = address;
    this.close = options.close;
  }
};

// node_modules/@supabase/storage-js/dist/module/lib/errors.js
var StorageError = class extends Error {
  constructor(message) {
    super(message);
    this.__isStorageError = true;
    this.name = "StorageError";
  }
};
function isStorageError(error) {
  return typeof error === "object" && error !== null && "__isStorageError" in error;
}
var StorageApiError = class extends StorageError {
  constructor(message, status) {
    super(message);
    this.name = "StorageApiError";
    this.status = status;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    };
  }
};
var StorageUnknownError = class extends StorageError {
  constructor(message, originalError) {
    super(message);
    this.name = "StorageUnknownError";
    this.originalError = originalError;
  }
};

// node_modules/@supabase/storage-js/dist/module/lib/helpers.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var resolveFetch2 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => Promise.resolve().then(() => (init_browser(), browser_exports)).then(({ default: fetch4 }) => fetch4(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
var resolveResponse = () => __awaiter2(void 0, void 0, void 0, function* () {
  if (typeof Response === "undefined") {
    return (yield Promise.resolve().then(() => (init_browser(), browser_exports))).Response;
  }
  return Response;
});
var recursiveToCamel = (item) => {
  if (Array.isArray(item)) {
    return item.map((el) => recursiveToCamel(el));
  } else if (typeof item === "function" || item !== Object(item)) {
    return item;
  }
  const result = {};
  Object.entries(item).forEach(([key, value]) => {
    const newKey = key.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ""));
    result[newKey] = recursiveToCamel(value);
  });
  return result;
};

// node_modules/@supabase/storage-js/dist/module/lib/fetch.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
var handleError = (error, reject, options) => __awaiter3(void 0, void 0, void 0, function* () {
  const Res = yield resolveResponse();
  if (error instanceof Res && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
    error.json().then((err) => {
      reject(new StorageApiError(_getErrorMessage(err), error.status || 500));
    }).catch((err) => {
      reject(new StorageUnknownError(_getErrorMessage(err), err));
    });
  } else {
    reject(new StorageUnknownError(_getErrorMessage(error), error));
  }
});
var _getRequestParams = (method, options, parameters, body) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET") {
    return params;
  }
  params.headers = Object.assign({ "Content-Type": "application/json" }, options === null || options === void 0 ? void 0 : options.headers);
  if (body) {
    params.body = JSON.stringify(body);
  }
  return Object.assign(Object.assign({}, params), parameters);
};
function _handleRequest(fetcher, method, url, options, parameters, body) {
  return __awaiter3(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      fetcher(url, _getRequestParams(method, options, parameters, body)).then((result) => {
        if (!result.ok)
          throw result;
        if (options === null || options === void 0 ? void 0 : options.noResolveJson)
          return result;
        return result.json();
      }).then((data) => resolve(data)).catch((error) => handleError(error, reject, options));
    });
  });
}
function get(fetcher, url, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "GET", url, options, parameters);
  });
}
function post(fetcher, url, body, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "POST", url, options, parameters, body);
  });
}
function put(fetcher, url, body, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "PUT", url, options, parameters, body);
  });
}
function head(fetcher, url, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "HEAD", url, Object.assign(Object.assign({}, options), { noResolveJson: true }), parameters);
  });
}
function remove(fetcher, url, body, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "DELETE", url, options, parameters, body);
  });
}

// node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_SEARCH_OPTIONS = {
  limit: 100,
  offset: 0,
  sortBy: {
    column: "name",
    order: "asc"
  }
};
var DEFAULT_FILE_OPTIONS = {
  cacheControl: "3600",
  contentType: "text/plain;charset=UTF-8",
  upsert: false
};
var StorageFileApi = class {
  constructor(url, headers = {}, bucketId, fetch4) {
    this.url = url;
    this.headers = headers;
    this.bucketId = bucketId;
    this.fetch = resolveFetch2(fetch4);
  }
  /**
   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
   *
   * @param method HTTP method.
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadOrUpdate(method, path, fileBody, fileOptions) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        let body;
        const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
        let headers = Object.assign(Object.assign({}, this.headers), method === "POST" && { "x-upsert": String(options.upsert) });
        const metadata = options.metadata;
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          body = new FormData();
          body.append("cacheControl", options.cacheControl);
          if (metadata) {
            body.append("metadata", this.encodeMetadata(metadata));
          }
          body.append("", fileBody);
        } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
          body = fileBody;
          body.append("cacheControl", options.cacheControl);
          if (metadata) {
            body.append("metadata", this.encodeMetadata(metadata));
          }
        } else {
          body = fileBody;
          headers["cache-control"] = `max-age=${options.cacheControl}`;
          headers["content-type"] = options.contentType;
          if (metadata) {
            headers["x-metadata"] = this.toBase64(this.encodeMetadata(metadata));
          }
        }
        if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) {
          headers = Object.assign(Object.assign({}, headers), fileOptions.headers);
        }
        const cleanPath = this._removeEmptyFolders(path);
        const _path = this._getFinalPath(cleanPath);
        const res = yield this.fetch(`${this.url}/object/${_path}`, Object.assign({ method, body, headers }, (options === null || options === void 0 ? void 0 : options.duplex) ? { duplex: options.duplex } : {}));
        const data = yield res.json();
        if (res.ok) {
          return {
            data: { path: cleanPath, id: data.Id, fullPath: data.Key },
            error: null
          };
        } else {
          const error = data;
          return { data: null, error };
        }
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Uploads a file to an existing bucket.
   *
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  upload(path, fileBody, fileOptions) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("POST", path, fileBody, fileOptions);
    });
  }
  /**
   * Upload a file with a token generated from `createSignedUploadUrl`.
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param token The token generated from `createSignedUploadUrl`
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadToSignedUrl(path, token, fileBody, fileOptions) {
    return __awaiter4(this, void 0, void 0, function* () {
      const cleanPath = this._removeEmptyFolders(path);
      const _path = this._getFinalPath(cleanPath);
      const url = new URL(this.url + `/object/upload/sign/${_path}`);
      url.searchParams.set("token", token);
      try {
        let body;
        const options = Object.assign({ upsert: DEFAULT_FILE_OPTIONS.upsert }, fileOptions);
        const headers = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(options.upsert) });
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          body = new FormData();
          body.append("cacheControl", options.cacheControl);
          body.append("", fileBody);
        } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
          body = fileBody;
          body.append("cacheControl", options.cacheControl);
        } else {
          body = fileBody;
          headers["cache-control"] = `max-age=${options.cacheControl}`;
          headers["content-type"] = options.contentType;
        }
        const res = yield this.fetch(url.toString(), {
          method: "PUT",
          body,
          headers
        });
        const data = yield res.json();
        if (res.ok) {
          return {
            data: { path: cleanPath, fullPath: data.Key },
            error: null
          };
        } else {
          const error = data;
          return { data: null, error };
        }
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a signed upload URL.
   * Signed upload URLs can be used to upload files to the bucket without further authentication.
   * They are valid for 2 hours.
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param options.upsert If set to true, allows the file to be overwritten if it already exists.
   */
  createSignedUploadUrl(path, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        const headers = Object.assign({}, this.headers);
        if (options === null || options === void 0 ? void 0 : options.upsert) {
          headers["x-upsert"] = "true";
        }
        const data = yield post(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, { headers });
        const url = new URL(this.url + data.url);
        const token = url.searchParams.get("token");
        if (!token) {
          throw new StorageError("No token returned by API");
        }
        return { data: { signedUrl: url.toString(), path, token }, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Replaces an existing file at the specified path with a new one.
   *
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  update(path, fileBody, fileOptions) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("PUT", path, fileBody, fileOptions);
    });
  }
  /**
   * Moves an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
   * @param options The destination options.
   */
  move(fromPath, toPath, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/object/move`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath,
          destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Copies an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
   * @param options The destination options.
   */
  copy(fromPath, toPath, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/object/copy`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath,
          destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
        }, { headers: this.headers });
        return { data: { path: data.Key }, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  createSignedUrl(path, expiresIn, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        let data = yield post(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({ expiresIn }, (options === null || options === void 0 ? void 0 : options.transform) ? { transform: options.transform } : {}), { headers: this.headers });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
        const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);
        data = { signedUrl };
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   */
  createSignedUrls(paths, expiresIn, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
        return {
          data: data.map((datum) => Object.assign(Object.assign({}, datum), { signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null })),
          error: null
        };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
   *
   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
   * @param options.transform Transform the asset before serving it to the client.
   */
  download(path, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
      const renderPath = wantsTransformation ? "render/image/authenticated" : "object";
      const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
      const queryString = transformationQuery ? `?${transformationQuery}` : "";
      try {
        const _path = this._getFinalPath(path);
        const res = yield get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {
          headers: this.headers,
          noResolveJson: true
        });
        const data = yield res.blob();
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the details of an existing file.
   * @param path
   */
  info(path) {
    return __awaiter4(this, void 0, void 0, function* () {
      const _path = this._getFinalPath(path);
      try {
        const data = yield get(this.fetch, `${this.url}/object/info/${_path}`, {
          headers: this.headers
        });
        return { data: recursiveToCamel(data), error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Checks the existence of a file.
   * @param path
   */
  exists(path) {
    return __awaiter4(this, void 0, void 0, function* () {
      const _path = this._getFinalPath(path);
      try {
        yield head(this.fetch, `${this.url}/object/${_path}`, {
          headers: this.headers
        });
        return { data: true, error: null };
      } catch (error) {
        if (isStorageError(error) && error instanceof StorageUnknownError) {
          const originalError = error.originalError;
          if ([400, 404].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) {
            return { data: false, error };
          }
        }
        throw error;
      }
    });
  }
  /**
   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
   *
   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  getPublicUrl(path, options) {
    const _path = this._getFinalPath(path);
    const _queryString = [];
    const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? "" : options.download}` : "";
    if (downloadQueryParam !== "") {
      _queryString.push(downloadQueryParam);
    }
    const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
    const renderPath = wantsTransformation ? "render/image" : "object";
    const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
    if (transformationQuery !== "") {
      _queryString.push(transformationQuery);
    }
    let queryString = _queryString.join("&");
    if (queryString !== "") {
      queryString = `?${queryString}`;
    }
    return {
      data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) }
    };
  }
  /**
   * Deletes files within the same bucket
   *
   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
   */
  remove(paths) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Get file metadata
   * @param id the file id to retrieve metadata
   */
  // async getMetadata(
  //   id: string
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Update file metadata
   * @param id the file id to update metadata
   * @param meta the new file metadata
   */
  // async updateMetadata(
  //   id: string,
  //   meta: Metadata
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await post(
  //       this.fetch,
  //       `${this.url}/metadata/${id}`,
  //       { ...meta },
  //       { headers: this.headers }
  //     )
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Lists all the files within a bucket.
   * @param path The folder path.
   */
  list(path, options, parameters) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || "" });
        const data = yield post(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  encodeMetadata(metadata) {
    return JSON.stringify(metadata);
  }
  toBase64(data) {
    if (typeof Buffer !== "undefined") {
      return Buffer.from(data).toString("base64");
    }
    return btoa(data);
  }
  _getFinalPath(path) {
    return `${this.bucketId}/${path}`;
  }
  _removeEmptyFolders(path) {
    return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
  }
  transformOptsToQueryString(transform) {
    const params = [];
    if (transform.width) {
      params.push(`width=${transform.width}`);
    }
    if (transform.height) {
      params.push(`height=${transform.height}`);
    }
    if (transform.resize) {
      params.push(`resize=${transform.resize}`);
    }
    if (transform.format) {
      params.push(`format=${transform.format}`);
    }
    if (transform.quality) {
      params.push(`quality=${transform.quality}`);
    }
    return params.join("&");
  }
};

// node_modules/@supabase/storage-js/dist/module/lib/version.js
var version2 = "2.7.1";

// node_modules/@supabase/storage-js/dist/module/lib/constants.js
var DEFAULT_HEADERS2 = { "X-Client-Info": `storage-js/${version2}` };

// node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var StorageBucketApi = class {
  constructor(url, headers = {}, fetch4) {
    this.url = url;
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS2), headers);
    this.fetch = resolveFetch2(fetch4);
  }
  /**
   * Retrieves the details of all Storage buckets within an existing project.
   */
  listBuckets() {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield get(this.fetch, `${this.url}/bucket`, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the details of an existing Storage bucket.
   *
   * @param id The unique identifier of the bucket you would like to retrieve.
   */
  getBucket(id) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a new Storage bucket
   *
   * @param id A unique identifier for the bucket you are creating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   * @returns newly created bucket id
   */
  createBucket(id, options = {
    public: false
  }) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/bucket`, {
          id,
          name: id,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Updates a Storage bucket
   *
   * @param id A unique identifier for the bucket you are updating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   */
  updateBucket(id, options) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield put(this.fetch, `${this.url}/bucket/${id}`, {
          id,
          name: id,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Removes all objects inside a single bucket.
   *
   * @param id The unique identifier of the bucket you would like to empty.
   */
  emptyBucket(id) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
   * You must first `empty()` the bucket.
   *
   * @param id The unique identifier of the bucket you would like to delete.
   */
  deleteBucket(id) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
};

// node_modules/@supabase/storage-js/dist/module/StorageClient.js
var StorageClient = class extends StorageBucketApi {
  constructor(url, headers = {}, fetch4) {
    super(url, headers, fetch4);
  }
  /**
   * Perform file operation in a bucket.
   *
   * @param id The bucket id to operate on.
   */
  from(id) {
    return new StorageFileApi(this.url, this.headers, id, this.fetch);
  }
};

// node_modules/@supabase/supabase-js/dist/module/lib/version.js
var version3 = "2.47.16";

// node_modules/@supabase/supabase-js/dist/module/lib/constants.js
var JS_ENV = "";
if (typeof Deno !== "undefined") {
  JS_ENV = "deno";
} else if (typeof document !== "undefined") {
  JS_ENV = "web";
} else if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
  JS_ENV = "react-native";
} else {
  JS_ENV = "node";
}
var DEFAULT_HEADERS3 = { "X-Client-Info": `supabase-js-${JS_ENV}/${version3}` };
var DEFAULT_GLOBAL_OPTIONS = {
  headers: DEFAULT_HEADERS3
};
var DEFAULT_DB_OPTIONS = {
  schema: "public"
};
var DEFAULT_AUTH_OPTIONS = {
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  flowType: "implicit"
};
var DEFAULT_REALTIME_OPTIONS = {};

// node_modules/@supabase/supabase-js/dist/module/lib/fetch.js
init_browser();
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var resolveFetch3 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = browser_default;
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
var resolveHeadersConstructor = () => {
  if (typeof Headers === "undefined") {
    return Headers2;
  }
  return Headers;
};
var fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {
  const fetch4 = resolveFetch3(customFetch);
  const HeadersConstructor = resolveHeadersConstructor();
  return (input, init) => __awaiter6(void 0, void 0, void 0, function* () {
    var _a2;
    const accessToken = (_a2 = yield getAccessToken()) !== null && _a2 !== void 0 ? _a2 : supabaseKey;
    let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
    if (!headers.has("apikey")) {
      headers.set("apikey", supabaseKey);
    }
    if (!headers.has("Authorization")) {
      headers.set("Authorization", `Bearer ${accessToken}`);
    }
    return fetch4(input, Object.assign(Object.assign({}, init), { headers }));
  });
};

// node_modules/@supabase/supabase-js/dist/module/lib/helpers.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function stripTrailingSlash(url) {
  return url.replace(/\/$/, "");
}
function applySettingDefaults(options, defaults2) {
  const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;
  const { db: DEFAULT_DB_OPTIONS2, auth: DEFAULT_AUTH_OPTIONS2, realtime: DEFAULT_REALTIME_OPTIONS2, global: DEFAULT_GLOBAL_OPTIONS2 } = defaults2;
  const result = {
    db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS2), dbOptions),
    auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS2), authOptions),
    realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS2), realtimeOptions),
    global: Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS2), globalOptions),
    accessToken: () => __awaiter7(this, void 0, void 0, function* () {
      return "";
    })
  };
  if (options.accessToken) {
    result.accessToken = options.accessToken;
  } else {
    delete result.accessToken;
  }
  return result;
}

// node_modules/@supabase/auth-js/dist/module/lib/version.js
var version4 = "2.67.3";

// node_modules/@supabase/auth-js/dist/module/lib/constants.js
var GOTRUE_URL = "http://localhost:9999";
var STORAGE_KEY = "supabase.auth.token";
var DEFAULT_HEADERS4 = { "X-Client-Info": `gotrue-js/${version4}` };
var EXPIRY_MARGIN = 10;
var API_VERSION_HEADER_NAME = "X-Supabase-Api-Version";
var API_VERSIONS = {
  "2024-01-01": {
    timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
    name: "2024-01-01"
  }
};

// node_modules/@supabase/auth-js/dist/module/lib/helpers.js
function expiresAt(expiresIn) {
  const timeNow = Math.round(Date.now() / 1e3);
  return timeNow + expiresIn;
}
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
var isBrowser = () => typeof window !== "undefined" && typeof document !== "undefined";
var localStorageWriteTests = {
  tested: false,
  writable: false
};
var supportsLocalStorage = () => {
  if (!isBrowser()) {
    return false;
  }
  try {
    if (typeof globalThis.localStorage !== "object") {
      return false;
    }
  } catch (e) {
    return false;
  }
  if (localStorageWriteTests.tested) {
    return localStorageWriteTests.writable;
  }
  const randomKey = `lswt-${Math.random()}${Math.random()}`;
  try {
    globalThis.localStorage.setItem(randomKey, randomKey);
    globalThis.localStorage.removeItem(randomKey);
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = true;
  } catch (e) {
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = false;
  }
  return localStorageWriteTests.writable;
};
function parseParametersFromURL(href) {
  const result = {};
  const url = new URL(href);
  if (url.hash && url.hash[0] === "#") {
    try {
      const hashSearchParams = new URLSearchParams(url.hash.substring(1));
      hashSearchParams.forEach((value, key) => {
        result[key] = value;
      });
    } catch (e) {
    }
  }
  url.searchParams.forEach((value, key) => {
    result[key] = value;
  });
  return result;
}
var resolveFetch4 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => Promise.resolve().then(() => (init_browser(), browser_exports)).then(({ default: fetch4 }) => fetch4(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
var looksLikeFetchResponse = (maybeResponse) => {
  return typeof maybeResponse === "object" && maybeResponse !== null && "status" in maybeResponse && "ok" in maybeResponse && "json" in maybeResponse && typeof maybeResponse.json === "function";
};
var setItemAsync = async (storage, key, data) => {
  await storage.setItem(key, JSON.stringify(data));
};
var getItemAsync = async (storage, key) => {
  const value = await storage.getItem(key);
  if (!value) {
    return null;
  }
  try {
    return JSON.parse(value);
  } catch (_a2) {
    return value;
  }
};
var removeItemAsync = async (storage, key) => {
  await storage.removeItem(key);
};
function decodeBase64URL(value) {
  const key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let base64 = "";
  let chr1, chr2, chr3;
  let enc1, enc2, enc3, enc4;
  let i = 0;
  value = value.replace("-", "+").replace("_", "/");
  while (i < value.length) {
    enc1 = key.indexOf(value.charAt(i++));
    enc2 = key.indexOf(value.charAt(i++));
    enc3 = key.indexOf(value.charAt(i++));
    enc4 = key.indexOf(value.charAt(i++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    base64 = base64 + String.fromCharCode(chr1);
    if (enc3 != 64 && chr2 != 0) {
      base64 = base64 + String.fromCharCode(chr2);
    }
    if (enc4 != 64 && chr3 != 0) {
      base64 = base64 + String.fromCharCode(chr3);
    }
  }
  return base64;
}
var Deferred = class {
  constructor() {
    ;
    this.promise = new Deferred.promiseConstructor((res, rej) => {
      ;
      this.resolve = res;
      this.reject = rej;
    });
  }
};
Deferred.promiseConstructor = Promise;
function decodeJWTPayload(token) {
  const base64UrlRegex = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i;
  const parts = token.split(".");
  if (parts.length !== 3) {
    throw new Error("JWT is not valid: not a JWT structure");
  }
  if (!base64UrlRegex.test(parts[1])) {
    throw new Error("JWT is not valid: payload is not in base64url format");
  }
  const base64Url = parts[1];
  return JSON.parse(decodeBase64URL(base64Url));
}
async function sleep(time) {
  return await new Promise((accept) => {
    setTimeout(() => accept(null), time);
  });
}
function retryable(fn, isRetryable) {
  const promise = new Promise((accept, reject) => {
    ;
    (async () => {
      for (let attempt = 0; attempt < Infinity; attempt++) {
        try {
          const result = await fn(attempt);
          if (!isRetryable(attempt, null, result)) {
            accept(result);
            return;
          }
        } catch (e) {
          if (!isRetryable(attempt, e)) {
            reject(e);
            return;
          }
        }
      }
    })();
  });
  return promise;
}
function dec2hex(dec) {
  return ("0" + dec.toString(16)).substr(-2);
}
function generatePKCEVerifier() {
  const verifierLength = 56;
  const array = new Uint32Array(verifierLength);
  if (typeof crypto === "undefined") {
    const charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
    const charSetLen = charSet.length;
    let verifier = "";
    for (let i = 0; i < verifierLength; i++) {
      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));
    }
    return verifier;
  }
  crypto.getRandomValues(array);
  return Array.from(array, dec2hex).join("");
}
async function sha256(randomString) {
  const encoder = new TextEncoder();
  const encodedData = encoder.encode(randomString);
  const hash = await crypto.subtle.digest("SHA-256", encodedData);
  const bytes = new Uint8Array(hash);
  return Array.from(bytes).map((c) => String.fromCharCode(c)).join("");
}
function base64urlencode(str2) {
  return btoa(str2).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function generatePKCEChallenge(verifier) {
  const hasCryptoSupport = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined" && typeof TextEncoder !== "undefined";
  if (!hasCryptoSupport) {
    console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.");
    return verifier;
  }
  const hashed = await sha256(verifier);
  return base64urlencode(hashed);
}
async function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {
  const codeVerifier = generatePKCEVerifier();
  let storedCodeVerifier = codeVerifier;
  if (isPasswordRecovery) {
    storedCodeVerifier += "/PASSWORD_RECOVERY";
  }
  await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);
  const codeChallenge = await generatePKCEChallenge(codeVerifier);
  const codeChallengeMethod = codeVerifier === codeChallenge ? "plain" : "s256";
  return [codeChallenge, codeChallengeMethod];
}
var API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function parseResponseAPIVersion(response) {
  const apiVersion = response.headers.get(API_VERSION_HEADER_NAME);
  if (!apiVersion) {
    return null;
  }
  if (!apiVersion.match(API_VERSION_REGEX)) {
    return null;
  }
  try {
    const date = new Date(`${apiVersion}T00:00:00.0Z`);
    return date;
  } catch (e) {
    return null;
  }
}

// node_modules/@supabase/auth-js/dist/module/lib/errors.js
var AuthError = class extends Error {
  constructor(message, status, code) {
    super(message);
    this.__isAuthError = true;
    this.name = "AuthError";
    this.status = status;
    this.code = code;
  }
};
function isAuthError(error) {
  return typeof error === "object" && error !== null && "__isAuthError" in error;
}
var AuthApiError = class extends AuthError {
  constructor(message, status, code) {
    super(message, status, code);
    this.name = "AuthApiError";
    this.status = status;
    this.code = code;
  }
};
function isAuthApiError(error) {
  return isAuthError(error) && error.name === "AuthApiError";
}
var AuthUnknownError = class extends AuthError {
  constructor(message, originalError) {
    super(message);
    this.name = "AuthUnknownError";
    this.originalError = originalError;
  }
};
var CustomAuthError = class extends AuthError {
  constructor(message, name, status, code) {
    super(message, status, code);
    this.name = name;
    this.status = status;
  }
};
var AuthSessionMissingError = class extends CustomAuthError {
  constructor() {
    super("Auth session missing!", "AuthSessionMissingError", 400, void 0);
  }
};
function isAuthSessionMissingError(error) {
  return isAuthError(error) && error.name === "AuthSessionMissingError";
}
var AuthInvalidTokenResponseError = class extends CustomAuthError {
  constructor() {
    super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0);
  }
};
var AuthInvalidCredentialsError = class extends CustomAuthError {
  constructor(message) {
    super(message, "AuthInvalidCredentialsError", 400, void 0);
  }
};
var AuthImplicitGrantRedirectError = class extends CustomAuthError {
  constructor(message, details = null) {
    super(message, "AuthImplicitGrantRedirectError", 500, void 0);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
};
function isAuthImplicitGrantRedirectError(error) {
  return isAuthError(error) && error.name === "AuthImplicitGrantRedirectError";
}
var AuthPKCEGrantCodeExchangeError = class extends CustomAuthError {
  constructor(message, details = null) {
    super(message, "AuthPKCEGrantCodeExchangeError", 500, void 0);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
};
var AuthRetryableFetchError = class extends CustomAuthError {
  constructor(message, status) {
    super(message, "AuthRetryableFetchError", status, void 0);
  }
};
function isAuthRetryableFetchError(error) {
  return isAuthError(error) && error.name === "AuthRetryableFetchError";
}
var AuthWeakPasswordError = class extends CustomAuthError {
  constructor(message, status, reasons) {
    super(message, "AuthWeakPasswordError", status, "weak_password");
    this.reasons = reasons;
  }
};

// node_modules/@supabase/auth-js/dist/module/lib/fetch.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var _getErrorMessage2 = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
var NETWORK_ERROR_CODES = [502, 503, 504];
async function handleError2(error) {
  var _a2;
  if (!looksLikeFetchResponse(error)) {
    throw new AuthRetryableFetchError(_getErrorMessage2(error), 0);
  }
  if (NETWORK_ERROR_CODES.includes(error.status)) {
    throw new AuthRetryableFetchError(_getErrorMessage2(error), error.status);
  }
  let data;
  try {
    data = await error.json();
  } catch (e) {
    throw new AuthUnknownError(_getErrorMessage2(e), e);
  }
  let errorCode = void 0;
  const responseAPIVersion = parseResponseAPIVersion(error);
  if (responseAPIVersion && responseAPIVersion.getTime() >= API_VERSIONS["2024-01-01"].timestamp && typeof data === "object" && data && typeof data.code === "string") {
    errorCode = data.code;
  } else if (typeof data === "object" && data && typeof data.error_code === "string") {
    errorCode = data.error_code;
  }
  if (!errorCode) {
    if (typeof data === "object" && data && typeof data.weak_password === "object" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
      throw new AuthWeakPasswordError(_getErrorMessage2(data), error.status, data.weak_password.reasons);
    }
  } else if (errorCode === "weak_password") {
    throw new AuthWeakPasswordError(_getErrorMessage2(data), error.status, ((_a2 = data.weak_password) === null || _a2 === void 0 ? void 0 : _a2.reasons) || []);
  } else if (errorCode === "session_not_found") {
    throw new AuthSessionMissingError();
  }
  throw new AuthApiError(_getErrorMessage2(data), error.status || 500, errorCode);
}
var _getRequestParams2 = (method, options, parameters, body) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET") {
    return params;
  }
  params.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, options === null || options === void 0 ? void 0 : options.headers);
  params.body = JSON.stringify(body);
  return Object.assign(Object.assign({}, params), parameters);
};
async function _request(fetcher, method, url, options) {
  var _a2;
  const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
  if (!headers[API_VERSION_HEADER_NAME]) {
    headers[API_VERSION_HEADER_NAME] = API_VERSIONS["2024-01-01"].name;
  }
  if (options === null || options === void 0 ? void 0 : options.jwt) {
    headers["Authorization"] = `Bearer ${options.jwt}`;
  }
  const qs = (_a2 = options === null || options === void 0 ? void 0 : options.query) !== null && _a2 !== void 0 ? _a2 : {};
  if (options === null || options === void 0 ? void 0 : options.redirectTo) {
    qs["redirect_to"] = options.redirectTo;
  }
  const queryString = Object.keys(qs).length ? "?" + new URLSearchParams(qs).toString() : "";
  const data = await _handleRequest2(fetcher, method, url + queryString, {
    headers,
    noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson
  }, {}, options === null || options === void 0 ? void 0 : options.body);
  return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };
}
async function _handleRequest2(fetcher, method, url, options, parameters, body) {
  const requestParams = _getRequestParams2(method, options, parameters, body);
  let result;
  try {
    result = await fetcher(url, Object.assign({}, requestParams));
  } catch (e) {
    console.error(e);
    throw new AuthRetryableFetchError(_getErrorMessage2(e), 0);
  }
  if (!result.ok) {
    await handleError2(result);
  }
  if (options === null || options === void 0 ? void 0 : options.noResolveJson) {
    return result;
  }
  try {
    return await result.json();
  } catch (e) {
    await handleError2(e);
  }
}
function _sessionResponse(data) {
  var _a2;
  let session = null;
  if (hasSession(data)) {
    session = Object.assign({}, data);
    if (!data.expires_at) {
      session.expires_at = expiresAt(data.expires_in);
    }
  }
  const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
  return { data: { session, user }, error: null };
}
function _sessionResponsePassword(data) {
  const response = _sessionResponse(data);
  if (!response.error && data.weak_password && typeof data.weak_password === "object" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === "string" && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
    response.data.weak_password = data.weak_password;
  }
  return response;
}
function _userResponse(data) {
  var _a2;
  const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
  return { data: { user }, error: null };
}
function _ssoResponse(data) {
  return { data, error: null };
}
function _generateLinkResponse(data) {
  const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
  const properties = {
    action_link,
    email_otp,
    hashed_token,
    redirect_to,
    verification_type
  };
  const user = Object.assign({}, rest);
  return {
    data: {
      properties,
      user
    },
    error: null
  };
}
function _noResolveJsonResponse(data) {
  return data;
}
function hasSession(data) {
  return data.access_token && data.refresh_token && data.expires_in;
}

// node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var GoTrueAdminApi = class {
  constructor({ url = "", headers = {}, fetch: fetch4 }) {
    this.url = url;
    this.headers = headers;
    this.fetch = resolveFetch4(fetch4);
    this.mfa = {
      listFactors: this._listFactors.bind(this),
      deleteFactor: this._deleteFactor.bind(this)
    };
  }
  /**
   * Removes a logged-in session.
   * @param jwt A valid, logged-in JWT.
   * @param scope The logout sope.
   */
  async signOut(jwt, scope = "global") {
    try {
      await _request(this.fetch, "POST", `${this.url}/logout?scope=${scope}`, {
        headers: this.headers,
        jwt,
        noResolveJson: true
      });
      return { data: null, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Sends an invite link to an email address.
   * @param email The email address of the user.
   * @param options Additional options to be included when inviting.
   */
  async inviteUserByEmail(email, options = {}) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/invite`, {
        body: { email, data: options.data },
        headers: this.headers,
        redirectTo: options.redirectTo,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Generates email links and OTPs to be sent via a custom email provider.
   * @param email The user's email.
   * @param options.password User password. For signup only.
   * @param options.data Optional user metadata. For signup only.
   * @param options.redirectTo The redirect url which should be appended to the generated link
   */
  async generateLink(params) {
    try {
      const { options } = params, rest = __rest2(params, ["options"]);
      const body = Object.assign(Object.assign({}, rest), options);
      if ("newEmail" in rest) {
        body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;
        delete body["newEmail"];
      }
      return await _request(this.fetch, "POST", `${this.url}/admin/generate_link`, {
        body,
        headers: this.headers,
        xform: _generateLinkResponse,
        redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo
      });
    } catch (error) {
      if (isAuthError(error)) {
        return {
          data: {
            properties: null,
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  // User Admin API
  /**
   * Creates a new user.
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async createUser(attributes) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/admin/users`, {
        body: attributes,
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Get a list of users.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
   */
  async listUsers(params) {
    var _a2, _b, _c, _d, _e, _f, _g;
    try {
      const pagination = { nextPage: null, lastPage: 0, total: 0 };
      const response = await _request(this.fetch, "GET", `${this.url}/admin/users`, {
        headers: this.headers,
        noResolveJson: true,
        query: {
          page: (_b = (_a2 = params === null || params === void 0 ? void 0 : params.page) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : "",
          per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
        },
        xform: _noResolveJsonResponse
      });
      if (response.error)
        throw response.error;
      const users = await response.json();
      const total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
      const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
      if (links.length > 0) {
        links.forEach((link) => {
          const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
          const rel = JSON.parse(link.split(";")[1].split("=")[1]);
          pagination[`${rel}Page`] = page;
        });
        pagination.total = parseInt(total);
      }
      return { data: Object.assign(Object.assign({}, users), pagination), error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { users: [] }, error };
      }
      throw error;
    }
  }
  /**
   * Get user by id.
   *
   * @param uid The user's unique identifier
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async getUserById(uid) {
    try {
      return await _request(this.fetch, "GET", `${this.url}/admin/users/${uid}`, {
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Updates the user data.
   *
   * @param attributes The data you want to update.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async updateUserById(uid, attributes) {
    try {
      return await _request(this.fetch, "PUT", `${this.url}/admin/users/${uid}`, {
        body: attributes,
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Delete a user. Requires a `service_role` key.
   *
   * @param id The user id you want to remove.
   * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.
   * Defaults to false for backward compatibility.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async deleteUser(id, shouldSoftDelete = false) {
    try {
      return await _request(this.fetch, "DELETE", `${this.url}/admin/users/${id}`, {
        headers: this.headers,
        body: {
          should_soft_delete: shouldSoftDelete
        },
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  async _listFactors(params) {
    try {
      const { data, error } = await _request(this.fetch, "GET", `${this.url}/admin/users/${params.userId}/factors`, {
        headers: this.headers,
        xform: (factors) => {
          return { data: { factors }, error: null };
        }
      });
      return { data, error };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  async _deleteFactor(params) {
    try {
      const data = await _request(this.fetch, "DELETE", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {
        headers: this.headers
      });
      return { data, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
};

// node_modules/@supabase/auth-js/dist/module/lib/local-storage.js
var localStorageAdapter = {
  getItem: (key) => {
    if (!supportsLocalStorage()) {
      return null;
    }
    return globalThis.localStorage.getItem(key);
  },
  setItem: (key, value) => {
    if (!supportsLocalStorage()) {
      return;
    }
    globalThis.localStorage.setItem(key, value);
  },
  removeItem: (key) => {
    if (!supportsLocalStorage()) {
      return;
    }
    globalThis.localStorage.removeItem(key);
  }
};
function memoryLocalStorageAdapter(store = {}) {
  return {
    getItem: (key) => {
      return store[key] || null;
    },
    setItem: (key, value) => {
      store[key] = value;
    },
    removeItem: (key) => {
      delete store[key];
    }
  };
}

// node_modules/@supabase/auth-js/dist/module/lib/polyfills.js
function polyfillGlobalThis() {
  if (typeof globalThis === "object")
    return;
  try {
    Object.defineProperty(Object.prototype, "__magic__", {
      get: function() {
        return this;
      },
      configurable: true
    });
    __magic__.globalThis = __magic__;
    delete Object.prototype.__magic__;
  } catch (e) {
    if (typeof self !== "undefined") {
      self.globalThis = self;
    }
  }
}

// node_modules/@supabase/auth-js/dist/module/lib/locks.js
var internals = {
  /**
   * @experimental
   */
  debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
var LockAcquireTimeoutError = class extends Error {
  constructor(message) {
    super(message);
    this.isAcquireTimeout = true;
  }
};
var NavigatorLockAcquireTimeoutError = class extends LockAcquireTimeoutError {
};
async function navigatorLock(name, acquireTimeout, fn) {
  if (internals.debug) {
    console.log("@supabase/gotrue-js: navigatorLock: acquire lock", name, acquireTimeout);
  }
  const abortController = new globalThis.AbortController();
  if (acquireTimeout > 0) {
    setTimeout(() => {
      abortController.abort();
      if (internals.debug) {
        console.log("@supabase/gotrue-js: navigatorLock acquire timed out", name);
      }
    }, acquireTimeout);
  }
  return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {
    mode: "exclusive",
    ifAvailable: true
  } : {
    mode: "exclusive",
    signal: abortController.signal
  }, async (lock) => {
    if (lock) {
      if (internals.debug) {
        console.log("@supabase/gotrue-js: navigatorLock: acquired", name, lock.name);
      }
      try {
        return await fn();
      } finally {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: released", name, lock.name);
        }
      }
    } else {
      if (acquireTimeout === 0) {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: not immediately available", name);
        }
        throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock "${name}" immediately failed`);
      } else {
        if (internals.debug) {
          try {
            const result = await globalThis.navigator.locks.query();
            console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(result, null, "  "));
          } catch (e) {
            console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", e);
          }
        }
        console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request");
        return await fn();
      }
    }
  }));
}

// node_modules/@supabase/auth-js/dist/module/GoTrueClient.js
polyfillGlobalThis();
var DEFAULT_OPTIONS = {
  url: GOTRUE_URL,
  storageKey: STORAGE_KEY,
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  headers: DEFAULT_HEADERS4,
  flowType: "implicit",
  debug: false,
  hasCustomAuthorizationHeader: false
};
var AUTO_REFRESH_TICK_DURATION = 30 * 1e3;
var AUTO_REFRESH_TICK_THRESHOLD = 3;
async function lockNoOp(name, acquireTimeout, fn) {
  return await fn();
}
var GoTrueClient = class {
  /**
   * Create a new client for use in the browser.
   */
  constructor(options) {
    var _a2, _b;
    this.memoryStorage = null;
    this.stateChangeEmitters = /* @__PURE__ */ new Map();
    this.autoRefreshTicker = null;
    this.visibilityChangedCallback = null;
    this.refreshingDeferred = null;
    this.initializePromise = null;
    this.detectSessionInUrl = true;
    this.hasCustomAuthorizationHeader = false;
    this.suppressGetSessionWarning = false;
    this.lockAcquired = false;
    this.pendingInLock = [];
    this.broadcastChannel = null;
    this.logger = console.log;
    this.instanceID = GoTrueClient.nextInstanceID;
    GoTrueClient.nextInstanceID += 1;
    if (this.instanceID > 0 && isBrowser()) {
      console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");
    }
    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    this.logDebugMessages = !!settings.debug;
    if (typeof settings.debug === "function") {
      this.logger = settings.debug;
    }
    this.persistSession = settings.persistSession;
    this.storageKey = settings.storageKey;
    this.autoRefreshToken = settings.autoRefreshToken;
    this.admin = new GoTrueAdminApi({
      url: settings.url,
      headers: settings.headers,
      fetch: settings.fetch
    });
    this.url = settings.url;
    this.headers = settings.headers;
    this.fetch = resolveFetch4(settings.fetch);
    this.lock = settings.lock || lockNoOp;
    this.detectSessionInUrl = settings.detectSessionInUrl;
    this.flowType = settings.flowType;
    this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;
    if (settings.lock) {
      this.lock = settings.lock;
    } else if (isBrowser() && ((_a2 = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a2 === void 0 ? void 0 : _a2.locks)) {
      this.lock = navigatorLock;
    } else {
      this.lock = lockNoOp;
    }
    this.mfa = {
      verify: this._verify.bind(this),
      enroll: this._enroll.bind(this),
      unenroll: this._unenroll.bind(this),
      challenge: this._challenge.bind(this),
      listFactors: this._listFactors.bind(this),
      challengeAndVerify: this._challengeAndVerify.bind(this),
      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)
    };
    if (this.persistSession) {
      if (settings.storage) {
        this.storage = settings.storage;
      } else {
        if (supportsLocalStorage()) {
          this.storage = localStorageAdapter;
        } else {
          this.memoryStorage = {};
          this.storage = memoryLocalStorageAdapter(this.memoryStorage);
        }
      }
    } else {
      this.memoryStorage = {};
      this.storage = memoryLocalStorageAdapter(this.memoryStorage);
    }
    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
      } catch (e) {
        console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", e);
      }
      (_b = this.broadcastChannel) === null || _b === void 0 ? void 0 : _b.addEventListener("message", async (event) => {
        this._debug("received broadcast notification from other tab or client", event);
        await this._notifyAllSubscribers(event.data.event, event.data.session, false);
      });
    }
    this.initialize();
  }
  _debug(...args) {
    if (this.logDebugMessages) {
      this.logger(`GoTrueClient@${this.instanceID} (${version4}) ${new Date().toISOString()}`, ...args);
    }
    return this;
  }
  /**
   * Initializes the client session either from the url or from storage.
   * This method is automatically called when instantiating the client, but should also be called
   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
   */
  async initialize() {
    if (this.initializePromise) {
      return await this.initializePromise;
    }
    this.initializePromise = (async () => {
      return await this._acquireLock(-1, async () => {
        return await this._initialize();
      });
    })();
    return await this.initializePromise;
  }
  /**
   * IMPORTANT:
   * 1. Never throw in this method, as it is called from the constructor
   * 2. Never return a session from this method as it would be cached over
   *    the whole lifetime of the client
   */
  async _initialize() {
    var _a2;
    try {
      const params = parseParametersFromURL(window.location.href);
      let callbackUrlType = "none";
      if (this._isImplicitGrantCallback(params)) {
        callbackUrlType = "implicit";
      } else if (await this._isPKCECallback(params)) {
        callbackUrlType = "pkce";
      }
      if (isBrowser() && this.detectSessionInUrl && callbackUrlType !== "none") {
        const { data, error } = await this._getSessionFromURL(params, callbackUrlType);
        if (error) {
          this._debug("#_initialize()", "error detecting session from URL", error);
          if (isAuthImplicitGrantRedirectError(error)) {
            const errorCode = (_a2 = error.details) === null || _a2 === void 0 ? void 0 : _a2.code;
            if (errorCode === "identity_already_exists" || errorCode === "identity_not_found" || errorCode === "single_identity_not_deletable") {
              return { error };
            }
          }
          await this._removeSession();
          return { error };
        }
        const { session, redirectType } = data;
        this._debug("#_initialize()", "detected session in URL", session, "redirect type", redirectType);
        await this._saveSession(session);
        setTimeout(async () => {
          if (redirectType === "recovery") {
            await this._notifyAllSubscribers("PASSWORD_RECOVERY", session);
          } else {
            await this._notifyAllSubscribers("SIGNED_IN", session);
          }
        }, 0);
        return { error: null };
      }
      await this._recoverAndRefresh();
      return { error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { error };
      }
      return {
        error: new AuthUnknownError("Unexpected error during initialization", error)
      };
    } finally {
      await this._handleVisibilityChange();
      this._debug("#_initialize()", "end");
    }
  }
  /**
   * Creates a new anonymous user.
   *
   * @returns A session where the is_anonymous claim in the access token JWT set to true
   */
  async signInAnonymously(credentials) {
    var _a2, _b, _c;
    try {
      const res = await _request(this.fetch, "POST", `${this.url}/signup`, {
        headers: this.headers,
        body: {
          data: (_b = (_a2 = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a2 === void 0 ? void 0 : _a2.data) !== null && _b !== void 0 ? _b : {},
          gotrue_meta_security: { captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken }
        },
        xform: _sessionResponse
      });
      const { data, error } = res;
      if (error || !data) {
        return { data: { user: null, session: null }, error };
      }
      const session = data.session;
      const user = data.user;
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return { data: { user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Creates a new user.
   *
   * Be aware that if a user account exists in the system you may get back an
   * error message that attempts to hide this information from the user.
   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
   *
   * @returns A logged-in session if the server has "autoconfirm" ON
   * @returns A user if the server has "autoconfirm" OFF
   */
  async signUp(credentials) {
    var _a2, _b, _c;
    try {
      let res;
      if ("email" in credentials) {
        const { email, password, options } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        res = await _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: {
            email,
            password,
            data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          xform: _sessionResponse
        });
      } else if ("phone" in credentials) {
        const { phone, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone,
            password,
            data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},
            channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : "sms",
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponse
        });
      } else {
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
      }
      const { data, error } = res;
      if (error || !data) {
        return { data: { user: null, session: null }, error };
      }
      const session = data.session;
      const user = data.user;
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return { data: { user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in an existing user with an email and password or phone and password.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or that the
   * email/phone and password combination is wrong or that the account can only
   * be accessed via social login.
   */
  async signInWithPassword(credentials) {
    try {
      let res;
      if ("email" in credentials) {
        const { email, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            email,
            password,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponsePassword
        });
      } else if ("phone" in credentials) {
        const { phone, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            phone,
            password,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponsePassword
        });
      } else {
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
      }
      const { data, error } = res;
      if (error) {
        return { data: { user: null, session: null }, error };
      } else if (!data || !data.session || !data.user) {
        return { data: { user: null, session: null }, error: new AuthInvalidTokenResponseError() };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return {
        data: Object.assign({ user: data.user, session: data.session }, data.weak_password ? { weakPassword: data.weak_password } : null),
        error
      };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in an existing user via a third-party provider.
   * This method supports the PKCE flow.
   */
  async signInWithOAuth(credentials) {
    var _a2, _b, _c, _d;
    return await this._handleProviderSignIn(credentials.provider, {
      redirectTo: (_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo,
      scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
      queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
      skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect
    });
  }
  /**
   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
   */
  async exchangeCodeForSession(authCode) {
    await this.initializePromise;
    return this._acquireLock(-1, async () => {
      return this._exchangeCodeForSession(authCode);
    });
  }
  async _exchangeCodeForSession(authCode) {
    const storageItem = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : "").split("/");
    try {
      const { data, error } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
        headers: this.headers,
        body: {
          auth_code: authCode,
          code_verifier: codeVerifier
        },
        xform: _sessionResponse
      });
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (error) {
        throw error;
      }
      if (!data || !data.session || !data.user) {
        return {
          data: { user: null, session: null, redirectType: null },
          error: new AuthInvalidTokenResponseError()
        };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return { data: Object.assign(Object.assign({}, data), { redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null }), error };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null, redirectType: null }, error };
      }
      throw error;
    }
  }
  /**
   * Allows signing in with an OIDC ID token. The authentication provider used
   * should be enabled and configured.
   */
  async signInWithIdToken(credentials) {
    try {
      const { options, provider, token, access_token, nonce } = credentials;
      const res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
        headers: this.headers,
        body: {
          provider,
          id_token: token,
          access_token,
          nonce,
          gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
        },
        xform: _sessionResponse
      });
      const { data, error } = res;
      if (error) {
        return { data: { user: null, session: null }, error };
      } else if (!data || !data.session || !data.user) {
        return {
          data: { user: null, session: null },
          error: new AuthInvalidTokenResponseError()
        };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return { data, error };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in a user using magiclink or a one-time password (OTP).
   *
   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or, that the account
   * can only be accessed via social login.
   *
   * Do note that you will need to configure a Whatsapp sender on Twilio
   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
   * channel is not supported on other providers
   * at this time.
   * This method supports PKCE when an email is passed.
   */
  async signInWithOtp(credentials) {
    var _a2, _b, _c, _d, _e;
    try {
      if ("email" in credentials) {
        const { email, options } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        const { error } = await _request(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email,
            data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
            create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return { data: { user: null, session: null }, error };
      }
      if ("phone" in credentials) {
        const { phone, options } = credentials;
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            phone,
            data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},
            create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : "sms"
          }
        });
        return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error };
      }
      throw new AuthInvalidCredentialsError("You must provide either an email or phone number.");
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in a user given a User supplied OTP or TokenHash received through mobile or email.
   */
  async verifyOtp(params) {
    var _a2, _b;
    try {
      let redirectTo = void 0;
      let captchaToken = void 0;
      if ("options" in params) {
        redirectTo = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo;
        captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;
      }
      const { data, error } = await _request(this.fetch, "POST", `${this.url}/verify`, {
        headers: this.headers,
        body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: captchaToken } }),
        redirectTo,
        xform: _sessionResponse
      });
      if (error) {
        throw error;
      }
      if (!data) {
        throw new Error("An error occurred on token verification.");
      }
      const session = data.session;
      const user = data.user;
      if (session === null || session === void 0 ? void 0 : session.access_token) {
        await this._saveSession(session);
        await this._notifyAllSubscribers(params.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", session);
      }
      return { data: { user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Attempts a single-sign on using an enterprise Identity Provider. A
   * successful SSO attempt will redirect the current page to the identity
   * provider authorization page. The redirect URL is implementation and SSO
   * protocol specific.
   *
   * You can use it by providing a SSO domain. Typically you can extract this
   * domain by asking users for their email address. If this domain is
   * registered on the Auth instance the redirect will use that organization's
   * currently active SSO Identity Provider for the login.
   *
   * If you have built an organization-specific login page, you can use the
   * organization's SSO Identity Provider UUID directly instead.
   */
  async signInWithSSO(params) {
    var _a2, _b, _c;
    try {
      let codeChallenge = null;
      let codeChallengeMethod = null;
      if (this.flowType === "pkce") {
        ;
        [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
      }
      return await _request(this.fetch, "POST", `${this.url}/sso`, {
        body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in params ? { provider_id: params.providerId } : null), "domain" in params ? { domain: params.domain } : null), { redirect_to: (_b = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo) !== null && _b !== void 0 ? _b : void 0 }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } } : null), { skip_http_redirect: true, code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
        headers: this.headers,
        xform: _ssoResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Sends a reauthentication OTP to the user's email or phone number.
   * Requires the user to be signed-in.
   */
  async reauthenticate() {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._reauthenticate();
    });
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError)
          throw sessionError;
        if (!session)
          throw new AuthSessionMissingError();
        const { error } = await _request(this.fetch, "GET", `${this.url}/reauthenticate`, {
          headers: this.headers,
          jwt: session.access_token
        });
        return { data: { user: null, session: null }, error };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
   */
  async resend(credentials) {
    try {
      const endpoint = `${this.url}/resend`;
      if ("email" in credentials) {
        const { email, type, options } = credentials;
        const { error } = await _request(this.fetch, "POST", endpoint, {
          headers: this.headers,
          body: {
            email,
            type,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return { data: { user: null, session: null }, error };
      } else if ("phone" in credentials) {
        const { phone, type, options } = credentials;
        const { data, error } = await _request(this.fetch, "POST", endpoint, {
          headers: this.headers,
          body: {
            phone,
            type,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          }
        });
        return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error };
      }
      throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a type");
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Returns the session, refreshing it if necessary.
   *
   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
   *
   * **IMPORTANT:** This method loads values directly from the storage attached
   * to the client. If that storage is based on request cookies for example,
   * the values in it may not be authentic and therefore it's strongly advised
   * against using this method and its results in such circumstances. A warning
   * will be emitted if this is detected. Use {@link #getUser()} instead.
   */
  async getSession() {
    await this.initializePromise;
    const result = await this._acquireLock(-1, async () => {
      return this._useSession(async (result2) => {
        return result2;
      });
    });
    return result;
  }
  /**
   * Acquires a global lock based on the storage key.
   */
  async _acquireLock(acquireTimeout, fn) {
    this._debug("#_acquireLock", "begin", acquireTimeout);
    try {
      if (this.lockAcquired) {
        const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
        const result = (async () => {
          await last;
          return await fn();
        })();
        this.pendingInLock.push((async () => {
          try {
            await result;
          } catch (e) {
          }
        })());
        return result;
      }
      return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async () => {
        this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
        try {
          this.lockAcquired = true;
          const result = fn();
          this.pendingInLock.push((async () => {
            try {
              await result;
            } catch (e) {
            }
          })());
          await result;
          while (this.pendingInLock.length) {
            const waitOn = [...this.pendingInLock];
            await Promise.all(waitOn);
            this.pendingInLock.splice(0, waitOn.length);
          }
          return await result;
        } finally {
          this._debug("#_acquireLock", "lock released for storage key", this.storageKey);
          this.lockAcquired = false;
        }
      });
    } finally {
      this._debug("#_acquireLock", "end");
    }
  }
  /**
   * Use instead of {@link #getSession} inside the library. It is
   * semantically usually what you want, as getting a session involves some
   * processing afterwards that requires only one client operating on the
   * session at once across multiple tabs or processes.
   */
  async _useSession(fn) {
    this._debug("#_useSession", "begin");
    try {
      const result = await this.__loadSession();
      return await fn(result);
    } finally {
      this._debug("#_useSession", "end");
    }
  }
  /**
   * NEVER USE DIRECTLY!
   *
   * Always use {@link #_useSession}.
   */
  async __loadSession() {
    this._debug("#__loadSession()", "begin");
    if (!this.lockAcquired) {
      this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
    }
    try {
      let currentSession = null;
      const maybeSession = await getItemAsync(this.storage, this.storageKey);
      this._debug("#getSession()", "session from storage", maybeSession);
      if (maybeSession !== null) {
        if (this._isValidSession(maybeSession)) {
          currentSession = maybeSession;
        } else {
          this._debug("#getSession()", "session from storage is not valid");
          await this._removeSession();
        }
      }
      if (!currentSession) {
        return { data: { session: null }, error: null };
      }
      const hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1e3 : false;
      this._debug("#__loadSession()", `session has${hasExpired ? "" : " not"} expired`, "expires_at", currentSession.expires_at);
      if (!hasExpired) {
        if (this.storage.isServer) {
          let suppressWarning = this.suppressGetSessionWarning;
          const proxySession = new Proxy(currentSession, {
            get: (target, prop, receiver) => {
              if (!suppressWarning && prop === "user") {
                console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.");
                suppressWarning = true;
                this.suppressGetSessionWarning = true;
              }
              return Reflect.get(target, prop, receiver);
            }
          });
          currentSession = proxySession;
        }
        return { data: { session: currentSession }, error: null };
      }
      const { session, error } = await this._callRefreshToken(currentSession.refresh_token);
      if (error) {
        return { data: { session: null }, error };
      }
      return { data: { session }, error: null };
    } finally {
      this._debug("#__loadSession()", "end");
    }
  }
  /**
   * Gets the current user details if there is an existing session. This method
   * performs a network request to the Supabase Auth server, so the returned
   * value is authentic and can be used to base authorization rules on.
   *
   * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.
   */
  async getUser(jwt) {
    if (jwt) {
      return await this._getUser(jwt);
    }
    await this.initializePromise;
    const result = await this._acquireLock(-1, async () => {
      return await this._getUser();
    });
    return result;
  }
  async _getUser(jwt) {
    try {
      if (jwt) {
        return await _request(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt,
          xform: _userResponse
        });
      }
      return await this._useSession(async (result) => {
        var _a2, _b, _c;
        const { data, error } = result;
        if (error) {
          throw error;
        }
        if (!((_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) && !this.hasCustomAuthorizationHeader) {
          return { data: { user: null }, error: new AuthSessionMissingError() };
        }
        return await _request(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : void 0,
          xform: _userResponse
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        if (isAuthSessionMissingError(error)) {
          await this._removeSession();
          await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        }
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Updates user data for a logged in user.
   */
  async updateUser(attributes, options = {}) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._updateUser(attributes, options);
    });
  }
  async _updateUser(attributes, options = {}) {
    try {
      return await this._useSession(async (result) => {
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          throw sessionError;
        }
        if (!sessionData.session) {
          throw new AuthSessionMissingError();
        }
        const session = sessionData.session;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce" && attributes.email != null) {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        const { data, error: userError } = await _request(this.fetch, "PUT", `${this.url}/user`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: Object.assign(Object.assign({}, attributes), { code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
          jwt: session.access_token,
          xform: _userResponse
        });
        if (userError)
          throw userError;
        session.user = data.user;
        await this._saveSession(session);
        await this._notifyAllSubscribers("USER_UPDATED", session);
        return { data: { user: session.user }, error: null };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Decodes a JWT (without performing any validation).
   */
  _decodeJWT(jwt) {
    return decodeJWTPayload(jwt);
  }
  /**
   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
   * If the refresh token or access token in the current session is invalid, an error will be thrown.
   * @param currentSession The current session that minimally contains an access token and refresh token.
   */
  async setSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._setSession(currentSession);
    });
  }
  async _setSession(currentSession) {
    try {
      if (!currentSession.access_token || !currentSession.refresh_token) {
        throw new AuthSessionMissingError();
      }
      const timeNow = Date.now() / 1e3;
      let expiresAt2 = timeNow;
      let hasExpired = true;
      let session = null;
      const payload = decodeJWTPayload(currentSession.access_token);
      if (payload.exp) {
        expiresAt2 = payload.exp;
        hasExpired = expiresAt2 <= timeNow;
      }
      if (hasExpired) {
        const { session: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return { data: { user: null, session: null }, error };
        }
        if (!refreshedSession) {
          return { data: { user: null, session: null }, error: null };
        }
        session = refreshedSession;
      } else {
        const { data, error } = await this._getUser(currentSession.access_token);
        if (error) {
          throw error;
        }
        session = {
          access_token: currentSession.access_token,
          refresh_token: currentSession.refresh_token,
          user: data.user,
          token_type: "bearer",
          expires_in: expiresAt2 - timeNow,
          expires_at: expiresAt2
        };
        await this._saveSession(session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return { data: { user: session.user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { session: null, user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Returns a new session, regardless of expiry status.
   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
   * If the current session's refresh token is invalid, an error will be thrown.
   * @param currentSession The current session. If passed in, it must contain a refresh token.
   */
  async refreshSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._refreshSession(currentSession);
    });
  }
  async _refreshSession(currentSession) {
    try {
      return await this._useSession(async (result) => {
        var _a2;
        if (!currentSession) {
          const { data, error: error2 } = result;
          if (error2) {
            throw error2;
          }
          currentSession = (_a2 = data.session) !== null && _a2 !== void 0 ? _a2 : void 0;
        }
        if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {
          throw new AuthSessionMissingError();
        }
        const { session, error } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return { data: { user: null, session: null }, error };
        }
        if (!session) {
          return { data: { user: null, session: null }, error: null };
        }
        return { data: { user: session.user, session }, error: null };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Gets the session data from a URL string
   */
  async _getSessionFromURL(params, callbackUrlType) {
    try {
      if (!isBrowser())
        throw new AuthImplicitGrantRedirectError("No browser detected.");
      if (params.error || params.error_description || params.error_code) {
        throw new AuthImplicitGrantRedirectError(params.error_description || "Error in URL with unspecified error_description", {
          error: params.error || "unspecified_error",
          code: params.error_code || "unspecified_code"
        });
      }
      switch (callbackUrlType) {
        case "implicit":
          if (this.flowType === "pkce") {
            throw new AuthPKCEGrantCodeExchangeError("Not a valid PKCE flow url.");
          }
          break;
        case "pkce":
          if (this.flowType === "implicit") {
            throw new AuthImplicitGrantRedirectError("Not a valid implicit grant flow url.");
          }
          break;
        default:
      }
      if (callbackUrlType === "pkce") {
        this._debug("#_initialize()", "begin", "is PKCE flow", true);
        if (!params.code)
          throw new AuthPKCEGrantCodeExchangeError("No code detected.");
        const { data: data2, error: error2 } = await this._exchangeCodeForSession(params.code);
        if (error2)
          throw error2;
        const url = new URL(window.location.href);
        url.searchParams.delete("code");
        window.history.replaceState(window.history.state, "", url.toString());
        return { data: { session: data2.session, redirectType: null }, error: null };
      }
      const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;
      if (!access_token || !expires_in || !refresh_token || !token_type) {
        throw new AuthImplicitGrantRedirectError("No session defined in URL");
      }
      const timeNow = Math.round(Date.now() / 1e3);
      const expiresIn = parseInt(expires_in);
      let expiresAt2 = timeNow + expiresIn;
      if (expires_at) {
        expiresAt2 = parseInt(expires_at);
      }
      const actuallyExpiresIn = expiresAt2 - timeNow;
      if (actuallyExpiresIn * 1e3 <= AUTO_REFRESH_TICK_DURATION) {
        console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);
      }
      const issuedAt = expiresAt2 - expiresIn;
      if (timeNow - issuedAt >= 120) {
        console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", issuedAt, expiresAt2, timeNow);
      } else if (timeNow - issuedAt < 0) {
        console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", issuedAt, expiresAt2, timeNow);
      }
      const { data, error } = await this._getUser(access_token);
      if (error)
        throw error;
      const session = {
        provider_token,
        provider_refresh_token,
        access_token,
        expires_in: expiresIn,
        expires_at: expiresAt2,
        refresh_token,
        token_type,
        user: data.user
      };
      window.location.hash = "";
      this._debug("#_getSessionFromURL()", "clearing window.location.hash");
      return { data: { session, redirectType: params.type }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { session: null, redirectType: null }, error };
      }
      throw error;
    }
  }
  /**
   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
   */
  _isImplicitGrantCallback(params) {
    return Boolean(params.access_token || params.error_description);
  }
  /**
   * Checks if the current URL and backing storage contain parameters given by a PKCE flow
   */
  async _isPKCECallback(params) {
    const currentStorageContent = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    return !!(params.code && currentStorageContent);
  }
  /**
   * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
   *
   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
   *
   * If using `others` scope, no `SIGNED_OUT` event is fired!
   */
  async signOut(options = { scope: "global" }) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._signOut(options);
    });
  }
  async _signOut({ scope } = { scope: "global" }) {
    return await this._useSession(async (result) => {
      var _a2;
      const { data, error: sessionError } = result;
      if (sessionError) {
        return { error: sessionError };
      }
      const accessToken = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token;
      if (accessToken) {
        const { error } = await this.admin.signOut(accessToken, scope);
        if (error) {
          if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401 || error.status === 403))) {
            return { error };
          }
        }
      }
      if (scope !== "others") {
        await this._removeSession();
        await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      }
      return { error: null };
    });
  }
  /**
   * Receive a notification every time an auth event happens.
   * @param callback A callback function to be invoked when an auth event happens.
   */
  onAuthStateChange(callback) {
    const id = uuid();
    const subscription = {
      id,
      callback,
      unsubscribe: () => {
        this._debug("#unsubscribe()", "state change callback with id removed", id);
        this.stateChangeEmitters.delete(id);
      }
    };
    this._debug("#onAuthStateChange()", "registered callback with id", id);
    this.stateChangeEmitters.set(id, subscription);
    (async () => {
      await this.initializePromise;
      await this._acquireLock(-1, async () => {
        this._emitInitialSession(id);
      });
    })();
    return { data: { subscription } };
  }
  async _emitInitialSession(id) {
    return await this._useSession(async (result) => {
      var _a2, _b;
      try {
        const { data: { session }, error } = result;
        if (error)
          throw error;
        await ((_a2 = this.stateChangeEmitters.get(id)) === null || _a2 === void 0 ? void 0 : _a2.callback("INITIAL_SESSION", session));
        this._debug("INITIAL_SESSION", "callback id", id, "session", session);
      } catch (err) {
        await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback("INITIAL_SESSION", null));
        this._debug("INITIAL_SESSION", "callback id", id, "error", err);
        console.error(err);
      }
    });
  }
  /**
   * Sends a password reset request to an email address. This method supports the PKCE flow.
   *
   * @param email The email address of the user.
   * @param options.redirectTo The URL to send the user to after they click the password reset link.
   * @param options.captchaToken Verification token received when the user completes the captcha on the site.
   */
  async resetPasswordForEmail(email, options = {}) {
    let codeChallenge = null;
    let codeChallengeMethod = null;
    if (this.flowType === "pkce") {
      ;
      [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(
        this.storage,
        this.storageKey,
        true
        // isPasswordRecovery
      );
    }
    try {
      return await _request(this.fetch, "POST", `${this.url}/recover`, {
        body: {
          email,
          code_challenge: codeChallenge,
          code_challenge_method: codeChallengeMethod,
          gotrue_meta_security: { captcha_token: options.captchaToken }
        },
        headers: this.headers,
        redirectTo: options.redirectTo
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Gets all the identities linked to a user.
   */
  async getUserIdentities() {
    var _a2;
    try {
      const { data, error } = await this.getUser();
      if (error)
        throw error;
      return { data: { identities: (_a2 = data.user.identities) !== null && _a2 !== void 0 ? _a2 : [] }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Links an oauth identity to an existing user.
   * This method supports the PKCE flow.
   */
  async linkIdentity(credentials) {
    var _a2;
    try {
      const { data, error } = await this._useSession(async (result) => {
        var _a3, _b, _c, _d, _e;
        const { data: data2, error: error2 } = result;
        if (error2)
          throw error2;
        const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {
          redirectTo: (_a3 = credentials.options) === null || _a3 === void 0 ? void 0 : _a3.redirectTo,
          scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
          queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
          skipBrowserRedirect: true
        });
        return await _request(this.fetch, "GET", url, {
          headers: this.headers,
          jwt: (_e = (_d = data2.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : void 0
        });
      });
      if (error)
        throw error;
      if (isBrowser() && !((_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.skipBrowserRedirect)) {
        window.location.assign(data === null || data === void 0 ? void 0 : data.url);
      }
      return { data: { provider: credentials.provider, url: data === null || data === void 0 ? void 0 : data.url }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { provider: credentials.provider, url: null }, error };
      }
      throw error;
    }
  }
  /**
   * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.
   */
  async unlinkIdentity(identity) {
    try {
      return await this._useSession(async (result) => {
        var _a2, _b;
        const { data, error } = result;
        if (error) {
          throw error;
        }
        return await _request(this.fetch, "DELETE", `${this.url}/user/identities/${identity.identity_id}`, {
          headers: this.headers,
          jwt: (_b = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b !== void 0 ? _b : void 0
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Generates a new JWT.
   * @param refreshToken A valid refresh token that was returned on login.
   */
  async _refreshAccessToken(refreshToken) {
    const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, "begin");
    try {
      const startedAt = Date.now();
      return await retryable(async (attempt) => {
        if (attempt > 0) {
          await sleep(200 * Math.pow(2, attempt - 1));
        }
        this._debug(debugName, "refreshing attempt", attempt);
        return await _request(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
          body: { refresh_token: refreshToken },
          headers: this.headers,
          xform: _sessionResponse
        });
      }, (attempt, error) => {
        const nextBackOffInterval = 200 * Math.pow(2, attempt);
        return error && isAuthRetryableFetchError(error) && // retryable only if the request can be sent before the backoff overflows the tick duration
        Date.now() + nextBackOffInterval - startedAt < AUTO_REFRESH_TICK_DURATION;
      });
    } catch (error) {
      this._debug(debugName, "error", error);
      if (isAuthError(error)) {
        return { data: { session: null, user: null }, error };
      }
      throw error;
    } finally {
      this._debug(debugName, "end");
    }
  }
  _isValidSession(maybeSession) {
    const isValidSession = typeof maybeSession === "object" && maybeSession !== null && "access_token" in maybeSession && "refresh_token" in maybeSession && "expires_at" in maybeSession;
    return isValidSession;
  }
  async _handleProviderSignIn(provider, options) {
    const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {
      redirectTo: options.redirectTo,
      scopes: options.scopes,
      queryParams: options.queryParams
    });
    this._debug("#_handleProviderSignIn()", "provider", provider, "options", options, "url", url);
    if (isBrowser() && !options.skipBrowserRedirect) {
      window.location.assign(url);
    }
    return { data: { provider, url }, error: null };
  }
  /**
   * Recovers the session from LocalStorage and refreshes the token
   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
   */
  async _recoverAndRefresh() {
    var _a2;
    const debugName = "#_recoverAndRefresh()";
    this._debug(debugName, "begin");
    try {
      const currentSession = await getItemAsync(this.storage, this.storageKey);
      this._debug(debugName, "session from storage", currentSession);
      if (!this._isValidSession(currentSession)) {
        this._debug(debugName, "session is not valid");
        if (currentSession !== null) {
          await this._removeSession();
        }
        return;
      }
      const timeNow = Math.round(Date.now() / 1e3);
      const expiresWithMargin = ((_a2 = currentSession.expires_at) !== null && _a2 !== void 0 ? _a2 : Infinity) < timeNow + EXPIRY_MARGIN;
      this._debug(debugName, `session has${expiresWithMargin ? "" : " not"} expired with margin of ${EXPIRY_MARGIN}s`);
      if (expiresWithMargin) {
        if (this.autoRefreshToken && currentSession.refresh_token) {
          const { error } = await this._callRefreshToken(currentSession.refresh_token);
          if (error) {
            console.error(error);
            if (!isAuthRetryableFetchError(error)) {
              this._debug(debugName, "refresh failed with a non-retryable error, removing the session", error);
              await this._removeSession();
            }
          }
        }
      } else {
        await this._notifyAllSubscribers("SIGNED_IN", currentSession);
      }
    } catch (err) {
      this._debug(debugName, "error", err);
      console.error(err);
      return;
    } finally {
      this._debug(debugName, "end");
    }
  }
  async _callRefreshToken(refreshToken) {
    var _a2, _b;
    if (!refreshToken) {
      throw new AuthSessionMissingError();
    }
    if (this.refreshingDeferred) {
      return this.refreshingDeferred.promise;
    }
    const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, "begin");
    try {
      this.refreshingDeferred = new Deferred();
      const { data, error } = await this._refreshAccessToken(refreshToken);
      if (error)
        throw error;
      if (!data.session)
        throw new AuthSessionMissingError();
      await this._saveSession(data.session);
      await this._notifyAllSubscribers("TOKEN_REFRESHED", data.session);
      const result = { session: data.session, error: null };
      this.refreshingDeferred.resolve(result);
      return result;
    } catch (error) {
      this._debug(debugName, "error", error);
      if (isAuthError(error)) {
        const result = { session: null, error };
        if (!isAuthRetryableFetchError(error)) {
          await this._removeSession();
        }
        (_a2 = this.refreshingDeferred) === null || _a2 === void 0 ? void 0 : _a2.resolve(result);
        return result;
      }
      (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);
      throw error;
    } finally {
      this.refreshingDeferred = null;
      this._debug(debugName, "end");
    }
  }
  async _notifyAllSubscribers(event, session, broadcast = true) {
    const debugName = `#_notifyAllSubscribers(${event})`;
    this._debug(debugName, "begin", session, `broadcast = ${broadcast}`);
    try {
      if (this.broadcastChannel && broadcast) {
        this.broadcastChannel.postMessage({ event, session });
      }
      const errors = [];
      const promises = Array.from(this.stateChangeEmitters.values()).map(async (x) => {
        try {
          await x.callback(event, session);
        } catch (e) {
          errors.push(e);
        }
      });
      await Promise.all(promises);
      if (errors.length > 0) {
        for (let i = 0; i < errors.length; i += 1) {
          console.error(errors[i]);
        }
        throw errors[0];
      }
    } finally {
      this._debug(debugName, "end");
    }
  }
  /**
   * set currentSession and currentUser
   * process to _startAutoRefreshToken if possible
   */
  async _saveSession(session) {
    this._debug("#_saveSession()", session);
    this.suppressGetSessionWarning = true;
    await setItemAsync(this.storage, this.storageKey, session);
  }
  async _removeSession() {
    this._debug("#_removeSession()");
    await removeItemAsync(this.storage, this.storageKey);
    await this._notifyAllSubscribers("SIGNED_OUT", null);
  }
  /**
   * Removes any registered visibilitychange callback.
   *
   * {@see #startAutoRefresh}
   * {@see #stopAutoRefresh}
   */
  _removeVisibilityChangedCallback() {
    this._debug("#_removeVisibilityChangedCallback()");
    const callback = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {
        window.removeEventListener("visibilitychange", callback);
      }
    } catch (e) {
      console.error("removing visibilitychange callback failed", e);
    }
  }
  /**
   * This is the private implementation of {@link #startAutoRefresh}. Use this
   * within the library.
   */
  async _startAutoRefresh() {
    await this._stopAutoRefresh();
    this._debug("#_startAutoRefresh()");
    const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION);
    this.autoRefreshTicker = ticker;
    if (ticker && typeof ticker === "object" && typeof ticker.unref === "function") {
      ticker.unref();
    } else if (typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function") {
      Deno.unrefTimer(ticker);
    }
    setTimeout(async () => {
      await this.initializePromise;
      await this._autoRefreshTokenTick();
    }, 0);
  }
  /**
   * This is the private implementation of {@link #stopAutoRefresh}. Use this
   * within the library.
   */
  async _stopAutoRefresh() {
    this._debug("#_stopAutoRefresh()");
    const ticker = this.autoRefreshTicker;
    this.autoRefreshTicker = null;
    if (ticker) {
      clearInterval(ticker);
    }
  }
  /**
   * Starts an auto-refresh process in the background. The session is checked
   * every few seconds. Close to the time of expiration a process is started to
   * refresh the session. If refreshing fails it will be retried for as long as
   * necessary.
   *
   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
   * to call this function, it will be called for you.
   *
   * On browsers the refresh process works only when the tab/window is in the
   * foreground to conserve resources as well as prevent race conditions and
   * flooding auth with requests. If you call this method any managed
   * visibility change callback will be removed and you must manage visibility
   * changes on your own.
   *
   * On non-browser platforms the refresh process works *continuously* in the
   * background, which may not be desirable. You should hook into your
   * platform's foreground indication mechanism and call these methods
   * appropriately to conserve resources.
   *
   * {@see #stopAutoRefresh}
   */
  async startAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._startAutoRefresh();
  }
  /**
   * Stops an active auto refresh process running in the background (if any).
   *
   * If you call this method any managed visibility change callback will be
   * removed and you must manage visibility changes on your own.
   *
   * See {@link #startAutoRefresh} for more details.
   */
  async stopAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._stopAutoRefresh();
  }
  /**
   * Runs the auto refresh token tick.
   */
  async _autoRefreshTokenTick() {
    this._debug("#_autoRefreshTokenTick()", "begin");
    try {
      await this._acquireLock(0, async () => {
        try {
          const now = Date.now();
          try {
            return await this._useSession(async (result) => {
              const { data: { session } } = result;
              if (!session || !session.refresh_token || !session.expires_at) {
                this._debug("#_autoRefreshTokenTick()", "no session");
                return;
              }
              const expiresInTicks = Math.floor((session.expires_at * 1e3 - now) / AUTO_REFRESH_TICK_DURATION);
              this._debug("#_autoRefreshTokenTick()", `access token expires in ${expiresInTicks} ticks, a tick lasts ${AUTO_REFRESH_TICK_DURATION}ms, refresh threshold is ${AUTO_REFRESH_TICK_THRESHOLD} ticks`);
              if (expiresInTicks <= AUTO_REFRESH_TICK_THRESHOLD) {
                await this._callRefreshToken(session.refresh_token);
              }
            });
          } catch (e) {
            console.error("Auto refresh tick failed with error. This is likely a transient error.", e);
          }
        } finally {
          this._debug("#_autoRefreshTokenTick()", "end");
        }
      });
    } catch (e) {
      if (e.isAcquireTimeout || e instanceof LockAcquireTimeoutError) {
        this._debug("auto refresh token tick lock not available");
      } else {
        throw e;
      }
    }
  }
  /**
   * Registers callbacks on the browser / platform, which in-turn run
   * algorithms when the browser window/tab are in foreground. On non-browser
   * platforms it assumes always foreground.
   */
  async _handleVisibilityChange() {
    this._debug("#_handleVisibilityChange()");
    if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
      if (this.autoRefreshToken) {
        this.startAutoRefresh();
      }
      return false;
    }
    try {
      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false);
      window === null || window === void 0 ? void 0 : window.addEventListener("visibilitychange", this.visibilityChangedCallback);
      await this._onVisibilityChanged(true);
    } catch (error) {
      console.error("_handleVisibilityChange", error);
    }
  }
  /**
   * Callback registered with `window.addEventListener('visibilitychange')`.
   */
  async _onVisibilityChanged(calledFromInitialize) {
    const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
    this._debug(methodName, "visibilityState", document.visibilityState);
    if (document.visibilityState === "visible") {
      if (this.autoRefreshToken) {
        this._startAutoRefresh();
      }
      if (!calledFromInitialize) {
        await this.initializePromise;
        await this._acquireLock(-1, async () => {
          if (document.visibilityState !== "visible") {
            this._debug(methodName, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
            return;
          }
          await this._recoverAndRefresh();
        });
      }
    } else if (document.visibilityState === "hidden") {
      if (this.autoRefreshToken) {
        this._stopAutoRefresh();
      }
    }
  }
  /**
   * Generates the relevant login URL for a third-party provider.
   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
   * @param options.scopes A space-separated list of scopes granted to the OAuth application.
   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
   */
  async _getUrlForProvider(url, provider, options) {
    const urlParams = [`provider=${encodeURIComponent(provider)}`];
    if (options === null || options === void 0 ? void 0 : options.redirectTo) {
      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
    }
    if (options === null || options === void 0 ? void 0 : options.scopes) {
      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
    }
    if (this.flowType === "pkce") {
      const [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
      const flowParams = new URLSearchParams({
        code_challenge: `${encodeURIComponent(codeChallenge)}`,
        code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`
      });
      urlParams.push(flowParams.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.queryParams) {
      const query = new URLSearchParams(options.queryParams);
      urlParams.push(query.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {
      urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);
    }
    return `${url}?${urlParams.join("&")}`;
  }
  async _unenroll(params) {
    try {
      return await this._useSession(async (result) => {
        var _a2;
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          return { data: null, error: sessionError };
        }
        return await _request(this.fetch, "DELETE", `${this.url}/factors/${params.factorId}`, {
          headers: this.headers,
          jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  async _enroll(params) {
    try {
      return await this._useSession(async (result) => {
        var _a2, _b;
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          return { data: null, error: sessionError };
        }
        const body = Object.assign({ friendly_name: params.friendlyName, factor_type: params.factorType }, params.factorType === "phone" ? { phone: params.phone } : { issuer: params.issuer });
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/factors`, {
          body,
          headers: this.headers,
          jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
        });
        if (error) {
          return { data: null, error };
        }
        if (params.factorType === "totp" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {
          data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;
        }
        return { data, error: null };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * {@see GoTrueMFAApi#verify}
   */
  async _verify(params) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (result) => {
          var _a2;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return { data: null, error: sessionError };
          }
          const { data, error } = await _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/verify`, {
            body: { code: params.code, challenge_id: params.challengeId },
            headers: this.headers,
            jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
          });
          if (error) {
            return { data: null, error };
          }
          await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + data.expires_in }, data));
          await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", data);
          return { data, error };
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challenge}
   */
  async _challenge(params) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (result) => {
          var _a2;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return { data: null, error: sessionError };
          }
          return await _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/challenge`, {
            body: { channel: params.channel },
            headers: this.headers,
            jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
          });
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challengeAndVerify}
   */
  async _challengeAndVerify(params) {
    const { data: challengeData, error: challengeError } = await this._challenge({
      factorId: params.factorId
    });
    if (challengeError) {
      return { data: null, error: challengeError };
    }
    return await this._verify({
      factorId: params.factorId,
      challengeId: challengeData.id,
      code: params.code
    });
  }
  /**
   * {@see GoTrueMFAApi#listFactors}
   */
  async _listFactors() {
    const { data: { user }, error: userError } = await this.getUser();
    if (userError) {
      return { data: null, error: userError };
    }
    const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];
    const totp = factors.filter((factor) => factor.factor_type === "totp" && factor.status === "verified");
    const phone = factors.filter((factor) => factor.factor_type === "phone" && factor.status === "verified");
    return {
      data: {
        all: factors,
        totp,
        phone
      },
      error: null
    };
  }
  /**
   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
   */
  async _getAuthenticatorAssuranceLevel() {
    return this._acquireLock(-1, async () => {
      return await this._useSession(async (result) => {
        var _a2, _b;
        const { data: { session }, error: sessionError } = result;
        if (sessionError) {
          return { data: null, error: sessionError };
        }
        if (!session) {
          return {
            data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },
            error: null
          };
        }
        const payload = this._decodeJWT(session.access_token);
        let currentLevel = null;
        if (payload.aal) {
          currentLevel = payload.aal;
        }
        let nextLevel = currentLevel;
        const verifiedFactors = (_b = (_a2 = session.user.factors) === null || _a2 === void 0 ? void 0 : _a2.filter((factor) => factor.status === "verified")) !== null && _b !== void 0 ? _b : [];
        if (verifiedFactors.length > 0) {
          nextLevel = "aal2";
        }
        const currentAuthenticationMethods = payload.amr || [];
        return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };
      });
    });
  }
};
GoTrueClient.nextInstanceID = 0;

// node_modules/@supabase/auth-js/dist/module/AuthClient.js
var AuthClient = GoTrueClient;
var AuthClient_default = AuthClient;

// node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js
var SupabaseAuthClient = class extends AuthClient_default {
  constructor(options) {
    super(options);
  }
};

// node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SupabaseClient = class {
  /**
   * Create a new client for use in the browser.
   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
   * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
   * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
   * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
   * @param options.realtime Options passed along to realtime-js constructor.
   * @param options.global.fetch A custom fetch implementation.
   * @param options.global.headers Any additional headers to send with each network request.
   */
  constructor(supabaseUrl, supabaseKey, options) {
    var _a2, _b, _c;
    this.supabaseUrl = supabaseUrl;
    this.supabaseKey = supabaseKey;
    if (!supabaseUrl)
      throw new Error("supabaseUrl is required.");
    if (!supabaseKey)
      throw new Error("supabaseKey is required.");
    const _supabaseUrl = stripTrailingSlash(supabaseUrl);
    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, "ws");
    this.authUrl = `${_supabaseUrl}/auth/v1`;
    this.storageUrl = `${_supabaseUrl}/storage/v1`;
    this.functionsUrl = `${_supabaseUrl}/functions/v1`;
    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split(".")[0]}-auth-token`;
    const DEFAULTS = {
      db: DEFAULT_DB_OPTIONS,
      realtime: DEFAULT_REALTIME_OPTIONS,
      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), { storageKey: defaultStorageKey }),
      global: DEFAULT_GLOBAL_OPTIONS
    };
    const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);
    this.storageKey = (_a2 = settings.auth.storageKey) !== null && _a2 !== void 0 ? _a2 : "";
    this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};
    if (!settings.accessToken) {
      this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);
    } else {
      this.accessToken = settings.accessToken;
      this.auth = new Proxy({}, {
        get: (_, prop) => {
          throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);
        }
      });
    }
    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);
    this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers, accessToken: this._getAccessToken.bind(this) }, settings.realtime));
    this.rest = new PostgrestClient(`${_supabaseUrl}/rest/v1`, {
      headers: this.headers,
      schema: settings.db.schema,
      fetch: this.fetch
    });
    if (!settings.accessToken) {
      this._listenForAuthEvents();
    }
  }
  /**
   * Supabase Functions allows you to deploy and invoke edge functions.
   */
  get functions() {
    return new FunctionsClient(this.functionsUrl, {
      headers: this.headers,
      customFetch: this.fetch
    });
  }
  /**
   * Supabase Storage allows you to manage user-generated content, such as photos or videos.
   */
  get storage() {
    return new StorageClient(this.storageUrl, this.headers, this.fetch);
  }
  /**
   * Perform a query on a table or a view.
   *
   * @param relation - The table or view name to query
   */
  from(relation) {
    return this.rest.from(relation);
  }
  // NOTE: signatures must be kept in sync with PostgrestClient.schema
  /**
   * Select a schema to query or perform an function (rpc) call.
   *
   * The schema needs to be on the list of exposed schemas inside Supabase.
   *
   * @param schema - The schema to query
   */
  schema(schema) {
    return this.rest.schema(schema);
  }
  // NOTE: signatures must be kept in sync with PostgrestClient.rpc
  /**
   * Perform a function call.
   *
   * @param fn - The function name to call
   * @param args - The arguments to pass to the function call
   * @param options - Named parameters
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   * @param options.get - When set to `true`, the function will be called with
   * read-only access mode.
   * @param options.count - Count algorithm to use to count rows returned by the
   * function. Only applicable for [set-returning
   * functions](https://www.postgresql.org/docs/current/functions-srf.html).
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  rpc(fn, args = {}, options = {}) {
    return this.rest.rpc(fn, args, options);
  }
  /**
   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
   *
   * @param {string} name - The name of the Realtime channel.
   * @param {Object} opts - The options to pass to the Realtime channel.
   *
   */
  channel(name, opts = { config: {} }) {
    return this.realtime.channel(name, opts);
  }
  /**
   * Returns all Realtime channels.
   */
  getChannels() {
    return this.realtime.getChannels();
  }
  /**
   * Unsubscribes and removes Realtime channel from Realtime client.
   *
   * @param {RealtimeChannel} channel - The name of the Realtime channel.
   *
   */
  removeChannel(channel) {
    return this.realtime.removeChannel(channel);
  }
  /**
   * Unsubscribes and removes all Realtime channels from Realtime client.
   */
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  _getAccessToken() {
    var _a2, _b;
    return __awaiter8(this, void 0, void 0, function* () {
      if (this.accessToken) {
        return yield this.accessToken();
      }
      const { data } = yield this.auth.getSession();
      return (_b = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b !== void 0 ? _b : null;
    });
  }
  _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, storageKey, flowType, lock, debug: debug2 }, headers, fetch4) {
    const authHeaders = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`
    };
    return new SupabaseAuthClient({
      url: this.authUrl,
      headers: Object.assign(Object.assign({}, authHeaders), headers),
      storageKey,
      autoRefreshToken,
      persistSession,
      detectSessionInUrl,
      storage,
      flowType,
      lock,
      debug: debug2,
      fetch: fetch4,
      // auth checks if there is a custom authorizaiton header using this flag
      // so it knows whether to return an error when getUser is called with no session
      hasCustomAuthorizationHeader: "Authorization" in this.headers
    });
  }
  _initRealtimeClient(options) {
    return new RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), { params: Object.assign({ apikey: this.supabaseKey }, options === null || options === void 0 ? void 0 : options.params) }));
  }
  _listenForAuthEvents() {
    let data = this.auth.onAuthStateChange((event, session) => {
      this._handleTokenChanged(event, "CLIENT", session === null || session === void 0 ? void 0 : session.access_token);
    });
    return data;
  }
  _handleTokenChanged(event, source, token) {
    if ((event === "TOKEN_REFRESHED" || event === "SIGNED_IN") && this.changedAccessToken !== token) {
      this.changedAccessToken = token;
    } else if (event === "SIGNED_OUT") {
      this.realtime.setAuth();
      if (source == "STORAGE")
        this.auth.signOut();
      this.changedAccessToken = void 0;
    }
  }
};

// node_modules/@supabase/supabase-js/dist/module/index.js
var createClient = (supabaseUrl, supabaseKey, options) => {
  return new SupabaseClient(supabaseUrl, supabaseKey, options);
};

// settings/Settings.ts
var DEFAULT_CHUNKING_OPTIONS = {
  chunkSize: 1e3,
  // Default size of each chunk in characters
  chunkOverlap: 200,
  // Default overlap between chunks
  minChunkSize: 100
  // Minimum chunk size to ensure usability
};
var DEFAULT_UPDATE_BEHAVIOR = {
  debounceTime: 1e3,
  // 1 second debounce delay by default
  processingMode: "instant",
  // Process updates instantly by default
  priorityOverride: 1
  // Default priority level for update operations
};
function generateDeviceId() {
  return crypto.randomUUID();
}
var SYSTEM_EXCLUSIONS = {
  folders: [
    ".obsidian",
    // Obsidian config folder
    ".trash",
    // Obsidian trash folder
    ".git",
    // Git folder if used
    "node_modules"
    // Node modules if used
  ],
  fileTypes: [
    ".mp3",
    ".jpg",
    ".png",
    ".pdf",
    // Non-markdown files
    ".excalidraw"
    // Excalidraw files
  ],
  filePrefixes: ["_", "."],
  // Hidden and special files
  files: [
    "_mindmatrixsync.md",
    // Sync file
    "_mindmatrixsync.md.backup"
    // Sync backup file
  ]
};
var DEFAULT_SETTINGS = {
  vaultId: null,
  lastKnownVaultName: "",
  supabase: {
    url: "",
    apiKey: "",
    initialized: false,
    lastSetupAttempt: 0,
    setupRetries: 0
  },
  openai: {
    apiKey: "",
    model: "text-embedding-ada-002",
    maxTokens: 8e3,
    temperature: 0
  },
  chunking: { ...DEFAULT_CHUNKING_OPTIONS },
  queue: {
    maxConcurrent: 3,
    retryAttempts: 3,
    retryDelay: 1e3
  },
  exclusions: {
    excludedFolders: [],
    excludedFileTypes: [],
    excludedFilePrefixes: [],
    excludedFiles: [],
    systemExcludedFolders: [...SYSTEM_EXCLUSIONS.folders],
    systemExcludedFileTypes: [...SYSTEM_EXCLUSIONS.fileTypes],
    systemExcludedFilePrefixes: [...SYSTEM_EXCLUSIONS.filePrefixes],
    systemExcludedFiles: [...SYSTEM_EXCLUSIONS.files]
  },
  debug: {
    enableDebugLogs: false,
    logLevel: "info",
    logToFile: false
  },
  enableAutoSync: true,
  enableNotifications: true,
  enableProgressBar: true,
  sync: {
    syncFilePath: "_mindmatrixsync.md",
    backupInterval: 36e5,
    // 1 hour in milliseconds
    checkInterval: 3e5,
    // 5 minutes in milliseconds
    checkAttempts: 3,
    timeout: 4e4,
    requireSync: true,
    deviceId: generateDeviceId(),
    deviceName: `Device-${Math.floor(Math.random() * 1e3)}`,
    knownDevices: [],
    connectionCheckInterval: 6e4,
    // 1 minute
    offlineQueueEnabled: true,
    conflictResolutionStrategy: "newest-wins"
  },
  initialSync: {
    batchSize: 50,
    maxConcurrentBatches: 3,
    enableAutoInitialSync: true,
    priorityRules: [
      { pattern: "daily/", priority: 3 },
      { pattern: "projects/", priority: 2 },
      { pattern: "archive/", priority: 1 }
    ]
  },
  updateBehavior: {
    ...DEFAULT_UPDATE_BEHAVIOR
  }
};
function getAllExclusions2(settings) {
  const exclusions = settings.exclusions;
  return {
    excludedFolders: [
      ...exclusions.systemExcludedFolders || SYSTEM_EXCLUSIONS.folders,
      ...exclusions.excludedFolders || []
    ],
    excludedFileTypes: [
      ...exclusions.systemExcludedFileTypes || SYSTEM_EXCLUSIONS.fileTypes,
      ...exclusions.excludedFileTypes || []
    ],
    excludedFilePrefixes: [
      ...exclusions.systemExcludedFilePrefixes || SYSTEM_EXCLUSIONS.filePrefixes,
      ...exclusions.excludedFilePrefixes || []
    ],
    excludedFiles: [
      ...exclusions.systemExcludedFiles || SYSTEM_EXCLUSIONS.files,
      ...exclusions.excludedFiles || []
    ]
  };
}
function getUserExclusions(settings) {
  const exclusions = settings.exclusions;
  return {
    excludedFolders: exclusions.excludedFolders || [],
    excludedFileTypes: exclusions.excludedFileTypes || [],
    excludedFilePrefixes: exclusions.excludedFilePrefixes || [],
    excludedFiles: exclusions.excludedFiles || []
  };
}
function isVaultInitialized2(settings) {
  return settings.vaultId !== null && settings.vaultId !== void 0 && settings.vaultId !== "";
}
function generateVaultId() {
  return crypto.randomUUID();
}

// services/SupabaseService.ts
var import_obsidian = require("obsidian");
var _SupabaseService = class {
  constructor(settings) {
    this.TABLE_NAME = "obsidian_documents";
    this.FILE_STATUS_TABLE = "obsidian_file_status";
    // Track deletion operations for a given file to avoid concurrent deletes
    this.deleteOperationsInProgress = /* @__PURE__ */ new Map();
    if (!settings.supabase.url || !settings.supabase.apiKey) {
      console.warn("Supabase configuration is incomplete. Supabase service will not be initialized.");
      this.client = null;
      return;
    }
    if (!isVaultInitialized2(settings)) {
      throw new Error("Vault is not initialized");
    }
    this.settings = settings;
    this.client = createClient(settings.supabase.url, settings.supabase.apiKey);
  }
  static async getInstance(settings) {
    if (!settings.supabase.url || !settings.supabase.apiKey) {
      console.warn("Supabase configuration is incomplete. Returning null.");
      return null;
    }
    if (!_SupabaseService.instance) {
      _SupabaseService.instance = new _SupabaseService(settings);
      await _SupabaseService.instance.initializeDatabase();
    } else if (_SupabaseService.instance.settings.supabase.url !== settings.supabase.url || _SupabaseService.instance.settings.supabase.apiKey !== settings.supabase.apiKey || _SupabaseService.instance.settings.vaultId !== settings.vaultId) {
      _SupabaseService.instance = new _SupabaseService(settings);
      await _SupabaseService.instance.initializeDatabase();
    }
    return _SupabaseService.instance;
  }
  async initializeDatabase() {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping database initialization.");
      return;
    }
    try {
      new import_obsidian.Notice("Checking database connection...");
      const { error: testError } = await this.client.from(this.TABLE_NAME).select("id").limit(1);
      if (testError && !testError.message.includes("does not exist")) {
        throw new Error(`Database connection failed: ${testError.message}`);
      }
      await this.initializeFileStatusTable();
      new import_obsidian.Notice("Database connection verified");
      this.settings.supabase.initialized = true;
    } catch (error) {
      console.error("Database initialization error:", error);
      new import_obsidian.Notice(`Database error: ${error.message}`);
      throw error;
    }
  }
  /**
   * Ensures that obsidian_file_status table exists.
   */
  async initializeFileStatusTable() {
    if (!this.client)
      return;
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.log("File status table missing. Please create it manually or run setup SQL.");
        new import_obsidian.Notice("Some database tables are missing. Plugin will work with limited functionality.", 5e3);
      } else {
        console.log("File status table exists and is accessible");
      }
    } catch (error) {
      console.error("Error initializing file status table:", error);
      throw new Error(`Failed to initialize file status table: ${error.message}`);
    }
  }
  /**
   * Inserts or updates document chunks in the obsidian_documents table using an atomic transaction.
   * Improvements:
   * - Transaction handling to ensure atomicity
   * - Verification of deletion success before insertion
   * - Proper error handling and retry logic
   * - Prevents concurrent deletions on the same file
   */
  async upsertChunks(chunks) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping upsertChunks.");
      return;
    }
    if (chunks.length === 0) {
      console.log("No chunks to upsert");
      return;
    }
    const obsidianId = chunks[0].metadata.obsidianId;
    if (this.deleteOperationsInProgress.get(obsidianId)) {
      console.warn(`Delete operation already in progress for ${obsidianId}. Queueing update.`);
      let retryCount = 0;
      const maxRetries = 5;
      const baseDelay = 500;
      while (this.deleteOperationsInProgress.get(obsidianId) && retryCount < maxRetries) {
        const delay = baseDelay * Math.pow(2, retryCount);
        await new Promise((resolve) => setTimeout(resolve, delay));
        retryCount++;
      }
      if (this.deleteOperationsInProgress.get(obsidianId)) {
        throw new Error(`Deletion operation timeout for ${obsidianId}`);
      }
    }
    this.deleteOperationsInProgress.set(obsidianId, true);
    try {
      const chunksToInsert = chunks.map((chunk) => ({
        vault_id: this.settings.vaultId,
        obsidian_id: chunk.metadata.obsidianId,
        chunk_index: chunk.chunkIndex,
        content: chunk.content,
        metadata: chunk.metadata,
        embedding: chunk.embedding,
        last_updated: new Date().toISOString(),
        vectorized_at: new Date().toISOString()
      }));
      const chunkCount = chunksToInsert.length;
      console.log(`Preparing to update ${chunkCount} chunks for file: ${obsidianId}`);
      const { error: deleteError, count: deletedCount } = await this.client.from(this.TABLE_NAME).delete().eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId).select("*", { head: true, count: "exact" });
      if (deleteError) {
        console.error("Error deleting existing chunks:", deleteError);
        throw deleteError;
      }
      console.log(`Successfully deleted ${deletedCount} existing chunks for ${obsidianId}`);
      const { data: remainingData, error: countError } = await this.client.from(this.TABLE_NAME).select("id", { count: "exact", head: true }).eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
      if (countError) {
        console.error("Error verifying deletion:", countError);
        throw countError;
      }
      const remainingCount = (remainingData == null ? void 0 : remainingData.length) || 0;
      if (remainingCount > 0) {
        console.warn(`Deletion verification failed: ${remainingCount} chunks still exist for ${obsidianId}`);
        const { error: retryError } = await this.client.from(this.TABLE_NAME).delete().eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
        if (retryError) {
          throw new Error(`Failed to clean up remaining chunks: ${retryError.message}`);
        }
      }
      const BATCH_SIZE = 50;
      const batches = [];
      for (let i = 0; i < chunksToInsert.length; i += BATCH_SIZE) {
        batches.push(chunksToInsert.slice(i, i + BATCH_SIZE));
      }
      console.log(`Inserting ${chunksToInsert.length} chunks in ${batches.length} batches`);
      for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        console.log(`Processing batch ${i + 1}/${batches.length} with ${batch.length} chunks`);
        const { error: insertError } = await this.client.from(this.TABLE_NAME).insert(batch);
        if (insertError) {
          console.error(`Error inserting batch ${i + 1}:`, insertError);
          await this.cleanupPartialInsert(obsidianId);
          throw insertError;
        }
      }
      const { data: insertedData, error: verifyError } = await this.client.from(this.TABLE_NAME).select("id", { count: "exact", head: true }).eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
      if (verifyError) {
        console.error("Error verifying insertion:", verifyError);
        throw verifyError;
      }
      const insertedCount = (insertedData == null ? void 0 : insertedData.length) || 0;
      if (insertedCount !== chunkCount) {
        console.warn(`Insertion verification: Expected ${chunkCount} chunks, found ${insertedCount}`);
      }
      await this.updateFileVectorizationStatus(chunks[0].metadata);
      console.log("Successfully updated chunks:", {
        numberOfChunks: chunks.length,
        vaultId: this.settings.vaultId,
        obsidianId
      });
    } catch (error) {
      console.error("Failed to upsert chunks:", error);
      throw error;
    } finally {
      this.deleteOperationsInProgress.set(obsidianId, false);
    }
  }
  /**
   * Cleans up partial inserts if an error occurs during batch insertion
   */
  async cleanupPartialInsert(obsidianId) {
    if (!this.client)
      return;
    try {
      console.log(`Cleaning up partial insert for ${obsidianId}`);
      const { error } = await this.client.from(this.TABLE_NAME).delete().eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
      if (error) {
        console.error("Error cleaning up partial insert:", error);
      } else {
        console.log(`Successfully cleaned up partial insert for ${obsidianId}`);
      }
    } catch (cleanupError) {
      console.error("Error during cleanup of partial insert:", cleanupError);
    }
  }
  /**
   * Bulk upsert method for file status records.
   * Improves performance for large vaults.
   */
  async bulkUpsertFileStatuses(statuses) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping bulkUpsertFileStatuses.");
      return;
    }
    try {
      if (statuses.length === 0)
        return;
      const { error } = await this.client.from(this.FILE_STATUS_TABLE).upsert(statuses, { onConflict: "vault_id,file_path" });
      if (error) {
        console.error("Error during bulk upsert of file statuses:", error);
        throw error;
      }
      console.log(`Bulk upsert of ${statuses.length} file statuses successful.`);
    } catch (error) {
      console.error("Failed to bulk upsert file statuses:", error);
      throw error;
    }
  }
  /**
   * Creates or updates a record in the obsidian_file_status table
   * to reflect the latest file status using provided metadata.
   */
  async updateFileVectorizationStatus(metadata) {
    var _a2, _b;
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping updateFileVectorizationStatus.");
      return;
    }
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Skipping status update.");
        return;
      }
      const fileStatus = {
        vault_id: this.settings.vaultId,
        file_path: metadata.obsidianId,
        last_modified: metadata.lastModified,
        last_vectorized: new Date().toISOString(),
        content_hash: ((_a2 = metadata.customMetadata) == null ? void 0 : _a2.contentHash) || "",
        status: "vectorized",
        // Mark as successfully vectorized
        tags: metadata.tags || [],
        aliases: ((_b = metadata.customMetadata) == null ? void 0 : _b.aliases) || [],
        links: metadata.links || [],
        updated_at: new Date().toISOString()
      };
      const { error } = await this.client.from(this.FILE_STATUS_TABLE).upsert(fileStatus, { onConflict: "vault_id,file_path" });
      if (error) {
        console.error("Error updating file vectorization status:", error);
        throw error;
      }
      console.log("File vectorization status updated:", metadata.obsidianId);
    } catch (error) {
      console.error("Failed to update file vectorization status:", error);
    }
  }
  /**
   * Marks a file as deleted in the obsidian_file_status table.
   */
  async updateFileStatusOnDelete(filePath) {
    if (!this.client)
      return;
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Skipping status update on delete.");
        return;
      }
      const { error } = await this.client.from(this.FILE_STATUS_TABLE).update({
        status: "deleted",
        updated_at: new Date().toISOString()
      }).eq("vault_id", this.settings.vaultId).eq("file_path", filePath);
      if (error) {
        console.error("Error updating file status on delete:", error);
        throw error;
      }
    } catch (error) {
      console.error("Failed to update file status on delete:", error);
    }
  }
  /**
   * Deletes document chunks for a given obsidianId from the obsidian_documents table.
   * Improved with tracking of operation progress and verification.
   */
  async deleteDocumentChunks(obsidianId) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping deleteDocumentChunks.");
      return;
    }
    if (this.deleteOperationsInProgress.get(obsidianId)) {
      console.warn(`Delete operation already in progress for ${obsidianId}. Waiting...`);
      await new Promise((resolve) => setTimeout(resolve, 500));
      if (this.deleteOperationsInProgress.get(obsidianId)) {
        console.log(`Still waiting for delete operation on ${obsidianId}...`);
        return;
      }
    }
    this.deleteOperationsInProgress.set(obsidianId, true);
    try {
      console.log(`Starting deletion of chunks for ${obsidianId}`);
      const { data: initialData, error: initialCountError } = await this.client.from(this.TABLE_NAME).select("id").eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
      if (initialCountError) {
        console.error("Error checking existing chunks:", initialCountError);
        throw initialCountError;
      }
      const initialCount = initialData ? initialData.length : 0;
      console.log(`Found ${initialCount} chunks to delete for ${obsidianId}`);
      if (initialCount === 0) {
        await this.purgeFileStatus(obsidianId);
        return;
      }
      const { error: deleteError } = await this.client.from(this.TABLE_NAME).delete().eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
      if (deleteError) {
        console.error("Error deleting chunks:", deleteError);
        throw deleteError;
      }
      await new Promise((resolve) => setTimeout(resolve, 500));
      const { data: remainingData, error: verifyError } = await this.client.from(this.TABLE_NAME).select("id").eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
      if (verifyError) {
        console.error("Error verifying deletion:", verifyError);
        throw verifyError;
      }
      const remainingCount = remainingData ? remainingData.length : 0;
      if (remainingCount > 0) {
        console.warn(`Deletion verification failed: ${remainingCount} chunks still exist for ${obsidianId}`);
        return;
      }
      await this.purgeFileStatus(obsidianId);
      console.log(`Successfully purged file status for ${obsidianId}`);
    } catch (error) {
      console.error("Failed to delete chunks:", error);
      throw error;
    } finally {
      this.deleteOperationsInProgress.set(obsidianId, false);
    }
  }
  /**
   * Retrieves document chunks for a given obsidianId.
   */
  async getDocumentChunks(obsidianId) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping getDocumentChunks.");
      return [];
    }
    try {
      const { data, error } = await this.client.from(this.TABLE_NAME).select("*").eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId).order("chunk_index");
      if (error)
        throw error;
      return data.map((row) => ({
        content: row.content,
        chunkIndex: row.chunk_index,
        metadata: row.metadata,
        embedding: row.embedding,
        vectorized_at: row.vectorized_at
      }));
    } catch (error) {
      console.error("Failed to get chunks:", error);
      throw error;
    }
  }
  /**
   * Checks if a file has been vectorized based on the obsidian_file_status table.
   */
  async isFileVectorized(filePath) {
    if (!this.client)
      return false;
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Assuming file is not vectorized.");
        return false;
      }
      const { data, error } = await this.client.from(this.FILE_STATUS_TABLE).select("status, last_vectorized").eq("vault_id", this.settings.vaultId).eq("file_path", filePath).single();
      if (error) {
        if (error.code === "PGRST116") {
          return false;
        }
        throw error;
      }
      return data && data.status === "vectorized" && !!data.last_vectorized;
    } catch (error) {
      console.error("Failed to check if file is vectorized:", error);
      return false;
    }
  }
  /**
   * Retrieves the vectorization status of a file from the database.
   */
  async getFileVectorizationStatus(filePath) {
    if (!this.client) {
      return {
        isVectorized: false,
        lastModified: 0,
        lastVectorized: null,
        contentHash: null,
        status: null
      };
    }
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Returning default status.");
        return {
          isVectorized: false,
          lastModified: 0,
          lastVectorized: null,
          contentHash: null,
          status: null
        };
      }
      const { data, error } = await this.client.from(this.FILE_STATUS_TABLE).select("*").eq("vault_id", this.settings.vaultId).eq("file_path", filePath).single();
      if (error) {
        if (error.code === "PGRST116") {
          return {
            isVectorized: false,
            lastModified: 0,
            lastVectorized: null,
            contentHash: null,
            status: null
          };
        }
        throw error;
      }
      return {
        isVectorized: data.status === "vectorized",
        lastModified: data.last_modified,
        lastVectorized: data.last_vectorized,
        contentHash: data.content_hash,
        status: data.status
      };
    } catch (error) {
      console.error("Failed to get file vectorization status:", error);
      return {
        isVectorized: false,
        lastModified: 0,
        lastVectorized: null,
        contentHash: null,
        status: null
      };
    }
  }
  /**
   * Determines if a file needs vectorizing based on last_modified and content_hash.
   */
  async needsVectorizing(filePath, lastModified, contentHash) {
    if (!this.client)
      return true;
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Assuming file needs vectorizing.");
        return true;
      }
      const status = await this.getFileVectorizationStatus(filePath);
      if (!status.status) {
        return true;
      }
      if (status.contentHash !== contentHash) {
        return true;
      }
      if (lastModified > status.lastModified) {
        return true;
      }
      return false;
    } catch (error) {
      console.error("Failed to check if file needs vectorizing:", error);
      return true;
    }
  }
  /**
   * Retrieves all files that do not have a status of 'vectorized' in the database.
   */
  async getFilesNeedingVectorization() {
    if (!this.client)
      return [];
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Unable to determine files needing vectorization.");
        return [];
      }
      const { data, error } = await this.client.from(this.FILE_STATUS_TABLE).select("file_path").eq("vault_id", this.settings.vaultId).not("status", "eq", "vectorized");
      if (error)
        throw error;
      return data.map((row) => row.file_path);
    } catch (error) {
      console.error("Failed to get files needing vectorization:", error);
      return [];
    }
  }
  /**
   * Performs a semantic search using the match_documents function.
   */
  async semanticSearch(embedding, limit2 = 5) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping semanticSearch.");
      return [];
    }
    try {
      const { data, error } = await this.client.rpc("match_documents", {
        query_embedding: embedding,
        search_vault_id: this.settings.vaultId,
        match_count: limit2
      });
      if (error)
        throw error;
      return data.map((row) => ({
        content: row.content,
        metadata: row.metadata,
        similarity: row.similarity
      }));
    } catch (error) {
      console.error("Failed to perform semantic search:", error);
      throw error;
    }
  }
  /**
   * Tests the connection by selecting from the obsidian_documents table.
   */
  async testConnection() {
    if (!this.client)
      return false;
    try {
      const { error } = await this.client.from(this.TABLE_NAME).select("id").limit(1);
      if (error && error.message && error.message.includes("does not exist")) {
        return true;
      }
      return !error;
    } catch (e) {
      return false;
    }
  }
  /**
   * Returns all unique obsidian_ids from the obsidian_documents table for the current vault.
   */
  async getAllDocumentIds() {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping getAllDocumentIds.");
      return [];
    }
    try {
      const { data, error } = await this.client.from(this.TABLE_NAME).select("obsidian_id").eq("vault_id", this.settings.vaultId).distinct();
      if (error) {
        if (error.message.includes("does not exist")) {
          return [];
        }
        throw error;
      }
      return data.map((row) => row.obsidian_id);
    } catch (error) {
      console.error("Failed to get document IDs:", error);
      throw error;
    }
  }
  /**
   * Creates the required database tables if needed (manual invocation).
   */
  async createRequiredTables() {
    if (!this.client) {
      return {
        success: false,
        message: "Supabase client not initialized"
      };
    }
    try {
      const createFileStatusTableSQL = `
				CREATE TABLE IF NOT EXISTS ${this.FILE_STATUS_TABLE} (
					id BIGSERIAL PRIMARY KEY,
					vault_id TEXT NOT NULL,
					file_path TEXT NOT NULL,
					last_modified BIGINT NOT NULL,
					last_vectorized TIMESTAMPTZ,
					content_hash TEXT,
					status TEXT,
					tags TEXT[],
					aliases TEXT[],
					links TEXT[],
					created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
					updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
					UNIQUE(vault_id, file_path)
				);
				CREATE INDEX IF NOT EXISTS idx_file_status_vault_path ON ${this.FILE_STATUS_TABLE}(vault_id, file_path);
			`;
      const { error } = await this.client.rpc("run_sql", { sql: createFileStatusTableSQL });
      if (error) {
        return { success: false, message: `Could not create tables: ${error.message}` };
      }
      return { success: true, message: "Tables created successfully" };
    } catch (error) {
      return { success: false, message: `Error creating tables: ${error.message}` };
    }
  }
  async updateFilePath(oldPath, newPath) {
    if (!this.client)
      return;
    try {
      const { error } = await this.client.from(this.FILE_STATUS_TABLE).update({ file_path: newPath, updated_at: new Date().toISOString() }).eq("vault_id", this.settings.vaultId).eq("file_path", oldPath);
      if (error) {
        throw error;
      }
      console.log(`File path updated from ${oldPath} to ${newPath}`);
    } catch (error) {
      console.error("Error updating file path:", error);
      throw error;
    }
  }
  async purgeFileStatus(filePath) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping purgeFileStatus.");
      return;
    }
    try {
      const { error } = await this.client.from(this.FILE_STATUS_TABLE).delete().eq("vault_id", this.settings.vaultId).eq("file_path", filePath);
      if (error) {
        console.error("Error purging file status:", error);
        throw error;
      }
      console.log(`Purged file status record for ${filePath}`);
    } catch (error) {
      console.error("Failed to purge file status record:", error);
      throw error;
    }
  }
};
var SupabaseService = _SupabaseService;
SupabaseService.instance = null;

// node_modules/openai/internal/qs/formats.mjs
var default_format = "RFC3986";
var formatters = {
  RFC1738: (v) => String(v).replace(/%20/g, "+"),
  RFC3986: (v) => String(v)
};
var RFC1738 = "RFC1738";

// node_modules/openai/internal/qs/utils.mjs
var is_array = Array.isArray;
var hex_table = (() => {
  const array = [];
  for (let i = 0; i < 256; ++i) {
    array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array;
})();
var limit = 1024;
var encode = (str2, _defaultEncoder, charset, _kind, format) => {
  if (str2.length === 0) {
    return str2;
  }
  let string = str2;
  if (typeof str2 === "symbol") {
    string = Symbol.prototype.toString.call(str2);
  } else if (typeof str2 !== "string") {
    string = String(str2);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  let out = "";
  for (let j = 0; j < string.length; j += limit) {
    const segment = string.length >= limit ? string.slice(j, j + limit) : string;
    const arr = [];
    for (let i = 0; i < segment.length; ++i) {
      let c = segment.charCodeAt(i);
      if (c === 45 || // -
      c === 46 || // .
      c === 95 || // _
      c === 126 || // ~
      c >= 48 && c <= 57 || // 0-9
      c >= 65 && c <= 90 || // a-z
      c >= 97 && c <= 122 || // A-Z
      format === RFC1738 && (c === 40 || c === 41)) {
        arr[arr.length] = segment.charAt(i);
        continue;
      }
      if (c < 128) {
        arr[arr.length] = hex_table[c];
        continue;
      }
      if (c < 2048) {
        arr[arr.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        arr[arr.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
      arr[arr.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
    }
    out += arr.join("");
  }
  return out;
};
function is_buffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn) {
  if (is_array(val)) {
    const mapped = [];
    for (let i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
}

// node_modules/openai/internal/qs/stringify.mjs
var has = Object.prototype.hasOwnProperty;
var array_prefix_generators = {
  brackets(prefix) {
    return String(prefix) + "[]";
  },
  comma: "comma",
  indices(prefix, key) {
    return String(prefix) + "[" + key + "]";
  },
  repeat(prefix) {
    return String(prefix);
  }
};
var is_array2 = Array.isArray;
var push = Array.prototype.push;
var push_to_array = function(arr, value_or_array) {
  push.apply(arr, is_array2(value_or_array) ? value_or_array : [value_or_array]);
};
var to_ISO = Date.prototype.toISOString;
var defaults = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: encode,
  encodeValuesOnly: false,
  format: default_format,
  formatter: formatters[default_format],
  /** @deprecated */
  indices: false,
  serializeDate(date) {
    return to_ISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
function is_non_nullish_primitive(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
}
var sentinel = {};
function inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
  let obj = object;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
    const pos = tmp_sc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate == null ? void 0 : serializeDate(obj);
  } else if (generateArrayPrefix === "comma" && is_array2(obj)) {
    obj = maybe_map(obj, function(value) {
      if (value instanceof Date) {
        return serializeDate == null ? void 0 : serializeDate(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? (
        // @ts-expect-error
        encoder(prefix, defaults.encoder, charset, "key", format)
      ) : prefix;
    }
    obj = "";
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder) {
      const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
      return [
        (formatter == null ? void 0 : formatter(key_value)) + "=" + // @ts-expect-error
        (formatter == null ? void 0 : formatter(encoder(obj, defaults.encoder, charset, "value", format)))
      ];
    }
    return [(formatter == null ? void 0 : formatter(prefix)) + "=" + (formatter == null ? void 0 : formatter(String(obj)))];
  }
  const values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && is_array2(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = maybe_map(obj, encoder);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (is_array2(filter)) {
    obj_keys = filter;
  } else {
    const keys = Object.keys(obj);
    obj_keys = sort ? keys.sort(sort) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && is_array2(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && is_array2(obj) && obj.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j = 0; j < obj_keys.length; ++j) {
    const key = obj_keys[j];
    const value = (
      // @ts-ignore
      typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
    );
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = is_array2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel.set(object, step);
    const valueSideChannel = /* @__PURE__ */ new WeakMap();
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(values, inner_stringify(
      value,
      key_prefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      // @ts-ignore
      generateArrayPrefix === "comma" && encodeValuesOnly && is_array2(obj) ? null : encoder,
      filter,
      sort,
      allowDots,
      serializeDate,
      format,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
}
function normalize_stringify_options(opts = defaults) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset = opts.charset || defaults.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has.call(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format = opts.format;
  }
  const formatter = formatters[format];
  let filter = defaults.filter;
  if (typeof opts.filter === "function" || is_array2(opts.filter)) {
    filter = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
    // @ts-ignore
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter,
    format,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
    // @ts-ignore
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
}
function stringify(object, opts = {}) {
  let obj = object;
  const options = normalize_stringify_options(opts);
  let obj_keys;
  let filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (is_array2(options.filter)) {
    filter = options.filter;
    obj_keys = filter;
  }
  const keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options.sort) {
    obj_keys.sort(options.sort);
  }
  const sideChannel = /* @__PURE__ */ new WeakMap();
  for (let i = 0; i < obj_keys.length; ++i) {
    const key = obj_keys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    push_to_array(keys, inner_stringify(
      obj[key],
      key,
      // @ts-expect-error
      generateArrayPrefix,
      commaRoundTrip,
      options.allowEmptyArrays,
      options.strictNullHandling,
      options.skipNulls,
      options.encodeDotInKeys,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel
    ));
  }
  const joined = keys.join(options.delimiter);
  let prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}

// node_modules/openai/version.mjs
var VERSION = "4.79.1";

// node_modules/openai/_shims/registry.mjs
var auto = false;
var kind = void 0;
var fetch3 = void 0;
var Request3 = void 0;
var Response3 = void 0;
var Headers3 = void 0;
var FormData2 = void 0;
var Blob2 = void 0;
var File2 = void 0;
var ReadableStream2 = void 0;
var getMultipartRequestOptions = void 0;
var getDefaultAgent = void 0;
var fileFromPath = void 0;
var isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
  }
  if (kind) {
    throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch3 = shims.fetch;
  Request3 = shims.Request;
  Response3 = shims.Response;
  Headers3 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}

// node_modules/openai/_shims/MultipartBody.mjs
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// node_modules/openai/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import \u2026 from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}

// node_modules/openai/_shims/index.mjs
if (!kind)
  setShims(getRuntime(), { auto: true });

// node_modules/openai/error.mjs
var OpenAIError = class extends Error {
};
var APIError = class extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.request_id = headers == null ? void 0 : headers["x-request-id"];
    this.error = error;
    const data = error;
    this.code = data == null ? void 0 : data["code"];
    this.param = data == null ? void 0 : data["param"];
    this.type = data == null ? void 0 : data["type"];
  }
  static makeMessage(status, error, message) {
    const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error = errorResponse == null ? void 0 : errorResponse["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message != null ? message : "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
};
var AuthenticationError = class extends APIError {
};
var PermissionDeniedError = class extends APIError {
};
var NotFoundError = class extends APIError {
};
var ConflictError = class extends APIError {
};
var UnprocessableEntityError = class extends APIError {
};
var RateLimitError = class extends APIError {
};
var InternalServerError = class extends APIError {
};
var LengthFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the length limit was reached`);
  }
};
var ContentFilterFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the request was rejected by the content filter`);
  }
};

// node_modules/openai/internal/decoders/line.mjs
var LineDecoder = class {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);
    if (trailingNewline) {
      lines.pop();
    }
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    var _a2;
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        (_a2 = this.textDecoder) != null ? _a2 : this.textDecoder = new TextDecoder("utf8");
        return this.textDecoder.decode(bytes);
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;

// node_modules/openai/streaming.mjs
var Stream = class {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError(void 0, data.error, void 0, void 0);
            }
            yield data;
          } else {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (sse.event == "error") {
              throw new APIError(void 0, data.error, data.message, void 0);
            }
            yield { event: sse.event, data };
          }
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = readableStreamAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new Stream(() => teeIterator(left), this.controller),
      new Stream(() => teeIterator(right), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self2 = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream2({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a2;
        await ((_a2 = iter.return) == null ? void 0 : _a2.call(iter));
      }
    });
  }
};
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = readableStreamAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 2; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition(str2, delimiter) {
  const index2 = str2.indexOf(delimiter);
  if (index2 !== -1) {
    return [str2.substring(0, index2), delimiter, str2.substring(index2 + delimiter.length)];
  }
  return [str2, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/openai/uploads.mjs
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isUploadable = (value) => {
  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};
async function toFile(value, name, options) {
  var _a2, _b, _c;
  value = await value;
  if (isFileLike(value)) {
    return value;
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = (_a2 = new URL(value.url).pathname.split(/[\\/]/).pop()) != null ? _a2 : "unknown_file");
    const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];
    return new File2(data, name, options);
  }
  const bits = await getBytes(value);
  name || (name = (_b = getName(value)) != null ? _b : "unknown_file");
  if (!(options == null ? void 0 : options.type)) {
    const type = (_c = bits[0]) == null ? void 0 : _c.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes(value) {
  var _a2;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a2 = value == null ? void 0 : value.constructor) == null ? void 0 : _a2.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a2;
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  ((_a2 = getStringFromMaybeBuffer(value.path)) == null ? void 0 : _a2.split(/[\\/]/).pop());
}
var getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return void 0;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
var createForm = async (body) => {
  const form = new FormData2();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/openai/core.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const isJSON = (contentType == null ? void 0 : contentType.includes("application/json")) || (contentType == null ? void 0 : contentType.includes("application/vnd.api+json"));
  if (isJSON) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return _addRequestID(json, response);
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
function _addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("x-request-id"),
    enumerable: false
  });
}
var APIPromise = class extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("x-request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 6e5,
    // 10 minutes
    httpAgent,
    fetch: overriddenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overriddenFetch != null ? overriddenFetch : fetch3;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then(async (opts2) => {
      const body = opts2 && isBlobLike(opts2 == null ? void 0 : opts2.body) ? new DataView(await opts2.body.arrayBuffer()) : (opts2 == null ? void 0 : opts2.body) instanceof DataView ? opts2.body : (opts2 == null ? void 0 : opts2.body) instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2 == null ? void 0 : opts2.body) ? new DataView(opts2.body.buffer) : opts2 == null ? void 0 : opts2.body;
      return { method, path, ...opts2, body };
    }));
  }
  getAPIList(path, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    } else if (ArrayBuffer.isView(body)) {
      return body.byteLength.toString();
    }
    return null;
  }
  buildRequest(options, { retryCount = 0 } = {}) {
    var _a2, _b, _c, _d, _e, _f;
    const { method, path, query, headers = {} } = options;
    const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    const timeout = (_a2 = options.timeout) != null ? _a2 : this.timeout;
    const httpAgent = (_c = (_b = options.httpAgent) != null ? _b : this.httpAgent) != null ? _c : getDefaultAgent(url);
    const minAgentTimeout = timeout + 1e3;
    if (typeof ((_d = httpAgent == null ? void 0 : httpAgent.options) == null ? void 0 : _d.timeout) === "number" && minAgentTimeout > ((_e = httpAgent.options.timeout) != null ? _e : 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: (_f = options.signal) != null ? _f : null
    };
    return { req, url, timeout };
  }
  buildHeaders({ options, headers, contentLength, retryCount }) {
    const reqHeaders = {};
    if (contentLength) {
      reqHeaders["content-length"] = contentLength;
    }
    const defaultHeaders = this.defaultHeaders(options);
    applyHeadersMut(reqHeaders, defaultHeaders);
    applyHeadersMut(reqHeaders, headers);
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["content-type"];
    }
    if (getHeader(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader(headers, "x-stainless-retry-count") === void 0) {
      reqHeaders["x-stainless-retry-count"] = String(retryCount);
    }
    this.validateHeaders(reqHeaders, headers);
    return reqHeaders;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    var _a2, _b, _c;
    const options = await optionsInput;
    const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if ((_b = options.signal) == null ? void 0 : _b.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if ((_c = options.signal) == null ? void 0 : _c.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e) => castToError(e).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page2);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const fetchOptions = {
      signal: controller.signal,
      ...options
    };
    if (fetchOptions.method) {
      fetchOptions.method = fetchOptions.method.toUpperCase();
    }
    return (
      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
      this.fetch.call(void 0, url, fetchOptions).finally(() => {
        clearTimeout(timeout);
      })
    );
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    var _a2;
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after-ms"];
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after"];
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep2(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
};
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo && typeof nextOptions.query === "object") {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page2) {
    super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
var requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true,
  __binaryRequest: true,
  __binaryResponse: true,
  __streamClass: true
};
var isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
};
var getPlatformProperties = () => {
  var _a2, _b;
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : (_b = (_a2 = Deno.version) == null ? void 0 : _a2.deno) != null ? _b : "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders != null ? _platformHeaders : _platformHeaders = getPlatformProperties();
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep2 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      return new Error(JSON.stringify(err));
    } catch (e) {
    }
  }
  return new Error(err);
};
var readEnv = (env) => {
  var _a2, _b, _c, _d, _e, _f;
  if (typeof process !== "undefined") {
    return (_c = (_b = (_a2 = process.env) == null ? void 0 : _a2[env]) == null ? void 0 : _b.trim()) != null ? _c : void 0;
  }
  if (typeof Deno !== "undefined") {
    return (_f = (_e = (_d = Deno.env) == null ? void 0 : _d.get) == null ? void 0 : _e.call(_d, env)) == null ? void 0 : _f.trim();
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k in newHeaders) {
    if (!hasOwn(newHeaders, k))
      continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
var SENSITIVE_HEADERS = /* @__PURE__ */ new Set(["authorization", "api-key"]);
function debug(action, ...args) {
  var _a2;
  if (typeof process !== "undefined" && ((_a2 = process == null ? void 0 : process.env) == null ? void 0 : _a2["DEBUG"]) === "true") {
    const modifiedArgs = args.map((arg) => {
      if (!arg) {
        return arg;
      }
      if (arg["headers"]) {
        const modifiedArg2 = { ...arg, headers: { ...arg["headers"] } };
        for (const header in arg["headers"]) {
          if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
            modifiedArg2["headers"][header] = "REDACTED";
          }
        }
        return modifiedArg2;
      }
      let modifiedArg = null;
      for (const header in arg) {
        if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
          modifiedArg != null ? modifiedArg : modifiedArg = { ...arg };
          modifiedArg[header] = "REDACTED";
        }
      }
      return modifiedArg != null ? modifiedArg : arg;
    });
    console.log(`OpenAI:DEBUG:${action}`, ...modifiedArgs);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
var isHeadersProtocol = (headers) => {
  return typeof (headers == null ? void 0 : headers.get) === "function";
};
var getHeader = (headers, header) => {
  var _a2;
  const lowerCasedHeader = header.toLowerCase();
  if (isHeadersProtocol(headers)) {
    const intercapsHeader = ((_a2 = header[0]) == null ? void 0 : _a2.toUpperCase()) + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
      const value = headers.get(key);
      if (value) {
        return value;
      }
    }
  }
  for (const [key, value] of Object.entries(headers)) {
    if (key.toLowerCase() === lowerCasedHeader) {
      if (Array.isArray(value)) {
        if (value.length <= 1)
          return value[0];
        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
        return value[0];
      }
      return value;
    }
  }
  return void 0;
};
function isObj(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj);
}

// node_modules/openai/pagination.mjs
var Page = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    var _a2;
    return (_a2 = this.data) != null ? _a2 : [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
};
var CursorPage = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
  }
  getPaginatedItems() {
    var _a2;
    return (_a2 = this.data) != null ? _a2 : [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info)
      return null;
    if ("params" in info)
      return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    var _a2;
    const data = this.getPaginatedItems();
    if (!data.length) {
      return null;
    }
    const id = (_a2 = data[data.length - 1]) == null ? void 0 : _a2.id;
    if (!id) {
      return null;
    }
    return { params: { after: id } };
  }
};

// node_modules/openai/resource.mjs
var APIResource = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/openai/resources/chat/completions.mjs
var Completions = class extends APIResource {
  create(body, options) {
    var _a2;
    return this._client.post("/chat/completions", { body, ...options, stream: (_a2 = body.stream) != null ? _a2 : false });
  }
};

// node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this._client);
  }
};
Chat.Completions = Completions;

// node_modules/openai/resources/audio/speech.mjs
var Speech = class extends APIResource {
  /**
   * Generates audio from the input text.
   */
  create(body, options) {
    return this._client.post("/audio/speech", {
      body,
      ...options,
      headers: { Accept: "application/octet-stream", ...options == null ? void 0 : options.headers },
      __binaryResponse: true
    });
  }
};

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource {
  create(body, options) {
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions({ body, ...options }));
  }
};

// node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource {
  create(body, options) {
    return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options }));
  }
};

// node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
};
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;
Audio.Speech = Speech;

// node_modules/openai/resources/batches.mjs
var Batches = class extends APIResource {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(body, options) {
    return this._client.post("/batches", { body, ...options });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(batchId, options) {
    return this._client.get(`/batches/${batchId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/batches", BatchesPage, { query, ...options });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(batchId, options) {
    return this._client.post(`/batches/${batchId}/cancel`, options);
  }
};
var BatchesPage = class extends CursorPage {
};
Batches.BatchesPage = BatchesPage;

// node_modules/openai/resources/beta/assistants.mjs
var Assistants = class extends APIResource {
  /**
   * Create an assistant with a model and instructions.
   */
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves an assistant.
   */
  retrieve(assistantId, options) {
    return this._client.get(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies an assistant.
   */
  update(assistantId, body, options) {
    return this._client.post(`/assistants/${assistantId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/assistants", AssistantsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete an assistant.
   */
  del(assistantId, options) {
    return this._client.delete(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};
var AssistantsPage = class extends CursorPage {
};
Assistants.AssistantsPage = AssistantsPage;

// node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}

// node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage = (message) => {
  return (message == null ? void 0 : message.role) === "assistant";
};
var isFunctionMessage = (message) => {
  return (message == null ? void 0 : message.role) === "function";
};
var isToolMessage = (message) => {
  return (message == null ? void 0 : message.role) === "tool";
};

// node_modules/openai/lib/EventStream.mjs
var __classPrivateFieldSet2 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EventStream_instances;
var _EventStream_connectedPromise;
var _EventStream_resolveConnectedPromise;
var _EventStream_rejectConnectedPromise;
var _EventStream_endPromise;
var _EventStream_resolveEndPromise;
var _EventStream_rejectEndPromise;
var _EventStream_listeners;
var _EventStream_ended;
var _EventStream_errored;
var _EventStream_aborted;
var _EventStream_catchingPromiseCreated;
var _EventStream_handleError;
var EventStream = class {
  constructor() {
    _EventStream_instances.add(this);
    this.controller = new AbortController();
    _EventStream_connectedPromise.set(this, void 0);
    _EventStream_resolveConnectedPromise.set(this, () => {
    });
    _EventStream_rejectConnectedPromise.set(this, () => {
    });
    _EventStream_endPromise.set(this, void 0);
    _EventStream_resolveEndPromise.set(this, () => {
    });
    _EventStream_rejectEndPromise.set(this, () => {
    });
    _EventStream_listeners.set(this, {});
    _EventStream_ended.set(this, false);
    _EventStream_errored.set(this, false);
    _EventStream_aborted.set(this, false);
    _EventStream_catchingPromiseCreated.set(this, false);
    __classPrivateFieldSet2(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _EventStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet2(this, _EventStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet2(this, _EventStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _EventStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet2(this, _EventStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet2(this, _EventStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet2(this, _EventStream_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet2(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
    }, 0);
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet2(this, _EventStream_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet2(this, _EventStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet2(this, _EventStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet2(this, _EventStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index2 = listeners.findIndex((l) => l.listener === listener);
    if (index2 >= 0)
      listeners.splice(index2, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _EventStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet2(this, _EventStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet2(this, _EventStream_endPromise, "f");
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet2(this, _EventStream_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet2(this, _EventStream_ended, true, "f");
      __classPrivateFieldGet2(this, _EventStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
  }
};
_EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error) {
  __classPrivateFieldSet2(this, _EventStream_errored, true, "f");
  if (error instanceof Error && error.name === "AbortError") {
    error = new APIUserAbortError();
  }
  if (error instanceof APIUserAbortError) {
    __classPrivateFieldSet2(this, _EventStream_aborted, true, "f");
    return this._emit("abort", error);
  }
  if (error instanceof OpenAIError) {
    return this._emit("error", error);
  }
  if (error instanceof Error) {
    const openAIError = new OpenAIError(error.message);
    openAIError.cause = error;
    return this._emit("error", openAIError);
  }
  return this._emit("error", new OpenAIError(String(error)));
};

// node_modules/openai/lib/parser.mjs
function isAutoParsableResponseFormat(response_format) {
  return (response_format == null ? void 0 : response_format["$brand"]) === "auto-parseable-response-format";
}
function isAutoParsableTool(tool) {
  return (tool == null ? void 0 : tool["$brand"]) === "auto-parseable-tool";
}
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => {
        var _a2;
        return {
          ...choice,
          message: { ...choice.message, parsed: null, tool_calls: (_a2 = choice.message.tool_calls) != null ? _a2 : [] }
        };
      })
    };
  }
  return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    var _a2, _b;
    if (choice.finish_reason === "length") {
      throw new LengthFinishReasonError();
    }
    if (choice.finish_reason === "content_filter") {
      throw new ContentFilterFinishReasonError();
    }
    return {
      ...choice,
      message: {
        ...choice.message,
        tool_calls: (_b = (_a2 = choice.message.tool_calls) == null ? void 0 : _a2.map((toolCall) => parseToolCall(params, toolCall))) != null ? _b : [],
        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
      }
    };
  });
  return { ...completion, choices };
}
function parseResponseFormat(params, content) {
  var _a2, _b;
  if (((_a2 = params.response_format) == null ? void 0 : _a2.type) !== "json_schema") {
    return null;
  }
  if (((_b = params.response_format) == null ? void 0 : _b.type) === "json_schema") {
    if ("$parseRaw" in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
function parseToolCall(params, toolCall) {
  var _a2;
  const inputTool = (_a2 = params.tools) == null ? void 0 : _a2.find((inputTool2) => {
    var _a3;
    return ((_a3 = inputTool2.function) == null ? void 0 : _a3.name) === toolCall.function.name;
  });
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCall.function.arguments) : null
    }
  };
}
function shouldParseToolCall(params, toolCall) {
  var _a2;
  if (!params) {
    return false;
  }
  const inputTool = (_a2 = params.tools) == null ? void 0 : _a2.find((inputTool2) => {
    var _a3;
    return ((_a3 = inputTool2.function) == null ? void 0 : _a3.name) === toolCall.function.name;
  });
  return isAutoParsableTool(inputTool) || (inputTool == null ? void 0 : inputTool.function.strict) || false;
}
function hasAutoParseableInput(params) {
  var _a2, _b;
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return (_b = (_a2 = params.tools) == null ? void 0 : _a2.some((t) => isAutoParsableTool(t) || t.type === "function" && t.function.strict === true)) != null ? _b : false;
}
function validateInputTools(tools) {
  for (const tool of tools != null ? tools : []) {
    if (tool.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
    }
    if (tool.function.strict !== true) {
      throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
    }
  }
}

// node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var __classPrivateFieldGet3 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractChatCompletionRunner_instances;
var _AbstractChatCompletionRunner_getFinalContent;
var _AbstractChatCompletionRunner_getFinalMessage;
var _AbstractChatCompletionRunner_getFinalFunctionCall;
var _AbstractChatCompletionRunner_getFinalFunctionCallResult;
var _AbstractChatCompletionRunner_calculateTotalUsage;
var _AbstractChatCompletionRunner_validateParams;
var _AbstractChatCompletionRunner_stringifyFunctionCallResult;
var DEFAULT_MAX_CHAT_COMPLETIONS = 10;
var AbstractChatCompletionRunner = class extends EventStream {
  constructor() {
    super(...arguments);
    _AbstractChatCompletionRunner_instances.add(this);
    this._chatCompletions = [];
    this.messages = [];
  }
  _addChatCompletion(chatCompletion) {
    var _a2;
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = (_a2 = chatCompletion.choices[0]) == null ? void 0 : _a2.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {
        this._emit("functionCallResult", message.content);
      } else if (isAssistantMessage(message) && message.function_call) {
        this._emit("functionCall", message.function_call);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionCall", tool_call.function);
          }
        }
      }
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionCall() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
  }
  async finalFunctionCallResult() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(client, params, options) {
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
  }
  async _runChatCompletion(client, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(client, params, options);
  }
  async _runFunctions(client, params, options) {
    var _a2;
    const role = "function";
    const { function_call = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof function_call !== "string" && (function_call == null ? void 0 : function_call.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const functionsByName = {};
    for (const f of params.functions) {
      functionsByName[f.name || f.function.name] = f;
    }
    const functions = params.functions.map((f) => ({
      name: f.name || f.function.name,
      parameters: f.parameters,
      description: f.description
    }));
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        function_call,
        functions,
        messages: [...this.messages]
      }, options);
      const message = (_a2 = chatCompletion.choices[0]) == null ? void 0 : _a2.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.function_call)
        return;
      const { name, arguments: args } = message.function_call;
      const fn = functionsByName[name];
      if (!fn) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f) => JSON.stringify(f.name)).join(", ")}. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      } else if (singleFunctionToCall && singleFunctionToCall !== name) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      }
      let parsed;
      try {
        parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
      } catch (error) {
        this._addMessage({
          role,
          name,
          content: error instanceof Error ? error.message : String(error)
        });
        continue;
      }
      const rawContent = await fn.function(parsed, this);
      const content = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
      this._addMessage({ role, name, content });
      if (singleFunctionToCall)
        return;
    }
  }
  async _runTools(client, params, options) {
    var _a2, _b, _c;
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && ((_a2 = tool_choice == null ? void 0 : tool_choice.function) == null ? void 0 : _a2.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const inputTools = params.tools.map((tool) => {
      if (isAutoParsableTool(tool)) {
        if (!tool.$callback) {
          throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
        }
        return {
          type: "function",
          function: {
            function: tool.$callback,
            name: tool.function.name,
            description: tool.function.description || "",
            parameters: tool.function.parameters,
            parse: tool.$parseRaw,
            strict: true
          }
        };
      }
      return tool;
    });
    const functionsByName = {};
    for (const f of inputTools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
      type: "function",
      function: {
        name: t.function.name || t.function.function.name,
        parameters: t.function.parameters,
        description: t.function.description,
        strict: t.function.strict
      }
    } : t) : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options);
      const message = (_b = chatCompletion.choices[0]) == null ? void 0 : _b.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!((_c = message.tool_calls) == null ? void 0 : _c.length)) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error) {
          const content2 = error instanceof Error ? error.message : String(error);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
};
_AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  var _a2;
  return (_a2 = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content) != null ? _a2 : null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  var _a2, _b;
  let i = this.messages.length;
  while (i-- > 0) {
    const message = this.messages[i];
    if (isAssistantMessage(message)) {
      const { function_call, ...rest } = message;
      const ret = {
        ...rest,
        content: (_a2 = message.content) != null ? _a2 : null,
        refusal: (_b = message.refusal) != null ? _b : null
      };
      if (function_call) {
        ret.function_call = function_call;
      }
      return ret;
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall2() {
  var _a2, _b;
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isAssistantMessage(message) && (message == null ? void 0 : message.function_call)) {
      return message.function_call;
    }
    if (isAssistantMessage(message) && ((_a2 = message == null ? void 0 : message.tool_calls) == null ? void 0 : _a2.length)) {
      return (_b = message.tool_calls.at(-1)) == null ? void 0 : _b.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isFunctionMessage(message) && message.content != null) {
      return message.content;
    }
    if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => {
      var _a2;
      return x.role === "assistant" && ((_a2 = x.tool_calls) == null ? void 0 : _a2.some((y) => y.type === "function" && y.id === message.tool_call_id));
    })) {
      return message.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
};

// node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner = class extends AbstractChatCompletionRunner {
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(client, params, options) {
    const runner = new ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(client, params, opts));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
  _addMessage(message, emit = true) {
    super._addMessage(message, emit);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
};

// node_modules/openai/_vendor/partial-json-parser/parser.mjs
var STR = 1;
var NUM = 2;
var ARR = 4;
var OBJ = 8;
var NULL = 16;
var BOOL = 32;
var NAN = 64;
var INFINITY = 128;
var MINUS_INFINITY = 256;
var INF = INFINITY | MINUS_INFINITY;
var SPECIAL = NULL | BOOL | INF | NAN;
var ATOM = STR | NUM | SPECIAL;
var COLLECTION = ARR | OBJ;
var ALL = ATOM | COLLECTION;
var Allow = {
  STR,
  NUM,
  ARR,
  OBJ,
  NULL,
  BOOL,
  NAN,
  INFINITY,
  MINUS_INFINITY,
  INF,
  SPECIAL,
  ATOM,
  COLLECTION,
  ALL
};
var PartialJSON = class extends Error {
};
var MalformedJSON = class extends Error {
};
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
var _parseJSON = (jsonString, allow) => {
  const length = jsonString.length;
  let index2 = 0;
  const markPartialJSON = (msg) => {
    throw new PartialJSON(`${msg} at position ${index2}`);
  };
  const throwMalformedError = (msg) => {
    throw new MalformedJSON(`${msg} at position ${index2}`);
  };
  const parseAny = () => {
    skipBlank();
    if (index2 >= length)
      markPartialJSON("Unexpected end of input");
    if (jsonString[index2] === '"')
      return parseStr();
    if (jsonString[index2] === "{")
      return parseObj();
    if (jsonString[index2] === "[")
      return parseArr();
    if (jsonString.substring(index2, index2 + 4) === "null" || Allow.NULL & allow && length - index2 < 4 && "null".startsWith(jsonString.substring(index2))) {
      index2 += 4;
      return null;
    }
    if (jsonString.substring(index2, index2 + 4) === "true" || Allow.BOOL & allow && length - index2 < 4 && "true".startsWith(jsonString.substring(index2))) {
      index2 += 4;
      return true;
    }
    if (jsonString.substring(index2, index2 + 5) === "false" || Allow.BOOL & allow && length - index2 < 5 && "false".startsWith(jsonString.substring(index2))) {
      index2 += 5;
      return false;
    }
    if (jsonString.substring(index2, index2 + 8) === "Infinity" || Allow.INFINITY & allow && length - index2 < 8 && "Infinity".startsWith(jsonString.substring(index2))) {
      index2 += 8;
      return Infinity;
    }
    if (jsonString.substring(index2, index2 + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index2 && length - index2 < 9 && "-Infinity".startsWith(jsonString.substring(index2))) {
      index2 += 9;
      return -Infinity;
    }
    if (jsonString.substring(index2, index2 + 3) === "NaN" || Allow.NAN & allow && length - index2 < 3 && "NaN".startsWith(jsonString.substring(index2))) {
      index2 += 3;
      return NaN;
    }
    return parseNum();
  };
  const parseStr = () => {
    const start = index2;
    let escape2 = false;
    index2++;
    while (index2 < length && (jsonString[index2] !== '"' || escape2 && jsonString[index2 - 1] === "\\")) {
      escape2 = jsonString[index2] === "\\" ? !escape2 : false;
      index2++;
    }
    if (jsonString.charAt(index2) == '"') {
      try {
        return JSON.parse(jsonString.substring(start, ++index2 - Number(escape2)));
      } catch (e) {
        throwMalformedError(String(e));
      }
    } else if (Allow.STR & allow) {
      try {
        return JSON.parse(jsonString.substring(start, index2 - Number(escape2)) + '"');
      } catch (e) {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
      }
    }
    markPartialJSON("Unterminated string literal");
  };
  const parseObj = () => {
    index2++;
    skipBlank();
    const obj = {};
    try {
      while (jsonString[index2] !== "}") {
        skipBlank();
        if (index2 >= length && Allow.OBJ & allow)
          return obj;
        const key = parseStr();
        skipBlank();
        index2++;
        try {
          const value = parseAny();
          Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
        } catch (e) {
          if (Allow.OBJ & allow)
            return obj;
          else
            throw e;
        }
        skipBlank();
        if (jsonString[index2] === ",")
          index2++;
      }
    } catch (e) {
      if (Allow.OBJ & allow)
        return obj;
      else
        markPartialJSON("Expected '}' at end of object");
    }
    index2++;
    return obj;
  };
  const parseArr = () => {
    index2++;
    const arr = [];
    try {
      while (jsonString[index2] !== "]") {
        arr.push(parseAny());
        skipBlank();
        if (jsonString[index2] === ",") {
          index2++;
        }
      }
    } catch (e) {
      if (Allow.ARR & allow) {
        return arr;
      }
      markPartialJSON("Expected ']' at end of array");
    }
    index2++;
    return arr;
  };
  const parseNum = () => {
    if (index2 === 0) {
      if (jsonString === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString);
      } catch (e) {
        if (Allow.NUM & allow) {
          try {
            if ("." === jsonString[jsonString.length - 1])
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
          } catch (e2) {
          }
        }
        throwMalformedError(String(e));
      }
    }
    const start = index2;
    if (jsonString[index2] === "-")
      index2++;
    while (jsonString[index2] && !",]}".includes(jsonString[index2]))
      index2++;
    if (index2 == length && !(Allow.NUM & allow))
      markPartialJSON("Unterminated number literal");
    try {
      return JSON.parse(jsonString.substring(start, index2));
    } catch (e) {
      if (jsonString.substring(start, index2) === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
      } catch (e2) {
        throwMalformedError(String(e2));
      }
    }
  };
  const skipBlank = () => {
    while (index2 < length && " \n\r	".includes(jsonString[index2])) {
      index2++;
    }
  };
  return parseAny();
};
var partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);

// node_modules/openai/lib/ChatCompletionStream.mjs
var __classPrivateFieldSet3 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet4 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ChatCompletionStream_instances;
var _ChatCompletionStream_params;
var _ChatCompletionStream_choiceEventStates;
var _ChatCompletionStream_currentChatCompletionSnapshot;
var _ChatCompletionStream_beginRequest;
var _ChatCompletionStream_getChoiceEventState;
var _ChatCompletionStream_addChunk;
var _ChatCompletionStream_emitToolCallDoneEvent;
var _ChatCompletionStream_emitContentDoneEvents;
var _ChatCompletionStream_endRequest;
var _ChatCompletionStream_getAutoParseableResponseFormat;
var _ChatCompletionStream_accumulateChatCompletion;
var ChatCompletionStream = class extends AbstractChatCompletionRunner {
  constructor(params) {
    super();
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_params.set(this, void 0);
    _ChatCompletionStream_choiceEventStates.set(this, void 0);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
    __classPrivateFieldSet3(this, _ChatCompletionStream_params, params, "f");
    __classPrivateFieldSet3(this, _ChatCompletionStream_choiceEventStates, [], "f");
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet4(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStream(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(client, params, options) {
    const runner = new ChatCompletionStream(params);
    runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(client, params, options) {
    var _a2;
    super._createChatCompletion;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
  }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
    let state = __classPrivateFieldGet4(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
    if (state) {
      return state;
    }
    state = {
      content_done: false,
      refusal_done: false,
      logprobs_content_done: false,
      logprobs_refusal_done: false,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    };
    __classPrivateFieldGet4(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
    return state;
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    for (const choice of chunk.choices) {
      const choiceSnapshot = completion.choices[choice.index];
      if (choice.delta.content != null && ((_a2 = choiceSnapshot.message) == null ? void 0 : _a2.role) === "assistant" && ((_b = choiceSnapshot.message) == null ? void 0 : _b.content)) {
        this._emit("content", choice.delta.content, choiceSnapshot.message.content);
        this._emit("content.delta", {
          delta: choice.delta.content,
          snapshot: choiceSnapshot.message.content,
          parsed: choiceSnapshot.message.parsed
        });
      }
      if (choice.delta.refusal != null && ((_c = choiceSnapshot.message) == null ? void 0 : _c.role) === "assistant" && ((_d = choiceSnapshot.message) == null ? void 0 : _d.refusal)) {
        this._emit("refusal.delta", {
          delta: choice.delta.refusal,
          snapshot: choiceSnapshot.message.refusal
        });
      }
      if (((_e = choice.logprobs) == null ? void 0 : _e.content) != null && ((_f = choiceSnapshot.message) == null ? void 0 : _f.role) === "assistant") {
        this._emit("logprobs.content.delta", {
          content: (_g = choice.logprobs) == null ? void 0 : _g.content,
          snapshot: (_i = (_h = choiceSnapshot.logprobs) == null ? void 0 : _h.content) != null ? _i : []
        });
      }
      if (((_j = choice.logprobs) == null ? void 0 : _j.refusal) != null && ((_k = choiceSnapshot.message) == null ? void 0 : _k.role) === "assistant") {
        this._emit("logprobs.refusal.delta", {
          refusal: (_l = choice.logprobs) == null ? void 0 : _l.refusal,
          snapshot: (_n = (_m = choiceSnapshot.logprobs) == null ? void 0 : _m.refusal) != null ? _n : []
        });
      }
      const state = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.finish_reason) {
        __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
        if (state.current_tool_call_index != null) {
          __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
        }
      }
      for (const toolCall of (_o = choice.delta.tool_calls) != null ? _o : []) {
        if (state.current_tool_call_index !== toolCall.index) {
          __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        state.current_tool_call_index = toolCall.index;
      }
      for (const toolCallDelta of (_p = choice.delta.tool_calls) != null ? _p : []) {
        const toolCallSnapshot = (_q = choiceSnapshot.message.tool_calls) == null ? void 0 : _q[toolCallDelta.index];
        if (!(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type)) {
          continue;
        }
        if ((toolCallSnapshot == null ? void 0 : toolCallSnapshot.type) === "function") {
          this._emit("tool_calls.function.arguments.delta", {
            name: (_r = toolCallSnapshot.function) == null ? void 0 : _r.name,
            index: toolCallDelta.index,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: toolCallSnapshot.function.parsed_arguments,
            arguments_delta: (_t = (_s = toolCallDelta.function) == null ? void 0 : _s.arguments) != null ? _t : ""
          });
        } else {
          assertNever(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type);
        }
      }
    }
  }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
    var _a2, _b, _c;
    const state = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (state.done_tool_calls.has(toolCallIndex)) {
      return;
    }
    const toolCallSnapshot = (_a2 = choiceSnapshot.message.tool_calls) == null ? void 0 : _a2[toolCallIndex];
    if (!toolCallSnapshot) {
      throw new Error("no tool call snapshot");
    }
    if (!toolCallSnapshot.type) {
      throw new Error("tool call snapshot missing `type`");
    }
    if (toolCallSnapshot.type === "function") {
      const inputTool = (_c = (_b = __classPrivateFieldGet4(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _b.tools) == null ? void 0 : _c.find((tool) => tool.type === "function" && tool.function.name === toolCallSnapshot.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: toolCallSnapshot.function.name,
        index: toolCallIndex,
        arguments: toolCallSnapshot.function.arguments,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCallSnapshot.function.arguments) : null
      });
    } else {
      assertNever(toolCallSnapshot.type);
    }
  }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
    var _a2, _b;
    const state = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (choiceSnapshot.message.content && !state.content_done) {
      state.content_done = true;
      const responseFormat = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
      this._emit("content.done", {
        content: choiceSnapshot.message.content,
        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
      });
    }
    if (choiceSnapshot.message.refusal && !state.refusal_done) {
      state.refusal_done = true;
      this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
    }
    if (((_a2 = choiceSnapshot.logprobs) == null ? void 0 : _a2.content) && !state.logprobs_content_done) {
      state.logprobs_content_done = true;
      this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
    }
    if (((_b = choiceSnapshot.logprobs) == null ? void 0 : _b.refusal) && !state.logprobs_refusal_done) {
      state.logprobs_refusal_done = true;
      this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet4(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
    __classPrivateFieldSet3(this, _ChatCompletionStream_choiceEventStates, [], "f");
    return finalizeChatCompletion(snapshot, __classPrivateFieldGet4(this, _ChatCompletionStream_params, "f"));
  }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
    var _a2;
    const responseFormat = (_a2 = __classPrivateFieldGet4(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _a2.response_format;
    if (isAutoParsableResponseFormat(responseFormat)) {
      return responseFormat;
    }
    return null;
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
    var _a3, _b2, _c2, _d2, _e, _f;
    var _a2, _b, _c, _d;
    let snapshot = __classPrivateFieldGet4(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      }, "f");
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index: index2, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index2];
      if (!choice) {
        choice = snapshot.choices[index2] = { finish_reason, index: index2, message: {}, logprobs, ...other };
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = Object.assign({}, logprobs);
        } else {
          const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
          assertIsEmpty(rest3);
          Object.assign(choice.logprobs, rest3);
          if (content2) {
            (_a3 = (_a2 = choice.logprobs).content) != null ? _a3 : _a2.content = [];
            choice.logprobs.content.push(...content2);
          }
          if (refusal2) {
            (_b2 = (_b = choice.logprobs).refusal) != null ? _b2 : _b.refusal = [];
            choice.logprobs.refusal.push(...refusal2);
          }
        }
      }
      if (finish_reason) {
        choice.finish_reason = finish_reason;
        if (__classPrivateFieldGet4(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput(__classPrivateFieldGet4(this, _ChatCompletionStream_params, "f"))) {
          if (finish_reason === "length") {
            throw new LengthFinishReasonError();
          }
          if (finish_reason === "content_filter") {
            throw new ContentFilterFinishReasonError();
          }
        }
      }
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
      assertIsEmpty(rest2);
      Object.assign(choice.message, rest2);
      if (refusal) {
        choice.message.refusal = (choice.message.refusal || "") + refusal;
      }
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_c2 = (_c = choice.message.function_call).arguments) != null ? _c2 : _c.arguments = "";
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (content) {
        choice.message.content = (choice.message.content || "") + content;
        if (!choice.message.refusal && __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
          choice.message.parsed = partialParse(choice.message.content);
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index3, id, type, function: fn, ...rest3 } of tool_calls) {
          const tool_call = (_d2 = (_d = choice.message.tool_calls)[index3]) != null ? _d2 : _d[index3] = {};
          Object.assign(tool_call, rest3);
          if (id)
            tool_call.id = id;
          if (type)
            tool_call.type = type;
          if (fn)
            (_f = tool_call.function) != null ? _f : tool_call.function = { name: (_e = fn.name) != null ? _e : "", arguments: "" };
          if (fn == null ? void 0 : fn.name)
            tool_call.function.name = fn.name;
          if (fn == null ? void 0 : fn.arguments) {
            tool_call.function.arguments += fn.arguments;
            if (shouldParseToolCall(__classPrivateFieldGet4(this, _ChatCompletionStream_params, "f"), tool_call)) {
              tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
            }
          }
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function finalizeChatCompletion(snapshot, params) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index: index2, logprobs, ...choiceRest }) => {
      var _a2, _b, _c;
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index2}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index2}`);
      }
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index2}`);
        }
        if (!name) {
          throw new OpenAIError(`missing function_call.name for choice ${index2}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name },
            role,
            refusal: (_a2 = message.refusal) != null ? _a2 : null
          },
          finish_reason,
          index: index2,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index: index2,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: (_b = message.refusal) != null ? _b : null,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].id
${str(snapshot)}`);
              }
              if (type == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].type
${str(snapshot)}`);
              }
              if (name == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].function.name
${str(snapshot)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
              }
              return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: (_c = message.refusal) != null ? _c : null },
        finish_reason,
        index: index2,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
  return maybeParseChatCompletion(completion, params);
}
function str(x) {
  return JSON.stringify(x);
}
function assertIsEmpty(obj) {
  return;
}
function assertNever(_x) {
}

// node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner = class extends ChatCompletionStream {
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStreamingRunner(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(client, params, options) {
    const runner = new ChatCompletionStreamingRunner(null);
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(client, params, opts));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new ChatCompletionStreamingRunner(
      // @ts-expect-error TODO these types are incompatible
      params
    );
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
};

// node_modules/openai/resources/beta/chat/completions.mjs
var Completions2 = class extends APIResource {
  parse(body, options) {
    validateInputTools(body.tools);
    return this._client.chat.completions.create(body, {
      ...options,
      headers: {
        ...options == null ? void 0 : options.headers,
        "X-Stainless-Helper-Method": "beta.chat.completions.parse"
      }
    })._thenUnwrap((completion) => parseChatCompletion(completion, body));
  }
  runFunctions(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runFunctions(this._client, body, options);
    }
    return ChatCompletionRunner.runFunctions(this._client, body, options);
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client, body, options);
    }
    return ChatCompletionRunner.runTools(this._client, body, options);
  }
  /**
   * Creates a chat completion stream
   */
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(this._client, body, options);
  }
};

// node_modules/openai/resources/beta/chat/chat.mjs
var Chat2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions2(this._client);
  }
};
(function(Chat3) {
  Chat3.Completions = Completions2;
})(Chat2 || (Chat2 = {}));

// node_modules/openai/resources/beta/realtime/sessions.mjs
var Sessions = class extends APIResource {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   */
  create(body, options) {
    return this._client.post("/realtime/sessions", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};

// node_modules/openai/resources/beta/realtime/realtime.mjs
var Realtime = class extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions(this._client);
  }
};
Realtime.Sessions = Sessions;

// node_modules/openai/lib/AssistantStream.mjs
var __classPrivateFieldGet5 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet4 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _AssistantStream_instances;
var _AssistantStream_events;
var _AssistantStream_runStepSnapshots;
var _AssistantStream_messageSnapshots;
var _AssistantStream_messageSnapshot;
var _AssistantStream_finalRun;
var _AssistantStream_currentContentIndex;
var _AssistantStream_currentContent;
var _AssistantStream_currentToolCallIndex;
var _AssistantStream_currentToolCall;
var _AssistantStream_currentEvent;
var _AssistantStream_currentRunSnapshot;
var _AssistantStream_currentRunStepSnapshot;
var _AssistantStream_addEvent;
var _AssistantStream_endRequest;
var _AssistantStream_handleMessage;
var _AssistantStream_handleRunStep;
var _AssistantStream_handleEvent;
var _AssistantStream_accumulateRunStep;
var _AssistantStream_accumulateMessage;
var _AssistantStream_accumulateContent;
var _AssistantStream_handleRun;
var AssistantStream = class extends EventStream {
  constructor() {
    super(...arguments);
    _AssistantStream_instances.add(this);
    _AssistantStream_events.set(this, []);
    _AssistantStream_runStepSnapshots.set(this, {});
    _AssistantStream_messageSnapshots.set(this, {});
    _AssistantStream_messageSnapshot.set(this, void 0);
    _AssistantStream_finalRun.set(this, void 0);
    _AssistantStream_currentContentIndex.set(this, void 0);
    _AssistantStream_currentContent.set(this, void 0);
    _AssistantStream_currentToolCallIndex.set(this, void 0);
    _AssistantStream_currentToolCall.set(this, void 0);
    _AssistantStream_currentEvent.set(this, void 0);
    _AssistantStream_currentRunSnapshot.set(this, void 0);
    _AssistantStream_currentRunStepSnapshot.set(this, void 0);
  }
  [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  static fromReadableStream(stream) {
    const runner = new AssistantStream();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  async _fromReadableStream(readableStream, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
  static createToolAssistantStream(threadId, runId, runs, params, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createToolAssistantStream(run, threadId, runId, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.submitToolOutputs(threadId, runId, body, {
      ...options,
      signal: this.controller.signal
    });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static createThreadAssistantStream(params, thread, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._threadAssistantStream(params, thread, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  static createAssistantStream(threadId, runs, params, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._runAssistantStream(threadId, runs, params, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  currentEvent() {
    return __classPrivateFieldGet5(this, _AssistantStream_currentEvent, "f");
  }
  currentRun() {
    return __classPrivateFieldGet5(this, _AssistantStream_currentRunSnapshot, "f");
  }
  currentMessageSnapshot() {
    return __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f");
  }
  currentRunStepSnapshot() {
    return __classPrivateFieldGet5(this, _AssistantStream_currentRunStepSnapshot, "f");
  }
  async finalRunSteps() {
    await this.done();
    return Object.values(__classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f"));
  }
  async finalMessages() {
    await this.done();
    return Object.values(__classPrivateFieldGet5(this, _AssistantStream_messageSnapshots, "f"));
  }
  async finalRun() {
    await this.done();
    if (!__classPrivateFieldGet5(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run was not received.");
    return __classPrivateFieldGet5(this, _AssistantStream_finalRun, "f");
  }
  async _createThreadAssistantStream(thread, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  async _createAssistantStream(run, threadId, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static accumulateDelta(acc, delta) {
    for (const [key, deltaValue] of Object.entries(delta)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = deltaValue;
        continue;
      }
      let accValue = acc[key];
      if (accValue === null || accValue === void 0) {
        acc[key] = deltaValue;
        continue;
      }
      if (key === "index" || key === "type") {
        acc[key] = deltaValue;
        continue;
      }
      if (typeof accValue === "string" && typeof deltaValue === "string") {
        accValue += deltaValue;
      } else if (typeof accValue === "number" && typeof deltaValue === "number") {
        accValue += deltaValue;
      } else if (isObj(accValue) && isObj(deltaValue)) {
        accValue = this.accumulateDelta(accValue, deltaValue);
      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
        if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
          accValue.push(...deltaValue);
          continue;
        }
        for (const deltaEntry of deltaValue) {
          if (!isObj(deltaEntry)) {
            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
          }
          const index2 = deltaEntry["index"];
          if (index2 == null) {
            console.error(deltaEntry);
            throw new Error("Expected array delta entry to have an `index` property");
          }
          if (typeof index2 !== "number") {
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index2}`);
          }
          const accEntry = accValue[index2];
          if (accEntry == null) {
            accValue.push(deltaEntry);
          } else {
            accValue[index2] = this.accumulateDelta(accEntry, deltaEntry);
          }
        }
        continue;
      } else {
        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
      }
      acc[key] = accValue;
    }
    return acc;
  }
  _addRun(run) {
    return run;
  }
  async _threadAssistantStream(params, thread, options) {
    return await this._createThreadAssistantStream(thread, params, options);
  }
  async _runAssistantStream(threadId, runs, params, options) {
    return await this._createAssistantStream(runs, threadId, params, options);
  }
  async _runToolAssistantStream(threadId, runId, runs, params, options) {
    return await this._createToolAssistantStream(runs, threadId, runId, params, options);
  }
};
_AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
  if (this.ended)
    return;
  __classPrivateFieldSet4(this, _AssistantStream_currentEvent, event, "f");
  __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
  switch (event.event) {
    case "thread.created":
      break;
    case "thread.run.created":
    case "thread.run.queued":
    case "thread.run.in_progress":
    case "thread.run.requires_action":
    case "thread.run.completed":
    case "thread.run.failed":
    case "thread.run.cancelling":
    case "thread.run.cancelled":
    case "thread.run.expired":
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
      break;
    case "thread.run.step.created":
    case "thread.run.step.in_progress":
    case "thread.run.step.delta":
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
      break;
    case "thread.message.created":
    case "thread.message.in_progress":
    case "thread.message.delta":
    case "thread.message.completed":
    case "thread.message.incomplete":
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
      break;
    case "error":
      throw new Error("Encountered an error event in event processing - errors should be processed earlier");
  }
}, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
  if (this.ended) {
    throw new OpenAIError(`stream has ended, this shouldn't happen`);
  }
  if (!__classPrivateFieldGet5(this, _AssistantStream_finalRun, "f"))
    throw Error("Final run has not been received");
  return __classPrivateFieldGet5(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
  const [accumulatedMessage, newContent] = __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
  __classPrivateFieldSet4(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
  __classPrivateFieldGet5(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
  for (const content of newContent) {
    const snapshotContent = accumulatedMessage.content[content.index];
    if ((snapshotContent == null ? void 0 : snapshotContent.type) == "text") {
      this._emit("textCreated", snapshotContent.text);
    }
  }
  switch (event.event) {
    case "thread.message.created":
      this._emit("messageCreated", event.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      this._emit("messageDelta", event.data.delta, accumulatedMessage);
      if (event.data.delta.content) {
        for (const content of event.data.delta.content) {
          if (content.type == "text" && content.text) {
            let textDelta = content.text;
            let snapshot = accumulatedMessage.content[content.index];
            if (snapshot && snapshot.type == "text") {
              this._emit("textDelta", textDelta, snapshot.text);
            } else {
              throw Error("The snapshot associated with this text delta is not text or missing");
            }
          }
          if (content.index != __classPrivateFieldGet5(this, _AssistantStream_currentContentIndex, "f")) {
            if (__classPrivateFieldGet5(this, _AssistantStream_currentContent, "f")) {
              switch (__classPrivateFieldGet5(this, _AssistantStream_currentContent, "f").type) {
                case "text":
                  this._emit("textDone", __classPrivateFieldGet5(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", __classPrivateFieldGet5(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
            __classPrivateFieldSet4(this, _AssistantStream_currentContentIndex, content.index, "f");
          }
          __classPrivateFieldSet4(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
        }
      }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (__classPrivateFieldGet5(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
        const currentContent = event.data.content[__classPrivateFieldGet5(this, _AssistantStream_currentContentIndex, "f")];
        if (currentContent) {
          switch (currentContent.type) {
            case "image_file":
              this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
              break;
            case "text":
              this._emit("textDone", currentContent.text, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
              break;
          }
        }
      }
      if (__classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f")) {
        this._emit("messageDone", event.data);
      }
      __classPrivateFieldSet4(this, _AssistantStream_messageSnapshot, void 0, "f");
  }
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
  const accumulatedRunStep = __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
  __classPrivateFieldSet4(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
  switch (event.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", event.data);
      break;
    case "thread.run.step.delta":
      const delta = event.data.delta;
      if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
        for (const toolCall of delta.step_details.tool_calls) {
          if (toolCall.index == __classPrivateFieldGet5(this, _AssistantStream_currentToolCallIndex, "f")) {
            this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
          } else {
            if (__classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"));
            }
            __classPrivateFieldSet4(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
            __classPrivateFieldSet4(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
            if (__classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"))
              this._emit("toolCallCreated", __classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"));
          }
        }
      }
      this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldSet4(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
      const details = event.data.step_details;
      if (details.type == "tool_calls") {
        if (__classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet4(this, _AssistantStream_currentToolCall, void 0, "f");
        }
      }
      this._emit("runStepDone", event.data, accumulatedRunStep);
      break;
    case "thread.run.step.in_progress":
      break;
  }
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
  __classPrivateFieldGet5(this, _AssistantStream_events, "f").push(event);
  this._emit("event", event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
  switch (event.event) {
    case "thread.run.step.created":
      __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      return event.data;
    case "thread.run.step.delta":
      let snapshot = __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      if (!snapshot) {
        throw Error("Received a RunStepDelta before creation of a snapshot");
      }
      let data = event.data;
      if (data.delta) {
        const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);
        __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
      }
      return __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      break;
  }
  if (__classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
    return __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
  throw new Error("No snapshot available");
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
  let newContent = [];
  switch (event.event) {
    case "thread.message.created":
      return [event.data, newContent];
    case "thread.message.delta":
      if (!snapshot) {
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      }
      let data = event.data;
      if (data.delta.content) {
        for (const contentElement of data.delta.content) {
          if (contentElement.index in snapshot.content) {
            let currentContent = snapshot.content[contentElement.index];
            snapshot.content[contentElement.index] = __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
          } else {
            snapshot.content[contentElement.index] = contentElement;
            newContent.push(contentElement);
          }
        }
      }
      return [snapshot, newContent];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (snapshot) {
        return [snapshot, newContent];
      } else {
        throw Error("Received thread message event with no existing snapshot");
      }
  }
  throw Error("Tried to accumulate a non-message event");
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
  return AssistantStream.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
  __classPrivateFieldSet4(this, _AssistantStream_currentRunSnapshot, event.data, "f");
  switch (event.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
      __classPrivateFieldSet4(this, _AssistantStream_finalRun, event.data, "f");
      if (__classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f")) {
        this._emit("toolCallDone", __classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"));
        __classPrivateFieldSet4(this, _AssistantStream_currentToolCall, void 0, "f");
      }
      break;
    case "thread.run.cancelling":
      break;
  }
};

// node_modules/openai/resources/beta/threads/messages.mjs
var Messages = class extends APIResource {
  /**
   * Create a message.
   */
  create(threadId, body, options) {
    return this._client.post(`/threads/${threadId}/messages`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieve a message.
   */
  retrieve(threadId, messageId, options) {
    return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a message.
   */
  update(threadId, messageId, body, options) {
    return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Deletes a message.
   */
  del(threadId, messageId, options) {
    return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};
var MessagesPage = class extends CursorPage {
};
Messages.MessagesPage = MessagesPage;

// node_modules/openai/resources/beta/threads/runs/steps.mjs
var Steps = class extends APIResource {
  retrieve(threadId, runId, stepId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.retrieve(threadId, runId, stepId, {}, query);
    }
    return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, runId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, runId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};
var RunStepsPage = class extends CursorPage {
};
Steps.RunStepsPage = RunStepsPage;

// node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs = class extends APIResource {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadId, params, options) {
    var _a2;
    const { include, ...body } = params;
    return this._client.post(`/threads/${threadId}/runs`, {
      query: { include },
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
      stream: (_a2 = params.stream) != null ? _a2 : false
    });
  }
  /**
   * Retrieves a run.
   */
  retrieve(threadId, runId, options) {
    return this._client.get(`/threads/${threadId}/runs/${runId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a run.
   */
  update(threadId, runId, body, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   */
  cancel(threadId, runId, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(threadId, body, options) {
    const run = await this.create(threadId, body, options);
    return await this.poll(threadId, run.id, options);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(threadId, runId, options) {
    const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
    if (options == null ? void 0 : options.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const { data: run, response } = await this.retrieve(threadId, runId, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, ...headers }
      }).withResponse();
      switch (run.status) {
        case "queued":
        case "in_progress":
        case "cancelling":
          let sleepInterval = 5e3;
          if (options == null ? void 0 : options.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return run;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  submitToolOutputs(threadId, runId, body, options) {
    var _a2;
    return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
      stream: (_a2 = body.stream) != null ? _a2 : false
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(threadId, runId, body, options) {
    const run = await this.submitToolOutputs(threadId, runId, body, options);
    return await this.poll(threadId, run.id, options);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(threadId, runId, body, options) {
    return AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);
  }
};
var RunsPage = class extends CursorPage {
};
Runs.RunsPage = RunsPage;
Runs.Steps = Steps;
Runs.RunStepsPage = RunStepsPage;

// node_modules/openai/resources/beta/threads/threads.mjs
var Threads = class extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs(this._client);
    this.messages = new Messages(this._client);
  }
  create(body = {}, options) {
    if (isRequestOptions(body)) {
      return this.create({}, body);
    }
    return this._client.post("/threads", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a thread.
   */
  retrieve(threadId, options) {
    return this._client.get(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a thread.
   */
  update(threadId, body, options) {
    return this._client.post(`/threads/${threadId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete a thread.
   */
  del(threadId, options) {
    return this._client.delete(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  createAndRun(body, options) {
    var _a2;
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
      stream: (_a2 = body.stream) != null ? _a2 : false
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(body, options) {
    const run = await this.createAndRun(body, options);
    return await this.runs.poll(run.thread_id, run.id, options);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(body, options) {
    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
  }
};
Threads.Runs = Runs;
Threads.RunsPage = RunsPage;
Threads.Messages = Messages;
Threads.MessagesPage = MessagesPage;

// node_modules/openai/lib/Util.mjs
var allSettledWithThrow = async (promises) => {
  const results = await Promise.allSettled(promises);
  const rejected = results.filter((result) => result.status === "rejected");
  if (rejected.length) {
    for (const result of rejected) {
      console.error(result.reason);
    }
    throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
  }
  const values = [];
  for (const result of results) {
    if (result.status === "fulfilled") {
      values.push(result.value);
    }
  }
  return values;
};

// node_modules/openai/resources/beta/vector-stores/files.mjs
var Files = class extends APIResource {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/files`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(vectorStoreId, fileId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(vectorStoreId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(vectorStoreId, {}, query);
    }
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  del(vectorStoreId, fileId, options) {
    return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const file = await this.create(vectorStoreId, body, options);
    return await this.poll(vectorStoreId, file.id, options);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(vectorStoreId, fileId, options) {
    const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
    if (options == null ? void 0 : options.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const fileResponse = await this.retrieve(vectorStoreId, fileId, {
        ...options,
        headers
      }).withResponse();
      const file = fileResponse.data;
      switch (file.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options == null ? void 0 : options.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "failed":
        case "completed":
          return file;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(vectorStoreId, file, options) {
    const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
    return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(vectorStoreId, file, options) {
    const fileInfo = await this.upload(vectorStoreId, file, options);
    return await this.poll(vectorStoreId, fileInfo.id, options);
  }
};
var VectorStoreFilesPage = class extends CursorPage {
};
Files.VectorStoreFilesPage = VectorStoreFilesPage;

// node_modules/openai/resources/beta/vector-stores/file-batches.mjs
var FileBatches = class extends APIResource {
  /**
   * Create a vector store file batch.
   */
  create(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(vectorStoreId, batchId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(vectorStoreId, batchId, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const batch = await this.create(vectorStoreId, body);
    return await this.poll(vectorStoreId, batch.id, options);
  }
  listFiles(vectorStoreId, batchId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listFiles(vectorStoreId, batchId, {}, query);
    }
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, VectorStoreFilesPage, { query, ...options, headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers } });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(vectorStoreId, batchId, options) {
    const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
    if (options == null ? void 0 : options.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {
        ...options,
        headers
      }).withResponse();
      switch (batch.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options == null ? void 0 : options.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return batch;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
    var _a2;
    if (files == null || files.length == 0) {
      throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
    }
    const configuredConcurrency = (_a2 = options == null ? void 0 : options.maxConcurrency) != null ? _a2 : 5;
    const concurrencyLimit = Math.min(configuredConcurrency, files.length);
    const client = this._client;
    const fileIterator = files.values();
    const allFileIds = [...fileIds];
    async function processFiles(iterator) {
      for (let item of iterator) {
        const fileObj = await client.files.create({ file: item, purpose: "assistants" }, options);
        allFileIds.push(fileObj.id);
      }
    }
    const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
    await allSettledWithThrow(workers);
    return await this.createAndPoll(vectorStoreId, {
      file_ids: allFileIds
    });
  }
};

// node_modules/openai/resources/beta/vector-stores/vector-stores.mjs
var VectorStores = class extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files(this._client);
    this.fileBatches = new FileBatches(this._client);
  }
  /**
   * Create a vector store.
   */
  create(body, options) {
    return this._client.post("/vector_stores", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(vectorStoreId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a vector store.
   */
  update(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/vector_stores", VectorStoresPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete a vector store.
   */
  del(vectorStoreId, options) {
    return this._client.delete(`/vector_stores/${vectorStoreId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};
var VectorStoresPage = class extends CursorPage {
};
VectorStores.VectorStoresPage = VectorStoresPage;
VectorStores.Files = Files;
VectorStores.VectorStoreFilesPage = VectorStoreFilesPage;
VectorStores.FileBatches = FileBatches;

// node_modules/openai/resources/beta/beta.mjs
var Beta = class extends APIResource {
  constructor() {
    super(...arguments);
    this.realtime = new Realtime(this._client);
    this.vectorStores = new VectorStores(this._client);
    this.chat = new Chat2(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads(this._client);
  }
};
Beta.Realtime = Realtime;
Beta.VectorStores = VectorStores;
Beta.VectorStoresPage = VectorStoresPage;
Beta.Assistants = Assistants;
Beta.AssistantsPage = AssistantsPage;
Beta.Threads = Threads;

// node_modules/openai/resources/completions.mjs
var Completions3 = class extends APIResource {
  create(body, options) {
    var _a2;
    return this._client.post("/completions", { body, ...options, stream: (_a2 = body.stream) != null ? _a2 : false });
  }
};

// node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(body, options) {
    return this._client.post("/embeddings", { body, ...options });
  }
};

// node_modules/openai/resources/files.mjs
var Files2 = class extends APIResource {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 100 GB.
   *
   * The Assistants API supports files up to 2 million tokens and of specific file
   * types. See the
   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
   * details.
   *
   * The Fine-tuning API only supports `.jsonl` files. The input also has certain
   * required formats for fine-tuning
   * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
   * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   * models.
   *
   * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
   * has a specific required
   * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(body, options) {
    return this._client.post("/files", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileId, options) {
    return this._client.get(`/files/${fileId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/files", FileObjectsPage, { query, ...options });
  }
  /**
   * Delete a file.
   */
  del(fileId, options) {
    return this._client.delete(`/files/${fileId}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, {
      ...options,
      headers: { Accept: "application/binary", ...options == null ? void 0 : options.headers },
      __binaryResponse: true
    });
  }
  /**
   * Returns the contents of the specified file.
   *
   * @deprecated The `.content()` method should be used instead
   */
  retrieveContent(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, options);
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep2(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};
var FileObjectsPage = class extends CursorPage {
};
Files2.FileObjectsPage = FileObjectsPage;

// node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs
var Checkpoints = class extends APIResource {
  list(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, { query, ...options });
  }
};
var FineTuningJobCheckpointsPage = class extends CursorPage {
};
Checkpoints.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;

// node_modules/openai/resources/fine-tuning/jobs/jobs.mjs
var Jobs = class extends APIResource {
  constructor() {
    super(...arguments);
    this.checkpoints = new Checkpoints(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  retrieve(fineTuningJobId, options) {
    return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuningJobId, options) {
    return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
  }
  listEvents(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
      query,
      ...options
    });
  }
};
var FineTuningJobsPage = class extends CursorPage {
};
var FineTuningJobEventsPage = class extends CursorPage {
};
Jobs.FineTuningJobsPage = FineTuningJobsPage;
Jobs.FineTuningJobEventsPage = FineTuningJobEventsPage;
Jobs.Checkpoints = Checkpoints;
Jobs.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource {
  constructor() {
    super(...arguments);
    this.jobs = new Jobs(this._client);
  }
};
FineTuning.Jobs = Jobs;
FineTuning.FineTuningJobsPage = FineTuningJobsPage;
FineTuning.FineTuningJobEventsPage = FineTuningJobEventsPage;

// node_modules/openai/resources/images.mjs
var Images = class extends APIResource {
  /**
   * Creates a variation of a given image.
   */
  createVariation(body, options) {
    return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an edited or extended image given an original image and a prompt.
   */
  edit(body, options) {
    return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an image given a prompt.
   */
  generate(body, options) {
    return this._client.post("/images/generations", { body, ...options });
  }
};

// node_modules/openai/resources/models.mjs
var Models = class extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options) {
    return this._client.get(`/models/${model}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this._client.getAPIList("/models", ModelsPage, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(model, options) {
    return this._client.delete(`/models/${model}`, options);
  }
};
var ModelsPage = class extends Page {
};
Models.ModelsPage = ModelsPage;

// node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
};

// node_modules/openai/resources/uploads/parts.mjs
var Parts = class extends APIResource {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(uploadId, body, options) {
    return this._client.post(`/uploads/${uploadId}/parts`, multipartFormRequestOptions({ body, ...options }));
  }
};

// node_modules/openai/resources/uploads/uploads.mjs
var Uploads = class extends APIResource {
  constructor() {
    super(...arguments);
    this.parts = new Parts(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose`s, the correct `mime_type` must be specified. Please refer
   * to documentation for the supported MIME types for your use case:
   *
   * - [Assistants](https://platform.openai.com/docs/assistants/tools/file-search#supported-files)
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(body, options) {
    return this._client.post("/uploads", { body, ...options });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(uploadId, options) {
    return this._client.post(`/uploads/${uploadId}/cancel`, options);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(uploadId, body, options) {
    return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });
  }
};
Uploads.Parts = Parts;

// node_modules/openai/index.mjs
var _a;
var OpenAI = class extends APIClient {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = ((_a2) => (_a2 = readEnv("OPENAI_ORG_ID")) != null ? _a2 : null)(), project = ((_b) => (_b = readEnv("OPENAI_PROJECT_ID")) != null ? _b : null)(), ...opts } = {}) {
    var _a3;
    if (apiKey === void 0) {
      throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
    }
    const options = {
      apiKey,
      organization,
      project,
      ...opts,
      baseURL: baseURL || `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    super({
      baseURL: options.baseURL,
      timeout: (_a3 = options.timeout) != null ? _a3 : 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.completions = new Completions3(this);
    this.chat = new Chat(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files2(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.beta = new Beta(this);
    this.batches = new Batches(this);
    this.uploads = new Uploads(this);
    this._options = options;
    this.apiKey = apiKey;
    this.organization = organization;
    this.project = project;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      "OpenAI-Project": this.project,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
  stringifyQuery(query) {
    return stringify(query, { arrayFormat: "brackets" });
  }
};
_a = OpenAI;
OpenAI.OpenAI = _a;
OpenAI.DEFAULT_TIMEOUT = 6e5;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
OpenAI.toFile = toFile;
OpenAI.fileFromPath = fileFromPath;
OpenAI.Completions = Completions3;
OpenAI.Chat = Chat;
OpenAI.Embeddings = Embeddings;
OpenAI.Files = Files2;
OpenAI.FileObjectsPage = FileObjectsPage;
OpenAI.Images = Images;
OpenAI.Audio = Audio;
OpenAI.Moderations = Moderations;
OpenAI.Models = Models;
OpenAI.ModelsPage = ModelsPage;
OpenAI.FineTuning = FineTuning;
OpenAI.Beta = Beta;
OpenAI.Batches = Batches;
OpenAI.BatchesPage = BatchesPage;
OpenAI.Uploads = Uploads;
var openai_default = OpenAI;

// services/OpenAIService.ts
var import_obsidian2 = require("obsidian");
var OpenAIService = class {
  constructor(settings, errorHandler) {
    this.rateLimitDelay = 20;
    // ms between requests
    this.lastRequestTime = 0;
    this.settings = settings;
    this.errorHandler = errorHandler;
    if (!settings.apiKey) {
      console.warn("OpenAI API key is missing. OpenAIService will not be initialized.");
      this.client = null;
      return;
    }
    this.client = new openai_default({
      apiKey: settings.apiKey,
      dangerouslyAllowBrowser: true
      // Enable browser-like environment usage
    });
  }
  /**
   * Check if the service is initialized
   */
  isInitialized() {
    return this.client !== null;
  }
  /**
   * Creates embeddings for the given text chunks with rate limiting and retries
   */
  async createEmbeddings(chunks) {
    if (!this.client) {
      console.warn("OpenAIService is not initialized. Cannot create embeddings.");
      new import_obsidian2.Notice("OpenAI API key is missing. Please set it in the plugin settings.");
      return chunks.map(() => ({
        data: [],
        usage: { prompt_tokens: 0, total_tokens: 0 },
        model: "text-embedding-ada-002"
        // Default model to maintain output consistency
      }));
    }
    const embeddings = [];
    for (let i = 0; i < chunks.length; i++) {
      try {
        const timeSinceLastRequest = Date.now() - this.lastRequestTime;
        if (timeSinceLastRequest < this.rateLimitDelay) {
          await new Promise(
            (resolve) => setTimeout(resolve, this.rateLimitDelay - timeSinceLastRequest)
          );
        }
        const response = await this.client.embeddings.create({
          model: "text-embedding-ada-002",
          // Use the correct model
          input: chunks[i],
          encoding_format: "float"
        });
        this.lastRequestTime = Date.now();
        embeddings.push({
          data: [
            {
              embedding: response.data[0].embedding,
              index: i
            }
          ],
          usage: {
            prompt_tokens: response.usage.prompt_tokens,
            total_tokens: response.usage.total_tokens
          },
          model: response.model
        });
      } catch (error) {
        this.handleEmbeddingError(error, chunks[i]);
        embeddings.push({
          data: [],
          usage: { prompt_tokens: 0, total_tokens: 0 },
          model: "text-embedding-ada-002"
        });
      }
    }
    return embeddings;
  }
  /**
   * Handles various types of OpenAI API errors
   */
  handleEmbeddingError(error, chunk) {
    let errorMessage;
    if (error instanceof openai_default.APIError) {
      switch (error.status) {
        case 429:
          errorMessage = "Rate limit exceeded. Please try again later.";
          break;
        case 401:
          errorMessage = "Invalid API key. Please check your settings.";
          break;
        case 413:
          errorMessage = "Text chunk too large for embedding.";
          break;
        default:
          errorMessage = `OpenAI API error: ${error.message}`;
      }
    } else {
      errorMessage = `Unexpected error: ${error.message}`;
    }
    this.errorHandler.handleError(error, {
      context: "OpenAIService.createEmbeddings",
      metadata: {
        chunkPreview: chunk.substring(0, 100) + "..."
        // First 100 chars for context
      }
    });
    new import_obsidian2.Notice(`Error creating embedding: ${errorMessage}`);
  }
  /**
   * Updates service settings
   */
  updateSettings(settings) {
    this.settings = settings;
    if (!settings.apiKey) {
      console.warn("OpenAI API key is missing. OpenAIService will not be initialized.");
      this.client = null;
      return;
    }
    this.client = new openai_default({
      apiKey: settings.apiKey,
      dangerouslyAllowBrowser: true
      // Ensure this remains enabled
    });
  }
  /**
   * Updates rate limiting parameters
   */
  updateRateLimit(delayMs) {
    this.rateLimitDelay = delayMs;
  }
};

// services/QueueService.ts
var import_obsidian4 = require("obsidian");

// services/MetadataExtractor.ts
var import_obsidian3 = require("obsidian");
var MetadataExtractor = class {
  /**
   * Extracts all metadata from an Obsidian file
   */
  async extractMetadata(file, content) {
    const fileContent = content || await file.vault.read(file);
    const frontMatter = this.extractFrontMatter(fileContent);
    const metadata = {
      obsidianId: file.path,
      path: file.path,
      lastModified: file.stat.mtime,
      created: file.stat.ctime,
      size: file.stat.size,
      frontMatter,
      tags: this.extractTags(fileContent, frontMatter),
      links: this.extractLinks(fileContent),
      customMetadata: {}
    };
    const aliases = this.extractAliases(frontMatter);
    if (aliases.length > 0) {
      metadata.customMetadata.aliases = aliases;
    }
    const loc = this.extractSourceLocation(frontMatter);
    if (loc) {
      metadata.loc = loc;
    }
    if (frontMatter == null ? void 0 : frontMatter.source) {
      metadata.source = frontMatter.source;
    }
    if (frontMatter == null ? void 0 : frontMatter.file_id) {
      metadata.file_id = frontMatter.file_id;
    }
    if (frontMatter == null ? void 0 : frontMatter.blobType) {
      metadata.blobType = frontMatter.blobType;
    }
    return metadata;
  }
  /**
   * Extracts metadata from the provided content and merges it with the given base metadata and front matter.
   * This new method is used by the TextSplitter to enhance metadata based on parsed front matter.
   */
  async extractMetadataFromContent(content, baseMetadata, frontMatter) {
    const merged = { ...baseMetadata };
    if (frontMatter) {
      merged.frontMatter = frontMatter;
      if (frontMatter.tags) {
        merged.tags = Array.isArray(frontMatter.tags) ? frontMatter.tags : [frontMatter.tags];
      }
      if (frontMatter.aliases) {
        merged.customMetadata = merged.customMetadata || {};
        merged.customMetadata.aliases = Array.isArray(frontMatter.aliases) ? frontMatter.aliases : [frontMatter.aliases];
      }
    }
    return merged;
  }
  /**
   * Extracts YAML front matter from document content
   */
  extractFrontMatter(content) {
    try {
      const frontMatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if (!frontMatterMatch)
        return void 0;
      const yaml = frontMatterMatch[1];
      return (0, import_obsidian3.parseYaml)(yaml);
    } catch (error) {
      console.error("Error parsing frontmatter:", error);
      throw new Error(`${"YAML_PARSE_ERROR" /* YAML_PARSE_ERROR */}: ${error.message}`);
    }
  }
  /**
   * Extracts internal links from document content.
   */
  extractLinks(content) {
    const linkRegex = /\[\[(.*?)(?:\|.*?)?\]\]/g;
    const links = /* @__PURE__ */ new Set();
    let match;
    while ((match = linkRegex.exec(content)) !== null) {
      const link = match[1].split("|")[0];
      const cleanLink = this.cleanLink(link);
      if (cleanLink) {
        links.add(cleanLink);
      }
    }
    return Array.from(links);
  }
  /**
   * Cleans and normalizes a link path.
   */
  cleanLink(link) {
    let cleanLink = link.split("#")[0];
    cleanLink = cleanLink.split("?")[0];
    cleanLink = cleanLink.trim();
    return cleanLink;
  }
  /**
   * Extracts tags from both content and front matter.
   */
  extractTags(content, frontMatter) {
    const tags = /* @__PURE__ */ new Set();
    const tagRegex = /#([A-Za-z0-9/_-]+)/g;
    let match;
    while ((match = tagRegex.exec(content)) !== null) {
      tags.add(match[1]);
    }
    if (frontMatter == null ? void 0 : frontMatter.tags) {
      const frontMatterTags = Array.isArray(frontMatter.tags) ? frontMatter.tags : [frontMatter.tags];
      frontMatterTags.forEach((tag) => {
        if (typeof tag === "string") {
          const cleanTag = tag.startsWith("#") ? tag.slice(1) : tag;
          tags.add(cleanTag);
        }
      });
    }
    return Array.from(tags);
  }
  /**
   * Extracts aliases from front matter.
   */
  extractAliases(frontMatter) {
    if (!(frontMatter == null ? void 0 : frontMatter.aliases))
      return [];
    if (Array.isArray(frontMatter.aliases)) {
      return frontMatter.aliases.filter((alias) => typeof alias === "string");
    }
    if (typeof frontMatter.aliases === "string") {
      return [frontMatter.aliases];
    }
    return [];
  }
  /**
   * Extracts source location information from front matter.
   */
  extractSourceLocation(frontMatter) {
    var _a2, _b, _c, _d;
    if (!((_b = (_a2 = frontMatter == null ? void 0 : frontMatter.loc) == null ? void 0 : _a2.lines) == null ? void 0 : _b.from) || !((_d = (_c = frontMatter == null ? void 0 : frontMatter.loc) == null ? void 0 : _c.lines) == null ? void 0 : _d.to)) {
      return void 0;
    }
    return {
      lines: {
        from: Number(frontMatter.loc.lines.from),
        to: Number(frontMatter.loc.lines.to)
      }
    };
  }
};

// utils/TextSplitter.ts
var TextSplitter = class {
  constructor(settings, metadataExtractor) {
    // Regex patterns for splitting
    this.SENTENCE_BOUNDARY = /[.!?]\s+/;
    this.PARAGRAPH_BOUNDARY = /\n\s*\n/;
    this.YAML_FRONT_MATTER = /^---\n([\s\S]*?)\n---/;
    this.settings = settings || { ...DEFAULT_CHUNKING_OPTIONS };
    this.validateSettings(this.settings);
    this.metadataExtractor = metadataExtractor || new MetadataExtractor();
  }
  /** Returns the current chunking settings. */
  getSettings() {
    return this.settings;
  }
  validateSettings(settings) {
    if (settings.chunkSize <= 0) {
      throw new Error("Chunk size must be greater than 0.");
    }
    if (settings.chunkOverlap >= settings.chunkSize) {
      throw new Error("Chunk overlap must be less than chunk size.");
    }
    if (settings.minChunkSize > settings.chunkSize) {
      throw new Error("Minimum chunk size must not exceed chunk size.");
    }
  }
  /**
   * Splits a document into chunks while enhancing metadata.
   * Extracts YAML front matter if present, and then uses the MetadataExtractor
   * to merge additional metadata (e.g., tags, aliases, links) into the base metadata.
   *
   * @param content The full text content of the document.
   * @param metadata Base metadata for the document.
   * @param abortSignal Optional AbortSignal to cancel the operation.
   * @returns An array of DocumentChunk.
   */
  async splitDocument(content, metadata, abortSignal) {
    const performanceMetrics = {};
    const overallStart = performance.now();
    try {
      console.log("Starting document split", { contentLength: content.length, settings: this.settings });
      if (abortSignal == null ? void 0 : abortSignal.aborted) {
        throw new Error("Document splitting aborted before start");
      }
      if (!(content == null ? void 0 : content.trim())) {
        console.log("Empty content received");
        return [];
      }
      let frontMatter = null;
      const frontMatterMatch = this.YAML_FRONT_MATTER.exec(content);
      if (frontMatterMatch) {
        try {
          frontMatter = this.parseFrontMatter(frontMatterMatch[1]);
          const enhancedMetadata = await this.metadataExtractor.extractMetadataFromContent(
            content,
            metadata,
            frontMatter
          );
          metadata = { ...metadata, ...enhancedMetadata };
          console.log("Front matter extracted and metadata enhanced", { frontMatter });
        } catch (error) {
          console.warn("Failed to parse front matter", error);
        }
      }
      const trimmedContent = content.trim();
      if (abortSignal == null ? void 0 : abortSignal.aborted) {
        throw new Error("Document splitting aborted after front matter processing");
      }
      if (trimmedContent.length <= Math.max(this.settings.minChunkSize, this.settings.chunkSize)) {
        if (trimmedContent.length === 0) {
          console.log("No content after trimming, returning empty array");
          return [];
        }
        console.log("Content is smaller than chunk size, creating single chunk", {
          contentLength: trimmedContent.length,
          chunkSize: this.settings.chunkSize,
          minChunkSize: this.settings.minChunkSize
        });
        const singleChunk = this.createChunk(trimmedContent, 0, metadata);
        performanceMetrics.singleChunkTime = performance.now() - overallStart;
        console.log("Created single chunk", { chunkSize: singleChunk.content.length, preview: singleChunk.content.substring(0, 100) });
        console.log(`Document split completed in ${performance.now() - overallStart} ms`, performanceMetrics);
        return [singleChunk];
      }
      const paragraphs = content.split(this.PARAGRAPH_BOUNDARY).map((p) => p.trim()).filter((p) => p.length > 0);
      console.log("Split into paragraphs", { paragraphCount: paragraphs.length, paragraphs: paragraphs.map((p) => p.substring(0, 100)) });
      if (abortSignal == null ? void 0 : abortSignal.aborted) {
        throw new Error("Document splitting aborted after paragraph split");
      }
      let chunks = [];
      let currentChunk = "";
      let chunkIndex = 0;
      for (const paragraph of paragraphs) {
        if (abortSignal == null ? void 0 : abortSignal.aborted) {
          chunks = [];
          throw new Error("Document splitting aborted during processing");
        }
        if (paragraph.length >= this.settings.chunkSize) {
          if (currentChunk) {
            chunks.push(this.createChunk(currentChunk, chunkIndex++, metadata));
            currentChunk = "";
          }
          const sentences = paragraph.split(this.SENTENCE_BOUNDARY);
          let sentenceChunk = "";
          for (const sentence of sentences) {
            if (abortSignal == null ? void 0 : abortSignal.aborted) {
              chunks = [];
              throw new Error("Document splitting aborted during sentence processing");
            }
            const trimmedSentence = sentence.trim();
            if (!trimmedSentence)
              continue;
            if ((sentenceChunk + " " + trimmedSentence).length > this.settings.chunkSize) {
              if (sentenceChunk) {
                chunks.push(this.createChunk(sentenceChunk, chunkIndex++, metadata));
                sentenceChunk = trimmedSentence;
              } else {
                let position = 0;
                while (position < trimmedSentence.length) {
                  const chunkText = trimmedSentence.slice(
                    position,
                    Math.min(position + this.settings.chunkSize, trimmedSentence.length)
                  );
                  chunks.push(this.createChunk(chunkText, chunkIndex++, metadata));
                  position += this.settings.chunkSize;
                }
                sentenceChunk = "";
              }
            } else {
              sentenceChunk += (sentenceChunk ? " " : "") + trimmedSentence;
            }
          }
          if (sentenceChunk) {
            chunks.push(this.createChunk(sentenceChunk, chunkIndex++, metadata));
          }
        } else {
          const potentialChunkSize = currentChunk ? currentChunk.length + 2 + paragraph.length : paragraph.length;
          if (potentialChunkSize <= this.settings.chunkSize) {
            currentChunk += (currentChunk ? "\n\n" : "") + paragraph;
          } else {
            if (currentChunk) {
              chunks.push(this.createChunk(currentChunk, chunkIndex++, metadata));
            }
            currentChunk = paragraph;
          }
        }
      }
      if (currentChunk) {
        chunks.push(this.createChunk(currentChunk, chunkIndex++, metadata));
      }
      if (chunks.length === 0 && trimmedContent.length > 0) {
        console.log("Creating fallback chunk for content", { contentLength: trimmedContent.length });
        chunks.push(this.createChunk(trimmedContent, 0, metadata));
      }
      if (this.settings.chunkOverlap > 0 && chunks.length > 1) {
        chunks = this.applyOverlap(chunks);
      }
      performanceMetrics.totalSplittingTime = performance.now() - overallStart;
      console.log("Finished creating chunks", {
        chunkCount: chunks.length,
        chunkSizes: chunks.map((c) => c.content.length),
        chunkPreviews: chunks.map((c) => ({
          index: c.chunkIndex,
          size: c.content.length,
          preview: c.content.substring(0, 100)
        })),
        performanceMetrics
      });
      return chunks;
    } catch (error) {
      console.error("Error in splitDocument", error);
      throw {
        type: "CHUNKING_ERROR" /* CHUNKING_ERROR */,
        message: "Error occurred during document chunking",
        details: error.message
      };
    }
  }
  createChunk(content, index2, metadata) {
    const trimmedContent = content.trim();
    if (trimmedContent.length < this.settings.minChunkSize) {
      console.warn("Chunk smaller than minChunkSize", {
        size: trimmedContent.length,
        minSize: this.settings.minChunkSize
      });
    }
    return {
      content: trimmedContent,
      chunkIndex: index2,
      metadata: { ...metadata }
    };
  }
  applyOverlap(chunks) {
    if (chunks.length <= 1)
      return chunks;
    const chunksWithOverlap = [...chunks];
    for (let i = chunksWithOverlap.length - 1; i > 0; i--) {
      const currentChunk = { ...chunksWithOverlap[i] };
      const previousChunk = chunksWithOverlap[i - 1];
      const overlapText = previousChunk.content.slice(-this.settings.chunkOverlap);
      if (overlapText) {
        chunksWithOverlap[i] = {
          ...currentChunk,
          content: overlapText + "\n\n" + currentChunk.content
        };
      }
    }
    return chunksWithOverlap;
  }
  parseFrontMatter(frontMatter) {
    try {
      const result = {};
      const lines = frontMatter.split("\n");
      for (const line of lines) {
        const trimmedLine = line.trim();
        if (!trimmedLine || trimmedLine.startsWith("#"))
          continue;
        const separatorIndex = line.indexOf(":");
        if (separatorIndex === -1)
          continue;
        const key = line.slice(0, separatorIndex).trim();
        let value = line.slice(separatorIndex + 1).trim();
        value = value.replace(/^["'](.*)["']$/, "$1");
        if (value.startsWith("- ")) {
          result[key] = value.split("\n").map((item) => item.replace("- ", "").trim()).filter(Boolean);
        } else {
          result[key] = value;
        }
      }
      return result;
    } catch (error) {
      console.warn("Failed to parse front matter", error);
      return {};
    }
  }
};

// services/EventEmitter.ts
var EventEmitter = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
  }
  /**
   * Emit an event with associated data.
   * Listeners registered for this event will be called with the data.
   */
  emit(event, data) {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      for (const callback of callbacks) {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in listener for event "${event}":`, error);
        }
      }
    }
  }
  /**
   * Register a callback to be invoked when the specified event is emitted.
   * Returns an unsubscribe function.
   */
  on(event, callback) {
    var _a2;
    if (!this.listeners.has(event)) {
      this.listeners.set(event, /* @__PURE__ */ new Set());
    }
    (_a2 = this.listeners.get(event)) == null ? void 0 : _a2.add(callback);
    return () => {
      var _a3;
      (_a3 = this.listeners.get(event)) == null ? void 0 : _a3.delete(callback);
    };
  }
};

// services/QueueService.ts
var QueueService = class {
  constructor(maxConcurrent, maxRetries, supabaseService, openAIService, errorHandler, notificationManager, vault, chunkSettings) {
    this.maxConcurrent = maxConcurrent;
    this.maxRetries = maxRetries;
    this.supabaseService = supabaseService;
    this.openAIService = openAIService;
    this.errorHandler = errorHandler;
    this.notificationManager = notificationManager;
    this.queue = [];
    this.processingQueue = [];
    this.isProcessing = false;
    this.isStopped = true;
    this.processingInterval = null;
    this.vault = vault;
    const validatedChunkSettings = chunkSettings || { ...DEFAULT_CHUNKING_OPTIONS };
    try {
      this.textSplitter = new TextSplitter(validatedChunkSettings);
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "QueueService.constructor",
        metadata: validatedChunkSettings
      });
      throw new Error("Failed to initialize TextSplitter with provided settings.");
    }
    this.eventEmitter = new EventEmitter();
  }
  start() {
    if (!this.isStopped)
      return;
    this.isStopped = false;
    this.processQueue();
    this.processingInterval = setInterval(() => {
      if (!this.isProcessing) {
        this.processQueue();
      }
    }, 1e3);
    this.eventEmitter.emit("queue-status", {
      queueSize: this.queue.length,
      pendingChanges: 0,
      processingCount: this.processingQueue.length,
      status: "processing"
    });
  }
  stop() {
    this.isStopped = true;
    if (this.processingInterval) {
      clearInterval(this.processingInterval);
      this.processingInterval = null;
    }
    this.eventEmitter.emit("queue-status", {
      queueSize: this.queue.length,
      pendingChanges: 0,
      processingCount: this.processingQueue.length,
      status: "paused"
    });
  }
  async addTask(task) {
    if (this.queue.length >= 1e3) {
      throw new Error("QUEUE_FULL" /* QUEUE_FULL */);
    }
    console.log("Adding task to queue:", { id: task.id, type: task.type, priority: task.priority });
    const existingTaskIndex = this.queue.findIndex((t) => t.id === task.id);
    const processingTaskIndex = this.processingQueue.findIndex((t) => t.id === task.id);
    if (task.type === "DELETE" /* DELETE */) {
      task.priority = 3;
      if (processingTaskIndex >= 0) {
        const processingTask = this.processingQueue[processingTaskIndex];
        if (processingTask.type !== "DELETE" /* DELETE */) {
          console.log(`Conflict in processing for ${task.id}. Marking existing task as CANCELLED.`);
          processingTask.status = "CANCELLED" /* CANCELLED */;
        }
      }
      if (existingTaskIndex >= 0) {
        const existingTask = this.queue[existingTaskIndex];
        if (existingTask.type === "DELETE" /* DELETE */) {
          console.log(`Duplicate DELETE task for ${task.id}. Ignoring.`);
          return;
        } else {
          console.log(`Replacing existing ${existingTask.type} task for ${task.id} with DELETE task.`);
          this.queue.splice(existingTaskIndex, 1);
        }
      }
      this.queue.unshift(task);
    } else {
      const hasDeleteTask = this.queue.some((t) => t.id === task.id && t.type === "DELETE" /* DELETE */);
      if (hasDeleteTask) {
        console.log(`Skipping ${task.type} for ${task.id} as DELETE is pending.`);
        return;
      }
      if (existingTaskIndex >= 0) {
        console.log(`Replacing existing task for ${task.id} with new ${task.type} task.`);
        this.queue[existingTaskIndex] = task;
      } else {
        if (task.priority >= 2) {
          this.queue.unshift(task);
        } else {
          this.queue.push(task);
        }
      }
    }
    this.eventEmitter.emit("queue-progress", {
      processed: 0,
      total: this.queue.length,
      currentTask: task.id
    });
    if (!this.isProcessing && !this.isStopped) {
      this.processQueue();
    }
  }
  async processQueue() {
    if (this.isProcessing || this.isStopped || this.queue.length === 0) {
      return;
    }
    this.isProcessing = true;
    try {
      this.queue.sort((a, b) => {
        if (b.priority !== a.priority)
          return b.priority - a.priority;
        if (a.type === "DELETE" /* DELETE */ && b.type !== "DELETE" /* DELETE */)
          return -1;
        if (b.type === "DELETE" /* DELETE */ && a.type !== "DELETE" /* DELETE */)
          return 1;
        return a.createdAt - b.createdAt;
      });
      const tasksByFile = /* @__PURE__ */ new Map();
      this.queue.forEach((task) => {
        if (!tasksByFile.has(task.id)) {
          tasksByFile.set(task.id, []);
        }
        tasksByFile.get(task.id).push(task);
      });
      let tasksToProcess = [];
      for (const [fileId, fileTasks] of tasksByFile.entries()) {
        if (fileTasks.length > 1) {
          console.log(`Detected ${fileTasks.length} tasks for ${fileId}, resolving collisions.`);
          const deleteTask = fileTasks.find((t) => t.type === "DELETE" /* DELETE */);
          if (deleteTask) {
            tasksToProcess.push(deleteTask);
            this.queue = this.queue.filter((t) => t.id !== fileId);
            console.log(`Keeping only DELETE task for ${fileId}`);
          } else {
            const mostRecentTask = fileTasks.reduce((latest, current) => current.updatedAt > latest.updatedAt ? current : latest, fileTasks[0]);
            tasksToProcess.push(mostRecentTask);
            this.queue = this.queue.filter((t) => t.id !== fileId || t === mostRecentTask);
            console.log(`Keeping most recent task for ${fileId}`);
          }
        }
      }
      for (const task of this.queue) {
        if (tasksToProcess.some((t) => t.id === task.id))
          continue;
        tasksToProcess.push(task);
        if (tasksToProcess.length + this.processingQueue.length >= this.maxConcurrent) {
          break;
        }
      }
      for (const task of tasksToProcess) {
        const index2 = this.queue.indexOf(task);
        if (index2 !== -1) {
          this.queue.splice(index2, 1);
        }
      }
      for (const task of tasksToProcess) {
        if (this.processingQueue.length >= this.maxConcurrent) {
          this.queue.unshift(task);
          continue;
        }
        this.processingQueue.push(task);
        this.processTask(task).catch((error) => {
          this.handleTaskError(task, error);
        });
      }
      this.eventEmitter.emit("queue-status", {
        queueSize: this.queue.length,
        pendingChanges: this.queue.length + this.processingQueue.length,
        processingCount: this.processingQueue.length,
        status: "processing"
      });
    } catch (error) {
      this.errorHandler.handleError(error, { context: "QueueService.processQueue" });
    } finally {
      this.isProcessing = false;
      if (this.queue.length > 0 && !this.isStopped) {
        setTimeout(() => this.processQueue(), 100);
      }
    }
  }
  async processTask(task) {
    console.log("Processing task:", { id: task.id, type: task.type, status: task.status });
    try {
      task.status = "PROCESSING" /* PROCESSING */;
      task.startedAt = Date.now();
      this.notifyProgress(task.id, 0, `Starting ${task.type.toLowerCase()}`);
      switch (task.type) {
        case "CREATE" /* CREATE */:
        case "UPDATE" /* UPDATE */:
          await this.processCreateUpdateTask(task);
          break;
        case "DELETE" /* DELETE */:
          await this.processDeleteTask(task);
          break;
        default:
          throw new Error(`Unsupported task type: ${task.type}`);
      }
      task.status = "COMPLETED" /* COMPLETED */;
      task.completedAt = Date.now();
      this.notifyProgress(task.id, 100, "Task completed");
      console.log("Task completed successfully:", task.id);
      this.eventEmitter.emit("queue-progress", {
        processed: 1,
        total: this.queue.length + 1,
        currentTask: task.id
      });
    } catch (error) {
      console.error("Error processing task:", { taskId: task.id, error });
      await this.handleTaskError(task, error);
    } finally {
      this.removeFromProcessingQueue(task);
    }
  }
  async processCreateUpdateTask(task) {
    if (!this.supabaseService || !this.openAIService) {
      throw new Error("Required services not initialized");
    }
    try {
      console.log("Reading file:", task.id);
      const file = this.vault.getAbstractFileByPath(task.id);
      if (!(file instanceof import_obsidian4.TFile)) {
        throw new Error(`File not found or not a TFile: ${task.id}`);
      }
      const timings = {
        start: Date.now(),
        readComplete: 0,
        chunkingComplete: 0,
        embeddingComplete: 0,
        saveComplete: 0
      };
      const content = await this.vault.read(file);
      timings.readComplete = Date.now();
      console.log("File content read:", {
        fileId: task.id,
        contentLength: content.length,
        readTime: timings.readComplete - timings.start
      });
      this.notifyProgress(task.id, 20, "Splitting content");
      const chunks = await this.textSplitter.splitDocument(content, task.metadata);
      timings.chunkingComplete = Date.now();
      if (!chunks || !Array.isArray(chunks) || chunks.length === 0) {
        console.log("No valid chunks created for file:", {
          fileId: task.id,
          contentLength: content.length,
          settings: this.textSplitter.getSettings()
        });
        if (this.supabaseService) {
          await this.supabaseService.updateFileVectorizationStatus(task.metadata);
        }
        return;
      }
      console.log("Content split into chunks:", {
        numberOfChunks: chunks.length,
        chunkSizes: chunks.map((c) => c.content.length),
        chunkingTime: timings.chunkingComplete - timings.readComplete
      });
      this.notifyProgress(task.id, 40, "Generating embeddings");
      for (let i = 0; i < chunks.length; i++) {
        const embedProgress = Math.floor(40 + i / chunks.length * 30);
        this.notifyProgress(task.id, embedProgress, `Generating embedding ${i + 1}/${chunks.length}`);
        const response = await this.openAIService.createEmbeddings([chunks[i].content]);
        if (response.length > 0 && response[0].data.length > 0) {
          chunks[i].embedding = response[0].data[0].embedding;
          chunks[i].vectorized_at = new Date().toISOString();
          console.log(`Generated embedding for chunk ${i + 1}/${chunks.length}`);
        } else {
          throw new Error(`Failed to generate embedding for chunk ${i + 1}`);
        }
      }
      timings.embeddingComplete = Date.now();
      const enhancedChunks = chunks.map((chunk) => ({
        ...chunk,
        metadata: {
          ...chunk.metadata,
          aliases: chunk.metadata.aliases || [],
          links: chunk.metadata.links || [],
          tags: chunk.metadata.tags || []
        }
      }));
      this.notifyProgress(task.id, 70, "Saving to database");
      let saveAttempts = 0;
      const maxSaveAttempts = 3;
      let savedSuccessfully = false;
      while (!savedSuccessfully && saveAttempts < maxSaveAttempts) {
        try {
          await this.supabaseService.upsertChunks(enhancedChunks);
          savedSuccessfully = true;
        } catch (saveError) {
          saveAttempts++;
          console.error(`Error saving chunks (attempt ${saveAttempts}/${maxSaveAttempts}):`, saveError);
          if (saveAttempts >= maxSaveAttempts)
            throw saveError;
          const backoffTime = Math.pow(2, saveAttempts) * 1e3;
          this.notifyProgress(task.id, 70, `Retrying database save in ${backoffTime / 1e3}s`);
          await new Promise((resolve) => setTimeout(resolve, backoffTime));
        }
      }
      timings.saveComplete = Date.now();
      console.log("Chunks saved to database:", {
        numberOfChunks: enhancedChunks.length,
        fileId: task.id,
        timings: {
          total: timings.saveComplete - timings.start,
          read: timings.readComplete - timings.start,
          chunking: timings.chunkingComplete - timings.readComplete,
          embedding: timings.embeddingComplete - timings.chunkingComplete,
          save: timings.saveComplete - timings.embeddingComplete
        }
      });
      this.notifyProgress(task.id, 100, "Processing completed");
    } catch (error) {
      console.error("Error in processCreateUpdateTask:", { error, taskId: task.id, metadata: task.metadata });
      throw error;
    }
  }
  async processDeleteTask(task) {
    if (!this.supabaseService)
      throw new Error("Supabase service not initialized");
    try {
      this.notifyProgress(task.id, 10, "Starting deletion process");
      console.log(`Checking document before deletion: ${task.metadata.obsidianId}`);
      const chunks = await this.supabaseService.getDocumentChunks(task.metadata.obsidianId);
      const chunkCount = chunks.length;
      if (chunkCount > 0) {
        console.log(`Found ${chunkCount} chunks to delete for ${task.metadata.obsidianId}`);
        this.notifyProgress(task.id, 30, `Deleting ${chunkCount} chunks`);
      } else {
        console.log(`No chunks found for deletion: ${task.metadata.obsidianId}`);
        this.notifyProgress(task.id, 30, "No chunks to delete");
      }
      let deleteAttempts = 0;
      const maxDeleteAttempts = 3;
      let deletedSuccessfully = false;
      while (!deletedSuccessfully && deleteAttempts < maxDeleteAttempts) {
        try {
          this.notifyProgress(task.id, 50, deleteAttempts > 0 ? `Deletion attempt ${deleteAttempts + 1}/${maxDeleteAttempts}` : "Deleting from database");
          await this.supabaseService.deleteDocumentChunks(task.metadata.obsidianId);
          deletedSuccessfully = true;
          const remainingChunks = await this.supabaseService.getDocumentChunks(task.metadata.obsidianId);
          if (remainingChunks.length > 0) {
            console.warn(`Deletion verification failed: ${remainingChunks.length} chunks still exist`);
            deletedSuccessfully = false;
            throw new Error(`Deletion verification failed for ${task.metadata.obsidianId}`);
          }
        } catch (deleteError) {
          deleteAttempts++;
          console.error(`Error deleting chunks (attempt ${deleteAttempts}/${maxDeleteAttempts}):`, deleteError);
          if (deleteAttempts >= maxDeleteAttempts)
            throw deleteError;
          const backoffTime = Math.pow(2, deleteAttempts) * 1e3;
          this.notifyProgress(task.id, 50, `Will retry deletion in ${backoffTime / 1e3}s`);
          await new Promise((resolve) => setTimeout(resolve, backoffTime));
        }
      }
      this.notifyProgress(task.id, 80, "Updating file status");
      await this.supabaseService.updateFileStatusOnDelete(task.metadata.obsidianId);
      this.notifyProgress(task.id, 100, "Delete completed");
      console.log(`Successfully deleted document: ${task.metadata.obsidianId}`);
    } catch (error) {
      console.error("Error in processDeleteTask:", { error, taskId: task.id, metadata: task.metadata });
      throw error;
    }
  }
  async handleTaskError(task, error) {
    task.retryCount = (task.retryCount || 0) + 1;
    task.updatedAt = Date.now();
    if (task.retryCount < this.maxRetries) {
      task.status = "RETRYING" /* RETRYING */;
      this.queue.unshift(task);
      this.notifyProgress(task.id, 0, `Retry attempt ${task.retryCount}`);
      console.log("Task queued for retry:", { taskId: task.id, retryCount: task.retryCount, maxRetries: this.maxRetries });
    } else {
      task.status = "FAILED" /* FAILED */;
      task.error = {
        message: error.message,
        code: error.code || "UNKNOWN_ERROR",
        stack: error.stack
      };
      task.completedAt = Date.now();
      console.error("Task failed after max retries:", { taskId: task.id, error: task.error });
    }
    this.errorHandler.handleError(error, { context: "QueueService.processTask", taskId: task.id, taskType: task.type });
    this.eventEmitter.emit("queue-progress", { processed: 0, total: this.queue.length, currentTask: task.id });
  }
  removeFromProcessingQueue(task) {
    const index2 = this.processingQueue.findIndex((t) => t.id === task.id);
    if (index2 !== -1) {
      this.processingQueue.splice(index2, 1);
    }
  }
  notifyProgress(taskId, progress, message) {
    this.notificationManager.updateProgress({
      taskId,
      progress,
      currentStep: message,
      totalSteps: 1,
      currentStepNumber: 1
    });
    this.eventEmitter.emit("queue-progress", { processed: progress, total: 100, currentTask: taskId });
  }
  getQueueStats() {
    const now = Date.now();
    const oneHour = 60 * 60 * 1e3;
    const tasksByStatus = this.queue.reduce((acc, task) => {
      acc[task.status] = (acc[task.status] || 0) + 1;
      return acc;
    }, {});
    const tasksByType = this.queue.reduce((acc, task) => {
      acc[task.type] = (acc[task.type] || 0) + 1;
      return acc;
    }, {});
    const completedTasks = this.queue.filter((task) => task.status === "COMPLETED" /* COMPLETED */ && task.completedAt);
    const averageTime = completedTasks.length > 0 ? completedTasks.reduce((sum, task) => sum + (task.completedAt - task.startedAt), 0) / completedTasks.length : 0;
    const tasksLastHour = completedTasks.filter((task) => task.completedAt > now - oneHour).length;
    return {
      totalTasks: this.queue.length,
      tasksByStatus,
      tasksByType,
      averageProcessingTime: averageTime,
      failedTasks: tasksByStatus["FAILED" /* FAILED */] || 0,
      retryingTasks: tasksByStatus["RETRYING" /* RETRYING */] || 0,
      tasksLastHour
    };
  }
  clear() {
    this.queue = [];
    this.processingQueue = [];
    this.notificationManager.clear();
  }
  updateSettings(settings) {
    this.maxConcurrent = settings.maxConcurrent;
    this.maxRetries = settings.maxRetries;
    if (settings.chunkSettings) {
      this.textSplitter = new TextSplitter(settings.chunkSettings);
    }
  }
  /**
   * Subscribe to queue events.
   * @param eventName The event to subscribe to.
   * @param callback The callback function.
   */
  on(eventName, callback) {
    return this.eventEmitter.on(eventName, callback);
  }
};

// utils/FileTracker.ts
var import_obsidian6 = require("obsidian");

// services/SyncFileManager.ts
var import_obsidian5 = require("obsidian");

// models/SyncModels.ts
var SyncErrorType = /* @__PURE__ */ ((SyncErrorType2) => {
  SyncErrorType2["SYNC_FILE_MISSING"] = "sync_file_missing";
  SyncErrorType2["SYNC_FILE_CORRUPT"] = "sync_file_corrupt";
  SyncErrorType2["SYNC_FILE_OUTDATED"] = "sync_file_outdated";
  SyncErrorType2["DEVICE_MISMATCH"] = "device_mismatch";
  SyncErrorType2["CONFLICT_DETECTED"] = "conflict_detected";
  SyncErrorType2["DATABASE_UNAVAILABLE"] = "database_unavailable";
  SyncErrorType2["SYNC_INTERRUPTED"] = "sync_interrupted";
  SyncErrorType2["UNKNOWN_ERROR"] = "unknown_error";
  return SyncErrorType2;
})(SyncErrorType || {});
var MAX_CONNECTION_EVENTS = 20;
var MAX_PENDING_OPERATIONS = 100;
var MAX_CONFLICTS = 50;
function getPlatformInfo() {
  const userAgent = window.navigator.userAgent;
  if (userAgent.indexOf("Win") !== -1)
    return "Windows";
  if (userAgent.indexOf("Mac") !== -1)
    return "macOS";
  if (userAgent.indexOf("iPhone") !== -1 || userAgent.indexOf("iPad") !== -1)
    return "iOS";
  if (userAgent.indexOf("Android") !== -1)
    return "Android";
  if (userAgent.indexOf("Linux") !== -1)
    return "Linux";
  return "Unknown";
}
function createEmptySyncFileData(vaultId, deviceId, deviceName, pluginVersion) {
  const now = Date.now();
  const platform = getPlatformInfo();
  const device = {
    deviceId,
    name: deviceName,
    platform,
    lastSeen: now,
    lastSyncTime: now
  };
  const devices = {};
  devices[deviceId] = device;
  return {
    header: {
      lastGlobalSync: now,
      syncState: "initializing" /* INITIALIZING */,
      vaultId,
      pluginVersion,
      lastWriter: deviceId,
      devices
    },
    connectionEvents: [],
    pendingOperations: [],
    conflicts: [],
    lastDatabaseCheck: now,
    databaseStatus: "unknown"
  };
}
function trimSyncHistoryArrays(data) {
  return {
    ...data,
    connectionEvents: data.connectionEvents.slice(-MAX_CONNECTION_EVENTS),
    pendingOperations: data.pendingOperations.slice(-MAX_PENDING_OPERATIONS),
    conflicts: data.conflicts.slice(-MAX_CONFLICTS)
  };
}
function updateDeviceInSyncFile(data, deviceId, deviceName, pluginVersion) {
  const now = Date.now();
  const platform = getPlatformInfo();
  const newData = JSON.parse(JSON.stringify(data));
  if (!newData.header.devices) {
    newData.header.devices = {};
  }
  if (newData.header.devices[deviceId]) {
    newData.header.devices[deviceId] = {
      ...newData.header.devices[deviceId],
      name: deviceName,
      platform,
      lastSeen: now,
      pluginVersion: pluginVersion || newData.header.devices[deviceId].pluginVersion
    };
  } else {
    newData.header.devices[deviceId] = {
      deviceId,
      name: deviceName,
      platform,
      lastSeen: now,
      lastSyncTime: now,
      pluginVersion
    };
  }
  newData.header.lastWriter = deviceId;
  if (pluginVersion) {
    newData.header.pluginVersion = pluginVersion;
  }
  return newData;
}
function updateDatabaseStatus(data, status) {
  const newData = JSON.parse(JSON.stringify(data));
  newData.databaseStatus = status;
  newData.lastDatabaseCheck = Date.now();
  if (status === "unavailable") {
    newData.header.syncState = "offline" /* OFFLINE */;
  } else if (status === "available") {
    newData.header.syncState = "online" /* ONLINE */;
  }
  return newData;
}
function updateDeviceSyncTime(data, deviceId) {
  const newData = JSON.parse(JSON.stringify(data));
  const now = Date.now();
  if (newData.header.devices && newData.header.devices[deviceId]) {
    newData.header.devices[deviceId].lastSyncTime = now;
    newData.header.devices[deviceId].lastSeen = now;
    newData.header.lastGlobalSync = now;
  }
  return newData;
}

// services/SyncFileManager.ts
var SyncFileManager = class {
  constructor(vault, errorHandler, syncFilePath = "_mindmatrixsync.md", backupInterval = 36e5, vaultId, deviceId, deviceName, pluginVersion) {
    this.vault = vault;
    this.errorHandler = errorHandler;
    this.lastBackup = 0;
    this.syncFile = null;
    this.currentSyncData = null;
    this.syncFilePath = syncFilePath;
    this.backupPath = `${syncFilePath}.backup`;
    this.backupInterval = backupInterval;
    this.vaultId = vaultId;
    this.deviceId = deviceId;
    this.deviceName = deviceName;
    this.pluginVersion = pluginVersion;
  }
  /**
   * Initialize or validate the sync file
   */
  async initialize() {
    try {
      const existingFile = this.vault.getAbstractFileByPath(this.syncFilePath);
      if (existingFile instanceof import_obsidian5.TFile) {
        this.syncFile = existingFile;
        const validationResult = await this.validateSyncFile();
        if (!validationResult.isValid) {
          const recovered = await this.repairSyncFile();
          if (!recovered) {
            await this.createSyncFile();
          }
        }
      } else {
        await this.createSyncFile();
      }
      await this.createBackup();
      return await this.validateSyncFile();
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.initialize",
        metadata: { syncFilePath: this.syncFilePath }
      });
      try {
        await this.createSyncFile();
        return { isValid: true };
      } catch (createError) {
        return {
          isValid: false,
          error: `Failed to initialize sync file: ${createError.message}`
        };
      }
    }
  }
  /**
   * Create a new sync file with the new structure
   */
  async createSyncFile() {
    console.log("Starting sync file creation with wait periods...");
    const FILE_OP_DELAY = 1e3;
    const existingFile = this.vault.getAbstractFileByPath(this.syncFilePath);
    this.currentSyncData = createEmptySyncFileData(
      this.vaultId,
      this.deviceId,
      this.deviceName,
      this.pluginVersion
    );
    const initialContent = this.generateSyncFileContent(this.currentSyncData);
    if (existingFile instanceof import_obsidian5.TFile) {
      try {
        console.log("Existing sync file found, attempting to modify it");
        this.syncFile = existingFile;
        await this.vault.modify(existingFile, initialContent);
        console.log("Successfully modified existing sync file");
        await new Promise((resolve) => setTimeout(resolve, FILE_OP_DELAY));
        return;
      } catch (modifyError) {
        console.warn("Failed to modify existing sync file, will try delete and recreate:", modifyError);
        try {
          await this.vault.delete(existingFile);
          await new Promise((resolve) => setTimeout(resolve, FILE_OP_DELAY));
        } catch (deleteError) {
          console.error("Failed to delete existing sync file:", deleteError);
          throw new Error(`Cannot modify or delete sync file: ${modifyError.message}, ${deleteError.message}`);
        }
      }
    }
    console.log("Waiting before creating sync file...");
    await new Promise((resolve) => setTimeout(resolve, FILE_OP_DELAY));
    let createAttempts = 0;
    const maxAttempts = 3;
    while (createAttempts < maxAttempts) {
      try {
        this.syncFile = await this.vault.create(this.syncFilePath, initialContent);
        console.log("Sync file created successfully");
        break;
      } catch (createError) {
        createAttempts++;
        console.warn(`Create attempt ${createAttempts} failed:`, createError);
        if (createAttempts >= maxAttempts) {
          const finalCheck = this.vault.getAbstractFileByPath(this.syncFilePath);
          if (finalCheck instanceof import_obsidian5.TFile) {
            console.log("Sync file exists despite creation error, using it");
            this.syncFile = finalCheck;
            return;
          }
          throw new Error(`Failed to create sync file after ${maxAttempts} attempts: ${createError.message}`);
        }
        const waitTime = FILE_OP_DELAY * (createAttempts + 1);
        console.log(`Waiting ${waitTime}ms before retry...`);
        await new Promise((resolve) => setTimeout(resolve, waitTime));
      }
    }
    const fileExists = this.vault.getAbstractFileByPath(this.syncFilePath);
    if (!fileExists) {
      throw this.errorHandler.handleSyncError(
        "sync_file_missing" /* SYNC_FILE_MISSING */,
        "Sync file creation failed - file not found after wait period",
        { context: "SyncFileManager.createSyncFile" },
        void 0,
        this.deviceId,
        false
      );
    }
    console.log("Sync file creation completed successfully");
  }
  /**
   * Generate sync file content from data
   */
  generateSyncFileContent(data) {
    const yamlContent = (0, import_obsidian5.stringifyYaml)(data);
    return `---
${yamlContent}---

## Mind Matrix Sync File

This file manages cross-device coordination for the Mind Matrix plugin.
Do not modify this file manually.
`;
  }
  /**
   * Validate sync file structure and content
   */
  async validateSyncFile() {
    if (!this.syncFile) {
      return {
        isValid: false,
        error: "Sync file not initialized"
      };
    }
    try {
      const content = await this.vault.read(this.syncFile);
      const yamlMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if (!yamlMatch) {
        console.log("Invalid sync file format: Missing YAML front matter. Will recreate file.");
        await this.createSyncFile();
        return { isValid: true };
      }
      const yamlContent = yamlMatch[1];
      let parsedData;
      try {
        parsedData = (0, import_obsidian5.parseYaml)(yamlContent);
      } catch (parseError) {
        console.log("Failed to parse YAML content:", parseError);
        await this.createSyncFile();
        return { isValid: true };
      }
      if (!parsedData || typeof parsedData !== "object") {
        console.log("Invalid sync file format: Cannot parse YAML content. Will recreate file.");
        await this.createSyncFile();
        return { isValid: true };
      }
      if (content.includes("| File Path | Last Modified |")) {
        console.log("Detected old format sync file. Will convert to new format.");
        await this.createSyncFile();
        return { isValid: true };
      }
      if (!parsedData.header || !parsedData.header.vaultId || !parsedData.header.lastGlobalSync || !parsedData.header.devices) {
        console.log("Invalid sync file format: Missing required fields. Will recreate file.");
        await this.createSyncFile();
        return { isValid: true };
      }
      if (parsedData.header.vaultId !== this.vaultId) {
        console.log("Vault ID mismatch. Old ID:", parsedData.header.vaultId, "New ID:", this.vaultId);
        parsedData.header.vaultId = this.vaultId;
      }
      this.currentSyncData = parsedData;
      if (!this.currentSyncData.connectionEvents)
        this.currentSyncData.connectionEvents = [];
      if (!this.currentSyncData.pendingOperations)
        this.currentSyncData.pendingOperations = [];
      if (!this.currentSyncData.conflicts)
        this.currentSyncData.conflicts = [];
      if (!this.currentSyncData.lastDatabaseCheck)
        this.currentSyncData.lastDatabaseCheck = Date.now();
      if (!this.currentSyncData.databaseStatus)
        this.currentSyncData.databaseStatus = "unknown";
      if (!this.currentSyncData.header.fileStatuses)
        this.currentSyncData.header.fileStatuses = {};
      this.currentSyncData = updateDeviceInSyncFile(
        this.currentSyncData,
        this.deviceId,
        this.deviceName,
        this.pluginVersion
      );
      await this.writeSyncFile(this.currentSyncData);
      return { isValid: true };
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.validateSyncFile" });
      console.log("Failed to validate sync file, will recreate:", error);
      try {
        await this.createSyncFile();
        return { isValid: true };
      } catch (createError) {
        return {
          isValid: false,
          error: `Failed to validate and recreate sync file: ${createError.message}`
        };
      }
    }
  }
  /**
   * Alias for validateSyncFile() to support legacy calls.
   */
  async validateSyncState() {
    return await this.validateSyncFile();
  }
  /**
   * Repair corrupted sync file
   */
  async repairSyncFile() {
    try {
      const restored = await this.restoreFromBackup();
      if (restored) {
        return true;
      }
      await this.createSyncFile();
      return true;
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.repairSyncFile",
        metadata: { syncFilePath: this.syncFilePath }
      });
      return false;
    }
  }
  /**
   * Read and parse the sync file
   */
  async readSyncFile() {
    if (!this.syncFile) {
      throw this.errorHandler.handleSyncError(
        "sync_file_missing" /* SYNC_FILE_MISSING */,
        "Sync file not initialized",
        { context: "SyncFileManager.readSyncFile" },
        void 0,
        this.deviceId
      );
    }
    try {
      const content = await this.vault.read(this.syncFile);
      const yamlMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if (!yamlMatch) {
        throw this.errorHandler.handleSyncError(
          "sync_file_corrupt" /* SYNC_FILE_CORRUPT */,
          "Invalid sync file format: Missing YAML front matter",
          { context: "SyncFileManager.readSyncFile" },
          void 0,
          this.deviceId
        );
      }
      const yamlContent = yamlMatch[1];
      const parsedData = (0, import_obsidian5.parseYaml)(yamlContent);
      if (!parsedData || !parsedData.header) {
        throw this.errorHandler.handleSyncError(
          "sync_file_corrupt" /* SYNC_FILE_CORRUPT */,
          "Invalid sync file format: Missing required fields",
          { context: "SyncFileManager.readSyncFile" },
          void 0,
          this.deviceId
        );
      }
      this.currentSyncData = parsedData;
      return parsedData;
    } catch (error) {
      if (!this.errorHandler.isSyncError(error)) {
        throw this.errorHandler.handleSyncError(
          "sync_file_corrupt" /* SYNC_FILE_CORRUPT */,
          `Error reading sync file: ${error.message}`,
          { context: "SyncFileManager.readSyncFile" },
          void 0,
          this.deviceId
        );
      }
      throw error;
    }
  }
  /**
   * Write sync data to the sync file
   */
  async writeSyncFile(data) {
    if (!this.syncFile) {
      throw this.errorHandler.handleSyncError(
        "sync_file_missing" /* SYNC_FILE_MISSING */,
        "Sync file not initialized",
        { context: "SyncFileManager.writeSyncFile" },
        void 0,
        this.deviceId
      );
    }
    try {
      const content = this.generateSyncFileContent(data);
      await this.vault.modify(this.syncFile, content);
      this.currentSyncData = data;
      if (Date.now() - this.lastBackup >= this.backupInterval) {
        await this.createBackup();
      }
    } catch (error) {
      throw this.errorHandler.handleSyncError(
        "unknown_error" /* UNKNOWN_ERROR */,
        `Failed to write sync file: ${error.message}`,
        { context: "SyncFileManager.writeSyncFile" },
        void 0,
        this.deviceId
      );
    }
  }
  /**
   * Create a backup of the sync file
   */
  async createBackup() {
    if (!this.syncFile)
      return;
    try {
      const content = await this.vault.read(this.syncFile);
      const backupFile = this.vault.getAbstractFileByPath(this.backupPath);
      if (backupFile instanceof import_obsidian5.TFile) {
        await this.vault.modify(backupFile, content);
      } else {
        await this.vault.create(this.backupPath, content);
      }
      this.lastBackup = Date.now();
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.createBackup" });
    }
  }
  /**
   * Restore sync file from backup
   */
  async restoreFromBackup() {
    const backupFile = this.vault.getAbstractFileByPath(this.backupPath);
    if (!(backupFile instanceof import_obsidian5.TFile)) {
      return false;
    }
    try {
      const content = await this.vault.read(backupFile);
      if (this.syncFile) {
        await this.vault.modify(this.syncFile, content);
      } else {
        this.syncFile = await this.vault.create(this.syncFilePath, content);
      }
      const validationResult = await this.validateSyncFile();
      return validationResult.isValid;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.restoreFromBackup" });
      return false;
    }
  }
  /**
   * Update the database connection status
   */
  async updateDatabaseStatus(status) {
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      if (this.currentSyncData) {
        const updatedData = updateDatabaseStatus(this.currentSyncData, status);
        if (status === "unavailable" && this.currentSyncData.databaseStatus !== "unavailable") {
          updatedData.connectionEvents.push({
            timestamp: Date.now(),
            eventType: "disconnected",
            deviceId: this.deviceId,
            details: "Database connection lost"
          });
        }
        if (status === "available" && this.currentSyncData.databaseStatus !== "available") {
          updatedData.connectionEvents.push({
            timestamp: Date.now(),
            eventType: "connected",
            deviceId: this.deviceId,
            details: "Database connection established"
          });
        }
        const trimmedData = trimSyncHistoryArrays(updatedData);
        await this.writeSyncFile(trimmedData);
      }
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.updateDatabaseStatus",
        metadata: { status }
      });
    }
  }
  /**
   * Update device sync timestamp and status
   */
  async updateDeviceSyncTimestamp() {
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      if (this.currentSyncData) {
        const updatedData = updateDeviceSyncTime(this.currentSyncData, this.deviceId);
        await this.writeSyncFile(updatedData);
      }
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.updateDeviceSyncTimestamp" });
    }
  }
  /**
   * **New Method:**
   * Updates the sync status for a given file in the sync file.
   * This method is used as a fallback when the database isn't available.
   */
  async updateSyncStatus(filePath, status, additionalData) {
    if (!this.currentSyncData) {
      await this.readSyncFile();
    }
    if (this.currentSyncData) {
      this.currentSyncData.header.fileStatuses = this.currentSyncData.header.fileStatuses || {};
      this.currentSyncData.header.fileStatuses[filePath] = {
        status,
        lastModified: additionalData.lastModified,
        hash: additionalData.hash,
        updatedAt: Date.now()
      };
      await this.writeSyncFile(this.currentSyncData);
    } else {
      throw new Error("Sync file data unavailable for updateSyncStatus");
    }
  }
  /**
   * Gets the sync status for a specific file path.
   */
  async getSyncStatus(path) {
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      if (this.currentSyncData && this.currentSyncData.header.fileStatuses) {
        return this.currentSyncData.header.fileStatuses[path] || null;
      }
      return null;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.getSyncStatus", metadata: { path } });
      return null;
    }
  }
  /**
   * Get all pending operations
   */
  async getPendingOperations() {
    var _a2;
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      return ((_a2 = this.currentSyncData) == null ? void 0 : _a2.pendingOperations) || [];
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.getPendingOperations" });
      return [];
    }
  }
  /**
   * Get current sync state
   */
  async getSyncState() {
    var _a2;
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      return ((_a2 = this.currentSyncData) == null ? void 0 : _a2.header.syncState) || "unknown" /* UNKNOWN */;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.getSyncState" });
      return "unknown" /* UNKNOWN */;
    }
  }
  /**
   * Get information about all known devices
   */
  async getKnownDevices() {
    var _a2;
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      return ((_a2 = this.currentSyncData) == null ? void 0 : _a2.header.devices) || {};
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.getKnownDevices" });
      return {};
    }
  }
  /**
   * Check if there are conflicts that need resolution
   */
  async detectConflicts() {
    var _a2;
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      const pendingConflicts = ((_a2 = this.currentSyncData) == null ? void 0 : _a2.conflicts.filter(
        (conflict) => conflict.resolutionStatus === "pending"
      )) || [];
      return pendingConflicts;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.detectConflicts" });
      return [];
    }
  }
  /**
   * Attempt to resolve a conflict based on a given resolution strategy.
   * Supports strategies:
   * - "newest-wins": Automatically resolves by favoring the most recent update.
   * - "keep-both": Marks as resolved and leaves both versions intact.
   * - "manual": Flags the conflict for manual intervention (does not auto-resolve).
   */
  async resolveConflict(conflictId, resolutionStrategy) {
    var _a2;
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      const conflictIndex = (_a2 = this.currentSyncData) == null ? void 0 : _a2.conflicts.findIndex((c) => c.id === conflictId);
      if (conflictIndex === void 0 || conflictIndex < 0) {
        console.warn("Conflict not found:", conflictId);
        return false;
      }
      const conflict = this.currentSyncData.conflicts[conflictIndex];
      switch (resolutionStrategy) {
        case "newest-wins":
          conflict.resolutionStrategy = "newest-wins";
          conflict.resolutionStatus = "resolved";
          conflict.resolvedAt = Date.now();
          conflict.resolvedBy = this.deviceId;
          break;
        case "keep-both":
          conflict.resolutionStrategy = "keep-both";
          conflict.resolutionStatus = "resolved";
          conflict.resolvedAt = Date.now();
          conflict.resolvedBy = this.deviceId;
          break;
        case "manual":
          conflict.resolutionStrategy = "manual";
          console.log("Manual resolution required for conflict:", conflictId);
          return false;
        default:
          throw new Error("Unsupported resolution strategy");
      }
      await this.writeSyncFile(this.currentSyncData);
      return true;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.resolveConflict", metadata: { conflictId } });
      return false;
    }
  }
  /**
   * Attempt to resolve all detected conflicts using a default strategy.
   */
  async resolveAllConflicts(defaultStrategy = "newest-wins") {
    try {
      const conflicts = await this.detectConflicts();
      for (const conflict of conflicts) {
        await this.resolveConflict(conflict.id, defaultStrategy);
      }
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.resolveAllConflicts" });
    }
  }
  /**
   * Update the last sync timestamp in the sync file header.
   */
  async updateLastSync() {
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      if (this.currentSyncData) {
        this.currentSyncData.header.lastGlobalSync = Date.now();
        await this.writeSyncFile(this.currentSyncData);
      }
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.updateLastSync" });
    }
  }
  /**
   * Gets all sync entries from the sync file.
   */
  async getAllSyncEntries() {
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      if (this.currentSyncData && this.currentSyncData.header.fileStatuses) {
        return Object.entries(this.currentSyncData.header.fileStatuses).map(([filePath, data]) => ({
          filePath,
          status: data.status,
          lastModified: data.lastModified,
          hash: data.hash
        }));
      }
      return [];
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.getAllSyncEntries" });
      return [];
    }
  }
  /**
   * Attempt recovery operations when sync issues are detected.
   */
  async attemptRecovery() {
    try {
      const recovered = await this.restoreFromBackup();
      if (recovered) {
        console.log("Successfully recovered from backup");
        return true;
      }
      console.log("Backup restoration failed, attempting to recreate sync file");
      await this.createSyncFile();
      const validationResult = await this.validateSyncFile();
      return validationResult.isValid;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.attemptRecovery" });
      return false;
    }
  }
};

// utils/FileTracker.ts
var FileTracker = class {
  /**
   * @param vault The Obsidian vault instance.
   * @param errorHandler Centralized error handler.
   * @param syncFilePath Path to the sync file.
   * @param supabaseService Optional Supabase service instance.
   * @param offlineQueueManager Optional OfflineQueueManager for offline mode.
   */
  constructor(vault, errorHandler, syncFilePath = "_mindmatrixsync.md", supabaseService = null, offlineQueueManager) {
    this.vault = vault;
    this.errorHandler = errorHandler;
    this.supabaseService = supabaseService;
    this.eventQueue = [];
    this.isProcessing = false;
    this.processingTimeout = 1e3;
    // Optional offline queue manager for offline operations
    this.offlineQueueManager = null;
    this.maxFileSizeBytes = 10 * 1024 * 1024;
    this.syncFilePath = syncFilePath;
    this.syncManager = new SyncFileManager(vault, errorHandler, syncFilePath);
    if (offlineQueueManager) {
      this.offlineQueueManager = offlineQueueManager;
    }
  }
  /**
   * Initialize the file tracker.
   * If a Supabase service is available, reconcile the database with the local sync file.
   */
  async initialize() {
    try {
      console.log("[FileTracker.initialize] Starting FileTracker initialization");
      console.log(`[FileTracker.initialize] Sync file path: ${this.syncFilePath}`);
      await this.syncManager.initialize();
      if (this.supabaseService) {
        await this.reconcileDatabaseWithSyncFile();
      } else {
        console.log("Supabase service not available. Using sync file only for tracking.");
      }
      console.log("FileTracker initialized.");
    } catch (error) {
      this.errorHandler.handleError(error, { context: "FileTracker.initialize" });
      throw error;
    }
  }
  /**
   * Reconcile database records with local sync file entries.
   * Ensures that each file in the vault has an up-to-date status in the database.
   */
  async reconcileDatabaseWithSyncFile() {
    try {
      if (!this.supabaseService)
        return;
      const syncEntries = await this.syncManager.getAllSyncEntries();
      const entriesMap = new Map(syncEntries.map((entry) => [entry.filePath, entry]));
      const files = this.vault.getFiles();
      for (const file of files) {
        if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path))
          continue;
        try {
          const dbStatus = await this.supabaseService.getFileVectorizationStatus(file.path);
          const currentHash = await this.calculateFileHash(file);
          if (dbStatus.isVectorized) {
            const fileModifiedSinceDb = file.stat.mtime > (dbStatus.lastModified || 0);
            if (fileModifiedSinceDb) {
              const metadata = await this.createFileMetadata(file);
              await this.supabaseService.updateFileVectorizationStatus(metadata);
              console.log(`Database record updated to PENDING for modified file: ${file.path}`);
            }
          } else {
            const metadata = await this.createFileMetadata(file);
            await this.supabaseService.updateFileVectorizationStatus(metadata);
            console.log(`Database record created/updated for file: ${file.path}`);
          }
        } catch (error) {
          this.errorHandler.handleError(error, {
            context: "FileTracker.reconcileDatabaseWithSyncFile",
            metadata: { filePath: file.path }
          });
        }
      }
      for (const entry of syncEntries) {
        const file = this.vault.getAbstractFileByPath(entry.filePath);
        if (!file && entry.status !== "ERROR" && this.supabaseService) {
          await this.supabaseService.updateFileStatusOnDelete(entry.filePath);
          console.log(`Database record marked as deleted for file: ${entry.filePath}`);
        }
      }
    } catch (error) {
      console.error("Error reconciling database with sync file:", error);
    }
  }
  async handleCreate(file) {
    if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path))
      return;
    const event = { type: "create", file, timestamp: Date.now() };
    await this.queueEvent(event);
  }
  /**
   * Handle file modification events.
   * Enhanced with change detection and intelligent debouncing.
   */
  async handleModify(file) {
    if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file))
      return;
    try {
      const recentChange = this.recentChanges.get(file.path);
      const currentTime = Date.now();
      const hash = await this.calculateFileHash(file);
      if (recentChange && recentChange.hash === hash && currentTime - recentChange.lastProcessed < this.processingTimeout * 2) {
        console.log(`Skipping redundant update for ${file.path} - content unchanged`);
        return;
      }
      if (recentChange) {
        console.log(`Content changed for ${file.path}. Previous hash: ${recentChange.hash.substring(0, 8)}..., New hash: ${hash.substring(0, 8)}...`);
      }
      this.recentChanges.set(file.path, {
        lastModified: file.stat.mtime,
        hash,
        lastProcessed: currentTime
      });
      const event = {
        type: "modify",
        file,
        timestamp: currentTime,
        hash
      };
      await this.queueEvent(event);
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "FileTracker.handleModify",
        metadata: { filePath: file.path }
      });
    }
  }
  async handleDelete(file) {
    if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path))
      return;
    const event = { type: "delete", file, timestamp: Date.now() };
    await this.queueEvent(event);
    if (this.offlineQueueManager) {
      await this.offlineQueueManager.queueOperation({
        operationType: "delete",
        fileId: file.path,
        timestamp: Date.now()
      });
    } else if (this.supabaseService) {
      try {
        await this.supabaseService.updateFileStatusOnDelete(file.path);
      } catch (error) {
        console.error("Error updating database for deleted file:", error);
      }
    } else {
      await this.syncManager.updateSyncStatus(file.path, "OK", {
        lastModified: Date.now(),
        hash: ""
      });
    }
  }
  async handleRename(file, oldPath) {
    if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path))
      return;
    const event = { type: "rename", file, oldPath, timestamp: Date.now() };
    await this.queueEvent(event);
    const newHash = await this.calculateFileHash(file);
    const metadata = await this.createFileMetadata(file);
    if (this.offlineQueueManager) {
      await this.offlineQueueManager.queueOperation({
        operationType: "rename",
        fileId: file.path,
        metadata: { oldPath },
        timestamp: Date.now()
      });
    } else if (this.supabaseService) {
      await this.supabaseService.updateFileVectorizationStatus(metadata);
      await this.supabaseService.updateFileStatusOnDelete(oldPath);
    } else {
      await this.syncManager.updateSyncStatus(file.path, "PENDING", {
        lastModified: file.stat.mtime,
        hash: newHash
      });
      await this.syncManager.updateSyncStatus(oldPath, "OK", {
        lastModified: Date.now(),
        hash: ""
      });
    }
  }
  /**
   * Queue an event for processing with intelligent debouncing.
   */
  async queueEvent(event) {
    this.eventQueue.push(event);
    if (!this.isProcessing) {
      let debounceTime = this.processingTimeout;
      if (event.type === "delete" || event.type === "rename") {
        debounceTime = Math.min(debounceTime / 2, 500);
      }
      if (event.type === "modify") {
        const recentEvents = this.eventQueue.filter(
          (e) => e.file.path === event.file.path && e.type === "modify" && event.timestamp - e.timestamp < 5e3
        );
        if (recentEvents.length > 3) {
          debounceTime = Math.max(debounceTime * 2, 3e3);
          console.log(`Increased debounce time to ${debounceTime}ms for rapid changes to ${event.file.path}`);
        }
      }
      setTimeout(() => this.processEventQueue(), debounceTime);
    }
  }
  /**
   * Process the event queue with improved conflict handling.
   */
  async processEventQueue() {
    var _a2;
    if (this.isProcessing || this.eventQueue.length === 0)
      return;
    this.isProcessing = true;
    console.log(`Processing ${this.eventQueue.length} queued events`);
    try {
      const eventsByPath = /* @__PURE__ */ new Map();
      for (const event of this.eventQueue) {
        const path = event.file.path;
        if (!eventsByPath.has(path)) {
          eventsByPath.set(path, []);
        }
        (_a2 = eventsByPath.get(path)) == null ? void 0 : _a2.push(event);
      }
      const paths = Array.from(eventsByPath.keys());
      const deleteFirst = paths.sort((a, b) => {
        var _a3, _b, _c, _d;
        const aHasDelete = (_b = (_a3 = eventsByPath.get(a)) == null ? void 0 : _a3.some((e) => e.type === "delete")) != null ? _b : false;
        const bHasDelete = (_d = (_c = eventsByPath.get(b)) == null ? void 0 : _c.some((e) => e.type === "delete")) != null ? _d : false;
        if (aHasDelete && !bHasDelete)
          return -1;
        if (!aHasDelete && bHasDelete)
          return 1;
        return 0;
      });
      for (const path of deleteFirst) {
        const events = eventsByPath.get(path);
        if (events) {
          await this.processFileEvents(path, events);
        }
      }
      this.eventQueue = [];
    } catch (error) {
      this.errorHandler.handleError(error, { context: "FileTracker.processEventQueue" });
    } finally {
      this.isProcessing = false;
      if (this.eventQueue.length > 0) {
        setTimeout(() => this.processEventQueue(), 100);
      }
    }
  }
  /**
   * Process all events for a single file with improved change detection.
   */
  async processFileEvents(path, events) {
    events.sort((a, b) => a.timestamp - b.timestamp);
    const finalEvent = events[events.length - 1];
    console.log(`Processing ${events.length} events for ${path}, final event: ${finalEvent.type}`);
    try {
      if (finalEvent.type === "delete") {
        console.log(`Skipping further processing for deleted file: ${path}`);
        return;
      }
      const newHash = finalEvent.hash || await this.calculateFileHash(finalEvent.file);
      let needsVectorizing = true;
      if (this.supabaseService) {
        try {
          needsVectorizing = await this.supabaseService.needsVectorizing(
            path,
            finalEvent.file.stat.mtime,
            newHash
          );
          if (!needsVectorizing) {
            console.log(`File ${path} does not need vectorizing - no significant changes`);
          }
        } catch (error) {
          console.error("Error checking if file needs vectorizing:", error);
          needsVectorizing = true;
        }
      } else {
        const syncStatus = await this.syncManager.getSyncStatus(path);
        if (syncStatus && syncStatus.hash === newHash && finalEvent.file.stat.mtime <= syncStatus.lastModified && syncStatus.status !== "PENDING") {
          needsVectorizing = false;
          console.log(`File ${path} does not need vectorizing according to sync file status`);
        }
      }
      this.recentChanges.set(path, {
        lastModified: finalEvent.file.stat.mtime,
        hash: newHash,
        lastProcessed: Date.now()
      });
      if (needsVectorizing) {
        console.log(`Updating status for ${path} with hash ${newHash.substring(0, 8)}...`);
        const metadata = await this.createFileMetadata(finalEvent.file);
        metadata.customMetadata.contentHash = newHash;
        if (this.supabaseService) {
          await this.supabaseService.updateFileVectorizationStatus(metadata);
        } else {
          await this.syncManager.updateSyncStatus(path, "PENDING", {
            lastModified: finalEvent.file.stat.mtime,
            hash: newHash
          });
        }
      }
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "FileTracker.processFileEvents",
        metadata: { path, eventType: finalEvent.type }
      });
    }
  }
  async calculateFileHash(file) {
    try {
      const content = await this.vault.read(file);
      return await this.hashString(content);
    } catch (error) {
      this.errorHandler.handleError(error, { context: "FileTracker.calculateFileHash", metadata: { filePath: file.path } });
      return "";
    }
  }
  async hashString(str2) {
    const encoder = new TextEncoder();
    const data = encoder.encode(str2);
    const buffer = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(buffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  async createFileMetadata(file) {
    try {
      const content = await this.vault.read(file);
      const lineCount = content.split("\n").length;
      let additionalMetadata = {};
      if (this.supabaseService) {
        try {
          const status = await this.supabaseService.getFileVectorizationStatus(file.path);
          if (status.isVectorized) {
            additionalMetadata = {
              lastVectorized: status.lastVectorized,
              contentHash: status.contentHash
            };
          }
        } catch (error) {
          console.error("Error getting file status from database:", error);
        }
      }
      return {
        obsidianId: file.path,
        path: file.path,
        lastModified: file.stat.mtime,
        created: file.stat.ctime,
        size: file.stat.size,
        customMetadata: { ...additionalMetadata },
        loc: { lines: { from: 1, to: lineCount } },
        source: "obsidian",
        file_id: file.path,
        blobType: "text/markdown"
      };
    } catch (error) {
      this.errorHandler.handleError(error, { context: "FileTracker.createFileMetadata", metadata: { filePath: file.path } });
      return {
        obsidianId: file.path,
        path: file.path,
        lastModified: file.stat.mtime,
        created: file.stat.ctime,
        size: file.stat.size,
        customMetadata: {}
      };
    }
  }
  /**
   * Determine if a file should be tracked and processed.
   * Enhanced with additional exclusion logic.
   */
  shouldTrackFile(file) {
    if (!this.settings || !isVaultInitialized(this.settings)) {
      return false;
    }
    if (!this.settings.enableAutoSync) {
      return false;
    }
    const allExclusions = getAllExclusions(this.settings);
    const filePath = file.path;
    const fileName = file.name;
    if (filePath === this.settings.sync.syncFilePath || filePath === this.settings.sync.syncFilePath + ".backup") {
      return false;
    }
    const isBinaryFile = this.isBinaryFile(fileName);
    if (isBinaryFile) {
      console.log(`Skipping binary file: ${fileName}`);
      return false;
    }
    if (file.stat.size > this.maxFileSizeBytes) {
      console.log(`Skipping file exceeding size limit: ${fileName} (${file.stat.size} bytes)`);
      return false;
    }
    if (Array.isArray(allExclusions.excludedFiles) && allExclusions.excludedFiles.includes(fileName)) {
      console.log("Skipping excluded file:", fileName);
      return false;
    }
    if (Array.isArray(allExclusions.excludedFolders)) {
      const isExcludedFolder = allExclusions.excludedFolders.some((folder) => {
        const normalizedFolder = folder.endsWith("/") ? folder : folder + "/";
        return filePath.startsWith(normalizedFolder);
      });
      if (isExcludedFolder) {
        console.log("Skipping file in excluded folder:", filePath);
        return false;
      }
    }
    if (Array.isArray(allExclusions.excludedFileTypes)) {
      const isExcludedType = allExclusions.excludedFileTypes.some(
        (ext) => filePath.toLowerCase().endsWith(ext.toLowerCase())
      );
      if (isExcludedType) {
        console.log("Skipping excluded file type:", filePath);
        return false;
      }
    }
    if (Array.isArray(allExclusions.excludedFilePrefixes)) {
      const isExcludedPrefix = allExclusions.excludedFilePrefixes.some(
        (prefix) => fileName.startsWith(prefix)
      );
      if (isExcludedPrefix) {
        console.log("Skipping file with excluded prefix:", fileName);
        return false;
      }
    }
    return true;
  }
  /**
   * Retrieve sync status for a given file from the sync file.
   */
  async getSyncStatus(path) {
    return await this.syncManager.getSyncStatus(path);
  }
  /**
   * Retrieve all sync statuses.
   */
  async getAllSyncStatuses() {
    return await this.syncManager.getAllSyncEntries();
  }
  /**
   * Allows late binding of the Supabase service.
   */
  setSupabaseService(service) {
    this.supabaseService = service;
  }
  /**
   * Clear the event queue.
   */
  clearQueue() {
    this.eventQueue = [];
  }
  /**
   * Update the processing timeout.
   */
  setProcessingTimeout(timeout) {
    this.processingTimeout = timeout;
  }
  /**
      * Helper method to determine if a file is likely binary based on extension
     */
  isBinaryFile(fileName) {
    const binaryExtensions = [
      ".jpg",
      ".jpeg",
      ".png",
      ".gif",
      ".bmp",
      ".tiff",
      ".ico",
      ".pdf",
      ".zip",
      ".7z",
      ".rar",
      ".tar",
      ".gz",
      ".mp3",
      ".mp4",
      ".wav",
      ".ogg",
      ".flac",
      ".exe",
      ".dll",
      ".so",
      ".dylib",
      ".db",
      ".sqlite"
    ];
    return binaryExtensions.some(
      (ext) => fileName.toLowerCase().endsWith(ext)
    );
  }
};

// utils/ErrorHandler.ts
var import_obsidian7 = require("obsidian");
var ErrorHandler = class {
  constructor(settings, vaultPath) {
    this.errorLogs = [];
    this.maxLogs = 100;
    this.settings = settings;
    if (settings.logToFile && vaultPath) {
      this.logFilePath = `${vaultPath}/.obsidian/mind-matrix.log`;
    }
  }
  /**
   * Handles errors with context and optional recovery.
   */
  handleError(error, context, level = "error") {
    if (!this.shouldLog(level)) {
      return;
    }
    const errorLog = {
      timestamp: Date.now(),
      error: this.normalizeError(error),
      context,
      level,
      handled: false
    };
    this.errorLogs.unshift(errorLog);
    if (this.errorLogs.length > this.maxLogs) {
      this.errorLogs.pop();
    }
    if (level === "error" || level === "warn" && this.settings.logLevel === "debug") {
      new import_obsidian7.Notice(`Error: ${error.message}`);
    }
    if (this.settings.enableDebugLogs) {
      console.group(`[${level.toUpperCase()}] ${context.context}`);
      console.error("Error details:", error);
      console.error("Context:", context);
      if (error.stack) {
        console.error("Stack trace:", error.stack);
      }
      console.groupEnd();
    }
    if (this.settings.logToFile && this.logFilePath) {
      this.writeToLogFile(errorLog);
    }
  }
  /**
   * Creates and handles a sync error.
   */
  handleSyncError(type, message, context, details, deviceId, recoverable = true) {
    const error = {
      name: "SyncError",
      message,
      type,
      details,
      deviceId,
      recoverable,
      stack: new Error().stack
    };
    this.handleError(error, context, recoverable ? "warn" : "error");
    return error;
  }
  /**
   * Handles connection errors specifically for sync operations.
   */
  handleConnectionError(error, context, deviceId) {
    let syncError;
    if (error && error.type && Object.values(SyncErrorType).includes(error.type)) {
      syncError = error;
    } else {
      syncError = {
        name: "SyncError",
        message: error.message || "Database connection error",
        type: "database_unavailable" /* DATABASE_UNAVAILABLE */,
        details: { originalError: error },
        deviceId,
        recoverable: true,
        stack: error.stack || new Error().stack
      };
    }
    this.handleError(syncError, { context }, "warn");
  }
  /**
   * Checks if the given error level should be logged.
   */
  shouldLog(level) {
    const levels = { error: 0, warn: 1, info: 2, debug: 3 };
    return levels[level] <= levels[this.settings.logLevel];
  }
  /**
   * Normalizes different error formats.
   */
  normalizeError(error) {
    if (error instanceof Error) {
      return error;
    }
    if (error && error.type && Object.values(SyncErrorType).includes(error.type)) {
      const syncError = new Error(error.message || "Sync error");
      syncError.name = "SyncError";
      Object.assign(syncError, error);
      return syncError;
    }
    if (this.isSupabaseError(error)) {
      return new Error(`Database error (${error.code}): ${error.message}${error.hint ? ` - ${error.hint}` : ""}`);
    }
    if (typeof error === "string") {
      return new Error(error);
    }
    if (typeof error === "object") {
      const message = error.message || "Unknown error";
      const normalizedError = new Error(message);
      Object.assign(normalizedError, error);
      return normalizedError;
    }
    return new Error("Unknown error occurred");
  }
  /**
   * Type guard for Supabase errors.
   */
  isSupabaseError(error) {
    return error && typeof error === "object" && "code" in error && "details" in error;
  }
  /**
   * Type guard for Sync errors.
   */
  isSyncError(error) {
    return error && typeof error === "object" && "type" in error && Object.values(SyncErrorType).includes(error.type);
  }
  /**
   * Shows an appropriate notification based on error type.
   */
  showErrorNotification(error) {
    let message = "An error occurred";
    let duration = 4e3;
    if (this.isSyncError(error)) {
      switch (error.type) {
        case "sync_file_missing" /* SYNC_FILE_MISSING */:
          message = "Sync file is missing. Will attempt to recreate.";
          break;
        case "sync_file_corrupt" /* SYNC_FILE_CORRUPT */:
          message = "Sync file is corrupted. Will attempt to repair.";
          break;
        case "device_mismatch" /* DEVICE_MISMATCH */:
          message = "Device identification issue. Check plugin settings.";
          break;
        case "conflict_detected" /* CONFLICT_DETECTED */:
          message = "Sync conflict detected. Check sync status for details.";
          duration = 6e3;
          break;
        case "database_unavailable" /* DATABASE_UNAVAILABLE */:
          message = "Database connection unavailable. Operating in offline mode.";
          break;
        case "sync_interrupted" /* SYNC_INTERRUPTED */:
          message = "Sync operation was interrupted. Will retry.";
          break;
        default:
          message = `Sync error: ${error.message}`;
      }
    } else if (this.isSupabaseError(error)) {
      switch (error.code) {
        case "42P01":
          message = "Database table not found. Please run setup SQL.";
          break;
        case "42501":
          message = "Insufficient database permissions.";
          break;
        case "23505":
          message = "Duplicate entry found.";
          break;
        default:
          message = `Database error: ${error.message}`;
      }
      duration = 6e3;
    } else if (error.type === "CHUNKING_ERROR" /* CHUNKING_ERROR */) {
      message = "Error splitting document into chunks";
    } else if (error.type === "EMBEDDING_ERROR" /* EMBEDDING_ERROR */) {
      message = "Error generating embeddings";
    } else if (error.type === "DATABASE_ERROR" /* DATABASE_ERROR */) {
      message = "Database operation failed";
    } else if (error.type === "INVALID_METADATA" /* INVALID_METADATA */) {
      message = "Invalid document metadata";
    } else if (error.type === "FILE_ACCESS_ERROR" /* FILE_ACCESS_ERROR */) {
      message = "Error accessing file";
    } else if (error.type === "YAML_PARSE_ERROR" /* YAML_PARSE_ERROR */) {
      message = "Error parsing YAML front matter";
    } else if (error.type === "VECTOR_EXTENSION_ERROR" /* VECTOR_EXTENSION_ERROR */) {
      message = "Vector extension not available";
    } else if (error.type === "SYNC_ERROR" /* SYNC_ERROR */) {
      message = "Sync operation failed";
    } else if (error.type === "QUEUE_FULL" /* QUEUE_FULL */) {
      message = "Task queue is full";
    } else if (error.type === "TASK_TIMEOUT" /* TASK_TIMEOUT */) {
      message = "Task timed out";
    } else if (error.type === "TASK_CANCELLED" /* TASK_CANCELLED */) {
      message = "Task was cancelled";
    } else if (error.type === "MAX_RETRIES_EXCEEDED" /* MAX_RETRIES_EXCEEDED */) {
      message = "Maximum retry attempts exceeded";
    } else if (error.type === "INVALID_TASK_STATE" /* INVALID_TASK_STATE */) {
      message = "Invalid task state";
    } else if (error.type === "TASK_NOT_FOUND" /* TASK_NOT_FOUND */) {
      message = "Task not found";
    }
    if (error.message && !this.isSyncError(error)) {
      message = `${message}: ${error.message}`;
    }
    new import_obsidian7.Notice(message, duration);
  }
  /**
   * Writes error log to file.
   */
  writeToLogFile(log) {
    var _a2, _b, _c;
    if (!this.logFilePath)
      return;
    const logEntry = {
      timestamp: new Date(log.timestamp).toISOString(),
      level: log.level.toUpperCase(),
      context: log.context.context,
      error: log.error.message,
      stack: log.error.stack,
      metadata: log.context.metadata
    };
    try {
      if ((_c = (_b = (_a2 = window.app) == null ? void 0 : _a2.vault) == null ? void 0 : _b.adapter) == null ? void 0 : _c.append) {
        window.app.vault.adapter.append(
          this.logFilePath,
          JSON.stringify(logEntry) + "\n"
        );
      }
    } catch (error) {
      console.error("Failed to write to log file:", error);
    }
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  getRecentLogs(count = 10) {
    return this.errorLogs.slice(0, count);
  }
  clearLogs() {
    this.errorLogs = [];
  }
  getErrorStats() {
    return this.errorLogs.reduce((acc, log) => {
      const errorType = log.error.name || "Unknown";
      acc[errorType] = (acc[errorType] || 0) + 1;
      return acc;
    }, {});
  }
  getSyncErrorStats() {
    const stats = {};
    Object.values(SyncErrorType).forEach((type) => {
      stats[type] = 0;
    });
    this.errorLogs.forEach((log) => {
      if (this.isSyncError(log.error)) {
        stats[log.error.type] = (stats[log.error.type] || 0) + 1;
      }
    });
    return stats;
  }
};

// utils/NotificationManager.ts
var import_obsidian8 = require("obsidian");
var NotificationManager = class {
  constructor(statusBarEl, enableNotifications, enableProgressBar) {
    this.fixedProgressBar = null;
    this.notificationQueue = [];
    this.isProcessingQueue = false;
    this.statusBarItem = statusBarEl;
    this.enableNotifications = enableNotifications;
    this.enableProgressBar = enableProgressBar;
    this.initializeStatusBar();
  }
  /**
   * Shows a notification message.
   */
  showNotification(message, duration = 4e3) {
    if (!this.enableNotifications)
      return;
    this.notificationQueue.push(message);
    if (!this.isProcessingQueue) {
      this.processNotificationQueue();
    }
  }
  /**
   * Updates the fixed progress bar with the current progress (in percent) and status message.
   */
  updateProgress(progress) {
    if (!this.enableProgressBar)
      return;
    if (!this.fixedProgressBar) {
      this.fixedProgressBar = this.createFixedProgressBar();
    }
    const progressPercentage = Math.round(progress.progress);
    this.fixedProgressBar.fill.style.width = `${progressPercentage}%`;
    this.fixedProgressBar.text.textContent = `${progressPercentage}% - ${progress.currentStep} (${progress.currentStepNumber}/${progress.totalSteps})`;
  }
  /**
   * Initializes the status bar container.
   */
  initializeStatusBar() {
    this.statusBarItem.innerHTML = "";
    const container = document.createElement("div");
    container.addClass("fixed-progress-container");
    this.statusBarItem.appendChild(container);
  }
  /**
   * Creates a fixed progress bar element.
   */
  createFixedProgressBar() {
    const container = document.createElement("div");
    container.addClass("fixed-progress-bar-container");
    const bar = document.createElement("div");
    bar.addClass("fixed-progress-bar");
    const fill = document.createElement("div");
    fill.addClass("fixed-progress-fill");
    const text = document.createElement("div");
    text.addClass("fixed-progress-text");
    bar.appendChild(fill);
    container.appendChild(bar);
    container.appendChild(text);
    this.statusBarItem.appendChild(container);
    return { container, fill, text };
  }
  /**
   * Processes the notification queue sequentially.
   */
  async processNotificationQueue() {
    if (this.isProcessingQueue || this.notificationQueue.length === 0)
      return;
    this.isProcessingQueue = true;
    try {
      while (this.notificationQueue.length > 0) {
        const message = this.notificationQueue.shift();
        if (message) {
          new import_obsidian8.Notice(message);
          await new Promise((resolve) => setTimeout(resolve, 500));
        }
      }
    } finally {
      this.isProcessingQueue = false;
    }
  }
  /**
   * Updates notification settings.
   */
  updateSettings(enableNotifications, enableProgressBar) {
    this.enableNotifications = enableNotifications;
    this.enableProgressBar = enableProgressBar;
  }
  /**
   * Clears all notifications.
   */
  clear() {
    this.notificationQueue = [];
  }
};

// settings/SettingsTab.ts
var import_obsidian9 = require("obsidian");
var MindMatrixSettingsTab = class extends import_obsidian9.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.settings = plugin.settings;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    console.log("DEBUG - All Exclusion Settings:", {
      userSettings: this.settings.exclusions,
      systemDefaults: SYSTEM_EXCLUSIONS
    });
    containerEl.createEl("h2", { text: "Vault Identification" });
    if (isVaultInitialized2(this.settings)) {
      new import_obsidian9.Setting(containerEl).setName("Vault ID").setDesc("Unique identifier for this vault in the database.").addText(
        (text) => text.setValue(this.settings.vaultId).setDisabled(true)
      );
      new import_obsidian9.Setting(containerEl).setName("Vault Name").setDesc("The name of your current vault.").addText(
        (text) => text.setValue(this.settings.lastKnownVaultName).setDisabled(true)
      );
      new import_obsidian9.Setting(containerEl).setName("Reset Vault ID").setDesc("Generate a new vault ID (requires full resync).").addButton(
        (btn) => btn.setButtonText("Reset").setWarning().onClick(async () => {
          const confirmed = await this.showResetConfirmation();
          if (confirmed) {
            this.settings.vaultId = generateVaultId();
            this.settings.lastKnownVaultName = this.app.vault.getName();
            await this.plugin.saveSettings();
            new import_obsidian9.Notice("Vault ID has been reset. Please resync your vault.");
            this.display();
          }
        })
      );
    } else {
      new import_obsidian9.Setting(containerEl).setName("Initialize Vault").setDesc("Generate a unique identifier for this vault to begin syncing.").addButton(
        (btn) => btn.setButtonText("Initialize").onClick(async () => {
          this.settings.vaultId = generateVaultId();
          this.settings.lastKnownVaultName = this.app.vault.getName();
          await this.plugin.saveSettings();
          new import_obsidian9.Notice("Vault has been initialized.");
          this.display();
        })
      );
    }
    containerEl.createEl("h2", { text: "Supabase Configuration" });
    new import_obsidian9.Setting(containerEl).setName("Supabase URL").setDesc("The URL of your Supabase project (e.g., https://your-project.supabase.co).").addText(
      (text) => text.setPlaceholder("https://your-project.supabase.co").setValue(this.settings.supabase.url).onChange(async (value) => {
        this.settings.supabase.url = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Supabase URL updated.");
      })
    );
    new import_obsidian9.Setting(containerEl).setName("Supabase API Key").setDesc("Your Supabase API key (found in your Supabase dashboard).").addText(
      (text) => text.setPlaceholder("Enter your API key").setValue(this.settings.supabase.apiKey).onChange(async (value) => {
        this.settings.supabase.apiKey = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Supabase API key updated.");
      })
    );
    containerEl.createEl("h2", { text: "OpenAI Configuration" });
    new import_obsidian9.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key for generating embeddings.").addText(
      (text) => text.setPlaceholder("Enter your API key").setValue(this.settings.openai.apiKey).onChange(async (value) => {
        this.settings.openai.apiKey = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("OpenAI API key updated.");
      })
    );
    containerEl.createEl("h2", { text: "Document Processing" });
    new import_obsidian9.Setting(containerEl).setName("Chunk Size").setDesc("Maximum size of text chunks (in characters).").addText(
      (text) => text.setValue(String(this.settings.chunking.chunkSize)).onChange(async (value) => {
        const numValue = Number(value);
        if (!isNaN(numValue) && numValue > 0) {
          this.settings.chunking.chunkSize = numValue;
          await this.plugin.saveSettings();
          new import_obsidian9.Notice("Chunk size updated.");
        }
      })
    );
    new import_obsidian9.Setting(containerEl).setName("Chunk Overlap").setDesc("Overlap between text chunks (in characters).").addText(
      (text) => text.setValue(String(this.settings.chunking.chunkOverlap)).onChange(async (value) => {
        const numValue = Number(value);
        if (!isNaN(numValue) && numValue >= 0) {
          this.settings.chunking.chunkOverlap = numValue;
          await this.plugin.saveSettings();
          new import_obsidian9.Notice("Chunk overlap updated.");
        }
      })
    );
    containerEl.createEl("h2", { text: "Exclusions" });
    const userExclusions = getUserExclusions(this.settings);
    console.log("DEBUG - User Exclusions from getUserExclusions():", userExclusions);
    const systemFolders = new Set(SYSTEM_EXCLUSIONS.folders);
    const systemFileTypes = new Set(SYSTEM_EXCLUSIONS.fileTypes);
    const systemFilePrefixes = new Set(SYSTEM_EXCLUSIONS.filePrefixes);
    const systemFiles = new Set(SYSTEM_EXCLUSIONS.files);
    console.log("DEBUG - System Exclusion Sets:", {
      folders: Array.from(systemFolders),
      fileTypes: Array.from(systemFileTypes),
      filePrefixes: Array.from(systemFilePrefixes),
      files: Array.from(systemFiles)
    });
    const filteredUserFolders = userExclusions.excludedFolders.filter((folder) => !systemFolders.has(folder));
    const filteredUserFileTypes = userExclusions.excludedFileTypes.filter((type) => !systemFileTypes.has(type));
    const filteredUserFilePrefixes = userExclusions.excludedFilePrefixes.filter((prefix) => !systemFilePrefixes.has(prefix));
    const filteredUserFiles = userExclusions.excludedFiles.filter((file) => !systemFiles.has(file));
    console.log("DEBUG - Filtered User Exclusions:", {
      folders: filteredUserFolders,
      fileTypes: filteredUserFileTypes,
      filePrefixes: filteredUserFilePrefixes,
      files: filteredUserFiles
    });
    new import_obsidian9.Setting(containerEl).setName("Excluded Folders").setDesc("Folders to exclude from syncing (comma-separated).").addText((text) => {
      const value = filteredUserFolders.join(", ");
      console.log("DEBUG - Setting excluded folders field value:", value);
      return text.setPlaceholder("folder1, folder2").setValue(value).onChange(async (value2) => {
        console.log("DEBUG - Folders onChange event value:", value2);
        const userFolders = value2.split(",").map((s) => s.trim()).filter((s) => s);
        const finalFolders = userFolders.filter((folder) => !systemFolders.has(folder));
        console.log("DEBUG - Final folders to save:", finalFolders);
        this.settings.exclusions.excludedFolders = finalFolders;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Excluded folders updated.");
      });
    });
    new import_obsidian9.Setting(containerEl).setName("Excluded File Types").setDesc("File extensions to exclude (comma-separated, include the dot).").addText((text) => {
      const value = filteredUserFileTypes.join(", ");
      return text.setPlaceholder(".type1, .type2").setValue(value).onChange(async (value2) => {
        const userFileTypes = value2.split(",").map((s) => s.trim()).filter((s) => s);
        const finalFileTypes = userFileTypes.filter((type) => !systemFileTypes.has(type));
        this.settings.exclusions.excludedFileTypes = finalFileTypes;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Excluded file types updated.");
      });
    });
    new import_obsidian9.Setting(containerEl).setName("Excluded File Prefixes").setDesc("File name prefixes to exclude (comma-separated).").addText((text) => {
      const value = filteredUserFilePrefixes.join(", ");
      console.log("DEBUG - Setting excluded file prefixes field value:", value);
      return text.setPlaceholder("temp, draft").setValue(value).onChange(async (value2) => {
        console.log("DEBUG - File prefixes onChange event value:", value2);
        const userFilePrefixes = value2.split(",").map((s) => s.trim()).filter((s) => s);
        const finalFilePrefixes = userFilePrefixes.filter((prefix) => !systemFilePrefixes.has(prefix));
        console.log("DEBUG - Final file prefixes to save:", finalFilePrefixes);
        this.settings.exclusions.excludedFilePrefixes = finalFilePrefixes;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Excluded file prefixes updated.");
      });
    });
    new import_obsidian9.Setting(containerEl).setName("Excluded Files").setDesc("Specific files to exclude from syncing (comma-separated).").addText((text) => {
      const value = filteredUserFiles.join(", ");
      console.log("DEBUG - Setting excluded files field value:", value);
      return text.setPlaceholder("file1.md, file2.md").setValue(value).onChange(async (value2) => {
        console.log("DEBUG - Files onChange event value:", value2);
        const userFiles = value2.split(",").map((s) => s.trim()).filter((s) => s);
        const finalFiles = userFiles.filter((file) => !systemFiles.has(file));
        console.log("DEBUG - Final files to save:", finalFiles);
        this.settings.exclusions.excludedFiles = finalFiles;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Excluded files updated.");
      });
    });
    const infoDiv = containerEl.createEl("div", { cls: "setting-item-description" });
    infoDiv.innerHTML = `
			<p><strong>Note:</strong> The following items are automatically excluded by the system:</p>
			<p><strong>Folders:</strong> ${SYSTEM_EXCLUSIONS.folders.join(", ")}</p>
			<p><strong>File Types:</strong> ${SYSTEM_EXCLUSIONS.fileTypes.join(", ")}</p>
			<p><strong>File Prefixes:</strong> ${SYSTEM_EXCLUSIONS.filePrefixes.join(", ")}</p>
			<p><strong>Files:</strong> ${SYSTEM_EXCLUSIONS.files.join(", ")}</p>
		`;
    containerEl.createEl("h2", { text: "Queue & Sync Settings" });
    new import_obsidian9.Setting(containerEl).setName("Auto Sync").setDesc("Automatically sync changes to the database when files are modified.").addToggle(
      (toggle) => toggle.setValue(this.settings.enableAutoSync).onChange(async (value) => {
        this.settings.enableAutoSync = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Auto sync updated.");
      })
    );
    new import_obsidian9.Setting(containerEl).setName("Sync File Path").setDesc("The path for the dedicated sync file.").addText(
      (text) => text.setValue(this.settings.sync.syncFilePath).onChange(async (value) => {
        this.settings.sync.syncFilePath = value;
        const systemFiles2 = this.settings.exclusions.systemExcludedFiles;
        const oldSyncFileIndex = systemFiles2.findIndex((f) => f === "_mindmatrixsync.md");
        const oldSyncBackupIndex = systemFiles2.findIndex((f) => f === "_mindmatrixsync.md.backup");
        if (oldSyncFileIndex !== -1)
          systemFiles2.splice(oldSyncFileIndex, 1);
        if (oldSyncBackupIndex !== -1)
          systemFiles2.splice(oldSyncBackupIndex, 1);
        systemFiles2.push(value);
        systemFiles2.push(value + ".backup");
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Sync file path updated.");
      })
    );
    containerEl.createEl("h2", { text: "Debug Settings" });
    new import_obsidian9.Setting(containerEl).setName("Enable Debug Logs").setDesc("Enable detailed debug logs in the console.").addToggle(
      (toggle) => toggle.setValue(this.settings.debug.enableDebugLogs).onChange(async (value) => {
        this.settings.debug.enableDebugLogs = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Debug logs setting updated.");
      })
    );
    new import_obsidian9.Setting(containerEl).setName("Log Level").setDesc("Select the level of detail for debug logging.").addDropdown(
      (dropdown) => dropdown.addOption("error", "Error").addOption("warn", "Warning").addOption("info", "Info").addOption("debug", "Debug").setValue(this.settings.debug.logLevel).onChange(async (value) => {
        this.settings.debug.logLevel = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Log level updated.");
      })
    );
    new import_obsidian9.Setting(containerEl).setName("Log to File").setDesc("Save debug logs to a file in your vault.").addToggle(
      (toggle) => toggle.setValue(this.settings.debug.logToFile).onChange(async (value) => {
        this.settings.debug.logToFile = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Log to file setting updated.");
      })
    );
  }
  async showResetConfirmation() {
    return new Promise((resolve) => {
      const modal = this.app.modal;
      modal.open((modal2) => {
        modal2.titleEl.setText("Reset Vault ID");
        modal2.contentEl.setText(
          "Warning: Resetting the vault ID will disconnect this vault from its existing database entries. This operation cannot be undone. Are you sure you want to continue?"
        );
        modal2.addButton((btn) => {
          btn.setButtonText("Cancel").onClick(() => {
            resolve(false);
            modal2.close();
          });
        });
        modal2.addButton((btn) => {
          btn.setButtonText("Reset").setWarning().onClick(() => {
            resolve(true);
            modal2.close();
          });
        });
      });
    });
  }
};

// services/InitialSyncManager.ts
var import_obsidian10 = require("obsidian");
var InitialSyncManager = class {
  constructor(vault, queueService, syncManager, metadataExtractor, errorHandler, notificationManager, supabaseService, options = {}) {
    this.vault = vault;
    this.queueService = queueService;
    this.syncManager = syncManager;
    this.metadataExtractor = metadataExtractor;
    this.errorHandler = errorHandler;
    this.notificationManager = notificationManager;
    this.batches = [];
    this.isRunning = false;
    this.lastProcessedIndex = 0;
    // For resuming interrupted syncs
    this.processingTimeout = null;
    this.resumeFileList = [];
    this.options = {
      batchSize: 50,
      maxConcurrentBatches: 3,
      enableAutoInitialSync: true,
      priorityRules: [],
      syncFilePath: "_mindmatrixsync.md",
      exclusions: {
        excludedFolders: [],
        excludedFileTypes: [],
        excludedFilePrefixes: [],
        excludedFiles: []
      },
      ...options
    };
    this.progress = {
      totalFiles: 0,
      processedFiles: 0,
      currentBatch: 0,
      totalBatches: 0,
      startTime: 0
    };
    this.supabaseService = supabaseService;
  }
  /**
   * Filters files based on exclusion rules.
   */
  filterExcludedFiles(files) {
    const syncFilePath = this.options.syncFilePath || "_mindmatrixsync.md";
    const exclusions = this.options.exclusions || {
      excludedFolders: [],
      excludedFileTypes: [],
      excludedFilePrefixes: [],
      excludedFiles: []
    };
    return files.filter((file) => {
      const filePath = file.path;
      const fileName = file.name;
      if (filePath === syncFilePath || filePath === "_mindmatrixsync.md" || filePath === "_mindmatrixsync.md.backup") {
        return false;
      }
      if (exclusions.excludedFiles.includes(fileName))
        return false;
      if (exclusions.excludedFolders.some((folder) => filePath.startsWith(folder.endsWith("/") ? folder : folder + "/")))
        return false;
      if (exclusions.excludedFileTypes.some((ext) => filePath.toLowerCase().endsWith(ext.toLowerCase())))
        return false;
      if (exclusions.excludedFilePrefixes.some((prefix) => fileName.startsWith(prefix)))
        return false;
      return true;
    });
  }
  /**
   * Starts the initial sync process.
   * Scans all markdown files in the vault and updates their status in the database.
   * Resumes from the last processed file if the sync is interrupted.
   */
  async startSync() {
    if (this.isRunning) {
      console.log("Initial sync already running");
      return;
    }
    try {
      this.isRunning = true;
      this.progress.startTime = Date.now();
      console.log("Starting initial sync...");
      const allFiles = this.vault.getMarkdownFiles();
      const files = this.filterExcludedFiles(allFiles);
      this.resumeFileList = await this.sortFilesByPriority(files);
      this.progress.totalFiles = this.resumeFileList.length;
      console.log(`Total files to sync: ${this.progress.totalFiles}`);
      this.batches = this.createBatches(this.resumeFileList.slice(this.lastProcessedIndex));
      this.progress.totalBatches = this.batches.length;
      console.log(`Created ${this.progress.totalBatches} batches for syncing`);
      await this.processBatches();
      new import_obsidian10.Notice("Initial sync completed successfully");
      console.log("Initial sync completed");
      this.lastProcessedIndex = 0;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "InitialSyncManager.startSync" });
      new import_obsidian10.Notice("Initial sync failed. Check console for details.");
    } finally {
      this.isRunning = false;
    }
  }
  /**
   * Sort files by priority based on rules.
   * Files matching higher priority rules are sorted to the front.
   */
  async sortFilesByPriority(files) {
    return files.sort((a, b) => {
      const priorityA = this.getFilePriority(a.path);
      const priorityB = this.getFilePriority(b.path);
      console.log(`Priority for ${a.path}: ${priorityA}, ${b.path}: ${priorityB}`);
      return priorityB - priorityA;
    });
  }
  /**
   * Determine the processing priority for a file.
   * Returns the highest matching rule priority or defaults to 1.
   */
  getFilePriority(path) {
    for (const rule of this.options.priorityRules) {
      if (path.includes(rule.pattern)) {
        return rule.priority;
      }
    }
    return 1;
  }
  /**
   * Create batches of files for processing.
   */
  createBatches(files) {
    const syncFilePath = this.options.syncFilePath || "_mindmatrixsync.md";
    files = files.filter((file) => file.path !== syncFilePath && file.path !== "_mindmatrixsync.md" && file.path !== "_mindmatrixsync.md.backup");
    const batches = [];
    for (let i = 0; i < files.length; i += this.options.batchSize) {
      const batchFiles = files.slice(i, i + this.options.batchSize);
      batches.push({
        id: `batch-${Math.floor(i / this.options.batchSize)}`,
        files: batchFiles,
        status: "pending",
        progress: 0
      });
    }
    return batches;
  }
  /**
   * Process batches concurrently with a limit.
   * Updates resume progress in case of interruption.
   */
  async processBatches() {
    const activeBatches = /* @__PURE__ */ new Set();
    for (const batch of this.batches) {
      while (activeBatches.size >= this.options.maxConcurrentBatches) {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
      activeBatches.add(batch.id);
      this.processBatch(batch).then(() => {
        activeBatches.delete(batch.id);
        this.lastProcessedIndex += batch.files.length;
        console.log(`Completed ${batch.id}, resuming at index ${this.lastProcessedIndex}`);
      }).catch((error) => {
        this.errorHandler.handleError(error, { context: "InitialSyncManager.processBatch", metadata: { batchId: batch.id } });
        activeBatches.delete(batch.id);
      });
    }
    while (activeBatches.size > 0) {
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }
  /**
   * Process a single batch of files.
   */
  async processBatch(batch) {
    try {
      batch.status = "processing";
      batch.startTime = Date.now();
      console.log(`Processing ${batch.id} with ${batch.files.length} files`);
      for (const file of batch.files) {
        try {
          await this.processFile(file);
          this.progress.processedFiles++;
          batch.progress = this.progress.processedFiles / this.progress.totalFiles * 100;
          this.updateProgressNotification();
        } catch (error) {
          this.errorHandler.handleError(error, { context: "InitialSyncManager.processFile", metadata: { filePath: file.path } });
        }
      }
      batch.status = "completed";
      batch.endTime = Date.now();
      console.log(`Batch ${batch.id} completed in ${batch.endTime - (batch.startTime || 0)} ms`);
    } catch (error) {
      batch.status = "failed";
      throw error;
    }
  }
  /**
   * Process a single file.
   * Extracts metadata, calculates file hash, and updates its status.
   */
  async processFile(file) {
    try {
      const syncFilePath = this.options.syncFilePath || "_mindmatrixsync.md";
      if (file.path === syncFilePath || file.path === "_mindmatrixsync.md" || file.path === "_mindmatrixsync.md.backup") {
        return;
      }
      const metadata = await this.metadataExtractor.extractMetadata(file);
      const fileHash = await this.calculateFileHash(file);
      if (this.supabaseService) {
        await this.supabaseService.updateFileVectorizationStatus(metadata);
      } else {
        await this.syncManager.updateSyncStatus(file.path, "PENDING", {
          lastModified: file.stat.mtime,
          hash: fileHash
        });
      }
      await new Promise((resolve, reject) => {
        this.queueService.addTask({
          id: file.path,
          type: "CREATE",
          priority: this.getFilePriority(file.path),
          maxRetries: 3,
          retryCount: 0,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          status: "PENDING",
          metadata,
          data: {}
        }).then(async () => {
          if (this.supabaseService) {
            await this.supabaseService.updateFileVectorizationStatus(metadata);
          } else {
            await this.syncManager.updateSyncStatus(file.path, "OK", {
              lastModified: file.stat.mtime,
              hash: fileHash
            });
          }
          resolve();
        }).catch(reject);
      });
      console.log(`Processed file: ${file.path}`);
    } catch (error) {
      this.errorHandler.handleError(error, { context: "InitialSyncManager.processFile", metadata: { filePath: file.path } });
      throw error;
    }
  }
  /**
   * Calculate SHA-256 hash of a file's content.
   */
  async calculateFileHash(file) {
    try {
      const content = await this.vault.read(file);
      const encoder = new TextEncoder();
      const data = encoder.encode(content);
      const buffer = await crypto.subtle.digest("SHA-256", data);
      return Array.from(new Uint8Array(buffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
    } catch (error) {
      this.errorHandler.handleError(error, { context: "InitialSyncManager.calculateFileHash", metadata: { filePath: file.path } });
      return "";
    }
  }
  /**
   * Update progress notifications.
   */
  updateProgressNotification() {
    const progressPercentage = this.progress.processedFiles / this.progress.totalFiles * 100;
    this.notificationManager.updateProgress({
      taskId: "initial-sync",
      progress: progressPercentage,
      currentStep: `Processing files (${this.progress.processedFiles}/${this.progress.totalFiles})`,
      totalSteps: this.progress.totalBatches,
      currentStepNumber: this.progress.currentBatch + 1,
      estimatedTimeRemaining: this.calculateEstimatedTimeRemaining(),
      details: {
        processedFiles: this.progress.processedFiles,
        totalFiles: this.progress.totalFiles
      }
    });
  }
  /**
   * Calculate estimated time remaining based on progress.
   */
  calculateEstimatedTimeRemaining() {
    const elapsed = Date.now() - this.progress.startTime;
    const filesPerMs = this.progress.processedFiles / elapsed;
    const remainingFiles = this.progress.totalFiles - this.progress.processedFiles;
    return filesPerMs > 0 ? remainingFiles / filesPerMs : 0;
  }
  /**
   * Stops the initial sync process.
   */
  stop() {
    this.isRunning = false;
    if (this.processingTimeout) {
      clearTimeout(this.processingTimeout);
      this.processingTimeout = null;
    }
    new import_obsidian10.Notice("Initial sync stopped");
  }
  /**
   * Get current sync progress.
   */
  getProgress() {
    return { ...this.progress };
  }
  /**
   * Update sync options.
   */
  updateOptions(options) {
    Object.assign(this.options, options);
  }
};

// services/StatusManager.ts
var import_obsidian11 = require("obsidian");
var StatusManager = class {
  constructor(statusBarItem) {
    this.statusBarItem = statusBarItem;
    this.currentStatus = "initializing" /* INITIALIZING */;
    this.statusDetails = {
      message: "Initializing plugin...",
      timestamp: Date.now(),
      connectivityStatus: "unknown"
    };
    this.subscribers = /* @__PURE__ */ new Set();
    this.updateStatusBar();
  }
  /**
   * Update the current status with new details.
   */
  setStatus(status, details = {}) {
    const oldStatus = this.currentStatus;
    this.currentStatus = status;
    this.statusDetails = {
      ...this.statusDetails,
      ...details,
      timestamp: Date.now()
    };
    this.updateStatusBar();
    if (oldStatus !== status) {
      this.notifySubscribers();
    }
    if (status === "error" /* ERROR */ && details.message) {
      new import_obsidian11.Notice(`Mind Matrix: ${details.message}`);
    }
  }
  /**
   * Get the current status and details.
   */
  getStatus() {
    return { status: this.currentStatus, details: { ...this.statusDetails } };
  }
  /**
   * Subscribe to status changes.
   */
  subscribe(callback) {
    this.subscribers.add(callback);
    return () => {
      this.subscribers.delete(callback);
    };
  }
  /**
   * Update the status bar UI.
   */
  updateStatusBar() {
    this.statusBarItem.innerHTML = "";
    const icon = this.createStatusIcon();
    this.statusBarItem.appendChild(icon);
    const detailsText = document.createElement("span");
    detailsText.addClass("mind-matrix-status-details");
    let displayText = this.statusDetails.message;
    if (this.statusDetails.operation) {
      displayText += ` [${this.statusDetails.operation}]`;
    }
    if (this.statusDetails.step) {
      displayText += ` - ${this.statusDetails.step}`;
    }
    if (this.statusDetails.progress !== void 0) {
      displayText += ` (${this.statusDetails.progress}%)`;
    }
    detailsText.textContent = displayText;
    this.statusBarItem.appendChild(detailsText);
    let tooltip = this.statusDetails.message;
    if (this.statusDetails.connectivityStatus) {
      tooltip += ` | Connectivity: ${this.statusDetails.connectivityStatus}`;
    }
    if (this.statusDetails.lastDatabaseCheck) {
      tooltip += ` | Last DB Check: ${new Date(this.statusDetails.lastDatabaseCheck).toLocaleTimeString()}`;
    }
    if (this.statusDetails.queueSize !== void 0) {
      tooltip += ` | Queue: ${this.statusDetails.queueSize}`;
    }
    if (this.statusDetails.pendingChanges !== void 0) {
      tooltip += ` | Pending: ${this.statusDetails.pendingChanges}`;
    }
    this.statusBarItem.setAttribute("aria-label", tooltip);
    this.statusBarItem.onclick = () => {
      new import_obsidian11.Notice(tooltip);
    };
  }
  /**
   * Create status icon element based on current status.
   */
  createStatusIcon() {
    const icon = document.createElement("span");
    icon.addClass("mind-matrix-status-icon");
    switch (this.currentStatus) {
      case "ready" /* READY */:
      case "completed" /* COMPLETED */:
        icon.addClass("is-ready");
        icon.innerHTML = "\u25CF";
        break;
      case "error" /* ERROR */:
        icon.addClass("is-error");
        icon.innerHTML = "\u26A0";
        break;
      case "waiting_sync" /* WAITING_FOR_SYNC */:
      case "checking_file" /* CHECKING_FILE */:
      case "queuing" /* QUEUING */:
      case "processing_queue" /* PROCESSING_QUEUE */:
      case "pending" /* PENDING */:
        icon.addClass("is-working");
        icon.innerHTML = "\u21BB";
        break;
      case "in_progress" /* IN_PROGRESS */:
        icon.addClass("is-in-progress");
        icon.innerHTML = "\u25CB";
        break;
      default:
        icon.addClass("is-initializing");
        icon.innerHTML = "\u25CB";
    }
    return icon;
  }
  /**
   * Notify all subscribers of a status change.
   */
  notifySubscribers() {
    this.subscribers.forEach((callback) => {
      try {
        callback(this.currentStatus, this.statusDetails);
      } catch (error) {
        console.error("Error in status change subscriber:", error);
      }
    });
  }
  /**
   * Check if the plugin is currently in a specific status.
   */
  isInStatus(status) {
    return this.currentStatus === status;
  }
  /**
   * Update progress for the current task with detailed step info.
   * @param progress Percentage of completion.
   * @param currentStep Description of the current step.
   * @param operation Optional operation name.
   * @param additionalDetails Optional extra details.
   */
  updateProgress(progress, currentStep, operation, additionalDetails) {
    this.statusDetails.progress = progress;
    this.statusDetails.step = currentStep;
    if (operation) {
      this.statusDetails.operation = operation;
    }
    if (additionalDetails) {
      this.statusDetails = { ...this.statusDetails, ...additionalDetails };
    }
    this.updateStatusBar();
  }
};

// services/SyncDetectionManager.ts
var SyncDetectionManager = class {
  // 5 seconds
  constructor(plugin, statusManager, onQuietPeriodReached) {
    this.plugin = plugin;
    this.statusManager = statusManager;
    this.onQuietPeriodReached = onQuietPeriodReached;
    this.lastSyncActivity = 0;
    this.syncCheckInterval = null;
    this.quietPeriodReached = false;
    this.isWaitingForQuietPeriod = false;
    this.QUIET_PERIOD_MS = 5e3;
  }
  /**
   * Start monitoring for sync activity
   */
  startMonitoring() {
    this.plugin.registerEvent(
      this.plugin.app.vault.on("modify", () => this.recordSyncActivity())
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("create", () => this.recordSyncActivity())
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("delete", () => this.recordSyncActivity())
    );
    this.startQuietPeriodCheck();
  }
  /**
   * Record sync activity and reset quiet period
   */
  recordSyncActivity() {
    this.lastSyncActivity = Date.now();
    this.quietPeriodReached = false;
    if (this.isWaitingForQuietPeriod) {
      this.statusManager.setStatus("waiting_sync" /* WAITING_FOR_SYNC */, {
        message: "Waiting for Obsidian sync to settle..."
      });
    }
  }
  /**
   * Start checking for quiet period
   */
  startQuietPeriodCheck() {
    if (this.syncCheckInterval) {
      clearInterval(this.syncCheckInterval);
    }
    this.isWaitingForQuietPeriod = true;
    this.syncCheckInterval = setInterval(() => {
      const timeSinceLastSync = Date.now() - this.lastSyncActivity;
      if (timeSinceLastSync >= this.QUIET_PERIOD_MS && !this.quietPeriodReached) {
        this.quietPeriodReached = true;
        this.isWaitingForQuietPeriod = false;
        if (this.syncCheckInterval) {
          clearInterval(this.syncCheckInterval);
          this.syncCheckInterval = null;
        }
        this.onQuietPeriodReached();
      }
    }, 1e3);
  }
  /**
   * Stop monitoring for sync activity
   */
  stopMonitoring() {
    if (this.syncCheckInterval) {
      clearInterval(this.syncCheckInterval);
      this.syncCheckInterval = null;
    }
    this.isWaitingForQuietPeriod = false;
  }
  /**
   * Check if currently waiting for quiet period
   */
  isWaiting() {
    return this.isWaitingForQuietPeriod;
  }
  /**
   * Get time since last sync activity
   */
  getTimeSinceLastSync() {
    return Date.now() - this.lastSyncActivity;
  }
};

// main.ts
var MindMatrixPlugin = class extends import_obsidian12.Plugin {
  constructor() {
    super(...arguments);
    this.supabaseService = null;
    this.openAIService = null;
    this.queueService = null;
    this.fileTracker = null;
    this.errorHandler = null;
    this.notificationManager = null;
    this.isInitializing = false;
    this.syncManager = null;
    this.syncCheckInterval = null;
    this.initializationTimeout = null;
    this.syncCheckAttempts = 0;
    this.initialSyncManager = null;
    this.metadataExtractor = null;
    this.statusManager = null;
    this.syncDetectionManager = null;
  }
  async onload() {
    var _a2;
    console.log("Loading Mind Matrix Plugin...");
    try {
      this.statusManager = new StatusManager(this.addStatusBarItem());
      this.statusManager.setStatus("initializing" /* INITIALIZING */, {
        message: "Loading Mind Matrix Plugin..."
      });
      await this.loadSettings();
      await this.initializeCoreServices();
      await this.initializeVaultIfNeeded();
      this.addSettingTab(new MindMatrixSettingsTab(this.app, this));
      if (isVaultInitialized2(this.settings)) {
        this.statusManager.setStatus("waiting_sync" /* WAITING_FOR_SYNC */, {
          message: "Waiting for Obsidian sync to settle..."
        });
        this.syncDetectionManager = new SyncDetectionManager(
          this,
          this.statusManager,
          this.onSyncQuietPeriodReached.bind(this)
        );
        this.syncDetectionManager.startMonitoring();
      } else {
        await this.completeInitialization();
      }
    } catch (error) {
      console.error("Failed to initialize Mind Matrix Plugin:", error);
      (_a2 = this.statusManager) == null ? void 0 : _a2.setStatus("error" /* ERROR */, {
        message: "Failed to initialize plugin. Check console for details.",
        error
      });
    }
  }
  async onSyncQuietPeriodReached() {
    var _a2, _b, _c;
    try {
      (_a2 = this.syncDetectionManager) == null ? void 0 : _a2.stopMonitoring();
      (_b = this.statusManager) == null ? void 0 : _b.setStatus("checking_file" /* CHECKING_FILE */, {
        message: "Initializing sync manager with updated sync file format..."
      });
      await this.initializeSyncManager();
      await this.startSyncProcess();
      await this.completeInitialization();
    } catch (error) {
      console.error("Error during quiet period initialization:", error);
      (_c = this.statusManager) == null ? void 0 : _c.setStatus("error" /* ERROR */, {
        message: "Failed to initialize after sync quiet period",
        error
      });
    }
  }
  async completeInitialization() {
    var _a2, _b;
    try {
      this.registerEventHandlers();
      this.addCommands();
      (_a2 = this.statusManager) == null ? void 0 : _a2.setStatus("ready" /* READY */, {
        message: "Mind Matrix is ready"
      });
    } catch (error) {
      console.error("Error completing initialization:", error);
      (_b = this.statusManager) == null ? void 0 : _b.setStatus("error" /* ERROR */, {
        message: "Failed to complete initialization",
        error
      });
    }
  }
  async onunload() {
    var _a2, _b, _c, _d;
    console.log("Unloading Mind Matrix Plugin...");
    (_a2 = this.syncDetectionManager) == null ? void 0 : _a2.stopMonitoring();
    if (this.initializationTimeout)
      clearTimeout(this.initializationTimeout);
    if (this.syncCheckInterval)
      clearInterval(this.syncCheckInterval);
    (_b = this.queueService) == null ? void 0 : _b.stop();
    (_c = this.notificationManager) == null ? void 0 : _c.clear();
    (_d = this.initialSyncManager) == null ? void 0 : _d.stop();
  }
  async startSyncProcess() {
    var _a2, _b, _c, _d, _e, _f;
    if (!this.syncManager)
      throw new Error("Sync manager not initialized");
    try {
      (_a2 = this.statusManager) == null ? void 0 : _a2.setStatus("checking_file" /* CHECKING_FILE */, {
        message: "Checking sync file status with new structure..."
      });
      const syncStatus = await this.syncManager.validateSyncState();
      if (!syncStatus.isValid) {
        if (this.settings.sync.requireSync) {
          (_b = this.statusManager) == null ? void 0 : _b.setStatus("error" /* ERROR */, {
            message: `Sync validation failed: ${syncStatus.error}`
          });
          throw new Error(`Sync validation failed: ${syncStatus.error}`);
        } else {
          console.warn(`Sync validation warning: ${syncStatus.error}`);
          new import_obsidian12.Notice(`Sync warning: ${syncStatus.error}`);
        }
      }
      (_c = this.statusManager) == null ? void 0 : _c.setStatus("initializing" /* INITIALIZING */, {
        message: "Initializing services..."
      });
      await this.initializeServices();
      this.startPeriodicSyncChecks();
      if (this.settings.initialSync.enableAutoInitialSync && this.initialSyncManager) {
        (_d = this.statusManager) == null ? void 0 : _d.setStatus("initializing" /* INITIALIZING */, {
          message: "Starting initial vault sync..."
        });
        await this.initialSyncManager.startSync();
      }
      (_e = this.statusManager) == null ? void 0 : _e.setStatus("ready" /* READY */, {
        message: "Sync process completed"
      });
    } catch (error) {
      if (this.settings.sync.requireSync) {
        (_f = this.statusManager) == null ? void 0 : _f.setStatus("error" /* ERROR */, {
          message: "Sync process failed",
          error
        });
        throw error;
      } else {
        console.error("Sync process error:", error);
        new import_obsidian12.Notice("Sync process error. Continuing with limited functionality.");
        await this.initializeServices();
      }
    }
  }
  async initializeSyncManager() {
    if (!this.errorHandler)
      throw new Error("Error handler must be initialized before sync manager");
    if (!this.settings.vaultId) {
      this.settings.vaultId = generateVaultId();
      await this.saveSettings();
    }
    try {
      this.syncManager = new SyncFileManager(
        this.app.vault,
        this.errorHandler,
        this.settings.sync.syncFilePath,
        this.settings.sync.backupInterval,
        this.settings.vaultId,
        this.settings.sync.deviceId,
        this.settings.sync.deviceName,
        this.manifest.version
      );
      await this.syncManager.initialize();
      console.log("Sync manager initialized successfully with new sync file format");
    } catch (error) {
      console.error("Failed to initialize sync manager:", error);
      if (this.settings.enableNotifications)
        new import_obsidian12.Notice("Failed to initialize sync system. Some features may be unavailable.");
      throw error;
    }
  }
  async initializeCoreServices() {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    (_a2 = this.statusManager) == null ? void 0 : _a2.setStatus("initializing" /* INITIALIZING */, { message: "Initializing core services..." });
    this.errorHandler = new ErrorHandler((_c = (_b = this.settings) == null ? void 0 : _b.debug) != null ? _c : DEFAULT_SETTINGS.debug, this.app.vault.adapter.getBasePath());
    this.notificationManager = new NotificationManager(this.addStatusBarItem(), (_e = (_d = this.settings) == null ? void 0 : _d.enableNotifications) != null ? _e : true, (_g = (_f = this.settings) == null ? void 0 : _f.enableProgressBar) != null ? _g : true);
    (_h = this.statusManager) == null ? void 0 : _h.setStatus("initializing" /* INITIALIZING */, { message: "Core services initialized" });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (!this.settings.exclusions)
      this.settings.exclusions = { ...DEFAULT_SETTINGS.exclusions };
    if (!this.settings.exclusions.excludedFolders)
      this.settings.exclusions.excludedFolders = [];
    if (!this.settings.exclusions.excludedFileTypes)
      this.settings.exclusions.excludedFileTypes = [];
    if (!this.settings.exclusions.excludedFilePrefixes)
      this.settings.exclusions.excludedFilePrefixes = [];
    if (!this.settings.exclusions.excludedFiles)
      this.settings.exclusions.excludedFiles = [];
    if (!this.settings.exclusions.systemExcludedFolders)
      this.settings.exclusions.systemExcludedFolders = [...SYSTEM_EXCLUSIONS.folders];
    if (!this.settings.exclusions.systemExcludedFileTypes)
      this.settings.exclusions.systemExcludedFileTypes = [...SYSTEM_EXCLUSIONS.fileTypes];
    if (!this.settings.exclusions.systemExcludedFilePrefixes)
      this.settings.exclusions.systemExcludedFilePrefixes = [...SYSTEM_EXCLUSIONS.filePrefixes];
    if (!this.settings.exclusions.systemExcludedFiles)
      this.settings.exclusions.systemExcludedFiles = [...SYSTEM_EXCLUSIONS.files];
  }
  async saveSettings() {
    var _a2, _b;
    await this.saveData(this.settings);
    (_a2 = this.notificationManager) == null ? void 0 : _a2.updateSettings(this.settings.enableNotifications, this.settings.enableProgressBar);
    (_b = this.errorHandler) == null ? void 0 : _b.updateSettings(this.settings.debug);
    if (isVaultInitialized2(this.settings))
      await this.initializeServices();
  }
  startPeriodicSyncChecks() {
    if (this.syncCheckInterval)
      clearInterval(this.syncCheckInterval);
    this.syncCheckInterval = setInterval(async () => {
      await this.performSyncCheck();
    }, this.settings.sync.checkInterval);
  }
  async performSyncCheck() {
    var _a2;
    if (!this.syncManager)
      return;
    try {
      const syncStatus = await this.syncManager.validateSyncState();
      if (!syncStatus.isValid) {
        console.warn(`Sync check failed: ${syncStatus.error}`);
        if (this.settings.enableNotifications)
          new import_obsidian12.Notice(`Sync issue detected: ${syncStatus.error}`);
        const recovered = await this.syncManager.attemptRecovery();
        if (!recovered && this.settings.sync.requireSync)
          await this.restartServices();
      }
      await this.syncManager.updateLastSync();
    } catch (error) {
      (_a2 = this.errorHandler) == null ? void 0 : _a2.handleError(error, { context: "performSyncCheck", metadata: { timestamp: Date.now() } });
    }
  }
  async restartServices() {
    var _a2;
    (_a2 = this.queueService) == null ? void 0 : _a2.stop();
    if (this.syncCheckInterval)
      clearInterval(this.syncCheckInterval);
    try {
      await this.initializeSyncManager();
      await this.startSyncProcess();
    } catch (error) {
      console.error("Failed to restart services:", error);
      if (this.settings.enableNotifications)
        new import_obsidian12.Notice("Failed to restart services after sync error");
    }
  }
  async initializeVaultIfNeeded() {
    if (this.isInitializing)
      return;
    this.isInitializing = true;
    try {
      if (!isVaultInitialized2(this.settings)) {
        this.settings.vaultId = generateVaultId();
        this.settings.lastKnownVaultName = this.app.vault.getName();
        await this.saveSettings();
        if (this.settings.enableNotifications)
          new import_obsidian12.Notice("Vault initialized with new ID");
      } else if (this.settings.lastKnownVaultName !== this.app.vault.getName()) {
        this.settings.lastKnownVaultName = this.app.vault.getName();
        await this.saveSettings();
      }
    } finally {
      this.isInitializing = false;
    }
  }
  async initializeServices() {
    console.log("Initializing services...", { hasVault: !!this.app.vault, hasErrorHandler: !!this.errorHandler });
    if (!this.errorHandler)
      throw new Error("Core services not initialized");
    try {
      this.fileTracker = new FileTracker(this.app.vault, this.errorHandler, this.settings.sync.syncFilePath);
      await this.fileTracker.initialize();
      console.log("FileTracker initialized.");
      try {
        this.supabaseService = await SupabaseService.getInstance(this.settings);
        if (!this.supabaseService) {
          new import_obsidian12.Notice("Supabase service not initialized. Please configure your API settings.");
          console.error("Supabase service initialization failed: Missing configuration.");
          return;
        }
        console.log("Supabase service initialized.");
      } catch (error) {
        console.error("Supabase initialization error:", error);
        new import_obsidian12.Notice(`Failed to initialize Supabase service: ${error.message}`);
        return;
      }
      this.openAIService = new OpenAIService(this.settings.openai, this.errorHandler);
      console.log("OpenAI service initialized.");
      if (!this.app.vault)
        throw new Error("Vault is not available");
      if (this.notificationManager && this.supabaseService && this.openAIService) {
        try {
          this.queueService = new QueueService(
            this.settings.queue.maxConcurrent,
            this.settings.queue.retryAttempts,
            this.supabaseService,
            this.openAIService,
            this.errorHandler,
            this.notificationManager,
            this.app.vault,
            this.settings.chunking
          );
          this.queueService.start();
          console.log("Queue service initialized and started.");
        } catch (error) {
          console.error("Failed to initialize QueueService:", error);
          new import_obsidian12.Notice(`Failed to initialize queue service: ${error.message}`);
          throw error;
        }
      } else {
        throw new Error("Required services not available for QueueService initialization");
      }
      this.metadataExtractor = new MetadataExtractor();
      console.log("MetadataExtractor initialized.");
      if (this.queueService && this.syncManager && this.metadataExtractor) {
        const initialSyncOptions = {
          ...this.settings.initialSync,
          syncFilePath: this.settings.sync.syncFilePath,
          exclusions: getAllExclusions2(this.settings)
        };
        this.initialSyncManager = new InitialSyncManager(
          this.app.vault,
          this.queueService,
          this.syncManager,
          this.metadataExtractor,
          this.errorHandler,
          this.notificationManager,
          this.supabaseService,
          initialSyncOptions
        );
        console.log("InitialSyncManager initialized.");
      }
    } catch (error) {
      console.error("Failed to initialize services:", error);
      throw error;
    }
  }
  checkRequiredConfigurations() {
    if (!this.settings.openai.apiKey) {
      new import_obsidian12.Notice("OpenAI API key is missing. AI features are disabled. Configure it in the settings.");
    }
    if (!this.settings.supabase.url || !this.settings.supabase.apiKey) {
      new import_obsidian12.Notice("Supabase configuration is incomplete. Database features are disabled. Configure it in the settings.");
    }
  }
  registerEventHandlers() {
    this.registerEvent(
      this.app.vault.on("create", async (file) => {
        var _a2;
        if (!(file instanceof import_obsidian12.TFile))
          return;
        if (!await this.ensureSyncFileExists()) {
          new import_obsidian12.Notice("Failed to create sync file. Plugin functionality limited.");
          return;
        }
        if (!this.shouldProcessFile(file))
          return;
        console.log(`File created: ${file.path}`);
        await ((_a2 = this.fileTracker) == null ? void 0 : _a2.handleCreate(file));
        await this.queueFileProcessing(file, "CREATE");
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", async (file) => {
        var _a2;
        if (!(file instanceof import_obsidian12.TFile))
          return;
        if (!await this.ensureSyncFileExists()) {
          new import_obsidian12.Notice("Failed to create sync file. Plugin functionality limited.");
          return;
        }
        if (!this.shouldProcessFile(file))
          return;
        console.log(`File modified: ${file.path}`);
        await ((_a2 = this.fileTracker) == null ? void 0 : _a2.handleModify(file));
        await this.queueFileProcessing(file, "UPDATE");
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", async (file) => {
        var _a2;
        if (!(file instanceof import_obsidian12.TFile))
          return;
        if (file.path === this.settings.sync.syncFilePath) {
          console.log("Sync file was deleted, will recreate on next operation");
          return;
        }
        if (!await this.ensureSyncFileExists()) {
          new import_obsidian12.Notice("Failed to create sync file. Plugin functionality limited.");
          return;
        }
        if (!this.shouldProcessFile(file))
          return;
        console.log(`File deleted: ${file.path}`);
        await ((_a2 = this.fileTracker) == null ? void 0 : _a2.handleDelete(file));
        await this.queueFileProcessing(file, "DELETE");
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", async (file, oldPath) => {
        var _a2;
        if (!(file instanceof import_obsidian12.TFile))
          return;
        if (!await this.ensureSyncFileExists()) {
          new import_obsidian12.Notice("Failed to create sync file. Plugin functionality limited.");
          return;
        }
        if (!this.shouldProcessFile(file))
          return;
        console.log(`File renamed from ${oldPath} to ${file.path}`);
        await ((_a2 = this.fileTracker) == null ? void 0 : _a2.handleRename(file, oldPath));
        await this.handleFileRename(file, oldPath);
      })
    );
  }
  shouldProcessFile(file) {
    if (!this.queueService || !isVaultInitialized2(this.settings))
      return false;
    if (!this.settings.enableAutoSync)
      return false;
    const allExclusions = getAllExclusions2(this.settings);
    const filePath = file.path;
    const fileName = file.name;
    if (filePath === this.settings.sync.syncFilePath || filePath === this.settings.sync.syncFilePath + ".backup") {
      console.log(`Skipping sync file: ${filePath}`);
      return false;
    }
    if (Array.isArray(allExclusions.excludedFiles) && allExclusions.excludedFiles.includes(fileName)) {
      console.log("Skipping excluded file:", fileName);
      return false;
    }
    if (Array.isArray(allExclusions.excludedFolders)) {
      const isExcludedFolder = allExclusions.excludedFolders.some((folder) => {
        const normalizedFolder = folder.endsWith("/") ? folder : folder + "/";
        return filePath.startsWith(normalizedFolder);
      });
      if (isExcludedFolder) {
        console.log("Skipping file in excluded folder:", filePath);
        return false;
      }
    }
    if (Array.isArray(allExclusions.excludedFileTypes)) {
      const isExcludedType = allExclusions.excludedFileTypes.some((ext) => filePath.toLowerCase().endsWith(ext.toLowerCase()));
      if (isExcludedType) {
        console.log("Skipping excluded file type:", filePath);
        return false;
      }
    }
    if (Array.isArray(allExclusions.excludedFilePrefixes)) {
      const isExcludedPrefix = allExclusions.excludedFilePrefixes.some((prefix) => fileName.startsWith(prefix));
      if (isExcludedPrefix) {
        console.log("Skipping file with excluded prefix:", fileName);
        return false;
      }
    }
    return true;
  }
  async ensureSyncFileExists() {
    if (!this.syncManager) {
      console.error("Sync manager not initialized");
      return false;
    }
    try {
      const syncFile = this.app.vault.getAbstractFileByPath(this.settings.sync.syncFilePath);
      if (!syncFile) {
        console.log("Sync file missing, recreating...");
        await this.syncManager.initialize();
        new import_obsidian12.Notice("Recreated sync file");
        return true;
      }
      return true;
    } catch (error) {
      console.error("Error ensuring sync file exists:", error);
      return false;
    }
  }
  async queueFileProcessing(file, type) {
    var _a2;
    try {
      if (!this.queueService || !this.fileTracker) {
        console.error("Required services not initialized:", { queueService: !!this.queueService, fileTracker: !!this.fileTracker });
        return;
      }
      console.log("Queueing file processing:", { fileName: file.name, type, path: file.path });
      const metadata = await this.fileTracker.createFileMetadata(file);
      console.log("Created metadata:", metadata);
      const task = {
        id: file.path,
        type,
        priority: type === "DELETE" ? 2 : 1,
        maxRetries: this.settings.queue.retryAttempts,
        retryCount: 0,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        status: "PENDING",
        metadata,
        data: {}
      };
      console.log("Created task:", task);
      await this.queueService.addTask(task);
      console.log("Task added to queue");
      if (this.settings.enableNotifications) {
        const action = type.toLowerCase();
        new import_obsidian12.Notice(`Queued ${action} for processing: ${file.name}`);
      }
    } catch (error) {
      console.error("Error in queueFileProcessing:", error);
      (_a2 = this.errorHandler) == null ? void 0 : _a2.handleError(error, { context: "queueFileProcessing", metadata: { filePath: file.path, type } });
      if (this.settings.enableNotifications) {
        new import_obsidian12.Notice(`Failed to queue ${file.name} for processing`);
      }
    }
  }
  async handleFileRename(file, oldPath) {
    var _a2;
    try {
      if (!this.supabaseService)
        return;
      await this.supabaseService.updateFilePath(oldPath, file.path);
      const chunks = await this.supabaseService.getDocumentChunks(oldPath);
      if (chunks.length > 0) {
        const updatedChunks = chunks.map((chunk) => ({
          ...chunk,
          metadata: {
            ...chunk.metadata,
            obsidianId: file.path,
            path: file.path
          }
        }));
        await this.supabaseService.deleteDocumentChunks(oldPath);
        await this.supabaseService.upsertChunks(updatedChunks);
      }
      if (this.settings.enableNotifications) {
        new import_obsidian12.Notice(`Updated database entries for renamed file: ${file.name}`);
      }
    } catch (error) {
      (_a2 = this.errorHandler) == null ? void 0 : _a2.handleError(error, { context: "handleFileRename", metadata: { filePath: file.path, oldPath } });
      if (this.settings.enableNotifications) {
        new import_obsidian12.Notice(`Failed to update database for renamed file: ${file.name}`);
      }
    }
  }
  addCommands() {
    this.addCommand({
      id: "force-sync-current-file",
      name: "Force sync current file",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          if (!checking) {
            this.queueFileProcessing(file, "UPDATE");
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "force-sync-all-files",
      name: "Force sync all files",
      callback: async () => {
        const files = this.app.vault.getMarkdownFiles();
        for (const file of files) {
          if (this.shouldProcessFile(file)) {
            await this.queueFileProcessing(file, "UPDATE");
          }
        }
      }
    });
    this.addCommand({
      id: "clear-sync-queue",
      name: "Clear sync queue",
      callback: () => {
        var _a2;
        (_a2 = this.queueService) == null ? void 0 : _a2.clear();
        if (this.settings.enableNotifications) {
          new import_obsidian12.Notice("Sync queue cleared");
        }
      }
    });
    this.addCommand({
      id: "reset-file-tracker",
      name: "Reset file tracker cache",
      callback: async () => {
        var _a2, _b;
        (_a2 = this.fileTracker) == null ? void 0 : _a2.clearQueue();
        await ((_b = this.fileTracker) == null ? void 0 : _b.initialize());
        if (this.settings.enableNotifications) {
          new import_obsidian12.Notice("File tracker cache reset");
        }
      }
    });
    this.addCommand({
      id: "start-initial-sync",
      name: "Start initial vault sync",
      callback: async () => {
        if (this.initialSyncManager) {
          await this.initialSyncManager.startSync();
        } else {
          new import_obsidian12.Notice("Initial sync manager not initialized");
        }
      }
    });
    this.addCommand({
      id: "stop-initial-sync",
      name: "Stop initial vault sync",
      callback: () => {
        var _a2;
        (_a2 = this.initialSyncManager) == null ? void 0 : _a2.stop();
        new import_obsidian12.Notice("Initial sync stopped");
      }
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9ub2RlLWZldGNoL2Jyb3dzZXIuanMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL1Bvc3RncmVzdEVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RCdWlsZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9zcmMvUG9zdGdyZXN0Q2xpZW50LnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9pbmRleC50cyIsICJub2RlX21vZHVsZXMvd3MvYnJvd3Nlci5qcyIsICJtYWluLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL3NyYy9oZWxwZXIudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9mdW5jdGlvbnMtanMvc3JjL3R5cGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL3NyYy9GdW5jdGlvbnNDbGllbnQudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9lc20vd3JhcHBlci5tanMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvc2VyaWFsaXplci50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvdGltZXIudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL3RyYW5zZm9ybWVycy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvcHVzaC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9SZWFsdGltZVByZXNlbmNlLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvc3JjL1JlYWx0aW1lQ2hhbm5lbC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9SZWFsdGltZUNsaWVudC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL2xpYi9lcnJvcnMudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL3NyYy9saWIvaGVscGVycy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL2xpYi9mZXRjaC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL3BhY2thZ2VzL1N0b3JhZ2VGaWxlQXBpLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL3NyYy9saWIvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9zcmMvcGFja2FnZXMvU3RvcmFnZUJ1Y2tldEFwaS50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL1N0b3JhZ2VDbGllbnQudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9saWIvZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL2hlbHBlcnMudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvdmVyc2lvbi50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvaGVscGVycy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9lcnJvcnMudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9Hb1RydWVBZG1pbkFwaS50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9sb2NhbC1zdG9yYWdlLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9zcmMvbGliL3BvbHlmaWxscy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9sb2Nrcy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL0dvVHJ1ZUNsaWVudC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL0F1dGhDbGllbnQudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL1N1cGFiYXNlQXV0aENsaWVudC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9TdXBhYmFzZUNsaWVudC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9pbmRleC50cyIsICJzZXR0aW5ncy9TZXR0aW5ncy50cyIsICJzZXJ2aWNlcy9TdXBhYmFzZVNlcnZpY2UudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvaW50ZXJuYWwvcXMvZm9ybWF0cy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9pbnRlcm5hbC9xcy91dGlscy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9pbnRlcm5hbC9xcy9zdHJpbmdpZnkudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvdmVyc2lvbi50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9fc2hpbXMvcmVnaXN0cnkudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvX3NoaW1zL011bHRpcGFydEJvZHkudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvX3NoaW1zL3dlYi1ydW50aW1lLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvX3NoaW1zL2luZGV4Lm1qcyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9lcnJvci50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9pbnRlcm5hbC9kZWNvZGVycy9saW5lLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3N0cmVhbWluZy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy91cGxvYWRzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2NvcmUudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcGFnaW5hdGlvbi50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZS50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvY2hhdC9jaGF0LnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9hdWRpby9zcGVlY2gudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2F1ZGlvL3RyYW5zY3JpcHRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9hdWRpby90cmFuc2xhdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2F1ZGlvL2F1ZGlvLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iYXRjaGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL2Fzc2lzdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL1J1bm5hYmxlRnVuY3Rpb24udHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL2NoYXRDb21wbGV0aW9uVXRpbHMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0V2ZW50U3RyZWFtLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2xpYi9wYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXIudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0NoYXRDb21wbGV0aW9uUnVubmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL192ZW5kb3IvcGFydGlhbC1qc29uLXBhcnNlci9wYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2xpYi9DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lci50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9jaGF0L2NvbXBsZXRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL2NoYXQvY2hhdC50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9yZWFsdGltZS9zZXNzaW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9yZWFsdGltZS9yZWFsdGltZS50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9saWIvQXNzaXN0YW50U3RyZWFtLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvbWVzc2FnZXMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2JldGEvdGhyZWFkcy9ydW5zL3N0ZXBzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvcnVucy9ydW5zLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvdGhyZWFkcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9saWIvVXRpbC50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS92ZWN0b3Itc3RvcmVzL2ZpbGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3ZlY3Rvci1zdG9yZXMvZmlsZS1iYXRjaGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3ZlY3Rvci1zdG9yZXMvdmVjdG9yLXN0b3Jlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9iZXRhLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9jb21wbGV0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZW1iZWRkaW5ncy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmlsZXMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ZpbmUtdHVuaW5nL2pvYnMvY2hlY2twb2ludHMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ZpbmUtdHVuaW5nL2pvYnMvam9icy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmluZS10dW5pbmcvZmluZS10dW5pbmcudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ltYWdlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvbW9kZWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9tb2RlcmF0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvdXBsb2Fkcy9wYXJ0cy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvdXBsb2Fkcy91cGxvYWRzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2luZGV4LnRzIiwgInNlcnZpY2VzL09wZW5BSVNlcnZpY2UudHMiLCAic2VydmljZXMvUXVldWVTZXJ2aWNlLnRzIiwgInNlcnZpY2VzL01ldGFkYXRhRXh0cmFjdG9yLnRzIiwgInV0aWxzL1RleHRTcGxpdHRlci50cyIsICJzZXJ2aWNlcy9FdmVudEVtaXR0ZXIudHMiLCAidXRpbHMvRmlsZVRyYWNrZXIudHMiLCAic2VydmljZXMvU3luY0ZpbGVNYW5hZ2VyLnRzIiwgIm1vZGVscy9TeW5jTW9kZWxzLnRzIiwgInV0aWxzL0Vycm9ySGFuZGxlci50cyIsICJ1dGlscy9Ob3RpZmljYXRpb25NYW5hZ2VyLnRzIiwgInNldHRpbmdzL1NldHRpbmdzVGFiLnRzIiwgInNlcnZpY2VzL0luaXRpYWxTeW5jTWFuYWdlci50cyIsICJzZXJ2aWNlcy9TdGF0dXNNYW5hZ2VyLnRzIiwgInNlcnZpY2VzL1N5bmNEZXRlY3Rpb25NYW5hZ2VyLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJcInVzZSBzdHJpY3RcIjtcblxuLy8gcmVmOiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciBnZXRHbG9iYWwgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB0aGUgb25seSByZWxpYWJsZSBtZWFucyB0byBnZXQgdGhlIGdsb2JhbCBvYmplY3QgaXNcbiAgICAvLyBgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKWBcbiAgICAvLyBIb3dldmVyLCB0aGlzIGNhdXNlcyBDU1AgdmlvbGF0aW9ucyBpbiBDaHJvbWUgYXBwcy5cbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBzZWxmOyB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiB3aW5kb3c7IH1cbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGdsb2JhbDsgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jyk7XG59XG5cbnZhciBnbG9iYWxPYmplY3QgPSBnZXRHbG9iYWwoKTtcblxuZXhwb3J0IGNvbnN0IGZldGNoID0gZ2xvYmFsT2JqZWN0LmZldGNoO1xuXG5leHBvcnQgZGVmYXVsdCBnbG9iYWxPYmplY3QuZmV0Y2guYmluZChnbG9iYWxPYmplY3QpO1xuXG5leHBvcnQgY29uc3QgSGVhZGVycyA9IGdsb2JhbE9iamVjdC5IZWFkZXJzO1xuZXhwb3J0IGNvbnN0IFJlcXVlc3QgPSBnbG9iYWxPYmplY3QuUmVxdWVzdDtcbmV4cG9ydCBjb25zdCBSZXNwb25zZSA9IGdsb2JhbE9iamVjdC5SZXNwb25zZTtcbiIsICIvKipcbiAqIEVycm9yIGZvcm1hdFxuICpcbiAqIHtAbGluayBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sP2hpZ2hsaWdodD1vcHRpb25zI2Vycm9ycy1hbmQtaHR0cC1zdGF0dXMtY29kZXN9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBkZXRhaWxzOiBzdHJpbmdcbiAgaGludDogc3RyaW5nXG4gIGNvZGU6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IHsgbWVzc2FnZTogc3RyaW5nOyBkZXRhaWxzOiBzdHJpbmc7IGhpbnQ6IHN0cmluZzsgY29kZTogc3RyaW5nIH0pIHtcbiAgICBzdXBlcihjb250ZXh0Lm1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1Bvc3RncmVzdEVycm9yJ1xuICAgIHRoaXMuZGV0YWlscyA9IGNvbnRleHQuZGV0YWlsc1xuICAgIHRoaXMuaGludCA9IGNvbnRleHQuaGludFxuICAgIHRoaXMuY29kZSA9IGNvbnRleHQuY29kZVxuICB9XG59XG4iLCAiLy8gQHRzLWlnbm9yZVxuaW1wb3J0IG5vZGVGZXRjaCBmcm9tICdAc3VwYWJhc2Uvbm9kZS1mZXRjaCdcblxuaW1wb3J0IHR5cGUgeyBGZXRjaCwgUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2UsIFBvc3RncmVzdFJlc3BvbnNlU3VjY2VzcyB9IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQgUG9zdGdyZXN0RXJyb3IgZnJvbSAnLi9Qb3N0Z3Jlc3RFcnJvcidcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUG9zdGdyZXN0QnVpbGRlcjxSZXN1bHQsIFRocm93T25FcnJvciBleHRlbmRzIGJvb2xlYW4gPSBmYWxzZT5cbiAgaW1wbGVtZW50c1xuICAgIFByb21pc2VMaWtlPFxuICAgICAgVGhyb3dPbkVycm9yIGV4dGVuZHMgdHJ1ZSA/IFBvc3RncmVzdFJlc3BvbnNlU3VjY2VzczxSZXN1bHQ+IDogUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2U8UmVzdWx0PlxuICAgID5cbntcbiAgcHJvdGVjdGVkIG1ldGhvZDogJ0dFVCcgfCAnSEVBRCcgfCAnUE9TVCcgfCAnUEFUQ0gnIHwgJ0RFTEVURSdcbiAgcHJvdGVjdGVkIHVybDogVVJMXG4gIHByb3RlY3RlZCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIHByb3RlY3RlZCBzY2hlbWE/OiBzdHJpbmdcbiAgcHJvdGVjdGVkIGJvZHk/OiB1bmtub3duXG4gIHByb3RlY3RlZCBzaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZVxuICBwcm90ZWN0ZWQgc2lnbmFsPzogQWJvcnRTaWduYWxcbiAgcHJvdGVjdGVkIGZldGNoOiBGZXRjaFxuICBwcm90ZWN0ZWQgaXNNYXliZVNpbmdsZTogYm9vbGVhblxuXG4gIGNvbnN0cnVjdG9yKGJ1aWxkZXI6IFBvc3RncmVzdEJ1aWxkZXI8UmVzdWx0Pikge1xuICAgIHRoaXMubWV0aG9kID0gYnVpbGRlci5tZXRob2RcbiAgICB0aGlzLnVybCA9IGJ1aWxkZXIudXJsXG4gICAgdGhpcy5oZWFkZXJzID0gYnVpbGRlci5oZWFkZXJzXG4gICAgdGhpcy5zY2hlbWEgPSBidWlsZGVyLnNjaGVtYVxuICAgIHRoaXMuYm9keSA9IGJ1aWxkZXIuYm9keVxuICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gYnVpbGRlci5zaG91bGRUaHJvd09uRXJyb3JcbiAgICB0aGlzLnNpZ25hbCA9IGJ1aWxkZXIuc2lnbmFsXG4gICAgdGhpcy5pc01heWJlU2luZ2xlID0gYnVpbGRlci5pc01heWJlU2luZ2xlXG5cbiAgICBpZiAoYnVpbGRlci5mZXRjaCkge1xuICAgICAgdGhpcy5mZXRjaCA9IGJ1aWxkZXIuZmV0Y2hcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuZmV0Y2ggPSBub2RlRmV0Y2hcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mZXRjaCA9IGZldGNoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZXJlJ3MgYW4gZXJyb3Igd2l0aCB0aGUgcXVlcnksIHRocm93T25FcnJvciB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZSBieVxuICAgKiB0aHJvd2luZyB0aGUgZXJyb3IgaW5zdGVhZCBvZiByZXR1cm5pbmcgaXQgYXMgcGFydCBvZiBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gICAqXG4gICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2Uvc3VwYWJhc2UtanMvaXNzdWVzLzkyfVxuICAgKi9cbiAgdGhyb3dPbkVycm9yKCk6IHRoaXMgJiBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdCwgdHJ1ZT4ge1xuICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZVxuICAgIHJldHVybiB0aGlzIGFzIHRoaXMgJiBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdCwgdHJ1ZT5cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYW4gSFRUUCBoZWFkZXIgZm9yIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgc2V0SGVhZGVyKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMuaGVhZGVycyA9IHsgLi4udGhpcy5oZWFkZXJzIH1cbiAgICB0aGlzLmhlYWRlcnNbbmFtZV0gPSB2YWx1ZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0aGVuPFxuICAgIFRSZXN1bHQxID0gVGhyb3dPbkVycm9yIGV4dGVuZHMgdHJ1ZVxuICAgICAgPyBQb3N0Z3Jlc3RSZXNwb25zZVN1Y2Nlc3M8UmVzdWx0PlxuICAgICAgOiBQb3N0Z3Jlc3RTaW5nbGVSZXNwb25zZTxSZXN1bHQ+LFxuICAgIFRSZXN1bHQyID0gbmV2ZXJcbiAgPihcbiAgICBvbmZ1bGZpbGxlZD86XG4gICAgICB8ICgoXG4gICAgICAgICAgdmFsdWU6IFRocm93T25FcnJvciBleHRlbmRzIHRydWVcbiAgICAgICAgICAgID8gUG9zdGdyZXN0UmVzcG9uc2VTdWNjZXNzPFJlc3VsdD5cbiAgICAgICAgICAgIDogUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2U8UmVzdWx0PlxuICAgICAgICApID0+IFRSZXN1bHQxIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDE+KVxuICAgICAgfCB1bmRlZmluZWRcbiAgICAgIHwgbnVsbCxcbiAgICBvbnJlamVjdGVkPzogKChyZWFzb246IGFueSkgPT4gVFJlc3VsdDIgfCBQcm9taXNlTGlrZTxUUmVzdWx0Mj4pIHwgdW5kZWZpbmVkIHwgbnVsbFxuICApOiBQcm9taXNlTGlrZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiB7XG4gICAgLy8gaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNzd2l0Y2hpbmctc2NoZW1hc1xuICAgIGlmICh0aGlzLnNjaGVtYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBza2lwXG4gICAgfSBlbHNlIGlmIChbJ0dFVCcsICdIRUFEJ10uaW5jbHVkZXModGhpcy5tZXRob2QpKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdC1Qcm9maWxlJ10gPSB0aGlzLnNjaGVtYVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ0NvbnRlbnQtUHJvZmlsZSddID0gdGhpcy5zY2hlbWFcbiAgICB9XG4gICAgaWYgKHRoaXMubWV0aG9kICE9PSAnR0VUJyAmJiB0aGlzLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgfVxuXG4gICAgLy8gTk9URTogSW52b2tlIHcvbyBgdGhpc2AgdG8gYXZvaWQgaWxsZWdhbCBpbnZvY2F0aW9uIGVycm9yLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvcHVsbC8yNDdcbiAgICBjb25zdCBfZmV0Y2ggPSB0aGlzLmZldGNoXG4gICAgbGV0IHJlcyA9IF9mZXRjaCh0aGlzLnVybC50b1N0cmluZygpLCB7XG4gICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodGhpcy5ib2R5KSxcbiAgICAgIHNpZ25hbDogdGhpcy5zaWduYWwsXG4gICAgfSkudGhlbihhc3luYyAocmVzKSA9PiB7XG4gICAgICBsZXQgZXJyb3IgPSBudWxsXG4gICAgICBsZXQgZGF0YSA9IG51bGxcbiAgICAgIGxldCBjb3VudDogbnVtYmVyIHwgbnVsbCA9IG51bGxcbiAgICAgIGxldCBzdGF0dXMgPSByZXMuc3RhdHVzXG4gICAgICBsZXQgc3RhdHVzVGV4dCA9IHJlcy5zdGF0dXNUZXh0XG5cbiAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgaWYgKHRoaXMubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzLnRleHQoKVxuICAgICAgICAgIGlmIChib2R5ID09PSAnJykge1xuICAgICAgICAgICAgLy8gUHJlZmVyOiByZXR1cm49bWluaW1hbFxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9PT0gJ3RleHQvY3N2Jykge1xuICAgICAgICAgICAgZGF0YSA9IGJvZHlcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSAmJlxuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXS5pbmNsdWRlcygnYXBwbGljYXRpb24vdm5kLnBncnN0LnBsYW4rdGV4dCcpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkYXRhID0gYm9keVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShib2R5KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvdW50SGVhZGVyID0gdGhpcy5oZWFkZXJzWydQcmVmZXInXT8ubWF0Y2goL2NvdW50PShleGFjdHxwbGFubmVkfGVzdGltYXRlZCkvKVxuICAgICAgICBjb25zdCBjb250ZW50UmFuZ2UgPSByZXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtcmFuZ2UnKT8uc3BsaXQoJy8nKVxuICAgICAgICBpZiAoY291bnRIZWFkZXIgJiYgY29udGVudFJhbmdlICYmIGNvbnRlbnRSYW5nZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgY291bnQgPSBwYXJzZUludChjb250ZW50UmFuZ2VbMV0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZW1wb3JhcnkgcGFydGlhbCBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzM2MVxuICAgICAgICAvLyBJc3N1ZSBwZXJzaXN0cyBlLmcuIGZvciBgLmluc2VydChbLi4uXSkuc2VsZWN0KCkubWF5YmVTaW5nbGUoKWBcbiAgICAgICAgaWYgKHRoaXMuaXNNYXliZVNpbmdsZSAmJiB0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgJiYgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vUG9zdGdSRVNUL3Bvc3RncmVzdC9ibG9iL2E4NjdkNzljNDI0MTlhZjE2YzE4YzNmYjAxOWViYThkZjk5MjYyNmYvc3JjL1Bvc3RnUkVTVC9FcnJvci5ocyNMNTUzXG4gICAgICAgICAgICAgIGNvZGU6ICdQR1JTVDExNicsXG4gICAgICAgICAgICAgIGRldGFpbHM6IGBSZXN1bHRzIGNvbnRhaW4gJHtkYXRhLmxlbmd0aH0gcm93cywgYXBwbGljYXRpb24vdm5kLnBncnN0Lm9iamVjdCtqc29uIHJlcXVpcmVzIDEgcm93YCxcbiAgICAgICAgICAgICAgaGludDogbnVsbCxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ0pTT04gb2JqZWN0IHJlcXVlc3RlZCwgbXVsdGlwbGUgKG9yIG5vKSByb3dzIHJldHVybmVkJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBudWxsXG4gICAgICAgICAgICBjb3VudCA9IG51bGxcbiAgICAgICAgICAgIHN0YXR1cyA9IDQwNlxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdOb3QgQWNjZXB0YWJsZSdcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBkYXRhID0gZGF0YVswXVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcy50ZXh0KClcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGVycm9yID0gSlNPTi5wYXJzZShib2R5KVxuXG4gICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9pc3N1ZXMvMjk1XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXJyb3IpICYmIHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgZGF0YSA9IFtdXG4gICAgICAgICAgICBlcnJvciA9IG51bGxcbiAgICAgICAgICAgIHN0YXR1cyA9IDIwMFxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdPSydcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzI5NVxuICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQgJiYgYm9keSA9PT0gJycpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9IDIwNFxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdObyBDb250ZW50J1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYm9keSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IgJiYgdGhpcy5pc01heWJlU2luZ2xlICYmIGVycm9yPy5kZXRhaWxzPy5pbmNsdWRlcygnMCByb3dzJykpIHtcbiAgICAgICAgICBlcnJvciA9IG51bGxcbiAgICAgICAgICBzdGF0dXMgPSAyMDBcbiAgICAgICAgICBzdGF0dXNUZXh0ID0gJ09LJ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yICYmIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBvc3RncmVzdEVycm9yKGVycm9yKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvc3RncmVzdFJlc3BvbnNlID0ge1xuICAgICAgICBlcnJvcixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY291bnQsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dCxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvc3RncmVzdFJlc3BvbnNlXG4gICAgfSlcbiAgICBpZiAoIXRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICByZXMgPSByZXMuY2F0Y2goKGZldGNoRXJyb3IpID0+ICh7XG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgbWVzc2FnZTogYCR7ZmV0Y2hFcnJvcj8ubmFtZSA/PyAnRmV0Y2hFcnJvcid9OiAke2ZldGNoRXJyb3I/Lm1lc3NhZ2V9YCxcbiAgICAgICAgICBkZXRhaWxzOiBgJHtmZXRjaEVycm9yPy5zdGFjayA/PyAnJ31gLFxuICAgICAgICAgIGhpbnQ6ICcnLFxuICAgICAgICAgIGNvZGU6IGAke2ZldGNoRXJyb3I/LmNvZGUgPz8gJyd9YCxcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgY291bnQ6IG51bGwsXG4gICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgc3RhdHVzVGV4dDogJycsXG4gICAgICB9KSlcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpXG4gIH1cbn1cbiIsICJpbXBvcnQgUG9zdGdyZXN0QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEJ1aWxkZXInXG5pbXBvcnQgeyBHZXRSZXN1bHQgfSBmcm9tICcuL3NlbGVjdC1xdWVyeS1wYXJzZXIvcmVzdWx0J1xuaW1wb3J0IHsgR2VuZXJpY1NjaGVtYSB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXI8XG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEsXG4gIFJvdyBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBSZXN1bHQsXG4gIFJlbGF0aW9uTmFtZSA9IHVua25vd24sXG4gIFJlbGF0aW9uc2hpcHMgPSB1bmtub3duXG4+IGV4dGVuZHMgUG9zdGdyZXN0QnVpbGRlcjxSZXN1bHQ+IHtcbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBTRUxFQ1Qgb24gdGhlIHF1ZXJ5IHJlc3VsdC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYC5pbnNlcnQoKWAsIGAudXBkYXRlKClgLCBgLnVwc2VydCgpYCwgYW5kIGAuZGVsZXRlKClgIGRvIG5vdFxuICAgKiByZXR1cm4gbW9kaWZpZWQgcm93cy4gQnkgY2FsbGluZyB0aGlzIG1ldGhvZCwgbW9kaWZpZWQgcm93cyBhcmUgcmV0dXJuZWQgaW5cbiAgICogYGRhdGFgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1ucyAtIFRoZSBjb2x1bW5zIHRvIHJldHJpZXZlLCBzZXBhcmF0ZWQgYnkgY29tbWFzXG4gICAqL1xuICBzZWxlY3Q8XG4gICAgUXVlcnkgZXh0ZW5kcyBzdHJpbmcgPSAnKicsXG4gICAgTmV3UmVzdWx0T25lID0gR2V0UmVzdWx0PFNjaGVtYSwgUm93LCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHMsIFF1ZXJ5PlxuICA+KFxuICAgIGNvbHVtbnM/OiBRdWVyeVxuICApOiBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyPFNjaGVtYSwgUm93LCBOZXdSZXN1bHRPbmVbXSwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2VzIGV4Y2VwdCB3aGVuIHF1b3RlZFxuICAgIGxldCBxdW90ZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNsZWFuZWRDb2x1bW5zID0gKGNvbHVtbnMgPz8gJyonKVxuICAgICAgLnNwbGl0KCcnKVxuICAgICAgLm1hcCgoYykgPT4ge1xuICAgICAgICBpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSB7XG4gICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICBxdW90ZWQgPSAhcXVvdGVkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH0pXG4gICAgICAuam9pbignJylcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZWxlY3QnLCBjbGVhbmVkQ29sdW1ucylcbiAgICBpZiAodGhpcy5oZWFkZXJzWydQcmVmZXInXSkge1xuICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSArPSAnLCdcbiAgICB9XG4gICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSArPSAncmV0dXJuPXJlcHJlc2VudGF0aW9uJ1xuICAgIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcjxcbiAgICAgIFNjaGVtYSxcbiAgICAgIFJvdyxcbiAgICAgIE5ld1Jlc3VsdE9uZVtdLFxuICAgICAgUmVsYXRpb25OYW1lLFxuICAgICAgUmVsYXRpb25zaGlwc1xuICAgID5cbiAgfVxuXG4gIG9yZGVyPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBvcHRpb25zPzogeyBhc2NlbmRpbmc/OiBib29sZWFuOyBudWxsc0ZpcnN0PzogYm9vbGVhbjsgcmVmZXJlbmNlZFRhYmxlPzogdW5kZWZpbmVkIH1cbiAgKTogdGhpc1xuICBvcmRlcihcbiAgICBjb2x1bW46IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyBhc2NlbmRpbmc/OiBib29sZWFuOyBudWxsc0ZpcnN0PzogYm9vbGVhbjsgcmVmZXJlbmNlZFRhYmxlPzogc3RyaW5nIH1cbiAgKTogdGhpc1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWAgaW5zdGVhZCBvZiBgb3B0aW9ucy5mb3JlaWduVGFibGVgXG4gICAqL1xuICBvcmRlcjxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgb3B0aW9ucz86IHsgYXNjZW5kaW5nPzogYm9vbGVhbjsgbnVsbHNGaXJzdD86IGJvb2xlYW47IGZvcmVpZ25UYWJsZT86IHVuZGVmaW5lZCB9XG4gICk6IHRoaXNcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgIGluc3RlYWQgb2YgYG9wdGlvbnMuZm9yZWlnblRhYmxlYFxuICAgKi9cbiAgb3JkZXIoXG4gICAgY29sdW1uOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgYXNjZW5kaW5nPzogYm9vbGVhbjsgbnVsbHNGaXJzdD86IGJvb2xlYW47IGZvcmVpZ25UYWJsZT86IHN0cmluZyB9XG4gICk6IHRoaXNcbiAgLyoqXG4gICAqIE9yZGVyIHRoZSBxdWVyeSByZXN1bHQgYnkgYGNvbHVtbmAuXG4gICAqXG4gICAqIFlvdSBjYW4gY2FsbCB0aGlzIG1ldGhvZCBtdWx0aXBsZSB0aW1lcyB0byBvcmRlciBieSBtdWx0aXBsZSBjb2x1bW5zLlxuICAgKlxuICAgKiBZb3UgY2FuIG9yZGVyIHJlZmVyZW5jZWQgdGFibGVzLCBidXQgaXQgb25seSBhZmZlY3RzIHRoZSBvcmRlcmluZyBvZiB0aGVcbiAgICogcGFyZW50IHRhYmxlIGlmIHlvdSB1c2UgYCFpbm5lcmAgaW4gdGhlIHF1ZXJ5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBvcmRlciBieVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMuYXNjZW5kaW5nIC0gSWYgYHRydWVgLCB0aGUgcmVzdWx0IHdpbGwgYmUgaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAqIEBwYXJhbSBvcHRpb25zLm51bGxzRmlyc3QgLSBJZiBgdHJ1ZWAsIGBudWxsYHMgYXBwZWFyIGZpcnN0LiBJZiBgZmFsc2VgLFxuICAgKiBgbnVsbGBzIGFwcGVhciBsYXN0LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBvcmRlciBhIHJlZmVyZW5jZWQgdGFibGUgYnlcbiAgICogaXRzIGNvbHVtbnNcbiAgICogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWBcbiAgICogaW5zdGVhZFxuICAgKi9cbiAgb3JkZXIoXG4gICAgY29sdW1uOiBzdHJpbmcsXG4gICAge1xuICAgICAgYXNjZW5kaW5nID0gdHJ1ZSxcbiAgICAgIG51bGxzRmlyc3QsXG4gICAgICBmb3JlaWduVGFibGUsXG4gICAgICByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUsXG4gICAgfToge1xuICAgICAgYXNjZW5kaW5nPzogYm9vbGVhblxuICAgICAgbnVsbHNGaXJzdD86IGJvb2xlYW5cbiAgICAgIGZvcmVpZ25UYWJsZT86IHN0cmluZ1xuICAgICAgcmVmZXJlbmNlZFRhYmxlPzogc3RyaW5nXG4gICAgfSA9IHt9XG4gICk6IHRoaXMge1xuICAgIGNvbnN0IGtleSA9IHJlZmVyZW5jZWRUYWJsZSA/IGAke3JlZmVyZW5jZWRUYWJsZX0ub3JkZXJgIDogJ29yZGVyJ1xuICAgIGNvbnN0IGV4aXN0aW5nT3JkZXIgPSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuZ2V0KGtleSlcblxuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoXG4gICAgICBrZXksXG4gICAgICBgJHtleGlzdGluZ09yZGVyID8gYCR7ZXhpc3RpbmdPcmRlcn0sYCA6ICcnfSR7Y29sdW1ufS4ke2FzY2VuZGluZyA/ICdhc2MnIDogJ2Rlc2MnfSR7XG4gICAgICAgIG51bGxzRmlyc3QgPT09IHVuZGVmaW5lZCA/ICcnIDogbnVsbHNGaXJzdCA/ICcubnVsbHNmaXJzdCcgOiAnLm51bGxzbGFzdCdcbiAgICAgIH1gXG4gICAgKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogTGltaXQgdGhlIHF1ZXJ5IHJlc3VsdCBieSBgY291bnRgLlxuICAgKlxuICAgKiBAcGFyYW0gY291bnQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0byByZXR1cm5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGxpbWl0IHJvd3Mgb2YgcmVmZXJlbmNlZFxuICAgKiB0YWJsZXMgaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG4gICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgXG4gICAqIGluc3RlYWRcbiAgICovXG4gIGxpbWl0KFxuICAgIGNvdW50OiBudW1iZXIsXG4gICAge1xuICAgICAgZm9yZWlnblRhYmxlLFxuICAgICAgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlLFxuICAgIH06IHsgZm9yZWlnblRhYmxlPzogc3RyaW5nOyByZWZlcmVuY2VkVGFibGU/OiBzdHJpbmcgfSA9IHt9XG4gICk6IHRoaXMge1xuICAgIGNvbnN0IGtleSA9IHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09ICd1bmRlZmluZWQnID8gJ2xpbWl0JyA6IGAke3JlZmVyZW5jZWRUYWJsZX0ubGltaXRgXG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIGAke2NvdW50fWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBMaW1pdCB0aGUgcXVlcnkgcmVzdWx0IGJ5IHN0YXJ0aW5nIGF0IGFuIG9mZnNldCBgZnJvbWAgYW5kIGVuZGluZyBhdCB0aGUgb2Zmc2V0IGB0b2AuXG4gICAqIE9ubHkgcmVjb3JkcyB3aXRoaW4gdGhpcyByYW5nZSBhcmUgcmV0dXJuZWQuXG4gICAqIFRoaXMgcmVzcGVjdHMgdGhlIHF1ZXJ5IG9yZGVyIGFuZCBpZiB0aGVyZSBpcyBubyBvcmRlciBjbGF1c2UgdGhlIHJhbmdlIGNvdWxkIGJlaGF2ZSB1bmV4cGVjdGVkbHkuXG4gICAqIFRoZSBgZnJvbWAgYW5kIGB0b2AgdmFsdWVzIGFyZSAwLWJhc2VkIGFuZCBpbmNsdXNpdmU6IGByYW5nZSgxLCAzKWAgd2lsbCBpbmNsdWRlIHRoZSBzZWNvbmQsIHRoaXJkXG4gICAqIGFuZCBmb3VydGggcm93cyBvZiB0aGUgcXVlcnkuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHN0YXJ0aW5nIGluZGV4IGZyb20gd2hpY2ggdG8gbGltaXQgdGhlIHJlc3VsdFxuICAgKiBAcGFyYW0gdG8gLSBUaGUgbGFzdCBpbmRleCB0byB3aGljaCB0byBsaW1pdCB0aGUgcmVzdWx0XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBsaW1pdCByb3dzIG9mIHJlZmVyZW5jZWRcbiAgICogdGFibGVzIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuICAgKiBpbnN0ZWFkXG4gICAqL1xuICByYW5nZShcbiAgICBmcm9tOiBudW1iZXIsXG4gICAgdG86IG51bWJlcixcbiAgICB7XG4gICAgICBmb3JlaWduVGFibGUsXG4gICAgICByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUsXG4gICAgfTogeyBmb3JlaWduVGFibGU/OiBzdHJpbmc7IHJlZmVyZW5jZWRUYWJsZT86IHN0cmluZyB9ID0ge31cbiAgKTogdGhpcyB7XG4gICAgY29uc3Qga2V5T2Zmc2V0ID1cbiAgICAgIHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09ICd1bmRlZmluZWQnID8gJ29mZnNldCcgOiBgJHtyZWZlcmVuY2VkVGFibGV9Lm9mZnNldGBcbiAgICBjb25zdCBrZXlMaW1pdCA9IHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09ICd1bmRlZmluZWQnID8gJ2xpbWl0JyA6IGAke3JlZmVyZW5jZWRUYWJsZX0ubGltaXRgXG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXlPZmZzZXQsIGAke2Zyb219YClcbiAgICAvLyBSYW5nZSBpcyBpbmNsdXNpdmUsIHNvIGFkZCAxXG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXlMaW1pdCwgYCR7dG8gLSBmcm9tICsgMX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBBYm9ydFNpZ25hbCBmb3IgdGhlIGZldGNoIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBzaWduYWwgLSBUaGUgQWJvcnRTaWduYWwgdG8gdXNlIGZvciB0aGUgZmV0Y2ggcmVxdWVzdFxuICAgKi9cbiAgYWJvcnRTaWduYWwoc2lnbmFsOiBBYm9ydFNpZ25hbCk6IHRoaXMge1xuICAgIHRoaXMuc2lnbmFsID0gc2lnbmFsXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYGRhdGFgIGFzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gICAqXG4gICAqIFF1ZXJ5IHJlc3VsdCBtdXN0IGJlIG9uZSByb3cgKGUuZy4gdXNpbmcgYC5saW1pdCgxKWApLCBvdGhlcndpc2UgdGhpc1xuICAgKiByZXR1cm5zIGFuIGVycm9yLlxuICAgKi9cbiAgc2luZ2xlPFxuICAgIFJlc3VsdE9uZSA9IFJlc3VsdCBleHRlbmRzIChpbmZlciBSZXN1bHRPbmUpW10gPyBSZXN1bHRPbmUgOiBuZXZlclxuICA+KCk6IFBvc3RncmVzdEJ1aWxkZXI8UmVzdWx0T25lPiB7XG4gICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24nXG4gICAgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdE9uZT5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYGRhdGFgIGFzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gICAqXG4gICAqIFF1ZXJ5IHJlc3VsdCBtdXN0IGJlIHplcm8gb3Igb25lIHJvdyAoZS5nLiB1c2luZyBgLmxpbWl0KDEpYCksIG90aGVyd2lzZVxuICAgKiB0aGlzIHJldHVybnMgYW4gZXJyb3IuXG4gICAqL1xuICBtYXliZVNpbmdsZTxcbiAgICBSZXN1bHRPbmUgPSBSZXN1bHQgZXh0ZW5kcyAoaW5mZXIgUmVzdWx0T25lKVtdID8gUmVzdWx0T25lIDogbmV2ZXJcbiAgPigpOiBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdE9uZSB8IG51bGw+IHtcbiAgICAvLyBUZW1wb3JhcnkgcGFydGlhbCBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzM2MVxuICAgIC8vIElzc3VlIHBlcnNpc3RzIGUuZy4gZm9yIGAuaW5zZXJ0KFsuLi5dKS5zZWxlY3QoKS5tYXliZVNpbmdsZSgpYFxuICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vanNvbidcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24nXG4gICAgfVxuICAgIHRoaXMuaXNNYXliZVNpbmdsZSA9IHRydWVcbiAgICByZXR1cm4gdGhpcyBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8UmVzdWx0T25lIHwgbnVsbD5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYGRhdGFgIGFzIGEgc3RyaW5nIGluIENTViBmb3JtYXQuXG4gICAqL1xuICBjc3YoKTogUG9zdGdyZXN0QnVpbGRlcjxzdHJpbmc+IHtcbiAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID0gJ3RleHQvY3N2J1xuICAgIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxzdHJpbmc+XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGBkYXRhYCBhcyBhbiBvYmplY3QgaW4gW0dlb0pTT05dKGh0dHBzOi8vZ2VvanNvbi5vcmcpIGZvcm1hdC5cbiAgICovXG4gIGdlb2pzb24oKTogUG9zdGdyZXN0QnVpbGRlcjxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4ge1xuICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vZ2VvK2pzb24nXG4gICAgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPFJlY29yZDxzdHJpbmcsIHVua25vd24+PlxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBgZGF0YWAgYXMgdGhlIEVYUExBSU4gcGxhbiBmb3IgdGhlIHF1ZXJ5LlxuICAgKlxuICAgKiBZb3UgbmVlZCB0byBlbmFibGUgdGhlXG4gICAqIFtkYl9wbGFuX2VuYWJsZWRdKGh0dHBzOi8vc3VwYWJhc2UuY29tL2RvY3MvZ3VpZGVzL2RhdGFiYXNlL2RlYnVnZ2luZy1wZXJmb3JtYW5jZSNlbmFibGluZy1leHBsYWluKVxuICAgKiBzZXR0aW5nIGJlZm9yZSB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmFuYWx5emUgLSBJZiBgdHJ1ZWAsIHRoZSBxdWVyeSB3aWxsIGJlIGV4ZWN1dGVkIGFuZCB0aGVcbiAgICogYWN0dWFsIHJ1biB0aW1lIHdpbGwgYmUgcmV0dXJuZWRcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMudmVyYm9zZSAtIElmIGB0cnVlYCwgdGhlIHF1ZXJ5IGlkZW50aWZpZXIgd2lsbCBiZSByZXR1cm5lZFxuICAgKiBhbmQgYGRhdGFgIHdpbGwgaW5jbHVkZSB0aGUgb3V0cHV0IGNvbHVtbnMgb2YgdGhlIHF1ZXJ5XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLnNldHRpbmdzIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIGNvbmZpZ3VyYXRpb25cbiAgICogcGFyYW1ldGVycyB0aGF0IGFmZmVjdCBxdWVyeSBwbGFubmluZ1xuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5idWZmZXJzIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIGJ1ZmZlciB1c2FnZVxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy53YWwgLSBJZiBgdHJ1ZWAsIGluY2x1ZGUgaW5mb3JtYXRpb24gb24gV0FMIHJlY29yZCBnZW5lcmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmZvcm1hdCAtIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCwgY2FuIGJlIGBcInRleHRcImAgKGRlZmF1bHQpXG4gICAqIG9yIGBcImpzb25cImBcbiAgICovXG4gIGV4cGxhaW4oe1xuICAgIGFuYWx5emUgPSBmYWxzZSxcbiAgICB2ZXJib3NlID0gZmFsc2UsXG4gICAgc2V0dGluZ3MgPSBmYWxzZSxcbiAgICBidWZmZXJzID0gZmFsc2UsXG4gICAgd2FsID0gZmFsc2UsXG4gICAgZm9ybWF0ID0gJ3RleHQnLFxuICB9OiB7XG4gICAgYW5hbHl6ZT86IGJvb2xlYW5cbiAgICB2ZXJib3NlPzogYm9vbGVhblxuICAgIHNldHRpbmdzPzogYm9vbGVhblxuICAgIGJ1ZmZlcnM/OiBib29sZWFuXG4gICAgd2FsPzogYm9vbGVhblxuICAgIGZvcm1hdD86ICdqc29uJyB8ICd0ZXh0J1xuICB9ID0ge30pOiBQb3N0Z3Jlc3RCdWlsZGVyPFJlY29yZDxzdHJpbmcsIHVua25vd24+W10+IHwgUG9zdGdyZXN0QnVpbGRlcjxzdHJpbmc+IHtcbiAgICBjb25zdCBvcHRpb25zID0gW1xuICAgICAgYW5hbHl6ZSA/ICdhbmFseXplJyA6IG51bGwsXG4gICAgICB2ZXJib3NlID8gJ3ZlcmJvc2UnIDogbnVsbCxcbiAgICAgIHNldHRpbmdzID8gJ3NldHRpbmdzJyA6IG51bGwsXG4gICAgICBidWZmZXJzID8gJ2J1ZmZlcnMnIDogbnVsbCxcbiAgICAgIHdhbCA/ICd3YWwnIDogbnVsbCxcbiAgICBdXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAuam9pbignfCcpXG4gICAgLy8gQW4gQWNjZXB0IGhlYWRlciBjYW4gY2FycnkgbXVsdGlwbGUgbWVkaWEgdHlwZXMgYnV0IHBvc3RncmVzdC1qcyBhbHdheXMgc2VuZHMgb25lXG4gICAgY29uc3QgZm9yTWVkaWF0eXBlID0gdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA/PyAnYXBwbGljYXRpb24vanNvbidcbiAgICB0aGlzLmhlYWRlcnNbXG4gICAgICAnQWNjZXB0J1xuICAgIF0gPSBgYXBwbGljYXRpb24vdm5kLnBncnN0LnBsYW4rJHtmb3JtYXR9OyBmb3I9XCIke2Zvck1lZGlhdHlwZX1cIjsgb3B0aW9ucz0ke29wdGlvbnN9O2BcbiAgICBpZiAoZm9ybWF0ID09PSAnanNvbicpIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdPlxuICAgIGVsc2UgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPHN0cmluZz5cbiAgfVxuXG4gIC8qKlxuICAgKiBSb2xsYmFjayB0aGUgcXVlcnkuXG4gICAqXG4gICAqIGBkYXRhYCB3aWxsIHN0aWxsIGJlIHJldHVybmVkLCBidXQgdGhlIHF1ZXJ5IGlzIG5vdCBjb21taXR0ZWQuXG4gICAqL1xuICByb2xsYmFjaygpOiB0aGlzIHtcbiAgICBpZiAoKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPz8gJycpLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ1ByZWZlciddICs9ICcsdHg9cm9sbGJhY2snXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSAndHg9cm9sbGJhY2snXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGBkYXRhYC5cbiAgICpcbiAgICogQHR5cGVQYXJhbSBOZXdSZXN1bHQgLSBUaGUgbmV3IHJlc3VsdCB0eXBlIHRvIG92ZXJyaWRlIHdpdGhcbiAgICovXG4gIHJldHVybnM8TmV3UmVzdWx0PigpOiBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyPFxuICAgIFNjaGVtYSxcbiAgICBSb3csXG4gICAgTmV3UmVzdWx0LFxuICAgIFJlbGF0aW9uTmFtZSxcbiAgICBSZWxhdGlvbnNoaXBzXG4gID4ge1xuICAgIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcjxcbiAgICAgIFNjaGVtYSxcbiAgICAgIFJvdyxcbiAgICAgIE5ld1Jlc3VsdCxcbiAgICAgIFJlbGF0aW9uTmFtZSxcbiAgICAgIFJlbGF0aW9uc2hpcHNcbiAgICA+XG4gIH1cbn1cbiIsICJpbXBvcnQgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXInXG5pbXBvcnQgeyBHZW5lcmljU2NoZW1hIH0gZnJvbSAnLi90eXBlcydcblxudHlwZSBGaWx0ZXJPcGVyYXRvciA9XG4gIHwgJ2VxJ1xuICB8ICduZXEnXG4gIHwgJ2d0J1xuICB8ICdndGUnXG4gIHwgJ2x0J1xuICB8ICdsdGUnXG4gIHwgJ2xpa2UnXG4gIHwgJ2lsaWtlJ1xuICB8ICdpcydcbiAgfCAnaW4nXG4gIHwgJ2NzJ1xuICB8ICdjZCdcbiAgfCAnc2wnXG4gIHwgJ3NyJ1xuICB8ICdueGwnXG4gIHwgJ254cidcbiAgfCAnYWRqJ1xuICB8ICdvdidcbiAgfCAnZnRzJ1xuICB8ICdwbGZ0cydcbiAgfCAncGhmdHMnXG4gIHwgJ3dmdHMnXG5cbi8vIE1hdGNoIHJlbGF0aW9uc2hpcCBmaWx0ZXJzIHdpdGggYHRhYmxlLmNvbHVtbmAgc3ludGF4IGFuZCByZXNvbHZlIHVuZGVybHlpbmdcbi8vIGNvbHVtbiB2YWx1ZS4gSWYgbm90IG1hdGNoZWQsIGZhbGxiYWNrIHRvIGdlbmVyaWMgdHlwZS5cbi8vIFRPRE86IFZhbGlkYXRlIHRoZSByZWxhdGlvbnNoaXAgaXRzZWxmIGFsYSBzZWxlY3QtcXVlcnktcGFyc2VyLiBDdXJyZW50bHkgd2Vcbi8vIGFzc3VtZSB0aGF0IGFsbCB0YWJsZXMgaGF2ZSB2YWxpZCByZWxhdGlvbnNoaXBzIHRvIGVhY2ggb3RoZXIsIGRlc3BpdGVcbi8vIG5vbmV4aXN0ZW50IGZvcmVpZ24ga2V5cy5cbnR5cGUgUmVzb2x2ZUZpbHRlclZhbHVlPFxuICBTY2hlbWEgZXh0ZW5kcyBHZW5lcmljU2NoZW1hLFxuICBSb3cgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgQ29sdW1uTmFtZSBleHRlbmRzIHN0cmluZ1xuPiA9IENvbHVtbk5hbWUgZXh0ZW5kcyBgJHtpbmZlciBSZWxhdGlvbnNoaXBUYWJsZX0uJHtpbmZlciBSZW1haW5kZXJ9YFxuICA/IFJlbWFpbmRlciBleHRlbmRzIGAke2luZmVyIF99LiR7aW5mZXIgX31gXG4gICAgPyBSZXNvbHZlRmlsdGVyVmFsdWU8U2NoZW1hLCBSb3csIFJlbWFpbmRlcj5cbiAgICA6IFJlc29sdmVGaWx0ZXJSZWxhdGlvbnNoaXBWYWx1ZTxTY2hlbWEsIFJlbGF0aW9uc2hpcFRhYmxlLCBSZW1haW5kZXI+XG4gIDogQ29sdW1uTmFtZSBleHRlbmRzIGtleW9mIFJvd1xuICA/IFJvd1tDb2x1bW5OYW1lXVxuICA6IG5ldmVyXG5cbnR5cGUgUmVzb2x2ZUZpbHRlclJlbGF0aW9uc2hpcFZhbHVlPFxuICBTY2hlbWEgZXh0ZW5kcyBHZW5lcmljU2NoZW1hLFxuICBSZWxhdGlvbnNoaXBUYWJsZSBleHRlbmRzIHN0cmluZyxcbiAgUmVsYXRpb25zaGlwQ29sdW1uIGV4dGVuZHMgc3RyaW5nXG4+ID0gU2NoZW1hWydUYWJsZXMnXSAmIFNjaGVtYVsnVmlld3MnXSBleHRlbmRzIGluZmVyIFRhYmxlc0FuZFZpZXdzXG4gID8gUmVsYXRpb25zaGlwVGFibGUgZXh0ZW5kcyBrZXlvZiBUYWJsZXNBbmRWaWV3c1xuICAgID8gJ1JvdycgZXh0ZW5kcyBrZXlvZiBUYWJsZXNBbmRWaWV3c1tSZWxhdGlvbnNoaXBUYWJsZV1cbiAgICAgID8gUmVsYXRpb25zaGlwQ29sdW1uIGV4dGVuZHMga2V5b2YgVGFibGVzQW5kVmlld3NbUmVsYXRpb25zaGlwVGFibGVdWydSb3cnXVxuICAgICAgICA/IFRhYmxlc0FuZFZpZXdzW1JlbGF0aW9uc2hpcFRhYmxlXVsnUm93J11bUmVsYXRpb25zaGlwQ29sdW1uXVxuICAgICAgICA6IHVua25vd25cbiAgICAgIDogdW5rbm93blxuICAgIDogdW5rbm93blxuICA6IG5ldmVyXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8XG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEsXG4gIFJvdyBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBSZXN1bHQsXG4gIFJlbGF0aW9uTmFtZSA9IHVua25vd24sXG4gIFJlbGF0aW9uc2hpcHMgPSB1bmtub3duXG4+IGV4dGVuZHMgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcjxTY2hlbWEsIFJvdywgUmVzdWx0LCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+IHtcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBUbyBjaGVjayBpZiB0aGUgdmFsdWUgb2YgYGNvbHVtbmAgaXMgTlVMTCwgeW91IHNob3VsZCB1c2UgYC5pcygpYCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBlcTxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nPihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgdmFsdWU6IFJlc29sdmVGaWx0ZXJWYWx1ZTxTY2hlbWEsIFJvdywgQ29sdW1uTmFtZT4gZXh0ZW5kcyBuZXZlclxuICAgICAgPyBOb25OdWxsYWJsZTx1bmtub3duPlxuICAgICAgOiBOb25OdWxsYWJsZTxSZXNvbHZlRmlsdGVyVmFsdWU8U2NoZW1hLCBSb3csIENvbHVtbk5hbWU+PlxuICApOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGVxLiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBub3QgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgbmVxPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmc+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZTogUmVzb2x2ZUZpbHRlclZhbHVlPFNjaGVtYSwgUm93LCBDb2x1bW5OYW1lPiBleHRlbmRzIG5ldmVyXG4gICAgICA/IHVua25vd25cbiAgICAgIDogUmVzb2x2ZUZpbHRlclZhbHVlPFNjaGVtYSwgUm93LCBDb2x1bW5OYW1lPlxuICApOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5lcS4ke3ZhbHVlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGd0PENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgdmFsdWU6IFJvd1tDb2x1bW5OYW1lXSk6IHRoaXNcbiAgZ3QoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBndChjb2x1bW46IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGd0LiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ3RlPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgdmFsdWU6IFJvd1tDb2x1bW5OYW1lXSk6IHRoaXNcbiAgZ3RlKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgZ3RlKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZ3RlLiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbHQ8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCB2YWx1ZTogUm93W0NvbHVtbk5hbWVdKTogdGhpc1xuICBsdChjb2x1bW46IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbGVzcyB0aGFuIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGx0KGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbHQuJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsdGU8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCB2YWx1ZTogUm93W0NvbHVtbk5hbWVdKTogdGhpc1xuICBsdGUoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBsdGUoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsdGUuJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsaWtlPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgcGF0dGVybjogc3RyaW5nKTogdGhpc1xuICBsaWtlKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuOiBzdHJpbmcpOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBgcGF0dGVybmAgY2FzZS1zZW5zaXRpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuICAgKi9cbiAgbGlrZShjb2x1bW46IHN0cmluZywgcGF0dGVybjogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsaWtlLiR7cGF0dGVybn1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsaWtlQWxsT2Y8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXVxuICApOiB0aGlzXG4gIGxpa2VBbGxPZihjb2x1bW46IHN0cmluZywgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYWxsIG9mIGBwYXR0ZXJuc2AgY2FzZS1zZW5zaXRpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG4gICAqL1xuICBsaWtlQWxsT2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZShhbGwpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbGlrZUFueU9mPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW11cbiAgKTogdGhpc1xuICBsaWtlQW55T2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFueSBvZiBgcGF0dGVybnNgIGNhc2Utc2Vuc2l0aXZlbHkuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuICAgKi9cbiAgbGlrZUFueU9mKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW10pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGxpa2UoYW55KS57JHtwYXR0ZXJucy5qb2luKCcsJyl9fWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlsaWtlPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgcGF0dGVybjogc3RyaW5nKTogdGhpc1xuICBpbGlrZShjb2x1bW46IHN0cmluZywgcGF0dGVybjogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYHBhdHRlcm5gIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuICAgKi9cbiAgaWxpa2UoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm46IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UuJHtwYXR0ZXJufWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlsaWtlQWxsT2Y8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXVxuICApOiB0aGlzXG4gIGlsaWtlQWxsT2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFsbCBvZiBgcGF0dGVybnNgIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG4gICAqL1xuICBpbGlrZUFsbE9mKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW10pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlsaWtlKGFsbCkueyR7cGF0dGVybnMuam9pbignLCcpfX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBpbGlrZUFueU9mPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW11cbiAgKTogdGhpc1xuICBpbGlrZUFueU9mKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW10pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbnkgb2YgYHBhdHRlcm5zYCBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuICAgKi9cbiAgaWxpa2VBbnlPZihjb2x1bW46IHN0cmluZywgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbGlrZShhbnkpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaXM8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHZhbHVlOiBSb3dbQ29sdW1uTmFtZV0gJiAoYm9vbGVhbiB8IG51bGwpXG4gICk6IHRoaXNcbiAgaXMoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBib29sZWFuIHwgbnVsbCk6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBJUyBgdmFsdWVgLlxuICAgKlxuICAgKiBGb3Igbm9uLWJvb2xlYW4gY29sdW1ucywgdGhpcyBpcyBvbmx5IHJlbGV2YW50IGZvciBjaGVja2luZyBpZiB0aGUgdmFsdWUgb2ZcbiAgICogYGNvbHVtbmAgaXMgTlVMTCBieSBzZXR0aW5nIGB2YWx1ZWAgdG8gYG51bGxgLlxuICAgKlxuICAgKiBGb3IgYm9vbGVhbiBjb2x1bW5zLCB5b3UgY2FuIGFsc28gc2V0IGB2YWx1ZWAgdG8gYHRydWVgIG9yIGBmYWxzZWAgYW5kIGl0XG4gICAqIHdpbGwgYmVoYXZlIHRoZSBzYW1lIHdheSBhcyBgLmVxKClgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBpcyhjb2x1bW46IHN0cmluZywgdmFsdWU6IGJvb2xlYW4gfCBudWxsKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpcy4ke3ZhbHVlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgaW5jbHVkZWQgaW4gdGhlIGB2YWx1ZXNgIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgYXJyYXkgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGluPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmc+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZXM6IFJlc29sdmVGaWx0ZXJWYWx1ZTxTY2hlbWEsIFJvdywgQ29sdW1uTmFtZT4gZXh0ZW5kcyBuZXZlclxuICAgICAgPyB1bmtub3duW11cbiAgICAgIDogUmVhZG9ubHlBcnJheTxSZXNvbHZlRmlsdGVyVmFsdWU8U2NoZW1hLCBSb3csIENvbHVtbk5hbWU+PlxuICApOiB0aGlzIHtcbiAgICBjb25zdCBjbGVhbmVkVmFsdWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KHZhbHVlcykpXG4gICAgICAubWFwKChzKSA9PiB7XG4gICAgICAgIC8vIGhhbmRsZSBwb3N0Z3Jlc3QgcmVzZXJ2ZWQgY2hhcmFjdGVyc1xuICAgICAgICAvLyBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vdjcuMC4wL2FwaS5odG1sI3Jlc2VydmVkLWNoYXJhY3RlcnNcbiAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJyAmJiBuZXcgUmVnRXhwKCdbLCgpXScpLnRlc3QocykpIHJldHVybiBgXCIke3N9XCJgXG4gICAgICAgIGVsc2UgcmV0dXJuIGAke3N9YFxuICAgICAgfSlcbiAgICAgIC5qb2luKCcsJylcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGluLigke2NsZWFuZWRWYWx1ZXN9KWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGNvbnRhaW5zPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZTogc3RyaW5nIHwgUmVhZG9ubHlBcnJheTxSb3dbQ29sdW1uTmFtZV0+IHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgKTogdGhpc1xuICBjb250YWlucyhjb2x1bW46IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHJlYWRvbmx5IHVua25vd25bXSB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IganNvbmIsIGFycmF5LCBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAqIGBjb2x1bW5gIGNvbnRhaW5zIGV2ZXJ5IGVsZW1lbnQgYXBwZWFyaW5nIGluIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBjb250YWlucyhjb2x1bW46IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHJlYWRvbmx5IHVua25vd25bXSB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdGhpcyB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIHJhbmdlIHR5cGVzIGNhbiBiZSBpbmNsdXNpdmUgJ1snLCAnXScgb3IgZXhjbHVzaXZlICcoJywgJyknIHNvIGp1c3RcbiAgICAgIC8vIGtlZXAgaXQgc2ltcGxlIGFuZCBhY2NlcHQgYSBzdHJpbmdcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MuJHt2YWx1ZX1gKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIC8vIGFycmF5XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNzLnske3ZhbHVlLmpvaW4oJywnKX19YClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganNvblxuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjcy4ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgY29udGFpbmVkQnk8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBSZWFkb25seUFycmF5PFJvd1tDb2x1bW5OYW1lXT4gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICApOiB0aGlzXG4gIGNvbnRhaW5lZEJ5KGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgcmVhZG9ubHkgdW5rbm93bltdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB0aGlzXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGZvciBqc29uYiwgYXJyYXksIGFuZCByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcbiAgICogZXZlcnkgZWxlbWVudCBhcHBlYXJpbmcgaW4gYGNvbHVtbmAgaXMgY29udGFpbmVkIGJ5IGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBjb250YWluZWRCeShjb2x1bW46IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHJlYWRvbmx5IHVua25vd25bXSB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdGhpcyB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIHJhbmdlXG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLiR7dmFsdWV9YClcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAvLyBhcnJheVxuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjZC57JHt2YWx1ZS5qb2luKCcsJyl9fWApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGpzb25cbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY2QuJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJhbmdlR3Q8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICByYW5nZUd0KGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICogYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIGFueSBlbGVtZW50IGluIGByYW5nZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIHJhbmdlR3QoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYHNyLiR7cmFuZ2V9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmFuZ2VHdGU8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICByYW5nZUd0ZShjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXNcbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAqIGBjb2x1bW5gIGlzIGVpdGhlciBjb250YWluZWQgaW4gYHJhbmdlYCBvciBncmVhdGVyIHRoYW4gYW55IGVsZW1lbnQgaW5cbiAgICogYHJhbmdlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgcmFuZ2VHdGUoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG54bC4ke3JhbmdlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJhbmdlTHQ8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICByYW5nZUx0KGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICogYGNvbHVtbmAgaXMgbGVzcyB0aGFuIGFueSBlbGVtZW50IGluIGByYW5nZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIHJhbmdlTHQoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYHNsLiR7cmFuZ2V9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmFuZ2VMdGU8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICByYW5nZUx0ZShjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXNcbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAqIGBjb2x1bW5gIGlzIGVpdGhlciBjb250YWluZWQgaW4gYHJhbmdlYCBvciBsZXNzIHRoYW4gYW55IGVsZW1lbnQgaW5cbiAgICogYHJhbmdlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgcmFuZ2VMdGUoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG54ci4ke3JhbmdlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJhbmdlQWRqYWNlbnQ8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICByYW5nZUFkamFjZW50KGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzXG4gICAqIG11dHVhbGx5IGV4Y2x1c2l2ZSB0byBgcmFuZ2VgIGFuZCB0aGVyZSBjYW4gYmUgbm8gZWxlbWVudCBiZXR3ZWVuIHRoZSB0d29cbiAgICogcmFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICByYW5nZUFkamFjZW50KGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBhZGouJHtyYW5nZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBvdmVybGFwczxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgdmFsdWU6IHN0cmluZyB8IFJlYWRvbmx5QXJyYXk8Um93W0NvbHVtbk5hbWVdPlxuICApOiB0aGlzXG4gIG92ZXJsYXBzKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgcmVhZG9ubHkgdW5rbm93bltdKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgYXJyYXkgYW5kIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuICAgKiBgY29sdW1uYCBhbmQgYHZhbHVlYCBoYXZlIGFuIGVsZW1lbnQgaW4gY29tbW9uLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGFycmF5IG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGFycmF5IG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBvdmVybGFwcyhjb2x1bW46IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHJlYWRvbmx5IHVua25vd25bXSk6IHRoaXMge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyByYW5nZVxuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBvdi4ke3ZhbHVlfWApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFycmF5XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG92Lnske3ZhbHVlLmpvaW4oJywnKX19YClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRleHRTZWFyY2g8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHF1ZXJ5OiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgY29uZmlnPzogc3RyaW5nOyB0eXBlPzogJ3BsYWluJyB8ICdwaHJhc2UnIHwgJ3dlYnNlYXJjaCcgfVxuICApOiB0aGlzXG4gIHRleHRTZWFyY2goXG4gICAgY29sdW1uOiBzdHJpbmcsXG4gICAgcXVlcnk6IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyBjb25maWc/OiBzdHJpbmc7IHR5cGU/OiAncGxhaW4nIHwgJ3BocmFzZScgfCAnd2Vic2VhcmNoJyB9XG4gICk6IHRoaXNcbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgZm9yIHRleHQgYW5kIHRzdmVjdG9yIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuICAgKiBgY29sdW1uYCBtYXRjaGVzIHRoZSBxdWVyeSBzdHJpbmcgaW4gYHF1ZXJ5YC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSB0ZXh0IG9yIHRzdmVjdG9yIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRleHQgdG8gbWF0Y2ggd2l0aFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMuY29uZmlnIC0gVGhlIHRleHQgc2VhcmNoIGNvbmZpZ3VyYXRpb24gdG8gdXNlXG4gICAqIEBwYXJhbSBvcHRpb25zLnR5cGUgLSBDaGFuZ2UgaG93IHRoZSBgcXVlcnlgIHRleHQgaXMgaW50ZXJwcmV0ZWRcbiAgICovXG4gIHRleHRTZWFyY2goXG4gICAgY29sdW1uOiBzdHJpbmcsXG4gICAgcXVlcnk6IHN0cmluZyxcbiAgICB7IGNvbmZpZywgdHlwZSB9OiB7IGNvbmZpZz86IHN0cmluZzsgdHlwZT86ICdwbGFpbicgfCAncGhyYXNlJyB8ICd3ZWJzZWFyY2gnIH0gPSB7fVxuICApOiB0aGlzIHtcbiAgICBsZXQgdHlwZVBhcnQgPSAnJ1xuICAgIGlmICh0eXBlID09PSAncGxhaW4nKSB7XG4gICAgICB0eXBlUGFydCA9ICdwbCdcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdwaHJhc2UnKSB7XG4gICAgICB0eXBlUGFydCA9ICdwaCdcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd3ZWJzZWFyY2gnKSB7XG4gICAgICB0eXBlUGFydCA9ICd3J1xuICAgIH1cbiAgICBjb25zdCBjb25maWdQYXJ0ID0gY29uZmlnID09PSB1bmRlZmluZWQgPyAnJyA6IGAoJHtjb25maWd9KWBcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYCR7dHlwZVBhcnR9ZnRzJHtjb25maWdQYXJ0fS4ke3F1ZXJ5fWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG1hdGNoPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KHF1ZXJ5OiBSZWNvcmQ8Q29sdW1uTmFtZSwgUm93W0NvbHVtbk5hbWVdPik6IHRoaXNcbiAgbWF0Y2gocXVlcnk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGVhY2ggY29sdW1uIGluIGBxdWVyeWAga2V5cyBpcyBlcXVhbCB0byBpdHNcbiAgICogYXNzb2NpYXRlZCB2YWx1ZS4gU2hvcnRoYW5kIGZvciBtdWx0aXBsZSBgLmVxKClgcy5cbiAgICpcbiAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIG9iamVjdCB0byBmaWx0ZXIgd2l0aCwgd2l0aCBjb2x1bW4gbmFtZXMgYXMga2V5cyBtYXBwZWRcbiAgICogdG8gdGhlaXIgZmlsdGVyIHZhbHVlc1xuICAgKi9cbiAgbWF0Y2gocXVlcnk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdGhpcyB7XG4gICAgT2JqZWN0LmVudHJpZXMocXVlcnkpLmZvckVhY2goKFtjb2x1bW4sIHZhbHVlXSkgPT4ge1xuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBlcS4ke3ZhbHVlfWApXG4gICAgfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbm90PENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBvcGVyYXRvcjogRmlsdGVyT3BlcmF0b3IsXG4gICAgdmFsdWU6IFJvd1tDb2x1bW5OYW1lXVxuICApOiB0aGlzXG4gIG5vdChjb2x1bW46IHN0cmluZywgb3BlcmF0b3I6IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hpY2ggZG9lc24ndCBzYXRpc2Z5IHRoZSBmaWx0ZXIuXG4gICAqXG4gICAqIFVubGlrZSBtb3N0IGZpbHRlcnMsIGBvcGVhcmF0b3JgIGFuZCBgdmFsdWVgIGFyZSB1c2VkIGFzLWlzIGFuZCBuZWVkIHRvXG4gICAqIGZvbGxvdyBbUG9zdGdSRVNUXG4gICAqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG4gICAqIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBwcm9wZXJseSBzYW5pdGl6ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gb3BlcmF0b3IgLSBUaGUgb3BlcmF0b3IgdG8gYmUgbmVnYXRlZCB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nXG4gICAqIFBvc3RnUkVTVCBzeW50YXhcbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgKi9cbiAgbm90KGNvbHVtbjogc3RyaW5nLCBvcGVyYXRvcjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbm90LiR7b3BlcmF0b3J9LiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBzYXRpc2Z5IGF0IGxlYXN0IG9uZSBvZiB0aGUgZmlsdGVycy5cbiAgICpcbiAgICogVW5saWtlIG1vc3QgZmlsdGVycywgYGZpbHRlcnNgIGlzIHVzZWQgYXMtaXMgYW5kIG5lZWRzIHRvIGZvbGxvdyBbUG9zdGdSRVNUXG4gICAqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG4gICAqIHRvIG1ha2Ugc3VyZSBpdCdzIHByb3Blcmx5IHNhbml0aXplZC5cbiAgICpcbiAgICogSXQncyBjdXJyZW50bHkgbm90IHBvc3NpYmxlIHRvIGRvIGFuIGAub3IoKWAgZmlsdGVyIGFjcm9zcyBtdWx0aXBsZSB0YWJsZXMuXG4gICAqXG4gICAqIEBwYXJhbSBmaWx0ZXJzIC0gVGhlIGZpbHRlcnMgdG8gdXNlLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gZmlsdGVyIG9uIHJlZmVyZW5jZWQgdGFibGVzXG4gICAqIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYHJlZmVyZW5jZWRUYWJsZWAgaW5zdGVhZFxuICAgKi9cbiAgb3IoXG4gICAgZmlsdGVyczogc3RyaW5nLFxuICAgIHtcbiAgICAgIGZvcmVpZ25UYWJsZSxcbiAgICAgIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSxcbiAgICB9OiB7IGZvcmVpZ25UYWJsZT86IHN0cmluZzsgcmVmZXJlbmNlZFRhYmxlPzogc3RyaW5nIH0gPSB7fVxuICApOiB0aGlzIHtcbiAgICBjb25zdCBrZXkgPSByZWZlcmVuY2VkVGFibGUgPyBgJHtyZWZlcmVuY2VkVGFibGV9Lm9yYCA6ICdvcidcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgYCgke2ZpbHRlcnN9KWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGZpbHRlcjxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgb3BlcmF0b3I6IGAkeycnIHwgJ25vdC4nfSR7RmlsdGVyT3BlcmF0b3J9YCxcbiAgICB2YWx1ZTogdW5rbm93blxuICApOiB0aGlzXG4gIGZpbHRlcihjb2x1bW46IHN0cmluZywgb3BlcmF0b3I6IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hpY2ggc2F0aXNmeSB0aGUgZmlsdGVyLiBUaGlzIGlzIGFuIGVzY2FwZSBoYXRjaCAtIHlvdVxuICAgKiBzaG91bGQgdXNlIHRoZSBzcGVjaWZpYyBmaWx0ZXIgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZS5cbiAgICpcbiAgICogVW5saWtlIG1vc3QgZmlsdGVycywgYG9wZWFyYXRvcmAgYW5kIGB2YWx1ZWAgYXJlIHVzZWQgYXMtaXMgYW5kIG5lZWQgdG9cbiAgICogZm9sbG93IFtQb3N0Z1JFU1RcbiAgICogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcbiAgICogdG8gbWFrZSBzdXJlIHRoZXkgYXJlIHByb3Blcmx5IHNhbml0aXplZC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBvcGVyYXRvciAtIFRoZSBvcGVyYXRvciB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgKi9cbiAgZmlsdGVyKGNvbHVtbjogc3RyaW5nLCBvcGVyYXRvcjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgJHtvcGVyYXRvcn0uJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cbiIsICJpbXBvcnQgUG9zdGdyZXN0QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0RmlsdGVyQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXInXG5pbXBvcnQgeyBHZXRSZXN1bHQgfSBmcm9tICcuL3NlbGVjdC1xdWVyeS1wYXJzZXIvcmVzdWx0J1xuaW1wb3J0IHsgRmV0Y2gsIEdlbmVyaWNTY2hlbWEsIEdlbmVyaWNUYWJsZSwgR2VuZXJpY1ZpZXcgfSBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8XG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEsXG4gIFJlbGF0aW9uIGV4dGVuZHMgR2VuZXJpY1RhYmxlIHwgR2VuZXJpY1ZpZXcsXG4gIFJlbGF0aW9uTmFtZSA9IHVua25vd24sXG4gIFJlbGF0aW9uc2hpcHMgPSBSZWxhdGlvbiBleHRlbmRzIHsgUmVsYXRpb25zaGlwczogaW5mZXIgUiB9ID8gUiA6IHVua25vd25cbj4ge1xuICB1cmw6IFVSTFxuICBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIHNjaGVtYT86IHN0cmluZ1xuICBzaWduYWw/OiBBYm9ydFNpZ25hbFxuICBmZXRjaD86IEZldGNoXG5cbiAgY29uc3RydWN0b3IoXG4gICAgdXJsOiBVUkwsXG4gICAge1xuICAgICAgaGVhZGVycyA9IHt9LFxuICAgICAgc2NoZW1hLFxuICAgICAgZmV0Y2gsXG4gICAgfToge1xuICAgICAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICAgIHNjaGVtYT86IHN0cmluZ1xuICAgICAgZmV0Y2g/OiBGZXRjaFxuICAgIH1cbiAgKSB7XG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWFcbiAgICB0aGlzLmZldGNoID0gZmV0Y2hcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgU0VMRUNUIHF1ZXJ5IG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1ucyAtIFRoZSBjb2x1bW5zIHRvIHJldHJpZXZlLCBzZXBhcmF0ZWQgYnkgY29tbWFzLiBDb2x1bW5zIGNhbiBiZSByZW5hbWVkIHdoZW4gcmV0dXJuZWQgd2l0aCBgY3VzdG9tTmFtZTpjb2x1bW5OYW1lYFxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgKiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIGluIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgKlxuICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAqIGhvb2QuXG4gICAqXG4gICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAqXG4gICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICogbnVtYmVycy5cbiAgICovXG4gIHNlbGVjdDxcbiAgICBRdWVyeSBleHRlbmRzIHN0cmluZyA9ICcqJyxcbiAgICBSZXN1bHRPbmUgPSBHZXRSZXN1bHQ8U2NoZW1hLCBSZWxhdGlvblsnUm93J10sIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcywgUXVlcnk+XG4gID4oXG4gICAgY29sdW1ucz86IFF1ZXJ5LFxuICAgIHtcbiAgICAgIGhlYWQgPSBmYWxzZSxcbiAgICAgIGNvdW50LFxuICAgIH06IHtcbiAgICAgIGhlYWQ/OiBib29sZWFuXG4gICAgICBjb3VudD86ICdleGFjdCcgfCAncGxhbm5lZCcgfCAnZXN0aW1hdGVkJ1xuICAgIH0gPSB7fVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBSZXN1bHRPbmVbXSwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgY29uc3QgbWV0aG9kID0gaGVhZCA/ICdIRUFEJyA6ICdHRVQnXG4gICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2VzIGV4Y2VwdCB3aGVuIHF1b3RlZFxuICAgIGxldCBxdW90ZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNsZWFuZWRDb2x1bW5zID0gKGNvbHVtbnMgPz8gJyonKVxuICAgICAgLnNwbGl0KCcnKVxuICAgICAgLm1hcCgoYykgPT4ge1xuICAgICAgICBpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSB7XG4gICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICBxdW90ZWQgPSAhcXVvdGVkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH0pXG4gICAgICAuam9pbignJylcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZWxlY3QnLCBjbGVhbmVkQ29sdW1ucylcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBgY291bnQ9JHtjb3VudH1gXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICB9IGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxSZXN1bHRPbmVbXT4pXG4gIH1cblxuICAvLyBUT0RPKHYzKTogTWFrZSBgZGVmYXVsdFRvTnVsbGAgY29uc2lzdGVudCBmb3IgYm90aCBzaW5nbGUgJiBidWxrIGluc2VydHMuXG4gIGluc2VydDxSb3cgZXh0ZW5kcyBSZWxhdGlvbiBleHRlbmRzIHsgSW5zZXJ0OiB1bmtub3duIH0gPyBSZWxhdGlvblsnSW5zZXJ0J10gOiBuZXZlcj4oXG4gICAgdmFsdWVzOiBSb3csXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBudWxsLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+XG4gIGluc2VydDxSb3cgZXh0ZW5kcyBSZWxhdGlvbiBleHRlbmRzIHsgSW5zZXJ0OiB1bmtub3duIH0gPyBSZWxhdGlvblsnSW5zZXJ0J10gOiBuZXZlcj4oXG4gICAgdmFsdWVzOiBSb3dbXSxcbiAgICBvcHRpb25zPzoge1xuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICAgIGRlZmF1bHRUb051bGw/OiBib29sZWFuXG4gICAgfVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBudWxsLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+XG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIElOU0VSVCBpbnRvIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBpbnNlcnRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcbiAgICogd2l0aCBgLnNlbGVjdCgpYC5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gaW5zZXJ0LiBQYXNzIGFuIG9iamVjdCB0byBpbnNlcnQgYSBzaW5nbGUgcm93XG4gICAqIG9yIGFuIGFycmF5IHRvIGluc2VydCBtdWx0aXBsZSByb3dzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGluc2VydGVkIHJvd3MuXG4gICAqXG4gICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICogaG9vZC5cbiAgICpcbiAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICpcbiAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgKiBudW1iZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cbiAgICogT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIE9ubHkgYXBwbGllcyBmb3IgYnVsa1xuICAgKiBpbnNlcnRzLlxuICAgKi9cbiAgaW5zZXJ0PFJvdyBleHRlbmRzIFJlbGF0aW9uIGV4dGVuZHMgeyBJbnNlcnQ6IHVua25vd24gfSA/IFJlbGF0aW9uWydJbnNlcnQnXSA6IG5ldmVyPihcbiAgICB2YWx1ZXM6IFJvdyB8IFJvd1tdLFxuICAgIHtcbiAgICAgIGNvdW50LFxuICAgICAgZGVmYXVsdFRvTnVsbCA9IHRydWUsXG4gICAgfToge1xuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICAgIGRlZmF1bHRUb051bGw/OiBib29sZWFuXG4gICAgfSA9IHt9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8U2NoZW1hLCBSZWxhdGlvblsnUm93J10sIG51bGwsIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcz4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJ1xuXG4gICAgY29uc3QgcHJlZmVyc0hlYWRlcnMgPSBbXVxuICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pXG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaChgY291bnQ9JHtjb3VudH1gKVxuICAgIH1cbiAgICBpZiAoIWRlZmF1bHRUb051bGwpIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2goJ21pc3Npbmc9ZGVmYXVsdCcpXG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJylcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYy5jb25jYXQoT2JqZWN0LmtleXMoeCkpLCBbXSBhcyBzdHJpbmdbXSlcbiAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdW5pcXVlQ29sdW1ucyA9IFsuLi5uZXcgU2V0KGNvbHVtbnMpXS5tYXAoKGNvbHVtbikgPT4gYFwiJHtjb2x1bW59XCJgKVxuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdjb2x1bW5zJywgdW5pcXVlQ29sdW1ucy5qb2luKCcsJykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgYm9keTogdmFsdWVzLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICB9IGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxudWxsPilcbiAgfVxuXG4gIC8vIFRPRE8odjMpOiBNYWtlIGBkZWZhdWx0VG9OdWxsYCBjb25zaXN0ZW50IGZvciBib3RoIHNpbmdsZSAmIGJ1bGsgdXBzZXJ0cy5cbiAgdXBzZXJ0PFJvdyBleHRlbmRzIFJlbGF0aW9uIGV4dGVuZHMgeyBJbnNlcnQ6IHVua25vd24gfSA/IFJlbGF0aW9uWydJbnNlcnQnXSA6IG5ldmVyPihcbiAgICB2YWx1ZXM6IFJvdyxcbiAgICBvcHRpb25zPzoge1xuICAgICAgb25Db25mbGljdD86IHN0cmluZ1xuICAgICAgaWdub3JlRHVwbGljYXRlcz86IGJvb2xlYW5cbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBudWxsLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+XG4gIHVwc2VydDxSb3cgZXh0ZW5kcyBSZWxhdGlvbiBleHRlbmRzIHsgSW5zZXJ0OiB1bmtub3duIH0gPyBSZWxhdGlvblsnSW5zZXJ0J10gOiBuZXZlcj4oXG4gICAgdmFsdWVzOiBSb3dbXSxcbiAgICBvcHRpb25zPzoge1xuICAgICAgb25Db25mbGljdD86IHN0cmluZ1xuICAgICAgaWdub3JlRHVwbGljYXRlcz86IGJvb2xlYW5cbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgICBkZWZhdWx0VG9OdWxsPzogYm9vbGVhblxuICAgIH1cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxTY2hlbWEsIFJlbGF0aW9uWydSb3cnXSwgbnVsbCwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPlxuICAvKipcbiAgICogUGVyZm9ybSBhbiBVUFNFUlQgb24gdGhlIHRhYmxlIG9yIHZpZXcuIERlcGVuZGluZyBvbiB0aGUgY29sdW1uKHMpIHBhc3NlZFxuICAgKiB0byBgb25Db25mbGljdGAsIGAudXBzZXJ0KClgIGFsbG93cyB5b3UgdG8gcGVyZm9ybSB0aGUgZXF1aXZhbGVudCBvZlxuICAgKiBgLmluc2VydCgpYCBpZiBhIHJvdyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGBvbkNvbmZsaWN0YCBjb2x1bW5zIGRvZXNuJ3RcbiAgICogZXhpc3QsIG9yIGlmIGl0IGRvZXMgZXhpc3QsIHBlcmZvcm0gYW4gYWx0ZXJuYXRpdmUgYWN0aW9uIGRlcGVuZGluZyBvblxuICAgKiBgaWdub3JlRHVwbGljYXRlc2AuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHVwc2VydGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuICAgKiB3aXRoIGAuc2VsZWN0KClgLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cHNlcnQgd2l0aC4gUGFzcyBhbiBvYmplY3QgdG8gdXBzZXJ0IGFcbiAgICogc2luZ2xlIHJvdyBvciBhbiBhcnJheSB0byB1cHNlcnQgbXVsdGlwbGUgcm93cy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLm9uQ29uZmxpY3QgLSBDb21tYS1zZXBhcmF0ZWQgVU5JUVVFIGNvbHVtbihzKSB0byBzcGVjaWZ5IGhvd1xuICAgKiBkdXBsaWNhdGUgcm93cyBhcmUgZGV0ZXJtaW5lZC4gVHdvIHJvd3MgYXJlIGR1cGxpY2F0ZXMgaWYgYWxsIHRoZVxuICAgKiBgb25Db25mbGljdGAgY29sdW1ucyBhcmUgZXF1YWwuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgLSBJZiBgdHJ1ZWAsIGR1cGxpY2F0ZSByb3dzIGFyZSBpZ25vcmVkLiBJZlxuICAgKiBgZmFsc2VgLCBkdXBsaWNhdGUgcm93cyBhcmUgbWVyZ2VkIHdpdGggZXhpc3Rpbmcgcm93cy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwc2VydGVkIHJvd3MuXG4gICAqXG4gICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICogaG9vZC5cbiAgICpcbiAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICpcbiAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgKiBudW1iZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cbiAgICogT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIFRoaXMgb25seSBhcHBsaWVzIHdoZW5cbiAgICogaW5zZXJ0aW5nIG5ldyByb3dzLCBub3Qgd2hlbiBtZXJnaW5nIHdpdGggZXhpc3Rpbmcgcm93cyB1bmRlclxuICAgKiBgaWdub3JlRHVwbGljYXRlczogZmFsc2VgLiBUaGlzIGFsc28gb25seSBhcHBsaWVzIHdoZW4gZG9pbmcgYnVsayB1cHNlcnRzLlxuICAgKi9cbiAgdXBzZXJ0PFJvdyBleHRlbmRzIFJlbGF0aW9uIGV4dGVuZHMgeyBJbnNlcnQ6IHVua25vd24gfSA/IFJlbGF0aW9uWydJbnNlcnQnXSA6IG5ldmVyPihcbiAgICB2YWx1ZXM6IFJvdyB8IFJvd1tdLFxuICAgIHtcbiAgICAgIG9uQ29uZmxpY3QsXG4gICAgICBpZ25vcmVEdXBsaWNhdGVzID0gZmFsc2UsXG4gICAgICBjb3VudCxcbiAgICAgIGRlZmF1bHRUb051bGwgPSB0cnVlLFxuICAgIH06IHtcbiAgICAgIG9uQ29uZmxpY3Q/OiBzdHJpbmdcbiAgICAgIGlnbm9yZUR1cGxpY2F0ZXM/OiBib29sZWFuXG4gICAgICBjb3VudD86ICdleGFjdCcgfCAncGxhbm5lZCcgfCAnZXN0aW1hdGVkJ1xuICAgICAgZGVmYXVsdFRvTnVsbD86IGJvb2xlYW5cbiAgICB9ID0ge31cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxTY2hlbWEsIFJlbGF0aW9uWydSb3cnXSwgbnVsbCwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnXG5cbiAgICBjb25zdCBwcmVmZXJzSGVhZGVycyA9IFtgcmVzb2x1dGlvbj0ke2lnbm9yZUR1cGxpY2F0ZXMgPyAnaWdub3JlJyA6ICdtZXJnZSd9LWR1cGxpY2F0ZXNgXVxuXG4gICAgaWYgKG9uQ29uZmxpY3QgIT09IHVuZGVmaW5lZCkgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldCgnb25fY29uZmxpY3QnLCBvbkNvbmZsaWN0KVxuICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pXG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaChgY291bnQ9JHtjb3VudH1gKVxuICAgIH1cbiAgICBpZiAoIWRlZmF1bHRUb051bGwpIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2goJ21pc3Npbmc9ZGVmYXVsdCcpXG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJylcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYy5jb25jYXQoT2JqZWN0LmtleXMoeCkpLCBbXSBhcyBzdHJpbmdbXSlcbiAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdW5pcXVlQ29sdW1ucyA9IFsuLi5uZXcgU2V0KGNvbHVtbnMpXS5tYXAoKGNvbHVtbikgPT4gYFwiJHtjb2x1bW59XCJgKVxuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdjb2x1bW5zJywgdW5pcXVlQ29sdW1ucy5qb2luKCcsJykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgYm9keTogdmFsdWVzLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICB9IGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxudWxsPilcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIFVQREFURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdXBkYXRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcbiAgICogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cGRhdGUgd2l0aFxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwZGF0ZWQgcm93cy5cbiAgICpcbiAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgKiBob29kLlxuICAgKlxuICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgKlxuICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAqIG51bWJlcnMuXG4gICAqL1xuICB1cGRhdGU8Um93IGV4dGVuZHMgUmVsYXRpb24gZXh0ZW5kcyB7IFVwZGF0ZTogdW5rbm93biB9ID8gUmVsYXRpb25bJ1VwZGF0ZSddIDogbmV2ZXI+KFxuICAgIHZhbHVlczogUm93LFxuICAgIHtcbiAgICAgIGNvdW50LFxuICAgIH06IHtcbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfSA9IHt9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8U2NoZW1hLCBSZWxhdGlvblsnUm93J10sIG51bGwsIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcz4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdQQVRDSCdcbiAgICBjb25zdCBwcmVmZXJzSGVhZGVycyA9IFtdXG4gICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2godGhpcy5oZWFkZXJzWydQcmVmZXInXSlcbiAgICB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApXG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJylcblxuICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgIGJvZHk6IHZhbHVlcyxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgfSBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8bnVsbD4pXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhIERFTEVURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgZGVsZXRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcbiAgICogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGRlbGV0ZWQgcm93cy5cbiAgICpcbiAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgKiBob29kLlxuICAgKlxuICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgKlxuICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAqIG51bWJlcnMuXG4gICAqL1xuICBkZWxldGUoe1xuICAgIGNvdW50LFxuICB9OiB7XG4gICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgfSA9IHt9KTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxTY2hlbWEsIFJlbGF0aW9uWydSb3cnXSwgbnVsbCwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSdcbiAgICBjb25zdCBwcmVmZXJzSGVhZGVycyA9IFtdXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApXG4gICAgfVxuICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy51bnNoaWZ0KHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pXG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJylcblxuICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgfSBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8bnVsbD4pXG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcxLjE3LjExJ1xuIiwgImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nXG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBwb3N0Z3Jlc3QtanMvJHt2ZXJzaW9ufWAgfVxuIiwgImltcG9ydCBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgZnJvbSAnLi9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0RmlsdGVyQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEJ1aWxkZXInXG5pbXBvcnQgeyBERUZBVUxUX0hFQURFUlMgfSBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB7IEZldGNoLCBHZW5lcmljU2NoZW1hIH0gZnJvbSAnLi90eXBlcydcblxuLyoqXG4gKiBQb3N0Z1JFU1QgY2xpZW50LlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0YWJhc2UgLSBUeXBlcyBmb3IgdGhlIHNjaGVtYSBmcm9tIHRoZSBbdHlwZVxuICogZ2VuZXJhdG9yXShodHRwczovL3N1cGFiYXNlLmNvbS9kb2NzL3JlZmVyZW5jZS9qYXZhc2NyaXB0L25leHQvdHlwZXNjcmlwdC1zdXBwb3J0KVxuICpcbiAqIEB0eXBlUGFyYW0gU2NoZW1hTmFtZSAtIFBvc3RncmVzIHNjaGVtYSB0byBzd2l0Y2ggdG8uIE11c3QgYmUgYSBzdHJpbmdcbiAqIGxpdGVyYWwsIHRoZSBzYW1lIG9uZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiBJZiB0aGUgc2NoZW1hIGlzIG5vdFxuICogYFwicHVibGljXCJgLCB0aGlzIG11c3QgYmUgc3VwcGxpZWQgbWFudWFsbHkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdENsaWVudDxcbiAgRGF0YWJhc2UgPSBhbnksXG4gIFNjaGVtYU5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSA9ICdwdWJsaWMnIGV4dGVuZHMga2V5b2YgRGF0YWJhc2VcbiAgICA/ICdwdWJsaWMnXG4gICAgOiBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSxcbiAgU2NoZW1hIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSA9IERhdGFiYXNlW1NjaGVtYU5hbWVdIGV4dGVuZHMgR2VuZXJpY1NjaGVtYVxuICAgID8gRGF0YWJhc2VbU2NoZW1hTmFtZV1cbiAgICA6IGFueVxuPiB7XG4gIHVybDogc3RyaW5nXG4gIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgc2NoZW1hTmFtZT86IFNjaGVtYU5hbWVcbiAgZmV0Y2g/OiBGZXRjaFxuXG4gIC8vIFRPRE86IEFkZCBiYWNrIHNob3VsZFRocm93T25FcnJvciBvbmNlIHdlIGZpZ3VyZSBvdXQgdGhlIHR5cGluZ3NcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQb3N0Z1JFU1QgY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0gdXJsIC0gVVJMIG9mIHRoZSBQb3N0Z1JFU1QgZW5kcG9pbnRcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgLSBDdXN0b20gaGVhZGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5zY2hlbWEgLSBQb3N0Z3JlcyBzY2hlbWEgdG8gc3dpdGNoIHRvXG4gICAqIEBwYXJhbSBvcHRpb25zLmZldGNoIC0gQ3VzdG9tIGZldGNoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICB1cmw6IHN0cmluZyxcbiAgICB7XG4gICAgICBoZWFkZXJzID0ge30sXG4gICAgICBzY2hlbWEsXG4gICAgICBmZXRjaCxcbiAgICB9OiB7XG4gICAgICBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgICAgc2NoZW1hPzogU2NoZW1hTmFtZVxuICAgICAgZmV0Y2g/OiBGZXRjaFxuICAgIH0gPSB7fVxuICApIHtcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMuaGVhZGVycyA9IHsgLi4uREVGQVVMVF9IRUFERVJTLCAuLi5oZWFkZXJzIH1cbiAgICB0aGlzLnNjaGVtYU5hbWUgPSBzY2hlbWFcbiAgICB0aGlzLmZldGNoID0gZmV0Y2hcbiAgfVxuXG4gIGZyb208XG4gICAgVGFibGVOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgU2NoZW1hWydUYWJsZXMnXSxcbiAgICBUYWJsZSBleHRlbmRzIFNjaGVtYVsnVGFibGVzJ11bVGFibGVOYW1lXVxuICA+KHJlbGF0aW9uOiBUYWJsZU5hbWUpOiBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8U2NoZW1hLCBUYWJsZSwgVGFibGVOYW1lPlxuICBmcm9tPFZpZXdOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgU2NoZW1hWydWaWV3cyddLCBWaWV3IGV4dGVuZHMgU2NoZW1hWydWaWV3cyddW1ZpZXdOYW1lXT4oXG4gICAgcmVsYXRpb246IFZpZXdOYW1lXG4gICk6IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjxTY2hlbWEsIFZpZXcsIFZpZXdOYW1lPlxuICAvKipcbiAgICogUGVyZm9ybSBhIHF1ZXJ5IG9uIGEgdGFibGUgb3IgYSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gcmVsYXRpb24gLSBUaGUgdGFibGUgb3IgdmlldyBuYW1lIHRvIHF1ZXJ5XG4gICAqL1xuICBmcm9tKHJlbGF0aW9uOiBzdHJpbmcpOiBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8U2NoZW1hLCBhbnksIGFueT4ge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9LyR7cmVsYXRpb259YClcbiAgICByZXR1cm4gbmV3IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcih1cmwsIHtcbiAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzIH0sXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hTmFtZSxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGEgc2NoZW1hIHRvIHF1ZXJ5IG9yIHBlcmZvcm0gYW4gZnVuY3Rpb24gKHJwYykgY2FsbC5cbiAgICpcbiAgICogVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuICAgKlxuICAgKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSB0byBxdWVyeVxuICAgKi9cbiAgc2NoZW1hPER5bmFtaWNTY2hlbWEgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZT4oXG4gICAgc2NoZW1hOiBEeW5hbWljU2NoZW1hXG4gICk6IFBvc3RncmVzdENsaWVudDxcbiAgICBEYXRhYmFzZSxcbiAgICBEeW5hbWljU2NoZW1hLFxuICAgIERhdGFiYXNlW0R5bmFtaWNTY2hlbWFdIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSA/IERhdGFiYXNlW0R5bmFtaWNTY2hlbWFdIDogYW55XG4gID4ge1xuICAgIHJldHVybiBuZXcgUG9zdGdyZXN0Q2xpZW50KHRoaXMudXJsLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWEsXG4gICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBmdW5jdGlvbiBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gbmFtZSB0byBjYWxsXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBjYWxsXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG4gICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICogQHBhcmFtIG9wdGlvbnMuZ2V0IC0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aFxuICAgKiByZWFkLW9ubHkgYWNjZXNzIG1vZGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIHJldHVybmVkIGJ5IHRoZVxuICAgKiBmdW5jdGlvbi4gT25seSBhcHBsaWNhYmxlIGZvciBbc2V0LXJldHVybmluZ1xuICAgKiBmdW5jdGlvbnNdKGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9mdW5jdGlvbnMtc3JmLmh0bWwpLlxuICAgKlxuICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAqIGhvb2QuXG4gICAqXG4gICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAqXG4gICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICogbnVtYmVycy5cbiAgICovXG4gIHJwYzxGbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBTY2hlbWFbJ0Z1bmN0aW9ucyddLCBGbiBleHRlbmRzIFNjaGVtYVsnRnVuY3Rpb25zJ11bRm5OYW1lXT4oXG4gICAgZm46IEZuTmFtZSxcbiAgICBhcmdzOiBGblsnQXJncyddID0ge30sXG4gICAge1xuICAgICAgaGVhZCA9IGZhbHNlLFxuICAgICAgZ2V0ID0gZmFsc2UsXG4gICAgICBjb3VudCxcbiAgICB9OiB7XG4gICAgICBoZWFkPzogYm9vbGVhblxuICAgICAgZ2V0PzogYm9vbGVhblxuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICB9ID0ge31cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxcbiAgICBTY2hlbWEsXG4gICAgRm5bJ1JldHVybnMnXSBleHRlbmRzIGFueVtdXG4gICAgICA/IEZuWydSZXR1cm5zJ11bbnVtYmVyXSBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gICAgICAgID8gRm5bJ1JldHVybnMnXVtudW1iZXJdXG4gICAgICAgIDogbmV2ZXJcbiAgICAgIDogbmV2ZXIsXG4gICAgRm5bJ1JldHVybnMnXSxcbiAgICBGbk5hbWUsXG4gICAgbnVsbFxuICA+IHtcbiAgICBsZXQgbWV0aG9kOiAnSEVBRCcgfCAnR0VUJyB8ICdQT1NUJ1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9L3JwYy8ke2ZufWApXG4gICAgbGV0IGJvZHk6IHVua25vd24gfCB1bmRlZmluZWRcbiAgICBpZiAoaGVhZCB8fCBnZXQpIHtcbiAgICAgIG1ldGhvZCA9IGhlYWQgPyAnSEVBRCcgOiAnR0VUJ1xuICAgICAgT2JqZWN0LmVudHJpZXMoYXJncylcbiAgICAgICAgLy8gcGFyYW1zIHdpdGggdW5kZWZpbmVkIHZhbHVlIG5lZWRzIHRvIGJlIGZpbHRlcmVkIG91dCwgb3RoZXJ3aXNlIGl0J2xsXG4gICAgICAgIC8vIHNob3cgdXAgYXMgYD9wYXJhbT11bmRlZmluZWRgXG4gICAgICAgIC5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIC8vIGFycmF5IHZhbHVlcyBuZWVkIHNwZWNpYWwgc3ludGF4XG4gICAgICAgIC5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IFtuYW1lLCBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGB7JHt2YWx1ZS5qb2luKCcsJyl9fWAgOiBgJHt2YWx1ZX1gXSlcbiAgICAgICAgLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbWV0aG9kID0gJ1BPU1QnXG4gICAgICBib2R5ID0gYXJnc1xuICAgIH1cblxuICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXMuaGVhZGVycyB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBoZWFkZXJzWydQcmVmZXInXSA9IGBjb3VudD0ke2NvdW50fWBcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuICAgICAgbWV0aG9kLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWFOYW1lLFxuICAgICAgYm9keSxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgfSBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8Rm5bJ1JldHVybnMnXT4pXG4gIH1cbn1cbiIsICIvLyBBbHdheXMgdXBkYXRlIHdyYXBwZXIubWpzIHdoZW4gdXBkYXRpbmcgdGhpcyBmaWxlLlxuaW1wb3J0IFBvc3RncmVzdENsaWVudCBmcm9tICcuL1Bvc3RncmVzdENsaWVudCdcbmltcG9ydCBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgZnJvbSAnLi9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0RmlsdGVyQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0RXJyb3IgZnJvbSAnLi9Qb3N0Z3Jlc3RFcnJvcidcblxuZXhwb3J0IHtcbiAgUG9zdGdyZXN0Q2xpZW50LFxuICBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIsXG4gIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsXG4gIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIsXG4gIFBvc3RncmVzdEJ1aWxkZXIsXG4gIFBvc3RncmVzdEVycm9yLFxufVxuZXhwb3J0IGRlZmF1bHQge1xuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbiAgUG9zdGdyZXN0QnVpbGRlcixcbiAgUG9zdGdyZXN0RXJyb3IsXG59XG5leHBvcnQgdHlwZSB7XG4gIFBvc3RncmVzdFJlc3BvbnNlLFxuICBQb3N0Z3Jlc3RSZXNwb25zZUZhaWx1cmUsXG4gIFBvc3RncmVzdFJlc3BvbnNlU3VjY2VzcyxcbiAgUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2UsXG4gIFBvc3RncmVzdE1heWJlU2luZ2xlUmVzcG9uc2UsXG59IGZyb20gJy4vdHlwZXMnXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy81NTFcbi8vIFRvIGJlIHJlcGxhY2VkIHdpdGggYSBoZWxwZXIgdHlwZSB0aGF0IG9ubHkgdXNlcyBwdWJsaWMgdHlwZXNcbmV4cG9ydCB0eXBlIHsgR2V0UmVzdWx0IGFzIFVuc3RhYmxlR2V0UmVzdWx0IH0gZnJvbSAnLi9zZWxlY3QtcXVlcnktcGFyc2VyL3Jlc3VsdCdcbiIsICIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3dzIGRvZXMgbm90IHdvcmsgaW4gdGhlIGJyb3dzZXIuIEJyb3dzZXIgY2xpZW50cyBtdXN0IHVzZSB0aGUgbmF0aXZlICcgK1xuICAgICAgJ1dlYlNvY2tldCBvYmplY3QnXG4gICk7XG59O1xuIiwgIi8vIHNyYy9tYWluLnRzXG5pbXBvcnQgeyBQbHVnaW4sIFRGaWxlLCBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBTdXBhYmFzZVNlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL1N1cGFiYXNlU2VydmljZSc7XG5pbXBvcnQgeyBPcGVuQUlTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy9PcGVuQUlTZXJ2aWNlJztcbmltcG9ydCB7IFF1ZXVlU2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvUXVldWVTZXJ2aWNlJztcbmltcG9ydCB7IEZpbGVUcmFja2VyIH0gZnJvbSAnLi91dGlscy9GaWxlVHJhY2tlcic7XG5pbXBvcnQgeyBFcnJvckhhbmRsZXIgfSBmcm9tICcuL3V0aWxzL0Vycm9ySGFuZGxlcic7XG5pbXBvcnQgeyBOb3RpZmljYXRpb25NYW5hZ2VyIH0gZnJvbSAnLi91dGlscy9Ob3RpZmljYXRpb25NYW5hZ2VyJztcbmltcG9ydCB7IE1pbmRNYXRyaXhTZXR0aW5nc1RhYiB9IGZyb20gJy4vc2V0dGluZ3MvU2V0dGluZ3NUYWInO1xuaW1wb3J0IHsgU3luY0ZpbGVNYW5hZ2VyIH0gZnJvbSAnLi9zZXJ2aWNlcy9TeW5jRmlsZU1hbmFnZXInO1xuaW1wb3J0IHsgSW5pdGlhbFN5bmNNYW5hZ2VyIH0gZnJvbSAnLi9zZXJ2aWNlcy9Jbml0aWFsU3luY01hbmFnZXInO1xuaW1wb3J0IHsgTWV0YWRhdGFFeHRyYWN0b3IgfSBmcm9tICcuL3NlcnZpY2VzL01ldGFkYXRhRXh0cmFjdG9yJztcbmltcG9ydCB7IFN0YXR1c01hbmFnZXIsIFBsdWdpblN0YXR1cyB9IGZyb20gJy4vc2VydmljZXMvU3RhdHVzTWFuYWdlcic7XG5pbXBvcnQgeyBTeW5jRGV0ZWN0aW9uTWFuYWdlciB9IGZyb20gJy4vc2VydmljZXMvU3luY0RldGVjdGlvbk1hbmFnZXInO1xuaW1wb3J0IHtcblx0TWluZE1hdHJpeFNldHRpbmdzLFxuXHRERUZBVUxUX1NFVFRJTkdTLFxuXHRpc1ZhdWx0SW5pdGlhbGl6ZWQsXG5cdGdlbmVyYXRlVmF1bHRJZCxcblx0Z2V0QWxsRXhjbHVzaW9ucyxcblx0U1lTVEVNX0VYQ0xVU0lPTlNcbn0gZnJvbSAnLi9zZXR0aW5ncy9TZXR0aW5ncyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1pbmRNYXRyaXhQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuXHRzZXR0aW5nczogTWluZE1hdHJpeFNldHRpbmdzO1xuXHRwcml2YXRlIHN1cGFiYXNlU2VydmljZTogU3VwYWJhc2VTZXJ2aWNlIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgb3BlbkFJU2VydmljZTogT3BlbkFJU2VydmljZSB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIHF1ZXVlU2VydmljZTogUXVldWVTZXJ2aWNlIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgZmlsZVRyYWNrZXI6IEZpbGVUcmFja2VyIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXIgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBub3RpZmljYXRpb25NYW5hZ2VyOiBOb3RpZmljYXRpb25NYW5hZ2VyIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgaXNJbml0aWFsaXppbmcgPSBmYWxzZTtcblx0cHJpdmF0ZSBzeW5jTWFuYWdlcjogU3luY0ZpbGVNYW5hZ2VyIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgc3luY0NoZWNrSW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgaW5pdGlhbGl6YXRpb25UaW1lb3V0OiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIHN5bmNDaGVja0F0dGVtcHRzID0gMDtcblx0cHJpdmF0ZSBpbml0aWFsU3luY01hbmFnZXI6IEluaXRpYWxTeW5jTWFuYWdlciB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIG1ldGFkYXRhRXh0cmFjdG9yOiBNZXRhZGF0YUV4dHJhY3RvciB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIHN0YXR1c01hbmFnZXI6IFN0YXR1c01hbmFnZXIgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBzeW5jRGV0ZWN0aW9uTWFuYWdlcjogU3luY0RldGVjdGlvbk1hbmFnZXIgfCBudWxsID0gbnVsbDtcblxuXHRhc3luYyBvbmxvYWQoKSB7XG5cdFx0Y29uc29sZS5sb2coJ0xvYWRpbmcgTWluZCBNYXRyaXggUGx1Z2luLi4uJyk7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIEluaXRpYWxpemUgc3RhdHVzIG1hbmFnZXIgZmlyc3Rcblx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlciA9IG5ldyBTdGF0dXNNYW5hZ2VyKHRoaXMuYWRkU3RhdHVzQmFySXRlbSgpKTtcblx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlci5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLklOSVRJQUxJWklORywge1xuXHRcdFx0XHRtZXNzYWdlOiAnTG9hZGluZyBNaW5kIE1hdHJpeCBQbHVnaW4uLi4nXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gTG9hZCBzZXR0aW5nc1xuXHRcdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBjb3JlIHNlcnZpY2VzIGFuZCB2YXVsdCBpZiBuZWVkZWRcblx0XHRcdGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUNvcmVTZXJ2aWNlcygpO1xuXHRcdFx0YXdhaXQgdGhpcy5pbml0aWFsaXplVmF1bHRJZk5lZWRlZCgpO1xuXG5cdFx0XHQvLyBBZGQgc2V0dGluZ3MgdGFiXG5cdFx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IE1pbmRNYXRyaXhTZXR0aW5nc1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG5cdFx0XHRpZiAoaXNWYXVsdEluaXRpYWxpemVkKHRoaXMuc2V0dGluZ3MpKSB7XG5cdFx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlci5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLldBSVRJTkdfRk9SX1NZTkMsIHtcblx0XHRcdFx0XHRtZXNzYWdlOiAnV2FpdGluZyBmb3IgT2JzaWRpYW4gc3luYyB0byBzZXR0bGUuLi4nXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQvLyBDcmVhdGUgYW5kIHN0YXJ0IHN5bmMgZGV0ZWN0aW9uIHdpdGggaW1wcm92ZWQgbG9nZ2luZ1xuXHRcdFx0XHR0aGlzLnN5bmNEZXRlY3Rpb25NYW5hZ2VyID0gbmV3IFN5bmNEZXRlY3Rpb25NYW5hZ2VyKFxuXHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0dGhpcy5zdGF0dXNNYW5hZ2VyLFxuXHRcdFx0XHRcdHRoaXMub25TeW5jUXVpZXRQZXJpb2RSZWFjaGVkLmJpbmQodGhpcylcblx0XHRcdFx0KTtcblx0XHRcdFx0dGhpcy5zeW5jRGV0ZWN0aW9uTWFuYWdlci5zdGFydE1vbml0b3JpbmcoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMuY29tcGxldGVJbml0aWFsaXphdGlvbigpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBNaW5kIE1hdHJpeCBQbHVnaW46JywgZXJyb3IpO1xuXHRcdFx0dGhpcy5zdGF0dXNNYW5hZ2VyPy5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLkVSUk9SLCB7XG5cdFx0XHRcdG1lc3NhZ2U6ICdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBwbHVnaW4uIENoZWNrIGNvbnNvbGUgZm9yIGRldGFpbHMuJyxcblx0XHRcdFx0ZXJyb3I6IGVycm9yIGFzIEVycm9yXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIG9uU3luY1F1aWV0UGVyaW9kUmVhY2hlZCgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gU3RvcCBtb25pdG9yaW5nIGFzIHdlJ3ZlIHJlYWNoZWQgYSBxdWlldCBwZXJpb2Rcblx0XHRcdHRoaXMuc3luY0RldGVjdGlvbk1hbmFnZXI/LnN0b3BNb25pdG9yaW5nKCk7XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuQ0hFQ0tJTkdfRklMRSwge1xuXHRcdFx0XHRtZXNzYWdlOiAnSW5pdGlhbGl6aW5nIHN5bmMgbWFuYWdlciB3aXRoIHVwZGF0ZWQgc3luYyBmaWxlIGZvcm1hdC4uLidcblx0XHRcdH0pO1xuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBzeW5jIG1hbmFnZXJcblx0XHRcdGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVN5bmNNYW5hZ2VyKCk7XG5cdFx0XHQvLyBTdGFydCBzeW5jIHByb2Nlc3Ncblx0XHRcdGF3YWl0IHRoaXMuc3RhcnRTeW5jUHJvY2VzcygpO1xuXHRcdFx0Ly8gQ29tcGxldGUgcmVtYWluaW5nIGluaXRpYWxpemF0aW9uXG5cdFx0XHRhd2FpdCB0aGlzLmNvbXBsZXRlSW5pdGlhbGl6YXRpb24oKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIHF1aWV0IHBlcmlvZCBpbml0aWFsaXphdGlvbjonLCBlcnJvcik7XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuRVJST1IsIHtcblx0XHRcdFx0bWVzc2FnZTogJ0ZhaWxlZCB0byBpbml0aWFsaXplIGFmdGVyIHN5bmMgcXVpZXQgcGVyaW9kJyxcblx0XHRcdFx0ZXJyb3I6IGVycm9yIGFzIEVycm9yXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGNvbXBsZXRlSW5pdGlhbGl6YXRpb24oKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzIGFuZCBjb21tYW5kc1xuXHRcdFx0dGhpcy5yZWdpc3RlckV2ZW50SGFuZGxlcnMoKTtcblx0XHRcdHRoaXMuYWRkQ29tbWFuZHMoKTtcblx0XHRcdC8vIFVwZGF0ZSBzdGF0dXMgdG8gcmVhZHlcblx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlcj8uc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5SRUFEWSwge1xuXHRcdFx0XHRtZXNzYWdlOiAnTWluZCBNYXRyaXggaXMgcmVhZHknXG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgY29tcGxldGluZyBpbml0aWFsaXphdGlvbjonLCBlcnJvcik7XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuRVJST1IsIHtcblx0XHRcdFx0bWVzc2FnZTogJ0ZhaWxlZCB0byBjb21wbGV0ZSBpbml0aWFsaXphdGlvbicsXG5cdFx0XHRcdGVycm9yOiBlcnJvciBhcyBFcnJvclxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgb251bmxvYWQoKSB7XG5cdFx0Y29uc29sZS5sb2coJ1VubG9hZGluZyBNaW5kIE1hdHJpeCBQbHVnaW4uLi4nKTtcblx0XHQvLyBTdG9wIHN5bmMgZGV0ZWN0aW9uIGFuZCBjbGVhciBhbnkgaW50ZXJ2YWxzL3RpbWVvdXRzXG5cdFx0dGhpcy5zeW5jRGV0ZWN0aW9uTWFuYWdlcj8uc3RvcE1vbml0b3JpbmcoKTtcblx0XHRpZiAodGhpcy5pbml0aWFsaXphdGlvblRpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLmluaXRpYWxpemF0aW9uVGltZW91dCk7XG5cdFx0aWYgKHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwpIGNsZWFySW50ZXJ2YWwodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCk7XG5cdFx0dGhpcy5xdWV1ZVNlcnZpY2U/LnN0b3AoKTtcblx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXI/LmNsZWFyKCk7XG5cdFx0dGhpcy5pbml0aWFsU3luY01hbmFnZXI/LnN0b3AoKTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgc3RhcnRTeW5jUHJvY2VzcygpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuc3luY01hbmFnZXIpIHRocm93IG5ldyBFcnJvcignU3luYyBtYW5hZ2VyIG5vdCBpbml0aWFsaXplZCcpO1xuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuQ0hFQ0tJTkdfRklMRSwge1xuXHRcdFx0XHRtZXNzYWdlOiAnQ2hlY2tpbmcgc3luYyBmaWxlIHN0YXR1cyB3aXRoIG5ldyBzdHJ1Y3R1cmUuLi4nXG5cdFx0XHR9KTtcblx0XHRcdGNvbnN0IHN5bmNTdGF0dXMgPSBhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLnZhbGlkYXRlU3luY1N0YXRlKCk7XG5cdFx0XHRpZiAoIXN5bmNTdGF0dXMuaXNWYWxpZCkge1xuXHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5zeW5jLnJlcXVpcmVTeW5jKSB7XG5cdFx0XHRcdFx0dGhpcy5zdGF0dXNNYW5hZ2VyPy5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLkVSUk9SLCB7XG5cdFx0XHRcdFx0XHRtZXNzYWdlOiBgU3luYyB2YWxpZGF0aW9uIGZhaWxlZDogJHtzeW5jU3RhdHVzLmVycm9yfWBcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFN5bmMgdmFsaWRhdGlvbiBmYWlsZWQ6ICR7c3luY1N0YXR1cy5lcnJvcn1gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oYFN5bmMgdmFsaWRhdGlvbiB3YXJuaW5nOiAke3N5bmNTdGF0dXMuZXJyb3J9YCk7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgU3luYyB3YXJuaW5nOiAke3N5bmNTdGF0dXMuZXJyb3J9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlcj8uc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5JTklUSUFMSVpJTkcsIHtcblx0XHRcdFx0bWVzc2FnZTogJ0luaXRpYWxpemluZyBzZXJ2aWNlcy4uLidcblx0XHRcdH0pO1xuXHRcdFx0YXdhaXQgdGhpcy5pbml0aWFsaXplU2VydmljZXMoKTtcblx0XHRcdC8vIFN0YXJ0IHBlcmlvZGljIHN5bmMgY2hlY2tzXG5cdFx0XHR0aGlzLnN0YXJ0UGVyaW9kaWNTeW5jQ2hlY2tzKCk7XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5pbml0aWFsU3luYy5lbmFibGVBdXRvSW5pdGlhbFN5bmMgJiYgdGhpcy5pbml0aWFsU3luY01hbmFnZXIpIHtcblx0XHRcdFx0dGhpcy5zdGF0dXNNYW5hZ2VyPy5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLklOSVRJQUxJWklORywge1xuXHRcdFx0XHRcdG1lc3NhZ2U6ICdTdGFydGluZyBpbml0aWFsIHZhdWx0IHN5bmMuLi4nXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRhd2FpdCB0aGlzLmluaXRpYWxTeW5jTWFuYWdlci5zdGFydFN5bmMoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlcj8uc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5SRUFEWSwge1xuXHRcdFx0XHRtZXNzYWdlOiAnU3luYyBwcm9jZXNzIGNvbXBsZXRlZCdcblx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5zeW5jLnJlcXVpcmVTeW5jKSB7XG5cdFx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlcj8uc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5FUlJPUiwge1xuXHRcdFx0XHRcdG1lc3NhZ2U6ICdTeW5jIHByb2Nlc3MgZmFpbGVkJyxcblx0XHRcdFx0XHRlcnJvcjogZXJyb3IgYXMgRXJyb3Jcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignU3luYyBwcm9jZXNzIGVycm9yOicsIGVycm9yKTtcblx0XHRcdFx0bmV3IE5vdGljZSgnU3luYyBwcm9jZXNzIGVycm9yLiBDb250aW51aW5nIHdpdGggbGltaXRlZCBmdW5jdGlvbmFsaXR5LicpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLmluaXRpYWxpemVTZXJ2aWNlcygpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZVN5bmNNYW5hZ2VyKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghdGhpcy5lcnJvckhhbmRsZXIpIHRocm93IG5ldyBFcnJvcignRXJyb3IgaGFuZGxlciBtdXN0IGJlIGluaXRpYWxpemVkIGJlZm9yZSBzeW5jIG1hbmFnZXInKTtcblx0XHRpZiAoIXRoaXMuc2V0dGluZ3MudmF1bHRJZCkge1xuXHRcdFx0dGhpcy5zZXR0aW5ncy52YXVsdElkID0gZ2VuZXJhdGVWYXVsdElkKCk7XG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0dGhpcy5zeW5jTWFuYWdlciA9IG5ldyBTeW5jRmlsZU1hbmFnZXIoXG5cdFx0XHRcdHRoaXMuYXBwLnZhdWx0LFxuXHRcdFx0XHR0aGlzLmVycm9ySGFuZGxlcixcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5zeW5jLnN5bmNGaWxlUGF0aCxcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5zeW5jLmJhY2t1cEludGVydmFsLFxuXHRcdFx0XHR0aGlzLnNldHRpbmdzLnZhdWx0SWQsXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3luYy5kZXZpY2VJZCxcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5zeW5jLmRldmljZU5hbWUsXG5cdFx0XHRcdHRoaXMubWFuaWZlc3QudmVyc2lvblxuXHRcdFx0KTtcblx0XHRcdGF3YWl0IHRoaXMuc3luY01hbmFnZXIuaW5pdGlhbGl6ZSgpO1xuXHRcdFx0Y29uc29sZS5sb2coJ1N5bmMgbWFuYWdlciBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHkgd2l0aCBuZXcgc3luYyBmaWxlIGZvcm1hdCcpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBzeW5jIG1hbmFnZXI6JywgZXJyb3IpO1xuXHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuZW5hYmxlTm90aWZpY2F0aW9ucykgbmV3IE5vdGljZSgnRmFpbGVkIHRvIGluaXRpYWxpemUgc3luYyBzeXN0ZW0uIFNvbWUgZmVhdHVyZXMgbWF5IGJlIHVuYXZhaWxhYmxlLicpO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBpbml0aWFsaXplQ29yZVNlcnZpY2VzKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRoaXMuc3RhdHVzTWFuYWdlcj8uc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5JTklUSUFMSVpJTkcsIHsgbWVzc2FnZTogJ0luaXRpYWxpemluZyBjb3JlIHNlcnZpY2VzLi4uJyB9KTtcblx0XHQvLyBJbml0aWFsaXplIGVycm9yIGhhbmRsZXJcblx0XHR0aGlzLmVycm9ySGFuZGxlciA9IG5ldyBFcnJvckhhbmRsZXIodGhpcy5zZXR0aW5ncz8uZGVidWcgPz8gREVGQVVMVF9TRVRUSU5HUy5kZWJ1ZywgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5nZXRCYXNlUGF0aCgpKTtcblx0XHQvLyBJbml0aWFsaXplIG5vdGlmaWNhdGlvbiBtYW5hZ2VyXG5cdFx0dGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyID0gbmV3IE5vdGlmaWNhdGlvbk1hbmFnZXIodGhpcy5hZGRTdGF0dXNCYXJJdGVtKCksIHRoaXMuc2V0dGluZ3M/LmVuYWJsZU5vdGlmaWNhdGlvbnMgPz8gdHJ1ZSwgdGhpcy5zZXR0aW5ncz8uZW5hYmxlUHJvZ3Jlc3NCYXIgPz8gdHJ1ZSk7XG5cdFx0dGhpcy5zdGF0dXNNYW5hZ2VyPy5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLklOSVRJQUxJWklORywgeyBtZXNzYWdlOiAnQ29yZSBzZXJ2aWNlcyBpbml0aWFsaXplZCcgfSk7XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcblx0XHQvLyBFbnN1cmUgZXhjbHVzaW9ucyBoYXZlIHRoZSBleHBlY3RlZCBzdHJ1Y3R1cmVcblx0XHRpZiAoIXRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucykgdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zID0geyAuLi5ERUZBVUxUX1NFVFRJTkdTLmV4Y2x1c2lvbnMgfTtcblx0XHRpZiAoIXRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZvbGRlcnMpIHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZvbGRlcnMgPSBbXTtcblx0XHRpZiAoIXRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcykgdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVR5cGVzID0gW107XG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlUHJlZml4ZXMpIHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVQcmVmaXhlcyA9IFtdO1xuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMpIHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVzID0gW107XG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuc3lzdGVtRXhjbHVkZWRGb2xkZXJzKSB0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuc3lzdGVtRXhjbHVkZWRGb2xkZXJzID0gWy4uLlNZU1RFTV9FWENMVVNJT05TLmZvbGRlcnNdO1xuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLnN5c3RlbUV4Y2x1ZGVkRmlsZVR5cGVzKSB0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuc3lzdGVtRXhjbHVkZWRGaWxlVHlwZXMgPSBbLi4uU1lTVEVNX0VYQ0xVU0lPTlMuZmlsZVR5cGVzXTtcblx0XHRpZiAoIXRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5zeXN0ZW1FeGNsdWRlZEZpbGVQcmVmaXhlcykgdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLnN5c3RlbUV4Y2x1ZGVkRmlsZVByZWZpeGVzID0gWy4uLlNZU1RFTV9FWENMVVNJT05TLmZpbGVQcmVmaXhlc107XG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuc3lzdGVtRXhjbHVkZWRGaWxlcykgdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLnN5c3RlbUV4Y2x1ZGVkRmlsZXMgPSBbLi4uU1lTVEVNX0VYQ0xVU0lPTlMuZmlsZXNdO1xuXHR9XG5cblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG5cdFx0Ly8gVXBkYXRlIHNlcnZpY2Ugc2V0dGluZ3MgYWZ0ZXIgc2F2aW5nXG5cdFx0dGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyPy51cGRhdGVTZXR0aW5ncyh0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMsIHRoaXMuc2V0dGluZ3MuZW5hYmxlUHJvZ3Jlc3NCYXIpO1xuXHRcdHRoaXMuZXJyb3JIYW5kbGVyPy51cGRhdGVTZXR0aW5ncyh0aGlzLnNldHRpbmdzLmRlYnVnKTtcblx0XHRpZiAoaXNWYXVsdEluaXRpYWxpemVkKHRoaXMuc2V0dGluZ3MpKSBhd2FpdCB0aGlzLmluaXRpYWxpemVTZXJ2aWNlcygpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGFydFBlcmlvZGljU3luY0NoZWNrcygpOiB2b2lkIHtcblx0XHRpZiAodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCkgY2xlYXJJbnRlcnZhbCh0aGlzLnN5bmNDaGVja0ludGVydmFsKTtcblx0XHR0aGlzLnN5bmNDaGVja0ludGVydmFsID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuXHRcdFx0YXdhaXQgdGhpcy5wZXJmb3JtU3luY0NoZWNrKCk7XG5cdFx0fSwgdGhpcy5zZXR0aW5ncy5zeW5jLmNoZWNrSW50ZXJ2YWwpO1xuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBwZXJmb3JtU3luY0NoZWNrKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghdGhpcy5zeW5jTWFuYWdlcikgcmV0dXJuO1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBzeW5jU3RhdHVzID0gYXdhaXQgdGhpcy5zeW5jTWFuYWdlci52YWxpZGF0ZVN5bmNTdGF0ZSgpO1xuXHRcdFx0aWYgKCFzeW5jU3RhdHVzLmlzVmFsaWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKGBTeW5jIGNoZWNrIGZhaWxlZDogJHtzeW5jU3RhdHVzLmVycm9yfWApO1xuXHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSBuZXcgTm90aWNlKGBTeW5jIGlzc3VlIGRldGVjdGVkOiAke3N5bmNTdGF0dXMuZXJyb3J9YCk7XG5cdFx0XHRcdGNvbnN0IHJlY292ZXJlZCA9IGF3YWl0IHRoaXMuc3luY01hbmFnZXIuYXR0ZW1wdFJlY292ZXJ5KCk7XG5cdFx0XHRcdGlmICghcmVjb3ZlcmVkICYmIHRoaXMuc2V0dGluZ3Muc3luYy5yZXF1aXJlU3luYykgYXdhaXQgdGhpcy5yZXN0YXJ0U2VydmljZXMoKTtcblx0XHRcdH1cblx0XHRcdGF3YWl0IHRoaXMuc3luY01hbmFnZXIudXBkYXRlTGFzdFN5bmMoKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXI/LmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdwZXJmb3JtU3luY0NoZWNrJywgbWV0YWRhdGE6IHsgdGltZXN0YW1wOiBEYXRlLm5vdygpIH0gfSk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyByZXN0YXJ0U2VydmljZXMoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dGhpcy5xdWV1ZVNlcnZpY2U/LnN0b3AoKTtcblx0XHRpZiAodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCkgY2xlYXJJbnRlcnZhbCh0aGlzLnN5bmNDaGVja0ludGVydmFsKTtcblx0XHR0cnkge1xuXHRcdFx0YXdhaXQgdGhpcy5pbml0aWFsaXplU3luY01hbmFnZXIoKTtcblx0XHRcdGF3YWl0IHRoaXMuc3RhcnRTeW5jUHJvY2VzcygpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcmVzdGFydCBzZXJ2aWNlczonLCBlcnJvcik7XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSBuZXcgTm90aWNlKCdGYWlsZWQgdG8gcmVzdGFydCBzZXJ2aWNlcyBhZnRlciBzeW5jIGVycm9yJyk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBpbml0aWFsaXplVmF1bHRJZk5lZWRlZCgpIHtcblx0XHRpZiAodGhpcy5pc0luaXRpYWxpemluZykgcmV0dXJuO1xuXHRcdHRoaXMuaXNJbml0aWFsaXppbmcgPSB0cnVlO1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIWlzVmF1bHRJbml0aWFsaXplZCh0aGlzLnNldHRpbmdzKSkge1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLnZhdWx0SWQgPSBnZW5lcmF0ZVZhdWx0SWQoKTtcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5sYXN0S25vd25WYXVsdE5hbWUgPSB0aGlzLmFwcC52YXVsdC5nZXROYW1lKCk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMpIG5ldyBOb3RpY2UoJ1ZhdWx0IGluaXRpYWxpemVkIHdpdGggbmV3IElEJyk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MubGFzdEtub3duVmF1bHROYW1lICE9PSB0aGlzLmFwcC52YXVsdC5nZXROYW1lKCkpIHtcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5sYXN0S25vd25WYXVsdE5hbWUgPSB0aGlzLmFwcC52YXVsdC5nZXROYW1lKCk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRoaXMuaXNJbml0aWFsaXppbmcgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGluaXRpYWxpemVTZXJ2aWNlcygpIHtcblx0XHRjb25zb2xlLmxvZygnSW5pdGlhbGl6aW5nIHNlcnZpY2VzLi4uJywgeyBoYXNWYXVsdDogISF0aGlzLmFwcC52YXVsdCwgaGFzRXJyb3JIYW5kbGVyOiAhIXRoaXMuZXJyb3JIYW5kbGVyIH0pO1xuXHRcdGlmICghdGhpcy5lcnJvckhhbmRsZXIpIHRocm93IG5ldyBFcnJvcignQ29yZSBzZXJ2aWNlcyBub3QgaW5pdGlhbGl6ZWQnKTtcblx0XHR0cnkge1xuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBGaWxlVHJhY2tlciB3aXRoIHJlZmluZWQgY2hhbmdlIGRldGVjdGlvbiBhbmQgZGVib3VuY2luZy5cblx0XHRcdHRoaXMuZmlsZVRyYWNrZXIgPSBuZXcgRmlsZVRyYWNrZXIodGhpcy5hcHAudmF1bHQsIHRoaXMuZXJyb3JIYW5kbGVyLCB0aGlzLnNldHRpbmdzLnN5bmMuc3luY0ZpbGVQYXRoKTtcblx0XHRcdGF3YWl0IHRoaXMuZmlsZVRyYWNrZXIuaW5pdGlhbGl6ZSgpO1xuXHRcdFx0Y29uc29sZS5sb2coJ0ZpbGVUcmFja2VyIGluaXRpYWxpemVkLicpO1xuXG5cdFx0XHQvLyBJbml0aWFsaXplIFN1cGFiYXNlIHNlcnZpY2Vcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuc3VwYWJhc2VTZXJ2aWNlID0gYXdhaXQgU3VwYWJhc2VTZXJ2aWNlLmdldEluc3RhbmNlKHRoaXMuc2V0dGluZ3MpO1xuXHRcdFx0XHRpZiAoIXRoaXMuc3VwYWJhc2VTZXJ2aWNlKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnU3VwYWJhc2Ugc2VydmljZSBub3QgaW5pdGlhbGl6ZWQuIFBsZWFzZSBjb25maWd1cmUgeW91ciBBUEkgc2V0dGluZ3MuJyk7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignU3VwYWJhc2Ugc2VydmljZSBpbml0aWFsaXphdGlvbiBmYWlsZWQ6IE1pc3NpbmcgY29uZmlndXJhdGlvbi4nKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc29sZS5sb2coJ1N1cGFiYXNlIHNlcnZpY2UgaW5pdGlhbGl6ZWQuJyk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBpbml0aWFsaXphdGlvbiBlcnJvcjonLCBlcnJvcik7XG5cdFx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byBpbml0aWFsaXplIFN1cGFiYXNlIHNlcnZpY2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbml0aWFsaXplIE9wZW5BSSBzZXJ2aWNlXG5cdFx0XHR0aGlzLm9wZW5BSVNlcnZpY2UgPSBuZXcgT3BlbkFJU2VydmljZSh0aGlzLnNldHRpbmdzLm9wZW5haSwgdGhpcy5lcnJvckhhbmRsZXIpO1xuXHRcdFx0Y29uc29sZS5sb2coJ09wZW5BSSBzZXJ2aWNlIGluaXRpYWxpemVkLicpO1xuXG5cdFx0XHRpZiAoIXRoaXMuYXBwLnZhdWx0KSB0aHJvdyBuZXcgRXJyb3IoJ1ZhdWx0IGlzIG5vdCBhdmFpbGFibGUnKTtcblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBxdWV1ZSBzZXJ2aWNlIHdpdGggaW1wcm92ZWQgY29sbGlzaW9uIGhhbmRsaW5nIGFuZCBwcm9ncmVzcyByZXBvcnRpbmcuXG5cdFx0XHRpZiAodGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyICYmIHRoaXMuc3VwYWJhc2VTZXJ2aWNlICYmIHRoaXMub3BlbkFJU2VydmljZSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHRoaXMucXVldWVTZXJ2aWNlID0gbmV3IFF1ZXVlU2VydmljZShcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MucXVldWUubWF4Q29uY3VycmVudCxcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MucXVldWUucmV0cnlBdHRlbXB0cyxcblx0XHRcdFx0XHRcdHRoaXMuc3VwYWJhc2VTZXJ2aWNlLFxuXHRcdFx0XHRcdFx0dGhpcy5vcGVuQUlTZXJ2aWNlLFxuXHRcdFx0XHRcdFx0dGhpcy5lcnJvckhhbmRsZXIsXG5cdFx0XHRcdFx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIsXG5cdFx0XHRcdFx0XHR0aGlzLmFwcC52YXVsdCxcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuY2h1bmtpbmdcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHRoaXMucXVldWVTZXJ2aWNlLnN0YXJ0KCk7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ1F1ZXVlIHNlcnZpY2UgaW5pdGlhbGl6ZWQgYW5kIHN0YXJ0ZWQuJyk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgUXVldWVTZXJ2aWNlOicsIGVycm9yKTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBxdWV1ZSBzZXJ2aWNlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgc2VydmljZXMgbm90IGF2YWlsYWJsZSBmb3IgUXVldWVTZXJ2aWNlIGluaXRpYWxpemF0aW9uJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWV0YWRhdGFFeHRyYWN0b3IgPSBuZXcgTWV0YWRhdGFFeHRyYWN0b3IoKTtcblx0XHRcdGNvbnNvbGUubG9nKCdNZXRhZGF0YUV4dHJhY3RvciBpbml0aWFsaXplZC4nKTtcblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBJbml0aWFsU3luY01hbmFnZXJcblx0XHRcdGlmICh0aGlzLnF1ZXVlU2VydmljZSAmJiB0aGlzLnN5bmNNYW5hZ2VyICYmIHRoaXMubWV0YWRhdGFFeHRyYWN0b3IpIHtcblx0XHRcdFx0Y29uc3QgaW5pdGlhbFN5bmNPcHRpb25zID0ge1xuXHRcdFx0XHRcdC4uLnRoaXMuc2V0dGluZ3MuaW5pdGlhbFN5bmMsXG5cdFx0XHRcdFx0c3luY0ZpbGVQYXRoOiB0aGlzLnNldHRpbmdzLnN5bmMuc3luY0ZpbGVQYXRoLFxuXHRcdFx0XHRcdGV4Y2x1c2lvbnM6IGdldEFsbEV4Y2x1c2lvbnModGhpcy5zZXR0aW5ncylcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5pbml0aWFsU3luY01hbmFnZXIgPSBuZXcgSW5pdGlhbFN5bmNNYW5hZ2VyKFxuXHRcdFx0XHRcdHRoaXMuYXBwLnZhdWx0LFxuXHRcdFx0XHRcdHRoaXMucXVldWVTZXJ2aWNlLFxuXHRcdFx0XHRcdHRoaXMuc3luY01hbmFnZXIsXG5cdFx0XHRcdFx0dGhpcy5tZXRhZGF0YUV4dHJhY3Rvcixcblx0XHRcdFx0XHR0aGlzLmVycm9ySGFuZGxlcixcblx0XHRcdFx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIsXG5cdFx0XHRcdFx0dGhpcy5zdXBhYmFzZVNlcnZpY2UsXG5cdFx0XHRcdFx0aW5pdGlhbFN5bmNPcHRpb25zXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdJbml0aWFsU3luY01hbmFnZXIgaW5pdGlhbGl6ZWQuJyk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIHNlcnZpY2VzOicsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgY2hlY2tSZXF1aXJlZENvbmZpZ3VyYXRpb25zKCk6IHZvaWQge1xuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5vcGVuYWkuYXBpS2V5KSB7XG5cdFx0XHRuZXcgTm90aWNlKCdPcGVuQUkgQVBJIGtleSBpcyBtaXNzaW5nLiBBSSBmZWF0dXJlcyBhcmUgZGlzYWJsZWQuIENvbmZpZ3VyZSBpdCBpbiB0aGUgc2V0dGluZ3MuJyk7XG5cdFx0fVxuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5zdXBhYmFzZS51cmwgfHwgIXRoaXMuc2V0dGluZ3Muc3VwYWJhc2UuYXBpS2V5KSB7XG5cdFx0XHRuZXcgTm90aWNlKCdTdXBhYmFzZSBjb25maWd1cmF0aW9uIGlzIGluY29tcGxldGUuIERhdGFiYXNlIGZlYXR1cmVzIGFyZSBkaXNhYmxlZC4gQ29uZmlndXJlIGl0IGluIHRoZSBzZXR0aW5ncy4nKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHJlZ2lzdGVyRXZlbnRIYW5kbGVycygpIHtcblx0XHQvLyBFbmhhbmNlZCBmaWxlIGV2ZW50IGhhbmRsZXJzIHdpdGggaW1wcm92ZWQgZGVib3VuY2luZyBhbmQgbG9nZ2luZ1xuXG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50KFxuXHRcdFx0dGhpcy5hcHAudmF1bHQub24oJ2NyZWF0ZScsIGFzeW5jIChmaWxlKSA9PiB7XG5cdFx0XHRcdGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHJldHVybjtcblx0XHRcdFx0aWYgKCEoYXdhaXQgdGhpcy5lbnN1cmVTeW5jRmlsZUV4aXN0cygpKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0ZhaWxlZCB0byBjcmVhdGUgc3luYyBmaWxlLiBQbHVnaW4gZnVuY3Rpb25hbGl0eSBsaW1pdGVkLicpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRoaXMuc2hvdWxkUHJvY2Vzc0ZpbGUoZmlsZSkpIHJldHVybjtcblx0XHRcdFx0Y29uc29sZS5sb2coYEZpbGUgY3JlYXRlZDogJHtmaWxlLnBhdGh9YCk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuZmlsZVRyYWNrZXI/LmhhbmRsZUNyZWF0ZShmaWxlKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5xdWV1ZUZpbGVQcm9jZXNzaW5nKGZpbGUsICdDUkVBVEUnKTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXHRcdHRoaXMucmVnaXN0ZXJFdmVudChcblx0XHRcdHRoaXMuYXBwLnZhdWx0Lm9uKCdtb2RpZnknLCBhc3luYyAoZmlsZSkgPT4ge1xuXHRcdFx0XHRpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSByZXR1cm47XG5cdFx0XHRcdGlmICghKGF3YWl0IHRoaXMuZW5zdXJlU3luY0ZpbGVFeGlzdHMoKSkpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKCdGYWlsZWQgdG8gY3JlYXRlIHN5bmMgZmlsZS4gUGx1Z2luIGZ1bmN0aW9uYWxpdHkgbGltaXRlZC4nKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0aGlzLnNob3VsZFByb2Nlc3NGaWxlKGZpbGUpKSByZXR1cm47XG5cdFx0XHRcdGNvbnNvbGUubG9nKGBGaWxlIG1vZGlmaWVkOiAke2ZpbGUucGF0aH1gKTtcblx0XHRcdFx0Ly8gRW5oYW5jZWQgZGVib3VuY2luZyBpcyBoYW5kbGVkIGluIEZpbGVUcmFja2VyLmhhbmRsZU1vZGlmeVxuXHRcdFx0XHRhd2FpdCB0aGlzLmZpbGVUcmFja2VyPy5oYW5kbGVNb2RpZnkoZmlsZSk7XG5cdFx0XHRcdGF3YWl0IHRoaXMucXVldWVGaWxlUHJvY2Vzc2luZyhmaWxlLCAnVVBEQVRFJyk7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQoXG5cdFx0XHR0aGlzLmFwcC52YXVsdC5vbignZGVsZXRlJywgYXN5bmMgKGZpbGUpID0+IHtcblx0XHRcdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkgcmV0dXJuO1xuXHRcdFx0XHRpZiAoZmlsZS5wYXRoID09PSB0aGlzLnNldHRpbmdzLnN5bmMuc3luY0ZpbGVQYXRoKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ1N5bmMgZmlsZSB3YXMgZGVsZXRlZCwgd2lsbCByZWNyZWF0ZSBvbiBuZXh0IG9wZXJhdGlvbicpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIShhd2FpdCB0aGlzLmVuc3VyZVN5bmNGaWxlRXhpc3RzKCkpKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnRmFpbGVkIHRvIGNyZWF0ZSBzeW5jIGZpbGUuIFBsdWdpbiBmdW5jdGlvbmFsaXR5IGxpbWl0ZWQuJyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5zaG91bGRQcm9jZXNzRmlsZShmaWxlKSkgcmV0dXJuO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhgRmlsZSBkZWxldGVkOiAke2ZpbGUucGF0aH1gKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5maWxlVHJhY2tlcj8uaGFuZGxlRGVsZXRlKGZpbGUpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnF1ZXVlRmlsZVByb2Nlc3NpbmcoZmlsZSwgJ0RFTEVURScpO1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50KFxuXHRcdFx0dGhpcy5hcHAudmF1bHQub24oJ3JlbmFtZScsIGFzeW5jIChmaWxlLCBvbGRQYXRoKSA9PiB7XG5cdFx0XHRcdGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHJldHVybjtcblx0XHRcdFx0aWYgKCEoYXdhaXQgdGhpcy5lbnN1cmVTeW5jRmlsZUV4aXN0cygpKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0ZhaWxlZCB0byBjcmVhdGUgc3luYyBmaWxlLiBQbHVnaW4gZnVuY3Rpb25hbGl0eSBsaW1pdGVkLicpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRoaXMuc2hvdWxkUHJvY2Vzc0ZpbGUoZmlsZSkpIHJldHVybjtcblx0XHRcdFx0Y29uc29sZS5sb2coYEZpbGUgcmVuYW1lZCBmcm9tICR7b2xkUGF0aH0gdG8gJHtmaWxlLnBhdGh9YCk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuZmlsZVRyYWNrZXI/LmhhbmRsZVJlbmFtZShmaWxlLCBvbGRQYXRoKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5oYW5kbGVGaWxlUmVuYW1lKGZpbGUsIG9sZFBhdGgpO1xuXHRcdFx0fSlcblx0XHQpO1xuXHR9XG5cblx0cHJpdmF0ZSBzaG91bGRQcm9jZXNzRmlsZShmaWxlOiBURmlsZSk6IGJvb2xlYW4ge1xuXHRcdGlmICghdGhpcy5xdWV1ZVNlcnZpY2UgfHwgIWlzVmF1bHRJbml0aWFsaXplZCh0aGlzLnNldHRpbmdzKSkgcmV0dXJuIGZhbHNlO1xuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5lbmFibGVBdXRvU3luYykgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Y29uc3QgYWxsRXhjbHVzaW9ucyA9IGdldEFsbEV4Y2x1c2lvbnModGhpcy5zZXR0aW5ncyk7XG5cdFx0Y29uc3QgZmlsZVBhdGggPSBmaWxlLnBhdGg7XG5cdFx0Y29uc3QgZmlsZU5hbWUgPSBmaWxlLm5hbWU7XG5cblx0XHRpZiAoZmlsZVBhdGggPT09IHRoaXMuc2V0dGluZ3Muc3luYy5zeW5jRmlsZVBhdGggfHwgZmlsZVBhdGggPT09IHRoaXMuc2V0dGluZ3Muc3luYy5zeW5jRmlsZVBhdGggKyAnLmJhY2t1cCcpIHtcblx0XHRcdGNvbnNvbGUubG9nKGBTa2lwcGluZyBzeW5jIGZpbGU6ICR7ZmlsZVBhdGh9YCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmIChBcnJheS5pc0FycmF5KGFsbEV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlcykgJiYgYWxsRXhjbHVzaW9ucy5leGNsdWRlZEZpbGVzLmluY2x1ZGVzKGZpbGVOYW1lKSkge1xuXHRcdFx0Y29uc29sZS5sb2coJ1NraXBwaW5nIGV4Y2x1ZGVkIGZpbGU6JywgZmlsZU5hbWUpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoQXJyYXkuaXNBcnJheShhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRm9sZGVycykpIHtcblx0XHRcdGNvbnN0IGlzRXhjbHVkZWRGb2xkZXIgPSBhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRm9sZGVycy5zb21lKGZvbGRlciA9PiB7XG5cdFx0XHRcdGNvbnN0IG5vcm1hbGl6ZWRGb2xkZXIgPSBmb2xkZXIuZW5kc1dpdGgoJy8nKSA/IGZvbGRlciA6IGZvbGRlciArICcvJztcblx0XHRcdFx0cmV0dXJuIGZpbGVQYXRoLnN0YXJ0c1dpdGgobm9ybWFsaXplZEZvbGRlcik7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChpc0V4Y2x1ZGVkRm9sZGVyKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdTa2lwcGluZyBmaWxlIGluIGV4Y2x1ZGVkIGZvbGRlcjonLCBmaWxlUGF0aCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoYWxsRXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcykpIHtcblx0XHRcdGNvbnN0IGlzRXhjbHVkZWRUeXBlID0gYWxsRXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcy5zb21lKGV4dCA9PiBmaWxlUGF0aC50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dC50b0xvd2VyQ2FzZSgpKSk7XG5cdFx0XHRpZiAoaXNFeGNsdWRlZFR5cGUpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ1NraXBwaW5nIGV4Y2x1ZGVkIGZpbGUgdHlwZTonLCBmaWxlUGF0aCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoYWxsRXhjbHVzaW9ucy5leGNsdWRlZEZpbGVQcmVmaXhlcykpIHtcblx0XHRcdGNvbnN0IGlzRXhjbHVkZWRQcmVmaXggPSBhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVByZWZpeGVzLnNvbWUocHJlZml4ID0+IGZpbGVOYW1lLnN0YXJ0c1dpdGgocHJlZml4KSk7XG5cdFx0XHRpZiAoaXNFeGNsdWRlZFByZWZpeCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnU2tpcHBpbmcgZmlsZSB3aXRoIGV4Y2x1ZGVkIHByZWZpeDonLCBmaWxlTmFtZSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGVuc3VyZVN5bmNGaWxlRXhpc3RzKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdGlmICghdGhpcy5zeW5jTWFuYWdlcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignU3luYyBtYW5hZ2VyIG5vdCBpbml0aWFsaXplZCcpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0Y29uc3Qgc3luY0ZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5zZXR0aW5ncy5zeW5jLnN5bmNGaWxlUGF0aCk7XG5cdFx0XHRpZiAoIXN5bmNGaWxlKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdTeW5jIGZpbGUgbWlzc2luZywgcmVjcmVhdGluZy4uLicpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLmluaXRpYWxpemUoKTtcblx0XHRcdFx0bmV3IE5vdGljZSgnUmVjcmVhdGVkIHN5bmMgZmlsZScpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBlbnN1cmluZyBzeW5jIGZpbGUgZXhpc3RzOicsIGVycm9yKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIHF1ZXVlRmlsZVByb2Nlc3NpbmcoZmlsZTogVEZpbGUsIHR5cGU6ICdDUkVBVEUnIHwgJ1VQREFURScgfCAnREVMRVRFJyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXRoaXMucXVldWVTZXJ2aWNlIHx8ICF0aGlzLmZpbGVUcmFja2VyKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1JlcXVpcmVkIHNlcnZpY2VzIG5vdCBpbml0aWFsaXplZDonLCB7IHF1ZXVlU2VydmljZTogISF0aGlzLnF1ZXVlU2VydmljZSwgZmlsZVRyYWNrZXI6ICEhdGhpcy5maWxlVHJhY2tlciB9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5sb2coJ1F1ZXVlaW5nIGZpbGUgcHJvY2Vzc2luZzonLCB7IGZpbGVOYW1lOiBmaWxlLm5hbWUsIHR5cGUsIHBhdGg6IGZpbGUucGF0aCB9KTtcblx0XHRcdGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5maWxlVHJhY2tlci5jcmVhdGVGaWxlTWV0YWRhdGEoZmlsZSk7XG5cdFx0XHRjb25zb2xlLmxvZygnQ3JlYXRlZCBtZXRhZGF0YTonLCBtZXRhZGF0YSk7XG5cdFx0XHRjb25zdCB0YXNrID0ge1xuXHRcdFx0XHRpZDogZmlsZS5wYXRoLFxuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRwcmlvcml0eTogdHlwZSA9PT0gJ0RFTEVURScgPyAyIDogMSxcblx0XHRcdFx0bWF4UmV0cmllczogdGhpcy5zZXR0aW5ncy5xdWV1ZS5yZXRyeUF0dGVtcHRzLFxuXHRcdFx0XHRyZXRyeUNvdW50OiAwLFxuXHRcdFx0XHRjcmVhdGVkQXQ6IERhdGUubm93KCksXG5cdFx0XHRcdHVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcblx0XHRcdFx0c3RhdHVzOiAnUEVORElORycsXG5cdFx0XHRcdG1ldGFkYXRhLFxuXHRcdFx0XHRkYXRhOiB7fVxuXHRcdFx0fTtcblx0XHRcdGNvbnNvbGUubG9nKCdDcmVhdGVkIHRhc2s6JywgdGFzayk7XG5cdFx0XHRhd2FpdCB0aGlzLnF1ZXVlU2VydmljZS5hZGRUYXNrKHRhc2spO1xuXHRcdFx0Y29uc29sZS5sb2coJ1Rhc2sgYWRkZWQgdG8gcXVldWUnKTtcblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMpIHtcblx0XHRcdFx0Y29uc3QgYWN0aW9uID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRuZXcgTm90aWNlKGBRdWV1ZWQgJHthY3Rpb259IGZvciBwcm9jZXNzaW5nOiAke2ZpbGUubmFtZX1gKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgaW4gcXVldWVGaWxlUHJvY2Vzc2luZzonLCBlcnJvcik7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlcj8uaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ3F1ZXVlRmlsZVByb2Nlc3NpbmcnLCBtZXRhZGF0YTogeyBmaWxlUGF0aDogZmlsZS5wYXRoLCB0eXBlIH0gfSk7XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byBxdWV1ZSAke2ZpbGUubmFtZX0gZm9yIHByb2Nlc3NpbmdgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGhhbmRsZUZpbGVSZW5hbWUoZmlsZTogVEZpbGUsIG9sZFBhdGg6IHN0cmluZykge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXRoaXMuc3VwYWJhc2VTZXJ2aWNlKSByZXR1cm47XG5cdFx0XHQvLyBGaXJzdCB1cGRhdGUgdGhlIGZpbGUgc3RhdHVzIHJlY29yZCB0byB1c2UgdGhlIG5ldyBwYXRoLlxuXHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UudXBkYXRlRmlsZVBhdGgob2xkUGF0aCwgZmlsZS5wYXRoKTtcblxuXHRcdFx0Ly8gVGhlbiwgaWYgdGhlcmUgYXJlIGRvY3VtZW50IGNodW5rcyBmb3IgdGhlIG9sZCBwYXRoLCB1cGRhdGUgdGhlbSBhcyB3ZWxsLlxuXHRcdFx0Y29uc3QgY2h1bmtzID0gYXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UuZ2V0RG9jdW1lbnRDaHVua3Mob2xkUGF0aCk7XG5cdFx0XHRpZiAoY2h1bmtzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc3QgdXBkYXRlZENodW5rcyA9IGNodW5rcy5tYXAoY2h1bmsgPT4gKHtcblx0XHRcdFx0XHQuLi5jaHVuayxcblx0XHRcdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHRcdFx0Li4uY2h1bmsubWV0YWRhdGEsXG5cdFx0XHRcdFx0XHRvYnNpZGlhbklkOiBmaWxlLnBhdGgsXG5cdFx0XHRcdFx0XHRwYXRoOiBmaWxlLnBhdGhcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UuZGVsZXRlRG9jdW1lbnRDaHVua3Mob2xkUGF0aCk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLnVwc2VydENodW5rcyh1cGRhdGVkQ2h1bmtzKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMpIHtcblx0XHRcdFx0bmV3IE5vdGljZShgVXBkYXRlZCBkYXRhYmFzZSBlbnRyaWVzIGZvciByZW5hbWVkIGZpbGU6ICR7ZmlsZS5uYW1lfWApO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlcj8uaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ2hhbmRsZUZpbGVSZW5hbWUnLCBtZXRhZGF0YTogeyBmaWxlUGF0aDogZmlsZS5wYXRoLCBvbGRQYXRoIH0gfSk7XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byB1cGRhdGUgZGF0YWJhc2UgZm9yIHJlbmFtZWQgZmlsZTogJHtmaWxlLm5hbWV9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhZGRDb21tYW5kcygpIHtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6ICdmb3JjZS1zeW5jLWN1cnJlbnQtZmlsZScsXG5cdFx0XHRuYW1lOiAnRm9yY2Ugc3luYyBjdXJyZW50IGZpbGUnLFxuXHRcdFx0Y2hlY2tDYWxsYmFjazogKGNoZWNraW5nOiBib29sZWFuKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuXHRcdFx0XHRpZiAoZmlsZSkge1xuXHRcdFx0XHRcdGlmICghY2hlY2tpbmcpIHtcblx0XHRcdFx0XHRcdHRoaXMucXVldWVGaWxlUHJvY2Vzc2luZyhmaWxlLCAnVVBEQVRFJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ2ZvcmNlLXN5bmMtYWxsLWZpbGVzJyxcblx0XHRcdG5hbWU6ICdGb3JjZSBzeW5jIGFsbCBmaWxlcycsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBmaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcblx0XHRcdFx0Zm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuc2hvdWxkUHJvY2Vzc0ZpbGUoZmlsZSkpIHtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucXVldWVGaWxlUHJvY2Vzc2luZyhmaWxlLCAnVVBEQVRFJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6ICdjbGVhci1zeW5jLXF1ZXVlJyxcblx0XHRcdG5hbWU6ICdDbGVhciBzeW5jIHF1ZXVlJyxcblx0XHRcdGNhbGxiYWNrOiAoKSA9PiB7XG5cdFx0XHRcdHRoaXMucXVldWVTZXJ2aWNlPy5jbGVhcigpO1xuXHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnU3luYyBxdWV1ZSBjbGVhcmVkJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ3Jlc2V0LWZpbGUtdHJhY2tlcicsXG5cdFx0XHRuYW1lOiAnUmVzZXQgZmlsZSB0cmFja2VyIGNhY2hlJyxcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdHRoaXMuZmlsZVRyYWNrZXI/LmNsZWFyUXVldWUoKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5maWxlVHJhY2tlcj8uaW5pdGlhbGl6ZSgpO1xuXHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnRmlsZSB0cmFja2VyIGNhY2hlIHJlc2V0Jyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ3N0YXJ0LWluaXRpYWwtc3luYycsXG5cdFx0XHRuYW1lOiAnU3RhcnQgaW5pdGlhbCB2YXVsdCBzeW5jJyxcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGlmICh0aGlzLmluaXRpYWxTeW5jTWFuYWdlcikge1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMuaW5pdGlhbFN5bmNNYW5hZ2VyLnN0YXJ0U3luYygpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0luaXRpYWwgc3luYyBtYW5hZ2VyIG5vdCBpbml0aWFsaXplZCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6ICdzdG9wLWluaXRpYWwtc3luYycsXG5cdFx0XHRuYW1lOiAnU3RvcCBpbml0aWFsIHZhdWx0IHN5bmMnLFxuXHRcdFx0Y2FsbGJhY2s6ICgpID0+IHtcblx0XHRcdFx0dGhpcy5pbml0aWFsU3luY01hbmFnZXI/LnN0b3AoKTtcblx0XHRcdFx0bmV3IE5vdGljZSgnSW5pdGlhbCBzeW5jIHN0b3BwZWQnKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufVxuIiwgImltcG9ydCB7IEZldGNoIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaD86IEZldGNoKTogRmV0Y2ggPT4ge1xuICBsZXQgX2ZldGNoOiBGZXRjaFxuICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaFxuICB9IGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT5cbiAgICAgIGltcG9ydCgnQHN1cGFiYXNlL25vZGUtZmV0Y2gnIGFzIGFueSkudGhlbigoeyBkZWZhdWx0OiBmZXRjaCB9KSA9PiBmZXRjaCguLi5hcmdzKSlcbiAgfSBlbHNlIHtcbiAgICBfZmV0Y2ggPSBmZXRjaFxuICB9XG4gIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpXG59XG4iLCAiZXhwb3J0IHR5cGUgRmV0Y2ggPSB0eXBlb2YgZmV0Y2hcblxuLyoqXG4gKiBSZXNwb25zZSBmb3JtYXRcbiAqXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25zUmVzcG9uc2VTdWNjZXNzPFQ+IHtcbiAgZGF0YTogVFxuICBlcnJvcjogbnVsbFxufVxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbnNSZXNwb25zZUZhaWx1cmUge1xuICBkYXRhOiBudWxsXG4gIGVycm9yOiBhbnlcbn1cbmV4cG9ydCB0eXBlIEZ1bmN0aW9uc1Jlc3BvbnNlPFQ+ID0gRnVuY3Rpb25zUmVzcG9uc2VTdWNjZXNzPFQ+IHwgRnVuY3Rpb25zUmVzcG9uc2VGYWlsdXJlXG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29udGV4dDogYW55XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgbmFtZSA9ICdGdW5jdGlvbnNFcnJvcicsIGNvbnRleHQ/OiBhbnkpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0ZldGNoRXJyb3IgZXh0ZW5kcyBGdW5jdGlvbnNFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IGFueSkge1xuICAgIHN1cGVyKCdGYWlsZWQgdG8gc2VuZCBhIHJlcXVlc3QgdG8gdGhlIEVkZ2UgRnVuY3Rpb24nLCAnRnVuY3Rpb25zRmV0Y2hFcnJvcicsIGNvbnRleHQpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc1JlbGF5RXJyb3IgZXh0ZW5kcyBGdW5jdGlvbnNFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IGFueSkge1xuICAgIHN1cGVyKCdSZWxheSBFcnJvciBpbnZva2luZyB0aGUgRWRnZSBGdW5jdGlvbicsICdGdW5jdGlvbnNSZWxheUVycm9yJywgY29udGV4dClcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zSHR0cEVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0OiBhbnkpIHtcbiAgICBzdXBlcignRWRnZSBGdW5jdGlvbiByZXR1cm5lZCBhIG5vbi0yeHggc3RhdHVzIGNvZGUnLCAnRnVuY3Rpb25zSHR0cEVycm9yJywgY29udGV4dClcbiAgfVxufVxuLy8gRGVmaW5lIHRoZSBlbnVtIGZvciB0aGUgJ3JlZ2lvbicgcHJvcGVydHlcbmV4cG9ydCBlbnVtIEZ1bmN0aW9uUmVnaW9uIHtcbiAgQW55ID0gJ2FueScsXG4gIEFwTm9ydGhlYXN0MSA9ICdhcC1ub3J0aGVhc3QtMScsXG4gIEFwTm9ydGhlYXN0MiA9ICdhcC1ub3J0aGVhc3QtMicsXG4gIEFwU291dGgxID0gJ2FwLXNvdXRoLTEnLFxuICBBcFNvdXRoZWFzdDEgPSAnYXAtc291dGhlYXN0LTEnLFxuICBBcFNvdXRoZWFzdDIgPSAnYXAtc291dGhlYXN0LTInLFxuICBDYUNlbnRyYWwxID0gJ2NhLWNlbnRyYWwtMScsXG4gIEV1Q2VudHJhbDEgPSAnZXUtY2VudHJhbC0xJyxcbiAgRXVXZXN0MSA9ICdldS13ZXN0LTEnLFxuICBFdVdlc3QyID0gJ2V1LXdlc3QtMicsXG4gIEV1V2VzdDMgPSAnZXUtd2VzdC0zJyxcbiAgU2FFYXN0MSA9ICdzYS1lYXN0LTEnLFxuICBVc0Vhc3QxID0gJ3VzLWVhc3QtMScsXG4gIFVzV2VzdDEgPSAndXMtd2VzdC0xJyxcbiAgVXNXZXN0MiA9ICd1cy13ZXN0LTInLFxufVxuXG5leHBvcnQgdHlwZSBGdW5jdGlvbkludm9rZU9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBoZWFkZXJzIHRvIHNlbmQgd2l0aCB0aGUgcmVxdWVzdC5cbiAgICogKi9cbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgLyoqXG4gICAqIFRoZSBIVFRQIHZlcmIgb2YgdGhlIHJlcXVlc3RcbiAgICovXG4gIG1ldGhvZD86ICdQT1NUJyB8ICdHRVQnIHwgJ1BVVCcgfCAnUEFUQ0gnIHwgJ0RFTEVURSdcbiAgLyoqXG4gICAqIFRoZSBSZWdpb24gdG8gaW52b2tlIHRoZSBmdW5jdGlvbiBpbi5cbiAgICovXG4gIHJlZ2lvbj86IEZ1bmN0aW9uUmVnaW9uXG4gIC8qKlxuICAgKiBUaGUgYm9keSBvZiB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGJvZHk/OlxuICAgIHwgRmlsZVxuICAgIHwgQmxvYlxuICAgIHwgQXJyYXlCdWZmZXJcbiAgICB8IEZvcm1EYXRhXG4gICAgfCBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxuICAgIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHwgc3RyaW5nXG59XG4iLCAiaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi9oZWxwZXInXG5pbXBvcnQge1xuICBGZXRjaCxcbiAgRnVuY3Rpb25zRmV0Y2hFcnJvcixcbiAgRnVuY3Rpb25zSHR0cEVycm9yLFxuICBGdW5jdGlvbnNSZWxheUVycm9yLFxuICBGdW5jdGlvbnNSZXNwb25zZSxcbiAgRnVuY3Rpb25JbnZva2VPcHRpb25zLFxuICBGdW5jdGlvblJlZ2lvbixcbn0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0NsaWVudCB7XG4gIHByb3RlY3RlZCB1cmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBwcm90ZWN0ZWQgcmVnaW9uOiBGdW5jdGlvblJlZ2lvblxuICBwcm90ZWN0ZWQgZmV0Y2g6IEZldGNoXG5cbiAgY29uc3RydWN0b3IoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAge1xuICAgICAgaGVhZGVycyA9IHt9LFxuICAgICAgY3VzdG9tRmV0Y2gsXG4gICAgICByZWdpb24gPSBGdW5jdGlvblJlZ2lvbi5BbnksXG4gICAgfToge1xuICAgICAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICAgIGN1c3RvbUZldGNoPzogRmV0Y2hcbiAgICAgIHJlZ2lvbj86IEZ1bmN0aW9uUmVnaW9uXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHRoaXMudXJsID0gdXJsXG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVyc1xuICAgIHRoaXMucmVnaW9uID0gcmVnaW9uXG4gICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChjdXN0b21GZXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBhdXRob3JpemF0aW9uIGhlYWRlclxuICAgKiBAcGFyYW0gdG9rZW4gLSB0aGUgbmV3IGp3dCB0b2tlbiBzZW50IGluIHRoZSBhdXRob3Jpc2F0aW9uIGhlYWRlclxuICAgKi9cbiAgc2V0QXV0aCh0b2tlbjogc3RyaW5nKSB7XG4gICAgdGhpcy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dG9rZW59YFxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZXMgYSBmdW5jdGlvblxuICAgKiBAcGFyYW0gZnVuY3Rpb25OYW1lIC0gVGhlIG5hbWUgb2YgdGhlIEZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBpbnZva2luZyB0aGUgRnVuY3Rpb24uXG4gICAqL1xuICBhc3luYyBpbnZva2U8VCA9IGFueT4oXG4gICAgZnVuY3Rpb25OYW1lOiBzdHJpbmcsXG4gICAgb3B0aW9uczogRnVuY3Rpb25JbnZva2VPcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTxGdW5jdGlvbnNSZXNwb25zZTxUPj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGhlYWRlcnMsIG1ldGhvZCwgYm9keTogZnVuY3Rpb25BcmdzIH0gPSBvcHRpb25zXG4gICAgICBsZXQgX2hlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICAgICAgbGV0IHsgcmVnaW9uIH0gPSBvcHRpb25zXG4gICAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgICByZWdpb24gPSB0aGlzLnJlZ2lvblxuICAgICAgfVxuICAgICAgaWYgKHJlZ2lvbiAmJiByZWdpb24gIT09ICdhbnknKSB7XG4gICAgICAgIF9oZWFkZXJzWyd4LXJlZ2lvbiddID0gcmVnaW9uXG4gICAgICB9XG4gICAgICBsZXQgYm9keTogYW55XG4gICAgICBpZiAoXG4gICAgICAgIGZ1bmN0aW9uQXJncyAmJlxuICAgICAgICAoKGhlYWRlcnMgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoZWFkZXJzLCAnQ29udGVudC1UeXBlJykpIHx8ICFoZWFkZXJzKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICAgZnVuY3Rpb25BcmdzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gd2lsbCB3b3JrIGZvciBGaWxlIGFzIEZpbGUgaW5oZXJpdHMgQmxvYlxuICAgICAgICAgIC8vIGFsc28gd29ya3MgZm9yIEFycmF5QnVmZmVyIGFzIGl0IGlzIHRoZSBzYW1lIHVuZGVybHlpbmcgc3RydWN0dXJlIGFzIGEgQmxvYlxuICAgICAgICAgIF9oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJnc1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jdGlvbkFyZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gcGxhaW4gc3RyaW5nXG4gICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ3RleHQvcGxhaW4nXG4gICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJnc1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgZnVuY3Rpb25BcmdzIGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgICAvLyBkb24ndCBzZXQgY29udGVudC10eXBlIGhlYWRlcnNcbiAgICAgICAgICAvLyBSZXF1ZXN0IHdpbGwgYXV0b21hdGljYWxseSBhZGQgdGhlIHJpZ2h0IGJvdW5kYXJ5IHZhbHVlXG4gICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJnc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRlZmF1bHQsIGFzc3VtZSB0aGlzIGlzIEpTT05cbiAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZnVuY3Rpb25BcmdzKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaChgJHt0aGlzLnVybH0vJHtmdW5jdGlvbk5hbWV9YCwge1xuICAgICAgICBtZXRob2Q6IG1ldGhvZCB8fCAnUE9TVCcsXG4gICAgICAgIC8vIGhlYWRlcnMgcHJpb3JpdHkgaXMgKGhpZ2ggdG8gbG93KTpcbiAgICAgICAgLy8gMS4gaW52b2tlLWxldmVsIGhlYWRlcnNcbiAgICAgICAgLy8gMi4gY2xpZW50LWxldmVsIGhlYWRlcnNcbiAgICAgICAgLy8gMy4gZGVmYXVsdCBDb250ZW50LVR5cGUgaGVhZGVyXG4gICAgICAgIGhlYWRlcnM6IHsgLi4uX2hlYWRlcnMsIC4uLnRoaXMuaGVhZGVycywgLi4uaGVhZGVycyB9LFxuICAgICAgICBib2R5LFxuICAgICAgfSkuY2F0Y2goKGZldGNoRXJyb3IpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc0ZldGNoRXJyb3IoZmV0Y2hFcnJvcilcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGlzUmVsYXlFcnJvciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXJlbGF5LWVycm9yJylcbiAgICAgIGlmIChpc1JlbGF5RXJyb3IgJiYgaXNSZWxheUVycm9yID09PSAndHJ1ZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc1JlbGF5RXJyb3IocmVzcG9uc2UpXG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc0h0dHBFcnJvcihyZXNwb25zZSlcbiAgICAgIH1cblxuICAgICAgbGV0IHJlc3BvbnNlVHlwZSA9IChyZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgPz8gJ3RleHQvcGxhaW4nKS5zcGxpdCgnOycpWzBdLnRyaW0oKVxuICAgICAgbGV0IGRhdGE6IGFueVxuICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpXG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQvZXZlbnQtc3RyZWFtJykge1xuICAgICAgICBkYXRhID0gcmVzcG9uc2VcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpIHtcbiAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmZvcm1EYXRhKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQgdG8gdGV4dFxuICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCBpbmRleCBmcm9tICcuLi9janMvaW5kZXguanMnXG5jb25zdCB7XG4gIFBvc3RncmVzdENsaWVudCxcbiAgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxuICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLFxuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RFcnJvcixcbn0gPSBpbmRleFxuXG5leHBvcnQge1xuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbiAgUG9zdGdyZXN0RXJyb3IsXG59XG5cbi8vIGNvbXBhdGliaWxpdHkgd2l0aCBDSlMgb3V0cHV0XG5leHBvcnQgZGVmYXVsdCB7XG4gIFBvc3RncmVzdENsaWVudCxcbiAgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxuICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLFxuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RFcnJvcixcbn1cbiIsICJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjExLjInXG4iLCAiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbidcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfSEVBREVSUyA9IHsgJ1gtQ2xpZW50LUluZm8nOiBgcmVhbHRpbWUtanMvJHt2ZXJzaW9ufWAgfVxuXG5leHBvcnQgY29uc3QgVlNOOiBzdHJpbmcgPSAnMS4wLjAnXG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1RJTUVPVVQgPSAxMDAwMFxuXG5leHBvcnQgY29uc3QgV1NfQ0xPU0VfTk9STUFMID0gMTAwMFxuXG5leHBvcnQgZW51bSBTT0NLRVRfU1RBVEVTIHtcbiAgY29ubmVjdGluZyA9IDAsXG4gIG9wZW4gPSAxLFxuICBjbG9zaW5nID0gMixcbiAgY2xvc2VkID0gMyxcbn1cblxuZXhwb3J0IGVudW0gQ0hBTk5FTF9TVEFURVMge1xuICBjbG9zZWQgPSAnY2xvc2VkJyxcbiAgZXJyb3JlZCA9ICdlcnJvcmVkJyxcbiAgam9pbmVkID0gJ2pvaW5lZCcsXG4gIGpvaW5pbmcgPSAnam9pbmluZycsXG4gIGxlYXZpbmcgPSAnbGVhdmluZycsXG59XG5cbmV4cG9ydCBlbnVtIENIQU5ORUxfRVZFTlRTIHtcbiAgY2xvc2UgPSAncGh4X2Nsb3NlJyxcbiAgZXJyb3IgPSAncGh4X2Vycm9yJyxcbiAgam9pbiA9ICdwaHhfam9pbicsXG4gIHJlcGx5ID0gJ3BoeF9yZXBseScsXG4gIGxlYXZlID0gJ3BoeF9sZWF2ZScsXG4gIGFjY2Vzc190b2tlbiA9ICdhY2Nlc3NfdG9rZW4nLFxufVxuXG5leHBvcnQgZW51bSBUUkFOU1BPUlRTIHtcbiAgd2Vic29ja2V0ID0gJ3dlYnNvY2tldCcsXG59XG5cbmV4cG9ydCBlbnVtIENPTk5FQ1RJT05fU1RBVEUge1xuICBDb25uZWN0aW5nID0gJ2Nvbm5lY3RpbmcnLFxuICBPcGVuID0gJ29wZW4nLFxuICBDbG9zaW5nID0gJ2Nsb3NpbmcnLFxuICBDbG9zZWQgPSAnY2xvc2VkJyxcbn1cbiIsICIvLyBUaGlzIGZpbGUgZHJhd3MgaGVhdmlseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvY29tbWl0L2NmMDk4ZTljZjdhNDRlZTY0NzlkMzFkOTExYTk3ZDNjNzQzMGM2ZmVcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXJpYWxpemVyIHtcbiAgSEVBREVSX0xFTkdUSCA9IDFcblxuICBkZWNvZGUocmF3UGF5bG9hZDogQXJyYXlCdWZmZXIgfCBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIGlmIChyYXdQYXlsb2FkLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2JpbmFyeURlY29kZShyYXdQYXlsb2FkKSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJhd1BheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5wYXJzZShyYXdQYXlsb2FkKSlcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbGJhY2soe30pXG4gIH1cblxuICBwcml2YXRlIF9iaW5hcnlEZWNvZGUoYnVmZmVyOiBBcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKVxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpXG4gIH1cblxuICBwcml2YXRlIF9kZWNvZGVCcm9hZGNhc3QoXG4gICAgYnVmZmVyOiBBcnJheUJ1ZmZlcixcbiAgICB2aWV3OiBEYXRhVmlldyxcbiAgICBkZWNvZGVyOiBUZXh0RGVjb2RlclxuICApOiB7XG4gICAgcmVmOiBudWxsXG4gICAgdG9waWM6IHN0cmluZ1xuICAgIGV2ZW50OiBzdHJpbmdcbiAgICBwYXlsb2FkOiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIH0ge1xuICAgIGNvbnN0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBjb25zdCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDIpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIDJcbiAgICBjb25zdCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgY29uc3QgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZVxuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKFxuICAgICAgZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpKVxuICAgIClcblxuICAgIHJldHVybiB7IHJlZjogbnVsbCwgdG9waWM6IHRvcGljLCBldmVudDogZXZlbnQsIHBheWxvYWQ6IGRhdGEgfVxuICB9XG59XG4iLCAiLyoqXG4gKiBDcmVhdGVzIGEgdGltZXIgdGhhdCBhY2NlcHRzIGEgYHRpbWVyQ2FsY2AgZnVuY3Rpb24gdG8gcGVyZm9ybSBjYWxjdWxhdGVkIHRpbWVvdXQgcmV0cmllcywgc3VjaCBhcyBleHBvbmVudGlhbCBiYWNrb2ZmLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICBsZXQgcmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoKCkgPT4gdGhpcy5jb25uZWN0KCksIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgICAgcmV0dXJuIFsxMDAwLCA1MDAwLCAxMDAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICogICAgfSlcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDUwMDBcbiAqICAgIHJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZXIge1xuICB0aW1lcjogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gIHRyaWVzOiBudW1iZXIgPSAwXG5cbiAgY29uc3RydWN0b3IocHVibGljIGNhbGxiYWNrOiBGdW5jdGlvbiwgcHVibGljIHRpbWVyQ2FsYzogRnVuY3Rpb24pIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsY1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy50cmllcyA9IDBcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcilcbiAgfVxuXG4gIC8vIENhbmNlbHMgYW55IHByZXZpb3VzIHNjaGVkdWxlVGltZW91dCBhbmQgc2NoZWR1bGVzIGNhbGxiYWNrXG4gIHNjaGVkdWxlVGltZW91dCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcilcblxuICAgIHRoaXMudGltZXIgPSA8YW55PnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmllcyA9IHRoaXMudHJpZXMgKyAxXG4gICAgICB0aGlzLmNhbGxiYWNrKClcbiAgICB9LCB0aGlzLnRpbWVyQ2FsYyh0aGlzLnRyaWVzICsgMSkpXG4gIH1cbn1cbiIsICIvKipcbiAqIEhlbHBlcnMgdG8gY29udmVydCB0aGUgY2hhbmdlIFBheWxvYWQgaW50byBuYXRpdmUgSlMgdHlwZXMuXG4gKi9cblxuLy8gQWRhcHRlZCBmcm9tIGVwZ3NxbCAoc3JjL2VwZ3NxbF9iaW5hcnkuZXJsKSwgdGhpcyBtb2R1bGUgbGljZW5zZWQgdW5kZXJcbi8vIDMtY2xhdXNlIEJTRCBmb3VuZCBoZXJlOiBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZXBnc3FsL2VwZ3NxbC9kZXZlbC9MSUNFTlNFXG5cbmV4cG9ydCBlbnVtIFBvc3RncmVzVHlwZXMge1xuICBhYnN0aW1lID0gJ2Fic3RpbWUnLFxuICBib29sID0gJ2Jvb2wnLFxuICBkYXRlID0gJ2RhdGUnLFxuICBkYXRlcmFuZ2UgPSAnZGF0ZXJhbmdlJyxcbiAgZmxvYXQ0ID0gJ2Zsb2F0NCcsXG4gIGZsb2F0OCA9ICdmbG9hdDgnLFxuICBpbnQyID0gJ2ludDInLFxuICBpbnQ0ID0gJ2ludDQnLFxuICBpbnQ0cmFuZ2UgPSAnaW50NHJhbmdlJyxcbiAgaW50OCA9ICdpbnQ4JyxcbiAgaW50OHJhbmdlID0gJ2ludDhyYW5nZScsXG4gIGpzb24gPSAnanNvbicsXG4gIGpzb25iID0gJ2pzb25iJyxcbiAgbW9uZXkgPSAnbW9uZXknLFxuICBudW1lcmljID0gJ251bWVyaWMnLFxuICBvaWQgPSAnb2lkJyxcbiAgcmVsdGltZSA9ICdyZWx0aW1lJyxcbiAgdGV4dCA9ICd0ZXh0JyxcbiAgdGltZSA9ICd0aW1lJyxcbiAgdGltZXN0YW1wID0gJ3RpbWVzdGFtcCcsXG4gIHRpbWVzdGFtcHR6ID0gJ3RpbWVzdGFtcHR6JyxcbiAgdGltZXR6ID0gJ3RpbWV0eicsXG4gIHRzcmFuZ2UgPSAndHNyYW5nZScsXG4gIHRzdHpyYW5nZSA9ICd0c3R6cmFuZ2UnLFxufVxuXG50eXBlIENvbHVtbnMgPSB7XG4gIG5hbWU6IHN0cmluZyAvLyB0aGUgY29sdW1uIG5hbWUuIGVnOiBcInVzZXJfaWRcIlxuICB0eXBlOiBzdHJpbmcgLy8gdGhlIGNvbHVtbiB0eXBlLiBlZzogXCJ1dWlkXCJcbiAgZmxhZ3M/OiBzdHJpbmdbXSAvLyBhbnkgc3BlY2lhbCBmbGFncyBmb3IgdGhlIGNvbHVtbi4gZWc6IFtcImtleVwiXVxuICB0eXBlX21vZGlmaWVyPzogbnVtYmVyIC8vIHRoZSB0eXBlIG1vZGlmaWVyLiBlZzogNDI5NDk2NzI5NVxufVtdXG5cbnR5cGUgQmFzZVZhbHVlID0gbnVsbCB8IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW5cbnR5cGUgUmVjb3JkVmFsdWUgPSBCYXNlVmFsdWUgfCBCYXNlVmFsdWVbXVxuXG50eXBlIFJlY29yZCA9IHtcbiAgW2tleTogc3RyaW5nXTogUmVjb3JkVmFsdWVcbn1cblxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBjb2x1bW5zIGFuZCBhbiBvYmplY3Qgb2Ygc3RyaW5nIHZhbHVlcyB0aGVuIGNvbnZlcnRzIGVhY2ggc3RyaW5nIHZhbHVlXG4gKiB0byBpdHMgbWFwcGVkIHR5cGUuXG4gKlxuICogQHBhcmFtIHt7bmFtZTogU3RyaW5nLCB0eXBlOiBTdHJpbmd9W119IGNvbHVtbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBtYXAgb2YgdmFyaW91cyBvcHRpb25zIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gdGhlIG1hcHBlclxuICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5za2lwVHlwZXMgVGhlIGFycmF5IG9mIHR5cGVzIHRoYXQgc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWRcbiAqXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2hhbmdlRGF0YShbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiczMyd9LCB7fSlcbiAqIC8vPT57IGZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAzMyB9XG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0Q2hhbmdlRGF0YSA9IChcbiAgY29sdW1uczogQ29sdW1ucyxcbiAgcmVjb3JkOiBSZWNvcmQsXG4gIG9wdGlvbnM6IHsgc2tpcFR5cGVzPzogc3RyaW5nW10gfSA9IHt9XG4pOiBSZWNvcmQgPT4ge1xuICBjb25zdCBza2lwVHlwZXMgPSBvcHRpb25zLnNraXBUeXBlcyA/PyBbXVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhyZWNvcmQpLnJlZHVjZSgoYWNjLCByZWNfa2V5KSA9PiB7XG4gICAgYWNjW3JlY19rZXldID0gY29udmVydENvbHVtbihyZWNfa2V5LCBjb2x1bW5zLCByZWNvcmQsIHNraXBUeXBlcylcbiAgICByZXR1cm4gYWNjXG4gIH0sIHt9IGFzIFJlY29yZClcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgdmFsdWUgb2YgYW4gaW5kaXZpZHVhbCBjb2x1bW4uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbk5hbWUgVGhlIGNvbHVtbiB0aGF0IHlvdSB3YW50IHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB7e25hbWU6IFN0cmluZywgdHlwZTogU3RyaW5nfVtdfSBjb2x1bW5zIEFsbCBvZiB0aGUgY29sdW1uc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCBUaGUgbWFwIG9mIHN0cmluZyB2YWx1ZXNcbiAqIEBwYXJhbSB7QXJyYXl9IHNraXBUeXBlcyBBbiBhcnJheSBvZiB0eXBlcyB0aGF0IHNob3VsZCBub3QgYmUgY29udmVydGVkXG4gKiBAcmV0dXJuIHtvYmplY3R9IFVzZWxlc3MgaW5mb3JtYXRpb25cbiAqXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q29sdW1uKCdhZ2UnLCBbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAnMzMnfSwgW10pXG4gKiAvLz0+IDMzXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q29sdW1uKCdhZ2UnLCBbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAnMzMnfSwgWydpbnQ0J10pXG4gKiAvLz0+IFwiMzNcIlxuICovXG5leHBvcnQgY29uc3QgY29udmVydENvbHVtbiA9IChcbiAgY29sdW1uTmFtZTogc3RyaW5nLFxuICBjb2x1bW5zOiBDb2x1bW5zLFxuICByZWNvcmQ6IFJlY29yZCxcbiAgc2tpcFR5cGVzOiBzdHJpbmdbXVxuKTogUmVjb3JkVmFsdWUgPT4ge1xuICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zLmZpbmQoKHgpID0+IHgubmFtZSA9PT0gY29sdW1uTmFtZSlcbiAgY29uc3QgY29sVHlwZSA9IGNvbHVtbj8udHlwZVxuICBjb25zdCB2YWx1ZSA9IHJlY29yZFtjb2x1bW5OYW1lXVxuXG4gIGlmIChjb2xUeXBlICYmICFza2lwVHlwZXMuaW5jbHVkZXMoY29sVHlwZSkpIHtcbiAgICByZXR1cm4gY29udmVydENlbGwoY29sVHlwZSwgdmFsdWUpXG4gIH1cblxuICByZXR1cm4gbm9vcCh2YWx1ZSlcbn1cblxuLyoqXG4gKiBJZiB0aGUgdmFsdWUgb2YgdGhlIGNlbGwgaXMgYG51bGxgLCByZXR1cm5zIG51bGwuXG4gKiBPdGhlcndpc2UgY29udmVydHMgdGhlIHN0cmluZyB2YWx1ZSB0byB0aGUgY29ycmVjdCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBwb3N0Z3JlcyBjb2x1bW4gdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBjZWxsIHZhbHVlXG4gKlxuICogQGV4YW1wbGUgY29udmVydENlbGwoJ2Jvb2wnLCAndCcpXG4gKiAvLz0+IHRydWVcbiAqIEBleGFtcGxlIGNvbnZlcnRDZWxsKCdpbnQ4JywgJzEwJylcbiAqIC8vPT4gMTBcbiAqIEBleGFtcGxlIGNvbnZlcnRDZWxsKCdfaW50NCcsICd7MSwyLDMsNH0nKVxuICogLy89PiBbMSwyLDMsNF1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRDZWxsID0gKHR5cGU6IHN0cmluZywgdmFsdWU6IFJlY29yZFZhbHVlKTogUmVjb3JkVmFsdWUgPT4ge1xuICAvLyBpZiBkYXRhIHR5cGUgaXMgYW4gYXJyYXlcbiAgaWYgKHR5cGUuY2hhckF0KDApID09PSAnXycpIHtcbiAgICBjb25zdCBkYXRhVHlwZSA9IHR5cGUuc2xpY2UoMSwgdHlwZS5sZW5ndGgpXG4gICAgcmV0dXJuIHRvQXJyYXkodmFsdWUsIGRhdGFUeXBlKVxuICB9XG5cbiAgLy8gSWYgbm90IG51bGwsIGNvbnZlcnQgdG8gY29ycmVjdCB0eXBlLlxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuYm9vbDpcbiAgICAgIHJldHVybiB0b0Jvb2xlYW4odmFsdWUpXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmZsb2F0NDpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuZmxvYXQ4OlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQyOlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ0OlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ4OlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5udW1lcmljOlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5vaWQ6XG4gICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmpzb246XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmpzb25iOlxuICAgICAgcmV0dXJuIHRvSnNvbih2YWx1ZSlcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZXN0YW1wOlxuICAgICAgcmV0dXJuIHRvVGltZXN0YW1wU3RyaW5nKHZhbHVlKSAvLyBGb3JtYXQgdG8gYmUgY29uc2lzdGVudCB3aXRoIFBvc3RnUkVTVFxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5hYnN0aW1lOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmRhdGU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuZGF0ZXJhbmdlOlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ0cmFuZ2U6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDhyYW5nZTpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMubW9uZXk6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnJlbHRpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudGV4dDpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1lc3RhbXB0ejogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1ldHo6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudHNyYW5nZTpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudHN0enJhbmdlOlxuICAgICAgcmV0dXJuIG5vb3AodmFsdWUpXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFJldHVybiB0aGUgdmFsdWUgZm9yIHJlbWFpbmluZyB0eXBlc1xuICAgICAgcmV0dXJuIG5vb3AodmFsdWUpXG4gIH1cbn1cblxuY29uc3Qgbm9vcCA9ICh2YWx1ZTogUmVjb3JkVmFsdWUpOiBSZWNvcmRWYWx1ZSA9PiB7XG4gIHJldHVybiB2YWx1ZVxufVxuZXhwb3J0IGNvbnN0IHRvQm9vbGVhbiA9ICh2YWx1ZTogUmVjb3JkVmFsdWUpOiBSZWNvcmRWYWx1ZSA9PiB7XG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlICd0JzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgY2FzZSAnZic6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZhbHVlXG4gIH1cbn1cbmV4cG9ydCBjb25zdCB0b051bWJlciA9ICh2YWx1ZTogUmVjb3JkVmFsdWUpOiBSZWNvcmRWYWx1ZSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKVxuICAgIGlmICghTnVtYmVyLmlzTmFOKHBhcnNlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHBhcnNlZFZhbHVlXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuZXhwb3J0IGNvbnN0IHRvSnNvbiA9ICh2YWx1ZTogUmVjb3JkVmFsdWUpOiBSZWNvcmRWYWx1ZSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhgSlNPTiBwYXJzZSBlcnJvcjogJHtlcnJvcn1gKVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgUG9zdGdyZXMgQXJyYXkgaW50byBhIG5hdGl2ZSBKUyBhcnJheVxuICpcbiAqIEBleGFtcGxlIHRvQXJyYXkoJ3t9JywgJ2ludDQnKVxuICogLy89PiBbXVxuICogQGV4YW1wbGUgdG9BcnJheSgne1wiWzIwMjEtMDEtMDEsMjAyMS0xMi0zMSlcIixcIigyMDIxLTAxLTAxLDIwMjEtMTItMzJdXCJ9JywgJ2RhdGVyYW5nZScpXG4gKiAvLz0+IFsnWzIwMjEtMDEtMDEsMjAyMS0xMi0zMSknLCAnKDIwMjEtMDEtMDEsMjAyMS0xMi0zMl0nXVxuICogQGV4YW1wbGUgdG9BcnJheShbMSwyLDMsNF0sICdpbnQ0JylcbiAqIC8vPT4gWzEsMiwzLDRdXG4gKi9cbmV4cG9ydCBjb25zdCB0b0FycmF5ID0gKHZhbHVlOiBSZWNvcmRWYWx1ZSwgdHlwZTogc3RyaW5nKTogUmVjb3JkVmFsdWUgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgY29uc3QgbGFzdElkeCA9IHZhbHVlLmxlbmd0aCAtIDFcbiAgY29uc3QgY2xvc2VCcmFjZSA9IHZhbHVlW2xhc3RJZHhdXG4gIGNvbnN0IG9wZW5CcmFjZSA9IHZhbHVlWzBdXG5cbiAgLy8gQ29uZmlybSB2YWx1ZSBpcyBhIFBvc3RncmVzIGFycmF5IGJ5IGNoZWNraW5nIGN1cmx5IGJyYWNrZXRzXG4gIGlmIChvcGVuQnJhY2UgPT09ICd7JyAmJiBjbG9zZUJyYWNlID09PSAnfScpIHtcbiAgICBsZXQgYXJyXG4gICAgY29uc3QgdmFsVHJpbSA9IHZhbHVlLnNsaWNlKDEsIGxhc3RJZHgpXG5cbiAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHNvbHV0aW9uIHRvIHNlcGFyYXRlIFBvc3RncmVzIGFycmF5IGRhdGFcbiAgICB0cnkge1xuICAgICAgYXJyID0gSlNPTi5wYXJzZSgnWycgKyB2YWxUcmltICsgJ10nKVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIC8vIFdBUk5JTkc6IHNwbGl0dGluZyBvbiBjb21tYSBkb2VzIG5vdCBjb3ZlciBhbGwgZWRnZSBjYXNlc1xuICAgICAgYXJyID0gdmFsVHJpbSA/IHZhbFRyaW0uc3BsaXQoJywnKSA6IFtdXG4gICAgfVxuXG4gICAgcmV0dXJuIGFyci5tYXAoKHZhbDogQmFzZVZhbHVlKSA9PiBjb252ZXJ0Q2VsbCh0eXBlLCB2YWwpKVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogRml4ZXMgdGltZXN0YW1wIHRvIGJlIElTTy04NjAxLiBTd2FwcyB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgZGF0ZSBhbmQgdGltZSBmb3IgYSAnVCdcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2Uvc3VwYWJhc2UvaXNzdWVzLzE4XG4gKlxuICogQGV4YW1wbGUgdG9UaW1lc3RhbXBTdHJpbmcoJzIwMTktMDktMTAgMDA6MDA6MDAnKVxuICogLy89PiAnMjAxOS0wOS0xMFQwMDowMDowMCdcbiAqL1xuZXhwb3J0IGNvbnN0IHRvVGltZXN0YW1wU3RyaW5nID0gKHZhbHVlOiBSZWNvcmRWYWx1ZSk6IFJlY29yZFZhbHVlID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgnICcsICdUJylcbiAgfVxuXG4gIHJldHVybiB2YWx1ZVxufVxuXG5leHBvcnQgY29uc3QgaHR0cEVuZHBvaW50VVJMID0gKHNvY2tldFVybDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgbGV0IHVybCA9IHNvY2tldFVybFxuICB1cmwgPSB1cmwucmVwbGFjZSgvXndzL2ksICdodHRwJylcbiAgdXJsID0gdXJsLnJlcGxhY2UoLyhcXC9zb2NrZXRcXC93ZWJzb2NrZXR8XFwvc29ja2V0fFxcL3dlYnNvY2tldClcXC8/JC9pLCAnJylcbiAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXC8rJC8sICcnKVxufVxuIiwgImltcG9ydCB7IERFRkFVTFRfVElNRU9VVCB9IGZyb20gJy4uL2xpYi9jb25zdGFudHMnXG5pbXBvcnQgdHlwZSBSZWFsdGltZUNoYW5uZWwgZnJvbSAnLi4vUmVhbHRpbWVDaGFubmVsJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdXNoIHtcbiAgc2VudDogYm9vbGVhbiA9IGZhbHNlXG4gIHRpbWVvdXRUaW1lcjogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gIHJlZjogc3RyaW5nID0gJydcbiAgcmVjZWl2ZWRSZXNwOiB7XG4gICAgc3RhdHVzOiBzdHJpbmdcbiAgICByZXNwb25zZTogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICB9IHwgbnVsbCA9IG51bGxcbiAgcmVjSG9va3M6IHtcbiAgICBzdGF0dXM6IHN0cmluZ1xuICAgIGNhbGxiYWNrOiBGdW5jdGlvblxuICB9W10gPSBbXVxuICByZWZFdmVudDogc3RyaW5nIHwgbnVsbCA9IG51bGxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIFB1c2hcbiAgICpcbiAgICogQHBhcmFtIGNoYW5uZWwgVGhlIENoYW5uZWxcbiAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCwgZm9yIGV4YW1wbGUgYFwicGh4X2pvaW5cImBcbiAgICogQHBhcmFtIHBheWxvYWQgVGhlIHBheWxvYWQsIGZvciBleGFtcGxlIGB7dXNlcl9pZDogMTIzfWBcbiAgICogQHBhcmFtIHRpbWVvdXQgVGhlIHB1c2ggdGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwsXG4gICAgcHVibGljIGV2ZW50OiBzdHJpbmcsXG4gICAgcHVibGljIHBheWxvYWQ6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fSxcbiAgICBwdWJsaWMgdGltZW91dDogbnVtYmVyID0gREVGQVVMVF9USU1FT1VUXG4gICkge31cblxuICByZXNlbmQodGltZW91dDogbnVtYmVyKSB7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgIHRoaXMuX2NhbmNlbFJlZkV2ZW50KClcbiAgICB0aGlzLnJlZiA9ICcnXG4gICAgdGhpcy5yZWZFdmVudCA9IG51bGxcbiAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IG51bGxcbiAgICB0aGlzLnNlbnQgPSBmYWxzZVxuICAgIHRoaXMuc2VuZCgpXG4gIH1cblxuICBzZW5kKCkge1xuICAgIGlmICh0aGlzLl9oYXNSZWNlaXZlZCgndGltZW91dCcpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5zdGFydFRpbWVvdXQoKVxuICAgIHRoaXMuc2VudCA9IHRydWVcbiAgICB0aGlzLmNoYW5uZWwuc29ja2V0LnB1c2goe1xuICAgICAgdG9waWM6IHRoaXMuY2hhbm5lbC50b3BpYyxcbiAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgcGF5bG9hZDogdGhpcy5wYXlsb2FkLFxuICAgICAgcmVmOiB0aGlzLnJlZixcbiAgICAgIGpvaW5fcmVmOiB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKSxcbiAgICB9KVxuICB9XG5cbiAgdXBkYXRlUGF5bG9hZChwYXlsb2FkOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KTogdm9pZCB7XG4gICAgdGhpcy5wYXlsb2FkID0geyAuLi50aGlzLnBheWxvYWQsIC4uLnBheWxvYWQgfVxuICB9XG5cbiAgcmVjZWl2ZShzdGF0dXM6IHN0cmluZywgY2FsbGJhY2s6IEZ1bmN0aW9uKSB7XG4gICAgaWYgKHRoaXMuX2hhc1JlY2VpdmVkKHN0YXR1cykpIHtcbiAgICAgIGNhbGxiYWNrKHRoaXMucmVjZWl2ZWRSZXNwPy5yZXNwb25zZSlcbiAgICB9XG5cbiAgICB0aGlzLnJlY0hvb2tzLnB1c2goeyBzdGF0dXMsIGNhbGxiYWNrIH0pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0VGltZW91dCgpIHtcbiAgICBpZiAodGhpcy50aW1lb3V0VGltZXIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLnJlZiA9IHRoaXMuY2hhbm5lbC5zb2NrZXQuX21ha2VSZWYoKVxuICAgIHRoaXMucmVmRXZlbnQgPSB0aGlzLmNoYW5uZWwuX3JlcGx5RXZlbnROYW1lKHRoaXMucmVmKVxuXG4gICAgY29uc3QgY2FsbGJhY2sgPSAocGF5bG9hZDogYW55KSA9PiB7XG4gICAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpXG4gICAgICB0aGlzLl9jYW5jZWxUaW1lb3V0KClcbiAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gcGF5bG9hZFxuICAgICAgdGhpcy5fbWF0Y2hSZWNlaXZlKHBheWxvYWQpXG4gICAgfVxuXG4gICAgdGhpcy5jaGFubmVsLl9vbih0aGlzLnJlZkV2ZW50LCB7fSwgY2FsbGJhY2spXG5cbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IDxhbnk+c2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3RpbWVvdXQnLCB7fSlcbiAgICB9LCB0aGlzLnRpbWVvdXQpXG4gIH1cblxuICB0cmlnZ2VyKHN0YXR1czogc3RyaW5nLCByZXNwb25zZTogYW55KSB7XG4gICAgaWYgKHRoaXMucmVmRXZlbnQpXG4gICAgICB0aGlzLmNoYW5uZWwuX3RyaWdnZXIodGhpcy5yZWZFdmVudCwgeyBzdGF0dXMsIHJlc3BvbnNlIH0pXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2NhbmNlbFJlZkV2ZW50KClcbiAgICB0aGlzLl9jYW5jZWxUaW1lb3V0KClcbiAgfVxuXG4gIHByaXZhdGUgX2NhbmNlbFJlZkV2ZW50KCkge1xuICAgIGlmICghdGhpcy5yZWZFdmVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jaGFubmVsLl9vZmYodGhpcy5yZWZFdmVudCwge30pXG4gIH1cblxuICBwcml2YXRlIF9jYW5jZWxUaW1lb3V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUaW1lcilcbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IHVuZGVmaW5lZFxuICB9XG5cbiAgcHJpdmF0ZSBfbWF0Y2hSZWNlaXZlKHtcbiAgICBzdGF0dXMsXG4gICAgcmVzcG9uc2UsXG4gIH06IHtcbiAgICBzdGF0dXM6IHN0cmluZ1xuICAgIHJlc3BvbnNlOiBGdW5jdGlvblxuICB9KSB7XG4gICAgdGhpcy5yZWNIb29rc1xuICAgICAgLmZpbHRlcigoaCkgPT4gaC5zdGF0dXMgPT09IHN0YXR1cylcbiAgICAgIC5mb3JFYWNoKChoKSA9PiBoLmNhbGxiYWNrKHJlc3BvbnNlKSlcbiAgfVxuXG4gIHByaXZhdGUgX2hhc1JlY2VpdmVkKHN0YXR1czogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjZWl2ZWRSZXNwICYmIHRoaXMucmVjZWl2ZWRSZXNwLnN0YXR1cyA9PT0gc3RhdHVzXG4gIH1cbn1cbiIsICIvKlxuICBUaGlzIGZpbGUgZHJhd3MgaGVhdmlseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9kMzQ0ZWMwYTczMmFiNGVlMjA0MjE1YjMxZGU2OWNmNGJlNzJlM2JmL2Fzc2V0cy9qcy9waG9lbml4L3ByZXNlbmNlLmpzXG4gIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9kMzQ0ZWMwYTczMmFiNGVlMjA0MjE1YjMxZGU2OWNmNGJlNzJlM2JmL0xJQ0VOU0UubWRcbiovXG5cbmltcG9ydCB0eXBlIHtcbiAgUHJlc2VuY2VPcHRzLFxuICBQcmVzZW5jZU9uSm9pbkNhbGxiYWNrLFxuICBQcmVzZW5jZU9uTGVhdmVDYWxsYmFjayxcbn0gZnJvbSAncGhvZW5peCdcbmltcG9ydCB0eXBlIFJlYWx0aW1lQ2hhbm5lbCBmcm9tICcuL1JlYWx0aW1lQ2hhbm5lbCdcblxudHlwZSBQcmVzZW5jZTxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9PiA9IHtcbiAgcHJlc2VuY2VfcmVmOiBzdHJpbmdcbn0gJiBUXG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUHJlc2VuY2VTdGF0ZTxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9PiA9IHtcbiAgW2tleTogc3RyaW5nXTogUHJlc2VuY2U8VD5bXVxufVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVByZXNlbmNlSm9pblBheWxvYWQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+ID0ge1xuICBldmVudDogYCR7UkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUy5KT0lOfWBcbiAga2V5OiBzdHJpbmdcbiAgY3VycmVudFByZXNlbmNlczogUHJlc2VuY2U8VD5bXVxuICBuZXdQcmVzZW5jZXM6IFByZXNlbmNlPFQ+W11cbn1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVQcmVzZW5jZUxlYXZlUGF5bG9hZDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4gPSB7XG4gIGV2ZW50OiBgJHtSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLkxFQVZFfWBcbiAga2V5OiBzdHJpbmdcbiAgY3VycmVudFByZXNlbmNlczogUHJlc2VuY2U8VD5bXVxuICBsZWZ0UHJlc2VuY2VzOiBQcmVzZW5jZTxUPltdXG59XG5cbmV4cG9ydCBlbnVtIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMge1xuICBTWU5DID0gJ3N5bmMnLFxuICBKT0lOID0gJ2pvaW4nLFxuICBMRUFWRSA9ICdsZWF2ZScsXG59XG5cbnR5cGUgUHJlc2VuY2VEaWZmID0ge1xuICBqb2luczogUmVhbHRpbWVQcmVzZW5jZVN0YXRlXG4gIGxlYXZlczogUmVhbHRpbWVQcmVzZW5jZVN0YXRlXG59XG5cbnR5cGUgUmF3UHJlc2VuY2VTdGF0ZSA9IHtcbiAgW2tleTogc3RyaW5nXToge1xuICAgIG1ldGFzOiB7XG4gICAgICBwaHhfcmVmPzogc3RyaW5nXG4gICAgICBwaHhfcmVmX3ByZXY/OiBzdHJpbmdcbiAgICAgIFtrZXk6IHN0cmluZ106IGFueVxuICAgIH1bXVxuICB9XG59XG5cbnR5cGUgUmF3UHJlc2VuY2VEaWZmID0ge1xuICBqb2luczogUmF3UHJlc2VuY2VTdGF0ZVxuICBsZWF2ZXM6IFJhd1ByZXNlbmNlU3RhdGVcbn1cblxudHlwZSBQcmVzZW5jZUNob29zZXI8VD4gPSAoa2V5OiBzdHJpbmcsIHByZXNlbmNlczogUHJlc2VuY2VbXSkgPT4gVFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFsdGltZVByZXNlbmNlIHtcbiAgc3RhdGU6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSA9IHt9XG4gIHBlbmRpbmdEaWZmczogUmF3UHJlc2VuY2VEaWZmW10gPSBbXVxuICBqb2luUmVmOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICBjYWxsZXI6IHtcbiAgICBvbkpvaW46IFByZXNlbmNlT25Kb2luQ2FsbGJhY2tcbiAgICBvbkxlYXZlOiBQcmVzZW5jZU9uTGVhdmVDYWxsYmFja1xuICAgIG9uU3luYzogKCkgPT4gdm9pZFxuICB9ID0ge1xuICAgIG9uSm9pbjogKCkgPT4ge30sXG4gICAgb25MZWF2ZTogKCkgPT4ge30sXG4gICAgb25TeW5jOiAoKSA9PiB7fSxcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgUHJlc2VuY2UuXG4gICAqXG4gICAqIEBwYXJhbSBjaGFubmVsIC0gVGhlIFJlYWx0aW1lQ2hhbm5lbFxuICAgKiBAcGFyYW0gb3B0cyAtIFRoZSBvcHRpb25zLFxuICAgKiAgICAgICAgZm9yIGV4YW1wbGUgYHtldmVudHM6IHtzdGF0ZTogJ3N0YXRlJywgZGlmZjogJ2RpZmYnfX1gXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsLCBvcHRzPzogUHJlc2VuY2VPcHRzKSB7XG4gICAgY29uc3QgZXZlbnRzID0gb3B0cz8uZXZlbnRzIHx8IHtcbiAgICAgIHN0YXRlOiAncHJlc2VuY2Vfc3RhdGUnLFxuICAgICAgZGlmZjogJ3ByZXNlbmNlX2RpZmYnLFxuICAgIH1cblxuICAgIHRoaXMuY2hhbm5lbC5fb24oZXZlbnRzLnN0YXRlLCB7fSwgKG5ld1N0YXRlOiBSYXdQcmVzZW5jZVN0YXRlKSA9PiB7XG4gICAgICBjb25zdCB7IG9uSm9pbiwgb25MZWF2ZSwgb25TeW5jIH0gPSB0aGlzLmNhbGxlclxuXG4gICAgICB0aGlzLmpvaW5SZWYgPSB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKVxuXG4gICAgICB0aGlzLnN0YXRlID0gUmVhbHRpbWVQcmVzZW5jZS5zeW5jU3RhdGUoXG4gICAgICAgIHRoaXMuc3RhdGUsXG4gICAgICAgIG5ld1N0YXRlLFxuICAgICAgICBvbkpvaW4sXG4gICAgICAgIG9uTGVhdmVcbiAgICAgIClcblxuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMuZm9yRWFjaCgoZGlmZikgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlID0gUmVhbHRpbWVQcmVzZW5jZS5zeW5jRGlmZihcbiAgICAgICAgICB0aGlzLnN0YXRlLFxuICAgICAgICAgIGRpZmYsXG4gICAgICAgICAgb25Kb2luLFxuICAgICAgICAgIG9uTGVhdmVcbiAgICAgICAgKVxuICAgICAgfSlcblxuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuXG4gICAgICBvblN5bmMoKVxuICAgIH0pXG5cbiAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5kaWZmLCB7fSwgKGRpZmY6IFJhd1ByZXNlbmNlRGlmZikgPT4ge1xuICAgICAgY29uc3QgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXJcblxuICAgICAgaWYgKHRoaXMuaW5QZW5kaW5nU3luY1N0YXRlKCkpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMucHVzaChkaWZmKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY0RpZmYoXG4gICAgICAgICAgdGhpcy5zdGF0ZSxcbiAgICAgICAgICBkaWZmLFxuICAgICAgICAgIG9uSm9pbixcbiAgICAgICAgICBvbkxlYXZlXG4gICAgICAgIClcblxuICAgICAgICBvblN5bmMoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLm9uSm9pbigoa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBuZXdQcmVzZW5jZXMpID0+IHtcbiAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcigncHJlc2VuY2UnLCB7XG4gICAgICAgIGV2ZW50OiAnam9pbicsXG4gICAgICAgIGtleSxcbiAgICAgICAgY3VycmVudFByZXNlbmNlcyxcbiAgICAgICAgbmV3UHJlc2VuY2VzLFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5vbkxlYXZlKChrZXksIGN1cnJlbnRQcmVzZW5jZXMsIGxlZnRQcmVzZW5jZXMpID0+IHtcbiAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcigncHJlc2VuY2UnLCB7XG4gICAgICAgIGV2ZW50OiAnbGVhdmUnLFxuICAgICAgICBrZXksXG4gICAgICAgIGN1cnJlbnRQcmVzZW5jZXMsXG4gICAgICAgIGxlZnRQcmVzZW5jZXMsXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uU3luYygoKSA9PiB7XG4gICAgICB0aGlzLmNoYW5uZWwuX3RyaWdnZXIoJ3ByZXNlbmNlJywgeyBldmVudDogJ3N5bmMnIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHN5bmMgdGhlIGxpc3Qgb2YgcHJlc2VuY2VzIG9uIHRoZSBzZXJ2ZXIgd2l0aCB0aGVcbiAgICogY2xpZW50J3Mgc3RhdGUuXG4gICAqXG4gICAqIEFuIG9wdGlvbmFsIGBvbkpvaW5gIGFuZCBgb25MZWF2ZWAgY2FsbGJhY2sgY2FuIGJlIHByb3ZpZGVkIHRvXG4gICAqIHJlYWN0IHRvIGNoYW5nZXMgaW4gdGhlIGNsaWVudCdzIGxvY2FsIHByZXNlbmNlcyBhY3Jvc3NcbiAgICogZGlzY29ubmVjdHMgYW5kIHJlY29ubmVjdHMgd2l0aCB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHN5bmNTdGF0ZShcbiAgICBjdXJyZW50U3RhdGU6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSxcbiAgICBuZXdTdGF0ZTogUmF3UHJlc2VuY2VTdGF0ZSB8IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSxcbiAgICBvbkpvaW46IFByZXNlbmNlT25Kb2luQ2FsbGJhY2ssXG4gICAgb25MZWF2ZTogUHJlc2VuY2VPbkxlYXZlQ2FsbGJhY2tcbiAgKTogUmVhbHRpbWVQcmVzZW5jZVN0YXRlIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuY2xvbmVEZWVwKGN1cnJlbnRTdGF0ZSlcbiAgICBjb25zdCB0cmFuc2Zvcm1lZFN0YXRlID0gdGhpcy50cmFuc2Zvcm1TdGF0ZShuZXdTdGF0ZSlcbiAgICBjb25zdCBqb2luczogUmVhbHRpbWVQcmVzZW5jZVN0YXRlID0ge31cbiAgICBjb25zdCBsZWF2ZXM6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSA9IHt9XG5cbiAgICB0aGlzLm1hcChzdGF0ZSwgKGtleTogc3RyaW5nLCBwcmVzZW5jZXM6IFByZXNlbmNlW10pID0+IHtcbiAgICAgIGlmICghdHJhbnNmb3JtZWRTdGF0ZVtrZXldKSB7XG4gICAgICAgIGxlYXZlc1trZXldID0gcHJlc2VuY2VzXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMubWFwKHRyYW5zZm9ybWVkU3RhdGUsIChrZXksIG5ld1ByZXNlbmNlczogUHJlc2VuY2VbXSkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFByZXNlbmNlczogUHJlc2VuY2VbXSA9IHN0YXRlW2tleV1cblxuICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZXMpIHtcbiAgICAgICAgY29uc3QgbmV3UHJlc2VuY2VSZWZzID0gbmV3UHJlc2VuY2VzLm1hcChcbiAgICAgICAgICAobTogUHJlc2VuY2UpID0+IG0ucHJlc2VuY2VfcmVmXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgY3VyUHJlc2VuY2VSZWZzID0gY3VycmVudFByZXNlbmNlcy5tYXAoXG4gICAgICAgICAgKG06IFByZXNlbmNlKSA9PiBtLnByZXNlbmNlX3JlZlxuICAgICAgICApXG4gICAgICAgIGNvbnN0IGpvaW5lZFByZXNlbmNlczogUHJlc2VuY2VbXSA9IG5ld1ByZXNlbmNlcy5maWx0ZXIoXG4gICAgICAgICAgKG06IFByZXNlbmNlKSA9PiBjdXJQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgbGVmdFByZXNlbmNlczogUHJlc2VuY2VbXSA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKFxuICAgICAgICAgIChtOiBQcmVzZW5jZSkgPT4gbmV3UHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGpvaW5lZFByZXNlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgam9pbnNba2V5XSA9IGpvaW5lZFByZXNlbmNlc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlZnRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxlYXZlc1trZXldID0gbGVmdFByZXNlbmNlc1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2VzXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzLnN5bmNEaWZmKHN0YXRlLCB7IGpvaW5zLCBsZWF2ZXMgfSwgb25Kb2luLCBvbkxlYXZlKVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gc3luYyBhIGRpZmYgb2YgcHJlc2VuY2Ugam9pbiBhbmQgbGVhdmUgZXZlbnRzIGZyb20gdGhlXG4gICAqIHNlcnZlciwgYXMgdGhleSBoYXBwZW4uXG4gICAqXG4gICAqIExpa2UgYHN5bmNTdGF0ZWAsIGBzeW5jRGlmZmAgYWNjZXB0cyBvcHRpb25hbCBgb25Kb2luYCBhbmRcbiAgICogYG9uTGVhdmVgIGNhbGxiYWNrcyB0byByZWFjdCB0byBhIHVzZXIgam9pbmluZyBvciBsZWF2aW5nIGZyb20gYVxuICAgKiBkZXZpY2UuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgc3luY0RpZmYoXG4gICAgc3RhdGU6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSxcbiAgICBkaWZmOiBSYXdQcmVzZW5jZURpZmYgfCBQcmVzZW5jZURpZmYsXG4gICAgb25Kb2luOiBQcmVzZW5jZU9uSm9pbkNhbGxiYWNrLFxuICAgIG9uTGVhdmU6IFByZXNlbmNlT25MZWF2ZUNhbGxiYWNrXG4gICk6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSB7XG4gICAgY29uc3QgeyBqb2lucywgbGVhdmVzIH0gPSB7XG4gICAgICBqb2luczogdGhpcy50cmFuc2Zvcm1TdGF0ZShkaWZmLmpvaW5zKSxcbiAgICAgIGxlYXZlczogdGhpcy50cmFuc2Zvcm1TdGF0ZShkaWZmLmxlYXZlcyksXG4gICAgfVxuXG4gICAgaWYgKCFvbkpvaW4pIHtcbiAgICAgIG9uSm9pbiA9ICgpID0+IHt9XG4gICAgfVxuXG4gICAgaWYgKCFvbkxlYXZlKSB7XG4gICAgICBvbkxlYXZlID0gKCkgPT4ge31cbiAgICB9XG5cbiAgICB0aGlzLm1hcChqb2lucywgKGtleSwgbmV3UHJlc2VuY2VzOiBQcmVzZW5jZVtdKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50UHJlc2VuY2VzOiBQcmVzZW5jZVtdID0gc3RhdGVba2V5XSA/PyBbXVxuICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmVEZWVwKG5ld1ByZXNlbmNlcylcblxuICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBqb2luZWRQcmVzZW5jZVJlZnMgPSBzdGF0ZVtrZXldLm1hcChcbiAgICAgICAgICAobTogUHJlc2VuY2UpID0+IG0ucHJlc2VuY2VfcmVmXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgY3VyUHJlc2VuY2VzOiBQcmVzZW5jZVtdID0gY3VycmVudFByZXNlbmNlcy5maWx0ZXIoXG4gICAgICAgICAgKG06IFByZXNlbmNlKSA9PiBqb2luZWRQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwXG4gICAgICAgIClcblxuICAgICAgICBzdGF0ZVtrZXldLnVuc2hpZnQoLi4uY3VyUHJlc2VuY2VzKVxuICAgICAgfVxuXG4gICAgICBvbkpvaW4oa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBuZXdQcmVzZW5jZXMpXG4gICAgfSlcblxuICAgIHRoaXMubWFwKGxlYXZlcywgKGtleSwgbGVmdFByZXNlbmNlczogUHJlc2VuY2VbXSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZXM6IFByZXNlbmNlW10gPSBzdGF0ZVtrZXldXG5cbiAgICAgIGlmICghY3VycmVudFByZXNlbmNlcykgcmV0dXJuXG5cbiAgICAgIGNvbnN0IHByZXNlbmNlUmVmc1RvUmVtb3ZlID0gbGVmdFByZXNlbmNlcy5tYXAoXG4gICAgICAgIChtOiBQcmVzZW5jZSkgPT4gbS5wcmVzZW5jZV9yZWZcbiAgICAgIClcbiAgICAgIGN1cnJlbnRQcmVzZW5jZXMgPSBjdXJyZW50UHJlc2VuY2VzLmZpbHRlcihcbiAgICAgICAgKG06IFByZXNlbmNlKSA9PiBwcmVzZW5jZVJlZnNUb1JlbW92ZS5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDBcbiAgICAgIClcblxuICAgICAgc3RhdGVba2V5XSA9IGN1cnJlbnRQcmVzZW5jZXNcblxuICAgICAgb25MZWF2ZShrZXksIGN1cnJlbnRQcmVzZW5jZXMsIGxlZnRQcmVzZW5jZXMpXG5cbiAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzLmxlbmd0aCA9PT0gMCkgZGVsZXRlIHN0YXRlW2tleV1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHN0YXRlXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgc3RhdGljIG1hcDxUID0gYW55PihcbiAgICBvYmo6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSxcbiAgICBmdW5jOiBQcmVzZW5jZUNob29zZXI8VD5cbiAgKTogVFtdIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5tYXAoKGtleSkgPT4gZnVuYyhrZXksIG9ialtrZXldKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgJ21ldGFzJyBrZXlcbiAgICogQ2hhbmdlICdwaHhfcmVmJyB0byAncHJlc2VuY2VfcmVmJ1xuICAgKiBSZW1vdmUgJ3BoeF9yZWYnIGFuZCAncGh4X3JlZl9wcmV2J1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyByZXR1cm5zIHtcbiAgICogIGFiYzEyMzogW1xuICAgKiAgICB7IHByZXNlbmNlX3JlZjogJzInLCB1c2VyX2lkOiAxIH0sXG4gICAqICAgIHsgcHJlc2VuY2VfcmVmOiAnMycsIHVzZXJfaWQ6IDIgfVxuICAgKiAgXVxuICAgKiB9XG4gICAqIFJlYWx0aW1lUHJlc2VuY2UudHJhbnNmb3JtU3RhdGUoe1xuICAgKiAgYWJjMTIzOiB7XG4gICAqICAgIG1ldGFzOiBbXG4gICAqICAgICAgeyBwaHhfcmVmOiAnMicsIHBoeF9yZWZfcHJldjogJzEnIHVzZXJfaWQ6IDEgfSxcbiAgICogICAgICB7IHBoeF9yZWY6ICczJywgdXNlcl9pZDogMiB9XG4gICAqICAgIF1cbiAgICogIH1cbiAgICogfSlcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyB0cmFuc2Zvcm1TdGF0ZShcbiAgICBzdGF0ZTogUmF3UHJlc2VuY2VTdGF0ZSB8IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZVxuICApOiBSZWFsdGltZVByZXNlbmNlU3RhdGUge1xuICAgIHN0YXRlID0gdGhpcy5jbG9uZURlZXAoc3RhdGUpXG5cbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RhdGUpLnJlZHVjZSgobmV3U3RhdGUsIGtleSkgPT4ge1xuICAgICAgY29uc3QgcHJlc2VuY2VzID0gc3RhdGVba2V5XVxuXG4gICAgICBpZiAoJ21ldGFzJyBpbiBwcmVzZW5jZXMpIHtcbiAgICAgICAgbmV3U3RhdGVba2V5XSA9IHByZXNlbmNlcy5tZXRhcy5tYXAoKHByZXNlbmNlKSA9PiB7XG4gICAgICAgICAgcHJlc2VuY2VbJ3ByZXNlbmNlX3JlZiddID0gcHJlc2VuY2VbJ3BoeF9yZWYnXVxuXG4gICAgICAgICAgZGVsZXRlIHByZXNlbmNlWydwaHhfcmVmJ11cbiAgICAgICAgICBkZWxldGUgcHJlc2VuY2VbJ3BoeF9yZWZfcHJldiddXG5cbiAgICAgICAgICByZXR1cm4gcHJlc2VuY2VcbiAgICAgICAgfSkgYXMgUHJlc2VuY2VbXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3U3RhdGVba2V5XSA9IHByZXNlbmNlc1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3U3RhdGVcbiAgICB9LCB7fSBhcyBSZWFsdGltZVByZXNlbmNlU3RhdGUpXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgc3RhdGljIGNsb25lRGVlcChvYmo6IHsgW2tleTogc3RyaW5nXTogYW55IH0pIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIG9uSm9pbihjYWxsYmFjazogUHJlc2VuY2VPbkpvaW5DYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuY2FsbGVyLm9uSm9pbiA9IGNhbGxiYWNrXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgb25MZWF2ZShjYWxsYmFjazogUHJlc2VuY2VPbkxlYXZlQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLmNhbGxlci5vbkxlYXZlID0gY2FsbGJhY2tcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBvblN5bmMoY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFja1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIGluUGVuZGluZ1N5bmNTdGF0ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuam9pblJlZiB8fCB0aGlzLmpvaW5SZWYgIT09IHRoaXMuY2hhbm5lbC5fam9pblJlZigpXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBDSEFOTkVMX0VWRU5UUywgQ0hBTk5FTF9TVEFURVMgfSBmcm9tICcuL2xpYi9jb25zdGFudHMnXG5pbXBvcnQgUHVzaCBmcm9tICcuL2xpYi9wdXNoJ1xuaW1wb3J0IHR5cGUgUmVhbHRpbWVDbGllbnQgZnJvbSAnLi9SZWFsdGltZUNsaWVudCdcbmltcG9ydCBUaW1lciBmcm9tICcuL2xpYi90aW1lcidcbmltcG9ydCBSZWFsdGltZVByZXNlbmNlLCB7XG4gIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMsXG59IGZyb20gJy4vUmVhbHRpbWVQcmVzZW5jZSdcbmltcG9ydCB0eXBlIHtcbiAgUmVhbHRpbWVQcmVzZW5jZUpvaW5QYXlsb2FkLFxuICBSZWFsdGltZVByZXNlbmNlTGVhdmVQYXlsb2FkLFxuICBSZWFsdGltZVByZXNlbmNlU3RhdGUsXG59IGZyb20gJy4vUmVhbHRpbWVQcmVzZW5jZSdcbmltcG9ydCAqIGFzIFRyYW5zZm9ybWVycyBmcm9tICcuL2xpYi90cmFuc2Zvcm1lcnMnXG5pbXBvcnQgeyBodHRwRW5kcG9pbnRVUkwgfSBmcm9tICcuL2xpYi90cmFuc2Zvcm1lcnMnXG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lQ2hhbm5lbE9wdGlvbnMgPSB7XG4gIGNvbmZpZzoge1xuICAgIC8qKlxuICAgICAqIHNlbGYgb3B0aW9uIGVuYWJsZXMgY2xpZW50IHRvIHJlY2VpdmUgbWVzc2FnZSBpdCBicm9hZGNhc3RcbiAgICAgKiBhY2sgb3B0aW9uIGluc3RydWN0cyBzZXJ2ZXIgdG8gYWNrbm93bGVkZ2UgdGhhdCBicm9hZGNhc3QgbWVzc2FnZSB3YXMgcmVjZWl2ZWRcbiAgICAgKi9cbiAgICBicm9hZGNhc3Q/OiB7IHNlbGY/OiBib29sZWFuOyBhY2s/OiBib29sZWFuIH1cbiAgICAvKipcbiAgICAgKiBrZXkgb3B0aW9uIGlzIHVzZWQgdG8gdHJhY2sgcHJlc2VuY2UgcGF5bG9hZCBhY3Jvc3MgY2xpZW50c1xuICAgICAqL1xuICAgIHByZXNlbmNlPzogeyBrZXk/OiBzdHJpbmcgfVxuICAgIC8qKlxuICAgICAqIGRlZmluZXMgaWYgdGhlIGNoYW5uZWwgaXMgcHJpdmF0ZSBvciBub3QgYW5kIGlmIFJMUyBwb2xpY2llcyB3aWxsIGJlIHVzZWQgdG8gY2hlY2sgZGF0YVxuICAgICAqL1xuICAgIHByaXZhdGU/OiBib29sZWFuXG4gIH1cbn1cblxudHlwZSBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc1BheWxvYWRCYXNlID0ge1xuICBzY2hlbWE6IHN0cmluZ1xuICB0YWJsZTogc3RyaW5nXG4gIGNvbW1pdF90aW1lc3RhbXA6IHN0cmluZ1xuICBlcnJvcnM6IHN0cmluZ1tdXG59XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUG9zdGdyZXNJbnNlcnRQYXlsb2FkPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PiA9XG4gIFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZEJhc2UgJiB7XG4gICAgZXZlbnRUeXBlOiBgJHtSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVC5JTlNFUlR9YFxuICAgIG5ldzogVFxuICAgIG9sZDoge31cbiAgfVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVBvc3RncmVzVXBkYXRlUGF5bG9hZDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4gPVxuICBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc1BheWxvYWRCYXNlICYge1xuICAgIGV2ZW50VHlwZTogYCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuVVBEQVRFfWBcbiAgICBuZXc6IFRcbiAgICBvbGQ6IFBhcnRpYWw8VD5cbiAgfVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVBvc3RncmVzRGVsZXRlUGF5bG9hZDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4gPVxuICBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc1BheWxvYWRCYXNlICYge1xuICAgIGV2ZW50VHlwZTogYCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuREVMRVRFfWBcbiAgICBuZXc6IHt9XG4gICAgb2xkOiBQYXJ0aWFsPFQ+XG4gIH1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PiA9XG4gIHwgUmVhbHRpbWVQb3N0Z3Jlc0luc2VydFBheWxvYWQ8VD5cbiAgfCBSZWFsdGltZVBvc3RncmVzVXBkYXRlUGF5bG9hZDxUPlxuICB8IFJlYWx0aW1lUG9zdGdyZXNEZWxldGVQYXlsb2FkPFQ+XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzRmlsdGVyPFxuICBUIGV4dGVuZHMgYCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlR9YFxuPiA9IHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGRhdGFiYXNlIGNoYW5nZSB0byBsaXN0ZW4gdG8uXG4gICAqL1xuICBldmVudDogVFxuICAvKipcbiAgICogVGhlIGRhdGFiYXNlIHNjaGVtYSB0byBsaXN0ZW4gdG8uXG4gICAqL1xuICBzY2hlbWE6IHN0cmluZ1xuICAvKipcbiAgICogVGhlIGRhdGFiYXNlIHRhYmxlIHRvIGxpc3RlbiB0by5cbiAgICovXG4gIHRhYmxlPzogc3RyaW5nXG4gIC8qKlxuICAgKiBSZWNlaXZlIGRhdGFiYXNlIGNoYW5nZXMgd2hlbiBmaWx0ZXIgaXMgbWF0Y2hlZC5cbiAgICovXG4gIGZpbHRlcj86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZUNoYW5uZWxTZW5kUmVzcG9uc2UgPSAnb2snIHwgJ3RpbWVkIG91dCcgfCAnZXJyb3InXG5cbmV4cG9ydCBlbnVtIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UIHtcbiAgQUxMID0gJyonLFxuICBJTlNFUlQgPSAnSU5TRVJUJyxcbiAgVVBEQVRFID0gJ1VQREFURScsXG4gIERFTEVURSA9ICdERUxFVEUnLFxufVxuXG5leHBvcnQgZW51bSBSRUFMVElNRV9MSVNURU5fVFlQRVMge1xuICBCUk9BRENBU1QgPSAnYnJvYWRjYXN0JyxcbiAgUFJFU0VOQ0UgPSAncHJlc2VuY2UnLFxuICBQT1NUR1JFU19DSEFOR0VTID0gJ3Bvc3RncmVzX2NoYW5nZXMnLFxuICBTWVNURU0gPSAnc3lzdGVtJyxcbn1cblxuZXhwb3J0IGVudW0gUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUyB7XG4gIFNVQlNDUklCRUQgPSAnU1VCU0NSSUJFRCcsXG4gIFRJTUVEX09VVCA9ICdUSU1FRF9PVVQnLFxuICBDTE9TRUQgPSAnQ0xPU0VEJyxcbiAgQ0hBTk5FTF9FUlJPUiA9ICdDSEFOTkVMX0VSUk9SJyxcbn1cblxuZXhwb3J0IGNvbnN0IFJFQUxUSU1FX0NIQU5ORUxfU1RBVEVTID0gQ0hBTk5FTF9TVEFURVNcblxuaW50ZXJmYWNlIFBvc3RncmVzQ2hhbmdlc0ZpbHRlcnMge1xuICBwb3N0Z3Jlc19jaGFuZ2VzOiB7XG4gICAgaWQ6IHN0cmluZ1xuICAgIGV2ZW50OiBzdHJpbmdcbiAgICBzY2hlbWE/OiBzdHJpbmdcbiAgICB0YWJsZT86IHN0cmluZ1xuICAgIGZpbHRlcj86IHN0cmluZ1xuICB9W11cbn1cbi8qKiBBIGNoYW5uZWwgaXMgdGhlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrIG9mIFJlYWx0aW1lXG4gKiBhbmQgbmFycm93cyB0aGUgc2NvcGUgb2YgZGF0YSBmbG93IHRvIHN1YnNjcmliZWQgY2xpZW50cy5cbiAqIFlvdSBjYW4gdGhpbmsgb2YgYSBjaGFubmVsIGFzIGEgY2hhdHJvb20gd2hlcmUgcGFydGljaXBhbnRzIGFyZSBhYmxlIHRvIHNlZSB3aG8ncyBvbmxpbmVcbiAqIGFuZCBzZW5kIGFuZCByZWNlaXZlIG1lc3NhZ2VzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFsdGltZUNoYW5uZWwge1xuICBiaW5kaW5nczoge1xuICAgIFtrZXk6IHN0cmluZ106IHtcbiAgICAgIHR5cGU6IHN0cmluZ1xuICAgICAgZmlsdGVyOiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gICAgICBjYWxsYmFjazogRnVuY3Rpb25cbiAgICAgIGlkPzogc3RyaW5nXG4gICAgfVtdXG4gIH0gPSB7fVxuICB0aW1lb3V0OiBudW1iZXJcbiAgc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgam9pbmVkT25jZSA9IGZhbHNlXG4gIGpvaW5QdXNoOiBQdXNoXG4gIHJlam9pblRpbWVyOiBUaW1lclxuICBwdXNoQnVmZmVyOiBQdXNoW10gPSBbXVxuICBwcmVzZW5jZTogUmVhbHRpbWVQcmVzZW5jZVxuICBicm9hZGNhc3RFbmRwb2ludFVSTDogc3RyaW5nXG4gIHN1YlRvcGljOiBzdHJpbmdcbiAgcHJpdmF0ZTogYm9vbGVhblxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUb3BpYyBuYW1lIGNhbiBiZSBhbnkgc3RyaW5nLiAqL1xuICAgIHB1YmxpYyB0b3BpYzogc3RyaW5nLFxuICAgIHB1YmxpYyBwYXJhbXM6IFJlYWx0aW1lQ2hhbm5lbE9wdGlvbnMgPSB7IGNvbmZpZzoge30gfSxcbiAgICBwdWJsaWMgc29ja2V0OiBSZWFsdGltZUNsaWVudFxuICApIHtcbiAgICB0aGlzLnN1YlRvcGljID0gdG9waWMucmVwbGFjZSgvXnJlYWx0aW1lOi9pLCAnJylcbiAgICB0aGlzLnBhcmFtcy5jb25maWcgPSB7XG4gICAgICAuLi57XG4gICAgICAgIGJyb2FkY2FzdDogeyBhY2s6IGZhbHNlLCBzZWxmOiBmYWxzZSB9LFxuICAgICAgICBwcmVzZW5jZTogeyBrZXk6ICcnIH0sXG4gICAgICAgIHByaXZhdGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIC4uLnBhcmFtcy5jb25maWcsXG4gICAgfVxuICAgIHRoaXMudGltZW91dCA9IHRoaXMuc29ja2V0LnRpbWVvdXRcbiAgICB0aGlzLmpvaW5QdXNoID0gbmV3IFB1c2goXG4gICAgICB0aGlzLFxuICAgICAgQ0hBTk5FTF9FVkVOVFMuam9pbixcbiAgICAgIHRoaXMucGFyYW1zLFxuICAgICAgdGhpcy50aW1lb3V0XG4gICAgKVxuICAgIHRoaXMucmVqb2luVGltZXIgPSBuZXcgVGltZXIoXG4gICAgICAoKSA9PiB0aGlzLl9yZWpvaW5VbnRpbENvbm5lY3RlZCgpLFxuICAgICAgdGhpcy5zb2NrZXQucmVjb25uZWN0QWZ0ZXJNc1xuICAgIClcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoJ29rJywgKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5lZFxuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaCgocHVzaEV2ZW50OiBQdXNoKSA9PiBwdXNoRXZlbnQuc2VuZCgpKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW11cbiAgICB9KVxuICAgIHRoaXMuX29uQ2xvc2UoKCkgPT4ge1xuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgY2xvc2UgJHt0aGlzLnRvcGljfSAke3RoaXMuX2pvaW5SZWYoKX1gKVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICAgICAgdGhpcy5zb2NrZXQuX3JlbW92ZSh0aGlzKVxuICAgIH0pXG4gICAgdGhpcy5fb25FcnJvcigocmVhc29uOiBzdHJpbmcpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pc0xlYXZpbmcoKSB8fCB0aGlzLl9pc0Nsb3NlZCgpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGVycm9yICR7dGhpcy50b3BpY31gLCByZWFzb24pXG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKVxuICAgIH0pXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9pc0pvaW5pbmcoKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGB0aW1lb3V0ICR7dGhpcy50b3BpY31gLCB0aGlzLmpvaW5QdXNoLnRpbWVvdXQpXG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKVxuICAgIH0pXG4gICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMucmVwbHksIHt9LCAocGF5bG9hZDogYW55LCByZWY6IHN0cmluZykgPT4ge1xuICAgICAgdGhpcy5fdHJpZ2dlcih0aGlzLl9yZXBseUV2ZW50TmFtZShyZWYpLCBwYXlsb2FkKVxuICAgIH0pXG5cbiAgICB0aGlzLnByZXNlbmNlID0gbmV3IFJlYWx0aW1lUHJlc2VuY2UodGhpcylcblxuICAgIHRoaXMuYnJvYWRjYXN0RW5kcG9pbnRVUkwgPVxuICAgICAgaHR0cEVuZHBvaW50VVJMKHRoaXMuc29ja2V0LmVuZFBvaW50KSArICcvYXBpL2Jyb2FkY2FzdCdcbiAgICB0aGlzLnByaXZhdGUgPSB0aGlzLnBhcmFtcy5jb25maWcucHJpdmF0ZSB8fCBmYWxzZVxuICB9XG5cbiAgLyoqIFN1YnNjcmliZSByZWdpc3RlcnMgeW91ciBjbGllbnQgd2l0aCB0aGUgc2VydmVyICovXG4gIHN1YnNjcmliZShcbiAgICBjYWxsYmFjaz86IChzdGF0dXM6IFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMsIGVycj86IEVycm9yKSA9PiB2b2lkLFxuICAgIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXRcbiAgKTogUmVhbHRpbWVDaGFubmVsIHtcbiAgICBpZiAoIXRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QoKVxuICAgIH1cbiAgICBpZiAodGhpcy5qb2luZWRPbmNlKSB7XG4gICAgICB0aHJvdyBgdHJpZWQgdG8gc3Vic2NyaWJlIG11bHRpcGxlIHRpbWVzLiAnc3Vic2NyaWJlJyBjYW4gb25seSBiZSBjYWxsZWQgYSBzaW5nbGUgdGltZSBwZXIgY2hhbm5lbCBpbnN0YW5jZWBcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb25maWc6IHsgYnJvYWRjYXN0LCBwcmVzZW5jZSwgcHJpdmF0ZTogaXNQcml2YXRlIH0sXG4gICAgICB9ID0gdGhpcy5wYXJhbXNcblxuICAgICAgdGhpcy5fb25FcnJvcigoZTogRXJyb3IpID0+XG4gICAgICAgIGNhbGxiYWNrPy4oUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DSEFOTkVMX0VSUk9SLCBlKVxuICAgICAgKVxuICAgICAgdGhpcy5fb25DbG9zZSgoKSA9PiBjYWxsYmFjaz8uKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0xPU0VEKSlcblxuICAgICAgY29uc3QgYWNjZXNzVG9rZW5QYXlsb2FkOiB7IGFjY2Vzc190b2tlbj86IHN0cmluZyB9ID0ge31cbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgYnJvYWRjYXN0LFxuICAgICAgICBwcmVzZW5jZSxcbiAgICAgICAgcG9zdGdyZXNfY2hhbmdlczpcbiAgICAgICAgICB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXM/Lm1hcCgocikgPT4gci5maWx0ZXIpID8/IFtdLFxuICAgICAgICBwcml2YXRlOiBpc1ByaXZhdGUsXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlKSB7XG4gICAgICAgIGFjY2Vzc1Rva2VuUGF5bG9hZC5hY2Nlc3NfdG9rZW4gPSB0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlXG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlSm9pblBheWxvYWQoeyAuLi57IGNvbmZpZyB9LCAuLi5hY2Nlc3NUb2tlblBheWxvYWQgfSlcblxuICAgICAgdGhpcy5qb2luZWRPbmNlID0gdHJ1ZVxuICAgICAgdGhpcy5fcmVqb2luKHRpbWVvdXQpXG5cbiAgICAgIHRoaXMuam9pblB1c2hcbiAgICAgICAgLnJlY2VpdmUoJ29rJywgYXN5bmMgKHsgcG9zdGdyZXNfY2hhbmdlcyB9OiBQb3N0Z3Jlc0NoYW5nZXNGaWx0ZXJzKSA9PiB7XG4gICAgICAgICAgdGhpcy5zb2NrZXQuc2V0QXV0aCgpXG4gICAgICAgICAgaWYgKHBvc3RncmVzX2NoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2FsbGJhY2s/LihSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLlNVQlNDUklCRUQpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50UG9zdGdyZXNCaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlc1xuICAgICAgICAgICAgY29uc3QgYmluZGluZ3NMZW4gPSBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzPy5sZW5ndGggPz8gMFxuICAgICAgICAgICAgY29uc3QgbmV3UG9zdGdyZXNCaW5kaW5ncyA9IFtdXG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3NMZW47IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBjbGllbnRQb3N0Z3Jlc0JpbmRpbmcgPSBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzW2ldXG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHsgZXZlbnQsIHNjaGVtYSwgdGFibGUsIGZpbHRlciB9LFxuICAgICAgICAgICAgICB9ID0gY2xpZW50UG9zdGdyZXNCaW5kaW5nXG4gICAgICAgICAgICAgIGNvbnN0IHNlcnZlclBvc3RncmVzRmlsdGVyID1cbiAgICAgICAgICAgICAgICBwb3N0Z3Jlc19jaGFuZ2VzICYmIHBvc3RncmVzX2NoYW5nZXNbaV1cblxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc2VydmVyUG9zdGdyZXNGaWx0ZXIgJiZcbiAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5ldmVudCA9PT0gZXZlbnQgJiZcbiAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5zY2hlbWEgPT09IHNjaGVtYSAmJlxuICAgICAgICAgICAgICAgIHNlcnZlclBvc3RncmVzRmlsdGVyLnRhYmxlID09PSB0YWJsZSAmJlxuICAgICAgICAgICAgICAgIHNlcnZlclBvc3RncmVzRmlsdGVyLmZpbHRlciA9PT0gZmlsdGVyXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG5ld1Bvc3RncmVzQmluZGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAuLi5jbGllbnRQb3N0Z3Jlc0JpbmRpbmcsXG4gICAgICAgICAgICAgICAgICBpZDogc2VydmVyUG9zdGdyZXNGaWx0ZXIuaWQsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKClcbiAgICAgICAgICAgICAgICBjYWxsYmFjaz8uKFxuICAgICAgICAgICAgICAgICAgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DSEFOTkVMX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnbWlzbWF0Y2ggYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCBiaW5kaW5ncyBmb3IgcG9zdGdyZXMgY2hhbmdlcydcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzID0gbmV3UG9zdGdyZXNCaW5kaW5nc1xuXG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLlNVQlNDUklCRUQpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5yZWNlaXZlKCdlcnJvcicsIChlcnJvcjogeyBba2V5OiBzdHJpbmddOiBhbnkgfSkgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrPy4oXG4gICAgICAgICAgICBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNIQU5ORUxfRVJST1IsXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KE9iamVjdC52YWx1ZXMoZXJyb3IpLmpvaW4oJywgJykgfHwgJ2Vycm9yJylcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0pXG4gICAgICAgIC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrPy4oUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5USU1FRF9PVVQpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcmVzZW5jZVN0YXRlPFxuICAgIFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge31cbiAgPigpOiBSZWFsdGltZVByZXNlbmNlU3RhdGU8VD4ge1xuICAgIHJldHVybiB0aGlzLnByZXNlbmNlLnN0YXRlIGFzIFJlYWx0aW1lUHJlc2VuY2VTdGF0ZTxUPlxuICB9XG5cbiAgYXN5bmMgdHJhY2soXG4gICAgcGF5bG9hZDogeyBba2V5OiBzdHJpbmddOiBhbnkgfSxcbiAgICBvcHRzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge31cbiAgKTogUHJvbWlzZTxSZWFsdGltZUNoYW5uZWxTZW5kUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kKFxuICAgICAge1xuICAgICAgICB0eXBlOiAncHJlc2VuY2UnLFxuICAgICAgICBldmVudDogJ3RyYWNrJyxcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgIH0sXG4gICAgICBvcHRzLnRpbWVvdXQgfHwgdGhpcy50aW1lb3V0XG4gICAgKVxuICB9XG5cbiAgYXN5bmMgdW50cmFjayhcbiAgICBvcHRzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge31cbiAgKTogUHJvbWlzZTxSZWFsdGltZUNoYW5uZWxTZW5kUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kKFxuICAgICAge1xuICAgICAgICB0eXBlOiAncHJlc2VuY2UnLFxuICAgICAgICBldmVudDogJ3VudHJhY2snLFxuICAgICAgfSxcbiAgICAgIG9wdHNcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBldmVudCBoYW5kbGVyIHRoYXQgbGlzdGVucyB0byBjaGFuZ2VzLlxuICAgKi9cbiAgb24oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFfWAsXG4gICAgZmlsdGVyOiB7IGV2ZW50OiBgJHtSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLlNZTkN9YCB9LFxuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFfWAsXG4gICAgZmlsdGVyOiB7IGV2ZW50OiBgJHtSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLkpPSU59YCB9LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDogUmVhbHRpbWVQcmVzZW5jZUpvaW5QYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFfWAsXG4gICAgZmlsdGVyOiB7IGV2ZW50OiBgJHtSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLkxFQVZFfWAgfSxcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IFJlYWx0aW1lUHJlc2VuY2VMZWF2ZVBheWxvYWQ8VD4pID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsXG4gIG9uPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PihcbiAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuUE9TVEdSRVNfQ0hBTkdFU31gLFxuICAgIGZpbHRlcjogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNGaWx0ZXI8YCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuQUxMfWA+LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBPU1RHUkVTX0NIQU5HRVN9YCxcbiAgICBmaWx0ZXI6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzRmlsdGVyPGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULklOU0VSVH1gPixcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IFJlYWx0aW1lUG9zdGdyZXNJbnNlcnRQYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBPU1RHUkVTX0NIQU5HRVN9YCxcbiAgICBmaWx0ZXI6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzRmlsdGVyPGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULlVQREFURX1gPixcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IFJlYWx0aW1lUG9zdGdyZXNVcGRhdGVQYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBPU1RHUkVTX0NIQU5HRVN9YCxcbiAgICBmaWx0ZXI6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzRmlsdGVyPGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULkRFTEVURX1gPixcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IFJlYWx0aW1lUG9zdGdyZXNEZWxldGVQYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICAvKipcbiAgICogVGhlIGZvbGxvd2luZyBpcyBwbGFjZWQgaGVyZSB0byBkaXNwbGF5IG9uIHN1cGFiYXNlLmNvbS9kb2NzL3JlZmVyZW5jZS9qYXZhc2NyaXB0L3N1YnNjcmliZS5cbiAgICogQHBhcmFtIHR5cGUgT25lIG9mIFwiYnJvYWRjYXN0XCIsIFwicHJlc2VuY2VcIiwgb3IgXCJwb3N0Z3Jlc19jaGFuZ2VzXCIuXG4gICAqIEBwYXJhbSBmaWx0ZXIgQ3VzdG9tIG9iamVjdCBzcGVjaWZpYyB0byB0aGUgUmVhbHRpbWUgZmVhdHVyZSBkZXRhaWxpbmcgd2hpY2ggcGF5bG9hZHMgdG8gcmVjZWl2ZS5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiBldmVudCBoYW5kbGVyIGlzIHRyaWdnZXJlZC5cbiAgICovXG4gIG9uKFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5CUk9BRENBU1R9YCxcbiAgICBmaWx0ZXI6IHsgZXZlbnQ6IHN0cmluZyB9LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDoge1xuICAgICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLkJST0FEQ0FTVH1gXG4gICAgICBldmVudDogc3RyaW5nXG4gICAgICBba2V5OiBzdHJpbmddOiBhbnlcbiAgICB9KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLkJST0FEQ0FTVH1gLFxuICAgIGZpbHRlcjogeyBldmVudDogc3RyaW5nIH0sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiB7XG4gICAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuQlJPQURDQVNUfWBcbiAgICAgIGV2ZW50OiBzdHJpbmdcbiAgICAgIHBheWxvYWQ6IFRcbiAgICB9KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlNZU1RFTX1gLFxuICAgIGZpbHRlcjoge30sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiBhbnkpID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsXG4gIG9uKFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFU31gLFxuICAgIGZpbHRlcjogeyBldmVudDogc3RyaW5nOyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSxcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IGFueSkgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWwge1xuICAgIHJldHVybiB0aGlzLl9vbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKVxuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIG1lc3NhZ2UgaW50byB0aGUgY2hhbm5lbC5cbiAgICpcbiAgICogQHBhcmFtIGFyZ3MgQXJndW1lbnRzIHRvIHNlbmQgdG8gY2hhbm5lbFxuICAgKiBAcGFyYW0gYXJncy50eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHRvIHNlbmRcbiAgICogQHBhcmFtIGFyZ3MuZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IGJlaW5nIHNlbnRcbiAgICogQHBhcmFtIGFyZ3MucGF5bG9hZCBQYXlsb2FkIHRvIGJlIHNlbnRcbiAgICogQHBhcmFtIG9wdHMgT3B0aW9ucyB0byBiZSB1c2VkIGR1cmluZyB0aGUgc2VuZCBwcm9jZXNzXG4gICAqL1xuICBhc3luYyBzZW5kKFxuICAgIGFyZ3M6IHtcbiAgICAgIHR5cGU6ICdicm9hZGNhc3QnIHwgJ3ByZXNlbmNlJyB8ICdwb3N0Z3Jlc19jaGFuZ2VzJ1xuICAgICAgZXZlbnQ6IHN0cmluZ1xuICAgICAgcGF5bG9hZD86IGFueVxuICAgICAgW2tleTogc3RyaW5nXTogYW55XG4gICAgfSxcbiAgICBvcHRzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge31cbiAgKTogUHJvbWlzZTxSZWFsdGltZUNoYW5uZWxTZW5kUmVzcG9uc2U+IHtcbiAgICBpZiAoIXRoaXMuX2NhblB1c2goKSAmJiBhcmdzLnR5cGUgPT09ICdicm9hZGNhc3QnKSB7XG4gICAgICBjb25zdCB7IGV2ZW50LCBwYXlsb2FkOiBlbmRwb2ludF9wYXlsb2FkIH0gPSBhcmdzXG4gICAgICBjb25zdCBhdXRob3JpemF0aW9uID0gdGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZVxuICAgICAgICA/IGBCZWFyZXIgJHt0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlfWBcbiAgICAgICAgOiAnJ1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uLFxuICAgICAgICAgIGFwaWtleTogdGhpcy5zb2NrZXQuYXBpS2V5ID8gdGhpcy5zb2NrZXQuYXBpS2V5IDogJycsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRvcGljOiB0aGlzLnN1YlRvcGljLFxuICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgcGF5bG9hZDogZW5kcG9pbnRfcGF5bG9hZCxcbiAgICAgICAgICAgICAgcHJpdmF0ZTogdGhpcy5wcml2YXRlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9KSxcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9mZXRjaFdpdGhUaW1lb3V0KFxuICAgICAgICAgIHRoaXMuYnJvYWRjYXN0RW5kcG9pbnRVUkwsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBvcHRzLnRpbWVvdXQgPz8gdGhpcy50aW1lb3V0XG4gICAgICAgIClcblxuICAgICAgICBhd2FpdCByZXNwb25zZS5ib2R5Py5jYW5jZWwoKVxuICAgICAgICByZXR1cm4gcmVzcG9uc2Uub2sgPyAnb2snIDogJ2Vycm9yJ1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgcmV0dXJuICd0aW1lZCBvdXQnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICdlcnJvcidcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgcHVzaCA9IHRoaXMuX3B1c2goYXJncy50eXBlLCBhcmdzLCBvcHRzLnRpbWVvdXQgfHwgdGhpcy50aW1lb3V0KVxuXG4gICAgICAgIGlmIChhcmdzLnR5cGUgPT09ICdicm9hZGNhc3QnICYmICF0aGlzLnBhcmFtcz8uY29uZmlnPy5icm9hZGNhc3Q/LmFjaykge1xuICAgICAgICAgIHJlc29sdmUoJ29rJylcbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2gucmVjZWl2ZSgnb2snLCAoKSA9PiByZXNvbHZlKCdvaycpKVxuICAgICAgICBwdXNoLnJlY2VpdmUoJ2Vycm9yJywgKCkgPT4gcmVzb2x2ZSgnZXJyb3InKSlcbiAgICAgICAgcHVzaC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4gcmVzb2x2ZSgndGltZWQgb3V0JykpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUpvaW5QYXlsb2FkKHBheWxvYWQ6IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiB2b2lkIHtcbiAgICB0aGlzLmpvaW5QdXNoLnVwZGF0ZVBheWxvYWQocGF5bG9hZClcbiAgfVxuXG4gIC8qKlxuICAgKiBMZWF2ZXMgdGhlIGNoYW5uZWwuXG4gICAqXG4gICAqIFVuc3Vic2NyaWJlcyBmcm9tIHNlcnZlciBldmVudHMsIGFuZCBpbnN0cnVjdHMgY2hhbm5lbCB0byB0ZXJtaW5hdGUgb24gc2VydmVyLlxuICAgKiBUcmlnZ2VycyBvbkNsb3NlKCkgaG9va3MuXG4gICAqXG4gICAqIFRvIHJlY2VpdmUgbGVhdmUgYWNrbm93bGVkZ2VtZW50cywgdXNlIHRoZSBhIGByZWNlaXZlYCBob29rIHRvIGJpbmQgdG8gdGhlIHNlcnZlciBhY2ssIGllOlxuICAgKiBjaGFubmVsLnVuc3Vic2NyaWJlKCkucmVjZWl2ZShcIm9rXCIsICgpID0+IGFsZXJ0KFwibGVmdCFcIikgKVxuICAgKi9cbiAgdW5zdWJzY3JpYmUodGltZW91dCA9IHRoaXMudGltZW91dCk6IFByb21pc2U8J29rJyB8ICd0aW1lZCBvdXQnIHwgJ2Vycm9yJz4ge1xuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nXG4gICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBsZWF2ZSAke3RoaXMudG9waWN9YClcbiAgICAgIHRoaXMuX3RyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuY2xvc2UsICdsZWF2ZScsIHRoaXMuX2pvaW5SZWYoKSlcbiAgICB9XG5cbiAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICAvLyBEZXN0cm95IGpvaW5QdXNoIHRvIGF2b2lkIGNvbm5lY3Rpb24gdGltZW91dHMgZHVyaW5nIHVuc2NyaXB0aW9uIHBoYXNlXG4gICAgdGhpcy5qb2luUHVzaC5kZXN0cm95KClcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIHt9LCB0aW1lb3V0KVxuICAgICAgbGVhdmVQdXNoXG4gICAgICAgIC5yZWNlaXZlKCdvaycsICgpID0+IHtcbiAgICAgICAgICBvbkNsb3NlKClcbiAgICAgICAgICByZXNvbHZlKCdvaycpXG4gICAgICAgIH0pXG4gICAgICAgIC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgICAgIG9uQ2xvc2UoKVxuICAgICAgICAgIHJlc29sdmUoJ3RpbWVkIG91dCcpXG4gICAgICAgIH0pXG4gICAgICAgIC5yZWNlaXZlKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCdlcnJvcicpXG4gICAgICAgIH0pXG5cbiAgICAgIGxlYXZlUHVzaC5zZW5kKClcbiAgICAgIGlmICghdGhpcy5fY2FuUHVzaCgpKSB7XG4gICAgICAgIGxlYXZlUHVzaC50cmlnZ2VyKCdvaycsIHt9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG5cbiAgYXN5bmMgX2ZldGNoV2l0aFRpbWVvdXQoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgb3B0aW9uczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSxcbiAgICB0aW1lb3V0OiBudW1iZXJcbiAgKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIGNvbnN0IGlkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpXG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc29ja2V0LmZldGNoKHVybCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgfSlcblxuICAgIGNsZWFyVGltZW91dChpZClcblxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcHVzaChcbiAgICBldmVudDogc3RyaW5nLFxuICAgIHBheWxvYWQ6IHsgW2tleTogc3RyaW5nXTogYW55IH0sXG4gICAgdGltZW91dCA9IHRoaXMudGltZW91dFxuICApIHtcbiAgICBpZiAoIXRoaXMuam9pbmVkT25jZSkge1xuICAgICAgdGhyb3cgYHRyaWVkIHRvIHB1c2ggJyR7ZXZlbnR9JyB0byAnJHt0aGlzLnRvcGljfScgYmVmb3JlIGpvaW5pbmcuIFVzZSBjaGFubmVsLnN1YnNjcmliZSgpIGJlZm9yZSBwdXNoaW5nIGV2ZW50c2BcbiAgICB9XG4gICAgbGV0IHB1c2hFdmVudCA9IG5ldyBQdXNoKHRoaXMsIGV2ZW50LCBwYXlsb2FkLCB0aW1lb3V0KVxuICAgIGlmICh0aGlzLl9jYW5QdXNoKCkpIHtcbiAgICAgIHB1c2hFdmVudC5zZW5kKClcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaEV2ZW50LnN0YXJ0VGltZW91dCgpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIucHVzaChwdXNoRXZlbnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHB1c2hFdmVudFxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRhYmxlIG1lc3NhZ2UgaG9va1xuICAgKlxuICAgKiBSZWNlaXZlcyBhbGwgZXZlbnRzIGZvciBzcGVjaWFsaXplZCBtZXNzYWdlIGhhbmRsaW5nIGJlZm9yZSBkaXNwYXRjaGluZyB0byB0aGUgY2hhbm5lbCBjYWxsYmFja3MuXG4gICAqIE11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9vbk1lc3NhZ2UoX2V2ZW50OiBzdHJpbmcsIHBheWxvYWQ6IGFueSwgX3JlZj86IHN0cmluZykge1xuICAgIHJldHVybiBwYXlsb2FkXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9pc01lbWJlcih0b3BpYzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudG9waWMgPT09IHRvcGljXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9qb2luUmVmKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuam9pblB1c2gucmVmXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF90cmlnZ2VyKHR5cGU6IHN0cmluZywgcGF5bG9hZD86IGFueSwgcmVmPzogc3RyaW5nKSB7XG4gICAgY29uc3QgdHlwZUxvd2VyID0gdHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpXG4gICAgY29uc3QgeyBjbG9zZSwgZXJyb3IsIGxlYXZlLCBqb2luIH0gPSBDSEFOTkVMX0VWRU5UU1xuICAgIGNvbnN0IGV2ZW50czogc3RyaW5nW10gPSBbY2xvc2UsIGVycm9yLCBsZWF2ZSwgam9pbl1cbiAgICBpZiAocmVmICYmIGV2ZW50cy5pbmRleE9mKHR5cGVMb3dlcikgPj0gMCAmJiByZWYgIT09IHRoaXMuX2pvaW5SZWYoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGxldCBoYW5kbGVkUGF5bG9hZCA9IHRoaXMuX29uTWVzc2FnZSh0eXBlTG93ZXIsIHBheWxvYWQsIHJlZilcbiAgICBpZiAocGF5bG9hZCAmJiAhaGFuZGxlZFBheWxvYWQpIHtcbiAgICAgIHRocm93ICdjaGFubmVsIG9uTWVzc2FnZSBjYWxsYmFja3MgbXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWQnXG4gICAgfVxuXG4gICAgaWYgKFsnaW5zZXJ0JywgJ3VwZGF0ZScsICdkZWxldGUnXS5pbmNsdWRlcyh0eXBlTG93ZXIpKSB7XG4gICAgICB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXNcbiAgICAgICAgPy5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgYmluZC5maWx0ZXI/LmV2ZW50ID09PSAnKicgfHxcbiAgICAgICAgICAgIGJpbmQuZmlsdGVyPy5ldmVudD8udG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0gdHlwZUxvd2VyXG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgICAubWFwKChiaW5kKSA9PiBiaW5kLmNhbGxiYWNrKGhhbmRsZWRQYXlsb2FkLCByZWYpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl1cbiAgICAgICAgPy5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBbJ2Jyb2FkY2FzdCcsICdwcmVzZW5jZScsICdwb3N0Z3Jlc19jaGFuZ2VzJ10uaW5jbHVkZXModHlwZUxvd2VyKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKCdpZCcgaW4gYmluZCkge1xuICAgICAgICAgICAgICBjb25zdCBiaW5kSWQgPSBiaW5kLmlkXG4gICAgICAgICAgICAgIGNvbnN0IGJpbmRFdmVudCA9IGJpbmQuZmlsdGVyPy5ldmVudFxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIGJpbmRJZCAmJlxuICAgICAgICAgICAgICAgIHBheWxvYWQuaWRzPy5pbmNsdWRlcyhiaW5kSWQpICYmXG4gICAgICAgICAgICAgICAgKGJpbmRFdmVudCA9PT0gJyonIHx8XG4gICAgICAgICAgICAgICAgICBiaW5kRXZlbnQ/LnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuZGF0YT8udHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBiaW5kRXZlbnQgPSBiaW5kPy5maWx0ZXI/LmV2ZW50Py50b0xvY2FsZUxvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgYmluZEV2ZW50ID09PSAnKicgfHxcbiAgICAgICAgICAgICAgICBiaW5kRXZlbnQgPT09IHBheWxvYWQ/LmV2ZW50Py50b0xvY2FsZUxvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmQudHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSB0eXBlTG93ZXJcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5tYXAoKGJpbmQpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZWRQYXlsb2FkID09PSAnb2JqZWN0JyAmJiAnaWRzJyBpbiBoYW5kbGVkUGF5bG9hZCkge1xuICAgICAgICAgICAgY29uc3QgcG9zdGdyZXNDaGFuZ2VzID0gaGFuZGxlZFBheWxvYWQuZGF0YVxuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWEsIHRhYmxlLCBjb21taXRfdGltZXN0YW1wLCB0eXBlLCBlcnJvcnMgfSA9XG4gICAgICAgICAgICAgIHBvc3RncmVzQ2hhbmdlc1xuICAgICAgICAgICAgY29uc3QgZW5yaWNoZWRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICBzY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgICBjb21taXRfdGltZXN0YW1wOiBjb21taXRfdGltZXN0YW1wLFxuICAgICAgICAgICAgICBldmVudFR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIG5ldzoge30sXG4gICAgICAgICAgICAgIG9sZDoge30sXG4gICAgICAgICAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlZFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgIC4uLmVucmljaGVkUGF5bG9hZCxcbiAgICAgICAgICAgICAgLi4udGhpcy5fZ2V0UGF5bG9hZFJlY29yZHMocG9zdGdyZXNDaGFuZ2VzKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmKVxuICAgICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2lzQ2xvc2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2lzSm9pbmVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luZWRcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2lzSm9pbmluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmluZ1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaXNMZWF2aW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9yZXBseUV2ZW50TmFtZShyZWY6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBjaGFuX3JlcGx5XyR7cmVmfWBcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX29uKHR5cGU6IHN0cmluZywgZmlsdGVyOiB7IFtrZXk6IHN0cmluZ106IGFueSB9LCBjYWxsYmFjazogRnVuY3Rpb24pIHtcbiAgICBjb25zdCB0eXBlTG93ZXIgPSB0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKClcblxuICAgIGNvbnN0IGJpbmRpbmcgPSB7XG4gICAgICB0eXBlOiB0eXBlTG93ZXIsXG4gICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdKSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0ucHVzaChiaW5kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0gPSBbYmluZGluZ11cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfb2ZmKHR5cGU6IHN0cmluZywgZmlsdGVyOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KSB7XG4gICAgY29uc3QgdHlwZUxvd2VyID0gdHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpXG5cbiAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0gPSB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0uZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICByZXR1cm4gIShcbiAgICAgICAgYmluZC50eXBlPy50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSB0eXBlTG93ZXIgJiZcbiAgICAgICAgUmVhbHRpbWVDaGFubmVsLmlzRXF1YWwoYmluZC5maWx0ZXIsIGZpbHRlcilcbiAgICAgIClcbiAgICB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgc3RhdGljIGlzRXF1YWwoXG4gICAgb2JqMTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSxcbiAgICBvYmoyOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gICkge1xuICAgIGlmIChPYmplY3Qua2V5cyhvYmoxKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG9iajIpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrIGluIG9iajEpIHtcbiAgICAgIGlmIChvYmoxW2tdICE9PSBvYmoyW2tdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX3Jlam9pblVudGlsQ29ubmVjdGVkKCkge1xuICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KClcbiAgICBpZiAodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgdGhpcy5fcmVqb2luKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYW5uZWwgY2xvc2VzLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgX29uQ2xvc2UoY2FsbGJhY2s6IEZ1bmN0aW9uKSB7XG4gICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIHt9LCBjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2hhbm5lbCBlbmNvdW50ZXJlcyBhbiBlcnJvci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIF9vbkVycm9yKGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIHRoaXMuX29uKENIQU5ORUxfRVZFTlRTLmVycm9yLCB7fSwgKHJlYXNvbjogc3RyaW5nKSA9PiBjYWxsYmFjayhyZWFzb24pKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzb2NrZXQgaXMgY29ubmVjdGVkIGFuZCB0aGUgY2hhbm5lbCBoYXMgYmVlbiBqb2luZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBfY2FuUHVzaCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLl9pc0pvaW5lZCgpXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX3Jlam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2lzTGVhdmluZygpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5zb2NrZXQuX2xlYXZlT3BlblRvcGljKHRoaXMudG9waWMpXG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5pbmdcbiAgICB0aGlzLmpvaW5QdXNoLnJlc2VuZCh0aW1lb3V0KVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9nZXRQYXlsb2FkUmVjb3JkcyhwYXlsb2FkOiBhbnkpIHtcbiAgICBjb25zdCByZWNvcmRzID0ge1xuICAgICAgbmV3OiB7fSxcbiAgICAgIG9sZDoge30sXG4gICAgfVxuXG4gICAgaWYgKHBheWxvYWQudHlwZSA9PT0gJ0lOU0VSVCcgfHwgcGF5bG9hZC50eXBlID09PSAnVVBEQVRFJykge1xuICAgICAgcmVjb3Jkcy5uZXcgPSBUcmFuc2Zvcm1lcnMuY29udmVydENoYW5nZURhdGEoXG4gICAgICAgIHBheWxvYWQuY29sdW1ucyxcbiAgICAgICAgcGF5bG9hZC5yZWNvcmRcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAocGF5bG9hZC50eXBlID09PSAnVVBEQVRFJyB8fCBwYXlsb2FkLnR5cGUgPT09ICdERUxFVEUnKSB7XG4gICAgICByZWNvcmRzLm9sZCA9IFRyYW5zZm9ybWVycy5jb252ZXJ0Q2hhbmdlRGF0YShcbiAgICAgICAgcGF5bG9hZC5jb2x1bW5zLFxuICAgICAgICBwYXlsb2FkLm9sZF9yZWNvcmRcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjb3Jkc1xuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBXZWJTb2NrZXQgYXMgV1NXZWJTb2NrZXQgfSBmcm9tICd3cydcblxuaW1wb3J0IHtcbiAgQ0hBTk5FTF9FVkVOVFMsXG4gIENPTk5FQ1RJT05fU1RBVEUsXG4gIERFRkFVTFRfSEVBREVSUyxcbiAgREVGQVVMVF9USU1FT1VULFxuICBTT0NLRVRfU1RBVEVTLFxuICBUUkFOU1BPUlRTLFxuICBWU04sXG4gIFdTX0NMT1NFX05PUk1BTCxcbn0gZnJvbSAnLi9saWIvY29uc3RhbnRzJ1xuaW1wb3J0IFNlcmlhbGl6ZXIgZnJvbSAnLi9saWIvc2VyaWFsaXplcidcbmltcG9ydCBUaW1lciBmcm9tICcuL2xpYi90aW1lcidcblxuaW1wb3J0IHsgaHR0cEVuZHBvaW50VVJMIH0gZnJvbSAnLi9saWIvdHJhbnNmb3JtZXJzJ1xuaW1wb3J0IFJlYWx0aW1lQ2hhbm5lbCBmcm9tICcuL1JlYWx0aW1lQ2hhbm5lbCdcbmltcG9ydCB0eXBlIHsgUmVhbHRpbWVDaGFubmVsT3B0aW9ucyB9IGZyb20gJy4vUmVhbHRpbWVDaGFubmVsJ1xuXG50eXBlIEZldGNoID0gdHlwZW9mIGZldGNoXG5cbmV4cG9ydCB0eXBlIENoYW5uZWwgPSB7XG4gIG5hbWU6IHN0cmluZ1xuICBpbnNlcnRlZF9hdDogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xuICBpZDogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lQ2xpZW50T3B0aW9ucyA9IHtcbiAgdHJhbnNwb3J0PzogV2ViU29ja2V0TGlrZUNvbnN0cnVjdG9yXG4gIHRpbWVvdXQ/OiBudW1iZXJcbiAgaGVhcnRiZWF0SW50ZXJ2YWxNcz86IG51bWJlclxuICBsb2dnZXI/OiBGdW5jdGlvblxuICBlbmNvZGU/OiBGdW5jdGlvblxuICBkZWNvZGU/OiBGdW5jdGlvblxuICByZWNvbm5lY3RBZnRlck1zPzogRnVuY3Rpb25cbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgcGFyYW1zPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICBsb2dfbGV2ZWw/OiAnaW5mbycgfCAnZGVidWcnIHwgJ3dhcm4nIHwgJ2Vycm9yJ1xuICBmZXRjaD86IEZldGNoXG4gIHdvcmtlcj86IGJvb2xlYW5cbiAgd29ya2VyVXJsPzogc3RyaW5nXG4gIGFjY2Vzc1Rva2VuPzogKCkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsPlxufVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZU1lc3NhZ2UgPSB7XG4gIHRvcGljOiBzdHJpbmdcbiAgZXZlbnQ6IHN0cmluZ1xuICBwYXlsb2FkOiBhbnlcbiAgcmVmOiBzdHJpbmdcbiAgam9pbl9yZWY/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVSZW1vdmVDaGFubmVsUmVzcG9uc2UgPSAnb2snIHwgJ3RpbWVkIG91dCcgfCAnZXJyb3InXG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFdlYlNvY2tldExpa2VDb25zdHJ1Y3RvciB7XG4gIG5ldyAoXG4gICAgYWRkcmVzczogc3RyaW5nIHwgVVJMLFxuICAgIF9pZ25vcmVkPzogYW55LFxuICAgIG9wdGlvbnM/OiB7IGhlYWRlcnM6IE9iamVjdCB8IHVuZGVmaW5lZCB9XG4gICk6IFdlYlNvY2tldExpa2Vcbn1cblxuZXhwb3J0IHR5cGUgV2ViU29ja2V0TGlrZSA9IFdlYlNvY2tldCB8IFdTV2ViU29ja2V0IHwgV1NXZWJTb2NrZXREdW1teVxuXG5leHBvcnQgaW50ZXJmYWNlIFdlYlNvY2tldExpa2VFcnJvciB7XG4gIGVycm9yOiBhbnlcbiAgbWVzc2FnZTogc3RyaW5nXG4gIHR5cGU6IHN0cmluZ1xufVxuXG5jb25zdCBOQVRJVkVfV0VCU09DS0VUX0FWQUlMQUJMRSA9IHR5cGVvZiBXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnXG5jb25zdCBXT1JLRVJfU0NSSVBUID0gYFxuICBhZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZSkgPT4ge1xuICAgIGlmIChlLmRhdGEuZXZlbnQgPT09IFwic3RhcnRcIikge1xuICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gcG9zdE1lc3NhZ2UoeyBldmVudDogXCJrZWVwQWxpdmVcIiB9KSwgZS5kYXRhLmludGVydmFsKTtcbiAgICB9XG4gIH0pO2BcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWx0aW1lQ2xpZW50IHtcbiAgYWNjZXNzVG9rZW5WYWx1ZTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgYXBpS2V5OiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICBjaGFubmVsczogUmVhbHRpbWVDaGFubmVsW10gPSBbXVxuICBlbmRQb2ludDogc3RyaW5nID0gJydcbiAgaHR0cEVuZHBvaW50OiBzdHJpbmcgPSAnJ1xuICBoZWFkZXJzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IERFRkFVTFRfSEVBREVSU1xuICBwYXJhbXM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge31cbiAgdGltZW91dDogbnVtYmVyID0gREVGQVVMVF9USU1FT1VUXG4gIHRyYW5zcG9ydDogV2ViU29ja2V0TGlrZUNvbnN0cnVjdG9yIHwgbnVsbFxuICBoZWFydGJlYXRJbnRlcnZhbE1zOiBudW1iZXIgPSAzMDAwMFxuICBoZWFydGJlYXRUaW1lcjogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gIHBlbmRpbmdIZWFydGJlYXRSZWY6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gIHJlZjogbnVtYmVyID0gMFxuICByZWNvbm5lY3RUaW1lcjogVGltZXJcbiAgbG9nZ2VyOiBGdW5jdGlvbiA9IG5vb3BcbiAgZW5jb2RlOiBGdW5jdGlvblxuICBkZWNvZGU6IEZ1bmN0aW9uXG4gIHJlY29ubmVjdEFmdGVyTXM6IEZ1bmN0aW9uXG4gIGNvbm46IFdlYlNvY2tldExpa2UgfCBudWxsID0gbnVsbFxuICBzZW5kQnVmZmVyOiBGdW5jdGlvbltdID0gW11cbiAgc2VyaWFsaXplcjogU2VyaWFsaXplciA9IG5ldyBTZXJpYWxpemVyKClcbiAgc3RhdGVDaGFuZ2VDYWxsYmFja3M6IHtcbiAgICBvcGVuOiBGdW5jdGlvbltdXG4gICAgY2xvc2U6IEZ1bmN0aW9uW11cbiAgICBlcnJvcjogRnVuY3Rpb25bXVxuICAgIG1lc3NhZ2U6IEZ1bmN0aW9uW11cbiAgfSA9IHtcbiAgICBvcGVuOiBbXSxcbiAgICBjbG9zZTogW10sXG4gICAgZXJyb3I6IFtdLFxuICAgIG1lc3NhZ2U6IFtdLFxuICB9XG4gIGZldGNoOiBGZXRjaFxuICBhY2Nlc3NUb2tlbjogKCgpID0+IFByb21pc2U8c3RyaW5nIHwgbnVsbD4pIHwgbnVsbCA9IG51bGxcbiAgd29ya2VyPzogYm9vbGVhblxuICB3b3JrZXJVcmw/OiBzdHJpbmdcbiAgd29ya2VyUmVmPzogV29ya2VyXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBlbmRQb2ludCBUaGUgc3RyaW5nIFdlYlNvY2tldCBlbmRwb2ludCwgaWUsIFwid3M6Ly9leGFtcGxlLmNvbS9zb2NrZXRcIiwgXCJ3c3M6Ly9leGFtcGxlLmNvbVwiLCBcIi9zb2NrZXRcIiAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAgICogQHBhcmFtIGh0dHBFbmRwb2ludCBUaGUgc3RyaW5nIEhUVFAgZW5kcG9pbnQsIGllLCBcImh0dHBzOi8vZXhhbXBsZS5jb21cIiwgXCIvXCIgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zcG9ydCBUaGUgV2Vic29ja2V0IFRyYW5zcG9ydCwgZm9yIGV4YW1wbGUgV2ViU29ja2V0LlxuICAgKiBAcGFyYW0gb3B0aW9ucy50aW1lb3V0IFRoZSBkZWZhdWx0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHRyaWdnZXIgcHVzaCB0aW1lb3V0cy5cbiAgICogQHBhcmFtIG9wdGlvbnMucGFyYW1zIFRoZSBvcHRpb25hbCBwYXJhbXMgdG8gcGFzcyB3aGVuIGNvbm5lY3RpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgVGhlIG9wdGlvbmFsIGhlYWRlcnMgdG8gcGFzcyB3aGVuIGNvbm5lY3RpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zLmhlYXJ0YmVhdEludGVydmFsTXMgVGhlIG1pbGxpc2VjIGludGVydmFsIHRvIHNlbmQgYSBoZWFydGJlYXQgbWVzc2FnZS5cbiAgICogQHBhcmFtIG9wdGlvbnMubG9nZ2VyIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZywgaWU6IGxvZ2dlcjogKGtpbmQsIG1zZywgZGF0YSkgPT4geyBjb25zb2xlLmxvZyhgJHtraW5kfTogJHttc2d9YCwgZGF0YSkgfVxuICAgKiBAcGFyYW0gb3B0aW9ucy5lbmNvZGUgVGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBvdXRnb2luZyBtZXNzYWdlcy4gRGVmYXVsdHMgdG8gSlNPTjogKHBheWxvYWQsIGNhbGxiYWNrKSA9PiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSlcbiAgICogQHBhcmFtIG9wdGlvbnMuZGVjb2RlIFRoZSBmdW5jdGlvbiB0byBkZWNvZGUgaW5jb21pbmcgbWVzc2FnZXMuIERlZmF1bHRzIHRvIFNlcmlhbGl6ZXIncyBkZWNvZGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlY29ubmVjdEFmdGVyTXMgaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsc2VjIHJlY29ubmVjdCBpbnRlcnZhbC4gRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mZi5cbiAgICogQHBhcmFtIG9wdGlvbnMud29ya2VyIFVzZSBXZWIgV29ya2VyIHRvIHNldCBhIHNpZGUgZmxvdy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqIEBwYXJhbSBvcHRpb25zLndvcmtlclVybCBUaGUgVVJMIG9mIHRoZSB3b3JrZXIgc2NyaXB0LiBEZWZhdWx0cyB0byBodHRwczovL3JlYWx0aW1lLnN1cGFiYXNlLmNvbS93b3JrZXIuanMgdGhhdCBpbmNsdWRlcyBhIGhlYXJ0YmVhdCBldmVudCBjYWxsIHRvIGtlZXAgdGhlIGNvbm5lY3Rpb24gYWxpdmUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbmRQb2ludDogc3RyaW5nLCBvcHRpb25zPzogUmVhbHRpbWVDbGllbnRPcHRpb25zKSB7XG4gICAgdGhpcy5lbmRQb2ludCA9IGAke2VuZFBvaW50fS8ke1RSQU5TUE9SVFMud2Vic29ja2V0fWBcbiAgICB0aGlzLmh0dHBFbmRwb2ludCA9IGh0dHBFbmRwb2ludFVSTChlbmRQb2ludClcbiAgICBpZiAob3B0aW9ucz8udHJhbnNwb3J0KSB7XG4gICAgICB0aGlzLnRyYW5zcG9ydCA9IG9wdGlvbnMudHJhbnNwb3J0XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbFxuICAgIH1cbiAgICBpZiAob3B0aW9ucz8ucGFyYW1zKSB0aGlzLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zXG4gICAgaWYgKG9wdGlvbnM/LmhlYWRlcnMpIHRoaXMuaGVhZGVycyA9IHsgLi4udGhpcy5oZWFkZXJzLCAuLi5vcHRpb25zLmhlYWRlcnMgfVxuICAgIGlmIChvcHRpb25zPy50aW1lb3V0KSB0aGlzLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXRcbiAgICBpZiAob3B0aW9ucz8ubG9nZ2VyKSB0aGlzLmxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyXG4gICAgaWYgKG9wdGlvbnM/LmhlYXJ0YmVhdEludGVydmFsTXMpXG4gICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMgPSBvcHRpb25zLmhlYXJ0YmVhdEludGVydmFsTXNcblxuICAgIGNvbnN0IGFjY2Vzc1Rva2VuVmFsdWUgPSBvcHRpb25zPy5wYXJhbXM/LmFwaWtleVxuICAgIGlmIChhY2Nlc3NUb2tlblZhbHVlKSB7XG4gICAgICB0aGlzLmFjY2Vzc1Rva2VuVmFsdWUgPSBhY2Nlc3NUb2tlblZhbHVlXG4gICAgICB0aGlzLmFwaUtleSA9IGFjY2Vzc1Rva2VuVmFsdWVcbiAgICB9XG5cbiAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPSBvcHRpb25zPy5yZWNvbm5lY3RBZnRlck1zXG4gICAgICA/IG9wdGlvbnMucmVjb25uZWN0QWZ0ZXJNc1xuICAgICAgOiAodHJpZXM6IG51bWJlcikgPT4ge1xuICAgICAgICAgIHJldHVybiBbMTAwMCwgMjAwMCwgNTAwMCwgMTAwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAgICAgICAgfVxuICAgIHRoaXMuZW5jb2RlID0gb3B0aW9ucz8uZW5jb2RlXG4gICAgICA/IG9wdGlvbnMuZW5jb2RlXG4gICAgICA6IChwYXlsb2FkOiBKU09OLCBjYWxsYmFjazogRnVuY3Rpb24pID0+IHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpXG4gICAgICAgIH1cbiAgICB0aGlzLmRlY29kZSA9IG9wdGlvbnM/LmRlY29kZVxuICAgICAgPyBvcHRpb25zLmRlY29kZVxuICAgICAgOiB0aGlzLnNlcmlhbGl6ZXIuZGVjb2RlLmJpbmQodGhpcy5zZXJpYWxpemVyKVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICAgIHRoaXMuY29ubmVjdCgpXG4gICAgfSwgdGhpcy5yZWNvbm5lY3RBZnRlck1zKVxuXG4gICAgdGhpcy5mZXRjaCA9IHRoaXMuX3Jlc29sdmVGZXRjaChvcHRpb25zPy5mZXRjaClcbiAgICBpZiAob3B0aW9ucz8ud29ya2VyKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5Xb3JrZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWIgV29ya2VyIGlzIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgfVxuICAgICAgdGhpcy53b3JrZXIgPSBvcHRpb25zPy53b3JrZXIgfHwgZmFsc2VcbiAgICAgIHRoaXMud29ya2VyVXJsID0gb3B0aW9ucz8ud29ya2VyVXJsXG4gICAgfVxuICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBvcHRpb25zPy5hY2Nlc3NUb2tlbiB8fCBudWxsXG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdHMgdGhlIHNvY2tldCwgdW5sZXNzIGFscmVhZHkgY29ubmVjdGVkLlxuICAgKi9cbiAgY29ubmVjdCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICAgIHRoaXMuY29ubiA9IG5ldyB0aGlzLnRyYW5zcG9ydCh0aGlzLmVuZHBvaW50VVJMKCksIHVuZGVmaW5lZCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKE5BVElWRV9XRUJTT0NLRVRfQVZBSUxBQkxFKSB7XG4gICAgICB0aGlzLmNvbm4gPSBuZXcgV2ViU29ja2V0KHRoaXMuZW5kcG9pbnRVUkwoKSlcbiAgICAgIHRoaXMuc2V0dXBDb25uZWN0aW9uKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY29ubiA9IG5ldyBXU1dlYlNvY2tldER1bW15KHRoaXMuZW5kcG9pbnRVUkwoKSwgdW5kZWZpbmVkLCB7XG4gICAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgICB0aGlzLmNvbm4gPSBudWxsXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICBpbXBvcnQoJ3dzJykudGhlbigoeyBkZWZhdWx0OiBXUyB9KSA9PiB7XG4gICAgICB0aGlzLmNvbm4gPSBuZXcgV1ModGhpcy5lbmRwb2ludFVSTCgpLCB1bmRlZmluZWQsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgfSlcbiAgICAgIHRoaXMuc2V0dXBDb25uZWN0aW9uKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFVSTCBvZiB0aGUgd2Vic29ja2V0LlxuICAgKiBAcmV0dXJucyBzdHJpbmcgVGhlIFVSTCBvZiB0aGUgd2Vic29ja2V0LlxuICAgKi9cbiAgZW5kcG9pbnRVUkwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fYXBwZW5kUGFyYW1zKFxuICAgICAgdGhpcy5lbmRQb2ludCxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGFyYW1zLCB7IHZzbjogVlNOIH0pXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBjb2RlIEEgbnVtZXJpYyBzdGF0dXMgY29kZSB0byBzZW5kIG9uIGRpc2Nvbm5lY3QuXG4gICAqIEBwYXJhbSByZWFzb24gQSBjdXN0b20gcmVhc29uIGZvciB0aGUgZGlzY29ubmVjdC5cbiAgICovXG4gIGRpc2Nvbm5lY3QoY29kZT86IG51bWJlciwgcmVhc29uPzogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7fSAvLyBub29wXG4gICAgICBpZiAoY29kZSkge1xuICAgICAgICB0aGlzLmNvbm4uY2xvc2UoY29kZSwgcmVhc29uID8/ICcnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb25uLmNsb3NlKClcbiAgICAgIH1cbiAgICAgIHRoaXMuY29ubiA9IG51bGxcbiAgICAgIC8vIHJlbW92ZSBvcGVuIGhhbmRsZXNcbiAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKVxuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGNyZWF0ZWQgY2hhbm5lbHNcbiAgICovXG4gIGdldENoYW5uZWxzKCk6IFJlYWx0aW1lQ2hhbm5lbFtdIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsc1xuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhIHNpbmdsZSBjaGFubmVsXG4gICAqIEBwYXJhbSBjaGFubmVsIEEgUmVhbHRpbWVDaGFubmVsIGluc3RhbmNlXG4gICAqL1xuICBhc3luYyByZW1vdmVDaGFubmVsKFxuICAgIGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbFxuICApOiBQcm9taXNlPFJlYWx0aW1lUmVtb3ZlQ2hhbm5lbFJlc3BvbnNlPiB7XG4gICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgY2hhbm5lbC51bnN1YnNjcmliZSgpXG4gICAgaWYgKHRoaXMuY2hhbm5lbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIH1cbiAgICByZXR1cm4gc3RhdHVzXG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIGFsbCBjaGFubmVsc1xuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQWxsQ2hhbm5lbHMoKTogUHJvbWlzZTxSZWFsdGltZVJlbW92ZUNoYW5uZWxSZXNwb25zZVtdPiB7XG4gICAgY29uc3QgdmFsdWVzXzEgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMuY2hhbm5lbHMubWFwKChjaGFubmVsKSA9PiBjaGFubmVsLnVuc3Vic2NyaWJlKCkpXG4gICAgKVxuICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgcmV0dXJuIHZhbHVlc18xXG4gIH1cblxuICAvKipcbiAgICogTG9ncyB0aGUgbWVzc2FnZS5cbiAgICpcbiAgICogRm9yIGN1c3RvbWl6ZWQgbG9nZ2luZywgYHRoaXMubG9nZ2VyYCBjYW4gYmUgb3ZlcnJpZGRlbi5cbiAgICovXG4gIGxvZyhraW5kOiBzdHJpbmcsIG1zZzogc3RyaW5nLCBkYXRhPzogYW55KSB7XG4gICAgdGhpcy5sb2dnZXIoa2luZCwgbXNnLCBkYXRhKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNvY2tldC5cbiAgICovXG4gIGNvbm5lY3Rpb25TdGF0ZSgpOiBDT05ORUNUSU9OX1NUQVRFIHtcbiAgICBzd2l0Y2ggKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4ucmVhZHlTdGF0ZSkge1xuICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLmNvbm5lY3Rpbmc6XG4gICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLkNvbm5lY3RpbmdcbiAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5vcGVuOlxuICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5PcGVuXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY2xvc2luZzpcbiAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuQ2xvc2luZ1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuQ2xvc2VkXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlzIHRoZSBjb25uZWN0aW9uIGlzIG9wZW4uXG4gICAqL1xuICBpc0Nvbm5lY3RlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uU3RhdGUoKSA9PT0gQ09OTkVDVElPTl9TVEFURS5PcGVuXG4gIH1cblxuICBjaGFubmVsKFxuICAgIHRvcGljOiBzdHJpbmcsXG4gICAgcGFyYW1zOiBSZWFsdGltZUNoYW5uZWxPcHRpb25zID0geyBjb25maWc6IHt9IH1cbiAgKTogUmVhbHRpbWVDaGFubmVsIHtcbiAgICBjb25zdCBjaGFuID0gbmV3IFJlYWx0aW1lQ2hhbm5lbChgcmVhbHRpbWU6JHt0b3BpY31gLCBwYXJhbXMsIHRoaXMpXG4gICAgdGhpcy5jaGFubmVscy5wdXNoKGNoYW4pXG4gICAgcmV0dXJuIGNoYW5cbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIG91dCBhIG1lc3NhZ2UgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQuXG4gICAqXG4gICAqIElmIHRoZSBzb2NrZXQgaXMgbm90IGNvbm5lY3RlZCwgdGhlIG1lc3NhZ2UgZ2V0cyBlbnF1ZXVlZCB3aXRoaW4gYSBsb2NhbCBidWZmZXIsIGFuZCBzZW50IG91dCB3aGVuIGEgY29ubmVjdGlvbiBpcyBuZXh0IGVzdGFibGlzaGVkLlxuICAgKi9cbiAgcHVzaChkYXRhOiBSZWFsdGltZU1lc3NhZ2UpOiB2b2lkIHtcbiAgICBjb25zdCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmIH0gPSBkYXRhXG4gICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLmVuY29kZShkYXRhLCAocmVzdWx0OiBhbnkpID0+IHtcbiAgICAgICAgdGhpcy5jb25uPy5zZW5kKHJlc3VsdClcbiAgICAgIH0pXG4gICAgfVxuICAgIHRoaXMubG9nKCdwdXNoJywgYCR7dG9waWN9ICR7ZXZlbnR9ICgke3JlZn0pYCwgcGF5bG9hZClcbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICBjYWxsYmFjaygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBKV1QgYWNjZXNzIHRva2VuIHVzZWQgZm9yIGNoYW5uZWwgc3Vic2NyaXB0aW9uIGF1dGhvcml6YXRpb24gYW5kIFJlYWx0aW1lIFJMUy5cbiAgICpcbiAgICogSWYgcGFyYW0gaXMgbnVsbCBpdCB3aWxsIHVzZSB0aGUgYGFjY2Vzc1Rva2VuYCBjYWxsYmFjayBmdW5jdGlvbiBvciB0aGUgdG9rZW4gc2V0IG9uIHRoZSBjbGllbnQuXG4gICAqXG4gICAqIE9uIGNhbGxiYWNrIHVzZWQsIGl0IHdpbGwgc2V0IHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4gaW50ZXJuYWwgdG8gdGhlIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIHRva2VuIEEgSldUIHN0cmluZyB0byBvdmVycmlkZSB0aGUgdG9rZW4gc2V0IG9uIHRoZSBjbGllbnQuXG4gICAqL1xuICBhc3luYyBzZXRBdXRoKHRva2VuOiBzdHJpbmcgfCBudWxsID0gbnVsbCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCB0b2tlblRvU2VuZCA9XG4gICAgICB0b2tlbiB8fFxuICAgICAgKHRoaXMuYWNjZXNzVG9rZW4gJiYgKGF3YWl0IHRoaXMuYWNjZXNzVG9rZW4oKSkpIHx8XG4gICAgICB0aGlzLmFjY2Vzc1Rva2VuVmFsdWVcblxuICAgIGlmICh0b2tlblRvU2VuZCkge1xuICAgICAgbGV0IHBhcnNlZCA9IG51bGxcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UoYXRvYih0b2tlblRvU2VuZC5zcGxpdCgnLicpWzFdKSlcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIGlmIChwYXJzZWQgJiYgcGFyc2VkLmV4cCkge1xuICAgICAgICBsZXQgbm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMClcbiAgICAgICAgbGV0IHZhbGlkID0gbm93IC0gcGFyc2VkLmV4cCA8IDBcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgICAgJ2F1dGgnLFxuICAgICAgICAgICAgYEludmFsaWRKV1RUb2tlbjogSW52YWxpZCB2YWx1ZSBmb3IgSldUIGNsYWltIFwiZXhwXCIgd2l0aCB2YWx1ZSAke3BhcnNlZC5leHB9YFxuICAgICAgICAgIClcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICBgSW52YWxpZEpXVFRva2VuOiBJbnZhbGlkIHZhbHVlIGZvciBKV1QgY2xhaW0gXCJleHBcIiB3aXRoIHZhbHVlICR7cGFyc2VkLmV4cH1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWNjZXNzVG9rZW5WYWx1ZSA9IHRva2VuVG9TZW5kXG4gICAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IHtcbiAgICAgICAgdG9rZW5Ub1NlbmQgJiYgY2hhbm5lbC51cGRhdGVKb2luUGF5bG9hZCh7IGFjY2Vzc190b2tlbjogdG9rZW5Ub1NlbmQgfSlcblxuICAgICAgICBpZiAoY2hhbm5lbC5qb2luZWRPbmNlICYmIGNoYW5uZWwuX2lzSm9pbmVkKCkpIHtcbiAgICAgICAgICBjaGFubmVsLl9wdXNoKENIQU5ORUxfRVZFTlRTLmFjY2Vzc190b2tlbiwge1xuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB0b2tlblRvU2VuZCxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2VuZHMgYSBoZWFydGJlYXQgbWVzc2FnZSBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZC5cbiAgICovXG4gIGFzeW5jIHNlbmRIZWFydGJlYXQoKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKSB7XG4gICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgICB0aGlzLmxvZyhcbiAgICAgICAgJ3RyYW5zcG9ydCcsXG4gICAgICAgICdoZWFydGJlYXQgdGltZW91dC4gQXR0ZW1wdGluZyB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvbidcbiAgICAgIClcbiAgICAgIHRoaXMuY29ubj8uY2xvc2UoV1NfQ0xPU0VfTk9STUFMLCAnaGVhcmJlYXQgdGltZW91dCcpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gdGhpcy5fbWFrZVJlZigpXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgIHRvcGljOiAncGhvZW5peCcsXG4gICAgICBldmVudDogJ2hlYXJ0YmVhdCcsXG4gICAgICBwYXlsb2FkOiB7fSxcbiAgICAgIHJlZjogdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmLFxuICAgIH0pXG4gICAgdGhpcy5zZXRBdXRoKClcbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaGVzIHNlbmQgYnVmZmVyXG4gICAqL1xuICBmbHVzaFNlbmRCdWZmZXIoKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zZW5kQnVmZmVyLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKVxuICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW11cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlIGVpdGhlciBjdXN0b20gZmV0Y2gsIGlmIHByb3ZpZGVkLCBvciBkZWZhdWx0IGZldGNoIHRvIG1ha2UgSFRUUCByZXF1ZXN0c1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9yZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2g/OiBGZXRjaCk6IEZldGNoID0+IHtcbiAgICBsZXQgX2ZldGNoOiBGZXRjaFxuICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgX2ZldGNoID0gY3VzdG9tRmV0Y2hcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIF9mZXRjaCA9ICguLi5hcmdzKSA9PlxuICAgICAgICBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJyBhcyBhbnkpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT5cbiAgICAgICAgICBmZXRjaCguLi5hcmdzKVxuICAgICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIF9mZXRjaCA9IGZldGNoXG4gICAgfVxuICAgIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuZXh0IG1lc3NhZ2UgcmVmLCBhY2NvdW50aW5nIGZvciBvdmVyZmxvd3NcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfbWFrZVJlZigpOiBzdHJpbmcge1xuICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZiArIDFcbiAgICBpZiAobmV3UmVmID09PSB0aGlzLnJlZikge1xuICAgICAgdGhpcy5yZWYgPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVmID0gbmV3UmVmXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVmLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBmcm9tIGNoYW5uZWxzIHdpdGggdGhlIHNwZWNpZmllZCB0b3BpYy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfbGVhdmVPcGVuVG9waWModG9waWM6IHN0cmluZyk6IHZvaWQge1xuICAgIGxldCBkdXBDaGFubmVsID0gdGhpcy5jaGFubmVscy5maW5kKFxuICAgICAgKGMpID0+IGMudG9waWMgPT09IHRvcGljICYmIChjLl9pc0pvaW5lZCgpIHx8IGMuX2lzSm9pbmluZygpKVxuICAgIClcbiAgICBpZiAoZHVwQ2hhbm5lbCkge1xuICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIGBsZWF2aW5nIGR1cGxpY2F0ZSB0b3BpYyBcIiR7dG9waWN9XCJgKVxuICAgICAgZHVwQ2hhbm5lbC51bnN1YnNjcmliZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBzdWJzY3JpcHRpb24gZnJvbSB0aGUgc29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gY2hhbm5lbCBBbiBvcGVuIHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfcmVtb3ZlKGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCkge1xuICAgIHRoaXMuY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzLmZpbHRlcihcbiAgICAgIChjOiBSZWFsdGltZUNoYW5uZWwpID0+IGMuX2pvaW5SZWYoKSAhPT0gY2hhbm5lbC5fam9pblJlZigpXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgY29ubmVjdGlvbiBoYW5kbGVycy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIHNldHVwQ29ubmVjdGlvbigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICB0aGlzLmNvbm4uYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLl9vbkNvbm5PcGVuKClcbiAgICAgIHRoaXMuY29ubi5vbmVycm9yID0gKGVycm9yOiBXZWJTb2NrZXRMaWtlRXJyb3IpID0+XG4gICAgICAgIHRoaXMuX29uQ29ubkVycm9yKGVycm9yIGFzIFdlYlNvY2tldExpa2VFcnJvcilcbiAgICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSAoZXZlbnQ6IGFueSkgPT4gdGhpcy5fb25Db25uTWVzc2FnZShldmVudClcbiAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gKGV2ZW50OiBhbnkpID0+IHRoaXMuX29uQ29ubkNsb3NlKGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfb25Db25uTWVzc2FnZShyYXdNZXNzYWdlOiB7IGRhdGE6IGFueSB9KSB7XG4gICAgdGhpcy5kZWNvZGUocmF3TWVzc2FnZS5kYXRhLCAobXNnOiBSZWFsdGltZU1lc3NhZ2UpID0+IHtcbiAgICAgIGxldCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmIH0gPSBtc2dcblxuICAgICAgaWYgKHJlZiAmJiByZWYgPT09IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZikge1xuICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nKFxuICAgICAgICAncmVjZWl2ZScsXG4gICAgICAgIGAke3BheWxvYWQuc3RhdHVzIHx8ICcnfSAke3RvcGljfSAke2V2ZW50fSAke1xuICAgICAgICAgIChyZWYgJiYgJygnICsgcmVmICsgJyknKSB8fCAnJ1xuICAgICAgICB9YCxcbiAgICAgICAgcGF5bG9hZFxuICAgICAgKVxuICAgICAgdGhpcy5jaGFubmVsc1xuICAgICAgICAuZmlsdGVyKChjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwpID0+IGNoYW5uZWwuX2lzTWVtYmVyKHRvcGljKSlcbiAgICAgICAgLmZvckVhY2goKGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCkgPT5cbiAgICAgICAgICBjaGFubmVsLl90cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYpXG4gICAgICAgIClcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZS5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2sobXNnKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIGFzeW5jIF9vbkNvbm5PcGVuKCkge1xuICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCBgY29ubmVjdGVkIHRvICR7dGhpcy5lbmRwb2ludFVSTCgpfWApXG4gICAgdGhpcy5mbHVzaFNlbmRCdWZmZXIoKVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKVxuICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHNldEludGVydmFsKFxuICAgICAgICAoKSA9PiB0aGlzLnNlbmRIZWFydGJlYXQoKSxcbiAgICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLndvcmtlclVybCkge1xuICAgICAgICB0aGlzLmxvZygnd29ya2VyJywgYHN0YXJ0aW5nIHdvcmtlciBmb3IgZnJvbSAke3RoaXMud29ya2VyVXJsfWApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZygnd29ya2VyJywgYHN0YXJ0aW5nIGRlZmF1bHQgd29ya2VyYClcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2JqZWN0VXJsID0gdGhpcy5fd29ya2VyT2JqZWN0VXJsKHRoaXMud29ya2VyVXJsISlcbiAgICAgIHRoaXMud29ya2VyUmVmID0gbmV3IFdvcmtlcihvYmplY3RVcmwpXG4gICAgICB0aGlzLndvcmtlclJlZi5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKCd3b3JrZXInLCAnd29ya2VyIGVycm9yJywgZXJyb3IubWVzc2FnZSlcbiAgICAgICAgdGhpcy53b3JrZXJSZWYhLnRlcm1pbmF0ZSgpXG4gICAgICB9XG4gICAgICB0aGlzLndvcmtlclJlZi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEuZXZlbnQgPT09ICdrZWVwQWxpdmUnKSB7XG4gICAgICAgICAgdGhpcy5zZW5kSGVhcnRiZWF0KClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy53b3JrZXJSZWYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBldmVudDogJ3N0YXJ0JyxcbiAgICAgICAgaW50ZXJ2YWw6IHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKSFcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBwcml2YXRlIF9vbkNvbm5DbG9zZShldmVudDogYW55KSB7XG4gICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsICdjbG9zZScsIGV2ZW50KVxuICAgIHRoaXMuX3RyaWdnZXJDaGFuRXJyb3IoKVxuICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmNsb3NlLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhldmVudCkpXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX29uQ29ubkVycm9yKGVycm9yOiBXZWJTb2NrZXRMaWtlRXJyb3IpIHtcbiAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgZXJyb3IubWVzc2FnZSlcbiAgICB0aGlzLl90cmlnZ2VyQ2hhbkVycm9yKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhlcnJvcikpXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX3RyaWdnZXJDaGFuRXJyb3IoKSB7XG4gICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKChjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwpID0+XG4gICAgICBjaGFubmVsLl90cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmVycm9yKVxuICAgIClcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfYXBwZW5kUGFyYW1zKFxuICAgIHVybDogc3RyaW5nLFxuICAgIHBhcmFtczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxuICApOiBzdHJpbmcge1xuICAgIGlmIChPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgICBjb25zdCBwcmVmaXggPSB1cmwubWF0Y2goL1xcPy8pID8gJyYnIDogJz8nXG4gICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcylcblxuICAgIHJldHVybiBgJHt1cmx9JHtwcmVmaXh9JHtxdWVyeX1gXG4gIH1cblxuICBwcml2YXRlIF93b3JrZXJPYmplY3RVcmwodXJsOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICAgIGxldCByZXN1bHRfdXJsOiBzdHJpbmdcbiAgICBpZiAodXJsKSB7XG4gICAgICByZXN1bHRfdXJsID0gdXJsXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbV09SS0VSX1NDUklQVF0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnIH0pXG4gICAgICByZXN1bHRfdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0X3VybFxuICB9XG59XG5cbmNsYXNzIFdTV2ViU29ja2V0RHVtbXkge1xuICBiaW5hcnlUeXBlOiBzdHJpbmcgPSAnYXJyYXlidWZmZXInXG4gIGNsb3NlOiBGdW5jdGlvblxuICBvbmNsb3NlOiBGdW5jdGlvbiA9ICgpID0+IHt9XG4gIG9uZXJyb3I6IEZ1bmN0aW9uID0gKCkgPT4ge31cbiAgb25tZXNzYWdlOiBGdW5jdGlvbiA9ICgpID0+IHt9XG4gIG9ub3BlbjogRnVuY3Rpb24gPSAoKSA9PiB7fVxuICByZWFkeVN0YXRlOiBudW1iZXIgPSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmdcbiAgc2VuZDogRnVuY3Rpb24gPSAoKSA9PiB7fVxuICB1cmw6IHN0cmluZyB8IFVSTCB8IG51bGwgPSBudWxsXG5cbiAgY29uc3RydWN0b3IoXG4gICAgYWRkcmVzczogc3RyaW5nLFxuICAgIF9wcm90b2NvbHM6IHVuZGVmaW5lZCxcbiAgICBvcHRpb25zOiB7IGNsb3NlOiBGdW5jdGlvbiB9XG4gICkge1xuICAgIHRoaXMudXJsID0gYWRkcmVzc1xuICAgIHRoaXMuY2xvc2UgPSBvcHRpb25zLmNsb3NlXG4gIH1cbn1cbiIsICJleHBvcnQgY2xhc3MgU3RvcmFnZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwcm90ZWN0ZWQgX19pc1N0b3JhZ2VFcnJvciA9IHRydWVcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdTdG9yYWdlRXJyb3InXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RvcmFnZUVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgU3RvcmFnZUVycm9yIHtcbiAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ19faXNTdG9yYWdlRXJyb3InIGluIGVycm9yXG59XG5cbmV4cG9ydCBjbGFzcyBTdG9yYWdlQXBpRXJyb3IgZXh0ZW5kcyBTdG9yYWdlRXJyb3Ige1xuICBzdGF0dXM6IG51bWJlclxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgc3RhdHVzOiBudW1iZXIpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdTdG9yYWdlQXBpRXJyb3InXG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXNcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0b3JhZ2VVbmtub3duRXJyb3IgZXh0ZW5kcyBTdG9yYWdlRXJyb3Ige1xuICBvcmlnaW5hbEVycm9yOiB1bmtub3duXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBvcmlnaW5hbEVycm9yOiB1bmtub3duKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnU3RvcmFnZVVua25vd25FcnJvcidcbiAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yXG4gIH1cbn1cbiIsICJ0eXBlIEZldGNoID0gdHlwZW9mIGZldGNoXG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2g/OiBGZXRjaCk6IEZldGNoID0+IHtcbiAgbGV0IF9mZXRjaDogRmV0Y2hcbiAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgX2ZldGNoID0gY3VzdG9tRmV0Y2hcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgX2ZldGNoID0gKC4uLmFyZ3MpID0+XG4gICAgICBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJyBhcyBhbnkpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT4gZmV0Y2goLi4uYXJncykpXG4gIH0gZWxzZSB7XG4gICAgX2ZldGNoID0gZmV0Y2hcbiAgfVxuICByZXR1cm4gKC4uLmFyZ3MpID0+IF9mZXRjaCguLi5hcmdzKVxufVxuXG5leHBvcnQgY29uc3QgcmVzb2x2ZVJlc3BvbnNlID0gYXN5bmMgKCk6IFByb21pc2U8dHlwZW9mIFJlc3BvbnNlPiA9PiB7XG4gIGlmICh0eXBlb2YgUmVzcG9uc2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiAoYXdhaXQgaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcgYXMgYW55KSkuUmVzcG9uc2VcbiAgfVxuXG4gIHJldHVybiBSZXNwb25zZVxufVxuXG5leHBvcnQgY29uc3QgcmVjdXJzaXZlVG9DYW1lbCA9IChpdGVtOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdW5rbm93biA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgcmV0dXJuIGl0ZW0ubWFwKChlbCkgPT4gcmVjdXJzaXZlVG9DYW1lbChlbCkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdmdW5jdGlvbicgfHwgaXRlbSAhPT0gT2JqZWN0KGl0ZW0pKSB7XG4gICAgcmV0dXJuIGl0ZW1cbiAgfVxuXG4gIGNvbnN0IHJlc3VsdDogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9XG4gIE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IG5ld0tleSA9IGtleS5yZXBsYWNlKC8oWy1fXVthLXpdKS9naSwgKGMpID0+IGMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9bLV9dL2csICcnKSlcbiAgICByZXN1bHRbbmV3S2V5XSA9IHJlY3Vyc2l2ZVRvQ2FtZWwodmFsdWUpXG4gIH0pXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwgImltcG9ydCB7IFN0b3JhZ2VBcGlFcnJvciwgU3RvcmFnZVVua25vd25FcnJvciB9IGZyb20gJy4vZXJyb3JzJ1xuaW1wb3J0IHsgcmVzb2x2ZVJlc3BvbnNlIH0gZnJvbSAnLi9oZWxwZXJzJ1xuaW1wb3J0IHsgRmV0Y2hQYXJhbWV0ZXJzIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IHR5cGUgRmV0Y2ggPSB0eXBlb2YgZmV0Y2hcblxuZXhwb3J0IGludGVyZmFjZSBGZXRjaE9wdGlvbnMge1xuICBoZWFkZXJzPzoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9XG4gIG5vUmVzb2x2ZUpzb24/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIFJlcXVlc3RNZXRob2RUeXBlID0gJ0dFVCcgfCAnUE9TVCcgfCAnUFVUJyB8ICdERUxFVEUnIHwgJ0hFQUQnXG5cbmNvbnN0IF9nZXRFcnJvck1lc3NhZ2UgPSAoZXJyOiBhbnkpOiBzdHJpbmcgPT5cbiAgZXJyLm1zZyB8fCBlcnIubWVzc2FnZSB8fCBlcnIuZXJyb3JfZGVzY3JpcHRpb24gfHwgZXJyLmVycm9yIHx8IEpTT04uc3RyaW5naWZ5KGVycilcblxuY29uc3QgaGFuZGxlRXJyb3IgPSBhc3luYyAoXG4gIGVycm9yOiB1bmtub3duLFxuICByZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWQsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnNcbikgPT4ge1xuICBjb25zdCBSZXMgPSBhd2FpdCByZXNvbHZlUmVzcG9uc2UoKVxuXG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIFJlcyAmJiAhb3B0aW9ucz8ubm9SZXNvbHZlSnNvbikge1xuICAgIGVycm9yXG4gICAgICAuanNvbigpXG4gICAgICAudGhlbigoZXJyKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgU3RvcmFnZUFwaUVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyKSwgZXJyb3Iuc3RhdHVzIHx8IDUwMCkpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBTdG9yYWdlVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyKSwgZXJyKSlcbiAgICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KG5ldyBTdG9yYWdlVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCBlcnJvcikpXG4gIH1cbn1cblxuY29uc3QgX2dldFJlcXVlc3RQYXJhbXMgPSAoXG4gIG1ldGhvZDogUmVxdWVzdE1ldGhvZFR5cGUsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnMsXG4gIGJvZHk/OiBvYmplY3RcbikgPT4ge1xuICBjb25zdCBwYXJhbXM6IHsgW2s6IHN0cmluZ106IGFueSB9ID0geyBtZXRob2QsIGhlYWRlcnM6IG9wdGlvbnM/LmhlYWRlcnMgfHwge30gfVxuXG4gIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG5cbiAgcGFyYW1zLmhlYWRlcnMgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfVxuXG4gIGlmIChib2R5KSB7XG4gICAgcGFyYW1zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KVxuICB9XG4gIHJldHVybiB7IC4uLnBhcmFtcywgLi4ucGFyYW1ldGVycyB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9oYW5kbGVSZXF1ZXN0KFxuICBmZXRjaGVyOiBGZXRjaCxcbiAgbWV0aG9kOiBSZXF1ZXN0TWV0aG9kVHlwZSxcbiAgdXJsOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnMsXG4gIGJvZHk/OiBvYmplY3Rcbik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZmV0Y2hlcih1cmwsIF9nZXRSZXF1ZXN0UGFyYW1zKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkpXG4gICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmICghcmVzdWx0Lm9rKSB0aHJvdyByZXN1bHRcbiAgICAgICAgaWYgKG9wdGlvbnM/Lm5vUmVzb2x2ZUpzb24pIHJldHVybiByZXN1bHRcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qc29uKClcbiAgICAgIH0pXG4gICAgICAudGhlbigoZGF0YSkgPT4gcmVzb2x2ZShkYXRhKSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IGhhbmRsZUVycm9yKGVycm9yLCByZWplY3QsIG9wdGlvbnMpKVxuICB9KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0KFxuICBmZXRjaGVyOiBGZXRjaCxcbiAgdXJsOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnNcbik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCAnR0VUJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcG9zdChcbiAgZmV0Y2hlcjogRmV0Y2gsXG4gIHVybDogc3RyaW5nLFxuICBib2R5OiBvYmplY3QsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnNcbik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCAnUE9TVCcsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHB1dChcbiAgZmV0Y2hlcjogRmV0Y2gsXG4gIHVybDogc3RyaW5nLFxuICBib2R5OiBvYmplY3QsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnNcbik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCAnUFVUJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGVhZChcbiAgZmV0Y2hlcjogRmV0Y2gsXG4gIHVybDogc3RyaW5nLFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzXG4pOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoXG4gICAgZmV0Y2hlcixcbiAgICAnSEVBRCcsXG4gICAgdXJsLFxuICAgIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgIH0sXG4gICAgcGFyYW1ldGVyc1xuICApXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmUoXG4gIGZldGNoZXI6IEZldGNoLFxuICB1cmw6IHN0cmluZyxcbiAgYm9keTogb2JqZWN0LFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzXG4pOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ0RFTEVURScsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSlcbn1cbiIsICJpbXBvcnQgeyBpc1N0b3JhZ2VFcnJvciwgU3RvcmFnZUVycm9yLCBTdG9yYWdlVW5rbm93bkVycm9yIH0gZnJvbSAnLi4vbGliL2Vycm9ycydcbmltcG9ydCB7IEZldGNoLCBnZXQsIGhlYWQsIHBvc3QsIHJlbW92ZSB9IGZyb20gJy4uL2xpYi9mZXRjaCdcbmltcG9ydCB7IHJlY3Vyc2l2ZVRvQ2FtZWwsIHJlc29sdmVGZXRjaCB9IGZyb20gJy4uL2xpYi9oZWxwZXJzJ1xuaW1wb3J0IHtcbiAgRmlsZU9iamVjdCxcbiAgRmlsZU9wdGlvbnMsXG4gIFNlYXJjaE9wdGlvbnMsXG4gIEZldGNoUGFyYW1ldGVycyxcbiAgVHJhbnNmb3JtT3B0aW9ucyxcbiAgRGVzdGluYXRpb25PcHRpb25zLFxuICBGaWxlT2JqZWN0VjIsXG4gIENhbWVsaXplLFxufSBmcm9tICcuLi9saWIvdHlwZXMnXG5cbmNvbnN0IERFRkFVTFRfU0VBUkNIX09QVElPTlMgPSB7XG4gIGxpbWl0OiAxMDAsXG4gIG9mZnNldDogMCxcbiAgc29ydEJ5OiB7XG4gICAgY29sdW1uOiAnbmFtZScsXG4gICAgb3JkZXI6ICdhc2MnLFxuICB9LFxufVxuXG5jb25zdCBERUZBVUxUX0ZJTEVfT1BUSU9OUzogRmlsZU9wdGlvbnMgPSB7XG4gIGNhY2hlQ29udHJvbDogJzM2MDAnLFxuICBjb250ZW50VHlwZTogJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcsXG4gIHVwc2VydDogZmFsc2UsXG59XG5cbnR5cGUgRmlsZUJvZHkgPVxuICB8IEFycmF5QnVmZmVyXG4gIHwgQXJyYXlCdWZmZXJWaWV3XG4gIHwgQmxvYlxuICB8IEJ1ZmZlclxuICB8IEZpbGVcbiAgfCBGb3JtRGF0YVxuICB8IE5vZGVKUy5SZWFkYWJsZVN0cmVhbVxuICB8IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+XG4gIHwgVVJMU2VhcmNoUGFyYW1zXG4gIHwgc3RyaW5nXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JhZ2VGaWxlQXBpIHtcbiAgcHJvdGVjdGVkIHVybDogc3RyaW5nXG4gIHByb3RlY3RlZCBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gIHByb3RlY3RlZCBidWNrZXRJZD86IHN0cmluZ1xuICBwcm90ZWN0ZWQgZmV0Y2g6IEZldGNoXG5cbiAgY29uc3RydWN0b3IoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9LFxuICAgIGJ1Y2tldElkPzogc3RyaW5nLFxuICAgIGZldGNoPzogRmV0Y2hcbiAgKSB7XG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gICAgdGhpcy5idWNrZXRJZCA9IGJ1Y2tldElkXG4gICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGxvYWRzIGEgZmlsZSB0byBhbiBleGlzdGluZyBidWNrZXQgb3IgcmVwbGFjZXMgYW4gZXhpc3RpbmcgZmlsZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggd2l0aCBhIG5ldyBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSBtZXRob2QgSFRUUCBtZXRob2QuXG4gICAqIEBwYXJhbSBwYXRoIFRoZSByZWxhdGl2ZSBmaWxlIHBhdGguIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwbG9hZC5cbiAgICogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB1cGxvYWRPclVwZGF0ZShcbiAgICBtZXRob2Q6ICdQT1NUJyB8ICdQVVQnLFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBmaWxlQm9keTogRmlsZUJvZHksXG4gICAgZmlsZU9wdGlvbnM/OiBGaWxlT3B0aW9uc1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IGlkOiBzdHJpbmc7IHBhdGg6IHN0cmluZzsgZnVsbFBhdGg6IHN0cmluZyB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IGJvZHlcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IC4uLkRFRkFVTFRfRklMRV9PUFRJT05TLCAuLi5maWxlT3B0aW9ucyB9XG4gICAgICBsZXQgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICAgLi4udGhpcy5oZWFkZXJzLFxuICAgICAgICAuLi4obWV0aG9kID09PSAnUE9TVCcgJiYgeyAneC11cHNlcnQnOiBTdHJpbmcob3B0aW9ucy51cHNlcnQgYXMgYm9vbGVhbikgfSksXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YVxuXG4gICAgICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBib2R5ID0gbmV3IEZvcm1EYXRhKClcbiAgICAgICAgYm9keS5hcHBlbmQoJ2NhY2hlQ29udHJvbCcsIG9wdGlvbnMuY2FjaGVDb250cm9sIGFzIHN0cmluZylcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgYm9keS5hcHBlbmQoJ21ldGFkYXRhJywgdGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpXG4gICAgICAgIH1cbiAgICAgICAgYm9keS5hcHBlbmQoJycsIGZpbGVCb2R5KVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgYm9keSA9IGZpbGVCb2R5XG4gICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCBhcyBzdHJpbmcpXG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgIGJvZHkuYXBwZW5kKCdtZXRhZGF0YScsIHRoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib2R5ID0gZmlsZUJvZHlcbiAgICAgICAgaGVhZGVyc1snY2FjaGUtY29udHJvbCddID0gYG1heC1hZ2U9JHtvcHRpb25zLmNhY2hlQ29udHJvbH1gXG4gICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gb3B0aW9ucy5jb250ZW50VHlwZSBhcyBzdHJpbmdcblxuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICBoZWFkZXJzWyd4LW1ldGFkYXRhJ10gPSB0aGlzLnRvQmFzZTY0KHRoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWxlT3B0aW9ucz8uaGVhZGVycykge1xuICAgICAgICBoZWFkZXJzID0geyAuLi5oZWFkZXJzLCAuLi5maWxlT3B0aW9ucy5oZWFkZXJzIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgY2xlYW5QYXRoID0gdGhpcy5fcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpXG4gICAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChjbGVhblBhdGgpXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmZldGNoKGAke3RoaXMudXJsfS9vYmplY3QvJHtfcGF0aH1gLCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgYm9keTogYm9keSBhcyBCb2R5SW5pdCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgLi4uKG9wdGlvbnM/LmR1cGxleCA/IHsgZHVwbGV4OiBvcHRpb25zLmR1cGxleCB9IDoge30pLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHsgcGF0aDogY2xlYW5QYXRoLCBpZDogZGF0YS5JZCwgZnVsbFBhdGg6IGRhdGEuS2V5IH0sXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZGF0YVxuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGxvYWRzIGEgZmlsZSB0byBhbiBleGlzdGluZyBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG4gICAqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cbiAgICovXG4gIGFzeW5jIHVwbG9hZChcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgZmlsZUJvZHk6IEZpbGVCb2R5LFxuICAgIGZpbGVPcHRpb25zPzogRmlsZU9wdGlvbnNcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBpZDogc3RyaW5nOyBwYXRoOiBzdHJpbmc7IGZ1bGxQYXRoOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMudXBsb2FkT3JVcGRhdGUoJ1BPU1QnLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkIGEgZmlsZSB3aXRoIGEgdG9rZW4gZ2VuZXJhdGVkIGZyb20gYGNyZWF0ZVNpZ25lZFVwbG9hZFVybGAuXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG4gICAqIEBwYXJhbSB0b2tlbiBUaGUgdG9rZW4gZ2VuZXJhdGVkIGZyb20gYGNyZWF0ZVNpZ25lZFVwbG9hZFVybGBcbiAgICogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuICAgKi9cbiAgYXN5bmMgdXBsb2FkVG9TaWduZWRVcmwoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgZmlsZUJvZHk6IEZpbGVCb2R5LFxuICAgIGZpbGVPcHRpb25zPzogRmlsZU9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3QgY2xlYW5QYXRoID0gdGhpcy5fcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpXG4gICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgoY2xlYW5QYXRoKVxuXG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh0aGlzLnVybCArIGAvb2JqZWN0L3VwbG9hZC9zaWduLyR7X3BhdGh9YClcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgndG9rZW4nLCB0b2tlbilcblxuICAgIHRyeSB7XG4gICAgICBsZXQgYm9keVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgdXBzZXJ0OiBERUZBVUxUX0ZJTEVfT1BUSU9OUy51cHNlcnQsIC4uLmZpbGVPcHRpb25zIH1cbiAgICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgLi4ueyAneC11cHNlcnQnOiBTdHJpbmcob3B0aW9ucy51cHNlcnQgYXMgYm9vbGVhbikgfSxcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgYm9keSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCBhcyBzdHJpbmcpXG4gICAgICAgIGJvZHkuYXBwZW5kKCcnLCBmaWxlQm9keSlcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgIGJvZHkgPSBmaWxlQm9keVxuICAgICAgICBib2R5LmFwcGVuZCgnY2FjaGVDb250cm9sJywgb3B0aW9ucy5jYWNoZUNvbnRyb2wgYXMgc3RyaW5nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYm9keSA9IGZpbGVCb2R5XG4gICAgICAgIGhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSA9IGBtYXgtYWdlPSR7b3B0aW9ucy5jYWNoZUNvbnRyb2x9YFxuICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IG9wdGlvbnMuY29udGVudFR5cGUgYXMgc3RyaW5nXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgYm9keTogYm9keSBhcyBCb2R5SW5pdCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpXG5cbiAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7IHBhdGg6IGNsZWFuUGF0aCwgZnVsbFBhdGg6IGRhdGEuS2V5IH0sXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZGF0YVxuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2lnbmVkIHVwbG9hZCBVUkwuXG4gICAqIFNpZ25lZCB1cGxvYWQgVVJMcyBjYW4gYmUgdXNlZCB0byB1cGxvYWQgZmlsZXMgdG8gdGhlIGJ1Y2tldCB3aXRob3V0IGZ1cnRoZXIgYXV0aGVudGljYXRpb24uXG4gICAqIFRoZXkgYXJlIHZhbGlkIGZvciAyIGhvdXJzLlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAqIEBwYXJhbSBvcHRpb25zLnVwc2VydCBJZiBzZXQgdG8gdHJ1ZSwgYWxsb3dzIHRoZSBmaWxlIHRvIGJlIG92ZXJ3cml0dGVuIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlU2lnbmVkVXBsb2FkVXJsKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyB1cHNlcnQ6IGJvb2xlYW4gfVxuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IHNpZ25lZFVybDogc3RyaW5nOyB0b2tlbjogc3RyaW5nOyBwYXRoOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKVxuXG4gICAgICBjb25zdCBoZWFkZXJzID0geyAuLi50aGlzLmhlYWRlcnMgfVxuXG4gICAgICBpZiAob3B0aW9ucz8udXBzZXJ0KSB7XG4gICAgICAgIGhlYWRlcnNbJ3gtdXBzZXJ0J10gPSAndHJ1ZSdcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9vYmplY3QvdXBsb2FkL3NpZ24vJHtfcGF0aH1gLFxuICAgICAgICB7fSxcbiAgICAgICAgeyBoZWFkZXJzIH1cbiAgICAgIClcblxuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh0aGlzLnVybCArIGRhdGEudXJsKVxuXG4gICAgICBjb25zdCB0b2tlbiA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCd0b2tlbicpXG5cbiAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcignTm8gdG9rZW4gcmV0dXJuZWQgYnkgQVBJJylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgZGF0YTogeyBzaWduZWRVcmw6IHVybC50b1N0cmluZygpLCBwYXRoLCB0b2tlbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggVGhlIHJlbGF0aXZlIGZpbGUgcGF0aC4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAqL1xuICBhc3luYyB1cGRhdGUoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGZpbGVCb2R5OlxuICAgICAgfCBBcnJheUJ1ZmZlclxuICAgICAgfCBBcnJheUJ1ZmZlclZpZXdcbiAgICAgIHwgQmxvYlxuICAgICAgfCBCdWZmZXJcbiAgICAgIHwgRmlsZVxuICAgICAgfCBGb3JtRGF0YVxuICAgICAgfCBOb2RlSlMuUmVhZGFibGVTdHJlYW1cbiAgICAgIHwgUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbiAgICAgIHwgVVJMU2VhcmNoUGFyYW1zXG4gICAgICB8IHN0cmluZyxcbiAgICBmaWxlT3B0aW9ucz86IEZpbGVPcHRpb25zXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgaWQ6IHN0cmluZzsgcGF0aDogc3RyaW5nOyBmdWxsUGF0aDogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHJldHVybiB0aGlzLnVwbG9hZE9yVXBkYXRlKCdQVVQnLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgYW4gZXhpc3RpbmcgZmlsZSB0byBhIG5ldyBwYXRoIGluIHRoZSBzYW1lIGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtIGZyb21QYXRoIFRoZSBvcmlnaW5hbCBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICogQHBhcmFtIHRvUGF0aCBUaGUgbmV3IGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBuZXcgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLW5ldy5wbmdgLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIG1vdmUoXG4gICAgZnJvbVBhdGg6IHN0cmluZyxcbiAgICB0b1BhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogRGVzdGluYXRpb25PcHRpb25zXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgbWVzc2FnZTogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L29iamVjdC9tb3ZlYCxcbiAgICAgICAge1xuICAgICAgICAgIGJ1Y2tldElkOiB0aGlzLmJ1Y2tldElkLFxuICAgICAgICAgIHNvdXJjZUtleTogZnJvbVBhdGgsXG4gICAgICAgICAgZGVzdGluYXRpb25LZXk6IHRvUGF0aCxcbiAgICAgICAgICBkZXN0aW5hdGlvbkJ1Y2tldDogb3B0aW9ucz8uZGVzdGluYXRpb25CdWNrZXQsXG4gICAgICAgIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyBhbiBleGlzdGluZyBmaWxlIHRvIGEgbmV3IHBhdGggaW4gdGhlIHNhbWUgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbVBhdGggVGhlIG9yaWdpbmFsIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgKiBAcGFyYW0gdG9QYXRoIFRoZSBuZXcgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIG5ldyBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UtY29weS5wbmdgLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIGNvcHkoXG4gICAgZnJvbVBhdGg6IHN0cmluZyxcbiAgICB0b1BhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogRGVzdGluYXRpb25PcHRpb25zXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgcGF0aDogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L29iamVjdC9jb3B5YCxcbiAgICAgICAge1xuICAgICAgICAgIGJ1Y2tldElkOiB0aGlzLmJ1Y2tldElkLFxuICAgICAgICAgIHNvdXJjZUtleTogZnJvbVBhdGgsXG4gICAgICAgICAgZGVzdGluYXRpb25LZXk6IHRvUGF0aCxcbiAgICAgICAgICBkZXN0aW5hdGlvbkJ1Y2tldDogb3B0aW9ucz8uZGVzdGluYXRpb25CdWNrZXQsXG4gICAgICAgIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGE6IHsgcGF0aDogZGF0YS5LZXkgfSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNpZ25lZCBVUkwuIFVzZSBhIHNpZ25lZCBVUkwgdG8gc2hhcmUgYSBmaWxlIGZvciBhIGZpeGVkIGFtb3VudCBvZiB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMIGV4cGlyZXMuIEZvciBleGFtcGxlLCBgNjBgIGZvciBhIFVSTCB3aGljaCBpcyB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG4gICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG4gICAqL1xuICBhc3luYyBjcmVhdGVTaWduZWRVcmwoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGV4cGlyZXNJbjogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiB7IGRvd25sb2FkPzogc3RyaW5nIHwgYm9vbGVhbjsgdHJhbnNmb3JtPzogVHJhbnNmb3JtT3B0aW9ucyB9XG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgc2lnbmVkVXJsOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKVxuXG4gICAgICBsZXQgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9vYmplY3Qvc2lnbi8ke19wYXRofWAsXG4gICAgICAgIHsgZXhwaXJlc0luLCAuLi4ob3B0aW9ucz8udHJhbnNmb3JtID8geyB0cmFuc2Zvcm06IG9wdGlvbnMudHJhbnNmb3JtIH0gOiB7fSkgfSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuICAgICAgY29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gb3B0aW9ucz8uZG93bmxvYWRcbiAgICAgICAgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/ICcnIDogb3B0aW9ucy5kb3dubG9hZH1gXG4gICAgICAgIDogJydcbiAgICAgIGNvbnN0IHNpZ25lZFVybCA9IGVuY29kZVVSSShgJHt0aGlzLnVybH0ke2RhdGEuc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApXG4gICAgICBkYXRhID0geyBzaWduZWRVcmwgfVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBtdWx0aXBsZSBzaWduZWQgVVJMcy4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRocyBUaGUgZmlsZSBwYXRocyB0byBiZSBkb3dubG9hZGVkLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lcy4gRm9yIGV4YW1wbGUgYFsnZm9sZGVyL2ltYWdlLnBuZycsICdmb2xkZXIyL2ltYWdlMi5wbmcnXWAuXG4gICAqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMcyBleHBpcmUuIEZvciBleGFtcGxlLCBgNjBgIGZvciBVUkxzIHdoaWNoIGFyZSB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG4gICAqL1xuICBhc3luYyBjcmVhdGVTaWduZWRVcmxzKFxuICAgIHBhdGhzOiBzdHJpbmdbXSxcbiAgICBleHBpcmVzSW46IG51bWJlcixcbiAgICBvcHRpb25zPzogeyBkb3dubG9hZDogc3RyaW5nIHwgYm9vbGVhbiB9XG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgZXJyb3I6IHN0cmluZyB8IG51bGw7IHBhdGg6IHN0cmluZyB8IG51bGw7IHNpZ25lZFVybDogc3RyaW5nIH1bXVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vb2JqZWN0L3NpZ24vJHt0aGlzLmJ1Y2tldElkfWAsXG4gICAgICAgIHsgZXhwaXJlc0luLCBwYXRocyB9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG5cbiAgICAgIGNvbnN0IGRvd25sb2FkUXVlcnlQYXJhbSA9IG9wdGlvbnM/LmRvd25sb2FkXG4gICAgICAgID8gYCZkb3dubG9hZD0ke29wdGlvbnMuZG93bmxvYWQgPT09IHRydWUgPyAnJyA6IG9wdGlvbnMuZG93bmxvYWR9YFxuICAgICAgICA6ICcnXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBkYXRhLm1hcCgoZGF0dW06IHsgc2lnbmVkVVJMOiBzdHJpbmcgfSkgPT4gKHtcbiAgICAgICAgICAuLi5kYXR1bSxcbiAgICAgICAgICBzaWduZWRVcmw6IGRhdHVtLnNpZ25lZFVSTFxuICAgICAgICAgICAgPyBlbmNvZGVVUkkoYCR7dGhpcy51cmx9JHtkYXR1bS5zaWduZWRVUkx9JHtkb3dubG9hZFF1ZXJ5UGFyYW19YClcbiAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgfSkpLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERvd25sb2FkcyBhIGZpbGUgZnJvbSBhIHByaXZhdGUgYnVja2V0LiBGb3IgcHVibGljIGJ1Y2tldHMsIG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBVUkwgcmV0dXJuZWQgZnJvbSBgZ2V0UHVibGljVXJsYCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgZnVsbCBwYXRoIGFuZCBmaWxlIG5hbWUgb2YgdGhlIGZpbGUgdG8gYmUgZG93bmxvYWRlZC4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuICAgKi9cbiAgYXN5bmMgZG93bmxvYWQoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IHRyYW5zZm9ybT86IFRyYW5zZm9ybU9wdGlvbnMgfVxuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBCbG9iXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICBjb25zdCB3YW50c1RyYW5zZm9ybWF0aW9uID0gdHlwZW9mIG9wdGlvbnM/LnRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCdcbiAgICBjb25zdCByZW5kZXJQYXRoID0gd2FudHNUcmFuc2Zvcm1hdGlvbiA/ICdyZW5kZXIvaW1hZ2UvYXV0aGVudGljYXRlZCcgOiAnb2JqZWN0J1xuICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uUXVlcnkgPSB0aGlzLnRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKG9wdGlvbnM/LnRyYW5zZm9ybSB8fCB7fSlcbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IHRyYW5zZm9ybWF0aW9uUXVlcnkgPyBgPyR7dHJhbnNmb3JtYXRpb25RdWVyeX1gIDogJydcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKVxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS8ke3JlbmRlclBhdGh9LyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgIH0pXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmJsb2IoKVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFuIGV4aXN0aW5nIGZpbGUuXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqL1xuICBhc3luYyBpbmZvKFxuICAgIHBhdGg6IHN0cmluZ1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBDYW1lbGl6ZTxGaWxlT2JqZWN0VjI+XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC9pbmZvLyR7X3BhdGh9YCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4geyBkYXRhOiByZWN1cnNpdmVUb0NhbWVsKGRhdGEpIGFzIENhbWVsaXplPEZpbGVPYmplY3RWMj4sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgZXhpc3RlbmNlIG9mIGEgZmlsZS5cbiAgICogQHBhcmFtIHBhdGhcbiAgICovXG4gIGFzeW5jIGV4aXN0cyhcbiAgICBwYXRoOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogYm9vbGVhblxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBib29sZWFuXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aClcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBoZWFkKHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvJHtfcGF0aH1gLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiB7IGRhdGE6IHRydWUsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSAmJiBlcnJvciBpbnN0YW5jZW9mIFN0b3JhZ2VVbmtub3duRXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxFcnJvciA9IChlcnJvci5vcmlnaW5hbEVycm9yIGFzIHVua25vd24pIGFzIHsgc3RhdHVzOiBudW1iZXIgfVxuXG4gICAgICAgIGlmIChbNDAwLCA0MDRdLmluY2x1ZGVzKG9yaWdpbmFsRXJyb3I/LnN0YXR1cykpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiBmYWxzZSwgZXJyb3IgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgc2ltcGxlIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCB0aGUgVVJMIGZvciBhbiBhc3NldCBpbiBhIHB1YmxpYyBidWNrZXQuIElmIHlvdSBkbyBub3Qgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiwgeW91IGNhbiBjb25zdHJ1Y3QgdGhlIHB1YmxpYyBVUkwgYnkgY29uY2F0ZW5hdGluZyB0aGUgYnVja2V0IFVSTCB3aXRoIHRoZSBwYXRoIHRvIHRoZSBhc3NldC5cbiAgICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB2ZXJpZnkgaWYgdGhlIGJ1Y2tldCBpcyBwdWJsaWMuIElmIGEgcHVibGljIFVSTCBpcyBjcmVhdGVkIGZvciBhIGJ1Y2tldCB3aGljaCBpcyBub3QgcHVibGljLCB5b3Ugd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZCB0aGUgYXNzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIGFuZCBuYW1lIG9mIHRoZSBmaWxlIHRvIGdlbmVyYXRlIHRoZSBwdWJsaWMgVVJMIGZvci4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCBUcmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cbiAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cbiAgICovXG4gIGdldFB1YmxpY1VybChcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgZG93bmxvYWQ/OiBzdHJpbmcgfCBib29sZWFuOyB0cmFuc2Zvcm0/OiBUcmFuc2Zvcm1PcHRpb25zIH1cbiAgKTogeyBkYXRhOiB7IHB1YmxpY1VybDogc3RyaW5nIH0gfSB7XG4gICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aClcbiAgICBjb25zdCBfcXVlcnlTdHJpbmcgPSBbXVxuXG4gICAgY29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gb3B0aW9ucz8uZG93bmxvYWRcbiAgICAgID8gYGRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/ICcnIDogb3B0aW9ucy5kb3dubG9hZH1gXG4gICAgICA6ICcnXG5cbiAgICBpZiAoZG93bmxvYWRRdWVyeVBhcmFtICE9PSAnJykge1xuICAgICAgX3F1ZXJ5U3RyaW5nLnB1c2goZG93bmxvYWRRdWVyeVBhcmFtKVxuICAgIH1cblxuICAgIGNvbnN0IHdhbnRzVHJhbnNmb3JtYXRpb24gPSB0eXBlb2Ygb3B0aW9ucz8udHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJ1xuICAgIGNvbnN0IHJlbmRlclBhdGggPSB3YW50c1RyYW5zZm9ybWF0aW9uID8gJ3JlbmRlci9pbWFnZScgOiAnb2JqZWN0J1xuICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uUXVlcnkgPSB0aGlzLnRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKG9wdGlvbnM/LnRyYW5zZm9ybSB8fCB7fSlcblxuICAgIGlmICh0cmFuc2Zvcm1hdGlvblF1ZXJ5ICE9PSAnJykge1xuICAgICAgX3F1ZXJ5U3RyaW5nLnB1c2godHJhbnNmb3JtYXRpb25RdWVyeSlcbiAgICB9XG5cbiAgICBsZXQgcXVlcnlTdHJpbmcgPSBfcXVlcnlTdHJpbmcuam9pbignJicpXG4gICAgaWYgKHF1ZXJ5U3RyaW5nICE9PSAnJykge1xuICAgICAgcXVlcnlTdHJpbmcgPSBgPyR7cXVlcnlTdHJpbmd9YFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiB7IHB1YmxpY1VybDogZW5jb2RlVVJJKGAke3RoaXMudXJsfS8ke3JlbmRlclBhdGh9L3B1YmxpYy8ke19wYXRofSR7cXVlcnlTdHJpbmd9YCkgfSxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBmaWxlcyB3aXRoaW4gdGhlIHNhbWUgYnVja2V0XG4gICAqXG4gICAqIEBwYXJhbSBwYXRocyBBbiBhcnJheSBvZiBmaWxlcyB0byBkZWxldGUsIGluY2x1ZGluZyB0aGUgcGF0aCBhbmQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBbYCdmb2xkZXIvaW1hZ2UucG5nJ2BdLlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlKFxuICAgIHBhdGhzOiBzdHJpbmdbXVxuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBGaWxlT2JqZWN0W11cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVtb3ZlKFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vb2JqZWN0LyR7dGhpcy5idWNrZXRJZH1gLFxuICAgICAgICB7IHByZWZpeGVzOiBwYXRocyB9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZmlsZSBtZXRhZGF0YVxuICAgKiBAcGFyYW0gaWQgdGhlIGZpbGUgaWQgdG8gcmV0cmlldmUgbWV0YWRhdGFcbiAgICovXG4gIC8vIGFzeW5jIGdldE1ldGFkYXRhKFxuICAvLyAgIGlkOiBzdHJpbmdcbiAgLy8gKTogUHJvbWlzZTxcbiAgLy8gICB8IHtcbiAgLy8gICAgICAgZGF0YTogTWV0YWRhdGFcbiAgLy8gICAgICAgZXJyb3I6IG51bGxcbiAgLy8gICAgIH1cbiAgLy8gICB8IHtcbiAgLy8gICAgICAgZGF0YTogbnVsbFxuICAvLyAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gIC8vICAgICB9XG4gIC8vID4ge1xuICAvLyAgIHRyeSB7XG4gIC8vICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9tZXRhZGF0YS8ke2lkfWAsIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pXG4gIC8vICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gIC8vICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgLy8gICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgLy8gICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAvLyAgICAgfVxuXG4gIC8vICAgICB0aHJvdyBlcnJvclxuICAvLyAgIH1cbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZmlsZSBtZXRhZGF0YVxuICAgKiBAcGFyYW0gaWQgdGhlIGZpbGUgaWQgdG8gdXBkYXRlIG1ldGFkYXRhXG4gICAqIEBwYXJhbSBtZXRhIHRoZSBuZXcgZmlsZSBtZXRhZGF0YVxuICAgKi9cbiAgLy8gYXN5bmMgdXBkYXRlTWV0YWRhdGEoXG4gIC8vICAgaWQ6IHN0cmluZyxcbiAgLy8gICBtZXRhOiBNZXRhZGF0YVxuICAvLyApOiBQcm9taXNlPFxuICAvLyAgIHwge1xuICAvLyAgICAgICBkYXRhOiBNZXRhZGF0YVxuICAvLyAgICAgICBlcnJvcjogbnVsbFxuICAvLyAgICAgfVxuICAvLyAgIHwge1xuICAvLyAgICAgICBkYXRhOiBudWxsXG4gIC8vICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgLy8gICAgIH1cbiAgLy8gPiB7XG4gIC8vICAgdHJ5IHtcbiAgLy8gICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAvLyAgICAgICB0aGlzLmZldGNoLFxuICAvLyAgICAgICBgJHt0aGlzLnVybH0vbWV0YWRhdGEvJHtpZH1gLFxuICAvLyAgICAgICB7IC4uLm1ldGEgfSxcbiAgLy8gICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAvLyAgICAgKVxuICAvLyAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAvLyAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gIC8vICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gIC8vICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgLy8gICAgIH1cblxuICAvLyAgICAgdGhyb3cgZXJyb3JcbiAgLy8gICB9XG4gIC8vIH1cblxuICAvKipcbiAgICogTGlzdHMgYWxsIHRoZSBmaWxlcyB3aXRoaW4gYSBidWNrZXQuXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBmb2xkZXIgcGF0aC5cbiAgICovXG4gIGFzeW5jIGxpc3QoXG4gICAgcGF0aD86IHN0cmluZyxcbiAgICBvcHRpb25zPzogU2VhcmNoT3B0aW9ucyxcbiAgICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IEZpbGVPYmplY3RbXVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJvZHkgPSB7IC4uLkRFRkFVTFRfU0VBUkNIX09QVElPTlMsIC4uLm9wdGlvbnMsIHByZWZpeDogcGF0aCB8fCAnJyB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L29iamVjdC9saXN0LyR7dGhpcy5idWNrZXRJZH1gLFxuICAgICAgICBib2R5LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9LFxuICAgICAgICBwYXJhbWV0ZXJzXG4gICAgICApXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBlbmNvZGVNZXRhZGF0YShtZXRhZGF0YTogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSlcbiAgfVxuXG4gIHRvQmFzZTY0KGRhdGE6IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgIH1cbiAgICByZXR1cm4gYnRvYShkYXRhKVxuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0RmluYWxQYXRoKHBhdGg6IHN0cmluZykge1xuICAgIHJldHVybiBgJHt0aGlzLmJ1Y2tldElkfS8ke3BhdGh9YFxuICB9XG5cbiAgcHJpdmF0ZSBfcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGg6IHN0cmluZykge1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL15cXC98XFwvJC9nLCAnJykucmVwbGFjZSgvXFwvKy9nLCAnLycpXG4gIH1cblxuICBwcml2YXRlIHRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKHRyYW5zZm9ybTogVHJhbnNmb3JtT3B0aW9ucykge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdXG4gICAgaWYgKHRyYW5zZm9ybS53aWR0aCkge1xuICAgICAgcGFyYW1zLnB1c2goYHdpZHRoPSR7dHJhbnNmb3JtLndpZHRofWApXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5oZWlnaHQpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGBoZWlnaHQ9JHt0cmFuc2Zvcm0uaGVpZ2h0fWApXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5yZXNpemUpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGByZXNpemU9JHt0cmFuc2Zvcm0ucmVzaXplfWApXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5mb3JtYXQpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGBmb3JtYXQ9JHt0cmFuc2Zvcm0uZm9ybWF0fWApXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5xdWFsaXR5KSB7XG4gICAgICBwYXJhbXMucHVzaChgcXVhbGl0eT0ke3RyYW5zZm9ybS5xdWFsaXR5fWApXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcy5qb2luKCcmJylcbiAgfVxufVxuIiwgIi8vIGdlbmVyYXRlZCBieSBnZW52ZXJzaW9uXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjcuMSdcbiIsICJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJ1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfSEVBREVSUyA9IHsgJ1gtQ2xpZW50LUluZm8nOiBgc3RvcmFnZS1qcy8ke3ZlcnNpb259YCB9XG4iLCAiaW1wb3J0IHsgREVGQVVMVF9IRUFERVJTIH0gZnJvbSAnLi4vbGliL2NvbnN0YW50cydcbmltcG9ydCB7IGlzU3RvcmFnZUVycm9yLCBTdG9yYWdlRXJyb3IgfSBmcm9tICcuLi9saWIvZXJyb3JzJ1xuaW1wb3J0IHsgRmV0Y2gsIGdldCwgcG9zdCwgcHV0LCByZW1vdmUgfSBmcm9tICcuLi9saWIvZmV0Y2gnXG5pbXBvcnQgeyByZXNvbHZlRmV0Y2ggfSBmcm9tICcuLi9saWIvaGVscGVycydcbmltcG9ydCB7IEJ1Y2tldCB9IGZyb20gJy4uL2xpYi90eXBlcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RvcmFnZUJ1Y2tldEFwaSB7XG4gIHByb3RlY3RlZCB1cmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxuICBwcm90ZWN0ZWQgZmV0Y2g6IEZldGNoXG5cbiAgY29uc3RydWN0b3IodXJsOiBzdHJpbmcsIGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fSwgZmV0Y2g/OiBGZXRjaCkge1xuICAgIHRoaXMudXJsID0gdXJsXG4gICAgdGhpcy5oZWFkZXJzID0geyAuLi5ERUZBVUxUX0hFQURFUlMsIC4uLmhlYWRlcnMgfVxuICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goZmV0Y2gpXG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFsbCBTdG9yYWdlIGJ1Y2tldHMgd2l0aGluIGFuIGV4aXN0aW5nIHByb2plY3QuXG4gICAqL1xuICBhc3luYyBsaXN0QnVja2V0cygpOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBCdWNrZXRbXVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L2J1Y2tldGAsIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgU3RvcmFnZSBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byByZXRyaWV2ZS5cbiAgICovXG4gIGFzeW5jIGdldEJ1Y2tldChcbiAgICBpZDogc3RyaW5nXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IEJ1Y2tldFxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L2J1Y2tldC8ke2lkfWAsIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFN0b3JhZ2UgYnVja2V0XG4gICAqXG4gICAqIEBwYXJhbSBpZCBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYnVja2V0IHlvdSBhcmUgY3JlYXRpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zLnB1YmxpYyBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgYnVja2V0LiBQdWJsaWMgYnVja2V0cyBkb24ndCByZXF1aXJlIGFuIGF1dGhvcml6YXRpb24gdG9rZW4gdG8gZG93bmxvYWQgb2JqZWN0cywgYnV0IHN0aWxsIHJlcXVpcmUgYSB2YWxpZCB0b2tlbiBmb3IgYWxsIG90aGVyIG9wZXJhdGlvbnMuIEJ5IGRlZmF1bHQsIGJ1Y2tldHMgYXJlIHByaXZhdGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLmZpbGVTaXplTGltaXQgc3BlY2lmaWVzIHRoZSBtYXggZmlsZSBzaXplIGluIGJ5dGVzIHRoYXQgY2FuIGJlIHVwbG9hZGVkIHRvIHRoaXMgYnVja2V0LlxuICAgKiBUaGUgZ2xvYmFsIGZpbGUgc2l6ZSBsaW1pdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhpcyB2YWx1ZS5cbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggZG9lc24ndCBzZXQgYSBwZXIgYnVja2V0IGZpbGUgc2l6ZSBsaW1pdC5cbiAgICogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyBzcGVjaWZpZXMgdGhlIGFsbG93ZWQgbWltZSB0eXBlcyB0aGF0IHRoaXMgYnVja2V0IGNhbiBhY2NlcHQgZHVyaW5nIHVwbG9hZC5cbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggYWxsb3dzIGZpbGVzIHdpdGggYWxsIG1pbWUgdHlwZXMgdG8gYmUgdXBsb2FkZWQuXG4gICAqIEVhY2ggbWltZSB0eXBlIHNwZWNpZmllZCBjYW4gYmUgYSB3aWxkY2FyZCwgZS5nLiBpbWFnZS8qLCBvciBhIHNwZWNpZmljIG1pbWUgdHlwZSwgZS5nLiBpbWFnZS9wbmcuXG4gICAqIEByZXR1cm5zIG5ld2x5IGNyZWF0ZWQgYnVja2V0IGlkXG4gICAqL1xuICBhc3luYyBjcmVhdGVCdWNrZXQoXG4gICAgaWQ6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwdWJsaWM6IGJvb2xlYW5cbiAgICAgIGZpbGVTaXplTGltaXQ/OiBudW1iZXIgfCBzdHJpbmcgfCBudWxsXG4gICAgICBhbGxvd2VkTWltZVR5cGVzPzogc3RyaW5nW10gfCBudWxsXG4gICAgfSA9IHtcbiAgICAgIHB1YmxpYzogZmFsc2UsXG4gICAgfVxuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBQaWNrPEJ1Y2tldCwgJ25hbWUnPlxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vYnVja2V0YCxcbiAgICAgICAge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIG5hbWU6IGlkLFxuICAgICAgICAgIHB1YmxpYzogb3B0aW9ucy5wdWJsaWMsXG4gICAgICAgICAgZmlsZV9zaXplX2xpbWl0OiBvcHRpb25zLmZpbGVTaXplTGltaXQsXG4gICAgICAgICAgYWxsb3dlZF9taW1lX3R5cGVzOiBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXMsXG4gICAgICAgIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBTdG9yYWdlIGJ1Y2tldFxuICAgKlxuICAgKiBAcGFyYW0gaWQgQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIHVwZGF0aW5nLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5wdWJsaWMgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGJ1Y2tldC4gUHVibGljIGJ1Y2tldHMgZG9uJ3QgcmVxdWlyZSBhbiBhdXRob3JpemF0aW9uIHRva2VuIHRvIGRvd25sb2FkIG9iamVjdHMsIGJ1dCBzdGlsbCByZXF1aXJlIGEgdmFsaWQgdG9rZW4gZm9yIGFsbCBvdGhlciBvcGVyYXRpb25zLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5maWxlU2l6ZUxpbWl0IHNwZWNpZmllcyB0aGUgbWF4IGZpbGUgc2l6ZSBpbiBieXRlcyB0aGF0IGNhbiBiZSB1cGxvYWRlZCB0byB0aGlzIGJ1Y2tldC5cbiAgICogVGhlIGdsb2JhbCBmaWxlIHNpemUgbGltaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgdmFsdWUuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGRvZXNuJ3Qgc2V0IGEgcGVyIGJ1Y2tldCBmaWxlIHNpemUgbGltaXQuXG4gICAqIEBwYXJhbSBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXMgc3BlY2lmaWVzIHRoZSBhbGxvd2VkIG1pbWUgdHlwZXMgdGhhdCB0aGlzIGJ1Y2tldCBjYW4gYWNjZXB0IGR1cmluZyB1cGxvYWQuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGFsbG93cyBmaWxlcyB3aXRoIGFsbCBtaW1lIHR5cGVzIHRvIGJlIHVwbG9hZGVkLlxuICAgKiBFYWNoIG1pbWUgdHlwZSBzcGVjaWZpZWQgY2FuIGJlIGEgd2lsZGNhcmQsIGUuZy4gaW1hZ2UvKiwgb3IgYSBzcGVjaWZpYyBtaW1lIHR5cGUsIGUuZy4gaW1hZ2UvcG5nLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlQnVja2V0KFxuICAgIGlkOiBzdHJpbmcsXG4gICAgb3B0aW9uczoge1xuICAgICAgcHVibGljOiBib29sZWFuXG4gICAgICBmaWxlU2l6ZUxpbWl0PzogbnVtYmVyIHwgc3RyaW5nIHwgbnVsbFxuICAgICAgYWxsb3dlZE1pbWVUeXBlcz86IHN0cmluZ1tdIHwgbnVsbFxuICAgIH1cbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBtZXNzYWdlOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwdXQoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH1gLFxuICAgICAgICB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgbmFtZTogaWQsXG4gICAgICAgICAgcHVibGljOiBvcHRpb25zLnB1YmxpYyxcbiAgICAgICAgICBmaWxlX3NpemVfbGltaXQ6IG9wdGlvbnMuZmlsZVNpemVMaW1pdCxcbiAgICAgICAgICBhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyxcbiAgICAgICAgfSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgb2JqZWN0cyBpbnNpZGUgYSBzaW5nbGUgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gZW1wdHkuXG4gICAqL1xuICBhc3luYyBlbXB0eUJ1Y2tldChcbiAgICBpZDogc3RyaW5nXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgbWVzc2FnZTogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L2J1Y2tldC8ke2lkfS9lbXB0eWAsXG4gICAgICAgIHt9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGV4aXN0aW5nIGJ1Y2tldC4gQSBidWNrZXQgY2FuJ3QgYmUgZGVsZXRlZCB3aXRoIGV4aXN0aW5nIG9iamVjdHMgaW5zaWRlIGl0LlxuICAgKiBZb3UgbXVzdCBmaXJzdCBgZW1wdHkoKWAgdGhlIGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGRlbGV0ZS5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZUJ1Y2tldChcbiAgICBpZDogc3RyaW5nXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgbWVzc2FnZTogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVtb3ZlKFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9YCxcbiAgICAgICAge30sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IFN0b3JhZ2VGaWxlQXBpIGZyb20gJy4vcGFja2FnZXMvU3RvcmFnZUZpbGVBcGknXG5pbXBvcnQgU3RvcmFnZUJ1Y2tldEFwaSBmcm9tICcuL3BhY2thZ2VzL1N0b3JhZ2VCdWNrZXRBcGknXG5pbXBvcnQgeyBGZXRjaCB9IGZyb20gJy4vbGliL2ZldGNoJ1xuXG5leHBvcnQgY2xhc3MgU3RvcmFnZUNsaWVudCBleHRlbmRzIFN0b3JhZ2VCdWNrZXRBcGkge1xuICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZywgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9LCBmZXRjaD86IEZldGNoKSB7XG4gICAgc3VwZXIodXJsLCBoZWFkZXJzLCBmZXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGZpbGUgb3BlcmF0aW9uIGluIGEgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gaWQgVGhlIGJ1Y2tldCBpZCB0byBvcGVyYXRlIG9uLlxuICAgKi9cbiAgZnJvbShpZDogc3RyaW5nKTogU3RvcmFnZUZpbGVBcGkge1xuICAgIHJldHVybiBuZXcgU3RvcmFnZUZpbGVBcGkodGhpcy51cmwsIHRoaXMuaGVhZGVycywgaWQsIHRoaXMuZmV0Y2gpXG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjQ3LjE2J1xuIiwgIi8vIGNvbnN0YW50cy50c1xuaW1wb3J0IHsgUmVhbHRpbWVDbGllbnRPcHRpb25zIH0gZnJvbSAnQHN1cGFiYXNlL3JlYWx0aW1lLWpzJ1xuaW1wb3J0IHsgU3VwYWJhc2VBdXRoQ2xpZW50T3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJ1xuXG5sZXQgSlNfRU5WID0gJydcbi8vIEB0cy1pZ25vcmVcbmlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgSlNfRU5WID0gJ2Rlbm8nXG59IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgSlNfRU5WID0gJ3dlYidcbn0gZWxzZSBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgSlNfRU5WID0gJ3JlYWN0LW5hdGl2ZSdcbn0gZWxzZSB7XG4gIEpTX0VOViA9ICdub2RlJ1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBzdXBhYmFzZS1qcy0ke0pTX0VOVn0vJHt2ZXJzaW9ufWAgfVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9HTE9CQUxfT1BUSU9OUyA9IHtcbiAgaGVhZGVyczogREVGQVVMVF9IRUFERVJTLFxufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9EQl9PUFRJT05TID0ge1xuICBzY2hlbWE6ICdwdWJsaWMnLFxufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9BVVRIX09QVElPTlM6IFN1cGFiYXNlQXV0aENsaWVudE9wdGlvbnMgPSB7XG4gIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuICBkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWUsXG4gIGZsb3dUeXBlOiAnaW1wbGljaXQnLFxufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9SRUFMVElNRV9PUFRJT05TOiBSZWFsdGltZUNsaWVudE9wdGlvbnMgPSB7fVxuIiwgIi8vIEB0cy1pZ25vcmVcbmltcG9ydCBub2RlRmV0Y2gsIHsgSGVhZGVycyBhcyBOb2RlRmV0Y2hIZWFkZXJzIH0gZnJvbSAnQHN1cGFiYXNlL25vZGUtZmV0Y2gnXG5cbnR5cGUgRmV0Y2ggPSB0eXBlb2YgZmV0Y2hcblxuZXhwb3J0IGNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaD86IEZldGNoKTogRmV0Y2ggPT4ge1xuICBsZXQgX2ZldGNoOiBGZXRjaFxuICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaFxuICB9IGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBfZmV0Y2ggPSBub2RlRmV0Y2ggYXMgdW5rbm93biBhcyBGZXRjaFxuICB9IGVsc2Uge1xuICAgIF9mZXRjaCA9IGZldGNoXG4gIH1cbiAgcmV0dXJuICguLi5hcmdzOiBQYXJhbWV0ZXJzPEZldGNoPikgPT4gX2ZldGNoKC4uLmFyZ3MpXG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlSGVhZGVyc0NvbnN0cnVjdG9yID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIEhlYWRlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIE5vZGVGZXRjaEhlYWRlcnNcbiAgfVxuXG4gIHJldHVybiBIZWFkZXJzXG59XG5cbmV4cG9ydCBjb25zdCBmZXRjaFdpdGhBdXRoID0gKFxuICBzdXBhYmFzZUtleTogc3RyaW5nLFxuICBnZXRBY2Nlc3NUb2tlbjogKCkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsPixcbiAgY3VzdG9tRmV0Y2g/OiBGZXRjaFxuKTogRmV0Y2ggPT4ge1xuICBjb25zdCBmZXRjaCA9IHJlc29sdmVGZXRjaChjdXN0b21GZXRjaClcbiAgY29uc3QgSGVhZGVyc0NvbnN0cnVjdG9yID0gcmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvcigpXG5cbiAgcmV0dXJuIGFzeW5jIChpbnB1dCwgaW5pdCkgPT4ge1xuICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gKGF3YWl0IGdldEFjY2Vzc1Rva2VuKCkpID8/IHN1cGFiYXNlS2V5XG4gICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVyc0NvbnN0cnVjdG9yKGluaXQ/LmhlYWRlcnMpXG5cbiAgICBpZiAoIWhlYWRlcnMuaGFzKCdhcGlrZXknKSkge1xuICAgICAgaGVhZGVycy5zZXQoJ2FwaWtleScsIHN1cGFiYXNlS2V5KVxuICAgIH1cblxuICAgIGlmICghaGVhZGVycy5oYXMoJ0F1dGhvcml6YXRpb24nKSkge1xuICAgICAgaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7YWNjZXNzVG9rZW59YClcbiAgICB9XG5cbiAgICByZXR1cm4gZmV0Y2goaW5wdXQsIHsgLi4uaW5pdCwgaGVhZGVycyB9KVxuICB9XG59XG4iLCAiLy8gaGVscGVycy50c1xuaW1wb3J0IHsgU3VwYWJhc2VDbGllbnRPcHRpb25zIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIHV1aWQoKSB7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsXG4gICAgICB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFRyYWlsaW5nU2xhc2godXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcLyQvLCAnJylcbn1cblxuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVNldHRpbmdEZWZhdWx0czxcbiAgRGF0YWJhc2UgPSBhbnksXG4gIFNjaGVtYU5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSA9ICdwdWJsaWMnIGV4dGVuZHMga2V5b2YgRGF0YWJhc2VcbiAgICA/ICdwdWJsaWMnXG4gICAgOiBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZVxuPihcbiAgb3B0aW9uczogU3VwYWJhc2VDbGllbnRPcHRpb25zPFNjaGVtYU5hbWU+LFxuICBkZWZhdWx0czogU3VwYWJhc2VDbGllbnRPcHRpb25zPGFueT5cbik6IFJlcXVpcmVkPFN1cGFiYXNlQ2xpZW50T3B0aW9uczxTY2hlbWFOYW1lPj4ge1xuICBjb25zdCB7XG4gICAgZGI6IGRiT3B0aW9ucyxcbiAgICBhdXRoOiBhdXRoT3B0aW9ucyxcbiAgICByZWFsdGltZTogcmVhbHRpbWVPcHRpb25zLFxuICAgIGdsb2JhbDogZ2xvYmFsT3B0aW9ucyxcbiAgfSA9IG9wdGlvbnNcbiAgY29uc3Qge1xuICAgIGRiOiBERUZBVUxUX0RCX09QVElPTlMsXG4gICAgYXV0aDogREVGQVVMVF9BVVRIX09QVElPTlMsXG4gICAgcmVhbHRpbWU6IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyxcbiAgICBnbG9iYWw6IERFRkFVTFRfR0xPQkFMX09QVElPTlMsXG4gIH0gPSBkZWZhdWx0c1xuXG4gIGNvbnN0IHJlc3VsdDogUmVxdWlyZWQ8U3VwYWJhc2VDbGllbnRPcHRpb25zPFNjaGVtYU5hbWU+PiA9IHtcbiAgICBkYjoge1xuICAgICAgLi4uREVGQVVMVF9EQl9PUFRJT05TLFxuICAgICAgLi4uZGJPcHRpb25zLFxuICAgIH0sXG4gICAgYXV0aDoge1xuICAgICAgLi4uREVGQVVMVF9BVVRIX09QVElPTlMsXG4gICAgICAuLi5hdXRoT3B0aW9ucyxcbiAgICB9LFxuICAgIHJlYWx0aW1lOiB7XG4gICAgICAuLi5ERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsXG4gICAgICAuLi5yZWFsdGltZU9wdGlvbnMsXG4gICAgfSxcbiAgICBnbG9iYWw6IHtcbiAgICAgIC4uLkRFRkFVTFRfR0xPQkFMX09QVElPTlMsXG4gICAgICAuLi5nbG9iYWxPcHRpb25zLFxuICAgIH0sXG4gICAgYWNjZXNzVG9rZW46IGFzeW5jICgpID0+ICcnLFxuICB9XG5cbiAgaWYgKG9wdGlvbnMuYWNjZXNzVG9rZW4pIHtcbiAgICByZXN1bHQuYWNjZXNzVG9rZW4gPSBvcHRpb25zLmFjY2Vzc1Rva2VuXG4gIH0gZWxzZSB7XG4gICAgLy8gaGFjayBhcm91bmQgUmVxdWlyZWQ8PlxuICAgIGRlbGV0ZSAocmVzdWx0IGFzIGFueSkuYWNjZXNzVG9rZW5cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cbiIsICJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjY3LjMnXG4iLCAiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbidcbmV4cG9ydCBjb25zdCBHT1RSVUVfVVJMID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6OTk5OSdcbmV4cG9ydCBjb25zdCBTVE9SQUdFX0tFWSA9ICdzdXBhYmFzZS5hdXRoLnRva2VuJ1xuZXhwb3J0IGNvbnN0IEFVRElFTkNFID0gJydcbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYGdvdHJ1ZS1qcy8ke3ZlcnNpb259YCB9XG5leHBvcnQgY29uc3QgRVhQSVJZX01BUkdJTiA9IDEwIC8vIGluIHNlY29uZHNcbmV4cG9ydCBjb25zdCBORVRXT1JLX0ZBSUxVUkUgPSB7XG4gIE1BWF9SRVRSSUVTOiAxMCxcbiAgUkVUUllfSU5URVJWQUw6IDIsIC8vIGluIGRlY2lzZWNvbmRzXG59XG5cbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSA9ICdYLVN1cGFiYXNlLUFwaS1WZXJzaW9uJ1xuZXhwb3J0IGNvbnN0IEFQSV9WRVJTSU9OUyA9IHtcbiAgJzIwMjQtMDEtMDEnOiB7XG4gICAgdGltZXN0YW1wOiBEYXRlLnBhcnNlKCcyMDI0LTAxLTAxVDAwOjAwOjAwLjBaJyksXG4gICAgbmFtZTogJzIwMjQtMDEtMDEnLFxuICB9LFxufVxuIiwgImltcG9ydCB7IEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FIH0gZnJvbSAnLi9jb25zdGFudHMnXG5pbXBvcnQgeyBTdXBwb3J0ZWRTdG9yYWdlIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGlyZXNBdChleHBpcmVzSW46IG51bWJlcikge1xuICBjb25zdCB0aW1lTm93ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMClcbiAgcmV0dXJuIHRpbWVOb3cgKyBleHBpcmVzSW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHV1aWQoKSB7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCxcbiAgICAgIHYgPSBjID09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDhcbiAgICByZXR1cm4gdi50b1N0cmluZygxNilcbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuY29uc3QgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cyA9IHtcbiAgdGVzdGVkOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGxvY2FsU3RvcmFnZSBpcyBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLlxuICovXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNMb2NhbFN0b3JhZ2UgPSAoKSA9PiB7XG4gIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIERPTSBleGNlcHRpb24gd2hlbiBhY2Nlc3NpbmcgYGxvY2FsU3RvcmFnZWBcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCkge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlXG4gIH1cblxuICBjb25zdCByYW5kb21LZXkgPSBgbHN3dC0ke01hdGgucmFuZG9tKCl9JHtNYXRoLnJhbmRvbSgpfWBcblxuICB0cnkge1xuICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnNldEl0ZW0ocmFuZG9tS2V5LCByYW5kb21LZXkpXG4gICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShyYW5kb21LZXkpXG5cbiAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCA9IHRydWVcbiAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlID0gdHJ1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gbG9jYWxTdG9yYWdlIGNhbid0IGJlIHdyaXR0ZW4gdG9cbiAgICAvLyBodHRwczovL3d3dy5jaHJvbWl1bS5vcmcvZm9yLXRlc3RlcnMvYnVnLXJlcG9ydGluZy1ndWlkZWxpbmVzL3VuY2F1Z2h0LXNlY3VyaXR5ZXJyb3ItZmFpbGVkLXRvLXJlYWQtdGhlLWxvY2Fsc3RvcmFnZS1wcm9wZXJ0eS1mcm9tLXdpbmRvdy1hY2Nlc3MtaXMtZGVuaWVkLWZvci10aGlzLWRvY3VtZW50XG5cbiAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCA9IHRydWVcbiAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlID0gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlXG59XG5cbi8qKlxuICogRXh0cmFjdHMgcGFyYW1ldGVycyBlbmNvZGVkIGluIHRoZSBVUkwgYm90aCBpbiB0aGUgcXVlcnkgYW5kIGZyYWdtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXJzRnJvbVVSTChocmVmOiBzdHJpbmcpIHtcbiAgY29uc3QgcmVzdWx0OiB7IFtwYXJhbWV0ZXI6IHN0cmluZ106IHN0cmluZyB9ID0ge31cblxuICBjb25zdCB1cmwgPSBuZXcgVVJMKGhyZWYpXG5cbiAgaWYgKHVybC5oYXNoICYmIHVybC5oYXNoWzBdID09PSAnIycpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGFzaFNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModXJsLmhhc2guc3Vic3RyaW5nKDEpKVxuICAgICAgaGFzaFNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAvLyBoYXNoIGlzIG5vdCBhIHF1ZXJ5IHN0cmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIHNlYXJjaCBwYXJhbWV0ZXJzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGhhc2ggcGFyYW1ldGVyc1xuICB1cmwuc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlXG4gIH0pXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG50eXBlIEZldGNoID0gdHlwZW9mIGZldGNoXG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2g/OiBGZXRjaCk6IEZldGNoID0+IHtcbiAgbGV0IF9mZXRjaDogRmV0Y2hcbiAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgX2ZldGNoID0gY3VzdG9tRmV0Y2hcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgX2ZldGNoID0gKC4uLmFyZ3MpID0+XG4gICAgICBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJyBhcyBhbnkpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT4gZmV0Y2goLi4uYXJncykpXG4gIH0gZWxzZSB7XG4gICAgX2ZldGNoID0gZmV0Y2hcbiAgfVxuICByZXR1cm4gKC4uLmFyZ3MpID0+IF9mZXRjaCguLi5hcmdzKVxufVxuXG5leHBvcnQgY29uc3QgbG9va3NMaWtlRmV0Y2hSZXNwb25zZSA9IChtYXliZVJlc3BvbnNlOiB1bmtub3duKTogbWF5YmVSZXNwb25zZSBpcyBSZXNwb25zZSA9PiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIG1heWJlUmVzcG9uc2UgPT09ICdvYmplY3QnICYmXG4gICAgbWF5YmVSZXNwb25zZSAhPT0gbnVsbCAmJlxuICAgICdzdGF0dXMnIGluIG1heWJlUmVzcG9uc2UgJiZcbiAgICAnb2snIGluIG1heWJlUmVzcG9uc2UgJiZcbiAgICAnanNvbicgaW4gbWF5YmVSZXNwb25zZSAmJlxuICAgIHR5cGVvZiAobWF5YmVSZXNwb25zZSBhcyBhbnkpLmpzb24gPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG4vLyBTdG9yYWdlIGhlbHBlcnNcbmV4cG9ydCBjb25zdCBzZXRJdGVtQXN5bmMgPSBhc3luYyAoXG4gIHN0b3JhZ2U6IFN1cHBvcnRlZFN0b3JhZ2UsXG4gIGtleTogc3RyaW5nLFxuICBkYXRhOiBhbnlcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBhd2FpdCBzdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShkYXRhKSlcbn1cblxuZXhwb3J0IGNvbnN0IGdldEl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlOiBTdXBwb3J0ZWRTdG9yYWdlLCBrZXk6IHN0cmluZyk6IFByb21pc2U8dW5rbm93bj4gPT4ge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IHN0b3JhZ2UuZ2V0SXRlbShrZXkpXG5cbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmVtb3ZlSXRlbUFzeW5jID0gYXN5bmMgKHN0b3JhZ2U6IFN1cHBvcnRlZFN0b3JhZ2UsIGtleTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGF3YWl0IHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCYXNlNjRVUkwodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGtleSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSdcbiAgbGV0IGJhc2U2NCA9ICcnXG4gIGxldCBjaHIxLCBjaHIyLCBjaHIzXG4gIGxldCBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0XG4gIGxldCBpID0gMFxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJy0nLCAnKycpLnJlcGxhY2UoJ18nLCAnLycpXG5cbiAgd2hpbGUgKGkgPCB2YWx1ZS5sZW5ndGgpIHtcbiAgICBlbmMxID0ga2V5LmluZGV4T2YodmFsdWUuY2hhckF0KGkrKykpXG4gICAgZW5jMiA9IGtleS5pbmRleE9mKHZhbHVlLmNoYXJBdChpKyspKVxuICAgIGVuYzMgPSBrZXkuaW5kZXhPZih2YWx1ZS5jaGFyQXQoaSsrKSlcbiAgICBlbmM0ID0ga2V5LmluZGV4T2YodmFsdWUuY2hhckF0KGkrKykpXG4gICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNClcbiAgICBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMilcbiAgICBjaHIzID0gKChlbmMzICYgMykgPDwgNikgfCBlbmM0XG4gICAgYmFzZTY0ID0gYmFzZTY0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIxKVxuXG4gICAgaWYgKGVuYzMgIT0gNjQgJiYgY2hyMiAhPSAwKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpXG4gICAgfVxuICAgIGlmIChlbmM0ICE9IDY0ICYmIGNocjMgIT0gMCkge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIzKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYmFzZTY0XG59XG5cbi8qKlxuICogQSBkZWZlcnJlZCByZXByZXNlbnRzIHNvbWUgYXN5bmNocm9ub3VzIHdvcmsgdGhhdCBpcyBub3QgeWV0IGZpbmlzaGVkLCB3aGljaFxuICogbWF5IG9yIG1heSBub3QgY3VsbWluYXRlIGluIGEgdmFsdWUuXG4gKiBUYWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbWlrZS1ub3J0aC90eXBlcy9ibG9iL21hc3Rlci9zcmMvYXN5bmMudHNcbiAqL1xuZXhwb3J0IGNsYXNzIERlZmVycmVkPFQgPSBhbnk+IHtcbiAgcHVibGljIHN0YXRpYyBwcm9taXNlQ29uc3RydWN0b3I6IFByb21pc2VDb25zdHJ1Y3RvciA9IFByb21pc2VcblxuICBwdWJsaWMgcmVhZG9ubHkgcHJvbWlzZSE6IFByb21pc2VMaWtlPFQ+XG5cbiAgcHVibGljIHJlYWRvbmx5IHJlc29sdmUhOiAodmFsdWU/OiBUIHwgUHJvbWlzZUxpa2U8VD4pID0+IHZvaWRcblxuICBwdWJsaWMgcmVhZG9ubHkgcmVqZWN0ITogKHJlYXNvbj86IGFueSkgPT4gYW55XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgIDsodGhpcyBhcyBhbnkpLnByb21pc2UgPSBuZXcgRGVmZXJyZWQucHJvbWlzZUNvbnN0cnVjdG9yKChyZXMsIHJlaikgPT4ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gICAgICA7KHRoaXMgYXMgYW55KS5yZXNvbHZlID0gcmVzXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgIDsodGhpcyBhcyBhbnkpLnJlamVjdCA9IHJlalxuICAgIH0pXG4gIH1cbn1cblxuLy8gVGFrZW4gZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzg1NTIwMDMvaG93LXRvLWRlY29kZS1qd3QtdG9rZW4taW4tamF2YXNjcmlwdC13aXRob3V0LXVzaW5nLWEtbGlicmFyeVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUpXVFBheWxvYWQodG9rZW46IHN0cmluZykge1xuICAvLyBSZWdleCBjaGVja3MgZm9yIGJhc2U2NHVybCBmb3JtYXRcbiAgY29uc3QgYmFzZTY0VXJsUmVnZXggPSAvXihbYS16MC05Xy1dezR9KSooJHxbYS16MC05Xy1dezN9PT8kfFthLXowLTlfLV17Mn0oPT0pPyQpJC9pXG5cbiAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdCgnLicpXG5cbiAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignSldUIGlzIG5vdCB2YWxpZDogbm90IGEgSldUIHN0cnVjdHVyZScpXG4gIH1cblxuICBpZiAoIWJhc2U2NFVybFJlZ2V4LnRlc3QocGFydHNbMV0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdKV1QgaXMgbm90IHZhbGlkOiBwYXlsb2FkIGlzIG5vdCBpbiBiYXNlNjR1cmwgZm9ybWF0JylcbiAgfVxuXG4gIGNvbnN0IGJhc2U2NFVybCA9IHBhcnRzWzFdXG4gIHJldHVybiBKU09OLnBhcnNlKGRlY29kZUJhc2U2NFVSTChiYXNlNjRVcmwpKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gbnVsbCBhZnRlciBzb21lIHRpbWUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzbGVlcCh0aW1lOiBudW1iZXIpOiBQcm9taXNlPG51bGw+IHtcbiAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChhY2NlcHQpID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IGFjY2VwdChudWxsKSwgdGltZSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcHJvdmlkZWQgYXN5bmMgZnVuY3Rpb24gaW50byBhIHJldHJ5YWJsZSBmdW5jdGlvbi4gRWFjaCByZXN1bHRcbiAqIG9yIHRocm93biBlcnJvciBpcyBzZW50IHRvIHRoZSBpc1JldHJ5YWJsZSBmdW5jdGlvbiB3aGljaCBzaG91bGQgcmV0dXJuIHRydWVcbiAqIGlmIHRoZSBmdW5jdGlvbiBzaG91bGQgcnVuIGFnYWluLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV0cnlhYmxlPFQ+KFxuICBmbjogKGF0dGVtcHQ6IG51bWJlcikgPT4gUHJvbWlzZTxUPixcbiAgaXNSZXRyeWFibGU6IChhdHRlbXB0OiBudW1iZXIsIGVycm9yOiBhbnkgfCBudWxsLCByZXN1bHQ/OiBUKSA9PiBib29sZWFuXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFQ+KChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgIDsoYXN5bmMgKCkgPT4ge1xuICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBJbmZpbml0eTsgYXR0ZW1wdCsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oYXR0ZW1wdClcblxuICAgICAgICAgIGlmICghaXNSZXRyeWFibGUoYXR0ZW1wdCwgbnVsbCwgcmVzdWx0KSkge1xuICAgICAgICAgICAgYWNjZXB0KHJlc3VsdClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgaWYgKCFpc1JldHJ5YWJsZShhdHRlbXB0LCBlKSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSgpXG4gIH0pXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gZGVjMmhleChkZWM6IG51bWJlcikge1xuICByZXR1cm4gKCcwJyArIGRlYy50b1N0cmluZygxNikpLnN1YnN0cigtMilcbn1cblxuLy8gRnVuY3Rpb25zIGJlbG93IHRha2VuIGZyb206IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYzMzA5NDA5L2NyZWF0aW5nLWEtY29kZS12ZXJpZmllci1hbmQtY2hhbGxlbmdlLWZvci1wa2NlLWF1dGgtb24tc3BvdGlmeS1hcGktaW4tcmVhY3Rqc1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUEtDRVZlcmlmaWVyKCkge1xuICBjb25zdCB2ZXJpZmllckxlbmd0aCA9IDU2XG4gIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KHZlcmlmaWVyTGVuZ3RoKVxuICBpZiAodHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdCBjaGFyU2V0ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LS5ffidcbiAgICBjb25zdCBjaGFyU2V0TGVuID0gY2hhclNldC5sZW5ndGhcbiAgICBsZXQgdmVyaWZpZXIgPSAnJ1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVyaWZpZXJMZW5ndGg7IGkrKykge1xuICAgICAgdmVyaWZpZXIgKz0gY2hhclNldC5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhclNldExlbikpXG4gICAgfVxuICAgIHJldHVybiB2ZXJpZmllclxuICB9XG4gIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpXG4gIHJldHVybiBBcnJheS5mcm9tKGFycmF5LCBkZWMyaGV4KS5qb2luKCcnKVxufVxuXG5hc3luYyBmdW5jdGlvbiBzaGEyNTYocmFuZG9tU3RyaW5nOiBzdHJpbmcpIHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG4gIGNvbnN0IGVuY29kZWREYXRhID0gZW5jb2Rlci5lbmNvZGUocmFuZG9tU3RyaW5nKVxuICBjb25zdCBoYXNoID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBlbmNvZGVkRGF0YSlcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShoYXNoKVxuXG4gIHJldHVybiBBcnJheS5mcm9tKGJ5dGVzKVxuICAgIC5tYXAoKGMpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYykpXG4gICAgLmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NHVybGVuY29kZShzdHI6IHN0cmluZykge1xuICByZXR1cm4gYnRvYShzdHIpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpLnJlcGxhY2UoLz0rJC8sICcnKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVQS0NFQ2hhbGxlbmdlKHZlcmlmaWVyOiBzdHJpbmcpIHtcbiAgY29uc3QgaGFzQ3J5cHRvU3VwcG9ydCA9XG4gICAgdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY3J5cHRvLnN1YnRsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnXG5cbiAgaWYgKCFoYXNDcnlwdG9TdXBwb3J0KSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1dlYkNyeXB0byBBUEkgaXMgbm90IHN1cHBvcnRlZC4gQ29kZSBjaGFsbGVuZ2UgbWV0aG9kIHdpbGwgZGVmYXVsdCB0byB1c2UgcGxhaW4gaW5zdGVhZCBvZiBzaGEyNTYuJ1xuICAgIClcbiAgICByZXR1cm4gdmVyaWZpZXJcbiAgfVxuICBjb25zdCBoYXNoZWQgPSBhd2FpdCBzaGEyNTYodmVyaWZpZXIpXG4gIHJldHVybiBiYXNlNjR1cmxlbmNvZGUoaGFzaGVkKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChcbiAgc3RvcmFnZTogU3VwcG9ydGVkU3RvcmFnZSxcbiAgc3RvcmFnZUtleTogc3RyaW5nLFxuICBpc1Bhc3N3b3JkUmVjb3ZlcnkgPSBmYWxzZVxuKSB7XG4gIGNvbnN0IGNvZGVWZXJpZmllciA9IGdlbmVyYXRlUEtDRVZlcmlmaWVyKClcbiAgbGV0IHN0b3JlZENvZGVWZXJpZmllciA9IGNvZGVWZXJpZmllclxuICBpZiAoaXNQYXNzd29yZFJlY292ZXJ5KSB7XG4gICAgc3RvcmVkQ29kZVZlcmlmaWVyICs9ICcvUEFTU1dPUkRfUkVDT1ZFUlknXG4gIH1cbiAgYXdhaXQgc2V0SXRlbUFzeW5jKHN0b3JhZ2UsIGAke3N0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgLCBzdG9yZWRDb2RlVmVyaWZpZXIpXG4gIGNvbnN0IGNvZGVDaGFsbGVuZ2UgPSBhd2FpdCBnZW5lcmF0ZVBLQ0VDaGFsbGVuZ2UoY29kZVZlcmlmaWVyKVxuICBjb25zdCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gY29kZVZlcmlmaWVyID09PSBjb2RlQ2hhbGxlbmdlID8gJ3BsYWluJyA6ICdzMjU2J1xuICByZXR1cm4gW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdXG59XG5cbi8qKiBQYXJzZXMgdGhlIEFQSSB2ZXJzaW9uIHdoaWNoIGlzIDJZWVktTU0tREQuICovXG5jb25zdCBBUElfVkVSU0lPTl9SRUdFWCA9IC9eMlswLTldezN9LSgwWzEtOV18MVswLTJdKS0oMFsxLTldfDFbMC05XXwyWzAtOV18M1swLTFdKSQvaVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZXNwb25zZUFQSVZlcnNpb24ocmVzcG9uc2U6IFJlc3BvbnNlKSB7XG4gIGNvbnN0IGFwaVZlcnNpb24gPSByZXNwb25zZS5oZWFkZXJzLmdldChBUElfVkVSU0lPTl9IRUFERVJfTkFNRSlcblxuICBpZiAoIWFwaVZlcnNpb24pIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgaWYgKCFhcGlWZXJzaW9uLm1hdGNoKEFQSV9WRVJTSU9OX1JFR0VYKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHthcGlWZXJzaW9ufVQwMDowMDowMC4wWmApXG4gICAgcmV0dXJuIGRhdGVcbiAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuIiwgImltcG9ydCB7IFdlYWtQYXNzd29yZFJlYXNvbnMgfSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHsgRXJyb3JDb2RlIH0gZnJvbSAnLi9lcnJvci1jb2RlcydcblxuZXhwb3J0IGNsYXNzIEF1dGhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIEVycm9yIGNvZGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBlcnJvci4gTW9zdCBlcnJvcnMgY29taW5nIGZyb21cbiAgICogSFRUUCByZXNwb25zZXMgd2lsbCBoYXZlIGEgY29kZSwgdGhvdWdoIHNvbWUgZXJyb3JzIHRoYXQgb2NjdXJcbiAgICogYmVmb3JlIGEgcmVzcG9uc2UgaXMgcmVjZWl2ZWQgd2lsbCBub3QgaGF2ZSBvbmUgcHJlc2VudC4gSW4gdGhhdFxuICAgKiBjYXNlIHtAbGluayAjc3RhdHVzfSB3aWxsIGFsc28gYmUgdW5kZWZpbmVkLlxuICAgKi9cbiAgY29kZTogRXJyb3JDb2RlIHwgKHN0cmluZyAmIHt9KSB8IHVuZGVmaW5lZFxuXG4gIC8qKiBIVFRQIHN0YXR1cyBjb2RlIHRoYXQgY2F1c2VkIHRoZSBlcnJvci4gKi9cbiAgc3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWRcblxuICBwcm90ZWN0ZWQgX19pc0F1dGhFcnJvciA9IHRydWVcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1cz86IG51bWJlciwgY29kZT86IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0F1dGhFcnJvcidcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c1xuICAgIHRoaXMuY29kZSA9IGNvZGVcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBBdXRoRXJyb3Ige1xuICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnX19pc0F1dGhFcnJvcicgaW4gZXJyb3Jcbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhBcGlFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gIHN0YXR1czogbnVtYmVyXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBzdGF0dXM6IG51bWJlciwgY29kZTogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgc3RhdHVzLCBjb2RlKVxuICAgIHRoaXMubmFtZSA9ICdBdXRoQXBpRXJyb3InXG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXNcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aEFwaUVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgQXV0aEFwaUVycm9yIHtcbiAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aEFwaUVycm9yJ1xufVxuXG5leHBvcnQgY2xhc3MgQXV0aFVua25vd25FcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gIG9yaWdpbmFsRXJyb3I6IHVua25vd25cblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIG9yaWdpbmFsRXJyb3I6IHVua25vd24pIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdBdXRoVW5rbm93bkVycm9yJ1xuICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3JcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ3VzdG9tQXV0aEVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgbmFtZTogc3RyaW5nXG4gIHN0YXR1czogbnVtYmVyXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyLCBjb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBzdGF0dXMsIGNvZGUpXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ0F1dGggc2Vzc2lvbiBtaXNzaW5nIScsICdBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcicsIDQwMCwgdW5kZWZpbmVkKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKGVycm9yOiBhbnkpOiBlcnJvciBpcyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciB7XG4gIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yJ1xufVxuXG5leHBvcnQgY2xhc3MgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignQXV0aCBzZXNzaW9uIG9yIHVzZXIgbWlzc2luZycsICdBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcicsIDUwMCwgdW5kZWZpbmVkKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlLCAnQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yJywgNDAwLCB1bmRlZmluZWQpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gIGRldGFpbHM6IHsgZXJyb3I6IHN0cmluZzsgY29kZTogc3RyaW5nIH0gfCBudWxsID0gbnVsbFxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGRldGFpbHM6IHsgZXJyb3I6IHN0cmluZzsgY29kZTogc3RyaW5nIH0gfCBudWxsID0gbnVsbCkge1xuICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3InLCA1MDAsIHVuZGVmaW5lZClcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzXG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBkZXRhaWxzOiB0aGlzLmRldGFpbHMsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihcbiAgZXJyb3I6IGFueVxuKTogZXJyb3IgaXMgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIHtcbiAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yJ1xufVxuXG5leHBvcnQgY2xhc3MgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgZGV0YWlsczogeyBlcnJvcjogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBkZXRhaWxzOiB7IGVycm9yOiBzdHJpbmc7IGNvZGU6IHN0cmluZyB9IHwgbnVsbCA9IG51bGwpIHtcbiAgICBzdXBlcihtZXNzYWdlLCAnQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yJywgNTAwLCB1bmRlZmluZWQpXG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlsc1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgZGV0YWlsczogdGhpcy5kZXRhaWxzLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhSZXRyeWFibGVGZXRjaEVycm9yJywgc3RhdHVzLCB1bmRlZmluZWQpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciB7XG4gIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhSZXRyeWFibGVGZXRjaEVycm9yJ1xufVxuXG4vKipcbiAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIG9uIGNlcnRhaW4gbWV0aG9kcyB3aGVuIHRoZSBwYXNzd29yZCB1c2VkIGlzIGRlZW1lZFxuICogd2Vhay4gSW5zcGVjdCB0aGUgcmVhc29ucyB0byBpZGVudGlmeSB3aGF0IHBhc3N3b3JkIHN0cmVuZ3RoIHJ1bGVzIGFyZVxuICogaW5hZGVxdWF0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhXZWFrUGFzc3dvcmRFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gIC8qKlxuICAgKiBSZWFzb25zIHdoeSB0aGUgcGFzc3dvcmQgaXMgZGVlbWVkIHdlYWsuXG4gICAqL1xuICByZWFzb25zOiBXZWFrUGFzc3dvcmRSZWFzb25zW11cblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyLCByZWFzb25zOiBzdHJpbmdbXSkge1xuICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoV2Vha1Bhc3N3b3JkRXJyb3InLCBzdGF0dXMsICd3ZWFrX3Bhc3N3b3JkJylcblxuICAgIHRoaXMucmVhc29ucyA9IHJlYXNvbnNcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBBdXRoV2Vha1Bhc3N3b3JkRXJyb3Ige1xuICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoV2Vha1Bhc3N3b3JkRXJyb3InXG59XG4iLCAiaW1wb3J0IHsgQVBJX1ZFUlNJT05TLCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSB9IGZyb20gJy4vY29uc3RhbnRzJ1xuaW1wb3J0IHsgZXhwaXJlc0F0LCBsb29rc0xpa2VGZXRjaFJlc3BvbnNlLCBwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbiB9IGZyb20gJy4vaGVscGVycydcbmltcG9ydCB7XG4gIEF1dGhSZXNwb25zZSxcbiAgQXV0aFJlc3BvbnNlUGFzc3dvcmQsXG4gIFNTT1Jlc3BvbnNlLFxuICBHZW5lcmF0ZUxpbmtQcm9wZXJ0aWVzLFxuICBHZW5lcmF0ZUxpbmtSZXNwb25zZSxcbiAgVXNlcixcbiAgVXNlclJlc3BvbnNlLFxufSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHtcbiAgQXV0aEFwaUVycm9yLFxuICBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcixcbiAgQXV0aFdlYWtQYXNzd29yZEVycm9yLFxuICBBdXRoVW5rbm93bkVycm9yLFxuICBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcixcbn0gZnJvbSAnLi9lcnJvcnMnXG5cbmV4cG9ydCB0eXBlIEZldGNoID0gdHlwZW9mIGZldGNoXG5cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hPcHRpb25zIHtcbiAgaGVhZGVycz86IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuICBub1Jlc29sdmVKc29uPzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZldGNoUGFyYW1ldGVycyB7XG4gIHNpZ25hbD86IEFib3J0U2lnbmFsXG59XG5cbmV4cG9ydCB0eXBlIFJlcXVlc3RNZXRob2RUeXBlID0gJ0dFVCcgfCAnUE9TVCcgfCAnUFVUJyB8ICdERUxFVEUnXG5cbmNvbnN0IF9nZXRFcnJvck1lc3NhZ2UgPSAoZXJyOiBhbnkpOiBzdHJpbmcgPT5cbiAgZXJyLm1zZyB8fCBlcnIubWVzc2FnZSB8fCBlcnIuZXJyb3JfZGVzY3JpcHRpb24gfHwgZXJyLmVycm9yIHx8IEpTT04uc3RyaW5naWZ5KGVycilcblxuY29uc3QgTkVUV09SS19FUlJPUl9DT0RFUyA9IFs1MDIsIDUwMywgNTA0XVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3I6IHVua25vd24pIHtcbiAgaWYgKCFsb29rc0xpa2VGZXRjaFJlc3BvbnNlKGVycm9yKSkge1xuICAgIHRocm93IG5ldyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSwgMClcbiAgfVxuXG4gIGlmIChORVRXT1JLX0VSUk9SX0NPREVTLmluY2x1ZGVzKGVycm9yLnN0YXR1cykpIHtcbiAgICAvLyBzdGF0dXMgaW4gNTAwLi4uNTk5IHJhbmdlIC0gc2VydmVyIGhhZCBhbiBlcnJvciwgcmVxdWVzdCBtaWdodCBiZSByZXRyeWVkLlxuICAgIHRocm93IG5ldyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSwgZXJyb3Iuc3RhdHVzKVxuICB9XG5cbiAgbGV0IGRhdGE6IGFueVxuICB0cnkge1xuICAgIGRhdGEgPSBhd2FpdCBlcnJvci5qc29uKClcbiAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgdGhyb3cgbmV3IEF1dGhVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZShlKSwgZSlcbiAgfVxuXG4gIGxldCBlcnJvckNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuXG4gIGNvbnN0IHJlc3BvbnNlQVBJVmVyc2lvbiA9IHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uKGVycm9yKVxuICBpZiAoXG4gICAgcmVzcG9uc2VBUElWZXJzaW9uICYmXG4gICAgcmVzcG9uc2VBUElWZXJzaW9uLmdldFRpbWUoKSA+PSBBUElfVkVSU0lPTlNbJzIwMjQtMDEtMDEnXS50aW1lc3RhbXAgJiZcbiAgICB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICBkYXRhICYmXG4gICAgdHlwZW9mIGRhdGEuY29kZSA9PT0gJ3N0cmluZydcbiAgKSB7XG4gICAgZXJyb3JDb2RlID0gZGF0YS5jb2RlXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgJiYgdHlwZW9mIGRhdGEuZXJyb3JfY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICBlcnJvckNvZGUgPSBkYXRhLmVycm9yX2NvZGVcbiAgfVxuXG4gIGlmICghZXJyb3JDb2RlKSB7XG4gICAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHdlYWsgcGFzc3dvcmQgZXJyb3JzLCB3aGVuIHRoZXJlIHdlcmUgbm8gZXJyb3IgY29kZXNcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIGRhdGEgJiZcbiAgICAgIHR5cGVvZiBkYXRhLndlYWtfcGFzc3dvcmQgPT09ICdvYmplY3QnICYmXG4gICAgICBkYXRhLndlYWtfcGFzc3dvcmQgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkoZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMpICYmXG4gICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5sZW5ndGggJiZcbiAgICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zLnJlZHVjZSgoYTogYm9vbGVhbiwgaTogYW55KSA9PiBhICYmIHR5cGVvZiBpID09PSAnc3RyaW5nJywgdHJ1ZSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoXG4gICAgICAgIF9nZXRFcnJvck1lc3NhZ2UoZGF0YSksXG4gICAgICAgIGVycm9yLnN0YXR1cyxcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnNcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXJyb3JDb2RlID09PSAnd2Vha19wYXNzd29yZCcpIHtcbiAgICB0aHJvdyBuZXcgQXV0aFdlYWtQYXNzd29yZEVycm9yKFxuICAgICAgX2dldEVycm9yTWVzc2FnZShkYXRhKSxcbiAgICAgIGVycm9yLnN0YXR1cyxcbiAgICAgIGRhdGEud2Vha19wYXNzd29yZD8ucmVhc29ucyB8fCBbXVxuICAgIClcbiAgfSBlbHNlIGlmIChlcnJvckNvZGUgPT09ICdzZXNzaW9uX25vdF9mb3VuZCcpIHtcbiAgICAvLyBUaGUgYHNlc3Npb25faWRgIGluc2lkZSB0aGUgSldUIGRvZXMgbm90IGNvcnJlc3BvbmQgdG8gYSByb3cgaW4gdGhlXG4gICAgLy8gYHNlc3Npb25zYCB0YWJsZS4gVGhpcyB1c3VhbGx5IG1lYW5zIHRoZSB1c2VyIGhhcyBzaWduZWQgb3V0LCBoYXMgYmVlblxuICAgIC8vIGRlbGV0ZWQsIG9yIHRoZWlyIHNlc3Npb24gaGFzIHNvbWVob3cgYmVlbiB0ZXJtaW5hdGVkLlxuICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG4gIH1cblxuICB0aHJvdyBuZXcgQXV0aEFwaUVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZGF0YSksIGVycm9yLnN0YXR1cyB8fCA1MDAsIGVycm9yQ29kZSlcbn1cblxuY29uc3QgX2dldFJlcXVlc3RQYXJhbXMgPSAoXG4gIG1ldGhvZDogUmVxdWVzdE1ldGhvZFR5cGUsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnMsXG4gIGJvZHk/OiBvYmplY3RcbikgPT4ge1xuICBjb25zdCBwYXJhbXM6IHsgW2s6IHN0cmluZ106IGFueSB9ID0geyBtZXRob2QsIGhlYWRlcnM6IG9wdGlvbnM/LmhlYWRlcnMgfHwge30gfVxuXG4gIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG5cbiAgcGFyYW1zLmhlYWRlcnMgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04JywgLi4ub3B0aW9ucz8uaGVhZGVycyB9XG4gIHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgcmV0dXJuIHsgLi4ucGFyYW1zLCAuLi5wYXJhbWV0ZXJzIH1cbn1cblxuaW50ZXJmYWNlIEdvdHJ1ZVJlcXVlc3RPcHRpb25zIGV4dGVuZHMgRmV0Y2hPcHRpb25zIHtcbiAgand0Pzogc3RyaW5nXG4gIHJlZGlyZWN0VG8/OiBzdHJpbmdcbiAgYm9keT86IG9iamVjdFxuICBxdWVyeT86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRoYXQgdHJhbnNmb3JtcyBhcGkgcmVzcG9uc2UgZnJvbSBnb3RydWUgaW50byBhIGRlc2lyYWJsZSAvIHN0YW5kYXJkaXNlZCBmb3JtYXRcbiAgICovXG4gIHhmb3JtPzogKGRhdGE6IGFueSkgPT4gYW55XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfcmVxdWVzdChcbiAgZmV0Y2hlcjogRmV0Y2gsXG4gIG1ldGhvZDogUmVxdWVzdE1ldGhvZFR5cGUsXG4gIHVybDogc3RyaW5nLFxuICBvcHRpb25zPzogR290cnVlUmVxdWVzdE9wdGlvbnNcbikge1xuICBjb25zdCBoZWFkZXJzID0ge1xuICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gIH1cblxuICBpZiAoIWhlYWRlcnNbQVBJX1ZFUlNJT05fSEVBREVSX05BTUVdKSB7XG4gICAgaGVhZGVyc1tBUElfVkVSU0lPTl9IRUFERVJfTkFNRV0gPSBBUElfVkVSU0lPTlNbJzIwMjQtMDEtMDEnXS5uYW1lXG4gIH1cblxuICBpZiAob3B0aW9ucz8uand0KSB7XG4gICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke29wdGlvbnMuand0fWBcbiAgfVxuXG4gIGNvbnN0IHFzID0gb3B0aW9ucz8ucXVlcnkgPz8ge31cbiAgaWYgKG9wdGlvbnM/LnJlZGlyZWN0VG8pIHtcbiAgICBxc1sncmVkaXJlY3RfdG8nXSA9IG9wdGlvbnMucmVkaXJlY3RUb1xuICB9XG5cbiAgY29uc3QgcXVlcnlTdHJpbmcgPSBPYmplY3Qua2V5cyhxcykubGVuZ3RoID8gJz8nICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhxcykudG9TdHJpbmcoKSA6ICcnXG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBfaGFuZGxlUmVxdWVzdChcbiAgICBmZXRjaGVyLFxuICAgIG1ldGhvZCxcbiAgICB1cmwgKyBxdWVyeVN0cmluZyxcbiAgICB7XG4gICAgICBoZWFkZXJzLFxuICAgICAgbm9SZXNvbHZlSnNvbjogb3B0aW9ucz8ubm9SZXNvbHZlSnNvbixcbiAgICB9LFxuICAgIHt9LFxuICAgIG9wdGlvbnM/LmJvZHlcbiAgKVxuICByZXR1cm4gb3B0aW9ucz8ueGZvcm0gPyBvcHRpb25zPy54Zm9ybShkYXRhKSA6IHsgZGF0YTogeyAuLi5kYXRhIH0sIGVycm9yOiBudWxsIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QoXG4gIGZldGNoZXI6IEZldGNoLFxuICBtZXRob2Q6IFJlcXVlc3RNZXRob2RUeXBlLFxuICB1cmw6IHN0cmluZyxcbiAgb3B0aW9ucz86IEZldGNoT3B0aW9ucyxcbiAgcGFyYW1ldGVycz86IEZldGNoUGFyYW1ldGVycyxcbiAgYm9keT86IG9iamVjdFxuKTogUHJvbWlzZTxhbnk+IHtcbiAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IF9nZXRSZXF1ZXN0UGFyYW1zKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSlcblxuICBsZXQgcmVzdWx0OiBhbnlcblxuICB0cnkge1xuICAgIHJlc3VsdCA9IGF3YWl0IGZldGNoZXIodXJsLCB7XG4gICAgICAuLi5yZXF1ZXN0UGFyYW1zLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpXG5cbiAgICAvLyBmZXRjaCBmYWlsZWQsIGxpa2VseSBkdWUgdG8gYSBuZXR3b3JrIG9yIENPUlMgZXJyb3JcbiAgICB0aHJvdyBuZXcgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoX2dldEVycm9yTWVzc2FnZShlKSwgMClcbiAgfVxuXG4gIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgYXdhaXQgaGFuZGxlRXJyb3IocmVzdWx0KVxuICB9XG5cbiAgaWYgKG9wdGlvbnM/Lm5vUmVzb2x2ZUpzb24pIHtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCByZXN1bHQuanNvbigpXG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIGF3YWl0IGhhbmRsZUVycm9yKGUpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9zZXNzaW9uUmVzcG9uc2UoZGF0YTogYW55KTogQXV0aFJlc3BvbnNlIHtcbiAgbGV0IHNlc3Npb24gPSBudWxsXG4gIGlmIChoYXNTZXNzaW9uKGRhdGEpKSB7XG4gICAgc2Vzc2lvbiA9IHsgLi4uZGF0YSB9XG5cbiAgICBpZiAoIWRhdGEuZXhwaXJlc19hdCkge1xuICAgICAgc2Vzc2lvbi5leHBpcmVzX2F0ID0gZXhwaXJlc0F0KGRhdGEuZXhwaXJlc19pbilcbiAgICB9XG4gIH1cblxuICBjb25zdCB1c2VyOiBVc2VyID0gZGF0YS51c2VyID8/IChkYXRhIGFzIFVzZXIpXG4gIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbiwgdXNlciB9LCBlcnJvcjogbnVsbCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQoZGF0YTogYW55KTogQXV0aFJlc3BvbnNlUGFzc3dvcmQge1xuICBjb25zdCByZXNwb25zZSA9IF9zZXNzaW9uUmVzcG9uc2UoZGF0YSkgYXMgQXV0aFJlc3BvbnNlUGFzc3dvcmRcblxuICBpZiAoXG4gICAgIXJlc3BvbnNlLmVycm9yICYmXG4gICAgZGF0YS53ZWFrX3Bhc3N3b3JkICYmXG4gICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZCA9PT0gJ29iamVjdCcgJiZcbiAgICBBcnJheS5pc0FycmF5KGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKSAmJlxuICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zLmxlbmd0aCAmJlxuICAgIGRhdGEud2Vha19wYXNzd29yZC5tZXNzYWdlICYmXG4gICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZC5tZXNzYWdlID09PSAnc3RyaW5nJyAmJlxuICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zLnJlZHVjZSgoYTogYm9vbGVhbiwgaTogYW55KSA9PiBhICYmIHR5cGVvZiBpID09PSAnc3RyaW5nJywgdHJ1ZSlcbiAgKSB7XG4gICAgcmVzcG9uc2UuZGF0YS53ZWFrX3Bhc3N3b3JkID0gZGF0YS53ZWFrX3Bhc3N3b3JkXG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF91c2VyUmVzcG9uc2UoZGF0YTogYW55KTogVXNlclJlc3BvbnNlIHtcbiAgY29uc3QgdXNlcjogVXNlciA9IGRhdGEudXNlciA/PyAoZGF0YSBhcyBVc2VyKVxuICByZXR1cm4geyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IG51bGwgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX3Nzb1Jlc3BvbnNlKGRhdGE6IGFueSk6IFNTT1Jlc3BvbnNlIHtcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX2dlbmVyYXRlTGlua1Jlc3BvbnNlKGRhdGE6IGFueSk6IEdlbmVyYXRlTGlua1Jlc3BvbnNlIHtcbiAgY29uc3QgeyBhY3Rpb25fbGluaywgZW1haWxfb3RwLCBoYXNoZWRfdG9rZW4sIHJlZGlyZWN0X3RvLCB2ZXJpZmljYXRpb25fdHlwZSwgLi4ucmVzdCB9ID0gZGF0YVxuXG4gIGNvbnN0IHByb3BlcnRpZXM6IEdlbmVyYXRlTGlua1Byb3BlcnRpZXMgPSB7XG4gICAgYWN0aW9uX2xpbmssXG4gICAgZW1haWxfb3RwLFxuICAgIGhhc2hlZF90b2tlbixcbiAgICByZWRpcmVjdF90byxcbiAgICB2ZXJpZmljYXRpb25fdHlwZSxcbiAgfVxuXG4gIGNvbnN0IHVzZXI6IFVzZXIgPSB7IC4uLnJlc3QgfVxuICByZXR1cm4ge1xuICAgIGRhdGE6IHtcbiAgICAgIHByb3BlcnRpZXMsXG4gICAgICB1c2VyLFxuICAgIH0sXG4gICAgZXJyb3I6IG51bGwsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9ub1Jlc29sdmVKc29uUmVzcG9uc2UoZGF0YTogYW55KTogUmVzcG9uc2Uge1xuICByZXR1cm4gZGF0YVxufVxuXG4vKipcbiAqIGhhc1Nlc3Npb24gY2hlY2tzIGlmIHRoZSByZXNwb25zZSBvYmplY3QgY29udGFpbnMgYSB2YWxpZCBzZXNzaW9uXG4gKiBAcGFyYW0gZGF0YSBBIHJlc3BvbnNlIG9iamVjdFxuICogQHJldHVybnMgdHJ1ZSBpZiBhIHNlc3Npb24gaXMgaW4gdGhlIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGhhc1Nlc3Npb24oZGF0YTogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiBkYXRhLmFjY2Vzc190b2tlbiAmJiBkYXRhLnJlZnJlc2hfdG9rZW4gJiYgZGF0YS5leHBpcmVzX2luXG59XG4iLCAiaW1wb3J0IHtcbiAgRmV0Y2gsXG4gIF9nZW5lcmF0ZUxpbmtSZXNwb25zZSxcbiAgX25vUmVzb2x2ZUpzb25SZXNwb25zZSxcbiAgX3JlcXVlc3QsXG4gIF91c2VyUmVzcG9uc2UsXG59IGZyb20gJy4vbGliL2ZldGNoJ1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi9saWIvaGVscGVycydcbmltcG9ydCB7XG4gIEFkbWluVXNlckF0dHJpYnV0ZXMsXG4gIEdlbmVyYXRlTGlua1BhcmFtcyxcbiAgR2VuZXJhdGVMaW5rUmVzcG9uc2UsXG4gIFBhZ2luYXRpb24sXG4gIFVzZXIsXG4gIFVzZXJSZXNwb25zZSxcbiAgR29UcnVlQWRtaW5NRkFBcGksXG4gIEF1dGhNRkFBZG1pbkRlbGV0ZUZhY3RvclBhcmFtcyxcbiAgQXV0aE1GQUFkbWluRGVsZXRlRmFjdG9yUmVzcG9uc2UsXG4gIEF1dGhNRkFBZG1pbkxpc3RGYWN0b3JzUGFyYW1zLFxuICBBdXRoTUZBQWRtaW5MaXN0RmFjdG9yc1Jlc3BvbnNlLFxuICBQYWdlUGFyYW1zLFxufSBmcm9tICcuL2xpYi90eXBlcydcbmltcG9ydCB7IEF1dGhFcnJvciwgaXNBdXRoRXJyb3IgfSBmcm9tICcuL2xpYi9lcnJvcnMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdvVHJ1ZUFkbWluQXBpIHtcbiAgLyoqIENvbnRhaW5zIGFsbCBNRkEgYWRtaW5pc3RyYXRpb24gbWV0aG9kcy4gKi9cbiAgbWZhOiBHb1RydWVBZG1pbk1GQUFwaVxuXG4gIHByb3RlY3RlZCB1cmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgaGVhZGVyczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9XG4gIHByb3RlY3RlZCBmZXRjaDogRmV0Y2hcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgdXJsID0gJycsXG4gICAgaGVhZGVycyA9IHt9LFxuICAgIGZldGNoLFxuICB9OiB7XG4gICAgdXJsOiBzdHJpbmdcbiAgICBoZWFkZXJzPzoge1xuICAgICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gICAgfVxuICAgIGZldGNoPzogRmV0Y2hcbiAgfSkge1xuICAgIHRoaXMudXJsID0gdXJsXG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVyc1xuICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goZmV0Y2gpXG4gICAgdGhpcy5tZmEgPSB7XG4gICAgICBsaXN0RmFjdG9yczogdGhpcy5fbGlzdEZhY3RvcnMuYmluZCh0aGlzKSxcbiAgICAgIGRlbGV0ZUZhY3RvcjogdGhpcy5fZGVsZXRlRmFjdG9yLmJpbmQodGhpcyksXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBsb2dnZWQtaW4gc2Vzc2lvbi5cbiAgICogQHBhcmFtIGp3dCBBIHZhbGlkLCBsb2dnZWQtaW4gSldULlxuICAgKiBAcGFyYW0gc2NvcGUgVGhlIGxvZ291dCBzb3BlLlxuICAgKi9cbiAgYXN5bmMgc2lnbk91dChcbiAgICBqd3Q6IHN0cmluZyxcbiAgICBzY29wZTogJ2dsb2JhbCcgfCAnbG9jYWwnIHwgJ290aGVycycgPSAnZ2xvYmFsJ1xuICApOiBQcm9taXNlPHsgZGF0YTogbnVsbDsgZXJyb3I6IEF1dGhFcnJvciB8IG51bGwgfT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9sb2dvdXQ/c2NvcGU9JHtzY29wZX1gLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgand0LFxuICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGFuIGludml0ZSBsaW5rIHRvIGFuIGVtYWlsIGFkZHJlc3MuXG4gICAqIEBwYXJhbSBlbWFpbCBUaGUgZW1haWwgYWRkcmVzcyBvZiB0aGUgdXNlci5cbiAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIGJlIGluY2x1ZGVkIHdoZW4gaW52aXRpbmcuXG4gICAqL1xuICBhc3luYyBpbnZpdGVVc2VyQnlFbWFpbChcbiAgICBlbWFpbDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIC8qKiBBIGN1c3RvbSBkYXRhIG9iamVjdCB0byBzdG9yZSBhZGRpdGlvbmFsIG1ldGFkYXRhIGFib3V0IHRoZSB1c2VyLiBUaGlzIG1hcHMgdG8gdGhlIGBhdXRoLnVzZXJzLnVzZXJfbWV0YWRhdGFgIGNvbHVtbi4gKi9cbiAgICAgIGRhdGE/OiBvYmplY3RcblxuICAgICAgLyoqIFRoZSBVUkwgd2hpY2ggd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZW1haWwgbGluayBzZW50IHRvIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy4gT25jZSBjbGlja2VkIHRoZSB1c2VyIHdpbGwgZW5kIHVwIG9uIHRoaXMgVVJMLiAqL1xuICAgICAgcmVkaXJlY3RUbz86IHN0cmluZ1xuICAgIH0gPSB7fVxuICApOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vaW52aXRlYCwge1xuICAgICAgICBib2R5OiB7IGVtYWlsLCBkYXRhOiBvcHRpb25zLmRhdGEgfSxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgZW1haWwgbGlua3MgYW5kIE9UUHMgdG8gYmUgc2VudCB2aWEgYSBjdXN0b20gZW1haWwgcHJvdmlkZXIuXG4gICAqIEBwYXJhbSBlbWFpbCBUaGUgdXNlcidzIGVtYWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5wYXNzd29yZCBVc2VyIHBhc3N3b3JkLiBGb3Igc2lnbnVwIG9ubHkuXG4gICAqIEBwYXJhbSBvcHRpb25zLmRhdGEgT3B0aW9uYWwgdXNlciBtZXRhZGF0YS4gRm9yIHNpZ251cCBvbmx5LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIFRoZSByZWRpcmVjdCB1cmwgd2hpY2ggc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBnZW5lcmF0ZWQgbGlua1xuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVMaW5rKHBhcmFtczogR2VuZXJhdGVMaW5rUGFyYW1zKTogUHJvbWlzZTxHZW5lcmF0ZUxpbmtSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IG9wdGlvbnMsIC4uLnJlc3QgfSA9IHBhcmFtc1xuICAgICAgY29uc3QgYm9keTogYW55ID0geyAuLi5yZXN0LCAuLi5vcHRpb25zIH1cbiAgICAgIGlmICgnbmV3RW1haWwnIGluIHJlc3QpIHtcbiAgICAgICAgLy8gcmVwbGFjZSBuZXdFbWFpbCB3aXRoIG5ld19lbWFpbCBpbiByZXF1ZXN0IGJvZHlcbiAgICAgICAgYm9keS5uZXdfZW1haWwgPSByZXN0Py5uZXdFbWFpbFxuICAgICAgICBkZWxldGUgYm9keVsnbmV3RW1haWwnXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2FkbWluL2dlbmVyYXRlX2xpbmtgLCB7XG4gICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgeGZvcm06IF9nZW5lcmF0ZUxpbmtSZXNwb25zZSxcbiAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucz8ucmVkaXJlY3RUbyxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgICAgICAgdXNlcjogbnVsbCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8vIFVzZXIgQWRtaW4gQVBJXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHVzZXIuXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAqL1xuICBhc3luYyBjcmVhdGVVc2VyKGF0dHJpYnV0ZXM6IEFkbWluVXNlckF0dHJpYnV0ZXMpOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnNgLCB7XG4gICAgICAgIGJvZHk6IGF0dHJpYnV0ZXMsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgdXNlcnMuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAqIEBwYXJhbSBwYXJhbXMgQW4gb2JqZWN0IHdoaWNoIHN1cHBvcnRzIGBwYWdlYCBhbmQgYHBlclBhZ2VgIGFzIG51bWJlcnMsIHRvIGFsdGVyIHRoZSBwYWdpbmF0ZWQgcmVzdWx0cy5cbiAgICovXG4gIGFzeW5jIGxpc3RVc2VycyhcbiAgICBwYXJhbXM/OiBQYWdlUGFyYW1zXG4gICk6IFByb21pc2U8XG4gICAgfCB7IGRhdGE6IHsgdXNlcnM6IFVzZXJbXTsgYXVkOiBzdHJpbmcgfSAmIFBhZ2luYXRpb247IGVycm9yOiBudWxsIH1cbiAgICB8IHsgZGF0YTogeyB1c2VyczogW10gfTsgZXJyb3I6IEF1dGhFcnJvciB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYWdpbmF0aW9uOiBQYWdpbmF0aW9uID0geyBuZXh0UGFnZTogbnVsbCwgbGFzdFBhZ2U6IDAsIHRvdGFsOiAwIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vyc2AsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgICAgICBxdWVyeToge1xuICAgICAgICAgIHBhZ2U6IHBhcmFtcz8ucGFnZT8udG9TdHJpbmcoKSA/PyAnJyxcbiAgICAgICAgICBwZXJfcGFnZTogcGFyYW1zPy5wZXJQYWdlPy50b1N0cmluZygpID8/ICcnLFxuICAgICAgICB9LFxuICAgICAgICB4Zm9ybTogX25vUmVzb2x2ZUpzb25SZXNwb25zZSxcbiAgICAgIH0pXG4gICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHRocm93IHJlc3BvbnNlLmVycm9yXG5cbiAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICBjb25zdCB0b3RhbCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXRvdGFsLWNvdW50JykgPz8gMFxuICAgICAgY29uc3QgbGlua3MgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnbGluaycpPy5zcGxpdCgnLCcpID8/IFtdXG4gICAgICBpZiAobGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICBsaW5rcy5mb3JFYWNoKChsaW5rOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBwYWdlID0gcGFyc2VJbnQobGluay5zcGxpdCgnOycpWzBdLnNwbGl0KCc9JylbMV0uc3Vic3RyaW5nKDAsIDEpKVxuICAgICAgICAgIGNvbnN0IHJlbCA9IEpTT04ucGFyc2UobGluay5zcGxpdCgnOycpWzFdLnNwbGl0KCc9JylbMV0pXG4gICAgICAgICAgcGFnaW5hdGlvbltgJHtyZWx9UGFnZWBdID0gcGFnZVxuICAgICAgICB9KVxuXG4gICAgICAgIHBhZ2luYXRpb24udG90YWwgPSBwYXJzZUludCh0b3RhbClcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgLi4udXNlcnMsIC4uLnBhZ2luYXRpb24gfSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcnM6IFtdIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB1c2VyIGJ5IGlkLlxuICAgKlxuICAgKiBAcGFyYW0gdWlkIFRoZSB1c2VyJ3MgdW5pcXVlIGlkZW50aWZpZXJcbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGFzeW5jIGdldFVzZXJCeUlkKHVpZDogc3RyaW5nKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHt1aWR9YCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB1c2VyIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBkYXRhIHlvdSB3YW50IHRvIHVwZGF0ZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVVzZXJCeUlkKHVpZDogc3RyaW5nLCBhdHRyaWJ1dGVzOiBBZG1pblVzZXJBdHRyaWJ1dGVzKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQVVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHt1aWR9YCwge1xuICAgICAgICBib2R5OiBhdHRyaWJ1dGVzLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSB1c2VyLiBSZXF1aXJlcyBhIGBzZXJ2aWNlX3JvbGVgIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGlkIFRoZSB1c2VyIGlkIHlvdSB3YW50IHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIHNob3VsZFNvZnREZWxldGUgSWYgdHJ1ZSwgdGhlbiB0aGUgdXNlciB3aWxsIGJlIHNvZnQtZGVsZXRlZCBmcm9tIHRoZSBhdXRoIHNjaGVtYS4gU29mdCBkZWxldGlvbiBhbGxvd3MgdXNlciBpZGVudGlmaWNhdGlvbiBmcm9tIHRoZSBoYXNoZWQgdXNlciBJRCBidXQgaXMgbm90IHJldmVyc2libGUuXG4gICAqIERlZmF1bHRzIHRvIGZhbHNlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlVXNlcihpZDogc3RyaW5nLCBzaG91bGRTb2Z0RGVsZXRlID0gZmFsc2UpOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke2lkfWAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgc2hvdWxkX3NvZnRfZGVsZXRlOiBzaG91bGRTb2Z0RGVsZXRlLFxuICAgICAgICB9LFxuICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9saXN0RmFjdG9ycyhcbiAgICBwYXJhbXM6IEF1dGhNRkFBZG1pbkxpc3RGYWN0b3JzUGFyYW1zXG4gICk6IFByb21pc2U8QXV0aE1GQUFkbWluTGlzdEZhY3RvcnNSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgJ0dFVCcsXG4gICAgICAgIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3BhcmFtcy51c2VySWR9L2ZhY3RvcnNgLFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIHhmb3JtOiAoZmFjdG9yczogYW55KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGZhY3RvcnMgfSwgZXJyb3I6IG51bGwgfVxuICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfZGVsZXRlRmFjdG9yKFxuICAgIHBhcmFtczogQXV0aE1GQUFkbWluRGVsZXRlRmFjdG9yUGFyYW1zXG4gICk6IFByb21pc2U8QXV0aE1GQUFkbWluRGVsZXRlRmFjdG9yUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IF9yZXF1ZXN0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICAnREVMRVRFJyxcbiAgICAgICAgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7cGFyYW1zLnVzZXJJZH0vZmFjdG9ycy8ke3BhcmFtcy5pZH1gLFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICB9XG4gICAgICApXG5cbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHsgc3VwcG9ydHNMb2NhbFN0b3JhZ2UgfSBmcm9tICcuL2hlbHBlcnMnXG5pbXBvcnQgeyBTdXBwb3J0ZWRTdG9yYWdlIH0gZnJvbSAnLi90eXBlcydcblxuLyoqXG4gKiBQcm92aWRlcyBzYWZlIGFjY2VzcyB0byB0aGUgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UgcHJvcGVydHkuXG4gKi9cbmV4cG9ydCBjb25zdCBsb2NhbFN0b3JhZ2VBZGFwdGVyOiBTdXBwb3J0ZWRTdG9yYWdlID0ge1xuICBnZXRJdGVtOiAoa2V5KSA9PiB7XG4gICAgaWYgKCFzdXBwb3J0c0xvY2FsU3RvcmFnZSgpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSlcbiAgfSxcbiAgc2V0SXRlbTogKGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAoIXN1cHBvcnRzTG9jYWxTdG9yYWdlKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSlcbiAgfSxcbiAgcmVtb3ZlSXRlbTogKGtleSkgPT4ge1xuICAgIGlmICghc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG4gIH0sXG59XG5cbi8qKlxuICogUmV0dXJucyBhIGxvY2FsU3RvcmFnZS1saWtlIG9iamVjdCB0aGF0IHN0b3JlcyB0aGUga2V5LXZhbHVlIHBhaXJzIGluXG4gKiBtZW1vcnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHN0b3JlOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge30pOiBTdXBwb3J0ZWRTdG9yYWdlIHtcbiAgcmV0dXJuIHtcbiAgICBnZXRJdGVtOiAoa2V5KSA9PiB7XG4gICAgICByZXR1cm4gc3RvcmVba2V5XSB8fCBudWxsXG4gICAgfSxcblxuICAgIHNldEl0ZW06IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICBzdG9yZVtrZXldID0gdmFsdWVcbiAgICB9LFxuXG4gICAgcmVtb3ZlSXRlbTogKGtleSkgPT4ge1xuICAgICAgZGVsZXRlIHN0b3JlW2tleV1cbiAgICB9LFxuICB9XG59XG4iLCAiLyoqXG4gKiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvZ2xvYmFsdGhpc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcG9seWZpbGxHbG9iYWxUaGlzKCkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm5cbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgJ19fbWFnaWNfXycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB9KVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBtYWdpYydcbiAgICBfX21hZ2ljX18uZ2xvYmFsVGhpcyA9IF9fbWFnaWNfX1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBtYWdpYydcbiAgICBkZWxldGUgT2JqZWN0LnByb3RvdHlwZS5fX21hZ2ljX19cbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBnbG9iYWxzJ1xuICAgICAgc2VsZi5nbG9iYWxUaGlzID0gc2VsZlxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IHN1cHBvcnRzTG9jYWxTdG9yYWdlIH0gZnJvbSAnLi9oZWxwZXJzJ1xuXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGNvbnN0IGludGVybmFscyA9IHtcbiAgLyoqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIGRlYnVnOiAhIShcbiAgICBnbG9iYWxUaGlzICYmXG4gICAgc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSAmJlxuICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlICYmXG4gICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc3VwYWJhc2UuZ290cnVlLWpzLmxvY2tzLmRlYnVnJykgPT09ICd0cnVlJ1xuICApLFxufVxuXG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGEgbG9jayBjYW5ub3QgYmUgYWNxdWlyZWQgYWZ0ZXIgc29tZSBhbW91bnQgb2YgdGltZS5cbiAqXG4gKiBVc2UgdGhlIHtAbGluayAjaXNBY3F1aXJlVGltZW91dH0gcHJvcGVydHkgaW5zdGVhZCBvZiBjaGVja2luZyB3aXRoIGBpbnN0YW5jZW9mYC5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgaXNBY3F1aXJlVGltZW91dCA9IHRydWVcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIHt9XG5leHBvcnQgY2xhc3MgUHJvY2Vzc0xvY2tBY3F1aXJlVGltZW91dEVycm9yIGV4dGVuZHMgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3Ige31cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgZ2xvYmFsIGV4Y2x1c2l2ZSBsb2NrIHVzaW5nIHRoZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgQVBJLiBJdFxuICogaXMgYXZhaWxhYmxlIG9uIGFsbCBicm93c2VycyByZWxlYXNlZCBhZnRlciAyMDIyLTAzLTE1IHdpdGggU2FmYXJpIGJlaW5nIHRoZVxuICogbGFzdCBvbmUgdG8gcmVsZWFzZSBzdXBwb3J0LiBJZiB0aGUgQVBJIGlzIG5vdCBhdmFpbGFibGUsIHRoaXMgZnVuY3Rpb24gd2lsbFxuICogdGhyb3cuIE1ha2Ugc3VyZSB5b3UgY2hlY2sgYXZhaWxhYmxpbGl0eSBiZWZvcmUgY29uZmlndXJpbmcge0BsaW5rXG4gKiBHb1RydWVDbGllbnR9LlxuICpcbiAqIFlvdSBjYW4gdHVybiBvbiBkZWJ1Z2dpbmcgYnkgc2V0dGluZyB0aGUgYHN1cGFiYXNlLmdvdHJ1ZS1qcy5sb2Nrcy5kZWJ1Z2BcbiAqIGxvY2FsIHN0b3JhZ2UgaXRlbSB0byBgdHJ1ZWAuXG4gKlxuICogSW50ZXJuYWxzOlxuICpcbiAqIFNpbmNlIHRoZSBMb2NrTWFuYWdlciBBUEkgZG9lcyBub3QgcHJlc2VydmUgc3RhY2sgdHJhY2VzIGZvciB0aGUgYXN5bmNcbiAqIGZ1bmN0aW9uIHBhc3NlZCBpbiB0aGUgYHJlcXVlc3RgIG1ldGhvZCwgYSB0cmljayBpcyB1c2VkIHdoZXJlIGFjcXVpcmluZyB0aGVcbiAqIGxvY2sgcmVsZWFzZXMgYSBwcmV2aW91c2x5IHN0YXJ0ZWQgcHJvbWlzZSB0byBydW4gdGhlIG9wZXJhdGlvbiBpbiB0aGUgYGZuYFxuICogZnVuY3Rpb24uIFRoZSBsb2NrIHdhaXRzIGZvciB0aGF0IHByb21pc2UgdG8gZmluaXNoICh3aXRoIG9yIHdpdGhvdXQgZXJyb3IpLFxuICogd2hpbGUgdGhlIGZ1bmN0aW9uIHdpbGwgZmluYWxseSB3YWl0IGZvciB0aGUgcmVzdWx0IGFueXdheS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBsb2NrIHRvIGJlIGFjcXVpcmVkLlxuICogQHBhcmFtIGFjcXVpcmVUaW1lb3V0IElmIG5lZ2F0aXZlLCBubyB0aW1lb3V0LiBJZiAwIGFuIGVycm9yIGlzIHRocm93biBpZlxuICogICAgICAgICAgICAgICAgICAgICAgIHRoZSBsb2NrIGNhbid0IGJlIGFjcXVpcmVkIHdpdGhvdXQgd2FpdGluZy4gSWYgcG9zaXRpdmUsIHRoZSBsb2NrIGFjcXVpcmVcbiAqICAgICAgICAgICAgICAgICAgICAgICB3aWxsIHRpbWUgb3V0IGFmdGVyIHNvIG1hbnkgbWlsbGlzZWNvbmRzLiBBbiBlcnJvciBpc1xuICogICAgICAgICAgICAgICAgICAgICAgIGEgdGltZW91dCBpZiBpdCBoYXMgYGlzQWNxdWlyZVRpbWVvdXRgIHNldCB0byB0cnVlLlxuICogQHBhcmFtIGZuIFRoZSBvcGVyYXRpb24gdG8gcnVuIG9uY2UgdGhlIGxvY2sgaXMgYWNxdWlyZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBuYXZpZ2F0b3JMb2NrPFI+KFxuICBuYW1lOiBzdHJpbmcsXG4gIGFjcXVpcmVUaW1lb3V0OiBudW1iZXIsXG4gIGZuOiAoKSA9PiBQcm9taXNlPFI+XG4pOiBQcm9taXNlPFI+IHtcbiAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBhY3F1aXJlIGxvY2snLCBuYW1lLCBhY3F1aXJlVGltZW91dClcbiAgfVxuXG4gIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlcigpXG5cbiAgaWYgKGFjcXVpcmVUaW1lb3V0ID4gMCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2sgYWNxdWlyZSB0aW1lZCBvdXQnLCBuYW1lKVxuICAgICAgfVxuICAgIH0sIGFjcXVpcmVUaW1lb3V0KVxuICB9XG5cbiAgLy8gTUROIGFydGljbGU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Mb2NrTWFuYWdlci9yZXF1ZXN0XG5cbiAgLy8gV3JhcHBpbmcgbmF2aWdhdG9yLmxvY2tzLnJlcXVlc3QoKSB3aXRoIGEgcGxhaW4gUHJvbWlzZSBpcyBkb25lIGFzIHNvbWVcbiAgLy8gbGlicmFyaWVzIGxpa2Ugem9uZS5qcyBwYXRjaCB0aGUgUHJvbWlzZSBvYmplY3QgdG8gdHJhY2sgdGhlIGV4ZWN1dGlvblxuICAvLyBjb250ZXh0LiBIb3dldmVyLCBpdCBhcHBlYXJzIHRoYXQgbW9zdCBicm93c2VycyB1c2UgYW4gaW50ZXJuYWwgcHJvbWlzZVxuICAvLyBpbXBsZW1lbnRhdGlvbiB3aGVuIHVzaW5nIHRoZSBuYXZpZ2F0b3IubG9ja3MucmVxdWVzdCgpIEFQSSBjYXVzaW5nIHRoZW1cbiAgLy8gdG8gbG9zZSBjb250ZXh0IGFuZCBlbWl0IGNvbmZ1c2luZyBsb2cgbWVzc2FnZXMgb3IgYnJlYWsgY2VydGFpbiBmZWF0dXJlcy5cbiAgLy8gVGhpcyB3cmFwcGluZyBpcyBiZWxpZXZlZCB0byBoZWxwIHpvbmUuanMgdHJhY2sgdGhlIGV4ZWN1dGlvbiBjb250ZXh0XG4gIC8vIGJldHRlci5cbiAgcmV0dXJuIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT5cbiAgICBnbG9iYWxUaGlzLm5hdmlnYXRvci5sb2Nrcy5yZXF1ZXN0KFxuICAgICAgbmFtZSxcbiAgICAgIGFjcXVpcmVUaW1lb3V0ID09PSAwXG4gICAgICAgID8ge1xuICAgICAgICAgICAgbW9kZTogJ2V4Y2x1c2l2ZScsXG4gICAgICAgICAgICBpZkF2YWlsYWJsZTogdHJ1ZSxcbiAgICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgbW9kZTogJ2V4Y2x1c2l2ZScsXG4gICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgfSxcbiAgICAgIGFzeW5jIChsb2NrKSA9PiB7XG4gICAgICAgIGlmIChsb2NrKSB7XG4gICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IGFjcXVpcmVkJywgbmFtZSwgbG9jay5uYW1lKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiByZWxlYXNlZCcsIG5hbWUsIGxvY2submFtZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGFjcXVpcmVUaW1lb3V0ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBub3QgaW1tZWRpYXRlbHkgYXZhaWxhYmxlJywgbmFtZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IE5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yKFxuICAgICAgICAgICAgICBgQWNxdWlyaW5nIGFuIGV4Y2x1c2l2ZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgbG9jayBcIiR7bmFtZX1cIiBpbW1lZGlhdGVseSBmYWlsZWRgXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnbG9iYWxUaGlzLm5hdmlnYXRvci5sb2Nrcy5xdWVyeSgpXG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICdAc3VwYWJhc2UvZ290cnVlLWpzOiBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgc3RhdGUnLFxuICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAnICAnKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgJ0BzdXBhYmFzZS9nb3RydWUtanM6IEVycm9yIHdoZW4gcXVlcnlpbmcgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHN0YXRlJyxcbiAgICAgICAgICAgICAgICAgIGVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQnJvd3NlciBpcyBub3QgZm9sbG93aW5nIHRoZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgc3BlYywgaXRcbiAgICAgICAgICAgIC8vIHJldHVybmVkIGEgbnVsbCBsb2NrIHdoZW4gd2UgZGlkbid0IHVzZSBpZkF2YWlsYWJsZS4gU28gd2UgY2FuXG4gICAgICAgICAgICAvLyBwcmV0ZW5kIHRoZSBsb2NrIGlzIGFjcXVpcmVkIGluIHRoZSBuYW1lIG9mIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIC8vIGFuZCB1c2VyIGV4cGVyaWVuY2UgYW5kIGp1c3QgcnVuIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ0BzdXBhYmFzZS9nb3RydWUtanM6IE5hdmlnYXRvciBMb2NrTWFuYWdlciByZXR1cm5lZCBhIG51bGwgbG9jayB3aGVuIHVzaW5nICNyZXF1ZXN0IHdpdGhvdXQgaWZBdmFpbGFibGUgc2V0IHRvIHRydWUsIGl0IGFwcGVhcnMgdGhpcyBicm93c2VyIGlzIG5vdCBmb2xsb3dpbmcgdGhlIExvY2tNYW5hZ2VyIHNwZWMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0xvY2tNYW5hZ2VyL3JlcXVlc3QnXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuICApXG59XG5cbmNvbnN0IFBST0NFU1NfTE9DS1M6IHsgW25hbWU6IHN0cmluZ106IFByb21pc2U8YW55PiB9ID0ge31cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgZ2xvYmFsIGV4Y2x1c2l2ZSBsb2NrIHRoYXQgd29ya3Mgb25seSBpbiB0aGUgY3VycmVudCBwcm9jZXNzLlxuICogVXNlZnVsIGZvciBlbnZpcm9ubWVudHMgbGlrZSBSZWFjdCBOYXRpdmUgb3Igb3RoZXIgbm9uLWJyb3dzZXJcbiAqIHNpbmdsZS1wcm9jZXNzIChpLmUuIG5vIGNvbmNlcHQgb2YgXCJ0YWJzXCIpIGVudmlyb25tZW50cy5cbiAqXG4gKiBVc2Uge0BsaW5rICNuYXZpZ2F0b3JMb2NrfSBpbiBicm93c2VyIGVudmlyb25tZW50cy5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBsb2NrIHRvIGJlIGFjcXVpcmVkLlxuICogQHBhcmFtIGFjcXVpcmVUaW1lb3V0IElmIG5lZ2F0aXZlLCBubyB0aW1lb3V0LiBJZiAwIGFuIGVycm9yIGlzIHRocm93biBpZlxuICogICAgICAgICAgICAgICAgICAgICAgIHRoZSBsb2NrIGNhbid0IGJlIGFjcXVpcmVkIHdpdGhvdXQgd2FpdGluZy4gSWYgcG9zaXRpdmUsIHRoZSBsb2NrIGFjcXVpcmVcbiAqICAgICAgICAgICAgICAgICAgICAgICB3aWxsIHRpbWUgb3V0IGFmdGVyIHNvIG1hbnkgbWlsbGlzZWNvbmRzLiBBbiBlcnJvciBpc1xuICogICAgICAgICAgICAgICAgICAgICAgIGEgdGltZW91dCBpZiBpdCBoYXMgYGlzQWNxdWlyZVRpbWVvdXRgIHNldCB0byB0cnVlLlxuICogQHBhcmFtIGZuIFRoZSBvcGVyYXRpb24gdG8gcnVuIG9uY2UgdGhlIGxvY2sgaXMgYWNxdWlyZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzTG9jazxSPihcbiAgbmFtZTogc3RyaW5nLFxuICBhY3F1aXJlVGltZW91dDogbnVtYmVyLFxuICBmbjogKCkgPT4gUHJvbWlzZTxSPlxuKTogUHJvbWlzZTxSPiB7XG4gIGNvbnN0IHByZXZpb3VzT3BlcmF0aW9uID0gUFJPQ0VTU19MT0NLU1tuYW1lXSA/PyBQcm9taXNlLnJlc29sdmUoKVxuXG4gIGNvbnN0IGN1cnJlbnRPcGVyYXRpb24gPSBQcm9taXNlLnJhY2UoXG4gICAgW1xuICAgICAgcHJldmlvdXNPcGVyYXRpb24uY2F0Y2goKCkgPT4ge1xuICAgICAgICAvLyBpZ25vcmUgZXJyb3Igb2YgcHJldmlvdXMgb3BlcmF0aW9uIHRoYXQgd2UncmUgd2FpdGluZyB0byBmaW5pc2hcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH0pLFxuICAgICAgYWNxdWlyZVRpbWVvdXQgPj0gMFxuICAgICAgICA/IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgbmV3IFByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcihcbiAgICAgICAgICAgICAgICAgIGBBY3F1cmluZyBwcm9jZXNzIGxvY2sgd2l0aCBuYW1lIFwiJHtuYW1lfVwiIHRpbWVkIG91dGBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0sIGFjcXVpcmVUaW1lb3V0KVxuICAgICAgICAgIH0pXG4gICAgICAgIDogbnVsbCxcbiAgICBdLmZpbHRlcigoeCkgPT4geClcbiAgKVxuICAgIC5jYXRjaCgoZTogYW55KSA9PiB7XG4gICAgICBpZiAoZSAmJiBlLmlzQWNxdWlyZVRpbWVvdXQpIHtcbiAgICAgICAgdGhyb3cgZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0pXG4gICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gcHJldmlvdXMgb3BlcmF0aW9ucyBmaW5pc2hlZCBhbmQgd2UgZGlkbid0IGdldCBhIHJhY2Ugb24gdGhlIGFjcXVpcmVcbiAgICAgIC8vIHRpbWVvdXQsIHNvIHRoZSBjdXJyZW50IG9wZXJhdGlvbiBjYW4gZmluYWxseSBzdGFydFxuICAgICAgcmV0dXJuIGF3YWl0IGZuKClcbiAgICB9KVxuXG4gIFBST0NFU1NfTE9DS1NbbmFtZV0gPSBjdXJyZW50T3BlcmF0aW9uLmNhdGNoKGFzeW5jIChlOiBhbnkpID0+IHtcbiAgICBpZiAoZSAmJiBlLmlzQWNxdWlyZVRpbWVvdXQpIHtcbiAgICAgIC8vIGlmIHRoZSBjdXJyZW50IG9wZXJhdGlvbiB0aW1lZCBvdXQsIGl0IGRvZXNuJ3QgbWVhbiB0aGF0IHRoZSBwcmV2aW91c1xuICAgICAgLy8gb3BlcmF0aW9uIGZpbmlzaGVkLCBzbyB3ZSBuZWVkIGNvbnRudWUgd2FpdGluZyBmb3IgaXQgdG8gZmluaXNoXG4gICAgICBhd2FpdCBwcmV2aW91c09wZXJhdGlvblxuXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHRocm93IGVcbiAgfSlcblxuICAvLyBmaW5hbGx5IHdhaXQgZm9yIHRoZSBjdXJyZW50IG9wZXJhdGlvbiB0byBmaW5pc2ggc3VjY2Vzc2Z1bGx5LCB3aXRoIGFuXG4gIC8vIGVycm9yIG9yIHdpdGggYW4gYWNxdWlyZSB0aW1lb3V0IGVycm9yXG4gIHJldHVybiBhd2FpdCBjdXJyZW50T3BlcmF0aW9uXG59XG4iLCAiaW1wb3J0IEdvVHJ1ZUFkbWluQXBpIGZyb20gJy4vR29UcnVlQWRtaW5BcGknXG5pbXBvcnQgeyBERUZBVUxUX0hFQURFUlMsIEVYUElSWV9NQVJHSU4sIEdPVFJVRV9VUkwsIFNUT1JBR0VfS0VZIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJ1xuaW1wb3J0IHtcbiAgQXV0aEVycm9yLFxuICBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IsXG4gIEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcixcbiAgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yLFxuICBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcixcbiAgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IsXG4gIEF1dGhVbmtub3duRXJyb3IsXG4gIGlzQXV0aEFwaUVycm9yLFxuICBpc0F1dGhFcnJvcixcbiAgaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcixcbiAgaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcixcbiAgaXNBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IsXG59IGZyb20gJy4vbGliL2Vycm9ycydcbmltcG9ydCB7XG4gIEZldGNoLFxuICBfcmVxdWVzdCxcbiAgX3Nlc3Npb25SZXNwb25zZSxcbiAgX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkLFxuICBfdXNlclJlc3BvbnNlLFxuICBfc3NvUmVzcG9uc2UsXG59IGZyb20gJy4vbGliL2ZldGNoJ1xuaW1wb3J0IHtcbiAgZGVjb2RlSldUUGF5bG9hZCxcbiAgRGVmZXJyZWQsXG4gIGdldEl0ZW1Bc3luYyxcbiAgaXNCcm93c2VyLFxuICByZW1vdmVJdGVtQXN5bmMsXG4gIHJlc29sdmVGZXRjaCxcbiAgc2V0SXRlbUFzeW5jLFxuICB1dWlkLFxuICByZXRyeWFibGUsXG4gIHNsZWVwLFxuICBzdXBwb3J0c0xvY2FsU3RvcmFnZSxcbiAgcGFyc2VQYXJhbWV0ZXJzRnJvbVVSTCxcbiAgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCxcbn0gZnJvbSAnLi9saWIvaGVscGVycydcbmltcG9ydCB7IGxvY2FsU3RvcmFnZUFkYXB0ZXIsIG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL2xpYi9sb2NhbC1zdG9yYWdlJ1xuaW1wb3J0IHsgcG9seWZpbGxHbG9iYWxUaGlzIH0gZnJvbSAnLi9saWIvcG9seWZpbGxzJ1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vbGliL3ZlcnNpb24nXG5pbXBvcnQgeyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciwgbmF2aWdhdG9yTG9jayB9IGZyb20gJy4vbGliL2xvY2tzJ1xuXG5pbXBvcnQgdHlwZSB7XG4gIEF1dGhDaGFuZ2VFdmVudCxcbiAgQXV0aFJlc3BvbnNlLFxuICBBdXRoUmVzcG9uc2VQYXNzd29yZCxcbiAgQXV0aFRva2VuUmVzcG9uc2UsXG4gIEF1dGhUb2tlblJlc3BvbnNlUGFzc3dvcmQsXG4gIEF1dGhPdHBSZXNwb25zZSxcbiAgQ2FsbFJlZnJlc2hUb2tlblJlc3VsdCxcbiAgR29UcnVlQ2xpZW50T3B0aW9ucyxcbiAgSW5pdGlhbGl6ZVJlc3VsdCxcbiAgT0F1dGhSZXNwb25zZSxcbiAgU1NPUmVzcG9uc2UsXG4gIFByb3ZpZGVyLFxuICBTZXNzaW9uLFxuICBTaWduSW5XaXRoSWRUb2tlbkNyZWRlbnRpYWxzLFxuICBTaWduSW5XaXRoT0F1dGhDcmVkZW50aWFscyxcbiAgU2lnbkluV2l0aFBhc3N3b3JkQ3JlZGVudGlhbHMsXG4gIFNpZ25JbldpdGhQYXNzd29yZGxlc3NDcmVkZW50aWFscyxcbiAgU2lnblVwV2l0aFBhc3N3b3JkQ3JlZGVudGlhbHMsXG4gIFNpZ25JbldpdGhTU08sXG4gIFNpZ25PdXQsXG4gIFN1YnNjcmlwdGlvbixcbiAgU3VwcG9ydGVkU3RvcmFnZSxcbiAgVXNlcixcbiAgVXNlckF0dHJpYnV0ZXMsXG4gIFVzZXJSZXNwb25zZSxcbiAgVmVyaWZ5T3RwUGFyYW1zLFxuICBHb1RydWVNRkFBcGksXG4gIE1GQUVucm9sbFBhcmFtcyxcbiAgQXV0aE1GQUVucm9sbFJlc3BvbnNlLFxuICBNRkFDaGFsbGVuZ2VQYXJhbXMsXG4gIEF1dGhNRkFDaGFsbGVuZ2VSZXNwb25zZSxcbiAgTUZBVW5lbnJvbGxQYXJhbXMsXG4gIEF1dGhNRkFVbmVucm9sbFJlc3BvbnNlLFxuICBNRkFWZXJpZnlQYXJhbXMsXG4gIEF1dGhNRkFWZXJpZnlSZXNwb25zZSxcbiAgQXV0aE1GQUxpc3RGYWN0b3JzUmVzcG9uc2UsXG4gIEFNUkVudHJ5LFxuICBBdXRoTUZBR2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsUmVzcG9uc2UsXG4gIEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbHMsXG4gIEZhY3RvcixcbiAgTUZBQ2hhbGxlbmdlQW5kVmVyaWZ5UGFyYW1zLFxuICBSZXNlbmRQYXJhbXMsXG4gIEF1dGhGbG93VHlwZSxcbiAgTG9ja0Z1bmMsXG4gIFVzZXJJZGVudGl0eSxcbiAgU2lnbkluQW5vbnltb3VzbHlDcmVkZW50aWFscyxcbn0gZnJvbSAnLi9saWIvdHlwZXMnXG5pbXBvcnQge1xuICBNRkFFbnJvbGxUT1RQUGFyYW1zLFxuICBNRkFFbnJvbGxQaG9uZVBhcmFtcyxcbiAgQXV0aE1GQUVucm9sbFRPVFBSZXNwb25zZSxcbiAgQXV0aE1GQUVucm9sbFBob25lUmVzcG9uc2UsXG59IGZyb20gJy4vbGliL2ludGVybmFsLXR5cGVzJ1xuXG5wb2x5ZmlsbEdsb2JhbFRoaXMoKSAvLyBNYWtlIFwiZ2xvYmFsVGhpc1wiIGF2YWlsYWJsZVxuXG5jb25zdCBERUZBVUxUX09QVElPTlM6IE9taXQ8UmVxdWlyZWQ8R29UcnVlQ2xpZW50T3B0aW9ucz4sICdmZXRjaCcgfCAnc3RvcmFnZScgfCAnbG9jayc+ID0ge1xuICB1cmw6IEdPVFJVRV9VUkwsXG4gIHN0b3JhZ2VLZXk6IFNUT1JBR0VfS0VZLFxuICBhdXRvUmVmcmVzaFRva2VuOiB0cnVlLFxuICBwZXJzaXN0U2Vzc2lvbjogdHJ1ZSxcbiAgZGV0ZWN0U2Vzc2lvbkluVXJsOiB0cnVlLFxuICBoZWFkZXJzOiBERUZBVUxUX0hFQURFUlMsXG4gIGZsb3dUeXBlOiAnaW1wbGljaXQnLFxuICBkZWJ1ZzogZmFsc2UsXG4gIGhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXI6IGZhbHNlLFxufVxuXG4vKiogQ3VycmVudCBzZXNzaW9uIHdpbGwgYmUgY2hlY2tlZCBmb3IgcmVmcmVzaCBhdCB0aGlzIGludGVydmFsLiAqL1xuY29uc3QgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT04gPSAzMCAqIDEwMDBcblxuLyoqXG4gKiBBIHRva2VuIHJlZnJlc2ggd2lsbCBiZSBhdHRlbXB0ZWQgdGhpcyBtYW55IHRpY2tzIGJlZm9yZSB0aGUgY3VycmVudCBzZXNzaW9uIGV4cGlyZXMuICovXG5jb25zdCBBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTEQgPSAzXG5cbmFzeW5jIGZ1bmN0aW9uIGxvY2tOb09wPFI+KG5hbWU6IHN0cmluZywgYWNxdWlyZVRpbWVvdXQ6IG51bWJlciwgZm46ICgpID0+IFByb21pc2U8Uj4pOiBQcm9taXNlPFI+IHtcbiAgcmV0dXJuIGF3YWl0IGZuKClcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR29UcnVlQ2xpZW50IHtcbiAgcHJpdmF0ZSBzdGF0aWMgbmV4dEluc3RhbmNlSUQgPSAwXG5cbiAgcHJpdmF0ZSBpbnN0YW5jZUlEOiBudW1iZXJcblxuICAvKipcbiAgICogTmFtZXNwYWNlIGZvciB0aGUgR29UcnVlIGFkbWluIG1ldGhvZHMuXG4gICAqIFRoZXNlIG1ldGhvZHMgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiBhIHRydXN0ZWQgc2VydmVyLXNpZGUgZW52aXJvbm1lbnQuXG4gICAqL1xuICBhZG1pbjogR29UcnVlQWRtaW5BcGlcbiAgLyoqXG4gICAqIE5hbWVzcGFjZSBmb3IgdGhlIE1GQSBtZXRob2RzLlxuICAgKi9cbiAgbWZhOiBHb1RydWVNRkFBcGlcbiAgLyoqXG4gICAqIFRoZSBzdG9yYWdlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoZSB2YWx1ZXMgc2F2ZWQgaW4gbG9jYWxTdG9yYWdlXG4gICAqL1xuICBwcm90ZWN0ZWQgc3RvcmFnZUtleTogc3RyaW5nXG5cbiAgcHJvdGVjdGVkIGZsb3dUeXBlOiBBdXRoRmxvd1R5cGVcblxuICBwcm90ZWN0ZWQgYXV0b1JlZnJlc2hUb2tlbjogYm9vbGVhblxuICBwcm90ZWN0ZWQgcGVyc2lzdFNlc3Npb246IGJvb2xlYW5cbiAgcHJvdGVjdGVkIHN0b3JhZ2U6IFN1cHBvcnRlZFN0b3JhZ2VcbiAgcHJvdGVjdGVkIG1lbW9yeVN0b3JhZ2U6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gfCBudWxsID0gbnVsbFxuICBwcm90ZWN0ZWQgc3RhdGVDaGFuZ2VFbWl0dGVyczogTWFwPHN0cmluZywgU3Vic2NyaXB0aW9uPiA9IG5ldyBNYXAoKVxuICBwcm90ZWN0ZWQgYXV0b1JlZnJlc2hUaWNrZXI6IFJldHVyblR5cGU8dHlwZW9mIHNldEludGVydmFsPiB8IG51bGwgPSBudWxsXG4gIHByb3RlY3RlZCB2aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrOiAoKCkgPT4gUHJvbWlzZTxhbnk+KSB8IG51bGwgPSBudWxsXG4gIHByb3RlY3RlZCByZWZyZXNoaW5nRGVmZXJyZWQ6IERlZmVycmVkPENhbGxSZWZyZXNoVG9rZW5SZXN1bHQ+IHwgbnVsbCA9IG51bGxcbiAgLyoqXG4gICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBhc3luYyBjbGllbnQgaW5pdGlhbGl6YXRpb24uXG4gICAqIFdoZW4gbnVsbCBvciBub3QgeWV0IHJlc29sdmVkIHRoZSBhdXRoIHN0YXRlIGlzIGB1bmtub3duYFxuICAgKiBPbmNlIHJlc29sdmVkIHRoZSB0aGUgYXV0aCBzdGF0ZSBpcyBrbm93biBhbmQgaXQncyBzYXZlIHRvIGNhbGwgYW55IGZ1cnRoZXIgY2xpZW50IG1ldGhvZHMuXG4gICAqIEtlZXAgZXh0cmEgY2FyZSB0byBuZXZlciByZWplY3Qgb3IgdGhyb3cgdW5jYXVnaHQgZXJyb3JzXG4gICAqL1xuICBwcm90ZWN0ZWQgaW5pdGlhbGl6ZVByb21pc2U6IFByb21pc2U8SW5pdGlhbGl6ZVJlc3VsdD4gfCBudWxsID0gbnVsbFxuICBwcm90ZWN0ZWQgZGV0ZWN0U2Vzc2lvbkluVXJsID0gdHJ1ZVxuICBwcm90ZWN0ZWQgdXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIGhlYWRlcnM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuICBwcm90ZWN0ZWQgaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciA9IGZhbHNlXG4gIHByb3RlY3RlZCBzdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gZmFsc2VcbiAgcHJvdGVjdGVkIGZldGNoOiBGZXRjaFxuICBwcm90ZWN0ZWQgbG9jazogTG9ja0Z1bmNcbiAgcHJvdGVjdGVkIGxvY2tBY3F1aXJlZCA9IGZhbHNlXG4gIHByb3RlY3RlZCBwZW5kaW5nSW5Mb2NrOiBQcm9taXNlPGFueT5bXSA9IFtdXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gYnJvYWRjYXN0IHN0YXRlIGNoYW5nZSBldmVudHMgdG8gb3RoZXIgdGFicyBsaXN0ZW5pbmcuXG4gICAqL1xuICBwcm90ZWN0ZWQgYnJvYWRjYXN0Q2hhbm5lbDogQnJvYWRjYXN0Q2hhbm5lbCB8IG51bGwgPSBudWxsXG5cbiAgcHJvdGVjdGVkIGxvZ0RlYnVnTWVzc2FnZXM6IGJvb2xlYW5cbiAgcHJvdGVjdGVkIGxvZ2dlcjogKG1lc3NhZ2U6IHN0cmluZywgLi4uYXJnczogYW55W10pID0+IHZvaWQgPSBjb25zb2xlLmxvZ1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgY2xpZW50IGZvciB1c2UgaW4gdGhlIGJyb3dzZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBHb1RydWVDbGllbnRPcHRpb25zKSB7XG4gICAgdGhpcy5pbnN0YW5jZUlEID0gR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEXG4gICAgR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEICs9IDFcblxuICAgIGlmICh0aGlzLmluc3RhbmNlSUQgPiAwICYmIGlzQnJvd3NlcigpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdNdWx0aXBsZSBHb1RydWVDbGllbnQgaW5zdGFuY2VzIGRldGVjdGVkIGluIHRoZSBzYW1lIGJyb3dzZXIgY29udGV4dC4gSXQgaXMgbm90IGFuIGVycm9yLCBidXQgdGhpcyBzaG91bGQgYmUgYXZvaWRlZCBhcyBpdCBtYXkgcHJvZHVjZSB1bmRlZmluZWQgYmVoYXZpb3Igd2hlbiB1c2VkIGNvbmN1cnJlbnRseSB1bmRlciB0aGUgc2FtZSBzdG9yYWdlIGtleS4nXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7IC4uLkRFRkFVTFRfT1BUSU9OUywgLi4ub3B0aW9ucyB9XG5cbiAgICB0aGlzLmxvZ0RlYnVnTWVzc2FnZXMgPSAhIXNldHRpbmdzLmRlYnVnXG4gICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5kZWJ1ZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5sb2dnZXIgPSBzZXR0aW5ncy5kZWJ1Z1xuICAgIH1cblxuICAgIHRoaXMucGVyc2lzdFNlc3Npb24gPSBzZXR0aW5ncy5wZXJzaXN0U2Vzc2lvblxuICAgIHRoaXMuc3RvcmFnZUtleSA9IHNldHRpbmdzLnN0b3JhZ2VLZXlcbiAgICB0aGlzLmF1dG9SZWZyZXNoVG9rZW4gPSBzZXR0aW5ncy5hdXRvUmVmcmVzaFRva2VuXG4gICAgdGhpcy5hZG1pbiA9IG5ldyBHb1RydWVBZG1pbkFwaSh7XG4gICAgICB1cmw6IHNldHRpbmdzLnVybCxcbiAgICAgIGhlYWRlcnM6IHNldHRpbmdzLmhlYWRlcnMsXG4gICAgICBmZXRjaDogc2V0dGluZ3MuZmV0Y2gsXG4gICAgfSlcblxuICAgIHRoaXMudXJsID0gc2V0dGluZ3MudXJsXG4gICAgdGhpcy5oZWFkZXJzID0gc2V0dGluZ3MuaGVhZGVyc1xuICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goc2V0dGluZ3MuZmV0Y2gpXG4gICAgdGhpcy5sb2NrID0gc2V0dGluZ3MubG9jayB8fCBsb2NrTm9PcFxuICAgIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsID0gc2V0dGluZ3MuZGV0ZWN0U2Vzc2lvbkluVXJsXG4gICAgdGhpcy5mbG93VHlwZSA9IHNldHRpbmdzLmZsb3dUeXBlXG4gICAgdGhpcy5oYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyID0gc2V0dGluZ3MuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlclxuXG4gICAgaWYgKHNldHRpbmdzLmxvY2spIHtcbiAgICAgIHRoaXMubG9jayA9IHNldHRpbmdzLmxvY2tcbiAgICB9IGVsc2UgaWYgKGlzQnJvd3NlcigpICYmIGdsb2JhbFRoaXM/Lm5hdmlnYXRvcj8ubG9ja3MpIHtcbiAgICAgIHRoaXMubG9jayA9IG5hdmlnYXRvckxvY2tcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2NrID0gbG9ja05vT3BcbiAgICB9XG5cbiAgICB0aGlzLm1mYSA9IHtcbiAgICAgIHZlcmlmeTogdGhpcy5fdmVyaWZ5LmJpbmQodGhpcyksXG4gICAgICBlbnJvbGw6IHRoaXMuX2Vucm9sbC5iaW5kKHRoaXMpLFxuICAgICAgdW5lbnJvbGw6IHRoaXMuX3VuZW5yb2xsLmJpbmQodGhpcyksXG4gICAgICBjaGFsbGVuZ2U6IHRoaXMuX2NoYWxsZW5nZS5iaW5kKHRoaXMpLFxuICAgICAgbGlzdEZhY3RvcnM6IHRoaXMuX2xpc3RGYWN0b3JzLmJpbmQodGhpcyksXG4gICAgICBjaGFsbGVuZ2VBbmRWZXJpZnk6IHRoaXMuX2NoYWxsZW5nZUFuZFZlcmlmeS5iaW5kKHRoaXMpLFxuICAgICAgZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsOiB0aGlzLl9nZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwuYmluZCh0aGlzKSxcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wZXJzaXN0U2Vzc2lvbikge1xuICAgICAgaWYgKHNldHRpbmdzLnN0b3JhZ2UpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc2V0dGluZ3Muc3RvcmFnZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzTG9jYWxTdG9yYWdlKCkpIHtcbiAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBsb2NhbFN0b3JhZ2VBZGFwdGVyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0ge31cbiAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHRoaXMubWVtb3J5U3RvcmFnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lbW9yeVN0b3JhZ2UgPSB7fVxuICAgICAgdGhpcy5zdG9yYWdlID0gbWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlcih0aGlzLm1lbW9yeVN0b3JhZ2UpXG4gICAgfVxuXG4gICAgaWYgKGlzQnJvd3NlcigpICYmIGdsb2JhbFRoaXMuQnJvYWRjYXN0Q2hhbm5lbCAmJiB0aGlzLnBlcnNpc3RTZXNzaW9uICYmIHRoaXMuc3RvcmFnZUtleSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbmV3IGdsb2JhbFRoaXMuQnJvYWRjYXN0Q2hhbm5lbCh0aGlzLnN0b3JhZ2VLZXkpXG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnRmFpbGVkIHRvIGNyZWF0ZSBhIG5ldyBCcm9hZGNhc3RDaGFubmVsLCBtdWx0aS10YWIgc3RhdGUgY2hhbmdlcyB3aWxsIG5vdCBiZSBhdmFpbGFibGUnLFxuICAgICAgICAgIGVcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWw/LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ3JlY2VpdmVkIGJyb2FkY2FzdCBub3RpZmljYXRpb24gZnJvbSBvdGhlciB0YWIgb3IgY2xpZW50JywgZXZlbnQpXG5cbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoZXZlbnQuZGF0YS5ldmVudCwgZXZlbnQuZGF0YS5zZXNzaW9uLCBmYWxzZSkgLy8gYnJvYWRjYXN0ID0gZmFsc2Ugc28gd2UgZG9uJ3QgZ2V0IGFuIGVuZGxlc3MgbG9vcCBvZiBtZXNzYWdlc1xuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmluaXRpYWxpemUoKVxuICB9XG5cbiAgcHJpdmF0ZSBfZGVidWcoLi4uYXJnczogYW55W10pOiBHb1RydWVDbGllbnQge1xuICAgIGlmICh0aGlzLmxvZ0RlYnVnTWVzc2FnZXMpIHtcbiAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICBgR29UcnVlQ2xpZW50QCR7dGhpcy5pbnN0YW5jZUlEfSAoJHt2ZXJzaW9ufSkgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YCxcbiAgICAgICAgLi4uYXJnc1xuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNsaWVudCBzZXNzaW9uIGVpdGhlciBmcm9tIHRoZSB1cmwgb3IgZnJvbSBzdG9yYWdlLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuIGluc3RhbnRpYXRpbmcgdGhlIGNsaWVudCwgYnV0IHNob3VsZCBhbHNvIGJlIGNhbGxlZFxuICAgKiBtYW51YWxseSB3aGVuIGNoZWNraW5nIGZvciBhbiBlcnJvciBmcm9tIGFuIGF1dGggcmVkaXJlY3QgKG9hdXRoLCBtYWdpY2xpbmssIHBhc3N3b3JkIHJlY292ZXJ5LCBldGMpLlxuICAgKi9cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPEluaXRpYWxpemVSZXN1bHQ+IHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXplUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcbiAgICB9XG5cbiAgICB0aGlzLmluaXRpYWxpemVQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5faW5pdGlhbGl6ZSgpXG4gICAgICB9KVxuICAgIH0pKClcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogSU1QT1JUQU5UOlxuICAgKiAxLiBOZXZlciB0aHJvdyBpbiB0aGlzIG1ldGhvZCwgYXMgaXQgaXMgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAqIDIuIE5ldmVyIHJldHVybiBhIHNlc3Npb24gZnJvbSB0aGlzIG1ldGhvZCBhcyBpdCB3b3VsZCBiZSBjYWNoZWQgb3ZlclxuICAgKiAgICB0aGUgd2hvbGUgbGlmZXRpbWUgb2YgdGhlIGNsaWVudFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfaW5pdGlhbGl6ZSgpOiBQcm9taXNlPEluaXRpYWxpemVSZXN1bHQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyYW1zID0gcGFyc2VQYXJhbWV0ZXJzRnJvbVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICAgIGxldCBjYWxsYmFja1VybFR5cGUgPSAnbm9uZSdcbiAgICAgIGlmICh0aGlzLl9pc0ltcGxpY2l0R3JhbnRDYWxsYmFjayhwYXJhbXMpKSB7XG4gICAgICAgIGNhbGxiYWNrVXJsVHlwZSA9ICdpbXBsaWNpdCdcbiAgICAgIH0gZWxzZSBpZiAoYXdhaXQgdGhpcy5faXNQS0NFQ2FsbGJhY2socGFyYW1zKSkge1xuICAgICAgICBjYWxsYmFja1VybFR5cGUgPSAncGtjZSdcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBdHRlbXB0IHRvIGdldCB0aGUgc2Vzc2lvbiBmcm9tIHRoZSBVUkwgb25seSBpZiB0aGVzZSBjb25kaXRpb25zIGFyZSBmdWxmaWxsZWRcbiAgICAgICAqXG4gICAgICAgKiBOb3RlOiBJZiB0aGUgVVJMIGlzbid0IG9uZSBvZiB0aGUgY2FsbGJhY2sgdXJsIHR5cGVzIChpbXBsaWNpdCBvciBwa2NlKSxcbiAgICAgICAqIHRoZW4gdGhlcmUgY291bGQgYmUgYW4gZXhpc3Rpbmcgc2Vzc2lvbiBzbyB3ZSBkb24ndCB3YW50IHRvIHByZW1hdHVyZWx5IHJlbW92ZSBpdFxuICAgICAgICovXG4gICAgICBpZiAoaXNCcm93c2VyKCkgJiYgdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgJiYgY2FsbGJhY2tVcmxUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0U2Vzc2lvbkZyb21VUkwocGFyYW1zLCBjYWxsYmFja1VybFR5cGUpXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdlcnJvciBkZXRlY3Rpbmcgc2Vzc2lvbiBmcm9tIFVSTCcsIGVycm9yKVxuXG4gICAgICAgICAgaWYgKGlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gZXJyb3IuZGV0YWlscz8uY29kZVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBlcnJvckNvZGUgPT09ICdpZGVudGl0eV9hbHJlYWR5X2V4aXN0cycgfHxcbiAgICAgICAgICAgICAgZXJyb3JDb2RlID09PSAnaWRlbnRpdHlfbm90X2ZvdW5kJyB8fFxuICAgICAgICAgICAgICBlcnJvckNvZGUgPT09ICdzaW5nbGVfaWRlbnRpdHlfbm90X2RlbGV0YWJsZSdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZmFpbGVkIGxvZ2luIGF0dGVtcHQgdmlhIHVybCxcbiAgICAgICAgICAvLyByZW1vdmUgb2xkIHNlc3Npb24gYXMgaW4gdmVyaWZ5T3RwLCBzaWduVXAgYW5kIHNpZ25JbldpdGgqXG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG5cbiAgICAgICAgICByZXR1cm4geyBlcnJvciB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHNlc3Npb24sIHJlZGlyZWN0VHlwZSB9ID0gZGF0YVxuXG4gICAgICAgIHRoaXMuX2RlYnVnKFxuICAgICAgICAgICcjX2luaXRpYWxpemUoKScsXG4gICAgICAgICAgJ2RldGVjdGVkIHNlc3Npb24gaW4gVVJMJyxcbiAgICAgICAgICBzZXNzaW9uLFxuICAgICAgICAgICdyZWRpcmVjdCB0eXBlJyxcbiAgICAgICAgICByZWRpcmVjdFR5cGVcbiAgICAgICAgKVxuXG4gICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pXG5cbiAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgaWYgKHJlZGlyZWN0VHlwZSA9PT0gJ3JlY292ZXJ5Jykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1BBU1NXT1JEX1JFQ09WRVJZJywgc2Vzc2lvbilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pXG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKVxuXG4gICAgICAgIHJldHVybiB7IGVycm9yOiBudWxsIH1cbiAgICAgIH1cbiAgICAgIC8vIG5vIGxvZ2luIGF0dGVtcHQgdmlhIGNhbGxiYWNrIHVybCB0cnkgdG8gcmVjb3ZlciBzZXNzaW9uIGZyb20gc3RvcmFnZVxuICAgICAgYXdhaXQgdGhpcy5fcmVjb3ZlckFuZFJlZnJlc2goKVxuICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGR1cmluZyBpbml0aWFsaXphdGlvbicsIGVycm9yKSxcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgdGhpcy5faGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpXG4gICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBhbm9ueW1vdXMgdXNlci5cbiAgICpcbiAgICogQHJldHVybnMgQSBzZXNzaW9uIHdoZXJlIHRoZSBpc19hbm9ueW1vdXMgY2xhaW0gaW4gdGhlIGFjY2VzcyB0b2tlbiBKV1Qgc2V0IHRvIHRydWVcbiAgICovXG4gIGFzeW5jIHNpZ25JbkFub255bW91c2x5KGNyZWRlbnRpYWxzPzogU2lnbkluQW5vbnltb3VzbHlDcmVkZW50aWFscyk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgZGF0YTogY3JlZGVudGlhbHM/Lm9wdGlvbnM/LmRhdGEgPz8ge30sXG4gICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogY3JlZGVudGlhbHM/Lm9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICB9LFxuICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgIH0pXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXNcblxuICAgICAgaWYgKGVycm9yIHx8ICFkYXRhKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwgPSBkYXRhLnNlc3Npb25cbiAgICAgIGNvbnN0IHVzZXI6IFVzZXIgfCBudWxsID0gZGF0YS51c2VyXG5cbiAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbilcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHVzZXIuXG4gICAqXG4gICAqIEJlIGF3YXJlIHRoYXQgaWYgYSB1c2VyIGFjY291bnQgZXhpc3RzIGluIHRoZSBzeXN0ZW0geW91IG1heSBnZXQgYmFjayBhblxuICAgKiBlcnJvciBtZXNzYWdlIHRoYXQgYXR0ZW1wdHMgdG8gaGlkZSB0aGlzIGluZm9ybWF0aW9uIGZyb20gdGhlIHVzZXIuXG4gICAqIFRoaXMgbWV0aG9kIGhhcyBzdXBwb3J0IGZvciBQS0NFIHZpYSBlbWFpbCBzaWdudXBzLiBUaGUgUEtDRSBmbG93IGNhbm5vdCBiZSB1c2VkIHdoZW4gYXV0b2NvbmZpcm0gaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHJldHVybnMgQSBsb2dnZWQtaW4gc2Vzc2lvbiBpZiB0aGUgc2VydmVyIGhhcyBcImF1dG9jb25maXJtXCIgT05cbiAgICogQHJldHVybnMgQSB1c2VyIGlmIHRoZSBzZXJ2ZXIgaGFzIFwiYXV0b2NvbmZpcm1cIiBPRkZcbiAgICovXG4gIGFzeW5jIHNpZ25VcChjcmVkZW50aWFsczogU2lnblVwV2l0aFBhc3N3b3JkQ3JlZGVudGlhbHMpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgcmVzOiBBdXRoUmVzcG9uc2VcbiAgICAgIGlmICgnZW1haWwnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFsc1xuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2Q6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICA7W2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZUtleVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnM/LmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgZGF0YTogb3B0aW9ucz8uZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCB7IHBob25lLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHNcbiAgICAgICAgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc2lnbnVwYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgZGF0YTogb3B0aW9ucz8uZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIGNoYW5uZWw6IG9wdGlvbnM/LmNoYW5uZWwgPz8gJ3NtcycsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcihcbiAgICAgICAgICAnWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gZW1haWwgb3IgcGhvbmUgbnVtYmVyIGFuZCBhIHBhc3N3b3JkJ1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc1xuXG4gICAgICBpZiAoZXJyb3IgfHwgIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlc3Npb246IFNlc3Npb24gfCBudWxsID0gZGF0YS5zZXNzaW9uXG4gICAgICBjb25zdCB1c2VyOiBVc2VyIHwgbnVsbCA9IGRhdGEudXNlclxuXG4gICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbilcbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9nIGluIGFuIGV4aXN0aW5nIHVzZXIgd2l0aCBhbiBlbWFpbCBhbmQgcGFzc3dvcmQgb3IgcGhvbmUgYW5kIHBhc3N3b3JkLlxuICAgKlxuICAgKiBCZSBhd2FyZSB0aGF0IHlvdSBtYXkgZ2V0IGJhY2sgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IHdpbGwgbm90IGRpc3Rpbmd1aXNoXG4gICAqIGJldHdlZW4gdGhlIGNhc2VzIHdoZXJlIHRoZSBhY2NvdW50IGRvZXMgbm90IGV4aXN0IG9yIHRoYXQgdGhlXG4gICAqIGVtYWlsL3Bob25lIGFuZCBwYXNzd29yZCBjb21iaW5hdGlvbiBpcyB3cm9uZyBvciB0aGF0IHRoZSBhY2NvdW50IGNhbiBvbmx5XG4gICAqIGJlIGFjY2Vzc2VkIHZpYSBzb2NpYWwgbG9naW4uXG4gICAqL1xuICBhc3luYyBzaWduSW5XaXRoUGFzc3dvcmQoXG4gICAgY3JlZGVudGlhbHM6IFNpZ25JbldpdGhQYXNzd29yZENyZWRlbnRpYWxzXG4gICk6IFByb21pc2U8QXV0aFRva2VuUmVzcG9uc2VQYXNzd29yZD4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgcmVzOiBBdXRoUmVzcG9uc2VQYXNzd29yZFxuICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBlbWFpbCwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGFzc3dvcmRgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBwaG9uZSwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGFzc3dvcmRgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKFxuICAgICAgICAgICdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH0gZWxzZSBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCkgfVxuICAgICAgfVxuICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pXG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdXNlcjogZGF0YS51c2VyLFxuICAgICAgICAgIHNlc3Npb246IGRhdGEuc2Vzc2lvbixcbiAgICAgICAgICAuLi4oZGF0YS53ZWFrX3Bhc3N3b3JkID8geyB3ZWFrUGFzc3dvcmQ6IGRhdGEud2Vha19wYXNzd29yZCB9IDogbnVsbCksXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yLFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgaW4gYW4gZXhpc3RpbmcgdXNlciB2aWEgYSB0aGlyZC1wYXJ0eSBwcm92aWRlci5cbiAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgdGhlIFBLQ0UgZmxvdy5cbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhPQXV0aChjcmVkZW50aWFsczogU2lnbkluV2l0aE9BdXRoQ3JlZGVudGlhbHMpOiBQcm9taXNlPE9BdXRoUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5faGFuZGxlUHJvdmlkZXJTaWduSW4oY3JlZGVudGlhbHMucHJvdmlkZXIsIHtcbiAgICAgIHJlZGlyZWN0VG86IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnJlZGlyZWN0VG8sXG4gICAgICBzY29wZXM6IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnNjb3BlcyxcbiAgICAgIHF1ZXJ5UGFyYW1zOiBjcmVkZW50aWFscy5vcHRpb25zPy5xdWVyeVBhcmFtcyxcbiAgICAgIHNraXBCcm93c2VyUmVkaXJlY3Q6IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnNraXBCcm93c2VyUmVkaXJlY3QsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgaW4gYW4gZXhpc3RpbmcgdXNlciBieSBleGNoYW5naW5nIGFuIEF1dGggQ29kZSBpc3N1ZWQgZHVyaW5nIHRoZSBQS0NFIGZsb3cuXG4gICAqL1xuICBhc3luYyBleGNoYW5nZUNvZGVGb3JTZXNzaW9uKGF1dGhDb2RlOiBzdHJpbmcpOiBQcm9taXNlPEF1dGhUb2tlblJlc3BvbnNlPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihhdXRoQ29kZSlcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihhdXRoQ29kZTogc3RyaW5nKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBzZXNzaW9uOiBTZXNzaW9uOyB1c2VyOiBVc2VyOyByZWRpcmVjdFR5cGU6IHN0cmluZyB8IG51bGwgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwgeyBkYXRhOiB7IHNlc3Npb246IG51bGw7IHVzZXI6IG51bGw7IHJlZGlyZWN0VHlwZTogbnVsbCB9OyBlcnJvcjogQXV0aEVycm9yIH1cbiAgPiB7XG4gICAgY29uc3Qgc3RvcmFnZUl0ZW0gPSBhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKVxuICAgIGNvbnN0IFtjb2RlVmVyaWZpZXIsIHJlZGlyZWN0VHlwZV0gPSAoKHN0b3JhZ2VJdGVtID8/ICcnKSBhcyBzdHJpbmcpLnNwbGl0KCcvJylcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgJ1BPU1QnLFxuICAgICAgICBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1wa2NlYCxcbiAgICAgICAge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBhdXRoX2NvZGU6IGF1dGhDb2RlLFxuICAgICAgICAgICAgY29kZV92ZXJpZmllcjogY29kZVZlcmlmaWVyLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LFxuICAgICAgICAgIGVycm9yOiBuZXcgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKSxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pXG4gICAgICB9XG4gICAgICByZXR1cm4geyBkYXRhOiB7IC4uLmRhdGEsIHJlZGlyZWN0VHlwZTogcmVkaXJlY3RUeXBlID8/IG51bGwgfSwgZXJyb3IgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgcmVkaXJlY3RUeXBlOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHNpZ25pbmcgaW4gd2l0aCBhbiBPSURDIElEIHRva2VuLiBUaGUgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgdXNlZFxuICAgKiBzaG91bGQgYmUgZW5hYmxlZCBhbmQgY29uZmlndXJlZC5cbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhJZFRva2VuKGNyZWRlbnRpYWxzOiBTaWduSW5XaXRoSWRUb2tlbkNyZWRlbnRpYWxzKTogUHJvbWlzZTxBdXRoVG9rZW5SZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IG9wdGlvbnMsIHByb3ZpZGVyLCB0b2tlbiwgYWNjZXNzX3Rva2VuLCBub25jZSB9ID0gY3JlZGVudGlhbHNcblxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1pZF90b2tlbmAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgaWRfdG9rZW46IHRva2VuLFxuICAgICAgICAgIGFjY2Vzc190b2tlbixcbiAgICAgICAgICBub25jZSxcbiAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgfSxcbiAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXNcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfSBlbHNlIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSxcbiAgICAgICAgICBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCksXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIG1hZ2ljbGluayBvciBhIG9uZS10aW1lIHBhc3N3b3JkIChPVFApLlxuICAgKlxuICAgKiBJZiB0aGUgYHt7IC5Db25maXJtYXRpb25VUkwgfX1gIHZhcmlhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgZW1haWwgdGVtcGxhdGUsIGEgbWFnaWNsaW5rIHdpbGwgYmUgc2VudC5cbiAgICogSWYgdGhlIGB7eyAuVG9rZW4gfX1gIHZhcmlhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgZW1haWwgdGVtcGxhdGUsIGFuIE9UUCB3aWxsIGJlIHNlbnQuXG4gICAqIElmIHlvdSdyZSB1c2luZyBwaG9uZSBzaWduLWlucywgb25seSBhbiBPVFAgd2lsbCBiZSBzZW50LiBZb3Ugd29uJ3QgYmUgYWJsZSB0byBzZW5kIGEgbWFnaWNsaW5rIGZvciBwaG9uZSBzaWduLWlucy5cbiAgICpcbiAgICogQmUgYXdhcmUgdGhhdCB5b3UgbWF5IGdldCBiYWNrIGFuIGVycm9yIG1lc3NhZ2UgdGhhdCB3aWxsIG5vdCBkaXN0aW5ndWlzaFxuICAgKiBiZXR3ZWVuIHRoZSBjYXNlcyB3aGVyZSB0aGUgYWNjb3VudCBkb2VzIG5vdCBleGlzdCBvciwgdGhhdCB0aGUgYWNjb3VudFxuICAgKiBjYW4gb25seSBiZSBhY2Nlc3NlZCB2aWEgc29jaWFsIGxvZ2luLlxuICAgKlxuICAgKiBEbyBub3RlIHRoYXQgeW91IHdpbGwgbmVlZCB0byBjb25maWd1cmUgYSBXaGF0c2FwcCBzZW5kZXIgb24gVHdpbGlvXG4gICAqIGlmIHlvdSBhcmUgdXNpbmcgcGhvbmUgc2lnbiBpbiB3aXRoIHRoZSAnd2hhdHNhcHAnIGNoYW5uZWwuIFRoZSB3aGF0c2FwcFxuICAgKiBjaGFubmVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gb3RoZXIgcHJvdmlkZXJzXG4gICAqIGF0IHRoaXMgdGltZS5cbiAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgUEtDRSB3aGVuIGFuIGVtYWlsIGlzIHBhc3NlZC5cbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhPdHAoY3JlZGVudGlhbHM6IFNpZ25JbldpdGhQYXNzd29yZGxlc3NDcmVkZW50aWFscyk6IFByb21pc2U8QXV0aE90cFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICgnZW1haWwnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgZW1haWwsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZDogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgIDtbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlS2V5XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L290cGAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICBkYXRhOiBvcHRpb25zPy5kYXRhID8/IHt9LFxuICAgICAgICAgICAgY3JlYXRlX3VzZXI6IG9wdGlvbnM/LnNob3VsZENyZWF0ZVVzZXIgPz8gdHJ1ZSxcbiAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zPy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCB7IHBob25lLCBvcHRpb25zIH0gPSBjcmVkZW50aWFsc1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9vdHBgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgZGF0YTogb3B0aW9ucz8uZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIGNyZWF0ZV91c2VyOiBvcHRpb25zPy5zaG91bGRDcmVhdGVVc2VyID8/IHRydWUsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgIGNoYW5uZWw6IG9wdGlvbnM/LmNoYW5uZWwgPz8gJ3NtcycsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsLCBtZXNzYWdlSWQ6IGRhdGE/Lm1lc3NhZ2VfaWQgfSwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcignWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gZW1haWwgb3IgcGhvbmUgbnVtYmVyLicpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9nIGluIGEgdXNlciBnaXZlbiBhIFVzZXIgc3VwcGxpZWQgT1RQIG9yIFRva2VuSGFzaCByZWNlaXZlZCB0aHJvdWdoIG1vYmlsZSBvciBlbWFpbC5cbiAgICovXG4gIGFzeW5jIHZlcmlmeU90cChwYXJhbXM6IFZlcmlmeU90cFBhcmFtcyk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCByZWRpcmVjdFRvOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgICAgIGxldCBjYXB0Y2hhVG9rZW46IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICAgICAgaWYgKCdvcHRpb25zJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgcmVkaXJlY3RUbyA9IHBhcmFtcy5vcHRpb25zPy5yZWRpcmVjdFRvXG4gICAgICAgIGNhcHRjaGFUb2tlbiA9IHBhcmFtcy5vcHRpb25zPy5jYXB0Y2hhVG9rZW5cbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3ZlcmlmeWAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IGNhcHRjaGFUb2tlbiB9LFxuICAgICAgICB9LFxuICAgICAgICByZWRpcmVjdFRvLFxuICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgIH0pXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCBvbiB0b2tlbiB2ZXJpZmljYXRpb24uJylcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwgPSBkYXRhLnNlc3Npb25cbiAgICAgIGNvbnN0IHVzZXI6IFVzZXIgPSBkYXRhLnVzZXJcblxuICAgICAgaWYgKHNlc3Npb24/LmFjY2Vzc190b2tlbikge1xuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uIGFzIFNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKFxuICAgICAgICAgIHBhcmFtcy50eXBlID09ICdyZWNvdmVyeScgPyAnUEFTU1dPUkRfUkVDT1ZFUlknIDogJ1NJR05FRF9JTicsXG4gICAgICAgICAgc2Vzc2lvblxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgYSBzaW5nbGUtc2lnbiBvbiB1c2luZyBhbiBlbnRlcnByaXNlIElkZW50aXR5IFByb3ZpZGVyLiBBXG4gICAqIHN1Y2Nlc3NmdWwgU1NPIGF0dGVtcHQgd2lsbCByZWRpcmVjdCB0aGUgY3VycmVudCBwYWdlIHRvIHRoZSBpZGVudGl0eVxuICAgKiBwcm92aWRlciBhdXRob3JpemF0aW9uIHBhZ2UuIFRoZSByZWRpcmVjdCBVUkwgaXMgaW1wbGVtZW50YXRpb24gYW5kIFNTT1xuICAgKiBwcm90b2NvbCBzcGVjaWZpYy5cbiAgICpcbiAgICogWW91IGNhbiB1c2UgaXQgYnkgcHJvdmlkaW5nIGEgU1NPIGRvbWFpbi4gVHlwaWNhbGx5IHlvdSBjYW4gZXh0cmFjdCB0aGlzXG4gICAqIGRvbWFpbiBieSBhc2tpbmcgdXNlcnMgZm9yIHRoZWlyIGVtYWlsIGFkZHJlc3MuIElmIHRoaXMgZG9tYWluIGlzXG4gICAqIHJlZ2lzdGVyZWQgb24gdGhlIEF1dGggaW5zdGFuY2UgdGhlIHJlZGlyZWN0IHdpbGwgdXNlIHRoYXQgb3JnYW5pemF0aW9uJ3NcbiAgICogY3VycmVudGx5IGFjdGl2ZSBTU08gSWRlbnRpdHkgUHJvdmlkZXIgZm9yIHRoZSBsb2dpbi5cbiAgICpcbiAgICogSWYgeW91IGhhdmUgYnVpbHQgYW4gb3JnYW5pemF0aW9uLXNwZWNpZmljIGxvZ2luIHBhZ2UsIHlvdSBjYW4gdXNlIHRoZVxuICAgKiBvcmdhbml6YXRpb24ncyBTU08gSWRlbnRpdHkgUHJvdmlkZXIgVVVJRCBkaXJlY3RseSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgc2lnbkluV2l0aFNTTyhwYXJhbXM6IFNpZ25JbldpdGhTU08pOiBQcm9taXNlPFNTT1Jlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb2RlQ2hhbGxlbmdlOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2Q6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgIDtbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKFxuICAgICAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgICAgICB0aGlzLnN0b3JhZ2VLZXlcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc3NvYCwge1xuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgLi4uKCdwcm92aWRlcklkJyBpbiBwYXJhbXMgPyB7IHByb3ZpZGVyX2lkOiBwYXJhbXMucHJvdmlkZXJJZCB9IDogbnVsbCksXG4gICAgICAgICAgLi4uKCdkb21haW4nIGluIHBhcmFtcyA/IHsgZG9tYWluOiBwYXJhbXMuZG9tYWluIH0gOiBudWxsKSxcbiAgICAgICAgICByZWRpcmVjdF90bzogcGFyYW1zLm9wdGlvbnM/LnJlZGlyZWN0VG8gPz8gdW5kZWZpbmVkLFxuICAgICAgICAgIC4uLihwYXJhbXM/Lm9wdGlvbnM/LmNhcHRjaGFUb2tlblxuICAgICAgICAgICAgPyB7IGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IHBhcmFtcy5vcHRpb25zLmNhcHRjaGFUb2tlbiB9IH1cbiAgICAgICAgICAgIDogbnVsbCksXG4gICAgICAgICAgc2tpcF9odHRwX3JlZGlyZWN0OiB0cnVlLCAvLyBmZXRjaCBkb2VzIG5vdCBoYW5kbGUgcmVkaXJlY3RzXG4gICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kLFxuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHhmb3JtOiBfc3NvUmVzcG9uc2UsXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVhdXRoZW50aWNhdGlvbiBPVFAgdG8gdGhlIHVzZXIncyBlbWFpbCBvciBwaG9uZSBudW1iZXIuXG4gICAqIFJlcXVpcmVzIHRoZSB1c2VyIHRvIGJlIHNpZ25lZC1pbi5cbiAgICovXG4gIGFzeW5jIHJlYXV0aGVudGljYXRlKCk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVhdXRoZW50aWNhdGUoKVxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9yZWF1dGhlbnRpY2F0ZSgpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkYXRhOiB7IHNlc3Npb24gfSxcbiAgICAgICAgICBlcnJvcjogc2Vzc2lvbkVycm9yLFxuICAgICAgICB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHRocm93IHNlc3Npb25FcnJvclxuICAgICAgICBpZiAoIXNlc3Npb24pIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG5cbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9yZWF1dGhlbnRpY2F0ZWAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2VuZHMgYW4gZXhpc3Rpbmcgc2lnbnVwIGNvbmZpcm1hdGlvbiBlbWFpbCwgZW1haWwgY2hhbmdlIGVtYWlsLCBTTVMgT1RQIG9yIHBob25lIGNoYW5nZSBPVFAuXG4gICAqL1xuICBhc3luYyByZXNlbmQoY3JlZGVudGlhbHM6IFJlc2VuZFBhcmFtcyk6IFByb21pc2U8QXV0aE90cFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy51cmx9L3Jlc2VuZGBcbiAgICAgIGlmICgnZW1haWwnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgZW1haWwsIHR5cGUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgZW5kcG9pbnQsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zPy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9IGVsc2UgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBwaG9uZSwgdHlwZSwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHNcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBlbmRwb2ludCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIG1lc3NhZ2VJZDogZGF0YT8ubWVzc2FnZV9pZCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKFxuICAgICAgICAnWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gZW1haWwgb3IgcGhvbmUgbnVtYmVyIGFuZCBhIHR5cGUnXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNlc3Npb24sIHJlZnJlc2hpbmcgaXQgaWYgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiBUaGUgc2Vzc2lvbiByZXR1cm5lZCBjYW4gYmUgbnVsbCBpZiB0aGUgc2Vzc2lvbiBpcyBub3QgZGV0ZWN0ZWQgd2hpY2ggY2FuIGhhcHBlbiBpbiB0aGUgZXZlbnQgYSB1c2VyIGlzIG5vdCBzaWduZWQtaW4gb3IgaGFzIGxvZ2dlZCBvdXQuXG4gICAqXG4gICAqICoqSU1QT1JUQU5UOioqIFRoaXMgbWV0aG9kIGxvYWRzIHZhbHVlcyBkaXJlY3RseSBmcm9tIHRoZSBzdG9yYWdlIGF0dGFjaGVkXG4gICAqIHRvIHRoZSBjbGllbnQuIElmIHRoYXQgc3RvcmFnZSBpcyBiYXNlZCBvbiByZXF1ZXN0IGNvb2tpZXMgZm9yIGV4YW1wbGUsXG4gICAqIHRoZSB2YWx1ZXMgaW4gaXQgbWF5IG5vdCBiZSBhdXRoZW50aWMgYW5kIHRoZXJlZm9yZSBpdCdzIHN0cm9uZ2x5IGFkdmlzZWRcbiAgICogYWdhaW5zdCB1c2luZyB0aGlzIG1ldGhvZCBhbmQgaXRzIHJlc3VsdHMgaW4gc3VjaCBjaXJjdW1zdGFuY2VzLiBBIHdhcm5pbmdcbiAgICogd2lsbCBiZSBlbWl0dGVkIGlmIHRoaXMgaXMgZGV0ZWN0ZWQuIFVzZSB7QGxpbmsgI2dldFVzZXIoKX0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFNlc3Npb24oKSB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLyoqXG4gICAqIEFjcXVpcmVzIGEgZ2xvYmFsIGxvY2sgYmFzZWQgb24gdGhlIHN0b3JhZ2Uga2V5LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfYWNxdWlyZUxvY2s8Uj4oYWNxdWlyZVRpbWVvdXQ6IG51bWJlciwgZm46ICgpID0+IFByb21pc2U8Uj4pOiBQcm9taXNlPFI+IHtcbiAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdiZWdpbicsIGFjcXVpcmVUaW1lb3V0KVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5wZW5kaW5nSW5Mb2NrLmxlbmd0aFxuICAgICAgICAgID8gdGhpcy5wZW5kaW5nSW5Mb2NrW3RoaXMucGVuZGluZ0luTG9jay5sZW5ndGggLSAxXVxuICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKClcblxuICAgICAgICBjb25zdCByZXN1bHQgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IGxhc3RcbiAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKVxuICAgICAgICB9KSgpXG5cbiAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnB1c2goXG4gICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IHJlc3VsdFxuICAgICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICAgIC8vIHdlIGp1c3QgY2FyZSBpZiBpdCBmaW5pc2hlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKClcbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9jayhgbG9jazoke3RoaXMuc3RvcmFnZUtleX1gLCBhY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdsb2NrIGFjcXVpcmVkIGZvciBzdG9yYWdlIGtleScsIHRoaXMuc3RvcmFnZUtleSlcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMubG9ja0FjcXVpcmVkID0gdHJ1ZVxuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4oKVxuXG4gICAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnB1c2goXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdFxuICAgICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGNhcmUgaWYgaXQgZmluaXNoZWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKVxuICAgICAgICAgIClcblxuICAgICAgICAgIGF3YWl0IHJlc3VsdFxuXG4gICAgICAgICAgLy8ga2VlcCBkcmFpbmluZyB0aGUgcXVldWUgdW50aWwgdGhlcmUncyBub3RoaW5nIHRvIHdhaXQgb25cbiAgICAgICAgICB3aGlsZSAodGhpcy5wZW5kaW5nSW5Mb2NrLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgd2FpdE9uID0gWy4uLnRoaXMucGVuZGluZ0luTG9ja11cblxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwod2FpdE9uKVxuXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2suc3BsaWNlKDAsIHdhaXRPbi5sZW5ndGgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3VsdFxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2xvY2sgcmVsZWFzZWQgZm9yIHN0b3JhZ2Uga2V5JywgdGhpcy5zdG9yYWdlS2V5KVxuXG4gICAgICAgICAgdGhpcy5sb2NrQWNxdWlyZWQgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgaW5zdGVhZCBvZiB7QGxpbmsgI2dldFNlc3Npb259IGluc2lkZSB0aGUgbGlicmFyeS4gSXQgaXNcbiAgICogc2VtYW50aWNhbGx5IHVzdWFsbHkgd2hhdCB5b3Ugd2FudCwgYXMgZ2V0dGluZyBhIHNlc3Npb24gaW52b2x2ZXMgc29tZVxuICAgKiBwcm9jZXNzaW5nIGFmdGVyd2FyZHMgdGhhdCByZXF1aXJlcyBvbmx5IG9uZSBjbGllbnQgb3BlcmF0aW5nIG9uIHRoZVxuICAgKiBzZXNzaW9uIGF0IG9uY2UgYWNyb3NzIG11bHRpcGxlIHRhYnMgb3IgcHJvY2Vzc2VzLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfdXNlU2Vzc2lvbjxSPihcbiAgICBmbjogKFxuICAgICAgcmVzdWx0OlxuICAgICAgICB8IHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc2Vzc2lvbjogU2Vzc2lvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIHwge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBzZXNzaW9uOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcjogQXV0aEVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB8IHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc2Vzc2lvbjogbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICB9XG4gICAgKSA9PiBQcm9taXNlPFI+XG4gICk6IFByb21pc2U8Uj4ge1xuICAgIHRoaXMuX2RlYnVnKCcjX3VzZVNlc3Npb24nLCAnYmVnaW4nKVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIHRoZSB1c2Ugb2YgX19sb2FkU2Vzc2lvbiBoZXJlIGlzIHRoZSBvbmx5IGNvcnJlY3QgdXNlIG9mIHRoZSBmdW5jdGlvbiFcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX19sb2FkU2Vzc2lvbigpXG5cbiAgICAgIHJldHVybiBhd2FpdCBmbihyZXN1bHQpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2RlYnVnKCcjX3VzZVNlc3Npb24nLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTkVWRVIgVVNFIERJUkVDVExZIVxuICAgKlxuICAgKiBBbHdheXMgdXNlIHtAbGluayAjX3VzZVNlc3Npb259LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfX2xvYWRTZXNzaW9uKCk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzZXNzaW9uOiBTZXNzaW9uXG4gICAgICAgIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgICAgfVxuICAgICAgICBlcnJvcjogQXV0aEVycm9yXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzZXNzaW9uOiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgPiB7XG4gICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAnYmVnaW4nKVxuXG4gICAgaWYgKCF0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAndXNlZCBvdXRzaWRlIG9mIGFuIGFjcXVpcmVkIGxvY2shJywgbmV3IEVycm9yKCkuc3RhY2spXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBjdXJyZW50U2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwgPSBudWxsXG5cbiAgICAgIGNvbnN0IG1heWJlU2Vzc2lvbiA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSlcblxuICAgICAgdGhpcy5fZGVidWcoJyNnZXRTZXNzaW9uKCknLCAnc2Vzc2lvbiBmcm9tIHN0b3JhZ2UnLCBtYXliZVNlc3Npb24pXG5cbiAgICAgIGlmIChtYXliZVNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRTZXNzaW9uKG1heWJlU2Vzc2lvbikpIHtcbiAgICAgICAgICBjdXJyZW50U2Vzc2lvbiA9IG1heWJlU2Vzc2lvblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlIGlzIG5vdCB2YWxpZCcpXG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwgfSwgZXJyb3I6IG51bGwgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBoYXNFeHBpcmVkID0gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdFxuICAgICAgICA/IGN1cnJlbnRTZXNzaW9uLmV4cGlyZXNfYXQgPD0gRGF0ZS5ub3coKSAvIDEwMDBcbiAgICAgICAgOiBmYWxzZVxuXG4gICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgJyNfX2xvYWRTZXNzaW9uKCknLFxuICAgICAgICBgc2Vzc2lvbiBoYXMke2hhc0V4cGlyZWQgPyAnJyA6ICcgbm90J30gZXhwaXJlZGAsXG4gICAgICAgICdleHBpcmVzX2F0JyxcbiAgICAgICAgY3VycmVudFNlc3Npb24uZXhwaXJlc19hdFxuICAgICAgKVxuXG4gICAgICBpZiAoIWhhc0V4cGlyZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5pc1NlcnZlcikge1xuICAgICAgICAgIGxldCBzdXBwcmVzc1dhcm5pbmcgPSB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmdcbiAgICAgICAgICBjb25zdCBwcm94eVNlc3Npb246IFNlc3Npb24gPSBuZXcgUHJveHkoY3VycmVudFNlc3Npb24sIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldDogYW55LCBwcm9wOiBzdHJpbmcsIHJlY2VpdmVyOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFzdXBwcmVzc1dhcm5pbmcgJiYgcHJvcCA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBzaG93IHdhcm5pbmcgd2hlbiB0aGUgdXNlciBvYmplY3QgaXMgYmVpbmcgYWNjZXNzZWQgZnJvbSB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgJ1VzaW5nIHRoZSB1c2VyIG9iamVjdCBhcyByZXR1cm5lZCBmcm9tIHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpIG9yIGZyb20gc29tZSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKCkgZXZlbnRzIGNvdWxkIGJlIGluc2VjdXJlISBUaGlzIHZhbHVlIGNvbWVzIGRpcmVjdGx5IGZyb20gdGhlIHN0b3JhZ2UgbWVkaXVtICh1c3VhbGx5IGNvb2tpZXMgb24gdGhlIHNlcnZlcikgYW5kIG1heSBub3QgYmUgYXV0aGVudGljLiBVc2Ugc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCkgaW5zdGVhZCB3aGljaCBhdXRoZW50aWNhdGVzIHRoZSBkYXRhIGJ5IGNvbnRhY3RpbmcgdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLidcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgc3VwcHJlc3NXYXJuaW5nID0gdHJ1ZSAvLyBrZWVwcyB0aGlzIHByb3h5IGluc3RhbmNlIGZyb20gbG9nZ2luZyBhZGRpdGlvbmFsIHdhcm5pbmdzXG4gICAgICAgICAgICAgICAgdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gdHJ1ZSAvLyBrZWVwcyB0aGlzIGNsaWVudCdzIGZ1dHVyZSBwcm94eSBpbnN0YW5jZXMgZnJvbSB3YXJuaW5nXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pXG4gICAgICAgICAgY3VycmVudFNlc3Npb24gPSBwcm94eVNlc3Npb25cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogY3VycmVudFNlc3Npb24gfSwgZXJyb3I6IG51bGwgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCB1c2VyIGRldGFpbHMgaWYgdGhlcmUgaXMgYW4gZXhpc3Rpbmcgc2Vzc2lvbi4gVGhpcyBtZXRob2RcbiAgICogcGVyZm9ybXMgYSBuZXR3b3JrIHJlcXVlc3QgdG8gdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLCBzbyB0aGUgcmV0dXJuZWRcbiAgICogdmFsdWUgaXMgYXV0aGVudGljIGFuZCBjYW4gYmUgdXNlZCB0byBiYXNlIGF1dGhvcml6YXRpb24gcnVsZXMgb24uXG4gICAqXG4gICAqIEBwYXJhbSBqd3QgVGFrZXMgaW4gYW4gb3B0aW9uYWwgYWNjZXNzIHRva2VuIEpXVC4gSWYgbm8gSldUIGlzIHByb3ZpZGVkLCB0aGUgSldUIGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyB1c2VkLlxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlcihqd3Q/OiBzdHJpbmcpOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIGlmIChqd3QpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKGp3dClcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldFVzZXIoKVxuICAgIH0pXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9nZXRVc2VyKGp3dD86IHN0cmluZyk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChqd3QpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vdXNlcmAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgand0OiBqd3QsXG4gICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm5zIGFuIGVycm9yIGlmIHRoZXJlIGlzIG5vIGFjY2Vzc190b2tlbiBvciBjdXN0b20gYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgICAgaWYgKCFkYXRhLnNlc3Npb24/LmFjY2Vzc190b2tlbiAmJiAhdGhpcy5oYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yOiBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBqd3Q6IGRhdGEuc2Vzc2lvbj8uYWNjZXNzX3Rva2VuID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgaWYgKGlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgLy8gSldUIGNvbnRhaW5zIGEgYHNlc3Npb25faWRgIHdoaWNoIGRvZXMgbm90IGNvcnJlc3BvbmQgdG8gYW4gYWN0aXZlXG4gICAgICAgICAgLy8gc2Vzc2lvbiBpbiB0aGUgZGF0YWJhc2UsIGluZGljYXRpbmcgdGhlIHVzZXIgaXMgc2lnbmVkIG91dC5cblxuICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKVxuICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHVzZXIgZGF0YSBmb3IgYSBsb2dnZWQgaW4gdXNlci5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVVzZXIoXG4gICAgYXR0cmlidXRlczogVXNlckF0dHJpYnV0ZXMsXG4gICAgb3B0aW9uczoge1xuICAgICAgZW1haWxSZWRpcmVjdFRvPzogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgfSA9IHt9XG4gICk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXBkYXRlVXNlcihhdHRyaWJ1dGVzLCBvcHRpb25zKVxuICAgIH0pXG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX3VwZGF0ZVVzZXIoXG4gICAgYXR0cmlidXRlczogVXNlckF0dHJpYnV0ZXMsXG4gICAgb3B0aW9uczoge1xuICAgICAgZW1haWxSZWRpcmVjdFRvPzogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgfSA9IHt9XG4gICk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBzZXNzaW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlc3Npb25EYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlc3Npb246IFNlc3Npb24gPSBzZXNzaW9uRGF0YS5zZXNzaW9uXG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZDogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJyAmJiBhdHRyaWJ1dGVzLmVtYWlsICE9IG51bGwpIHtcbiAgICAgICAgICA7W2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZUtleVxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3I6IHVzZXJFcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BVVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zPy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLFxuICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgfSlcbiAgICAgICAgaWYgKHVzZXJFcnJvcikgdGhyb3cgdXNlckVycm9yXG4gICAgICAgIHNlc3Npb24udXNlciA9IGRhdGEudXNlciBhcyBVc2VyXG4gICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdVU0VSX1VQREFURUQnLCBzZXNzaW9uKVxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IHNlc3Npb24udXNlciB9LCBlcnJvcjogbnVsbCB9XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZXMgYSBKV1QgKHdpdGhvdXQgcGVyZm9ybWluZyBhbnkgdmFsaWRhdGlvbikuXG4gICAqL1xuICBwcml2YXRlIF9kZWNvZGVKV1Qoand0OiBzdHJpbmcpOiB7XG4gICAgZXhwPzogbnVtYmVyXG4gICAgYWFsPzogQXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVscyB8IG51bGxcbiAgICBhbXI/OiBBTVJFbnRyeVtdIHwgbnVsbFxuICB9IHtcbiAgICByZXR1cm4gZGVjb2RlSldUUGF5bG9hZChqd3QpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2Vzc2lvbiBkYXRhIGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbi4gSWYgdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyBleHBpcmVkLCBzZXRTZXNzaW9uIHdpbGwgdGFrZSBjYXJlIG9mIHJlZnJlc2hpbmcgaXQgdG8gb2J0YWluIGEgbmV3IHNlc3Npb24uXG4gICAqIElmIHRoZSByZWZyZXNoIHRva2VuIG9yIGFjY2VzcyB0b2tlbiBpbiB0aGUgY3VycmVudCBzZXNzaW9uIGlzIGludmFsaWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgKiBAcGFyYW0gY3VycmVudFNlc3Npb24gVGhlIGN1cnJlbnQgc2Vzc2lvbiB0aGF0IG1pbmltYWxseSBjb250YWlucyBhbiBhY2Nlc3MgdG9rZW4gYW5kIHJlZnJlc2ggdG9rZW4uXG4gICAqL1xuICBhc3luYyBzZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uOiB7XG4gICAgYWNjZXNzX3Rva2VuOiBzdHJpbmdcbiAgICByZWZyZXNoX3Rva2VuOiBzdHJpbmdcbiAgfSk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2V0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbilcbiAgICB9KVxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9zZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uOiB7XG4gICAgYWNjZXNzX3Rva2VuOiBzdHJpbmdcbiAgICByZWZyZXNoX3Rva2VuOiBzdHJpbmdcbiAgfSk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuIHx8ICFjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRpbWVOb3cgPSBEYXRlLm5vdygpIC8gMTAwMFxuICAgICAgbGV0IGV4cGlyZXNBdCA9IHRpbWVOb3dcbiAgICAgIGxldCBoYXNFeHBpcmVkID0gdHJ1ZVxuICAgICAgbGV0IHNlc3Npb246IFNlc3Npb24gfCBudWxsID0gbnVsbFxuICAgICAgY29uc3QgcGF5bG9hZCA9IGRlY29kZUpXVFBheWxvYWQoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKVxuICAgICAgaWYgKHBheWxvYWQuZXhwKSB7XG4gICAgICAgIGV4cGlyZXNBdCA9IHBheWxvYWQuZXhwXG4gICAgICAgIGhhc0V4cGlyZWQgPSBleHBpcmVzQXQgPD0gdGltZU5vd1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzRXhwaXJlZCkge1xuICAgICAgICBjb25zdCB7IHNlc3Npb246IHJlZnJlc2hlZFNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKFxuICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW5cbiAgICAgICAgKVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVmcmVzaGVkU2Vzc2lvbikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9XG4gICAgICAgIH1cbiAgICAgICAgc2Vzc2lvbiA9IHJlZnJlc2hlZFNlc3Npb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICB9XG4gICAgICAgIHNlc3Npb24gPSB7XG4gICAgICAgICAgYWNjZXNzX3Rva2VuOiBjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgcmVmcmVzaF90b2tlbjogY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbixcbiAgICAgICAgICB1c2VyOiBkYXRhLnVzZXIsXG4gICAgICAgICAgdG9rZW5fdHlwZTogJ2JlYXJlcicsXG4gICAgICAgICAgZXhwaXJlc19pbjogZXhwaXJlc0F0IC0gdGltZU5vdyxcbiAgICAgICAgICBleHBpcmVzX2F0OiBleHBpcmVzQXQsXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbilcbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwsIHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHNlc3Npb24sIHJlZ2FyZGxlc3Mgb2YgZXhwaXJ5IHN0YXR1cy5cbiAgICogVGFrZXMgaW4gYW4gb3B0aW9uYWwgY3VycmVudCBzZXNzaW9uLiBJZiBub3QgcGFzc2VkIGluLCB0aGVuIHJlZnJlc2hTZXNzaW9uKCkgd2lsbCBhdHRlbXB0IHRvIHJldHJpZXZlIGl0IGZyb20gZ2V0U2Vzc2lvbigpLlxuICAgKiBJZiB0aGUgY3VycmVudCBzZXNzaW9uJ3MgcmVmcmVzaCB0b2tlbiBpcyBpbnZhbGlkLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICogQHBhcmFtIGN1cnJlbnRTZXNzaW9uIFRoZSBjdXJyZW50IHNlc3Npb24uIElmIHBhc3NlZCBpbiwgaXQgbXVzdCBjb250YWluIGEgcmVmcmVzaCB0b2tlbi5cbiAgICovXG4gIGFzeW5jIHJlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uPzogeyByZWZyZXNoX3Rva2VuOiBzdHJpbmcgfSk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pXG4gICAgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24/OiB7XG4gICAgcmVmcmVzaF90b2tlbjogc3RyaW5nXG4gIH0pOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmICghY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFNlc3Npb24gPSBkYXRhLnNlc3Npb24gPz8gdW5kZWZpbmVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uPy5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc2Vzc2lvbiwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbilcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IG51bGwgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBzZXNzaW9uLnVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzZXNzaW9uIGRhdGEgZnJvbSBhIFVSTCBzdHJpbmdcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2dldFNlc3Npb25Gcm9tVVJMKFxuICAgIHBhcmFtczogeyBbcGFyYW1ldGVyOiBzdHJpbmddOiBzdHJpbmcgfSxcbiAgICBjYWxsYmFja1VybFR5cGU6IHN0cmluZ1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IHNlc3Npb246IFNlc3Npb247IHJlZGlyZWN0VHlwZTogc3RyaW5nIHwgbnVsbCB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbDsgcmVkaXJlY3RUeXBlOiBudWxsIH07IGVycm9yOiBBdXRoRXJyb3IgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFpc0Jyb3dzZXIoKSkgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm8gYnJvd3NlciBkZXRlY3RlZC4nKVxuXG4gICAgICAvLyBJZiB0aGVyZSdzIGFuIGVycm9yIGluIHRoZSBVUkwsIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgZmxvdyBpdCBpcywgd2UganVzdCByZXR1cm4gdGhlIGVycm9yLlxuICAgICAgaWYgKHBhcmFtcy5lcnJvciB8fCBwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24gfHwgcGFyYW1zLmVycm9yX2NvZGUpIHtcbiAgICAgICAgLy8gVGhlIGVycm9yIGNsYXNzIHJldHVybmVkIGltcGxpZXMgdGhhdCB0aGUgcmVkaXJlY3QgaXMgZnJvbSBhbiBpbXBsaWNpdCBncmFudCBmbG93XG4gICAgICAgIC8vIGJ1dCBpdCBjb3VsZCBhbHNvIGJlIGZyb20gYSByZWRpcmVjdCBlcnJvciBmcm9tIGEgUEtDRSBmbG93LlxuICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKFxuICAgICAgICAgIHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbiB8fCAnRXJyb3IgaW4gVVJMIHdpdGggdW5zcGVjaWZpZWQgZXJyb3JfZGVzY3JpcHRpb24nLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yOiBwYXJhbXMuZXJyb3IgfHwgJ3Vuc3BlY2lmaWVkX2Vycm9yJyxcbiAgICAgICAgICAgIGNvZGU6IHBhcmFtcy5lcnJvcl9jb2RlIHx8ICd1bnNwZWNpZmllZF9jb2RlJyxcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2tzIGZvciBtaXNtYXRjaGVzIGJldHdlZW4gdGhlIGZsb3dUeXBlIGluaXRpYWxpc2VkIGluIHRoZSBjbGllbnQgYW5kIHRoZSBVUkwgcGFyYW1ldGVyc1xuICAgICAgc3dpdGNoIChjYWxsYmFja1VybFR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW1wbGljaXQnOlxuICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IoJ05vdCBhIHZhbGlkIFBLQ0UgZmxvdyB1cmwuJylcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAncGtjZSc6XG4gICAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdpbXBsaWNpdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vdCBhIHZhbGlkIGltcGxpY2l0IGdyYW50IGZsb3cgdXJsLicpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIHRoZXJlJ3Mgbm8gbWlzbWF0Y2ggc28gd2UgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gU2luY2UgdGhpcyBpcyBhIHJlZGlyZWN0IGZvciBQS0NFLCB3ZSBhdHRlbXB0IHRvIHJldHJpZXZlIHRoZSBjb2RlIGZyb20gdGhlIFVSTCBmb3IgdGhlIGNvZGUgZXhjaGFuZ2VcbiAgICAgIGlmIChjYWxsYmFja1VybFR5cGUgPT09ICdwa2NlJykge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnYmVnaW4nLCAnaXMgUEtDRSBmbG93JywgdHJ1ZSlcbiAgICAgICAgaWYgKCFwYXJhbXMuY29kZSkgdGhyb3cgbmV3IEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcignTm8gY29kZSBkZXRlY3RlZC4nKVxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9leGNoYW5nZUNvZGVGb3JTZXNzaW9uKHBhcmFtcy5jb2RlKVxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoJ2NvZGUnKVxuXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh3aW5kb3cuaGlzdG9yeS5zdGF0ZSwgJycsIHVybC50b1N0cmluZygpKVxuXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogZGF0YS5zZXNzaW9uLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3I6IG51bGwgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHByb3ZpZGVyX3Rva2VuLFxuICAgICAgICBwcm92aWRlcl9yZWZyZXNoX3Rva2VuLFxuICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgIHJlZnJlc2hfdG9rZW4sXG4gICAgICAgIGV4cGlyZXNfaW4sXG4gICAgICAgIGV4cGlyZXNfYXQsXG4gICAgICAgIHRva2VuX3R5cGUsXG4gICAgICB9ID0gcGFyYW1zXG5cbiAgICAgIGlmICghYWNjZXNzX3Rva2VuIHx8ICFleHBpcmVzX2luIHx8ICFyZWZyZXNoX3Rva2VuIHx8ICF0b2tlbl90eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vIHNlc3Npb24gZGVmaW5lZCBpbiBVUkwnKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB0aW1lTm93ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMClcbiAgICAgIGNvbnN0IGV4cGlyZXNJbiA9IHBhcnNlSW50KGV4cGlyZXNfaW4pXG4gICAgICBsZXQgZXhwaXJlc0F0ID0gdGltZU5vdyArIGV4cGlyZXNJblxuXG4gICAgICBpZiAoZXhwaXJlc19hdCkge1xuICAgICAgICBleHBpcmVzQXQgPSBwYXJzZUludChleHBpcmVzX2F0KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBhY3R1YWxseUV4cGlyZXNJbiA9IGV4cGlyZXNBdCAtIHRpbWVOb3dcbiAgICAgIGlmIChhY3R1YWxseUV4cGlyZXNJbiAqIDEwMDAgPD0gQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT04pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBAc3VwYWJhc2UvZ290cnVlLWpzOiBTZXNzaW9uIGFzIHJldHJpZXZlZCBmcm9tIFVSTCBleHBpcmVzIGluICR7YWN0dWFsbHlFeHBpcmVzSW59cywgc2hvdWxkIGhhdmUgYmVlbiBjbG9zZXIgdG8gJHtleHBpcmVzSW59c2BcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpc3N1ZWRBdCA9IGV4cGlyZXNBdCAtIGV4cGlyZXNJblxuICAgICAgaWYgKHRpbWVOb3cgLSBpc3N1ZWRBdCA+PSAxMjApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdAc3VwYWJhc2UvZ290cnVlLWpzOiBTZXNzaW9uIGFzIHJldHJpZXZlZCBmcm9tIFVSTCB3YXMgaXNzdWVkIG92ZXIgMTIwcyBhZ28sIFVSTCBjb3VsZCBiZSBzdGFsZScsXG4gICAgICAgICAgaXNzdWVkQXQsXG4gICAgICAgICAgZXhwaXJlc0F0LFxuICAgICAgICAgIHRpbWVOb3dcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIGlmICh0aW1lTm93IC0gaXNzdWVkQXQgPCAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnQHN1cGFiYXNlL2dvdHJ1ZS1qczogU2Vzc2lvbiBhcyByZXRyaWV2ZWQgZnJvbSBVUkwgd2FzIGlzc3VlZCBpbiB0aGUgZnV0dXJlPyBDaGVjayB0aGUgZGV2aWNlIGNsb2NrIGZvciBza2V3JyxcbiAgICAgICAgICBpc3N1ZWRBdCxcbiAgICAgICAgICBleHBpcmVzQXQsXG4gICAgICAgICAgdGltZU5vd1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoYWNjZXNzX3Rva2VuKVxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBjb25zdCBzZXNzaW9uOiBTZXNzaW9uID0ge1xuICAgICAgICBwcm92aWRlcl90b2tlbixcbiAgICAgICAgcHJvdmlkZXJfcmVmcmVzaF90b2tlbixcbiAgICAgICAgYWNjZXNzX3Rva2VuLFxuICAgICAgICBleHBpcmVzX2luOiBleHBpcmVzSW4sXG4gICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCxcbiAgICAgICAgcmVmcmVzaF90b2tlbixcbiAgICAgICAgdG9rZW5fdHlwZSxcbiAgICAgICAgdXNlcjogZGF0YS51c2VyLFxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdG9rZW5zIGZyb20gVVJMXG4gICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICcnXG4gICAgICB0aGlzLl9kZWJ1ZygnI19nZXRTZXNzaW9uRnJvbVVSTCgpJywgJ2NsZWFyaW5nIHdpbmRvdy5sb2NhdGlvbi5oYXNoJylcblxuICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uLCByZWRpcmVjdFR5cGU6IHBhcmFtcy50eXBlIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBVUkwgY29udGFpbnMgcGFyYW1ldGVycyBnaXZlbiBieSBhbiBpbXBsaWNpdCBvYXV0aCBncmFudCBmbG93IChodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjc0OS5odG1sI3NlY3Rpb24tNC4yKVxuICAgKi9cbiAgcHJpdmF0ZSBfaXNJbXBsaWNpdEdyYW50Q2FsbGJhY2socGFyYW1zOiB7IFtwYXJhbWV0ZXI6IHN0cmluZ106IHN0cmluZyB9KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIEJvb2xlYW4ocGFyYW1zLmFjY2Vzc190b2tlbiB8fCBwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24pXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IFVSTCBhbmQgYmFja2luZyBzdG9yYWdlIGNvbnRhaW4gcGFyYW1ldGVycyBnaXZlbiBieSBhIFBLQ0UgZmxvd1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfaXNQS0NFQ2FsbGJhY2socGFyYW1zOiB7IFtwYXJhbWV0ZXI6IHN0cmluZ106IHN0cmluZyB9KTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgY3VycmVudFN0b3JhZ2VDb250ZW50ID0gYXdhaXQgZ2V0SXRlbUFzeW5jKFxuICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYFxuICAgIClcblxuICAgIHJldHVybiAhIShwYXJhbXMuY29kZSAmJiBjdXJyZW50U3RvcmFnZUNvbnRlbnQpXG4gIH1cblxuICAvKipcbiAgICogSW5zaWRlIGEgYnJvd3NlciBjb250ZXh0LCBgc2lnbk91dCgpYCB3aWxsIHJlbW92ZSB0aGUgbG9nZ2VkIGluIHVzZXIgZnJvbSB0aGUgYnJvd3NlciBzZXNzaW9uIGFuZCBsb2cgdGhlbSBvdXQgLSByZW1vdmluZyBhbGwgaXRlbXMgZnJvbSBsb2NhbHN0b3JhZ2UgYW5kIHRoZW4gdHJpZ2dlciBhIGBcIlNJR05FRF9PVVRcImAgZXZlbnQuXG4gICAqXG4gICAqIEZvciBzZXJ2ZXItc2lkZSBtYW5hZ2VtZW50LCB5b3UgY2FuIHJldm9rZSBhbGwgcmVmcmVzaCB0b2tlbnMgZm9yIGEgdXNlciBieSBwYXNzaW5nIGEgdXNlcidzIEpXVCB0aHJvdWdoIHRvIGBhdXRoLmFwaS5zaWduT3V0KEpXVDogc3RyaW5nKWAuXG4gICAqIFRoZXJlIGlzIG5vIHdheSB0byByZXZva2UgYSB1c2VyJ3MgYWNjZXNzIHRva2VuIGp3dCB1bnRpbCBpdCBleHBpcmVzLiBJdCBpcyByZWNvbW1lbmRlZCB0byBzZXQgYSBzaG9ydGVyIGV4cGlyeSBvbiB0aGUgand0IGZvciB0aGlzIHJlYXNvbi5cbiAgICpcbiAgICogSWYgdXNpbmcgYG90aGVyc2Agc2NvcGUsIG5vIGBTSUdORURfT1VUYCBldmVudCBpcyBmaXJlZCFcbiAgICovXG4gIGFzeW5jIHNpZ25PdXQob3B0aW9uczogU2lnbk91dCA9IHsgc2NvcGU6ICdnbG9iYWwnIH0pOiBQcm9taXNlPHsgZXJyb3I6IEF1dGhFcnJvciB8IG51bGwgfT4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NpZ25PdXQob3B0aW9ucylcbiAgICB9KVxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9zaWduT3V0KFxuICAgIHsgc2NvcGUgfTogU2lnbk91dCA9IHsgc2NvcGU6ICdnbG9iYWwnIH1cbiAgKTogUHJvbWlzZTx7IGVycm9yOiBBdXRoRXJyb3IgfCBudWxsIH0+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdFxuICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogc2Vzc2lvbkVycm9yIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gZGF0YS5zZXNzaW9uPy5hY2Nlc3NfdG9rZW5cbiAgICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCB0aGlzLmFkbWluLnNpZ25PdXQoYWNjZXNzVG9rZW4sIHNjb3BlKVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBpZ25vcmUgNDA0cyBzaW5jZSB1c2VyIG1pZ2h0IG5vdCBleGlzdCBhbnltb3JlXG4gICAgICAgICAgLy8gaWdub3JlIDQwMXMgc2luY2UgYW4gaW52YWxpZCBvciBleHBpcmVkIEpXVCBzaG91bGQgc2lnbiBvdXQgdGhlIGN1cnJlbnQgc2Vzc2lvblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgIGlzQXV0aEFwaUVycm9yKGVycm9yKSAmJlxuICAgICAgICAgICAgICAoZXJyb3Iuc3RhdHVzID09PSA0MDQgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDEgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDMpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvciB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2NvcGUgIT09ICdvdGhlcnMnKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKVxuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmVjZWl2ZSBhIG5vdGlmaWNhdGlvbiBldmVyeSB0aW1lIGFuIGF1dGggZXZlbnQgaGFwcGVucy5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIGFuIGF1dGggZXZlbnQgaGFwcGVucy5cbiAgICovXG4gIG9uQXV0aFN0YXRlQ2hhbmdlKFxuICAgIGNhbGxiYWNrOiAoZXZlbnQ6IEF1dGhDaGFuZ2VFdmVudCwgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+XG4gICk6IHtcbiAgICBkYXRhOiB7IHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uIH1cbiAgfSB7XG4gICAgY29uc3QgaWQ6IHN0cmluZyA9IHV1aWQoKVxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0ge1xuICAgICAgaWQsXG4gICAgICBjYWxsYmFjayxcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjdW5zdWJzY3JpYmUoKScsICdzdGF0ZSBjaGFuZ2UgY2FsbGJhY2sgd2l0aCBpZCByZW1vdmVkJywgaWQpXG5cbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLmRlbGV0ZShpZClcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgdGhpcy5fZGVidWcoJyNvbkF1dGhTdGF0ZUNoYW5nZSgpJywgJ3JlZ2lzdGVyZWQgY2FsbGJhY2sgd2l0aCBpZCcsIGlkKVxuXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLnNldChpZCwgc3Vic2NyaXB0aW9uKVxuICAgIDsoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbWl0SW5pdGlhbFNlc3Npb24oaWQpXG4gICAgICB9KVxuICAgIH0pKClcblxuICAgIHJldHVybiB7IGRhdGE6IHsgc3Vic2NyaXB0aW9uIH0gfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfZW1pdEluaXRpYWxTZXNzaW9uKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGF0YTogeyBzZXNzaW9uIH0sXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICAgIGF3YWl0IHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5nZXQoaWQpPy5jYWxsYmFjaygnSU5JVElBTF9TRVNTSU9OJywgc2Vzc2lvbilcbiAgICAgICAgdGhpcy5fZGVidWcoJ0lOSVRJQUxfU0VTU0lPTicsICdjYWxsYmFjayBpZCcsIGlkLCAnc2Vzc2lvbicsIHNlc3Npb24pXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLmdldChpZCk/LmNhbGxiYWNrKCdJTklUSUFMX1NFU1NJT04nLCBudWxsKVxuICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdlcnJvcicsIGVycilcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBhc3N3b3JkIHJlc2V0IHJlcXVlc3QgdG8gYW4gZW1haWwgYWRkcmVzcy4gVGhpcyBtZXRob2Qgc3VwcG9ydHMgdGhlIFBLQ0UgZmxvdy5cbiAgICpcbiAgICogQHBhcmFtIGVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSB1c2VyLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIFRoZSBVUkwgdG8gc2VuZCB0aGUgdXNlciB0byBhZnRlciB0aGV5IGNsaWNrIHRoZSBwYXNzd29yZCByZXNldCBsaW5rLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5jYXB0Y2hhVG9rZW4gVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLlxuICAgKi9cbiAgYXN5bmMgcmVzZXRQYXNzd29yZEZvckVtYWlsKFxuICAgIGVtYWlsOiBzdHJpbmcsXG4gICAgb3B0aW9uczoge1xuICAgICAgcmVkaXJlY3RUbz86IHN0cmluZ1xuICAgICAgY2FwdGNoYVRva2VuPzogc3RyaW5nXG4gICAgfSA9IHt9XG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHt9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7IGRhdGE6IG51bGw7IGVycm9yOiBBdXRoRXJyb3IgfVxuICA+IHtcbiAgICBsZXQgY29kZUNoYWxsZW5nZTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZDogc3RyaW5nIHwgbnVsbCA9IG51bGxcblxuICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgIDtbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKFxuICAgICAgICB0aGlzLnN0b3JhZ2UsXG4gICAgICAgIHRoaXMuc3RvcmFnZUtleSxcbiAgICAgICAgdHJ1ZSAvLyBpc1Bhc3N3b3JkUmVjb3ZlcnlcbiAgICAgIClcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9yZWNvdmVyYCwge1xuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgZW1haWwsXG4gICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kLFxuICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIHRoZSBpZGVudGl0aWVzIGxpbmtlZCB0byBhIHVzZXIuXG4gICAqL1xuICBhc3luYyBnZXRVc2VySWRlbnRpdGllcygpOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWRlbnRpdGllczogVXNlcklkZW50aXR5W11cbiAgICAgICAgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwgeyBkYXRhOiBudWxsOyBlcnJvcjogQXV0aEVycm9yIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuZ2V0VXNlcigpXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICByZXR1cm4geyBkYXRhOiB7IGlkZW50aXRpZXM6IGRhdGEudXNlci5pZGVudGl0aWVzID8/IFtdIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuICAvKipcbiAgICogTGlua3MgYW4gb2F1dGggaWRlbnRpdHkgdG8gYW4gZXhpc3RpbmcgdXNlci5cbiAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgdGhlIFBLQ0UgZmxvdy5cbiAgICovXG4gIGFzeW5jIGxpbmtJZGVudGl0eShjcmVkZW50aWFsczogU2lnbkluV2l0aE9BdXRoQ3JlZGVudGlhbHMpOiBQcm9taXNlPE9BdXRoUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICAgIGNvbnN0IHVybDogc3RyaW5nID0gYXdhaXQgdGhpcy5fZ2V0VXJsRm9yUHJvdmlkZXIoXG4gICAgICAgICAgYCR7dGhpcy51cmx9L3VzZXIvaWRlbnRpdGllcy9hdXRob3JpemVgLFxuICAgICAgICAgIGNyZWRlbnRpYWxzLnByb3ZpZGVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlZGlyZWN0VG86IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnJlZGlyZWN0VG8sXG4gICAgICAgICAgICBzY29wZXM6IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnNjb3BlcyxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBjcmVkZW50aWFscy5vcHRpb25zPy5xdWVyeVBhcmFtcyxcbiAgICAgICAgICAgIHNraXBCcm93c2VyUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgdXJsLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGp3dDogZGF0YS5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4gPz8gdW5kZWZpbmVkLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhY3JlZGVudGlhbHMub3B0aW9ucz8uc2tpcEJyb3dzZXJSZWRpcmVjdCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKGRhdGE/LnVybClcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgcHJvdmlkZXI6IGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB1cmw6IGRhdGE/LnVybCB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBwcm92aWRlcjogY3JlZGVudGlhbHMucHJvdmlkZXIsIHVybDogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbmxpbmtzIGFuIGlkZW50aXR5IGZyb20gYSB1c2VyIGJ5IGRlbGV0aW5nIGl0LiBUaGUgdXNlciB3aWxsIG5vIGxvbmdlciBiZSBhYmxlIHRvIHNpZ24gaW4gd2l0aCB0aGF0IGlkZW50aXR5IG9uY2UgaXQncyB1bmxpbmtlZC5cbiAgICovXG4gIGFzeW5jIHVubGlua0lkZW50aXR5KGlkZW50aXR5OiBVc2VySWRlbnRpdHkpOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7fVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwgeyBkYXRhOiBudWxsOyBlcnJvcjogQXV0aEVycm9yIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KFxuICAgICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgICAgJ0RFTEVURScsXG4gICAgICAgICAgYCR7dGhpcy51cmx9L3VzZXIvaWRlbnRpdGllcy8ke2lkZW50aXR5LmlkZW50aXR5X2lkfWAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgand0OiBkYXRhLnNlc3Npb24/LmFjY2Vzc190b2tlbiA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIG5ldyBKV1QuXG4gICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gQSB2YWxpZCByZWZyZXNoIHRva2VuIHRoYXQgd2FzIHJldHVybmVkIG9uIGxvZ2luLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfcmVmcmVzaEFjY2Vzc1Rva2VuKHJlZnJlc2hUb2tlbjogc3RyaW5nKTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19yZWZyZXNoQWNjZXNzVG9rZW4oJHtyZWZyZXNoVG9rZW4uc3Vic3RyaW5nKDAsIDUpfS4uLilgXG4gICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXJ0ZWRBdCA9IERhdGUubm93KClcblxuICAgICAgLy8gd2lsbCBhdHRlbXB0IHRvIHJlZnJlc2ggdGhlIHRva2VuIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgcmV0dXJuIGF3YWl0IHJldHJ5YWJsZShcbiAgICAgICAgYXN5bmMgKGF0dGVtcHQpID0+IHtcbiAgICAgICAgICBpZiAoYXR0ZW1wdCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKDIwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKSkgLy8gMjAwLCA0MDAsIDgwMCwgLi4uXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAncmVmcmVzaGluZyBhdHRlbXB0JywgYXR0ZW1wdClcblxuICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXJlZnJlc2hfdG9rZW5gLCB7XG4gICAgICAgICAgICBib2R5OiB7IHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbiB9LFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgKGF0dGVtcHQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV4dEJhY2tPZmZJbnRlcnZhbCA9IDIwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGVycm9yICYmXG4gICAgICAgICAgICBpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yKSAmJlxuICAgICAgICAgICAgLy8gcmV0cnlhYmxlIG9ubHkgaWYgdGhlIHJlcXVlc3QgY2FuIGJlIHNlbnQgYmVmb3JlIHRoZSBiYWNrb2ZmIG92ZXJmbG93cyB0aGUgdGljayBkdXJhdGlvblxuICAgICAgICAgICAgRGF0ZS5ub3coKSArIG5leHRCYWNrT2ZmSW50ZXJ2YWwgLSBzdGFydGVkQXQgPCBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTlxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycm9yKVxuXG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2lzVmFsaWRTZXNzaW9uKG1heWJlU2Vzc2lvbjogdW5rbm93bik6IG1heWJlU2Vzc2lvbiBpcyBTZXNzaW9uIHtcbiAgICBjb25zdCBpc1ZhbGlkU2Vzc2lvbiA9XG4gICAgICB0eXBlb2YgbWF5YmVTZXNzaW9uID09PSAnb2JqZWN0JyAmJlxuICAgICAgbWF5YmVTZXNzaW9uICE9PSBudWxsICYmXG4gICAgICAnYWNjZXNzX3Rva2VuJyBpbiBtYXliZVNlc3Npb24gJiZcbiAgICAgICdyZWZyZXNoX3Rva2VuJyBpbiBtYXliZVNlc3Npb24gJiZcbiAgICAgICdleHBpcmVzX2F0JyBpbiBtYXliZVNlc3Npb25cblxuICAgIHJldHVybiBpc1ZhbGlkU2Vzc2lvblxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfaGFuZGxlUHJvdmlkZXJTaWduSW4oXG4gICAgcHJvdmlkZXI6IFByb3ZpZGVyLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHJlZGlyZWN0VG8/OiBzdHJpbmdcbiAgICAgIHNjb3Blcz86IHN0cmluZ1xuICAgICAgcXVlcnlQYXJhbXM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gICAgICBza2lwQnJvd3NlclJlZGlyZWN0PzogYm9vbGVhblxuICAgIH1cbiAgKSB7XG4gICAgY29uc3QgdXJsOiBzdHJpbmcgPSBhd2FpdCB0aGlzLl9nZXRVcmxGb3JQcm92aWRlcihgJHt0aGlzLnVybH0vYXV0aG9yaXplYCwgcHJvdmlkZXIsIHtcbiAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMucmVkaXJlY3RUbyxcbiAgICAgIHNjb3Blczogb3B0aW9ucy5zY29wZXMsXG4gICAgICBxdWVyeVBhcmFtczogb3B0aW9ucy5xdWVyeVBhcmFtcyxcbiAgICB9KVxuXG4gICAgdGhpcy5fZGVidWcoJyNfaGFuZGxlUHJvdmlkZXJTaWduSW4oKScsICdwcm92aWRlcicsIHByb3ZpZGVyLCAnb3B0aW9ucycsIG9wdGlvbnMsICd1cmwnLCB1cmwpXG5cbiAgICAvLyB0cnkgdG8gb3BlbiBvbiB0aGUgYnJvd3NlclxuICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhb3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybClcbiAgICB9XG5cbiAgICByZXR1cm4geyBkYXRhOiB7IHByb3ZpZGVyLCB1cmwgfSwgZXJyb3I6IG51bGwgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY292ZXJzIHRoZSBzZXNzaW9uIGZyb20gTG9jYWxTdG9yYWdlIGFuZCByZWZyZXNoZXMgdGhlIHRva2VuXG4gICAqIE5vdGU6IHRoaXMgbWV0aG9kIGlzIGFzeW5jIHRvIGFjY29tbW9kYXRlIGZvciBBc3luY1N0b3JhZ2UgZS5nLiBpbiBSZWFjdCBuYXRpdmUuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9yZWNvdmVyQW5kUmVmcmVzaCgpIHtcbiAgICBjb25zdCBkZWJ1Z05hbWUgPSAnI19yZWNvdmVyQW5kUmVmcmVzaCgpJ1xuICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJylcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSlcbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlJywgY3VycmVudFNlc3Npb24pXG5cbiAgICAgIGlmICghdGhpcy5faXNWYWxpZFNlc3Npb24oY3VycmVudFNlc3Npb24pKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3Nlc3Npb24gaXMgbm90IHZhbGlkJylcbiAgICAgICAgaWYgKGN1cnJlbnRTZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgdGltZU5vdyA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApXG4gICAgICBjb25zdCBleHBpcmVzV2l0aE1hcmdpbiA9IChjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0ID8/IEluZmluaXR5KSA8IHRpbWVOb3cgKyBFWFBJUllfTUFSR0lOXG5cbiAgICAgIHRoaXMuX2RlYnVnKFxuICAgICAgICBkZWJ1Z05hbWUsXG4gICAgICAgIGBzZXNzaW9uIGhhcyR7ZXhwaXJlc1dpdGhNYXJnaW4gPyAnJyA6ICcgbm90J30gZXhwaXJlZCB3aXRoIG1hcmdpbiBvZiAke0VYUElSWV9NQVJHSU59c2BcbiAgICAgIClcblxuICAgICAgaWYgKGV4cGlyZXNXaXRoTWFyZ2luKSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4gJiYgY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbikge1xuICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbilcblxuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcilcblxuICAgICAgICAgICAgaWYgKCFpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgICAgICAgICBkZWJ1Z05hbWUsXG4gICAgICAgICAgICAgICAgJ3JlZnJlc2ggZmFpbGVkIHdpdGggYSBub24tcmV0cnlhYmxlIGVycm9yLCByZW1vdmluZyB0aGUgc2Vzc2lvbicsXG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gcGVyc2lzdCBjdXJyZW50U2Vzc2lvbiBhZ2FpbiwgYXMgd2UganVzdCBsb2FkZWQgaXQgZnJvbVxuICAgICAgICAvLyBsb2NhbCBzdG9yYWdlOyBwZXJzaXN0aW5nIGl0IGFnYWluIG1heSBvdmVyd3JpdGUgYSB2YWx1ZSBzYXZlZCBieVxuICAgICAgICAvLyBhbm90aGVyIGNsaWVudCB3aXRoIGFjY2VzcyB0byB0aGUgc2FtZSBsb2NhbCBzdG9yYWdlXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBjdXJyZW50U2Vzc2lvbilcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2Vycm9yJywgZXJyKVxuXG4gICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgIHJldHVyblxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2NhbGxSZWZyZXNoVG9rZW4ocmVmcmVzaFRva2VuOiBzdHJpbmcpOiBQcm9taXNlPENhbGxSZWZyZXNoVG9rZW5SZXN1bHQ+IHtcbiAgICBpZiAoIXJlZnJlc2hUb2tlbikge1xuICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcbiAgICB9XG5cbiAgICAvLyByZWZyZXNoaW5nIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3NcbiAgICBpZiAodGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZC5wcm9taXNlXG4gICAgfVxuXG4gICAgY29uc3QgZGVidWdOYW1lID0gYCNfY2FsbFJlZnJlc2hUb2tlbigke3JlZnJlc2hUb2tlbi5zdWJzdHJpbmcoMCwgNSl9Li4uKWBcblxuICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJylcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCA9IG5ldyBEZWZlcnJlZDxDYWxsUmVmcmVzaFRva2VuUmVzdWx0PigpXG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX3JlZnJlc2hBY2Nlc3NUb2tlbihyZWZyZXNoVG9rZW4pXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICBpZiAoIWRhdGEuc2Vzc2lvbikgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcblxuICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKVxuICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1RPS0VOX1JFRlJFU0hFRCcsIGRhdGEuc2Vzc2lvbilcblxuICAgICAgY29uc3QgcmVzdWx0ID0geyBzZXNzaW9uOiBkYXRhLnNlc3Npb24sIGVycm9yOiBudWxsIH1cblxuICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpXG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnJvcilcblxuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IHNlc3Npb246IG51bGwsIGVycm9yIH1cblxuICAgICAgICBpZiAoIWlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZD8ucmVzb2x2ZShyZXN1bHQpXG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZD8ucmVqZWN0KGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBudWxsXG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX25vdGlmeUFsbFN1YnNjcmliZXJzKFxuICAgIGV2ZW50OiBBdXRoQ2hhbmdlRXZlbnQsXG4gICAgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwsXG4gICAgYnJvYWRjYXN0ID0gdHJ1ZVxuICApIHtcbiAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19ub3RpZnlBbGxTdWJzY3JpYmVycygke2V2ZW50fSlgXG4gICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nLCBzZXNzaW9uLCBgYnJvYWRjYXN0ID0gJHticm9hZGNhc3R9YClcblxuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5icm9hZGNhc3RDaGFubmVsICYmIGJyb2FkY2FzdCkge1xuICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2UoeyBldmVudCwgc2Vzc2lvbiB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBlcnJvcnM6IGFueVtdID0gW11cbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMudmFsdWVzKCkpLm1hcChhc3luYyAoeCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHguY2FsbGJhY2soZXZlbnQsIHNlc3Npb24pXG4gICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxuXG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yc1tpXSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycm9yc1swXVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgY3VycmVudFNlc3Npb24gYW5kIGN1cnJlbnRVc2VyXG4gICAqIHByb2Nlc3MgdG8gX3N0YXJ0QXV0b1JlZnJlc2hUb2tlbiBpZiBwb3NzaWJsZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfc2F2ZVNlc3Npb24oc2Vzc2lvbjogU2Vzc2lvbikge1xuICAgIHRoaXMuX2RlYnVnKCcjX3NhdmVTZXNzaW9uKCknLCBzZXNzaW9uKVxuICAgIC8vIF9zYXZlU2Vzc2lvbiBpcyBhbHdheXMgY2FsbGVkIHdoZW5ldmVyIGEgbmV3IHNlc3Npb24gaGFzIGJlZW4gYWNxdWlyZWRcbiAgICAvLyBzbyB3ZSBjYW4gc2FmZWx5IHN1cHByZXNzIHRoZSB3YXJuaW5nIHJldHVybmVkIGJ5IGZ1dHVyZSBnZXRTZXNzaW9uIGNhbGxzXG4gICAgdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gdHJ1ZVxuICAgIGF3YWl0IHNldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSwgc2Vzc2lvbilcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX3JlbW92ZVNlc3Npb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJyNfcmVtb3ZlU2Vzc2lvbigpJylcblxuICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSlcbiAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX09VVCcsIG51bGwpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbnkgcmVnaXN0ZXJlZCB2aXNpYmlsaXR5Y2hhbmdlIGNhbGxiYWNrLlxuICAgKlxuICAgKiB7QHNlZSAjc3RhcnRBdXRvUmVmcmVzaH1cbiAgICoge0BzZWUgI3N0b3BBdXRvUmVmcmVzaH1cbiAgICovXG4gIHByaXZhdGUgX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fZGVidWcoJyNfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpJylcblxuICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrXG4gICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrID0gbnVsbFxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChjYWxsYmFjayAmJiBpc0Jyb3dzZXIoKSAmJiB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBjYWxsYmFjaylcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdyZW1vdmluZyB2aXNpYmlsaXR5Y2hhbmdlIGNhbGxiYWNrIGZhaWxlZCcsIGUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIHByaXZhdGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rICNzdGFydEF1dG9SZWZyZXNofS4gVXNlIHRoaXNcbiAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfc3RhcnRBdXRvUmVmcmVzaCgpIHtcbiAgICBhd2FpdCB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKVxuXG4gICAgdGhpcy5fZGVidWcoJyNfc3RhcnRBdXRvUmVmcmVzaCgpJylcblxuICAgIGNvbnN0IHRpY2tlciA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCksIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OKVxuICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrZXIgPSB0aWNrZXJcblxuICAgIGlmICh0aWNrZXIgJiYgdHlwZW9mIHRpY2tlciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRpY2tlci51bnJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gdGlja2VyIGlzIGEgTm9kZUpTIFRpbWVvdXQgb2JqZWN0IHRoYXQgaGFzIGFuIGB1bnJlZmAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL3RpbWVycy5odG1sI3RpbWVvdXR1bnJlZlxuICAgICAgLy8gV2hlbiBhdXRvIHJlZnJlc2ggaXMgdXNlZCBpbiBOb2RlSlMgKGxpa2UgZm9yIHRlc3RpbmcpIHRoZVxuICAgICAgLy8gYHNldEludGVydmFsYCBpcyBwcmV2ZW50aW5nIHRoZSBwcm9jZXNzIGZyb20gYmVpbmcgbWFya2VkIGFzXG4gICAgICAvLyBmaW5pc2hlZCBhbmQgdGVzdHMgcnVuIGVuZGxlc3NseS4gVGhpcyBjYW4gYmUgcHJldmVudGVkIGJ5IGNhbGxpbmdcbiAgICAgIC8vIGB1bnJlZigpYCBvbiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICAgICAgdGlja2VyLnVucmVmKClcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgaGFzIG5vIGNvbnRleHQgb2YgRGVub1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBEZW5vLnVucmVmVGltZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIHNpbWlsYXIgbGlrZSBmb3IgTm9kZUpTLCBidXQgd2l0aCB0aGUgRGVubyBBUElcbiAgICAgIC8vIGh0dHBzOi8vZGVuby5sYW5kL2FwaUBsYXRlc3Q/dW5zdGFibGUmcz1EZW5vLnVucmVmVGltZXJcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgaGFzIG5vIGNvbnRleHQgb2YgRGVub1xuICAgICAgRGVuby51bnJlZlRpbWVyKHRpY2tlcilcbiAgICB9XG5cbiAgICAvLyBydW4gdGhlIHRpY2sgaW1tZWRpYXRlbHksIGJ1dCBpbiB0aGUgbmV4dCBwYXNzIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXRcbiAgICAvLyAjX2luaXRpYWxpemUgY2FuIGJlIGFsbG93ZWQgdG8gY29tcGxldGUgd2l0aG91dCByZWN1cnNpdmVseSB3YWl0aW5nIG9uXG4gICAgLy8gaXRzZWxmXG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG4gICAgICBhd2FpdCB0aGlzLl9hdXRvUmVmcmVzaFRva2VuVGljaygpXG4gICAgfSwgMClcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayAjc3RvcEF1dG9SZWZyZXNofS4gVXNlIHRoaXNcbiAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfc3RvcEF1dG9SZWZyZXNoKCkge1xuICAgIHRoaXMuX2RlYnVnKCcjX3N0b3BBdXRvUmVmcmVzaCgpJylcblxuICAgIGNvbnN0IHRpY2tlciA9IHRoaXMuYXV0b1JlZnJlc2hUaWNrZXJcbiAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gbnVsbFxuXG4gICAgaWYgKHRpY2tlcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aWNrZXIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBhbiBhdXRvLXJlZnJlc2ggcHJvY2VzcyBpbiB0aGUgYmFja2dyb3VuZC4gVGhlIHNlc3Npb24gaXMgY2hlY2tlZFxuICAgKiBldmVyeSBmZXcgc2Vjb25kcy4gQ2xvc2UgdG8gdGhlIHRpbWUgb2YgZXhwaXJhdGlvbiBhIHByb2Nlc3MgaXMgc3RhcnRlZCB0b1xuICAgKiByZWZyZXNoIHRoZSBzZXNzaW9uLiBJZiByZWZyZXNoaW5nIGZhaWxzIGl0IHdpbGwgYmUgcmV0cmllZCBmb3IgYXMgbG9uZyBhc1xuICAgKiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIElmIHlvdSBzZXQgdGhlIHtAbGluayBHb1RydWVDbGllbnRPcHRpb25zI2F1dG9SZWZyZXNoVG9rZW59IHlvdSBkb24ndCBuZWVkXG4gICAqIHRvIGNhbGwgdGhpcyBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgZm9yIHlvdS5cbiAgICpcbiAgICogT24gYnJvd3NlcnMgdGhlIHJlZnJlc2ggcHJvY2VzcyB3b3JrcyBvbmx5IHdoZW4gdGhlIHRhYi93aW5kb3cgaXMgaW4gdGhlXG4gICAqIGZvcmVncm91bmQgdG8gY29uc2VydmUgcmVzb3VyY2VzIGFzIHdlbGwgYXMgcHJldmVudCByYWNlIGNvbmRpdGlvbnMgYW5kXG4gICAqIGZsb29kaW5nIGF1dGggd2l0aCByZXF1ZXN0cy4gSWYgeW91IGNhbGwgdGhpcyBtZXRob2QgYW55IG1hbmFnZWRcbiAgICogdmlzaWJpbGl0eSBjaGFuZ2UgY2FsbGJhY2sgd2lsbCBiZSByZW1vdmVkIGFuZCB5b3UgbXVzdCBtYW5hZ2UgdmlzaWJpbGl0eVxuICAgKiBjaGFuZ2VzIG9uIHlvdXIgb3duLlxuICAgKlxuICAgKiBPbiBub24tYnJvd3NlciBwbGF0Zm9ybXMgdGhlIHJlZnJlc2ggcHJvY2VzcyB3b3JrcyAqY29udGludW91c2x5KiBpbiB0aGVcbiAgICogYmFja2dyb3VuZCwgd2hpY2ggbWF5IG5vdCBiZSBkZXNpcmFibGUuIFlvdSBzaG91bGQgaG9vayBpbnRvIHlvdXJcbiAgICogcGxhdGZvcm0ncyBmb3JlZ3JvdW5kIGluZGljYXRpb24gbWVjaGFuaXNtIGFuZCBjYWxsIHRoZXNlIG1ldGhvZHNcbiAgICogYXBwcm9wcmlhdGVseSB0byBjb25zZXJ2ZSByZXNvdXJjZXMuXG4gICAqXG4gICAqIHtAc2VlICNzdG9wQXV0b1JlZnJlc2h9XG4gICAqL1xuICBhc3luYyBzdGFydEF1dG9SZWZyZXNoKCkge1xuICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKVxuICAgIGF3YWl0IHRoaXMuX3N0YXJ0QXV0b1JlZnJlc2goKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIGFuIGFjdGl2ZSBhdXRvIHJlZnJlc2ggcHJvY2VzcyBydW5uaW5nIGluIHRoZSBiYWNrZ3JvdW5kIChpZiBhbnkpLlxuICAgKlxuICAgKiBJZiB5b3UgY2FsbCB0aGlzIG1ldGhvZCBhbnkgbWFuYWdlZCB2aXNpYmlsaXR5IGNoYW5nZSBjYWxsYmFjayB3aWxsIGJlXG4gICAqIHJlbW92ZWQgYW5kIHlvdSBtdXN0IG1hbmFnZSB2aXNpYmlsaXR5IGNoYW5nZXMgb24geW91ciBvd24uXG4gICAqXG4gICAqIFNlZSB7QGxpbmsgI3N0YXJ0QXV0b1JlZnJlc2h9IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBhc3luYyBzdG9wQXV0b1JlZnJlc2goKSB7XG4gICAgdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpXG4gICAgYXdhaXQgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHRoZSBhdXRvIHJlZnJlc2ggdG9rZW4gdGljay5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCkge1xuICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCAnYmVnaW4nKVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKDAsIGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBzZXNzaW9uIH0sXG4gICAgICAgICAgICAgIH0gPSByZXN1bHRcblxuICAgICAgICAgICAgICBpZiAoIXNlc3Npb24gfHwgIXNlc3Npb24ucmVmcmVzaF90b2tlbiB8fCAhc2Vzc2lvbi5leHBpcmVzX2F0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdubyBzZXNzaW9uJylcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIHNlc3Npb24gd2lsbCBleHBpcmUgaW4gdGhpcyBtYW55IHRpY2tzIChvciBoYXMgYWxyZWFkeSBleHBpcmVkIGlmIDw9IDApXG4gICAgICAgICAgICAgIGNvbnN0IGV4cGlyZXNJblRpY2tzID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAgICAgICAoc2Vzc2lvbi5leHBpcmVzX2F0ICogMTAwMCAtIG5vdykgLyBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTlxuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgICAgICAgICAgJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsXG4gICAgICAgICAgICAgICAgYGFjY2VzcyB0b2tlbiBleHBpcmVzIGluICR7ZXhwaXJlc0luVGlja3N9IHRpY2tzLCBhIHRpY2sgbGFzdHMgJHtBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTn1tcywgcmVmcmVzaCB0aHJlc2hvbGQgaXMgJHtBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTER9IHRpY2tzYFxuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgaWYgKGV4cGlyZXNJblRpY2tzIDw9IEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oc2Vzc2lvbi5yZWZyZXNoX3Rva2VuKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJ0F1dG8gcmVmcmVzaCB0aWNrIGZhaWxlZCB3aXRoIGVycm9yLiBUaGlzIGlzIGxpa2VseSBhIHRyYW5zaWVudCBlcnJvci4nLFxuICAgICAgICAgICAgICBlXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCAnZW5kJylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIGlmIChlLmlzQWNxdWlyZVRpbWVvdXQgfHwgZSBpbnN0YW5jZW9mIExvY2tBY3F1aXJlVGltZW91dEVycm9yKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdhdXRvIHJlZnJlc2ggdG9rZW4gdGljayBsb2NrIG5vdCBhdmFpbGFibGUnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIG9uIHRoZSBicm93c2VyIC8gcGxhdGZvcm0sIHdoaWNoIGluLXR1cm4gcnVuXG4gICAqIGFsZ29yaXRobXMgd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cvdGFiIGFyZSBpbiBmb3JlZ3JvdW5kLiBPbiBub24tYnJvd3NlclxuICAgKiBwbGF0Zm9ybXMgaXQgYXNzdW1lcyBhbHdheXMgZm9yZWdyb3VuZC5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgdGhpcy5fZGVidWcoJyNfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpJylcblxuICAgIGlmICghaXNCcm93c2VyKCkgfHwgIXdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbikge1xuICAgICAgICAvLyBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgdGhlIHJlZnJlc2ggdG9rZW4gdGlja2VyIHJ1bnMgYWx3YXlzXG4gICAgICAgIHRoaXMuc3RhcnRBdXRvUmVmcmVzaCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2sgPSBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2VkKGZhbHNlKVxuXG4gICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2spXG5cbiAgICAgIC8vIG5vdyBpbW1lZGlhdGVseSBjYWxsIHRoZSB2aXNiaWxpdHkgY2hhbmdlZCBjYWxsYmFjayB0byBzZXR1cCB3aXRoIHRoZVxuICAgICAgLy8gY3VycmVudCB2aXNiaWxpdHkgc3RhdGVcbiAgICAgIGF3YWl0IHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZWQodHJ1ZSkgLy8gaW5pdGlhbCBjYWxsXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ19oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlJywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHJlZ2lzdGVyZWQgd2l0aCBgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnKWAuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9vblZpc2liaWxpdHlDaGFuZ2VkKGNhbGxlZEZyb21Jbml0aWFsaXplOiBib29sZWFuKSB7XG4gICAgY29uc3QgbWV0aG9kTmFtZSA9IGAjX29uVmlzaWJpbGl0eUNoYW5nZWQoJHtjYWxsZWRGcm9tSW5pdGlhbGl6ZX0pYFxuICAgIHRoaXMuX2RlYnVnKG1ldGhvZE5hbWUsICd2aXNpYmlsaXR5U3RhdGUnLCBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUpXG5cbiAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgLy8gaW4gYnJvd3NlciBlbnZpcm9ubWVudHMgdGhlIHJlZnJlc2ggdG9rZW4gdGlja2VyIHJ1bnMgb25seSBvbiBmb2N1c2VkIHRhYnNcbiAgICAgICAgLy8gd2hpY2ggcHJldmVudHMgcmFjZSBjb25kaXRpb25zXG4gICAgICAgIHRoaXMuX3N0YXJ0QXV0b1JlZnJlc2goKVxuICAgICAgfVxuXG4gICAgICBpZiAoIWNhbGxlZEZyb21Jbml0aWFsaXplKSB7XG4gICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkLCBpLmUuIHRoZSBicm93c2VyXG4gICAgICAgIC8vIHRyYW5zaXRpb25lZCBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlIHNvIHdlIG5lZWQgdG8gc2VlIGlmIHRoZSBzZXNzaW9uXG4gICAgICAgIC8vIHNob3VsZCBiZSByZWNvdmVyZWQgaW1tZWRpYXRlbHkuLi4gYnV0IHRvIGRvIHRoYXQgd2UgbmVlZCB0byBhY3F1aXJlXG4gICAgICAgIC8vIHRoZSBsb2NrIGZpcnN0IGFzeW5jaHJvbm91c2x5XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgIT09ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICdhY3F1aXJlZCB0aGUgbG9jayB0byByZWNvdmVyIHRoZSBzZXNzaW9uLCBidXQgdGhlIGJyb3dzZXIgdmlzaWJpbGl0eVN0YXRlIGlzIG5vIGxvbmdlciB2aXNpYmxlLCBhYm9ydGluZydcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgLy8gdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCB3aGlsZSB3YWl0aW5nIGZvciB0aGUgbG9jaywgYWJvcnRcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlY292ZXIgdGhlIHNlc3Npb25cbiAgICAgICAgICBhd2FpdCB0aGlzLl9yZWNvdmVyQW5kUmVmcmVzaCgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuKSB7XG4gICAgICAgIHRoaXMuX3N0b3BBdXRvUmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgcmVsZXZhbnQgbG9naW4gVVJMIGZvciBhIHRoaXJkLXBhcnR5IHByb3ZpZGVyLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIEEgVVJMIG9yIG1vYmlsZSBhZGRyZXNzIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBhcmUgY29uZmlybWVkLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zY29wZXMgQSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiBzY29wZXMgZ3JhbnRlZCB0byB0aGUgT0F1dGggYXBwbGljYXRpb24uXG4gICAqIEBwYXJhbSBvcHRpb25zLnF1ZXJ5UGFyYW1zIEFuIG9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgY29udGFpbmluZyBxdWVyeSBwYXJhbWV0ZXJzIGdyYW50ZWQgdG8gdGhlIE9BdXRoIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0VXJsRm9yUHJvdmlkZXIoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgcHJvdmlkZXI6IFByb3ZpZGVyLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHJlZGlyZWN0VG8/OiBzdHJpbmdcbiAgICAgIHNjb3Blcz86IHN0cmluZ1xuICAgICAgcXVlcnlQYXJhbXM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gICAgICBza2lwQnJvd3NlclJlZGlyZWN0PzogYm9vbGVhblxuICAgIH1cbiAgKSB7XG4gICAgY29uc3QgdXJsUGFyYW1zOiBzdHJpbmdbXSA9IFtgcHJvdmlkZXI9JHtlbmNvZGVVUklDb21wb25lbnQocHJvdmlkZXIpfWBdXG4gICAgaWYgKG9wdGlvbnM/LnJlZGlyZWN0VG8pIHtcbiAgICAgIHVybFBhcmFtcy5wdXNoKGByZWRpcmVjdF90bz0ke2VuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLnJlZGlyZWN0VG8pfWApXG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5zY29wZXMpIHtcbiAgICAgIHVybFBhcmFtcy5wdXNoKGBzY29wZXM9JHtlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5zY29wZXMpfWApXG4gICAgfVxuICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgIGNvbnN0IFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QoXG4gICAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgICAgdGhpcy5zdG9yYWdlS2V5XG4gICAgICApXG5cbiAgICAgIGNvbnN0IGZsb3dQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGAke2VuY29kZVVSSUNvbXBvbmVudChjb2RlQ2hhbGxlbmdlKX1gLFxuICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGAke2VuY29kZVVSSUNvbXBvbmVudChjb2RlQ2hhbGxlbmdlTWV0aG9kKX1gLFxuICAgICAgfSlcbiAgICAgIHVybFBhcmFtcy5wdXNoKGZsb3dQYXJhbXMudG9TdHJpbmcoKSlcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LnF1ZXJ5UGFyYW1zKSB7XG4gICAgICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucy5xdWVyeVBhcmFtcylcbiAgICAgIHVybFBhcmFtcy5wdXNoKHF1ZXJ5LnRvU3RyaW5nKCkpXG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICB1cmxQYXJhbXMucHVzaChgc2tpcF9odHRwX3JlZGlyZWN0PSR7b3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0fWApXG4gICAgfVxuXG4gICAgcmV0dXJuIGAke3VybH0/JHt1cmxQYXJhbXMuam9pbignJicpfWBcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX3VuZW5yb2xsKHBhcmFtczogTUZBVW5lbnJvbGxQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFVbmVucm9sbFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L2ZhY3RvcnMvJHtwYXJhbXMuZmFjdG9ySWR9YCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBqd3Q6IHNlc3Npb25EYXRhPy5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNlbnJvbGx9XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9lbnJvbGwocGFyYW1zOiBNRkFFbnJvbGxUT1RQUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBRW5yb2xsVE9UUFJlc3BvbnNlPlxuICBwcml2YXRlIGFzeW5jIF9lbnJvbGwocGFyYW1zOiBNRkFFbnJvbGxQaG9uZVBhcmFtcyk6IFByb21pc2U8QXV0aE1GQUVucm9sbFBob25lUmVzcG9uc2U+XG4gIHByaXZhdGUgYXN5bmMgX2Vucm9sbChwYXJhbXM6IE1GQUVucm9sbFBhcmFtcyk6IFByb21pc2U8QXV0aE1GQUVucm9sbFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgZnJpZW5kbHlfbmFtZTogcGFyYW1zLmZyaWVuZGx5TmFtZSxcbiAgICAgICAgICBmYWN0b3JfdHlwZTogcGFyYW1zLmZhY3RvclR5cGUsXG4gICAgICAgICAgLi4uKHBhcmFtcy5mYWN0b3JUeXBlID09PSAncGhvbmUnID8geyBwaG9uZTogcGFyYW1zLnBob25lIH0gOiB7IGlzc3VlcjogcGFyYW1zLmlzc3VlciB9KSxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ZhY3RvcnNgLCB7XG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgand0OiBzZXNzaW9uRGF0YT8uc2Vzc2lvbj8uYWNjZXNzX3Rva2VuLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuZmFjdG9yVHlwZSA9PT0gJ3RvdHAnICYmIGRhdGE/LnRvdHA/LnFyX2NvZGUpIHtcbiAgICAgICAgICBkYXRhLnRvdHAucXJfY29kZSA9IGBkYXRhOmltYWdlL3N2Zyt4bWw7dXRmLTgsJHtkYXRhLnRvdHAucXJfY29kZX1gXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSN2ZXJpZnl9XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF92ZXJpZnkocGFyYW1zOiBNRkFWZXJpZnlQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFWZXJpZnlSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KFxuICAgICAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgICAgICdQT1NUJyxcbiAgICAgICAgICAgIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfS92ZXJpZnlgLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBib2R5OiB7IGNvZGU6IHBhcmFtcy5jb2RlLCBjaGFsbGVuZ2VfaWQ6IHBhcmFtcy5jaGFsbGVuZ2VJZCB9LFxuICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgIGp3dDogc2Vzc2lvbkRhdGE/LnNlc3Npb24/LmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oe1xuICAgICAgICAgICAgZXhwaXJlc19hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkgKyBkYXRhLmV4cGlyZXNfaW4sXG4gICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ01GQV9DSEFMTEVOR0VfVkVSSUZJRUQnLCBkYXRhKVxuXG4gICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgR29UcnVlTUZBQXBpI2NoYWxsZW5nZX1cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2NoYWxsZW5nZShwYXJhbXM6IE1GQUNoYWxsZW5nZVBhcmFtcyk6IFByb21pc2U8QXV0aE1GQUNoYWxsZW5nZVJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0XG4gICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KFxuICAgICAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgICAgICdQT1NUJyxcbiAgICAgICAgICAgIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfS9jaGFsbGVuZ2VgLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBib2R5OiB7IGNoYW5uZWw6IHBhcmFtcy5jaGFubmVsIH0sXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgand0OiBzZXNzaW9uRGF0YT8uc2Vzc2lvbj8uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNjaGFsbGVuZ2VBbmRWZXJpZnl9XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9jaGFsbGVuZ2VBbmRWZXJpZnkoXG4gICAgcGFyYW1zOiBNRkFDaGFsbGVuZ2VBbmRWZXJpZnlQYXJhbXNcbiAgKTogUHJvbWlzZTxBdXRoTUZBVmVyaWZ5UmVzcG9uc2U+IHtcbiAgICAvLyBib3RoIF9jaGFsbGVuZ2UgYW5kIF92ZXJpZnkgaW5kZXBlbmRlbnRseSBhY3F1aXJlIHRoZSBsb2NrLCBzbyBubyBuZWVkXG4gICAgLy8gdG8gYWNxdWlyZSBpdCBoZXJlXG5cbiAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZURhdGEsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9ID0gYXdhaXQgdGhpcy5fY2hhbGxlbmdlKHtcbiAgICAgIGZhY3RvcklkOiBwYXJhbXMuZmFjdG9ySWQsXG4gICAgfSlcbiAgICBpZiAoY2hhbGxlbmdlRXJyb3IpIHtcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3ZlcmlmeSh7XG4gICAgICBmYWN0b3JJZDogcGFyYW1zLmZhY3RvcklkLFxuICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZURhdGEuaWQsXG4gICAgICBjb2RlOiBwYXJhbXMuY29kZSxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNsaXN0RmFjdG9yc31cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2xpc3RGYWN0b3JzKCk6IFByb21pc2U8QXV0aE1GQUxpc3RGYWN0b3JzUmVzcG9uc2U+IHtcbiAgICAvLyB1c2UgI2dldFVzZXIgaW5zdGVhZCBvZiAjX2dldFVzZXIgYXMgdGhlIGZvcm1lciBhY3F1aXJlcyBhIGxvY2tcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7IHVzZXIgfSxcbiAgICAgIGVycm9yOiB1c2VyRXJyb3IsXG4gICAgfSA9IGF3YWl0IHRoaXMuZ2V0VXNlcigpXG4gICAgaWYgKHVzZXJFcnJvcikge1xuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHVzZXJFcnJvciB9XG4gICAgfVxuXG4gICAgY29uc3QgZmFjdG9ycyA9IHVzZXI/LmZhY3RvcnMgfHwgW11cbiAgICBjb25zdCB0b3RwID0gZmFjdG9ycy5maWx0ZXIoXG4gICAgICAoZmFjdG9yKSA9PiBmYWN0b3IuZmFjdG9yX3R5cGUgPT09ICd0b3RwJyAmJiBmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnXG4gICAgKVxuICAgIGNvbnN0IHBob25lID0gZmFjdG9ycy5maWx0ZXIoXG4gICAgICAoZmFjdG9yKSA9PiBmYWN0b3IuZmFjdG9yX3R5cGUgPT09ICdwaG9uZScgJiYgZmFjdG9yLnN0YXR1cyA9PT0gJ3ZlcmlmaWVkJ1xuICAgIClcblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGFsbDogZmFjdG9ycyxcbiAgICAgICAgdG90cCxcbiAgICAgICAgcGhvbmUsXG4gICAgICB9LFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWx9XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9nZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwoKTogUHJvbWlzZTxBdXRoTUZBR2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRhdGE6IHsgc2Vzc2lvbiB9LFxuICAgICAgICAgIGVycm9yOiBzZXNzaW9uRXJyb3IsXG4gICAgICAgIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB7IGN1cnJlbnRMZXZlbDogbnVsbCwgbmV4dExldmVsOiBudWxsLCBjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzOiBbXSB9LFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuX2RlY29kZUpXVChzZXNzaW9uLmFjY2Vzc190b2tlbilcblxuICAgICAgICBsZXQgY3VycmVudExldmVsOiBBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWxzIHwgbnVsbCA9IG51bGxcblxuICAgICAgICBpZiAocGF5bG9hZC5hYWwpIHtcbiAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBwYXlsb2FkLmFhbFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5leHRMZXZlbDogQXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVscyB8IG51bGwgPSBjdXJyZW50TGV2ZWxcblxuICAgICAgICBjb25zdCB2ZXJpZmllZEZhY3RvcnMgPVxuICAgICAgICAgIHNlc3Npb24udXNlci5mYWN0b3JzPy5maWx0ZXIoKGZhY3RvcjogRmFjdG9yKSA9PiBmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnKSA/PyBbXVxuXG4gICAgICAgIGlmICh2ZXJpZmllZEZhY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG5leHRMZXZlbCA9ICdhYWwyJ1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kcyA9IHBheWxvYWQuYW1yIHx8IFtdXG5cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBjdXJyZW50TGV2ZWwsIG5leHRMZXZlbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kcyB9LCBlcnJvcjogbnVsbCB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbiIsICJpbXBvcnQgR29UcnVlQ2xpZW50IGZyb20gJy4vR29UcnVlQ2xpZW50J1xuXG5jb25zdCBBdXRoQ2xpZW50ID0gR29UcnVlQ2xpZW50XG5cbmV4cG9ydCBkZWZhdWx0IEF1dGhDbGllbnRcbiIsICJpbXBvcnQgeyBBdXRoQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG5pbXBvcnQgeyBTdXBhYmFzZUF1dGhDbGllbnRPcHRpb25zIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGNsYXNzIFN1cGFiYXNlQXV0aENsaWVudCBleHRlbmRzIEF1dGhDbGllbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTdXBhYmFzZUF1dGhDbGllbnRPcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucylcbiAgfVxufVxuIiwgImltcG9ydCB7IEZ1bmN0aW9uc0NsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9mdW5jdGlvbnMtanMnXG5pbXBvcnQgeyBBdXRoQ2hhbmdlRXZlbnQgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbmltcG9ydCB7XG4gIFBvc3RncmVzdENsaWVudCxcbiAgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcbiAgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxufSBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJ1xuaW1wb3J0IHtcbiAgUmVhbHRpbWVDaGFubmVsLFxuICBSZWFsdGltZUNoYW5uZWxPcHRpb25zLFxuICBSZWFsdGltZUNsaWVudCxcbiAgUmVhbHRpbWVDbGllbnRPcHRpb25zLFxufSBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnXG5pbXBvcnQgeyBTdG9yYWdlQ2xpZW50IGFzIFN1cGFiYXNlU3RvcmFnZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdG9yYWdlLWpzJ1xuaW1wb3J0IHtcbiAgREVGQVVMVF9HTE9CQUxfT1BUSU9OUyxcbiAgREVGQVVMVF9EQl9PUFRJT05TLFxuICBERUZBVUxUX0FVVEhfT1BUSU9OUyxcbiAgREVGQVVMVF9SRUFMVElNRV9PUFRJT05TLFxufSBmcm9tICcuL2xpYi9jb25zdGFudHMnXG5pbXBvcnQgeyBmZXRjaFdpdGhBdXRoIH0gZnJvbSAnLi9saWIvZmV0Y2gnXG5pbXBvcnQgeyBzdHJpcFRyYWlsaW5nU2xhc2gsIGFwcGx5U2V0dGluZ0RlZmF1bHRzIH0gZnJvbSAnLi9saWIvaGVscGVycydcbmltcG9ydCB7IFN1cGFiYXNlQXV0aENsaWVudCB9IGZyb20gJy4vbGliL1N1cGFiYXNlQXV0aENsaWVudCdcbmltcG9ydCB7IEZldGNoLCBHZW5lcmljU2NoZW1hLCBTdXBhYmFzZUNsaWVudE9wdGlvbnMsIFN1cGFiYXNlQXV0aENsaWVudE9wdGlvbnMgfSBmcm9tICcuL2xpYi90eXBlcydcblxuLyoqXG4gKiBTdXBhYmFzZSBDbGllbnQuXG4gKlxuICogQW4gaXNvbW9ycGhpYyBKYXZhc2NyaXB0IGNsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBQb3N0Z3Jlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3VwYWJhc2VDbGllbnQ8XG4gIERhdGFiYXNlID0gYW55LFxuICBTY2hlbWFOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgRGF0YWJhc2UgPSAncHVibGljJyBleHRlbmRzIGtleW9mIERhdGFiYXNlXG4gICAgPyAncHVibGljJ1xuICAgIDogc3RyaW5nICYga2V5b2YgRGF0YWJhc2UsXG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEgPSBEYXRhYmFzZVtTY2hlbWFOYW1lXSBleHRlbmRzIEdlbmVyaWNTY2hlbWFcbiAgICA/IERhdGFiYXNlW1NjaGVtYU5hbWVdXG4gICAgOiBhbnlcbj4ge1xuICAvKipcbiAgICogU3VwYWJhc2UgQXV0aCBhbGxvd3MgeW91IHRvIGNyZWF0ZSBhbmQgbWFuYWdlIHVzZXIgc2Vzc2lvbnMgZm9yIGFjY2VzcyB0byBkYXRhIHRoYXQgaXMgc2VjdXJlZCBieSBhY2Nlc3MgcG9saWNpZXMuXG4gICAqL1xuICBhdXRoOiBTdXBhYmFzZUF1dGhDbGllbnRcbiAgcmVhbHRpbWU6IFJlYWx0aW1lQ2xpZW50XG5cbiAgcHJvdGVjdGVkIHJlYWx0aW1lVXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIGF1dGhVcmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgc3RvcmFnZVVybDogc3RyaW5nXG4gIHByb3RlY3RlZCBmdW5jdGlvbnNVcmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgcmVzdDogUG9zdGdyZXN0Q2xpZW50PERhdGFiYXNlLCBTY2hlbWFOYW1lLCBTY2hlbWE+XG4gIHByb3RlY3RlZCBzdG9yYWdlS2V5OiBzdHJpbmdcbiAgcHJvdGVjdGVkIGZldGNoPzogRmV0Y2hcbiAgcHJvdGVjdGVkIGNoYW5nZWRBY2Nlc3NUb2tlbj86IHN0cmluZ1xuICBwcm90ZWN0ZWQgYWNjZXNzVG9rZW4/OiAoKSA9PiBQcm9taXNlPHN0cmluZyB8IG51bGw+XG5cbiAgcHJvdGVjdGVkIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGNsaWVudCBmb3IgdXNlIGluIHRoZSBicm93c2VyLlxuICAgKiBAcGFyYW0gc3VwYWJhc2VVcmwgVGhlIHVuaXF1ZSBTdXBhYmFzZSBVUkwgd2hpY2ggaXMgc3VwcGxpZWQgd2hlbiB5b3UgY3JlYXRlIGEgbmV3IHByb2plY3QgaW4geW91ciBwcm9qZWN0IGRhc2hib2FyZC5cbiAgICogQHBhcmFtIHN1cGFiYXNlS2V5IFRoZSB1bmlxdWUgU3VwYWJhc2UgS2V5IHdoaWNoIGlzIHN1cHBsaWVkIHdoZW4geW91IGNyZWF0ZSBhIG5ldyBwcm9qZWN0IGluIHlvdXIgcHJvamVjdCBkYXNoYm9hcmQuXG4gICAqIEBwYXJhbSBvcHRpb25zLmRiLnNjaGVtYSBZb3UgY2FuIHN3aXRjaCBpbiBiZXR3ZWVuIHNjaGVtYXMuIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuYXV0aC5hdXRvUmVmcmVzaFRva2VuIFNldCB0byBcInRydWVcIiBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlZnJlc2ggdGhlIHRva2VuIGJlZm9yZSBleHBpcmluZy5cbiAgICogQHBhcmFtIG9wdGlvbnMuYXV0aC5wZXJzaXN0U2Vzc2lvbiBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSBzYXZlIHRoZSB1c2VyIHNlc3Npb24gaW50byBsb2NhbCBzdG9yYWdlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5hdXRoLmRldGVjdFNlc3Npb25JblVybCBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSBkZXRlY3RzIE9BdXRoIGdyYW50cyBpbiB0aGUgVVJMIGFuZCBzaWducyBpbiB0aGUgdXNlci5cbiAgICogQHBhcmFtIG9wdGlvbnMucmVhbHRpbWUgT3B0aW9ucyBwYXNzZWQgYWxvbmcgdG8gcmVhbHRpbWUtanMgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSBvcHRpb25zLmdsb2JhbC5mZXRjaCBBIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvbi5cbiAgICogQHBhcmFtIG9wdGlvbnMuZ2xvYmFsLmhlYWRlcnMgQW55IGFkZGl0aW9uYWwgaGVhZGVycyB0byBzZW5kIHdpdGggZWFjaCBuZXR3b3JrIHJlcXVlc3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgc3VwYWJhc2VVcmw6IHN0cmluZyxcbiAgICBwcm90ZWN0ZWQgc3VwYWJhc2VLZXk6IHN0cmluZyxcbiAgICBvcHRpb25zPzogU3VwYWJhc2VDbGllbnRPcHRpb25zPFNjaGVtYU5hbWU+XG4gICkge1xuICAgIGlmICghc3VwYWJhc2VVcmwpIHRocm93IG5ldyBFcnJvcignc3VwYWJhc2VVcmwgaXMgcmVxdWlyZWQuJylcbiAgICBpZiAoIXN1cGFiYXNlS2V5KSB0aHJvdyBuZXcgRXJyb3IoJ3N1cGFiYXNlS2V5IGlzIHJlcXVpcmVkLicpXG5cbiAgICBjb25zdCBfc3VwYWJhc2VVcmwgPSBzdHJpcFRyYWlsaW5nU2xhc2goc3VwYWJhc2VVcmwpXG5cbiAgICB0aGlzLnJlYWx0aW1lVXJsID0gYCR7X3N1cGFiYXNlVXJsfS9yZWFsdGltZS92MWAucmVwbGFjZSgvXmh0dHAvaSwgJ3dzJylcbiAgICB0aGlzLmF1dGhVcmwgPSBgJHtfc3VwYWJhc2VVcmx9L2F1dGgvdjFgXG4gICAgdGhpcy5zdG9yYWdlVXJsID0gYCR7X3N1cGFiYXNlVXJsfS9zdG9yYWdlL3YxYFxuICAgIHRoaXMuZnVuY3Rpb25zVXJsID0gYCR7X3N1cGFiYXNlVXJsfS9mdW5jdGlvbnMvdjFgXG5cbiAgICAvLyBkZWZhdWx0IHN0b3JhZ2Uga2V5IHVzZXMgdGhlIHN1cGFiYXNlIHByb2plY3QgcmVmIGFzIGEgbmFtZXNwYWNlXG4gICAgY29uc3QgZGVmYXVsdFN0b3JhZ2VLZXkgPSBgc2ItJHtuZXcgVVJMKHRoaXMuYXV0aFVybCkuaG9zdG5hbWUuc3BsaXQoJy4nKVswXX0tYXV0aC10b2tlbmBcbiAgICBjb25zdCBERUZBVUxUUyA9IHtcbiAgICAgIGRiOiBERUZBVUxUX0RCX09QVElPTlMsXG4gICAgICByZWFsdGltZTogREVGQVVMVF9SRUFMVElNRV9PUFRJT05TLFxuICAgICAgYXV0aDogeyAuLi5ERUZBVUxUX0FVVEhfT1BUSU9OUywgc3RvcmFnZUtleTogZGVmYXVsdFN0b3JhZ2VLZXkgfSxcbiAgICAgIGdsb2JhbDogREVGQVVMVF9HTE9CQUxfT1BUSU9OUyxcbiAgICB9XG5cbiAgICBjb25zdCBzZXR0aW5ncyA9IGFwcGx5U2V0dGluZ0RlZmF1bHRzKG9wdGlvbnMgPz8ge30sIERFRkFVTFRTKVxuXG4gICAgdGhpcy5zdG9yYWdlS2V5ID0gc2V0dGluZ3MuYXV0aC5zdG9yYWdlS2V5ID8/ICcnXG4gICAgdGhpcy5oZWFkZXJzID0gc2V0dGluZ3MuZ2xvYmFsLmhlYWRlcnMgPz8ge31cblxuICAgIGlmICghc2V0dGluZ3MuYWNjZXNzVG9rZW4pIHtcbiAgICAgIHRoaXMuYXV0aCA9IHRoaXMuX2luaXRTdXBhYmFzZUF1dGhDbGllbnQoXG4gICAgICAgIHNldHRpbmdzLmF1dGggPz8ge30sXG4gICAgICAgIHRoaXMuaGVhZGVycyxcbiAgICAgICAgc2V0dGluZ3MuZ2xvYmFsLmZldGNoXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBzZXR0aW5ncy5hY2Nlc3NUb2tlblxuXG4gICAgICB0aGlzLmF1dGggPSBuZXcgUHJveHk8U3VwYWJhc2VBdXRoQ2xpZW50Pih7fSBhcyBhbnksIHtcbiAgICAgICAgZ2V0OiAoXywgcHJvcCkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBAc3VwYWJhc2Uvc3VwYWJhc2UtanM6IFN1cGFiYXNlIENsaWVudCBpcyBjb25maWd1cmVkIHdpdGggdGhlIGFjY2Vzc1Rva2VuIG9wdGlvbiwgYWNjZXNzaW5nIHN1cGFiYXNlLmF1dGguJHtTdHJpbmcoXG4gICAgICAgICAgICAgIHByb3BcbiAgICAgICAgICAgICl9IGlzIG5vdCBwb3NzaWJsZWBcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuZmV0Y2ggPSBmZXRjaFdpdGhBdXRoKHN1cGFiYXNlS2V5LCB0aGlzLl9nZXRBY2Nlc3NUb2tlbi5iaW5kKHRoaXMpLCBzZXR0aW5ncy5nbG9iYWwuZmV0Y2gpXG4gICAgdGhpcy5yZWFsdGltZSA9IHRoaXMuX2luaXRSZWFsdGltZUNsaWVudCh7XG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBhY2Nlc3NUb2tlbjogdGhpcy5fZ2V0QWNjZXNzVG9rZW4uYmluZCh0aGlzKSxcbiAgICAgIC4uLnNldHRpbmdzLnJlYWx0aW1lLFxuICAgIH0pXG4gICAgdGhpcy5yZXN0ID0gbmV3IFBvc3RncmVzdENsaWVudChgJHtfc3VwYWJhc2VVcmx9L3Jlc3QvdjFgLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHNldHRpbmdzLmRiLnNjaGVtYSxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgIH0pXG5cbiAgICBpZiAoIXNldHRpbmdzLmFjY2Vzc1Rva2VuKSB7XG4gICAgICB0aGlzLl9saXN0ZW5Gb3JBdXRoRXZlbnRzKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3VwYWJhc2UgRnVuY3Rpb25zIGFsbG93cyB5b3UgdG8gZGVwbG95IGFuZCBpbnZva2UgZWRnZSBmdW5jdGlvbnMuXG4gICAqL1xuICBnZXQgZnVuY3Rpb25zKCk6IEZ1bmN0aW9uc0NsaWVudCB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbnNDbGllbnQodGhpcy5mdW5jdGlvbnNVcmwsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIGN1c3RvbUZldGNoOiB0aGlzLmZldGNoLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU3VwYWJhc2UgU3RvcmFnZSBhbGxvd3MgeW91IHRvIG1hbmFnZSB1c2VyLWdlbmVyYXRlZCBjb250ZW50LCBzdWNoIGFzIHBob3RvcyBvciB2aWRlb3MuXG4gICAqL1xuICBnZXQgc3RvcmFnZSgpOiBTdXBhYmFzZVN0b3JhZ2VDbGllbnQge1xuICAgIHJldHVybiBuZXcgU3VwYWJhc2VTdG9yYWdlQ2xpZW50KHRoaXMuc3RvcmFnZVVybCwgdGhpcy5oZWFkZXJzLCB0aGlzLmZldGNoKVxuICB9XG5cbiAgLy8gTk9URTogc2lnbmF0dXJlcyBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIFBvc3RncmVzdENsaWVudC5mcm9tXG4gIGZyb208XG4gICAgVGFibGVOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgU2NoZW1hWydUYWJsZXMnXSxcbiAgICBUYWJsZSBleHRlbmRzIFNjaGVtYVsnVGFibGVzJ11bVGFibGVOYW1lXVxuICA+KHJlbGF0aW9uOiBUYWJsZU5hbWUpOiBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8U2NoZW1hLCBUYWJsZSwgVGFibGVOYW1lPlxuICBmcm9tPFZpZXdOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgU2NoZW1hWydWaWV3cyddLCBWaWV3IGV4dGVuZHMgU2NoZW1hWydWaWV3cyddW1ZpZXdOYW1lXT4oXG4gICAgcmVsYXRpb246IFZpZXdOYW1lXG4gICk6IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjxTY2hlbWEsIFZpZXcsIFZpZXdOYW1lPlxuICAvKipcbiAgICogUGVyZm9ybSBhIHF1ZXJ5IG9uIGEgdGFibGUgb3IgYSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gcmVsYXRpb24gLSBUaGUgdGFibGUgb3IgdmlldyBuYW1lIHRvIHF1ZXJ5XG4gICAqL1xuICBmcm9tKHJlbGF0aW9uOiBzdHJpbmcpOiBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8U2NoZW1hLCBhbnksIGFueT4ge1xuICAgIHJldHVybiB0aGlzLnJlc3QuZnJvbShyZWxhdGlvbilcbiAgfVxuXG4gIC8vIE5PVEU6IHNpZ25hdHVyZXMgbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCBQb3N0Z3Jlc3RDbGllbnQuc2NoZW1hXG4gIC8qKlxuICAgKiBTZWxlY3QgYSBzY2hlbWEgdG8gcXVlcnkgb3IgcGVyZm9ybSBhbiBmdW5jdGlvbiAocnBjKSBjYWxsLlxuICAgKlxuICAgKiBUaGUgc2NoZW1hIG5lZWRzIHRvIGJlIG9uIHRoZSBsaXN0IG9mIGV4cG9zZWQgc2NoZW1hcyBpbnNpZGUgU3VwYWJhc2UuXG4gICAqXG4gICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIHF1ZXJ5XG4gICAqL1xuICBzY2hlbWE8RHluYW1pY1NjaGVtYSBleHRlbmRzIHN0cmluZyAmIGtleW9mIERhdGFiYXNlPihcbiAgICBzY2hlbWE6IER5bmFtaWNTY2hlbWFcbiAgKTogUG9zdGdyZXN0Q2xpZW50PFxuICAgIERhdGFiYXNlLFxuICAgIER5bmFtaWNTY2hlbWEsXG4gICAgRGF0YWJhc2VbRHluYW1pY1NjaGVtYV0gZXh0ZW5kcyBHZW5lcmljU2NoZW1hID8gRGF0YWJhc2VbRHluYW1pY1NjaGVtYV0gOiBhbnlcbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5zY2hlbWE8RHluYW1pY1NjaGVtYT4oc2NoZW1hKVxuICB9XG5cbiAgLy8gTk9URTogc2lnbmF0dXJlcyBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIFBvc3RncmVzdENsaWVudC5ycGNcbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBmdW5jdGlvbiBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gbmFtZSB0byBjYWxsXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBjYWxsXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG4gICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICogQHBhcmFtIG9wdGlvbnMuZ2V0IC0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aFxuICAgKiByZWFkLW9ubHkgYWNjZXNzIG1vZGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIHJldHVybmVkIGJ5IHRoZVxuICAgKiBmdW5jdGlvbi4gT25seSBhcHBsaWNhYmxlIGZvciBbc2V0LXJldHVybmluZ1xuICAgKiBmdW5jdGlvbnNdKGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9mdW5jdGlvbnMtc3JmLmh0bWwpLlxuICAgKlxuICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAqIGhvb2QuXG4gICAqXG4gICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAqXG4gICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICogbnVtYmVycy5cbiAgICovXG4gIHJwYzxGbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBTY2hlbWFbJ0Z1bmN0aW9ucyddLCBGbiBleHRlbmRzIFNjaGVtYVsnRnVuY3Rpb25zJ11bRm5OYW1lXT4oXG4gICAgZm46IEZuTmFtZSxcbiAgICBhcmdzOiBGblsnQXJncyddID0ge30sXG4gICAgb3B0aW9uczoge1xuICAgICAgaGVhZD86IGJvb2xlYW5cbiAgICAgIGdldD86IGJvb2xlYW5cbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfSA9IHt9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8XG4gICAgU2NoZW1hLFxuICAgIEZuWydSZXR1cm5zJ10gZXh0ZW5kcyBhbnlbXVxuICAgICAgPyBGblsnUmV0dXJucyddW251bWJlcl0gZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICAgICAgICA/IEZuWydSZXR1cm5zJ11bbnVtYmVyXVxuICAgICAgICA6IG5ldmVyXG4gICAgICA6IG5ldmVyLFxuICAgIEZuWydSZXR1cm5zJ10sXG4gICAgRm5OYW1lLFxuICAgIG51bGxcbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5ycGMoZm4sIGFyZ3MsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlYWx0aW1lIGNoYW5uZWwgd2l0aCBCcm9hZGNhc3QsIFByZXNlbmNlLCBhbmQgUG9zdGdyZXMgQ2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBSZWFsdGltZSBjaGFubmVsLlxuICAgKlxuICAgKi9cbiAgY2hhbm5lbChuYW1lOiBzdHJpbmcsIG9wdHM6IFJlYWx0aW1lQ2hhbm5lbE9wdGlvbnMgPSB7IGNvbmZpZzoge30gfSk6IFJlYWx0aW1lQ2hhbm5lbCB7XG4gICAgcmV0dXJuIHRoaXMucmVhbHRpbWUuY2hhbm5lbChuYW1lLCBvcHRzKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIFJlYWx0aW1lIGNoYW5uZWxzLlxuICAgKi9cbiAgZ2V0Q2hhbm5lbHMoKTogUmVhbHRpbWVDaGFubmVsW10ge1xuICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLmdldENoYW5uZWxzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgUmVhbHRpbWUgY2hhbm5lbCBmcm9tIFJlYWx0aW1lIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFsdGltZUNoYW5uZWx9IGNoYW5uZWwgLSBUaGUgbmFtZSBvZiB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cbiAgICpcbiAgICovXG4gIHJlbW92ZUNoYW5uZWwoY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsKTogUHJvbWlzZTwnb2snIHwgJ3RpbWVkIG91dCcgfCAnZXJyb3InPiB7XG4gICAgcmV0dXJuIHRoaXMucmVhbHRpbWUucmVtb3ZlQ2hhbm5lbChjaGFubmVsKVxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhbGwgUmVhbHRpbWUgY2hhbm5lbHMgZnJvbSBSZWFsdGltZSBjbGllbnQuXG4gICAqL1xuICByZW1vdmVBbGxDaGFubmVscygpOiBQcm9taXNlPCgnb2snIHwgJ3RpbWVkIG91dCcgfCAnZXJyb3InKVtdPiB7XG4gICAgcmV0dXJuIHRoaXMucmVhbHRpbWUucmVtb3ZlQWxsQ2hhbm5lbHMoKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0QWNjZXNzVG9rZW4oKSB7XG4gICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFjY2Vzc1Rva2VuKClcbiAgICB9XG5cbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHRoaXMuYXV0aC5nZXRTZXNzaW9uKClcblxuICAgIHJldHVybiBkYXRhLnNlc3Npb24/LmFjY2Vzc190b2tlbiA/PyBudWxsXG4gIH1cblxuICBwcml2YXRlIF9pbml0U3VwYWJhc2VBdXRoQ2xpZW50KFxuICAgIHtcbiAgICAgIGF1dG9SZWZyZXNoVG9rZW4sXG4gICAgICBwZXJzaXN0U2Vzc2lvbixcbiAgICAgIGRldGVjdFNlc3Npb25JblVybCxcbiAgICAgIHN0b3JhZ2UsXG4gICAgICBzdG9yYWdlS2V5LFxuICAgICAgZmxvd1R5cGUsXG4gICAgICBsb2NrLFxuICAgICAgZGVidWcsXG4gICAgfTogU3VwYWJhc2VBdXRoQ2xpZW50T3B0aW9ucyxcbiAgICBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgICBmZXRjaD86IEZldGNoXG4gICkge1xuICAgIGNvbnN0IGF1dGhIZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuc3VwYWJhc2VLZXl9YCxcbiAgICAgIGFwaWtleTogYCR7dGhpcy5zdXBhYmFzZUtleX1gLFxuICAgIH1cbiAgICByZXR1cm4gbmV3IFN1cGFiYXNlQXV0aENsaWVudCh7XG4gICAgICB1cmw6IHRoaXMuYXV0aFVybCxcbiAgICAgIGhlYWRlcnM6IHsgLi4uYXV0aEhlYWRlcnMsIC4uLmhlYWRlcnMgfSxcbiAgICAgIHN0b3JhZ2VLZXk6IHN0b3JhZ2VLZXksXG4gICAgICBhdXRvUmVmcmVzaFRva2VuLFxuICAgICAgcGVyc2lzdFNlc3Npb24sXG4gICAgICBkZXRlY3RTZXNzaW9uSW5VcmwsXG4gICAgICBzdG9yYWdlLFxuICAgICAgZmxvd1R5cGUsXG4gICAgICBsb2NrLFxuICAgICAgZGVidWcsXG4gICAgICBmZXRjaCxcbiAgICAgIC8vIGF1dGggY2hlY2tzIGlmIHRoZXJlIGlzIGEgY3VzdG9tIGF1dGhvcml6YWl0b24gaGVhZGVyIHVzaW5nIHRoaXMgZmxhZ1xuICAgICAgLy8gc28gaXQga25vd3Mgd2hldGhlciB0byByZXR1cm4gYW4gZXJyb3Igd2hlbiBnZXRVc2VyIGlzIGNhbGxlZCB3aXRoIG5vIHNlc3Npb25cbiAgICAgIGhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXI6ICdBdXRob3JpemF0aW9uJyBpbiB0aGlzLmhlYWRlcnMsXG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgX2luaXRSZWFsdGltZUNsaWVudChvcHRpb25zOiBSZWFsdGltZUNsaWVudE9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlYWx0aW1lQ2xpZW50KHRoaXMucmVhbHRpbWVVcmwsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBwYXJhbXM6IHsgLi4ueyBhcGlrZXk6IHRoaXMuc3VwYWJhc2VLZXkgfSwgLi4ub3B0aW9ucz8ucGFyYW1zIH0sXG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgX2xpc3RlbkZvckF1dGhFdmVudHMoKSB7XG4gICAgbGV0IGRhdGEgPSB0aGlzLmF1dGgub25BdXRoU3RhdGVDaGFuZ2UoKGV2ZW50LCBzZXNzaW9uKSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVUb2tlbkNoYW5nZWQoZXZlbnQsICdDTElFTlQnLCBzZXNzaW9uPy5hY2Nlc3NfdG9rZW4pXG4gICAgfSlcbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgcHJpdmF0ZSBfaGFuZGxlVG9rZW5DaGFuZ2VkKFxuICAgIGV2ZW50OiBBdXRoQ2hhbmdlRXZlbnQsXG4gICAgc291cmNlOiAnQ0xJRU5UJyB8ICdTVE9SQUdFJyxcbiAgICB0b2tlbj86IHN0cmluZ1xuICApIHtcbiAgICBpZiAoXG4gICAgICAoZXZlbnQgPT09ICdUT0tFTl9SRUZSRVNIRUQnIHx8IGV2ZW50ID09PSAnU0lHTkVEX0lOJykgJiZcbiAgICAgIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuICE9PSB0b2tlblxuICAgICkge1xuICAgICAgdGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gPSB0b2tlblxuICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09ICdTSUdORURfT1VUJykge1xuICAgICAgdGhpcy5yZWFsdGltZS5zZXRBdXRoKClcbiAgICAgIGlmIChzb3VyY2UgPT0gJ1NUT1JBR0UnKSB0aGlzLmF1dGguc2lnbk91dCgpXG4gICAgICB0aGlzLmNoYW5nZWRBY2Nlc3NUb2tlbiA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCBTdXBhYmFzZUNsaWVudCBmcm9tICcuL1N1cGFiYXNlQ2xpZW50J1xuaW1wb3J0IHR5cGUgeyBHZW5lcmljU2NoZW1hLCBTdXBhYmFzZUNsaWVudE9wdGlvbnMgfSBmcm9tICcuL2xpYi90eXBlcydcblxuZXhwb3J0ICogZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG5leHBvcnQgdHlwZSB7IFVzZXIgYXMgQXV0aFVzZXIsIFNlc3Npb24gYXMgQXV0aFNlc3Npb24gfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbmV4cG9ydCB7XG4gIHR5cGUgUG9zdGdyZXN0UmVzcG9uc2UsXG4gIHR5cGUgUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2UsXG4gIHR5cGUgUG9zdGdyZXN0TWF5YmVTaW5nbGVSZXNwb25zZSxcbiAgUG9zdGdyZXN0RXJyb3IsXG59IGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnXG5leHBvcnQge1xuICBGdW5jdGlvbnNIdHRwRXJyb3IsXG4gIEZ1bmN0aW9uc0ZldGNoRXJyb3IsXG4gIEZ1bmN0aW9uc1JlbGF5RXJyb3IsXG4gIEZ1bmN0aW9uc0Vycm9yLFxuICB0eXBlIEZ1bmN0aW9uSW52b2tlT3B0aW9ucyxcbiAgRnVuY3Rpb25SZWdpb24sXG59IGZyb20gJ0BzdXBhYmFzZS9mdW5jdGlvbnMtanMnXG5leHBvcnQgKiBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFN1cGFiYXNlQ2xpZW50IH0gZnJvbSAnLi9TdXBhYmFzZUNsaWVudCdcbmV4cG9ydCB0eXBlIHsgU3VwYWJhc2VDbGllbnRPcHRpb25zLCBRdWVyeVJlc3VsdCwgUXVlcnlEYXRhLCBRdWVyeUVycm9yIH0gZnJvbSAnLi9saWIvdHlwZXMnXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTdXBhYmFzZSBDbGllbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVDbGllbnQgPSA8XG4gIERhdGFiYXNlID0gYW55LFxuICBTY2hlbWFOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgRGF0YWJhc2UgPSAncHVibGljJyBleHRlbmRzIGtleW9mIERhdGFiYXNlXG4gICAgPyAncHVibGljJ1xuICAgIDogc3RyaW5nICYga2V5b2YgRGF0YWJhc2UsXG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEgPSBEYXRhYmFzZVtTY2hlbWFOYW1lXSBleHRlbmRzIEdlbmVyaWNTY2hlbWFcbiAgICA/IERhdGFiYXNlW1NjaGVtYU5hbWVdXG4gICAgOiBhbnlcbj4oXG4gIHN1cGFiYXNlVXJsOiBzdHJpbmcsXG4gIHN1cGFiYXNlS2V5OiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBTdXBhYmFzZUNsaWVudE9wdGlvbnM8U2NoZW1hTmFtZT5cbik6IFN1cGFiYXNlQ2xpZW50PERhdGFiYXNlLCBTY2hlbWFOYW1lLCBTY2hlbWE+ID0+IHtcbiAgcmV0dXJuIG5ldyBTdXBhYmFzZUNsaWVudDxEYXRhYmFzZSwgU2NoZW1hTmFtZSwgU2NoZW1hPihzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpXG59XG4iLCAiLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGNodW5raW5nIHRleHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaHVua1NldHRpbmdzIHtcblx0Y2h1bmtTaXplOiBudW1iZXI7ICAgICAgIC8vIFNpemUgb2YgZWFjaCBjaHVuayBpbiBjaGFyYWN0ZXJzXG5cdGNodW5rT3ZlcmxhcDogbnVtYmVyOyAgICAvLyBPdmVybGFwIGJldHdlZW4gY2h1bmtzXG5cdG1pbkNodW5rU2l6ZTogbnVtYmVyOyAgICAvLyBNaW5pbXVtIHNpemUgb2YgYSBjaHVua1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGV4Y2x1ZGVkIHBhdGhzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXhjbHVzaW9uU2V0dGluZ3Mge1xuXHRleGNsdWRlZEZvbGRlcnM6IHN0cmluZ1tdOyAgICAgIC8vIFVzZXItZGVmaW5lZCBmb2xkZXJzIHRvIGV4Y2x1ZGUgZnJvbSBwcm9jZXNzaW5nXG5cdGV4Y2x1ZGVkRmlsZVR5cGVzOiBzdHJpbmdbXTsgICAgLy8gVXNlci1kZWZpbmVkIGZpbGUgZXh0ZW5zaW9ucyB0byBleGNsdWRlXG5cdGV4Y2x1ZGVkRmlsZVByZWZpeGVzOiBzdHJpbmdbXTsgLy8gVXNlci1kZWZpbmVkIGZpbGUgbmFtZSBwcmVmaXhlcyB0byBleGNsdWRlXG5cdGV4Y2x1ZGVkRmlsZXM6IHN0cmluZ1tdOyAgICAgICAgLy8gVXNlci1kZWZpbmVkIHNwZWNpZmljIGZpbGVzIHRvIGV4Y2x1ZGVcblx0Ly8gU3lzdGVtLWxldmVsIGV4Y2x1c2lvbnMgdGhhdCBhcmUgYWx3YXlzIGFwcGxpZWQgYnV0IG5vdCBzaG93biBpbiBVSVxuXHRzeXN0ZW1FeGNsdWRlZEZvbGRlcnM6IHN0cmluZ1tdO1xuXHRzeXN0ZW1FeGNsdWRlZEZpbGVUeXBlczogc3RyaW5nW107XG5cdHN5c3RlbUV4Y2x1ZGVkRmlsZVByZWZpeGVzOiBzdHJpbmdbXTtcblx0c3lzdGVtRXhjbHVkZWRGaWxlczogc3RyaW5nW107XG59XG5cbi8qKlxuICogT3BlbkFJIEFQSSBzZXR0aW5nc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIE9wZW5BSVNldHRpbmdzIHtcblx0YXBpS2V5OiBzdHJpbmc7ICAgICAgICAgLy8gQVBJIGtleSBmb3IgT3BlbkFJXG5cdG1vZGVsOiBzdHJpbmc7ICAgICAgICAgIC8vIE1vZGVsIHRvIHVzZSBmb3IgZW1iZWRkaW5nc1xuXHRtYXhUb2tlbnM6IG51bWJlcjsgICAgICAvLyBNYXhpbXVtIHRva2VucyBmb3IgYSBzaW5nbGUgcmVxdWVzdFxuXHR0ZW1wZXJhdHVyZTogbnVtYmVyOyAgICAvLyBTYW1wbGluZyB0ZW1wZXJhdHVyZSBmb3IgZ2VuZXJhdGlvblxufVxuXG4vKipcbiAqIFN1cGFiYXNlIGNvbm5lY3Rpb24gc2V0dGluZ3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdXBhYmFzZVNldHRpbmdzIHtcblx0dXJsOiBzdHJpbmc7ICAgICAgICAgICAgICAvLyBTdXBhYmFzZSBwcm9qZWN0IFVSTFxuXHRhcGlLZXk6IHN0cmluZzsgICAgICAgICAgLy8gU3VwYWJhc2UgQVBJIGtleVxuXHRpbml0aWFsaXplZD86IGJvb2xlYW47ICAgIC8vIFdoZXRoZXIgZGF0YWJhc2UgaXMgaW5pdGlhbGl6ZWRcblx0bGFzdFNldHVwQXR0ZW1wdD86IG51bWJlcjsgLy8gVGltZXN0YW1wIG9mIGxhc3Qgc2V0dXAgYXR0ZW1wdFxuXHRzZXR1cFJldHJpZXM/OiBudW1iZXI7ICAgIC8vIE51bWJlciBvZiBzZXR1cCBhdHRlbXB0c1xufVxuXG4vKipcbiAqIFByb2Nlc3NpbmcgcXVldWUgc2V0dGluZ3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBRdWV1ZVNldHRpbmdzIHtcblx0bWF4Q29uY3VycmVudDogbnVtYmVyOyAgLy8gTWF4aW11bSBjb25jdXJyZW50IHRhc2tzXG5cdHJldHJ5QXR0ZW1wdHM6IG51bWJlcjsgIC8vIE51bWJlciBvZiByZXRyeSBhdHRlbXB0c1xuXHRyZXRyeURlbGF5OiBudW1iZXI7ICAgICAvLyBEZWxheSBiZXR3ZWVuIHJldHJpZXMgaW4gbWlsbGlzZWNvbmRzXG59XG5cbi8qKlxuICogRGVidWcgYW5kIGxvZ2dpbmcgc2V0dGluZ3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZWJ1Z1NldHRpbmdzIHtcblx0ZW5hYmxlRGVidWdMb2dzOiBib29sZWFuOyAgLy8gRW5hYmxlIGRldGFpbGVkIGRlYnVnIGxvZ3Ncblx0bG9nTGV2ZWw6ICdlcnJvcicgfCAnd2FybicgfCAnaW5mbycgfCAnZGVidWcnOyAgLy8gTG9nZ2luZyBsZXZlbFxuXHRsb2dUb0ZpbGU6IGJvb2xlYW47ICAgICAgICAvLyBXaGV0aGVyIHRvIGxvZyB0byBhIGZpbGVcbn1cblxuLyoqXG4gKiBEZXZpY2UgaW5mb3JtYXRpb24gZm9yIGNyb3NzLWRldmljZSBjb29yZGluYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZXZpY2VJbmZvIHtcblx0ZGV2aWNlSWQ6IHN0cmluZzsgICAgICAgICAvLyBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGRldmljZVxuXHRuYW1lOiBzdHJpbmc7ICAgICAgICAgICAgIC8vIFVzZXItZnJpZW5kbHkgbmFtZSBmb3IgdGhlIGRldmljZVxuXHRwbGF0Zm9ybTogc3RyaW5nOyAgICAgICAgIC8vIE9wZXJhdGluZyBzeXN0ZW0vcGxhdGZvcm1cblx0bGFzdFNlZW46IG51bWJlcjsgICAgICAgICAvLyBUaW1lc3RhbXAgd2hlbiBkZXZpY2Ugd2FzIGxhc3QgYWN0aXZlXG5cdGxhc3RTeW5jVGltZTogbnVtYmVyOyAgICAgLy8gVGltZXN0YW1wIG9mIGxhc3Qgc3VjY2Vzc2Z1bCBzeW5jXG59XG5cbi8qKlxuICogRW5oYW5jZWQgc3luYyBzZXR0aW5ncyB3aXRoIGNyb3NzLWRldmljZSBjb29yZGluYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTeW5jU2V0dGluZ3Mge1xuXHRzeW5jRmlsZVBhdGg6IHN0cmluZzsgICAgICAgICAgIC8vIFBhdGggdG8gdGhlIHN5bmMgZmlsZVxuXHRiYWNrdXBJbnRlcnZhbDogbnVtYmVyOyAgICAgICAgIC8vIFRpbWUgYmV0d2VlbiBiYWNrdXBzIChtcylcblx0Y2hlY2tJbnRlcnZhbDogbnVtYmVyOyAgICAgICAgICAvLyBUaW1lIGJldHdlZW4gc3luYyBjaGVja3MgKG1zKVxuXHRjaGVja0F0dGVtcHRzOiBudW1iZXI7ICAgICAgICAgIC8vIE51bWJlciBvZiBzeW5jIGNoZWNrIGF0dGVtcHRzXG5cdHRpbWVvdXQ6IG51bWJlcjsgICAgICAgICAgICAgICAgLy8gVGltZW91dCBmb3Igc3luYyBvcGVyYXRpb25zIChtcylcblx0cmVxdWlyZVN5bmM6IGJvb2xlYW47ICAgICAgICAgICAvLyBXaGV0aGVyIHN5bmMgaXMgcmVxdWlyZWQgYmVmb3JlIHN0YXJ0dXBcblx0Ly8gTmV3IGNyb3NzLWRldmljZSBzZXR0aW5nc1xuXHRkZXZpY2VJZDogc3RyaW5nOyAgICAgICAgICAgICAgIC8vIFVuaXF1ZSBpZGVudGlmaWVyIGZvciBjdXJyZW50IGRldmljZVxuXHRkZXZpY2VOYW1lOiBzdHJpbmc7ICAgICAgICAgICAgIC8vIFVzZXItY29uZmlndXJhYmxlIGRldmljZSBuYW1lXG5cdGtub3duRGV2aWNlczogRGV2aWNlSW5mb1tdOyAgICAgLy8gSW5mb3JtYXRpb24gYWJvdXQgYWxsIGtub3duIGRldmljZXNcblx0Y29ubmVjdGlvbkNoZWNrSW50ZXJ2YWw6IG51bWJlcjsgLy8gSG93IG9mdGVuIHRvIGNoZWNrIGRhdGFiYXNlIGNvbm5lY3Rpb25cblx0b2ZmbGluZVF1ZXVlRW5hYmxlZDogYm9vbGVhbjsgICAvLyBXaGV0aGVyIHRvIHF1ZXVlIG9wZXJhdGlvbnMgd2hlbiBvZmZsaW5lXG5cdGNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5OiAnbmV3ZXN0LXdpbnMnIHwgJ21hbnVhbCcgfCAna2VlcC1ib3RoJzsgLy8gSG93IHRvIGhhbmRsZSBjb25mbGljdHNcbn1cblxuLyoqXG4gKiBJbml0aWFsIHN5bmMgc2V0dGluZ3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbml0aWFsU3luY1NldHRpbmdzIHtcblx0YmF0Y2hTaXplOiBudW1iZXI7ICAgICAgICAgICAgIC8vIE51bWJlciBvZiBmaWxlcyBwZXIgYmF0Y2hcblx0bWF4Q29uY3VycmVudEJhdGNoZXM6IG51bWJlcjsgIC8vIE1heGltdW0gY29uY3VycmVudCBiYXRjaCBwcm9jZXNzaW5nXG5cdGVuYWJsZUF1dG9Jbml0aWFsU3luYzogYm9vbGVhbjsgLy8gQXV0by1zdGFydCBpbml0aWFsIHN5bmNcblx0cHJpb3JpdHlSdWxlczogUHJpb3JpdHlSdWxlW107IC8vIFJ1bGVzIGZvciBmaWxlIHByb2Nlc3NpbmcgcHJpb3JpdHlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmlvcml0eVJ1bGUge1xuXHRwYXR0ZXJuOiBzdHJpbmc7ICAgLy8gUGF0dGVybiB0byBtYXRjaCBpbiBmaWxlIHBhdGhcblx0cHJpb3JpdHk6IG51bWJlcjsgIC8vIFByaW9yaXR5IGxldmVsIChoaWdoZXIgPSBwcm9jZXNzZWQgZmlyc3QpXG59XG5cbi8qKlxuICogTmV3IHVwZGF0ZSBiZWhhdmlvciBzZXR0aW5ncyBmb3IgZmlsZSBwcm9jZXNzaW5nXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlQmVoYXZpb3JTZXR0aW5ncyB7XG4gICAgZGVib3VuY2VUaW1lOiBudW1iZXI7ICAgICAgICAgICAgICAvLyBEZWJvdW5jZSBkZWxheSBpbiBtaWxsaXNlY29uZHMgZm9yIHVwZGF0ZSBvcGVyYXRpb25zXG4gICAgcHJvY2Vzc2luZ01vZGU6ICdpbnN0YW50JyB8ICdkZWxheWVkJzsgIC8vIFdoZXRoZXIgdXBkYXRlcyBhcmUgcHJvY2Vzc2VkIGluc3RhbnRseSBvciBhZnRlciBhIGRlbGF5XG4gICAgcHJpb3JpdHlPdmVycmlkZTogbnVtYmVyOyAgICAgICAgICAvLyBEZWZhdWx0IHByb2Nlc3NpbmcgcHJpb3JpdHkgb3ZlcnJpZGUgZm9yIHVwZGF0ZSB0YXNrc1xufVxuXG4vKipcbiAqIE1haW4gc2V0dGluZ3MgaW50ZXJmYWNlIGZvciB0aGUgcGx1Z2luXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWluZE1hdHJpeFNldHRpbmdzIHtcblx0Ly8gVmF1bHQgaWRlbnRpZmljYXRpb25cblx0dmF1bHRJZDogc3RyaW5nIHwgbnVsbDsgICAgICAvLyBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHZhdWx0XG5cdGxhc3RLbm93blZhdWx0TmFtZTogc3RyaW5nOyAgLy8gTGFzdCBrbm93biBuYW1lIG9mIHRoZSB2YXVsdFxuXHQvLyBBUEkgQ29uZmlndXJhdGlvblxuXHRzdXBhYmFzZTogU3VwYWJhc2VTZXR0aW5nczsgIC8vIFN1cGFiYXNlIGNvbmZpZ3VyYXRpb25cblx0b3BlbmFpOiBPcGVuQUlTZXR0aW5nczsgICAgICAvLyBPcGVuQUkgY29uZmlndXJhdGlvblxuXHQvLyBQcm9jZXNzaW5nIHNldHRpbmdzXG5cdGNodW5raW5nOiBDaHVua1NldHRpbmdzOyAgICAgLy8gVGV4dCBjaHVua2luZyBzZXR0aW5nc1xuXHRxdWV1ZTogUXVldWVTZXR0aW5nczsgICAgICAgIC8vIFF1ZXVlIHByb2Nlc3Npbmcgc2V0dGluZ3Ncblx0Ly8gRXhjbHVzaW9uIHBhdHRlcm5zXG5cdGV4Y2x1c2lvbnM6IEV4Y2x1c2lvblNldHRpbmdzOyAgLy8gUGF0aHMgYW5kIGZpbGUgdHlwZXMgdG8gZXhjbHVkZVxuXHQvLyBEZWJ1ZyBzZXR0aW5nc1xuXHRkZWJ1ZzogRGVidWdTZXR0aW5nczsgICAgICAgIC8vIERlYnVnZ2luZyBhbmQgbG9nZ2luZyBjb25maWd1cmF0aW9uXG5cdC8vIEZlYXR1cmUgZmxhZ3Ncblx0ZW5hYmxlQXV0b1N5bmM6IGJvb2xlYW47ICAgICAgLy8gRW5hYmxlIGF1dG9tYXRpYyBzeW5jaHJvbml6YXRpb25cblx0ZW5hYmxlTm90aWZpY2F0aW9uczogYm9vbGVhbjsgLy8gU2hvdyBub3RpZmljYXRpb25zIGZvciBhY3Rpb25zXG5cdGVuYWJsZVByb2dyZXNzQmFyOiBib29sZWFuOyAgIC8vIFNob3cgYSBwcm9ncmVzcyBiYXIgZHVyaW5nIHRhc2tzXG5cdC8vIFN5bmMgc2V0dGluZ3Ncblx0c3luYzogU3luY1NldHRpbmdzO1xuXHQvLyBJbml0aWFsIHN5bmMgc2V0dGluZ3Ncblx0aW5pdGlhbFN5bmM6IEluaXRpYWxTeW5jU2V0dGluZ3M7XG5cdC8vIE5ldyB1cGRhdGUgYmVoYXZpb3Igc2V0dGluZ3Ncblx0dXBkYXRlQmVoYXZpb3I6IFVwZGF0ZUJlaGF2aW9yU2V0dGluZ3M7XG59XG5cbi8qKlxuICogRGVmYXVsdCBjaHVua2luZyBvcHRpb25zIGZvciB0ZXh0IHByb2Nlc3NpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ0hVTktJTkdfT1BUSU9OUzogQ2h1bmtTZXR0aW5ncyA9IHtcblx0Y2h1bmtTaXplOiAxMDAwLCAgICAgICAvLyBEZWZhdWx0IHNpemUgb2YgZWFjaCBjaHVuayBpbiBjaGFyYWN0ZXJzXG5cdGNodW5rT3ZlcmxhcDogMjAwLCAgICAgLy8gRGVmYXVsdCBvdmVybGFwIGJldHdlZW4gY2h1bmtzXG5cdG1pbkNodW5rU2l6ZTogMTAwLCAgICAgLy8gTWluaW11bSBjaHVuayBzaXplIHRvIGVuc3VyZSB1c2FiaWxpdHlcbn07XG5cbi8qKlxuICogRGVmYXVsdCB1cGRhdGUgYmVoYXZpb3Igc2V0dGluZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVVBEQVRFX0JFSEFWSU9SOiBVcGRhdGVCZWhhdmlvclNldHRpbmdzID0ge1xuICAgIGRlYm91bmNlVGltZTogMTAwMCwgICAgICAgICAgICAgLy8gMSBzZWNvbmQgZGVib3VuY2UgZGVsYXkgYnkgZGVmYXVsdFxuICAgIHByb2Nlc3NpbmdNb2RlOiAnaW5zdGFudCcsICAgICAgLy8gUHJvY2VzcyB1cGRhdGVzIGluc3RhbnRseSBieSBkZWZhdWx0XG4gICAgcHJpb3JpdHlPdmVycmlkZTogMSAgICAgICAgICAgICAvLyBEZWZhdWx0IHByaW9yaXR5IGxldmVsIGZvciB1cGRhdGUgb3BlcmF0aW9uc1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHVuaXF1ZSBkZXZpY2UgaWRlbnRpZmllclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVEZXZpY2VJZCgpOiBzdHJpbmcge1xuXHRyZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbn1cblxuLyoqXG4gKiBHZXQgcGxhdGZvcm0gaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYXRmb3JtSW5mbygpOiBzdHJpbmcge1xuXHRjb25zdCB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblx0aWYgKHVzZXJBZ2VudC5pbmRleE9mKCdXaW4nKSAhPT0gLTEpIHJldHVybiAnV2luZG93cyc7XG5cdGlmICh1c2VyQWdlbnQuaW5kZXhPZignTWFjJykgIT09IC0xKSByZXR1cm4gJ21hY09TJztcblx0aWYgKHVzZXJBZ2VudC5pbmRleE9mKCdpUGhvbmUnKSAhPT0gLTEgfHwgdXNlckFnZW50LmluZGV4T2YoJ2lQYWQnKSAhPT0gLTEpIHJldHVybiAnaU9TJztcblx0aWYgKHVzZXJBZ2VudC5pbmRleE9mKCdBbmRyb2lkJykgIT09IC0xKSByZXR1cm4gJ0FuZHJvaWQnO1xuXHRpZiAodXNlckFnZW50LmluZGV4T2YoJ0xpbnV4JykgIT09IC0xKSByZXR1cm4gJ0xpbnV4Jztcblx0cmV0dXJuICdVbmtub3duJztcbn1cblxuLyoqXG4gKiBTeXN0ZW0tbGV2ZWwgZXhjbHVzaW9ucyB0aGF0IGFyZSBhbHdheXMgYXBwbGllZCBidXQgbm90IHNob3duIGluIFVJXG4gKi9cbmV4cG9ydCBjb25zdCBTWVNURU1fRVhDTFVTSU9OUyA9IHtcblx0Zm9sZGVyczogW1xuXHRcdCcub2JzaWRpYW4nLCAgICAgICAgICAgLy8gT2JzaWRpYW4gY29uZmlnIGZvbGRlclxuXHRcdCcudHJhc2gnLCAgICAgICAgICAgICAgLy8gT2JzaWRpYW4gdHJhc2ggZm9sZGVyXG5cdFx0Jy5naXQnLCAgICAgICAgICAgICAgICAvLyBHaXQgZm9sZGVyIGlmIHVzZWRcblx0XHQnbm9kZV9tb2R1bGVzJyAgICAgICAgIC8vIE5vZGUgbW9kdWxlcyBpZiB1c2VkXG5cdF0sXG5cdGZpbGVUeXBlczogW1xuXHRcdCcubXAzJywgJy5qcGcnLCAnLnBuZycsICcucGRmJywgLy8gTm9uLW1hcmtkb3duIGZpbGVzXG5cdFx0Jy5leGNhbGlkcmF3JyAgICAgICAgICAgICAgICAgICAgLy8gRXhjYWxpZHJhdyBmaWxlc1xuXHRdLFxuXHRmaWxlUHJlZml4ZXM6IFsnXycsICcuJ10sICAgLy8gSGlkZGVuIGFuZCBzcGVjaWFsIGZpbGVzXG5cdGZpbGVzOiBbXG5cdFx0J19taW5kbWF0cml4c3luYy5tZCcsICAgICAgICAgICAvLyBTeW5jIGZpbGVcblx0XHQnX21pbmRtYXRyaXhzeW5jLm1kLmJhY2t1cCcgICAgIC8vIFN5bmMgYmFja3VwIGZpbGVcblx0XVxufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNldHRpbmdzIHdoZW4gcGx1Z2luIGlzIGZpcnN0IGluaXRpYWxpemVkXG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBNaW5kTWF0cml4U2V0dGluZ3MgPSB7XG5cdHZhdWx0SWQ6IG51bGwsXG5cdGxhc3RLbm93blZhdWx0TmFtZTogJycsXG5cdHN1cGFiYXNlOiB7XG5cdFx0dXJsOiAnJyxcblx0XHRhcGlLZXk6ICcnLFxuXHRcdGluaXRpYWxpemVkOiBmYWxzZSxcblx0XHRsYXN0U2V0dXBBdHRlbXB0OiAwLFxuXHRcdHNldHVwUmV0cmllczogMCxcblx0fSxcblx0b3BlbmFpOiB7XG5cdFx0YXBpS2V5OiAnJyxcblx0XHRtb2RlbDogJ3RleHQtZW1iZWRkaW5nLWFkYS0wMDInLFxuXHRcdG1heFRva2VuczogODAwMCxcblx0XHR0ZW1wZXJhdHVyZTogMC4wLFxuXHR9LFxuXHRjaHVua2luZzogeyAuLi5ERUZBVUxUX0NIVU5LSU5HX09QVElPTlMgfSxcblx0cXVldWU6IHtcblx0XHRtYXhDb25jdXJyZW50OiAzLFxuXHRcdHJldHJ5QXR0ZW1wdHM6IDMsXG5cdFx0cmV0cnlEZWxheTogMTAwMCxcblx0fSxcblx0ZXhjbHVzaW9uczoge1xuXHRcdGV4Y2x1ZGVkRm9sZGVyczogW10sXG5cdFx0ZXhjbHVkZWRGaWxlVHlwZXM6IFtdLFxuXHRcdGV4Y2x1ZGVkRmlsZVByZWZpeGVzOiBbXSxcblx0XHRleGNsdWRlZEZpbGVzOiBbXSxcblx0XHRzeXN0ZW1FeGNsdWRlZEZvbGRlcnM6IFsuLi5TWVNURU1fRVhDTFVTSU9OUy5mb2xkZXJzXSxcblx0XHRzeXN0ZW1FeGNsdWRlZEZpbGVUeXBlczogWy4uLlNZU1RFTV9FWENMVVNJT05TLmZpbGVUeXBlc10sXG5cdFx0c3lzdGVtRXhjbHVkZWRGaWxlUHJlZml4ZXM6IFsuLi5TWVNURU1fRVhDTFVTSU9OUy5maWxlUHJlZml4ZXNdLFxuXHRcdHN5c3RlbUV4Y2x1ZGVkRmlsZXM6IFsuLi5TWVNURU1fRVhDTFVTSU9OUy5maWxlc11cblx0fSxcblx0ZGVidWc6IHtcblx0XHRlbmFibGVEZWJ1Z0xvZ3M6IGZhbHNlLFxuXHRcdGxvZ0xldmVsOiAnaW5mbycsXG5cdFx0bG9nVG9GaWxlOiBmYWxzZSxcblx0fSxcblx0ZW5hYmxlQXV0b1N5bmM6IHRydWUsXG5cdGVuYWJsZU5vdGlmaWNhdGlvbnM6IHRydWUsXG5cdGVuYWJsZVByb2dyZXNzQmFyOiB0cnVlLFxuXHRzeW5jOiB7XG5cdFx0c3luY0ZpbGVQYXRoOiAnX21pbmRtYXRyaXhzeW5jLm1kJyxcblx0XHRiYWNrdXBJbnRlcnZhbDogMzYwMDAwMCwgIC8vIDEgaG91ciBpbiBtaWxsaXNlY29uZHNcblx0XHRjaGVja0ludGVydmFsOiAzMDAwMDAsICAgIC8vIDUgbWludXRlcyBpbiBtaWxsaXNlY29uZHNcblx0XHRjaGVja0F0dGVtcHRzOiAzLFxuXHRcdHRpbWVvdXQ6IDQwMDAwLFxuXHRcdHJlcXVpcmVTeW5jOiB0cnVlLFxuXHRcdGRldmljZUlkOiBnZW5lcmF0ZURldmljZUlkKCksXG5cdFx0ZGV2aWNlTmFtZTogYERldmljZS0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApfWAsXG5cdFx0a25vd25EZXZpY2VzOiBbXSxcblx0XHRjb25uZWN0aW9uQ2hlY2tJbnRlcnZhbDogNjAwMDAsIC8vIDEgbWludXRlXG5cdFx0b2ZmbGluZVF1ZXVlRW5hYmxlZDogdHJ1ZSxcblx0XHRjb25mbGljdFJlc29sdXRpb25TdHJhdGVneTogJ25ld2VzdC13aW5zJ1xuXHR9LFxuXHRpbml0aWFsU3luYzoge1xuXHRcdGJhdGNoU2l6ZTogNTAsXG5cdFx0bWF4Q29uY3VycmVudEJhdGNoZXM6IDMsXG5cdFx0ZW5hYmxlQXV0b0luaXRpYWxTeW5jOiB0cnVlLFxuXHRcdHByaW9yaXR5UnVsZXM6IFtcblx0XHRcdHsgcGF0dGVybjogJ2RhaWx5LycsIHByaW9yaXR5OiAzIH0sXG5cdFx0XHR7IHBhdHRlcm46ICdwcm9qZWN0cy8nLCBwcmlvcml0eTogMiB9LFxuXHRcdFx0eyBwYXR0ZXJuOiAnYXJjaGl2ZS8nLCBwcmlvcml0eTogMSB9XG5cdFx0XVxuXHR9LFxuXHR1cGRhdGVCZWhhdmlvcjoge1xuXHRcdC4uLkRFRkFVTFRfVVBEQVRFX0JFSEFWSU9SXG5cdH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGNvbWJpbmVkIGxpc3Qgb2YgYWxsIGV4Y2x1c2lvbnMgKHN5c3RlbSArIHVzZXIpIHVzZWQgZm9yIHByb2Nlc3NpbmcuXG4gKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW50ZXJuYWxseSBmb3IgZmlsZSBwcm9jZXNzaW5nIGFuZCBjb21iaW5lcyBib3RoIHVzZXItZGVmaW5lZCBhbmQgc3lzdGVtLWxldmVsIGV4Y2x1c2lvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxFeGNsdXNpb25zKHNldHRpbmdzOiBNaW5kTWF0cml4U2V0dGluZ3MpOiB7XG5cdGV4Y2x1ZGVkRm9sZGVyczogc3RyaW5nW10sXG5cdGV4Y2x1ZGVkRmlsZVR5cGVzOiBzdHJpbmdbXSxcblx0ZXhjbHVkZWRGaWxlUHJlZml4ZXM6IHN0cmluZ1tdLFxuXHRleGNsdWRlZEZpbGVzOiBzdHJpbmdbXVxufSB7XG5cdGNvbnN0IGV4Y2x1c2lvbnMgPSBzZXR0aW5ncy5leGNsdXNpb25zO1xuXHRyZXR1cm4ge1xuXHRcdGV4Y2x1ZGVkRm9sZGVyczogW1xuXHRcdFx0Li4uZXhjbHVzaW9ucy5zeXN0ZW1FeGNsdWRlZEZvbGRlcnMgfHwgU1lTVEVNX0VYQ0xVU0lPTlMuZm9sZGVycyxcblx0XHRcdC4uLmV4Y2x1c2lvbnMuZXhjbHVkZWRGb2xkZXJzIHx8IFtdXG5cdFx0XSxcblx0XHRleGNsdWRlZEZpbGVUeXBlczogW1xuXHRcdFx0Li4uZXhjbHVzaW9ucy5zeXN0ZW1FeGNsdWRlZEZpbGVUeXBlcyB8fCBTWVNURU1fRVhDTFVTSU9OUy5maWxlVHlwZXMsXG5cdFx0XHQuLi5leGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVR5cGVzIHx8IFtdXG5cdFx0XSxcblx0XHRleGNsdWRlZEZpbGVQcmVmaXhlczogW1xuXHRcdFx0Li4uZXhjbHVzaW9ucy5zeXN0ZW1FeGNsdWRlZEZpbGVQcmVmaXhlcyB8fCBTWVNURU1fRVhDTFVTSU9OUy5maWxlUHJlZml4ZXMsXG5cdFx0XHQuLi5leGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVByZWZpeGVzIHx8IFtdXG5cdFx0XSxcblx0XHRleGNsdWRlZEZpbGVzOiBbXG5cdFx0XHQuLi5leGNsdXNpb25zLnN5c3RlbUV4Y2x1ZGVkRmlsZXMgfHwgU1lTVEVNX0VYQ0xVU0lPTlMuZmlsZXMsXG5cdFx0XHQuLi5leGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMgfHwgW11cblx0XHRdXG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBvbmx5IHRoZSB1c2VyLWRlZmluZWQgZXhjbHVzaW9ucyAod2l0aG91dCBzeXN0ZW0tbGV2ZWwgZGVmYXVsdHMpLlxuICogVGhpcyBoZWxwZXIgY2FuIGJlIHVzZWQgaW4gVUkgY29tcG9uZW50cyB0byBlbnN1cmUgdGhhdCBzeXN0ZW0gZXhjbHVzaW9ucyByZW1haW4gaGlkZGVuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlckV4Y2x1c2lvbnMoc2V0dGluZ3M6IE1pbmRNYXRyaXhTZXR0aW5ncyk6IHtcblx0ZXhjbHVkZWRGb2xkZXJzOiBzdHJpbmdbXSxcblx0ZXhjbHVkZWRGaWxlVHlwZXM6IHN0cmluZ1tdLFxuXHRleGNsdWRlZEZpbGVQcmVmaXhlczogc3RyaW5nW10sXG5cdGV4Y2x1ZGVkRmlsZXM6IHN0cmluZ1tdXG59IHtcblx0Y29uc3QgZXhjbHVzaW9ucyA9IHNldHRpbmdzLmV4Y2x1c2lvbnM7XG5cdHJldHVybiB7XG5cdFx0ZXhjbHVkZWRGb2xkZXJzOiBleGNsdXNpb25zLmV4Y2x1ZGVkRm9sZGVycyB8fCBbXSxcblx0XHRleGNsdWRlZEZpbGVUeXBlczogZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcyB8fCBbXSxcblx0XHRleGNsdWRlZEZpbGVQcmVmaXhlczogZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVQcmVmaXhlcyB8fCBbXSxcblx0XHRleGNsdWRlZEZpbGVzOiBleGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMgfHwgW11cblx0fTtcbn1cblxuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGEgdmF1bHQgaXMgaW5pdGlhbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhdWx0SW5pdGlhbGl6ZWQoc2V0dGluZ3M6IE1pbmRNYXRyaXhTZXR0aW5ncyk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gc2V0dGluZ3MudmF1bHRJZCAhPT0gbnVsbCAmJiBzZXR0aW5ncy52YXVsdElkICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3MudmF1bHRJZCAhPT0gJyc7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGNyZWF0ZSBhIG5ldyB2YXVsdCBJRC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVmF1bHRJZCgpOiBzdHJpbmcge1xuXHRyZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbn1cbiIsICJpbXBvcnQgeyBjcmVhdGVDbGllbnQsIFN1cGFiYXNlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcbmltcG9ydCB7IERvY3VtZW50Q2h1bmssIERvY3VtZW50TWV0YWRhdGEgfSBmcm9tICcuLi9tb2RlbHMvRG9jdW1lbnRDaHVuayc7XG5pbXBvcnQgeyBNaW5kTWF0cml4U2V0dGluZ3MsIGlzVmF1bHRJbml0aWFsaXplZCB9IGZyb20gJy4uL3NldHRpbmdzL1NldHRpbmdzJztcbmltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcmVjb3JkIGZyb20gb2JzaWRpYW5fZmlsZV9zdGF0dXMuXG4gKi9cbmludGVyZmFjZSBGaWxlU3RhdHVzUmVjb3JkIHtcblx0dmF1bHRfaWQ6IHN0cmluZztcblx0ZmlsZV9wYXRoOiBzdHJpbmc7XG5cdGxhc3RfbW9kaWZpZWQ6IG51bWJlcjtcblx0bGFzdF92ZWN0b3JpemVkPzogc3RyaW5nO1xuXHRjb250ZW50X2hhc2g/OiBzdHJpbmc7XG5cdHN0YXR1cz86IHN0cmluZztcblx0dGFncz86IHN0cmluZ1tdO1xuXHRhbGlhc2VzPzogc3RyaW5nW107XG5cdGxpbmtzPzogc3RyaW5nW107XG5cdGNyZWF0ZWRfYXQ/OiBzdHJpbmc7XG5cdHVwZGF0ZWRfYXQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBTdXBhYmFzZVNlcnZpY2Uge1xuXHRwcml2YXRlIGNsaWVudDogU3VwYWJhc2VDbGllbnQgfCBudWxsO1xuXHRwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogU3VwYWJhc2VTZXJ2aWNlIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgc2V0dGluZ3M6IE1pbmRNYXRyaXhTZXR0aW5ncztcblx0cHJpdmF0ZSByZWFkb25seSBUQUJMRV9OQU1FID0gJ29ic2lkaWFuX2RvY3VtZW50cyc7XG5cdHByaXZhdGUgcmVhZG9ubHkgRklMRV9TVEFUVVNfVEFCTEUgPSAnb2JzaWRpYW5fZmlsZV9zdGF0dXMnO1xuXHQvLyBUcmFjayBkZWxldGlvbiBvcGVyYXRpb25zIGZvciBhIGdpdmVuIGZpbGUgdG8gYXZvaWQgY29uY3VycmVudCBkZWxldGVzXG5cdHByaXZhdGUgZGVsZXRlT3BlcmF0aW9uc0luUHJvZ3Jlc3M6IE1hcDxzdHJpbmcsIGJvb2xlYW4+ID0gbmV3IE1hcCgpO1xuXG5cdHByaXZhdGUgY29uc3RydWN0b3Ioc2V0dGluZ3M6IE1pbmRNYXRyaXhTZXR0aW5ncykge1xuXHRcdGlmICghc2V0dGluZ3Muc3VwYWJhc2UudXJsIHx8ICFzZXR0aW5ncy5zdXBhYmFzZS5hcGlLZXkpIHtcblx0XHRcdGNvbnNvbGUud2FybignU3VwYWJhc2UgY29uZmlndXJhdGlvbiBpcyBpbmNvbXBsZXRlLiBTdXBhYmFzZSBzZXJ2aWNlIHdpbGwgbm90IGJlIGluaXRpYWxpemVkLicpO1xuXHRcdFx0dGhpcy5jbGllbnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIWlzVmF1bHRJbml0aWFsaXplZChzZXR0aW5ncykpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVmF1bHQgaXMgbm90IGluaXRpYWxpemVkJyk7XG5cdFx0fVxuXHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcblx0XHR0aGlzLmNsaWVudCA9IGNyZWF0ZUNsaWVudChzZXR0aW5ncy5zdXBhYmFzZS51cmwsIHNldHRpbmdzLnN1cGFiYXNlLmFwaUtleSk7XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljIGFzeW5jIGdldEluc3RhbmNlKHNldHRpbmdzOiBNaW5kTWF0cml4U2V0dGluZ3MpOiBQcm9taXNlPFN1cGFiYXNlU2VydmljZSB8IG51bGw+IHtcblx0XHRpZiAoIXNldHRpbmdzLnN1cGFiYXNlLnVybCB8fCAhc2V0dGluZ3Muc3VwYWJhc2UuYXBpS2V5KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNvbmZpZ3VyYXRpb24gaXMgaW5jb21wbGV0ZS4gUmV0dXJuaW5nIG51bGwuJyk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0aWYgKCFTdXBhYmFzZVNlcnZpY2UuaW5zdGFuY2UpIHtcblx0XHRcdFN1cGFiYXNlU2VydmljZS5pbnN0YW5jZSA9IG5ldyBTdXBhYmFzZVNlcnZpY2Uoc2V0dGluZ3MpO1xuXHRcdFx0YXdhaXQgU3VwYWJhc2VTZXJ2aWNlLmluc3RhbmNlLmluaXRpYWxpemVEYXRhYmFzZSgpO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRTdXBhYmFzZVNlcnZpY2UuaW5zdGFuY2Uuc2V0dGluZ3Muc3VwYWJhc2UudXJsICE9PSBzZXR0aW5ncy5zdXBhYmFzZS51cmwgfHxcblx0XHRcdFN1cGFiYXNlU2VydmljZS5pbnN0YW5jZS5zZXR0aW5ncy5zdXBhYmFzZS5hcGlLZXkgIT09IHNldHRpbmdzLnN1cGFiYXNlLmFwaUtleSB8fFxuXHRcdFx0U3VwYWJhc2VTZXJ2aWNlLmluc3RhbmNlLnNldHRpbmdzLnZhdWx0SWQgIT09IHNldHRpbmdzLnZhdWx0SWRcblx0XHQpIHtcblx0XHRcdFN1cGFiYXNlU2VydmljZS5pbnN0YW5jZSA9IG5ldyBTdXBhYmFzZVNlcnZpY2Uoc2V0dGluZ3MpO1xuXHRcdFx0YXdhaXQgU3VwYWJhc2VTZXJ2aWNlLmluc3RhbmNlLmluaXRpYWxpemVEYXRhYmFzZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gU3VwYWJhc2VTZXJ2aWNlLmluc3RhbmNlO1xuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBpbml0aWFsaXplRGF0YWJhc2UoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdTdXBhYmFzZSBjbGllbnQgaXMgbm90IGluaXRpYWxpemVkLiBTa2lwcGluZyBkYXRhYmFzZSBpbml0aWFsaXphdGlvbi4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdG5ldyBOb3RpY2UoJ0NoZWNraW5nIGRhdGFiYXNlIGNvbm5lY3Rpb24uLi4nKTtcblx0XHRcdC8vIFZlcmlmeSBjb25uZWN0aW9uIGJ5IHNlbGVjdGluZyBmcm9tIG9ic2lkaWFuX2RvY3VtZW50c1xuXHRcdFx0Y29uc3QgeyBlcnJvcjogdGVzdEVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLlRBQkxFX05BTUUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJylcblx0XHRcdFx0LmxpbWl0KDEpO1xuXHRcdFx0aWYgKHRlc3RFcnJvciAmJiAhdGVzdEVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZDogJHt0ZXN0RXJyb3IubWVzc2FnZX1gKTtcblx0XHRcdH1cblx0XHRcdC8vIEVuc3VyZSB0aGUgZmlsZSBzdGF0dXMgdGFibGUgZXhpc3RzXG5cdFx0XHRhd2FpdCB0aGlzLmluaXRpYWxpemVGaWxlU3RhdHVzVGFibGUoKTtcblx0XHRcdG5ldyBOb3RpY2UoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gdmVyaWZpZWQnKTtcblx0XHRcdHRoaXMuc2V0dGluZ3Muc3VwYWJhc2UuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdEYXRhYmFzZSBpbml0aWFsaXphdGlvbiBlcnJvcjonLCBlcnJvcik7XG5cdFx0XHRuZXcgTm90aWNlKGBEYXRhYmFzZSBlcnJvcjogJHsoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2V9YCk7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRW5zdXJlcyB0aGF0IG9ic2lkaWFuX2ZpbGVfc3RhdHVzIHRhYmxlIGV4aXN0cy5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZUZpbGVTdGF0dXNUYWJsZSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSByZXR1cm47XG5cdFx0dHJ5IHtcblx0XHRcdC8vIENoZWNrIGlmIGZpbGUgc3RhdHVzIHRhYmxlIGV4aXN0c1xuXHRcdFx0Y29uc3QgeyBlcnJvcjogY2hlY2tFcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5GSUxFX1NUQVRVU19UQUJMRSlcblx0XHRcdFx0LnNlbGVjdCgnaWQnKVxuXHRcdFx0XHQubGltaXQoMSk7XG5cdFx0XHRpZiAoY2hlY2tFcnJvciAmJiBjaGVja0Vycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0ZpbGUgc3RhdHVzIHRhYmxlIG1pc3NpbmcuIFBsZWFzZSBjcmVhdGUgaXQgbWFudWFsbHkgb3IgcnVuIHNldHVwIFNRTC4nKTtcblx0XHRcdFx0bmV3IE5vdGljZSgnU29tZSBkYXRhYmFzZSB0YWJsZXMgYXJlIG1pc3NpbmcuIFBsdWdpbiB3aWxsIHdvcmsgd2l0aCBsaW1pdGVkIGZ1bmN0aW9uYWxpdHkuJywgNTAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnRmlsZSBzdGF0dXMgdGFibGUgZXhpc3RzIGFuZCBpcyBhY2Nlc3NpYmxlJyk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBmaWxlIHN0YXR1cyB0YWJsZTonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBpbml0aWFsaXplIGZpbGUgc3RhdHVzIHRhYmxlOiAkeyhlcnJvciBhcyBFcnJvcikubWVzc2FnZX1gKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSW5zZXJ0cyBvciB1cGRhdGVzIGRvY3VtZW50IGNodW5rcyBpbiB0aGUgb2JzaWRpYW5fZG9jdW1lbnRzIHRhYmxlIHVzaW5nIGFuIGF0b21pYyB0cmFuc2FjdGlvbi5cblx0ICogSW1wcm92ZW1lbnRzOlxuXHQgKiAtIFRyYW5zYWN0aW9uIGhhbmRsaW5nIHRvIGVuc3VyZSBhdG9taWNpdHlcblx0ICogLSBWZXJpZmljYXRpb24gb2YgZGVsZXRpb24gc3VjY2VzcyBiZWZvcmUgaW5zZXJ0aW9uXG5cdCAqIC0gUHJvcGVyIGVycm9yIGhhbmRsaW5nIGFuZCByZXRyeSBsb2dpY1xuXHQgKiAtIFByZXZlbnRzIGNvbmN1cnJlbnQgZGVsZXRpb25zIG9uIHRoZSBzYW1lIGZpbGVcblx0ICovXG5cdHB1YmxpYyBhc3luYyB1cHNlcnRDaHVua3MoY2h1bmtzOiBEb2N1bWVudENodW5rW10pOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNsaWVudCBpcyBub3QgaW5pdGlhbGl6ZWQuIFNraXBwaW5nIHVwc2VydENodW5rcy4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0Y29uc29sZS5sb2coJ05vIGNodW5rcyB0byB1cHNlcnQnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgdGhlIG9ic2lkaWFuSWQgZnJvbSB0aGUgZmlyc3QgY2h1bmtcblx0XHRjb25zdCBvYnNpZGlhbklkID0gY2h1bmtzWzBdLm1ldGFkYXRhLm9ic2lkaWFuSWQ7XG5cblx0XHQvLyBDaGVjayBpZiBhIGRlbGV0ZSBvcGVyYXRpb24gaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyBmb3IgdGhpcyBmaWxlXG5cdFx0aWYgKHRoaXMuZGVsZXRlT3BlcmF0aW9uc0luUHJvZ3Jlc3MuZ2V0KG9ic2lkaWFuSWQpKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oYERlbGV0ZSBvcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcyBmb3IgJHtvYnNpZGlhbklkfS4gUXVldWVpbmcgdXBkYXRlLmApO1xuXHRcdFx0Ly8gV2FpdCBmb3IgcHJldmlvdXMgb3BlcmF0aW9uIHRvIGNvbXBsZXRlIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuXHRcdFx0bGV0IHJldHJ5Q291bnQgPSAwO1xuXHRcdFx0Y29uc3QgbWF4UmV0cmllcyA9IDU7XG5cdFx0XHRjb25zdCBiYXNlRGVsYXkgPSA1MDA7IC8vIG1zXG5cblx0XHRcdHdoaWxlICh0aGlzLmRlbGV0ZU9wZXJhdGlvbnNJblByb2dyZXNzLmdldChvYnNpZGlhbklkKSAmJiByZXRyeUNvdW50IDwgbWF4UmV0cmllcykge1xuXHRcdFx0XHRjb25zdCBkZWxheSA9IGJhc2VEZWxheSAqIE1hdGgucG93KDIsIHJldHJ5Q291bnQpO1xuXHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcblx0XHRcdFx0cmV0cnlDb3VudCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5kZWxldGVPcGVyYXRpb25zSW5Qcm9ncmVzcy5nZXQob2JzaWRpYW5JZCkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBEZWxldGlvbiBvcGVyYXRpb24gdGltZW91dCBmb3IgJHtvYnNpZGlhbklkfWApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE1hcmsgZGVsZXRpb24gYXMgaW4gcHJvZ3Jlc3Ncblx0XHR0aGlzLmRlbGV0ZU9wZXJhdGlvbnNJblByb2dyZXNzLnNldChvYnNpZGlhbklkLCB0cnVlKTtcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBQcmVwYXJlIG5ldyBjaHVuayBkYXRhIGZvciBpbnNlcnRpb25cblx0XHRcdGNvbnN0IGNodW5rc1RvSW5zZXJ0ID0gY2h1bmtzLm1hcChjaHVuayA9PiAoe1xuXHRcdFx0XHR2YXVsdF9pZDogdGhpcy5zZXR0aW5ncy52YXVsdElkLFxuXHRcdFx0XHRvYnNpZGlhbl9pZDogY2h1bmsubWV0YWRhdGEub2JzaWRpYW5JZCxcblx0XHRcdFx0Y2h1bmtfaW5kZXg6IGNodW5rLmNodW5rSW5kZXgsXG5cdFx0XHRcdGNvbnRlbnQ6IGNodW5rLmNvbnRlbnQsXG5cdFx0XHRcdG1ldGFkYXRhOiBjaHVuay5tZXRhZGF0YSxcblx0XHRcdFx0ZW1iZWRkaW5nOiBjaHVuay5lbWJlZGRpbmcsXG5cdFx0XHRcdGxhc3RfdXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuXHRcdFx0XHR2ZWN0b3JpemVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcblx0XHRcdH0pKTtcblxuXHRcdFx0Ly8gUmVjb3JkIG9yaWdpbmFsIG51bWJlciBvZiBjaHVua3MgZm9yIHZlcmlmaWNhdGlvblxuXHRcdFx0Y29uc3QgY2h1bmtDb3VudCA9IGNodW5rc1RvSW5zZXJ0Lmxlbmd0aDtcblx0XHRcdGNvbnNvbGUubG9nKGBQcmVwYXJpbmcgdG8gdXBkYXRlICR7Y2h1bmtDb3VudH0gY2h1bmtzIGZvciBmaWxlOiAke29ic2lkaWFuSWR9YCk7XG5cblx0XHRcdC8vIEV4ZWN1dGUgZGVsZXRlIGFuZCBpbnNlcnQgb3BlcmF0aW9ucyBpbiBhIHRyYW5zYWN0aW9uLWxpa2UgbWFubmVyXG5cdFx0XHQvLyBGaXJzdCBkZWxldGUgZXhpc3RpbmcgY2h1bmtzIGZvciB0aGlzIGZpbGUuXG5cdFx0XHQvLyBNb2RpZmllZCBxdWVyeTogcmVtb3ZlIC5zZWxlY3QoJ2NvdW50JykgYW5kIHVzZSBoZWFkIGNvdW50IGluc3RlYWQuXG5cdFx0XHRjb25zdCB7IGVycm9yOiBkZWxldGVFcnJvciwgY291bnQ6IGRlbGV0ZWRDb3VudCB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5UQUJMRV9OQU1FKVxuXHRcdFx0XHQuZGVsZXRlKClcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmVxKCdvYnNpZGlhbl9pZCcsIG9ic2lkaWFuSWQpXG5cdFx0XHRcdC5zZWxlY3QoJyonLCB7IGhlYWQ6IHRydWUsIGNvdW50OiAnZXhhY3QnIH0pO1xuXHRcdFx0aWYgKGRlbGV0ZUVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGV4aXN0aW5nIGNodW5rczonLCBkZWxldGVFcnJvcik7XG5cdFx0XHRcdHRocm93IGRlbGV0ZUVycm9yO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBkZWxldGVkICR7ZGVsZXRlZENvdW50fSBleGlzdGluZyBjaHVua3MgZm9yICR7b2JzaWRpYW5JZH1gKTtcblxuXHRcdFx0Ly8gVmVyaWZ5IHRoZXJlIGFyZSBubyByZW1haW5pbmcgY2h1bmtzIChkb3VibGUtY2hlY2sgZGVsZXRpb24pXG5cdFx0XHRjb25zdCB7IGRhdGE6IHJlbWFpbmluZ0RhdGEsIGVycm9yOiBjb3VudEVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLlRBQkxFX05BTUUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuXHRcdFx0XHQuZXEoJ3ZhdWx0X2lkJywgdGhpcy5zZXR0aW5ncy52YXVsdElkKVxuXHRcdFx0XHQuZXEoJ29ic2lkaWFuX2lkJywgb2JzaWRpYW5JZCk7XG5cdFx0XHRpZiAoY291bnRFcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciB2ZXJpZnlpbmcgZGVsZXRpb246JywgY291bnRFcnJvcik7XG5cdFx0XHRcdHRocm93IGNvdW50RXJyb3I7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJlbWFpbmluZ0NvdW50ID0gcmVtYWluaW5nRGF0YT8ubGVuZ3RoIHx8IDA7XG5cdFx0XHRpZiAocmVtYWluaW5nQ291bnQgPiAwKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybihgRGVsZXRpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogJHtyZW1haW5pbmdDb3VudH0gY2h1bmtzIHN0aWxsIGV4aXN0IGZvciAke29ic2lkaWFuSWR9YCk7XG5cdFx0XHRcdC8vIEF0dGVtcHQgZGVsZXRpb24gYWdhaW4gaWYgY2h1bmtzIHJlbWFpblxuXHRcdFx0XHRjb25zdCB7IGVycm9yOiByZXRyeUVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHRcdC5mcm9tKHRoaXMuVEFCTEVfTkFNRSlcblx0XHRcdFx0XHQuZGVsZXRlKClcblx0XHRcdFx0XHQuZXEoJ3ZhdWx0X2lkJywgdGhpcy5zZXR0aW5ncy52YXVsdElkKVxuXHRcdFx0XHRcdC5lcSgnb2JzaWRpYW5faWQnLCBvYnNpZGlhbklkKTtcblx0XHRcdFx0aWYgKHJldHJ5RXJyb3IpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjbGVhbiB1cCByZW1haW5pbmcgY2h1bmtzOiAke3JldHJ5RXJyb3IubWVzc2FnZX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBOb3cgaW5zZXJ0IHRoZSBuZXcgY2h1bmtzIGluIGJhdGNoZXMgdG8gYXZvaWQgcG90ZW50aWFsIHBheWxvYWQgbGltaXRzXG5cdFx0XHRjb25zdCBCQVRDSF9TSVpFID0gNTA7IC8vIEFkanVzdCBiYXNlZCBvbiB5b3VyIFN1cGFiYXNlIGxpbWl0c1xuXHRcdFx0Y29uc3QgYmF0Y2hlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rc1RvSW5zZXJ0Lmxlbmd0aDsgaSArPSBCQVRDSF9TSVpFKSB7XG5cdFx0XHRcdGJhdGNoZXMucHVzaChjaHVua3NUb0luc2VydC5zbGljZShpLCBpICsgQkFUQ0hfU0laRSkpO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5sb2coYEluc2VydGluZyAke2NodW5rc1RvSW5zZXJ0Lmxlbmd0aH0gY2h1bmtzIGluICR7YmF0Y2hlcy5sZW5ndGh9IGJhdGNoZXNgKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGJhdGNoID0gYmF0Y2hlc1tpXTtcblx0XHRcdFx0Y29uc29sZS5sb2coYFByb2Nlc3NpbmcgYmF0Y2ggJHtpICsgMX0vJHtiYXRjaGVzLmxlbmd0aH0gd2l0aCAke2JhdGNoLmxlbmd0aH0gY2h1bmtzYCk7XG5cdFx0XHRcdGNvbnN0IHsgZXJyb3I6IGluc2VydEVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHRcdC5mcm9tKHRoaXMuVEFCTEVfTkFNRSlcblx0XHRcdFx0XHQuaW5zZXJ0KGJhdGNoKTtcblx0XHRcdFx0aWYgKGluc2VydEVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihgRXJyb3IgaW5zZXJ0aW5nIGJhdGNoICR7aSArIDF9OmAsIGluc2VydEVycm9yKTtcblx0XHRcdFx0XHQvLyBDbGVhbiB1cCBwYXJ0aWFsbHkgaW5zZXJ0ZWQgZGF0YSBvbiBlcnJvclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMuY2xlYW51cFBhcnRpYWxJbnNlcnQob2JzaWRpYW5JZCk7XG5cdFx0XHRcdFx0dGhyb3cgaW5zZXJ0RXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVmVyaWZ5IGFsbCBjaHVua3Mgd2VyZSBpbnNlcnRlZFxuXHRcdFx0Y29uc3QgeyBkYXRhOiBpbnNlcnRlZERhdGEsIGVycm9yOiB2ZXJpZnlFcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5UQUJMRV9OQU1FKVxuXHRcdFx0XHQuc2VsZWN0KCdpZCcsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmVxKCdvYnNpZGlhbl9pZCcsIG9ic2lkaWFuSWQpO1xuXHRcdFx0aWYgKHZlcmlmeUVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBpbnNlcnRpb246JywgdmVyaWZ5RXJyb3IpO1xuXHRcdFx0XHR0aHJvdyB2ZXJpZnlFcnJvcjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaW5zZXJ0ZWRDb3VudCA9IGluc2VydGVkRGF0YT8ubGVuZ3RoIHx8IDA7XG5cdFx0XHRpZiAoaW5zZXJ0ZWRDb3VudCAhPT0gY2h1bmtDb3VudCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oYEluc2VydGlvbiB2ZXJpZmljYXRpb246IEV4cGVjdGVkICR7Y2h1bmtDb3VudH0gY2h1bmtzLCBmb3VuZCAke2luc2VydGVkQ291bnR9YCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSBmaWxlIHN0YXR1cyB0byB0cmFjayB2ZWN0b3JpemF0aW9uXG5cdFx0XHRhd2FpdCB0aGlzLnVwZGF0ZUZpbGVWZWN0b3JpemF0aW9uU3RhdHVzKGNodW5rc1swXS5tZXRhZGF0YSk7XG5cdFx0XHRjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgY2h1bmtzOicsIHtcblx0XHRcdFx0bnVtYmVyT2ZDaHVua3M6IGNodW5rcy5sZW5ndGgsXG5cdFx0XHRcdHZhdWx0SWQ6IHRoaXMuc2V0dGluZ3MudmF1bHRJZCxcblx0XHRcdFx0b2JzaWRpYW5JZFxuXHRcdFx0fSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB1cHNlcnQgY2h1bmtzOicsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHQvLyBDbGVhciBkZWxldGlvbiBpbiBwcm9ncmVzcyBmbGFnXG5cdFx0XHR0aGlzLmRlbGV0ZU9wZXJhdGlvbnNJblByb2dyZXNzLnNldChvYnNpZGlhbklkLCBmYWxzZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFucyB1cCBwYXJ0aWFsIGluc2VydHMgaWYgYW4gZXJyb3Igb2NjdXJzIGR1cmluZyBiYXRjaCBpbnNlcnRpb25cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgY2xlYW51cFBhcnRpYWxJbnNlcnQob2JzaWRpYW5JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkgcmV0dXJuO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGNvbnNvbGUubG9nKGBDbGVhbmluZyB1cCBwYXJ0aWFsIGluc2VydCBmb3IgJHtvYnNpZGlhbklkfWApO1xuXHRcdFx0Y29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5UQUJMRV9OQU1FKVxuXHRcdFx0XHQuZGVsZXRlKClcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmVxKCdvYnNpZGlhbl9pZCcsIG9ic2lkaWFuSWQpO1xuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNsZWFuaW5nIHVwIHBhcnRpYWwgaW5zZXJ0OicsIGVycm9yKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgY2xlYW5lZCB1cCBwYXJ0aWFsIGluc2VydCBmb3IgJHtvYnNpZGlhbklkfWApO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGNsZWFudXBFcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGNsZWFudXAgb2YgcGFydGlhbCBpbnNlcnQ6JywgY2xlYW51cEVycm9yKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQnVsayB1cHNlcnQgbWV0aG9kIGZvciBmaWxlIHN0YXR1cyByZWNvcmRzLlxuXHQgKiBJbXByb3ZlcyBwZXJmb3JtYW5jZSBmb3IgbGFyZ2UgdmF1bHRzLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGJ1bGtVcHNlcnRGaWxlU3RhdHVzZXMoc3RhdHVzZXM6IEZpbGVTdGF0dXNSZWNvcmRbXSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHtcblx0XHRcdGNvbnNvbGUud2FybignU3VwYWJhc2UgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZC4gU2tpcHBpbmcgYnVsa1Vwc2VydEZpbGVTdGF0dXNlcy4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdGlmIChzdGF0dXNlcy5sZW5ndGggPT09IDApIHJldHVybjtcblx0XHRcdGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC51cHNlcnQoc3RhdHVzZXMsIHsgb25Db25mbGljdDogJ3ZhdWx0X2lkLGZpbGVfcGF0aCcgfSk7XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGJ1bGsgdXBzZXJ0IG9mIGZpbGUgc3RhdHVzZXM6JywgZXJyb3IpO1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH1cblx0XHRcdGNvbnNvbGUubG9nKGBCdWxrIHVwc2VydCBvZiAke3N0YXR1c2VzLmxlbmd0aH0gZmlsZSBzdGF0dXNlcyBzdWNjZXNzZnVsLmApO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gYnVsayB1cHNlcnQgZmlsZSBzdGF0dXNlczonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBvciB1cGRhdGVzIGEgcmVjb3JkIGluIHRoZSBvYnNpZGlhbl9maWxlX3N0YXR1cyB0YWJsZVxuXHQgKiB0byByZWZsZWN0IHRoZSBsYXRlc3QgZmlsZSBzdGF0dXMgdXNpbmcgcHJvdmlkZWQgbWV0YWRhdGEuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgdXBkYXRlRmlsZVZlY3Rvcml6YXRpb25TdGF0dXMobWV0YWRhdGE6IERvY3VtZW50TWV0YWRhdGEpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNsaWVudCBpcyBub3QgaW5pdGlhbGl6ZWQuIFNraXBwaW5nIHVwZGF0ZUZpbGVWZWN0b3JpemF0aW9uU3RhdHVzLicpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0Ly8gQ2hlY2sgaWYgZmlsZSBzdGF0dXMgdGFibGUgZXhpc3RzXG5cdFx0XHRjb25zdCB7IGVycm9yOiBjaGVja0Vycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLkZJTEVfU1RBVFVTX1RBQkxFKVxuXHRcdFx0XHQuc2VsZWN0KCdpZCcpXG5cdFx0XHRcdC5saW1pdCgxKTtcblx0XHRcdGlmIChjaGVja0Vycm9yICYmIGNoZWNrRXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZG9lcyBub3QgZXhpc3QnKSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZpbGUgc3RhdHVzIHRhYmxlIGRvZXMgbm90IGV4aXN0LiBTa2lwcGluZyBzdGF0dXMgdXBkYXRlLicpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBDb25zdHJ1Y3QgYSBGaWxlU3RhdHVzUmVjb3JkXG5cdFx0XHRjb25zdCBmaWxlU3RhdHVzOiBGaWxlU3RhdHVzUmVjb3JkID0ge1xuXHRcdFx0XHR2YXVsdF9pZDogdGhpcy5zZXR0aW5ncy52YXVsdElkISxcblx0XHRcdFx0ZmlsZV9wYXRoOiBtZXRhZGF0YS5vYnNpZGlhbklkLFxuXHRcdFx0XHRsYXN0X21vZGlmaWVkOiBtZXRhZGF0YS5sYXN0TW9kaWZpZWQsXG5cdFx0XHRcdGxhc3RfdmVjdG9yaXplZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuXHRcdFx0XHRjb250ZW50X2hhc2g6IG1ldGFkYXRhLmN1c3RvbU1ldGFkYXRhPy5jb250ZW50SGFzaCB8fCAnJyxcblx0XHRcdFx0c3RhdHVzOiAndmVjdG9yaXplZCcsIC8vIE1hcmsgYXMgc3VjY2Vzc2Z1bGx5IHZlY3Rvcml6ZWRcblx0XHRcdFx0dGFnczogbWV0YWRhdGEudGFncyB8fCBbXSxcblx0XHRcdFx0YWxpYXNlczogbWV0YWRhdGEuY3VzdG9tTWV0YWRhdGE/LmFsaWFzZXMgfHwgW10sXG5cdFx0XHRcdGxpbmtzOiBtZXRhZGF0YS5saW5rcyB8fCBbXSxcblx0XHRcdFx0dXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG5cdFx0XHR9O1xuXHRcdFx0Ly8gVXBzZXJ0IHRoZSByZWNvcmQgaW50byB0aGUgZmlsZSBzdGF0dXMgdGFibGVcblx0XHRcdGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC51cHNlcnQoZmlsZVN0YXR1cywgeyBvbkNvbmZsaWN0OiAndmF1bHRfaWQsZmlsZV9wYXRoJyB9KTtcblx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBmaWxlIHZlY3Rvcml6YXRpb24gc3RhdHVzOicsIGVycm9yKTtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cdFx0XHRjb25zb2xlLmxvZygnRmlsZSB2ZWN0b3JpemF0aW9uIHN0YXR1cyB1cGRhdGVkOicsIG1ldGFkYXRhLm9ic2lkaWFuSWQpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGZpbGUgdmVjdG9yaXphdGlvbiBzdGF0dXM6JywgZXJyb3IpO1xuXHRcdFx0Ly8gTm9uLWNyaXRpY2FsLCBzbyBqdXN0IGxvZyB0aGUgZXJyb3Jcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTWFya3MgYSBmaWxlIGFzIGRlbGV0ZWQgaW4gdGhlIG9ic2lkaWFuX2ZpbGVfc3RhdHVzIHRhYmxlLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIHVwZGF0ZUZpbGVTdGF0dXNPbkRlbGV0ZShmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkgcmV0dXJuO1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCB7IGVycm9yOiBjaGVja0Vycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLkZJTEVfU1RBVFVTX1RBQkxFKVxuXHRcdFx0XHQuc2VsZWN0KCdpZCcpXG5cdFx0XHRcdC5saW1pdCgxKTtcblx0XHRcdGlmIChjaGVja0Vycm9yICYmIGNoZWNrRXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZG9lcyBub3QgZXhpc3QnKSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZpbGUgc3RhdHVzIHRhYmxlIGRvZXMgbm90IGV4aXN0LiBTa2lwcGluZyBzdGF0dXMgdXBkYXRlIG9uIGRlbGV0ZS4nKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5GSUxFX1NUQVRVU19UQUJMRSlcblx0XHRcdFx0LnVwZGF0ZSh7XG5cdFx0XHRcdFx0c3RhdHVzOiAnZGVsZXRlZCcsXG5cdFx0XHRcdFx0dXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5lcSgndmF1bHRfaWQnLCB0aGlzLnNldHRpbmdzLnZhdWx0SWQpXG5cdFx0XHRcdC5lcSgnZmlsZV9wYXRoJywgZmlsZVBhdGgpO1xuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGZpbGUgc3RhdHVzIG9uIGRlbGV0ZTonLCBlcnJvcik7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGZpbGUgc3RhdHVzIG9uIGRlbGV0ZTonLCBlcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIERlbGV0ZXMgZG9jdW1lbnQgY2h1bmtzIGZvciBhIGdpdmVuIG9ic2lkaWFuSWQgZnJvbSB0aGUgb2JzaWRpYW5fZG9jdW1lbnRzIHRhYmxlLlxuXHQgKiBJbXByb3ZlZCB3aXRoIHRyYWNraW5nIG9mIG9wZXJhdGlvbiBwcm9ncmVzcyBhbmQgdmVyaWZpY2F0aW9uLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGRlbGV0ZURvY3VtZW50Q2h1bmtzKG9ic2lkaWFuSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHtcblx0XHRcdGNvbnNvbGUud2FybignU3VwYWJhc2UgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZC4gU2tpcHBpbmcgZGVsZXRlRG9jdW1lbnRDaHVua3MuJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgYSBkZWxldGlvbiBpcyBhbHJlYWR5IGluIHByb2dyZXNzIGZvciB0aGlzIGZpbGUsIHdhaXQgYnJpZWZseS5cblx0XHRpZiAodGhpcy5kZWxldGVPcGVyYXRpb25zSW5Qcm9ncmVzcy5nZXQob2JzaWRpYW5JZCkpIHtcblx0XHRcdGNvbnNvbGUud2FybihgRGVsZXRlIG9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzIGZvciAke29ic2lkaWFuSWR9LiBXYWl0aW5nLi4uYCk7XG5cdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG5cdFx0XHRpZiAodGhpcy5kZWxldGVPcGVyYXRpb25zSW5Qcm9ncmVzcy5nZXQob2JzaWRpYW5JZCkpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coYFN0aWxsIHdhaXRpbmcgZm9yIGRlbGV0ZSBvcGVyYXRpb24gb24gJHtvYnNpZGlhbklkfS4uLmApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTWFyayBkZWxldGlvbiBhcyBpbiBwcm9ncmVzcy5cblx0XHR0aGlzLmRlbGV0ZU9wZXJhdGlvbnNJblByb2dyZXNzLnNldChvYnNpZGlhbklkLCB0cnVlKTtcblxuXHRcdHRyeSB7XG5cdFx0XHRjb25zb2xlLmxvZyhgU3RhcnRpbmcgZGVsZXRpb24gb2YgY2h1bmtzIGZvciAke29ic2lkaWFuSWR9YCk7XG5cblx0XHRcdC8vIENoZWNrIGhvdyBtYW55IGNodW5rcyBleGlzdCAodXNpbmcgYSBwbGFpbiBzZWxlY3QgcXVlcnkpLlxuXHRcdFx0Y29uc3QgeyBkYXRhOiBpbml0aWFsRGF0YSwgZXJyb3I6IGluaXRpYWxDb3VudEVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLlRBQkxFX05BTUUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJylcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmVxKCdvYnNpZGlhbl9pZCcsIG9ic2lkaWFuSWQpO1xuXHRcdFx0aWYgKGluaXRpYWxDb3VudEVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGV4aXN0aW5nIGNodW5rczonLCBpbml0aWFsQ291bnRFcnJvcik7XG5cdFx0XHRcdHRocm93IGluaXRpYWxDb3VudEVycm9yO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgaW5pdGlhbENvdW50ID0gaW5pdGlhbERhdGEgPyBpbml0aWFsRGF0YS5sZW5ndGggOiAwO1xuXHRcdFx0Y29uc29sZS5sb2coYEZvdW5kICR7aW5pdGlhbENvdW50fSBjaHVua3MgdG8gZGVsZXRlIGZvciAke29ic2lkaWFuSWR9YCk7XG5cblx0XHRcdC8vIElmIHRoZXJlIGFyZSBubyBjaHVua3MsIHdlIGNhbiBkaXJlY3RseSBwdXJnZSB0aGUgZmlsZSBzdGF0dXMuXG5cdFx0XHRpZiAoaW5pdGlhbENvdW50ID09PSAwKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMucHVyZ2VGaWxlU3RhdHVzKG9ic2lkaWFuSWQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlbGV0ZSB0aGUgY2h1bmtzLlxuXHRcdFx0Y29uc3QgeyBlcnJvcjogZGVsZXRlRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuVEFCTEVfTkFNRSlcblx0XHRcdFx0LmRlbGV0ZSgpXG5cdFx0XHRcdC5lcSgndmF1bHRfaWQnLCB0aGlzLnNldHRpbmdzLnZhdWx0SWQpXG5cdFx0XHRcdC5lcSgnb2JzaWRpYW5faWQnLCBvYnNpZGlhbklkKTtcblx0XHRcdGlmIChkZWxldGVFcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBjaHVua3M6JywgZGVsZXRlRXJyb3IpO1xuXHRcdFx0XHR0aHJvdyBkZWxldGVFcnJvcjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2FpdCBicmllZmx5IHRvIGxldCB0aGUgZGVsZXRpb24gcHJvcGFnYXRlLlxuXHRcdFx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuXG5cdFx0XHQvLyBWZXJpZnkgZGVsZXRpb24gYnkgc2VsZWN0aW5nIHJlbWFpbmluZyByb3dzLlxuXHRcdFx0Y29uc3QgeyBkYXRhOiByZW1haW5pbmdEYXRhLCBlcnJvcjogdmVyaWZ5RXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuVEFCTEVfTkFNRSlcblx0XHRcdFx0LnNlbGVjdCgnaWQnKVxuXHRcdFx0XHQuZXEoJ3ZhdWx0X2lkJywgdGhpcy5zZXR0aW5ncy52YXVsdElkKVxuXHRcdFx0XHQuZXEoJ29ic2lkaWFuX2lkJywgb2JzaWRpYW5JZCk7XG5cdFx0XHRpZiAodmVyaWZ5RXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIGRlbGV0aW9uOicsIHZlcmlmeUVycm9yKTtcblx0XHRcdFx0dGhyb3cgdmVyaWZ5RXJyb3I7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCByZW1haW5pbmdDb3VudCA9IHJlbWFpbmluZ0RhdGEgPyByZW1haW5pbmdEYXRhLmxlbmd0aCA6IDA7XG5cdFx0XHRpZiAocmVtYWluaW5nQ291bnQgPiAwKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybihgRGVsZXRpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogJHtyZW1haW5pbmdDb3VudH0gY2h1bmtzIHN0aWxsIGV4aXN0IGZvciAke29ic2lkaWFuSWR9YCk7XG5cdFx0XHRcdC8vIElmIHRoZXJlIGFyZSBsZWZ0b3ZlciBjaHVua3MsIGRvIG5vdCBwdXJnZSB5ZXQuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWxsIGNodW5rcyBoYXZlIGJlZW4gcmVtb3ZlZDsgcHVyZ2UgdGhlIGZpbGUgc3RhdHVzIHJlY29yZC5cblx0XHRcdGF3YWl0IHRoaXMucHVyZ2VGaWxlU3RhdHVzKG9ic2lkaWFuSWQpO1xuXHRcdFx0Y29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBwdXJnZWQgZmlsZSBzdGF0dXMgZm9yICR7b2JzaWRpYW5JZH1gKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBjaHVua3M6JywgZXJyb3IpO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdC8vIENsZWFyIHRoZSBkZWxldGlvbi1pbi1wcm9ncmVzcyBmbGFnLlxuXHRcdFx0dGhpcy5kZWxldGVPcGVyYXRpb25zSW5Qcm9ncmVzcy5zZXQob2JzaWRpYW5JZCwgZmFsc2UpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgZG9jdW1lbnQgY2h1bmtzIGZvciBhIGdpdmVuIG9ic2lkaWFuSWQuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgZ2V0RG9jdW1lbnRDaHVua3Mob2JzaWRpYW5JZDogc3RyaW5nKTogUHJvbWlzZTxEb2N1bWVudENodW5rW10+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNsaWVudCBpcyBub3QgaW5pdGlhbGl6ZWQuIFNraXBwaW5nIGdldERvY3VtZW50Q2h1bmtzLicpO1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5UQUJMRV9OQU1FKVxuXHRcdFx0XHQuc2VsZWN0KCcqJylcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmVxKCdvYnNpZGlhbl9pZCcsIG9ic2lkaWFuSWQpXG5cdFx0XHRcdC5vcmRlcignY2h1bmtfaW5kZXgnKTtcblx0XHRcdGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRyZXR1cm4gZGF0YS5tYXAocm93ID0+ICh7XG5cdFx0XHRcdGNvbnRlbnQ6IHJvdy5jb250ZW50LFxuXHRcdFx0XHRjaHVua0luZGV4OiByb3cuY2h1bmtfaW5kZXgsXG5cdFx0XHRcdG1ldGFkYXRhOiByb3cubWV0YWRhdGEgYXMgRG9jdW1lbnRNZXRhZGF0YSxcblx0XHRcdFx0ZW1iZWRkaW5nOiByb3cuZW1iZWRkaW5nLFxuXHRcdFx0XHR2ZWN0b3JpemVkX2F0OiByb3cudmVjdG9yaXplZF9hdFxuXHRcdFx0fSkpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGNodW5rczonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGEgZmlsZSBoYXMgYmVlbiB2ZWN0b3JpemVkIGJhc2VkIG9uIHRoZSBvYnNpZGlhbl9maWxlX3N0YXR1cyB0YWJsZS5cblx0ICovXG5cdHB1YmxpYyBhc3luYyBpc0ZpbGVWZWN0b3JpemVkKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSByZXR1cm4gZmFsc2U7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZXJyb3I6IGNoZWNrRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJylcblx0XHRcdFx0LmxpbWl0KDEpO1xuXHRcdFx0aWYgKGNoZWNrRXJyb3IgJiYgY2hlY2tFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdkb2VzIG5vdCBleGlzdCcpKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignRmlsZSBzdGF0dXMgdGFibGUgZG9lcyBub3QgZXhpc3QuIEFzc3VtaW5nIGZpbGUgaXMgbm90IHZlY3Rvcml6ZWQuJyk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJ3N0YXR1cywgbGFzdF92ZWN0b3JpemVkJylcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmVxKCdmaWxlX3BhdGgnLCBmaWxlUGF0aClcblx0XHRcdFx0LnNpbmdsZSgpO1xuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdGlmIChlcnJvci5jb2RlID09PSAnUEdSU1QxMTYnKSB7XG5cdFx0XHRcdFx0Ly8gUm93IG5vdCBmb3VuZFxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkYXRhICYmIGRhdGEuc3RhdHVzID09PSAndmVjdG9yaXplZCcgJiYgISFkYXRhLmxhc3RfdmVjdG9yaXplZDtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNoZWNrIGlmIGZpbGUgaXMgdmVjdG9yaXplZDonLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgdmVjdG9yaXphdGlvbiBzdGF0dXMgb2YgYSBmaWxlIGZyb20gdGhlIGRhdGFiYXNlLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGdldEZpbGVWZWN0b3JpemF0aW9uU3RhdHVzKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHtcblx0XHRpc1ZlY3Rvcml6ZWQ6IGJvb2xlYW47XG5cdFx0bGFzdE1vZGlmaWVkOiBudW1iZXI7XG5cdFx0bGFzdFZlY3Rvcml6ZWQ6IHN0cmluZyB8IG51bGw7XG5cdFx0Y29udGVudEhhc2g6IHN0cmluZyB8IG51bGw7XG5cdFx0c3RhdHVzOiBzdHJpbmcgfCBudWxsO1xuXHR9PiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aXNWZWN0b3JpemVkOiBmYWxzZSxcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiAwLFxuXHRcdFx0XHRsYXN0VmVjdG9yaXplZDogbnVsbCxcblx0XHRcdFx0Y29udGVudEhhc2g6IG51bGwsXG5cdFx0XHRcdHN0YXR1czogbnVsbFxuXHRcdFx0fTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZXJyb3I6IGNoZWNrRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJylcblx0XHRcdFx0LmxpbWl0KDEpO1xuXHRcdFx0aWYgKGNoZWNrRXJyb3IgJiYgY2hlY2tFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdkb2VzIG5vdCBleGlzdCcpKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignRmlsZSBzdGF0dXMgdGFibGUgZG9lcyBub3QgZXhpc3QuIFJldHVybmluZyBkZWZhdWx0IHN0YXR1cy4nKTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpc1ZlY3Rvcml6ZWQ6IGZhbHNlLFxuXHRcdFx0XHRcdGxhc3RNb2RpZmllZDogMCxcblx0XHRcdFx0XHRsYXN0VmVjdG9yaXplZDogbnVsbCxcblx0XHRcdFx0XHRjb250ZW50SGFzaDogbnVsbCxcblx0XHRcdFx0XHRzdGF0dXM6IG51bGxcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJyonKVxuXHRcdFx0XHQuZXEoJ3ZhdWx0X2lkJywgdGhpcy5zZXR0aW5ncy52YXVsdElkKVxuXHRcdFx0XHQuZXEoJ2ZpbGVfcGF0aCcsIGZpbGVQYXRoKVxuXHRcdFx0XHQuc2luZ2xlKCk7XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0aWYgKGVycm9yLmNvZGUgPT09ICdQR1JTVDExNicpIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0aXNWZWN0b3JpemVkOiBmYWxzZSxcblx0XHRcdFx0XHRcdGxhc3RNb2RpZmllZDogMCxcblx0XHRcdFx0XHRcdGxhc3RWZWN0b3JpemVkOiBudWxsLFxuXHRcdFx0XHRcdFx0Y29udGVudEhhc2g6IG51bGwsXG5cdFx0XHRcdFx0XHRzdGF0dXM6IG51bGxcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aXNWZWN0b3JpemVkOiBkYXRhLnN0YXR1cyA9PT0gJ3ZlY3Rvcml6ZWQnLFxuXHRcdFx0XHRsYXN0TW9kaWZpZWQ6IGRhdGEubGFzdF9tb2RpZmllZCxcblx0XHRcdFx0bGFzdFZlY3Rvcml6ZWQ6IGRhdGEubGFzdF92ZWN0b3JpemVkLFxuXHRcdFx0XHRjb250ZW50SGFzaDogZGF0YS5jb250ZW50X2hhc2gsXG5cdFx0XHRcdHN0YXR1czogZGF0YS5zdGF0dXNcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgZmlsZSB2ZWN0b3JpemF0aW9uIHN0YXR1czonLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRpc1ZlY3Rvcml6ZWQ6IGZhbHNlLFxuXHRcdFx0XHRsYXN0TW9kaWZpZWQ6IDAsXG5cdFx0XHRcdGxhc3RWZWN0b3JpemVkOiBudWxsLFxuXHRcdFx0XHRjb250ZW50SGFzaDogbnVsbCxcblx0XHRcdFx0c3RhdHVzOiBudWxsXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIGEgZmlsZSBuZWVkcyB2ZWN0b3JpemluZyBiYXNlZCBvbiBsYXN0X21vZGlmaWVkIGFuZCBjb250ZW50X2hhc2guXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgbmVlZHNWZWN0b3JpemluZyhcblx0XHRmaWxlUGF0aDogc3RyaW5nLFxuXHRcdGxhc3RNb2RpZmllZDogbnVtYmVyLFxuXHRcdGNvbnRlbnRIYXNoOiBzdHJpbmdcblx0KTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkgcmV0dXJuIHRydWU7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZXJyb3I6IGNoZWNrRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJylcblx0XHRcdFx0LmxpbWl0KDEpO1xuXHRcdFx0aWYgKGNoZWNrRXJyb3IgJiYgY2hlY2tFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdkb2VzIG5vdCBleGlzdCcpKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignRmlsZSBzdGF0dXMgdGFibGUgZG9lcyBub3QgZXhpc3QuIEFzc3VtaW5nIGZpbGUgbmVlZHMgdmVjdG9yaXppbmcuJyk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy5nZXRGaWxlVmVjdG9yaXphdGlvblN0YXR1cyhmaWxlUGF0aCk7XG5cdFx0XHRpZiAoIXN0YXR1cy5zdGF0dXMpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7IC8vIE5vIHJlY29yZCBtZWFucyBpdCBuZWVkcyB2ZWN0b3JpemluZ1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN0YXR1cy5jb250ZW50SGFzaCAhPT0gY29udGVudEhhc2gpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7IC8vIENvbnRlbnQgaGFzIGNoYW5nZWRcblx0XHRcdH1cblx0XHRcdGlmIChsYXN0TW9kaWZpZWQgPiBzdGF0dXMubGFzdE1vZGlmaWVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlOyAvLyBGaWxlIG1vZGlmaWVkIHNpbmNlIGxhc3QgdmVjdG9yaXphdGlvblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2hlY2sgaWYgZmlsZSBuZWVkcyB2ZWN0b3JpemluZzonLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gRGVmYXVsdCB0byBuZWVkaW5nIHZlY3Rvcml6YXRpb24gb24gZXJyb3JzXG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyBhbGwgZmlsZXMgdGhhdCBkbyBub3QgaGF2ZSBhIHN0YXR1cyBvZiAndmVjdG9yaXplZCcgaW4gdGhlIGRhdGFiYXNlLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGdldEZpbGVzTmVlZGluZ1ZlY3Rvcml6YXRpb24oKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHJldHVybiBbXTtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgeyBlcnJvcjogY2hlY2tFcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5GSUxFX1NUQVRVU19UQUJMRSlcblx0XHRcdFx0LnNlbGVjdCgnaWQnKVxuXHRcdFx0XHQubGltaXQoMSk7XG5cdFx0XHRpZiAoY2hlY2tFcnJvciAmJiBjaGVja0Vycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdGaWxlIHN0YXR1cyB0YWJsZSBkb2VzIG5vdCBleGlzdC4gVW5hYmxlIHRvIGRldGVybWluZSBmaWxlcyBuZWVkaW5nIHZlY3Rvcml6YXRpb24uJyk7XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJ2ZpbGVfcGF0aCcpXG5cdFx0XHRcdC5lcSgndmF1bHRfaWQnLCB0aGlzLnNldHRpbmdzLnZhdWx0SWQpXG5cdFx0XHRcdC5ub3QoJ3N0YXR1cycsICdlcScsICd2ZWN0b3JpemVkJyk7XG5cdFx0XHRpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0cmV0dXJuIGRhdGEubWFwKChyb3c6IHsgZmlsZV9wYXRoOiBzdHJpbmcgfSkgPT4gcm93LmZpbGVfcGF0aCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgZmlsZXMgbmVlZGluZyB2ZWN0b3JpemF0aW9uOicsIGVycm9yKTtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUGVyZm9ybXMgYSBzZW1hbnRpYyBzZWFyY2ggdXNpbmcgdGhlIG1hdGNoX2RvY3VtZW50cyBmdW5jdGlvbi5cblx0ICovXG5cdHB1YmxpYyBhc3luYyBzZW1hbnRpY1NlYXJjaChlbWJlZGRpbmc6IG51bWJlcltdLCBsaW1pdDogbnVtYmVyID0gNSk6IFByb21pc2U8QXJyYXk8e1xuXHRcdGNvbnRlbnQ6IHN0cmluZztcblx0XHRtZXRhZGF0YTogRG9jdW1lbnRNZXRhZGF0YTtcblx0XHRzaW1pbGFyaXR5OiBudW1iZXI7XG5cdH0+PiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdTdXBhYmFzZSBjbGllbnQgaXMgbm90IGluaXRpYWxpemVkLiBTa2lwcGluZyBzZW1hbnRpY1NlYXJjaC4nKTtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50LnJwYygnbWF0Y2hfZG9jdW1lbnRzJywge1xuXHRcdFx0XHRxdWVyeV9lbWJlZGRpbmc6IGVtYmVkZGluZyxcblx0XHRcdFx0c2VhcmNoX3ZhdWx0X2lkOiB0aGlzLnNldHRpbmdzLnZhdWx0SWQsXG5cdFx0XHRcdG1hdGNoX2NvdW50OiBsaW1pdFxuXHRcdFx0fSk7XG5cdFx0XHRpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0cmV0dXJuIGRhdGEubWFwKChyb3c6IGFueSkgPT4gKHtcblx0XHRcdFx0Y29udGVudDogcm93LmNvbnRlbnQsXG5cdFx0XHRcdG1ldGFkYXRhOiByb3cubWV0YWRhdGEgYXMgRG9jdW1lbnRNZXRhZGF0YSxcblx0XHRcdFx0c2ltaWxhcml0eTogcm93LnNpbWlsYXJpdHlcblx0XHRcdH0pKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBlcmZvcm0gc2VtYW50aWMgc2VhcmNoOicsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUZXN0cyB0aGUgY29ubmVjdGlvbiBieSBzZWxlY3RpbmcgZnJvbSB0aGUgb2JzaWRpYW5fZG9jdW1lbnRzIHRhYmxlLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIHRlc3RDb25uZWN0aW9uKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHJldHVybiBmYWxzZTtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5UQUJMRV9OQU1FKVxuXHRcdFx0XHQuc2VsZWN0KCdpZCcpXG5cdFx0XHRcdC5saW1pdCgxKTtcblx0XHRcdC8vIENvbnNpZGVyIGNvbm5lY3RlZCBldmVuIGlmIHRhYmxlIGRvZXNuJ3QgZXhpc3Rcblx0XHRcdGlmIChlcnJvciAmJiBlcnJvci5tZXNzYWdlICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gIWVycm9yO1xuXHRcdH0gY2F0Y2gge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFsbCB1bmlxdWUgb2JzaWRpYW5faWRzIGZyb20gdGhlIG9ic2lkaWFuX2RvY3VtZW50cyB0YWJsZSBmb3IgdGhlIGN1cnJlbnQgdmF1bHQuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgZ2V0QWxsRG9jdW1lbnRJZHMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHtcblx0XHRcdGNvbnNvbGUud2FybignU3VwYWJhc2UgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZC4gU2tpcHBpbmcgZ2V0QWxsRG9jdW1lbnRJZHMuJyk7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLlRBQkxFX05BTUUpXG5cdFx0XHRcdC5zZWxlY3QoJ29ic2lkaWFuX2lkJylcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmRpc3RpbmN0KCk7XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0aWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGF0YS5tYXAoKHJvdzogYW55KSA9PiByb3cub2JzaWRpYW5faWQpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGRvY3VtZW50IElEczonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyB0aGUgcmVxdWlyZWQgZGF0YWJhc2UgdGFibGVzIGlmIG5lZWRlZCAobWFudWFsIGludm9jYXRpb24pLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGNyZWF0ZVJlcXVpcmVkVGFibGVzKCk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHN1Y2Nlc3M6IGZhbHNlLFxuXHRcdFx0XHRtZXNzYWdlOiAnU3VwYWJhc2UgY2xpZW50IG5vdCBpbml0aWFsaXplZCdcblx0XHRcdH07XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHQvLyBBdHRlbXB0IHRvIGNyZWF0ZSB0aGUgZmlsZSBzdGF0dXMgdGFibGVcblx0XHRcdGNvbnN0IGNyZWF0ZUZpbGVTdGF0dXNUYWJsZVNRTCA9IGBcblx0XHRcdFx0Q1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgJHt0aGlzLkZJTEVfU1RBVFVTX1RBQkxFfSAoXG5cdFx0XHRcdFx0aWQgQklHU0VSSUFMIFBSSU1BUlkgS0VZLFxuXHRcdFx0XHRcdHZhdWx0X2lkIFRFWFQgTk9UIE5VTEwsXG5cdFx0XHRcdFx0ZmlsZV9wYXRoIFRFWFQgTk9UIE5VTEwsXG5cdFx0XHRcdFx0bGFzdF9tb2RpZmllZCBCSUdJTlQgTk9UIE5VTEwsXG5cdFx0XHRcdFx0bGFzdF92ZWN0b3JpemVkIFRJTUVTVEFNUFRaLFxuXHRcdFx0XHRcdGNvbnRlbnRfaGFzaCBURVhULFxuXHRcdFx0XHRcdHN0YXR1cyBURVhULFxuXHRcdFx0XHRcdHRhZ3MgVEVYVFtdLFxuXHRcdFx0XHRcdGFsaWFzZXMgVEVYVFtdLFxuXHRcdFx0XHRcdGxpbmtzIFRFWFRbXSxcblx0XHRcdFx0XHRjcmVhdGVkX2F0IFRJTUVTVEFNUFRaIERFRkFVTFQgQ1VSUkVOVF9USU1FU1RBTVAsXG5cdFx0XHRcdFx0dXBkYXRlZF9hdCBUSU1FU1RBTVBUWiBERUZBVUxUIENVUlJFTlRfVElNRVNUQU1QLFxuXHRcdFx0XHRcdFVOSVFVRSh2YXVsdF9pZCwgZmlsZV9wYXRoKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRDUkVBVEUgSU5ERVggSUYgTk9UIEVYSVNUUyBpZHhfZmlsZV9zdGF0dXNfdmF1bHRfcGF0aCBPTiAke3RoaXMuRklMRV9TVEFUVVNfVEFCTEV9KHZhdWx0X2lkLCBmaWxlX3BhdGgpO1xuXHRcdFx0YDtcblx0XHRcdC8vIEV4ZWN1dGUgdmlhIGEgUG9zdGdyZXMgUlBDOyBub3RlIHRoYXQgdGhpcyBtYXkgcmVxdWlyZSBlbGV2YXRlZCBwcml2aWxlZ2VzLlxuXHRcdFx0Y29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnQucnBjKCdydW5fc3FsJywgeyBzcWw6IGNyZWF0ZUZpbGVTdGF0dXNUYWJsZVNRTCB9KTtcblx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRyZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogYENvdWxkIG5vdCBjcmVhdGUgdGFibGVzOiAke2Vycm9yLm1lc3NhZ2V9YCB9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZTogJ1RhYmxlcyBjcmVhdGVkIHN1Y2Nlc3NmdWxseScgfTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0cmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6IGBFcnJvciBjcmVhdGluZyB0YWJsZXM6ICR7KGVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWAgfTtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgdXBkYXRlRmlsZVBhdGgob2xkUGF0aDogc3RyaW5nLCBuZXdQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSByZXR1cm47XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC51cGRhdGUoeyBmaWxlX3BhdGg6IG5ld1BhdGgsIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KVxuXHRcdFx0XHQuZXEoJ3ZhdWx0X2lkJywgdGhpcy5zZXR0aW5ncy52YXVsdElkKVxuXHRcdFx0XHQuZXEoJ2ZpbGVfcGF0aCcsIG9sZFBhdGgpO1xuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5sb2coYEZpbGUgcGF0aCB1cGRhdGVkIGZyb20gJHtvbGRQYXRofSB0byAke25ld1BhdGh9YCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGZpbGUgcGF0aDonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgcHVyZ2VGaWxlU3RhdHVzKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNsaWVudCBpcyBub3QgaW5pdGlhbGl6ZWQuIFNraXBwaW5nIHB1cmdlRmlsZVN0YXR1cy4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5kZWxldGUoKVxuXHRcdFx0XHQuZXEoJ3ZhdWx0X2lkJywgdGhpcy5zZXR0aW5ncy52YXVsdElkKVxuXHRcdFx0XHQuZXEoJ2ZpbGVfcGF0aCcsIGZpbGVQYXRoKTtcblx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBwdXJnaW5nIGZpbGUgc3RhdHVzOicsIGVycm9yKTtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cdFx0XHRjb25zb2xlLmxvZyhgUHVyZ2VkIGZpbGUgc3RhdHVzIHJlY29yZCBmb3IgJHtmaWxlUGF0aH1gKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHB1cmdlIGZpbGUgc3RhdHVzIHJlY29yZDonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxufVxuIiwgImltcG9ydCB0eXBlIHsgRm9ybWF0IH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0X2Zvcm1hdDogRm9ybWF0ID0gJ1JGQzM5ODYnO1xuZXhwb3J0IGNvbnN0IGZvcm1hdHRlcnM6IFJlY29yZDxGb3JtYXQsIChzdHI6IFByb3BlcnR5S2V5KSA9PiBzdHJpbmc+ID0ge1xuICBSRkMxNzM4OiAodjogUHJvcGVydHlLZXkpID0+IFN0cmluZyh2KS5yZXBsYWNlKC8lMjAvZywgJysnKSxcbiAgUkZDMzk4NjogKHY6IFByb3BlcnR5S2V5KSA9PiBTdHJpbmcodiksXG59O1xuZXhwb3J0IGNvbnN0IFJGQzE3MzggPSAnUkZDMTczOCc7XG5leHBvcnQgY29uc3QgUkZDMzk4NiA9ICdSRkMzOTg2JztcbiIsICJpbXBvcnQgeyBSRkMxNzM4IH0gZnJvbSAnLi9mb3JtYXRzJztcbmltcG9ydCB0eXBlIHsgRGVmYXVsdEVuY29kZXIsIEZvcm1hdCB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuY29uc3QgaXNfYXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5jb25zdCBoZXhfdGFibGUgPSAoKCkgPT4ge1xuICBjb25zdCBhcnJheSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgYXJyYXkucHVzaCgnJScgKyAoKGkgPCAxNiA/ICcwJyA6ICcnKSArIGkudG9TdHJpbmcoMTYpKS50b1VwcGVyQ2FzZSgpKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGNvbXBhY3RfcXVldWU8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4+KHF1ZXVlOiBBcnJheTx7IG9iajogVDsgcHJvcDogc3RyaW5nIH0+KSB7XG4gIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgaXRlbSA9IHF1ZXVlLnBvcCgpO1xuICAgIGlmICghaXRlbSkgY29udGludWU7XG5cbiAgICBjb25zdCBvYmogPSBpdGVtLm9ialtpdGVtLnByb3BdO1xuXG4gICAgaWYgKGlzX2FycmF5KG9iaikpIHtcbiAgICAgIGNvbnN0IGNvbXBhY3RlZDogdW5rbm93bltdID0gW107XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb2JqLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqW2pdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbXBhY3RlZC5wdXNoKG9ialtqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaXRlbS5vYmpbaXRlbS5wcm9wXSA9IGNvbXBhY3RlZDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXJyYXlfdG9fb2JqZWN0KHNvdXJjZTogYW55W10sIG9wdGlvbnM6IHsgcGxhaW5PYmplY3RzOiBib29sZWFuIH0pIHtcbiAgY29uc3Qgb2JqID0gb3B0aW9ucyAmJiBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9ialtpXSA9IHNvdXJjZVtpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2UoXG4gIHRhcmdldDogYW55LFxuICBzb3VyY2U6IGFueSxcbiAgb3B0aW9uczogeyBwbGFpbk9iamVjdHM/OiBib29sZWFuOyBhbGxvd1Byb3RvdHlwZXM/OiBib29sZWFuIH0gPSB7fSxcbikge1xuICBpZiAoIXNvdXJjZSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoaXNfYXJyYXkodGFyZ2V0KSkge1xuICAgICAgdGFyZ2V0LnB1c2goc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKFxuICAgICAgICAob3B0aW9ucyAmJiAob3B0aW9ucy5wbGFpbk9iamVjdHMgfHwgb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpKSB8fFxuICAgICAgICAhaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgc291cmNlKVxuICAgICAgKSB7XG4gICAgICAgIHRhcmdldFtzb3VyY2VdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFt0YXJnZXQsIHNvdXJjZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGlmICghdGFyZ2V0IHx8IHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIFt0YXJnZXRdLmNvbmNhdChzb3VyY2UpO1xuICB9XG5cbiAgbGV0IG1lcmdlVGFyZ2V0ID0gdGFyZ2V0O1xuICBpZiAoaXNfYXJyYXkodGFyZ2V0KSAmJiAhaXNfYXJyYXkoc291cmNlKSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBtZXJnZVRhcmdldCA9IGFycmF5X3RvX29iamVjdCh0YXJnZXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKGlzX2FycmF5KHRhcmdldCkgJiYgaXNfYXJyYXkoc291cmNlKSkge1xuICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICBpZiAoaGFzLmNhbGwodGFyZ2V0LCBpKSkge1xuICAgICAgICBjb25zdCB0YXJnZXRJdGVtID0gdGFyZ2V0W2ldO1xuICAgICAgICBpZiAodGFyZ2V0SXRlbSAmJiB0eXBlb2YgdGFyZ2V0SXRlbSA9PT0gJ29iamVjdCcgJiYgaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0YXJnZXRbaV0gPSBtZXJnZSh0YXJnZXRJdGVtLCBpdGVtLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W2ldID0gaXRlbTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgIGNvbnN0IHZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICBpZiAoaGFzLmNhbGwoYWNjLCBrZXkpKSB7XG4gICAgICBhY2Nba2V5XSA9IG1lcmdlKGFjY1trZXldLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIG1lcmdlVGFyZ2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbl9zaW5nbGVfc291cmNlKHRhcmdldDogYW55LCBzb3VyY2U6IGFueSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgYWNjW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB0YXJnZXQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKHN0cjogc3RyaW5nLCBfOiBhbnksIGNoYXJzZXQ6IHN0cmluZykge1xuICBjb25zdCBzdHJXaXRob3V0UGx1cyA9IHN0ci5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgaWYgKGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgIC8vIHVuZXNjYXBlIG5ldmVyIHRocm93cywgbm8gdHJ5Li4uY2F0Y2ggbmVlZGVkOlxuICAgIHJldHVybiBzdHJXaXRob3V0UGx1cy5yZXBsYWNlKC8lWzAtOWEtZl17Mn0vZ2ksIHVuZXNjYXBlKTtcbiAgfVxuICAvLyB1dGYtOFxuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyV2l0aG91dFBsdXMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHN0cldpdGhvdXRQbHVzO1xuICB9XG59XG5cbmNvbnN0IGxpbWl0ID0gMTAyNDtcblxuZXhwb3J0IGNvbnN0IGVuY29kZTogKFxuICBzdHI6IGFueSxcbiAgZGVmYXVsdEVuY29kZXI6IERlZmF1bHRFbmNvZGVyLFxuICBjaGFyc2V0OiBzdHJpbmcsXG4gIHR5cGU6ICdrZXknIHwgJ3ZhbHVlJyxcbiAgZm9ybWF0OiBGb3JtYXQsXG4pID0+IHN0cmluZyA9IChzdHIsIF9kZWZhdWx0RW5jb2RlciwgY2hhcnNldCwgX2tpbmQsIGZvcm1hdDogRm9ybWF0KSA9PiB7XG4gIC8vIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGJ5IEJyaWFuIFdoaXRlIGZvciB0aGUgaW8uanMgY29yZSBxdWVyeXN0cmluZyBsaWJyYXJ5LlxuICAvLyBJdCBoYXMgYmVlbiBhZGFwdGVkIGhlcmUgZm9yIHN0cmljdGVyIGFkaGVyZW5jZSB0byBSRkMgMzk4NlxuICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBsZXQgc3RyaW5nID0gc3RyO1xuICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N5bWJvbCcpIHtcbiAgICBzdHJpbmcgPSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3RyKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9IFN0cmluZyhzdHIpO1xuICB9XG5cbiAgaWYgKGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgIHJldHVybiBlc2NhcGUoc3RyaW5nKS5yZXBsYWNlKC8ldVswLTlhLWZdezR9L2dpLCBmdW5jdGlvbiAoJDApIHtcbiAgICAgIHJldHVybiAnJTI2JTIzJyArIHBhcnNlSW50KCQwLnNsaWNlKDIpLCAxNikgKyAnJTNCJztcbiAgICB9KTtcbiAgfVxuXG4gIGxldCBvdXQgPSAnJztcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBzdHJpbmcubGVuZ3RoOyBqICs9IGxpbWl0KSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHN0cmluZy5sZW5ndGggPj0gbGltaXQgPyBzdHJpbmcuc2xpY2UoaiwgaiArIGxpbWl0KSA6IHN0cmluZztcbiAgICBjb25zdCBhcnIgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudC5sZW5ndGg7ICsraSkge1xuICAgICAgbGV0IGMgPSBzZWdtZW50LmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoXG4gICAgICAgIGMgPT09IDB4MmQgfHwgLy8gLVxuICAgICAgICBjID09PSAweDJlIHx8IC8vIC5cbiAgICAgICAgYyA9PT0gMHg1ZiB8fCAvLyBfXG4gICAgICAgIGMgPT09IDB4N2UgfHwgLy8gflxuICAgICAgICAoYyA+PSAweDMwICYmIGMgPD0gMHgzOSkgfHwgLy8gMC05XG4gICAgICAgIChjID49IDB4NDEgJiYgYyA8PSAweDVhKSB8fCAvLyBhLXpcbiAgICAgICAgKGMgPj0gMHg2MSAmJiBjIDw9IDB4N2EpIHx8IC8vIEEtWlxuICAgICAgICAoZm9ybWF0ID09PSBSRkMxNzM4ICYmIChjID09PSAweDI4IHx8IGMgPT09IDB4MjkpKSAvLyAoIClcbiAgICAgICkge1xuICAgICAgICBhcnJbYXJyLmxlbmd0aF0gPSBzZWdtZW50LmNoYXJBdChpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICBhcnJbYXJyLmxlbmd0aF0gPSBoZXhfdGFibGVbY107XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgIGFyclthcnIubGVuZ3RoXSA9IGhleF90YWJsZVsweGMwIHwgKGMgPj4gNildISArIGhleF90YWJsZVsweDgwIHwgKGMgJiAweDNmKV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZTAwMCkge1xuICAgICAgICBhcnJbYXJyLmxlbmd0aF0gPVxuICAgICAgICAgIGhleF90YWJsZVsweGUwIHwgKGMgPj4gMTIpXSEgKyBoZXhfdGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpXSArIGhleF90YWJsZVsweDgwIHwgKGMgJiAweDNmKV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgICBjID0gMHgxMDAwMCArICgoKGMgJiAweDNmZikgPDwgMTApIHwgKHNlZ21lbnQuY2hhckNvZGVBdChpKSAmIDB4M2ZmKSk7XG5cbiAgICAgIGFyclthcnIubGVuZ3RoXSA9XG4gICAgICAgIGhleF90YWJsZVsweGYwIHwgKGMgPj4gMTgpXSEgK1xuICAgICAgICBoZXhfdGFibGVbMHg4MCB8ICgoYyA+PiAxMikgJiAweDNmKV0gK1xuICAgICAgICBoZXhfdGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpXSArXG4gICAgICAgIGhleF90YWJsZVsweDgwIHwgKGMgJiAweDNmKV07XG4gICAgfVxuXG4gICAgb3V0ICs9IGFyci5qb2luKCcnKTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFjdCh2YWx1ZTogYW55KSB7XG4gIGNvbnN0IHF1ZXVlID0gW3sgb2JqOiB7IG86IHZhbHVlIH0sIHByb3A6ICdvJyB9XTtcbiAgY29uc3QgcmVmcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBpdGVtID0gcXVldWVbaV07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbal0hO1xuICAgICAgY29uc3QgdmFsID0gb2JqW2tleV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsICYmIHJlZnMuaW5kZXhPZih2YWwpID09PSAtMSkge1xuICAgICAgICBxdWV1ZS5wdXNoKHsgb2JqOiBvYmosIHByb3A6IGtleSB9KTtcbiAgICAgICAgcmVmcy5wdXNoKHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29tcGFjdF9xdWV1ZShxdWV1ZSk7XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNfcmVnZXhwKG9iajogYW55KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc19idWZmZXIob2JqOiBhbnkpIHtcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gISEob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lKGE6IGFueSwgYjogYW55KSB7XG4gIHJldHVybiBbXS5jb25jYXQoYSwgYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZV9tYXA8VD4odmFsOiBUW10sIGZuOiAodjogVCkgPT4gVCkge1xuICBpZiAoaXNfYXJyYXkodmFsKSkge1xuICAgIGNvbnN0IG1hcHBlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBtYXBwZWQucHVzaChmbih2YWxbaV0hKSk7XG4gICAgfVxuICAgIHJldHVybiBtYXBwZWQ7XG4gIH1cbiAgcmV0dXJuIGZuKHZhbCk7XG59XG4iLCAiaW1wb3J0IHsgZW5jb2RlLCBpc19idWZmZXIsIG1heWJlX21hcCB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgZGVmYXVsdF9mb3JtYXQsIGZvcm1hdHRlcnMgfSBmcm9tICcuL2Zvcm1hdHMnO1xuaW1wb3J0IHR5cGUgeyBOb25OdWxsYWJsZVByb3BlcnRpZXMsIFN0cmluZ2lmeU9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuY29uc3QgYXJyYXlfcHJlZml4X2dlbmVyYXRvcnMgPSB7XG4gIGJyYWNrZXRzKHByZWZpeDogUHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gU3RyaW5nKHByZWZpeCkgKyAnW10nO1xuICB9LFxuICBjb21tYTogJ2NvbW1hJyxcbiAgaW5kaWNlcyhwcmVmaXg6IFByb3BlcnR5S2V5LCBrZXk6IHN0cmluZykge1xuICAgIHJldHVybiBTdHJpbmcocHJlZml4KSArICdbJyArIGtleSArICddJztcbiAgfSxcbiAgcmVwZWF0KHByZWZpeDogUHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gU3RyaW5nKHByZWZpeCk7XG4gIH0sXG59O1xuXG5jb25zdCBpc19hcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBwdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG5jb25zdCBwdXNoX3RvX2FycmF5ID0gZnVuY3Rpb24gKGFycjogYW55W10sIHZhbHVlX29yX2FycmF5OiBhbnkpIHtcbiAgcHVzaC5hcHBseShhcnIsIGlzX2FycmF5KHZhbHVlX29yX2FycmF5KSA/IHZhbHVlX29yX2FycmF5IDogW3ZhbHVlX29yX2FycmF5XSk7XG59O1xuXG5jb25zdCB0b19JU08gPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGFkZFF1ZXJ5UHJlZml4OiBmYWxzZSxcbiAgYWxsb3dEb3RzOiBmYWxzZSxcbiAgYWxsb3dFbXB0eUFycmF5czogZmFsc2UsXG4gIGFycmF5Rm9ybWF0OiAnaW5kaWNlcycsXG4gIGNoYXJzZXQ6ICd1dGYtOCcsXG4gIGNoYXJzZXRTZW50aW5lbDogZmFsc2UsXG4gIGRlbGltaXRlcjogJyYnLFxuICBlbmNvZGU6IHRydWUsXG4gIGVuY29kZURvdEluS2V5czogZmFsc2UsXG4gIGVuY29kZXI6IGVuY29kZSxcbiAgZW5jb2RlVmFsdWVzT25seTogZmFsc2UsXG4gIGZvcm1hdDogZGVmYXVsdF9mb3JtYXQsXG4gIGZvcm1hdHRlcjogZm9ybWF0dGVyc1tkZWZhdWx0X2Zvcm1hdF0sXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBpbmRpY2VzOiBmYWxzZSxcbiAgc2VyaWFsaXplRGF0ZShkYXRlKSB7XG4gICAgcmV0dXJuIHRvX0lTTy5jYWxsKGRhdGUpO1xuICB9LFxuICBza2lwTnVsbHM6IGZhbHNlLFxuICBzdHJpY3ROdWxsSGFuZGxpbmc6IGZhbHNlLFxufSBhcyBOb25OdWxsYWJsZVByb3BlcnRpZXM8U3RyaW5naWZ5T3B0aW9ucyAmIHsgZm9ybWF0dGVyOiAodHlwZW9mIGZvcm1hdHRlcnMpWydSRkMxNzM4J10gfT47XG5cbmZ1bmN0aW9uIGlzX25vbl9udWxsaXNoX3ByaW1pdGl2ZSh2OiB1bmtub3duKTogdiBpcyBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgc3ltYm9sIHwgYmlnaW50IHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdiA9PT0gJ251bWJlcicgfHxcbiAgICB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgdHlwZW9mIHYgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHYgPT09ICdiaWdpbnQnXG4gICk7XG59XG5cbmNvbnN0IHNlbnRpbmVsID0ge307XG5cbmZ1bmN0aW9uIGlubmVyX3N0cmluZ2lmeShcbiAgb2JqZWN0OiBhbnksXG4gIHByZWZpeDogUHJvcGVydHlLZXksXG4gIGdlbmVyYXRlQXJyYXlQcmVmaXg6IFN0cmluZ2lmeU9wdGlvbnNbJ2FycmF5Rm9ybWF0J10gfCAoKHByZWZpeDogc3RyaW5nLCBrZXk6IHN0cmluZykgPT4gc3RyaW5nKSxcbiAgY29tbWFSb3VuZFRyaXA6IGJvb2xlYW4sXG4gIGFsbG93RW1wdHlBcnJheXM6IGJvb2xlYW4sXG4gIHN0cmljdE51bGxIYW5kbGluZzogYm9vbGVhbixcbiAgc2tpcE51bGxzOiBib29sZWFuLFxuICBlbmNvZGVEb3RJbktleXM6IGJvb2xlYW4sXG4gIGVuY29kZXI6IFN0cmluZ2lmeU9wdGlvbnNbJ2VuY29kZXInXSxcbiAgZmlsdGVyOiBTdHJpbmdpZnlPcHRpb25zWydmaWx0ZXInXSxcbiAgc29ydDogU3RyaW5naWZ5T3B0aW9uc1snc29ydCddLFxuICBhbGxvd0RvdHM6IFN0cmluZ2lmeU9wdGlvbnNbJ2FsbG93RG90cyddLFxuICBzZXJpYWxpemVEYXRlOiBTdHJpbmdpZnlPcHRpb25zWydzZXJpYWxpemVEYXRlJ10sXG4gIGZvcm1hdDogU3RyaW5naWZ5T3B0aW9uc1snZm9ybWF0J10sXG4gIGZvcm1hdHRlcjogU3RyaW5naWZ5T3B0aW9uc1snZm9ybWF0dGVyJ10sXG4gIGVuY29kZVZhbHVlc09ubHk6IGJvb2xlYW4sXG4gIGNoYXJzZXQ6IFN0cmluZ2lmeU9wdGlvbnNbJ2NoYXJzZXQnXSxcbiAgc2lkZUNoYW5uZWw6IFdlYWtNYXA8YW55LCBhbnk+LFxuKSB7XG4gIGxldCBvYmogPSBvYmplY3Q7XG5cbiAgbGV0IHRtcF9zYyA9IHNpZGVDaGFubmVsO1xuICBsZXQgc3RlcCA9IDA7XG4gIGxldCBmaW5kX2ZsYWcgPSBmYWxzZTtcbiAgd2hpbGUgKCh0bXBfc2MgPSB0bXBfc2MuZ2V0KHNlbnRpbmVsKSkgIT09IHZvaWQgdW5kZWZpbmVkICYmICFmaW5kX2ZsYWcpIHtcbiAgICAvLyBXaGVyZSBvYmplY3QgbGFzdCBhcHBlYXJlZCBpbiB0aGUgcmVmIHRyZWVcbiAgICBjb25zdCBwb3MgPSB0bXBfc2MuZ2V0KG9iamVjdCk7XG4gICAgc3RlcCArPSAxO1xuICAgIGlmICh0eXBlb2YgcG9zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHBvcyA9PT0gc3RlcCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ3ljbGljIG9iamVjdCB2YWx1ZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluZF9mbGFnID0gdHJ1ZTsgLy8gQnJlYWsgd2hpbGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0bXBfc2MuZ2V0KHNlbnRpbmVsKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHN0ZXAgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb2JqID0gZmlsdGVyKHByZWZpeCwgb2JqKTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgb2JqID0gc2VyaWFsaXplRGF0ZT8uKG9iaik7XG4gIH0gZWxzZSBpZiAoZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBpc19hcnJheShvYmopKSB7XG4gICAgb2JqID0gbWF5YmVfbWFwKG9iaiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVEYXRlPy4odmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIGlmIChzdHJpY3ROdWxsSGFuZGxpbmcpIHtcbiAgICAgIHJldHVybiBlbmNvZGVyICYmICFlbmNvZGVWYWx1ZXNPbmx5ID9cbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICdrZXknLCBmb3JtYXQpXG4gICAgICAgIDogcHJlZml4O1xuICAgIH1cblxuICAgIG9iaiA9ICcnO1xuICB9XG5cbiAgaWYgKGlzX25vbl9udWxsaXNoX3ByaW1pdGl2ZShvYmopIHx8IGlzX2J1ZmZlcihvYmopKSB7XG4gICAgaWYgKGVuY29kZXIpIHtcbiAgICAgIGNvbnN0IGtleV92YWx1ZSA9XG4gICAgICAgIGVuY29kZVZhbHVlc09ubHkgPyBwcmVmaXhcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIDogZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICdrZXknLCBmb3JtYXQpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgZm9ybWF0dGVyPy4oa2V5X3ZhbHVlKSArXG4gICAgICAgICAgJz0nICtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgZm9ybWF0dGVyPy4oZW5jb2RlcihvYmosIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICd2YWx1ZScsIGZvcm1hdCkpLFxuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtmb3JtYXR0ZXI/LihwcmVmaXgpICsgJz0nICsgZm9ybWF0dGVyPy4oU3RyaW5nKG9iaikpXTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlczogc3RyaW5nW10gPSBbXTtcblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgbGV0IG9ial9rZXlzO1xuICBpZiAoZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBpc19hcnJheShvYmopKSB7XG4gICAgLy8gd2UgbmVlZCB0byBqb2luIGVsZW1lbnRzIGluXG4gICAgaWYgKGVuY29kZVZhbHVlc09ubHkgJiYgZW5jb2Rlcikge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB2YWx1ZXMgb25seVxuICAgICAgb2JqID0gbWF5YmVfbWFwKG9iaiwgZW5jb2Rlcik7XG4gICAgfVxuICAgIG9ial9rZXlzID0gW3sgdmFsdWU6IG9iai5sZW5ndGggPiAwID8gb2JqLmpvaW4oJywnKSB8fCBudWxsIDogdm9pZCB1bmRlZmluZWQgfV07XG4gIH0gZWxzZSBpZiAoaXNfYXJyYXkoZmlsdGVyKSkge1xuICAgIG9ial9rZXlzID0gZmlsdGVyO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIG9ial9rZXlzID0gc29ydCA/IGtleXMuc29ydChzb3J0KSA6IGtleXM7XG4gIH1cblxuICBjb25zdCBlbmNvZGVkX3ByZWZpeCA9IGVuY29kZURvdEluS2V5cyA/IFN0cmluZyhwcmVmaXgpLnJlcGxhY2UoL1xcLi9nLCAnJTJFJykgOiBTdHJpbmcocHJlZml4KTtcblxuICBjb25zdCBhZGp1c3RlZF9wcmVmaXggPVxuICAgIGNvbW1hUm91bmRUcmlwICYmIGlzX2FycmF5KG9iaikgJiYgb2JqLmxlbmd0aCA9PT0gMSA/IGVuY29kZWRfcHJlZml4ICsgJ1tdJyA6IGVuY29kZWRfcHJlZml4O1xuXG4gIGlmIChhbGxvd0VtcHR5QXJyYXlzICYmIGlzX2FycmF5KG9iaikgJiYgb2JqLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBhZGp1c3RlZF9wcmVmaXggKyAnW10nO1xuICB9XG5cbiAgZm9yIChsZXQgaiA9IDA7IGogPCBvYmpfa2V5cy5sZW5ndGg7ICsraikge1xuICAgIGNvbnN0IGtleSA9IG9ial9rZXlzW2pdO1xuICAgIGNvbnN0IHZhbHVlID1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBrZXkudmFsdWUgIT09ICd1bmRlZmluZWQnID8ga2V5LnZhbHVlIDogb2JqW2tleSBhcyBhbnldO1xuXG4gICAgaWYgKHNraXBOdWxscyAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGVuY29kZWRfa2V5ID0gYWxsb3dEb3RzICYmIGVuY29kZURvdEluS2V5cyA/IChrZXkgYXMgYW55KS5yZXBsYWNlKC9cXC4vZywgJyUyRScpIDoga2V5O1xuICAgIGNvbnN0IGtleV9wcmVmaXggPVxuICAgICAgaXNfYXJyYXkob2JqKSA/XG4gICAgICAgIHR5cGVvZiBnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4KGFkanVzdGVkX3ByZWZpeCwgZW5jb2RlZF9rZXkpXG4gICAgICAgIDogYWRqdXN0ZWRfcHJlZml4XG4gICAgICA6IGFkanVzdGVkX3ByZWZpeCArIChhbGxvd0RvdHMgPyAnLicgKyBlbmNvZGVkX2tleSA6ICdbJyArIGVuY29kZWRfa2V5ICsgJ10nKTtcblxuICAgIHNpZGVDaGFubmVsLnNldChvYmplY3QsIHN0ZXApO1xuICAgIGNvbnN0IHZhbHVlU2lkZUNoYW5uZWwgPSBuZXcgV2Vha01hcCgpO1xuICAgIHZhbHVlU2lkZUNoYW5uZWwuc2V0KHNlbnRpbmVsLCBzaWRlQ2hhbm5lbCk7XG4gICAgcHVzaF90b19hcnJheShcbiAgICAgIHZhbHVlcyxcbiAgICAgIGlubmVyX3N0cmluZ2lmeShcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGtleV9wcmVmaXgsXG4gICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgICAgIGNvbW1hUm91bmRUcmlwLFxuICAgICAgICBhbGxvd0VtcHR5QXJyYXlzLFxuICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgIHNraXBOdWxscyxcbiAgICAgICAgZW5jb2RlRG90SW5LZXlzLFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgZW5jb2RlVmFsdWVzT25seSAmJiBpc19hcnJheShvYmopID8gbnVsbCA6IGVuY29kZXIsXG4gICAgICAgIGZpbHRlcixcbiAgICAgICAgc29ydCxcbiAgICAgICAgYWxsb3dEb3RzLFxuICAgICAgICBzZXJpYWxpemVEYXRlLFxuICAgICAgICBmb3JtYXQsXG4gICAgICAgIGZvcm1hdHRlcixcbiAgICAgICAgZW5jb2RlVmFsdWVzT25seSxcbiAgICAgICAgY2hhcnNldCxcbiAgICAgICAgdmFsdWVTaWRlQ2hhbm5lbCxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZXM7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZV9zdHJpbmdpZnlfb3B0aW9ucyhcbiAgb3B0czogU3RyaW5naWZ5T3B0aW9ucyA9IGRlZmF1bHRzLFxuKTogTm9uTnVsbGFibGVQcm9wZXJ0aWVzPE9taXQ8U3RyaW5naWZ5T3B0aW9ucywgJ2luZGljZXMnPj4gJiB7IGluZGljZXM/OiBib29sZWFuIH0ge1xuICBpZiAodHlwZW9mIG9wdHMuYWxsb3dFbXB0eUFycmF5cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9wdHMuYWxsb3dFbXB0eUFycmF5cyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYGFsbG93RW1wdHlBcnJheXNgIG9wdGlvbiBjYW4gb25seSBiZSBgdHJ1ZWAgb3IgYGZhbHNlYCwgd2hlbiBwcm92aWRlZCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRzLmVuY29kZURvdEluS2V5cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9wdHMuZW5jb2RlRG90SW5LZXlzICE9PSAnYm9vbGVhbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgZW5jb2RlRG90SW5LZXlzYCBvcHRpb24gY2FuIG9ubHkgYmUgYHRydWVgIG9yIGBmYWxzZWAsIHdoZW4gcHJvdmlkZWQnKTtcbiAgfVxuXG4gIGlmIChvcHRzLmVuY29kZXIgIT09IG51bGwgJiYgdHlwZW9mIG9wdHMuZW5jb2RlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9wdHMuZW5jb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuY29kZXIgaGFzIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICBjb25zdCBjaGFyc2V0ID0gb3B0cy5jaGFyc2V0IHx8IGRlZmF1bHRzLmNoYXJzZXQ7XG4gIGlmICh0eXBlb2Ygb3B0cy5jaGFyc2V0ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmNoYXJzZXQgIT09ICd1dGYtOCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAnaXNvLTg4NTktMScpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2hhcnNldCBvcHRpb24gbXVzdCBiZSBlaXRoZXIgdXRmLTgsIGlzby04ODU5LTEsIG9yIHVuZGVmaW5lZCcpO1xuICB9XG5cbiAgbGV0IGZvcm1hdCA9IGRlZmF1bHRfZm9ybWF0O1xuICBpZiAodHlwZW9mIG9wdHMuZm9ybWF0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICghaGFzLmNhbGwoZm9ybWF0dGVycywgb3B0cy5mb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGZvcm1hdCBvcHRpb24gcHJvdmlkZWQuJyk7XG4gICAgfVxuICAgIGZvcm1hdCA9IG9wdHMuZm9ybWF0O1xuICB9XG4gIGNvbnN0IGZvcm1hdHRlciA9IGZvcm1hdHRlcnNbZm9ybWF0XTtcblxuICBsZXQgZmlsdGVyID0gZGVmYXVsdHMuZmlsdGVyO1xuICBpZiAodHlwZW9mIG9wdHMuZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8IGlzX2FycmF5KG9wdHMuZmlsdGVyKSkge1xuICAgIGZpbHRlciA9IG9wdHMuZmlsdGVyO1xuICB9XG5cbiAgbGV0IGFycmF5Rm9ybWF0OiBTdHJpbmdpZnlPcHRpb25zWydhcnJheUZvcm1hdCddO1xuICBpZiAob3B0cy5hcnJheUZvcm1hdCAmJiBvcHRzLmFycmF5Rm9ybWF0IGluIGFycmF5X3ByZWZpeF9nZW5lcmF0b3JzKSB7XG4gICAgYXJyYXlGb3JtYXQgPSBvcHRzLmFycmF5Rm9ybWF0O1xuICB9IGVsc2UgaWYgKCdpbmRpY2VzJyBpbiBvcHRzKSB7XG4gICAgYXJyYXlGb3JtYXQgPSBvcHRzLmluZGljZXMgPyAnaW5kaWNlcycgOiAncmVwZWF0JztcbiAgfSBlbHNlIHtcbiAgICBhcnJheUZvcm1hdCA9IGRlZmF1bHRzLmFycmF5Rm9ybWF0O1xuICB9XG5cbiAgaWYgKCdjb21tYVJvdW5kVHJpcCcgaW4gb3B0cyAmJiB0eXBlb2Ygb3B0cy5jb21tYVJvdW5kVHJpcCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYGNvbW1hUm91bmRUcmlwYCBtdXN0IGJlIGEgYm9vbGVhbiwgb3IgYWJzZW50Jyk7XG4gIH1cblxuICBjb25zdCBhbGxvd0RvdHMgPVxuICAgIHR5cGVvZiBvcHRzLmFsbG93RG90cyA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgISFvcHRzLmVuY29kZURvdEluS2V5cyA9PT0gdHJ1ZSA/XG4gICAgICAgIHRydWVcbiAgICAgIDogZGVmYXVsdHMuYWxsb3dEb3RzXG4gICAgOiAhIW9wdHMuYWxsb3dEb3RzO1xuXG4gIHJldHVybiB7XG4gICAgYWRkUXVlcnlQcmVmaXg6IHR5cGVvZiBvcHRzLmFkZFF1ZXJ5UHJlZml4ID09PSAnYm9vbGVhbicgPyBvcHRzLmFkZFF1ZXJ5UHJlZml4IDogZGVmYXVsdHMuYWRkUXVlcnlQcmVmaXgsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGFsbG93RG90czogYWxsb3dEb3RzLFxuICAgIGFsbG93RW1wdHlBcnJheXM6XG4gICAgICB0eXBlb2Ygb3B0cy5hbGxvd0VtcHR5QXJyYXlzID09PSAnYm9vbGVhbicgPyAhIW9wdHMuYWxsb3dFbXB0eUFycmF5cyA6IGRlZmF1bHRzLmFsbG93RW1wdHlBcnJheXMsXG4gICAgYXJyYXlGb3JtYXQ6IGFycmF5Rm9ybWF0LFxuICAgIGNoYXJzZXQ6IGNoYXJzZXQsXG4gICAgY2hhcnNldFNlbnRpbmVsOlxuICAgICAgdHlwZW9mIG9wdHMuY2hhcnNldFNlbnRpbmVsID09PSAnYm9vbGVhbicgPyBvcHRzLmNoYXJzZXRTZW50aW5lbCA6IGRlZmF1bHRzLmNoYXJzZXRTZW50aW5lbCxcbiAgICBjb21tYVJvdW5kVHJpcDogISFvcHRzLmNvbW1hUm91bmRUcmlwLFxuICAgIGRlbGltaXRlcjogdHlwZW9mIG9wdHMuZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmRlbGltaXRlciA6IG9wdHMuZGVsaW1pdGVyLFxuICAgIGVuY29kZTogdHlwZW9mIG9wdHMuZW5jb2RlID09PSAnYm9vbGVhbicgPyBvcHRzLmVuY29kZSA6IGRlZmF1bHRzLmVuY29kZSxcbiAgICBlbmNvZGVEb3RJbktleXM6XG4gICAgICB0eXBlb2Ygb3B0cy5lbmNvZGVEb3RJbktleXMgPT09ICdib29sZWFuJyA/IG9wdHMuZW5jb2RlRG90SW5LZXlzIDogZGVmYXVsdHMuZW5jb2RlRG90SW5LZXlzLFxuICAgIGVuY29kZXI6IHR5cGVvZiBvcHRzLmVuY29kZXIgPT09ICdmdW5jdGlvbicgPyBvcHRzLmVuY29kZXIgOiBkZWZhdWx0cy5lbmNvZGVyLFxuICAgIGVuY29kZVZhbHVlc09ubHk6XG4gICAgICB0eXBlb2Ygb3B0cy5lbmNvZGVWYWx1ZXNPbmx5ID09PSAnYm9vbGVhbicgPyBvcHRzLmVuY29kZVZhbHVlc09ubHkgOiBkZWZhdWx0cy5lbmNvZGVWYWx1ZXNPbmx5LFxuICAgIGZpbHRlcjogZmlsdGVyLFxuICAgIGZvcm1hdDogZm9ybWF0LFxuICAgIGZvcm1hdHRlcjogZm9ybWF0dGVyLFxuICAgIHNlcmlhbGl6ZURhdGU6IHR5cGVvZiBvcHRzLnNlcmlhbGl6ZURhdGUgPT09ICdmdW5jdGlvbicgPyBvcHRzLnNlcmlhbGl6ZURhdGUgOiBkZWZhdWx0cy5zZXJpYWxpemVEYXRlLFxuICAgIHNraXBOdWxsczogdHlwZW9mIG9wdHMuc2tpcE51bGxzID09PSAnYm9vbGVhbicgPyBvcHRzLnNraXBOdWxscyA6IGRlZmF1bHRzLnNraXBOdWxscyxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgc29ydDogdHlwZW9mIG9wdHMuc29ydCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuc29ydCA6IG51bGwsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nOlxuICAgICAgdHlwZW9mIG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZyxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeShvYmplY3Q6IGFueSwgb3B0czogU3RyaW5naWZ5T3B0aW9ucyA9IHt9KSB7XG4gIGxldCBvYmogPSBvYmplY3Q7XG4gIGNvbnN0IG9wdGlvbnMgPSBub3JtYWxpemVfc3RyaW5naWZ5X29wdGlvbnMob3B0cyk7XG5cbiAgbGV0IG9ial9rZXlzOiBQcm9wZXJ0eUtleVtdIHwgdW5kZWZpbmVkO1xuICBsZXQgZmlsdGVyO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICBvYmogPSBmaWx0ZXIoJycsIG9iaik7XG4gIH0gZWxzZSBpZiAoaXNfYXJyYXkob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgb2JqX2tleXMgPSBmaWx0ZXI7XG4gIH1cblxuICBjb25zdCBrZXlzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBjb25zdCBnZW5lcmF0ZUFycmF5UHJlZml4ID0gYXJyYXlfcHJlZml4X2dlbmVyYXRvcnNbb3B0aW9ucy5hcnJheUZvcm1hdF07XG4gIGNvbnN0IGNvbW1hUm91bmRUcmlwID0gZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBvcHRpb25zLmNvbW1hUm91bmRUcmlwO1xuXG4gIGlmICghb2JqX2tleXMpIHtcbiAgICBvYmpfa2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIH1cblxuICBpZiAob3B0aW9ucy5zb3J0KSB7XG4gICAgb2JqX2tleXMuc29ydChvcHRpb25zLnNvcnQpO1xuICB9XG5cbiAgY29uc3Qgc2lkZUNoYW5uZWwgPSBuZXcgV2Vha01hcCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG9ial9rZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0gb2JqX2tleXNbaV0hO1xuXG4gICAgaWYgKG9wdGlvbnMuc2tpcE51bGxzICYmIG9ialtrZXldID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcHVzaF90b19hcnJheShcbiAgICAgIGtleXMsXG4gICAgICBpbm5lcl9zdHJpbmdpZnkoXG4gICAgICAgIG9ialtrZXldLFxuICAgICAgICBrZXksXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgY29tbWFSb3VuZFRyaXAsXG4gICAgICAgIG9wdGlvbnMuYWxsb3dFbXB0eUFycmF5cyxcbiAgICAgICAgb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgIG9wdGlvbnMuc2tpcE51bGxzLFxuICAgICAgICBvcHRpb25zLmVuY29kZURvdEluS2V5cyxcbiAgICAgICAgb3B0aW9ucy5lbmNvZGUgPyBvcHRpb25zLmVuY29kZXIgOiBudWxsLFxuICAgICAgICBvcHRpb25zLmZpbHRlcixcbiAgICAgICAgb3B0aW9ucy5zb3J0LFxuICAgICAgICBvcHRpb25zLmFsbG93RG90cyxcbiAgICAgICAgb3B0aW9ucy5zZXJpYWxpemVEYXRlLFxuICAgICAgICBvcHRpb25zLmZvcm1hdCxcbiAgICAgICAgb3B0aW9ucy5mb3JtYXR0ZXIsXG4gICAgICAgIG9wdGlvbnMuZW5jb2RlVmFsdWVzT25seSxcbiAgICAgICAgb3B0aW9ucy5jaGFyc2V0LFxuICAgICAgICBzaWRlQ2hhbm5lbCxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGpvaW5lZCA9IGtleXMuam9pbihvcHRpb25zLmRlbGltaXRlcik7XG4gIGxldCBwcmVmaXggPSBvcHRpb25zLmFkZFF1ZXJ5UHJlZml4ID09PSB0cnVlID8gJz8nIDogJyc7XG5cbiAgaWYgKG9wdGlvbnMuY2hhcnNldFNlbnRpbmVsKSB7XG4gICAgaWYgKG9wdGlvbnMuY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAvLyBlbmNvZGVVUklDb21wb25lbnQoJyYjMTAwMDM7JyksIHRoZSBcIm51bWVyaWMgZW50aXR5XCIgcmVwcmVzZW50YXRpb24gb2YgYSBjaGVja21hcmtcbiAgICAgIHByZWZpeCArPSAndXRmOD0lMjYlMjMxMDAwMyUzQiYnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbmNvZGVVUklDb21wb25lbnQoJ1x1MjcxMycpXG4gICAgICBwcmVmaXggKz0gJ3V0Zjg9JUUyJTlDJTkzJic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGpvaW5lZC5sZW5ndGggPiAwID8gcHJlZml4ICsgam9pbmVkIDogJyc7XG59XG4iLCAiZXhwb3J0IGNvbnN0IFZFUlNJT04gPSAnNC43OS4xJzsgLy8geC1yZWxlYXNlLXBsZWFzZS12ZXJzaW9uXG4iLCAiLyoqXG4gKiBEaXNjbGFpbWVyOiBtb2R1bGVzIGluIF9zaGltcyBhcmVuJ3QgaW50ZW5kZWQgdG8gYmUgaW1wb3J0ZWQgYnkgU0RLIHVzZXJzLlxuICovXG5pbXBvcnQgeyB0eXBlIFJlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vY29yZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hpbXMge1xuICBraW5kOiBzdHJpbmc7XG4gIGZldGNoOiBhbnk7XG4gIFJlcXVlc3Q6IGFueTtcbiAgUmVzcG9uc2U6IGFueTtcbiAgSGVhZGVyczogYW55O1xuICBGb3JtRGF0YTogYW55O1xuICBCbG9iOiBhbnk7XG4gIEZpbGU6IGFueTtcbiAgUmVhZGFibGVTdHJlYW06IGFueTtcbiAgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnM6IDxUID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KFxuICAgIGZvcm06IFNoaW1zWydGb3JtRGF0YSddLFxuICAgIG9wdHM6IFJlcXVlc3RPcHRpb25zPFQ+LFxuICApID0+IFByb21pc2U8UmVxdWVzdE9wdGlvbnM8VD4+O1xuICBnZXREZWZhdWx0QWdlbnQ6ICh1cmw6IHN0cmluZykgPT4gYW55O1xuICBmaWxlRnJvbVBhdGg6XG4gICAgfCAoKHBhdGg6IHN0cmluZywgZmlsZW5hbWU/OiBzdHJpbmcsIG9wdGlvbnM/OiB7fSkgPT4gUHJvbWlzZTxTaGltc1snRmlsZSddPilcbiAgICB8ICgocGF0aDogc3RyaW5nLCBvcHRpb25zPzoge30pID0+IFByb21pc2U8U2hpbXNbJ0ZpbGUnXT4pO1xuICBpc0ZzUmVhZFN0cmVhbTogKHZhbHVlOiBhbnkpID0+IGJvb2xlYW47XG59XG5cbmV4cG9ydCBsZXQgYXV0byA9IGZhbHNlO1xuZXhwb3J0IGxldCBraW5kOiBTaGltc1sna2luZCddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBmZXRjaDogU2hpbXNbJ2ZldGNoJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IFJlcXVlc3Q6IFNoaW1zWydSZXF1ZXN0J10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IFJlc3BvbnNlOiBTaGltc1snUmVzcG9uc2UnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgSGVhZGVyczogU2hpbXNbJ0hlYWRlcnMnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgRm9ybURhdGE6IFNoaW1zWydGb3JtRGF0YSddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBCbG9iOiBTaGltc1snQmxvYiddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBGaWxlOiBTaGltc1snRmlsZSddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBSZWFkYWJsZVN0cmVhbTogU2hpbXNbJ1JlYWRhYmxlU3RyZWFtJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zOiBTaGltc1snZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgZ2V0RGVmYXVsdEFnZW50OiBTaGltc1snZ2V0RGVmYXVsdEFnZW50J10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGZpbGVGcm9tUGF0aDogU2hpbXNbJ2ZpbGVGcm9tUGF0aCddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBpc0ZzUmVhZFN0cmVhbTogU2hpbXNbJ2lzRnNSZWFkU3RyZWFtJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRTaGltcyhzaGltczogU2hpbXMsIG9wdGlvbnM6IHsgYXV0bzogYm9vbGVhbiB9ID0geyBhdXRvOiBmYWxzZSB9KSB7XG4gIGlmIChhdXRvKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYHlvdSBtdXN0IFxcYGltcG9ydCAnb3BlbmFpL3NoaW1zLyR7c2hpbXMua2luZH0nXFxgIGJlZm9yZSBpbXBvcnRpbmcgYW55dGhpbmcgZWxzZSBmcm9tIG9wZW5haWAsXG4gICAgKTtcbiAgfVxuICBpZiAoa2luZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2FuJ3QgXFxgaW1wb3J0ICdvcGVuYWkvc2hpbXMvJHtzaGltcy5raW5kfSdcXGAgYWZ0ZXIgXFxgaW1wb3J0ICdvcGVuYWkvc2hpbXMvJHtraW5kfSdcXGBgKTtcbiAgfVxuICBhdXRvID0gb3B0aW9ucy5hdXRvO1xuICBraW5kID0gc2hpbXMua2luZDtcbiAgZmV0Y2ggPSBzaGltcy5mZXRjaDtcbiAgUmVxdWVzdCA9IHNoaW1zLlJlcXVlc3Q7XG4gIFJlc3BvbnNlID0gc2hpbXMuUmVzcG9uc2U7XG4gIEhlYWRlcnMgPSBzaGltcy5IZWFkZXJzO1xuICBGb3JtRGF0YSA9IHNoaW1zLkZvcm1EYXRhO1xuICBCbG9iID0gc2hpbXMuQmxvYjtcbiAgRmlsZSA9IHNoaW1zLkZpbGU7XG4gIFJlYWRhYmxlU3RyZWFtID0gc2hpbXMuUmVhZGFibGVTdHJlYW07XG4gIGdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zID0gc2hpbXMuZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnM7XG4gIGdldERlZmF1bHRBZ2VudCA9IHNoaW1zLmdldERlZmF1bHRBZ2VudDtcbiAgZmlsZUZyb21QYXRoID0gc2hpbXMuZmlsZUZyb21QYXRoO1xuICBpc0ZzUmVhZFN0cmVhbSA9IHNoaW1zLmlzRnNSZWFkU3RyZWFtO1xufVxuIiwgIi8qKlxuICogRGlzY2xhaW1lcjogbW9kdWxlcyBpbiBfc2hpbXMgYXJlbid0IGludGVuZGVkIHRvIGJlIGltcG9ydGVkIGJ5IFNESyB1c2Vycy5cbiAqL1xuZXhwb3J0IGNsYXNzIE11bHRpcGFydEJvZHkge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgYm9keTogYW55KSB7fVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ011bHRpcGFydEJvZHknO1xuICB9XG59XG4iLCAiLyoqXG4gKiBEaXNjbGFpbWVyOiBtb2R1bGVzIGluIF9zaGltcyBhcmVuJ3QgaW50ZW5kZWQgdG8gYmUgaW1wb3J0ZWQgYnkgU0RLIHVzZXJzLlxuICovXG5pbXBvcnQgeyBNdWx0aXBhcnRCb2R5IH0gZnJvbSAnLi9NdWx0aXBhcnRCb2R5JztcbmltcG9ydCB7IHR5cGUgUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7IHR5cGUgU2hpbXMgfSBmcm9tICcuL3JlZ2lzdHJ5JztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJ1bnRpbWUoeyBtYW51YWxseUltcG9ydGVkIH06IHsgbWFudWFsbHlJbXBvcnRlZD86IGJvb2xlYW4gfSA9IHt9KTogU2hpbXMge1xuICBjb25zdCByZWNvbW1lbmRhdGlvbiA9XG4gICAgbWFudWFsbHlJbXBvcnRlZCA/XG4gICAgICBgWW91IG1heSBuZWVkIHRvIHVzZSBwb2x5ZmlsbHNgXG4gICAgOiBgQWRkIG9uZSBvZiB0aGVzZSBpbXBvcnRzIGJlZm9yZSB5b3VyIGZpcnN0IFxcYGltcG9ydCBcdTIwMjYgZnJvbSAnb3BlbmFpJ1xcYDpcbi0gXFxgaW1wb3J0ICdvcGVuYWkvc2hpbXMvbm9kZSdcXGAgKGlmIHlvdSdyZSBydW5uaW5nIG9uIE5vZGUpXG4tIFxcYGltcG9ydCAnb3BlbmFpL3NoaW1zL3dlYidcXGAgKG90aGVyd2lzZSlcbmA7XG5cbiAgbGV0IF9mZXRjaCwgX1JlcXVlc3QsIF9SZXNwb25zZSwgX0hlYWRlcnM7XG4gIHRyeSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIF9mZXRjaCA9IGZldGNoO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBfUmVxdWVzdCA9IFJlcXVlc3Q7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIF9SZXNwb25zZSA9IFJlc3BvbnNlO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBfSGVhZGVycyA9IEhlYWRlcnM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYHRoaXMgZW52aXJvbm1lbnQgaXMgbWlzc2luZyB0aGUgZm9sbG93aW5nIFdlYiBGZXRjaCBBUEkgdHlwZTogJHtcbiAgICAgICAgKGVycm9yIGFzIGFueSkubWVzc2FnZVxuICAgICAgfS4gJHtyZWNvbW1lbmRhdGlvbn1gLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGtpbmQ6ICd3ZWInLFxuICAgIGZldGNoOiBfZmV0Y2gsXG4gICAgUmVxdWVzdDogX1JlcXVlc3QsXG4gICAgUmVzcG9uc2U6IF9SZXNwb25zZSxcbiAgICBIZWFkZXJzOiBfSGVhZGVycyxcbiAgICBGb3JtRGF0YTpcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBGb3JtRGF0YSA6IChcbiAgICAgICAgY2xhc3MgRm9ybURhdGEge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYGZpbGUgdXBsb2FkcyBhcmVuJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQgeWV0IGFzICdGb3JtRGF0YScgaXMgdW5kZWZpbmVkLiAke3JlY29tbWVuZGF0aW9ufWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICBCbG9iOlxuICAgICAgdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnID8gQmxvYiA6IChcbiAgICAgICAgY2xhc3MgQmxvYiB7XG4gICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBmaWxlIHVwbG9hZHMgYXJlbid0IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50IHlldCBhcyAnQmxvYicgaXMgdW5kZWZpbmVkLiAke3JlY29tbWVuZGF0aW9ufWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICBGaWxlOlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnID8gRmlsZSA6IChcbiAgICAgICAgY2xhc3MgRmlsZSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgZmlsZSB1cGxvYWRzIGFyZW4ndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCB5ZXQgYXMgJ0ZpbGUnIGlzIHVuZGVmaW5lZC4gJHtyZWNvbW1lbmRhdGlvbn1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgUmVhZGFibGVTdHJlYW06XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0eXBlb2YgUmVhZGFibGVTdHJlYW0gIT09ICd1bmRlZmluZWQnID8gUmVhZGFibGVTdHJlYW0gOiAoXG4gICAgICAgIGNsYXNzIFJlYWRhYmxlU3RyZWFtIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBzdHJlYW1pbmcgaXNuJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQgeWV0IGFzICdSZWFkYWJsZVN0cmVhbScgaXMgdW5kZWZpbmVkLiAke3JlY29tbWVuZGF0aW9ufWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9uczogYXN5bmMgPFQgPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBmb3JtOiBGb3JtRGF0YSxcbiAgICAgIG9wdHM6IFJlcXVlc3RPcHRpb25zPFQ+LFxuICAgICk6IFByb21pc2U8UmVxdWVzdE9wdGlvbnM8VD4+ID0+ICh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgYm9keTogbmV3IE11bHRpcGFydEJvZHkoZm9ybSkgYXMgYW55LFxuICAgIH0pLFxuICAgIGdldERlZmF1bHRBZ2VudDogKHVybDogc3RyaW5nKSA9PiB1bmRlZmluZWQsXG4gICAgZmlsZUZyb21QYXRoOiAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgYGZpbGVGcm9tUGF0aGAgZnVuY3Rpb24gaXMgb25seSBzdXBwb3J0ZWQgaW4gTm9kZS4gU2VlIHRoZSBSRUFETUUgZm9yIG1vcmUgZGV0YWlsczogaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUjZmlsZS11cGxvYWRzJyxcbiAgICAgICk7XG4gICAgfSxcbiAgICBpc0ZzUmVhZFN0cmVhbTogKHZhbHVlOiBhbnkpID0+IGZhbHNlLFxuICB9O1xufVxuIiwgIi8qKlxuICogRGlzY2xhaW1lcjogbW9kdWxlcyBpbiBfc2hpbXMgYXJlbid0IGludGVuZGVkIHRvIGJlIGltcG9ydGVkIGJ5IFNESyB1c2Vycy5cbiAqL1xuaW1wb3J0ICogYXMgc2hpbXMgZnJvbSAnLi9yZWdpc3RyeS5tanMnO1xuaW1wb3J0ICogYXMgYXV0byBmcm9tICdvcGVuYWkvX3NoaW1zL2F1dG8vcnVudGltZSc7XG5pZiAoIXNoaW1zLmtpbmQpIHNoaW1zLnNldFNoaW1zKGF1dG8uZ2V0UnVudGltZSgpLCB7IGF1dG86IHRydWUgfSk7XG5leHBvcnQgKiBmcm9tICcuL3JlZ2lzdHJ5Lm1qcyc7XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgY2FzdFRvRXJyb3IsIEhlYWRlcnMgfSBmcm9tICcuL2NvcmUnO1xuXG5leHBvcnQgY2xhc3MgT3BlbkFJRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5leHBvcnQgY2xhc3MgQVBJRXJyb3I8XG4gIFRTdGF0dXMgZXh0ZW5kcyBudW1iZXIgfCB1bmRlZmluZWQgPSBudW1iZXIgfCB1bmRlZmluZWQsXG4gIFRIZWFkZXJzIGV4dGVuZHMgSGVhZGVycyB8IHVuZGVmaW5lZCA9IEhlYWRlcnMgfCB1bmRlZmluZWQsXG4gIFRFcnJvciBleHRlbmRzIE9iamVjdCB8IHVuZGVmaW5lZCA9IE9iamVjdCB8IHVuZGVmaW5lZCxcbj4gZXh0ZW5kcyBPcGVuQUlFcnJvciB7XG4gIC8qKiBIVFRQIHN0YXR1cyBmb3IgdGhlIHJlc3BvbnNlIHRoYXQgY2F1c2VkIHRoZSBlcnJvciAqL1xuICByZWFkb25seSBzdGF0dXM6IFRTdGF0dXM7XG4gIC8qKiBIVFRQIGhlYWRlcnMgZm9yIHRoZSByZXNwb25zZSB0aGF0IGNhdXNlZCB0aGUgZXJyb3IgKi9cbiAgcmVhZG9ubHkgaGVhZGVyczogVEhlYWRlcnM7XG4gIC8qKiBKU09OIGJvZHkgb2YgdGhlIHJlc3BvbnNlIHRoYXQgY2F1c2VkIHRoZSBlcnJvciAqL1xuICByZWFkb25seSBlcnJvcjogVEVycm9yO1xuXG4gIHJlYWRvbmx5IGNvZGU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG4gIHJlYWRvbmx5IHBhcmFtOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xuICByZWFkb25seSB0eXBlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgcmVhZG9ubHkgcmVxdWVzdF9pZDogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihzdGF0dXM6IFRTdGF0dXMsIGVycm9yOiBURXJyb3IsIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCwgaGVhZGVyczogVEhlYWRlcnMpIHtcbiAgICBzdXBlcihgJHtBUElFcnJvci5tYWtlTWVzc2FnZShzdGF0dXMsIGVycm9yLCBtZXNzYWdlKX1gKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMucmVxdWVzdF9pZCA9IGhlYWRlcnM/LlsneC1yZXF1ZXN0LWlkJ107XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuXG4gICAgY29uc3QgZGF0YSA9IGVycm9yIGFzIFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgdGhpcy5jb2RlID0gZGF0YT8uWydjb2RlJ107XG4gICAgdGhpcy5wYXJhbSA9IGRhdGE/LlsncGFyYW0nXTtcbiAgICB0aGlzLnR5cGUgPSBkYXRhPy5bJ3R5cGUnXTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIG1ha2VNZXNzYWdlKHN0YXR1czogbnVtYmVyIHwgdW5kZWZpbmVkLCBlcnJvcjogYW55LCBtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBtc2cgPVxuICAgICAgZXJyb3I/Lm1lc3NhZ2UgP1xuICAgICAgICB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgIGVycm9yLm1lc3NhZ2VcbiAgICAgICAgOiBKU09OLnN0cmluZ2lmeShlcnJvci5tZXNzYWdlKVxuICAgICAgOiBlcnJvciA/IEpTT04uc3RyaW5naWZ5KGVycm9yKVxuICAgICAgOiBtZXNzYWdlO1xuXG4gICAgaWYgKHN0YXR1cyAmJiBtc2cpIHtcbiAgICAgIHJldHVybiBgJHtzdGF0dXN9ICR7bXNnfWA7XG4gICAgfVxuICAgIGlmIChzdGF0dXMpIHtcbiAgICAgIHJldHVybiBgJHtzdGF0dXN9IHN0YXR1cyBjb2RlIChubyBib2R5KWA7XG4gICAgfVxuICAgIGlmIChtc2cpIHtcbiAgICAgIHJldHVybiBtc2c7XG4gICAgfVxuICAgIHJldHVybiAnKG5vIHN0YXR1cyBjb2RlIG9yIGJvZHkpJztcbiAgfVxuXG4gIHN0YXRpYyBnZW5lcmF0ZShcbiAgICBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgICBlcnJvclJlc3BvbnNlOiBPYmplY3QgfCB1bmRlZmluZWQsXG4gICAgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIGhlYWRlcnM6IEhlYWRlcnMgfCB1bmRlZmluZWQsXG4gICk6IEFQSUVycm9yIHtcbiAgICBpZiAoIXN0YXR1cyB8fCAhaGVhZGVycykge1xuICAgICAgcmV0dXJuIG5ldyBBUElDb25uZWN0aW9uRXJyb3IoeyBtZXNzYWdlLCBjYXVzZTogY2FzdFRvRXJyb3IoZXJyb3JSZXNwb25zZSkgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3IgPSAoZXJyb3JSZXNwb25zZSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+KT8uWydlcnJvciddO1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDAwKSB7XG4gICAgICByZXR1cm4gbmV3IEJhZFJlcXVlc3RFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MDEpIHtcbiAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MDMpIHtcbiAgICAgIHJldHVybiBuZXcgUGVybWlzc2lvbkRlbmllZEVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IDQwNCkge1xuICAgICAgcmV0dXJuIG5ldyBOb3RGb3VuZEVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IDQwOSkge1xuICAgICAgcmV0dXJuIG5ldyBDb25mbGljdEVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IDQyMikge1xuICAgICAgcmV0dXJuIG5ldyBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICByZXR1cm4gbmV3IFJhdGVMaW1pdEVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPj0gNTAwKSB7XG4gICAgICByZXR1cm4gbmV3IEludGVybmFsU2VydmVyRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBUElFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQVBJVXNlckFib3J0RXJyb3IgZXh0ZW5kcyBBUElFcnJvcjx1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkPiB7XG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9OiB7IG1lc3NhZ2U/OiBzdHJpbmcgfSA9IHt9KSB7XG4gICAgc3VwZXIodW5kZWZpbmVkLCB1bmRlZmluZWQsIG1lc3NhZ2UgfHwgJ1JlcXVlc3Qgd2FzIGFib3J0ZWQuJywgdW5kZWZpbmVkKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQVBJQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgQVBJRXJyb3I8dW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZD4ge1xuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UsIGNhdXNlIH06IHsgbWVzc2FnZT86IHN0cmluZyB8IHVuZGVmaW5lZDsgY2F1c2U/OiBFcnJvciB8IHVuZGVmaW5lZCB9KSB7XG4gICAgc3VwZXIodW5kZWZpbmVkLCB1bmRlZmluZWQsIG1lc3NhZ2UgfHwgJ0Nvbm5lY3Rpb24gZXJyb3IuJywgdW5kZWZpbmVkKTtcbiAgICAvLyBpbiBzb21lIGVudmlyb25tZW50cyB0aGUgJ2NhdXNlJyBwcm9wZXJ0eSBpcyBhbHJlYWR5IGRlY2xhcmVkXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChjYXVzZSkgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBUElDb25uZWN0aW9uVGltZW91dEVycm9yIGV4dGVuZHMgQVBJQ29ubmVjdGlvbkVycm9yIHtcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlIH06IHsgbWVzc2FnZT86IHN0cmluZyB9ID0ge30pIHtcbiAgICBzdXBlcih7IG1lc3NhZ2U6IG1lc3NhZ2UgPz8gJ1JlcXVlc3QgdGltZWQgb3V0LicgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJhZFJlcXVlc3RFcnJvciBleHRlbmRzIEFQSUVycm9yPDQwMCwgSGVhZGVycz4ge31cblxuZXhwb3J0IGNsYXNzIEF1dGhlbnRpY2F0aW9uRXJyb3IgZXh0ZW5kcyBBUElFcnJvcjw0MDEsIEhlYWRlcnM+IHt9XG5cbmV4cG9ydCBjbGFzcyBQZXJtaXNzaW9uRGVuaWVkRXJyb3IgZXh0ZW5kcyBBUElFcnJvcjw0MDMsIEhlYWRlcnM+IHt9XG5cbmV4cG9ydCBjbGFzcyBOb3RGb3VuZEVycm9yIGV4dGVuZHMgQVBJRXJyb3I8NDA0LCBIZWFkZXJzPiB7fVxuXG5leHBvcnQgY2xhc3MgQ29uZmxpY3RFcnJvciBleHRlbmRzIEFQSUVycm9yPDQwOSwgSGVhZGVycz4ge31cblxuZXhwb3J0IGNsYXNzIFVucHJvY2Vzc2FibGVFbnRpdHlFcnJvciBleHRlbmRzIEFQSUVycm9yPDQyMiwgSGVhZGVycz4ge31cblxuZXhwb3J0IGNsYXNzIFJhdGVMaW1pdEVycm9yIGV4dGVuZHMgQVBJRXJyb3I8NDI5LCBIZWFkZXJzPiB7fVxuXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxTZXJ2ZXJFcnJvciBleHRlbmRzIEFQSUVycm9yPG51bWJlciwgSGVhZGVycz4ge31cblxuZXhwb3J0IGNsYXNzIExlbmd0aEZpbmlzaFJlYXNvbkVycm9yIGV4dGVuZHMgT3BlbkFJRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihgQ291bGQgbm90IHBhcnNlIHJlc3BvbnNlIGNvbnRlbnQgYXMgdGhlIGxlbmd0aCBsaW1pdCB3YXMgcmVhY2hlZGApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb250ZW50RmlsdGVyRmluaXNoUmVhc29uRXJyb3IgZXh0ZW5kcyBPcGVuQUlFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGBDb3VsZCBub3QgcGFyc2UgcmVzcG9uc2UgY29udGVudCBhcyB0aGUgcmVxdWVzdCB3YXMgcmVqZWN0ZWQgYnkgdGhlIGNvbnRlbnQgZmlsdGVyYCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBPcGVuQUlFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9yJztcblxudHlwZSBCeXRlcyA9IHN0cmluZyB8IEFycmF5QnVmZmVyIHwgVWludDhBcnJheSB8IEJ1ZmZlciB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSByZS1pbXBsZW1lbnRhdGlvbiBvZiBodHRweCdzIGBMaW5lRGVjb2RlcmAgaW4gUHl0aG9uIHRoYXQgaGFuZGxlcyBpbmNyZW1lbnRhbGx5XG4gKiByZWFkaW5nIGxpbmVzIGZyb20gdGV4dC5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZW5jb2RlL2h0dHB4L2Jsb2IvOTIwMzMzZWE5ODExOGU5Y2Y2MTdmMjQ2OTA1ZDdiMjAyNTEwOTQxYy9odHRweC9fZGVjb2RlcnMucHkjTDI1OFxuICovXG5leHBvcnQgY2xhc3MgTGluZURlY29kZXIge1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgc3RhdGljIE5FV0xJTkVfQ0hBUlMgPSBuZXcgU2V0KFsnXFxuJywgJ1xcciddKTtcbiAgc3RhdGljIE5FV0xJTkVfUkVHRVhQID0gL1xcclxcbnxbXFxuXFxyXS9nO1xuXG4gIGJ1ZmZlcjogc3RyaW5nW107XG4gIHRyYWlsaW5nQ1I6IGJvb2xlYW47XG4gIHRleHREZWNvZGVyOiBhbnk7IC8vIFRleHREZWNvZGVyIGZvdW5kIGluIGJyb3dzZXJzOyBub3QgdHlwZWQgdG8gYXZvaWQgcHVsbGluZyBpbiBlaXRoZXIgXCJkb21cIiBvciBcIm5vZGVcIiB0eXBlcy5cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIHRoaXMudHJhaWxpbmdDUiA9IGZhbHNlO1xuICB9XG5cbiAgZGVjb2RlKGNodW5rOiBCeXRlcyk6IHN0cmluZ1tdIHtcbiAgICBsZXQgdGV4dCA9IHRoaXMuZGVjb2RlVGV4dChjaHVuayk7XG5cbiAgICBpZiAodGhpcy50cmFpbGluZ0NSKSB7XG4gICAgICB0ZXh0ID0gJ1xccicgKyB0ZXh0O1xuICAgICAgdGhpcy50cmFpbGluZ0NSID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0ZXh0LmVuZHNXaXRoKCdcXHInKSkge1xuICAgICAgdGhpcy50cmFpbGluZ0NSID0gdHJ1ZTtcbiAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIC0xKTtcbiAgICB9XG5cbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFpbGluZ05ld2xpbmUgPSBMaW5lRGVjb2Rlci5ORVdMSU5FX0NIQVJTLmhhcyh0ZXh0W3RleHQubGVuZ3RoIC0gMV0gfHwgJycpO1xuICAgIGxldCBsaW5lcyA9IHRleHQuc3BsaXQoTGluZURlY29kZXIuTkVXTElORV9SRUdFWFApO1xuXG4gICAgLy8gaWYgdGhlcmUgaXMgYSB0cmFpbGluZyBuZXcgbGluZSB0aGVuIHRoZSBsYXN0IGVudHJ5IHdpbGwgYmUgYW4gZW1wdHlcbiAgICAvLyBzdHJpbmcgd2hpY2ggd2UgZG9uJ3QgY2FyZSBhYm91dFxuICAgIGlmICh0cmFpbGluZ05ld2xpbmUpIHtcbiAgICAgIGxpbmVzLnBvcCgpO1xuICAgIH1cblxuICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDEgJiYgIXRyYWlsaW5nTmV3bGluZSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChsaW5lc1swXSEpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICBsaW5lcyA9IFt0aGlzLmJ1ZmZlci5qb2luKCcnKSArIGxpbmVzWzBdLCAuLi5saW5lcy5zbGljZSgxKV07XG4gICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIH1cblxuICAgIGlmICghdHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICB0aGlzLmJ1ZmZlciA9IFtsaW5lcy5wb3AoKSB8fCAnJ107XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgZGVjb2RlVGV4dChieXRlczogQnl0ZXMpOiBzdHJpbmcge1xuICAgIGlmIChieXRlcyA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHJldHVybiBieXRlcztcblxuICAgIC8vIE5vZGU6XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShieXRlcykudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZDogcmVjZWl2ZWQgbm9uLVVpbnQ4QXJyYXkgKCR7Ynl0ZXMuY29uc3RydWN0b3IubmFtZX0pIHN0cmVhbSBjaHVuayBpbiBhbiBlbnZpcm9ubWVudCB3aXRoIGEgZ2xvYmFsIFwiQnVmZmVyXCIgZGVmaW5lZCwgd2hpY2ggdGhpcyBsaWJyYXJ5IGFzc3VtZXMgdG8gYmUgTm9kZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGVycm9yLmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEJyb3dzZXJcbiAgICBpZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHRoaXMudGV4dERlY29kZXIgPz89IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpO1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUoYnl0ZXMpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoXG4gICAgICAgIGBVbmV4cGVjdGVkOiByZWNlaXZlZCBub24tVWludDhBcnJheS9BcnJheUJ1ZmZlciAoJHtcbiAgICAgICAgICAoYnl0ZXMgYXMgYW55KS5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgIH0pIGluIGEgd2ViIHBsYXRmb3JtLiBQbGVhc2UgcmVwb3J0IHRoaXMgZXJyb3IuYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgYFVuZXhwZWN0ZWQ6IG5laXRoZXIgQnVmZmVyIG5vciBUZXh0RGVjb2RlciBhcmUgYXZhaWxhYmxlIGFzIGdsb2JhbHMuIFBsZWFzZSByZXBvcnQgdGhpcyBlcnJvci5gLFxuICAgICk7XG4gIH1cblxuICBmbHVzaCgpOiBzdHJpbmdbXSB7XG4gICAgaWYgKCF0aGlzLmJ1ZmZlci5sZW5ndGggJiYgIXRoaXMudHJhaWxpbmdDUikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmVzID0gW3RoaXMuYnVmZmVyLmpvaW4oJycpXTtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIHRoaXMudHJhaWxpbmdDUiA9IGZhbHNlO1xuICAgIHJldHVybiBsaW5lcztcbiAgfVxufVxuIiwgImltcG9ydCB7IFJlYWRhYmxlU3RyZWFtLCB0eXBlIFJlc3BvbnNlIH0gZnJvbSAnLi9fc2hpbXMvaW5kZXgnO1xuaW1wb3J0IHsgT3BlbkFJRXJyb3IgfSBmcm9tICcuL2Vycm9yJztcbmltcG9ydCB7IExpbmVEZWNvZGVyIH0gZnJvbSAnLi9pbnRlcm5hbC9kZWNvZGVycy9saW5lJztcblxuaW1wb3J0IHsgQVBJRXJyb3IgfSBmcm9tICcuL2Vycm9yJztcblxudHlwZSBCeXRlcyA9IHN0cmluZyB8IEFycmF5QnVmZmVyIHwgVWludDhBcnJheSB8IEJ1ZmZlciB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCB0eXBlIFNlcnZlclNlbnRFdmVudCA9IHtcbiAgZXZlbnQ6IHN0cmluZyB8IG51bGw7XG4gIGRhdGE6IHN0cmluZztcbiAgcmF3OiBzdHJpbmdbXTtcbn07XG5cbmV4cG9ydCBjbGFzcyBTdHJlYW08SXRlbT4gaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPEl0ZW0+IHtcbiAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaXRlcmF0b3I6ICgpID0+IEFzeW5jSXRlcmF0b3I8SXRlbT4sXG4gICAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyLFxuICApIHtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICB9XG5cbiAgc3RhdGljIGZyb21TU0VSZXNwb25zZTxJdGVtPihyZXNwb25zZTogUmVzcG9uc2UsIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcik6IFN0cmVhbTxJdGVtPiB7XG4gICAgbGV0IGNvbnN1bWVkID0gZmFsc2U7XG5cbiAgICBhc3luYyBmdW5jdGlvbiogaXRlcmF0b3IoKTogQXN5bmNJdGVyYXRvcjxJdGVtLCBhbnksIHVuZGVmaW5lZD4ge1xuICAgICAgaWYgKGNvbnN1bWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGl0ZXJhdGUgb3ZlciBhIGNvbnN1bWVkIHN0cmVhbSwgdXNlIGAudGVlKClgIHRvIHNwbGl0IHRoZSBzdHJlYW0uJyk7XG4gICAgICB9XG4gICAgICBjb25zdW1lZCA9IHRydWU7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBzc2Ugb2YgX2l0ZXJTU0VNZXNzYWdlcyhyZXNwb25zZSwgY29udHJvbGxlcikpIHtcbiAgICAgICAgICBpZiAoZG9uZSkgY29udGludWU7XG5cbiAgICAgICAgICBpZiAoc3NlLmRhdGEuc3RhcnRzV2l0aCgnW0RPTkVdJykpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNzZS5ldmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGRhdGE7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHNzZS5kYXRhKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IHBhcnNlIG1lc3NhZ2UgaW50byBKU09OOmAsIHNzZS5kYXRhKTtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRnJvbSBjaHVuazpgLCBzc2UucmF3KTtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5lcnJvcikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgQVBJRXJyb3IodW5kZWZpbmVkLCBkYXRhLmVycm9yLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHlpZWxkIGRhdGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2Uoc3NlLmRhdGEpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgcGFyc2UgbWVzc2FnZSBpbnRvIEpTT046YCwgc3NlLmRhdGEpO1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGcm9tIGNodW5rOmAsIHNzZS5yYXcpO1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogSXMgdGhpcyB3aGVyZSB0aGUgZXJyb3Igc2hvdWxkIGJlIHRocm93bj9cbiAgICAgICAgICAgIGlmIChzc2UuZXZlbnQgPT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgQVBJRXJyb3IodW5kZWZpbmVkLCBkYXRhLmVycm9yLCBkYXRhLm1lc3NhZ2UsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCB7IGV2ZW50OiBzc2UuZXZlbnQsIGRhdGE6IGRhdGEgfSBhcyBhbnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBjYWxscyBgc3RyZWFtLmNvbnRyb2xsZXIuYWJvcnQoKWAsIHdlIHNob3VsZCBleGl0IHdpdGhvdXQgdGhyb3dpbmcuXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHJldHVybjtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGBicmVha2BzLCBhYm9ydCB0aGUgb25nb2luZyByZXF1ZXN0LlxuICAgICAgICBpZiAoIWRvbmUpIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFN0cmVhbShpdGVyYXRvciwgY29udHJvbGxlcik7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgU3RyZWFtIGZyb20gYSBuZXdsaW5lLXNlcGFyYXRlZCBSZWFkYWJsZVN0cmVhbVxuICAgKiB3aGVyZSBlYWNoIGl0ZW0gaXMgYSBKU09OIHZhbHVlLlxuICAgKi9cbiAgc3RhdGljIGZyb21SZWFkYWJsZVN0cmVhbTxJdGVtPihyZWFkYWJsZVN0cmVhbTogUmVhZGFibGVTdHJlYW0sIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcik6IFN0cmVhbTxJdGVtPiB7XG4gICAgbGV0IGNvbnN1bWVkID0gZmFsc2U7XG5cbiAgICBhc3luYyBmdW5jdGlvbiogaXRlckxpbmVzKCk6IEFzeW5jR2VuZXJhdG9yPHN0cmluZywgdm9pZCwgdW5rbm93bj4ge1xuICAgICAgY29uc3QgbGluZURlY29kZXIgPSBuZXcgTGluZURlY29kZXIoKTtcblxuICAgICAgY29uc3QgaXRlciA9IHJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYWJsZTxCeXRlcz4ocmVhZGFibGVTdHJlYW0pO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpdGVyKSB7XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5kZWNvZGUoY2h1bmspKSB7XG4gICAgICAgICAgeWllbGQgbGluZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZmx1c2goKSkge1xuICAgICAgICB5aWVsZCBsaW5lO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uKiBpdGVyYXRvcigpOiBBc3luY0l0ZXJhdG9yPEl0ZW0sIGFueSwgdW5kZWZpbmVkPiB7XG4gICAgICBpZiAoY29uc3VtZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaXRlcmF0ZSBvdmVyIGEgY29uc3VtZWQgc3RyZWFtLCB1c2UgYC50ZWUoKWAgdG8gc3BsaXQgdGhlIHN0cmVhbS4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN1bWVkID0gdHJ1ZTtcbiAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGxpbmUgb2YgaXRlckxpbmVzKCkpIHtcbiAgICAgICAgICBpZiAoZG9uZSkgY29udGludWU7XG4gICAgICAgICAgaWYgKGxpbmUpIHlpZWxkIEpTT04ucGFyc2UobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGNhbGxzIGBzdHJlYW0uY29udHJvbGxlci5hYm9ydCgpYCwgd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCB0aHJvd2luZy5cbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm5hbWUgPT09ICdBYm9ydEVycm9yJykgcmV0dXJuO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgYGJyZWFrYHMsIGFib3J0IHRoZSBvbmdvaW5nIHJlcXVlc3QuXG4gICAgICAgIGlmICghZG9uZSkgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3RyZWFtKGl0ZXJhdG9yLCBjb250cm9sbGVyKTtcbiAgfVxuXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTogQXN5bmNJdGVyYXRvcjxJdGVtPiB7XG4gICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgdGhlIHN0cmVhbSBpbnRvIHR3byBzdHJlYW1zIHdoaWNoIGNhbiBiZVxuICAgKiBpbmRlcGVuZGVudGx5IHJlYWQgZnJvbSBhdCBkaWZmZXJlbnQgc3BlZWRzLlxuICAgKi9cbiAgdGVlKCk6IFtTdHJlYW08SXRlbT4sIFN0cmVhbTxJdGVtPl0ge1xuICAgIGNvbnN0IGxlZnQ6IEFycmF5PFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8SXRlbT4+PiA9IFtdO1xuICAgIGNvbnN0IHJpZ2h0OiBBcnJheTxQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PEl0ZW0+Pj4gPSBbXTtcbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcblxuICAgIGNvbnN0IHRlZUl0ZXJhdG9yID0gKHF1ZXVlOiBBcnJheTxQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PEl0ZW0+Pj4pOiBBc3luY0l0ZXJhdG9yPEl0ZW0+ID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBsZWZ0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIHJpZ2h0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHF1ZXVlLnNoaWZ0KCkhO1xuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBTdHJlYW0oKCkgPT4gdGVlSXRlcmF0b3IobGVmdCksIHRoaXMuY29udHJvbGxlciksXG4gICAgICBuZXcgU3RyZWFtKCgpID0+IHRlZUl0ZXJhdG9yKHJpZ2h0KSwgdGhpcy5jb250cm9sbGVyKSxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgc3RyZWFtIHRvIGEgbmV3bGluZS1zZXBhcmF0ZWQgUmVhZGFibGVTdHJlYW0gb2ZcbiAgICogSlNPTiBzdHJpbmdpZmllZCB2YWx1ZXMgaW4gdGhlIHN0cmVhbVxuICAgKiB3aGljaCBjYW4gYmUgdHVybmVkIGJhY2sgaW50byBhIFN0cmVhbSB3aXRoIGBTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKClgLlxuICAgKi9cbiAgdG9SZWFkYWJsZVN0cmVhbSgpOiBSZWFkYWJsZVN0cmVhbSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGl0ZXI6IEFzeW5jSXRlcmF0b3I8SXRlbT47XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgaXRlciA9IHNlbGZbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgcHVsbChjdHJsOiBhbnkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpdGVyLm5leHQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuIGN0cmwuY2xvc2UoKTtcblxuICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ1xcbicpO1xuXG4gICAgICAgICAgY3RybC5lbnF1ZXVlKGJ5dGVzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY3RybC5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgICBhd2FpdCBpdGVyLnJldHVybj8uKCk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogX2l0ZXJTU0VNZXNzYWdlcyhcbiAgcmVzcG9uc2U6IFJlc3BvbnNlLFxuICBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIsXG4pOiBBc3luY0dlbmVyYXRvcjxTZXJ2ZXJTZW50RXZlbnQsIHZvaWQsIHVua25vd24+IHtcbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgQXR0ZW1wdGVkIHRvIGl0ZXJhdGUgb3ZlciBhIHJlc3BvbnNlIHdpdGggbm8gYm9keWApO1xuICB9XG5cbiAgY29uc3Qgc3NlRGVjb2RlciA9IG5ldyBTU0VEZWNvZGVyKCk7XG4gIGNvbnN0IGxpbmVEZWNvZGVyID0gbmV3IExpbmVEZWNvZGVyKCk7XG5cbiAgY29uc3QgaXRlciA9IHJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYWJsZTxCeXRlcz4ocmVzcG9uc2UuYm9keSk7XG4gIGZvciBhd2FpdCAoY29uc3Qgc3NlQ2h1bmsgb2YgaXRlclNTRUNodW5rcyhpdGVyKSkge1xuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5kZWNvZGUoc3NlQ2h1bmspKSB7XG4gICAgICBjb25zdCBzc2UgPSBzc2VEZWNvZGVyLmRlY29kZShsaW5lKTtcbiAgICAgIGlmIChzc2UpIHlpZWxkIHNzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZmx1c2goKSkge1xuICAgIGNvbnN0IHNzZSA9IHNzZURlY29kZXIuZGVjb2RlKGxpbmUpO1xuICAgIGlmIChzc2UpIHlpZWxkIHNzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGFzeW5jIGl0ZXJhYmxlIGl0ZXJhdG9yLCBpdGVyYXRlcyBvdmVyIGl0IGFuZCB5aWVsZHMgZnVsbFxuICogU1NFIGNodW5rcywgaS5lLiB5aWVsZHMgd2hlbiBhIGRvdWJsZSBuZXctbGluZSBpcyBlbmNvdW50ZXJlZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24qIGl0ZXJTU0VDaHVua3MoaXRlcmF0b3I6IEFzeW5jSXRlcmFibGVJdGVyYXRvcjxCeXRlcz4pOiBBc3luY0dlbmVyYXRvcjxVaW50OEFycmF5PiB7XG4gIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoKTtcblxuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGl0ZXJhdG9yKSB7XG4gICAgaWYgKGNodW5rID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGJpbmFyeUNodW5rID1cbiAgICAgIGNodW5rIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgVWludDhBcnJheShjaHVuaylcbiAgICAgIDogdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShjaHVuaylcbiAgICAgIDogY2h1bms7XG5cbiAgICBsZXQgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgYmluYXJ5Q2h1bmsubGVuZ3RoKTtcbiAgICBuZXdEYXRhLnNldChkYXRhKTtcbiAgICBuZXdEYXRhLnNldChiaW5hcnlDaHVuaywgZGF0YS5sZW5ndGgpO1xuICAgIGRhdGEgPSBuZXdEYXRhO1xuXG4gICAgbGV0IHBhdHRlcm5JbmRleDtcbiAgICB3aGlsZSAoKHBhdHRlcm5JbmRleCA9IGZpbmREb3VibGVOZXdsaW5lSW5kZXgoZGF0YSkpICE9PSAtMSkge1xuICAgICAgeWllbGQgZGF0YS5zbGljZSgwLCBwYXR0ZXJuSW5kZXgpO1xuICAgICAgZGF0YSA9IGRhdGEuc2xpY2UocGF0dGVybkluZGV4KTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgeWllbGQgZGF0YTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kRG91YmxlTmV3bGluZUluZGV4KGJ1ZmZlcjogVWludDhBcnJheSk6IG51bWJlciB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gc2VhcmNoZXMgdGhlIGJ1ZmZlciBmb3IgdGhlIGVuZCBwYXR0ZXJucyAoXFxyXFxyLCBcXG5cXG4sIFxcclxcblxcclxcbilcbiAgLy8gYW5kIHJldHVybnMgdGhlIGluZGV4IHJpZ2h0IGFmdGVyIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFueSBwYXR0ZXJuLFxuICAvLyBvciAtMSBpZiBub25lIG9mIHRoZSBwYXR0ZXJucyBhcmUgZm91bmQuXG4gIGNvbnN0IG5ld2xpbmUgPSAweDBhOyAvLyBcXG5cbiAgY29uc3QgY2FycmlhZ2UgPSAweDBkOyAvLyBcXHJcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGggLSAyOyBpKyspIHtcbiAgICBpZiAoYnVmZmVyW2ldID09PSBuZXdsaW5lICYmIGJ1ZmZlcltpICsgMV0gPT09IG5ld2xpbmUpIHtcbiAgICAgIC8vIFxcblxcblxuICAgICAgcmV0dXJuIGkgKyAyO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyW2ldID09PSBjYXJyaWFnZSAmJiBidWZmZXJbaSArIDFdID09PSBjYXJyaWFnZSkge1xuICAgICAgLy8gXFxyXFxyXG4gICAgICByZXR1cm4gaSArIDI7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGJ1ZmZlcltpXSA9PT0gY2FycmlhZ2UgJiZcbiAgICAgIGJ1ZmZlcltpICsgMV0gPT09IG5ld2xpbmUgJiZcbiAgICAgIGkgKyAzIDwgYnVmZmVyLmxlbmd0aCAmJlxuICAgICAgYnVmZmVyW2kgKyAyXSA9PT0gY2FycmlhZ2UgJiZcbiAgICAgIGJ1ZmZlcltpICsgM10gPT09IG5ld2xpbmVcbiAgICApIHtcbiAgICAgIC8vIFxcclxcblxcclxcblxuICAgICAgcmV0dXJuIGkgKyA0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuY2xhc3MgU1NFRGVjb2RlciB7XG4gIHByaXZhdGUgZGF0YTogc3RyaW5nW107XG4gIHByaXZhdGUgZXZlbnQ6IHN0cmluZyB8IG51bGw7XG4gIHByaXZhdGUgY2h1bmtzOiBzdHJpbmdbXTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICB9XG5cbiAgZGVjb2RlKGxpbmU6IHN0cmluZykge1xuICAgIGlmIChsaW5lLmVuZHNXaXRoKCdcXHInKSkge1xuICAgICAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKDAsIGxpbmUubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgaWYgKCFsaW5lKSB7XG4gICAgICAvLyBlbXB0eSBsaW5lIGFuZCB3ZSBkaWRuJ3QgcHJldmlvdXNseSBlbmNvdW50ZXIgYW55IG1lc3NhZ2VzXG4gICAgICBpZiAoIXRoaXMuZXZlbnQgJiYgIXRoaXMuZGF0YS5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgICBjb25zdCBzc2U6IFNlcnZlclNlbnRFdmVudCA9IHtcbiAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgIGRhdGE6IHRoaXMuZGF0YS5qb2luKCdcXG4nKSxcbiAgICAgICAgcmF3OiB0aGlzLmNodW5rcyxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZXZlbnQgPSBudWxsO1xuICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICB0aGlzLmNodW5rcyA9IFtdO1xuXG4gICAgICByZXR1cm4gc3NlO1xuICAgIH1cblxuICAgIHRoaXMuY2h1bmtzLnB1c2gobGluZSk7XG5cbiAgICBpZiAobGluZS5zdGFydHNXaXRoKCc6JykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBbZmllbGRuYW1lLCBfLCB2YWx1ZV0gPSBwYXJ0aXRpb24obGluZSwgJzonKTtcblxuICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCcgJykpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgIH1cblxuICAgIGlmIChmaWVsZG5hbWUgPT09ICdldmVudCcpIHtcbiAgICAgIHRoaXMuZXZlbnQgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkbmFtZSA9PT0gJ2RhdGEnKSB7XG4gICAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqIFRoaXMgaXMgYW4gaW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIHRoYXQncyBqdXN0IHVzZWQgZm9yIHRlc3RpbmcgKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVjb2RlQ2h1bmtzKGNodW5rczogc3RyaW5nW10pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgTGluZURlY29kZXIoKTtcbiAgY29uc3QgbGluZXM6IHN0cmluZ1tdID0gW107XG4gIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgbGluZXMucHVzaCguLi5kZWNvZGVyLmRlY29kZShjaHVuaykpO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVzO1xufVxuXG5mdW5jdGlvbiBwYXJ0aXRpb24oc3RyOiBzdHJpbmcsIGRlbGltaXRlcjogc3RyaW5nKTogW3N0cmluZywgc3RyaW5nLCBzdHJpbmddIHtcbiAgY29uc3QgaW5kZXggPSBzdHIuaW5kZXhPZihkZWxpbWl0ZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgcmV0dXJuIFtzdHIuc3Vic3RyaW5nKDAsIGluZGV4KSwgZGVsaW1pdGVyLCBzdHIuc3Vic3RyaW5nKGluZGV4ICsgZGVsaW1pdGVyLmxlbmd0aCldO1xuICB9XG5cbiAgcmV0dXJuIFtzdHIsICcnLCAnJ107XG59XG5cbi8qKlxuICogTW9zdCBicm93c2VycyBkb24ndCB5ZXQgaGF2ZSBhc3luYyBpdGVyYWJsZSBzdXBwb3J0IGZvciBSZWFkYWJsZVN0cmVhbSxcbiAqIGFuZCBOb2RlIGhhcyBhIHZlcnkgZGlmZmVyZW50IHdheSBvZiByZWFkaW5nIGJ5dGVzIGZyb20gaXRzIFwiUmVhZGFibGVTdHJlYW1cIi5cbiAqXG4gKiBUaGlzIHBvbHlmaWxsIHdhcyBwdWxsZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vTWF0dGlhc0J1ZWxlbnMvd2ViLXN0cmVhbXMtcG9seWZpbGwvcHVsbC8xMjIjaXNzdWVjb21tZW50LTE2MjczNTQ0OTBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYWJsZTxUPihzdHJlYW06IGFueSk6IEFzeW5jSXRlcmFibGVJdGVyYXRvcjxUPiB7XG4gIGlmIChzdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSByZXR1cm4gc3RyZWFtO1xuXG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyBuZXh0KCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKHJlc3VsdD8uZG9uZSkgcmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayB3aGVuIHN0cmVhbSBiZWNvbWVzIGNsb3NlZFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgZXJyb3JlZFxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgcmV0dXJuKCkge1xuICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IHJlYWRlci5jYW5jZWwoKTtcbiAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgYXdhaXQgY2FuY2VsUHJvbWlzZTtcbiAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICB9LFxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICB9O1xufVxuIiwgImltcG9ydCB7IHR5cGUgUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuL2NvcmUnO1xuaW1wb3J0IHtcbiAgRm9ybURhdGEsXG4gIEZpbGUsXG4gIHR5cGUgQmxvYixcbiAgdHlwZSBGaWxlUHJvcGVydHlCYWcsXG4gIGdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zLFxuICB0eXBlIEZzUmVhZFN0cmVhbSxcbiAgaXNGc1JlYWRTdHJlYW0sXG59IGZyb20gJy4vX3NoaW1zL2luZGV4JztcbmltcG9ydCB7IE11bHRpcGFydEJvZHkgfSBmcm9tICcuL19zaGltcy9NdWx0aXBhcnRCb2R5JztcbmV4cG9ydCB7IGZpbGVGcm9tUGF0aCB9IGZyb20gJy4vX3NoaW1zL2luZGV4JztcblxudHlwZSBCbG9iTGlrZVBhcnQgPSBzdHJpbmcgfCBBcnJheUJ1ZmZlciB8IEFycmF5QnVmZmVyVmlldyB8IEJsb2JMaWtlIHwgVWludDhBcnJheSB8IERhdGFWaWV3O1xuZXhwb3J0IHR5cGUgQmxvYlBhcnQgPSBzdHJpbmcgfCBBcnJheUJ1ZmZlciB8IEFycmF5QnVmZmVyVmlldyB8IEJsb2IgfCBVaW50OEFycmF5IHwgRGF0YVZpZXc7XG5cbi8qKlxuICogVHlwaWNhbGx5LCB0aGlzIGlzIGEgbmF0aXZlIFwiRmlsZVwiIGNsYXNzLlxuICpcbiAqIFdlIHByb3ZpZGUgdGhlIHtAbGluayB0b0ZpbGV9IHV0aWxpdHkgdG8gY29udmVydCBhIHZhcmlldHkgb2Ygb2JqZWN0c1xuICogaW50byB0aGUgRmlsZSBjbGFzcy5cbiAqXG4gKiBGb3IgY29udmVuaWVuY2UsIHlvdSBjYW4gYWxzbyBwYXNzIGEgZmV0Y2ggUmVzcG9uc2UsIG9yIGluIE5vZGUsXG4gKiB0aGUgcmVzdWx0IG9mIGZzLmNyZWF0ZVJlYWRTdHJlYW0oKS5cbiAqL1xuZXhwb3J0IHR5cGUgVXBsb2FkYWJsZSA9IEZpbGVMaWtlIHwgUmVzcG9uc2VMaWtlIHwgRnNSZWFkU3RyZWFtO1xuXG4vKipcbiAqIEludGVuZGVkIHRvIG1hdGNoIHdlYi5CbG9iLCBub2RlLkJsb2IsIG5vZGUtZmV0Y2guQmxvYiwgZXRjLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJsb2JMaWtlIHtcbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQmxvYi9zaXplKSAqL1xuICByZWFkb25seSBzaXplOiBudW1iZXI7XG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0Jsb2IvdHlwZSkgKi9cbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nO1xuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9CbG9iL3RleHQpICovXG4gIHRleHQoKTogUHJvbWlzZTxzdHJpbmc+O1xuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9CbG9iL3NsaWNlKSAqL1xuICBzbGljZShzdGFydD86IG51bWJlciwgZW5kPzogbnVtYmVyKTogQmxvYkxpa2U7XG4gIC8vIHVuZm9ydHVuYXRlbHkgQHR5cGVzL25vZGUtZmV0Y2hAXjIuNi40IGRvZXNuJ3QgdHlwZSB0aGUgYXJyYXlCdWZmZXIgbWV0aG9kXG59XG5cbi8qKlxuICogSW50ZW5kZWQgdG8gbWF0Y2ggd2ViLkZpbGUsIG5vZGUuRmlsZSwgbm9kZS1mZXRjaC5GaWxlLCBldGMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUxpa2UgZXh0ZW5kcyBCbG9iTGlrZSB7XG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0ZpbGUvbGFzdE1vZGlmaWVkKSAqL1xuICByZWFkb25seSBsYXN0TW9kaWZpZWQ6IG51bWJlcjtcbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRmlsZS9uYW1lKSAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG59XG5cbi8qKlxuICogSW50ZW5kZWQgdG8gbWF0Y2ggd2ViLlJlc3BvbnNlLCBub2RlLlJlc3BvbnNlLCBub2RlLWZldGNoLlJlc3BvbnNlLCBldGMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VMaWtlIHtcbiAgdXJsOiBzdHJpbmc7XG4gIGJsb2IoKTogUHJvbWlzZTxCbG9iTGlrZT47XG59XG5cbmV4cG9ydCBjb25zdCBpc1Jlc3BvbnNlTGlrZSA9ICh2YWx1ZTogYW55KTogdmFsdWUgaXMgUmVzcG9uc2VMaWtlID0+XG4gIHZhbHVlICE9IG51bGwgJiZcbiAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICB0eXBlb2YgdmFsdWUudXJsID09PSAnc3RyaW5nJyAmJlxuICB0eXBlb2YgdmFsdWUuYmxvYiA9PT0gJ2Z1bmN0aW9uJztcblxuZXhwb3J0IGNvbnN0IGlzRmlsZUxpa2UgPSAodmFsdWU6IGFueSk6IHZhbHVlIGlzIEZpbGVMaWtlID0+XG4gIHZhbHVlICE9IG51bGwgJiZcbiAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICB0eXBlb2YgdmFsdWUubmFtZSA9PT0gJ3N0cmluZycgJiZcbiAgdHlwZW9mIHZhbHVlLmxhc3RNb2RpZmllZCA9PT0gJ251bWJlcicgJiZcbiAgaXNCbG9iTGlrZSh2YWx1ZSk7XG5cbi8qKlxuICogVGhlIEJsb2JMaWtlIHR5cGUgb21pdHMgYXJyYXlCdWZmZXIoKSBiZWNhdXNlIEB0eXBlcy9ub2RlLWZldGNoQF4yLjYuNCBsYWNrcyBpdDsgYnV0IHRoaXMgY2hlY2tcbiAqIGFkZHMgdGhlIGFycmF5QnVmZmVyKCkgbWV0aG9kIHR5cGUgYmVjYXVzZSBpdCBpcyBhdmFpbGFibGUgYW5kIHVzZWQgYXQgcnVudGltZVxuICovXG5leHBvcnQgY29uc3QgaXNCbG9iTGlrZSA9ICh2YWx1ZTogYW55KTogdmFsdWUgaXMgQmxvYkxpa2UgJiB7IGFycmF5QnVmZmVyKCk6IFByb21pc2U8QXJyYXlCdWZmZXI+IH0gPT5cbiAgdmFsdWUgIT0gbnVsbCAmJlxuICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gIHR5cGVvZiB2YWx1ZS5zaXplID09PSAnbnVtYmVyJyAmJlxuICB0eXBlb2YgdmFsdWUudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIHZhbHVlLnNsaWNlID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiB2YWx1ZS5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcblxuZXhwb3J0IGNvbnN0IGlzVXBsb2FkYWJsZSA9ICh2YWx1ZTogYW55KTogdmFsdWUgaXMgVXBsb2FkYWJsZSA9PiB7XG4gIHJldHVybiBpc0ZpbGVMaWtlKHZhbHVlKSB8fCBpc1Jlc3BvbnNlTGlrZSh2YWx1ZSkgfHwgaXNGc1JlYWRTdHJlYW0odmFsdWUpO1xufTtcblxuZXhwb3J0IHR5cGUgVG9GaWxlSW5wdXQgPSBVcGxvYWRhYmxlIHwgRXhjbHVkZTxCbG9iTGlrZVBhcnQsIHN0cmluZz4gfCBBc3luY0l0ZXJhYmxlPEJsb2JMaWtlUGFydD47XG5cbi8qKlxuICogSGVscGVyIGZvciBjcmVhdGluZyBhIHtAbGluayBGaWxlfSB0byBwYXNzIHRvIGFuIFNESyB1cGxvYWQgbWV0aG9kIGZyb20gYSB2YXJpZXR5IG9mIGRpZmZlcmVudCBkYXRhIGZvcm1hdHNcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgcmF3IGNvbnRlbnQgb2YgdGhlIGZpbGUuICBDYW4gYmUgYW4ge0BsaW5rIFVwbG9hZGFibGV9LCB7QGxpbmsgQmxvYkxpa2VQYXJ0fSwgb3Ige0BsaW5rIEFzeW5jSXRlcmFibGV9IG9mIHtAbGluayBCbG9iTGlrZVBhcnR9c1xuICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlLiBJZiBvbWl0dGVkLCB0b0ZpbGUgd2lsbCB0cnkgdG8gZGV0ZXJtaW5lIGEgZmlsZSBuYW1lIGZyb20gYml0cyBpZiBwb3NzaWJsZVxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLnR5cGUgdGhlIE1JTUUgdHlwZSBvZiB0aGUgY29udGVudFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRpb25zLmxhc3RNb2RpZmllZCB0aGUgbGFzdCBtb2RpZmllZCB0aW1lc3RhbXBcbiAqIEByZXR1cm5zIGEge0BsaW5rIEZpbGV9IHdpdGggdGhlIGdpdmVuIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRvRmlsZShcbiAgdmFsdWU6IFRvRmlsZUlucHV0IHwgUHJvbWlzZUxpa2U8VG9GaWxlSW5wdXQ+LFxuICBuYW1lPzogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgb3B0aW9ucz86IEZpbGVQcm9wZXJ0eUJhZyB8IHVuZGVmaW5lZCxcbik6IFByb21pc2U8RmlsZUxpa2U+IHtcbiAgLy8gSWYgaXQncyBhIHByb21pc2UsIHJlc29sdmUgaXQuXG4gIHZhbHVlID0gYXdhaXQgdmFsdWU7XG5cbiAgLy8gSWYgd2UndmUgYmVlbiBnaXZlbiBhIGBGaWxlYCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gIGlmIChpc0ZpbGVMaWtlKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc1Jlc3BvbnNlTGlrZSh2YWx1ZSkpIHtcbiAgICBjb25zdCBibG9iID0gYXdhaXQgdmFsdWUuYmxvYigpO1xuICAgIG5hbWUgfHw9IG5ldyBVUkwodmFsdWUudXJsKS5wYXRobmFtZS5zcGxpdCgvW1xcXFwvXS8pLnBvcCgpID8/ICd1bmtub3duX2ZpbGUnO1xuXG4gICAgLy8gd2UgbmVlZCB0byBjb252ZXJ0IHRoZSBgQmxvYmAgaW50byBhbiBhcnJheSBidWZmZXIgYmVjYXVzZSB0aGUgYEJsb2JgIGNsYXNzXG4gICAgLy8gdGhhdCBgbm9kZS1mZXRjaGAgZGVmaW5lcyBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgd2ViIHN0YW5kYXJkIHdoaWNoIHJlc3VsdHNcbiAgICAvLyBpbiBgbmV3IEZpbGVgIGludGVycHJldGluZyBpdCBhcyBhIHN0cmluZyBpbnN0ZWFkIG9mIGJpbmFyeSBkYXRhLlxuICAgIGNvbnN0IGRhdGEgPSBpc0Jsb2JMaWtlKGJsb2IpID8gWyhhd2FpdCBibG9iLmFycmF5QnVmZmVyKCkpIGFzIGFueV0gOiBbYmxvYl07XG5cbiAgICByZXR1cm4gbmV3IEZpbGUoZGF0YSwgbmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICBjb25zdCBiaXRzID0gYXdhaXQgZ2V0Qnl0ZXModmFsdWUpO1xuXG4gIG5hbWUgfHw9IGdldE5hbWUodmFsdWUpID8/ICd1bmtub3duX2ZpbGUnO1xuXG4gIGlmICghb3B0aW9ucz8udHlwZSkge1xuICAgIGNvbnN0IHR5cGUgPSAoYml0c1swXSBhcyBhbnkpPy50eXBlO1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHR5cGUgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEZpbGUoYml0cywgbmFtZSwgb3B0aW9ucyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEJ5dGVzKHZhbHVlOiBUb0ZpbGVJbnB1dCk6IFByb21pc2U8QXJyYXk8QmxvYlBhcnQ+PiB7XG4gIGxldCBwYXJ0czogQXJyYXk8QmxvYlBhcnQ+ID0gW107XG4gIGlmIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSB8fCAvLyBpbmNsdWRlcyBVaW50OEFycmF5LCBCdWZmZXIsIGV0Yy5cbiAgICB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyXG4gICkge1xuICAgIHBhcnRzLnB1c2godmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQmxvYkxpa2UodmFsdWUpKSB7XG4gICAgcGFydHMucHVzaChhd2FpdCB2YWx1ZS5hcnJheUJ1ZmZlcigpKTtcbiAgfSBlbHNlIGlmIChcbiAgICBpc0FzeW5jSXRlcmFibGVJdGVyYXRvcih2YWx1ZSkgLy8gaW5jbHVkZXMgUmVhZGFibGUsIFJlYWRhYmxlU3RyZWFtLCBldGMuXG4gICkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgdmFsdWUpIHtcbiAgICAgIHBhcnRzLnB1c2goY2h1bmsgYXMgQmxvYlBhcnQpOyAvLyBUT0RPLCBjb25zaWRlciB2YWxpZGF0aW5nP1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVW5leHBlY3RlZCBkYXRhIHR5cGU6ICR7dHlwZW9mIHZhbHVlfTsgY29uc3RydWN0b3I6ICR7dmFsdWU/LmNvbnN0cnVjdG9yXG4gICAgICAgID8ubmFtZX07IHByb3BzOiAke3Byb3BzRm9yRXJyb3IodmFsdWUpfWAsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuZnVuY3Rpb24gcHJvcHNGb3JFcnJvcih2YWx1ZTogYW55KTogc3RyaW5nIHtcbiAgY29uc3QgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIHJldHVybiBgWyR7cHJvcHMubWFwKChwKSA9PiBgXCIke3B9XCJgKS5qb2luKCcsICcpfV1gO1xufVxuXG5mdW5jdGlvbiBnZXROYW1lKHZhbHVlOiBhbnkpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICByZXR1cm4gKFxuICAgIGdldFN0cmluZ0Zyb21NYXliZUJ1ZmZlcih2YWx1ZS5uYW1lKSB8fFxuICAgIGdldFN0cmluZ0Zyb21NYXliZUJ1ZmZlcih2YWx1ZS5maWxlbmFtZSkgfHxcbiAgICAvLyBGb3IgZnMuUmVhZFN0cmVhbVxuICAgIGdldFN0cmluZ0Zyb21NYXliZUJ1ZmZlcih2YWx1ZS5wYXRoKT8uc3BsaXQoL1tcXFxcL10vKS5wb3AoKVxuICApO1xufVxuXG5jb25zdCBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIgPSAoeDogc3RyaW5nIHwgQnVmZmVyIHwgdW5rbm93bik6IHN0cmluZyB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpIHJldHVybiB4O1xuICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIEJ1ZmZlcikgcmV0dXJuIFN0cmluZyh4KTtcbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmNvbnN0IGlzQXN5bmNJdGVyYWJsZUl0ZXJhdG9yID0gKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBBc3luY0l0ZXJhYmxlSXRlcmF0b3I8dW5rbm93bj4gPT5cbiAgdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG5cbmV4cG9ydCBjb25zdCBpc011bHRpcGFydEJvZHkgPSAoYm9keTogYW55KTogYm9keSBpcyBNdWx0aXBhcnRCb2R5ID0+XG4gIGJvZHkgJiYgdHlwZW9mIGJvZHkgPT09ICdvYmplY3QnICYmIGJvZHkuYm9keSAmJiBib2R5W1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNdWx0aXBhcnRCb2R5JztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbXVsdGlwYXJ0L2Zvcm0tZGF0YSByZXF1ZXN0IGlmIGFueSBwYXJ0IG9mIHRoZSBnaXZlbiByZXF1ZXN0IGJvZHkgY29udGFpbnMgYSBGaWxlIC8gQmxvYiB2YWx1ZS5cbiAqIE90aGVyd2lzZSByZXR1cm5zIHRoZSByZXF1ZXN0IGFzIGlzLlxuICovXG5leHBvcnQgY29uc3QgbWF5YmVNdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMgPSBhc3luYyA8VCA9IFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgb3B0czogUmVxdWVzdE9wdGlvbnM8VD4sXG4pOiBQcm9taXNlPFJlcXVlc3RPcHRpb25zPFQgfCBNdWx0aXBhcnRCb2R5Pj4gPT4ge1xuICBpZiAoIWhhc1VwbG9hZGFibGVWYWx1ZShvcHRzLmJvZHkpKSByZXR1cm4gb3B0cztcblxuICBjb25zdCBmb3JtID0gYXdhaXQgY3JlYXRlRm9ybShvcHRzLmJvZHkpO1xuICByZXR1cm4gZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMoZm9ybSwgb3B0cyk7XG59O1xuXG5leHBvcnQgY29uc3QgbXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zID0gYXN5bmMgPFQgPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gIG9wdHM6IFJlcXVlc3RPcHRpb25zPFQ+LFxuKTogUHJvbWlzZTxSZXF1ZXN0T3B0aW9uczxUIHwgTXVsdGlwYXJ0Qm9keT4+ID0+IHtcbiAgY29uc3QgZm9ybSA9IGF3YWl0IGNyZWF0ZUZvcm0ob3B0cy5ib2R5KTtcbiAgcmV0dXJuIGdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zKGZvcm0sIG9wdHMpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUZvcm0gPSBhc3luYyA8VCA9IFJlY29yZDxzdHJpbmcsIHVua25vd24+Pihib2R5OiBUIHwgdW5kZWZpbmVkKTogUHJvbWlzZTxGb3JtRGF0YT4gPT4ge1xuICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG4gIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5lbnRyaWVzKGJvZHkgfHwge30pLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBhZGRGb3JtVmFsdWUoZm9ybSwga2V5LCB2YWx1ZSkpKTtcbiAgcmV0dXJuIGZvcm07XG59O1xuXG5jb25zdCBoYXNVcGxvYWRhYmxlVmFsdWUgPSAodmFsdWU6IHVua25vd24pOiBib29sZWFuID0+IHtcbiAgaWYgKGlzVXBsb2FkYWJsZSh2YWx1ZSkpIHJldHVybiB0cnVlO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB2YWx1ZS5zb21lKGhhc1VwbG9hZGFibGVWYWx1ZSk7XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChjb25zdCBrIGluIHZhbHVlKSB7XG4gICAgICBpZiAoaGFzVXBsb2FkYWJsZVZhbHVlKCh2YWx1ZSBhcyBhbnkpW2tdKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGFkZEZvcm1WYWx1ZSA9IGFzeW5jIChmb3JtOiBGb3JtRGF0YSwga2V5OiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBSZWNlaXZlZCBudWxsIGZvciBcIiR7a2V5fVwiOyB0byBwYXNzIG51bGwgaW4gRm9ybURhdGEsIHlvdSBtdXN0IHVzZSB0aGUgc3RyaW5nICdudWxsJ2AsXG4gICAgKTtcbiAgfVxuXG4gIC8vIFRPRE86IG1ha2UgbmVzdGVkIGZvcm1hdHMgY29uZmlndXJhYmxlXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICBmb3JtLmFwcGVuZChrZXksIFN0cmluZyh2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKGlzVXBsb2FkYWJsZSh2YWx1ZSkpIHtcbiAgICBjb25zdCBmaWxlID0gYXdhaXQgdG9GaWxlKHZhbHVlKTtcbiAgICBmb3JtLmFwcGVuZChrZXksIGZpbGUgYXMgRmlsZSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbCh2YWx1ZS5tYXAoKGVudHJ5KSA9PiBhZGRGb3JtVmFsdWUoZm9ybSwga2V5ICsgJ1tdJywgZW50cnkpKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCgoW25hbWUsIHByb3BdKSA9PiBhZGRGb3JtVmFsdWUoZm9ybSwgYCR7a2V5fVske25hbWV9XWAsIHByb3ApKSxcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBgSW52YWxpZCB2YWx1ZSBnaXZlbiB0byBmb3JtLCBleHBlY3RlZCBhIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvYmplY3QsIEFycmF5LCBGaWxlIG9yIEJsb2IgYnV0IGdvdCAke3ZhbHVlfSBpbnN0ZWFkYCxcbiAgICApO1xuICB9XG59O1xuIiwgImltcG9ydCB7IFZFUlNJT04gfSBmcm9tICcuL3ZlcnNpb24nO1xuaW1wb3J0IHsgU3RyZWFtIH0gZnJvbSAnLi9zdHJlYW1pbmcnO1xuaW1wb3J0IHtcbiAgT3BlbkFJRXJyb3IsXG4gIEFQSUVycm9yLFxuICBBUElDb25uZWN0aW9uRXJyb3IsXG4gIEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IsXG4gIEFQSVVzZXJBYm9ydEVycm9yLFxufSBmcm9tICcuL2Vycm9yJztcbmltcG9ydCB7XG4gIGtpbmQgYXMgc2hpbXNLaW5kLFxuICB0eXBlIFJlYWRhYmxlLFxuICBnZXREZWZhdWx0QWdlbnQsXG4gIHR5cGUgQWdlbnQsXG4gIGZldGNoLFxuICB0eXBlIFJlcXVlc3RJbmZvLFxuICB0eXBlIFJlcXVlc3RJbml0LFxuICB0eXBlIFJlc3BvbnNlLFxuICB0eXBlIEhlYWRlcnNJbml0LFxufSBmcm9tICcuL19zaGltcy9pbmRleCc7XG5leHBvcnQgeyB0eXBlIFJlc3BvbnNlIH07XG5pbXBvcnQgeyBCbG9iTGlrZSwgaXNCbG9iTGlrZSwgaXNNdWx0aXBhcnRCb2R5IH0gZnJvbSAnLi91cGxvYWRzJztcbmV4cG9ydCB7XG4gIG1heWJlTXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zLFxuICBtdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMsXG4gIGNyZWF0ZUZvcm0sXG4gIHR5cGUgVXBsb2FkYWJsZSxcbn0gZnJvbSAnLi91cGxvYWRzJztcblxuZXhwb3J0IHR5cGUgRmV0Y2ggPSAodXJsOiBSZXF1ZXN0SW5mbywgaW5pdD86IFJlcXVlc3RJbml0KSA9PiBQcm9taXNlPFJlc3BvbnNlPjtcblxudHlwZSBQcm9taXNlT3JWYWx1ZTxUPiA9IFQgfCBQcm9taXNlPFQ+O1xuXG50eXBlIEFQSVJlc3BvbnNlUHJvcHMgPSB7XG4gIHJlc3BvbnNlOiBSZXNwb25zZTtcbiAgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucztcbiAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyO1xufTtcblxuYXN5bmMgZnVuY3Rpb24gZGVmYXVsdFBhcnNlUmVzcG9uc2U8VD4ocHJvcHM6IEFQSVJlc3BvbnNlUHJvcHMpOiBQcm9taXNlPFdpdGhSZXF1ZXN0SUQ8VD4+IHtcbiAgY29uc3QgeyByZXNwb25zZSB9ID0gcHJvcHM7XG4gIGlmIChwcm9wcy5vcHRpb25zLnN0cmVhbSkge1xuICAgIGRlYnVnKCdyZXNwb25zZScsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UudXJsLCByZXNwb25zZS5oZWFkZXJzLCByZXNwb25zZS5ib2R5KTtcblxuICAgIC8vIE5vdGU6IHRoZXJlIGlzIGFuIGludmFyaWFudCBoZXJlIHRoYXQgaXNuJ3QgcmVwcmVzZW50ZWQgaW4gdGhlIHR5cGUgc3lzdGVtXG4gICAgLy8gdGhhdCBpZiB5b3Ugc2V0IGBzdHJlYW06IHRydWVgIHRoZSByZXNwb25zZSB0eXBlIG11c3QgYWxzbyBiZSBgU3RyZWFtPFQ+YFxuXG4gICAgaWYgKHByb3BzLm9wdGlvbnMuX19zdHJlYW1DbGFzcykge1xuICAgICAgcmV0dXJuIHByb3BzLm9wdGlvbnMuX19zdHJlYW1DbGFzcy5mcm9tU1NFUmVzcG9uc2UocmVzcG9uc2UsIHByb3BzLmNvbnRyb2xsZXIpIGFzIGFueTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyZWFtLmZyb21TU0VSZXNwb25zZShyZXNwb25zZSwgcHJvcHMuY29udHJvbGxlcikgYXMgYW55O1xuICB9XG5cbiAgLy8gZmV0Y2ggcmVmdXNlcyB0byByZWFkIHRoZSBib2R5IHdoZW4gdGhlIHN0YXR1cyBjb2RlIGlzIDIwNC5cbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgcmV0dXJuIG51bGwgYXMgV2l0aFJlcXVlc3RJRDxUPjtcbiAgfVxuXG4gIGlmIChwcm9wcy5vcHRpb25zLl9fYmluYXJ5UmVzcG9uc2UpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UgYXMgdW5rbm93biBhcyBXaXRoUmVxdWVzdElEPFQ+O1xuICB9XG5cbiAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gIGNvbnN0IGlzSlNPTiA9XG4gICAgY29udGVudFR5cGU/LmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykgfHwgY29udGVudFR5cGU/LmluY2x1ZGVzKCdhcHBsaWNhdGlvbi92bmQuYXBpK2pzb24nKTtcbiAgaWYgKGlzSlNPTikge1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICBkZWJ1ZygncmVzcG9uc2UnLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnVybCwgcmVzcG9uc2UuaGVhZGVycywganNvbik7XG5cbiAgICByZXR1cm4gX2FkZFJlcXVlc3RJRChqc29uLCByZXNwb25zZSk7XG4gIH1cblxuICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICBkZWJ1ZygncmVzcG9uc2UnLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnVybCwgcmVzcG9uc2UuaGVhZGVycywgdGV4dCk7XG5cbiAgLy8gVE9ETyBoYW5kbGUgYmxvYiwgYXJyYXlidWZmZXIsIG90aGVyIGNvbnRlbnQgdHlwZXMsIGV0Yy5cbiAgcmV0dXJuIHRleHQgYXMgdW5rbm93biBhcyBXaXRoUmVxdWVzdElEPFQ+O1xufVxuXG50eXBlIFdpdGhSZXF1ZXN0SUQ8VD4gPVxuICBUIGV4dGVuZHMgQXJyYXk8YW55PiB8IFJlc3BvbnNlIHwgQWJzdHJhY3RQYWdlPGFueT4gPyBUXG4gIDogVCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4gPyBUICYgeyBfcmVxdWVzdF9pZD86IHN0cmluZyB8IG51bGwgfVxuICA6IFQ7XG5cbmZ1bmN0aW9uIF9hZGRSZXF1ZXN0SUQ8VD4odmFsdWU6IFQsIHJlc3BvbnNlOiBSZXNwb25zZSk6IFdpdGhSZXF1ZXN0SUQ8VD4ge1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUgYXMgV2l0aFJlcXVlc3RJRDxUPjtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWUsICdfcmVxdWVzdF9pZCcsIHtcbiAgICB2YWx1ZTogcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtcmVxdWVzdC1pZCcpLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICB9KSBhcyBXaXRoUmVxdWVzdElEPFQ+O1xufVxuXG4vKipcbiAqIEEgc3ViY2xhc3Mgb2YgYFByb21pc2VgIHByb3ZpZGluZyBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzXG4gKiBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgU0RLLlxuICovXG5leHBvcnQgY2xhc3MgQVBJUHJvbWlzZTxUPiBleHRlbmRzIFByb21pc2U8V2l0aFJlcXVlc3RJRDxUPj4ge1xuICBwcml2YXRlIHBhcnNlZFByb21pc2U6IFByb21pc2U8V2l0aFJlcXVlc3RJRDxUPj4gfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZXNwb25zZVByb21pc2U6IFByb21pc2U8QVBJUmVzcG9uc2VQcm9wcz4sXG4gICAgcHJpdmF0ZSBwYXJzZVJlc3BvbnNlOiAoXG4gICAgICBwcm9wczogQVBJUmVzcG9uc2VQcm9wcyxcbiAgICApID0+IFByb21pc2VPclZhbHVlPFdpdGhSZXF1ZXN0SUQ8VD4+ID0gZGVmYXVsdFBhcnNlUmVzcG9uc2UsXG4gICkge1xuICAgIHN1cGVyKChyZXNvbHZlKSA9PiB7XG4gICAgICAvLyB0aGlzIGlzIG1heWJlIGEgYml0IHdlaXJkIGJ1dCB0aGlzIGhhcyB0byBiZSBhIG5vLW9wIHRvIG5vdCBpbXBsaWNpdGx5XG4gICAgICAvLyBwYXJzZSB0aGUgcmVzcG9uc2UgYm9keTsgaW5zdGVhZCAudGhlbiwgLmNhdGNoLCAuZmluYWxseSBhcmUgb3ZlcnJpZGRlblxuICAgICAgLy8gdG8gcGFyc2UgdGhlIHJlc3BvbnNlXG4gICAgICByZXNvbHZlKG51bGwgYXMgYW55KTtcbiAgICB9KTtcbiAgfVxuXG4gIF90aGVuVW53cmFwPFU+KHRyYW5zZm9ybTogKGRhdGE6IFQsIHByb3BzOiBBUElSZXNwb25zZVByb3BzKSA9PiBVKTogQVBJUHJvbWlzZTxVPiB7XG4gICAgcmV0dXJuIG5ldyBBUElQcm9taXNlKHRoaXMucmVzcG9uc2VQcm9taXNlLCBhc3luYyAocHJvcHMpID0+XG4gICAgICBfYWRkUmVxdWVzdElEKHRyYW5zZm9ybShhd2FpdCB0aGlzLnBhcnNlUmVzcG9uc2UocHJvcHMpLCBwcm9wcyksIHByb3BzLnJlc3BvbnNlKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHJhdyBgUmVzcG9uc2VgIGluc3RhbmNlIGluc3RlYWQgb2YgcGFyc2luZyB0aGUgcmVzcG9uc2VcbiAgICogZGF0YS5cbiAgICpcbiAgICogSWYgeW91IHdhbnQgdG8gcGFyc2UgdGhlIHJlc3BvbnNlIGJvZHkgYnV0IHN0aWxsIGdldCB0aGUgYFJlc3BvbnNlYFxuICAgKiBpbnN0YW5jZSwgeW91IGNhbiB1c2Uge0BsaW5rIHdpdGhSZXNwb25zZSgpfS5cbiAgICpcbiAgICogXHVEODNEXHVEQzRCIEdldHRpbmcgdGhlIHdyb25nIFR5cGVTY3JpcHQgdHlwZSBmb3IgYFJlc3BvbnNlYD9cbiAgICogVHJ5IHNldHRpbmcgYFwibW9kdWxlUmVzb2x1dGlvblwiOiBcIk5vZGVOZXh0XCJgIGlmIHlvdSBjYW4sXG4gICAqIG9yIGFkZCBvbmUgb2YgdGhlc2UgaW1wb3J0cyBiZWZvcmUgeW91ciBmaXJzdCBgaW1wb3J0IFx1MjAyNiBmcm9tICdvcGVuYWknYDpcbiAgICogLSBgaW1wb3J0ICdvcGVuYWkvc2hpbXMvbm9kZSdgIChpZiB5b3UncmUgcnVubmluZyBvbiBOb2RlKVxuICAgKiAtIGBpbXBvcnQgJ29wZW5haS9zaGltcy93ZWInYCAob3RoZXJ3aXNlKVxuICAgKi9cbiAgYXNSZXNwb25zZSgpOiBQcm9taXNlPFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2VQcm9taXNlLnRoZW4oKHApID0+IHAucmVzcG9uc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHBhcnNlZCByZXNwb25zZSBkYXRhLCB0aGUgcmF3IGBSZXNwb25zZWAgaW5zdGFuY2UgYW5kIHRoZSBJRCBvZiB0aGUgcmVxdWVzdCxcbiAgICogcmV0dXJuZWQgdmlhIHRoZSBYLVJlcXVlc3QtSUQgaGVhZGVyIHdoaWNoIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nIHJlcXVlc3RzIGFuZCByZXBvcnRpbmdcbiAgICogaXNzdWVzIHRvIE9wZW5BSS5cbiAgICpcbiAgICogSWYgeW91IGp1c3Qgd2FudCB0byBnZXQgdGhlIHJhdyBgUmVzcG9uc2VgIGluc3RhbmNlIHdpdGhvdXQgcGFyc2luZyBpdCxcbiAgICogeW91IGNhbiB1c2Uge0BsaW5rIGFzUmVzcG9uc2UoKX0uXG4gICAqXG4gICAqXG4gICAqIFx1RDgzRFx1REM0QiBHZXR0aW5nIHRoZSB3cm9uZyBUeXBlU2NyaXB0IHR5cGUgZm9yIGBSZXNwb25zZWA/XG4gICAqIFRyeSBzZXR0aW5nIGBcIm1vZHVsZVJlc29sdXRpb25cIjogXCJOb2RlTmV4dFwiYCBpZiB5b3UgY2FuLFxuICAgKiBvciBhZGQgb25lIG9mIHRoZXNlIGltcG9ydHMgYmVmb3JlIHlvdXIgZmlyc3QgYGltcG9ydCBcdTIwMjYgZnJvbSAnb3BlbmFpJ2A6XG4gICAqIC0gYGltcG9ydCAnb3BlbmFpL3NoaW1zL25vZGUnYCAoaWYgeW91J3JlIHJ1bm5pbmcgb24gTm9kZSlcbiAgICogLSBgaW1wb3J0ICdvcGVuYWkvc2hpbXMvd2ViJ2AgKG90aGVyd2lzZSlcbiAgICovXG4gIGFzeW5jIHdpdGhSZXNwb25zZSgpOiBQcm9taXNlPHsgZGF0YTogVDsgcmVzcG9uc2U6IFJlc3BvbnNlOyByZXF1ZXN0X2lkOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkIH0+IHtcbiAgICBjb25zdCBbZGF0YSwgcmVzcG9uc2VdID0gYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMucGFyc2UoKSwgdGhpcy5hc1Jlc3BvbnNlKCldKTtcbiAgICByZXR1cm4geyBkYXRhLCByZXNwb25zZSwgcmVxdWVzdF9pZDogcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtcmVxdWVzdC1pZCcpIH07XG4gIH1cblxuICBwcml2YXRlIHBhcnNlKCk6IFByb21pc2U8V2l0aFJlcXVlc3RJRDxUPj4ge1xuICAgIGlmICghdGhpcy5wYXJzZWRQcm9taXNlKSB7XG4gICAgICB0aGlzLnBhcnNlZFByb21pc2UgPSB0aGlzLnJlc3BvbnNlUHJvbWlzZS50aGVuKHRoaXMucGFyc2VSZXNwb25zZSkgYXMgYW55IGFzIFByb21pc2U8V2l0aFJlcXVlc3RJRDxUPj47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlZFByb21pc2U7XG4gIH1cblxuICBvdmVycmlkZSB0aGVuPFRSZXN1bHQxID0gV2l0aFJlcXVlc3RJRDxUPiwgVFJlc3VsdDIgPSBuZXZlcj4oXG4gICAgb25mdWxmaWxsZWQ/OiAoKHZhbHVlOiBXaXRoUmVxdWVzdElEPFQ+KSA9PiBUUmVzdWx0MSB8IFByb21pc2VMaWtlPFRSZXN1bHQxPikgfCB1bmRlZmluZWQgfCBudWxsLFxuICAgIG9ucmVqZWN0ZWQ/OiAoKHJlYXNvbjogYW55KSA9PiBUUmVzdWx0MiB8IFByb21pc2VMaWtlPFRSZXN1bHQyPikgfCB1bmRlZmluZWQgfCBudWxsLFxuICApOiBQcm9taXNlPFRSZXN1bHQxIHwgVFJlc3VsdDI+IHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZSgpLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuICB9XG5cbiAgb3ZlcnJpZGUgY2F0Y2g8VFJlc3VsdCA9IG5ldmVyPihcbiAgICBvbnJlamVjdGVkPzogKChyZWFzb246IGFueSkgPT4gVFJlc3VsdCB8IFByb21pc2VMaWtlPFRSZXN1bHQ+KSB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICk6IFByb21pc2U8V2l0aFJlcXVlc3RJRDxUPiB8IFRSZXN1bHQ+IHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZSgpLmNhdGNoKG9ucmVqZWN0ZWQpO1xuICB9XG5cbiAgb3ZlcnJpZGUgZmluYWxseShvbmZpbmFsbHk/OiAoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWQgfCBudWxsKTogUHJvbWlzZTxXaXRoUmVxdWVzdElEPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2UoKS5maW5hbGx5KG9uZmluYWxseSk7XG4gIH1cbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFQSUNsaWVudCB7XG4gIGJhc2VVUkw6IHN0cmluZztcbiAgbWF4UmV0cmllczogbnVtYmVyO1xuICB0aW1lb3V0OiBudW1iZXI7XG4gIGh0dHBBZ2VudDogQWdlbnQgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBmZXRjaDogRmV0Y2g7XG4gIHByb3RlY3RlZCBpZGVtcG90ZW5jeUhlYWRlcj86IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmFzZVVSTCxcbiAgICBtYXhSZXRyaWVzID0gMixcbiAgICB0aW1lb3V0ID0gNjAwMDAwLCAvLyAxMCBtaW51dGVzXG4gICAgaHR0cEFnZW50LFxuICAgIGZldGNoOiBvdmVycmlkZGVuRmV0Y2gsXG4gIH06IHtcbiAgICBiYXNlVVJMOiBzdHJpbmc7XG4gICAgbWF4UmV0cmllcz86IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICB0aW1lb3V0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgaHR0cEFnZW50OiBBZ2VudCB8IHVuZGVmaW5lZDtcbiAgICBmZXRjaDogRmV0Y2ggfCB1bmRlZmluZWQ7XG4gIH0pIHtcbiAgICB0aGlzLmJhc2VVUkwgPSBiYXNlVVJMO1xuICAgIHRoaXMubWF4UmV0cmllcyA9IHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKCdtYXhSZXRyaWVzJywgbWF4UmV0cmllcyk7XG4gICAgdGhpcy50aW1lb3V0ID0gdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoJ3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICB0aGlzLmh0dHBBZ2VudCA9IGh0dHBBZ2VudDtcblxuICAgIHRoaXMuZmV0Y2ggPSBvdmVycmlkZGVuRmV0Y2ggPz8gZmV0Y2g7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXV0aEhlYWRlcnMob3B0czogRmluYWxSZXF1ZXN0T3B0aW9ucyk6IEhlYWRlcnMge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGlzIHRvIGFkZCB5b3VyIG93biBkZWZhdWx0IGhlYWRlcnMsIGZvciBleGFtcGxlOlxuICAgKlxuICAgKiAge1xuICAgKiAgICAuLi5zdXBlci5kZWZhdWx0SGVhZGVycygpLFxuICAgKiAgICBBdXRob3JpemF0aW9uOiAnQmVhcmVyIDEyMycsXG4gICAqICB9XG4gICAqL1xuICBwcm90ZWN0ZWQgZGVmYXVsdEhlYWRlcnMob3B0czogRmluYWxSZXF1ZXN0T3B0aW9ucyk6IEhlYWRlcnMge1xuICAgIHJldHVybiB7XG4gICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnVXNlci1BZ2VudCc6IHRoaXMuZ2V0VXNlckFnZW50KCksXG4gICAgICAuLi5nZXRQbGF0Zm9ybUhlYWRlcnMoKSxcbiAgICAgIC4uLnRoaXMuYXV0aEhlYWRlcnMob3B0cyksXG4gICAgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBkZWZhdWx0UXVlcnkoKTogRGVmYXVsdFF1ZXJ5IHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGlzIHRvIGFkZCB5b3VyIG93biBoZWFkZXJzIHZhbGlkYXRpb246XG4gICAqL1xuICBwcm90ZWN0ZWQgdmFsaWRhdGVIZWFkZXJzKGhlYWRlcnM6IEhlYWRlcnMsIGN1c3RvbUhlYWRlcnM6IEhlYWRlcnMpIHt9XG5cbiAgcHJvdGVjdGVkIGRlZmF1bHRJZGVtcG90ZW5jeUtleSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgc3RhaW5sZXNzLW5vZGUtcmV0cnktJHt1dWlkNCgpfWA7XG4gIH1cblxuICBnZXQ8UmVxLCBSc3A+KHBhdGg6IHN0cmluZywgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+KTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdnZXQnLCBwYXRoLCBvcHRzKTtcbiAgfVxuXG4gIHBvc3Q8UmVxLCBSc3A+KHBhdGg6IHN0cmluZywgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+KTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwb3N0JywgcGF0aCwgb3B0cyk7XG4gIH1cblxuICBwYXRjaDxSZXEsIFJzcD4ocGF0aDogc3RyaW5nLCBvcHRzPzogUHJvbWlzZU9yVmFsdWU8UmVxdWVzdE9wdGlvbnM8UmVxPj4pOiBBUElQcm9taXNlPFJzcD4ge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoJ3BhdGNoJywgcGF0aCwgb3B0cyk7XG4gIH1cblxuICBwdXQ8UmVxLCBSc3A+KHBhdGg6IHN0cmluZywgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+KTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwdXQnLCBwYXRoLCBvcHRzKTtcbiAgfVxuXG4gIGRlbGV0ZTxSZXEsIFJzcD4ocGF0aDogc3RyaW5nLCBvcHRzPzogUHJvbWlzZU9yVmFsdWU8UmVxdWVzdE9wdGlvbnM8UmVxPj4pOiBBUElQcm9taXNlPFJzcD4ge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoJ2RlbGV0ZScsIHBhdGgsIG9wdHMpO1xuICB9XG5cbiAgcHJpdmF0ZSBtZXRob2RSZXF1ZXN0PFJlcSwgUnNwPihcbiAgICBtZXRob2Q6IEhUVFBNZXRob2QsXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG9wdHM/OiBQcm9taXNlT3JWYWx1ZTxSZXF1ZXN0T3B0aW9uczxSZXE+PixcbiAgKTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFxuICAgICAgUHJvbWlzZS5yZXNvbHZlKG9wdHMpLnRoZW4oYXN5bmMgKG9wdHMpID0+IHtcbiAgICAgICAgY29uc3QgYm9keSA9XG4gICAgICAgICAgb3B0cyAmJiBpc0Jsb2JMaWtlKG9wdHM/LmJvZHkpID8gbmV3IERhdGFWaWV3KGF3YWl0IG9wdHMuYm9keS5hcnJheUJ1ZmZlcigpKVxuICAgICAgICAgIDogb3B0cz8uYm9keSBpbnN0YW5jZW9mIERhdGFWaWV3ID8gb3B0cy5ib2R5XG4gICAgICAgICAgOiBvcHRzPy5ib2R5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgRGF0YVZpZXcob3B0cy5ib2R5KVxuICAgICAgICAgIDogb3B0cyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcob3B0cz8uYm9keSkgPyBuZXcgRGF0YVZpZXcob3B0cy5ib2R5LmJ1ZmZlcilcbiAgICAgICAgICA6IG9wdHM/LmJvZHk7XG4gICAgICAgIHJldHVybiB7IG1ldGhvZCwgcGF0aCwgLi4ub3B0cywgYm9keSB9O1xuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIGdldEFQSUxpc3Q8SXRlbSwgUGFnZUNsYXNzIGV4dGVuZHMgQWJzdHJhY3RQYWdlPEl0ZW0+ID0gQWJzdHJhY3RQYWdlPEl0ZW0+PihcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgUGFnZTogbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gUGFnZUNsYXNzLFxuICAgIG9wdHM/OiBSZXF1ZXN0T3B0aW9uczxhbnk+LFxuICApOiBQYWdlUHJvbWlzZTxQYWdlQ2xhc3MsIEl0ZW0+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QVBJTGlzdChQYWdlLCB7IG1ldGhvZDogJ2dldCcsIHBhdGgsIC4uLm9wdHMgfSk7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUNvbnRlbnRMZW5ndGgoYm9keTogdW5rbm93bik6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoYm9keSwgJ3V0ZjgnKS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIFRleHRFbmNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVyLmVuY29kZShib2R5KTtcbiAgICAgICAgcmV0dXJuIGVuY29kZWQubGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkpIHtcbiAgICAgIHJldHVybiBib2R5LmJ5dGVMZW5ndGgudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGJ1aWxkUmVxdWVzdDxSZXE+KFxuICAgIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnM8UmVxPixcbiAgICB7IHJldHJ5Q291bnQgPSAwIH06IHsgcmV0cnlDb3VudD86IG51bWJlciB9ID0ge30sXG4gICk6IHsgcmVxOiBSZXF1ZXN0SW5pdDsgdXJsOiBzdHJpbmc7IHRpbWVvdXQ6IG51bWJlciB9IHtcbiAgICBjb25zdCB7IG1ldGhvZCwgcGF0aCwgcXVlcnksIGhlYWRlcnM6IGhlYWRlcnMgPSB7fSB9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGJvZHkgPVxuICAgICAgQXJyYXlCdWZmZXIuaXNWaWV3KG9wdGlvbnMuYm9keSkgfHwgKG9wdGlvbnMuX19iaW5hcnlSZXF1ZXN0ICYmIHR5cGVvZiBvcHRpb25zLmJvZHkgPT09ICdzdHJpbmcnKSA/XG4gICAgICAgIG9wdGlvbnMuYm9keVxuICAgICAgOiBpc011bHRpcGFydEJvZHkob3B0aW9ucy5ib2R5KSA/IG9wdGlvbnMuYm9keS5ib2R5XG4gICAgICA6IG9wdGlvbnMuYm9keSA/IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9keSwgbnVsbCwgMilcbiAgICAgIDogbnVsbDtcbiAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gdGhpcy5jYWxjdWxhdGVDb250ZW50TGVuZ3RoKGJvZHkpO1xuXG4gICAgY29uc3QgdXJsID0gdGhpcy5idWlsZFVSTChwYXRoISwgcXVlcnkpO1xuICAgIGlmICgndGltZW91dCcgaW4gb3B0aW9ucykgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoJ3RpbWVvdXQnLCBvcHRpb25zLnRpbWVvdXQpO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgPz8gdGhpcy50aW1lb3V0O1xuICAgIGNvbnN0IGh0dHBBZ2VudCA9IG9wdGlvbnMuaHR0cEFnZW50ID8/IHRoaXMuaHR0cEFnZW50ID8/IGdldERlZmF1bHRBZ2VudCh1cmwpO1xuICAgIGNvbnN0IG1pbkFnZW50VGltZW91dCA9IHRpbWVvdXQgKyAxMDAwO1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiAoaHR0cEFnZW50IGFzIGFueSk/Lm9wdGlvbnM/LnRpbWVvdXQgPT09ICdudW1iZXInICYmXG4gICAgICBtaW5BZ2VudFRpbWVvdXQgPiAoKGh0dHBBZ2VudCBhcyBhbnkpLm9wdGlvbnMudGltZW91dCA/PyAwKVxuICAgICkge1xuICAgICAgLy8gQWxsb3cgYW55IGdpdmVuIHJlcXVlc3QgdG8gYnVtcCBvdXIgYWdlbnQgYWN0aXZlIHNvY2tldCB0aW1lb3V0LlxuICAgICAgLy8gVGhpcyBtYXkgc2VlbSBzdHJhbmdlLCBidXQgbGVha2luZyBhY3RpdmUgc29ja2V0cyBzaG91bGQgYmUgcmFyZSBhbmQgbm90IHBhcnRpY3VsYXJseSBwcm9ibGVtYXRpYyxcbiAgICAgIC8vIGFuZCB3aXRob3V0IG11dGF0aW5nIGFnZW50IHdlIHdvdWxkIG5lZWQgdG8gY3JlYXRlIG1vcmUgb2YgdGhlbS5cbiAgICAgIC8vIFRoaXMgdHJhZGVvZmYgb3B0aW1pemVzIGZvciBwZXJmb3JtYW5jZS5cbiAgICAgIChodHRwQWdlbnQgYXMgYW55KS5vcHRpb25zLnRpbWVvdXQgPSBtaW5BZ2VudFRpbWVvdXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaWRlbXBvdGVuY3lIZWFkZXIgJiYgbWV0aG9kICE9PSAnZ2V0Jykge1xuICAgICAgaWYgKCFvcHRpb25zLmlkZW1wb3RlbmN5S2V5KSBvcHRpb25zLmlkZW1wb3RlbmN5S2V5ID0gdGhpcy5kZWZhdWx0SWRlbXBvdGVuY3lLZXkoKTtcbiAgICAgIGhlYWRlcnNbdGhpcy5pZGVtcG90ZW5jeUhlYWRlcl0gPSBvcHRpb25zLmlkZW1wb3RlbmN5S2V5O1xuICAgIH1cblxuICAgIGNvbnN0IHJlcUhlYWRlcnMgPSB0aGlzLmJ1aWxkSGVhZGVycyh7IG9wdGlvbnMsIGhlYWRlcnMsIGNvbnRlbnRMZW5ndGgsIHJldHJ5Q291bnQgfSk7XG5cbiAgICBjb25zdCByZXE6IFJlcXVlc3RJbml0ID0ge1xuICAgICAgbWV0aG9kLFxuICAgICAgLi4uKGJvZHkgJiYgeyBib2R5OiBib2R5IGFzIGFueSB9KSxcbiAgICAgIGhlYWRlcnM6IHJlcUhlYWRlcnMsXG4gICAgICAuLi4oaHR0cEFnZW50ICYmIHsgYWdlbnQ6IGh0dHBBZ2VudCB9KSxcbiAgICAgIC8vIEB0cy1pZ25vcmUgbm9kZS1mZXRjaCB1c2VzIGEgY3VzdG9tIEFib3J0U2lnbmFsIHR5cGUgdGhhdCBpc1xuICAgICAgLy8gbm90IGNvbXBhdGlibGUgd2l0aCBzdGFuZGFyZCB3ZWIgdHlwZXNcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwgPz8gbnVsbCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHsgcmVxLCB1cmwsIHRpbWVvdXQgfTtcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRIZWFkZXJzKHtcbiAgICBvcHRpb25zLFxuICAgIGhlYWRlcnMsXG4gICAgY29udGVudExlbmd0aCxcbiAgICByZXRyeUNvdW50LFxuICB9OiB7XG4gICAgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucztcbiAgICBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPjtcbiAgICBjb250ZW50TGVuZ3RoOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xuICAgIHJldHJ5Q291bnQ6IG51bWJlcjtcbiAgfSk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIGNvbnN0IHJlcUhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICBpZiAoY29udGVudExlbmd0aCkge1xuICAgICAgcmVxSGVhZGVyc1snY29udGVudC1sZW5ndGgnXSA9IGNvbnRlbnRMZW5ndGg7XG4gICAgfVxuXG4gICAgY29uc3QgZGVmYXVsdEhlYWRlcnMgPSB0aGlzLmRlZmF1bHRIZWFkZXJzKG9wdGlvbnMpO1xuICAgIGFwcGx5SGVhZGVyc011dChyZXFIZWFkZXJzLCBkZWZhdWx0SGVhZGVycyk7XG4gICAgYXBwbHlIZWFkZXJzTXV0KHJlcUhlYWRlcnMsIGhlYWRlcnMpO1xuXG4gICAgLy8gbGV0IGJ1aWx0aW4gZmV0Y2ggc2V0IHRoZSBDb250ZW50LVR5cGUgZm9yIG11bHRpcGFydCBib2RpZXNcbiAgICBpZiAoaXNNdWx0aXBhcnRCb2R5KG9wdGlvbnMuYm9keSkgJiYgc2hpbXNLaW5kICE9PSAnbm9kZScpIHtcbiAgICAgIGRlbGV0ZSByZXFIZWFkZXJzWydjb250ZW50LXR5cGUnXTtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBzZXQgdGhlIHJldHJ5IGNvdW50IGhlYWRlciBpZiBpdCB3YXMgYWxyZWFkeSBzZXQgb3IgcmVtb3ZlZCB0aHJvdWdoIGRlZmF1bHQgaGVhZGVycyBvciBieSB0aGVcbiAgICAvLyBjYWxsZXIuIFdlIGNoZWNrIGBkZWZhdWx0SGVhZGVyc2AgYW5kIGBoZWFkZXJzYCwgd2hpY2ggY2FuIGNvbnRhaW4gbnVsbHMsIGluc3RlYWQgb2YgYHJlcUhlYWRlcnNgIHRvXG4gICAgLy8gYWNjb3VudCBmb3IgdGhlIHJlbW92YWwgY2FzZS5cbiAgICBpZiAoXG4gICAgICBnZXRIZWFkZXIoZGVmYXVsdEhlYWRlcnMsICd4LXN0YWlubGVzcy1yZXRyeS1jb3VudCcpID09PSB1bmRlZmluZWQgJiZcbiAgICAgIGdldEhlYWRlcihoZWFkZXJzLCAneC1zdGFpbmxlc3MtcmV0cnktY291bnQnKSA9PT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICByZXFIZWFkZXJzWyd4LXN0YWlubGVzcy1yZXRyeS1jb3VudCddID0gU3RyaW5nKHJldHJ5Q291bnQpO1xuICAgIH1cblxuICAgIHRoaXMudmFsaWRhdGVIZWFkZXJzKHJlcUhlYWRlcnMsIGhlYWRlcnMpO1xuXG4gICAgcmV0dXJuIHJlcUhlYWRlcnM7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBhcyBhIGNhbGxiYWNrIGZvciBtdXRhdGluZyB0aGUgZ2l2ZW4gYEZpbmFsUmVxdWVzdE9wdGlvbnNgIG9iamVjdC5cbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBwcmVwYXJlT3B0aW9ucyhvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7fVxuXG4gIC8qKlxuICAgKiBVc2VkIGFzIGEgY2FsbGJhY2sgZm9yIG11dGF0aW5nIHRoZSBnaXZlbiBgUmVxdWVzdEluaXRgIG9iamVjdC5cbiAgICpcbiAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGNhc2VzIHdoZXJlIHlvdSB3YW50IHRvIGFkZCBjZXJ0YWluIGhlYWRlcnMgYmFzZWQgb2ZmIG9mXG4gICAqIHRoZSByZXF1ZXN0IHByb3BlcnRpZXMsIGUuZy4gYG1ldGhvZGAgb3IgYHVybGAuXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgcHJlcGFyZVJlcXVlc3QoXG4gICAgcmVxdWVzdDogUmVxdWVzdEluaXQsXG4gICAgeyB1cmwsIG9wdGlvbnMgfTogeyB1cmw6IHN0cmluZzsgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucyB9LFxuICApOiBQcm9taXNlPHZvaWQ+IHt9XG5cbiAgcHJvdGVjdGVkIHBhcnNlSGVhZGVycyhoZWFkZXJzOiBIZWFkZXJzSW5pdCB8IG51bGwgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICByZXR1cm4gKFxuICAgICAgIWhlYWRlcnMgPyB7fVxuICAgICAgOiBTeW1ib2wuaXRlcmF0b3IgaW4gaGVhZGVycyA/XG4gICAgICAgIE9iamVjdC5mcm9tRW50cmllcyhBcnJheS5mcm9tKGhlYWRlcnMgYXMgSXRlcmFibGU8c3RyaW5nW10+KS5tYXAoKGhlYWRlcikgPT4gWy4uLmhlYWRlcl0pKVxuICAgICAgOiB7IC4uLmhlYWRlcnMgfVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgbWFrZVN0YXR1c0Vycm9yKFxuICAgIHN0YXR1czogbnVtYmVyIHwgdW5kZWZpbmVkLFxuICAgIGVycm9yOiBPYmplY3QgfCB1bmRlZmluZWQsXG4gICAgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIGhlYWRlcnM6IEhlYWRlcnMgfCB1bmRlZmluZWQsXG4gICk6IEFQSUVycm9yIHtcbiAgICByZXR1cm4gQVBJRXJyb3IuZ2VuZXJhdGUoc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gIH1cblxuICByZXF1ZXN0PFJlcSwgUnNwPihcbiAgICBvcHRpb25zOiBQcm9taXNlT3JWYWx1ZTxGaW5hbFJlcXVlc3RPcHRpb25zPFJlcT4+LFxuICAgIHJlbWFpbmluZ1JldHJpZXM6IG51bWJlciB8IG51bGwgPSBudWxsLFxuICApOiBBUElQcm9taXNlPFJzcD4ge1xuICAgIHJldHVybiBuZXcgQVBJUHJvbWlzZSh0aGlzLm1ha2VSZXF1ZXN0KG9wdGlvbnMsIHJlbWFpbmluZ1JldHJpZXMpKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbWFrZVJlcXVlc3Q8UmVxPihcbiAgICBvcHRpb25zSW5wdXQ6IFByb21pc2VPclZhbHVlPEZpbmFsUmVxdWVzdE9wdGlvbnM8UmVxPj4sXG4gICAgcmV0cmllc1JlbWFpbmluZzogbnVtYmVyIHwgbnVsbCxcbiAgKTogUHJvbWlzZTxBUElSZXNwb25zZVByb3BzPiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IG9wdGlvbnNJbnB1dDtcbiAgICBjb25zdCBtYXhSZXRyaWVzID0gb3B0aW9ucy5tYXhSZXRyaWVzID8/IHRoaXMubWF4UmV0cmllcztcbiAgICBpZiAocmV0cmllc1JlbWFpbmluZyA9PSBudWxsKSB7XG4gICAgICByZXRyaWVzUmVtYWluaW5nID0gbWF4UmV0cmllcztcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLnByZXBhcmVPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgY29uc3QgeyByZXEsIHVybCwgdGltZW91dCB9ID0gdGhpcy5idWlsZFJlcXVlc3Qob3B0aW9ucywgeyByZXRyeUNvdW50OiBtYXhSZXRyaWVzIC0gcmV0cmllc1JlbWFpbmluZyB9KTtcblxuICAgIGF3YWl0IHRoaXMucHJlcGFyZVJlcXVlc3QocmVxLCB7IHVybCwgb3B0aW9ucyB9KTtcblxuICAgIGRlYnVnKCdyZXF1ZXN0JywgdXJsLCBvcHRpb25zLCByZXEuaGVhZGVycyk7XG5cbiAgICBpZiAob3B0aW9ucy5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aFRpbWVvdXQodXJsLCByZXEsIHRpbWVvdXQsIGNvbnRyb2xsZXIpLmNhdGNoKGNhc3RUb0Vycm9yKTtcblxuICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBpZiAob3B0aW9ucy5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgICB9XG4gICAgICBpZiAocmV0cmllc1JlbWFpbmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3Qob3B0aW9ucywgcmV0cmllc1JlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICBpZiAocmVzcG9uc2UubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIHRocm93IG5ldyBBUElDb25uZWN0aW9uVGltZW91dEVycm9yKCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQVBJQ29ubmVjdGlvbkVycm9yKHsgY2F1c2U6IHJlc3BvbnNlIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGNyZWF0ZVJlc3BvbnNlSGVhZGVycyhyZXNwb25zZS5oZWFkZXJzKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGlmIChyZXRyaWVzUmVtYWluaW5nICYmIHRoaXMuc2hvdWxkUmV0cnkocmVzcG9uc2UpKSB7XG4gICAgICAgIGNvbnN0IHJldHJ5TWVzc2FnZSA9IGByZXRyeWluZywgJHtyZXRyaWVzUmVtYWluaW5nfSBhdHRlbXB0cyByZW1haW5pbmdgO1xuICAgICAgICBkZWJ1ZyhgcmVzcG9uc2UgKGVycm9yOyAke3JldHJ5TWVzc2FnZX0pYCwgcmVzcG9uc2Uuc3RhdHVzLCB1cmwsIHJlc3BvbnNlSGVhZGVycyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChvcHRpb25zLCByZXRyaWVzUmVtYWluaW5nLCByZXNwb25zZUhlYWRlcnMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlcnJUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKChlKSA9PiBjYXN0VG9FcnJvcihlKS5tZXNzYWdlKTtcbiAgICAgIGNvbnN0IGVyckpTT04gPSBzYWZlSlNPTihlcnJUZXh0KTtcbiAgICAgIGNvbnN0IGVyck1lc3NhZ2UgPSBlcnJKU09OID8gdW5kZWZpbmVkIDogZXJyVGV4dDtcbiAgICAgIGNvbnN0IHJldHJ5TWVzc2FnZSA9IHJldHJpZXNSZW1haW5pbmcgPyBgKGVycm9yOyBubyBtb3JlIHJldHJpZXMgbGVmdClgIDogYChlcnJvcjsgbm90IHJldHJ5YWJsZSlgO1xuXG4gICAgICBkZWJ1ZyhgcmVzcG9uc2UgKGVycm9yOyAke3JldHJ5TWVzc2FnZX0pYCwgcmVzcG9uc2Uuc3RhdHVzLCB1cmwsIHJlc3BvbnNlSGVhZGVycywgZXJyTWVzc2FnZSk7XG5cbiAgICAgIGNvbnN0IGVyciA9IHRoaXMubWFrZVN0YXR1c0Vycm9yKHJlc3BvbnNlLnN0YXR1cywgZXJySlNPTiwgZXJyTWVzc2FnZSwgcmVzcG9uc2VIZWFkZXJzKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICByZXR1cm4geyByZXNwb25zZSwgb3B0aW9ucywgY29udHJvbGxlciB9O1xuICB9XG5cbiAgcmVxdWVzdEFQSUxpc3Q8SXRlbSA9IHVua25vd24sIFBhZ2VDbGFzcyBleHRlbmRzIEFic3RyYWN0UGFnZTxJdGVtPiA9IEFic3RyYWN0UGFnZTxJdGVtPj4oXG4gICAgUGFnZTogbmV3ICguLi5hcmdzOiBDb25zdHJ1Y3RvclBhcmFtZXRlcnM8dHlwZW9mIEFic3RyYWN0UGFnZT4pID0+IFBhZ2VDbGFzcyxcbiAgICBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zLFxuICApOiBQYWdlUHJvbWlzZTxQYWdlQ2xhc3MsIEl0ZW0+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5tYWtlUmVxdWVzdChvcHRpb25zLCBudWxsKTtcbiAgICByZXR1cm4gbmV3IFBhZ2VQcm9taXNlPFBhZ2VDbGFzcywgSXRlbT4odGhpcywgcmVxdWVzdCwgUGFnZSk7XG4gIH1cblxuICBidWlsZFVSTDxSZXE+KHBhdGg6IHN0cmluZywgcXVlcnk6IFJlcSB8IG51bGwgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICAgIGNvbnN0IHVybCA9XG4gICAgICBpc0Fic29sdXRlVVJMKHBhdGgpID9cbiAgICAgICAgbmV3IFVSTChwYXRoKVxuICAgICAgOiBuZXcgVVJMKHRoaXMuYmFzZVVSTCArICh0aGlzLmJhc2VVUkwuZW5kc1dpdGgoJy8nKSAmJiBwYXRoLnN0YXJ0c1dpdGgoJy8nKSA/IHBhdGguc2xpY2UoMSkgOiBwYXRoKSk7XG5cbiAgICBjb25zdCBkZWZhdWx0UXVlcnkgPSB0aGlzLmRlZmF1bHRRdWVyeSgpO1xuICAgIGlmICghaXNFbXB0eU9iaihkZWZhdWx0UXVlcnkpKSB7XG4gICAgICBxdWVyeSA9IHsgLi4uZGVmYXVsdFF1ZXJ5LCAuLi5xdWVyeSB9IGFzIFJlcTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0JyAmJiBxdWVyeSAmJiAhQXJyYXkuaXNBcnJheShxdWVyeSkpIHtcbiAgICAgIHVybC5zZWFyY2ggPSB0aGlzLnN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5IGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RyaW5naWZ5UXVlcnkocXVlcnk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogc3RyaW5nIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMocXVlcnkpXG4gICAgICAuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKVxuICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09YDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoXG4gICAgICAgICAgYENhbm5vdCBzdHJpbmdpZnkgdHlwZSAke3R5cGVvZiB2YWx1ZX07IEV4cGVjdGVkIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBudWxsLiBJZiB5b3UgbmVlZCB0byBwYXNzIG5lc3RlZCBxdWVyeSBwYXJhbWV0ZXJzLCB5b3UgY2FuIG1hbnVhbGx5IGVuY29kZSB0aGVtLCBlLmcuIHsgcXVlcnk6IHsgJ2Zvb1trZXkxXSc6IHZhbHVlMSwgJ2Zvb1trZXkyXSc6IHZhbHVlMiB9IH0sIGFuZCBwbGVhc2Ugb3BlbiBhIEdpdEh1YiBpc3N1ZSByZXF1ZXN0aW5nIGJldHRlciBzdXBwb3J0IGZvciB5b3VyIHVzZSBjYXNlLmAsXG4gICAgICAgICk7XG4gICAgICB9KVxuICAgICAgLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoV2l0aFRpbWVvdXQoXG4gICAgdXJsOiBSZXF1ZXN0SW5mbyxcbiAgICBpbml0OiBSZXF1ZXN0SW5pdCB8IHVuZGVmaW5lZCxcbiAgICBtczogbnVtYmVyLFxuICAgIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcixcbiAgKTogUHJvbWlzZTxSZXNwb25zZT4ge1xuICAgIGNvbnN0IHsgc2lnbmFsLCAuLi5vcHRpb25zIH0gPSBpbml0IHx8IHt9O1xuICAgIGlmIChzaWduYWwpIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSk7XG5cbiAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIG1zKTtcblxuICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IHtcbiAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwgYXMgYW55LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuICAgIGlmIChmZXRjaE9wdGlvbnMubWV0aG9kKSB7XG4gICAgICAvLyBDdXN0b20gbWV0aG9kcyBsaWtlICdwYXRjaCcgbmVlZCB0byBiZSB1cHBlcmNhc2VkXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzIyOTRcbiAgICAgIGZldGNoT3B0aW9ucy5tZXRob2QgPSBmZXRjaE9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIC8vIHVzZSB1bmRlZmluZWQgdGhpcyBiaW5kaW5nOyBmZXRjaCBlcnJvcnMgaWYgYm91bmQgdG8gc29tZXRoaW5nIGVsc2UgaW4gYnJvd3Nlci9jbG91ZGZsYXJlXG4gICAgICB0aGlzLmZldGNoLmNhbGwodW5kZWZpbmVkLCB1cmwsIGZldGNoT3B0aW9ucykuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc2hvdWxkUmV0cnkocmVzcG9uc2U6IFJlc3BvbnNlKTogYm9vbGVhbiB7XG4gICAgLy8gTm90ZSB0aGlzIGlzIG5vdCBhIHN0YW5kYXJkIGhlYWRlci5cbiAgICBjb25zdCBzaG91bGRSZXRyeUhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXNob3VsZC1yZXRyeScpO1xuXG4gICAgLy8gSWYgdGhlIHNlcnZlciBleHBsaWNpdGx5IHNheXMgd2hldGhlciBvciBub3QgdG8gcmV0cnksIG9iZXkuXG4gICAgaWYgKHNob3VsZFJldHJ5SGVhZGVyID09PSAndHJ1ZScpIHJldHVybiB0cnVlO1xuICAgIGlmIChzaG91bGRSZXRyeUhlYWRlciA9PT0gJ2ZhbHNlJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gUmV0cnkgb24gcmVxdWVzdCB0aW1lb3V0cy5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDgpIHJldHVybiB0cnVlO1xuXG4gICAgLy8gUmV0cnkgb24gbG9jayB0aW1lb3V0cy5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDkpIHJldHVybiB0cnVlO1xuXG4gICAgLy8gUmV0cnkgb24gcmF0ZSBsaW1pdHMuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIFJldHJ5IGludGVybmFsIGVycm9ycy5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDUwMCkgcmV0dXJuIHRydWU7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJldHJ5UmVxdWVzdChcbiAgICBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zLFxuICAgIHJldHJpZXNSZW1haW5pbmc6IG51bWJlcixcbiAgICByZXNwb25zZUhlYWRlcnM/OiBIZWFkZXJzIHwgdW5kZWZpbmVkLFxuICApOiBQcm9taXNlPEFQSVJlc3BvbnNlUHJvcHM+IHtcbiAgICBsZXQgdGltZW91dE1pbGxpczogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gICAgLy8gTm90ZSB0aGUgYHJldHJ5LWFmdGVyLW1zYCBoZWFkZXIgbWF5IG5vdCBiZSBzdGFuZGFyZCwgYnV0IGlzIGEgZ29vZCBpZGVhIGFuZCB3ZSdkIGxpa2UgcHJvYWN0aXZlIHN1cHBvcnQgZm9yIGl0LlxuICAgIGNvbnN0IHJldHJ5QWZ0ZXJNaWxsaXNIZWFkZXIgPSByZXNwb25zZUhlYWRlcnM/LlsncmV0cnktYWZ0ZXItbXMnXTtcbiAgICBpZiAocmV0cnlBZnRlck1pbGxpc0hlYWRlcikge1xuICAgICAgY29uc3QgdGltZW91dE1zID0gcGFyc2VGbG9hdChyZXRyeUFmdGVyTWlsbGlzSGVhZGVyKTtcbiAgICAgIGlmICghTnVtYmVyLmlzTmFOKHRpbWVvdXRNcykpIHtcbiAgICAgICAgdGltZW91dE1pbGxpcyA9IHRpbWVvdXRNcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBYm91dCB0aGUgUmV0cnktQWZ0ZXIgaGVhZGVyOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvUmV0cnktQWZ0ZXJcbiAgICBjb25zdCByZXRyeUFmdGVySGVhZGVyID0gcmVzcG9uc2VIZWFkZXJzPy5bJ3JldHJ5LWFmdGVyJ107XG4gICAgaWYgKHJldHJ5QWZ0ZXJIZWFkZXIgJiYgIXRpbWVvdXRNaWxsaXMpIHtcbiAgICAgIGNvbnN0IHRpbWVvdXRTZWNvbmRzID0gcGFyc2VGbG9hdChyZXRyeUFmdGVySGVhZGVyKTtcbiAgICAgIGlmICghTnVtYmVyLmlzTmFOKHRpbWVvdXRTZWNvbmRzKSkge1xuICAgICAgICB0aW1lb3V0TWlsbGlzID0gdGltZW91dFNlY29uZHMgKiAxMDAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dE1pbGxpcyA9IERhdGUucGFyc2UocmV0cnlBZnRlckhlYWRlcikgLSBEYXRlLm5vdygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBBUEkgYXNrcyB1cyB0byB3YWl0IGEgY2VydGFpbiBhbW91bnQgb2YgdGltZSAoYW5kIGl0J3MgYSByZWFzb25hYmxlIGFtb3VudCksXG4gICAgLy8ganVzdCBkbyB3aGF0IGl0IHNheXMsIGJ1dCBvdGhlcndpc2UgY2FsY3VsYXRlIGEgZGVmYXVsdFxuICAgIGlmICghKHRpbWVvdXRNaWxsaXMgJiYgMCA8PSB0aW1lb3V0TWlsbGlzICYmIHRpbWVvdXRNaWxsaXMgPCA2MCAqIDEwMDApKSB7XG4gICAgICBjb25zdCBtYXhSZXRyaWVzID0gb3B0aW9ucy5tYXhSZXRyaWVzID8/IHRoaXMubWF4UmV0cmllcztcbiAgICAgIHRpbWVvdXRNaWxsaXMgPSB0aGlzLmNhbGN1bGF0ZURlZmF1bHRSZXRyeVRpbWVvdXRNaWxsaXMocmV0cmllc1JlbWFpbmluZywgbWF4UmV0cmllcyk7XG4gICAgfVxuICAgIGF3YWl0IHNsZWVwKHRpbWVvdXRNaWxsaXMpO1xuXG4gICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3Qob3B0aW9ucywgcmV0cmllc1JlbWFpbmluZyAtIDEpO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVEZWZhdWx0UmV0cnlUaW1lb3V0TWlsbGlzKHJldHJpZXNSZW1haW5pbmc6IG51bWJlciwgbWF4UmV0cmllczogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBpbml0aWFsUmV0cnlEZWxheSA9IDAuNTtcbiAgICBjb25zdCBtYXhSZXRyeURlbGF5ID0gOC4wO1xuXG4gICAgY29uc3QgbnVtUmV0cmllcyA9IG1heFJldHJpZXMgLSByZXRyaWVzUmVtYWluaW5nO1xuXG4gICAgLy8gQXBwbHkgZXhwb25lbnRpYWwgYmFja29mZiwgYnV0IG5vdCBtb3JlIHRoYW4gdGhlIG1heC5cbiAgICBjb25zdCBzbGVlcFNlY29uZHMgPSBNYXRoLm1pbihpbml0aWFsUmV0cnlEZWxheSAqIE1hdGgucG93KDIsIG51bVJldHJpZXMpLCBtYXhSZXRyeURlbGF5KTtcblxuICAgIC8vIEFwcGx5IHNvbWUgaml0dGVyLCB0YWtlIHVwIHRvIGF0IG1vc3QgMjUgcGVyY2VudCBvZiB0aGUgcmV0cnkgdGltZS5cbiAgICBjb25zdCBqaXR0ZXIgPSAxIC0gTWF0aC5yYW5kb20oKSAqIDAuMjU7XG5cbiAgICByZXR1cm4gc2xlZXBTZWNvbmRzICogaml0dGVyICogMTAwMDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0VXNlckFnZW50KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0vSlMgJHtWRVJTSU9OfWA7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgUGFnZUluZm8gPSB7IHVybDogVVJMIH0gfCB7IHBhcmFtczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBudWxsIH07XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdFBhZ2U8SXRlbT4gaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPEl0ZW0+IHtcbiAgI2NsaWVudDogQVBJQ2xpZW50O1xuICBwcm90ZWN0ZWQgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucztcblxuICBwcm90ZWN0ZWQgcmVzcG9uc2U6IFJlc3BvbnNlO1xuICBwcm90ZWN0ZWQgYm9keTogdW5rbm93bjtcblxuICBjb25zdHJ1Y3RvcihjbGllbnQ6IEFQSUNsaWVudCwgcmVzcG9uc2U6IFJlc3BvbnNlLCBib2R5OiB1bmtub3duLCBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zKSB7XG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG5leHRQYWdlSW5mbyBpbnN0ZWFkXG4gICAqL1xuICBhYnN0cmFjdCBuZXh0UGFnZVBhcmFtcygpOiBQYXJ0aWFsPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiB8IG51bGw7XG4gIGFic3RyYWN0IG5leHRQYWdlSW5mbygpOiBQYWdlSW5mbyB8IG51bGw7XG5cbiAgYWJzdHJhY3QgZ2V0UGFnaW5hdGVkSXRlbXMoKTogSXRlbVtdO1xuXG4gIGhhc05leHRQYWdlKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5nZXRQYWdpbmF0ZWRJdGVtcygpO1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMubmV4dFBhZ2VJbmZvKCkgIT0gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGdldE5leHRQYWdlKCk6IFByb21pc2U8dGhpcz4ge1xuICAgIGNvbnN0IG5leHRJbmZvID0gdGhpcy5uZXh0UGFnZUluZm8oKTtcbiAgICBpZiAoIW5leHRJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoXG4gICAgICAgICdObyBuZXh0IHBhZ2UgZXhwZWN0ZWQ7IHBsZWFzZSBjaGVjayBgLmhhc05leHRQYWdlKClgIGJlZm9yZSBjYWxsaW5nIGAuZ2V0TmV4dFBhZ2UoKWAuJyxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG5leHRPcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMgfTtcbiAgICBpZiAoJ3BhcmFtcycgaW4gbmV4dEluZm8gJiYgdHlwZW9mIG5leHRPcHRpb25zLnF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgbmV4dE9wdGlvbnMucXVlcnkgPSB7IC4uLm5leHRPcHRpb25zLnF1ZXJ5LCAuLi5uZXh0SW5mby5wYXJhbXMgfTtcbiAgICB9IGVsc2UgaWYgKCd1cmwnIGluIG5leHRJbmZvKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBbLi4uT2JqZWN0LmVudHJpZXMobmV4dE9wdGlvbnMucXVlcnkgfHwge30pLCAuLi5uZXh0SW5mby51cmwuc2VhcmNoUGFyYW1zLmVudHJpZXMoKV07XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBwYXJhbXMpIHtcbiAgICAgICAgbmV4dEluZm8udXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSBhcyBhbnkpO1xuICAgICAgfVxuICAgICAgbmV4dE9wdGlvbnMucXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgICBuZXh0T3B0aW9ucy5wYXRoID0gbmV4dEluZm8udXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLiNjbGllbnQucmVxdWVzdEFQSUxpc3QodGhpcy5jb25zdHJ1Y3RvciBhcyBhbnksIG5leHRPcHRpb25zKTtcbiAgfVxuXG4gIGFzeW5jICppdGVyUGFnZXMoKTogQXN5bmNHZW5lcmF0b3I8dGhpcz4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgIGxldCBwYWdlOiB0aGlzID0gdGhpcztcbiAgICB5aWVsZCBwYWdlO1xuICAgIHdoaWxlIChwYWdlLmhhc05leHRQYWdlKCkpIHtcbiAgICAgIHBhZ2UgPSBhd2FpdCBwYWdlLmdldE5leHRQYWdlKCk7XG4gICAgICB5aWVsZCBwYWdlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk6IEFzeW5jR2VuZXJhdG9yPEl0ZW0+IHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHBhZ2Ugb2YgdGhpcy5pdGVyUGFnZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHBhZ2UuZ2V0UGFnaW5hdGVkSXRlbXMoKSkge1xuICAgICAgICB5aWVsZCBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgc3ViY2xhc3Mgb2YgUHJvbWlzZSB3aWxsIHJlc29sdmUgdG8gYW4gaW5zdGFudGlhdGVkIFBhZ2Ugb25jZSB0aGUgcmVxdWVzdCBjb21wbGV0ZXMuXG4gKlxuICogSXQgYWxzbyBpbXBsZW1lbnRzIEFzeW5jSXRlcmFibGUgdG8gYWxsb3cgYXV0by1wYWdpbmF0aW5nIGl0ZXJhdGlvbiBvbiBhbiB1bmF3YWl0ZWQgbGlzdCBjYWxsLCBlZzpcbiAqXG4gKiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgY2xpZW50Lml0ZW1zLmxpc3QoKSkge1xuICogICAgICBjb25zb2xlLmxvZyhpdGVtKVxuICogICAgfVxuICovXG5leHBvcnQgY2xhc3MgUGFnZVByb21pc2U8XG4gICAgUGFnZUNsYXNzIGV4dGVuZHMgQWJzdHJhY3RQYWdlPEl0ZW0+LFxuICAgIEl0ZW0gPSBSZXR1cm5UeXBlPFBhZ2VDbGFzc1snZ2V0UGFnaW5hdGVkSXRlbXMnXT5bbnVtYmVyXSxcbiAgPlxuICBleHRlbmRzIEFQSVByb21pc2U8UGFnZUNsYXNzPlxuICBpbXBsZW1lbnRzIEFzeW5jSXRlcmFibGU8SXRlbT5cbntcbiAgY29uc3RydWN0b3IoXG4gICAgY2xpZW50OiBBUElDbGllbnQsXG4gICAgcmVxdWVzdDogUHJvbWlzZTxBUElSZXNwb25zZVByb3BzPixcbiAgICBQYWdlOiBuZXcgKC4uLmFyZ3M6IENvbnN0cnVjdG9yUGFyYW1ldGVyczx0eXBlb2YgQWJzdHJhY3RQYWdlPikgPT4gUGFnZUNsYXNzLFxuICApIHtcbiAgICBzdXBlcihcbiAgICAgIHJlcXVlc3QsXG4gICAgICBhc3luYyAocHJvcHMpID0+XG4gICAgICAgIG5ldyBQYWdlKFxuICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICBwcm9wcy5yZXNwb25zZSxcbiAgICAgICAgICBhd2FpdCBkZWZhdWx0UGFyc2VSZXNwb25zZShwcm9wcyksXG4gICAgICAgICAgcHJvcHMub3B0aW9ucyxcbiAgICAgICAgKSBhcyBXaXRoUmVxdWVzdElEPFBhZ2VDbGFzcz4sXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvdyBhdXRvLXBhZ2luYXRpbmcgaXRlcmF0aW9uIG9uIGFuIHVuYXdhaXRlZCBsaXN0IGNhbGwsIGVnOlxuICAgKlxuICAgKiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgY2xpZW50Lml0ZW1zLmxpc3QoKSkge1xuICAgKiAgICAgIGNvbnNvbGUubG9nKGl0ZW0pXG4gICAqICAgIH1cbiAgICovXG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk6IEFzeW5jR2VuZXJhdG9yPEl0ZW0+IHtcbiAgICBjb25zdCBwYWdlID0gYXdhaXQgdGhpcztcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgcGFnZSkge1xuICAgICAgeWllbGQgaXRlbTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlc3BvbnNlSGVhZGVycyA9IChcbiAgaGVhZGVyczogQXdhaXRlZDxSZXR1cm5UeXBlPEZldGNoPj5bJ2hlYWRlcnMnXSxcbik6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPT4ge1xuICByZXR1cm4gbmV3IFByb3h5KFxuICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGhlYWRlcnMuZW50cmllcygpLFxuICAgICksXG4gICAge1xuICAgICAgZ2V0KHRhcmdldCwgbmFtZSkge1xuICAgICAgICBjb25zdCBrZXkgPSBuYW1lLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0YXJnZXRba2V5LnRvTG93ZXJDYXNlKCldIHx8IHRhcmdldFtrZXldO1xuICAgICAgfSxcbiAgICB9LFxuICApO1xufTtcblxudHlwZSBIVFRQTWV0aG9kID0gJ2dldCcgfCAncG9zdCcgfCAncHV0JyB8ICdwYXRjaCcgfCAnZGVsZXRlJztcblxuZXhwb3J0IHR5cGUgUmVxdWVzdENsaWVudCA9IHsgZmV0Y2g6IEZldGNoIH07XG5leHBvcnQgdHlwZSBIZWFkZXJzID0gUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZD47XG5leHBvcnQgdHlwZSBEZWZhdWx0UXVlcnkgPSBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+O1xuZXhwb3J0IHR5cGUgS2V5c0VudW08VD4gPSB7IFtQIGluIGtleW9mIFJlcXVpcmVkPFQ+XTogdHJ1ZSB9O1xuXG5leHBvcnQgdHlwZSBSZXF1ZXN0T3B0aW9uczxcbiAgUmVxID0gdW5rbm93biB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgUmVhZGFibGUgfCBCbG9iTGlrZSB8IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyLFxuPiA9IHtcbiAgbWV0aG9kPzogSFRUUE1ldGhvZDtcbiAgcGF0aD86IHN0cmluZztcbiAgcXVlcnk/OiBSZXEgfCB1bmRlZmluZWQ7XG4gIGJvZHk/OiBSZXEgfCBudWxsIHwgdW5kZWZpbmVkO1xuICBoZWFkZXJzPzogSGVhZGVycyB8IHVuZGVmaW5lZDtcblxuICBtYXhSZXRyaWVzPzogbnVtYmVyO1xuICBzdHJlYW0/OiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICB0aW1lb3V0PzogbnVtYmVyO1xuICBodHRwQWdlbnQ/OiBBZ2VudDtcbiAgc2lnbmFsPzogQWJvcnRTaWduYWwgfCB1bmRlZmluZWQgfCBudWxsO1xuICBpZGVtcG90ZW5jeUtleT86IHN0cmluZztcblxuICBfX2JpbmFyeVJlcXVlc3Q/OiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICBfX2JpbmFyeVJlc3BvbnNlPzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgX19zdHJlYW1DbGFzcz86IHR5cGVvZiBTdHJlYW07XG59O1xuXG4vLyBUaGlzIGlzIHJlcXVpcmVkIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSBpZiBhIGdpdmVuIG9iamVjdCBtYXRjaGVzIHRoZSBSZXF1ZXN0T3B0aW9uc1xuLy8gdHlwZSBhdCBydW50aW1lLiBXaGlsZSB0aGlzIHJlcXVpcmVzIGR1cGxpY2F0aW9uLCBpdCBpcyBlbmZvcmNlZCBieSB0aGUgVHlwZVNjcmlwdFxuLy8gY29tcGlsZXIgc3VjaCB0aGF0IGFueSBtaXNzaW5nIC8gZXh0cmFuZW91cyBrZXlzIHdpbGwgY2F1c2UgYW4gZXJyb3IuXG5jb25zdCByZXF1ZXN0T3B0aW9uc0tleXM6IEtleXNFbnVtPFJlcXVlc3RPcHRpb25zPiA9IHtcbiAgbWV0aG9kOiB0cnVlLFxuICBwYXRoOiB0cnVlLFxuICBxdWVyeTogdHJ1ZSxcbiAgYm9keTogdHJ1ZSxcbiAgaGVhZGVyczogdHJ1ZSxcblxuICBtYXhSZXRyaWVzOiB0cnVlLFxuICBzdHJlYW06IHRydWUsXG4gIHRpbWVvdXQ6IHRydWUsXG4gIGh0dHBBZ2VudDogdHJ1ZSxcbiAgc2lnbmFsOiB0cnVlLFxuICBpZGVtcG90ZW5jeUtleTogdHJ1ZSxcblxuICBfX2JpbmFyeVJlcXVlc3Q6IHRydWUsXG4gIF9fYmluYXJ5UmVzcG9uc2U6IHRydWUsXG4gIF9fc3RyZWFtQ2xhc3M6IHRydWUsXG59O1xuXG5leHBvcnQgY29uc3QgaXNSZXF1ZXN0T3B0aW9ucyA9IChvYmo6IHVua25vd24pOiBvYmogaXMgUmVxdWVzdE9wdGlvbnMgPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgb2JqICE9PSBudWxsICYmXG4gICAgIWlzRW1wdHlPYmoob2JqKSAmJlxuICAgIE9iamVjdC5rZXlzKG9iaikuZXZlcnkoKGspID0+IGhhc093bihyZXF1ZXN0T3B0aW9uc0tleXMsIGspKVxuICApO1xufTtcblxuZXhwb3J0IHR5cGUgRmluYWxSZXF1ZXN0T3B0aW9uczxSZXEgPSB1bmtub3duIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBSZWFkYWJsZSB8IERhdGFWaWV3PiA9XG4gIFJlcXVlc3RPcHRpb25zPFJlcT4gJiB7XG4gICAgbWV0aG9kOiBIVFRQTWV0aG9kO1xuICAgIHBhdGg6IHN0cmluZztcbiAgfTtcblxuZGVjbGFyZSBjb25zdCBEZW5vOiBhbnk7XG5kZWNsYXJlIGNvbnN0IEVkZ2VSdW50aW1lOiBhbnk7XG50eXBlIEFyY2ggPSAneDMyJyB8ICd4NjQnIHwgJ2FybScgfCAnYXJtNjQnIHwgYG90aGVyOiR7c3RyaW5nfWAgfCAndW5rbm93bic7XG50eXBlIFBsYXRmb3JtTmFtZSA9XG4gIHwgJ01hY09TJ1xuICB8ICdMaW51eCdcbiAgfCAnV2luZG93cydcbiAgfCAnRnJlZUJTRCdcbiAgfCAnT3BlbkJTRCdcbiAgfCAnaU9TJ1xuICB8ICdBbmRyb2lkJ1xuICB8IGBPdGhlcjoke3N0cmluZ31gXG4gIHwgJ1Vua25vd24nO1xudHlwZSBCcm93c2VyID0gJ2llJyB8ICdlZGdlJyB8ICdjaHJvbWUnIHwgJ2ZpcmVmb3gnIHwgJ3NhZmFyaSc7XG50eXBlIFBsYXRmb3JtUHJvcGVydGllcyA9IHtcbiAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnO1xuICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogc3RyaW5nO1xuICAnWC1TdGFpbmxlc3MtT1MnOiBQbGF0Zm9ybU5hbWU7XG4gICdYLVN0YWlubGVzcy1BcmNoJzogQXJjaDtcbiAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAnbm9kZScgfCAnZGVubycgfCAnZWRnZScgfCBgYnJvd3Nlcjoke0Jyb3dzZXJ9YCB8ICd1bmtub3duJztcbiAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IHN0cmluZztcbn07XG5jb25zdCBnZXRQbGF0Zm9ybVByb3BlcnRpZXMgPSAoKTogUGxhdGZvcm1Qcm9wZXJ0aWVzID0+IHtcbiAgaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJyAmJiBEZW5vLmJ1aWxkICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAnWC1TdGFpbmxlc3MtT1MnOiBub3JtYWxpemVQbGF0Zm9ybShEZW5vLmJ1aWxkLm9zKSxcbiAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogbm9ybWFsaXplQXJjaChEZW5vLmJ1aWxkLmFyY2gpLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAnZGVubycsXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzpcbiAgICAgICAgdHlwZW9mIERlbm8udmVyc2lvbiA9PT0gJ3N0cmluZycgPyBEZW5vLnZlcnNpb24gOiBEZW5vLnZlcnNpb24/LmRlbm8gPz8gJ3Vua25vd24nLFxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBFZGdlUnVudGltZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAnWC1TdGFpbmxlc3MtT1MnOiAnVW5rbm93bicsXG4gICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6IGBvdGhlcjoke0VkZ2VSdW50aW1lfWAsXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICdlZGdlJyxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiBwcm9jZXNzLnZlcnNpb24sXG4gICAgfTtcbiAgfVxuICAvLyBDaGVjayBpZiBOb2RlLmpzXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnID8gcHJvY2VzcyA6IDApID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAnWC1TdGFpbmxlc3MtT1MnOiBub3JtYWxpemVQbGF0Zm9ybShwcm9jZXNzLnBsYXRmb3JtKSxcbiAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogbm9ybWFsaXplQXJjaChwcm9jZXNzLmFyY2gpLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAnbm9kZScsXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogcHJvY2Vzcy52ZXJzaW9uLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBicm93c2VySW5mbyA9IGdldEJyb3dzZXJJbmZvKCk7XG4gIGlmIChicm93c2VySW5mbykge1xuICAgIHJldHVybiB7XG4gICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICdYLVN0YWlubGVzcy1PUyc6ICdVbmtub3duJyxcbiAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogJ3Vua25vd24nLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiBgYnJvd3Nlcjoke2Jyb3dzZXJJbmZvLmJyb3dzZXJ9YCxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiBicm93c2VySW5mby52ZXJzaW9uLFxuICAgIH07XG4gIH1cblxuICAvLyBUT0RPIGFkZCBzdXBwb3J0IGZvciBDbG91ZGZsYXJlIHdvcmtlcnMsIGV0Yy5cbiAgcmV0dXJuIHtcbiAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgJ1gtU3RhaW5sZXNzLU9TJzogJ1Vua25vd24nLFxuICAgICdYLVN0YWlubGVzcy1BcmNoJzogJ3Vua25vd24nLFxuICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ3Vua25vd24nLFxuICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiAndW5rbm93bicsXG4gIH07XG59O1xuXG50eXBlIEJyb3dzZXJJbmZvID0ge1xuICBicm93c2VyOiBCcm93c2VyO1xuICB2ZXJzaW9uOiBzdHJpbmc7XG59O1xuXG5kZWNsYXJlIGNvbnN0IG5hdmlnYXRvcjogeyB1c2VyQWdlbnQ6IHN0cmluZyB9IHwgdW5kZWZpbmVkO1xuXG4vLyBOb3RlOiBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9KUy1EZXZUb29scy9ob3N0LWVudmlyb25tZW50L2Jsb2IvYjFhYjc5ZWNkZTM3ZGI1ZDZlMTYzYzA1MGU1NGZlN2QyODdkN2M5Mi9zcmMvaXNvbW9ycGhpYy5icm93c2VyLnRzXG5mdW5jdGlvbiBnZXRCcm93c2VySW5mbygpOiBCcm93c2VySW5mbyB8IG51bGwge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTk9URTogVGhlIG9yZGVyIG1hdHRlcnMgaGVyZSFcbiAgY29uc3QgYnJvd3NlclBhdHRlcm5zID0gW1xuICAgIHsga2V5OiAnZWRnZScgYXMgY29uc3QsIHBhdHRlcm46IC9FZGdlKD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgeyBrZXk6ICdpZScgYXMgY29uc3QsIHBhdHRlcm46IC9NU0lFKD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgeyBrZXk6ICdpZScgYXMgY29uc3QsIHBhdHRlcm46IC9UcmlkZW50KD86LipydlxcOihcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgeyBrZXk6ICdjaHJvbWUnIGFzIGNvbnN0LCBwYXR0ZXJuOiAvQ2hyb21lKD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgeyBrZXk6ICdmaXJlZm94JyBhcyBjb25zdCwgcGF0dGVybjogL0ZpcmVmb3goPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICB7IGtleTogJ3NhZmFyaScgYXMgY29uc3QsIHBhdHRlcm46IC8oPzpWZXJzaW9uXFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8oPzpcXFcrTW9iaWxlXFxTKik/XFxXK1NhZmFyaS8gfSxcbiAgXTtcblxuICAvLyBGaW5kIHRoZSBGSVJTVCBtYXRjaGluZyBicm93c2VyXG4gIGZvciAoY29uc3QgeyBrZXksIHBhdHRlcm4gfSBvZiBicm93c2VyUGF0dGVybnMpIHtcbiAgICBjb25zdCBtYXRjaCA9IHBhdHRlcm4uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGNvbnN0IG1ham9yID0gbWF0Y2hbMV0gfHwgMDtcbiAgICAgIGNvbnN0IG1pbm9yID0gbWF0Y2hbMl0gfHwgMDtcbiAgICAgIGNvbnN0IHBhdGNoID0gbWF0Y2hbM10gfHwgMDtcblxuICAgICAgcmV0dXJuIHsgYnJvd3Nlcjoga2V5LCB2ZXJzaW9uOiBgJHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH1gIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IG5vcm1hbGl6ZUFyY2ggPSAoYXJjaDogc3RyaW5nKTogQXJjaCA9PiB7XG4gIC8vIE5vZGUgZG9jczpcbiAgLy8gLSBodHRwczovL25vZGVqcy5vcmcvYXBpL3Byb2Nlc3MuaHRtbCNwcm9jZXNzYXJjaFxuICAvLyBEZW5vIGRvY3M6XG4gIC8vIC0gaHR0cHM6Ly9kb2MuZGVuby5sYW5kL2Rlbm8vc3RhYmxlL34vRGVuby5idWlsZFxuICBpZiAoYXJjaCA9PT0gJ3gzMicpIHJldHVybiAneDMyJztcbiAgaWYgKGFyY2ggPT09ICd4ODZfNjQnIHx8IGFyY2ggPT09ICd4NjQnKSByZXR1cm4gJ3g2NCc7XG4gIGlmIChhcmNoID09PSAnYXJtJykgcmV0dXJuICdhcm0nO1xuICBpZiAoYXJjaCA9PT0gJ2FhcmNoNjQnIHx8IGFyY2ggPT09ICdhcm02NCcpIHJldHVybiAnYXJtNjQnO1xuICBpZiAoYXJjaCkgcmV0dXJuIGBvdGhlcjoke2FyY2h9YDtcbiAgcmV0dXJuICd1bmtub3duJztcbn07XG5cbmNvbnN0IG5vcm1hbGl6ZVBsYXRmb3JtID0gKHBsYXRmb3JtOiBzdHJpbmcpOiBQbGF0Zm9ybU5hbWUgPT4ge1xuICAvLyBOb2RlIHBsYXRmb3JtczpcbiAgLy8gLSBodHRwczovL25vZGVqcy5vcmcvYXBpL3Byb2Nlc3MuaHRtbCNwcm9jZXNzcGxhdGZvcm1cbiAgLy8gRGVubyBwbGF0Zm9ybXM6XG4gIC8vIC0gaHR0cHM6Ly9kb2MuZGVuby5sYW5kL2Rlbm8vc3RhYmxlL34vRGVuby5idWlsZFxuICAvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9kZW5vbGFuZC9kZW5vL2lzc3Vlcy8xNDc5OVxuXG4gIHBsYXRmb3JtID0gcGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcblxuICAvLyBOT1RFOiB0aGlzIGlPUyBjaGVjayBpcyB1bnRlc3RlZCBhbmQgbWF5IG5vdCB3b3JrXG4gIC8vIE5vZGUgZG9lcyBub3Qgd29yayBuYXRpdmVseSBvbiBJT1MsIHRoZXJlIGlzIGEgZm9yayBhdFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzLW1vYmlsZS9ub2RlanMtbW9iaWxlXG4gIC8vIGhvd2V2ZXIgaXQgaXMgdW5rbm93biBhdCB0aGUgdGltZSBvZiB3cml0aW5nIGhvdyB0byBkZXRlY3QgaWYgaXQgaXMgcnVubmluZ1xuICBpZiAocGxhdGZvcm0uaW5jbHVkZXMoJ2lvcycpKSByZXR1cm4gJ2lPUyc7XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKSByZXR1cm4gJ0FuZHJvaWQnO1xuICBpZiAocGxhdGZvcm0gPT09ICdkYXJ3aW4nKSByZXR1cm4gJ01hY09TJztcbiAgaWYgKHBsYXRmb3JtID09PSAnd2luMzInKSByZXR1cm4gJ1dpbmRvd3MnO1xuICBpZiAocGxhdGZvcm0gPT09ICdmcmVlYnNkJykgcmV0dXJuICdGcmVlQlNEJztcbiAgaWYgKHBsYXRmb3JtID09PSAnb3BlbmJzZCcpIHJldHVybiAnT3BlbkJTRCc7XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ2xpbnV4JykgcmV0dXJuICdMaW51eCc7XG4gIGlmIChwbGF0Zm9ybSkgcmV0dXJuIGBPdGhlcjoke3BsYXRmb3JtfWA7XG4gIHJldHVybiAnVW5rbm93bic7XG59O1xuXG5sZXQgX3BsYXRmb3JtSGVhZGVyczogUGxhdGZvcm1Qcm9wZXJ0aWVzO1xuY29uc3QgZ2V0UGxhdGZvcm1IZWFkZXJzID0gKCkgPT4ge1xuICByZXR1cm4gKF9wbGF0Zm9ybUhlYWRlcnMgPz89IGdldFBsYXRmb3JtUHJvcGVydGllcygpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzYWZlSlNPTiA9ICh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtc2NoZW1lLXN0cmluZ1xuY29uc3Qgc3RhcnRzV2l0aFNjaGVtZVJlZ2V4cCA9IC9eW2Etel1bYS16MC05Ky4tXSo6L2k7XG5jb25zdCBpc0Fic29sdXRlVVJMID0gKHVybDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIHJldHVybiBzdGFydHNXaXRoU2NoZW1lUmVnZXhwLnRlc3QodXJsKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzbGVlcCA9IChtczogbnVtYmVyKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xuXG5jb25zdCB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlciA9IChuYW1lOiBzdHJpbmcsIG46IHVua25vd24pOiBudW1iZXIgPT4ge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKG4pKSB7XG4gICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGAke25hbWV9IG11c3QgYmUgYW4gaW50ZWdlcmApO1xuICB9XG4gIGlmIChuIDwgMCkge1xuICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgJHtuYW1lfSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcmApO1xuICB9XG4gIHJldHVybiBuO1xufTtcblxuZXhwb3J0IGNvbnN0IGNhc3RUb0Vycm9yID0gKGVycjogYW55KTogRXJyb3IgPT4ge1xuICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiBlcnI7XG4gIGlmICh0eXBlb2YgZXJyID09PSAnb2JqZWN0JyAmJiBlcnIgIT09IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShlcnIpKTtcbiAgICB9IGNhdGNoIHt9XG4gIH1cbiAgcmV0dXJuIG5ldyBFcnJvcihlcnIpO1xufTtcblxuZXhwb3J0IGNvbnN0IGVuc3VyZVByZXNlbnQgPSA8VD4odmFsdWU6IFQgfCBudWxsIHwgdW5kZWZpbmVkKTogVCA9PiB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYEV4cGVjdGVkIGEgdmFsdWUgdG8gYmUgZ2l2ZW4gYnV0IHJlY2VpdmVkICR7dmFsdWV9IGluc3RlYWQuYCk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZCBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAqXG4gKiBUcmltcyBiZWdpbm5pbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuXG4gKlxuICogV2lsbCByZXR1cm4gdW5kZWZpbmVkIGlmIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBkb2Vzbid0IGV4aXN0IG9yIGNhbm5vdCBiZSBhY2Nlc3NlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRFbnYgPSAoZW52OiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Py5bZW52XT8udHJpbSgpID8/IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIERlbm8uZW52Py5nZXQ/LihlbnYpPy50cmltKCk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCBjb25zdCBjb2VyY2VJbnRlZ2VyID0gKHZhbHVlOiB1bmtub3duKTogbnVtYmVyID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuXG4gIHRocm93IG5ldyBPcGVuQUlFcnJvcihgQ291bGQgbm90IGNvZXJjZSAke3ZhbHVlfSAodHlwZTogJHt0eXBlb2YgdmFsdWV9KSBpbnRvIGEgbnVtYmVyYCk7XG59O1xuXG5leHBvcnQgY29uc3QgY29lcmNlRmxvYXQgPSAodmFsdWU6IHVua25vd24pOiBudW1iZXIgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuIHZhbHVlO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gIHRocm93IG5ldyBPcGVuQUlFcnJvcihgQ291bGQgbm90IGNvZXJjZSAke3ZhbHVlfSAodHlwZTogJHt0eXBlb2YgdmFsdWV9KSBpbnRvIGEgbnVtYmVyYCk7XG59O1xuXG5leHBvcnQgY29uc3QgY29lcmNlQm9vbGVhbiA9ICh2YWx1ZTogdW5rbm93bik6IGJvb2xlYW4gPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHJldHVybiB2YWx1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHJldHVybiB2YWx1ZSA9PT0gJ3RydWUnO1xuICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XG59O1xuXG5leHBvcnQgY29uc3QgbWF5YmVDb2VyY2VJbnRlZ2VyID0gKHZhbHVlOiB1bmtub3duKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBjb2VyY2VJbnRlZ2VyKHZhbHVlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBtYXliZUNvZXJjZUZsb2F0ID0gKHZhbHVlOiB1bmtub3duKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBjb2VyY2VGbG9hdCh2YWx1ZSk7XG59O1xuXG5leHBvcnQgY29uc3QgbWF5YmVDb2VyY2VCb29sZWFuID0gKHZhbHVlOiB1bmtub3duKTogYm9vbGVhbiB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gY29lcmNlQm9vbGVhbih2YWx1ZSk7XG59O1xuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ0OTEyODdcbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5T2JqKG9iajogT2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICBpZiAoIW9iaikgcmV0dXJuIHRydWU7XG4gIGZvciAoY29uc3QgX2sgaW4gb2JqKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBodHRwczovL2VzbGludC5vcmcvZG9jcy9sYXRlc3QvcnVsZXMvbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duKG9iajogT2JqZWN0LCBrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgaGVhZGVycyBmcm9tIFwibmV3SGVhZGVyc1wiIG9udG8gXCJ0YXJnZXRIZWFkZXJzXCIsXG4gKiB1c2luZyBsb3dlci1jYXNlIGZvciBhbGwgcHJvcGVydGllcyxcbiAqIGlnbm9yaW5nIGFueSBrZXlzIHdpdGggdW5kZWZpbmVkIHZhbHVlcyxcbiAqIGFuZCBkZWxldGluZyBhbnkga2V5cyB3aXRoIG51bGwgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBhcHBseUhlYWRlcnNNdXQodGFyZ2V0SGVhZGVyczogSGVhZGVycywgbmV3SGVhZGVyczogSGVhZGVycyk6IHZvaWQge1xuICBmb3IgKGNvbnN0IGsgaW4gbmV3SGVhZGVycykge1xuICAgIGlmICghaGFzT3duKG5ld0hlYWRlcnMsIGspKSBjb250aW51ZTtcbiAgICBjb25zdCBsb3dlcktleSA9IGsudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIWxvd2VyS2V5KSBjb250aW51ZTtcblxuICAgIGNvbnN0IHZhbCA9IG5ld0hlYWRlcnNba107XG5cbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0SGVhZGVyc1tsb3dlcktleV07XG4gICAgfSBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0SGVhZGVyc1tsb3dlcktleV0gPSB2YWw7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFNFTlNJVElWRV9IRUFERVJTID0gbmV3IFNldChbJ2F1dGhvcml6YXRpb24nLCAnYXBpLWtleSddKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnKGFjdGlvbjogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3M/LmVudj8uWydERUJVRyddID09PSAndHJ1ZScpIHtcbiAgICBjb25zdCBtb2RpZmllZEFyZ3MgPSBhcmdzLm1hcCgoYXJnKSA9PiB7XG4gICAgICBpZiAoIWFyZykge1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3Igc2Vuc2l0aXZlIGhlYWRlcnMgaW4gcmVxdWVzdCBib2R5ICdoZWFkZXJzJyBvYmplY3RcbiAgICAgIGlmIChhcmdbJ2hlYWRlcnMnXSkge1xuICAgICAgICAvLyBjbG9uZSBzbyB3ZSBkb24ndCBtdXRhdGVcbiAgICAgICAgY29uc3QgbW9kaWZpZWRBcmcgPSB7IC4uLmFyZywgaGVhZGVyczogeyAuLi5hcmdbJ2hlYWRlcnMnXSB9IH07XG5cbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgaW4gYXJnWydoZWFkZXJzJ10pIHtcbiAgICAgICAgICBpZiAoU0VOU0lUSVZFX0hFQURFUlMuaGFzKGhlYWRlci50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgbW9kaWZpZWRBcmdbJ2hlYWRlcnMnXVtoZWFkZXJdID0gJ1JFREFDVEVEJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kaWZpZWRBcmc7XG4gICAgICB9XG5cbiAgICAgIGxldCBtb2RpZmllZEFyZyA9IG51bGw7XG5cbiAgICAgIC8vIENoZWNrIGZvciBzZW5zaXRpdmUgaGVhZGVycyBpbiBoZWFkZXJzIG9iamVjdFxuICAgICAgZm9yIChjb25zdCBoZWFkZXIgaW4gYXJnKSB7XG4gICAgICAgIGlmIChTRU5TSVRJVkVfSEVBREVSUy5oYXMoaGVhZGVyLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgLy8gYXZvaWQgbWFraW5nIGEgY29weSB1bnRpbCB3ZSBuZWVkIHRvXG4gICAgICAgICAgbW9kaWZpZWRBcmcgPz89IHsgLi4uYXJnIH07XG4gICAgICAgICAgbW9kaWZpZWRBcmdbaGVhZGVyXSA9ICdSRURBQ1RFRCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1vZGlmaWVkQXJnID8/IGFyZztcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZyhgT3BlbkFJOkRFQlVHOiR7YWN0aW9ufWAsIC4uLm1vZGlmaWVkQXJncyk7XG4gIH1cbn1cblxuLyoqXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjExNzUyM1xuICovXG5jb25zdCB1dWlkNCA9ICgpID0+IHtcbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgKGMpID0+IHtcbiAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwO1xuICAgIGNvbnN0IHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNSdW5uaW5nSW5Ccm93c2VyID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJ1xuICApO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBIZWFkZXJzUHJvdG9jb2wge1xuICBnZXQ6IChoZWFkZXI6IHN0cmluZykgPT4gc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCB0eXBlIEhlYWRlcnNMaWtlID0gUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10gfCB1bmRlZmluZWQ+IHwgSGVhZGVyc1Byb3RvY29sO1xuXG5leHBvcnQgY29uc3QgaXNIZWFkZXJzUHJvdG9jb2wgPSAoaGVhZGVyczogYW55KTogaGVhZGVycyBpcyBIZWFkZXJzUHJvdG9jb2wgPT4ge1xuICByZXR1cm4gdHlwZW9mIGhlYWRlcnM/LmdldCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRSZXF1aXJlZEhlYWRlciA9IChoZWFkZXJzOiBIZWFkZXJzTGlrZSB8IEhlYWRlcnMsIGhlYWRlcjogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgY29uc3QgZm91bmRIZWFkZXIgPSBnZXRIZWFkZXIoaGVhZGVycywgaGVhZGVyKTtcbiAgaWYgKGZvdW5kSGVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kICR7aGVhZGVyfSBoZWFkZXJgKTtcbiAgfVxuICByZXR1cm4gZm91bmRIZWFkZXI7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0SGVhZGVyID0gKGhlYWRlcnM6IEhlYWRlcnNMaWtlIHwgSGVhZGVycywgaGVhZGVyOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQgPT4ge1xuICBjb25zdCBsb3dlckNhc2VkSGVhZGVyID0gaGVhZGVyLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChpc0hlYWRlcnNQcm90b2NvbChoZWFkZXJzKSkge1xuICAgIC8vIHRvIGRlYWwgd2l0aCB0aGUgY2FzZSB3aGVyZSB0aGUgaGVhZGVyIGxvb2tzIGxpa2UgU3RhaW5sZXNzLUV2ZW50LUlkXG4gICAgY29uc3QgaW50ZXJjYXBzSGVhZGVyID1cbiAgICAgIGhlYWRlclswXT8udG9VcHBlckNhc2UoKSArXG4gICAgICBoZWFkZXIuc3Vic3RyaW5nKDEpLnJlcGxhY2UoLyhbXlxcd10pKFxcdykvZywgKF9tLCBnMSwgZzIpID0+IGcxICsgZzIudG9VcHBlckNhc2UoKSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgW2hlYWRlciwgbG93ZXJDYXNlZEhlYWRlciwgaGVhZGVyLnRvVXBwZXJDYXNlKCksIGludGVyY2Fwc0hlYWRlcl0pIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gaGVhZGVycy5nZXQoa2V5KTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IGxvd2VyQ2FzZWRIZWFkZXIpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDw9IDEpIHJldHVybiB2YWx1ZVswXTtcbiAgICAgICAgY29uc29sZS53YXJuKGBSZWNlaXZlZCAke3ZhbHVlLmxlbmd0aH0gZW50cmllcyBmb3IgdGhlICR7aGVhZGVyfSBoZWFkZXIsIHVzaW5nIHRoZSBmaXJzdCBlbnRyeS5gKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlWzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgdG8gQmFzZTY0IGZvcm1hdC5cbiAqL1xuZXhwb3J0IGNvbnN0IHRvQmFzZTY0ID0gKHN0cjogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCk6IHN0cmluZyA9PiB7XG4gIGlmICghc3RyKSByZXR1cm4gJyc7XG4gIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnRvYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gYnRvYShzdHIpO1xuICB9XG5cbiAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKCdDYW5ub3QgZ2VuZXJhdGUgYjY0IHN0cmluZzsgRXhwZWN0ZWQgYEJ1ZmZlcmAgb3IgYGJ0b2FgIHRvIGJlIGRlZmluZWQnKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc09iaihvYmo6IHVua25vd24pOiBvYmogaXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBYnN0cmFjdFBhZ2UsIFJlc3BvbnNlLCBBUElDbGllbnQsIEZpbmFsUmVxdWVzdE9wdGlvbnMsIFBhZ2VJbmZvIH0gZnJvbSAnLi9jb3JlJztcblxuZXhwb3J0IGludGVyZmFjZSBQYWdlUmVzcG9uc2U8SXRlbT4ge1xuICBkYXRhOiBBcnJheTxJdGVtPjtcblxuICBvYmplY3Q6IHN0cmluZztcbn1cblxuLyoqXG4gKiBOb3RlOiBubyBwYWdpbmF0aW9uIGFjdHVhbGx5IG9jY3VycyB5ZXQsIHRoaXMgaXMgZm9yIGZvcndhcmRzLWNvbXBhdGliaWxpdHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYWdlPEl0ZW0+IGV4dGVuZHMgQWJzdHJhY3RQYWdlPEl0ZW0+IGltcGxlbWVudHMgUGFnZVJlc3BvbnNlPEl0ZW0+IHtcbiAgZGF0YTogQXJyYXk8SXRlbT47XG5cbiAgb2JqZWN0OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoY2xpZW50OiBBUElDbGllbnQsIHJlc3BvbnNlOiBSZXNwb25zZSwgYm9keTogUGFnZVJlc3BvbnNlPEl0ZW0+LCBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zKSB7XG4gICAgc3VwZXIoY2xpZW50LCByZXNwb25zZSwgYm9keSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmRhdGEgPSBib2R5LmRhdGEgfHwgW107XG4gICAgdGhpcy5vYmplY3QgPSBib2R5Lm9iamVjdDtcbiAgfVxuXG4gIGdldFBhZ2luYXRlZEl0ZW1zKCk6IEl0ZW1bXSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YSA/PyBbXTtcbiAgfVxuXG4gIC8vIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYG5leHRQYWdlSW5mbygpYCBpbnN0ZWFkXG4gIC8qKlxuICAgKiBUaGlzIHBhZ2UgcmVwcmVzZW50cyBhIHJlc3BvbnNlIHRoYXQgaXNuJ3QgYWN0dWFsbHkgcGFnaW5hdGVkIGF0IHRoZSBBUEkgbGV2ZWxcbiAgICogc28gdGhlcmUgd2lsbCBuZXZlciBiZSBhbnkgbmV4dCBwYWdlIHBhcmFtcy5cbiAgICovXG4gIG5leHRQYWdlUGFyYW1zKCk6IG51bGwge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbmV4dFBhZ2VJbmZvKCk6IG51bGwge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3Vyc29yUGFnZVJlc3BvbnNlPEl0ZW0+IHtcbiAgZGF0YTogQXJyYXk8SXRlbT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3Vyc29yUGFnZVBhcmFtcyB7XG4gIGFmdGVyPzogc3RyaW5nO1xuXG4gIGxpbWl0PzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgQ3Vyc29yUGFnZTxJdGVtIGV4dGVuZHMgeyBpZDogc3RyaW5nIH0+XG4gIGV4dGVuZHMgQWJzdHJhY3RQYWdlPEl0ZW0+XG4gIGltcGxlbWVudHMgQ3Vyc29yUGFnZVJlc3BvbnNlPEl0ZW0+XG57XG4gIGRhdGE6IEFycmF5PEl0ZW0+O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGNsaWVudDogQVBJQ2xpZW50LFxuICAgIHJlc3BvbnNlOiBSZXNwb25zZSxcbiAgICBib2R5OiBDdXJzb3JQYWdlUmVzcG9uc2U8SXRlbT4sXG4gICAgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucyxcbiAgKSB7XG4gICAgc3VwZXIoY2xpZW50LCByZXNwb25zZSwgYm9keSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmRhdGEgPSBib2R5LmRhdGEgfHwgW107XG4gIH1cblxuICBnZXRQYWdpbmF0ZWRJdGVtcygpOiBJdGVtW10ge1xuICAgIHJldHVybiB0aGlzLmRhdGEgPz8gW107XG4gIH1cblxuICAvLyBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGBuZXh0UGFnZUluZm8oKWAgaW5zdGVhZFxuICBuZXh0UGFnZVBhcmFtcygpOiBQYXJ0aWFsPEN1cnNvclBhZ2VQYXJhbXM+IHwgbnVsbCB7XG4gICAgY29uc3QgaW5mbyA9IHRoaXMubmV4dFBhZ2VJbmZvKCk7XG4gICAgaWYgKCFpbmZvKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoJ3BhcmFtcycgaW4gaW5mbykgcmV0dXJuIGluZm8ucGFyYW1zO1xuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5mcm9tRW50cmllcyhpbmZvLnVybC5zZWFyY2hQYXJhbXMpO1xuICAgIGlmICghT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICBuZXh0UGFnZUluZm8oKTogUGFnZUluZm8gfCBudWxsIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRQYWdpbmF0ZWRJdGVtcygpO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGlkID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdPy5pZDtcbiAgICBpZiAoIWlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4geyBwYXJhbXM6IHsgYWZ0ZXI6IGlkIH0gfTtcbiAgfVxufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB0eXBlIHsgT3BlbkFJIH0gZnJvbSAnLi9pbmRleCc7XG5cbmV4cG9ydCBjbGFzcyBBUElSZXNvdXJjZSB7XG4gIHByb3RlY3RlZCBfY2xpZW50OiBPcGVuQUk7XG5cbiAgY29uc3RydWN0b3IoY2xpZW50OiBPcGVuQUkpIHtcbiAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gIH1cbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IEFQSVByb21pc2UgfSBmcm9tICcuLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDaGF0Q29tcGxldGlvbnNBUEkgZnJvbSAnLi9jb21wbGV0aW9ucyc7XG5pbXBvcnQgKiBhcyBDb21wbGV0aW9uc0FQSSBmcm9tICcuLi9jb21wbGV0aW9ucyc7XG5pbXBvcnQgKiBhcyBTaGFyZWQgZnJvbSAnLi4vc2hhcmVkJztcbmltcG9ydCAqIGFzIENoYXRBUEkgZnJvbSAnLi9jaGF0JztcbmltcG9ydCB7IFN0cmVhbSB9IGZyb20gJy4uLy4uL3N0cmVhbWluZyc7XG5cbmV4cG9ydCBjbGFzcyBDb21wbGV0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtb2RlbCByZXNwb25zZSBmb3IgdGhlIGdpdmVuIGNoYXQgY29udmVyc2F0aW9uLiBMZWFybiBtb3JlIGluIHRoZVxuICAgKiBbdGV4dCBnZW5lcmF0aW9uXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvdGV4dC1nZW5lcmF0aW9uKSxcbiAgICogW3Zpc2lvbl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3Zpc2lvbiksIGFuZFxuICAgKiBbYXVkaW9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9hdWRpbykgZ3VpZGVzLlxuICAgKlxuICAgKiBQYXJhbWV0ZXIgc3VwcG9ydCBjYW4gZGlmZmVyIGRlcGVuZGluZyBvbiB0aGUgbW9kZWwgdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogcmVzcG9uc2UsIHBhcnRpY3VsYXJseSBmb3IgbmV3ZXIgcmVhc29uaW5nIG1vZGVscy4gUGFyYW1ldGVycyB0aGF0IGFyZSBvbmx5XG4gICAqIHN1cHBvcnRlZCBmb3IgcmVhc29uaW5nIG1vZGVscyBhcmUgbm90ZWQgYmVsb3cuIEZvciB0aGUgY3VycmVudCBzdGF0ZSBvZlxuICAgKiB1bnN1cHBvcnRlZCBwYXJhbWV0ZXJzIGluIHJlYXNvbmluZyBtb2RlbHMsXG4gICAqIFtyZWZlciB0byB0aGUgcmVhc29uaW5nIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvcmVhc29uaW5nKS5cbiAgICovXG4gIGNyZWF0ZShcbiAgICBib2R5OiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxDaGF0Q29tcGxldGlvbj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08Q2hhdENvbXBsZXRpb25DaHVuaz4+O1xuICBjcmVhdGUoXG4gICAgYm9keTogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxDaGF0Q29tcGxldGlvbkNodW5rPiB8IENoYXRDb21wbGV0aW9uPjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPENoYXRDb21wbGV0aW9uPiB8IEFQSVByb21pc2U8U3RyZWFtPENoYXRDb21wbGV0aW9uQ2h1bms+PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvY2hhdC9jb21wbGV0aW9ucycsIHsgYm9keSwgLi4ub3B0aW9ucywgc3RyZWFtOiBib2R5LnN0cmVhbSA/PyBmYWxzZSB9KSBhc1xuICAgICAgfCBBUElQcm9taXNlPENoYXRDb21wbGV0aW9uPlxuICAgICAgfCBBUElQcm9taXNlPFN0cmVhbTxDaGF0Q29tcGxldGlvbkNodW5rPj47XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hhdCBjb21wbGV0aW9uIHJlc3BvbnNlIHJldHVybmVkIGJ5IG1vZGVsLCBiYXNlZCBvbiB0aGUgcHJvdmlkZWRcbiAqIGlucHV0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjaGF0IGNvbXBsZXRpb24uXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgY2hhdCBjb21wbGV0aW9uIGNob2ljZXMuIENhbiBiZSBtb3JlIHRoYW4gb25lIGlmIGBuYCBpcyBncmVhdGVyXG4gICAqIHRoYW4gMS5cbiAgICovXG4gIGNob2ljZXM6IEFycmF5PENoYXRDb21wbGV0aW9uLkNob2ljZT47XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgb2Ygd2hlbiB0aGUgY2hhdCBjb21wbGV0aW9uIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdXNlZCBmb3IgdGhlIGNoYXQgY29tcGxldGlvbi5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGBjaGF0LmNvbXBsZXRpb25gLlxuICAgKi9cbiAgb2JqZWN0OiAnY2hhdC5jb21wbGV0aW9uJztcblxuICAvKipcbiAgICogVGhlIHNlcnZpY2UgdGllciB1c2VkIGZvciBwcm9jZXNzaW5nIHRoZSByZXF1ZXN0LiBUaGlzIGZpZWxkIGlzIG9ubHkgaW5jbHVkZWQgaWZcbiAgICogdGhlIGBzZXJ2aWNlX3RpZXJgIHBhcmFtZXRlciBpcyBzcGVjaWZpZWQgaW4gdGhlIHJlcXVlc3QuXG4gICAqL1xuICBzZXJ2aWNlX3RpZXI/OiAnc2NhbGUnIHwgJ2RlZmF1bHQnIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhpcyBmaW5nZXJwcmludCByZXByZXNlbnRzIHRoZSBiYWNrZW5kIGNvbmZpZ3VyYXRpb24gdGhhdCB0aGUgbW9kZWwgcnVucyB3aXRoLlxuICAgKlxuICAgKiBDYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBgc2VlZGAgcmVxdWVzdCBwYXJhbWV0ZXIgdG8gdW5kZXJzdGFuZCB3aGVuXG4gICAqIGJhY2tlbmQgY2hhbmdlcyBoYXZlIGJlZW4gbWFkZSB0aGF0IG1pZ2h0IGltcGFjdCBkZXRlcm1pbmlzbS5cbiAgICovXG4gIHN5c3RlbV9maW5nZXJwcmludD86IHN0cmluZztcblxuICAvKipcbiAgICogVXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIGNvbXBsZXRpb24gcmVxdWVzdC5cbiAgICovXG4gIHVzYWdlPzogQ29tcGxldGlvbnNBUEkuQ29tcGxldGlvblVzYWdlO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uIHtcbiAgZXhwb3J0IGludGVyZmFjZSBDaG9pY2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSByZWFzb24gdGhlIG1vZGVsIHN0b3BwZWQgZ2VuZXJhdGluZyB0b2tlbnMuIFRoaXMgd2lsbCBiZSBgc3RvcGAgaWYgdGhlIG1vZGVsXG4gICAgICogaGl0IGEgbmF0dXJhbCBzdG9wIHBvaW50IG9yIGEgcHJvdmlkZWQgc3RvcCBzZXF1ZW5jZSwgYGxlbmd0aGAgaWYgdGhlIG1heGltdW1cbiAgICAgKiBudW1iZXIgb2YgdG9rZW5zIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdCB3YXMgcmVhY2hlZCwgYGNvbnRlbnRfZmlsdGVyYCBpZlxuICAgICAqIGNvbnRlbnQgd2FzIG9taXR0ZWQgZHVlIHRvIGEgZmxhZyBmcm9tIG91ciBjb250ZW50IGZpbHRlcnMsIGB0b29sX2NhbGxzYCBpZiB0aGVcbiAgICAgKiBtb2RlbCBjYWxsZWQgYSB0b29sLCBvciBgZnVuY3Rpb25fY2FsbGAgKGRlcHJlY2F0ZWQpIGlmIHRoZSBtb2RlbCBjYWxsZWQgYVxuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZpbmlzaF9yZWFzb246ICdzdG9wJyB8ICdsZW5ndGgnIHwgJ3Rvb2xfY2FsbHMnIHwgJ2NvbnRlbnRfZmlsdGVyJyB8ICdmdW5jdGlvbl9jYWxsJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgY2hvaWNlIGluIHRoZSBsaXN0IG9mIGNob2ljZXMuXG4gICAgICovXG4gICAgaW5kZXg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIExvZyBwcm9iYWJpbGl0eSBpbmZvcm1hdGlvbiBmb3IgdGhlIGNob2ljZS5cbiAgICAgKi9cbiAgICBsb2dwcm9iczogQ2hvaWNlLkxvZ3Byb2JzIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgY2hhdCBjb21wbGV0aW9uIG1lc3NhZ2UgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBtZXNzYWdlOiBDaGF0Q29tcGxldGlvbnNBUEkuQ2hhdENvbXBsZXRpb25NZXNzYWdlO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBDaG9pY2Uge1xuICAgIC8qKlxuICAgICAqIExvZyBwcm9iYWJpbGl0eSBpbmZvcm1hdGlvbiBmb3IgdGhlIGNob2ljZS5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIExvZ3Byb2JzIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIG1lc3NhZ2UgY29udGVudCB0b2tlbnMgd2l0aCBsb2cgcHJvYmFiaWxpdHkgaW5mb3JtYXRpb24uXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ6IEFycmF5PENoYXRDb21wbGV0aW9uc0FQSS5DaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYj4gfCBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBtZXNzYWdlIHJlZnVzYWwgdG9rZW5zIHdpdGggbG9nIHByb2JhYmlsaXR5IGluZm9ybWF0aW9uLlxuICAgICAgICovXG4gICAgICByZWZ1c2FsOiBBcnJheTxDaGF0Q29tcGxldGlvbnNBUEkuQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2I+IHwgbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXNzYWdlcyBzZW50IGJ5IHRoZSBtb2RlbCBpbiByZXNwb25zZSB0byB1c2VyIG1lc3NhZ2VzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtIHtcbiAgLyoqXG4gICAqIFRoZSByb2xlIG9mIHRoZSBtZXNzYWdlcyBhdXRob3IsIGluIHRoaXMgY2FzZSBgYXNzaXN0YW50YC5cbiAgICovXG4gIHJvbGU6ICdhc3Npc3RhbnQnO1xuXG4gIC8qKlxuICAgKiBEYXRhIGFib3V0IGEgcHJldmlvdXMgYXVkaW8gcmVzcG9uc2UgZnJvbSB0aGUgbW9kZWwuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYXVkaW8pLlxuICAgKi9cbiAgYXVkaW8/OiBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbS5BdWRpbyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgYXNzaXN0YW50IG1lc3NhZ2UuIFJlcXVpcmVkIHVubGVzcyBgdG9vbF9jYWxsc2Agb3JcbiAgICogYGZ1bmN0aW9uX2NhbGxgIGlzIHNwZWNpZmllZC5cbiAgICovXG4gIGNvbnRlbnQ/OiBzdHJpbmcgfCBBcnJheTxDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dCB8IENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRSZWZ1c2FsPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkOiBEZXByZWNhdGVkIGFuZCByZXBsYWNlZCBieSBgdG9vbF9jYWxsc2AuIFRoZSBuYW1lIGFuZCBhcmd1bWVudHMgb2ZcbiAgICogYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQsIGFzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICBmdW5jdGlvbl9jYWxsPzogQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0uRnVuY3Rpb25DYWxsIHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIHBhcnRpY2lwYW50LiBQcm92aWRlcyB0aGUgbW9kZWwgaW5mb3JtYXRpb24gdG9cbiAgICogZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHBhcnRpY2lwYW50cyBvZiB0aGUgc2FtZSByb2xlLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJlZnVzYWwgbWVzc2FnZSBieSB0aGUgYXNzaXN0YW50LlxuICAgKi9cbiAgcmVmdXNhbD86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSB0b29sIGNhbGxzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwsIHN1Y2ggYXMgZnVuY3Rpb24gY2FsbHMuXG4gICAqL1xuICB0b29sX2NhbGxzPzogQXJyYXk8Q2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGw+O1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtIHtcbiAgLyoqXG4gICAqIERhdGEgYWJvdXQgYSBwcmV2aW91cyBhdWRpbyByZXNwb25zZSBmcm9tIHRoZSBtb2RlbC5cbiAgICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9hdWRpbykuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEF1ZGlvIHtcbiAgICAvKipcbiAgICAgKiBVbmlxdWUgaWRlbnRpZmllciBmb3IgYSBwcmV2aW91cyBhdWRpbyByZXNwb25zZSBmcm9tIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBpZDogc3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkOiBEZXByZWNhdGVkIGFuZCByZXBsYWNlZCBieSBgdG9vbF9jYWxsc2AuIFRoZSBuYW1lIGFuZCBhcmd1bWVudHMgb2ZcbiAgICogYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQsIGFzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQ2FsbCB7XG4gICAgLyoqXG4gICAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICAgKiBmb3JtYXQuIE5vdGUgdGhhdCB0aGUgbW9kZWwgZG9lcyBub3QgYWx3YXlzIGdlbmVyYXRlIHZhbGlkIEpTT04sIGFuZCBtYXlcbiAgICAgKiBoYWxsdWNpbmF0ZSBwYXJhbWV0ZXJzIG5vdCBkZWZpbmVkIGJ5IHlvdXIgZnVuY3Rpb24gc2NoZW1hLiBWYWxpZGF0ZSB0aGVcbiAgICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXJndW1lbnRzOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBJZiB0aGUgYXVkaW8gb3V0cHV0IG1vZGFsaXR5IGlzIHJlcXVlc3RlZCwgdGhpcyBvYmplY3QgY29udGFpbnMgZGF0YSBhYm91dCB0aGVcbiAqIGF1ZGlvIHJlc3BvbnNlIGZyb20gdGhlIG1vZGVsLlxuICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9hdWRpbykuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25BdWRpbyB7XG4gIC8qKlxuICAgKiBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBhdWRpbyByZXNwb25zZS5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEJhc2U2NCBlbmNvZGVkIGF1ZGlvIGJ5dGVzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwsIGluIHRoZSBmb3JtYXQgc3BlY2lmaWVkIGluXG4gICAqIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgZGF0YTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoaXMgYXVkaW8gcmVzcG9uc2Ugd2lsbCBubyBsb25nZXIgYmVcbiAgICogYWNjZXNzaWJsZSBvbiB0aGUgc2VydmVyIGZvciB1c2UgaW4gbXVsdGktdHVybiBjb252ZXJzYXRpb25zLlxuICAgKi9cbiAgZXhwaXJlc19hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUcmFuc2NyaXB0IG9mIHRoZSBhdWRpbyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgdHJhbnNjcmlwdDogc3RyaW5nO1xufVxuXG4vKipcbiAqIFBhcmFtZXRlcnMgZm9yIGF1ZGlvIG91dHB1dC4gUmVxdWlyZWQgd2hlbiBhdWRpbyBvdXRwdXQgaXMgcmVxdWVzdGVkIHdpdGhcbiAqIGBtb2RhbGl0aWVzOiBbXCJhdWRpb1wiXWAuXG4gKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2F1ZGlvKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkF1ZGlvUGFyYW0ge1xuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBvdXRwdXQgYXVkaW8gZm9ybWF0LiBNdXN0IGJlIG9uZSBvZiBgd2F2YCwgYG1wM2AsIGBmbGFjYCwgYG9wdXNgLFxuICAgKiBvciBgcGNtMTZgLlxuICAgKi9cbiAgZm9ybWF0OiAnd2F2JyB8ICdtcDMnIHwgJ2ZsYWMnIHwgJ29wdXMnIHwgJ3BjbTE2JztcblxuICAvKipcbiAgICogVGhlIHZvaWNlIHRoZSBtb2RlbCB1c2VzIHRvIHJlc3BvbmQuIFN1cHBvcnRlZCB2b2ljZXMgYXJlIGBhc2hgLCBgYmFsbGFkYCxcbiAgICogYGNvcmFsYCwgYHNhZ2VgLCBhbmQgYHZlcnNlYCAoYWxzbyBzdXBwb3J0ZWQgYnV0IG5vdCByZWNvbW1lbmRlZCBhcmUgYGFsbG95YCxcbiAgICogYGVjaG9gLCBhbmQgYHNoaW1tZXJgOyB0aGVzZSB2b2ljZXMgYXJlIGxlc3MgZXhwcmVzc2l2ZSkuXG4gICAqL1xuICB2b2ljZTogJ2FsbG95JyB8ICdhc2gnIHwgJ2JhbGxhZCcgfCAnY29yYWwnIHwgJ2VjaG8nIHwgJ3NhZ2UnIHwgJ3NoaW1tZXInIHwgJ3ZlcnNlJztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3RyZWFtZWQgY2h1bmsgb2YgYSBjaGF0IGNvbXBsZXRpb24gcmVzcG9uc2UgcmV0dXJuZWQgYnkgbW9kZWwsXG4gKiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgaW5wdXQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25DaHVuayB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY2hhdCBjb21wbGV0aW9uLiBFYWNoIGNodW5rIGhhcyB0aGUgc2FtZSBJRC5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBjaGF0IGNvbXBsZXRpb24gY2hvaWNlcy4gQ2FuIGNvbnRhaW4gbW9yZSB0aGFuIG9uZSBlbGVtZW50cyBpZiBgbmAgaXNcbiAgICogZ3JlYXRlciB0aGFuIDEuIENhbiBhbHNvIGJlIGVtcHR5IGZvciB0aGUgbGFzdCBjaHVuayBpZiB5b3Ugc2V0XG4gICAqIGBzdHJlYW1fb3B0aW9uczoge1wiaW5jbHVkZV91c2FnZVwiOiB0cnVlfWAuXG4gICAqL1xuICBjaG9pY2VzOiBBcnJheTxDaGF0Q29tcGxldGlvbkNodW5rLkNob2ljZT47XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgb2Ygd2hlbiB0aGUgY2hhdCBjb21wbGV0aW9uIHdhcyBjcmVhdGVkLiBFYWNoXG4gICAqIGNodW5rIGhhcyB0aGUgc2FtZSB0aW1lc3RhbXAuXG4gICAqL1xuICBjcmVhdGVkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlbCB0byBnZW5lcmF0ZSB0aGUgY29tcGxldGlvbi5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGBjaGF0LmNvbXBsZXRpb24uY2h1bmtgLlxuICAgKi9cbiAgb2JqZWN0OiAnY2hhdC5jb21wbGV0aW9uLmNodW5rJztcblxuICAvKipcbiAgICogVGhlIHNlcnZpY2UgdGllciB1c2VkIGZvciBwcm9jZXNzaW5nIHRoZSByZXF1ZXN0LiBUaGlzIGZpZWxkIGlzIG9ubHkgaW5jbHVkZWQgaWZcbiAgICogdGhlIGBzZXJ2aWNlX3RpZXJgIHBhcmFtZXRlciBpcyBzcGVjaWZpZWQgaW4gdGhlIHJlcXVlc3QuXG4gICAqL1xuICBzZXJ2aWNlX3RpZXI/OiAnc2NhbGUnIHwgJ2RlZmF1bHQnIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhpcyBmaW5nZXJwcmludCByZXByZXNlbnRzIHRoZSBiYWNrZW5kIGNvbmZpZ3VyYXRpb24gdGhhdCB0aGUgbW9kZWwgcnVucyB3aXRoLlxuICAgKiBDYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBgc2VlZGAgcmVxdWVzdCBwYXJhbWV0ZXIgdG8gdW5kZXJzdGFuZCB3aGVuXG4gICAqIGJhY2tlbmQgY2hhbmdlcyBoYXZlIGJlZW4gbWFkZSB0aGF0IG1pZ2h0IGltcGFjdCBkZXRlcm1pbmlzbS5cbiAgICovXG4gIHN5c3RlbV9maW5nZXJwcmludD86IHN0cmluZztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgZmllbGQgdGhhdCB3aWxsIG9ubHkgYmUgcHJlc2VudCB3aGVuIHlvdSBzZXRcbiAgICogYHN0cmVhbV9vcHRpb25zOiB7XCJpbmNsdWRlX3VzYWdlXCI6IHRydWV9YCBpbiB5b3VyIHJlcXVlc3QuIFdoZW4gcHJlc2VudCwgaXRcbiAgICogY29udGFpbnMgYSBudWxsIHZhbHVlIGV4Y2VwdCBmb3IgdGhlIGxhc3QgY2h1bmsgd2hpY2ggY29udGFpbnMgdGhlIHRva2VuIHVzYWdlXG4gICAqIHN0YXRpc3RpY3MgZm9yIHRoZSBlbnRpcmUgcmVxdWVzdC5cbiAgICovXG4gIHVzYWdlPzogQ29tcGxldGlvbnNBUEkuQ29tcGxldGlvblVzYWdlIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0Q29tcGxldGlvbkNodW5rIHtcbiAgZXhwb3J0IGludGVyZmFjZSBDaG9pY2Uge1xuICAgIC8qKlxuICAgICAqIEEgY2hhdCBjb21wbGV0aW9uIGRlbHRhIGdlbmVyYXRlZCBieSBzdHJlYW1lZCBtb2RlbCByZXNwb25zZXMuXG4gICAgICovXG4gICAgZGVsdGE6IENob2ljZS5EZWx0YTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZWFzb24gdGhlIG1vZGVsIHN0b3BwZWQgZ2VuZXJhdGluZyB0b2tlbnMuIFRoaXMgd2lsbCBiZSBgc3RvcGAgaWYgdGhlIG1vZGVsXG4gICAgICogaGl0IGEgbmF0dXJhbCBzdG9wIHBvaW50IG9yIGEgcHJvdmlkZWQgc3RvcCBzZXF1ZW5jZSwgYGxlbmd0aGAgaWYgdGhlIG1heGltdW1cbiAgICAgKiBudW1iZXIgb2YgdG9rZW5zIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdCB3YXMgcmVhY2hlZCwgYGNvbnRlbnRfZmlsdGVyYCBpZlxuICAgICAqIGNvbnRlbnQgd2FzIG9taXR0ZWQgZHVlIHRvIGEgZmxhZyBmcm9tIG91ciBjb250ZW50IGZpbHRlcnMsIGB0b29sX2NhbGxzYCBpZiB0aGVcbiAgICAgKiBtb2RlbCBjYWxsZWQgYSB0b29sLCBvciBgZnVuY3Rpb25fY2FsbGAgKGRlcHJlY2F0ZWQpIGlmIHRoZSBtb2RlbCBjYWxsZWQgYVxuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZpbmlzaF9yZWFzb246ICdzdG9wJyB8ICdsZW5ndGgnIHwgJ3Rvb2xfY2FsbHMnIHwgJ2NvbnRlbnRfZmlsdGVyJyB8ICdmdW5jdGlvbl9jYWxsJyB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGNob2ljZSBpbiB0aGUgbGlzdCBvZiBjaG9pY2VzLlxuICAgICAqL1xuICAgIGluZGV4OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBMb2cgcHJvYmFiaWxpdHkgaW5mb3JtYXRpb24gZm9yIHRoZSBjaG9pY2UuXG4gICAgICovXG4gICAgbG9ncHJvYnM/OiBDaG9pY2UuTG9ncHJvYnMgfCBudWxsO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBDaG9pY2Uge1xuICAgIC8qKlxuICAgICAqIEEgY2hhdCBjb21wbGV0aW9uIGRlbHRhIGdlbmVyYXRlZCBieSBzdHJlYW1lZCBtb2RlbCByZXNwb25zZXMuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBEZWx0YSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjb250ZW50cyBvZiB0aGUgY2h1bmsgbWVzc2FnZS5cbiAgICAgICAqL1xuICAgICAgY29udGVudD86IHN0cmluZyB8IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogQGRlcHJlY2F0ZWQ6IERlcHJlY2F0ZWQgYW5kIHJlcGxhY2VkIGJ5IGB0b29sX2NhbGxzYC4gVGhlIG5hbWUgYW5kIGFyZ3VtZW50cyBvZlxuICAgICAgICogYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQsIGFzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uX2NhbGw/OiBEZWx0YS5GdW5jdGlvbkNhbGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHJlZnVzYWwgbWVzc2FnZSBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgICAgICovXG4gICAgICByZWZ1c2FsPzogc3RyaW5nIHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcm9sZSBvZiB0aGUgYXV0aG9yIG9mIHRoaXMgbWVzc2FnZS5cbiAgICAgICAqL1xuICAgICAgcm9sZT86ICdzeXN0ZW0nIHwgJ3VzZXInIHwgJ2Fzc2lzdGFudCcgfCAndG9vbCc7XG5cbiAgICAgIHRvb2xfY2FsbHM/OiBBcnJheTxEZWx0YS5Ub29sQ2FsbD47XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBEZWx0YSB7XG4gICAgICAvKipcbiAgICAgICAqIEBkZXByZWNhdGVkOiBEZXByZWNhdGVkIGFuZCByZXBsYWNlZCBieSBgdG9vbF9jYWxsc2AuIFRoZSBuYW1lIGFuZCBhcmd1bWVudHMgb2ZcbiAgICAgICAqIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgICAgICovXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQ2FsbCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGgsIGFzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaW4gSlNPTlxuICAgICAgICAgKiBmb3JtYXQuIE5vdGUgdGhhdCB0aGUgbW9kZWwgZG9lcyBub3QgYWx3YXlzIGdlbmVyYXRlIHZhbGlkIEpTT04sIGFuZCBtYXlcbiAgICAgICAgICogaGFsbHVjaW5hdGUgcGFyYW1ldGVycyBub3QgZGVmaW5lZCBieSB5b3VyIGZ1bmN0aW9uIHNjaGVtYS4gVmFsaWRhdGUgdGhlXG4gICAgICAgICAqIGFyZ3VtZW50cyBpbiB5b3VyIGNvZGUgYmVmb3JlIGNhbGxpbmcgeW91ciBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGFyZ3VtZW50cz86IHN0cmluZztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgICBuYW1lPzogc3RyaW5nO1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIFRvb2xDYWxsIHtcbiAgICAgICAgaW5kZXg6IG51bWJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgICBpZD86IHN0cmluZztcblxuICAgICAgICBmdW5jdGlvbj86IFRvb2xDYWxsLkZ1bmN0aW9uO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbC4gQ3VycmVudGx5LCBvbmx5IGBmdW5jdGlvbmAgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZT86ICdmdW5jdGlvbic7XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydCBuYW1lc3BhY2UgVG9vbENhbGwge1xuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGgsIGFzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaW4gSlNPTlxuICAgICAgICAgICAqIGZvcm1hdC4gTm90ZSB0aGF0IHRoZSBtb2RlbCBkb2VzIG5vdCBhbHdheXMgZ2VuZXJhdGUgdmFsaWQgSlNPTiwgYW5kIG1heVxuICAgICAgICAgICAqIGhhbGx1Y2luYXRlIHBhcmFtZXRlcnMgbm90IGRlZmluZWQgYnkgeW91ciBmdW5jdGlvbiBzY2hlbWEuIFZhbGlkYXRlIHRoZVxuICAgICAgICAgICAqIGFyZ3VtZW50cyBpbiB5b3VyIGNvZGUgYmVmb3JlIGNhbGxpbmcgeW91ciBmdW5jdGlvbi5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBhcmd1bWVudHM/OiBzdHJpbmc7XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBuYW1lPzogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9nIHByb2JhYmlsaXR5IGluZm9ybWF0aW9uIGZvciB0aGUgY2hvaWNlLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgTG9ncHJvYnMge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgbWVzc2FnZSBjb250ZW50IHRva2VucyB3aXRoIGxvZyBwcm9iYWJpbGl0eSBpbmZvcm1hdGlvbi5cbiAgICAgICAqL1xuICAgICAgY29udGVudDogQXJyYXk8Q2hhdENvbXBsZXRpb25zQVBJLkNoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iPiB8IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIG1lc3NhZ2UgcmVmdXNhbCB0b2tlbnMgd2l0aCBsb2cgcHJvYmFiaWxpdHkgaW5mb3JtYXRpb24uXG4gICAgICAgKi9cbiAgICAgIHJlZnVzYWw6IEFycmF5PENoYXRDb21wbGV0aW9uc0FQSS5DaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYj4gfCBudWxsO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIExlYXJuIGFib3V0XG4gKiBbdGV4dCBpbnB1dHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy90ZXh0LWdlbmVyYXRpb24pLlxuICovXG5leHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0ID1cbiAgfCBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dFxuICB8IENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbWFnZVxuICB8IENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbnB1dEF1ZGlvO1xuXG4vKipcbiAqIExlYXJuIGFib3V0IFtpbWFnZSBpbnB1dHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy92aXNpb24pLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbWFnZSB7XG4gIGltYWdlX3VybDogQ2hhdENvbXBsZXRpb25Db250ZW50UGFydEltYWdlLkltYWdlVVJMO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgY29udGVudCBwYXJ0LlxuICAgKi9cbiAgdHlwZTogJ2ltYWdlX3VybCc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydEltYWdlIHtcbiAgZXhwb3J0IGludGVyZmFjZSBJbWFnZVVSTCB7XG4gICAgLyoqXG4gICAgICogRWl0aGVyIGEgVVJMIG9mIHRoZSBpbWFnZSBvciB0aGUgYmFzZTY0IGVuY29kZWQgaW1hZ2UgZGF0YS5cbiAgICAgKi9cbiAgICB1cmw6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgZGV0YWlsIGxldmVsIG9mIHRoZSBpbWFnZS4gTGVhcm4gbW9yZSBpbiB0aGVcbiAgICAgKiBbVmlzaW9uIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvdmlzaW9uI2xvdy1vci1oaWdoLWZpZGVsaXR5LWltYWdlLXVuZGVyc3RhbmRpbmcpLlxuICAgICAqL1xuICAgIGRldGFpbD86ICdhdXRvJyB8ICdsb3cnIHwgJ2hpZ2gnO1xuICB9XG59XG5cbi8qKlxuICogTGVhcm4gYWJvdXQgW2F1ZGlvIGlucHV0c10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2F1ZGlvKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW5wdXRBdWRpbyB7XG4gIGlucHV0X2F1ZGlvOiBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW5wdXRBdWRpby5JbnB1dEF1ZGlvO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgY29udGVudCBwYXJ0LiBBbHdheXMgYGlucHV0X2F1ZGlvYC5cbiAgICovXG4gIHR5cGU6ICdpbnB1dF9hdWRpbyc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydElucHV0QXVkaW8ge1xuICBleHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW8ge1xuICAgIC8qKlxuICAgICAqIEJhc2U2NCBlbmNvZGVkIGF1ZGlvIGRhdGEuXG4gICAgICovXG4gICAgZGF0YTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcm1hdCBvZiB0aGUgZW5jb2RlZCBhdWRpbyBkYXRhLiBDdXJyZW50bHkgc3VwcG9ydHMgXCJ3YXZcIiBhbmQgXCJtcDNcIi5cbiAgICAgKi9cbiAgICBmb3JtYXQ6ICd3YXYnIHwgJ21wMyc7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0UmVmdXNhbCB7XG4gIC8qKlxuICAgKiBUaGUgcmVmdXNhbCBtZXNzYWdlIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICByZWZ1c2FsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBjb250ZW50IHBhcnQuXG4gICAqL1xuICB0eXBlOiAncmVmdXNhbCc7XG59XG5cbi8qKlxuICogTGVhcm4gYWJvdXRcbiAqIFt0ZXh0IGlucHV0c10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3RleHQtZ2VuZXJhdGlvbikuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQge1xuICAvKipcbiAgICogVGhlIHRleHQgY29udGVudC5cbiAgICovXG4gIHRleHQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIGNvbnRlbnQgcGFydC5cbiAgICovXG4gIHR5cGU6ICd0ZXh0Jztcbn1cblxuLyoqXG4gKiBEZXZlbG9wZXItcHJvdmlkZWQgaW5zdHJ1Y3Rpb25zIHRoYXQgdGhlIG1vZGVsIHNob3VsZCBmb2xsb3csIHJlZ2FyZGxlc3Mgb2ZcbiAqIG1lc3NhZ2VzIHNlbnQgYnkgdGhlIHVzZXIuIFdpdGggbzEgbW9kZWxzIGFuZCBuZXdlciwgYGRldmVsb3BlcmAgbWVzc2FnZXNcbiAqIHJlcGxhY2UgdGhlIHByZXZpb3VzIGBzeXN0ZW1gIG1lc3NhZ2VzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uRGV2ZWxvcGVyTWVzc2FnZVBhcmFtIHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgZGV2ZWxvcGVyIG1lc3NhZ2UuXG4gICAqL1xuICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dD47XG5cbiAgLyoqXG4gICAqIFRoZSByb2xlIG9mIHRoZSBtZXNzYWdlcyBhdXRob3IsIGluIHRoaXMgY2FzZSBgZGV2ZWxvcGVyYC5cbiAgICovXG4gIHJvbGU6ICdkZXZlbG9wZXInO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBuYW1lIGZvciB0aGUgcGFydGljaXBhbnQuIFByb3ZpZGVzIHRoZSBtb2RlbCBpbmZvcm1hdGlvbiB0b1xuICAgKiBkaWZmZXJlbnRpYXRlIGJldHdlZW4gcGFydGljaXBhbnRzIG9mIHRoZSBzYW1lIHJvbGUuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFNwZWNpZnlpbmcgYSBwYXJ0aWN1bGFyIGZ1bmN0aW9uIHZpYSBge1wibmFtZVwiOiBcIm15X2Z1bmN0aW9uXCJ9YCBmb3JjZXMgdGhlIG1vZGVsXG4gKiB0byBjYWxsIHRoYXQgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25GdW5jdGlvbkNhbGxPcHRpb24ge1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAqL1xuICBuYW1lOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uTWVzc2FnZVBhcmFtIHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgZnVuY3Rpb24gbWVzc2FnZS5cbiAgICovXG4gIGNvbnRlbnQ6IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgbWVzc2FnZXMgYXV0aG9yLCBpbiB0aGlzIGNhc2UgYGZ1bmN0aW9uYC5cbiAgICovXG4gIHJvbGU6ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogQSBjaGF0IGNvbXBsZXRpb24gbWVzc2FnZSBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBjb250ZW50OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVmdXNhbCBtZXNzYWdlIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICByZWZ1c2FsOiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgYXV0aG9yIG9mIHRoaXMgbWVzc2FnZS5cbiAgICovXG4gIHJvbGU6ICdhc3Npc3RhbnQnO1xuXG4gIC8qKlxuICAgKiBJZiB0aGUgYXVkaW8gb3V0cHV0IG1vZGFsaXR5IGlzIHJlcXVlc3RlZCwgdGhpcyBvYmplY3QgY29udGFpbnMgZGF0YSBhYm91dCB0aGVcbiAgICogYXVkaW8gcmVzcG9uc2UgZnJvbSB0aGUgbW9kZWwuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYXVkaW8pLlxuICAgKi9cbiAgYXVkaW8/OiBDaGF0Q29tcGxldGlvbkF1ZGlvIHwgbnVsbDtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQ6IERlcHJlY2F0ZWQgYW5kIHJlcGxhY2VkIGJ5IGB0b29sX2NhbGxzYC4gVGhlIG5hbWUgYW5kIGFyZ3VtZW50cyBvZlxuICAgKiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIGZ1bmN0aW9uX2NhbGw/OiBDaGF0Q29tcGxldGlvbk1lc3NhZ2UuRnVuY3Rpb25DYWxsIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHRvb2wgY2FsbHMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCwgc3VjaCBhcyBmdW5jdGlvbiBjYWxscy5cbiAgICovXG4gIHRvb2xfY2FsbHM/OiBBcnJheTxDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbD47XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdENvbXBsZXRpb25NZXNzYWdlIHtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkOiBEZXByZWNhdGVkIGFuZCByZXBsYWNlZCBieSBgdG9vbF9jYWxsc2AuIFRoZSBuYW1lIGFuZCBhcmd1bWVudHMgb2ZcbiAgICogYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQsIGFzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQ2FsbCB7XG4gICAgLyoqXG4gICAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICAgKiBmb3JtYXQuIE5vdGUgdGhhdCB0aGUgbW9kZWwgZG9lcyBub3QgYWx3YXlzIGdlbmVyYXRlIHZhbGlkIEpTT04sIGFuZCBtYXlcbiAgICAgKiBoYWxsdWNpbmF0ZSBwYXJhbWV0ZXJzIG5vdCBkZWZpbmVkIGJ5IHlvdXIgZnVuY3Rpb24gc2NoZW1hLiBWYWxpZGF0ZSB0aGVcbiAgICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXJndW1lbnRzOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXZlbG9wZXItcHJvdmlkZWQgaW5zdHJ1Y3Rpb25zIHRoYXQgdGhlIG1vZGVsIHNob3VsZCBmb2xsb3csIHJlZ2FyZGxlc3Mgb2ZcbiAqIG1lc3NhZ2VzIHNlbnQgYnkgdGhlIHVzZXIuIFdpdGggbzEgbW9kZWxzIGFuZCBuZXdlciwgYGRldmVsb3BlcmAgbWVzc2FnZXNcbiAqIHJlcGxhY2UgdGhlIHByZXZpb3VzIGBzeXN0ZW1gIG1lc3NhZ2VzLlxuICovXG5leHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSA9XG4gIHwgQ2hhdENvbXBsZXRpb25EZXZlbG9wZXJNZXNzYWdlUGFyYW1cbiAgfCBDaGF0Q29tcGxldGlvblN5c3RlbU1lc3NhZ2VQYXJhbVxuICB8IENoYXRDb21wbGV0aW9uVXNlck1lc3NhZ2VQYXJhbVxuICB8IENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtXG4gIHwgQ2hhdENvbXBsZXRpb25Ub29sTWVzc2FnZVBhcmFtXG4gIHwgQ2hhdENvbXBsZXRpb25GdW5jdGlvbk1lc3NhZ2VQYXJhbTtcblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbC5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBmdW5jdGlvbiB0aGF0IHRoZSBtb2RlbCBjYWxsZWQuXG4gICAqL1xuICBmdW5jdGlvbjogQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwuRnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSB0b29sLiBDdXJyZW50bHksIG9ubHkgYGZ1bmN0aW9uYCBpcyBzdXBwb3J0ZWQuXG4gICAqL1xuICB0eXBlOiAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsIHtcbiAgLyoqXG4gICAqIFRoZSBmdW5jdGlvbiB0aGF0IHRoZSBtb2RlbCBjYWxsZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGgsIGFzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaW4gSlNPTlxuICAgICAqIGZvcm1hdC4gTm90ZSB0aGF0IHRoZSBtb2RlbCBkb2VzIG5vdCBhbHdheXMgZ2VuZXJhdGUgdmFsaWQgSlNPTiwgYW5kIG1heVxuICAgICAqIGhhbGx1Y2luYXRlIHBhcmFtZXRlcnMgbm90IGRlZmluZWQgYnkgeW91ciBmdW5jdGlvbiBzY2hlbWEuIFZhbGlkYXRlIHRoZVxuICAgICAqIGFyZ3VtZW50cyBpbiB5b3VyIGNvZGUgYmVmb3JlIGNhbGxpbmcgeW91ciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBhcmd1bWVudHM6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZztcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvbk1vZGFsaXR5ID0gJ3RleHQnIHwgJ2F1ZGlvJztcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSB0b29sIHRoZSBtb2RlbCBzaG91bGQgdXNlLiBVc2UgdG8gZm9yY2UgdGhlIG1vZGVsIHRvIGNhbGwgYSBzcGVjaWZpY1xuICogZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25OYW1lZFRvb2xDaG9pY2Uge1xuICBmdW5jdGlvbjogQ2hhdENvbXBsZXRpb25OYW1lZFRvb2xDaG9pY2UuRnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSB0b29sLiBDdXJyZW50bHksIG9ubHkgYGZ1bmN0aW9uYCBpcyBzdXBwb3J0ZWQuXG4gICAqL1xuICB0eXBlOiAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlIHtcbiAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogU3RhdGljIHByZWRpY3RlZCBvdXRwdXQgY29udGVudCwgc3VjaCBhcyB0aGUgY29udGVudCBvZiBhIHRleHQgZmlsZSB0aGF0IGlzXG4gKiBiZWluZyByZWdlbmVyYXRlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvblByZWRpY3Rpb25Db250ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IHRoYXQgc2hvdWxkIGJlIG1hdGNoZWQgd2hlbiBnZW5lcmF0aW5nIGEgbW9kZWwgcmVzcG9uc2UuIElmXG4gICAqIGdlbmVyYXRlZCB0b2tlbnMgd291bGQgbWF0Y2ggdGhpcyBjb250ZW50LCB0aGUgZW50aXJlIG1vZGVsIHJlc3BvbnNlIGNhbiBiZVxuICAgKiByZXR1cm5lZCBtdWNoIG1vcmUgcXVpY2tseS5cbiAgICovXG4gIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0PjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIHByZWRpY3RlZCBjb250ZW50IHlvdSB3YW50IHRvIHByb3ZpZGUuIFRoaXMgdHlwZSBpcyBjdXJyZW50bHlcbiAgICogYWx3YXlzIGBjb250ZW50YC5cbiAgICovXG4gIHR5cGU6ICdjb250ZW50Jztcbn1cblxuLyoqXG4gKiAqKm8xIG1vZGVscyBvbmx5KipcbiAqXG4gKiBDb25zdHJhaW5zIGVmZm9ydCBvbiByZWFzb25pbmcgZm9yXG4gKiBbcmVhc29uaW5nIG1vZGVsc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3JlYXNvbmluZykuIEN1cnJlbnRseVxuICogc3VwcG9ydGVkIHZhbHVlcyBhcmUgYGxvd2AsIGBtZWRpdW1gLCBhbmQgYGhpZ2hgLiBSZWR1Y2luZyByZWFzb25pbmcgZWZmb3J0IGNhblxuICogcmVzdWx0IGluIGZhc3RlciByZXNwb25zZXMgYW5kIGZld2VyIHRva2VucyB1c2VkIG9uIHJlYXNvbmluZyBpbiBhIHJlc3BvbnNlLlxuICovXG5leHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvblJlYXNvbmluZ0VmZm9ydCA9ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCc7XG5cbi8qKlxuICogVGhlIHJvbGUgb2YgdGhlIGF1dGhvciBvZiBhIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25Sb2xlID0gJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50JyB8ICd0b29sJyB8ICdmdW5jdGlvbic7XG5cbi8qKlxuICogT3B0aW9ucyBmb3Igc3RyZWFtaW5nIHJlc3BvbnNlLiBPbmx5IHNldCB0aGlzIHdoZW4geW91IHNldCBgc3RyZWFtOiB0cnVlYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvblN0cmVhbU9wdGlvbnMge1xuICAvKipcbiAgICogSWYgc2V0LCBhbiBhZGRpdGlvbmFsIGNodW5rIHdpbGwgYmUgc3RyZWFtZWQgYmVmb3JlIHRoZSBgZGF0YTogW0RPTkVdYCBtZXNzYWdlLlxuICAgKiBUaGUgYHVzYWdlYCBmaWVsZCBvbiB0aGlzIGNodW5rIHNob3dzIHRoZSB0b2tlbiB1c2FnZSBzdGF0aXN0aWNzIGZvciB0aGUgZW50aXJlXG4gICAqIHJlcXVlc3QsIGFuZCB0aGUgYGNob2ljZXNgIGZpZWxkIHdpbGwgYWx3YXlzIGJlIGFuIGVtcHR5IGFycmF5LiBBbGwgb3RoZXIgY2h1bmtzXG4gICAqIHdpbGwgYWxzbyBpbmNsdWRlIGEgYHVzYWdlYCBmaWVsZCwgYnV0IHdpdGggYSBudWxsIHZhbHVlLlxuICAgKi9cbiAgaW5jbHVkZV91c2FnZT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogRGV2ZWxvcGVyLXByb3ZpZGVkIGluc3RydWN0aW9ucyB0aGF0IHRoZSBtb2RlbCBzaG91bGQgZm9sbG93LCByZWdhcmRsZXNzIG9mXG4gKiBtZXNzYWdlcyBzZW50IGJ5IHRoZSB1c2VyLiBXaXRoIG8xIG1vZGVscyBhbmQgbmV3ZXIsIHVzZSBgZGV2ZWxvcGVyYCBtZXNzYWdlc1xuICogZm9yIHRoaXMgcHVycG9zZSBpbnN0ZWFkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uU3lzdGVtTWVzc2FnZVBhcmFtIHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgc3lzdGVtIG1lc3NhZ2UuXG4gICAqL1xuICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dD47XG5cbiAgLyoqXG4gICAqIFRoZSByb2xlIG9mIHRoZSBtZXNzYWdlcyBhdXRob3IsIGluIHRoaXMgY2FzZSBgc3lzdGVtYC5cbiAgICovXG4gIHJvbGU6ICdzeXN0ZW0nO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBuYW1lIGZvciB0aGUgcGFydGljaXBhbnQuIFByb3ZpZGVzIHRoZSBtb2RlbCBpbmZvcm1hdGlvbiB0b1xuICAgKiBkaWZmZXJlbnRpYXRlIGJldHdlZW4gcGFydGljaXBhbnRzIG9mIHRoZSBzYW1lIHJvbGUuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iIHtcbiAgLyoqXG4gICAqIFRoZSB0b2tlbi5cbiAgICovXG4gIHRva2VuOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBpbnRlZ2VycyByZXByZXNlbnRpbmcgdGhlIFVURi04IGJ5dGVzIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0b2tlbi5cbiAgICogVXNlZnVsIGluIGluc3RhbmNlcyB3aGVyZSBjaGFyYWN0ZXJzIGFyZSByZXByZXNlbnRlZCBieSBtdWx0aXBsZSB0b2tlbnMgYW5kXG4gICAqIHRoZWlyIGJ5dGUgcmVwcmVzZW50YXRpb25zIG11c3QgYmUgY29tYmluZWQgdG8gZ2VuZXJhdGUgdGhlIGNvcnJlY3QgdGV4dFxuICAgKiByZXByZXNlbnRhdGlvbi4gQ2FuIGJlIGBudWxsYCBpZiB0aGVyZSBpcyBubyBieXRlcyByZXByZXNlbnRhdGlvbiBmb3IgdGhlIHRva2VuLlxuICAgKi9cbiAgYnl0ZXM6IEFycmF5PG51bWJlcj4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbG9nIHByb2JhYmlsaXR5IG9mIHRoaXMgdG9rZW4sIGlmIGl0IGlzIHdpdGhpbiB0aGUgdG9wIDIwIG1vc3QgbGlrZWx5XG4gICAqIHRva2Vucy4gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgYC05OTk5LjBgIGlzIHVzZWQgdG8gc2lnbmlmeSB0aGF0IHRoZSB0b2tlbiBpcyB2ZXJ5XG4gICAqIHVubGlrZWx5LlxuICAgKi9cbiAgbG9ncHJvYjogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHRoZSBtb3N0IGxpa2VseSB0b2tlbnMgYW5kIHRoZWlyIGxvZyBwcm9iYWJpbGl0eSwgYXQgdGhpcyB0b2tlblxuICAgKiBwb3NpdGlvbi4gSW4gcmFyZSBjYXNlcywgdGhlcmUgbWF5IGJlIGZld2VyIHRoYW4gdGhlIG51bWJlciBvZiByZXF1ZXN0ZWRcbiAgICogYHRvcF9sb2dwcm9ic2AgcmV0dXJuZWQuXG4gICAqL1xuICB0b3BfbG9ncHJvYnM6IEFycmF5PENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iLlRvcExvZ3Byb2I+O1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iIHtcbiAgZXhwb3J0IGludGVyZmFjZSBUb3BMb2dwcm9iIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdG9rZW4uXG4gICAgICovXG4gICAgdG9rZW46IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBpbnRlZ2VycyByZXByZXNlbnRpbmcgdGhlIFVURi04IGJ5dGVzIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0b2tlbi5cbiAgICAgKiBVc2VmdWwgaW4gaW5zdGFuY2VzIHdoZXJlIGNoYXJhY3RlcnMgYXJlIHJlcHJlc2VudGVkIGJ5IG11bHRpcGxlIHRva2VucyBhbmRcbiAgICAgKiB0aGVpciBieXRlIHJlcHJlc2VudGF0aW9ucyBtdXN0IGJlIGNvbWJpbmVkIHRvIGdlbmVyYXRlIHRoZSBjb3JyZWN0IHRleHRcbiAgICAgKiByZXByZXNlbnRhdGlvbi4gQ2FuIGJlIGBudWxsYCBpZiB0aGVyZSBpcyBubyBieXRlcyByZXByZXNlbnRhdGlvbiBmb3IgdGhlIHRva2VuLlxuICAgICAqL1xuICAgIGJ5dGVzOiBBcnJheTxudW1iZXI+IHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb2cgcHJvYmFiaWxpdHkgb2YgdGhpcyB0b2tlbiwgaWYgaXQgaXMgd2l0aGluIHRoZSB0b3AgMjAgbW9zdCBsaWtlbHlcbiAgICAgKiB0b2tlbnMuIE90aGVyd2lzZSwgdGhlIHZhbHVlIGAtOTk5OS4wYCBpcyB1c2VkIHRvIHNpZ25pZnkgdGhhdCB0aGUgdG9rZW4gaXMgdmVyeVxuICAgICAqIHVubGlrZWx5LlxuICAgICAqL1xuICAgIGxvZ3Byb2I6IG51bWJlcjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uVG9vbCB7XG4gIGZ1bmN0aW9uOiBTaGFyZWQuRnVuY3Rpb25EZWZpbml0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbC4gQ3VycmVudGx5LCBvbmx5IGBmdW5jdGlvbmAgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgdHlwZTogJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBDb250cm9scyB3aGljaCAoaWYgYW55KSB0b29sIGlzIGNhbGxlZCBieSB0aGUgbW9kZWwuIGBub25lYCBtZWFucyB0aGUgbW9kZWwgd2lsbFxuICogbm90IGNhbGwgYW55IHRvb2wgYW5kIGluc3RlYWQgZ2VuZXJhdGVzIGEgbWVzc2FnZS4gYGF1dG9gIG1lYW5zIHRoZSBtb2RlbCBjYW5cbiAqIHBpY2sgYmV0d2VlbiBnZW5lcmF0aW5nIGEgbWVzc2FnZSBvciBjYWxsaW5nIG9uZSBvciBtb3JlIHRvb2xzLiBgcmVxdWlyZWRgIG1lYW5zXG4gKiB0aGUgbW9kZWwgbXVzdCBjYWxsIG9uZSBvciBtb3JlIHRvb2xzLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciB0b29sIHZpYVxuICogYHtcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifX1gIGZvcmNlcyB0aGUgbW9kZWwgdG9cbiAqIGNhbGwgdGhhdCB0b29sLlxuICpcbiAqIGBub25lYCBpcyB0aGUgZGVmYXVsdCB3aGVuIG5vIHRvb2xzIGFyZSBwcmVzZW50LiBgYXV0b2AgaXMgdGhlIGRlZmF1bHQgaWYgdG9vbHNcbiAqIGFyZSBwcmVzZW50LlxuICovXG5leHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvblRvb2xDaG9pY2VPcHRpb24gPSAnbm9uZScgfCAnYXV0bycgfCAncmVxdWlyZWQnIHwgQ2hhdENvbXBsZXRpb25OYW1lZFRvb2xDaG9pY2U7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25Ub29sTWVzc2FnZVBhcmFtIHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgdG9vbCBtZXNzYWdlLlxuICAgKi9cbiAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8Q2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgbWVzc2FnZXMgYXV0aG9yLCBpbiB0aGlzIGNhc2UgYHRvb2xgLlxuICAgKi9cbiAgcm9sZTogJ3Rvb2wnO1xuXG4gIC8qKlxuICAgKiBUb29sIGNhbGwgdGhhdCB0aGlzIG1lc3NhZ2UgaXMgcmVzcG9uZGluZyB0by5cbiAgICovXG4gIHRvb2xfY2FsbF9pZDogc3RyaW5nO1xufVxuXG4vKipcbiAqIE1lc3NhZ2VzIHNlbnQgYnkgYW4gZW5kIHVzZXIsIGNvbnRhaW5pbmcgcHJvbXB0cyBvciBhZGRpdGlvbmFsIGNvbnRleHRcbiAqIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uVXNlck1lc3NhZ2VQYXJhbSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIHVzZXIgbWVzc2FnZS5cbiAgICovXG4gIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PENoYXRDb21wbGV0aW9uQ29udGVudFBhcnQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgbWVzc2FnZXMgYXV0aG9yLCBpbiB0aGlzIGNhc2UgYHVzZXJgLlxuICAgKi9cbiAgcm9sZTogJ3VzZXInO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBuYW1lIGZvciB0aGUgcGFydGljaXBhbnQuIFByb3ZpZGVzIHRoZSBtb2RlbCBpbmZvcm1hdGlvbiB0b1xuICAgKiBkaWZmZXJlbnRpYXRlIGJldHdlZW4gcGFydGljaXBhbnRzIG9mIHRoZSBzYW1lIHJvbGUuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtIHNob3VsZCBiZSB1c2VkIGluc3RlYWRcbiAqL1xuZXhwb3J0IHR5cGUgQ3JlYXRlQ2hhdENvbXBsZXRpb25SZXF1ZXN0TWVzc2FnZSA9IENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtO1xuXG5leHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyA9XG4gIHwgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmdcbiAgfCBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogQSBsaXN0IG9mIG1lc3NhZ2VzIGNvbXByaXNpbmcgdGhlIGNvbnZlcnNhdGlvbiBzbyBmYXIuIERlcGVuZGluZyBvbiB0aGVcbiAgICogW21vZGVsXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMpIHlvdSB1c2UsIGRpZmZlcmVudCBtZXNzYWdlXG4gICAqIHR5cGVzIChtb2RhbGl0aWVzKSBhcmUgc3VwcG9ydGVkLCBsaWtlXG4gICAqIFt0ZXh0XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvdGV4dC1nZW5lcmF0aW9uKSxcbiAgICogW2ltYWdlc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3Zpc2lvbiksIGFuZFxuICAgKiBbYXVkaW9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9hdWRpbykuXG4gICAqL1xuICBtZXNzYWdlczogQXJyYXk8Q2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0+O1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBTZWUgdGhlXG4gICAqIFttb2RlbCBlbmRwb2ludCBjb21wYXRpYmlsaXR5XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjbW9kZWwtZW5kcG9pbnQtY29tcGF0aWJpbGl0eSlcbiAgICogdGFibGUgZm9yIGRldGFpbHMgb24gd2hpY2ggbW9kZWxzIHdvcmsgd2l0aCB0aGUgQ2hhdCBBUEkuXG4gICAqL1xuICBtb2RlbDogKHN0cmluZyAmIHt9KSB8IENoYXRBUEkuQ2hhdE1vZGVsO1xuXG4gIC8qKlxuICAgKiBQYXJhbWV0ZXJzIGZvciBhdWRpbyBvdXRwdXQuIFJlcXVpcmVkIHdoZW4gYXVkaW8gb3V0cHV0IGlzIHJlcXVlc3RlZCB3aXRoXG4gICAqIGBtb2RhbGl0aWVzOiBbXCJhdWRpb1wiXWAuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYXVkaW8pLlxuICAgKi9cbiAgYXVkaW8/OiBDaGF0Q29tcGxldGlvbkF1ZGlvUGFyYW0gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgYmV0d2VlbiAtMi4wIGFuZCAyLjAuIFBvc2l0aXZlIHZhbHVlcyBwZW5hbGl6ZSBuZXcgdG9rZW5zIGJhc2VkIG9uIHRoZWlyXG4gICAqIGV4aXN0aW5nIGZyZXF1ZW5jeSBpbiB0aGUgdGV4dCBzbyBmYXIsIGRlY3JlYXNpbmcgdGhlIG1vZGVsJ3MgbGlrZWxpaG9vZCB0b1xuICAgKiByZXBlYXQgdGhlIHNhbWUgbGluZSB2ZXJiYXRpbS5cbiAgICovXG4gIGZyZXF1ZW5jeV9wZW5hbHR5PzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogRGVwcmVjYXRlZCBpbiBmYXZvciBvZiBgdG9vbF9jaG9pY2VgLlxuICAgKlxuICAgKiBDb250cm9scyB3aGljaCAoaWYgYW55KSBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgdGhlIG1vZGVsLlxuICAgKlxuICAgKiBgbm9uZWAgbWVhbnMgdGhlIG1vZGVsIHdpbGwgbm90IGNhbGwgYSBmdW5jdGlvbiBhbmQgaW5zdGVhZCBnZW5lcmF0ZXMgYSBtZXNzYWdlLlxuICAgKlxuICAgKiBgYXV0b2AgbWVhbnMgdGhlIG1vZGVsIGNhbiBwaWNrIGJldHdlZW4gZ2VuZXJhdGluZyBhIG1lc3NhZ2Ugb3IgY2FsbGluZyBhXG4gICAqIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciBmdW5jdGlvbiB2aWEgYHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifWAgZm9yY2VzIHRoZSBtb2RlbFxuICAgKiB0byBjYWxsIHRoYXQgZnVuY3Rpb24uXG4gICAqXG4gICAqIGBub25lYCBpcyB0aGUgZGVmYXVsdCB3aGVuIG5vIGZ1bmN0aW9ucyBhcmUgcHJlc2VudC4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IGlmXG4gICAqIGZ1bmN0aW9ucyBhcmUgcHJlc2VudC5cbiAgICovXG4gIGZ1bmN0aW9uX2NhbGw/OiAnbm9uZScgfCAnYXV0bycgfCBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uQ2FsbE9wdGlvbjtcblxuICAvKipcbiAgICogRGVwcmVjYXRlZCBpbiBmYXZvciBvZiBgdG9vbHNgLlxuICAgKlxuICAgKiBBIGxpc3Qgb2YgZnVuY3Rpb25zIHRoZSBtb2RlbCBtYXkgZ2VuZXJhdGUgSlNPTiBpbnB1dHMgZm9yLlxuICAgKi9cbiAgZnVuY3Rpb25zPzogQXJyYXk8Q2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMuRnVuY3Rpb24+O1xuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIGxpa2VsaWhvb2Qgb2Ygc3BlY2lmaWVkIHRva2VucyBhcHBlYXJpbmcgaW4gdGhlIGNvbXBsZXRpb24uXG4gICAqXG4gICAqIEFjY2VwdHMgYSBKU09OIG9iamVjdCB0aGF0IG1hcHMgdG9rZW5zIChzcGVjaWZpZWQgYnkgdGhlaXIgdG9rZW4gSUQgaW4gdGhlXG4gICAqIHRva2VuaXplcikgdG8gYW4gYXNzb2NpYXRlZCBiaWFzIHZhbHVlIGZyb20gLTEwMCB0byAxMDAuIE1hdGhlbWF0aWNhbGx5LCB0aGVcbiAgICogYmlhcyBpcyBhZGRlZCB0byB0aGUgbG9naXRzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgcHJpb3IgdG8gc2FtcGxpbmcuIFRoZSBleGFjdFxuICAgKiBlZmZlY3Qgd2lsbCB2YXJ5IHBlciBtb2RlbCwgYnV0IHZhbHVlcyBiZXR3ZWVuIC0xIGFuZCAxIHNob3VsZCBkZWNyZWFzZSBvclxuICAgKiBpbmNyZWFzZSBsaWtlbGlob29kIG9mIHNlbGVjdGlvbjsgdmFsdWVzIGxpa2UgLTEwMCBvciAxMDAgc2hvdWxkIHJlc3VsdCBpbiBhIGJhblxuICAgKiBvciBleGNsdXNpdmUgc2VsZWN0aW9uIG9mIHRoZSByZWxldmFudCB0b2tlbi5cbiAgICovXG4gIGxvZ2l0X2JpYXM/OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IHwgbnVsbDtcblxuICAvKipcbiAgICogV2hldGhlciB0byByZXR1cm4gbG9nIHByb2JhYmlsaXRpZXMgb2YgdGhlIG91dHB1dCB0b2tlbnMgb3Igbm90LiBJZiB0cnVlLFxuICAgKiByZXR1cm5zIHRoZSBsb2cgcHJvYmFiaWxpdGllcyBvZiBlYWNoIG91dHB1dCB0b2tlbiByZXR1cm5lZCBpbiB0aGUgYGNvbnRlbnRgIG9mXG4gICAqIGBtZXNzYWdlYC5cbiAgICovXG4gIGxvZ3Byb2JzPzogYm9vbGVhbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEFuIHVwcGVyIGJvdW5kIGZvciB0aGUgbnVtYmVyIG9mIHRva2VucyB0aGF0IGNhbiBiZSBnZW5lcmF0ZWQgZm9yIGEgY29tcGxldGlvbixcbiAgICogaW5jbHVkaW5nIHZpc2libGUgb3V0cHV0IHRva2VucyBhbmRcbiAgICogW3JlYXNvbmluZyB0b2tlbnNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9yZWFzb25pbmcpLlxuICAgKi9cbiAgbWF4X2NvbXBsZXRpb25fdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIFt0b2tlbnNdKC90b2tlbml6ZXIpIHRoYXQgY2FuIGJlIGdlbmVyYXRlZCBpbiB0aGUgY2hhdFxuICAgKiBjb21wbGV0aW9uLiBUaGlzIHZhbHVlIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2xcbiAgICogW2Nvc3RzXShodHRwczovL29wZW5haS5jb20vYXBpL3ByaWNpbmcvKSBmb3IgdGV4dCBnZW5lcmF0ZWQgdmlhIEFQSS5cbiAgICpcbiAgICogVGhpcyB2YWx1ZSBpcyBub3cgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBgbWF4X2NvbXBsZXRpb25fdG9rZW5zYCwgYW5kIGlzIG5vdFxuICAgKiBjb21wYXRpYmxlIHdpdGhcbiAgICogW28xIHNlcmllcyBtb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9yZWFzb25pbmcpLlxuICAgKi9cbiAgbWF4X3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIERldmVsb3Blci1kZWZpbmVkIHRhZ3MgYW5kIHZhbHVlcyB1c2VkIGZvciBmaWx0ZXJpbmcgY29tcGxldGlvbnMgaW4gdGhlXG4gICAqIFtkYXNoYm9hcmRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9jaGF0LWNvbXBsZXRpb25zKS5cbiAgICovXG4gIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE91dHB1dCB0eXBlcyB0aGF0IHlvdSB3b3VsZCBsaWtlIHRoZSBtb2RlbCB0byBnZW5lcmF0ZSBmb3IgdGhpcyByZXF1ZXN0LiBNb3N0XG4gICAqIG1vZGVscyBhcmUgY2FwYWJsZSBvZiBnZW5lcmF0aW5nIHRleHQsIHdoaWNoIGlzIHRoZSBkZWZhdWx0OlxuICAgKlxuICAgKiBgW1widGV4dFwiXWBcbiAgICpcbiAgICogVGhlIGBncHQtNG8tYXVkaW8tcHJldmlld2AgbW9kZWwgY2FuIGFsc28gYmUgdXNlZCB0b1xuICAgKiBbZ2VuZXJhdGUgYXVkaW9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9hdWRpbykuIFRvIHJlcXVlc3QgdGhhdFxuICAgKiB0aGlzIG1vZGVsIGdlbmVyYXRlIGJvdGggdGV4dCBhbmQgYXVkaW8gcmVzcG9uc2VzLCB5b3UgY2FuIHVzZTpcbiAgICpcbiAgICogYFtcInRleHRcIiwgXCJhdWRpb1wiXWBcbiAgICovXG4gIG1vZGFsaXRpZXM/OiBBcnJheTxDaGF0Q29tcGxldGlvbk1vZGFsaXR5PiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEhvdyBtYW55IGNoYXQgY29tcGxldGlvbiBjaG9pY2VzIHRvIGdlbmVyYXRlIGZvciBlYWNoIGlucHV0IG1lc3NhZ2UuIE5vdGUgdGhhdFxuICAgKiB5b3Ugd2lsbCBiZSBjaGFyZ2VkIGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgZ2VuZXJhdGVkIHRva2VucyBhY3Jvc3MgYWxsIG9mIHRoZVxuICAgKiBjaG9pY2VzLiBLZWVwIGBuYCBhcyBgMWAgdG8gbWluaW1pemUgY29zdHMuXG4gICAqL1xuICBuPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGVcbiAgICogW3BhcmFsbGVsIGZ1bmN0aW9uIGNhbGxpbmddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9mdW5jdGlvbi1jYWxsaW5nI2NvbmZpZ3VyaW5nLXBhcmFsbGVsLWZ1bmN0aW9uLWNhbGxpbmcpXG4gICAqIGR1cmluZyB0b29sIHVzZS5cbiAgICovXG4gIHBhcmFsbGVsX3Rvb2xfY2FsbHM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgcHJlZGljdGVkIG91dHB1dCBjb250ZW50LCBzdWNoIGFzIHRoZSBjb250ZW50IG9mIGEgdGV4dCBmaWxlIHRoYXQgaXNcbiAgICogYmVpbmcgcmVnZW5lcmF0ZWQuXG4gICAqL1xuICBwcmVkaWN0aW9uPzogQ2hhdENvbXBsZXRpb25QcmVkaWN0aW9uQ29udGVudCB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE51bWJlciBiZXR3ZWVuIC0yLjAgYW5kIDIuMC4gUG9zaXRpdmUgdmFsdWVzIHBlbmFsaXplIG5ldyB0b2tlbnMgYmFzZWQgb25cbiAgICogd2hldGhlciB0aGV5IGFwcGVhciBpbiB0aGUgdGV4dCBzbyBmYXIsIGluY3JlYXNpbmcgdGhlIG1vZGVsJ3MgbGlrZWxpaG9vZCB0b1xuICAgKiB0YWxrIGFib3V0IG5ldyB0b3BpY3MuXG4gICAqL1xuICBwcmVzZW5jZV9wZW5hbHR5PzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogKipvMSBtb2RlbHMgb25seSoqXG4gICAqXG4gICAqIENvbnN0cmFpbnMgZWZmb3J0IG9uIHJlYXNvbmluZyBmb3JcbiAgICogW3JlYXNvbmluZyBtb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9yZWFzb25pbmcpLiBDdXJyZW50bHlcbiAgICogc3VwcG9ydGVkIHZhbHVlcyBhcmUgYGxvd2AsIGBtZWRpdW1gLCBhbmQgYGhpZ2hgLiBSZWR1Y2luZyByZWFzb25pbmcgZWZmb3J0IGNhblxuICAgKiByZXN1bHQgaW4gZmFzdGVyIHJlc3BvbnNlcyBhbmQgZmV3ZXIgdG9rZW5zIHVzZWQgb24gcmVhc29uaW5nIGluIGEgcmVzcG9uc2UuXG4gICAqL1xuICByZWFzb25pbmdfZWZmb3J0PzogQ2hhdENvbXBsZXRpb25SZWFzb25pbmdFZmZvcnQ7XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBmb3JtYXQgdGhhdCB0aGUgbW9kZWwgbXVzdCBvdXRwdXQuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9zY2hlbWFcIiwgXCJqc29uX3NjaGVtYVwiOiB7Li4ufSB9YCBlbmFibGVzIFN0cnVjdHVyZWRcbiAgICogT3V0cHV0cyB3aGljaCBlbnN1cmVzIHRoZSBtb2RlbCB3aWxsIG1hdGNoIHlvdXIgc3VwcGxpZWQgSlNPTiBzY2hlbWEuIExlYXJuIG1vcmVcbiAgICogaW4gdGhlXG4gICAqIFtTdHJ1Y3R1cmVkIE91dHB1dHMgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zdHJ1Y3R1cmVkLW91dHB1dHMpLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGVuc3VyZXMgdGhlXG4gICAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICAgKlxuICAgKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gICAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAgICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAgICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAgICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICAgKiBtYXggY29udGV4dCBsZW5ndGguXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OlxuICAgIHwgU2hhcmVkLlJlc3BvbnNlRm9ybWF0VGV4dFxuICAgIHwgU2hhcmVkLlJlc3BvbnNlRm9ybWF0SlNPTk9iamVjdFxuICAgIHwgU2hhcmVkLlJlc3BvbnNlRm9ybWF0SlNPTlNjaGVtYTtcblxuICAvKipcbiAgICogVGhpcyBmZWF0dXJlIGlzIGluIEJldGEuIElmIHNwZWNpZmllZCwgb3VyIHN5c3RlbSB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0b1xuICAgKiBzYW1wbGUgZGV0ZXJtaW5pc3RpY2FsbHksIHN1Y2ggdGhhdCByZXBlYXRlZCByZXF1ZXN0cyB3aXRoIHRoZSBzYW1lIGBzZWVkYCBhbmRcbiAgICogcGFyYW1ldGVycyBzaG91bGQgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdC4gRGV0ZXJtaW5pc20gaXMgbm90IGd1YXJhbnRlZWQsIGFuZCB5b3VcbiAgICogc2hvdWxkIHJlZmVyIHRvIHRoZSBgc3lzdGVtX2ZpbmdlcnByaW50YCByZXNwb25zZSBwYXJhbWV0ZXIgdG8gbW9uaXRvciBjaGFuZ2VzXG4gICAqIGluIHRoZSBiYWNrZW5kLlxuICAgKi9cbiAgc2VlZD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgbGF0ZW5jeSB0aWVyIHRvIHVzZSBmb3IgcHJvY2Vzc2luZyB0aGUgcmVxdWVzdC4gVGhpcyBwYXJhbWV0ZXIgaXNcbiAgICogcmVsZXZhbnQgZm9yIGN1c3RvbWVycyBzdWJzY3JpYmVkIHRvIHRoZSBzY2FsZSB0aWVyIHNlcnZpY2U6XG4gICAqXG4gICAqIC0gSWYgc2V0IHRvICdhdXRvJywgYW5kIHRoZSBQcm9qZWN0IGlzIFNjYWxlIHRpZXIgZW5hYmxlZCwgdGhlIHN5c3RlbSB3aWxsXG4gICAqICAgdXRpbGl6ZSBzY2FsZSB0aWVyIGNyZWRpdHMgdW50aWwgdGhleSBhcmUgZXhoYXVzdGVkLlxuICAgKiAtIElmIHNldCB0byAnYXV0bycsIGFuZCB0aGUgUHJvamVjdCBpcyBub3QgU2NhbGUgdGllciBlbmFibGVkLCB0aGUgcmVxdWVzdCB3aWxsXG4gICAqICAgYmUgcHJvY2Vzc2VkIHVzaW5nIHRoZSBkZWZhdWx0IHNlcnZpY2UgdGllciB3aXRoIGEgbG93ZXIgdXB0aW1lIFNMQSBhbmQgbm9cbiAgICogICBsYXRlbmN5IGd1YXJlbnRlZS5cbiAgICogLSBJZiBzZXQgdG8gJ2RlZmF1bHQnLCB0aGUgcmVxdWVzdCB3aWxsIGJlIHByb2Nlc3NlZCB1c2luZyB0aGUgZGVmYXVsdCBzZXJ2aWNlXG4gICAqICAgdGllciB3aXRoIGEgbG93ZXIgdXB0aW1lIFNMQSBhbmQgbm8gbGF0ZW5jeSBndWFyZW50ZWUuXG4gICAqIC0gV2hlbiBub3Qgc2V0LCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyAnYXV0bycuXG4gICAqXG4gICAqIFdoZW4gdGhpcyBwYXJhbWV0ZXIgaXMgc2V0LCB0aGUgcmVzcG9uc2UgYm9keSB3aWxsIGluY2x1ZGUgdGhlIGBzZXJ2aWNlX3RpZXJgXG4gICAqIHV0aWxpemVkLlxuICAgKi9cbiAgc2VydmljZV90aWVyPzogJ2F1dG8nIHwgJ2RlZmF1bHQnIHwgbnVsbDtcblxuICAvKipcbiAgICogVXAgdG8gNCBzZXF1ZW5jZXMgd2hlcmUgdGhlIEFQSSB3aWxsIHN0b3AgZ2VuZXJhdGluZyBmdXJ0aGVyIHRva2Vucy5cbiAgICovXG4gIHN0b3A/OiBzdHJpbmcgfCBudWxsIHwgQXJyYXk8c3RyaW5nPjtcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdG8gc3RvcmUgdGhlIG91dHB1dCBvZiB0aGlzIGNoYXQgY29tcGxldGlvbiByZXF1ZXN0IGZvciB1c2UgaW5cbiAgICogb3VyIFttb2RlbCBkaXN0aWxsYXRpb25dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9kaXN0aWxsYXRpb24pXG4gICAqIG9yIFtldmFsc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2V2YWxzKSBwcm9kdWN0cy5cbiAgICovXG4gIHN0b3JlPzogYm9vbGVhbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIElmIHNldCwgcGFydGlhbCBtZXNzYWdlIGRlbHRhcyB3aWxsIGJlIHNlbnQsIGxpa2UgaW4gQ2hhdEdQVC4gVG9rZW5zIHdpbGwgYmVcbiAgICogc2VudCBhcyBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLCB3aXRoIHRoZSBzdHJlYW0gdGVybWluYXRlZCBieSBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2Nvb2tib29rLm9wZW5haS5jb20vZXhhbXBsZXMvaG93X3RvX3N0cmVhbV9jb21wbGV0aW9ucykuXG4gICAqL1xuICBzdHJlYW0/OiBib29sZWFuIHwgbnVsbDtcblxuICAvKipcbiAgICogT3B0aW9ucyBmb3Igc3RyZWFtaW5nIHJlc3BvbnNlLiBPbmx5IHNldCB0aGlzIHdoZW4geW91IHNldCBgc3RyZWFtOiB0cnVlYC5cbiAgICovXG4gIHN0cmVhbV9vcHRpb25zPzogQ2hhdENvbXBsZXRpb25TdHJlYW1PcHRpb25zIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciBgdG9wX3BgIGJ1dFxuICAgKiBub3QgYm90aC5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgdG9vbCBpcyBjYWxsZWQgYnkgdGhlIG1vZGVsLiBgbm9uZWAgbWVhbnMgdGhlIG1vZGVsIHdpbGxcbiAgICogbm90IGNhbGwgYW55IHRvb2wgYW5kIGluc3RlYWQgZ2VuZXJhdGVzIGEgbWVzc2FnZS4gYGF1dG9gIG1lYW5zIHRoZSBtb2RlbCBjYW5cbiAgICogcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yIGNhbGxpbmcgb25lIG9yIG1vcmUgdG9vbHMuIGByZXF1aXJlZGAgbWVhbnNcbiAgICogdGhlIG1vZGVsIG11c3QgY2FsbCBvbmUgb3IgbW9yZSB0b29scy4gU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgdG9vbCB2aWFcbiAgICogYHtcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifX1gIGZvcmNlcyB0aGUgbW9kZWwgdG9cbiAgICogY2FsbCB0aGF0IHRvb2wuXG4gICAqXG4gICAqIGBub25lYCBpcyB0aGUgZGVmYXVsdCB3aGVuIG5vIHRvb2xzIGFyZSBwcmVzZW50LiBgYXV0b2AgaXMgdGhlIGRlZmF1bHQgaWYgdG9vbHNcbiAgICogYXJlIHByZXNlbnQuXG4gICAqL1xuICB0b29sX2Nob2ljZT86IENoYXRDb21wbGV0aW9uVG9vbENob2ljZU9wdGlvbjtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIHRvb2xzIHRoZSBtb2RlbCBtYXkgY2FsbC4gQ3VycmVudGx5LCBvbmx5IGZ1bmN0aW9ucyBhcmUgc3VwcG9ydGVkIGFzIGFcbiAgICogdG9vbC4gVXNlIHRoaXMgdG8gcHJvdmlkZSBhIGxpc3Qgb2YgZnVuY3Rpb25zIHRoZSBtb2RlbCBtYXkgZ2VuZXJhdGUgSlNPTiBpbnB1dHNcbiAgICogZm9yLiBBIG1heCBvZiAxMjggZnVuY3Rpb25zIGFyZSBzdXBwb3J0ZWQuXG4gICAqL1xuICB0b29scz86IEFycmF5PENoYXRDb21wbGV0aW9uVG9vbD47XG5cbiAgLyoqXG4gICAqIEFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCAyMCBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgbW9zdCBsaWtlbHkgdG9rZW5zIHRvXG4gICAqIHJldHVybiBhdCBlYWNoIHRva2VuIHBvc2l0aW9uLCBlYWNoIHdpdGggYW4gYXNzb2NpYXRlZCBsb2cgcHJvYmFiaWxpdHkuXG4gICAqIGBsb2dwcm9ic2AgbXVzdCBiZSBzZXQgdG8gYHRydWVgIGlmIHRoaXMgcGFyYW1ldGVyIGlzIHVzZWQuXG4gICAqL1xuICB0b3BfbG9ncHJvYnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciBgdGVtcGVyYXR1cmVgIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRvcF9wPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciByZXByZXNlbnRpbmcgeW91ciBlbmQtdXNlciwgd2hpY2ggY2FuIGhlbHAgT3BlbkFJIHRvIG1vbml0b3JcbiAgICogYW5kIGRldGVjdCBhYnVzZS5cbiAgICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zYWZldHktYmVzdC1wcmFjdGljZXMjZW5kLXVzZXItaWRzKS5cbiAgICovXG4gIHVzZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQuIE11c3QgYmUgYS16LCBBLVosIDAtOSwgb3IgY29udGFpblxuICAgICAqIHVuZGVyc2NvcmVzIGFuZCBkYXNoZXMsIHdpdGggYSBtYXhpbXVtIGxlbmd0aCBvZiA2NC5cbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBBIGRlc2NyaXB0aW9uIG9mIHdoYXQgdGhlIGZ1bmN0aW9uIGRvZXMsIHVzZWQgYnkgdGhlIG1vZGVsIHRvIGNob29zZSB3aGVuIGFuZFxuICAgICAqIGhvdyB0byBjYWxsIHRoZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBwYXJhbWV0ZXJzIHRoZSBmdW5jdGlvbnMgYWNjZXB0cywgZGVzY3JpYmVkIGFzIGEgSlNPTiBTY2hlbWEgb2JqZWN0LiBTZWUgdGhlXG4gICAgICogW2d1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZnVuY3Rpb24tY2FsbGluZykgZm9yIGV4YW1wbGVzLFxuICAgICAqIGFuZCB0aGVcbiAgICAgKiBbSlNPTiBTY2hlbWEgcmVmZXJlbmNlXShodHRwczovL2pzb24tc2NoZW1hLm9yZy91bmRlcnN0YW5kaW5nLWpzb24tc2NoZW1hLykgZm9yXG4gICAgICogZG9jdW1lbnRhdGlvbiBhYm91dCB0aGUgZm9ybWF0LlxuICAgICAqXG4gICAgICogT21pdHRpbmcgYHBhcmFtZXRlcnNgIGRlZmluZXMgYSBmdW5jdGlvbiB3aXRoIGFuIGVtcHR5IHBhcmFtZXRlciBsaXN0LlxuICAgICAqL1xuICAgIHBhcmFtZXRlcnM/OiBTaGFyZWQuRnVuY3Rpb25QYXJhbWV0ZXJzO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgPVxuICAgIENoYXRDb21wbGV0aW9uc0FQSS5DaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZztcbiAgZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSBDaGF0Q29tcGxldGlvbnNBUEkuQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmc7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIGluc3RlYWRcbiAqL1xuZXhwb3J0IHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyA9IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIElmIHNldCwgcGFydGlhbCBtZXNzYWdlIGRlbHRhcyB3aWxsIGJlIHNlbnQsIGxpa2UgaW4gQ2hhdEdQVC4gVG9rZW5zIHdpbGwgYmVcbiAgICogc2VudCBhcyBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLCB3aXRoIHRoZSBzdHJlYW0gdGVybWluYXRlZCBieSBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2Nvb2tib29rLm9wZW5haS5jb20vZXhhbXBsZXMvaG93X3RvX3N0cmVhbV9jb21wbGV0aW9ucykuXG4gICAqL1xuICBzdHJlYW0/OiBmYWxzZSB8IG51bGw7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGluc3RlYWRcbiAqL1xuZXhwb3J0IHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyA9IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIElmIHNldCwgcGFydGlhbCBtZXNzYWdlIGRlbHRhcyB3aWxsIGJlIHNlbnQsIGxpa2UgaW4gQ2hhdEdQVC4gVG9rZW5zIHdpbGwgYmVcbiAgICogc2VudCBhcyBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLCB3aXRoIHRoZSBzdHJlYW0gdGVybWluYXRlZCBieSBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2Nvb2tib29rLm9wZW5haS5jb20vZXhhbXBsZXMvaG93X3RvX3N0cmVhbV9jb21wbGV0aW9ucykuXG4gICAqL1xuICBzdHJlYW06IHRydWU7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGluc3RlYWRcbiAqL1xuZXhwb3J0IHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyA9IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgQ29tcGxldGlvbnMge1xuICBleHBvcnQge1xuICAgIHR5cGUgQ2hhdENvbXBsZXRpb24gYXMgQ2hhdENvbXBsZXRpb24sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQXVkaW8gYXMgQ2hhdENvbXBsZXRpb25BdWRpbyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQXVkaW9QYXJhbSBhcyBDaGF0Q29tcGxldGlvbkF1ZGlvUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNodW5rIGFzIENoYXRDb21wbGV0aW9uQ2h1bmssXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0IGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnQsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2UgYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydEltYWdlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydElucHV0QXVkaW8gYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydElucHV0QXVkaW8sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0UmVmdXNhbCBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0UmVmdXNhbCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0IGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25EZXZlbG9wZXJNZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25EZXZlbG9wZXJNZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uQ2FsbE9wdGlvbiBhcyBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uQ2FsbE9wdGlvbixcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25GdW5jdGlvbk1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZSBhcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2UsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsIGFzIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Nb2RhbGl0eSBhcyBDaGF0Q29tcGxldGlvbk1vZGFsaXR5LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25OYW1lZFRvb2xDaG9pY2UgYXMgQ2hhdENvbXBsZXRpb25OYW1lZFRvb2xDaG9pY2UsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblByZWRpY3Rpb25Db250ZW50IGFzIENoYXRDb21wbGV0aW9uUHJlZGljdGlvbkNvbnRlbnQsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblJlYXNvbmluZ0VmZm9ydCBhcyBDaGF0Q29tcGxldGlvblJlYXNvbmluZ0VmZm9ydCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uUm9sZSBhcyBDaGF0Q29tcGxldGlvblJvbGUsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblN0cmVhbU9wdGlvbnMgYXMgQ2hhdENvbXBsZXRpb25TdHJlYW1PcHRpb25zLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25TeXN0ZW1NZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25TeXN0ZW1NZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYiBhcyBDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYixcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVG9vbCBhcyBDaGF0Q29tcGxldGlvblRvb2wsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblRvb2xDaG9pY2VPcHRpb24gYXMgQ2hhdENvbXBsZXRpb25Ub29sQ2hvaWNlT3B0aW9uLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVXNlck1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvblVzZXJNZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDcmVhdGVDaGF0Q29tcGxldGlvblJlcXVlc3RNZXNzYWdlIGFzIENyZWF0ZUNoYXRDb21wbGV0aW9uUmVxdWVzdE1lc3NhZ2UsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyBhcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXMgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGFzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBhcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgYXMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gICAgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGFzIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBDb21wbGV0aW9uc0FQSSBmcm9tICcuL2NvbXBsZXRpb25zJztcbmltcG9ydCB7XG4gIENoYXRDb21wbGV0aW9uLFxuICBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25BdWRpbyxcbiAgQ2hhdENvbXBsZXRpb25BdWRpb1BhcmFtLFxuICBDaGF0Q29tcGxldGlvbkNodW5rLFxuICBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0LFxuICBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2UsXG4gIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbnB1dEF1ZGlvLFxuICBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0UmVmdXNhbCxcbiAgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQsXG4gIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gIENoYXRDb21wbGV0aW9uRGV2ZWxvcGVyTWVzc2FnZVBhcmFtLFxuICBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uQ2FsbE9wdGlvbixcbiAgQ2hhdENvbXBsZXRpb25GdW5jdGlvbk1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25NZXNzYWdlLFxuICBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwsXG4gIENoYXRDb21wbGV0aW9uTW9kYWxpdHksXG4gIENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlLFxuICBDaGF0Q29tcGxldGlvblByZWRpY3Rpb25Db250ZW50LFxuICBDaGF0Q29tcGxldGlvblJlYXNvbmluZ0VmZm9ydCxcbiAgQ2hhdENvbXBsZXRpb25Sb2xlLFxuICBDaGF0Q29tcGxldGlvblN0cmVhbU9wdGlvbnMsXG4gIENoYXRDb21wbGV0aW9uU3lzdGVtTWVzc2FnZVBhcmFtLFxuICBDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYixcbiAgQ2hhdENvbXBsZXRpb25Ub29sLFxuICBDaGF0Q29tcGxldGlvblRvb2xDaG9pY2VPcHRpb24sXG4gIENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25Vc2VyTWVzc2FnZVBhcmFtLFxuICBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICBDb21wbGV0aW9ucyxcbiAgQ3JlYXRlQ2hhdENvbXBsZXRpb25SZXF1ZXN0TWVzc2FnZSxcbn0gZnJvbSAnLi9jb21wbGV0aW9ucyc7XG5cbmV4cG9ydCBjbGFzcyBDaGF0IGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICBjb21wbGV0aW9uczogQ29tcGxldGlvbnNBUEkuQ29tcGxldGlvbnMgPSBuZXcgQ29tcGxldGlvbnNBUEkuQ29tcGxldGlvbnModGhpcy5fY2xpZW50KTtcbn1cblxuZXhwb3J0IHR5cGUgQ2hhdE1vZGVsID1cbiAgfCAnbzEnXG4gIHwgJ28xLTIwMjQtMTItMTcnXG4gIHwgJ28xLXByZXZpZXcnXG4gIHwgJ28xLXByZXZpZXctMjAyNC0wOS0xMidcbiAgfCAnbzEtbWluaSdcbiAgfCAnbzEtbWluaS0yMDI0LTA5LTEyJ1xuICB8ICdncHQtNG8nXG4gIHwgJ2dwdC00by0yMDI0LTExLTIwJ1xuICB8ICdncHQtNG8tMjAyNC0wOC0wNidcbiAgfCAnZ3B0LTRvLTIwMjQtMDUtMTMnXG4gIHwgJ2dwdC00by1hdWRpby1wcmV2aWV3J1xuICB8ICdncHQtNG8tYXVkaW8tcHJldmlldy0yMDI0LTEwLTAxJ1xuICB8ICdncHQtNG8tYXVkaW8tcHJldmlldy0yMDI0LTEyLTE3J1xuICB8ICdncHQtNG8tbWluaS1hdWRpby1wcmV2aWV3J1xuICB8ICdncHQtNG8tbWluaS1hdWRpby1wcmV2aWV3LTIwMjQtMTItMTcnXG4gIHwgJ2NoYXRncHQtNG8tbGF0ZXN0J1xuICB8ICdncHQtNG8tbWluaSdcbiAgfCAnZ3B0LTRvLW1pbmktMjAyNC0wNy0xOCdcbiAgfCAnZ3B0LTQtdHVyYm8nXG4gIHwgJ2dwdC00LXR1cmJvLTIwMjQtMDQtMDknXG4gIHwgJ2dwdC00LTAxMjUtcHJldmlldydcbiAgfCAnZ3B0LTQtdHVyYm8tcHJldmlldydcbiAgfCAnZ3B0LTQtMTEwNi1wcmV2aWV3J1xuICB8ICdncHQtNC12aXNpb24tcHJldmlldydcbiAgfCAnZ3B0LTQnXG4gIHwgJ2dwdC00LTAzMTQnXG4gIHwgJ2dwdC00LTA2MTMnXG4gIHwgJ2dwdC00LTMyaydcbiAgfCAnZ3B0LTQtMzJrLTAzMTQnXG4gIHwgJ2dwdC00LTMyay0wNjEzJ1xuICB8ICdncHQtMy41LXR1cmJvJ1xuICB8ICdncHQtMy41LXR1cmJvLTE2aydcbiAgfCAnZ3B0LTMuNS10dXJiby0wMzAxJ1xuICB8ICdncHQtMy41LXR1cmJvLTA2MTMnXG4gIHwgJ2dwdC0zLjUtdHVyYm8tMTEwNidcbiAgfCAnZ3B0LTMuNS10dXJiby0wMTI1J1xuICB8ICdncHQtMy41LXR1cmJvLTE2ay0wNjEzJztcblxuQ2hhdC5Db21wbGV0aW9ucyA9IENvbXBsZXRpb25zO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgQ2hhdCB7XG4gIGV4cG9ydCB7IHR5cGUgQ2hhdE1vZGVsIGFzIENoYXRNb2RlbCB9O1xuXG4gIGV4cG9ydCB7XG4gICAgQ29tcGxldGlvbnMgYXMgQ29tcGxldGlvbnMsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbiBhcyBDaGF0Q29tcGxldGlvbixcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25BdWRpbyBhcyBDaGF0Q29tcGxldGlvbkF1ZGlvLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25BdWRpb1BhcmFtIGFzIENoYXRDb21wbGV0aW9uQXVkaW9QYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ2h1bmsgYXMgQ2hhdENvbXBsZXRpb25DaHVuayxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnQgYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbWFnZSBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2UsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW5wdXRBdWRpbyBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW5wdXRBdWRpbyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRSZWZ1c2FsIGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRSZWZ1c2FsLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQgYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkRldmVsb3Blck1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvbkRldmVsb3Blck1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uRnVuY3Rpb25DYWxsT3B0aW9uIGFzIENoYXRDb21wbGV0aW9uRnVuY3Rpb25DYWxsT3B0aW9uLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25GdW5jdGlvbk1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlIGFzIENoYXRDb21wbGV0aW9uTWVzc2FnZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwgYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk1vZGFsaXR5IGFzIENoYXRDb21wbGV0aW9uTW9kYWxpdHksXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk5hbWVkVG9vbENob2ljZSBhcyBDaGF0Q29tcGxldGlvbk5hbWVkVG9vbENob2ljZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uUHJlZGljdGlvbkNvbnRlbnQgYXMgQ2hhdENvbXBsZXRpb25QcmVkaWN0aW9uQ29udGVudCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uUmVhc29uaW5nRWZmb3J0IGFzIENoYXRDb21wbGV0aW9uUmVhc29uaW5nRWZmb3J0LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Sb2xlIGFzIENoYXRDb21wbGV0aW9uUm9sZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uU3RyZWFtT3B0aW9ucyBhcyBDaGF0Q29tcGxldGlvblN0cmVhbU9wdGlvbnMsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblN5c3RlbU1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvblN5c3RlbU1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iIGFzIENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sIGFzIENoYXRDb21wbGV0aW9uVG9vbCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVG9vbENob2ljZU9wdGlvbiBhcyBDaGF0Q29tcGxldGlvblRvb2xDaG9pY2VPcHRpb24sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblRvb2xNZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25Ub29sTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Vc2VyTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uVXNlck1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENyZWF0ZUNoYXRDb21wbGV0aW9uUmVxdWVzdE1lc3NhZ2UgYXMgQ3JlYXRlQ2hhdENvbXBsZXRpb25SZXF1ZXN0TWVzc2FnZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIGFzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyBhcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgYXMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGFzIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBhcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vY29yZSc7XG5pbXBvcnQgeyB0eXBlIFJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vX3NoaW1zL2luZGV4JztcblxuZXhwb3J0IGNsYXNzIFNwZWVjaCBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhdWRpbyBmcm9tIHRoZSBpbnB1dCB0ZXh0LlxuICAgKi9cbiAgY3JlYXRlKGJvZHk6IFNwZWVjaENyZWF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8UmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9hdWRpby9zcGVlY2gnLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgQWNjZXB0OiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgX19iaW5hcnlSZXNwb25zZTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBTcGVlY2hNb2RlbCA9ICd0dHMtMScgfCAndHRzLTEtaGQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNwZWVjaENyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgdGV4dCB0byBnZW5lcmF0ZSBhdWRpbyBmb3IuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyA0MDk2IGNoYXJhY3RlcnMuXG4gICAqL1xuICBpbnB1dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPbmUgb2YgdGhlIGF2YWlsYWJsZSBbVFRTIG1vZGVsc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI3R0cyk6XG4gICAqIGB0dHMtMWAgb3IgYHR0cy0xLWhkYFxuICAgKi9cbiAgbW9kZWw6IChzdHJpbmcgJiB7fSkgfCBTcGVlY2hNb2RlbDtcblxuICAvKipcbiAgICogVGhlIHZvaWNlIHRvIHVzZSB3aGVuIGdlbmVyYXRpbmcgdGhlIGF1ZGlvLiBTdXBwb3J0ZWQgdm9pY2VzIGFyZSBgYWxsb3lgLFxuICAgKiBgZWNob2AsIGBmYWJsZWAsIGBvbnl4YCwgYG5vdmFgLCBhbmQgYHNoaW1tZXJgLiBQcmV2aWV3cyBvZiB0aGUgdm9pY2VzIGFyZVxuICAgKiBhdmFpbGFibGUgaW4gdGhlXG4gICAqIFtUZXh0IHRvIHNwZWVjaCBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3RleHQtdG8tc3BlZWNoI3ZvaWNlLW9wdGlvbnMpLlxuICAgKi9cbiAgdm9pY2U6ICdhbGxveScgfCAnZWNobycgfCAnZmFibGUnIHwgJ29ueXgnIHwgJ25vdmEnIHwgJ3NoaW1tZXInO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IHRvIGF1ZGlvIGluLiBTdXBwb3J0ZWQgZm9ybWF0cyBhcmUgYG1wM2AsIGBvcHVzYCwgYGFhY2AsIGBmbGFjYCxcbiAgICogYHdhdmAsIGFuZCBgcGNtYC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86ICdtcDMnIHwgJ29wdXMnIHwgJ2FhYycgfCAnZmxhYycgfCAnd2F2JyB8ICdwY20nO1xuXG4gIC8qKlxuICAgKiBUaGUgc3BlZWQgb2YgdGhlIGdlbmVyYXRlZCBhdWRpby4gU2VsZWN0IGEgdmFsdWUgZnJvbSBgMC4yNWAgdG8gYDQuMGAuIGAxLjBgIGlzXG4gICAqIHRoZSBkZWZhdWx0LlxuICAgKi9cbiAgc3BlZWQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBTcGVlY2gge1xuICBleHBvcnQgeyB0eXBlIFNwZWVjaE1vZGVsIGFzIFNwZWVjaE1vZGVsLCB0eXBlIFNwZWVjaENyZWF0ZVBhcmFtcyBhcyBTcGVlY2hDcmVhdGVQYXJhbXMgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBBdWRpb0FQSSBmcm9tICcuL2F1ZGlvJztcblxuZXhwb3J0IGNsYXNzIFRyYW5zY3JpcHRpb25zIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogVHJhbnNjcmliZXMgYXVkaW8gaW50byB0aGUgaW5wdXQgbGFuZ3VhZ2UuXG4gICAqL1xuICBjcmVhdGUoXG4gICAgYm9keTogVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtczwnanNvbicgfCB1bmRlZmluZWQ+LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VHJhbnNjcmlwdGlvbj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zPCd2ZXJib3NlX2pzb24nPixcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFRyYW5zY3JpcHRpb25WZXJib3NlPjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXM8J3NydCcgfCAndnR0JyB8ICd0ZXh0Jz4sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxzdHJpbmc+O1xuICBjcmVhdGUoYm9keTogVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8VHJhbnNjcmlwdGlvbj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VHJhbnNjcmlwdGlvbkNyZWF0ZVJlc3BvbnNlIHwgc3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvYXVkaW8vdHJhbnNjcmlwdGlvbnMnLCBDb3JlLm11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyh7IGJvZHksIC4uLm9wdGlvbnMgfSkpO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRyYW5zY3JpcHRpb24gcmVzcG9uc2UgcmV0dXJuZWQgYnkgbW9kZWwsIGJhc2VkIG9uIHRoZSBwcm92aWRlZFxuICogaW5wdXQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNjcmlwdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgdHJhbnNjcmliZWQgdGV4dC5cbiAgICovXG4gIHRleHQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2NyaXB0aW9uU2VnbWVudCB7XG4gIC8qKlxuICAgKiBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgc2VnbWVudC5cbiAgICovXG4gIGlkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEF2ZXJhZ2UgbG9ncHJvYiBvZiB0aGUgc2VnbWVudC4gSWYgdGhlIHZhbHVlIGlzIGxvd2VyIHRoYW4gLTEsIGNvbnNpZGVyIHRoZVxuICAgKiBsb2dwcm9icyBmYWlsZWQuXG4gICAqL1xuICBhdmdfbG9ncHJvYjogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBDb21wcmVzc2lvbiByYXRpbyBvZiB0aGUgc2VnbWVudC4gSWYgdGhlIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiAyLjQsIGNvbnNpZGVyIHRoZVxuICAgKiBjb21wcmVzc2lvbiBmYWlsZWQuXG4gICAqL1xuICBjb21wcmVzc2lvbl9yYXRpbzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBFbmQgdGltZSBvZiB0aGUgc2VnbWVudCBpbiBzZWNvbmRzLlxuICAgKi9cbiAgZW5kOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFByb2JhYmlsaXR5IG9mIG5vIHNwZWVjaCBpbiB0aGUgc2VnbWVudC4gSWYgdGhlIHZhbHVlIGlzIGhpZ2hlciB0aGFuIDEuMCBhbmQgdGhlXG4gICAqIGBhdmdfbG9ncHJvYmAgaXMgYmVsb3cgLTEsIGNvbnNpZGVyIHRoaXMgc2VnbWVudCBzaWxlbnQuXG4gICAqL1xuICBub19zcGVlY2hfcHJvYjogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBTZWVrIG9mZnNldCBvZiB0aGUgc2VnbWVudC5cbiAgICovXG4gIHNlZWs6IG51bWJlcjtcblxuICAvKipcbiAgICogU3RhcnQgdGltZSBvZiB0aGUgc2VnbWVudCBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc3RhcnQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGVtcGVyYXR1cmUgcGFyYW1ldGVyIHVzZWQgZm9yIGdlbmVyYXRpbmcgdGhlIHNlZ21lbnQuXG4gICAqL1xuICB0ZW1wZXJhdHVyZTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUZXh0IGNvbnRlbnQgb2YgdGhlIHNlZ21lbnQuXG4gICAqL1xuICB0ZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFycmF5IG9mIHRva2VuIElEcyBmb3IgdGhlIHRleHQgY29udGVudC5cbiAgICovXG4gIHRva2VuczogQXJyYXk8bnVtYmVyPjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdmVyYm9zZSBqc29uIHRyYW5zY3JpcHRpb24gcmVzcG9uc2UgcmV0dXJuZWQgYnkgbW9kZWwsIGJhc2VkIG9uIHRoZVxuICogcHJvdmlkZWQgaW5wdXQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNjcmlwdGlvblZlcmJvc2Uge1xuICAvKipcbiAgICogVGhlIGR1cmF0aW9uIG9mIHRoZSBpbnB1dCBhdWRpby5cbiAgICovXG4gIGR1cmF0aW9uOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBsYW5ndWFnZSBvZiB0aGUgaW5wdXQgYXVkaW8uXG4gICAqL1xuICBsYW5ndWFnZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNjcmliZWQgdGV4dC5cbiAgICovXG4gIHRleHQ6IHN0cmluZztcblxuICAvKipcbiAgICogU2VnbWVudHMgb2YgdGhlIHRyYW5zY3JpYmVkIHRleHQgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgZGV0YWlscy5cbiAgICovXG4gIHNlZ21lbnRzPzogQXJyYXk8VHJhbnNjcmlwdGlvblNlZ21lbnQ+O1xuXG4gIC8qKlxuICAgKiBFeHRyYWN0ZWQgd29yZHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgdGltZXN0YW1wcy5cbiAgICovXG4gIHdvcmRzPzogQXJyYXk8VHJhbnNjcmlwdGlvbldvcmQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zY3JpcHRpb25Xb3JkIHtcbiAgLyoqXG4gICAqIEVuZCB0aW1lIG9mIHRoZSB3b3JkIGluIHNlY29uZHMuXG4gICAqL1xuICBlbmQ6IG51bWJlcjtcblxuICAvKipcbiAgICogU3RhcnQgdGltZSBvZiB0aGUgd29yZCBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc3RhcnQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHRleHQgY29udGVudCBvZiB0aGUgd29yZC5cbiAgICovXG4gIHdvcmQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNjcmlwdGlvbiByZXNwb25zZSByZXR1cm5lZCBieSBtb2RlbCwgYmFzZWQgb24gdGhlIHByb3ZpZGVkXG4gKiBpbnB1dC5cbiAqL1xuZXhwb3J0IHR5cGUgVHJhbnNjcmlwdGlvbkNyZWF0ZVJlc3BvbnNlID0gVHJhbnNjcmlwdGlvbiB8IFRyYW5zY3JpcHRpb25WZXJib3NlO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXM8XG4gIFJlc3BvbnNlRm9ybWF0IGV4dGVuZHMgQXVkaW9BUEkuQXVkaW9SZXNwb25zZUZvcm1hdCB8IHVuZGVmaW5lZCA9IEF1ZGlvQVBJLkF1ZGlvUmVzcG9uc2VGb3JtYXQgfCB1bmRlZmluZWQsXG4+IHtcbiAgLyoqXG4gICAqIFRoZSBhdWRpbyBmaWxlIG9iamVjdCAobm90IGZpbGUgbmFtZSkgdG8gdHJhbnNjcmliZSwgaW4gb25lIG9mIHRoZXNlIGZvcm1hdHM6XG4gICAqIGZsYWMsIG1wMywgbXA0LCBtcGVnLCBtcGdhLCBtNGEsIG9nZywgd2F2LCBvciB3ZWJtLlxuICAgKi9cbiAgZmlsZTogQ29yZS5VcGxvYWRhYmxlO1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBPbmx5IGB3aGlzcGVyLTFgICh3aGljaCBpcyBwb3dlcmVkIGJ5IG91ciBvcGVuIHNvdXJjZVxuICAgKiBXaGlzcGVyIFYyIG1vZGVsKSBpcyBjdXJyZW50bHkgYXZhaWxhYmxlLlxuICAgKi9cbiAgbW9kZWw6IChzdHJpbmcgJiB7fSkgfCBBdWRpb0FQSS5BdWRpb01vZGVsO1xuXG4gIC8qKlxuICAgKiBUaGUgbGFuZ3VhZ2Ugb2YgdGhlIGlucHV0IGF1ZGlvLiBTdXBwbHlpbmcgdGhlIGlucHV0IGxhbmd1YWdlIGluXG4gICAqIFtJU08tNjM5LTFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfSVNPXzYzOS0xX2NvZGVzKSBmb3JtYXQgd2lsbFxuICAgKiBpbXByb3ZlIGFjY3VyYWN5IGFuZCBsYXRlbmN5LlxuICAgKi9cbiAgbGFuZ3VhZ2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIHRleHQgdG8gZ3VpZGUgdGhlIG1vZGVsJ3Mgc3R5bGUgb3IgY29udGludWUgYSBwcmV2aW91cyBhdWRpb1xuICAgKiBzZWdtZW50LiBUaGVcbiAgICogW3Byb21wdF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3NwZWVjaC10by10ZXh0I3Byb21wdGluZylcbiAgICogc2hvdWxkIG1hdGNoIHRoZSBhdWRpbyBsYW5ndWFnZS5cbiAgICovXG4gIHByb21wdD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0LCBpbiBvbmUgb2YgdGhlc2Ugb3B0aW9uczogYGpzb25gLCBgdGV4dGAsIGBzcnRgLFxuICAgKiBgdmVyYm9zZV9qc29uYCwgb3IgYHZ0dGAuXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBSZXNwb25zZUZvcm1hdDtcblxuICAvKipcbiAgICogVGhlIHNhbXBsaW5nIHRlbXBlcmF0dXJlLCBiZXR3ZWVuIDAgYW5kIDEuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbCBtYWtlIHRoZVxuICAgKiBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZSBmb2N1c2VkIGFuZFxuICAgKiBkZXRlcm1pbmlzdGljLiBJZiBzZXQgdG8gMCwgdGhlIG1vZGVsIHdpbGwgdXNlXG4gICAqIFtsb2cgcHJvYmFiaWxpdHldKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xvZ19wcm9iYWJpbGl0eSkgdG9cbiAgICogYXV0b21hdGljYWxseSBpbmNyZWFzZSB0aGUgdGVtcGVyYXR1cmUgdW50aWwgY2VydGFpbiB0aHJlc2hvbGRzIGFyZSBoaXQuXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHRpbWVzdGFtcCBncmFudWxhcml0aWVzIHRvIHBvcHVsYXRlIGZvciB0aGlzIHRyYW5zY3JpcHRpb24uXG4gICAqIGByZXNwb25zZV9mb3JtYXRgIG11c3QgYmUgc2V0IGB2ZXJib3NlX2pzb25gIHRvIHVzZSB0aW1lc3RhbXAgZ3JhbnVsYXJpdGllcy5cbiAgICogRWl0aGVyIG9yIGJvdGggb2YgdGhlc2Ugb3B0aW9ucyBhcmUgc3VwcG9ydGVkOiBgd29yZGAsIG9yIGBzZWdtZW50YC4gTm90ZTogVGhlcmVcbiAgICogaXMgbm8gYWRkaXRpb25hbCBsYXRlbmN5IGZvciBzZWdtZW50IHRpbWVzdGFtcHMsIGJ1dCBnZW5lcmF0aW5nIHdvcmQgdGltZXN0YW1wc1xuICAgKiBpbmN1cnMgYWRkaXRpb25hbCBsYXRlbmN5LlxuICAgKi9cbiAgdGltZXN0YW1wX2dyYW51bGFyaXRpZXM/OiBBcnJheTwnd29yZCcgfCAnc2VnbWVudCc+O1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVHJhbnNjcmlwdGlvbnMge1xuICBleHBvcnQge1xuICAgIHR5cGUgVHJhbnNjcmlwdGlvbiBhcyBUcmFuc2NyaXB0aW9uLFxuICAgIHR5cGUgVHJhbnNjcmlwdGlvblNlZ21lbnQgYXMgVHJhbnNjcmlwdGlvblNlZ21lbnQsXG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uVmVyYm9zZSBhcyBUcmFuc2NyaXB0aW9uVmVyYm9zZSxcbiAgICB0eXBlIFRyYW5zY3JpcHRpb25Xb3JkIGFzIFRyYW5zY3JpcHRpb25Xb3JkLFxuICAgIHR5cGUgVHJhbnNjcmlwdGlvbkNyZWF0ZVJlc3BvbnNlIGFzIFRyYW5zY3JpcHRpb25DcmVhdGVSZXNwb25zZSxcbiAgICB0eXBlIFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXMgYXMgVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBBdWRpb0FQSSBmcm9tICcuL2F1ZGlvJztcbmltcG9ydCAqIGFzIFRyYW5zY3JpcHRpb25zQVBJIGZyb20gJy4vdHJhbnNjcmlwdGlvbnMnO1xuXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRpb25zIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogVHJhbnNsYXRlcyBhdWRpbyBpbnRvIEVuZ2xpc2guXG4gICAqL1xuICBjcmVhdGUoXG4gICAgYm9keTogVHJhbnNsYXRpb25DcmVhdGVQYXJhbXM8J2pzb24nIHwgdW5kZWZpbmVkPixcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFRyYW5zbGF0aW9uPjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zPCd2ZXJib3NlX2pzb24nPixcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFRyYW5zbGF0aW9uVmVyYm9zZT47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtczwndGV4dCcgfCAnc3J0JyB8ICd2dHQnPixcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPHN0cmluZz47XG4gIGNyZWF0ZShib2R5OiBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8VHJhbnNsYXRpb24+O1xuICBjcmVhdGUoXG4gICAgYm9keTogVHJhbnNsYXRpb25DcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxUcmFuc2xhdGlvbkNyZWF0ZVJlc3BvbnNlIHwgc3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvYXVkaW8vdHJhbnNsYXRpb25zJywgQ29yZS5tdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbGF0aW9uIHtcbiAgdGV4dDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbGF0aW9uVmVyYm9zZSB7XG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24gb2YgdGhlIGlucHV0IGF1ZGlvLlxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGxhbmd1YWdlIG9mIHRoZSBvdXRwdXQgdHJhbnNsYXRpb24gKGFsd2F5cyBgZW5nbGlzaGApLlxuICAgKi9cbiAgbGFuZ3VhZ2U6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHRyYW5zbGF0ZWQgdGV4dC5cbiAgICovXG4gIHRleHQ6IHN0cmluZztcblxuICAvKipcbiAgICogU2VnbWVudHMgb2YgdGhlIHRyYW5zbGF0ZWQgdGV4dCBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBkZXRhaWxzLlxuICAgKi9cbiAgc2VnbWVudHM/OiBBcnJheTxUcmFuc2NyaXB0aW9uc0FQSS5UcmFuc2NyaXB0aW9uU2VnbWVudD47XG59XG5cbmV4cG9ydCB0eXBlIFRyYW5zbGF0aW9uQ3JlYXRlUmVzcG9uc2UgPSBUcmFuc2xhdGlvbiB8IFRyYW5zbGF0aW9uVmVyYm9zZTtcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtczxcbiAgUmVzcG9uc2VGb3JtYXQgZXh0ZW5kcyBBdWRpb0FQSS5BdWRpb1Jlc3BvbnNlRm9ybWF0IHwgdW5kZWZpbmVkID0gQXVkaW9BUEkuQXVkaW9SZXNwb25zZUZvcm1hdCB8IHVuZGVmaW5lZCxcbj4ge1xuICAvKipcbiAgICogVGhlIGF1ZGlvIGZpbGUgb2JqZWN0IChub3QgZmlsZSBuYW1lKSB0cmFuc2xhdGUsIGluIG9uZSBvZiB0aGVzZSBmb3JtYXRzOiBmbGFjLFxuICAgKiBtcDMsIG1wNCwgbXBlZywgbXBnYSwgbTRhLCBvZ2csIHdhdiwgb3Igd2VibS5cbiAgICovXG4gIGZpbGU6IENvcmUuVXBsb2FkYWJsZTtcblxuICAvKipcbiAgICogSUQgb2YgdGhlIG1vZGVsIHRvIHVzZS4gT25seSBgd2hpc3Blci0xYCAod2hpY2ggaXMgcG93ZXJlZCBieSBvdXIgb3BlbiBzb3VyY2VcbiAgICogV2hpc3BlciBWMiBtb2RlbCkgaXMgY3VycmVudGx5IGF2YWlsYWJsZS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgQXVkaW9BUEkuQXVkaW9Nb2RlbDtcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgdGV4dCB0byBndWlkZSB0aGUgbW9kZWwncyBzdHlsZSBvciBjb250aW51ZSBhIHByZXZpb3VzIGF1ZGlvXG4gICAqIHNlZ21lbnQuIFRoZVxuICAgKiBbcHJvbXB0XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc3BlZWNoLXRvLXRleHQjcHJvbXB0aW5nKVxuICAgKiBzaG91bGQgYmUgaW4gRW5nbGlzaC5cbiAgICovXG4gIHByb21wdD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0LCBpbiBvbmUgb2YgdGhlc2Ugb3B0aW9uczogYGpzb25gLCBgdGV4dGAsIGBzcnRgLFxuICAgKiBgdmVyYm9zZV9qc29uYCwgb3IgYHZ0dGAuXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBSZXNwb25zZUZvcm1hdDtcblxuICAvKipcbiAgICogVGhlIHNhbXBsaW5nIHRlbXBlcmF0dXJlLCBiZXR3ZWVuIDAgYW5kIDEuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbCBtYWtlIHRoZVxuICAgKiBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZSBmb2N1c2VkIGFuZFxuICAgKiBkZXRlcm1pbmlzdGljLiBJZiBzZXQgdG8gMCwgdGhlIG1vZGVsIHdpbGwgdXNlXG4gICAqIFtsb2cgcHJvYmFiaWxpdHldKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xvZ19wcm9iYWJpbGl0eSkgdG9cbiAgICogYXV0b21hdGljYWxseSBpbmNyZWFzZSB0aGUgdGVtcGVyYXR1cmUgdW50aWwgY2VydGFpbiB0aHJlc2hvbGRzIGFyZSBoaXQuXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFRyYW5zbGF0aW9ucyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBUcmFuc2xhdGlvbiBhcyBUcmFuc2xhdGlvbixcbiAgICB0eXBlIFRyYW5zbGF0aW9uVmVyYm9zZSBhcyBUcmFuc2xhdGlvblZlcmJvc2UsXG4gICAgdHlwZSBUcmFuc2xhdGlvbkNyZWF0ZVJlc3BvbnNlIGFzIFRyYW5zbGF0aW9uQ3JlYXRlUmVzcG9uc2UsXG4gICAgdHlwZSBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcyBhcyBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIFNwZWVjaEFQSSBmcm9tICcuL3NwZWVjaCc7XG5pbXBvcnQgeyBTcGVlY2gsIFNwZWVjaENyZWF0ZVBhcmFtcywgU3BlZWNoTW9kZWwgfSBmcm9tICcuL3NwZWVjaCc7XG5pbXBvcnQgKiBhcyBUcmFuc2NyaXB0aW9uc0FQSSBmcm9tICcuL3RyYW5zY3JpcHRpb25zJztcbmltcG9ydCB7XG4gIFRyYW5zY3JpcHRpb24sXG4gIFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXMsXG4gIFRyYW5zY3JpcHRpb25DcmVhdGVSZXNwb25zZSxcbiAgVHJhbnNjcmlwdGlvblNlZ21lbnQsXG4gIFRyYW5zY3JpcHRpb25WZXJib3NlLFxuICBUcmFuc2NyaXB0aW9uV29yZCxcbiAgVHJhbnNjcmlwdGlvbnMsXG59IGZyb20gJy4vdHJhbnNjcmlwdGlvbnMnO1xuaW1wb3J0ICogYXMgVHJhbnNsYXRpb25zQVBJIGZyb20gJy4vdHJhbnNsYXRpb25zJztcbmltcG9ydCB7XG4gIFRyYW5zbGF0aW9uLFxuICBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcyxcbiAgVHJhbnNsYXRpb25DcmVhdGVSZXNwb25zZSxcbiAgVHJhbnNsYXRpb25WZXJib3NlLFxuICBUcmFuc2xhdGlvbnMsXG59IGZyb20gJy4vdHJhbnNsYXRpb25zJztcblxuZXhwb3J0IGNsYXNzIEF1ZGlvIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICB0cmFuc2NyaXB0aW9uczogVHJhbnNjcmlwdGlvbnNBUEkuVHJhbnNjcmlwdGlvbnMgPSBuZXcgVHJhbnNjcmlwdGlvbnNBUEkuVHJhbnNjcmlwdGlvbnModGhpcy5fY2xpZW50KTtcbiAgdHJhbnNsYXRpb25zOiBUcmFuc2xhdGlvbnNBUEkuVHJhbnNsYXRpb25zID0gbmV3IFRyYW5zbGF0aW9uc0FQSS5UcmFuc2xhdGlvbnModGhpcy5fY2xpZW50KTtcbiAgc3BlZWNoOiBTcGVlY2hBUEkuU3BlZWNoID0gbmV3IFNwZWVjaEFQSS5TcGVlY2godGhpcy5fY2xpZW50KTtcbn1cblxuZXhwb3J0IHR5cGUgQXVkaW9Nb2RlbCA9ICd3aGlzcGVyLTEnO1xuXG4vKipcbiAqIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCwgaW4gb25lIG9mIHRoZXNlIG9wdGlvbnM6IGBqc29uYCwgYHRleHRgLCBgc3J0YCxcbiAqIGB2ZXJib3NlX2pzb25gLCBvciBgdnR0YC5cbiAqL1xuZXhwb3J0IHR5cGUgQXVkaW9SZXNwb25zZUZvcm1hdCA9ICdqc29uJyB8ICd0ZXh0JyB8ICdzcnQnIHwgJ3ZlcmJvc2VfanNvbicgfCAndnR0JztcblxuQXVkaW8uVHJhbnNjcmlwdGlvbnMgPSBUcmFuc2NyaXB0aW9ucztcbkF1ZGlvLlRyYW5zbGF0aW9ucyA9IFRyYW5zbGF0aW9ucztcbkF1ZGlvLlNwZWVjaCA9IFNwZWVjaDtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEF1ZGlvIHtcbiAgZXhwb3J0IHsgdHlwZSBBdWRpb01vZGVsIGFzIEF1ZGlvTW9kZWwsIHR5cGUgQXVkaW9SZXNwb25zZUZvcm1hdCBhcyBBdWRpb1Jlc3BvbnNlRm9ybWF0IH07XG5cbiAgZXhwb3J0IHtcbiAgICBUcmFuc2NyaXB0aW9ucyBhcyBUcmFuc2NyaXB0aW9ucyxcbiAgICB0eXBlIFRyYW5zY3JpcHRpb24gYXMgVHJhbnNjcmlwdGlvbixcbiAgICB0eXBlIFRyYW5zY3JpcHRpb25TZWdtZW50IGFzIFRyYW5zY3JpcHRpb25TZWdtZW50LFxuICAgIHR5cGUgVHJhbnNjcmlwdGlvblZlcmJvc2UgYXMgVHJhbnNjcmlwdGlvblZlcmJvc2UsXG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uV29yZCBhcyBUcmFuc2NyaXB0aW9uV29yZCxcbiAgICB0eXBlIFRyYW5zY3JpcHRpb25DcmVhdGVSZXNwb25zZSBhcyBUcmFuc2NyaXB0aW9uQ3JlYXRlUmVzcG9uc2UsXG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zIGFzIFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHtcbiAgICBUcmFuc2xhdGlvbnMgYXMgVHJhbnNsYXRpb25zLFxuICAgIHR5cGUgVHJhbnNsYXRpb24gYXMgVHJhbnNsYXRpb24sXG4gICAgdHlwZSBUcmFuc2xhdGlvblZlcmJvc2UgYXMgVHJhbnNsYXRpb25WZXJib3NlLFxuICAgIHR5cGUgVHJhbnNsYXRpb25DcmVhdGVSZXNwb25zZSBhcyBUcmFuc2xhdGlvbkNyZWF0ZVJlc3BvbnNlLFxuICAgIHR5cGUgVHJhbnNsYXRpb25DcmVhdGVQYXJhbXMgYXMgVHJhbnNsYXRpb25DcmVhdGVQYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHsgU3BlZWNoIGFzIFNwZWVjaCwgdHlwZSBTcGVlY2hNb2RlbCBhcyBTcGVlY2hNb2RlbCwgdHlwZSBTcGVlY2hDcmVhdGVQYXJhbXMgYXMgU3BlZWNoQ3JlYXRlUGFyYW1zIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQmF0Y2hlc0FQSSBmcm9tICcuL2JhdGNoZXMnO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSwgdHlwZSBDdXJzb3JQYWdlUGFyYW1zIH0gZnJvbSAnLi4vcGFnaW5hdGlvbic7XG5cbmV4cG9ydCBjbGFzcyBCYXRjaGVzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgZXhlY3V0ZXMgYSBiYXRjaCBmcm9tIGFuIHVwbG9hZGVkIGZpbGUgb2YgcmVxdWVzdHNcbiAgICovXG4gIGNyZWF0ZShib2R5OiBCYXRjaENyZWF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8QmF0Y2g+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9iYXRjaGVzJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIGJhdGNoLlxuICAgKi9cbiAgcmV0cmlldmUoYmF0Y2hJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxCYXRjaD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvYmF0Y2hlcy8ke2JhdGNoSWR9YCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCB5b3VyIG9yZ2FuaXphdGlvbidzIGJhdGNoZXMuXG4gICAqL1xuICBsaXN0KHF1ZXJ5PzogQmF0Y2hMaXN0UGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuUGFnZVByb21pc2U8QmF0Y2hlc1BhZ2UsIEJhdGNoPjtcbiAgbGlzdChvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuUGFnZVByb21pc2U8QmF0Y2hlc1BhZ2UsIEJhdGNoPjtcbiAgbGlzdChcbiAgICBxdWVyeTogQmF0Y2hMaXN0UGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEJhdGNoZXNQYWdlLCBCYXRjaD4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdCh7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy9iYXRjaGVzJywgQmF0Y2hlc1BhZ2UsIHsgcXVlcnksIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyBhbiBpbi1wcm9ncmVzcyBiYXRjaC4gVGhlIGJhdGNoIHdpbGwgYmUgaW4gc3RhdHVzIGBjYW5jZWxsaW5nYCBmb3IgdXAgdG9cbiAgICogMTAgbWludXRlcywgYmVmb3JlIGNoYW5naW5nIHRvIGBjYW5jZWxsZWRgLCB3aGVyZSBpdCB3aWxsIGhhdmUgcGFydGlhbCByZXN1bHRzXG4gICAqIChpZiBhbnkpIGF2YWlsYWJsZSBpbiB0aGUgb3V0cHV0IGZpbGUuXG4gICAqL1xuICBjYW5jZWwoYmF0Y2hJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxCYXRjaD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL2JhdGNoZXMvJHtiYXRjaElkfS9jYW5jZWxgLCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmF0Y2hlc1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlPEJhdGNoPiB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhdGNoIHtcbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHRpbWUgZnJhbWUgd2l0aGluIHdoaWNoIHRoZSBiYXRjaCBzaG91bGQgYmUgcHJvY2Vzc2VkLlxuICAgKi9cbiAgY29tcGxldGlvbl93aW5kb3c6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgYmF0Y2ggd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBPcGVuQUkgQVBJIGVuZHBvaW50IHVzZWQgYnkgdGhlIGJhdGNoLlxuICAgKi9cbiAgZW5kcG9pbnQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBpbnB1dCBmaWxlIGZvciB0aGUgYmF0Y2guXG4gICAqL1xuICBpbnB1dF9maWxlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGBiYXRjaGAuXG4gICAqL1xuICBvYmplY3Q6ICdiYXRjaCc7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgYmF0Y2guXG4gICAqL1xuICBzdGF0dXM6XG4gICAgfCAndmFsaWRhdGluZydcbiAgICB8ICdmYWlsZWQnXG4gICAgfCAnaW5fcHJvZ3Jlc3MnXG4gICAgfCAnZmluYWxpemluZydcbiAgICB8ICdjb21wbGV0ZWQnXG4gICAgfCAnZXhwaXJlZCdcbiAgICB8ICdjYW5jZWxsaW5nJ1xuICAgIHwgJ2NhbmNlbGxlZCc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGJhdGNoIHdhcyBjYW5jZWxsZWQuXG4gICAqL1xuICBjYW5jZWxsZWRfYXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGJhdGNoIHN0YXJ0ZWQgY2FuY2VsbGluZy5cbiAgICovXG4gIGNhbmNlbGxpbmdfYXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGJhdGNoIHdhcyBjb21wbGV0ZWQuXG4gICAqL1xuICBjb21wbGV0ZWRfYXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgZmlsZSBjb250YWluaW5nIHRoZSBvdXRwdXRzIG9mIHJlcXVlc3RzIHdpdGggZXJyb3JzLlxuICAgKi9cbiAgZXJyb3JfZmlsZV9pZD86IHN0cmluZztcblxuICBlcnJvcnM/OiBCYXRjaC5FcnJvcnM7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGJhdGNoIGV4cGlyZWQuXG4gICAqL1xuICBleHBpcmVkX2F0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBiYXRjaCB3aWxsIGV4cGlyZS5cbiAgICovXG4gIGV4cGlyZXNfYXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGJhdGNoIGZhaWxlZC5cbiAgICovXG4gIGZhaWxlZF9hdD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgYmF0Y2ggc3RhcnRlZCBmaW5hbGl6aW5nLlxuICAgKi9cbiAgZmluYWxpemluZ19hdD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgYmF0Y2ggc3RhcnRlZCBwcm9jZXNzaW5nLlxuICAgKi9cbiAgaW5fcHJvZ3Jlc3NfYXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgZmlsZSBjb250YWluaW5nIHRoZSBvdXRwdXRzIG9mIHN1Y2Nlc3NmdWxseSBleGVjdXRlZCByZXF1ZXN0cy5cbiAgICovXG4gIG91dHB1dF9maWxlX2lkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVxdWVzdCBjb3VudHMgZm9yIGRpZmZlcmVudCBzdGF0dXNlcyB3aXRoaW4gdGhlIGJhdGNoLlxuICAgKi9cbiAgcmVxdWVzdF9jb3VudHM/OiBCYXRjaFJlcXVlc3RDb3VudHM7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQmF0Y2gge1xuICBleHBvcnQgaW50ZXJmYWNlIEVycm9ycyB7XG4gICAgZGF0YT86IEFycmF5PEJhdGNoZXNBUEkuQmF0Y2hFcnJvcj47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgbGlzdGAuXG4gICAgICovXG4gICAgb2JqZWN0Pzogc3RyaW5nO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmF0Y2hFcnJvciB7XG4gIC8qKlxuICAgKiBBbiBlcnJvciBjb2RlIGlkZW50aWZ5aW5nIHRoZSBlcnJvciB0eXBlLlxuICAgKi9cbiAgY29kZT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBpbnB1dCBmaWxlIHdoZXJlIHRoZSBlcnJvciBvY2N1cnJlZCwgaWYgYXBwbGljYWJsZS5cbiAgICovXG4gIGxpbmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIGh1bWFuLXJlYWRhYmxlIG1lc3NhZ2UgcHJvdmlkaW5nIG1vcmUgZGV0YWlscyBhYm91dCB0aGUgZXJyb3IuXG4gICAqL1xuICBtZXNzYWdlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIHRoYXQgY2F1c2VkIHRoZSBlcnJvciwgaWYgYXBwbGljYWJsZS5cbiAgICovXG4gIHBhcmFtPzogc3RyaW5nIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBUaGUgcmVxdWVzdCBjb3VudHMgZm9yIGRpZmZlcmVudCBzdGF0dXNlcyB3aXRoaW4gdGhlIGJhdGNoLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJhdGNoUmVxdWVzdENvdW50cyB7XG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcmVxdWVzdHMgdGhhdCBoYXZlIGJlZW4gY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAgICovXG4gIGNvbXBsZXRlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcmVxdWVzdHMgdGhhdCBoYXZlIGZhaWxlZC5cbiAgICovXG4gIGZhaWxlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUb3RhbCBudW1iZXIgb2YgcmVxdWVzdHMgaW4gdGhlIGJhdGNoLlxuICAgKi9cbiAgdG90YWw6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXRjaENyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgdGltZSBmcmFtZSB3aXRoaW4gd2hpY2ggdGhlIGJhdGNoIHNob3VsZCBiZSBwcm9jZXNzZWQuIEN1cnJlbnRseSBvbmx5IGAyNGhgXG4gICAqIGlzIHN1cHBvcnRlZC5cbiAgICovXG4gIGNvbXBsZXRpb25fd2luZG93OiAnMjRoJztcblxuICAvKipcbiAgICogVGhlIGVuZHBvaW50IHRvIGJlIHVzZWQgZm9yIGFsbCByZXF1ZXN0cyBpbiB0aGUgYmF0Y2guIEN1cnJlbnRseVxuICAgKiBgL3YxL2NoYXQvY29tcGxldGlvbnNgLCBgL3YxL2VtYmVkZGluZ3NgLCBhbmQgYC92MS9jb21wbGV0aW9uc2AgYXJlIHN1cHBvcnRlZC5cbiAgICogTm90ZSB0aGF0IGAvdjEvZW1iZWRkaW5nc2AgYmF0Y2hlcyBhcmUgYWxzbyByZXN0cmljdGVkIHRvIGEgbWF4aW11bSBvZiA1MCwwMDBcbiAgICogZW1iZWRkaW5nIGlucHV0cyBhY3Jvc3MgYWxsIHJlcXVlc3RzIGluIHRoZSBiYXRjaC5cbiAgICovXG4gIGVuZHBvaW50OiAnL3YxL2NoYXQvY29tcGxldGlvbnMnIHwgJy92MS9lbWJlZGRpbmdzJyB8ICcvdjEvY29tcGxldGlvbnMnO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgYW4gdXBsb2FkZWQgZmlsZSB0aGF0IGNvbnRhaW5zIHJlcXVlc3RzIGZvciB0aGUgbmV3IGJhdGNoLlxuICAgKlxuICAgKiBTZWUgW3VwbG9hZCBmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL2NyZWF0ZSlcbiAgICogZm9yIGhvdyB0byB1cGxvYWQgYSBmaWxlLlxuICAgKlxuICAgKiBZb3VyIGlucHV0IGZpbGUgbXVzdCBiZSBmb3JtYXR0ZWQgYXMgYVxuICAgKiBbSlNPTkwgZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9iYXRjaC9yZXF1ZXN0LWlucHV0KSxcbiAgICogYW5kIG11c3QgYmUgdXBsb2FkZWQgd2l0aCB0aGUgcHVycG9zZSBgYmF0Y2hgLiBUaGUgZmlsZSBjYW4gY29udGFpbiB1cCB0byA1MCwwMDBcbiAgICogcmVxdWVzdHMsIGFuZCBjYW4gYmUgdXAgdG8gMjAwIE1CIGluIHNpemUuXG4gICAqL1xuICBpbnB1dF9maWxlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGN1c3RvbSBtZXRhZGF0YSBmb3IgdGhlIGJhdGNoLlxuICAgKi9cbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXRjaExpc3RQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHt9XG5cbkJhdGNoZXMuQmF0Y2hlc1BhZ2UgPSBCYXRjaGVzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEJhdGNoZXMge1xuICBleHBvcnQge1xuICAgIHR5cGUgQmF0Y2ggYXMgQmF0Y2gsXG4gICAgdHlwZSBCYXRjaEVycm9yIGFzIEJhdGNoRXJyb3IsXG4gICAgdHlwZSBCYXRjaFJlcXVlc3RDb3VudHMgYXMgQmF0Y2hSZXF1ZXN0Q291bnRzLFxuICAgIEJhdGNoZXNQYWdlIGFzIEJhdGNoZXNQYWdlLFxuICAgIHR5cGUgQmF0Y2hDcmVhdGVQYXJhbXMgYXMgQmF0Y2hDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBCYXRjaExpc3RQYXJhbXMgYXMgQmF0Y2hMaXN0UGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIFNoYXJlZCBmcm9tICcuLi9zaGFyZWQnO1xuaW1wb3J0ICogYXMgQ2hhdEFQSSBmcm9tICcuLi9jaGF0L2NoYXQnO1xuaW1wb3J0ICogYXMgTWVzc2FnZXNBUEkgZnJvbSAnLi90aHJlYWRzL21lc3NhZ2VzJztcbmltcG9ydCAqIGFzIFRocmVhZHNBUEkgZnJvbSAnLi90aHJlYWRzL3RocmVhZHMnO1xuaW1wb3J0ICogYXMgVmVjdG9yU3RvcmVzQVBJIGZyb20gJy4vdmVjdG9yLXN0b3Jlcy92ZWN0b3Itc3RvcmVzJztcbmltcG9ydCAqIGFzIFJ1bnNBUEkgZnJvbSAnLi90aHJlYWRzL3J1bnMvcnVucyc7XG5pbXBvcnQgKiBhcyBTdGVwc0FQSSBmcm9tICcuL3RocmVhZHMvcnVucy9zdGVwcyc7XG5pbXBvcnQgeyBDdXJzb3JQYWdlLCB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgfSBmcm9tICcuLi8uLi9wYWdpbmF0aW9uJztcblxuZXhwb3J0IGNsYXNzIEFzc2lzdGFudHMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gYXNzaXN0YW50IHdpdGggYSBtb2RlbCBhbmQgaW5zdHJ1Y3Rpb25zLlxuICAgKi9cbiAgY3JlYXRlKGJvZHk6IEFzc2lzdGFudENyZWF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8QXNzaXN0YW50PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvYXNzaXN0YW50cycsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYW4gYXNzaXN0YW50LlxuICAgKi9cbiAgcmV0cmlldmUoYXNzaXN0YW50SWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8QXNzaXN0YW50PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC9hc3Npc3RhbnRzLyR7YXNzaXN0YW50SWR9YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZpZXMgYW4gYXNzaXN0YW50LlxuICAgKi9cbiAgdXBkYXRlKFxuICAgIGFzc2lzdGFudElkOiBzdHJpbmcsXG4gICAgYm9keTogQXNzaXN0YW50VXBkYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8QXNzaXN0YW50PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvYXNzaXN0YW50cy8ke2Fzc2lzdGFudElkfWAsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhc3Npc3RhbnRzLlxuICAgKi9cbiAgbGlzdChcbiAgICBxdWVyeT86IEFzc2lzdGFudExpc3RQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8QXNzaXN0YW50c1BhZ2UsIEFzc2lzdGFudD47XG4gIGxpc3Qob3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPEFzc2lzdGFudHNQYWdlLCBBc3Npc3RhbnQ+O1xuICBsaXN0KFxuICAgIHF1ZXJ5OiBBc3Npc3RhbnRMaXN0UGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEFzc2lzdGFudHNQYWdlLCBBc3Npc3RhbnQ+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3Qoe30sIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KCcvYXNzaXN0YW50cycsIEFzc2lzdGFudHNQYWdlLCB7XG4gICAgICBxdWVyeSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbiBhc3Npc3RhbnQuXG4gICAqL1xuICBkZWwoYXNzaXN0YW50SWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8QXNzaXN0YW50RGVsZXRlZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZGVsZXRlKGAvYXNzaXN0YW50cy8ke2Fzc2lzdGFudElkfWAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBc3Npc3RhbnRzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8QXNzaXN0YW50PiB7fVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYGFzc2lzdGFudGAgdGhhdCBjYW4gY2FsbCB0aGUgbW9kZWwgYW5kIHVzZSB0b29scy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBc3Npc3RhbnQge1xuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBhc3Npc3RhbnQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYXNzaXN0YW50LiBUaGUgbWF4aW11bSBsZW5ndGggaXMgNTEyIGNoYXJhY3RlcnMuXG4gICAqL1xuICBkZXNjcmlwdGlvbjogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHN5c3RlbSBpbnN0cnVjdGlvbnMgdGhhdCB0aGUgYXNzaXN0YW50IHVzZXMuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyAyNTYsMDAwXG4gICAqIGNoYXJhY3RlcnMuXG4gICAqL1xuICBpbnN0cnVjdGlvbnM6IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhOiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogSUQgb2YgdGhlIG1vZGVsIHRvIHVzZS4gWW91IGNhbiB1c2UgdGhlXG4gICAqIFtMaXN0IG1vZGVsc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tb2RlbHMvbGlzdCkgQVBJIHRvXG4gICAqIHNlZSBhbGwgb2YgeW91ciBhdmFpbGFibGUgbW9kZWxzLCBvciBzZWUgb3VyXG4gICAqIFtNb2RlbCBvdmVydmlld10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzKSBmb3IgZGVzY3JpcHRpb25zIG9mXG4gICAqIHRoZW0uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgYXNzaXN0YW50LiBUaGUgbWF4aW11bSBsZW5ndGggaXMgMjU2IGNoYXJhY3RlcnMuXG4gICAqL1xuICBuYW1lOiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgYXNzaXN0YW50YC5cbiAgICovXG4gIG9iamVjdDogJ2Fzc2lzdGFudCc7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0b29sIGVuYWJsZWQgb24gdGhlIGFzc2lzdGFudC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxMjggdG9vbHMgcGVyXG4gICAqIGFzc2lzdGFudC4gVG9vbHMgY2FuIGJlIG9mIHR5cGVzIGBjb2RlX2ludGVycHJldGVyYCwgYGZpbGVfc2VhcmNoYCwgb3JcbiAgICogYGZ1bmN0aW9uYC5cbiAgICovXG4gIHRvb2xzOiBBcnJheTxBc3Npc3RhbnRUb29sPjtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBmb3JtYXQgdGhhdCB0aGUgbW9kZWwgbXVzdCBvdXRwdXQuIENvbXBhdGlibGUgd2l0aFxuICAgKiBbR1BULTRvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTRvKSxcbiAgICogW0dQVC00IFR1cmJvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTQtdHVyYm8tYW5kLWdwdC00KSxcbiAgICogYW5kIGFsbCBHUFQtMy41IFR1cmJvIG1vZGVscyBzaW5jZSBgZ3B0LTMuNS10dXJiby0xMTA2YC5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX3NjaGVtYVwiLCBcImpzb25fc2NoZW1hXCI6IHsuLi59IH1gIGVuYWJsZXMgU3RydWN0dXJlZFxuICAgKiBPdXRwdXRzIHdoaWNoIGVuc3VyZXMgdGhlIG1vZGVsIHdpbGwgbWF0Y2ggeW91ciBzdXBwbGllZCBKU09OIHNjaGVtYS4gTGVhcm4gbW9yZVxuICAgKiBpbiB0aGVcbiAgICogW1N0cnVjdHVyZWQgT3V0cHV0cyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3N0cnVjdHVyZWQtb3V0cHV0cykuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9vYmplY3RcIiB9YCBlbmFibGVzIEpTT04gbW9kZSwgd2hpY2ggZW5zdXJlcyB0aGVcbiAgICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gICAqXG4gICAqICoqSW1wb3J0YW50OioqIHdoZW4gdXNpbmcgSlNPTiBtb2RlLCB5b3UgKiptdXN0KiogYWxzbyBpbnN0cnVjdCB0aGUgbW9kZWwgdG9cbiAgICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICAgKiBnZW5lcmF0ZSBhbiB1bmVuZGluZyBzdHJlYW0gb2Ygd2hpdGVzcGFjZSB1bnRpbCB0aGUgZ2VuZXJhdGlvbiByZWFjaGVzIHRoZSB0b2tlblxuICAgKiBsaW1pdCwgcmVzdWx0aW5nIGluIGEgbG9uZy1ydW5uaW5nIGFuZCBzZWVtaW5nbHkgXCJzdHVja1wiIHJlcXVlc3QuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICAgKiBpbmRpY2F0ZXMgdGhlIGdlbmVyYXRpb24gZXhjZWVkZWQgYG1heF90b2tlbnNgIG9yIHRoZSBjb252ZXJzYXRpb24gZXhjZWVkZWQgdGhlXG4gICAqIG1heCBjb250ZXh0IGxlbmd0aC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86IFRocmVhZHNBUEkuQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIGFzc2lzdGFudCdzIHRvb2xzLiBUaGUgcmVzb3VyY2VzIGFyZVxuICAgKiBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzXG4gICAqIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlXG4gICAqIElEcy5cbiAgICovXG4gIHRvb2xfcmVzb3VyY2VzPzogQXNzaXN0YW50LlRvb2xSZXNvdXJjZXMgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQXNzaXN0YW50IHtcbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBhc3Npc3RhbnQncyB0b29scy4gVGhlIHJlc291cmNlcyBhcmVcbiAgICogc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlc1xuICAgKiBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZVxuICAgKiBJRHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGNvZGVfaW50ZXJwcmV0ZXI/OiBUb29sUmVzb3VyY2VzLkNvZGVJbnRlcnByZXRlcjtcblxuICAgIGZpbGVfc2VhcmNoPzogVG9vbFJlc291cmNlcy5GaWxlU2VhcmNoO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIG1hZGVcbiAgICAgICAqIGF2YWlsYWJsZSB0byB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzXG4gICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2wuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSUQgb2YgdGhlXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyBhc3Npc3RhbnQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAqIHRoZSBhc3Npc3RhbnQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFzc2lzdGFudERlbGV0ZWQge1xuICBpZDogc3RyaW5nO1xuXG4gIGRlbGV0ZWQ6IGJvb2xlYW47XG5cbiAgb2JqZWN0OiAnYXNzaXN0YW50LmRlbGV0ZWQnO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXZlbnQgZW1pdHRlZCB3aGVuIHN0cmVhbWluZyBhIFJ1bi5cbiAqXG4gKiBFYWNoIGV2ZW50IGluIGEgc2VydmVyLXNlbnQgZXZlbnRzIHN0cmVhbSBoYXMgYW4gYGV2ZW50YCBhbmQgYGRhdGFgIHByb3BlcnR5OlxuICpcbiAqIGBgYFxuICogZXZlbnQ6IHRocmVhZC5jcmVhdGVkXG4gKiBkYXRhOiB7XCJpZFwiOiBcInRocmVhZF8xMjNcIiwgXCJvYmplY3RcIjogXCJ0aHJlYWRcIiwgLi4ufVxuICogYGBgXG4gKlxuICogV2UgZW1pdCBldmVudHMgd2hlbmV2ZXIgYSBuZXcgb2JqZWN0IGlzIGNyZWF0ZWQsIHRyYW5zaXRpb25zIHRvIGEgbmV3IHN0YXRlLCBvclxuICogaXMgYmVpbmcgc3RyZWFtZWQgaW4gcGFydHMgKGRlbHRhcykuIEZvciBleGFtcGxlLCB3ZSBlbWl0IGB0aHJlYWQucnVuLmNyZWF0ZWRgXG4gKiB3aGVuIGEgbmV3IHJ1biBpcyBjcmVhdGVkLCBgdGhyZWFkLnJ1bi5jb21wbGV0ZWRgIHdoZW4gYSBydW4gY29tcGxldGVzLCBhbmQgc29cbiAqIG9uLiBXaGVuIGFuIEFzc2lzdGFudCBjaG9vc2VzIHRvIGNyZWF0ZSBhIG1lc3NhZ2UgZHVyaW5nIGEgcnVuLCB3ZSBlbWl0IGFcbiAqIGB0aHJlYWQubWVzc2FnZS5jcmVhdGVkIGV2ZW50YCwgYSBgdGhyZWFkLm1lc3NhZ2UuaW5fcHJvZ3Jlc3NgIGV2ZW50LCBtYW55XG4gKiBgdGhyZWFkLm1lc3NhZ2UuZGVsdGFgIGV2ZW50cywgYW5kIGZpbmFsbHkgYSBgdGhyZWFkLm1lc3NhZ2UuY29tcGxldGVkYCBldmVudC5cbiAqXG4gKiBXZSBtYXkgYWRkIGFkZGl0aW9uYWwgZXZlbnRzIG92ZXIgdGltZSwgc28gd2UgcmVjb21tZW5kIGhhbmRsaW5nIHVua25vd24gZXZlbnRzXG4gKiBncmFjZWZ1bGx5IGluIHlvdXIgY29kZS4gU2VlIHRoZVxuICogW0Fzc2lzdGFudHMgQVBJIHF1aWNrc3RhcnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvb3ZlcnZpZXcpXG4gKiB0byBsZWFybiBob3cgdG8gaW50ZWdyYXRlIHRoZSBBc3Npc3RhbnRzIEFQSSB3aXRoIHN0cmVhbWluZy5cbiAqL1xuZXhwb3J0IHR5cGUgQXNzaXN0YW50U3RyZWFtRXZlbnQgPVxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZENyZWF0ZWRcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5DcmVhdGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuUXVldWVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuSW5Qcm9ncmVzc1xuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1blJlcXVpcmVzQWN0aW9uXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuQ29tcGxldGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuSW5jb21wbGV0ZVxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1bkZhaWxlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1bkNhbmNlbGxpbmdcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5DYW5jZWxsZWRcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5FeHBpcmVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcENyZWF0ZWRcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwSW5Qcm9ncmVzc1xuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBEZWx0YVxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBDb21wbGV0ZWRcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwRmFpbGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcENhbmNlbGxlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBFeHBpcmVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkTWVzc2FnZUNyZWF0ZWRcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRNZXNzYWdlSW5Qcm9ncmVzc1xuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZE1lc3NhZ2VEZWx0YVxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZE1lc3NhZ2VDb21wbGV0ZWRcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRNZXNzYWdlSW5jb21wbGV0ZVxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LkVycm9yRXZlbnQ7XG5cbmV4cG9ydCBuYW1lc3BhY2UgQXNzaXN0YW50U3RyZWFtRXZlbnQge1xuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBuZXdcbiAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzL29iamVjdCkgaXNcbiAgICogY3JlYXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkQ3JlYXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHRocmVhZCB0aGF0IGNvbnRhaW5zXG4gICAgICogW21lc3NhZ2VzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBUaHJlYWRzQVBJLlRocmVhZDtcblxuICAgIGV2ZW50OiAndGhyZWFkLmNyZWF0ZWQnO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBlbmFibGUgaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBlbmFibGVkPzogYm9vbGVhbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIG5ld1xuICAgKiBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KSBpcyBjcmVhdGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5DcmVhdGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uY3JlYXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBtb3ZlcyB0byBhIGBxdWV1ZWRgIHN0YXR1cy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuUXVldWVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4ucXVldWVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIG1vdmVzIHRvIGFuIGBpbl9wcm9ncmVzc2Agc3RhdHVzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5JblByb2dyZXNzIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uaW5fcHJvZ3Jlc3MnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogbW92ZXMgdG8gYSBgcmVxdWlyZXNfYWN0aW9uYCBzdGF0dXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blJlcXVpcmVzQWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4ucmVxdWlyZXNfYWN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIGlzIGNvbXBsZXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuQ29tcGxldGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uY29tcGxldGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIGVuZHMgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5JbmNvbXBsZXRlIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uaW5jb21wbGV0ZSc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBmYWlscy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuRmFpbGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uZmFpbGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIG1vdmVzIHRvIGEgYGNhbmNlbGxpbmdgIHN0YXR1cy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuQ2FuY2VsbGluZyB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmNhbmNlbGxpbmcnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogaXMgY2FuY2VsbGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5DYW5jZWxsZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5jYW5jZWxsZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogZXhwaXJlcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuRXhwaXJlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmV4cGlyZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogaXMgY3JlYXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcENyZWF0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuY3JlYXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBtb3ZlcyB0byBhbiBgaW5fcHJvZ3Jlc3NgIHN0YXRlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwSW5Qcm9ncmVzcyB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5pbl9wcm9ncmVzcyc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gcGFydHMgb2YgYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBhcmUgYmVpbmcgc3RyZWFtZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBEZWx0YSB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHJ1biBzdGVwIGRlbHRhIGkuZS4gYW55IGNoYW5nZWQgZmllbGRzIG9uIGEgcnVuIHN0ZXAgZHVyaW5nXG4gICAgICogc3RyZWFtaW5nLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXBEZWx0YUV2ZW50O1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuZGVsdGEnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogaXMgY29tcGxldGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwQ29tcGxldGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc3RlcCBpbiBleGVjdXRpb24gb2YgYSBydW4uXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmNvbXBsZXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBmYWlscy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcEZhaWxlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5mYWlsZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogaXMgY2FuY2VsbGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwQ2FuY2VsbGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc3RlcCBpbiBleGVjdXRpb24gb2YgYSBydW4uXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmNhbmNlbGxlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBleHBpcmVzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwRXhwaXJlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5leHBpcmVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFttZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzL29iamVjdCkgaXNcbiAgICogY3JlYXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkTWVzc2FnZUNyZWF0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIHdpdGhpbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBNZXNzYWdlc0FQSS5NZXNzYWdlO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQubWVzc2FnZS5jcmVhdGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFttZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzL29iamVjdCkgbW92ZXNcbiAgICogdG8gYW4gYGluX3Byb2dyZXNzYCBzdGF0ZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkTWVzc2FnZUluUHJvZ3Jlc3Mge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIHdpdGhpbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBNZXNzYWdlc0FQSS5NZXNzYWdlO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQubWVzc2FnZS5pbl9wcm9ncmVzcyc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gcGFydHMgb2YgYVxuICAgKiBbTWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcy9vYmplY3QpIGFyZVxuICAgKiBiZWluZyBzdHJlYW1lZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkTWVzc2FnZURlbHRhIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgbWVzc2FnZSBkZWx0YSBpLmUuIGFueSBjaGFuZ2VkIGZpZWxkcyBvbiBhIG1lc3NhZ2UgZHVyaW5nXG4gICAgICogc3RyZWFtaW5nLlxuICAgICAqL1xuICAgIGRhdGE6IE1lc3NhZ2VzQVBJLk1lc3NhZ2VEZWx0YUV2ZW50O1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQubWVzc2FnZS5kZWx0YSc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbbWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcy9vYmplY3QpIGlzXG4gICAqIGNvbXBsZXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkTWVzc2FnZUNvbXBsZXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIG1lc3NhZ2Ugd2l0aGluIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IE1lc3NhZ2VzQVBJLk1lc3NhZ2U7XG5cbiAgICBldmVudDogJ3RocmVhZC5tZXNzYWdlLmNvbXBsZXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbbWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcy9vYmplY3QpIGVuZHNcbiAgICogYmVmb3JlIGl0IGlzIGNvbXBsZXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkTWVzc2FnZUluY29tcGxldGUge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIHdpdGhpbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBNZXNzYWdlc0FQSS5NZXNzYWdlO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQubWVzc2FnZS5pbmNvbXBsZXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhblxuICAgKiBbZXJyb3JdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9lcnJvci1jb2RlcyNhcGktZXJyb3JzKSBvY2N1cnMuXG4gICAqIFRoaXMgY2FuIGhhcHBlbiBkdWUgdG8gYW4gaW50ZXJuYWwgc2VydmVyIGVycm9yIG9yIGEgdGltZW91dC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXJyb3JFdmVudCB7XG4gICAgZGF0YTogU2hhcmVkLkVycm9yT2JqZWN0O1xuXG4gICAgZXZlbnQ6ICdlcnJvcic7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQXNzaXN0YW50VG9vbCA9IENvZGVJbnRlcnByZXRlclRvb2wgfCBGaWxlU2VhcmNoVG9vbCB8IEZ1bmN0aW9uVG9vbDtcblxuZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXJUb29sIHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRvb2wgYmVpbmcgZGVmaW5lZDogYGNvZGVfaW50ZXJwcmV0ZXJgXG4gICAqL1xuICB0eXBlOiAnY29kZV9pbnRlcnByZXRlcic7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaFRvb2wge1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdG9vbCBiZWluZyBkZWZpbmVkOiBgZmlsZV9zZWFyY2hgXG4gICAqL1xuICB0eXBlOiAnZmlsZV9zZWFyY2gnO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgZm9yIHRoZSBmaWxlIHNlYXJjaCB0b29sLlxuICAgKi9cbiAgZmlsZV9zZWFyY2g/OiBGaWxlU2VhcmNoVG9vbC5GaWxlU2VhcmNoO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZpbGVTZWFyY2hUb29sIHtcbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBmb3IgdGhlIGZpbGUgc2VhcmNoIHRvb2wuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZXN1bHRzIHRoZSBmaWxlIHNlYXJjaCB0b29sIHNob3VsZCBvdXRwdXQuIFRoZSBkZWZhdWx0IGlzXG4gICAgICogMjAgZm9yIGBncHQtNCpgIG1vZGVscyBhbmQgNSBmb3IgYGdwdC0zLjUtdHVyYm9gLiBUaGlzIG51bWJlciBzaG91bGQgYmUgYmV0d2VlblxuICAgICAqIDEgYW5kIDUwIGluY2x1c2l2ZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGUgZmlsZSBzZWFyY2ggdG9vbCBtYXkgb3V0cHV0IGZld2VyIHRoYW4gYG1heF9udW1fcmVzdWx0c2AgcmVzdWx0cy5cbiAgICAgKiBTZWUgdGhlXG4gICAgICogW2ZpbGUgc2VhcmNoIHRvb2wgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy90b29scy9maWxlLXNlYXJjaCNjdXN0b21pemluZy1maWxlLXNlYXJjaC1zZXR0aW5ncylcbiAgICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBtYXhfbnVtX3Jlc3VsdHM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmFua2luZyBvcHRpb25zIGZvciB0aGUgZmlsZSBzZWFyY2guIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBmaWxlIHNlYXJjaCB0b29sXG4gICAgICogd2lsbCB1c2UgdGhlIGBhdXRvYCByYW5rZXIgYW5kIGEgc2NvcmVfdGhyZXNob2xkIG9mIDAuXG4gICAgICpcbiAgICAgKiBTZWUgdGhlXG4gICAgICogW2ZpbGUgc2VhcmNoIHRvb2wgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy90b29scy9maWxlLXNlYXJjaCNjdXN0b21pemluZy1maWxlLXNlYXJjaC1zZXR0aW5ncylcbiAgICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICByYW5raW5nX29wdGlvbnM/OiBGaWxlU2VhcmNoLlJhbmtpbmdPcHRpb25zO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBGaWxlU2VhcmNoIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcmFua2luZyBvcHRpb25zIGZvciB0aGUgZmlsZSBzZWFyY2guIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBmaWxlIHNlYXJjaCB0b29sXG4gICAgICogd2lsbCB1c2UgdGhlIGBhdXRvYCByYW5rZXIgYW5kIGEgc2NvcmVfdGhyZXNob2xkIG9mIDAuXG4gICAgICpcbiAgICAgKiBTZWUgdGhlXG4gICAgICogW2ZpbGUgc2VhcmNoIHRvb2wgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy90b29scy9maWxlLXNlYXJjaCNjdXN0b21pemluZy1maWxlLXNlYXJjaC1zZXR0aW5ncylcbiAgICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIFJhbmtpbmdPcHRpb25zIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHNjb3JlIHRocmVzaG9sZCBmb3IgdGhlIGZpbGUgc2VhcmNoLiBBbGwgdmFsdWVzIG11c3QgYmUgYSBmbG9hdGluZyBwb2ludFxuICAgICAgICogbnVtYmVyIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgICAqL1xuICAgICAgc2NvcmVfdGhyZXNob2xkOiBudW1iZXI7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHJhbmtlciB0byB1c2UgZm9yIHRoZSBmaWxlIHNlYXJjaC4gSWYgbm90IHNwZWNpZmllZCB3aWxsIHVzZSB0aGUgYGF1dG9gXG4gICAgICAgKiByYW5rZXIuXG4gICAgICAgKi9cbiAgICAgIHJhbmtlcj86ICdhdXRvJyB8ICdkZWZhdWx0XzIwMjRfMDhfMjEnO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uVG9vbCB7XG4gIGZ1bmN0aW9uOiBTaGFyZWQuRnVuY3Rpb25EZWZpbml0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0b29sIGJlaW5nIGRlZmluZWQ6IGBmdW5jdGlvbmBcbiAgICovXG4gIHR5cGU6ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogT2NjdXJzIHdoZW4gYVxuICogW21lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMvb2JqZWN0KSBpc1xuICogY3JlYXRlZC5cbiAqL1xuZXhwb3J0IHR5cGUgTWVzc2FnZVN0cmVhbUV2ZW50ID1cbiAgfCBNZXNzYWdlU3RyZWFtRXZlbnQuVGhyZWFkTWVzc2FnZUNyZWF0ZWRcbiAgfCBNZXNzYWdlU3RyZWFtRXZlbnQuVGhyZWFkTWVzc2FnZUluUHJvZ3Jlc3NcbiAgfCBNZXNzYWdlU3RyZWFtRXZlbnQuVGhyZWFkTWVzc2FnZURlbHRhXG4gIHwgTWVzc2FnZVN0cmVhbUV2ZW50LlRocmVhZE1lc3NhZ2VDb21wbGV0ZWRcbiAgfCBNZXNzYWdlU3RyZWFtRXZlbnQuVGhyZWFkTWVzc2FnZUluY29tcGxldGU7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTWVzc2FnZVN0cmVhbUV2ZW50IHtcbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW21lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMvb2JqZWN0KSBpc1xuICAgKiBjcmVhdGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRNZXNzYWdlQ3JlYXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIG1lc3NhZ2Ugd2l0aGluIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IE1lc3NhZ2VzQVBJLk1lc3NhZ2U7XG5cbiAgICBldmVudDogJ3RocmVhZC5tZXNzYWdlLmNyZWF0ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW21lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMvb2JqZWN0KSBtb3Zlc1xuICAgKiB0byBhbiBgaW5fcHJvZ3Jlc3NgIHN0YXRlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRNZXNzYWdlSW5Qcm9ncmVzcyB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIG1lc3NhZ2Ugd2l0aGluIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IE1lc3NhZ2VzQVBJLk1lc3NhZ2U7XG5cbiAgICBldmVudDogJ3RocmVhZC5tZXNzYWdlLmluX3Byb2dyZXNzJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBwYXJ0cyBvZiBhXG4gICAqIFtNZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzL29iamVjdCkgYXJlXG4gICAqIGJlaW5nIHN0cmVhbWVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRNZXNzYWdlRGVsdGEge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIGRlbHRhIGkuZS4gYW55IGNoYW5nZWQgZmllbGRzIG9uIGEgbWVzc2FnZSBkdXJpbmdcbiAgICAgKiBzdHJlYW1pbmcuXG4gICAgICovXG4gICAgZGF0YTogTWVzc2FnZXNBUEkuTWVzc2FnZURlbHRhRXZlbnQ7XG5cbiAgICBldmVudDogJ3RocmVhZC5tZXNzYWdlLmRlbHRhJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFttZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzL29iamVjdCkgaXNcbiAgICogY29tcGxldGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRNZXNzYWdlQ29tcGxldGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgbWVzc2FnZSB3aXRoaW4gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogTWVzc2FnZXNBUEkuTWVzc2FnZTtcblxuICAgIGV2ZW50OiAndGhyZWFkLm1lc3NhZ2UuY29tcGxldGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFttZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzL29iamVjdCkgZW5kc1xuICAgKiBiZWZvcmUgaXQgaXMgY29tcGxldGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRNZXNzYWdlSW5jb21wbGV0ZSB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIG1lc3NhZ2Ugd2l0aGluIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IE1lc3NhZ2VzQVBJLk1lc3NhZ2U7XG5cbiAgICBldmVudDogJ3RocmVhZC5tZXNzYWdlLmluY29tcGxldGUnO1xuICB9XG59XG5cbi8qKlxuICogT2NjdXJzIHdoZW4gYVxuICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAqIGlzIGNyZWF0ZWQuXG4gKi9cbmV4cG9ydCB0eXBlIFJ1blN0ZXBTdHJlYW1FdmVudCA9XG4gIHwgUnVuU3RlcFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBDcmVhdGVkXG4gIHwgUnVuU3RlcFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBJblByb2dyZXNzXG4gIHwgUnVuU3RlcFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBEZWx0YVxuICB8IFJ1blN0ZXBTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwQ29tcGxldGVkXG4gIHwgUnVuU3RlcFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBGYWlsZWRcbiAgfCBSdW5TdGVwU3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcENhbmNlbGxlZFxuICB8IFJ1blN0ZXBTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwRXhwaXJlZDtcblxuZXhwb3J0IG5hbWVzcGFjZSBSdW5TdGVwU3RyZWFtRXZlbnQge1xuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBpcyBjcmVhdGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwQ3JlYXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5jcmVhdGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIG1vdmVzIHRvIGFuIGBpbl9wcm9ncmVzc2Agc3RhdGUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBJblByb2dyZXNzIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc3RlcCBpbiBleGVjdXRpb24gb2YgYSBydW4uXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmluX3Byb2dyZXNzJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBwYXJ0cyBvZiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIGFyZSBiZWluZyBzdHJlYW1lZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcERlbHRhIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgcnVuIHN0ZXAgZGVsdGEgaS5lLiBhbnkgY2hhbmdlZCBmaWVsZHMgb24gYSBydW4gc3RlcCBkdXJpbmdcbiAgICAgKiBzdHJlYW1pbmcuXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcERlbHRhRXZlbnQ7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5kZWx0YSc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBpcyBjb21wbGV0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBDb21wbGV0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuY29tcGxldGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIGZhaWxzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwRmFpbGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc3RlcCBpbiBleGVjdXRpb24gb2YgYSBydW4uXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmZhaWxlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBpcyBjYW5jZWxsZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBDYW5jZWxsZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuY2FuY2VsbGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIGV4cGlyZXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBFeHBpcmVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc3RlcCBpbiBleGVjdXRpb24gb2YgYSBydW4uXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmV4cGlyZWQnO1xuICB9XG59XG5cbi8qKlxuICogT2NjdXJzIHdoZW4gYSBuZXdcbiAqIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpIGlzIGNyZWF0ZWQuXG4gKi9cbmV4cG9ydCB0eXBlIFJ1blN0cmVhbUV2ZW50ID1cbiAgfCBSdW5TdHJlYW1FdmVudC5UaHJlYWRSdW5DcmVhdGVkXG4gIHwgUnVuU3RyZWFtRXZlbnQuVGhyZWFkUnVuUXVldWVkXG4gIHwgUnVuU3RyZWFtRXZlbnQuVGhyZWFkUnVuSW5Qcm9ncmVzc1xuICB8IFJ1blN0cmVhbUV2ZW50LlRocmVhZFJ1blJlcXVpcmVzQWN0aW9uXG4gIHwgUnVuU3RyZWFtRXZlbnQuVGhyZWFkUnVuQ29tcGxldGVkXG4gIHwgUnVuU3RyZWFtRXZlbnQuVGhyZWFkUnVuSW5jb21wbGV0ZVxuICB8IFJ1blN0cmVhbUV2ZW50LlRocmVhZFJ1bkZhaWxlZFxuICB8IFJ1blN0cmVhbUV2ZW50LlRocmVhZFJ1bkNhbmNlbGxpbmdcbiAgfCBSdW5TdHJlYW1FdmVudC5UaHJlYWRSdW5DYW5jZWxsZWRcbiAgfCBSdW5TdHJlYW1FdmVudC5UaHJlYWRSdW5FeHBpcmVkO1xuXG5leHBvcnQgbmFtZXNwYWNlIFJ1blN0cmVhbUV2ZW50IHtcbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgbmV3XG4gICAqIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpIGlzIGNyZWF0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkNyZWF0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5jcmVhdGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIG1vdmVzIHRvIGEgYHF1ZXVlZGAgc3RhdHVzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5RdWV1ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5xdWV1ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogbW92ZXMgdG8gYW4gYGluX3Byb2dyZXNzYCBzdGF0dXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkluUHJvZ3Jlc3Mge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5pbl9wcm9ncmVzcyc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBtb3ZlcyB0byBhIGByZXF1aXJlc19hY3Rpb25gIHN0YXR1cy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuUmVxdWlyZXNBY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5yZXF1aXJlc19hY3Rpb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogaXMgY29tcGxldGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5Db21wbGV0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5jb21wbGV0ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogZW5kcyB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkluY29tcGxldGUge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5pbmNvbXBsZXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIGZhaWxzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5GYWlsZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5mYWlsZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogbW92ZXMgdG8gYSBgY2FuY2VsbGluZ2Agc3RhdHVzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5DYW5jZWxsaW5nIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uY2FuY2VsbGluZyc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBpcyBjYW5jZWxsZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkNhbmNlbGxlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmNhbmNlbGxlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBleHBpcmVzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5FeHBpcmVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uZXhwaXJlZCc7XG4gIH1cbn1cblxuLyoqXG4gKiBPY2N1cnMgd2hlbiBhIG5ld1xuICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzL29iamVjdCkgaXNcbiAqIGNyZWF0ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkU3RyZWFtRXZlbnQge1xuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHRocmVhZCB0aGF0IGNvbnRhaW5zXG4gICAqIFttZXNzYWdlc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcykuXG4gICAqL1xuICBkYXRhOiBUaHJlYWRzQVBJLlRocmVhZDtcblxuICBldmVudDogJ3RocmVhZC5jcmVhdGVkJztcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbi5cbiAgICovXG4gIGVuYWJsZWQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFzc2lzdGFudENyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBZb3UgY2FuIHVzZSB0aGVcbiAgICogW0xpc3QgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscy9saXN0KSBBUEkgdG9cbiAgICogc2VlIGFsbCBvZiB5b3VyIGF2YWlsYWJsZSBtb2RlbHMsIG9yIHNlZSBvdXJcbiAgICogW01vZGVsIG92ZXJ2aWV3XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMpIGZvciBkZXNjcmlwdGlvbnMgb2ZcbiAgICogdGhlbS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgQ2hhdEFQSS5DaGF0TW9kZWw7XG5cbiAgLyoqXG4gICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYXNzaXN0YW50LiBUaGUgbWF4aW11bSBsZW5ndGggaXMgNTEyIGNoYXJhY3RlcnMuXG4gICAqL1xuICBkZXNjcmlwdGlvbj86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzeXN0ZW0gaW5zdHJ1Y3Rpb25zIHRoYXQgdGhlIGFzc2lzdGFudCB1c2VzLiBUaGUgbWF4aW11bSBsZW5ndGggaXMgMjU2LDAwMFxuICAgKiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGFzc2lzdGFudC4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDI1NiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAgICogW0dQVC00b10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00byksXG4gICAqIFtHUFQtNCBUdXJib10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00LXR1cmJvLWFuZC1ncHQtNCksXG4gICAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9zY2hlbWFcIiwgXCJqc29uX3NjaGVtYVwiOiB7Li4ufSB9YCBlbmFibGVzIFN0cnVjdHVyZWRcbiAgICogT3V0cHV0cyB3aGljaCBlbnN1cmVzIHRoZSBtb2RlbCB3aWxsIG1hdGNoIHlvdXIgc3VwcGxpZWQgSlNPTiBzY2hlbWEuIExlYXJuIG1vcmVcbiAgICogaW4gdGhlXG4gICAqIFtTdHJ1Y3R1cmVkIE91dHB1dHMgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zdHJ1Y3R1cmVkLW91dHB1dHMpLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGVuc3VyZXMgdGhlXG4gICAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICAgKlxuICAgKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gICAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAgICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAgICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAgICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICAgKiBtYXggY29udGV4dCBsZW5ndGguXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBUaHJlYWRzQVBJLkFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBhc3Npc3RhbnQncyB0b29scy4gVGhlIHJlc291cmNlcyBhcmVcbiAgICogc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlc1xuICAgKiBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZVxuICAgKiBJRHMuXG4gICAqL1xuICB0b29sX3Jlc291cmNlcz86IEFzc2lzdGFudENyZWF0ZVBhcmFtcy5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIHRvb2wgZW5hYmxlZCBvbiB0aGUgYXNzaXN0YW50LiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEyOCB0b29scyBwZXJcbiAgICogYXNzaXN0YW50LiBUb29scyBjYW4gYmUgb2YgdHlwZXMgYGNvZGVfaW50ZXJwcmV0ZXJgLCBgZmlsZV9zZWFyY2hgLCBvclxuICAgKiBgZnVuY3Rpb25gLlxuICAgKi9cbiAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRUb29sPjtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgdGVtcGVyYXR1cmUgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdG9wX3A/OiBudW1iZXIgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEFzc2lzdGFudENyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgdXNlZCBieSB0aGUgYXNzaXN0YW50J3MgdG9vbHMuIFRoZSByZXNvdXJjZXMgYXJlXG4gICAqIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXNcbiAgICogYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVcbiAgICogSURzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzXG4gICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2wuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGVcbiAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgKiBhdHRhY2hlZCB0byB0aGlzIGFzc2lzdGFudC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvciBzdG9yZSBhdHRhY2hlZCB0b1xuICAgICAgICogdGhlIGFzc2lzdGFudC5cbiAgICAgICAqL1xuICAgICAgdmVjdG9yX3N0b3JlX2lkcz86IEFycmF5PHN0cmluZz47XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBoZWxwZXIgdG8gY3JlYXRlIGFcbiAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgKiB3aXRoIGZpbGVfaWRzIGFuZCBhdHRhY2ggaXQgdG8gdGhpcyBhc3Npc3RhbnQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMVxuICAgICAgICogdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvIHRoZSBhc3Npc3RhbnQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZXM/OiBBcnJheTxGaWxlU2VhcmNoLlZlY3RvclN0b3JlPjtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIEZpbGVTZWFyY2gge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2h1bmtpbmcgc3RyYXRlZ3kgdXNlZCB0byBjaHVuayB0aGUgZmlsZShzKS4gSWYgbm90IHNldCwgd2lsbCB1c2UgdGhlIGBhdXRvYFxuICAgICAgICAgKiBzdHJhdGVneS4gT25seSBhcHBsaWNhYmxlIGlmIGBmaWxlX2lkc2AgaXMgbm9uLWVtcHR5LlxuICAgICAgICAgKi9cbiAgICAgICAgY2h1bmtpbmdfc3RyYXRlZ3k/OiBWZWN0b3JTdG9yZXNBUEkuRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgdG9cbiAgICAgICAgICogYWRkIHRvIHRoZSB2ZWN0b3Igc3RvcmUuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMTAwMDAgZmlsZXMgaW4gYSB2ZWN0b3JcbiAgICAgICAgICogc3RvcmUuXG4gICAgICAgICAqL1xuICAgICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB2ZWN0b3Igc3RvcmUuIFRoaXMgY2FuIGJlXG4gICAgICAgICAqIHVzZWZ1bCBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2ZWN0b3Igc3RvcmUgaW4gYSBzdHJ1Y3R1cmVkXG4gICAgICAgICAqIGZvcm1hdC4gS2V5cyBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bVxuICAgICAgICAgKiBvZiA1MTIgY2hhcmFjdGVycyBsb25nLlxuICAgICAgICAgKi9cbiAgICAgICAgbWV0YWRhdGE/OiB1bmtub3duO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFzc2lzdGFudFVwZGF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGFzc2lzdGFudC4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDUxMiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgZGVzY3JpcHRpb24/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIGluc3RydWN0aW9ucyB0aGF0IHRoZSBhc3Npc3RhbnQgdXNlcy4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDI1NiwwMDBcbiAgICogY2hhcmFjdGVycy5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIElEIG9mIHRoZSBtb2RlbCB0byB1c2UuIFlvdSBjYW4gdXNlIHRoZVxuICAgKiBbTGlzdCBtb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzL2xpc3QpIEFQSSB0b1xuICAgKiBzZWUgYWxsIG9mIHlvdXIgYXZhaWxhYmxlIG1vZGVscywgb3Igc2VlIG91clxuICAgKiBbTW9kZWwgb3ZlcnZpZXddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscykgZm9yIGRlc2NyaXB0aW9ucyBvZlxuICAgKiB0aGVtLlxuICAgKi9cbiAgbW9kZWw/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBhc3Npc3RhbnQuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyAyNTYgY2hhcmFjdGVycy5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gICAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNG8pLFxuICAgKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICAgKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fc2NoZW1hXCIsIFwianNvbl9zY2hlbWFcIjogey4uLn0gfWAgZW5hYmxlcyBTdHJ1Y3R1cmVkXG4gICAqIE91dHB1dHMgd2hpY2ggZW5zdXJlcyB0aGUgbW9kZWwgd2lsbCBtYXRjaCB5b3VyIHN1cHBsaWVkIEpTT04gc2NoZW1hLiBMZWFybiBtb3JlXG4gICAqIGluIHRoZVxuICAgKiBbU3RydWN0dXJlZCBPdXRwdXRzIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc3RydWN0dXJlZC1vdXRwdXRzKS5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBlbnN1cmVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogVGhyZWFkc0FQSS5Bc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoYXQgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdG8gdXNlLCBiZXR3ZWVuIDAgYW5kIDIuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbFxuICAgKiBtYWtlIHRoZSBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZVxuICAgKiBmb2N1c2VkIGFuZCBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgdXNlZCBieSB0aGUgYXNzaXN0YW50J3MgdG9vbHMuIFRoZSByZXNvdXJjZXMgYXJlXG4gICAqIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXNcbiAgICogYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVcbiAgICogSURzLlxuICAgKi9cbiAgdG9vbF9yZXNvdXJjZXM/OiBBc3Npc3RhbnRVcGRhdGVQYXJhbXMuVG9vbFJlc291cmNlcyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0b29sIGVuYWJsZWQgb24gdGhlIGFzc2lzdGFudC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxMjggdG9vbHMgcGVyXG4gICAqIGFzc2lzdGFudC4gVG9vbHMgY2FuIGJlIG9mIHR5cGVzIGBjb2RlX2ludGVycHJldGVyYCwgYGZpbGVfc2VhcmNoYCwgb3JcbiAgICogYGZ1bmN0aW9uYC5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50VG9vbD47XG5cbiAgLyoqXG4gICAqIEFuIGFsdGVybmF0aXZlIHRvIHNhbXBsaW5nIHdpdGggdGVtcGVyYXR1cmUsIGNhbGxlZCBudWNsZXVzIHNhbXBsaW5nLCB3aGVyZSB0aGVcbiAgICogbW9kZWwgY29uc2lkZXJzIHRoZSByZXN1bHRzIG9mIHRoZSB0b2tlbnMgd2l0aCB0b3BfcCBwcm9iYWJpbGl0eSBtYXNzLiBTbyAwLjFcbiAgICogbWVhbnMgb25seSB0aGUgdG9rZW5zIGNvbXByaXNpbmcgdGhlIHRvcCAxMCUgcHJvYmFiaWxpdHkgbWFzcyBhcmUgY29uc2lkZXJlZC5cbiAgICpcbiAgICogV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIHRlbXBlcmF0dXJlIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRvcF9wPzogbnVtYmVyIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBBc3Npc3RhbnRVcGRhdGVQYXJhbXMge1xuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIGFzc2lzdGFudCdzIHRvb2xzLiBUaGUgcmVzb3VyY2VzIGFyZVxuICAgKiBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzXG4gICAqIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlXG4gICAqIElEcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgY29kZV9pbnRlcnByZXRlcj86IFRvb2xSZXNvdXJjZXMuQ29kZUludGVycHJldGVyO1xuXG4gICAgZmlsZV9zZWFyY2g/OiBUb29sUmVzb3VyY2VzLkZpbGVTZWFyY2g7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIHRoZSBsaXN0IG9mXG4gICAgICAgKiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIG1hZGUgYXZhaWxhYmxlXG4gICAgICAgKiB0byB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMjAgZmlsZXMgYXNzb2NpYXRlZFxuICAgICAgICogd2l0aCB0aGUgdG9vbC5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyB0aGVcbiAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgKiBhdHRhY2hlZCB0byB0aGlzIGFzc2lzdGFudC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvciBzdG9yZSBhdHRhY2hlZCB0b1xuICAgICAgICogdGhlIGFzc2lzdGFudC5cbiAgICAgICAqL1xuICAgICAgdmVjdG9yX3N0b3JlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXNzaXN0YW50TGlzdFBhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge1xuICAvKipcbiAgICogQSBjdXJzb3IgZm9yIHVzZSBpbiBwYWdpbmF0aW9uLiBgYmVmb3JlYCBpcyBhbiBvYmplY3QgSUQgdGhhdCBkZWZpbmVzIHlvdXIgcGxhY2VcbiAgICogaW4gdGhlIGxpc3QuIEZvciBpbnN0YW5jZSwgaWYgeW91IG1ha2UgYSBsaXN0IHJlcXVlc3QgYW5kIHJlY2VpdmUgMTAwIG9iamVjdHMsXG4gICAqIHN0YXJ0aW5nIHdpdGggb2JqX2ZvbywgeW91ciBzdWJzZXF1ZW50IGNhbGwgY2FuIGluY2x1ZGUgYmVmb3JlPW9ial9mb28gaW4gb3JkZXJcbiAgICogdG8gZmV0Y2ggdGhlIHByZXZpb3VzIHBhZ2Ugb2YgdGhlIGxpc3QuXG4gICAqL1xuICBiZWZvcmU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNvcnQgb3JkZXIgYnkgdGhlIGBjcmVhdGVkX2F0YCB0aW1lc3RhbXAgb2YgdGhlIG9iamVjdHMuIGBhc2NgIGZvciBhc2NlbmRpbmdcbiAgICogb3JkZXIgYW5kIGBkZXNjYCBmb3IgZGVzY2VuZGluZyBvcmRlci5cbiAgICovXG4gIG9yZGVyPzogJ2FzYycgfCAnZGVzYyc7XG59XG5cbkFzc2lzdGFudHMuQXNzaXN0YW50c1BhZ2UgPSBBc3Npc3RhbnRzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEFzc2lzdGFudHMge1xuICBleHBvcnQge1xuICAgIHR5cGUgQXNzaXN0YW50IGFzIEFzc2lzdGFudCxcbiAgICB0eXBlIEFzc2lzdGFudERlbGV0ZWQgYXMgQXNzaXN0YW50RGVsZXRlZCxcbiAgICB0eXBlIEFzc2lzdGFudFN0cmVhbUV2ZW50IGFzIEFzc2lzdGFudFN0cmVhbUV2ZW50LFxuICAgIHR5cGUgQXNzaXN0YW50VG9vbCBhcyBBc3Npc3RhbnRUb29sLFxuICAgIHR5cGUgQ29kZUludGVycHJldGVyVG9vbCBhcyBDb2RlSW50ZXJwcmV0ZXJUb29sLFxuICAgIHR5cGUgRmlsZVNlYXJjaFRvb2wgYXMgRmlsZVNlYXJjaFRvb2wsXG4gICAgdHlwZSBGdW5jdGlvblRvb2wgYXMgRnVuY3Rpb25Ub29sLFxuICAgIHR5cGUgTWVzc2FnZVN0cmVhbUV2ZW50IGFzIE1lc3NhZ2VTdHJlYW1FdmVudCxcbiAgICB0eXBlIFJ1blN0ZXBTdHJlYW1FdmVudCBhcyBSdW5TdGVwU3RyZWFtRXZlbnQsXG4gICAgdHlwZSBSdW5TdHJlYW1FdmVudCBhcyBSdW5TdHJlYW1FdmVudCxcbiAgICB0eXBlIFRocmVhZFN0cmVhbUV2ZW50IGFzIFRocmVhZFN0cmVhbUV2ZW50LFxuICAgIEFzc2lzdGFudHNQYWdlIGFzIEFzc2lzdGFudHNQYWdlLFxuICAgIHR5cGUgQXNzaXN0YW50Q3JlYXRlUGFyYW1zIGFzIEFzc2lzdGFudENyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIEFzc2lzdGFudFVwZGF0ZVBhcmFtcyBhcyBBc3Npc3RhbnRVcGRhdGVQYXJhbXMsXG4gICAgdHlwZSBBc3Npc3RhbnRMaXN0UGFyYW1zIGFzIEFzc2lzdGFudExpc3RQYXJhbXMsXG4gIH07XG59XG4iLCAiaW1wb3J0IHsgdHlwZSBDaGF0Q29tcGxldGlvblJ1bm5lciB9IGZyb20gJy4vQ2hhdENvbXBsZXRpb25SdW5uZXInO1xuaW1wb3J0IHsgdHlwZSBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lciB9IGZyb20gJy4vQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXInO1xuaW1wb3J0IHsgSlNPTlNjaGVtYSB9IGZyb20gJy4vanNvbnNjaGVtYSc7XG5cbnR5cGUgUHJvbWlzZU9yVmFsdWU8VD4gPSBUIHwgUHJvbWlzZTxUPjtcblxuZXhwb3J0IHR5cGUgUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzIGV4dGVuZHMgb2JqZWN0PiA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSBhcmdzIHRoZSByZXR1cm4gdmFsdWUgZnJvbSBgcGFyc2VgLlxuICAgKiBAcGFyYW0gcnVubmVyIHRoZSBydW5uZXIgZXZhbHVhdGluZyB0aGlzIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyBhIHN0cmluZyB0byBzZW5kIGJhY2sgdG8gT3BlbkFJLlxuICAgKi9cbiAgZnVuY3Rpb246IChcbiAgICBhcmdzOiBBcmdzLFxuICAgIHJ1bm5lcjogQ2hhdENvbXBsZXRpb25SdW5uZXI8dW5rbm93bj4gfCBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcjx1bmtub3duPixcbiAgKSA9PiBQcm9taXNlT3JWYWx1ZTx1bmtub3duPjtcbiAgLyoqXG4gICAqIEBwYXJhbSBpbnB1dCB0aGUgcmF3IGFyZ3MgZnJvbSB0aGUgT3BlbkFJIGZ1bmN0aW9uIGNhbGwuXG4gICAqIEByZXR1cm5zIHRoZSBwYXJzZWQgYXJndW1lbnRzIHRvIHBhc3MgdG8gYGZ1bmN0aW9uYFxuICAgKi9cbiAgcGFyc2U6IChpbnB1dDogc3RyaW5nKSA9PiBQcm9taXNlT3JWYWx1ZTxBcmdzPjtcbiAgLyoqXG4gICAqIFRoZSBwYXJhbWV0ZXJzIHRoZSBmdW5jdGlvbiBhY2NlcHRzLCBkZXNjcmliZXMgYXMgYSBKU09OIFNjaGVtYSBvYmplY3QuXG4gICAqL1xuICBwYXJhbWV0ZXJzOiBKU09OU2NoZW1hO1xuICAvKipcbiAgICogQSBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoZSBmdW5jdGlvbiBkb2VzLCB1c2VkIGJ5IHRoZSBtb2RlbCB0byBjaG9vc2Ugd2hlbiBhbmQgaG93IHRvIGNhbGwgdGhlIGZ1bmN0aW9uLlxuICAgKi9cbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQuIFdpbGwgZGVmYXVsdCB0byBmdW5jdGlvbi5uYW1lIGlmIG9taXR0ZWQuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBzdHJpY3Q/OiBib29sZWFuIHwgdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IHR5cGUgUnVubmFibGVGdW5jdGlvbldpdGhvdXRQYXJzZSA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSBhcmdzIHRoZSByYXcgYXJncyBmcm9tIHRoZSBPcGVuQUkgZnVuY3Rpb24gY2FsbC5cbiAgICogQHJldHVybnMgYSBzdHJpbmcgdG8gc2VuZCBiYWNrIHRvIE9wZW5BSVxuICAgKi9cbiAgZnVuY3Rpb246IChcbiAgICBhcmdzOiBzdHJpbmcsXG4gICAgcnVubmVyOiBDaGF0Q29tcGxldGlvblJ1bm5lcjx1bmtub3duPiB8IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyPHVua25vd24+LFxuICApID0+IFByb21pc2VPclZhbHVlPHVua25vd24+O1xuICAvKipcbiAgICogVGhlIHBhcmFtZXRlcnMgdGhlIGZ1bmN0aW9uIGFjY2VwdHMsIGRlc2NyaWJlcyBhcyBhIEpTT04gU2NoZW1hIG9iamVjdC5cbiAgICovXG4gIHBhcmFtZXRlcnM6IEpTT05TY2hlbWE7XG4gIC8qKlxuICAgKiBBIGRlc2NyaXB0aW9uIG9mIHdoYXQgdGhlIGZ1bmN0aW9uIGRvZXMsIHVzZWQgYnkgdGhlIG1vZGVsIHRvIGNob29zZSB3aGVuIGFuZCBob3cgdG8gY2FsbCB0aGUgZnVuY3Rpb24uXG4gICAqL1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC4gV2lsbCBkZWZhdWx0IHRvIGZ1bmN0aW9uLm5hbWUgaWYgb21pdHRlZC5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHN0cmljdD86IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgdHlwZSBSdW5uYWJsZUZ1bmN0aW9uPEFyZ3MgZXh0ZW5kcyBvYmplY3QgfCBzdHJpbmc+ID1cbiAgQXJncyBleHRlbmRzIHN0cmluZyA/IFJ1bm5hYmxlRnVuY3Rpb25XaXRob3V0UGFyc2VcbiAgOiBBcmdzIGV4dGVuZHMgb2JqZWN0ID8gUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzPlxuICA6IG5ldmVyO1xuXG5leHBvcnQgdHlwZSBSdW5uYWJsZVRvb2xGdW5jdGlvbjxBcmdzIGV4dGVuZHMgb2JqZWN0IHwgc3RyaW5nPiA9XG4gIEFyZ3MgZXh0ZW5kcyBzdHJpbmcgPyBSdW5uYWJsZVRvb2xGdW5jdGlvbldpdGhvdXRQYXJzZVxuICA6IEFyZ3MgZXh0ZW5kcyBvYmplY3QgPyBSdW5uYWJsZVRvb2xGdW5jdGlvbldpdGhQYXJzZTxBcmdzPlxuICA6IG5ldmVyO1xuXG5leHBvcnQgdHlwZSBSdW5uYWJsZVRvb2xGdW5jdGlvbldpdGhvdXRQYXJzZSA9IHtcbiAgdHlwZTogJ2Z1bmN0aW9uJztcbiAgZnVuY3Rpb246IFJ1bm5hYmxlRnVuY3Rpb25XaXRob3V0UGFyc2U7XG59O1xuZXhwb3J0IHR5cGUgUnVubmFibGVUb29sRnVuY3Rpb25XaXRoUGFyc2U8QXJncyBleHRlbmRzIG9iamVjdD4gPSB7XG4gIHR5cGU6ICdmdW5jdGlvbic7XG4gIGZ1bmN0aW9uOiBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3M+O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzIGV4dGVuZHMgb2JqZWN0PihcbiAgZm46IGFueSxcbik6IGZuIGlzIFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncz4ge1xuICByZXR1cm4gdHlwZW9mIChmbiBhcyBhbnkpLnBhcnNlID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgdHlwZSBCYXNlRnVuY3Rpb25zQXJncyA9IHJlYWRvbmx5IChvYmplY3QgfCBzdHJpbmcpW107XG5cbmV4cG9ydCB0eXBlIFJ1bm5hYmxlRnVuY3Rpb25zPEZ1bmN0aW9uc0FyZ3MgZXh0ZW5kcyBCYXNlRnVuY3Rpb25zQXJncz4gPVxuICBbYW55W11dIGV4dGVuZHMgW0Z1bmN0aW9uc0FyZ3NdID8gcmVhZG9ubHkgUnVubmFibGVGdW5jdGlvbjxhbnk+W11cbiAgOiB7XG4gICAgICBbSW5kZXggaW4ga2V5b2YgRnVuY3Rpb25zQXJnc106IEluZGV4IGV4dGVuZHMgbnVtYmVyID8gUnVubmFibGVGdW5jdGlvbjxGdW5jdGlvbnNBcmdzW0luZGV4XT5cbiAgICAgIDogRnVuY3Rpb25zQXJnc1tJbmRleF07XG4gICAgfTtcblxuZXhwb3J0IHR5cGUgUnVubmFibGVUb29sczxGdW5jdGlvbnNBcmdzIGV4dGVuZHMgQmFzZUZ1bmN0aW9uc0FyZ3M+ID1cbiAgW2FueVtdXSBleHRlbmRzIFtGdW5jdGlvbnNBcmdzXSA/IHJlYWRvbmx5IFJ1bm5hYmxlVG9vbEZ1bmN0aW9uPGFueT5bXVxuICA6IHtcbiAgICAgIFtJbmRleCBpbiBrZXlvZiBGdW5jdGlvbnNBcmdzXTogSW5kZXggZXh0ZW5kcyBudW1iZXIgPyBSdW5uYWJsZVRvb2xGdW5jdGlvbjxGdW5jdGlvbnNBcmdzW0luZGV4XT5cbiAgICAgIDogRnVuY3Rpb25zQXJnc1tJbmRleF07XG4gICAgfTtcblxuLyoqXG4gKiBUaGlzIGlzIGhlbHBlciBjbGFzcyBmb3IgcGFzc2luZyBhIGBmdW5jdGlvbmAgYW5kIGBwYXJzZWAgd2hlcmUgdGhlIGBmdW5jdGlvbmBcbiAqIGFyZ3VtZW50IHR5cGUgbWF0Y2hlcyB0aGUgYHBhcnNlYCByZXR1cm4gdHlwZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCAtIHBsZWFzZSB1c2UgUGFyc2luZ1Rvb2xGdW5jdGlvbiBpbnN0ZWFkLlxuICovXG5leHBvcnQgY2xhc3MgUGFyc2luZ0Z1bmN0aW9uPEFyZ3MgZXh0ZW5kcyBvYmplY3Q+IHtcbiAgZnVuY3Rpb246IFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncz5bJ2Z1bmN0aW9uJ107XG4gIHBhcnNlOiBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3M+WydwYXJzZSddO1xuICBwYXJhbWV0ZXJzOiBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3M+WydwYXJhbWV0ZXJzJ107XG4gIGRlc2NyaXB0aW9uOiBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3M+WydkZXNjcmlwdGlvbiddO1xuICBuYW1lPzogUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzPlsnbmFtZSddO1xuXG4gIGNvbnN0cnVjdG9yKGlucHV0OiBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3M+KSB7XG4gICAgdGhpcy5mdW5jdGlvbiA9IGlucHV0LmZ1bmN0aW9uO1xuICAgIHRoaXMucGFyc2UgPSBpbnB1dC5wYXJzZTtcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSBpbnB1dC5wYXJhbWV0ZXJzO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBpbnB1dC5kZXNjcmlwdGlvbjtcbiAgICB0aGlzLm5hbWUgPSBpbnB1dC5uYW1lO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBoZWxwZXIgY2xhc3MgZm9yIHBhc3NpbmcgYSBgZnVuY3Rpb25gIGFuZCBgcGFyc2VgIHdoZXJlIHRoZSBgZnVuY3Rpb25gXG4gKiBhcmd1bWVudCB0eXBlIG1hdGNoZXMgdGhlIGBwYXJzZWAgcmV0dXJuIHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJzaW5nVG9vbEZ1bmN0aW9uPEFyZ3MgZXh0ZW5kcyBvYmplY3Q+IHtcbiAgdHlwZTogJ2Z1bmN0aW9uJztcbiAgZnVuY3Rpb246IFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncz47XG5cbiAgY29uc3RydWN0b3IoaW5wdXQ6IFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncz4pIHtcbiAgICB0aGlzLnR5cGUgPSAnZnVuY3Rpb24nO1xuICAgIHRoaXMuZnVuY3Rpb24gPSBpbnB1dDtcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIHR5cGUgQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0sXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25GdW5jdGlvbk1lc3NhZ2VQYXJhbSxcbiAgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSxcbiAgdHlwZSBDaGF0Q29tcGxldGlvblRvb2xNZXNzYWdlUGFyYW0sXG59IGZyb20gJy4uL3Jlc291cmNlcyc7XG5cbmV4cG9ydCBjb25zdCBpc0Fzc2lzdGFudE1lc3NhZ2UgPSAoXG4gIG1lc3NhZ2U6IENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtIHwgbnVsbCB8IHVuZGVmaW5lZCxcbik6IG1lc3NhZ2UgaXMgQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0gPT4ge1xuICByZXR1cm4gbWVzc2FnZT8ucm9sZSA9PT0gJ2Fzc2lzdGFudCc7XG59O1xuXG5leHBvcnQgY29uc3QgaXNGdW5jdGlvbk1lc3NhZ2UgPSAoXG4gIG1lc3NhZ2U6IENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtIHwgbnVsbCB8IHVuZGVmaW5lZCxcbik6IG1lc3NhZ2UgaXMgQ2hhdENvbXBsZXRpb25GdW5jdGlvbk1lc3NhZ2VQYXJhbSA9PiB7XG4gIHJldHVybiBtZXNzYWdlPy5yb2xlID09PSAnZnVuY3Rpb24nO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzVG9vbE1lc3NhZ2UgPSAoXG4gIG1lc3NhZ2U6IENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtIHwgbnVsbCB8IHVuZGVmaW5lZCxcbik6IG1lc3NhZ2UgaXMgQ2hhdENvbXBsZXRpb25Ub29sTWVzc2FnZVBhcmFtID0+IHtcbiAgcmV0dXJuIG1lc3NhZ2U/LnJvbGUgPT09ICd0b29sJztcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ByZXNlbnQ8VD4ob2JqOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCk6IG9iaiBpcyBUIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsO1xufVxuIiwgImltcG9ydCB7IEFQSVVzZXJBYm9ydEVycm9yLCBPcGVuQUlFcnJvciB9IGZyb20gJy4uL2Vycm9yJztcblxuZXhwb3J0IGNsYXNzIEV2ZW50U3RyZWFtPEV2ZW50VHlwZXMgZXh0ZW5kcyBCYXNlRXZlbnRzPiB7XG4gIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblxuICAjY29ubmVjdGVkUHJvbWlzZTogUHJvbWlzZTx2b2lkPjtcbiAgI3Jlc29sdmVDb25uZWN0ZWRQcm9taXNlOiAoKSA9PiB2b2lkID0gKCkgPT4ge307XG4gICNyZWplY3RDb25uZWN0ZWRQcm9taXNlOiAoZXJyb3I6IE9wZW5BSUVycm9yKSA9PiB2b2lkID0gKCkgPT4ge307XG5cbiAgI2VuZFByb21pc2U6IFByb21pc2U8dm9pZD47XG4gICNyZXNvbHZlRW5kUHJvbWlzZTogKCkgPT4gdm9pZCA9ICgpID0+IHt9O1xuICAjcmVqZWN0RW5kUHJvbWlzZTogKGVycm9yOiBPcGVuQUlFcnJvcikgPT4gdm9pZCA9ICgpID0+IHt9O1xuXG4gICNsaXN0ZW5lcnM6IHtcbiAgICBbRXZlbnQgaW4ga2V5b2YgRXZlbnRUeXBlc10/OiBFdmVudExpc3RlbmVyczxFdmVudFR5cGVzLCBFdmVudD47XG4gIH0gPSB7fTtcblxuICAjZW5kZWQgPSBmYWxzZTtcbiAgI2Vycm9yZWQgPSBmYWxzZTtcbiAgI2Fib3J0ZWQgPSBmYWxzZTtcbiAgI2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLiNjb25uZWN0ZWRQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy4jcmVzb2x2ZUNvbm5lY3RlZFByb21pc2UgPSByZXNvbHZlO1xuICAgICAgdGhpcy4jcmVqZWN0Q29ubmVjdGVkUHJvbWlzZSA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHRoaXMuI2VuZFByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLiNyZXNvbHZlRW5kUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLiNyZWplY3RFbmRQcm9taXNlID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgLy8gRG9uJ3QgbGV0IHRoZXNlIHByb21pc2VzIGNhdXNlIHVuaGFuZGxlZCByZWplY3Rpb24gZXJyb3JzLlxuICAgIC8vIHdlIHdpbGwgbWFudWFsbHkgY2F1c2UgYW4gdW5oYW5kbGVkIHJlamVjdGlvbiBlcnJvciBsYXRlclxuICAgIC8vIGlmIHRoZSB1c2VyIGhhc24ndCByZWdpc3RlcmVkIGFueSBlcnJvciBsaXN0ZW5lciBvciBjYWxsZWRcbiAgICAvLyBhbnkgcHJvbWlzZS1yZXR1cm5pbmcgbWV0aG9kLlxuICAgIHRoaXMuI2Nvbm5lY3RlZFByb21pc2UuY2F0Y2goKCkgPT4ge30pO1xuICAgIHRoaXMuI2VuZFByb21pc2UuY2F0Y2goKCkgPT4ge30pO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9ydW4odGhpczogRXZlbnRTdHJlYW08RXZlbnRUeXBlcz4sIGV4ZWN1dG9yOiAoKSA9PiBQcm9taXNlPGFueT4pIHtcbiAgICAvLyBVbmZvcnR1bmF0ZWx5IGlmIHdlIGNhbGwgYGV4ZWN1dG9yKClgIGltbWVkaWF0ZWx5IHdlIGdldCBydW50aW1lIGVycm9ycyBhYm91dFxuICAgIC8vIHJlZmVyZW5jZXMgdG8gYHRoaXNgIGJlZm9yZSB0aGUgYHN1cGVyKClgIGNvbnN0cnVjdG9yIGNhbGwgcmV0dXJucy5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGV4ZWN1dG9yKCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VtaXRGaW5hbCgpO1xuICAgICAgICB0aGlzLl9lbWl0KCdlbmQnKTtcbiAgICAgIH0sIHRoaXMuI2hhbmRsZUVycm9yLmJpbmQodGhpcykpO1xuICAgIH0sIDApO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb25uZWN0ZWQodGhpczogRXZlbnRTdHJlYW08RXZlbnRUeXBlcz4pIHtcbiAgICBpZiAodGhpcy5lbmRlZCkgcmV0dXJuO1xuICAgIHRoaXMuI3Jlc29sdmVDb25uZWN0ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5fZW1pdCgnY29ubmVjdCcpO1xuICB9XG5cbiAgZ2V0IGVuZGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLiNlbmRlZDtcbiAgfVxuXG4gIGdldCBlcnJvcmVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLiNlcnJvcmVkO1xuICB9XG5cbiAgZ2V0IGFib3J0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuI2Fib3J0ZWQ7XG4gIH1cblxuICBhYm9ydCgpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkgZm9yIHRoZSBldmVudC5cbiAgICogTm8gY2hlY2tzIGFyZSBtYWRlIHRvIHNlZSBpZiB0aGUgbGlzdGVuZXIgaGFzIGFscmVhZHkgYmVlbiBhZGRlZC4gTXVsdGlwbGUgY2FsbHMgcGFzc2luZ1xuICAgKiB0aGUgc2FtZSBjb21iaW5hdGlvbiBvZiBldmVudCBhbmQgbGlzdGVuZXIgd2lsbCByZXN1bHQgaW4gdGhlIGxpc3RlbmVyIGJlaW5nIGFkZGVkLCBhbmRcbiAgICogY2FsbGVkLCBtdWx0aXBsZSB0aW1lcy5cbiAgICogQHJldHVybnMgdGhpcyBDaGF0Q29tcGxldGlvblN0cmVhbSwgc28gdGhhdCBjYWxscyBjYW4gYmUgY2hhaW5lZFxuICAgKi9cbiAgb248RXZlbnQgZXh0ZW5kcyBrZXlvZiBFdmVudFR5cGVzPihldmVudDogRXZlbnQsIGxpc3RlbmVyOiBFdmVudExpc3RlbmVyPEV2ZW50VHlwZXMsIEV2ZW50Pik6IHRoaXMge1xuICAgIGNvbnN0IGxpc3RlbmVyczogRXZlbnRMaXN0ZW5lcnM8RXZlbnRUeXBlcywgRXZlbnQ+ID1cbiAgICAgIHRoaXMuI2xpc3RlbmVyc1tldmVudF0gfHwgKHRoaXMuI2xpc3RlbmVyc1tldmVudF0gPSBbXSk7XG4gICAgbGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgZnJvbSB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBldmVudC5cbiAgICogb2ZmKCkgd2lsbCByZW1vdmUsIGF0IG1vc3QsIG9uZSBpbnN0YW5jZSBvZiBhIGxpc3RlbmVyIGZyb20gdGhlIGxpc3RlbmVyIGFycmF5LiBJZiBhbnkgc2luZ2xlXG4gICAqIGxpc3RlbmVyIGhhcyBiZWVuIGFkZGVkIG11bHRpcGxlIHRpbWVzIHRvIHRoZSBsaXN0ZW5lciBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudCwgdGhlblxuICAgKiBvZmYoKSBtdXN0IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byByZW1vdmUgZWFjaCBpbnN0YW5jZS5cbiAgICogQHJldHVybnMgdGhpcyBDaGF0Q29tcGxldGlvblN0cmVhbSwgc28gdGhhdCBjYWxscyBjYW4gYmUgY2hhaW5lZFxuICAgKi9cbiAgb2ZmPEV2ZW50IGV4dGVuZHMga2V5b2YgRXZlbnRUeXBlcz4oZXZlbnQ6IEV2ZW50LCBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjxFdmVudFR5cGVzLCBFdmVudD4pOiB0aGlzIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLiNsaXN0ZW5lcnNbZXZlbnRdO1xuICAgIGlmICghbGlzdGVuZXJzKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5maW5kSW5kZXgoKGwpID0+IGwubGlzdGVuZXIgPT09IGxpc3RlbmVyKTtcbiAgICBpZiAoaW5kZXggPj0gMCkgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG9uZS10aW1lIGxpc3RlbmVyIGZ1bmN0aW9uIGZvciB0aGUgZXZlbnQuIFRoZSBuZXh0IHRpbWUgdGhlIGV2ZW50IGlzIHRyaWdnZXJlZCxcbiAgICogdGhpcyBsaXN0ZW5lciBpcyByZW1vdmVkIGFuZCB0aGVuIGludm9rZWQuXG4gICAqIEByZXR1cm5zIHRoaXMgQ2hhdENvbXBsZXRpb25TdHJlYW0sIHNvIHRoYXQgY2FsbHMgY2FuIGJlIGNoYWluZWRcbiAgICovXG4gIG9uY2U8RXZlbnQgZXh0ZW5kcyBrZXlvZiBFdmVudFR5cGVzPihldmVudDogRXZlbnQsIGxpc3RlbmVyOiBFdmVudExpc3RlbmVyPEV2ZW50VHlwZXMsIEV2ZW50Pik6IHRoaXMge1xuICAgIGNvbnN0IGxpc3RlbmVyczogRXZlbnRMaXN0ZW5lcnM8RXZlbnRUeXBlcywgRXZlbnQ+ID1cbiAgICAgIHRoaXMuI2xpc3RlbmVyc1tldmVudF0gfHwgKHRoaXMuI2xpc3RlbmVyc1tldmVudF0gPSBbXSk7XG4gICAgbGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogdHJ1ZSB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHNpbWlsYXIgdG8gYC5vbmNlKClgLCBidXQgcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0aGUgbmV4dCB0aW1lXG4gICAqIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQsIGluc3RlYWQgb2YgY2FsbGluZyBhIGxpc3RlbmVyIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0aGUgbmV4dCB0aW1lIGdpdmVuIGV2ZW50IGlzIHRyaWdnZXJlZCxcbiAgICogb3IgcmVqZWN0cyBpZiBhbiBlcnJvciBpcyBlbWl0dGVkLiAgKElmIHlvdSByZXF1ZXN0IHRoZSAnZXJyb3InIGV2ZW50LFxuICAgKiByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGVycm9yKS5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogICBjb25zdCBtZXNzYWdlID0gYXdhaXQgc3RyZWFtLmVtaXR0ZWQoJ21lc3NhZ2UnKSAvLyByZWplY3RzIGlmIHRoZSBzdHJlYW0gZXJyb3JzXG4gICAqL1xuICBlbWl0dGVkPEV2ZW50IGV4dGVuZHMga2V5b2YgRXZlbnRUeXBlcz4oXG4gICAgZXZlbnQ6IEV2ZW50LFxuICApOiBQcm9taXNlPFxuICAgIEV2ZW50UGFyYW1ldGVyczxFdmVudFR5cGVzLCBFdmVudD4gZXh0ZW5kcyBbaW5mZXIgUGFyYW1dID8gUGFyYW1cbiAgICA6IEV2ZW50UGFyYW1ldGVyczxFdmVudFR5cGVzLCBFdmVudD4gZXh0ZW5kcyBbXSA/IHZvaWRcbiAgICA6IEV2ZW50UGFyYW1ldGVyczxFdmVudFR5cGVzLCBFdmVudD5cbiAgPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuI2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQgPSB0cnVlO1xuICAgICAgaWYgKGV2ZW50ICE9PSAnZXJyb3InKSB0aGlzLm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIHRoaXMub25jZShldmVudCwgcmVzb2x2ZSBhcyBhbnkpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZG9uZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLiNjYXRjaGluZ1Byb21pc2VDcmVhdGVkID0gdHJ1ZTtcbiAgICBhd2FpdCB0aGlzLiNlbmRQcm9taXNlO1xuICB9XG5cbiAgI2hhbmRsZUVycm9yKHRoaXM6IEV2ZW50U3RyZWFtPEV2ZW50VHlwZXM+LCBlcnJvcjogdW5rbm93bikge1xuICAgIHRoaXMuI2Vycm9yZWQgPSB0cnVlO1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgZXJyb3IgPSBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQVBJVXNlckFib3J0RXJyb3IpIHtcbiAgICAgIHRoaXMuI2Fib3J0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuX2VtaXQoJ2Fib3J0JywgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBPcGVuQUlFcnJvcikge1xuICAgICAgcmV0dXJuIHRoaXMuX2VtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgY29uc3Qgb3BlbkFJRXJyb3I6IE9wZW5BSUVycm9yID0gbmV3IE9wZW5BSUVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgb3BlbkFJRXJyb3IuY2F1c2UgPSBlcnJvcjtcbiAgICAgIHJldHVybiB0aGlzLl9lbWl0KCdlcnJvcicsIG9wZW5BSUVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VtaXQoJ2Vycm9yJywgbmV3IE9wZW5BSUVycm9yKFN0cmluZyhlcnJvcikpKTtcbiAgfVxuXG4gIF9lbWl0PEV2ZW50IGV4dGVuZHMga2V5b2YgQmFzZUV2ZW50cz4oZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiBFdmVudFBhcmFtZXRlcnM8QmFzZUV2ZW50cywgRXZlbnQ+KTogdm9pZDtcbiAgX2VtaXQ8RXZlbnQgZXh0ZW5kcyBrZXlvZiBFdmVudFR5cGVzPihldmVudDogRXZlbnQsIC4uLmFyZ3M6IEV2ZW50UGFyYW1ldGVyczxFdmVudFR5cGVzLCBFdmVudD4pOiB2b2lkO1xuICBfZW1pdDxFdmVudCBleHRlbmRzIGtleW9mIEV2ZW50VHlwZXM+KFxuICAgIHRoaXM6IEV2ZW50U3RyZWFtPEV2ZW50VHlwZXM+LFxuICAgIGV2ZW50OiBFdmVudCxcbiAgICAuLi5hcmdzOiBFdmVudFBhcmFtZXRlcnM8RXZlbnRUeXBlcywgRXZlbnQ+XG4gICkge1xuICAgIC8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBlbWl0IGFueSBldmVudHMgYWZ0ZXIgZW5kXG4gICAgaWYgKHRoaXMuI2VuZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50ID09PSAnZW5kJykge1xuICAgICAgdGhpcy4jZW5kZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jcmVzb2x2ZUVuZFByb21pc2UoKTtcbiAgICB9XG5cbiAgICBjb25zdCBsaXN0ZW5lcnM6IEV2ZW50TGlzdGVuZXJzPEV2ZW50VHlwZXMsIEV2ZW50PiB8IHVuZGVmaW5lZCA9IHRoaXMuI2xpc3RlbmVyc1tldmVudF07XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgdGhpcy4jbGlzdGVuZXJzW2V2ZW50XSA9IGxpc3RlbmVycy5maWx0ZXIoKGwpID0+ICFsLm9uY2UpIGFzIGFueTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKCh7IGxpc3RlbmVyIH06IGFueSkgPT4gbGlzdGVuZXIoLi4uKGFyZ3MgYXMgYW55KSkpO1xuICAgIH1cblxuICAgIGlmIChldmVudCA9PT0gJ2Fib3J0Jykge1xuICAgICAgY29uc3QgZXJyb3IgPSBhcmdzWzBdIGFzIEFQSVVzZXJBYm9ydEVycm9yO1xuICAgICAgaWYgKCF0aGlzLiNjYXRjaGluZ1Byb21pc2VDcmVhdGVkICYmICFsaXN0ZW5lcnM/Lmxlbmd0aCkge1xuICAgICAgICBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgICB0aGlzLiNyZWplY3RDb25uZWN0ZWRQcm9taXNlKGVycm9yKTtcbiAgICAgIHRoaXMuI3JlamVjdEVuZFByb21pc2UoZXJyb3IpO1xuICAgICAgdGhpcy5fZW1pdCgnZW5kJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50ID09PSAnZXJyb3InKSB7XG4gICAgICAvLyBOT1RFOiBfZW1pdCgnZXJyb3InLCBlcnJvcikgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZyb20gI2hhbmRsZUVycm9yKCkuXG5cbiAgICAgIGNvbnN0IGVycm9yID0gYXJnc1swXSBhcyBPcGVuQUlFcnJvcjtcbiAgICAgIGlmICghdGhpcy4jY2F0Y2hpbmdQcm9taXNlQ3JlYXRlZCAmJiAhbGlzdGVuZXJzPy5sZW5ndGgpIHtcbiAgICAgICAgLy8gVHJpZ2dlciBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uIGlmIHRoZSB1c2VyIGhhc24ndCByZWdpc3RlcmVkIGFueSBlcnJvciBoYW5kbGVycy5cbiAgICAgICAgLy8gSWYgeW91IGFyZSBzZWVpbmcgc3RhY2sgdHJhY2VzIGhlcmUsIG1ha2Ugc3VyZSB0byBoYW5kbGUgZXJyb3JzIHZpYSBlaXRoZXI6XG4gICAgICAgIC8vIC0gcnVubmVyLm9uKCdlcnJvcicsICgpID0+IC4uLilcbiAgICAgICAgLy8gLSBhd2FpdCBydW5uZXIuZG9uZSgpXG4gICAgICAgIC8vIC0gYXdhaXQgcnVubmVyLmZpbmFsQ2hhdENvbXBsZXRpb24oKVxuICAgICAgICAvLyAtIGV0Yy5cbiAgICAgICAgUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgdGhpcy4jcmVqZWN0Q29ubmVjdGVkUHJvbWlzZShlcnJvcik7XG4gICAgICB0aGlzLiNyZWplY3RFbmRQcm9taXNlKGVycm9yKTtcbiAgICAgIHRoaXMuX2VtaXQoJ2VuZCcpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfZW1pdEZpbmFsKCk6IHZvaWQge31cbn1cblxudHlwZSBFdmVudExpc3RlbmVyPEV2ZW50cywgRXZlbnRUeXBlIGV4dGVuZHMga2V5b2YgRXZlbnRzPiA9IEV2ZW50c1tFdmVudFR5cGVdO1xuXG50eXBlIEV2ZW50TGlzdGVuZXJzPEV2ZW50cywgRXZlbnRUeXBlIGV4dGVuZHMga2V5b2YgRXZlbnRzPiA9IEFycmF5PHtcbiAgbGlzdGVuZXI6IEV2ZW50TGlzdGVuZXI8RXZlbnRzLCBFdmVudFR5cGU+O1xuICBvbmNlPzogYm9vbGVhbjtcbn0+O1xuXG5leHBvcnQgdHlwZSBFdmVudFBhcmFtZXRlcnM8RXZlbnRzLCBFdmVudFR5cGUgZXh0ZW5kcyBrZXlvZiBFdmVudHM+ID0ge1xuICBbRXZlbnQgaW4gRXZlbnRUeXBlXTogRXZlbnRMaXN0ZW5lcjxFdmVudHMsIEV2ZW50VHlwZT4gZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUCkgPT4gYW55ID8gUCA6IG5ldmVyO1xufVtFdmVudFR5cGVdO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhc2VFdmVudHMge1xuICBjb25uZWN0OiAoKSA9PiB2b2lkO1xuICBlcnJvcjogKGVycm9yOiBPcGVuQUlFcnJvcikgPT4gdm9pZDtcbiAgYWJvcnQ6IChlcnJvcjogQVBJVXNlckFib3J0RXJyb3IpID0+IHZvaWQ7XG4gIGVuZDogKCkgPT4gdm9pZDtcbn1cbiIsICJpbXBvcnQge1xuICBDaGF0Q29tcGxldGlvbixcbiAgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsLFxuICBDaGF0Q29tcGxldGlvblRvb2wsXG59IGZyb20gJy4uL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zJztcbmltcG9ydCB7XG4gIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nVG9vbFJ1bm5lclBhcmFtcyxcbiAgQ2hhdENvbXBsZXRpb25TdHJlYW1QYXJhbXMsXG4gIENoYXRDb21wbGV0aW9uVG9vbFJ1bm5lclBhcmFtcyxcbiAgUGFyc2VkQ2hhdENvbXBsZXRpb24sXG4gIFBhcnNlZENob2ljZSxcbiAgUGFyc2VkRnVuY3Rpb25Ub29sQ2FsbCxcbn0gZnJvbSAnLi4vcmVzb3VyY2VzL2JldGEvY2hhdC9jb21wbGV0aW9ucyc7XG5pbXBvcnQgeyBSZXNwb25zZUZvcm1hdEpTT05TY2hlbWEgfSBmcm9tICcuLi9yZXNvdXJjZXMvc2hhcmVkJztcbmltcG9ydCB7IENvbnRlbnRGaWx0ZXJGaW5pc2hSZWFzb25FcnJvciwgTGVuZ3RoRmluaXNoUmVhc29uRXJyb3IsIE9wZW5BSUVycm9yIH0gZnJvbSAnLi4vZXJyb3InO1xuXG50eXBlIEFueUNoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zID1cbiAgfCBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1xuICB8IENoYXRDb21wbGV0aW9uVG9vbFJ1bm5lclBhcmFtczxhbnk+XG4gIHwgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdUb29sUnVubmVyUGFyYW1zPGFueT5cbiAgfCBDaGF0Q29tcGxldGlvblN0cmVhbVBhcmFtcztcblxuZXhwb3J0IHR5cGUgRXh0cmFjdFBhcnNlZENvbnRlbnRGcm9tUGFyYW1zPFBhcmFtcyBleHRlbmRzIEFueUNoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zPiA9XG4gIFBhcmFtc1sncmVzcG9uc2VfZm9ybWF0J10gZXh0ZW5kcyBBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQ8aW5mZXIgUD4gPyBQIDogbnVsbDtcblxuZXhwb3J0IHR5cGUgQXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0PFBhcnNlZFQ+ID0gUmVzcG9uc2VGb3JtYXRKU09OU2NoZW1hICYge1xuICBfX291dHB1dDogUGFyc2VkVDsgLy8gdHlwZS1sZXZlbCBvbmx5XG5cbiAgJGJyYW5kOiAnYXV0by1wYXJzZWFibGUtcmVzcG9uc2UtZm9ybWF0JztcbiAgJHBhcnNlUmF3KGNvbnRlbnQ6IHN0cmluZyk6IFBhcnNlZFQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVBhcnNlYWJsZVJlc3BvbnNlRm9ybWF0PFBhcnNlZFQ+KFxuICByZXNwb25zZV9mb3JtYXQ6IFJlc3BvbnNlRm9ybWF0SlNPTlNjaGVtYSxcbiAgcGFyc2VyOiAoY29udGVudDogc3RyaW5nKSA9PiBQYXJzZWRULFxuKTogQXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0PFBhcnNlZFQ+IHtcbiAgY29uc3Qgb2JqID0geyAuLi5yZXNwb25zZV9mb3JtYXQgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmosIHtcbiAgICAkYnJhbmQ6IHtcbiAgICAgIHZhbHVlOiAnYXV0by1wYXJzZWFibGUtcmVzcG9uc2UtZm9ybWF0JyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgJHBhcnNlUmF3OiB7XG4gICAgICB2YWx1ZTogcGFyc2VyLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSxcbiAgfSk7XG5cbiAgcmV0dXJuIG9iaiBhcyBBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQ8UGFyc2VkVD47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dG9QYXJzYWJsZVJlc3BvbnNlRm9ybWF0PFBhcnNlZFQ+KFxuICByZXNwb25zZV9mb3JtYXQ6IGFueSxcbik6IHJlc3BvbnNlX2Zvcm1hdCBpcyBBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQ8UGFyc2VkVD4ge1xuICByZXR1cm4gcmVzcG9uc2VfZm9ybWF0Py5bJyRicmFuZCddID09PSAnYXV0by1wYXJzZWFibGUtcmVzcG9uc2UtZm9ybWF0Jztcbn1cblxudHlwZSBUb29sT3B0aW9ucyA9IHtcbiAgbmFtZTogc3RyaW5nO1xuICBhcmd1bWVudHM6IGFueTtcbiAgZnVuY3Rpb24/OiAoKGFyZ3M6IGFueSkgPT4gYW55KSB8IHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCB0eXBlIEF1dG9QYXJzZWFibGVUb29sPFxuICBPcHRpb25zVCBleHRlbmRzIFRvb2xPcHRpb25zLFxuICBIYXNGdW5jdGlvbiA9IE9wdGlvbnNUWydmdW5jdGlvbiddIGV4dGVuZHMgRnVuY3Rpb24gPyB0cnVlIDogZmFsc2UsXG4+ID0gQ2hhdENvbXBsZXRpb25Ub29sICYge1xuICBfX2FyZ3VtZW50czogT3B0aW9uc1RbJ2FyZ3VtZW50cyddOyAvLyB0eXBlLWxldmVsIG9ubHlcbiAgX19uYW1lOiBPcHRpb25zVFsnbmFtZSddOyAvLyB0eXBlLWxldmVsIG9ubHlcbiAgX19oYXNGdW5jdGlvbjogSGFzRnVuY3Rpb247IC8vIHR5cGUtbGV2ZWwgb25seVxuXG4gICRicmFuZDogJ2F1dG8tcGFyc2VhYmxlLXRvb2wnO1xuICAkY2FsbGJhY2s6ICgoYXJnczogT3B0aW9uc1RbJ2FyZ3VtZW50cyddKSA9PiBhbnkpIHwgdW5kZWZpbmVkO1xuICAkcGFyc2VSYXcoYXJnczogc3RyaW5nKTogT3B0aW9uc1RbJ2FyZ3VtZW50cyddO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQYXJzZWFibGVUb29sPE9wdGlvbnNUIGV4dGVuZHMgVG9vbE9wdGlvbnM+KFxuICB0b29sOiBDaGF0Q29tcGxldGlvblRvb2wsXG4gIHtcbiAgICBwYXJzZXIsXG4gICAgY2FsbGJhY2ssXG4gIH06IHtcbiAgICBwYXJzZXI6IChjb250ZW50OiBzdHJpbmcpID0+IE9wdGlvbnNUWydhcmd1bWVudHMnXTtcbiAgICBjYWxsYmFjazogKChhcmdzOiBhbnkpID0+IGFueSkgfCB1bmRlZmluZWQ7XG4gIH0sXG4pOiBBdXRvUGFyc2VhYmxlVG9vbDxPcHRpb25zVFsnYXJndW1lbnRzJ10+IHtcbiAgY29uc3Qgb2JqID0geyAuLi50b29sIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqLCB7XG4gICAgJGJyYW5kOiB7XG4gICAgICB2YWx1ZTogJ2F1dG8tcGFyc2VhYmxlLXRvb2wnLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICAkcGFyc2VSYXc6IHtcbiAgICAgIHZhbHVlOiBwYXJzZXIsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgICRjYWxsYmFjazoge1xuICAgICAgdmFsdWU6IGNhbGxiYWNrLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSxcbiAgfSk7XG5cbiAgcmV0dXJuIG9iaiBhcyBBdXRvUGFyc2VhYmxlVG9vbDxPcHRpb25zVFsnYXJndW1lbnRzJ10+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRvUGFyc2FibGVUb29sKHRvb2w6IGFueSk6IHRvb2wgaXMgQXV0b1BhcnNlYWJsZVRvb2w8YW55PiB7XG4gIHJldHVybiB0b29sPy5bJyRicmFuZCddID09PSAnYXV0by1wYXJzZWFibGUtdG9vbCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZVBhcnNlQ2hhdENvbXBsZXRpb248XG4gIFBhcmFtcyBleHRlbmRzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIHwgbnVsbCxcbiAgUGFyc2VkVCA9IFBhcmFtcyBleHRlbmRzIG51bGwgPyBudWxsIDogRXh0cmFjdFBhcnNlZENvbnRlbnRGcm9tUGFyYW1zPE5vbk51bGxhYmxlPFBhcmFtcz4+LFxuPihjb21wbGV0aW9uOiBDaGF0Q29tcGxldGlvbiwgcGFyYW1zOiBQYXJhbXMpOiBQYXJzZWRDaGF0Q29tcGxldGlvbjxQYXJzZWRUPiB7XG4gIGlmICghcGFyYW1zIHx8ICFoYXNBdXRvUGFyc2VhYmxlSW5wdXQocGFyYW1zKSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jb21wbGV0aW9uLFxuICAgICAgY2hvaWNlczogY29tcGxldGlvbi5jaG9pY2VzLm1hcCgoY2hvaWNlKSA9PiAoe1xuICAgICAgICAuLi5jaG9pY2UsXG4gICAgICAgIG1lc3NhZ2U6IHsgLi4uY2hvaWNlLm1lc3NhZ2UsIHBhcnNlZDogbnVsbCwgdG9vbF9jYWxsczogY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxscyA/PyBbXSB9LFxuICAgICAgfSkpLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gcGFyc2VDaGF0Q29tcGxldGlvbihjb21wbGV0aW9uLCBwYXJhbXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDaGF0Q29tcGxldGlvbjxcbiAgUGFyYW1zIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gIFBhcnNlZFQgPSBFeHRyYWN0UGFyc2VkQ29udGVudEZyb21QYXJhbXM8UGFyYW1zPixcbj4oY29tcGxldGlvbjogQ2hhdENvbXBsZXRpb24sIHBhcmFtczogUGFyYW1zKTogUGFyc2VkQ2hhdENvbXBsZXRpb248UGFyc2VkVD4ge1xuICBjb25zdCBjaG9pY2VzOiBBcnJheTxQYXJzZWRDaG9pY2U8UGFyc2VkVD4+ID0gY29tcGxldGlvbi5jaG9pY2VzLm1hcCgoY2hvaWNlKTogUGFyc2VkQ2hvaWNlPFBhcnNlZFQ+ID0+IHtcbiAgICBpZiAoY2hvaWNlLmZpbmlzaF9yZWFzb24gPT09ICdsZW5ndGgnKSB7XG4gICAgICB0aHJvdyBuZXcgTGVuZ3RoRmluaXNoUmVhc29uRXJyb3IoKTtcbiAgICB9XG5cbiAgICBpZiAoY2hvaWNlLmZpbmlzaF9yZWFzb24gPT09ICdjb250ZW50X2ZpbHRlcicpIHtcbiAgICAgIHRocm93IG5ldyBDb250ZW50RmlsdGVyRmluaXNoUmVhc29uRXJyb3IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uY2hvaWNlLFxuICAgICAgbWVzc2FnZToge1xuICAgICAgICAuLi5jaG9pY2UubWVzc2FnZSxcbiAgICAgICAgdG9vbF9jYWxsczogY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxscz8ubWFwKCh0b29sQ2FsbCkgPT4gcGFyc2VUb29sQ2FsbChwYXJhbXMsIHRvb2xDYWxsKSkgPz8gW10sXG4gICAgICAgIHBhcnNlZDpcbiAgICAgICAgICBjaG9pY2UubWVzc2FnZS5jb250ZW50ICYmICFjaG9pY2UubWVzc2FnZS5yZWZ1c2FsID9cbiAgICAgICAgICAgIHBhcnNlUmVzcG9uc2VGb3JtYXQocGFyYW1zLCBjaG9pY2UubWVzc2FnZS5jb250ZW50KVxuICAgICAgICAgIDogbnVsbCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgLi4uY29tcGxldGlvbiwgY2hvaWNlcyB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlRm9ybWF0PFxuICBQYXJhbXMgZXh0ZW5kcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgUGFyc2VkVCA9IEV4dHJhY3RQYXJzZWRDb250ZW50RnJvbVBhcmFtczxQYXJhbXM+LFxuPihwYXJhbXM6IFBhcmFtcywgY29udGVudDogc3RyaW5nKTogUGFyc2VkVCB8IG51bGwge1xuICBpZiAocGFyYW1zLnJlc3BvbnNlX2Zvcm1hdD8udHlwZSAhPT0gJ2pzb25fc2NoZW1hJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5yZXNwb25zZV9mb3JtYXQ/LnR5cGUgPT09ICdqc29uX3NjaGVtYScpIHtcbiAgICBpZiAoJyRwYXJzZVJhdycgaW4gcGFyYW1zLnJlc3BvbnNlX2Zvcm1hdCkge1xuICAgICAgY29uc3QgcmVzcG9uc2VfZm9ybWF0ID0gcGFyYW1zLnJlc3BvbnNlX2Zvcm1hdCBhcyBBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQ8UGFyc2VkVD47XG5cbiAgICAgIHJldHVybiByZXNwb25zZV9mb3JtYXQuJHBhcnNlUmF3KGNvbnRlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBKU09OLnBhcnNlKGNvbnRlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9vbENhbGw8UGFyYW1zIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXM+KFxuICBwYXJhbXM6IFBhcmFtcyxcbiAgdG9vbENhbGw6IENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsLFxuKTogUGFyc2VkRnVuY3Rpb25Ub29sQ2FsbCB7XG4gIGNvbnN0IGlucHV0VG9vbCA9IHBhcmFtcy50b29scz8uZmluZCgoaW5wdXRUb29sKSA9PiBpbnB1dFRvb2wuZnVuY3Rpb24/Lm5hbWUgPT09IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUpO1xuICByZXR1cm4ge1xuICAgIC4uLnRvb2xDYWxsLFxuICAgIGZ1bmN0aW9uOiB7XG4gICAgICAuLi50b29sQ2FsbC5mdW5jdGlvbixcbiAgICAgIHBhcnNlZF9hcmd1bWVudHM6XG4gICAgICAgIGlzQXV0b1BhcnNhYmxlVG9vbChpbnB1dFRvb2wpID8gaW5wdXRUb29sLiRwYXJzZVJhdyh0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMpXG4gICAgICAgIDogaW5wdXRUb29sPy5mdW5jdGlvbi5zdHJpY3QgPyBKU09OLnBhcnNlKHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cylcbiAgICAgICAgOiBudWxsLFxuICAgIH0sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRQYXJzZVRvb2xDYWxsKFxuICBwYXJhbXM6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgdG9vbENhbGw6IENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsLFxuKTogYm9vbGVhbiB7XG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgaW5wdXRUb29sID0gcGFyYW1zLnRvb2xzPy5maW5kKChpbnB1dFRvb2wpID0+IGlucHV0VG9vbC5mdW5jdGlvbj8ubmFtZSA9PT0gdG9vbENhbGwuZnVuY3Rpb24ubmFtZSk7XG4gIHJldHVybiBpc0F1dG9QYXJzYWJsZVRvb2woaW5wdXRUb29sKSB8fCBpbnB1dFRvb2w/LmZ1bmN0aW9uLnN0cmljdCB8fCBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0F1dG9QYXJzZWFibGVJbnB1dChwYXJhbXM6IEFueUNoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zKTogYm9vbGVhbiB7XG4gIGlmIChpc0F1dG9QYXJzYWJsZVJlc3BvbnNlRm9ybWF0KHBhcmFtcy5yZXNwb25zZV9mb3JtYXQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIHBhcmFtcy50b29scz8uc29tZShcbiAgICAgICh0KSA9PiBpc0F1dG9QYXJzYWJsZVRvb2wodCkgfHwgKHQudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0LmZ1bmN0aW9uLnN0cmljdCA9PT0gdHJ1ZSksXG4gICAgKSA/PyBmYWxzZVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVJbnB1dFRvb2xzKHRvb2xzOiBDaGF0Q29tcGxldGlvblRvb2xbXSB8IHVuZGVmaW5lZCkge1xuICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbHMgPz8gW10pIHtcbiAgICBpZiAodG9vbC50eXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoXG4gICAgICAgIGBDdXJyZW50bHkgb25seSBcXGBmdW5jdGlvblxcYCB0b29sIHR5cGVzIHN1cHBvcnQgYXV0by1wYXJzaW5nOyBSZWNlaXZlZCBcXGAke3Rvb2wudHlwZX1cXGBgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodG9vbC5mdW5jdGlvbi5zdHJpY3QgIT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihcbiAgICAgICAgYFRoZSBcXGAke3Rvb2wuZnVuY3Rpb24ubmFtZX1cXGAgdG9vbCBpcyBub3QgbWFya2VkIHdpdGggXFxgc3RyaWN0OiB0cnVlXFxgLiBPbmx5IHN0cmljdCBmdW5jdGlvbiB0b29scyBjYW4gYmUgYXV0by1wYXJzZWRgLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0IHsgdHlwZSBDb21wbGV0aW9uVXNhZ2UgfSBmcm9tICcuLi9yZXNvdXJjZXMvY29tcGxldGlvbnMnO1xuaW1wb3J0IHtcbiAgdHlwZSBDaGF0Q29tcGxldGlvbixcbiAgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2UsXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0sXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sLFxufSBmcm9tICcuLi9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucyc7XG5pbXBvcnQgeyBPcGVuQUlFcnJvciB9IGZyb20gJy4uL2Vycm9yJztcbmltcG9ydCB7XG4gIHR5cGUgUnVubmFibGVGdW5jdGlvbixcbiAgaXNSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlLFxuICB0eXBlIEJhc2VGdW5jdGlvbnNBcmdzLFxuICBSdW5uYWJsZVRvb2xGdW5jdGlvbixcbn0gZnJvbSAnLi9SdW5uYWJsZUZ1bmN0aW9uJztcbmltcG9ydCB7IENoYXRDb21wbGV0aW9uRnVuY3Rpb25SdW5uZXJQYXJhbXMsIENoYXRDb21wbGV0aW9uVG9vbFJ1bm5lclBhcmFtcyB9IGZyb20gJy4vQ2hhdENvbXBsZXRpb25SdW5uZXInO1xuaW1wb3J0IHtcbiAgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdGdW5jdGlvblJ1bm5lclBhcmFtcyxcbiAgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdUb29sUnVubmVyUGFyYW1zLFxufSBmcm9tICcuL0NoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyJztcbmltcG9ydCB7IGlzQXNzaXN0YW50TWVzc2FnZSwgaXNGdW5jdGlvbk1lc3NhZ2UsIGlzVG9vbE1lc3NhZ2UgfSBmcm9tICcuL2NoYXRDb21wbGV0aW9uVXRpbHMnO1xuaW1wb3J0IHsgQmFzZUV2ZW50cywgRXZlbnRTdHJlYW0gfSBmcm9tICcuL0V2ZW50U3RyZWFtJztcbmltcG9ydCB7IFBhcnNlZENoYXRDb21wbGV0aW9uIH0gZnJvbSAnLi4vcmVzb3VyY2VzL2JldGEvY2hhdC9jb21wbGV0aW9ucyc7XG5pbXBvcnQgT3BlbkFJIGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IGlzQXV0b1BhcnNhYmxlVG9vbCwgcGFyc2VDaGF0Q29tcGxldGlvbiB9IGZyb20gJy4uL2xpYi9wYXJzZXInO1xuXG5jb25zdCBERUZBVUxUX01BWF9DSEFUX0NPTVBMRVRJT05TID0gMTA7XG5leHBvcnQgaW50ZXJmYWNlIFJ1bm5lck9wdGlvbnMgZXh0ZW5kcyBDb3JlLlJlcXVlc3RPcHRpb25zIHtcbiAgLyoqIEhvdyBtYW55IHJlcXVlc3RzIHRvIG1ha2UgYmVmb3JlIGNhbmNlbGluZy4gRGVmYXVsdCAxMC4gKi9cbiAgbWF4Q2hhdENvbXBsZXRpb25zPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcjxcbiAgRXZlbnRUeXBlcyBleHRlbmRzIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMsXG4gIFBhcnNlZFQsXG4+IGV4dGVuZHMgRXZlbnRTdHJlYW08RXZlbnRUeXBlcz4ge1xuICBwcm90ZWN0ZWQgX2NoYXRDb21wbGV0aW9uczogUGFyc2VkQ2hhdENvbXBsZXRpb248UGFyc2VkVD5bXSA9IFtdO1xuICBtZXNzYWdlczogQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW1bXSA9IFtdO1xuXG4gIHByb3RlY3RlZCBfYWRkQ2hhdENvbXBsZXRpb24oXG4gICAgdGhpczogQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcjxBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzLCBQYXJzZWRUPixcbiAgICBjaGF0Q29tcGxldGlvbjogUGFyc2VkQ2hhdENvbXBsZXRpb248UGFyc2VkVD4sXG4gICk6IFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+IHtcbiAgICB0aGlzLl9jaGF0Q29tcGxldGlvbnMucHVzaChjaGF0Q29tcGxldGlvbik7XG4gICAgdGhpcy5fZW1pdCgnY2hhdENvbXBsZXRpb24nLCBjaGF0Q29tcGxldGlvbik7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNoYXRDb21wbGV0aW9uLmNob2ljZXNbMF0/Lm1lc3NhZ2U7XG4gICAgaWYgKG1lc3NhZ2UpIHRoaXMuX2FkZE1lc3NhZ2UobWVzc2FnZSBhcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSk7XG4gICAgcmV0dXJuIGNoYXRDb21wbGV0aW9uO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9hZGRNZXNzYWdlKFxuICAgIHRoaXM6IEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXI8QWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cywgUGFyc2VkVD4sXG4gICAgbWVzc2FnZTogQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0sXG4gICAgZW1pdCA9IHRydWUsXG4gICkge1xuICAgIGlmICghKCdjb250ZW50JyBpbiBtZXNzYWdlKSkgbWVzc2FnZS5jb250ZW50ID0gbnVsbDtcblxuICAgIHRoaXMubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcblxuICAgIGlmIChlbWl0KSB7XG4gICAgICB0aGlzLl9lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICBpZiAoKGlzRnVuY3Rpb25NZXNzYWdlKG1lc3NhZ2UpIHx8IGlzVG9vbE1lc3NhZ2UobWVzc2FnZSkpICYmIG1lc3NhZ2UuY29udGVudCkge1xuICAgICAgICAvLyBOb3RlLCB0aGlzIGFzc3VtZXMgdGhhdCB7cm9sZTogJ3Rvb2wnLCBjb250ZW50OiBcdTIwMjZ9IGlzIGFsd2F5cyB0aGUgcmVzdWx0IG9mIGEgY2FsbCBvZiB0b29sIG9mIHR5cGU9ZnVuY3Rpb24uXG4gICAgICAgIHRoaXMuX2VtaXQoJ2Z1bmN0aW9uQ2FsbFJlc3VsdCcsIG1lc3NhZ2UuY29udGVudCBhcyBzdHJpbmcpO1xuICAgICAgfSBlbHNlIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2UobWVzc2FnZSkgJiYgbWVzc2FnZS5mdW5jdGlvbl9jYWxsKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJ2Z1bmN0aW9uQ2FsbCcsIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCk7XG4gICAgICB9IGVsc2UgaWYgKGlzQXNzaXN0YW50TWVzc2FnZShtZXNzYWdlKSAmJiBtZXNzYWdlLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgZm9yIChjb25zdCB0b29sX2NhbGwgb2YgbWVzc2FnZS50b29sX2NhbGxzKSB7XG4gICAgICAgICAgaWYgKHRvb2xfY2FsbC50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdmdW5jdGlvbkNhbGwnLCB0b29sX2NhbGwuZnVuY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBmaW5hbCBDaGF0Q29tcGxldGlvbiwgb3IgcmVqZWN0c1xuICAgKiBpZiBhbiBlcnJvciBvY2N1cnJlZCBvciB0aGUgc3RyZWFtIGVuZGVkIHByZW1hdHVyZWx5IHdpdGhvdXQgcHJvZHVjaW5nIGEgQ2hhdENvbXBsZXRpb24uXG4gICAqL1xuICBhc3luYyBmaW5hbENoYXRDb21wbGV0aW9uKCk6IFByb21pc2U8UGFyc2VkQ2hhdENvbXBsZXRpb248UGFyc2VkVD4+IHtcbiAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICBjb25zdCBjb21wbGV0aW9uID0gdGhpcy5fY2hhdENvbXBsZXRpb25zW3RoaXMuX2NoYXRDb21wbGV0aW9ucy5sZW5ndGggLSAxXTtcbiAgICBpZiAoIWNvbXBsZXRpb24pIHRocm93IG5ldyBPcGVuQUlFcnJvcignc3RyZWFtIGVuZGVkIHdpdGhvdXQgcHJvZHVjaW5nIGEgQ2hhdENvbXBsZXRpb24nKTtcbiAgICByZXR1cm4gY29tcGxldGlvbjtcbiAgfVxuXG4gICNnZXRGaW5hbENvbnRlbnQoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuI2dldEZpbmFsTWVzc2FnZSgpLmNvbnRlbnQgPz8gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBjb250ZW50IG9mIHRoZSBmaW5hbCBDaGF0Q29tcGxldGlvbk1lc3NhZ2UsIG9yIHJlamVjdHNcbiAgICogaWYgYW4gZXJyb3Igb2NjdXJyZWQgb3IgdGhlIHN0cmVhbSBlbmRlZCBwcmVtYXR1cmVseSB3aXRob3V0IHByb2R1Y2luZyBhIENoYXRDb21wbGV0aW9uTWVzc2FnZS5cbiAgICovXG4gIGFzeW5jIGZpbmFsQ29udGVudCgpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICByZXR1cm4gdGhpcy4jZ2V0RmluYWxDb250ZW50KCk7XG4gIH1cblxuICAjZ2V0RmluYWxNZXNzYWdlKCk6IENoYXRDb21wbGV0aW9uTWVzc2FnZSB7XG4gICAgbGV0IGkgPSB0aGlzLm1lc3NhZ2VzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbaV07XG4gICAgICBpZiAoaXNBc3Npc3RhbnRNZXNzYWdlKG1lc3NhZ2UpKSB7XG4gICAgICAgIGNvbnN0IHsgZnVuY3Rpb25fY2FsbCwgLi4ucmVzdCB9ID0gbWVzc2FnZTtcblxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGF1ZGlvIGhlcmVcbiAgICAgICAgY29uc3QgcmV0OiBPbWl0PENoYXRDb21wbGV0aW9uTWVzc2FnZSwgJ2F1ZGlvJz4gPSB7XG4gICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICBjb250ZW50OiAobWVzc2FnZSBhcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2UpLmNvbnRlbnQgPz8gbnVsbCxcbiAgICAgICAgICByZWZ1c2FsOiAobWVzc2FnZSBhcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2UpLnJlZnVzYWwgPz8gbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZ1bmN0aW9uX2NhbGwpIHtcbiAgICAgICAgICByZXQuZnVuY3Rpb25fY2FsbCA9IGZ1bmN0aW9uX2NhbGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKCdzdHJlYW0gZW5kZWQgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbk1lc3NhZ2Ugd2l0aCByb2xlPWFzc2lzdGFudCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHRoZSBmaW5hbCBhc3Npc3RhbnQgQ2hhdENvbXBsZXRpb25NZXNzYWdlIHJlc3BvbnNlLFxuICAgKiBvciByZWplY3RzIGlmIGFuIGVycm9yIG9jY3VycmVkIG9yIHRoZSBzdHJlYW0gZW5kZWQgcHJlbWF0dXJlbHkgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbk1lc3NhZ2UuXG4gICAqL1xuICBhc3luYyBmaW5hbE1lc3NhZ2UoKTogUHJvbWlzZTxDaGF0Q29tcGxldGlvbk1lc3NhZ2U+IHtcbiAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICByZXR1cm4gdGhpcy4jZ2V0RmluYWxNZXNzYWdlKCk7XG4gIH1cblxuICAjZ2V0RmluYWxGdW5jdGlvbkNhbGwoKTogQ2hhdENvbXBsZXRpb25NZXNzYWdlLkZ1bmN0aW9uQ2FsbCB8IHVuZGVmaW5lZCB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMubWVzc2FnZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW2ldO1xuICAgICAgaWYgKGlzQXNzaXN0YW50TWVzc2FnZShtZXNzYWdlKSAmJiBtZXNzYWdlPy5mdW5jdGlvbl9jYWxsKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLmZ1bmN0aW9uX2NhbGw7XG4gICAgICB9XG4gICAgICBpZiAoaXNBc3Npc3RhbnRNZXNzYWdlKG1lc3NhZ2UpICYmIG1lc3NhZ2U/LnRvb2xfY2FsbHM/Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZS50b29sX2NhbGxzLmF0KC0xKT8uZnVuY3Rpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGNvbnRlbnQgb2YgdGhlIGZpbmFsIEZ1bmN0aW9uQ2FsbCwgb3IgcmVqZWN0c1xuICAgKiBpZiBhbiBlcnJvciBvY2N1cnJlZCBvciB0aGUgc3RyZWFtIGVuZGVkIHByZW1hdHVyZWx5IHdpdGhvdXQgcHJvZHVjaW5nIGEgQ2hhdENvbXBsZXRpb25NZXNzYWdlLlxuICAgKi9cbiAgYXN5bmMgZmluYWxGdW5jdGlvbkNhbGwoKTogUHJvbWlzZTxDaGF0Q29tcGxldGlvbk1lc3NhZ2UuRnVuY3Rpb25DYWxsIHwgdW5kZWZpbmVkPiB7XG4gICAgYXdhaXQgdGhpcy5kb25lKCk7XG4gICAgcmV0dXJuIHRoaXMuI2dldEZpbmFsRnVuY3Rpb25DYWxsKCk7XG4gIH1cblxuICAjZ2V0RmluYWxGdW5jdGlvbkNhbGxSZXN1bHQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5tZXNzYWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbaV07XG4gICAgICBpZiAoaXNGdW5jdGlvbk1lc3NhZ2UobWVzc2FnZSkgJiYgbWVzc2FnZS5jb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UuY29udGVudDtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgaXNUb29sTWVzc2FnZShtZXNzYWdlKSAmJlxuICAgICAgICBtZXNzYWdlLmNvbnRlbnQgIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSAnc3RyaW5nJyAmJlxuICAgICAgICB0aGlzLm1lc3NhZ2VzLnNvbWUoXG4gICAgICAgICAgKHgpID0+XG4gICAgICAgICAgICB4LnJvbGUgPT09ICdhc3Npc3RhbnQnICYmXG4gICAgICAgICAgICB4LnRvb2xfY2FsbHM/LnNvbWUoKHkpID0+IHkudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB5LmlkID09PSBtZXNzYWdlLnRvb2xfY2FsbF9pZCksXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZS5jb250ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGFzeW5jIGZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0KCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgYXdhaXQgdGhpcy5kb25lKCk7XG4gICAgcmV0dXJuIHRoaXMuI2dldEZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0KCk7XG4gIH1cblxuICAjY2FsY3VsYXRlVG90YWxVc2FnZSgpOiBDb21wbGV0aW9uVXNhZ2Uge1xuICAgIGNvbnN0IHRvdGFsOiBDb21wbGV0aW9uVXNhZ2UgPSB7XG4gICAgICBjb21wbGV0aW9uX3Rva2VuczogMCxcbiAgICAgIHByb21wdF90b2tlbnM6IDAsXG4gICAgICB0b3RhbF90b2tlbnM6IDAsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHsgdXNhZ2UgfSBvZiB0aGlzLl9jaGF0Q29tcGxldGlvbnMpIHtcbiAgICAgIGlmICh1c2FnZSkge1xuICAgICAgICB0b3RhbC5jb21wbGV0aW9uX3Rva2VucyArPSB1c2FnZS5jb21wbGV0aW9uX3Rva2VucztcbiAgICAgICAgdG90YWwucHJvbXB0X3Rva2VucyArPSB1c2FnZS5wcm9tcHRfdG9rZW5zO1xuICAgICAgICB0b3RhbC50b3RhbF90b2tlbnMgKz0gdXNhZ2UudG90YWxfdG9rZW5zO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cblxuICBhc3luYyB0b3RhbFVzYWdlKCk6IFByb21pc2U8Q29tcGxldGlvblVzYWdlPiB7XG4gICAgYXdhaXQgdGhpcy5kb25lKCk7XG4gICAgcmV0dXJuIHRoaXMuI2NhbGN1bGF0ZVRvdGFsVXNhZ2UoKTtcbiAgfVxuXG4gIGFsbENoYXRDb21wbGV0aW9ucygpOiBDaGF0Q29tcGxldGlvbltdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX2NoYXRDb21wbGV0aW9uc107XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgX2VtaXRGaW5hbChcbiAgICB0aGlzOiBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyPEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMsIFBhcnNlZFQ+LFxuICApIHtcbiAgICBjb25zdCBjb21wbGV0aW9uID0gdGhpcy5fY2hhdENvbXBsZXRpb25zW3RoaXMuX2NoYXRDb21wbGV0aW9ucy5sZW5ndGggLSAxXTtcbiAgICBpZiAoY29tcGxldGlvbikgdGhpcy5fZW1pdCgnZmluYWxDaGF0Q29tcGxldGlvbicsIGNvbXBsZXRpb24pO1xuICAgIGNvbnN0IGZpbmFsTWVzc2FnZSA9IHRoaXMuI2dldEZpbmFsTWVzc2FnZSgpO1xuICAgIGlmIChmaW5hbE1lc3NhZ2UpIHRoaXMuX2VtaXQoJ2ZpbmFsTWVzc2FnZScsIGZpbmFsTWVzc2FnZSk7XG4gICAgY29uc3QgZmluYWxDb250ZW50ID0gdGhpcy4jZ2V0RmluYWxDb250ZW50KCk7XG4gICAgaWYgKGZpbmFsQ29udGVudCkgdGhpcy5fZW1pdCgnZmluYWxDb250ZW50JywgZmluYWxDb250ZW50KTtcblxuICAgIGNvbnN0IGZpbmFsRnVuY3Rpb25DYWxsID0gdGhpcy4jZ2V0RmluYWxGdW5jdGlvbkNhbGwoKTtcbiAgICBpZiAoZmluYWxGdW5jdGlvbkNhbGwpIHRoaXMuX2VtaXQoJ2ZpbmFsRnVuY3Rpb25DYWxsJywgZmluYWxGdW5jdGlvbkNhbGwpO1xuXG4gICAgY29uc3QgZmluYWxGdW5jdGlvbkNhbGxSZXN1bHQgPSB0aGlzLiNnZXRGaW5hbEZ1bmN0aW9uQ2FsbFJlc3VsdCgpO1xuICAgIGlmIChmaW5hbEZ1bmN0aW9uQ2FsbFJlc3VsdCAhPSBudWxsKSB0aGlzLl9lbWl0KCdmaW5hbEZ1bmN0aW9uQ2FsbFJlc3VsdCcsIGZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0KTtcblxuICAgIGlmICh0aGlzLl9jaGF0Q29tcGxldGlvbnMuc29tZSgoYykgPT4gYy51c2FnZSkpIHtcbiAgICAgIHRoaXMuX2VtaXQoJ3RvdGFsVXNhZ2UnLCB0aGlzLiNjYWxjdWxhdGVUb3RhbFVzYWdlKCkpO1xuICAgIH1cbiAgfVxuXG4gICN2YWxpZGF0ZVBhcmFtcyhwYXJhbXM6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zKTogdm9pZCB7XG4gICAgaWYgKHBhcmFtcy5uICE9IG51bGwgJiYgcGFyYW1zLm4gPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoXG4gICAgICAgICdDaGF0Q29tcGxldGlvbiBjb252ZW5pZW5jZSBoZWxwZXJzIG9ubHkgc3VwcG9ydCBuPTEgYXQgdGhpcyB0aW1lLiBUbyB1c2Ugbj4xLCBwbGVhc2UgdXNlIGNoYXQuY29tcGxldGlvbnMuY3JlYXRlKCkgZGlyZWN0bHkuJyxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9jcmVhdGVDaGF0Q29tcGxldGlvbihcbiAgICBjbGllbnQ6IE9wZW5BSSxcbiAgICBwYXJhbXM6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBQcm9taXNlPFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+PiB7XG4gICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgIGlmIChzaWduYWwpIHtcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgfVxuICAgIHRoaXMuI3ZhbGlkYXRlUGFyYW1zKHBhcmFtcyk7XG5cbiAgICBjb25zdCBjaGF0Q29tcGxldGlvbiA9IGF3YWl0IGNsaWVudC5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZShcbiAgICAgIHsgLi4ucGFyYW1zLCBzdHJlYW06IGZhbHNlIH0sXG4gICAgICB7IC4uLm9wdGlvbnMsIHNpZ25hbDogdGhpcy5jb250cm9sbGVyLnNpZ25hbCB9LFxuICAgICk7XG4gICAgdGhpcy5fY29ubmVjdGVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoYXRDb21wbGV0aW9uKHBhcnNlQ2hhdENvbXBsZXRpb24oY2hhdENvbXBsZXRpb24sIHBhcmFtcykpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9ydW5DaGF0Q29tcGxldGlvbihcbiAgICBjbGllbnQ6IE9wZW5BSSxcbiAgICBwYXJhbXM6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBQcm9taXNlPENoYXRDb21wbGV0aW9uPiB7XG4gICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHBhcmFtcy5tZXNzYWdlcykge1xuICAgICAgdGhpcy5fYWRkTWVzc2FnZShtZXNzYWdlLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9jcmVhdGVDaGF0Q29tcGxldGlvbihjbGllbnQsIHBhcmFtcywgb3B0aW9ucyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX3J1bkZ1bmN0aW9uczxGdW5jdGlvbnNBcmdzIGV4dGVuZHMgQmFzZUZ1bmN0aW9uc0FyZ3M+KFxuICAgIGNsaWVudDogT3BlbkFJLFxuICAgIHBhcmFtczpcbiAgICAgIHwgQ2hhdENvbXBsZXRpb25GdW5jdGlvblJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzPlxuICAgICAgfCBDaGF0Q29tcGxldGlvblN0cmVhbWluZ0Z1bmN0aW9uUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3M+LFxuICAgIG9wdGlvbnM/OiBSdW5uZXJPcHRpb25zLFxuICApIHtcbiAgICBjb25zdCByb2xlID0gJ2Z1bmN0aW9uJyBhcyBjb25zdDtcbiAgICBjb25zdCB7IGZ1bmN0aW9uX2NhbGwgPSAnYXV0bycsIHN0cmVhbSwgLi4ucmVzdFBhcmFtcyB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHNpbmdsZUZ1bmN0aW9uVG9DYWxsID0gdHlwZW9mIGZ1bmN0aW9uX2NhbGwgIT09ICdzdHJpbmcnICYmIGZ1bmN0aW9uX2NhbGw/Lm5hbWU7XG4gICAgY29uc3QgeyBtYXhDaGF0Q29tcGxldGlvbnMgPSBERUZBVUxUX01BWF9DSEFUX0NPTVBMRVRJT05TIH0gPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3QgZnVuY3Rpb25zQnlOYW1lOiBSZWNvcmQ8c3RyaW5nLCBSdW5uYWJsZUZ1bmN0aW9uPGFueT4+ID0ge307XG4gICAgZm9yIChjb25zdCBmIG9mIHBhcmFtcy5mdW5jdGlvbnMpIHtcbiAgICAgIGZ1bmN0aW9uc0J5TmFtZVtmLm5hbWUgfHwgZi5mdW5jdGlvbi5uYW1lXSA9IGY7XG4gICAgfVxuXG4gICAgY29uc3QgZnVuY3Rpb25zOiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcy5GdW5jdGlvbltdID0gcGFyYW1zLmZ1bmN0aW9ucy5tYXAoXG4gICAgICAoZik6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLkZ1bmN0aW9uID0+ICh7XG4gICAgICAgIG5hbWU6IGYubmFtZSB8fCBmLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgIHBhcmFtZXRlcnM6IGYucGFyYW1ldGVycyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgICAgICAgZGVzY3JpcHRpb246IGYuZGVzY3JpcHRpb24sXG4gICAgICB9KSxcbiAgICApO1xuXG4gICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHBhcmFtcy5tZXNzYWdlcykge1xuICAgICAgdGhpcy5fYWRkTWVzc2FnZShtZXNzYWdlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhDaGF0Q29tcGxldGlvbnM7ICsraSkge1xuICAgICAgY29uc3QgY2hhdENvbXBsZXRpb246IENoYXRDb21wbGV0aW9uID0gYXdhaXQgdGhpcy5fY3JlYXRlQ2hhdENvbXBsZXRpb24oXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAge1xuICAgICAgICAgIC4uLnJlc3RQYXJhbXMsXG4gICAgICAgICAgZnVuY3Rpb25fY2FsbCxcbiAgICAgICAgICBmdW5jdGlvbnMsXG4gICAgICAgICAgbWVzc2FnZXM6IFsuLi50aGlzLm1lc3NhZ2VzXSxcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICk7XG4gICAgICBjb25zdCBtZXNzYWdlID0gY2hhdENvbXBsZXRpb24uY2hvaWNlc1swXT8ubWVzc2FnZTtcbiAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYG1pc3NpbmcgbWVzc2FnZSBpbiBDaGF0Q29tcGxldGlvbiByZXNwb25zZWApO1xuICAgICAgfVxuICAgICAgaWYgKCFtZXNzYWdlLmZ1bmN0aW9uX2NhbGwpIHJldHVybjtcbiAgICAgIGNvbnN0IHsgbmFtZSwgYXJndW1lbnRzOiBhcmdzIH0gPSBtZXNzYWdlLmZ1bmN0aW9uX2NhbGw7XG4gICAgICBjb25zdCBmbiA9IGZ1bmN0aW9uc0J5TmFtZVtuYW1lXTtcbiAgICAgIGlmICghZm4pIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGBJbnZhbGlkIGZ1bmN0aW9uX2NhbGw6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9LiBBdmFpbGFibGUgb3B0aW9ucyBhcmU6ICR7ZnVuY3Rpb25zXG4gICAgICAgICAgLm1hcCgoZikgPT4gSlNPTi5zdHJpbmdpZnkoZi5uYW1lKSlcbiAgICAgICAgICAuam9pbignLCAnKX0uIFBsZWFzZSB0cnkgYWdhaW5gO1xuXG4gICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoeyByb2xlLCBuYW1lLCBjb250ZW50IH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2luZ2xlRnVuY3Rpb25Ub0NhbGwgJiYgc2luZ2xlRnVuY3Rpb25Ub0NhbGwgIT09IG5hbWUpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGBJbnZhbGlkIGZ1bmN0aW9uX2NhbGw6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9LiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHNpbmdsZUZ1bmN0aW9uVG9DYWxsLFxuICAgICAgICApfSByZXF1ZXN0ZWQuIFBsZWFzZSB0cnkgYWdhaW5gO1xuXG4gICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoeyByb2xlLCBuYW1lLCBjb250ZW50IH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IHBhcnNlZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZCA9IGlzUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZShmbikgPyBhd2FpdCBmbi5wYXJzZShhcmdzKSA6IGFyZ3M7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHtcbiAgICAgICAgICByb2xlLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgY29udGVudDogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaXQgY2FuJ3QgcnVsZSBvdXQgYG5ldmVyYCB0eXBlLlxuICAgICAgY29uc3QgcmF3Q29udGVudCA9IGF3YWl0IGZuLmZ1bmN0aW9uKHBhcnNlZCwgdGhpcyk7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGhpcy4jc3RyaW5naWZ5RnVuY3Rpb25DYWxsUmVzdWx0KHJhd0NvbnRlbnQpO1xuXG4gICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgbmFtZSwgY29udGVudCB9KTtcblxuICAgICAgaWYgKHNpbmdsZUZ1bmN0aW9uVG9DYWxsKSByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9ydW5Ub29sczxGdW5jdGlvbnNBcmdzIGV4dGVuZHMgQmFzZUZ1bmN0aW9uc0FyZ3M+KFxuICAgIGNsaWVudDogT3BlbkFJLFxuICAgIHBhcmFtczpcbiAgICAgIHwgQ2hhdENvbXBsZXRpb25Ub29sUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3M+XG4gICAgICB8IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nVG9vbFJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzPixcbiAgICBvcHRpb25zPzogUnVubmVyT3B0aW9ucyxcbiAgKSB7XG4gICAgY29uc3Qgcm9sZSA9ICd0b29sJyBhcyBjb25zdDtcbiAgICBjb25zdCB7IHRvb2xfY2hvaWNlID0gJ2F1dG8nLCBzdHJlYW0sIC4uLnJlc3RQYXJhbXMgfSA9IHBhcmFtcztcbiAgICBjb25zdCBzaW5nbGVGdW5jdGlvblRvQ2FsbCA9IHR5cGVvZiB0b29sX2Nob2ljZSAhPT0gJ3N0cmluZycgJiYgdG9vbF9jaG9pY2U/LmZ1bmN0aW9uPy5uYW1lO1xuICAgIGNvbnN0IHsgbWF4Q2hhdENvbXBsZXRpb25zID0gREVGQVVMVF9NQVhfQ0hBVF9DT01QTEVUSU9OUyB9ID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIFRPRE8oc29tZWRheSk6IGNsZWFuIHRoaXMgbG9naWMgdXBcbiAgICBjb25zdCBpbnB1dFRvb2xzID0gcGFyYW1zLnRvb2xzLm1hcCgodG9vbCk6IFJ1bm5hYmxlVG9vbEZ1bmN0aW9uPGFueT4gPT4ge1xuICAgICAgaWYgKGlzQXV0b1BhcnNhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICBpZiAoIXRvb2wuJGNhbGxiYWNrKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKCdUb29sIGdpdmVuIHRvIGAucnVuVG9vbHMoKWAgdGhhdCBkb2VzIG5vdCBoYXZlIGFuIGFzc29jaWF0ZWQgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgZnVuY3Rpb246IHRvb2wuJGNhbGxiYWNrLFxuICAgICAgICAgICAgbmFtZTogdG9vbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRvb2wuZnVuY3Rpb24uZGVzY3JpcHRpb24gfHwgJycsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB0b29sLmZ1bmN0aW9uLnBhcmFtZXRlcnMgYXMgYW55LFxuICAgICAgICAgICAgcGFyc2U6IHRvb2wuJHBhcnNlUmF3LFxuICAgICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b29sIGFzIGFueSBhcyBSdW5uYWJsZVRvb2xGdW5jdGlvbjxhbnk+O1xuICAgIH0pO1xuXG4gICAgY29uc3QgZnVuY3Rpb25zQnlOYW1lOiBSZWNvcmQ8c3RyaW5nLCBSdW5uYWJsZUZ1bmN0aW9uPGFueT4+ID0ge307XG4gICAgZm9yIChjb25zdCBmIG9mIGlucHV0VG9vbHMpIHtcbiAgICAgIGlmIChmLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZnVuY3Rpb25zQnlOYW1lW2YuZnVuY3Rpb24ubmFtZSB8fCBmLmZ1bmN0aW9uLmZ1bmN0aW9uLm5hbWVdID0gZi5mdW5jdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0b29sczogQ2hhdENvbXBsZXRpb25Ub29sW10gPVxuICAgICAgJ3Rvb2xzJyBpbiBwYXJhbXMgP1xuICAgICAgICBpbnB1dFRvb2xzLm1hcCgodCkgPT5cbiAgICAgICAgICB0LnR5cGUgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHQuZnVuY3Rpb24ubmFtZSB8fCB0LmZ1bmN0aW9uLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczogdC5mdW5jdGlvbi5wYXJhbWV0ZXJzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0LmZ1bmN0aW9uLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHN0cmljdDogdC5mdW5jdGlvbi5zdHJpY3QsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiAodCBhcyB1bmtub3duIGFzIENoYXRDb21wbGV0aW9uVG9vbCksXG4gICAgICAgIClcbiAgICAgIDogKHVuZGVmaW5lZCBhcyBhbnkpO1xuXG4gICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHBhcmFtcy5tZXNzYWdlcykge1xuICAgICAgdGhpcy5fYWRkTWVzc2FnZShtZXNzYWdlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhDaGF0Q29tcGxldGlvbnM7ICsraSkge1xuICAgICAgY29uc3QgY2hhdENvbXBsZXRpb246IENoYXRDb21wbGV0aW9uID0gYXdhaXQgdGhpcy5fY3JlYXRlQ2hhdENvbXBsZXRpb24oXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAge1xuICAgICAgICAgIC4uLnJlc3RQYXJhbXMsXG4gICAgICAgICAgdG9vbF9jaG9pY2UsXG4gICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgbWVzc2FnZXM6IFsuLi50aGlzLm1lc3NhZ2VzXSxcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICk7XG4gICAgICBjb25zdCBtZXNzYWdlID0gY2hhdENvbXBsZXRpb24uY2hvaWNlc1swXT8ubWVzc2FnZTtcbiAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYG1pc3NpbmcgbWVzc2FnZSBpbiBDaGF0Q29tcGxldGlvbiByZXNwb25zZWApO1xuICAgICAgfVxuICAgICAgaWYgKCFtZXNzYWdlLnRvb2xfY2FsbHM/Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgdG9vbF9jYWxsIG9mIG1lc3NhZ2UudG9vbF9jYWxscykge1xuICAgICAgICBpZiAodG9vbF9jYWxsLnR5cGUgIT09ICdmdW5jdGlvbicpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB0b29sX2NhbGxfaWQgPSB0b29sX2NhbGwuaWQ7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgYXJndW1lbnRzOiBhcmdzIH0gPSB0b29sX2NhbGwuZnVuY3Rpb247XG4gICAgICAgIGNvbnN0IGZuID0gZnVuY3Rpb25zQnlOYW1lW25hbWVdO1xuXG4gICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICBjb25zdCBjb250ZW50ID0gYEludmFsaWQgdG9vbF9jYWxsOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfS4gQXZhaWxhYmxlIG9wdGlvbnMgYXJlOiAke09iamVjdC5rZXlzKFxuICAgICAgICAgICAgZnVuY3Rpb25zQnlOYW1lLFxuICAgICAgICAgIClcbiAgICAgICAgICAgIC5tYXAoKG5hbWUpID0+IEpTT04uc3RyaW5naWZ5KG5hbWUpKVxuICAgICAgICAgICAgLmpvaW4oJywgJyl9LiBQbGVhc2UgdHJ5IGFnYWluYDtcblxuICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoeyByb2xlLCB0b29sX2NhbGxfaWQsIGNvbnRlbnQgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2luZ2xlRnVuY3Rpb25Ub0NhbGwgJiYgc2luZ2xlRnVuY3Rpb25Ub0NhbGwgIT09IG5hbWUpIHtcbiAgICAgICAgICBjb25zdCBjb250ZW50ID0gYEludmFsaWQgdG9vbF9jYWxsOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfS4gJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHNpbmdsZUZ1bmN0aW9uVG9DYWxsLFxuICAgICAgICAgICl9IHJlcXVlc3RlZC4gUGxlYXNlIHRyeSBhZ2FpbmA7XG5cbiAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgdG9vbF9jYWxsX2lkLCBjb250ZW50IH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBhcnNlZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWQgPSBpc1J1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2UoZm4pID8gYXdhaXQgZm4ucGFyc2UoYXJncykgOiBhcmdzO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGUsIHRvb2xfY2FsbF9pZCwgY29udGVudCB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaXQgY2FuJ3QgcnVsZSBvdXQgYG5ldmVyYCB0eXBlLlxuICAgICAgICBjb25zdCByYXdDb250ZW50ID0gYXdhaXQgZm4uZnVuY3Rpb24ocGFyc2VkLCB0aGlzKTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuI3N0cmluZ2lmeUZ1bmN0aW9uQ2FsbFJlc3VsdChyYXdDb250ZW50KTtcbiAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGUsIHRvb2xfY2FsbF9pZCwgY29udGVudCB9KTtcblxuICAgICAgICBpZiAoc2luZ2xlRnVuY3Rpb25Ub0NhbGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAjc3RyaW5naWZ5RnVuY3Rpb25DYWxsUmVzdWx0KHJhd0NvbnRlbnQ6IHVua25vd24pOiBzdHJpbmcge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgcmF3Q29udGVudCA9PT0gJ3N0cmluZycgPyByYXdDb250ZW50XG4gICAgICA6IHJhd0NvbnRlbnQgPT09IHVuZGVmaW5lZCA/ICd1bmRlZmluZWQnXG4gICAgICA6IEpTT04uc3RyaW5naWZ5KHJhd0NvbnRlbnQpXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMgZXh0ZW5kcyBCYXNlRXZlbnRzIHtcbiAgZnVuY3Rpb25DYWxsOiAoZnVuY3Rpb25DYWxsOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2UuRnVuY3Rpb25DYWxsKSA9PiB2b2lkO1xuICBtZXNzYWdlOiAobWVzc2FnZTogQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0pID0+IHZvaWQ7XG4gIGNoYXRDb21wbGV0aW9uOiAoY29tcGxldGlvbjogQ2hhdENvbXBsZXRpb24pID0+IHZvaWQ7XG4gIGZpbmFsQ29udGVudDogKGNvbnRlbnRTbmFwc2hvdDogc3RyaW5nKSA9PiB2b2lkO1xuICBmaW5hbE1lc3NhZ2U6IChtZXNzYWdlOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSkgPT4gdm9pZDtcbiAgZmluYWxDaGF0Q29tcGxldGlvbjogKGNvbXBsZXRpb246IENoYXRDb21wbGV0aW9uKSA9PiB2b2lkO1xuICBmaW5hbEZ1bmN0aW9uQ2FsbDogKGZ1bmN0aW9uQ2FsbDogQ2hhdENvbXBsZXRpb25NZXNzYWdlLkZ1bmN0aW9uQ2FsbCkgPT4gdm9pZDtcbiAgZnVuY3Rpb25DYWxsUmVzdWx0OiAoY29udGVudDogc3RyaW5nKSA9PiB2b2lkO1xuICBmaW5hbEZ1bmN0aW9uQ2FsbFJlc3VsdDogKGNvbnRlbnQ6IHN0cmluZykgPT4gdm9pZDtcbiAgdG90YWxVc2FnZTogKHVzYWdlOiBDb21wbGV0aW9uVXNhZ2UpID0+IHZvaWQ7XG59XG4iLCAiaW1wb3J0IHtcbiAgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSxcbiAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbn0gZnJvbSAnLi4vcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMnO1xuaW1wb3J0IHsgdHlwZSBSdW5uYWJsZUZ1bmN0aW9ucywgdHlwZSBCYXNlRnVuY3Rpb25zQXJncywgUnVubmFibGVUb29scyB9IGZyb20gJy4vUnVubmFibGVGdW5jdGlvbic7XG5pbXBvcnQge1xuICBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyLFxuICBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzLFxuICBSdW5uZXJPcHRpb25zLFxufSBmcm9tICcuL0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXInO1xuaW1wb3J0IHsgaXNBc3Npc3RhbnRNZXNzYWdlIH0gZnJvbSAnLi9jaGF0Q29tcGxldGlvblV0aWxzJztcbmltcG9ydCBPcGVuQUkgZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHsgQXV0b1BhcnNlYWJsZVRvb2wgfSBmcm9tICcuLi9saWIvcGFyc2VyJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cyBleHRlbmRzIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMge1xuICBjb250ZW50OiAoY29udGVudDogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3MgZXh0ZW5kcyBCYXNlRnVuY3Rpb25zQXJncz4gPSBPbWl0PFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgJ2Z1bmN0aW9ucydcbj4gJiB7XG4gIGZ1bmN0aW9uczogUnVubmFibGVGdW5jdGlvbnM8RnVuY3Rpb25zQXJncz47XG59O1xuXG5leHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvblRvb2xSdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncyBleHRlbmRzIEJhc2VGdW5jdGlvbnNBcmdzPiA9IE9taXQ8XG4gIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAndG9vbHMnXG4+ICYge1xuICB0b29sczogUnVubmFibGVUb29sczxGdW5jdGlvbnNBcmdzPiB8IEF1dG9QYXJzZWFibGVUb29sPGFueSwgdHJ1ZT5bXTtcbn07XG5cbmV4cG9ydCBjbGFzcyBDaGF0Q29tcGxldGlvblJ1bm5lcjxQYXJzZWRUID0gbnVsbD4gZXh0ZW5kcyBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyPFxuICBDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cyxcbiAgUGFyc2VkVFxuPiB7XG4gIC8qKiBAZGVwcmVjYXRlZCAtIHBsZWFzZSB1c2UgYHJ1blRvb2xzYCBpbnN0ZWFkLiAqL1xuICBzdGF0aWMgcnVuRnVuY3Rpb25zKFxuICAgIGNsaWVudDogT3BlbkFJLFxuICAgIHBhcmFtczogQ2hhdENvbXBsZXRpb25GdW5jdGlvblJ1bm5lclBhcmFtczxhbnlbXT4sXG4gICAgb3B0aW9ucz86IFJ1bm5lck9wdGlvbnMsXG4gICk6IENoYXRDb21wbGV0aW9uUnVubmVyPG51bGw+IHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgQ2hhdENvbXBsZXRpb25SdW5uZXIoKTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAncnVuRnVuY3Rpb25zJyB9LFxuICAgIH07XG4gICAgcnVubmVyLl9ydW4oKCkgPT4gcnVubmVyLl9ydW5GdW5jdGlvbnMoY2xpZW50LCBwYXJhbXMsIG9wdHMpKTtcbiAgICByZXR1cm4gcnVubmVyO1xuICB9XG5cbiAgc3RhdGljIHJ1blRvb2xzPFBhcnNlZFQ+KFxuICAgIGNsaWVudDogT3BlbkFJLFxuICAgIHBhcmFtczogQ2hhdENvbXBsZXRpb25Ub29sUnVubmVyUGFyYW1zPGFueVtdPixcbiAgICBvcHRpb25zPzogUnVubmVyT3B0aW9ucyxcbiAgKTogQ2hhdENvbXBsZXRpb25SdW5uZXI8UGFyc2VkVD4ge1xuICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBDaGF0Q29tcGxldGlvblJ1bm5lcjxQYXJzZWRUPigpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtSGVscGVyLU1ldGhvZCc6ICdydW5Ub29scycgfSxcbiAgICB9O1xuICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fcnVuVG9vbHMoY2xpZW50LCBwYXJhbXMsIG9wdHMpKTtcbiAgICByZXR1cm4gcnVubmVyO1xuICB9XG5cbiAgb3ZlcnJpZGUgX2FkZE1lc3NhZ2UoXG4gICAgdGhpczogQ2hhdENvbXBsZXRpb25SdW5uZXI8UGFyc2VkVD4sXG4gICAgbWVzc2FnZTogQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0sXG4gICAgZW1pdDogYm9vbGVhbiA9IHRydWUsXG4gICkge1xuICAgIHN1cGVyLl9hZGRNZXNzYWdlKG1lc3NhZ2UsIGVtaXQpO1xuICAgIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2UobWVzc2FnZSkgJiYgbWVzc2FnZS5jb250ZW50KSB7XG4gICAgICB0aGlzLl9lbWl0KCdjb250ZW50JywgbWVzc2FnZS5jb250ZW50IGFzIHN0cmluZyk7XG4gICAgfVxuICB9XG59XG4iLCAiY29uc3QgU1RSID0gMGIwMDAwMDAwMDE7XG5jb25zdCBOVU0gPSAwYjAwMDAwMDAxMDtcbmNvbnN0IEFSUiA9IDBiMDAwMDAwMTAwO1xuY29uc3QgT0JKID0gMGIwMDAwMDEwMDA7XG5jb25zdCBOVUxMID0gMGIwMDAwMTAwMDA7XG5jb25zdCBCT09MID0gMGIwMDAxMDAwMDA7XG5jb25zdCBOQU4gPSAwYjAwMTAwMDAwMDtcbmNvbnN0IElORklOSVRZID0gMGIwMTAwMDAwMDA7XG5jb25zdCBNSU5VU19JTkZJTklUWSA9IDBiMTAwMDAwMDAwO1xuXG5jb25zdCBJTkYgPSBJTkZJTklUWSB8IE1JTlVTX0lORklOSVRZO1xuY29uc3QgU1BFQ0lBTCA9IE5VTEwgfCBCT09MIHwgSU5GIHwgTkFOO1xuY29uc3QgQVRPTSA9IFNUUiB8IE5VTSB8IFNQRUNJQUw7XG5jb25zdCBDT0xMRUNUSU9OID0gQVJSIHwgT0JKO1xuY29uc3QgQUxMID0gQVRPTSB8IENPTExFQ1RJT047XG5cbmNvbnN0IEFsbG93ID0ge1xuICBTVFIsXG4gIE5VTSxcbiAgQVJSLFxuICBPQkosXG4gIE5VTEwsXG4gIEJPT0wsXG4gIE5BTixcbiAgSU5GSU5JVFksXG4gIE1JTlVTX0lORklOSVRZLFxuICBJTkYsXG4gIFNQRUNJQUwsXG4gIEFUT00sXG4gIENPTExFQ1RJT04sXG4gIEFMTCxcbn07XG5cbi8vIFRoZSBKU09OIHN0cmluZyBzZWdtZW50IHdhcyB1bmFibGUgdG8gYmUgcGFyc2VkIGNvbXBsZXRlbHlcbmNsYXNzIFBhcnRpYWxKU09OIGV4dGVuZHMgRXJyb3Ige31cblxuY2xhc3MgTWFsZm9ybWVkSlNPTiBleHRlbmRzIEVycm9yIHt9XG5cbi8qKlxuICogUGFyc2UgaW5jb21wbGV0ZSBKU09OXG4gKiBAcGFyYW0ge3N0cmluZ30ganNvblN0cmluZyBQYXJ0aWFsIEpTT04gdG8gYmUgcGFyc2VkXG4gKiBAcGFyYW0ge251bWJlcn0gYWxsb3dQYXJ0aWFsIFNwZWNpZnkgd2hhdCB0eXBlcyBhcmUgYWxsb3dlZCB0byBiZSBwYXJ0aWFsLCBzZWUge0BsaW5rIEFsbG93fSBmb3IgZGV0YWlsc1xuICogQHJldHVybnMgVGhlIHBhcnNlZCBKU09OXG4gKiBAdGhyb3dzIHtQYXJ0aWFsSlNPTn0gSWYgdGhlIEpTT04gaXMgaW5jb21wbGV0ZSAocmVsYXRlZCB0byB0aGUgYGFsbG93YCBwYXJhbWV0ZXIpXG4gKiBAdGhyb3dzIHtNYWxmb3JtZWRKU09OfSBJZiB0aGUgSlNPTiBpcyBtYWxmb3JtZWRcbiAqL1xuZnVuY3Rpb24gcGFyc2VKU09OKGpzb25TdHJpbmc6IHN0cmluZywgYWxsb3dQYXJ0aWFsOiBudW1iZXIgPSBBbGxvdy5BTEwpOiBhbnkge1xuICBpZiAodHlwZW9mIGpzb25TdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0aW5nIHN0ciwgZ290ICR7dHlwZW9mIGpzb25TdHJpbmd9YCk7XG4gIH1cbiAgaWYgKCFqc29uU3RyaW5nLnRyaW0oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHtqc29uU3RyaW5nfSBpcyBlbXB0eWApO1xuICB9XG4gIHJldHVybiBfcGFyc2VKU09OKGpzb25TdHJpbmcudHJpbSgpLCBhbGxvd1BhcnRpYWwpO1xufVxuXG5jb25zdCBfcGFyc2VKU09OID0gKGpzb25TdHJpbmc6IHN0cmluZywgYWxsb3c6IG51bWJlcikgPT4ge1xuICBjb25zdCBsZW5ndGggPSBqc29uU3RyaW5nLmxlbmd0aDtcbiAgbGV0IGluZGV4ID0gMDtcblxuICBjb25zdCBtYXJrUGFydGlhbEpTT04gPSAobXNnOiBzdHJpbmcpID0+IHtcbiAgICB0aHJvdyBuZXcgUGFydGlhbEpTT04oYCR7bXNnfSBhdCBwb3NpdGlvbiAke2luZGV4fWApO1xuICB9O1xuXG4gIGNvbnN0IHRocm93TWFsZm9ybWVkRXJyb3IgPSAobXNnOiBzdHJpbmcpID0+IHtcbiAgICB0aHJvdyBuZXcgTWFsZm9ybWVkSlNPTihgJHttc2d9IGF0IHBvc2l0aW9uICR7aW5kZXh9YCk7XG4gIH07XG5cbiAgY29uc3QgcGFyc2VBbnk6ICgpID0+IGFueSA9ICgpID0+IHtcbiAgICBza2lwQmxhbmsoKTtcbiAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSBtYXJrUGFydGlhbEpTT04oJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gICAgaWYgKGpzb25TdHJpbmdbaW5kZXhdID09PSAnXCInKSByZXR1cm4gcGFyc2VTdHIoKTtcbiAgICBpZiAoanNvblN0cmluZ1tpbmRleF0gPT09ICd7JykgcmV0dXJuIHBhcnNlT2JqKCk7XG4gICAgaWYgKGpzb25TdHJpbmdbaW5kZXhdID09PSAnWycpIHJldHVybiBwYXJzZUFycigpO1xuICAgIGlmIChcbiAgICAgIGpzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4LCBpbmRleCArIDQpID09PSAnbnVsbCcgfHxcbiAgICAgIChBbGxvdy5OVUxMICYgYWxsb3cgJiYgbGVuZ3RoIC0gaW5kZXggPCA0ICYmICdudWxsJy5zdGFydHNXaXRoKGpzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4KSkpXG4gICAgKSB7XG4gICAgICBpbmRleCArPSA0O1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGpzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4LCBpbmRleCArIDQpID09PSAndHJ1ZScgfHxcbiAgICAgIChBbGxvdy5CT09MICYgYWxsb3cgJiYgbGVuZ3RoIC0gaW5kZXggPCA0ICYmICd0cnVlJy5zdGFydHNXaXRoKGpzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4KSkpXG4gICAgKSB7XG4gICAgICBpbmRleCArPSA0O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGpzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4LCBpbmRleCArIDUpID09PSAnZmFsc2UnIHx8XG4gICAgICAoQWxsb3cuQk9PTCAmIGFsbG93ICYmIGxlbmd0aCAtIGluZGV4IDwgNSAmJiAnZmFsc2UnLnN0YXJ0c1dpdGgoanNvblN0cmluZy5zdWJzdHJpbmcoaW5kZXgpKSlcbiAgICApIHtcbiAgICAgIGluZGV4ICs9IDU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGpzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4LCBpbmRleCArIDgpID09PSAnSW5maW5pdHknIHx8XG4gICAgICAoQWxsb3cuSU5GSU5JVFkgJiBhbGxvdyAmJiBsZW5ndGggLSBpbmRleCA8IDggJiYgJ0luZmluaXR5Jy5zdGFydHNXaXRoKGpzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4KSkpXG4gICAgKSB7XG4gICAgICBpbmRleCArPSA4O1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCwgaW5kZXggKyA5KSA9PT0gJy1JbmZpbml0eScgfHxcbiAgICAgIChBbGxvdy5NSU5VU19JTkZJTklUWSAmIGFsbG93ICYmXG4gICAgICAgIDEgPCBsZW5ndGggLSBpbmRleCAmJlxuICAgICAgICBsZW5ndGggLSBpbmRleCA8IDkgJiZcbiAgICAgICAgJy1JbmZpbml0eScuc3RhcnRzV2l0aChqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCkpKVxuICAgICkge1xuICAgICAgaW5kZXggKz0gOTtcbiAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGpzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4LCBpbmRleCArIDMpID09PSAnTmFOJyB8fFxuICAgICAgKEFsbG93Lk5BTiAmIGFsbG93ICYmIGxlbmd0aCAtIGluZGV4IDwgMyAmJiAnTmFOJy5zdGFydHNXaXRoKGpzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4KSkpXG4gICAgKSB7XG4gICAgICBpbmRleCArPSAzO1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlTnVtKCk7XG4gIH07XG5cbiAgY29uc3QgcGFyc2VTdHI6ICgpID0+IHN0cmluZyA9ICgpID0+IHtcbiAgICBjb25zdCBzdGFydCA9IGluZGV4O1xuICAgIGxldCBlc2NhcGUgPSBmYWxzZTtcbiAgICBpbmRleCsrOyAvLyBza2lwIGluaXRpYWwgcXVvdGVcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGggJiYgKGpzb25TdHJpbmdbaW5kZXhdICE9PSAnXCInIHx8IChlc2NhcGUgJiYganNvblN0cmluZ1tpbmRleCAtIDFdID09PSAnXFxcXCcpKSkge1xuICAgICAgZXNjYXBlID0ganNvblN0cmluZ1tpbmRleF0gPT09ICdcXFxcJyA/ICFlc2NhcGUgOiBmYWxzZTtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIGlmIChqc29uU3RyaW5nLmNoYXJBdChpbmRleCkgPT0gJ1wiJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZy5zdWJzdHJpbmcoc3RhcnQsICsraW5kZXggLSBOdW1iZXIoZXNjYXBlKSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvd01hbGZvcm1lZEVycm9yKFN0cmluZyhlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBbGxvdy5TVFIgJiBhbGxvdykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGluZGV4IC0gTnVtYmVyKGVzY2FwZSkpICsgJ1wiJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFN5bnRheEVycm9yOiBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uU3RyaW5nLnN1YnN0cmluZyhzdGFydCwganNvblN0cmluZy5sYXN0SW5kZXhPZignXFxcXCcpKSArICdcIicpO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXJrUGFydGlhbEpTT04oJ1VudGVybWluYXRlZCBzdHJpbmcgbGl0ZXJhbCcpO1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlT2JqID0gKCkgPT4ge1xuICAgIGluZGV4Kys7IC8vIHNraXAgaW5pdGlhbCBicmFjZVxuICAgIHNraXBCbGFuaygpO1xuICAgIGNvbnN0IG9iajogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAoanNvblN0cmluZ1tpbmRleF0gIT09ICd9Jykge1xuICAgICAgICBza2lwQmxhbmsoKTtcbiAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCAmJiBBbGxvdy5PQkogJiBhbGxvdykgcmV0dXJuIG9iajtcbiAgICAgICAgY29uc3Qga2V5ID0gcGFyc2VTdHIoKTtcbiAgICAgICAgc2tpcEJsYW5rKCk7XG4gICAgICAgIGluZGV4Kys7IC8vIHNraXAgY29sb25cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlQW55KCk7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlLCB3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKEFsbG93Lk9CSiAmIGFsbG93KSByZXR1cm4gb2JqO1xuICAgICAgICAgIGVsc2UgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBza2lwQmxhbmsoKTtcbiAgICAgICAgaWYgKGpzb25TdHJpbmdbaW5kZXhdID09PSAnLCcpIGluZGV4Kys7IC8vIHNraXAgY29tbWFcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoQWxsb3cuT0JKICYgYWxsb3cpIHJldHVybiBvYmo7XG4gICAgICBlbHNlIG1hcmtQYXJ0aWFsSlNPTihcIkV4cGVjdGVkICd9JyBhdCBlbmQgb2Ygb2JqZWN0XCIpO1xuICAgIH1cbiAgICBpbmRleCsrOyAvLyBza2lwIGZpbmFsIGJyYWNlXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICBjb25zdCBwYXJzZUFyciA9ICgpID0+IHtcbiAgICBpbmRleCsrOyAvLyBza2lwIGluaXRpYWwgYnJhY2tldFxuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAoanNvblN0cmluZ1tpbmRleF0gIT09ICddJykge1xuICAgICAgICBhcnIucHVzaChwYXJzZUFueSgpKTtcbiAgICAgICAgc2tpcEJsYW5rKCk7XG4gICAgICAgIGlmIChqc29uU3RyaW5nW2luZGV4XSA9PT0gJywnKSB7XG4gICAgICAgICAgaW5kZXgrKzsgLy8gc2tpcCBjb21tYVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKEFsbG93LkFSUiAmIGFsbG93KSB7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9XG4gICAgICBtYXJrUGFydGlhbEpTT04oXCJFeHBlY3RlZCAnXScgYXQgZW5kIG9mIGFycmF5XCIpO1xuICAgIH1cbiAgICBpbmRleCsrOyAvLyBza2lwIGZpbmFsIGJyYWNrZXRcbiAgICByZXR1cm4gYXJyO1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlTnVtID0gKCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgaWYgKGpzb25TdHJpbmcgPT09ICctJyAmJiBBbGxvdy5OVU0gJiBhbGxvdykgbWFya1BhcnRpYWxKU09OKFwiTm90IHN1cmUgd2hhdCAnLScgaXNcIik7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uU3RyaW5nKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKEFsbG93Lk5VTSAmIGFsbG93KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICgnLicgPT09IGpzb25TdHJpbmdbanNvblN0cmluZy5sZW5ndGggLSAxXSlcbiAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZy5zdWJzdHJpbmcoMCwganNvblN0cmluZy5sYXN0SW5kZXhPZignLicpKSk7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uU3RyaW5nLnN1YnN0cmluZygwLCBqc29uU3RyaW5nLmxhc3RJbmRleE9mKCdlJykpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIHRocm93TWFsZm9ybWVkRXJyb3IoU3RyaW5nKGUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdGFydCA9IGluZGV4O1xuXG4gICAgaWYgKGpzb25TdHJpbmdbaW5kZXhdID09PSAnLScpIGluZGV4Kys7XG4gICAgd2hpbGUgKGpzb25TdHJpbmdbaW5kZXhdICYmICEnLF19Jy5pbmNsdWRlcyhqc29uU3RyaW5nW2luZGV4XSEpKSBpbmRleCsrO1xuXG4gICAgaWYgKGluZGV4ID09IGxlbmd0aCAmJiAhKEFsbG93Lk5VTSAmIGFsbG93KSkgbWFya1BhcnRpYWxKU09OKCdVbnRlcm1pbmF0ZWQgbnVtYmVyIGxpdGVyYWwnKTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgaW5kZXgpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoanNvblN0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGluZGV4KSA9PT0gJy0nICYmIEFsbG93Lk5VTSAmIGFsbG93KVxuICAgICAgICBtYXJrUGFydGlhbEpTT04oXCJOb3Qgc3VyZSB3aGF0ICctJyBpc1wiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBqc29uU3RyaW5nLmxhc3RJbmRleE9mKCdlJykpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3dNYWxmb3JtZWRFcnJvcihTdHJpbmcoZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBza2lwQmxhbmsgPSAoKSA9PiB7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoICYmICcgXFxuXFxyXFx0Jy5pbmNsdWRlcyhqc29uU3RyaW5nW2luZGV4XSEpKSB7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gcGFyc2VBbnkoKTtcbn07XG5cbi8vIHVzaW5nIHRoaXMgZnVuY3Rpb24gd2l0aCBtYWxmb3JtZWQgSlNPTiBpcyB1bmRlZmluZWQgYmVoYXZpb3JcbmNvbnN0IHBhcnRpYWxQYXJzZSA9IChpbnB1dDogc3RyaW5nKSA9PiBwYXJzZUpTT04oaW5wdXQsIEFsbG93LkFMTCBeIEFsbG93Lk5VTSk7XG5cbmV4cG9ydCB7IHBhcnRpYWxQYXJzZSwgUGFydGlhbEpTT04sIE1hbGZvcm1lZEpTT04gfTtcbiIsICJpbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0IHtcbiAgT3BlbkFJRXJyb3IsXG4gIEFQSVVzZXJBYm9ydEVycm9yLFxuICBMZW5ndGhGaW5pc2hSZWFzb25FcnJvcixcbiAgQ29udGVudEZpbHRlckZpbmlzaFJlYXNvbkVycm9yLFxufSBmcm9tICcuLi9lcnJvcic7XG5pbXBvcnQge1xuICBDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYixcbiAgdHlwZSBDaGF0Q29tcGxldGlvbixcbiAgdHlwZSBDaGF0Q29tcGxldGlvbkNodW5rLFxuICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSxcbn0gZnJvbSAnLi4vcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMnO1xuaW1wb3J0IHtcbiAgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcixcbiAgdHlwZSBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzLFxufSBmcm9tICcuL0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXInO1xuaW1wb3J0IHsgdHlwZSBSZWFkYWJsZVN0cmVhbSB9IGZyb20gJy4uL19zaGltcy9pbmRleCc7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tICcuLi9zdHJlYW1pbmcnO1xuaW1wb3J0IE9wZW5BSSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyBQYXJzZWRDaGF0Q29tcGxldGlvbiB9IGZyb20gJy4uL3Jlc291cmNlcy9iZXRhL2NoYXQvY29tcGxldGlvbnMnO1xuaW1wb3J0IHtcbiAgQXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0LFxuICBoYXNBdXRvUGFyc2VhYmxlSW5wdXQsXG4gIGlzQXV0b1BhcnNhYmxlUmVzcG9uc2VGb3JtYXQsXG4gIGlzQXV0b1BhcnNhYmxlVG9vbCxcbiAgbWF5YmVQYXJzZUNoYXRDb21wbGV0aW9uLFxuICBzaG91bGRQYXJzZVRvb2xDYWxsLFxufSBmcm9tICcuLi9saWIvcGFyc2VyJztcbmltcG9ydCB7IHBhcnRpYWxQYXJzZSB9IGZyb20gJy4uL192ZW5kb3IvcGFydGlhbC1qc29uLXBhcnNlci9wYXJzZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRlbnREZWx0YUV2ZW50IHtcbiAgZGVsdGE6IHN0cmluZztcbiAgc25hcHNob3Q6IHN0cmluZztcbiAgcGFyc2VkOiB1bmtub3duIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb250ZW50RG9uZUV2ZW50PFBhcnNlZFQgPSBudWxsPiB7XG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgcGFyc2VkOiBQYXJzZWRUIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWZ1c2FsRGVsdGFFdmVudCB7XG4gIGRlbHRhOiBzdHJpbmc7XG4gIHNuYXBzaG90OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVmdXNhbERvbmVFdmVudCB7XG4gIHJlZnVzYWw6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvblRvb2xDYWxsQXJndW1lbnRzRGVsdGFFdmVudCB7XG4gIG5hbWU6IHN0cmluZztcblxuICBpbmRleDogbnVtYmVyO1xuXG4gIGFyZ3VtZW50czogc3RyaW5nO1xuXG4gIHBhcnNlZF9hcmd1bWVudHM6IHVua25vd247XG5cbiAgYXJndW1lbnRzX2RlbHRhOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25Ub29sQ2FsbEFyZ3VtZW50c0RvbmVFdmVudCB7XG4gIG5hbWU6IHN0cmluZztcblxuICBpbmRleDogbnVtYmVyO1xuXG4gIGFyZ3VtZW50czogc3RyaW5nO1xuXG4gIHBhcnNlZF9hcmd1bWVudHM6IHVua25vd247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9nUHJvYnNDb250ZW50RGVsdGFFdmVudCB7XG4gIGNvbnRlbnQ6IEFycmF5PENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iPjtcbiAgc25hcHNob3Q6IEFycmF5PENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dQcm9ic0NvbnRlbnREb25lRXZlbnQge1xuICBjb250ZW50OiBBcnJheTxDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9nUHJvYnNSZWZ1c2FsRGVsdGFFdmVudCB7XG4gIHJlZnVzYWw6IEFycmF5PENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iPjtcbiAgc25hcHNob3Q6IEFycmF5PENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dQcm9ic1JlZnVzYWxEb25lRXZlbnQge1xuICByZWZ1c2FsOiBBcnJheTxDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25TdHJlYW1FdmVudHM8UGFyc2VkVCA9IG51bGw+IGV4dGVuZHMgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cyB7XG4gIGNvbnRlbnQ6IChjb250ZW50RGVsdGE6IHN0cmluZywgY29udGVudFNuYXBzaG90OiBzdHJpbmcpID0+IHZvaWQ7XG4gIGNodW5rOiAoY2h1bms6IENoYXRDb21wbGV0aW9uQ2h1bmssIHNuYXBzaG90OiBDaGF0Q29tcGxldGlvblNuYXBzaG90KSA9PiB2b2lkO1xuXG4gICdjb250ZW50LmRlbHRhJzogKHByb3BzOiBDb250ZW50RGVsdGFFdmVudCkgPT4gdm9pZDtcbiAgJ2NvbnRlbnQuZG9uZSc6IChwcm9wczogQ29udGVudERvbmVFdmVudDxQYXJzZWRUPikgPT4gdm9pZDtcblxuICAncmVmdXNhbC5kZWx0YSc6IChwcm9wczogUmVmdXNhbERlbHRhRXZlbnQpID0+IHZvaWQ7XG4gICdyZWZ1c2FsLmRvbmUnOiAocHJvcHM6IFJlZnVzYWxEb25lRXZlbnQpID0+IHZvaWQ7XG5cbiAgJ3Rvb2xfY2FsbHMuZnVuY3Rpb24uYXJndW1lbnRzLmRlbHRhJzogKHByb3BzOiBGdW5jdGlvblRvb2xDYWxsQXJndW1lbnRzRGVsdGFFdmVudCkgPT4gdm9pZDtcbiAgJ3Rvb2xfY2FsbHMuZnVuY3Rpb24uYXJndW1lbnRzLmRvbmUnOiAocHJvcHM6IEZ1bmN0aW9uVG9vbENhbGxBcmd1bWVudHNEb25lRXZlbnQpID0+IHZvaWQ7XG5cbiAgJ2xvZ3Byb2JzLmNvbnRlbnQuZGVsdGEnOiAocHJvcHM6IExvZ1Byb2JzQ29udGVudERlbHRhRXZlbnQpID0+IHZvaWQ7XG4gICdsb2dwcm9icy5jb250ZW50LmRvbmUnOiAocHJvcHM6IExvZ1Byb2JzQ29udGVudERvbmVFdmVudCkgPT4gdm9pZDtcblxuICAnbG9ncHJvYnMucmVmdXNhbC5kZWx0YSc6IChwcm9wczogTG9nUHJvYnNSZWZ1c2FsRGVsdGFFdmVudCkgPT4gdm9pZDtcbiAgJ2xvZ3Byb2JzLnJlZnVzYWwuZG9uZSc6IChwcm9wczogTG9nUHJvYnNSZWZ1c2FsRG9uZUV2ZW50KSA9PiB2b2lkO1xufVxuXG5leHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvblN0cmVhbVBhcmFtcyA9IE9taXQ8Q2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlLCAnc3RyZWFtJz4gJiB7XG4gIHN0cmVhbT86IHRydWU7XG59O1xuXG5pbnRlcmZhY2UgQ2hvaWNlRXZlbnRTdGF0ZSB7XG4gIGNvbnRlbnRfZG9uZTogYm9vbGVhbjtcbiAgcmVmdXNhbF9kb25lOiBib29sZWFuO1xuICBsb2dwcm9ic19jb250ZW50X2RvbmU6IGJvb2xlYW47XG4gIGxvZ3Byb2JzX3JlZnVzYWxfZG9uZTogYm9vbGVhbjtcbiAgY3VycmVudF90b29sX2NhbGxfaW5kZXg6IG51bWJlciB8IG51bGw7XG4gIGRvbmVfdG9vbF9jYWxsczogU2V0PG51bWJlcj47XG59XG5cbmV4cG9ydCBjbGFzcyBDaGF0Q29tcGxldGlvblN0cmVhbTxQYXJzZWRUID0gbnVsbD5cbiAgZXh0ZW5kcyBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyPENoYXRDb21wbGV0aW9uU3RyZWFtRXZlbnRzPFBhcnNlZFQ+LCBQYXJzZWRUPlxuICBpbXBsZW1lbnRzIEFzeW5jSXRlcmFibGU8Q2hhdENvbXBsZXRpb25DaHVuaz5cbntcbiAgI3BhcmFtczogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMgfCBudWxsO1xuICAjY2hvaWNlRXZlbnRTdGF0ZXM6IENob2ljZUV2ZW50U3RhdGVbXTtcbiAgI2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90OiBDaGF0Q29tcGxldGlvblNuYXBzaG90IHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMgfCBudWxsKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNwYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy4jY2hvaWNlRXZlbnRTdGF0ZXMgPSBbXTtcbiAgfVxuXG4gIGdldCBjdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdCgpOiBDaGF0Q29tcGxldGlvblNuYXBzaG90IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3Q7XG4gIH1cblxuICAvKipcbiAgICogSW50ZW5kZWQgZm9yIHVzZSBvbiB0aGUgZnJvbnRlbmQsIGNvbnN1bWluZyBhIHN0cmVhbSBwcm9kdWNlZCB3aXRoXG4gICAqIGAudG9SZWFkYWJsZVN0cmVhbSgpYCBvbiB0aGUgYmFja2VuZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IG1lc3NhZ2VzIHNlbnQgdG8gdGhlIG1vZGVsIGRvIG5vdCBhcHBlYXIgaW4gYC5vbignbWVzc2FnZScpYFxuICAgKiBpbiB0aGlzIGNvbnRleHQuXG4gICAqL1xuICBzdGF0aWMgZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pOiBDaGF0Q29tcGxldGlvblN0cmVhbTxudWxsPiB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IENoYXRDb21wbGV0aW9uU3RyZWFtKG51bGwpO1xuICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuICAgIHJldHVybiBydW5uZXI7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlQ2hhdENvbXBsZXRpb248UGFyc2VkVD4oXG4gICAgY2xpZW50OiBPcGVuQUksXG4gICAgcGFyYW1zOiBDaGF0Q29tcGxldGlvblN0cmVhbVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ2hhdENvbXBsZXRpb25TdHJlYW08UGFyc2VkVD4ge1xuICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBDaGF0Q29tcGxldGlvblN0cmVhbTxQYXJzZWRUPihwYXJhbXMgYXMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcpO1xuICAgIHJ1bm5lci5fcnVuKCgpID0+XG4gICAgICBydW5uZXIuX3J1bkNoYXRDb21wbGV0aW9uKFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHsgLi4ucGFyYW1zLCBzdHJlYW06IHRydWUgfSxcbiAgICAgICAgeyAuLi5vcHRpb25zLCBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3N0cmVhbScgfSB9LFxuICAgICAgKSxcbiAgICApO1xuICAgIHJldHVybiBydW5uZXI7XG4gIH1cblxuICAjYmVnaW5SZXF1ZXN0KCkge1xuICAgIGlmICh0aGlzLmVuZGVkKSByZXR1cm47XG4gICAgdGhpcy4jY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3QgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAjZ2V0Q2hvaWNlRXZlbnRTdGF0ZShjaG9pY2U6IENoYXRDb21wbGV0aW9uU25hcHNob3QuQ2hvaWNlKTogQ2hvaWNlRXZlbnRTdGF0ZSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy4jY2hvaWNlRXZlbnRTdGF0ZXNbY2hvaWNlLmluZGV4XTtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBzdGF0ZSA9IHtcbiAgICAgIGNvbnRlbnRfZG9uZTogZmFsc2UsXG4gICAgICByZWZ1c2FsX2RvbmU6IGZhbHNlLFxuICAgICAgbG9ncHJvYnNfY29udGVudF9kb25lOiBmYWxzZSxcbiAgICAgIGxvZ3Byb2JzX3JlZnVzYWxfZG9uZTogZmFsc2UsXG4gICAgICBkb25lX3Rvb2xfY2FsbHM6IG5ldyBTZXQoKSxcbiAgICAgIGN1cnJlbnRfdG9vbF9jYWxsX2luZGV4OiBudWxsLFxuICAgIH07XG4gICAgdGhpcy4jY2hvaWNlRXZlbnRTdGF0ZXNbY2hvaWNlLmluZGV4XSA9IHN0YXRlO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gICNhZGRDaHVuayh0aGlzOiBDaGF0Q29tcGxldGlvblN0cmVhbTxQYXJzZWRUPiwgY2h1bms6IENoYXRDb21wbGV0aW9uQ2h1bmspIHtcbiAgICBpZiAodGhpcy5lbmRlZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgY29tcGxldGlvbiA9IHRoaXMuI2FjY3VtdWxhdGVDaGF0Q29tcGxldGlvbihjaHVuayk7XG4gICAgdGhpcy5fZW1pdCgnY2h1bmsnLCBjaHVuaywgY29tcGxldGlvbik7XG5cbiAgICBmb3IgKGNvbnN0IGNob2ljZSBvZiBjaHVuay5jaG9pY2VzKSB7XG4gICAgICBjb25zdCBjaG9pY2VTbmFwc2hvdCA9IGNvbXBsZXRpb24uY2hvaWNlc1tjaG9pY2UuaW5kZXhdITtcblxuICAgICAgaWYgKFxuICAgICAgICBjaG9pY2UuZGVsdGEuY29udGVudCAhPSBudWxsICYmXG4gICAgICAgIGNob2ljZVNuYXBzaG90Lm1lc3NhZ2U/LnJvbGUgPT09ICdhc3Npc3RhbnQnICYmXG4gICAgICAgIGNob2ljZVNuYXBzaG90Lm1lc3NhZ2U/LmNvbnRlbnRcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9lbWl0KCdjb250ZW50JywgY2hvaWNlLmRlbHRhLmNvbnRlbnQsIGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UuY29udGVudCk7XG4gICAgICAgIHRoaXMuX2VtaXQoJ2NvbnRlbnQuZGVsdGEnLCB7XG4gICAgICAgICAgZGVsdGE6IGNob2ljZS5kZWx0YS5jb250ZW50LFxuICAgICAgICAgIHNuYXBzaG90OiBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgICAgcGFyc2VkOiBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLnBhcnNlZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgY2hvaWNlLmRlbHRhLnJlZnVzYWwgIT0gbnVsbCAmJlxuICAgICAgICBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlPy5yb2xlID09PSAnYXNzaXN0YW50JyAmJlxuICAgICAgICBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlPy5yZWZ1c2FsXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fZW1pdCgncmVmdXNhbC5kZWx0YScsIHtcbiAgICAgICAgICBkZWx0YTogY2hvaWNlLmRlbHRhLnJlZnVzYWwsXG4gICAgICAgICAgc25hcHNob3Q6IGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UucmVmdXNhbCxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaG9pY2UubG9ncHJvYnM/LmNvbnRlbnQgIT0gbnVsbCAmJiBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlPy5yb2xlID09PSAnYXNzaXN0YW50Jykge1xuICAgICAgICB0aGlzLl9lbWl0KCdsb2dwcm9icy5jb250ZW50LmRlbHRhJywge1xuICAgICAgICAgIGNvbnRlbnQ6IGNob2ljZS5sb2dwcm9icz8uY29udGVudCxcbiAgICAgICAgICBzbmFwc2hvdDogY2hvaWNlU25hcHNob3QubG9ncHJvYnM/LmNvbnRlbnQgPz8gW10sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hvaWNlLmxvZ3Byb2JzPy5yZWZ1c2FsICE9IG51bGwgJiYgY2hvaWNlU25hcHNob3QubWVzc2FnZT8ucm9sZSA9PT0gJ2Fzc2lzdGFudCcpIHtcbiAgICAgICAgdGhpcy5fZW1pdCgnbG9ncHJvYnMucmVmdXNhbC5kZWx0YScsIHtcbiAgICAgICAgICByZWZ1c2FsOiBjaG9pY2UubG9ncHJvYnM/LnJlZnVzYWwsXG4gICAgICAgICAgc25hcHNob3Q6IGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzPy5yZWZ1c2FsID8/IFtdLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLiNnZXRDaG9pY2VFdmVudFN0YXRlKGNob2ljZVNuYXBzaG90KTtcblxuICAgICAgaWYgKGNob2ljZVNuYXBzaG90LmZpbmlzaF9yZWFzb24pIHtcbiAgICAgICAgdGhpcy4jZW1pdENvbnRlbnREb25lRXZlbnRzKGNob2ljZVNuYXBzaG90KTtcblxuICAgICAgICBpZiAoc3RhdGUuY3VycmVudF90b29sX2NhbGxfaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuI2VtaXRUb29sQ2FsbERvbmVFdmVudChjaG9pY2VTbmFwc2hvdCwgc3RhdGUuY3VycmVudF90b29sX2NhbGxfaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgY2hvaWNlLmRlbHRhLnRvb2xfY2FsbHMgPz8gW10pIHtcbiAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRfdG9vbF9jYWxsX2luZGV4ICE9PSB0b29sQ2FsbC5pbmRleCkge1xuICAgICAgICAgIHRoaXMuI2VtaXRDb250ZW50RG9uZUV2ZW50cyhjaG9pY2VTbmFwc2hvdCk7XG5cbiAgICAgICAgICAvLyBuZXcgdG9vbCBjYWxsIHN0YXJ0ZWQsIHRoZSBwcmV2aW91cyBvbmUgaXMgZG9uZVxuICAgICAgICAgIGlmIChzdGF0ZS5jdXJyZW50X3Rvb2xfY2FsbF9pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNlbWl0VG9vbENhbGxEb25lRXZlbnQoY2hvaWNlU25hcHNob3QsIHN0YXRlLmN1cnJlbnRfdG9vbF9jYWxsX2luZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5jdXJyZW50X3Rvb2xfY2FsbF9pbmRleCA9IHRvb2xDYWxsLmluZGV4O1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsRGVsdGEgb2YgY2hvaWNlLmRlbHRhLnRvb2xfY2FsbHMgPz8gW10pIHtcbiAgICAgICAgY29uc3QgdG9vbENhbGxTbmFwc2hvdCA9IGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UudG9vbF9jYWxscz8uW3Rvb2xDYWxsRGVsdGEuaW5kZXhdO1xuICAgICAgICBpZiAoIXRvb2xDYWxsU25hcHNob3Q/LnR5cGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b29sQ2FsbFNuYXBzaG90Py50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdCgndG9vbF9jYWxscy5mdW5jdGlvbi5hcmd1bWVudHMuZGVsdGEnLCB7XG4gICAgICAgICAgICBuYW1lOiB0b29sQ2FsbFNuYXBzaG90LmZ1bmN0aW9uPy5uYW1lLFxuICAgICAgICAgICAgaW5kZXg6IHRvb2xDYWxsRGVsdGEuaW5kZXgsXG4gICAgICAgICAgICBhcmd1bWVudHM6IHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgcGFyc2VkX2FyZ3VtZW50czogdG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbi5wYXJzZWRfYXJndW1lbnRzLFxuICAgICAgICAgICAgYXJndW1lbnRzX2RlbHRhOiB0b29sQ2FsbERlbHRhLmZ1bmN0aW9uPy5hcmd1bWVudHMgPz8gJycsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzZXJ0TmV2ZXIodG9vbENhbGxTbmFwc2hvdD8udHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAjZW1pdFRvb2xDYWxsRG9uZUV2ZW50KGNob2ljZVNuYXBzaG90OiBDaGF0Q29tcGxldGlvblNuYXBzaG90LkNob2ljZSwgdG9vbENhbGxJbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLiNnZXRDaG9pY2VFdmVudFN0YXRlKGNob2ljZVNuYXBzaG90KTtcbiAgICBpZiAoc3RhdGUuZG9uZV90b29sX2NhbGxzLmhhcyh0b29sQ2FsbEluZGV4KSkge1xuICAgICAgLy8gd2UndmUgYWxyZWFkeSBmaXJlZCB0aGUgZG9uZSBldmVudFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRvb2xDYWxsU25hcHNob3QgPSBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLnRvb2xfY2FsbHM/Llt0b29sQ2FsbEluZGV4XTtcbiAgICBpZiAoIXRvb2xDYWxsU25hcHNob3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gdG9vbCBjYWxsIHNuYXBzaG90Jyk7XG4gICAgfVxuICAgIGlmICghdG9vbENhbGxTbmFwc2hvdC50eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rvb2wgY2FsbCBzbmFwc2hvdCBtaXNzaW5nIGB0eXBlYCcpO1xuICAgIH1cblxuICAgIGlmICh0b29sQ2FsbFNuYXBzaG90LnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IGlucHV0VG9vbCA9IHRoaXMuI3BhcmFtcz8udG9vbHM/LmZpbmQoXG4gICAgICAgICh0b29sKSA9PiB0b29sLnR5cGUgPT09ICdmdW5jdGlvbicgJiYgdG9vbC5mdW5jdGlvbi5uYW1lID09PSB0b29sQ2FsbFNuYXBzaG90LmZ1bmN0aW9uLm5hbWUsXG4gICAgICApO1xuXG4gICAgICB0aGlzLl9lbWl0KCd0b29sX2NhbGxzLmZ1bmN0aW9uLmFyZ3VtZW50cy5kb25lJywge1xuICAgICAgICBuYW1lOiB0b29sQ2FsbFNuYXBzaG90LmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgIGluZGV4OiB0b29sQ2FsbEluZGV4LFxuICAgICAgICBhcmd1bWVudHM6IHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICBwYXJzZWRfYXJndW1lbnRzOlxuICAgICAgICAgIGlzQXV0b1BhcnNhYmxlVG9vbChpbnB1dFRvb2wpID8gaW5wdXRUb29sLiRwYXJzZVJhdyh0b29sQ2FsbFNuYXBzaG90LmZ1bmN0aW9uLmFyZ3VtZW50cylcbiAgICAgICAgICA6IGlucHV0VG9vbD8uZnVuY3Rpb24uc3RyaWN0ID8gSlNPTi5wYXJzZSh0b29sQ2FsbFNuYXBzaG90LmZ1bmN0aW9uLmFyZ3VtZW50cylcbiAgICAgICAgICA6IG51bGwsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0TmV2ZXIodG9vbENhbGxTbmFwc2hvdC50eXBlKTtcbiAgICB9XG4gIH1cblxuICAjZW1pdENvbnRlbnREb25lRXZlbnRzKGNob2ljZVNuYXBzaG90OiBDaGF0Q29tcGxldGlvblNuYXBzaG90LkNob2ljZSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jZ2V0Q2hvaWNlRXZlbnRTdGF0ZShjaG9pY2VTbmFwc2hvdCk7XG5cbiAgICBpZiAoY2hvaWNlU25hcHNob3QubWVzc2FnZS5jb250ZW50ICYmICFzdGF0ZS5jb250ZW50X2RvbmUpIHtcbiAgICAgIHN0YXRlLmNvbnRlbnRfZG9uZSA9IHRydWU7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlRm9ybWF0ID0gdGhpcy4jZ2V0QXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0KCk7XG5cbiAgICAgIHRoaXMuX2VtaXQoJ2NvbnRlbnQuZG9uZScsIHtcbiAgICAgICAgY29udGVudDogY2hvaWNlU25hcHNob3QubWVzc2FnZS5jb250ZW50LFxuICAgICAgICBwYXJzZWQ6IHJlc3BvbnNlRm9ybWF0ID8gcmVzcG9uc2VGb3JtYXQuJHBhcnNlUmF3KGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UuY29udGVudCkgOiAobnVsbCBhcyBhbnkpLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UucmVmdXNhbCAmJiAhc3RhdGUucmVmdXNhbF9kb25lKSB7XG4gICAgICBzdGF0ZS5yZWZ1c2FsX2RvbmUgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9lbWl0KCdyZWZ1c2FsLmRvbmUnLCB7IHJlZnVzYWw6IGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UucmVmdXNhbCB9KTtcbiAgICB9XG5cbiAgICBpZiAoY2hvaWNlU25hcHNob3QubG9ncHJvYnM/LmNvbnRlbnQgJiYgIXN0YXRlLmxvZ3Byb2JzX2NvbnRlbnRfZG9uZSkge1xuICAgICAgc3RhdGUubG9ncHJvYnNfY29udGVudF9kb25lID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fZW1pdCgnbG9ncHJvYnMuY29udGVudC5kb25lJywgeyBjb250ZW50OiBjaG9pY2VTbmFwc2hvdC5sb2dwcm9icy5jb250ZW50IH0pO1xuICAgIH1cblxuICAgIGlmIChjaG9pY2VTbmFwc2hvdC5sb2dwcm9icz8ucmVmdXNhbCAmJiAhc3RhdGUubG9ncHJvYnNfcmVmdXNhbF9kb25lKSB7XG4gICAgICBzdGF0ZS5sb2dwcm9ic19yZWZ1c2FsX2RvbmUgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9lbWl0KCdsb2dwcm9icy5yZWZ1c2FsLmRvbmUnLCB7IHJlZnVzYWw6IGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzLnJlZnVzYWwgfSk7XG4gICAgfVxuICB9XG5cbiAgI2VuZFJlcXVlc3QoKTogUGFyc2VkQ2hhdENvbXBsZXRpb248UGFyc2VkVD4ge1xuICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYHN0cmVhbSBoYXMgZW5kZWQsIHRoaXMgc2hvdWxkbid0IGhhcHBlbmApO1xuICAgIH1cbiAgICBjb25zdCBzbmFwc2hvdCA9IHRoaXMuI2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90O1xuICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgcmVxdWVzdCBlbmRlZCB3aXRob3V0IHNlbmRpbmcgYW55IGNodW5rc2ApO1xuICAgIH1cbiAgICB0aGlzLiNjdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiNjaG9pY2VFdmVudFN0YXRlcyA9IFtdO1xuICAgIHJldHVybiBmaW5hbGl6ZUNoYXRDb21wbGV0aW9uKHNuYXBzaG90LCB0aGlzLiNwYXJhbXMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGFzeW5jIF9jcmVhdGVDaGF0Q29tcGxldGlvbihcbiAgICBjbGllbnQ6IE9wZW5BSSxcbiAgICBwYXJhbXM6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBQcm9taXNlPFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+PiB7XG4gICAgc3VwZXIuX2NyZWF0ZUNoYXRDb21wbGV0aW9uO1xuICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbDtcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gdGhpcy5jb250cm9sbGVyLmFib3J0KCkpO1xuICAgIH1cbiAgICB0aGlzLiNiZWdpblJlcXVlc3QoKTtcblxuICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGNsaWVudC5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZShcbiAgICAgIHsgLi4ucGFyYW1zLCBzdHJlYW06IHRydWUgfSxcbiAgICAgIHsgLi4ub3B0aW9ucywgc2lnbmFsOiB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsIH0sXG4gICAgKTtcbiAgICB0aGlzLl9jb25uZWN0ZWQoKTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgdGhpcy4jYWRkQ2h1bmsoY2h1bmspO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLmNvbnRyb2xsZXIuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoYXRDb21wbGV0aW9uKHRoaXMuI2VuZFJlcXVlc3QoKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX2Zyb21SZWFkYWJsZVN0cmVhbShcbiAgICByZWFkYWJsZVN0cmVhbTogUmVhZGFibGVTdHJlYW0sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IFByb21pc2U8Q2hhdENvbXBsZXRpb24+IHtcbiAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXMuY29udHJvbGxlci5hYm9ydCgpKTtcbiAgICB9XG4gICAgdGhpcy4jYmVnaW5SZXF1ZXN0KCk7XG4gICAgdGhpcy5fY29ubmVjdGVkKCk7XG4gICAgY29uc3Qgc3RyZWFtID0gU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbTxDaGF0Q29tcGxldGlvbkNodW5rPihyZWFkYWJsZVN0cmVhbSwgdGhpcy5jb250cm9sbGVyKTtcbiAgICBsZXQgY2hhdElkO1xuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICBpZiAoY2hhdElkICYmIGNoYXRJZCAhPT0gY2h1bmsuaWQpIHtcbiAgICAgICAgLy8gQSBuZXcgcmVxdWVzdCBoYXMgYmVlbiBtYWRlLlxuICAgICAgICB0aGlzLl9hZGRDaGF0Q29tcGxldGlvbih0aGlzLiNlbmRSZXF1ZXN0KCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiNhZGRDaHVuayhjaHVuayk7XG4gICAgICBjaGF0SWQgPSBjaHVuay5pZDtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5jb250cm9sbGVyLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hZGRDaGF0Q29tcGxldGlvbih0aGlzLiNlbmRSZXF1ZXN0KCkpO1xuICB9XG5cbiAgI2dldEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdCgpOiBBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQ8UGFyc2VkVD4gfCBudWxsIHtcbiAgICBjb25zdCByZXNwb25zZUZvcm1hdCA9IHRoaXMuI3BhcmFtcz8ucmVzcG9uc2VfZm9ybWF0O1xuICAgIGlmIChpc0F1dG9QYXJzYWJsZVJlc3BvbnNlRm9ybWF0PFBhcnNlZFQ+KHJlc3BvbnNlRm9ybWF0KSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlRm9ybWF0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgI2FjY3VtdWxhdGVDaGF0Q29tcGxldGlvbihjaHVuazogQ2hhdENvbXBsZXRpb25DaHVuayk6IENoYXRDb21wbGV0aW9uU25hcHNob3Qge1xuICAgIGxldCBzbmFwc2hvdCA9IHRoaXMuI2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90O1xuICAgIGNvbnN0IHsgY2hvaWNlcywgLi4ucmVzdCB9ID0gY2h1bms7XG4gICAgaWYgKCFzbmFwc2hvdCkge1xuICAgICAgc25hcHNob3QgPSB0aGlzLiNjdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdCA9IHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgY2hvaWNlczogW10sXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuYXNzaWduKHNuYXBzaG90LCByZXN0KTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHsgZGVsdGEsIGZpbmlzaF9yZWFzb24sIGluZGV4LCBsb2dwcm9icyA9IG51bGwsIC4uLm90aGVyIH0gb2YgY2h1bmsuY2hvaWNlcykge1xuICAgICAgbGV0IGNob2ljZSA9IHNuYXBzaG90LmNob2ljZXNbaW5kZXhdO1xuICAgICAgaWYgKCFjaG9pY2UpIHtcbiAgICAgICAgY2hvaWNlID0gc25hcHNob3QuY2hvaWNlc1tpbmRleF0gPSB7IGZpbmlzaF9yZWFzb24sIGluZGV4LCBtZXNzYWdlOiB7fSwgbG9ncHJvYnMsIC4uLm90aGVyIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChsb2dwcm9icykge1xuICAgICAgICBpZiAoIWNob2ljZS5sb2dwcm9icykge1xuICAgICAgICAgIGNob2ljZS5sb2dwcm9icyA9IE9iamVjdC5hc3NpZ24oe30sIGxvZ3Byb2JzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB7IGNvbnRlbnQsIHJlZnVzYWwsIC4uLnJlc3QgfSA9IGxvZ3Byb2JzO1xuICAgICAgICAgIGFzc2VydElzRW1wdHkocmVzdCk7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihjaG9pY2UubG9ncHJvYnMsIHJlc3QpO1xuXG4gICAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGNob2ljZS5sb2dwcm9icy5jb250ZW50ID8/PSBbXTtcbiAgICAgICAgICAgIGNob2ljZS5sb2dwcm9icy5jb250ZW50LnB1c2goLi4uY29udGVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlZnVzYWwpIHtcbiAgICAgICAgICAgIGNob2ljZS5sb2dwcm9icy5yZWZ1c2FsID8/PSBbXTtcbiAgICAgICAgICAgIGNob2ljZS5sb2dwcm9icy5yZWZ1c2FsLnB1c2goLi4ucmVmdXNhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5pc2hfcmVhc29uKSB7XG4gICAgICAgIGNob2ljZS5maW5pc2hfcmVhc29uID0gZmluaXNoX3JlYXNvbjtcblxuICAgICAgICBpZiAodGhpcy4jcGFyYW1zICYmIGhhc0F1dG9QYXJzZWFibGVJbnB1dCh0aGlzLiNwYXJhbXMpKSB7XG4gICAgICAgICAgaWYgKGZpbmlzaF9yZWFzb24gPT09ICdsZW5ndGgnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTGVuZ3RoRmluaXNoUmVhc29uRXJyb3IoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmluaXNoX3JlYXNvbiA9PT0gJ2NvbnRlbnRfZmlsdGVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbnRlbnRGaWx0ZXJGaW5pc2hSZWFzb25FcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGNob2ljZSwgb3RoZXIpO1xuXG4gICAgICBpZiAoIWRlbHRhKSBjb250aW51ZTsgLy8gU2hvdWxkbid0IGhhcHBlbjsganVzdCBpbiBjYXNlLlxuXG4gICAgICBjb25zdCB7IGNvbnRlbnQsIHJlZnVzYWwsIGZ1bmN0aW9uX2NhbGwsIHJvbGUsIHRvb2xfY2FsbHMsIC4uLnJlc3QgfSA9IGRlbHRhO1xuICAgICAgYXNzZXJ0SXNFbXB0eShyZXN0KTtcbiAgICAgIE9iamVjdC5hc3NpZ24oY2hvaWNlLm1lc3NhZ2UsIHJlc3QpO1xuXG4gICAgICBpZiAocmVmdXNhbCkge1xuICAgICAgICBjaG9pY2UubWVzc2FnZS5yZWZ1c2FsID0gKGNob2ljZS5tZXNzYWdlLnJlZnVzYWwgfHwgJycpICsgcmVmdXNhbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvbGUpIGNob2ljZS5tZXNzYWdlLnJvbGUgPSByb2xlO1xuICAgICAgaWYgKGZ1bmN0aW9uX2NhbGwpIHtcbiAgICAgICAgaWYgKCFjaG9pY2UubWVzc2FnZS5mdW5jdGlvbl9jYWxsKSB7XG4gICAgICAgICAgY2hvaWNlLm1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9IGZ1bmN0aW9uX2NhbGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZ1bmN0aW9uX2NhbGwubmFtZSkgY2hvaWNlLm1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5uYW1lID0gZnVuY3Rpb25fY2FsbC5uYW1lO1xuICAgICAgICAgIGlmIChmdW5jdGlvbl9jYWxsLmFyZ3VtZW50cykge1xuICAgICAgICAgICAgY2hvaWNlLm1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgPz89ICcnO1xuICAgICAgICAgICAgY2hvaWNlLm1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgKz0gZnVuY3Rpb25fY2FsbC5hcmd1bWVudHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICBjaG9pY2UubWVzc2FnZS5jb250ZW50ID0gKGNob2ljZS5tZXNzYWdlLmNvbnRlbnQgfHwgJycpICsgY29udGVudDtcblxuICAgICAgICBpZiAoIWNob2ljZS5tZXNzYWdlLnJlZnVzYWwgJiYgdGhpcy4jZ2V0QXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0KCkpIHtcbiAgICAgICAgICBjaG9pY2UubWVzc2FnZS5wYXJzZWQgPSBwYXJ0aWFsUGFyc2UoY2hvaWNlLm1lc3NhZ2UuY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRvb2xfY2FsbHMpIHtcbiAgICAgICAgaWYgKCFjaG9pY2UubWVzc2FnZS50b29sX2NhbGxzKSBjaG9pY2UubWVzc2FnZS50b29sX2NhbGxzID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCB7IGluZGV4LCBpZCwgdHlwZSwgZnVuY3Rpb246IGZuLCAuLi5yZXN0IH0gb2YgdG9vbF9jYWxscykge1xuICAgICAgICAgIGNvbnN0IHRvb2xfY2FsbCA9IChjaG9pY2UubWVzc2FnZS50b29sX2NhbGxzW2luZGV4XSA/Pz1cbiAgICAgICAgICAgIHt9IGFzIENoYXRDb21wbGV0aW9uU25hcHNob3QuQ2hvaWNlLk1lc3NhZ2UuVG9vbENhbGwpO1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24odG9vbF9jYWxsLCByZXN0KTtcbiAgICAgICAgICBpZiAoaWQpIHRvb2xfY2FsbC5pZCA9IGlkO1xuICAgICAgICAgIGlmICh0eXBlKSB0b29sX2NhbGwudHlwZSA9IHR5cGU7XG4gICAgICAgICAgaWYgKGZuKSB0b29sX2NhbGwuZnVuY3Rpb24gPz89IHsgbmFtZTogZm4ubmFtZSA/PyAnJywgYXJndW1lbnRzOiAnJyB9O1xuICAgICAgICAgIGlmIChmbj8ubmFtZSkgdG9vbF9jYWxsLmZ1bmN0aW9uIS5uYW1lID0gZm4ubmFtZTtcbiAgICAgICAgICBpZiAoZm4/LmFyZ3VtZW50cykge1xuICAgICAgICAgICAgdG9vbF9jYWxsLmZ1bmN0aW9uIS5hcmd1bWVudHMgKz0gZm4uYXJndW1lbnRzO1xuXG4gICAgICAgICAgICBpZiAoc2hvdWxkUGFyc2VUb29sQ2FsbCh0aGlzLiNwYXJhbXMsIHRvb2xfY2FsbCkpIHtcbiAgICAgICAgICAgICAgdG9vbF9jYWxsLmZ1bmN0aW9uIS5wYXJzZWRfYXJndW1lbnRzID0gcGFydGlhbFBhcnNlKHRvb2xfY2FsbC5mdW5jdGlvbiEuYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNuYXBzaG90O1xuICB9XG5cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSh0aGlzOiBDaGF0Q29tcGxldGlvblN0cmVhbTxQYXJzZWRUPik6IEFzeW5jSXRlcmF0b3I8Q2hhdENvbXBsZXRpb25DaHVuaz4ge1xuICAgIGNvbnN0IHB1c2hRdWV1ZTogQ2hhdENvbXBsZXRpb25DaHVua1tdID0gW107XG4gICAgY29uc3QgcmVhZFF1ZXVlOiB7XG4gICAgICByZXNvbHZlOiAoY2h1bms6IENoYXRDb21wbGV0aW9uQ2h1bmsgfCB1bmRlZmluZWQpID0+IHZvaWQ7XG4gICAgICByZWplY3Q6IChlcnI6IHVua25vd24pID0+IHZvaWQ7XG4gICAgfVtdID0gW107XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcblxuICAgIHRoaXMub24oJ2NodW5rJywgKGNodW5rKSA9PiB7XG4gICAgICBjb25zdCByZWFkZXIgPSByZWFkUXVldWUuc2hpZnQoKTtcbiAgICAgIGlmIChyZWFkZXIpIHtcbiAgICAgICAgcmVhZGVyLnJlc29sdmUoY2h1bmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaFF1ZXVlLnB1c2goY2h1bmspO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5vbignZW5kJywgKCkgPT4ge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiByZWFkUXVldWUpIHtcbiAgICAgICAgcmVhZGVyLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIHJlYWRRdWV1ZS5sZW5ndGggPSAwO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbignYWJvcnQnLCAoZXJyKSA9PiB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHJlYWRRdWV1ZSkge1xuICAgICAgICByZWFkZXIucmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICB9KTtcblxuICAgIHRoaXMub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiByZWFkUXVldWUpIHtcbiAgICAgICAgcmVhZGVyLnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVhZFF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogYXN5bmMgKCk6IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8Q2hhdENvbXBsZXRpb25DaHVuaz4+ID0+IHtcbiAgICAgICAgaWYgKCFwdXNoUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPENoYXRDb21wbGV0aW9uQ2h1bmsgfCB1bmRlZmluZWQ+KChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICAgICAgICByZWFkUXVldWUucHVzaCh7IHJlc29sdmUsIHJlamVjdCB9KSxcbiAgICAgICAgICApLnRoZW4oKGNodW5rKSA9PiAoY2h1bmsgPyB7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSA6IHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2h1bmsgPSBwdXNoUXVldWUuc2hpZnQoKSE7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfTtcbiAgICAgIH0sXG4gICAgICByZXR1cm46IGFzeW5jICgpID0+IHtcbiAgICAgICAgdGhpcy5hYm9ydCgpO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICB0b1JlYWRhYmxlU3RyZWFtKCk6IFJlYWRhYmxlU3RyZWFtIHtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgU3RyZWFtKHRoaXNbU3ltYm9sLmFzeW5jSXRlcmF0b3JdLmJpbmQodGhpcyksIHRoaXMuY29udHJvbGxlcik7XG4gICAgcmV0dXJuIHN0cmVhbS50b1JlYWRhYmxlU3RyZWFtKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluYWxpemVDaGF0Q29tcGxldGlvbjxQYXJzZWRUPihcbiAgc25hcHNob3Q6IENoYXRDb21wbGV0aW9uU25hcHNob3QsXG4gIHBhcmFtczogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMgfCBudWxsLFxuKTogUGFyc2VkQ2hhdENvbXBsZXRpb248UGFyc2VkVD4ge1xuICBjb25zdCB7IGlkLCBjaG9pY2VzLCBjcmVhdGVkLCBtb2RlbCwgc3lzdGVtX2ZpbmdlcnByaW50LCAuLi5yZXN0IH0gPSBzbmFwc2hvdDtcbiAgY29uc3QgY29tcGxldGlvbjogQ2hhdENvbXBsZXRpb24gPSB7XG4gICAgLi4ucmVzdCxcbiAgICBpZCxcbiAgICBjaG9pY2VzOiBjaG9pY2VzLm1hcChcbiAgICAgICh7IG1lc3NhZ2UsIGZpbmlzaF9yZWFzb24sIGluZGV4LCBsb2dwcm9icywgLi4uY2hvaWNlUmVzdCB9KTogQ2hhdENvbXBsZXRpb24uQ2hvaWNlID0+IHtcbiAgICAgICAgaWYgKCFmaW5pc2hfcmVhc29uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIGZpbmlzaF9yZWFzb24gZm9yIGNob2ljZSAke2luZGV4fWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBjb250ZW50ID0gbnVsbCwgZnVuY3Rpb25fY2FsbCwgdG9vbF9jYWxscywgLi4ubWVzc2FnZVJlc3QgfSA9IG1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IHJvbGUgPSBtZXNzYWdlLnJvbGUgYXMgJ2Fzc2lzdGFudCc7IC8vIHRoaXMgaXMgd2hhdCB3ZSBleHBlY3Q7IGluIHRoZW9yeSBpdCBjb3VsZCBiZSBkaWZmZXJlbnQgd2hpY2ggd291bGQgbWFrZSBvdXIgdHlwZXMgYSBzbGlnaHQgbGllIGJ1dCB3b3VsZCBiZSBmaW5lLlxuICAgICAgICBpZiAoIXJvbGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYG1pc3Npbmcgcm9sZSBmb3IgY2hvaWNlICR7aW5kZXh9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnVuY3Rpb25fY2FsbCkge1xuICAgICAgICAgIGNvbnN0IHsgYXJndW1lbnRzOiBhcmdzLCBuYW1lIH0gPSBmdW5jdGlvbl9jYWxsO1xuICAgICAgICAgIGlmIChhcmdzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBmdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyBmb3IgY2hvaWNlICR7aW5kZXh9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYG1pc3NpbmcgZnVuY3Rpb25fY2FsbC5uYW1lIGZvciBjaG9pY2UgJHtpbmRleH1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY2hvaWNlUmVzdCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogeyBhcmd1bWVudHM6IGFyZ3MsIG5hbWUgfSxcbiAgICAgICAgICAgICAgcm9sZSxcbiAgICAgICAgICAgICAgcmVmdXNhbDogbWVzc2FnZS5yZWZ1c2FsID8/IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmluaXNoX3JlYXNvbixcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgbG9ncHJvYnMsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b29sX2NhbGxzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNob2ljZVJlc3QsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIGZpbmlzaF9yZWFzb24sXG4gICAgICAgICAgICBsb2dwcm9icyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgLi4ubWVzc2FnZVJlc3QsXG4gICAgICAgICAgICAgIHJvbGUsXG4gICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgIHJlZnVzYWw6IG1lc3NhZ2UucmVmdXNhbCA/PyBudWxsLFxuICAgICAgICAgICAgICB0b29sX2NhbGxzOiB0b29sX2NhbGxzLm1hcCgodG9vbF9jYWxsLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmdW5jdGlvbjogZm4sIHR5cGUsIGlkLCAuLi50b29sUmVzdCB9ID0gdG9vbF9jYWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXJndW1lbnRzOiBhcmdzLCBuYW1lLCAuLi5mblJlc3QgfSA9IGZuIHx8IHt9O1xuICAgICAgICAgICAgICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYG1pc3NpbmcgY2hvaWNlc1ske2luZGV4fV0udG9vbF9jYWxsc1ske2l9XS5pZFxcbiR7c3RyKHNuYXBzaG90KX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIGNob2ljZXNbJHtpbmRleH1dLnRvb2xfY2FsbHNbJHtpfV0udHlwZVxcbiR7c3RyKHNuYXBzaG90KX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgbWlzc2luZyBjaG9pY2VzWyR7aW5kZXh9XS50b29sX2NhbGxzWyR7aX1dLmZ1bmN0aW9uLm5hbWVcXG4ke3N0cihzbmFwc2hvdCl9YCxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhcmdzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYG1pc3NpbmcgY2hvaWNlc1ske2luZGV4fV0udG9vbF9jYWxsc1ske2l9XS5mdW5jdGlvbi5hcmd1bWVudHNcXG4ke3N0cihzbmFwc2hvdCl9YCxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4udG9vbFJlc3QsIGlkLCB0eXBlLCBmdW5jdGlvbjogeyAuLi5mblJlc3QsIG5hbWUsIGFyZ3VtZW50czogYXJncyB9IH07XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY2hvaWNlUmVzdCxcbiAgICAgICAgICBtZXNzYWdlOiB7IC4uLm1lc3NhZ2VSZXN0LCBjb250ZW50LCByb2xlLCByZWZ1c2FsOiBtZXNzYWdlLnJlZnVzYWwgPz8gbnVsbCB9LFxuICAgICAgICAgIGZpbmlzaF9yZWFzb24sXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgbG9ncHJvYnMsXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICksXG4gICAgY3JlYXRlZCxcbiAgICBtb2RlbCxcbiAgICBvYmplY3Q6ICdjaGF0LmNvbXBsZXRpb24nLFxuICAgIC4uLihzeXN0ZW1fZmluZ2VycHJpbnQgPyB7IHN5c3RlbV9maW5nZXJwcmludCB9IDoge30pLFxuICB9O1xuXG4gIHJldHVybiBtYXliZVBhcnNlQ2hhdENvbXBsZXRpb24oY29tcGxldGlvbiwgcGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gc3RyKHg6IHVua25vd24pIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHgpO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdHJlYW1lZCBjaHVuayBvZiBhIGNoYXQgY29tcGxldGlvbiByZXNwb25zZSByZXR1cm5lZCBieSBtb2RlbCxcbiAqIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBpbnB1dC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvblNuYXBzaG90IHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjaGF0IGNvbXBsZXRpb24uXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgY2hhdCBjb21wbGV0aW9uIGNob2ljZXMuIENhbiBiZSBtb3JlIHRoYW4gb25lIGlmIGBuYCBpcyBncmVhdGVyXG4gICAqIHRoYW4gMS5cbiAgICovXG4gIGNob2ljZXM6IEFycmF5PENoYXRDb21wbGV0aW9uU25hcHNob3QuQ2hvaWNlPjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBvZiB3aGVuIHRoZSBjaGF0IGNvbXBsZXRpb24gd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlbCB0byBnZW5lcmF0ZSB0aGUgY29tcGxldGlvbi5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLy8gTm90ZSB3ZSBkbyBub3QgaW5jbHVkZSBhbiBcIm9iamVjdFwiIHR5cGUgb24gdGhlIHNuYXBzaG90LFxuICAvLyBiZWNhdXNlIHRoZSBvYmplY3QgaXMgbm90IGEgdmFsaWQgXCJjaGF0LmNvbXBsZXRpb25cIiB1bnRpbCBmaW5hbGl6ZWQuXG4gIC8vIG9iamVjdDogJ2NoYXQuY29tcGxldGlvbic7XG5cbiAgLyoqXG4gICAqIFRoaXMgZmluZ2VycHJpbnQgcmVwcmVzZW50cyB0aGUgYmFja2VuZCBjb25maWd1cmF0aW9uIHRoYXQgdGhlIG1vZGVsIHJ1bnMgd2l0aC5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgYHNlZWRgIHJlcXVlc3QgcGFyYW1ldGVyIHRvIHVuZGVyc3RhbmQgd2hlblxuICAgKiBiYWNrZW5kIGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUgdGhhdCBtaWdodCBpbXBhY3QgZGV0ZXJtaW5pc20uXG4gICAqL1xuICBzeXN0ZW1fZmluZ2VycHJpbnQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdENvbXBsZXRpb25TbmFwc2hvdCB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ2hvaWNlIHtcbiAgICAvKipcbiAgICAgKiBBIGNoYXQgY29tcGxldGlvbiBkZWx0YSBnZW5lcmF0ZWQgYnkgc3RyZWFtZWQgbW9kZWwgcmVzcG9uc2VzLlxuICAgICAqL1xuICAgIG1lc3NhZ2U6IENob2ljZS5NZXNzYWdlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlYXNvbiB0aGUgbW9kZWwgc3RvcHBlZCBnZW5lcmF0aW5nIHRva2Vucy4gVGhpcyB3aWxsIGJlIGBzdG9wYCBpZiB0aGUgbW9kZWxcbiAgICAgKiBoaXQgYSBuYXR1cmFsIHN0b3AgcG9pbnQgb3IgYSBwcm92aWRlZCBzdG9wIHNlcXVlbmNlLCBgbGVuZ3RoYCBpZiB0aGUgbWF4aW11bVxuICAgICAqIG51bWJlciBvZiB0b2tlbnMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0IHdhcyByZWFjaGVkLCBgY29udGVudF9maWx0ZXJgIGlmXG4gICAgICogY29udGVudCB3YXMgb21pdHRlZCBkdWUgdG8gYSBmbGFnIGZyb20gb3VyIGNvbnRlbnQgZmlsdGVycywgb3IgYGZ1bmN0aW9uX2NhbGxgXG4gICAgICogaWYgdGhlIG1vZGVsIGNhbGxlZCBhIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZpbmlzaF9yZWFzb246IENoYXRDb21wbGV0aW9uLkNob2ljZVsnZmluaXNoX3JlYXNvbiddIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIExvZyBwcm9iYWJpbGl0eSBpbmZvcm1hdGlvbiBmb3IgdGhlIGNob2ljZS5cbiAgICAgKi9cbiAgICBsb2dwcm9iczogQ2hhdENvbXBsZXRpb24uQ2hvaWNlLkxvZ3Byb2JzIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgY2hvaWNlIGluIHRoZSBsaXN0IG9mIGNob2ljZXMuXG4gICAgICovXG4gICAgaW5kZXg6IG51bWJlcjtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgQ2hvaWNlIHtcbiAgICAvKipcbiAgICAgKiBBIGNoYXQgY29tcGxldGlvbiBkZWx0YSBnZW5lcmF0ZWQgYnkgc3RyZWFtZWQgbW9kZWwgcmVzcG9uc2VzLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjb250ZW50cyBvZiB0aGUgY2h1bmsgbWVzc2FnZS5cbiAgICAgICAqL1xuICAgICAgY29udGVudD86IHN0cmluZyB8IG51bGw7XG5cbiAgICAgIHJlZnVzYWw/OiBzdHJpbmcgfCBudWxsO1xuXG4gICAgICBwYXJzZWQ/OiB1bmtub3duIHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlXG4gICAgICAgKiBtb2RlbC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb25fY2FsbD86IE1lc3NhZ2UuRnVuY3Rpb25DYWxsO1xuXG4gICAgICB0b29sX2NhbGxzPzogQXJyYXk8TWVzc2FnZS5Ub29sQ2FsbD47XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHJvbGUgb2YgdGhlIGF1dGhvciBvZiB0aGlzIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIHJvbGU/OiAnc3lzdGVtJyB8ICd1c2VyJyB8ICdhc3Npc3RhbnQnIHwgJ2Z1bmN0aW9uJyB8ICd0b29sJztcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIE1lc3NhZ2Uge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBUb29sQ2FsbCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbC5cbiAgICAgICAgICovXG4gICAgICAgIGlkOiBzdHJpbmc7XG5cbiAgICAgICAgZnVuY3Rpb246IFRvb2xDYWxsLkZ1bmN0aW9uO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbC5cbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbic7XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydCBuYW1lc3BhY2UgVG9vbENhbGwge1xuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGgsIGFzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaW4gSlNPTlxuICAgICAgICAgICAqIGZvcm1hdC4gTm90ZSB0aGF0IHRoZSBtb2RlbCBkb2VzIG5vdCBhbHdheXMgZ2VuZXJhdGUgdmFsaWQgSlNPTiwgYW5kIG1heVxuICAgICAgICAgICAqIGhhbGx1Y2luYXRlIHBhcmFtZXRlcnMgbm90IGRlZmluZWQgYnkgeW91ciBmdW5jdGlvbiBzY2hlbWEuIFZhbGlkYXRlIHRoZVxuICAgICAgICAgICAqIGFyZ3VtZW50cyBpbiB5b3VyIGNvZGUgYmVmb3JlIGNhbGxpbmcgeW91ciBmdW5jdGlvbi5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBhcmd1bWVudHM6IHN0cmluZztcblxuICAgICAgICAgIHBhcnNlZF9hcmd1bWVudHM/OiB1bmtub3duO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICAgICAgICovXG4gICAgICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgYW5kIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZVxuICAgICAgICogbW9kZWwuXG4gICAgICAgKi9cbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25DYWxsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhcmd1bWVudHMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpbiBKU09OXG4gICAgICAgICAqIGZvcm1hdC4gTm90ZSB0aGF0IHRoZSBtb2RlbCBkb2VzIG5vdCBhbHdheXMgZ2VuZXJhdGUgdmFsaWQgSlNPTiwgYW5kIG1heVxuICAgICAgICAgKiBoYWxsdWNpbmF0ZSBwYXJhbWV0ZXJzIG5vdCBkZWZpbmVkIGJ5IHlvdXIgZnVuY3Rpb24gc2NoZW1hLiBWYWxpZGF0ZSB0aGVcbiAgICAgICAgICogYXJndW1lbnRzIGluIHlvdXIgY29kZSBiZWZvcmUgY2FsbGluZyB5b3VyIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgYXJndW1lbnRzPzogc3RyaW5nO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgICAgICovXG4gICAgICAgIG5hbWU/OiBzdHJpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnR5cGUgQXNzZXJ0SXNFbXB0eTxUIGV4dGVuZHMge30+ID0ga2V5b2YgVCBleHRlbmRzIG5ldmVyID8gVCA6IG5ldmVyO1xuXG4vKipcbiAqIEVuc3VyZXMgdGhlIGdpdmVuIGFyZ3VtZW50IGlzIGFuIGVtcHR5IG9iamVjdCwgdXNlZnVsIGZvclxuICogYXNzZXJ0aW5nIHRoYXQgYWxsIGtub3duIHByb3BlcnRpZXMgb24gYW4gb2JqZWN0IGhhdmUgYmVlblxuICogZGVzdHJ1Y3R1cmVkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0VtcHR5PFQgZXh0ZW5kcyB7fT4ob2JqOiBBc3NlcnRJc0VtcHR5PFQ+KTogYXNzZXJ0cyBvYmogaXMgQXNzZXJ0SXNFbXB0eTxUPiB7XG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3g6IG5ldmVyKSB7fVxuIiwgImltcG9ydCB7XG4gIHR5cGUgQ2hhdENvbXBsZXRpb25DaHVuayxcbiAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbn0gZnJvbSAnLi4vcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMnO1xuaW1wb3J0IHsgUnVubmVyT3B0aW9ucywgdHlwZSBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzIH0gZnJvbSAnLi9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyJztcbmltcG9ydCB7IHR5cGUgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9fc2hpbXMvaW5kZXgnO1xuaW1wb3J0IHsgUnVubmFibGVUb29scywgdHlwZSBCYXNlRnVuY3Rpb25zQXJncywgdHlwZSBSdW5uYWJsZUZ1bmN0aW9ucyB9IGZyb20gJy4vUnVubmFibGVGdW5jdGlvbic7XG5pbXBvcnQgeyBDaGF0Q29tcGxldGlvblNuYXBzaG90LCBDaGF0Q29tcGxldGlvblN0cmVhbSB9IGZyb20gJy4vQ2hhdENvbXBsZXRpb25TdHJlYW0nO1xuaW1wb3J0IE9wZW5BSSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyBBdXRvUGFyc2VhYmxlVG9vbCB9IGZyb20gJy4uL2xpYi9wYXJzZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uU3RyZWFtRXZlbnRzIGV4dGVuZHMgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cyB7XG4gIGNvbnRlbnQ6IChjb250ZW50RGVsdGE6IHN0cmluZywgY29udGVudFNuYXBzaG90OiBzdHJpbmcpID0+IHZvaWQ7XG4gIGNodW5rOiAoY2h1bms6IENoYXRDb21wbGV0aW9uQ2h1bmssIHNuYXBzaG90OiBDaGF0Q29tcGxldGlvblNuYXBzaG90KSA9PiB2b2lkO1xufVxuXG5leHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvblN0cmVhbWluZ0Z1bmN0aW9uUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3MgZXh0ZW5kcyBCYXNlRnVuY3Rpb25zQXJncz4gPSBPbWl0PFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgJ2Z1bmN0aW9ucydcbj4gJiB7XG4gIGZ1bmN0aW9uczogUnVubmFibGVGdW5jdGlvbnM8RnVuY3Rpb25zQXJncz47XG59O1xuXG5leHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1Rvb2xSdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncyBleHRlbmRzIEJhc2VGdW5jdGlvbnNBcmdzPiA9IE9taXQ8XG4gIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICAndG9vbHMnXG4+ICYge1xuICB0b29sczogUnVubmFibGVUb29sczxGdW5jdGlvbnNBcmdzPiB8IEF1dG9QYXJzZWFibGVUb29sPGFueSwgdHJ1ZT5bXTtcbn07XG5cbmV4cG9ydCBjbGFzcyBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcjxQYXJzZWRUID0gbnVsbD5cbiAgZXh0ZW5kcyBDaGF0Q29tcGxldGlvblN0cmVhbTxQYXJzZWRUPlxuICBpbXBsZW1lbnRzIEFzeW5jSXRlcmFibGU8Q2hhdENvbXBsZXRpb25DaHVuaz5cbntcbiAgc3RhdGljIG92ZXJyaWRlIGZyb21SZWFkYWJsZVN0cmVhbShzdHJlYW06IFJlYWRhYmxlU3RyZWFtKTogQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXI8bnVsbD4ge1xuICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcihudWxsKTtcbiAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX2Zyb21SZWFkYWJsZVN0cmVhbShzdHJlYW0pKTtcbiAgICByZXR1cm4gcnVubmVyO1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkIC0gcGxlYXNlIHVzZSBgcnVuVG9vbHNgIGluc3RlYWQuICovXG4gIHN0YXRpYyBydW5GdW5jdGlvbnM8VCBleHRlbmRzIChzdHJpbmcgfCBvYmplY3QpW10+KFxuICAgIGNsaWVudDogT3BlbkFJLFxuICAgIHBhcmFtczogQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdGdW5jdGlvblJ1bm5lclBhcmFtczxUPixcbiAgICBvcHRpb25zPzogUnVubmVyT3B0aW9ucyxcbiAgKTogQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXI8bnVsbD4ge1xuICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcihudWxsKTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAncnVuRnVuY3Rpb25zJyB9LFxuICAgIH07XG4gICAgcnVubmVyLl9ydW4oKCkgPT4gcnVubmVyLl9ydW5GdW5jdGlvbnMoY2xpZW50LCBwYXJhbXMsIG9wdHMpKTtcbiAgICByZXR1cm4gcnVubmVyO1xuICB9XG5cbiAgc3RhdGljIHJ1blRvb2xzPFQgZXh0ZW5kcyAoc3RyaW5nIHwgb2JqZWN0KVtdLCBQYXJzZWRUID0gbnVsbD4oXG4gICAgY2xpZW50OiBPcGVuQUksXG4gICAgcGFyYW1zOiBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1Rvb2xSdW5uZXJQYXJhbXM8VD4sXG4gICAgb3B0aW9ucz86IFJ1bm5lck9wdGlvbnMsXG4gICk6IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyPFBhcnNlZFQ+IHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXI8UGFyc2VkVD4oXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gdGhlc2UgdHlwZXMgYXJlIGluY29tcGF0aWJsZVxuICAgICAgcGFyYW1zLFxuICAgICk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3J1blRvb2xzJyB9LFxuICAgIH07XG4gICAgcnVubmVyLl9ydW4oKCkgPT4gcnVubmVyLl9ydW5Ub29scyhjbGllbnQsIHBhcmFtcywgb3B0cykpO1xuICAgIHJldHVybiBydW5uZXI7XG4gIH1cbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBDaGF0Q29tcGxldGlvblJ1bm5lciwgQ2hhdENvbXBsZXRpb25GdW5jdGlvblJ1bm5lclBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL2xpYi9DaGF0Q29tcGxldGlvblJ1bm5lcic7XG5pbXBvcnQge1xuICBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcixcbiAgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdGdW5jdGlvblJ1bm5lclBhcmFtcyxcbn0gZnJvbSAnLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyJztcbmltcG9ydCB7IEJhc2VGdW5jdGlvbnNBcmdzIH0gZnJvbSAnLi4vLi4vLi4vbGliL1J1bm5hYmxlRnVuY3Rpb24nO1xuaW1wb3J0IHsgUnVubmVyT3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL2xpYi9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyJztcbmltcG9ydCB7IENoYXRDb21wbGV0aW9uVG9vbFJ1bm5lclBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL2xpYi9DaGF0Q29tcGxldGlvblJ1bm5lcic7XG5pbXBvcnQgeyBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1Rvb2xSdW5uZXJQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXInO1xuaW1wb3J0IHsgQ2hhdENvbXBsZXRpb25TdHJlYW0sIHR5cGUgQ2hhdENvbXBsZXRpb25TdHJlYW1QYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25TdHJlYW0nO1xuaW1wb3J0IHtcbiAgQ2hhdENvbXBsZXRpb24sXG4gIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICBDaGF0Q29tcGxldGlvbk1lc3NhZ2UsXG4gIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsLFxufSBmcm9tICcuLi8uLi9jaGF0L2NvbXBsZXRpb25zJztcbmltcG9ydCB7IEV4dHJhY3RQYXJzZWRDb250ZW50RnJvbVBhcmFtcywgcGFyc2VDaGF0Q29tcGxldGlvbiwgdmFsaWRhdGVJbnB1dFRvb2xzIH0gZnJvbSAnLi4vLi4vLi4vbGliL3BhcnNlcic7XG5cbmV4cG9ydCB7XG4gIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyLFxuICB0eXBlIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nRnVuY3Rpb25SdW5uZXJQYXJhbXMsXG59IGZyb20gJy4uLy4uLy4uL2xpYi9DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcic7XG5leHBvcnQge1xuICB0eXBlIFJ1bm5hYmxlRnVuY3Rpb24sXG4gIHR5cGUgUnVubmFibGVGdW5jdGlvbnMsXG4gIHR5cGUgUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZSxcbiAgdHlwZSBSdW5uYWJsZUZ1bmN0aW9uV2l0aG91dFBhcnNlLFxuICBQYXJzaW5nRnVuY3Rpb24sXG4gIFBhcnNpbmdUb29sRnVuY3Rpb24sXG59IGZyb20gJy4uLy4uLy4uL2xpYi9SdW5uYWJsZUZ1bmN0aW9uJztcbmV4cG9ydCB7IHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sUnVubmVyUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uUnVubmVyJztcbmV4cG9ydCB7IHR5cGUgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdUb29sUnVubmVyUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyJztcbmV4cG9ydCB7IENoYXRDb21wbGV0aW9uU3RyZWFtLCB0eXBlIENoYXRDb21wbGV0aW9uU3RyZWFtUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtJztcbmV4cG9ydCB7XG4gIENoYXRDb21wbGV0aW9uUnVubmVyLFxuICB0eXBlIENoYXRDb21wbGV0aW9uRnVuY3Rpb25SdW5uZXJQYXJhbXMsXG59IGZyb20gJy4uLy4uLy4uL2xpYi9DaGF0Q29tcGxldGlvblJ1bm5lcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkRnVuY3Rpb24gZXh0ZW5kcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbC5GdW5jdGlvbiB7XG4gIHBhcnNlZF9hcmd1bWVudHM/OiB1bmtub3duO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnNlZEZ1bmN0aW9uVG9vbENhbGwgZXh0ZW5kcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCB7XG4gIGZ1bmN0aW9uOiBQYXJzZWRGdW5jdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRDaGF0Q29tcGxldGlvbk1lc3NhZ2U8UGFyc2VkVD4gZXh0ZW5kcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2Uge1xuICBwYXJzZWQ6IFBhcnNlZFQgfCBudWxsO1xuICB0b29sX2NhbGxzOiBBcnJheTxQYXJzZWRGdW5jdGlvblRvb2xDYWxsPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRDaG9pY2U8UGFyc2VkVD4gZXh0ZW5kcyBDaGF0Q29tcGxldGlvbi5DaG9pY2Uge1xuICBtZXNzYWdlOiBQYXJzZWRDaGF0Q29tcGxldGlvbk1lc3NhZ2U8UGFyc2VkVD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkQ2hhdENvbXBsZXRpb248UGFyc2VkVD4gZXh0ZW5kcyBDaGF0Q29tcGxldGlvbiB7XG4gIGNob2ljZXM6IEFycmF5PFBhcnNlZENob2ljZTxQYXJzZWRUPj47XG59XG5cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uUGFyc2VQYXJhbXMgPSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZztcblxuZXhwb3J0IGNsYXNzIENvbXBsZXRpb25zIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICBwYXJzZTxQYXJhbXMgZXh0ZW5kcyBDaGF0Q29tcGxldGlvblBhcnNlUGFyYW1zLCBQYXJzZWRUID0gRXh0cmFjdFBhcnNlZENvbnRlbnRGcm9tUGFyYW1zPFBhcmFtcz4+KFxuICAgIGJvZHk6IFBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+PiB7XG4gICAgdmFsaWRhdGVJbnB1dFRvb2xzKGJvZHkudG9vbHMpO1xuXG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5jaGF0LmNvbXBsZXRpb25zXG4gICAgICAuY3JlYXRlKGJvZHksIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgICAgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAnYmV0YS5jaGF0LmNvbXBsZXRpb25zLnBhcnNlJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICAuX3RoZW5VbndyYXAoKGNvbXBsZXRpb24pID0+IHBhcnNlQ2hhdENvbXBsZXRpb24oY29tcGxldGlvbiwgYm9keSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIC0gdXNlIGBydW5Ub29sc2AgaW5zdGVhZC5cbiAgICovXG4gIHJ1bkZ1bmN0aW9uczxGdW5jdGlvbnNBcmdzIGV4dGVuZHMgQmFzZUZ1bmN0aW9uc0FyZ3M+KFxuICAgIGJvZHk6IENoYXRDb21wbGV0aW9uRnVuY3Rpb25SdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncz4sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENoYXRDb21wbGV0aW9uUnVubmVyPG51bGw+O1xuICBydW5GdW5jdGlvbnM8RnVuY3Rpb25zQXJncyBleHRlbmRzIEJhc2VGdW5jdGlvbnNBcmdzPihcbiAgICBib2R5OiBDaGF0Q29tcGxldGlvblN0cmVhbWluZ0Z1bmN0aW9uUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3M+LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcjxudWxsPjtcbiAgcnVuRnVuY3Rpb25zPEZ1bmN0aW9uc0FyZ3MgZXh0ZW5kcyBCYXNlRnVuY3Rpb25zQXJncz4oXG4gICAgYm9keTpcbiAgICAgIHwgQ2hhdENvbXBsZXRpb25GdW5jdGlvblJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzPlxuICAgICAgfCBDaGF0Q29tcGxldGlvblN0cmVhbWluZ0Z1bmN0aW9uUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3M+LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDaGF0Q29tcGxldGlvblJ1bm5lcjxudWxsPiB8IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyPG51bGw+IHtcbiAgICBpZiAoYm9keS5zdHJlYW0pIHtcbiAgICAgIHJldHVybiBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lci5ydW5GdW5jdGlvbnMoXG4gICAgICAgIHRoaXMuX2NsaWVudCxcbiAgICAgICAgYm9keSBhcyBDaGF0Q29tcGxldGlvblN0cmVhbWluZ0Z1bmN0aW9uUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3M+LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIENoYXRDb21wbGV0aW9uUnVubmVyLnJ1bkZ1bmN0aW9ucyhcbiAgICAgIHRoaXMuX2NsaWVudCxcbiAgICAgIGJvZHkgYXMgQ2hhdENvbXBsZXRpb25GdW5jdGlvblJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzPixcbiAgICAgIG9wdGlvbnMsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbmNlIGhlbHBlciBmb3IgdXNpbmcgdG9vbCBjYWxscyB3aXRoIHRoZSAvY2hhdC9jb21wbGV0aW9ucyBlbmRwb2ludFxuICAgKiB3aGljaCBhdXRvbWF0aWNhbGx5IGNhbGxzIHRoZSBKYXZhU2NyaXB0IGZ1bmN0aW9ucyB5b3UgcHJvdmlkZSBhbmQgc2VuZHMgdGhlaXJcbiAgICogcmVzdWx0cyBiYWNrIHRvIHRoZSAvY2hhdC9jb21wbGV0aW9ucyBlbmRwb2ludCwgbG9vcGluZyBhcyBsb25nIGFzIHRoZSBtb2RlbFxuICAgKiByZXF1ZXN0cyBmdW5jdGlvbiBjYWxscy5cbiAgICpcbiAgICogRm9yIG1vcmUgZGV0YWlscyBhbmQgZXhhbXBsZXMsIHNlZVxuICAgKiBbdGhlIGRvY3NdKGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUjYXV0b21hdGVkLWZ1bmN0aW9uLWNhbGxzKVxuICAgKi9cbiAgcnVuVG9vbHM8XG4gICAgUGFyYW1zIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25Ub29sUnVubmVyUGFyYW1zPGFueT4sXG4gICAgUGFyc2VkVCA9IEV4dHJhY3RQYXJzZWRDb250ZW50RnJvbVBhcmFtczxQYXJhbXM+LFxuICA+KGJvZHk6IFBhcmFtcywgb3B0aW9ucz86IFJ1bm5lck9wdGlvbnMpOiBDaGF0Q29tcGxldGlvblJ1bm5lcjxQYXJzZWRUPjtcblxuICBydW5Ub29sczxcbiAgICBQYXJhbXMgZXh0ZW5kcyBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1Rvb2xSdW5uZXJQYXJhbXM8YW55PixcbiAgICBQYXJzZWRUID0gRXh0cmFjdFBhcnNlZENvbnRlbnRGcm9tUGFyYW1zPFBhcmFtcz4sXG4gID4oYm9keTogUGFyYW1zLCBvcHRpb25zPzogUnVubmVyT3B0aW9ucyk6IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyPFBhcnNlZFQ+O1xuXG4gIHJ1blRvb2xzPFxuICAgIFBhcmFtcyBleHRlbmRzIENoYXRDb21wbGV0aW9uVG9vbFJ1bm5lclBhcmFtczxhbnk+IHwgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdUb29sUnVubmVyUGFyYW1zPGFueT4sXG4gICAgUGFyc2VkVCA9IEV4dHJhY3RQYXJzZWRDb250ZW50RnJvbVBhcmFtczxQYXJhbXM+LFxuICA+KFxuICAgIGJvZHk6IFBhcmFtcyxcbiAgICBvcHRpb25zPzogUnVubmVyT3B0aW9ucyxcbiAgKTogQ2hhdENvbXBsZXRpb25SdW5uZXI8UGFyc2VkVD4gfCBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcjxQYXJzZWRUPiB7XG4gICAgaWYgKGJvZHkuc3RyZWFtKSB7XG4gICAgICByZXR1cm4gQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIucnVuVG9vbHMoXG4gICAgICAgIHRoaXMuX2NsaWVudCxcbiAgICAgICAgYm9keSBhcyBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1Rvb2xSdW5uZXJQYXJhbXM8YW55PixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIENoYXRDb21wbGV0aW9uUnVubmVyLnJ1blRvb2xzKHRoaXMuX2NsaWVudCwgYm9keSBhcyBDaGF0Q29tcGxldGlvblRvb2xSdW5uZXJQYXJhbXM8YW55Piwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNoYXQgY29tcGxldGlvbiBzdHJlYW1cbiAgICovXG4gIHN0cmVhbTxQYXJhbXMgZXh0ZW5kcyBDaGF0Q29tcGxldGlvblN0cmVhbVBhcmFtcywgUGFyc2VkVCA9IEV4dHJhY3RQYXJzZWRDb250ZW50RnJvbVBhcmFtczxQYXJhbXM+PihcbiAgICBib2R5OiBQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENoYXRDb21wbGV0aW9uU3RyZWFtPFBhcnNlZFQ+IHtcbiAgICByZXR1cm4gQ2hhdENvbXBsZXRpb25TdHJlYW0uY3JlYXRlQ2hhdENvbXBsZXRpb24odGhpcy5fY2xpZW50LCBib2R5LCBvcHRpb25zKTtcbiAgfVxufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgQ29tcGxldGlvbnNBUEkgZnJvbSAnLi9jb21wbGV0aW9ucyc7XG5cbmV4cG9ydCBjbGFzcyBDaGF0IGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICBjb21wbGV0aW9uczogQ29tcGxldGlvbnNBUEkuQ29tcGxldGlvbnMgPSBuZXcgQ29tcGxldGlvbnNBUEkuQ29tcGxldGlvbnModGhpcy5fY2xpZW50KTtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0IHtcbiAgZXhwb3J0IGltcG9ydCBDb21wbGV0aW9ucyA9IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zO1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi8uLi9jb3JlJztcblxuZXhwb3J0IGNsYXNzIFNlc3Npb25zIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlIGFuIGVwaGVtZXJhbCBBUEkgdG9rZW4gZm9yIHVzZSBpbiBjbGllbnQtc2lkZSBhcHBsaWNhdGlvbnMgd2l0aCB0aGVcbiAgICogUmVhbHRpbWUgQVBJLiBDYW4gYmUgY29uZmlndXJlZCB3aXRoIHRoZSBzYW1lIHNlc3Npb24gcGFyYW1ldGVycyBhcyB0aGVcbiAgICogYHNlc3Npb24udXBkYXRlYCBjbGllbnQgZXZlbnQuXG4gICAqXG4gICAqIEl0IHJlc3BvbmRzIHdpdGggYSBzZXNzaW9uIG9iamVjdCwgcGx1cyBhIGBjbGllbnRfc2VjcmV0YCBrZXkgd2hpY2ggY29udGFpbnMgYVxuICAgKiB1c2FibGUgZXBoZW1lcmFsIEFQSSB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGF1dGhlbnRpY2F0ZSBicm93c2VyIGNsaWVudHMgZm9yXG4gICAqIHRoZSBSZWFsdGltZSBBUEkuXG4gICAqL1xuICBjcmVhdGUoYm9keTogU2Vzc2lvbkNyZWF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8U2Vzc2lvbkNyZWF0ZVJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvcmVhbHRpbWUvc2Vzc2lvbnMnLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWFsdGltZSBzZXNzaW9uIG9iamVjdCBjb25maWd1cmF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlc3Npb24ge1xuICAvKipcbiAgICogVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBzZXNzaW9uIG9iamVjdC5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IG9mIGlucHV0IGF1ZGlvLiBPcHRpb25zIGFyZSBgcGNtMTZgLCBgZzcxMV91bGF3YCwgb3IgYGc3MTFfYWxhd2AuXG4gICAqL1xuICBpbnB1dF9hdWRpb19mb3JtYXQ/OiAncGNtMTYnIHwgJ2c3MTFfdWxhdycgfCAnZzcxMV9hbGF3JztcblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiwgZGVmYXVsdHMgdG8gb2ZmIGFuZCBjYW4gYmUgc2V0IHRvXG4gICAqIGBudWxsYCB0byB0dXJuIG9mZiBvbmNlIG9uLiBJbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uIGlzIG5vdCBuYXRpdmUgdG8gdGhlXG4gICAqIG1vZGVsLCBzaW5jZSB0aGUgbW9kZWwgY29uc3VtZXMgYXVkaW8gZGlyZWN0bHkuIFRyYW5zY3JpcHRpb24gcnVuc1xuICAgKiBhc3luY2hyb25vdXNseSB0aHJvdWdoIFdoaXNwZXIgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIHJvdWdoIGd1aWRhbmNlIHJhdGhlclxuICAgKiB0aGFuIHRoZSByZXByZXNlbnRhdGlvbiB1bmRlcnN0b29kIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIGlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24/OiBTZXNzaW9uLklucHV0QXVkaW9UcmFuc2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBzeXN0ZW0gaW5zdHJ1Y3Rpb25zIChpLmUuIHN5c3RlbSBtZXNzYWdlKSBwcmVwZW5kZWQgdG8gbW9kZWwgY2FsbHMuXG4gICAqIFRoaXMgZmllbGQgYWxsb3dzIHRoZSBjbGllbnQgdG8gZ3VpZGUgdGhlIG1vZGVsIG9uIGRlc2lyZWQgcmVzcG9uc2VzLiBUaGUgbW9kZWxcbiAgICogY2FuIGJlIGluc3RydWN0ZWQgb24gcmVzcG9uc2UgY29udGVudCBhbmQgZm9ybWF0LCAoZS5nLiBcImJlIGV4dHJlbWVseSBzdWNjaW5jdFwiLFxuICAgKiBcImFjdCBmcmllbmRseVwiLCBcImhlcmUgYXJlIGV4YW1wbGVzIG9mIGdvb2QgcmVzcG9uc2VzXCIpIGFuZCBvbiBhdWRpbyBiZWhhdmlvclxuICAgKiAoZS5nLiBcInRhbGsgcXVpY2tseVwiLCBcImluamVjdCBlbW90aW9uIGludG8geW91ciB2b2ljZVwiLCBcImxhdWdoIGZyZXF1ZW50bHlcIikuIFRoZVxuICAgKiBpbnN0cnVjdGlvbnMgYXJlIG5vdCBndWFyYW50ZWVkIHRvIGJlIGZvbGxvd2VkIGJ5IHRoZSBtb2RlbCwgYnV0IHRoZXkgcHJvdmlkZVxuICAgKiBndWlkYW5jZSB0byB0aGUgbW9kZWwgb24gdGhlIGRlc2lyZWQgYmVoYXZpb3IuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgc2VydmVyIHNldHMgZGVmYXVsdCBpbnN0cnVjdGlvbnMgd2hpY2ggd2lsbCBiZSB1c2VkIGlmIHRoaXMgZmllbGRcbiAgICogaXMgbm90IHNldCBhbmQgYXJlIHZpc2libGUgaW4gdGhlIGBzZXNzaW9uLmNyZWF0ZWRgIGV2ZW50IGF0IHRoZSBzdGFydCBvZiB0aGVcbiAgICogc2Vzc2lvbi5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZztcblxuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2Ygb3V0cHV0IHRva2VucyBmb3IgYSBzaW5nbGUgYXNzaXN0YW50IHJlc3BvbnNlLCBpbmNsdXNpdmUgb2ZcbiAgICogdG9vbCBjYWxscy4gUHJvdmlkZSBhbiBpbnRlZ2VyIGJldHdlZW4gMSBhbmQgNDA5NiB0byBsaW1pdCBvdXRwdXQgdG9rZW5zLCBvclxuICAgKiBgaW5mYCBmb3IgdGhlIG1heGltdW0gYXZhaWxhYmxlIHRva2VucyBmb3IgYSBnaXZlbiBtb2RlbC4gRGVmYXVsdHMgdG8gYGluZmAuXG4gICAqL1xuICBtYXhfcmVzcG9uc2Vfb3V0cHV0X3Rva2Vucz86IG51bWJlciB8ICdpbmYnO1xuXG4gIC8qKlxuICAgKiBUaGUgc2V0IG9mIG1vZGFsaXRpZXMgdGhlIG1vZGVsIGNhbiByZXNwb25kIHdpdGguIFRvIGRpc2FibGUgYXVkaW8sIHNldCB0aGlzIHRvXG4gICAqIFtcInRleHRcIl0uXG4gICAqL1xuICBtb2RhbGl0aWVzPzogQXJyYXk8J3RleHQnIHwgJ2F1ZGlvJz47XG5cbiAgLyoqXG4gICAqIFRoZSBSZWFsdGltZSBtb2RlbCB1c2VkIGZvciB0aGlzIHNlc3Npb24uXG4gICAqL1xuICBtb2RlbD86XG4gICAgfCAoc3RyaW5nICYge30pXG4gICAgfCAnZ3B0LTRvLXJlYWx0aW1lLXByZXZpZXcnXG4gICAgfCAnZ3B0LTRvLXJlYWx0aW1lLXByZXZpZXctMjAyNC0xMC0wMSdcbiAgICB8ICdncHQtNG8tcmVhbHRpbWUtcHJldmlldy0yMDI0LTEyLTE3J1xuICAgIHwgJ2dwdC00by1taW5pLXJlYWx0aW1lLXByZXZpZXcnXG4gICAgfCAnZ3B0LTRvLW1pbmktcmVhbHRpbWUtcHJldmlldy0yMDI0LTEyLTE3JztcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCBvZiBvdXRwdXQgYXVkaW8uIE9wdGlvbnMgYXJlIGBwY20xNmAsIGBnNzExX3VsYXdgLCBvciBgZzcxMV9hbGF3YC5cbiAgICovXG4gIG91dHB1dF9hdWRpb19mb3JtYXQ/OiAncGNtMTYnIHwgJ2c3MTFfdWxhdycgfCAnZzcxMV9hbGF3JztcblxuICAvKipcbiAgICogU2FtcGxpbmcgdGVtcGVyYXR1cmUgZm9yIHRoZSBtb2RlbCwgbGltaXRlZCB0byBbMC42LCAxLjJdLiBEZWZhdWx0cyB0byAwLjguXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcblxuICAvKipcbiAgICogSG93IHRoZSBtb2RlbCBjaG9vc2VzIHRvb2xzLiBPcHRpb25zIGFyZSBgYXV0b2AsIGBub25lYCwgYHJlcXVpcmVkYCwgb3Igc3BlY2lmeVxuICAgKiBhIGZ1bmN0aW9uLlxuICAgKi9cbiAgdG9vbF9jaG9pY2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRvb2xzIChmdW5jdGlvbnMpIGF2YWlsYWJsZSB0byB0aGUgbW9kZWwuXG4gICAqL1xuICB0b29scz86IEFycmF5PFNlc3Npb24uVG9vbD47XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gZm9yIHR1cm4gZGV0ZWN0aW9uLiBDYW4gYmUgc2V0IHRvIGBudWxsYCB0byB0dXJuIG9mZi4gU2VydmVyIFZBRFxuICAgKiBtZWFucyB0aGF0IHRoZSBtb2RlbCB3aWxsIGRldGVjdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiBzcGVlY2ggYmFzZWQgb24gYXVkaW9cbiAgICogdm9sdW1lIGFuZCByZXNwb25kIGF0IHRoZSBlbmQgb2YgdXNlciBzcGVlY2guXG4gICAqL1xuICB0dXJuX2RldGVjdGlvbj86IFNlc3Npb24uVHVybkRldGVjdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSB2b2ljZSB0aGUgbW9kZWwgdXNlcyB0byByZXNwb25kLiBWb2ljZSBjYW5ub3QgYmUgY2hhbmdlZCBkdXJpbmcgdGhlIHNlc3Npb25cbiAgICogb25jZSB0aGUgbW9kZWwgaGFzIHJlc3BvbmRlZCB3aXRoIGF1ZGlvIGF0IGxlYXN0IG9uY2UuIEN1cnJlbnQgdm9pY2Ugb3B0aW9ucyBhcmVcbiAgICogYGFsbG95YCwgYGFzaGAsIGBiYWxsYWRgLCBgY29yYWxgLCBgZWNob2AgYHNhZ2VgLCBgc2hpbW1lcmAgYW5kIGB2ZXJzZWAuXG4gICAqL1xuICB2b2ljZT86ICdhbGxveScgfCAnYXNoJyB8ICdiYWxsYWQnIHwgJ2NvcmFsJyB8ICdlY2hvJyB8ICdzYWdlJyB8ICdzaGltbWVyJyB8ICd2ZXJzZSc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgU2Vzc2lvbiB7XG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciBpbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uLCBkZWZhdWx0cyB0byBvZmYgYW5kIGNhbiBiZSBzZXQgdG9cbiAgICogYG51bGxgIHRvIHR1cm4gb2ZmIG9uY2Ugb24uIElucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24gaXMgbm90IG5hdGl2ZSB0byB0aGVcbiAgICogbW9kZWwsIHNpbmNlIHRoZSBtb2RlbCBjb25zdW1lcyBhdWRpbyBkaXJlY3RseS4gVHJhbnNjcmlwdGlvbiBydW5zXG4gICAqIGFzeW5jaHJvbm91c2x5IHRocm91Z2ggV2hpc3BlciBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgcm91Z2ggZ3VpZGFuY2UgcmF0aGVyXG4gICAqIHRoYW4gdGhlIHJlcHJlc2VudGF0aW9uIHVuZGVyc3Rvb2QgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsIHRvIHVzZSBmb3IgdHJhbnNjcmlwdGlvbiwgYHdoaXNwZXItMWAgaXMgdGhlIG9ubHkgY3VycmVudGx5IHN1cHBvcnRlZFxuICAgICAqIG1vZGVsLlxuICAgICAqL1xuICAgIG1vZGVsPzogc3RyaW5nO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGZ1bmN0aW9uLCBpbmNsdWRpbmcgZ3VpZGFuY2Ugb24gd2hlbiBhbmQgaG93IHRvIGNhbGwgaXQsXG4gICAgICogYW5kIGd1aWRhbmNlIGFib3V0IHdoYXQgdG8gdGVsbCB0aGUgdXNlciB3aGVuIGNhbGxpbmcgKGlmIGFueXRoaW5nKS5cbiAgICAgKi9cbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBuYW1lPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUGFyYW1ldGVycyBvZiB0aGUgZnVuY3Rpb24gaW4gSlNPTiBTY2hlbWEuXG4gICAgICovXG4gICAgcGFyYW1ldGVycz86IHVua25vd247XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbCwgaS5lLiBgZnVuY3Rpb25gLlxuICAgICAqL1xuICAgIHR5cGU/OiAnZnVuY3Rpb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gZm9yIHR1cm4gZGV0ZWN0aW9uLiBDYW4gYmUgc2V0IHRvIGBudWxsYCB0byB0dXJuIG9mZi4gU2VydmVyIFZBRFxuICAgKiBtZWFucyB0aGF0IHRoZSBtb2RlbCB3aWxsIGRldGVjdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiBzcGVlY2ggYmFzZWQgb24gYXVkaW9cbiAgICogdm9sdW1lIGFuZCByZXNwb25kIGF0IHRoZSBlbmQgb2YgdXNlciBzcGVlY2guXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFR1cm5EZXRlY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIEFtb3VudCBvZiBhdWRpbyB0byBpbmNsdWRlIGJlZm9yZSB0aGUgVkFEIGRldGVjdGVkIHNwZWVjaCAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICAgKiBEZWZhdWx0cyB0byAzMDBtcy5cbiAgICAgKi9cbiAgICBwcmVmaXhfcGFkZGluZ19tcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIER1cmF0aW9uIG9mIHNpbGVuY2UgdG8gZGV0ZWN0IHNwZWVjaCBzdG9wIChpbiBtaWxsaXNlY29uZHMpLiBEZWZhdWx0cyB0byA1MDBtcy5cbiAgICAgKiBXaXRoIHNob3J0ZXIgdmFsdWVzIHRoZSBtb2RlbCB3aWxsIHJlc3BvbmQgbW9yZSBxdWlja2x5LCBidXQgbWF5IGp1bXAgaW4gb25cbiAgICAgKiBzaG9ydCBwYXVzZXMgZnJvbSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBzaWxlbmNlX2R1cmF0aW9uX21zPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGlvbiB0aHJlc2hvbGQgZm9yIFZBRCAoMC4wIHRvIDEuMCksIHRoaXMgZGVmYXVsdHMgdG8gMC41LiBBIGhpZ2hlclxuICAgICAqIHRocmVzaG9sZCB3aWxsIHJlcXVpcmUgbG91ZGVyIGF1ZGlvIHRvIGFjdGl2YXRlIHRoZSBtb2RlbCwgYW5kIHRodXMgbWlnaHRcbiAgICAgKiBwZXJmb3JtIGJldHRlciBpbiBub2lzeSBlbnZpcm9ubWVudHMuXG4gICAgICovXG4gICAgdGhyZXNob2xkPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiB0dXJuIGRldGVjdGlvbiwgb25seSBgc2VydmVyX3ZhZGAgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICB0eXBlPzogJ3NlcnZlcl92YWQnO1xuICB9XG59XG5cbi8qKlxuICogQSBuZXcgUmVhbHRpbWUgc2Vzc2lvbiBjb25maWd1cmF0aW9uLCB3aXRoIGFuIGVwaGVybWVyYWwga2V5LiBEZWZhdWx0IFRUTCBmb3JcbiAqIGtleXMgaXMgb25lIG1pbnV0ZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uQ3JlYXRlUmVzcG9uc2Uge1xuICAvKipcbiAgICogRXBoZW1lcmFsIGtleSByZXR1cm5lZCBieSB0aGUgQVBJLlxuICAgKi9cbiAgY2xpZW50X3NlY3JldD86IFNlc3Npb25DcmVhdGVSZXNwb25zZS5DbGllbnRTZWNyZXQ7XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgb2YgaW5wdXQgYXVkaW8uIE9wdGlvbnMgYXJlIGBwY20xNmAsIGBnNzExX3VsYXdgLCBvciBgZzcxMV9hbGF3YC5cbiAgICovXG4gIGlucHV0X2F1ZGlvX2Zvcm1hdD86IHN0cmluZztcblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiwgZGVmYXVsdHMgdG8gb2ZmIGFuZCBjYW4gYmUgc2V0IHRvXG4gICAqIGBudWxsYCB0byB0dXJuIG9mZiBvbmNlIG9uLiBJbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uIGlzIG5vdCBuYXRpdmUgdG8gdGhlXG4gICAqIG1vZGVsLCBzaW5jZSB0aGUgbW9kZWwgY29uc3VtZXMgYXVkaW8gZGlyZWN0bHkuIFRyYW5zY3JpcHRpb24gcnVuc1xuICAgKiBhc3luY2hyb25vdXNseSB0aHJvdWdoIFdoaXNwZXIgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIHJvdWdoIGd1aWRhbmNlIHJhdGhlclxuICAgKiB0aGFuIHRoZSByZXByZXNlbnRhdGlvbiB1bmRlcnN0b29kIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIGlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24/OiBTZXNzaW9uQ3JlYXRlUmVzcG9uc2UuSW5wdXRBdWRpb1RyYW5zY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHN5c3RlbSBpbnN0cnVjdGlvbnMgKGkuZS4gc3lzdGVtIG1lc3NhZ2UpIHByZXBlbmRlZCB0byBtb2RlbCBjYWxscy5cbiAgICogVGhpcyBmaWVsZCBhbGxvd3MgdGhlIGNsaWVudCB0byBndWlkZSB0aGUgbW9kZWwgb24gZGVzaXJlZCByZXNwb25zZXMuIFRoZSBtb2RlbFxuICAgKiBjYW4gYmUgaW5zdHJ1Y3RlZCBvbiByZXNwb25zZSBjb250ZW50IGFuZCBmb3JtYXQsIChlLmcuIFwiYmUgZXh0cmVtZWx5IHN1Y2NpbmN0XCIsXG4gICAqIFwiYWN0IGZyaWVuZGx5XCIsIFwiaGVyZSBhcmUgZXhhbXBsZXMgb2YgZ29vZCByZXNwb25zZXNcIikgYW5kIG9uIGF1ZGlvIGJlaGF2aW9yXG4gICAqIChlLmcuIFwidGFsayBxdWlja2x5XCIsIFwiaW5qZWN0IGVtb3Rpb24gaW50byB5b3VyIHZvaWNlXCIsIFwibGF1Z2ggZnJlcXVlbnRseVwiKS4gVGhlXG4gICAqIGluc3RydWN0aW9ucyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gYmUgZm9sbG93ZWQgYnkgdGhlIG1vZGVsLCBidXQgdGhleSBwcm92aWRlXG4gICAqIGd1aWRhbmNlIHRvIHRoZSBtb2RlbCBvbiB0aGUgZGVzaXJlZCBiZWhhdmlvci5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBzZXJ2ZXIgc2V0cyBkZWZhdWx0IGluc3RydWN0aW9ucyB3aGljaCB3aWxsIGJlIHVzZWQgaWYgdGhpcyBmaWVsZFxuICAgKiBpcyBub3Qgc2V0IGFuZCBhcmUgdmlzaWJsZSBpbiB0aGUgYHNlc3Npb24uY3JlYXRlZGAgZXZlbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZVxuICAgKiBzZXNzaW9uLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiBvdXRwdXQgdG9rZW5zIGZvciBhIHNpbmdsZSBhc3Npc3RhbnQgcmVzcG9uc2UsIGluY2x1c2l2ZSBvZlxuICAgKiB0b29sIGNhbGxzLiBQcm92aWRlIGFuIGludGVnZXIgYmV0d2VlbiAxIGFuZCA0MDk2IHRvIGxpbWl0IG91dHB1dCB0b2tlbnMsIG9yXG4gICAqIGBpbmZgIGZvciB0aGUgbWF4aW11bSBhdmFpbGFibGUgdG9rZW5zIGZvciBhIGdpdmVuIG1vZGVsLiBEZWZhdWx0cyB0byBgaW5mYC5cbiAgICovXG4gIG1heF9yZXNwb25zZV9vdXRwdXRfdG9rZW5zPzogbnVtYmVyIHwgJ2luZic7XG5cbiAgLyoqXG4gICAqIFRoZSBzZXQgb2YgbW9kYWxpdGllcyB0aGUgbW9kZWwgY2FuIHJlc3BvbmQgd2l0aC4gVG8gZGlzYWJsZSBhdWRpbywgc2V0IHRoaXMgdG9cbiAgICogW1widGV4dFwiXS5cbiAgICovXG4gIG1vZGFsaXRpZXM/OiBBcnJheTwndGV4dCcgfCAnYXVkaW8nPjtcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCBvZiBvdXRwdXQgYXVkaW8uIE9wdGlvbnMgYXJlIGBwY20xNmAsIGBnNzExX3VsYXdgLCBvciBgZzcxMV9hbGF3YC5cbiAgICovXG4gIG91dHB1dF9hdWRpb19mb3JtYXQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNhbXBsaW5nIHRlbXBlcmF0dXJlIGZvciB0aGUgbW9kZWwsIGxpbWl0ZWQgdG8gWzAuNiwgMS4yXS4gRGVmYXVsdHMgdG8gMC44LlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEhvdyB0aGUgbW9kZWwgY2hvb3NlcyB0b29scy4gT3B0aW9ucyBhcmUgYGF1dG9gLCBgbm9uZWAsIGByZXF1aXJlZGAsIG9yIHNwZWNpZnlcbiAgICogYSBmdW5jdGlvbi5cbiAgICovXG4gIHRvb2xfY2hvaWNlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUb29scyAoZnVuY3Rpb25zKSBhdmFpbGFibGUgdG8gdGhlIG1vZGVsLlxuICAgKi9cbiAgdG9vbHM/OiBBcnJheTxTZXNzaW9uQ3JlYXRlUmVzcG9uc2UuVG9vbD47XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gZm9yIHR1cm4gZGV0ZWN0aW9uLiBDYW4gYmUgc2V0IHRvIGBudWxsYCB0byB0dXJuIG9mZi4gU2VydmVyIFZBRFxuICAgKiBtZWFucyB0aGF0IHRoZSBtb2RlbCB3aWxsIGRldGVjdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiBzcGVlY2ggYmFzZWQgb24gYXVkaW9cbiAgICogdm9sdW1lIGFuZCByZXNwb25kIGF0IHRoZSBlbmQgb2YgdXNlciBzcGVlY2guXG4gICAqL1xuICB0dXJuX2RldGVjdGlvbj86IFNlc3Npb25DcmVhdGVSZXNwb25zZS5UdXJuRGV0ZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdm9pY2UgdGhlIG1vZGVsIHVzZXMgdG8gcmVzcG9uZC4gVm9pY2UgY2Fubm90IGJlIGNoYW5nZWQgZHVyaW5nIHRoZSBzZXNzaW9uXG4gICAqIG9uY2UgdGhlIG1vZGVsIGhhcyByZXNwb25kZWQgd2l0aCBhdWRpbyBhdCBsZWFzdCBvbmNlLiBDdXJyZW50IHZvaWNlIG9wdGlvbnMgYXJlXG4gICAqIGBhbGxveWAsIGBhc2hgLCBgYmFsbGFkYCwgYGNvcmFsYCwgYGVjaG9gIGBzYWdlYCwgYHNoaW1tZXJgIGFuZCBgdmVyc2VgLlxuICAgKi9cbiAgdm9pY2U/OiAnYWxsb3knIHwgJ2FzaCcgfCAnYmFsbGFkJyB8ICdjb3JhbCcgfCAnZWNobycgfCAnc2FnZScgfCAnc2hpbW1lcicgfCAndmVyc2UnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFNlc3Npb25DcmVhdGVSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBFcGhlbWVyYWwga2V5IHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIENsaWVudFNlY3JldCB7XG4gICAgLyoqXG4gICAgICogVGltZXN0YW1wIGZvciB3aGVuIHRoZSB0b2tlbiBleHBpcmVzLiBDdXJyZW50bHksIGFsbCB0b2tlbnMgZXhwaXJlIGFmdGVyIG9uZVxuICAgICAqIG1pbnV0ZS5cbiAgICAgKi9cbiAgICBleHBpcmVzX2F0PzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogRXBoZW1lcmFsIGtleSB1c2FibGUgaW4gY2xpZW50IGVudmlyb25tZW50cyB0byBhdXRoZW50aWNhdGUgY29ubmVjdGlvbnMgdG8gdGhlXG4gICAgICogUmVhbHRpbWUgQVBJLiBVc2UgdGhpcyBpbiBjbGllbnQtc2lkZSBlbnZpcm9ubWVudHMgcmF0aGVyIHRoYW4gYSBzdGFuZGFyZCBBUElcbiAgICAgKiB0b2tlbiwgd2hpY2ggc2hvdWxkIG9ubHkgYmUgdXNlZCBzZXJ2ZXItc2lkZS5cbiAgICAgKi9cbiAgICB2YWx1ZT86IHN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciBpbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uLCBkZWZhdWx0cyB0byBvZmYgYW5kIGNhbiBiZSBzZXQgdG9cbiAgICogYG51bGxgIHRvIHR1cm4gb2ZmIG9uY2Ugb24uIElucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24gaXMgbm90IG5hdGl2ZSB0byB0aGVcbiAgICogbW9kZWwsIHNpbmNlIHRoZSBtb2RlbCBjb25zdW1lcyBhdWRpbyBkaXJlY3RseS4gVHJhbnNjcmlwdGlvbiBydW5zXG4gICAqIGFzeW5jaHJvbm91c2x5IHRocm91Z2ggV2hpc3BlciBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgcm91Z2ggZ3VpZGFuY2UgcmF0aGVyXG4gICAqIHRoYW4gdGhlIHJlcHJlc2VudGF0aW9uIHVuZGVyc3Rvb2QgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsIHRvIHVzZSBmb3IgdHJhbnNjcmlwdGlvbiwgYHdoaXNwZXItMWAgaXMgdGhlIG9ubHkgY3VycmVudGx5IHN1cHBvcnRlZFxuICAgICAqIG1vZGVsLlxuICAgICAqL1xuICAgIG1vZGVsPzogc3RyaW5nO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGZ1bmN0aW9uLCBpbmNsdWRpbmcgZ3VpZGFuY2Ugb24gd2hlbiBhbmQgaG93IHRvIGNhbGwgaXQsXG4gICAgICogYW5kIGd1aWRhbmNlIGFib3V0IHdoYXQgdG8gdGVsbCB0aGUgdXNlciB3aGVuIGNhbGxpbmcgKGlmIGFueXRoaW5nKS5cbiAgICAgKi9cbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBuYW1lPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUGFyYW1ldGVycyBvZiB0aGUgZnVuY3Rpb24gaW4gSlNPTiBTY2hlbWEuXG4gICAgICovXG4gICAgcGFyYW1ldGVycz86IHVua25vd247XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbCwgaS5lLiBgZnVuY3Rpb25gLlxuICAgICAqL1xuICAgIHR5cGU/OiAnZnVuY3Rpb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gZm9yIHR1cm4gZGV0ZWN0aW9uLiBDYW4gYmUgc2V0IHRvIGBudWxsYCB0byB0dXJuIG9mZi4gU2VydmVyIFZBRFxuICAgKiBtZWFucyB0aGF0IHRoZSBtb2RlbCB3aWxsIGRldGVjdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiBzcGVlY2ggYmFzZWQgb24gYXVkaW9cbiAgICogdm9sdW1lIGFuZCByZXNwb25kIGF0IHRoZSBlbmQgb2YgdXNlciBzcGVlY2guXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFR1cm5EZXRlY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIEFtb3VudCBvZiBhdWRpbyB0byBpbmNsdWRlIGJlZm9yZSB0aGUgVkFEIGRldGVjdGVkIHNwZWVjaCAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICAgKiBEZWZhdWx0cyB0byAzMDBtcy5cbiAgICAgKi9cbiAgICBwcmVmaXhfcGFkZGluZ19tcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIER1cmF0aW9uIG9mIHNpbGVuY2UgdG8gZGV0ZWN0IHNwZWVjaCBzdG9wIChpbiBtaWxsaXNlY29uZHMpLiBEZWZhdWx0cyB0byA1MDBtcy5cbiAgICAgKiBXaXRoIHNob3J0ZXIgdmFsdWVzIHRoZSBtb2RlbCB3aWxsIHJlc3BvbmQgbW9yZSBxdWlja2x5LCBidXQgbWF5IGp1bXAgaW4gb25cbiAgICAgKiBzaG9ydCBwYXVzZXMgZnJvbSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBzaWxlbmNlX2R1cmF0aW9uX21zPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGlvbiB0aHJlc2hvbGQgZm9yIFZBRCAoMC4wIHRvIDEuMCksIHRoaXMgZGVmYXVsdHMgdG8gMC41LiBBIGhpZ2hlclxuICAgICAqIHRocmVzaG9sZCB3aWxsIHJlcXVpcmUgbG91ZGVyIGF1ZGlvIHRvIGFjdGl2YXRlIHRoZSBtb2RlbCwgYW5kIHRodXMgbWlnaHRcbiAgICAgKiBwZXJmb3JtIGJldHRlciBpbiBub2lzeSBlbnZpcm9ubWVudHMuXG4gICAgICovXG4gICAgdGhyZXNob2xkPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiB0dXJuIGRldGVjdGlvbiwgb25seSBgc2VydmVyX3ZhZGAgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICB0eXBlPzogc3RyaW5nO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbkNyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgUmVhbHRpbWUgbW9kZWwgdXNlZCBmb3IgdGhpcyBzZXNzaW9uLlxuICAgKi9cbiAgbW9kZWw6XG4gICAgfCAnZ3B0LTRvLXJlYWx0aW1lLXByZXZpZXcnXG4gICAgfCAnZ3B0LTRvLXJlYWx0aW1lLXByZXZpZXctMjAyNC0xMC0wMSdcbiAgICB8ICdncHQtNG8tcmVhbHRpbWUtcHJldmlldy0yMDI0LTEyLTE3J1xuICAgIHwgJ2dwdC00by1taW5pLXJlYWx0aW1lLXByZXZpZXcnXG4gICAgfCAnZ3B0LTRvLW1pbmktcmVhbHRpbWUtcHJldmlldy0yMDI0LTEyLTE3JztcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCBvZiBpbnB1dCBhdWRpby4gT3B0aW9ucyBhcmUgYHBjbTE2YCwgYGc3MTFfdWxhd2AsIG9yIGBnNzExX2FsYXdgLlxuICAgKi9cbiAgaW5wdXRfYXVkaW9fZm9ybWF0PzogJ3BjbTE2JyB8ICdnNzExX3VsYXcnIHwgJ2c3MTFfYWxhdyc7XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gZm9yIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24sIGRlZmF1bHRzIHRvIG9mZiBhbmQgY2FuIGJlIHNldCB0b1xuICAgKiBgbnVsbGAgdG8gdHVybiBvZmYgb25jZSBvbi4gSW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiBpcyBub3QgbmF0aXZlIHRvIHRoZVxuICAgKiBtb2RlbCwgc2luY2UgdGhlIG1vZGVsIGNvbnN1bWVzIGF1ZGlvIGRpcmVjdGx5LiBUcmFuc2NyaXB0aW9uIHJ1bnNcbiAgICogYXN5bmNocm9ub3VzbHkgdGhyb3VnaCBXaGlzcGVyIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyByb3VnaCBndWlkYW5jZSByYXRoZXJcbiAgICogdGhhbiB0aGUgcmVwcmVzZW50YXRpb24gdW5kZXJzdG9vZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICBpbnB1dF9hdWRpb190cmFuc2NyaXB0aW9uPzogU2Vzc2lvbkNyZWF0ZVBhcmFtcy5JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgc3lzdGVtIGluc3RydWN0aW9ucyAoaS5lLiBzeXN0ZW0gbWVzc2FnZSkgcHJlcGVuZGVkIHRvIG1vZGVsIGNhbGxzLlxuICAgKiBUaGlzIGZpZWxkIGFsbG93cyB0aGUgY2xpZW50IHRvIGd1aWRlIHRoZSBtb2RlbCBvbiBkZXNpcmVkIHJlc3BvbnNlcy4gVGhlIG1vZGVsXG4gICAqIGNhbiBiZSBpbnN0cnVjdGVkIG9uIHJlc3BvbnNlIGNvbnRlbnQgYW5kIGZvcm1hdCwgKGUuZy4gXCJiZSBleHRyZW1lbHkgc3VjY2luY3RcIixcbiAgICogXCJhY3QgZnJpZW5kbHlcIiwgXCJoZXJlIGFyZSBleGFtcGxlcyBvZiBnb29kIHJlc3BvbnNlc1wiKSBhbmQgb24gYXVkaW8gYmVoYXZpb3JcbiAgICogKGUuZy4gXCJ0YWxrIHF1aWNrbHlcIiwgXCJpbmplY3QgZW1vdGlvbiBpbnRvIHlvdXIgdm9pY2VcIiwgXCJsYXVnaCBmcmVxdWVudGx5XCIpLiBUaGVcbiAgICogaW5zdHJ1Y3Rpb25zIGFyZSBub3QgZ3VhcmFudGVlZCB0byBiZSBmb2xsb3dlZCBieSB0aGUgbW9kZWwsIGJ1dCB0aGV5IHByb3ZpZGVcbiAgICogZ3VpZGFuY2UgdG8gdGhlIG1vZGVsIG9uIHRoZSBkZXNpcmVkIGJlaGF2aW9yLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIHNlcnZlciBzZXRzIGRlZmF1bHQgaW5zdHJ1Y3Rpb25zIHdoaWNoIHdpbGwgYmUgdXNlZCBpZiB0aGlzIGZpZWxkXG4gICAqIGlzIG5vdCBzZXQgYW5kIGFyZSB2aXNpYmxlIGluIHRoZSBgc2Vzc2lvbi5jcmVhdGVkYCBldmVudCBhdCB0aGUgc3RhcnQgb2YgdGhlXG4gICAqIHNlc3Npb24uXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIG91dHB1dCB0b2tlbnMgZm9yIGEgc2luZ2xlIGFzc2lzdGFudCByZXNwb25zZSwgaW5jbHVzaXZlIG9mXG4gICAqIHRvb2wgY2FsbHMuIFByb3ZpZGUgYW4gaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDQwOTYgdG8gbGltaXQgb3V0cHV0IHRva2Vucywgb3JcbiAgICogYGluZmAgZm9yIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSB0b2tlbnMgZm9yIGEgZ2l2ZW4gbW9kZWwuIERlZmF1bHRzIHRvIGBpbmZgLlxuICAgKi9cbiAgbWF4X3Jlc3BvbnNlX291dHB1dF90b2tlbnM/OiBudW1iZXIgfCAnaW5mJztcblxuICAvKipcbiAgICogVGhlIHNldCBvZiBtb2RhbGl0aWVzIHRoZSBtb2RlbCBjYW4gcmVzcG9uZCB3aXRoLiBUbyBkaXNhYmxlIGF1ZGlvLCBzZXQgdGhpcyB0b1xuICAgKiBbXCJ0ZXh0XCJdLlxuICAgKi9cbiAgbW9kYWxpdGllcz86IEFycmF5PCd0ZXh0JyB8ICdhdWRpbyc+O1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IG9mIG91dHB1dCBhdWRpby4gT3B0aW9ucyBhcmUgYHBjbTE2YCwgYGc3MTFfdWxhd2AsIG9yIGBnNzExX2FsYXdgLlxuICAgKi9cbiAgb3V0cHV0X2F1ZGlvX2Zvcm1hdD86ICdwY20xNicgfCAnZzcxMV91bGF3JyB8ICdnNzExX2FsYXcnO1xuXG4gIC8qKlxuICAgKiBTYW1wbGluZyB0ZW1wZXJhdHVyZSBmb3IgdGhlIG1vZGVsLCBsaW1pdGVkIHRvIFswLjYsIDEuMl0uIERlZmF1bHRzIHRvIDAuOC5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBIb3cgdGhlIG1vZGVsIGNob29zZXMgdG9vbHMuIE9wdGlvbnMgYXJlIGBhdXRvYCwgYG5vbmVgLCBgcmVxdWlyZWRgLCBvciBzcGVjaWZ5XG4gICAqIGEgZnVuY3Rpb24uXG4gICAqL1xuICB0b29sX2Nob2ljZT86IHN0cmluZztcblxuICAvKipcbiAgICogVG9vbHMgKGZ1bmN0aW9ucykgYXZhaWxhYmxlIHRvIHRoZSBtb2RlbC5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8U2Vzc2lvbkNyZWF0ZVBhcmFtcy5Ub29sPjtcblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgdHVybiBkZXRlY3Rpb24uIENhbiBiZSBzZXQgdG8gYG51bGxgIHRvIHR1cm4gb2ZmLiBTZXJ2ZXIgVkFEXG4gICAqIG1lYW5zIHRoYXQgdGhlIG1vZGVsIHdpbGwgZGV0ZWN0IHRoZSBzdGFydCBhbmQgZW5kIG9mIHNwZWVjaCBiYXNlZCBvbiBhdWRpb1xuICAgKiB2b2x1bWUgYW5kIHJlc3BvbmQgYXQgdGhlIGVuZCBvZiB1c2VyIHNwZWVjaC5cbiAgICovXG4gIHR1cm5fZGV0ZWN0aW9uPzogU2Vzc2lvbkNyZWF0ZVBhcmFtcy5UdXJuRGV0ZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdm9pY2UgdGhlIG1vZGVsIHVzZXMgdG8gcmVzcG9uZC4gVm9pY2UgY2Fubm90IGJlIGNoYW5nZWQgZHVyaW5nIHRoZSBzZXNzaW9uXG4gICAqIG9uY2UgdGhlIG1vZGVsIGhhcyByZXNwb25kZWQgd2l0aCBhdWRpbyBhdCBsZWFzdCBvbmNlLiBDdXJyZW50IHZvaWNlIG9wdGlvbnMgYXJlXG4gICAqIGBhbGxveWAsIGBhc2hgLCBgYmFsbGFkYCwgYGNvcmFsYCwgYGVjaG9gIGBzYWdlYCwgYHNoaW1tZXJgIGFuZCBgdmVyc2VgLlxuICAgKi9cbiAgdm9pY2U/OiAnYWxsb3knIHwgJ2FzaCcgfCAnYmFsbGFkJyB8ICdjb3JhbCcgfCAnZWNobycgfCAnc2FnZScgfCAnc2hpbW1lcicgfCAndmVyc2UnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFNlc3Npb25DcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiwgZGVmYXVsdHMgdG8gb2ZmIGFuZCBjYW4gYmUgc2V0IHRvXG4gICAqIGBudWxsYCB0byB0dXJuIG9mZiBvbmNlIG9uLiBJbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uIGlzIG5vdCBuYXRpdmUgdG8gdGhlXG4gICAqIG1vZGVsLCBzaW5jZSB0aGUgbW9kZWwgY29uc3VtZXMgYXVkaW8gZGlyZWN0bHkuIFRyYW5zY3JpcHRpb24gcnVuc1xuICAgKiBhc3luY2hyb25vdXNseSB0aHJvdWdoIFdoaXNwZXIgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIHJvdWdoIGd1aWRhbmNlIHJhdGhlclxuICAgKiB0aGFuIHRoZSByZXByZXNlbnRhdGlvbiB1bmRlcnN0b29kIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlbCB0byB1c2UgZm9yIHRyYW5zY3JpcHRpb24sIGB3aGlzcGVyLTFgIGlzIHRoZSBvbmx5IGN1cnJlbnRseSBzdXBwb3J0ZWRcbiAgICAgKiBtb2RlbC5cbiAgICAgKi9cbiAgICBtb2RlbD86IHN0cmluZztcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbCB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBmdW5jdGlvbiwgaW5jbHVkaW5nIGd1aWRhbmNlIG9uIHdoZW4gYW5kIGhvdyB0byBjYWxsIGl0LFxuICAgICAqIGFuZCBndWlkYW5jZSBhYm91dCB3aGF0IHRvIHRlbGwgdGhlIHVzZXIgd2hlbiBjYWxsaW5nIChpZiBhbnl0aGluZykuXG4gICAgICovXG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbmFtZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFBhcmFtZXRlcnMgb2YgdGhlIGZ1bmN0aW9uIGluIEpTT04gU2NoZW1hLlxuICAgICAqL1xuICAgIHBhcmFtZXRlcnM/OiB1bmtub3duO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wsIGkuZS4gYGZ1bmN0aW9uYC5cbiAgICAgKi9cbiAgICB0eXBlPzogJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciB0dXJuIGRldGVjdGlvbi4gQ2FuIGJlIHNldCB0byBgbnVsbGAgdG8gdHVybiBvZmYuIFNlcnZlciBWQURcbiAgICogbWVhbnMgdGhhdCB0aGUgbW9kZWwgd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IGFuZCBlbmQgb2Ygc3BlZWNoIGJhc2VkIG9uIGF1ZGlvXG4gICAqIHZvbHVtZSBhbmQgcmVzcG9uZCBhdCB0aGUgZW5kIG9mIHVzZXIgc3BlZWNoLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUdXJuRGV0ZWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIGEgcmVzcG9uc2Ugd2hlbiBWQUQgaXMgZW5hYmxlZC4gYHRydWVgXG4gICAgICogYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBjcmVhdGVfcmVzcG9uc2U/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQW1vdW50IG9mIGF1ZGlvIHRvIGluY2x1ZGUgYmVmb3JlIHRoZSBWQUQgZGV0ZWN0ZWQgc3BlZWNoIChpbiBtaWxsaXNlY29uZHMpLlxuICAgICAqIERlZmF1bHRzIHRvIDMwMG1zLlxuICAgICAqL1xuICAgIHByZWZpeF9wYWRkaW5nX21zPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogRHVyYXRpb24gb2Ygc2lsZW5jZSB0byBkZXRlY3Qgc3BlZWNoIHN0b3AgKGluIG1pbGxpc2Vjb25kcykuIERlZmF1bHRzIHRvIDUwMG1zLlxuICAgICAqIFdpdGggc2hvcnRlciB2YWx1ZXMgdGhlIG1vZGVsIHdpbGwgcmVzcG9uZCBtb3JlIHF1aWNrbHksIGJ1dCBtYXkganVtcCBpbiBvblxuICAgICAqIHNob3J0IHBhdXNlcyBmcm9tIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIHNpbGVuY2VfZHVyYXRpb25fbXM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0aW9uIHRocmVzaG9sZCBmb3IgVkFEICgwLjAgdG8gMS4wKSwgdGhpcyBkZWZhdWx0cyB0byAwLjUuIEEgaGlnaGVyXG4gICAgICogdGhyZXNob2xkIHdpbGwgcmVxdWlyZSBsb3VkZXIgYXVkaW8gdG8gYWN0aXZhdGUgdGhlIG1vZGVsLCBhbmQgdGh1cyBtaWdodFxuICAgICAqIHBlcmZvcm0gYmV0dGVyIGluIG5vaXN5IGVudmlyb25tZW50cy5cbiAgICAgKi9cbiAgICB0aHJlc2hvbGQ/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIHR1cm4gZGV0ZWN0aW9uLCBvbmx5IGBzZXJ2ZXJfdmFkYCBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIHR5cGU/OiBzdHJpbmc7XG4gIH1cbn1cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFNlc3Npb25zIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIFNlc3Npb24gYXMgU2Vzc2lvbixcbiAgICB0eXBlIFNlc3Npb25DcmVhdGVSZXNwb25zZSBhcyBTZXNzaW9uQ3JlYXRlUmVzcG9uc2UsXG4gICAgdHlwZSBTZXNzaW9uQ3JlYXRlUGFyYW1zIGFzIFNlc3Npb25DcmVhdGVQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBSZWFsdGltZUFQSSBmcm9tICcuL3JlYWx0aW1lJztcbmltcG9ydCAqIGFzIFNlc3Npb25zQVBJIGZyb20gJy4vc2Vzc2lvbnMnO1xuaW1wb3J0IHtcbiAgU2Vzc2lvbiBhcyBTZXNzaW9uc0FQSVNlc3Npb24sXG4gIFNlc3Npb25DcmVhdGVQYXJhbXMsXG4gIFNlc3Npb25DcmVhdGVSZXNwb25zZSxcbiAgU2Vzc2lvbnMsXG59IGZyb20gJy4vc2Vzc2lvbnMnO1xuXG5leHBvcnQgY2xhc3MgUmVhbHRpbWUgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIHNlc3Npb25zOiBTZXNzaW9uc0FQSS5TZXNzaW9ucyA9IG5ldyBTZXNzaW9uc0FQSS5TZXNzaW9ucyh0aGlzLl9jbGllbnQpO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBjb252ZXJzYXRpb24gaXMgY3JlYXRlZC4gRW1pdHRlZCByaWdodCBhZnRlciBzZXNzaW9uIGNyZWF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbkNyZWF0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgY29udmVyc2F0aW9uIHJlc291cmNlLlxuICAgKi9cbiAgY29udmVyc2F0aW9uOiBDb252ZXJzYXRpb25DcmVhdGVkRXZlbnQuQ29udmVyc2F0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgY29udmVyc2F0aW9uLmNyZWF0ZWRgLlxuICAgKi9cbiAgdHlwZTogJ2NvbnZlcnNhdGlvbi5jcmVhdGVkJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDb252ZXJzYXRpb25DcmVhdGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIGNvbnZlcnNhdGlvbiByZXNvdXJjZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgaWQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0IHR5cGUsIG11c3QgYmUgYHJlYWx0aW1lLmNvbnZlcnNhdGlvbmAuXG4gICAgICovXG4gICAgb2JqZWN0PzogJ3JlYWx0aW1lLmNvbnZlcnNhdGlvbic7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb25JdGVtIHtcbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIGl0ZW0sIHRoaXMgY2FuIGJlIGdlbmVyYXRlZCBieSB0aGUgY2xpZW50IHRvIGhlbHAgbWFuYWdlXG4gICAqIHNlcnZlci1zaWRlIGNvbnRleHQsIGJ1dCBpcyBub3QgcmVxdWlyZWQgYmVjYXVzZSB0aGUgc2VydmVyIHdpbGwgZ2VuZXJhdGUgb25lIGlmXG4gICAqIG5vdCBwcm92aWRlZC5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgYXJndW1lbnRzIG9mIHRoZSBmdW5jdGlvbiBjYWxsIChmb3IgYGZ1bmN0aW9uX2NhbGxgIGl0ZW1zKS5cbiAgICovXG4gIGFyZ3VtZW50cz86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBmdW5jdGlvbiBjYWxsIChmb3IgYGZ1bmN0aW9uX2NhbGxgIGFuZCBgZnVuY3Rpb25fY2FsbF9vdXRwdXRgXG4gICAqIGl0ZW1zKS4gSWYgcGFzc2VkIG9uIGEgYGZ1bmN0aW9uX2NhbGxfb3V0cHV0YCBpdGVtLCB0aGUgc2VydmVyIHdpbGwgY2hlY2sgdGhhdCBhXG4gICAqIGBmdW5jdGlvbl9jYWxsYCBpdGVtIHdpdGggdGhlIHNhbWUgSUQgZXhpc3RzIGluIHRoZSBjb252ZXJzYXRpb24gaGlzdG9yeS5cbiAgICovXG4gIGNhbGxfaWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBtZXNzYWdlLCBhcHBsaWNhYmxlIGZvciBgbWVzc2FnZWAgaXRlbXMuXG4gICAqXG4gICAqIC0gTWVzc2FnZSBpdGVtcyBvZiByb2xlIGBzeXN0ZW1gIHN1cHBvcnQgb25seSBgaW5wdXRfdGV4dGAgY29udGVudFxuICAgKiAtIE1lc3NhZ2UgaXRlbXMgb2Ygcm9sZSBgdXNlcmAgc3VwcG9ydCBgaW5wdXRfdGV4dGAgYW5kIGBpbnB1dF9hdWRpb2AgY29udGVudFxuICAgKiAtIE1lc3NhZ2UgaXRlbXMgb2Ygcm9sZSBgYXNzaXN0YW50YCBzdXBwb3J0IGB0ZXh0YCBjb250ZW50LlxuICAgKi9cbiAgY29udGVudD86IEFycmF5PENvbnZlcnNhdGlvbkl0ZW1Db250ZW50PjtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCAoZm9yIGBmdW5jdGlvbl9jYWxsYCBpdGVtcykuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJZGVudGlmaWVyIGZvciB0aGUgQVBJIG9iamVjdCBiZWluZyByZXR1cm5lZCAtIGFsd2F5cyBgcmVhbHRpbWUuaXRlbWAuXG4gICAqL1xuICBvYmplY3Q/OiAncmVhbHRpbWUuaXRlbSc7XG5cbiAgLyoqXG4gICAqIFRoZSBvdXRwdXQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwgKGZvciBgZnVuY3Rpb25fY2FsbF9vdXRwdXRgIGl0ZW1zKS5cbiAgICovXG4gIG91dHB1dD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIG1lc3NhZ2Ugc2VuZGVyIChgdXNlcmAsIGBhc3Npc3RhbnRgLCBgc3lzdGVtYCksIG9ubHkgYXBwbGljYWJsZVxuICAgKiBmb3IgYG1lc3NhZ2VgIGl0ZW1zLlxuICAgKi9cbiAgcm9sZT86ICd1c2VyJyB8ICdhc3Npc3RhbnQnIHwgJ3N5c3RlbSc7XG5cbiAgLyoqXG4gICAqIFRoZSBzdGF0dXMgb2YgdGhlIGl0ZW0gKGBjb21wbGV0ZWRgLCBgaW5jb21wbGV0ZWApLiBUaGVzZSBoYXZlIG5vIGVmZmVjdCBvbiB0aGVcbiAgICogY29udmVyc2F0aW9uLCBidXQgYXJlIGFjY2VwdGVkIGZvciBjb25zaXN0ZW5jeSB3aXRoIHRoZVxuICAgKiBgY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlZGAgZXZlbnQuXG4gICAqL1xuICBzdGF0dXM/OiAnY29tcGxldGVkJyB8ICdpbmNvbXBsZXRlJztcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIGl0ZW0gKGBtZXNzYWdlYCwgYGZ1bmN0aW9uX2NhbGxgLCBgZnVuY3Rpb25fY2FsbF9vdXRwdXRgKS5cbiAgICovXG4gIHR5cGU/OiAnbWVzc2FnZScgfCAnZnVuY3Rpb25fY2FsbCcgfCAnZnVuY3Rpb25fY2FsbF9vdXRwdXQnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbkl0ZW1Db250ZW50IHtcbiAgLyoqXG4gICAqIElEIG9mIGEgcHJldmlvdXMgY29udmVyc2F0aW9uIGl0ZW0gdG8gcmVmZXJlbmNlIChmb3IgYGl0ZW1fcmVmZXJlbmNlYCBjb250ZW50XG4gICAqIHR5cGVzIGluIGByZXNwb25zZS5jcmVhdGVgIGV2ZW50cykuIFRoZXNlIGNhbiByZWZlcmVuY2UgYm90aCBjbGllbnQgYW5kIHNlcnZlclxuICAgKiBjcmVhdGVkIGl0ZW1zLlxuICAgKi9cbiAgaWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEJhc2U2NC1lbmNvZGVkIGF1ZGlvIGJ5dGVzLCB1c2VkIGZvciBgaW5wdXRfYXVkaW9gIGNvbnRlbnQgdHlwZS5cbiAgICovXG4gIGF1ZGlvPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdGV4dCBjb250ZW50LCB1c2VkIGZvciBgaW5wdXRfdGV4dGAgYW5kIGB0ZXh0YCBjb250ZW50IHR5cGVzLlxuICAgKi9cbiAgdGV4dD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHRyYW5zY3JpcHQgb2YgdGhlIGF1ZGlvLCB1c2VkIGZvciBgaW5wdXRfYXVkaW9gIGNvbnRlbnQgdHlwZS5cbiAgICovXG4gIHRyYW5zY3JpcHQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IHR5cGUgKGBpbnB1dF90ZXh0YCwgYGlucHV0X2F1ZGlvYCwgYGl0ZW1fcmVmZXJlbmNlYCwgYHRleHRgKS5cbiAgICovXG4gIHR5cGU/OiAnaW5wdXRfdGV4dCcgfCAnaW5wdXRfYXVkaW8nIHwgJ2l0ZW1fcmVmZXJlbmNlJyB8ICd0ZXh0Jztcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgSXRlbSB0byB0aGUgQ29udmVyc2F0aW9uJ3MgY29udGV4dCwgaW5jbHVkaW5nIG1lc3NhZ2VzLCBmdW5jdGlvblxuICogY2FsbHMsIGFuZCBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlcy4gVGhpcyBldmVudCBjYW4gYmUgdXNlZCBib3RoIHRvIHBvcHVsYXRlIGFcbiAqIFwiaGlzdG9yeVwiIG9mIHRoZSBjb252ZXJzYXRpb24gYW5kIHRvIGFkZCBuZXcgaXRlbXMgbWlkLXN0cmVhbSwgYnV0IGhhcyB0aGVcbiAqIGN1cnJlbnQgbGltaXRhdGlvbiB0aGF0IGl0IGNhbm5vdCBwb3B1bGF0ZSBhc3Npc3RhbnQgYXVkaW8gbWVzc2FnZXMuXG4gKlxuICogSWYgc3VjY2Vzc2Z1bCwgdGhlIHNlcnZlciB3aWxsIHJlc3BvbmQgd2l0aCBhIGBjb252ZXJzYXRpb24uaXRlbS5jcmVhdGVkYCBldmVudCxcbiAqIG90aGVyd2lzZSBhbiBgZXJyb3JgIGV2ZW50IHdpbGwgYmUgc2VudC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb25JdGVtQ3JlYXRlRXZlbnQge1xuICAvKipcbiAgICogVGhlIGl0ZW0gdG8gYWRkIHRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAqL1xuICBpdGVtOiBDb252ZXJzYXRpb25JdGVtO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlYC5cbiAgICovXG4gIHR5cGU6ICdjb252ZXJzYXRpb24uaXRlbS5jcmVhdGUnO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjbGllbnQtZ2VuZXJhdGVkIElEIHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHByZWNlZGluZyBpdGVtIGFmdGVyIHdoaWNoIHRoZSBuZXcgaXRlbSB3aWxsIGJlIGluc2VydGVkLiBJZiBub3RcbiAgICogc2V0LCB0aGUgbmV3IGl0ZW0gd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBjb252ZXJzYXRpb24uIElmIHNldCwgaXRcbiAgICogYWxsb3dzIGFuIGl0ZW0gdG8gYmUgaW5zZXJ0ZWQgbWlkLWNvbnZlcnNhdGlvbi4gSWYgdGhlIElEIGNhbm5vdCBiZSBmb3VuZCwgYW5cbiAgICogZXJyb3Igd2lsbCBiZSByZXR1cm5lZCBhbmQgdGhlIGl0ZW0gd2lsbCBub3QgYmUgYWRkZWQuXG4gICAqL1xuICBwcmV2aW91c19pdGVtX2lkPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBjb252ZXJzYXRpb24gaXRlbSBpcyBjcmVhdGVkLiBUaGVyZSBhcmUgc2V2ZXJhbCBzY2VuYXJpb3MgdGhhdFxuICogcHJvZHVjZSB0aGlzIGV2ZW50OlxuICpcbiAqIC0gVGhlIHNlcnZlciBpcyBnZW5lcmF0aW5nIGEgUmVzcG9uc2UsIHdoaWNoIGlmIHN1Y2Nlc3NmdWwgd2lsbCBwcm9kdWNlIGVpdGhlclxuICogICBvbmUgb3IgdHdvIEl0ZW1zLCB3aGljaCB3aWxsIGJlIG9mIHR5cGUgYG1lc3NhZ2VgIChyb2xlIGBhc3Npc3RhbnRgKSBvciB0eXBlXG4gKiAgIGBmdW5jdGlvbl9jYWxsYC5cbiAqIC0gVGhlIGlucHV0IGF1ZGlvIGJ1ZmZlciBoYXMgYmVlbiBjb21taXR0ZWQsIGVpdGhlciBieSB0aGUgY2xpZW50IG9yIHRoZSBzZXJ2ZXJcbiAqICAgKGluIGBzZXJ2ZXJfdmFkYCBtb2RlKS4gVGhlIHNlcnZlciB3aWxsIHRha2UgdGhlIGNvbnRlbnQgb2YgdGhlIGlucHV0IGF1ZGlvXG4gKiAgIGJ1ZmZlciBhbmQgYWRkIGl0IHRvIGEgbmV3IHVzZXIgbWVzc2FnZSBJdGVtLlxuICogLSBUaGUgY2xpZW50IGhhcyBzZW50IGEgYGNvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZWAgZXZlbnQgdG8gYWRkIGEgbmV3IEl0ZW0gdG9cbiAqICAgdGhlIENvbnZlcnNhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb25JdGVtQ3JlYXRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpdGVtIHRvIGFkZCB0byB0aGUgY29udmVyc2F0aW9uLlxuICAgKi9cbiAgaXRlbTogQ29udmVyc2F0aW9uSXRlbTtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBwcmVjZWRpbmcgaXRlbSBpbiB0aGUgQ29udmVyc2F0aW9uIGNvbnRleHQsIGFsbG93cyB0aGUgY2xpZW50IHRvXG4gICAqIHVuZGVyc3RhbmQgdGhlIG9yZGVyIG9mIHRoZSBjb252ZXJzYXRpb24uXG4gICAqL1xuICBwcmV2aW91c19pdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBjb252ZXJzYXRpb24uaXRlbS5jcmVhdGVkYC5cbiAgICovXG4gIHR5cGU6ICdjb252ZXJzYXRpb24uaXRlbS5jcmVhdGVkJztcbn1cblxuLyoqXG4gKiBTZW5kIHRoaXMgZXZlbnQgd2hlbiB5b3Ugd2FudCB0byByZW1vdmUgYW55IGl0ZW0gZnJvbSB0aGUgY29udmVyc2F0aW9uIGhpc3RvcnkuXG4gKiBUaGUgc2VydmVyIHdpbGwgcmVzcG9uZCB3aXRoIGEgYGNvbnZlcnNhdGlvbi5pdGVtLmRlbGV0ZWRgIGV2ZW50LCB1bmxlc3MgdGhlXG4gKiBpdGVtIGRvZXMgbm90IGV4aXN0IGluIHRoZSBjb252ZXJzYXRpb24gaGlzdG9yeSwgaW4gd2hpY2ggY2FzZSB0aGUgc2VydmVyIHdpbGxcbiAqIHJlc3BvbmQgd2l0aCBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb25JdGVtRGVsZXRlRXZlbnQge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBpdGVtIHRvIGRlbGV0ZS5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGNvbnZlcnNhdGlvbi5pdGVtLmRlbGV0ZWAuXG4gICAqL1xuICB0eXBlOiAnY29udmVyc2F0aW9uLml0ZW0uZGVsZXRlJztcblxuICAvKipcbiAgICogT3B0aW9uYWwgY2xpZW50LWdlbmVyYXRlZCBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGFuIGl0ZW0gaW4gdGhlIGNvbnZlcnNhdGlvbiBpcyBkZWxldGVkIGJ5IHRoZSBjbGllbnQgd2l0aCBhXG4gKiBgY29udmVyc2F0aW9uLml0ZW0uZGVsZXRlYCBldmVudC4gVGhpcyBldmVudCBpcyB1c2VkIHRvIHN5bmNocm9uaXplIHRoZSBzZXJ2ZXInc1xuICogdW5kZXJzdGFuZGluZyBvZiB0aGUgY29udmVyc2F0aW9uIGhpc3Rvcnkgd2l0aCB0aGUgY2xpZW50J3Mgdmlldy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb25JdGVtRGVsZXRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgaXRlbSB0aGF0IHdhcyBkZWxldGVkLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgY29udmVyc2F0aW9uLml0ZW0uZGVsZXRlZGAuXG4gICAqL1xuICB0eXBlOiAnY29udmVyc2F0aW9uLml0ZW0uZGVsZXRlZCc7XG59XG5cbi8qKlxuICogVGhpcyBldmVudCBpcyB0aGUgb3V0cHV0IG9mIGF1ZGlvIHRyYW5zY3JpcHRpb24gZm9yIHVzZXIgYXVkaW8gd3JpdHRlbiB0byB0aGVcbiAqIHVzZXIgYXVkaW8gYnVmZmVyLiBUcmFuc2NyaXB0aW9uIGJlZ2lucyB3aGVuIHRoZSBpbnB1dCBhdWRpbyBidWZmZXIgaXMgY29tbWl0dGVkXG4gKiBieSB0aGUgY2xpZW50IG9yIHNlcnZlciAoaW4gYHNlcnZlcl92YWRgIG1vZGUpLiBUcmFuc2NyaXB0aW9uIHJ1bnNcbiAqIGFzeW5jaHJvbm91c2x5IHdpdGggUmVzcG9uc2UgY3JlYXRpb24sIHNvIHRoaXMgZXZlbnQgbWF5IGNvbWUgYmVmb3JlIG9yIGFmdGVyXG4gKiB0aGUgUmVzcG9uc2UgZXZlbnRzLlxuICpcbiAqIFJlYWx0aW1lIEFQSSBtb2RlbHMgYWNjZXB0IGF1ZGlvIG5hdGl2ZWx5LCBhbmQgdGh1cyBpbnB1dCB0cmFuc2NyaXB0aW9uIGlzIGFcbiAqIHNlcGFyYXRlIHByb2Nlc3MgcnVuIG9uIGEgc2VwYXJhdGUgQVNSIChBdXRvbWF0aWMgU3BlZWNoIFJlY29nbml0aW9uKSBtb2RlbCxcbiAqIGN1cnJlbnRseSBhbHdheXMgYHdoaXNwZXItMWAuIFRodXMgdGhlIHRyYW5zY3JpcHQgbWF5IGRpdmVyZ2Ugc29tZXdoYXQgZnJvbSB0aGVcbiAqIG1vZGVsJ3MgaW50ZXJwcmV0YXRpb24sIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHJvdWdoIGd1aWRlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbkl0ZW1JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbkNvbXBsZXRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGNvbnRhaW5pbmcgdGhlIGF1ZGlvLlxuICAgKi9cbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHVzZXIgbWVzc2FnZSBpdGVtIGNvbnRhaW5pbmcgdGhlIGF1ZGlvLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNjcmliZWQgdGV4dC5cbiAgICovXG4gIHRyYW5zY3JpcHQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGNvbnZlcnNhdGlvbi5pdGVtLmlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24uY29tcGxldGVkYC5cbiAgICovXG4gIHR5cGU6ICdjb252ZXJzYXRpb24uaXRlbS5pbnB1dF9hdWRpb190cmFuc2NyaXB0aW9uLmNvbXBsZXRlZCc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBpbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uIGlzIGNvbmZpZ3VyZWQsIGFuZCBhIHRyYW5zY3JpcHRpb25cbiAqIHJlcXVlc3QgZm9yIGEgdXNlciBtZXNzYWdlIGZhaWxlZC4gVGhlc2UgZXZlbnRzIGFyZSBzZXBhcmF0ZSBmcm9tIG90aGVyIGBlcnJvcmBcbiAqIGV2ZW50cyBzbyB0aGF0IHRoZSBjbGllbnQgY2FuIGlkZW50aWZ5IHRoZSByZWxhdGVkIEl0ZW0uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uSXRlbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uRmFpbGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgY29udGFpbmluZyB0aGUgYXVkaW8uXG4gICAqL1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIERldGFpbHMgb2YgdGhlIHRyYW5zY3JpcHRpb24gZXJyb3IuXG4gICAqL1xuICBlcnJvcjogQ29udmVyc2F0aW9uSXRlbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uRmFpbGVkRXZlbnQuRXJyb3I7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdXNlciBtZXNzYWdlIGl0ZW0uXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBjb252ZXJzYXRpb24uaXRlbS5pbnB1dF9hdWRpb190cmFuc2NyaXB0aW9uLmZhaWxlZGAuXG4gICAqL1xuICB0eXBlOiAnY29udmVyc2F0aW9uLml0ZW0uaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbi5mYWlsZWQnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENvbnZlcnNhdGlvbkl0ZW1JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbkZhaWxlZEV2ZW50IHtcbiAgLyoqXG4gICAqIERldGFpbHMgb2YgdGhlIHRyYW5zY3JpcHRpb24gZXJyb3IuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlLCBpZiBhbnkuXG4gICAgICovXG4gICAgY29kZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEEgaHVtYW4tcmVhZGFibGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUGFyYW1ldGVyIHJlbGF0ZWQgdG8gdGhlIGVycm9yLCBpZiBhbnkuXG4gICAgICovXG4gICAgcGFyYW0/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBlcnJvci5cbiAgICAgKi9cbiAgICB0eXBlPzogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogU2VuZCB0aGlzIGV2ZW50IHRvIHRydW5jYXRlIGEgcHJldmlvdXMgYXNzaXN0YW50IG1lc3NhZ2VcdTIwMTlzIGF1ZGlvLiBUaGUgc2VydmVyXG4gKiB3aWxsIHByb2R1Y2UgYXVkaW8gZmFzdGVyIHRoYW4gcmVhbHRpbWUsIHNvIHRoaXMgZXZlbnQgaXMgdXNlZnVsIHdoZW4gdGhlIHVzZXJcbiAqIGludGVycnVwdHMgdG8gdHJ1bmNhdGUgYXVkaW8gdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHNlbnQgdG8gdGhlIGNsaWVudCBidXQgbm90XG4gKiB5ZXQgcGxheWVkLiBUaGlzIHdpbGwgc3luY2hyb25pemUgdGhlIHNlcnZlcidzIHVuZGVyc3RhbmRpbmcgb2YgdGhlIGF1ZGlvIHdpdGhcbiAqIHRoZSBjbGllbnQncyBwbGF5YmFjay5cbiAqXG4gKiBUcnVuY2F0aW5nIGF1ZGlvIHdpbGwgZGVsZXRlIHRoZSBzZXJ2ZXItc2lkZSB0ZXh0IHRyYW5zY3JpcHQgdG8gZW5zdXJlIHRoZXJlIGlzXG4gKiBub3QgdGV4dCBpbiB0aGUgY29udGV4dCB0aGF0IGhhc24ndCBiZWVuIGhlYXJkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIElmIHN1Y2Nlc3NmdWwsIHRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kIHdpdGggYSBgY29udmVyc2F0aW9uLml0ZW0udHJ1bmNhdGVkYFxuICogZXZlbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uSXRlbVRydW5jYXRlRXZlbnQge1xuICAvKipcbiAgICogSW5jbHVzaXZlIGR1cmF0aW9uIHVwIHRvIHdoaWNoIGF1ZGlvIGlzIHRydW5jYXRlZCwgaW4gbWlsbGlzZWNvbmRzLiBJZiB0aGVcbiAgICogYXVkaW9fZW5kX21zIGlzIGdyZWF0ZXIgdGhhbiB0aGUgYWN0dWFsIGF1ZGlvIGR1cmF0aW9uLCB0aGUgc2VydmVyIHdpbGwgcmVzcG9uZFxuICAgKiB3aXRoIGFuIGVycm9yLlxuICAgKi9cbiAgYXVkaW9fZW5kX21zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IHRvIHRydW5jYXRlLiBTZXQgdGhpcyB0byAwLlxuICAgKi9cbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGFzc2lzdGFudCBtZXNzYWdlIGl0ZW0gdG8gdHJ1bmNhdGUuIE9ubHkgYXNzaXN0YW50IG1lc3NhZ2UgaXRlbXNcbiAgICogY2FuIGJlIHRydW5jYXRlZC5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGNvbnZlcnNhdGlvbi5pdGVtLnRydW5jYXRlYC5cbiAgICovXG4gIHR5cGU6ICdjb252ZXJzYXRpb24uaXRlbS50cnVuY2F0ZSc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGNsaWVudC1nZW5lcmF0ZWQgSUQgdXNlZCB0byBpZGVudGlmeSB0aGlzIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhbiBlYXJsaWVyIGFzc2lzdGFudCBhdWRpbyBtZXNzYWdlIGl0ZW0gaXMgdHJ1bmNhdGVkIGJ5IHRoZSBjbGllbnRcbiAqIHdpdGggYSBgY29udmVyc2F0aW9uLml0ZW0udHJ1bmNhdGVgIGV2ZW50LiBUaGlzIGV2ZW50IGlzIHVzZWQgdG8gc3luY2hyb25pemUgdGhlXG4gKiBzZXJ2ZXIncyB1bmRlcnN0YW5kaW5nIG9mIHRoZSBhdWRpbyB3aXRoIHRoZSBjbGllbnQncyBwbGF5YmFjay5cbiAqXG4gKiBUaGlzIGFjdGlvbiB3aWxsIHRydW5jYXRlIHRoZSBhdWRpbyBhbmQgcmVtb3ZlIHRoZSBzZXJ2ZXItc2lkZSB0ZXh0IHRyYW5zY3JpcHRcbiAqIHRvIGVuc3VyZSB0aGVyZSBpcyBubyB0ZXh0IGluIHRoZSBjb250ZXh0IHRoYXQgaGFzbid0IGJlZW4gaGVhcmQgYnkgdGhlIHVzZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uSXRlbVRydW5jYXRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBkdXJhdGlvbiB1cCB0byB3aGljaCB0aGUgYXVkaW8gd2FzIHRydW5jYXRlZCwgaW4gbWlsbGlzZWNvbmRzLlxuICAgKi9cbiAgYXVkaW9fZW5kX21zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IHRoYXQgd2FzIHRydW5jYXRlZC5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBhc3Npc3RhbnQgbWVzc2FnZSBpdGVtIHRoYXQgd2FzIHRydW5jYXRlZC5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGNvbnZlcnNhdGlvbi5pdGVtLnRydW5jYXRlZGAuXG4gICAqL1xuICB0eXBlOiAnY29udmVyc2F0aW9uLml0ZW0udHJ1bmNhdGVkJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGFuIGVycm9yIG9jY3Vycywgd2hpY2ggY291bGQgYmUgYSBjbGllbnQgcHJvYmxlbSBvciBhIHNlcnZlclxuICogcHJvYmxlbS4gTW9zdCBlcnJvcnMgYXJlIHJlY292ZXJhYmxlIGFuZCB0aGUgc2Vzc2lvbiB3aWxsIHN0YXkgb3Blbiwgd2VcbiAqIHJlY29tbWVuZCB0byBpbXBsZW1lbnRvcnMgdG8gbW9uaXRvciBhbmQgbG9nIGVycm9yIG1lc3NhZ2VzIGJ5IGRlZmF1bHQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JFdmVudCB7XG4gIC8qKlxuICAgKiBEZXRhaWxzIG9mIHRoZSBlcnJvci5cbiAgICovXG4gIGVycm9yOiBFcnJvckV2ZW50LkVycm9yO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgZXJyb3JgLlxuICAgKi9cbiAgdHlwZTogJ2Vycm9yJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBFcnJvckV2ZW50IHtcbiAgLyoqXG4gICAqIERldGFpbHMgb2YgdGhlIGVycm9yLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBFcnJvciB7XG4gICAgLyoqXG4gICAgICogQSBodW1hbi1yZWFkYWJsZSBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIG1lc3NhZ2U6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIGVycm9yIChlLmcuLCBcImludmFsaWRfcmVxdWVzdF9lcnJvclwiLCBcInNlcnZlcl9lcnJvclwiKS5cbiAgICAgKi9cbiAgICB0eXBlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlLCBpZiBhbnkuXG4gICAgICovXG4gICAgY29kZT86IHN0cmluZyB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnRfaWQgb2YgdGhlIGNsaWVudCBldmVudCB0aGF0IGNhdXNlZCB0aGUgZXJyb3IsIGlmIGFwcGxpY2FibGUuXG4gICAgICovXG4gICAgZXZlbnRfaWQ/OiBzdHJpbmcgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUGFyYW1ldGVyIHJlbGF0ZWQgdG8gdGhlIGVycm9yLCBpZiBhbnkuXG4gICAgICovXG4gICAgcGFyYW0/OiBzdHJpbmcgfCBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2VuZCB0aGlzIGV2ZW50IHRvIGFwcGVuZCBhdWRpbyBieXRlcyB0byB0aGUgaW5wdXQgYXVkaW8gYnVmZmVyLiBUaGUgYXVkaW9cbiAqIGJ1ZmZlciBpcyB0ZW1wb3Jhcnkgc3RvcmFnZSB5b3UgY2FuIHdyaXRlIHRvIGFuZCBsYXRlciBjb21taXQuIEluIFNlcnZlciBWQURcbiAqIG1vZGUsIHRoZSBhdWRpbyBidWZmZXIgaXMgdXNlZCB0byBkZXRlY3Qgc3BlZWNoIGFuZCB0aGUgc2VydmVyIHdpbGwgZGVjaWRlIHdoZW5cbiAqIHRvIGNvbW1pdC4gV2hlbiBTZXJ2ZXIgVkFEIGlzIGRpc2FibGVkLCB5b3UgbXVzdCBjb21taXQgdGhlIGF1ZGlvIGJ1ZmZlclxuICogbWFudWFsbHkuXG4gKlxuICogVGhlIGNsaWVudCBtYXkgY2hvb3NlIGhvdyBtdWNoIGF1ZGlvIHRvIHBsYWNlIGluIGVhY2ggZXZlbnQgdXAgdG8gYSBtYXhpbXVtIG9mXG4gKiAxNSBNaUIsIGZvciBleGFtcGxlIHN0cmVhbWluZyBzbWFsbGVyIGNodW5rcyBmcm9tIHRoZSBjbGllbnQgbWF5IGFsbG93IHRoZSBWQURcbiAqIHRvIGJlIG1vcmUgcmVzcG9uc2l2ZS4gVW5saWtlIG1hZGUgb3RoZXIgY2xpZW50IGV2ZW50cywgdGhlIHNlcnZlciB3aWxsIG5vdCBzZW5kXG4gKiBhIGNvbmZpcm1hdGlvbiByZXNwb25zZSB0byB0aGlzIGV2ZW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9CdWZmZXJBcHBlbmRFdmVudCB7XG4gIC8qKlxuICAgKiBCYXNlNjQtZW5jb2RlZCBhdWRpbyBieXRlcy4gVGhpcyBtdXN0IGJlIGluIHRoZSBmb3JtYXQgc3BlY2lmaWVkIGJ5IHRoZVxuICAgKiBgaW5wdXRfYXVkaW9fZm9ybWF0YCBmaWVsZCBpbiB0aGUgc2Vzc2lvbiBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgYXVkaW86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGlucHV0X2F1ZGlvX2J1ZmZlci5hcHBlbmRgLlxuICAgKi9cbiAgdHlwZTogJ2lucHV0X2F1ZGlvX2J1ZmZlci5hcHBlbmQnO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjbGllbnQtZ2VuZXJhdGVkIElEIHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFNlbmQgdGhpcyBldmVudCB0byBjbGVhciB0aGUgYXVkaW8gYnl0ZXMgaW4gdGhlIGJ1ZmZlci4gVGhlIHNlcnZlciB3aWxsIHJlc3BvbmRcbiAqIHdpdGggYW4gYGlucHV0X2F1ZGlvX2J1ZmZlci5jbGVhcmVkYCBldmVudC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvQnVmZmVyQ2xlYXJFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgaW5wdXRfYXVkaW9fYnVmZmVyLmNsZWFyYC5cbiAgICovXG4gIHR5cGU6ICdpbnB1dF9hdWRpb19idWZmZXIuY2xlYXInO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjbGllbnQtZ2VuZXJhdGVkIElEIHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gdGhlIGlucHV0IGF1ZGlvIGJ1ZmZlciBpcyBjbGVhcmVkIGJ5IHRoZSBjbGllbnQgd2l0aCBhXG4gKiBgaW5wdXRfYXVkaW9fYnVmZmVyLmNsZWFyYCBldmVudC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvQnVmZmVyQ2xlYXJlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBpbnB1dF9hdWRpb19idWZmZXIuY2xlYXJlZGAuXG4gICAqL1xuICB0eXBlOiAnaW5wdXRfYXVkaW9fYnVmZmVyLmNsZWFyZWQnO1xufVxuXG4vKipcbiAqIFNlbmQgdGhpcyBldmVudCB0byBjb21taXQgdGhlIHVzZXIgaW5wdXQgYXVkaW8gYnVmZmVyLCB3aGljaCB3aWxsIGNyZWF0ZSBhIG5ld1xuICogdXNlciBtZXNzYWdlIGl0ZW0gaW4gdGhlIGNvbnZlcnNhdGlvbi4gVGhpcyBldmVudCB3aWxsIHByb2R1Y2UgYW4gZXJyb3IgaWYgdGhlXG4gKiBpbnB1dCBhdWRpbyBidWZmZXIgaXMgZW1wdHkuIFdoZW4gaW4gU2VydmVyIFZBRCBtb2RlLCB0aGUgY2xpZW50IGRvZXMgbm90IG5lZWRcbiAqIHRvIHNlbmQgdGhpcyBldmVudCwgdGhlIHNlcnZlciB3aWxsIGNvbW1pdCB0aGUgYXVkaW8gYnVmZmVyIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogQ29tbWl0dGluZyB0aGUgaW5wdXQgYXVkaW8gYnVmZmVyIHdpbGwgdHJpZ2dlciBpbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uIChpZlxuICogZW5hYmxlZCBpbiBzZXNzaW9uIGNvbmZpZ3VyYXRpb24pLCBidXQgaXQgd2lsbCBub3QgY3JlYXRlIGEgcmVzcG9uc2UgZnJvbSB0aGVcbiAqIG1vZGVsLiBUaGUgc2VydmVyIHdpbGwgcmVzcG9uZCB3aXRoIGFuIGBpbnB1dF9hdWRpb19idWZmZXIuY29tbWl0dGVkYCBldmVudC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvQnVmZmVyQ29tbWl0RXZlbnQge1xuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGlucHV0X2F1ZGlvX2J1ZmZlci5jb21taXRgLlxuICAgKi9cbiAgdHlwZTogJ2lucHV0X2F1ZGlvX2J1ZmZlci5jb21taXQnO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjbGllbnQtZ2VuZXJhdGVkIElEIHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYW4gaW5wdXQgYXVkaW8gYnVmZmVyIGlzIGNvbW1pdHRlZCwgZWl0aGVyIGJ5IHRoZSBjbGllbnQgb3JcbiAqIGF1dG9tYXRpY2FsbHkgaW4gc2VydmVyIFZBRCBtb2RlLiBUaGUgYGl0ZW1faWRgIHByb3BlcnR5IGlzIHRoZSBJRCBvZiB0aGUgdXNlclxuICogbWVzc2FnZSBpdGVtIHRoYXQgd2lsbCBiZSBjcmVhdGVkLCB0aHVzIGEgYGNvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZWRgIGV2ZW50IHdpbGxcbiAqIGFsc28gYmUgc2VudCB0byB0aGUgY2xpZW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9CdWZmZXJDb21taXR0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHVzZXIgbWVzc2FnZSBpdGVtIHRoYXQgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHByZWNlZGluZyBpdGVtIGFmdGVyIHdoaWNoIHRoZSBuZXcgaXRlbSB3aWxsIGJlIGluc2VydGVkLlxuICAgKi9cbiAgcHJldmlvdXNfaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgaW5wdXRfYXVkaW9fYnVmZmVyLmNvbW1pdHRlZGAuXG4gICAqL1xuICB0eXBlOiAnaW5wdXRfYXVkaW9fYnVmZmVyLmNvbW1pdHRlZCc7XG59XG5cbi8qKlxuICogU2VudCBieSB0aGUgc2VydmVyIHdoZW4gaW4gYHNlcnZlcl92YWRgIG1vZGUgdG8gaW5kaWNhdGUgdGhhdCBzcGVlY2ggaGFzIGJlZW5cbiAqIGRldGVjdGVkIGluIHRoZSBhdWRpbyBidWZmZXIuIFRoaXMgY2FuIGhhcHBlbiBhbnkgdGltZSBhdWRpbyBpcyBhZGRlZCB0byB0aGVcbiAqIGJ1ZmZlciAodW5sZXNzIHNwZWVjaCBpcyBhbHJlYWR5IGRldGVjdGVkKS4gVGhlIGNsaWVudCBtYXkgd2FudCB0byB1c2UgdGhpc1xuICogZXZlbnQgdG8gaW50ZXJydXB0IGF1ZGlvIHBsYXliYWNrIG9yIHByb3ZpZGUgdmlzdWFsIGZlZWRiYWNrIHRvIHRoZSB1c2VyLlxuICpcbiAqIFRoZSBjbGllbnQgc2hvdWxkIGV4cGVjdCB0byByZWNlaXZlIGEgYGlucHV0X2F1ZGlvX2J1ZmZlci5zcGVlY2hfc3RvcHBlZGAgZXZlbnRcbiAqIHdoZW4gc3BlZWNoIHN0b3BzLiBUaGUgYGl0ZW1faWRgIHByb3BlcnR5IGlzIHRoZSBJRCBvZiB0aGUgdXNlciBtZXNzYWdlIGl0ZW1cbiAqIHRoYXQgd2lsbCBiZSBjcmVhdGVkIHdoZW4gc3BlZWNoIHN0b3BzIGFuZCB3aWxsIGFsc28gYmUgaW5jbHVkZWQgaW4gdGhlXG4gKiBgaW5wdXRfYXVkaW9fYnVmZmVyLnNwZWVjaF9zdG9wcGVkYCBldmVudCAodW5sZXNzIHRoZSBjbGllbnQgbWFudWFsbHkgY29tbWl0c1xuICogdGhlIGF1ZGlvIGJ1ZmZlciBkdXJpbmcgVkFEIGFjdGl2YXRpb24pLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9CdWZmZXJTcGVlY2hTdGFydGVkRXZlbnQge1xuICAvKipcbiAgICogTWlsbGlzZWNvbmRzIGZyb20gdGhlIHN0YXJ0IG9mIGFsbCBhdWRpbyB3cml0dGVuIHRvIHRoZSBidWZmZXIgZHVyaW5nIHRoZVxuICAgKiBzZXNzaW9uIHdoZW4gc3BlZWNoIHdhcyBmaXJzdCBkZXRlY3RlZC4gVGhpcyB3aWxsIGNvcnJlc3BvbmQgdG8gdGhlIGJlZ2lubmluZyBvZlxuICAgKiBhdWRpbyBzZW50IHRvIHRoZSBtb2RlbCwgYW5kIHRodXMgaW5jbHVkZXMgdGhlIGBwcmVmaXhfcGFkZGluZ19tc2AgY29uZmlndXJlZCBpblxuICAgKiB0aGUgU2Vzc2lvbi5cbiAgICovXG4gIGF1ZGlvX3N0YXJ0X21zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdXNlciBtZXNzYWdlIGl0ZW0gdGhhdCB3aWxsIGJlIGNyZWF0ZWQgd2hlbiBzcGVlY2ggc3RvcHMuXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBpbnB1dF9hdWRpb19idWZmZXIuc3BlZWNoX3N0YXJ0ZWRgLlxuICAgKi9cbiAgdHlwZTogJ2lucHV0X2F1ZGlvX2J1ZmZlci5zcGVlY2hfc3RhcnRlZCc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgaW4gYHNlcnZlcl92YWRgIG1vZGUgd2hlbiB0aGUgc2VydmVyIGRldGVjdHMgdGhlIGVuZCBvZiBzcGVlY2ggaW4gdGhlXG4gKiBhdWRpbyBidWZmZXIuIFRoZSBzZXJ2ZXIgd2lsbCBhbHNvIHNlbmQgYW4gYGNvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZWRgIGV2ZW50XG4gKiB3aXRoIHRoZSB1c2VyIG1lc3NhZ2UgaXRlbSB0aGF0IGlzIGNyZWF0ZWQgZnJvbSB0aGUgYXVkaW8gYnVmZmVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9CdWZmZXJTcGVlY2hTdG9wcGVkRXZlbnQge1xuICAvKipcbiAgICogTWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBzZXNzaW9uIHN0YXJ0ZWQgd2hlbiBzcGVlY2ggc3RvcHBlZC4gVGhpcyB3aWxsIGNvcnJlc3BvbmRcbiAgICogdG8gdGhlIGVuZCBvZiBhdWRpbyBzZW50IHRvIHRoZSBtb2RlbCwgYW5kIHRodXMgaW5jbHVkZXMgdGhlXG4gICAqIGBtaW5fc2lsZW5jZV9kdXJhdGlvbl9tc2AgY29uZmlndXJlZCBpbiB0aGUgU2Vzc2lvbi5cbiAgICovXG4gIGF1ZGlvX2VuZF9tczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHVzZXIgbWVzc2FnZSBpdGVtIHRoYXQgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgaW5wdXRfYXVkaW9fYnVmZmVyLnNwZWVjaF9zdG9wcGVkYC5cbiAgICovXG4gIHR5cGU6ICdpbnB1dF9hdWRpb19idWZmZXIuc3BlZWNoX3N0b3BwZWQnO1xufVxuXG4vKipcbiAqIEVtaXR0ZWQgYXQgdGhlIGJlZ2lubmluZyBvZiBhIFJlc3BvbnNlIHRvIGluZGljYXRlIHRoZSB1cGRhdGVkIHJhdGUgbGltaXRzLiBXaGVuXG4gKiBhIFJlc3BvbnNlIGlzIGNyZWF0ZWQgc29tZSB0b2tlbnMgd2lsbCBiZSBcInJlc2VydmVkXCIgZm9yIHRoZSBvdXRwdXQgdG9rZW5zLCB0aGVcbiAqIHJhdGUgbGltaXRzIHNob3duIGhlcmUgcmVmbGVjdCB0aGF0IHJlc2VydmF0aW9uLCB3aGljaCBpcyB0aGVuIGFkanVzdGVkXG4gKiBhY2NvcmRpbmdseSBvbmNlIHRoZSBSZXNwb25zZSBpcyBjb21wbGV0ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmF0ZUxpbWl0c1VwZGF0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHJhdGUgbGltaXQgaW5mb3JtYXRpb24uXG4gICAqL1xuICByYXRlX2xpbWl0czogQXJyYXk8UmF0ZUxpbWl0c1VwZGF0ZWRFdmVudC5SYXRlTGltaXQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmF0ZV9saW1pdHMudXBkYXRlZGAuXG4gICAqL1xuICB0eXBlOiAncmF0ZV9saW1pdHMudXBkYXRlZCc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUmF0ZUxpbWl0c1VwZGF0ZWRFdmVudCB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgUmF0ZUxpbWl0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlIGZvciB0aGUgcmF0ZSBsaW1pdC5cbiAgICAgKi9cbiAgICBsaW1pdD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSByYXRlIGxpbWl0IChgcmVxdWVzdHNgLCBgdG9rZW5zYCkuXG4gICAgICovXG4gICAgbmFtZT86ICdyZXF1ZXN0cycgfCAndG9rZW5zJztcblxuICAgIC8qKlxuICAgICAqIFRoZSByZW1haW5pbmcgdmFsdWUgYmVmb3JlIHRoZSBsaW1pdCBpcyByZWFjaGVkLlxuICAgICAqL1xuICAgIHJlbWFpbmluZz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFNlY29uZHMgdW50aWwgdGhlIHJhdGUgbGltaXQgcmVzZXRzLlxuICAgICAqL1xuICAgIHJlc2V0X3NlY29uZHM/OiBudW1iZXI7XG4gIH1cbn1cblxuLyoqXG4gKiBBbGwgZXZlbnRzIHRoYXQgdGhlIGNsaWVudCBjYW4gc2VuZCB0byB0aGUgUmVhbHRpbWUgQVBJXG4gKi9cbmV4cG9ydCB0eXBlIFJlYWx0aW1lQ2xpZW50RXZlbnQgPVxuICB8IFNlc3Npb25VcGRhdGVFdmVudFxuICB8IElucHV0QXVkaW9CdWZmZXJBcHBlbmRFdmVudFxuICB8IElucHV0QXVkaW9CdWZmZXJDb21taXRFdmVudFxuICB8IElucHV0QXVkaW9CdWZmZXJDbGVhckV2ZW50XG4gIHwgQ29udmVyc2F0aW9uSXRlbUNyZWF0ZUV2ZW50XG4gIHwgQ29udmVyc2F0aW9uSXRlbVRydW5jYXRlRXZlbnRcbiAgfCBDb252ZXJzYXRpb25JdGVtRGVsZXRlRXZlbnRcbiAgfCBSZXNwb25zZUNyZWF0ZUV2ZW50XG4gIHwgUmVzcG9uc2VDYW5jZWxFdmVudDtcblxuLyoqXG4gKiBUaGUgcmVzcG9uc2UgcmVzb3VyY2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVhbHRpbWVSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSByZXNwb25zZS5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZXZlbG9wZXItcHJvdmlkZWQgc3RyaW5nIGtleS12YWx1ZSBwYWlycyBhc3NvY2lhdGVkIHdpdGggdGhpcyByZXNwb25zZS5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgbXVzdCBiZSBgcmVhbHRpbWUucmVzcG9uc2VgLlxuICAgKi9cbiAgb2JqZWN0PzogJ3JlYWx0aW1lLnJlc3BvbnNlJztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2Ygb3V0cHV0IGl0ZW1zIGdlbmVyYXRlZCBieSB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXQ/OiBBcnJheTxDb252ZXJzYXRpb25JdGVtPjtcblxuICAvKipcbiAgICogVGhlIGZpbmFsIHN0YXR1cyBvZiB0aGUgcmVzcG9uc2UgKGBjb21wbGV0ZWRgLCBgY2FuY2VsbGVkYCwgYGZhaWxlZGAsIG9yXG4gICAqIGBpbmNvbXBsZXRlYCkuXG4gICAqL1xuICBzdGF0dXM/OiAnY29tcGxldGVkJyB8ICdjYW5jZWxsZWQnIHwgJ2ZhaWxlZCcgfCAnaW5jb21wbGV0ZSc7XG5cbiAgLyoqXG4gICAqIEFkZGl0aW9uYWwgZGV0YWlscyBhYm91dCB0aGUgc3RhdHVzLlxuICAgKi9cbiAgc3RhdHVzX2RldGFpbHM/OiBSZWFsdGltZVJlc3BvbnNlU3RhdHVzO1xuXG4gIC8qKlxuICAgKiBVc2FnZSBzdGF0aXN0aWNzIGZvciB0aGUgUmVzcG9uc2UsIHRoaXMgd2lsbCBjb3JyZXNwb25kIHRvIGJpbGxpbmcuIEEgUmVhbHRpbWVcbiAgICogQVBJIHNlc3Npb24gd2lsbCBtYWludGFpbiBhIGNvbnZlcnNhdGlvbiBjb250ZXh0IGFuZCBhcHBlbmQgbmV3IEl0ZW1zIHRvIHRoZVxuICAgKiBDb252ZXJzYXRpb24sIHRodXMgb3V0cHV0IGZyb20gcHJldmlvdXMgdHVybnMgKHRleHQgYW5kIGF1ZGlvIHRva2Vucykgd2lsbFxuICAgKiBiZWNvbWUgdGhlIGlucHV0IGZvciBsYXRlciB0dXJucy5cbiAgICovXG4gIHVzYWdlPzogUmVhbHRpbWVSZXNwb25zZVVzYWdlO1xufVxuXG4vKipcbiAqIEFkZGl0aW9uYWwgZGV0YWlscyBhYm91dCB0aGUgc3RhdHVzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlYWx0aW1lUmVzcG9uc2VTdGF0dXMge1xuICAvKipcbiAgICogQSBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3IgdGhhdCBjYXVzZWQgdGhlIHJlc3BvbnNlIHRvIGZhaWwsIHBvcHVsYXRlZCB3aGVuIHRoZVxuICAgKiBgc3RhdHVzYCBpcyBgZmFpbGVkYC5cbiAgICovXG4gIGVycm9yPzogUmVhbHRpbWVSZXNwb25zZVN0YXR1cy5FcnJvcjtcblxuICAvKipcbiAgICogVGhlIHJlYXNvbiB0aGUgUmVzcG9uc2UgZGlkIG5vdCBjb21wbGV0ZS4gRm9yIGEgYGNhbmNlbGxlZGAgUmVzcG9uc2UsIG9uZSBvZlxuICAgKiBgdHVybl9kZXRlY3RlZGAgKHRoZSBzZXJ2ZXIgVkFEIGRldGVjdGVkIGEgbmV3IHN0YXJ0IG9mIHNwZWVjaCkgb3JcbiAgICogYGNsaWVudF9jYW5jZWxsZWRgICh0aGUgY2xpZW50IHNlbnQgYSBjYW5jZWwgZXZlbnQpLiBGb3IgYW4gYGluY29tcGxldGVgXG4gICAqIFJlc3BvbnNlLCBvbmUgb2YgYG1heF9vdXRwdXRfdG9rZW5zYCBvciBgY29udGVudF9maWx0ZXJgICh0aGUgc2VydmVyLXNpZGUgc2FmZXR5XG4gICAqIGZpbHRlciBhY3RpdmF0ZWQgYW5kIGN1dCBvZmYgdGhlIHJlc3BvbnNlKS5cbiAgICovXG4gIHJlYXNvbj86ICd0dXJuX2RldGVjdGVkJyB8ICdjbGllbnRfY2FuY2VsbGVkJyB8ICdtYXhfb3V0cHV0X3Rva2VucycgfCAnY29udGVudF9maWx0ZXInO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBlcnJvciB0aGF0IGNhdXNlZCB0aGUgcmVzcG9uc2UgdG8gZmFpbCwgY29ycmVzcG9uZGluZyB3aXRoIHRoZVxuICAgKiBgc3RhdHVzYCBmaWVsZCAoYGNvbXBsZXRlZGAsIGBjYW5jZWxsZWRgLCBgaW5jb21wbGV0ZWAsIGBmYWlsZWRgKS5cbiAgICovXG4gIHR5cGU/OiAnY29tcGxldGVkJyB8ICdjYW5jZWxsZWQnIHwgJ2luY29tcGxldGUnIHwgJ2ZhaWxlZCc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUmVhbHRpbWVSZXNwb25zZVN0YXR1cyB7XG4gIC8qKlxuICAgKiBBIGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvciB0aGF0IGNhdXNlZCB0aGUgcmVzcG9uc2UgdG8gZmFpbCwgcG9wdWxhdGVkIHdoZW4gdGhlXG4gICAqIGBzdGF0dXNgIGlzIGBmYWlsZWRgLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBFcnJvciB7XG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSwgaWYgYW55LlxuICAgICAqL1xuICAgIGNvZGU/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBlcnJvci5cbiAgICAgKi9cbiAgICB0eXBlPzogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogVXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIFJlc3BvbnNlLCB0aGlzIHdpbGwgY29ycmVzcG9uZCB0byBiaWxsaW5nLiBBIFJlYWx0aW1lXG4gKiBBUEkgc2Vzc2lvbiB3aWxsIG1haW50YWluIGEgY29udmVyc2F0aW9uIGNvbnRleHQgYW5kIGFwcGVuZCBuZXcgSXRlbXMgdG8gdGhlXG4gKiBDb252ZXJzYXRpb24sIHRodXMgb3V0cHV0IGZyb20gcHJldmlvdXMgdHVybnMgKHRleHQgYW5kIGF1ZGlvIHRva2Vucykgd2lsbFxuICogYmVjb21lIHRoZSBpbnB1dCBmb3IgbGF0ZXIgdHVybnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVhbHRpbWVSZXNwb25zZVVzYWdlIHtcbiAgLyoqXG4gICAqIERldGFpbHMgYWJvdXQgdGhlIGlucHV0IHRva2VucyB1c2VkIGluIHRoZSBSZXNwb25zZS5cbiAgICovXG4gIGlucHV0X3Rva2VuX2RldGFpbHM/OiBSZWFsdGltZVJlc3BvbnNlVXNhZ2UuSW5wdXRUb2tlbkRldGFpbHM7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgaW5wdXQgdG9rZW5zIHVzZWQgaW4gdGhlIFJlc3BvbnNlLCBpbmNsdWRpbmcgdGV4dCBhbmQgYXVkaW9cbiAgICogdG9rZW5zLlxuICAgKi9cbiAgaW5wdXRfdG9rZW5zPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBEZXRhaWxzIGFib3V0IHRoZSBvdXRwdXQgdG9rZW5zIHVzZWQgaW4gdGhlIFJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0X3Rva2VuX2RldGFpbHM/OiBSZWFsdGltZVJlc3BvbnNlVXNhZ2UuT3V0cHV0VG9rZW5EZXRhaWxzO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIG91dHB1dCB0b2tlbnMgc2VudCBpbiB0aGUgUmVzcG9uc2UsIGluY2x1ZGluZyB0ZXh0IGFuZCBhdWRpb1xuICAgKiB0b2tlbnMuXG4gICAqL1xuICBvdXRwdXRfdG9rZW5zPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIHRva2VucyBpbiB0aGUgUmVzcG9uc2UgaW5jbHVkaW5nIGlucHV0IGFuZCBvdXRwdXQgdGV4dCBhbmRcbiAgICogYXVkaW8gdG9rZW5zLlxuICAgKi9cbiAgdG90YWxfdG9rZW5zPzogbnVtYmVyO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJlYWx0aW1lUmVzcG9uc2VVc2FnZSB7XG4gIC8qKlxuICAgKiBEZXRhaWxzIGFib3V0IHRoZSBpbnB1dCB0b2tlbnMgdXNlZCBpbiB0aGUgUmVzcG9uc2UuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIElucHV0VG9rZW5EZXRhaWxzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGF1ZGlvIHRva2VucyB1c2VkIGluIHRoZSBSZXNwb25zZS5cbiAgICAgKi9cbiAgICBhdWRpb190b2tlbnM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGNhY2hlZCB0b2tlbnMgdXNlZCBpbiB0aGUgUmVzcG9uc2UuXG4gICAgICovXG4gICAgY2FjaGVkX3Rva2Vucz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgdGV4dCB0b2tlbnMgdXNlZCBpbiB0aGUgUmVzcG9uc2UuXG4gICAgICovXG4gICAgdGV4dF90b2tlbnM/OiBudW1iZXI7XG4gIH1cblxuICAvKipcbiAgICogRGV0YWlscyBhYm91dCB0aGUgb3V0cHV0IHRva2VucyB1c2VkIGluIHRoZSBSZXNwb25zZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgT3V0cHV0VG9rZW5EZXRhaWxzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGF1ZGlvIHRva2VucyB1c2VkIGluIHRoZSBSZXNwb25zZS5cbiAgICAgKi9cbiAgICBhdWRpb190b2tlbnM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRleHQgdG9rZW5zIHVzZWQgaW4gdGhlIFJlc3BvbnNlLlxuICAgICAqL1xuICAgIHRleHRfdG9rZW5zPzogbnVtYmVyO1xuICB9XG59XG5cbi8qKlxuICogQWxsIGV2ZW50cyB0aGF0IHRoZSBSZWFsdGltZSBBUEkgY2FuIHNlbmQgYmFja1xuICovXG5leHBvcnQgdHlwZSBSZWFsdGltZVNlcnZlckV2ZW50ID1cbiAgfCBFcnJvckV2ZW50XG4gIHwgU2Vzc2lvbkNyZWF0ZWRFdmVudFxuICB8IFNlc3Npb25VcGRhdGVkRXZlbnRcbiAgfCBDb252ZXJzYXRpb25DcmVhdGVkRXZlbnRcbiAgfCBJbnB1dEF1ZGlvQnVmZmVyQ29tbWl0dGVkRXZlbnRcbiAgfCBJbnB1dEF1ZGlvQnVmZmVyQ2xlYXJlZEV2ZW50XG4gIHwgSW5wdXRBdWRpb0J1ZmZlclNwZWVjaFN0YXJ0ZWRFdmVudFxuICB8IElucHV0QXVkaW9CdWZmZXJTcGVlY2hTdG9wcGVkRXZlbnRcbiAgfCBDb252ZXJzYXRpb25JdGVtQ3JlYXRlZEV2ZW50XG4gIHwgQ29udmVyc2F0aW9uSXRlbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uQ29tcGxldGVkRXZlbnRcbiAgfCBDb252ZXJzYXRpb25JdGVtSW5wdXRBdWRpb1RyYW5zY3JpcHRpb25GYWlsZWRFdmVudFxuICB8IENvbnZlcnNhdGlvbkl0ZW1UcnVuY2F0ZWRFdmVudFxuICB8IENvbnZlcnNhdGlvbkl0ZW1EZWxldGVkRXZlbnRcbiAgfCBSZXNwb25zZUNyZWF0ZWRFdmVudFxuICB8IFJlc3BvbnNlRG9uZUV2ZW50XG4gIHwgUmVzcG9uc2VPdXRwdXRJdGVtQWRkZWRFdmVudFxuICB8IFJlc3BvbnNlT3V0cHV0SXRlbURvbmVFdmVudFxuICB8IFJlc3BvbnNlQ29udGVudFBhcnRBZGRlZEV2ZW50XG4gIHwgUmVzcG9uc2VDb250ZW50UGFydERvbmVFdmVudFxuICB8IFJlc3BvbnNlVGV4dERlbHRhRXZlbnRcbiAgfCBSZXNwb25zZVRleHREb25lRXZlbnRcbiAgfCBSZXNwb25zZUF1ZGlvVHJhbnNjcmlwdERlbHRhRXZlbnRcbiAgfCBSZXNwb25zZUF1ZGlvVHJhbnNjcmlwdERvbmVFdmVudFxuICB8IFJlc3BvbnNlQXVkaW9EZWx0YUV2ZW50XG4gIHwgUmVzcG9uc2VBdWRpb0RvbmVFdmVudFxuICB8IFJlc3BvbnNlRnVuY3Rpb25DYWxsQXJndW1lbnRzRGVsdGFFdmVudFxuICB8IFJlc3BvbnNlRnVuY3Rpb25DYWxsQXJndW1lbnRzRG9uZUV2ZW50XG4gIHwgUmF0ZUxpbWl0c1VwZGF0ZWRFdmVudDtcblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIHRoZSBtb2RlbC1nZW5lcmF0ZWQgYXVkaW8gaXMgdXBkYXRlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUF1ZGlvRGVsdGFFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCBpbiB0aGUgaXRlbSdzIGNvbnRlbnQgYXJyYXkuXG4gICAqL1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEJhc2U2NC1lbmNvZGVkIGF1ZGlvIGRhdGEgZGVsdGEuXG4gICAqL1xuICBkZWx0YTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGl0ZW0uXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGl0ZW0gaW4gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UuYXVkaW8uZGVsdGFgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLmF1ZGlvLmRlbHRhJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIHRoZSBtb2RlbC1nZW5lcmF0ZWQgYXVkaW8gaXMgZG9uZS4gQWxzbyBlbWl0dGVkIHdoZW4gYSBSZXNwb25zZSBpc1xuICogaW50ZXJydXB0ZWQsIGluY29tcGxldGUsIG9yIGNhbmNlbGxlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUF1ZGlvRG9uZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGluIHRoZSBpdGVtJ3MgY29udGVudCBhcnJheS5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBpdGVtLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSByZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLmF1ZGlvLmRvbmVgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLmF1ZGlvLmRvbmUnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gdGhlIG1vZGVsLWdlbmVyYXRlZCB0cmFuc2NyaXB0aW9uIG9mIGF1ZGlvIG91dHB1dCBpcyB1cGRhdGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQXVkaW9UcmFuc2NyaXB0RGVsdGFFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCBpbiB0aGUgaXRlbSdzIGNvbnRlbnQgYXJyYXkuXG4gICAqL1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0cmFuc2NyaXB0IGRlbHRhLlxuICAgKi9cbiAgZGVsdGE6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBpdGVtLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSByZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLmF1ZGlvX3RyYW5zY3JpcHQuZGVsdGFgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLmF1ZGlvX3RyYW5zY3JpcHQuZGVsdGEnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gdGhlIG1vZGVsLWdlbmVyYXRlZCB0cmFuc2NyaXB0aW9uIG9mIGF1ZGlvIG91dHB1dCBpcyBkb25lXG4gKiBzdHJlYW1pbmcuIEFsc28gZW1pdHRlZCB3aGVuIGEgUmVzcG9uc2UgaXMgaW50ZXJydXB0ZWQsIGluY29tcGxldGUsIG9yXG4gKiBjYW5jZWxsZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VBdWRpb1RyYW5zY3JpcHREb25lRXZlbnQge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgaW4gdGhlIGl0ZW0ncyBjb250ZW50IGFycmF5LlxuICAgKi9cbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGl0ZW0uXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGl0ZW0gaW4gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZmluYWwgdHJhbnNjcmlwdCBvZiB0aGUgYXVkaW8uXG4gICAqL1xuICB0cmFuc2NyaXB0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5hdWRpb190cmFuc2NyaXB0LmRvbmVgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLmF1ZGlvX3RyYW5zY3JpcHQuZG9uZSc7XG59XG5cbi8qKlxuICogU2VuZCB0aGlzIGV2ZW50IHRvIGNhbmNlbCBhbiBpbi1wcm9ncmVzcyByZXNwb25zZS4gVGhlIHNlcnZlciB3aWxsIHJlc3BvbmQgd2l0aFxuICogYSBgcmVzcG9uc2UuY2FuY2VsbGVkYCBldmVudCBvciBhbiBlcnJvciBpZiB0aGVyZSBpcyBubyByZXNwb25zZSB0byBjYW5jZWwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VDYW5jZWxFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UuY2FuY2VsYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5jYW5jZWwnO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjbGllbnQtZ2VuZXJhdGVkIElEIHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIHNwZWNpZmljIHJlc3BvbnNlIElEIHRvIGNhbmNlbCAtIGlmIG5vdCBwcm92aWRlZCwgd2lsbCBjYW5jZWwgYW4gaW4tcHJvZ3Jlc3NcbiAgICogcmVzcG9uc2UgaW4gdGhlIGRlZmF1bHQgY29udmVyc2F0aW9uLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhIG5ldyBjb250ZW50IHBhcnQgaXMgYWRkZWQgdG8gYW4gYXNzaXN0YW50IG1lc3NhZ2UgaXRlbSBkdXJpbmdcbiAqIHJlc3BvbnNlIGdlbmVyYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VDb250ZW50UGFydEFkZGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgaW4gdGhlIGl0ZW0ncyBjb250ZW50IGFycmF5LlxuICAgKi9cbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGl0ZW0gdG8gd2hpY2ggdGhlIGNvbnRlbnQgcGFydCB3YXMgYWRkZWQuXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGl0ZW0gaW4gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IHBhcnQgdGhhdCB3YXMgYWRkZWQuXG4gICAqL1xuICBwYXJ0OiBSZXNwb25zZUNvbnRlbnRQYXJ0QWRkZWRFdmVudC5QYXJ0O1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLmNvbnRlbnRfcGFydC5hZGRlZGAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UuY29udGVudF9wYXJ0LmFkZGVkJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSZXNwb25zZUNvbnRlbnRQYXJ0QWRkZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBwYXJ0IHRoYXQgd2FzIGFkZGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBQYXJ0IHtcbiAgICAvKipcbiAgICAgKiBCYXNlNjQtZW5jb2RlZCBhdWRpbyBkYXRhIChpZiB0eXBlIGlzIFwiYXVkaW9cIikuXG4gICAgICovXG4gICAgYXVkaW8/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCBjb250ZW50IChpZiB0eXBlIGlzIFwidGV4dFwiKS5cbiAgICAgKi9cbiAgICB0ZXh0Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zY3JpcHQgb2YgdGhlIGF1ZGlvIChpZiB0eXBlIGlzIFwiYXVkaW9cIikuXG4gICAgICovXG4gICAgdHJhbnNjcmlwdD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZW50IHR5cGUgKFwidGV4dFwiLCBcImF1ZGlvXCIpLlxuICAgICAqL1xuICAgIHR5cGU/OiAndGV4dCcgfCAnYXVkaW8nO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhIGNvbnRlbnQgcGFydCBpcyBkb25lIHN0cmVhbWluZyBpbiBhbiBhc3Npc3RhbnQgbWVzc2FnZSBpdGVtLlxuICogQWxzbyBlbWl0dGVkIHdoZW4gYSBSZXNwb25zZSBpcyBpbnRlcnJ1cHRlZCwgaW5jb21wbGV0ZSwgb3IgY2FuY2VsbGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQ29udGVudFBhcnREb25lRXZlbnQge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgaW4gdGhlIGl0ZW0ncyBjb250ZW50IGFycmF5LlxuICAgKi9cbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGl0ZW0uXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGl0ZW0gaW4gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IHBhcnQgdGhhdCBpcyBkb25lLlxuICAgKi9cbiAgcGFydDogUmVzcG9uc2VDb250ZW50UGFydERvbmVFdmVudC5QYXJ0O1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLmNvbnRlbnRfcGFydC5kb25lYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5jb250ZW50X3BhcnQuZG9uZSc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUmVzcG9uc2VDb250ZW50UGFydERvbmVFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBwYXJ0IHRoYXQgaXMgZG9uZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgUGFydCB7XG4gICAgLyoqXG4gICAgICogQmFzZTY0LWVuY29kZWQgYXVkaW8gZGF0YSAoaWYgdHlwZSBpcyBcImF1ZGlvXCIpLlxuICAgICAqL1xuICAgIGF1ZGlvPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgY29udGVudCAoaWYgdHlwZSBpcyBcInRleHRcIikuXG4gICAgICovXG4gICAgdGV4dD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2NyaXB0IG9mIHRoZSBhdWRpbyAoaWYgdHlwZSBpcyBcImF1ZGlvXCIpLlxuICAgICAqL1xuICAgIHRyYW5zY3JpcHQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGVudCB0eXBlIChcInRleHRcIiwgXCJhdWRpb1wiKS5cbiAgICAgKi9cbiAgICB0eXBlPzogJ3RleHQnIHwgJ2F1ZGlvJztcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZXZlbnQgaW5zdHJ1Y3RzIHRoZSBzZXJ2ZXIgdG8gY3JlYXRlIGEgUmVzcG9uc2UsIHdoaWNoIG1lYW5zIHRyaWdnZXJpbmdcbiAqIG1vZGVsIGluZmVyZW5jZS4gV2hlbiBpbiBTZXJ2ZXIgVkFEIG1vZGUsIHRoZSBzZXJ2ZXIgd2lsbCBjcmVhdGUgUmVzcG9uc2VzXG4gKiBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIEEgUmVzcG9uc2Ugd2lsbCBpbmNsdWRlIGF0IGxlYXN0IG9uZSBJdGVtLCBhbmQgbWF5IGhhdmUgdHdvLCBpbiB3aGljaCBjYXNlIHRoZVxuICogc2Vjb25kIHdpbGwgYmUgYSBmdW5jdGlvbiBjYWxsLiBUaGVzZSBJdGVtcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBjb252ZXJzYXRpb25cbiAqIGhpc3RvcnkuXG4gKlxuICogVGhlIHNlcnZlciB3aWxsIHJlc3BvbmQgd2l0aCBhIGByZXNwb25zZS5jcmVhdGVkYCBldmVudCwgZXZlbnRzIGZvciBJdGVtcyBhbmRcbiAqIGNvbnRlbnQgY3JlYXRlZCwgYW5kIGZpbmFsbHkgYSBgcmVzcG9uc2UuZG9uZWAgZXZlbnQgdG8gaW5kaWNhdGUgdGhlIFJlc3BvbnNlIGlzXG4gKiBjb21wbGV0ZS5cbiAqXG4gKiBUaGUgYHJlc3BvbnNlLmNyZWF0ZWAgZXZlbnQgaW5jbHVkZXMgaW5mZXJlbmNlIGNvbmZpZ3VyYXRpb24gbGlrZVxuICogYGluc3RydWN0aW9uc2AsIGFuZCBgdGVtcGVyYXR1cmVgLiBUaGVzZSBmaWVsZHMgd2lsbCBvdmVycmlkZSB0aGUgU2Vzc2lvbidzXG4gKiBjb25maWd1cmF0aW9uIGZvciB0aGlzIFJlc3BvbnNlIG9ubHkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VDcmVhdGVFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UuY3JlYXRlYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5jcmVhdGUnO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjbGllbnQtZ2VuZXJhdGVkIElEIHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUmVhbHRpbWUgcmVzcG9uc2Ugd2l0aCB0aGVzZSBwYXJhbWV0ZXJzXG4gICAqL1xuICByZXNwb25zZT86IFJlc3BvbnNlQ3JlYXRlRXZlbnQuUmVzcG9uc2U7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUmVzcG9uc2VDcmVhdGVFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUmVhbHRpbWUgcmVzcG9uc2Ugd2l0aCB0aGVzZSBwYXJhbWV0ZXJzXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiBDb250cm9scyB3aGljaCBjb252ZXJzYXRpb24gdGhlIHJlc3BvbnNlIGlzIGFkZGVkIHRvLiBDdXJyZW50bHkgc3VwcG9ydHMgYGF1dG9gXG4gICAgICogYW5kIGBub25lYCwgd2l0aCBgYXV0b2AgYXMgdGhlIGRlZmF1bHQgdmFsdWUuIFRoZSBgYXV0b2AgdmFsdWUgbWVhbnMgdGhhdCB0aGVcbiAgICAgKiBjb250ZW50cyBvZiB0aGUgcmVzcG9uc2Ugd2lsbCBiZSBhZGRlZCB0byB0aGUgZGVmYXVsdCBjb252ZXJzYXRpb24uIFNldCB0aGlzIHRvXG4gICAgICogYG5vbmVgIHRvIGNyZWF0ZSBhbiBvdXQtb2YtYmFuZCByZXNwb25zZSB3aGljaCB3aWxsIG5vdCBhZGQgaXRlbXMgdG8gZGVmYXVsdFxuICAgICAqIGNvbnZlcnNhdGlvbi5cbiAgICAgKi9cbiAgICBjb252ZXJzYXRpb24/OiAoc3RyaW5nICYge30pIHwgJ2F1dG8nIHwgJ25vbmUnO1xuXG4gICAgLyoqXG4gICAgICogSW5wdXQgaXRlbXMgdG8gaW5jbHVkZSBpbiB0aGUgcHJvbXB0IGZvciB0aGUgbW9kZWwuIENyZWF0ZXMgYSBuZXcgY29udGV4dCBmb3JcbiAgICAgKiB0aGlzIHJlc3BvbnNlLCB3aXRob3V0IGluY2x1ZGluZyB0aGUgZGVmYXVsdCBjb252ZXJzYXRpb24uIENhbiBpbmNsdWRlXG4gICAgICogcmVmZXJlbmNlcyB0byBpdGVtcyBmcm9tIHRoZSBkZWZhdWx0IGNvbnZlcnNhdGlvbi5cbiAgICAgKi9cbiAgICBpbnB1dD86IEFycmF5PFJlYWx0aW1lQVBJLkNvbnZlcnNhdGlvbkl0ZW0+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgc3lzdGVtIGluc3RydWN0aW9ucyAoaS5lLiBzeXN0ZW0gbWVzc2FnZSkgcHJlcGVuZGVkIHRvIG1vZGVsIGNhbGxzLlxuICAgICAqIFRoaXMgZmllbGQgYWxsb3dzIHRoZSBjbGllbnQgdG8gZ3VpZGUgdGhlIG1vZGVsIG9uIGRlc2lyZWQgcmVzcG9uc2VzLiBUaGUgbW9kZWxcbiAgICAgKiBjYW4gYmUgaW5zdHJ1Y3RlZCBvbiByZXNwb25zZSBjb250ZW50IGFuZCBmb3JtYXQsIChlLmcuIFwiYmUgZXh0cmVtZWx5IHN1Y2NpbmN0XCIsXG4gICAgICogXCJhY3QgZnJpZW5kbHlcIiwgXCJoZXJlIGFyZSBleGFtcGxlcyBvZiBnb29kIHJlc3BvbnNlc1wiKSBhbmQgb24gYXVkaW8gYmVoYXZpb3JcbiAgICAgKiAoZS5nLiBcInRhbGsgcXVpY2tseVwiLCBcImluamVjdCBlbW90aW9uIGludG8geW91ciB2b2ljZVwiLCBcImxhdWdoIGZyZXF1ZW50bHlcIikuIFRoZVxuICAgICAqIGluc3RydWN0aW9ucyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gYmUgZm9sbG93ZWQgYnkgdGhlIG1vZGVsLCBidXQgdGhleSBwcm92aWRlXG4gICAgICogZ3VpZGFuY2UgdG8gdGhlIG1vZGVsIG9uIHRoZSBkZXNpcmVkIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBzZXJ2ZXIgc2V0cyBkZWZhdWx0IGluc3RydWN0aW9ucyB3aGljaCB3aWxsIGJlIHVzZWQgaWYgdGhpcyBmaWVsZFxuICAgICAqIGlzIG5vdCBzZXQgYW5kIGFyZSB2aXNpYmxlIGluIHRoZSBgc2Vzc2lvbi5jcmVhdGVkYCBldmVudCBhdCB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICogc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBpbnN0cnVjdGlvbnM/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBvdXRwdXQgdG9rZW5zIGZvciBhIHNpbmdsZSBhc3Npc3RhbnQgcmVzcG9uc2UsIGluY2x1c2l2ZSBvZlxuICAgICAqIHRvb2wgY2FsbHMuIFByb3ZpZGUgYW4gaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDQwOTYgdG8gbGltaXQgb3V0cHV0IHRva2Vucywgb3JcbiAgICAgKiBgaW5mYCBmb3IgdGhlIG1heGltdW0gYXZhaWxhYmxlIHRva2VucyBmb3IgYSBnaXZlbiBtb2RlbC4gRGVmYXVsdHMgdG8gYGluZmAuXG4gICAgICovXG4gICAgbWF4X3Jlc3BvbnNlX291dHB1dF90b2tlbnM/OiBudW1iZXIgfCAnaW5mJztcblxuICAgIC8qKlxuICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aW11bSBvZiA1MTJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICovXG4gICAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZXQgb2YgbW9kYWxpdGllcyB0aGUgbW9kZWwgY2FuIHJlc3BvbmQgd2l0aC4gVG8gZGlzYWJsZSBhdWRpbywgc2V0IHRoaXMgdG9cbiAgICAgKiBbXCJ0ZXh0XCJdLlxuICAgICAqL1xuICAgIG1vZGFsaXRpZXM/OiBBcnJheTwndGV4dCcgfCAnYXVkaW8nPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb3JtYXQgb2Ygb3V0cHV0IGF1ZGlvLiBPcHRpb25zIGFyZSBgcGNtMTZgLCBgZzcxMV91bGF3YCwgb3IgYGc3MTFfYWxhd2AuXG4gICAgICovXG4gICAgb3V0cHV0X2F1ZGlvX2Zvcm1hdD86ICdwY20xNicgfCAnZzcxMV91bGF3JyB8ICdnNzExX2FsYXcnO1xuXG4gICAgLyoqXG4gICAgICogU2FtcGxpbmcgdGVtcGVyYXR1cmUgZm9yIHRoZSBtb2RlbCwgbGltaXRlZCB0byBbMC42LCAxLjJdLiBEZWZhdWx0cyB0byAwLjguXG4gICAgICovXG4gICAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBIb3cgdGhlIG1vZGVsIGNob29zZXMgdG9vbHMuIE9wdGlvbnMgYXJlIGBhdXRvYCwgYG5vbmVgLCBgcmVxdWlyZWRgLCBvciBzcGVjaWZ5XG4gICAgICogYSBmdW5jdGlvbiwgbGlrZSBge1widHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIm15X2Z1bmN0aW9uXCJ9fWAuXG4gICAgICovXG4gICAgdG9vbF9jaG9pY2U/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUb29scyAoZnVuY3Rpb25zKSBhdmFpbGFibGUgdG8gdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIHRvb2xzPzogQXJyYXk8UmVzcG9uc2UuVG9vbD47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdm9pY2UgdGhlIG1vZGVsIHVzZXMgdG8gcmVzcG9uZC4gVm9pY2UgY2Fubm90IGJlIGNoYW5nZWQgZHVyaW5nIHRoZSBzZXNzaW9uXG4gICAgICogb25jZSB0aGUgbW9kZWwgaGFzIHJlc3BvbmRlZCB3aXRoIGF1ZGlvIGF0IGxlYXN0IG9uY2UuIEN1cnJlbnQgdm9pY2Ugb3B0aW9ucyBhcmVcbiAgICAgKiBgYWxsb3lgLCBgYXNoYCwgYGJhbGxhZGAsIGBjb3JhbGAsIGBlY2hvYCBgc2FnZWAsIGBzaGltbWVyYCBhbmQgYHZlcnNlYC5cbiAgICAgKi9cbiAgICB2b2ljZT86ICdhbGxveScgfCAnYXNoJyB8ICdiYWxsYWQnIHwgJ2NvcmFsJyB8ICdlY2hvJyB8ICdzYWdlJyB8ICdzaGltbWVyJyB8ICd2ZXJzZSc7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFJlc3BvbnNlIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIFRvb2wge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGZ1bmN0aW9uLCBpbmNsdWRpbmcgZ3VpZGFuY2Ugb24gd2hlbiBhbmQgaG93IHRvIGNhbGwgaXQsXG4gICAgICAgKiBhbmQgZ3VpZGFuY2UgYWJvdXQgd2hhdCB0byB0ZWxsIHRoZSB1c2VyIHdoZW4gY2FsbGluZyAoaWYgYW55dGhpbmcpLlxuICAgICAgICovXG4gICAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICAgKi9cbiAgICAgIG5hbWU/OiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFyYW1ldGVycyBvZiB0aGUgZnVuY3Rpb24gaW4gSlNPTiBTY2hlbWEuXG4gICAgICAgKi9cbiAgICAgIHBhcmFtZXRlcnM/OiB1bmtub3duO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSB0b29sLCBpLmUuIGBmdW5jdGlvbmAuXG4gICAgICAgKi9cbiAgICAgIHR5cGU/OiAnZnVuY3Rpb24nO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBuZXcgUmVzcG9uc2UgaXMgY3JlYXRlZC4gVGhlIGZpcnN0IGV2ZW50IG9mIHJlc3BvbnNlIGNyZWF0aW9uLFxuICogd2hlcmUgdGhlIHJlc3BvbnNlIGlzIGluIGFuIGluaXRpYWwgc3RhdGUgb2YgYGluX3Byb2dyZXNzYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUNyZWF0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVzcG9uc2UgcmVzb3VyY2UuXG4gICAqL1xuICByZXNwb25zZTogUmVhbHRpbWVSZXNwb25zZTtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLmNyZWF0ZWRgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLmNyZWF0ZWQnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBSZXNwb25zZSBpcyBkb25lIHN0cmVhbWluZy4gQWx3YXlzIGVtaXR0ZWQsIG5vIG1hdHRlciB0aGUgZmluYWxcbiAqIHN0YXRlLiBUaGUgUmVzcG9uc2Ugb2JqZWN0IGluY2x1ZGVkIGluIHRoZSBgcmVzcG9uc2UuZG9uZWAgZXZlbnQgd2lsbCBpbmNsdWRlXG4gKiBhbGwgb3V0cHV0IEl0ZW1zIGluIHRoZSBSZXNwb25zZSBidXQgd2lsbCBvbWl0IHRoZSByYXcgYXVkaW8gZGF0YS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZURvbmVFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVzcG9uc2UgcmVzb3VyY2UuXG4gICAqL1xuICByZXNwb25zZTogUmVhbHRpbWVSZXNwb25zZTtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLmRvbmVgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLmRvbmUnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gdGhlIG1vZGVsLWdlbmVyYXRlZCBmdW5jdGlvbiBjYWxsIGFyZ3VtZW50cyBhcmUgdXBkYXRlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUZ1bmN0aW9uQ2FsbEFyZ3VtZW50c0RlbHRhRXZlbnQge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBmdW5jdGlvbiBjYWxsLlxuICAgKi9cbiAgY2FsbF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgYXJndW1lbnRzIGRlbHRhIGFzIGEgSlNPTiBzdHJpbmcuXG4gICAqL1xuICBkZWx0YTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwgaXRlbS5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaXRlbSBpbiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSByZXNwb25zZS5cbiAgICovXG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5mdW5jdGlvbl9jYWxsX2FyZ3VtZW50cy5kZWx0YWAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UuZnVuY3Rpb25fY2FsbF9hcmd1bWVudHMuZGVsdGEnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gdGhlIG1vZGVsLWdlbmVyYXRlZCBmdW5jdGlvbiBjYWxsIGFyZ3VtZW50cyBhcmUgZG9uZSBzdHJlYW1pbmcuXG4gKiBBbHNvIGVtaXR0ZWQgd2hlbiBhIFJlc3BvbnNlIGlzIGludGVycnVwdGVkLCBpbmNvbXBsZXRlLCBvciBjYW5jZWxsZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VGdW5jdGlvbkNhbGxBcmd1bWVudHNEb25lRXZlbnQge1xuICAvKipcbiAgICogVGhlIGZpbmFsIGFyZ3VtZW50cyBhcyBhIEpTT04gc3RyaW5nLlxuICAgKi9cbiAgYXJndW1lbnRzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgZnVuY3Rpb24gY2FsbC5cbiAgICovXG4gIGNhbGxfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBmdW5jdGlvbiBjYWxsIGl0ZW0uXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGl0ZW0gaW4gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UuZnVuY3Rpb25fY2FsbF9hcmd1bWVudHMuZG9uZWAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UuZnVuY3Rpb25fY2FsbF9hcmd1bWVudHMuZG9uZSc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhIG5ldyBJdGVtIGlzIGNyZWF0ZWQgZHVyaW5nIFJlc3BvbnNlIGdlbmVyYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VPdXRwdXRJdGVtQWRkZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICovXG4gIGl0ZW06IENvbnZlcnNhdGlvbkl0ZW07XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGl0ZW0gaW4gdGhlIFJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgUmVzcG9uc2UgdG8gd2hpY2ggdGhlIGl0ZW0gYmVsb25ncy5cbiAgICovXG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5vdXRwdXRfaXRlbS5hZGRlZGAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2Uub3V0cHV0X2l0ZW0uYWRkZWQnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYW4gSXRlbSBpcyBkb25lIHN0cmVhbWluZy4gQWxzbyBlbWl0dGVkIHdoZW4gYSBSZXNwb25zZSBpc1xuICogaW50ZXJydXB0ZWQsIGluY29tcGxldGUsIG9yIGNhbmNlbGxlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZU91dHB1dEl0ZW1Eb25lRXZlbnQge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGl0ZW0gdG8gYWRkIHRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAqL1xuICBpdGVtOiBDb252ZXJzYXRpb25JdGVtO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSBSZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFJlc3BvbnNlIHRvIHdoaWNoIHRoZSBpdGVtIGJlbG9uZ3MuXG4gICAqL1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2Uub3V0cHV0X2l0ZW0uZG9uZWAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2Uub3V0cHV0X2l0ZW0uZG9uZSc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiB0aGUgdGV4dCB2YWx1ZSBvZiBhIFwidGV4dFwiIGNvbnRlbnQgcGFydCBpcyB1cGRhdGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlVGV4dERlbHRhRXZlbnQge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgaW4gdGhlIGl0ZW0ncyBjb250ZW50IGFycmF5LlxuICAgKi9cbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdGV4dCBkZWx0YS5cbiAgICovXG4gIGRlbHRhOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgaXRlbS5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaXRlbSBpbiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSByZXNwb25zZS5cbiAgICovXG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS50ZXh0LmRlbHRhYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS50ZXh0LmRlbHRhJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIHRoZSB0ZXh0IHZhbHVlIG9mIGEgXCJ0ZXh0XCIgY29udGVudCBwYXJ0IGlzIGRvbmUgc3RyZWFtaW5nLiBBbHNvXG4gKiBlbWl0dGVkIHdoZW4gYSBSZXNwb25zZSBpcyBpbnRlcnJ1cHRlZCwgaW5jb21wbGV0ZSwgb3IgY2FuY2VsbGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlVGV4dERvbmVFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCBpbiB0aGUgaXRlbSdzIGNvbnRlbnQgYXJyYXkuXG4gICAqL1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgaXRlbS5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaXRlbSBpbiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSByZXNwb25zZS5cbiAgICovXG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBmaW5hbCB0ZXh0IGNvbnRlbnQuXG4gICAqL1xuICB0ZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS50ZXh0LmRvbmVgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLnRleHQuZG9uZSc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhIFNlc3Npb24gaXMgY3JlYXRlZC4gRW1pdHRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gYSBuZXcgY29ubmVjdGlvblxuICogaXMgZXN0YWJsaXNoZWQgYXMgdGhlIGZpcnN0IHNlcnZlciBldmVudC4gVGhpcyBldmVudCB3aWxsIGNvbnRhaW4gdGhlIGRlZmF1bHRcbiAqIFNlc3Npb24gY29uZmlndXJhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uQ3JlYXRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJlYWx0aW1lIHNlc3Npb24gb2JqZWN0IGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBzZXNzaW9uOiBTZXNzaW9uc0FQSS5TZXNzaW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgc2Vzc2lvbi5jcmVhdGVkYC5cbiAgICovXG4gIHR5cGU6ICdzZXNzaW9uLmNyZWF0ZWQnO1xufVxuXG4vKipcbiAqIFNlbmQgdGhpcyBldmVudCB0byB1cGRhdGUgdGhlIHNlc3Npb25cdTIwMTlzIGRlZmF1bHQgY29uZmlndXJhdGlvbi4gVGhlIGNsaWVudCBtYXlcbiAqIHNlbmQgdGhpcyBldmVudCBhdCBhbnkgdGltZSB0byB1cGRhdGUgdGhlIHNlc3Npb24gY29uZmlndXJhdGlvbiwgYW5kIGFueSBmaWVsZFxuICogbWF5IGJlIHVwZGF0ZWQgYXQgYW55IHRpbWUsIGV4Y2VwdCBmb3IgXCJ2b2ljZVwiLiBUaGUgc2VydmVyIHdpbGwgcmVzcG9uZCB3aXRoIGFcbiAqIGBzZXNzaW9uLnVwZGF0ZWRgIGV2ZW50IHRoYXQgc2hvd3MgdGhlIGZ1bGwgZWZmZWN0aXZlIGNvbmZpZ3VyYXRpb24uIE9ubHkgZmllbGRzXG4gKiB0aGF0IGFyZSBwcmVzZW50IGFyZSB1cGRhdGVkLCB0aHVzIHRoZSBjb3JyZWN0IHdheSB0byBjbGVhciBhIGZpZWxkIGxpa2VcbiAqIFwiaW5zdHJ1Y3Rpb25zXCIgaXMgdG8gcGFzcyBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvblVwZGF0ZUV2ZW50IHtcbiAgLyoqXG4gICAqIFJlYWx0aW1lIHNlc3Npb24gb2JqZWN0IGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBzZXNzaW9uOiBTZXNzaW9uVXBkYXRlRXZlbnQuU2Vzc2lvbjtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHNlc3Npb24udXBkYXRlYC5cbiAgICovXG4gIHR5cGU6ICdzZXNzaW9uLnVwZGF0ZSc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGNsaWVudC1nZW5lcmF0ZWQgSUQgdXNlZCB0byBpZGVudGlmeSB0aGlzIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgU2Vzc2lvblVwZGF0ZUV2ZW50IHtcbiAgLyoqXG4gICAqIFJlYWx0aW1lIHNlc3Npb24gb2JqZWN0IGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFNlc3Npb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBSZWFsdGltZSBtb2RlbCB1c2VkIGZvciB0aGlzIHNlc3Npb24uXG4gICAgICovXG4gICAgbW9kZWw6XG4gICAgICB8ICdncHQtNG8tcmVhbHRpbWUtcHJldmlldydcbiAgICAgIHwgJ2dwdC00by1yZWFsdGltZS1wcmV2aWV3LTIwMjQtMTAtMDEnXG4gICAgICB8ICdncHQtNG8tcmVhbHRpbWUtcHJldmlldy0yMDI0LTEyLTE3J1xuICAgICAgfCAnZ3B0LTRvLW1pbmktcmVhbHRpbWUtcHJldmlldydcbiAgICAgIHwgJ2dwdC00by1taW5pLXJlYWx0aW1lLXByZXZpZXctMjAyNC0xMi0xNyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybWF0IG9mIGlucHV0IGF1ZGlvLiBPcHRpb25zIGFyZSBgcGNtMTZgLCBgZzcxMV91bGF3YCwgb3IgYGc3MTFfYWxhd2AuXG4gICAgICovXG4gICAgaW5wdXRfYXVkaW9fZm9ybWF0PzogJ3BjbTE2JyB8ICdnNzExX3VsYXcnIHwgJ2c3MTFfYWxhdyc7XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGZvciBpbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uLCBkZWZhdWx0cyB0byBvZmYgYW5kIGNhbiBiZSBzZXQgdG9cbiAgICAgKiBgbnVsbGAgdG8gdHVybiBvZmYgb25jZSBvbi4gSW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiBpcyBub3QgbmF0aXZlIHRvIHRoZVxuICAgICAqIG1vZGVsLCBzaW5jZSB0aGUgbW9kZWwgY29uc3VtZXMgYXVkaW8gZGlyZWN0bHkuIFRyYW5zY3JpcHRpb24gcnVuc1xuICAgICAqIGFzeW5jaHJvbm91c2x5IHRocm91Z2ggV2hpc3BlciBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgcm91Z2ggZ3VpZGFuY2UgcmF0aGVyXG4gICAgICogdGhhbiB0aGUgcmVwcmVzZW50YXRpb24gdW5kZXJzdG9vZCBieSB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbj86IFNlc3Npb24uSW5wdXRBdWRpb1RyYW5zY3JpcHRpb247XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBzeXN0ZW0gaW5zdHJ1Y3Rpb25zIChpLmUuIHN5c3RlbSBtZXNzYWdlKSBwcmVwZW5kZWQgdG8gbW9kZWwgY2FsbHMuXG4gICAgICogVGhpcyBmaWVsZCBhbGxvd3MgdGhlIGNsaWVudCB0byBndWlkZSB0aGUgbW9kZWwgb24gZGVzaXJlZCByZXNwb25zZXMuIFRoZSBtb2RlbFxuICAgICAqIGNhbiBiZSBpbnN0cnVjdGVkIG9uIHJlc3BvbnNlIGNvbnRlbnQgYW5kIGZvcm1hdCwgKGUuZy4gXCJiZSBleHRyZW1lbHkgc3VjY2luY3RcIixcbiAgICAgKiBcImFjdCBmcmllbmRseVwiLCBcImhlcmUgYXJlIGV4YW1wbGVzIG9mIGdvb2QgcmVzcG9uc2VzXCIpIGFuZCBvbiBhdWRpbyBiZWhhdmlvclxuICAgICAqIChlLmcuIFwidGFsayBxdWlja2x5XCIsIFwiaW5qZWN0IGVtb3Rpb24gaW50byB5b3VyIHZvaWNlXCIsIFwibGF1Z2ggZnJlcXVlbnRseVwiKS4gVGhlXG4gICAgICogaW5zdHJ1Y3Rpb25zIGFyZSBub3QgZ3VhcmFudGVlZCB0byBiZSBmb2xsb3dlZCBieSB0aGUgbW9kZWwsIGJ1dCB0aGV5IHByb3ZpZGVcbiAgICAgKiBndWlkYW5jZSB0byB0aGUgbW9kZWwgb24gdGhlIGRlc2lyZWQgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIHNlcnZlciBzZXRzIGRlZmF1bHQgaW5zdHJ1Y3Rpb25zIHdoaWNoIHdpbGwgYmUgdXNlZCBpZiB0aGlzIGZpZWxkXG4gICAgICogaXMgbm90IHNldCBhbmQgYXJlIHZpc2libGUgaW4gdGhlIGBzZXNzaW9uLmNyZWF0ZWRgIGV2ZW50IGF0IHRoZSBzdGFydCBvZiB0aGVcbiAgICAgKiBzZXNzaW9uLlxuICAgICAqL1xuICAgIGluc3RydWN0aW9ucz86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIE1heGltdW0gbnVtYmVyIG9mIG91dHB1dCB0b2tlbnMgZm9yIGEgc2luZ2xlIGFzc2lzdGFudCByZXNwb25zZSwgaW5jbHVzaXZlIG9mXG4gICAgICogdG9vbCBjYWxscy4gUHJvdmlkZSBhbiBpbnRlZ2VyIGJldHdlZW4gMSBhbmQgNDA5NiB0byBsaW1pdCBvdXRwdXQgdG9rZW5zLCBvclxuICAgICAqIGBpbmZgIGZvciB0aGUgbWF4aW11bSBhdmFpbGFibGUgdG9rZW5zIGZvciBhIGdpdmVuIG1vZGVsLiBEZWZhdWx0cyB0byBgaW5mYC5cbiAgICAgKi9cbiAgICBtYXhfcmVzcG9uc2Vfb3V0cHV0X3Rva2Vucz86IG51bWJlciB8ICdpbmYnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNldCBvZiBtb2RhbGl0aWVzIHRoZSBtb2RlbCBjYW4gcmVzcG9uZCB3aXRoLiBUbyBkaXNhYmxlIGF1ZGlvLCBzZXQgdGhpcyB0b1xuICAgICAqIFtcInRleHRcIl0uXG4gICAgICovXG4gICAgbW9kYWxpdGllcz86IEFycmF5PCd0ZXh0JyB8ICdhdWRpbyc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcm1hdCBvZiBvdXRwdXQgYXVkaW8uIE9wdGlvbnMgYXJlIGBwY20xNmAsIGBnNzExX3VsYXdgLCBvciBgZzcxMV9hbGF3YC5cbiAgICAgKi9cbiAgICBvdXRwdXRfYXVkaW9fZm9ybWF0PzogJ3BjbTE2JyB8ICdnNzExX3VsYXcnIHwgJ2c3MTFfYWxhdyc7XG5cbiAgICAvKipcbiAgICAgKiBTYW1wbGluZyB0ZW1wZXJhdHVyZSBmb3IgdGhlIG1vZGVsLCBsaW1pdGVkIHRvIFswLjYsIDEuMl0uIERlZmF1bHRzIHRvIDAuOC5cbiAgICAgKi9cbiAgICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEhvdyB0aGUgbW9kZWwgY2hvb3NlcyB0b29scy4gT3B0aW9ucyBhcmUgYGF1dG9gLCBgbm9uZWAsIGByZXF1aXJlZGAsIG9yIHNwZWNpZnlcbiAgICAgKiBhIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHRvb2xfY2hvaWNlPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVG9vbHMgKGZ1bmN0aW9ucykgYXZhaWxhYmxlIHRvIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICB0b29scz86IEFycmF5PFNlc3Npb24uVG9vbD47XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGZvciB0dXJuIGRldGVjdGlvbi4gQ2FuIGJlIHNldCB0byBgbnVsbGAgdG8gdHVybiBvZmYuIFNlcnZlciBWQURcbiAgICAgKiBtZWFucyB0aGF0IHRoZSBtb2RlbCB3aWxsIGRldGVjdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiBzcGVlY2ggYmFzZWQgb24gYXVkaW9cbiAgICAgKiB2b2x1bWUgYW5kIHJlc3BvbmQgYXQgdGhlIGVuZCBvZiB1c2VyIHNwZWVjaC5cbiAgICAgKi9cbiAgICB0dXJuX2RldGVjdGlvbj86IFNlc3Npb24uVHVybkRldGVjdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2b2ljZSB0aGUgbW9kZWwgdXNlcyB0byByZXNwb25kLiBWb2ljZSBjYW5ub3QgYmUgY2hhbmdlZCBkdXJpbmcgdGhlIHNlc3Npb25cbiAgICAgKiBvbmNlIHRoZSBtb2RlbCBoYXMgcmVzcG9uZGVkIHdpdGggYXVkaW8gYXQgbGVhc3Qgb25jZS4gQ3VycmVudCB2b2ljZSBvcHRpb25zIGFyZVxuICAgICAqIGBhbGxveWAsIGBhc2hgLCBgYmFsbGFkYCwgYGNvcmFsYCwgYGVjaG9gIGBzYWdlYCwgYHNoaW1tZXJgIGFuZCBgdmVyc2VgLlxuICAgICAqL1xuICAgIHZvaWNlPzogJ2FsbG95JyB8ICdhc2gnIHwgJ2JhbGxhZCcgfCAnY29yYWwnIHwgJ2VjaG8nIHwgJ3NhZ2UnIHwgJ3NoaW1tZXInIHwgJ3ZlcnNlJztcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgU2Vzc2lvbiB7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiwgZGVmYXVsdHMgdG8gb2ZmIGFuZCBjYW4gYmUgc2V0IHRvXG4gICAgICogYG51bGxgIHRvIHR1cm4gb2ZmIG9uY2Ugb24uIElucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24gaXMgbm90IG5hdGl2ZSB0byB0aGVcbiAgICAgKiBtb2RlbCwgc2luY2UgdGhlIG1vZGVsIGNvbnN1bWVzIGF1ZGlvIGRpcmVjdGx5LiBUcmFuc2NyaXB0aW9uIHJ1bnNcbiAgICAgKiBhc3luY2hyb25vdXNseSB0aHJvdWdoIFdoaXNwZXIgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIHJvdWdoIGd1aWRhbmNlIHJhdGhlclxuICAgICAqIHRoYW4gdGhlIHJlcHJlc2VudGF0aW9uIHVuZGVyc3Rvb2QgYnkgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbW9kZWwgdG8gdXNlIGZvciB0cmFuc2NyaXB0aW9uLCBgd2hpc3Blci0xYCBpcyB0aGUgb25seSBjdXJyZW50bHkgc3VwcG9ydGVkXG4gICAgICAgKiBtb2RlbC5cbiAgICAgICAqL1xuICAgICAgbW9kZWw/OiBzdHJpbmc7XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBUb29sIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBmdW5jdGlvbiwgaW5jbHVkaW5nIGd1aWRhbmNlIG9uIHdoZW4gYW5kIGhvdyB0byBjYWxsIGl0LFxuICAgICAgICogYW5kIGd1aWRhbmNlIGFib3V0IHdoYXQgdG8gdGVsbCB0aGUgdXNlciB3aGVuIGNhbGxpbmcgKGlmIGFueXRoaW5nKS5cbiAgICAgICAqL1xuICAgICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAgICovXG4gICAgICBuYW1lPzogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFBhcmFtZXRlcnMgb2YgdGhlIGZ1bmN0aW9uIGluIEpTT04gU2NoZW1hLlxuICAgICAgICovXG4gICAgICBwYXJhbWV0ZXJzPzogdW5rbm93bjtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbCwgaS5lLiBgZnVuY3Rpb25gLlxuICAgICAgICovXG4gICAgICB0eXBlPzogJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGZvciB0dXJuIGRldGVjdGlvbi4gQ2FuIGJlIHNldCB0byBgbnVsbGAgdG8gdHVybiBvZmYuIFNlcnZlciBWQURcbiAgICAgKiBtZWFucyB0aGF0IHRoZSBtb2RlbCB3aWxsIGRldGVjdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiBzcGVlY2ggYmFzZWQgb24gYXVkaW9cbiAgICAgKiB2b2x1bWUgYW5kIHJlc3BvbmQgYXQgdGhlIGVuZCBvZiB1c2VyIHNwZWVjaC5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIFR1cm5EZXRlY3Rpb24ge1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIGEgcmVzcG9uc2Ugd2hlbiBWQUQgaXMgZW5hYmxlZC4gYHRydWVgXG4gICAgICAgKiBieSBkZWZhdWx0LlxuICAgICAgICovXG4gICAgICBjcmVhdGVfcmVzcG9uc2U/OiBib29sZWFuO1xuXG4gICAgICAvKipcbiAgICAgICAqIEFtb3VudCBvZiBhdWRpbyB0byBpbmNsdWRlIGJlZm9yZSB0aGUgVkFEIGRldGVjdGVkIHNwZWVjaCAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICAgICAqIERlZmF1bHRzIHRvIDMwMG1zLlxuICAgICAgICovXG4gICAgICBwcmVmaXhfcGFkZGluZ19tcz86IG51bWJlcjtcblxuICAgICAgLyoqXG4gICAgICAgKiBEdXJhdGlvbiBvZiBzaWxlbmNlIHRvIGRldGVjdCBzcGVlY2ggc3RvcCAoaW4gbWlsbGlzZWNvbmRzKS4gRGVmYXVsdHMgdG8gNTAwbXMuXG4gICAgICAgKiBXaXRoIHNob3J0ZXIgdmFsdWVzIHRoZSBtb2RlbCB3aWxsIHJlc3BvbmQgbW9yZSBxdWlja2x5LCBidXQgbWF5IGp1bXAgaW4gb25cbiAgICAgICAqIHNob3J0IHBhdXNlcyBmcm9tIHRoZSB1c2VyLlxuICAgICAgICovXG4gICAgICBzaWxlbmNlX2R1cmF0aW9uX21zPzogbnVtYmVyO1xuXG4gICAgICAvKipcbiAgICAgICAqIEFjdGl2YXRpb24gdGhyZXNob2xkIGZvciBWQUQgKDAuMCB0byAxLjApLCB0aGlzIGRlZmF1bHRzIHRvIDAuNS4gQSBoaWdoZXJcbiAgICAgICAqIHRocmVzaG9sZCB3aWxsIHJlcXVpcmUgbG91ZGVyIGF1ZGlvIHRvIGFjdGl2YXRlIHRoZSBtb2RlbCwgYW5kIHRodXMgbWlnaHRcbiAgICAgICAqIHBlcmZvcm0gYmV0dGVyIGluIG5vaXN5IGVudmlyb25tZW50cy5cbiAgICAgICAqL1xuICAgICAgdGhyZXNob2xkPzogbnVtYmVyO1xuXG4gICAgICAvKipcbiAgICAgICAqIFR5cGUgb2YgdHVybiBkZXRlY3Rpb24sIG9ubHkgYHNlcnZlcl92YWRgIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gICAgICAgKi9cbiAgICAgIHR5cGU/OiBzdHJpbmc7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhIHNlc3Npb24gaXMgdXBkYXRlZCB3aXRoIGEgYHNlc3Npb24udXBkYXRlYCBldmVudCwgdW5sZXNzIHRoZXJlXG4gKiBpcyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uVXBkYXRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJlYWx0aW1lIHNlc3Npb24gb2JqZWN0IGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBzZXNzaW9uOiBTZXNzaW9uc0FQSS5TZXNzaW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgc2Vzc2lvbi51cGRhdGVkYC5cbiAgICovXG4gIHR5cGU6ICdzZXNzaW9uLnVwZGF0ZWQnO1xufVxuXG5SZWFsdGltZS5TZXNzaW9ucyA9IFNlc3Npb25zO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgUmVhbHRpbWUge1xuICBleHBvcnQge1xuICAgIFNlc3Npb25zIGFzIFNlc3Npb25zLFxuICAgIHR5cGUgU2Vzc2lvbnNBUElTZXNzaW9uIGFzIFNlc3Npb24sXG4gICAgdHlwZSBTZXNzaW9uQ3JlYXRlUmVzcG9uc2UgYXMgU2Vzc2lvbkNyZWF0ZVJlc3BvbnNlLFxuICAgIHR5cGUgU2Vzc2lvbkNyZWF0ZVBhcmFtcyBhcyBTZXNzaW9uQ3JlYXRlUGFyYW1zLFxuICB9O1xufVxuIiwgImltcG9ydCB7XG4gIFRleHRDb250ZW50QmxvY2ssXG4gIEltYWdlRmlsZUNvbnRlbnRCbG9jayxcbiAgTWVzc2FnZSxcbiAgTWVzc2FnZUNvbnRlbnREZWx0YSxcbiAgVGV4dCxcbiAgSW1hZ2VGaWxlLFxuICBUZXh0RGVsdGEsXG4gIE1lc3NhZ2VEZWx0YSxcbiAgTWVzc2FnZUNvbnRlbnQsXG59IGZyb20gJy4uL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvbWVzc2FnZXMnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7IFJlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQge1xuICBSdW4sXG4gIFJ1bkNyZWF0ZVBhcmFtc0Jhc2UsXG4gIFJ1bkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgUnVucyxcbiAgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNCYXNlLFxuICBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbWluZyxcbn0gZnJvbSAnLi4vcmVzb3VyY2VzL2JldGEvdGhyZWFkcy9ydW5zL3J1bnMnO1xuaW1wb3J0IHsgdHlwZSBSZWFkYWJsZVN0cmVhbSB9IGZyb20gJy4uL19zaGltcy9pbmRleCc7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tICcuLi9zdHJlYW1pbmcnO1xuaW1wb3J0IHsgQVBJVXNlckFib3J0RXJyb3IsIE9wZW5BSUVycm9yIH0gZnJvbSAnLi4vZXJyb3InO1xuaW1wb3J0IHtcbiAgQXNzaXN0YW50U3RyZWFtRXZlbnQsXG4gIE1lc3NhZ2VTdHJlYW1FdmVudCxcbiAgUnVuU3RlcFN0cmVhbUV2ZW50LFxuICBSdW5TdHJlYW1FdmVudCxcbn0gZnJvbSAnLi4vcmVzb3VyY2VzL2JldGEvYXNzaXN0YW50cyc7XG5pbXBvcnQgeyBSdW5TdGVwLCBSdW5TdGVwRGVsdGEsIFRvb2xDYWxsLCBUb29sQ2FsbERlbHRhIH0gZnJvbSAnLi4vcmVzb3VyY2VzL2JldGEvdGhyZWFkcy9ydW5zL3N0ZXBzJztcbmltcG9ydCB7IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc0Jhc2UsIFRocmVhZHMgfSBmcm9tICcuLi9yZXNvdXJjZXMvYmV0YS90aHJlYWRzL3RocmVhZHMnO1xuaW1wb3J0IHsgQmFzZUV2ZW50cywgRXZlbnRTdHJlYW0gfSBmcm9tICcuL0V2ZW50U3RyZWFtJztcblxuZXhwb3J0IGludGVyZmFjZSBBc3Npc3RhbnRTdHJlYW1FdmVudHMgZXh0ZW5kcyBCYXNlRXZlbnRzIHtcbiAgcnVuOiAocnVuOiBSdW4pID0+IHZvaWQ7XG5cbiAgLy9OZXcgZXZlbnQgc3RydWN0dXJlXG4gIG1lc3NhZ2VDcmVhdGVkOiAobWVzc2FnZTogTWVzc2FnZSkgPT4gdm9pZDtcbiAgbWVzc2FnZURlbHRhOiAobWVzc2FnZTogTWVzc2FnZURlbHRhLCBzbmFwc2hvdDogTWVzc2FnZSkgPT4gdm9pZDtcbiAgbWVzc2FnZURvbmU6IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB2b2lkO1xuXG4gIHJ1blN0ZXBDcmVhdGVkOiAocnVuU3RlcDogUnVuU3RlcCkgPT4gdm9pZDtcbiAgcnVuU3RlcERlbHRhOiAoZGVsdGE6IFJ1blN0ZXBEZWx0YSwgc25hcHNob3Q6IFJ1bnMuUnVuU3RlcCkgPT4gdm9pZDtcbiAgcnVuU3RlcERvbmU6IChydW5TdGVwOiBSdW5zLlJ1blN0ZXAsIHNuYXBzaG90OiBSdW5zLlJ1blN0ZXApID0+IHZvaWQ7XG5cbiAgdG9vbENhbGxDcmVhdGVkOiAodG9vbENhbGw6IFRvb2xDYWxsKSA9PiB2b2lkO1xuICB0b29sQ2FsbERlbHRhOiAoZGVsdGE6IFRvb2xDYWxsRGVsdGEsIHNuYXBzaG90OiBUb29sQ2FsbCkgPT4gdm9pZDtcbiAgdG9vbENhbGxEb25lOiAodG9vbENhbGw6IFRvb2xDYWxsKSA9PiB2b2lkO1xuXG4gIHRleHRDcmVhdGVkOiAoY29udGVudDogVGV4dCkgPT4gdm9pZDtcbiAgdGV4dERlbHRhOiAoZGVsdGE6IFRleHREZWx0YSwgc25hcHNob3Q6IFRleHQpID0+IHZvaWQ7XG4gIHRleHREb25lOiAoY29udGVudDogVGV4dCwgc25hcHNob3Q6IE1lc3NhZ2UpID0+IHZvaWQ7XG5cbiAgLy9ObyBjcmVhdGVkIG9yIGRlbHRhIGFzIHRoaXMgaXMgbm90IHN0cmVhbWVkXG4gIGltYWdlRmlsZURvbmU6IChjb250ZW50OiBJbWFnZUZpbGUsIHNuYXBzaG90OiBNZXNzYWdlKSA9PiB2b2lkO1xuXG4gIGV2ZW50OiAoZXZlbnQ6IEFzc2lzdGFudFN0cmVhbUV2ZW50KSA9PiB2b2lkO1xufVxuXG5leHBvcnQgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlU3RyZWFtID0gT21pdDxUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlLCAnc3RyZWFtJz4gJiB7XG4gIHN0cmVhbT86IHRydWU7XG59O1xuXG5leHBvcnQgdHlwZSBSdW5DcmVhdGVQYXJhbXNCYXNlU3RyZWFtID0gT21pdDxSdW5DcmVhdGVQYXJhbXNCYXNlLCAnc3RyZWFtJz4gJiB7XG4gIHN0cmVhbT86IHRydWU7XG59O1xuXG5leHBvcnQgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbSA9IE9taXQ8UnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNCYXNlLCAnc3RyZWFtJz4gJiB7XG4gIHN0cmVhbT86IHRydWU7XG59O1xuXG5leHBvcnQgY2xhc3MgQXNzaXN0YW50U3RyZWFtXG4gIGV4dGVuZHMgRXZlbnRTdHJlYW08QXNzaXN0YW50U3RyZWFtRXZlbnRzPlxuICBpbXBsZW1lbnRzIEFzeW5jSXRlcmFibGU8QXNzaXN0YW50U3RyZWFtRXZlbnQ+XG57XG4gIC8vVHJhY2sgYWxsIGV2ZW50cyBpbiBhIHNpbmdsZSBsaXN0IGZvciByZWZlcmVuY2VcbiAgI2V2ZW50czogQXNzaXN0YW50U3RyZWFtRXZlbnRbXSA9IFtdO1xuXG4gIC8vVXNlZCB0byBhY2N1bXVsYXRlIGRlbHRhc1xuICAvL1dlIGFyZSBhY2N1bXVsYXRpbmcgbWFueSB0eXBlcyBzbyB0aGUgdmFsdWUgaGVyZSBpcyBub3Qgc3RyaWN0XG4gICNydW5TdGVwU25hcHNob3RzOiB7IFtpZDogc3RyaW5nXTogUnVucy5SdW5TdGVwIH0gPSB7fTtcbiAgI21lc3NhZ2VTbmFwc2hvdHM6IHsgW2lkOiBzdHJpbmddOiBNZXNzYWdlIH0gPSB7fTtcbiAgI21lc3NhZ2VTbmFwc2hvdDogTWVzc2FnZSB8IHVuZGVmaW5lZDtcbiAgI2ZpbmFsUnVuOiBSdW4gfCB1bmRlZmluZWQ7XG4gICNjdXJyZW50Q29udGVudEluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICNjdXJyZW50Q29udGVudDogTWVzc2FnZUNvbnRlbnQgfCB1bmRlZmluZWQ7XG4gICNjdXJyZW50VG9vbENhbGxJbmRleDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAjY3VycmVudFRvb2xDYWxsOiBUb29sQ2FsbCB8IHVuZGVmaW5lZDtcblxuICAvL0ZvciBjdXJyZW50IHNuYXBzaG90IG1ldGhvZHNcbiAgI2N1cnJlbnRFdmVudDogQXNzaXN0YW50U3RyZWFtRXZlbnQgfCB1bmRlZmluZWQ7XG4gICNjdXJyZW50UnVuU25hcHNob3Q6IFJ1biB8IHVuZGVmaW5lZDtcbiAgI2N1cnJlbnRSdW5TdGVwU25hcHNob3Q6IFJ1bnMuUnVuU3RlcCB8IHVuZGVmaW5lZDtcblxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk6IEFzeW5jSXRlcmF0b3I8QXNzaXN0YW50U3RyZWFtRXZlbnQ+IHtcbiAgICBjb25zdCBwdXNoUXVldWU6IEFzc2lzdGFudFN0cmVhbUV2ZW50W10gPSBbXTtcbiAgICBjb25zdCByZWFkUXVldWU6IHtcbiAgICAgIHJlc29sdmU6IChjaHVuazogQXNzaXN0YW50U3RyZWFtRXZlbnQgfCB1bmRlZmluZWQpID0+IHZvaWQ7XG4gICAgICByZWplY3Q6IChlcnI6IHVua25vd24pID0+IHZvaWQ7XG4gICAgfVtdID0gW107XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcblxuICAgIC8vQ2F0Y2ggYWxsIGZvciBwYXNzaW5nIGFsb25nIGFsbCBldmVudHNcbiAgICB0aGlzLm9uKCdldmVudCcsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgcmVhZGVyID0gcmVhZFF1ZXVlLnNoaWZ0KCk7XG4gICAgICBpZiAocmVhZGVyKSB7XG4gICAgICAgIHJlYWRlci5yZXNvbHZlKGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hRdWV1ZS5wdXNoKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMub24oJ2VuZCcsICgpID0+IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgcmVhZFF1ZXVlKSB7XG4gICAgICAgIHJlYWRlci5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICB9KTtcblxuICAgIHRoaXMub24oJ2Fib3J0JywgKGVycikgPT4ge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiByZWFkUXVldWUpIHtcbiAgICAgICAgcmVhZGVyLnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVhZFF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgcmVhZFF1ZXVlKSB7XG4gICAgICAgIHJlYWRlci5yZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlYWRRdWV1ZS5sZW5ndGggPSAwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGFzeW5jICgpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PEFzc2lzdGFudFN0cmVhbUV2ZW50Pj4gPT4ge1xuICAgICAgICBpZiAoIXB1c2hRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8QXNzaXN0YW50U3RyZWFtRXZlbnQgfCB1bmRlZmluZWQ+KChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICAgICAgICByZWFkUXVldWUucHVzaCh7IHJlc29sdmUsIHJlamVjdCB9KSxcbiAgICAgICAgICApLnRoZW4oKGNodW5rKSA9PiAoY2h1bmsgPyB7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSA6IHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2h1bmsgPSBwdXNoUXVldWUuc2hpZnQoKSE7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfTtcbiAgICAgIH0sXG4gICAgICByZXR1cm46IGFzeW5jICgpID0+IHtcbiAgICAgICAgdGhpcy5hYm9ydCgpO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pOiBBc3Npc3RhbnRTdHJlYW0ge1xuICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBBc3Npc3RhbnRTdHJlYW0oKTtcbiAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX2Zyb21SZWFkYWJsZVN0cmVhbShzdHJlYW0pKTtcbiAgICByZXR1cm4gcnVubmVyO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9mcm9tUmVhZGFibGVTdHJlYW0oXG4gICAgcmVhZGFibGVTdHJlYW06IFJlYWRhYmxlU3RyZWFtLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBQcm9taXNlPFJ1bj4ge1xuICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbDtcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gdGhpcy5jb250cm9sbGVyLmFib3J0KCkpO1xuICAgIH1cbiAgICB0aGlzLl9jb25uZWN0ZWQoKTtcbiAgICBjb25zdCBzdHJlYW0gPSBTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtPEFzc2lzdGFudFN0cmVhbUV2ZW50PihyZWFkYWJsZVN0cmVhbSwgdGhpcy5jb250cm9sbGVyKTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGV2ZW50IG9mIHN0cmVhbSkge1xuICAgICAgdGhpcy4jYWRkRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLmNvbnRyb2xsZXIuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FkZFJ1bih0aGlzLiNlbmRSZXF1ZXN0KCkpO1xuICB9XG5cbiAgdG9SZWFkYWJsZVN0cmVhbSgpOiBSZWFkYWJsZVN0cmVhbSB7XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IFN0cmVhbSh0aGlzW1N5bWJvbC5hc3luY0l0ZXJhdG9yXS5iaW5kKHRoaXMpLCB0aGlzLmNvbnRyb2xsZXIpO1xuICAgIHJldHVybiBzdHJlYW0udG9SZWFkYWJsZVN0cmVhbSgpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZVRvb2xBc3Npc3RhbnRTdHJlYW0oXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIHJ1bnM6IFJ1bnMsXG4gICAgcGFyYW1zOiBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbSxcbiAgICBvcHRpb25zOiBSZXF1ZXN0T3B0aW9ucyB8IHVuZGVmaW5lZCxcbiAgKTogQXNzaXN0YW50U3RyZWFtIHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgQXNzaXN0YW50U3RyZWFtKCk7XG4gICAgcnVubmVyLl9ydW4oKCkgPT5cbiAgICAgIHJ1bm5lci5fcnVuVG9vbEFzc2lzdGFudFN0cmVhbSh0aHJlYWRJZCwgcnVuSWQsIHJ1bnMsIHBhcmFtcywge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3N0cmVhbScgfSxcbiAgICAgIH0pLFxuICAgICk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfY3JlYXRlVG9vbEFzc2lzdGFudFN0cmVhbShcbiAgICBydW46IFJ1bnMsXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIHBhcmFtczogUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW0sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IFByb21pc2U8UnVuPiB7XG4gICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgIGlmIChzaWduYWwpIHtcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keTogUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmcgPSB7IC4uLnBhcmFtcywgc3RyZWFtOiB0cnVlIH07XG4gICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgcnVuLnN1Ym1pdFRvb2xPdXRwdXRzKHRocmVhZElkLCBydW5JZCwgYm9keSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHNpZ25hbDogdGhpcy5jb250cm9sbGVyLnNpZ25hbCxcbiAgICB9KTtcblxuICAgIHRoaXMuX2Nvbm5lY3RlZCgpO1xuXG4gICAgZm9yIGF3YWl0IChjb25zdCBldmVudCBvZiBzdHJlYW0pIHtcbiAgICAgIHRoaXMuI2FkZEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5jb250cm9sbGVyLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2FkZFJ1bih0aGlzLiNlbmRSZXF1ZXN0KCkpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZVRocmVhZEFzc2lzdGFudFN0cmVhbShcbiAgICBwYXJhbXM6IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc0Jhc2VTdHJlYW0sXG4gICAgdGhyZWFkOiBUaHJlYWRzLFxuICAgIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucyxcbiAgKTogQXNzaXN0YW50U3RyZWFtIHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgQXNzaXN0YW50U3RyZWFtKCk7XG4gICAgcnVubmVyLl9ydW4oKCkgPT5cbiAgICAgIHJ1bm5lci5fdGhyZWFkQXNzaXN0YW50U3RyZWFtKHBhcmFtcywgdGhyZWFkLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAnc3RyZWFtJyB9LFxuICAgICAgfSksXG4gICAgKTtcbiAgICByZXR1cm4gcnVubmVyO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUFzc2lzdGFudFN0cmVhbShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bnM6IFJ1bnMsXG4gICAgcGFyYW1zOiBSdW5DcmVhdGVQYXJhbXNCYXNlU3RyZWFtLFxuICAgIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucyxcbiAgKTogQXNzaXN0YW50U3RyZWFtIHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgQXNzaXN0YW50U3RyZWFtKCk7XG4gICAgcnVubmVyLl9ydW4oKCkgPT5cbiAgICAgIHJ1bm5lci5fcnVuQXNzaXN0YW50U3RyZWFtKHRocmVhZElkLCBydW5zLCBwYXJhbXMsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtSGVscGVyLU1ldGhvZCc6ICdzdHJlYW0nIH0sXG4gICAgICB9KSxcbiAgICApO1xuICAgIHJldHVybiBydW5uZXI7XG4gIH1cblxuICBjdXJyZW50RXZlbnQoKTogQXNzaXN0YW50U3RyZWFtRXZlbnQgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50RXZlbnQ7XG4gIH1cblxuICBjdXJyZW50UnVuKCk6IFJ1biB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRSdW5TbmFwc2hvdDtcbiAgfVxuXG4gIGN1cnJlbnRNZXNzYWdlU25hcHNob3QoKTogTWVzc2FnZSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuI21lc3NhZ2VTbmFwc2hvdDtcbiAgfVxuXG4gIGN1cnJlbnRSdW5TdGVwU25hcHNob3QoKTogUnVucy5SdW5TdGVwIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudFJ1blN0ZXBTbmFwc2hvdDtcbiAgfVxuXG4gIGFzeW5jIGZpbmFsUnVuU3RlcHMoKTogUHJvbWlzZTxSdW5zLlJ1blN0ZXBbXT4ge1xuICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy4jcnVuU3RlcFNuYXBzaG90cyk7XG4gIH1cblxuICBhc3luYyBmaW5hbE1lc3NhZ2VzKCk6IFByb21pc2U8TWVzc2FnZVtdPiB7XG4gICAgYXdhaXQgdGhpcy5kb25lKCk7XG5cbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLiNtZXNzYWdlU25hcHNob3RzKTtcbiAgfVxuXG4gIGFzeW5jIGZpbmFsUnVuKCk6IFByb21pc2U8UnVuPiB7XG4gICAgYXdhaXQgdGhpcy5kb25lKCk7XG4gICAgaWYgKCF0aGlzLiNmaW5hbFJ1bikgdGhyb3cgRXJyb3IoJ0ZpbmFsIHJ1biB3YXMgbm90IHJlY2VpdmVkLicpO1xuXG4gICAgcmV0dXJuIHRoaXMuI2ZpbmFsUnVuO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9jcmVhdGVUaHJlYWRBc3Npc3RhbnRTdHJlYW0oXG4gICAgdGhyZWFkOiBUaHJlYWRzLFxuICAgIHBhcmFtczogVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zQmFzZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxSdW4+IHtcbiAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXMuY29udHJvbGxlci5hYm9ydCgpKTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5OiBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSB7IC4uLnBhcmFtcywgc3RyZWFtOiB0cnVlIH07XG4gICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgdGhyZWFkLmNyZWF0ZUFuZFJ1bihib2R5LCB7IC4uLm9wdGlvbnMsIHNpZ25hbDogdGhpcy5jb250cm9sbGVyLnNpZ25hbCB9KTtcblxuICAgIHRoaXMuX2Nvbm5lY3RlZCgpO1xuXG4gICAgZm9yIGF3YWl0IChjb25zdCBldmVudCBvZiBzdHJlYW0pIHtcbiAgICAgIHRoaXMuI2FkZEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5jb250cm9sbGVyLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2FkZFJ1bih0aGlzLiNlbmRSZXF1ZXN0KCkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9jcmVhdGVBc3Npc3RhbnRTdHJlYW0oXG4gICAgcnVuOiBSdW5zLFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcGFyYW1zOiBSdW5DcmVhdGVQYXJhbXNCYXNlLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBQcm9taXNlPFJ1bj4ge1xuICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbDtcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gdGhpcy5jb250cm9sbGVyLmFib3J0KCkpO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHk6IFJ1bkNyZWF0ZVBhcmFtc1N0cmVhbWluZyA9IHsgLi4ucGFyYW1zLCBzdHJlYW06IHRydWUgfTtcbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBydW4uY3JlYXRlKHRocmVhZElkLCBib2R5LCB7IC4uLm9wdGlvbnMsIHNpZ25hbDogdGhpcy5jb250cm9sbGVyLnNpZ25hbCB9KTtcblxuICAgIHRoaXMuX2Nvbm5lY3RlZCgpO1xuXG4gICAgZm9yIGF3YWl0IChjb25zdCBldmVudCBvZiBzdHJlYW0pIHtcbiAgICAgIHRoaXMuI2FkZEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5jb250cm9sbGVyLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2FkZFJ1bih0aGlzLiNlbmRSZXF1ZXN0KCkpO1xuICB9XG5cbiAgI2FkZEV2ZW50KGV2ZW50OiBBc3Npc3RhbnRTdHJlYW1FdmVudCkge1xuICAgIGlmICh0aGlzLmVuZGVkKSByZXR1cm47XG5cbiAgICB0aGlzLiNjdXJyZW50RXZlbnQgPSBldmVudDtcblxuICAgIHRoaXMuI2hhbmRsZUV2ZW50KGV2ZW50KTtcblxuICAgIHN3aXRjaCAoZXZlbnQuZXZlbnQpIHtcbiAgICAgIGNhc2UgJ3RocmVhZC5jcmVhdGVkJzpcbiAgICAgICAgLy9ObyBhY3Rpb24gb24gdGhpcyBldmVudC5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uY3JlYXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnF1ZXVlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmluX3Byb2dyZXNzJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4ucmVxdWlyZXNfYWN0aW9uJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uY29tcGxldGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uZmFpbGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uY2FuY2VsbGluZyc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmNhbmNlbGxlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmV4cGlyZWQnOlxuICAgICAgICB0aGlzLiNoYW5kbGVSdW4oZXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmNyZWF0ZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmluX3Byb2dyZXNzJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5kZWx0YSc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY29tcGxldGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5mYWlsZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmNhbmNlbGxlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZXhwaXJlZCc6XG4gICAgICAgIHRoaXMuI2hhbmRsZVJ1blN0ZXAoZXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuY3JlYXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5pbl9wcm9ncmVzcyc6XG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5kZWx0YSc6XG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5jb21wbGV0ZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuaW5jb21wbGV0ZSc6XG4gICAgICAgIHRoaXMuI2hhbmRsZU1lc3NhZ2UoZXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAvL1RoaXMgaXMgaW5jbHVkZWQgZm9yIGNvbXBsZXRlbmVzcywgYnV0IGVycm9ycyBhcmUgcHJvY2Vzc2VkIGluIHRoZSBTU0UgZXZlbnQgcHJvY2Vzc2luZyBzbyB0aGlzIHNob3VsZCBub3Qgb2NjdXJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdFbmNvdW50ZXJlZCBhbiBlcnJvciBldmVudCBpbiBldmVudCBwcm9jZXNzaW5nIC0gZXJyb3JzIHNob3VsZCBiZSBwcm9jZXNzZWQgZWFybGllcicsXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgI2VuZFJlcXVlc3QoKTogUnVuIHtcbiAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBzdHJlYW0gaGFzIGVuZGVkLCB0aGlzIHNob3VsZG4ndCBoYXBwZW5gKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuI2ZpbmFsUnVuKSB0aHJvdyBFcnJvcignRmluYWwgcnVuIGhhcyBub3QgYmVlbiByZWNlaXZlZCcpO1xuXG4gICAgcmV0dXJuIHRoaXMuI2ZpbmFsUnVuO1xuICB9XG5cbiAgI2hhbmRsZU1lc3NhZ2UodGhpczogQXNzaXN0YW50U3RyZWFtLCBldmVudDogTWVzc2FnZVN0cmVhbUV2ZW50KSB7XG4gICAgY29uc3QgW2FjY3VtdWxhdGVkTWVzc2FnZSwgbmV3Q29udGVudF0gPSB0aGlzLiNhY2N1bXVsYXRlTWVzc2FnZShldmVudCwgdGhpcy4jbWVzc2FnZVNuYXBzaG90KTtcbiAgICB0aGlzLiNtZXNzYWdlU25hcHNob3QgPSBhY2N1bXVsYXRlZE1lc3NhZ2U7XG4gICAgdGhpcy4jbWVzc2FnZVNuYXBzaG90c1thY2N1bXVsYXRlZE1lc3NhZ2UuaWRdID0gYWNjdW11bGF0ZWRNZXNzYWdlO1xuXG4gICAgZm9yIChjb25zdCBjb250ZW50IG9mIG5ld0NvbnRlbnQpIHtcbiAgICAgIGNvbnN0IHNuYXBzaG90Q29udGVudCA9IGFjY3VtdWxhdGVkTWVzc2FnZS5jb250ZW50W2NvbnRlbnQuaW5kZXhdO1xuICAgICAgaWYgKHNuYXBzaG90Q29udGVudD8udHlwZSA9PSAndGV4dCcpIHtcbiAgICAgICAgdGhpcy5fZW1pdCgndGV4dENyZWF0ZWQnLCBzbmFwc2hvdENvbnRlbnQudGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChldmVudC5ldmVudCkge1xuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuY3JlYXRlZCc6XG4gICAgICAgIHRoaXMuX2VtaXQoJ21lc3NhZ2VDcmVhdGVkJywgZXZlbnQuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5pbl9wcm9ncmVzcyc6XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5kZWx0YSc6XG4gICAgICAgIHRoaXMuX2VtaXQoJ21lc3NhZ2VEZWx0YScsIGV2ZW50LmRhdGEuZGVsdGEsIGFjY3VtdWxhdGVkTWVzc2FnZSk7XG5cbiAgICAgICAgaWYgKGV2ZW50LmRhdGEuZGVsdGEuY29udGVudCkge1xuICAgICAgICAgIGZvciAoY29uc3QgY29udGVudCBvZiBldmVudC5kYXRhLmRlbHRhLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vSWYgaXQgaXMgdGV4dCBkZWx0YSwgZW1pdCBhIHRleHQgZGVsdGEgZXZlbnRcbiAgICAgICAgICAgIGlmIChjb250ZW50LnR5cGUgPT0gJ3RleHQnICYmIGNvbnRlbnQudGV4dCkge1xuICAgICAgICAgICAgICBsZXQgdGV4dERlbHRhID0gY29udGVudC50ZXh0O1xuICAgICAgICAgICAgICBsZXQgc25hcHNob3QgPSBhY2N1bXVsYXRlZE1lc3NhZ2UuY29udGVudFtjb250ZW50LmluZGV4XTtcbiAgICAgICAgICAgICAgaWYgKHNuYXBzaG90ICYmIHNuYXBzaG90LnR5cGUgPT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgndGV4dERlbHRhJywgdGV4dERlbHRhLCBzbmFwc2hvdC50ZXh0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVGhlIHNuYXBzaG90IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRleHQgZGVsdGEgaXMgbm90IHRleHQgb3IgbWlzc2luZycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb250ZW50LmluZGV4ICE9IHRoaXMuI2N1cnJlbnRDb250ZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgLy9TZWUgaWYgd2UgaGF2ZSBpbiBwcm9ncmVzcyBjb250ZW50XG4gICAgICAgICAgICAgIGlmICh0aGlzLiNjdXJyZW50Q29udGVudCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy4jY3VycmVudENvbnRlbnQudHlwZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3RleHREb25lJywgdGhpcy4jY3VycmVudENvbnRlbnQudGV4dCwgdGhpcy4jbWVzc2FnZVNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdpbWFnZV9maWxlJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgnaW1hZ2VGaWxlRG9uZScsIHRoaXMuI2N1cnJlbnRDb250ZW50LmltYWdlX2ZpbGUsIHRoaXMuI21lc3NhZ2VTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuI2N1cnJlbnRDb250ZW50SW5kZXggPSBjb250ZW50LmluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiNjdXJyZW50Q29udGVudCA9IGFjY3VtdWxhdGVkTWVzc2FnZS5jb250ZW50W2NvbnRlbnQuaW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5jb21wbGV0ZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuaW5jb21wbGV0ZSc6XG4gICAgICAgIC8vV2UgZW1pdCB0aGUgbGF0ZXN0IGNvbnRlbnQgd2Ugd2VyZSB3b3JraW5nIG9uIG9uIGNvbXBsZXRpb24gKGluY2x1ZGluZyBpbmNvbXBsZXRlKVxuICAgICAgICBpZiAodGhpcy4jY3VycmVudENvbnRlbnRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudENvbnRlbnQgPSBldmVudC5kYXRhLmNvbnRlbnRbdGhpcy4jY3VycmVudENvbnRlbnRJbmRleF07XG4gICAgICAgICAgaWYgKGN1cnJlbnRDb250ZW50KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnRDb250ZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnaW1hZ2VfZmlsZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgnaW1hZ2VGaWxlRG9uZScsIGN1cnJlbnRDb250ZW50LmltYWdlX2ZpbGUsIHRoaXMuI21lc3NhZ2VTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3RleHREb25lJywgY3VycmVudENvbnRlbnQudGV4dCwgdGhpcy4jbWVzc2FnZVNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy4jbWVzc2FnZVNuYXBzaG90KSB7XG4gICAgICAgICAgdGhpcy5fZW1pdCgnbWVzc2FnZURvbmUnLCBldmVudC5kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuI21lc3NhZ2VTbmFwc2hvdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAjaGFuZGxlUnVuU3RlcCh0aGlzOiBBc3Npc3RhbnRTdHJlYW0sIGV2ZW50OiBSdW5TdGVwU3RyZWFtRXZlbnQpIHtcbiAgICBjb25zdCBhY2N1bXVsYXRlZFJ1blN0ZXAgPSB0aGlzLiNhY2N1bXVsYXRlUnVuU3RlcChldmVudCk7XG4gICAgdGhpcy4jY3VycmVudFJ1blN0ZXBTbmFwc2hvdCA9IGFjY3VtdWxhdGVkUnVuU3RlcDtcblxuICAgIHN3aXRjaCAoZXZlbnQuZXZlbnQpIHtcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jcmVhdGVkJzpcbiAgICAgICAgdGhpcy5fZW1pdCgncnVuU3RlcENyZWF0ZWQnLCBldmVudC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZGVsdGEnOlxuICAgICAgICBjb25zdCBkZWx0YSA9IGV2ZW50LmRhdGEuZGVsdGE7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBkZWx0YS5zdGVwX2RldGFpbHMgJiZcbiAgICAgICAgICBkZWx0YS5zdGVwX2RldGFpbHMudHlwZSA9PSAndG9vbF9jYWxscycgJiZcbiAgICAgICAgICBkZWx0YS5zdGVwX2RldGFpbHMudG9vbF9jYWxscyAmJlxuICAgICAgICAgIGFjY3VtdWxhdGVkUnVuU3RlcC5zdGVwX2RldGFpbHMudHlwZSA9PSAndG9vbF9jYWxscydcbiAgICAgICAgKSB7XG4gICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBkZWx0YS5zdGVwX2RldGFpbHMudG9vbF9jYWxscykge1xuICAgICAgICAgICAgaWYgKHRvb2xDYWxsLmluZGV4ID09IHRoaXMuI2N1cnJlbnRUb29sQ2FsbEluZGV4KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2VtaXQoXG4gICAgICAgICAgICAgICAgJ3Rvb2xDYWxsRGVsdGEnLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsLFxuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkUnVuU3RlcC5zdGVwX2RldGFpbHMudG9vbF9jYWxsc1t0b29sQ2FsbC5pbmRleF0gYXMgVG9vbENhbGwsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodGhpcy4jY3VycmVudFRvb2xDYWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgndG9vbENhbGxEb25lJywgdGhpcy4jY3VycmVudFRvb2xDYWxsKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuI2N1cnJlbnRUb29sQ2FsbEluZGV4ID0gdG9vbENhbGwuaW5kZXg7XG4gICAgICAgICAgICAgIHRoaXMuI2N1cnJlbnRUb29sQ2FsbCA9IGFjY3VtdWxhdGVkUnVuU3RlcC5zdGVwX2RldGFpbHMudG9vbF9jYWxsc1t0b29sQ2FsbC5pbmRleF07XG4gICAgICAgICAgICAgIGlmICh0aGlzLiNjdXJyZW50VG9vbENhbGwpIHRoaXMuX2VtaXQoJ3Rvb2xDYWxsQ3JlYXRlZCcsIHRoaXMuI2N1cnJlbnRUb29sQ2FsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZW1pdCgncnVuU3RlcERlbHRhJywgZXZlbnQuZGF0YS5kZWx0YSwgYWNjdW11bGF0ZWRSdW5TdGVwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY29tcGxldGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5mYWlsZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmNhbmNlbGxlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZXhwaXJlZCc6XG4gICAgICAgIHRoaXMuI2N1cnJlbnRSdW5TdGVwU25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBldmVudC5kYXRhLnN0ZXBfZGV0YWlscztcbiAgICAgICAgaWYgKGRldGFpbHMudHlwZSA9PSAndG9vbF9jYWxscycpIHtcbiAgICAgICAgICBpZiAodGhpcy4jY3VycmVudFRvb2xDYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCd0b29sQ2FsbERvbmUnLCB0aGlzLiNjdXJyZW50VG9vbENhbGwgYXMgVG9vbENhbGwpO1xuICAgICAgICAgICAgdGhpcy4jY3VycmVudFRvb2xDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbWl0KCdydW5TdGVwRG9uZScsIGV2ZW50LmRhdGEsIGFjY3VtdWxhdGVkUnVuU3RlcCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmluX3Byb2dyZXNzJzpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgI2hhbmRsZUV2ZW50KHRoaXM6IEFzc2lzdGFudFN0cmVhbSwgZXZlbnQ6IEFzc2lzdGFudFN0cmVhbUV2ZW50KSB7XG4gICAgdGhpcy4jZXZlbnRzLnB1c2goZXZlbnQpO1xuICAgIHRoaXMuX2VtaXQoJ2V2ZW50JywgZXZlbnQpO1xuICB9XG5cbiAgI2FjY3VtdWxhdGVSdW5TdGVwKGV2ZW50OiBSdW5TdGVwU3RyZWFtRXZlbnQpOiBSdW5zLlJ1blN0ZXAge1xuICAgIHN3aXRjaCAoZXZlbnQuZXZlbnQpIHtcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jcmVhdGVkJzpcbiAgICAgICAgdGhpcy4jcnVuU3RlcFNuYXBzaG90c1tldmVudC5kYXRhLmlkXSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIHJldHVybiBldmVudC5kYXRhO1xuXG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZGVsdGEnOlxuICAgICAgICBsZXQgc25hcHNob3QgPSB0aGlzLiNydW5TdGVwU25hcHNob3RzW2V2ZW50LmRhdGEuaWRdIGFzIFJ1bnMuUnVuU3RlcDtcbiAgICAgICAgaWYgKCFzbmFwc2hvdCkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdSZWNlaXZlZCBhIFJ1blN0ZXBEZWx0YSBiZWZvcmUgY3JlYXRpb24gb2YgYSBzbmFwc2hvdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRhdGEgPSBldmVudC5kYXRhO1xuXG4gICAgICAgIGlmIChkYXRhLmRlbHRhKSB7XG4gICAgICAgICAgY29uc3QgYWNjdW11bGF0ZWQgPSBBc3Npc3RhbnRTdHJlYW0uYWNjdW11bGF0ZURlbHRhKHNuYXBzaG90LCBkYXRhLmRlbHRhKSBhcyBSdW5zLlJ1blN0ZXA7XG4gICAgICAgICAgdGhpcy4jcnVuU3RlcFNuYXBzaG90c1tldmVudC5kYXRhLmlkXSA9IGFjY3VtdWxhdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuI3J1blN0ZXBTbmFwc2hvdHNbZXZlbnQuZGF0YS5pZF0gYXMgUnVucy5SdW5TdGVwO1xuXG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY29tcGxldGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5mYWlsZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmNhbmNlbGxlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZXhwaXJlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuaW5fcHJvZ3Jlc3MnOlxuICAgICAgICB0aGlzLiNydW5TdGVwU25hcHNob3RzW2V2ZW50LmRhdGEuaWRdID0gZXZlbnQuZGF0YTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuI3J1blN0ZXBTbmFwc2hvdHNbZXZlbnQuZGF0YS5pZF0pIHJldHVybiB0aGlzLiNydW5TdGVwU25hcHNob3RzW2V2ZW50LmRhdGEuaWRdIGFzIFJ1bnMuUnVuU3RlcDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNuYXBzaG90IGF2YWlsYWJsZScpO1xuICB9XG5cbiAgI2FjY3VtdWxhdGVNZXNzYWdlKFxuICAgIGV2ZW50OiBBc3Npc3RhbnRTdHJlYW1FdmVudCxcbiAgICBzbmFwc2hvdDogTWVzc2FnZSB8IHVuZGVmaW5lZCxcbiAgKTogW01lc3NhZ2UsIE1lc3NhZ2VDb250ZW50RGVsdGFbXV0ge1xuICAgIGxldCBuZXdDb250ZW50OiBNZXNzYWdlQ29udGVudERlbHRhW10gPSBbXTtcblxuICAgIHN3aXRjaCAoZXZlbnQuZXZlbnQpIHtcbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmNyZWF0ZWQnOlxuICAgICAgICAvL09uIGNyZWF0aW9uIHRoZSBzbmFwc2hvdCBpcyBqdXN0IHRoZSBpbml0aWFsIG1lc3NhZ2VcbiAgICAgICAgcmV0dXJuIFtldmVudC5kYXRhLCBuZXdDb250ZW50XTtcblxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuZGVsdGEnOlxuICAgICAgICBpZiAoIXNuYXBzaG90KSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAnUmVjZWl2ZWQgYSBkZWx0YSB3aXRoIG5vIGV4aXN0aW5nIHNuYXBzaG90ICh0aGVyZSBzaG91bGQgYmUgb25lIGZyb20gbWVzc2FnZSBjcmVhdGlvbiknLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGF0YSA9IGV2ZW50LmRhdGE7XG5cbiAgICAgICAgLy9JZiB0aGlzIGRlbHRhIGRvZXMgbm90IGhhdmUgY29udGVudCwgbm90aGluZyB0byBwcm9jZXNzXG4gICAgICAgIGlmIChkYXRhLmRlbHRhLmNvbnRlbnQpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRlbnRFbGVtZW50IG9mIGRhdGEuZGVsdGEuY29udGVudCkge1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRFbGVtZW50LmluZGV4IGluIHNuYXBzaG90LmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgbGV0IGN1cnJlbnRDb250ZW50ID0gc25hcHNob3QuY29udGVudFtjb250ZW50RWxlbWVudC5pbmRleF07XG4gICAgICAgICAgICAgIHNuYXBzaG90LmNvbnRlbnRbY29udGVudEVsZW1lbnQuaW5kZXhdID0gdGhpcy4jYWNjdW11bGF0ZUNvbnRlbnQoXG4gICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRlbnQsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzbmFwc2hvdC5jb250ZW50W2NvbnRlbnRFbGVtZW50LmluZGV4XSA9IGNvbnRlbnRFbGVtZW50IGFzIE1lc3NhZ2VDb250ZW50O1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgICAgbmV3Q29udGVudC5wdXNoKGNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3NuYXBzaG90LCBuZXdDb250ZW50XTtcblxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuaW5fcHJvZ3Jlc3MnOlxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuY29tcGxldGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmluY29tcGxldGUnOlxuICAgICAgICAvL05vIGNoYW5nZXMgb24gb3RoZXIgdGhyZWFkIGV2ZW50c1xuICAgICAgICBpZiAoc25hcHNob3QpIHtcbiAgICAgICAgICByZXR1cm4gW3NuYXBzaG90LCBuZXdDb250ZW50XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignUmVjZWl2ZWQgdGhyZWFkIG1lc3NhZ2UgZXZlbnQgd2l0aCBubyBleGlzdGluZyBzbmFwc2hvdCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdUcmllZCB0byBhY2N1bXVsYXRlIGEgbm9uLW1lc3NhZ2UgZXZlbnQnKTtcbiAgfVxuXG4gICNhY2N1bXVsYXRlQ29udGVudChcbiAgICBjb250ZW50RWxlbWVudDogTWVzc2FnZUNvbnRlbnREZWx0YSxcbiAgICBjdXJyZW50Q29udGVudDogTWVzc2FnZUNvbnRlbnQgfCB1bmRlZmluZWQsXG4gICk6IFRleHRDb250ZW50QmxvY2sgfCBJbWFnZUZpbGVDb250ZW50QmxvY2sge1xuICAgIHJldHVybiBBc3Npc3RhbnRTdHJlYW0uYWNjdW11bGF0ZURlbHRhKGN1cnJlbnRDb250ZW50IGFzIHVua25vd24gYXMgUmVjb3JkPGFueSwgYW55PiwgY29udGVudEVsZW1lbnQpIGFzXG4gICAgICB8IFRleHRDb250ZW50QmxvY2tcbiAgICAgIHwgSW1hZ2VGaWxlQ29udGVudEJsb2NrO1xuICB9XG5cbiAgc3RhdGljIGFjY3VtdWxhdGVEZWx0YShhY2M6IFJlY29yZDxzdHJpbmcsIGFueT4sIGRlbHRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgZm9yIChjb25zdCBba2V5LCBkZWx0YVZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkZWx0YSkpIHtcbiAgICAgIGlmICghYWNjLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgYWNjW2tleV0gPSBkZWx0YVZhbHVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGFjY1ZhbHVlID0gYWNjW2tleV07XG4gICAgICBpZiAoYWNjVmFsdWUgPT09IG51bGwgfHwgYWNjVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhY2Nba2V5XSA9IGRlbHRhVmFsdWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBkb24ndCBhY2N1bXVsYXRlIHRoZXNlIHNwZWNpYWwgcHJvcGVydGllc1xuICAgICAgaWYgKGtleSA9PT0gJ2luZGV4JyB8fCBrZXkgPT09ICd0eXBlJykge1xuICAgICAgICBhY2Nba2V5XSA9IGRlbHRhVmFsdWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBUeXBlLXNwZWNpZmljIGFjY3VtdWxhdGlvbiBsb2dpY1xuICAgICAgaWYgKHR5cGVvZiBhY2NWYWx1ZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGRlbHRhVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFjY1ZhbHVlICs9IGRlbHRhVmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhY2NWYWx1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGRlbHRhVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGFjY1ZhbHVlICs9IGRlbHRhVmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKENvcmUuaXNPYmooYWNjVmFsdWUpICYmIENvcmUuaXNPYmooZGVsdGFWYWx1ZSkpIHtcbiAgICAgICAgYWNjVmFsdWUgPSB0aGlzLmFjY3VtdWxhdGVEZWx0YShhY2NWYWx1ZSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBkZWx0YVZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIGFueT4pO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFjY1ZhbHVlKSAmJiBBcnJheS5pc0FycmF5KGRlbHRhVmFsdWUpKSB7XG4gICAgICAgIGlmIChhY2NWYWx1ZS5ldmVyeSgoeCkgPT4gdHlwZW9mIHggPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB4ID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICBhY2NWYWx1ZS5wdXNoKC4uLmRlbHRhVmFsdWUpOyAvLyBVc2Ugc3ByZWFkIHN5bnRheCBmb3IgZWZmaWNpZW50IGFkZGl0aW9uXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGRlbHRhRW50cnkgb2YgZGVsdGFWYWx1ZSkge1xuICAgICAgICAgIGlmICghQ29yZS5pc09iaihkZWx0YUVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhcnJheSBkZWx0YSBlbnRyeSB0byBiZSBhbiBvYmplY3QgYnV0IGdvdDogJHtkZWx0YUVudHJ5fWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGluZGV4ID0gZGVsdGFFbnRyeVsnaW5kZXgnXTtcbiAgICAgICAgICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihkZWx0YUVudHJ5KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYXJyYXkgZGVsdGEgZW50cnkgdG8gaGF2ZSBhbiBgaW5kZXhgIHByb3BlcnR5Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXJyYXkgZGVsdGEgZW50cnkgXFxgaW5kZXhcXGAgcHJvcGVydHkgdG8gYmUgYSBudW1iZXIgYnV0IGdvdCAke2luZGV4fWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGFjY0VudHJ5ID0gYWNjVmFsdWVbaW5kZXhdO1xuICAgICAgICAgIGlmIChhY2NFbnRyeSA9PSBudWxsKSB7XG4gICAgICAgICAgICBhY2NWYWx1ZS5wdXNoKGRlbHRhRW50cnkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2NWYWx1ZVtpbmRleF0gPSB0aGlzLmFjY3VtdWxhdGVEZWx0YShhY2NFbnRyeSwgZGVsdGFFbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVuaGFuZGxlZCByZWNvcmQgdHlwZTogJHtrZXl9LCBkZWx0YVZhbHVlOiAke2RlbHRhVmFsdWV9LCBhY2NWYWx1ZTogJHthY2NWYWx1ZX1gKTtcbiAgICAgIH1cbiAgICAgIGFjY1trZXldID0gYWNjVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfVxuXG4gICNoYW5kbGVSdW4odGhpczogQXNzaXN0YW50U3RyZWFtLCBldmVudDogUnVuU3RyZWFtRXZlbnQpIHtcbiAgICB0aGlzLiNjdXJyZW50UnVuU25hcHNob3QgPSBldmVudC5kYXRhO1xuICAgIHN3aXRjaCAoZXZlbnQuZXZlbnQpIHtcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uY3JlYXRlZCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5xdWV1ZWQnOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uaW5fcHJvZ3Jlc3MnOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4ucmVxdWlyZXNfYWN0aW9uJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uY2FuY2VsbGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uZmFpbGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uY29tcGxldGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uZXhwaXJlZCc6XG4gICAgICAgIHRoaXMuI2ZpbmFsUnVuID0gZXZlbnQuZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuI2N1cnJlbnRUb29sQ2FsbCkge1xuICAgICAgICAgIHRoaXMuX2VtaXQoJ3Rvb2xDYWxsRG9uZScsIHRoaXMuI2N1cnJlbnRUb29sQ2FsbCk7XG4gICAgICAgICAgdGhpcy4jY3VycmVudFRvb2xDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jYW5jZWxsaW5nJzpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9hZGRSdW4ocnVuOiBSdW4pOiBSdW4ge1xuICAgIHJldHVybiBydW47XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX3RocmVhZEFzc2lzdGFudFN0cmVhbShcbiAgICBwYXJhbXM6IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc0Jhc2UsXG4gICAgdGhyZWFkOiBUaHJlYWRzLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBQcm9taXNlPFJ1bj4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9jcmVhdGVUaHJlYWRBc3Npc3RhbnRTdHJlYW0odGhyZWFkLCBwYXJhbXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9ydW5Bc3Npc3RhbnRTdHJlYW0oXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5zOiBSdW5zLFxuICAgIHBhcmFtczogUnVuQ3JlYXRlUGFyYW1zQmFzZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxSdW4+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fY3JlYXRlQXNzaXN0YW50U3RyZWFtKHJ1bnMsIHRocmVhZElkLCBwYXJhbXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9ydW5Ub29sQXNzaXN0YW50U3RyZWFtKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBydW5zOiBSdW5zLFxuICAgIHBhcmFtczogUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW0sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IFByb21pc2U8UnVuPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2NyZWF0ZVRvb2xBc3Npc3RhbnRTdHJlYW0ocnVucywgdGhyZWFkSWQsIHJ1bklkLCBwYXJhbXMsIG9wdGlvbnMpO1xuICB9XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQXNzaXN0YW50c0FQSSBmcm9tICcuLi9hc3Npc3RhbnRzJztcbmltcG9ydCB7IEN1cnNvclBhZ2UsIHR5cGUgQ3Vyc29yUGFnZVBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL3BhZ2luYXRpb24nO1xuXG5leHBvcnQgY2xhc3MgTWVzc2FnZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtZXNzYWdlLlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgYm9keTogTWVzc2FnZUNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPE1lc3NhZ2U+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L21lc3NhZ2VzYCwge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGEgbWVzc2FnZS5cbiAgICovXG4gIHJldHJpZXZlKHRocmVhZElkOiBzdHJpbmcsIG1lc3NhZ2VJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxNZXNzYWdlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC90aHJlYWRzLyR7dGhyZWFkSWR9L21lc3NhZ2VzLyR7bWVzc2FnZUlkfWAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIGEgbWVzc2FnZS5cbiAgICovXG4gIHVwZGF0ZShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIG1lc3NhZ2VJZDogc3RyaW5nLFxuICAgIGJvZHk6IE1lc3NhZ2VVcGRhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxNZXNzYWdlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9tZXNzYWdlcy8ke21lc3NhZ2VJZH1gLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgbWVzc2FnZXMgZm9yIGEgZ2l2ZW4gdGhyZWFkLlxuICAgKi9cbiAgbGlzdChcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHF1ZXJ5PzogTWVzc2FnZUxpc3RQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8TWVzc2FnZXNQYWdlLCBNZXNzYWdlPjtcbiAgbGlzdCh0aHJlYWRJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuUGFnZVByb21pc2U8TWVzc2FnZXNQYWdlLCBNZXNzYWdlPjtcbiAgbGlzdChcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHF1ZXJ5OiBNZXNzYWdlTGlzdFBhcmFtcyB8IENvcmUuUmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxNZXNzYWdlc1BhZ2UsIE1lc3NhZ2U+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3QodGhyZWFkSWQsIHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vbWVzc2FnZXNgLCBNZXNzYWdlc1BhZ2UsIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhIG1lc3NhZ2UuXG4gICAqL1xuICBkZWwodGhyZWFkSWQ6IHN0cmluZywgbWVzc2FnZUlkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPE1lc3NhZ2VEZWxldGVkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5kZWxldGUoYC90aHJlYWRzLyR7dGhyZWFkSWR9L21lc3NhZ2VzLyR7bWVzc2FnZUlkfWAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNZXNzYWdlc1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlPE1lc3NhZ2U+IHt9XG5cbi8qKlxuICogQSBjaXRhdGlvbiB3aXRoaW4gdGhlIG1lc3NhZ2UgdGhhdCBwb2ludHMgdG8gYSBzcGVjaWZpYyBxdW90ZSBmcm9tIGEgc3BlY2lmaWNcbiAqIEZpbGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3Npc3RhbnQgb3IgdGhlIG1lc3NhZ2UuIEdlbmVyYXRlZCB3aGVuIHRoZSBhc3Npc3RhbnRcbiAqIHVzZXMgdGhlIFwiZmlsZV9zZWFyY2hcIiB0b29sIHRvIHNlYXJjaCBmaWxlcy5cbiAqL1xuZXhwb3J0IHR5cGUgQW5ub3RhdGlvbiA9IEZpbGVDaXRhdGlvbkFubm90YXRpb24gfCBGaWxlUGF0aEFubm90YXRpb247XG5cbi8qKlxuICogQSBjaXRhdGlvbiB3aXRoaW4gdGhlIG1lc3NhZ2UgdGhhdCBwb2ludHMgdG8gYSBzcGVjaWZpYyBxdW90ZSBmcm9tIGEgc3BlY2lmaWNcbiAqIEZpbGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3Npc3RhbnQgb3IgdGhlIG1lc3NhZ2UuIEdlbmVyYXRlZCB3aGVuIHRoZSBhc3Npc3RhbnRcbiAqIHVzZXMgdGhlIFwiZmlsZV9zZWFyY2hcIiB0b29sIHRvIHNlYXJjaCBmaWxlcy5cbiAqL1xuZXhwb3J0IHR5cGUgQW5ub3RhdGlvbkRlbHRhID0gRmlsZUNpdGF0aW9uRGVsdGFBbm5vdGF0aW9uIHwgRmlsZVBhdGhEZWx0YUFubm90YXRpb247XG5cbi8qKlxuICogQSBjaXRhdGlvbiB3aXRoaW4gdGhlIG1lc3NhZ2UgdGhhdCBwb2ludHMgdG8gYSBzcGVjaWZpYyBxdW90ZSBmcm9tIGEgc3BlY2lmaWNcbiAqIEZpbGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3Npc3RhbnQgb3IgdGhlIG1lc3NhZ2UuIEdlbmVyYXRlZCB3aGVuIHRoZSBhc3Npc3RhbnRcbiAqIHVzZXMgdGhlIFwiZmlsZV9zZWFyY2hcIiB0b29sIHRvIHNlYXJjaCBmaWxlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaWxlQ2l0YXRpb25Bbm5vdGF0aW9uIHtcbiAgZW5kX2luZGV4OiBudW1iZXI7XG5cbiAgZmlsZV9jaXRhdGlvbjogRmlsZUNpdGF0aW9uQW5ub3RhdGlvbi5GaWxlQ2l0YXRpb247XG5cbiAgc3RhcnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHRleHQgaW4gdGhlIG1lc3NhZ2UgY29udGVudCB0aGF0IG5lZWRzIHRvIGJlIHJlcGxhY2VkLlxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYGZpbGVfY2l0YXRpb25gLlxuICAgKi9cbiAgdHlwZTogJ2ZpbGVfY2l0YXRpb24nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZpbGVDaXRhdGlvbkFubm90YXRpb24ge1xuICBleHBvcnQgaW50ZXJmYWNlIEZpbGVDaXRhdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBzcGVjaWZpYyBGaWxlIHRoZSBjaXRhdGlvbiBpcyBmcm9tLlxuICAgICAqL1xuICAgIGZpbGVfaWQ6IHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIEEgY2l0YXRpb24gd2l0aGluIHRoZSBtZXNzYWdlIHRoYXQgcG9pbnRzIHRvIGEgc3BlY2lmaWMgcXVvdGUgZnJvbSBhIHNwZWNpZmljXG4gKiBGaWxlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzaXN0YW50IG9yIHRoZSBtZXNzYWdlLiBHZW5lcmF0ZWQgd2hlbiB0aGUgYXNzaXN0YW50XG4gKiB1c2VzIHRoZSBcImZpbGVfc2VhcmNoXCIgdG9vbCB0byBzZWFyY2ggZmlsZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUNpdGF0aW9uRGVsdGFBbm5vdGF0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgYW5ub3RhdGlvbiBpbiB0aGUgdGV4dCBjb250ZW50IHBhcnQuXG4gICAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYGZpbGVfY2l0YXRpb25gLlxuICAgKi9cbiAgdHlwZTogJ2ZpbGVfY2l0YXRpb24nO1xuXG4gIGVuZF9pbmRleD86IG51bWJlcjtcblxuICBmaWxlX2NpdGF0aW9uPzogRmlsZUNpdGF0aW9uRGVsdGFBbm5vdGF0aW9uLkZpbGVDaXRhdGlvbjtcblxuICBzdGFydF9pbmRleD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHRleHQgaW4gdGhlIG1lc3NhZ2UgY29udGVudCB0aGF0IG5lZWRzIHRvIGJlIHJlcGxhY2VkLlxuICAgKi9cbiAgdGV4dD86IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaWxlQ2l0YXRpb25EZWx0YUFubm90YXRpb24ge1xuICBleHBvcnQgaW50ZXJmYWNlIEZpbGVDaXRhdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBzcGVjaWZpYyBGaWxlIHRoZSBjaXRhdGlvbiBpcyBmcm9tLlxuICAgICAqL1xuICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3BlY2lmaWMgcXVvdGUgaW4gdGhlIGZpbGUuXG4gICAgICovXG4gICAgcXVvdGU/OiBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBBIFVSTCBmb3IgdGhlIGZpbGUgdGhhdCdzIGdlbmVyYXRlZCB3aGVuIHRoZSBhc3Npc3RhbnQgdXNlZCB0aGVcbiAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHRvIGdlbmVyYXRlIGEgZmlsZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaWxlUGF0aEFubm90YXRpb24ge1xuICBlbmRfaW5kZXg6IG51bWJlcjtcblxuICBmaWxlX3BhdGg6IEZpbGVQYXRoQW5ub3RhdGlvbi5GaWxlUGF0aDtcblxuICBzdGFydF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdGV4dCBpbiB0aGUgbWVzc2FnZSBjb250ZW50IHRoYXQgbmVlZHMgdG8gYmUgcmVwbGFjZWQuXG4gICAqL1xuICB0ZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgZmlsZV9wYXRoYC5cbiAgICovXG4gIHR5cGU6ICdmaWxlX3BhdGgnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZpbGVQYXRoQW5ub3RhdGlvbiB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVBhdGgge1xuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgZmlsZSB0aGF0IHdhcyBnZW5lcmF0ZWQuXG4gICAgICovXG4gICAgZmlsZV9pZDogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogQSBVUkwgZm9yIHRoZSBmaWxlIHRoYXQncyBnZW5lcmF0ZWQgd2hlbiB0aGUgYXNzaXN0YW50IHVzZWQgdGhlXG4gKiBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCB0byBnZW5lcmF0ZSBhIGZpbGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVBhdGhEZWx0YUFubm90YXRpb24ge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBhbm5vdGF0aW9uIGluIHRoZSB0ZXh0IGNvbnRlbnQgcGFydC5cbiAgICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgZmlsZV9wYXRoYC5cbiAgICovXG4gIHR5cGU6ICdmaWxlX3BhdGgnO1xuXG4gIGVuZF9pbmRleD86IG51bWJlcjtcblxuICBmaWxlX3BhdGg/OiBGaWxlUGF0aERlbHRhQW5ub3RhdGlvbi5GaWxlUGF0aDtcblxuICBzdGFydF9pbmRleD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHRleHQgaW4gdGhlIG1lc3NhZ2UgY29udGVudCB0aGF0IG5lZWRzIHRvIGJlIHJlcGxhY2VkLlxuICAgKi9cbiAgdGV4dD86IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaWxlUGF0aERlbHRhQW5ub3RhdGlvbiB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVBhdGgge1xuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgZmlsZSB0aGF0IHdhcyBnZW5lcmF0ZWQuXG4gICAgICovXG4gICAgZmlsZV9pZD86IHN0cmluZztcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlRmlsZSB7XG4gIC8qKlxuICAgKiBUaGUgW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEIG9mIHRoZSBpbWFnZVxuICAgKiBpbiB0aGUgbWVzc2FnZSBjb250ZW50LiBTZXQgYHB1cnBvc2U9XCJ2aXNpb25cImAgd2hlbiB1cGxvYWRpbmcgdGhlIEZpbGUgaWYgeW91XG4gICAqIG5lZWQgdG8gbGF0ZXIgZGlzcGxheSB0aGUgZmlsZSBjb250ZW50LlxuICAgKi9cbiAgZmlsZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGRldGFpbCBsZXZlbCBvZiB0aGUgaW1hZ2UgaWYgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyLiBgbG93YCB1c2VzXG4gICAqIGZld2VyIHRva2VucywgeW91IGNhbiBvcHQgaW4gdG8gaGlnaCByZXNvbHV0aW9uIHVzaW5nIGBoaWdoYC5cbiAgICovXG4gIGRldGFpbD86ICdhdXRvJyB8ICdsb3cnIHwgJ2hpZ2gnO1xufVxuXG4vKipcbiAqIFJlZmVyZW5jZXMgYW4gaW1hZ2UgW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpXG4gKiBpbiB0aGUgY29udGVudCBvZiBhIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VGaWxlQ29udGVudEJsb2NrIHtcbiAgaW1hZ2VfZmlsZTogSW1hZ2VGaWxlO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYGltYWdlX2ZpbGVgLlxuICAgKi9cbiAgdHlwZTogJ2ltYWdlX2ZpbGUnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlRmlsZURlbHRhIHtcbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZGV0YWlsIGxldmVsIG9mIHRoZSBpbWFnZSBpZiBzcGVjaWZpZWQgYnkgdGhlIHVzZXIuIGBsb3dgIHVzZXNcbiAgICogZmV3ZXIgdG9rZW5zLCB5b3UgY2FuIG9wdCBpbiB0byBoaWdoIHJlc29sdXRpb24gdXNpbmcgYGhpZ2hgLlxuICAgKi9cbiAgZGV0YWlsPzogJ2F1dG8nIHwgJ2xvdycgfCAnaGlnaCc7XG5cbiAgLyoqXG4gICAqIFRoZSBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSUQgb2YgdGhlIGltYWdlXG4gICAqIGluIHRoZSBtZXNzYWdlIGNvbnRlbnQuIFNldCBgcHVycG9zZT1cInZpc2lvblwiYCB3aGVuIHVwbG9hZGluZyB0aGUgRmlsZSBpZiB5b3VcbiAgICogbmVlZCB0byBsYXRlciBkaXNwbGF5IHRoZSBmaWxlIGNvbnRlbnQuXG4gICAqL1xuICBmaWxlX2lkPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlZmVyZW5jZXMgYW4gaW1hZ2UgW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpXG4gKiBpbiB0aGUgY29udGVudCBvZiBhIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VGaWxlRGVsdGFCbG9jayB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCBpbiB0aGUgbWVzc2FnZS5cbiAgICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgaW1hZ2VfZmlsZWAuXG4gICAqL1xuICB0eXBlOiAnaW1hZ2VfZmlsZSc7XG5cbiAgaW1hZ2VfZmlsZT86IEltYWdlRmlsZURlbHRhO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlVVJMIHtcbiAgLyoqXG4gICAqIFRoZSBleHRlcm5hbCBVUkwgb2YgdGhlIGltYWdlLCBtdXN0IGJlIGEgc3VwcG9ydGVkIGltYWdlIHR5cGVzOiBqcGVnLCBqcGcsIHBuZyxcbiAgICogZ2lmLCB3ZWJwLlxuICAgKi9cbiAgdXJsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZGV0YWlsIGxldmVsIG9mIHRoZSBpbWFnZS4gYGxvd2AgdXNlcyBmZXdlciB0b2tlbnMsIHlvdSBjYW4gb3B0IGluXG4gICAqIHRvIGhpZ2ggcmVzb2x1dGlvbiB1c2luZyBgaGlnaGAuIERlZmF1bHQgdmFsdWUgaXMgYGF1dG9gXG4gICAqL1xuICBkZXRhaWw/OiAnYXV0bycgfCAnbG93JyB8ICdoaWdoJztcbn1cblxuLyoqXG4gKiBSZWZlcmVuY2VzIGFuIGltYWdlIFVSTCBpbiB0aGUgY29udGVudCBvZiBhIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VVUkxDb250ZW50QmxvY2sge1xuICBpbWFnZV91cmw6IEltYWdlVVJMO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgY29udGVudCBwYXJ0LlxuICAgKi9cbiAgdHlwZTogJ2ltYWdlX3VybCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VVUkxEZWx0YSB7XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGRldGFpbCBsZXZlbCBvZiB0aGUgaW1hZ2UuIGBsb3dgIHVzZXMgZmV3ZXIgdG9rZW5zLCB5b3UgY2FuIG9wdCBpblxuICAgKiB0byBoaWdoIHJlc29sdXRpb24gdXNpbmcgYGhpZ2hgLlxuICAgKi9cbiAgZGV0YWlsPzogJ2F1dG8nIHwgJ2xvdycgfCAnaGlnaCc7XG5cbiAgLyoqXG4gICAqIFRoZSBVUkwgb2YgdGhlIGltYWdlLCBtdXN0IGJlIGEgc3VwcG9ydGVkIGltYWdlIHR5cGVzOiBqcGVnLCBqcGcsIHBuZywgZ2lmLFxuICAgKiB3ZWJwLlxuICAgKi9cbiAgdXJsPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlZmVyZW5jZXMgYW4gaW1hZ2UgVVJMIGluIHRoZSBjb250ZW50IG9mIGEgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbWFnZVVSTERlbHRhQmxvY2sge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgaW4gdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYGltYWdlX3VybGAuXG4gICAqL1xuICB0eXBlOiAnaW1hZ2VfdXJsJztcblxuICBpbWFnZV91cmw/OiBJbWFnZVVSTERlbHRhO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIHdpdGhpbiBhXG4gKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2Uge1xuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJZiBhcHBsaWNhYmxlLCB0aGUgSUQgb2YgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdGhhdFxuICAgKiBhdXRob3JlZCB0aGlzIG1lc3NhZ2UuXG4gICAqL1xuICBhc3Npc3RhbnRfaWQ6IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byB0aGUgbWVzc2FnZSwgYW5kIHRoZSB0b29scyB0aGV5IHdlcmUgYWRkZWQgdG8uXG4gICAqL1xuICBhdHRhY2htZW50czogQXJyYXk8TWVzc2FnZS5BdHRhY2htZW50PiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIG1lc3NhZ2Ugd2FzIGNvbXBsZXRlZC5cbiAgICovXG4gIGNvbXBsZXRlZF9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIG1lc3NhZ2UgaW4gYXJyYXkgb2YgdGV4dCBhbmQvb3IgaW1hZ2VzLlxuICAgKi9cbiAgY29udGVudDogQXJyYXk8TWVzc2FnZUNvbnRlbnQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBtZXNzYWdlIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBtZXNzYWdlIHdhcyBtYXJrZWQgYXMgaW5jb21wbGV0ZS5cbiAgICovXG4gIGluY29tcGxldGVfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE9uIGFuIGluY29tcGxldGUgbWVzc2FnZSwgZGV0YWlscyBhYm91dCB3aHkgdGhlIG1lc3NhZ2UgaXMgaW5jb21wbGV0ZS5cbiAgICovXG4gIGluY29tcGxldGVfZGV0YWlsczogTWVzc2FnZS5JbmNvbXBsZXRlRGV0YWlscyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhOiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYHRocmVhZC5tZXNzYWdlYC5cbiAgICovXG4gIG9iamVjdDogJ3RocmVhZC5tZXNzYWdlJztcblxuICAvKipcbiAgICogVGhlIGVudGl0eSB0aGF0IHByb2R1Y2VkIHRoZSBtZXNzYWdlLiBPbmUgb2YgYHVzZXJgIG9yIGBhc3Npc3RhbnRgLlxuICAgKi9cbiAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zKVxuICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIGNyZWF0aW9uIG9mIHRoaXMgbWVzc2FnZS4gVmFsdWUgaXMgYG51bGxgIHdoZW4gbWVzc2FnZXMgYXJlXG4gICAqIGNyZWF0ZWQgbWFudWFsbHkgdXNpbmcgdGhlIGNyZWF0ZSBtZXNzYWdlIG9yIGNyZWF0ZSB0aHJlYWQgZW5kcG9pbnRzLlxuICAgKi9cbiAgcnVuX2lkOiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhdHVzIG9mIHRoZSBtZXNzYWdlLCB3aGljaCBjYW4gYmUgZWl0aGVyIGBpbl9wcm9ncmVzc2AsIGBpbmNvbXBsZXRlYCwgb3JcbiAgICogYGNvbXBsZXRlZGAuXG4gICAqL1xuICBzdGF0dXM6ICdpbl9wcm9ncmVzcycgfCAnaW5jb21wbGV0ZScgfCAnY29tcGxldGVkJztcblxuICAvKipcbiAgICogVGhlIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykgSUQgdGhhdFxuICAgKiB0aGlzIG1lc3NhZ2UgYmVsb25ncyB0by5cbiAgICovXG4gIHRocmVhZF9pZDogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIE1lc3NhZ2Uge1xuICBleHBvcnQgaW50ZXJmYWNlIEF0dGFjaG1lbnQge1xuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBhdHRhY2ggdG8gdGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgZmlsZV9pZD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b29scyB0byBhZGQgdGhpcyBmaWxlIHRvLlxuICAgICAqL1xuICAgIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXR0YWNobWVudC5Bc3Npc3RhbnRUb29sc0ZpbGVTZWFyY2hUeXBlT25seT47XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIEF0dGFjaG1lbnQge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQXNzaXN0YW50VG9vbHNGaWxlU2VhcmNoVHlwZU9ubHkge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdHlwZSBvZiB0b29sIGJlaW5nIGRlZmluZWQ6IGBmaWxlX3NlYXJjaGBcbiAgICAgICAqL1xuICAgICAgdHlwZTogJ2ZpbGVfc2VhcmNoJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT24gYW4gaW5jb21wbGV0ZSBtZXNzYWdlLCBkZXRhaWxzIGFib3V0IHdoeSB0aGUgbWVzc2FnZSBpcyBpbmNvbXBsZXRlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBJbmNvbXBsZXRlRGV0YWlscyB7XG4gICAgLyoqXG4gICAgICogVGhlIHJlYXNvbiB0aGUgbWVzc2FnZSBpcyBpbmNvbXBsZXRlLlxuICAgICAqL1xuICAgIHJlYXNvbjogJ2NvbnRlbnRfZmlsdGVyJyB8ICdtYXhfdG9rZW5zJyB8ICdydW5fY2FuY2VsbGVkJyB8ICdydW5fZXhwaXJlZCcgfCAncnVuX2ZhaWxlZCc7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWZlcmVuY2VzIGFuIGltYWdlIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKVxuICogaW4gdGhlIGNvbnRlbnQgb2YgYSBtZXNzYWdlLlxuICovXG5leHBvcnQgdHlwZSBNZXNzYWdlQ29udGVudCA9XG4gIHwgSW1hZ2VGaWxlQ29udGVudEJsb2NrXG4gIHwgSW1hZ2VVUkxDb250ZW50QmxvY2tcbiAgfCBUZXh0Q29udGVudEJsb2NrXG4gIHwgUmVmdXNhbENvbnRlbnRCbG9jaztcblxuLyoqXG4gKiBSZWZlcmVuY2VzIGFuIGltYWdlIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKVxuICogaW4gdGhlIGNvbnRlbnQgb2YgYSBtZXNzYWdlLlxuICovXG5leHBvcnQgdHlwZSBNZXNzYWdlQ29udGVudERlbHRhID1cbiAgfCBJbWFnZUZpbGVEZWx0YUJsb2NrXG4gIHwgVGV4dERlbHRhQmxvY2tcbiAgfCBSZWZ1c2FsRGVsdGFCbG9ja1xuICB8IEltYWdlVVJMRGVsdGFCbG9jaztcblxuLyoqXG4gKiBSZWZlcmVuY2VzIGFuIGltYWdlIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKVxuICogaW4gdGhlIGNvbnRlbnQgb2YgYSBtZXNzYWdlLlxuICovXG5leHBvcnQgdHlwZSBNZXNzYWdlQ29udGVudFBhcnRQYXJhbSA9IEltYWdlRmlsZUNvbnRlbnRCbG9jayB8IEltYWdlVVJMQ29udGVudEJsb2NrIHwgVGV4dENvbnRlbnRCbG9ja1BhcmFtO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VEZWxldGVkIHtcbiAgaWQ6IHN0cmluZztcblxuICBkZWxldGVkOiBib29sZWFuO1xuXG4gIG9iamVjdDogJ3RocmVhZC5tZXNzYWdlLmRlbGV0ZWQnO1xufVxuXG4vKipcbiAqIFRoZSBkZWx0YSBjb250YWluaW5nIHRoZSBmaWVsZHMgdGhhdCBoYXZlIGNoYW5nZWQgb24gdGhlIE1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZURlbHRhIHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBtZXNzYWdlIGluIGFycmF5IG9mIHRleHQgYW5kL29yIGltYWdlcy5cbiAgICovXG4gIGNvbnRlbnQ/OiBBcnJheTxNZXNzYWdlQ29udGVudERlbHRhPjtcblxuICAvKipcbiAgICogVGhlIGVudGl0eSB0aGF0IHByb2R1Y2VkIHRoZSBtZXNzYWdlLiBPbmUgb2YgYHVzZXJgIG9yIGBhc3Npc3RhbnRgLlxuICAgKi9cbiAgcm9sZT86ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIGRlbHRhIGkuZS4gYW55IGNoYW5nZWQgZmllbGRzIG9uIGEgbWVzc2FnZSBkdXJpbmdcbiAqIHN0cmVhbWluZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlRGVsdGFFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgbWVzc2FnZSwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWx0YSBjb250YWluaW5nIHRoZSBmaWVsZHMgdGhhdCBoYXZlIGNoYW5nZWQgb24gdGhlIE1lc3NhZ2UuXG4gICAqL1xuICBkZWx0YTogTWVzc2FnZURlbHRhO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgdGhyZWFkLm1lc3NhZ2UuZGVsdGFgLlxuICAgKi9cbiAgb2JqZWN0OiAndGhyZWFkLm1lc3NhZ2UuZGVsdGEnO1xufVxuXG4vKipcbiAqIFRoZSByZWZ1c2FsIGNvbnRlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBhc3Npc3RhbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVmdXNhbENvbnRlbnRCbG9jayB7XG4gIHJlZnVzYWw6IHN0cmluZztcblxuICAvKipcbiAgICogQWx3YXlzIGByZWZ1c2FsYC5cbiAgICovXG4gIHR5cGU6ICdyZWZ1c2FsJztcbn1cblxuLyoqXG4gKiBUaGUgcmVmdXNhbCBjb250ZW50IHRoYXQgaXMgcGFydCBvZiBhIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVmdXNhbERlbHRhQmxvY2sge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSByZWZ1c2FsIHBhcnQgaW4gdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYHJlZnVzYWxgLlxuICAgKi9cbiAgdHlwZTogJ3JlZnVzYWwnO1xuXG4gIHJlZnVzYWw/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dCB7XG4gIGFubm90YXRpb25zOiBBcnJheTxBbm5vdGF0aW9uPjtcblxuICAvKipcbiAgICogVGhlIGRhdGEgdGhhdCBtYWtlcyB1cCB0aGUgdGV4dC5cbiAgICovXG4gIHZhbHVlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhlIHRleHQgY29udGVudCB0aGF0IGlzIHBhcnQgb2YgYSBtZXNzYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRleHRDb250ZW50QmxvY2sge1xuICB0ZXh0OiBUZXh0O1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYHRleHRgLlxuICAgKi9cbiAgdHlwZTogJ3RleHQnO1xufVxuXG4vKipcbiAqIFRoZSB0ZXh0IGNvbnRlbnQgdGhhdCBpcyBwYXJ0IG9mIGEgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZXh0Q29udGVudEJsb2NrUGFyYW0ge1xuICAvKipcbiAgICogVGV4dCBjb250ZW50IHRvIGJlIHNlbnQgdG8gdGhlIG1vZGVsXG4gICAqL1xuICB0ZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgdGV4dGAuXG4gICAqL1xuICB0eXBlOiAndGV4dCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dERlbHRhIHtcbiAgYW5ub3RhdGlvbnM/OiBBcnJheTxBbm5vdGF0aW9uRGVsdGE+O1xuXG4gIC8qKlxuICAgKiBUaGUgZGF0YSB0aGF0IG1ha2VzIHVwIHRoZSB0ZXh0LlxuICAgKi9cbiAgdmFsdWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhlIHRleHQgY29udGVudCB0aGF0IGlzIHBhcnQgb2YgYSBtZXNzYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRleHREZWx0YUJsb2NrIHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGluIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogQWx3YXlzIGB0ZXh0YC5cbiAgICovXG4gIHR5cGU6ICd0ZXh0JztcblxuICB0ZXh0PzogVGV4dERlbHRhO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIHRleHQgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxNZXNzYWdlQ29udGVudFBhcnRQYXJhbT47XG5cbiAgLyoqXG4gICAqIFRoZSByb2xlIG9mIHRoZSBlbnRpdHkgdGhhdCBpcyBjcmVhdGluZyB0aGUgbWVzc2FnZS4gQWxsb3dlZCB2YWx1ZXMgaW5jbHVkZTpcbiAgICpcbiAgICogLSBgdXNlcmA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBzZW50IGJ5IGFuIGFjdHVhbCB1c2VyIGFuZCBzaG91bGQgYmUgdXNlZCBpblxuICAgKiAgIG1vc3QgY2FzZXMgdG8gcmVwcmVzZW50IHVzZXItZ2VuZXJhdGVkIG1lc3NhZ2VzLlxuICAgKiAtIGBhc3Npc3RhbnRgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBhc3Npc3RhbnQuIFVzZSB0aGlzXG4gICAqICAgdmFsdWUgdG8gaW5zZXJ0IG1lc3NhZ2VzIGZyb20gdGhlIGFzc2lzdGFudCBpbnRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAqL1xuICByb2xlOiAndXNlcicgfCAnYXNzaXN0YW50JztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIHRoZSBtZXNzYWdlLCBhbmQgdGhlIHRvb2xzIHRoZXkgc2hvdWxkIGJlIGFkZGVkIHRvLlxuICAgKi9cbiAgYXR0YWNobWVudHM/OiBBcnJheTxNZXNzYWdlQ3JlYXRlUGFyYW1zLkF0dGFjaG1lbnQ+IHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBNZXNzYWdlQ3JlYXRlUGFyYW1zIHtcbiAgZXhwb3J0IGludGVyZmFjZSBBdHRhY2htZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gYXR0YWNoIHRvIHRoZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG9vbHMgdG8gYWRkIHRoaXMgZmlsZSB0by5cbiAgICAgKi9cbiAgICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEF0dGFjaG1lbnQuRmlsZVNlYXJjaD47XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIEF0dGFjaG1lbnQge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0eXBlIG9mIHRvb2wgYmVpbmcgZGVmaW5lZDogYGZpbGVfc2VhcmNoYFxuICAgICAgICovXG4gICAgICB0eXBlOiAnZmlsZV9zZWFyY2gnO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VVcGRhdGVQYXJhbXMge1xuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlTGlzdFBhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge1xuICAvKipcbiAgICogQSBjdXJzb3IgZm9yIHVzZSBpbiBwYWdpbmF0aW9uLiBgYmVmb3JlYCBpcyBhbiBvYmplY3QgSUQgdGhhdCBkZWZpbmVzIHlvdXIgcGxhY2VcbiAgICogaW4gdGhlIGxpc3QuIEZvciBpbnN0YW5jZSwgaWYgeW91IG1ha2UgYSBsaXN0IHJlcXVlc3QgYW5kIHJlY2VpdmUgMTAwIG9iamVjdHMsXG4gICAqIHN0YXJ0aW5nIHdpdGggb2JqX2ZvbywgeW91ciBzdWJzZXF1ZW50IGNhbGwgY2FuIGluY2x1ZGUgYmVmb3JlPW9ial9mb28gaW4gb3JkZXJcbiAgICogdG8gZmV0Y2ggdGhlIHByZXZpb3VzIHBhZ2Ugb2YgdGhlIGxpc3QuXG4gICAqL1xuICBiZWZvcmU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNvcnQgb3JkZXIgYnkgdGhlIGBjcmVhdGVkX2F0YCB0aW1lc3RhbXAgb2YgdGhlIG9iamVjdHMuIGBhc2NgIGZvciBhc2NlbmRpbmdcbiAgICogb3JkZXIgYW5kIGBkZXNjYCBmb3IgZGVzY2VuZGluZyBvcmRlci5cbiAgICovXG4gIG9yZGVyPzogJ2FzYycgfCAnZGVzYyc7XG5cbiAgLyoqXG4gICAqIEZpbHRlciBtZXNzYWdlcyBieSB0aGUgcnVuIElEIHRoYXQgZ2VuZXJhdGVkIHRoZW0uXG4gICAqL1xuICBydW5faWQ/OiBzdHJpbmc7XG59XG5cbk1lc3NhZ2VzLk1lc3NhZ2VzUGFnZSA9IE1lc3NhZ2VzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIE1lc3NhZ2VzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIEFubm90YXRpb24gYXMgQW5ub3RhdGlvbixcbiAgICB0eXBlIEFubm90YXRpb25EZWx0YSBhcyBBbm5vdGF0aW9uRGVsdGEsXG4gICAgdHlwZSBGaWxlQ2l0YXRpb25Bbm5vdGF0aW9uIGFzIEZpbGVDaXRhdGlvbkFubm90YXRpb24sXG4gICAgdHlwZSBGaWxlQ2l0YXRpb25EZWx0YUFubm90YXRpb24gYXMgRmlsZUNpdGF0aW9uRGVsdGFBbm5vdGF0aW9uLFxuICAgIHR5cGUgRmlsZVBhdGhBbm5vdGF0aW9uIGFzIEZpbGVQYXRoQW5ub3RhdGlvbixcbiAgICB0eXBlIEZpbGVQYXRoRGVsdGFBbm5vdGF0aW9uIGFzIEZpbGVQYXRoRGVsdGFBbm5vdGF0aW9uLFxuICAgIHR5cGUgSW1hZ2VGaWxlIGFzIEltYWdlRmlsZSxcbiAgICB0eXBlIEltYWdlRmlsZUNvbnRlbnRCbG9jayBhcyBJbWFnZUZpbGVDb250ZW50QmxvY2ssXG4gICAgdHlwZSBJbWFnZUZpbGVEZWx0YSBhcyBJbWFnZUZpbGVEZWx0YSxcbiAgICB0eXBlIEltYWdlRmlsZURlbHRhQmxvY2sgYXMgSW1hZ2VGaWxlRGVsdGFCbG9jayxcbiAgICB0eXBlIEltYWdlVVJMIGFzIEltYWdlVVJMLFxuICAgIHR5cGUgSW1hZ2VVUkxDb250ZW50QmxvY2sgYXMgSW1hZ2VVUkxDb250ZW50QmxvY2ssXG4gICAgdHlwZSBJbWFnZVVSTERlbHRhIGFzIEltYWdlVVJMRGVsdGEsXG4gICAgdHlwZSBJbWFnZVVSTERlbHRhQmxvY2sgYXMgSW1hZ2VVUkxEZWx0YUJsb2NrLFxuICAgIHR5cGUgTWVzc2FnZSBhcyBNZXNzYWdlLFxuICAgIHR5cGUgTWVzc2FnZUNvbnRlbnQgYXMgTWVzc2FnZUNvbnRlbnQsXG4gICAgdHlwZSBNZXNzYWdlQ29udGVudERlbHRhIGFzIE1lc3NhZ2VDb250ZW50RGVsdGEsXG4gICAgdHlwZSBNZXNzYWdlQ29udGVudFBhcnRQYXJhbSBhcyBNZXNzYWdlQ29udGVudFBhcnRQYXJhbSxcbiAgICB0eXBlIE1lc3NhZ2VEZWxldGVkIGFzIE1lc3NhZ2VEZWxldGVkLFxuICAgIHR5cGUgTWVzc2FnZURlbHRhIGFzIE1lc3NhZ2VEZWx0YSxcbiAgICB0eXBlIE1lc3NhZ2VEZWx0YUV2ZW50IGFzIE1lc3NhZ2VEZWx0YUV2ZW50LFxuICAgIHR5cGUgUmVmdXNhbENvbnRlbnRCbG9jayBhcyBSZWZ1c2FsQ29udGVudEJsb2NrLFxuICAgIHR5cGUgUmVmdXNhbERlbHRhQmxvY2sgYXMgUmVmdXNhbERlbHRhQmxvY2ssXG4gICAgdHlwZSBUZXh0IGFzIFRleHQsXG4gICAgdHlwZSBUZXh0Q29udGVudEJsb2NrIGFzIFRleHRDb250ZW50QmxvY2ssXG4gICAgdHlwZSBUZXh0Q29udGVudEJsb2NrUGFyYW0gYXMgVGV4dENvbnRlbnRCbG9ja1BhcmFtLFxuICAgIHR5cGUgVGV4dERlbHRhIGFzIFRleHREZWx0YSxcbiAgICB0eXBlIFRleHREZWx0YUJsb2NrIGFzIFRleHREZWx0YUJsb2NrLFxuICAgIE1lc3NhZ2VzUGFnZSBhcyBNZXNzYWdlc1BhZ2UsXG4gICAgdHlwZSBNZXNzYWdlQ3JlYXRlUGFyYW1zIGFzIE1lc3NhZ2VDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBNZXNzYWdlVXBkYXRlUGFyYW1zIGFzIE1lc3NhZ2VVcGRhdGVQYXJhbXMsXG4gICAgdHlwZSBNZXNzYWdlTGlzdFBhcmFtcyBhcyBNZXNzYWdlTGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBTdGVwc0FQSSBmcm9tICcuL3N0ZXBzJztcbmltcG9ydCB7IEN1cnNvclBhZ2UsIHR5cGUgQ3Vyc29yUGFnZVBhcmFtcyB9IGZyb20gJy4uLy4uLy4uLy4uL3BhZ2luYXRpb24nO1xuXG5leHBvcnQgY2xhc3MgU3RlcHMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBydW4gc3RlcC5cbiAgICovXG4gIHJldHJpZXZlKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBzdGVwSWQ6IHN0cmluZyxcbiAgICBxdWVyeT86IFN0ZXBSZXRyaWV2ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFJ1blN0ZXA+O1xuICByZXRyaWV2ZShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgc3RlcElkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxSdW5TdGVwPjtcbiAgcmV0cmlldmUoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIHN0ZXBJZDogc3RyaW5nLFxuICAgIHF1ZXJ5OiBTdGVwUmV0cmlldmVQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxSdW5TdGVwPiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXRyaWV2ZSh0aHJlYWRJZCwgcnVuSWQsIHN0ZXBJZCwge30sIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH0vc3RlcHMvJHtzdGVwSWR9YCwge1xuICAgICAgcXVlcnksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBydW4gc3RlcHMgYmVsb25naW5nIHRvIGEgcnVuLlxuICAgKi9cbiAgbGlzdChcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgcXVlcnk/OiBTdGVwTGlzdFBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxSdW5TdGVwc1BhZ2UsIFJ1blN0ZXA+O1xuICBsaXN0KFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxSdW5TdGVwc1BhZ2UsIFJ1blN0ZXA+O1xuICBsaXN0KFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBxdWVyeTogU3RlcExpc3RQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8UnVuU3RlcHNQYWdlLCBSdW5TdGVwPiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0KHRocmVhZElkLCBydW5JZCwge30sIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9L3N0ZXBzYCwgUnVuU3RlcHNQYWdlLCB7XG4gICAgICBxdWVyeSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSdW5TdGVwc1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlPFJ1blN0ZXA+IHt9XG5cbi8qKlxuICogVGV4dCBvdXRwdXQgZnJvbSB0aGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwgYXMgcGFydCBvZiBhIHJ1biBzdGVwLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlckxvZ3Mge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaW4gdGhlIG91dHB1dHMgYXJyYXkuXG4gICAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYGxvZ3NgLlxuICAgKi9cbiAgdHlwZTogJ2xvZ3MnO1xuXG4gIC8qKlxuICAgKiBUaGUgdGV4dCBvdXRwdXQgZnJvbSB0aGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwuXG4gICAqL1xuICBsb2dzPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlck91dHB1dEltYWdlIHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGluIHRoZSBvdXRwdXRzIGFycmF5LlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogQWx3YXlzIGBpbWFnZWAuXG4gICAqL1xuICB0eXBlOiAnaW1hZ2UnO1xuXG4gIGltYWdlPzogQ29kZUludGVycHJldGVyT3V0cHV0SW1hZ2UuSW1hZ2U7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29kZUludGVycHJldGVyT3V0cHV0SW1hZ2Uge1xuICBleHBvcnQgaW50ZXJmYWNlIEltYWdlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEIG9mIHRoZVxuICAgICAqIGltYWdlLlxuICAgICAqL1xuICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRhaWxzIG9mIHRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbCB0aGUgcnVuIHN0ZXAgd2FzIGludm9sdmVkIGluLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlclRvb2xDYWxsIHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsIGRlZmluaXRpb24uXG4gICAqL1xuICBjb2RlX2ludGVycHJldGVyOiBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbC5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRvb2wgY2FsbC4gVGhpcyBpcyBhbHdheXMgZ29pbmcgdG8gYmUgYGNvZGVfaW50ZXJwcmV0ZXJgIGZvciB0aGlzXG4gICAqIHR5cGUgb2YgdG9vbCBjYWxsLlxuICAgKi9cbiAgdHlwZTogJ2NvZGVfaW50ZXJwcmV0ZXInO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENvZGVJbnRlcnByZXRlclRvb2xDYWxsIHtcbiAgLyoqXG4gICAqIFRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbCBkZWZpbml0aW9uLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnB1dCB0byB0aGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwuXG4gICAgICovXG4gICAgaW5wdXQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBvdXRwdXRzIGZyb20gdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsLiBDb2RlIEludGVycHJldGVyIGNhbiBvdXRwdXQgb25lXG4gICAgICogb3IgbW9yZSBpdGVtcywgaW5jbHVkaW5nIHRleHQgKGBsb2dzYCkgb3IgaW1hZ2VzIChgaW1hZ2VgKS4gRWFjaCBvZiB0aGVzZSBhcmVcbiAgICAgKiByZXByZXNlbnRlZCBieSBhIGRpZmZlcmVudCBvYmplY3QgdHlwZS5cbiAgICAgKi9cbiAgICBvdXRwdXRzOiBBcnJheTxDb2RlSW50ZXJwcmV0ZXIuTG9ncyB8IENvZGVJbnRlcnByZXRlci5JbWFnZT47XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgLyoqXG4gICAgICogVGV4dCBvdXRwdXQgZnJvbSB0aGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwgYXMgcGFydCBvZiBhIHJ1biBzdGVwLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgTG9ncyB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0ZXh0IG91dHB1dCBmcm9tIHRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbC5cbiAgICAgICAqL1xuICAgICAgbG9nczogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIEFsd2F5cyBgbG9nc2AuXG4gICAgICAgKi9cbiAgICAgIHR5cGU6ICdsb2dzJztcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIEltYWdlIHtcbiAgICAgIGltYWdlOiBJbWFnZS5JbWFnZTtcblxuICAgICAgLyoqXG4gICAgICAgKiBBbHdheXMgYGltYWdlYC5cbiAgICAgICAqL1xuICAgICAgdHlwZTogJ2ltYWdlJztcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIEltYWdlIHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgSW1hZ2Uge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRCBvZiB0aGVcbiAgICAgICAgICogaW1hZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBmaWxlX2lkOiBzdHJpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGV0YWlscyBvZiB0aGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwgdGhlIHJ1biBzdGVwIHdhcyBpbnZvbHZlZCBpbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbERlbHRhIHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgdG9vbCBjYWxsIGluIHRoZSB0b29sIGNhbGxzIGFycmF5LlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdG9vbCBjYWxsLiBUaGlzIGlzIGFsd2F5cyBnb2luZyB0byBiZSBgY29kZV9pbnRlcnByZXRlcmAgZm9yIHRoaXNcbiAgICogdHlwZSBvZiB0b29sIGNhbGwuXG4gICAqL1xuICB0eXBlOiAnY29kZV9pbnRlcnByZXRlcic7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsLlxuICAgKi9cbiAgaWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbCBkZWZpbml0aW9uLlxuICAgKi9cbiAgY29kZV9pbnRlcnByZXRlcj86IENvZGVJbnRlcnByZXRlclRvb2xDYWxsRGVsdGEuQ29kZUludGVycHJldGVyO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENvZGVJbnRlcnByZXRlclRvb2xDYWxsRGVsdGEge1xuICAvKipcbiAgICogVGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsIGRlZmluaXRpb24uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgLyoqXG4gICAgICogVGhlIGlucHV0IHRvIHRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbC5cbiAgICAgKi9cbiAgICBpbnB1dD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBvdXRwdXRzIGZyb20gdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsLiBDb2RlIEludGVycHJldGVyIGNhbiBvdXRwdXQgb25lXG4gICAgICogb3IgbW9yZSBpdGVtcywgaW5jbHVkaW5nIHRleHQgKGBsb2dzYCkgb3IgaW1hZ2VzIChgaW1hZ2VgKS4gRWFjaCBvZiB0aGVzZSBhcmVcbiAgICAgKiByZXByZXNlbnRlZCBieSBhIGRpZmZlcmVudCBvYmplY3QgdHlwZS5cbiAgICAgKi9cbiAgICBvdXRwdXRzPzogQXJyYXk8U3RlcHNBUEkuQ29kZUludGVycHJldGVyTG9ncyB8IFN0ZXBzQVBJLkNvZGVJbnRlcnByZXRlck91dHB1dEltYWdlPjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2hUb29sQ2FsbCB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbCBvYmplY3QuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGb3Igbm93LCB0aGlzIGlzIGFsd2F5cyBnb2luZyB0byBiZSBhbiBlbXB0eSBvYmplY3QuXG4gICAqL1xuICBmaWxlX3NlYXJjaDogRmlsZVNlYXJjaFRvb2xDYWxsLkZpbGVTZWFyY2g7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRvb2wgY2FsbC4gVGhpcyBpcyBhbHdheXMgZ29pbmcgdG8gYmUgYGZpbGVfc2VhcmNoYCBmb3IgdGhpcyB0eXBlIG9mXG4gICAqIHRvb2wgY2FsbC5cbiAgICovXG4gIHR5cGU6ICdmaWxlX3NlYXJjaCc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRmlsZVNlYXJjaFRvb2xDYWxsIHtcbiAgLyoqXG4gICAqIEZvciBub3csIHRoaXMgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIGFuIGVtcHR5IG9iamVjdC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgLyoqXG4gICAgICogVGhlIHJhbmtpbmcgb3B0aW9ucyBmb3IgdGhlIGZpbGUgc2VhcmNoLlxuICAgICAqL1xuICAgIHJhbmtpbmdfb3B0aW9ucz86IEZpbGVTZWFyY2guUmFua2luZ09wdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdWx0cyBvZiB0aGUgZmlsZSBzZWFyY2guXG4gICAgICovXG4gICAgcmVzdWx0cz86IEFycmF5PEZpbGVTZWFyY2guUmVzdWx0PjtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgRmlsZVNlYXJjaCB7XG4gICAgLyoqXG4gICAgICogVGhlIHJhbmtpbmcgb3B0aW9ucyBmb3IgdGhlIGZpbGUgc2VhcmNoLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgUmFua2luZ09wdGlvbnMge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcmFua2VyIHVzZWQgZm9yIHRoZSBmaWxlIHNlYXJjaC5cbiAgICAgICAqL1xuICAgICAgcmFua2VyOiAnZGVmYXVsdF8yMDI0XzA4XzIxJztcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgc2NvcmUgdGhyZXNob2xkIGZvciB0aGUgZmlsZSBzZWFyY2guIEFsbCB2YWx1ZXMgbXVzdCBiZSBhIGZsb2F0aW5nIHBvaW50XG4gICAgICAgKiBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAgICovXG4gICAgICBzY29yZV90aHJlc2hvbGQ6IG51bWJlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHJlc3VsdCBpbnN0YW5jZSBvZiB0aGUgZmlsZSBzZWFyY2guXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBSZXN1bHQge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdGhhdCByZXN1bHQgd2FzIGZvdW5kIGluLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkOiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGZpbGUgdGhhdCByZXN1bHQgd2FzIGZvdW5kIGluLlxuICAgICAgICovXG4gICAgICBmaWxlX25hbWU6IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgc2NvcmUgb2YgdGhlIHJlc3VsdC4gQWxsIHZhbHVlcyBtdXN0IGJlIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGJldHdlZW4gMFxuICAgICAgICogYW5kIDEuXG4gICAgICAgKi9cbiAgICAgIHNjb3JlOiBudW1iZXI7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGNvbnRlbnQgb2YgdGhlIHJlc3VsdCB0aGF0IHdhcyBmb3VuZC4gVGhlIGNvbnRlbnQgaXMgb25seSBpbmNsdWRlZCBpZlxuICAgICAgICogcmVxdWVzdGVkIHZpYSB0aGUgaW5jbHVkZSBxdWVyeSBwYXJhbWV0ZXIuXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ/OiBBcnJheTxSZXN1bHQuQ29udGVudD47XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBSZXN1bHQge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBDb250ZW50IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIGZpbGUuXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0Pzogc3RyaW5nO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgY29udGVudC5cbiAgICAgICAgICovXG4gICAgICAgIHR5cGU/OiAndGV4dCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaFRvb2xDYWxsRGVsdGEge1xuICAvKipcbiAgICogRm9yIG5vdywgdGhpcyBpcyBhbHdheXMgZ29pbmcgdG8gYmUgYW4gZW1wdHkgb2JqZWN0LlxuICAgKi9cbiAgZmlsZV9zZWFyY2g6IHVua25vd247XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgdG9vbCBjYWxsIGluIHRoZSB0b29sIGNhbGxzIGFycmF5LlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdG9vbCBjYWxsLiBUaGlzIGlzIGFsd2F5cyBnb2luZyB0byBiZSBgZmlsZV9zZWFyY2hgIGZvciB0aGlzIHR5cGUgb2ZcbiAgICogdG9vbCBjYWxsLlxuICAgKi9cbiAgdHlwZTogJ2ZpbGVfc2VhcmNoJztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwgb2JqZWN0LlxuICAgKi9cbiAgaWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25Ub29sQ2FsbCB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbCBvYmplY3QuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmaW5pdGlvbiBvZiB0aGUgZnVuY3Rpb24gdGhhdCB3YXMgY2FsbGVkLlxuICAgKi9cbiAgZnVuY3Rpb246IEZ1bmN0aW9uVG9vbENhbGwuRnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRvb2wgY2FsbC4gVGhpcyBpcyBhbHdheXMgZ29pbmcgdG8gYmUgYGZ1bmN0aW9uYCBmb3IgdGhpcyB0eXBlIG9mXG4gICAqIHRvb2wgY2FsbC5cbiAgICovXG4gIHR5cGU6ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRnVuY3Rpb25Ub29sQ2FsbCB7XG4gIC8qKlxuICAgKiBUaGUgZGVmaW5pdGlvbiBvZiB0aGUgZnVuY3Rpb24gdGhhdCB3YXMgY2FsbGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGFyZ3VtZW50czogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBvdXRwdXQgb2YgdGhlIGZ1bmN0aW9uLiBUaGlzIHdpbGwgYmUgYG51bGxgIGlmIHRoZSBvdXRwdXRzIGhhdmUgbm90IGJlZW5cbiAgICAgKiBbc3VibWl0dGVkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvc3VibWl0VG9vbE91dHB1dHMpXG4gICAgICogeWV0LlxuICAgICAqL1xuICAgIG91dHB1dDogc3RyaW5nIHwgbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uVG9vbENhbGxEZWx0YSB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIHRvb2wgY2FsbCBpbiB0aGUgdG9vbCBjYWxscyBhcnJheS5cbiAgICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRvb2wgY2FsbC4gVGhpcyBpcyBhbHdheXMgZ29pbmcgdG8gYmUgYGZ1bmN0aW9uYCBmb3IgdGhpcyB0eXBlIG9mXG4gICAqIHRvb2wgY2FsbC5cbiAgICovXG4gIHR5cGU6ICdmdW5jdGlvbic7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsIG9iamVjdC5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmaW5pdGlvbiBvZiB0aGUgZnVuY3Rpb24gdGhhdCB3YXMgY2FsbGVkLlxuICAgKi9cbiAgZnVuY3Rpb24/OiBGdW5jdGlvblRvb2xDYWxsRGVsdGEuRnVuY3Rpb247XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRnVuY3Rpb25Ub29sQ2FsbERlbHRhIHtcbiAgLyoqXG4gICAqIFRoZSBkZWZpbml0aW9uIG9mIHRoZSBmdW5jdGlvbiB0aGF0IHdhcyBjYWxsZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXJndW1lbnRzPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG5hbWU/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0IG9mIHRoZSBmdW5jdGlvbi4gVGhpcyB3aWxsIGJlIGBudWxsYCBpZiB0aGUgb3V0cHV0cyBoYXZlIG5vdCBiZWVuXG4gICAgICogW3N1Ym1pdHRlZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL3N1Ym1pdFRvb2xPdXRwdXRzKVxuICAgICAqIHlldC5cbiAgICAgKi9cbiAgICBvdXRwdXQ/OiBzdHJpbmcgfCBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRGV0YWlscyBvZiB0aGUgbWVzc2FnZSBjcmVhdGlvbiBieSB0aGUgcnVuIHN0ZXAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZUNyZWF0aW9uU3RlcERldGFpbHMge1xuICBtZXNzYWdlX2NyZWF0aW9uOiBNZXNzYWdlQ3JlYXRpb25TdGVwRGV0YWlscy5NZXNzYWdlQ3JlYXRpb247XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgbWVzc2FnZV9jcmVhdGlvbmAuXG4gICAqL1xuICB0eXBlOiAnbWVzc2FnZV9jcmVhdGlvbic7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgTWVzc2FnZUNyZWF0aW9uU3RlcERldGFpbHMge1xuICBleHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VDcmVhdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBtZXNzYWdlIHRoYXQgd2FzIGNyZWF0ZWQgYnkgdGhpcyBydW4gc3RlcC5cbiAgICAgKi9cbiAgICBtZXNzYWdlX2lkOiBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3RlcCBpbiBleGVjdXRpb24gb2YgYSBydW4uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUnVuU3RlcCB7XG4gIC8qKlxuICAgKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgcnVuIHN0ZXAsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cylcbiAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSBydW4gc3RlcC5cbiAgICovXG4gIGFzc2lzdGFudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBydW4gc3RlcCB3YXMgY2FuY2VsbGVkLlxuICAgKi9cbiAgY2FuY2VsbGVkX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBydW4gc3RlcCBjb21wbGV0ZWQuXG4gICAqL1xuICBjb21wbGV0ZWRfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHJ1biBzdGVwIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBydW4gc3RlcCBleHBpcmVkLiBBIHN0ZXAgaXNcbiAgICogY29uc2lkZXJlZCBleHBpcmVkIGlmIHRoZSBwYXJlbnQgcnVuIGlzIGV4cGlyZWQuXG4gICAqL1xuICBleHBpcmVkX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBydW4gc3RlcCBmYWlsZWQuXG4gICAqL1xuICBmYWlsZWRfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBsYXN0IGVycm9yIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJ1biBzdGVwLiBXaWxsIGJlIGBudWxsYCBpZiB0aGVyZSBhcmUgbm9cbiAgICogZXJyb3JzLlxuICAgKi9cbiAgbGFzdF9lcnJvcjogUnVuU3RlcC5MYXN0RXJyb3IgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YTogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGB0aHJlYWQucnVuLnN0ZXBgLlxuICAgKi9cbiAgb2JqZWN0OiAndGhyZWFkLnJ1bi5zdGVwJztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMpIHRoYXRcbiAgICogdGhpcyBydW4gc3RlcCBpcyBhIHBhcnQgb2YuXG4gICAqL1xuICBydW5faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHN0YXR1cyBvZiB0aGUgcnVuIHN0ZXAsIHdoaWNoIGNhbiBiZSBlaXRoZXIgYGluX3Byb2dyZXNzYCwgYGNhbmNlbGxlZGAsXG4gICAqIGBmYWlsZWRgLCBgY29tcGxldGVkYCwgb3IgYGV4cGlyZWRgLlxuICAgKi9cbiAgc3RhdHVzOiAnaW5fcHJvZ3Jlc3MnIHwgJ2NhbmNlbGxlZCcgfCAnZmFpbGVkJyB8ICdjb21wbGV0ZWQnIHwgJ2V4cGlyZWQnO1xuXG4gIC8qKlxuICAgKiBUaGUgZGV0YWlscyBvZiB0aGUgcnVuIHN0ZXAuXG4gICAqL1xuICBzdGVwX2RldGFpbHM6IE1lc3NhZ2VDcmVhdGlvblN0ZXBEZXRhaWxzIHwgVG9vbENhbGxzU3RlcERldGFpbHM7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKVxuICAgKiB0aGF0IHdhcyBydW4uXG4gICAqL1xuICB0aHJlYWRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgcnVuIHN0ZXAsIHdoaWNoIGNhbiBiZSBlaXRoZXIgYG1lc3NhZ2VfY3JlYXRpb25gIG9yIGB0b29sX2NhbGxzYC5cbiAgICovXG4gIHR5cGU6ICdtZXNzYWdlX2NyZWF0aW9uJyB8ICd0b29sX2NhbGxzJztcblxuICAvKipcbiAgICogVXNhZ2Ugc3RhdGlzdGljcyByZWxhdGVkIHRvIHRoZSBydW4gc3RlcC4gVGhpcyB2YWx1ZSB3aWxsIGJlIGBudWxsYCB3aGlsZSB0aGVcbiAgICogcnVuIHN0ZXAncyBzdGF0dXMgaXMgYGluX3Byb2dyZXNzYC5cbiAgICovXG4gIHVzYWdlOiBSdW5TdGVwLlVzYWdlIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSdW5TdGVwIHtcbiAgLyoqXG4gICAqIFRoZSBsYXN0IGVycm9yIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJ1biBzdGVwLiBXaWxsIGJlIGBudWxsYCBpZiB0aGVyZSBhcmUgbm9cbiAgICogZXJyb3JzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBMYXN0RXJyb3Ige1xuICAgIC8qKlxuICAgICAqIE9uZSBvZiBgc2VydmVyX2Vycm9yYCBvciBgcmF0ZV9saW1pdF9leGNlZWRlZGAuXG4gICAgICovXG4gICAgY29kZTogJ3NlcnZlcl9lcnJvcicgfCAncmF0ZV9saW1pdF9leGNlZWRlZCc7XG5cbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvci5cbiAgICAgKi9cbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogVXNhZ2Ugc3RhdGlzdGljcyByZWxhdGVkIHRvIHRoZSBydW4gc3RlcC4gVGhpcyB2YWx1ZSB3aWxsIGJlIGBudWxsYCB3aGlsZSB0aGVcbiAgICogcnVuIHN0ZXAncyBzdGF0dXMgaXMgYGluX3Byb2dyZXNzYC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVXNhZ2Uge1xuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBjb21wbGV0aW9uIHRva2VucyB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgcnVuIHN0ZXAuXG4gICAgICovXG4gICAgY29tcGxldGlvbl90b2tlbnM6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBwcm9tcHQgdG9rZW5zIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBydW4gc3RlcC5cbiAgICAgKi9cbiAgICBwcm9tcHRfdG9rZW5zOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUb3RhbCBudW1iZXIgb2YgdG9rZW5zIHVzZWQgKHByb21wdCArIGNvbXBsZXRpb24pLlxuICAgICAqL1xuICAgIHRvdGFsX3Rva2VuczogbnVtYmVyO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGRlbHRhIGNvbnRhaW5pbmcgdGhlIGZpZWxkcyB0aGF0IGhhdmUgY2hhbmdlZCBvbiB0aGUgcnVuIHN0ZXAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUnVuU3RlcERlbHRhIHtcbiAgLyoqXG4gICAqIFRoZSBkZXRhaWxzIG9mIHRoZSBydW4gc3RlcC5cbiAgICovXG4gIHN0ZXBfZGV0YWlscz86IFJ1blN0ZXBEZWx0YU1lc3NhZ2VEZWx0YSB8IFRvb2xDYWxsRGVsdGFPYmplY3Q7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHJ1biBzdGVwIGRlbHRhIGkuZS4gYW55IGNoYW5nZWQgZmllbGRzIG9uIGEgcnVuIHN0ZXAgZHVyaW5nXG4gKiBzdHJlYW1pbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUnVuU3RlcERlbHRhRXZlbnQge1xuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIgb2YgdGhlIHJ1biBzdGVwLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGRlbHRhIGNvbnRhaW5pbmcgdGhlIGZpZWxkcyB0aGF0IGhhdmUgY2hhbmdlZCBvbiB0aGUgcnVuIHN0ZXAuXG4gICAqL1xuICBkZWx0YTogUnVuU3RlcERlbHRhO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgdGhyZWFkLnJ1bi5zdGVwLmRlbHRhYC5cbiAgICovXG4gIG9iamVjdDogJ3RocmVhZC5ydW4uc3RlcC5kZWx0YSc7XG59XG5cbi8qKlxuICogRGV0YWlscyBvZiB0aGUgbWVzc2FnZSBjcmVhdGlvbiBieSB0aGUgcnVuIHN0ZXAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUnVuU3RlcERlbHRhTWVzc2FnZURlbHRhIHtcbiAgLyoqXG4gICAqIEFsd2F5cyBgbWVzc2FnZV9jcmVhdGlvbmAuXG4gICAqL1xuICB0eXBlOiAnbWVzc2FnZV9jcmVhdGlvbic7XG5cbiAgbWVzc2FnZV9jcmVhdGlvbj86IFJ1blN0ZXBEZWx0YU1lc3NhZ2VEZWx0YS5NZXNzYWdlQ3JlYXRpb247XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuU3RlcERlbHRhTWVzc2FnZURlbHRhIHtcbiAgZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlQ3JlYXRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgbWVzc2FnZSB0aGF0IHdhcyBjcmVhdGVkIGJ5IHRoaXMgcnVuIHN0ZXAuXG4gICAgICovXG4gICAgbWVzc2FnZV9pZD86IHN0cmluZztcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBSdW5TdGVwSW5jbHVkZSA9ICdzdGVwX2RldGFpbHMudG9vbF9jYWxsc1sqXS5maWxlX3NlYXJjaC5yZXN1bHRzWypdLmNvbnRlbnQnO1xuXG4vKipcbiAqIERldGFpbHMgb2YgdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsIHRoZSBydW4gc3RlcCB3YXMgaW52b2x2ZWQgaW4uXG4gKi9cbmV4cG9ydCB0eXBlIFRvb2xDYWxsID0gQ29kZUludGVycHJldGVyVG9vbENhbGwgfCBGaWxlU2VhcmNoVG9vbENhbGwgfCBGdW5jdGlvblRvb2xDYWxsO1xuXG4vKipcbiAqIERldGFpbHMgb2YgdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsIHRoZSBydW4gc3RlcCB3YXMgaW52b2x2ZWQgaW4uXG4gKi9cbmV4cG9ydCB0eXBlIFRvb2xDYWxsRGVsdGEgPSBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbERlbHRhIHwgRmlsZVNlYXJjaFRvb2xDYWxsRGVsdGEgfCBGdW5jdGlvblRvb2xDYWxsRGVsdGE7XG5cbi8qKlxuICogRGV0YWlscyBvZiB0aGUgdG9vbCBjYWxsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRvb2xDYWxsRGVsdGFPYmplY3Qge1xuICAvKipcbiAgICogQWx3YXlzIGB0b29sX2NhbGxzYC5cbiAgICovXG4gIHR5cGU6ICd0b29sX2NhbGxzJztcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgdG9vbCBjYWxscyB0aGUgcnVuIHN0ZXAgd2FzIGludm9sdmVkIGluLiBUaGVzZSBjYW4gYmUgYXNzb2NpYXRlZFxuICAgKiB3aXRoIG9uZSBvZiB0aHJlZSB0eXBlcyBvZiB0b29sczogYGNvZGVfaW50ZXJwcmV0ZXJgLCBgZmlsZV9zZWFyY2hgLCBvclxuICAgKiBgZnVuY3Rpb25gLlxuICAgKi9cbiAgdG9vbF9jYWxscz86IEFycmF5PFRvb2xDYWxsRGVsdGE+O1xufVxuXG4vKipcbiAqIERldGFpbHMgb2YgdGhlIHRvb2wgY2FsbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUb29sQ2FsbHNTdGVwRGV0YWlscyB7XG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiB0b29sIGNhbGxzIHRoZSBydW4gc3RlcCB3YXMgaW52b2x2ZWQgaW4uIFRoZXNlIGNhbiBiZSBhc3NvY2lhdGVkXG4gICAqIHdpdGggb25lIG9mIHRocmVlIHR5cGVzIG9mIHRvb2xzOiBgY29kZV9pbnRlcnByZXRlcmAsIGBmaWxlX3NlYXJjaGAsIG9yXG4gICAqIGBmdW5jdGlvbmAuXG4gICAqL1xuICB0b29sX2NhbGxzOiBBcnJheTxUb29sQ2FsbD47XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgdG9vbF9jYWxsc2AuXG4gICAqL1xuICB0eXBlOiAndG9vbF9jYWxscyc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RlcFJldHJpZXZlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBhZGRpdGlvbmFsIGZpZWxkcyB0byBpbmNsdWRlIGluIHRoZSByZXNwb25zZS4gQ3VycmVudGx5IHRoZSBvbmx5XG4gICAqIHN1cHBvcnRlZCB2YWx1ZSBpcyBgc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHNbKl0uZmlsZV9zZWFyY2gucmVzdWx0c1sqXS5jb250ZW50YFxuICAgKiB0byBmZXRjaCB0aGUgZmlsZSBzZWFyY2ggcmVzdWx0IGNvbnRlbnQuXG4gICAqXG4gICAqIFNlZSB0aGVcbiAgICogW2ZpbGUgc2VhcmNoIHRvb2wgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy90b29scy9maWxlLXNlYXJjaCNjdXN0b21pemluZy1maWxlLXNlYXJjaC1zZXR0aW5ncylcbiAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbmNsdWRlPzogQXJyYXk8UnVuU3RlcEluY2x1ZGU+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0ZXBMaXN0UGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIGN1cnNvciBmb3IgdXNlIGluIHBhZ2luYXRpb24uIGBiZWZvcmVgIGlzIGFuIG9iamVjdCBJRCB0aGF0IGRlZmluZXMgeW91ciBwbGFjZVxuICAgKiBpbiB0aGUgbGlzdC4gRm9yIGluc3RhbmNlLCBpZiB5b3UgbWFrZSBhIGxpc3QgcmVxdWVzdCBhbmQgcmVjZWl2ZSAxMDAgb2JqZWN0cyxcbiAgICogc3RhcnRpbmcgd2l0aCBvYmpfZm9vLCB5b3VyIHN1YnNlcXVlbnQgY2FsbCBjYW4gaW5jbHVkZSBiZWZvcmU9b2JqX2ZvbyBpbiBvcmRlclxuICAgKiB0byBmZXRjaCB0aGUgcHJldmlvdXMgcGFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGJlZm9yZT86IHN0cmluZztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGFkZGl0aW9uYWwgZmllbGRzIHRvIGluY2x1ZGUgaW4gdGhlIHJlc3BvbnNlLiBDdXJyZW50bHkgdGhlIG9ubHlcbiAgICogc3VwcG9ydGVkIHZhbHVlIGlzIGBzdGVwX2RldGFpbHMudG9vbF9jYWxsc1sqXS5maWxlX3NlYXJjaC5yZXN1bHRzWypdLmNvbnRlbnRgXG4gICAqIHRvIGZldGNoIHRoZSBmaWxlIHNlYXJjaCByZXN1bHQgY29udGVudC5cbiAgICpcbiAgICogU2VlIHRoZVxuICAgKiBbZmlsZSBzZWFyY2ggdG9vbCBkb2N1bWVudGF0aW9uXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL3Rvb2xzL2ZpbGUtc2VhcmNoI2N1c3RvbWl6aW5nLWZpbGUtc2VhcmNoLXNldHRpbmdzKVxuICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGluY2x1ZGU/OiBBcnJheTxSdW5TdGVwSW5jbHVkZT47XG5cbiAgLyoqXG4gICAqIFNvcnQgb3JkZXIgYnkgdGhlIGBjcmVhdGVkX2F0YCB0aW1lc3RhbXAgb2YgdGhlIG9iamVjdHMuIGBhc2NgIGZvciBhc2NlbmRpbmdcbiAgICogb3JkZXIgYW5kIGBkZXNjYCBmb3IgZGVzY2VuZGluZyBvcmRlci5cbiAgICovXG4gIG9yZGVyPzogJ2FzYycgfCAnZGVzYyc7XG59XG5cblN0ZXBzLlJ1blN0ZXBzUGFnZSA9IFJ1blN0ZXBzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFN0ZXBzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIENvZGVJbnRlcnByZXRlckxvZ3MgYXMgQ29kZUludGVycHJldGVyTG9ncyxcbiAgICB0eXBlIENvZGVJbnRlcnByZXRlck91dHB1dEltYWdlIGFzIENvZGVJbnRlcnByZXRlck91dHB1dEltYWdlLFxuICAgIHR5cGUgQ29kZUludGVycHJldGVyVG9vbENhbGwgYXMgQ29kZUludGVycHJldGVyVG9vbENhbGwsXG4gICAgdHlwZSBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbERlbHRhIGFzIENvZGVJbnRlcnByZXRlclRvb2xDYWxsRGVsdGEsXG4gICAgdHlwZSBGaWxlU2VhcmNoVG9vbENhbGwgYXMgRmlsZVNlYXJjaFRvb2xDYWxsLFxuICAgIHR5cGUgRmlsZVNlYXJjaFRvb2xDYWxsRGVsdGEgYXMgRmlsZVNlYXJjaFRvb2xDYWxsRGVsdGEsXG4gICAgdHlwZSBGdW5jdGlvblRvb2xDYWxsIGFzIEZ1bmN0aW9uVG9vbENhbGwsXG4gICAgdHlwZSBGdW5jdGlvblRvb2xDYWxsRGVsdGEgYXMgRnVuY3Rpb25Ub29sQ2FsbERlbHRhLFxuICAgIHR5cGUgTWVzc2FnZUNyZWF0aW9uU3RlcERldGFpbHMgYXMgTWVzc2FnZUNyZWF0aW9uU3RlcERldGFpbHMsXG4gICAgdHlwZSBSdW5TdGVwIGFzIFJ1blN0ZXAsXG4gICAgdHlwZSBSdW5TdGVwRGVsdGEgYXMgUnVuU3RlcERlbHRhLFxuICAgIHR5cGUgUnVuU3RlcERlbHRhRXZlbnQgYXMgUnVuU3RlcERlbHRhRXZlbnQsXG4gICAgdHlwZSBSdW5TdGVwRGVsdGFNZXNzYWdlRGVsdGEgYXMgUnVuU3RlcERlbHRhTWVzc2FnZURlbHRhLFxuICAgIHR5cGUgUnVuU3RlcEluY2x1ZGUgYXMgUnVuU3RlcEluY2x1ZGUsXG4gICAgdHlwZSBUb29sQ2FsbCBhcyBUb29sQ2FsbCxcbiAgICB0eXBlIFRvb2xDYWxsRGVsdGEgYXMgVG9vbENhbGxEZWx0YSxcbiAgICB0eXBlIFRvb2xDYWxsRGVsdGFPYmplY3QgYXMgVG9vbENhbGxEZWx0YU9iamVjdCxcbiAgICB0eXBlIFRvb2xDYWxsc1N0ZXBEZXRhaWxzIGFzIFRvb2xDYWxsc1N0ZXBEZXRhaWxzLFxuICAgIFJ1blN0ZXBzUGFnZSBhcyBSdW5TdGVwc1BhZ2UsXG4gICAgdHlwZSBTdGVwUmV0cmlldmVQYXJhbXMgYXMgU3RlcFJldHJpZXZlUGFyYW1zLFxuICAgIHR5cGUgU3RlcExpc3RQYXJhbXMgYXMgU3RlcExpc3RQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi8uLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgeyBBUElQcm9taXNlIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0IHsgQXNzaXN0YW50U3RyZWFtLCBSdW5DcmVhdGVQYXJhbXNCYXNlU3RyZWFtIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGliL0Fzc2lzdGFudFN0cmVhbSc7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4uLy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0IHsgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW0gfSBmcm9tICcuLi8uLi8uLi8uLi9saWIvQXNzaXN0YW50U3RyZWFtJztcbmltcG9ydCAqIGFzIFJ1bnNBUEkgZnJvbSAnLi9ydW5zJztcbmltcG9ydCAqIGFzIEFzc2lzdGFudHNBUEkgZnJvbSAnLi4vLi4vYXNzaXN0YW50cyc7XG5pbXBvcnQgKiBhcyBDaGF0QVBJIGZyb20gJy4uLy4uLy4uL2NoYXQvY2hhdCc7XG5pbXBvcnQgKiBhcyBNZXNzYWdlc0FQSSBmcm9tICcuLi9tZXNzYWdlcyc7XG5pbXBvcnQgKiBhcyBUaHJlYWRzQVBJIGZyb20gJy4uL3RocmVhZHMnO1xuaW1wb3J0ICogYXMgU3RlcHNBUEkgZnJvbSAnLi9zdGVwcyc7XG5pbXBvcnQge1xuICBDb2RlSW50ZXJwcmV0ZXJMb2dzLFxuICBDb2RlSW50ZXJwcmV0ZXJPdXRwdXRJbWFnZSxcbiAgQ29kZUludGVycHJldGVyVG9vbENhbGwsXG4gIENvZGVJbnRlcnByZXRlclRvb2xDYWxsRGVsdGEsXG4gIEZpbGVTZWFyY2hUb29sQ2FsbCxcbiAgRmlsZVNlYXJjaFRvb2xDYWxsRGVsdGEsXG4gIEZ1bmN0aW9uVG9vbENhbGwsXG4gIEZ1bmN0aW9uVG9vbENhbGxEZWx0YSxcbiAgTWVzc2FnZUNyZWF0aW9uU3RlcERldGFpbHMsXG4gIFJ1blN0ZXAsXG4gIFJ1blN0ZXBEZWx0YSxcbiAgUnVuU3RlcERlbHRhRXZlbnQsXG4gIFJ1blN0ZXBEZWx0YU1lc3NhZ2VEZWx0YSxcbiAgUnVuU3RlcEluY2x1ZGUsXG4gIFJ1blN0ZXBzUGFnZSxcbiAgU3RlcExpc3RQYXJhbXMsXG4gIFN0ZXBSZXRyaWV2ZVBhcmFtcyxcbiAgU3RlcHMsXG4gIFRvb2xDYWxsLFxuICBUb29sQ2FsbERlbHRhLFxuICBUb29sQ2FsbERlbHRhT2JqZWN0LFxuICBUb29sQ2FsbHNTdGVwRGV0YWlscyxcbn0gZnJvbSAnLi9zdGVwcyc7XG5pbXBvcnQgeyBDdXJzb3JQYWdlLCB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi8uLi9wYWdpbmF0aW9uJztcbmltcG9ydCB7IFN0cmVhbSB9IGZyb20gJy4uLy4uLy4uLy4uL3N0cmVhbWluZyc7XG5cbmV4cG9ydCBjbGFzcyBSdW5zIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICBzdGVwczogU3RlcHNBUEkuU3RlcHMgPSBuZXcgU3RlcHNBUEkuU3RlcHModGhpcy5fY2xpZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgcnVuLlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcGFyYW1zOiBSdW5DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8UnVuPjtcbiAgY3JlYXRlKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcGFyYW1zOiBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8U3RyZWFtPEFzc2lzdGFudHNBUEkuQXNzaXN0YW50U3RyZWFtRXZlbnQ+PjtcbiAgY3JlYXRlKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcGFyYW1zOiBSdW5DcmVhdGVQYXJhbXNCYXNlLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50PiB8IFJ1bj47XG4gIGNyZWF0ZShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHBhcmFtczogUnVuQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFJ1bj4gfCBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50Pj4ge1xuICAgIGNvbnN0IHsgaW5jbHVkZSwgLi4uYm9keSB9ID0gcGFyYW1zO1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVuc2AsIHtcbiAgICAgIHF1ZXJ5OiB7IGluY2x1ZGUgfSxcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgIHN0cmVhbTogcGFyYW1zLnN0cmVhbSA/PyBmYWxzZSxcbiAgICB9KSBhcyBBUElQcm9taXNlPFJ1bj4gfCBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50Pj47XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgcnVuLlxuICAgKi9cbiAgcmV0cmlldmUodGhyZWFkSWQ6IHN0cmluZywgcnVuSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8UnVuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZmllcyBhIHJ1bi5cbiAgICovXG4gIHVwZGF0ZShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgYm9keTogUnVuVXBkYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8UnVuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9YCwge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHJ1bnMgYmVsb25naW5nIHRvIGEgdGhyZWFkLlxuICAgKi9cbiAgbGlzdChcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHF1ZXJ5PzogUnVuTGlzdFBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxSdW5zUGFnZSwgUnVuPjtcbiAgbGlzdCh0aHJlYWRJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuUGFnZVByb21pc2U8UnVuc1BhZ2UsIFJ1bj47XG4gIGxpc3QoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBxdWVyeTogUnVuTGlzdFBhcmFtcyB8IENvcmUuUmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxSdW5zUGFnZSwgUnVuPiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0KHRocmVhZElkLCB7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnNgLCBSdW5zUGFnZSwge1xuICAgICAgcXVlcnksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcnVuIHRoYXQgaXMgYGluX3Byb2dyZXNzYC5cbiAgICovXG4gIGNhbmNlbCh0aHJlYWRJZDogc3RyaW5nLCBydW5JZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxSdW4+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH0vY2FuY2VsYCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBoZWxwZXIgdG8gY3JlYXRlIGEgcnVuIGFuIHBvbGwgZm9yIGEgdGVybWluYWwgc3RhdGUuIE1vcmUgaW5mb3JtYXRpb24gb24gUnVuXG4gICAqIGxpZmVjeWNsZXMgY2FuIGJlIGZvdW5kIGhlcmU6XG4gICAqIGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvaG93LWl0LXdvcmtzL3J1bnMtYW5kLXJ1bi1zdGVwc1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlQW5kUG9sbChcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIGJvZHk6IFJ1bkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyAmIHsgcG9sbEludGVydmFsTXM/OiBudW1iZXIgfSxcbiAgKTogUHJvbWlzZTxSdW4+IHtcbiAgICBjb25zdCBydW4gPSBhd2FpdCB0aGlzLmNyZWF0ZSh0aHJlYWRJZCwgYm9keSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucG9sbCh0aHJlYWRJZCwgcnVuLmlkLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBSdW4gc3RyZWFtXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgc3RyZWFtYCBpbnN0ZWFkXG4gICAqL1xuICBjcmVhdGVBbmRTdHJlYW0oXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBib2R5OiBSdW5DcmVhdGVQYXJhbXNCYXNlU3RyZWFtLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBc3Npc3RhbnRTdHJlYW0ge1xuICAgIHJldHVybiBBc3Npc3RhbnRTdHJlYW0uY3JlYXRlQXNzaXN0YW50U3RyZWFtKHRocmVhZElkLCB0aGlzLl9jbGllbnQuYmV0YS50aHJlYWRzLnJ1bnMsIGJvZHksIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIHRvIHBvbGwgYSBydW4gc3RhdHVzIHVudGlsIGl0IHJlYWNoZXMgYSB0ZXJtaW5hbCBzdGF0ZS4gTW9yZVxuICAgKiBpbmZvcm1hdGlvbiBvbiBSdW4gbGlmZWN5Y2xlcyBjYW4gYmUgZm91bmQgaGVyZTpcbiAgICogaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy9ob3ctaXQtd29ya3MvcnVucy1hbmQtcnVuLXN0ZXBzXG4gICAqL1xuICBhc3luYyBwb2xsKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyAmIHsgcG9sbEludGVydmFsTXM/OiBudW1iZXIgfSxcbiAgKTogUHJvbWlzZTxSdW4+IHtcbiAgICBjb25zdCBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0geyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtUG9sbC1IZWxwZXInOiAndHJ1ZScgfTtcblxuICAgIGlmIChvcHRpb25zPy5wb2xsSW50ZXJ2YWxNcykge1xuICAgICAgaGVhZGVyc1snWC1TdGFpbmxlc3MtQ3VzdG9tLVBvbGwtSW50ZXJ2YWwnXSA9IG9wdGlvbnMucG9sbEludGVydmFsTXMudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBkYXRhOiBydW4sIHJlc3BvbnNlIH0gPSBhd2FpdCB0aGlzLnJldHJpZXZlKHRocmVhZElkLCBydW5JZCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsIC4uLmhlYWRlcnMgfSxcbiAgICAgIH0pLndpdGhSZXNwb25zZSgpO1xuXG4gICAgICBzd2l0Y2ggKHJ1bi5zdGF0dXMpIHtcbiAgICAgICAgLy9JZiB3ZSBhcmUgaW4gYW55IHNvcnQgb2YgaW50ZXJtZWRpYXRlIHN0YXRlIHdlIHBvbGxcbiAgICAgICAgY2FzZSAncXVldWVkJzpcbiAgICAgICAgY2FzZSAnaW5fcHJvZ3Jlc3MnOlxuICAgICAgICBjYXNlICdjYW5jZWxsaW5nJzpcbiAgICAgICAgICBsZXQgc2xlZXBJbnRlcnZhbCA9IDUwMDA7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucz8ucG9sbEludGVydmFsTXMpIHtcbiAgICAgICAgICAgIHNsZWVwSW50ZXJ2YWwgPSBvcHRpb25zLnBvbGxJbnRlcnZhbE1zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJJbnRlcnZhbCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdvcGVuYWktcG9sbC1hZnRlci1tcycpO1xuICAgICAgICAgICAgaWYgKGhlYWRlckludGVydmFsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGhlYWRlckludGVydmFsTXMgPSBwYXJzZUludChoZWFkZXJJbnRlcnZhbCk7XG4gICAgICAgICAgICAgIGlmICghaXNOYU4oaGVhZGVySW50ZXJ2YWxNcykpIHtcbiAgICAgICAgICAgICAgICBzbGVlcEludGVydmFsID0gaGVhZGVySW50ZXJ2YWxNcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBzbGVlcChzbGVlcEludGVydmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy9XZSByZXR1cm4gdGhlIHJ1biBpbiBhbnkgdGVybWluYWwgc3RhdGUuXG4gICAgICAgIGNhc2UgJ3JlcXVpcmVzX2FjdGlvbic6XG4gICAgICAgIGNhc2UgJ2luY29tcGxldGUnOlxuICAgICAgICBjYXNlICdjYW5jZWxsZWQnOlxuICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICBjYXNlICdleHBpcmVkJzpcbiAgICAgICAgICByZXR1cm4gcnVuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBSdW4gc3RyZWFtXG4gICAqL1xuICBzdHJlYW0odGhyZWFkSWQ6IHN0cmluZywgYm9keTogUnVuQ3JlYXRlUGFyYW1zQmFzZVN0cmVhbSwgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBBc3Npc3RhbnRTdHJlYW0ge1xuICAgIHJldHVybiBBc3Npc3RhbnRTdHJlYW0uY3JlYXRlQXNzaXN0YW50U3RyZWFtKHRocmVhZElkLCB0aGlzLl9jbGllbnQuYmV0YS50aHJlYWRzLnJ1bnMsIGJvZHksIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBydW4gaGFzIHRoZSBgc3RhdHVzOiBcInJlcXVpcmVzX2FjdGlvblwiYCBhbmQgYHJlcXVpcmVkX2FjdGlvbi50eXBlYCBpc1xuICAgKiBgc3VibWl0X3Rvb2xfb3V0cHV0c2AsIHRoaXMgZW5kcG9pbnQgY2FuIGJlIHVzZWQgdG8gc3VibWl0IHRoZSBvdXRwdXRzIGZyb20gdGhlXG4gICAqIHRvb2wgY2FsbHMgb25jZSB0aGV5J3JlIGFsbCBjb21wbGV0ZWQuIEFsbCBvdXRwdXRzIG11c3QgYmUgc3VibWl0dGVkIGluIGEgc2luZ2xlXG4gICAqIHJlcXVlc3QuXG4gICAqL1xuICBzdWJtaXRUb29sT3V0cHV0cyhcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgYm9keTogUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8UnVuPjtcbiAgc3VibWl0VG9vbE91dHB1dHMoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIGJvZHk6IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50Pj47XG4gIHN1Ym1pdFRvb2xPdXRwdXRzKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBib2R5OiBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc0Jhc2UsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8U3RyZWFtPEFzc2lzdGFudHNBUEkuQXNzaXN0YW50U3RyZWFtRXZlbnQ+IHwgUnVuPjtcbiAgc3VibWl0VG9vbE91dHB1dHMoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIGJvZHk6IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFJ1bj4gfCBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50Pj4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfS9zdWJtaXRfdG9vbF9vdXRwdXRzYCwge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgc3RyZWFtOiBib2R5LnN0cmVhbSA/PyBmYWxzZSxcbiAgICB9KSBhcyBBUElQcm9taXNlPFJ1bj4gfCBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50Pj47XG4gIH1cblxuICAvKipcbiAgICogQSBoZWxwZXIgdG8gc3VibWl0IGEgdG9vbCBvdXRwdXQgdG8gYSBydW4gYW5kIHBvbGwgZm9yIGEgdGVybWluYWwgcnVuIHN0YXRlLlxuICAgKiBNb3JlIGluZm9ybWF0aW9uIG9uIFJ1biBsaWZlY3ljbGVzIGNhbiBiZSBmb3VuZCBoZXJlOlxuICAgKiBodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL2hvdy1pdC13b3Jrcy9ydW5zLWFuZC1ydW4tc3RlcHNcbiAgICovXG4gIGFzeW5jIHN1Ym1pdFRvb2xPdXRwdXRzQW5kUG9sbChcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgYm9keTogUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMgJiB7IHBvbGxJbnRlcnZhbE1zPzogbnVtYmVyIH0sXG4gICk6IFByb21pc2U8UnVuPiB7XG4gICAgY29uc3QgcnVuID0gYXdhaXQgdGhpcy5zdWJtaXRUb29sT3V0cHV0cyh0aHJlYWRJZCwgcnVuSWQsIGJvZHksIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnBvbGwodGhyZWFkSWQsIHJ1bi5pZCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU3VibWl0IHRoZSB0b29sIG91dHB1dHMgZnJvbSBhIHByZXZpb3VzIHJ1biBhbmQgc3RyZWFtIHRoZSBydW4gdG8gYSB0ZXJtaW5hbFxuICAgKiBzdGF0ZS4gTW9yZSBpbmZvcm1hdGlvbiBvbiBSdW4gbGlmZWN5Y2xlcyBjYW4gYmUgZm91bmQgaGVyZTpcbiAgICogaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy9ob3ctaXQtd29ya3MvcnVucy1hbmQtcnVuLXN0ZXBzXG4gICAqL1xuICBzdWJtaXRUb29sT3V0cHV0c1N0cmVhbShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgYm9keTogUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW0sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFzc2lzdGFudFN0cmVhbSB7XG4gICAgcmV0dXJuIEFzc2lzdGFudFN0cmVhbS5jcmVhdGVUb29sQXNzaXN0YW50U3RyZWFtKFxuICAgICAgdGhyZWFkSWQsXG4gICAgICBydW5JZCxcbiAgICAgIHRoaXMuX2NsaWVudC5iZXRhLnRocmVhZHMucnVucyxcbiAgICAgIGJvZHksXG4gICAgICBvcHRpb25zLFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJ1bnNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxSdW4+IHt9XG5cbi8qKlxuICogVG9vbCBjYWxsIG9iamVjdHNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXF1aXJlZEFjdGlvbkZ1bmN0aW9uVG9vbENhbGwge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwuIFRoaXMgSUQgbXVzdCBiZSByZWZlcmVuY2VkIHdoZW4geW91IHN1Ym1pdCB0aGUgdG9vbFxuICAgKiBvdXRwdXRzIGluIHVzaW5nIHRoZVxuICAgKiBbU3VibWl0IHRvb2wgb3V0cHV0cyB0byBydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9zdWJtaXRUb29sT3V0cHV0cylcbiAgICogZW5kcG9pbnQuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gZGVmaW5pdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uOiBSZXF1aXJlZEFjdGlvbkZ1bmN0aW9uVG9vbENhbGwuRnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRvb2wgY2FsbCB0aGUgb3V0cHV0IGlzIHJlcXVpcmVkIGZvci4gRm9yIG5vdywgdGhpcyBpcyBhbHdheXNcbiAgICogYGZ1bmN0aW9uYC5cbiAgICovXG4gIHR5cGU6ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUmVxdWlyZWRBY3Rpb25GdW5jdGlvblRvb2xDYWxsIHtcbiAgLyoqXG4gICAqIFRoZSBmdW5jdGlvbiBkZWZpbml0aW9uLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIGFyZ3VtZW50cyB0aGF0IHRoZSBtb2RlbCBleHBlY3RzIHlvdSB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBhcmd1bWVudHM6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSdW4ge1xuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdXNlZCBmb3JcbiAgICogZXhlY3V0aW9uIG9mIHRoaXMgcnVuLlxuICAgKi9cbiAgYXNzaXN0YW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHJ1biB3YXMgY2FuY2VsbGVkLlxuICAgKi9cbiAgY2FuY2VsbGVkX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBydW4gd2FzIGNvbXBsZXRlZC5cbiAgICovXG4gIGNvbXBsZXRlZF9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBydW4gd2lsbCBleHBpcmUuXG4gICAqL1xuICBleHBpcmVzX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBydW4gZmFpbGVkLlxuICAgKi9cbiAgZmFpbGVkX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBEZXRhaWxzIG9uIHdoeSB0aGUgcnVuIGlzIGluY29tcGxldGUuIFdpbGwgYmUgYG51bGxgIGlmIHRoZSBydW4gaXMgbm90XG4gICAqIGluY29tcGxldGUuXG4gICAqL1xuICBpbmNvbXBsZXRlX2RldGFpbHM6IFJ1bi5JbmNvbXBsZXRlRGV0YWlscyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBpbnN0cnVjdGlvbnMgdGhhdCB0aGVcbiAgICogW2Fzc2lzdGFudF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSB1c2VkIGZvclxuICAgKiB0aGlzIHJ1bi5cbiAgICovXG4gIGluc3RydWN0aW9uczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbGFzdCBlcnJvciBhc3NvY2lhdGVkIHdpdGggdGhpcyBydW4uIFdpbGwgYmUgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBlcnJvcnMuXG4gICAqL1xuICBsYXN0X2Vycm9yOiBSdW4uTGFzdEVycm9yIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zIHNwZWNpZmllZCB0byBoYXZlIGJlZW4gdXNlZCBvdmVyIHRoZVxuICAgKiBjb3Vyc2Ugb2YgdGhlIHJ1bi5cbiAgICovXG4gIG1heF9jb21wbGV0aW9uX3Rva2VuczogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHByb21wdCB0b2tlbnMgc3BlY2lmaWVkIHRvIGhhdmUgYmVlbiB1c2VkIG92ZXIgdGhlIGNvdXJzZVxuICAgKiBvZiB0aGUgcnVuLlxuICAgKi9cbiAgbWF4X3Byb21wdF90b2tlbnM6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhOiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHRoYXQgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdXNlZCBmb3JcbiAgICogdGhpcyBydW4uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgdGhyZWFkLnJ1bmAuXG4gICAqL1xuICBvYmplY3Q6ICd0aHJlYWQucnVuJztcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGVcbiAgICogW3BhcmFsbGVsIGZ1bmN0aW9uIGNhbGxpbmddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9mdW5jdGlvbi1jYWxsaW5nI2NvbmZpZ3VyaW5nLXBhcmFsbGVsLWZ1bmN0aW9uLWNhbGxpbmcpXG4gICAqIGR1cmluZyB0b29sIHVzZS5cbiAgICovXG4gIHBhcmFsbGVsX3Rvb2xfY2FsbHM6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERldGFpbHMgb24gdGhlIGFjdGlvbiByZXF1aXJlZCB0byBjb250aW51ZSB0aGUgcnVuLiBXaWxsIGJlIGBudWxsYCBpZiBubyBhY3Rpb25cbiAgICogaXMgcmVxdWlyZWQuXG4gICAqL1xuICByZXF1aXJlZF9hY3Rpb246IFJ1bi5SZXF1aXJlZEFjdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAgICogW0dQVC00b10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00byksXG4gICAqIFtHUFQtNCBUdXJib10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00LXR1cmJvLWFuZC1ncHQtNCksXG4gICAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9zY2hlbWFcIiwgXCJqc29uX3NjaGVtYVwiOiB7Li4ufSB9YCBlbmFibGVzIFN0cnVjdHVyZWRcbiAgICogT3V0cHV0cyB3aGljaCBlbnN1cmVzIHRoZSBtb2RlbCB3aWxsIG1hdGNoIHlvdXIgc3VwcGxpZWQgSlNPTiBzY2hlbWEuIExlYXJuIG1vcmVcbiAgICogaW4gdGhlXG4gICAqIFtTdHJ1Y3R1cmVkIE91dHB1dHMgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zdHJ1Y3R1cmVkLW91dHB1dHMpLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGVuc3VyZXMgdGhlXG4gICAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICAgKlxuICAgKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gICAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAgICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAgICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAgICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICAgKiBtYXggY29udGV4dCBsZW5ndGguXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ6IFRocmVhZHNBUEkuQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBydW4gd2FzIHN0YXJ0ZWQuXG4gICAqL1xuICBzdGFydGVkX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhdHVzIG9mIHRoZSBydW4sIHdoaWNoIGNhbiBiZSBlaXRoZXIgYHF1ZXVlZGAsIGBpbl9wcm9ncmVzc2AsXG4gICAqIGByZXF1aXJlc19hY3Rpb25gLCBgY2FuY2VsbGluZ2AsIGBjYW5jZWxsZWRgLCBgZmFpbGVkYCwgYGNvbXBsZXRlZGAsXG4gICAqIGBpbmNvbXBsZXRlYCwgb3IgYGV4cGlyZWRgLlxuICAgKi9cbiAgc3RhdHVzOiBSdW5TdGF0dXM7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKVxuICAgKiB0aGF0IHdhcyBleGVjdXRlZCBvbiBhcyBhIHBhcnQgb2YgdGhpcyBydW4uXG4gICAqL1xuICB0aHJlYWRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgdG9vbCBpcyBjYWxsZWQgYnkgdGhlIG1vZGVsLiBgbm9uZWAgbWVhbnMgdGhlIG1vZGVsIHdpbGxcbiAgICogbm90IGNhbGwgYW55IHRvb2xzIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBpcyB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgKiBhbmQgbWVhbnMgdGhlIG1vZGVsIGNhbiBwaWNrIGJldHdlZW4gZ2VuZXJhdGluZyBhIG1lc3NhZ2Ugb3IgY2FsbGluZyBvbmUgb3IgbW9yZVxuICAgKiB0b29scy4gYHJlcXVpcmVkYCBtZWFucyB0aGUgbW9kZWwgbXVzdCBjYWxsIG9uZSBvciBtb3JlIHRvb2xzIGJlZm9yZSByZXNwb25kaW5nXG4gICAqIHRvIHRoZSB1c2VyLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciB0b29sIGxpa2UgYHtcInR5cGVcIjogXCJmaWxlX3NlYXJjaFwifWAgb3JcbiAgICogYHtcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifX1gIGZvcmNlcyB0aGUgbW9kZWwgdG9cbiAgICogY2FsbCB0aGF0IHRvb2wuXG4gICAqL1xuICB0b29sX2Nob2ljZTogVGhyZWFkc0FQSS5Bc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgdG9vbHMgdGhhdCB0aGVcbiAgICogW2Fzc2lzdGFudF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSB1c2VkIGZvclxuICAgKiB0aGlzIHJ1bi5cbiAgICovXG4gIHRvb2xzOiBBcnJheTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFRvb2w+O1xuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgdHJ1bmNhdGlvbl9zdHJhdGVneTogUnVuLlRydW5jYXRpb25TdHJhdGVneSB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgcmVsYXRlZCB0byB0aGUgcnVuLiBUaGlzIHZhbHVlIHdpbGwgYmUgYG51bGxgIGlmIHRoZSBydW4gaXMgbm90XG4gICAqIGluIGEgdGVybWluYWwgc3RhdGUgKGkuZS4gYGluX3Byb2dyZXNzYCwgYHF1ZXVlZGAsIGV0Yy4pLlxuICAgKi9cbiAgdXNhZ2U6IFJ1bi5Vc2FnZSB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzYW1wbGluZyB0ZW1wZXJhdHVyZSB1c2VkIGZvciB0aGlzIHJ1bi4gSWYgbm90IHNldCwgZGVmYXVsdHMgdG8gMS5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG51Y2xldXMgc2FtcGxpbmcgdmFsdWUgdXNlZCBmb3IgdGhpcyBydW4uIElmIG5vdCBzZXQsIGRlZmF1bHRzIHRvIDEuXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuIHtcbiAgLyoqXG4gICAqIERldGFpbHMgb24gd2h5IHRoZSBydW4gaXMgaW5jb21wbGV0ZS4gV2lsbCBiZSBgbnVsbGAgaWYgdGhlIHJ1biBpcyBub3RcbiAgICogaW5jb21wbGV0ZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSW5jb21wbGV0ZURldGFpbHMge1xuICAgIC8qKlxuICAgICAqIFRoZSByZWFzb24gd2h5IHRoZSBydW4gaXMgaW5jb21wbGV0ZS4gVGhpcyB3aWxsIHBvaW50IHRvIHdoaWNoIHNwZWNpZmljIHRva2VuXG4gICAgICogbGltaXQgd2FzIHJlYWNoZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBydW4uXG4gICAgICovXG4gICAgcmVhc29uPzogJ21heF9jb21wbGV0aW9uX3Rva2VucycgfCAnbWF4X3Byb21wdF90b2tlbnMnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBsYXN0IGVycm9yIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJ1bi4gV2lsbCBiZSBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIGVycm9ycy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgTGFzdEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBPbmUgb2YgYHNlcnZlcl9lcnJvcmAsIGByYXRlX2xpbWl0X2V4Y2VlZGVkYCwgb3IgYGludmFsaWRfcHJvbXB0YC5cbiAgICAgKi9cbiAgICBjb2RlOiAnc2VydmVyX2Vycm9yJyB8ICdyYXRlX2xpbWl0X2V4Y2VlZGVkJyB8ICdpbnZhbGlkX3Byb21wdCc7XG5cbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvci5cbiAgICAgKi9cbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogRGV0YWlscyBvbiB0aGUgYWN0aW9uIHJlcXVpcmVkIHRvIGNvbnRpbnVlIHRoZSBydW4uIFdpbGwgYmUgYG51bGxgIGlmIG5vIGFjdGlvblxuICAgKiBpcyByZXF1aXJlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgUmVxdWlyZWRBY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIERldGFpbHMgb24gdGhlIHRvb2wgb3V0cHV0cyBuZWVkZWQgZm9yIHRoaXMgcnVuIHRvIGNvbnRpbnVlLlxuICAgICAqL1xuICAgIHN1Ym1pdF90b29sX291dHB1dHM6IFJlcXVpcmVkQWN0aW9uLlN1Ym1pdFRvb2xPdXRwdXRzO1xuXG4gICAgLyoqXG4gICAgICogRm9yIG5vdywgdGhpcyBpcyBhbHdheXMgYHN1Ym1pdF90b29sX291dHB1dHNgLlxuICAgICAqL1xuICAgIHR5cGU6ICdzdWJtaXRfdG9vbF9vdXRwdXRzJztcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgUmVxdWlyZWRBY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIERldGFpbHMgb24gdGhlIHRvb2wgb3V0cHV0cyBuZWVkZWQgZm9yIHRoaXMgcnVuIHRvIGNvbnRpbnVlLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgU3VibWl0VG9vbE91dHB1dHMge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgdGhlIHJlbGV2YW50IHRvb2wgY2FsbHMuXG4gICAgICAgKi9cbiAgICAgIHRvb2xfY2FsbHM6IEFycmF5PFJ1bnNBUEkuUmVxdWlyZWRBY3Rpb25GdW5jdGlvblRvb2xDYWxsPjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVHJ1bmNhdGlvblN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJ1bmNhdGlvbiBzdHJhdGVneSB0byB1c2UgZm9yIHRoZSB0aHJlYWQuIFRoZSBkZWZhdWx0IGlzIGBhdXRvYC4gSWYgc2V0IHRvXG4gICAgICogYGxhc3RfbWVzc2FnZXNgLCB0aGUgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHRvIHRoZSBuIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGluXG4gICAgICogdGhlIHRocmVhZC4gV2hlbiBzZXQgdG8gYGF1dG9gLCBtZXNzYWdlcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSB0aHJlYWQgd2lsbCBiZVxuICAgICAqIGRyb3BwZWQgdG8gZml0IHRoZSBjb250ZXh0IGxlbmd0aCBvZiB0aGUgbW9kZWwsIGBtYXhfcHJvbXB0X3Rva2Vuc2AuXG4gICAgICovXG4gICAgdHlwZTogJ2F1dG8nIHwgJ2xhc3RfbWVzc2FnZXMnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtb3N0IHJlY2VudCBtZXNzYWdlcyBmcm9tIHRoZSB0aHJlYWQgd2hlbiBjb25zdHJ1Y3RpbmcgdGhlIGNvbnRleHRcbiAgICAgKiBmb3IgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBsYXN0X21lc3NhZ2VzPzogbnVtYmVyIHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2FnZSBzdGF0aXN0aWNzIHJlbGF0ZWQgdG8gdGhlIHJ1bi4gVGhpcyB2YWx1ZSB3aWxsIGJlIGBudWxsYCBpZiB0aGUgcnVuIGlzIG5vdFxuICAgKiBpbiBhIHRlcm1pbmFsIHN0YXRlIChpLmUuIGBpbl9wcm9ncmVzc2AsIGBxdWV1ZWRgLCBldGMuKS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVXNhZ2Uge1xuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBjb21wbGV0aW9uIHRva2VucyB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgcnVuLlxuICAgICAqL1xuICAgIGNvbXBsZXRpb25fdG9rZW5zOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgcHJvbXB0IHRva2VucyB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgcnVuLlxuICAgICAqL1xuICAgIHByb21wdF90b2tlbnM6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRvdGFsIG51bWJlciBvZiB0b2tlbnMgdXNlZCAocHJvbXB0ICsgY29tcGxldGlvbikuXG4gICAgICovXG4gICAgdG90YWxfdG9rZW5zOiBudW1iZXI7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgc3RhdHVzIG9mIHRoZSBydW4sIHdoaWNoIGNhbiBiZSBlaXRoZXIgYHF1ZXVlZGAsIGBpbl9wcm9ncmVzc2AsXG4gKiBgcmVxdWlyZXNfYWN0aW9uYCwgYGNhbmNlbGxpbmdgLCBgY2FuY2VsbGVkYCwgYGZhaWxlZGAsIGBjb21wbGV0ZWRgLFxuICogYGluY29tcGxldGVgLCBvciBgZXhwaXJlZGAuXG4gKi9cbmV4cG9ydCB0eXBlIFJ1blN0YXR1cyA9XG4gIHwgJ3F1ZXVlZCdcbiAgfCAnaW5fcHJvZ3Jlc3MnXG4gIHwgJ3JlcXVpcmVzX2FjdGlvbidcbiAgfCAnY2FuY2VsbGluZydcbiAgfCAnY2FuY2VsbGVkJ1xuICB8ICdmYWlsZWQnXG4gIHwgJ2NvbXBsZXRlZCdcbiAgfCAnaW5jb21wbGV0ZSdcbiAgfCAnZXhwaXJlZCc7XG5cbmV4cG9ydCB0eXBlIFJ1bkNyZWF0ZVBhcmFtcyA9IFJ1bkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyB8IFJ1bkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcblxuZXhwb3J0IGludGVyZmFjZSBSdW5DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IFRoZSBJRCBvZiB0aGVcbiAgICogW2Fzc2lzdGFudF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSB0byB1c2UgdG9cbiAgICogZXhlY3V0ZSB0aGlzIHJ1bi5cbiAgICovXG4gIGFzc2lzdGFudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBRdWVyeSBwYXJhbTogQSBsaXN0IG9mIGFkZGl0aW9uYWwgZmllbGRzIHRvIGluY2x1ZGUgaW4gdGhlIHJlc3BvbnNlLiBDdXJyZW50bHlcbiAgICogdGhlIG9ubHkgc3VwcG9ydGVkIHZhbHVlIGlzXG4gICAqIGBzdGVwX2RldGFpbHMudG9vbF9jYWxsc1sqXS5maWxlX3NlYXJjaC5yZXN1bHRzWypdLmNvbnRlbnRgIHRvIGZldGNoIHRoZSBmaWxlXG4gICAqIHNlYXJjaCByZXN1bHQgY29udGVudC5cbiAgICpcbiAgICogU2VlIHRoZVxuICAgKiBbZmlsZSBzZWFyY2ggdG9vbCBkb2N1bWVudGF0aW9uXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL3Rvb2xzL2ZpbGUtc2VhcmNoI2N1c3RvbWl6aW5nLWZpbGUtc2VhcmNoLXNldHRpbmdzKVxuICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGluY2x1ZGU/OiBBcnJheTxTdGVwc0FQSS5SdW5TdGVwSW5jbHVkZT47XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IEFwcGVuZHMgYWRkaXRpb25hbCBpbnN0cnVjdGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgaW5zdHJ1Y3Rpb25zIGZvclxuICAgKiB0aGUgcnVuLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMgd2l0aG91dFxuICAgKiBvdmVycmlkaW5nIG90aGVyIGluc3RydWN0aW9ucy5cbiAgICovXG4gIGFkZGl0aW9uYWxfaW5zdHJ1Y3Rpb25zPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogQWRkcyBhZGRpdGlvbmFsIG1lc3NhZ2VzIHRvIHRoZSB0aHJlYWQgYmVmb3JlIGNyZWF0aW5nIHRoZSBydW4uXG4gICAqL1xuICBhZGRpdGlvbmFsX21lc3NhZ2VzPzogQXJyYXk8UnVuQ3JlYXRlUGFyYW1zLkFkZGl0aW9uYWxNZXNzYWdlPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IE92ZXJyaWRlcyB0aGVcbiAgICogW2luc3RydWN0aW9uc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzL2NyZWF0ZUFzc2lzdGFudClcbiAgICogb2YgdGhlIGFzc2lzdGFudC4gVGhpcyBpcyB1c2VmdWwgZm9yIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogVGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zIHRoYXQgbWF5IGJlIHVzZWQgb3ZlciB0aGVcbiAgICogY291cnNlIG9mIHRoZSBydW4uIFRoZSBydW4gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdXNlIG9ubHkgdGhlIG51bWJlciBvZlxuICAgKiBjb21wbGV0aW9uIHRva2VucyBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuXG4gICAqIGV4Y2VlZHMgdGhlIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXNcbiAgICogYGluY29tcGxldGVgLiBTZWUgYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9jb21wbGV0aW9uX3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IFRoZSBtYXhpbXVtIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zIHRoYXQgbWF5IGJlIHVzZWQgb3ZlciB0aGUgY291cnNlXG4gICAqIG9mIHRoZSBydW4uIFRoZSBydW4gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdXNlIG9ubHkgdGhlIG51bWJlciBvZiBwcm9tcHRcbiAgICogdG9rZW5zIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGVcbiAgICogbnVtYmVyIG9mIHByb21wdCB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC5cbiAgICogU2VlIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfcHJvbXB0X3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzXG4gICAqIGNhbiBiZSB1c2VmdWwgZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGFcbiAgICogc3RydWN0dXJlZCBmb3JtYXQuIEtleXMgY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmVcbiAgICogYSBtYXhpdW0gb2YgNTEyIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IFRoZSBJRCBvZiB0aGVcbiAgICogW01vZGVsXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscykgdG8gYmUgdXNlZCB0b1xuICAgKiBleGVjdXRlIHRoaXMgcnVuLiBJZiBhIHZhbHVlIGlzIHByb3ZpZGVkIGhlcmUsIGl0IHdpbGwgb3ZlcnJpZGUgdGhlIG1vZGVsXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzaXN0YW50LiBJZiBub3QsIHRoZSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2lzdGFudFxuICAgKiB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICBtb2RlbD86IChzdHJpbmcgJiB7fSkgfCBDaGF0QVBJLkNoYXRNb2RlbCB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IFdoZXRoZXIgdG8gZW5hYmxlXG4gICAqIFtwYXJhbGxlbCBmdW5jdGlvbiBjYWxsaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZnVuY3Rpb24tY2FsbGluZyNjb25maWd1cmluZy1wYXJhbGxlbC1mdW5jdGlvbi1jYWxsaW5nKVxuICAgKiBkdXJpbmcgdG9vbCB1c2UuXG4gICAqL1xuICBwYXJhbGxlbF90b29sX2NhbGxzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogU3BlY2lmaWVzIHRoZSBmb3JtYXQgdGhhdCB0aGUgbW9kZWwgbXVzdCBvdXRwdXQuIENvbXBhdGlibGUgd2l0aFxuICAgKiBbR1BULTRvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTRvKSxcbiAgICogW0dQVC00IFR1cmJvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTQtdHVyYm8tYW5kLWdwdC00KSxcbiAgICogYW5kIGFsbCBHUFQtMy41IFR1cmJvIG1vZGVscyBzaW5jZSBgZ3B0LTMuNS10dXJiby0xMTA2YC5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX3NjaGVtYVwiLCBcImpzb25fc2NoZW1hXCI6IHsuLi59IH1gIGVuYWJsZXMgU3RydWN0dXJlZFxuICAgKiBPdXRwdXRzIHdoaWNoIGVuc3VyZXMgdGhlIG1vZGVsIHdpbGwgbWF0Y2ggeW91ciBzdXBwbGllZCBKU09OIHNjaGVtYS4gTGVhcm4gbW9yZVxuICAgKiBpbiB0aGVcbiAgICogW1N0cnVjdHVyZWQgT3V0cHV0cyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3N0cnVjdHVyZWQtb3V0cHV0cykuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9vYmplY3RcIiB9YCBlbmFibGVzIEpTT04gbW9kZSwgd2hpY2ggZW5zdXJlcyB0aGVcbiAgICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gICAqXG4gICAqICoqSW1wb3J0YW50OioqIHdoZW4gdXNpbmcgSlNPTiBtb2RlLCB5b3UgKiptdXN0KiogYWxzbyBpbnN0cnVjdCB0aGUgbW9kZWwgdG9cbiAgICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICAgKiBnZW5lcmF0ZSBhbiB1bmVuZGluZyBzdHJlYW0gb2Ygd2hpdGVzcGFjZSB1bnRpbCB0aGUgZ2VuZXJhdGlvbiByZWFjaGVzIHRoZSB0b2tlblxuICAgKiBsaW1pdCwgcmVzdWx0aW5nIGluIGEgbG9uZy1ydW5uaW5nIGFuZCBzZWVtaW5nbHkgXCJzdHVja1wiIHJlcXVlc3QuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICAgKiBpbmRpY2F0ZXMgdGhlIGdlbmVyYXRpb24gZXhjZWVkZWQgYG1heF90b2tlbnNgIG9yIHRoZSBjb252ZXJzYXRpb24gZXhjZWVkZWQgdGhlXG4gICAqIG1heCBjb250ZXh0IGxlbmd0aC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86IFRocmVhZHNBUEkuQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBJZiBgdHJ1ZWAsIHJldHVybnMgYSBzdHJlYW0gb2YgZXZlbnRzIHRoYXQgaGFwcGVuIGR1cmluZyB0aGUgUnVuIGFzXG4gICAqIHNlcnZlci1zZW50IGV2ZW50cywgdGVybWluYXRpbmcgd2hlbiB0aGUgUnVuIGVudGVycyBhIHRlcm1pbmFsIHN0YXRlIHdpdGggYVxuICAgKiBgZGF0YTogW0RPTkVdYCBtZXNzYWdlLlxuICAgKi9cbiAgc3RyZWFtPzogYm9vbGVhbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IFdoYXQgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdG8gdXNlLCBiZXR3ZWVuIDAgYW5kIDIuIEhpZ2hlciB2YWx1ZXNcbiAgICogbGlrZSAwLjggd2lsbCBtYWtlIHRoZSBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2VcbiAgICogaXQgbW9yZSBmb2N1c2VkIGFuZCBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBDb250cm9scyB3aGljaCAoaWYgYW55KSB0b29sIGlzIGNhbGxlZCBieSB0aGUgbW9kZWwuIGBub25lYCBtZWFuc1xuICAgKiB0aGUgbW9kZWwgd2lsbCBub3QgY2FsbCBhbnkgdG9vbHMgYW5kIGluc3RlYWQgZ2VuZXJhdGVzIGEgbWVzc2FnZS4gYGF1dG9gIGlzIHRoZVxuICAgKiBkZWZhdWx0IHZhbHVlIGFuZCBtZWFucyB0aGUgbW9kZWwgY2FuIHBpY2sgYmV0d2VlbiBnZW5lcmF0aW5nIGEgbWVzc2FnZSBvclxuICAgKiBjYWxsaW5nIG9uZSBvciBtb3JlIHRvb2xzLiBgcmVxdWlyZWRgIG1lYW5zIHRoZSBtb2RlbCBtdXN0IGNhbGwgb25lIG9yIG1vcmVcbiAgICogdG9vbHMgYmVmb3JlIHJlc3BvbmRpbmcgdG8gdGhlIHVzZXIuIFNwZWNpZnlpbmcgYSBwYXJ0aWN1bGFyIHRvb2wgbGlrZVxuICAgKiBge1widHlwZVwiOiBcImZpbGVfc2VhcmNoXCJ9YCBvclxuICAgKiBge1widHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIm15X2Z1bmN0aW9uXCJ9fWAgZm9yY2VzIHRoZSBtb2RlbCB0b1xuICAgKiBjYWxsIHRoYXQgdG9vbC5cbiAgICovXG4gIHRvb2xfY2hvaWNlPzogVGhyZWFkc0FQSS5Bc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogT3ZlcnJpZGUgdGhlIHRvb2xzIHRoZSBhc3Npc3RhbnQgY2FuIHVzZSBmb3IgdGhpcyBydW4uIFRoaXMgaXNcbiAgICogdXNlZnVsIGZvciBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRUb29sPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IEFuIGFsdGVybmF0aXZlIHRvIHNhbXBsaW5nIHdpdGggdGVtcGVyYXR1cmUsIGNhbGxlZCBudWNsZXVzXG4gICAqIHNhbXBsaW5nLCB3aGVyZSB0aGUgbW9kZWwgY29uc2lkZXJzIHRoZSByZXN1bHRzIG9mIHRoZSB0b2tlbnMgd2l0aCB0b3BfcFxuICAgKiBwcm9iYWJpbGl0eSBtYXNzLiBTbyAwLjEgbWVhbnMgb25seSB0aGUgdG9rZW5zIGNvbXByaXNpbmcgdGhlIHRvcCAxMCVcbiAgICogcHJvYmFiaWxpdHkgbWFzcyBhcmUgY29uc2lkZXJlZC5cbiAgICpcbiAgICogV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIHRlbXBlcmF0dXJlIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRvcF9wPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2VcbiAgICogdGhpcyB0byBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIHRydW5jYXRpb25fc3RyYXRlZ3k/OiBSdW5DcmVhdGVQYXJhbXMuVHJ1bmNhdGlvblN0cmF0ZWd5IHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSdW5DcmVhdGVQYXJhbXMge1xuICBleHBvcnQgaW50ZXJmYWNlIEFkZGl0aW9uYWxNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCBjb250ZW50cyBvZiB0aGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxNZXNzYWdlc0FQSS5NZXNzYWdlQ29udGVudFBhcnRQYXJhbT47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm9sZSBvZiB0aGUgZW50aXR5IHRoYXQgaXMgY3JlYXRpbmcgdGhlIG1lc3NhZ2UuIEFsbG93ZWQgdmFsdWVzIGluY2x1ZGU6XG4gICAgICpcbiAgICAgKiAtIGB1c2VyYDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIHNlbnQgYnkgYW4gYWN0dWFsIHVzZXIgYW5kIHNob3VsZCBiZSB1c2VkIGluXG4gICAgICogICBtb3N0IGNhc2VzIHRvIHJlcHJlc2VudCB1c2VyLWdlbmVyYXRlZCBtZXNzYWdlcy5cbiAgICAgKiAtIGBhc3Npc3RhbnRgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBhc3Npc3RhbnQuIFVzZSB0aGlzXG4gICAgICogICB2YWx1ZSB0byBpbnNlcnQgbWVzc2FnZXMgZnJvbSB0aGUgYXNzaXN0YW50IGludG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgKi9cbiAgICByb2xlOiAndXNlcicgfCAnYXNzaXN0YW50JztcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byB0aGUgbWVzc2FnZSwgYW5kIHRoZSB0b29scyB0aGV5IHNob3VsZCBiZSBhZGRlZCB0by5cbiAgICAgKi9cbiAgICBhdHRhY2htZW50cz86IEFycmF5PEFkZGl0aW9uYWxNZXNzYWdlLkF0dGFjaG1lbnQ+IHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgKi9cbiAgICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBBZGRpdGlvbmFsTWVzc2FnZSB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBBdHRhY2htZW50IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIElEIG9mIHRoZSBmaWxlIHRvIGF0dGFjaCB0byB0aGUgbWVzc2FnZS5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZD86IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdG9vbHMgdG8gYWRkIHRoaXMgZmlsZSB0by5cbiAgICAgICAqL1xuICAgICAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkNvZGVJbnRlcnByZXRlclRvb2wgfCBBdHRhY2htZW50LkZpbGVTZWFyY2g+O1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgQXR0YWNobWVudCB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdG9vbCBiZWluZyBkZWZpbmVkOiBgZmlsZV9zZWFyY2hgXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnZmlsZV9zZWFyY2gnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUcnVuY2F0aW9uU3RyYXRlZ3kge1xuICAgIC8qKlxuICAgICAqIFRoZSB0cnVuY2F0aW9uIHN0cmF0ZWd5IHRvIHVzZSBmb3IgdGhlIHRocmVhZC4gVGhlIGRlZmF1bHQgaXMgYGF1dG9gLiBJZiBzZXQgdG9cbiAgICAgKiBgbGFzdF9tZXNzYWdlc2AsIHRoZSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgdG8gdGhlIG4gbW9zdCByZWNlbnQgbWVzc2FnZXMgaW5cbiAgICAgKiB0aGUgdGhyZWFkLiBXaGVuIHNldCB0byBgYXV0b2AsIG1lc3NhZ2VzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHRocmVhZCB3aWxsIGJlXG4gICAgICogZHJvcHBlZCB0byBmaXQgdGhlIGNvbnRleHQgbGVuZ3RoIG9mIHRoZSBtb2RlbCwgYG1heF9wcm9tcHRfdG9rZW5zYC5cbiAgICAgKi9cbiAgICB0eXBlOiAnYXV0bycgfCAnbGFzdF9tZXNzYWdlcyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGZyb20gdGhlIHRocmVhZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgY29udGV4dFxuICAgICAqIGZvciB0aGUgcnVuLlxuICAgICAqL1xuICAgIGxhc3RfbWVzc2FnZXM/OiBudW1iZXIgfCBudWxsO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgUnVuQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nID0gUnVuc0FQSS5SdW5DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmc7XG4gIGV4cG9ydCB0eXBlIFJ1bkNyZWF0ZVBhcmFtc1N0cmVhbWluZyA9IFJ1bnNBUEkuUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1bkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBleHRlbmRzIFJ1bkNyZWF0ZVBhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogQm9keSBwYXJhbTogSWYgYHRydWVgLCByZXR1cm5zIGEgc3RyZWFtIG9mIGV2ZW50cyB0aGF0IGhhcHBlbiBkdXJpbmcgdGhlIFJ1biBhc1xuICAgKiBzZXJ2ZXItc2VudCBldmVudHMsIHRlcm1pbmF0aW5nIHdoZW4gdGhlIFJ1biBlbnRlcnMgYSB0ZXJtaW5hbCBzdGF0ZSB3aXRoIGFcbiAgICogYGRhdGE6IFtET05FXWAgbWVzc2FnZS5cbiAgICovXG4gIHN0cmVhbT86IGZhbHNlIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmcgZXh0ZW5kcyBSdW5DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IElmIGB0cnVlYCwgcmV0dXJucyBhIHN0cmVhbSBvZiBldmVudHMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoZSBSdW4gYXNcbiAgICogc2VydmVyLXNlbnQgZXZlbnRzLCB0ZXJtaW5hdGluZyB3aGVuIHRoZSBSdW4gZW50ZXJzIGEgdGVybWluYWwgc3RhdGUgd2l0aCBhXG4gICAqIGBkYXRhOiBbRE9ORV1gIG1lc3NhZ2UuXG4gICAqL1xuICBzdHJlYW06IHRydWU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuVXBkYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuTGlzdFBhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge1xuICAvKipcbiAgICogQSBjdXJzb3IgZm9yIHVzZSBpbiBwYWdpbmF0aW9uLiBgYmVmb3JlYCBpcyBhbiBvYmplY3QgSUQgdGhhdCBkZWZpbmVzIHlvdXIgcGxhY2VcbiAgICogaW4gdGhlIGxpc3QuIEZvciBpbnN0YW5jZSwgaWYgeW91IG1ha2UgYSBsaXN0IHJlcXVlc3QgYW5kIHJlY2VpdmUgMTAwIG9iamVjdHMsXG4gICAqIHN0YXJ0aW5nIHdpdGggb2JqX2ZvbywgeW91ciBzdWJzZXF1ZW50IGNhbGwgY2FuIGluY2x1ZGUgYmVmb3JlPW9ial9mb28gaW4gb3JkZXJcbiAgICogdG8gZmV0Y2ggdGhlIHByZXZpb3VzIHBhZ2Ugb2YgdGhlIGxpc3QuXG4gICAqL1xuICBiZWZvcmU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNvcnQgb3JkZXIgYnkgdGhlIGBjcmVhdGVkX2F0YCB0aW1lc3RhbXAgb2YgdGhlIG9iamVjdHMuIGBhc2NgIGZvciBhc2NlbmRpbmdcbiAgICogb3JkZXIgYW5kIGBkZXNjYCBmb3IgZGVzY2VuZGluZyBvcmRlci5cbiAgICovXG4gIG9yZGVyPzogJ2FzYycgfCAnZGVzYyc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuQ3JlYXRlQW5kUG9sbFBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdG8gdXNlIHRvXG4gICAqIGV4ZWN1dGUgdGhpcyBydW4uXG4gICAqL1xuICBhc3Npc3RhbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQXBwZW5kcyBhZGRpdGlvbmFsIGluc3RydWN0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSBpbnN0cnVjdGlvbnMgZm9yIHRoZSBydW4uIFRoaXNcbiAgICogaXMgdXNlZnVsIGZvciBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcyB3aXRob3V0IG92ZXJyaWRpbmcgb3RoZXJcbiAgICogaW5zdHJ1Y3Rpb25zLlxuICAgKi9cbiAgYWRkaXRpb25hbF9pbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBZGRzIGFkZGl0aW9uYWwgbWVzc2FnZXMgdG8gdGhlIHRocmVhZCBiZWZvcmUgY3JlYXRpbmcgdGhlIHJ1bi5cbiAgICovXG4gIGFkZGl0aW9uYWxfbWVzc2FnZXM/OiBBcnJheTxSdW5DcmVhdGVBbmRQb2xsUGFyYW1zLkFkZGl0aW9uYWxNZXNzYWdlPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyB0aGVcbiAgICogW2luc3RydWN0aW9uc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzL2NyZWF0ZUFzc2lzdGFudClcbiAgICogb2YgdGhlIGFzc2lzdGFudC4gVGhpcyBpcyB1c2VmdWwgZm9yIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zIHRoYXQgbWF5IGJlIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZVxuICAgKiBydW4uIFRoZSBydW4gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdXNlIG9ubHkgdGhlIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2Vuc1xuICAgKiBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlIG51bWJlciBvZlxuICAgKiBjb21wbGV0aW9uIHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLiBTZWVcbiAgICogYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9jb21wbGV0aW9uX3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zIHRoYXQgbWF5IGJlIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBydW4uXG4gICAqIFRoZSBydW4gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdXNlIG9ubHkgdGhlIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zXG4gICAqIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGUgbnVtYmVyIG9mXG4gICAqIHByb21wdCB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC4gU2VlXG4gICAqIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfcHJvbXB0X3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgW01vZGVsXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscykgdG9cbiAgICogYmUgdXNlZCB0byBleGVjdXRlIHRoaXMgcnVuLiBJZiBhIHZhbHVlIGlzIHByb3ZpZGVkIGhlcmUsIGl0IHdpbGwgb3ZlcnJpZGUgdGhlXG4gICAqIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzaXN0YW50LiBJZiBub3QsIHRoZSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAqIGFzc2lzdGFudCB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICBtb2RlbD86XG4gICAgfCAoc3RyaW5nICYge30pXG4gICAgfCAnZ3B0LTRvJ1xuICAgIHwgJ2dwdC00by0yMDI0LTA1LTEzJ1xuICAgIHwgJ2dwdC00LXR1cmJvJ1xuICAgIHwgJ2dwdC00LXR1cmJvLTIwMjQtMDQtMDknXG4gICAgfCAnZ3B0LTQtMDEyNS1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LXR1cmJvLXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtMTEwNi1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LXZpc2lvbi1wcmV2aWV3J1xuICAgIHwgJ2dwdC00J1xuICAgIHwgJ2dwdC00LTAzMTQnXG4gICAgfCAnZ3B0LTQtMDYxMydcbiAgICB8ICdncHQtNC0zMmsnXG4gICAgfCAnZ3B0LTQtMzJrLTAzMTQnXG4gICAgfCAnZ3B0LTQtMzJrLTA2MTMnXG4gICAgfCAnZ3B0LTMuNS10dXJibydcbiAgICB8ICdncHQtMy41LXR1cmJvLTE2aydcbiAgICB8ICdncHQtMy41LXR1cmJvLTA2MTMnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xMTA2J1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMDEyNSdcbiAgICB8ICdncHQtMy41LXR1cmJvLTE2ay0wNjEzJ1xuICAgIHwgbnVsbDtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBmb3JtYXQgdGhhdCB0aGUgbW9kZWwgbXVzdCBvdXRwdXQuIENvbXBhdGlibGUgd2l0aFxuICAgKiBbR1BULTRvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMvZ3B0LTRvKSxcbiAgICogW0dQVC00IFR1cmJvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMvZ3B0LTQtdHVyYm8tYW5kLWdwdC00KSxcbiAgICogYW5kIGFsbCBHUFQtMy41IFR1cmJvIG1vZGVscyBzaW5jZSBgZ3B0LTMuNS10dXJiby0xMTA2YC5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBndWFyYW50ZWVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogVGhyZWFkc0FQSS5Bc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoYXQgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdG8gdXNlLCBiZXR3ZWVuIDAgYW5kIDIuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbFxuICAgKiBtYWtlIHRoZSBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZVxuICAgKiBmb2N1c2VkIGFuZCBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyB3aGljaCAoaWYgYW55KSB0b29sIGlzIGNhbGxlZCBieSB0aGUgbW9kZWwuIGBub25lYCBtZWFucyB0aGUgbW9kZWwgd2lsbFxuICAgKiBub3QgY2FsbCBhbnkgdG9vbHMgYW5kIGluc3RlYWQgZ2VuZXJhdGVzIGEgbWVzc2FnZS4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAqIGFuZCBtZWFucyB0aGUgbW9kZWwgY2FuIHBpY2sgYmV0d2VlbiBnZW5lcmF0aW5nIGEgbWVzc2FnZSBvciBjYWxsaW5nIG9uZSBvciBtb3JlXG4gICAqIHRvb2xzLiBgcmVxdWlyZWRgIG1lYW5zIHRoZSBtb2RlbCBtdXN0IGNhbGwgb25lIG9yIG1vcmUgdG9vbHMgYmVmb3JlIHJlc3BvbmRpbmdcbiAgICogdG8gdGhlIHVzZXIuIFNwZWNpZnlpbmcgYSBwYXJ0aWN1bGFyIHRvb2wgbGlrZSBge1widHlwZVwiOiBcImZpbGVfc2VhcmNoXCJ9YCBvclxuICAgKiBge1widHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIm15X2Z1bmN0aW9uXCJ9fWAgZm9yY2VzIHRoZSBtb2RlbCB0b1xuICAgKiBjYWxsIHRoYXQgdG9vbC5cbiAgICovXG4gIHRvb2xfY2hvaWNlPzogVGhyZWFkc0FQSS5Bc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHRvb2xzIHRoZSBhc3Npc3RhbnQgY2FuIHVzZSBmb3IgdGhpcyBydW4uIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRUb29sPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEFuIGFsdGVybmF0aXZlIHRvIHNhbXBsaW5nIHdpdGggdGVtcGVyYXR1cmUsIGNhbGxlZCBudWNsZXVzIHNhbXBsaW5nLCB3aGVyZSB0aGVcbiAgICogbW9kZWwgY29uc2lkZXJzIHRoZSByZXN1bHRzIG9mIHRoZSB0b2tlbnMgd2l0aCB0b3BfcCBwcm9iYWJpbGl0eSBtYXNzLiBTbyAwLjFcbiAgICogbWVhbnMgb25seSB0aGUgdG9rZW5zIGNvbXByaXNpbmcgdGhlIHRvcCAxMCUgcHJvYmFiaWxpdHkgbWFzcyBhcmUgY29uc2lkZXJlZC5cbiAgICpcbiAgICogV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIHRlbXBlcmF0dXJlIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRvcF9wPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIHRydW5jYXRpb25fc3RyYXRlZ3k/OiBSdW5DcmVhdGVBbmRQb2xsUGFyYW1zLlRydW5jYXRpb25TdHJhdGVneSB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuQ3JlYXRlQW5kUG9sbFBhcmFtcyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQWRkaXRpb25hbE1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PE1lc3NhZ2VzQVBJLk1lc3NhZ2VDb250ZW50UGFydFBhcmFtPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSByb2xlIG9mIHRoZSBlbnRpdHkgdGhhdCBpcyBjcmVhdGluZyB0aGUgbWVzc2FnZS4gQWxsb3dlZCB2YWx1ZXMgaW5jbHVkZTpcbiAgICAgKlxuICAgICAqIC0gYHVzZXJgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgc2VudCBieSBhbiBhY3R1YWwgdXNlciBhbmQgc2hvdWxkIGJlIHVzZWQgaW5cbiAgICAgKiAgIG1vc3QgY2FzZXMgdG8gcmVwcmVzZW50IHVzZXItZ2VuZXJhdGVkIG1lc3NhZ2VzLlxuICAgICAqIC0gYGFzc2lzdGFudGA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBnZW5lcmF0ZWQgYnkgdGhlIGFzc2lzdGFudC4gVXNlIHRoaXNcbiAgICAgKiAgIHZhbHVlIHRvIGluc2VydCBtZXNzYWdlcyBmcm9tIHRoZSBhc3Npc3RhbnQgaW50byB0aGUgY29udmVyc2F0aW9uLlxuICAgICAqL1xuICAgIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xuXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIHRoZSBtZXNzYWdlLCBhbmQgdGhlIHRvb2xzIHRoZXkgc2hvdWxkIGJlIGFkZGVkIHRvLlxuICAgICAqL1xuICAgIGF0dGFjaG1lbnRzPzogQXJyYXk8QWRkaXRpb25hbE1lc3NhZ2UuQXR0YWNobWVudD4gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAgICogY2hhcmFjdGVycyBsb25nLlxuICAgICAqL1xuICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIEFkZGl0aW9uYWxNZXNzYWdlIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIEF0dGFjaG1lbnQge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gYXR0YWNoIHRvIHRoZSBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkPzogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0b29scyB0byBhZGQgdGhpcyBmaWxlIHRvLlxuICAgICAgICovXG4gICAgICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEFzc2lzdGFudHNBUEkuRmlsZVNlYXJjaFRvb2w+O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUcnVuY2F0aW9uU3RyYXRlZ3kge1xuICAgIC8qKlxuICAgICAqIFRoZSB0cnVuY2F0aW9uIHN0cmF0ZWd5IHRvIHVzZSBmb3IgdGhlIHRocmVhZC4gVGhlIGRlZmF1bHQgaXMgYGF1dG9gLiBJZiBzZXQgdG9cbiAgICAgKiBgbGFzdF9tZXNzYWdlc2AsIHRoZSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgdG8gdGhlIG4gbW9zdCByZWNlbnQgbWVzc2FnZXMgaW5cbiAgICAgKiB0aGUgdGhyZWFkLiBXaGVuIHNldCB0byBgYXV0b2AsIG1lc3NhZ2VzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHRocmVhZCB3aWxsIGJlXG4gICAgICogZHJvcHBlZCB0byBmaXQgdGhlIGNvbnRleHQgbGVuZ3RoIG9mIHRoZSBtb2RlbCwgYG1heF9wcm9tcHRfdG9rZW5zYC5cbiAgICAgKi9cbiAgICB0eXBlOiAnYXV0bycgfCAnbGFzdF9tZXNzYWdlcyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGZyb20gdGhlIHRocmVhZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgY29udGV4dFxuICAgICAqIGZvciB0aGUgcnVuLlxuICAgICAqL1xuICAgIGxhc3RfbWVzc2FnZXM/OiBudW1iZXIgfCBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuQ3JlYXRlQW5kU3RyZWFtUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGVcbiAgICogW2Fzc2lzdGFudF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSB0byB1c2UgdG9cbiAgICogZXhlY3V0ZSB0aGlzIHJ1bi5cbiAgICovXG4gIGFzc2lzdGFudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBcHBlbmRzIGFkZGl0aW9uYWwgaW5zdHJ1Y3Rpb25zIGF0IHRoZSBlbmQgb2YgdGhlIGluc3RydWN0aW9ucyBmb3IgdGhlIHJ1bi4gVGhpc1xuICAgKiBpcyB1c2VmdWwgZm9yIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzIHdpdGhvdXQgb3ZlcnJpZGluZyBvdGhlclxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICBhZGRpdGlvbmFsX2luc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEFkZHMgYWRkaXRpb25hbCBtZXNzYWdlcyB0byB0aGUgdGhyZWFkIGJlZm9yZSBjcmVhdGluZyB0aGUgcnVuLlxuICAgKi9cbiAgYWRkaXRpb25hbF9tZXNzYWdlcz86IEFycmF5PFJ1bkNyZWF0ZUFuZFN0cmVhbVBhcmFtcy5BZGRpdGlvbmFsTWVzc2FnZT4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgdGhlXG4gICAqIFtpbnN0cnVjdGlvbnNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cy9jcmVhdGVBc3Npc3RhbnQpXG4gICAqIG9mIHRoZSBhc3Npc3RhbnQuIFRoaXMgaXMgdXNlZnVsIGZvciBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGVcbiAgICogcnVuLiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogY29tcGxldGlvbiB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC4gU2VlXG4gICAqIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfY29tcGxldGlvbl90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcHJvbXB0IHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgcnVuLlxuICAgKiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgcHJvbXB0IHRva2Vuc1xuICAgKiBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlIG51bWJlciBvZlxuICAgKiBwcm9tcHQgdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X3Byb21wdF90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFtNb2RlbF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tb2RlbHMpIHRvXG4gICAqIGJlIHVzZWQgdG8gZXhlY3V0ZSB0aGlzIHJ1bi4gSWYgYSB2YWx1ZSBpcyBwcm92aWRlZCBoZXJlLCBpdCB3aWxsIG92ZXJyaWRlIHRoZVxuICAgKiBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2lzdGFudC4gSWYgbm90LCB0aGUgbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgKiBhc3Npc3RhbnQgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgbW9kZWw/OlxuICAgIHwgKHN0cmluZyAmIHt9KVxuICAgIHwgJ2dwdC00bydcbiAgICB8ICdncHQtNG8tMjAyNC0wNS0xMydcbiAgICB8ICdncHQtNC10dXJibydcbiAgICB8ICdncHQtNC10dXJiby0yMDI0LTA0LTA5J1xuICAgIHwgJ2dwdC00LTAxMjUtcHJldmlldydcbiAgICB8ICdncHQtNC10dXJiby1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LTExMDYtcHJldmlldydcbiAgICB8ICdncHQtNC12aXNpb24tcHJldmlldydcbiAgICB8ICdncHQtNCdcbiAgICB8ICdncHQtNC0wMzE0J1xuICAgIHwgJ2dwdC00LTA2MTMnXG4gICAgfCAnZ3B0LTQtMzJrJ1xuICAgIHwgJ2dwdC00LTMyay0wMzE0J1xuICAgIHwgJ2dwdC00LTMyay0wNjEzJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8nXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xNmsnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0wNjEzJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTEwNidcbiAgICB8ICdncHQtMy41LXR1cmJvLTAxMjUnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xNmstMDYxMydcbiAgICB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAgICogW0dQVC00b10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzL2dwdC00byksXG4gICAqIFtHUFQtNCBUdXJib10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzL2dwdC00LXR1cmJvLWFuZC1ncHQtNCksXG4gICAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9vYmplY3RcIiB9YCBlbmFibGVzIEpTT04gbW9kZSwgd2hpY2ggZ3VhcmFudGVlcyB0aGVcbiAgICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gICAqXG4gICAqICoqSW1wb3J0YW50OioqIHdoZW4gdXNpbmcgSlNPTiBtb2RlLCB5b3UgKiptdXN0KiogYWxzbyBpbnN0cnVjdCB0aGUgbW9kZWwgdG9cbiAgICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICAgKiBnZW5lcmF0ZSBhbiB1bmVuZGluZyBzdHJlYW0gb2Ygd2hpdGVzcGFjZSB1bnRpbCB0aGUgZ2VuZXJhdGlvbiByZWFjaGVzIHRoZSB0b2tlblxuICAgKiBsaW1pdCwgcmVzdWx0aW5nIGluIGEgbG9uZy1ydW5uaW5nIGFuZCBzZWVtaW5nbHkgXCJzdHVja1wiIHJlcXVlc3QuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICAgKiBpbmRpY2F0ZXMgdGhlIGdlbmVyYXRpb24gZXhjZWVkZWQgYG1heF90b2tlbnNgIG9yIHRoZSBjb252ZXJzYXRpb24gZXhjZWVkZWQgdGhlXG4gICAqIG1heCBjb250ZXh0IGxlbmd0aC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86IFRocmVhZHNBUEkuQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgdG9vbCBpcyBjYWxsZWQgYnkgdGhlIG1vZGVsLiBgbm9uZWAgbWVhbnMgdGhlIG1vZGVsIHdpbGxcbiAgICogbm90IGNhbGwgYW55IHRvb2xzIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBpcyB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgKiBhbmQgbWVhbnMgdGhlIG1vZGVsIGNhbiBwaWNrIGJldHdlZW4gZ2VuZXJhdGluZyBhIG1lc3NhZ2Ugb3IgY2FsbGluZyBvbmUgb3IgbW9yZVxuICAgKiB0b29scy4gYHJlcXVpcmVkYCBtZWFucyB0aGUgbW9kZWwgbXVzdCBjYWxsIG9uZSBvciBtb3JlIHRvb2xzIGJlZm9yZSByZXNwb25kaW5nXG4gICAqIHRvIHRoZSB1c2VyLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciB0b29sIGxpa2UgYHtcInR5cGVcIjogXCJmaWxlX3NlYXJjaFwifWAgb3JcbiAgICogYHtcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifX1gIGZvcmNlcyB0aGUgbW9kZWwgdG9cbiAgICogY2FsbCB0aGF0IHRvb2wuXG4gICAqL1xuICB0b29sX2Nob2ljZT86IFRocmVhZHNBUEkuQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSB0b29scyB0aGUgYXNzaXN0YW50IGNhbiB1c2UgZm9yIHRoaXMgcnVuLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQXNzaXN0YW50VG9vbD4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICB0cnVuY2F0aW9uX3N0cmF0ZWd5PzogUnVuQ3JlYXRlQW5kU3RyZWFtUGFyYW1zLlRydW5jYXRpb25TdHJhdGVneSB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuQ3JlYXRlQW5kU3RyZWFtUGFyYW1zIHtcbiAgZXhwb3J0IGludGVyZmFjZSBBZGRpdGlvbmFsTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8TWVzc2FnZXNBUEkuTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJvbGUgb2YgdGhlIGVudGl0eSB0aGF0IGlzIGNyZWF0aW5nIHRoZSBtZXNzYWdlLiBBbGxvd2VkIHZhbHVlcyBpbmNsdWRlOlxuICAgICAqXG4gICAgICogLSBgdXNlcmA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBzZW50IGJ5IGFuIGFjdHVhbCB1c2VyIGFuZCBzaG91bGQgYmUgdXNlZCBpblxuICAgICAqICAgbW9zdCBjYXNlcyB0byByZXByZXNlbnQgdXNlci1nZW5lcmF0ZWQgbWVzc2FnZXMuXG4gICAgICogLSBgYXNzaXN0YW50YDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGdlbmVyYXRlZCBieSB0aGUgYXNzaXN0YW50LiBVc2UgdGhpc1xuICAgICAqICAgdmFsdWUgdG8gaW5zZXJ0IG1lc3NhZ2VzIGZyb20gdGhlIGFzc2lzdGFudCBpbnRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgZmlsZXMgYXR0YWNoZWQgdG8gdGhlIG1lc3NhZ2UsIGFuZCB0aGUgdG9vbHMgdGhleSBzaG91bGQgYmUgYWRkZWQgdG8uXG4gICAgICovXG4gICAgYXR0YWNobWVudHM/OiBBcnJheTxBZGRpdGlvbmFsTWVzc2FnZS5BdHRhY2htZW50PiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICovXG4gICAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgQWRkaXRpb25hbE1lc3NhZ2Uge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBhdHRhY2ggdG8gdGhlIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRvb2xzIHRvIGFkZCB0aGlzIGZpbGUgdG8uXG4gICAgICAgKi9cbiAgICAgIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXNzaXN0YW50c0FQSS5GaWxlU2VhcmNoVG9vbD47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRydW5jYXRpb25TdHJhdGVneSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRydW5jYXRpb24gc3RyYXRlZ3kgdG8gdXNlIGZvciB0aGUgdGhyZWFkLiBUaGUgZGVmYXVsdCBpcyBgYXV0b2AuIElmIHNldCB0b1xuICAgICAqIGBsYXN0X21lc3NhZ2VzYCwgdGhlIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCB0byB0aGUgbiBtb3N0IHJlY2VudCBtZXNzYWdlcyBpblxuICAgICAqIHRoZSB0aHJlYWQuIFdoZW4gc2V0IHRvIGBhdXRvYCwgbWVzc2FnZXMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdGhyZWFkIHdpbGwgYmVcbiAgICAgKiBkcm9wcGVkIHRvIGZpdCB0aGUgY29udGV4dCBsZW5ndGggb2YgdGhlIG1vZGVsLCBgbWF4X3Byb21wdF90b2tlbnNgLlxuICAgICAqL1xuICAgIHR5cGU6ICdhdXRvJyB8ICdsYXN0X21lc3NhZ2VzJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbW9zdCByZWNlbnQgbWVzc2FnZXMgZnJvbSB0aGUgdGhyZWFkIHdoZW4gY29uc3RydWN0aW5nIHRoZSBjb250ZXh0XG4gICAgICogZm9yIHRoZSBydW4uXG4gICAgICovXG4gICAgbGFzdF9tZXNzYWdlcz86IG51bWJlciB8IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSdW5TdHJlYW1QYXJhbXMge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIHRvIHVzZSB0b1xuICAgKiBleGVjdXRlIHRoaXMgcnVuLlxuICAgKi9cbiAgYXNzaXN0YW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgYWRkaXRpb25hbCBpbnN0cnVjdGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgaW5zdHJ1Y3Rpb25zIGZvciB0aGUgcnVuLiBUaGlzXG4gICAqIGlzIHVzZWZ1bCBmb3IgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMgd2l0aG91dCBvdmVycmlkaW5nIG90aGVyXG4gICAqIGluc3RydWN0aW9ucy5cbiAgICovXG4gIGFkZGl0aW9uYWxfaW5zdHJ1Y3Rpb25zPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogQWRkcyBhZGRpdGlvbmFsIG1lc3NhZ2VzIHRvIHRoZSB0aHJlYWQgYmVmb3JlIGNyZWF0aW5nIHRoZSBydW4uXG4gICAqL1xuICBhZGRpdGlvbmFsX21lc3NhZ2VzPzogQXJyYXk8UnVuU3RyZWFtUGFyYW1zLkFkZGl0aW9uYWxNZXNzYWdlPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyB0aGVcbiAgICogW2luc3RydWN0aW9uc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzL2NyZWF0ZUFzc2lzdGFudClcbiAgICogb2YgdGhlIGFzc2lzdGFudC4gVGhpcyBpcyB1c2VmdWwgZm9yIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zIHRoYXQgbWF5IGJlIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZVxuICAgKiBydW4uIFRoZSBydW4gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdXNlIG9ubHkgdGhlIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2Vuc1xuICAgKiBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlIG51bWJlciBvZlxuICAgKiBjb21wbGV0aW9uIHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLiBTZWVcbiAgICogYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9jb21wbGV0aW9uX3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zIHRoYXQgbWF5IGJlIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBydW4uXG4gICAqIFRoZSBydW4gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdXNlIG9ubHkgdGhlIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zXG4gICAqIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGUgbnVtYmVyIG9mXG4gICAqIHByb21wdCB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC4gU2VlXG4gICAqIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfcHJvbXB0X3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgW01vZGVsXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscykgdG9cbiAgICogYmUgdXNlZCB0byBleGVjdXRlIHRoaXMgcnVuLiBJZiBhIHZhbHVlIGlzIHByb3ZpZGVkIGhlcmUsIGl0IHdpbGwgb3ZlcnJpZGUgdGhlXG4gICAqIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzaXN0YW50LiBJZiBub3QsIHRoZSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAqIGFzc2lzdGFudCB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICBtb2RlbD86XG4gICAgfCAoc3RyaW5nICYge30pXG4gICAgfCAnZ3B0LTRvJ1xuICAgIHwgJ2dwdC00by0yMDI0LTA1LTEzJ1xuICAgIHwgJ2dwdC00LXR1cmJvJ1xuICAgIHwgJ2dwdC00LXR1cmJvLTIwMjQtMDQtMDknXG4gICAgfCAnZ3B0LTQtMDEyNS1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LXR1cmJvLXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtMTEwNi1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LXZpc2lvbi1wcmV2aWV3J1xuICAgIHwgJ2dwdC00J1xuICAgIHwgJ2dwdC00LTAzMTQnXG4gICAgfCAnZ3B0LTQtMDYxMydcbiAgICB8ICdncHQtNC0zMmsnXG4gICAgfCAnZ3B0LTQtMzJrLTAzMTQnXG4gICAgfCAnZ3B0LTQtMzJrLTA2MTMnXG4gICAgfCAnZ3B0LTMuNS10dXJibydcbiAgICB8ICdncHQtMy41LXR1cmJvLTE2aydcbiAgICB8ICdncHQtMy41LXR1cmJvLTA2MTMnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xMTA2J1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMDEyNSdcbiAgICB8ICdncHQtMy41LXR1cmJvLTE2ay0wNjEzJ1xuICAgIHwgbnVsbDtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBmb3JtYXQgdGhhdCB0aGUgbW9kZWwgbXVzdCBvdXRwdXQuIENvbXBhdGlibGUgd2l0aFxuICAgKiBbR1BULTRvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMvZ3B0LTRvKSxcbiAgICogW0dQVC00IFR1cmJvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMvZ3B0LTQtdHVyYm8tYW5kLWdwdC00KSxcbiAgICogYW5kIGFsbCBHUFQtMy41IFR1cmJvIG1vZGVscyBzaW5jZSBgZ3B0LTMuNS10dXJiby0xMTA2YC5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBndWFyYW50ZWVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogVGhyZWFkc0FQSS5Bc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoYXQgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdG8gdXNlLCBiZXR3ZWVuIDAgYW5kIDIuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbFxuICAgKiBtYWtlIHRoZSBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZVxuICAgKiBmb2N1c2VkIGFuZCBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyB3aGljaCAoaWYgYW55KSB0b29sIGlzIGNhbGxlZCBieSB0aGUgbW9kZWwuIGBub25lYCBtZWFucyB0aGUgbW9kZWwgd2lsbFxuICAgKiBub3QgY2FsbCBhbnkgdG9vbHMgYW5kIGluc3RlYWQgZ2VuZXJhdGVzIGEgbWVzc2FnZS4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAqIGFuZCBtZWFucyB0aGUgbW9kZWwgY2FuIHBpY2sgYmV0d2VlbiBnZW5lcmF0aW5nIGEgbWVzc2FnZSBvciBjYWxsaW5nIG9uZSBvciBtb3JlXG4gICAqIHRvb2xzLiBgcmVxdWlyZWRgIG1lYW5zIHRoZSBtb2RlbCBtdXN0IGNhbGwgb25lIG9yIG1vcmUgdG9vbHMgYmVmb3JlIHJlc3BvbmRpbmdcbiAgICogdG8gdGhlIHVzZXIuIFNwZWNpZnlpbmcgYSBwYXJ0aWN1bGFyIHRvb2wgbGlrZSBge1widHlwZVwiOiBcImZpbGVfc2VhcmNoXCJ9YCBvclxuICAgKiBge1widHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIm15X2Z1bmN0aW9uXCJ9fWAgZm9yY2VzIHRoZSBtb2RlbCB0b1xuICAgKiBjYWxsIHRoYXQgdG9vbC5cbiAgICovXG4gIHRvb2xfY2hvaWNlPzogVGhyZWFkc0FQSS5Bc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHRvb2xzIHRoZSBhc3Npc3RhbnQgY2FuIHVzZSBmb3IgdGhpcyBydW4uIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRUb29sPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEFuIGFsdGVybmF0aXZlIHRvIHNhbXBsaW5nIHdpdGggdGVtcGVyYXR1cmUsIGNhbGxlZCBudWNsZXVzIHNhbXBsaW5nLCB3aGVyZSB0aGVcbiAgICogbW9kZWwgY29uc2lkZXJzIHRoZSByZXN1bHRzIG9mIHRoZSB0b2tlbnMgd2l0aCB0b3BfcCBwcm9iYWJpbGl0eSBtYXNzLiBTbyAwLjFcbiAgICogbWVhbnMgb25seSB0aGUgdG9rZW5zIGNvbXByaXNpbmcgdGhlIHRvcCAxMCUgcHJvYmFiaWxpdHkgbWFzcyBhcmUgY29uc2lkZXJlZC5cbiAgICpcbiAgICogV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIHRlbXBlcmF0dXJlIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRvcF9wPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIHRydW5jYXRpb25fc3RyYXRlZ3k/OiBSdW5TdHJlYW1QYXJhbXMuVHJ1bmNhdGlvblN0cmF0ZWd5IHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSdW5TdHJlYW1QYXJhbXMge1xuICBleHBvcnQgaW50ZXJmYWNlIEFkZGl0aW9uYWxNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCBjb250ZW50cyBvZiB0aGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxNZXNzYWdlc0FQSS5NZXNzYWdlQ29udGVudFBhcnRQYXJhbT47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm9sZSBvZiB0aGUgZW50aXR5IHRoYXQgaXMgY3JlYXRpbmcgdGhlIG1lc3NhZ2UuIEFsbG93ZWQgdmFsdWVzIGluY2x1ZGU6XG4gICAgICpcbiAgICAgKiAtIGB1c2VyYDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIHNlbnQgYnkgYW4gYWN0dWFsIHVzZXIgYW5kIHNob3VsZCBiZSB1c2VkIGluXG4gICAgICogICBtb3N0IGNhc2VzIHRvIHJlcHJlc2VudCB1c2VyLWdlbmVyYXRlZCBtZXNzYWdlcy5cbiAgICAgKiAtIGBhc3Npc3RhbnRgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBhc3Npc3RhbnQuIFVzZSB0aGlzXG4gICAgICogICB2YWx1ZSB0byBpbnNlcnQgbWVzc2FnZXMgZnJvbSB0aGUgYXNzaXN0YW50IGludG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgKi9cbiAgICByb2xlOiAndXNlcicgfCAnYXNzaXN0YW50JztcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byB0aGUgbWVzc2FnZSwgYW5kIHRoZSB0b29scyB0aGV5IHNob3VsZCBiZSBhZGRlZCB0by5cbiAgICAgKi9cbiAgICBhdHRhY2htZW50cz86IEFycmF5PEFkZGl0aW9uYWxNZXNzYWdlLkF0dGFjaG1lbnQ+IHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgKi9cbiAgICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBBZGRpdGlvbmFsTWVzc2FnZSB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBBdHRhY2htZW50IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIElEIG9mIHRoZSBmaWxlIHRvIGF0dGFjaCB0byB0aGUgbWVzc2FnZS5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZD86IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdG9vbHMgdG8gYWRkIHRoaXMgZmlsZSB0by5cbiAgICAgICAqL1xuICAgICAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkNvZGVJbnRlcnByZXRlclRvb2wgfCBBc3Npc3RhbnRzQVBJLkZpbGVTZWFyY2hUb29sPjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVHJ1bmNhdGlvblN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJ1bmNhdGlvbiBzdHJhdGVneSB0byB1c2UgZm9yIHRoZSB0aHJlYWQuIFRoZSBkZWZhdWx0IGlzIGBhdXRvYC4gSWYgc2V0IHRvXG4gICAgICogYGxhc3RfbWVzc2FnZXNgLCB0aGUgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHRvIHRoZSBuIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGluXG4gICAgICogdGhlIHRocmVhZC4gV2hlbiBzZXQgdG8gYGF1dG9gLCBtZXNzYWdlcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSB0aHJlYWQgd2lsbCBiZVxuICAgICAqIGRyb3BwZWQgdG8gZml0IHRoZSBjb250ZXh0IGxlbmd0aCBvZiB0aGUgbW9kZWwsIGBtYXhfcHJvbXB0X3Rva2Vuc2AuXG4gICAgICovXG4gICAgdHlwZTogJ2F1dG8nIHwgJ2xhc3RfbWVzc2FnZXMnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtb3N0IHJlY2VudCBtZXNzYWdlcyBmcm9tIHRoZSB0aHJlYWQgd2hlbiBjb25zdHJ1Y3RpbmcgdGhlIGNvbnRleHRcbiAgICAgKiBmb3IgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBsYXN0X21lc3NhZ2VzPzogbnVtYmVyIHwgbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtcyA9XG4gIHwgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNOb25TdHJlYW1pbmdcbiAgfCBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbWluZztcblxuZXhwb3J0IGludGVyZmFjZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogQSBsaXN0IG9mIHRvb2xzIGZvciB3aGljaCB0aGUgb3V0cHV0cyBhcmUgYmVpbmcgc3VibWl0dGVkLlxuICAgKi9cbiAgdG9vbF9vdXRwdXRzOiBBcnJheTxSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtcy5Ub29sT3V0cHV0PjtcblxuICAvKipcbiAgICogSWYgYHRydWVgLCByZXR1cm5zIGEgc3RyZWFtIG9mIGV2ZW50cyB0aGF0IGhhcHBlbiBkdXJpbmcgdGhlIFJ1biBhcyBzZXJ2ZXItc2VudFxuICAgKiBldmVudHMsIHRlcm1pbmF0aW5nIHdoZW4gdGhlIFJ1biBlbnRlcnMgYSB0ZXJtaW5hbCBzdGF0ZSB3aXRoIGEgYGRhdGE6IFtET05FXWBcbiAgICogbWVzc2FnZS5cbiAgICovXG4gIHN0cmVhbT86IGJvb2xlYW4gfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zIHtcbiAgZXhwb3J0IGludGVyZmFjZSBUb29sT3V0cHV0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0IG9mIHRoZSB0b29sIGNhbGwgdG8gYmUgc3VibWl0dGVkIHRvIGNvbnRpbnVlIHRoZSBydW4uXG4gICAgICovXG4gICAgb3V0cHV0Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwgaW4gdGhlIGByZXF1aXJlZF9hY3Rpb25gIG9iamVjdCB3aXRoaW4gdGhlIHJ1biBvYmplY3RcbiAgICAgKiB0aGUgb3V0cHV0IGlzIGJlaW5nIHN1Ym1pdHRlZCBmb3IuXG4gICAgICovXG4gICAgdG9vbF9jYWxsX2lkPzogc3RyaW5nO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNOb25TdHJlYW1pbmcgPSBSdW5zQVBJLlJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nO1xuICBleHBvcnQgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbWluZyA9IFJ1bnNBUEkuUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNOb25TdHJlYW1pbmcgZXh0ZW5kcyBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogSWYgYHRydWVgLCByZXR1cm5zIGEgc3RyZWFtIG9mIGV2ZW50cyB0aGF0IGhhcHBlbiBkdXJpbmcgdGhlIFJ1biBhcyBzZXJ2ZXItc2VudFxuICAgKiBldmVudHMsIHRlcm1pbmF0aW5nIHdoZW4gdGhlIFJ1biBlbnRlcnMgYSB0ZXJtaW5hbCBzdGF0ZSB3aXRoIGEgYGRhdGE6IFtET05FXWBcbiAgICogbWVzc2FnZS5cbiAgICovXG4gIHN0cmVhbT86IGZhbHNlIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbWluZyBleHRlbmRzIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHJldHVybnMgYSBzdHJlYW0gb2YgZXZlbnRzIHRoYXQgaGFwcGVuIGR1cmluZyB0aGUgUnVuIGFzIHNlcnZlci1zZW50XG4gICAqIGV2ZW50cywgdGVybWluYXRpbmcgd2hlbiB0aGUgUnVuIGVudGVycyBhIHRlcm1pbmFsIHN0YXRlIHdpdGggYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKi9cbiAgc3RyZWFtOiB0cnVlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzQW5kUG9sbFBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdG9vbHMgZm9yIHdoaWNoIHRoZSBvdXRwdXRzIGFyZSBiZWluZyBzdWJtaXR0ZWQuXG4gICAqL1xuICB0b29sX291dHB1dHM6IEFycmF5PFJ1blN1Ym1pdFRvb2xPdXRwdXRzQW5kUG9sbFBhcmFtcy5Ub29sT3V0cHV0Pjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSdW5TdWJtaXRUb29sT3V0cHV0c0FuZFBvbGxQYXJhbXMge1xuICBleHBvcnQgaW50ZXJmYWNlIFRvb2xPdXRwdXQge1xuICAgIC8qKlxuICAgICAqIFRoZSBvdXRwdXQgb2YgdGhlIHRvb2wgY2FsbCB0byBiZSBzdWJtaXR0ZWQgdG8gY29udGludWUgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBvdXRwdXQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbCBpbiB0aGUgYHJlcXVpcmVkX2FjdGlvbmAgb2JqZWN0IHdpdGhpbiB0aGUgcnVuIG9iamVjdFxuICAgICAqIHRoZSBvdXRwdXQgaXMgYmVpbmcgc3VibWl0dGVkIGZvci5cbiAgICAgKi9cbiAgICB0b29sX2NhbGxfaWQ/OiBzdHJpbmc7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSdW5TdWJtaXRUb29sT3V0cHV0c1N0cmVhbVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdG9vbHMgZm9yIHdoaWNoIHRoZSBvdXRwdXRzIGFyZSBiZWluZyBzdWJtaXR0ZWQuXG4gICAqL1xuICB0b29sX291dHB1dHM6IEFycmF5PFJ1blN1Ym1pdFRvb2xPdXRwdXRzU3RyZWFtUGFyYW1zLlRvb2xPdXRwdXQ+O1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzU3RyZWFtUGFyYW1zIHtcbiAgZXhwb3J0IGludGVyZmFjZSBUb29sT3V0cHV0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0IG9mIHRoZSB0b29sIGNhbGwgdG8gYmUgc3VibWl0dGVkIHRvIGNvbnRpbnVlIHRoZSBydW4uXG4gICAgICovXG4gICAgb3V0cHV0Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwgaW4gdGhlIGByZXF1aXJlZF9hY3Rpb25gIG9iamVjdCB3aXRoaW4gdGhlIHJ1biBvYmplY3RcbiAgICAgKiB0aGUgb3V0cHV0IGlzIGJlaW5nIHN1Ym1pdHRlZCBmb3IuXG4gICAgICovXG4gICAgdG9vbF9jYWxsX2lkPzogc3RyaW5nO1xuICB9XG59XG5cblJ1bnMuUnVuc1BhZ2UgPSBSdW5zUGFnZTtcblJ1bnMuU3RlcHMgPSBTdGVwcztcblJ1bnMuUnVuU3RlcHNQYWdlID0gUnVuU3RlcHNQYWdlO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgUnVucyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBSZXF1aXJlZEFjdGlvbkZ1bmN0aW9uVG9vbENhbGwgYXMgUmVxdWlyZWRBY3Rpb25GdW5jdGlvblRvb2xDYWxsLFxuICAgIHR5cGUgUnVuIGFzIFJ1bixcbiAgICB0eXBlIFJ1blN0YXR1cyBhcyBSdW5TdGF0dXMsXG4gICAgUnVuc1BhZ2UgYXMgUnVuc1BhZ2UsXG4gICAgdHlwZSBSdW5DcmVhdGVQYXJhbXMgYXMgUnVuQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgUnVuQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGFzIFJ1bkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIFJ1bkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBhcyBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gICAgdHlwZSBSdW5VcGRhdGVQYXJhbXMgYXMgUnVuVXBkYXRlUGFyYW1zLFxuICAgIHR5cGUgUnVuTGlzdFBhcmFtcyBhcyBSdW5MaXN0UGFyYW1zLFxuICAgIHR5cGUgUnVuQ3JlYXRlQW5kUG9sbFBhcmFtcyxcbiAgICB0eXBlIFJ1bkNyZWF0ZUFuZFN0cmVhbVBhcmFtcyxcbiAgICB0eXBlIFJ1blN0cmVhbVBhcmFtcyxcbiAgICB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zIGFzIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zLFxuICAgIHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNOb25TdHJlYW1pbmcgYXMgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbWluZyBhcyBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbWluZyxcbiAgICB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzQW5kUG9sbFBhcmFtcyxcbiAgICB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzU3RyZWFtUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgU3RlcHMgYXMgU3RlcHMsXG4gICAgdHlwZSBDb2RlSW50ZXJwcmV0ZXJMb2dzIGFzIENvZGVJbnRlcnByZXRlckxvZ3MsXG4gICAgdHlwZSBDb2RlSW50ZXJwcmV0ZXJPdXRwdXRJbWFnZSBhcyBDb2RlSW50ZXJwcmV0ZXJPdXRwdXRJbWFnZSxcbiAgICB0eXBlIENvZGVJbnRlcnByZXRlclRvb2xDYWxsIGFzIENvZGVJbnRlcnByZXRlclRvb2xDYWxsLFxuICAgIHR5cGUgQ29kZUludGVycHJldGVyVG9vbENhbGxEZWx0YSBhcyBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbERlbHRhLFxuICAgIHR5cGUgRmlsZVNlYXJjaFRvb2xDYWxsIGFzIEZpbGVTZWFyY2hUb29sQ2FsbCxcbiAgICB0eXBlIEZpbGVTZWFyY2hUb29sQ2FsbERlbHRhIGFzIEZpbGVTZWFyY2hUb29sQ2FsbERlbHRhLFxuICAgIHR5cGUgRnVuY3Rpb25Ub29sQ2FsbCBhcyBGdW5jdGlvblRvb2xDYWxsLFxuICAgIHR5cGUgRnVuY3Rpb25Ub29sQ2FsbERlbHRhIGFzIEZ1bmN0aW9uVG9vbENhbGxEZWx0YSxcbiAgICB0eXBlIE1lc3NhZ2VDcmVhdGlvblN0ZXBEZXRhaWxzIGFzIE1lc3NhZ2VDcmVhdGlvblN0ZXBEZXRhaWxzLFxuICAgIHR5cGUgUnVuU3RlcCBhcyBSdW5TdGVwLFxuICAgIHR5cGUgUnVuU3RlcERlbHRhIGFzIFJ1blN0ZXBEZWx0YSxcbiAgICB0eXBlIFJ1blN0ZXBEZWx0YUV2ZW50IGFzIFJ1blN0ZXBEZWx0YUV2ZW50LFxuICAgIHR5cGUgUnVuU3RlcERlbHRhTWVzc2FnZURlbHRhIGFzIFJ1blN0ZXBEZWx0YU1lc3NhZ2VEZWx0YSxcbiAgICB0eXBlIFJ1blN0ZXBJbmNsdWRlIGFzIFJ1blN0ZXBJbmNsdWRlLFxuICAgIHR5cGUgVG9vbENhbGwgYXMgVG9vbENhbGwsXG4gICAgdHlwZSBUb29sQ2FsbERlbHRhIGFzIFRvb2xDYWxsRGVsdGEsXG4gICAgdHlwZSBUb29sQ2FsbERlbHRhT2JqZWN0IGFzIFRvb2xDYWxsRGVsdGFPYmplY3QsXG4gICAgdHlwZSBUb29sQ2FsbHNTdGVwRGV0YWlscyBhcyBUb29sQ2FsbHNTdGVwRGV0YWlscyxcbiAgICBSdW5TdGVwc1BhZ2UgYXMgUnVuU3RlcHNQYWdlLFxuICAgIHR5cGUgU3RlcFJldHJpZXZlUGFyYW1zIGFzIFN0ZXBSZXRyaWV2ZVBhcmFtcyxcbiAgICB0eXBlIFN0ZXBMaXN0UGFyYW1zIGFzIFN0ZXBMaXN0UGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0IHsgQXNzaXN0YW50U3RyZWFtLCBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlU3RyZWFtIH0gZnJvbSAnLi4vLi4vLi4vbGliL0Fzc2lzdGFudFN0cmVhbSc7XG5pbXBvcnQgeyBBUElQcm9taXNlIH0gZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgVGhyZWFkc0FQSSBmcm9tICcuL3RocmVhZHMnO1xuaW1wb3J0ICogYXMgU2hhcmVkIGZyb20gJy4uLy4uL3NoYXJlZCc7XG5pbXBvcnQgKiBhcyBBc3Npc3RhbnRzQVBJIGZyb20gJy4uL2Fzc2lzdGFudHMnO1xuaW1wb3J0ICogYXMgQ2hhdEFQSSBmcm9tICcuLi8uLi9jaGF0L2NoYXQnO1xuaW1wb3J0ICogYXMgTWVzc2FnZXNBUEkgZnJvbSAnLi9tZXNzYWdlcyc7XG5pbXBvcnQge1xuICBBbm5vdGF0aW9uLFxuICBBbm5vdGF0aW9uRGVsdGEsXG4gIEZpbGVDaXRhdGlvbkFubm90YXRpb24sXG4gIEZpbGVDaXRhdGlvbkRlbHRhQW5ub3RhdGlvbixcbiAgRmlsZVBhdGhBbm5vdGF0aW9uLFxuICBGaWxlUGF0aERlbHRhQW5ub3RhdGlvbixcbiAgSW1hZ2VGaWxlLFxuICBJbWFnZUZpbGVDb250ZW50QmxvY2ssXG4gIEltYWdlRmlsZURlbHRhLFxuICBJbWFnZUZpbGVEZWx0YUJsb2NrLFxuICBJbWFnZVVSTCxcbiAgSW1hZ2VVUkxDb250ZW50QmxvY2ssXG4gIEltYWdlVVJMRGVsdGEsXG4gIEltYWdlVVJMRGVsdGFCbG9jayxcbiAgTWVzc2FnZSBhcyBNZXNzYWdlc0FQSU1lc3NhZ2UsXG4gIE1lc3NhZ2VDb250ZW50LFxuICBNZXNzYWdlQ29udGVudERlbHRhLFxuICBNZXNzYWdlQ29udGVudFBhcnRQYXJhbSxcbiAgTWVzc2FnZUNyZWF0ZVBhcmFtcyxcbiAgTWVzc2FnZURlbGV0ZWQsXG4gIE1lc3NhZ2VEZWx0YSxcbiAgTWVzc2FnZURlbHRhRXZlbnQsXG4gIE1lc3NhZ2VMaXN0UGFyYW1zLFxuICBNZXNzYWdlVXBkYXRlUGFyYW1zLFxuICBNZXNzYWdlcyxcbiAgTWVzc2FnZXNQYWdlLFxuICBSZWZ1c2FsQ29udGVudEJsb2NrLFxuICBSZWZ1c2FsRGVsdGFCbG9jayxcbiAgVGV4dCxcbiAgVGV4dENvbnRlbnRCbG9jayxcbiAgVGV4dENvbnRlbnRCbG9ja1BhcmFtLFxuICBUZXh0RGVsdGEsXG4gIFRleHREZWx0YUJsb2NrLFxufSBmcm9tICcuL21lc3NhZ2VzJztcbmltcG9ydCAqIGFzIFZlY3RvclN0b3Jlc0FQSSBmcm9tICcuLi92ZWN0b3Itc3RvcmVzL3ZlY3Rvci1zdG9yZXMnO1xuaW1wb3J0ICogYXMgUnVuc0FQSSBmcm9tICcuL3J1bnMvcnVucyc7XG5pbXBvcnQge1xuICBSZXF1aXJlZEFjdGlvbkZ1bmN0aW9uVG9vbENhbGwsXG4gIFJ1bixcbiAgUnVuQ3JlYXRlQW5kUG9sbFBhcmFtcyxcbiAgUnVuQ3JlYXRlQW5kU3RyZWFtUGFyYW1zLFxuICBSdW5DcmVhdGVQYXJhbXMsXG4gIFJ1bkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICBSdW5MaXN0UGFyYW1zLFxuICBSdW5TdGF0dXMsXG4gIFJ1blN0cmVhbVBhcmFtcyxcbiAgUnVuU3VibWl0VG9vbE91dHB1dHNBbmRQb2xsUGFyYW1zLFxuICBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtcyxcbiAgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNOb25TdHJlYW1pbmcsXG4gIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtaW5nLFxuICBSdW5TdWJtaXRUb29sT3V0cHV0c1N0cmVhbVBhcmFtcyxcbiAgUnVuVXBkYXRlUGFyYW1zLFxuICBSdW5zLFxuICBSdW5zUGFnZSxcbn0gZnJvbSAnLi9ydW5zL3J1bnMnO1xuaW1wb3J0IHsgU3RyZWFtIH0gZnJvbSAnLi4vLi4vLi4vc3RyZWFtaW5nJztcblxuZXhwb3J0IGNsYXNzIFRocmVhZHMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIHJ1bnM6IFJ1bnNBUEkuUnVucyA9IG5ldyBSdW5zQVBJLlJ1bnModGhpcy5fY2xpZW50KTtcbiAgbWVzc2FnZXM6IE1lc3NhZ2VzQVBJLk1lc3NhZ2VzID0gbmV3IE1lc3NhZ2VzQVBJLk1lc3NhZ2VzKHRoaXMuX2NsaWVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRocmVhZC5cbiAgICovXG4gIGNyZWF0ZShib2R5PzogVGhyZWFkQ3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxUaHJlYWQ+O1xuICBjcmVhdGUob3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8VGhyZWFkPjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IFRocmVhZENyZWF0ZVBhcmFtcyB8IENvcmUuUmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFRocmVhZD4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKGJvZHkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGUoe30sIGJvZHkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy90aHJlYWRzJywge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIHRocmVhZC5cbiAgICovXG4gIHJldHJpZXZlKHRocmVhZElkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFRocmVhZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvdGhyZWFkcy8ke3RocmVhZElkfWAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIGEgdGhyZWFkLlxuICAgKi9cbiAgdXBkYXRlKHRocmVhZElkOiBzdHJpbmcsIGJvZHk6IFRocmVhZFVwZGF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8VGhyZWFkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdGhyZWFkcy8ke3RocmVhZElkfWAsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSB0aHJlYWQuXG4gICAqL1xuICBkZWwodGhyZWFkSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8VGhyZWFkRGVsZXRlZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZGVsZXRlKGAvdGhyZWFkcy8ke3RocmVhZElkfWAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRocmVhZCBhbmQgcnVuIGl0IGluIG9uZSByZXF1ZXN0LlxuICAgKi9cbiAgY3JlYXRlQW5kUnVuKFxuICAgIGJvZHk6IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc05vblN0cmVhbWluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxSdW5zQVBJLlJ1bj47XG4gIGNyZWF0ZUFuZFJ1bihcbiAgICBib2R5OiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNTdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8U3RyZWFtPEFzc2lzdGFudHNBUEkuQXNzaXN0YW50U3RyZWFtRXZlbnQ+PjtcbiAgY3JlYXRlQW5kUnVuKFxuICAgIGJvZHk6IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc0Jhc2UsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8U3RyZWFtPEFzc2lzdGFudHNBUEkuQXNzaXN0YW50U3RyZWFtRXZlbnQ+IHwgUnVuc0FQSS5SdW4+O1xuICBjcmVhdGVBbmRSdW4oXG4gICAgYm9keTogVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFJ1bnNBUEkuUnVuPiB8IEFQSVByb21pc2U8U3RyZWFtPEFzc2lzdGFudHNBUEkuQXNzaXN0YW50U3RyZWFtRXZlbnQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvdGhyZWFkcy9ydW5zJywge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgc3RyZWFtOiBib2R5LnN0cmVhbSA/PyBmYWxzZSxcbiAgICB9KSBhcyBBUElQcm9taXNlPFJ1bnNBUEkuUnVuPiB8IEFQSVByb21pc2U8U3RyZWFtPEFzc2lzdGFudHNBUEkuQXNzaXN0YW50U3RyZWFtRXZlbnQ+PjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGhlbHBlciB0byBjcmVhdGUgYSB0aHJlYWQsIHN0YXJ0IGEgcnVuIGFuZCB0aGVuIHBvbGwgZm9yIGEgdGVybWluYWwgc3RhdGUuXG4gICAqIE1vcmUgaW5mb3JtYXRpb24gb24gUnVuIGxpZmVjeWNsZXMgY2FuIGJlIGZvdW5kIGhlcmU6XG4gICAqIGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvaG93LWl0LXdvcmtzL3J1bnMtYW5kLXJ1bi1zdGVwc1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlQW5kUnVuUG9sbChcbiAgICBib2R5OiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMgJiB7IHBvbGxJbnRlcnZhbE1zPzogbnVtYmVyIH0sXG4gICk6IFByb21pc2U8VGhyZWFkcy5SdW4+IHtcbiAgICBjb25zdCBydW4gPSBhd2FpdCB0aGlzLmNyZWF0ZUFuZFJ1bihib2R5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5ydW5zLnBvbGwocnVuLnRocmVhZF9pZCwgcnVuLmlkLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0aHJlYWQgYW5kIHN0cmVhbSB0aGUgcnVuIGJhY2tcbiAgICovXG4gIGNyZWF0ZUFuZFJ1blN0cmVhbShcbiAgICBib2R5OiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlU3RyZWFtLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBc3Npc3RhbnRTdHJlYW0ge1xuICAgIHJldHVybiBBc3Npc3RhbnRTdHJlYW0uY3JlYXRlVGhyZWFkQXNzaXN0YW50U3RyZWFtKGJvZHksIHRoaXMuX2NsaWVudC5iZXRhLnRocmVhZHMsIG9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBmb3JtYXQgdGhhdCB0aGUgbW9kZWwgbXVzdCBvdXRwdXQuIENvbXBhdGlibGUgd2l0aFxuICogW0dQVC00b10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00byksXG4gKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICogYW5kIGFsbCBHUFQtMy41IFR1cmJvIG1vZGVscyBzaW5jZSBgZ3B0LTMuNS10dXJiby0xMTA2YC5cbiAqXG4gKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fc2NoZW1hXCIsIFwianNvbl9zY2hlbWFcIjogey4uLn0gfWAgZW5hYmxlcyBTdHJ1Y3R1cmVkXG4gKiBPdXRwdXRzIHdoaWNoIGVuc3VyZXMgdGhlIG1vZGVsIHdpbGwgbWF0Y2ggeW91ciBzdXBwbGllZCBKU09OIHNjaGVtYS4gTGVhcm4gbW9yZVxuICogaW4gdGhlXG4gKiBbU3RydWN0dXJlZCBPdXRwdXRzIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc3RydWN0dXJlZC1vdXRwdXRzKS5cbiAqXG4gKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGVuc3VyZXMgdGhlXG4gKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAqXG4gKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gKiBnZW5lcmF0ZSBhbiB1bmVuZGluZyBzdHJlYW0gb2Ygd2hpdGVzcGFjZSB1bnRpbCB0aGUgZ2VuZXJhdGlvbiByZWFjaGVzIHRoZSB0b2tlblxuICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gKiBpbmRpY2F0ZXMgdGhlIGdlbmVyYXRpb24gZXhjZWVkZWQgYG1heF90b2tlbnNgIG9yIHRoZSBjb252ZXJzYXRpb24gZXhjZWVkZWQgdGhlXG4gKiBtYXggY29udGV4dCBsZW5ndGguXG4gKi9cbmV4cG9ydCB0eXBlIEFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uID1cbiAgfCAnYXV0bydcbiAgfCBTaGFyZWQuUmVzcG9uc2VGb3JtYXRUZXh0XG4gIHwgU2hhcmVkLlJlc3BvbnNlRm9ybWF0SlNPTk9iamVjdFxuICB8IFNoYXJlZC5SZXNwb25zZUZvcm1hdEpTT05TY2hlbWE7XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgdG9vbCB0aGUgbW9kZWwgc2hvdWxkIHVzZS4gVXNlIHRvIGZvcmNlIHRoZSBtb2RlbCB0byBjYWxsIGEgc3BlY2lmaWNcbiAqIHRvb2wuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXNzaXN0YW50VG9vbENob2ljZSB7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbC4gSWYgdHlwZSBpcyBgZnVuY3Rpb25gLCB0aGUgZnVuY3Rpb24gbmFtZSBtdXN0IGJlIHNldFxuICAgKi9cbiAgdHlwZTogJ2Z1bmN0aW9uJyB8ICdjb2RlX2ludGVycHJldGVyJyB8ICdmaWxlX3NlYXJjaCc7XG5cbiAgZnVuY3Rpb24/OiBBc3Npc3RhbnRUb29sQ2hvaWNlRnVuY3Rpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXNzaXN0YW50VG9vbENob2ljZUZ1bmN0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIENvbnRyb2xzIHdoaWNoIChpZiBhbnkpIHRvb2wgaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC4gYG5vbmVgIG1lYW5zIHRoZSBtb2RlbCB3aWxsXG4gKiBub3QgY2FsbCBhbnkgdG9vbHMgYW5kIGluc3RlYWQgZ2VuZXJhdGVzIGEgbWVzc2FnZS4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IHZhbHVlXG4gKiBhbmQgbWVhbnMgdGhlIG1vZGVsIGNhbiBwaWNrIGJldHdlZW4gZ2VuZXJhdGluZyBhIG1lc3NhZ2Ugb3IgY2FsbGluZyBvbmUgb3IgbW9yZVxuICogdG9vbHMuIGByZXF1aXJlZGAgbWVhbnMgdGhlIG1vZGVsIG11c3QgY2FsbCBvbmUgb3IgbW9yZSB0b29scyBiZWZvcmUgcmVzcG9uZGluZ1xuICogdG8gdGhlIHVzZXIuIFNwZWNpZnlpbmcgYSBwYXJ0aWN1bGFyIHRvb2wgbGlrZSBge1widHlwZVwiOiBcImZpbGVfc2VhcmNoXCJ9YCBvclxuICogYHtcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifX1gIGZvcmNlcyB0aGUgbW9kZWwgdG9cbiAqIGNhbGwgdGhhdCB0b29sLlxuICovXG5leHBvcnQgdHlwZSBBc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uID0gJ25vbmUnIHwgJ2F1dG8nIHwgJ3JlcXVpcmVkJyB8IEFzc2lzdGFudFRvb2xDaG9pY2U7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRocmVhZCB0aGF0IGNvbnRhaW5zXG4gKiBbbWVzc2FnZXNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMpLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRocmVhZCB7XG4gIC8qKlxuICAgKiBUaGUgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHRocmVhZCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE6IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgdGhyZWFkYC5cbiAgICovXG4gIG9iamVjdDogJ3RocmVhZCc7XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYXNzaXN0YW50J3MgdG9vbHMgaW4gdGhpc1xuICAgKiB0aHJlYWQuIFRoZSByZXNvdXJjZXMgYXJlIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGVcbiAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgKiB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgSURzLlxuICAgKi9cbiAgdG9vbF9yZXNvdXJjZXM6IFRocmVhZC5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBUaHJlYWQge1xuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBhc3Npc3RhbnQncyB0b29scyBpbiB0aGlzXG4gICAqIHRocmVhZC4gVGhlIHJlc291cmNlcyBhcmUgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZVxuICAgKiBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgXG4gICAqIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBJRHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGNvZGVfaW50ZXJwcmV0ZXI/OiBUb29sUmVzb3VyY2VzLkNvZGVJbnRlcnByZXRlcjtcblxuICAgIGZpbGVfc2VhcmNoPzogVG9vbFJlc291cmNlcy5GaWxlU2VhcmNoO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIG1hZGVcbiAgICAgICAqIGF2YWlsYWJsZSB0byB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMjAgZmlsZXNcbiAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9vbC5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZVxuICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgdGhyZWFkLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvXG4gICAgICAgKiB0aGUgdGhyZWFkLlxuICAgICAgICovXG4gICAgICB2ZWN0b3Jfc3RvcmVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaHJlYWREZWxldGVkIHtcbiAgaWQ6IHN0cmluZztcblxuICBkZWxldGVkOiBib29sZWFuO1xuXG4gIG9iamVjdDogJ3RocmVhZC5kZWxldGVkJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaHJlYWRDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogQSBsaXN0IG9mIFttZXNzYWdlc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcykgdG9cbiAgICogc3RhcnQgdGhlIHRocmVhZCB3aXRoLlxuICAgKi9cbiAgbWVzc2FnZXM/OiBBcnJheTxUaHJlYWRDcmVhdGVQYXJhbXMuTWVzc2FnZT47XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYXNzaXN0YW50J3MgdG9vbHMgaW4gdGhpc1xuICAgKiB0aHJlYWQuIFRoZSByZXNvdXJjZXMgYXJlIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGVcbiAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgKiB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgSURzLlxuICAgKi9cbiAgdG9vbF9yZXNvdXJjZXM/OiBUaHJlYWRDcmVhdGVQYXJhbXMuVG9vbFJlc291cmNlcyB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVGhyZWFkQ3JlYXRlUGFyYW1zIHtcbiAgZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCBjb250ZW50cyBvZiB0aGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxNZXNzYWdlc0FQSS5NZXNzYWdlQ29udGVudFBhcnRQYXJhbT47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm9sZSBvZiB0aGUgZW50aXR5IHRoYXQgaXMgY3JlYXRpbmcgdGhlIG1lc3NhZ2UuIEFsbG93ZWQgdmFsdWVzIGluY2x1ZGU6XG4gICAgICpcbiAgICAgKiAtIGB1c2VyYDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIHNlbnQgYnkgYW4gYWN0dWFsIHVzZXIgYW5kIHNob3VsZCBiZSB1c2VkIGluXG4gICAgICogICBtb3N0IGNhc2VzIHRvIHJlcHJlc2VudCB1c2VyLWdlbmVyYXRlZCBtZXNzYWdlcy5cbiAgICAgKiAtIGBhc3Npc3RhbnRgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBhc3Npc3RhbnQuIFVzZSB0aGlzXG4gICAgICogICB2YWx1ZSB0byBpbnNlcnQgbWVzc2FnZXMgZnJvbSB0aGUgYXNzaXN0YW50IGludG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgKi9cbiAgICByb2xlOiAndXNlcicgfCAnYXNzaXN0YW50JztcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byB0aGUgbWVzc2FnZSwgYW5kIHRoZSB0b29scyB0aGV5IHNob3VsZCBiZSBhZGRlZCB0by5cbiAgICAgKi9cbiAgICBhdHRhY2htZW50cz86IEFycmF5PE1lc3NhZ2UuQXR0YWNobWVudD4gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAgICogY2hhcmFjdGVycyBsb25nLlxuICAgICAqL1xuICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIE1lc3NhZ2Uge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBhdHRhY2ggdG8gdGhlIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRvb2xzIHRvIGFkZCB0aGlzIGZpbGUgdG8uXG4gICAgICAgKi9cbiAgICAgIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXR0YWNobWVudC5GaWxlU2VhcmNoPjtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIEF0dGFjaG1lbnQge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRvb2wgYmVpbmcgZGVmaW5lZDogYGZpbGVfc2VhcmNoYFxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2ZpbGVfc2VhcmNoJztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBhc3Npc3RhbnQncyB0b29scyBpbiB0aGlzXG4gICAqIHRocmVhZC4gVGhlIHJlc291cmNlcyBhcmUgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZVxuICAgKiBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgXG4gICAqIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBJRHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGNvZGVfaW50ZXJwcmV0ZXI/OiBUb29sUmVzb3VyY2VzLkNvZGVJbnRlcnByZXRlcjtcblxuICAgIGZpbGVfc2VhcmNoPzogVG9vbFJlc291cmNlcy5GaWxlU2VhcmNoO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIG1hZGVcbiAgICAgICAqIGF2YWlsYWJsZSB0byB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMjAgZmlsZXNcbiAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9vbC5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZVxuICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgdGhyZWFkLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvXG4gICAgICAgKiB0aGUgdGhyZWFkLlxuICAgICAgICovXG4gICAgICB2ZWN0b3Jfc3RvcmVfaWRzPzogQXJyYXk8c3RyaW5nPjtcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGhlbHBlciB0byBjcmVhdGUgYVxuICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAqIHdpdGggZmlsZV9pZHMgYW5kIGF0dGFjaCBpdCB0byB0aGlzIHRocmVhZC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvclxuICAgICAgICogc3RvcmUgYXR0YWNoZWQgdG8gdGhlIHRocmVhZC5cbiAgICAgICAqL1xuICAgICAgdmVjdG9yX3N0b3Jlcz86IEFycmF5PEZpbGVTZWFyY2guVmVjdG9yU3RvcmU+O1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgRmlsZVNlYXJjaCB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjaHVua2luZyBzdHJhdGVneSB1c2VkIHRvIGNodW5rIHRoZSBmaWxlKHMpLiBJZiBub3Qgc2V0LCB3aWxsIHVzZSB0aGUgYGF1dG9gXG4gICAgICAgICAqIHN0cmF0ZWd5LiBPbmx5IGFwcGxpY2FibGUgaWYgYGZpbGVfaWRzYCBpcyBub24tZW1wdHkuXG4gICAgICAgICAqL1xuICAgICAgICBjaHVua2luZ19zdHJhdGVneT86IFZlY3RvclN0b3Jlc0FQSS5GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyB0b1xuICAgICAgICAgKiBhZGQgdG8gdGhlIHZlY3RvciBzdG9yZS4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxMDAwMCBmaWxlcyBpbiBhIHZlY3RvclxuICAgICAgICAgKiBzdG9yZS5cbiAgICAgICAgICovXG4gICAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIHZlY3RvciBzdG9yZS4gVGhpcyBjYW4gYmVcbiAgICAgICAgICogdXNlZnVsIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZlY3RvciBzdG9yZSBpbiBhIHN0cnVjdHVyZWRcbiAgICAgICAgICogZm9ybWF0LiBLZXlzIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtXG4gICAgICAgICAqIG9mIDUxMiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICAgICAqL1xuICAgICAgICBtZXRhZGF0YT86IHVua25vd247XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkVXBkYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYXNzaXN0YW50J3MgdG9vbHMgaW4gdGhpc1xuICAgKiB0aHJlYWQuIFRoZSByZXNvdXJjZXMgYXJlIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGVcbiAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgKiB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgSURzLlxuICAgKi9cbiAgdG9vbF9yZXNvdXJjZXM/OiBUaHJlYWRVcGRhdGVQYXJhbXMuVG9vbFJlc291cmNlcyB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVGhyZWFkVXBkYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYXNzaXN0YW50J3MgdG9vbHMgaW4gdGhpc1xuICAgKiB0aHJlYWQuIFRoZSByZXNvdXJjZXMgYXJlIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGVcbiAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgKiB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgSURzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzXG4gICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2wuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGVcbiAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgKiBhdHRhY2hlZCB0byB0aGlzIHRocmVhZC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvciBzdG9yZSBhdHRhY2hlZCB0b1xuICAgICAgICogdGhlIHRocmVhZC5cbiAgICAgICAqL1xuICAgICAgdmVjdG9yX3N0b3JlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtcyA9XG4gIHwgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zTm9uU3RyZWFtaW5nXG4gIHwgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zU3RyZWFtaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIHRvIHVzZSB0b1xuICAgKiBleGVjdXRlIHRoaXMgcnVuLlxuICAgKi9cbiAgYXNzaXN0YW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHN5c3RlbSBtZXNzYWdlIG9mIHRoZSBhc3Npc3RhbnQuIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGVcbiAgICogcnVuLiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogY29tcGxldGlvbiB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC4gU2VlXG4gICAqIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfY29tcGxldGlvbl90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcHJvbXB0IHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgcnVuLlxuICAgKiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgcHJvbXB0IHRva2Vuc1xuICAgKiBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlIG51bWJlciBvZlxuICAgKiBwcm9tcHQgdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X3Byb21wdF90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFtNb2RlbF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tb2RlbHMpIHRvXG4gICAqIGJlIHVzZWQgdG8gZXhlY3V0ZSB0aGlzIHJ1bi4gSWYgYSB2YWx1ZSBpcyBwcm92aWRlZCBoZXJlLCBpdCB3aWxsIG92ZXJyaWRlIHRoZVxuICAgKiBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2lzdGFudC4gSWYgbm90LCB0aGUgbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgKiBhc3Npc3RhbnQgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgbW9kZWw/OiAoc3RyaW5nICYge30pIHwgQ2hhdEFQSS5DaGF0TW9kZWwgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZVxuICAgKiBbcGFyYWxsZWwgZnVuY3Rpb24gY2FsbGluZ10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2Z1bmN0aW9uLWNhbGxpbmcjY29uZmlndXJpbmctcGFyYWxsZWwtZnVuY3Rpb24tY2FsbGluZylcbiAgICogZHVyaW5nIHRvb2wgdXNlLlxuICAgKi9cbiAgcGFyYWxsZWxfdG9vbF9jYWxscz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAgICogW0dQVC00b10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00byksXG4gICAqIFtHUFQtNCBUdXJib10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00LXR1cmJvLWFuZC1ncHQtNCksXG4gICAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9zY2hlbWFcIiwgXCJqc29uX3NjaGVtYVwiOiB7Li4ufSB9YCBlbmFibGVzIFN0cnVjdHVyZWRcbiAgICogT3V0cHV0cyB3aGljaCBlbnN1cmVzIHRoZSBtb2RlbCB3aWxsIG1hdGNoIHlvdXIgc3VwcGxpZWQgSlNPTiBzY2hlbWEuIExlYXJuIG1vcmVcbiAgICogaW4gdGhlXG4gICAqIFtTdHJ1Y3R1cmVkIE91dHB1dHMgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zdHJ1Y3R1cmVkLW91dHB1dHMpLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGVuc3VyZXMgdGhlXG4gICAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICAgKlxuICAgKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gICAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAgICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAgICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAgICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICAgKiBtYXggY29udGV4dCBsZW5ndGguXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBBc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgcmV0dXJucyBhIHN0cmVhbSBvZiBldmVudHMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoZSBSdW4gYXMgc2VydmVyLXNlbnRcbiAgICogZXZlbnRzLCB0ZXJtaW5hdGluZyB3aGVuIHRoZSBSdW4gZW50ZXJzIGEgdGVybWluYWwgc3RhdGUgd2l0aCBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqL1xuICBzdHJlYW0/OiBib29sZWFuIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIElmIG5vIHRocmVhZCBpcyBwcm92aWRlZCwgYW4gZW1wdHkgdGhyZWFkIHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIHRocmVhZD86IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtcy5UaHJlYWQ7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIHdoaWNoIChpZiBhbnkpIHRvb2wgaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC4gYG5vbmVgIG1lYW5zIHRoZSBtb2RlbCB3aWxsXG4gICAqIG5vdCBjYWxsIGFueSB0b29scyBhbmQgaW5zdGVhZCBnZW5lcmF0ZXMgYSBtZXNzYWdlLiBgYXV0b2AgaXMgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICogYW5kIG1lYW5zIHRoZSBtb2RlbCBjYW4gcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yIGNhbGxpbmcgb25lIG9yIG1vcmVcbiAgICogdG9vbHMuIGByZXF1aXJlZGAgbWVhbnMgdGhlIG1vZGVsIG11c3QgY2FsbCBvbmUgb3IgbW9yZSB0b29scyBiZWZvcmUgcmVzcG9uZGluZ1xuICAgKiB0byB0aGUgdXNlci4gU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgdG9vbCBsaWtlIGB7XCJ0eXBlXCI6IFwiZmlsZV9zZWFyY2hcIn1gIG9yXG4gICAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gICAqIGNhbGwgdGhhdCB0b29sLlxuICAgKi9cbiAgdG9vbF9jaG9pY2U/OiBBc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIGFzc2lzdGFudCdzIHRvb2xzLiBUaGUgcmVzb3VyY2VzIGFyZVxuICAgKiBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzXG4gICAqIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlXG4gICAqIElEcy5cbiAgICovXG4gIHRvb2xfcmVzb3VyY2VzPzogVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zLlRvb2xSZXNvdXJjZXMgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgdG9vbHMgdGhlIGFzc2lzdGFudCBjYW4gdXNlIGZvciB0aGlzIHJ1bi4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzLlxuICAgKi9cbiAgdG9vbHM/OiBBcnJheTxcbiAgICBBc3Npc3RhbnRzQVBJLkNvZGVJbnRlcnByZXRlclRvb2wgfCBBc3Npc3RhbnRzQVBJLkZpbGVTZWFyY2hUb29sIHwgQXNzaXN0YW50c0FQSS5GdW5jdGlvblRvb2xcbiAgPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEFuIGFsdGVybmF0aXZlIHRvIHNhbXBsaW5nIHdpdGggdGVtcGVyYXR1cmUsIGNhbGxlZCBudWNsZXVzIHNhbXBsaW5nLCB3aGVyZSB0aGVcbiAgICogbW9kZWwgY29uc2lkZXJzIHRoZSByZXN1bHRzIG9mIHRoZSB0b2tlbnMgd2l0aCB0b3BfcCBwcm9iYWJpbGl0eSBtYXNzLiBTbyAwLjFcbiAgICogbWVhbnMgb25seSB0aGUgdG9rZW5zIGNvbXByaXNpbmcgdGhlIHRvcCAxMCUgcHJvYmFiaWxpdHkgbWFzcyBhcmUgY29uc2lkZXJlZC5cbiAgICpcbiAgICogV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIHRlbXBlcmF0dXJlIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRvcF9wPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIHRydW5jYXRpb25fc3RyYXRlZ3k/OiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXMuVHJ1bmNhdGlvblN0cmF0ZWd5IHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXMge1xuICAvKipcbiAgICogSWYgbm8gdGhyZWFkIGlzIHByb3ZpZGVkLCBhbiBlbXB0eSB0aHJlYWQgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWQge1xuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBbbWVzc2FnZXNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMpIHRvXG4gICAgICogc3RhcnQgdGhlIHRocmVhZCB3aXRoLlxuICAgICAqL1xuICAgIG1lc3NhZ2VzPzogQXJyYXk8VGhyZWFkLk1lc3NhZ2U+O1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAgICogY2hhcmFjdGVycyBsb25nLlxuICAgICAqL1xuICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICAgKiB0aHJlYWQuIFRoZSByZXNvdXJjZXMgYXJlIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGVcbiAgICAgKiBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgXG4gICAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICAgKi9cbiAgICB0b29sX3Jlc291cmNlcz86IFRocmVhZC5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVGhyZWFkIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdGV4dCBjb250ZW50cyBvZiB0aGUgbWVzc2FnZS5cbiAgICAgICAqL1xuICAgICAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8TWVzc2FnZXNBUEkuTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0+O1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSByb2xlIG9mIHRoZSBlbnRpdHkgdGhhdCBpcyBjcmVhdGluZyB0aGUgbWVzc2FnZS4gQWxsb3dlZCB2YWx1ZXMgaW5jbHVkZTpcbiAgICAgICAqXG4gICAgICAgKiAtIGB1c2VyYDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIHNlbnQgYnkgYW4gYWN0dWFsIHVzZXIgYW5kIHNob3VsZCBiZSB1c2VkIGluXG4gICAgICAgKiAgIG1vc3QgY2FzZXMgdG8gcmVwcmVzZW50IHVzZXItZ2VuZXJhdGVkIG1lc3NhZ2VzLlxuICAgICAgICogLSBgYXNzaXN0YW50YDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGdlbmVyYXRlZCBieSB0aGUgYXNzaXN0YW50LiBVc2UgdGhpc1xuICAgICAgICogICB2YWx1ZSB0byBpbnNlcnQgbWVzc2FnZXMgZnJvbSB0aGUgYXNzaXN0YW50IGludG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgICAqL1xuICAgICAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIHRoZSBtZXNzYWdlLCBhbmQgdGhlIHRvb2xzIHRoZXkgc2hvdWxkIGJlIGFkZGVkIHRvLlxuICAgICAgICovXG4gICAgICBhdHRhY2htZW50cz86IEFycmF5PE1lc3NhZ2UuQXR0YWNobWVudD4gfCBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAgICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgICAqL1xuICAgICAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIE1lc3NhZ2Uge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBBdHRhY2htZW50IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBhdHRhY2ggdG8gdGhlIG1lc3NhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBmaWxlX2lkPzogc3RyaW5nO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG9vbHMgdG8gYWRkIHRoaXMgZmlsZSB0by5cbiAgICAgICAgICovXG4gICAgICAgIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXR0YWNobWVudC5GaWxlU2VhcmNoPjtcbiAgICAgIH1cblxuICAgICAgZXhwb3J0IG5hbWVzcGFjZSBBdHRhY2htZW50IHtcbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgdHlwZSBvZiB0b29sIGJlaW5nIGRlZmluZWQ6IGBmaWxlX3NlYXJjaGBcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0eXBlOiAnZmlsZV9zZWFyY2gnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBhc3Npc3RhbnQncyB0b29scyBpbiB0aGlzXG4gICAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgICAqIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBJRHMuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICAgIGNvZGVfaW50ZXJwcmV0ZXI/OiBUb29sUmVzb3VyY2VzLkNvZGVJbnRlcnByZXRlcjtcblxuICAgICAgZmlsZV9zZWFyY2g/OiBUb29sUmVzb3VyY2VzLkZpbGVTZWFyY2g7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIG1hZGVcbiAgICAgICAgICogYXZhaWxhYmxlIHRvIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlc1xuICAgICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2wuXG4gICAgICAgICAqL1xuICAgICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVcbiAgICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyB0aHJlYWQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAgICogdGhlIHRocmVhZC5cbiAgICAgICAgICovXG4gICAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGhlbHBlciB0byBjcmVhdGUgYVxuICAgICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICAgKiB3aXRoIGZpbGVfaWRzIGFuZCBhdHRhY2ggaXQgdG8gdGhpcyB0aHJlYWQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3JcbiAgICAgICAgICogc3RvcmUgYXR0YWNoZWQgdG8gdGhlIHRocmVhZC5cbiAgICAgICAgICovXG4gICAgICAgIHZlY3Rvcl9zdG9yZXM/OiBBcnJheTxGaWxlU2VhcmNoLlZlY3RvclN0b3JlPjtcbiAgICAgIH1cblxuICAgICAgZXhwb3J0IG5hbWVzcGFjZSBGaWxlU2VhcmNoIHtcbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIGNodW5raW5nIHN0cmF0ZWd5IHVzZWQgdG8gY2h1bmsgdGhlIGZpbGUocykuIElmIG5vdCBzZXQsIHdpbGwgdXNlIHRoZSBgYXV0b2BcbiAgICAgICAgICAgKiBzdHJhdGVneS4gT25seSBhcHBsaWNhYmxlIGlmIGBmaWxlX2lkc2AgaXMgbm9uLWVtcHR5LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNodW5raW5nX3N0cmF0ZWd5PzogVmVjdG9yU3RvcmVzQVBJLkZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW07XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyB0b1xuICAgICAgICAgICAqIGFkZCB0byB0aGUgdmVjdG9yIHN0b3JlLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEwMDAwIGZpbGVzIGluIGEgdmVjdG9yXG4gICAgICAgICAgICogc3RvcmUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIHZlY3RvciBzdG9yZS4gVGhpcyBjYW4gYmVcbiAgICAgICAgICAgKiB1c2VmdWwgZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdmVjdG9yIHN0b3JlIGluIGEgc3RydWN0dXJlZFxuICAgICAgICAgICAqIGZvcm1hdC4gS2V5cyBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bVxuICAgICAgICAgICAqIG9mIDUxMiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICAgICAgICovXG4gICAgICAgICAgbWV0YWRhdGE/OiB1bmtub3duO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBhc3Npc3RhbnQncyB0b29scy4gVGhlIHJlc291cmNlcyBhcmVcbiAgICogc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlc1xuICAgKiBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZVxuICAgKiBJRHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGNvZGVfaW50ZXJwcmV0ZXI/OiBUb29sUmVzb3VyY2VzLkNvZGVJbnRlcnByZXRlcjtcblxuICAgIGZpbGVfc2VhcmNoPzogVG9vbFJlc291cmNlcy5GaWxlU2VhcmNoO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIG1hZGVcbiAgICAgICAqIGF2YWlsYWJsZSB0byB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMjAgZmlsZXNcbiAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9vbC5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBJRCBvZiB0aGVcbiAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgKiBhdHRhY2hlZCB0byB0aGlzIGFzc2lzdGFudC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvciBzdG9yZSBhdHRhY2hlZCB0b1xuICAgICAgICogdGhlIGFzc2lzdGFudC5cbiAgICAgICAqL1xuICAgICAgdmVjdG9yX3N0b3JlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRydW5jYXRpb25TdHJhdGVneSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRydW5jYXRpb24gc3RyYXRlZ3kgdG8gdXNlIGZvciB0aGUgdGhyZWFkLiBUaGUgZGVmYXVsdCBpcyBgYXV0b2AuIElmIHNldCB0b1xuICAgICAqIGBsYXN0X21lc3NhZ2VzYCwgdGhlIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCB0byB0aGUgbiBtb3N0IHJlY2VudCBtZXNzYWdlcyBpblxuICAgICAqIHRoZSB0aHJlYWQuIFdoZW4gc2V0IHRvIGBhdXRvYCwgbWVzc2FnZXMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdGhyZWFkIHdpbGwgYmVcbiAgICAgKiBkcm9wcGVkIHRvIGZpdCB0aGUgY29udGV4dCBsZW5ndGggb2YgdGhlIG1vZGVsLCBgbWF4X3Byb21wdF90b2tlbnNgLlxuICAgICAqL1xuICAgIHR5cGU6ICdhdXRvJyB8ICdsYXN0X21lc3NhZ2VzJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbW9zdCByZWNlbnQgbWVzc2FnZXMgZnJvbSB0aGUgdGhyZWFkIHdoZW4gY29uc3RydWN0aW5nIHRoZSBjb250ZXh0XG4gICAgICogZm9yIHRoZSBydW4uXG4gICAgICovXG4gICAgbGFzdF9tZXNzYWdlcz86IG51bWJlciB8IG51bGw7XG4gIH1cblxuICBleHBvcnQgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNOb25TdHJlYW1pbmcgPSBUaHJlYWRzQVBJLlRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc05vblN0cmVhbWluZztcbiAgZXhwb3J0IHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zU3RyZWFtaW5nID0gVGhyZWFkc0FQSS5UaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNTdHJlYW1pbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zTm9uU3RyZWFtaW5nIGV4dGVuZHMgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHJldHVybnMgYSBzdHJlYW0gb2YgZXZlbnRzIHRoYXQgaGFwcGVuIGR1cmluZyB0aGUgUnVuIGFzIHNlcnZlci1zZW50XG4gICAqIGV2ZW50cywgdGVybWluYXRpbmcgd2hlbiB0aGUgUnVuIGVudGVycyBhIHRlcm1pbmFsIHN0YXRlIHdpdGggYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKi9cbiAgc3RyZWFtPzogZmFsc2UgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc1N0cmVhbWluZyBleHRlbmRzIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogSWYgYHRydWVgLCByZXR1cm5zIGEgc3RyZWFtIG9mIGV2ZW50cyB0aGF0IGhhcHBlbiBkdXJpbmcgdGhlIFJ1biBhcyBzZXJ2ZXItc2VudFxuICAgKiBldmVudHMsIHRlcm1pbmF0aW5nIHdoZW4gdGhlIFJ1biBlbnRlcnMgYSB0ZXJtaW5hbCBzdGF0ZSB3aXRoIGEgYGRhdGE6IFtET05FXWBcbiAgICogbWVzc2FnZS5cbiAgICovXG4gIHN0cmVhbTogdHJ1ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaHJlYWRDcmVhdGVBbmRSdW5Qb2xsUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGVcbiAgICogW2Fzc2lzdGFudF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSB0byB1c2UgdG9cbiAgICogZXhlY3V0ZSB0aGlzIHJ1bi5cbiAgICovXG4gIGFzc2lzdGFudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBzeXN0ZW0gbWVzc2FnZSBvZiB0aGUgYXNzaXN0YW50LiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlXG4gICAqIHJ1bi4gVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zXG4gICAqIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGUgbnVtYmVyIG9mXG4gICAqIGNvbXBsZXRpb24gdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X2NvbXBsZXRpb25fdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHByb21wdCB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1bi5cbiAgICogVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIHByb21wdCB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogcHJvbXB0IHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLiBTZWVcbiAgICogYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9wcm9tcHRfdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBbTW9kZWxdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzKSB0b1xuICAgKiBiZSB1c2VkIHRvIGV4ZWN1dGUgdGhpcyBydW4uIElmIGEgdmFsdWUgaXMgcHJvdmlkZWQgaGVyZSwgaXQgd2lsbCBvdmVycmlkZSB0aGVcbiAgICogbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3Npc3RhbnQuIElmIG5vdCwgdGhlIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICogYXNzaXN0YW50IHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIG1vZGVsPzpcbiAgICB8IChzdHJpbmcgJiB7fSlcbiAgICB8ICdncHQtNG8nXG4gICAgfCAnZ3B0LTRvLTIwMjQtMDUtMTMnXG4gICAgfCAnZ3B0LTQtdHVyYm8nXG4gICAgfCAnZ3B0LTQtdHVyYm8tMjAyNC0wNC0wOSdcbiAgICB8ICdncHQtNC0wMTI1LXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtdHVyYm8tcHJldmlldydcbiAgICB8ICdncHQtNC0xMTA2LXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtdmlzaW9uLXByZXZpZXcnXG4gICAgfCAnZ3B0LTQnXG4gICAgfCAnZ3B0LTQtMDMxNCdcbiAgICB8ICdncHQtNC0wNjEzJ1xuICAgIHwgJ2dwdC00LTMyaydcbiAgICB8ICdncHQtNC0zMmstMDMxNCdcbiAgICB8ICdncHQtNC0zMmstMDYxMydcbiAgICB8ICdncHQtMy41LXR1cmJvJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTZrJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMDYxMydcbiAgICB8ICdncHQtMy41LXR1cmJvLTExMDYnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0wMTI1J1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTZrLTA2MTMnXG4gICAgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gICAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscy9ncHQtNG8pLFxuICAgKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscy9ncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICAgKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGd1YXJhbnRlZXMgdGhlXG4gICAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICAgKlxuICAgKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gICAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAgICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAgICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAgICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICAgKiBtYXggY29udGV4dCBsZW5ndGguXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBBc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoYXQgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdG8gdXNlLCBiZXR3ZWVuIDAgYW5kIDIuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbFxuICAgKiBtYWtlIHRoZSBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZVxuICAgKiBmb2N1c2VkIGFuZCBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJZiBubyB0aHJlYWQgaXMgcHJvdmlkZWQsIGFuIGVtcHR5IHRocmVhZCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqL1xuICB0aHJlYWQ/OiBUaHJlYWRDcmVhdGVBbmRSdW5Qb2xsUGFyYW1zLlRocmVhZDtcblxuICAvKipcbiAgICogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgdG9vbCBpcyBjYWxsZWQgYnkgdGhlIG1vZGVsLiBgbm9uZWAgbWVhbnMgdGhlIG1vZGVsIHdpbGxcbiAgICogbm90IGNhbGwgYW55IHRvb2xzIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBpcyB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgKiBhbmQgbWVhbnMgdGhlIG1vZGVsIGNhbiBwaWNrIGJldHdlZW4gZ2VuZXJhdGluZyBhIG1lc3NhZ2Ugb3IgY2FsbGluZyBvbmUgb3IgbW9yZVxuICAgKiB0b29scy4gYHJlcXVpcmVkYCBtZWFucyB0aGUgbW9kZWwgbXVzdCBjYWxsIG9uZSBvciBtb3JlIHRvb2xzIGJlZm9yZSByZXNwb25kaW5nXG4gICAqIHRvIHRoZSB1c2VyLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciB0b29sIGxpa2UgYHtcInR5cGVcIjogXCJmaWxlX3NlYXJjaFwifWAgb3JcbiAgICogYHtcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifX1gIGZvcmNlcyB0aGUgbW9kZWwgdG9cbiAgICogY2FsbCB0aGF0IHRvb2wuXG4gICAqL1xuICB0b29sX2Nob2ljZT86IEFzc2lzdGFudFRvb2xDaG9pY2VPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgdXNlZCBieSB0aGUgYXNzaXN0YW50J3MgdG9vbHMuIFRoZSByZXNvdXJjZXMgYXJlXG4gICAqIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXNcbiAgICogYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVcbiAgICogSURzLlxuICAgKi9cbiAgdG9vbF9yZXNvdXJjZXM/OiBUaHJlYWRDcmVhdGVBbmRSdW5Qb2xsUGFyYW1zLlRvb2xSZXNvdXJjZXMgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgdG9vbHMgdGhlIGFzc2lzdGFudCBjYW4gdXNlIGZvciB0aGlzIHJ1bi4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzLlxuICAgKi9cbiAgdG9vbHM/OiBBcnJheTxcbiAgICBBc3Npc3RhbnRzQVBJLkNvZGVJbnRlcnByZXRlclRvb2wgfCBBc3Npc3RhbnRzQVBJLkZpbGVTZWFyY2hUb29sIHwgQXNzaXN0YW50c0FQSS5GdW5jdGlvblRvb2xcbiAgPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEFuIGFsdGVybmF0aXZlIHRvIHNhbXBsaW5nIHdpdGggdGVtcGVyYXR1cmUsIGNhbGxlZCBudWNsZXVzIHNhbXBsaW5nLCB3aGVyZSB0aGVcbiAgICogbW9kZWwgY29uc2lkZXJzIHRoZSByZXN1bHRzIG9mIHRoZSB0b2tlbnMgd2l0aCB0b3BfcCBwcm9iYWJpbGl0eSBtYXNzLiBTbyAwLjFcbiAgICogbWVhbnMgb25seSB0aGUgdG9rZW5zIGNvbXByaXNpbmcgdGhlIHRvcCAxMCUgcHJvYmFiaWxpdHkgbWFzcyBhcmUgY29uc2lkZXJlZC5cbiAgICpcbiAgICogV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIHRlbXBlcmF0dXJlIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRvcF9wPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIHRydW5jYXRpb25fc3RyYXRlZ3k/OiBUaHJlYWRDcmVhdGVBbmRSdW5Qb2xsUGFyYW1zLlRydW5jYXRpb25TdHJhdGVneSB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVGhyZWFkQ3JlYXRlQW5kUnVuUG9sbFBhcmFtcyB7XG4gIC8qKlxuICAgKiBJZiBubyB0aHJlYWQgaXMgcHJvdmlkZWQsIGFuIGVtcHR5IHRocmVhZCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZCB7XG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIFttZXNzYWdlc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcykgdG9cbiAgICAgKiBzdGFydCB0aGUgdGhyZWFkIHdpdGguXG4gICAgICovXG4gICAgbWVzc2FnZXM/OiBBcnJheTxUaHJlYWQuTWVzc2FnZT47XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICovXG4gICAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYXNzaXN0YW50J3MgdG9vbHMgaW4gdGhpc1xuICAgICAqIHRocmVhZC4gVGhlIHJlc291cmNlcyBhcmUgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZVxuICAgICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICAgKiB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgSURzLlxuICAgICAqL1xuICAgIHRvb2xfcmVzb3VyY2VzPzogVGhyZWFkLlRvb2xSZXNvdXJjZXMgfCBudWxsO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBUaHJlYWQge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxNZXNzYWdlc0FQSS5NZXNzYWdlQ29udGVudFBhcnRQYXJhbT47XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHJvbGUgb2YgdGhlIGVudGl0eSB0aGF0IGlzIGNyZWF0aW5nIHRoZSBtZXNzYWdlLiBBbGxvd2VkIHZhbHVlcyBpbmNsdWRlOlxuICAgICAgICpcbiAgICAgICAqIC0gYHVzZXJgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgc2VudCBieSBhbiBhY3R1YWwgdXNlciBhbmQgc2hvdWxkIGJlIHVzZWQgaW5cbiAgICAgICAqICAgbW9zdCBjYXNlcyB0byByZXByZXNlbnQgdXNlci1nZW5lcmF0ZWQgbWVzc2FnZXMuXG4gICAgICAgKiAtIGBhc3Npc3RhbnRgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBhc3Npc3RhbnQuIFVzZSB0aGlzXG4gICAgICAgKiAgIHZhbHVlIHRvIGluc2VydCBtZXNzYWdlcyBmcm9tIHRoZSBhc3Npc3RhbnQgaW50byB0aGUgY29udmVyc2F0aW9uLlxuICAgICAgICovXG4gICAgICByb2xlOiAndXNlcicgfCAnYXNzaXN0YW50JztcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgZmlsZXMgYXR0YWNoZWQgdG8gdGhlIG1lc3NhZ2UsIGFuZCB0aGUgdG9vbHMgdGhleSBzaG91bGQgYmUgYWRkZWQgdG8uXG4gICAgICAgKi9cbiAgICAgIGF0dGFjaG1lbnRzPzogQXJyYXk8TWVzc2FnZS5BdHRhY2htZW50PiB8IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgICAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICAgICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgICAgICogY2hhcmFjdGVycyBsb25nLlxuICAgICAgICovXG4gICAgICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgTWVzc2FnZSB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEF0dGFjaG1lbnQge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSBmaWxlIHRvIGF0dGFjaCB0byB0aGUgbWVzc2FnZS5cbiAgICAgICAgICovXG4gICAgICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b29scyB0byBhZGQgdGhpcyBmaWxlIHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkNvZGVJbnRlcnByZXRlclRvb2wgfCBBc3Npc3RhbnRzQVBJLkZpbGVTZWFyY2hUb29sPjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICAgKiB0aHJlYWQuIFRoZSByZXNvdXJjZXMgYXJlIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGVcbiAgICAgKiBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgXG4gICAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgICAgY29kZV9pbnRlcnByZXRlcj86IFRvb2xSZXNvdXJjZXMuQ29kZUludGVycHJldGVyO1xuXG4gICAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgbWFkZVxuICAgICAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzXG4gICAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9vbC5cbiAgICAgICAgICovXG4gICAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICAgIH1cblxuICAgICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZVxuICAgICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICAgKiBhdHRhY2hlZCB0byB0aGlzIHRocmVhZC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvciBzdG9yZSBhdHRhY2hlZCB0b1xuICAgICAgICAgKiB0aGUgdGhyZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgdmVjdG9yX3N0b3JlX2lkcz86IEFycmF5PHN0cmluZz47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgaGVscGVyIHRvIGNyZWF0ZSBhXG4gICAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgICAqIHdpdGggZmlsZV9pZHMgYW5kIGF0dGFjaCBpdCB0byB0aGlzIHRocmVhZC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvclxuICAgICAgICAgKiBzdG9yZSBhdHRhY2hlZCB0byB0aGUgdGhyZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgdmVjdG9yX3N0b3Jlcz86IEFycmF5PEZpbGVTZWFyY2guVmVjdG9yU3RvcmU+O1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgbmFtZXNwYWNlIEZpbGVTZWFyY2gge1xuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyB0b1xuICAgICAgICAgICAqIGFkZCB0byB0aGUgdmVjdG9yIHN0b3JlLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEwMDAwIGZpbGVzIGluIGEgdmVjdG9yXG4gICAgICAgICAgICogc3RvcmUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIHZlY3RvciBzdG9yZS4gVGhpcyBjYW4gYmVcbiAgICAgICAgICAgKiB1c2VmdWwgZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdmVjdG9yIHN0b3JlIGluIGEgc3RydWN0dXJlZFxuICAgICAgICAgICAqIGZvcm1hdC4gS2V5cyBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bVxuICAgICAgICAgICAqIG9mIDUxMiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICAgICAgICovXG4gICAgICAgICAgbWV0YWRhdGE/OiB1bmtub3duO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBhc3Npc3RhbnQncyB0b29scy4gVGhlIHJlc291cmNlcyBhcmVcbiAgICogc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlc1xuICAgKiBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZVxuICAgKiBJRHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGNvZGVfaW50ZXJwcmV0ZXI/OiBUb29sUmVzb3VyY2VzLkNvZGVJbnRlcnByZXRlcjtcblxuICAgIGZpbGVfc2VhcmNoPzogVG9vbFJlc291cmNlcy5GaWxlU2VhcmNoO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIG1hZGVcbiAgICAgICAqIGF2YWlsYWJsZSB0byB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMjAgZmlsZXNcbiAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9vbC5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBJRCBvZiB0aGVcbiAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgKiBhdHRhY2hlZCB0byB0aGlzIGFzc2lzdGFudC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvciBzdG9yZSBhdHRhY2hlZCB0b1xuICAgICAgICogdGhlIGFzc2lzdGFudC5cbiAgICAgICAqL1xuICAgICAgdmVjdG9yX3N0b3JlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRydW5jYXRpb25TdHJhdGVneSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRydW5jYXRpb24gc3RyYXRlZ3kgdG8gdXNlIGZvciB0aGUgdGhyZWFkLiBUaGUgZGVmYXVsdCBpcyBgYXV0b2AuIElmIHNldCB0b1xuICAgICAqIGBsYXN0X21lc3NhZ2VzYCwgdGhlIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCB0byB0aGUgbiBtb3N0IHJlY2VudCBtZXNzYWdlcyBpblxuICAgICAqIHRoZSB0aHJlYWQuIFdoZW4gc2V0IHRvIGBhdXRvYCwgbWVzc2FnZXMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdGhyZWFkIHdpbGwgYmVcbiAgICAgKiBkcm9wcGVkIHRvIGZpdCB0aGUgY29udGV4dCBsZW5ndGggb2YgdGhlIG1vZGVsLCBgbWF4X3Byb21wdF90b2tlbnNgLlxuICAgICAqL1xuICAgIHR5cGU6ICdhdXRvJyB8ICdsYXN0X21lc3NhZ2VzJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbW9zdCByZWNlbnQgbWVzc2FnZXMgZnJvbSB0aGUgdGhyZWFkIHdoZW4gY29uc3RydWN0aW5nIHRoZSBjb250ZXh0XG4gICAgICogZm9yIHRoZSBydW4uXG4gICAgICovXG4gICAgbGFzdF9tZXNzYWdlcz86IG51bWJlciB8IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaHJlYWRDcmVhdGVBbmRSdW5TdHJlYW1QYXJhbXMge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIHRvIHVzZSB0b1xuICAgKiBleGVjdXRlIHRoaXMgcnVuLlxuICAgKi9cbiAgYXNzaXN0YW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHN5c3RlbSBtZXNzYWdlIG9mIHRoZSBhc3Npc3RhbnQuIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGVcbiAgICogcnVuLiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogY29tcGxldGlvbiB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC4gU2VlXG4gICAqIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfY29tcGxldGlvbl90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcHJvbXB0IHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgcnVuLlxuICAgKiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgcHJvbXB0IHRva2Vuc1xuICAgKiBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlIG51bWJlciBvZlxuICAgKiBwcm9tcHQgdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X3Byb21wdF90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFtNb2RlbF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tb2RlbHMpIHRvXG4gICAqIGJlIHVzZWQgdG8gZXhlY3V0ZSB0aGlzIHJ1bi4gSWYgYSB2YWx1ZSBpcyBwcm92aWRlZCBoZXJlLCBpdCB3aWxsIG92ZXJyaWRlIHRoZVxuICAgKiBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2lzdGFudC4gSWYgbm90LCB0aGUgbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgKiBhc3Npc3RhbnQgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgbW9kZWw/OlxuICAgIHwgKHN0cmluZyAmIHt9KVxuICAgIHwgJ2dwdC00bydcbiAgICB8ICdncHQtNG8tMjAyNC0wNS0xMydcbiAgICB8ICdncHQtNC10dXJibydcbiAgICB8ICdncHQtNC10dXJiby0yMDI0LTA0LTA5J1xuICAgIHwgJ2dwdC00LTAxMjUtcHJldmlldydcbiAgICB8ICdncHQtNC10dXJiby1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LTExMDYtcHJldmlldydcbiAgICB8ICdncHQtNC12aXNpb24tcHJldmlldydcbiAgICB8ICdncHQtNCdcbiAgICB8ICdncHQtNC0wMzE0J1xuICAgIHwgJ2dwdC00LTA2MTMnXG4gICAgfCAnZ3B0LTQtMzJrJ1xuICAgIHwgJ2dwdC00LTMyay0wMzE0J1xuICAgIHwgJ2dwdC00LTMyay0wNjEzJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8nXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xNmsnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0wNjEzJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTEwNidcbiAgICB8ICdncHQtMy41LXR1cmJvLTAxMjUnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xNmstMDYxMydcbiAgICB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAgICogW0dQVC00b10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzL2dwdC00byksXG4gICAqIFtHUFQtNCBUdXJib10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzL2dwdC00LXR1cmJvLWFuZC1ncHQtNCksXG4gICAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9vYmplY3RcIiB9YCBlbmFibGVzIEpTT04gbW9kZSwgd2hpY2ggZ3VhcmFudGVlcyB0aGVcbiAgICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gICAqXG4gICAqICoqSW1wb3J0YW50OioqIHdoZW4gdXNpbmcgSlNPTiBtb2RlLCB5b3UgKiptdXN0KiogYWxzbyBpbnN0cnVjdCB0aGUgbW9kZWwgdG9cbiAgICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICAgKiBnZW5lcmF0ZSBhbiB1bmVuZGluZyBzdHJlYW0gb2Ygd2hpdGVzcGFjZSB1bnRpbCB0aGUgZ2VuZXJhdGlvbiByZWFjaGVzIHRoZSB0b2tlblxuICAgKiBsaW1pdCwgcmVzdWx0aW5nIGluIGEgbG9uZy1ydW5uaW5nIGFuZCBzZWVtaW5nbHkgXCJzdHVja1wiIHJlcXVlc3QuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICAgKiBpbmRpY2F0ZXMgdGhlIGdlbmVyYXRpb24gZXhjZWVkZWQgYG1heF90b2tlbnNgIG9yIHRoZSBjb252ZXJzYXRpb24gZXhjZWVkZWQgdGhlXG4gICAqIG1heCBjb250ZXh0IGxlbmd0aC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86IEFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIElmIG5vIHRocmVhZCBpcyBwcm92aWRlZCwgYW4gZW1wdHkgdGhyZWFkIHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIHRocmVhZD86IFRocmVhZENyZWF0ZUFuZFJ1blN0cmVhbVBhcmFtcy5UaHJlYWQ7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIHdoaWNoIChpZiBhbnkpIHRvb2wgaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC4gYG5vbmVgIG1lYW5zIHRoZSBtb2RlbCB3aWxsXG4gICAqIG5vdCBjYWxsIGFueSB0b29scyBhbmQgaW5zdGVhZCBnZW5lcmF0ZXMgYSBtZXNzYWdlLiBgYXV0b2AgaXMgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICogYW5kIG1lYW5zIHRoZSBtb2RlbCBjYW4gcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yIGNhbGxpbmcgb25lIG9yIG1vcmVcbiAgICogdG9vbHMuIGByZXF1aXJlZGAgbWVhbnMgdGhlIG1vZGVsIG11c3QgY2FsbCBvbmUgb3IgbW9yZSB0b29scyBiZWZvcmUgcmVzcG9uZGluZ1xuICAgKiB0byB0aGUgdXNlci4gU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgdG9vbCBsaWtlIGB7XCJ0eXBlXCI6IFwiZmlsZV9zZWFyY2hcIn1gIG9yXG4gICAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gICAqIGNhbGwgdGhhdCB0b29sLlxuICAgKi9cbiAgdG9vbF9jaG9pY2U/OiBBc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIGFzc2lzdGFudCdzIHRvb2xzLiBUaGUgcmVzb3VyY2VzIGFyZVxuICAgKiBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzXG4gICAqIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlXG4gICAqIElEcy5cbiAgICovXG4gIHRvb2xfcmVzb3VyY2VzPzogVGhyZWFkQ3JlYXRlQW5kUnVuU3RyZWFtUGFyYW1zLlRvb2xSZXNvdXJjZXMgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgdG9vbHMgdGhlIGFzc2lzdGFudCBjYW4gdXNlIGZvciB0aGlzIHJ1bi4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzLlxuICAgKi9cbiAgdG9vbHM/OiBBcnJheTxcbiAgICBBc3Npc3RhbnRzQVBJLkNvZGVJbnRlcnByZXRlclRvb2wgfCBBc3Npc3RhbnRzQVBJLkZpbGVTZWFyY2hUb29sIHwgQXNzaXN0YW50c0FQSS5GdW5jdGlvblRvb2xcbiAgPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEFuIGFsdGVybmF0aXZlIHRvIHNhbXBsaW5nIHdpdGggdGVtcGVyYXR1cmUsIGNhbGxlZCBudWNsZXVzIHNhbXBsaW5nLCB3aGVyZSB0aGVcbiAgICogbW9kZWwgY29uc2lkZXJzIHRoZSByZXN1bHRzIG9mIHRoZSB0b2tlbnMgd2l0aCB0b3BfcCBwcm9iYWJpbGl0eSBtYXNzLiBTbyAwLjFcbiAgICogbWVhbnMgb25seSB0aGUgdG9rZW5zIGNvbXByaXNpbmcgdGhlIHRvcCAxMCUgcHJvYmFiaWxpdHkgbWFzcyBhcmUgY29uc2lkZXJlZC5cbiAgICpcbiAgICogV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIHRlbXBlcmF0dXJlIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRvcF9wPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIHRydW5jYXRpb25fc3RyYXRlZ3k/OiBUaHJlYWRDcmVhdGVBbmRSdW5TdHJlYW1QYXJhbXMuVHJ1bmNhdGlvblN0cmF0ZWd5IHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBUaHJlYWRDcmVhdGVBbmRSdW5TdHJlYW1QYXJhbXMge1xuICAvKipcbiAgICogSWYgbm8gdGhyZWFkIGlzIHByb3ZpZGVkLCBhbiBlbXB0eSB0aHJlYWQgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWQge1xuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBbbWVzc2FnZXNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMpIHRvXG4gICAgICogc3RhcnQgdGhlIHRocmVhZCB3aXRoLlxuICAgICAqL1xuICAgIG1lc3NhZ2VzPzogQXJyYXk8VGhyZWFkLk1lc3NhZ2U+O1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAgICogY2hhcmFjdGVycyBsb25nLlxuICAgICAqL1xuICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICAgKiB0aHJlYWQuIFRoZSByZXNvdXJjZXMgYXJlIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGVcbiAgICAgKiBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgXG4gICAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICAgKi9cbiAgICB0b29sX3Jlc291cmNlcz86IFRocmVhZC5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVGhyZWFkIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdGV4dCBjb250ZW50cyBvZiB0aGUgbWVzc2FnZS5cbiAgICAgICAqL1xuICAgICAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8TWVzc2FnZXNBUEkuTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0+O1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSByb2xlIG9mIHRoZSBlbnRpdHkgdGhhdCBpcyBjcmVhdGluZyB0aGUgbWVzc2FnZS4gQWxsb3dlZCB2YWx1ZXMgaW5jbHVkZTpcbiAgICAgICAqXG4gICAgICAgKiAtIGB1c2VyYDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIHNlbnQgYnkgYW4gYWN0dWFsIHVzZXIgYW5kIHNob3VsZCBiZSB1c2VkIGluXG4gICAgICAgKiAgIG1vc3QgY2FzZXMgdG8gcmVwcmVzZW50IHVzZXItZ2VuZXJhdGVkIG1lc3NhZ2VzLlxuICAgICAgICogLSBgYXNzaXN0YW50YDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGdlbmVyYXRlZCBieSB0aGUgYXNzaXN0YW50LiBVc2UgdGhpc1xuICAgICAgICogICB2YWx1ZSB0byBpbnNlcnQgbWVzc2FnZXMgZnJvbSB0aGUgYXNzaXN0YW50IGludG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgICAqL1xuICAgICAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIHRoZSBtZXNzYWdlLCBhbmQgdGhlIHRvb2xzIHRoZXkgc2hvdWxkIGJlIGFkZGVkIHRvLlxuICAgICAgICovXG4gICAgICBhdHRhY2htZW50cz86IEFycmF5PE1lc3NhZ2UuQXR0YWNobWVudD4gfCBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAgICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgICAqL1xuICAgICAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIE1lc3NhZ2Uge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBBdHRhY2htZW50IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBhdHRhY2ggdG8gdGhlIG1lc3NhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBmaWxlX2lkPzogc3RyaW5nO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG9vbHMgdG8gYWRkIHRoaXMgZmlsZSB0by5cbiAgICAgICAgICovXG4gICAgICAgIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXNzaXN0YW50c0FQSS5GaWxlU2VhcmNoVG9vbD47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBhc3Npc3RhbnQncyB0b29scyBpbiB0aGlzXG4gICAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgICAqIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBJRHMuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICAgIGNvZGVfaW50ZXJwcmV0ZXI/OiBUb29sUmVzb3VyY2VzLkNvZGVJbnRlcnByZXRlcjtcblxuICAgICAgZmlsZV9zZWFyY2g/OiBUb29sUmVzb3VyY2VzLkZpbGVTZWFyY2g7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIG1hZGVcbiAgICAgICAgICogYXZhaWxhYmxlIHRvIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlc1xuICAgICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2wuXG4gICAgICAgICAqL1xuICAgICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVcbiAgICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyB0aHJlYWQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAgICogdGhlIHRocmVhZC5cbiAgICAgICAgICovXG4gICAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGhlbHBlciB0byBjcmVhdGUgYVxuICAgICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICAgKiB3aXRoIGZpbGVfaWRzIGFuZCBhdHRhY2ggaXQgdG8gdGhpcyB0aHJlYWQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3JcbiAgICAgICAgICogc3RvcmUgYXR0YWNoZWQgdG8gdGhlIHRocmVhZC5cbiAgICAgICAgICovXG4gICAgICAgIHZlY3Rvcl9zdG9yZXM/OiBBcnJheTxGaWxlU2VhcmNoLlZlY3RvclN0b3JlPjtcbiAgICAgIH1cblxuICAgICAgZXhwb3J0IG5hbWVzcGFjZSBGaWxlU2VhcmNoIHtcbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgdG9cbiAgICAgICAgICAgKiBhZGQgdG8gdGhlIHZlY3RvciBzdG9yZS4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxMDAwMCBmaWxlcyBpbiBhIHZlY3RvclxuICAgICAgICAgICAqIHN0b3JlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB2ZWN0b3Igc3RvcmUuIFRoaXMgY2FuIGJlXG4gICAgICAgICAgICogdXNlZnVsIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZlY3RvciBzdG9yZSBpbiBhIHN0cnVjdHVyZWRcbiAgICAgICAgICAgKiBmb3JtYXQuIEtleXMgY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW1cbiAgICAgICAgICAgKiBvZiA1MTIgY2hhcmFjdGVycyBsb25nLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1ldGFkYXRhPzogdW5rbm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgdXNlZCBieSB0aGUgYXNzaXN0YW50J3MgdG9vbHMuIFRoZSByZXNvdXJjZXMgYXJlXG4gICAqIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXNcbiAgICogYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVcbiAgICogSURzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzXG4gICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2wuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSUQgb2YgdGhlXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyBhc3Npc3RhbnQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAqIHRoZSBhc3Npc3RhbnQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUcnVuY2F0aW9uU3RyYXRlZ3kge1xuICAgIC8qKlxuICAgICAqIFRoZSB0cnVuY2F0aW9uIHN0cmF0ZWd5IHRvIHVzZSBmb3IgdGhlIHRocmVhZC4gVGhlIGRlZmF1bHQgaXMgYGF1dG9gLiBJZiBzZXQgdG9cbiAgICAgKiBgbGFzdF9tZXNzYWdlc2AsIHRoZSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgdG8gdGhlIG4gbW9zdCByZWNlbnQgbWVzc2FnZXMgaW5cbiAgICAgKiB0aGUgdGhyZWFkLiBXaGVuIHNldCB0byBgYXV0b2AsIG1lc3NhZ2VzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHRocmVhZCB3aWxsIGJlXG4gICAgICogZHJvcHBlZCB0byBmaXQgdGhlIGNvbnRleHQgbGVuZ3RoIG9mIHRoZSBtb2RlbCwgYG1heF9wcm9tcHRfdG9rZW5zYC5cbiAgICAgKi9cbiAgICB0eXBlOiAnYXV0bycgfCAnbGFzdF9tZXNzYWdlcyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGZyb20gdGhlIHRocmVhZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgY29udGV4dFxuICAgICAqIGZvciB0aGUgcnVuLlxuICAgICAqL1xuICAgIGxhc3RfbWVzc2FnZXM/OiBudW1iZXIgfCBudWxsO1xuICB9XG59XG5cblRocmVhZHMuUnVucyA9IFJ1bnM7XG5UaHJlYWRzLlJ1bnNQYWdlID0gUnVuc1BhZ2U7XG5UaHJlYWRzLk1lc3NhZ2VzID0gTWVzc2FnZXM7XG5UaHJlYWRzLk1lc3NhZ2VzUGFnZSA9IE1lc3NhZ2VzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFRocmVhZHMge1xuICBleHBvcnQge1xuICAgIHR5cGUgQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gYXMgQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24sXG4gICAgdHlwZSBBc3Npc3RhbnRUb29sQ2hvaWNlIGFzIEFzc2lzdGFudFRvb2xDaG9pY2UsXG4gICAgdHlwZSBBc3Npc3RhbnRUb29sQ2hvaWNlRnVuY3Rpb24gYXMgQXNzaXN0YW50VG9vbENob2ljZUZ1bmN0aW9uLFxuICAgIHR5cGUgQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiBhcyBBc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uLFxuICAgIHR5cGUgVGhyZWFkIGFzIFRocmVhZCxcbiAgICB0eXBlIFRocmVhZERlbGV0ZWQgYXMgVGhyZWFkRGVsZXRlZCxcbiAgICB0eXBlIFRocmVhZENyZWF0ZVBhcmFtcyBhcyBUaHJlYWRDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBUaHJlYWRVcGRhdGVQYXJhbXMgYXMgVGhyZWFkVXBkYXRlUGFyYW1zLFxuICAgIHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zIGFzIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtcyxcbiAgICB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc05vblN0cmVhbWluZyBhcyBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNTdHJlYW1pbmcgYXMgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zU3RyZWFtaW5nLFxuICAgIHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUG9sbFBhcmFtcyxcbiAgICB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blN0cmVhbVBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIFJ1bnMgYXMgUnVucyxcbiAgICB0eXBlIFJlcXVpcmVkQWN0aW9uRnVuY3Rpb25Ub29sQ2FsbCBhcyBSZXF1aXJlZEFjdGlvbkZ1bmN0aW9uVG9vbENhbGwsXG4gICAgdHlwZSBSdW4gYXMgUnVuLFxuICAgIHR5cGUgUnVuU3RhdHVzIGFzIFJ1blN0YXR1cyxcbiAgICBSdW5zUGFnZSBhcyBSdW5zUGFnZSxcbiAgICB0eXBlIFJ1bkNyZWF0ZVBhcmFtcyBhcyBSdW5DcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBSdW5DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgYXMgUnVuQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGFzIFJ1bkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgICB0eXBlIFJ1blVwZGF0ZVBhcmFtcyBhcyBSdW5VcGRhdGVQYXJhbXMsXG4gICAgdHlwZSBSdW5MaXN0UGFyYW1zIGFzIFJ1bkxpc3RQYXJhbXMsXG4gICAgdHlwZSBSdW5DcmVhdGVBbmRQb2xsUGFyYW1zLFxuICAgIHR5cGUgUnVuQ3JlYXRlQW5kU3RyZWFtUGFyYW1zLFxuICAgIHR5cGUgUnVuU3RyZWFtUGFyYW1zLFxuICAgIHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXMgYXMgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXMsXG4gICAgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc05vblN0cmVhbWluZyBhcyBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtaW5nIGFzIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtaW5nLFxuICAgIHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNBbmRQb2xsUGFyYW1zLFxuICAgIHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNTdHJlYW1QYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHtcbiAgICBNZXNzYWdlcyBhcyBNZXNzYWdlcyxcbiAgICB0eXBlIEFubm90YXRpb24gYXMgQW5ub3RhdGlvbixcbiAgICB0eXBlIEFubm90YXRpb25EZWx0YSBhcyBBbm5vdGF0aW9uRGVsdGEsXG4gICAgdHlwZSBGaWxlQ2l0YXRpb25Bbm5vdGF0aW9uIGFzIEZpbGVDaXRhdGlvbkFubm90YXRpb24sXG4gICAgdHlwZSBGaWxlQ2l0YXRpb25EZWx0YUFubm90YXRpb24gYXMgRmlsZUNpdGF0aW9uRGVsdGFBbm5vdGF0aW9uLFxuICAgIHR5cGUgRmlsZVBhdGhBbm5vdGF0aW9uIGFzIEZpbGVQYXRoQW5ub3RhdGlvbixcbiAgICB0eXBlIEZpbGVQYXRoRGVsdGFBbm5vdGF0aW9uIGFzIEZpbGVQYXRoRGVsdGFBbm5vdGF0aW9uLFxuICAgIHR5cGUgSW1hZ2VGaWxlIGFzIEltYWdlRmlsZSxcbiAgICB0eXBlIEltYWdlRmlsZUNvbnRlbnRCbG9jayBhcyBJbWFnZUZpbGVDb250ZW50QmxvY2ssXG4gICAgdHlwZSBJbWFnZUZpbGVEZWx0YSBhcyBJbWFnZUZpbGVEZWx0YSxcbiAgICB0eXBlIEltYWdlRmlsZURlbHRhQmxvY2sgYXMgSW1hZ2VGaWxlRGVsdGFCbG9jayxcbiAgICB0eXBlIEltYWdlVVJMIGFzIEltYWdlVVJMLFxuICAgIHR5cGUgSW1hZ2VVUkxDb250ZW50QmxvY2sgYXMgSW1hZ2VVUkxDb250ZW50QmxvY2ssXG4gICAgdHlwZSBJbWFnZVVSTERlbHRhIGFzIEltYWdlVVJMRGVsdGEsXG4gICAgdHlwZSBJbWFnZVVSTERlbHRhQmxvY2sgYXMgSW1hZ2VVUkxEZWx0YUJsb2NrLFxuICAgIHR5cGUgTWVzc2FnZXNBUElNZXNzYWdlIGFzIE1lc3NhZ2UsXG4gICAgdHlwZSBNZXNzYWdlQ29udGVudCBhcyBNZXNzYWdlQ29udGVudCxcbiAgICB0eXBlIE1lc3NhZ2VDb250ZW50RGVsdGEgYXMgTWVzc2FnZUNvbnRlbnREZWx0YSxcbiAgICB0eXBlIE1lc3NhZ2VDb250ZW50UGFydFBhcmFtIGFzIE1lc3NhZ2VDb250ZW50UGFydFBhcmFtLFxuICAgIHR5cGUgTWVzc2FnZURlbGV0ZWQgYXMgTWVzc2FnZURlbGV0ZWQsXG4gICAgdHlwZSBNZXNzYWdlRGVsdGEgYXMgTWVzc2FnZURlbHRhLFxuICAgIHR5cGUgTWVzc2FnZURlbHRhRXZlbnQgYXMgTWVzc2FnZURlbHRhRXZlbnQsXG4gICAgdHlwZSBSZWZ1c2FsQ29udGVudEJsb2NrIGFzIFJlZnVzYWxDb250ZW50QmxvY2ssXG4gICAgdHlwZSBSZWZ1c2FsRGVsdGFCbG9jayBhcyBSZWZ1c2FsRGVsdGFCbG9jayxcbiAgICB0eXBlIFRleHQgYXMgVGV4dCxcbiAgICB0eXBlIFRleHRDb250ZW50QmxvY2sgYXMgVGV4dENvbnRlbnRCbG9jayxcbiAgICB0eXBlIFRleHRDb250ZW50QmxvY2tQYXJhbSBhcyBUZXh0Q29udGVudEJsb2NrUGFyYW0sXG4gICAgdHlwZSBUZXh0RGVsdGEgYXMgVGV4dERlbHRhLFxuICAgIHR5cGUgVGV4dERlbHRhQmxvY2sgYXMgVGV4dERlbHRhQmxvY2ssXG4gICAgTWVzc2FnZXNQYWdlIGFzIE1lc3NhZ2VzUGFnZSxcbiAgICB0eXBlIE1lc3NhZ2VDcmVhdGVQYXJhbXMgYXMgTWVzc2FnZUNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIE1lc3NhZ2VVcGRhdGVQYXJhbXMgYXMgTWVzc2FnZVVwZGF0ZVBhcmFtcyxcbiAgICB0eXBlIE1lc3NhZ2VMaXN0UGFyYW1zIGFzIE1lc3NhZ2VMaXN0UGFyYW1zLFxuICB9O1xufVxuIiwgIi8qKlxuICogTGlrZSBgUHJvbWlzZS5hbGxTZXR0bGVkKClgIGJ1dCB0aHJvd3MgYW4gZXJyb3IgaWYgYW55IHByb21pc2VzIGFyZSByZWplY3RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGFsbFNldHRsZWRXaXRoVGhyb3cgPSBhc3luYyA8Uj4ocHJvbWlzZXM6IFByb21pc2U8Uj5bXSk6IFByb21pc2U8UltdPiA9PiB7XG4gIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpO1xuICBjb25zdCByZWplY3RlZCA9IHJlc3VsdHMuZmlsdGVyKChyZXN1bHQpOiByZXN1bHQgaXMgUHJvbWlzZVJlamVjdGVkUmVzdWx0ID0+IHJlc3VsdC5zdGF0dXMgPT09ICdyZWplY3RlZCcpO1xuICBpZiAocmVqZWN0ZWQubGVuZ3RoKSB7XG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVqZWN0ZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IocmVzdWx0LnJlYXNvbik7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3JlamVjdGVkLmxlbmd0aH0gcHJvbWlzZShzKSBmYWlsZWQgLSBzZWUgdGhlIGFib3ZlIGVycm9yc2ApO1xuICB9XG5cbiAgLy8gTm90ZTogVFMgd2FzIGNvbXBsYWluaW5nIGFib3V0IHVzaW5nIGAuZmlsdGVyKCkubWFwKClgIGhlcmUgZm9yIHNvbWUgcmVhc29uXG4gIGNvbnN0IHZhbHVlczogUltdID0gW107XG4gIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgIHZhbHVlcy5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59O1xuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgc2xlZXAsIFVwbG9hZGFibGUsIGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBWZWN0b3JTdG9yZXNBUEkgZnJvbSAnLi92ZWN0b3Itc3RvcmVzJztcbmltcG9ydCB7IEN1cnNvclBhZ2UsIHR5cGUgQ3Vyc29yUGFnZVBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL3BhZ2luYXRpb24nO1xuXG5leHBvcnQgY2xhc3MgRmlsZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB2ZWN0b3Igc3RvcmUgZmlsZSBieSBhdHRhY2hpbmcgYVxuICAgKiBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgdG8gYVxuICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KS5cbiAgICovXG4gIGNyZWF0ZShcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgYm9keTogRmlsZUNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFZlY3RvclN0b3JlRmlsZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlc2AsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSB2ZWN0b3Igc3RvcmUgZmlsZS5cbiAgICovXG4gIHJldHJpZXZlKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBmaWxlSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFZlY3RvclN0b3JlRmlsZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9L2ZpbGVzLyR7ZmlsZUlkfWAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBmaWxlcy5cbiAgICovXG4gIGxpc3QoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIHF1ZXJ5PzogRmlsZUxpc3RQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8VmVjdG9yU3RvcmVGaWxlc1BhZ2UsIFZlY3RvclN0b3JlRmlsZT47XG4gIGxpc3QoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFZlY3RvclN0b3JlRmlsZXNQYWdlLCBWZWN0b3JTdG9yZUZpbGU+O1xuICBsaXN0KFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBxdWVyeTogRmlsZUxpc3RQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8VmVjdG9yU3RvcmVGaWxlc1BhZ2UsIFZlY3RvclN0b3JlRmlsZT4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdCh2ZWN0b3JTdG9yZUlkLCB7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH0vZmlsZXNgLCBWZWN0b3JTdG9yZUZpbGVzUGFnZSwge1xuICAgICAgcXVlcnksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSB2ZWN0b3Igc3RvcmUgZmlsZS4gVGhpcyB3aWxsIHJlbW92ZSB0aGUgZmlsZSBmcm9tIHRoZSB2ZWN0b3Igc3RvcmUgYnV0XG4gICAqIHRoZSBmaWxlIGl0c2VsZiB3aWxsIG5vdCBiZSBkZWxldGVkLiBUbyBkZWxldGUgdGhlIGZpbGUsIHVzZSB0aGVcbiAgICogW2RlbGV0ZSBmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL2RlbGV0ZSlcbiAgICogZW5kcG9pbnQuXG4gICAqL1xuICBkZWwoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGZpbGVJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VmVjdG9yU3RvcmVGaWxlRGVsZXRlZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZGVsZXRlKGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9L2ZpbGVzLyR7ZmlsZUlkfWAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBhIGZpbGUgdG8gdGhlIGdpdmVuIHZlY3RvciBzdG9yZSBhbmQgd2FpdCBmb3IgaXQgdG8gYmUgcHJvY2Vzc2VkLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQW5kUG9sbChcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgYm9keTogRmlsZUNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyAmIHsgcG9sbEludGVydmFsTXM/OiBudW1iZXIgfSxcbiAgKTogUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGU+IHtcbiAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy5jcmVhdGUodmVjdG9yU3RvcmVJZCwgYm9keSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucG9sbCh2ZWN0b3JTdG9yZUlkLCBmaWxlLmlkLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0IGZvciB0aGUgdmVjdG9yIHN0b3JlIGZpbGUgdG8gZmluaXNoIHByb2Nlc3NpbmcuXG4gICAqXG4gICAqIE5vdGU6IHRoaXMgd2lsbCByZXR1cm4gZXZlbiBpZiB0aGUgZmlsZSBmYWlsZWQgdG8gcHJvY2VzcywgeW91IG5lZWQgdG8gY2hlY2tcbiAgICogZmlsZS5sYXN0X2Vycm9yIGFuZCBmaWxlLnN0YXR1cyB0byBoYW5kbGUgdGhlc2UgY2FzZXNcbiAgICovXG4gIGFzeW5jIHBvbGwoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGZpbGVJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zICYgeyBwb2xsSW50ZXJ2YWxNcz86IG51bWJlciB9LFxuICApOiBQcm9taXNlPFZlY3RvclN0b3JlRmlsZT4ge1xuICAgIGNvbnN0IGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1Qb2xsLUhlbHBlcic6ICd0cnVlJyB9O1xuICAgIGlmIChvcHRpb25zPy5wb2xsSW50ZXJ2YWxNcykge1xuICAgICAgaGVhZGVyc1snWC1TdGFpbmxlc3MtQ3VzdG9tLVBvbGwtSW50ZXJ2YWwnXSA9IG9wdGlvbnMucG9sbEludGVydmFsTXMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGZpbGVSZXNwb25zZSA9IGF3YWl0IHRoaXMucmV0cmlldmUodmVjdG9yU3RvcmVJZCwgZmlsZUlkLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICB9KS53aXRoUmVzcG9uc2UoKTtcblxuICAgICAgY29uc3QgZmlsZSA9IGZpbGVSZXNwb25zZS5kYXRhO1xuXG4gICAgICBzd2l0Y2ggKGZpbGUuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgJ2luX3Byb2dyZXNzJzpcbiAgICAgICAgICBsZXQgc2xlZXBJbnRlcnZhbCA9IDUwMDA7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucz8ucG9sbEludGVydmFsTXMpIHtcbiAgICAgICAgICAgIHNsZWVwSW50ZXJ2YWwgPSBvcHRpb25zLnBvbGxJbnRlcnZhbE1zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJJbnRlcnZhbCA9IGZpbGVSZXNwb25zZS5yZXNwb25zZS5oZWFkZXJzLmdldCgnb3BlbmFpLXBvbGwtYWZ0ZXItbXMnKTtcbiAgICAgICAgICAgIGlmIChoZWFkZXJJbnRlcnZhbCkge1xuICAgICAgICAgICAgICBjb25zdCBoZWFkZXJJbnRlcnZhbE1zID0gcGFyc2VJbnQoaGVhZGVySW50ZXJ2YWwpO1xuICAgICAgICAgICAgICBpZiAoIWlzTmFOKGhlYWRlckludGVydmFsTXMpKSB7XG4gICAgICAgICAgICAgICAgc2xlZXBJbnRlcnZhbCA9IGhlYWRlckludGVydmFsTXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgc2xlZXAoc2xlZXBJbnRlcnZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwbG9hZCBhIGZpbGUgdG8gdGhlIGBmaWxlc2AgQVBJIGFuZCB0aGVuIGF0dGFjaCBpdCB0byB0aGUgZ2l2ZW4gdmVjdG9yIHN0b3JlLlxuICAgKlxuICAgKiBOb3RlIHRoZSBmaWxlIHdpbGwgYmUgYXN5bmNocm9ub3VzbHkgcHJvY2Vzc2VkICh5b3UgY2FuIHVzZSB0aGUgYWx0ZXJuYXRpdmVcbiAgICogcG9sbGluZyBoZWxwZXIgbWV0aG9kIHRvIHdhaXQgZm9yIHByb2Nlc3NpbmcgdG8gY29tcGxldGUpLlxuICAgKi9cbiAgYXN5bmMgdXBsb2FkKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBmaWxlOiBVcGxvYWRhYmxlLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBQcm9taXNlPFZlY3RvclN0b3JlRmlsZT4ge1xuICAgIGNvbnN0IGZpbGVJbmZvID0gYXdhaXQgdGhpcy5fY2xpZW50LmZpbGVzLmNyZWF0ZSh7IGZpbGU6IGZpbGUsIHB1cnBvc2U6ICdhc3Npc3RhbnRzJyB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGUodmVjdG9yU3RvcmVJZCwgeyBmaWxlX2lkOiBmaWxlSW5mby5pZCB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBmaWxlIHRvIGEgdmVjdG9yIHN0b3JlIGFuZCBwb2xsIHVudGlsIHByb2Nlc3NpbmcgaXMgY29tcGxldGUuXG4gICAqL1xuICBhc3luYyB1cGxvYWRBbmRQb2xsKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBmaWxlOiBVcGxvYWRhYmxlLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zICYgeyBwb2xsSW50ZXJ2YWxNcz86IG51bWJlciB9LFxuICApOiBQcm9taXNlPFZlY3RvclN0b3JlRmlsZT4ge1xuICAgIGNvbnN0IGZpbGVJbmZvID0gYXdhaXQgdGhpcy51cGxvYWQodmVjdG9yU3RvcmVJZCwgZmlsZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucG9sbCh2ZWN0b3JTdG9yZUlkLCBmaWxlSW5mby5pZCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFZlY3RvclN0b3JlRmlsZXNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxWZWN0b3JTdG9yZUZpbGU+IHt9XG5cbi8qKlxuICogQSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIGEgdmVjdG9yIHN0b3JlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlRmlsZSB7XG4gIC8qKlxuICAgKiBUaGUgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHZlY3RvciBzdG9yZSBmaWxlIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbGFzdCBlcnJvciBhc3NvY2lhdGVkIHdpdGggdGhpcyB2ZWN0b3Igc3RvcmUgZmlsZS4gV2lsbCBiZSBgbnVsbGAgaWYgdGhlcmVcbiAgICogYXJlIG5vIGVycm9ycy5cbiAgICovXG4gIGxhc3RfZXJyb3I6IFZlY3RvclN0b3JlRmlsZS5MYXN0RXJyb3IgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgdmVjdG9yX3N0b3JlLmZpbGVgLlxuICAgKi9cbiAgb2JqZWN0OiAndmVjdG9yX3N0b3JlLmZpbGUnO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhdHVzIG9mIHRoZSB2ZWN0b3Igc3RvcmUgZmlsZSwgd2hpY2ggY2FuIGJlIGVpdGhlciBgaW5fcHJvZ3Jlc3NgLFxuICAgKiBgY29tcGxldGVkYCwgYGNhbmNlbGxlZGAsIG9yIGBmYWlsZWRgLiBUaGUgc3RhdHVzIGBjb21wbGV0ZWRgIGluZGljYXRlcyB0aGF0IHRoZVxuICAgKiB2ZWN0b3Igc3RvcmUgZmlsZSBpcyByZWFkeSBmb3IgdXNlLlxuICAgKi9cbiAgc3RhdHVzOiAnaW5fcHJvZ3Jlc3MnIHwgJ2NvbXBsZXRlZCcgfCAnY2FuY2VsbGVkJyB8ICdmYWlsZWQnO1xuXG4gIC8qKlxuICAgKiBUaGUgdG90YWwgdmVjdG9yIHN0b3JlIHVzYWdlIGluIGJ5dGVzLiBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgZGlmZmVyZW50IGZyb20gdGhlXG4gICAqIG9yaWdpbmFsIGZpbGUgc2l6ZS5cbiAgICovXG4gIHVzYWdlX2J5dGVzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGVcbiAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICogdGhhdCB0aGUgW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIGlzXG4gICAqIGF0dGFjaGVkIHRvLlxuICAgKi9cbiAgdmVjdG9yX3N0b3JlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBzdHJhdGVneSB1c2VkIHRvIGNodW5rIHRoZSBmaWxlLlxuICAgKi9cbiAgY2h1bmtpbmdfc3RyYXRlZ3k/OiBWZWN0b3JTdG9yZXNBUEkuRmlsZUNodW5raW5nU3RyYXRlZ3k7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVmVjdG9yU3RvcmVGaWxlIHtcbiAgLyoqXG4gICAqIFRoZSBsYXN0IGVycm9yIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHZlY3RvciBzdG9yZSBmaWxlLiBXaWxsIGJlIGBudWxsYCBpZiB0aGVyZVxuICAgKiBhcmUgbm8gZXJyb3JzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBMYXN0RXJyb3Ige1xuICAgIC8qKlxuICAgICAqIE9uZSBvZiBgc2VydmVyX2Vycm9yYCBvciBgcmF0ZV9saW1pdF9leGNlZWRlZGAuXG4gICAgICovXG4gICAgY29kZTogJ3NlcnZlcl9lcnJvcicgfCAndW5zdXBwb3J0ZWRfZmlsZScgfCAnaW52YWxpZF9maWxlJztcblxuICAgIC8qKlxuICAgICAqIEEgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGVycm9yLlxuICAgICAqL1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlRmlsZURlbGV0ZWQge1xuICBpZDogc3RyaW5nO1xuXG4gIGRlbGV0ZWQ6IGJvb2xlYW47XG5cbiAgb2JqZWN0OiAndmVjdG9yX3N0b3JlLmZpbGUuZGVsZXRlZCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUNyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRCB0aGF0IHRoZVxuICAgKiB2ZWN0b3Igc3RvcmUgc2hvdWxkIHVzZS4gVXNlZnVsIGZvciB0b29scyBsaWtlIGBmaWxlX3NlYXJjaGAgdGhhdCBjYW4gYWNjZXNzXG4gICAqIGZpbGVzLlxuICAgKi9cbiAgZmlsZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY2h1bmtpbmcgc3RyYXRlZ3kgdXNlZCB0byBjaHVuayB0aGUgZmlsZShzKS4gSWYgbm90IHNldCwgd2lsbCB1c2UgdGhlIGBhdXRvYFxuICAgKiBzdHJhdGVneS4gT25seSBhcHBsaWNhYmxlIGlmIGBmaWxlX2lkc2AgaXMgbm9uLWVtcHR5LlxuICAgKi9cbiAgY2h1bmtpbmdfc3RyYXRlZ3k/OiBWZWN0b3JTdG9yZXNBUEkuRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlTGlzdFBhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge1xuICAvKipcbiAgICogQSBjdXJzb3IgZm9yIHVzZSBpbiBwYWdpbmF0aW9uLiBgYmVmb3JlYCBpcyBhbiBvYmplY3QgSUQgdGhhdCBkZWZpbmVzIHlvdXIgcGxhY2VcbiAgICogaW4gdGhlIGxpc3QuIEZvciBpbnN0YW5jZSwgaWYgeW91IG1ha2UgYSBsaXN0IHJlcXVlc3QgYW5kIHJlY2VpdmUgMTAwIG9iamVjdHMsXG4gICAqIHN0YXJ0aW5nIHdpdGggb2JqX2ZvbywgeW91ciBzdWJzZXF1ZW50IGNhbGwgY2FuIGluY2x1ZGUgYmVmb3JlPW9ial9mb28gaW4gb3JkZXJcbiAgICogdG8gZmV0Y2ggdGhlIHByZXZpb3VzIHBhZ2Ugb2YgdGhlIGxpc3QuXG4gICAqL1xuICBiZWZvcmU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZpbHRlciBieSBmaWxlIHN0YXR1cy4gT25lIG9mIGBpbl9wcm9ncmVzc2AsIGBjb21wbGV0ZWRgLCBgZmFpbGVkYCwgYGNhbmNlbGxlZGAuXG4gICAqL1xuICBmaWx0ZXI/OiAnaW5fcHJvZ3Jlc3MnIHwgJ2NvbXBsZXRlZCcgfCAnZmFpbGVkJyB8ICdjYW5jZWxsZWQnO1xuXG4gIC8qKlxuICAgKiBTb3J0IG9yZGVyIGJ5IHRoZSBgY3JlYXRlZF9hdGAgdGltZXN0YW1wIG9mIHRoZSBvYmplY3RzLiBgYXNjYCBmb3IgYXNjZW5kaW5nXG4gICAqIG9yZGVyIGFuZCBgZGVzY2AgZm9yIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAqL1xuICBvcmRlcj86ICdhc2MnIHwgJ2Rlc2MnO1xufVxuXG5GaWxlcy5WZWN0b3JTdG9yZUZpbGVzUGFnZSA9IFZlY3RvclN0b3JlRmlsZXNQYWdlO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgRmlsZXMge1xuICBleHBvcnQge1xuICAgIHR5cGUgVmVjdG9yU3RvcmVGaWxlIGFzIFZlY3RvclN0b3JlRmlsZSxcbiAgICB0eXBlIFZlY3RvclN0b3JlRmlsZURlbGV0ZWQgYXMgVmVjdG9yU3RvcmVGaWxlRGVsZXRlZCxcbiAgICBWZWN0b3JTdG9yZUZpbGVzUGFnZSBhcyBWZWN0b3JTdG9yZUZpbGVzUGFnZSxcbiAgICB0eXBlIEZpbGVDcmVhdGVQYXJhbXMgYXMgRmlsZUNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIEZpbGVMaXN0UGFyYW1zIGFzIEZpbGVMaXN0UGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCB7IFVwbG9hZGFibGUgfSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCB7IGFsbFNldHRsZWRXaXRoVGhyb3cgfSBmcm9tICcuLi8uLi8uLi9saWIvVXRpbCc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgRmlsZXNBUEkgZnJvbSAnLi9maWxlcyc7XG5pbXBvcnQgeyBWZWN0b3JTdG9yZUZpbGVzUGFnZSB9IGZyb20gJy4vZmlsZXMnO1xuaW1wb3J0ICogYXMgVmVjdG9yU3RvcmVzQVBJIGZyb20gJy4vdmVjdG9yLXN0b3Jlcyc7XG5pbXBvcnQgeyB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9wYWdpbmF0aW9uJztcblxuZXhwb3J0IGNsYXNzIEZpbGVCYXRjaGVzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlIGEgdmVjdG9yIHN0b3JlIGZpbGUgYmF0Y2guXG4gICAqL1xuICBjcmVhdGUoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGJvZHk6IEZpbGVCYXRjaENyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFZlY3RvclN0b3JlRmlsZUJhdGNoPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9L2ZpbGVfYmF0Y2hlc2AsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSB2ZWN0b3Igc3RvcmUgZmlsZSBiYXRjaC5cbiAgICovXG4gIHJldHJpZXZlKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBiYXRjaElkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVCYXRjaD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9L2ZpbGVfYmF0Y2hlcy8ke2JhdGNoSWR9YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIGEgdmVjdG9yIHN0b3JlIGZpbGUgYmF0Y2guIFRoaXMgYXR0ZW1wdHMgdG8gY2FuY2VsIHRoZSBwcm9jZXNzaW5nIG9mXG4gICAqIGZpbGVzIGluIHRoaXMgYmF0Y2ggYXMgc29vbiBhcyBwb3NzaWJsZS5cbiAgICovXG4gIGNhbmNlbChcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgYmF0Y2hJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VmVjdG9yU3RvcmVGaWxlQmF0Y2g+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH0vZmlsZV9iYXRjaGVzLyR7YmF0Y2hJZH0vY2FuY2VsYCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdmVjdG9yIHN0b3JlIGJhdGNoIGFuZCBwb2xsIHVudGlsIGFsbCBmaWxlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQW5kUG9sbChcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgYm9keTogRmlsZUJhdGNoQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zICYgeyBwb2xsSW50ZXJ2YWxNcz86IG51bWJlciB9LFxuICApOiBQcm9taXNlPFZlY3RvclN0b3JlRmlsZUJhdGNoPiB7XG4gICAgY29uc3QgYmF0Y2ggPSBhd2FpdCB0aGlzLmNyZWF0ZSh2ZWN0b3JTdG9yZUlkLCBib2R5KTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5wb2xsKHZlY3RvclN0b3JlSWQsIGJhdGNoLmlkLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgZmlsZXMgaW4gYSBiYXRjaC5cbiAgICovXG4gIGxpc3RGaWxlcyhcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgYmF0Y2hJZDogc3RyaW5nLFxuICAgIHF1ZXJ5PzogRmlsZUJhdGNoTGlzdEZpbGVzUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFZlY3RvclN0b3JlRmlsZXNQYWdlLCBGaWxlc0FQSS5WZWN0b3JTdG9yZUZpbGU+O1xuICBsaXN0RmlsZXMoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGJhdGNoSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVzUGFnZSwgRmlsZXNBUEkuVmVjdG9yU3RvcmVGaWxlPjtcbiAgbGlzdEZpbGVzKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBiYXRjaElkOiBzdHJpbmcsXG4gICAgcXVlcnk6IEZpbGVCYXRjaExpc3RGaWxlc1BhcmFtcyB8IENvcmUuUmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVzUGFnZSwgRmlsZXNBUEkuVmVjdG9yU3RvcmVGaWxlPiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0RmlsZXModmVjdG9yU3RvcmVJZCwgYmF0Y2hJZCwge30sIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KFxuICAgICAgYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH0vZmlsZV9iYXRjaGVzLyR7YmF0Y2hJZH0vZmlsZXNgLFxuICAgICAgVmVjdG9yU3RvcmVGaWxlc1BhZ2UsXG4gICAgICB7IHF1ZXJ5LCAuLi5vcHRpb25zLCBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9IH0sXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0IGZvciB0aGUgZ2l2ZW4gZmlsZSBiYXRjaCB0byBiZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIE5vdGU6IHRoaXMgd2lsbCByZXR1cm4gZXZlbiBpZiBvbmUgb2YgdGhlIGZpbGVzIGZhaWxlZCB0byBwcm9jZXNzLCB5b3UgbmVlZCB0b1xuICAgKiBjaGVjayBiYXRjaC5maWxlX2NvdW50cy5mYWlsZWRfY291bnQgdG8gaGFuZGxlIHRoaXMgY2FzZS5cbiAgICovXG4gIGFzeW5jIHBvbGwoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGJhdGNoSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyAmIHsgcG9sbEludGVydmFsTXM/OiBudW1iZXIgfSxcbiAgKTogUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVCYXRjaD4ge1xuICAgIGNvbnN0IGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1Qb2xsLUhlbHBlcic6ICd0cnVlJyB9O1xuICAgIGlmIChvcHRpb25zPy5wb2xsSW50ZXJ2YWxNcykge1xuICAgICAgaGVhZGVyc1snWC1TdGFpbmxlc3MtQ3VzdG9tLVBvbGwtSW50ZXJ2YWwnXSA9IG9wdGlvbnMucG9sbEludGVydmFsTXMudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBkYXRhOiBiYXRjaCwgcmVzcG9uc2UgfSA9IGF3YWl0IHRoaXMucmV0cmlldmUodmVjdG9yU3RvcmVJZCwgYmF0Y2hJZCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgfSkud2l0aFJlc3BvbnNlKCk7XG5cbiAgICAgIHN3aXRjaCAoYmF0Y2guc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgJ2luX3Byb2dyZXNzJzpcbiAgICAgICAgICBsZXQgc2xlZXBJbnRlcnZhbCA9IDUwMDA7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucz8ucG9sbEludGVydmFsTXMpIHtcbiAgICAgICAgICAgIHNsZWVwSW50ZXJ2YWwgPSBvcHRpb25zLnBvbGxJbnRlcnZhbE1zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJJbnRlcnZhbCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdvcGVuYWktcG9sbC1hZnRlci1tcycpO1xuICAgICAgICAgICAgaWYgKGhlYWRlckludGVydmFsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGhlYWRlckludGVydmFsTXMgPSBwYXJzZUludChoZWFkZXJJbnRlcnZhbCk7XG4gICAgICAgICAgICAgIGlmICghaXNOYU4oaGVhZGVySW50ZXJ2YWxNcykpIHtcbiAgICAgICAgICAgICAgICBzbGVlcEludGVydmFsID0gaGVhZGVySW50ZXJ2YWxNcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBzbGVlcChzbGVlcEludGVydmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgY2FzZSAnY2FuY2VsbGVkJzpcbiAgICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgICByZXR1cm4gYmF0Y2g7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwbG9hZHMgdGhlIGdpdmVuIGZpbGVzIGNvbmN1cnJlbnRseSBhbmQgdGhlbiBjcmVhdGVzIGEgdmVjdG9yIHN0b3JlIGZpbGUgYmF0Y2guXG4gICAqXG4gICAqIFRoZSBjb25jdXJyZW5jeSBsaW1pdCBpcyBjb25maWd1cmFibGUgdXNpbmcgdGhlIGBtYXhDb25jdXJyZW5jeWAgcGFyYW1ldGVyLlxuICAgKi9cbiAgYXN5bmMgdXBsb2FkQW5kUG9sbChcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgeyBmaWxlcywgZmlsZUlkcyA9IFtdIH06IHsgZmlsZXM6IFVwbG9hZGFibGVbXTsgZmlsZUlkcz86IHN0cmluZ1tdIH0sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMgJiB7IHBvbGxJbnRlcnZhbE1zPzogbnVtYmVyOyBtYXhDb25jdXJyZW5jeT86IG51bWJlciB9LFxuICApOiBQcm9taXNlPFZlY3RvclN0b3JlRmlsZUJhdGNoPiB7XG4gICAgaWYgKGZpbGVzID09IG51bGwgfHwgZmlsZXMubGVuZ3RoID09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE5vIFxcYGZpbGVzXFxgIHByb3ZpZGVkIHRvIHByb2Nlc3MuIElmIHlvdSd2ZSBhbHJlYWR5IHVwbG9hZGVkIGZpbGVzIHlvdSBzaG91bGQgdXNlIFxcYC5jcmVhdGVBbmRQb2xsKClcXGAgaW5zdGVhZGAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbmZpZ3VyZWRDb25jdXJyZW5jeSA9IG9wdGlvbnM/Lm1heENvbmN1cnJlbmN5ID8/IDU7XG5cbiAgICAvLyBXZSBjYXAgdGhlIG51bWJlciBvZiB3b3JrZXJzIGF0IHRoZSBudW1iZXIgb2YgZmlsZXMgKHNvIHdlIGRvbid0IHN0YXJ0IGFueSB1bm5lY2Vzc2FyeSB3b3JrZXJzKVxuICAgIGNvbnN0IGNvbmN1cnJlbmN5TGltaXQgPSBNYXRoLm1pbihjb25maWd1cmVkQ29uY3VycmVuY3ksIGZpbGVzLmxlbmd0aCk7XG5cbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLl9jbGllbnQ7XG4gICAgY29uc3QgZmlsZUl0ZXJhdG9yID0gZmlsZXMudmFsdWVzKCk7XG4gICAgY29uc3QgYWxsRmlsZUlkczogc3RyaW5nW10gPSBbLi4uZmlsZUlkc107XG5cbiAgICAvLyBUaGlzIGNvZGUgaXMgYmFzZWQgb24gdGhpcyBkZXNpZ24uIFRoZSBsaWJyYXJpZXMgZG9uJ3QgYWNjb21tb2RhdGUgb3VyIGVudmlyb25tZW50IGxpbWl0cy5cbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MDYzOTQzMi93aGF0LWlzLXRoZS1iZXN0LXdheS10by1saW1pdC1jb25jdXJyZW5jeS13aGVuLXVzaW5nLWVzNnMtcHJvbWlzZS1hbGxcbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzRmlsZXMoaXRlcmF0b3I6IEl0ZXJhYmxlSXRlcmF0b3I8VXBsb2FkYWJsZT4pIHtcbiAgICAgIGZvciAobGV0IGl0ZW0gb2YgaXRlcmF0b3IpIHtcbiAgICAgICAgY29uc3QgZmlsZU9iaiA9IGF3YWl0IGNsaWVudC5maWxlcy5jcmVhdGUoeyBmaWxlOiBpdGVtLCBwdXJwb3NlOiAnYXNzaXN0YW50cycgfSwgb3B0aW9ucyk7XG4gICAgICAgIGFsbEZpbGVJZHMucHVzaChmaWxlT2JqLmlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGFydCB3b3JrZXJzIHRvIHByb2Nlc3MgcmVzdWx0c1xuICAgIGNvbnN0IHdvcmtlcnMgPSBBcnJheShjb25jdXJyZW5jeUxpbWl0KS5maWxsKGZpbGVJdGVyYXRvcikubWFwKHByb2Nlc3NGaWxlcyk7XG5cbiAgICAvLyBXYWl0IGZvciBhbGwgcHJvY2Vzc2luZyB0byBjb21wbGV0ZS5cbiAgICBhd2FpdCBhbGxTZXR0bGVkV2l0aFRocm93KHdvcmtlcnMpO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlQW5kUG9sbCh2ZWN0b3JTdG9yZUlkLCB7XG4gICAgICBmaWxlX2lkczogYWxsRmlsZUlkcyxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEEgYmF0Y2ggb2YgZmlsZXMgYXR0YWNoZWQgdG8gYSB2ZWN0b3Igc3RvcmUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmVGaWxlQmF0Y2gge1xuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSB2ZWN0b3Igc3RvcmUgZmlsZXMgYmF0Y2ggd2FzXG4gICAqIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgZmlsZV9jb3VudHM6IFZlY3RvclN0b3JlRmlsZUJhdGNoLkZpbGVDb3VudHM7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGB2ZWN0b3Jfc3RvcmUuZmlsZV9iYXRjaGAuXG4gICAqL1xuICBvYmplY3Q6ICd2ZWN0b3Jfc3RvcmUuZmlsZXNfYmF0Y2gnO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhdHVzIG9mIHRoZSB2ZWN0b3Igc3RvcmUgZmlsZXMgYmF0Y2gsIHdoaWNoIGNhbiBiZSBlaXRoZXIgYGluX3Byb2dyZXNzYCxcbiAgICogYGNvbXBsZXRlZGAsIGBjYW5jZWxsZWRgIG9yIGBmYWlsZWRgLlxuICAgKi9cbiAgc3RhdHVzOiAnaW5fcHJvZ3Jlc3MnIHwgJ2NvbXBsZXRlZCcgfCAnY2FuY2VsbGVkJyB8ICdmYWlsZWQnO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlXG4gICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAqIHRoYXQgdGhlIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBpc1xuICAgKiBhdHRhY2hlZCB0by5cbiAgICovXG4gIHZlY3Rvcl9zdG9yZV9pZDogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFZlY3RvclN0b3JlRmlsZUJhdGNoIHtcbiAgZXhwb3J0IGludGVyZmFjZSBGaWxlQ291bnRzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGZpbGVzIHRoYXQgd2hlcmUgY2FuY2VsbGVkLlxuICAgICAqL1xuICAgIGNhbmNlbGxlZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBmaWxlcyB0aGF0IGhhdmUgYmVlbiBwcm9jZXNzZWQuXG4gICAgICovXG4gICAgY29tcGxldGVkOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGZpbGVzIHRoYXQgaGF2ZSBmYWlsZWQgdG8gcHJvY2Vzcy5cbiAgICAgKi9cbiAgICBmYWlsZWQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZmlsZXMgdGhhdCBhcmUgY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgKi9cbiAgICBpbl9wcm9ncmVzczogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvdGFsIG51bWJlciBvZiBmaWxlcy5cbiAgICAgKi9cbiAgICB0b3RhbDogbnVtYmVyO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUJhdGNoQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIHRoYXRcbiAgICogdGhlIHZlY3RvciBzdG9yZSBzaG91bGQgdXNlLiBVc2VmdWwgZm9yIHRvb2xzIGxpa2UgYGZpbGVfc2VhcmNoYCB0aGF0IGNhbiBhY2Nlc3NcbiAgICogZmlsZXMuXG4gICAqL1xuICBmaWxlX2lkczogQXJyYXk8c3RyaW5nPjtcblxuICAvKipcbiAgICogVGhlIGNodW5raW5nIHN0cmF0ZWd5IHVzZWQgdG8gY2h1bmsgdGhlIGZpbGUocykuIElmIG5vdCBzZXQsIHdpbGwgdXNlIHRoZSBgYXV0b2BcbiAgICogc3RyYXRlZ3kuIE9ubHkgYXBwbGljYWJsZSBpZiBgZmlsZV9pZHNgIGlzIG5vbi1lbXB0eS5cbiAgICovXG4gIGNodW5raW5nX3N0cmF0ZWd5PzogVmVjdG9yU3RvcmVzQVBJLkZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUJhdGNoTGlzdEZpbGVzUGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIGN1cnNvciBmb3IgdXNlIGluIHBhZ2luYXRpb24uIGBiZWZvcmVgIGlzIGFuIG9iamVjdCBJRCB0aGF0IGRlZmluZXMgeW91ciBwbGFjZVxuICAgKiBpbiB0aGUgbGlzdC4gRm9yIGluc3RhbmNlLCBpZiB5b3UgbWFrZSBhIGxpc3QgcmVxdWVzdCBhbmQgcmVjZWl2ZSAxMDAgb2JqZWN0cyxcbiAgICogc3RhcnRpbmcgd2l0aCBvYmpfZm9vLCB5b3VyIHN1YnNlcXVlbnQgY2FsbCBjYW4gaW5jbHVkZSBiZWZvcmU9b2JqX2ZvbyBpbiBvcmRlclxuICAgKiB0byBmZXRjaCB0aGUgcHJldmlvdXMgcGFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGJlZm9yZT86IHN0cmluZztcblxuICAvKipcbiAgICogRmlsdGVyIGJ5IGZpbGUgc3RhdHVzLiBPbmUgb2YgYGluX3Byb2dyZXNzYCwgYGNvbXBsZXRlZGAsIGBmYWlsZWRgLCBgY2FuY2VsbGVkYC5cbiAgICovXG4gIGZpbHRlcj86ICdpbl9wcm9ncmVzcycgfCAnY29tcGxldGVkJyB8ICdmYWlsZWQnIHwgJ2NhbmNlbGxlZCc7XG5cbiAgLyoqXG4gICAqIFNvcnQgb3JkZXIgYnkgdGhlIGBjcmVhdGVkX2F0YCB0aW1lc3RhbXAgb2YgdGhlIG9iamVjdHMuIGBhc2NgIGZvciBhc2NlbmRpbmdcbiAgICogb3JkZXIgYW5kIGBkZXNjYCBmb3IgZGVzY2VuZGluZyBvcmRlci5cbiAgICovXG4gIG9yZGVyPzogJ2FzYycgfCAnZGVzYyc7XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBGaWxlQmF0Y2hlcyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBWZWN0b3JTdG9yZUZpbGVCYXRjaCBhcyBWZWN0b3JTdG9yZUZpbGVCYXRjaCxcbiAgICB0eXBlIEZpbGVCYXRjaENyZWF0ZVBhcmFtcyBhcyBGaWxlQmF0Y2hDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBGaWxlQmF0Y2hMaXN0RmlsZXNQYXJhbXMgYXMgRmlsZUJhdGNoTGlzdEZpbGVzUGFyYW1zLFxuICB9O1xufVxuXG5leHBvcnQgeyBWZWN0b3JTdG9yZUZpbGVzUGFnZSB9O1xuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIEZpbGVCYXRjaGVzQVBJIGZyb20gJy4vZmlsZS1iYXRjaGVzJztcbmltcG9ydCB7XG4gIEZpbGVCYXRjaENyZWF0ZVBhcmFtcyxcbiAgRmlsZUJhdGNoTGlzdEZpbGVzUGFyYW1zLFxuICBGaWxlQmF0Y2hlcyxcbiAgVmVjdG9yU3RvcmVGaWxlQmF0Y2gsXG59IGZyb20gJy4vZmlsZS1iYXRjaGVzJztcbmltcG9ydCAqIGFzIEZpbGVzQVBJIGZyb20gJy4vZmlsZXMnO1xuaW1wb3J0IHtcbiAgRmlsZUNyZWF0ZVBhcmFtcyxcbiAgRmlsZUxpc3RQYXJhbXMsXG4gIEZpbGVzLFxuICBWZWN0b3JTdG9yZUZpbGUsXG4gIFZlY3RvclN0b3JlRmlsZURlbGV0ZWQsXG4gIFZlY3RvclN0b3JlRmlsZXNQYWdlLFxufSBmcm9tICcuL2ZpbGVzJztcbmltcG9ydCB7IEN1cnNvclBhZ2UsIHR5cGUgQ3Vyc29yUGFnZVBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL3BhZ2luYXRpb24nO1xuXG5leHBvcnQgY2xhc3MgVmVjdG9yU3RvcmVzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICBmaWxlczogRmlsZXNBUEkuRmlsZXMgPSBuZXcgRmlsZXNBUEkuRmlsZXModGhpcy5fY2xpZW50KTtcbiAgZmlsZUJhdGNoZXM6IEZpbGVCYXRjaGVzQVBJLkZpbGVCYXRjaGVzID0gbmV3IEZpbGVCYXRjaGVzQVBJLkZpbGVCYXRjaGVzKHRoaXMuX2NsaWVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIGNyZWF0ZShib2R5OiBWZWN0b3JTdG9yZUNyZWF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8VmVjdG9yU3RvcmU+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy92ZWN0b3Jfc3RvcmVzJywge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIHJldHJpZXZlKHZlY3RvclN0b3JlSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8VmVjdG9yU3RvcmU+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfWAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIGEgdmVjdG9yIHN0b3JlLlxuICAgKi9cbiAgdXBkYXRlKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBib2R5OiBWZWN0b3JTdG9yZVVwZGF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFZlY3RvclN0b3JlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9YCwge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZXMuXG4gICAqL1xuICBsaXN0KFxuICAgIHF1ZXJ5PzogVmVjdG9yU3RvcmVMaXN0UGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFZlY3RvclN0b3Jlc1BhZ2UsIFZlY3RvclN0b3JlPjtcbiAgbGlzdChvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuUGFnZVByb21pc2U8VmVjdG9yU3RvcmVzUGFnZSwgVmVjdG9yU3RvcmU+O1xuICBsaXN0KFxuICAgIHF1ZXJ5OiBWZWN0b3JTdG9yZUxpc3RQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8VmVjdG9yU3RvcmVzUGFnZSwgVmVjdG9yU3RvcmU+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3Qoe30sIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KCcvdmVjdG9yX3N0b3JlcycsIFZlY3RvclN0b3Jlc1BhZ2UsIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgdmVjdG9yIHN0b3JlLlxuICAgKi9cbiAgZGVsKHZlY3RvclN0b3JlSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8VmVjdG9yU3RvcmVEZWxldGVkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5kZWxldGUoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVmVjdG9yU3RvcmVzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8VmVjdG9yU3RvcmU+IHt9XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgc3RyYXRlZ3kuIFRoaXMgc3RyYXRlZ3kgY3VycmVudGx5IHVzZXMgYSBgbWF4X2NodW5rX3NpemVfdG9rZW5zYCBvZlxuICogYDgwMGAgYW5kIGBjaHVua19vdmVybGFwX3Rva2Vuc2Agb2YgYDQwMGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXV0b0ZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0ge1xuICAvKipcbiAgICogQWx3YXlzIGBhdXRvYC5cbiAgICovXG4gIHR5cGU6ICdhdXRvJztcbn1cblxuLyoqXG4gKiBUaGUgc3RyYXRlZ3kgdXNlZCB0byBjaHVuayB0aGUgZmlsZS5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsZUNodW5raW5nU3RyYXRlZ3kgPSBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdCB8IE90aGVyRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3Q7XG5cbi8qKlxuICogVGhlIGNodW5raW5nIHN0cmF0ZWd5IHVzZWQgdG8gY2h1bmsgdGhlIGZpbGUocykuIElmIG5vdCBzZXQsIHdpbGwgdXNlIHRoZSBgYXV0b2BcbiAqIHN0cmF0ZWd5LiBPbmx5IGFwcGxpY2FibGUgaWYgYGZpbGVfaWRzYCBpcyBub24tZW1wdHkuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0gPSBBdXRvRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbSB8IFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0UGFyYW07XG5cbi8qKlxuICogVGhpcyBpcyByZXR1cm5lZCB3aGVuIHRoZSBjaHVua2luZyBzdHJhdGVneSBpcyB1bmtub3duLiBUeXBpY2FsbHksIHRoaXMgaXNcbiAqIGJlY2F1c2UgdGhlIGZpbGUgd2FzIGluZGV4ZWQgYmVmb3JlIHRoZSBgY2h1bmtpbmdfc3RyYXRlZ3lgIGNvbmNlcHQgd2FzXG4gKiBpbnRyb2R1Y2VkIGluIHRoZSBBUEkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3RoZXJGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdCB7XG4gIC8qKlxuICAgKiBBbHdheXMgYG90aGVyYC5cbiAgICovXG4gIHR5cGU6ICdvdGhlcic7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3kge1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiB0b2tlbnMgdGhhdCBvdmVybGFwIGJldHdlZW4gY2h1bmtzLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgNDAwYC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBvdmVybGFwIG11c3Qgbm90IGV4Y2VlZCBoYWxmIG9mIGBtYXhfY2h1bmtfc2l6ZV90b2tlbnNgLlxuICAgKi9cbiAgY2h1bmtfb3ZlcmxhcF90b2tlbnM6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHRva2VucyBpbiBlYWNoIGNodW5rLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgODAwYC4gVGhlXG4gICAqIG1pbmltdW0gdmFsdWUgaXMgYDEwMGAgYW5kIHRoZSBtYXhpbXVtIHZhbHVlIGlzIGA0MDk2YC5cbiAgICovXG4gIG1heF9jaHVua19zaXplX3Rva2VuczogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0IHtcbiAgc3RhdGljOiBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneTtcblxuICAvKipcbiAgICogQWx3YXlzIGBzdGF0aWNgLlxuICAgKi9cbiAgdHlwZTogJ3N0YXRpYyc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3RQYXJhbSB7XG4gIHN0YXRpYzogU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3k7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgc3RhdGljYC5cbiAgICovXG4gIHR5cGU6ICdzdGF0aWMnO1xufVxuXG4vKipcbiAqIEEgdmVjdG9yIHN0b3JlIGlzIGEgY29sbGVjdGlvbiBvZiBwcm9jZXNzZWQgZmlsZXMgY2FuIGJlIHVzZWQgYnkgdGhlXG4gKiBgZmlsZV9zZWFyY2hgIHRvb2wuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmUge1xuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSB2ZWN0b3Igc3RvcmUgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgZmlsZV9jb3VudHM6IFZlY3RvclN0b3JlLkZpbGVDb3VudHM7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHZlY3RvciBzdG9yZSB3YXMgbGFzdCBhY3RpdmUuXG4gICAqL1xuICBsYXN0X2FjdGl2ZV9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE6IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgdmVjdG9yIHN0b3JlLlxuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgdmVjdG9yX3N0b3JlYC5cbiAgICovXG4gIG9iamVjdDogJ3ZlY3Rvcl9zdG9yZSc7XG5cbiAgLyoqXG4gICAqIFRoZSBzdGF0dXMgb2YgdGhlIHZlY3RvciBzdG9yZSwgd2hpY2ggY2FuIGJlIGVpdGhlciBgZXhwaXJlZGAsIGBpbl9wcm9ncmVzc2AsIG9yXG4gICAqIGBjb21wbGV0ZWRgLiBBIHN0YXR1cyBvZiBgY29tcGxldGVkYCBpbmRpY2F0ZXMgdGhhdCB0aGUgdmVjdG9yIHN0b3JlIGlzIHJlYWR5XG4gICAqIGZvciB1c2UuXG4gICAqL1xuICBzdGF0dXM6ICdleHBpcmVkJyB8ICdpbl9wcm9ncmVzcycgfCAnY29tcGxldGVkJztcblxuICAvKipcbiAgICogVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyB1c2VkIGJ5IHRoZSBmaWxlcyBpbiB0aGUgdmVjdG9yIHN0b3JlLlxuICAgKi9cbiAgdXNhZ2VfYnl0ZXM6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGV4cGlyYXRpb24gcG9saWN5IGZvciBhIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIGV4cGlyZXNfYWZ0ZXI/OiBWZWN0b3JTdG9yZS5FeHBpcmVzQWZ0ZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHZlY3RvciBzdG9yZSB3aWxsIGV4cGlyZS5cbiAgICovXG4gIGV4cGlyZXNfYXQ/OiBudW1iZXIgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFZlY3RvclN0b3JlIHtcbiAgZXhwb3J0IGludGVyZmFjZSBGaWxlQ291bnRzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGZpbGVzIHRoYXQgd2VyZSBjYW5jZWxsZWQuXG4gICAgICovXG4gICAgY2FuY2VsbGVkOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGZpbGVzIHRoYXQgaGF2ZSBiZWVuIHN1Y2Nlc3NmdWxseSBwcm9jZXNzZWQuXG4gICAgICovXG4gICAgY29tcGxldGVkOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGZpbGVzIHRoYXQgaGF2ZSBmYWlsZWQgdG8gcHJvY2Vzcy5cbiAgICAgKi9cbiAgICBmYWlsZWQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZmlsZXMgdGhhdCBhcmUgY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgKi9cbiAgICBpbl9wcm9ncmVzczogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvdGFsIG51bWJlciBvZiBmaWxlcy5cbiAgICAgKi9cbiAgICB0b3RhbDogbnVtYmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBleHBpcmF0aW9uIHBvbGljeSBmb3IgYSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEV4cGlyZXNBZnRlciB7XG4gICAgLyoqXG4gICAgICogQW5jaG9yIHRpbWVzdGFtcCBhZnRlciB3aGljaCB0aGUgZXhwaXJhdGlvbiBwb2xpY3kgYXBwbGllcy4gU3VwcG9ydGVkIGFuY2hvcnM6XG4gICAgICogYGxhc3RfYWN0aXZlX2F0YC5cbiAgICAgKi9cbiAgICBhbmNob3I6ICdsYXN0X2FjdGl2ZV9hdCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRheXMgYWZ0ZXIgdGhlIGFuY2hvciB0aW1lIHRoYXQgdGhlIHZlY3RvciBzdG9yZSB3aWxsIGV4cGlyZS5cbiAgICAgKi9cbiAgICBkYXlzOiBudW1iZXI7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZURlbGV0ZWQge1xuICBpZDogc3RyaW5nO1xuXG4gIGRlbGV0ZWQ6IGJvb2xlYW47XG5cbiAgb2JqZWN0OiAndmVjdG9yX3N0b3JlLmRlbGV0ZWQnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBjaHVua2luZyBzdHJhdGVneSB1c2VkIHRvIGNodW5rIHRoZSBmaWxlKHMpLiBJZiBub3Qgc2V0LCB3aWxsIHVzZSB0aGUgYGF1dG9gXG4gICAqIHN0cmF0ZWd5LiBPbmx5IGFwcGxpY2FibGUgaWYgYGZpbGVfaWRzYCBpcyBub24tZW1wdHkuXG4gICAqL1xuICBjaHVua2luZ19zdHJhdGVneT86IEZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW07XG5cbiAgLyoqXG4gICAqIFRoZSBleHBpcmF0aW9uIHBvbGljeSBmb3IgYSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICBleHBpcmVzX2FmdGVyPzogVmVjdG9yU3RvcmVDcmVhdGVQYXJhbXMuRXhwaXJlc0FmdGVyO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyB0aGF0XG4gICAqIHRoZSB2ZWN0b3Igc3RvcmUgc2hvdWxkIHVzZS4gVXNlZnVsIGZvciB0b29scyBsaWtlIGBmaWxlX3NlYXJjaGAgdGhhdCBjYW4gYWNjZXNzXG4gICAqIGZpbGVzLlxuICAgKi9cbiAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgdmVjdG9yIHN0b3JlLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBWZWN0b3JTdG9yZUNyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgZXhwaXJhdGlvbiBwb2xpY3kgZm9yIGEgdmVjdG9yIHN0b3JlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBFeHBpcmVzQWZ0ZXIge1xuICAgIC8qKlxuICAgICAqIEFuY2hvciB0aW1lc3RhbXAgYWZ0ZXIgd2hpY2ggdGhlIGV4cGlyYXRpb24gcG9saWN5IGFwcGxpZXMuIFN1cHBvcnRlZCBhbmNob3JzOlxuICAgICAqIGBsYXN0X2FjdGl2ZV9hdGAuXG4gICAgICovXG4gICAgYW5jaG9yOiAnbGFzdF9hY3RpdmVfYXQnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBkYXlzIGFmdGVyIHRoZSBhbmNob3IgdGltZSB0aGF0IHRoZSB2ZWN0b3Igc3RvcmUgd2lsbCBleHBpcmUuXG4gICAgICovXG4gICAgZGF5czogbnVtYmVyO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmVVcGRhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIGV4cGlyYXRpb24gcG9saWN5IGZvciBhIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIGV4cGlyZXNfYWZ0ZXI/OiBWZWN0b3JTdG9yZVVwZGF0ZVBhcmFtcy5FeHBpcmVzQWZ0ZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgdmVjdG9yIHN0b3JlLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVmVjdG9yU3RvcmVVcGRhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIGV4cGlyYXRpb24gcG9saWN5IGZvciBhIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXhwaXJlc0FmdGVyIHtcbiAgICAvKipcbiAgICAgKiBBbmNob3IgdGltZXN0YW1wIGFmdGVyIHdoaWNoIHRoZSBleHBpcmF0aW9uIHBvbGljeSBhcHBsaWVzLiBTdXBwb3J0ZWQgYW5jaG9yczpcbiAgICAgKiBgbGFzdF9hY3RpdmVfYXRgLlxuICAgICAqL1xuICAgIGFuY2hvcjogJ2xhc3RfYWN0aXZlX2F0JztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZGF5cyBhZnRlciB0aGUgYW5jaG9yIHRpbWUgdGhhdCB0aGUgdmVjdG9yIHN0b3JlIHdpbGwgZXhwaXJlLlxuICAgICAqL1xuICAgIGRheXM6IG51bWJlcjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlTGlzdFBhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge1xuICAvKipcbiAgICogQSBjdXJzb3IgZm9yIHVzZSBpbiBwYWdpbmF0aW9uLiBgYmVmb3JlYCBpcyBhbiBvYmplY3QgSUQgdGhhdCBkZWZpbmVzIHlvdXIgcGxhY2VcbiAgICogaW4gdGhlIGxpc3QuIEZvciBpbnN0YW5jZSwgaWYgeW91IG1ha2UgYSBsaXN0IHJlcXVlc3QgYW5kIHJlY2VpdmUgMTAwIG9iamVjdHMsXG4gICAqIHN0YXJ0aW5nIHdpdGggb2JqX2ZvbywgeW91ciBzdWJzZXF1ZW50IGNhbGwgY2FuIGluY2x1ZGUgYmVmb3JlPW9ial9mb28gaW4gb3JkZXJcbiAgICogdG8gZmV0Y2ggdGhlIHByZXZpb3VzIHBhZ2Ugb2YgdGhlIGxpc3QuXG4gICAqL1xuICBiZWZvcmU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNvcnQgb3JkZXIgYnkgdGhlIGBjcmVhdGVkX2F0YCB0aW1lc3RhbXAgb2YgdGhlIG9iamVjdHMuIGBhc2NgIGZvciBhc2NlbmRpbmdcbiAgICogb3JkZXIgYW5kIGBkZXNjYCBmb3IgZGVzY2VuZGluZyBvcmRlci5cbiAgICovXG4gIG9yZGVyPzogJ2FzYycgfCAnZGVzYyc7XG59XG5cblZlY3RvclN0b3Jlcy5WZWN0b3JTdG9yZXNQYWdlID0gVmVjdG9yU3RvcmVzUGFnZTtcblZlY3RvclN0b3Jlcy5GaWxlcyA9IEZpbGVzO1xuVmVjdG9yU3RvcmVzLlZlY3RvclN0b3JlRmlsZXNQYWdlID0gVmVjdG9yU3RvcmVGaWxlc1BhZ2U7XG5WZWN0b3JTdG9yZXMuRmlsZUJhdGNoZXMgPSBGaWxlQmF0Y2hlcztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFZlY3RvclN0b3JlcyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBBdXRvRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbSBhcyBBdXRvRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbSxcbiAgICB0eXBlIEZpbGVDaHVua2luZ1N0cmF0ZWd5IGFzIEZpbGVDaHVua2luZ1N0cmF0ZWd5LFxuICAgIHR5cGUgRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbSBhcyBGaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtLFxuICAgIHR5cGUgT3RoZXJGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdCBhcyBPdGhlckZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0LFxuICAgIHR5cGUgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3kgYXMgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3ksXG4gICAgdHlwZSBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdCBhcyBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdCxcbiAgICB0eXBlIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0UGFyYW0gYXMgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3RQYXJhbSxcbiAgICB0eXBlIFZlY3RvclN0b3JlIGFzIFZlY3RvclN0b3JlLFxuICAgIHR5cGUgVmVjdG9yU3RvcmVEZWxldGVkIGFzIFZlY3RvclN0b3JlRGVsZXRlZCxcbiAgICBWZWN0b3JTdG9yZXNQYWdlIGFzIFZlY3RvclN0b3Jlc1BhZ2UsXG4gICAgdHlwZSBWZWN0b3JTdG9yZUNyZWF0ZVBhcmFtcyBhcyBWZWN0b3JTdG9yZUNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIFZlY3RvclN0b3JlVXBkYXRlUGFyYW1zIGFzIFZlY3RvclN0b3JlVXBkYXRlUGFyYW1zLFxuICAgIHR5cGUgVmVjdG9yU3RvcmVMaXN0UGFyYW1zIGFzIFZlY3RvclN0b3JlTGlzdFBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIEZpbGVzIGFzIEZpbGVzLFxuICAgIHR5cGUgVmVjdG9yU3RvcmVGaWxlIGFzIFZlY3RvclN0b3JlRmlsZSxcbiAgICB0eXBlIFZlY3RvclN0b3JlRmlsZURlbGV0ZWQgYXMgVmVjdG9yU3RvcmVGaWxlRGVsZXRlZCxcbiAgICBWZWN0b3JTdG9yZUZpbGVzUGFnZSBhcyBWZWN0b3JTdG9yZUZpbGVzUGFnZSxcbiAgICB0eXBlIEZpbGVDcmVhdGVQYXJhbXMgYXMgRmlsZUNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIEZpbGVMaXN0UGFyYW1zIGFzIEZpbGVMaXN0UGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgRmlsZUJhdGNoZXMgYXMgRmlsZUJhdGNoZXMsXG4gICAgdHlwZSBWZWN0b3JTdG9yZUZpbGVCYXRjaCBhcyBWZWN0b3JTdG9yZUZpbGVCYXRjaCxcbiAgICB0eXBlIEZpbGVCYXRjaENyZWF0ZVBhcmFtcyBhcyBGaWxlQmF0Y2hDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBGaWxlQmF0Y2hMaXN0RmlsZXNQYXJhbXMgYXMgRmlsZUJhdGNoTGlzdEZpbGVzUGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgQXNzaXN0YW50c0FQSSBmcm9tICcuL2Fzc2lzdGFudHMnO1xuaW1wb3J0ICogYXMgQ2hhdEFQSSBmcm9tICcuL2NoYXQvY2hhdCc7XG5pbXBvcnQge1xuICBBc3Npc3RhbnQsXG4gIEFzc2lzdGFudENyZWF0ZVBhcmFtcyxcbiAgQXNzaXN0YW50RGVsZXRlZCxcbiAgQXNzaXN0YW50TGlzdFBhcmFtcyxcbiAgQXNzaXN0YW50U3RyZWFtRXZlbnQsXG4gIEFzc2lzdGFudFRvb2wsXG4gIEFzc2lzdGFudFVwZGF0ZVBhcmFtcyxcbiAgQXNzaXN0YW50cyxcbiAgQXNzaXN0YW50c1BhZ2UsXG4gIENvZGVJbnRlcnByZXRlclRvb2wsXG4gIEZpbGVTZWFyY2hUb29sLFxuICBGdW5jdGlvblRvb2wsXG4gIE1lc3NhZ2VTdHJlYW1FdmVudCxcbiAgUnVuU3RlcFN0cmVhbUV2ZW50LFxuICBSdW5TdHJlYW1FdmVudCxcbiAgVGhyZWFkU3RyZWFtRXZlbnQsXG59IGZyb20gJy4vYXNzaXN0YW50cyc7XG5pbXBvcnQgKiBhcyBSZWFsdGltZUFQSSBmcm9tICcuL3JlYWx0aW1lL3JlYWx0aW1lJztcbmltcG9ydCB7IFJlYWx0aW1lIH0gZnJvbSAnLi9yZWFsdGltZS9yZWFsdGltZSc7XG5pbXBvcnQgKiBhcyBUaHJlYWRzQVBJIGZyb20gJy4vdGhyZWFkcy90aHJlYWRzJztcbmltcG9ydCB7XG4gIEFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uLFxuICBBc3Npc3RhbnRUb29sQ2hvaWNlLFxuICBBc3Npc3RhbnRUb29sQ2hvaWNlRnVuY3Rpb24sXG4gIEFzc2lzdGFudFRvb2xDaG9pY2VPcHRpb24sXG4gIFRocmVhZCxcbiAgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zLFxuICBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNOb25TdHJlYW1pbmcsXG4gIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc1N0cmVhbWluZyxcbiAgVGhyZWFkQ3JlYXRlQW5kUnVuUG9sbFBhcmFtcyxcbiAgVGhyZWFkQ3JlYXRlQW5kUnVuU3RyZWFtUGFyYW1zLFxuICBUaHJlYWRDcmVhdGVQYXJhbXMsXG4gIFRocmVhZERlbGV0ZWQsXG4gIFRocmVhZFVwZGF0ZVBhcmFtcyxcbiAgVGhyZWFkcyxcbn0gZnJvbSAnLi90aHJlYWRzL3RocmVhZHMnO1xuaW1wb3J0ICogYXMgVmVjdG9yU3RvcmVzQVBJIGZyb20gJy4vdmVjdG9yLXN0b3Jlcy92ZWN0b3Itc3RvcmVzJztcbmltcG9ydCB7XG4gIEF1dG9GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtLFxuICBGaWxlQ2h1bmtpbmdTdHJhdGVneSxcbiAgRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbSxcbiAgT3RoZXJGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdCxcbiAgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3ksXG4gIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0LFxuICBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdFBhcmFtLFxuICBWZWN0b3JTdG9yZSxcbiAgVmVjdG9yU3RvcmVDcmVhdGVQYXJhbXMsXG4gIFZlY3RvclN0b3JlRGVsZXRlZCxcbiAgVmVjdG9yU3RvcmVMaXN0UGFyYW1zLFxuICBWZWN0b3JTdG9yZVVwZGF0ZVBhcmFtcyxcbiAgVmVjdG9yU3RvcmVzLFxuICBWZWN0b3JTdG9yZXNQYWdlLFxufSBmcm9tICcuL3ZlY3Rvci1zdG9yZXMvdmVjdG9yLXN0b3Jlcyc7XG5pbXBvcnQgeyBDaGF0IH0gZnJvbSAnLi9jaGF0L2NoYXQnO1xuXG5leHBvcnQgY2xhc3MgQmV0YSBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgcmVhbHRpbWU6IFJlYWx0aW1lQVBJLlJlYWx0aW1lID0gbmV3IFJlYWx0aW1lQVBJLlJlYWx0aW1lKHRoaXMuX2NsaWVudCk7XG4gIHZlY3RvclN0b3JlczogVmVjdG9yU3RvcmVzQVBJLlZlY3RvclN0b3JlcyA9IG5ldyBWZWN0b3JTdG9yZXNBUEkuVmVjdG9yU3RvcmVzKHRoaXMuX2NsaWVudCk7XG4gIGNoYXQ6IENoYXRBUEkuQ2hhdCA9IG5ldyBDaGF0QVBJLkNoYXQodGhpcy5fY2xpZW50KTtcbiAgYXNzaXN0YW50czogQXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRzID0gbmV3IEFzc2lzdGFudHNBUEkuQXNzaXN0YW50cyh0aGlzLl9jbGllbnQpO1xuICB0aHJlYWRzOiBUaHJlYWRzQVBJLlRocmVhZHMgPSBuZXcgVGhyZWFkc0FQSS5UaHJlYWRzKHRoaXMuX2NsaWVudCk7XG59XG5cbkJldGEuUmVhbHRpbWUgPSBSZWFsdGltZTtcbkJldGEuVmVjdG9yU3RvcmVzID0gVmVjdG9yU3RvcmVzO1xuQmV0YS5WZWN0b3JTdG9yZXNQYWdlID0gVmVjdG9yU3RvcmVzUGFnZTtcbkJldGEuQXNzaXN0YW50cyA9IEFzc2lzdGFudHM7XG5CZXRhLkFzc2lzdGFudHNQYWdlID0gQXNzaXN0YW50c1BhZ2U7XG5CZXRhLlRocmVhZHMgPSBUaHJlYWRzO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgQmV0YSB7XG4gIGV4cG9ydCB7IFJlYWx0aW1lIGFzIFJlYWx0aW1lIH07XG5cbiAgZXhwb3J0IHtcbiAgICBWZWN0b3JTdG9yZXMgYXMgVmVjdG9yU3RvcmVzLFxuICAgIHR5cGUgQXV0b0ZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0gYXMgQXV0b0ZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0sXG4gICAgdHlwZSBGaWxlQ2h1bmtpbmdTdHJhdGVneSBhcyBGaWxlQ2h1bmtpbmdTdHJhdGVneSxcbiAgICB0eXBlIEZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0gYXMgRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbSxcbiAgICB0eXBlIE90aGVyRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QgYXMgT3RoZXJGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdCxcbiAgICB0eXBlIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5IGFzIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5LFxuICAgIHR5cGUgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QgYXMgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QsXG4gICAgdHlwZSBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdFBhcmFtIGFzIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0UGFyYW0sXG4gICAgdHlwZSBWZWN0b3JTdG9yZSBhcyBWZWN0b3JTdG9yZSxcbiAgICB0eXBlIFZlY3RvclN0b3JlRGVsZXRlZCBhcyBWZWN0b3JTdG9yZURlbGV0ZWQsXG4gICAgVmVjdG9yU3RvcmVzUGFnZSBhcyBWZWN0b3JTdG9yZXNQYWdlLFxuICAgIHR5cGUgVmVjdG9yU3RvcmVDcmVhdGVQYXJhbXMgYXMgVmVjdG9yU3RvcmVDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBWZWN0b3JTdG9yZVVwZGF0ZVBhcmFtcyBhcyBWZWN0b3JTdG9yZVVwZGF0ZVBhcmFtcyxcbiAgICB0eXBlIFZlY3RvclN0b3JlTGlzdFBhcmFtcyBhcyBWZWN0b3JTdG9yZUxpc3RQYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHsgQ2hhdCB9O1xuXG4gIGV4cG9ydCB7XG4gICAgQXNzaXN0YW50cyBhcyBBc3Npc3RhbnRzLFxuICAgIHR5cGUgQXNzaXN0YW50IGFzIEFzc2lzdGFudCxcbiAgICB0eXBlIEFzc2lzdGFudERlbGV0ZWQgYXMgQXNzaXN0YW50RGVsZXRlZCxcbiAgICB0eXBlIEFzc2lzdGFudFN0cmVhbUV2ZW50IGFzIEFzc2lzdGFudFN0cmVhbUV2ZW50LFxuICAgIHR5cGUgQXNzaXN0YW50VG9vbCBhcyBBc3Npc3RhbnRUb29sLFxuICAgIHR5cGUgQ29kZUludGVycHJldGVyVG9vbCBhcyBDb2RlSW50ZXJwcmV0ZXJUb29sLFxuICAgIHR5cGUgRmlsZVNlYXJjaFRvb2wgYXMgRmlsZVNlYXJjaFRvb2wsXG4gICAgdHlwZSBGdW5jdGlvblRvb2wgYXMgRnVuY3Rpb25Ub29sLFxuICAgIHR5cGUgTWVzc2FnZVN0cmVhbUV2ZW50IGFzIE1lc3NhZ2VTdHJlYW1FdmVudCxcbiAgICB0eXBlIFJ1blN0ZXBTdHJlYW1FdmVudCBhcyBSdW5TdGVwU3RyZWFtRXZlbnQsXG4gICAgdHlwZSBSdW5TdHJlYW1FdmVudCBhcyBSdW5TdHJlYW1FdmVudCxcbiAgICB0eXBlIFRocmVhZFN0cmVhbUV2ZW50IGFzIFRocmVhZFN0cmVhbUV2ZW50LFxuICAgIEFzc2lzdGFudHNQYWdlIGFzIEFzc2lzdGFudHNQYWdlLFxuICAgIHR5cGUgQXNzaXN0YW50Q3JlYXRlUGFyYW1zIGFzIEFzc2lzdGFudENyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIEFzc2lzdGFudFVwZGF0ZVBhcmFtcyBhcyBBc3Npc3RhbnRVcGRhdGVQYXJhbXMsXG4gICAgdHlwZSBBc3Npc3RhbnRMaXN0UGFyYW1zIGFzIEFzc2lzdGFudExpc3RQYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHtcbiAgICBUaHJlYWRzIGFzIFRocmVhZHMsXG4gICAgdHlwZSBBc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiBhcyBBc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbixcbiAgICB0eXBlIEFzc2lzdGFudFRvb2xDaG9pY2UgYXMgQXNzaXN0YW50VG9vbENob2ljZSxcbiAgICB0eXBlIEFzc2lzdGFudFRvb2xDaG9pY2VGdW5jdGlvbiBhcyBBc3Npc3RhbnRUb29sQ2hvaWNlRnVuY3Rpb24sXG4gICAgdHlwZSBBc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uIGFzIEFzc2lzdGFudFRvb2xDaG9pY2VPcHRpb24sXG4gICAgdHlwZSBUaHJlYWQgYXMgVGhyZWFkLFxuICAgIHR5cGUgVGhyZWFkRGVsZXRlZCBhcyBUaHJlYWREZWxldGVkLFxuICAgIHR5cGUgVGhyZWFkQ3JlYXRlUGFyYW1zIGFzIFRocmVhZENyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIFRocmVhZFVwZGF0ZVBhcmFtcyBhcyBUaHJlYWRVcGRhdGVQYXJhbXMsXG4gICAgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXMgYXMgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zLFxuICAgIHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zTm9uU3RyZWFtaW5nIGFzIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc1N0cmVhbWluZyBhcyBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNTdHJlYW1pbmcsXG4gICAgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5Qb2xsUGFyYW1zLFxuICAgIHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuU3RyZWFtUGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgQVBJUHJvbWlzZSB9IGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCAqIGFzIENvbXBsZXRpb25zQVBJIGZyb20gJy4vY29tcGxldGlvbnMnO1xuaW1wb3J0ICogYXMgQ2hhdENvbXBsZXRpb25zQVBJIGZyb20gJy4vY2hhdC9jb21wbGV0aW9ucyc7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tICcuLi9zdHJlYW1pbmcnO1xuXG5leHBvcnQgY2xhc3MgQ29tcGxldGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcGxldGlvbiBmb3IgdGhlIHByb3ZpZGVkIHByb21wdCBhbmQgcGFyYW1ldGVycy5cbiAgICovXG4gIGNyZWF0ZShib2R5OiBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IEFQSVByb21pc2U8Q29tcGxldGlvbj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxDb21wbGV0aW9uPj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08Q29tcGxldGlvbj4gfCBDb21wbGV0aW9uPjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8Q29tcGxldGlvbj4gfCBBUElQcm9taXNlPFN0cmVhbTxDb21wbGV0aW9uPj4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2NvbXBsZXRpb25zJywgeyBib2R5LCAuLi5vcHRpb25zLCBzdHJlYW06IGJvZHkuc3RyZWFtID8/IGZhbHNlIH0pIGFzXG4gICAgICB8IEFQSVByb21pc2U8Q29tcGxldGlvbj5cbiAgICAgIHwgQVBJUHJvbWlzZTxTdHJlYW08Q29tcGxldGlvbj4+O1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbXBsZXRpb24gcmVzcG9uc2UgZnJvbSB0aGUgQVBJLiBOb3RlOiBib3RoIHRoZSBzdHJlYW1lZCBhbmRcbiAqIG5vbi1zdHJlYW1lZCByZXNwb25zZSBvYmplY3RzIHNoYXJlIHRoZSBzYW1lIHNoYXBlICh1bmxpa2UgdGhlIGNoYXQgZW5kcG9pbnQpLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb24ge1xuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNvbXBsZXRpb24uXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBjb21wbGV0aW9uIGNob2ljZXMgdGhlIG1vZGVsIGdlbmVyYXRlZCBmb3IgdGhlIGlucHV0IHByb21wdC5cbiAgICovXG4gIGNob2ljZXM6IEFycmF5PENvbXBsZXRpb25DaG9pY2U+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIG9mIHdoZW4gdGhlIGNvbXBsZXRpb24gd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlbCB1c2VkIGZvciBjb21wbGV0aW9uLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgXCJ0ZXh0X2NvbXBsZXRpb25cIlxuICAgKi9cbiAgb2JqZWN0OiAndGV4dF9jb21wbGV0aW9uJztcblxuICAvKipcbiAgICogVGhpcyBmaW5nZXJwcmludCByZXByZXNlbnRzIHRoZSBiYWNrZW5kIGNvbmZpZ3VyYXRpb24gdGhhdCB0aGUgbW9kZWwgcnVucyB3aXRoLlxuICAgKlxuICAgKiBDYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBgc2VlZGAgcmVxdWVzdCBwYXJhbWV0ZXIgdG8gdW5kZXJzdGFuZCB3aGVuXG4gICAqIGJhY2tlbmQgY2hhbmdlcyBoYXZlIGJlZW4gbWFkZSB0aGF0IG1pZ2h0IGltcGFjdCBkZXRlcm1pbmlzbS5cbiAgICovXG4gIHN5c3RlbV9maW5nZXJwcmludD86IHN0cmluZztcblxuICAvKipcbiAgICogVXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIGNvbXBsZXRpb24gcmVxdWVzdC5cbiAgICovXG4gIHVzYWdlPzogQ29tcGxldGlvblVzYWdlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25DaG9pY2Uge1xuICAvKipcbiAgICogVGhlIHJlYXNvbiB0aGUgbW9kZWwgc3RvcHBlZCBnZW5lcmF0aW5nIHRva2Vucy4gVGhpcyB3aWxsIGJlIGBzdG9wYCBpZiB0aGUgbW9kZWxcbiAgICogaGl0IGEgbmF0dXJhbCBzdG9wIHBvaW50IG9yIGEgcHJvdmlkZWQgc3RvcCBzZXF1ZW5jZSwgYGxlbmd0aGAgaWYgdGhlIG1heGltdW1cbiAgICogbnVtYmVyIG9mIHRva2VucyBzcGVjaWZpZWQgaW4gdGhlIHJlcXVlc3Qgd2FzIHJlYWNoZWQsIG9yIGBjb250ZW50X2ZpbHRlcmAgaWZcbiAgICogY29udGVudCB3YXMgb21pdHRlZCBkdWUgdG8gYSBmbGFnIGZyb20gb3VyIGNvbnRlbnQgZmlsdGVycy5cbiAgICovXG4gIGZpbmlzaF9yZWFzb246ICdzdG9wJyB8ICdsZW5ndGgnIHwgJ2NvbnRlbnRfZmlsdGVyJztcblxuICBpbmRleDogbnVtYmVyO1xuXG4gIGxvZ3Byb2JzOiBDb21wbGV0aW9uQ2hvaWNlLkxvZ3Byb2JzIHwgbnVsbDtcblxuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29tcGxldGlvbkNob2ljZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgTG9ncHJvYnMge1xuICAgIHRleHRfb2Zmc2V0PzogQXJyYXk8bnVtYmVyPjtcblxuICAgIHRva2VuX2xvZ3Byb2JzPzogQXJyYXk8bnVtYmVyPjtcblxuICAgIHRva2Vucz86IEFycmF5PHN0cmluZz47XG5cbiAgICB0b3BfbG9ncHJvYnM/OiBBcnJheTxSZWNvcmQ8c3RyaW5nLCBudW1iZXI+PjtcbiAgfVxufVxuXG4vKipcbiAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBjb21wbGV0aW9uIHJlcXVlc3QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvblVzYWdlIHtcbiAgLyoqXG4gICAqIE51bWJlciBvZiB0b2tlbnMgaW4gdGhlIGdlbmVyYXRlZCBjb21wbGV0aW9uLlxuICAgKi9cbiAgY29tcGxldGlvbl90b2tlbnM6IG51bWJlcjtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHRva2VucyBpbiB0aGUgcHJvbXB0LlxuICAgKi9cbiAgcHJvbXB0X3Rva2VuczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUb3RhbCBudW1iZXIgb2YgdG9rZW5zIHVzZWQgaW4gdGhlIHJlcXVlc3QgKHByb21wdCArIGNvbXBsZXRpb24pLlxuICAgKi9cbiAgdG90YWxfdG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEJyZWFrZG93biBvZiB0b2tlbnMgdXNlZCBpbiBhIGNvbXBsZXRpb24uXG4gICAqL1xuICBjb21wbGV0aW9uX3Rva2Vuc19kZXRhaWxzPzogQ29tcGxldGlvblVzYWdlLkNvbXBsZXRpb25Ub2tlbnNEZXRhaWxzO1xuXG4gIC8qKlxuICAgKiBCcmVha2Rvd24gb2YgdG9rZW5zIHVzZWQgaW4gdGhlIHByb21wdC5cbiAgICovXG4gIHByb21wdF90b2tlbnNfZGV0YWlscz86IENvbXBsZXRpb25Vc2FnZS5Qcm9tcHRUb2tlbnNEZXRhaWxzO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENvbXBsZXRpb25Vc2FnZSB7XG4gIC8qKlxuICAgKiBCcmVha2Rvd24gb2YgdG9rZW5zIHVzZWQgaW4gYSBjb21wbGV0aW9uLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uVG9rZW5zRGV0YWlscyB7XG4gICAgLyoqXG4gICAgICogV2hlbiB1c2luZyBQcmVkaWN0ZWQgT3V0cHV0cywgdGhlIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIHByZWRpY3Rpb24gdGhhdFxuICAgICAqIGFwcGVhcmVkIGluIHRoZSBjb21wbGV0aW9uLlxuICAgICAqL1xuICAgIGFjY2VwdGVkX3ByZWRpY3Rpb25fdG9rZW5zPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQXVkaW8gaW5wdXQgdG9rZW5zIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgYXVkaW9fdG9rZW5zPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVG9rZW5zIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgZm9yIHJlYXNvbmluZy5cbiAgICAgKi9cbiAgICByZWFzb25pbmdfdG9rZW5zPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiB1c2luZyBQcmVkaWN0ZWQgT3V0cHV0cywgdGhlIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIHByZWRpY3Rpb24gdGhhdCBkaWRcbiAgICAgKiBub3QgYXBwZWFyIGluIHRoZSBjb21wbGV0aW9uLiBIb3dldmVyLCBsaWtlIHJlYXNvbmluZyB0b2tlbnMsIHRoZXNlIHRva2VucyBhcmVcbiAgICAgKiBzdGlsbCBjb3VudGVkIGluIHRoZSB0b3RhbCBjb21wbGV0aW9uIHRva2VucyBmb3IgcHVycG9zZXMgb2YgYmlsbGluZywgb3V0cHV0LFxuICAgICAqIGFuZCBjb250ZXh0IHdpbmRvdyBsaW1pdHMuXG4gICAgICovXG4gICAgcmVqZWN0ZWRfcHJlZGljdGlvbl90b2tlbnM/OiBudW1iZXI7XG4gIH1cblxuICAvKipcbiAgICogQnJlYWtkb3duIG9mIHRva2VucyB1c2VkIGluIHRoZSBwcm9tcHQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFByb21wdFRva2Vuc0RldGFpbHMge1xuICAgIC8qKlxuICAgICAqIEF1ZGlvIGlucHV0IHRva2VucyBwcmVzZW50IGluIHRoZSBwcm9tcHQuXG4gICAgICovXG4gICAgYXVkaW9fdG9rZW5zPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIHRva2VucyBwcmVzZW50IGluIHRoZSBwcm9tcHQuXG4gICAgICovXG4gICAgY2FjaGVkX3Rva2Vucz86IG51bWJlcjtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zID0gQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyB8IENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogSUQgb2YgdGhlIG1vZGVsIHRvIHVzZS4gWW91IGNhbiB1c2UgdGhlXG4gICAqIFtMaXN0IG1vZGVsc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tb2RlbHMvbGlzdCkgQVBJIHRvXG4gICAqIHNlZSBhbGwgb2YgeW91ciBhdmFpbGFibGUgbW9kZWxzLCBvciBzZWUgb3VyXG4gICAqIFtNb2RlbCBvdmVydmlld10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzKSBmb3IgZGVzY3JpcHRpb25zIG9mXG4gICAqIHRoZW0uXG4gICAqL1xuICBtb2RlbDogKHN0cmluZyAmIHt9KSB8ICdncHQtMy41LXR1cmJvLWluc3RydWN0JyB8ICdkYXZpbmNpLTAwMicgfCAnYmFiYmFnZS0wMDInO1xuXG4gIC8qKlxuICAgKiBUaGUgcHJvbXB0KHMpIHRvIGdlbmVyYXRlIGNvbXBsZXRpb25zIGZvciwgZW5jb2RlZCBhcyBhIHN0cmluZywgYXJyYXkgb2ZcbiAgICogc3RyaW5ncywgYXJyYXkgb2YgdG9rZW5zLCBvciBhcnJheSBvZiB0b2tlbiBhcnJheXMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCA8fGVuZG9mdGV4dHw+IGlzIHRoZSBkb2N1bWVudCBzZXBhcmF0b3IgdGhhdCB0aGUgbW9kZWwgc2VlcyBkdXJpbmdcbiAgICogdHJhaW5pbmcsIHNvIGlmIGEgcHJvbXB0IGlzIG5vdCBzcGVjaWZpZWQgdGhlIG1vZGVsIHdpbGwgZ2VuZXJhdGUgYXMgaWYgZnJvbSB0aGVcbiAgICogYmVnaW5uaW5nIG9mIGEgbmV3IGRvY3VtZW50LlxuICAgKi9cbiAgcHJvbXB0OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+IHwgQXJyYXk8bnVtYmVyPiB8IEFycmF5PEFycmF5PG51bWJlcj4+IHwgbnVsbDtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIGBiZXN0X29mYCBjb21wbGV0aW9ucyBzZXJ2ZXItc2lkZSBhbmQgcmV0dXJucyB0aGUgXCJiZXN0XCIgKHRoZSBvbmUgd2l0aFxuICAgKiB0aGUgaGlnaGVzdCBsb2cgcHJvYmFiaWxpdHkgcGVyIHRva2VuKS4gUmVzdWx0cyBjYW5ub3QgYmUgc3RyZWFtZWQuXG4gICAqXG4gICAqIFdoZW4gdXNlZCB3aXRoIGBuYCwgYGJlc3Rfb2ZgIGNvbnRyb2xzIHRoZSBudW1iZXIgb2YgY2FuZGlkYXRlIGNvbXBsZXRpb25zIGFuZFxuICAgKiBgbmAgc3BlY2lmaWVzIGhvdyBtYW55IHRvIHJldHVybiBcdTIwMTMgYGJlc3Rfb2ZgIG11c3QgYmUgZ3JlYXRlciB0aGFuIGBuYC5cbiAgICpcbiAgICogKipOb3RlOioqIEJlY2F1c2UgdGhpcyBwYXJhbWV0ZXIgZ2VuZXJhdGVzIG1hbnkgY29tcGxldGlvbnMsIGl0IGNhbiBxdWlja2x5XG4gICAqIGNvbnN1bWUgeW91ciB0b2tlbiBxdW90YS4gVXNlIGNhcmVmdWxseSBhbmQgZW5zdXJlIHRoYXQgeW91IGhhdmUgcmVhc29uYWJsZVxuICAgKiBzZXR0aW5ncyBmb3IgYG1heF90b2tlbnNgIGFuZCBgc3RvcGAuXG4gICAqL1xuICBiZXN0X29mPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogRWNobyBiYWNrIHRoZSBwcm9tcHQgaW4gYWRkaXRpb24gdG8gdGhlIGNvbXBsZXRpb25cbiAgICovXG4gIGVjaG8/OiBib29sZWFuIHwgbnVsbDtcblxuICAvKipcbiAgICogTnVtYmVyIGJldHdlZW4gLTIuMCBhbmQgMi4wLiBQb3NpdGl2ZSB2YWx1ZXMgcGVuYWxpemUgbmV3IHRva2VucyBiYXNlZCBvbiB0aGVpclxuICAgKiBleGlzdGluZyBmcmVxdWVuY3kgaW4gdGhlIHRleHQgc28gZmFyLCBkZWNyZWFzaW5nIHRoZSBtb2RlbCdzIGxpa2VsaWhvb2QgdG9cbiAgICogcmVwZWF0IHRoZSBzYW1lIGxpbmUgdmVyYmF0aW0uXG4gICAqXG4gICAqIFtTZWUgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBmcmVxdWVuY3kgYW5kIHByZXNlbmNlIHBlbmFsdGllcy5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy90ZXh0LWdlbmVyYXRpb24pXG4gICAqL1xuICBmcmVxdWVuY3lfcGVuYWx0eT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE1vZGlmeSB0aGUgbGlrZWxpaG9vZCBvZiBzcGVjaWZpZWQgdG9rZW5zIGFwcGVhcmluZyBpbiB0aGUgY29tcGxldGlvbi5cbiAgICpcbiAgICogQWNjZXB0cyBhIEpTT04gb2JqZWN0IHRoYXQgbWFwcyB0b2tlbnMgKHNwZWNpZmllZCBieSB0aGVpciB0b2tlbiBJRCBpbiB0aGUgR1BUXG4gICAqIHRva2VuaXplcikgdG8gYW4gYXNzb2NpYXRlZCBiaWFzIHZhbHVlIGZyb20gLTEwMCB0byAxMDAuIFlvdSBjYW4gdXNlIHRoaXNcbiAgICogW3Rva2VuaXplciB0b29sXSgvdG9rZW5pemVyP3ZpZXc9YnBlKSB0byBjb252ZXJ0IHRleHQgdG8gdG9rZW4gSURzLlxuICAgKiBNYXRoZW1hdGljYWxseSwgdGhlIGJpYXMgaXMgYWRkZWQgdG8gdGhlIGxvZ2l0cyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIHByaW9yIHRvXG4gICAqIHNhbXBsaW5nLiBUaGUgZXhhY3QgZWZmZWN0IHdpbGwgdmFyeSBwZXIgbW9kZWwsIGJ1dCB2YWx1ZXMgYmV0d2VlbiAtMSBhbmQgMVxuICAgKiBzaG91bGQgZGVjcmVhc2Ugb3IgaW5jcmVhc2UgbGlrZWxpaG9vZCBvZiBzZWxlY3Rpb247IHZhbHVlcyBsaWtlIC0xMDAgb3IgMTAwXG4gICAqIHNob3VsZCByZXN1bHQgaW4gYSBiYW4gb3IgZXhjbHVzaXZlIHNlbGVjdGlvbiBvZiB0aGUgcmVsZXZhbnQgdG9rZW4uXG4gICAqXG4gICAqIEFzIGFuIGV4YW1wbGUsIHlvdSBjYW4gcGFzcyBge1wiNTAyNTZcIjogLTEwMH1gIHRvIHByZXZlbnQgdGhlIDx8ZW5kb2Z0ZXh0fD4gdG9rZW5cbiAgICogZnJvbSBiZWluZyBnZW5lcmF0ZWQuXG4gICAqL1xuICBsb2dpdF9iaWFzPzogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEluY2x1ZGUgdGhlIGxvZyBwcm9iYWJpbGl0aWVzIG9uIHRoZSBgbG9ncHJvYnNgIG1vc3QgbGlrZWx5IG91dHB1dCB0b2tlbnMsIGFzXG4gICAqIHdlbGwgdGhlIGNob3NlbiB0b2tlbnMuIEZvciBleGFtcGxlLCBpZiBgbG9ncHJvYnNgIGlzIDUsIHRoZSBBUEkgd2lsbCByZXR1cm4gYVxuICAgKiBsaXN0IG9mIHRoZSA1IG1vc3QgbGlrZWx5IHRva2Vucy4gVGhlIEFQSSB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIGBsb2dwcm9iYCBvZlxuICAgKiB0aGUgc2FtcGxlZCB0b2tlbiwgc28gdGhlcmUgbWF5IGJlIHVwIHRvIGBsb2dwcm9icysxYCBlbGVtZW50cyBpbiB0aGUgcmVzcG9uc2UuXG4gICAqXG4gICAqIFRoZSBtYXhpbXVtIHZhbHVlIGZvciBgbG9ncHJvYnNgIGlzIDUuXG4gICAqL1xuICBsb2dwcm9icz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBbdG9rZW5zXSgvdG9rZW5pemVyKSB0aGF0IGNhbiBiZSBnZW5lcmF0ZWQgaW4gdGhlXG4gICAqIGNvbXBsZXRpb24uXG4gICAqXG4gICAqIFRoZSB0b2tlbiBjb3VudCBvZiB5b3VyIHByb21wdCBwbHVzIGBtYXhfdG9rZW5zYCBjYW5ub3QgZXhjZWVkIHRoZSBtb2RlbCdzXG4gICAqIGNvbnRleHQgbGVuZ3RoLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9jb29rYm9vay5vcGVuYWkuY29tL2V4YW1wbGVzL2hvd190b19jb3VudF90b2tlbnNfd2l0aF90aWt0b2tlbilcbiAgICogZm9yIGNvdW50aW5nIHRva2Vucy5cbiAgICovXG4gIG1heF90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBIb3cgbWFueSBjb21wbGV0aW9ucyB0byBnZW5lcmF0ZSBmb3IgZWFjaCBwcm9tcHQuXG4gICAqXG4gICAqICoqTm90ZToqKiBCZWNhdXNlIHRoaXMgcGFyYW1ldGVyIGdlbmVyYXRlcyBtYW55IGNvbXBsZXRpb25zLCBpdCBjYW4gcXVpY2tseVxuICAgKiBjb25zdW1lIHlvdXIgdG9rZW4gcXVvdGEuIFVzZSBjYXJlZnVsbHkgYW5kIGVuc3VyZSB0aGF0IHlvdSBoYXZlIHJlYXNvbmFibGVcbiAgICogc2V0dGluZ3MgZm9yIGBtYXhfdG9rZW5zYCBhbmQgYHN0b3BgLlxuICAgKi9cbiAgbj86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE51bWJlciBiZXR3ZWVuIC0yLjAgYW5kIDIuMC4gUG9zaXRpdmUgdmFsdWVzIHBlbmFsaXplIG5ldyB0b2tlbnMgYmFzZWQgb25cbiAgICogd2hldGhlciB0aGV5IGFwcGVhciBpbiB0aGUgdGV4dCBzbyBmYXIsIGluY3JlYXNpbmcgdGhlIG1vZGVsJ3MgbGlrZWxpaG9vZCB0b1xuICAgKiB0YWxrIGFib3V0IG5ldyB0b3BpY3MuXG4gICAqXG4gICAqIFtTZWUgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBmcmVxdWVuY3kgYW5kIHByZXNlbmNlIHBlbmFsdGllcy5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy90ZXh0LWdlbmVyYXRpb24pXG4gICAqL1xuICBwcmVzZW5jZV9wZW5hbHR5PzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogSWYgc3BlY2lmaWVkLCBvdXIgc3lzdGVtIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHNhbXBsZSBkZXRlcm1pbmlzdGljYWxseSxcbiAgICogc3VjaCB0aGF0IHJlcGVhdGVkIHJlcXVlc3RzIHdpdGggdGhlIHNhbWUgYHNlZWRgIGFuZCBwYXJhbWV0ZXJzIHNob3VsZCByZXR1cm5cbiAgICogdGhlIHNhbWUgcmVzdWx0LlxuICAgKlxuICAgKiBEZXRlcm1pbmlzbSBpcyBub3QgZ3VhcmFudGVlZCwgYW5kIHlvdSBzaG91bGQgcmVmZXIgdG8gdGhlIGBzeXN0ZW1fZmluZ2VycHJpbnRgXG4gICAqIHJlc3BvbnNlIHBhcmFtZXRlciB0byBtb25pdG9yIGNoYW5nZXMgaW4gdGhlIGJhY2tlbmQuXG4gICAqL1xuICBzZWVkPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVXAgdG8gNCBzZXF1ZW5jZXMgd2hlcmUgdGhlIEFQSSB3aWxsIHN0b3AgZ2VuZXJhdGluZyBmdXJ0aGVyIHRva2Vucy4gVGhlXG4gICAqIHJldHVybmVkIHRleHQgd2lsbCBub3QgY29udGFpbiB0aGUgc3RvcCBzZXF1ZW5jZS5cbiAgICovXG4gIHN0b3A/OiBzdHJpbmcgfCBudWxsIHwgQXJyYXk8c3RyaW5nPjtcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdHJlYW0gYmFjayBwYXJ0aWFsIHByb2dyZXNzLiBJZiBzZXQsIHRva2VucyB3aWxsIGJlIHNlbnQgYXNcbiAgICogZGF0YS1vbmx5XG4gICAqIFtzZXJ2ZXItc2VudCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2ZXItc2VudF9ldmVudHMvVXNpbmdfc2VydmVyLXNlbnRfZXZlbnRzI0V2ZW50X3N0cmVhbV9mb3JtYXQpXG4gICAqIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSwgd2l0aCB0aGUgc3RyZWFtIHRlcm1pbmF0ZWQgYnkgYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9jb29rYm9vay5vcGVuYWkuY29tL2V4YW1wbGVzL2hvd190b19zdHJlYW1fY29tcGxldGlvbnMpLlxuICAgKi9cbiAgc3RyZWFtPzogYm9vbGVhbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgZm9yIHN0cmVhbWluZyByZXNwb25zZS4gT25seSBzZXQgdGhpcyB3aGVuIHlvdSBzZXQgYHN0cmVhbTogdHJ1ZWAuXG4gICAqL1xuICBzdHJlYW1fb3B0aW9ucz86IENoYXRDb21wbGV0aW9uc0FQSS5DaGF0Q29tcGxldGlvblN0cmVhbU9wdGlvbnMgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc3VmZml4IHRoYXQgY29tZXMgYWZ0ZXIgYSBjb21wbGV0aW9uIG9mIGluc2VydGVkIHRleHQuXG4gICAqXG4gICAqIFRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBgZ3B0LTMuNS10dXJiby1pbnN0cnVjdGAuXG4gICAqL1xuICBzdWZmaXg/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICpcbiAgICogV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIGB0b3BfcGAgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciBgdGVtcGVyYXR1cmVgIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRvcF9wPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciByZXByZXNlbnRpbmcgeW91ciBlbmQtdXNlciwgd2hpY2ggY2FuIGhlbHAgT3BlbkFJIHRvIG1vbml0b3JcbiAgICogYW5kIGRldGVjdCBhYnVzZS5cbiAgICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zYWZldHktYmVzdC1wcmFjdGljZXMjZW5kLXVzZXItaWRzKS5cbiAgICovXG4gIHVzZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyB7XG4gIGV4cG9ydCB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgPSBDb21wbGV0aW9uc0FQSS5Db21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nO1xuICBleHBvcnQgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nID0gQ29tcGxldGlvbnNBUEkuQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGV4dGVuZHMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogV2hldGhlciB0byBzdHJlYW0gYmFjayBwYXJ0aWFsIHByb2dyZXNzLiBJZiBzZXQsIHRva2VucyB3aWxsIGJlIHNlbnQgYXNcbiAgICogZGF0YS1vbmx5XG4gICAqIFtzZXJ2ZXItc2VudCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2ZXItc2VudF9ldmVudHMvVXNpbmdfc2VydmVyLXNlbnRfZXZlbnRzI0V2ZW50X3N0cmVhbV9mb3JtYXQpXG4gICAqIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSwgd2l0aCB0aGUgc3RyZWFtIHRlcm1pbmF0ZWQgYnkgYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9jb29rYm9vay5vcGVuYWkuY29tL2V4YW1wbGVzL2hvd190b19zdHJlYW1fY29tcGxldGlvbnMpLlxuICAgKi9cbiAgc3RyZWFtPzogZmFsc2UgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgZXh0ZW5kcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN0cmVhbSBiYWNrIHBhcnRpYWwgcHJvZ3Jlc3MuIElmIHNldCwgdG9rZW5zIHdpbGwgYmUgc2VudCBhc1xuICAgKiBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLCB3aXRoIHRoZSBzdHJlYW0gdGVybWluYXRlZCBieSBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2Nvb2tib29rLm9wZW5haS5jb20vZXhhbXBsZXMvaG93X3RvX3N0cmVhbV9jb21wbGV0aW9ucykuXG4gICAqL1xuICBzdHJlYW06IHRydWU7XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBDb21wbGV0aW9ucyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBDb21wbGV0aW9uIGFzIENvbXBsZXRpb24sXG4gICAgdHlwZSBDb21wbGV0aW9uQ2hvaWNlIGFzIENvbXBsZXRpb25DaG9pY2UsXG4gICAgdHlwZSBDb21wbGV0aW9uVXNhZ2UgYXMgQ29tcGxldGlvblVzYWdlLFxuICAgIHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyBhcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBhcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBhcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi9jb3JlJztcblxuZXhwb3J0IGNsYXNzIEVtYmVkZGluZ3MgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGVtYmVkZGluZyB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBpbnB1dCB0ZXh0LlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIGJvZHk6IEVtYmVkZGluZ0NyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPENyZWF0ZUVtYmVkZGluZ1Jlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvZW1iZWRkaW5ncycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZUVtYmVkZGluZ1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIGVtYmVkZGluZ3MgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIGRhdGE6IEFycmF5PEVtYmVkZGluZz47XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBtb2RlbCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBlbWJlZGRpbmcuXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcImxpc3RcIi5cbiAgICovXG4gIG9iamVjdDogJ2xpc3QnO1xuXG4gIC8qKlxuICAgKiBUaGUgdXNhZ2UgaW5mb3JtYXRpb24gZm9yIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgdXNhZ2U6IENyZWF0ZUVtYmVkZGluZ1Jlc3BvbnNlLlVzYWdlO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENyZWF0ZUVtYmVkZGluZ1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqIFRoZSB1c2FnZSBpbmZvcm1hdGlvbiBmb3IgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFVzYWdlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRva2VucyB1c2VkIGJ5IHRoZSBwcm9tcHQuXG4gICAgICovXG4gICAgcHJvbXB0X3Rva2VuczogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvdGFsIG51bWJlciBvZiB0b2tlbnMgdXNlZCBieSB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICB0b3RhbF90b2tlbnM6IG51bWJlcjtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZW1iZWRkaW5nIHZlY3RvciByZXR1cm5lZCBieSBlbWJlZGRpbmcgZW5kcG9pbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRW1iZWRkaW5nIHtcbiAgLyoqXG4gICAqIFRoZSBlbWJlZGRpbmcgdmVjdG9yLCB3aGljaCBpcyBhIGxpc3Qgb2YgZmxvYXRzLiBUaGUgbGVuZ3RoIG9mIHZlY3RvciBkZXBlbmRzIG9uXG4gICAqIHRoZSBtb2RlbCBhcyBsaXN0ZWQgaW4gdGhlXG4gICAqIFtlbWJlZGRpbmcgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9lbWJlZGRpbmdzKS5cbiAgICovXG4gIGVtYmVkZGluZzogQXJyYXk8bnVtYmVyPjtcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBlbWJlZGRpbmcgaW4gdGhlIGxpc3Qgb2YgZW1iZWRkaW5ncy5cbiAgICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwiZW1iZWRkaW5nXCIuXG4gICAqL1xuICBvYmplY3Q6ICdlbWJlZGRpbmcnO1xufVxuXG5leHBvcnQgdHlwZSBFbWJlZGRpbmdNb2RlbCA9ICd0ZXh0LWVtYmVkZGluZy1hZGEtMDAyJyB8ICd0ZXh0LWVtYmVkZGluZy0zLXNtYWxsJyB8ICd0ZXh0LWVtYmVkZGluZy0zLWxhcmdlJztcblxuZXhwb3J0IGludGVyZmFjZSBFbWJlZGRpbmdDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogSW5wdXQgdGV4dCB0byBlbWJlZCwgZW5jb2RlZCBhcyBhIHN0cmluZyBvciBhcnJheSBvZiB0b2tlbnMuIFRvIGVtYmVkIG11bHRpcGxlXG4gICAqIGlucHV0cyBpbiBhIHNpbmdsZSByZXF1ZXN0LCBwYXNzIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgYXJyYXkgb2YgdG9rZW4gYXJyYXlzLlxuICAgKiBUaGUgaW5wdXQgbXVzdCBub3QgZXhjZWVkIHRoZSBtYXggaW5wdXQgdG9rZW5zIGZvciB0aGUgbW9kZWwgKDgxOTIgdG9rZW5zIGZvclxuICAgKiBgdGV4dC1lbWJlZGRpbmctYWRhLTAwMmApLCBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nLCBhbmQgYW55IGFycmF5IG11c3QgYmUgMjA0OFxuICAgKiBkaW1lbnNpb25zIG9yIGxlc3MuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2Nvb2tib29rLm9wZW5haS5jb20vZXhhbXBsZXMvaG93X3RvX2NvdW50X3Rva2Vuc193aXRoX3Rpa3Rva2VuKVxuICAgKiBmb3IgY291bnRpbmcgdG9rZW5zLlxuICAgKi9cbiAgaW5wdXQ6IHN0cmluZyB8IEFycmF5PHN0cmluZz4gfCBBcnJheTxudW1iZXI+IHwgQXJyYXk8QXJyYXk8bnVtYmVyPj47XG5cbiAgLyoqXG4gICAqIElEIG9mIHRoZSBtb2RlbCB0byB1c2UuIFlvdSBjYW4gdXNlIHRoZVxuICAgKiBbTGlzdCBtb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzL2xpc3QpIEFQSSB0b1xuICAgKiBzZWUgYWxsIG9mIHlvdXIgYXZhaWxhYmxlIG1vZGVscywgb3Igc2VlIG91clxuICAgKiBbTW9kZWwgb3ZlcnZpZXddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscykgZm9yIGRlc2NyaXB0aW9ucyBvZlxuICAgKiB0aGVtLlxuICAgKi9cbiAgbW9kZWw6IChzdHJpbmcgJiB7fSkgfCBFbWJlZGRpbmdNb2RlbDtcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBkaW1lbnNpb25zIHRoZSByZXN1bHRpbmcgb3V0cHV0IGVtYmVkZGluZ3Mgc2hvdWxkIGhhdmUuIE9ubHlcbiAgICogc3VwcG9ydGVkIGluIGB0ZXh0LWVtYmVkZGluZy0zYCBhbmQgbGF0ZXIgbW9kZWxzLlxuICAgKi9cbiAgZGltZW5zaW9ucz86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCB0byByZXR1cm4gdGhlIGVtYmVkZGluZ3MgaW4uIENhbiBiZSBlaXRoZXIgYGZsb2F0YCBvclxuICAgKiBbYGJhc2U2NGBdKGh0dHBzOi8vcHlwaS5vcmcvcHJvamVjdC9weWJhc2U2NC8pLlxuICAgKi9cbiAgZW5jb2RpbmdfZm9ybWF0PzogJ2Zsb2F0JyB8ICdiYXNlNjQnO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIHJlcHJlc2VudGluZyB5b3VyIGVuZC11c2VyLCB3aGljaCBjYW4gaGVscCBPcGVuQUkgdG8gbW9uaXRvclxuICAgKiBhbmQgZGV0ZWN0IGFidXNlLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3NhZmV0eS1iZXN0LXByYWN0aWNlcyNlbmQtdXNlci1pZHMpLlxuICAgKi9cbiAgdXNlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEVtYmVkZGluZ3Mge1xuICBleHBvcnQge1xuICAgIHR5cGUgQ3JlYXRlRW1iZWRkaW5nUmVzcG9uc2UgYXMgQ3JlYXRlRW1iZWRkaW5nUmVzcG9uc2UsXG4gICAgdHlwZSBFbWJlZGRpbmcgYXMgRW1iZWRkaW5nLFxuICAgIHR5cGUgRW1iZWRkaW5nTW9kZWwgYXMgRW1iZWRkaW5nTW9kZWwsXG4gICAgdHlwZSBFbWJlZGRpbmdDcmVhdGVQYXJhbXMgYXMgRW1iZWRkaW5nQ3JlYXRlUGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7IEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IgfSBmcm9tICcuLi9lcnJvcic7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSwgdHlwZSBDdXJzb3JQYWdlUGFyYW1zIH0gZnJvbSAnLi4vcGFnaW5hdGlvbic7XG5pbXBvcnQgeyB0eXBlIFJlc3BvbnNlIH0gZnJvbSAnLi4vX3NoaW1zL2luZGV4JztcblxuZXhwb3J0IGNsYXNzIEZpbGVzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogVXBsb2FkIGEgZmlsZSB0aGF0IGNhbiBiZSB1c2VkIGFjcm9zcyB2YXJpb3VzIGVuZHBvaW50cy4gSW5kaXZpZHVhbCBmaWxlcyBjYW4gYmVcbiAgICogdXAgdG8gNTEyIE1CLCBhbmQgdGhlIHNpemUgb2YgYWxsIGZpbGVzIHVwbG9hZGVkIGJ5IG9uZSBvcmdhbml6YXRpb24gY2FuIGJlIHVwXG4gICAqIHRvIDEwMCBHQi5cbiAgICpcbiAgICogVGhlIEFzc2lzdGFudHMgQVBJIHN1cHBvcnRzIGZpbGVzIHVwIHRvIDIgbWlsbGlvbiB0b2tlbnMgYW5kIG9mIHNwZWNpZmljIGZpbGVcbiAgICogdHlwZXMuIFNlZSB0aGVcbiAgICogW0Fzc2lzdGFudHMgVG9vbHMgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvdG9vbHMpIGZvclxuICAgKiBkZXRhaWxzLlxuICAgKlxuICAgKiBUaGUgRmluZS10dW5pbmcgQVBJIG9ubHkgc3VwcG9ydHMgYC5qc29ubGAgZmlsZXMuIFRoZSBpbnB1dCBhbHNvIGhhcyBjZXJ0YWluXG4gICAqIHJlcXVpcmVkIGZvcm1hdHMgZm9yIGZpbmUtdHVuaW5nXG4gICAqIFtjaGF0XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuaW5nL2NoYXQtaW5wdXQpIG9yXG4gICAqIFtjb21wbGV0aW9uc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maW5lLXR1bmluZy9jb21wbGV0aW9ucy1pbnB1dClcbiAgICogbW9kZWxzLlxuICAgKlxuICAgKiBUaGUgQmF0Y2ggQVBJIG9ubHkgc3VwcG9ydHMgYC5qc29ubGAgZmlsZXMgdXAgdG8gMjAwIE1CIGluIHNpemUuIFRoZSBpbnB1dCBhbHNvXG4gICAqIGhhcyBhIHNwZWNpZmljIHJlcXVpcmVkXG4gICAqIFtmb3JtYXRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYmF0Y2gvcmVxdWVzdC1pbnB1dCkuXG4gICAqXG4gICAqIFBsZWFzZSBbY29udGFjdCB1c10oaHR0cHM6Ly9oZWxwLm9wZW5haS5jb20vKSBpZiB5b3UgbmVlZCB0byBpbmNyZWFzZSB0aGVzZVxuICAgKiBzdG9yYWdlIGxpbWl0cy5cbiAgICovXG4gIGNyZWF0ZShib2R5OiBGaWxlQ3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxGaWxlT2JqZWN0PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvZmlsZXMnLCBDb3JlLm11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyh7IGJvZHksIC4uLm9wdGlvbnMgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgYSBzcGVjaWZpYyBmaWxlLlxuICAgKi9cbiAgcmV0cmlldmUoZmlsZUlkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEZpbGVPYmplY3Q+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL2ZpbGVzLyR7ZmlsZUlkfWAsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIGZpbGVzLlxuICAgKi9cbiAgbGlzdChxdWVyeT86IEZpbGVMaXN0UGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuUGFnZVByb21pc2U8RmlsZU9iamVjdHNQYWdlLCBGaWxlT2JqZWN0PjtcbiAgbGlzdChvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuUGFnZVByb21pc2U8RmlsZU9iamVjdHNQYWdlLCBGaWxlT2JqZWN0PjtcbiAgbGlzdChcbiAgICBxdWVyeTogRmlsZUxpc3RQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8RmlsZU9iamVjdHNQYWdlLCBGaWxlT2JqZWN0PiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0KHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdCgnL2ZpbGVzJywgRmlsZU9iamVjdHNQYWdlLCB7IHF1ZXJ5LCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGZpbGUuXG4gICAqL1xuICBkZWwoZmlsZUlkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEZpbGVEZWxldGVkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5kZWxldGUoYC9maWxlcy8ke2ZpbGVJZH1gLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGUgc3BlY2lmaWVkIGZpbGUuXG4gICAqL1xuICBjb250ZW50KGZpbGVJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvZmlsZXMvJHtmaWxlSWR9L2NvbnRlbnRgLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9iaW5hcnknLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICBfX2JpbmFyeVJlc3BvbnNlOiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRlbnRzIG9mIHRoZSBzcGVjaWZpZWQgZmlsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVGhlIGAuY29udGVudCgpYCBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZFxuICAgKi9cbiAgcmV0cmlldmVDb250ZW50KGZpbGVJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL2ZpbGVzLyR7ZmlsZUlkfS9jb250ZW50YCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogV2FpdHMgZm9yIHRoZSBnaXZlbiBmaWxlIHRvIGJlIHByb2Nlc3NlZCwgZGVmYXVsdCB0aW1lb3V0IGlzIDMwIG1pbnMuXG4gICAqL1xuICBhc3luYyB3YWl0Rm9yUHJvY2Vzc2luZyhcbiAgICBpZDogc3RyaW5nLFxuICAgIHsgcG9sbEludGVydmFsID0gNTAwMCwgbWF4V2FpdCA9IDMwICogNjAgKiAxMDAwIH06IHsgcG9sbEludGVydmFsPzogbnVtYmVyOyBtYXhXYWl0PzogbnVtYmVyIH0gPSB7fSxcbiAgKTogUHJvbWlzZTxGaWxlT2JqZWN0PiB7XG4gICAgY29uc3QgVEVSTUlOQUxfU1RBVEVTID0gbmV3IFNldChbJ3Byb2Nlc3NlZCcsICdlcnJvcicsICdkZWxldGVkJ10pO1xuXG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGxldCBmaWxlID0gYXdhaXQgdGhpcy5yZXRyaWV2ZShpZCk7XG5cbiAgICB3aGlsZSAoIWZpbGUuc3RhdHVzIHx8ICFURVJNSU5BTF9TVEFURVMuaGFzKGZpbGUuc3RhdHVzKSkge1xuICAgICAgYXdhaXQgc2xlZXAocG9sbEludGVydmFsKTtcblxuICAgICAgZmlsZSA9IGF3YWl0IHRoaXMucmV0cmlldmUoaWQpO1xuICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydCA+IG1heFdhaXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGBHaXZpbmcgdXAgb24gd2FpdGluZyBmb3IgZmlsZSAke2lkfSB0byBmaW5pc2ggcHJvY2Vzc2luZyBhZnRlciAke21heFdhaXR9IG1pbGxpc2Vjb25kcy5gLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmlsZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmlsZU9iamVjdHNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxGaWxlT2JqZWN0PiB7fVxuXG5leHBvcnQgdHlwZSBGaWxlQ29udGVudCA9IHN0cmluZztcblxuZXhwb3J0IGludGVyZmFjZSBGaWxlRGVsZXRlZCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgZGVsZXRlZDogYm9vbGVhbjtcblxuICBvYmplY3Q6ICdmaWxlJztcbn1cblxuLyoqXG4gKiBUaGUgYEZpbGVgIG9iamVjdCByZXByZXNlbnRzIGEgZG9jdW1lbnQgdGhhdCBoYXMgYmVlbiB1cGxvYWRlZCB0byBPcGVuQUkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZU9iamVjdCB7XG4gIC8qKlxuICAgKiBUaGUgZmlsZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBmaWxlLCBpbiBieXRlcy5cbiAgICovXG4gIGJ5dGVzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGZpbGUgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmaWxlLlxuICAgKi9cbiAgZmlsZW5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYGZpbGVgLlxuICAgKi9cbiAgb2JqZWN0OiAnZmlsZSc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbnRlbmRlZCBwdXJwb3NlIG9mIHRoZSBmaWxlLiBTdXBwb3J0ZWQgdmFsdWVzIGFyZSBgYXNzaXN0YW50c2AsXG4gICAqIGBhc3Npc3RhbnRzX291dHB1dGAsIGBiYXRjaGAsIGBiYXRjaF9vdXRwdXRgLCBgZmluZS10dW5lYCwgYGZpbmUtdHVuZS1yZXN1bHRzYFxuICAgKiBhbmQgYHZpc2lvbmAuXG4gICAqL1xuICBwdXJwb3NlOlxuICAgIHwgJ2Fzc2lzdGFudHMnXG4gICAgfCAnYXNzaXN0YW50c19vdXRwdXQnXG4gICAgfCAnYmF0Y2gnXG4gICAgfCAnYmF0Y2hfb3V0cHV0J1xuICAgIHwgJ2ZpbmUtdHVuZSdcbiAgICB8ICdmaW5lLXR1bmUtcmVzdWx0cydcbiAgICB8ICd2aXNpb24nO1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZDogRGVwcmVjYXRlZC4gVGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBmaWxlLCB3aGljaCBjYW4gYmUgZWl0aGVyXG4gICAqIGB1cGxvYWRlZGAsIGBwcm9jZXNzZWRgLCBvciBgZXJyb3JgLlxuICAgKi9cbiAgc3RhdHVzOiAndXBsb2FkZWQnIHwgJ3Byb2Nlc3NlZCcgfCAnZXJyb3InO1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZDogRGVwcmVjYXRlZC4gRm9yIGRldGFpbHMgb24gd2h5IGEgZmluZS10dW5pbmcgdHJhaW5pbmcgZmlsZSBmYWlsZWRcbiAgICogdmFsaWRhdGlvbiwgc2VlIHRoZSBgZXJyb3JgIGZpZWxkIG9uIGBmaW5lX3R1bmluZy5qb2JgLlxuICAgKi9cbiAgc3RhdHVzX2RldGFpbHM/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhlIGludGVuZGVkIHB1cnBvc2Ugb2YgdGhlIHVwbG9hZGVkIGZpbGUuXG4gKlxuICogVXNlIFwiYXNzaXN0YW50c1wiIGZvclxuICogW0Fzc2lzdGFudHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgYW5kXG4gKiBbTWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcykgZmlsZXMsXG4gKiBcInZpc2lvblwiIGZvciBBc3Npc3RhbnRzIGltYWdlIGZpbGUgaW5wdXRzLCBcImJhdGNoXCIgZm9yXG4gKiBbQmF0Y2ggQVBJXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYmF0Y2gpLCBhbmQgXCJmaW5lLXR1bmVcIiBmb3JcbiAqIFtGaW5lLXR1bmluZ10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maW5lLXR1bmluZykuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbGVQdXJwb3NlID0gJ2Fzc2lzdGFudHMnIHwgJ2JhdGNoJyB8ICdmaW5lLXR1bmUnIHwgJ3Zpc2lvbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUNyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgRmlsZSBvYmplY3QgKG5vdCBmaWxlIG5hbWUpIHRvIGJlIHVwbG9hZGVkLlxuICAgKi9cbiAgZmlsZTogQ29yZS5VcGxvYWRhYmxlO1xuXG4gIC8qKlxuICAgKiBUaGUgaW50ZW5kZWQgcHVycG9zZSBvZiB0aGUgdXBsb2FkZWQgZmlsZS5cbiAgICpcbiAgICogVXNlIFwiYXNzaXN0YW50c1wiIGZvclxuICAgKiBbQXNzaXN0YW50c10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSBhbmRcbiAgICogW01lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMpIGZpbGVzLFxuICAgKiBcInZpc2lvblwiIGZvciBBc3Npc3RhbnRzIGltYWdlIGZpbGUgaW5wdXRzLCBcImJhdGNoXCIgZm9yXG4gICAqIFtCYXRjaCBBUEldKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9iYXRjaCksIGFuZCBcImZpbmUtdHVuZVwiIGZvclxuICAgKiBbRmluZS10dW5pbmddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmluZS10dW5pbmcpLlxuICAgKi9cbiAgcHVycG9zZTogRmlsZVB1cnBvc2U7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUxpc3RQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFNvcnQgb3JkZXIgYnkgdGhlIGBjcmVhdGVkX2F0YCB0aW1lc3RhbXAgb2YgdGhlIG9iamVjdHMuIGBhc2NgIGZvciBhc2NlbmRpbmdcbiAgICogb3JkZXIgYW5kIGBkZXNjYCBmb3IgZGVzY2VuZGluZyBvcmRlci5cbiAgICovXG4gIG9yZGVyPzogJ2FzYycgfCAnZGVzYyc7XG5cbiAgLyoqXG4gICAqIE9ubHkgcmV0dXJuIGZpbGVzIHdpdGggdGhlIGdpdmVuIHB1cnBvc2UuXG4gICAqL1xuICBwdXJwb3NlPzogc3RyaW5nO1xufVxuXG5GaWxlcy5GaWxlT2JqZWN0c1BhZ2UgPSBGaWxlT2JqZWN0c1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBGaWxlcyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBGaWxlQ29udGVudCBhcyBGaWxlQ29udGVudCxcbiAgICB0eXBlIEZpbGVEZWxldGVkIGFzIEZpbGVEZWxldGVkLFxuICAgIHR5cGUgRmlsZU9iamVjdCBhcyBGaWxlT2JqZWN0LFxuICAgIHR5cGUgRmlsZVB1cnBvc2UgYXMgRmlsZVB1cnBvc2UsXG4gICAgRmlsZU9iamVjdHNQYWdlIGFzIEZpbGVPYmplY3RzUGFnZSxcbiAgICB0eXBlIEZpbGVDcmVhdGVQYXJhbXMgYXMgRmlsZUNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIEZpbGVMaXN0UGFyYW1zIGFzIEZpbGVMaXN0UGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCB7IEN1cnNvclBhZ2UsIHR5cGUgQ3Vyc29yUGFnZVBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL3BhZ2luYXRpb24nO1xuXG5leHBvcnQgY2xhc3MgQ2hlY2twb2ludHMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBMaXN0IGNoZWNrcG9pbnRzIGZvciBhIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIGxpc3QoXG4gICAgZmluZVR1bmluZ0pvYklkOiBzdHJpbmcsXG4gICAgcXVlcnk/OiBDaGVja3BvaW50TGlzdFBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxGaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlLCBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludD47XG4gIGxpc3QoXG4gICAgZmluZVR1bmluZ0pvYklkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSwgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnQ+O1xuICBsaXN0KFxuICAgIGZpbmVUdW5pbmdKb2JJZDogc3RyaW5nLFxuICAgIHF1ZXJ5OiBDaGVja3BvaW50TGlzdFBhcmFtcyB8IENvcmUuUmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxGaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlLCBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludD4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdChmaW5lVHVuaW5nSm9iSWQsIHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdChcbiAgICAgIGAvZmluZV90dW5pbmcvam9icy8ke2ZpbmVUdW5pbmdKb2JJZH0vY2hlY2twb2ludHNgLFxuICAgICAgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSxcbiAgICAgIHsgcXVlcnksIC4uLm9wdGlvbnMgfSxcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxGaW5lVHVuaW5nSm9iQ2hlY2twb2ludD4ge31cblxuLyoqXG4gKiBUaGUgYGZpbmVfdHVuaW5nLmpvYi5jaGVja3BvaW50YCBvYmplY3QgcmVwcmVzZW50cyBhIG1vZGVsIGNoZWNrcG9pbnQgZm9yIGFcbiAqIGZpbmUtdHVuaW5nIGpvYiB0aGF0IGlzIHJlYWR5IHRvIHVzZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludCB7XG4gIC8qKlxuICAgKiBUaGUgY2hlY2twb2ludCBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGNoZWNrcG9pbnQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmaW5lLXR1bmVkIGNoZWNrcG9pbnQgbW9kZWwgdGhhdCBpcyBjcmVhdGVkLlxuICAgKi9cbiAgZmluZV90dW5lZF9tb2RlbF9jaGVja3BvaW50OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmaW5lLXR1bmluZyBqb2IgdGhhdCB0aGlzIGNoZWNrcG9pbnQgd2FzIGNyZWF0ZWQgZnJvbS5cbiAgICovXG4gIGZpbmVfdHVuaW5nX2pvYl9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBNZXRyaWNzIGF0IHRoZSBzdGVwIG51bWJlciBkdXJpbmcgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIG1ldHJpY3M6IEZpbmVUdW5pbmdKb2JDaGVja3BvaW50Lk1ldHJpY3M7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwiZmluZV90dW5pbmcuam9iLmNoZWNrcG9pbnRcIi5cbiAgICovXG4gIG9iamVjdDogJ2ZpbmVfdHVuaW5nLmpvYi5jaGVja3BvaW50JztcblxuICAvKipcbiAgICogVGhlIHN0ZXAgbnVtYmVyIHRoYXQgdGhlIGNoZWNrcG9pbnQgd2FzIGNyZWF0ZWQgYXQuXG4gICAqL1xuICBzdGVwX251bWJlcjogbnVtYmVyO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50IHtcbiAgLyoqXG4gICAqIE1ldHJpY3MgYXQgdGhlIHN0ZXAgbnVtYmVyIGR1cmluZyB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBNZXRyaWNzIHtcbiAgICBmdWxsX3ZhbGlkX2xvc3M/OiBudW1iZXI7XG5cbiAgICBmdWxsX3ZhbGlkX21lYW5fdG9rZW5fYWNjdXJhY3k/OiBudW1iZXI7XG5cbiAgICBzdGVwPzogbnVtYmVyO1xuXG4gICAgdHJhaW5fbG9zcz86IG51bWJlcjtcblxuICAgIHRyYWluX21lYW5fdG9rZW5fYWNjdXJhY3k/OiBudW1iZXI7XG5cbiAgICB2YWxpZF9sb3NzPzogbnVtYmVyO1xuXG4gICAgdmFsaWRfbWVhbl90b2tlbl9hY2N1cmFjeT86IG51bWJlcjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrcG9pbnRMaXN0UGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7fVxuXG5DaGVja3BvaW50cy5GaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlID0gRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIENoZWNrcG9pbnRzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50IGFzIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50LFxuICAgIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UgYXMgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSxcbiAgICB0eXBlIENoZWNrcG9pbnRMaXN0UGFyYW1zIGFzIENoZWNrcG9pbnRMaXN0UGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIENoZWNrcG9pbnRzQVBJIGZyb20gJy4vY2hlY2twb2ludHMnO1xuaW1wb3J0IHtcbiAgQ2hlY2twb2ludExpc3RQYXJhbXMsXG4gIENoZWNrcG9pbnRzLFxuICBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludCxcbiAgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSxcbn0gZnJvbSAnLi9jaGVja3BvaW50cyc7XG5pbXBvcnQgeyBDdXJzb3JQYWdlLCB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9wYWdpbmF0aW9uJztcblxuZXhwb3J0IGNsYXNzIEpvYnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIGNoZWNrcG9pbnRzOiBDaGVja3BvaW50c0FQSS5DaGVja3BvaW50cyA9IG5ldyBDaGVja3BvaW50c0FQSS5DaGVja3BvaW50cyh0aGlzLl9jbGllbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZmluZS10dW5pbmcgam9iIHdoaWNoIGJlZ2lucyB0aGUgcHJvY2VzcyBvZiBjcmVhdGluZyBhIG5ldyBtb2RlbCBmcm9tXG4gICAqIGEgZ2l2ZW4gZGF0YXNldC5cbiAgICpcbiAgICogUmVzcG9uc2UgaW5jbHVkZXMgZGV0YWlscyBvZiB0aGUgZW5xdWV1ZWQgam9iIGluY2x1ZGluZyBqb2Igc3RhdHVzIGFuZCB0aGUgbmFtZVxuICAgKiBvZiB0aGUgZmluZS10dW5lZCBtb2RlbHMgb25jZSBjb21wbGV0ZS5cbiAgICpcbiAgICogW0xlYXJuIG1vcmUgYWJvdXQgZmluZS10dW5pbmddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9maW5lLXR1bmluZylcbiAgICovXG4gIGNyZWF0ZShib2R5OiBKb2JDcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEZpbmVUdW5pbmdKb2I+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9maW5lX3R1bmluZy9qb2JzJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBpbmZvIGFib3V0IGEgZmluZS10dW5pbmcgam9iLlxuICAgKlxuICAgKiBbTGVhcm4gbW9yZSBhYm91dCBmaW5lLXR1bmluZ10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2ZpbmUtdHVuaW5nKVxuICAgKi9cbiAgcmV0cmlldmUoZmluZVR1bmluZ0pvYklkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEZpbmVUdW5pbmdKb2I+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL2ZpbmVfdHVuaW5nL2pvYnMvJHtmaW5lVHVuaW5nSm9iSWR9YCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCB5b3VyIG9yZ2FuaXphdGlvbidzIGZpbmUtdHVuaW5nIGpvYnNcbiAgICovXG4gIGxpc3QoXG4gICAgcXVlcnk/OiBKb2JMaXN0UGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JzUGFnZSwgRmluZVR1bmluZ0pvYj47XG4gIGxpc3Qob3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JzUGFnZSwgRmluZVR1bmluZ0pvYj47XG4gIGxpc3QoXG4gICAgcXVlcnk6IEpvYkxpc3RQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmluZ0pvYnNQYWdlLCBGaW5lVHVuaW5nSm9iPiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0KHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdCgnL2ZpbmVfdHVuaW5nL2pvYnMnLCBGaW5lVHVuaW5nSm9ic1BhZ2UsIHsgcXVlcnksIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW1tZWRpYXRlbHkgY2FuY2VsIGEgZmluZS10dW5lIGpvYi5cbiAgICovXG4gIGNhbmNlbChmaW5lVHVuaW5nSm9iSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8RmluZVR1bmluZ0pvYj4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL2ZpbmVfdHVuaW5nL2pvYnMvJHtmaW5lVHVuaW5nSm9iSWR9L2NhbmNlbGAsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzdGF0dXMgdXBkYXRlcyBmb3IgYSBmaW5lLXR1bmluZyBqb2IuXG4gICAqL1xuICBsaXN0RXZlbnRzKFxuICAgIGZpbmVUdW5pbmdKb2JJZDogc3RyaW5nLFxuICAgIHF1ZXJ5PzogSm9iTGlzdEV2ZW50c1BhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSwgRmluZVR1bmluZ0pvYkV2ZW50PjtcbiAgbGlzdEV2ZW50cyhcbiAgICBmaW5lVHVuaW5nSm9iSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSwgRmluZVR1bmluZ0pvYkV2ZW50PjtcbiAgbGlzdEV2ZW50cyhcbiAgICBmaW5lVHVuaW5nSm9iSWQ6IHN0cmluZyxcbiAgICBxdWVyeTogSm9iTGlzdEV2ZW50c1BhcmFtcyB8IENvcmUuUmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSwgRmluZVR1bmluZ0pvYkV2ZW50PiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0RXZlbnRzKGZpbmVUdW5pbmdKb2JJZCwge30sIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KGAvZmluZV90dW5pbmcvam9icy8ke2ZpbmVUdW5pbmdKb2JJZH0vZXZlbnRzYCwgRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UsIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmluZVR1bmluZ0pvYnNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxGaW5lVHVuaW5nSm9iPiB7fVxuXG5leHBvcnQgY2xhc3MgRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlPEZpbmVUdW5pbmdKb2JFdmVudD4ge31cblxuLyoqXG4gKiBUaGUgYGZpbmVfdHVuaW5nLmpvYmAgb2JqZWN0IHJlcHJlc2VudHMgYSBmaW5lLXR1bmluZyBqb2IgdGhhdCBoYXMgYmVlbiBjcmVhdGVkXG4gKiB0aHJvdWdoIHRoZSBBUEkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmluZVR1bmluZ0pvYiB7XG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IGlkZW50aWZpZXIsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIHRoZSBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgZmluZS10dW5pbmcgam9iIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBGb3IgZmluZS10dW5pbmcgam9icyB0aGF0IGhhdmUgYGZhaWxlZGAsIHRoaXMgd2lsbCBjb250YWluIG1vcmUgaW5mb3JtYXRpb24gb25cbiAgICogdGhlIGNhdXNlIG9mIHRoZSBmYWlsdXJlLlxuICAgKi9cbiAgZXJyb3I6IEZpbmVUdW5pbmdKb2IuRXJyb3IgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZmluZS10dW5lZCBtb2RlbCB0aGF0IGlzIGJlaW5nIGNyZWF0ZWQuIFRoZSB2YWx1ZSB3aWxsIGJlIG51bGxcbiAgICogaWYgdGhlIGZpbmUtdHVuaW5nIGpvYiBpcyBzdGlsbCBydW5uaW5nLlxuICAgKi9cbiAgZmluZV90dW5lZF9tb2RlbDogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgZmluZS10dW5pbmcgam9iIHdhcyBmaW5pc2hlZC4gVGhlXG4gICAqIHZhbHVlIHdpbGwgYmUgbnVsbCBpZiB0aGUgZmluZS10dW5pbmcgam9iIGlzIHN0aWxsIHJ1bm5pbmcuXG4gICAqL1xuICBmaW5pc2hlZF9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLiBUaGlzIHZhbHVlIHdpbGwgb25seSBiZVxuICAgKiByZXR1cm5lZCB3aGVuIHJ1bm5pbmcgYHN1cGVydmlzZWRgIGpvYnMuXG4gICAqL1xuICBoeXBlcnBhcmFtZXRlcnM6IEZpbmVUdW5pbmdKb2IuSHlwZXJwYXJhbWV0ZXJzO1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBtb2RlbCB0aGF0IGlzIGJlaW5nIGZpbmUtdHVuZWQuXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcImZpbmVfdHVuaW5nLmpvYlwiLlxuICAgKi9cbiAgb2JqZWN0OiAnZmluZV90dW5pbmcuam9iJztcblxuICAvKipcbiAgICogVGhlIG9yZ2FuaXphdGlvbiB0aGF0IG93bnMgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIG9yZ2FuaXphdGlvbl9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY29tcGlsZWQgcmVzdWx0cyBmaWxlIElEKHMpIGZvciB0aGUgZmluZS10dW5pbmcgam9iLiBZb3UgY2FuIHJldHJpZXZlIHRoZVxuICAgKiByZXN1bHRzIHdpdGggdGhlXG4gICAqIFtGaWxlcyBBUEldKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMvcmV0cmlldmUtY29udGVudHMpLlxuICAgKi9cbiAgcmVzdWx0X2ZpbGVzOiBBcnJheTxzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBUaGUgc2VlZCB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgKi9cbiAgc2VlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIGZpbmUtdHVuaW5nIGpvYiwgd2hpY2ggY2FuIGJlIGVpdGhlclxuICAgKiBgdmFsaWRhdGluZ19maWxlc2AsIGBxdWV1ZWRgLCBgcnVubmluZ2AsIGBzdWNjZWVkZWRgLCBgZmFpbGVkYCwgb3IgYGNhbmNlbGxlZGAuXG4gICAqL1xuICBzdGF0dXM6ICd2YWxpZGF0aW5nX2ZpbGVzJyB8ICdxdWV1ZWQnIHwgJ3J1bm5pbmcnIHwgJ3N1Y2NlZWRlZCcgfCAnZmFpbGVkJyB8ICdjYW5jZWxsZWQnO1xuXG4gIC8qKlxuICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIGJpbGxhYmxlIHRva2VucyBwcm9jZXNzZWQgYnkgdGhpcyBmaW5lLXR1bmluZyBqb2IuIFRoZSB2YWx1ZVxuICAgKiB3aWxsIGJlIG51bGwgaWYgdGhlIGZpbmUtdHVuaW5nIGpvYiBpcyBzdGlsbCBydW5uaW5nLlxuICAgKi9cbiAgdHJhaW5lZF90b2tlbnM6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBmaWxlIElEIHVzZWQgZm9yIHRyYWluaW5nLiBZb3UgY2FuIHJldHJpZXZlIHRoZSB0cmFpbmluZyBkYXRhIHdpdGggdGhlXG4gICAqIFtGaWxlcyBBUEldKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMvcmV0cmlldmUtY29udGVudHMpLlxuICAgKi9cbiAgdHJhaW5pbmdfZmlsZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZmlsZSBJRCB1c2VkIGZvciB2YWxpZGF0aW9uLiBZb3UgY2FuIHJldHJpZXZlIHRoZSB2YWxpZGF0aW9uIHJlc3VsdHMgd2l0aFxuICAgKiB0aGVcbiAgICogW0ZpbGVzIEFQSV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9yZXRyaWV2ZS1jb250ZW50cykuXG4gICAqL1xuICB2YWxpZGF0aW9uX2ZpbGU6IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGZpbmUtdHVuaW5nIGpvYiBpcyBlc3RpbWF0ZWQgdG9cbiAgICogZmluaXNoLiBUaGUgdmFsdWUgd2lsbCBiZSBudWxsIGlmIHRoZSBmaW5lLXR1bmluZyBqb2IgaXMgbm90IHJ1bm5pbmcuXG4gICAqL1xuICBlc3RpbWF0ZWRfZmluaXNoPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGludGVncmF0aW9ucyB0byBlbmFibGUgZm9yIHRoaXMgZmluZS10dW5pbmcgam9iLlxuICAgKi9cbiAgaW50ZWdyYXRpb25zPzogQXJyYXk8RmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb25PYmplY3Q+IHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1ldGhvZCB1c2VkIGZvciBmaW5lLXR1bmluZy5cbiAgICovXG4gIG1ldGhvZD86IEZpbmVUdW5pbmdKb2IuTWV0aG9kO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZpbmVUdW5pbmdKb2Ige1xuICAvKipcbiAgICogRm9yIGZpbmUtdHVuaW5nIGpvYnMgdGhhdCBoYXZlIGBmYWlsZWRgLCB0aGlzIHdpbGwgY29udGFpbiBtb3JlIGluZm9ybWF0aW9uIG9uXG4gICAqIHRoZSBjYXVzZSBvZiB0aGUgZmFpbHVyZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEEgbWFjaGluZS1yZWFkYWJsZSBlcnJvciBjb2RlLlxuICAgICAqL1xuICAgIGNvZGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEEgaHVtYW4tcmVhZGFibGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBtZXNzYWdlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGFyYW1ldGVyIHRoYXQgd2FzIGludmFsaWQsIHVzdWFsbHkgYHRyYWluaW5nX2ZpbGVgIG9yIGB2YWxpZGF0aW9uX2ZpbGVgLlxuICAgICAqIFRoaXMgZmllbGQgd2lsbCBiZSBudWxsIGlmIHRoZSBmYWlsdXJlIHdhcyBub3QgcGFyYW1ldGVyLXNwZWNpZmljLlxuICAgICAqL1xuICAgIHBhcmFtOiBzdHJpbmcgfCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi4gVGhpcyB2YWx1ZSB3aWxsIG9ubHkgYmVcbiAgICogcmV0dXJuZWQgd2hlbiBydW5uaW5nIGBzdXBlcnZpc2VkYCBqb2JzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBIeXBlcnBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBleGFtcGxlcyBpbiBlYWNoIGJhdGNoLiBBIGxhcmdlciBiYXRjaCBzaXplIG1lYW5zIHRoYXQgbW9kZWxcbiAgICAgKiBwYXJhbWV0ZXJzIGFyZSB1cGRhdGVkIGxlc3MgZnJlcXVlbnRseSwgYnV0IHdpdGggbG93ZXIgdmFyaWFuY2UuXG4gICAgICovXG4gICAgYmF0Y2hfc2l6ZT86ICdhdXRvJyB8IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFNjYWxpbmcgZmFjdG9yIGZvciB0aGUgbGVhcm5pbmcgcmF0ZS4gQSBzbWFsbGVyIGxlYXJuaW5nIHJhdGUgbWF5IGJlIHVzZWZ1bCB0b1xuICAgICAqIGF2b2lkIG92ZXJmaXR0aW5nLlxuICAgICAqL1xuICAgIGxlYXJuaW5nX3JhdGVfbXVsdGlwbGllcj86ICdhdXRvJyB8IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZXBvY2hzIHRvIHRyYWluIHRoZSBtb2RlbCBmb3IuIEFuIGVwb2NoIHJlZmVycyB0byBvbmUgZnVsbCBjeWNsZVxuICAgICAqIHRocm91Z2ggdGhlIHRyYWluaW5nIGRhdGFzZXQuXG4gICAgICovXG4gICAgbl9lcG9jaHM/OiAnYXV0bycgfCBudW1iZXI7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1ldGhvZCB1c2VkIGZvciBmaW5lLXR1bmluZy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgTWV0aG9kIHtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGZvciB0aGUgRFBPIGZpbmUtdHVuaW5nIG1ldGhvZC5cbiAgICAgKi9cbiAgICBkcG8/OiBNZXRob2QuRHBvO1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIHN1cGVydmlzZWQgZmluZS10dW5pbmcgbWV0aG9kLlxuICAgICAqL1xuICAgIHN1cGVydmlzZWQ/OiBNZXRob2QuU3VwZXJ2aXNlZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIG1ldGhvZC4gSXMgZWl0aGVyIGBzdXBlcnZpc2VkYCBvciBgZHBvYC5cbiAgICAgKi9cbiAgICB0eXBlPzogJ3N1cGVydmlzZWQnIHwgJ2Rwbyc7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIE1ldGhvZCB7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIERQTyBmaW5lLXR1bmluZyBtZXRob2QuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBEcG8ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuXG4gICAgICAgKi9cbiAgICAgIGh5cGVycGFyYW1ldGVycz86IERwby5IeXBlcnBhcmFtZXRlcnM7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBEcG8ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuXG4gICAgICAgKi9cbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgSHlwZXJwYXJhbWV0ZXJzIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBvZiBleGFtcGxlcyBpbiBlYWNoIGJhdGNoLiBBIGxhcmdlciBiYXRjaCBzaXplIG1lYW5zIHRoYXQgbW9kZWxcbiAgICAgICAgICogcGFyYW1ldGVycyBhcmUgdXBkYXRlZCBsZXNzIGZyZXF1ZW50bHksIGJ1dCB3aXRoIGxvd2VyIHZhcmlhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgYmF0Y2hfc2l6ZT86ICdhdXRvJyB8IG51bWJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJldGEgdmFsdWUgZm9yIHRoZSBEUE8gbWV0aG9kLiBBIGhpZ2hlciBiZXRhIHZhbHVlIHdpbGwgaW5jcmVhc2UgdGhlIHdlaWdodFxuICAgICAgICAgKiBvZiB0aGUgcGVuYWx0eSBiZXR3ZWVuIHRoZSBwb2xpY3kgYW5kIHJlZmVyZW5jZSBtb2RlbC5cbiAgICAgICAgICovXG4gICAgICAgIGJldGE/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxpbmcgZmFjdG9yIGZvciB0aGUgbGVhcm5pbmcgcmF0ZS4gQSBzbWFsbGVyIGxlYXJuaW5nIHJhdGUgbWF5IGJlIHVzZWZ1bCB0b1xuICAgICAgICAgKiBhdm9pZCBvdmVyZml0dGluZy5cbiAgICAgICAgICovXG4gICAgICAgIGxlYXJuaW5nX3JhdGVfbXVsdGlwbGllcj86ICdhdXRvJyB8IG51bWJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBlcG9jaHMgdG8gdHJhaW4gdGhlIG1vZGVsIGZvci4gQW4gZXBvY2ggcmVmZXJzIHRvIG9uZSBmdWxsIGN5Y2xlXG4gICAgICAgICAqIHRocm91Z2ggdGhlIHRyYWluaW5nIGRhdGFzZXQuXG4gICAgICAgICAqL1xuICAgICAgICBuX2Vwb2Nocz86ICdhdXRvJyB8IG51bWJlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGZvciB0aGUgc3VwZXJ2aXNlZCBmaW5lLXR1bmluZyBtZXRob2QuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBTdXBlcnZpc2VkIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgICAgICovXG4gICAgICBoeXBlcnBhcmFtZXRlcnM/OiBTdXBlcnZpc2VkLkh5cGVycGFyYW1ldGVycztcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIFN1cGVydmlzZWQge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuXG4gICAgICAgKi9cbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgSHlwZXJwYXJhbWV0ZXJzIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBvZiBleGFtcGxlcyBpbiBlYWNoIGJhdGNoLiBBIGxhcmdlciBiYXRjaCBzaXplIG1lYW5zIHRoYXQgbW9kZWxcbiAgICAgICAgICogcGFyYW1ldGVycyBhcmUgdXBkYXRlZCBsZXNzIGZyZXF1ZW50bHksIGJ1dCB3aXRoIGxvd2VyIHZhcmlhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgYmF0Y2hfc2l6ZT86ICdhdXRvJyB8IG51bWJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2NhbGluZyBmYWN0b3IgZm9yIHRoZSBsZWFybmluZyByYXRlLiBBIHNtYWxsZXIgbGVhcm5pbmcgcmF0ZSBtYXkgYmUgdXNlZnVsIHRvXG4gICAgICAgICAqIGF2b2lkIG92ZXJmaXR0aW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgbGVhcm5pbmdfcmF0ZV9tdWx0aXBsaWVyPzogJ2F1dG8nIHwgbnVtYmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGVwb2NocyB0byB0cmFpbiB0aGUgbW9kZWwgZm9yLiBBbiBlcG9jaCByZWZlcnMgdG8gb25lIGZ1bGwgY3ljbGVcbiAgICAgICAgICogdGhyb3VnaCB0aGUgdHJhaW5pbmcgZGF0YXNldC5cbiAgICAgICAgICovXG4gICAgICAgIG5fZXBvY2hzPzogJ2F1dG8nIHwgbnVtYmVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEZpbmUtdHVuaW5nIGpvYiBldmVudCBvYmplY3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaW5lVHVuaW5nSm9iRXZlbnQge1xuICAvKipcbiAgICogVGhlIG9iamVjdCBpZGVudGlmaWVyLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgZmluZS10dW5pbmcgam9iIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbG9nIGxldmVsIG9mIHRoZSBldmVudC5cbiAgICovXG4gIGxldmVsOiAnaW5mbycgfCAnd2FybicgfCAnZXJyb3InO1xuXG4gIC8qKlxuICAgKiBUaGUgbWVzc2FnZSBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBtZXNzYWdlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwiZmluZV90dW5pbmcuam9iLmV2ZW50XCIuXG4gICAqL1xuICBvYmplY3Q6ICdmaW5lX3R1bmluZy5qb2IuZXZlbnQnO1xuXG4gIC8qKlxuICAgKiBUaGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxuICAgKi9cbiAgZGF0YT86IHVua25vd247XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGV2ZW50LlxuICAgKi9cbiAgdHlwZT86ICdtZXNzYWdlJyB8ICdtZXRyaWNzJztcbn1cblxuZXhwb3J0IHR5cGUgRmluZVR1bmluZ0pvYkludGVncmF0aW9uID0gRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb25PYmplY3Q7XG5cbi8qKlxuICogVGhlIHNldHRpbmdzIGZvciB5b3VyIGludGVncmF0aW9uIHdpdGggV2VpZ2h0cyBhbmQgQmlhc2VzLiBUaGlzIHBheWxvYWRcbiAqIHNwZWNpZmllcyB0aGUgcHJvamVjdCB0aGF0IG1ldHJpY3Mgd2lsbCBiZSBzZW50IHRvLiBPcHRpb25hbGx5LCB5b3UgY2FuIHNldCBhblxuICogZXhwbGljaXQgZGlzcGxheSBuYW1lIGZvciB5b3VyIHJ1biwgYWRkIHRhZ3MgdG8geW91ciBydW4sIGFuZCBzZXQgYSBkZWZhdWx0XG4gKiBlbnRpdHkgKHRlYW0sIHVzZXJuYW1lLCBldGMpIHRvIGJlIGFzc29jaWF0ZWQgd2l0aCB5b3VyIHJ1bi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcHJvamVjdCB0aGF0IHRoZSBuZXcgcnVuIHdpbGwgYmUgY3JlYXRlZCB1bmRlci5cbiAgICovXG4gIHByb2plY3Q6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGVudGl0eSB0byB1c2UgZm9yIHRoZSBydW4uIFRoaXMgYWxsb3dzIHlvdSB0byBzZXQgdGhlIHRlYW0gb3IgdXNlcm5hbWUgb2ZcbiAgICogdGhlIFdhbmRCIHVzZXIgdGhhdCB5b3Ugd291bGQgbGlrZSBhc3NvY2lhdGVkIHdpdGggdGhlIHJ1bi4gSWYgbm90IHNldCwgdGhlXG4gICAqIGRlZmF1bHQgZW50aXR5IGZvciB0aGUgcmVnaXN0ZXJlZCBXYW5kQiBBUEkga2V5IGlzIHVzZWQuXG4gICAqL1xuICBlbnRpdHk/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIGRpc3BsYXkgbmFtZSB0byBzZXQgZm9yIHRoZSBydW4uIElmIG5vdCBzZXQsIHdlIHdpbGwgdXNlIHRoZSBKb2IgSUQgYXMgdGhlXG4gICAqIG5hbWUuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIHRhZ3MgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgcnVuLiBUaGVzZSB0YWdzIGFyZSBwYXNzZWRcbiAgICogdGhyb3VnaCBkaXJlY3RseSB0byBXYW5kQi4gU29tZSBkZWZhdWx0IHRhZ3MgYXJlIGdlbmVyYXRlZCBieSBPcGVuQUk6XG4gICAqIFwib3BlbmFpL2ZpbmV0dW5lXCIsIFwib3BlbmFpL3tiYXNlLW1vZGVsfVwiLCBcIm9wZW5haS97ZnRqb2ItYWJjZGVmfVwiLlxuICAgKi9cbiAgdGFncz86IEFycmF5PHN0cmluZz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb25PYmplY3Qge1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIGludGVncmF0aW9uIGJlaW5nIGVuYWJsZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2JcbiAgICovXG4gIHR5cGU6ICd3YW5kYic7XG5cbiAgLyoqXG4gICAqIFRoZSBzZXR0aW5ncyBmb3IgeW91ciBpbnRlZ3JhdGlvbiB3aXRoIFdlaWdodHMgYW5kIEJpYXNlcy4gVGhpcyBwYXlsb2FkXG4gICAqIHNwZWNpZmllcyB0aGUgcHJvamVjdCB0aGF0IG1ldHJpY3Mgd2lsbCBiZSBzZW50IHRvLiBPcHRpb25hbGx5LCB5b3UgY2FuIHNldCBhblxuICAgKiBleHBsaWNpdCBkaXNwbGF5IG5hbWUgZm9yIHlvdXIgcnVuLCBhZGQgdGFncyB0byB5b3VyIHJ1biwgYW5kIHNldCBhIGRlZmF1bHRcbiAgICogZW50aXR5ICh0ZWFtLCB1c2VybmFtZSwgZXRjKSB0byBiZSBhc3NvY2lhdGVkIHdpdGggeW91ciBydW4uXG4gICAqL1xuICB3YW5kYjogRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSm9iQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBtb2RlbCB0byBmaW5lLXR1bmUuIFlvdSBjYW4gc2VsZWN0IG9uZSBvZiB0aGVcbiAgICogW3N1cHBvcnRlZCBtb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9maW5lLXR1bmluZyN3aGljaC1tb2RlbHMtY2FuLWJlLWZpbmUtdHVuZWQpLlxuICAgKi9cbiAgbW9kZWw6IChzdHJpbmcgJiB7fSkgfCAnYmFiYmFnZS0wMDInIHwgJ2RhdmluY2ktMDAyJyB8ICdncHQtMy41LXR1cmJvJyB8ICdncHQtNG8tbWluaSc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiBhbiB1cGxvYWRlZCBmaWxlIHRoYXQgY29udGFpbnMgdHJhaW5pbmcgZGF0YS5cbiAgICpcbiAgICogU2VlIFt1cGxvYWQgZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9jcmVhdGUpXG4gICAqIGZvciBob3cgdG8gdXBsb2FkIGEgZmlsZS5cbiAgICpcbiAgICogWW91ciBkYXRhc2V0IG11c3QgYmUgZm9ybWF0dGVkIGFzIGEgSlNPTkwgZmlsZS4gQWRkaXRpb25hbGx5LCB5b3UgbXVzdCB1cGxvYWRcbiAgICogeW91ciBmaWxlIHdpdGggdGhlIHB1cnBvc2UgYGZpbmUtdHVuZWAuXG4gICAqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgZmlsZSBzaG91bGQgZGlmZmVyIGRlcGVuZGluZyBvbiBpZiB0aGUgbW9kZWwgdXNlcyB0aGVcbiAgICogW2NoYXRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmluZS10dW5pbmcvY2hhdC1pbnB1dCksXG4gICAqIFtjb21wbGV0aW9uc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maW5lLXR1bmluZy9jb21wbGV0aW9ucy1pbnB1dClcbiAgICogZm9ybWF0LCBvciBpZiB0aGUgZmluZS10dW5pbmcgbWV0aG9kIHVzZXMgdGhlXG4gICAqIFtwcmVmZXJlbmNlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuaW5nL3ByZWZlcmVuY2UtaW5wdXQpXG4gICAqIGZvcm1hdC5cbiAgICpcbiAgICogU2VlIHRoZSBbZmluZS10dW5pbmcgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9maW5lLXR1bmluZylcbiAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIHRyYWluaW5nX2ZpbGU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLiBUaGlzIHZhbHVlIGlzIG5vdyBkZXByZWNhdGVkXG4gICAqIGluIGZhdm9yIG9mIGBtZXRob2RgLCBhbmQgc2hvdWxkIGJlIHBhc3NlZCBpbiB1bmRlciB0aGUgYG1ldGhvZGAgcGFyYW1ldGVyLlxuICAgKi9cbiAgaHlwZXJwYXJhbWV0ZXJzPzogSm9iQ3JlYXRlUGFyYW1zLkh5cGVycGFyYW1ldGVycztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGludGVncmF0aW9ucyB0byBlbmFibGUgZm9yIHlvdXIgZmluZS10dW5pbmcgam9iLlxuICAgKi9cbiAgaW50ZWdyYXRpb25zPzogQXJyYXk8Sm9iQ3JlYXRlUGFyYW1zLkludGVncmF0aW9uPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgdXNlZCBmb3IgZmluZS10dW5pbmcuXG4gICAqL1xuICBtZXRob2Q/OiBKb2JDcmVhdGVQYXJhbXMuTWV0aG9kO1xuXG4gIC8qKlxuICAgKiBUaGUgc2VlZCBjb250cm9scyB0aGUgcmVwcm9kdWNpYmlsaXR5IG9mIHRoZSBqb2IuIFBhc3NpbmcgaW4gdGhlIHNhbWUgc2VlZCBhbmRcbiAgICogam9iIHBhcmFtZXRlcnMgc2hvdWxkIHByb2R1Y2UgdGhlIHNhbWUgcmVzdWx0cywgYnV0IG1heSBkaWZmZXIgaW4gcmFyZSBjYXNlcy4gSWZcbiAgICogYSBzZWVkIGlzIG5vdCBzcGVjaWZpZWQsIG9uZSB3aWxsIGJlIGdlbmVyYXRlZCBmb3IgeW91LlxuICAgKi9cbiAgc2VlZD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgc3RyaW5nIG9mIHVwIHRvIDY0IGNoYXJhY3RlcnMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHlvdXIgZmluZS10dW5lZCBtb2RlbFxuICAgKiBuYW1lLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgYSBgc3VmZml4YCBvZiBcImN1c3RvbS1tb2RlbC1uYW1lXCIgd291bGQgcHJvZHVjZSBhIG1vZGVsIG5hbWUgbGlrZVxuICAgKiBgZnQ6Z3B0LTRvLW1pbmk6b3BlbmFpOmN1c3RvbS1tb2RlbC1uYW1lOjdwNGxVUmVsYC5cbiAgICovXG4gIHN1ZmZpeD86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiBhbiB1cGxvYWRlZCBmaWxlIHRoYXQgY29udGFpbnMgdmFsaWRhdGlvbiBkYXRhLlxuICAgKlxuICAgKiBJZiB5b3UgcHJvdmlkZSB0aGlzIGZpbGUsIHRoZSBkYXRhIGlzIHVzZWQgdG8gZ2VuZXJhdGUgdmFsaWRhdGlvbiBtZXRyaWNzXG4gICAqIHBlcmlvZGljYWxseSBkdXJpbmcgZmluZS10dW5pbmcuIFRoZXNlIG1ldHJpY3MgY2FuIGJlIHZpZXdlZCBpbiB0aGUgZmluZS10dW5pbmdcbiAgICogcmVzdWx0cyBmaWxlLiBUaGUgc2FtZSBkYXRhIHNob3VsZCBub3QgYmUgcHJlc2VudCBpbiBib3RoIHRyYWluIGFuZCB2YWxpZGF0aW9uXG4gICAqIGZpbGVzLlxuICAgKlxuICAgKiBZb3VyIGRhdGFzZXQgbXVzdCBiZSBmb3JtYXR0ZWQgYXMgYSBKU09OTCBmaWxlLiBZb3UgbXVzdCB1cGxvYWQgeW91ciBmaWxlIHdpdGhcbiAgICogdGhlIHB1cnBvc2UgYGZpbmUtdHVuZWAuXG4gICAqXG4gICAqIFNlZSB0aGUgW2ZpbmUtdHVuaW5nIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICB2YWxpZGF0aW9uX2ZpbGU/OiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEpvYkNyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZDogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLiBUaGlzIHZhbHVlIGlzIG5vd1xuICAgKiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGBtZXRob2RgLCBhbmQgc2hvdWxkIGJlIHBhc3NlZCBpbiB1bmRlciB0aGUgYG1ldGhvZGBcbiAgICogcGFyYW1ldGVyLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBIeXBlcnBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBleGFtcGxlcyBpbiBlYWNoIGJhdGNoLiBBIGxhcmdlciBiYXRjaCBzaXplIG1lYW5zIHRoYXQgbW9kZWxcbiAgICAgKiBwYXJhbWV0ZXJzIGFyZSB1cGRhdGVkIGxlc3MgZnJlcXVlbnRseSwgYnV0IHdpdGggbG93ZXIgdmFyaWFuY2UuXG4gICAgICovXG4gICAgYmF0Y2hfc2l6ZT86ICdhdXRvJyB8IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFNjYWxpbmcgZmFjdG9yIGZvciB0aGUgbGVhcm5pbmcgcmF0ZS4gQSBzbWFsbGVyIGxlYXJuaW5nIHJhdGUgbWF5IGJlIHVzZWZ1bCB0b1xuICAgICAqIGF2b2lkIG92ZXJmaXR0aW5nLlxuICAgICAqL1xuICAgIGxlYXJuaW5nX3JhdGVfbXVsdGlwbGllcj86ICdhdXRvJyB8IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZXBvY2hzIHRvIHRyYWluIHRoZSBtb2RlbCBmb3IuIEFuIGVwb2NoIHJlZmVycyB0byBvbmUgZnVsbCBjeWNsZVxuICAgICAqIHRocm91Z2ggdGhlIHRyYWluaW5nIGRhdGFzZXQuXG4gICAgICovXG4gICAgbl9lcG9jaHM/OiAnYXV0bycgfCBudW1iZXI7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIEludGVncmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBpbnRlZ3JhdGlvbiB0byBlbmFibGUuIEN1cnJlbnRseSwgb25seSBcIndhbmRiXCIgKFdlaWdodHMgYW5kIEJpYXNlcylcbiAgICAgKiBpcyBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgdHlwZTogJ3dhbmRiJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZXR0aW5ncyBmb3IgeW91ciBpbnRlZ3JhdGlvbiB3aXRoIFdlaWdodHMgYW5kIEJpYXNlcy4gVGhpcyBwYXlsb2FkXG4gICAgICogc3BlY2lmaWVzIHRoZSBwcm9qZWN0IHRoYXQgbWV0cmljcyB3aWxsIGJlIHNlbnQgdG8uIE9wdGlvbmFsbHksIHlvdSBjYW4gc2V0IGFuXG4gICAgICogZXhwbGljaXQgZGlzcGxheSBuYW1lIGZvciB5b3VyIHJ1biwgYWRkIHRhZ3MgdG8geW91ciBydW4sIGFuZCBzZXQgYSBkZWZhdWx0XG4gICAgICogZW50aXR5ICh0ZWFtLCB1c2VybmFtZSwgZXRjKSB0byBiZSBhc3NvY2lhdGVkIHdpdGggeW91ciBydW4uXG4gICAgICovXG4gICAgd2FuZGI6IEludGVncmF0aW9uLldhbmRiO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBJbnRlZ3JhdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNldHRpbmdzIGZvciB5b3VyIGludGVncmF0aW9uIHdpdGggV2VpZ2h0cyBhbmQgQmlhc2VzLiBUaGlzIHBheWxvYWRcbiAgICAgKiBzcGVjaWZpZXMgdGhlIHByb2plY3QgdGhhdCBtZXRyaWNzIHdpbGwgYmUgc2VudCB0by4gT3B0aW9uYWxseSwgeW91IGNhbiBzZXQgYW5cbiAgICAgKiBleHBsaWNpdCBkaXNwbGF5IG5hbWUgZm9yIHlvdXIgcnVuLCBhZGQgdGFncyB0byB5b3VyIHJ1biwgYW5kIHNldCBhIGRlZmF1bHRcbiAgICAgKiBlbnRpdHkgKHRlYW0sIHVzZXJuYW1lLCBldGMpIHRvIGJlIGFzc29jaWF0ZWQgd2l0aCB5b3VyIHJ1bi5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIFdhbmRiIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHByb2plY3QgdGhhdCB0aGUgbmV3IHJ1biB3aWxsIGJlIGNyZWF0ZWQgdW5kZXIuXG4gICAgICAgKi9cbiAgICAgIHByb2plY3Q6IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZW50aXR5IHRvIHVzZSBmb3IgdGhlIHJ1bi4gVGhpcyBhbGxvd3MgeW91IHRvIHNldCB0aGUgdGVhbSBvciB1c2VybmFtZSBvZlxuICAgICAgICogdGhlIFdhbmRCIHVzZXIgdGhhdCB5b3Ugd291bGQgbGlrZSBhc3NvY2lhdGVkIHdpdGggdGhlIHJ1bi4gSWYgbm90IHNldCwgdGhlXG4gICAgICAgKiBkZWZhdWx0IGVudGl0eSBmb3IgdGhlIHJlZ2lzdGVyZWQgV2FuZEIgQVBJIGtleSBpcyB1c2VkLlxuICAgICAgICovXG4gICAgICBlbnRpdHk/OiBzdHJpbmcgfCBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgZGlzcGxheSBuYW1lIHRvIHNldCBmb3IgdGhlIHJ1bi4gSWYgbm90IHNldCwgd2Ugd2lsbCB1c2UgdGhlIEpvYiBJRCBhcyB0aGVcbiAgICAgICAqIG5hbWUuXG4gICAgICAgKi9cbiAgICAgIG5hbWU/OiBzdHJpbmcgfCBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiB0YWdzIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBuZXdseSBjcmVhdGVkIHJ1bi4gVGhlc2UgdGFncyBhcmUgcGFzc2VkXG4gICAgICAgKiB0aHJvdWdoIGRpcmVjdGx5IHRvIFdhbmRCLiBTb21lIGRlZmF1bHQgdGFncyBhcmUgZ2VuZXJhdGVkIGJ5IE9wZW5BSTpcbiAgICAgICAqIFwib3BlbmFpL2ZpbmV0dW5lXCIsIFwib3BlbmFpL3tiYXNlLW1vZGVsfVwiLCBcIm9wZW5haS97ZnRqb2ItYWJjZGVmfVwiLlxuICAgICAgICovXG4gICAgICB0YWdzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1ldGhvZCB1c2VkIGZvciBmaW5lLXR1bmluZy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgTWV0aG9kIHtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGZvciB0aGUgRFBPIGZpbmUtdHVuaW5nIG1ldGhvZC5cbiAgICAgKi9cbiAgICBkcG8/OiBNZXRob2QuRHBvO1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIHN1cGVydmlzZWQgZmluZS10dW5pbmcgbWV0aG9kLlxuICAgICAqL1xuICAgIHN1cGVydmlzZWQ/OiBNZXRob2QuU3VwZXJ2aXNlZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIG1ldGhvZC4gSXMgZWl0aGVyIGBzdXBlcnZpc2VkYCBvciBgZHBvYC5cbiAgICAgKi9cbiAgICB0eXBlPzogJ3N1cGVydmlzZWQnIHwgJ2Rwbyc7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIE1ldGhvZCB7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIERQTyBmaW5lLXR1bmluZyBtZXRob2QuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBEcG8ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuXG4gICAgICAgKi9cbiAgICAgIGh5cGVycGFyYW1ldGVycz86IERwby5IeXBlcnBhcmFtZXRlcnM7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBEcG8ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuXG4gICAgICAgKi9cbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgSHlwZXJwYXJhbWV0ZXJzIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBvZiBleGFtcGxlcyBpbiBlYWNoIGJhdGNoLiBBIGxhcmdlciBiYXRjaCBzaXplIG1lYW5zIHRoYXQgbW9kZWxcbiAgICAgICAgICogcGFyYW1ldGVycyBhcmUgdXBkYXRlZCBsZXNzIGZyZXF1ZW50bHksIGJ1dCB3aXRoIGxvd2VyIHZhcmlhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgYmF0Y2hfc2l6ZT86ICdhdXRvJyB8IG51bWJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJldGEgdmFsdWUgZm9yIHRoZSBEUE8gbWV0aG9kLiBBIGhpZ2hlciBiZXRhIHZhbHVlIHdpbGwgaW5jcmVhc2UgdGhlIHdlaWdodFxuICAgICAgICAgKiBvZiB0aGUgcGVuYWx0eSBiZXR3ZWVuIHRoZSBwb2xpY3kgYW5kIHJlZmVyZW5jZSBtb2RlbC5cbiAgICAgICAgICovXG4gICAgICAgIGJldGE/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxpbmcgZmFjdG9yIGZvciB0aGUgbGVhcm5pbmcgcmF0ZS4gQSBzbWFsbGVyIGxlYXJuaW5nIHJhdGUgbWF5IGJlIHVzZWZ1bCB0b1xuICAgICAgICAgKiBhdm9pZCBvdmVyZml0dGluZy5cbiAgICAgICAgICovXG4gICAgICAgIGxlYXJuaW5nX3JhdGVfbXVsdGlwbGllcj86ICdhdXRvJyB8IG51bWJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBlcG9jaHMgdG8gdHJhaW4gdGhlIG1vZGVsIGZvci4gQW4gZXBvY2ggcmVmZXJzIHRvIG9uZSBmdWxsIGN5Y2xlXG4gICAgICAgICAqIHRocm91Z2ggdGhlIHRyYWluaW5nIGRhdGFzZXQuXG4gICAgICAgICAqL1xuICAgICAgICBuX2Vwb2Nocz86ICdhdXRvJyB8IG51bWJlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGZvciB0aGUgc3VwZXJ2aXNlZCBmaW5lLXR1bmluZyBtZXRob2QuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBTdXBlcnZpc2VkIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgICAgICovXG4gICAgICBoeXBlcnBhcmFtZXRlcnM/OiBTdXBlcnZpc2VkLkh5cGVycGFyYW1ldGVycztcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIFN1cGVydmlzZWQge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuXG4gICAgICAgKi9cbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgSHlwZXJwYXJhbWV0ZXJzIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBvZiBleGFtcGxlcyBpbiBlYWNoIGJhdGNoLiBBIGxhcmdlciBiYXRjaCBzaXplIG1lYW5zIHRoYXQgbW9kZWxcbiAgICAgICAgICogcGFyYW1ldGVycyBhcmUgdXBkYXRlZCBsZXNzIGZyZXF1ZW50bHksIGJ1dCB3aXRoIGxvd2VyIHZhcmlhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgYmF0Y2hfc2l6ZT86ICdhdXRvJyB8IG51bWJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2NhbGluZyBmYWN0b3IgZm9yIHRoZSBsZWFybmluZyByYXRlLiBBIHNtYWxsZXIgbGVhcm5pbmcgcmF0ZSBtYXkgYmUgdXNlZnVsIHRvXG4gICAgICAgICAqIGF2b2lkIG92ZXJmaXR0aW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgbGVhcm5pbmdfcmF0ZV9tdWx0aXBsaWVyPzogJ2F1dG8nIHwgbnVtYmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGVwb2NocyB0byB0cmFpbiB0aGUgbW9kZWwgZm9yLiBBbiBlcG9jaCByZWZlcnMgdG8gb25lIGZ1bGwgY3ljbGVcbiAgICAgICAgICogdGhyb3VnaCB0aGUgdHJhaW5pbmcgZGF0YXNldC5cbiAgICAgICAgICovXG4gICAgICAgIG5fZXBvY2hzPzogJ2F1dG8nIHwgbnVtYmVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEpvYkxpc3RQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgSm9iTGlzdEV2ZW50c1BhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge31cblxuSm9icy5GaW5lVHVuaW5nSm9ic1BhZ2UgPSBGaW5lVHVuaW5nSm9ic1BhZ2U7XG5Kb2JzLkZpbmVUdW5pbmdKb2JFdmVudHNQYWdlID0gRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2U7XG5Kb2JzLkNoZWNrcG9pbnRzID0gQ2hlY2twb2ludHM7XG5Kb2JzLkZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UgPSBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgSm9icyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iIGFzIEZpbmVUdW5pbmdKb2IsXG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iRXZlbnQgYXMgRmluZVR1bmluZ0pvYkV2ZW50LFxuICAgIHR5cGUgRmluZVR1bmluZ0pvYkludGVncmF0aW9uIGFzIEZpbmVUdW5pbmdKb2JJbnRlZ3JhdGlvbixcbiAgICB0eXBlIEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uIGFzIEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uLFxuICAgIHR5cGUgRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb25PYmplY3QgYXMgRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb25PYmplY3QsXG4gICAgRmluZVR1bmluZ0pvYnNQYWdlIGFzIEZpbmVUdW5pbmdKb2JzUGFnZSxcbiAgICBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSBhcyBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSxcbiAgICB0eXBlIEpvYkNyZWF0ZVBhcmFtcyBhcyBKb2JDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBKb2JMaXN0UGFyYW1zIGFzIEpvYkxpc3RQYXJhbXMsXG4gICAgdHlwZSBKb2JMaXN0RXZlbnRzUGFyYW1zIGFzIEpvYkxpc3RFdmVudHNQYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHtcbiAgICBDaGVja3BvaW50cyBhcyBDaGVja3BvaW50cyxcbiAgICB0eXBlIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50IGFzIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50LFxuICAgIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UgYXMgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSxcbiAgICB0eXBlIENoZWNrcG9pbnRMaXN0UGFyYW1zIGFzIENoZWNrcG9pbnRMaXN0UGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgSm9ic0FQSSBmcm9tICcuL2pvYnMvam9icyc7XG5pbXBvcnQge1xuICBGaW5lVHVuaW5nSm9iLFxuICBGaW5lVHVuaW5nSm9iRXZlbnQsXG4gIEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlLFxuICBGaW5lVHVuaW5nSm9iSW50ZWdyYXRpb24sXG4gIEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uLFxuICBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbk9iamVjdCxcbiAgRmluZVR1bmluZ0pvYnNQYWdlLFxuICBKb2JDcmVhdGVQYXJhbXMsXG4gIEpvYkxpc3RFdmVudHNQYXJhbXMsXG4gIEpvYkxpc3RQYXJhbXMsXG4gIEpvYnMsXG59IGZyb20gJy4vam9icy9qb2JzJztcblxuZXhwb3J0IGNsYXNzIEZpbmVUdW5pbmcgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIGpvYnM6IEpvYnNBUEkuSm9icyA9IG5ldyBKb2JzQVBJLkpvYnModGhpcy5fY2xpZW50KTtcbn1cblxuRmluZVR1bmluZy5Kb2JzID0gSm9icztcbkZpbmVUdW5pbmcuRmluZVR1bmluZ0pvYnNQYWdlID0gRmluZVR1bmluZ0pvYnNQYWdlO1xuRmluZVR1bmluZy5GaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSA9IEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgRmluZVR1bmluZyB7XG4gIGV4cG9ydCB7XG4gICAgSm9icyBhcyBKb2JzLFxuICAgIHR5cGUgRmluZVR1bmluZ0pvYiBhcyBGaW5lVHVuaW5nSm9iLFxuICAgIHR5cGUgRmluZVR1bmluZ0pvYkV2ZW50IGFzIEZpbmVUdW5pbmdKb2JFdmVudCxcbiAgICB0eXBlIEZpbmVUdW5pbmdKb2JJbnRlZ3JhdGlvbiBhcyBGaW5lVHVuaW5nSm9iSW50ZWdyYXRpb24sXG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbiBhcyBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbixcbiAgICB0eXBlIEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uT2JqZWN0IGFzIEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uT2JqZWN0LFxuICAgIEZpbmVUdW5pbmdKb2JzUGFnZSBhcyBGaW5lVHVuaW5nSm9ic1BhZ2UsXG4gICAgRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UgYXMgRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UsXG4gICAgdHlwZSBKb2JDcmVhdGVQYXJhbXMgYXMgSm9iQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgSm9iTGlzdFBhcmFtcyBhcyBKb2JMaXN0UGFyYW1zLFxuICAgIHR5cGUgSm9iTGlzdEV2ZW50c1BhcmFtcyBhcyBKb2JMaXN0RXZlbnRzUGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi9jb3JlJztcblxuZXhwb3J0IGNsYXNzIEltYWdlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB2YXJpYXRpb24gb2YgYSBnaXZlbiBpbWFnZS5cbiAgICovXG4gIGNyZWF0ZVZhcmlhdGlvbihcbiAgICBib2R5OiBJbWFnZUNyZWF0ZVZhcmlhdGlvblBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPEltYWdlc1Jlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvaW1hZ2VzL3ZhcmlhdGlvbnMnLCBDb3JlLm11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyh7IGJvZHksIC4uLm9wdGlvbnMgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZWRpdGVkIG9yIGV4dGVuZGVkIGltYWdlIGdpdmVuIGFuIG9yaWdpbmFsIGltYWdlIGFuZCBhIHByb21wdC5cbiAgICovXG4gIGVkaXQoYm9keTogSW1hZ2VFZGl0UGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxJbWFnZXNSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2ltYWdlcy9lZGl0cycsIENvcmUubXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zKHsgYm9keSwgLi4ub3B0aW9ucyB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbWFnZSBnaXZlbiBhIHByb21wdC5cbiAgICovXG4gIGdlbmVyYXRlKGJvZHk6IEltYWdlR2VuZXJhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEltYWdlc1Jlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvaW1hZ2VzL2dlbmVyYXRpb25zJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdXJsIG9yIHRoZSBjb250ZW50IG9mIGFuIGltYWdlIGdlbmVyYXRlZCBieSB0aGUgT3BlbkFJIEFQSS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbWFnZSB7XG4gIC8qKlxuICAgKiBUaGUgYmFzZTY0LWVuY29kZWQgSlNPTiBvZiB0aGUgZ2VuZXJhdGVkIGltYWdlLCBpZiBgcmVzcG9uc2VfZm9ybWF0YCBpc1xuICAgKiBgYjY0X2pzb25gLlxuICAgKi9cbiAgYjY0X2pzb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBwcm9tcHQgdGhhdCB3YXMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgaW1hZ2UsIGlmIHRoZXJlIHdhcyBhbnkgcmV2aXNpb24gdG8gdGhlXG4gICAqIHByb21wdC5cbiAgICovXG4gIHJldmlzZWRfcHJvbXB0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVVJMIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2UsIGlmIGByZXNwb25zZV9mb3JtYXRgIGlzIGB1cmxgIChkZWZhdWx0KS5cbiAgICovXG4gIHVybD86IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgSW1hZ2VNb2RlbCA9ICdkYWxsLWUtMicgfCAnZGFsbC1lLTMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlc1Jlc3BvbnNlIHtcbiAgY3JlYXRlZDogbnVtYmVyO1xuXG4gIGRhdGE6IEFycmF5PEltYWdlPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZUNyZWF0ZVZhcmlhdGlvblBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgaW1hZ2UgdG8gdXNlIGFzIHRoZSBiYXNpcyBmb3IgdGhlIHZhcmlhdGlvbihzKS4gTXVzdCBiZSBhIHZhbGlkIFBORyBmaWxlLFxuICAgKiBsZXNzIHRoYW4gNE1CLCBhbmQgc3F1YXJlLlxuICAgKi9cbiAgaW1hZ2U6IENvcmUuVXBsb2FkYWJsZTtcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHRvIHVzZSBmb3IgaW1hZ2UgZ2VuZXJhdGlvbi4gT25seSBgZGFsbC1lLTJgIGlzIHN1cHBvcnRlZCBhdCB0aGlzXG4gICAqIHRpbWUuXG4gICAqL1xuICBtb2RlbD86IChzdHJpbmcgJiB7fSkgfCBJbWFnZU1vZGVsIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBpbWFnZXMgdG8gZ2VuZXJhdGUuIE11c3QgYmUgYmV0d2VlbiAxIGFuZCAxMC4gRm9yIGBkYWxsLWUtM2AsIG9ubHlcbiAgICogYG49MWAgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgbj86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgaW4gd2hpY2ggdGhlIGdlbmVyYXRlZCBpbWFnZXMgYXJlIHJldHVybmVkLiBNdXN0IGJlIG9uZSBvZiBgdXJsYCBvclxuICAgKiBgYjY0X2pzb25gLiBVUkxzIGFyZSBvbmx5IHZhbGlkIGZvciA2MCBtaW51dGVzIGFmdGVyIHRoZSBpbWFnZSBoYXMgYmVlblxuICAgKiBnZW5lcmF0ZWQuXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiAndXJsJyB8ICdiNjRfanNvbicgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIGltYWdlcy4gTXVzdCBiZSBvbmUgb2YgYDI1NngyNTZgLCBgNTEyeDUxMmAsIG9yXG4gICAqIGAxMDI0eDEwMjRgLlxuICAgKi9cbiAgc2l6ZT86ICcyNTZ4MjU2JyB8ICc1MTJ4NTEyJyB8ICcxMDI0eDEwMjQnIHwgbnVsbDtcblxuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciByZXByZXNlbnRpbmcgeW91ciBlbmQtdXNlciwgd2hpY2ggY2FuIGhlbHAgT3BlbkFJIHRvIG1vbml0b3JcbiAgICogYW5kIGRldGVjdCBhYnVzZS5cbiAgICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zYWZldHktYmVzdC1wcmFjdGljZXMjZW5kLXVzZXItaWRzKS5cbiAgICovXG4gIHVzZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VFZGl0UGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBpbWFnZSB0byBlZGl0LiBNdXN0IGJlIGEgdmFsaWQgUE5HIGZpbGUsIGxlc3MgdGhhbiA0TUIsIGFuZCBzcXVhcmUuIElmIG1hc2tcbiAgICogaXMgbm90IHByb3ZpZGVkLCBpbWFnZSBtdXN0IGhhdmUgdHJhbnNwYXJlbmN5LCB3aGljaCB3aWxsIGJlIHVzZWQgYXMgdGhlIG1hc2suXG4gICAqL1xuICBpbWFnZTogQ29yZS5VcGxvYWRhYmxlO1xuXG4gIC8qKlxuICAgKiBBIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGRlc2lyZWQgaW1hZ2UocykuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyAxMDAwXG4gICAqIGNoYXJhY3RlcnMuXG4gICAqL1xuICBwcm9tcHQ6IHN0cmluZztcblxuICAvKipcbiAgICogQW4gYWRkaXRpb25hbCBpbWFnZSB3aG9zZSBmdWxseSB0cmFuc3BhcmVudCBhcmVhcyAoZS5nLiB3aGVyZSBhbHBoYSBpcyB6ZXJvKVxuICAgKiBpbmRpY2F0ZSB3aGVyZSBgaW1hZ2VgIHNob3VsZCBiZSBlZGl0ZWQuIE11c3QgYmUgYSB2YWxpZCBQTkcgZmlsZSwgbGVzcyB0aGFuXG4gICAqIDRNQiwgYW5kIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucyBhcyBgaW1hZ2VgLlxuICAgKi9cbiAgbWFzaz86IENvcmUuVXBsb2FkYWJsZTtcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHRvIHVzZSBmb3IgaW1hZ2UgZ2VuZXJhdGlvbi4gT25seSBgZGFsbC1lLTJgIGlzIHN1cHBvcnRlZCBhdCB0aGlzXG4gICAqIHRpbWUuXG4gICAqL1xuICBtb2RlbD86IChzdHJpbmcgJiB7fSkgfCBJbWFnZU1vZGVsIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBpbWFnZXMgdG8gZ2VuZXJhdGUuIE11c3QgYmUgYmV0d2VlbiAxIGFuZCAxMC5cbiAgICovXG4gIG4/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IGluIHdoaWNoIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzIGFyZSByZXR1cm5lZC4gTXVzdCBiZSBvbmUgb2YgYHVybGAgb3JcbiAgICogYGI2NF9qc29uYC4gVVJMcyBhcmUgb25seSB2YWxpZCBmb3IgNjAgbWludXRlcyBhZnRlciB0aGUgaW1hZ2UgaGFzIGJlZW5cbiAgICogZ2VuZXJhdGVkLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogJ3VybCcgfCAnYjY0X2pzb24nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIGdlbmVyYXRlZCBpbWFnZXMuIE11c3QgYmUgb25lIG9mIGAyNTZ4MjU2YCwgYDUxMng1MTJgLCBvclxuICAgKiBgMTAyNHgxMDI0YC5cbiAgICovXG4gIHNpemU/OiAnMjU2eDI1NicgfCAnNTEyeDUxMicgfCAnMTAyNHgxMDI0JyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgcmVwcmVzZW50aW5nIHlvdXIgZW5kLXVzZXIsIHdoaWNoIGNhbiBoZWxwIE9wZW5BSSB0byBtb25pdG9yXG4gICAqIGFuZCBkZXRlY3QgYWJ1c2UuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc2FmZXR5LWJlc3QtcHJhY3RpY2VzI2VuZC11c2VyLWlkcykuXG4gICAqL1xuICB1c2VyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlR2VuZXJhdGVQYXJhbXMge1xuICAvKipcbiAgICogQSB0ZXh0IGRlc2NyaXB0aW9uIG9mIHRoZSBkZXNpcmVkIGltYWdlKHMpLiBUaGUgbWF4aW11bSBsZW5ndGggaXMgMTAwMFxuICAgKiBjaGFyYWN0ZXJzIGZvciBgZGFsbC1lLTJgIGFuZCA0MDAwIGNoYXJhY3RlcnMgZm9yIGBkYWxsLWUtM2AuXG4gICAqL1xuICBwcm9tcHQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHRvIHVzZSBmb3IgaW1hZ2UgZ2VuZXJhdGlvbi5cbiAgICovXG4gIG1vZGVsPzogKHN0cmluZyAmIHt9KSB8IEltYWdlTW9kZWwgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGltYWdlcyB0byBnZW5lcmF0ZS4gTXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDEwLiBGb3IgYGRhbGwtZS0zYCwgb25seVxuICAgKiBgbj0xYCBpcyBzdXBwb3J0ZWQuXG4gICAqL1xuICBuPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHF1YWxpdHkgb2YgdGhlIGltYWdlIHRoYXQgd2lsbCBiZSBnZW5lcmF0ZWQuIGBoZGAgY3JlYXRlcyBpbWFnZXMgd2l0aCBmaW5lclxuICAgKiBkZXRhaWxzIGFuZCBncmVhdGVyIGNvbnNpc3RlbmN5IGFjcm9zcyB0aGUgaW1hZ2UuIFRoaXMgcGFyYW0gaXMgb25seSBzdXBwb3J0ZWRcbiAgICogZm9yIGBkYWxsLWUtM2AuXG4gICAqL1xuICBxdWFsaXR5PzogJ3N0YW5kYXJkJyB8ICdoZCc7XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgaW4gd2hpY2ggdGhlIGdlbmVyYXRlZCBpbWFnZXMgYXJlIHJldHVybmVkLiBNdXN0IGJlIG9uZSBvZiBgdXJsYCBvclxuICAgKiBgYjY0X2pzb25gLiBVUkxzIGFyZSBvbmx5IHZhbGlkIGZvciA2MCBtaW51dGVzIGFmdGVyIHRoZSBpbWFnZSBoYXMgYmVlblxuICAgKiBnZW5lcmF0ZWQuXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiAndXJsJyB8ICdiNjRfanNvbicgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIGltYWdlcy4gTXVzdCBiZSBvbmUgb2YgYDI1NngyNTZgLCBgNTEyeDUxMmAsIG9yXG4gICAqIGAxMDI0eDEwMjRgIGZvciBgZGFsbC1lLTJgLiBNdXN0IGJlIG9uZSBvZiBgMTAyNHgxMDI0YCwgYDE3OTJ4MTAyNGAsIG9yXG4gICAqIGAxMDI0eDE3OTJgIGZvciBgZGFsbC1lLTNgIG1vZGVscy5cbiAgICovXG4gIHNpemU/OiAnMjU2eDI1NicgfCAnNTEyeDUxMicgfCAnMTAyNHgxMDI0JyB8ICcxNzkyeDEwMjQnIHwgJzEwMjR4MTc5MicgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc3R5bGUgb2YgdGhlIGdlbmVyYXRlZCBpbWFnZXMuIE11c3QgYmUgb25lIG9mIGB2aXZpZGAgb3IgYG5hdHVyYWxgLiBWaXZpZFxuICAgKiBjYXVzZXMgdGhlIG1vZGVsIHRvIGxlYW4gdG93YXJkcyBnZW5lcmF0aW5nIGh5cGVyLXJlYWwgYW5kIGRyYW1hdGljIGltYWdlcy5cbiAgICogTmF0dXJhbCBjYXVzZXMgdGhlIG1vZGVsIHRvIHByb2R1Y2UgbW9yZSBuYXR1cmFsLCBsZXNzIGh5cGVyLXJlYWwgbG9va2luZ1xuICAgKiBpbWFnZXMuIFRoaXMgcGFyYW0gaXMgb25seSBzdXBwb3J0ZWQgZm9yIGBkYWxsLWUtM2AuXG4gICAqL1xuICBzdHlsZT86ICd2aXZpZCcgfCAnbmF0dXJhbCcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIHJlcHJlc2VudGluZyB5b3VyIGVuZC11c2VyLCB3aGljaCBjYW4gaGVscCBPcGVuQUkgdG8gbW9uaXRvclxuICAgKiBhbmQgZGV0ZWN0IGFidXNlLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3NhZmV0eS1iZXN0LXByYWN0aWNlcyNlbmQtdXNlci1pZHMpLlxuICAgKi9cbiAgdXNlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEltYWdlcyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBJbWFnZSBhcyBJbWFnZSxcbiAgICB0eXBlIEltYWdlTW9kZWwgYXMgSW1hZ2VNb2RlbCxcbiAgICB0eXBlIEltYWdlc1Jlc3BvbnNlIGFzIEltYWdlc1Jlc3BvbnNlLFxuICAgIHR5cGUgSW1hZ2VDcmVhdGVWYXJpYXRpb25QYXJhbXMgYXMgSW1hZ2VDcmVhdGVWYXJpYXRpb25QYXJhbXMsXG4gICAgdHlwZSBJbWFnZUVkaXRQYXJhbXMgYXMgSW1hZ2VFZGl0UGFyYW1zLFxuICAgIHR5cGUgSW1hZ2VHZW5lcmF0ZVBhcmFtcyBhcyBJbWFnZUdlbmVyYXRlUGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7IFBhZ2UgfSBmcm9tICcuLi9wYWdpbmF0aW9uJztcblxuZXhwb3J0IGNsYXNzIE1vZGVscyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIG1vZGVsIGluc3RhbmNlLCBwcm92aWRpbmcgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1vZGVsIHN1Y2ggYXNcbiAgICogdGhlIG93bmVyIGFuZCBwZXJtaXNzaW9uaW5nLlxuICAgKi9cbiAgcmV0cmlldmUobW9kZWw6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8TW9kZWw+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL21vZGVscy8ke21vZGVsfWAsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RzIHRoZSBjdXJyZW50bHkgYXZhaWxhYmxlIG1vZGVscywgYW5kIHByb3ZpZGVzIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IGVhY2hcbiAgICogb25lIHN1Y2ggYXMgdGhlIG93bmVyIGFuZCBhdmFpbGFiaWxpdHkuXG4gICAqL1xuICBsaXN0KG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5QYWdlUHJvbWlzZTxNb2RlbHNQYWdlLCBNb2RlbD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdCgnL21vZGVscycsIE1vZGVsc1BhZ2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGZpbmUtdHVuZWQgbW9kZWwuIFlvdSBtdXN0IGhhdmUgdGhlIE93bmVyIHJvbGUgaW4geW91ciBvcmdhbml6YXRpb24gdG9cbiAgICogZGVsZXRlIGEgbW9kZWwuXG4gICAqL1xuICBkZWwobW9kZWw6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8TW9kZWxEZWxldGVkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5kZWxldGUoYC9tb2RlbHMvJHttb2RlbH1gLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vdGU6IG5vIHBhZ2luYXRpb24gYWN0dWFsbHkgb2NjdXJzIHlldCwgdGhpcyBpcyBmb3IgZm9yd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIE1vZGVsc1BhZ2UgZXh0ZW5kcyBQYWdlPE1vZGVsPiB7fVxuXG4vKipcbiAqIERlc2NyaWJlcyBhbiBPcGVuQUkgbW9kZWwgb2ZmZXJpbmcgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHRoZSBBUEkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZWwge1xuICAvKipcbiAgICogVGhlIG1vZGVsIGlkZW50aWZpZXIsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIHRoZSBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSB3aGVuIHRoZSBtb2RlbCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgXCJtb2RlbFwiLlxuICAgKi9cbiAgb2JqZWN0OiAnbW9kZWwnO1xuXG4gIC8qKlxuICAgKiBUaGUgb3JnYW5pemF0aW9uIHRoYXQgb3ducyB0aGUgbW9kZWwuXG4gICAqL1xuICBvd25lZF9ieTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVsRGVsZXRlZCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgZGVsZXRlZDogYm9vbGVhbjtcblxuICBvYmplY3Q6IHN0cmluZztcbn1cblxuTW9kZWxzLk1vZGVsc1BhZ2UgPSBNb2RlbHNQYWdlO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgTW9kZWxzIHtcbiAgZXhwb3J0IHsgdHlwZSBNb2RlbCBhcyBNb2RlbCwgdHlwZSBNb2RlbERlbGV0ZWQgYXMgTW9kZWxEZWxldGVkLCBNb2RlbHNQYWdlIGFzIE1vZGVsc1BhZ2UgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vY29yZSc7XG5cbmV4cG9ydCBjbGFzcyBNb2RlcmF0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENsYXNzaWZpZXMgaWYgdGV4dCBhbmQvb3IgaW1hZ2UgaW5wdXRzIGFyZSBwb3RlbnRpYWxseSBoYXJtZnVsLiBMZWFybiBtb3JlIGluXG4gICAqIHRoZSBbbW9kZXJhdGlvbiBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL21vZGVyYXRpb24pLlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIGJvZHk6IE1vZGVyYXRpb25DcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxNb2RlcmF0aW9uQ3JlYXRlUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9tb2RlcmF0aW9ucycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVyYXRpb24ge1xuICAvKipcbiAgICogQSBsaXN0IG9mIHRoZSBjYXRlZ29yaWVzLCBhbmQgd2hldGhlciB0aGV5IGFyZSBmbGFnZ2VkIG9yIG5vdC5cbiAgICovXG4gIGNhdGVnb3JpZXM6IE1vZGVyYXRpb24uQ2F0ZWdvcmllcztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIHRoZSBjYXRlZ29yaWVzIGFsb25nIHdpdGggdGhlIGlucHV0IHR5cGUocykgdGhhdCB0aGUgc2NvcmUgYXBwbGllcyB0by5cbiAgICovXG4gIGNhdGVnb3J5X2FwcGxpZWRfaW5wdXRfdHlwZXM6IE1vZGVyYXRpb24uQ2F0ZWdvcnlBcHBsaWVkSW5wdXRUeXBlcztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIHRoZSBjYXRlZ29yaWVzIGFsb25nIHdpdGggdGhlaXIgc2NvcmVzIGFzIHByZWRpY3RlZCBieSBtb2RlbC5cbiAgICovXG4gIGNhdGVnb3J5X3Njb3JlczogTW9kZXJhdGlvbi5DYXRlZ29yeVNjb3JlcztcblxuICAvKipcbiAgICogV2hldGhlciBhbnkgb2YgdGhlIGJlbG93IGNhdGVnb3JpZXMgYXJlIGZsYWdnZWQuXG4gICAqL1xuICBmbGFnZ2VkOiBib29sZWFuO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIE1vZGVyYXRpb24ge1xuICAvKipcbiAgICogQSBsaXN0IG9mIHRoZSBjYXRlZ29yaWVzLCBhbmQgd2hldGhlciB0aGV5IGFyZSBmbGFnZ2VkIG9yIG5vdC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ2F0ZWdvcmllcyB7XG4gICAgLyoqXG4gICAgICogQ29udGVudCB0aGF0IGV4cHJlc3NlcywgaW5jaXRlcywgb3IgcHJvbW90ZXMgaGFyYXNzaW5nIGxhbmd1YWdlIHRvd2FyZHMgYW55XG4gICAgICogdGFyZ2V0LlxuICAgICAqL1xuICAgIGhhcmFzc21lbnQ6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBIYXJhc3NtZW50IGNvbnRlbnQgdGhhdCBhbHNvIGluY2x1ZGVzIHZpb2xlbmNlIG9yIHNlcmlvdXMgaGFybSB0b3dhcmRzIGFueVxuICAgICAqIHRhcmdldC5cbiAgICAgKi9cbiAgICAnaGFyYXNzbWVudC90aHJlYXRlbmluZyc6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IHRoYXQgZXhwcmVzc2VzLCBpbmNpdGVzLCBvciBwcm9tb3RlcyBoYXRlIGJhc2VkIG9uIHJhY2UsIGdlbmRlcixcbiAgICAgKiBldGhuaWNpdHksIHJlbGlnaW9uLCBuYXRpb25hbGl0eSwgc2V4dWFsIG9yaWVudGF0aW9uLCBkaXNhYmlsaXR5IHN0YXR1cywgb3JcbiAgICAgKiBjYXN0ZS4gSGF0ZWZ1bCBjb250ZW50IGFpbWVkIGF0IG5vbi1wcm90ZWN0ZWQgZ3JvdXBzIChlLmcuLCBjaGVzcyBwbGF5ZXJzKSBpc1xuICAgICAqIGhhcmFzc21lbnQuXG4gICAgICovXG4gICAgaGF0ZTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEhhdGVmdWwgY29udGVudCB0aGF0IGFsc28gaW5jbHVkZXMgdmlvbGVuY2Ugb3Igc2VyaW91cyBoYXJtIHRvd2FyZHMgdGhlIHRhcmdldGVkXG4gICAgICogZ3JvdXAgYmFzZWQgb24gcmFjZSwgZ2VuZGVyLCBldGhuaWNpdHksIHJlbGlnaW9uLCBuYXRpb25hbGl0eSwgc2V4dWFsXG4gICAgICogb3JpZW50YXRpb24sIGRpc2FiaWxpdHkgc3RhdHVzLCBvciBjYXN0ZS5cbiAgICAgKi9cbiAgICAnaGF0ZS90aHJlYXRlbmluZyc6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IHRoYXQgaW5jbHVkZXMgaW5zdHJ1Y3Rpb25zIG9yIGFkdmljZSB0aGF0IGZhY2lsaXRhdGUgdGhlIHBsYW5uaW5nIG9yXG4gICAgICogZXhlY3V0aW9uIG9mIHdyb25nZG9pbmcsIG9yIHRoYXQgZ2l2ZXMgYWR2aWNlIG9yIGluc3RydWN0aW9uIG9uIGhvdyB0byBjb21taXRcbiAgICAgKiBpbGxpY2l0IGFjdHMuIEZvciBleGFtcGxlLCBcImhvdyB0byBzaG9wbGlmdFwiIHdvdWxkIGZpdCB0aGlzIGNhdGVnb3J5LlxuICAgICAqL1xuICAgIGlsbGljaXQ6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IHRoYXQgaW5jbHVkZXMgaW5zdHJ1Y3Rpb25zIG9yIGFkdmljZSB0aGF0IGZhY2lsaXRhdGUgdGhlIHBsYW5uaW5nIG9yXG4gICAgICogZXhlY3V0aW9uIG9mIHdyb25nZG9pbmcgdGhhdCBhbHNvIGluY2x1ZGVzIHZpb2xlbmNlLCBvciB0aGF0IGdpdmVzIGFkdmljZSBvclxuICAgICAqIGluc3RydWN0aW9uIG9uIHRoZSBwcm9jdXJlbWVudCBvZiBhbnkgd2VhcG9uLlxuICAgICAqL1xuICAgICdpbGxpY2l0L3Zpb2xlbnQnOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB0aGF0IHByb21vdGVzLCBlbmNvdXJhZ2VzLCBvciBkZXBpY3RzIGFjdHMgb2Ygc2VsZi1oYXJtLCBzdWNoIGFzXG4gICAgICogc3VpY2lkZSwgY3V0dGluZywgYW5kIGVhdGluZyBkaXNvcmRlcnMuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybSc6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IHRoYXQgZW5jb3VyYWdlcyBwZXJmb3JtaW5nIGFjdHMgb2Ygc2VsZi1oYXJtLCBzdWNoIGFzIHN1aWNpZGUsIGN1dHRpbmcsXG4gICAgICogYW5kIGVhdGluZyBkaXNvcmRlcnMsIG9yIHRoYXQgZ2l2ZXMgaW5zdHJ1Y3Rpb25zIG9yIGFkdmljZSBvbiBob3cgdG8gY29tbWl0IHN1Y2hcbiAgICAgKiBhY3RzLlxuICAgICAqL1xuICAgICdzZWxmLWhhcm0vaW5zdHJ1Y3Rpb25zJzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgd2hlcmUgdGhlIHNwZWFrZXIgZXhwcmVzc2VzIHRoYXQgdGhleSBhcmUgZW5nYWdpbmcgb3IgaW50ZW5kIHRvIGVuZ2FnZVxuICAgICAqIGluIGFjdHMgb2Ygc2VsZi1oYXJtLCBzdWNoIGFzIHN1aWNpZGUsIGN1dHRpbmcsIGFuZCBlYXRpbmcgZGlzb3JkZXJzLlxuICAgICAqL1xuICAgICdzZWxmLWhhcm0vaW50ZW50JzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgbWVhbnQgdG8gYXJvdXNlIHNleHVhbCBleGNpdGVtZW50LCBzdWNoIGFzIHRoZSBkZXNjcmlwdGlvbiBvZiBzZXh1YWxcbiAgICAgKiBhY3Rpdml0eSwgb3IgdGhhdCBwcm9tb3RlcyBzZXh1YWwgc2VydmljZXMgKGV4Y2x1ZGluZyBzZXggZWR1Y2F0aW9uIGFuZFxuICAgICAqIHdlbGxuZXNzKS5cbiAgICAgKi9cbiAgICBzZXh1YWw6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBTZXh1YWwgY29udGVudCB0aGF0IGluY2x1ZGVzIGFuIGluZGl2aWR1YWwgd2hvIGlzIHVuZGVyIDE4IHllYXJzIG9sZC5cbiAgICAgKi9cbiAgICAnc2V4dWFsL21pbm9ycyc6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IHRoYXQgZGVwaWN0cyBkZWF0aCwgdmlvbGVuY2UsIG9yIHBoeXNpY2FsIGluanVyeS5cbiAgICAgKi9cbiAgICB2aW9sZW5jZTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgdGhhdCBkZXBpY3RzIGRlYXRoLCB2aW9sZW5jZSwgb3IgcGh5c2ljYWwgaW5qdXJ5IGluIGdyYXBoaWMgZGV0YWlsLlxuICAgICAqL1xuICAgICd2aW9sZW5jZS9ncmFwaGljJzogYm9vbGVhbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdGhlIGNhdGVnb3JpZXMgYWxvbmcgd2l0aCB0aGUgaW5wdXQgdHlwZShzKSB0aGF0IHRoZSBzY29yZSBhcHBsaWVzIHRvLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDYXRlZ29yeUFwcGxpZWRJbnB1dFR5cGVzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ2hhcmFzc21lbnQnLlxuICAgICAqL1xuICAgIGhhcmFzc21lbnQ6IEFycmF5PCd0ZXh0Jz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ2hhcmFzc21lbnQvdGhyZWF0ZW5pbmcnLlxuICAgICAqL1xuICAgICdoYXJhc3NtZW50L3RocmVhdGVuaW5nJzogQXJyYXk8J3RleHQnPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAnaGF0ZScuXG4gICAgICovXG4gICAgaGF0ZTogQXJyYXk8J3RleHQnPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAnaGF0ZS90aHJlYXRlbmluZycuXG4gICAgICovXG4gICAgJ2hhdGUvdGhyZWF0ZW5pbmcnOiBBcnJheTwndGV4dCc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICdpbGxpY2l0Jy5cbiAgICAgKi9cbiAgICBpbGxpY2l0OiBBcnJheTwndGV4dCc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICdpbGxpY2l0L3Zpb2xlbnQnLlxuICAgICAqL1xuICAgICdpbGxpY2l0L3Zpb2xlbnQnOiBBcnJheTwndGV4dCc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICdzZWxmLWhhcm0nLlxuICAgICAqL1xuICAgICdzZWxmLWhhcm0nOiBBcnJheTwndGV4dCcgfCAnaW1hZ2UnPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAnc2VsZi1oYXJtL2luc3RydWN0aW9ucycuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybS9pbnN0cnVjdGlvbnMnOiBBcnJheTwndGV4dCcgfCAnaW1hZ2UnPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAnc2VsZi1oYXJtL2ludGVudCcuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybS9pbnRlbnQnOiBBcnJheTwndGV4dCcgfCAnaW1hZ2UnPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAnc2V4dWFsJy5cbiAgICAgKi9cbiAgICBzZXh1YWw6IEFycmF5PCd0ZXh0JyB8ICdpbWFnZSc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICdzZXh1YWwvbWlub3JzJy5cbiAgICAgKi9cbiAgICAnc2V4dWFsL21pbm9ycyc6IEFycmF5PCd0ZXh0Jz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ3Zpb2xlbmNlJy5cbiAgICAgKi9cbiAgICB2aW9sZW5jZTogQXJyYXk8J3RleHQnIHwgJ2ltYWdlJz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ3Zpb2xlbmNlL2dyYXBoaWMnLlxuICAgICAqL1xuICAgICd2aW9sZW5jZS9ncmFwaGljJzogQXJyYXk8J3RleHQnIHwgJ2ltYWdlJz47XG4gIH1cblxuICAvKipcbiAgICogQSBsaXN0IG9mIHRoZSBjYXRlZ29yaWVzIGFsb25nIHdpdGggdGhlaXIgc2NvcmVzIGFzIHByZWRpY3RlZCBieSBtb2RlbC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ2F0ZWdvcnlTY29yZXMge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdoYXJhc3NtZW50Jy5cbiAgICAgKi9cbiAgICBoYXJhc3NtZW50OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnaGFyYXNzbWVudC90aHJlYXRlbmluZycuXG4gICAgICovXG4gICAgJ2hhcmFzc21lbnQvdGhyZWF0ZW5pbmcnOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnaGF0ZScuXG4gICAgICovXG4gICAgaGF0ZTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ2hhdGUvdGhyZWF0ZW5pbmcnLlxuICAgICAqL1xuICAgICdoYXRlL3RocmVhdGVuaW5nJzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ2lsbGljaXQnLlxuICAgICAqL1xuICAgIGlsbGljaXQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdpbGxpY2l0L3Zpb2xlbnQnLlxuICAgICAqL1xuICAgICdpbGxpY2l0L3Zpb2xlbnQnOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnc2VsZi1oYXJtJy5cbiAgICAgKi9cbiAgICAnc2VsZi1oYXJtJzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ3NlbGYtaGFybS9pbnN0cnVjdGlvbnMnLlxuICAgICAqL1xuICAgICdzZWxmLWhhcm0vaW5zdHJ1Y3Rpb25zJzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ3NlbGYtaGFybS9pbnRlbnQnLlxuICAgICAqL1xuICAgICdzZWxmLWhhcm0vaW50ZW50JzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ3NleHVhbCcuXG4gICAgICovXG4gICAgc2V4dWFsOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnc2V4dWFsL21pbm9ycycuXG4gICAgICovXG4gICAgJ3NleHVhbC9taW5vcnMnOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAndmlvbGVuY2UnLlxuICAgICAqL1xuICAgIHZpb2xlbmNlOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAndmlvbGVuY2UvZ3JhcGhpYycuXG4gICAgICovXG4gICAgJ3Zpb2xlbmNlL2dyYXBoaWMnOiBudW1iZXI7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBvYmplY3QgZGVzY3JpYmluZyBhbiBpbWFnZSB0byBjbGFzc2lmeS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNb2RlcmF0aW9uSW1hZ2VVUkxJbnB1dCB7XG4gIC8qKlxuICAgKiBDb250YWlucyBlaXRoZXIgYW4gaW1hZ2UgVVJMIG9yIGEgZGF0YSBVUkwgZm9yIGEgYmFzZTY0IGVuY29kZWQgaW1hZ2UuXG4gICAqL1xuICBpbWFnZV91cmw6IE1vZGVyYXRpb25JbWFnZVVSTElucHV0LkltYWdlVVJMO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYGltYWdlX3VybGAuXG4gICAqL1xuICB0eXBlOiAnaW1hZ2VfdXJsJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBNb2RlcmF0aW9uSW1hZ2VVUkxJbnB1dCB7XG4gIC8qKlxuICAgKiBDb250YWlucyBlaXRoZXIgYW4gaW1hZ2UgVVJMIG9yIGEgZGF0YSBVUkwgZm9yIGEgYmFzZTY0IGVuY29kZWQgaW1hZ2UuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEltYWdlVVJMIHtcbiAgICAvKipcbiAgICAgKiBFaXRoZXIgYSBVUkwgb2YgdGhlIGltYWdlIG9yIHRoZSBiYXNlNjQgZW5jb2RlZCBpbWFnZSBkYXRhLlxuICAgICAqL1xuICAgIHVybDogc3RyaW5nO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIE1vZGVyYXRpb25Nb2RlbCA9XG4gIHwgJ29tbmktbW9kZXJhdGlvbi1sYXRlc3QnXG4gIHwgJ29tbmktbW9kZXJhdGlvbi0yMDI0LTA5LTI2J1xuICB8ICd0ZXh0LW1vZGVyYXRpb24tbGF0ZXN0J1xuICB8ICd0ZXh0LW1vZGVyYXRpb24tc3RhYmxlJztcblxuLyoqXG4gKiBBbiBvYmplY3QgZGVzY3JpYmluZyBhbiBpbWFnZSB0byBjbGFzc2lmeS5cbiAqL1xuZXhwb3J0IHR5cGUgTW9kZXJhdGlvbk11bHRpTW9kYWxJbnB1dCA9IE1vZGVyYXRpb25JbWFnZVVSTElucHV0IHwgTW9kZXJhdGlvblRleHRJbnB1dDtcblxuLyoqXG4gKiBBbiBvYmplY3QgZGVzY3JpYmluZyB0ZXh0IHRvIGNsYXNzaWZ5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVyYXRpb25UZXh0SW5wdXQge1xuICAvKipcbiAgICogQSBzdHJpbmcgb2YgdGV4dCB0byBjbGFzc2lmeS5cbiAgICovXG4gIHRleHQ6IHN0cmluZztcblxuICAvKipcbiAgICogQWx3YXlzIGB0ZXh0YC5cbiAgICovXG4gIHR5cGU6ICd0ZXh0Jztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGlmIGEgZ2l2ZW4gdGV4dCBpbnB1dCBpcyBwb3RlbnRpYWxseSBoYXJtZnVsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVyYXRpb25DcmVhdGVSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBtb2RlcmF0aW9uIHJlcXVlc3QuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdXNlZCB0byBnZW5lcmF0ZSB0aGUgbW9kZXJhdGlvbiByZXN1bHRzLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIG1vZGVyYXRpb24gb2JqZWN0cy5cbiAgICovXG4gIHJlc3VsdHM6IEFycmF5PE1vZGVyYXRpb24+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVyYXRpb25DcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogSW5wdXQgKG9yIGlucHV0cykgdG8gY2xhc3NpZnkuIENhbiBiZSBhIHNpbmdsZSBzdHJpbmcsIGFuIGFycmF5IG9mIHN0cmluZ3MsIG9yXG4gICAqIGFuIGFycmF5IG9mIG11bHRpLW1vZGFsIGlucHV0IG9iamVjdHMgc2ltaWxhciB0byBvdGhlciBtb2RlbHMuXG4gICAqL1xuICBpbnB1dDogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPiB8IEFycmF5PE1vZGVyYXRpb25NdWx0aU1vZGFsSW5wdXQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBtb2RlcmF0aW9uIG1vZGVsIHlvdSB3b3VsZCBsaWtlIHRvIHVzZS4gTGVhcm4gbW9yZSBpblxuICAgKiBbdGhlIG1vZGVyYXRpb24gZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9tb2RlcmF0aW9uKSwgYW5kXG4gICAqIGxlYXJuIGFib3V0IGF2YWlsYWJsZSBtb2RlbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNtb2RlcmF0aW9uKS5cbiAgICovXG4gIG1vZGVsPzogKHN0cmluZyAmIHt9KSB8IE1vZGVyYXRpb25Nb2RlbDtcbn1cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIE1vZGVyYXRpb25zIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIE1vZGVyYXRpb24gYXMgTW9kZXJhdGlvbixcbiAgICB0eXBlIE1vZGVyYXRpb25JbWFnZVVSTElucHV0IGFzIE1vZGVyYXRpb25JbWFnZVVSTElucHV0LFxuICAgIHR5cGUgTW9kZXJhdGlvbk1vZGVsIGFzIE1vZGVyYXRpb25Nb2RlbCxcbiAgICB0eXBlIE1vZGVyYXRpb25NdWx0aU1vZGFsSW5wdXQgYXMgTW9kZXJhdGlvbk11bHRpTW9kYWxJbnB1dCxcbiAgICB0eXBlIE1vZGVyYXRpb25UZXh0SW5wdXQgYXMgTW9kZXJhdGlvblRleHRJbnB1dCxcbiAgICB0eXBlIE1vZGVyYXRpb25DcmVhdGVSZXNwb25zZSBhcyBNb2RlcmF0aW9uQ3JlYXRlUmVzcG9uc2UsXG4gICAgdHlwZSBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zIGFzIE1vZGVyYXRpb25DcmVhdGVQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uL2NvcmUnO1xuXG5leHBvcnQgY2xhc3MgUGFydHMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBBZGRzIGFcbiAgICogW1BhcnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdXBsb2Fkcy9wYXJ0LW9iamVjdCkgdG8gYW5cbiAgICogW1VwbG9hZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS91cGxvYWRzL29iamVjdCkgb2JqZWN0LlxuICAgKiBBIFBhcnQgcmVwcmVzZW50cyBhIGNodW5rIG9mIGJ5dGVzIGZyb20gdGhlIGZpbGUgeW91IGFyZSB0cnlpbmcgdG8gdXBsb2FkLlxuICAgKlxuICAgKiBFYWNoIFBhcnQgY2FuIGJlIGF0IG1vc3QgNjQgTUIsIGFuZCB5b3UgY2FuIGFkZCBQYXJ0cyB1bnRpbCB5b3UgaGl0IHRoZSBVcGxvYWRcbiAgICogbWF4aW11bSBvZiA4IEdCLlxuICAgKlxuICAgKiBJdCBpcyBwb3NzaWJsZSB0byBhZGQgbXVsdGlwbGUgUGFydHMgaW4gcGFyYWxsZWwuIFlvdSBjYW4gZGVjaWRlIHRoZSBpbnRlbmRlZFxuICAgKiBvcmRlciBvZiB0aGUgUGFydHMgd2hlbiB5b3VcbiAgICogW2NvbXBsZXRlIHRoZSBVcGxvYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdXBsb2Fkcy9jb21wbGV0ZSkuXG4gICAqL1xuICBjcmVhdGUoXG4gICAgdXBsb2FkSWQ6IHN0cmluZyxcbiAgICBib2R5OiBQYXJ0Q3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VXBsb2FkUGFydD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChcbiAgICAgIGAvdXBsb2Fkcy8ke3VwbG9hZElkfS9wYXJ0c2AsXG4gICAgICBDb3JlLm11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyh7IGJvZHksIC4uLm9wdGlvbnMgfSksXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSB1cGxvYWQgUGFydCByZXByZXNlbnRzIGEgY2h1bmsgb2YgYnl0ZXMgd2UgY2FuIGFkZCB0byBhbiBVcGxvYWQgb2JqZWN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVwbG9hZFBhcnQge1xuICAvKipcbiAgICogVGhlIHVwbG9hZCBQYXJ0IHVuaXF1ZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgUGFydCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYHVwbG9hZC5wYXJ0YC5cbiAgICovXG4gIG9iamVjdDogJ3VwbG9hZC5wYXJ0JztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBVcGxvYWQgb2JqZWN0IHRoYXQgdGhpcyBQYXJ0IHdhcyBhZGRlZCB0by5cbiAgICovXG4gIHVwbG9hZF9pZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnRDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIGNodW5rIG9mIGJ5dGVzIGZvciB0aGlzIFBhcnQuXG4gICAqL1xuICBkYXRhOiBDb3JlLlVwbG9hZGFibGU7XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBQYXJ0cyB7XG4gIGV4cG9ydCB7IHR5cGUgVXBsb2FkUGFydCBhcyBVcGxvYWRQYXJ0LCB0eXBlIFBhcnRDcmVhdGVQYXJhbXMgYXMgUGFydENyZWF0ZVBhcmFtcyB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIEZpbGVzQVBJIGZyb20gJy4uL2ZpbGVzJztcbmltcG9ydCAqIGFzIFBhcnRzQVBJIGZyb20gJy4vcGFydHMnO1xuaW1wb3J0IHsgUGFydENyZWF0ZVBhcmFtcywgUGFydHMsIFVwbG9hZFBhcnQgfSBmcm9tICcuL3BhcnRzJztcblxuZXhwb3J0IGNsYXNzIFVwbG9hZHMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIHBhcnRzOiBQYXJ0c0FQSS5QYXJ0cyA9IG5ldyBQYXJ0c0FQSS5QYXJ0cyh0aGlzLl9jbGllbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGludGVybWVkaWF0ZVxuICAgKiBbVXBsb2FkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3VwbG9hZHMvb2JqZWN0KSBvYmplY3RcbiAgICogdGhhdCB5b3UgY2FuIGFkZFxuICAgKiBbUGFydHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdXBsb2Fkcy9wYXJ0LW9iamVjdCkgdG8uXG4gICAqIEN1cnJlbnRseSwgYW4gVXBsb2FkIGNhbiBhY2NlcHQgYXQgbW9zdCA4IEdCIGluIHRvdGFsIGFuZCBleHBpcmVzIGFmdGVyIGFuIGhvdXJcbiAgICogYWZ0ZXIgeW91IGNyZWF0ZSBpdC5cbiAgICpcbiAgICogT25jZSB5b3UgY29tcGxldGUgdGhlIFVwbG9hZCwgd2Ugd2lsbCBjcmVhdGUgYVxuICAgKiBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9vYmplY3QpIG9iamVjdCB0aGF0XG4gICAqIGNvbnRhaW5zIGFsbCB0aGUgcGFydHMgeW91IHVwbG9hZGVkLiBUaGlzIEZpbGUgaXMgdXNhYmxlIGluIHRoZSByZXN0IG9mIG91clxuICAgKiBwbGF0Zm9ybSBhcyBhIHJlZ3VsYXIgRmlsZSBvYmplY3QuXG4gICAqXG4gICAqIEZvciBjZXJ0YWluIGBwdXJwb3NlYHMsIHRoZSBjb3JyZWN0IGBtaW1lX3R5cGVgIG11c3QgYmUgc3BlY2lmaWVkLiBQbGVhc2UgcmVmZXJcbiAgICogdG8gZG9jdW1lbnRhdGlvbiBmb3IgdGhlIHN1cHBvcnRlZCBNSU1FIHR5cGVzIGZvciB5b3VyIHVzZSBjYXNlOlxuICAgKlxuICAgKiAtIFtBc3Npc3RhbnRzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL3Rvb2xzL2ZpbGUtc2VhcmNoI3N1cHBvcnRlZC1maWxlcylcbiAgICpcbiAgICogRm9yIGd1aWRhbmNlIG9uIHRoZSBwcm9wZXIgZmlsZW5hbWUgZXh0ZW5zaW9ucyBmb3IgZWFjaCBwdXJwb3NlLCBwbGVhc2UgZm9sbG93XG4gICAqIHRoZSBkb2N1bWVudGF0aW9uIG9uXG4gICAqIFtjcmVhdGluZyBhIEZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMvY3JlYXRlKS5cbiAgICovXG4gIGNyZWF0ZShib2R5OiBVcGxvYWRDcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFVwbG9hZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL3VwbG9hZHMnLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyB0aGUgVXBsb2FkLiBObyBQYXJ0cyBtYXkgYmUgYWRkZWQgYWZ0ZXIgYW4gVXBsb2FkIGlzIGNhbmNlbGxlZC5cbiAgICovXG4gIGNhbmNlbCh1cGxvYWRJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxVcGxvYWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC91cGxvYWRzLyR7dXBsb2FkSWR9L2NhbmNlbGAsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBsZXRlcyB0aGVcbiAgICogW1VwbG9hZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS91cGxvYWRzL29iamVjdCkuXG4gICAqXG4gICAqIFdpdGhpbiB0aGUgcmV0dXJuZWQgVXBsb2FkIG9iamVjdCwgdGhlcmUgaXMgYSBuZXN0ZWRcbiAgICogW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMvb2JqZWN0KSBvYmplY3QgdGhhdFxuICAgKiBpcyByZWFkeSB0byB1c2UgaW4gdGhlIHJlc3Qgb2YgdGhlIHBsYXRmb3JtLlxuICAgKlxuICAgKiBZb3UgY2FuIHNwZWNpZnkgdGhlIG9yZGVyIG9mIHRoZSBQYXJ0cyBieSBwYXNzaW5nIGluIGFuIG9yZGVyZWQgbGlzdCBvZiB0aGUgUGFydFxuICAgKiBJRHMuXG4gICAqXG4gICAqIFRoZSBudW1iZXIgb2YgYnl0ZXMgdXBsb2FkZWQgdXBvbiBjb21wbGV0aW9uIG11c3QgbWF0Y2ggdGhlIG51bWJlciBvZiBieXRlc1xuICAgKiBpbml0aWFsbHkgc3BlY2lmaWVkIHdoZW4gY3JlYXRpbmcgdGhlIFVwbG9hZCBvYmplY3QuIE5vIFBhcnRzIG1heSBiZSBhZGRlZCBhZnRlclxuICAgKiBhbiBVcGxvYWQgaXMgY29tcGxldGVkLlxuICAgKi9cbiAgY29tcGxldGUoXG4gICAgdXBsb2FkSWQ6IHN0cmluZyxcbiAgICBib2R5OiBVcGxvYWRDb21wbGV0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFVwbG9hZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3VwbG9hZHMvJHt1cGxvYWRJZH0vY29tcGxldGVgLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgVXBsb2FkIG9iamVjdCBjYW4gYWNjZXB0IGJ5dGUgY2h1bmtzIGluIHRoZSBmb3JtIG9mIFBhcnRzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVwbG9hZCB7XG4gIC8qKlxuICAgKiBUaGUgVXBsb2FkIHVuaXF1ZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGludGVuZGVkIG51bWJlciBvZiBieXRlcyB0byBiZSB1cGxvYWRlZC5cbiAgICovXG4gIGJ5dGVzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIFVwbG9hZCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgVXBsb2FkIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgZXhwaXJlc19hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZC5cbiAgICovXG4gIGZpbGVuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwidXBsb2FkXCIuXG4gICAqL1xuICBvYmplY3Q6ICd1cGxvYWQnO1xuXG4gIC8qKlxuICAgKiBUaGUgaW50ZW5kZWQgcHVycG9zZSBvZiB0aGUgZmlsZS5cbiAgICogW1BsZWFzZSByZWZlciBoZXJlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL29iamVjdCNmaWxlcy9vYmplY3QtcHVycG9zZSlcbiAgICogZm9yIGFjY2VwdGFibGUgdmFsdWVzLlxuICAgKi9cbiAgcHVycG9zZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhdHVzIG9mIHRoZSBVcGxvYWQuXG4gICAqL1xuICBzdGF0dXM6ICdwZW5kaW5nJyB8ICdjb21wbGV0ZWQnIHwgJ2NhbmNlbGxlZCcgfCAnZXhwaXJlZCc7XG5cbiAgLyoqXG4gICAqIFRoZSByZWFkeSBGaWxlIG9iamVjdCBhZnRlciB0aGUgVXBsb2FkIGlzIGNvbXBsZXRlZC5cbiAgICovXG4gIGZpbGU/OiBGaWxlc0FQSS5GaWxlT2JqZWN0IHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVcGxvYWRDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGUgZmlsZSB5b3UgYXJlIHVwbG9hZGluZy5cbiAgICovXG4gIGJ5dGVzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIHVwbG9hZC5cbiAgICovXG4gIGZpbGVuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBNSU1FIHR5cGUgb2YgdGhlIGZpbGUuXG4gICAqXG4gICAqIFRoaXMgbXVzdCBmYWxsIHdpdGhpbiB0aGUgc3VwcG9ydGVkIE1JTUUgdHlwZXMgZm9yIHlvdXIgZmlsZSBwdXJwb3NlLiBTZWUgdGhlXG4gICAqIHN1cHBvcnRlZCBNSU1FIHR5cGVzIGZvciBhc3Npc3RhbnRzIGFuZCB2aXNpb24uXG4gICAqL1xuICBtaW1lX3R5cGU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGludGVuZGVkIHB1cnBvc2Ugb2YgdGhlIHVwbG9hZGVkIGZpbGUuXG4gICAqXG4gICAqIFNlZSB0aGVcbiAgICogW2RvY3VtZW50YXRpb24gb24gRmlsZSBwdXJwb3Nlc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9jcmVhdGUjZmlsZXMtY3JlYXRlLXB1cnBvc2UpLlxuICAgKi9cbiAgcHVycG9zZTogRmlsZXNBUEkuRmlsZVB1cnBvc2U7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBsb2FkQ29tcGxldGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIG9yZGVyZWQgbGlzdCBvZiBQYXJ0IElEcy5cbiAgICovXG4gIHBhcnRfaWRzOiBBcnJheTxzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBUaGUgb3B0aW9uYWwgbWQ1IGNoZWNrc3VtIGZvciB0aGUgZmlsZSBjb250ZW50cyB0byB2ZXJpZnkgaWYgdGhlIGJ5dGVzIHVwbG9hZGVkXG4gICAqIG1hdGNoZXMgd2hhdCB5b3UgZXhwZWN0LlxuICAgKi9cbiAgbWQ1Pzogc3RyaW5nO1xufVxuXG5VcGxvYWRzLlBhcnRzID0gUGFydHM7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBVcGxvYWRzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIFVwbG9hZCBhcyBVcGxvYWQsXG4gICAgdHlwZSBVcGxvYWRDcmVhdGVQYXJhbXMgYXMgVXBsb2FkQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgVXBsb2FkQ29tcGxldGVQYXJhbXMgYXMgVXBsb2FkQ29tcGxldGVQYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHsgUGFydHMgYXMgUGFydHMsIHR5cGUgVXBsb2FkUGFydCBhcyBVcGxvYWRQYXJ0LCB0eXBlIFBhcnRDcmVhdGVQYXJhbXMgYXMgUGFydENyZWF0ZVBhcmFtcyB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IHR5cGUgQWdlbnQsIHR5cGUgUmVxdWVzdEluaXQgfSBmcm9tICcuL19zaGltcy9pbmRleCc7XG5pbXBvcnQgKiBhcyBxcyBmcm9tICcuL2ludGVybmFsL3FzJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi9jb3JlJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL2Vycm9yJztcbmltcG9ydCAqIGFzIFBhZ2luYXRpb24gZnJvbSAnLi9wYWdpbmF0aW9uJztcbmltcG9ydCB7IHR5cGUgQ3Vyc29yUGFnZVBhcmFtcywgQ3Vyc29yUGFnZVJlc3BvbnNlLCBQYWdlUmVzcG9uc2UgfSBmcm9tICcuL3BhZ2luYXRpb24nO1xuaW1wb3J0ICogYXMgVXBsb2FkcyBmcm9tICcuL3VwbG9hZHMnO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vcmVzb3VyY2VzL2luZGV4JztcbmltcG9ydCB7XG4gIEJhdGNoLFxuICBCYXRjaENyZWF0ZVBhcmFtcyxcbiAgQmF0Y2hFcnJvcixcbiAgQmF0Y2hMaXN0UGFyYW1zLFxuICBCYXRjaFJlcXVlc3RDb3VudHMsXG4gIEJhdGNoZXMsXG4gIEJhdGNoZXNQYWdlLFxufSBmcm9tICcuL3Jlc291cmNlcy9iYXRjaGVzJztcbmltcG9ydCB7XG4gIENvbXBsZXRpb24sXG4gIENvbXBsZXRpb25DaG9pY2UsXG4gIENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gIENvbXBsZXRpb25Vc2FnZSxcbiAgQ29tcGxldGlvbnMsXG59IGZyb20gJy4vcmVzb3VyY2VzL2NvbXBsZXRpb25zJztcbmltcG9ydCB7XG4gIENyZWF0ZUVtYmVkZGluZ1Jlc3BvbnNlLFxuICBFbWJlZGRpbmcsXG4gIEVtYmVkZGluZ0NyZWF0ZVBhcmFtcyxcbiAgRW1iZWRkaW5nTW9kZWwsXG4gIEVtYmVkZGluZ3MsXG59IGZyb20gJy4vcmVzb3VyY2VzL2VtYmVkZGluZ3MnO1xuaW1wb3J0IHtcbiAgRmlsZUNvbnRlbnQsXG4gIEZpbGVDcmVhdGVQYXJhbXMsXG4gIEZpbGVEZWxldGVkLFxuICBGaWxlTGlzdFBhcmFtcyxcbiAgRmlsZU9iamVjdCxcbiAgRmlsZU9iamVjdHNQYWdlLFxuICBGaWxlUHVycG9zZSxcbiAgRmlsZXMsXG59IGZyb20gJy4vcmVzb3VyY2VzL2ZpbGVzJztcbmltcG9ydCB7XG4gIEltYWdlLFxuICBJbWFnZUNyZWF0ZVZhcmlhdGlvblBhcmFtcyxcbiAgSW1hZ2VFZGl0UGFyYW1zLFxuICBJbWFnZUdlbmVyYXRlUGFyYW1zLFxuICBJbWFnZU1vZGVsLFxuICBJbWFnZXMsXG4gIEltYWdlc1Jlc3BvbnNlLFxufSBmcm9tICcuL3Jlc291cmNlcy9pbWFnZXMnO1xuaW1wb3J0IHsgTW9kZWwsIE1vZGVsRGVsZXRlZCwgTW9kZWxzLCBNb2RlbHNQYWdlIH0gZnJvbSAnLi9yZXNvdXJjZXMvbW9kZWxzJztcbmltcG9ydCB7XG4gIE1vZGVyYXRpb24sXG4gIE1vZGVyYXRpb25DcmVhdGVQYXJhbXMsXG4gIE1vZGVyYXRpb25DcmVhdGVSZXNwb25zZSxcbiAgTW9kZXJhdGlvbkltYWdlVVJMSW5wdXQsXG4gIE1vZGVyYXRpb25Nb2RlbCxcbiAgTW9kZXJhdGlvbk11bHRpTW9kYWxJbnB1dCxcbiAgTW9kZXJhdGlvblRleHRJbnB1dCxcbiAgTW9kZXJhdGlvbnMsXG59IGZyb20gJy4vcmVzb3VyY2VzL21vZGVyYXRpb25zJztcbmltcG9ydCB7IEF1ZGlvLCBBdWRpb01vZGVsLCBBdWRpb1Jlc3BvbnNlRm9ybWF0IH0gZnJvbSAnLi9yZXNvdXJjZXMvYXVkaW8vYXVkaW8nO1xuaW1wb3J0IHsgQmV0YSB9IGZyb20gJy4vcmVzb3VyY2VzL2JldGEvYmV0YSc7XG5pbXBvcnQgeyBDaGF0LCBDaGF0TW9kZWwgfSBmcm9tICcuL3Jlc291cmNlcy9jaGF0L2NoYXQnO1xuaW1wb3J0IHtcbiAgQ2hhdENvbXBsZXRpb24sXG4gIENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtLFxuICBDaGF0Q29tcGxldGlvbkF1ZGlvLFxuICBDaGF0Q29tcGxldGlvbkF1ZGlvUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uQ2h1bmssXG4gIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnQsXG4gIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbWFnZSxcbiAgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydElucHV0QXVkaW8sXG4gIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRSZWZ1c2FsLFxuICBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dCxcbiAgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgQ2hhdENvbXBsZXRpb25EZXZlbG9wZXJNZXNzYWdlUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uRnVuY3Rpb25DYWxsT3B0aW9uLFxuICBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uTWVzc2FnZVBhcmFtLFxuICBDaGF0Q29tcGxldGlvbk1lc3NhZ2UsXG4gIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtLFxuICBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCxcbiAgQ2hhdENvbXBsZXRpb25Nb2RhbGl0eSxcbiAgQ2hhdENvbXBsZXRpb25OYW1lZFRvb2xDaG9pY2UsXG4gIENoYXRDb21wbGV0aW9uUHJlZGljdGlvbkNvbnRlbnQsXG4gIENoYXRDb21wbGV0aW9uUmVhc29uaW5nRWZmb3J0LFxuICBDaGF0Q29tcGxldGlvblJvbGUsXG4gIENoYXRDb21wbGV0aW9uU3RyZWFtT3B0aW9ucyxcbiAgQ2hhdENvbXBsZXRpb25TeXN0ZW1NZXNzYWdlUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iLFxuICBDaGF0Q29tcGxldGlvblRvb2wsXG4gIENoYXRDb21wbGV0aW9uVG9vbENob2ljZU9wdGlvbixcbiAgQ2hhdENvbXBsZXRpb25Ub29sTWVzc2FnZVBhcmFtLFxuICBDaGF0Q29tcGxldGlvblVzZXJNZXNzYWdlUGFyYW0sXG59IGZyb20gJy4vcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMnO1xuaW1wb3J0IHsgRmluZVR1bmluZyB9IGZyb20gJy4vcmVzb3VyY2VzL2ZpbmUtdHVuaW5nL2ZpbmUtdHVuaW5nJztcbmltcG9ydCB7XG4gIFVwbG9hZCxcbiAgVXBsb2FkQ29tcGxldGVQYXJhbXMsXG4gIFVwbG9hZENyZWF0ZVBhcmFtcyxcbiAgVXBsb2FkcyBhcyBVcGxvYWRzQVBJVXBsb2Fkcyxcbn0gZnJvbSAnLi9yZXNvdXJjZXMvdXBsb2Fkcy91cGxvYWRzJztcblxuZXhwb3J0IGludGVyZmFjZSBDbGllbnRPcHRpb25zIHtcbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIHByb2Nlc3MuZW52WydPUEVOQUlfQVBJX0tFWSddLlxuICAgKi9cbiAgYXBpS2V5Pzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBwcm9jZXNzLmVudlsnT1BFTkFJX09SR19JRCddLlxuICAgKi9cbiAgb3JnYW5pemF0aW9uPzogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogRGVmYXVsdHMgdG8gcHJvY2Vzcy5lbnZbJ09QRU5BSV9QUk9KRUNUX0lEJ10uXG4gICAqL1xuICBwcm9qZWN0Pzogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmFzZSBVUkwgZm9yIHRoZSBBUEksIGUuZy4sIFwiaHR0cHM6Ly9hcGkuZXhhbXBsZS5jb20vdjIvXCJcbiAgICpcbiAgICogRGVmYXVsdHMgdG8gcHJvY2Vzcy5lbnZbJ09QRU5BSV9CQVNFX1VSTCddLlxuICAgKi9cbiAgYmFzZVVSTD86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRoYXQgdGhlIGNsaWVudCBzaG91bGQgd2FpdCBmb3IgYSByZXNwb25zZVxuICAgKiBmcm9tIHRoZSBzZXJ2ZXIgYmVmb3JlIHRpbWluZyBvdXQgYSBzaW5nbGUgcmVxdWVzdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHJlcXVlc3QgdGltZW91dHMgYXJlIHJldHJpZWQgYnkgZGVmYXVsdCwgc28gaW4gYSB3b3JzdC1jYXNlIHNjZW5hcmlvIHlvdSBtYXkgd2FpdFxuICAgKiBtdWNoIGxvbmdlciB0aGFuIHRoaXMgdGltZW91dCBiZWZvcmUgdGhlIHByb21pc2Ugc3VjY2VlZHMgb3IgZmFpbHMuXG4gICAqL1xuICB0aW1lb3V0PzogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBBbiBIVFRQIGFnZW50IHVzZWQgdG8gbWFuYWdlIEhUVFAoUykgY29ubmVjdGlvbnMuXG4gICAqXG4gICAqIElmIG5vdCBwcm92aWRlZCwgYW4gYWdlbnQgd2lsbCBiZSBjb25zdHJ1Y3RlZCBieSBkZWZhdWx0IGluIHRoZSBOb2RlLmpzIGVudmlyb25tZW50LFxuICAgKiBvdGhlcndpc2Ugbm8gYWdlbnQgaXMgdXNlZC5cbiAgICovXG4gIGh0dHBBZ2VudD86IEFnZW50IHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGEgY3VzdG9tIGBmZXRjaGAgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIElmIG5vdCBwcm92aWRlZCwgd2UgdXNlIGBub2RlLWZldGNoYCBvbiBOb2RlLmpzIGFuZCBvdGhlcndpc2UgZXhwZWN0IHRoYXQgYGZldGNoYCBpc1xuICAgKiBkZWZpbmVkIGdsb2JhbGx5LlxuICAgKi9cbiAgZmV0Y2g/OiBDb3JlLkZldGNoIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgdGltZXMgdGhhdCB0aGUgY2xpZW50IHdpbGwgcmV0cnkgYSByZXF1ZXN0IGluIGNhc2Ugb2YgYVxuICAgKiB0ZW1wb3JhcnkgZmFpbHVyZSwgbGlrZSBhIG5ldHdvcmsgZXJyb3Igb3IgYSA1WFggZXJyb3IgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAZGVmYXVsdCAyXG4gICAqL1xuICBtYXhSZXRyaWVzPzogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGhlYWRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICpcbiAgICogVGhlc2UgY2FuIGJlIHJlbW92ZWQgaW4gaW5kaXZpZHVhbCByZXF1ZXN0cyBieSBleHBsaWNpdGx5IHNldHRpbmcgdGhlXG4gICAqIGhlYWRlciB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW4gcmVxdWVzdCBvcHRpb25zLlxuICAgKi9cbiAgZGVmYXVsdEhlYWRlcnM/OiBDb3JlLkhlYWRlcnMgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcXVlcnkgcGFyYW1ldGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgKlxuICAgKiBUaGVzZSBjYW4gYmUgcmVtb3ZlZCBpbiBpbmRpdmlkdWFsIHJlcXVlc3RzIGJ5IGV4cGxpY2l0bHkgc2V0dGluZyB0aGVcbiAgICogcGFyYW0gdG8gYHVuZGVmaW5lZGAgaW4gcmVxdWVzdCBvcHRpb25zLlxuICAgKi9cbiAgZGVmYXVsdFF1ZXJ5PzogQ29yZS5EZWZhdWx0UXVlcnkgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQsIGNsaWVudC1zaWRlIHVzZSBvZiB0aGlzIGxpYnJhcnkgaXMgbm90IGFsbG93ZWQsIGFzIGl0IHJpc2tzIGV4cG9zaW5nIHlvdXIgc2VjcmV0IEFQSSBjcmVkZW50aWFscyB0byBhdHRhY2tlcnMuXG4gICAqIE9ubHkgc2V0IHRoaXMgb3B0aW9uIHRvIGB0cnVlYCBpZiB5b3UgdW5kZXJzdGFuZCB0aGUgcmlza3MgYW5kIGhhdmUgYXBwcm9wcmlhdGUgbWl0aWdhdGlvbnMgaW4gcGxhY2UuXG4gICAqL1xuICBkYW5nZXJvdXNseUFsbG93QnJvd3Nlcj86IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQVBJIENsaWVudCBmb3IgaW50ZXJmYWNpbmcgd2l0aCB0aGUgT3BlbkFJIEFQSS5cbiAqL1xuZXhwb3J0IGNsYXNzIE9wZW5BSSBleHRlbmRzIENvcmUuQVBJQ2xpZW50IHtcbiAgYXBpS2V5OiBzdHJpbmc7XG4gIG9yZ2FuaXphdGlvbjogc3RyaW5nIHwgbnVsbDtcbiAgcHJvamVjdDogc3RyaW5nIHwgbnVsbDtcblxuICBwcml2YXRlIF9vcHRpb25zOiBDbGllbnRPcHRpb25zO1xuXG4gIC8qKlxuICAgKiBBUEkgQ2xpZW50IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBPcGVuQUkgQVBJLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW29wdHMuYXBpS2V5PXByb2Nlc3MuZW52WydPUEVOQUlfQVBJX0tFWSddID8/IHVuZGVmaW5lZF1cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0cy5vcmdhbml6YXRpb249cHJvY2Vzcy5lbnZbJ09QRU5BSV9PUkdfSUQnXSA/PyBudWxsXVxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRzLnByb2plY3Q9cHJvY2Vzcy5lbnZbJ09QRU5BSV9QUk9KRUNUX0lEJ10gPz8gbnVsbF1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhc2VVUkw9cHJvY2Vzcy5lbnZbJ09QRU5BSV9CQVNFX1VSTCddID8/IGh0dHBzOi8vYXBpLm9wZW5haS5jb20vdjFdIC0gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmFzZSBVUkwgZm9yIHRoZSBBUEkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lb3V0PTEwIG1pbnV0ZXNdIC0gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdGhlIGNsaWVudCB3aWxsIHdhaXQgZm9yIGEgcmVzcG9uc2UgYmVmb3JlIHRpbWluZyBvdXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5odHRwQWdlbnRdIC0gQW4gSFRUUCBhZ2VudCB1c2VkIHRvIG1hbmFnZSBIVFRQKHMpIGNvbm5lY3Rpb25zLlxuICAgKiBAcGFyYW0ge0NvcmUuRmV0Y2h9IFtvcHRzLmZldGNoXSAtIFNwZWNpZnkgYSBjdXN0b20gYGZldGNoYCBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLm1heFJldHJpZXM9Ml0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgdGltZXMgdGhlIGNsaWVudCB3aWxsIHJldHJ5IGEgcmVxdWVzdC5cbiAgICogQHBhcmFtIHtDb3JlLkhlYWRlcnN9IG9wdHMuZGVmYXVsdEhlYWRlcnMgLSBEZWZhdWx0IGhlYWRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICogQHBhcmFtIHtDb3JlLkRlZmF1bHRRdWVyeX0gb3B0cy5kZWZhdWx0UXVlcnkgLSBEZWZhdWx0IHF1ZXJ5IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5kYW5nZXJvdXNseUFsbG93QnJvd3Nlcj1mYWxzZV0gLSBCeSBkZWZhdWx0LCBjbGllbnQtc2lkZSB1c2Ugb2YgdGhpcyBsaWJyYXJ5IGlzIG5vdCBhbGxvd2VkLCBhcyBpdCByaXNrcyBleHBvc2luZyB5b3VyIHNlY3JldCBBUEkgY3JlZGVudGlhbHMgdG8gYXR0YWNrZXJzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVUkwgPSBDb3JlLnJlYWRFbnYoJ09QRU5BSV9CQVNFX1VSTCcpLFxuICAgIGFwaUtleSA9IENvcmUucmVhZEVudignT1BFTkFJX0FQSV9LRVknKSxcbiAgICBvcmdhbml6YXRpb24gPSBDb3JlLnJlYWRFbnYoJ09QRU5BSV9PUkdfSUQnKSA/PyBudWxsLFxuICAgIHByb2plY3QgPSBDb3JlLnJlYWRFbnYoJ09QRU5BSV9QUk9KRUNUX0lEJykgPz8gbnVsbCxcbiAgICAuLi5vcHRzXG4gIH06IENsaWVudE9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChhcGlLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcihcbiAgICAgICAgXCJUaGUgT1BFTkFJX0FQSV9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbWlzc2luZyBvciBlbXB0eTsgZWl0aGVyIHByb3ZpZGUgaXQsIG9yIGluc3RhbnRpYXRlIHRoZSBPcGVuQUkgY2xpZW50IHdpdGggYW4gYXBpS2V5IG9wdGlvbiwgbGlrZSBuZXcgT3BlbkFJKHsgYXBpS2V5OiAnTXkgQVBJIEtleScgfSkuXCIsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnM6IENsaWVudE9wdGlvbnMgPSB7XG4gICAgICBhcGlLZXksXG4gICAgICBvcmdhbml6YXRpb24sXG4gICAgICBwcm9qZWN0LFxuICAgICAgLi4ub3B0cyxcbiAgICAgIGJhc2VVUkw6IGJhc2VVUkwgfHwgYGh0dHBzOi8vYXBpLm9wZW5haS5jb20vdjFgLFxuICAgIH07XG5cbiAgICBpZiAoIW9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXIgJiYgQ29yZS5pc1J1bm5pbmdJbkJyb3dzZXIoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcihcbiAgICAgICAgXCJJdCBsb29rcyBsaWtlIHlvdSdyZSBydW5uaW5nIGluIGEgYnJvd3Nlci1saWtlIGVudmlyb25tZW50LlxcblxcblRoaXMgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdCwgYXMgaXQgcmlza3MgZXhwb3NpbmcgeW91ciBzZWNyZXQgQVBJIGNyZWRlbnRpYWxzIHRvIGF0dGFja2Vycy5cXG5JZiB5b3UgdW5kZXJzdGFuZCB0aGUgcmlza3MgYW5kIGhhdmUgYXBwcm9wcmlhdGUgbWl0aWdhdGlvbnMgaW4gcGxhY2UsXFxueW91IGNhbiBzZXQgdGhlIGBkYW5nZXJvdXNseUFsbG93QnJvd3NlcmAgb3B0aW9uIHRvIGB0cnVlYCwgZS5nLixcXG5cXG5uZXcgT3BlbkFJKHsgYXBpS2V5LCBkYW5nZXJvdXNseUFsbG93QnJvd3NlcjogdHJ1ZSB9KTtcXG5cXG5odHRwczovL2hlbHAub3BlbmFpLmNvbS9lbi9hcnRpY2xlcy81MTEyNTk1LWJlc3QtcHJhY3RpY2VzLWZvci1hcGkta2V5LXNhZmV0eVxcblwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBzdXBlcih7XG4gICAgICBiYXNlVVJMOiBvcHRpb25zLmJhc2VVUkwhLFxuICAgICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0ID8/IDYwMDAwMCAvKiAxMCBtaW51dGVzICovLFxuICAgICAgaHR0cEFnZW50OiBvcHRpb25zLmh0dHBBZ2VudCxcbiAgICAgIG1heFJldHJpZXM6IG9wdGlvbnMubWF4UmV0cmllcyxcbiAgICAgIGZldGNoOiBvcHRpb25zLmZldGNoLFxuICAgIH0pO1xuXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICB0aGlzLm9yZ2FuaXphdGlvbiA9IG9yZ2FuaXphdGlvbjtcbiAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICB9XG5cbiAgY29tcGxldGlvbnM6IEFQSS5Db21wbGV0aW9ucyA9IG5ldyBBUEkuQ29tcGxldGlvbnModGhpcyk7XG4gIGNoYXQ6IEFQSS5DaGF0ID0gbmV3IEFQSS5DaGF0KHRoaXMpO1xuICBlbWJlZGRpbmdzOiBBUEkuRW1iZWRkaW5ncyA9IG5ldyBBUEkuRW1iZWRkaW5ncyh0aGlzKTtcbiAgZmlsZXM6IEFQSS5GaWxlcyA9IG5ldyBBUEkuRmlsZXModGhpcyk7XG4gIGltYWdlczogQVBJLkltYWdlcyA9IG5ldyBBUEkuSW1hZ2VzKHRoaXMpO1xuICBhdWRpbzogQVBJLkF1ZGlvID0gbmV3IEFQSS5BdWRpbyh0aGlzKTtcbiAgbW9kZXJhdGlvbnM6IEFQSS5Nb2RlcmF0aW9ucyA9IG5ldyBBUEkuTW9kZXJhdGlvbnModGhpcyk7XG4gIG1vZGVsczogQVBJLk1vZGVscyA9IG5ldyBBUEkuTW9kZWxzKHRoaXMpO1xuICBmaW5lVHVuaW5nOiBBUEkuRmluZVR1bmluZyA9IG5ldyBBUEkuRmluZVR1bmluZyh0aGlzKTtcbiAgYmV0YTogQVBJLkJldGEgPSBuZXcgQVBJLkJldGEodGhpcyk7XG4gIGJhdGNoZXM6IEFQSS5CYXRjaGVzID0gbmV3IEFQSS5CYXRjaGVzKHRoaXMpO1xuICB1cGxvYWRzOiBBUEkuVXBsb2FkcyA9IG5ldyBBUEkuVXBsb2Fkcyh0aGlzKTtcblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgZGVmYXVsdFF1ZXJ5KCk6IENvcmUuRGVmYXVsdFF1ZXJ5IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5kZWZhdWx0UXVlcnk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgZGVmYXVsdEhlYWRlcnMob3B0czogQ29yZS5GaW5hbFJlcXVlc3RPcHRpb25zKTogQ29yZS5IZWFkZXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZGVmYXVsdEhlYWRlcnMob3B0cyksXG4gICAgICAnT3BlbkFJLU9yZ2FuaXphdGlvbic6IHRoaXMub3JnYW5pemF0aW9uLFxuICAgICAgJ09wZW5BSS1Qcm9qZWN0JzogdGhpcy5wcm9qZWN0LFxuICAgICAgLi4udGhpcy5fb3B0aW9ucy5kZWZhdWx0SGVhZGVycyxcbiAgICB9O1xuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGF1dGhIZWFkZXJzKG9wdHM6IENvcmUuRmluYWxSZXF1ZXN0T3B0aW9ucyk6IENvcmUuSGVhZGVycyB7XG4gICAgcmV0dXJuIHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuYXBpS2V5fWAgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBzdHJpbmdpZnlRdWVyeShxdWVyeTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBzdHJpbmcge1xuICAgIHJldHVybiBxcy5zdHJpbmdpZnkocXVlcnksIHsgYXJyYXlGb3JtYXQ6ICdicmFja2V0cycgfSk7XG4gIH1cblxuICBzdGF0aWMgT3BlbkFJID0gdGhpcztcbiAgc3RhdGljIERFRkFVTFRfVElNRU9VVCA9IDYwMDAwMDsgLy8gMTAgbWludXRlc1xuXG4gIHN0YXRpYyBPcGVuQUlFcnJvciA9IEVycm9ycy5PcGVuQUlFcnJvcjtcbiAgc3RhdGljIEFQSUVycm9yID0gRXJyb3JzLkFQSUVycm9yO1xuICBzdGF0aWMgQVBJQ29ubmVjdGlvbkVycm9yID0gRXJyb3JzLkFQSUNvbm5lY3Rpb25FcnJvcjtcbiAgc3RhdGljIEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IgPSBFcnJvcnMuQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcjtcbiAgc3RhdGljIEFQSVVzZXJBYm9ydEVycm9yID0gRXJyb3JzLkFQSVVzZXJBYm9ydEVycm9yO1xuICBzdGF0aWMgTm90Rm91bmRFcnJvciA9IEVycm9ycy5Ob3RGb3VuZEVycm9yO1xuICBzdGF0aWMgQ29uZmxpY3RFcnJvciA9IEVycm9ycy5Db25mbGljdEVycm9yO1xuICBzdGF0aWMgUmF0ZUxpbWl0RXJyb3IgPSBFcnJvcnMuUmF0ZUxpbWl0RXJyb3I7XG4gIHN0YXRpYyBCYWRSZXF1ZXN0RXJyb3IgPSBFcnJvcnMuQmFkUmVxdWVzdEVycm9yO1xuICBzdGF0aWMgQXV0aGVudGljYXRpb25FcnJvciA9IEVycm9ycy5BdXRoZW50aWNhdGlvbkVycm9yO1xuICBzdGF0aWMgSW50ZXJuYWxTZXJ2ZXJFcnJvciA9IEVycm9ycy5JbnRlcm5hbFNlcnZlckVycm9yO1xuICBzdGF0aWMgUGVybWlzc2lvbkRlbmllZEVycm9yID0gRXJyb3JzLlBlcm1pc3Npb25EZW5pZWRFcnJvcjtcbiAgc3RhdGljIFVucHJvY2Vzc2FibGVFbnRpdHlFcnJvciA9IEVycm9ycy5VbnByb2Nlc3NhYmxlRW50aXR5RXJyb3I7XG5cbiAgc3RhdGljIHRvRmlsZSA9IFVwbG9hZHMudG9GaWxlO1xuICBzdGF0aWMgZmlsZUZyb21QYXRoID0gVXBsb2Fkcy5maWxlRnJvbVBhdGg7XG59XG5cbk9wZW5BSS5Db21wbGV0aW9ucyA9IENvbXBsZXRpb25zO1xuT3BlbkFJLkNoYXQgPSBDaGF0O1xuT3BlbkFJLkVtYmVkZGluZ3MgPSBFbWJlZGRpbmdzO1xuT3BlbkFJLkZpbGVzID0gRmlsZXM7XG5PcGVuQUkuRmlsZU9iamVjdHNQYWdlID0gRmlsZU9iamVjdHNQYWdlO1xuT3BlbkFJLkltYWdlcyA9IEltYWdlcztcbk9wZW5BSS5BdWRpbyA9IEF1ZGlvO1xuT3BlbkFJLk1vZGVyYXRpb25zID0gTW9kZXJhdGlvbnM7XG5PcGVuQUkuTW9kZWxzID0gTW9kZWxzO1xuT3BlbkFJLk1vZGVsc1BhZ2UgPSBNb2RlbHNQYWdlO1xuT3BlbkFJLkZpbmVUdW5pbmcgPSBGaW5lVHVuaW5nO1xuT3BlbkFJLkJldGEgPSBCZXRhO1xuT3BlbkFJLkJhdGNoZXMgPSBCYXRjaGVzO1xuT3BlbkFJLkJhdGNoZXNQYWdlID0gQmF0Y2hlc1BhZ2U7XG5PcGVuQUkuVXBsb2FkcyA9IFVwbG9hZHNBUElVcGxvYWRzO1xuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIE9wZW5BSSB7XG4gIGV4cG9ydCB0eXBlIFJlcXVlc3RPcHRpb25zID0gQ29yZS5SZXF1ZXN0T3B0aW9ucztcblxuICBleHBvcnQgaW1wb3J0IFBhZ2UgPSBQYWdpbmF0aW9uLlBhZ2U7XG4gIGV4cG9ydCB7IHR5cGUgUGFnZVJlc3BvbnNlIGFzIFBhZ2VSZXNwb25zZSB9O1xuXG4gIGV4cG9ydCBpbXBvcnQgQ3Vyc29yUGFnZSA9IFBhZ2luYXRpb24uQ3Vyc29yUGFnZTtcbiAgZXhwb3J0IHsgdHlwZSBDdXJzb3JQYWdlUGFyYW1zIGFzIEN1cnNvclBhZ2VQYXJhbXMsIHR5cGUgQ3Vyc29yUGFnZVJlc3BvbnNlIGFzIEN1cnNvclBhZ2VSZXNwb25zZSB9O1xuXG4gIGV4cG9ydCB7XG4gICAgQ29tcGxldGlvbnMgYXMgQ29tcGxldGlvbnMsXG4gICAgdHlwZSBDb21wbGV0aW9uIGFzIENvbXBsZXRpb24sXG4gICAgdHlwZSBDb21wbGV0aW9uQ2hvaWNlIGFzIENvbXBsZXRpb25DaG9pY2UsXG4gICAgdHlwZSBDb21wbGV0aW9uVXNhZ2UgYXMgQ29tcGxldGlvblVzYWdlLFxuICAgIHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyBhcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBhcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBhcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgQ2hhdCBhcyBDaGF0LFxuICAgIHR5cGUgQ2hhdE1vZGVsIGFzIENoYXRNb2RlbCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uIGFzIENoYXRDb21wbGV0aW9uLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkF1ZGlvIGFzIENoYXRDb21wbGV0aW9uQXVkaW8sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkF1ZGlvUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25BdWRpb1BhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25DaHVuayBhcyBDaGF0Q29tcGxldGlvbkNodW5rLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydCBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydEltYWdlIGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbWFnZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbnB1dEF1ZGlvIGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbnB1dEF1ZGlvLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFJlZnVzYWwgYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFJlZnVzYWwsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dCBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uRGV2ZWxvcGVyTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uRGV2ZWxvcGVyTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25GdW5jdGlvbkNhbGxPcHRpb24gYXMgQ2hhdENvbXBsZXRpb25GdW5jdGlvbkNhbGxPcHRpb24sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2UgYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCBhcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTW9kYWxpdHkgYXMgQ2hhdENvbXBsZXRpb25Nb2RhbGl0eSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlIGFzIENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25QcmVkaWN0aW9uQ29udGVudCBhcyBDaGF0Q29tcGxldGlvblByZWRpY3Rpb25Db250ZW50LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25SZWFzb25pbmdFZmZvcnQgYXMgQ2hhdENvbXBsZXRpb25SZWFzb25pbmdFZmZvcnQsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblJvbGUgYXMgQ2hhdENvbXBsZXRpb25Sb2xlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25TdHJlYW1PcHRpb25zIGFzIENoYXRDb21wbGV0aW9uU3RyZWFtT3B0aW9ucyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uU3lzdGVtTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uU3lzdGVtTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2IgYXMgQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2IsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblRvb2wgYXMgQ2hhdENvbXBsZXRpb25Ub29sLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sQ2hvaWNlT3B0aW9uIGFzIENoYXRDb21wbGV0aW9uVG9vbENob2ljZU9wdGlvbixcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvblRvb2xNZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblVzZXJNZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25Vc2VyTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMgYXMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBhcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGFzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgRW1iZWRkaW5ncyBhcyBFbWJlZGRpbmdzLFxuICAgIHR5cGUgQ3JlYXRlRW1iZWRkaW5nUmVzcG9uc2UgYXMgQ3JlYXRlRW1iZWRkaW5nUmVzcG9uc2UsXG4gICAgdHlwZSBFbWJlZGRpbmcgYXMgRW1iZWRkaW5nLFxuICAgIHR5cGUgRW1iZWRkaW5nTW9kZWwgYXMgRW1iZWRkaW5nTW9kZWwsXG4gICAgdHlwZSBFbWJlZGRpbmdDcmVhdGVQYXJhbXMgYXMgRW1iZWRkaW5nQ3JlYXRlUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgRmlsZXMgYXMgRmlsZXMsXG4gICAgdHlwZSBGaWxlQ29udGVudCBhcyBGaWxlQ29udGVudCxcbiAgICB0eXBlIEZpbGVEZWxldGVkIGFzIEZpbGVEZWxldGVkLFxuICAgIHR5cGUgRmlsZU9iamVjdCBhcyBGaWxlT2JqZWN0LFxuICAgIHR5cGUgRmlsZVB1cnBvc2UgYXMgRmlsZVB1cnBvc2UsXG4gICAgRmlsZU9iamVjdHNQYWdlIGFzIEZpbGVPYmplY3RzUGFnZSxcbiAgICB0eXBlIEZpbGVDcmVhdGVQYXJhbXMgYXMgRmlsZUNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIEZpbGVMaXN0UGFyYW1zIGFzIEZpbGVMaXN0UGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgSW1hZ2VzIGFzIEltYWdlcyxcbiAgICB0eXBlIEltYWdlIGFzIEltYWdlLFxuICAgIHR5cGUgSW1hZ2VNb2RlbCBhcyBJbWFnZU1vZGVsLFxuICAgIHR5cGUgSW1hZ2VzUmVzcG9uc2UgYXMgSW1hZ2VzUmVzcG9uc2UsXG4gICAgdHlwZSBJbWFnZUNyZWF0ZVZhcmlhdGlvblBhcmFtcyBhcyBJbWFnZUNyZWF0ZVZhcmlhdGlvblBhcmFtcyxcbiAgICB0eXBlIEltYWdlRWRpdFBhcmFtcyBhcyBJbWFnZUVkaXRQYXJhbXMsXG4gICAgdHlwZSBJbWFnZUdlbmVyYXRlUGFyYW1zIGFzIEltYWdlR2VuZXJhdGVQYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHsgQXVkaW8gYXMgQXVkaW8sIHR5cGUgQXVkaW9Nb2RlbCBhcyBBdWRpb01vZGVsLCB0eXBlIEF1ZGlvUmVzcG9uc2VGb3JtYXQgYXMgQXVkaW9SZXNwb25zZUZvcm1hdCB9O1xuXG4gIGV4cG9ydCB7XG4gICAgTW9kZXJhdGlvbnMgYXMgTW9kZXJhdGlvbnMsXG4gICAgdHlwZSBNb2RlcmF0aW9uIGFzIE1vZGVyYXRpb24sXG4gICAgdHlwZSBNb2RlcmF0aW9uSW1hZ2VVUkxJbnB1dCBhcyBNb2RlcmF0aW9uSW1hZ2VVUkxJbnB1dCxcbiAgICB0eXBlIE1vZGVyYXRpb25Nb2RlbCBhcyBNb2RlcmF0aW9uTW9kZWwsXG4gICAgdHlwZSBNb2RlcmF0aW9uTXVsdGlNb2RhbElucHV0IGFzIE1vZGVyYXRpb25NdWx0aU1vZGFsSW5wdXQsXG4gICAgdHlwZSBNb2RlcmF0aW9uVGV4dElucHV0IGFzIE1vZGVyYXRpb25UZXh0SW5wdXQsXG4gICAgdHlwZSBNb2RlcmF0aW9uQ3JlYXRlUmVzcG9uc2UgYXMgTW9kZXJhdGlvbkNyZWF0ZVJlc3BvbnNlLFxuICAgIHR5cGUgTW9kZXJhdGlvbkNyZWF0ZVBhcmFtcyBhcyBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgTW9kZWxzIGFzIE1vZGVscyxcbiAgICB0eXBlIE1vZGVsIGFzIE1vZGVsLFxuICAgIHR5cGUgTW9kZWxEZWxldGVkIGFzIE1vZGVsRGVsZXRlZCxcbiAgICBNb2RlbHNQYWdlIGFzIE1vZGVsc1BhZ2UsXG4gIH07XG5cbiAgZXhwb3J0IHsgRmluZVR1bmluZyBhcyBGaW5lVHVuaW5nIH07XG5cbiAgZXhwb3J0IHsgQmV0YSBhcyBCZXRhIH07XG5cbiAgZXhwb3J0IHtcbiAgICBCYXRjaGVzIGFzIEJhdGNoZXMsXG4gICAgdHlwZSBCYXRjaCBhcyBCYXRjaCxcbiAgICB0eXBlIEJhdGNoRXJyb3IgYXMgQmF0Y2hFcnJvcixcbiAgICB0eXBlIEJhdGNoUmVxdWVzdENvdW50cyBhcyBCYXRjaFJlcXVlc3RDb3VudHMsXG4gICAgQmF0Y2hlc1BhZ2UgYXMgQmF0Y2hlc1BhZ2UsXG4gICAgdHlwZSBCYXRjaENyZWF0ZVBhcmFtcyBhcyBCYXRjaENyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIEJhdGNoTGlzdFBhcmFtcyBhcyBCYXRjaExpc3RQYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHtcbiAgICBVcGxvYWRzQVBJVXBsb2FkcyBhcyBVcGxvYWRzLFxuICAgIHR5cGUgVXBsb2FkIGFzIFVwbG9hZCxcbiAgICB0eXBlIFVwbG9hZENyZWF0ZVBhcmFtcyBhcyBVcGxvYWRDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBVcGxvYWRDb21wbGV0ZVBhcmFtcyBhcyBVcGxvYWRDb21wbGV0ZVBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQgdHlwZSBFcnJvck9iamVjdCA9IEFQSS5FcnJvck9iamVjdDtcbiAgZXhwb3J0IHR5cGUgRnVuY3Rpb25EZWZpbml0aW9uID0gQVBJLkZ1bmN0aW9uRGVmaW5pdGlvbjtcbiAgZXhwb3J0IHR5cGUgRnVuY3Rpb25QYXJhbWV0ZXJzID0gQVBJLkZ1bmN0aW9uUGFyYW1ldGVycztcbiAgZXhwb3J0IHR5cGUgUmVzcG9uc2VGb3JtYXRKU09OT2JqZWN0ID0gQVBJLlJlc3BvbnNlRm9ybWF0SlNPTk9iamVjdDtcbiAgZXhwb3J0IHR5cGUgUmVzcG9uc2VGb3JtYXRKU09OU2NoZW1hID0gQVBJLlJlc3BvbnNlRm9ybWF0SlNPTlNjaGVtYTtcbiAgZXhwb3J0IHR5cGUgUmVzcG9uc2VGb3JtYXRUZXh0ID0gQVBJLlJlc3BvbnNlRm9ybWF0VGV4dDtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBBenVyZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKiBBUEkgQ2xpZW50IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBBenVyZSBPcGVuQUkgQVBJLiAqL1xuZXhwb3J0IGludGVyZmFjZSBBenVyZUNsaWVudE9wdGlvbnMgZXh0ZW5kcyBDbGllbnRPcHRpb25zIHtcbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIHByb2Nlc3MuZW52WydPUEVOQUlfQVBJX1ZFUlNJT04nXS5cbiAgICovXG4gIGFwaVZlcnNpb24/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFlvdXIgQXp1cmUgZW5kcG9pbnQsIGluY2x1ZGluZyB0aGUgcmVzb3VyY2UsIGUuZy4gYGh0dHBzOi8vZXhhbXBsZS1yZXNvdXJjZS5henVyZS5vcGVuYWkuY29tL2BcbiAgICovXG4gIGVuZHBvaW50Pzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBBIG1vZGVsIGRlcGxveW1lbnQsIGlmIGdpdmVuLCBzZXRzIHRoZSBiYXNlIGNsaWVudCBVUkwgdG8gaW5jbHVkZSBgL2RlcGxveW1lbnRzL3tkZXBsb3ltZW50fWAuXG4gICAqIE5vdGU6IHRoaXMgbWVhbnMgeW91IHdvbid0IGJlIGFibGUgdG8gdXNlIG5vbi1kZXBsb3ltZW50IGVuZHBvaW50cy4gTm90IHN1cHBvcnRlZCB3aXRoIEFzc2lzdGFudHMgQVBJcy5cbiAgICovXG4gIGRlcGxveW1lbnQ/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIHByb2Nlc3MuZW52WydBWlVSRV9PUEVOQUlfQVBJX0tFWSddLlxuICAgKi9cbiAgYXBpS2V5Pzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhY2Nlc3MgdG9rZW4gZm9yIE1pY3Jvc29mdCBFbnRyYSAoZm9ybWVybHkga25vd24gYXMgQXp1cmUgQWN0aXZlIERpcmVjdG9yeSksXG4gICAqIHdoaWNoIHdpbGwgYmUgaW52b2tlZCBvbiBldmVyeSByZXF1ZXN0LlxuICAgKi9cbiAgYXp1cmVBRFRva2VuUHJvdmlkZXI/OiAoKCkgPT4gUHJvbWlzZTxzdHJpbmc+KSB8IHVuZGVmaW5lZDtcbn1cblxuLyoqIEFQSSBDbGllbnQgZm9yIGludGVyZmFjaW5nIHdpdGggdGhlIEF6dXJlIE9wZW5BSSBBUEkuICovXG5leHBvcnQgY2xhc3MgQXp1cmVPcGVuQUkgZXh0ZW5kcyBPcGVuQUkge1xuICBwcml2YXRlIF9henVyZUFEVG9rZW5Qcm92aWRlcjogKCgpID0+IFByb21pc2U8c3RyaW5nPikgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgX2RlcGxveW1lbnQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgYXBpVmVyc2lvbjogc3RyaW5nID0gJyc7XG4gIC8qKlxuICAgKiBBUEkgQ2xpZW50IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBBenVyZSBPcGVuQUkgQVBJLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW29wdHMuYXBpVmVyc2lvbj1wcm9jZXNzLmVudlsnT1BFTkFJX0FQSV9WRVJTSU9OJ10gPz8gdW5kZWZpbmVkXVxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW29wdHMuZW5kcG9pbnQ9cHJvY2Vzcy5lbnZbJ0FaVVJFX09QRU5BSV9FTkRQT0lOVCddID8/IHVuZGVmaW5lZF0gLSBZb3VyIEF6dXJlIGVuZHBvaW50LCBpbmNsdWRpbmcgdGhlIHJlc291cmNlLCBlLmcuIGBodHRwczovL2V4YW1wbGUtcmVzb3VyY2UuYXp1cmUub3BlbmFpLmNvbS9gXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbb3B0cy5hcGlLZXk9cHJvY2Vzcy5lbnZbJ0FaVVJFX09QRU5BSV9BUElfS0VZJ10gPz8gdW5kZWZpbmVkXVxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gb3B0cy5kZXBsb3ltZW50IC0gQSBtb2RlbCBkZXBsb3ltZW50LCBpZiBnaXZlbiwgc2V0cyB0aGUgYmFzZSBjbGllbnQgVVJMIHRvIGluY2x1ZGUgYC9kZXBsb3ltZW50cy97ZGVwbG95bWVudH1gLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRzLm9yZ2FuaXphdGlvbj1wcm9jZXNzLmVudlsnT1BFTkFJX09SR19JRCddID8/IG51bGxdXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYXNlVVJMPXByb2Nlc3MuZW52WydPUEVOQUlfQkFTRV9VUkwnXV0gLSBTZXRzIHRoZSBiYXNlIFVSTCBmb3IgdGhlIEFQSSwgZS5nLiBgaHR0cHM6Ly9leGFtcGxlLXJlc291cmNlLmF6dXJlLm9wZW5haS5jb20vb3BlbmFpL2AuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lb3V0PTEwIG1pbnV0ZXNdIC0gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdGhlIGNsaWVudCB3aWxsIHdhaXQgZm9yIGEgcmVzcG9uc2UgYmVmb3JlIHRpbWluZyBvdXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5odHRwQWdlbnRdIC0gQW4gSFRUUCBhZ2VudCB1c2VkIHRvIG1hbmFnZSBIVFRQKHMpIGNvbm5lY3Rpb25zLlxuICAgKiBAcGFyYW0ge0NvcmUuRmV0Y2h9IFtvcHRzLmZldGNoXSAtIFNwZWNpZnkgYSBjdXN0b20gYGZldGNoYCBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLm1heFJldHJpZXM9Ml0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgdGltZXMgdGhlIGNsaWVudCB3aWxsIHJldHJ5IGEgcmVxdWVzdC5cbiAgICogQHBhcmFtIHtDb3JlLkhlYWRlcnN9IG9wdHMuZGVmYXVsdEhlYWRlcnMgLSBEZWZhdWx0IGhlYWRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICogQHBhcmFtIHtDb3JlLkRlZmF1bHRRdWVyeX0gb3B0cy5kZWZhdWx0UXVlcnkgLSBEZWZhdWx0IHF1ZXJ5IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5kYW5nZXJvdXNseUFsbG93QnJvd3Nlcj1mYWxzZV0gLSBCeSBkZWZhdWx0LCBjbGllbnQtc2lkZSB1c2Ugb2YgdGhpcyBsaWJyYXJ5IGlzIG5vdCBhbGxvd2VkLCBhcyBpdCByaXNrcyBleHBvc2luZyB5b3VyIHNlY3JldCBBUEkgY3JlZGVudGlhbHMgdG8gYXR0YWNrZXJzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVUkwgPSBDb3JlLnJlYWRFbnYoJ09QRU5BSV9CQVNFX1VSTCcpLFxuICAgIGFwaUtleSA9IENvcmUucmVhZEVudignQVpVUkVfT1BFTkFJX0FQSV9LRVknKSxcbiAgICBhcGlWZXJzaW9uID0gQ29yZS5yZWFkRW52KCdPUEVOQUlfQVBJX1ZFUlNJT04nKSxcbiAgICBlbmRwb2ludCxcbiAgICBkZXBsb3ltZW50LFxuICAgIGF6dXJlQURUb2tlblByb3ZpZGVyLFxuICAgIGRhbmdlcm91c2x5QWxsb3dCcm93c2VyLFxuICAgIC4uLm9wdHNcbiAgfTogQXp1cmVDbGllbnRPcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWFwaVZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuT3BlbkFJRXJyb3IoXG4gICAgICAgIFwiVGhlIE9QRU5BSV9BUElfVkVSU0lPTiBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtaXNzaW5nIG9yIGVtcHR5OyBlaXRoZXIgcHJvdmlkZSBpdCwgb3IgaW5zdGFudGlhdGUgdGhlIEF6dXJlT3BlbkFJIGNsaWVudCB3aXRoIGFuIGFwaVZlcnNpb24gb3B0aW9uLCBsaWtlIG5ldyBBenVyZU9wZW5BSSh7IGFwaVZlcnNpb246ICdNeSBBUEkgVmVyc2lvbicgfSkuXCIsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYXp1cmVBRFRva2VuUHJvdmlkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRhbmdlcm91c2x5QWxsb3dCcm93c2VyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWF6dXJlQURUb2tlblByb3ZpZGVyICYmICFhcGlLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuT3BlbkFJRXJyb3IoXG4gICAgICAgICdNaXNzaW5nIGNyZWRlbnRpYWxzLiBQbGVhc2UgcGFzcyBvbmUgb2YgYGFwaUtleWAgYW5kIGBhenVyZUFEVG9rZW5Qcm92aWRlcmAsIG9yIHNldCB0aGUgYEFaVVJFX09QRU5BSV9BUElfS0VZYCBlbnZpcm9ubWVudCB2YXJpYWJsZS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoYXp1cmVBRFRva2VuUHJvdmlkZXIgJiYgYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKFxuICAgICAgICAnVGhlIGBhcGlLZXlgIGFuZCBgYXp1cmVBRFRva2VuUHJvdmlkZXJgIGFyZ3VtZW50cyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlOyBvbmx5IG9uZSBjYW4gYmUgcGFzc2VkIGF0IGEgdGltZS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBkZWZpbmUgYSBzZW50aW5lbCB2YWx1ZSB0byBhdm9pZCBhbnkgdHlwaW5nIGlzc3Vlc1xuICAgIGFwaUtleSA/Pz0gQVBJX0tFWV9TRU5USU5FTDtcblxuICAgIG9wdHMuZGVmYXVsdFF1ZXJ5ID0geyAuLi5vcHRzLmRlZmF1bHRRdWVyeSwgJ2FwaS12ZXJzaW9uJzogYXBpVmVyc2lvbiB9O1xuXG4gICAgaWYgKCFiYXNlVVJMKSB7XG4gICAgICBpZiAoIWVuZHBvaW50KSB7XG4gICAgICAgIGVuZHBvaW50ID0gcHJvY2Vzcy5lbnZbJ0FaVVJFX09QRU5BSV9FTkRQT0lOVCddO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVuZHBvaW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcnMuT3BlbkFJRXJyb3IoXG4gICAgICAgICAgJ011c3QgcHJvdmlkZSBvbmUgb2YgdGhlIGBiYXNlVVJMYCBvciBgZW5kcG9pbnRgIGFyZ3VtZW50cywgb3IgdGhlIGBBWlVSRV9PUEVOQUlfRU5EUE9JTlRgIGVudmlyb25tZW50IHZhcmlhYmxlJyxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgYmFzZVVSTCA9IGAke2VuZHBvaW50fS9vcGVuYWlgO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZW5kcG9pbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcignYmFzZVVSTCBhbmQgZW5kcG9pbnQgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyKHtcbiAgICAgIGFwaUtleSxcbiAgICAgIGJhc2VVUkwsXG4gICAgICAuLi5vcHRzLFxuICAgICAgLi4uKGRhbmdlcm91c2x5QWxsb3dCcm93c2VyICE9PSB1bmRlZmluZWQgPyB7IGRhbmdlcm91c2x5QWxsb3dCcm93c2VyIH0gOiB7fSksXG4gICAgfSk7XG5cbiAgICB0aGlzLl9henVyZUFEVG9rZW5Qcm92aWRlciA9IGF6dXJlQURUb2tlblByb3ZpZGVyO1xuICAgIHRoaXMuYXBpVmVyc2lvbiA9IGFwaVZlcnNpb247XG4gICAgdGhpcy5fZGVwbG95bWVudCA9IGRlcGxveW1lbnQ7XG4gIH1cblxuICBvdmVycmlkZSBidWlsZFJlcXVlc3Qob3B0aW9uczogQ29yZS5GaW5hbFJlcXVlc3RPcHRpb25zPHVua25vd24+KToge1xuICAgIHJlcTogUmVxdWVzdEluaXQ7XG4gICAgdXJsOiBzdHJpbmc7XG4gICAgdGltZW91dDogbnVtYmVyO1xuICB9IHtcbiAgICBpZiAoX2RlcGxveW1lbnRzX2VuZHBvaW50cy5oYXMob3B0aW9ucy5wYXRoKSAmJiBvcHRpb25zLm1ldGhvZCA9PT0gJ3Bvc3QnICYmIG9wdGlvbnMuYm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIUNvcmUuaXNPYmoob3B0aW9ucy5ib2R5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHJlcXVlc3QgYm9keSB0byBiZSBhbiBvYmplY3QnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fZGVwbG95bWVudCB8fCBvcHRpb25zLmJvZHlbJ21vZGVsJ107XG4gICAgICBpZiAobW9kZWwgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5iYXNlVVJMLmluY2x1ZGVzKCcvZGVwbG95bWVudHMnKSkge1xuICAgICAgICBvcHRpb25zLnBhdGggPSBgL2RlcGxveW1lbnRzLyR7bW9kZWx9JHtvcHRpb25zLnBhdGh9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmJ1aWxkUmVxdWVzdChvcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2dldEF6dXJlQURUb2tlbigpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fYXp1cmVBRFRva2VuUHJvdmlkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdGhpcy5fYXp1cmVBRFRva2VuUHJvdmlkZXIoKTtcbiAgICAgIGlmICghdG9rZW4gfHwgdHlwZW9mIHRva2VuICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCAnYXp1cmVBRFRva2VuUHJvdmlkZXInIGFyZ3VtZW50IHRvIHJldHVybiBhIHN0cmluZyBidXQgaXQgcmV0dXJuZWQgJHt0b2tlbn1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGF1dGhIZWFkZXJzKG9wdHM6IENvcmUuRmluYWxSZXF1ZXN0T3B0aW9ucyk6IENvcmUuSGVhZGVycyB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGFzeW5jIHByZXBhcmVPcHRpb25zKG9wdHM6IENvcmUuRmluYWxSZXF1ZXN0T3B0aW9uczx1bmtub3duPik6IFByb21pc2U8dm9pZD4ge1xuICAgIC8qKlxuICAgICAqIFRoZSB1c2VyIHNob3VsZCBwcm92aWRlIGEgYmVhcmVyIHRva2VuIHByb3ZpZGVyIGlmIHRoZXkgd2FudFxuICAgICAqIHRvIHVzZSBBenVyZSBBRCBhdXRoZW50aWNhdGlvbi4gVGhlIHVzZXIgc2hvdWxkbid0IHNldCB0aGVcbiAgICAgKiBBdXRob3JpemF0aW9uIGhlYWRlciBtYW51YWxseSBiZWNhdXNlIHRoZSBoZWFkZXIgaXMgb3ZlcndyaXR0ZW5cbiAgICAgKiB3aXRoIHRoZSBBenVyZSBBRCB0b2tlbiBpZiBhIGJlYXJlciB0b2tlbiBwcm92aWRlciBpcyBwcm92aWRlZC5cbiAgICAgKi9cbiAgICBpZiAob3B0cy5oZWFkZXJzPy5bJ2FwaS1rZXknXSkge1xuICAgICAgcmV0dXJuIHN1cGVyLnByZXBhcmVPcHRpb25zKG9wdHMpO1xuICAgIH1cbiAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHRoaXMuX2dldEF6dXJlQURUb2tlbigpO1xuICAgIG9wdHMuaGVhZGVycyA/Pz0ge307XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBvcHRzLmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hcGlLZXkgIT09IEFQSV9LRVlfU0VOVElORUwpIHtcbiAgICAgIG9wdHMuaGVhZGVyc1snYXBpLWtleSddID0gdGhpcy5hcGlLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuT3BlbkFJRXJyb3IoJ1VuYWJsZSB0byBoYW5kbGUgYXV0aCcpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucHJlcGFyZU9wdGlvbnMob3B0cyk7XG4gIH1cbn1cblxuY29uc3QgX2RlcGxveW1lbnRzX2VuZHBvaW50cyA9IG5ldyBTZXQoW1xuICAnL2NvbXBsZXRpb25zJyxcbiAgJy9jaGF0L2NvbXBsZXRpb25zJyxcbiAgJy9lbWJlZGRpbmdzJyxcbiAgJy9hdWRpby90cmFuc2NyaXB0aW9ucycsXG4gICcvYXVkaW8vdHJhbnNsYXRpb25zJyxcbiAgJy9hdWRpby9zcGVlY2gnLFxuICAnL2ltYWdlcy9nZW5lcmF0aW9ucycsXG5dKTtcblxuY29uc3QgQVBJX0tFWV9TRU5USU5FTCA9ICc8TWlzc2luZyBLZXk+JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFbmQgQXp1cmUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgeyB0b0ZpbGUsIGZpbGVGcm9tUGF0aCB9IGZyb20gJy4vdXBsb2Fkcyc7XG5leHBvcnQge1xuICBPcGVuQUlFcnJvcixcbiAgQVBJRXJyb3IsXG4gIEFQSUNvbm5lY3Rpb25FcnJvcixcbiAgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcixcbiAgQVBJVXNlckFib3J0RXJyb3IsXG4gIE5vdEZvdW5kRXJyb3IsXG4gIENvbmZsaWN0RXJyb3IsXG4gIFJhdGVMaW1pdEVycm9yLFxuICBCYWRSZXF1ZXN0RXJyb3IsXG4gIEF1dGhlbnRpY2F0aW9uRXJyb3IsXG4gIEludGVybmFsU2VydmVyRXJyb3IsXG4gIFBlcm1pc3Npb25EZW5pZWRFcnJvcixcbiAgVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yLFxufSBmcm9tICcuL2Vycm9yJztcblxuZXhwb3J0IGRlZmF1bHQgT3BlbkFJO1xuIiwgImltcG9ydCBPcGVuQUkgZnJvbSAnb3BlbmFpJztcbmltcG9ydCB7IEVtYmVkZGluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vbW9kZWxzL0RvY3VtZW50Q2h1bmsnO1xuaW1wb3J0IHsgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgRXJyb3JIYW5kbGVyIH0gZnJvbSAnLi4vdXRpbHMvRXJyb3JIYW5kbGVyJztcbmltcG9ydCB7IE9wZW5BSVNldHRpbmdzIH0gZnJvbSAnLi4vc2V0dGluZ3MvU2V0dGluZ3MnO1xuXG5leHBvcnQgY2xhc3MgT3BlbkFJU2VydmljZSB7XG5cdHByaXZhdGUgY2xpZW50OiBPcGVuQUkgfCBudWxsO1xuXHRwcml2YXRlIHJhdGVMaW1pdERlbGF5OiBudW1iZXIgPSAyMDsgLy8gbXMgYmV0d2VlbiByZXF1ZXN0c1xuXHRwcml2YXRlIGxhc3RSZXF1ZXN0VGltZTogbnVtYmVyID0gMDtcblx0cHJpdmF0ZSByZWFkb25seSBlcnJvckhhbmRsZXI6IEVycm9ySGFuZGxlcjtcblx0cHJpdmF0ZSBzZXR0aW5nczogT3BlbkFJU2V0dGluZ3M7XG5cblx0Y29uc3RydWN0b3Ioc2V0dGluZ3M6IE9wZW5BSVNldHRpbmdzLCBlcnJvckhhbmRsZXI6IEVycm9ySGFuZGxlcikge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcblx0XHR0aGlzLmVycm9ySGFuZGxlciA9IGVycm9ySGFuZGxlcjtcblxuXHRcdGlmICghc2V0dGluZ3MuYXBpS2V5KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ09wZW5BSSBBUEkga2V5IGlzIG1pc3NpbmcuIE9wZW5BSVNlcnZpY2Ugd2lsbCBub3QgYmUgaW5pdGlhbGl6ZWQuJyk7XG5cdFx0XHR0aGlzLmNsaWVudCA9IG51bGw7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdGlhbGl6ZSBPcGVuQUkgY2xpZW50IHdpdGggYnJvd3NlciBzdXBwb3J0XG5cdFx0dGhpcy5jbGllbnQgPSBuZXcgT3BlbkFJKHtcblx0XHRcdGFwaUtleTogc2V0dGluZ3MuYXBpS2V5LFxuXHRcdFx0ZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI6IHRydWUsIC8vIEVuYWJsZSBicm93c2VyLWxpa2UgZW52aXJvbm1lbnQgdXNhZ2Vcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGUgc2VydmljZSBpcyBpbml0aWFsaXplZFxuXHQgKi9cblx0cHVibGljIGlzSW5pdGlhbGl6ZWQoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuY2xpZW50ICE9PSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgZW1iZWRkaW5ncyBmb3IgdGhlIGdpdmVuIHRleHQgY2h1bmtzIHdpdGggcmF0ZSBsaW1pdGluZyBhbmQgcmV0cmllc1xuXHQgKi9cblx0YXN5bmMgY3JlYXRlRW1iZWRkaW5ncyhjaHVua3M6IHN0cmluZ1tdKTogUHJvbWlzZTxFbWJlZGRpbmdSZXNwb25zZVtdPiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdPcGVuQUlTZXJ2aWNlIGlzIG5vdCBpbml0aWFsaXplZC4gQ2Fubm90IGNyZWF0ZSBlbWJlZGRpbmdzLicpO1xuXHRcdFx0bmV3IE5vdGljZSgnT3BlbkFJIEFQSSBrZXkgaXMgbWlzc2luZy4gUGxlYXNlIHNldCBpdCBpbiB0aGUgcGx1Z2luIHNldHRpbmdzLicpO1xuXHRcdFx0cmV0dXJuIGNodW5rcy5tYXAoKCkgPT4gKHtcblx0XHRcdFx0ZGF0YTogW10sXG5cdFx0XHRcdHVzYWdlOiB7IHByb21wdF90b2tlbnM6IDAsIHRvdGFsX3Rva2VuczogMCB9LFxuXHRcdFx0XHRtb2RlbDogXCJ0ZXh0LWVtYmVkZGluZy1hZGEtMDAyXCIsIC8vIERlZmF1bHQgbW9kZWwgdG8gbWFpbnRhaW4gb3V0cHV0IGNvbnNpc3RlbmN5XG5cdFx0XHR9KSk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZW1iZWRkaW5nczogRW1iZWRkaW5nUmVzcG9uc2VbXSA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCB0aW1lU2luY2VMYXN0UmVxdWVzdCA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RSZXF1ZXN0VGltZTtcblx0XHRcdFx0aWYgKHRpbWVTaW5jZUxhc3RSZXF1ZXN0IDwgdGhpcy5yYXRlTGltaXREZWxheSkge1xuXHRcdFx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT5cblx0XHRcdFx0XHRcdHNldFRpbWVvdXQocmVzb2x2ZSwgdGhpcy5yYXRlTGltaXREZWxheSAtIHRpbWVTaW5jZUxhc3RSZXF1ZXN0KVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBFeHBsaWNpdGx5IHNldCB0aGUgbW9kZWwgdG8gYHRleHQtZW1iZWRkaW5nLWFkYS0wMDJgXG5cdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQuZW1iZWRkaW5ncy5jcmVhdGUoe1xuXHRcdFx0XHRcdG1vZGVsOiBcInRleHQtZW1iZWRkaW5nLWFkYS0wMDJcIiwgLy8gVXNlIHRoZSBjb3JyZWN0IG1vZGVsXG5cdFx0XHRcdFx0aW5wdXQ6IGNodW5rc1tpXSxcblx0XHRcdFx0XHRlbmNvZGluZ19mb3JtYXQ6IFwiZmxvYXRcIixcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dGhpcy5sYXN0UmVxdWVzdFRpbWUgPSBEYXRlLm5vdygpO1xuXG5cdFx0XHRcdGVtYmVkZGluZ3MucHVzaCh7XG5cdFx0XHRcdFx0ZGF0YTogW1xuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRlbWJlZGRpbmc6IHJlc3BvbnNlLmRhdGFbMF0uZW1iZWRkaW5nLFxuXHRcdFx0XHRcdFx0XHRpbmRleDogaSxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XSxcblx0XHRcdFx0XHR1c2FnZToge1xuXHRcdFx0XHRcdFx0cHJvbXB0X3Rva2VuczogcmVzcG9uc2UudXNhZ2UucHJvbXB0X3Rva2Vucyxcblx0XHRcdFx0XHRcdHRvdGFsX3Rva2VuczogcmVzcG9uc2UudXNhZ2UudG90YWxfdG9rZW5zLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0bW9kZWw6IHJlc3BvbnNlLm1vZGVsLFxuXHRcdFx0XHR9KTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdHRoaXMuaGFuZGxlRW1iZWRkaW5nRXJyb3IoZXJyb3IsIGNodW5rc1tpXSk7XG5cdFx0XHRcdGVtYmVkZGluZ3MucHVzaCh7XG5cdFx0XHRcdFx0ZGF0YTogW10sXG5cdFx0XHRcdFx0dXNhZ2U6IHsgcHJvbXB0X3Rva2VuczogMCwgdG90YWxfdG9rZW5zOiAwIH0sXG5cdFx0XHRcdFx0bW9kZWw6IFwidGV4dC1lbWJlZGRpbmctYWRhLTAwMlwiLFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZW1iZWRkaW5ncztcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIHZhcmlvdXMgdHlwZXMgb2YgT3BlbkFJIEFQSSBlcnJvcnNcblx0ICovXG5cdHByaXZhdGUgaGFuZGxlRW1iZWRkaW5nRXJyb3IoZXJyb3I6IGFueSwgY2h1bms6IHN0cmluZyk6IHZvaWQge1xuXHRcdGxldCBlcnJvck1lc3NhZ2U6IHN0cmluZztcblxuXHRcdGlmIChlcnJvciBpbnN0YW5jZW9mIE9wZW5BSS5BUElFcnJvcikge1xuXHRcdFx0c3dpdGNoIChlcnJvci5zdGF0dXMpIHtcblx0XHRcdFx0Y2FzZSA0Mjk6XG5cdFx0XHRcdFx0ZXJyb3JNZXNzYWdlID0gJ1JhdGUgbGltaXQgZXhjZWVkZWQuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA0MDE6XG5cdFx0XHRcdFx0ZXJyb3JNZXNzYWdlID0gJ0ludmFsaWQgQVBJIGtleS4gUGxlYXNlIGNoZWNrIHlvdXIgc2V0dGluZ3MuJztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA0MTM6XG5cdFx0XHRcdFx0ZXJyb3JNZXNzYWdlID0gJ1RleHQgY2h1bmsgdG9vIGxhcmdlIGZvciBlbWJlZGRpbmcuJztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRlcnJvck1lc3NhZ2UgPSBgT3BlbkFJIEFQSSBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVycm9yTWVzc2FnZSA9IGBVbmV4cGVjdGVkIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YDtcblx0XHR9XG5cblx0XHQvLyBMb2cgdGhlIGVycm9yIHRocm91Z2ggdGhlIGNlbnRyYWxpemVkIGVycm9yIGhhbmRsZXJcblx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0Y29udGV4dDogJ09wZW5BSVNlcnZpY2UuY3JlYXRlRW1iZWRkaW5ncycsXG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHRjaHVua1ByZXZpZXc6IGNodW5rLnN1YnN0cmluZygwLCAxMDApICsgJy4uLicgLy8gRmlyc3QgMTAwIGNoYXJzIGZvciBjb250ZXh0XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRuZXcgTm90aWNlKGBFcnJvciBjcmVhdGluZyBlbWJlZGRpbmc6ICR7ZXJyb3JNZXNzYWdlfWApO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgc2VydmljZSBzZXR0aW5nc1xuXHQgKi9cblx0dXBkYXRlU2V0dGluZ3Moc2V0dGluZ3M6IE9wZW5BSVNldHRpbmdzKTogdm9pZCB7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuXG5cdFx0aWYgKCFzZXR0aW5ncy5hcGlLZXkpIHtcblx0XHRcdGNvbnNvbGUud2FybignT3BlbkFJIEFQSSBrZXkgaXMgbWlzc2luZy4gT3BlbkFJU2VydmljZSB3aWxsIG5vdCBiZSBpbml0aWFsaXplZC4nKTtcblx0XHRcdHRoaXMuY2xpZW50ID0gbnVsbDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZWluaXRpYWxpemUgdGhlIE9wZW5BSSBjbGllbnQgd2l0aCB1cGRhdGVkIHNldHRpbmdzXG5cdFx0dGhpcy5jbGllbnQgPSBuZXcgT3BlbkFJKHtcblx0XHRcdGFwaUtleTogc2V0dGluZ3MuYXBpS2V5LFxuXHRcdFx0ZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI6IHRydWUsIC8vIEVuc3VyZSB0aGlzIHJlbWFpbnMgZW5hYmxlZFxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgcmF0ZSBsaW1pdGluZyBwYXJhbWV0ZXJzXG5cdCAqL1xuXHR1cGRhdGVSYXRlTGltaXQoZGVsYXlNczogbnVtYmVyKTogdm9pZCB7XG5cdFx0dGhpcy5yYXRlTGltaXREZWxheSA9IGRlbGF5TXM7XG5cdH1cbn1cbiIsICIvLyBzcmMvc2VydmljZXMvUXVldWVTZXJ2aWNlLnRzXG5pbXBvcnQgeyBWYXVsdCwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBUZXh0U3BsaXR0ZXIgfSBmcm9tICcuLi91dGlscy9UZXh0U3BsaXR0ZXInO1xuaW1wb3J0IHtcblx0UHJvY2Vzc2luZ1Rhc2ssXG5cdFRhc2tTdGF0dXMsXG5cdFRhc2tUeXBlLFxuXHRRdWV1ZVN0YXRzLFxuXHRUYXNrUHJvZ3Jlc3MsXG5cdFRhc2tQcm9jZXNzaW5nRXJyb3Jcbn0gZnJvbSAnLi4vbW9kZWxzL1Byb2Nlc3NpbmdUYXNrJztcbmltcG9ydCB7IEVycm9ySGFuZGxlciB9IGZyb20gJy4uL3V0aWxzL0Vycm9ySGFuZGxlcic7XG5pbXBvcnQgeyBOb3RpZmljYXRpb25NYW5hZ2VyIH0gZnJvbSAnLi4vdXRpbHMvTm90aWZpY2F0aW9uTWFuYWdlcic7XG5pbXBvcnQgeyBTdXBhYmFzZVNlcnZpY2UgfSBmcm9tICcuL1N1cGFiYXNlU2VydmljZSc7XG5pbXBvcnQgeyBPcGVuQUlTZXJ2aWNlIH0gZnJvbSAnLi9PcGVuQUlTZXJ2aWNlJztcbmltcG9ydCB7IERFRkFVTFRfQ0hVTktJTkdfT1BUSU9OUyB9IGZyb20gJy4uL3NldHRpbmdzL1NldHRpbmdzJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4vRXZlbnRFbWl0dGVyJztcblxuZXhwb3J0IGNsYXNzIFF1ZXVlU2VydmljZSB7XG5cdHByaXZhdGUgcXVldWU6IFByb2Nlc3NpbmdUYXNrW10gPSBbXTtcblx0cHJpdmF0ZSBwcm9jZXNzaW5nUXVldWU6IFByb2Nlc3NpbmdUYXNrW10gPSBbXTtcblx0cHJpdmF0ZSBpc1Byb2Nlc3Npbmc6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHJpdmF0ZSBpc1N0b3BwZWQ6IGJvb2xlYW4gPSB0cnVlO1xuXHRwcml2YXRlIHByb2Nlc3NpbmdJbnRlcnZhbDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSB0ZXh0U3BsaXR0ZXI6IFRleHRTcGxpdHRlcjtcblx0cHJpdmF0ZSB2YXVsdDogVmF1bHQ7XG5cdC8vIEV2ZW50IGVtaXR0ZXIgZm9yIHF1ZXVlIGV2ZW50c1xuXHRwcml2YXRlIGV2ZW50RW1pdHRlcjogRXZlbnRFbWl0dGVyO1xuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByaXZhdGUgbWF4Q29uY3VycmVudDogbnVtYmVyLFxuXHRcdHByaXZhdGUgbWF4UmV0cmllczogbnVtYmVyLFxuXHRcdHByaXZhdGUgc3VwYWJhc2VTZXJ2aWNlOiBTdXBhYmFzZVNlcnZpY2UgfCBudWxsLFxuXHRcdHByaXZhdGUgb3BlbkFJU2VydmljZTogT3BlbkFJU2VydmljZSB8IG51bGwsXG5cdFx0cHJpdmF0ZSBlcnJvckhhbmRsZXI6IEVycm9ySGFuZGxlcixcblx0XHRwcml2YXRlIG5vdGlmaWNhdGlvbk1hbmFnZXI6IE5vdGlmaWNhdGlvbk1hbmFnZXIsXG5cdFx0dmF1bHQ6IFZhdWx0LFxuXHRcdGNodW5rU2V0dGluZ3M/OiB7IGNodW5rU2l6ZTogbnVtYmVyOyBjaHVua092ZXJsYXA6IG51bWJlcjsgbWluQ2h1bmtTaXplOiBudW1iZXIgfVxuXHQpIHtcblx0XHR0aGlzLnZhdWx0ID0gdmF1bHQ7XG5cdFx0Y29uc3QgdmFsaWRhdGVkQ2h1bmtTZXR0aW5ncyA9IGNodW5rU2V0dGluZ3MgfHwgeyAuLi5ERUZBVUxUX0NIVU5LSU5HX09QVElPTlMgfTtcblx0XHR0cnkge1xuXHRcdFx0dGhpcy50ZXh0U3BsaXR0ZXIgPSBuZXcgVGV4dFNwbGl0dGVyKHZhbGlkYXRlZENodW5rU2V0dGluZ3MpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0XHRjb250ZXh0OiAnUXVldWVTZXJ2aWNlLmNvbnN0cnVjdG9yJyxcblx0XHRcdFx0bWV0YWRhdGE6IHZhbGlkYXRlZENodW5rU2V0dGluZ3MsXG5cdFx0XHR9KTtcblx0XHRcdHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgVGV4dFNwbGl0dGVyIHdpdGggcHJvdmlkZWQgc2V0dGluZ3MuJyk7XG5cdFx0fVxuXHRcdHRoaXMuZXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXHR9XG5cblx0cHVibGljIHN0YXJ0KCk6IHZvaWQge1xuXHRcdGlmICghdGhpcy5pc1N0b3BwZWQpIHJldHVybjtcblx0XHR0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuXHRcdHRoaXMucHJvY2Vzc1F1ZXVlKCk7XG5cdFx0dGhpcy5wcm9jZXNzaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG5cdFx0XHRpZiAoIXRoaXMuaXNQcm9jZXNzaW5nKSB7XG5cdFx0XHRcdHRoaXMucHJvY2Vzc1F1ZXVlKCk7XG5cdFx0XHR9XG5cdFx0fSwgMTAwMCk7XG5cdFx0Ly8gRW1pdCBpbml0aWFsIHF1ZXVlIHN0YXR1c1xuXHRcdHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3F1ZXVlLXN0YXR1cycsIHtcblx0XHRcdHF1ZXVlU2l6ZTogdGhpcy5xdWV1ZS5sZW5ndGgsXG5cdFx0XHRwZW5kaW5nQ2hhbmdlczogMCxcblx0XHRcdHByb2Nlc3NpbmdDb3VudDogdGhpcy5wcm9jZXNzaW5nUXVldWUubGVuZ3RoLFxuXHRcdFx0c3RhdHVzOiAncHJvY2Vzc2luZydcblx0XHR9KTtcblx0fVxuXG5cdHB1YmxpYyBzdG9wKCk6IHZvaWQge1xuXHRcdHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcblx0XHRpZiAodGhpcy5wcm9jZXNzaW5nSW50ZXJ2YWwpIHtcblx0XHRcdGNsZWFySW50ZXJ2YWwodGhpcy5wcm9jZXNzaW5nSW50ZXJ2YWwpO1xuXHRcdFx0dGhpcy5wcm9jZXNzaW5nSW50ZXJ2YWwgPSBudWxsO1xuXHRcdH1cblx0XHR0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdxdWV1ZS1zdGF0dXMnLCB7XG5cdFx0XHRxdWV1ZVNpemU6IHRoaXMucXVldWUubGVuZ3RoLFxuXHRcdFx0cGVuZGluZ0NoYW5nZXM6IDAsXG5cdFx0XHRwcm9jZXNzaW5nQ291bnQ6IHRoaXMucHJvY2Vzc2luZ1F1ZXVlLmxlbmd0aCxcblx0XHRcdHN0YXR1czogJ3BhdXNlZCdcblx0XHR9KTtcblx0fVxuXG5cdHB1YmxpYyBhc3luYyBhZGRUYXNrKHRhc2s6IFByb2Nlc3NpbmdUYXNrKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKHRoaXMucXVldWUubGVuZ3RoID49IDEwMDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihUYXNrUHJvY2Vzc2luZ0Vycm9yLlFVRVVFX0ZVTEwpO1xuXHRcdH1cblx0XHRjb25zb2xlLmxvZygnQWRkaW5nIHRhc2sgdG8gcXVldWU6JywgeyBpZDogdGFzay5pZCwgdHlwZTogdGFzay50eXBlLCBwcmlvcml0eTogdGFzay5wcmlvcml0eSB9KTtcblxuXHRcdC8vIENoZWNrIGZvciBkdXBsaWNhdGUgb3IgY29uZmxpY3RpbmcgdGFza3Mgb24gdGhlIHNhbWUgZmlsZS5cblx0XHRjb25zdCBleGlzdGluZ1Rhc2tJbmRleCA9IHRoaXMucXVldWUuZmluZEluZGV4KHQgPT4gdC5pZCA9PT0gdGFzay5pZCk7XG5cdFx0Y29uc3QgcHJvY2Vzc2luZ1Rhc2tJbmRleCA9IHRoaXMucHJvY2Vzc2luZ1F1ZXVlLmZpbmRJbmRleCh0ID0+IHQuaWQgPT09IHRhc2suaWQpO1xuXG5cdFx0aWYgKHRhc2sudHlwZSA9PT0gVGFza1R5cGUuREVMRVRFKSB7XG5cdFx0XHQvLyBERUxFVEUgdGFza3MgZ2V0IGhpZ2hlc3QgcHJpb3JpdHkuXG5cdFx0XHR0YXNrLnByaW9yaXR5ID0gMztcblx0XHRcdGlmIChwcm9jZXNzaW5nVGFza0luZGV4ID49IDApIHtcblx0XHRcdFx0Y29uc3QgcHJvY2Vzc2luZ1Rhc2sgPSB0aGlzLnByb2Nlc3NpbmdRdWV1ZVtwcm9jZXNzaW5nVGFza0luZGV4XTtcblx0XHRcdFx0aWYgKHByb2Nlc3NpbmdUYXNrLnR5cGUgIT09IFRhc2tUeXBlLkRFTEVURSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGBDb25mbGljdCBpbiBwcm9jZXNzaW5nIGZvciAke3Rhc2suaWR9LiBNYXJraW5nIGV4aXN0aW5nIHRhc2sgYXMgQ0FOQ0VMTEVELmApO1xuXHRcdFx0XHRcdHByb2Nlc3NpbmdUYXNrLnN0YXR1cyA9IFRhc2tTdGF0dXMuQ0FOQ0VMTEVEO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZXhpc3RpbmdUYXNrSW5kZXggPj0gMCkge1xuXHRcdFx0XHRjb25zdCBleGlzdGluZ1Rhc2sgPSB0aGlzLnF1ZXVlW2V4aXN0aW5nVGFza0luZGV4XTtcblx0XHRcdFx0aWYgKGV4aXN0aW5nVGFzay50eXBlID09PSBUYXNrVHlwZS5ERUxFVEUpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhgRHVwbGljYXRlIERFTEVURSB0YXNrIGZvciAke3Rhc2suaWR9LiBJZ25vcmluZy5gKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coYFJlcGxhY2luZyBleGlzdGluZyAke2V4aXN0aW5nVGFzay50eXBlfSB0YXNrIGZvciAke3Rhc2suaWR9IHdpdGggREVMRVRFIHRhc2suYCk7XG5cdFx0XHRcdFx0dGhpcy5xdWV1ZS5zcGxpY2UoZXhpc3RpbmdUYXNrSW5kZXgsIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBVbnNoaWZ0IHRvIHByaW9yaXRpemUgZGVsZXRpb25cblx0XHRcdHRoaXMucXVldWUudW5zaGlmdCh0YXNrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRm9yIENSRUFURS9VUERBVEUgdGFza3MsIGlmIGEgREVMRVRFIGlzIHBlbmRpbmcsIHNraXAgdGhlIHVwZGF0ZS5cblx0XHRcdGNvbnN0IGhhc0RlbGV0ZVRhc2sgPSB0aGlzLnF1ZXVlLnNvbWUodCA9PiB0LmlkID09PSB0YXNrLmlkICYmIHQudHlwZSA9PT0gVGFza1R5cGUuREVMRVRFKTtcblx0XHRcdGlmIChoYXNEZWxldGVUYXNrKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGBTa2lwcGluZyAke3Rhc2sudHlwZX0gZm9yICR7dGFzay5pZH0gYXMgREVMRVRFIGlzIHBlbmRpbmcuYCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmIChleGlzdGluZ1Rhc2tJbmRleCA+PSAwKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGBSZXBsYWNpbmcgZXhpc3RpbmcgdGFzayBmb3IgJHt0YXNrLmlkfSB3aXRoIG5ldyAke3Rhc2sudHlwZX0gdGFzay5gKTtcblx0XHRcdFx0dGhpcy5xdWV1ZVtleGlzdGluZ1Rhc2tJbmRleF0gPSB0YXNrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQWRkIGJhc2VkIG9uIHByaW9yaXR5LlxuXHRcdFx0XHRpZiAodGFzay5wcmlvcml0eSA+PSAyKSB7XG5cdFx0XHRcdFx0dGhpcy5xdWV1ZS51bnNoaWZ0KHRhc2spO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMucXVldWUucHVzaCh0YXNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEVtaXQgcHJvZ3Jlc3MgdXBkYXRlIGV2ZW50LlxuXHRcdHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3F1ZXVlLXByb2dyZXNzJywge1xuXHRcdFx0cHJvY2Vzc2VkOiAwLFxuXHRcdFx0dG90YWw6IHRoaXMucXVldWUubGVuZ3RoLFxuXHRcdFx0Y3VycmVudFRhc2s6IHRhc2suaWRcblx0XHR9KTtcblxuXHRcdGlmICghdGhpcy5pc1Byb2Nlc3NpbmcgJiYgIXRoaXMuaXNTdG9wcGVkKSB7XG5cdFx0XHR0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc1F1ZXVlKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICh0aGlzLmlzUHJvY2Vzc2luZyB8fCB0aGlzLmlzU3RvcHBlZCB8fCB0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLmlzUHJvY2Vzc2luZyA9IHRydWU7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFNvcnQgdGFza3MgYnkgcHJpb3JpdHksIHRoZW4gREVMRVRFIHRhc2tzLCB0aGVuIGJ5IGNyZWF0aW9uIHRpbWUuXG5cdFx0XHR0aGlzLnF1ZXVlLnNvcnQoKGEsIGIpID0+IHtcblx0XHRcdFx0aWYgKGIucHJpb3JpdHkgIT09IGEucHJpb3JpdHkpIHJldHVybiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eTtcblx0XHRcdFx0aWYgKGEudHlwZSA9PT0gVGFza1R5cGUuREVMRVRFICYmIGIudHlwZSAhPT0gVGFza1R5cGUuREVMRVRFKSByZXR1cm4gLTE7XG5cdFx0XHRcdGlmIChiLnR5cGUgPT09IFRhc2tUeXBlLkRFTEVURSAmJiBhLnR5cGUgIT09IFRhc2tUeXBlLkRFTEVURSkgcmV0dXJuIDE7XG5cdFx0XHRcdHJldHVybiBhLmNyZWF0ZWRBdCAtIGIuY3JlYXRlZEF0O1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEdyb3VwIHRhc2tzIGJ5IGZpbGUgaWQgdG8gcmVzb2x2ZSBjb2xsaXNpb25zLlxuXHRcdFx0Y29uc3QgdGFza3NCeUZpbGUgPSBuZXcgTWFwPHN0cmluZywgUHJvY2Vzc2luZ1Rhc2tbXT4oKTtcblx0XHRcdHRoaXMucXVldWUuZm9yRWFjaCh0YXNrID0+IHtcblx0XHRcdFx0aWYgKCF0YXNrc0J5RmlsZS5oYXModGFzay5pZCkpIHtcblx0XHRcdFx0XHR0YXNrc0J5RmlsZS5zZXQodGFzay5pZCwgW10pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRhc2tzQnlGaWxlLmdldCh0YXNrLmlkKSEucHVzaCh0YXNrKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRsZXQgdGFza3NUb1Byb2Nlc3M6IFByb2Nlc3NpbmdUYXNrW10gPSBbXTtcblx0XHRcdGZvciAoY29uc3QgW2ZpbGVJZCwgZmlsZVRhc2tzXSBvZiB0YXNrc0J5RmlsZS5lbnRyaWVzKCkpIHtcblx0XHRcdFx0aWYgKGZpbGVUYXNrcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coYERldGVjdGVkICR7ZmlsZVRhc2tzLmxlbmd0aH0gdGFza3MgZm9yICR7ZmlsZUlkfSwgcmVzb2x2aW5nIGNvbGxpc2lvbnMuYCk7XG5cdFx0XHRcdFx0Y29uc3QgZGVsZXRlVGFzayA9IGZpbGVUYXNrcy5maW5kKHQgPT4gdC50eXBlID09PSBUYXNrVHlwZS5ERUxFVEUpO1xuXHRcdFx0XHRcdGlmIChkZWxldGVUYXNrKSB7XG5cdFx0XHRcdFx0XHR0YXNrc1RvUHJvY2Vzcy5wdXNoKGRlbGV0ZVRhc2spO1xuXHRcdFx0XHRcdFx0dGhpcy5xdWV1ZSA9IHRoaXMucXVldWUuZmlsdGVyKHQgPT4gdC5pZCAhPT0gZmlsZUlkKTtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGBLZWVwaW5nIG9ubHkgREVMRVRFIHRhc2sgZm9yICR7ZmlsZUlkfWApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zdCBtb3N0UmVjZW50VGFzayA9IGZpbGVUYXNrcy5yZWR1Y2UoKGxhdGVzdCwgY3VycmVudCkgPT5cblx0XHRcdFx0XHRcdFx0Y3VycmVudC51cGRhdGVkQXQgPiBsYXRlc3QudXBkYXRlZEF0ID8gY3VycmVudCA6IGxhdGVzdCwgZmlsZVRhc2tzWzBdKTtcblx0XHRcdFx0XHRcdHRhc2tzVG9Qcm9jZXNzLnB1c2gobW9zdFJlY2VudFRhc2spO1xuXHRcdFx0XHRcdFx0dGhpcy5xdWV1ZSA9IHRoaXMucXVldWUuZmlsdGVyKHQgPT4gdC5pZCAhPT0gZmlsZUlkIHx8IHQgPT09IG1vc3RSZWNlbnRUYXNrKTtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGBLZWVwaW5nIG1vc3QgcmVjZW50IHRhc2sgZm9yICR7ZmlsZUlkfWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGaWxsIHRhc2tzVG9Qcm9jZXNzIHdpdGggcmVtYWluaW5nIHRhc2tzIHVudGlsIHdlIGhpdCB0aGUgY29uY3VycmVuY3kgbGltaXQuXG5cdFx0XHRmb3IgKGNvbnN0IHRhc2sgb2YgdGhpcy5xdWV1ZSkge1xuXHRcdFx0XHRpZiAodGFza3NUb1Byb2Nlc3Muc29tZSh0ID0+IHQuaWQgPT09IHRhc2suaWQpKSBjb250aW51ZTtcblx0XHRcdFx0dGFza3NUb1Byb2Nlc3MucHVzaCh0YXNrKTtcblx0XHRcdFx0aWYgKHRhc2tzVG9Qcm9jZXNzLmxlbmd0aCArIHRoaXMucHJvY2Vzc2luZ1F1ZXVlLmxlbmd0aCA+PSB0aGlzLm1heENvbmN1cnJlbnQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgc2VsZWN0ZWQgdGFza3MgZnJvbSB0aGUgbWFpbiBxdWV1ZS5cblx0XHRcdGZvciAoY29uc3QgdGFzayBvZiB0YXNrc1RvUHJvY2Vzcykge1xuXHRcdFx0XHRjb25zdCBpbmRleCA9IHRoaXMucXVldWUuaW5kZXhPZih0YXNrKTtcblx0XHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdHRoaXMucXVldWUuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBQcm9jZXNzIHNlbGVjdGVkIHRhc2tzLlxuXHRcdFx0Zm9yIChjb25zdCB0YXNrIG9mIHRhc2tzVG9Qcm9jZXNzKSB7XG5cdFx0XHRcdGlmICh0aGlzLnByb2Nlc3NpbmdRdWV1ZS5sZW5ndGggPj0gdGhpcy5tYXhDb25jdXJyZW50KSB7XG5cdFx0XHRcdFx0dGhpcy5xdWV1ZS51bnNoaWZ0KHRhc2spO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucHJvY2Vzc2luZ1F1ZXVlLnB1c2godGFzayk7XG5cdFx0XHRcdHRoaXMucHJvY2Vzc1Rhc2sodGFzaykuY2F0Y2goZXJyb3IgPT4ge1xuXHRcdFx0XHRcdHRoaXMuaGFuZGxlVGFza0Vycm9yKHRhc2ssIGVycm9yKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3F1ZXVlLXN0YXR1cycsIHtcblx0XHRcdFx0cXVldWVTaXplOiB0aGlzLnF1ZXVlLmxlbmd0aCxcblx0XHRcdFx0cGVuZGluZ0NoYW5nZXM6IHRoaXMucXVldWUubGVuZ3RoICsgdGhpcy5wcm9jZXNzaW5nUXVldWUubGVuZ3RoLFxuXHRcdFx0XHRwcm9jZXNzaW5nQ291bnQ6IHRoaXMucHJvY2Vzc2luZ1F1ZXVlLmxlbmd0aCxcblx0XHRcdFx0c3RhdHVzOiAncHJvY2Vzc2luZydcblx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnUXVldWVTZXJ2aWNlLnByb2Nlc3NRdWV1ZScgfSk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG5cdFx0XHRpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwICYmICF0aGlzLmlzU3RvcHBlZCkge1xuXHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHRoaXMucHJvY2Vzc1F1ZXVlKCksIDEwMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBwcm9jZXNzVGFzayh0YXNrOiBQcm9jZXNzaW5nVGFzayk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIHRhc2s6JywgeyBpZDogdGFzay5pZCwgdHlwZTogdGFzay50eXBlLCBzdGF0dXM6IHRhc2suc3RhdHVzIH0pO1xuXHRcdHRyeSB7XG5cdFx0XHR0YXNrLnN0YXR1cyA9IFRhc2tTdGF0dXMuUFJPQ0VTU0lORztcblx0XHRcdHRhc2suc3RhcnRlZEF0ID0gRGF0ZS5ub3coKTtcblx0XHRcdHRoaXMubm90aWZ5UHJvZ3Jlc3ModGFzay5pZCwgMCwgYFN0YXJ0aW5nICR7dGFzay50eXBlLnRvTG93ZXJDYXNlKCl9YCk7XG5cdFx0XHRzd2l0Y2ggKHRhc2sudHlwZSkge1xuXHRcdFx0XHRjYXNlIFRhc2tUeXBlLkNSRUFURTpcblx0XHRcdFx0Y2FzZSBUYXNrVHlwZS5VUERBVEU6XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wcm9jZXNzQ3JlYXRlVXBkYXRlVGFzayh0YXNrKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBUYXNrVHlwZS5ERUxFVEU6XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wcm9jZXNzRGVsZXRlVGFzayh0YXNrKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHRhc2sgdHlwZTogJHt0YXNrLnR5cGV9YCk7XG5cdFx0XHR9XG5cdFx0XHR0YXNrLnN0YXR1cyA9IFRhc2tTdGF0dXMuQ09NUExFVEVEO1xuXHRcdFx0dGFzay5jb21wbGV0ZWRBdCA9IERhdGUubm93KCk7XG5cdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDEwMCwgJ1Rhc2sgY29tcGxldGVkJyk7XG5cdFx0XHRjb25zb2xlLmxvZygnVGFzayBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5OicsIHRhc2suaWQpO1xuXHRcdFx0dGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgncXVldWUtcHJvZ3Jlc3MnLCB7XG5cdFx0XHRcdHByb2Nlc3NlZDogMSxcblx0XHRcdFx0dG90YWw6IHRoaXMucXVldWUubGVuZ3RoICsgMSxcblx0XHRcdFx0Y3VycmVudFRhc2s6IHRhc2suaWRcblx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBwcm9jZXNzaW5nIHRhc2s6JywgeyB0YXNrSWQ6IHRhc2suaWQsIGVycm9yIH0pO1xuXHRcdFx0YXdhaXQgdGhpcy5oYW5kbGVUYXNrRXJyb3IodGFzaywgZXJyb3IpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0aGlzLnJlbW92ZUZyb21Qcm9jZXNzaW5nUXVldWUodGFzayk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBwcm9jZXNzQ3JlYXRlVXBkYXRlVGFzayh0YXNrOiBQcm9jZXNzaW5nVGFzayk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghdGhpcy5zdXBhYmFzZVNlcnZpY2UgfHwgIXRoaXMub3BlbkFJU2VydmljZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBzZXJ2aWNlcyBub3QgaW5pdGlhbGl6ZWQnKTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnNvbGUubG9nKCdSZWFkaW5nIGZpbGU6JywgdGFzay5pZCk7XG5cdFx0XHRjb25zdCBmaWxlID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGFzay5pZCk7XG5cdFx0XHRpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgRmlsZSBub3QgZm91bmQgb3Igbm90IGEgVEZpbGU6ICR7dGFzay5pZH1gKTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHRpbWluZ3MgPSB7XG5cdFx0XHRcdHN0YXJ0OiBEYXRlLm5vdygpLFxuXHRcdFx0XHRyZWFkQ29tcGxldGU6IDAsXG5cdFx0XHRcdGNodW5raW5nQ29tcGxldGU6IDAsXG5cdFx0XHRcdGVtYmVkZGluZ0NvbXBsZXRlOiAwLFxuXHRcdFx0XHRzYXZlQ29tcGxldGU6IDBcblx0XHRcdH07XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkKGZpbGUpO1xuXHRcdFx0dGltaW5ncy5yZWFkQ29tcGxldGUgPSBEYXRlLm5vdygpO1xuXHRcdFx0Y29uc29sZS5sb2coJ0ZpbGUgY29udGVudCByZWFkOicsIHtcblx0XHRcdFx0ZmlsZUlkOiB0YXNrLmlkLFxuXHRcdFx0XHRjb250ZW50TGVuZ3RoOiBjb250ZW50Lmxlbmd0aCxcblx0XHRcdFx0cmVhZFRpbWU6IHRpbWluZ3MucmVhZENvbXBsZXRlIC0gdGltaW5ncy5zdGFydFxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDIwLCAnU3BsaXR0aW5nIGNvbnRlbnQnKTtcblx0XHRcdGNvbnN0IGNodW5rcyA9IGF3YWl0IHRoaXMudGV4dFNwbGl0dGVyLnNwbGl0RG9jdW1lbnQoY29udGVudCwgdGFzay5tZXRhZGF0YSk7XG5cdFx0XHR0aW1pbmdzLmNodW5raW5nQ29tcGxldGUgPSBEYXRlLm5vdygpO1xuXHRcdFx0aWYgKCFjaHVua3MgfHwgIUFycmF5LmlzQXJyYXkoY2h1bmtzKSB8fCBjaHVua3MubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdObyB2YWxpZCBjaHVua3MgY3JlYXRlZCBmb3IgZmlsZTonLCB7XG5cdFx0XHRcdFx0ZmlsZUlkOiB0YXNrLmlkLFxuXHRcdFx0XHRcdGNvbnRlbnRMZW5ndGg6IGNvbnRlbnQubGVuZ3RoLFxuXHRcdFx0XHRcdHNldHRpbmdzOiB0aGlzLnRleHRTcGxpdHRlci5nZXRTZXR0aW5ncygpXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAodGhpcy5zdXBhYmFzZVNlcnZpY2UpIHtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS51cGRhdGVGaWxlVmVjdG9yaXphdGlvblN0YXR1cyh0YXNrLm1ldGFkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjb25zb2xlLmxvZygnQ29udGVudCBzcGxpdCBpbnRvIGNodW5rczonLCB7XG5cdFx0XHRcdG51bWJlck9mQ2h1bmtzOiBjaHVua3MubGVuZ3RoLFxuXHRcdFx0XHRjaHVua1NpemVzOiBjaHVua3MubWFwKGMgPT4gYy5jb250ZW50Lmxlbmd0aCksXG5cdFx0XHRcdGNodW5raW5nVGltZTogdGltaW5ncy5jaHVua2luZ0NvbXBsZXRlIC0gdGltaW5ncy5yZWFkQ29tcGxldGVcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCA0MCwgJ0dlbmVyYXRpbmcgZW1iZWRkaW5ncycpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgZW1iZWRQcm9ncmVzcyA9IE1hdGguZmxvb3IoNDAgKyAoaSAvIGNodW5rcy5sZW5ndGgpICogMzApO1xuXHRcdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIGVtYmVkUHJvZ3Jlc3MsIGBHZW5lcmF0aW5nIGVtYmVkZGluZyAke2kgKyAxfS8ke2NodW5rcy5sZW5ndGh9YCk7XG5cdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5vcGVuQUlTZXJ2aWNlLmNyZWF0ZUVtYmVkZGluZ3MoW2NodW5rc1tpXS5jb250ZW50XSk7XG5cdFx0XHRcdGlmIChyZXNwb25zZS5sZW5ndGggPiAwICYmIHJlc3BvbnNlWzBdLmRhdGEubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdGNodW5rc1tpXS5lbWJlZGRpbmcgPSByZXNwb25zZVswXS5kYXRhWzBdLmVtYmVkZGluZztcblx0XHRcdFx0XHRjaHVua3NbaV0udmVjdG9yaXplZF9hdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhgR2VuZXJhdGVkIGVtYmVkZGluZyBmb3IgY2h1bmsgJHtpICsgMX0vJHtjaHVua3MubGVuZ3RofWApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdlbmVyYXRlIGVtYmVkZGluZyBmb3IgY2h1bmsgJHtpICsgMX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGltaW5ncy5lbWJlZGRpbmdDb21wbGV0ZSA9IERhdGUubm93KCk7XG5cdFx0XHRjb25zdCBlbmhhbmNlZENodW5rcyA9IGNodW5rcy5tYXAoY2h1bmsgPT4gKHtcblx0XHRcdFx0Li4uY2h1bmssXG5cdFx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdFx0Li4uY2h1bmsubWV0YWRhdGEsXG5cdFx0XHRcdFx0YWxpYXNlczogY2h1bmsubWV0YWRhdGEuYWxpYXNlcyB8fCBbXSxcblx0XHRcdFx0XHRsaW5rczogY2h1bmsubWV0YWRhdGEubGlua3MgfHwgW10sXG5cdFx0XHRcdFx0dGFnczogY2h1bmsubWV0YWRhdGEudGFncyB8fCBbXVxuXHRcdFx0XHR9XG5cdFx0XHR9KSk7XG5cdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDcwLCAnU2F2aW5nIHRvIGRhdGFiYXNlJyk7XG5cdFx0XHRsZXQgc2F2ZUF0dGVtcHRzID0gMDtcblx0XHRcdGNvbnN0IG1heFNhdmVBdHRlbXB0cyA9IDM7XG5cdFx0XHRsZXQgc2F2ZWRTdWNjZXNzZnVsbHkgPSBmYWxzZTtcblx0XHRcdHdoaWxlICghc2F2ZWRTdWNjZXNzZnVsbHkgJiYgc2F2ZUF0dGVtcHRzIDwgbWF4U2F2ZUF0dGVtcHRzKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UudXBzZXJ0Q2h1bmtzKGVuaGFuY2VkQ2h1bmtzKTtcblx0XHRcdFx0XHRzYXZlZFN1Y2Nlc3NmdWxseSA9IHRydWU7XG5cdFx0XHRcdH0gY2F0Y2ggKHNhdmVFcnJvcikge1xuXHRcdFx0XHRcdHNhdmVBdHRlbXB0cysrO1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoYEVycm9yIHNhdmluZyBjaHVua3MgKGF0dGVtcHQgJHtzYXZlQXR0ZW1wdHN9LyR7bWF4U2F2ZUF0dGVtcHRzfSk6YCwgc2F2ZUVycm9yKTtcblx0XHRcdFx0XHRpZiAoc2F2ZUF0dGVtcHRzID49IG1heFNhdmVBdHRlbXB0cykgdGhyb3cgc2F2ZUVycm9yO1xuXHRcdFx0XHRcdGNvbnN0IGJhY2tvZmZUaW1lID0gTWF0aC5wb3coMiwgc2F2ZUF0dGVtcHRzKSAqIDEwMDA7XG5cdFx0XHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCA3MCwgYFJldHJ5aW5nIGRhdGFiYXNlIHNhdmUgaW4gJHtiYWNrb2ZmVGltZSAvIDEwMDB9c2ApO1xuXHRcdFx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBiYWNrb2ZmVGltZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aW1pbmdzLnNhdmVDb21wbGV0ZSA9IERhdGUubm93KCk7XG5cdFx0XHRjb25zb2xlLmxvZygnQ2h1bmtzIHNhdmVkIHRvIGRhdGFiYXNlOicsIHtcblx0XHRcdFx0bnVtYmVyT2ZDaHVua3M6IGVuaGFuY2VkQ2h1bmtzLmxlbmd0aCxcblx0XHRcdFx0ZmlsZUlkOiB0YXNrLmlkLFxuXHRcdFx0XHR0aW1pbmdzOiB7XG5cdFx0XHRcdFx0dG90YWw6IHRpbWluZ3Muc2F2ZUNvbXBsZXRlIC0gdGltaW5ncy5zdGFydCxcblx0XHRcdFx0XHRyZWFkOiB0aW1pbmdzLnJlYWRDb21wbGV0ZSAtIHRpbWluZ3Muc3RhcnQsXG5cdFx0XHRcdFx0Y2h1bmtpbmc6IHRpbWluZ3MuY2h1bmtpbmdDb21wbGV0ZSAtIHRpbWluZ3MucmVhZENvbXBsZXRlLFxuXHRcdFx0XHRcdGVtYmVkZGluZzogdGltaW5ncy5lbWJlZGRpbmdDb21wbGV0ZSAtIHRpbWluZ3MuY2h1bmtpbmdDb21wbGV0ZSxcblx0XHRcdFx0XHRzYXZlOiB0aW1pbmdzLnNhdmVDb21wbGV0ZSAtIHRpbWluZ3MuZW1iZWRkaW5nQ29tcGxldGVcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDEwMCwgJ1Byb2Nlc3NpbmcgY29tcGxldGVkJyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHByb2Nlc3NDcmVhdGVVcGRhdGVUYXNrOicsIHsgZXJyb3IsIHRhc2tJZDogdGFzay5pZCwgbWV0YWRhdGE6IHRhc2subWV0YWRhdGEgfSk7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIHByb2Nlc3NEZWxldGVUYXNrKHRhc2s6IFByb2Nlc3NpbmdUYXNrKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCF0aGlzLnN1cGFiYXNlU2VydmljZSkgdGhyb3cgbmV3IEVycm9yKCdTdXBhYmFzZSBzZXJ2aWNlIG5vdCBpbml0aWFsaXplZCcpO1xuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDEwLCAnU3RhcnRpbmcgZGVsZXRpb24gcHJvY2VzcycpO1xuXHRcdFx0Y29uc29sZS5sb2coYENoZWNraW5nIGRvY3VtZW50IGJlZm9yZSBkZWxldGlvbjogJHt0YXNrLm1ldGFkYXRhLm9ic2lkaWFuSWR9YCk7XG5cdFx0XHRjb25zdCBjaHVua3MgPSBhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS5nZXREb2N1bWVudENodW5rcyh0YXNrLm1ldGFkYXRhLm9ic2lkaWFuSWQpO1xuXHRcdFx0Y29uc3QgY2h1bmtDb3VudCA9IGNodW5rcy5sZW5ndGg7XG5cdFx0XHRpZiAoY2h1bmtDb3VudCA+IDApIHtcblx0XHRcdFx0Y29uc29sZS5sb2coYEZvdW5kICR7Y2h1bmtDb3VudH0gY2h1bmtzIHRvIGRlbGV0ZSBmb3IgJHt0YXNrLm1ldGFkYXRhLm9ic2lkaWFuSWR9YCk7XG5cdFx0XHRcdHRoaXMubm90aWZ5UHJvZ3Jlc3ModGFzay5pZCwgMzAsIGBEZWxldGluZyAke2NodW5rQ291bnR9IGNodW5rc2ApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS5sb2coYE5vIGNodW5rcyBmb3VuZCBmb3IgZGVsZXRpb246ICR7dGFzay5tZXRhZGF0YS5vYnNpZGlhbklkfWApO1xuXHRcdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDMwLCAnTm8gY2h1bmtzIHRvIGRlbGV0ZScpO1xuXHRcdFx0fVxuXHRcdFx0bGV0IGRlbGV0ZUF0dGVtcHRzID0gMDtcblx0XHRcdGNvbnN0IG1heERlbGV0ZUF0dGVtcHRzID0gMztcblx0XHRcdGxldCBkZWxldGVkU3VjY2Vzc2Z1bGx5ID0gZmFsc2U7XG5cdFx0XHR3aGlsZSAoIWRlbGV0ZWRTdWNjZXNzZnVsbHkgJiYgZGVsZXRlQXR0ZW1wdHMgPCBtYXhEZWxldGVBdHRlbXB0cykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHRoaXMubm90aWZ5UHJvZ3Jlc3ModGFzay5pZCwgNTAsIGRlbGV0ZUF0dGVtcHRzID4gMCA/IGBEZWxldGlvbiBhdHRlbXB0ICR7ZGVsZXRlQXR0ZW1wdHMgKyAxfS8ke21heERlbGV0ZUF0dGVtcHRzfWAgOiAnRGVsZXRpbmcgZnJvbSBkYXRhYmFzZScpO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLmRlbGV0ZURvY3VtZW50Q2h1bmtzKHRhc2subWV0YWRhdGEub2JzaWRpYW5JZCk7XG5cdFx0XHRcdFx0ZGVsZXRlZFN1Y2Nlc3NmdWxseSA9IHRydWU7XG5cdFx0XHRcdFx0Y29uc3QgcmVtYWluaW5nQ2h1bmtzID0gYXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UuZ2V0RG9jdW1lbnRDaHVua3ModGFzay5tZXRhZGF0YS5vYnNpZGlhbklkKTtcblx0XHRcdFx0XHRpZiAocmVtYWluaW5nQ2h1bmtzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybihgRGVsZXRpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogJHtyZW1haW5pbmdDaHVua3MubGVuZ3RofSBjaHVua3Mgc3RpbGwgZXhpc3RgKTtcblx0XHRcdFx0XHRcdGRlbGV0ZWRTdWNjZXNzZnVsbHkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgRGVsZXRpb24gdmVyaWZpY2F0aW9uIGZhaWxlZCBmb3IgJHt0YXNrLm1ldGFkYXRhLm9ic2lkaWFuSWR9YCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChkZWxldGVFcnJvcikge1xuXHRcdFx0XHRcdGRlbGV0ZUF0dGVtcHRzKys7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihgRXJyb3IgZGVsZXRpbmcgY2h1bmtzIChhdHRlbXB0ICR7ZGVsZXRlQXR0ZW1wdHN9LyR7bWF4RGVsZXRlQXR0ZW1wdHN9KTpgLCBkZWxldGVFcnJvcik7XG5cdFx0XHRcdFx0aWYgKGRlbGV0ZUF0dGVtcHRzID49IG1heERlbGV0ZUF0dGVtcHRzKSB0aHJvdyBkZWxldGVFcnJvcjtcblx0XHRcdFx0XHRjb25zdCBiYWNrb2ZmVGltZSA9IE1hdGgucG93KDIsIGRlbGV0ZUF0dGVtcHRzKSAqIDEwMDA7XG5cdFx0XHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCA1MCwgYFdpbGwgcmV0cnkgZGVsZXRpb24gaW4gJHtiYWNrb2ZmVGltZSAvIDEwMDB9c2ApO1xuXHRcdFx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBiYWNrb2ZmVGltZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDgwLCAnVXBkYXRpbmcgZmlsZSBzdGF0dXMnKTtcblx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLnVwZGF0ZUZpbGVTdGF0dXNPbkRlbGV0ZSh0YXNrLm1ldGFkYXRhLm9ic2lkaWFuSWQpO1xuXHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCAxMDAsICdEZWxldGUgY29tcGxldGVkJyk7XG5cdFx0XHRjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGRlbGV0ZWQgZG9jdW1lbnQ6ICR7dGFzay5tZXRhZGF0YS5vYnNpZGlhbklkfWApO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBpbiBwcm9jZXNzRGVsZXRlVGFzazonLCB7IGVycm9yLCB0YXNrSWQ6IHRhc2suaWQsIG1ldGFkYXRhOiB0YXNrLm1ldGFkYXRhIH0pO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBoYW5kbGVUYXNrRXJyb3IodGFzazogUHJvY2Vzc2luZ1Rhc2ssIGVycm9yOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0YXNrLnJldHJ5Q291bnQgPSAodGFzay5yZXRyeUNvdW50IHx8IDApICsgMTtcblx0XHR0YXNrLnVwZGF0ZWRBdCA9IERhdGUubm93KCk7XG5cdFx0aWYgKHRhc2sucmV0cnlDb3VudCA8IHRoaXMubWF4UmV0cmllcykge1xuXHRcdFx0dGFzay5zdGF0dXMgPSBUYXNrU3RhdHVzLlJFVFJZSU5HO1xuXHRcdFx0dGhpcy5xdWV1ZS51bnNoaWZ0KHRhc2spO1xuXHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCAwLCBgUmV0cnkgYXR0ZW1wdCAke3Rhc2sucmV0cnlDb3VudH1gKTtcblx0XHRcdGNvbnNvbGUubG9nKCdUYXNrIHF1ZXVlZCBmb3IgcmV0cnk6JywgeyB0YXNrSWQ6IHRhc2suaWQsIHJldHJ5Q291bnQ6IHRhc2sucmV0cnlDb3VudCwgbWF4UmV0cmllczogdGhpcy5tYXhSZXRyaWVzIH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXNrLnN0YXR1cyA9IFRhc2tTdGF0dXMuRkFJTEVEO1xuXHRcdFx0dGFzay5lcnJvciA9IHtcblx0XHRcdFx0bWVzc2FnZTogZXJyb3IubWVzc2FnZSxcblx0XHRcdFx0Y29kZTogZXJyb3IuY29kZSB8fCAnVU5LTk9XTl9FUlJPUicsXG5cdFx0XHRcdHN0YWNrOiBlcnJvci5zdGFjayxcblx0XHRcdH07XG5cdFx0XHR0YXNrLmNvbXBsZXRlZEF0ID0gRGF0ZS5ub3coKTtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1Rhc2sgZmFpbGVkIGFmdGVyIG1heCByZXRyaWVzOicsIHsgdGFza0lkOiB0YXNrLmlkLCBlcnJvcjogdGFzay5lcnJvciB9KTtcblx0XHR9XG5cdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1F1ZXVlU2VydmljZS5wcm9jZXNzVGFzaycsIHRhc2tJZDogdGFzay5pZCwgdGFza1R5cGU6IHRhc2sudHlwZSB9KTtcblx0XHR0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdxdWV1ZS1wcm9ncmVzcycsIHsgcHJvY2Vzc2VkOiAwLCB0b3RhbDogdGhpcy5xdWV1ZS5sZW5ndGgsIGN1cnJlbnRUYXNrOiB0YXNrLmlkIH0pO1xuXHR9XG5cblx0cHJpdmF0ZSByZW1vdmVGcm9tUHJvY2Vzc2luZ1F1ZXVlKHRhc2s6IFByb2Nlc3NpbmdUYXNrKTogdm9pZCB7XG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLnByb2Nlc3NpbmdRdWV1ZS5maW5kSW5kZXgodCA9PiB0LmlkID09PSB0YXNrLmlkKTtcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHR0aGlzLnByb2Nlc3NpbmdRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgbm90aWZ5UHJvZ3Jlc3ModGFza0lkOiBzdHJpbmcsIHByb2dyZXNzOiBudW1iZXIsIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuXHRcdHRoaXMubm90aWZpY2F0aW9uTWFuYWdlci51cGRhdGVQcm9ncmVzcyh7XG5cdFx0XHR0YXNrSWQsXG5cdFx0XHRwcm9ncmVzcyxcblx0XHRcdGN1cnJlbnRTdGVwOiBtZXNzYWdlLFxuXHRcdFx0dG90YWxTdGVwczogMSxcblx0XHRcdGN1cnJlbnRTdGVwTnVtYmVyOiAxLFxuXHRcdH0pO1xuXHRcdHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3F1ZXVlLXByb2dyZXNzJywgeyBwcm9jZXNzZWQ6IHByb2dyZXNzLCB0b3RhbDogMTAwLCBjdXJyZW50VGFzazogdGFza0lkIH0pO1xuXHR9XG5cblx0cHVibGljIGdldFF1ZXVlU3RhdHMoKTogUXVldWVTdGF0cyB7XG5cdFx0Y29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblx0XHRjb25zdCBvbmVIb3VyID0gNjAgKiA2MCAqIDEwMDA7XG5cdFx0Y29uc3QgdGFza3NCeVN0YXR1cyA9IHRoaXMucXVldWUucmVkdWNlKChhY2MsIHRhc2spID0+IHtcblx0XHRcdGFjY1t0YXNrLnN0YXR1c10gPSAoYWNjW3Rhc2suc3RhdHVzXSB8fCAwKSArIDE7XG5cdFx0XHRyZXR1cm4gYWNjO1xuXHRcdH0sIHt9IGFzIFJlY29yZDxUYXNrU3RhdHVzLCBudW1iZXI+KTtcblx0XHRjb25zdCB0YXNrc0J5VHlwZSA9IHRoaXMucXVldWUucmVkdWNlKChhY2MsIHRhc2spID0+IHtcblx0XHRcdGFjY1t0YXNrLnR5cGVdID0gKGFjY1t0YXNrLnR5cGVdIHx8IDApICsgMTtcblx0XHRcdHJldHVybiBhY2M7XG5cdFx0fSwge30gYXMgUmVjb3JkPFRhc2tUeXBlLCBudW1iZXI+KTtcblx0XHRjb25zdCBjb21wbGV0ZWRUYXNrcyA9IHRoaXMucXVldWUuZmlsdGVyKHRhc2sgPT4gdGFzay5zdGF0dXMgPT09IFRhc2tTdGF0dXMuQ09NUExFVEVEICYmIHRhc2suY29tcGxldGVkQXQpO1xuXHRcdGNvbnN0IGF2ZXJhZ2VUaW1lID0gY29tcGxldGVkVGFza3MubGVuZ3RoID4gMFxuXHRcdFx0PyBjb21wbGV0ZWRUYXNrcy5yZWR1Y2UoKHN1bSwgdGFzaykgPT4gc3VtICsgKHRhc2suY29tcGxldGVkQXQhIC0gdGFzay5zdGFydGVkQXQhKSwgMCkgLyBjb21wbGV0ZWRUYXNrcy5sZW5ndGhcblx0XHRcdDogMDtcblx0XHRjb25zdCB0YXNrc0xhc3RIb3VyID0gY29tcGxldGVkVGFza3MuZmlsdGVyKHRhc2sgPT4gdGFzay5jb21wbGV0ZWRBdCEgPiBub3cgLSBvbmVIb3VyKS5sZW5ndGg7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvdGFsVGFza3M6IHRoaXMucXVldWUubGVuZ3RoLFxuXHRcdFx0dGFza3NCeVN0YXR1cyxcblx0XHRcdHRhc2tzQnlUeXBlLFxuXHRcdFx0YXZlcmFnZVByb2Nlc3NpbmdUaW1lOiBhdmVyYWdlVGltZSxcblx0XHRcdGZhaWxlZFRhc2tzOiB0YXNrc0J5U3RhdHVzW1Rhc2tTdGF0dXMuRkFJTEVEXSB8fCAwLFxuXHRcdFx0cmV0cnlpbmdUYXNrczogdGFza3NCeVN0YXR1c1tUYXNrU3RhdHVzLlJFVFJZSU5HXSB8fCAwLFxuXHRcdFx0dGFza3NMYXN0SG91cixcblx0XHR9O1xuXHR9XG5cblx0cHVibGljIGNsZWFyKCk6IHZvaWQge1xuXHRcdHRoaXMucXVldWUgPSBbXTtcblx0XHR0aGlzLnByb2Nlc3NpbmdRdWV1ZSA9IFtdO1xuXHRcdHRoaXMubm90aWZpY2F0aW9uTWFuYWdlci5jbGVhcigpO1xuXHR9XG5cblx0cHVibGljIHVwZGF0ZVNldHRpbmdzKHNldHRpbmdzOiB7IG1heENvbmN1cnJlbnQ6IG51bWJlcjsgbWF4UmV0cmllczogbnVtYmVyOyBjaHVua1NldHRpbmdzPzogeyBjaHVua1NpemU6IG51bWJlcjsgY2h1bmtPdmVybGFwOiBudW1iZXI7IG1pbkNodW5rU2l6ZTogbnVtYmVyIH0gfSk6IHZvaWQge1xuXHRcdHRoaXMubWF4Q29uY3VycmVudCA9IHNldHRpbmdzLm1heENvbmN1cnJlbnQ7XG5cdFx0dGhpcy5tYXhSZXRyaWVzID0gc2V0dGluZ3MubWF4UmV0cmllcztcblx0XHRpZiAoc2V0dGluZ3MuY2h1bmtTZXR0aW5ncykge1xuXHRcdFx0dGhpcy50ZXh0U3BsaXR0ZXIgPSBuZXcgVGV4dFNwbGl0dGVyKHNldHRpbmdzLmNodW5rU2V0dGluZ3MpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJzY3JpYmUgdG8gcXVldWUgZXZlbnRzLlxuXHQgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCB0byBzdWJzY3JpYmUgdG8uXG5cdCAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRwdWJsaWMgb248VCBleHRlbmRzIGtleW9mIGFueT4oZXZlbnROYW1lOiBULCBjYWxsYmFjazogKGRhdGE6IGFueSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xuXHRcdHJldHVybiB0aGlzLmV2ZW50RW1pdHRlci5vbihldmVudE5hbWUgYXMgYW55LCBjYWxsYmFjayk7XG5cdH1cbn1cbiIsICIvLyBzcmMvc2VydmljZXMvTWV0YWRhdGFFeHRyYWN0b3IudHNcbmltcG9ydCB7IFRGaWxlLCBwYXJzZVlhbWwgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBEb2N1bWVudE1ldGFkYXRhLCBEb2N1bWVudFByb2Nlc3NpbmdFcnJvciB9IGZyb20gJy4uL21vZGVscy9Eb2N1bWVudENodW5rJztcblxuZXhwb3J0IGNsYXNzIE1ldGFkYXRhRXh0cmFjdG9yIHtcblx0LyoqXG5cdCAqIEV4dHJhY3RzIGFsbCBtZXRhZGF0YSBmcm9tIGFuIE9ic2lkaWFuIGZpbGVcblx0ICovXG5cdHB1YmxpYyBhc3luYyBleHRyYWN0TWV0YWRhdGEoZmlsZTogVEZpbGUsIGNvbnRlbnQ/OiBzdHJpbmcpOiBQcm9taXNlPERvY3VtZW50TWV0YWRhdGE+IHtcblx0XHRjb25zdCBmaWxlQ29udGVudCA9IGNvbnRlbnQgfHwgYXdhaXQgZmlsZS52YXVsdC5yZWFkKGZpbGUpO1xuXHRcdGNvbnN0IGZyb250TWF0dGVyID0gdGhpcy5leHRyYWN0RnJvbnRNYXR0ZXIoZmlsZUNvbnRlbnQpO1xuXHRcdGNvbnN0IG1ldGFkYXRhOiBEb2N1bWVudE1ldGFkYXRhID0ge1xuXHRcdFx0b2JzaWRpYW5JZDogZmlsZS5wYXRoLFxuXHRcdFx0cGF0aDogZmlsZS5wYXRoLFxuXHRcdFx0bGFzdE1vZGlmaWVkOiBmaWxlLnN0YXQubXRpbWUsXG5cdFx0XHRjcmVhdGVkOiBmaWxlLnN0YXQuY3RpbWUsXG5cdFx0XHRzaXplOiBmaWxlLnN0YXQuc2l6ZSxcblx0XHRcdGZyb250TWF0dGVyOiBmcm9udE1hdHRlcixcblx0XHRcdHRhZ3M6IHRoaXMuZXh0cmFjdFRhZ3MoZmlsZUNvbnRlbnQsIGZyb250TWF0dGVyKSxcblx0XHRcdGxpbmtzOiB0aGlzLmV4dHJhY3RMaW5rcyhmaWxlQ29udGVudCksXG5cdFx0XHRjdXN0b21NZXRhZGF0YToge31cblx0XHR9O1xuXG5cdFx0Ly8gRXh0cmFjdCBvcHRpb25hbCBhbGlhc2VzIGZyb20gZnJvbnRtYXR0ZXJcblx0XHRjb25zdCBhbGlhc2VzID0gdGhpcy5leHRyYWN0QWxpYXNlcyhmcm9udE1hdHRlcik7XG5cdFx0aWYgKGFsaWFzZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0bWV0YWRhdGEuY3VzdG9tTWV0YWRhdGEuYWxpYXNlcyA9IGFsaWFzZXM7XG5cdFx0fVxuXG5cdFx0Ly8gRXh0cmFjdCBzb3VyY2UgbG9jYXRpb24gaWYgYXZhaWxhYmxlXG5cdFx0Y29uc3QgbG9jID0gdGhpcy5leHRyYWN0U291cmNlTG9jYXRpb24oZnJvbnRNYXR0ZXIpO1xuXHRcdGlmIChsb2MpIHtcblx0XHRcdG1ldGFkYXRhLmxvYyA9IGxvYztcblx0XHR9XG5cblx0XHQvLyBBZGQgb3RoZXIgb3B0aW9uYWwgZnJvbnRtYXR0ZXIgZmllbGRzIGlmIHByZXNlbnRcblx0XHRpZiAoZnJvbnRNYXR0ZXI/LnNvdXJjZSkge1xuXHRcdFx0bWV0YWRhdGEuc291cmNlID0gZnJvbnRNYXR0ZXIuc291cmNlO1xuXHRcdH1cblx0XHRpZiAoZnJvbnRNYXR0ZXI/LmZpbGVfaWQpIHtcblx0XHRcdG1ldGFkYXRhLmZpbGVfaWQgPSBmcm9udE1hdHRlci5maWxlX2lkO1xuXHRcdH1cblx0XHRpZiAoZnJvbnRNYXR0ZXI/LmJsb2JUeXBlKSB7XG5cdFx0XHRtZXRhZGF0YS5ibG9iVHlwZSA9IGZyb250TWF0dGVyLmJsb2JUeXBlO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZXRhZGF0YTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFeHRyYWN0cyBtZXRhZGF0YSBmcm9tIHRoZSBwcm92aWRlZCBjb250ZW50IGFuZCBtZXJnZXMgaXQgd2l0aCB0aGUgZ2l2ZW4gYmFzZSBtZXRhZGF0YSBhbmQgZnJvbnQgbWF0dGVyLlxuXHQgKiBUaGlzIG5ldyBtZXRob2QgaXMgdXNlZCBieSB0aGUgVGV4dFNwbGl0dGVyIHRvIGVuaGFuY2UgbWV0YWRhdGEgYmFzZWQgb24gcGFyc2VkIGZyb250IG1hdHRlci5cblx0ICovXG5cdHB1YmxpYyBhc3luYyBleHRyYWN0TWV0YWRhdGFGcm9tQ29udGVudChcblx0XHRjb250ZW50OiBzdHJpbmcsXG5cdFx0YmFzZU1ldGFkYXRhOiBEb2N1bWVudE1ldGFkYXRhLFxuXHRcdGZyb250TWF0dGVyOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgbnVsbFxuXHQpOiBQcm9taXNlPERvY3VtZW50TWV0YWRhdGE+IHtcblx0XHRjb25zdCBtZXJnZWQgPSB7IC4uLmJhc2VNZXRhZGF0YSB9O1xuXHRcdGlmIChmcm9udE1hdHRlcikge1xuXHRcdFx0bWVyZ2VkLmZyb250TWF0dGVyID0gZnJvbnRNYXR0ZXI7XG5cdFx0XHQvLyBNZXJnZSB0YWdzIGZyb20gZnJvbnQgbWF0dGVyXG5cdFx0XHRpZiAoZnJvbnRNYXR0ZXIudGFncykge1xuXHRcdFx0XHRtZXJnZWQudGFncyA9IEFycmF5LmlzQXJyYXkoZnJvbnRNYXR0ZXIudGFncykgPyBmcm9udE1hdHRlci50YWdzIDogW2Zyb250TWF0dGVyLnRhZ3NdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTWVyZ2UgYWxpYXNlcyBpbnRvIGN1c3RvbU1ldGFkYXRhXG5cdFx0XHRpZiAoZnJvbnRNYXR0ZXIuYWxpYXNlcykge1xuXHRcdFx0XHRtZXJnZWQuY3VzdG9tTWV0YWRhdGEgPSBtZXJnZWQuY3VzdG9tTWV0YWRhdGEgfHwge307XG5cdFx0XHRcdG1lcmdlZC5jdXN0b21NZXRhZGF0YS5hbGlhc2VzID0gQXJyYXkuaXNBcnJheShmcm9udE1hdHRlci5hbGlhc2VzKVxuXHRcdFx0XHRcdD8gZnJvbnRNYXR0ZXIuYWxpYXNlc1xuXHRcdFx0XHRcdDogW2Zyb250TWF0dGVyLmFsaWFzZXNdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWVyZ2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4dHJhY3RzIFlBTUwgZnJvbnQgbWF0dGVyIGZyb20gZG9jdW1lbnQgY29udGVudFxuXHQgKi9cblx0cHJpdmF0ZSBleHRyYWN0RnJvbnRNYXR0ZXIoY29udGVudDogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGZyb250TWF0dGVyTWF0Y2ggPSBjb250ZW50Lm1hdGNoKC9eLS0tXFxuKFtcXHNcXFNdKj8pXFxuLS0tLyk7XG5cdFx0XHRpZiAoIWZyb250TWF0dGVyTWF0Y2gpIHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRjb25zdCB5YW1sID0gZnJvbnRNYXR0ZXJNYXRjaFsxXTtcblx0XHRcdHJldHVybiBwYXJzZVlhbWwoeWFtbCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgZnJvbnRtYXR0ZXI6JywgZXJyb3IpO1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGAke0RvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLllBTUxfUEFSU0VfRVJST1J9OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEV4dHJhY3RzIGludGVybmFsIGxpbmtzIGZyb20gZG9jdW1lbnQgY29udGVudC5cblx0ICovXG5cdHByaXZhdGUgZXh0cmFjdExpbmtzKGNvbnRlbnQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcblx0XHRjb25zdCBsaW5rUmVnZXggPSAvXFxbXFxbKC4qPykoPzpcXHwuKj8pP1xcXVxcXS9nO1xuXHRcdGNvbnN0IGxpbmtzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cdFx0bGV0IG1hdGNoO1xuXHRcdHdoaWxlICgobWF0Y2ggPSBsaW5rUmVnZXguZXhlYyhjb250ZW50KSkgIT09IG51bGwpIHtcblx0XHRcdGNvbnN0IGxpbmsgPSBtYXRjaFsxXS5zcGxpdCgnfCcpWzBdO1xuXHRcdFx0Y29uc3QgY2xlYW5MaW5rID0gdGhpcy5jbGVhbkxpbmsobGluayk7XG5cdFx0XHRpZiAoY2xlYW5MaW5rKSB7XG5cdFx0XHRcdGxpbmtzLmFkZChjbGVhbkxpbmspO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gQXJyYXkuZnJvbShsaW5rcyk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYW5zIGFuZCBub3JtYWxpemVzIGEgbGluayBwYXRoLlxuXHQgKi9cblx0cHJpdmF0ZSBjbGVhbkxpbmsobGluazogc3RyaW5nKTogc3RyaW5nIHtcblx0XHRsZXQgY2xlYW5MaW5rID0gbGluay5zcGxpdCgnIycpWzBdO1xuXHRcdGNsZWFuTGluayA9IGNsZWFuTGluay5zcGxpdCgnPycpWzBdO1xuXHRcdGNsZWFuTGluayA9IGNsZWFuTGluay50cmltKCk7XG5cdFx0cmV0dXJuIGNsZWFuTGluaztcblx0fVxuXG5cdC8qKlxuXHQgKiBFeHRyYWN0cyB0YWdzIGZyb20gYm90aCBjb250ZW50IGFuZCBmcm9udCBtYXR0ZXIuXG5cdCAqL1xuXHRwcml2YXRlIGV4dHJhY3RUYWdzKGNvbnRlbnQ6IHN0cmluZywgZnJvbnRNYXR0ZXI/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogc3RyaW5nW10ge1xuXHRcdGNvbnN0IHRhZ3MgPSBuZXcgU2V0PHN0cmluZz4oKTtcblx0XHRjb25zdCB0YWdSZWdleCA9IC8jKFtBLVphLXowLTkvXy1dKykvZztcblx0XHRsZXQgbWF0Y2g7XG5cdFx0d2hpbGUgKChtYXRjaCA9IHRhZ1JlZ2V4LmV4ZWMoY29udGVudCkpICE9PSBudWxsKSB7XG5cdFx0XHR0YWdzLmFkZChtYXRjaFsxXSk7XG5cdFx0fVxuXHRcdGlmIChmcm9udE1hdHRlcj8udGFncykge1xuXHRcdFx0Y29uc3QgZnJvbnRNYXR0ZXJUYWdzID0gQXJyYXkuaXNBcnJheShmcm9udE1hdHRlci50YWdzKVxuXHRcdFx0XHQ/IGZyb250TWF0dGVyLnRhZ3Ncblx0XHRcdFx0OiBbZnJvbnRNYXR0ZXIudGFnc107XG5cdFx0XHRmcm9udE1hdHRlclRhZ3MuZm9yRWFjaCh0YWcgPT4ge1xuXHRcdFx0XHRpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRjb25zdCBjbGVhblRhZyA9IHRhZy5zdGFydHNXaXRoKCcjJykgPyB0YWcuc2xpY2UoMSkgOiB0YWc7XG5cdFx0XHRcdFx0dGFncy5hZGQoY2xlYW5UYWcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIEFycmF5LmZyb20odGFncyk7XG5cdH1cblxuXHQvKipcblx0ICogRXh0cmFjdHMgYWxpYXNlcyBmcm9tIGZyb250IG1hdHRlci5cblx0ICovXG5cdHByaXZhdGUgZXh0cmFjdEFsaWFzZXMoZnJvbnRNYXR0ZXI/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogc3RyaW5nW10ge1xuXHRcdGlmICghZnJvbnRNYXR0ZXI/LmFsaWFzZXMpIHJldHVybiBbXTtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShmcm9udE1hdHRlci5hbGlhc2VzKSkge1xuXHRcdFx0cmV0dXJuIGZyb250TWF0dGVyLmFsaWFzZXMuZmlsdGVyKGFsaWFzID0+IHR5cGVvZiBhbGlhcyA9PT0gJ3N0cmluZycpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIGZyb250TWF0dGVyLmFsaWFzZXMgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gW2Zyb250TWF0dGVyLmFsaWFzZXNdO1xuXHRcdH1cblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHQvKipcblx0ICogRXh0cmFjdHMgc291cmNlIGxvY2F0aW9uIGluZm9ybWF0aW9uIGZyb20gZnJvbnQgbWF0dGVyLlxuXHQgKi9cblx0cHJpdmF0ZSBleHRyYWN0U291cmNlTG9jYXRpb24oZnJvbnRNYXR0ZXI/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogeyBsaW5lczogeyBmcm9tOiBudW1iZXI7IHRvOiBudW1iZXIgfSB9IHwgdW5kZWZpbmVkIHtcblx0XHRpZiAoIWZyb250TWF0dGVyPy5sb2M/LmxpbmVzPy5mcm9tIHx8ICFmcm9udE1hdHRlcj8ubG9jPy5saW5lcz8udG8pIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRsaW5lczoge1xuXHRcdFx0XHRmcm9tOiBOdW1iZXIoZnJvbnRNYXR0ZXIubG9jLmxpbmVzLmZyb20pLFxuXHRcdFx0XHR0bzogTnVtYmVyKGZyb250TWF0dGVyLmxvYy5saW5lcy50bylcblx0XHRcdH1cblx0XHR9O1xuXHR9XG59XG4iLCAiLy9UZXh0U3BsaXR0ZXIudHNcbmltcG9ydCB7XG5cdERvY3VtZW50Q2h1bmssXG5cdERvY3VtZW50TWV0YWRhdGEsXG5cdERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLFxufSBmcm9tICcuLi9tb2RlbHMvRG9jdW1lbnRDaHVuayc7XG5pbXBvcnQgeyBERUZBVUxUX0NIVU5LSU5HX09QVElPTlMgfSBmcm9tICcuLi9zZXR0aW5ncy9TZXR0aW5ncyc7XG5pbXBvcnQgeyBNZXRhZGF0YUV4dHJhY3RvciB9IGZyb20gJy4uL3NlcnZpY2VzL01ldGFkYXRhRXh0cmFjdG9yJztcblxuZXhwb3J0IGNsYXNzIFRleHRTcGxpdHRlciB7XG5cdHByaXZhdGUgc2V0dGluZ3M6IHtcblx0XHRjaHVua1NpemU6IG51bWJlcjtcblx0XHRjaHVua092ZXJsYXA6IG51bWJlcjtcblx0XHRtaW5DaHVua1NpemU6IG51bWJlcjtcblx0fTtcblx0cHJpdmF0ZSBtZXRhZGF0YUV4dHJhY3RvcjogTWV0YWRhdGFFeHRyYWN0b3I7XG5cdC8vIFJlZ2V4IHBhdHRlcm5zIGZvciBzcGxpdHRpbmdcblx0cHJpdmF0ZSByZWFkb25seSBTRU5URU5DRV9CT1VOREFSWSA9IC9bLiE/XVxccysvO1xuXHRwcml2YXRlIHJlYWRvbmx5IFBBUkFHUkFQSF9CT1VOREFSWSA9IC9cXG5cXHMqXFxuLztcblx0cHJpdmF0ZSByZWFkb25seSBZQU1MX0ZST05UX01BVFRFUiA9IC9eLS0tXFxuKFtcXHNcXFNdKj8pXFxuLS0tLztcblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRzZXR0aW5ncz86IHsgY2h1bmtTaXplOiBudW1iZXI7IGNodW5rT3ZlcmxhcDogbnVtYmVyOyBtaW5DaHVua1NpemU6IG51bWJlciB9LFxuXHRcdG1ldGFkYXRhRXh0cmFjdG9yPzogTWV0YWRhdGFFeHRyYWN0b3Jcblx0KSB7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzIHx8IHsgLi4uREVGQVVMVF9DSFVOS0lOR19PUFRJT05TIH07XG5cdFx0dGhpcy52YWxpZGF0ZVNldHRpbmdzKHRoaXMuc2V0dGluZ3MpO1xuXHRcdHRoaXMubWV0YWRhdGFFeHRyYWN0b3IgPSBtZXRhZGF0YUV4dHJhY3RvciB8fCBuZXcgTWV0YWRhdGFFeHRyYWN0b3IoKTtcblx0fVxuXG5cdC8qKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNodW5raW5nIHNldHRpbmdzLiAqL1xuXHRwdWJsaWMgZ2V0U2V0dGluZ3MoKTogeyBjaHVua1NpemU6IG51bWJlcjsgY2h1bmtPdmVybGFwOiBudW1iZXI7IG1pbkNodW5rU2l6ZTogbnVtYmVyIH0ge1xuXHRcdHJldHVybiB0aGlzLnNldHRpbmdzO1xuXHR9XG5cblx0cHJpdmF0ZSB2YWxpZGF0ZVNldHRpbmdzKHNldHRpbmdzOiB7IGNodW5rU2l6ZTogbnVtYmVyOyBjaHVua092ZXJsYXA6IG51bWJlcjsgbWluQ2h1bmtTaXplOiBudW1iZXIgfSk6IHZvaWQge1xuXHRcdGlmIChzZXR0aW5ncy5jaHVua1NpemUgPD0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDaHVuayBzaXplIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuJyk7XG5cdFx0fVxuXHRcdGlmIChzZXR0aW5ncy5jaHVua092ZXJsYXAgPj0gc2V0dGluZ3MuY2h1bmtTaXplKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NodW5rIG92ZXJsYXAgbXVzdCBiZSBsZXNzIHRoYW4gY2h1bmsgc2l6ZS4nKTtcblx0XHR9XG5cdFx0aWYgKHNldHRpbmdzLm1pbkNodW5rU2l6ZSA+IHNldHRpbmdzLmNodW5rU2l6ZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNaW5pbXVtIGNodW5rIHNpemUgbXVzdCBub3QgZXhjZWVkIGNodW5rIHNpemUuJyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNwbGl0cyBhIGRvY3VtZW50IGludG8gY2h1bmtzIHdoaWxlIGVuaGFuY2luZyBtZXRhZGF0YS5cblx0ICogRXh0cmFjdHMgWUFNTCBmcm9udCBtYXR0ZXIgaWYgcHJlc2VudCwgYW5kIHRoZW4gdXNlcyB0aGUgTWV0YWRhdGFFeHRyYWN0b3Jcblx0ICogdG8gbWVyZ2UgYWRkaXRpb25hbCBtZXRhZGF0YSAoZS5nLiwgdGFncywgYWxpYXNlcywgbGlua3MpIGludG8gdGhlIGJhc2UgbWV0YWRhdGEuXG5cdCAqXG5cdCAqIEBwYXJhbSBjb250ZW50IFRoZSBmdWxsIHRleHQgY29udGVudCBvZiB0aGUgZG9jdW1lbnQuXG5cdCAqIEBwYXJhbSBtZXRhZGF0YSBCYXNlIG1ldGFkYXRhIGZvciB0aGUgZG9jdW1lbnQuXG5cdCAqIEBwYXJhbSBhYm9ydFNpZ25hbCBPcHRpb25hbCBBYm9ydFNpZ25hbCB0byBjYW5jZWwgdGhlIG9wZXJhdGlvbi5cblx0ICogQHJldHVybnMgQW4gYXJyYXkgb2YgRG9jdW1lbnRDaHVuay5cblx0ICovXG5cdHB1YmxpYyBhc3luYyBzcGxpdERvY3VtZW50KFxuXHRcdGNvbnRlbnQ6IHN0cmluZyxcblx0XHRtZXRhZGF0YTogRG9jdW1lbnRNZXRhZGF0YSxcblx0XHRhYm9ydFNpZ25hbD86IEFib3J0U2lnbmFsXG5cdCk6IFByb21pc2U8RG9jdW1lbnRDaHVua1tdPiB7XG5cdFx0Y29uc3QgcGVyZm9ybWFuY2VNZXRyaWNzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG5cdFx0Y29uc3Qgb3ZlcmFsbFN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc29sZS5sb2coJ1N0YXJ0aW5nIGRvY3VtZW50IHNwbGl0JywgeyBjb250ZW50TGVuZ3RoOiBjb250ZW50Lmxlbmd0aCwgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MgfSk7XG5cblx0XHRcdGlmIChhYm9ydFNpZ25hbD8uYWJvcnRlZCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0RvY3VtZW50IHNwbGl0dGluZyBhYm9ydGVkIGJlZm9yZSBzdGFydCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWNvbnRlbnQ/LnRyaW0oKSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnRW1wdHkgY29udGVudCByZWNlaXZlZCcpO1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0dGVtcHQgdG8gZXh0cmFjdCBZQU1MIGZyb250IG1hdHRlciB3aXRob3V0IGFsdGVyaW5nIHRoZSBvcmlnaW5hbCBjb250ZW50LlxuXHRcdFx0bGV0IGZyb250TWF0dGVyID0gbnVsbDtcblx0XHRcdGNvbnN0IGZyb250TWF0dGVyTWF0Y2ggPSB0aGlzLllBTUxfRlJPTlRfTUFUVEVSLmV4ZWMoY29udGVudCk7XG5cdFx0XHRpZiAoZnJvbnRNYXR0ZXJNYXRjaCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZyb250TWF0dGVyID0gdGhpcy5wYXJzZUZyb250TWF0dGVyKGZyb250TWF0dGVyTWF0Y2hbMV0pO1xuXHRcdFx0XHRcdC8vIEVuaGFuY2UgbWV0YWRhdGEgdXNpbmcgTWV0YWRhdGFFeHRyYWN0b3Igd2l0aCBleHRyYWN0ZWQgZnJvbnQgbWF0dGVyLlxuXHRcdFx0XHRcdGNvbnN0IGVuaGFuY2VkTWV0YWRhdGEgPSBhd2FpdCB0aGlzLm1ldGFkYXRhRXh0cmFjdG9yLmV4dHJhY3RNZXRhZGF0YUZyb21Db250ZW50KFxuXHRcdFx0XHRcdFx0Y29udGVudCxcblx0XHRcdFx0XHRcdG1ldGFkYXRhLFxuXHRcdFx0XHRcdFx0ZnJvbnRNYXR0ZXJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdG1ldGFkYXRhID0geyAuLi5tZXRhZGF0YSwgLi4uZW5oYW5jZWRNZXRhZGF0YSB9O1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdGcm9udCBtYXR0ZXIgZXh0cmFjdGVkIGFuZCBtZXRhZGF0YSBlbmhhbmNlZCcsIHsgZnJvbnRNYXR0ZXIgfSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgZnJvbnQgbWF0dGVyJywgZXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRyaW1tZWRDb250ZW50ID0gY29udGVudC50cmltKCk7XG5cdFx0XHRpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCBzcGxpdHRpbmcgYWJvcnRlZCBhZnRlciBmcm9udCBtYXR0ZXIgcHJvY2Vzc2luZycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBjb250ZW50IGlzIHNtYWxsZXIgdGhhbiB0aGUgY2h1bmsgc2l6ZSwgcmV0dXJuIGFzIGEgc2luZ2xlIGNodW5rLlxuXHRcdFx0aWYgKHRyaW1tZWRDb250ZW50Lmxlbmd0aCA8PSBNYXRoLm1heCh0aGlzLnNldHRpbmdzLm1pbkNodW5rU2l6ZSwgdGhpcy5zZXR0aW5ncy5jaHVua1NpemUpKSB7XG5cdFx0XHRcdGlmICh0cmltbWVkQ29udGVudC5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygnTm8gY29udGVudCBhZnRlciB0cmltbWluZywgcmV0dXJuaW5nIGVtcHR5IGFycmF5Jyk7XG5cdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdDb250ZW50IGlzIHNtYWxsZXIgdGhhbiBjaHVuayBzaXplLCBjcmVhdGluZyBzaW5nbGUgY2h1bmsnLCB7XG5cdFx0XHRcdFx0Y29udGVudExlbmd0aDogdHJpbW1lZENvbnRlbnQubGVuZ3RoLFxuXHRcdFx0XHRcdGNodW5rU2l6ZTogdGhpcy5zZXR0aW5ncy5jaHVua1NpemUsXG5cdFx0XHRcdFx0bWluQ2h1bmtTaXplOiB0aGlzLnNldHRpbmdzLm1pbkNodW5rU2l6ZSxcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGNvbnN0IHNpbmdsZUNodW5rID0gdGhpcy5jcmVhdGVDaHVuayh0cmltbWVkQ29udGVudCwgMCwgbWV0YWRhdGEpO1xuXHRcdFx0XHRwZXJmb3JtYW5jZU1ldHJpY3Muc2luZ2xlQ2h1bmtUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBvdmVyYWxsU3RhcnQ7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdDcmVhdGVkIHNpbmdsZSBjaHVuaycsIHsgY2h1bmtTaXplOiBzaW5nbGVDaHVuay5jb250ZW50Lmxlbmd0aCwgcHJldmlldzogc2luZ2xlQ2h1bmsuY29udGVudC5zdWJzdHJpbmcoMCwgMTAwKSB9KTtcblx0XHRcdFx0Y29uc29sZS5sb2coYERvY3VtZW50IHNwbGl0IGNvbXBsZXRlZCBpbiAke3BlcmZvcm1hbmNlLm5vdygpIC0gb3ZlcmFsbFN0YXJ0fSBtc2AsIHBlcmZvcm1hbmNlTWV0cmljcyk7XG5cdFx0XHRcdHJldHVybiBbc2luZ2xlQ2h1bmtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTcGxpdCBjb250ZW50IGludG8gcGFyYWdyYXBocy5cblx0XHRcdGNvbnN0IHBhcmFncmFwaHMgPSBjb250ZW50LnNwbGl0KHRoaXMuUEFSQUdSQVBIX0JPVU5EQVJZKVxuXHRcdFx0XHQubWFwKHAgPT4gcC50cmltKCkpXG5cdFx0XHRcdC5maWx0ZXIocCA9PiBwLmxlbmd0aCA+IDApO1xuXHRcdFx0Y29uc29sZS5sb2coJ1NwbGl0IGludG8gcGFyYWdyYXBocycsIHsgcGFyYWdyYXBoQ291bnQ6IHBhcmFncmFwaHMubGVuZ3RoLCBwYXJhZ3JhcGhzOiBwYXJhZ3JhcGhzLm1hcChwID0+IHAuc3Vic3RyaW5nKDAsIDEwMCkpIH0pO1xuXG5cdFx0XHRpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCBzcGxpdHRpbmcgYWJvcnRlZCBhZnRlciBwYXJhZ3JhcGggc3BsaXQnKTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGNodW5rczogRG9jdW1lbnRDaHVua1tdID0gW107XG5cdFx0XHRsZXQgY3VycmVudENodW5rID0gJyc7XG5cdFx0XHRsZXQgY2h1bmtJbmRleCA9IDA7XG5cblx0XHRcdC8vIFByb2Nlc3MgZWFjaCBwYXJhZ3JhcGhcblx0XHRcdGZvciAoY29uc3QgcGFyYWdyYXBoIG9mIHBhcmFncmFwaHMpIHtcblx0XHRcdFx0aWYgKGFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG5cdFx0XHRcdFx0Ly8gQ2xlYW51cCBhbnkgcGFydGlhbCByZXN1bHRzIGlmIGFib3J0ZWRcblx0XHRcdFx0XHRjaHVua3MgPSBbXTtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0RvY3VtZW50IHNwbGl0dGluZyBhYm9ydGVkIGR1cmluZyBwcm9jZXNzaW5nJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gSWYgcGFyYWdyYXBoIGlzIGxhcmdlciB0aGFuIHRoZSBjaHVuayBzaXplLCBzcGxpdCBpdCBpbnRvIHNlbnRlbmNlcy5cblx0XHRcdFx0aWYgKHBhcmFncmFwaC5sZW5ndGggPj0gdGhpcy5zZXR0aW5ncy5jaHVua1NpemUpIHtcblx0XHRcdFx0XHRpZiAoY3VycmVudENodW5rKSB7XG5cdFx0XHRcdFx0XHRjaHVua3MucHVzaCh0aGlzLmNyZWF0ZUNodW5rKGN1cnJlbnRDaHVuaywgY2h1bmtJbmRleCsrLCBtZXRhZGF0YSkpO1xuXHRcdFx0XHRcdFx0Y3VycmVudENodW5rID0gJyc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnN0IHNlbnRlbmNlcyA9IHBhcmFncmFwaC5zcGxpdCh0aGlzLlNFTlRFTkNFX0JPVU5EQVJZKTtcblx0XHRcdFx0XHRsZXQgc2VudGVuY2VDaHVuayA9ICcnO1xuXHRcdFx0XHRcdGZvciAoY29uc3Qgc2VudGVuY2Ugb2Ygc2VudGVuY2VzKSB7XG5cdFx0XHRcdFx0XHRpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcblx0XHRcdFx0XHRcdFx0Y2h1bmtzID0gW107XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignRG9jdW1lbnQgc3BsaXR0aW5nIGFib3J0ZWQgZHVyaW5nIHNlbnRlbmNlIHByb2Nlc3NpbmcnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbnN0IHRyaW1tZWRTZW50ZW5jZSA9IHNlbnRlbmNlLnRyaW0oKTtcblx0XHRcdFx0XHRcdGlmICghdHJpbW1lZFNlbnRlbmNlKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdGlmICgoc2VudGVuY2VDaHVuayArICcgJyArIHRyaW1tZWRTZW50ZW5jZSkubGVuZ3RoID4gdGhpcy5zZXR0aW5ncy5jaHVua1NpemUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHNlbnRlbmNlQ2h1bmspIHtcblx0XHRcdFx0XHRcdFx0XHRjaHVua3MucHVzaCh0aGlzLmNyZWF0ZUNodW5rKHNlbnRlbmNlQ2h1bmssIGNodW5rSW5kZXgrKywgbWV0YWRhdGEpKTtcblx0XHRcdFx0XHRcdFx0XHRzZW50ZW5jZUNodW5rID0gdHJpbW1lZFNlbnRlbmNlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIEZvciB2ZXJ5IGxvbmcgc2VudGVuY2VzLCBmb3JjZSBzcGxpdC5cblx0XHRcdFx0XHRcdFx0XHRsZXQgcG9zaXRpb24gPSAwO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChwb3NpdGlvbiA8IHRyaW1tZWRTZW50ZW5jZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGNodW5rVGV4dCA9IHRyaW1tZWRTZW50ZW5jZS5zbGljZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdE1hdGgubWluKHBvc2l0aW9uICsgdGhpcy5zZXR0aW5ncy5jaHVua1NpemUsIHRyaW1tZWRTZW50ZW5jZS5sZW5ndGgpXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2h1bmtzLnB1c2godGhpcy5jcmVhdGVDaHVuayhjaHVua1RleHQsIGNodW5rSW5kZXgrKywgbWV0YWRhdGEpKTtcblx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IHRoaXMuc2V0dGluZ3MuY2h1bmtTaXplO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRzZW50ZW5jZUNodW5rID0gJyc7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNlbnRlbmNlQ2h1bmsgKz0gKHNlbnRlbmNlQ2h1bmsgPyAnICcgOiAnJykgKyB0cmltbWVkU2VudGVuY2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzZW50ZW5jZUNodW5rKSB7XG5cdFx0XHRcdFx0XHRjaHVua3MucHVzaCh0aGlzLmNyZWF0ZUNodW5rKHNlbnRlbmNlQ2h1bmssIGNodW5rSW5kZXgrKywgbWV0YWRhdGEpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQWNjdW11bGF0ZSBwYXJhZ3JhcGhzIHVudGlsIHJlYWNoaW5nIGNodW5rIHNpemUuXG5cdFx0XHRcdFx0Y29uc3QgcG90ZW50aWFsQ2h1bmtTaXplID0gY3VycmVudENodW5rXG5cdFx0XHRcdFx0XHQ/IGN1cnJlbnRDaHVuay5sZW5ndGggKyAyICsgcGFyYWdyYXBoLmxlbmd0aFxuXHRcdFx0XHRcdFx0OiBwYXJhZ3JhcGgubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChwb3RlbnRpYWxDaHVua1NpemUgPD0gdGhpcy5zZXR0aW5ncy5jaHVua1NpemUpIHtcblx0XHRcdFx0XHRcdGN1cnJlbnRDaHVuayArPSAoY3VycmVudENodW5rID8gJ1xcblxcbicgOiAnJykgKyBwYXJhZ3JhcGg7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50Q2h1bmspIHtcblx0XHRcdFx0XHRcdFx0Y2h1bmtzLnB1c2godGhpcy5jcmVhdGVDaHVuayhjdXJyZW50Q2h1bmssIGNodW5rSW5kZXgrKywgbWV0YWRhdGEpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGN1cnJlbnRDaHVuayA9IHBhcmFncmFwaDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChjdXJyZW50Q2h1bmspIHtcblx0XHRcdFx0Y2h1bmtzLnB1c2godGhpcy5jcmVhdGVDaHVuayhjdXJyZW50Q2h1bmssIGNodW5rSW5kZXgrKywgbWV0YWRhdGEpKTtcblx0XHRcdH1cblx0XHRcdGlmIChjaHVua3MubGVuZ3RoID09PSAwICYmIHRyaW1tZWRDb250ZW50Lmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0NyZWF0aW5nIGZhbGxiYWNrIGNodW5rIGZvciBjb250ZW50JywgeyBjb250ZW50TGVuZ3RoOiB0cmltbWVkQ29udGVudC5sZW5ndGggfSk7XG5cdFx0XHRcdGNodW5rcy5wdXNoKHRoaXMuY3JlYXRlQ2h1bmsodHJpbW1lZENvbnRlbnQsIDAsIG1ldGFkYXRhKSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBBcHBseSBvdmVybGFwIGJldHdlZW4gY2h1bmtzIGlmIGNvbmZpZ3VyZWQuXG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5jaHVua092ZXJsYXAgPiAwICYmIGNodW5rcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdGNodW5rcyA9IHRoaXMuYXBwbHlPdmVybGFwKGNodW5rcyk7XG5cdFx0XHR9XG5cblx0XHRcdHBlcmZvcm1hbmNlTWV0cmljcy50b3RhbFNwbGl0dGluZ1RpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIG92ZXJhbGxTdGFydDtcblx0XHRcdGNvbnNvbGUubG9nKCdGaW5pc2hlZCBjcmVhdGluZyBjaHVua3MnLCB7XG5cdFx0XHRcdGNodW5rQ291bnQ6IGNodW5rcy5sZW5ndGgsXG5cdFx0XHRcdGNodW5rU2l6ZXM6IGNodW5rcy5tYXAoYyA9PiBjLmNvbnRlbnQubGVuZ3RoKSxcblx0XHRcdFx0Y2h1bmtQcmV2aWV3czogY2h1bmtzLm1hcChjID0+ICh7XG5cdFx0XHRcdFx0aW5kZXg6IGMuY2h1bmtJbmRleCxcblx0XHRcdFx0XHRzaXplOiBjLmNvbnRlbnQubGVuZ3RoLFxuXHRcdFx0XHRcdHByZXZpZXc6IGMuY29udGVudC5zdWJzdHJpbmcoMCwgMTAwKSxcblx0XHRcdFx0fSkpLFxuXHRcdFx0XHRwZXJmb3JtYW5jZU1ldHJpY3Ncblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGNodW5rcztcblx0XHR9IGNhdGNoIChlcnJvcjogYW55KSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBpbiBzcGxpdERvY3VtZW50JywgZXJyb3IpO1xuXHRcdFx0Ly8gRW5zdXJlIGFueSBwYXJ0aWFsIHJlc3VsdHMgYXJlIGNsZWFuZWQgdXBcblx0XHRcdHRocm93IHtcblx0XHRcdFx0dHlwZTogRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IuQ0hVTktJTkdfRVJST1IsXG5cdFx0XHRcdG1lc3NhZ2U6ICdFcnJvciBvY2N1cnJlZCBkdXJpbmcgZG9jdW1lbnQgY2h1bmtpbmcnLFxuXHRcdFx0XHRkZXRhaWxzOiBlcnJvci5tZXNzYWdlLFxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGNyZWF0ZUNodW5rKGNvbnRlbnQ6IHN0cmluZywgaW5kZXg6IG51bWJlciwgbWV0YWRhdGE6IERvY3VtZW50TWV0YWRhdGEpOiBEb2N1bWVudENodW5rIHtcblx0XHRjb25zdCB0cmltbWVkQ29udGVudCA9IGNvbnRlbnQudHJpbSgpO1xuXHRcdGlmICh0cmltbWVkQ29udGVudC5sZW5ndGggPCB0aGlzLnNldHRpbmdzLm1pbkNodW5rU2l6ZSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdDaHVuayBzbWFsbGVyIHRoYW4gbWluQ2h1bmtTaXplJywge1xuXHRcdFx0XHRzaXplOiB0cmltbWVkQ29udGVudC5sZW5ndGgsXG5cdFx0XHRcdG1pblNpemU6IHRoaXMuc2V0dGluZ3MubWluQ2h1bmtTaXplLFxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRjb250ZW50OiB0cmltbWVkQ29udGVudCxcblx0XHRcdGNodW5rSW5kZXg6IGluZGV4LFxuXHRcdFx0bWV0YWRhdGE6IHsgLi4ubWV0YWRhdGEgfSxcblx0XHR9O1xuXHR9XG5cblx0cHJpdmF0ZSBhcHBseU92ZXJsYXAoY2h1bmtzOiBEb2N1bWVudENodW5rW10pOiBEb2N1bWVudENodW5rW10ge1xuXHRcdGlmIChjaHVua3MubGVuZ3RoIDw9IDEpIHJldHVybiBjaHVua3M7XG5cdFx0Y29uc3QgY2h1bmtzV2l0aE92ZXJsYXAgPSBbLi4uY2h1bmtzXTtcblx0XHRmb3IgKGxldCBpID0gY2h1bmtzV2l0aE92ZXJsYXAubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuXHRcdFx0Y29uc3QgY3VycmVudENodW5rID0geyAuLi5jaHVua3NXaXRoT3ZlcmxhcFtpXSB9O1xuXHRcdFx0Y29uc3QgcHJldmlvdXNDaHVuayA9IGNodW5rc1dpdGhPdmVybGFwW2kgLSAxXTtcblx0XHRcdGNvbnN0IG92ZXJsYXBUZXh0ID0gcHJldmlvdXNDaHVuay5jb250ZW50LnNsaWNlKC10aGlzLnNldHRpbmdzLmNodW5rT3ZlcmxhcCk7XG5cdFx0XHRpZiAob3ZlcmxhcFRleHQpIHtcblx0XHRcdFx0Y2h1bmtzV2l0aE92ZXJsYXBbaV0gPSB7XG5cdFx0XHRcdFx0Li4uY3VycmVudENodW5rLFxuXHRcdFx0XHRcdGNvbnRlbnQ6IG92ZXJsYXBUZXh0ICsgJ1xcblxcbicgKyBjdXJyZW50Q2h1bmsuY29udGVudCxcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNodW5rc1dpdGhPdmVybGFwO1xuXHR9XG5cblx0cHJpdmF0ZSBwYXJzZUZyb250TWF0dGVyKGZyb250TWF0dGVyOiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG5cdFx0XHRjb25zdCBsaW5lcyA9IGZyb250TWF0dGVyLnNwbGl0KCdcXG4nKTtcblx0XHRcdGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuXHRcdFx0XHRjb25zdCB0cmltbWVkTGluZSA9IGxpbmUudHJpbSgpO1xuXHRcdFx0XHRpZiAoIXRyaW1tZWRMaW5lIHx8IHRyaW1tZWRMaW5lLnN0YXJ0c1dpdGgoJyMnKSkgY29udGludWU7XG5cdFx0XHRcdGNvbnN0IHNlcGFyYXRvckluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG5cdFx0XHRcdGlmIChzZXBhcmF0b3JJbmRleCA9PT0gLTEpIGNvbnRpbnVlO1xuXHRcdFx0XHRjb25zdCBrZXkgPSBsaW5lLnNsaWNlKDAsIHNlcGFyYXRvckluZGV4KS50cmltKCk7XG5cdFx0XHRcdGxldCB2YWx1ZSA9IGxpbmUuc2xpY2Uoc2VwYXJhdG9ySW5kZXggKyAxKS50cmltKCk7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXltcIiddKC4qKVtcIiddJC8sICckMScpO1xuXHRcdFx0XHRpZiAodmFsdWUuc3RhcnRzV2l0aCgnLSAnKSkge1xuXHRcdFx0XHRcdHJlc3VsdFtrZXldID0gdmFsdWVcblx0XHRcdFx0XHRcdC5zcGxpdCgnXFxuJylcblx0XHRcdFx0XHRcdC5tYXAoaXRlbSA9PiBpdGVtLnJlcGxhY2UoJy0gJywgJycpLnRyaW0oKSlcblx0XHRcdFx0XHRcdC5maWx0ZXIoQm9vbGVhbik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdWx0W2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgZnJvbnQgbWF0dGVyJywgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIHt9O1xuXHRcdH1cblx0fVxufVxuIiwgIi8vIHNyYy9zZXJ2aWNlcy9FdmVudEVtaXR0ZXIudHNcbmltcG9ydCB7IFF1ZXVlRXZlbnRUeXBlcywgUXVldWVFdmVudENhbGxiYWNrIH0gZnJvbSAnLi4vbW9kZWxzL1F1ZXVlRXZlbnRzJztcblxuZXhwb3J0IGNsYXNzIEV2ZW50RW1pdHRlciB7XG5cdHByaXZhdGUgbGlzdGVuZXJzOiBNYXA8c3RyaW5nLCBTZXQ8RnVuY3Rpb24+PiA9IG5ldyBNYXAoKTtcblxuXHQvKipcblx0ICogRW1pdCBhbiBldmVudCB3aXRoIGFzc29jaWF0ZWQgZGF0YS5cblx0ICogTGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgZGF0YS5cblx0ICovXG5cdGVtaXQ8VCBleHRlbmRzIGtleW9mIFF1ZXVlRXZlbnRUeXBlcz4oZXZlbnQ6IFQsIGRhdGE6IFF1ZXVlRXZlbnRUeXBlc1tUXSk6IHZvaWQge1xuXHRcdGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMubGlzdGVuZXJzLmdldChldmVudCk7XG5cdFx0aWYgKGNhbGxiYWNrcykge1xuXHRcdFx0Zm9yIChjb25zdCBjYWxsYmFjayBvZiBjYWxsYmFja3MpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjYWxsYmFjayhkYXRhKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGBFcnJvciBpbiBsaXN0ZW5lciBmb3IgZXZlbnQgXCIke2V2ZW50fVwiOmAsIGVycm9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgc3BlY2lmaWVkIGV2ZW50IGlzIGVtaXR0ZWQuXG5cdCAqIFJldHVybnMgYW4gdW5zdWJzY3JpYmUgZnVuY3Rpb24uXG5cdCAqL1xuXHRvbjxUIGV4dGVuZHMga2V5b2YgUXVldWVFdmVudFR5cGVzPihldmVudDogVCwgY2FsbGJhY2s6IFF1ZXVlRXZlbnRDYWxsYmFjazxUPik6ICgpID0+IHZvaWQge1xuXHRcdGlmICghdGhpcy5saXN0ZW5lcnMuaGFzKGV2ZW50KSkge1xuXHRcdFx0dGhpcy5saXN0ZW5lcnMuc2V0KGV2ZW50LCBuZXcgU2V0KCkpO1xuXHRcdH1cblx0XHR0aGlzLmxpc3RlbmVycy5nZXQoZXZlbnQpPy5hZGQoY2FsbGJhY2spO1xuXHRcdC8vIFJldHVybiBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbi5cblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0dGhpcy5saXN0ZW5lcnMuZ2V0KGV2ZW50KT8uZGVsZXRlKGNhbGxiYWNrKTtcblx0XHR9O1xuXHR9XG59XG4iLCAiLy8gc3JjL3V0aWxzL0ZpbGVUcmFja2VyLnRzXG5pbXBvcnQgeyBUQWJzdHJhY3RGaWxlLCBURmlsZSwgVmF1bHQgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBFcnJvckhhbmRsZXIgfSBmcm9tICcuL0Vycm9ySGFuZGxlcic7XG5pbXBvcnQgeyBEb2N1bWVudE1ldGFkYXRhIH0gZnJvbSAnLi4vbW9kZWxzL0RvY3VtZW50Q2h1bmsnO1xuaW1wb3J0IHsgU3luY0ZpbGVNYW5hZ2VyIH0gZnJvbSAnLi4vc2VydmljZXMvU3luY0ZpbGVNYW5hZ2VyJztcbmltcG9ydCB7IFN1cGFiYXNlU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL1N1cGFiYXNlU2VydmljZSc7XG4vLyBPcHRpb25hbDogSW1wb3J0IE9mZmxpbmVRdWV1ZU1hbmFnZXIgaWYgYXZhaWxhYmxlXG5pbXBvcnQgeyBPZmZsaW5lUXVldWVNYW5hZ2VyIH0gZnJvbSAnLi4vc2VydmljZXMvT2ZmbGluZVF1ZXVlTWFuYWdlcic7XG5cbmludGVyZmFjZSBGaWxlRXZlbnQge1xuXHR0eXBlOiAnY3JlYXRlJyB8ICdtb2RpZnknIHwgJ2RlbGV0ZScgfCAncmVuYW1lJztcblx0ZmlsZTogVEZpbGU7XG5cdG9sZFBhdGg/OiBzdHJpbmc7XG5cdHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgRmlsZVRyYWNrZXIge1xuXHRwcml2YXRlIGV2ZW50UXVldWU6IEZpbGVFdmVudFtdID0gW107XG5cdHByaXZhdGUgaXNQcm9jZXNzaW5nOiBib29sZWFuID0gZmFsc2U7XG5cdHByaXZhdGUgcHJvY2Vzc2luZ1RpbWVvdXQ6IG51bWJlciA9IDEwMDA7IC8vIERlYm91bmNlIHRpbWUgaW4gbXNcblx0cHJpdmF0ZSBzeW5jTWFuYWdlcjogU3luY0ZpbGVNYW5hZ2VyO1xuXHRwcml2YXRlIHJlYWRvbmx5IHN5bmNGaWxlUGF0aDogc3RyaW5nO1xuXHQvLyBPcHRpb25hbCBvZmZsaW5lIHF1ZXVlIG1hbmFnZXIgZm9yIG9mZmxpbmUgb3BlcmF0aW9uc1xuXHRwcml2YXRlIG9mZmxpbmVRdWV1ZU1hbmFnZXI6IE9mZmxpbmVRdWV1ZU1hbmFnZXIgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBtYXhGaWxlU2l6ZUJ5dGVzOiBudW1iZXIgPSAxMCAqIDEwMjQgKiAxMDI0O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0gdmF1bHQgVGhlIE9ic2lkaWFuIHZhdWx0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0gZXJyb3JIYW5kbGVyIENlbnRyYWxpemVkIGVycm9yIGhhbmRsZXIuXG5cdCAqIEBwYXJhbSBzeW5jRmlsZVBhdGggUGF0aCB0byB0aGUgc3luYyBmaWxlLlxuXHQgKiBAcGFyYW0gc3VwYWJhc2VTZXJ2aWNlIE9wdGlvbmFsIFN1cGFiYXNlIHNlcnZpY2UgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSBvZmZsaW5lUXVldWVNYW5hZ2VyIE9wdGlvbmFsIE9mZmxpbmVRdWV1ZU1hbmFnZXIgZm9yIG9mZmxpbmUgbW9kZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByaXZhdGUgdmF1bHQ6IFZhdWx0LFxuXHRcdHByaXZhdGUgZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXIsXG5cdFx0c3luY0ZpbGVQYXRoOiBzdHJpbmcgPSAnX21pbmRtYXRyaXhzeW5jLm1kJyxcblx0XHRwcml2YXRlIHN1cGFiYXNlU2VydmljZTogU3VwYWJhc2VTZXJ2aWNlIHwgbnVsbCA9IG51bGwsXG5cdFx0b2ZmbGluZVF1ZXVlTWFuYWdlcj86IE9mZmxpbmVRdWV1ZU1hbmFnZXJcblx0KSB7XG5cdFx0dGhpcy5zeW5jRmlsZVBhdGggPSBzeW5jRmlsZVBhdGg7XG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3luYyBtYW5hZ2VyIHVzaW5nIHRoZSBwcm92aWRlZCBzeW5jIGZpbGUgcGF0aC5cblx0XHR0aGlzLnN5bmNNYW5hZ2VyID0gbmV3IFN5bmNGaWxlTWFuYWdlcih2YXVsdCwgZXJyb3JIYW5kbGVyLCBzeW5jRmlsZVBhdGgpO1xuXHRcdGlmIChvZmZsaW5lUXVldWVNYW5hZ2VyKSB7XG5cdFx0XHR0aGlzLm9mZmxpbmVRdWV1ZU1hbmFnZXIgPSBvZmZsaW5lUXVldWVNYW5hZ2VyO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBmaWxlIHRyYWNrZXIuXG5cdCAqIElmIGEgU3VwYWJhc2Ugc2VydmljZSBpcyBhdmFpbGFibGUsIHJlY29uY2lsZSB0aGUgZGF0YWJhc2Ugd2l0aCB0aGUgbG9jYWwgc3luYyBmaWxlLlxuXHQgKi9cblx0YXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc29sZS5sb2coJ1tGaWxlVHJhY2tlci5pbml0aWFsaXplXSBTdGFydGluZyBGaWxlVHJhY2tlciBpbml0aWFsaXphdGlvbicpO1xuXHRcdFx0Y29uc29sZS5sb2coYFtGaWxlVHJhY2tlci5pbml0aWFsaXplXSBTeW5jIGZpbGUgcGF0aDogJHt0aGlzLnN5bmNGaWxlUGF0aH1gKTtcblx0XHRcdC8vIEluaXRpYWxpemUgc3luYyBtYW5hZ2VyIChmYWxsYmFjayBmb3Igb2ZmbGluZSBtb2RlKVxuXHRcdFx0YXdhaXQgdGhpcy5zeW5jTWFuYWdlci5pbml0aWFsaXplKCk7XG5cdFx0XHQvLyBJZiBTdXBhYmFzZSBzZXJ2aWNlIGlzIGF2YWlsYWJsZSwgcmVjb25jaWxlIERCIHN0YXR1cyB3aXRoIGxvY2FsIGZpbGUgc3RhdGUuXG5cdFx0XHRpZiAodGhpcy5zdXBhYmFzZVNlcnZpY2UpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy5yZWNvbmNpbGVEYXRhYmFzZVdpdGhTeW5jRmlsZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ1N1cGFiYXNlIHNlcnZpY2Ugbm90IGF2YWlsYWJsZS4gVXNpbmcgc3luYyBmaWxlIG9ubHkgZm9yIHRyYWNraW5nLicpO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5sb2coJ0ZpbGVUcmFja2VyIGluaXRpYWxpemVkLicpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnRmlsZVRyYWNrZXIuaW5pdGlhbGl6ZScgfSk7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVjb25jaWxlIGRhdGFiYXNlIHJlY29yZHMgd2l0aCBsb2NhbCBzeW5jIGZpbGUgZW50cmllcy5cblx0ICogRW5zdXJlcyB0aGF0IGVhY2ggZmlsZSBpbiB0aGUgdmF1bHQgaGFzIGFuIHVwLXRvLWRhdGUgc3RhdHVzIGluIHRoZSBkYXRhYmFzZS5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgcmVjb25jaWxlRGF0YWJhc2VXaXRoU3luY0ZpbGUoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghdGhpcy5zdXBhYmFzZVNlcnZpY2UpIHJldHVybjtcblx0XHRcdC8vIFJldHJpZXZlIGFsbCBzeW5jIGVudHJpZXMgZnJvbSB0aGUgbG9jYWwgc3luYyBmaWxlXG5cdFx0XHRjb25zdCBzeW5jRW50cmllcyA9IGF3YWl0IHRoaXMuc3luY01hbmFnZXIuZ2V0QWxsU3luY0VudHJpZXMoKTtcblx0XHRcdGNvbnN0IGVudHJpZXNNYXAgPSBuZXcgTWFwKHN5bmNFbnRyaWVzLm1hcChlbnRyeSA9PiBbZW50cnkuZmlsZVBhdGgsIGVudHJ5XSkpO1xuXHRcdFx0Ly8gSXRlcmF0ZSBvdmVyIGFsbCBmaWxlcyBpbiB0aGUgdmF1bHRcblx0XHRcdGNvbnN0IGZpbGVzID0gdGhpcy52YXVsdC5nZXRGaWxlcygpO1xuXHRcdFx0Zm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG5cdFx0XHRcdC8vIE9ubHkgcHJvY2VzcyBtYXJrZG93biBmaWxlcyB0aGF0IGFyZSBub3QgZXhjbHVkZWRcblx0XHRcdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB8fCAhdGhpcy5zaG91bGRUcmFja0ZpbGUoZmlsZS5wYXRoKSkgY29udGludWU7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gR2V0IGZpbGUgc3RhdHVzIGZyb20gdGhlIGRhdGFiYXNlXG5cdFx0XHRcdFx0Y29uc3QgZGJTdGF0dXMgPSBhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS5nZXRGaWxlVmVjdG9yaXphdGlvblN0YXR1cyhmaWxlLnBhdGgpO1xuXHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRIYXNoID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVGaWxlSGFzaChmaWxlKTtcblx0XHRcdFx0XHQvLyBJZiB0aGUgZmlsZSBpcyBtYXJrZWQgYXMgdmVjdG9yaXplZCBidXQgdGhlIGZpbGUgaGFzIGNoYW5nZWQsIHVwZGF0ZSBzdGF0dXMgdG8gUEVORElOR1xuXHRcdFx0XHRcdGlmIChkYlN0YXR1cy5pc1ZlY3Rvcml6ZWQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGZpbGVNb2RpZmllZFNpbmNlRGIgPSBmaWxlLnN0YXQubXRpbWUgPiAoZGJTdGF0dXMubGFzdE1vZGlmaWVkIHx8IDApO1xuXHRcdFx0XHRcdFx0aWYgKGZpbGVNb2RpZmllZFNpbmNlRGIpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLmNyZWF0ZUZpbGVNZXRhZGF0YShmaWxlKTtcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UudXBkYXRlRmlsZVZlY3Rvcml6YXRpb25TdGF0dXMobWV0YWRhdGEpO1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhgRGF0YWJhc2UgcmVjb3JkIHVwZGF0ZWQgdG8gUEVORElORyBmb3IgbW9kaWZpZWQgZmlsZTogJHtmaWxlLnBhdGh9YCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIE5vIHZhbGlkIHJlY29yZCBvciBub3QgdmVjdG9yaXplZCB5ZXRcdTIwMTRjcmVhdGUgb3IgdXBkYXRlIGl0IGluIHRoZSBkYXRhYmFzZVxuXHRcdFx0XHRcdFx0Y29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLmNyZWF0ZUZpbGVNZXRhZGF0YShmaWxlKTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLnVwZGF0ZUZpbGVWZWN0b3JpemF0aW9uU3RhdHVzKG1ldGFkYXRhKTtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGBEYXRhYmFzZSByZWNvcmQgY3JlYXRlZC91cGRhdGVkIGZvciBmaWxlOiAke2ZpbGUucGF0aH1gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0XHRcdGNvbnRleHQ6ICdGaWxlVHJhY2tlci5yZWNvbmNpbGVEYXRhYmFzZVdpdGhTeW5jRmlsZScsXG5cdFx0XHRcdFx0XHRtZXRhZGF0YTogeyBmaWxlUGF0aDogZmlsZS5wYXRoIH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gRm9yIGZpbGVzIHRoYXQgZXhpc3QgaW4gdGhlIHN5bmMgZmlsZSBidXQgYXJlIGRlbGV0ZWQgZnJvbSB0aGUgdmF1bHQsXG5cdFx0XHQvLyBtYXJrIHRoZW0gYXMgZGVsZXRlZCBpbiB0aGUgZGF0YWJhc2UuXG5cdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIHN5bmNFbnRyaWVzKSB7XG5cdFx0XHRcdGNvbnN0IGZpbGUgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChlbnRyeS5maWxlUGF0aCk7XG5cdFx0XHRcdGlmICghZmlsZSAmJiBlbnRyeS5zdGF0dXMgIT09ICdFUlJPUicgJiYgdGhpcy5zdXBhYmFzZVNlcnZpY2UpIHtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS51cGRhdGVGaWxlU3RhdHVzT25EZWxldGUoZW50cnkuZmlsZVBhdGgpO1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGBEYXRhYmFzZSByZWNvcmQgbWFya2VkIGFzIGRlbGV0ZWQgZm9yIGZpbGU6ICR7ZW50cnkuZmlsZVBhdGh9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgcmVjb25jaWxpbmcgZGF0YWJhc2Ugd2l0aCBzeW5jIGZpbGU6JywgZXJyb3IpO1xuXHRcdFx0Ly8gTm9uLWNyaXRpY2FsOyBkbyBub3QgdGhyb3cuXG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgaGFuZGxlQ3JlYXRlKGZpbGU6IFRBYnN0cmFjdEZpbGUpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHx8ICF0aGlzLnNob3VsZFRyYWNrRmlsZShmaWxlLnBhdGgpKSByZXR1cm47XG5cdFx0Y29uc3QgZXZlbnQ6IEZpbGVFdmVudCA9IHsgdHlwZTogJ2NyZWF0ZScsIGZpbGUsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9O1xuXHRcdGF3YWl0IHRoaXMucXVldWVFdmVudChldmVudCk7XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlIGZpbGUgbW9kaWZpY2F0aW9uIGV2ZW50cy5cblx0ICogRW5oYW5jZWQgd2l0aCBjaGFuZ2UgZGV0ZWN0aW9uIGFuZCBpbnRlbGxpZ2VudCBkZWJvdW5jaW5nLlxuXHQgKi9cblx0YXN5bmMgaGFuZGxlTW9kaWZ5KGZpbGU6IFRBYnN0cmFjdEZpbGUpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHx8ICF0aGlzLnNob3VsZFRyYWNrRmlsZShmaWxlKSkgcmV0dXJuO1xuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIENoZWNrIGlmIHRoaXMgZmlsZSB3YXMgcmVjZW50bHkgbW9kaWZpZWRcblx0XHRcdGNvbnN0IHJlY2VudENoYW5nZSA9IHRoaXMucmVjZW50Q2hhbmdlcy5nZXQoZmlsZS5wYXRoKTtcblx0XHRcdGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIGhhc2ggZm9yIGNoYW5nZSBkZXRlY3Rpb25cblx0XHRcdGNvbnN0IGhhc2ggPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUZpbGVIYXNoKGZpbGUpO1xuXG5cdFx0XHQvLyBJZiB0aGUgZmlsZSB3YXMgcmVjZW50bHkgcHJvY2Vzc2VkIGFuZCBjb250ZW50IGhhc24ndCBjaGFuZ2VkLCBkZWJvdW5jZSBtb3JlIGFnZ3Jlc3NpdmVseVxuXHRcdFx0aWYgKHJlY2VudENoYW5nZSAmJlxuXHRcdFx0XHRyZWNlbnRDaGFuZ2UuaGFzaCA9PT0gaGFzaCAmJlxuXHRcdFx0XHQoY3VycmVudFRpbWUgLSByZWNlbnRDaGFuZ2UubGFzdFByb2Nlc3NlZCkgPCAodGhpcy5wcm9jZXNzaW5nVGltZW91dCAqIDIpKSB7XG5cblx0XHRcdFx0Y29uc29sZS5sb2coYFNraXBwaW5nIHJlZHVuZGFudCB1cGRhdGUgZm9yICR7ZmlsZS5wYXRofSAtIGNvbnRlbnQgdW5jaGFuZ2VkYCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZmlsZSB3YXMgcmVjZW50bHkgcHJvY2Vzc2VkIGJ1dCBjb250ZW50IGhhcyBjaGFuZ2VkLCB3ZSdsbCBxdWV1ZSBpdFxuXHRcdFx0aWYgKHJlY2VudENoYW5nZSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhgQ29udGVudCBjaGFuZ2VkIGZvciAke2ZpbGUucGF0aH0uIFByZXZpb3VzIGhhc2g6ICR7cmVjZW50Q2hhbmdlLmhhc2guc3Vic3RyaW5nKDAsIDgpfS4uLiwgTmV3IGhhc2g6ICR7aGFzaC5zdWJzdHJpbmcoMCwgOCl9Li4uYCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSB0aGUgcmVjZW50IGNoYW5nZXMgcmVjb3JkXG5cdFx0XHR0aGlzLnJlY2VudENoYW5nZXMuc2V0KGZpbGUucGF0aCwge1xuXHRcdFx0XHRsYXN0TW9kaWZpZWQ6IGZpbGUuc3RhdC5tdGltZSxcblx0XHRcdFx0aGFzaCxcblx0XHRcdFx0bGFzdFByb2Nlc3NlZDogY3VycmVudFRpbWVcblx0XHRcdH0pO1xuXG5cdFx0XHRjb25zdCBldmVudDogRmlsZUV2ZW50ID0ge1xuXHRcdFx0XHR0eXBlOiAnbW9kaWZ5Jyxcblx0XHRcdFx0ZmlsZSxcblx0XHRcdFx0dGltZXN0YW1wOiBjdXJyZW50VGltZSxcblx0XHRcdFx0aGFzaFxuXHRcdFx0fTtcblxuXHRcdFx0YXdhaXQgdGhpcy5xdWV1ZUV2ZW50KGV2ZW50KTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ0ZpbGVUcmFja2VyLmhhbmRsZU1vZGlmeScsXG5cdFx0XHRcdG1ldGFkYXRhOiB7IGZpbGVQYXRoOiBmaWxlLnBhdGggfVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgaGFuZGxlRGVsZXRlKGZpbGU6IFRBYnN0cmFjdEZpbGUpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHx8ICF0aGlzLnNob3VsZFRyYWNrRmlsZShmaWxlLnBhdGgpKSByZXR1cm47XG5cdFx0Y29uc3QgZXZlbnQ6IEZpbGVFdmVudCA9IHsgdHlwZTogJ2RlbGV0ZScsIGZpbGUsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9O1xuXHRcdGF3YWl0IHRoaXMucXVldWVFdmVudChldmVudCk7XG5cblx0XHQvLyBJZiBvZmZsaW5lIHF1ZXVlIG1hbmFnZXIgaXMgZW5hYmxlZCwgcXVldWUgdGhlIGRlbGV0aW9uIG9wZXJhdGlvbi5cblx0XHRpZiAodGhpcy5vZmZsaW5lUXVldWVNYW5hZ2VyKSB7XG5cdFx0XHRhd2FpdCB0aGlzLm9mZmxpbmVRdWV1ZU1hbmFnZXIucXVldWVPcGVyYXRpb24oe1xuXHRcdFx0XHRvcGVyYXRpb25UeXBlOiAnZGVsZXRlJyxcblx0XHRcdFx0ZmlsZUlkOiBmaWxlLnBhdGgsXG5cdFx0XHRcdHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnN1cGFiYXNlU2VydmljZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UudXBkYXRlRmlsZVN0YXR1c09uRGVsZXRlKGZpbGUucGF0aCk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBkYXRhYmFzZSBmb3IgZGVsZXRlZCBmaWxlOicsIGVycm9yKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gdXBkYXRpbmcgdGhlIHN5bmMgZmlsZVxuXHRcdFx0YXdhaXQgdGhpcy5zeW5jTWFuYWdlci51cGRhdGVTeW5jU3RhdHVzKGZpbGUucGF0aCwgJ09LJywge1xuXHRcdFx0XHRsYXN0TW9kaWZpZWQ6IERhdGUubm93KCksXG5cdFx0XHRcdGhhc2g6ICcnXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRhc3luYyBoYW5kbGVSZW5hbWUoZmlsZTogVEFic3RyYWN0RmlsZSwgb2xkUGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB8fCAhdGhpcy5zaG91bGRUcmFja0ZpbGUoZmlsZS5wYXRoKSkgcmV0dXJuO1xuXHRcdGNvbnN0IGV2ZW50OiBGaWxlRXZlbnQgPSB7IHR5cGU6ICdyZW5hbWUnLCBmaWxlLCBvbGRQYXRoLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfTtcblx0XHRhd2FpdCB0aGlzLnF1ZXVlRXZlbnQoZXZlbnQpO1xuXHRcdGNvbnN0IG5ld0hhc2ggPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUZpbGVIYXNoKGZpbGUpO1xuXHRcdGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5jcmVhdGVGaWxlTWV0YWRhdGEoZmlsZSk7XG5cblx0XHQvLyBJZiBvZmZsaW5lLCBxdWV1ZSByZW5hbWUgb3BlcmF0aW9uXG5cdFx0aWYgKHRoaXMub2ZmbGluZVF1ZXVlTWFuYWdlcikge1xuXHRcdFx0YXdhaXQgdGhpcy5vZmZsaW5lUXVldWVNYW5hZ2VyLnF1ZXVlT3BlcmF0aW9uKHtcblx0XHRcdFx0b3BlcmF0aW9uVHlwZTogJ3JlbmFtZScsXG5cdFx0XHRcdGZpbGVJZDogZmlsZS5wYXRoLFxuXHRcdFx0XHRtZXRhZGF0YTogeyBvbGRQYXRoIH0sXG5cdFx0XHRcdHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnN1cGFiYXNlU2VydmljZSkge1xuXHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UudXBkYXRlRmlsZVZlY3Rvcml6YXRpb25TdGF0dXMobWV0YWRhdGEpO1xuXHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UudXBkYXRlRmlsZVN0YXR1c09uRGVsZXRlKG9sZFBhdGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLnVwZGF0ZVN5bmNTdGF0dXMoZmlsZS5wYXRoLCAnUEVORElORycsIHtcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiBmaWxlLnN0YXQubXRpbWUsXG5cdFx0XHRcdGhhc2g6IG5ld0hhc2hcblx0XHRcdH0pO1xuXHRcdFx0YXdhaXQgdGhpcy5zeW5jTWFuYWdlci51cGRhdGVTeW5jU3RhdHVzKG9sZFBhdGgsICdPSycsIHtcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiBEYXRlLm5vdygpLFxuXHRcdFx0XHRoYXNoOiAnJ1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFF1ZXVlIGFuIGV2ZW50IGZvciBwcm9jZXNzaW5nIHdpdGggaW50ZWxsaWdlbnQgZGVib3VuY2luZy5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgcXVldWVFdmVudChldmVudDogRmlsZUV2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Ly8gQWRkIHRoZSBldmVudCB0byB0aGUgcXVldWVcblx0XHR0aGlzLmV2ZW50UXVldWUucHVzaChldmVudCk7XG5cblx0XHQvLyBJZiBub3QgYWxyZWFkeSBwcm9jZXNzaW5nLCBzdGFydCBhIHRpbWVyIGJhc2VkIG9uIGV2ZW50IHR5cGVcblx0XHRpZiAoIXRoaXMuaXNQcm9jZXNzaW5nKSB7XG5cdFx0XHQvLyBVc2Ugc3RhbmRhcmQgZGVib3VuY2UgdGltZSBmb3IgbW9zdCBldmVudHNcblx0XHRcdGxldCBkZWJvdW5jZVRpbWUgPSB0aGlzLnByb2Nlc3NpbmdUaW1lb3V0O1xuXG5cdFx0XHQvLyBGb3IgZGVsZXRlIGFuZCByZW5hbWUgZXZlbnRzLCB1c2UgYSBzaG9ydGVyIGRlYm91bmNlIHRpbWVcblx0XHRcdGlmIChldmVudC50eXBlID09PSAnZGVsZXRlJyB8fCBldmVudC50eXBlID09PSAncmVuYW1lJykge1xuXHRcdFx0XHRkZWJvdW5jZVRpbWUgPSBNYXRoLm1pbihkZWJvdW5jZVRpbWUgLyAyLCA1MDApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgcmFwaWQgdHlwaW5nIHNjZW5hcmlvcywgdXNlIGEgbG9uZ2VyIGRlYm91bmNlIHRpbWVcblx0XHRcdGlmIChldmVudC50eXBlID09PSAnbW9kaWZ5Jykge1xuXHRcdFx0XHRjb25zdCByZWNlbnRFdmVudHMgPSB0aGlzLmV2ZW50UXVldWUuZmlsdGVyKGUgPT5cblx0XHRcdFx0XHRlLmZpbGUucGF0aCA9PT0gZXZlbnQuZmlsZS5wYXRoICYmXG5cdFx0XHRcdFx0ZS50eXBlID09PSAnbW9kaWZ5JyAmJlxuXHRcdFx0XHRcdChldmVudC50aW1lc3RhbXAgLSBlLnRpbWVzdGFtcCkgPCA1MDAwXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKHJlY2VudEV2ZW50cy5sZW5ndGggPiAzKSB7XG5cdFx0XHRcdFx0Ly8gTXVsdGlwbGUgcmFwaWQgY2hhbmdlcyBkZXRlY3RlZCwgaW5jcmVhc2UgZGVib3VuY2UgdGltZVxuXHRcdFx0XHRcdGRlYm91bmNlVGltZSA9IE1hdGgubWF4KGRlYm91bmNlVGltZSAqIDIsIDMwMDApO1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGBJbmNyZWFzZWQgZGVib3VuY2UgdGltZSB0byAke2RlYm91bmNlVGltZX1tcyBmb3IgcmFwaWQgY2hhbmdlcyB0byAke2V2ZW50LmZpbGUucGF0aH1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IHRoaXMucHJvY2Vzc0V2ZW50UXVldWUoKSwgZGVib3VuY2VUaW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUHJvY2VzcyB0aGUgZXZlbnQgcXVldWUgd2l0aCBpbXByb3ZlZCBjb25mbGljdCBoYW5kbGluZy5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc0V2ZW50UXVldWUoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKHRoaXMuaXNQcm9jZXNzaW5nIHx8IHRoaXMuZXZlbnRRdWV1ZS5sZW5ndGggPT09IDApIHJldHVybjtcblxuXHRcdHRoaXMuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcblx0XHRjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyAke3RoaXMuZXZlbnRRdWV1ZS5sZW5ndGh9IHF1ZXVlZCBldmVudHNgKTtcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBHcm91cCBldmVudHMgYnkgZmlsZSBwYXRoIGZvciBpbnRlbGxpZ2VudCBwcm9jZXNzaW5nXG5cdFx0XHRjb25zdCBldmVudHNCeVBhdGggPSBuZXcgTWFwPHN0cmluZywgRmlsZUV2ZW50W10+KCk7XG5cblx0XHRcdGZvciAoY29uc3QgZXZlbnQgb2YgdGhpcy5ldmVudFF1ZXVlKSB7XG5cdFx0XHRcdGNvbnN0IHBhdGggPSBldmVudC5maWxlLnBhdGg7XG5cdFx0XHRcdGlmICghZXZlbnRzQnlQYXRoLmhhcyhwYXRoKSkge1xuXHRcdFx0XHRcdGV2ZW50c0J5UGF0aC5zZXQocGF0aCwgW10pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGV2ZW50c0J5UGF0aC5nZXQocGF0aCk/LnB1c2goZXZlbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQcm9jZXNzIGV2ZW50cyBmb3IgZWFjaCBmaWxlIHdpdGggcHJvcGVyIHByaW9yaXRpemF0aW9uXG5cdFx0XHRjb25zdCBwYXRocyA9IEFycmF5LmZyb20oZXZlbnRzQnlQYXRoLmtleXMoKSk7XG5cblx0XHRcdC8vIFByb2Nlc3MgZGVsZXRlIG9wZXJhdGlvbnMgZmlyc3Rcblx0XHRcdGNvbnN0IGRlbGV0ZUZpcnN0ID0gcGF0aHMuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0XHRjb25zdCBhSGFzRGVsZXRlID0gZXZlbnRzQnlQYXRoLmdldChhKT8uc29tZShlID0+IGUudHlwZSA9PT0gJ2RlbGV0ZScpID8/IGZhbHNlO1xuXHRcdFx0XHRjb25zdCBiSGFzRGVsZXRlID0gZXZlbnRzQnlQYXRoLmdldChiKT8uc29tZShlID0+IGUudHlwZSA9PT0gJ2RlbGV0ZScpID8/IGZhbHNlO1xuXG5cdFx0XHRcdGlmIChhSGFzRGVsZXRlICYmICFiSGFzRGVsZXRlKSByZXR1cm4gLTE7XG5cdFx0XHRcdGlmICghYUhhc0RlbGV0ZSAmJiBiSGFzRGVsZXRlKSByZXR1cm4gMTtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9KTtcblxuXHRcdFx0Zm9yIChjb25zdCBwYXRoIG9mIGRlbGV0ZUZpcnN0KSB7XG5cdFx0XHRcdGNvbnN0IGV2ZW50cyA9IGV2ZW50c0J5UGF0aC5nZXQocGF0aCk7XG5cdFx0XHRcdGlmIChldmVudHMpIHtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnByb2Nlc3NGaWxlRXZlbnRzKHBhdGgsIGV2ZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdGhlIGV2ZW50IHF1ZXVlXG5cdFx0XHR0aGlzLmV2ZW50UXVldWUgPSBbXTtcblxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnRmlsZVRyYWNrZXIucHJvY2Vzc0V2ZW50UXVldWUnIH0pO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBJZiBldmVudHMgd2VyZSBhZGRlZCBkdXJpbmcgcHJvY2Vzc2luZywgdHJpZ2dlciBhbm90aGVyIHByb2Nlc3MgY3ljbGVcblx0XHRcdGlmICh0aGlzLmV2ZW50UXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHRoaXMucHJvY2Vzc0V2ZW50UXVldWUoKSwgMTAwKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUHJvY2VzcyBhbGwgZXZlbnRzIGZvciBhIHNpbmdsZSBmaWxlIHdpdGggaW1wcm92ZWQgY2hhbmdlIGRldGVjdGlvbi5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc0ZpbGVFdmVudHMocGF0aDogc3RyaW5nLCBldmVudHM6IEZpbGVFdmVudFtdKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Ly8gU29ydCBldmVudHMgYnkgdGltZXN0YW1wIHRvIGVuc3VyZSBjb3JyZWN0IG9yZGVyXG5cdFx0ZXZlbnRzLnNvcnQoKGEsIGIpID0+IGEudGltZXN0YW1wIC0gYi50aW1lc3RhbXApO1xuXG5cdFx0Ly8gR2V0IHRoZSBmaW5hbCBldmVudCBhZnRlciBhbGwgY2hhbmdlc1xuXHRcdGNvbnN0IGZpbmFsRXZlbnQgPSBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdO1xuXG5cdFx0Y29uc29sZS5sb2coYFByb2Nlc3NpbmcgJHtldmVudHMubGVuZ3RofSBldmVudHMgZm9yICR7cGF0aH0sIGZpbmFsIGV2ZW50OiAke2ZpbmFsRXZlbnQudHlwZX1gKTtcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBEZWxldGUgZXZlbnRzIGFyZSBoYW5kbGVkIGltbWVkaWF0ZWx5IGluIGhhbmRsZURlbGV0ZSwgbm8gZnVydGhlciBwcm9jZXNzaW5nIG5lZWRlZFxuXHRcdFx0aWYgKGZpbmFsRXZlbnQudHlwZSA9PT0gJ2RlbGV0ZScpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coYFNraXBwaW5nIGZ1cnRoZXIgcHJvY2Vzc2luZyBmb3IgZGVsZXRlZCBmaWxlOiAke3BhdGh9YCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2V0IHRoZSBoYXNoIGVpdGhlciBmcm9tIHRoZSBldmVudCBvciBjYWxjdWxhdGUgaXRcblx0XHRcdGNvbnN0IG5ld0hhc2ggPSBmaW5hbEV2ZW50Lmhhc2ggfHwgYXdhaXQgdGhpcy5jYWxjdWxhdGVGaWxlSGFzaChmaW5hbEV2ZW50LmZpbGUpO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgdGhlIGZpbGUgbmVlZHMgdmVjdG9yaXppbmcgYmFzZWQgb24gYXZhaWxhYmxlIHNlcnZpY2VzXG5cdFx0XHRsZXQgbmVlZHNWZWN0b3JpemluZyA9IHRydWU7XG5cblx0XHRcdGlmICh0aGlzLnN1cGFiYXNlU2VydmljZSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdG5lZWRzVmVjdG9yaXppbmcgPSBhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS5uZWVkc1ZlY3Rvcml6aW5nKFxuXHRcdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHRcdGZpbmFsRXZlbnQuZmlsZS5zdGF0Lm10aW1lLFxuXHRcdFx0XHRcdFx0bmV3SGFzaFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAoIW5lZWRzVmVjdG9yaXppbmcpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGBGaWxlICR7cGF0aH0gZG9lcyBub3QgbmVlZCB2ZWN0b3JpemluZyAtIG5vIHNpZ25pZmljYW50IGNoYW5nZXNgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgaWYgZmlsZSBuZWVkcyB2ZWN0b3JpemluZzonLCBlcnJvcik7XG5cdFx0XHRcdFx0bmVlZHNWZWN0b3JpemluZyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHN5bmMgZmlsZSBzdGF0dXMgY2hlY2tcblx0XHRcdFx0Y29uc3Qgc3luY1N0YXR1cyA9IGF3YWl0IHRoaXMuc3luY01hbmFnZXIuZ2V0U3luY1N0YXR1cyhwYXRoKTtcblxuXHRcdFx0XHRpZiAoc3luY1N0YXR1cyAmJlxuXHRcdFx0XHRcdHN5bmNTdGF0dXMuaGFzaCA9PT0gbmV3SGFzaCAmJlxuXHRcdFx0XHRcdGZpbmFsRXZlbnQuZmlsZS5zdGF0Lm10aW1lIDw9IHN5bmNTdGF0dXMubGFzdE1vZGlmaWVkICYmXG5cdFx0XHRcdFx0c3luY1N0YXR1cy5zdGF0dXMgIT09ICdQRU5ESU5HJykge1xuXG5cdFx0XHRcdFx0bmVlZHNWZWN0b3JpemluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGBGaWxlICR7cGF0aH0gZG9lcyBub3QgbmVlZCB2ZWN0b3JpemluZyBhY2NvcmRpbmcgdG8gc3luYyBmaWxlIHN0YXR1c2ApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSB0cmFja2luZyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdmVjdG9yaXphdGlvbiBpcyBuZWVkZWRcblx0XHRcdHRoaXMucmVjZW50Q2hhbmdlcy5zZXQocGF0aCwge1xuXHRcdFx0XHRsYXN0TW9kaWZpZWQ6IGZpbmFsRXZlbnQuZmlsZS5zdGF0Lm10aW1lLFxuXHRcdFx0XHRoYXNoOiBuZXdIYXNoLFxuXHRcdFx0XHRsYXN0UHJvY2Vzc2VkOiBEYXRlLm5vdygpXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gT25seSBwcm9jZWVkIHdpdGggdmVjdG9yaXphdGlvbiBpZiBuZWVkZWRcblx0XHRcdGlmIChuZWVkc1ZlY3Rvcml6aW5nKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGBVcGRhdGluZyBzdGF0dXMgZm9yICR7cGF0aH0gd2l0aCBoYXNoICR7bmV3SGFzaC5zdWJzdHJpbmcoMCwgOCl9Li4uYCk7XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIG1ldGFkYXRhIHdpdGggY29udGVudCBoYXNoIGZvciByZWxpYWJsZSBjaGFuZ2UgZGV0ZWN0aW9uXG5cdFx0XHRcdGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5jcmVhdGVGaWxlTWV0YWRhdGEoZmluYWxFdmVudC5maWxlKTtcblx0XHRcdFx0bWV0YWRhdGEuY3VzdG9tTWV0YWRhdGEuY29udGVudEhhc2ggPSBuZXdIYXNoO1xuXG5cdFx0XHRcdGlmICh0aGlzLnN1cGFiYXNlU2VydmljZSkge1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLnVwZGF0ZUZpbGVWZWN0b3JpemF0aW9uU3RhdHVzKG1ldGFkYXRhKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLnVwZGF0ZVN5bmNTdGF0dXMocGF0aCwgJ1BFTkRJTkcnLCB7XG5cdFx0XHRcdFx0XHRsYXN0TW9kaWZpZWQ6IGZpbmFsRXZlbnQuZmlsZS5zdGF0Lm10aW1lLFxuXHRcdFx0XHRcdFx0aGFzaDogbmV3SGFzaFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7XG5cdFx0XHRcdGNvbnRleHQ6ICdGaWxlVHJhY2tlci5wcm9jZXNzRmlsZUV2ZW50cycsXG5cdFx0XHRcdG1ldGFkYXRhOiB7IHBhdGgsIGV2ZW50VHlwZTogZmluYWxFdmVudC50eXBlIH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgY2FsY3VsYXRlRmlsZUhhc2goZmlsZTogVEZpbGUpOiBQcm9taXNlPHN0cmluZz4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkKGZpbGUpO1xuXHRcdFx0cmV0dXJuIGF3YWl0IHRoaXMuaGFzaFN0cmluZyhjb250ZW50KTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ0ZpbGVUcmFja2VyLmNhbGN1bGF0ZUZpbGVIYXNoJywgbWV0YWRhdGE6IHsgZmlsZVBhdGg6IGZpbGUucGF0aCB9IH0pO1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgaGFzaFN0cmluZyhzdHI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG5cdFx0Y29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXHRcdGNvbnN0IGRhdGEgPSBlbmNvZGVyLmVuY29kZShzdHIpO1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgZGF0YSk7XG5cdFx0cmV0dXJuIEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSlcblx0XHRcdC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKVxuXHRcdFx0LmpvaW4oJycpO1xuXHR9XG5cblx0cHVibGljIGFzeW5jIGNyZWF0ZUZpbGVNZXRhZGF0YShmaWxlOiBURmlsZSk6IFByb21pc2U8RG9jdW1lbnRNZXRhZGF0YT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkKGZpbGUpO1xuXHRcdFx0Y29uc3QgbGluZUNvdW50ID0gY29udGVudC5zcGxpdCgnXFxuJykubGVuZ3RoO1xuXHRcdFx0bGV0IGFkZGl0aW9uYWxNZXRhZGF0YSA9IHt9O1xuXHRcdFx0aWYgKHRoaXMuc3VwYWJhc2VTZXJ2aWNlKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UuZ2V0RmlsZVZlY3Rvcml6YXRpb25TdGF0dXMoZmlsZS5wYXRoKTtcblx0XHRcdFx0XHRpZiAoc3RhdHVzLmlzVmVjdG9yaXplZCkge1xuXHRcdFx0XHRcdFx0YWRkaXRpb25hbE1ldGFkYXRhID0ge1xuXHRcdFx0XHRcdFx0XHRsYXN0VmVjdG9yaXplZDogc3RhdHVzLmxhc3RWZWN0b3JpemVkLFxuXHRcdFx0XHRcdFx0XHRjb250ZW50SGFzaDogc3RhdHVzLmNvbnRlbnRIYXNoXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGZpbGUgc3RhdHVzIGZyb20gZGF0YWJhc2U6JywgZXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRvYnNpZGlhbklkOiBmaWxlLnBhdGgsXG5cdFx0XHRcdHBhdGg6IGZpbGUucGF0aCxcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiBmaWxlLnN0YXQubXRpbWUsXG5cdFx0XHRcdGNyZWF0ZWQ6IGZpbGUuc3RhdC5jdGltZSxcblx0XHRcdFx0c2l6ZTogZmlsZS5zdGF0LnNpemUsXG5cdFx0XHRcdGN1c3RvbU1ldGFkYXRhOiB7IC4uLmFkZGl0aW9uYWxNZXRhZGF0YSB9LFxuXHRcdFx0XHRsb2M6IHsgbGluZXM6IHsgZnJvbTogMSwgdG86IGxpbmVDb3VudCB9IH0sXG5cdFx0XHRcdHNvdXJjZTogXCJvYnNpZGlhblwiLFxuXHRcdFx0XHRmaWxlX2lkOiBmaWxlLnBhdGgsXG5cdFx0XHRcdGJsb2JUeXBlOiBcInRleHQvbWFya2Rvd25cIlxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ0ZpbGVUcmFja2VyLmNyZWF0ZUZpbGVNZXRhZGF0YScsIG1ldGFkYXRhOiB7IGZpbGVQYXRoOiBmaWxlLnBhdGggfSB9KTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG9ic2lkaWFuSWQ6IGZpbGUucGF0aCxcblx0XHRcdFx0cGF0aDogZmlsZS5wYXRoLFxuXHRcdFx0XHRsYXN0TW9kaWZpZWQ6IGZpbGUuc3RhdC5tdGltZSxcblx0XHRcdFx0Y3JlYXRlZDogZmlsZS5zdGF0LmN0aW1lLFxuXHRcdFx0XHRzaXplOiBmaWxlLnN0YXQuc2l6ZSxcblx0XHRcdFx0Y3VzdG9tTWV0YWRhdGE6IHt9XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhIGZpbGUgc2hvdWxkIGJlIHRyYWNrZWQgYW5kIHByb2Nlc3NlZC5cblx0ICogRW5oYW5jZWQgd2l0aCBhZGRpdGlvbmFsIGV4Y2x1c2lvbiBsb2dpYy5cblx0ICovXG5cdHByaXZhdGUgc2hvdWxkVHJhY2tGaWxlKGZpbGU6IFRGaWxlKTogYm9vbGVhbiB7XG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzIHx8ICFpc1ZhdWx0SW5pdGlhbGl6ZWQodGhpcy5zZXR0aW5ncykpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuc2V0dGluZ3MuZW5hYmxlQXV0b1N5bmMpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBHZXQgY29tYmluZWQgZXhjbHVzaW9ucyAoc3lzdGVtICsgdXNlcilcblx0XHRjb25zdCBhbGxFeGNsdXNpb25zID0gZ2V0QWxsRXhjbHVzaW9ucyh0aGlzLnNldHRpbmdzKTtcblxuXHRcdGNvbnN0IGZpbGVQYXRoID0gZmlsZS5wYXRoO1xuXHRcdGNvbnN0IGZpbGVOYW1lID0gZmlsZS5uYW1lO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgc3luYyBmaWxlIGRpcmVjdGx5XG5cdFx0aWYgKGZpbGVQYXRoID09PSB0aGlzLnNldHRpbmdzLnN5bmMuc3luY0ZpbGVQYXRoIHx8XG5cdFx0XHRmaWxlUGF0aCA9PT0gdGhpcy5zZXR0aW5ncy5zeW5jLnN5bmNGaWxlUGF0aCArICcuYmFja3VwJykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciBub24tdGV4dCBiYXNlZFxuXHRcdGNvbnN0IGlzQmluYXJ5RmlsZSA9IHRoaXMuaXNCaW5hcnlGaWxlKGZpbGVOYW1lKTtcblx0XHRpZiAoaXNCaW5hcnlGaWxlKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhgU2tpcHBpbmcgYmluYXJ5IGZpbGU6ICR7ZmlsZU5hbWV9YCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZmlsZSBzaXplIGNvbnN0cmFpbnRzIC0gc2tpcCBleHRyZW1lbHkgbGFyZ2UgZmlsZXNcblx0XHRpZiAoZmlsZS5zdGF0LnNpemUgPiB0aGlzLm1heEZpbGVTaXplQnl0ZXMpIHtcblx0XHRcdGNvbnNvbGUubG9nKGBTa2lwcGluZyBmaWxlIGV4Y2VlZGluZyBzaXplIGxpbWl0OiAke2ZpbGVOYW1lfSAoJHtmaWxlLnN0YXQuc2l6ZX0gYnl0ZXMpYCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZXhjbHVkZWQgZmlsZXNcblx0XHRpZiAoQXJyYXkuaXNBcnJheShhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMpICYmXG5cdFx0XHRhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMuaW5jbHVkZXMoZmlsZU5hbWUpKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnU2tpcHBpbmcgZXhjbHVkZWQgZmlsZTonLCBmaWxlTmFtZSk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZXhjbHVkZWQgZm9sZGVyc1xuXHRcdGlmIChBcnJheS5pc0FycmF5KGFsbEV4Y2x1c2lvbnMuZXhjbHVkZWRGb2xkZXJzKSkge1xuXHRcdFx0Y29uc3QgaXNFeGNsdWRlZEZvbGRlciA9IGFsbEV4Y2x1c2lvbnMuZXhjbHVkZWRGb2xkZXJzLnNvbWUoZm9sZGVyID0+IHtcblx0XHRcdFx0Y29uc3Qgbm9ybWFsaXplZEZvbGRlciA9IGZvbGRlci5lbmRzV2l0aCgnLycpID8gZm9sZGVyIDogZm9sZGVyICsgJy8nO1xuXHRcdFx0XHRyZXR1cm4gZmlsZVBhdGguc3RhcnRzV2l0aChub3JtYWxpemVkRm9sZGVyKTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKGlzRXhjbHVkZWRGb2xkZXIpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ1NraXBwaW5nIGZpbGUgaW4gZXhjbHVkZWQgZm9sZGVyOicsIGZpbGVQYXRoKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENoZWNrIGV4Y2x1ZGVkIGZpbGUgdHlwZXNcblx0XHRpZiAoQXJyYXkuaXNBcnJheShhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVR5cGVzKSkge1xuXHRcdFx0Y29uc3QgaXNFeGNsdWRlZFR5cGUgPSBhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVR5cGVzLnNvbWUoXG5cdFx0XHRcdGV4dCA9PiBmaWxlUGF0aC50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dC50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0KTtcblx0XHRcdGlmIChpc0V4Y2x1ZGVkVHlwZSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnU2tpcHBpbmcgZXhjbHVkZWQgZmlsZSB0eXBlOicsIGZpbGVQYXRoKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENoZWNrIGV4Y2x1ZGVkIGZpbGUgcHJlZml4ZXNcblx0XHRpZiAoQXJyYXkuaXNBcnJheShhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVByZWZpeGVzKSkge1xuXHRcdFx0Y29uc3QgaXNFeGNsdWRlZFByZWZpeCA9IGFsbEV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlUHJlZml4ZXMuc29tZShcblx0XHRcdFx0cHJlZml4ID0+IGZpbGVOYW1lLnN0YXJ0c1dpdGgocHJlZml4KVxuXHRcdFx0KTtcblx0XHRcdGlmIChpc0V4Y2x1ZGVkUHJlZml4KSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdTa2lwcGluZyBmaWxlIHdpdGggZXhjbHVkZWQgcHJlZml4OicsIGZpbGVOYW1lKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblxuXHQvKipcblx0ICogUmV0cmlldmUgc3luYyBzdGF0dXMgZm9yIGEgZ2l2ZW4gZmlsZSBmcm9tIHRoZSBzeW5jIGZpbGUuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgZ2V0U3luY1N0YXR1cyhwYXRoOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gYXdhaXQgdGhpcy5zeW5jTWFuYWdlci5nZXRTeW5jU3RhdHVzKHBhdGgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlIGFsbCBzeW5jIHN0YXR1c2VzLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGdldEFsbFN5bmNTdGF0dXNlcygpIHtcblx0XHRyZXR1cm4gYXdhaXQgdGhpcy5zeW5jTWFuYWdlci5nZXRBbGxTeW5jRW50cmllcygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFsbG93cyBsYXRlIGJpbmRpbmcgb2YgdGhlIFN1cGFiYXNlIHNlcnZpY2UuXG5cdCAqL1xuXHRwdWJsaWMgc2V0U3VwYWJhc2VTZXJ2aWNlKHNlcnZpY2U6IFN1cGFiYXNlU2VydmljZSk6IHZvaWQge1xuXHRcdHRoaXMuc3VwYWJhc2VTZXJ2aWNlID0gc2VydmljZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhciB0aGUgZXZlbnQgcXVldWUuXG5cdCAqL1xuXHRwdWJsaWMgY2xlYXJRdWV1ZSgpOiB2b2lkIHtcblx0XHR0aGlzLmV2ZW50UXVldWUgPSBbXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIHByb2Nlc3NpbmcgdGltZW91dC5cblx0ICovXG5cdHB1YmxpYyBzZXRQcm9jZXNzaW5nVGltZW91dCh0aW1lb3V0OiBudW1iZXIpOiB2b2lkIHtcblx0XHR0aGlzLnByb2Nlc3NpbmdUaW1lb3V0ID0gdGltZW91dDtcblx0fVxuXG5cdC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIGEgZmlsZSBpcyBsaWtlbHkgYmluYXJ5IGJhc2VkIG9uIGV4dGVuc2lvblxuICAgICovXG5cdHByaXZhdGUgaXNCaW5hcnlGaWxlKGZpbGVOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcblx0XHRjb25zdCBiaW5hcnlFeHRlbnNpb25zID0gW1xuXHRcdFx0Jy5qcGcnLCAnLmpwZWcnLCAnLnBuZycsICcuZ2lmJywgJy5ibXAnLCAnLnRpZmYnLCAnLmljbycsXG5cdFx0XHQnLnBkZicsICcuemlwJywgJy43eicsICcucmFyJywgJy50YXInLCAnLmd6Jyxcblx0XHRcdCcubXAzJywgJy5tcDQnLCAnLndhdicsICcub2dnJywgJy5mbGFjJyxcblx0XHRcdCcuZXhlJywgJy5kbGwnLCAnLnNvJywgJy5keWxpYicsXG5cdFx0XHQnLmRiJywgJy5zcWxpdGUnXG5cdFx0XTtcblxuXHRcdHJldHVybiBiaW5hcnlFeHRlbnNpb25zLnNvbWUoZXh0ID0+XG5cdFx0XHRmaWxlTmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dClcblx0XHQpO1xuXHR9XG59XG4iLCAiLy8gc3JjL3NlcnZpY2VzL1N5bmNGaWxlTWFuYWdlci50c1xuaW1wb3J0IHsgVEZpbGUsIFZhdWx0LCBwYXJzZVlhbWwsIHN0cmluZ2lmeVlhbWwgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBFcnJvckhhbmRsZXIgfSBmcm9tICcuLi91dGlscy9FcnJvckhhbmRsZXInO1xuaW1wb3J0IHsgRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IgfSBmcm9tICcuLi9tb2RlbHMvRG9jdW1lbnRDaHVuayc7XG5pbXBvcnQge1xuXHRTeW5jRmlsZURhdGEsXG5cdFN5bmNWYWxpZGF0aW9uUmVzdWx0LFxuXHRTeW5jRXJyb3JUeXBlLFxuXHRTeW5jU3RhdGUsXG5cdGNyZWF0ZUVtcHR5U3luY0ZpbGVEYXRhLFxuXHR1cGRhdGVEZXZpY2VJblN5bmNGaWxlLFxuXHRhZGRDb25uZWN0aW9uRXZlbnQsXG5cdHVwZGF0ZURhdGFiYXNlU3RhdHVzLFxuXHR1cGRhdGVEZXZpY2VTeW5jVGltZSxcblx0dHJpbVN5bmNIaXN0b3J5QXJyYXlzLFxuXHRTeW5jQ29uZmxpY3Rcbn0gZnJvbSAnLi4vbW9kZWxzL1N5bmNNb2RlbHMnO1xuXG5leHBvcnQgY2xhc3MgU3luY0ZpbGVNYW5hZ2VyIHtcblx0cHJpdmF0ZSBzeW5jRmlsZVBhdGg6IHN0cmluZztcblx0cHJpdmF0ZSBiYWNrdXBQYXRoOiBzdHJpbmc7XG5cdHByaXZhdGUgbGFzdEJhY2t1cDogbnVtYmVyID0gMDtcblx0cHJpdmF0ZSBiYWNrdXBJbnRlcnZhbDogbnVtYmVyO1xuXHRwcml2YXRlIHN5bmNGaWxlOiBURmlsZSB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIGN1cnJlbnRTeW5jRGF0YTogU3luY0ZpbGVEYXRhIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgdmF1bHRJZDogc3RyaW5nO1xuXHRwcml2YXRlIGRldmljZUlkOiBzdHJpbmc7XG5cdHByaXZhdGUgZGV2aWNlTmFtZTogc3RyaW5nO1xuXHRwcml2YXRlIHBsdWdpblZlcnNpb246IHN0cmluZztcblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRwcml2YXRlIHZhdWx0OiBWYXVsdCxcblx0XHRwcml2YXRlIGVycm9ySGFuZGxlcjogRXJyb3JIYW5kbGVyLFxuXHRcdHN5bmNGaWxlUGF0aDogc3RyaW5nID0gJ19taW5kbWF0cml4c3luYy5tZCcsXG5cdFx0YmFja3VwSW50ZXJ2YWw6IG51bWJlciA9IDM2MDAwMDAsIC8vIDEgaG91ciBpbiBtaWxsaXNlY29uZHNcblx0XHR2YXVsdElkOiBzdHJpbmcsXG5cdFx0ZGV2aWNlSWQ6IHN0cmluZyxcblx0XHRkZXZpY2VOYW1lOiBzdHJpbmcsXG5cdFx0cGx1Z2luVmVyc2lvbjogc3RyaW5nXG5cdCkge1xuXHRcdHRoaXMuc3luY0ZpbGVQYXRoID0gc3luY0ZpbGVQYXRoO1xuXHRcdHRoaXMuYmFja3VwUGF0aCA9IGAke3N5bmNGaWxlUGF0aH0uYmFja3VwYDtcblx0XHR0aGlzLmJhY2t1cEludGVydmFsID0gYmFja3VwSW50ZXJ2YWw7XG5cdFx0dGhpcy52YXVsdElkID0gdmF1bHRJZDtcblx0XHR0aGlzLmRldmljZUlkID0gZGV2aWNlSWQ7XG5cdFx0dGhpcy5kZXZpY2VOYW1lID0gZGV2aWNlTmFtZTtcblx0XHR0aGlzLnBsdWdpblZlcnNpb24gPSBwbHVnaW5WZXJzaW9uO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgb3IgdmFsaWRhdGUgdGhlIHN5bmMgZmlsZVxuXHQgKi9cblx0YXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPFN5bmNWYWxpZGF0aW9uUmVzdWx0PiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIENoZWNrIGlmIHN5bmMgZmlsZSBleGlzdHNcblx0XHRcdGNvbnN0IGV4aXN0aW5nRmlsZSA9IHRoaXMudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMuc3luY0ZpbGVQYXRoKTtcblx0XHRcdGlmIChleGlzdGluZ0ZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0XHR0aGlzLnN5bmNGaWxlID0gZXhpc3RpbmdGaWxlO1xuXHRcdFx0XHQvLyBWYWxpZGF0ZSBleGlzdGluZyBmaWxlIGFuZCBwYXJzZSBpdHMgY29udGVudHNcblx0XHRcdFx0Y29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMudmFsaWRhdGVTeW5jRmlsZSgpO1xuXHRcdFx0XHRpZiAoIXZhbGlkYXRpb25SZXN1bHQuaXNWYWxpZCkge1xuXHRcdFx0XHRcdGNvbnN0IHJlY292ZXJlZCA9IGF3YWl0IHRoaXMucmVwYWlyU3luY0ZpbGUoKTtcblx0XHRcdFx0XHRpZiAoIXJlY292ZXJlZCkge1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVTeW5jRmlsZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQ3JlYXRlIG5ldyBzeW5jIGZpbGVcblx0XHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVTeW5jRmlsZSgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ3JlYXRlIGluaXRpYWwgYmFja3VwXG5cdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZUJhY2t1cCgpO1xuXHRcdFx0cmV0dXJuIGF3YWl0IHRoaXMudmFsaWRhdGVTeW5jRmlsZSgpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0XHRjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLmluaXRpYWxpemUnLFxuXHRcdFx0XHRtZXRhZGF0YTogeyBzeW5jRmlsZVBhdGg6IHRoaXMuc3luY0ZpbGVQYXRoIH1cblx0XHRcdH0pO1xuXHRcdFx0Ly8gVHJ5IHRvIGNyZWF0ZSBhIG5ldyBmaWxlIGFzIGEgbGFzdCByZXNvcnRcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMuY3JlYXRlU3luY0ZpbGUoKTtcblx0XHRcdFx0cmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xuXHRcdFx0fSBjYXRjaCAoY3JlYXRlRXJyb3IpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpc1ZhbGlkOiBmYWxzZSxcblx0XHRcdFx0XHRlcnJvcjogYEZhaWxlZCB0byBpbml0aWFsaXplIHN5bmMgZmlsZTogJHtjcmVhdGVFcnJvci5tZXNzYWdlfWBcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIGEgbmV3IHN5bmMgZmlsZSB3aXRoIHRoZSBuZXcgc3RydWN0dXJlXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIGNyZWF0ZVN5bmNGaWxlKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnNvbGUubG9nKCdTdGFydGluZyBzeW5jIGZpbGUgY3JlYXRpb24gd2l0aCB3YWl0IHBlcmlvZHMuLi4nKTtcblxuXHRcdC8vIEluY3JlYXNlZCBkZWxheSBmb3Igc2FmZXIgZmlsZSBvcGVyYXRpb25zXG5cdFx0Y29uc3QgRklMRV9PUF9ERUxBWSA9IDEwMDA7IC8vIDEgc2Vjb25kXG5cblx0XHQvLyBGaXJzdCBjaGVjayBpZiB0aGUgZmlsZSBleGlzdHNcblx0XHRjb25zdCBleGlzdGluZ0ZpbGUgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLnN5bmNGaWxlUGF0aCk7XG5cblx0XHQvLyBDcmVhdGUgbmV3IHN5bmMgZGF0YVxuXHRcdHRoaXMuY3VycmVudFN5bmNEYXRhID0gY3JlYXRlRW1wdHlTeW5jRmlsZURhdGEoXG5cdFx0XHR0aGlzLnZhdWx0SWQsXG5cdFx0XHR0aGlzLmRldmljZUlkLFxuXHRcdFx0dGhpcy5kZXZpY2VOYW1lLFxuXHRcdFx0dGhpcy5wbHVnaW5WZXJzaW9uXG5cdFx0KTtcblxuXHRcdC8vIEdlbmVyYXRlIGluaXRpYWwgY29udGVudFxuXHRcdGNvbnN0IGluaXRpYWxDb250ZW50ID0gdGhpcy5nZW5lcmF0ZVN5bmNGaWxlQ29udGVudCh0aGlzLmN1cnJlbnRTeW5jRGF0YSk7XG5cblx0XHQvLyBJZiBmaWxlIGV4aXN0cywgcHJpb3JpdGl6ZSBtb2RpZnlpbmcgaXQgaW5zdGVhZCBvZiBkZWxldGluZyBhbmQgcmVjcmVhdGluZ1xuXHRcdGlmIChleGlzdGluZ0ZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0V4aXN0aW5nIHN5bmMgZmlsZSBmb3VuZCwgYXR0ZW1wdGluZyB0byBtb2RpZnkgaXQnKTtcblx0XHRcdFx0dGhpcy5zeW5jRmlsZSA9IGV4aXN0aW5nRmlsZTtcblx0XHRcdFx0YXdhaXQgdGhpcy52YXVsdC5tb2RpZnkoZXhpc3RpbmdGaWxlLCBpbml0aWFsQ29udGVudCk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgbW9kaWZpZWQgZXhpc3Rpbmcgc3luYyBmaWxlJyk7XG5cblx0XHRcdFx0Ly8gV2FpdCBhIGJpdCB0byBlbnN1cmUgZmlsZSBzeXN0ZW0gb3BlcmF0aW9ucyBjb21wbGV0ZVxuXHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgRklMRV9PUF9ERUxBWSkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGNhdGNoIChtb2RpZnlFcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBtb2RpZnkgZXhpc3Rpbmcgc3luYyBmaWxlLCB3aWxsIHRyeSBkZWxldGUgYW5kIHJlY3JlYXRlOicsIG1vZGlmeUVycm9yKTtcblxuXHRcdFx0XHQvLyBJZiBtb2RpZmljYXRpb24gZmFpbHMsIHRyeSBkZWxldGUgYW5kIHJlY3JlYXRlIGFwcHJvYWNoXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy52YXVsdC5kZWxldGUoZXhpc3RpbmdGaWxlKTtcblx0XHRcdFx0XHQvLyBMb25nZXIgZGVsYXkgYWZ0ZXIgZGVsZXRpb25cblx0XHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgRklMRV9PUF9ERUxBWSkpO1xuXHRcdFx0XHR9IGNhdGNoIChkZWxldGVFcnJvcikge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgZXhpc3Rpbmcgc3luYyBmaWxlOicsIGRlbGV0ZUVycm9yKTtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBtb2RpZnkgb3IgZGVsZXRlIHN5bmMgZmlsZTogJHttb2RpZnlFcnJvci5tZXNzYWdlfSwgJHtkZWxldGVFcnJvci5tZXNzYWdlfWApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlsZSBkb2Vzbid0IGV4aXN0IG9yIHdhcyBkZWxldGVkLCBwcm9jZWVkIHdpdGggY3JlYXRpb25cblx0XHRjb25zb2xlLmxvZygnV2FpdGluZyBiZWZvcmUgY3JlYXRpbmcgc3luYyBmaWxlLi4uJyk7XG5cdFx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIEZJTEVfT1BfREVMQVkpKTtcblxuXHRcdC8vIE11bHRpcGxlIGF0dGVtcHRzIGZvciBjcmVhdGlvbiB3aXRoIGluY3JlYXNpbmcgZGVsYXlzXG5cdFx0bGV0IGNyZWF0ZUF0dGVtcHRzID0gMDtcblx0XHRjb25zdCBtYXhBdHRlbXB0cyA9IDM7XG5cblx0XHR3aGlsZSAoY3JlYXRlQXR0ZW1wdHMgPCBtYXhBdHRlbXB0cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpcy5zeW5jRmlsZSA9IGF3YWl0IHRoaXMudmF1bHQuY3JlYXRlKHRoaXMuc3luY0ZpbGVQYXRoLCBpbml0aWFsQ29udGVudCk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdTeW5jIGZpbGUgY3JlYXRlZCBzdWNjZXNzZnVsbHknKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9IGNhdGNoIChjcmVhdGVFcnJvcikge1xuXHRcdFx0XHRjcmVhdGVBdHRlbXB0cysrO1xuXHRcdFx0XHRjb25zb2xlLndhcm4oYENyZWF0ZSBhdHRlbXB0ICR7Y3JlYXRlQXR0ZW1wdHN9IGZhaWxlZDpgLCBjcmVhdGVFcnJvcik7XG5cblx0XHRcdFx0aWYgKGNyZWF0ZUF0dGVtcHRzID49IG1heEF0dGVtcHRzKSB7XG5cdFx0XHRcdFx0Ly8gTGFzdCByZXNvcnQ6IGNoZWNrIGlmIGZpbGUgZXhpc3RzIGRlc3BpdGUgY3JlYXRpb24gZXJyb3Jcblx0XHRcdFx0XHRjb25zdCBmaW5hbENoZWNrID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5zeW5jRmlsZVBhdGgpO1xuXHRcdFx0XHRcdGlmIChmaW5hbENoZWNrIGluc3RhbmNlb2YgVEZpbGUpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCdTeW5jIGZpbGUgZXhpc3RzIGRlc3BpdGUgY3JlYXRpb24gZXJyb3IsIHVzaW5nIGl0Jyk7XG5cdFx0XHRcdFx0XHR0aGlzLnN5bmNGaWxlID0gZmluYWxDaGVjaztcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgc3luYyBmaWxlIGFmdGVyICR7bWF4QXR0ZW1wdHN9IGF0dGVtcHRzOiAke2NyZWF0ZUVycm9yLm1lc3NhZ2V9YCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBFeHBvbmVudGlhbCBiYWNrb2ZmIGZvciByZXRyaWVzXG5cdFx0XHRcdGNvbnN0IHdhaXRUaW1lID0gRklMRV9PUF9ERUxBWSAqIChjcmVhdGVBdHRlbXB0cyArIDEpO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhgV2FpdGluZyAke3dhaXRUaW1lfW1zIGJlZm9yZSByZXRyeS4uLmApO1xuXHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgd2FpdFRpbWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBWZXJpZnkgZmlsZSBleGlzdHMgYW5kIGlzIHJlYWRhYmxlXG5cdFx0Y29uc3QgZmlsZUV4aXN0cyA9IHRoaXMudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMuc3luY0ZpbGVQYXRoKTtcblx0XHRpZiAoIWZpbGVFeGlzdHMpIHtcblx0XHRcdHRocm93IHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZVN5bmNFcnJvcihcblx0XHRcdFx0U3luY0Vycm9yVHlwZS5TWU5DX0ZJTEVfTUlTU0lORyxcblx0XHRcdFx0J1N5bmMgZmlsZSBjcmVhdGlvbiBmYWlsZWQgLSBmaWxlIG5vdCBmb3VuZCBhZnRlciB3YWl0IHBlcmlvZCcsXG5cdFx0XHRcdHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci5jcmVhdGVTeW5jRmlsZScgfSxcblx0XHRcdFx0dW5kZWZpbmVkLFxuXHRcdFx0XHR0aGlzLmRldmljZUlkLFxuXHRcdFx0XHRmYWxzZVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRjb25zb2xlLmxvZygnU3luYyBmaWxlIGNyZWF0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBzeW5jIGZpbGUgY29udGVudCBmcm9tIGRhdGFcblx0ICovXG5cdHByaXZhdGUgZ2VuZXJhdGVTeW5jRmlsZUNvbnRlbnQoZGF0YTogU3luY0ZpbGVEYXRhKTogc3RyaW5nIHtcblx0XHQvLyBDb252ZXJ0IGRhdGEgdG8gWUFNTCB1c2luZyBPYnNpZGlhbidzIGJ1aWx0LWluIGZ1bmN0aW9uXG5cdFx0Y29uc3QgeWFtbENvbnRlbnQgPSBzdHJpbmdpZnlZYW1sKGRhdGEpO1xuXHRcdC8vIFJldHVybiBhcyBtYXJrZG93biB3aXRoIFlBTUwgZnJvbnQgbWF0dGVyXG5cdFx0cmV0dXJuIGAtLS1cXG4ke3lhbWxDb250ZW50fS0tLVxcblxcbiMjIE1pbmQgTWF0cml4IFN5bmMgRmlsZVxcblxcblRoaXMgZmlsZSBtYW5hZ2VzIGNyb3NzLWRldmljZSBjb29yZGluYXRpb24gZm9yIHRoZSBNaW5kIE1hdHJpeCBwbHVnaW4uXFxuRG8gbm90IG1vZGlmeSB0aGlzIGZpbGUgbWFudWFsbHkuXFxuYDtcblx0fVxuXG5cdC8qKlxuXHQgKiBWYWxpZGF0ZSBzeW5jIGZpbGUgc3RydWN0dXJlIGFuZCBjb250ZW50XG5cdCAqL1xuXHRhc3luYyB2YWxpZGF0ZVN5bmNGaWxlKCk6IFByb21pc2U8U3luY1ZhbGlkYXRpb25SZXN1bHQ+IHtcblx0XHRpZiAoIXRoaXMuc3luY0ZpbGUpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGlzVmFsaWQ6IGZhbHNlLFxuXHRcdFx0XHRlcnJvcjogJ1N5bmMgZmlsZSBub3QgaW5pdGlhbGl6ZWQnXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkKHRoaXMuc3luY0ZpbGUpO1xuXHRcdFx0Ly8gRXh0cmFjdCBZQU1MIGZyb250IG1hdHRlclxuXHRcdFx0Y29uc3QgeWFtbE1hdGNoID0gY29udGVudC5tYXRjaCgvXi0tLVxcbihbXFxzXFxTXSo/KVxcbi0tLS8pO1xuXHRcdFx0aWYgKCF5YW1sTWF0Y2gpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0ludmFsaWQgc3luYyBmaWxlIGZvcm1hdDogTWlzc2luZyBZQU1MIGZyb250IG1hdHRlci4gV2lsbCByZWNyZWF0ZSBmaWxlLicpO1xuXHRcdFx0XHQvLyBJbnN0ZWFkIG9mIGp1c3QgcmV0dXJuaW5nIGFuIGVycm9yLCByZWNyZWF0ZSB0aGUgZmlsZVxuXHRcdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZVN5bmNGaWxlKCk7XG5cdFx0XHRcdHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcblx0XHRcdH1cblx0XHRcdC8vIFBhcnNlIFlBTUwgY29udGVudCB1c2luZyBPYnNpZGlhbidzIGJ1aWx0LWluIGZ1bmN0aW9uXG5cdFx0XHRjb25zdCB5YW1sQ29udGVudCA9IHlhbWxNYXRjaFsxXTtcblx0XHRcdGxldCBwYXJzZWREYXRhO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cGFyc2VkRGF0YSA9IHBhcnNlWWFtbCh5YW1sQ29udGVudCk7XG5cdFx0XHR9IGNhdGNoIChwYXJzZUVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gcGFyc2UgWUFNTCBjb250ZW50OicsIHBhcnNlRXJyb3IpO1xuXHRcdFx0XHQvLyBJZiBwYXJzaW5nIGZhaWxzLCByZWNyZWF0ZSB0aGUgZmlsZVxuXHRcdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZVN5bmNGaWxlKCk7XG5cdFx0XHRcdHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcblx0XHRcdH1cblx0XHRcdC8vIFZhbGlkYXRlIGJhc2ljIHN0cnVjdHVyZVxuXHRcdFx0aWYgKCFwYXJzZWREYXRhIHx8IHR5cGVvZiBwYXJzZWREYXRhICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnSW52YWxpZCBzeW5jIGZpbGUgZm9ybWF0OiBDYW5ub3QgcGFyc2UgWUFNTCBjb250ZW50LiBXaWxsIHJlY3JlYXRlIGZpbGUuJyk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuY3JlYXRlU3luY0ZpbGUoKTtcblx0XHRcdFx0cmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ2hlY2sgaWYgdGhpcyBpcyBhbiBvbGQgZm9ybWF0IHN5bmMgZmlsZSAoaGFzIGEgdGFibGUgc3RydWN0dXJlKVxuXHRcdFx0aWYgKGNvbnRlbnQuaW5jbHVkZXMoJ3wgRmlsZSBQYXRoIHwgTGFzdCBNb2RpZmllZCB8JykpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0RldGVjdGVkIG9sZCBmb3JtYXQgc3luYyBmaWxlLiBXaWxsIGNvbnZlcnQgdG8gbmV3IGZvcm1hdC4nKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVTeW5jRmlsZSgpO1xuXHRcdFx0XHRyZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07XG5cdFx0XHR9XG5cdFx0XHQvLyBDaGVjayByZXF1aXJlZCBmaWVsZHNcblx0XHRcdGlmIChcblx0XHRcdFx0IXBhcnNlZERhdGEuaGVhZGVyIHx8XG5cdFx0XHRcdCFwYXJzZWREYXRhLmhlYWRlci52YXVsdElkIHx8XG5cdFx0XHRcdCFwYXJzZWREYXRhLmhlYWRlci5sYXN0R2xvYmFsU3luYyB8fFxuXHRcdFx0XHQhcGFyc2VkRGF0YS5oZWFkZXIuZGV2aWNlc1xuXHRcdFx0KSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdJbnZhbGlkIHN5bmMgZmlsZSBmb3JtYXQ6IE1pc3NpbmcgcmVxdWlyZWQgZmllbGRzLiBXaWxsIHJlY3JlYXRlIGZpbGUuJyk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuY3JlYXRlU3luY0ZpbGUoKTtcblx0XHRcdFx0cmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gVmVyaWZ5IHZhdWx0IElEIG1hdGNoZXNcblx0XHRcdGlmIChwYXJzZWREYXRhLmhlYWRlci52YXVsdElkICE9PSB0aGlzLnZhdWx0SWQpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ1ZhdWx0IElEIG1pc21hdGNoLiBPbGQgSUQ6JywgcGFyc2VkRGF0YS5oZWFkZXIudmF1bHRJZCwgJ05ldyBJRDonLCB0aGlzLnZhdWx0SWQpO1xuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIHZhdWx0IElEIHRvIG1hdGNoIHRoZSBjdXJyZW50IG9uZVxuXHRcdFx0XHRwYXJzZWREYXRhLmhlYWRlci52YXVsdElkID0gdGhpcy52YXVsdElkO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3RvcmUgdGhlIHBhcnNlZCBkYXRhXG5cdFx0XHR0aGlzLmN1cnJlbnRTeW5jRGF0YSA9IHBhcnNlZERhdGEgYXMgU3luY0ZpbGVEYXRhO1xuXHRcdFx0Ly8gRW5zdXJlIGFsbCByZXF1aXJlZCBwcm9wZXJ0aWVzIGV4aXN0IGluIHRoZSBkYXRhIHN0cnVjdHVyZVxuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YS5jb25uZWN0aW9uRXZlbnRzKSB0aGlzLmN1cnJlbnRTeW5jRGF0YS5jb25uZWN0aW9uRXZlbnRzID0gW107XG5cdFx0XHRpZiAoIXRoaXMuY3VycmVudFN5bmNEYXRhLnBlbmRpbmdPcGVyYXRpb25zKSB0aGlzLmN1cnJlbnRTeW5jRGF0YS5wZW5kaW5nT3BlcmF0aW9ucyA9IFtdO1xuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YS5jb25mbGljdHMpIHRoaXMuY3VycmVudFN5bmNEYXRhLmNvbmZsaWN0cyA9IFtdO1xuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YS5sYXN0RGF0YWJhc2VDaGVjaykgdGhpcy5jdXJyZW50U3luY0RhdGEubGFzdERhdGFiYXNlQ2hlY2sgPSBEYXRlLm5vdygpO1xuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YS5kYXRhYmFzZVN0YXR1cykgdGhpcy5jdXJyZW50U3luY0RhdGEuZGF0YWJhc2VTdGF0dXMgPSAndW5rbm93bic7XG5cblx0XHRcdC8vIEluaXRpYWxpemUgZmlsZVN0YXR1c2VzIGlmIGl0IGRvZXNuJ3QgZXhpc3Rcblx0XHRcdGlmICghdGhpcy5jdXJyZW50U3luY0RhdGEuaGVhZGVyLmZpbGVTdGF0dXNlcykgdGhpcy5jdXJyZW50U3luY0RhdGEuaGVhZGVyLmZpbGVTdGF0dXNlcyA9IHt9O1xuXG5cdFx0XHQvLyBVcGRhdGUgZGV2aWNlIGluZm9ybWF0aW9uXG5cdFx0XHR0aGlzLmN1cnJlbnRTeW5jRGF0YSA9IHVwZGF0ZURldmljZUluU3luY0ZpbGUoXG5cdFx0XHRcdHRoaXMuY3VycmVudFN5bmNEYXRhLFxuXHRcdFx0XHR0aGlzLmRldmljZUlkLFxuXHRcdFx0XHR0aGlzLmRldmljZU5hbWUsXG5cdFx0XHRcdHRoaXMucGx1Z2luVmVyc2lvblxuXHRcdFx0KTtcblx0XHRcdC8vIFdyaXRlIGJhY2sgdGhlIHVwZGF0ZWQgZGF0YVxuXHRcdFx0YXdhaXQgdGhpcy53cml0ZVN5bmNGaWxlKHRoaXMuY3VycmVudFN5bmNEYXRhKTtcblx0XHRcdHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci52YWxpZGF0ZVN5bmNGaWxlJyB9KTtcblx0XHRcdGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gdmFsaWRhdGUgc3luYyBmaWxlLCB3aWxsIHJlY3JlYXRlOicsIGVycm9yKTtcblx0XHRcdC8vIFRyeSB0byByZWNyZWF0ZSB0aGUgZmlsZSBhcyBhIGxhc3QgcmVzb3J0XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZVN5bmNGaWxlKCk7XG5cdFx0XHRcdHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcblx0XHRcdH0gY2F0Y2ggKGNyZWF0ZUVycm9yKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aXNWYWxpZDogZmFsc2UsXG5cdFx0XHRcdFx0ZXJyb3I6IGBGYWlsZWQgdG8gdmFsaWRhdGUgYW5kIHJlY3JlYXRlIHN5bmMgZmlsZTogJHtjcmVhdGVFcnJvci5tZXNzYWdlfWBcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQWxpYXMgZm9yIHZhbGlkYXRlU3luY0ZpbGUoKSB0byBzdXBwb3J0IGxlZ2FjeSBjYWxscy5cblx0ICovXG5cdGFzeW5jIHZhbGlkYXRlU3luY1N0YXRlKCk6IFByb21pc2U8U3luY1ZhbGlkYXRpb25SZXN1bHQ+IHtcblx0XHRyZXR1cm4gYXdhaXQgdGhpcy52YWxpZGF0ZVN5bmNGaWxlKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVwYWlyIGNvcnJ1cHRlZCBzeW5jIGZpbGVcblx0ICovXG5cdHByaXZhdGUgYXN5bmMgcmVwYWlyU3luY0ZpbGUoKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFRyeSB0byByZXN0b3JlIGZyb20gYmFja3VwIGZpcnN0XG5cdFx0XHRjb25zdCByZXN0b3JlZCA9IGF3YWl0IHRoaXMucmVzdG9yZUZyb21CYWNrdXAoKTtcblx0XHRcdGlmIChyZXN0b3JlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIElmIHJlc3RvcmF0aW9uIGZhaWxzLCBjcmVhdGUgbmV3IHN5bmMgZmlsZVxuXHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVTeW5jRmlsZSgpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7XG5cdFx0XHRcdGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIucmVwYWlyU3luY0ZpbGUnLFxuXHRcdFx0XHRtZXRhZGF0YTogeyBzeW5jRmlsZVBhdGg6IHRoaXMuc3luY0ZpbGVQYXRoIH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkIGFuZCBwYXJzZSB0aGUgc3luYyBmaWxlXG5cdCAqL1xuXHRhc3luYyByZWFkU3luY0ZpbGUoKTogUHJvbWlzZTxTeW5jRmlsZURhdGEgfCBudWxsPiB7XG5cdFx0aWYgKCF0aGlzLnN5bmNGaWxlKSB7XG5cdFx0XHR0aHJvdyB0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVTeW5jRXJyb3IoXG5cdFx0XHRcdFN5bmNFcnJvclR5cGUuU1lOQ19GSUxFX01JU1NJTkcsXG5cdFx0XHRcdCdTeW5jIGZpbGUgbm90IGluaXRpYWxpemVkJyxcblx0XHRcdFx0eyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLnJlYWRTeW5jRmlsZScgfSxcblx0XHRcdFx0dW5kZWZpbmVkLFxuXHRcdFx0XHR0aGlzLmRldmljZUlkXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkKHRoaXMuc3luY0ZpbGUpO1xuXHRcdFx0Ly8gRXh0cmFjdCBZQU1MIGZyb250IG1hdHRlclxuXHRcdFx0Y29uc3QgeWFtbE1hdGNoID0gY29udGVudC5tYXRjaCgvXi0tLVxcbihbXFxzXFxTXSo/KVxcbi0tLS8pO1xuXHRcdFx0aWYgKCF5YW1sTWF0Y2gpIHtcblx0XHRcdFx0dGhyb3cgdGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlU3luY0Vycm9yKFxuXHRcdFx0XHRcdFN5bmNFcnJvclR5cGUuU1lOQ19GSUxFX0NPUlJVUFQsXG5cdFx0XHRcdFx0J0ludmFsaWQgc3luYyBmaWxlIGZvcm1hdDogTWlzc2luZyBZQU1MIGZyb250IG1hdHRlcicsXG5cdFx0XHRcdFx0eyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLnJlYWRTeW5jRmlsZScgfSxcblx0XHRcdFx0XHR1bmRlZmluZWQsXG5cdFx0XHRcdFx0dGhpcy5kZXZpY2VJZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUGFyc2UgWUFNTCBjb250ZW50IHVzaW5nIE9ic2lkaWFuJ3MgYnVpbHQtaW4gZnVuY3Rpb25cblx0XHRcdGNvbnN0IHlhbWxDb250ZW50ID0geWFtbE1hdGNoWzFdO1xuXHRcdFx0Y29uc3QgcGFyc2VkRGF0YSA9IHBhcnNlWWFtbCh5YW1sQ29udGVudCkgYXMgU3luY0ZpbGVEYXRhO1xuXHRcdFx0aWYgKCFwYXJzZWREYXRhIHx8ICFwYXJzZWREYXRhLmhlYWRlcikge1xuXHRcdFx0XHR0aHJvdyB0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVTeW5jRXJyb3IoXG5cdFx0XHRcdFx0U3luY0Vycm9yVHlwZS5TWU5DX0ZJTEVfQ09SUlVQVCxcblx0XHRcdFx0XHQnSW52YWxpZCBzeW5jIGZpbGUgZm9ybWF0OiBNaXNzaW5nIHJlcXVpcmVkIGZpZWxkcycsXG5cdFx0XHRcdFx0eyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLnJlYWRTeW5jRmlsZScgfSxcblx0XHRcdFx0XHR1bmRlZmluZWQsXG5cdFx0XHRcdFx0dGhpcy5kZXZpY2VJZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHBhcnNlZCBkYXRhXG5cdFx0XHR0aGlzLmN1cnJlbnRTeW5jRGF0YSA9IHBhcnNlZERhdGE7XG5cdFx0XHRyZXR1cm4gcGFyc2VkRGF0YTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKCF0aGlzLmVycm9ySGFuZGxlci5pc1N5bmNFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0dGhyb3cgdGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlU3luY0Vycm9yKFxuXHRcdFx0XHRcdFN5bmNFcnJvclR5cGUuU1lOQ19GSUxFX0NPUlJVUFQsXG5cdFx0XHRcdFx0YEVycm9yIHJlYWRpbmcgc3luYyBmaWxlOiAke2Vycm9yLm1lc3NhZ2V9YCxcblx0XHRcdFx0XHR7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIucmVhZFN5bmNGaWxlJyB9LFxuXHRcdFx0XHRcdHVuZGVmaW5lZCxcblx0XHRcdFx0XHR0aGlzLmRldmljZUlkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogV3JpdGUgc3luYyBkYXRhIHRvIHRoZSBzeW5jIGZpbGVcblx0ICovXG5cdGFzeW5jIHdyaXRlU3luY0ZpbGUoZGF0YTogU3luY0ZpbGVEYXRhKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCF0aGlzLnN5bmNGaWxlKSB7XG5cdFx0XHR0aHJvdyB0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVTeW5jRXJyb3IoXG5cdFx0XHRcdFN5bmNFcnJvclR5cGUuU1lOQ19GSUxFX01JU1NJTkcsXG5cdFx0XHRcdCdTeW5jIGZpbGUgbm90IGluaXRpYWxpemVkJyxcblx0XHRcdFx0eyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLndyaXRlU3luY0ZpbGUnIH0sXG5cdFx0XHRcdHVuZGVmaW5lZCxcblx0XHRcdFx0dGhpcy5kZXZpY2VJZFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gVXBkYXRlIHN5bmMgZmlsZSBjb250ZW50XG5cdFx0XHRjb25zdCBjb250ZW50ID0gdGhpcy5nZW5lcmF0ZVN5bmNGaWxlQ29udGVudChkYXRhKTtcblx0XHRcdGF3YWl0IHRoaXMudmF1bHQubW9kaWZ5KHRoaXMuc3luY0ZpbGUsIGNvbnRlbnQpO1xuXHRcdFx0Ly8gVXBkYXRlIGNhY2hlZCBkYXRhXG5cdFx0XHR0aGlzLmN1cnJlbnRTeW5jRGF0YSA9IGRhdGE7XG5cdFx0XHQvLyBDcmVhdGUgYmFja3VwIGlmIG5lZWRlZFxuXHRcdFx0aWYgKERhdGUubm93KCkgLSB0aGlzLmxhc3RCYWNrdXAgPj0gdGhpcy5iYWNrdXBJbnRlcnZhbCkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZUJhY2t1cCgpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aHJvdyB0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVTeW5jRXJyb3IoXG5cdFx0XHRcdFN5bmNFcnJvclR5cGUuVU5LTk9XTl9FUlJPUixcblx0XHRcdFx0YEZhaWxlZCB0byB3cml0ZSBzeW5jIGZpbGU6ICR7ZXJyb3IubWVzc2FnZX1gLFxuXHRcdFx0XHR7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIud3JpdGVTeW5jRmlsZScgfSxcblx0XHRcdFx0dW5kZWZpbmVkLFxuXHRcdFx0XHR0aGlzLmRldmljZUlkXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBiYWNrdXAgb2YgdGhlIHN5bmMgZmlsZVxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBjcmVhdGVCYWNrdXAoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCF0aGlzLnN5bmNGaWxlKSByZXR1cm47XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHQucmVhZCh0aGlzLnN5bmNGaWxlKTtcblx0XHRcdGNvbnN0IGJhY2t1cEZpbGUgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLmJhY2t1cFBhdGgpO1xuXHRcdFx0aWYgKGJhY2t1cEZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnZhdWx0Lm1vZGlmeShiYWNrdXBGaWxlLCBjb250ZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMudmF1bHQuY3JlYXRlKHRoaXMuYmFja3VwUGF0aCwgY29udGVudCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmxhc3RCYWNrdXAgPSBEYXRlLm5vdygpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLmNyZWF0ZUJhY2t1cCcgfSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlc3RvcmUgc3luYyBmaWxlIGZyb20gYmFja3VwXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIHJlc3RvcmVGcm9tQmFja3VwKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdGNvbnN0IGJhY2t1cEZpbGUgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLmJhY2t1cFBhdGgpO1xuXHRcdGlmICghKGJhY2t1cEZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHQucmVhZChiYWNrdXBGaWxlKTtcblx0XHRcdGlmICh0aGlzLnN5bmNGaWxlKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMudmF1bHQubW9kaWZ5KHRoaXMuc3luY0ZpbGUsIGNvbnRlbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zeW5jRmlsZSA9IGF3YWl0IHRoaXMudmF1bHQuY3JlYXRlKHRoaXMuc3luY0ZpbGVQYXRoLCBjb250ZW50KTtcblx0XHRcdH1cblx0XHRcdC8vIFRyeSB0byBwYXJzZSB0aGUgcmVzdG9yZWQgY29udGVudFxuXHRcdFx0Y29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMudmFsaWRhdGVTeW5jRmlsZSgpO1xuXHRcdFx0cmV0dXJuIHZhbGlkYXRpb25SZXN1bHQuaXNWYWxpZDtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci5yZXN0b3JlRnJvbUJhY2t1cCcgfSk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbiBzdGF0dXNcblx0ICovXG5cdGFzeW5jIHVwZGF0ZURhdGFiYXNlU3RhdHVzKHN0YXR1czogJ2F2YWlsYWJsZScgfCAndW5hdmFpbGFibGUnIHwgJ3Vua25vd24nKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFJlYWQgY3VycmVudCBkYXRhIGlmIG5vdCBjYWNoZWRcblx0XHRcdGlmICghdGhpcy5jdXJyZW50U3luY0RhdGEpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy5yZWFkU3luY0ZpbGUoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHRcdC8vIFVwZGF0ZSBzdGF0dXNcblx0XHRcdFx0Y29uc3QgdXBkYXRlZERhdGEgPSB1cGRhdGVEYXRhYmFzZVN0YXR1cyh0aGlzLmN1cnJlbnRTeW5jRGF0YSwgc3RhdHVzKTtcblx0XHRcdFx0Ly8gSWYgc3RhdHVzIGNoYW5nZWQgdG8gdW5hdmFpbGFibGUsIGFkZCBjb25uZWN0aW9uIGV2ZW50XG5cdFx0XHRcdGlmIChzdGF0dXMgPT09ICd1bmF2YWlsYWJsZScgJiYgdGhpcy5jdXJyZW50U3luY0RhdGEuZGF0YWJhc2VTdGF0dXMgIT09ICd1bmF2YWlsYWJsZScpIHtcblx0XHRcdFx0XHR1cGRhdGVkRGF0YS5jb25uZWN0aW9uRXZlbnRzLnB1c2goe1xuXHRcdFx0XHRcdFx0dGltZXN0YW1wOiBEYXRlLm5vdygpLFxuXHRcdFx0XHRcdFx0ZXZlbnRUeXBlOiAnZGlzY29ubmVjdGVkJyxcblx0XHRcdFx0XHRcdGRldmljZUlkOiB0aGlzLmRldmljZUlkLFxuXHRcdFx0XHRcdFx0ZGV0YWlsczogJ0RhdGFiYXNlIGNvbm5lY3Rpb24gbG9zdCdcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBJZiBzdGF0dXMgY2hhbmdlZCB0byBhdmFpbGFibGUsIGFkZCBjb25uZWN0aW9uIGV2ZW50XG5cdFx0XHRcdGlmIChzdGF0dXMgPT09ICdhdmFpbGFibGUnICYmIHRoaXMuY3VycmVudFN5bmNEYXRhLmRhdGFiYXNlU3RhdHVzICE9PSAnYXZhaWxhYmxlJykge1xuXHRcdFx0XHRcdHVwZGF0ZWREYXRhLmNvbm5lY3Rpb25FdmVudHMucHVzaCh7XG5cdFx0XHRcdFx0XHR0aW1lc3RhbXA6IERhdGUubm93KCksXG5cdFx0XHRcdFx0XHRldmVudFR5cGU6ICdjb25uZWN0ZWQnLFxuXHRcdFx0XHRcdFx0ZGV2aWNlSWQ6IHRoaXMuZGV2aWNlSWQsXG5cdFx0XHRcdFx0XHRkZXRhaWxzOiAnRGF0YWJhc2UgY29ubmVjdGlvbiBlc3RhYmxpc2hlZCdcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBUcmltIGFycmF5cyB0byBwcmV2ZW50IGV4Y2Vzc2l2ZSBncm93dGhcblx0XHRcdFx0Y29uc3QgdHJpbW1lZERhdGEgPSB0cmltU3luY0hpc3RvcnlBcnJheXModXBkYXRlZERhdGEpO1xuXHRcdFx0XHQvLyBXcml0ZSB1cGRhdGVkIGRhdGFcblx0XHRcdFx0YXdhaXQgdGhpcy53cml0ZVN5bmNGaWxlKHRyaW1tZWREYXRhKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci51cGRhdGVEYXRhYmFzZVN0YXR1cycsXG5cdFx0XHRcdG1ldGFkYXRhOiB7IHN0YXR1cyB9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIGRldmljZSBzeW5jIHRpbWVzdGFtcCBhbmQgc3RhdHVzXG5cdCAqL1xuXHRhc3luYyB1cGRhdGVEZXZpY2VTeW5jVGltZXN0YW1wKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBSZWFkIGN1cnJlbnQgZGF0YSBpZiBub3QgY2FjaGVkXG5cdFx0XHRpZiAoIXRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMucmVhZFN5bmNGaWxlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5jdXJyZW50U3luY0RhdGEpIHtcblx0XHRcdFx0Ly8gVXBkYXRlIGRldmljZSBzeW5jIHRpbWVcblx0XHRcdFx0Y29uc3QgdXBkYXRlZERhdGEgPSB1cGRhdGVEZXZpY2VTeW5jVGltZSh0aGlzLmN1cnJlbnRTeW5jRGF0YSwgdGhpcy5kZXZpY2VJZCk7XG5cdFx0XHRcdC8vIFdyaXRlIHVwZGF0ZWQgZGF0YVxuXHRcdFx0XHRhd2FpdCB0aGlzLndyaXRlU3luY0ZpbGUodXBkYXRlZERhdGEpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLnVwZGF0ZURldmljZVN5bmNUaW1lc3RhbXAnIH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiAqKk5ldyBNZXRob2Q6Kipcblx0ICogVXBkYXRlcyB0aGUgc3luYyBzdGF0dXMgZm9yIGEgZ2l2ZW4gZmlsZSBpbiB0aGUgc3luYyBmaWxlLlxuXHQgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGFzIGEgZmFsbGJhY2sgd2hlbiB0aGUgZGF0YWJhc2UgaXNuJ3QgYXZhaWxhYmxlLlxuXHQgKi9cblx0YXN5bmMgdXBkYXRlU3luY1N0YXR1cyhmaWxlUGF0aDogc3RyaW5nLCBzdGF0dXM6IHN0cmluZywgYWRkaXRpb25hbERhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQcm9taXNlPHZvaWQ+IHtcblx0XHQvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgY3VycmVudCBzeW5jIGRhdGFcblx0XHRpZiAoIXRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHRhd2FpdCB0aGlzLnJlYWRTeW5jRmlsZSgpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5jdXJyZW50U3luY0RhdGEpIHtcblx0XHRcdC8vIEFzc3VtaW5nIHlvdXIgc3luYyBmaWxlIGhlYWRlciBjb250YWlucyBhIGZpbGVTdGF0dXNlcyBtYXBcblx0XHRcdHRoaXMuY3VycmVudFN5bmNEYXRhLmhlYWRlci5maWxlU3RhdHVzZXMgPSB0aGlzLmN1cnJlbnRTeW5jRGF0YS5oZWFkZXIuZmlsZVN0YXR1c2VzIHx8IHt9O1xuXHRcdFx0dGhpcy5jdXJyZW50U3luY0RhdGEuaGVhZGVyLmZpbGVTdGF0dXNlc1tmaWxlUGF0aF0gPSB7XG5cdFx0XHRcdHN0YXR1cyxcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiBhZGRpdGlvbmFsRGF0YS5sYXN0TW9kaWZpZWQsXG5cdFx0XHRcdGhhc2g6IGFkZGl0aW9uYWxEYXRhLmhhc2gsXG5cdFx0XHRcdHVwZGF0ZWRBdDogRGF0ZS5ub3coKVxuXHRcdFx0fTtcblx0XHRcdGF3YWl0IHRoaXMud3JpdGVTeW5jRmlsZSh0aGlzLmN1cnJlbnRTeW5jRGF0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlN5bmMgZmlsZSBkYXRhIHVuYXZhaWxhYmxlIGZvciB1cGRhdGVTeW5jU3RhdHVzXCIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBzeW5jIHN0YXR1cyBmb3IgYSBzcGVjaWZpYyBmaWxlIHBhdGguXG5cdCAqL1xuXHRhc3luYyBnZXRTeW5jU3RhdHVzKHBhdGg6IHN0cmluZyk6IFByb21pc2U8eyBzdGF0dXM6IHN0cmluZzsgbGFzdE1vZGlmaWVkOiBudW1iZXI7IGhhc2g6IHN0cmluZyB9IHwgbnVsbD4ge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMucmVhZFN5bmNGaWxlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmN1cnJlbnRTeW5jRGF0YSAmJiB0aGlzLmN1cnJlbnRTeW5jRGF0YS5oZWFkZXIuZmlsZVN0YXR1c2VzKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmN1cnJlbnRTeW5jRGF0YS5oZWFkZXIuZmlsZVN0YXR1c2VzW3BhdGhdIHx8IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLmdldFN5bmNTdGF0dXMnLCBtZXRhZGF0YTogeyBwYXRoIH0gfSk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGFsbCBwZW5kaW5nIG9wZXJhdGlvbnNcblx0ICovXG5cdGFzeW5jIGdldFBlbmRpbmdPcGVyYXRpb25zKCk6IFByb21pc2U8QXJyYXk8e1xuXHRcdGlkOiBzdHJpbmc7XG5cdFx0ZmlsZUlkOiBzdHJpbmc7XG5cdFx0b3BlcmF0aW9uVHlwZTogc3RyaW5nO1xuXHRcdHRpbWVzdGFtcDogbnVtYmVyO1xuXHRcdGRldmljZUlkOiBzdHJpbmc7XG5cdFx0bWV0YWRhdGE/OiBhbnk7XG5cdFx0c3RhdHVzOiBzdHJpbmc7XG5cdH0+PiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFJlYWQgY3VycmVudCBkYXRhIGlmIG5vdCBjYWNoZWRcblx0XHRcdGlmICghdGhpcy5jdXJyZW50U3luY0RhdGEpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy5yZWFkU3luY0ZpbGUoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmN1cnJlbnRTeW5jRGF0YT8ucGVuZGluZ09wZXJhdGlvbnMgfHwgW107XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIuZ2V0UGVuZGluZ09wZXJhdGlvbnMnIH0pO1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgY3VycmVudCBzeW5jIHN0YXRlXG5cdCAqL1xuXHRhc3luYyBnZXRTeW5jU3RhdGUoKTogUHJvbWlzZTxTeW5jU3RhdGU+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gUmVhZCBjdXJyZW50IGRhdGEgaWYgbm90IGNhY2hlZFxuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnJlYWRTeW5jRmlsZSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuY3VycmVudFN5bmNEYXRhPy5oZWFkZXIuc3luY1N0YXRlIHx8IFN5bmNTdGF0ZS5VTktOT1dOO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLmdldFN5bmNTdGF0ZScgfSk7XG5cdFx0XHRyZXR1cm4gU3luY1N0YXRlLlVOS05PV047XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhbGwga25vd24gZGV2aWNlc1xuXHQgKi9cblx0YXN5bmMgZ2V0S25vd25EZXZpY2VzKCk6IFByb21pc2U8UmVjb3JkPHN0cmluZywge1xuXHRcdGRldmljZUlkOiBzdHJpbmc7XG5cdFx0bmFtZTogc3RyaW5nO1xuXHRcdHBsYXRmb3JtOiBzdHJpbmc7XG5cdFx0bGFzdFNlZW46IG51bWJlcjtcblx0XHRsYXN0U3luY1RpbWU6IG51bWJlcjtcblx0fT4+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gUmVhZCBjdXJyZW50IGRhdGEgaWYgbm90IGNhY2hlZFxuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnJlYWRTeW5jRmlsZSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuY3VycmVudFN5bmNEYXRhPy5oZWFkZXIuZGV2aWNlcyB8fCB7fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci5nZXRLbm93bkRldmljZXMnIH0pO1xuXHRcdFx0cmV0dXJuIHt9O1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGVyZSBhcmUgY29uZmxpY3RzIHRoYXQgbmVlZCByZXNvbHV0aW9uXG5cdCAqL1xuXHRhc3luYyBkZXRlY3RDb25mbGljdHMoKTogUHJvbWlzZTxTeW5jQ29uZmxpY3RbXT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMucmVhZFN5bmNGaWxlKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBFbmhhbmNlZDogRmlsdGVyIGZvciBjb25mbGljdHMgd2l0aCBtb3JlIGRldGFpbGVkIG1ldGFkYXRhIChpZiBuZWVkZWQpXG5cdFx0XHRjb25zdCBwZW5kaW5nQ29uZmxpY3RzID0gdGhpcy5jdXJyZW50U3luY0RhdGE/LmNvbmZsaWN0cy5maWx0ZXIoXG5cdFx0XHRcdGNvbmZsaWN0ID0+IGNvbmZsaWN0LnJlc29sdXRpb25TdGF0dXMgPT09ICdwZW5kaW5nJ1xuXHRcdFx0KSB8fCBbXTtcblx0XHRcdHJldHVybiBwZW5kaW5nQ29uZmxpY3RzO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLmRldGVjdENvbmZsaWN0cycgfSk7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEF0dGVtcHQgdG8gcmVzb2x2ZSBhIGNvbmZsaWN0IGJhc2VkIG9uIGEgZ2l2ZW4gcmVzb2x1dGlvbiBzdHJhdGVneS5cblx0ICogU3VwcG9ydHMgc3RyYXRlZ2llczpcblx0ICogLSBcIm5ld2VzdC13aW5zXCI6IEF1dG9tYXRpY2FsbHkgcmVzb2x2ZXMgYnkgZmF2b3JpbmcgdGhlIG1vc3QgcmVjZW50IHVwZGF0ZS5cblx0ICogLSBcImtlZXAtYm90aFwiOiBNYXJrcyBhcyByZXNvbHZlZCBhbmQgbGVhdmVzIGJvdGggdmVyc2lvbnMgaW50YWN0LlxuXHQgKiAtIFwibWFudWFsXCI6IEZsYWdzIHRoZSBjb25mbGljdCBmb3IgbWFudWFsIGludGVydmVudGlvbiAoZG9lcyBub3QgYXV0by1yZXNvbHZlKS5cblx0ICovXG5cdGFzeW5jIHJlc29sdmVDb25mbGljdChjb25mbGljdElkOiBzdHJpbmcsIHJlc29sdXRpb25TdHJhdGVneTogJ25ld2VzdC13aW5zJyB8ICdtYW51YWwnIHwgJ2tlZXAtYm90aCcpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnJlYWRTeW5jRmlsZSgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRmluZCB0aGUgY29uZmxpY3QgYnkgSURcblx0XHRcdGNvbnN0IGNvbmZsaWN0SW5kZXggPSB0aGlzLmN1cnJlbnRTeW5jRGF0YT8uY29uZmxpY3RzLmZpbmRJbmRleChjID0+IGMuaWQgPT09IGNvbmZsaWN0SWQpO1xuXHRcdFx0aWYgKGNvbmZsaWN0SW5kZXggPT09IHVuZGVmaW5lZCB8fCBjb25mbGljdEluZGV4IDwgMCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0NvbmZsaWN0IG5vdCBmb3VuZDonLCBjb25mbGljdElkKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgY29uZmxpY3QgPSB0aGlzLmN1cnJlbnRTeW5jRGF0YSEuY29uZmxpY3RzW2NvbmZsaWN0SW5kZXhdO1xuXHRcdFx0c3dpdGNoIChyZXNvbHV0aW9uU3RyYXRlZ3kpIHtcblx0XHRcdFx0Y2FzZSAnbmV3ZXN0LXdpbnMnOlxuXHRcdFx0XHRcdC8vIEluIGEgcmVhbCBzY2VuYXJpbywgY29tcGFyZSB0aW1lc3RhbXBzIG9yIGNvbnRlbnQgaGFzaGVzIGhlcmUuXG5cdFx0XHRcdFx0Y29uZmxpY3QucmVzb2x1dGlvblN0cmF0ZWd5ID0gJ25ld2VzdC13aW5zJztcblx0XHRcdFx0XHRjb25mbGljdC5yZXNvbHV0aW9uU3RhdHVzID0gJ3Jlc29sdmVkJztcblx0XHRcdFx0XHRjb25mbGljdC5yZXNvbHZlZEF0ID0gRGF0ZS5ub3coKTtcblx0XHRcdFx0XHRjb25mbGljdC5yZXNvbHZlZEJ5ID0gdGhpcy5kZXZpY2VJZDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAna2VlcC1ib3RoJzpcblx0XHRcdFx0XHQvLyBPcHRpb25hbGx5LCBkdXBsaWNhdGUgdGhlIGZpbGUgZW50cnkgaW4gdGhlIGRhdGFiYXNlIGFuZCBtYXJrIGNvbmZsaWN0IGFzIHJlc29sdmVkLlxuXHRcdFx0XHRcdGNvbmZsaWN0LnJlc29sdXRpb25TdHJhdGVneSA9ICdrZWVwLWJvdGgnO1xuXHRcdFx0XHRcdGNvbmZsaWN0LnJlc29sdXRpb25TdGF0dXMgPSAncmVzb2x2ZWQnO1xuXHRcdFx0XHRcdGNvbmZsaWN0LnJlc29sdmVkQXQgPSBEYXRlLm5vdygpO1xuXHRcdFx0XHRcdGNvbmZsaWN0LnJlc29sdmVkQnkgPSB0aGlzLmRldmljZUlkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdtYW51YWwnOlxuXHRcdFx0XHRcdC8vIERvIG5vdCBhdXRvLXJlc29sdmU7IGZsYWcgZm9yIG1hbnVhbCBpbnRlcnZlbnRpb24uXG5cdFx0XHRcdFx0Y29uZmxpY3QucmVzb2x1dGlvblN0cmF0ZWd5ID0gJ21hbnVhbCc7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ01hbnVhbCByZXNvbHV0aW9uIHJlcXVpcmVkIGZvciBjb25mbGljdDonLCBjb25mbGljdElkKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCByZXNvbHV0aW9uIHN0cmF0ZWd5Jyk7XG5cdFx0XHR9XG5cdFx0XHRhd2FpdCB0aGlzLndyaXRlU3luY0ZpbGUodGhpcy5jdXJyZW50U3luY0RhdGEhKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLnJlc29sdmVDb25mbGljdCcsIG1ldGFkYXRhOiB7IGNvbmZsaWN0SWQgfSB9KTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQXR0ZW1wdCB0byByZXNvbHZlIGFsbCBkZXRlY3RlZCBjb25mbGljdHMgdXNpbmcgYSBkZWZhdWx0IHN0cmF0ZWd5LlxuXHQgKi9cblx0YXN5bmMgcmVzb2x2ZUFsbENvbmZsaWN0cyhkZWZhdWx0U3RyYXRlZ3k6ICduZXdlc3Qtd2lucycgfCAnbWFudWFsJyB8ICdrZWVwLWJvdGgnID0gJ25ld2VzdC13aW5zJyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb25mbGljdHMgPSBhd2FpdCB0aGlzLmRldGVjdENvbmZsaWN0cygpO1xuXHRcdFx0Zm9yIChjb25zdCBjb25mbGljdCBvZiBjb25mbGljdHMpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy5yZXNvbHZlQ29uZmxpY3QoY29uZmxpY3QuaWQsIGRlZmF1bHRTdHJhdGVneSk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIucmVzb2x2ZUFsbENvbmZsaWN0cycgfSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgbGFzdCBzeW5jIHRpbWVzdGFtcCBpbiB0aGUgc3luYyBmaWxlIGhlYWRlci5cblx0ICovXG5cdGFzeW5jIHVwZGF0ZUxhc3RTeW5jKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMucmVhZFN5bmNGaWxlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5jdXJyZW50U3luY0RhdGEpIHtcblx0XHRcdFx0dGhpcy5jdXJyZW50U3luY0RhdGEuaGVhZGVyLmxhc3RHbG9iYWxTeW5jID0gRGF0ZS5ub3coKTtcblx0XHRcdFx0YXdhaXQgdGhpcy53cml0ZVN5bmNGaWxlKHRoaXMuY3VycmVudFN5bmNEYXRhKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci51cGRhdGVMYXN0U3luYycgfSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYWxsIHN5bmMgZW50cmllcyBmcm9tIHRoZSBzeW5jIGZpbGUuXG5cdCAqL1xuXHRhc3luYyBnZXRBbGxTeW5jRW50cmllcygpOiBQcm9taXNlPEFycmF5PHsgZmlsZVBhdGg6IHN0cmluZzsgc3RhdHVzOiBzdHJpbmc7IGxhc3RNb2RpZmllZDogbnVtYmVyOyBoYXNoOiBzdHJpbmcgfT4+IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnJlYWRTeW5jRmlsZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5jdXJyZW50U3luY0RhdGEgJiYgdGhpcy5jdXJyZW50U3luY0RhdGEuaGVhZGVyLmZpbGVTdGF0dXNlcykge1xuXHRcdFx0XHRyZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy5jdXJyZW50U3luY0RhdGEuaGVhZGVyLmZpbGVTdGF0dXNlcykubWFwKChbZmlsZVBhdGgsIGRhdGFdKSA9PiAoe1xuXHRcdFx0XHRcdGZpbGVQYXRoLFxuXHRcdFx0XHRcdHN0YXR1czogZGF0YS5zdGF0dXMsXG5cdFx0XHRcdFx0bGFzdE1vZGlmaWVkOiBkYXRhLmxhc3RNb2RpZmllZCxcblx0XHRcdFx0XHRoYXNoOiBkYXRhLmhhc2hcblx0XHRcdFx0fSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIuZ2V0QWxsU3luY0VudHJpZXMnIH0pO1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBdHRlbXB0IHJlY292ZXJ5IG9wZXJhdGlvbnMgd2hlbiBzeW5jIGlzc3VlcyBhcmUgZGV0ZWN0ZWQuXG5cdCAqL1xuXHRhc3luYyBhdHRlbXB0UmVjb3ZlcnkoKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIEF0dGVtcHQgdG8gcmVzdG9yZSBmcm9tIGJhY2t1cFxuXHRcdFx0Y29uc3QgcmVjb3ZlcmVkID0gYXdhaXQgdGhpcy5yZXN0b3JlRnJvbUJhY2t1cCgpO1xuXHRcdFx0aWYgKHJlY292ZXJlZCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IHJlY292ZXJlZCBmcm9tIGJhY2t1cCcpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYmFja3VwIHJlc3RvcmF0aW9uIGZhaWxzLCB0cnkgdG8gcmVjcmVhdGUgdGhlIHN5bmMgZmlsZVxuXHRcdFx0Y29uc29sZS5sb2coJ0JhY2t1cCByZXN0b3JhdGlvbiBmYWlsZWQsIGF0dGVtcHRpbmcgdG8gcmVjcmVhdGUgc3luYyBmaWxlJyk7XG5cdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZVN5bmNGaWxlKCk7XG5cblx0XHRcdC8vIFZlcmlmeSB0aGUgbmV3IGZpbGUgaXMgdmFsaWRcblx0XHRcdGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBhd2FpdCB0aGlzLnZhbGlkYXRlU3luY0ZpbGUoKTtcblx0XHRcdHJldHVybiB2YWxpZGF0aW9uUmVzdWx0LmlzVmFsaWQ7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIuYXR0ZW1wdFJlY292ZXJ5JyB9KTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cbn1cbiIsICIvLyBzcmMvbW9kZWxzL1N5bmNNb2RlbHMudHNcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBzdHJ1Y3R1cmUgYW5kIHR5cGVzIGZvciBzeW5jIGZpbGUgY29vcmRpbmF0aW9uXG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGV2aWNlIGtub3duIGJ5IHRoZSBzeW5jIHN5c3RlbVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNEZXZpY2Uge1xuICAgIGRldmljZUlkOiBzdHJpbmc7ICAgICAgICAgLy8gVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgZGV2aWNlXG4gICAgbmFtZTogc3RyaW5nOyAgICAgICAgICAgICAvLyBVc2VyLWZyaWVuZGx5IGRldmljZSBuYW1lXG4gICAgcGxhdGZvcm06IHN0cmluZzsgICAgICAgICAvLyBPcGVyYXRpbmcgc3lzdGVtL3BsYXRmb3JtXG4gICAgbGFzdFNlZW46IG51bWJlcjsgICAgICAgICAvLyBUaW1lc3RhbXAgd2hlbiBkZXZpY2Ugd2FzIGxhc3QgYWN0aXZlXG4gICAgbGFzdFN5bmNUaW1lOiBudW1iZXI7ICAgICAvLyBMYXN0IHN1Y2Nlc3NmdWwgZGF0YWJhc2Ugc3luYyB0aW1lc3RhbXBcbiAgICBvYnNpZGlhblZlcnNpb24/OiBzdHJpbmc7IC8vIE9ic2lkaWFuIHZlcnNpb24gKG9wdGlvbmFsKVxuICAgIHBsdWdpblZlcnNpb24/OiBzdHJpbmc7ICAgLy8gUGx1Z2luIHZlcnNpb24gKG9wdGlvbmFsKVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIG92ZXJhbGwgc3luYyBzdGF0ZVxuICovXG5leHBvcnQgZW51bSBTeW5jU3RhdGUge1xuICAgIFVOS05PV04gPSAndW5rbm93bicsXG4gICAgSU5JVElBTElaSU5HID0gJ2luaXRpYWxpemluZycsXG4gICAgT05MSU5FID0gJ29ubGluZScsXG4gICAgT0ZGTElORSA9ICdvZmZsaW5lJyxcbiAgICBFUlJPUiA9ICdlcnJvcicsXG4gICAgQ09ORkxJQ1QgPSAnY29uZmxpY3QnXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbm5lY3Rpb24gZXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0aW9uRXZlbnQge1xuICAgIHRpbWVzdGFtcDogbnVtYmVyO1xuICAgIGV2ZW50VHlwZTogJ2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJztcbiAgICBkZXZpY2VJZDogc3RyaW5nO1xuICAgIGRldGFpbHM/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHN5bmMgb3BlcmF0aW9uIHBlcmZvcm1lZCBkdXJpbmcgb2ZmbGluZSBtb2RlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGVuZGluZ09wZXJhdGlvbiB7XG4gICAgaWQ6IHN0cmluZzsgICAgICAgICAgICAgICAvLyBVbmlxdWUgb3BlcmF0aW9uIElEXG4gICAgZmlsZUlkOiBzdHJpbmc7ICAgICAgICAgICAvLyBGaWxlIHBhdGggdGhpcyBvcGVyYXRpb24gYWZmZWN0c1xuICAgIG9wZXJhdGlvblR5cGU6ICdjcmVhdGUnIHwgJ3VwZGF0ZScgfCAnZGVsZXRlJyB8ICdyZW5hbWUnO1xuICAgIHRpbWVzdGFtcDogbnVtYmVyOyAgICAgICAgLy8gV2hlbiB0aGUgb3BlcmF0aW9uIG9jY3VycmVkXG4gICAgZGV2aWNlSWQ6IHN0cmluZzsgICAgICAgICAvLyBEZXZpY2UgdGhhdCBwZXJmb3JtZWQgdGhlIG9wZXJhdGlvblxuICAgIG1ldGFkYXRhPzogeyAgICAgICAgICAgICAgLy8gQWRkaXRpb25hbCBvcGVyYXRpb24gZGF0YVxuICAgICAgICBvbGRQYXRoPzogc3RyaW5nOyAgICAgLy8gRm9yIHJlbmFtZSBvcGVyYXRpb25zXG4gICAgICAgIGNvbnRlbnRIYXNoPzogc3RyaW5nOyAvLyBGb3IgY3JlYXRlL3VwZGF0ZSBvcGVyYXRpb25zXG4gICAgICAgIGxhc3RNb2RpZmllZD86IG51bWJlcjsgLy8gTGFzdCBtb2RpZmllZCB0aW1lc3RhbXBcbiAgICB9O1xuICAgIHN0YXR1czogJ3BlbmRpbmcnIHwgJ3Byb2Nlc3NpbmcnIHwgJ2Vycm9yJztcbiAgICBlcnJvckRldGFpbHM/OiBzdHJpbmc7ICAgIC8vIEVycm9yIGluZm9ybWF0aW9uIGlmIHN0YXR1cyBpcyAnZXJyb3InXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGRldGVjdGVkIGNvbmZsaWN0IGJldHdlZW4gZGV2aWNlc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNDb25mbGljdCB7XG4gICAgaWQ6IHN0cmluZzsgICAgICAgICAgICAgICAgICAgIC8vIFVuaXF1ZSBjb25mbGljdCBJRFxuICAgIGZpbGVJZDogc3RyaW5nOyAgICAgICAgICAgICAgICAvLyBGaWxlIHBhdGggd2l0aCBjb25mbGljdFxuICAgIGRldGVjdGVkQXQ6IG51bWJlcjsgICAgICAgICAgICAvLyBXaGVuIGNvbmZsaWN0IHdhcyBkZXRlY3RlZFxuICAgIGRldmljZXM6IHN0cmluZ1tdOyAgICAgICAgICAgICAvLyBEZXZpY2UgSURzIGludm9sdmVkIGluIGNvbmZsaWN0XG4gICAgcmVzb2x1dGlvblN0YXR1czogJ3BlbmRpbmcnIHwgJ3Jlc29sdmVkJztcbiAgICByZXNvbHV0aW9uU3RyYXRlZ3k/OiAnbmV3ZXN0LXdpbnMnIHwgJ21hbnVhbCcgfCAna2VlcC1ib3RoJztcbiAgICByZXNvbHZlZEF0PzogbnVtYmVyOyAgICAgICAgICAgLy8gV2hlbiBjb25mbGljdCB3YXMgcmVzb2x2ZWRcbiAgICByZXNvbHZlZEJ5Pzogc3RyaW5nOyAgICAgICAgICAgLy8gRGV2aWNlIElEIHRoYXQgcmVzb2x2ZWQgdGhlIGNvbmZsaWN0XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgc3RydWN0dXJlIG9mIHRoZSBzeW5jIGZpbGUgWUFNTCBoZWFkZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTeW5jRmlsZUhlYWRlciB7XG4gICAgbGFzdEdsb2JhbFN5bmM6IG51bWJlcjsgICAgICAgICAgICAgLy8gTGFzdCB0aW1lIGFueSBkZXZpY2Ugc3luY2VkIHN1Y2Nlc3NmdWxseVxuICAgIHN5bmNTdGF0ZTogU3luY1N0YXRlOyAgICAgICAgICAgICAgIC8vIEN1cnJlbnQgc3luYyBzdGF0ZVxuICAgIHZhdWx0SWQ6IHN0cmluZzsgICAgICAgICAgICAgICAgICAgIC8vIFZhdWx0IGlkZW50aWZpZXJcbiAgICBwbHVnaW5WZXJzaW9uOiBzdHJpbmc7ICAgICAgICAgICAgICAvLyBQbHVnaW4gdmVyc2lvbiB0aGF0IGxhc3Qgd3JvdGUgdGhpcyBmaWxlXG4gICAgbGFzdFdyaXRlcjogc3RyaW5nOyAgICAgICAgICAgICAgICAgLy8gRGV2aWNlIElEIHRoYXQgbGFzdCB3cm90ZSB0aGlzIGZpbGVcbiAgICBkZXZpY2VzOiBSZWNvcmQ8c3RyaW5nLCBTeW5jRGV2aWNlPjsgLy8gTWFwIG9mIGRldmljZSBJRHMgdG8gZGV2aWNlIGluZm9cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBmdWxsIHN0cnVjdHVyZSBvZiB0aGUgc3luYyBmaWxlXG4gKiBUaGlzIHdpbGwgYmUgc2VyaWFsaXplZCB0by9mcm9tIFlBTUxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTeW5jRmlsZURhdGEge1xuICAgIGhlYWRlcjogU3luY0ZpbGVIZWFkZXI7XG4gICAgY29ubmVjdGlvbkV2ZW50czogQ29ubmVjdGlvbkV2ZW50W107ICAgLy8gUmVjZW50IGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlc1xuICAgIHBlbmRpbmdPcGVyYXRpb25zOiBQZW5kaW5nT3BlcmF0aW9uW107IC8vIE9wZXJhdGlvbnMgcXVldWVkIGR1cmluZyBvZmZsaW5lIG1vZGVcbiAgICBjb25mbGljdHM6IFN5bmNDb25mbGljdFtdOyAgICAgICAgICAgIC8vIERldGVjdGVkIHN5bmMgY29uZmxpY3RzXG4gICAgbGFzdERhdGFiYXNlQ2hlY2s6IG51bWJlcjsgICAgICAgICAgICAvLyBMYXN0IHRpbWUgZGF0YWJhc2UgY29ubmVjdGl2aXR5IHdhcyBjaGVja2VkXG4gICAgZGF0YWJhc2VTdGF0dXM6ICdhdmFpbGFibGUnIHwgJ3VuYXZhaWxhYmxlJyB8ICd1bmtub3duJztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB2YWxpZGF0aW9uIHN0YXR1cyBvZiB0aGUgc3luYyBmaWxlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3luY1ZhbGlkYXRpb25SZXN1bHQge1xuICAgIGlzVmFsaWQ6IGJvb2xlYW47XG4gICAgZXJyb3I/OiBzdHJpbmc7XG4gICAgZGV0YWlscz86IFJlY29yZDxzdHJpbmcsIGFueT47XG59XG5cbi8qKlxuICogRXJyb3IgdHlwZXMgc3BlY2lmaWMgdG8gc3luYyBvcGVyYXRpb25zXG4gKi9cbmV4cG9ydCBlbnVtIFN5bmNFcnJvclR5cGUge1xuICAgIFNZTkNfRklMRV9NSVNTSU5HID0gJ3N5bmNfZmlsZV9taXNzaW5nJyxcbiAgICBTWU5DX0ZJTEVfQ09SUlVQVCA9ICdzeW5jX2ZpbGVfY29ycnVwdCcsXG4gICAgU1lOQ19GSUxFX09VVERBVEVEID0gJ3N5bmNfZmlsZV9vdXRkYXRlZCcsXG4gICAgREVWSUNFX01JU01BVENIID0gJ2RldmljZV9taXNtYXRjaCcsXG4gICAgQ09ORkxJQ1RfREVURUNURUQgPSAnY29uZmxpY3RfZGV0ZWN0ZWQnLFxuICAgIERBVEFCQVNFX1VOQVZBSUxBQkxFID0gJ2RhdGFiYXNlX3VuYXZhaWxhYmxlJyxcbiAgICBTWU5DX0lOVEVSUlVQVEVEID0gJ3N5bmNfaW50ZXJydXB0ZWQnLFxuICAgIFVOS05PV05fRVJST1IgPSAndW5rbm93bl9lcnJvcidcbn1cblxuLyoqXG4gKiBEZWZhdWx0IG1heGltdW0gaXRlbXMgdG8ga2VlcCBpbiBlYWNoIGhpc3RvcnkgbGlzdFxuICovXG5leHBvcnQgY29uc3QgTUFYX0NPTk5FQ1RJT05fRVZFTlRTID0gMjA7XG5leHBvcnQgY29uc3QgTUFYX1BFTkRJTkdfT1BFUkFUSU9OUyA9IDEwMDtcbmV4cG9ydCBjb25zdCBNQVhfQ09ORkxJQ1RTID0gNTA7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBwbGF0Zm9ybSBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGxhdGZvcm1JbmZvKCk6IHN0cmluZyB7XG4gICAgY29uc3QgdXNlckFnZW50ID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgICBpZiAodXNlckFnZW50LmluZGV4T2YoJ1dpbicpICE9PSAtMSkgcmV0dXJuICdXaW5kb3dzJztcbiAgICBpZiAodXNlckFnZW50LmluZGV4T2YoJ01hYycpICE9PSAtMSkgcmV0dXJuICdtYWNPUyc7XG4gICAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdpUGhvbmUnKSAhPT0gLTEgfHwgdXNlckFnZW50LmluZGV4T2YoJ2lQYWQnKSAhPT0gLTEpIHJldHVybiAnaU9TJztcbiAgICBpZiAodXNlckFnZW50LmluZGV4T2YoJ0FuZHJvaWQnKSAhPT0gLTEpIHJldHVybiAnQW5kcm9pZCc7XG4gICAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdMaW51eCcpICE9PSAtMSkgcmV0dXJuICdMaW51eCc7XG5cbiAgICByZXR1cm4gJ1Vua25vd24nO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZW1wdHkgc3luYyBmaWxlIGRhdGEgc3RydWN0dXJlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbXB0eVN5bmNGaWxlRGF0YShcbiAgICB2YXVsdElkOiBzdHJpbmcsXG4gICAgZGV2aWNlSWQ6IHN0cmluZyxcbiAgICBkZXZpY2VOYW1lOiBzdHJpbmcsXG4gICAgcGx1Z2luVmVyc2lvbjogc3RyaW5nXG4pOiBTeW5jRmlsZURhdGEge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcGxhdGZvcm0gPSBnZXRQbGF0Zm9ybUluZm8oKTtcblxuICAgIGNvbnN0IGRldmljZTogU3luY0RldmljZSA9IHtcbiAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgIG5hbWU6IGRldmljZU5hbWUsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBsYXN0U2Vlbjogbm93LFxuICAgICAgICBsYXN0U3luY1RpbWU6IG5vd1xuICAgIH07XG5cbiAgICBjb25zdCBkZXZpY2VzOiBSZWNvcmQ8c3RyaW5nLCBTeW5jRGV2aWNlPiA9IHt9O1xuICAgIGRldmljZXNbZGV2aWNlSWRdID0gZGV2aWNlO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGVyOiB7XG4gICAgICAgICAgICBsYXN0R2xvYmFsU3luYzogbm93LFxuICAgICAgICAgICAgc3luY1N0YXRlOiBTeW5jU3RhdGUuSU5JVElBTElaSU5HLFxuICAgICAgICAgICAgdmF1bHRJZCxcbiAgICAgICAgICAgIHBsdWdpblZlcnNpb24sXG4gICAgICAgICAgICBsYXN0V3JpdGVyOiBkZXZpY2VJZCxcbiAgICAgICAgICAgIGRldmljZXNcbiAgICAgICAgfSxcbiAgICAgICAgY29ubmVjdGlvbkV2ZW50czogW10sXG4gICAgICAgIHBlbmRpbmdPcGVyYXRpb25zOiBbXSxcbiAgICAgICAgY29uZmxpY3RzOiBbXSxcbiAgICAgICAgbGFzdERhdGFiYXNlQ2hlY2s6IG5vdyxcbiAgICAgICAgZGF0YWJhc2VTdGF0dXM6ICd1bmtub3duJ1xuICAgIH07XG59XG5cbi8qKlxuICogVHJpbXMgaGlzdG9yeSBhcnJheXMgdG8ga2VlcCB0aGVtIGF0IGEgcmVhc29uYWJsZSBzaXplXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltU3luY0hpc3RvcnlBcnJheXMoZGF0YTogU3luY0ZpbGVEYXRhKTogU3luY0ZpbGVEYXRhIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBjb25uZWN0aW9uRXZlbnRzOiBkYXRhLmNvbm5lY3Rpb25FdmVudHMuc2xpY2UoLU1BWF9DT05ORUNUSU9OX0VWRU5UUyksXG4gICAgICAgIHBlbmRpbmdPcGVyYXRpb25zOiBkYXRhLnBlbmRpbmdPcGVyYXRpb25zLnNsaWNlKC1NQVhfUEVORElOR19PUEVSQVRJT05TKSxcbiAgICAgICAgY29uZmxpY3RzOiBkYXRhLmNvbmZsaWN0cy5zbGljZSgtTUFYX0NPTkZMSUNUUylcbiAgICB9O1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgZGV2aWNlIGluZm9ybWF0aW9uIGluIHRoZSBzeW5jIGZpbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZURldmljZUluU3luY0ZpbGUoXG4gICAgZGF0YTogU3luY0ZpbGVEYXRhLFxuICAgIGRldmljZUlkOiBzdHJpbmcsXG4gICAgZGV2aWNlTmFtZTogc3RyaW5nLFxuICAgIHBsdWdpblZlcnNpb24/OiBzdHJpbmdcbik6IFN5bmNGaWxlRGF0YSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBwbGF0Zm9ybSA9IGdldFBsYXRmb3JtSW5mbygpO1xuXG4gICAgLy8gRGVlcCBjbG9uZSB0aGUgZGF0YSB0byBhdm9pZCBtdXRhdGlvbnNcbiAgICBjb25zdCBuZXdEYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSkgYXMgU3luY0ZpbGVEYXRhO1xuXG4gICAgaWYgKCFuZXdEYXRhLmhlYWRlci5kZXZpY2VzKSB7XG4gICAgICAgIG5ld0RhdGEuaGVhZGVyLmRldmljZXMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgb3IgY3JlYXRlIGRldmljZSBlbnRyeVxuICAgIGlmIChuZXdEYXRhLmhlYWRlci5kZXZpY2VzW2RldmljZUlkXSkge1xuICAgICAgICBuZXdEYXRhLmhlYWRlci5kZXZpY2VzW2RldmljZUlkXSA9IHtcbiAgICAgICAgICAgIC4uLm5ld0RhdGEuaGVhZGVyLmRldmljZXNbZGV2aWNlSWRdLFxuICAgICAgICAgICAgbmFtZTogZGV2aWNlTmFtZSxcbiAgICAgICAgICAgIHBsYXRmb3JtLFxuICAgICAgICAgICAgbGFzdFNlZW46IG5vdyxcbiAgICAgICAgICAgIHBsdWdpblZlcnNpb246IHBsdWdpblZlcnNpb24gfHwgbmV3RGF0YS5oZWFkZXIuZGV2aWNlc1tkZXZpY2VJZF0ucGx1Z2luVmVyc2lvblxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0RhdGEuaGVhZGVyLmRldmljZXNbZGV2aWNlSWRdID0ge1xuICAgICAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgICAgICBuYW1lOiBkZXZpY2VOYW1lLFxuICAgICAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgICAgICBsYXN0U2Vlbjogbm93LFxuICAgICAgICAgICAgbGFzdFN5bmNUaW1lOiBub3csXG4gICAgICAgICAgICBwbHVnaW5WZXJzaW9uXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbmV3RGF0YS5oZWFkZXIubGFzdFdyaXRlciA9IGRldmljZUlkO1xuICAgIGlmIChwbHVnaW5WZXJzaW9uKSB7XG4gICAgICAgIG5ld0RhdGEuaGVhZGVyLnBsdWdpblZlcnNpb24gPSBwbHVnaW5WZXJzaW9uO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdEYXRhO1xufVxuXG4vKipcbiAqIEFkZHMgYSBjb25uZWN0aW9uIGV2ZW50IHRvIHRoZSBzeW5jIGZpbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvbm5lY3Rpb25FdmVudChcbiAgICBkYXRhOiBTeW5jRmlsZURhdGEsXG4gICAgZXZlbnRUeXBlOiAnY29ubmVjdGVkJyB8ICdkaXNjb25uZWN0ZWQnLFxuICAgIGRldmljZUlkOiBzdHJpbmcsXG4gICAgZGV0YWlscz86IHN0cmluZ1xuKTogU3luY0ZpbGVEYXRhIHtcbiAgICBjb25zdCBuZXdEYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSkgYXMgU3luY0ZpbGVEYXRhO1xuXG4gICAgbmV3RGF0YS5jb25uZWN0aW9uRXZlbnRzLnB1c2goe1xuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIGV2ZW50VHlwZSxcbiAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgIGRldGFpbHNcbiAgICB9KTtcblxuICAgIC8vIEtlZXAgYXJyYXkgc2l6ZSBtYW5hZ2VhYmxlXG4gICAgaWYgKG5ld0RhdGEuY29ubmVjdGlvbkV2ZW50cy5sZW5ndGggPiBNQVhfQ09OTkVDVElPTl9FVkVOVFMpIHtcbiAgICAgICAgbmV3RGF0YS5jb25uZWN0aW9uRXZlbnRzID0gbmV3RGF0YS5jb25uZWN0aW9uRXZlbnRzLnNsaWNlKC1NQVhfQ09OTkVDVElPTl9FVkVOVFMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdEYXRhO1xufVxuXG4vKipcbiAqIEFkZHMgYSBwZW5kaW5nIG9wZXJhdGlvbiB0byB0aGUgc3luYyBmaWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRQZW5kaW5nT3BlcmF0aW9uKFxuICAgIGRhdGE6IFN5bmNGaWxlRGF0YSxcbiAgICBmaWxlSWQ6IHN0cmluZyxcbiAgICBvcGVyYXRpb25UeXBlOiAnY3JlYXRlJyB8ICd1cGRhdGUnIHwgJ2RlbGV0ZScgfCAncmVuYW1lJyxcbiAgICBkZXZpY2VJZDogc3RyaW5nLFxuICAgIG1ldGFkYXRhPzoge1xuICAgICAgICBvbGRQYXRoPzogc3RyaW5nO1xuICAgICAgICBjb250ZW50SGFzaD86IHN0cmluZztcbiAgICAgICAgbGFzdE1vZGlmaWVkPzogbnVtYmVyO1xuICAgIH1cbik6IFN5bmNGaWxlRGF0YSB7XG4gICAgY29uc3QgbmV3RGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpIGFzIFN5bmNGaWxlRGF0YTtcblxuICAgIG5ld0RhdGEucGVuZGluZ09wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgICBmaWxlSWQsXG4gICAgICAgIG9wZXJhdGlvblR5cGUsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJ1xuICAgIH0pO1xuXG4gICAgLy8gS2VlcCBhcnJheSBzaXplIG1hbmFnZWFibGVcbiAgICBpZiAobmV3RGF0YS5wZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPiBNQVhfUEVORElOR19PUEVSQVRJT05TKSB7XG4gICAgICAgIG5ld0RhdGEucGVuZGluZ09wZXJhdGlvbnMgPSBuZXdEYXRhLnBlbmRpbmdPcGVyYXRpb25zLnNsaWNlKC1NQVhfUEVORElOR19PUEVSQVRJT05TKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RGF0YTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgc3luYyBjb25mbGljdCB0byB0aGUgc3luYyBmaWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRTeW5jQ29uZmxpY3QoXG4gICAgZGF0YTogU3luY0ZpbGVEYXRhLFxuICAgIGZpbGVJZDogc3RyaW5nLFxuICAgIGRldmljZXM6IHN0cmluZ1tdXG4pOiBTeW5jRmlsZURhdGEge1xuICAgIGNvbnN0IG5ld0RhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpKSBhcyBTeW5jRmlsZURhdGE7XG5cbiAgICBuZXdEYXRhLmNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXG4gICAgICAgIGZpbGVJZCxcbiAgICAgICAgZGV0ZWN0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgZGV2aWNlcyxcbiAgICAgICAgcmVzb2x1dGlvblN0YXR1czogJ3BlbmRpbmcnXG4gICAgfSk7XG5cbiAgICAvLyBLZWVwIGFycmF5IHNpemUgbWFuYWdlYWJsZVxuICAgIGlmIChuZXdEYXRhLmNvbmZsaWN0cy5sZW5ndGggPiBNQVhfQ09ORkxJQ1RTKSB7XG4gICAgICAgIG5ld0RhdGEuY29uZmxpY3RzID0gbmV3RGF0YS5jb25mbGljdHMuc2xpY2UoLU1BWF9DT05GTElDVFMpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzeW5jIHN0YXRlIHRvIGluZGljYXRlIGNvbmZsaWN0XG4gICAgbmV3RGF0YS5oZWFkZXIuc3luY1N0YXRlID0gU3luY1N0YXRlLkNPTkZMSUNUO1xuXG4gICAgcmV0dXJuIG5ld0RhdGE7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgZGF0YWJhc2Ugc3RhdHVzIGluIHRoZSBzeW5jIGZpbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZURhdGFiYXNlU3RhdHVzKFxuICAgIGRhdGE6IFN5bmNGaWxlRGF0YSxcbiAgICBzdGF0dXM6ICdhdmFpbGFibGUnIHwgJ3VuYXZhaWxhYmxlJyB8ICd1bmtub3duJ1xuKTogU3luY0ZpbGVEYXRhIHtcbiAgICBjb25zdCBuZXdEYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSkgYXMgU3luY0ZpbGVEYXRhO1xuXG4gICAgbmV3RGF0YS5kYXRhYmFzZVN0YXR1cyA9IHN0YXR1cztcbiAgICBuZXdEYXRhLmxhc3REYXRhYmFzZUNoZWNrID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIFVwZGF0ZSBzeW5jIHN0YXRlIGJhc2VkIG9uIGRhdGFiYXNlIHN0YXR1c1xuICAgIGlmIChzdGF0dXMgPT09ICd1bmF2YWlsYWJsZScpIHtcbiAgICAgICAgbmV3RGF0YS5oZWFkZXIuc3luY1N0YXRlID0gU3luY1N0YXRlLk9GRkxJTkU7XG4gICAgfSBlbHNlIGlmIChzdGF0dXMgPT09ICdhdmFpbGFibGUnKSB7XG4gICAgICAgIG5ld0RhdGEuaGVhZGVyLnN5bmNTdGF0ZSA9IFN5bmNTdGF0ZS5PTkxJTkU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0RhdGE7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgbGFzdCBzeW5jIHRpbWUgZm9yIGEgZGV2aWNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVEZXZpY2VTeW5jVGltZShcbiAgICBkYXRhOiBTeW5jRmlsZURhdGEsXG4gICAgZGV2aWNlSWQ6IHN0cmluZ1xuKTogU3luY0ZpbGVEYXRhIHtcbiAgICBjb25zdCBuZXdEYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSkgYXMgU3luY0ZpbGVEYXRhO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBpZiAobmV3RGF0YS5oZWFkZXIuZGV2aWNlcyAmJiBuZXdEYXRhLmhlYWRlci5kZXZpY2VzW2RldmljZUlkXSkge1xuICAgICAgICBuZXdEYXRhLmhlYWRlci5kZXZpY2VzW2RldmljZUlkXS5sYXN0U3luY1RpbWUgPSBub3c7XG4gICAgICAgIG5ld0RhdGEuaGVhZGVyLmRldmljZXNbZGV2aWNlSWRdLmxhc3RTZWVuID0gbm93O1xuICAgICAgICBuZXdEYXRhLmhlYWRlci5sYXN0R2xvYmFsU3luYyA9IG5vdztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RGF0YTtcbn1cbiIsICIvLyBzcmMvdXRpbHMvRXJyb3JIYW5kbGVyLnRzXG5pbXBvcnQgeyBEb2N1bWVudFByb2Nlc3NpbmdFcnJvciB9IGZyb20gJy4uL21vZGVscy9Eb2N1bWVudENodW5rJztcbmltcG9ydCB7IFRhc2tQcm9jZXNzaW5nRXJyb3IgfSBmcm9tICcuLi9tb2RlbHMvUHJvY2Vzc2luZ1Rhc2snO1xuaW1wb3J0IHsgU3luY0Vycm9yVHlwZSB9IGZyb20gJy4uL21vZGVscy9TeW5jTW9kZWxzJztcbmltcG9ydCB7IERlYnVnU2V0dGluZ3MgfSBmcm9tICcuLi9zZXR0aW5ncy9TZXR0aW5ncyc7XG5pbXBvcnQgeyBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBQb3N0Z3Jlc3RFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JDb250ZXh0IHtcblx0Y29udGV4dDogc3RyaW5nO1xuXHR0YXNrSWQ/OiBzdHJpbmc7XG5cdHRhc2tUeXBlPzogc3RyaW5nO1xuXHRtZXRhZGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JMb2cge1xuXHR0aW1lc3RhbXA6IG51bWJlcjtcblx0ZXJyb3I6IEVycm9yO1xuXHRjb250ZXh0OiBFcnJvckNvbnRleHQ7XG5cdGxldmVsOiAnZXJyb3InIHwgJ3dhcm4nIHwgJ2luZm8nIHwgJ2RlYnVnJztcblx0aGFuZGxlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdXBhYmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb2RlOiBzdHJpbmc7XG5cdGRldGFpbHM6IHN0cmluZztcblx0aGludD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTeW5jRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdHR5cGU6IFN5bmNFcnJvclR5cGU7XG5cdGRldGFpbHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXHRkZXZpY2VJZD86IHN0cmluZztcblx0cmVjb3ZlcmFibGU6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBFcnJvckhhbmRsZXIge1xuXHRwcml2YXRlIGVycm9yTG9nczogRXJyb3JMb2dbXSA9IFtdO1xuXHRwcml2YXRlIHJlYWRvbmx5IG1heExvZ3M6IG51bWJlciA9IDEwMDtcblx0cHJpdmF0ZSBzZXR0aW5nczogRGVidWdTZXR0aW5ncztcblx0cHJpdmF0ZSBsb2dGaWxlUGF0aD86IHN0cmluZztcblxuXHRjb25zdHJ1Y3RvcihzZXR0aW5nczogRGVidWdTZXR0aW5ncywgdmF1bHRQYXRoPzogc3RyaW5nKSB7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuXHRcdGlmIChzZXR0aW5ncy5sb2dUb0ZpbGUgJiYgdmF1bHRQYXRoKSB7XG5cdFx0XHR0aGlzLmxvZ0ZpbGVQYXRoID0gYCR7dmF1bHRQYXRofS8ub2JzaWRpYW4vbWluZC1tYXRyaXgubG9nYDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBlcnJvcnMgd2l0aCBjb250ZXh0IGFuZCBvcHRpb25hbCByZWNvdmVyeS5cblx0ICovXG5cdGhhbmRsZUVycm9yKGVycm9yOiBhbnksIGNvbnRleHQ6IEVycm9yQ29udGV4dCwgbGV2ZWw6ICdlcnJvcicgfCAnd2FybicgfCAnaW5mbycgfCAnZGVidWcnID0gJ2Vycm9yJyk6IHZvaWQge1xuXHRcdGlmICghdGhpcy5zaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGNvbnN0IGVycm9yTG9nOiBFcnJvckxvZyA9IHtcblx0XHRcdHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcblx0XHRcdGVycm9yOiB0aGlzLm5vcm1hbGl6ZUVycm9yKGVycm9yKSxcblx0XHRcdGNvbnRleHQsXG5cdFx0XHRsZXZlbCxcblx0XHRcdGhhbmRsZWQ6IGZhbHNlXG5cdFx0fTtcblx0XHR0aGlzLmVycm9yTG9ncy51bnNoaWZ0KGVycm9yTG9nKTtcblx0XHRpZiAodGhpcy5lcnJvckxvZ3MubGVuZ3RoID4gdGhpcy5tYXhMb2dzKSB7XG5cdFx0XHR0aGlzLmVycm9yTG9ncy5wb3AoKTtcblx0XHR9XG5cdFx0Ly8gU2hvdyBhIG5vdGljZSBmb3IgaW1wb3J0YW50IGVycm9ycy5cblx0XHRpZiAobGV2ZWwgPT09ICdlcnJvcicgfHwgKGxldmVsID09PSAnd2FybicgJiYgdGhpcy5zZXR0aW5ncy5sb2dMZXZlbCA9PT0gJ2RlYnVnJykpIHtcblx0XHRcdG5ldyBOb3RpY2UoYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG5cdFx0fVxuXHRcdC8vIERlYnVnIGxvZ2dpbmcuXG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MuZW5hYmxlRGVidWdMb2dzKSB7XG5cdFx0XHRjb25zb2xlLmdyb3VwKGBbJHtsZXZlbC50b1VwcGVyQ2FzZSgpfV0gJHtjb250ZXh0LmNvbnRleHR9YCk7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhaWxzOicsIGVycm9yKTtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0NvbnRleHQ6JywgY29udGV4dCk7XG5cdFx0XHRpZiAoZXJyb3Iuc3RhY2spIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignU3RhY2sgdHJhY2U6JywgZXJyb3Iuc3RhY2spO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5ncm91cEVuZCgpO1xuXHRcdH1cblx0XHQvLyBGaWxlIGxvZ2dpbmcgaWYgZW5hYmxlZC5cblx0XHRpZiAodGhpcy5zZXR0aW5ncy5sb2dUb0ZpbGUgJiYgdGhpcy5sb2dGaWxlUGF0aCkge1xuXHRcdFx0dGhpcy53cml0ZVRvTG9nRmlsZShlcnJvckxvZyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW5kIGhhbmRsZXMgYSBzeW5jIGVycm9yLlxuXHQgKi9cblx0aGFuZGxlU3luY0Vycm9yKFxuXHRcdHR5cGU6IFN5bmNFcnJvclR5cGUsXG5cdFx0bWVzc2FnZTogc3RyaW5nLFxuXHRcdGNvbnRleHQ6IEVycm9yQ29udGV4dCxcblx0XHRkZXRhaWxzPzogUmVjb3JkPHN0cmluZywgYW55Pixcblx0XHRkZXZpY2VJZD86IHN0cmluZyxcblx0XHRyZWNvdmVyYWJsZTogYm9vbGVhbiA9IHRydWVcblx0KTogU3luY0Vycm9yIHtcblx0XHRjb25zdCBlcnJvcjogU3luY0Vycm9yID0ge1xuXHRcdFx0bmFtZTogJ1N5bmNFcnJvcicsXG5cdFx0XHRtZXNzYWdlLFxuXHRcdFx0dHlwZSxcblx0XHRcdGRldGFpbHMsXG5cdFx0XHRkZXZpY2VJZCxcblx0XHRcdHJlY292ZXJhYmxlLFxuXHRcdFx0c3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrXG5cdFx0fTtcblx0XHR0aGlzLmhhbmRsZUVycm9yKGVycm9yLCBjb250ZXh0LCByZWNvdmVyYWJsZSA/ICd3YXJuJyA6ICdlcnJvcicpO1xuXHRcdHJldHVybiBlcnJvcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGNvbm5lY3Rpb24gZXJyb3JzIHNwZWNpZmljYWxseSBmb3Igc3luYyBvcGVyYXRpb25zLlxuXHQgKi9cblx0aGFuZGxlQ29ubmVjdGlvbkVycm9yKGVycm9yOiBhbnksIGNvbnRleHQ6IHN0cmluZywgZGV2aWNlSWQ/OiBzdHJpbmcpOiB2b2lkIHtcblx0XHRsZXQgc3luY0Vycm9yOiBTeW5jRXJyb3I7XG5cdFx0aWYgKGVycm9yICYmIGVycm9yLnR5cGUgJiYgT2JqZWN0LnZhbHVlcyhTeW5jRXJyb3JUeXBlKS5pbmNsdWRlcyhlcnJvci50eXBlIGFzIFN5bmNFcnJvclR5cGUpKSB7XG5cdFx0XHRzeW5jRXJyb3IgPSBlcnJvciBhcyBTeW5jRXJyb3I7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN5bmNFcnJvciA9IHtcblx0XHRcdFx0bmFtZTogJ1N5bmNFcnJvcicsXG5cdFx0XHRcdG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZXJyb3InLFxuXHRcdFx0XHR0eXBlOiBTeW5jRXJyb3JUeXBlLkRBVEFCQVNFX1VOQVZBSUxBQkxFLFxuXHRcdFx0XHRkZXRhaWxzOiB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH0sXG5cdFx0XHRcdGRldmljZUlkLFxuXHRcdFx0XHRyZWNvdmVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0c3RhY2s6IGVycm9yLnN0YWNrIHx8IG5ldyBFcnJvcigpLnN0YWNrXG5cdFx0XHR9O1xuXHRcdH1cblx0XHR0aGlzLmhhbmRsZUVycm9yKHN5bmNFcnJvciwgeyBjb250ZXh0IH0sICd3YXJuJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBsZXZlbCBzaG91bGQgYmUgbG9nZ2VkLlxuXHQgKi9cblx0cHJpdmF0ZSBzaG91bGRMb2cobGV2ZWw6ICdlcnJvcicgfCAnd2FybicgfCAnaW5mbycgfCAnZGVidWcnKTogYm9vbGVhbiB7XG5cdFx0Y29uc3QgbGV2ZWxzID0geyBlcnJvcjogMCwgd2FybjogMSwgaW5mbzogMiwgZGVidWc6IDMgfTtcblx0XHRyZXR1cm4gbGV2ZWxzW2xldmVsXSA8PSBsZXZlbHNbdGhpcy5zZXR0aW5ncy5sb2dMZXZlbF07XG5cdH1cblxuXHQvKipcblx0ICogTm9ybWFsaXplcyBkaWZmZXJlbnQgZXJyb3IgZm9ybWF0cy5cblx0ICovXG5cdHByaXZhdGUgbm9ybWFsaXplRXJyb3IoZXJyb3I6IGFueSk6IEVycm9yIHtcblx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdH1cblx0XHQvLyBIYW5kbGUgU3luYyBlcnJvcnMuXG5cdFx0aWYgKGVycm9yICYmIGVycm9yLnR5cGUgJiYgT2JqZWN0LnZhbHVlcyhTeW5jRXJyb3JUeXBlKS5pbmNsdWRlcyhlcnJvci50eXBlIGFzIFN5bmNFcnJvclR5cGUpKSB7XG5cdFx0XHRjb25zdCBzeW5jRXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSB8fCAnU3luYyBlcnJvcicpO1xuXHRcdFx0c3luY0Vycm9yLm5hbWUgPSAnU3luY0Vycm9yJztcblx0XHRcdE9iamVjdC5hc3NpZ24oc3luY0Vycm9yLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4gc3luY0Vycm9yO1xuXHRcdH1cblx0XHQvLyBIYW5kbGUgU3VwYWJhc2UgZXJyb3JzLlxuXHRcdGlmICh0aGlzLmlzU3VwYWJhc2VFcnJvcihlcnJvcikpIHtcblx0XHRcdHJldHVybiBuZXcgRXJyb3IoYERhdGFiYXNlIGVycm9yICgke2Vycm9yLmNvZGV9KTogJHtlcnJvci5tZXNzYWdlfSR7ZXJyb3IuaGludCA/IGAgLSAke2Vycm9yLmhpbnR9YCA6ICcnfWApO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIG5ldyBFcnJvcihlcnJvcik7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRjb25zdCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcic7XG5cdFx0XHRjb25zdCBub3JtYWxpemVkRXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG5cdFx0XHRPYmplY3QuYXNzaWduKG5vcm1hbGl6ZWRFcnJvciwgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIG5vcm1hbGl6ZWRFcnJvcjtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBFcnJvcignVW5rbm93biBlcnJvciBvY2N1cnJlZCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFR5cGUgZ3VhcmQgZm9yIFN1cGFiYXNlIGVycm9ycy5cblx0ICovXG5cdHByaXZhdGUgaXNTdXBhYmFzZUVycm9yKGVycm9yOiBhbnkpOiBlcnJvciBpcyBQb3N0Z3Jlc3RFcnJvciB7XG5cdFx0cmV0dXJuIGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgJ2NvZGUnIGluIGVycm9yICYmICdkZXRhaWxzJyBpbiBlcnJvcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBUeXBlIGd1YXJkIGZvciBTeW5jIGVycm9ycy5cblx0ICovXG5cdGlzU3luY0Vycm9yKGVycm9yOiBhbnkpOiBlcnJvciBpcyBTeW5jRXJyb3Ige1xuXHRcdHJldHVybiBlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmICd0eXBlJyBpbiBlcnJvciAmJiBPYmplY3QudmFsdWVzKFN5bmNFcnJvclR5cGUpLmluY2x1ZGVzKGVycm9yLnR5cGUgYXMgU3luY0Vycm9yVHlwZSk7XG5cdH1cblxuXHQvKipcblx0ICogU2hvd3MgYW4gYXBwcm9wcmlhdGUgbm90aWZpY2F0aW9uIGJhc2VkIG9uIGVycm9yIHR5cGUuXG5cdCAqL1xuXHRwcml2YXRlIHNob3dFcnJvck5vdGlmaWNhdGlvbihlcnJvcjogYW55KTogdm9pZCB7XG5cdFx0bGV0IG1lc3NhZ2UgPSAnQW4gZXJyb3Igb2NjdXJyZWQnO1xuXHRcdGxldCBkdXJhdGlvbiA9IDQwMDA7XG5cdFx0aWYgKHRoaXMuaXNTeW5jRXJyb3IoZXJyb3IpKSB7XG5cdFx0XHRzd2l0Y2goZXJyb3IudHlwZSkge1xuXHRcdFx0XHRjYXNlIFN5bmNFcnJvclR5cGUuU1lOQ19GSUxFX01JU1NJTkc6XG5cdFx0XHRcdFx0bWVzc2FnZSA9ICdTeW5jIGZpbGUgaXMgbWlzc2luZy4gV2lsbCBhdHRlbXB0IHRvIHJlY3JlYXRlLic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgU3luY0Vycm9yVHlwZS5TWU5DX0ZJTEVfQ09SUlVQVDpcblx0XHRcdFx0XHRtZXNzYWdlID0gJ1N5bmMgZmlsZSBpcyBjb3JydXB0ZWQuIFdpbGwgYXR0ZW1wdCB0byByZXBhaXIuJztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBTeW5jRXJyb3JUeXBlLkRFVklDRV9NSVNNQVRDSDpcblx0XHRcdFx0XHRtZXNzYWdlID0gJ0RldmljZSBpZGVudGlmaWNhdGlvbiBpc3N1ZS4gQ2hlY2sgcGx1Z2luIHNldHRpbmdzLic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgU3luY0Vycm9yVHlwZS5DT05GTElDVF9ERVRFQ1RFRDpcblx0XHRcdFx0XHRtZXNzYWdlID0gJ1N5bmMgY29uZmxpY3QgZGV0ZWN0ZWQuIENoZWNrIHN5bmMgc3RhdHVzIGZvciBkZXRhaWxzLic7XG5cdFx0XHRcdFx0ZHVyYXRpb24gPSA2MDAwO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFN5bmNFcnJvclR5cGUuREFUQUJBU0VfVU5BVkFJTEFCTEU6XG5cdFx0XHRcdFx0bWVzc2FnZSA9ICdEYXRhYmFzZSBjb25uZWN0aW9uIHVuYXZhaWxhYmxlLiBPcGVyYXRpbmcgaW4gb2ZmbGluZSBtb2RlLic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgU3luY0Vycm9yVHlwZS5TWU5DX0lOVEVSUlVQVEVEOlxuXHRcdFx0XHRcdG1lc3NhZ2UgPSAnU3luYyBvcGVyYXRpb24gd2FzIGludGVycnVwdGVkLiBXaWxsIHJldHJ5Lic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0bWVzc2FnZSA9IGBTeW5jIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRoaXMuaXNTdXBhYmFzZUVycm9yKGVycm9yKSkge1xuXHRcdFx0c3dpdGNoIChlcnJvci5jb2RlKSB7XG5cdFx0XHRcdGNhc2UgJzQyUDAxJzpcblx0XHRcdFx0XHRtZXNzYWdlID0gJ0RhdGFiYXNlIHRhYmxlIG5vdCBmb3VuZC4gUGxlYXNlIHJ1biBzZXR1cCBTUUwuJztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnNDI1MDEnOlxuXHRcdFx0XHRcdG1lc3NhZ2UgPSAnSW5zdWZmaWNpZW50IGRhdGFiYXNlIHBlcm1pc3Npb25zLic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJzIzNTA1Jzpcblx0XHRcdFx0XHRtZXNzYWdlID0gJ0R1cGxpY2F0ZSBlbnRyeSBmb3VuZC4nO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdG1lc3NhZ2UgPSBgRGF0YWJhc2UgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gO1xuXHRcdFx0fVxuXHRcdFx0ZHVyYXRpb24gPSA2MDAwO1xuXHRcdH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IuQ0hVTktJTkdfRVJST1IpIHtcblx0XHRcdG1lc3NhZ2UgPSAnRXJyb3Igc3BsaXR0aW5nIGRvY3VtZW50IGludG8gY2h1bmtzJztcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLkVNQkVERElOR19FUlJPUikge1xuXHRcdFx0bWVzc2FnZSA9ICdFcnJvciBnZW5lcmF0aW5nIGVtYmVkZGluZ3MnO1xuXHRcdH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IuREFUQUJBU0VfRVJST1IpIHtcblx0XHRcdG1lc3NhZ2UgPSAnRGF0YWJhc2Ugb3BlcmF0aW9uIGZhaWxlZCc7XG5cdFx0fSBlbHNlIGlmIChlcnJvci50eXBlID09PSBEb2N1bWVudFByb2Nlc3NpbmdFcnJvci5JTlZBTElEX01FVEFEQVRBKSB7XG5cdFx0XHRtZXNzYWdlID0gJ0ludmFsaWQgZG9jdW1lbnQgbWV0YWRhdGEnO1xuXHRcdH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IuRklMRV9BQ0NFU1NfRVJST1IpIHtcblx0XHRcdG1lc3NhZ2UgPSAnRXJyb3IgYWNjZXNzaW5nIGZpbGUnO1xuXHRcdH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IuWUFNTF9QQVJTRV9FUlJPUikge1xuXHRcdFx0bWVzc2FnZSA9ICdFcnJvciBwYXJzaW5nIFlBTUwgZnJvbnQgbWF0dGVyJztcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLlZFQ1RPUl9FWFRFTlNJT05fRVJST1IpIHtcblx0XHRcdG1lc3NhZ2UgPSAnVmVjdG9yIGV4dGVuc2lvbiBub3QgYXZhaWxhYmxlJztcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLlNZTkNfRVJST1IpIHtcblx0XHRcdG1lc3NhZ2UgPSAnU3luYyBvcGVyYXRpb24gZmFpbGVkJztcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IFRhc2tQcm9jZXNzaW5nRXJyb3IuUVVFVUVfRlVMTCkge1xuXHRcdFx0bWVzc2FnZSA9ICdUYXNrIHF1ZXVlIGlzIGZ1bGwnO1xuXHRcdH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gVGFza1Byb2Nlc3NpbmdFcnJvci5UQVNLX1RJTUVPVVQpIHtcblx0XHRcdG1lc3NhZ2UgPSAnVGFzayB0aW1lZCBvdXQnO1xuXHRcdH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gVGFza1Byb2Nlc3NpbmdFcnJvci5UQVNLX0NBTkNFTExFRCkge1xuXHRcdFx0bWVzc2FnZSA9ICdUYXNrIHdhcyBjYW5jZWxsZWQnO1xuXHRcdH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gVGFza1Byb2Nlc3NpbmdFcnJvci5NQVhfUkVUUklFU19FWENFRURFRCkge1xuXHRcdFx0bWVzc2FnZSA9ICdNYXhpbXVtIHJldHJ5IGF0dGVtcHRzIGV4Y2VlZGVkJztcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IFRhc2tQcm9jZXNzaW5nRXJyb3IuSU5WQUxJRF9UQVNLX1NUQVRFKSB7XG5cdFx0XHRtZXNzYWdlID0gJ0ludmFsaWQgdGFzayBzdGF0ZSc7XG5cdFx0fSBlbHNlIGlmIChlcnJvci50eXBlID09PSBUYXNrUHJvY2Vzc2luZ0Vycm9yLlRBU0tfTk9UX0ZPVU5EKSB7XG5cdFx0XHRtZXNzYWdlID0gJ1Rhc2sgbm90IGZvdW5kJztcblx0XHR9XG5cdFx0aWYgKGVycm9yLm1lc3NhZ2UgJiYgIXRoaXMuaXNTeW5jRXJyb3IoZXJyb3IpKSB7XG5cdFx0XHRtZXNzYWdlID0gYCR7bWVzc2FnZX06ICR7ZXJyb3IubWVzc2FnZX1gO1xuXHRcdH1cblx0XHRuZXcgTm90aWNlKG1lc3NhZ2UsIGR1cmF0aW9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBXcml0ZXMgZXJyb3IgbG9nIHRvIGZpbGUuXG5cdCAqL1xuXHRwcml2YXRlIHdyaXRlVG9Mb2dGaWxlKGxvZzogRXJyb3JMb2cpOiB2b2lkIHtcblx0XHRpZiAoIXRoaXMubG9nRmlsZVBhdGgpIHJldHVybjtcblx0XHRjb25zdCBsb2dFbnRyeSA9IHtcblx0XHRcdHRpbWVzdGFtcDogbmV3IERhdGUobG9nLnRpbWVzdGFtcCkudG9JU09TdHJpbmcoKSxcblx0XHRcdGxldmVsOiBsb2cubGV2ZWwudG9VcHBlckNhc2UoKSxcblx0XHRcdGNvbnRleHQ6IGxvZy5jb250ZXh0LmNvbnRleHQsXG5cdFx0XHRlcnJvcjogbG9nLmVycm9yLm1lc3NhZ2UsXG5cdFx0XHRzdGFjazogbG9nLmVycm9yLnN0YWNrLFxuXHRcdFx0bWV0YWRhdGE6IGxvZy5jb250ZXh0Lm1ldGFkYXRhXG5cdFx0fTtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCh3aW5kb3cgYXMgYW55KS5hcHA/LnZhdWx0Py5hZGFwdGVyPy5hcHBlbmQpIHtcblx0XHRcdFx0KHdpbmRvdyBhcyBhbnkpLmFwcC52YXVsdC5hZGFwdGVyLmFwcGVuZChcblx0XHRcdFx0XHR0aGlzLmxvZ0ZpbGVQYXRoLFxuXHRcdFx0XHRcdEpTT04uc3RyaW5naWZ5KGxvZ0VudHJ5KSArICdcXG4nXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB3cml0ZSB0byBsb2cgZmlsZTonLCBlcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0dXBkYXRlU2V0dGluZ3Moc2V0dGluZ3M6IERlYnVnU2V0dGluZ3MpOiB2b2lkIHtcblx0XHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG5cdH1cblxuXHRnZXRSZWNlbnRMb2dzKGNvdW50OiBudW1iZXIgPSAxMCk6IEVycm9yTG9nW10ge1xuXHRcdHJldHVybiB0aGlzLmVycm9yTG9ncy5zbGljZSgwLCBjb3VudCk7XG5cdH1cblxuXHRjbGVhckxvZ3MoKTogdm9pZCB7XG5cdFx0dGhpcy5lcnJvckxvZ3MgPSBbXTtcblx0fVxuXG5cdGdldEVycm9yU3RhdHMoKTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB7XG5cdFx0cmV0dXJuIHRoaXMuZXJyb3JMb2dzLnJlZHVjZSgoYWNjLCBsb2cpID0+IHtcblx0XHRcdGNvbnN0IGVycm9yVHlwZSA9IGxvZy5lcnJvci5uYW1lIHx8ICdVbmtub3duJztcblx0XHRcdGFjY1tlcnJvclR5cGVdID0gKGFjY1tlcnJvclR5cGVdIHx8IDApICsgMTtcblx0XHRcdHJldHVybiBhY2M7XG5cdFx0fSwge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPik7XG5cdH1cblxuXHRnZXRTeW5jRXJyb3JTdGF0cygpOiBSZWNvcmQ8U3luY0Vycm9yVHlwZSwgbnVtYmVyPiB7XG5cdFx0Y29uc3Qgc3RhdHMgPSB7fSBhcyBSZWNvcmQ8U3luY0Vycm9yVHlwZSwgbnVtYmVyPjtcblx0XHRPYmplY3QudmFsdWVzKFN5bmNFcnJvclR5cGUpLmZvckVhY2godHlwZSA9PiB7XG5cdFx0XHRzdGF0c1t0eXBlIGFzIFN5bmNFcnJvclR5cGVdID0gMDtcblx0XHR9KTtcblx0XHR0aGlzLmVycm9yTG9ncy5mb3JFYWNoKGxvZyA9PiB7XG5cdFx0XHRpZiAodGhpcy5pc1N5bmNFcnJvcihsb2cuZXJyb3IpKSB7XG5cdFx0XHRcdHN0YXRzW2xvZy5lcnJvci50eXBlXSA9IChzdGF0c1tsb2cuZXJyb3IudHlwZV0gfHwgMCkgKyAxO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBzdGF0cztcblx0fVxufVxuIiwgIi8vIHNyYy91dGlscy9Ob3RpZmljYXRpb25NYW5hZ2VyLnRzXG5pbXBvcnQgeyBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBUYXNrUHJvZ3Jlc3MgfSBmcm9tICcuLi9tb2RlbHMvUHJvY2Vzc2luZ1Rhc2snO1xuXG5leHBvcnQgY2xhc3MgTm90aWZpY2F0aW9uTWFuYWdlciB7XG5cdHByaXZhdGUgZml4ZWRQcm9ncmVzc0Jhcjoge1xuXHRcdGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG5cdFx0ZmlsbDogSFRNTEVsZW1lbnQ7XG5cdFx0dGV4dDogSFRNTEVsZW1lbnQ7XG5cdH0gfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBzdGF0dXNCYXJJdGVtOiBIVE1MRWxlbWVudDtcblx0cHJpdmF0ZSBlbmFibGVOb3RpZmljYXRpb25zOiBib29sZWFuO1xuXHRwcml2YXRlIGVuYWJsZVByb2dyZXNzQmFyOiBib29sZWFuO1xuXHRwcml2YXRlIG5vdGlmaWNhdGlvblF1ZXVlOiBzdHJpbmdbXSA9IFtdO1xuXHRwcml2YXRlIGlzUHJvY2Vzc2luZ1F1ZXVlOiBib29sZWFuID0gZmFsc2U7XG5cblx0Y29uc3RydWN0b3IoXG5cdFx0c3RhdHVzQmFyRWw6IEhUTUxFbGVtZW50LFxuXHRcdGVuYWJsZU5vdGlmaWNhdGlvbnM6IGJvb2xlYW4sXG5cdFx0ZW5hYmxlUHJvZ3Jlc3NCYXI6IGJvb2xlYW5cblx0KSB7XG5cdFx0dGhpcy5zdGF0dXNCYXJJdGVtID0gc3RhdHVzQmFyRWw7XG5cdFx0dGhpcy5lbmFibGVOb3RpZmljYXRpb25zID0gZW5hYmxlTm90aWZpY2F0aW9ucztcblx0XHR0aGlzLmVuYWJsZVByb2dyZXNzQmFyID0gZW5hYmxlUHJvZ3Jlc3NCYXI7XG5cdFx0dGhpcy5pbml0aWFsaXplU3RhdHVzQmFyKCk7XG5cdH1cblxuXHQvKipcblx0ICogU2hvd3MgYSBub3RpZmljYXRpb24gbWVzc2FnZS5cblx0ICovXG5cdHNob3dOb3RpZmljYXRpb24obWVzc2FnZTogc3RyaW5nLCBkdXJhdGlvbjogbnVtYmVyID0gNDAwMCk6IHZvaWQge1xuXHRcdGlmICghdGhpcy5lbmFibGVOb3RpZmljYXRpb25zKSByZXR1cm47XG5cdFx0Ly8gUXVldWUgbm90aWZpY2F0aW9uIHRvIGF2b2lkIHNwYW1taW5nIHRoZSBVSS5cblx0XHR0aGlzLm5vdGlmaWNhdGlvblF1ZXVlLnB1c2gobWVzc2FnZSk7XG5cdFx0aWYgKCF0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlKSB7XG5cdFx0XHR0aGlzLnByb2Nlc3NOb3RpZmljYXRpb25RdWV1ZSgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBmaXhlZCBwcm9ncmVzcyBiYXIgd2l0aCB0aGUgY3VycmVudCBwcm9ncmVzcyAoaW4gcGVyY2VudCkgYW5kIHN0YXR1cyBtZXNzYWdlLlxuXHQgKi9cblx0dXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3M6IFRhc2tQcm9ncmVzcyk6IHZvaWQge1xuXHRcdGlmICghdGhpcy5lbmFibGVQcm9ncmVzc0JhcikgcmV0dXJuO1xuXHRcdC8vIENyZWF0ZSB0aGUgZml4ZWQgcHJvZ3Jlc3MgYmFyIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG5cdFx0aWYgKCF0aGlzLmZpeGVkUHJvZ3Jlc3NCYXIpIHtcblx0XHRcdHRoaXMuZml4ZWRQcm9ncmVzc0JhciA9IHRoaXMuY3JlYXRlRml4ZWRQcm9ncmVzc0JhcigpO1xuXHRcdH1cblx0XHRjb25zdCBwcm9ncmVzc1BlcmNlbnRhZ2UgPSBNYXRoLnJvdW5kKHByb2dyZXNzLnByb2dyZXNzKTtcblx0XHR0aGlzLmZpeGVkUHJvZ3Jlc3NCYXIuZmlsbC5zdHlsZS53aWR0aCA9IGAke3Byb2dyZXNzUGVyY2VudGFnZX0lYDtcblx0XHQvLyBEaXNwbGF5IHRoZSBwZXJjZW50YWdlIGFsb25nIHdpdGggYSBjdXN0b20gc3RhdHVzIG1lc3NhZ2UuXG5cdFx0dGhpcy5maXhlZFByb2dyZXNzQmFyLnRleHQudGV4dENvbnRlbnQgPSBgJHtwcm9ncmVzc1BlcmNlbnRhZ2V9JSAtICR7cHJvZ3Jlc3MuY3VycmVudFN0ZXB9ICgke3Byb2dyZXNzLmN1cnJlbnRTdGVwTnVtYmVyfS8ke3Byb2dyZXNzLnRvdGFsU3RlcHN9KWA7XG5cdH1cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgdGhlIHN0YXR1cyBiYXIgY29udGFpbmVyLlxuXHQgKi9cblx0cHJpdmF0ZSBpbml0aWFsaXplU3RhdHVzQmFyKCk6IHZvaWQge1xuXHRcdC8vIENsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuXHRcdHRoaXMuc3RhdHVzQmFySXRlbS5pbm5lckhUTUwgPSAnJztcblx0XHQvLyBDcmVhdGUgYSBjb250YWluZXIgZWxlbWVudCAoaWYgbmVlZGVkKSB0byBob3N0IHRoZSBmaXhlZCBwcm9ncmVzcyBiYXIuXG5cdFx0Y29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0Y29udGFpbmVyLmFkZENsYXNzKCdmaXhlZC1wcm9ncmVzcy1jb250YWluZXInKTtcblx0XHR0aGlzLnN0YXR1c0Jhckl0ZW0uYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgZml4ZWQgcHJvZ3Jlc3MgYmFyIGVsZW1lbnQuXG5cdCAqL1xuXHRwcml2YXRlIGNyZWF0ZUZpeGVkUHJvZ3Jlc3NCYXIoKTogeyBjb250YWluZXI6IEhUTUxFbGVtZW50OyBmaWxsOiBIVE1MRWxlbWVudDsgdGV4dDogSFRNTEVsZW1lbnQgfSB7XG5cdFx0Y29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0Y29udGFpbmVyLmFkZENsYXNzKCdmaXhlZC1wcm9ncmVzcy1iYXItY29udGFpbmVyJyk7XG5cblx0XHRjb25zdCBiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRiYXIuYWRkQ2xhc3MoJ2ZpeGVkLXByb2dyZXNzLWJhcicpO1xuXG5cdFx0Y29uc3QgZmlsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdGZpbGwuYWRkQ2xhc3MoJ2ZpeGVkLXByb2dyZXNzLWZpbGwnKTtcblxuXHRcdGNvbnN0IHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHR0ZXh0LmFkZENsYXNzKCdmaXhlZC1wcm9ncmVzcy10ZXh0Jyk7XG5cblx0XHRiYXIuYXBwZW5kQ2hpbGQoZmlsbCk7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGJhcik7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRleHQpO1xuXHRcdHRoaXMuc3RhdHVzQmFySXRlbS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG5cdFx0cmV0dXJuIHsgY29udGFpbmVyLCBmaWxsLCB0ZXh0IH07XG5cdH1cblxuXHQvKipcblx0ICogUHJvY2Vzc2VzIHRoZSBub3RpZmljYXRpb24gcXVldWUgc2VxdWVudGlhbGx5LlxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBwcm9jZXNzTm90aWZpY2F0aW9uUXVldWUoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKHRoaXMuaXNQcm9jZXNzaW5nUXVldWUgfHwgdGhpcy5ub3RpZmljYXRpb25RdWV1ZS5sZW5ndGggPT09IDApIHJldHVybjtcblx0XHR0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlID0gdHJ1ZTtcblx0XHR0cnkge1xuXHRcdFx0d2hpbGUgKHRoaXMubm90aWZpY2F0aW9uUXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRjb25zdCBtZXNzYWdlID0gdGhpcy5ub3RpZmljYXRpb25RdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHRpZiAobWVzc2FnZSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UobWVzc2FnZSk7XG5cdFx0XHRcdFx0Ly8gV2FpdCBhIGJpdCBiZXR3ZWVuIG5vdGlmaWNhdGlvbnMgdG8gYXZvaWQgc3BhbW1pbmcuXG5cdFx0XHRcdFx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRoaXMuaXNQcm9jZXNzaW5nUXVldWUgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyBub3RpZmljYXRpb24gc2V0dGluZ3MuXG5cdCAqL1xuXHR1cGRhdGVTZXR0aW5ncyhlbmFibGVOb3RpZmljYXRpb25zOiBib29sZWFuLCBlbmFibGVQcm9ncmVzc0JhcjogYm9vbGVhbik6IHZvaWQge1xuXHRcdHRoaXMuZW5hYmxlTm90aWZpY2F0aW9ucyA9IGVuYWJsZU5vdGlmaWNhdGlvbnM7XG5cdFx0dGhpcy5lbmFibGVQcm9ncmVzc0JhciA9IGVuYWJsZVByb2dyZXNzQmFyO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFycyBhbGwgbm90aWZpY2F0aW9ucy5cblx0ICovXG5cdGNsZWFyKCk6IHZvaWQge1xuXHRcdHRoaXMubm90aWZpY2F0aW9uUXVldWUgPSBbXTtcblx0fVxufVxuIiwgIi8vU2V0dGluZ3NUYWIudHNcbmltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IE1pbmRNYXRyaXhQbHVnaW4gZnJvbSAnLi4vbWFpbic7XG5pbXBvcnQgeyBNaW5kTWF0cml4U2V0dGluZ3MsIGdlbmVyYXRlVmF1bHRJZCwgaXNWYXVsdEluaXRpYWxpemVkLCBnZXRVc2VyRXhjbHVzaW9ucywgU1lTVEVNX0VYQ0xVU0lPTlMgfSBmcm9tICcuL1NldHRpbmdzJztcblxuZXhwb3J0IGNsYXNzIE1pbmRNYXRyaXhTZXR0aW5nc1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuXHRwbHVnaW46IE1pbmRNYXRyaXhQbHVnaW47XG5cdHNldHRpbmdzOiBNaW5kTWF0cml4U2V0dGluZ3M7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogTWluZE1hdHJpeFBsdWdpbikge1xuXHRcdHN1cGVyKGFwcCwgcGx1Z2luKTtcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcblx0XHR0aGlzLnNldHRpbmdzID0gcGx1Z2luLnNldHRpbmdzO1xuXHR9XG5cblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHQvLyBEZWJ1Z2dpbmc6IExvZyBhbGwgZXhjbHVzaW9uIHNldHRpbmdzIHRvIGNvbnNvbGVcblx0XHRjb25zb2xlLmxvZyhcIkRFQlVHIC0gQWxsIEV4Y2x1c2lvbiBTZXR0aW5nczpcIiwge1xuXHRcdFx0dXNlclNldHRpbmdzOiB0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMsXG5cdFx0XHRzeXN0ZW1EZWZhdWx0czogU1lTVEVNX0VYQ0xVU0lPTlNcblx0XHR9KTtcblxuXHRcdC8vIFZhdWx0IElkZW50aWZpY2F0aW9uIFNlY3Rpb25cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdWYXVsdCBJZGVudGlmaWNhdGlvbicgfSk7XG5cblx0XHRpZiAoaXNWYXVsdEluaXRpYWxpemVkKHRoaXMuc2V0dGluZ3MpKSB7XG5cdFx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdFx0LnNldE5hbWUoJ1ZhdWx0IElEJylcblx0XHRcdFx0LnNldERlc2MoJ1VuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIHZhdWx0IGluIHRoZSBkYXRhYmFzZS4nKVxuXHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+XG5cdFx0XHRcdFx0dGV4dC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzLnZhdWx0SWQhKVxuXHRcdFx0XHRcdFx0LnNldERpc2FibGVkKHRydWUpXG5cdFx0XHRcdCk7XG5cblx0XHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0XHQuc2V0TmFtZSgnVmF1bHQgTmFtZScpXG5cdFx0XHRcdC5zZXREZXNjKCdUaGUgbmFtZSBvZiB5b3VyIGN1cnJlbnQgdmF1bHQuJylcblx0XHRcdFx0LmFkZFRleHQodGV4dCA9PlxuXHRcdFx0XHRcdHRleHQuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5sYXN0S25vd25WYXVsdE5hbWUpXG5cdFx0XHRcdFx0XHQuc2V0RGlzYWJsZWQodHJ1ZSlcblx0XHRcdFx0KTtcblxuXHRcdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXROYW1lKCdSZXNldCBWYXVsdCBJRCcpXG5cdFx0XHRcdC5zZXREZXNjKCdHZW5lcmF0ZSBhIG5ldyB2YXVsdCBJRCAocmVxdWlyZXMgZnVsbCByZXN5bmMpLicpXG5cdFx0XHRcdC5hZGRCdXR0b24oYnRuID0+XG5cdFx0XHRcdFx0YnRuLnNldEJ1dHRvblRleHQoJ1Jlc2V0Jylcblx0XHRcdFx0XHRcdC5zZXRXYXJuaW5nKClcblx0XHRcdFx0XHRcdC5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgY29uZmlybWVkID0gYXdhaXQgdGhpcy5zaG93UmVzZXRDb25maXJtYXRpb24oKTtcblx0XHRcdFx0XHRcdFx0aWYgKGNvbmZpcm1lZCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MudmF1bHRJZCA9IGdlbmVyYXRlVmF1bHRJZCgpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MubGFzdEtub3duVmF1bHROYW1lID0gdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpO1xuXHRcdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1ZhdWx0IElEIGhhcyBiZWVuIHJlc2V0LiBQbGVhc2UgcmVzeW5jIHlvdXIgdmF1bHQuJyk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5kaXNwbGF5KCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0XHQuc2V0TmFtZSgnSW5pdGlhbGl6ZSBWYXVsdCcpXG5cdFx0XHRcdC5zZXREZXNjKCdHZW5lcmF0ZSBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIHZhdWx0IHRvIGJlZ2luIHN5bmNpbmcuJylcblx0XHRcdFx0LmFkZEJ1dHRvbihidG4gPT5cblx0XHRcdFx0XHRidG4uc2V0QnV0dG9uVGV4dCgnSW5pdGlhbGl6ZScpXG5cdFx0XHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MudmF1bHRJZCA9IGdlbmVyYXRlVmF1bHRJZCgpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmxhc3RLbm93blZhdWx0TmFtZSA9IHRoaXMuYXBwLnZhdWx0LmdldE5hbWUoKTtcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1ZhdWx0IGhhcyBiZWVuIGluaXRpYWxpemVkLicpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmRpc3BsYXkoKTtcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwYWJhc2UgU2V0dGluZ3MgU2VjdGlvblxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1N1cGFiYXNlIENvbmZpZ3VyYXRpb24nIH0pO1xuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ1N1cGFiYXNlIFVSTCcpXG5cdFx0XHQuc2V0RGVzYygnVGhlIFVSTCBvZiB5b3VyIFN1cGFiYXNlIHByb2plY3QgKGUuZy4sIGh0dHBzOi8veW91ci1wcm9qZWN0LnN1cGFiYXNlLmNvKS4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PlxuXHRcdFx0XHR0ZXh0LnNldFBsYWNlaG9sZGVyKCdodHRwczovL3lvdXItcHJvamVjdC5zdXBhYmFzZS5jbycpXG5cdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc2V0dGluZ3Muc3VwYWJhc2UudXJsKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3VwYWJhc2UudXJsID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1N1cGFiYXNlIFVSTCB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHQpO1xuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ1N1cGFiYXNlIEFQSSBLZXknKVxuXHRcdFx0LnNldERlc2MoJ1lvdXIgU3VwYWJhc2UgQVBJIGtleSAoZm91bmQgaW4geW91ciBTdXBhYmFzZSBkYXNoYm9hcmQpLicpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+XG5cdFx0XHRcdHRleHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHlvdXIgQVBJIGtleScpXG5cdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc2V0dGluZ3Muc3VwYWJhc2UuYXBpS2V5KVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3VwYWJhc2UuYXBpS2V5ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1N1cGFiYXNlIEFQSSBrZXkgdXBkYXRlZC4nKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdC8vIE9wZW5BSSBTZXR0aW5ncyBTZWN0aW9uXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnT3BlbkFJIENvbmZpZ3VyYXRpb24nIH0pO1xuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ09wZW5BSSBBUEkgS2V5Jylcblx0XHRcdC5zZXREZXNjKCdZb3VyIE9wZW5BSSBBUEkga2V5IGZvciBnZW5lcmF0aW5nIGVtYmVkZGluZ3MuJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT5cblx0XHRcdFx0dGV4dC5zZXRQbGFjZWhvbGRlcignRW50ZXIgeW91ciBBUEkga2V5Jylcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5vcGVuYWkuYXBpS2V5KVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3Mub3BlbmFpLmFwaUtleSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdPcGVuQUkgQVBJIGtleSB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0Ly8gRG9jdW1lbnQgUHJvY2Vzc2luZyBTZXR0aW5ncyBTZWN0aW9uXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnRG9jdW1lbnQgUHJvY2Vzc2luZycgfSk7XG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnQ2h1bmsgU2l6ZScpXG5cdFx0XHQuc2V0RGVzYygnTWF4aW11bSBzaXplIG9mIHRleHQgY2h1bmtzIChpbiBjaGFyYWN0ZXJzKS4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PlxuXHRcdFx0XHR0ZXh0LnNldFZhbHVlKFN0cmluZyh0aGlzLnNldHRpbmdzLmNodW5raW5nLmNodW5rU2l6ZSkpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgbnVtVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHRcdFx0XHRcdFx0aWYgKCFpc05hTihudW1WYWx1ZSkgJiYgbnVtVmFsdWUgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuY2h1bmtpbmcuY2h1bmtTaXplID0gbnVtVmFsdWU7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdDaHVuayBzaXplIHVwZGF0ZWQuJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSlcblx0XHRcdCk7XG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnQ2h1bmsgT3ZlcmxhcCcpXG5cdFx0XHQuc2V0RGVzYygnT3ZlcmxhcCBiZXR3ZWVuIHRleHQgY2h1bmtzIChpbiBjaGFyYWN0ZXJzKS4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PlxuXHRcdFx0XHR0ZXh0LnNldFZhbHVlKFN0cmluZyh0aGlzLnNldHRpbmdzLmNodW5raW5nLmNodW5rT3ZlcmxhcCkpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgbnVtVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHRcdFx0XHRcdFx0aWYgKCFpc05hTihudW1WYWx1ZSkgJiYgbnVtVmFsdWUgPj0gMCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmNodW5raW5nLmNodW5rT3ZlcmxhcCA9IG51bVZhbHVlO1xuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnQ2h1bmsgb3ZlcmxhcCB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0Ly8gRXhjbHVzaW9uIFNldHRpbmdzIFNlY3Rpb24gLSBPbmx5IHNob3dpbmcgdXNlci1kZWZpbmVkIGV4Y2x1c2lvbnNcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdFeGNsdXNpb25zJyB9KTtcblxuXHRcdC8vIEdldCBvbmx5IHVzZXItZGVmaW5lZCBleGNsdXNpb25zIGZvciBVSSBkaXNwbGF5XG5cdFx0Y29uc3QgdXNlckV4Y2x1c2lvbnMgPSBnZXRVc2VyRXhjbHVzaW9ucyh0aGlzLnNldHRpbmdzKTtcblxuXHRcdC8vIERlYnVnOiBMb2cgdXNlciBleGNsdXNpb25zIGZyb20gdGhlIGZ1bmN0aW9uXG5cdFx0Y29uc29sZS5sb2coXCJERUJVRyAtIFVzZXIgRXhjbHVzaW9ucyBmcm9tIGdldFVzZXJFeGNsdXNpb25zKCk6XCIsIHVzZXJFeGNsdXNpb25zKTtcblxuXHRcdC8vIEZpbHRlciBvdXQgYW55IHN5c3RlbSBleGNsdXNpb25zIHRoYXQgbWlnaHQgaGF2ZSBiZWVuIGFjY2lkZW50YWxseSBzYXZlZCBpbiB1c2VyIGxpc3RzXG5cdFx0Y29uc3Qgc3lzdGVtRm9sZGVycyA9IG5ldyBTZXQoU1lTVEVNX0VYQ0xVU0lPTlMuZm9sZGVycyk7XG5cdFx0Y29uc3Qgc3lzdGVtRmlsZVR5cGVzID0gbmV3IFNldChTWVNURU1fRVhDTFVTSU9OUy5maWxlVHlwZXMpO1xuXHRcdGNvbnN0IHN5c3RlbUZpbGVQcmVmaXhlcyA9IG5ldyBTZXQoU1lTVEVNX0VYQ0xVU0lPTlMuZmlsZVByZWZpeGVzKTtcblx0XHRjb25zdCBzeXN0ZW1GaWxlcyA9IG5ldyBTZXQoU1lTVEVNX0VYQ0xVU0lPTlMuZmlsZXMpO1xuXG5cdFx0Ly8gRGVidWc6IExvZyB0aGUgc3lzdGVtIGV4Y2x1c2lvbiBzZXRzXG5cdFx0Y29uc29sZS5sb2coXCJERUJVRyAtIFN5c3RlbSBFeGNsdXNpb24gU2V0czpcIiwge1xuXHRcdFx0Zm9sZGVyczogQXJyYXkuZnJvbShzeXN0ZW1Gb2xkZXJzKSxcblx0XHRcdGZpbGVUeXBlczogQXJyYXkuZnJvbShzeXN0ZW1GaWxlVHlwZXMpLFxuXHRcdFx0ZmlsZVByZWZpeGVzOiBBcnJheS5mcm9tKHN5c3RlbUZpbGVQcmVmaXhlcyksXG5cdFx0XHRmaWxlczogQXJyYXkuZnJvbShzeXN0ZW1GaWxlcylcblx0XHR9KTtcblxuXHRcdC8vIEZpbHRlciBvdXQgc3lzdGVtIGl0ZW1zIGZyb20gdXNlciBleGNsdXNpb25zXG5cdFx0Y29uc3QgZmlsdGVyZWRVc2VyRm9sZGVycyA9IHVzZXJFeGNsdXNpb25zLmV4Y2x1ZGVkRm9sZGVycy5maWx0ZXIoZm9sZGVyID0+ICFzeXN0ZW1Gb2xkZXJzLmhhcyhmb2xkZXIpKTtcblx0XHRjb25zdCBmaWx0ZXJlZFVzZXJGaWxlVHlwZXMgPSB1c2VyRXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcy5maWx0ZXIodHlwZSA9PiAhc3lzdGVtRmlsZVR5cGVzLmhhcyh0eXBlKSk7XG5cdFx0Y29uc3QgZmlsdGVyZWRVc2VyRmlsZVByZWZpeGVzID0gdXNlckV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlUHJlZml4ZXMuZmlsdGVyKHByZWZpeCA9PiAhc3lzdGVtRmlsZVByZWZpeGVzLmhhcyhwcmVmaXgpKTtcblx0XHRjb25zdCBmaWx0ZXJlZFVzZXJGaWxlcyA9IHVzZXJFeGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMuZmlsdGVyKGZpbGUgPT4gIXN5c3RlbUZpbGVzLmhhcyhmaWxlKSk7XG5cblx0XHQvLyBEZWJ1ZzogTG9nIHRoZSBmaWx0ZXJlZCBleGNsdXNpb25zXG5cdFx0Y29uc29sZS5sb2coXCJERUJVRyAtIEZpbHRlcmVkIFVzZXIgRXhjbHVzaW9uczpcIiwge1xuXHRcdFx0Zm9sZGVyczogZmlsdGVyZWRVc2VyRm9sZGVycyxcblx0XHRcdGZpbGVUeXBlczogZmlsdGVyZWRVc2VyRmlsZVR5cGVzLFxuXHRcdFx0ZmlsZVByZWZpeGVzOiBmaWx0ZXJlZFVzZXJGaWxlUHJlZml4ZXMsXG5cdFx0XHRmaWxlczogZmlsdGVyZWRVc2VyRmlsZXNcblx0XHR9KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0V4Y2x1ZGVkIEZvbGRlcnMnKVxuXHRcdFx0LnNldERlc2MoJ0ZvbGRlcnMgdG8gZXhjbHVkZSBmcm9tIHN5bmNpbmcgKGNvbW1hLXNlcGFyYXRlZCkuJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGZpbHRlcmVkVXNlckZvbGRlcnMuam9pbignLCAnKTtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJERUJVRyAtIFNldHRpbmcgZXhjbHVkZWQgZm9sZGVycyBmaWVsZCB2YWx1ZTpcIiwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gdGV4dC5zZXRQbGFjZWhvbGRlcignZm9sZGVyMSwgZm9sZGVyMicpXG5cdFx0XHRcdFx0LnNldFZhbHVlKHZhbHVlKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiREVCVUcgLSBGb2xkZXJzIG9uQ2hhbmdlIGV2ZW50IHZhbHVlOlwiLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHQvLyBTYXZlIG9ubHkgdXNlci1kZWZpbmVkIGZvbGRlcnMsIGVuc3VyaW5nIHdlIGRvbid0IGR1cGxpY2F0ZSBzeXN0ZW0gZm9sZGVyc1xuXHRcdFx0XHRcdFx0Y29uc3QgdXNlckZvbGRlcnMgPSB2YWx1ZS5zcGxpdCgnLCcpLm1hcChzID0+IHMudHJpbSgpKS5maWx0ZXIocyA9PiBzKTtcblx0XHRcdFx0XHRcdGNvbnN0IGZpbmFsRm9sZGVycyA9IHVzZXJGb2xkZXJzLmZpbHRlcihmb2xkZXIgPT4gIXN5c3RlbUZvbGRlcnMuaGFzKGZvbGRlcikpO1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJERUJVRyAtIEZpbmFsIGZvbGRlcnMgdG8gc2F2ZTpcIiwgZmluYWxGb2xkZXJzKTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZvbGRlcnMgPSBmaW5hbEZvbGRlcnM7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0V4Y2x1ZGVkIGZvbGRlcnMgdXBkYXRlZC4nKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnRXhjbHVkZWQgRmlsZSBUeXBlcycpXG5cdFx0XHQuc2V0RGVzYygnRmlsZSBleHRlbnNpb25zIHRvIGV4Y2x1ZGUgKGNvbW1hLXNlcGFyYXRlZCwgaW5jbHVkZSB0aGUgZG90KS4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gZmlsdGVyZWRVc2VyRmlsZVR5cGVzLmpvaW4oJywgJyk7XG5cblx0XHRcdFx0cmV0dXJuIHRleHQuc2V0UGxhY2Vob2xkZXIoJy50eXBlMSwgLnR5cGUyJylcblx0XHRcdFx0XHQuc2V0VmFsdWUodmFsdWUpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgdXNlckZpbGVUeXBlcyA9IHZhbHVlLnNwbGl0KCcsJykubWFwKHMgPT4gcy50cmltKCkpLmZpbHRlcihzID0+IHMpO1xuXHRcdFx0XHRcdFx0Y29uc3QgZmluYWxGaWxlVHlwZXMgPSB1c2VyRmlsZVR5cGVzLmZpbHRlcih0eXBlID0+ICFzeXN0ZW1GaWxlVHlwZXMuaGFzKHR5cGUpKTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcyA9IGZpbmFsRmlsZVR5cGVzO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdFeGNsdWRlZCBmaWxlIHR5cGVzIHVwZGF0ZWQuJyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0V4Y2x1ZGVkIEZpbGUgUHJlZml4ZXMnKVxuXHRcdFx0LnNldERlc2MoJ0ZpbGUgbmFtZSBwcmVmaXhlcyB0byBleGNsdWRlIChjb21tYS1zZXBhcmF0ZWQpLicpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBmaWx0ZXJlZFVzZXJGaWxlUHJlZml4ZXMuam9pbignLCAnKTtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJERUJVRyAtIFNldHRpbmcgZXhjbHVkZWQgZmlsZSBwcmVmaXhlcyBmaWVsZCB2YWx1ZTpcIiwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gdGV4dC5zZXRQbGFjZWhvbGRlcigndGVtcCwgZHJhZnQnKVxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh2YWx1ZSlcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkRFQlVHIC0gRmlsZSBwcmVmaXhlcyBvbkNoYW5nZSBldmVudCB2YWx1ZTpcIiwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0Ly8gU2F2ZSBvbmx5IHVzZXItZGVmaW5lZCBwcmVmaXhlcywgZW5zdXJpbmcgd2UgZG9uJ3QgZHVwbGljYXRlIHN5c3RlbSBwcmVmaXhlc1xuXHRcdFx0XHRcdFx0Y29uc3QgdXNlckZpbGVQcmVmaXhlcyA9IHZhbHVlLnNwbGl0KCcsJykubWFwKHMgPT4gcy50cmltKCkpLmZpbHRlcihzID0+IHMpO1xuXHRcdFx0XHRcdFx0Y29uc3QgZmluYWxGaWxlUHJlZml4ZXMgPSB1c2VyRmlsZVByZWZpeGVzLmZpbHRlcihwcmVmaXggPT4gIXN5c3RlbUZpbGVQcmVmaXhlcy5oYXMocHJlZml4KSk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkRFQlVHIC0gRmluYWwgZmlsZSBwcmVmaXhlcyB0byBzYXZlOlwiLCBmaW5hbEZpbGVQcmVmaXhlcyk7XG5cdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlUHJlZml4ZXMgPSBmaW5hbEZpbGVQcmVmaXhlcztcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnRXhjbHVkZWQgZmlsZSBwcmVmaXhlcyB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdFeGNsdWRlZCBGaWxlcycpXG5cdFx0XHQuc2V0RGVzYygnU3BlY2lmaWMgZmlsZXMgdG8gZXhjbHVkZSBmcm9tIHN5bmNpbmcgKGNvbW1hLXNlcGFyYXRlZCkuJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGZpbHRlcmVkVXNlckZpbGVzLmpvaW4oJywgJyk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiREVCVUcgLSBTZXR0aW5nIGV4Y2x1ZGVkIGZpbGVzIGZpZWxkIHZhbHVlOlwiLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiB0ZXh0LnNldFBsYWNlaG9sZGVyKCdmaWxlMS5tZCwgZmlsZTIubWQnKVxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh2YWx1ZSlcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkRFQlVHIC0gRmlsZXMgb25DaGFuZ2UgZXZlbnQgdmFsdWU6XCIsIHZhbHVlKTtcblx0XHRcdFx0XHRcdC8vIFNhdmUgb25seSB1c2VyLWRlZmluZWQgZmlsZXMsIGVuc3VyaW5nIHdlIGRvbid0IGR1cGxpY2F0ZSBzeXN0ZW0gZmlsZXNcblx0XHRcdFx0XHRcdGNvbnN0IHVzZXJGaWxlcyA9IHZhbHVlLnNwbGl0KCcsJykubWFwKHMgPT4gcy50cmltKCkpLmZpbHRlcihzID0+IHMpO1xuXHRcdFx0XHRcdFx0Y29uc3QgZmluYWxGaWxlcyA9IHVzZXJGaWxlcy5maWx0ZXIoZmlsZSA9PiAhc3lzdGVtRmlsZXMuaGFzKGZpbGUpKTtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiREVCVUcgLSBGaW5hbCBmaWxlcyB0byBzYXZlOlwiLCBmaW5hbEZpbGVzKTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVzID0gZmluYWxGaWxlcztcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnRXhjbHVkZWQgZmlsZXMgdXBkYXRlZC4nKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0Ly8gSW1wcm92ZWQgaW5mbyB0ZXh0IGFib3V0IHN5c3RlbSBkZWZhdWx0c1xuXHRcdGNvbnN0IGluZm9EaXYgPSBjb250YWluZXJFbC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdzZXR0aW5nLWl0ZW0tZGVzY3JpcHRpb24nIH0pO1xuXHRcdGluZm9EaXYuaW5uZXJIVE1MID0gYFxuXHRcdFx0PHA+PHN0cm9uZz5Ob3RlOjwvc3Ryb25nPiBUaGUgZm9sbG93aW5nIGl0ZW1zIGFyZSBhdXRvbWF0aWNhbGx5IGV4Y2x1ZGVkIGJ5IHRoZSBzeXN0ZW06PC9wPlxuXHRcdFx0PHA+PHN0cm9uZz5Gb2xkZXJzOjwvc3Ryb25nPiAke1NZU1RFTV9FWENMVVNJT05TLmZvbGRlcnMuam9pbignLCAnKX08L3A+XG5cdFx0XHQ8cD48c3Ryb25nPkZpbGUgVHlwZXM6PC9zdHJvbmc+ICR7U1lTVEVNX0VYQ0xVU0lPTlMuZmlsZVR5cGVzLmpvaW4oJywgJyl9PC9wPlxuXHRcdFx0PHA+PHN0cm9uZz5GaWxlIFByZWZpeGVzOjwvc3Ryb25nPiAke1NZU1RFTV9FWENMVVNJT05TLmZpbGVQcmVmaXhlcy5qb2luKCcsICcpfTwvcD5cblx0XHRcdDxwPjxzdHJvbmc+RmlsZXM6PC9zdHJvbmc+ICR7U1lTVEVNX0VYQ0xVU0lPTlMuZmlsZXMuam9pbignLCAnKX08L3A+XG5cdFx0YDtcblxuXHRcdC8vIFF1ZXVlICYgU3luYyBTZXR0aW5ncyBTZWN0aW9uXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnUXVldWUgJiBTeW5jIFNldHRpbmdzJyB9KTtcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdBdXRvIFN5bmMnKVxuXHRcdFx0LnNldERlc2MoJ0F1dG9tYXRpY2FsbHkgc3luYyBjaGFuZ2VzIHRvIHRoZSBkYXRhYmFzZSB3aGVuIGZpbGVzIGFyZSBtb2RpZmllZC4nKVxuXHRcdFx0LmFkZFRvZ2dsZSh0b2dnbGUgPT5cblx0XHRcdFx0dG9nZ2xlLnNldFZhbHVlKHRoaXMuc2V0dGluZ3MuZW5hYmxlQXV0b1N5bmMpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5lbmFibGVBdXRvU3luYyA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdBdXRvIHN5bmMgdXBkYXRlZC4nKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0KTtcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdTeW5jIEZpbGUgUGF0aCcpXG5cdFx0XHQuc2V0RGVzYygnVGhlIHBhdGggZm9yIHRoZSBkZWRpY2F0ZWQgc3luYyBmaWxlLicpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+XG5cdFx0XHRcdHRleHQuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5zeW5jLnN5bmNGaWxlUGF0aClcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLnN5bmMuc3luY0ZpbGVQYXRoID0gdmFsdWU7XG5cdFx0XHRcdFx0XHQvLyBBbHNvIHVwZGF0ZSB0aGUgc3lzdGVtIGV4Y2x1ZGVkIGZpbGVzXG5cdFx0XHRcdFx0XHRjb25zdCBzeXN0ZW1GaWxlcyA9IHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5zeXN0ZW1FeGNsdWRlZEZpbGVzO1xuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIG9sZCBzeW5jIGZpbGUgcmVmZXJlbmNlc1xuXHRcdFx0XHRcdFx0Y29uc3Qgb2xkU3luY0ZpbGVJbmRleCA9IHN5c3RlbUZpbGVzLmZpbmRJbmRleChmID0+IGYgPT09ICdfbWluZG1hdHJpeHN5bmMubWQnKTtcblx0XHRcdFx0XHRcdGNvbnN0IG9sZFN5bmNCYWNrdXBJbmRleCA9IHN5c3RlbUZpbGVzLmZpbmRJbmRleChmID0+IGYgPT09ICdfbWluZG1hdHJpeHN5bmMubWQuYmFja3VwJyk7XG5cdFx0XHRcdFx0XHRpZiAob2xkU3luY0ZpbGVJbmRleCAhPT0gLTEpIHN5c3RlbUZpbGVzLnNwbGljZShvbGRTeW5jRmlsZUluZGV4LCAxKTtcblx0XHRcdFx0XHRcdGlmIChvbGRTeW5jQmFja3VwSW5kZXggIT09IC0xKSBzeXN0ZW1GaWxlcy5zcGxpY2Uob2xkU3luY0JhY2t1cEluZGV4LCAxKTtcblx0XHRcdFx0XHRcdC8vIEFkZCBuZXcgc3luYyBmaWxlIHJlZmVyZW5jZXNcblx0XHRcdFx0XHRcdHN5c3RlbUZpbGVzLnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdFx0c3lzdGVtRmlsZXMucHVzaCh2YWx1ZSArICcuYmFja3VwJyk7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1N5bmMgZmlsZSBwYXRoIHVwZGF0ZWQuJyk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHQvLyBEZWJ1ZyBTZXR0aW5ncyBTZWN0aW9uXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnRGVidWcgU2V0dGluZ3MnIH0pO1xuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0VuYWJsZSBEZWJ1ZyBMb2dzJylcblx0XHRcdC5zZXREZXNjKCdFbmFibGUgZGV0YWlsZWQgZGVidWcgbG9ncyBpbiB0aGUgY29uc29sZS4nKVxuXHRcdFx0LmFkZFRvZ2dsZSh0b2dnbGUgPT5cblx0XHRcdFx0dG9nZ2xlLnNldFZhbHVlKHRoaXMuc2V0dGluZ3MuZGVidWcuZW5hYmxlRGVidWdMb2dzKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuZGVidWcuZW5hYmxlRGVidWdMb2dzID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0RlYnVnIGxvZ3Mgc2V0dGluZyB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHQpO1xuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0xvZyBMZXZlbCcpXG5cdFx0XHQuc2V0RGVzYygnU2VsZWN0IHRoZSBsZXZlbCBvZiBkZXRhaWwgZm9yIGRlYnVnIGxvZ2dpbmcuJylcblx0XHRcdC5hZGREcm9wZG93bihkcm9wZG93biA9PlxuXHRcdFx0XHRkcm9wZG93bi5hZGRPcHRpb24oJ2Vycm9yJywgJ0Vycm9yJylcblx0XHRcdFx0XHQuYWRkT3B0aW9uKCd3YXJuJywgJ1dhcm5pbmcnKVxuXHRcdFx0XHRcdC5hZGRPcHRpb24oJ2luZm8nLCAnSW5mbycpXG5cdFx0XHRcdFx0LmFkZE9wdGlvbignZGVidWcnLCAnRGVidWcnKVxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzLmRlYnVnLmxvZ0xldmVsKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuZGVidWcubG9nTGV2ZWwgPSB2YWx1ZSBhcyAnZXJyb3InIHwgJ3dhcm4nIHwgJ2luZm8nIHwgJ2RlYnVnJztcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnTG9nIGxldmVsIHVwZGF0ZWQuJyk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdCk7XG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnTG9nIHRvIEZpbGUnKVxuXHRcdFx0LnNldERlc2MoJ1NhdmUgZGVidWcgbG9ncyB0byBhIGZpbGUgaW4geW91ciB2YXVsdC4nKVxuXHRcdFx0LmFkZFRvZ2dsZSh0b2dnbGUgPT5cblx0XHRcdFx0dG9nZ2xlLnNldFZhbHVlKHRoaXMuc2V0dGluZ3MuZGVidWcubG9nVG9GaWxlKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuZGVidWcubG9nVG9GaWxlID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0xvZyB0byBmaWxlIHNldHRpbmcgdXBkYXRlZC4nKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0KTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgc2hvd1Jlc2V0Q29uZmlybWF0aW9uKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuXHRcdFx0Y29uc3QgbW9kYWwgPSB0aGlzLmFwcC5tb2RhbDtcblx0XHRcdG1vZGFsLm9wZW4oKG1vZGFsKSA9PiB7XG5cdFx0XHRcdG1vZGFsLnRpdGxlRWwuc2V0VGV4dCgnUmVzZXQgVmF1bHQgSUQnKTtcblx0XHRcdFx0bW9kYWwuY29udGVudEVsLnNldFRleHQoXG5cdFx0XHRcdFx0J1dhcm5pbmc6IFJlc2V0dGluZyB0aGUgdmF1bHQgSUQgd2lsbCBkaXNjb25uZWN0IHRoaXMgdmF1bHQgZnJvbSBpdHMgZXhpc3RpbmcgZGF0YWJhc2UgZW50cmllcy4gVGhpcyBvcGVyYXRpb24gY2Fubm90IGJlIHVuZG9uZS4gQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGNvbnRpbnVlPydcblx0XHRcdFx0KTtcblx0XHRcdFx0bW9kYWwuYWRkQnV0dG9uKChidG4pID0+IHtcblx0XHRcdFx0XHRidG4uc2V0QnV0dG9uVGV4dCgnQ2FuY2VsJykub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKGZhbHNlKTtcblx0XHRcdFx0XHRcdG1vZGFsLmNsb3NlKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRtb2RhbC5hZGRCdXR0b24oKGJ0bikgPT4ge1xuXHRcdFx0XHRcdGJ0bi5zZXRCdXR0b25UZXh0KCdSZXNldCcpLnNldFdhcm5pbmcoKS5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHRcdHJlc29sdmUodHJ1ZSk7XG5cdFx0XHRcdFx0XHRtb2RhbC5jbG9zZSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG59XG4iLCAiLy8gc3JjL3NlcnZpY2VzL0luaXRpYWxTeW5jTWFuYWdlci50c1xuaW1wb3J0IHsgVEZpbGUsIFZhdWx0LCBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBFcnJvckhhbmRsZXIgfSBmcm9tICcuLi91dGlscy9FcnJvckhhbmRsZXInO1xuaW1wb3J0IHsgTm90aWZpY2F0aW9uTWFuYWdlciB9IGZyb20gJy4uL3V0aWxzL05vdGlmaWNhdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgUXVldWVTZXJ2aWNlIH0gZnJvbSAnLi9RdWV1ZVNlcnZpY2UnO1xuaW1wb3J0IHsgU3luY0ZpbGVNYW5hZ2VyIH0gZnJvbSAnLi9TeW5jRmlsZU1hbmFnZXInO1xuaW1wb3J0IHsgTWV0YWRhdGFFeHRyYWN0b3IgfSBmcm9tICcuL01ldGFkYXRhRXh0cmFjdG9yJztcbmltcG9ydCB7IFN1cGFiYXNlU2VydmljZSB9IGZyb20gJy4vU3VwYWJhc2VTZXJ2aWNlJztcblxuaW50ZXJmYWNlIEluaXRpYWxTeW5jT3B0aW9ucyB7XG5cdGJhdGNoU2l6ZTogbnVtYmVyO1xuXHRtYXhDb25jdXJyZW50QmF0Y2hlczogbnVtYmVyO1xuXHRlbmFibGVBdXRvSW5pdGlhbFN5bmM6IGJvb2xlYW47XG5cdHByaW9yaXR5UnVsZXM6IFByaW9yaXR5UnVsZVtdO1xuXHRzeW5jRmlsZVBhdGg/OiBzdHJpbmc7XG5cdGV4Y2x1c2lvbnM/OiB7XG5cdFx0ZXhjbHVkZWRGb2xkZXJzOiBzdHJpbmdbXTtcblx0XHRleGNsdWRlZEZpbGVUeXBlczogc3RyaW5nW107XG5cdFx0ZXhjbHVkZWRGaWxlUHJlZml4ZXM6IHN0cmluZ1tdO1xuXHRcdGV4Y2x1ZGVkRmlsZXM6IHN0cmluZ1tdO1xuXHR9O1xufVxuXG5pbnRlcmZhY2UgUHJpb3JpdHlSdWxlIHtcblx0cGF0dGVybjogc3RyaW5nO1xuXHRwcmlvcml0eTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgU3luY0JhdGNoIHtcblx0aWQ6IHN0cmluZztcblx0ZmlsZXM6IFRGaWxlW107XG5cdHN0YXR1czogJ3BlbmRpbmcnIHwgJ3Byb2Nlc3NpbmcnIHwgJ2NvbXBsZXRlZCcgfCAnZmFpbGVkJztcblx0cHJvZ3Jlc3M6IG51bWJlcjtcblx0c3RhcnRUaW1lPzogbnVtYmVyO1xuXHRlbmRUaW1lPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNQcm9ncmVzcyB7XG5cdHRvdGFsRmlsZXM6IG51bWJlcjtcblx0cHJvY2Vzc2VkRmlsZXM6IG51bWJlcjtcblx0Y3VycmVudEJhdGNoOiBudW1iZXI7XG5cdHRvdGFsQmF0Y2hlczogbnVtYmVyO1xuXHRzdGFydFRpbWU6IG51bWJlcjtcblx0ZXN0aW1hdGVkVGltZVJlbWFpbmluZz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEluaXRpYWxTeW5jTWFuYWdlciB7XG5cdHByaXZhdGUgYmF0Y2hlczogU3luY0JhdGNoW10gPSBbXTtcblx0cHJpdmF0ZSBwcm9ncmVzczogU3luY1Byb2dyZXNzO1xuXHRwcml2YXRlIGlzUnVubmluZzogYm9vbGVhbiA9IGZhbHNlO1xuXHRwcml2YXRlIGxhc3RQcm9jZXNzZWRJbmRleDogbnVtYmVyID0gMDsgLy8gRm9yIHJlc3VtaW5nIGludGVycnVwdGVkIHN5bmNzXG5cdHByaXZhdGUgcHJvY2Vzc2luZ1RpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogSW5pdGlhbFN5bmNPcHRpb25zO1xuXHRwcml2YXRlIHN1cGFiYXNlU2VydmljZTogU3VwYWJhc2VTZXJ2aWNlIHwgbnVsbDtcblx0cHJpdmF0ZSByZXN1bWVGaWxlTGlzdDogVEZpbGVbXSA9IFtdO1xuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByaXZhdGUgdmF1bHQ6IFZhdWx0LFxuXHRcdHByaXZhdGUgcXVldWVTZXJ2aWNlOiBRdWV1ZVNlcnZpY2UsXG5cdFx0cHJpdmF0ZSBzeW5jTWFuYWdlcjogU3luY0ZpbGVNYW5hZ2VyLFxuXHRcdHByaXZhdGUgbWV0YWRhdGFFeHRyYWN0b3I6IE1ldGFkYXRhRXh0cmFjdG9yLFxuXHRcdHByaXZhdGUgZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXIsXG5cdFx0cHJpdmF0ZSBub3RpZmljYXRpb25NYW5hZ2VyOiBOb3RpZmljYXRpb25NYW5hZ2VyLFxuXHRcdHN1cGFiYXNlU2VydmljZTogU3VwYWJhc2VTZXJ2aWNlIHwgbnVsbCxcblx0XHRvcHRpb25zOiBQYXJ0aWFsPEluaXRpYWxTeW5jT3B0aW9ucz4gPSB7fVxuXHQpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSB7XG5cdFx0XHRiYXRjaFNpemU6IDUwLFxuXHRcdFx0bWF4Q29uY3VycmVudEJhdGNoZXM6IDMsXG5cdFx0XHRlbmFibGVBdXRvSW5pdGlhbFN5bmM6IHRydWUsXG5cdFx0XHRwcmlvcml0eVJ1bGVzOiBbXSxcblx0XHRcdHN5bmNGaWxlUGF0aDogJ19taW5kbWF0cml4c3luYy5tZCcsXG5cdFx0XHRleGNsdXNpb25zOiB7XG5cdFx0XHRcdGV4Y2x1ZGVkRm9sZGVyczogW10sXG5cdFx0XHRcdGV4Y2x1ZGVkRmlsZVR5cGVzOiBbXSxcblx0XHRcdFx0ZXhjbHVkZWRGaWxlUHJlZml4ZXM6IFtdLFxuXHRcdFx0XHRleGNsdWRlZEZpbGVzOiBbXVxuXHRcdFx0fSxcblx0XHRcdC4uLm9wdGlvbnNcblx0XHR9O1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSB7XG5cdFx0XHR0b3RhbEZpbGVzOiAwLFxuXHRcdFx0cHJvY2Vzc2VkRmlsZXM6IDAsXG5cdFx0XHRjdXJyZW50QmF0Y2g6IDAsXG5cdFx0XHR0b3RhbEJhdGNoZXM6IDAsXG5cdFx0XHRzdGFydFRpbWU6IDBcblx0XHR9O1xuXHRcdHRoaXMuc3VwYWJhc2VTZXJ2aWNlID0gc3VwYWJhc2VTZXJ2aWNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZpbHRlcnMgZmlsZXMgYmFzZWQgb24gZXhjbHVzaW9uIHJ1bGVzLlxuXHQgKi9cblx0cHJpdmF0ZSBmaWx0ZXJFeGNsdWRlZEZpbGVzKGZpbGVzOiBURmlsZVtdKTogVEZpbGVbXSB7XG5cdFx0Y29uc3Qgc3luY0ZpbGVQYXRoID0gdGhpcy5vcHRpb25zLnN5bmNGaWxlUGF0aCB8fCAnX21pbmRtYXRyaXhzeW5jLm1kJztcblx0XHRjb25zdCBleGNsdXNpb25zID0gdGhpcy5vcHRpb25zLmV4Y2x1c2lvbnMgfHwge1xuXHRcdFx0ZXhjbHVkZWRGb2xkZXJzOiBbXSxcblx0XHRcdGV4Y2x1ZGVkRmlsZVR5cGVzOiBbXSxcblx0XHRcdGV4Y2x1ZGVkRmlsZVByZWZpeGVzOiBbXSxcblx0XHRcdGV4Y2x1ZGVkRmlsZXM6IFtdXG5cdFx0fTtcblxuXHRcdHJldHVybiBmaWxlcy5maWx0ZXIoZmlsZSA9PiB7XG5cdFx0XHRjb25zdCBmaWxlUGF0aCA9IGZpbGUucGF0aDtcblx0XHRcdGNvbnN0IGZpbGVOYW1lID0gZmlsZS5uYW1lO1xuXHRcdFx0Ly8gRXhjbHVkZSBzeW5jIGZpbGVzIGV4cGxpY2l0bHlcblx0XHRcdGlmIChcblx0XHRcdFx0ZmlsZVBhdGggPT09IHN5bmNGaWxlUGF0aCB8fFxuXHRcdFx0XHRmaWxlUGF0aCA9PT0gJ19taW5kbWF0cml4c3luYy5tZCcgfHxcblx0XHRcdFx0ZmlsZVBhdGggPT09ICdfbWluZG1hdHJpeHN5bmMubWQuYmFja3VwJ1xuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmIChleGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMuaW5jbHVkZXMoZmlsZU5hbWUpKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRpZiAoZXhjbHVzaW9ucy5leGNsdWRlZEZvbGRlcnMuc29tZShmb2xkZXIgPT4gZmlsZVBhdGguc3RhcnRzV2l0aChmb2xkZXIuZW5kc1dpdGgoJy8nKSA/IGZvbGRlciA6IGZvbGRlciArICcvJykpKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRpZiAoZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcy5zb21lKGV4dCA9PiBmaWxlUGF0aC50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dC50b0xvd2VyQ2FzZSgpKSkpIHJldHVybiBmYWxzZTtcblx0XHRcdGlmIChleGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVByZWZpeGVzLnNvbWUocHJlZml4ID0+IGZpbGVOYW1lLnN0YXJ0c1dpdGgocHJlZml4KSkpIHJldHVybiBmYWxzZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyB0aGUgaW5pdGlhbCBzeW5jIHByb2Nlc3MuXG5cdCAqIFNjYW5zIGFsbCBtYXJrZG93biBmaWxlcyBpbiB0aGUgdmF1bHQgYW5kIHVwZGF0ZXMgdGhlaXIgc3RhdHVzIGluIHRoZSBkYXRhYmFzZS5cblx0ICogUmVzdW1lcyBmcm9tIHRoZSBsYXN0IHByb2Nlc3NlZCBmaWxlIGlmIHRoZSBzeW5jIGlzIGludGVycnVwdGVkLlxuXHQgKi9cblx0YXN5bmMgc3RhcnRTeW5jKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICh0aGlzLmlzUnVubmluZykge1xuXHRcdFx0Y29uc29sZS5sb2coJ0luaXRpYWwgc3luYyBhbHJlYWR5IHJ1bm5pbmcnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcblx0XHRcdHRoaXMucHJvZ3Jlc3Muc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdGNvbnNvbGUubG9nKCdTdGFydGluZyBpbml0aWFsIHN5bmMuLi4nKTtcblxuXHRcdFx0Ly8gR2V0IGFuZCBmaWx0ZXIgYWxsIG1hcmtkb3duIGZpbGVzXG5cdFx0XHRjb25zdCBhbGxGaWxlcyA9IHRoaXMudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuXHRcdFx0Y29uc3QgZmlsZXMgPSB0aGlzLmZpbHRlckV4Y2x1ZGVkRmlsZXMoYWxsRmlsZXMpO1xuXHRcdFx0dGhpcy5yZXN1bWVGaWxlTGlzdCA9IGF3YWl0IHRoaXMuc29ydEZpbGVzQnlQcmlvcml0eShmaWxlcyk7XG5cdFx0XHR0aGlzLnByb2dyZXNzLnRvdGFsRmlsZXMgPSB0aGlzLnJlc3VtZUZpbGVMaXN0Lmxlbmd0aDtcblx0XHRcdGNvbnNvbGUubG9nKGBUb3RhbCBmaWxlcyB0byBzeW5jOiAke3RoaXMucHJvZ3Jlc3MudG90YWxGaWxlc31gKTtcblxuXHRcdFx0Ly8gQ3JlYXRlIGJhdGNoZXMgZnJvbSB0aGUgZmlsZXMgc3RhcnRpbmcgZnJvbSBsYXN0UHJvY2Vzc2VkSW5kZXhcblx0XHRcdHRoaXMuYmF0Y2hlcyA9IHRoaXMuY3JlYXRlQmF0Y2hlcyh0aGlzLnJlc3VtZUZpbGVMaXN0LnNsaWNlKHRoaXMubGFzdFByb2Nlc3NlZEluZGV4KSk7XG5cdFx0XHR0aGlzLnByb2dyZXNzLnRvdGFsQmF0Y2hlcyA9IHRoaXMuYmF0Y2hlcy5sZW5ndGg7XG5cdFx0XHRjb25zb2xlLmxvZyhgQ3JlYXRlZCAke3RoaXMucHJvZ3Jlc3MudG90YWxCYXRjaGVzfSBiYXRjaGVzIGZvciBzeW5jaW5nYCk7XG5cblx0XHRcdC8vIFByb2Nlc3MgZWFjaCBiYXRjaCBjb25jdXJyZW50bHkgd2l0aCBhIGxpbWl0XG5cdFx0XHRhd2FpdCB0aGlzLnByb2Nlc3NCYXRjaGVzKCk7XG5cblx0XHRcdG5ldyBOb3RpY2UoJ0luaXRpYWwgc3luYyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG5cdFx0XHRjb25zb2xlLmxvZygnSW5pdGlhbCBzeW5jIGNvbXBsZXRlZCcpO1xuXHRcdFx0Ly8gUmVzZXQgcmVzdW1lIGluZGV4IG9uIHN1Y2Nlc3Ncblx0XHRcdHRoaXMubGFzdFByb2Nlc3NlZEluZGV4ID0gMDtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ0luaXRpYWxTeW5jTWFuYWdlci5zdGFydFN5bmMnIH0pO1xuXHRcdFx0bmV3IE5vdGljZSgnSW5pdGlhbCBzeW5jIGZhaWxlZC4gQ2hlY2sgY29uc29sZSBmb3IgZGV0YWlscy4nKTtcblx0XHRcdC8vIFJlc3VtZSBmcm9tIHRoZSBsYXN0IHByb2Nlc3NlZCBpbmRleCBvbiBmYWlsdXJlXG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNvcnQgZmlsZXMgYnkgcHJpb3JpdHkgYmFzZWQgb24gcnVsZXMuXG5cdCAqIEZpbGVzIG1hdGNoaW5nIGhpZ2hlciBwcmlvcml0eSBydWxlcyBhcmUgc29ydGVkIHRvIHRoZSBmcm9udC5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgc29ydEZpbGVzQnlQcmlvcml0eShmaWxlczogVEZpbGVbXSk6IFByb21pc2U8VEZpbGVbXT4ge1xuXHRcdHJldHVybiBmaWxlcy5zb3J0KChhLCBiKSA9PiB7XG5cdFx0XHRjb25zdCBwcmlvcml0eUEgPSB0aGlzLmdldEZpbGVQcmlvcml0eShhLnBhdGgpO1xuXHRcdFx0Y29uc3QgcHJpb3JpdHlCID0gdGhpcy5nZXRGaWxlUHJpb3JpdHkoYi5wYXRoKTtcblx0XHRcdGNvbnNvbGUubG9nKGBQcmlvcml0eSBmb3IgJHthLnBhdGh9OiAke3ByaW9yaXR5QX0sICR7Yi5wYXRofTogJHtwcmlvcml0eUJ9YCk7XG5cdFx0XHRyZXR1cm4gcHJpb3JpdHlCIC0gcHJpb3JpdHlBO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgcHJvY2Vzc2luZyBwcmlvcml0eSBmb3IgYSBmaWxlLlxuXHQgKiBSZXR1cm5zIHRoZSBoaWdoZXN0IG1hdGNoaW5nIHJ1bGUgcHJpb3JpdHkgb3IgZGVmYXVsdHMgdG8gMS5cblx0ICovXG5cdHByaXZhdGUgZ2V0RmlsZVByaW9yaXR5KHBhdGg6IHN0cmluZyk6IG51bWJlciB7XG5cdFx0Zm9yIChjb25zdCBydWxlIG9mIHRoaXMub3B0aW9ucy5wcmlvcml0eVJ1bGVzKSB7XG5cdFx0XHRpZiAocGF0aC5pbmNsdWRlcyhydWxlLnBhdHRlcm4pKSB7XG5cdFx0XHRcdHJldHVybiBydWxlLnByaW9yaXR5O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYmF0Y2hlcyBvZiBmaWxlcyBmb3IgcHJvY2Vzc2luZy5cblx0ICovXG5cdHByaXZhdGUgY3JlYXRlQmF0Y2hlcyhmaWxlczogVEZpbGVbXSk6IFN5bmNCYXRjaFtdIHtcblx0XHRjb25zdCBzeW5jRmlsZVBhdGggPSB0aGlzLm9wdGlvbnMuc3luY0ZpbGVQYXRoIHx8ICdfbWluZG1hdHJpeHN5bmMubWQnO1xuXHRcdC8vIEVuc3VyZSBzeW5jIGZpbGUgaXMgbm90IGluY2x1ZGVkXG5cdFx0ZmlsZXMgPSBmaWxlcy5maWx0ZXIoZmlsZSA9PiBmaWxlLnBhdGggIT09IHN5bmNGaWxlUGF0aCAmJiBmaWxlLnBhdGggIT09ICdfbWluZG1hdHJpeHN5bmMubWQnICYmIGZpbGUucGF0aCAhPT0gJ19taW5kbWF0cml4c3luYy5tZC5iYWNrdXAnKTtcblx0XHRjb25zdCBiYXRjaGVzOiBTeW5jQmF0Y2hbXSA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpICs9IHRoaXMub3B0aW9ucy5iYXRjaFNpemUpIHtcblx0XHRcdGNvbnN0IGJhdGNoRmlsZXMgPSBmaWxlcy5zbGljZShpLCBpICsgdGhpcy5vcHRpb25zLmJhdGNoU2l6ZSk7XG5cdFx0XHRiYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRpZDogYGJhdGNoLSR7TWF0aC5mbG9vcihpIC8gdGhpcy5vcHRpb25zLmJhdGNoU2l6ZSl9YCxcblx0XHRcdFx0ZmlsZXM6IGJhdGNoRmlsZXMsXG5cdFx0XHRcdHN0YXR1czogJ3BlbmRpbmcnLFxuXHRcdFx0XHRwcm9ncmVzczogMFxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBiYXRjaGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgYmF0Y2hlcyBjb25jdXJyZW50bHkgd2l0aCBhIGxpbWl0LlxuXHQgKiBVcGRhdGVzIHJlc3VtZSBwcm9ncmVzcyBpbiBjYXNlIG9mIGludGVycnVwdGlvbi5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc0JhdGNoZXMoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgYWN0aXZlQmF0Y2hlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXHRcdGZvciAoY29uc3QgYmF0Y2ggb2YgdGhpcy5iYXRjaGVzKSB7XG5cdFx0XHQvLyBXYWl0IHVudGlsIGFjdGl2ZSBiYXRjaGVzIGFyZSBiZWxvdyB0aGUgY29uY3VycmVudCBsaW1pdFxuXHRcdFx0d2hpbGUgKGFjdGl2ZUJhdGNoZXMuc2l6ZSA+PSB0aGlzLm9wdGlvbnMubWF4Q29uY3VycmVudEJhdGNoZXMpIHtcblx0XHRcdFx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuXHRcdFx0fVxuXHRcdFx0YWN0aXZlQmF0Y2hlcy5hZGQoYmF0Y2guaWQpO1xuXHRcdFx0dGhpcy5wcm9jZXNzQmF0Y2goYmF0Y2gpXG5cdFx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRhY3RpdmVCYXRjaGVzLmRlbGV0ZShiYXRjaC5pZCk7XG5cdFx0XHRcdFx0Ly8gVXBkYXRlIHJlc3VtZSBpbmRleCBhZnRlciBiYXRjaCBjb21wbGV0ZXNcblx0XHRcdFx0XHR0aGlzLmxhc3RQcm9jZXNzZWRJbmRleCArPSBiYXRjaC5maWxlcy5sZW5ndGg7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coYENvbXBsZXRlZCAke2JhdGNoLmlkfSwgcmVzdW1pbmcgYXQgaW5kZXggJHt0aGlzLmxhc3RQcm9jZXNzZWRJbmRleH1gKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmNhdGNoKGVycm9yID0+IHtcblx0XHRcdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnSW5pdGlhbFN5bmNNYW5hZ2VyLnByb2Nlc3NCYXRjaCcsIG1ldGFkYXRhOiB7IGJhdGNoSWQ6IGJhdGNoLmlkIH0gfSk7XG5cdFx0XHRcdFx0YWN0aXZlQmF0Y2hlcy5kZWxldGUoYmF0Y2guaWQpO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cdFx0Ly8gV2FpdCB1bnRpbCBhbGwgYmF0Y2hlcyBhcmUgcHJvY2Vzc2VkXG5cdFx0d2hpbGUgKGFjdGl2ZUJhdGNoZXMuc2l6ZSA+IDApIHtcblx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUHJvY2VzcyBhIHNpbmdsZSBiYXRjaCBvZiBmaWxlcy5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc0JhdGNoKGJhdGNoOiBTeW5jQmF0Y2gpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0cnkge1xuXHRcdFx0YmF0Y2guc3RhdHVzID0gJ3Byb2Nlc3NpbmcnO1xuXHRcdFx0YmF0Y2guc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nICR7YmF0Y2guaWR9IHdpdGggJHtiYXRjaC5maWxlcy5sZW5ndGh9IGZpbGVzYCk7XG5cdFx0XHRmb3IgKGNvbnN0IGZpbGUgb2YgYmF0Y2guZmlsZXMpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnByb2Nlc3NGaWxlKGZpbGUpO1xuXHRcdFx0XHRcdHRoaXMucHJvZ3Jlc3MucHJvY2Vzc2VkRmlsZXMrKztcblx0XHRcdFx0XHRiYXRjaC5wcm9ncmVzcyA9ICh0aGlzLnByb2dyZXNzLnByb2Nlc3NlZEZpbGVzIC8gdGhpcy5wcm9ncmVzcy50b3RhbEZpbGVzKSAqIDEwMDtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZVByb2dyZXNzTm90aWZpY2F0aW9uKCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ0luaXRpYWxTeW5jTWFuYWdlci5wcm9jZXNzRmlsZScsIG1ldGFkYXRhOiB7IGZpbGVQYXRoOiBmaWxlLnBhdGggfSB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YmF0Y2guc3RhdHVzID0gJ2NvbXBsZXRlZCc7XG5cdFx0XHRiYXRjaC5lbmRUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdGNvbnNvbGUubG9nKGBCYXRjaCAke2JhdGNoLmlkfSBjb21wbGV0ZWQgaW4gJHtiYXRjaC5lbmRUaW1lIC0gKGJhdGNoLnN0YXJ0VGltZSB8fCAwKX0gbXNgKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0YmF0Y2guc3RhdHVzID0gJ2ZhaWxlZCc7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUHJvY2VzcyBhIHNpbmdsZSBmaWxlLlxuXHQgKiBFeHRyYWN0cyBtZXRhZGF0YSwgY2FsY3VsYXRlcyBmaWxlIGhhc2gsIGFuZCB1cGRhdGVzIGl0cyBzdGF0dXMuXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIHByb2Nlc3NGaWxlKGZpbGU6IFRGaWxlKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFNraXAgc3luYyBmaWxlIGlmIHNvbWVob3cgcmVhY2hlZCBoZXJlXG5cdFx0XHRjb25zdCBzeW5jRmlsZVBhdGggPSB0aGlzLm9wdGlvbnMuc3luY0ZpbGVQYXRoIHx8ICdfbWluZG1hdHJpeHN5bmMubWQnO1xuXHRcdFx0aWYgKGZpbGUucGF0aCA9PT0gc3luY0ZpbGVQYXRoIHx8IGZpbGUucGF0aCA9PT0gJ19taW5kbWF0cml4c3luYy5tZCcgfHwgZmlsZS5wYXRoID09PSAnX21pbmRtYXRyaXhzeW5jLm1kLmJhY2t1cCcpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLm1ldGFkYXRhRXh0cmFjdG9yLmV4dHJhY3RNZXRhZGF0YShmaWxlKTtcblx0XHRcdGNvbnN0IGZpbGVIYXNoID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVGaWxlSGFzaChmaWxlKTtcblx0XHRcdC8vIFVwZGF0ZSBmaWxlIHN0YXR1cyBpbiB0aGUgZGF0YWJhc2UgaWYgYXZhaWxhYmxlOyBlbHNlLCB1cGRhdGUgc3luYyBmaWxlIHN0YXR1cy5cblx0XHRcdGlmICh0aGlzLnN1cGFiYXNlU2VydmljZSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS51cGRhdGVGaWxlVmVjdG9yaXphdGlvblN0YXR1cyhtZXRhZGF0YSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLnVwZGF0ZVN5bmNTdGF0dXMoZmlsZS5wYXRoLCAnUEVORElORycsIHtcblx0XHRcdFx0XHRsYXN0TW9kaWZpZWQ6IGZpbGUuc3RhdC5tdGltZSxcblx0XHRcdFx0XHRoYXNoOiBmaWxlSGFzaFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdC8vIFF1ZXVlIGZpbGUgcHJvY2Vzc2luZyBmb3IgZnVydGhlciBzdGVwcyAobGlrZSBlbWJlZGRpbmcgZ2VuZXJhdGlvbilcblx0XHRcdGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdFx0dGhpcy5xdWV1ZVNlcnZpY2UuYWRkVGFzayh7XG5cdFx0XHRcdFx0aWQ6IGZpbGUucGF0aCxcblx0XHRcdFx0XHR0eXBlOiAnQ1JFQVRFJyxcblx0XHRcdFx0XHRwcmlvcml0eTogdGhpcy5nZXRGaWxlUHJpb3JpdHkoZmlsZS5wYXRoKSxcblx0XHRcdFx0XHRtYXhSZXRyaWVzOiAzLFxuXHRcdFx0XHRcdHJldHJ5Q291bnQ6IDAsXG5cdFx0XHRcdFx0Y3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuXHRcdFx0XHRcdHVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcblx0XHRcdFx0XHRzdGF0dXM6ICdQRU5ESU5HJyxcblx0XHRcdFx0XHRtZXRhZGF0YSxcblx0XHRcdFx0XHRkYXRhOiB7fVxuXHRcdFx0XHR9KS50aGVuKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHQvLyBNYXJrIGZpbGUgYXMgcHJvY2Vzc2VkIGluIHRoZSBkYXRhYmFzZSBvciBzeW5jIGZpbGUuXG5cdFx0XHRcdFx0aWYgKHRoaXMuc3VwYWJhc2VTZXJ2aWNlKSB7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS51cGRhdGVGaWxlVmVjdG9yaXphdGlvblN0YXR1cyhtZXRhZGF0YSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuc3luY01hbmFnZXIudXBkYXRlU3luY1N0YXR1cyhmaWxlLnBhdGgsICdPSycsIHtcblx0XHRcdFx0XHRcdFx0bGFzdE1vZGlmaWVkOiBmaWxlLnN0YXQubXRpbWUsXG5cdFx0XHRcdFx0XHRcdGhhc2g6IGZpbGVIYXNoXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHR9KS5jYXRjaChyZWplY3QpO1xuXHRcdFx0fSk7XG5cdFx0XHRjb25zb2xlLmxvZyhgUHJvY2Vzc2VkIGZpbGU6ICR7ZmlsZS5wYXRofWApO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnSW5pdGlhbFN5bmNNYW5hZ2VyLnByb2Nlc3NGaWxlJywgbWV0YWRhdGE6IHsgZmlsZVBhdGg6IGZpbGUucGF0aCB9IH0pO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSBTSEEtMjU2IGhhc2ggb2YgYSBmaWxlJ3MgY29udGVudC5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgY2FsY3VsYXRlRmlsZUhhc2goZmlsZTogVEZpbGUpOiBQcm9taXNlPHN0cmluZz4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkKGZpbGUpO1xuXHRcdFx0Y29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXHRcdFx0Y29uc3QgZGF0YSA9IGVuY29kZXIuZW5jb2RlKGNvbnRlbnQpO1xuXHRcdFx0Y29uc3QgYnVmZmVyID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBkYXRhKTtcblx0XHRcdHJldHVybiBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpXG5cdFx0XHRcdC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKVxuXHRcdFx0XHQuam9pbignJyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdJbml0aWFsU3luY01hbmFnZXIuY2FsY3VsYXRlRmlsZUhhc2gnLCBtZXRhZGF0YTogeyBmaWxlUGF0aDogZmlsZS5wYXRoIH0gfSk7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBwcm9ncmVzcyBub3RpZmljYXRpb25zLlxuXHQgKi9cblx0cHJpdmF0ZSB1cGRhdGVQcm9ncmVzc05vdGlmaWNhdGlvbigpOiB2b2lkIHtcblx0XHRjb25zdCBwcm9ncmVzc1BlcmNlbnRhZ2UgPSAodGhpcy5wcm9ncmVzcy5wcm9jZXNzZWRGaWxlcyAvIHRoaXMucHJvZ3Jlc3MudG90YWxGaWxlcykgKiAxMDA7XG5cdFx0dGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyLnVwZGF0ZVByb2dyZXNzKHtcblx0XHRcdHRhc2tJZDogJ2luaXRpYWwtc3luYycsXG5cdFx0XHRwcm9ncmVzczogcHJvZ3Jlc3NQZXJjZW50YWdlLFxuXHRcdFx0Y3VycmVudFN0ZXA6IGBQcm9jZXNzaW5nIGZpbGVzICgke3RoaXMucHJvZ3Jlc3MucHJvY2Vzc2VkRmlsZXN9LyR7dGhpcy5wcm9ncmVzcy50b3RhbEZpbGVzfSlgLFxuXHRcdFx0dG90YWxTdGVwczogdGhpcy5wcm9ncmVzcy50b3RhbEJhdGNoZXMsXG5cdFx0XHRjdXJyZW50U3RlcE51bWJlcjogdGhpcy5wcm9ncmVzcy5jdXJyZW50QmF0Y2ggKyAxLFxuXHRcdFx0ZXN0aW1hdGVkVGltZVJlbWFpbmluZzogdGhpcy5jYWxjdWxhdGVFc3RpbWF0ZWRUaW1lUmVtYWluaW5nKCksXG5cdFx0XHRkZXRhaWxzOiB7XG5cdFx0XHRcdHByb2Nlc3NlZEZpbGVzOiB0aGlzLnByb2dyZXNzLnByb2Nlc3NlZEZpbGVzLFxuXHRcdFx0XHR0b3RhbEZpbGVzOiB0aGlzLnByb2dyZXNzLnRvdGFsRmlsZXNcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgZXN0aW1hdGVkIHRpbWUgcmVtYWluaW5nIGJhc2VkIG9uIHByb2dyZXNzLlxuXHQgKi9cblx0cHJpdmF0ZSBjYWxjdWxhdGVFc3RpbWF0ZWRUaW1lUmVtYWluaW5nKCk6IG51bWJlciB7XG5cdFx0Y29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSB0aGlzLnByb2dyZXNzLnN0YXJ0VGltZTtcblx0XHRjb25zdCBmaWxlc1Blck1zID0gdGhpcy5wcm9ncmVzcy5wcm9jZXNzZWRGaWxlcyAvIGVsYXBzZWQ7XG5cdFx0Y29uc3QgcmVtYWluaW5nRmlsZXMgPSB0aGlzLnByb2dyZXNzLnRvdGFsRmlsZXMgLSB0aGlzLnByb2dyZXNzLnByb2Nlc3NlZEZpbGVzO1xuXHRcdHJldHVybiBmaWxlc1Blck1zID4gMCA/IHJlbWFpbmluZ0ZpbGVzIC8gZmlsZXNQZXJNcyA6IDA7XG5cdH1cblxuXHQvKipcblx0ICogU3RvcHMgdGhlIGluaXRpYWwgc3luYyBwcm9jZXNzLlxuXHQgKi9cblx0c3RvcCgpOiB2b2lkIHtcblx0XHR0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuXHRcdGlmICh0aGlzLnByb2Nlc3NpbmdUaW1lb3V0KSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5wcm9jZXNzaW5nVGltZW91dCk7XG5cdFx0XHR0aGlzLnByb2Nlc3NpbmdUaW1lb3V0ID0gbnVsbDtcblx0XHR9XG5cdFx0bmV3IE5vdGljZSgnSW5pdGlhbCBzeW5jIHN0b3BwZWQnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgY3VycmVudCBzeW5jIHByb2dyZXNzLlxuXHQgKi9cblx0Z2V0UHJvZ3Jlc3MoKTogU3luY1Byb2dyZXNzIHtcblx0XHRyZXR1cm4geyAuLi50aGlzLnByb2dyZXNzIH07XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHN5bmMgb3B0aW9ucy5cblx0ICovXG5cdHVwZGF0ZU9wdGlvbnMob3B0aW9uczogUGFydGlhbDxJbml0aWFsU3luY09wdGlvbnM+KTogdm9pZCB7XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXHR9XG59XG4iLCAiLy8gc3JjL3NlcnZpY2VzL1N0YXR1c01hbmFnZXIudHNcbmltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcblxuZXhwb3J0IGVudW0gUGx1Z2luU3RhdHVzIHtcbiAgICBJTklUSUFMSVpJTkcgPSAnaW5pdGlhbGl6aW5nJyxcbiAgICBXQUlUSU5HX0ZPUl9TWU5DID0gJ3dhaXRpbmdfc3luYycsXG4gICAgQ0hFQ0tJTkdfRklMRSA9ICdjaGVja2luZ19maWxlJyxcbiAgICBSRUFEWSA9ICdyZWFkeScsXG4gICAgRVJST1IgPSAnZXJyb3InLFxuICAgIFFVRVVJTkcgPSAncXVldWluZycsXG4gICAgUFJPQ0VTU0lOR19RVUVVRSA9ICdwcm9jZXNzaW5nX3F1ZXVlJyxcbiAgICBQRU5ESU5HID0gJ3BlbmRpbmcnLCAgICAgICAgIC8vIE5ldzogd2hlbiBhbiBvcGVyYXRpb24gaXMgcGVuZGluZ1xuICAgIElOX1BST0dSRVNTID0gJ2luX3Byb2dyZXNzJywgLy8gTmV3OiB3aGVuIGFuIG9wZXJhdGlvbiBpcyBhY3RpdmVseSBwcm9jZXNzaW5nXG4gICAgQ09NUExFVEVEID0gJ2NvbXBsZXRlZCcgICAgICAvLyBOZXc6IHdoZW4gYW4gb3BlcmF0aW9uIGhhcyBmaW5pc2hlZCBzdWNjZXNzZnVsbHlcbn1cblxuaW50ZXJmYWNlIFN0YXR1c0RldGFpbHMge1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgICBlcnJvcj86IEVycm9yO1xuICAgIHByb2dyZXNzPzogbnVtYmVyOyAvLyBQZXJjZW50YWdlICgwLTEwMClcbiAgICBxdWV1ZVNpemU/OiBudW1iZXI7XG4gICAgcGVuZGluZ0NoYW5nZXM/OiBudW1iZXI7XG4gICAgY29ubmVjdGl2aXR5U3RhdHVzPzogJ29ubGluZScgfCAnb2ZmbGluZScgfCAndW5rbm93bic7XG4gICAgbGFzdERhdGFiYXNlQ2hlY2s/OiBudW1iZXI7XG4gICAgLy8gQWRkaXRpb25hbCBkZXRhaWxzIGZvciBvcGVyYXRpb25zXG4gICAgb3BlcmF0aW9uPzogc3RyaW5nO1xuICAgIHN0ZXA/OiBzdHJpbmc7XG59XG5cbnR5cGUgU3RhdHVzQ2hhbmdlQ2FsbGJhY2sgPSAoc3RhdHVzOiBQbHVnaW5TdGF0dXMsIGRldGFpbHM6IFN0YXR1c0RldGFpbHMpID0+IHZvaWQ7XG5cbmV4cG9ydCBjbGFzcyBTdGF0dXNNYW5hZ2VyIHtcbiAgICBwcml2YXRlIGN1cnJlbnRTdGF0dXM6IFBsdWdpblN0YXR1cztcbiAgICBwcml2YXRlIHN0YXR1c0RldGFpbHM6IFN0YXR1c0RldGFpbHM7XG4gICAgcHJpdmF0ZSBzdGF0dXNCYXJJdGVtOiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIHN1YnNjcmliZXJzOiBTZXQ8U3RhdHVzQ2hhbmdlQ2FsbGJhY2s+O1xuXG4gICAgY29uc3RydWN0b3Ioc3RhdHVzQmFySXRlbTogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNCYXJJdGVtID0gc3RhdHVzQmFySXRlbTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdHVzID0gUGx1Z2luU3RhdHVzLklOSVRJQUxJWklORztcbiAgICAgICAgdGhpcy5zdGF0dXNEZXRhaWxzID0ge1xuICAgICAgICAgICAgbWVzc2FnZTogJ0luaXRpYWxpemluZyBwbHVnaW4uLi4nLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgY29ubmVjdGl2aXR5U3RhdHVzOiAndW5rbm93bidcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGN1cnJlbnQgc3RhdHVzIHdpdGggbmV3IGRldGFpbHMuXG4gICAgICovXG4gICAgcHVibGljIHNldFN0YXR1cyhzdGF0dXM6IFBsdWdpblN0YXR1cywgZGV0YWlsczogUGFydGlhbDxTdGF0dXNEZXRhaWxzPiA9IHt9KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG9sZFN0YXR1cyA9IHRoaXMuY3VycmVudFN0YXR1cztcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLnN0YXR1c0RldGFpbHMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnN0YXR1c0RldGFpbHMsXG4gICAgICAgICAgICAuLi5kZXRhaWxzLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKCk7XG4gICAgICAgIGlmIChvbGRTdGF0dXMgIT09IHN0YXR1cykge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09IFBsdWdpblN0YXR1cy5FUlJPUiAmJiBkZXRhaWxzLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYE1pbmQgTWF0cml4OiAke2RldGFpbHMubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBzdGF0dXMgYW5kIGRldGFpbHMuXG4gICAgICovXG4gICAgcHVibGljIGdldFN0YXR1cygpOiB7IHN0YXR1czogUGx1Z2luU3RhdHVzOyBkZXRhaWxzOiBTdGF0dXNEZXRhaWxzIH0ge1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHRoaXMuY3VycmVudFN0YXR1cywgZGV0YWlsczogeyAuLi50aGlzLnN0YXR1c0RldGFpbHMgfSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byBzdGF0dXMgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3Vic2NyaWJlKGNhbGxiYWNrOiBTdGF0dXNDaGFuZ2VDYWxsYmFjayk6ICgpID0+IHZvaWQge1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmFkZChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzdGF0dXMgYmFyIFVJLlxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlU3RhdHVzQmFyKCk6IHZvaWQge1xuICAgICAgICAvLyBDbGVhciBleGlzdGluZyBjb250ZW50XG4gICAgICAgIHRoaXMuc3RhdHVzQmFySXRlbS5pbm5lckhUTUwgPSAnJztcblxuICAgICAgICAvLyBDcmVhdGUgYW5kIGFwcGVuZCB0aGUgc3RhdHVzIGljb25cbiAgICAgICAgY29uc3QgaWNvbiA9IHRoaXMuY3JlYXRlU3RhdHVzSWNvbigpO1xuICAgICAgICB0aGlzLnN0YXR1c0Jhckl0ZW0uYXBwZW5kQ2hpbGQoaWNvbik7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFuZCBhcHBlbmQgdGhlIHN0YXR1cyBkZXRhaWxzIHRleHRcbiAgICAgICAgY29uc3QgZGV0YWlsc1RleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGRldGFpbHNUZXh0LmFkZENsYXNzKCdtaW5kLW1hdHJpeC1zdGF0dXMtZGV0YWlscycpO1xuICAgICAgICBsZXQgZGlzcGxheVRleHQgPSB0aGlzLnN0YXR1c0RldGFpbHMubWVzc2FnZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzRGV0YWlscy5vcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0ICs9IGAgWyR7dGhpcy5zdGF0dXNEZXRhaWxzLm9wZXJhdGlvbn1dYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXNEZXRhaWxzLnN0ZXApIHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0ICs9IGAgLSAke3RoaXMuc3RhdHVzRGV0YWlscy5zdGVwfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzRGV0YWlscy5wcm9ncmVzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkaXNwbGF5VGV4dCArPSBgICgke3RoaXMuc3RhdHVzRGV0YWlscy5wcm9ncmVzc30lKWA7XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWlsc1RleHQudGV4dENvbnRlbnQgPSBkaXNwbGF5VGV4dDtcbiAgICAgICAgdGhpcy5zdGF0dXNCYXJJdGVtLmFwcGVuZENoaWxkKGRldGFpbHNUZXh0KTtcblxuICAgICAgICAvLyBDb21wb3NlIHRvb2x0aXAgd2l0aCBhZGRpdGlvbmFsIGRldGFpbHNcbiAgICAgICAgbGV0IHRvb2x0aXAgPSB0aGlzLnN0YXR1c0RldGFpbHMubWVzc2FnZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzRGV0YWlscy5jb25uZWN0aXZpdHlTdGF0dXMpIHtcbiAgICAgICAgICAgIHRvb2x0aXAgKz0gYCB8IENvbm5lY3Rpdml0eTogJHt0aGlzLnN0YXR1c0RldGFpbHMuY29ubmVjdGl2aXR5U3RhdHVzfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzRGV0YWlscy5sYXN0RGF0YWJhc2VDaGVjaykge1xuICAgICAgICAgICAgdG9vbHRpcCArPSBgIHwgTGFzdCBEQiBDaGVjazogJHtuZXcgRGF0ZSh0aGlzLnN0YXR1c0RldGFpbHMubGFzdERhdGFiYXNlQ2hlY2spLnRvTG9jYWxlVGltZVN0cmluZygpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzRGV0YWlscy5xdWV1ZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9vbHRpcCArPSBgIHwgUXVldWU6ICR7dGhpcy5zdGF0dXNEZXRhaWxzLnF1ZXVlU2l6ZX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1c0RldGFpbHMucGVuZGluZ0NoYW5nZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9vbHRpcCArPSBgIHwgUGVuZGluZzogJHt0aGlzLnN0YXR1c0RldGFpbHMucGVuZGluZ0NoYW5nZXN9YDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXR1c0Jhckl0ZW0uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdG9vbHRpcCk7XG4gICAgICAgIHRoaXMuc3RhdHVzQmFySXRlbS5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgbmV3IE5vdGljZSh0b29sdGlwKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc3RhdHVzIGljb24gZWxlbWVudCBiYXNlZCBvbiBjdXJyZW50IHN0YXR1cy5cbiAgICAgKi9cbiAgICBwcml2YXRlIGNyZWF0ZVN0YXR1c0ljb24oKTogSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdCBpY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBpY29uLmFkZENsYXNzKCdtaW5kLW1hdHJpeC1zdGF0dXMtaWNvbicpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuY3VycmVudFN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBQbHVnaW5TdGF0dXMuUkVBRFk6XG4gICAgICAgICAgICBjYXNlIFBsdWdpblN0YXR1cy5DT01QTEVURUQ6XG4gICAgICAgICAgICAgICAgaWNvbi5hZGRDbGFzcygnaXMtcmVhZHknKTtcbiAgICAgICAgICAgICAgICBpY29uLmlubmVySFRNTCA9ICdcdTI1Q0YnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQbHVnaW5TdGF0dXMuRVJST1I6XG4gICAgICAgICAgICAgICAgaWNvbi5hZGRDbGFzcygnaXMtZXJyb3InKTtcbiAgICAgICAgICAgICAgICBpY29uLmlubmVySFRNTCA9ICdcdTI2QTAnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQbHVnaW5TdGF0dXMuV0FJVElOR19GT1JfU1lOQzpcbiAgICAgICAgICAgIGNhc2UgUGx1Z2luU3RhdHVzLkNIRUNLSU5HX0ZJTEU6XG4gICAgICAgICAgICBjYXNlIFBsdWdpblN0YXR1cy5RVUVVSU5HOlxuICAgICAgICAgICAgY2FzZSBQbHVnaW5TdGF0dXMuUFJPQ0VTU0lOR19RVUVVRTpcbiAgICAgICAgICAgIGNhc2UgUGx1Z2luU3RhdHVzLlBFTkRJTkc6XG4gICAgICAgICAgICAgICAgaWNvbi5hZGRDbGFzcygnaXMtd29ya2luZycpO1xuICAgICAgICAgICAgICAgIGljb24uaW5uZXJIVE1MID0gJ1x1MjFCQic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFBsdWdpblN0YXR1cy5JTl9QUk9HUkVTUzpcbiAgICAgICAgICAgICAgICBpY29uLmFkZENsYXNzKCdpcy1pbi1wcm9ncmVzcycpO1xuICAgICAgICAgICAgICAgIGljb24uaW5uZXJIVE1MID0gJ1x1MjVDQic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGljb24uYWRkQ2xhc3MoJ2lzLWluaXRpYWxpemluZycpO1xuICAgICAgICAgICAgICAgIGljb24uaW5uZXJIVE1MID0gJ1x1MjVDQic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGljb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IGFsbCBzdWJzY3JpYmVycyBvZiBhIHN0YXR1cyBjaGFuZ2UuXG4gICAgICovXG4gICAgcHJpdmF0ZSBub3RpZnlTdWJzY3JpYmVycygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5jdXJyZW50U3RhdHVzLCB0aGlzLnN0YXR1c0RldGFpbHMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBzdGF0dXMgY2hhbmdlIHN1YnNjcmliZXI6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgcGx1Z2luIGlzIGN1cnJlbnRseSBpbiBhIHNwZWNpZmljIHN0YXR1cy5cbiAgICAgKi9cbiAgICBwdWJsaWMgaXNJblN0YXR1cyhzdGF0dXM6IFBsdWdpblN0YXR1cyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U3RhdHVzID09PSBzdGF0dXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHByb2dyZXNzIGZvciB0aGUgY3VycmVudCB0YXNrIHdpdGggZGV0YWlsZWQgc3RlcCBpbmZvLlxuICAgICAqIEBwYXJhbSBwcm9ncmVzcyBQZXJjZW50YWdlIG9mIGNvbXBsZXRpb24uXG4gICAgICogQHBhcmFtIGN1cnJlbnRTdGVwIERlc2NyaXB0aW9uIG9mIHRoZSBjdXJyZW50IHN0ZXAuXG4gICAgICogQHBhcmFtIG9wZXJhdGlvbiBPcHRpb25hbCBvcGVyYXRpb24gbmFtZS5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbERldGFpbHMgT3B0aW9uYWwgZXh0cmEgZGV0YWlscy5cbiAgICAgKi9cbiAgICBwdWJsaWMgdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3M6IG51bWJlciwgY3VycmVudFN0ZXA6IHN0cmluZywgb3BlcmF0aW9uPzogc3RyaW5nLCBhZGRpdGlvbmFsRGV0YWlscz86IFBhcnRpYWw8U3RhdHVzRGV0YWlscz4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdGF0dXNEZXRhaWxzLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgIHRoaXMuc3RhdHVzRGV0YWlscy5zdGVwID0gY3VycmVudFN0ZXA7XG4gICAgICAgIGlmIChvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzRGV0YWlscy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZGl0aW9uYWxEZXRhaWxzKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0RldGFpbHMgPSB7IC4uLnRoaXMuc3RhdHVzRGV0YWlscywgLi4uYWRkaXRpb25hbERldGFpbHMgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcigpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBQbHVnaW4sIFRBYnN0cmFjdEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBTdGF0dXNNYW5hZ2VyLCBQbHVnaW5TdGF0dXMgfSBmcm9tICcuL1N0YXR1c01hbmFnZXInO1xuXG5leHBvcnQgY2xhc3MgU3luY0RldGVjdGlvbk1hbmFnZXIge1xuICAgIHByaXZhdGUgbGFzdFN5bmNBY3Rpdml0eTogbnVtYmVyID0gMDtcbiAgICBwcml2YXRlIHN5bmNDaGVja0ludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgcXVpZXRQZXJpb2RSZWFjaGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBpc1dhaXRpbmdGb3JRdWlldFBlcmlvZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgUVVJRVRfUEVSSU9EX01TID0gNTAwMDsgLy8gNSBzZWNvbmRzXG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBwbHVnaW46IFBsdWdpbixcbiAgICAgICAgcHJpdmF0ZSBzdGF0dXNNYW5hZ2VyOiBTdGF0dXNNYW5hZ2VyLFxuICAgICAgICBwcml2YXRlIG9uUXVpZXRQZXJpb2RSZWFjaGVkOiAoKSA9PiB2b2lkXG4gICAgKSB7fVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgbW9uaXRvcmluZyBmb3Igc3luYyBhY3Rpdml0eVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGFydE1vbml0b3JpbmcoKTogdm9pZCB7XG4gICAgICAgIC8vIFRyYWNrIGZpbGUgY2hhbmdlcyBhcyBwb3RlbnRpYWwgc3luYyBhY3Rpdml0eVxuICAgICAgICB0aGlzLnBsdWdpbi5yZWdpc3RlckV2ZW50KFxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uYXBwLnZhdWx0Lm9uKCdtb2RpZnknLCAoKSA9PiB0aGlzLnJlY29yZFN5bmNBY3Rpdml0eSgpKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBsdWdpbi5yZWdpc3RlckV2ZW50KFxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uYXBwLnZhdWx0Lm9uKCdjcmVhdGUnLCAoKSA9PiB0aGlzLnJlY29yZFN5bmNBY3Rpdml0eSgpKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBsdWdpbi5yZWdpc3RlckV2ZW50KFxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uYXBwLnZhdWx0Lm9uKCdkZWxldGUnLCAoKSA9PiB0aGlzLnJlY29yZFN5bmNBY3Rpdml0eSgpKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFN0YXJ0IGNoZWNraW5nIGZvciBxdWlldCBwZXJpb2RcbiAgICAgICAgdGhpcy5zdGFydFF1aWV0UGVyaW9kQ2hlY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNvcmQgc3luYyBhY3Rpdml0eSBhbmQgcmVzZXQgcXVpZXQgcGVyaW9kXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWNvcmRTeW5jQWN0aXZpdHkoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubGFzdFN5bmNBY3Rpdml0eSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMucXVpZXRQZXJpb2RSZWFjaGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNXYWl0aW5nRm9yUXVpZXRQZXJpb2QpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzTWFuYWdlci5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLldBSVRJTkdfRk9SX1NZTkMsIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnV2FpdGluZyBmb3IgT2JzaWRpYW4gc3luYyB0byBzZXR0bGUuLi4nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGNoZWNraW5nIGZvciBxdWlldCBwZXJpb2RcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXJ0UXVpZXRQZXJpb2RDaGVjaygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzV2FpdGluZ0ZvclF1aWV0UGVyaW9kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RTeW5jID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdFN5bmNBY3Rpdml0eTtcblxuICAgICAgICAgICAgaWYgKHRpbWVTaW5jZUxhc3RTeW5jID49IHRoaXMuUVVJRVRfUEVSSU9EX01TICYmICF0aGlzLnF1aWV0UGVyaW9kUmVhY2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucXVpZXRQZXJpb2RSZWFjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzV2FpdGluZ0ZvclF1aWV0UGVyaW9kID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNDaGVja0ludGVydmFsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9uUXVpZXRQZXJpb2RSZWFjaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMDApOyAvLyBDaGVjayBldmVyeSBzZWNvbmRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIG1vbml0b3JpbmcgZm9yIHN5bmMgYWN0aXZpdHlcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RvcE1vbml0b3JpbmcoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnN5bmNDaGVja0ludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1dhaXRpbmdGb3JRdWlldFBlcmlvZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGN1cnJlbnRseSB3YWl0aW5nIGZvciBxdWlldCBwZXJpb2RcbiAgICAgKi9cbiAgICBwdWJsaWMgaXNXYWl0aW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1dhaXRpbmdGb3JRdWlldFBlcmlvZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGltZSBzaW5jZSBsYXN0IHN5bmMgYWN0aXZpdHlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0VGltZVNpbmNlTGFzdFN5bmMoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLmxhc3RTeW5jQWN0aXZpdHk7XG4gICAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQSxpQkFBQUE7QUFBQSxFQUFBLGVBQUFDO0FBQUEsRUFBQSxnQkFBQUM7QUFBQSxFQUFBO0FBQUEsZUFBQUM7QUFBQTtBQUFBLElBR0ksV0FVQSxjQUVTQSxRQUVOLGlCQUVNSCxVQUNBQyxVQUNBQztBQXJCYjtBQUFBO0FBQUE7QUFHQSxJQUFJLFlBQVksV0FBVztBQUl2QixVQUFJLE9BQU8sU0FBUyxhQUFhO0FBQUUsZUFBTztBQUFBLE1BQU07QUFDaEQsVUFBSSxPQUFPLFdBQVcsYUFBYTtBQUFFLGVBQU87QUFBQSxNQUFRO0FBQ3BELFVBQUksT0FBTyxXQUFXLGFBQWE7QUFBRSxlQUFPO0FBQUEsTUFBUTtBQUNwRCxZQUFNLElBQUksTUFBTSxnQ0FBZ0M7QUFBQSxJQUNwRDtBQUVBLElBQUksZUFBZSxVQUFVO0FBRXRCLElBQU1DLFNBQVEsYUFBYTtBQUVsQyxJQUFPLGtCQUFRLGFBQWEsTUFBTSxLQUFLLFlBQVk7QUFFNUMsSUFBTUgsV0FBVSxhQUFhO0FBQzdCLElBQU1DLFdBQVUsYUFBYTtBQUM3QixJ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Q0osTUFBTTtBQUFBLE1BQ04sVUFBVSxNQUFNO0FBbm1CbkIsWUFBQUE7QUFvbUJJLFNBQUFBLE1BQUEsS0FBSyxpQkFBTCxnQkFBQUEsSUFBbUI7QUFDbkIsWUFBSSxLQUFLLFNBQVMscUJBQXFCO0FBQ3RDLGNBQUkseUJBQU8sb0JBQW9CO0FBQUEsUUFDaEM7QUFBQSxNQUNEO0FBQUEsSUFDRCxDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDZixJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixVQUFVLFlBQVk7QUE5bUJ6QixZQUFBQSxLQUFBO0FBK21CSSxTQUFBQSxNQUFBLEtBQUssZ0JBQUwsZ0JBQUFBLElBQWtCO0FBQ2xCLGdCQUFNLFVBQUssZ0JBQUwsbUJBQWtCO0FBQ3hCLFlBQUksS0FBSyxTQUFTLHFCQUFxQjtBQUN0QyxjQUFJLHlCQUFPLDBCQUEwQjtBQUFBLFFBQ3RDO0FBQUEsTUFDRDtBQUFBLElBQ0QsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2YsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxZQUFZO0FBQ3JCLFlBQUksS0FBSyxvQkFBb0I7QUFDNUIsZ0JBQU0sS0FBSyxtQkFBbUIsVUFBVTtBQUFBLFFBQ3pDLE9BQU87QUFDTixjQUFJLHlCQUFPLHNDQUFzQztBQUFBLFFBQ2xEO0FBQUEsTUFDRDtBQUFBLElBQ0QsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2YsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxNQUFNO0FBdG9CbkIsWUFBQUE7QUF1b0JJLFNBQUFBLE1BQUEsS0FBSyx1QkFBTCxnQkFBQUEsSUFBeUI7QUFDekIsWUFBSSx5QkFBTyxzQkFBc0I7QUFBQSxNQUNsQztBQUFBLElBQ0QsQ0FBQztBQUFBLEVBQ0Y7QUFDRDsiLAogICJuYW1lcyI6IFsiSGVhZGVycyIsICJSZXF1ZXN0IiwgIlJlc3BvbnNlIiwgImZldGNoIiwgIlBvc3RncmVzdEVycm9yIiwgIlBvc3RncmVzdEJ1aWxkZXIiLCAicmVzIiwgIl9hIiwgIlBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIiLCAiX2EiLCAiUG9zdGdyZXN0RmlsdGVyQnVpbGRlciIsICJQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIiLCAiZmV0Y2giLCAiaGVhZCIsICJQb3N0Z3Jlc3RDbGllbnQiLCAiZmV0Y2giLCAiaGVhZCIsICJnZXQiLCAibW9kdWxlIiwgImltcG9ydF9vYnNpZGlhbiIsICJmZXRjaCIsICJGdW5jdGlvblJlZ2lvbiIsICJfYSIsICJpbmRleCIsICJTT0NLRVRfU1RBVEVTIiwgIkNIQU5ORUxfU1RBVEVTIiwgIkNIQU5ORUxfRVZFTlRTIiwgIlRSQU5TUE9SVFMiLCAiQ09OTkVDVElPTl9TVEFURSIsICJQb3N0Z3Jlc1R5cGVzIiwgIl9hIiwgIl9hIiwgIlJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMiLCAiX2EiLCAiUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQiLCAiUkVBTFRJTUVfTElTVEVOX1RZUEVTIiwgIlJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMiLCAiX2EiLCAicHVzaCIsICJfYiIsICJ0eXBlIiwgIm5vb3AiLCAiZmV0Y2giLCAiX2EiLCAia2luZCIsICJyZXNvbHZlRmV0Y2giLCAiZmV0Y2giLCAiX19hd2FpdGVyIiwgIl9fYXdhaXRlciIsICJmZXRjaCIsICJyZXNvbHZlRmV0Y2giLCAidmVyc2lvbiIsICJERUZBVUxUX0hFQURFUlMiLCAidmVyc2lvbiIsICJmZXRjaCIsICJERUZBVUxUX0hFQURFUlMiLCAicmVzb2x2ZUZldGNoIiwgImZldGNoIiwgInZlcnNpb24iLCAiREVGQVVMVF9IRUFERVJTIiwgInZlcnNpb24iLCAicmVzb2x2ZUZldGNoIiwgIkhlYWRlcnMiLCAiZmV0Y2giLCAiX19hd2FpdGVyIiwgIl9hIiwgImRlZmF1bHRzIiwgIkRFRkFVTFRfREJfT1BUSU9OUyIsICJERUZBVUxUX0FVVEhfT1BUSU9OUyIsICJERUZBVUxUX1JFQUxUSU1FX09QVElPTlMiLCAiREVGQVVMVF9HTE9CQUxfT1BUSU9OUyIsICJfX2F3YWl0ZXIiLCAidmVyc2lvbiIsICJERUZBVUxUX0hFQURFUlMiLCAidmVyc2lvbiIsICJyZXNvbHZlRmV0Y2giLCAiZmV0Y2giLCAiX2EiLCAic3RyIiwgIl9nZXRFcnJvck1lc3NhZ2UiLCAiaGFuZGxlRXJyb3IiLCAiX2EiLCAiX2dldFJlcXVlc3RQYXJhbXMiLCAiX2hhbmRsZVJlcXVlc3QiLCAiZmV0Y2giLCAicmVzb2x2ZUZldGNoIiwgIl9fcmVzdCIsICJfYSIsICJERUZBVUxUX0hFQURFUlMiLCAicmVzb2x2ZUZldGNoIiwgIl9hIiwgInZlcnNpb24iLCAicmVzdWx0IiwgImV4cGlyZXNBdCIsICJlcnJvciIsICJkYXRhIiwgIl9hIiwgImRlYnVnIiwgImZldGNoIiwgImdldEFsbEV4Y2x1c2lvbnMiLCAiaXNWYXVsdEluaXRpYWxpemVkIiwgImlzVmF1bHRJbml0aWFsaXplZCIsICJfYSIsICJsaW1pdCIsICJzdHIiLCAiaXNfYXJyYXkiLCAiZmV0Y2giLCAiUmVxdWVzdCIsICJSZXNwb25zZSIsICJIZWFkZXJzIiwgIkZvcm1EYXRhIiwgIkJsb2IiLCAiRmlsZSIsICJSZWFkYWJsZVN0cmVhbSIsICJfYSIsICJzZWxmIiwgIlJlYWRhYmxlU3RyZWFtIiwgIl9hIiwgInN0ciIsICJpbmRleCIsICJfYSIsICJGaWxlIiwgIkZvcm1EYXRhIiwgImZldGNoIiwgIm9wdHMiLCAiUGFnZSIsICJfYSIsICJyZXRyeU1lc3NhZ2UiLCAic2xlZXAiLCAiX2EiLCAiX2EiLCAibW9kaWZpZWRBcmciLCAiX2EiLCAiX2EiLCAiX2EiLCAiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsICJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IiwgImluZGV4IiwgIl9hIiwgImlucHV0VG9vbCIsICJfYSIsICJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IiwgImNvbnRlbnQiLCAibmFtZSIsICJfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbE1lc3NhZ2UiLCAiX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxGdW5jdGlvbkNhbGwiLCAiX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxGdW5jdGlvbkNhbGxSZXN1bHQiLCAiX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfY2FsY3VsYXRlVG90YWxVc2FnZSIsICJfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl92YWxpZGF0ZVBhcmFtcyIsICJfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9zdHJpbmdpZnlGdW5jdGlvbkNhbGxSZXN1bHQiLCAiaW5kZXgiLCAiZXNjYXBlIiwgImUiLCAiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsICJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IiwgIl9hIiwgIl9DaGF0Q29tcGxldGlvblN0cmVhbV9iZWdpblJlcXVlc3QiLCAiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2dldENob2ljZUV2ZW50U3RhdGUiLCAiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2FkZENodW5rIiwgIl9DaGF0Q29tcGxldGlvblN0cmVhbV9lbWl0VG9vbENhbGxEb25lRXZlbnQiLCAiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRDb250ZW50RG9uZUV2ZW50cyIsICJfQ2hhdENvbXBsZXRpb25TdHJlYW1fZW5kUmVxdWVzdCIsICJfQ2hhdENvbXBsZXRpb25TdHJlYW1fZ2V0QXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0IiwgIl9DaGF0Q29tcGxldGlvblN0cmVhbV9hY2N1bXVsYXRlQ2hhdENvbXBsZXRpb24iLCAiaW5kZXgiLCAiY29udGVudCIsICJyZWZ1c2FsIiwgInJlc3QiLCAiX2IiLCAiX2MiLCAiX2QiLCAiY2h1bmsiLCAiaWQiLCAiQ29tcGxldGlvbnMiLCAiQ2hhdCIsICJDb21wbGV0aW9ucyIsICJjaHVuayIsICJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IiwgIl9hIiwgImluZGV4IiwgIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCAiX0Fzc2lzdGFudFN0cmVhbV9lbmRSZXF1ZXN0IiwgIl9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlTWVzc2FnZSIsICJfQXNzaXN0YW50U3RyZWFtX2hhbmRsZVJ1blN0ZXAiLCAiX0Fzc2lzdGFudFN0cmVhbV9oYW5kbGVFdmVudCIsICJfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVSdW5TdGVwIiwgIl9Bc3Npc3RhbnRTdHJlYW1fYWNjdW11bGF0ZU1lc3NhZ2UiLCAiX0Fzc2lzdGFudFN0cmVhbV9hY2N1bXVsYXRlQ29udGVudCIsICJfQXNzaXN0YW50U3RyZWFtX2hhbmRsZVJ1biIsICJfYSIsICJzbGVlcCIsICJfYSIsICJzbGVlcCIsICJzbGVlcCIsICJfYSIsICJDaGF0IiwgIkNvbXBsZXRpb25zIiwgIl9hIiwgIkZpbGVzIiwgInNsZWVwIiwgIl9hIiwgIkNvbXBsZXRpb25zIiwgIkZpbGVzIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgIl9hIiwgImluZGV4IiwgIl9hIiwgImluZGV4IiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiU3luY0Vycm9yVHlwZSIsICJfYSIsICJfYSIsICJzdHIiLCAiaW1wb3J0X29ic2lkaWFuIiwgIl9hIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaXNWYXVsdEluaXRpYWxpemVkIiwgInZhbHVlIiwgInN5c3RlbUZpbGVzIiwgIm1vZGFsIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiX2EiLCAiaXNWYXVsdEluaXRpYWxpemVkIiwgImdldEFsbEV4Y2x1c2lvbnMiXQp9Cg==
