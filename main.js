/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the GitHub repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@supabase/node-fetch/browser.js
var browser_exports = {};
__export(browser_exports, {
  Headers: () => Headers2,
  Request: () => Request2,
  Response: () => Response2,
  default: () => browser_default,
  fetch: () => fetch2
});
var getGlobal, globalObject, fetch2, browser_default, Headers2, Request2, Response2;
var init_browser = __esm({
  "node_modules/@supabase/node-fetch/browser.js"() {
    "use strict";
    getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    globalObject = getGlobal();
    fetch2 = globalObject.fetch;
    browser_default = globalObject.fetch.bind(globalObject);
    Headers2 = globalObject.Headers;
    Request2 = globalObject.Request;
    Response2 = globalObject.Response;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js
var require_PostgrestError = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestError2 = class extends Error {
      constructor(context) {
        super(context.message);
        this.name = "PostgrestError";
        this.details = context.details;
        this.hint = context.hint;
        this.code = context.code;
      }
    };
    exports.default = PostgrestError2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js
var require_PostgrestBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var node_fetch_1 = __importDefault((init_browser(), __toCommonJS(browser_exports)));
    var PostgrestError_1 = __importDefault(require_PostgrestError());
    var PostgrestBuilder2 = class {
      constructor(builder) {
        this.shouldThrowOnError = false;
        this.method = builder.method;
        this.url = builder.url;
        this.headers = builder.headers;
        this.schema = builder.schema;
        this.body = builder.body;
        this.shouldThrowOnError = builder.shouldThrowOnError;
        this.signal = builder.signal;
        this.isMaybeSingle = builder.isMaybeSingle;
        if (builder.fetch) {
          this.fetch = builder.fetch;
        } else if (typeof fetch === "undefined") {
          this.fetch = node_fetch_1.default;
        } else {
          this.fetch = fetch;
        }
      }
      /**
       * If there's an error with the query, throwOnError will reject the promise by
       * throwing the error instead of returning it as part of a successful response.
       *
       * {@link https://github.com/supabase/supabase-js/issues/92}
       */
      throwOnError() {
        this.shouldThrowOnError = true;
        return this;
      }
      /**
       * Set an HTTP header for the request.
       */
      setHeader(name, value) {
        this.headers = Object.assign({}, this.headers);
        this.headers[name] = value;
        return this;
      }
      then(onfulfilled, onrejected) {
        if (this.schema === void 0) {
        } else if (["GET", "HEAD"].includes(this.method)) {
          this.headers["Accept-Profile"] = this.schema;
        } else {
          this.headers["Content-Profile"] = this.schema;
        }
        if (this.method !== "GET" && this.method !== "HEAD") {
          this.headers["Content-Type"] = "application/json";
        }
        const _fetch = this.fetch;
        let res = _fetch(this.url.toString(), {
          method: this.method,
          headers: this.headers,
          body: JSON.stringify(this.body),
          signal: this.signal
        }).then(async (res2) => {
          var _a2, _b, _c;
          let error = null;
          let data = null;
          let count = null;
          let status = res2.status;
          let statusText = res2.statusText;
          if (res2.ok) {
            if (this.method !== "HEAD") {
              const body = await res2.text();
              if (body === "") {
              } else if (this.headers["Accept"] === "text/csv") {
                data = body;
              } else if (this.headers["Accept"] && this.headers["Accept"].includes("application/vnd.pgrst.plan+text")) {
                data = body;
              } else {
                data = JSON.parse(body);
              }
            }
            const countHeader = (_a2 = this.headers["Prefer"]) === null || _a2 === void 0 ? void 0 : _a2.match(/count=(exact|planned|estimated)/);
            const contentRange = (_b = res2.headers.get("content-range")) === null || _b === void 0 ? void 0 : _b.split("/");
            if (countHeader && contentRange && contentRange.length > 1) {
              count = parseInt(contentRange[1]);
            }
            if (this.isMaybeSingle && this.method === "GET" && Array.isArray(data)) {
              if (data.length > 1) {
                error = {
                  // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553
                  code: "PGRST116",
                  details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                  hint: null,
                  message: "JSON object requested, multiple (or no) rows returned"
                };
                data = null;
                count = null;
                status = 406;
                statusText = "Not Acceptable";
              } else if (data.length === 1) {
                data = data[0];
              } else {
                data = null;
              }
            }
          } else {
            const body = await res2.text();
            try {
              error = JSON.parse(body);
              if (Array.isArray(error) && res2.status === 404) {
                data = [];
                error = null;
                status = 200;
                statusText = "OK";
              }
            } catch (_d) {
              if (res2.status === 404 && body === "") {
                status = 204;
                statusText = "No Content";
              } else {
                error = {
                  message: body
                };
              }
            }
            if (error && this.isMaybeSingle && ((_c = error === null || error === void 0 ? void 0 : error.details) === null || _c === void 0 ? void 0 : _c.includes("0 rows"))) {
              error = null;
              status = 200;
              statusText = "OK";
            }
            if (error && this.shouldThrowOnError) {
              throw new PostgrestError_1.default(error);
            }
          }
          const postgrestResponse = {
            error,
            data,
            count,
            status,
            statusText
          };
          return postgrestResponse;
        });
        if (!this.shouldThrowOnError) {
          res = res.catch((fetchError) => {
            var _a2, _b, _c;
            return {
              error: {
                message: `${(_a2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _a2 !== void 0 ? _a2 : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,
                details: `${(_b = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _b !== void 0 ? _b : ""}`,
                hint: "",
                code: `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) !== null && _c !== void 0 ? _c : ""}`
              },
              data: null,
              count: null,
              status: 0,
              statusText: ""
            };
          });
        }
        return res.then(onfulfilled, onrejected);
      }
    };
    exports.default = PostgrestBuilder2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js
var require_PostgrestTransformBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestBuilder_1 = __importDefault(require_PostgrestBuilder());
    var PostgrestTransformBuilder2 = class extends PostgrestBuilder_1.default {
      /**
       * Perform a SELECT on the query result.
       *
       * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
       * return modified rows. By calling this method, modified rows are returned in
       * `data`.
       *
       * @param columns - The columns to retrieve, separated by commas
       */
      select(columns) {
        let quoted = false;
        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c) => {
          if (/\s/.test(c) && !quoted) {
            return "";
          }
          if (c === '"') {
            quoted = !quoted;
          }
          return c;
        }).join("");
        this.url.searchParams.set("select", cleanedColumns);
        if (this.headers["Prefer"]) {
          this.headers["Prefer"] += ",";
        }
        this.headers["Prefer"] += "return=representation";
        return this;
      }
      /**
       * Order the query result by `column`.
       *
       * You can call this method multiple times to order by multiple columns.
       *
       * You can order referenced tables, but it only affects the ordering of the
       * parent table if you use `!inner` in the query.
       *
       * @param column - The column to order by
       * @param options - Named parameters
       * @param options.ascending - If `true`, the result will be in ascending order
       * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
       * `null`s appear last.
       * @param options.referencedTable - Set this to order a referenced table by
       * its columns
       * @param options.foreignTable - Deprecated, use `options.referencedTable`
       * instead
       */
      order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {
        const key = referencedTable ? `${referencedTable}.order` : "order";
        const existingOrder = this.url.searchParams.get(key);
        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ""}${column}.${ascending ? "asc" : "desc"}${nullsFirst === void 0 ? "" : nullsFirst ? ".nullsfirst" : ".nullslast"}`);
        return this;
      }
      /**
       * Limit the query result by `count`.
       *
       * @param count - The maximum number of rows to return
       * @param options - Named parameters
       * @param options.referencedTable - Set this to limit rows of referenced
       * tables instead of the parent table
       * @param options.foreignTable - Deprecated, use `options.referencedTable`
       * instead
       */
      limit(count, { foreignTable, referencedTable = foreignTable } = {}) {
        const key = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
        this.url.searchParams.set(key, `${count}`);
        return this;
      }
      /**
       * Limit the query result by starting at an offset `from` and ending at the offset `to`.
       * Only records within this range are returned.
       * This respects the query order and if there is no order clause the range could behave unexpectedly.
       * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
       * and fourth rows of the query.
       *
       * @param from - The starting index from which to limit the result
       * @param to - The last index to which to limit the result
       * @param options - Named parameters
       * @param options.referencedTable - Set this to limit rows of referenced
       * tables instead of the parent table
       * @param options.foreignTable - Deprecated, use `options.referencedTable`
       * instead
       */
      range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {
        const keyOffset = typeof referencedTable === "undefined" ? "offset" : `${referencedTable}.offset`;
        const keyLimit = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
        this.url.searchParams.set(keyOffset, `${from}`);
        this.url.searchParams.set(keyLimit, `${to - from + 1}`);
        return this;
      }
      /**
       * Set the AbortSignal for the fetch request.
       *
       * @param signal - The AbortSignal to use for the fetch request
       */
      abortSignal(signal) {
        this.signal = signal;
        return this;
      }
      /**
       * Return `data` as a single object instead of an array of objects.
       *
       * Query result must be one row (e.g. using `.limit(1)`), otherwise this
       * returns an error.
       */
      single() {
        this.headers["Accept"] = "application/vnd.pgrst.object+json";
        return this;
      }
      /**
       * Return `data` as a single object instead of an array of objects.
       *
       * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
       * this returns an error.
       */
      maybeSingle() {
        if (this.method === "GET") {
          this.headers["Accept"] = "application/json";
        } else {
          this.headers["Accept"] = "application/vnd.pgrst.object+json";
        }
        this.isMaybeSingle = true;
        return this;
      }
      /**
       * Return `data` as a string in CSV format.
       */
      csv() {
        this.headers["Accept"] = "text/csv";
        return this;
      }
      /**
       * Return `data` as an object in [GeoJSON](https://geojson.org) format.
       */
      geojson() {
        this.headers["Accept"] = "application/geo+json";
        return this;
      }
      /**
       * Return `data` as the EXPLAIN plan for the query.
       *
       * You need to enable the
       * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
       * setting before using this method.
       *
       * @param options - Named parameters
       *
       * @param options.analyze - If `true`, the query will be executed and the
       * actual run time will be returned
       *
       * @param options.verbose - If `true`, the query identifier will be returned
       * and `data` will include the output columns of the query
       *
       * @param options.settings - If `true`, include information on configuration
       * parameters that affect query planning
       *
       * @param options.buffers - If `true`, include information on buffer usage
       *
       * @param options.wal - If `true`, include information on WAL record generation
       *
       * @param options.format - The format of the output, can be `"text"` (default)
       * or `"json"`
       */
      explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = "text" } = {}) {
        var _a2;
        const options = [
          analyze ? "analyze" : null,
          verbose ? "verbose" : null,
          settings ? "settings" : null,
          buffers ? "buffers" : null,
          wal ? "wal" : null
        ].filter(Boolean).join("|");
        const forMediatype = (_a2 = this.headers["Accept"]) !== null && _a2 !== void 0 ? _a2 : "application/json";
        this.headers["Accept"] = `application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`;
        if (format === "json")
          return this;
        else
          return this;
      }
      /**
       * Rollback the query.
       *
       * `data` will still be returned, but the query is not committed.
       */
      rollback() {
        var _a2;
        if (((_a2 = this.headers["Prefer"]) !== null && _a2 !== void 0 ? _a2 : "").trim().length > 0) {
          this.headers["Prefer"] += ",tx=rollback";
        } else {
          this.headers["Prefer"] = "tx=rollback";
        }
        return this;
      }
      /**
       * Override the type of the returned `data`.
       *
       * @typeParam NewResult - The new result type to override with
       */
      returns() {
        return this;
      }
    };
    exports.default = PostgrestTransformBuilder2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js
var require_PostgrestFilterBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestTransformBuilder_1 = __importDefault(require_PostgrestTransformBuilder());
    var PostgrestFilterBuilder2 = class extends PostgrestTransformBuilder_1.default {
      /**
       * Match only rows where `column` is equal to `value`.
       *
       * To check if the value of `column` is NULL, you should use `.is()` instead.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      eq(column, value) {
        this.url.searchParams.append(column, `eq.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is not equal to `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      neq(column, value) {
        this.url.searchParams.append(column, `neq.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is greater than `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      gt(column, value) {
        this.url.searchParams.append(column, `gt.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is greater than or equal to `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      gte(column, value) {
        this.url.searchParams.append(column, `gte.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is less than `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      lt(column, value) {
        this.url.searchParams.append(column, `lt.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is less than or equal to `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      lte(column, value) {
        this.url.searchParams.append(column, `lte.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` matches `pattern` case-sensitively.
       *
       * @param column - The column to filter on
       * @param pattern - The pattern to match with
       */
      like(column, pattern) {
        this.url.searchParams.append(column, `like.${pattern}`);
        return this;
      }
      /**
       * Match only rows where `column` matches all of `patterns` case-sensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      likeAllOf(column, patterns) {
        this.url.searchParams.append(column, `like(all).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` matches any of `patterns` case-sensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      likeAnyOf(column, patterns) {
        this.url.searchParams.append(column, `like(any).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` matches `pattern` case-insensitively.
       *
       * @param column - The column to filter on
       * @param pattern - The pattern to match with
       */
      ilike(column, pattern) {
        this.url.searchParams.append(column, `ilike.${pattern}`);
        return this;
      }
      /**
       * Match only rows where `column` matches all of `patterns` case-insensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      ilikeAllOf(column, patterns) {
        this.url.searchParams.append(column, `ilike(all).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` matches any of `patterns` case-insensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      ilikeAnyOf(column, patterns) {
        this.url.searchParams.append(column, `ilike(any).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` IS `value`.
       *
       * For non-boolean columns, this is only relevant for checking if the value of
       * `column` is NULL by setting `value` to `null`.
       *
       * For boolean columns, you can also set `value` to `true` or `false` and it
       * will behave the same way as `.eq()`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      is(column, value) {
        this.url.searchParams.append(column, `is.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is included in the `values` array.
       *
       * @param column - The column to filter on
       * @param values - The values array to filter with
       */
      in(column, values) {
        const cleanedValues = Array.from(new Set(values)).map((s) => {
          if (typeof s === "string" && new RegExp("[,()]").test(s))
            return `"${s}"`;
          else
            return `${s}`;
        }).join(",");
        this.url.searchParams.append(column, `in.(${cleanedValues})`);
        return this;
      }
      /**
       * Only relevant for jsonb, array, and range columns. Match only rows where
       * `column` contains every element appearing in `value`.
       *
       * @param column - The jsonb, array, or range column to filter on
       * @param value - The jsonb, array, or range value to filter with
       */
      contains(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(column, `cs.${value}`);
        } else if (Array.isArray(value)) {
          this.url.searchParams.append(column, `cs.{${value.join(",")}}`);
        } else {
          this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);
        }
        return this;
      }
      /**
       * Only relevant for jsonb, array, and range columns. Match only rows where
       * every element appearing in `column` is contained by `value`.
       *
       * @param column - The jsonb, array, or range column to filter on
       * @param value - The jsonb, array, or range value to filter with
       */
      containedBy(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(column, `cd.${value}`);
        } else if (Array.isArray(value)) {
          this.url.searchParams.append(column, `cd.{${value.join(",")}}`);
        } else {
          this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);
        }
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is greater than any element in `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeGt(column, range) {
        this.url.searchParams.append(column, `sr.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is either contained in `range` or greater than any element in
       * `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeGte(column, range) {
        this.url.searchParams.append(column, `nxl.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is less than any element in `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeLt(column, range) {
        this.url.searchParams.append(column, `sl.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is either contained in `range` or less than any element in
       * `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeLte(column, range) {
        this.url.searchParams.append(column, `nxr.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where `column` is
       * mutually exclusive to `range` and there can be no element between the two
       * ranges.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeAdjacent(column, range) {
        this.url.searchParams.append(column, `adj.${range}`);
        return this;
      }
      /**
       * Only relevant for array and range columns. Match only rows where
       * `column` and `value` have an element in common.
       *
       * @param column - The array or range column to filter on
       * @param value - The array or range value to filter with
       */
      overlaps(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(column, `ov.${value}`);
        } else {
          this.url.searchParams.append(column, `ov.{${value.join(",")}}`);
        }
        return this;
      }
      /**
       * Only relevant for text and tsvector columns. Match only rows where
       * `column` matches the query string in `query`.
       *
       * @param column - The text or tsvector column to filter on
       * @param query - The query text to match with
       * @param options - Named parameters
       * @param options.config - The text search configuration to use
       * @param options.type - Change how the `query` text is interpreted
       */
      textSearch(column, query, { config, type } = {}) {
        let typePart = "";
        if (type === "plain") {
          typePart = "pl";
        } else if (type === "phrase") {
          typePart = "ph";
        } else if (type === "websearch") {
          typePart = "w";
        }
        const configPart = config === void 0 ? "" : `(${config})`;
        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);
        return this;
      }
      /**
       * Match only rows where each column in `query` keys is equal to its
       * associated value. Shorthand for multiple `.eq()`s.
       *
       * @param query - The object to filter with, with column names as keys mapped
       * to their filter values
       */
      match(query) {
        Object.entries(query).forEach(([column, value]) => {
          this.url.searchParams.append(column, `eq.${value}`);
        });
        return this;
      }
      /**
       * Match only rows which doesn't satisfy the filter.
       *
       * Unlike most filters, `opearator` and `value` are used as-is and need to
       * follow [PostgREST
       * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
       * to make sure they are properly sanitized.
       *
       * @param column - The column to filter on
       * @param operator - The operator to be negated to filter with, following
       * PostgREST syntax
       * @param value - The value to filter with, following PostgREST syntax
       */
      not(column, operator, value) {
        this.url.searchParams.append(column, `not.${operator}.${value}`);
        return this;
      }
      /**
       * Match only rows which satisfy at least one of the filters.
       *
       * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
       * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
       * to make sure it's properly sanitized.
       *
       * It's currently not possible to do an `.or()` filter across multiple tables.
       *
       * @param filters - The filters to use, following PostgREST syntax
       * @param options - Named parameters
       * @param options.referencedTable - Set this to filter on referenced tables
       * instead of the parent table
       * @param options.foreignTable - Deprecated, use `referencedTable` instead
       */
      or(filters, { foreignTable, referencedTable = foreignTable } = {}) {
        const key = referencedTable ? `${referencedTable}.or` : "or";
        this.url.searchParams.append(key, `(${filters})`);
        return this;
      }
      /**
       * Match only rows which satisfy the filter. This is an escape hatch - you
       * should use the specific filter methods wherever possible.
       *
       * Unlike most filters, `opearator` and `value` are used as-is and need to
       * follow [PostgREST
       * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
       * to make sure they are properly sanitized.
       *
       * @param column - The column to filter on
       * @param operator - The operator to filter with, following PostgREST syntax
       * @param value - The value to filter with, following PostgREST syntax
       */
      filter(column, operator, value) {
        this.url.searchParams.append(column, `${operator}.${value}`);
        return this;
      }
    };
    exports.default = PostgrestFilterBuilder2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js
var require_PostgrestQueryBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestFilterBuilder_1 = __importDefault(require_PostgrestFilterBuilder());
    var PostgrestQueryBuilder2 = class {
      constructor(url, { headers = {}, schema, fetch: fetch4 }) {
        this.url = url;
        this.headers = headers;
        this.schema = schema;
        this.fetch = fetch4;
      }
      /**
       * Perform a SELECT query on the table or view.
       *
       * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
       *
       * @param options - Named parameters
       *
       * @param options.head - When set to `true`, `data` will not be returned.
       * Useful if you only need the count.
       *
       * @param options.count - Count algorithm to use to count rows in the table or view.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      select(columns, { head: head2 = false, count } = {}) {
        const method = head2 ? "HEAD" : "GET";
        let quoted = false;
        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c) => {
          if (/\s/.test(c) && !quoted) {
            return "";
          }
          if (c === '"') {
            quoted = !quoted;
          }
          return c;
        }).join("");
        this.url.searchParams.set("select", cleanedColumns);
        if (count) {
          this.headers["Prefer"] = `count=${count}`;
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
      /**
       * Perform an INSERT into the table or view.
       *
       * By default, inserted rows are not returned. To return it, chain the call
       * with `.select()`.
       *
       * @param values - The values to insert. Pass an object to insert a single row
       * or an array to insert multiple rows.
       *
       * @param options - Named parameters
       *
       * @param options.count - Count algorithm to use to count inserted rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       *
       * @param options.defaultToNull - Make missing fields default to `null`.
       * Otherwise, use the default value for the column. Only applies for bulk
       * inserts.
       */
      insert(values, { count, defaultToNull = true } = {}) {
        const method = "POST";
        const prefersHeaders = [];
        if (this.headers["Prefer"]) {
          prefersHeaders.push(this.headers["Prefer"]);
        }
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        if (!defaultToNull) {
          prefersHeaders.push("missing=default");
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        if (Array.isArray(values)) {
          const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
          if (columns.length > 0) {
            const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
            this.url.searchParams.set("columns", uniqueColumns.join(","));
          }
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: values,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
      /**
       * Perform an UPSERT on the table or view. Depending on the column(s) passed
       * to `onConflict`, `.upsert()` allows you to perform the equivalent of
       * `.insert()` if a row with the corresponding `onConflict` columns doesn't
       * exist, or if it does exist, perform an alternative action depending on
       * `ignoreDuplicates`.
       *
       * By default, upserted rows are not returned. To return it, chain the call
       * with `.select()`.
       *
       * @param values - The values to upsert with. Pass an object to upsert a
       * single row or an array to upsert multiple rows.
       *
       * @param options - Named parameters
       *
       * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
       * duplicate rows are determined. Two rows are duplicates if all the
       * `onConflict` columns are equal.
       *
       * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
       * `false`, duplicate rows are merged with existing rows.
       *
       * @param options.count - Count algorithm to use to count upserted rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       *
       * @param options.defaultToNull - Make missing fields default to `null`.
       * Otherwise, use the default value for the column. This only applies when
       * inserting new rows, not when merging with existing rows under
       * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
       */
      upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {
        const method = "POST";
        const prefersHeaders = [`resolution=${ignoreDuplicates ? "ignore" : "merge"}-duplicates`];
        if (onConflict !== void 0)
          this.url.searchParams.set("on_conflict", onConflict);
        if (this.headers["Prefer"]) {
          prefersHeaders.push(this.headers["Prefer"]);
        }
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        if (!defaultToNull) {
          prefersHeaders.push("missing=default");
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        if (Array.isArray(values)) {
          const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
          if (columns.length > 0) {
            const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
            this.url.searchParams.set("columns", uniqueColumns.join(","));
          }
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: values,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
      /**
       * Perform an UPDATE on the table or view.
       *
       * By default, updated rows are not returned. To return it, chain the call
       * with `.select()` after filters.
       *
       * @param values - The values to update with
       *
       * @param options - Named parameters
       *
       * @param options.count - Count algorithm to use to count updated rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      update(values, { count } = {}) {
        const method = "PATCH";
        const prefersHeaders = [];
        if (this.headers["Prefer"]) {
          prefersHeaders.push(this.headers["Prefer"]);
        }
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: values,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
      /**
       * Perform a DELETE on the table or view.
       *
       * By default, deleted rows are not returned. To return it, chain the call
       * with `.select()` after filters.
       *
       * @param options - Named parameters
       *
       * @param options.count - Count algorithm to use to count deleted rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      delete({ count } = {}) {
        const method = "DELETE";
        const prefersHeaders = [];
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        if (this.headers["Prefer"]) {
          prefersHeaders.unshift(this.headers["Prefer"]);
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
    };
    exports.default = PostgrestQueryBuilder2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/version.js
var require_version = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "0.0.0-automated";
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/constants.js
var require_constants = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_HEADERS = void 0;
    var version_1 = require_version();
    exports.DEFAULT_HEADERS = { "X-Client-Info": `postgrest-js/${version_1.version}` };
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js
var require_PostgrestClient = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestQueryBuilder_1 = __importDefault(require_PostgrestQueryBuilder());
    var PostgrestFilterBuilder_1 = __importDefault(require_PostgrestFilterBuilder());
    var constants_1 = require_constants();
    var PostgrestClient2 = class {
      // TODO: Add back shouldThrowOnError once we figure out the typings
      /**
       * Creates a PostgREST client.
       *
       * @param url - URL of the PostgREST endpoint
       * @param options - Named parameters
       * @param options.headers - Custom headers
       * @param options.schema - Postgres schema to switch to
       * @param options.fetch - Custom fetch
       */
      constructor(url, { headers = {}, schema, fetch: fetch4 } = {}) {
        this.url = url;
        this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);
        this.schemaName = schema;
        this.fetch = fetch4;
      }
      /**
       * Perform a query on a table or a view.
       *
       * @param relation - The table or view name to query
       */
      from(relation) {
        const url = new URL(`${this.url}/${relation}`);
        return new PostgrestQueryBuilder_1.default(url, {
          headers: Object.assign({}, this.headers),
          schema: this.schemaName,
          fetch: this.fetch
        });
      }
      /**
       * Select a schema to query or perform an function (rpc) call.
       *
       * The schema needs to be on the list of exposed schemas inside Supabase.
       *
       * @param schema - The schema to query
       */
      schema(schema) {
        return new PostgrestClient2(this.url, {
          headers: this.headers,
          schema,
          fetch: this.fetch
        });
      }
      /**
       * Perform a function call.
       *
       * @param fn - The function name to call
       * @param args - The arguments to pass to the function call
       * @param options - Named parameters
       * @param options.head - When set to `true`, `data` will not be returned.
       * Useful if you only need the count.
       * @param options.get - When set to `true`, the function will be called with
       * read-only access mode.
       * @param options.count - Count algorithm to use to count rows returned by the
       * function. Only applicable for [set-returning
       * functions](https://www.postgresql.org/docs/current/functions-srf.html).
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      rpc(fn, args = {}, { head: head2 = false, get: get2 = false, count } = {}) {
        let method;
        const url = new URL(`${this.url}/rpc/${fn}`);
        let body;
        if (head2 || get2) {
          method = head2 ? "HEAD" : "GET";
          Object.entries(args).filter(([_, value]) => value !== void 0).map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(",")}}` : `${value}`]).forEach(([name, value]) => {
            url.searchParams.append(name, value);
          });
        } else {
          method = "POST";
          body = args;
        }
        const headers = Object.assign({}, this.headers);
        if (count) {
          headers["Prefer"] = `count=${count}`;
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url,
          headers,
          schema: this.schemaName,
          body,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
    };
    exports.default = PostgrestClient2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PostgrestError = exports.PostgrestBuilder = exports.PostgrestTransformBuilder = exports.PostgrestFilterBuilder = exports.PostgrestQueryBuilder = exports.PostgrestClient = void 0;
    var PostgrestClient_1 = __importDefault(require_PostgrestClient());
    exports.PostgrestClient = PostgrestClient_1.default;
    var PostgrestQueryBuilder_1 = __importDefault(require_PostgrestQueryBuilder());
    exports.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;
    var PostgrestFilterBuilder_1 = __importDefault(require_PostgrestFilterBuilder());
    exports.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;
    var PostgrestTransformBuilder_1 = __importDefault(require_PostgrestTransformBuilder());
    exports.PostgrestTransformBuilder = PostgrestTransformBuilder_1.default;
    var PostgrestBuilder_1 = __importDefault(require_PostgrestBuilder());
    exports.PostgrestBuilder = PostgrestBuilder_1.default;
    var PostgrestError_1 = __importDefault(require_PostgrestError());
    exports.PostgrestError = PostgrestError_1.default;
    exports.default = {
      PostgrestClient: PostgrestClient_1.default,
      PostgrestQueryBuilder: PostgrestQueryBuilder_1.default,
      PostgrestFilterBuilder: PostgrestFilterBuilder_1.default,
      PostgrestTransformBuilder: PostgrestTransformBuilder_1.default,
      PostgrestBuilder: PostgrestBuilder_1.default,
      PostgrestError: PostgrestError_1.default
    };
  }
});

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MindMatrixPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian12 = require("obsidian");

// node_modules/@supabase/functions-js/dist/module/helper.js
var resolveFetch = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => Promise.resolve().then(() => (init_browser(), browser_exports)).then(({ default: fetch4 }) => fetch4(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};

// node_modules/@supabase/functions-js/dist/module/types.js
var FunctionsError = class extends Error {
  constructor(message, name = "FunctionsError", context) {
    super(message);
    this.name = name;
    this.context = context;
  }
};
var FunctionsFetchError = class extends FunctionsError {
  constructor(context) {
    super("Failed to send a request to the Edge Function", "FunctionsFetchError", context);
  }
};
var FunctionsRelayError = class extends FunctionsError {
  constructor(context) {
    super("Relay Error invoking the Edge Function", "FunctionsRelayError", context);
  }
};
var FunctionsHttpError = class extends FunctionsError {
  constructor(context) {
    super("Edge Function returned a non-2xx status code", "FunctionsHttpError", context);
  }
};
var FunctionRegion;
(function(FunctionRegion2) {
  FunctionRegion2["Any"] = "any";
  FunctionRegion2["ApNortheast1"] = "ap-northeast-1";
  FunctionRegion2["ApNortheast2"] = "ap-northeast-2";
  FunctionRegion2["ApSouth1"] = "ap-south-1";
  FunctionRegion2["ApSoutheast1"] = "ap-southeast-1";
  FunctionRegion2["ApSoutheast2"] = "ap-southeast-2";
  FunctionRegion2["CaCentral1"] = "ca-central-1";
  FunctionRegion2["EuCentral1"] = "eu-central-1";
  FunctionRegion2["EuWest1"] = "eu-west-1";
  FunctionRegion2["EuWest2"] = "eu-west-2";
  FunctionRegion2["EuWest3"] = "eu-west-3";
  FunctionRegion2["SaEast1"] = "sa-east-1";
  FunctionRegion2["UsEast1"] = "us-east-1";
  FunctionRegion2["UsWest1"] = "us-west-1";
  FunctionRegion2["UsWest2"] = "us-west-2";
})(FunctionRegion || (FunctionRegion = {}));

// node_modules/@supabase/functions-js/dist/module/FunctionsClient.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FunctionsClient = class {
  constructor(url, { headers = {}, customFetch, region = FunctionRegion.Any } = {}) {
    this.url = url;
    this.headers = headers;
    this.region = region;
    this.fetch = resolveFetch(customFetch);
  }
  /**
   * Updates the authorization header
   * @param token - the new jwt token sent in the authorisation header
   */
  setAuth(token) {
    this.headers.Authorization = `Bearer ${token}`;
  }
  /**
   * Invokes a function
   * @param functionName - The name of the Function to invoke.
   * @param options - Options for invoking the Function.
   */
  invoke(functionName, options = {}) {
    var _a2;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const { headers, method, body: functionArgs } = options;
        let _headers = {};
        let { region } = options;
        if (!region) {
          region = this.region;
        }
        if (region && region !== "any") {
          _headers["x-region"] = region;
        }
        let body;
        if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, "Content-Type") || !headers)) {
          if (typeof Blob !== "undefined" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
            _headers["Content-Type"] = "application/octet-stream";
            body = functionArgs;
          } else if (typeof functionArgs === "string") {
            _headers["Content-Type"] = "text/plain";
            body = functionArgs;
          } else if (typeof FormData !== "undefined" && functionArgs instanceof FormData) {
            body = functionArgs;
          } else {
            _headers["Content-Type"] = "application/json";
            body = JSON.stringify(functionArgs);
          }
        }
        const response = yield this.fetch(`${this.url}/${functionName}`, {
          method: method || "POST",
          // headers priority is (high to low):
          // 1. invoke-level headers
          // 2. client-level headers
          // 3. default Content-Type header
          headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),
          body
        }).catch((fetchError) => {
          throw new FunctionsFetchError(fetchError);
        });
        const isRelayError = response.headers.get("x-relay-error");
        if (isRelayError && isRelayError === "true") {
          throw new FunctionsRelayError(response);
        }
        if (!response.ok) {
          throw new FunctionsHttpError(response);
        }
        let responseType = ((_a2 = response.headers.get("Content-Type")) !== null && _a2 !== void 0 ? _a2 : "text/plain").split(";")[0].trim();
        let data;
        if (responseType === "application/json") {
          data = yield response.json();
        } else if (responseType === "application/octet-stream") {
          data = yield response.blob();
        } else if (responseType === "text/event-stream") {
          data = response;
        } else if (responseType === "multipart/form-data") {
          data = yield response.formData();
        } else {
          data = yield response.text();
        }
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    });
  }
};

// node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs
var import_cjs = __toESM(require_cjs(), 1);
var {
  PostgrestClient,
  PostgrestQueryBuilder,
  PostgrestFilterBuilder,
  PostgrestTransformBuilder,
  PostgrestBuilder,
  PostgrestError
} = import_cjs.default;

// node_modules/@supabase/realtime-js/dist/module/lib/version.js
var version = "2.11.2";

// node_modules/@supabase/realtime-js/dist/module/lib/constants.js
var DEFAULT_HEADERS = { "X-Client-Info": `realtime-js/${version}` };
var VSN = "1.0.0";
var DEFAULT_TIMEOUT = 1e4;
var WS_CLOSE_NORMAL = 1e3;
var SOCKET_STATES;
(function(SOCKET_STATES2) {
  SOCKET_STATES2[SOCKET_STATES2["connecting"] = 0] = "connecting";
  SOCKET_STATES2[SOCKET_STATES2["open"] = 1] = "open";
  SOCKET_STATES2[SOCKET_STATES2["closing"] = 2] = "closing";
  SOCKET_STATES2[SOCKET_STATES2["closed"] = 3] = "closed";
})(SOCKET_STATES || (SOCKET_STATES = {}));
var CHANNEL_STATES;
(function(CHANNEL_STATES2) {
  CHANNEL_STATES2["closed"] = "closed";
  CHANNEL_STATES2["errored"] = "errored";
  CHANNEL_STATES2["joined"] = "joined";
  CHANNEL_STATES2["joining"] = "joining";
  CHANNEL_STATES2["leaving"] = "leaving";
})(CHANNEL_STATES || (CHANNEL_STATES = {}));
var CHANNEL_EVENTS;
(function(CHANNEL_EVENTS2) {
  CHANNEL_EVENTS2["close"] = "phx_close";
  CHANNEL_EVENTS2["error"] = "phx_error";
  CHANNEL_EVENTS2["join"] = "phx_join";
  CHANNEL_EVENTS2["reply"] = "phx_reply";
  CHANNEL_EVENTS2["leave"] = "phx_leave";
  CHANNEL_EVENTS2["access_token"] = "access_token";
})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));
var TRANSPORTS;
(function(TRANSPORTS2) {
  TRANSPORTS2["websocket"] = "websocket";
})(TRANSPORTS || (TRANSPORTS = {}));
var CONNECTION_STATE;
(function(CONNECTION_STATE2) {
  CONNECTION_STATE2["Connecting"] = "connecting";
  CONNECTION_STATE2["Open"] = "open";
  CONNECTION_STATE2["Closing"] = "closing";
  CONNECTION_STATE2["Closed"] = "closed";
})(CONNECTION_STATE || (CONNECTION_STATE = {}));

// node_modules/@supabase/realtime-js/dist/module/lib/serializer.js
var Serializer = class {
  constructor() {
    this.HEADER_LENGTH = 1;
  }
  decode(rawPayload, callback) {
    if (rawPayload.constructor === ArrayBuffer) {
      return callback(this._binaryDecode(rawPayload));
    }
    if (typeof rawPayload === "string") {
      return callback(JSON.parse(rawPayload));
    }
    return callback({});
  }
  _binaryDecode(buffer) {
    const view = new DataView(buffer);
    const decoder = new TextDecoder();
    return this._decodeBroadcast(buffer, view, decoder);
  }
  _decodeBroadcast(buffer, view, decoder) {
    const topicSize = view.getUint8(1);
    const eventSize = view.getUint8(2);
    let offset = this.HEADER_LENGTH + 2;
    const topic = decoder.decode(buffer.slice(offset, offset + topicSize));
    offset = offset + topicSize;
    const event = decoder.decode(buffer.slice(offset, offset + eventSize));
    offset = offset + eventSize;
    const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));
    return { ref: null, topic, event, payload: data };
  }
};

// node_modules/@supabase/realtime-js/dist/module/lib/timer.js
var Timer = class {
  constructor(callback, timerCalc) {
    this.callback = callback;
    this.timerCalc = timerCalc;
    this.timer = void 0;
    this.tries = 0;
    this.callback = callback;
    this.timerCalc = timerCalc;
  }
  reset() {
    this.tries = 0;
    clearTimeout(this.timer);
  }
  // Cancels any previous scheduleTimeout and schedules callback
  scheduleTimeout() {
    clearTimeout(this.timer);
    this.timer = setTimeout(() => {
      this.tries = this.tries + 1;
      this.callback();
    }, this.timerCalc(this.tries + 1));
  }
};

// node_modules/@supabase/realtime-js/dist/module/lib/transformers.js
var PostgresTypes;
(function(PostgresTypes2) {
  PostgresTypes2["abstime"] = "abstime";
  PostgresTypes2["bool"] = "bool";
  PostgresTypes2["date"] = "date";
  PostgresTypes2["daterange"] = "daterange";
  PostgresTypes2["float4"] = "float4";
  PostgresTypes2["float8"] = "float8";
  PostgresTypes2["int2"] = "int2";
  PostgresTypes2["int4"] = "int4";
  PostgresTypes2["int4range"] = "int4range";
  PostgresTypes2["int8"] = "int8";
  PostgresTypes2["int8range"] = "int8range";
  PostgresTypes2["json"] = "json";
  PostgresTypes2["jsonb"] = "jsonb";
  PostgresTypes2["money"] = "money";
  PostgresTypes2["numeric"] = "numeric";
  PostgresTypes2["oid"] = "oid";
  PostgresTypes2["reltime"] = "reltime";
  PostgresTypes2["text"] = "text";
  PostgresTypes2["time"] = "time";
  PostgresTypes2["timestamp"] = "timestamp";
  PostgresTypes2["timestamptz"] = "timestamptz";
  PostgresTypes2["timetz"] = "timetz";
  PostgresTypes2["tsrange"] = "tsrange";
  PostgresTypes2["tstzrange"] = "tstzrange";
})(PostgresTypes || (PostgresTypes = {}));
var convertChangeData = (columns, record, options = {}) => {
  var _a2;
  const skipTypes = (_a2 = options.skipTypes) !== null && _a2 !== void 0 ? _a2 : [];
  return Object.keys(record).reduce((acc, rec_key) => {
    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
    return acc;
  }, {});
};
var convertColumn = (columnName, columns, record, skipTypes) => {
  const column = columns.find((x) => x.name === columnName);
  const colType = column === null || column === void 0 ? void 0 : column.type;
  const value = record[columnName];
  if (colType && !skipTypes.includes(colType)) {
    return convertCell(colType, value);
  }
  return noop(value);
};
var convertCell = (type, value) => {
  if (type.charAt(0) === "_") {
    const dataType = type.slice(1, type.length);
    return toArray(value, dataType);
  }
  switch (type) {
    case PostgresTypes.bool:
      return toBoolean(value);
    case PostgresTypes.float4:
    case PostgresTypes.float8:
    case PostgresTypes.int2:
    case PostgresTypes.int4:
    case PostgresTypes.int8:
    case PostgresTypes.numeric:
    case PostgresTypes.oid:
      return toNumber(value);
    case PostgresTypes.json:
    case PostgresTypes.jsonb:
      return toJson(value);
    case PostgresTypes.timestamp:
      return toTimestampString(value);
    case PostgresTypes.abstime:
    case PostgresTypes.date:
    case PostgresTypes.daterange:
    case PostgresTypes.int4range:
    case PostgresTypes.int8range:
    case PostgresTypes.money:
    case PostgresTypes.reltime:
    case PostgresTypes.text:
    case PostgresTypes.time:
    case PostgresTypes.timestamptz:
    case PostgresTypes.timetz:
    case PostgresTypes.tsrange:
    case PostgresTypes.tstzrange:
      return noop(value);
    default:
      return noop(value);
  }
};
var noop = (value) => {
  return value;
};
var toBoolean = (value) => {
  switch (value) {
    case "t":
      return true;
    case "f":
      return false;
    default:
      return value;
  }
};
var toNumber = (value) => {
  if (typeof value === "string") {
    const parsedValue = parseFloat(value);
    if (!Number.isNaN(parsedValue)) {
      return parsedValue;
    }
  }
  return value;
};
var toJson = (value) => {
  if (typeof value === "string") {
    try {
      return JSON.parse(value);
    } catch (error) {
      console.log(`JSON parse error: ${error}`);
      return value;
    }
  }
  return value;
};
var toArray = (value, type) => {
  if (typeof value !== "string") {
    return value;
  }
  const lastIdx = value.length - 1;
  const closeBrace = value[lastIdx];
  const openBrace = value[0];
  if (openBrace === "{" && closeBrace === "}") {
    let arr;
    const valTrim = value.slice(1, lastIdx);
    try {
      arr = JSON.parse("[" + valTrim + "]");
    } catch (_) {
      arr = valTrim ? valTrim.split(",") : [];
    }
    return arr.map((val) => convertCell(type, val));
  }
  return value;
};
var toTimestampString = (value) => {
  if (typeof value === "string") {
    return value.replace(" ", "T");
  }
  return value;
};
var httpEndpointURL = (socketUrl) => {
  let url = socketUrl;
  url = url.replace(/^ws/i, "http");
  url = url.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, "");
  return url.replace(/\/+$/, "");
};

// node_modules/@supabase/realtime-js/dist/module/lib/push.js
var Push = class {
  /**
   * Initializes the Push
   *
   * @param channel The Channel
   * @param event The event, for example `"phx_join"`
   * @param payload The payload, for example `{user_id: 123}`
   * @param timeout The push timeout in milliseconds
   */
  constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {
    this.channel = channel;
    this.event = event;
    this.payload = payload;
    this.timeout = timeout;
    this.sent = false;
    this.timeoutTimer = void 0;
    this.ref = "";
    this.receivedResp = null;
    this.recHooks = [];
    this.refEvent = null;
  }
  resend(timeout) {
    this.timeout = timeout;
    this._cancelRefEvent();
    this.ref = "";
    this.refEvent = null;
    this.receivedResp = null;
    this.sent = false;
    this.send();
  }
  send() {
    if (this._hasReceived("timeout")) {
      return;
    }
    this.startTimeout();
    this.sent = true;
    this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload,
      ref: this.ref,
      join_ref: this.channel._joinRef()
    });
  }
  updatePayload(payload) {
    this.payload = Object.assign(Object.assign({}, this.payload), payload);
  }
  receive(status, callback) {
    var _a2;
    if (this._hasReceived(status)) {
      callback((_a2 = this.receivedResp) === null || _a2 === void 0 ? void 0 : _a2.response);
    }
    this.recHooks.push({ status, callback });
    return this;
  }
  startTimeout() {
    if (this.timeoutTimer) {
      return;
    }
    this.ref = this.channel.socket._makeRef();
    this.refEvent = this.channel._replyEventName(this.ref);
    const callback = (payload) => {
      this._cancelRefEvent();
      this._cancelTimeout();
      this.receivedResp = payload;
      this._matchReceive(payload);
    };
    this.channel._on(this.refEvent, {}, callback);
    this.timeoutTimer = setTimeout(() => {
      this.trigger("timeout", {});
    }, this.timeout);
  }
  trigger(status, response) {
    if (this.refEvent)
      this.channel._trigger(this.refEvent, { status, response });
  }
  destroy() {
    this._cancelRefEvent();
    this._cancelTimeout();
  }
  _cancelRefEvent() {
    if (!this.refEvent) {
      return;
    }
    this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer);
    this.timeoutTimer = void 0;
  }
  _matchReceive({ status, response }) {
    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
  }
  _hasReceived(status) {
    return this.receivedResp && this.receivedResp.status === status;
  }
};

// node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js
var REALTIME_PRESENCE_LISTEN_EVENTS;
(function(REALTIME_PRESENCE_LISTEN_EVENTS2) {
  REALTIME_PRESENCE_LISTEN_EVENTS2["SYNC"] = "sync";
  REALTIME_PRESENCE_LISTEN_EVENTS2["JOIN"] = "join";
  REALTIME_PRESENCE_LISTEN_EVENTS2["LEAVE"] = "leave";
})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));
var RealtimePresence = class {
  /**
   * Initializes the Presence.
   *
   * @param channel - The RealtimeChannel
   * @param opts - The options,
   *        for example `{events: {state: 'state', diff: 'diff'}}`
   */
  constructor(channel, opts) {
    this.channel = channel;
    this.state = {};
    this.pendingDiffs = [];
    this.joinRef = null;
    this.caller = {
      onJoin: () => {
      },
      onLeave: () => {
      },
      onSync: () => {
      }
    };
    const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {
      state: "presence_state",
      diff: "presence_diff"
    };
    this.channel._on(events.state, {}, (newState) => {
      const { onJoin, onLeave, onSync } = this.caller;
      this.joinRef = this.channel._joinRef();
      this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);
      this.pendingDiffs.forEach((diff) => {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
      });
      this.pendingDiffs = [];
      onSync();
    });
    this.channel._on(events.diff, {}, (diff) => {
      const { onJoin, onLeave, onSync } = this.caller;
      if (this.inPendingSyncState()) {
        this.pendingDiffs.push(diff);
      } else {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
        onSync();
      }
    });
    this.onJoin((key, currentPresences, newPresences) => {
      this.channel._trigger("presence", {
        event: "join",
        key,
        currentPresences,
        newPresences
      });
    });
    this.onLeave((key, currentPresences, leftPresences) => {
      this.channel._trigger("presence", {
        event: "leave",
        key,
        currentPresences,
        leftPresences
      });
    });
    this.onSync(() => {
      this.channel._trigger("presence", { event: "sync" });
    });
  }
  /**
   * Used to sync the list of presences on the server with the
   * client's state.
   *
   * An optional `onJoin` and `onLeave` callback can be provided to
   * react to changes in the client's local presences across
   * disconnects and reconnects with the server.
   *
   * @internal
   */
  static syncState(currentState, newState, onJoin, onLeave) {
    const state = this.cloneDeep(currentState);
    const transformedState = this.transformState(newState);
    const joins = {};
    const leaves = {};
    this.map(state, (key, presences) => {
      if (!transformedState[key]) {
        leaves[key] = presences;
      }
    });
    this.map(transformedState, (key, newPresences) => {
      const currentPresences = state[key];
      if (currentPresences) {
        const newPresenceRefs = newPresences.map((m) => m.presence_ref);
        const curPresenceRefs = currentPresences.map((m) => m.presence_ref);
        const joinedPresences = newPresences.filter((m) => curPresenceRefs.indexOf(m.presence_ref) < 0);
        const leftPresences = currentPresences.filter((m) => newPresenceRefs.indexOf(m.presence_ref) < 0);
        if (joinedPresences.length > 0) {
          joins[key] = joinedPresences;
        }
        if (leftPresences.length > 0) {
          leaves[key] = leftPresences;
        }
      } else {
        joins[key] = newPresences;
      }
    });
    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);
  }
  /**
   * Used to sync a diff of presence join and leave events from the
   * server, as they happen.
   *
   * Like `syncState`, `syncDiff` accepts optional `onJoin` and
   * `onLeave` callbacks to react to a user joining or leaving from a
   * device.
   *
   * @internal
   */
  static syncDiff(state, diff, onJoin, onLeave) {
    const { joins, leaves } = {
      joins: this.transformState(diff.joins),
      leaves: this.transformState(diff.leaves)
    };
    if (!onJoin) {
      onJoin = () => {
      };
    }
    if (!onLeave) {
      onLeave = () => {
      };
    }
    this.map(joins, (key, newPresences) => {
      var _a2;
      const currentPresences = (_a2 = state[key]) !== null && _a2 !== void 0 ? _a2 : [];
      state[key] = this.cloneDeep(newPresences);
      if (currentPresences.length > 0) {
        const joinedPresenceRefs = state[key].map((m) => m.presence_ref);
        const curPresences = currentPresences.filter((m) => joinedPresenceRefs.indexOf(m.presence_ref) < 0);
        state[key].unshift(...curPresences);
      }
      onJoin(key, currentPresences, newPresences);
    });
    this.map(leaves, (key, leftPresences) => {
      let currentPresences = state[key];
      if (!currentPresences)
        return;
      const presenceRefsToRemove = leftPresences.map((m) => m.presence_ref);
      currentPresences = currentPresences.filter((m) => presenceRefsToRemove.indexOf(m.presence_ref) < 0);
      state[key] = currentPresences;
      onLeave(key, currentPresences, leftPresences);
      if (currentPresences.length === 0)
        delete state[key];
    });
    return state;
  }
  /** @internal */
  static map(obj, func) {
    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));
  }
  /**
   * Remove 'metas' key
   * Change 'phx_ref' to 'presence_ref'
   * Remove 'phx_ref' and 'phx_ref_prev'
   *
   * @example
   * // returns {
   *  abc123: [
   *    { presence_ref: '2', user_id: 1 },
   *    { presence_ref: '3', user_id: 2 }
   *  ]
   * }
   * RealtimePresence.transformState({
   *  abc123: {
   *    metas: [
   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
   *      { phx_ref: '3', user_id: 2 }
   *    ]
   *  }
   * })
   *
   * @internal
   */
  static transformState(state) {
    state = this.cloneDeep(state);
    return Object.getOwnPropertyNames(state).reduce((newState, key) => {
      const presences = state[key];
      if ("metas" in presences) {
        newState[key] = presences.metas.map((presence) => {
          presence["presence_ref"] = presence["phx_ref"];
          delete presence["phx_ref"];
          delete presence["phx_ref_prev"];
          return presence;
        });
      } else {
        newState[key] = presences;
      }
      return newState;
    }, {});
  }
  /** @internal */
  static cloneDeep(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  /** @internal */
  onJoin(callback) {
    this.caller.onJoin = callback;
  }
  /** @internal */
  onLeave(callback) {
    this.caller.onLeave = callback;
  }
  /** @internal */
  onSync(callback) {
    this.caller.onSync = callback;
  }
  /** @internal */
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
};

// node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js
var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2) {
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["ALL"] = "*";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["INSERT"] = "INSERT";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["UPDATE"] = "UPDATE";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["DELETE"] = "DELETE";
})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
var REALTIME_LISTEN_TYPES;
(function(REALTIME_LISTEN_TYPES2) {
  REALTIME_LISTEN_TYPES2["BROADCAST"] = "broadcast";
  REALTIME_LISTEN_TYPES2["PRESENCE"] = "presence";
  REALTIME_LISTEN_TYPES2["POSTGRES_CHANGES"] = "postgres_changes";
  REALTIME_LISTEN_TYPES2["SYSTEM"] = "system";
})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));
var REALTIME_SUBSCRIBE_STATES;
(function(REALTIME_SUBSCRIBE_STATES2) {
  REALTIME_SUBSCRIBE_STATES2["SUBSCRIBED"] = "SUBSCRIBED";
  REALTIME_SUBSCRIBE_STATES2["TIMED_OUT"] = "TIMED_OUT";
  REALTIME_SUBSCRIBE_STATES2["CLOSED"] = "CLOSED";
  REALTIME_SUBSCRIBE_STATES2["CHANNEL_ERROR"] = "CHANNEL_ERROR";
})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));
var RealtimeChannel = class {
  constructor(topic, params = { config: {} }, socket) {
    this.topic = topic;
    this.params = params;
    this.socket = socket;
    this.bindings = {};
    this.state = CHANNEL_STATES.closed;
    this.joinedOnce = false;
    this.pushBuffer = [];
    this.subTopic = topic.replace(/^realtime:/i, "");
    this.params.config = Object.assign({
      broadcast: { ack: false, self: false },
      presence: { key: "" },
      private: false
    }, params.config);
    this.timeout = this.socket.timeout;
    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
    this.joinPush.receive("ok", () => {
      this.state = CHANNEL_STATES.joined;
      this.rejoinTimer.reset();
      this.pushBuffer.forEach((pushEvent) => pushEvent.send());
      this.pushBuffer = [];
    });
    this._onClose(() => {
      this.rejoinTimer.reset();
      this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`);
      this.state = CHANNEL_STATES.closed;
      this.socket._remove(this);
    });
    this._onError((reason) => {
      if (this._isLeaving() || this._isClosed()) {
        return;
      }
      this.socket.log("channel", `error ${this.topic}`, reason);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this.joinPush.receive("timeout", () => {
      if (!this._isJoining()) {
        return;
      }
      this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {
      this._trigger(this._replyEventName(ref), payload);
    });
    this.presence = new RealtimePresence(this);
    this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint) + "/api/broadcast";
    this.private = this.params.config.private || false;
  }
  /** Subscribe registers your client with the server */
  subscribe(callback, timeout = this.timeout) {
    var _a2, _b;
    if (!this.socket.isConnected()) {
      this.socket.connect();
    }
    if (this.joinedOnce) {
      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;
    } else {
      const { config: { broadcast, presence, private: isPrivate } } = this.params;
      this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));
      this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));
      const accessTokenPayload = {};
      const config = {
        broadcast,
        presence,
        postgres_changes: (_b = (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [],
        private: isPrivate
      };
      if (this.socket.accessTokenValue) {
        accessTokenPayload.access_token = this.socket.accessTokenValue;
      }
      this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));
      this.joinedOnce = true;
      this._rejoin(timeout);
      this.joinPush.receive("ok", async ({ postgres_changes }) => {
        var _a3;
        this.socket.setAuth();
        if (postgres_changes === void 0) {
          callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          return;
        } else {
          const clientPostgresBindings = this.bindings.postgres_changes;
          const bindingsLen = (_a3 = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a3 !== void 0 ? _a3 : 0;
          const newPostgresBindings = [];
          for (let i = 0; i < bindingsLen; i++) {
            const clientPostgresBinding = clientPostgresBindings[i];
            const { filter: { event, schema, table, filter } } = clientPostgresBinding;
            const serverPostgresFilter = postgres_changes && postgres_changes[i];
            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {
              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));
            } else {
              this.unsubscribe();
              callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
              return;
            }
          }
          this.bindings.postgres_changes = newPostgresBindings;
          callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          return;
        }
      }).receive("error", (error) => {
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(", ") || "error")));
        return;
      }).receive("timeout", () => {
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);
        return;
      });
    }
    return this;
  }
  presenceState() {
    return this.presence.state;
  }
  async track(payload, opts = {}) {
    return await this.send({
      type: "presence",
      event: "track",
      payload
    }, opts.timeout || this.timeout);
  }
  async untrack(opts = {}) {
    return await this.send({
      type: "presence",
      event: "untrack"
    }, opts);
  }
  on(type, filter, callback) {
    return this._on(type, filter, callback);
  }
  /**
   * Sends a message into the channel.
   *
   * @param args Arguments to send to channel
   * @param args.type The type of event to send
   * @param args.event The name of the event being sent
   * @param args.payload Payload to be sent
   * @param opts Options to be used during the send process
   */
  async send(args, opts = {}) {
    var _a2, _b;
    if (!this._canPush() && args.type === "broadcast") {
      const { event, payload: endpoint_payload } = args;
      const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
      const options = {
        method: "POST",
        headers: {
          Authorization: authorization,
          apikey: this.socket.apiKey ? this.socket.apiKey : "",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: [
            {
              topic: this.subTopic,
              event,
              payload: endpoint_payload,
              private: this.private
            }
          ]
        })
      };
      try {
        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a2 = opts.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout);
        await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());
        return response.ok ? "ok" : "error";
      } catch (error) {
        if (error.name === "AbortError") {
          return "timed out";
        } else {
          return "error";
        }
      }
    } else {
      return new Promise((resolve) => {
        var _a3, _b2, _c;
        const push2 = this._push(args.type, args, opts.timeout || this.timeout);
        if (args.type === "broadcast" && !((_c = (_b2 = (_a3 = this.params) === null || _a3 === void 0 ? void 0 : _a3.config) === null || _b2 === void 0 ? void 0 : _b2.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {
          resolve("ok");
        }
        push2.receive("ok", () => resolve("ok"));
        push2.receive("error", () => resolve("error"));
        push2.receive("timeout", () => resolve("timed out"));
      });
    }
  }
  updateJoinPayload(payload) {
    this.joinPush.updatePayload(payload);
  }
  /**
   * Leaves the channel.
   *
   * Unsubscribes from server events, and instructs channel to terminate on server.
   * Triggers onClose() hooks.
   *
   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
   * channel.unsubscribe().receive("ok", () => alert("left!") )
   */
  unsubscribe(timeout = this.timeout) {
    this.state = CHANNEL_STATES.leaving;
    const onClose = () => {
      this.socket.log("channel", `leave ${this.topic}`);
      this._trigger(CHANNEL_EVENTS.close, "leave", this._joinRef());
    };
    this.rejoinTimer.reset();
    this.joinPush.destroy();
    return new Promise((resolve) => {
      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);
      leavePush.receive("ok", () => {
        onClose();
        resolve("ok");
      }).receive("timeout", () => {
        onClose();
        resolve("timed out");
      }).receive("error", () => {
        resolve("error");
      });
      leavePush.send();
      if (!this._canPush()) {
        leavePush.trigger("ok", {});
      }
    });
  }
  /** @internal */
  async _fetchWithTimeout(url, options, timeout) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));
    clearTimeout(id);
    return response;
  }
  /** @internal */
  _push(event, payload, timeout = this.timeout) {
    if (!this.joinedOnce) {
      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    }
    let pushEvent = new Push(this, event, payload, timeout);
    if (this._canPush()) {
      pushEvent.send();
    } else {
      pushEvent.startTimeout();
      this.pushBuffer.push(pushEvent);
    }
    return pushEvent;
  }
  /**
   * Overridable message hook
   *
   * Receives all events for specialized message handling before dispatching to the channel callbacks.
   * Must return the payload, modified or unmodified.
   *
   * @internal
   */
  _onMessage(_event, payload, _ref) {
    return payload;
  }
  /** @internal */
  _isMember(topic) {
    return this.topic === topic;
  }
  /** @internal */
  _joinRef() {
    return this.joinPush.ref;
  }
  /** @internal */
  _trigger(type, payload, ref) {
    var _a2, _b;
    const typeLower = type.toLocaleLowerCase();
    const { close, error, leave, join } = CHANNEL_EVENTS;
    const events = [close, error, leave, join];
    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
      return;
    }
    let handledPayload = this._onMessage(typeLower, payload, ref);
    if (payload && !handledPayload) {
      throw "channel onMessage callbacks must return the payload, modified or unmodified";
    }
    if (["insert", "update", "delete"].includes(typeLower)) {
      (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.filter((bind) => {
        var _a3, _b2, _c;
        return ((_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event) === "*" || ((_c = (_b2 = bind.filter) === null || _b2 === void 0 ? void 0 : _b2.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
      }).map((bind) => bind.callback(handledPayload, ref));
    } else {
      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {
        var _a3, _b2, _c, _d, _e, _f;
        if (["broadcast", "presence", "postgres_changes"].includes(typeLower)) {
          if ("id" in bind) {
            const bindId = bind.id;
            const bindEvent = (_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event;
            return bindId && ((_b2 = payload.ids) === null || _b2 === void 0 ? void 0 : _b2.includes(bindId)) && (bindEvent === "*" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));
          } else {
            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();
            return bindEvent === "*" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());
          }
        } else {
          return bind.type.toLocaleLowerCase() === typeLower;
        }
      }).map((bind) => {
        if (typeof handledPayload === "object" && "ids" in handledPayload) {
          const postgresChanges = handledPayload.data;
          const { schema, table, commit_timestamp, type: type2, errors } = postgresChanges;
          const enrichedPayload = {
            schema,
            table,
            commit_timestamp,
            eventType: type2,
            new: {},
            old: {},
            errors
          };
          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));
        }
        bind.callback(handledPayload, ref);
      });
    }
  }
  /** @internal */
  _isClosed() {
    return this.state === CHANNEL_STATES.closed;
  }
  /** @internal */
  _isJoined() {
    return this.state === CHANNEL_STATES.joined;
  }
  /** @internal */
  _isJoining() {
    return this.state === CHANNEL_STATES.joining;
  }
  /** @internal */
  _isLeaving() {
    return this.state === CHANNEL_STATES.leaving;
  }
  /** @internal */
  _replyEventName(ref) {
    return `chan_reply_${ref}`;
  }
  /** @internal */
  _on(type, filter, callback) {
    const typeLower = type.toLocaleLowerCase();
    const binding = {
      type: typeLower,
      filter,
      callback
    };
    if (this.bindings[typeLower]) {
      this.bindings[typeLower].push(binding);
    } else {
      this.bindings[typeLower] = [binding];
    }
    return this;
  }
  /** @internal */
  _off(type, filter) {
    const typeLower = type.toLocaleLowerCase();
    this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {
      var _a2;
      return !(((_a2 = bind.type) === null || _a2 === void 0 ? void 0 : _a2.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
    });
    return this;
  }
  /** @internal */
  static isEqual(obj1, obj2) {
    if (Object.keys(obj1).length !== Object.keys(obj2).length) {
      return false;
    }
    for (const k in obj1) {
      if (obj1[k] !== obj2[k]) {
        return false;
      }
    }
    return true;
  }
  /** @internal */
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout();
    if (this.socket.isConnected()) {
      this._rejoin();
    }
  }
  /**
   * Registers a callback that will be executed when the channel closes.
   *
   * @internal
   */
  _onClose(callback) {
    this._on(CHANNEL_EVENTS.close, {}, callback);
  }
  /**
   * Registers a callback that will be executed when the channel encounteres an error.
   *
   * @internal
   */
  _onError(callback) {
    this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));
  }
  /**
   * Returns `true` if the socket is connected and the channel has been joined.
   *
   * @internal
   */
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  /** @internal */
  _rejoin(timeout = this.timeout) {
    if (this._isLeaving()) {
      return;
    }
    this.socket._leaveOpenTopic(this.topic);
    this.state = CHANNEL_STATES.joining;
    this.joinPush.resend(timeout);
  }
  /** @internal */
  _getPayloadRecords(payload) {
    const records = {
      new: {},
      old: {}
    };
    if (payload.type === "INSERT" || payload.type === "UPDATE") {
      records.new = convertChangeData(payload.columns, payload.record);
    }
    if (payload.type === "UPDATE" || payload.type === "DELETE") {
      records.old = convertChangeData(payload.columns, payload.old_record);
    }
    return records;
  }
};

// node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js
var noop2 = () => {
};
var NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket !== "undefined";
var WORKER_SCRIPT = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
var RealtimeClient = class {
  /**
   * Initializes the Socket.
   *
   * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
   * @param httpEndpoint The string HTTP endpoint, ie, "https://example.com", "/" (inherited host & protocol)
   * @param options.transport The Websocket Transport, for example WebSocket.
   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
   * @param options.params The optional params to pass when connecting.
   * @param options.headers The optional headers to pass when connecting.
   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
   * @param options.worker Use Web Worker to set a side flow. Defaults to false.
   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.
   */
  constructor(endPoint, options) {
    var _a2;
    this.accessTokenValue = null;
    this.apiKey = null;
    this.channels = [];
    this.endPoint = "";
    this.httpEndpoint = "";
    this.headers = DEFAULT_HEADERS;
    this.params = {};
    this.timeout = DEFAULT_TIMEOUT;
    this.heartbeatIntervalMs = 3e4;
    this.heartbeatTimer = void 0;
    this.pendingHeartbeatRef = null;
    this.ref = 0;
    this.logger = noop2;
    this.conn = null;
    this.sendBuffer = [];
    this.serializer = new Serializer();
    this.stateChangeCallbacks = {
      open: [],
      close: [],
      error: [],
      message: []
    };
    this.accessToken = null;
    this._resolveFetch = (customFetch) => {
      let _fetch;
      if (customFetch) {
        _fetch = customFetch;
      } else if (typeof fetch === "undefined") {
        _fetch = (...args) => Promise.resolve().then(() => (init_browser(), browser_exports)).then(({ default: fetch4 }) => fetch4(...args));
      } else {
        _fetch = fetch;
      }
      return (...args) => _fetch(...args);
    };
    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
    this.httpEndpoint = httpEndpointURL(endPoint);
    if (options === null || options === void 0 ? void 0 : options.transport) {
      this.transport = options.transport;
    } else {
      this.transport = null;
    }
    if (options === null || options === void 0 ? void 0 : options.params)
      this.params = options.params;
    if (options === null || options === void 0 ? void 0 : options.headers)
      this.headers = Object.assign(Object.assign({}, this.headers), options.headers);
    if (options === null || options === void 0 ? void 0 : options.timeout)
      this.timeout = options.timeout;
    if (options === null || options === void 0 ? void 0 : options.logger)
      this.logger = options.logger;
    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)
      this.heartbeatIntervalMs = options.heartbeatIntervalMs;
    const accessTokenValue = (_a2 = options === null || options === void 0 ? void 0 : options.params) === null || _a2 === void 0 ? void 0 : _a2.apikey;
    if (accessTokenValue) {
      this.accessTokenValue = accessTokenValue;
      this.apiKey = accessTokenValue;
    }
    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : (tries) => {
      return [1e3, 2e3, 5e3, 1e4][tries - 1] || 1e4;
    };
    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {
      return callback(JSON.stringify(payload));
    };
    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);
    this.reconnectTimer = new Timer(async () => {
      this.disconnect();
      this.connect();
    }, this.reconnectAfterMs);
    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);
    if (options === null || options === void 0 ? void 0 : options.worker) {
      if (typeof window !== "undefined" && !window.Worker) {
        throw new Error("Web Worker is not supported");
      }
      this.worker = (options === null || options === void 0 ? void 0 : options.worker) || false;
      this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;
    }
    this.accessToken = (options === null || options === void 0 ? void 0 : options.accessToken) || null;
  }
  /**
   * Connects the socket, unless already connected.
   */
  connect() {
    if (this.conn) {
      return;
    }
    if (this.transport) {
      this.conn = new this.transport(this.endpointURL(), void 0, {
        headers: this.headers
      });
      return;
    }
    if (NATIVE_WEBSOCKET_AVAILABLE) {
      this.conn = new WebSocket(this.endpointURL());
      this.setupConnection();
      return;
    }
    this.conn = new WSWebSocketDummy(this.endpointURL(), void 0, {
      close: () => {
        this.conn = null;
      }
    });
    Promise.resolve().then(() => __toESM(require_browser())).then(({ default: WS }) => {
      this.conn = new WS(this.endpointURL(), void 0, {
        headers: this.headers
      });
      this.setupConnection();
    });
  }
  /**
   * Returns the URL of the websocket.
   * @returns string The URL of the websocket.
   */
  endpointURL() {
    return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));
  }
  /**
   * Disconnects the socket.
   *
   * @param code A numeric status code to send on disconnect.
   * @param reason A custom reason for the disconnect.
   */
  disconnect(code, reason) {
    if (this.conn) {
      this.conn.onclose = function() {
      };
      if (code) {
        this.conn.close(code, reason !== null && reason !== void 0 ? reason : "");
      } else {
        this.conn.close();
      }
      this.conn = null;
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.reconnectTimer.reset();
    }
  }
  /**
   * Returns all created channels
   */
  getChannels() {
    return this.channels;
  }
  /**
   * Unsubscribes and removes a single channel
   * @param channel A RealtimeChannel instance
   */
  async removeChannel(channel) {
    const status = await channel.unsubscribe();
    if (this.channels.length === 0) {
      this.disconnect();
    }
    return status;
  }
  /**
   * Unsubscribes and removes all channels
   */
  async removeAllChannels() {
    const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));
    this.disconnect();
    return values_1;
  }
  /**
   * Logs the message.
   *
   * For customized logging, `this.logger` can be overridden.
   */
  log(kind2, msg, data) {
    this.logger(kind2, msg, data);
  }
  /**
   * Returns the current state of the socket.
   */
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case SOCKET_STATES.connecting:
        return CONNECTION_STATE.Connecting;
      case SOCKET_STATES.open:
        return CONNECTION_STATE.Open;
      case SOCKET_STATES.closing:
        return CONNECTION_STATE.Closing;
      default:
        return CONNECTION_STATE.Closed;
    }
  }
  /**
   * Returns `true` is the connection is open.
   */
  isConnected() {
    return this.connectionState() === CONNECTION_STATE.Open;
  }
  channel(topic, params = { config: {} }) {
    const chan = new RealtimeChannel(`realtime:${topic}`, params, this);
    this.channels.push(chan);
    return chan;
  }
  /**
   * Push out a message if the socket is connected.
   *
   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
   */
  push(data) {
    const { topic, event, payload, ref } = data;
    const callback = () => {
      this.encode(data, (result) => {
        var _a2;
        (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.send(result);
      });
    };
    this.log("push", `${topic} ${event} (${ref})`, payload);
    if (this.isConnected()) {
      callback();
    } else {
      this.sendBuffer.push(callback);
    }
  }
  /**
   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
   *
   * If param is null it will use the `accessToken` callback function or the token set on the client.
   *
   * On callback used, it will set the value of the token internal to the client.
   *
   * @param token A JWT string to override the token set on the client.
   */
  async setAuth(token = null) {
    let tokenToSend = token || this.accessToken && await this.accessToken() || this.accessTokenValue;
    if (tokenToSend) {
      let parsed = null;
      try {
        parsed = JSON.parse(atob(tokenToSend.split(".")[1]));
      } catch (_error) {
      }
      if (parsed && parsed.exp) {
        let now = Math.floor(Date.now() / 1e3);
        let valid = now - parsed.exp < 0;
        if (!valid) {
          this.log("auth", `InvalidJWTToken: Invalid value for JWT claim "exp" with value ${parsed.exp}`);
          return Promise.reject(`InvalidJWTToken: Invalid value for JWT claim "exp" with value ${parsed.exp}`);
        }
      }
      this.accessTokenValue = tokenToSend;
      this.channels.forEach((channel) => {
        tokenToSend && channel.updateJoinPayload({ access_token: tokenToSend });
        if (channel.joinedOnce && channel._isJoined()) {
          channel._push(CHANNEL_EVENTS.access_token, {
            access_token: tokenToSend
          });
        }
      });
    }
  }
  /**
   * Sends a heartbeat message if the socket is connected.
   */
  async sendHeartbeat() {
    var _a2;
    if (!this.isConnected()) {
      return;
    }
    if (this.pendingHeartbeatRef) {
      this.pendingHeartbeatRef = null;
      this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
      (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.close(WS_CLOSE_NORMAL, "hearbeat timeout");
      return;
    }
    this.pendingHeartbeatRef = this._makeRef();
    this.push({
      topic: "phoenix",
      event: "heartbeat",
      payload: {},
      ref: this.pendingHeartbeatRef
    });
    this.setAuth();
  }
  /**
   * Flushes send buffer
   */
  flushSendBuffer() {
    if (this.isConnected() && this.sendBuffer.length > 0) {
      this.sendBuffer.forEach((callback) => callback());
      this.sendBuffer = [];
    }
  }
  /**
   * Return the next message ref, accounting for overflows
   *
   * @internal
   */
  _makeRef() {
    let newRef = this.ref + 1;
    if (newRef === this.ref) {
      this.ref = 0;
    } else {
      this.ref = newRef;
    }
    return this.ref.toString();
  }
  /**
   * Unsubscribe from channels with the specified topic.
   *
   * @internal
   */
  _leaveOpenTopic(topic) {
    let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));
    if (dupChannel) {
      this.log("transport", `leaving duplicate topic "${topic}"`);
      dupChannel.unsubscribe();
    }
  }
  /**
   * Removes a subscription from the socket.
   *
   * @param channel An open subscription.
   *
   * @internal
   */
  _remove(channel) {
    this.channels = this.channels.filter((c) => c._joinRef() !== channel._joinRef());
  }
  /**
   * Sets up connection handlers.
   *
   * @internal
   */
  setupConnection() {
    if (this.conn) {
      this.conn.binaryType = "arraybuffer";
      this.conn.onopen = () => this._onConnOpen();
      this.conn.onerror = (error) => this._onConnError(error);
      this.conn.onmessage = (event) => this._onConnMessage(event);
      this.conn.onclose = (event) => this._onConnClose(event);
    }
  }
  /** @internal */
  _onConnMessage(rawMessage) {
    this.decode(rawMessage.data, (msg) => {
      let { topic, event, payload, ref } = msg;
      if (ref && ref === this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
      }
      this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
      this.channels.filter((channel) => channel._isMember(topic)).forEach((channel) => channel._trigger(event, payload, ref));
      this.stateChangeCallbacks.message.forEach((callback) => callback(msg));
    });
  }
  /** @internal */
  async _onConnOpen() {
    this.log("transport", `connected to ${this.endpointURL()}`);
    this.flushSendBuffer();
    this.reconnectTimer.reset();
    if (!this.worker) {
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    } else {
      if (this.workerUrl) {
        this.log("worker", `starting worker for from ${this.workerUrl}`);
      } else {
        this.log("worker", `starting default worker`);
      }
      const objectUrl = this._workerObjectUrl(this.workerUrl);
      this.workerRef = new Worker(objectUrl);
      this.workerRef.onerror = (error) => {
        this.log("worker", "worker error", error.message);
        this.workerRef.terminate();
      };
      this.workerRef.onmessage = (event) => {
        if (event.data.event === "keepAlive") {
          this.sendHeartbeat();
        }
      };
      this.workerRef.postMessage({
        event: "start",
        interval: this.heartbeatIntervalMs
      });
    }
    this.stateChangeCallbacks.open.forEach((callback) => callback());
  }
  /** @internal */
  _onConnClose(event) {
    this.log("transport", "close", event);
    this._triggerChanError();
    this.heartbeatTimer && clearInterval(this.heartbeatTimer);
    this.reconnectTimer.scheduleTimeout();
    this.stateChangeCallbacks.close.forEach((callback) => callback(event));
  }
  /** @internal */
  _onConnError(error) {
    this.log("transport", error.message);
    this._triggerChanError();
    this.stateChangeCallbacks.error.forEach((callback) => callback(error));
  }
  /** @internal */
  _triggerChanError() {
    this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));
  }
  /** @internal */
  _appendParams(url, params) {
    if (Object.keys(params).length === 0) {
      return url;
    }
    const prefix = url.match(/\?/) ? "&" : "?";
    const query = new URLSearchParams(params);
    return `${url}${prefix}${query}`;
  }
  _workerObjectUrl(url) {
    let result_url;
    if (url) {
      result_url = url;
    } else {
      const blob = new Blob([WORKER_SCRIPT], { type: "application/javascript" });
      result_url = URL.createObjectURL(blob);
    }
    return result_url;
  }
};
var WSWebSocketDummy = class {
  constructor(address, _protocols, options) {
    this.binaryType = "arraybuffer";
    this.onclose = () => {
    };
    this.onerror = () => {
    };
    this.onmessage = () => {
    };
    this.onopen = () => {
    };
    this.readyState = SOCKET_STATES.connecting;
    this.send = () => {
    };
    this.url = null;
    this.url = address;
    this.close = options.close;
  }
};

// node_modules/@supabase/storage-js/dist/module/lib/errors.js
var StorageError = class extends Error {
  constructor(message) {
    super(message);
    this.__isStorageError = true;
    this.name = "StorageError";
  }
};
function isStorageError(error) {
  return typeof error === "object" && error !== null && "__isStorageError" in error;
}
var StorageApiError = class extends StorageError {
  constructor(message, status) {
    super(message);
    this.name = "StorageApiError";
    this.status = status;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    };
  }
};
var StorageUnknownError = class extends StorageError {
  constructor(message, originalError) {
    super(message);
    this.name = "StorageUnknownError";
    this.originalError = originalError;
  }
};

// node_modules/@supabase/storage-js/dist/module/lib/helpers.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var resolveFetch2 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => Promise.resolve().then(() => (init_browser(), browser_exports)).then(({ default: fetch4 }) => fetch4(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
var resolveResponse = () => __awaiter2(void 0, void 0, void 0, function* () {
  if (typeof Response === "undefined") {
    return (yield Promise.resolve().then(() => (init_browser(), browser_exports))).Response;
  }
  return Response;
});
var recursiveToCamel = (item) => {
  if (Array.isArray(item)) {
    return item.map((el) => recursiveToCamel(el));
  } else if (typeof item === "function" || item !== Object(item)) {
    return item;
  }
  const result = {};
  Object.entries(item).forEach(([key, value]) => {
    const newKey = key.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ""));
    result[newKey] = recursiveToCamel(value);
  });
  return result;
};

// node_modules/@supabase/storage-js/dist/module/lib/fetch.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
var handleError = (error, reject, options) => __awaiter3(void 0, void 0, void 0, function* () {
  const Res = yield resolveResponse();
  if (error instanceof Res && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
    error.json().then((err) => {
      reject(new StorageApiError(_getErrorMessage(err), error.status || 500));
    }).catch((err) => {
      reject(new StorageUnknownError(_getErrorMessage(err), err));
    });
  } else {
    reject(new StorageUnknownError(_getErrorMessage(error), error));
  }
});
var _getRequestParams = (method, options, parameters, body) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET") {
    return params;
  }
  params.headers = Object.assign({ "Content-Type": "application/json" }, options === null || options === void 0 ? void 0 : options.headers);
  if (body) {
    params.body = JSON.stringify(body);
  }
  return Object.assign(Object.assign({}, params), parameters);
};
function _handleRequest(fetcher, method, url, options, parameters, body) {
  return __awaiter3(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      fetcher(url, _getRequestParams(method, options, parameters, body)).then((result) => {
        if (!result.ok)
          throw result;
        if (options === null || options === void 0 ? void 0 : options.noResolveJson)
          return result;
        return result.json();
      }).then((data) => resolve(data)).catch((error) => handleError(error, reject, options));
    });
  });
}
function get(fetcher, url, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "GET", url, options, parameters);
  });
}
function post(fetcher, url, body, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "POST", url, options, parameters, body);
  });
}
function put(fetcher, url, body, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "PUT", url, options, parameters, body);
  });
}
function head(fetcher, url, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "HEAD", url, Object.assign(Object.assign({}, options), { noResolveJson: true }), parameters);
  });
}
function remove(fetcher, url, body, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "DELETE", url, options, parameters, body);
  });
}

// node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_SEARCH_OPTIONS = {
  limit: 100,
  offset: 0,
  sortBy: {
    column: "name",
    order: "asc"
  }
};
var DEFAULT_FILE_OPTIONS = {
  cacheControl: "3600",
  contentType: "text/plain;charset=UTF-8",
  upsert: false
};
var StorageFileApi = class {
  constructor(url, headers = {}, bucketId, fetch4) {
    this.url = url;
    this.headers = headers;
    this.bucketId = bucketId;
    this.fetch = resolveFetch2(fetch4);
  }
  /**
   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
   *
   * @param method HTTP method.
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadOrUpdate(method, path, fileBody, fileOptions) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        let body;
        const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
        let headers = Object.assign(Object.assign({}, this.headers), method === "POST" && { "x-upsert": String(options.upsert) });
        const metadata = options.metadata;
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          body = new FormData();
          body.append("cacheControl", options.cacheControl);
          if (metadata) {
            body.append("metadata", this.encodeMetadata(metadata));
          }
          body.append("", fileBody);
        } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
          body = fileBody;
          body.append("cacheControl", options.cacheControl);
          if (metadata) {
            body.append("metadata", this.encodeMetadata(metadata));
          }
        } else {
          body = fileBody;
          headers["cache-control"] = `max-age=${options.cacheControl}`;
          headers["content-type"] = options.contentType;
          if (metadata) {
            headers["x-metadata"] = this.toBase64(this.encodeMetadata(metadata));
          }
        }
        if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) {
          headers = Object.assign(Object.assign({}, headers), fileOptions.headers);
        }
        const cleanPath = this._removeEmptyFolders(path);
        const _path = this._getFinalPath(cleanPath);
        const res = yield this.fetch(`${this.url}/object/${_path}`, Object.assign({ method, body, headers }, (options === null || options === void 0 ? void 0 : options.duplex) ? { duplex: options.duplex } : {}));
        const data = yield res.json();
        if (res.ok) {
          return {
            data: { path: cleanPath, id: data.Id, fullPath: data.Key },
            error: null
          };
        } else {
          const error = data;
          return { data: null, error };
        }
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Uploads a file to an existing bucket.
   *
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  upload(path, fileBody, fileOptions) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("POST", path, fileBody, fileOptions);
    });
  }
  /**
   * Upload a file with a token generated from `createSignedUploadUrl`.
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param token The token generated from `createSignedUploadUrl`
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadToSignedUrl(path, token, fileBody, fileOptions) {
    return __awaiter4(this, void 0, void 0, function* () {
      const cleanPath = this._removeEmptyFolders(path);
      const _path = this._getFinalPath(cleanPath);
      const url = new URL(this.url + `/object/upload/sign/${_path}`);
      url.searchParams.set("token", token);
      try {
        let body;
        const options = Object.assign({ upsert: DEFAULT_FILE_OPTIONS.upsert }, fileOptions);
        const headers = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(options.upsert) });
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          body = new FormData();
          body.append("cacheControl", options.cacheControl);
          body.append("", fileBody);
        } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
          body = fileBody;
          body.append("cacheControl", options.cacheControl);
        } else {
          body = fileBody;
          headers["cache-control"] = `max-age=${options.cacheControl}`;
          headers["content-type"] = options.contentType;
        }
        const res = yield this.fetch(url.toString(), {
          method: "PUT",
          body,
          headers
        });
        const data = yield res.json();
        if (res.ok) {
          return {
            data: { path: cleanPath, fullPath: data.Key },
            error: null
          };
        } else {
          const error = data;
          return { data: null, error };
        }
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a signed upload URL.
   * Signed upload URLs can be used to upload files to the bucket without further authentication.
   * They are valid for 2 hours.
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param options.upsert If set to true, allows the file to be overwritten if it already exists.
   */
  createSignedUploadUrl(path, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        const headers = Object.assign({}, this.headers);
        if (options === null || options === void 0 ? void 0 : options.upsert) {
          headers["x-upsert"] = "true";
        }
        const data = yield post(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, { headers });
        const url = new URL(this.url + data.url);
        const token = url.searchParams.get("token");
        if (!token) {
          throw new StorageError("No token returned by API");
        }
        return { data: { signedUrl: url.toString(), path, token }, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Replaces an existing file at the specified path with a new one.
   *
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  update(path, fileBody, fileOptions) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("PUT", path, fileBody, fileOptions);
    });
  }
  /**
   * Moves an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
   * @param options The destination options.
   */
  move(fromPath, toPath, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/object/move`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath,
          destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Copies an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
   * @param options The destination options.
   */
  copy(fromPath, toPath, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/object/copy`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath,
          destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
        }, { headers: this.headers });
        return { data: { path: data.Key }, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  createSignedUrl(path, expiresIn, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        let data = yield post(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({ expiresIn }, (options === null || options === void 0 ? void 0 : options.transform) ? { transform: options.transform } : {}), { headers: this.headers });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
        const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);
        data = { signedUrl };
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   */
  createSignedUrls(paths, expiresIn, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
        return {
          data: data.map((datum) => Object.assign(Object.assign({}, datum), { signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null })),
          error: null
        };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
   *
   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
   * @param options.transform Transform the asset before serving it to the client.
   */
  download(path, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
      const renderPath = wantsTransformation ? "render/image/authenticated" : "object";
      const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
      const queryString = transformationQuery ? `?${transformationQuery}` : "";
      try {
        const _path = this._getFinalPath(path);
        const res = yield get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {
          headers: this.headers,
          noResolveJson: true
        });
        const data = yield res.blob();
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the details of an existing file.
   * @param path
   */
  info(path) {
    return __awaiter4(this, void 0, void 0, function* () {
      const _path = this._getFinalPath(path);
      try {
        const data = yield get(this.fetch, `${this.url}/object/info/${_path}`, {
          headers: this.headers
        });
        return { data: recursiveToCamel(data), error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Checks the existence of a file.
   * @param path
   */
  exists(path) {
    return __awaiter4(this, void 0, void 0, function* () {
      const _path = this._getFinalPath(path);
      try {
        yield head(this.fetch, `${this.url}/object/${_path}`, {
          headers: this.headers
        });
        return { data: true, error: null };
      } catch (error) {
        if (isStorageError(error) && error instanceof StorageUnknownError) {
          const originalError = error.originalError;
          if ([400, 404].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) {
            return { data: false, error };
          }
        }
        throw error;
      }
    });
  }
  /**
   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
   *
   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  getPublicUrl(path, options) {
    const _path = this._getFinalPath(path);
    const _queryString = [];
    const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? "" : options.download}` : "";
    if (downloadQueryParam !== "") {
      _queryString.push(downloadQueryParam);
    }
    const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
    const renderPath = wantsTransformation ? "render/image" : "object";
    const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
    if (transformationQuery !== "") {
      _queryString.push(transformationQuery);
    }
    let queryString = _queryString.join("&");
    if (queryString !== "") {
      queryString = `?${queryString}`;
    }
    return {
      data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) }
    };
  }
  /**
   * Deletes files within the same bucket
   *
   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
   */
  remove(paths) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Get file metadata
   * @param id the file id to retrieve metadata
   */
  // async getMetadata(
  //   id: string
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Update file metadata
   * @param id the file id to update metadata
   * @param meta the new file metadata
   */
  // async updateMetadata(
  //   id: string,
  //   meta: Metadata
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await post(
  //       this.fetch,
  //       `${this.url}/metadata/${id}`,
  //       { ...meta },
  //       { headers: this.headers }
  //     )
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Lists all the files within a bucket.
   * @param path The folder path.
   */
  list(path, options, parameters) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || "" });
        const data = yield post(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  encodeMetadata(metadata) {
    return JSON.stringify(metadata);
  }
  toBase64(data) {
    if (typeof Buffer !== "undefined") {
      return Buffer.from(data).toString("base64");
    }
    return btoa(data);
  }
  _getFinalPath(path) {
    return `${this.bucketId}/${path}`;
  }
  _removeEmptyFolders(path) {
    return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
  }
  transformOptsToQueryString(transform) {
    const params = [];
    if (transform.width) {
      params.push(`width=${transform.width}`);
    }
    if (transform.height) {
      params.push(`height=${transform.height}`);
    }
    if (transform.resize) {
      params.push(`resize=${transform.resize}`);
    }
    if (transform.format) {
      params.push(`format=${transform.format}`);
    }
    if (transform.quality) {
      params.push(`quality=${transform.quality}`);
    }
    return params.join("&");
  }
};

// node_modules/@supabase/storage-js/dist/module/lib/version.js
var version2 = "2.7.1";

// node_modules/@supabase/storage-js/dist/module/lib/constants.js
var DEFAULT_HEADERS2 = { "X-Client-Info": `storage-js/${version2}` };

// node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var StorageBucketApi = class {
  constructor(url, headers = {}, fetch4) {
    this.url = url;
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS2), headers);
    this.fetch = resolveFetch2(fetch4);
  }
  /**
   * Retrieves the details of all Storage buckets within an existing project.
   */
  listBuckets() {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield get(this.fetch, `${this.url}/bucket`, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the details of an existing Storage bucket.
   *
   * @param id The unique identifier of the bucket you would like to retrieve.
   */
  getBucket(id) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a new Storage bucket
   *
   * @param id A unique identifier for the bucket you are creating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   * @returns newly created bucket id
   */
  createBucket(id, options = {
    public: false
  }) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/bucket`, {
          id,
          name: id,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Updates a Storage bucket
   *
   * @param id A unique identifier for the bucket you are updating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   */
  updateBucket(id, options) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield put(this.fetch, `${this.url}/bucket/${id}`, {
          id,
          name: id,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Removes all objects inside a single bucket.
   *
   * @param id The unique identifier of the bucket you would like to empty.
   */
  emptyBucket(id) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
   * You must first `empty()` the bucket.
   *
   * @param id The unique identifier of the bucket you would like to delete.
   */
  deleteBucket(id) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
};

// node_modules/@supabase/storage-js/dist/module/StorageClient.js
var StorageClient = class extends StorageBucketApi {
  constructor(url, headers = {}, fetch4) {
    super(url, headers, fetch4);
  }
  /**
   * Perform file operation in a bucket.
   *
   * @param id The bucket id to operate on.
   */
  from(id) {
    return new StorageFileApi(this.url, this.headers, id, this.fetch);
  }
};

// node_modules/@supabase/supabase-js/dist/module/lib/version.js
var version3 = "2.47.16";

// node_modules/@supabase/supabase-js/dist/module/lib/constants.js
var JS_ENV = "";
if (typeof Deno !== "undefined") {
  JS_ENV = "deno";
} else if (typeof document !== "undefined") {
  JS_ENV = "web";
} else if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
  JS_ENV = "react-native";
} else {
  JS_ENV = "node";
}
var DEFAULT_HEADERS3 = { "X-Client-Info": `supabase-js-${JS_ENV}/${version3}` };
var DEFAULT_GLOBAL_OPTIONS = {
  headers: DEFAULT_HEADERS3
};
var DEFAULT_DB_OPTIONS = {
  schema: "public"
};
var DEFAULT_AUTH_OPTIONS = {
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  flowType: "implicit"
};
var DEFAULT_REALTIME_OPTIONS = {};

// node_modules/@supabase/supabase-js/dist/module/lib/fetch.js
init_browser();
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var resolveFetch3 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = browser_default;
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
var resolveHeadersConstructor = () => {
  if (typeof Headers === "undefined") {
    return Headers2;
  }
  return Headers;
};
var fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {
  const fetch4 = resolveFetch3(customFetch);
  const HeadersConstructor = resolveHeadersConstructor();
  return (input, init) => __awaiter6(void 0, void 0, void 0, function* () {
    var _a2;
    const accessToken = (_a2 = yield getAccessToken()) !== null && _a2 !== void 0 ? _a2 : supabaseKey;
    let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
    if (!headers.has("apikey")) {
      headers.set("apikey", supabaseKey);
    }
    if (!headers.has("Authorization")) {
      headers.set("Authorization", `Bearer ${accessToken}`);
    }
    return fetch4(input, Object.assign(Object.assign({}, init), { headers }));
  });
};

// node_modules/@supabase/supabase-js/dist/module/lib/helpers.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function stripTrailingSlash(url) {
  return url.replace(/\/$/, "");
}
function applySettingDefaults(options, defaults2) {
  const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;
  const { db: DEFAULT_DB_OPTIONS2, auth: DEFAULT_AUTH_OPTIONS2, realtime: DEFAULT_REALTIME_OPTIONS2, global: DEFAULT_GLOBAL_OPTIONS2 } = defaults2;
  const result = {
    db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS2), dbOptions),
    auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS2), authOptions),
    realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS2), realtimeOptions),
    global: Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS2), globalOptions),
    accessToken: () => __awaiter7(this, void 0, void 0, function* () {
      return "";
    })
  };
  if (options.accessToken) {
    result.accessToken = options.accessToken;
  } else {
    delete result.accessToken;
  }
  return result;
}

// node_modules/@supabase/auth-js/dist/module/lib/version.js
var version4 = "2.67.3";

// node_modules/@supabase/auth-js/dist/module/lib/constants.js
var GOTRUE_URL = "http://localhost:9999";
var STORAGE_KEY = "supabase.auth.token";
var DEFAULT_HEADERS4 = { "X-Client-Info": `gotrue-js/${version4}` };
var EXPIRY_MARGIN = 10;
var API_VERSION_HEADER_NAME = "X-Supabase-Api-Version";
var API_VERSIONS = {
  "2024-01-01": {
    timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
    name: "2024-01-01"
  }
};

// node_modules/@supabase/auth-js/dist/module/lib/helpers.js
function expiresAt(expiresIn) {
  const timeNow = Math.round(Date.now() / 1e3);
  return timeNow + expiresIn;
}
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
var isBrowser = () => typeof window !== "undefined" && typeof document !== "undefined";
var localStorageWriteTests = {
  tested: false,
  writable: false
};
var supportsLocalStorage = () => {
  if (!isBrowser()) {
    return false;
  }
  try {
    if (typeof globalThis.localStorage !== "object") {
      return false;
    }
  } catch (e) {
    return false;
  }
  if (localStorageWriteTests.tested) {
    return localStorageWriteTests.writable;
  }
  const randomKey = `lswt-${Math.random()}${Math.random()}`;
  try {
    globalThis.localStorage.setItem(randomKey, randomKey);
    globalThis.localStorage.removeItem(randomKey);
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = true;
  } catch (e) {
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = false;
  }
  return localStorageWriteTests.writable;
};
function parseParametersFromURL(href) {
  const result = {};
  const url = new URL(href);
  if (url.hash && url.hash[0] === "#") {
    try {
      const hashSearchParams = new URLSearchParams(url.hash.substring(1));
      hashSearchParams.forEach((value, key) => {
        result[key] = value;
      });
    } catch (e) {
    }
  }
  url.searchParams.forEach((value, key) => {
    result[key] = value;
  });
  return result;
}
var resolveFetch4 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => Promise.resolve().then(() => (init_browser(), browser_exports)).then(({ default: fetch4 }) => fetch4(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
var looksLikeFetchResponse = (maybeResponse) => {
  return typeof maybeResponse === "object" && maybeResponse !== null && "status" in maybeResponse && "ok" in maybeResponse && "json" in maybeResponse && typeof maybeResponse.json === "function";
};
var setItemAsync = async (storage, key, data) => {
  await storage.setItem(key, JSON.stringify(data));
};
var getItemAsync = async (storage, key) => {
  const value = await storage.getItem(key);
  if (!value) {
    return null;
  }
  try {
    return JSON.parse(value);
  } catch (_a2) {
    return value;
  }
};
var removeItemAsync = async (storage, key) => {
  await storage.removeItem(key);
};
function decodeBase64URL(value) {
  const key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let base64 = "";
  let chr1, chr2, chr3;
  let enc1, enc2, enc3, enc4;
  let i = 0;
  value = value.replace("-", "+").replace("_", "/");
  while (i < value.length) {
    enc1 = key.indexOf(value.charAt(i++));
    enc2 = key.indexOf(value.charAt(i++));
    enc3 = key.indexOf(value.charAt(i++));
    enc4 = key.indexOf(value.charAt(i++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    base64 = base64 + String.fromCharCode(chr1);
    if (enc3 != 64 && chr2 != 0) {
      base64 = base64 + String.fromCharCode(chr2);
    }
    if (enc4 != 64 && chr3 != 0) {
      base64 = base64 + String.fromCharCode(chr3);
    }
  }
  return base64;
}
var Deferred = class {
  constructor() {
    ;
    this.promise = new Deferred.promiseConstructor((res, rej) => {
      ;
      this.resolve = res;
      this.reject = rej;
    });
  }
};
Deferred.promiseConstructor = Promise;
function decodeJWTPayload(token) {
  const base64UrlRegex = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i;
  const parts = token.split(".");
  if (parts.length !== 3) {
    throw new Error("JWT is not valid: not a JWT structure");
  }
  if (!base64UrlRegex.test(parts[1])) {
    throw new Error("JWT is not valid: payload is not in base64url format");
  }
  const base64Url = parts[1];
  return JSON.parse(decodeBase64URL(base64Url));
}
async function sleep(time) {
  return await new Promise((accept) => {
    setTimeout(() => accept(null), time);
  });
}
function retryable(fn, isRetryable) {
  const promise = new Promise((accept, reject) => {
    ;
    (async () => {
      for (let attempt = 0; attempt < Infinity; attempt++) {
        try {
          const result = await fn(attempt);
          if (!isRetryable(attempt, null, result)) {
            accept(result);
            return;
          }
        } catch (e) {
          if (!isRetryable(attempt, e)) {
            reject(e);
            return;
          }
        }
      }
    })();
  });
  return promise;
}
function dec2hex(dec) {
  return ("0" + dec.toString(16)).substr(-2);
}
function generatePKCEVerifier() {
  const verifierLength = 56;
  const array = new Uint32Array(verifierLength);
  if (typeof crypto === "undefined") {
    const charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
    const charSetLen = charSet.length;
    let verifier = "";
    for (let i = 0; i < verifierLength; i++) {
      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));
    }
    return verifier;
  }
  crypto.getRandomValues(array);
  return Array.from(array, dec2hex).join("");
}
async function sha256(randomString) {
  const encoder = new TextEncoder();
  const encodedData = encoder.encode(randomString);
  const hash = await crypto.subtle.digest("SHA-256", encodedData);
  const bytes = new Uint8Array(hash);
  return Array.from(bytes).map((c) => String.fromCharCode(c)).join("");
}
function base64urlencode(str2) {
  return btoa(str2).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function generatePKCEChallenge(verifier) {
  const hasCryptoSupport = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined" && typeof TextEncoder !== "undefined";
  if (!hasCryptoSupport) {
    console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.");
    return verifier;
  }
  const hashed = await sha256(verifier);
  return base64urlencode(hashed);
}
async function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {
  const codeVerifier = generatePKCEVerifier();
  let storedCodeVerifier = codeVerifier;
  if (isPasswordRecovery) {
    storedCodeVerifier += "/PASSWORD_RECOVERY";
  }
  await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);
  const codeChallenge = await generatePKCEChallenge(codeVerifier);
  const codeChallengeMethod = codeVerifier === codeChallenge ? "plain" : "s256";
  return [codeChallenge, codeChallengeMethod];
}
var API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function parseResponseAPIVersion(response) {
  const apiVersion = response.headers.get(API_VERSION_HEADER_NAME);
  if (!apiVersion) {
    return null;
  }
  if (!apiVersion.match(API_VERSION_REGEX)) {
    return null;
  }
  try {
    const date = new Date(`${apiVersion}T00:00:00.0Z`);
    return date;
  } catch (e) {
    return null;
  }
}

// node_modules/@supabase/auth-js/dist/module/lib/errors.js
var AuthError = class extends Error {
  constructor(message, status, code) {
    super(message);
    this.__isAuthError = true;
    this.name = "AuthError";
    this.status = status;
    this.code = code;
  }
};
function isAuthError(error) {
  return typeof error === "object" && error !== null && "__isAuthError" in error;
}
var AuthApiError = class extends AuthError {
  constructor(message, status, code) {
    super(message, status, code);
    this.name = "AuthApiError";
    this.status = status;
    this.code = code;
  }
};
function isAuthApiError(error) {
  return isAuthError(error) && error.name === "AuthApiError";
}
var AuthUnknownError = class extends AuthError {
  constructor(message, originalError) {
    super(message);
    this.name = "AuthUnknownError";
    this.originalError = originalError;
  }
};
var CustomAuthError = class extends AuthError {
  constructor(message, name, status, code) {
    super(message, status, code);
    this.name = name;
    this.status = status;
  }
};
var AuthSessionMissingError = class extends CustomAuthError {
  constructor() {
    super("Auth session missing!", "AuthSessionMissingError", 400, void 0);
  }
};
function isAuthSessionMissingError(error) {
  return isAuthError(error) && error.name === "AuthSessionMissingError";
}
var AuthInvalidTokenResponseError = class extends CustomAuthError {
  constructor() {
    super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0);
  }
};
var AuthInvalidCredentialsError = class extends CustomAuthError {
  constructor(message) {
    super(message, "AuthInvalidCredentialsError", 400, void 0);
  }
};
var AuthImplicitGrantRedirectError = class extends CustomAuthError {
  constructor(message, details = null) {
    super(message, "AuthImplicitGrantRedirectError", 500, void 0);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
};
function isAuthImplicitGrantRedirectError(error) {
  return isAuthError(error) && error.name === "AuthImplicitGrantRedirectError";
}
var AuthPKCEGrantCodeExchangeError = class extends CustomAuthError {
  constructor(message, details = null) {
    super(message, "AuthPKCEGrantCodeExchangeError", 500, void 0);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
};
var AuthRetryableFetchError = class extends CustomAuthError {
  constructor(message, status) {
    super(message, "AuthRetryableFetchError", status, void 0);
  }
};
function isAuthRetryableFetchError(error) {
  return isAuthError(error) && error.name === "AuthRetryableFetchError";
}
var AuthWeakPasswordError = class extends CustomAuthError {
  constructor(message, status, reasons) {
    super(message, "AuthWeakPasswordError", status, "weak_password");
    this.reasons = reasons;
  }
};

// node_modules/@supabase/auth-js/dist/module/lib/fetch.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var _getErrorMessage2 = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
var NETWORK_ERROR_CODES = [502, 503, 504];
async function handleError2(error) {
  var _a2;
  if (!looksLikeFetchResponse(error)) {
    throw new AuthRetryableFetchError(_getErrorMessage2(error), 0);
  }
  if (NETWORK_ERROR_CODES.includes(error.status)) {
    throw new AuthRetryableFetchError(_getErrorMessage2(error), error.status);
  }
  let data;
  try {
    data = await error.json();
  } catch (e) {
    throw new AuthUnknownError(_getErrorMessage2(e), e);
  }
  let errorCode = void 0;
  const responseAPIVersion = parseResponseAPIVersion(error);
  if (responseAPIVersion && responseAPIVersion.getTime() >= API_VERSIONS["2024-01-01"].timestamp && typeof data === "object" && data && typeof data.code === "string") {
    errorCode = data.code;
  } else if (typeof data === "object" && data && typeof data.error_code === "string") {
    errorCode = data.error_code;
  }
  if (!errorCode) {
    if (typeof data === "object" && data && typeof data.weak_password === "object" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
      throw new AuthWeakPasswordError(_getErrorMessage2(data), error.status, data.weak_password.reasons);
    }
  } else if (errorCode === "weak_password") {
    throw new AuthWeakPasswordError(_getErrorMessage2(data), error.status, ((_a2 = data.weak_password) === null || _a2 === void 0 ? void 0 : _a2.reasons) || []);
  } else if (errorCode === "session_not_found") {
    throw new AuthSessionMissingError();
  }
  throw new AuthApiError(_getErrorMessage2(data), error.status || 500, errorCode);
}
var _getRequestParams2 = (method, options, parameters, body) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET") {
    return params;
  }
  params.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, options === null || options === void 0 ? void 0 : options.headers);
  params.body = JSON.stringify(body);
  return Object.assign(Object.assign({}, params), parameters);
};
async function _request(fetcher, method, url, options) {
  var _a2;
  const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
  if (!headers[API_VERSION_HEADER_NAME]) {
    headers[API_VERSION_HEADER_NAME] = API_VERSIONS["2024-01-01"].name;
  }
  if (options === null || options === void 0 ? void 0 : options.jwt) {
    headers["Authorization"] = `Bearer ${options.jwt}`;
  }
  const qs = (_a2 = options === null || options === void 0 ? void 0 : options.query) !== null && _a2 !== void 0 ? _a2 : {};
  if (options === null || options === void 0 ? void 0 : options.redirectTo) {
    qs["redirect_to"] = options.redirectTo;
  }
  const queryString = Object.keys(qs).length ? "?" + new URLSearchParams(qs).toString() : "";
  const data = await _handleRequest2(fetcher, method, url + queryString, {
    headers,
    noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson
  }, {}, options === null || options === void 0 ? void 0 : options.body);
  return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };
}
async function _handleRequest2(fetcher, method, url, options, parameters, body) {
  const requestParams = _getRequestParams2(method, options, parameters, body);
  let result;
  try {
    result = await fetcher(url, Object.assign({}, requestParams));
  } catch (e) {
    console.error(e);
    throw new AuthRetryableFetchError(_getErrorMessage2(e), 0);
  }
  if (!result.ok) {
    await handleError2(result);
  }
  if (options === null || options === void 0 ? void 0 : options.noResolveJson) {
    return result;
  }
  try {
    return await result.json();
  } catch (e) {
    await handleError2(e);
  }
}
function _sessionResponse(data) {
  var _a2;
  let session = null;
  if (hasSession(data)) {
    session = Object.assign({}, data);
    if (!data.expires_at) {
      session.expires_at = expiresAt(data.expires_in);
    }
  }
  const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
  return { data: { session, user }, error: null };
}
function _sessionResponsePassword(data) {
  const response = _sessionResponse(data);
  if (!response.error && data.weak_password && typeof data.weak_password === "object" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === "string" && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
    response.data.weak_password = data.weak_password;
  }
  return response;
}
function _userResponse(data) {
  var _a2;
  const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
  return { data: { user }, error: null };
}
function _ssoResponse(data) {
  return { data, error: null };
}
function _generateLinkResponse(data) {
  const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
  const properties = {
    action_link,
    email_otp,
    hashed_token,
    redirect_to,
    verification_type
  };
  const user = Object.assign({}, rest);
  return {
    data: {
      properties,
      user
    },
    error: null
  };
}
function _noResolveJsonResponse(data) {
  return data;
}
function hasSession(data) {
  return data.access_token && data.refresh_token && data.expires_in;
}

// node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var GoTrueAdminApi = class {
  constructor({ url = "", headers = {}, fetch: fetch4 }) {
    this.url = url;
    this.headers = headers;
    this.fetch = resolveFetch4(fetch4);
    this.mfa = {
      listFactors: this._listFactors.bind(this),
      deleteFactor: this._deleteFactor.bind(this)
    };
  }
  /**
   * Removes a logged-in session.
   * @param jwt A valid, logged-in JWT.
   * @param scope The logout sope.
   */
  async signOut(jwt, scope = "global") {
    try {
      await _request(this.fetch, "POST", `${this.url}/logout?scope=${scope}`, {
        headers: this.headers,
        jwt,
        noResolveJson: true
      });
      return { data: null, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Sends an invite link to an email address.
   * @param email The email address of the user.
   * @param options Additional options to be included when inviting.
   */
  async inviteUserByEmail(email, options = {}) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/invite`, {
        body: { email, data: options.data },
        headers: this.headers,
        redirectTo: options.redirectTo,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Generates email links and OTPs to be sent via a custom email provider.
   * @param email The user's email.
   * @param options.password User password. For signup only.
   * @param options.data Optional user metadata. For signup only.
   * @param options.redirectTo The redirect url which should be appended to the generated link
   */
  async generateLink(params) {
    try {
      const { options } = params, rest = __rest2(params, ["options"]);
      const body = Object.assign(Object.assign({}, rest), options);
      if ("newEmail" in rest) {
        body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;
        delete body["newEmail"];
      }
      return await _request(this.fetch, "POST", `${this.url}/admin/generate_link`, {
        body,
        headers: this.headers,
        xform: _generateLinkResponse,
        redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo
      });
    } catch (error) {
      if (isAuthError(error)) {
        return {
          data: {
            properties: null,
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  // User Admin API
  /**
   * Creates a new user.
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async createUser(attributes) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/admin/users`, {
        body: attributes,
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Get a list of users.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
   */
  async listUsers(params) {
    var _a2, _b, _c, _d, _e, _f, _g;
    try {
      const pagination = { nextPage: null, lastPage: 0, total: 0 };
      const response = await _request(this.fetch, "GET", `${this.url}/admin/users`, {
        headers: this.headers,
        noResolveJson: true,
        query: {
          page: (_b = (_a2 = params === null || params === void 0 ? void 0 : params.page) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : "",
          per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
        },
        xform: _noResolveJsonResponse
      });
      if (response.error)
        throw response.error;
      const users = await response.json();
      const total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
      const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
      if (links.length > 0) {
        links.forEach((link) => {
          const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
          const rel = JSON.parse(link.split(";")[1].split("=")[1]);
          pagination[`${rel}Page`] = page;
        });
        pagination.total = parseInt(total);
      }
      return { data: Object.assign(Object.assign({}, users), pagination), error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { users: [] }, error };
      }
      throw error;
    }
  }
  /**
   * Get user by id.
   *
   * @param uid The user's unique identifier
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async getUserById(uid) {
    try {
      return await _request(this.fetch, "GET", `${this.url}/admin/users/${uid}`, {
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Updates the user data.
   *
   * @param attributes The data you want to update.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async updateUserById(uid, attributes) {
    try {
      return await _request(this.fetch, "PUT", `${this.url}/admin/users/${uid}`, {
        body: attributes,
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Delete a user. Requires a `service_role` key.
   *
   * @param id The user id you want to remove.
   * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.
   * Defaults to false for backward compatibility.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async deleteUser(id, shouldSoftDelete = false) {
    try {
      return await _request(this.fetch, "DELETE", `${this.url}/admin/users/${id}`, {
        headers: this.headers,
        body: {
          should_soft_delete: shouldSoftDelete
        },
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  async _listFactors(params) {
    try {
      const { data, error } = await _request(this.fetch, "GET", `${this.url}/admin/users/${params.userId}/factors`, {
        headers: this.headers,
        xform: (factors) => {
          return { data: { factors }, error: null };
        }
      });
      return { data, error };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  async _deleteFactor(params) {
    try {
      const data = await _request(this.fetch, "DELETE", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {
        headers: this.headers
      });
      return { data, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
};

// node_modules/@supabase/auth-js/dist/module/lib/local-storage.js
var localStorageAdapter = {
  getItem: (key) => {
    if (!supportsLocalStorage()) {
      return null;
    }
    return globalThis.localStorage.getItem(key);
  },
  setItem: (key, value) => {
    if (!supportsLocalStorage()) {
      return;
    }
    globalThis.localStorage.setItem(key, value);
  },
  removeItem: (key) => {
    if (!supportsLocalStorage()) {
      return;
    }
    globalThis.localStorage.removeItem(key);
  }
};
function memoryLocalStorageAdapter(store = {}) {
  return {
    getItem: (key) => {
      return store[key] || null;
    },
    setItem: (key, value) => {
      store[key] = value;
    },
    removeItem: (key) => {
      delete store[key];
    }
  };
}

// node_modules/@supabase/auth-js/dist/module/lib/polyfills.js
function polyfillGlobalThis() {
  if (typeof globalThis === "object")
    return;
  try {
    Object.defineProperty(Object.prototype, "__magic__", {
      get: function() {
        return this;
      },
      configurable: true
    });
    __magic__.globalThis = __magic__;
    delete Object.prototype.__magic__;
  } catch (e) {
    if (typeof self !== "undefined") {
      self.globalThis = self;
    }
  }
}

// node_modules/@supabase/auth-js/dist/module/lib/locks.js
var internals = {
  /**
   * @experimental
   */
  debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
var LockAcquireTimeoutError = class extends Error {
  constructor(message) {
    super(message);
    this.isAcquireTimeout = true;
  }
};
var NavigatorLockAcquireTimeoutError = class extends LockAcquireTimeoutError {
};
async function navigatorLock(name, acquireTimeout, fn) {
  if (internals.debug) {
    console.log("@supabase/gotrue-js: navigatorLock: acquire lock", name, acquireTimeout);
  }
  const abortController = new globalThis.AbortController();
  if (acquireTimeout > 0) {
    setTimeout(() => {
      abortController.abort();
      if (internals.debug) {
        console.log("@supabase/gotrue-js: navigatorLock acquire timed out", name);
      }
    }, acquireTimeout);
  }
  return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {
    mode: "exclusive",
    ifAvailable: true
  } : {
    mode: "exclusive",
    signal: abortController.signal
  }, async (lock) => {
    if (lock) {
      if (internals.debug) {
        console.log("@supabase/gotrue-js: navigatorLock: acquired", name, lock.name);
      }
      try {
        return await fn();
      } finally {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: released", name, lock.name);
        }
      }
    } else {
      if (acquireTimeout === 0) {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: not immediately available", name);
        }
        throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock "${name}" immediately failed`);
      } else {
        if (internals.debug) {
          try {
            const result = await globalThis.navigator.locks.query();
            console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(result, null, "  "));
          } catch (e) {
            console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", e);
          }
        }
        console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request");
        return await fn();
      }
    }
  }));
}

// node_modules/@supabase/auth-js/dist/module/GoTrueClient.js
polyfillGlobalThis();
var DEFAULT_OPTIONS = {
  url: GOTRUE_URL,
  storageKey: STORAGE_KEY,
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  headers: DEFAULT_HEADERS4,
  flowType: "implicit",
  debug: false,
  hasCustomAuthorizationHeader: false
};
var AUTO_REFRESH_TICK_DURATION = 30 * 1e3;
var AUTO_REFRESH_TICK_THRESHOLD = 3;
async function lockNoOp(name, acquireTimeout, fn) {
  return await fn();
}
var GoTrueClient = class {
  /**
   * Create a new client for use in the browser.
   */
  constructor(options) {
    var _a2, _b;
    this.memoryStorage = null;
    this.stateChangeEmitters = /* @__PURE__ */ new Map();
    this.autoRefreshTicker = null;
    this.visibilityChangedCallback = null;
    this.refreshingDeferred = null;
    this.initializePromise = null;
    this.detectSessionInUrl = true;
    this.hasCustomAuthorizationHeader = false;
    this.suppressGetSessionWarning = false;
    this.lockAcquired = false;
    this.pendingInLock = [];
    this.broadcastChannel = null;
    this.logger = console.log;
    this.instanceID = GoTrueClient.nextInstanceID;
    GoTrueClient.nextInstanceID += 1;
    if (this.instanceID > 0 && isBrowser()) {
      console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");
    }
    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    this.logDebugMessages = !!settings.debug;
    if (typeof settings.debug === "function") {
      this.logger = settings.debug;
    }
    this.persistSession = settings.persistSession;
    this.storageKey = settings.storageKey;
    this.autoRefreshToken = settings.autoRefreshToken;
    this.admin = new GoTrueAdminApi({
      url: settings.url,
      headers: settings.headers,
      fetch: settings.fetch
    });
    this.url = settings.url;
    this.headers = settings.headers;
    this.fetch = resolveFetch4(settings.fetch);
    this.lock = settings.lock || lockNoOp;
    this.detectSessionInUrl = settings.detectSessionInUrl;
    this.flowType = settings.flowType;
    this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;
    if (settings.lock) {
      this.lock = settings.lock;
    } else if (isBrowser() && ((_a2 = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a2 === void 0 ? void 0 : _a2.locks)) {
      this.lock = navigatorLock;
    } else {
      this.lock = lockNoOp;
    }
    this.mfa = {
      verify: this._verify.bind(this),
      enroll: this._enroll.bind(this),
      unenroll: this._unenroll.bind(this),
      challenge: this._challenge.bind(this),
      listFactors: this._listFactors.bind(this),
      challengeAndVerify: this._challengeAndVerify.bind(this),
      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)
    };
    if (this.persistSession) {
      if (settings.storage) {
        this.storage = settings.storage;
      } else {
        if (supportsLocalStorage()) {
          this.storage = localStorageAdapter;
        } else {
          this.memoryStorage = {};
          this.storage = memoryLocalStorageAdapter(this.memoryStorage);
        }
      }
    } else {
      this.memoryStorage = {};
      this.storage = memoryLocalStorageAdapter(this.memoryStorage);
    }
    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
      } catch (e) {
        console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", e);
      }
      (_b = this.broadcastChannel) === null || _b === void 0 ? void 0 : _b.addEventListener("message", async (event) => {
        this._debug("received broadcast notification from other tab or client", event);
        await this._notifyAllSubscribers(event.data.event, event.data.session, false);
      });
    }
    this.initialize();
  }
  _debug(...args) {
    if (this.logDebugMessages) {
      this.logger(`GoTrueClient@${this.instanceID} (${version4}) ${new Date().toISOString()}`, ...args);
    }
    return this;
  }
  /**
   * Initializes the client session either from the url or from storage.
   * This method is automatically called when instantiating the client, but should also be called
   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
   */
  async initialize() {
    if (this.initializePromise) {
      return await this.initializePromise;
    }
    this.initializePromise = (async () => {
      return await this._acquireLock(-1, async () => {
        return await this._initialize();
      });
    })();
    return await this.initializePromise;
  }
  /**
   * IMPORTANT:
   * 1. Never throw in this method, as it is called from the constructor
   * 2. Never return a session from this method as it would be cached over
   *    the whole lifetime of the client
   */
  async _initialize() {
    var _a2;
    try {
      const params = parseParametersFromURL(window.location.href);
      let callbackUrlType = "none";
      if (this._isImplicitGrantCallback(params)) {
        callbackUrlType = "implicit";
      } else if (await this._isPKCECallback(params)) {
        callbackUrlType = "pkce";
      }
      if (isBrowser() && this.detectSessionInUrl && callbackUrlType !== "none") {
        const { data, error } = await this._getSessionFromURL(params, callbackUrlType);
        if (error) {
          this._debug("#_initialize()", "error detecting session from URL", error);
          if (isAuthImplicitGrantRedirectError(error)) {
            const errorCode = (_a2 = error.details) === null || _a2 === void 0 ? void 0 : _a2.code;
            if (errorCode === "identity_already_exists" || errorCode === "identity_not_found" || errorCode === "single_identity_not_deletable") {
              return { error };
            }
          }
          await this._removeSession();
          return { error };
        }
        const { session, redirectType } = data;
        this._debug("#_initialize()", "detected session in URL", session, "redirect type", redirectType);
        await this._saveSession(session);
        setTimeout(async () => {
          if (redirectType === "recovery") {
            await this._notifyAllSubscribers("PASSWORD_RECOVERY", session);
          } else {
            await this._notifyAllSubscribers("SIGNED_IN", session);
          }
        }, 0);
        return { error: null };
      }
      await this._recoverAndRefresh();
      return { error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { error };
      }
      return {
        error: new AuthUnknownError("Unexpected error during initialization", error)
      };
    } finally {
      await this._handleVisibilityChange();
      this._debug("#_initialize()", "end");
    }
  }
  /**
   * Creates a new anonymous user.
   *
   * @returns A session where the is_anonymous claim in the access token JWT set to true
   */
  async signInAnonymously(credentials) {
    var _a2, _b, _c;
    try {
      const res = await _request(this.fetch, "POST", `${this.url}/signup`, {
        headers: this.headers,
        body: {
          data: (_b = (_a2 = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a2 === void 0 ? void 0 : _a2.data) !== null && _b !== void 0 ? _b : {},
          gotrue_meta_security: { captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken }
        },
        xform: _sessionResponse
      });
      const { data, error } = res;
      if (error || !data) {
        return { data: { user: null, session: null }, error };
      }
      const session = data.session;
      const user = data.user;
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return { data: { user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Creates a new user.
   *
   * Be aware that if a user account exists in the system you may get back an
   * error message that attempts to hide this information from the user.
   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
   *
   * @returns A logged-in session if the server has "autoconfirm" ON
   * @returns A user if the server has "autoconfirm" OFF
   */
  async signUp(credentials) {
    var _a2, _b, _c;
    try {
      let res;
      if ("email" in credentials) {
        const { email, password, options } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        res = await _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: {
            email,
            password,
            data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          xform: _sessionResponse
        });
      } else if ("phone" in credentials) {
        const { phone, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone,
            password,
            data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},
            channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : "sms",
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponse
        });
      } else {
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
      }
      const { data, error } = res;
      if (error || !data) {
        return { data: { user: null, session: null }, error };
      }
      const session = data.session;
      const user = data.user;
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return { data: { user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in an existing user with an email and password or phone and password.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or that the
   * email/phone and password combination is wrong or that the account can only
   * be accessed via social login.
   */
  async signInWithPassword(credentials) {
    try {
      let res;
      if ("email" in credentials) {
        const { email, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            email,
            password,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponsePassword
        });
      } else if ("phone" in credentials) {
        const { phone, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            phone,
            password,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponsePassword
        });
      } else {
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
      }
      const { data, error } = res;
      if (error) {
        return { data: { user: null, session: null }, error };
      } else if (!data || !data.session || !data.user) {
        return { data: { user: null, session: null }, error: new AuthInvalidTokenResponseError() };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return {
        data: Object.assign({ user: data.user, session: data.session }, data.weak_password ? { weakPassword: data.weak_password } : null),
        error
      };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in an existing user via a third-party provider.
   * This method supports the PKCE flow.
   */
  async signInWithOAuth(credentials) {
    var _a2, _b, _c, _d;
    return await this._handleProviderSignIn(credentials.provider, {
      redirectTo: (_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo,
      scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
      queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
      skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect
    });
  }
  /**
   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
   */
  async exchangeCodeForSession(authCode) {
    await this.initializePromise;
    return this._acquireLock(-1, async () => {
      return this._exchangeCodeForSession(authCode);
    });
  }
  async _exchangeCodeForSession(authCode) {
    const storageItem = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : "").split("/");
    try {
      const { data, error } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
        headers: this.headers,
        body: {
          auth_code: authCode,
          code_verifier: codeVerifier
        },
        xform: _sessionResponse
      });
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (error) {
        throw error;
      }
      if (!data || !data.session || !data.user) {
        return {
          data: { user: null, session: null, redirectType: null },
          error: new AuthInvalidTokenResponseError()
        };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return { data: Object.assign(Object.assign({}, data), { redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null }), error };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null, redirectType: null }, error };
      }
      throw error;
    }
  }
  /**
   * Allows signing in with an OIDC ID token. The authentication provider used
   * should be enabled and configured.
   */
  async signInWithIdToken(credentials) {
    try {
      const { options, provider, token, access_token, nonce } = credentials;
      const res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
        headers: this.headers,
        body: {
          provider,
          id_token: token,
          access_token,
          nonce,
          gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
        },
        xform: _sessionResponse
      });
      const { data, error } = res;
      if (error) {
        return { data: { user: null, session: null }, error };
      } else if (!data || !data.session || !data.user) {
        return {
          data: { user: null, session: null },
          error: new AuthInvalidTokenResponseError()
        };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return { data, error };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in a user using magiclink or a one-time password (OTP).
   *
   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or, that the account
   * can only be accessed via social login.
   *
   * Do note that you will need to configure a Whatsapp sender on Twilio
   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
   * channel is not supported on other providers
   * at this time.
   * This method supports PKCE when an email is passed.
   */
  async signInWithOtp(credentials) {
    var _a2, _b, _c, _d, _e;
    try {
      if ("email" in credentials) {
        const { email, options } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        const { error } = await _request(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email,
            data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
            create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return { data: { user: null, session: null }, error };
      }
      if ("phone" in credentials) {
        const { phone, options } = credentials;
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            phone,
            data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},
            create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : "sms"
          }
        });
        return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error };
      }
      throw new AuthInvalidCredentialsError("You must provide either an email or phone number.");
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in a user given a User supplied OTP or TokenHash received through mobile or email.
   */
  async verifyOtp(params) {
    var _a2, _b;
    try {
      let redirectTo = void 0;
      let captchaToken = void 0;
      if ("options" in params) {
        redirectTo = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo;
        captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;
      }
      const { data, error } = await _request(this.fetch, "POST", `${this.url}/verify`, {
        headers: this.headers,
        body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: captchaToken } }),
        redirectTo,
        xform: _sessionResponse
      });
      if (error) {
        throw error;
      }
      if (!data) {
        throw new Error("An error occurred on token verification.");
      }
      const session = data.session;
      const user = data.user;
      if (session === null || session === void 0 ? void 0 : session.access_token) {
        await this._saveSession(session);
        await this._notifyAllSubscribers(params.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", session);
      }
      return { data: { user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Attempts a single-sign on using an enterprise Identity Provider. A
   * successful SSO attempt will redirect the current page to the identity
   * provider authorization page. The redirect URL is implementation and SSO
   * protocol specific.
   *
   * You can use it by providing a SSO domain. Typically you can extract this
   * domain by asking users for their email address. If this domain is
   * registered on the Auth instance the redirect will use that organization's
   * currently active SSO Identity Provider for the login.
   *
   * If you have built an organization-specific login page, you can use the
   * organization's SSO Identity Provider UUID directly instead.
   */
  async signInWithSSO(params) {
    var _a2, _b, _c;
    try {
      let codeChallenge = null;
      let codeChallengeMethod = null;
      if (this.flowType === "pkce") {
        ;
        [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
      }
      return await _request(this.fetch, "POST", `${this.url}/sso`, {
        body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in params ? { provider_id: params.providerId } : null), "domain" in params ? { domain: params.domain } : null), { redirect_to: (_b = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo) !== null && _b !== void 0 ? _b : void 0 }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } } : null), { skip_http_redirect: true, code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
        headers: this.headers,
        xform: _ssoResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Sends a reauthentication OTP to the user's email or phone number.
   * Requires the user to be signed-in.
   */
  async reauthenticate() {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._reauthenticate();
    });
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError)
          throw sessionError;
        if (!session)
          throw new AuthSessionMissingError();
        const { error } = await _request(this.fetch, "GET", `${this.url}/reauthenticate`, {
          headers: this.headers,
          jwt: session.access_token
        });
        return { data: { user: null, session: null }, error };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
   */
  async resend(credentials) {
    try {
      const endpoint = `${this.url}/resend`;
      if ("email" in credentials) {
        const { email, type, options } = credentials;
        const { error } = await _request(this.fetch, "POST", endpoint, {
          headers: this.headers,
          body: {
            email,
            type,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return { data: { user: null, session: null }, error };
      } else if ("phone" in credentials) {
        const { phone, type, options } = credentials;
        const { data, error } = await _request(this.fetch, "POST", endpoint, {
          headers: this.headers,
          body: {
            phone,
            type,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          }
        });
        return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error };
      }
      throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a type");
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Returns the session, refreshing it if necessary.
   *
   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
   *
   * **IMPORTANT:** This method loads values directly from the storage attached
   * to the client. If that storage is based on request cookies for example,
   * the values in it may not be authentic and therefore it's strongly advised
   * against using this method and its results in such circumstances. A warning
   * will be emitted if this is detected. Use {@link #getUser()} instead.
   */
  async getSession() {
    await this.initializePromise;
    const result = await this._acquireLock(-1, async () => {
      return this._useSession(async (result2) => {
        return result2;
      });
    });
    return result;
  }
  /**
   * Acquires a global lock based on the storage key.
   */
  async _acquireLock(acquireTimeout, fn) {
    this._debug("#_acquireLock", "begin", acquireTimeout);
    try {
      if (this.lockAcquired) {
        const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
        const result = (async () => {
          await last;
          return await fn();
        })();
        this.pendingInLock.push((async () => {
          try {
            await result;
          } catch (e) {
          }
        })());
        return result;
      }
      return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async () => {
        this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
        try {
          this.lockAcquired = true;
          const result = fn();
          this.pendingInLock.push((async () => {
            try {
              await result;
            } catch (e) {
            }
          })());
          await result;
          while (this.pendingInLock.length) {
            const waitOn = [...this.pendingInLock];
            await Promise.all(waitOn);
            this.pendingInLock.splice(0, waitOn.length);
          }
          return await result;
        } finally {
          this._debug("#_acquireLock", "lock released for storage key", this.storageKey);
          this.lockAcquired = false;
        }
      });
    } finally {
      this._debug("#_acquireLock", "end");
    }
  }
  /**
   * Use instead of {@link #getSession} inside the library. It is
   * semantically usually what you want, as getting a session involves some
   * processing afterwards that requires only one client operating on the
   * session at once across multiple tabs or processes.
   */
  async _useSession(fn) {
    this._debug("#_useSession", "begin");
    try {
      const result = await this.__loadSession();
      return await fn(result);
    } finally {
      this._debug("#_useSession", "end");
    }
  }
  /**
   * NEVER USE DIRECTLY!
   *
   * Always use {@link #_useSession}.
   */
  async __loadSession() {
    this._debug("#__loadSession()", "begin");
    if (!this.lockAcquired) {
      this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
    }
    try {
      let currentSession = null;
      const maybeSession = await getItemAsync(this.storage, this.storageKey);
      this._debug("#getSession()", "session from storage", maybeSession);
      if (maybeSession !== null) {
        if (this._isValidSession(maybeSession)) {
          currentSession = maybeSession;
        } else {
          this._debug("#getSession()", "session from storage is not valid");
          await this._removeSession();
        }
      }
      if (!currentSession) {
        return { data: { session: null }, error: null };
      }
      const hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1e3 : false;
      this._debug("#__loadSession()", `session has${hasExpired ? "" : " not"} expired`, "expires_at", currentSession.expires_at);
      if (!hasExpired) {
        if (this.storage.isServer) {
          let suppressWarning = this.suppressGetSessionWarning;
          const proxySession = new Proxy(currentSession, {
            get: (target, prop, receiver) => {
              if (!suppressWarning && prop === "user") {
                console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.");
                suppressWarning = true;
                this.suppressGetSessionWarning = true;
              }
              return Reflect.get(target, prop, receiver);
            }
          });
          currentSession = proxySession;
        }
        return { data: { session: currentSession }, error: null };
      }
      const { session, error } = await this._callRefreshToken(currentSession.refresh_token);
      if (error) {
        return { data: { session: null }, error };
      }
      return { data: { session }, error: null };
    } finally {
      this._debug("#__loadSession()", "end");
    }
  }
  /**
   * Gets the current user details if there is an existing session. This method
   * performs a network request to the Supabase Auth server, so the returned
   * value is authentic and can be used to base authorization rules on.
   *
   * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.
   */
  async getUser(jwt) {
    if (jwt) {
      return await this._getUser(jwt);
    }
    await this.initializePromise;
    const result = await this._acquireLock(-1, async () => {
      return await this._getUser();
    });
    return result;
  }
  async _getUser(jwt) {
    try {
      if (jwt) {
        return await _request(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt,
          xform: _userResponse
        });
      }
      return await this._useSession(async (result) => {
        var _a2, _b, _c;
        const { data, error } = result;
        if (error) {
          throw error;
        }
        if (!((_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) && !this.hasCustomAuthorizationHeader) {
          return { data: { user: null }, error: new AuthSessionMissingError() };
        }
        return await _request(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : void 0,
          xform: _userResponse
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        if (isAuthSessionMissingError(error)) {
          await this._removeSession();
          await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        }
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Updates user data for a logged in user.
   */
  async updateUser(attributes, options = {}) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._updateUser(attributes, options);
    });
  }
  async _updateUser(attributes, options = {}) {
    try {
      return await this._useSession(async (result) => {
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          throw sessionError;
        }
        if (!sessionData.session) {
          throw new AuthSessionMissingError();
        }
        const session = sessionData.session;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce" && attributes.email != null) {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        const { data, error: userError } = await _request(this.fetch, "PUT", `${this.url}/user`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: Object.assign(Object.assign({}, attributes), { code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
          jwt: session.access_token,
          xform: _userResponse
        });
        if (userError)
          throw userError;
        session.user = data.user;
        await this._saveSession(session);
        await this._notifyAllSubscribers("USER_UPDATED", session);
        return { data: { user: session.user }, error: null };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Decodes a JWT (without performing any validation).
   */
  _decodeJWT(jwt) {
    return decodeJWTPayload(jwt);
  }
  /**
   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
   * If the refresh token or access token in the current session is invalid, an error will be thrown.
   * @param currentSession The current session that minimally contains an access token and refresh token.
   */
  async setSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._setSession(currentSession);
    });
  }
  async _setSession(currentSession) {
    try {
      if (!currentSession.access_token || !currentSession.refresh_token) {
        throw new AuthSessionMissingError();
      }
      const timeNow = Date.now() / 1e3;
      let expiresAt2 = timeNow;
      let hasExpired = true;
      let session = null;
      const payload = decodeJWTPayload(currentSession.access_token);
      if (payload.exp) {
        expiresAt2 = payload.exp;
        hasExpired = expiresAt2 <= timeNow;
      }
      if (hasExpired) {
        const { session: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return { data: { user: null, session: null }, error };
        }
        if (!refreshedSession) {
          return { data: { user: null, session: null }, error: null };
        }
        session = refreshedSession;
      } else {
        const { data, error } = await this._getUser(currentSession.access_token);
        if (error) {
          throw error;
        }
        session = {
          access_token: currentSession.access_token,
          refresh_token: currentSession.refresh_token,
          user: data.user,
          token_type: "bearer",
          expires_in: expiresAt2 - timeNow,
          expires_at: expiresAt2
        };
        await this._saveSession(session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return { data: { user: session.user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { session: null, user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Returns a new session, regardless of expiry status.
   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
   * If the current session's refresh token is invalid, an error will be thrown.
   * @param currentSession The current session. If passed in, it must contain a refresh token.
   */
  async refreshSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._refreshSession(currentSession);
    });
  }
  async _refreshSession(currentSession) {
    try {
      return await this._useSession(async (result) => {
        var _a2;
        if (!currentSession) {
          const { data, error: error2 } = result;
          if (error2) {
            throw error2;
          }
          currentSession = (_a2 = data.session) !== null && _a2 !== void 0 ? _a2 : void 0;
        }
        if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {
          throw new AuthSessionMissingError();
        }
        const { session, error } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return { data: { user: null, session: null }, error };
        }
        if (!session) {
          return { data: { user: null, session: null }, error: null };
        }
        return { data: { user: session.user, session }, error: null };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Gets the session data from a URL string
   */
  async _getSessionFromURL(params, callbackUrlType) {
    try {
      if (!isBrowser())
        throw new AuthImplicitGrantRedirectError("No browser detected.");
      if (params.error || params.error_description || params.error_code) {
        throw new AuthImplicitGrantRedirectError(params.error_description || "Error in URL with unspecified error_description", {
          error: params.error || "unspecified_error",
          code: params.error_code || "unspecified_code"
        });
      }
      switch (callbackUrlType) {
        case "implicit":
          if (this.flowType === "pkce") {
            throw new AuthPKCEGrantCodeExchangeError("Not a valid PKCE flow url.");
          }
          break;
        case "pkce":
          if (this.flowType === "implicit") {
            throw new AuthImplicitGrantRedirectError("Not a valid implicit grant flow url.");
          }
          break;
        default:
      }
      if (callbackUrlType === "pkce") {
        this._debug("#_initialize()", "begin", "is PKCE flow", true);
        if (!params.code)
          throw new AuthPKCEGrantCodeExchangeError("No code detected.");
        const { data: data2, error: error2 } = await this._exchangeCodeForSession(params.code);
        if (error2)
          throw error2;
        const url = new URL(window.location.href);
        url.searchParams.delete("code");
        window.history.replaceState(window.history.state, "", url.toString());
        return { data: { session: data2.session, redirectType: null }, error: null };
      }
      const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;
      if (!access_token || !expires_in || !refresh_token || !token_type) {
        throw new AuthImplicitGrantRedirectError("No session defined in URL");
      }
      const timeNow = Math.round(Date.now() / 1e3);
      const expiresIn = parseInt(expires_in);
      let expiresAt2 = timeNow + expiresIn;
      if (expires_at) {
        expiresAt2 = parseInt(expires_at);
      }
      const actuallyExpiresIn = expiresAt2 - timeNow;
      if (actuallyExpiresIn * 1e3 <= AUTO_REFRESH_TICK_DURATION) {
        console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);
      }
      const issuedAt = expiresAt2 - expiresIn;
      if (timeNow - issuedAt >= 120) {
        console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", issuedAt, expiresAt2, timeNow);
      } else if (timeNow - issuedAt < 0) {
        console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", issuedAt, expiresAt2, timeNow);
      }
      const { data, error } = await this._getUser(access_token);
      if (error)
        throw error;
      const session = {
        provider_token,
        provider_refresh_token,
        access_token,
        expires_in: expiresIn,
        expires_at: expiresAt2,
        refresh_token,
        token_type,
        user: data.user
      };
      window.location.hash = "";
      this._debug("#_getSessionFromURL()", "clearing window.location.hash");
      return { data: { session, redirectType: params.type }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { session: null, redirectType: null }, error };
      }
      throw error;
    }
  }
  /**
   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
   */
  _isImplicitGrantCallback(params) {
    return Boolean(params.access_token || params.error_description);
  }
  /**
   * Checks if the current URL and backing storage contain parameters given by a PKCE flow
   */
  async _isPKCECallback(params) {
    const currentStorageContent = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    return !!(params.code && currentStorageContent);
  }
  /**
   * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
   *
   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
   *
   * If using `others` scope, no `SIGNED_OUT` event is fired!
   */
  async signOut(options = { scope: "global" }) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._signOut(options);
    });
  }
  async _signOut({ scope } = { scope: "global" }) {
    return await this._useSession(async (result) => {
      var _a2;
      const { data, error: sessionError } = result;
      if (sessionError) {
        return { error: sessionError };
      }
      const accessToken = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token;
      if (accessToken) {
        const { error } = await this.admin.signOut(accessToken, scope);
        if (error) {
          if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401 || error.status === 403))) {
            return { error };
          }
        }
      }
      if (scope !== "others") {
        await this._removeSession();
        await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      }
      return { error: null };
    });
  }
  /**
   * Receive a notification every time an auth event happens.
   * @param callback A callback function to be invoked when an auth event happens.
   */
  onAuthStateChange(callback) {
    const id = uuid();
    const subscription = {
      id,
      callback,
      unsubscribe: () => {
        this._debug("#unsubscribe()", "state change callback with id removed", id);
        this.stateChangeEmitters.delete(id);
      }
    };
    this._debug("#onAuthStateChange()", "registered callback with id", id);
    this.stateChangeEmitters.set(id, subscription);
    (async () => {
      await this.initializePromise;
      await this._acquireLock(-1, async () => {
        this._emitInitialSession(id);
      });
    })();
    return { data: { subscription } };
  }
  async _emitInitialSession(id) {
    return await this._useSession(async (result) => {
      var _a2, _b;
      try {
        const { data: { session }, error } = result;
        if (error)
          throw error;
        await ((_a2 = this.stateChangeEmitters.get(id)) === null || _a2 === void 0 ? void 0 : _a2.callback("INITIAL_SESSION", session));
        this._debug("INITIAL_SESSION", "callback id", id, "session", session);
      } catch (err) {
        await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback("INITIAL_SESSION", null));
        this._debug("INITIAL_SESSION", "callback id", id, "error", err);
        console.error(err);
      }
    });
  }
  /**
   * Sends a password reset request to an email address. This method supports the PKCE flow.
   *
   * @param email The email address of the user.
   * @param options.redirectTo The URL to send the user to after they click the password reset link.
   * @param options.captchaToken Verification token received when the user completes the captcha on the site.
   */
  async resetPasswordForEmail(email, options = {}) {
    let codeChallenge = null;
    let codeChallengeMethod = null;
    if (this.flowType === "pkce") {
      ;
      [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(
        this.storage,
        this.storageKey,
        true
        // isPasswordRecovery
      );
    }
    try {
      return await _request(this.fetch, "POST", `${this.url}/recover`, {
        body: {
          email,
          code_challenge: codeChallenge,
          code_challenge_method: codeChallengeMethod,
          gotrue_meta_security: { captcha_token: options.captchaToken }
        },
        headers: this.headers,
        redirectTo: options.redirectTo
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Gets all the identities linked to a user.
   */
  async getUserIdentities() {
    var _a2;
    try {
      const { data, error } = await this.getUser();
      if (error)
        throw error;
      return { data: { identities: (_a2 = data.user.identities) !== null && _a2 !== void 0 ? _a2 : [] }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Links an oauth identity to an existing user.
   * This method supports the PKCE flow.
   */
  async linkIdentity(credentials) {
    var _a2;
    try {
      const { data, error } = await this._useSession(async (result) => {
        var _a3, _b, _c, _d, _e;
        const { data: data2, error: error2 } = result;
        if (error2)
          throw error2;
        const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {
          redirectTo: (_a3 = credentials.options) === null || _a3 === void 0 ? void 0 : _a3.redirectTo,
          scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
          queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
          skipBrowserRedirect: true
        });
        return await _request(this.fetch, "GET", url, {
          headers: this.headers,
          jwt: (_e = (_d = data2.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : void 0
        });
      });
      if (error)
        throw error;
      if (isBrowser() && !((_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.skipBrowserRedirect)) {
        window.location.assign(data === null || data === void 0 ? void 0 : data.url);
      }
      return { data: { provider: credentials.provider, url: data === null || data === void 0 ? void 0 : data.url }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { provider: credentials.provider, url: null }, error };
      }
      throw error;
    }
  }
  /**
   * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.
   */
  async unlinkIdentity(identity) {
    try {
      return await this._useSession(async (result) => {
        var _a2, _b;
        const { data, error } = result;
        if (error) {
          throw error;
        }
        return await _request(this.fetch, "DELETE", `${this.url}/user/identities/${identity.identity_id}`, {
          headers: this.headers,
          jwt: (_b = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b !== void 0 ? _b : void 0
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Generates a new JWT.
   * @param refreshToken A valid refresh token that was returned on login.
   */
  async _refreshAccessToken(refreshToken) {
    const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, "begin");
    try {
      const startedAt = Date.now();
      return await retryable(async (attempt) => {
        if (attempt > 0) {
          await sleep(200 * Math.pow(2, attempt - 1));
        }
        this._debug(debugName, "refreshing attempt", attempt);
        return await _request(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
          body: { refresh_token: refreshToken },
          headers: this.headers,
          xform: _sessionResponse
        });
      }, (attempt, error) => {
        const nextBackOffInterval = 200 * Math.pow(2, attempt);
        return error && isAuthRetryableFetchError(error) && // retryable only if the request can be sent before the backoff overflows the tick duration
        Date.now() + nextBackOffInterval - startedAt < AUTO_REFRESH_TICK_DURATION;
      });
    } catch (error) {
      this._debug(debugName, "error", error);
      if (isAuthError(error)) {
        return { data: { session: null, user: null }, error };
      }
      throw error;
    } finally {
      this._debug(debugName, "end");
    }
  }
  _isValidSession(maybeSession) {
    const isValidSession = typeof maybeSession === "object" && maybeSession !== null && "access_token" in maybeSession && "refresh_token" in maybeSession && "expires_at" in maybeSession;
    return isValidSession;
  }
  async _handleProviderSignIn(provider, options) {
    const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {
      redirectTo: options.redirectTo,
      scopes: options.scopes,
      queryParams: options.queryParams
    });
    this._debug("#_handleProviderSignIn()", "provider", provider, "options", options, "url", url);
    if (isBrowser() && !options.skipBrowserRedirect) {
      window.location.assign(url);
    }
    return { data: { provider, url }, error: null };
  }
  /**
   * Recovers the session from LocalStorage and refreshes the token
   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
   */
  async _recoverAndRefresh() {
    var _a2;
    const debugName = "#_recoverAndRefresh()";
    this._debug(debugName, "begin");
    try {
      const currentSession = await getItemAsync(this.storage, this.storageKey);
      this._debug(debugName, "session from storage", currentSession);
      if (!this._isValidSession(currentSession)) {
        this._debug(debugName, "session is not valid");
        if (currentSession !== null) {
          await this._removeSession();
        }
        return;
      }
      const timeNow = Math.round(Date.now() / 1e3);
      const expiresWithMargin = ((_a2 = currentSession.expires_at) !== null && _a2 !== void 0 ? _a2 : Infinity) < timeNow + EXPIRY_MARGIN;
      this._debug(debugName, `session has${expiresWithMargin ? "" : " not"} expired with margin of ${EXPIRY_MARGIN}s`);
      if (expiresWithMargin) {
        if (this.autoRefreshToken && currentSession.refresh_token) {
          const { error } = await this._callRefreshToken(currentSession.refresh_token);
          if (error) {
            console.error(error);
            if (!isAuthRetryableFetchError(error)) {
              this._debug(debugName, "refresh failed with a non-retryable error, removing the session", error);
              await this._removeSession();
            }
          }
        }
      } else {
        await this._notifyAllSubscribers("SIGNED_IN", currentSession);
      }
    } catch (err) {
      this._debug(debugName, "error", err);
      console.error(err);
      return;
    } finally {
      this._debug(debugName, "end");
    }
  }
  async _callRefreshToken(refreshToken) {
    var _a2, _b;
    if (!refreshToken) {
      throw new AuthSessionMissingError();
    }
    if (this.refreshingDeferred) {
      return this.refreshingDeferred.promise;
    }
    const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, "begin");
    try {
      this.refreshingDeferred = new Deferred();
      const { data, error } = await this._refreshAccessToken(refreshToken);
      if (error)
        throw error;
      if (!data.session)
        throw new AuthSessionMissingError();
      await this._saveSession(data.session);
      await this._notifyAllSubscribers("TOKEN_REFRESHED", data.session);
      const result = { session: data.session, error: null };
      this.refreshingDeferred.resolve(result);
      return result;
    } catch (error) {
      this._debug(debugName, "error", error);
      if (isAuthError(error)) {
        const result = { session: null, error };
        if (!isAuthRetryableFetchError(error)) {
          await this._removeSession();
        }
        (_a2 = this.refreshingDeferred) === null || _a2 === void 0 ? void 0 : _a2.resolve(result);
        return result;
      }
      (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);
      throw error;
    } finally {
      this.refreshingDeferred = null;
      this._debug(debugName, "end");
    }
  }
  async _notifyAllSubscribers(event, session, broadcast = true) {
    const debugName = `#_notifyAllSubscribers(${event})`;
    this._debug(debugName, "begin", session, `broadcast = ${broadcast}`);
    try {
      if (this.broadcastChannel && broadcast) {
        this.broadcastChannel.postMessage({ event, session });
      }
      const errors = [];
      const promises = Array.from(this.stateChangeEmitters.values()).map(async (x) => {
        try {
          await x.callback(event, session);
        } catch (e) {
          errors.push(e);
        }
      });
      await Promise.all(promises);
      if (errors.length > 0) {
        for (let i = 0; i < errors.length; i += 1) {
          console.error(errors[i]);
        }
        throw errors[0];
      }
    } finally {
      this._debug(debugName, "end");
    }
  }
  /**
   * set currentSession and currentUser
   * process to _startAutoRefreshToken if possible
   */
  async _saveSession(session) {
    this._debug("#_saveSession()", session);
    this.suppressGetSessionWarning = true;
    await setItemAsync(this.storage, this.storageKey, session);
  }
  async _removeSession() {
    this._debug("#_removeSession()");
    await removeItemAsync(this.storage, this.storageKey);
    await this._notifyAllSubscribers("SIGNED_OUT", null);
  }
  /**
   * Removes any registered visibilitychange callback.
   *
   * {@see #startAutoRefresh}
   * {@see #stopAutoRefresh}
   */
  _removeVisibilityChangedCallback() {
    this._debug("#_removeVisibilityChangedCallback()");
    const callback = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {
        window.removeEventListener("visibilitychange", callback);
      }
    } catch (e) {
      console.error("removing visibilitychange callback failed", e);
    }
  }
  /**
   * This is the private implementation of {@link #startAutoRefresh}. Use this
   * within the library.
   */
  async _startAutoRefresh() {
    await this._stopAutoRefresh();
    this._debug("#_startAutoRefresh()");
    const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION);
    this.autoRefreshTicker = ticker;
    if (ticker && typeof ticker === "object" && typeof ticker.unref === "function") {
      ticker.unref();
    } else if (typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function") {
      Deno.unrefTimer(ticker);
    }
    setTimeout(async () => {
      await this.initializePromise;
      await this._autoRefreshTokenTick();
    }, 0);
  }
  /**
   * This is the private implementation of {@link #stopAutoRefresh}. Use this
   * within the library.
   */
  async _stopAutoRefresh() {
    this._debug("#_stopAutoRefresh()");
    const ticker = this.autoRefreshTicker;
    this.autoRefreshTicker = null;
    if (ticker) {
      clearInterval(ticker);
    }
  }
  /**
   * Starts an auto-refresh process in the background. The session is checked
   * every few seconds. Close to the time of expiration a process is started to
   * refresh the session. If refreshing fails it will be retried for as long as
   * necessary.
   *
   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
   * to call this function, it will be called for you.
   *
   * On browsers the refresh process works only when the tab/window is in the
   * foreground to conserve resources as well as prevent race conditions and
   * flooding auth with requests. If you call this method any managed
   * visibility change callback will be removed and you must manage visibility
   * changes on your own.
   *
   * On non-browser platforms the refresh process works *continuously* in the
   * background, which may not be desirable. You should hook into your
   * platform's foreground indication mechanism and call these methods
   * appropriately to conserve resources.
   *
   * {@see #stopAutoRefresh}
   */
  async startAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._startAutoRefresh();
  }
  /**
   * Stops an active auto refresh process running in the background (if any).
   *
   * If you call this method any managed visibility change callback will be
   * removed and you must manage visibility changes on your own.
   *
   * See {@link #startAutoRefresh} for more details.
   */
  async stopAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._stopAutoRefresh();
  }
  /**
   * Runs the auto refresh token tick.
   */
  async _autoRefreshTokenTick() {
    this._debug("#_autoRefreshTokenTick()", "begin");
    try {
      await this._acquireLock(0, async () => {
        try {
          const now = Date.now();
          try {
            return await this._useSession(async (result) => {
              const { data: { session } } = result;
              if (!session || !session.refresh_token || !session.expires_at) {
                this._debug("#_autoRefreshTokenTick()", "no session");
                return;
              }
              const expiresInTicks = Math.floor((session.expires_at * 1e3 - now) / AUTO_REFRESH_TICK_DURATION);
              this._debug("#_autoRefreshTokenTick()", `access token expires in ${expiresInTicks} ticks, a tick lasts ${AUTO_REFRESH_TICK_DURATION}ms, refresh threshold is ${AUTO_REFRESH_TICK_THRESHOLD} ticks`);
              if (expiresInTicks <= AUTO_REFRESH_TICK_THRESHOLD) {
                await this._callRefreshToken(session.refresh_token);
              }
            });
          } catch (e) {
            console.error("Auto refresh tick failed with error. This is likely a transient error.", e);
          }
        } finally {
          this._debug("#_autoRefreshTokenTick()", "end");
        }
      });
    } catch (e) {
      if (e.isAcquireTimeout || e instanceof LockAcquireTimeoutError) {
        this._debug("auto refresh token tick lock not available");
      } else {
        throw e;
      }
    }
  }
  /**
   * Registers callbacks on the browser / platform, which in-turn run
   * algorithms when the browser window/tab are in foreground. On non-browser
   * platforms it assumes always foreground.
   */
  async _handleVisibilityChange() {
    this._debug("#_handleVisibilityChange()");
    if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
      if (this.autoRefreshToken) {
        this.startAutoRefresh();
      }
      return false;
    }
    try {
      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false);
      window === null || window === void 0 ? void 0 : window.addEventListener("visibilitychange", this.visibilityChangedCallback);
      await this._onVisibilityChanged(true);
    } catch (error) {
      console.error("_handleVisibilityChange", error);
    }
  }
  /**
   * Callback registered with `window.addEventListener('visibilitychange')`.
   */
  async _onVisibilityChanged(calledFromInitialize) {
    const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
    this._debug(methodName, "visibilityState", document.visibilityState);
    if (document.visibilityState === "visible") {
      if (this.autoRefreshToken) {
        this._startAutoRefresh();
      }
      if (!calledFromInitialize) {
        await this.initializePromise;
        await this._acquireLock(-1, async () => {
          if (document.visibilityState !== "visible") {
            this._debug(methodName, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
            return;
          }
          await this._recoverAndRefresh();
        });
      }
    } else if (document.visibilityState === "hidden") {
      if (this.autoRefreshToken) {
        this._stopAutoRefresh();
      }
    }
  }
  /**
   * Generates the relevant login URL for a third-party provider.
   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
   * @param options.scopes A space-separated list of scopes granted to the OAuth application.
   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
   */
  async _getUrlForProvider(url, provider, options) {
    const urlParams = [`provider=${encodeURIComponent(provider)}`];
    if (options === null || options === void 0 ? void 0 : options.redirectTo) {
      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
    }
    if (options === null || options === void 0 ? void 0 : options.scopes) {
      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
    }
    if (this.flowType === "pkce") {
      const [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
      const flowParams = new URLSearchParams({
        code_challenge: `${encodeURIComponent(codeChallenge)}`,
        code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`
      });
      urlParams.push(flowParams.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.queryParams) {
      const query = new URLSearchParams(options.queryParams);
      urlParams.push(query.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {
      urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);
    }
    return `${url}?${urlParams.join("&")}`;
  }
  async _unenroll(params) {
    try {
      return await this._useSession(async (result) => {
        var _a2;
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          return { data: null, error: sessionError };
        }
        return await _request(this.fetch, "DELETE", `${this.url}/factors/${params.factorId}`, {
          headers: this.headers,
          jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  async _enroll(params) {
    try {
      return await this._useSession(async (result) => {
        var _a2, _b;
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          return { data: null, error: sessionError };
        }
        const body = Object.assign({ friendly_name: params.friendlyName, factor_type: params.factorType }, params.factorType === "phone" ? { phone: params.phone } : { issuer: params.issuer });
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/factors`, {
          body,
          headers: this.headers,
          jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
        });
        if (error) {
          return { data: null, error };
        }
        if (params.factorType === "totp" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {
          data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;
        }
        return { data, error: null };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * {@see GoTrueMFAApi#verify}
   */
  async _verify(params) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (result) => {
          var _a2;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return { data: null, error: sessionError };
          }
          const { data, error } = await _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/verify`, {
            body: { code: params.code, challenge_id: params.challengeId },
            headers: this.headers,
            jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
          });
          if (error) {
            return { data: null, error };
          }
          await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + data.expires_in }, data));
          await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", data);
          return { data, error };
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challenge}
   */
  async _challenge(params) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (result) => {
          var _a2;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return { data: null, error: sessionError };
          }
          return await _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/challenge`, {
            body: { channel: params.channel },
            headers: this.headers,
            jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
          });
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challengeAndVerify}
   */
  async _challengeAndVerify(params) {
    const { data: challengeData, error: challengeError } = await this._challenge({
      factorId: params.factorId
    });
    if (challengeError) {
      return { data: null, error: challengeError };
    }
    return await this._verify({
      factorId: params.factorId,
      challengeId: challengeData.id,
      code: params.code
    });
  }
  /**
   * {@see GoTrueMFAApi#listFactors}
   */
  async _listFactors() {
    const { data: { user }, error: userError } = await this.getUser();
    if (userError) {
      return { data: null, error: userError };
    }
    const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];
    const totp = factors.filter((factor) => factor.factor_type === "totp" && factor.status === "verified");
    const phone = factors.filter((factor) => factor.factor_type === "phone" && factor.status === "verified");
    return {
      data: {
        all: factors,
        totp,
        phone
      },
      error: null
    };
  }
  /**
   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
   */
  async _getAuthenticatorAssuranceLevel() {
    return this._acquireLock(-1, async () => {
      return await this._useSession(async (result) => {
        var _a2, _b;
        const { data: { session }, error: sessionError } = result;
        if (sessionError) {
          return { data: null, error: sessionError };
        }
        if (!session) {
          return {
            data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },
            error: null
          };
        }
        const payload = this._decodeJWT(session.access_token);
        let currentLevel = null;
        if (payload.aal) {
          currentLevel = payload.aal;
        }
        let nextLevel = currentLevel;
        const verifiedFactors = (_b = (_a2 = session.user.factors) === null || _a2 === void 0 ? void 0 : _a2.filter((factor) => factor.status === "verified")) !== null && _b !== void 0 ? _b : [];
        if (verifiedFactors.length > 0) {
          nextLevel = "aal2";
        }
        const currentAuthenticationMethods = payload.amr || [];
        return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };
      });
    });
  }
};
GoTrueClient.nextInstanceID = 0;

// node_modules/@supabase/auth-js/dist/module/AuthClient.js
var AuthClient = GoTrueClient;
var AuthClient_default = AuthClient;

// node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js
var SupabaseAuthClient = class extends AuthClient_default {
  constructor(options) {
    super(options);
  }
};

// node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SupabaseClient = class {
  /**
   * Create a new client for use in the browser.
   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
   * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
   * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
   * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
   * @param options.realtime Options passed along to realtime-js constructor.
   * @param options.global.fetch A custom fetch implementation.
   * @param options.global.headers Any additional headers to send with each network request.
   */
  constructor(supabaseUrl, supabaseKey, options) {
    var _a2, _b, _c;
    this.supabaseUrl = supabaseUrl;
    this.supabaseKey = supabaseKey;
    if (!supabaseUrl)
      throw new Error("supabaseUrl is required.");
    if (!supabaseKey)
      throw new Error("supabaseKey is required.");
    const _supabaseUrl = stripTrailingSlash(supabaseUrl);
    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, "ws");
    this.authUrl = `${_supabaseUrl}/auth/v1`;
    this.storageUrl = `${_supabaseUrl}/storage/v1`;
    this.functionsUrl = `${_supabaseUrl}/functions/v1`;
    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split(".")[0]}-auth-token`;
    const DEFAULTS = {
      db: DEFAULT_DB_OPTIONS,
      realtime: DEFAULT_REALTIME_OPTIONS,
      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), { storageKey: defaultStorageKey }),
      global: DEFAULT_GLOBAL_OPTIONS
    };
    const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);
    this.storageKey = (_a2 = settings.auth.storageKey) !== null && _a2 !== void 0 ? _a2 : "";
    this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};
    if (!settings.accessToken) {
      this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);
    } else {
      this.accessToken = settings.accessToken;
      this.auth = new Proxy({}, {
        get: (_, prop) => {
          throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);
        }
      });
    }
    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);
    this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers, accessToken: this._getAccessToken.bind(this) }, settings.realtime));
    this.rest = new PostgrestClient(`${_supabaseUrl}/rest/v1`, {
      headers: this.headers,
      schema: settings.db.schema,
      fetch: this.fetch
    });
    if (!settings.accessToken) {
      this._listenForAuthEvents();
    }
  }
  /**
   * Supabase Functions allows you to deploy and invoke edge functions.
   */
  get functions() {
    return new FunctionsClient(this.functionsUrl, {
      headers: this.headers,
      customFetch: this.fetch
    });
  }
  /**
   * Supabase Storage allows you to manage user-generated content, such as photos or videos.
   */
  get storage() {
    return new StorageClient(this.storageUrl, this.headers, this.fetch);
  }
  /**
   * Perform a query on a table or a view.
   *
   * @param relation - The table or view name to query
   */
  from(relation) {
    return this.rest.from(relation);
  }
  // NOTE: signatures must be kept in sync with PostgrestClient.schema
  /**
   * Select a schema to query or perform an function (rpc) call.
   *
   * The schema needs to be on the list of exposed schemas inside Supabase.
   *
   * @param schema - The schema to query
   */
  schema(schema) {
    return this.rest.schema(schema);
  }
  // NOTE: signatures must be kept in sync with PostgrestClient.rpc
  /**
   * Perform a function call.
   *
   * @param fn - The function name to call
   * @param args - The arguments to pass to the function call
   * @param options - Named parameters
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   * @param options.get - When set to `true`, the function will be called with
   * read-only access mode.
   * @param options.count - Count algorithm to use to count rows returned by the
   * function. Only applicable for [set-returning
   * functions](https://www.postgresql.org/docs/current/functions-srf.html).
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  rpc(fn, args = {}, options = {}) {
    return this.rest.rpc(fn, args, options);
  }
  /**
   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
   *
   * @param {string} name - The name of the Realtime channel.
   * @param {Object} opts - The options to pass to the Realtime channel.
   *
   */
  channel(name, opts = { config: {} }) {
    return this.realtime.channel(name, opts);
  }
  /**
   * Returns all Realtime channels.
   */
  getChannels() {
    return this.realtime.getChannels();
  }
  /**
   * Unsubscribes and removes Realtime channel from Realtime client.
   *
   * @param {RealtimeChannel} channel - The name of the Realtime channel.
   *
   */
  removeChannel(channel) {
    return this.realtime.removeChannel(channel);
  }
  /**
   * Unsubscribes and removes all Realtime channels from Realtime client.
   */
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  _getAccessToken() {
    var _a2, _b;
    return __awaiter8(this, void 0, void 0, function* () {
      if (this.accessToken) {
        return yield this.accessToken();
      }
      const { data } = yield this.auth.getSession();
      return (_b = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b !== void 0 ? _b : null;
    });
  }
  _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, storageKey, flowType, lock, debug: debug2 }, headers, fetch4) {
    const authHeaders = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`
    };
    return new SupabaseAuthClient({
      url: this.authUrl,
      headers: Object.assign(Object.assign({}, authHeaders), headers),
      storageKey,
      autoRefreshToken,
      persistSession,
      detectSessionInUrl,
      storage,
      flowType,
      lock,
      debug: debug2,
      fetch: fetch4,
      // auth checks if there is a custom authorizaiton header using this flag
      // so it knows whether to return an error when getUser is called with no session
      hasCustomAuthorizationHeader: "Authorization" in this.headers
    });
  }
  _initRealtimeClient(options) {
    return new RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), { params: Object.assign({ apikey: this.supabaseKey }, options === null || options === void 0 ? void 0 : options.params) }));
  }
  _listenForAuthEvents() {
    let data = this.auth.onAuthStateChange((event, session) => {
      this._handleTokenChanged(event, "CLIENT", session === null || session === void 0 ? void 0 : session.access_token);
    });
    return data;
  }
  _handleTokenChanged(event, source, token) {
    if ((event === "TOKEN_REFRESHED" || event === "SIGNED_IN") && this.changedAccessToken !== token) {
      this.changedAccessToken = token;
    } else if (event === "SIGNED_OUT") {
      this.realtime.setAuth();
      if (source == "STORAGE")
        this.auth.signOut();
      this.changedAccessToken = void 0;
    }
  }
};

// node_modules/@supabase/supabase-js/dist/module/index.js
var createClient = (supabaseUrl, supabaseKey, options) => {
  return new SupabaseClient(supabaseUrl, supabaseKey, options);
};

// settings/Settings.ts
var DEFAULT_CHUNKING_OPTIONS = {
  chunkSize: 1e3,
  // Default size of each chunk in characters
  chunkOverlap: 200,
  // Default overlap between chunks
  minChunkSize: 100
  // Minimum chunk size to ensure usability
};
var DEFAULT_SETTINGS = {
  vaultId: null,
  lastKnownVaultName: "",
  supabase: {
    url: "",
    apiKey: "",
    initialized: false,
    lastSetupAttempt: 0,
    setupRetries: 0
  },
  openai: {
    apiKey: "",
    model: "text-embedding-ada-002",
    maxTokens: 8e3,
    temperature: 0
  },
  chunking: { ...DEFAULT_CHUNKING_OPTIONS },
  // Use default chunking options
  queue: {
    maxConcurrent: 3,
    retryAttempts: 3,
    retryDelay: 1e3
  },
  exclusions: {
    excludedFolders: [
      ".obsidian",
      // Obsidian config folder
      ".trash",
      // Obsidian trash folder
      ".git",
      // Git folder if used
      "node_modules"
      // Node modules if used
    ],
    excludedFileTypes: [
      ".mp3",
      ".jpg",
      ".png",
      ".pdf",
      // Non-markdown files
      ".excalidraw"
      // Excalidraw files
    ],
    excludedFilePrefixes: ["_", "."],
    // Hidden and special files
    excludedFiles: [
      "_mindmatrixsync.md",
      // Sync file
      "_mindmatrixsync.md.backup"
      // Sync backup file
    ]
  },
  debug: {
    enableDebugLogs: false,
    logLevel: "info",
    logToFile: false
  },
  enableAutoSync: true,
  enableNotifications: true,
  enableProgressBar: true,
  sync: {
    syncFilePath: "_mindmatrixsync.md",
    backupInterval: 36e5,
    // 1 hour in milliseconds
    checkInterval: 3e5,
    // 5 minutes in milliseconds
    checkAttempts: 3,
    requireSync: true
  },
  initialSync: {
    batchSize: 50,
    maxConcurrentBatches: 3,
    enableAutoInitialSync: true,
    priorityRules: [
      { pattern: "daily/", priority: 3 },
      { pattern: "projects/", priority: 2 },
      { pattern: "archive/", priority: 1 }
    ]
  }
};
function isVaultInitialized(settings) {
  return settings.vaultId !== null && settings.vaultId !== void 0 && settings.vaultId !== "";
}
function generateVaultId() {
  return crypto.randomUUID();
}

// services/SupabaseService.ts
var import_obsidian = require("obsidian");
var _SupabaseService = class {
  constructor(settings) {
    this.TABLE_NAME = "obsidian_documents";
    if (!settings.supabase.url || !settings.supabase.apiKey) {
      console.warn("Supabase configuration is incomplete. Supabase service will not be initialized.");
      this.client = null;
      return;
    }
    if (!isVaultInitialized(settings)) {
      throw new Error("Vault is not initialized");
    }
    this.settings = settings;
    this.client = createClient(settings.supabase.url, settings.supabase.apiKey);
  }
  static async getInstance(settings) {
    if (!settings.supabase.url || !settings.supabase.apiKey) {
      console.warn("Supabase configuration is incomplete. Returning null.");
      return null;
    }
    if (!_SupabaseService.instance) {
      _SupabaseService.instance = new _SupabaseService(settings);
      await _SupabaseService.instance.initializeDatabase();
    } else if (_SupabaseService.instance.settings.supabase.url !== settings.supabase.url || _SupabaseService.instance.settings.supabase.apiKey !== settings.supabase.apiKey || _SupabaseService.instance.settings.vaultId !== settings.vaultId) {
      _SupabaseService.instance = new _SupabaseService(settings);
      await _SupabaseService.instance.initializeDatabase();
    }
    return _SupabaseService.instance;
  }
  async initializeDatabase() {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping database initialization.");
      return;
    }
    try {
      new import_obsidian.Notice("Checking database connection...");
      const { data: testData, error: testError } = await this.client.from(this.TABLE_NAME).select("id").limit(1);
      if (testError && !testError.message.includes("does not exist")) {
        throw new Error(`Database connection failed: ${testError.message}`);
      }
      const { error: initError } = await this.client.rpc("init_obsidian_documents");
      if (initError) {
        throw new Error(`Failed to initialize database: ${initError.message}`);
      }
      new import_obsidian.Notice("Database connection verified");
      this.settings.supabase.initialized = true;
    } catch (error) {
      console.error("Database initialization error:", error);
      new import_obsidian.Notice(`Database error: ${error.message}`);
      throw error;
    }
  }
  async upsertChunks(chunks) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping upsertChunks.");
      return;
    }
    try {
      if (chunks.length === 0) {
        console.log("No chunks to upsert");
        return;
      }
      const obsidianId = chunks[0].metadata.obsidianId;
      console.log("Attempting to delete existing chunks for:", obsidianId);
      const { error: deleteError } = await this.client.from(this.TABLE_NAME).delete().eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
      if (deleteError) {
        console.error("Error deleting existing chunks:", deleteError);
        throw deleteError;
      }
      const chunksToInsert = chunks.map((chunk) => ({
        vault_id: this.settings.vaultId,
        obsidian_id: chunk.metadata.obsidianId,
        chunk_index: chunk.chunkIndex,
        content: chunk.content,
        metadata: chunk.metadata,
        embedding: chunk.embedding,
        last_updated: new Date().toISOString()
      }));
      const { error: insertError } = await this.client.from(this.TABLE_NAME).insert(chunksToInsert);
      if (insertError) {
        console.error("Error inserting new chunks:", insertError);
        throw insertError;
      }
      console.log("Successfully updated chunks:", {
        numberOfChunks: chunks.length,
        vaultId: this.settings.vaultId,
        obsidianId
      });
    } catch (error) {
      console.error("Failed to upsert chunks:", error);
      throw error;
    }
  }
  async deleteDocumentChunks(obsidianId) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping deleteDocumentChunks.");
      return;
    }
    try {
      const { error } = await this.client.from(this.TABLE_NAME).delete().eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
      if (error) {
        throw error;
      }
    } catch (error) {
      console.error("Failed to delete chunks:", error);
      throw error;
    }
  }
  async getDocumentChunks(obsidianId) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping getDocumentChunks.");
      return [];
    }
    try {
      const { data, error } = await this.client.from(this.TABLE_NAME).select("*").eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId).order("chunk_index");
      if (error) {
        throw error;
      }
      return data.map((row) => ({
        content: row.content,
        chunkIndex: row.chunk_index,
        metadata: row.metadata,
        embedding: row.embedding
      }));
    } catch (error) {
      console.error("Failed to get chunks:", error);
      throw error;
    }
  }
  async semanticSearch(embedding, limit2 = 5) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping semanticSearch.");
      return [];
    }
    try {
      const { data, error } = await this.client.rpc("match_documents", {
        query_embedding: embedding,
        search_vault_id: this.settings.vaultId,
        match_count: limit2
      });
      if (error) {
        throw error;
      }
      return data.map((row) => ({
        content: row.content,
        metadata: row.metadata,
        similarity: row.similarity
      }));
    } catch (error) {
      console.error("Failed to perform semantic search:", error);
      throw error;
    }
  }
  async testConnection() {
    if (!this.client) {
      return false;
    }
    try {
      const { error } = await this.client.from(this.TABLE_NAME).select("id").limit(1);
      return !error;
    } catch (error) {
      return false;
    }
  }
  async getAllDocumentIds() {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping getAllDocumentIds.");
      return [];
    }
    try {
      const { data, error } = await this.client.from(this.TABLE_NAME).select("obsidian_id").eq("vault_id", this.settings.vaultId).distinct();
      if (error) {
        throw error;
      }
      return data.map((row) => row.obsidian_id);
    } catch (error) {
      console.error("Failed to get document IDs:", error);
      throw error;
    }
  }
};
var SupabaseService = _SupabaseService;
SupabaseService.instance = null;

// node_modules/openai/internal/qs/formats.mjs
var default_format = "RFC3986";
var formatters = {
  RFC1738: (v) => String(v).replace(/%20/g, "+"),
  RFC3986: (v) => String(v)
};
var RFC1738 = "RFC1738";

// node_modules/openai/internal/qs/utils.mjs
var is_array = Array.isArray;
var hex_table = (() => {
  const array = [];
  for (let i = 0; i < 256; ++i) {
    array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array;
})();
var limit = 1024;
var encode = (str2, _defaultEncoder, charset, _kind, format) => {
  if (str2.length === 0) {
    return str2;
  }
  let string = str2;
  if (typeof str2 === "symbol") {
    string = Symbol.prototype.toString.call(str2);
  } else if (typeof str2 !== "string") {
    string = String(str2);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  let out = "";
  for (let j = 0; j < string.length; j += limit) {
    const segment = string.length >= limit ? string.slice(j, j + limit) : string;
    const arr = [];
    for (let i = 0; i < segment.length; ++i) {
      let c = segment.charCodeAt(i);
      if (c === 45 || // -
      c === 46 || // .
      c === 95 || // _
      c === 126 || // ~
      c >= 48 && c <= 57 || // 0-9
      c >= 65 && c <= 90 || // a-z
      c >= 97 && c <= 122 || // A-Z
      format === RFC1738 && (c === 40 || c === 41)) {
        arr[arr.length] = segment.charAt(i);
        continue;
      }
      if (c < 128) {
        arr[arr.length] = hex_table[c];
        continue;
      }
      if (c < 2048) {
        arr[arr.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        arr[arr.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
      arr[arr.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
    }
    out += arr.join("");
  }
  return out;
};
function is_buffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn) {
  if (is_array(val)) {
    const mapped = [];
    for (let i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
}

// node_modules/openai/internal/qs/stringify.mjs
var has = Object.prototype.hasOwnProperty;
var array_prefix_generators = {
  brackets(prefix) {
    return String(prefix) + "[]";
  },
  comma: "comma",
  indices(prefix, key) {
    return String(prefix) + "[" + key + "]";
  },
  repeat(prefix) {
    return String(prefix);
  }
};
var is_array2 = Array.isArray;
var push = Array.prototype.push;
var push_to_array = function(arr, value_or_array) {
  push.apply(arr, is_array2(value_or_array) ? value_or_array : [value_or_array]);
};
var to_ISO = Date.prototype.toISOString;
var defaults = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: encode,
  encodeValuesOnly: false,
  format: default_format,
  formatter: formatters[default_format],
  /** @deprecated */
  indices: false,
  serializeDate(date) {
    return to_ISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
function is_non_nullish_primitive(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
}
var sentinel = {};
function inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
  let obj = object;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
    const pos = tmp_sc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate == null ? void 0 : serializeDate(obj);
  } else if (generateArrayPrefix === "comma" && is_array2(obj)) {
    obj = maybe_map(obj, function(value) {
      if (value instanceof Date) {
        return serializeDate == null ? void 0 : serializeDate(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? (
        // @ts-expect-error
        encoder(prefix, defaults.encoder, charset, "key", format)
      ) : prefix;
    }
    obj = "";
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder) {
      const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
      return [
        (formatter == null ? void 0 : formatter(key_value)) + "=" + // @ts-expect-error
        (formatter == null ? void 0 : formatter(encoder(obj, defaults.encoder, charset, "value", format)))
      ];
    }
    return [(formatter == null ? void 0 : formatter(prefix)) + "=" + (formatter == null ? void 0 : formatter(String(obj)))];
  }
  const values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && is_array2(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = maybe_map(obj, encoder);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (is_array2(filter)) {
    obj_keys = filter;
  } else {
    const keys = Object.keys(obj);
    obj_keys = sort ? keys.sort(sort) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && is_array2(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && is_array2(obj) && obj.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j = 0; j < obj_keys.length; ++j) {
    const key = obj_keys[j];
    const value = (
      // @ts-ignore
      typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
    );
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = is_array2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel.set(object, step);
    const valueSideChannel = /* @__PURE__ */ new WeakMap();
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(values, inner_stringify(
      value,
      key_prefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      // @ts-ignore
      generateArrayPrefix === "comma" && encodeValuesOnly && is_array2(obj) ? null : encoder,
      filter,
      sort,
      allowDots,
      serializeDate,
      format,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
}
function normalize_stringify_options(opts = defaults) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset = opts.charset || defaults.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has.call(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format = opts.format;
  }
  const formatter = formatters[format];
  let filter = defaults.filter;
  if (typeof opts.filter === "function" || is_array2(opts.filter)) {
    filter = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
    // @ts-ignore
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter,
    format,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
    // @ts-ignore
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
}
function stringify(object, opts = {}) {
  let obj = object;
  const options = normalize_stringify_options(opts);
  let obj_keys;
  let filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (is_array2(options.filter)) {
    filter = options.filter;
    obj_keys = filter;
  }
  const keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options.sort) {
    obj_keys.sort(options.sort);
  }
  const sideChannel = /* @__PURE__ */ new WeakMap();
  for (let i = 0; i < obj_keys.length; ++i) {
    const key = obj_keys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    push_to_array(keys, inner_stringify(
      obj[key],
      key,
      // @ts-expect-error
      generateArrayPrefix,
      commaRoundTrip,
      options.allowEmptyArrays,
      options.strictNullHandling,
      options.skipNulls,
      options.encodeDotInKeys,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel
    ));
  }
  const joined = keys.join(options.delimiter);
  let prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}

// node_modules/openai/version.mjs
var VERSION = "4.79.1";

// node_modules/openai/_shims/registry.mjs
var auto = false;
var kind = void 0;
var fetch3 = void 0;
var Request3 = void 0;
var Response3 = void 0;
var Headers3 = void 0;
var FormData2 = void 0;
var Blob2 = void 0;
var File2 = void 0;
var ReadableStream2 = void 0;
var getMultipartRequestOptions = void 0;
var getDefaultAgent = void 0;
var fileFromPath = void 0;
var isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
  }
  if (kind) {
    throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch3 = shims.fetch;
  Request3 = shims.Request;
  Response3 = shims.Response;
  Headers3 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}

// node_modules/openai/_shims/MultipartBody.mjs
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// node_modules/openai/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import \u2026 from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}

// node_modules/openai/_shims/index.mjs
if (!kind)
  setShims(getRuntime(), { auto: true });

// node_modules/openai/error.mjs
var OpenAIError = class extends Error {
};
var APIError = class extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.request_id = headers == null ? void 0 : headers["x-request-id"];
    this.error = error;
    const data = error;
    this.code = data == null ? void 0 : data["code"];
    this.param = data == null ? void 0 : data["param"];
    this.type = data == null ? void 0 : data["type"];
  }
  static makeMessage(status, error, message) {
    const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error = errorResponse == null ? void 0 : errorResponse["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message != null ? message : "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
};
var AuthenticationError = class extends APIError {
};
var PermissionDeniedError = class extends APIError {
};
var NotFoundError = class extends APIError {
};
var ConflictError = class extends APIError {
};
var UnprocessableEntityError = class extends APIError {
};
var RateLimitError = class extends APIError {
};
var InternalServerError = class extends APIError {
};
var LengthFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the length limit was reached`);
  }
};
var ContentFilterFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the request was rejected by the content filter`);
  }
};

// node_modules/openai/internal/decoders/line.mjs
var LineDecoder = class {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);
    if (trailingNewline) {
      lines.pop();
    }
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    var _a2;
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        (_a2 = this.textDecoder) != null ? _a2 : this.textDecoder = new TextDecoder("utf8");
        return this.textDecoder.decode(bytes);
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;

// node_modules/openai/streaming.mjs
var Stream = class {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError(void 0, data.error, void 0, void 0);
            }
            yield data;
          } else {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (sse.event == "error") {
              throw new APIError(void 0, data.error, data.message, void 0);
            }
            yield { event: sse.event, data };
          }
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = readableStreamAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new Stream(() => teeIterator(left), this.controller),
      new Stream(() => teeIterator(right), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self2 = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream2({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a2;
        await ((_a2 = iter.return) == null ? void 0 : _a2.call(iter));
      }
    });
  }
};
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = readableStreamAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 2; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition(str2, delimiter) {
  const index2 = str2.indexOf(delimiter);
  if (index2 !== -1) {
    return [str2.substring(0, index2), delimiter, str2.substring(index2 + delimiter.length)];
  }
  return [str2, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/openai/uploads.mjs
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isUploadable = (value) => {
  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};
async function toFile(value, name, options) {
  var _a2, _b, _c;
  value = await value;
  if (isFileLike(value)) {
    return value;
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = (_a2 = new URL(value.url).pathname.split(/[\\/]/).pop()) != null ? _a2 : "unknown_file");
    const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];
    return new File2(data, name, options);
  }
  const bits = await getBytes(value);
  name || (name = (_b = getName(value)) != null ? _b : "unknown_file");
  if (!(options == null ? void 0 : options.type)) {
    const type = (_c = bits[0]) == null ? void 0 : _c.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes(value) {
  var _a2;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a2 = value == null ? void 0 : value.constructor) == null ? void 0 : _a2.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a2;
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  ((_a2 = getStringFromMaybeBuffer(value.path)) == null ? void 0 : _a2.split(/[\\/]/).pop());
}
var getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return void 0;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
var createForm = async (body) => {
  const form = new FormData2();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/openai/core.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const isJSON = (contentType == null ? void 0 : contentType.includes("application/json")) || (contentType == null ? void 0 : contentType.includes("application/vnd.api+json"));
  if (isJSON) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return _addRequestID(json, response);
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
function _addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("x-request-id"),
    enumerable: false
  });
}
var APIPromise = class extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("x-request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 6e5,
    // 10 minutes
    httpAgent,
    fetch: overriddenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overriddenFetch != null ? overriddenFetch : fetch3;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then(async (opts2) => {
      const body = opts2 && isBlobLike(opts2 == null ? void 0 : opts2.body) ? new DataView(await opts2.body.arrayBuffer()) : (opts2 == null ? void 0 : opts2.body) instanceof DataView ? opts2.body : (opts2 == null ? void 0 : opts2.body) instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2 == null ? void 0 : opts2.body) ? new DataView(opts2.body.buffer) : opts2 == null ? void 0 : opts2.body;
      return { method, path, ...opts2, body };
    }));
  }
  getAPIList(path, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    } else if (ArrayBuffer.isView(body)) {
      return body.byteLength.toString();
    }
    return null;
  }
  buildRequest(options, { retryCount = 0 } = {}) {
    var _a2, _b, _c, _d, _e, _f;
    const { method, path, query, headers = {} } = options;
    const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    const timeout = (_a2 = options.timeout) != null ? _a2 : this.timeout;
    const httpAgent = (_c = (_b = options.httpAgent) != null ? _b : this.httpAgent) != null ? _c : getDefaultAgent(url);
    const minAgentTimeout = timeout + 1e3;
    if (typeof ((_d = httpAgent == null ? void 0 : httpAgent.options) == null ? void 0 : _d.timeout) === "number" && minAgentTimeout > ((_e = httpAgent.options.timeout) != null ? _e : 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: (_f = options.signal) != null ? _f : null
    };
    return { req, url, timeout };
  }
  buildHeaders({ options, headers, contentLength, retryCount }) {
    const reqHeaders = {};
    if (contentLength) {
      reqHeaders["content-length"] = contentLength;
    }
    const defaultHeaders = this.defaultHeaders(options);
    applyHeadersMut(reqHeaders, defaultHeaders);
    applyHeadersMut(reqHeaders, headers);
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["content-type"];
    }
    if (getHeader(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader(headers, "x-stainless-retry-count") === void 0) {
      reqHeaders["x-stainless-retry-count"] = String(retryCount);
    }
    this.validateHeaders(reqHeaders, headers);
    return reqHeaders;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    var _a2, _b, _c;
    const options = await optionsInput;
    const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if ((_b = options.signal) == null ? void 0 : _b.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if ((_c = options.signal) == null ? void 0 : _c.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e) => castToError(e).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page2);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const fetchOptions = {
      signal: controller.signal,
      ...options
    };
    if (fetchOptions.method) {
      fetchOptions.method = fetchOptions.method.toUpperCase();
    }
    return (
      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
      this.fetch.call(void 0, url, fetchOptions).finally(() => {
        clearTimeout(timeout);
      })
    );
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    var _a2;
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after-ms"];
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after"];
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep2(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
};
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo && typeof nextOptions.query === "object") {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page2) {
    super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
var requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true,
  __binaryRequest: true,
  __binaryResponse: true,
  __streamClass: true
};
var isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
};
var getPlatformProperties = () => {
  var _a2, _b;
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : (_b = (_a2 = Deno.version) == null ? void 0 : _a2.deno) != null ? _b : "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders != null ? _platformHeaders : _platformHeaders = getPlatformProperties();
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep2 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      return new Error(JSON.stringify(err));
    } catch (e) {
    }
  }
  return new Error(err);
};
var readEnv = (env) => {
  var _a2, _b, _c, _d, _e, _f;
  if (typeof process !== "undefined") {
    return (_c = (_b = (_a2 = process.env) == null ? void 0 : _a2[env]) == null ? void 0 : _b.trim()) != null ? _c : void 0;
  }
  if (typeof Deno !== "undefined") {
    return (_f = (_e = (_d = Deno.env) == null ? void 0 : _d.get) == null ? void 0 : _e.call(_d, env)) == null ? void 0 : _f.trim();
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k in newHeaders) {
    if (!hasOwn(newHeaders, k))
      continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
var SENSITIVE_HEADERS = /* @__PURE__ */ new Set(["authorization", "api-key"]);
function debug(action, ...args) {
  var _a2;
  if (typeof process !== "undefined" && ((_a2 = process == null ? void 0 : process.env) == null ? void 0 : _a2["DEBUG"]) === "true") {
    const modifiedArgs = args.map((arg) => {
      if (!arg) {
        return arg;
      }
      if (arg["headers"]) {
        const modifiedArg2 = { ...arg, headers: { ...arg["headers"] } };
        for (const header in arg["headers"]) {
          if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
            modifiedArg2["headers"][header] = "REDACTED";
          }
        }
        return modifiedArg2;
      }
      let modifiedArg = null;
      for (const header in arg) {
        if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
          modifiedArg != null ? modifiedArg : modifiedArg = { ...arg };
          modifiedArg[header] = "REDACTED";
        }
      }
      return modifiedArg != null ? modifiedArg : arg;
    });
    console.log(`OpenAI:DEBUG:${action}`, ...modifiedArgs);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
var isHeadersProtocol = (headers) => {
  return typeof (headers == null ? void 0 : headers.get) === "function";
};
var getHeader = (headers, header) => {
  var _a2;
  const lowerCasedHeader = header.toLowerCase();
  if (isHeadersProtocol(headers)) {
    const intercapsHeader = ((_a2 = header[0]) == null ? void 0 : _a2.toUpperCase()) + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
      const value = headers.get(key);
      if (value) {
        return value;
      }
    }
  }
  for (const [key, value] of Object.entries(headers)) {
    if (key.toLowerCase() === lowerCasedHeader) {
      if (Array.isArray(value)) {
        if (value.length <= 1)
          return value[0];
        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
        return value[0];
      }
      return value;
    }
  }
  return void 0;
};
function isObj(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj);
}

// node_modules/openai/pagination.mjs
var Page = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    var _a2;
    return (_a2 = this.data) != null ? _a2 : [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
};
var CursorPage = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
  }
  getPaginatedItems() {
    var _a2;
    return (_a2 = this.data) != null ? _a2 : [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info)
      return null;
    if ("params" in info)
      return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    var _a2;
    const data = this.getPaginatedItems();
    if (!data.length) {
      return null;
    }
    const id = (_a2 = data[data.length - 1]) == null ? void 0 : _a2.id;
    if (!id) {
      return null;
    }
    return { params: { after: id } };
  }
};

// node_modules/openai/resource.mjs
var APIResource = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/openai/resources/chat/completions.mjs
var Completions = class extends APIResource {
  create(body, options) {
    var _a2;
    return this._client.post("/chat/completions", { body, ...options, stream: (_a2 = body.stream) != null ? _a2 : false });
  }
};

// node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this._client);
  }
};
Chat.Completions = Completions;

// node_modules/openai/resources/audio/speech.mjs
var Speech = class extends APIResource {
  /**
   * Generates audio from the input text.
   */
  create(body, options) {
    return this._client.post("/audio/speech", {
      body,
      ...options,
      headers: { Accept: "application/octet-stream", ...options == null ? void 0 : options.headers },
      __binaryResponse: true
    });
  }
};

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource {
  create(body, options) {
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions({ body, ...options }));
  }
};

// node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource {
  create(body, options) {
    return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options }));
  }
};

// node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
};
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;
Audio.Speech = Speech;

// node_modules/openai/resources/batches.mjs
var Batches = class extends APIResource {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(body, options) {
    return this._client.post("/batches", { body, ...options });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(batchId, options) {
    return this._client.get(`/batches/${batchId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/batches", BatchesPage, { query, ...options });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(batchId, options) {
    return this._client.post(`/batches/${batchId}/cancel`, options);
  }
};
var BatchesPage = class extends CursorPage {
};
Batches.BatchesPage = BatchesPage;

// node_modules/openai/resources/beta/assistants.mjs
var Assistants = class extends APIResource {
  /**
   * Create an assistant with a model and instructions.
   */
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves an assistant.
   */
  retrieve(assistantId, options) {
    return this._client.get(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies an assistant.
   */
  update(assistantId, body, options) {
    return this._client.post(`/assistants/${assistantId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/assistants", AssistantsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete an assistant.
   */
  del(assistantId, options) {
    return this._client.delete(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};
var AssistantsPage = class extends CursorPage {
};
Assistants.AssistantsPage = AssistantsPage;

// node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}

// node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage = (message) => {
  return (message == null ? void 0 : message.role) === "assistant";
};
var isFunctionMessage = (message) => {
  return (message == null ? void 0 : message.role) === "function";
};
var isToolMessage = (message) => {
  return (message == null ? void 0 : message.role) === "tool";
};

// node_modules/openai/lib/EventStream.mjs
var __classPrivateFieldSet2 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EventStream_instances;
var _EventStream_connectedPromise;
var _EventStream_resolveConnectedPromise;
var _EventStream_rejectConnectedPromise;
var _EventStream_endPromise;
var _EventStream_resolveEndPromise;
var _EventStream_rejectEndPromise;
var _EventStream_listeners;
var _EventStream_ended;
var _EventStream_errored;
var _EventStream_aborted;
var _EventStream_catchingPromiseCreated;
var _EventStream_handleError;
var EventStream = class {
  constructor() {
    _EventStream_instances.add(this);
    this.controller = new AbortController();
    _EventStream_connectedPromise.set(this, void 0);
    _EventStream_resolveConnectedPromise.set(this, () => {
    });
    _EventStream_rejectConnectedPromise.set(this, () => {
    });
    _EventStream_endPromise.set(this, void 0);
    _EventStream_resolveEndPromise.set(this, () => {
    });
    _EventStream_rejectEndPromise.set(this, () => {
    });
    _EventStream_listeners.set(this, {});
    _EventStream_ended.set(this, false);
    _EventStream_errored.set(this, false);
    _EventStream_aborted.set(this, false);
    _EventStream_catchingPromiseCreated.set(this, false);
    __classPrivateFieldSet2(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _EventStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet2(this, _EventStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet2(this, _EventStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _EventStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet2(this, _EventStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet2(this, _EventStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet2(this, _EventStream_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet2(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
    }, 0);
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet2(this, _EventStream_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet2(this, _EventStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet2(this, _EventStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet2(this, _EventStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index2 = listeners.findIndex((l) => l.listener === listener);
    if (index2 >= 0)
      listeners.splice(index2, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _EventStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet2(this, _EventStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet2(this, _EventStream_endPromise, "f");
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet2(this, _EventStream_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet2(this, _EventStream_ended, true, "f");
      __classPrivateFieldGet2(this, _EventStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
  }
};
_EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error) {
  __classPrivateFieldSet2(this, _EventStream_errored, true, "f");
  if (error instanceof Error && error.name === "AbortError") {
    error = new APIUserAbortError();
  }
  if (error instanceof APIUserAbortError) {
    __classPrivateFieldSet2(this, _EventStream_aborted, true, "f");
    return this._emit("abort", error);
  }
  if (error instanceof OpenAIError) {
    return this._emit("error", error);
  }
  if (error instanceof Error) {
    const openAIError = new OpenAIError(error.message);
    openAIError.cause = error;
    return this._emit("error", openAIError);
  }
  return this._emit("error", new OpenAIError(String(error)));
};

// node_modules/openai/lib/parser.mjs
function isAutoParsableResponseFormat(response_format) {
  return (response_format == null ? void 0 : response_format["$brand"]) === "auto-parseable-response-format";
}
function isAutoParsableTool(tool) {
  return (tool == null ? void 0 : tool["$brand"]) === "auto-parseable-tool";
}
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => {
        var _a2;
        return {
          ...choice,
          message: { ...choice.message, parsed: null, tool_calls: (_a2 = choice.message.tool_calls) != null ? _a2 : [] }
        };
      })
    };
  }
  return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    var _a2, _b;
    if (choice.finish_reason === "length") {
      throw new LengthFinishReasonError();
    }
    if (choice.finish_reason === "content_filter") {
      throw new ContentFilterFinishReasonError();
    }
    return {
      ...choice,
      message: {
        ...choice.message,
        tool_calls: (_b = (_a2 = choice.message.tool_calls) == null ? void 0 : _a2.map((toolCall) => parseToolCall(params, toolCall))) != null ? _b : [],
        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
      }
    };
  });
  return { ...completion, choices };
}
function parseResponseFormat(params, content) {
  var _a2, _b;
  if (((_a2 = params.response_format) == null ? void 0 : _a2.type) !== "json_schema") {
    return null;
  }
  if (((_b = params.response_format) == null ? void 0 : _b.type) === "json_schema") {
    if ("$parseRaw" in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
function parseToolCall(params, toolCall) {
  var _a2;
  const inputTool = (_a2 = params.tools) == null ? void 0 : _a2.find((inputTool2) => {
    var _a3;
    return ((_a3 = inputTool2.function) == null ? void 0 : _a3.name) === toolCall.function.name;
  });
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCall.function.arguments) : null
    }
  };
}
function shouldParseToolCall(params, toolCall) {
  var _a2;
  if (!params) {
    return false;
  }
  const inputTool = (_a2 = params.tools) == null ? void 0 : _a2.find((inputTool2) => {
    var _a3;
    return ((_a3 = inputTool2.function) == null ? void 0 : _a3.name) === toolCall.function.name;
  });
  return isAutoParsableTool(inputTool) || (inputTool == null ? void 0 : inputTool.function.strict) || false;
}
function hasAutoParseableInput(params) {
  var _a2, _b;
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return (_b = (_a2 = params.tools) == null ? void 0 : _a2.some((t) => isAutoParsableTool(t) || t.type === "function" && t.function.strict === true)) != null ? _b : false;
}
function validateInputTools(tools) {
  for (const tool of tools != null ? tools : []) {
    if (tool.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
    }
    if (tool.function.strict !== true) {
      throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
    }
  }
}

// node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var __classPrivateFieldGet3 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractChatCompletionRunner_instances;
var _AbstractChatCompletionRunner_getFinalContent;
var _AbstractChatCompletionRunner_getFinalMessage;
var _AbstractChatCompletionRunner_getFinalFunctionCall;
var _AbstractChatCompletionRunner_getFinalFunctionCallResult;
var _AbstractChatCompletionRunner_calculateTotalUsage;
var _AbstractChatCompletionRunner_validateParams;
var _AbstractChatCompletionRunner_stringifyFunctionCallResult;
var DEFAULT_MAX_CHAT_COMPLETIONS = 10;
var AbstractChatCompletionRunner = class extends EventStream {
  constructor() {
    super(...arguments);
    _AbstractChatCompletionRunner_instances.add(this);
    this._chatCompletions = [];
    this.messages = [];
  }
  _addChatCompletion(chatCompletion) {
    var _a2;
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = (_a2 = chatCompletion.choices[0]) == null ? void 0 : _a2.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {
        this._emit("functionCallResult", message.content);
      } else if (isAssistantMessage(message) && message.function_call) {
        this._emit("functionCall", message.function_call);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionCall", tool_call.function);
          }
        }
      }
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionCall() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
  }
  async finalFunctionCallResult() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(client, params, options) {
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
  }
  async _runChatCompletion(client, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(client, params, options);
  }
  async _runFunctions(client, params, options) {
    var _a2;
    const role = "function";
    const { function_call = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof function_call !== "string" && (function_call == null ? void 0 : function_call.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const functionsByName = {};
    for (const f of params.functions) {
      functionsByName[f.name || f.function.name] = f;
    }
    const functions = params.functions.map((f) => ({
      name: f.name || f.function.name,
      parameters: f.parameters,
      description: f.description
    }));
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        function_call,
        functions,
        messages: [...this.messages]
      }, options);
      const message = (_a2 = chatCompletion.choices[0]) == null ? void 0 : _a2.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.function_call)
        return;
      const { name, arguments: args } = message.function_call;
      const fn = functionsByName[name];
      if (!fn) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f) => JSON.stringify(f.name)).join(", ")}. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      } else if (singleFunctionToCall && singleFunctionToCall !== name) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      }
      let parsed;
      try {
        parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
      } catch (error) {
        this._addMessage({
          role,
          name,
          content: error instanceof Error ? error.message : String(error)
        });
        continue;
      }
      const rawContent = await fn.function(parsed, this);
      const content = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
      this._addMessage({ role, name, content });
      if (singleFunctionToCall)
        return;
    }
  }
  async _runTools(client, params, options) {
    var _a2, _b, _c;
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && ((_a2 = tool_choice == null ? void 0 : tool_choice.function) == null ? void 0 : _a2.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const inputTools = params.tools.map((tool) => {
      if (isAutoParsableTool(tool)) {
        if (!tool.$callback) {
          throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
        }
        return {
          type: "function",
          function: {
            function: tool.$callback,
            name: tool.function.name,
            description: tool.function.description || "",
            parameters: tool.function.parameters,
            parse: tool.$parseRaw,
            strict: true
          }
        };
      }
      return tool;
    });
    const functionsByName = {};
    for (const f of inputTools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
      type: "function",
      function: {
        name: t.function.name || t.function.function.name,
        parameters: t.function.parameters,
        description: t.function.description,
        strict: t.function.strict
      }
    } : t) : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options);
      const message = (_b = chatCompletion.choices[0]) == null ? void 0 : _b.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!((_c = message.tool_calls) == null ? void 0 : _c.length)) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error) {
          const content2 = error instanceof Error ? error.message : String(error);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
};
_AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  var _a2;
  return (_a2 = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content) != null ? _a2 : null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  var _a2, _b;
  let i = this.messages.length;
  while (i-- > 0) {
    const message = this.messages[i];
    if (isAssistantMessage(message)) {
      const { function_call, ...rest } = message;
      const ret = {
        ...rest,
        content: (_a2 = message.content) != null ? _a2 : null,
        refusal: (_b = message.refusal) != null ? _b : null
      };
      if (function_call) {
        ret.function_call = function_call;
      }
      return ret;
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall2() {
  var _a2, _b;
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isAssistantMessage(message) && (message == null ? void 0 : message.function_call)) {
      return message.function_call;
    }
    if (isAssistantMessage(message) && ((_a2 = message == null ? void 0 : message.tool_calls) == null ? void 0 : _a2.length)) {
      return (_b = message.tool_calls.at(-1)) == null ? void 0 : _b.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isFunctionMessage(message) && message.content != null) {
      return message.content;
    }
    if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => {
      var _a2;
      return x.role === "assistant" && ((_a2 = x.tool_calls) == null ? void 0 : _a2.some((y) => y.type === "function" && y.id === message.tool_call_id));
    })) {
      return message.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
};

// node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner = class extends AbstractChatCompletionRunner {
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(client, params, options) {
    const runner = new ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(client, params, opts));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
  _addMessage(message, emit = true) {
    super._addMessage(message, emit);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
};

// node_modules/openai/_vendor/partial-json-parser/parser.mjs
var STR = 1;
var NUM = 2;
var ARR = 4;
var OBJ = 8;
var NULL = 16;
var BOOL = 32;
var NAN = 64;
var INFINITY = 128;
var MINUS_INFINITY = 256;
var INF = INFINITY | MINUS_INFINITY;
var SPECIAL = NULL | BOOL | INF | NAN;
var ATOM = STR | NUM | SPECIAL;
var COLLECTION = ARR | OBJ;
var ALL = ATOM | COLLECTION;
var Allow = {
  STR,
  NUM,
  ARR,
  OBJ,
  NULL,
  BOOL,
  NAN,
  INFINITY,
  MINUS_INFINITY,
  INF,
  SPECIAL,
  ATOM,
  COLLECTION,
  ALL
};
var PartialJSON = class extends Error {
};
var MalformedJSON = class extends Error {
};
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
var _parseJSON = (jsonString, allow) => {
  const length = jsonString.length;
  let index2 = 0;
  const markPartialJSON = (msg) => {
    throw new PartialJSON(`${msg} at position ${index2}`);
  };
  const throwMalformedError = (msg) => {
    throw new MalformedJSON(`${msg} at position ${index2}`);
  };
  const parseAny = () => {
    skipBlank();
    if (index2 >= length)
      markPartialJSON("Unexpected end of input");
    if (jsonString[index2] === '"')
      return parseStr();
    if (jsonString[index2] === "{")
      return parseObj();
    if (jsonString[index2] === "[")
      return parseArr();
    if (jsonString.substring(index2, index2 + 4) === "null" || Allow.NULL & allow && length - index2 < 4 && "null".startsWith(jsonString.substring(index2))) {
      index2 += 4;
      return null;
    }
    if (jsonString.substring(index2, index2 + 4) === "true" || Allow.BOOL & allow && length - index2 < 4 && "true".startsWith(jsonString.substring(index2))) {
      index2 += 4;
      return true;
    }
    if (jsonString.substring(index2, index2 + 5) === "false" || Allow.BOOL & allow && length - index2 < 5 && "false".startsWith(jsonString.substring(index2))) {
      index2 += 5;
      return false;
    }
    if (jsonString.substring(index2, index2 + 8) === "Infinity" || Allow.INFINITY & allow && length - index2 < 8 && "Infinity".startsWith(jsonString.substring(index2))) {
      index2 += 8;
      return Infinity;
    }
    if (jsonString.substring(index2, index2 + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index2 && length - index2 < 9 && "-Infinity".startsWith(jsonString.substring(index2))) {
      index2 += 9;
      return -Infinity;
    }
    if (jsonString.substring(index2, index2 + 3) === "NaN" || Allow.NAN & allow && length - index2 < 3 && "NaN".startsWith(jsonString.substring(index2))) {
      index2 += 3;
      return NaN;
    }
    return parseNum();
  };
  const parseStr = () => {
    const start = index2;
    let escape2 = false;
    index2++;
    while (index2 < length && (jsonString[index2] !== '"' || escape2 && jsonString[index2 - 1] === "\\")) {
      escape2 = jsonString[index2] === "\\" ? !escape2 : false;
      index2++;
    }
    if (jsonString.charAt(index2) == '"') {
      try {
        return JSON.parse(jsonString.substring(start, ++index2 - Number(escape2)));
      } catch (e) {
        throwMalformedError(String(e));
      }
    } else if (Allow.STR & allow) {
      try {
        return JSON.parse(jsonString.substring(start, index2 - Number(escape2)) + '"');
      } catch (e) {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
      }
    }
    markPartialJSON("Unterminated string literal");
  };
  const parseObj = () => {
    index2++;
    skipBlank();
    const obj = {};
    try {
      while (jsonString[index2] !== "}") {
        skipBlank();
        if (index2 >= length && Allow.OBJ & allow)
          return obj;
        const key = parseStr();
        skipBlank();
        index2++;
        try {
          const value = parseAny();
          Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
        } catch (e) {
          if (Allow.OBJ & allow)
            return obj;
          else
            throw e;
        }
        skipBlank();
        if (jsonString[index2] === ",")
          index2++;
      }
    } catch (e) {
      if (Allow.OBJ & allow)
        return obj;
      else
        markPartialJSON("Expected '}' at end of object");
    }
    index2++;
    return obj;
  };
  const parseArr = () => {
    index2++;
    const arr = [];
    try {
      while (jsonString[index2] !== "]") {
        arr.push(parseAny());
        skipBlank();
        if (jsonString[index2] === ",") {
          index2++;
        }
      }
    } catch (e) {
      if (Allow.ARR & allow) {
        return arr;
      }
      markPartialJSON("Expected ']' at end of array");
    }
    index2++;
    return arr;
  };
  const parseNum = () => {
    if (index2 === 0) {
      if (jsonString === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString);
      } catch (e) {
        if (Allow.NUM & allow) {
          try {
            if ("." === jsonString[jsonString.length - 1])
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
          } catch (e2) {
          }
        }
        throwMalformedError(String(e));
      }
    }
    const start = index2;
    if (jsonString[index2] === "-")
      index2++;
    while (jsonString[index2] && !",]}".includes(jsonString[index2]))
      index2++;
    if (index2 == length && !(Allow.NUM & allow))
      markPartialJSON("Unterminated number literal");
    try {
      return JSON.parse(jsonString.substring(start, index2));
    } catch (e) {
      if (jsonString.substring(start, index2) === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
      } catch (e2) {
        throwMalformedError(String(e2));
      }
    }
  };
  const skipBlank = () => {
    while (index2 < length && " \n\r	".includes(jsonString[index2])) {
      index2++;
    }
  };
  return parseAny();
};
var partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);

// node_modules/openai/lib/ChatCompletionStream.mjs
var __classPrivateFieldSet3 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet4 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ChatCompletionStream_instances;
var _ChatCompletionStream_params;
var _ChatCompletionStream_choiceEventStates;
var _ChatCompletionStream_currentChatCompletionSnapshot;
var _ChatCompletionStream_beginRequest;
var _ChatCompletionStream_getChoiceEventState;
var _ChatCompletionStream_addChunk;
var _ChatCompletionStream_emitToolCallDoneEvent;
var _ChatCompletionStream_emitContentDoneEvents;
var _ChatCompletionStream_endRequest;
var _ChatCompletionStream_getAutoParseableResponseFormat;
var _ChatCompletionStream_accumulateChatCompletion;
var ChatCompletionStream = class extends AbstractChatCompletionRunner {
  constructor(params) {
    super();
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_params.set(this, void 0);
    _ChatCompletionStream_choiceEventStates.set(this, void 0);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
    __classPrivateFieldSet3(this, _ChatCompletionStream_params, params, "f");
    __classPrivateFieldSet3(this, _ChatCompletionStream_choiceEventStates, [], "f");
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet4(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStream(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(client, params, options) {
    const runner = new ChatCompletionStream(params);
    runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(client, params, options) {
    var _a2;
    super._createChatCompletion;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
  }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
    let state = __classPrivateFieldGet4(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
    if (state) {
      return state;
    }
    state = {
      content_done: false,
      refusal_done: false,
      logprobs_content_done: false,
      logprobs_refusal_done: false,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    };
    __classPrivateFieldGet4(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
    return state;
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    for (const choice of chunk.choices) {
      const choiceSnapshot = completion.choices[choice.index];
      if (choice.delta.content != null && ((_a2 = choiceSnapshot.message) == null ? void 0 : _a2.role) === "assistant" && ((_b = choiceSnapshot.message) == null ? void 0 : _b.content)) {
        this._emit("content", choice.delta.content, choiceSnapshot.message.content);
        this._emit("content.delta", {
          delta: choice.delta.content,
          snapshot: choiceSnapshot.message.content,
          parsed: choiceSnapshot.message.parsed
        });
      }
      if (choice.delta.refusal != null && ((_c = choiceSnapshot.message) == null ? void 0 : _c.role) === "assistant" && ((_d = choiceSnapshot.message) == null ? void 0 : _d.refusal)) {
        this._emit("refusal.delta", {
          delta: choice.delta.refusal,
          snapshot: choiceSnapshot.message.refusal
        });
      }
      if (((_e = choice.logprobs) == null ? void 0 : _e.content) != null && ((_f = choiceSnapshot.message) == null ? void 0 : _f.role) === "assistant") {
        this._emit("logprobs.content.delta", {
          content: (_g = choice.logprobs) == null ? void 0 : _g.content,
          snapshot: (_i = (_h = choiceSnapshot.logprobs) == null ? void 0 : _h.content) != null ? _i : []
        });
      }
      if (((_j = choice.logprobs) == null ? void 0 : _j.refusal) != null && ((_k = choiceSnapshot.message) == null ? void 0 : _k.role) === "assistant") {
        this._emit("logprobs.refusal.delta", {
          refusal: (_l = choice.logprobs) == null ? void 0 : _l.refusal,
          snapshot: (_n = (_m = choiceSnapshot.logprobs) == null ? void 0 : _m.refusal) != null ? _n : []
        });
      }
      const state = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.finish_reason) {
        __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
        if (state.current_tool_call_index != null) {
          __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
        }
      }
      for (const toolCall of (_o = choice.delta.tool_calls) != null ? _o : []) {
        if (state.current_tool_call_index !== toolCall.index) {
          __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        state.current_tool_call_index = toolCall.index;
      }
      for (const toolCallDelta of (_p = choice.delta.tool_calls) != null ? _p : []) {
        const toolCallSnapshot = (_q = choiceSnapshot.message.tool_calls) == null ? void 0 : _q[toolCallDelta.index];
        if (!(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type)) {
          continue;
        }
        if ((toolCallSnapshot == null ? void 0 : toolCallSnapshot.type) === "function") {
          this._emit("tool_calls.function.arguments.delta", {
            name: (_r = toolCallSnapshot.function) == null ? void 0 : _r.name,
            index: toolCallDelta.index,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: toolCallSnapshot.function.parsed_arguments,
            arguments_delta: (_t = (_s = toolCallDelta.function) == null ? void 0 : _s.arguments) != null ? _t : ""
          });
        } else {
          assertNever(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type);
        }
      }
    }
  }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
    var _a2, _b, _c;
    const state = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (state.done_tool_calls.has(toolCallIndex)) {
      return;
    }
    const toolCallSnapshot = (_a2 = choiceSnapshot.message.tool_calls) == null ? void 0 : _a2[toolCallIndex];
    if (!toolCallSnapshot) {
      throw new Error("no tool call snapshot");
    }
    if (!toolCallSnapshot.type) {
      throw new Error("tool call snapshot missing `type`");
    }
    if (toolCallSnapshot.type === "function") {
      const inputTool = (_c = (_b = __classPrivateFieldGet4(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _b.tools) == null ? void 0 : _c.find((tool) => tool.type === "function" && tool.function.name === toolCallSnapshot.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: toolCallSnapshot.function.name,
        index: toolCallIndex,
        arguments: toolCallSnapshot.function.arguments,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCallSnapshot.function.arguments) : null
      });
    } else {
      assertNever(toolCallSnapshot.type);
    }
  }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
    var _a2, _b;
    const state = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (choiceSnapshot.message.content && !state.content_done) {
      state.content_done = true;
      const responseFormat = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
      this._emit("content.done", {
        content: choiceSnapshot.message.content,
        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
      });
    }
    if (choiceSnapshot.message.refusal && !state.refusal_done) {
      state.refusal_done = true;
      this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
    }
    if (((_a2 = choiceSnapshot.logprobs) == null ? void 0 : _a2.content) && !state.logprobs_content_done) {
      state.logprobs_content_done = true;
      this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
    }
    if (((_b = choiceSnapshot.logprobs) == null ? void 0 : _b.refusal) && !state.logprobs_refusal_done) {
      state.logprobs_refusal_done = true;
      this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet4(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
    __classPrivateFieldSet3(this, _ChatCompletionStream_choiceEventStates, [], "f");
    return finalizeChatCompletion(snapshot, __classPrivateFieldGet4(this, _ChatCompletionStream_params, "f"));
  }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
    var _a2;
    const responseFormat = (_a2 = __classPrivateFieldGet4(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _a2.response_format;
    if (isAutoParsableResponseFormat(responseFormat)) {
      return responseFormat;
    }
    return null;
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
    var _a3, _b2, _c2, _d2, _e, _f;
    var _a2, _b, _c, _d;
    let snapshot = __classPrivateFieldGet4(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      }, "f");
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index: index2, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index2];
      if (!choice) {
        choice = snapshot.choices[index2] = { finish_reason, index: index2, message: {}, logprobs, ...other };
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = Object.assign({}, logprobs);
        } else {
          const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
          assertIsEmpty(rest3);
          Object.assign(choice.logprobs, rest3);
          if (content2) {
            (_a3 = (_a2 = choice.logprobs).content) != null ? _a3 : _a2.content = [];
            choice.logprobs.content.push(...content2);
          }
          if (refusal2) {
            (_b2 = (_b = choice.logprobs).refusal) != null ? _b2 : _b.refusal = [];
            choice.logprobs.refusal.push(...refusal2);
          }
        }
      }
      if (finish_reason) {
        choice.finish_reason = finish_reason;
        if (__classPrivateFieldGet4(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput(__classPrivateFieldGet4(this, _ChatCompletionStream_params, "f"))) {
          if (finish_reason === "length") {
            throw new LengthFinishReasonError();
          }
          if (finish_reason === "content_filter") {
            throw new ContentFilterFinishReasonError();
          }
        }
      }
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
      assertIsEmpty(rest2);
      Object.assign(choice.message, rest2);
      if (refusal) {
        choice.message.refusal = (choice.message.refusal || "") + refusal;
      }
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_c2 = (_c = choice.message.function_call).arguments) != null ? _c2 : _c.arguments = "";
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (content) {
        choice.message.content = (choice.message.content || "") + content;
        if (!choice.message.refusal && __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
          choice.message.parsed = partialParse(choice.message.content);
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index3, id, type, function: fn, ...rest3 } of tool_calls) {
          const tool_call = (_d2 = (_d = choice.message.tool_calls)[index3]) != null ? _d2 : _d[index3] = {};
          Object.assign(tool_call, rest3);
          if (id)
            tool_call.id = id;
          if (type)
            tool_call.type = type;
          if (fn)
            (_f = tool_call.function) != null ? _f : tool_call.function = { name: (_e = fn.name) != null ? _e : "", arguments: "" };
          if (fn == null ? void 0 : fn.name)
            tool_call.function.name = fn.name;
          if (fn == null ? void 0 : fn.arguments) {
            tool_call.function.arguments += fn.arguments;
            if (shouldParseToolCall(__classPrivateFieldGet4(this, _ChatCompletionStream_params, "f"), tool_call)) {
              tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
            }
          }
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function finalizeChatCompletion(snapshot, params) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index: index2, logprobs, ...choiceRest }) => {
      var _a2, _b, _c;
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index2}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index2}`);
      }
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index2}`);
        }
        if (!name) {
          throw new OpenAIError(`missing function_call.name for choice ${index2}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name },
            role,
            refusal: (_a2 = message.refusal) != null ? _a2 : null
          },
          finish_reason,
          index: index2,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index: index2,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: (_b = message.refusal) != null ? _b : null,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].id
${str(snapshot)}`);
              }
              if (type == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].type
${str(snapshot)}`);
              }
              if (name == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].function.name
${str(snapshot)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
              }
              return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: (_c = message.refusal) != null ? _c : null },
        finish_reason,
        index: index2,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
  return maybeParseChatCompletion(completion, params);
}
function str(x) {
  return JSON.stringify(x);
}
function assertIsEmpty(obj) {
  return;
}
function assertNever(_x) {
}

// node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner = class extends ChatCompletionStream {
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStreamingRunner(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(client, params, options) {
    const runner = new ChatCompletionStreamingRunner(null);
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(client, params, opts));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new ChatCompletionStreamingRunner(
      // @ts-expect-error TODO these types are incompatible
      params
    );
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
};

// node_modules/openai/resources/beta/chat/completions.mjs
var Completions2 = class extends APIResource {
  parse(body, options) {
    validateInputTools(body.tools);
    return this._client.chat.completions.create(body, {
      ...options,
      headers: {
        ...options == null ? void 0 : options.headers,
        "X-Stainless-Helper-Method": "beta.chat.completions.parse"
      }
    })._thenUnwrap((completion) => parseChatCompletion(completion, body));
  }
  runFunctions(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runFunctions(this._client, body, options);
    }
    return ChatCompletionRunner.runFunctions(this._client, body, options);
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client, body, options);
    }
    return ChatCompletionRunner.runTools(this._client, body, options);
  }
  /**
   * Creates a chat completion stream
   */
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(this._client, body, options);
  }
};

// node_modules/openai/resources/beta/chat/chat.mjs
var Chat2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions2(this._client);
  }
};
(function(Chat3) {
  Chat3.Completions = Completions2;
})(Chat2 || (Chat2 = {}));

// node_modules/openai/resources/beta/realtime/sessions.mjs
var Sessions = class extends APIResource {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   */
  create(body, options) {
    return this._client.post("/realtime/sessions", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};

// node_modules/openai/resources/beta/realtime/realtime.mjs
var Realtime = class extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions(this._client);
  }
};
Realtime.Sessions = Sessions;

// node_modules/openai/lib/AssistantStream.mjs
var __classPrivateFieldGet5 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet4 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _AssistantStream_instances;
var _AssistantStream_events;
var _AssistantStream_runStepSnapshots;
var _AssistantStream_messageSnapshots;
var _AssistantStream_messageSnapshot;
var _AssistantStream_finalRun;
var _AssistantStream_currentContentIndex;
var _AssistantStream_currentContent;
var _AssistantStream_currentToolCallIndex;
var _AssistantStream_currentToolCall;
var _AssistantStream_currentEvent;
var _AssistantStream_currentRunSnapshot;
var _AssistantStream_currentRunStepSnapshot;
var _AssistantStream_addEvent;
var _AssistantStream_endRequest;
var _AssistantStream_handleMessage;
var _AssistantStream_handleRunStep;
var _AssistantStream_handleEvent;
var _AssistantStream_accumulateRunStep;
var _AssistantStream_accumulateMessage;
var _AssistantStream_accumulateContent;
var _AssistantStream_handleRun;
var AssistantStream = class extends EventStream {
  constructor() {
    super(...arguments);
    _AssistantStream_instances.add(this);
    _AssistantStream_events.set(this, []);
    _AssistantStream_runStepSnapshots.set(this, {});
    _AssistantStream_messageSnapshots.set(this, {});
    _AssistantStream_messageSnapshot.set(this, void 0);
    _AssistantStream_finalRun.set(this, void 0);
    _AssistantStream_currentContentIndex.set(this, void 0);
    _AssistantStream_currentContent.set(this, void 0);
    _AssistantStream_currentToolCallIndex.set(this, void 0);
    _AssistantStream_currentToolCall.set(this, void 0);
    _AssistantStream_currentEvent.set(this, void 0);
    _AssistantStream_currentRunSnapshot.set(this, void 0);
    _AssistantStream_currentRunStepSnapshot.set(this, void 0);
  }
  [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  static fromReadableStream(stream) {
    const runner = new AssistantStream();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  async _fromReadableStream(readableStream, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
  static createToolAssistantStream(threadId, runId, runs, params, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createToolAssistantStream(run, threadId, runId, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.submitToolOutputs(threadId, runId, body, {
      ...options,
      signal: this.controller.signal
    });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static createThreadAssistantStream(params, thread, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._threadAssistantStream(params, thread, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  static createAssistantStream(threadId, runs, params, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._runAssistantStream(threadId, runs, params, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  currentEvent() {
    return __classPrivateFieldGet5(this, _AssistantStream_currentEvent, "f");
  }
  currentRun() {
    return __classPrivateFieldGet5(this, _AssistantStream_currentRunSnapshot, "f");
  }
  currentMessageSnapshot() {
    return __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f");
  }
  currentRunStepSnapshot() {
    return __classPrivateFieldGet5(this, _AssistantStream_currentRunStepSnapshot, "f");
  }
  async finalRunSteps() {
    await this.done();
    return Object.values(__classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f"));
  }
  async finalMessages() {
    await this.done();
    return Object.values(__classPrivateFieldGet5(this, _AssistantStream_messageSnapshots, "f"));
  }
  async finalRun() {
    await this.done();
    if (!__classPrivateFieldGet5(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run was not received.");
    return __classPrivateFieldGet5(this, _AssistantStream_finalRun, "f");
  }
  async _createThreadAssistantStream(thread, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  async _createAssistantStream(run, threadId, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static accumulateDelta(acc, delta) {
    for (const [key, deltaValue] of Object.entries(delta)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = deltaValue;
        continue;
      }
      let accValue = acc[key];
      if (accValue === null || accValue === void 0) {
        acc[key] = deltaValue;
        continue;
      }
      if (key === "index" || key === "type") {
        acc[key] = deltaValue;
        continue;
      }
      if (typeof accValue === "string" && typeof deltaValue === "string") {
        accValue += deltaValue;
      } else if (typeof accValue === "number" && typeof deltaValue === "number") {
        accValue += deltaValue;
      } else if (isObj(accValue) && isObj(deltaValue)) {
        accValue = this.accumulateDelta(accValue, deltaValue);
      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
        if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
          accValue.push(...deltaValue);
          continue;
        }
        for (const deltaEntry of deltaValue) {
          if (!isObj(deltaEntry)) {
            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
          }
          const index2 = deltaEntry["index"];
          if (index2 == null) {
            console.error(deltaEntry);
            throw new Error("Expected array delta entry to have an `index` property");
          }
          if (typeof index2 !== "number") {
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index2}`);
          }
          const accEntry = accValue[index2];
          if (accEntry == null) {
            accValue.push(deltaEntry);
          } else {
            accValue[index2] = this.accumulateDelta(accEntry, deltaEntry);
          }
        }
        continue;
      } else {
        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
      }
      acc[key] = accValue;
    }
    return acc;
  }
  _addRun(run) {
    return run;
  }
  async _threadAssistantStream(params, thread, options) {
    return await this._createThreadAssistantStream(thread, params, options);
  }
  async _runAssistantStream(threadId, runs, params, options) {
    return await this._createAssistantStream(runs, threadId, params, options);
  }
  async _runToolAssistantStream(threadId, runId, runs, params, options) {
    return await this._createToolAssistantStream(runs, threadId, runId, params, options);
  }
};
_AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
  if (this.ended)
    return;
  __classPrivateFieldSet4(this, _AssistantStream_currentEvent, event, "f");
  __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
  switch (event.event) {
    case "thread.created":
      break;
    case "thread.run.created":
    case "thread.run.queued":
    case "thread.run.in_progress":
    case "thread.run.requires_action":
    case "thread.run.completed":
    case "thread.run.failed":
    case "thread.run.cancelling":
    case "thread.run.cancelled":
    case "thread.run.expired":
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
      break;
    case "thread.run.step.created":
    case "thread.run.step.in_progress":
    case "thread.run.step.delta":
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
      break;
    case "thread.message.created":
    case "thread.message.in_progress":
    case "thread.message.delta":
    case "thread.message.completed":
    case "thread.message.incomplete":
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
      break;
    case "error":
      throw new Error("Encountered an error event in event processing - errors should be processed earlier");
  }
}, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
  if (this.ended) {
    throw new OpenAIError(`stream has ended, this shouldn't happen`);
  }
  if (!__classPrivateFieldGet5(this, _AssistantStream_finalRun, "f"))
    throw Error("Final run has not been received");
  return __classPrivateFieldGet5(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
  const [accumulatedMessage, newContent] = __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
  __classPrivateFieldSet4(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
  __classPrivateFieldGet5(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
  for (const content of newContent) {
    const snapshotContent = accumulatedMessage.content[content.index];
    if ((snapshotContent == null ? void 0 : snapshotContent.type) == "text") {
      this._emit("textCreated", snapshotContent.text);
    }
  }
  switch (event.event) {
    case "thread.message.created":
      this._emit("messageCreated", event.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      this._emit("messageDelta", event.data.delta, accumulatedMessage);
      if (event.data.delta.content) {
        for (const content of event.data.delta.content) {
          if (content.type == "text" && content.text) {
            let textDelta = content.text;
            let snapshot = accumulatedMessage.content[content.index];
            if (snapshot && snapshot.type == "text") {
              this._emit("textDelta", textDelta, snapshot.text);
            } else {
              throw Error("The snapshot associated with this text delta is not text or missing");
            }
          }
          if (content.index != __classPrivateFieldGet5(this, _AssistantStream_currentContentIndex, "f")) {
            if (__classPrivateFieldGet5(this, _AssistantStream_currentContent, "f")) {
              switch (__classPrivateFieldGet5(this, _AssistantStream_currentContent, "f").type) {
                case "text":
                  this._emit("textDone", __classPrivateFieldGet5(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", __classPrivateFieldGet5(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
            __classPrivateFieldSet4(this, _AssistantStream_currentContentIndex, content.index, "f");
          }
          __classPrivateFieldSet4(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
        }
      }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (__classPrivateFieldGet5(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
        const currentContent = event.data.content[__classPrivateFieldGet5(this, _AssistantStream_currentContentIndex, "f")];
        if (currentContent) {
          switch (currentContent.type) {
            case "image_file":
              this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
              break;
            case "text":
              this._emit("textDone", currentContent.text, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
              break;
          }
        }
      }
      if (__classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f")) {
        this._emit("messageDone", event.data);
      }
      __classPrivateFieldSet4(this, _AssistantStream_messageSnapshot, void 0, "f");
  }
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
  const accumulatedRunStep = __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
  __classPrivateFieldSet4(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
  switch (event.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", event.data);
      break;
    case "thread.run.step.delta":
      const delta = event.data.delta;
      if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
        for (const toolCall of delta.step_details.tool_calls) {
          if (toolCall.index == __classPrivateFieldGet5(this, _AssistantStream_currentToolCallIndex, "f")) {
            this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
          } else {
            if (__classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"));
            }
            __classPrivateFieldSet4(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
            __classPrivateFieldSet4(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
            if (__classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"))
              this._emit("toolCallCreated", __classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"));
          }
        }
      }
      this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldSet4(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
      const details = event.data.step_details;
      if (details.type == "tool_calls") {
        if (__classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet4(this, _AssistantStream_currentToolCall, void 0, "f");
        }
      }
      this._emit("runStepDone", event.data, accumulatedRunStep);
      break;
    case "thread.run.step.in_progress":
      break;
  }
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
  __classPrivateFieldGet5(this, _AssistantStream_events, "f").push(event);
  this._emit("event", event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
  switch (event.event) {
    case "thread.run.step.created":
      __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      return event.data;
    case "thread.run.step.delta":
      let snapshot = __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      if (!snapshot) {
        throw Error("Received a RunStepDelta before creation of a snapshot");
      }
      let data = event.data;
      if (data.delta) {
        const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);
        __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
      }
      return __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      break;
  }
  if (__classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
    return __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
  throw new Error("No snapshot available");
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
  let newContent = [];
  switch (event.event) {
    case "thread.message.created":
      return [event.data, newContent];
    case "thread.message.delta":
      if (!snapshot) {
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      }
      let data = event.data;
      if (data.delta.content) {
        for (const contentElement of data.delta.content) {
          if (contentElement.index in snapshot.content) {
            let currentContent = snapshot.content[contentElement.index];
            snapshot.content[contentElement.index] = __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
          } else {
            snapshot.content[contentElement.index] = contentElement;
            newContent.push(contentElement);
          }
        }
      }
      return [snapshot, newContent];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (snapshot) {
        return [snapshot, newContent];
      } else {
        throw Error("Received thread message event with no existing snapshot");
      }
  }
  throw Error("Tried to accumulate a non-message event");
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
  return AssistantStream.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
  __classPrivateFieldSet4(this, _AssistantStream_currentRunSnapshot, event.data, "f");
  switch (event.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
      __classPrivateFieldSet4(this, _AssistantStream_finalRun, event.data, "f");
      if (__classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f")) {
        this._emit("toolCallDone", __classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"));
        __classPrivateFieldSet4(this, _AssistantStream_currentToolCall, void 0, "f");
      }
      break;
    case "thread.run.cancelling":
      break;
  }
};

// node_modules/openai/resources/beta/threads/messages.mjs
var Messages = class extends APIResource {
  /**
   * Create a message.
   */
  create(threadId, body, options) {
    return this._client.post(`/threads/${threadId}/messages`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieve a message.
   */
  retrieve(threadId, messageId, options) {
    return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a message.
   */
  update(threadId, messageId, body, options) {
    return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Deletes a message.
   */
  del(threadId, messageId, options) {
    return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};
var MessagesPage = class extends CursorPage {
};
Messages.MessagesPage = MessagesPage;

// node_modules/openai/resources/beta/threads/runs/steps.mjs
var Steps = class extends APIResource {
  retrieve(threadId, runId, stepId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.retrieve(threadId, runId, stepId, {}, query);
    }
    return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, runId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, runId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};
var RunStepsPage = class extends CursorPage {
};
Steps.RunStepsPage = RunStepsPage;

// node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs = class extends APIResource {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadId, params, options) {
    var _a2;
    const { include, ...body } = params;
    return this._client.post(`/threads/${threadId}/runs`, {
      query: { include },
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
      stream: (_a2 = params.stream) != null ? _a2 : false
    });
  }
  /**
   * Retrieves a run.
   */
  retrieve(threadId, runId, options) {
    return this._client.get(`/threads/${threadId}/runs/${runId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a run.
   */
  update(threadId, runId, body, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   */
  cancel(threadId, runId, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(threadId, body, options) {
    const run = await this.create(threadId, body, options);
    return await this.poll(threadId, run.id, options);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(threadId, runId, options) {
    const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
    if (options == null ? void 0 : options.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const { data: run, response } = await this.retrieve(threadId, runId, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, ...headers }
      }).withResponse();
      switch (run.status) {
        case "queued":
        case "in_progress":
        case "cancelling":
          let sleepInterval = 5e3;
          if (options == null ? void 0 : options.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return run;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  submitToolOutputs(threadId, runId, body, options) {
    var _a2;
    return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
      stream: (_a2 = body.stream) != null ? _a2 : false
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(threadId, runId, body, options) {
    const run = await this.submitToolOutputs(threadId, runId, body, options);
    return await this.poll(threadId, run.id, options);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(threadId, runId, body, options) {
    return AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);
  }
};
var RunsPage = class extends CursorPage {
};
Runs.RunsPage = RunsPage;
Runs.Steps = Steps;
Runs.RunStepsPage = RunStepsPage;

// node_modules/openai/resources/beta/threads/threads.mjs
var Threads = class extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs(this._client);
    this.messages = new Messages(this._client);
  }
  create(body = {}, options) {
    if (isRequestOptions(body)) {
      return this.create({}, body);
    }
    return this._client.post("/threads", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a thread.
   */
  retrieve(threadId, options) {
    return this._client.get(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a thread.
   */
  update(threadId, body, options) {
    return this._client.post(`/threads/${threadId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete a thread.
   */
  del(threadId, options) {
    return this._client.delete(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  createAndRun(body, options) {
    var _a2;
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
      stream: (_a2 = body.stream) != null ? _a2 : false
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(body, options) {
    const run = await this.createAndRun(body, options);
    return await this.runs.poll(run.thread_id, run.id, options);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(body, options) {
    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
  }
};
Threads.Runs = Runs;
Threads.RunsPage = RunsPage;
Threads.Messages = Messages;
Threads.MessagesPage = MessagesPage;

// node_modules/openai/lib/Util.mjs
var allSettledWithThrow = async (promises) => {
  const results = await Promise.allSettled(promises);
  const rejected = results.filter((result) => result.status === "rejected");
  if (rejected.length) {
    for (const result of rejected) {
      console.error(result.reason);
    }
    throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
  }
  const values = [];
  for (const result of results) {
    if (result.status === "fulfilled") {
      values.push(result.value);
    }
  }
  return values;
};

// node_modules/openai/resources/beta/vector-stores/files.mjs
var Files = class extends APIResource {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/files`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(vectorStoreId, fileId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(vectorStoreId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(vectorStoreId, {}, query);
    }
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  del(vectorStoreId, fileId, options) {
    return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const file = await this.create(vectorStoreId, body, options);
    return await this.poll(vectorStoreId, file.id, options);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(vectorStoreId, fileId, options) {
    const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
    if (options == null ? void 0 : options.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const fileResponse = await this.retrieve(vectorStoreId, fileId, {
        ...options,
        headers
      }).withResponse();
      const file = fileResponse.data;
      switch (file.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options == null ? void 0 : options.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "failed":
        case "completed":
          return file;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(vectorStoreId, file, options) {
    const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
    return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(vectorStoreId, file, options) {
    const fileInfo = await this.upload(vectorStoreId, file, options);
    return await this.poll(vectorStoreId, fileInfo.id, options);
  }
};
var VectorStoreFilesPage = class extends CursorPage {
};
Files.VectorStoreFilesPage = VectorStoreFilesPage;

// node_modules/openai/resources/beta/vector-stores/file-batches.mjs
var FileBatches = class extends APIResource {
  /**
   * Create a vector store file batch.
   */
  create(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(vectorStoreId, batchId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(vectorStoreId, batchId, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const batch = await this.create(vectorStoreId, body);
    return await this.poll(vectorStoreId, batch.id, options);
  }
  listFiles(vectorStoreId, batchId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listFiles(vectorStoreId, batchId, {}, query);
    }
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, VectorStoreFilesPage, { query, ...options, headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers } });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(vectorStoreId, batchId, options) {
    const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
    if (options == null ? void 0 : options.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {
        ...options,
        headers
      }).withResponse();
      switch (batch.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options == null ? void 0 : options.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return batch;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
    var _a2;
    if (files == null || files.length == 0) {
      throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
    }
    const configuredConcurrency = (_a2 = options == null ? void 0 : options.maxConcurrency) != null ? _a2 : 5;
    const concurrencyLimit = Math.min(configuredConcurrency, files.length);
    const client = this._client;
    const fileIterator = files.values();
    const allFileIds = [...fileIds];
    async function processFiles(iterator) {
      for (let item of iterator) {
        const fileObj = await client.files.create({ file: item, purpose: "assistants" }, options);
        allFileIds.push(fileObj.id);
      }
    }
    const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
    await allSettledWithThrow(workers);
    return await this.createAndPoll(vectorStoreId, {
      file_ids: allFileIds
    });
  }
};

// node_modules/openai/resources/beta/vector-stores/vector-stores.mjs
var VectorStores = class extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files(this._client);
    this.fileBatches = new FileBatches(this._client);
  }
  /**
   * Create a vector store.
   */
  create(body, options) {
    return this._client.post("/vector_stores", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(vectorStoreId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a vector store.
   */
  update(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/vector_stores", VectorStoresPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete a vector store.
   */
  del(vectorStoreId, options) {
    return this._client.delete(`/vector_stores/${vectorStoreId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};
var VectorStoresPage = class extends CursorPage {
};
VectorStores.VectorStoresPage = VectorStoresPage;
VectorStores.Files = Files;
VectorStores.VectorStoreFilesPage = VectorStoreFilesPage;
VectorStores.FileBatches = FileBatches;

// node_modules/openai/resources/beta/beta.mjs
var Beta = class extends APIResource {
  constructor() {
    super(...arguments);
    this.realtime = new Realtime(this._client);
    this.vectorStores = new VectorStores(this._client);
    this.chat = new Chat2(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads(this._client);
  }
};
Beta.Realtime = Realtime;
Beta.VectorStores = VectorStores;
Beta.VectorStoresPage = VectorStoresPage;
Beta.Assistants = Assistants;
Beta.AssistantsPage = AssistantsPage;
Beta.Threads = Threads;

// node_modules/openai/resources/completions.mjs
var Completions3 = class extends APIResource {
  create(body, options) {
    var _a2;
    return this._client.post("/completions", { body, ...options, stream: (_a2 = body.stream) != null ? _a2 : false });
  }
};

// node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(body, options) {
    return this._client.post("/embeddings", { body, ...options });
  }
};

// node_modules/openai/resources/files.mjs
var Files2 = class extends APIResource {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 100 GB.
   *
   * The Assistants API supports files up to 2 million tokens and of specific file
   * types. See the
   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
   * details.
   *
   * The Fine-tuning API only supports `.jsonl` files. The input also has certain
   * required formats for fine-tuning
   * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
   * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   * models.
   *
   * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
   * has a specific required
   * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(body, options) {
    return this._client.post("/files", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileId, options) {
    return this._client.get(`/files/${fileId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/files", FileObjectsPage, { query, ...options });
  }
  /**
   * Delete a file.
   */
  del(fileId, options) {
    return this._client.delete(`/files/${fileId}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, {
      ...options,
      headers: { Accept: "application/binary", ...options == null ? void 0 : options.headers },
      __binaryResponse: true
    });
  }
  /**
   * Returns the contents of the specified file.
   *
   * @deprecated The `.content()` method should be used instead
   */
  retrieveContent(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, options);
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep2(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};
var FileObjectsPage = class extends CursorPage {
};
Files2.FileObjectsPage = FileObjectsPage;

// node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs
var Checkpoints = class extends APIResource {
  list(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, { query, ...options });
  }
};
var FineTuningJobCheckpointsPage = class extends CursorPage {
};
Checkpoints.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;

// node_modules/openai/resources/fine-tuning/jobs/jobs.mjs
var Jobs = class extends APIResource {
  constructor() {
    super(...arguments);
    this.checkpoints = new Checkpoints(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  retrieve(fineTuningJobId, options) {
    return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuningJobId, options) {
    return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
  }
  listEvents(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
      query,
      ...options
    });
  }
};
var FineTuningJobsPage = class extends CursorPage {
};
var FineTuningJobEventsPage = class extends CursorPage {
};
Jobs.FineTuningJobsPage = FineTuningJobsPage;
Jobs.FineTuningJobEventsPage = FineTuningJobEventsPage;
Jobs.Checkpoints = Checkpoints;
Jobs.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource {
  constructor() {
    super(...arguments);
    this.jobs = new Jobs(this._client);
  }
};
FineTuning.Jobs = Jobs;
FineTuning.FineTuningJobsPage = FineTuningJobsPage;
FineTuning.FineTuningJobEventsPage = FineTuningJobEventsPage;

// node_modules/openai/resources/images.mjs
var Images = class extends APIResource {
  /**
   * Creates a variation of a given image.
   */
  createVariation(body, options) {
    return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an edited or extended image given an original image and a prompt.
   */
  edit(body, options) {
    return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an image given a prompt.
   */
  generate(body, options) {
    return this._client.post("/images/generations", { body, ...options });
  }
};

// node_modules/openai/resources/models.mjs
var Models = class extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options) {
    return this._client.get(`/models/${model}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this._client.getAPIList("/models", ModelsPage, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(model, options) {
    return this._client.delete(`/models/${model}`, options);
  }
};
var ModelsPage = class extends Page {
};
Models.ModelsPage = ModelsPage;

// node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
};

// node_modules/openai/resources/uploads/parts.mjs
var Parts = class extends APIResource {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(uploadId, body, options) {
    return this._client.post(`/uploads/${uploadId}/parts`, multipartFormRequestOptions({ body, ...options }));
  }
};

// node_modules/openai/resources/uploads/uploads.mjs
var Uploads = class extends APIResource {
  constructor() {
    super(...arguments);
    this.parts = new Parts(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose`s, the correct `mime_type` must be specified. Please refer
   * to documentation for the supported MIME types for your use case:
   *
   * - [Assistants](https://platform.openai.com/docs/assistants/tools/file-search#supported-files)
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(body, options) {
    return this._client.post("/uploads", { body, ...options });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(uploadId, options) {
    return this._client.post(`/uploads/${uploadId}/cancel`, options);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(uploadId, body, options) {
    return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });
  }
};
Uploads.Parts = Parts;

// node_modules/openai/index.mjs
var _a;
var OpenAI = class extends APIClient {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = ((_a2) => (_a2 = readEnv("OPENAI_ORG_ID")) != null ? _a2 : null)(), project = ((_b) => (_b = readEnv("OPENAI_PROJECT_ID")) != null ? _b : null)(), ...opts } = {}) {
    var _a3;
    if (apiKey === void 0) {
      throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
    }
    const options = {
      apiKey,
      organization,
      project,
      ...opts,
      baseURL: baseURL || `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    super({
      baseURL: options.baseURL,
      timeout: (_a3 = options.timeout) != null ? _a3 : 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.completions = new Completions3(this);
    this.chat = new Chat(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files2(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.beta = new Beta(this);
    this.batches = new Batches(this);
    this.uploads = new Uploads(this);
    this._options = options;
    this.apiKey = apiKey;
    this.organization = organization;
    this.project = project;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      "OpenAI-Project": this.project,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
  stringifyQuery(query) {
    return stringify(query, { arrayFormat: "brackets" });
  }
};
_a = OpenAI;
OpenAI.OpenAI = _a;
OpenAI.DEFAULT_TIMEOUT = 6e5;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
OpenAI.toFile = toFile;
OpenAI.fileFromPath = fileFromPath;
OpenAI.Completions = Completions3;
OpenAI.Chat = Chat;
OpenAI.Embeddings = Embeddings;
OpenAI.Files = Files2;
OpenAI.FileObjectsPage = FileObjectsPage;
OpenAI.Images = Images;
OpenAI.Audio = Audio;
OpenAI.Moderations = Moderations;
OpenAI.Models = Models;
OpenAI.ModelsPage = ModelsPage;
OpenAI.FineTuning = FineTuning;
OpenAI.Beta = Beta;
OpenAI.Batches = Batches;
OpenAI.BatchesPage = BatchesPage;
OpenAI.Uploads = Uploads;
var openai_default = OpenAI;

// services/OpenAIService.ts
var import_obsidian2 = require("obsidian");
var OpenAIService = class {
  constructor(settings, errorHandler) {
    this.rateLimitDelay = 20;
    // ms between requests
    this.lastRequestTime = 0;
    this.settings = settings;
    this.errorHandler = errorHandler;
    if (!settings.apiKey) {
      console.warn("OpenAI API key is missing. OpenAIService will not be initialized.");
      this.client = null;
      return;
    }
    this.client = new openai_default({
      apiKey: settings.apiKey,
      dangerouslyAllowBrowser: true
      // Enable browser-like environment usage
    });
  }
  /**
   * Check if the service is initialized
   */
  isInitialized() {
    return this.client !== null;
  }
  /**
   * Creates embeddings for the given text chunks with rate limiting and retries
   */
  async createEmbeddings(chunks) {
    if (!this.client) {
      console.warn("OpenAIService is not initialized. Cannot create embeddings.");
      new import_obsidian2.Notice("OpenAI API key is missing. Please set it in the plugin settings.");
      return chunks.map(() => ({
        data: [],
        usage: { prompt_tokens: 0, total_tokens: 0 },
        model: "text-embedding-ada-002"
        // Default model to maintain output consistency
      }));
    }
    const embeddings = [];
    for (let i = 0; i < chunks.length; i++) {
      try {
        const timeSinceLastRequest = Date.now() - this.lastRequestTime;
        if (timeSinceLastRequest < this.rateLimitDelay) {
          await new Promise(
            (resolve) => setTimeout(resolve, this.rateLimitDelay - timeSinceLastRequest)
          );
        }
        const response = await this.client.embeddings.create({
          model: "text-embedding-ada-002",
          // Use the correct model
          input: chunks[i],
          encoding_format: "float"
        });
        this.lastRequestTime = Date.now();
        embeddings.push({
          data: [
            {
              embedding: response.data[0].embedding,
              index: i
            }
          ],
          usage: {
            prompt_tokens: response.usage.prompt_tokens,
            total_tokens: response.usage.total_tokens
          },
          model: response.model
        });
      } catch (error) {
        this.handleEmbeddingError(error, chunks[i]);
        embeddings.push({
          data: [],
          usage: { prompt_tokens: 0, total_tokens: 0 },
          model: "text-embedding-ada-002"
        });
      }
    }
    return embeddings;
  }
  /**
   * Handles various types of OpenAI API errors
   */
  handleEmbeddingError(error, chunk) {
    let errorMessage;
    if (error instanceof openai_default.APIError) {
      switch (error.status) {
        case 429:
          errorMessage = "Rate limit exceeded. Please try again later.";
          break;
        case 401:
          errorMessage = "Invalid API key. Please check your settings.";
          break;
        case 413:
          errorMessage = "Text chunk too large for embedding.";
          break;
        default:
          errorMessage = `OpenAI API error: ${error.message}`;
      }
    } else {
      errorMessage = `Unexpected error: ${error.message}`;
    }
    this.errorHandler.handleError(error, {
      context: "OpenAIService.createEmbeddings",
      metadata: {
        chunkPreview: chunk.substring(0, 100) + "..."
        // First 100 chars for context
      }
    });
    new import_obsidian2.Notice(`Error creating embedding: ${errorMessage}`);
  }
  /**
   * Updates service settings
   */
  updateSettings(settings) {
    this.settings = settings;
    if (!settings.apiKey) {
      console.warn("OpenAI API key is missing. OpenAIService will not be initialized.");
      this.client = null;
      return;
    }
    this.client = new openai_default({
      apiKey: settings.apiKey,
      dangerouslyAllowBrowser: true
      // Ensure this remains enabled
    });
  }
  /**
   * Updates rate limiting parameters
   */
  updateRateLimit(delayMs) {
    this.rateLimitDelay = delayMs;
  }
};

// services/QueueService.ts
var import_obsidian4 = require("obsidian");

// services/MetadataExtractor.ts
var import_obsidian3 = require("obsidian");
var MetadataExtractor = class {
  /**
   * Extracts all metadata from an Obsidian file
   */
  async extractMetadata(file, content) {
    try {
      const fileContent = content || await file.vault.read(file);
      const frontMatter = this.extractFrontMatter(fileContent);
      const metadata = {
        obsidianId: file.path,
        path: file.path,
        lastModified: file.stat.mtime,
        created: file.stat.ctime,
        size: file.stat.size,
        frontMatter,
        tags: this.extractTags(fileContent, frontMatter),
        links: this.extractLinks(fileContent),
        customMetadata: {}
      };
      const aliases = this.extractAliases(frontMatter);
      if (aliases.length > 0) {
        metadata.customMetadata.aliases = aliases;
      }
      const loc = this.extractSourceLocation(frontMatter);
      if (loc) {
        metadata.loc = loc;
      }
      if (frontMatter == null ? void 0 : frontMatter.source) {
        metadata.source = frontMatter.source;
      }
      if (frontMatter == null ? void 0 : frontMatter.file_id) {
        metadata.file_id = frontMatter.file_id;
      }
      if (frontMatter == null ? void 0 : frontMatter.blobType) {
        metadata.blobType = frontMatter.blobType;
      }
      return metadata;
    } catch (error) {
      console.error("Error extracting metadata:", error);
      throw new Error(`${"INVALID_METADATA" /* INVALID_METADATA */}: ${error.message}`);
    }
  }
  /**
   * Extracts YAML frontmatter from document content
   */
  extractFrontMatter(content) {
    try {
      const frontMatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if (!frontMatterMatch)
        return void 0;
      const yaml = frontMatterMatch[1];
      return (0, import_obsidian3.parseYaml)(yaml);
    } catch (error) {
      console.error("Error parsing frontmatter:", error);
      throw new Error(`${"YAML_PARSE_ERROR" /* YAML_PARSE_ERROR */}: ${error.message}`);
    }
  }
  /**
   * Extracts internal links from document content
   * Handles both standard links [[Page]] and aliased links [[Page|Alias]]
   */
  extractLinks(content) {
    const linkRegex = /\[\[(.*?)(?:\|.*?)?\]\]/g;
    const links = /* @__PURE__ */ new Set();
    let match;
    while ((match = linkRegex.exec(content)) !== null) {
      const link = match[1].split("|")[0];
      const cleanLink = this.cleanLink(link);
      if (cleanLink) {
        links.add(cleanLink);
      }
    }
    return Array.from(links);
  }
  /**
   * Cleans and normalizes a link path
   */
  cleanLink(link) {
    let cleanLink = link.split("#")[0];
    cleanLink = cleanLink.split("?")[0];
    cleanLink = cleanLink.trim();
    return cleanLink;
  }
  /**
   * Extracts tags from both content and frontmatter
   */
  extractTags(content, frontMatter) {
    const tags = /* @__PURE__ */ new Set();
    const tagRegex = /#([A-Za-z0-9/_-]+)/g;
    let match;
    while ((match = tagRegex.exec(content)) !== null) {
      tags.add(match[1]);
    }
    if (frontMatter == null ? void 0 : frontMatter.tags) {
      const frontMatterTags = Array.isArray(frontMatter.tags) ? frontMatter.tags : [frontMatter.tags];
      frontMatterTags.forEach((tag) => {
        if (typeof tag === "string") {
          const cleanTag = tag.startsWith("#") ? tag.slice(1) : tag;
          tags.add(cleanTag);
        }
      });
    }
    return Array.from(tags);
  }
  /**
   * Extracts aliases from frontmatter
   */
  extractAliases(frontMatter) {
    if (!(frontMatter == null ? void 0 : frontMatter.aliases))
      return [];
    if (Array.isArray(frontMatter.aliases)) {
      return frontMatter.aliases.filter((alias) => typeof alias === "string");
    }
    if (typeof frontMatter.aliases === "string") {
      return [frontMatter.aliases];
    }
    return [];
  }
  /**
   * Extracts source location information from frontmatter
   */
  extractSourceLocation(frontMatter) {
    var _a2, _b, _c, _d;
    if (!((_b = (_a2 = frontMatter == null ? void 0 : frontMatter.loc) == null ? void 0 : _a2.lines) == null ? void 0 : _b.from) || !((_d = (_c = frontMatter == null ? void 0 : frontMatter.loc) == null ? void 0 : _c.lines) == null ? void 0 : _d.to)) {
      return void 0;
    }
    return {
      lines: {
        from: Number(frontMatter.loc.lines.from),
        to: Number(frontMatter.loc.lines.to)
      }
    };
  }
};

// utils/TextSplitter.ts
var TextSplitter = class {
  constructor(settings, metadataExtractor) {
    // Regex patterns for splitting
    this.SENTENCE_BOUNDARY = /[.!?]\s+/;
    this.PARAGRAPH_BOUNDARY = /\n\s*\n/;
    this.YAML_FRONT_MATTER = /^---\n([\s\S]*?)\n---/;
    this.settings = settings || { ...DEFAULT_CHUNKING_OPTIONS };
    this.validateSettings(this.settings);
    this.metadataExtractor = metadataExtractor || new MetadataExtractor();
  }
  validateSettings(settings) {
    if (settings.chunkSize <= 0) {
      throw new Error("Chunk size must be greater than 0.");
    }
    if (settings.chunkOverlap >= settings.chunkSize) {
      throw new Error("Chunk overlap must be less than chunk size.");
    }
    if (settings.minChunkSize > settings.chunkSize) {
      throw new Error("Minimum chunk size must not exceed chunk size.");
    }
  }
  async splitDocument(content, metadata) {
    try {
      console.log("Starting document split:", {
        contentLength: content.length,
        settings: this.settings
      });
      if (!(content == null ? void 0 : content.trim())) {
        console.log("Empty content received");
        return [];
      }
      let frontMatter = null;
      const frontMatterMatch = this.YAML_FRONT_MATTER.exec(content);
      if (frontMatterMatch) {
        try {
          frontMatter = this.parseFrontMatter(frontMatterMatch[1]);
          const enhancedMetadata = await this.enhanceMetadata(content, metadata, frontMatter);
          metadata = enhancedMetadata;
          content = content.replace(this.YAML_FRONT_MATTER, "").trim();
          console.log("Front matter extracted and metadata enhanced:", { frontMatter });
        } catch (error) {
          console.warn("Failed to parse front matter:", error);
        }
      }
      const trimmedContent = content.trim();
      if (trimmedContent.length <= Math.max(this.settings.minChunkSize, this.settings.chunkSize)) {
        if (trimmedContent.length === 0) {
          console.log("No content after trimming, returning empty array");
          return [];
        }
        console.log("Content is smaller than chunk size, creating single chunk:", {
          contentLength: trimmedContent.length,
          chunkSize: this.settings.chunkSize,
          minChunkSize: this.settings.minChunkSize
        });
        const singleChunk = this.createChunk(trimmedContent, 0, metadata);
        console.log("Created single chunk:", {
          chunkSize: singleChunk.content.length,
          preview: singleChunk.content.substring(0, 100)
        });
        return [singleChunk];
      }
      const paragraphs = content.split(this.PARAGRAPH_BOUNDARY).map((p) => p.trim()).filter((p) => p.length > 0);
      console.log("Split into paragraphs:", {
        paragraphCount: paragraphs.length,
        paragraphs: paragraphs.map((p) => p.substring(0, 100))
        // Log preview of each paragraph
      });
      const chunks = [];
      let currentChunk = "";
      let chunkIndex = 0;
      for (const paragraph of paragraphs) {
        if (paragraph.length >= this.settings.chunkSize) {
          if (currentChunk) {
            chunks.push(this.createChunk(currentChunk, chunkIndex++, metadata));
            currentChunk = "";
          }
          const sentences = paragraph.split(this.SENTENCE_BOUNDARY);
          let sentenceChunk = "";
          for (const sentence of sentences) {
            const trimmedSentence = sentence.trim();
            if (!trimmedSentence)
              continue;
            if ((sentenceChunk + " " + trimmedSentence).length > this.settings.chunkSize) {
              if (sentenceChunk) {
                chunks.push(this.createChunk(sentenceChunk, chunkIndex++, metadata));
                sentenceChunk = trimmedSentence;
              } else {
                let position = 0;
                while (position < trimmedSentence.length) {
                  const chunk = trimmedSentence.slice(
                    position,
                    Math.min(position + this.settings.chunkSize, trimmedSentence.length)
                  );
                  chunks.push(this.createChunk(chunk, chunkIndex++, metadata));
                  position += this.settings.chunkSize;
                }
                sentenceChunk = "";
              }
            } else {
              sentenceChunk += (sentenceChunk ? " " : "") + trimmedSentence;
            }
          }
          if (sentenceChunk) {
            chunks.push(this.createChunk(sentenceChunk, chunkIndex++, metadata));
          }
        } else {
          const potentialChunkSize = currentChunk ? currentChunk.length + 2 + paragraph.length : paragraph.length;
          if (potentialChunkSize <= this.settings.chunkSize) {
            currentChunk += (currentChunk ? "\n\n" : "") + paragraph;
          } else {
            if (currentChunk) {
              chunks.push(this.createChunk(currentChunk, chunkIndex++, metadata));
            }
            currentChunk = paragraph;
          }
        }
      }
      if (currentChunk) {
        chunks.push(this.createChunk(currentChunk, chunkIndex++, metadata));
      }
      if (chunks.length === 0 && trimmedContent.length > 0) {
        console.log("Creating fallback chunk for content:", {
          contentLength: trimmedContent.length
        });
        chunks.push(this.createChunk(trimmedContent, 0, metadata));
      }
      if (this.settings.chunkOverlap > 0 && chunks.length > 1) {
        this.applyOverlap(chunks);
      }
      console.log("Finished creating chunks:", {
        chunkCount: chunks.length,
        chunkSizes: chunks.map((c) => c.content.length),
        chunkPreviews: chunks.map((c) => ({
          index: c.chunkIndex,
          size: c.content.length,
          preview: c.content.substring(0, 100)
        }))
      });
      return chunks;
    } catch (error) {
      console.error("Error in splitDocument:", error);
      throw {
        type: "CHUNKING_ERROR" /* CHUNKING_ERROR */,
        message: "Error occurred during document chunking",
        details: error.message
      };
    }
  }
  createChunk(content, index2, metadata) {
    const trimmedContent = content.trim();
    if (trimmedContent.length < this.settings.minChunkSize) {
      console.warn("Chunk smaller than minChunkSize:", {
        size: trimmedContent.length,
        minSize: this.settings.minChunkSize
      });
    }
    return {
      content: trimmedContent,
      chunkIndex: index2,
      metadata: { ...metadata }
    };
  }
  applyOverlap(chunks) {
    if (chunks.length <= 1)
      return;
    for (let i = chunks.length - 1; i > 0; i--) {
      const currentChunk = chunks[i];
      const previousChunk = chunks[i - 1];
      const overlapText = previousChunk.content.slice(-this.settings.chunkOverlap);
      if (overlapText) {
        currentChunk.content = overlapText + "\n\n" + currentChunk.content;
      }
    }
  }
  async enhanceMetadata(content, baseMetadata, frontMatter) {
    var _a2, _b, _c, _d;
    const enhancedMetadata = { ...baseMetadata };
    const tags = new Set(enhancedMetadata.tags || []);
    const links = new Set(enhancedMetadata.links || []);
    let aliases = ((_a2 = enhancedMetadata.customMetadata) == null ? void 0 : _a2.aliases) || [];
    const contentMetadata = await this.metadataExtractor.extractMetadata({
      path: baseMetadata.obsidianId,
      stat: {
        mtime: baseMetadata.lastModified,
        ctime: baseMetadata.created,
        size: baseMetadata.size
      },
      vault: baseMetadata.vault
    }, content);
    (_b = contentMetadata.tags) == null ? void 0 : _b.forEach((tag) => tags.add(tag));
    (_c = contentMetadata.links) == null ? void 0 : _c.forEach((link) => links.add(link));
    if ((_d = contentMetadata.customMetadata) == null ? void 0 : _d.aliases) {
      aliases = [.../* @__PURE__ */ new Set([...aliases, ...contentMetadata.customMetadata.aliases])];
    }
    enhancedMetadata.tags = Array.from(tags);
    enhancedMetadata.customMetadata = {
      ...enhancedMetadata.customMetadata,
      aliases
    };
    enhancedMetadata.frontMatter = frontMatter || enhancedMetadata.frontMatter;
    return enhancedMetadata;
  }
  parseFrontMatter(frontMatter) {
    try {
      const result = {};
      const lines = frontMatter.split("\n");
      for (const line of lines) {
        const trimmedLine = line.trim();
        if (!trimmedLine || trimmedLine.startsWith("#"))
          continue;
        const separatorIndex = line.indexOf(":");
        if (separatorIndex === -1)
          continue;
        const key = line.slice(0, separatorIndex).trim();
        let value = line.slice(separatorIndex + 1).trim();
        value = value.replace(/^["'](.*)["']$/, "$1");
        if (value.startsWith("- ")) {
          result[key] = value.split("\n").map((item) => item.replace("- ", "").trim()).filter(Boolean);
        } else {
          result[key] = value;
        }
      }
      return result;
    } catch (error) {
      console.warn("Failed to parse front matter:", error);
      return {};
    }
  }
  getSettings() {
    return { ...this.settings };
  }
};

// services/QueueService.ts
var QueueService = class {
  constructor(maxConcurrent, maxRetries, supabaseService, openAIService, errorHandler, notificationManager, vault, chunkSettings) {
    this.maxConcurrent = maxConcurrent;
    this.maxRetries = maxRetries;
    this.supabaseService = supabaseService;
    this.openAIService = openAIService;
    this.errorHandler = errorHandler;
    this.notificationManager = notificationManager;
    this.queue = [];
    this.processingQueue = [];
    this.isProcessing = false;
    this.isStopped = true;
    this.isInitialized = false;
    this.processingInterval = null;
    this.vault = vault;
    const validatedChunkSettings = chunkSettings || { ...DEFAULT_CHUNKING_OPTIONS };
    try {
      this.textSplitter = new TextSplitter(validatedChunkSettings);
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "QueueService.constructor",
        metadata: validatedChunkSettings
      });
      throw new Error("Failed to initialize TextSplitter with provided settings.");
    }
  }
  start() {
    if (!this.isStopped)
      return;
    this.isStopped = false;
    this.processQueue();
    this.processingInterval = setInterval(() => {
      if (!this.isProcessing) {
        this.processQueue();
      }
    }, 1e3);
  }
  stop() {
    this.isStopped = true;
    if (this.processingInterval) {
      clearInterval(this.processingInterval);
      this.processingInterval = null;
    }
  }
  async addTask(task) {
    if (this.queue.length >= 1e3) {
      throw new Error("QUEUE_FULL" /* QUEUE_FULL */);
    }
    console.log("Adding task to queue:", {
      id: task.id,
      type: task.type,
      priority: task.priority
    });
    if (task.priority > 1) {
      this.queue.unshift(task);
    } else {
      this.queue.push(task);
    }
    this.notifyProgress(task.id, 0, "Task queued");
    if (!this.isProcessing && !this.isStopped) {
      this.processQueue();
    }
  }
  async processQueue() {
    if (this.isProcessing || this.isStopped || this.queue.length === 0) {
      return;
    }
    this.isProcessing = true;
    try {
      while (this.queue.length > 0 && this.processingQueue.length < this.maxConcurrent) {
        const task = this.queue.shift();
        if (task) {
          this.processingQueue.push(task);
          this.processTask(task).catch((error) => {
            this.handleTaskError(task, error);
          });
        }
      }
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "QueueService.processQueue"
      });
    } finally {
      this.isProcessing = false;
    }
  }
  async processTask(task) {
    console.log("Processing task:", {
      id: task.id,
      type: task.type,
      status: task.status
    });
    try {
      task.status = "PROCESSING" /* PROCESSING */;
      task.startedAt = Date.now();
      this.notifyProgress(task.id, 0, `Starting ${task.type.toLowerCase()}`);
      switch (task.type) {
        case "CREATE" /* CREATE */:
        case "UPDATE" /* UPDATE */:
          await this.processCreateUpdateTask(task);
          break;
        case "DELETE" /* DELETE */:
          await this.processDeleteTask(task);
          break;
        default:
          throw new Error(`Unsupported task type: ${task.type}`);
      }
      task.status = "COMPLETED" /* COMPLETED */;
      task.completedAt = Date.now();
      this.notifyProgress(task.id, 100, "Task completed");
      console.log("Task completed successfully:", task.id);
    } catch (error) {
      console.error("Error processing task:", {
        taskId: task.id,
        error
      });
      await this.handleTaskError(task, error);
    } finally {
      this.removeFromProcessingQueue(task);
    }
  }
  async processCreateUpdateTask(task) {
    var _a2;
    if (!this.supabaseService || !this.openAIService) {
      throw new Error("Required services not initialized");
    }
    try {
      console.log("Reading file:", task.id);
      const file = this.vault.getAbstractFileByPath(task.id);
      if (!(file instanceof import_obsidian4.TFile)) {
        throw new Error(`File not found or not a TFile: ${task.id}`);
      }
      const content = await this.vault.read(file);
      console.log("File content read successfully:", {
        fileId: task.id,
        contentLength: content.length,
        contentPreview: content.substring(0, 100)
      });
      this.notifyProgress(task.id, 20, "Splitting content");
      const chunks = this.textSplitter.splitDocument(content, task.metadata);
      if (!chunks || !Array.isArray(chunks) || chunks.length === 0) {
        console.log("No valid chunks created for file:", {
          fileId: task.id,
          contentLength: content.length,
          settings: this.textSplitter.getSettings()
        });
        return;
      }
      console.log("Content split into chunks:", {
        numberOfChunks: chunks.length,
        chunkSizes: chunks.map((c) => c.content.length),
        firstChunkPreview: (_a2 = chunks[0]) == null ? void 0 : _a2.content.substring(0, 100)
      });
      if (chunks.length === 0) {
        console.warn("No chunks created for file:", {
          fileId: task.id,
          contentLength: content.length,
          settings: this.textSplitter.getSettings()
        });
        throw new Error("No chunks created from file content");
      }
      this.notifyProgress(task.id, 40, "Generating embeddings");
      for (let i = 0; i < chunks.length; i++) {
        const response = await this.openAIService.createEmbeddings([chunks[i].content]);
        if (response.length > 0 && response[0].data.length > 0) {
          chunks[i].embedding = response[0].data[0].embedding;
          chunks[i].vectorized_at = new Date().toISOString();
          console.log(`Generated embedding for chunk ${i + 1}/${chunks.length}`);
        } else {
          throw new Error(`Failed to generate embedding for chunk ${i + 1}`);
        }
        this.notifyProgress(
          task.id,
          40 + Math.floor(i / chunks.length * 30),
          `Processed ${i + 1} of ${chunks.length} chunks`
        );
      }
      const enhancedChunks = chunks.map((chunk) => ({
        ...chunk,
        metadata: {
          ...chunk.metadata,
          // Ensure all metadata fields are present
          aliases: chunk.metadata.aliases || [],
          links: chunk.metadata.links || [],
          tags: chunk.metadata.tags || []
        }
      }));
      this.notifyProgress(task.id, 70, "Saving to database");
      await this.supabaseService.upsertChunks(enhancedChunks);
      console.log("Chunks saved to database:", {
        numberOfChunks: enhancedChunks.length,
        fileId: task.id
      });
      this.notifyProgress(task.id, 100, "Processing completed");
    } catch (error) {
      console.error("Error in processCreateUpdateTask:", {
        error,
        taskId: task.id,
        metadata: task.metadata
      });
      throw error;
    }
  }
  async processDeleteTask(task) {
    if (!this.supabaseService) {
      throw new Error("Supabase service not initialized");
    }
    try {
      this.notifyProgress(task.id, 50, "Deleting from database");
      await this.supabaseService.deleteDocumentChunks(task.metadata.obsidianId);
      this.notifyProgress(task.id, 100, "Delete completed");
    } catch (error) {
      console.error("Error in processDeleteTask:", {
        error,
        taskId: task.id,
        metadata: task.metadata
      });
      throw error;
    }
  }
  async handleTaskError(task, error) {
    task.retryCount = (task.retryCount || 0) + 1;
    task.updatedAt = Date.now();
    if (task.retryCount < this.maxRetries) {
      task.status = "RETRYING" /* RETRYING */;
      this.queue.unshift(task);
      this.notifyProgress(task.id, 0, `Retry attempt ${task.retryCount}`);
      console.log("Task queued for retry:", {
        taskId: task.id,
        retryCount: task.retryCount,
        maxRetries: this.maxRetries
      });
    } else {
      task.status = "FAILED" /* FAILED */;
      task.error = {
        message: error.message,
        code: error.code || "UNKNOWN_ERROR",
        stack: error.stack
      };
      task.completedAt = Date.now();
      console.error("Task failed after max retries:", {
        taskId: task.id,
        error: task.error
      });
    }
    this.errorHandler.handleError(error, {
      context: "QueueService.processTask",
      taskId: task.id,
      taskType: task.type
    });
  }
  removeFromProcessingQueue(task) {
    const index2 = this.processingQueue.findIndex((t) => t.id === task.id);
    if (index2 !== -1) {
      this.processingQueue.splice(index2, 1);
    }
  }
  notifyProgress(taskId, progress, message) {
    this.notificationManager.updateProgress({
      taskId,
      progress,
      currentStep: message,
      totalSteps: 1,
      currentStepNumber: 1
    });
  }
  getQueueStats() {
    const now = Date.now();
    const oneHour = 60 * 60 * 1e3;
    const tasksByStatus = this.queue.reduce((acc, task) => {
      acc[task.status] = (acc[task.status] || 0) + 1;
      return acc;
    }, {});
    const tasksByType = this.queue.reduce((acc, task) => {
      acc[task.type] = (acc[task.type] || 0) + 1;
      return acc;
    }, {});
    const completedTasks = this.queue.filter(
      (task) => task.status === "COMPLETED" /* COMPLETED */ && task.completedAt
    );
    const averageTime = completedTasks.length > 0 ? completedTasks.reduce((sum, task) => sum + (task.completedAt - task.startedAt), 0) / completedTasks.length : 0;
    const tasksLastHour = completedTasks.filter(
      (task) => task.completedAt > now - oneHour
    ).length;
    return {
      totalTasks: this.queue.length,
      tasksByStatus,
      tasksByType,
      averageProcessingTime: averageTime,
      failedTasks: tasksByStatus["FAILED" /* FAILED */] || 0,
      retryingTasks: tasksByStatus["RETRYING" /* RETRYING */] || 0,
      tasksLastHour
    };
  }
  clear() {
    this.queue = [];
    this.processingQueue = [];
    this.notificationManager.clear();
  }
  updateSettings(settings) {
    this.maxConcurrent = settings.maxConcurrent;
    this.maxRetries = settings.maxRetries;
    if (settings.chunkSettings) {
      this.textSplitter = new TextSplitter(settings.chunkSettings);
    }
  }
};

// utils/FileTracker.ts
var import_obsidian6 = require("obsidian");

// services/SyncFileManager.ts
var import_obsidian5 = require("obsidian");
var SyncFileManager = class {
  constructor(vault, errorHandler, syncFilePath = "_mindmatrixsync.md", backupInterval = 36e5) {
    this.vault = vault;
    this.errorHandler = errorHandler;
    this.lastBackup = 0;
    this.syncFile = null;
    this.syncFilePath = syncFilePath;
    this.backupPath = `${syncFilePath}.backup`;
    this.backupInterval = backupInterval;
  }
  /**
   * Initialize or validate the sync file
   */
  async initialize() {
    try {
      const existingFile = this.vault.getAbstractFileByPath(this.syncFilePath);
      if (existingFile instanceof import_obsidian5.TFile) {
        this.syncFile = existingFile;
        const isValid = await this.validateSyncFile();
        if (!isValid) {
          await this.repairSyncFile();
        }
      } else {
        await this.createSyncFile();
      }
      await this.createBackup();
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.initialize",
        metadata: { syncFilePath: this.syncFilePath }
      });
      throw error;
    }
  }
  /**
   * Create a new sync file with initial structure
   */
  async createSyncFile() {
    console.log("Starting sync file creation with wait periods...");
    const initialContent = this.generateInitialContent();
    console.log("Waiting 20 seconds before creating sync file...");
    await new Promise((resolve) => setTimeout(resolve, 2e4));
    this.syncFile = await this.vault.create(this.syncFilePath, initialContent);
    console.log("Sync file created, starting stability wait period...");
    await new Promise((resolve) => setTimeout(resolve, 5e3));
    const fileExists = this.vault.getAbstractFileByPath(this.syncFilePath);
    if (!fileExists) {
      throw new Error("Sync file creation failed - file not found after wait period");
    }
    console.log("Sync file creation completed successfully");
  }
  /**
   * Generate initial content for sync file
   */
  generateInitialContent() {
    return `---
last_sync: ${Date.now()}
---

## Synced Files
| File Path | Last Modified | Last Synced | Hash | Status |
|-----------|--------------|-------------|------|--------|
`;
  }
  /**
   * Validate sync file structure and content
   */
  async validateSyncFile() {
    if (!this.syncFile)
      return false;
    try {
      const content = await this.vault.read(this.syncFile);
      const hasYamlFrontmatter = /^---\n[\s\S]*?\n---/.test(content);
      const hasTableHeader = content.includes("| File Path | Last Modified | Last Synced | Hash | Status |");
      const hasTableDelimiter = content.includes("|-----------|--------------|-------------|------|--------|");
      if (!hasYamlFrontmatter || !hasTableHeader || !hasTableDelimiter) {
        return false;
      }
      const entries = await this.parseSyncFile();
      for (const entry of entries) {
        if (!this.validateEntry(entry)) {
          return false;
        }
      }
      return true;
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.validateSyncFile",
        metadata: { syncFilePath: this.syncFilePath }
      });
      return false;
    }
  }
  /**
   * Validate a single sync entry
   */
  validateEntry(entry) {
    return typeof entry.filePath === "string" && typeof entry.lastModified === "number" && typeof entry.lastSynced === "number" && typeof entry.hash === "string" && ["OK", "PENDING", "ERROR"].includes(entry.status);
  }
  /**
   * Repair corrupted sync file
   */
  async repairSyncFile() {
    try {
      const restored = await this.restoreFromBackup();
      if (!restored) {
        await this.createSyncFile();
      }
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.repairSyncFile",
        metadata: { syncFilePath: this.syncFilePath }
      });
      throw error;
    }
  }
  /**
   * Parse sync file content
   */
  async parseSyncFile() {
    if (!this.syncFile) {
      throw new Error("SYNC_ERROR" /* SYNC_ERROR */);
    }
    const content = await this.vault.read(this.syncFile);
    const lines = content.split("\n");
    const entries = [];
    let tableStartIndex = -1;
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].includes("| File Path | Last Modified |")) {
        tableStartIndex = i + 2;
        break;
      }
    }
    if (tableStartIndex === -1) {
      throw new Error("Invalid sync file format");
    }
    for (let i = tableStartIndex; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line || line.startsWith("#"))
        continue;
      const parts = line.split("|").map((part) => part.trim());
      if (parts.length >= 6) {
        entries.push({
          filePath: parts[1],
          lastModified: parseInt(parts[2]),
          lastSynced: parseInt(parts[3]),
          hash: parts[4],
          status: parts[5]
        });
      }
    }
    return entries;
  }
  /**
   * Update sync status for a file
   */
  async updateSyncStatus(filePath, status, metadata) {
    try {
      if (!this.syncFile) {
        throw new Error("Sync file not initialized");
      }
      const entries = await this.parseSyncFile();
      const existingEntryIndex = entries.findIndex((e) => e.filePath === filePath);
      const newEntry = {
        filePath,
        lastModified: metadata.lastModified,
        lastSynced: Date.now(),
        hash: metadata.hash,
        status
      };
      if (existingEntryIndex >= 0) {
        entries[existingEntryIndex] = newEntry;
      } else {
        entries.push(newEntry);
      }
      await this.writeSyncFile(entries);
      if (Date.now() - this.lastBackup >= this.backupInterval) {
        await this.createBackup();
      }
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.updateSyncStatus",
        metadata: { filePath, status }
      });
      throw error;
    }
  }
  /**
   * Write entries to sync file
   */
  async writeSyncFile(entries) {
    if (!this.syncFile) {
      throw new Error("Sync file not initialized");
    }
    const header = `---
last_sync: ${Date.now()}
---

## Synced Files
| File Path | Last Modified | Last Synced | Hash | Status |
|-----------|--------------|-------------|------|--------|
`;
    const content = entries.map((entry) => `| ${entry.filePath} | ${entry.lastModified} | ${entry.lastSynced} | ${entry.hash} | ${entry.status} |`).join("\n");
    await this.vault.modify(this.syncFile, header + content);
  }
  /**
   * Create a backup of the sync file
   */
  async createBackup() {
    if (!this.syncFile)
      return;
    try {
      const content = await this.vault.read(this.syncFile);
      const backupFile = this.vault.getAbstractFileByPath(this.backupPath);
      if (backupFile instanceof import_obsidian5.TFile) {
        await this.vault.modify(backupFile, content);
      } else {
        await this.vault.create(this.backupPath, content);
      }
      this.lastBackup = Date.now();
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.createBackup"
      });
    }
  }
  /**
   * Restore sync file from backup
   */
  async restoreFromBackup() {
    const backupFile = this.vault.getAbstractFileByPath(this.backupPath);
    if (!(backupFile instanceof import_obsidian5.TFile)) {
      return false;
    }
    try {
      const content = await this.vault.read(backupFile);
      if (this.syncFile) {
        await this.vault.modify(this.syncFile, content);
      } else {
        this.syncFile = await this.vault.create(this.syncFilePath, content);
      }
      return true;
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.restoreFromBackup"
      });
      return false;
    }
  }
  /**
   * Get sync status for a file
   */
  async getSyncStatus(filePath) {
    try {
      const entries = await this.parseSyncFile();
      return entries.find((e) => e.filePath === filePath) || null;
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.getSyncStatus",
        metadata: { filePath }
      });
      return null;
    }
  }
  /**
   * Get all sync entries
   */
  async getAllSyncEntries() {
    try {
      return await this.parseSyncFile();
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.getAllSyncEntries"
      });
      return [];
    }
  }
  async validateSyncState() {
    try {
      if (!this.syncFile) {
        return {
          isValid: false,
          error: "Sync file not initialized"
        };
      }
      const content = await this.vault.read(this.syncFile);
      const hasYamlFrontmatter = /^---\n[\s\S]*?\n---/.test(content);
      const hasTableHeader = content.includes("| File Path | Last Modified | Last Synced | Hash | Status |");
      const hasTableDelimiter = content.includes("|-----------|--------------|-------------|------|--------|");
      if (!hasYamlFrontmatter || !hasTableHeader || !hasTableDelimiter) {
        return {
          isValid: false,
          error: "Invalid sync file structure"
        };
      }
      const entries = await this.parseSyncFile();
      for (const entry of entries) {
        if (!this.validateEntry(entry)) {
          return {
            isValid: false,
            error: "Invalid sync entry found"
          };
        }
      }
      return { isValid: true };
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.validateSyncState"
      });
      return {
        isValid: false,
        error: error.message
      };
    }
  }
  async attemptRecovery() {
    try {
      const restored = await this.restoreFromBackup();
      if (restored) {
        return true;
      }
      await this.createSyncFile();
      return true;
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.attemptRecovery"
      });
      return false;
    }
  }
  async updateLastSync() {
    try {
      if (!this.syncFile) {
        throw new Error("Sync file not initialized");
      }
      const content = await this.vault.read(this.syncFile);
      const updatedContent = content.replace(
        /^---\nlast_sync: \d+/m,
        `---
last_sync: ${Date.now()}`
      );
      await this.vault.modify(this.syncFile, updatedContent);
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.updateLastSync"
      });
      throw error;
    }
  }
};

// utils/FileTracker.ts
var FileTracker = class {
  constructor(vault, errorHandler, syncFilePath = "_mindmatrixsync.md") {
    this.vault = vault;
    this.errorHandler = errorHandler;
    this.fileCache = /* @__PURE__ */ new Map();
    this.eventQueue = [];
    this.isProcessing = false;
    this.processingTimeout = 1e3;
    this.syncManager = new SyncFileManager(vault, errorHandler, syncFilePath);
  }
  /**
   * Initialize the file tracker and sync manager
   */
  async initialize() {
    try {
      await this.syncManager.initialize();
      const syncEntries = await this.syncManager.getAllSyncEntries();
      for (const entry of syncEntries) {
        if (this.shouldTrackFile(entry.filePath)) {
          this.fileCache.set(entry.filePath, {
            path: entry.filePath,
            hash: entry.hash,
            lastModified: entry.lastModified,
            lastSynced: entry.lastSynced
          });
        }
      }
      const files = this.vault.getFiles();
      for (const file of files) {
        try {
          if (!this.shouldTrackFile(file.path)) {
            continue;
          }
          const hash = await this.calculateFileHash(file);
          const existing = this.fileCache.get(file.path);
          if (!existing || existing.hash !== hash) {
            this.fileCache.set(file.path, {
              path: file.path,
              hash,
              lastModified: file.stat.mtime
            });
            await this.syncManager.updateSyncStatus(file.path, "PENDING", {
              lastModified: file.stat.mtime,
              hash
            });
          }
        } catch (error) {
          this.errorHandler.handleError(error, {
            context: "FileTracker.initialize",
            metadata: { filePath: file.path }
          });
        }
      }
      const allPaths = new Set(files.map((f) => f.path));
      for (const [path, cache] of this.fileCache.entries()) {
        if (!allPaths.has(path)) {
          this.fileCache.delete(path);
        }
      }
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "FileTracker.initialize"
      });
      throw error;
    }
  }
  /**
   * Handle file creation events
   */
  async handleCreate(file) {
    if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path)) {
      return;
    }
    const event = {
      type: "create",
      file,
      timestamp: Date.now()
    };
    await this.queueEvent(event);
  }
  /**
   * Handle file modification events
   */
  async handleModify(file) {
    if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path)) {
      return;
    }
    const event = {
      type: "modify",
      file,
      timestamp: Date.now()
    };
    await this.queueEvent(event);
  }
  /**
   * Handle file deletion events
   */
  async handleDelete(file) {
    if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path)) {
      return;
    }
    const event = {
      type: "delete",
      file,
      timestamp: Date.now()
    };
    await this.queueEvent(event);
    this.fileCache.delete(file.path);
    await this.syncManager.updateSyncStatus(file.path, "OK", {
      lastModified: Date.now(),
      hash: ""
      // Empty hash indicates deletion
    });
  }
  /**
   * Handle file rename events
   */
  async handleRename(file, oldPath) {
    if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path)) {
      return;
    }
    const event = {
      type: "rename",
      file,
      oldPath,
      timestamp: Date.now()
    };
    await this.queueEvent(event);
    if (this.fileCache.has(oldPath)) {
      const cache = this.fileCache.get(oldPath);
      if (cache) {
        this.fileCache.delete(oldPath);
        const newHash = await this.calculateFileHash(file);
        this.fileCache.set(file.path, {
          ...cache,
          path: file.path,
          hash: newHash,
          lastModified: file.stat.mtime
        });
        await this.syncManager.updateSyncStatus(oldPath, "OK", {
          lastModified: Date.now(),
          hash: ""
          // Empty hash indicates deletion/move
        });
        await this.syncManager.updateSyncStatus(file.path, "PENDING", {
          lastModified: file.stat.mtime,
          hash: newHash
        });
      }
    }
  }
  shouldTrackFile(filePath) {
    if (filePath === this.syncFilePath || filePath.endsWith("_mindmatrixsync.md") || filePath.endsWith("_mindmatrixsync.md.backup")) {
      return false;
    }
    return true;
  }
  /**
   * Queue an event for processing
   */
  async queueEvent(event) {
    this.eventQueue.push(event);
    if (!this.isProcessing) {
      setTimeout(() => this.processEventQueue(), this.processingTimeout);
    }
  }
  /**
   * Process queued events with debouncing
   */
  async processEventQueue() {
    var _a2;
    if (this.isProcessing || this.eventQueue.length === 0)
      return;
    this.isProcessing = true;
    try {
      const eventsByPath = /* @__PURE__ */ new Map();
      for (const event of this.eventQueue) {
        const path = event.file.path;
        if (!eventsByPath.has(path)) {
          eventsByPath.set(path, []);
        }
        (_a2 = eventsByPath.get(path)) == null ? void 0 : _a2.push(event);
      }
      for (const [path, events] of eventsByPath) {
        await this.processFileEvents(path, events);
      }
      this.eventQueue = [];
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "FileTracker.processEventQueue"
      });
    } finally {
      this.isProcessing = false;
    }
  }
  /**
   * Process all events for a single file
   */
  async processFileEvents(path, events) {
    events.sort((a, b) => a.timestamp - b.timestamp);
    const finalEvent = events[events.length - 1];
    try {
      if (finalEvent.type !== "delete") {
        const newHash = await this.calculateFileHash(finalEvent.file);
        const existingCache = this.fileCache.get(path);
        if (existingCache && existingCache.hash === newHash) {
          return;
        }
        this.fileCache.set(path, {
          path,
          hash: newHash,
          lastModified: finalEvent.file.stat.mtime
        });
        await this.syncManager.updateSyncStatus(path, "PENDING", {
          lastModified: finalEvent.file.stat.mtime,
          hash: newHash
        });
      }
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "FileTracker.processFileEvents",
        metadata: { path, eventType: finalEvent.type }
      });
    }
  }
  /**
   * Calculate a hash of file contents
   */
  async calculateFileHash(file) {
    try {
      const content = await this.vault.read(file);
      return await this.hashString(content);
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "FileTracker.calculateFileHash",
        metadata: { filePath: file.path }
      });
      return "";
    }
  }
  /**
   * Create a hash from a string
   */
  async hashString(str2) {
    const encoder = new TextEncoder();
    const data = encoder.encode(str2);
    const buffer = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(buffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  /**
   * Create metadata for a file
   */
  async createFileMetadata(file) {
    try {
      const content = await this.vault.read(file);
      const lineCount = content.split("\n").length;
      return {
        obsidianId: file.path,
        path: file.path,
        lastModified: file.stat.mtime,
        created: file.stat.ctime,
        size: file.stat.size,
        customMetadata: {},
        // Add n8n compatible metadata
        loc: {
          lines: {
            from: 1,
            to: lineCount
          }
        },
        source: "obsidian",
        file_id: file.path,
        blobType: "text/markdown"
      };
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "FileTracker.createFileMetadata",
        metadata: { filePath: file.path }
      });
      return {
        obsidianId: file.path,
        path: file.path,
        lastModified: file.stat.mtime,
        created: file.stat.ctime,
        size: file.stat.size,
        customMetadata: {}
      };
    }
  }
  /**
   * Clear file cache and queue
   */
  clearCache() {
    this.fileCache.clear();
    this.eventQueue = [];
  }
  /**
   * Update processing timeout
   */
  setProcessingTimeout(timeout) {
    this.processingTimeout = timeout;
  }
  /**
   * Get sync status for a file
   */
  async getSyncStatus(path) {
    return await this.syncManager.getSyncStatus(path);
  }
  /**
   * Get all sync statuses
   */
  async getAllSyncStatuses() {
    return await this.syncManager.getAllSyncEntries();
  }
};

// utils/ErrorHandler.ts
var import_obsidian7 = require("obsidian");
var ErrorHandler = class {
  constructor(settings, vaultPath) {
    this.errorLogs = [];
    this.maxLogs = 100;
    this.settings = settings;
    if (settings.logToFile && vaultPath) {
      this.logFilePath = `${vaultPath}/.obsidian/mind-matrix.log`;
    }
  }
  /**
   * Handles errors with context and optional recovery
   */
  handleError(error, context, level = "error") {
    if (!this.shouldLog(level)) {
      return;
    }
    const errorLog = {
      timestamp: Date.now(),
      error: this.normalizeError(error),
      context,
      level,
      handled: false
    };
    this.errorLogs.unshift(errorLog);
    if (this.errorLogs.length > this.maxLogs) {
      this.errorLogs.pop();
    }
    if (level === "error" || level === "warn" && this.settings.logLevel === "debug") {
      this.showErrorNotification(error);
    }
    if (this.settings.enableDebugLogs) {
      console.group(`[${level.toUpperCase()}] ${context.context}`);
      console.error("Error details:", error);
      console.error("Context:", context);
      if (error.stack) {
        console.error("Stack trace:", error.stack);
      }
      console.groupEnd();
    }
    if (this.settings.logToFile && this.logFilePath) {
      this.writeToLogFile(errorLog);
    }
  }
  /**
   * Checks if the error level should be logged
   */
  shouldLog(level) {
    const levels = {
      "error": 0,
      "warn": 1,
      "info": 2,
      "debug": 3
    };
    return levels[level] <= levels[this.settings.logLevel];
  }
  /**
   * Normalizes different error formats
   */
  normalizeError(error) {
    if (error instanceof Error) {
      return error;
    }
    if (this.isSupabaseError(error)) {
      return new Error(`Database error (${error.code}): ${error.message}${error.hint ? ` - ${error.hint}` : ""}`);
    }
    if (typeof error === "string") {
      return new Error(error);
    }
    if (typeof error === "object") {
      const message = error.message || "Unknown error";
      const normalizedError = new Error(message);
      Object.assign(normalizedError, error);
      return normalizedError;
    }
    return new Error("Unknown error occurred");
  }
  /**
   * Type guard for Supabase errors
   */
  isSupabaseError(error) {
    return error && typeof error === "object" && "code" in error && "details" in error;
  }
  /**
   * Shows appropriate notification based on error type
   */
  showErrorNotification(error) {
    let message = "An error occurred";
    let duration = 4e3;
    if (this.isSupabaseError(error)) {
      switch (error.code) {
        case "42P01":
          message = "Database table not found. Please run setup SQL.";
          break;
        case "42501":
          message = "Insufficient database permissions.";
          break;
        case "23505":
          message = "Duplicate entry found.";
          break;
        default:
          message = `Database error: ${error.message}`;
      }
      duration = 6e3;
    } else if (error.type === "CHUNKING_ERROR" /* CHUNKING_ERROR */) {
      message = "Error splitting document into chunks";
    } else if (error.type === "EMBEDDING_ERROR" /* EMBEDDING_ERROR */) {
      message = "Error generating embeddings";
    } else if (error.type === "DATABASE_ERROR" /* DATABASE_ERROR */) {
      message = "Database operation failed";
    } else if (error.type === "INVALID_METADATA" /* INVALID_METADATA */) {
      message = "Invalid document metadata";
    } else if (error.type === "FILE_ACCESS_ERROR" /* FILE_ACCESS_ERROR */) {
      message = "Error accessing file";
    } else if (error.type === "YAML_PARSE_ERROR" /* YAML_PARSE_ERROR */) {
      message = "Error parsing YAML front matter";
    } else if (error.type === "VECTOR_EXTENSION_ERROR" /* VECTOR_EXTENSION_ERROR */) {
      message = "Vector extension not available";
    } else if (error.type === "SYNC_ERROR" /* SYNC_ERROR */) {
      message = "Sync operation failed";
    } else if (error.type === "QUEUE_FULL" /* QUEUE_FULL */) {
      message = "Task queue is full";
    } else if (error.type === "TASK_TIMEOUT" /* TASK_TIMEOUT */) {
      message = "Task timed out";
    } else if (error.type === "TASK_CANCELLED" /* TASK_CANCELLED */) {
      message = "Task was cancelled";
    } else if (error.type === "MAX_RETRIES_EXCEEDED" /* MAX_RETRIES_EXCEEDED */) {
      message = "Maximum retry attempts exceeded";
    } else if (error.type === "INVALID_TASK_STATE" /* INVALID_TASK_STATE */) {
      message = "Invalid task state";
    } else if (error.type === "TASK_NOT_FOUND" /* TASK_NOT_FOUND */) {
      message = "Task not found";
    }
    if (error.message) {
      message = `${message}: ${error.message}`;
    }
    new import_obsidian7.Notice(message, duration);
  }
  /**
   * Writes error log to file
   */
  writeToLogFile(log) {
    var _a2, _b, _c;
    if (!this.logFilePath)
      return;
    const logEntry = {
      timestamp: new Date(log.timestamp).toISOString(),
      level: log.level.toUpperCase(),
      context: log.context.context,
      error: log.error.message,
      stack: log.error.stack,
      metadata: log.context.metadata
    };
    try {
      if ((_c = (_b = (_a2 = this.app) == null ? void 0 : _a2.vault) == null ? void 0 : _b.adapter) == null ? void 0 : _c.append) {
        this.app.vault.adapter.append(
          this.logFilePath,
          JSON.stringify(logEntry) + "\n"
        );
      }
    } catch (error) {
      console.error("Failed to write to log file:", error);
    }
  }
  /**
   * Updates debug settings
   */
  updateSettings(settings) {
    this.settings = settings;
  }
  /**
   * Gets recent error logs
   */
  getRecentLogs(count = 10) {
    return this.errorLogs.slice(0, count);
  }
  /**
   * Clears error logs
   */
  clearLogs() {
    this.errorLogs = [];
  }
  /**
   * Gets error statistics
   */
  getErrorStats() {
    return this.errorLogs.reduce((acc, log) => {
      const errorType = log.error.name || "Unknown";
      acc[errorType] = (acc[errorType] || 0) + 1;
      return acc;
    }, {});
  }
};

// utils/NotificationManager.ts
var import_obsidian8 = require("obsidian");
var NotificationManager = class {
  constructor(statusBarEl, enableNotifications, enableProgressBar) {
    this.progressBars = /* @__PURE__ */ new Map();
    this.notificationQueue = [];
    this.isProcessingQueue = false;
    this.statusBarItem = statusBarEl;
    this.enableNotifications = enableNotifications;
    this.enableProgressBar = enableProgressBar;
    this.initializeStatusBar();
  }
  /**
   * Shows a notification message
   */
  showNotification(message, duration = 4e3) {
    if (!this.enableNotifications)
      return;
    this.notificationQueue.push(message);
    if (!this.isProcessingQueue) {
      this.processNotificationQueue();
    }
  }
  /**
   * Updates progress for a task
   */
  updateProgress(progress) {
    if (!this.enableProgressBar)
      return;
    const progressBarId = `progress-${progress.taskId}`;
    const progressPercentage = Math.round(progress.progress);
    this.updateProgressBar(progressBarId, {
      progress: progressPercentage,
      message: this.formatProgressMessage(progress),
      total: progress.totalSteps,
      current: progress.currentStepNumber
    });
    if (progress.details) {
      const details = this.formatProgressDetails(progress.details);
      if (details) {
        this.showNotification(details, 2e3);
      }
    }
    if (progressPercentage >= 100) {
      setTimeout(() => {
        this.removeProgressBar(progressBarId);
      }, 2e3);
    }
  }
  /**
   * Initializes the status bar
   */
  initializeStatusBar() {
    const container = document.createElement("div");
    container.addClass("mind-matrix-status");
    this.statusBarItem.appendChild(container);
  }
  /**
   * Updates or creates a progress bar
   */
  updateProgressBar(id, options) {
    let progressBar = this.progressBars.get(id);
    if (!progressBar) {
      progressBar = this.createProgressBar(id);
      this.progressBars.set(id, progressBar);
    }
    progressBar.fill.style.width = `${options.progress}%`;
    progressBar.text.textContent = this.formatProgressMessage({
      taskId: id,
      progress: options.progress,
      currentStep: options.message,
      totalSteps: options.total,
      currentStepNumber: options.current
    });
    progressBar.lastUpdate = Date.now();
  }
  /**
   * Creates a new progress bar
   */
  createProgressBar(id) {
    const container = document.createElement("div");
    container.addClass("progress-container");
    container.setAttribute("data-id", id);
    const bar = document.createElement("div");
    bar.addClass("progress-bar");
    const fill = document.createElement("div");
    fill.addClass("progress-fill");
    const text = document.createElement("div");
    text.addClass("progress-text");
    bar.appendChild(fill);
    container.appendChild(bar);
    container.appendChild(text);
    this.statusBarItem.appendChild(container);
    return {
      container,
      fill,
      text,
      lastUpdate: Date.now()
    };
  }
  /**
   * Removes a progress bar
   */
  removeProgressBar(id) {
    const progressBar = this.progressBars.get(id);
    if (progressBar) {
      progressBar.container.remove();
      this.progressBars.delete(id);
    }
  }
  /**
   * Formats progress message
   */
  formatProgressMessage(progress) {
    return `${progress.currentStep} (${progress.currentStepNumber}/${progress.totalSteps})`;
  }
  /**
   * Formats progress details
   */
  formatProgressDetails(details) {
    if (!details)
      return null;
    const parts = [];
    if (details.processedChunks !== void 0) {
      parts.push(`Chunks: ${details.processedChunks}/${details.totalChunks}`);
    }
    if (details.processedTokens !== void 0) {
      parts.push(`Tokens: ${details.processedTokens}/${details.totalTokens}`);
    }
    return parts.join(" | ");
  }
  /**
   * Processes notification queue
   */
  async processNotificationQueue() {
    if (this.isProcessingQueue || this.notificationQueue.length === 0)
      return;
    this.isProcessingQueue = true;
    try {
      while (this.notificationQueue.length > 0) {
        const message = this.notificationQueue.shift();
        if (message) {
          new import_obsidian8.Notice(message);
          await new Promise((resolve) => setTimeout(resolve, 500));
        }
      }
    } finally {
      this.isProcessingQueue = false;
    }
  }
  /**
   * Updates notification settings
   */
  updateSettings(enableNotifications, enableProgressBar) {
    this.enableNotifications = enableNotifications;
    this.enableProgressBar = enableProgressBar;
    if (!enableProgressBar) {
      for (const [id] of this.progressBars) {
        this.removeProgressBar(id);
      }
    }
  }
  /**
   * Clears all progress bars
   */
  clear() {
    for (const [id] of this.progressBars) {
      this.removeProgressBar(id);
    }
    this.notificationQueue = [];
  }
};

// settings/SettingsTab.ts
var import_obsidian9 = require("obsidian");
var MindMatrixSettingsTab = class extends import_obsidian9.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.settings = plugin.settings;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Vault Identification" });
    if (isVaultInitialized(this.settings)) {
      new import_obsidian9.Setting(containerEl).setName("Vault ID").setDesc("Unique identifier used to track this vault in the database. This ensures your notes are correctly synchronized.").addText(
        (text) => text.setValue(this.settings.vaultId).setDisabled(true)
      );
      new import_obsidian9.Setting(containerEl).setName("Vault Name").setDesc("The current name of your Obsidian vault (displayed for reference).").addText(
        (text) => text.setValue(this.settings.lastKnownVaultName).setDisabled(true)
      );
      new import_obsidian9.Setting(containerEl).setName("Reset Vault ID").setDesc("Generates a new vault ID. Warning: This will disconnect the vault from its existing database entries and require a full resync.").addButton((btn) => btn.setButtonText("Reset").setWarning().onClick(async () => {
        const confirmed = await this.showResetConfirmation();
        if (confirmed) {
          this.settings.vaultId = generateVaultId();
          this.settings.lastKnownVaultName = this.app.vault.getName();
          await this.plugin.saveSettings();
          new import_obsidian9.Notice("Vault ID has been reset.");
          this.display();
        }
      }));
    } else {
      new import_obsidian9.Setting(containerEl).setName("Initialize Vault").setDesc("Generate a unique identifier for this vault to begin syncing with the database.").addButton((btn) => btn.setButtonText("Initialize").onClick(async () => {
        this.settings.vaultId = generateVaultId();
        this.settings.lastKnownVaultName = this.app.vault.getName();
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Vault has been initialized.");
        this.display();
      }));
    }
    containerEl.createEl("h2", { text: "Supabase Configuration" });
    new import_obsidian9.Setting(containerEl).setName("Supabase URL").setDesc("The URL for your Supabase project. Find this in your Supabase dashboard under Project Settings > API > Project URL. Should look like: https://xxx.supabase.co").addText((text) => text.setPlaceholder("https://your-project.supabase.co").setValue(this.settings.supabase.url).onChange(async (value) => {
      this.settings.supabase.url = value;
      await this.plugin.saveSettings();
      new import_obsidian9.Notice("Supabase URL updated.");
    }));
    new import_obsidian9.Setting(containerEl).setName("Supabase API Key").setDesc('Your Supabase project API key. Find this in Project Settings > API > Project API keys. Use the "service_role" key for full database access. Keep this key secure.').addText((text) => text.setPlaceholder("Enter your API key").setValue(this.settings.supabase.apiKey).onChange(async (value) => {
      this.settings.supabase.apiKey = value;
      await this.plugin.saveSettings();
      new import_obsidian9.Notice("Supabase API key updated.");
    }));
    containerEl.createEl("h2", { text: "OpenAI Configuration" });
    new import_obsidian9.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key for generating embeddings. Create one at https://platform.openai.com/api-keys. Estimated cost: ~$0.0001 per page. Keep this key secure.").addText((text) => text.setPlaceholder("Enter your API key").setValue(this.settings.openai.apiKey).onChange(async (value) => {
      this.settings.openai.apiKey = value;
      await this.plugin.saveSettings();
      new import_obsidian9.Notice("OpenAI API key updated.");
    }));
    containerEl.createEl("h2", { text: "Document Processing" });
    new import_obsidian9.Setting(containerEl).setName("Chunk Size").setDesc("Maximum size of text chunks in characters. Larger chunks provide more context but cost more tokens. Recommended: 1000-1500 characters for optimal semantic search results.").addText((text) => text.setValue(String(this.settings.chunking.chunkSize)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.settings.chunking.chunkSize = numValue;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Chunk size updated.");
      }
    }));
    new import_obsidian9.Setting(containerEl).setName("Chunk Overlap").setDesc("Number of characters to overlap between chunks. Helps maintain context across chunk boundaries. Recommended: 10-20% of chunk size (100-200 characters for default settings).").addText((text) => text.setValue(String(this.settings.chunking.chunkOverlap)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue >= 0) {
        this.settings.chunking.chunkOverlap = numValue;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Chunk overlap updated.");
      }
    }));
    containerEl.createEl("h2", { text: "Exclusions" });
    new import_obsidian9.Setting(containerEl).setName("Excluded Folders").setDesc("Folders to exclude from syncing. Common examples: .git, .obsidian, node_modules, attachments. Separate multiple folders with commas.").addText((text) => text.setValue(this.settings.exclusions.excludedFolders.join(", ")).onChange(async (value) => {
      this.settings.exclusions.excludedFolders = value.split(",").map((s) => s.trim()).filter((s) => s);
      await this.plugin.saveSettings();
      new import_obsidian9.Notice("Excluded folders updated.");
    }));
    new import_obsidian9.Setting(containerEl).setName("Excluded File Types").setDesc("File extensions to exclude from syncing (e.g., .mp3, .jpg, .png). Include the dot prefix. Only markdown files are recommended for embedding.").addText((text) => text.setValue(this.settings.exclusions.excludedFileTypes.join(", ")).onChange(async (value) => {
      this.settings.exclusions.excludedFileTypes = value.split(",").map((s) => s.trim()).filter((s) => s);
      await this.plugin.saveSettings();
      new import_obsidian9.Notice("Excluded file types updated.");
    }));
    containerEl.createEl("h2", { text: "Processing Queue" });
    new import_obsidian9.Setting(containerEl).setName("Concurrent Tasks").setDesc("Maximum number of tasks to process simultaneously. Higher values may improve speed but increase API usage. Default: 3").addText((text) => text.setValue(String(this.settings.queue.maxConcurrent)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.settings.queue.maxConcurrent = numValue;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Concurrent tasks limit updated.");
      }
    }));
    new import_obsidian9.Setting(containerEl).setName("Retry Attempts").setDesc("Number of times to retry failed operations before giving up. Helps handle temporary API or network issues. Default: 3").addText((text) => text.setValue(String(this.settings.queue.retryAttempts)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue >= 0) {
        this.settings.queue.retryAttempts = numValue;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Retry attempts updated.");
      }
    }));
    containerEl.createEl("h2", { text: "Features" });
    new import_obsidian9.Setting(containerEl).setName("Auto Sync").setDesc("Automatically sync changes to the database when files are created, modified, or deleted. Disable this if you prefer to manually control when files are synced.").addToggle((toggle) => toggle.setValue(this.settings.enableAutoSync).onChange(async (value) => {
      this.settings.enableAutoSync = value;
      await this.plugin.saveSettings();
      new import_obsidian9.Notice("Auto sync updated.");
    }));
    new import_obsidian9.Setting(containerEl).setName("Show Notifications").setDesc("Display notifications for sync events, errors, and important updates. Helps track the status of background operations.").addToggle((toggle) => toggle.setValue(this.settings.enableNotifications).onChange(async (value) => {
      this.settings.enableNotifications = value;
      await this.plugin.saveSettings();
      new import_obsidian9.Notice("Notification settings updated.");
    }));
    new import_obsidian9.Setting(containerEl).setName("Show Progress Bar").setDesc("Display a progress bar in the status bar during sync operations. Useful for monitoring long-running tasks and large vault synchronizations.").addToggle((toggle) => toggle.setValue(this.settings.enableProgressBar).onChange(async (value) => {
      this.settings.enableProgressBar = value;
      await this.plugin.saveSettings();
      new import_obsidian9.Notice("Progress bar setting updated.");
    }));
    new import_obsidian9.Setting(containerEl).setName("Test Database Connection").setDesc("Click to test the connection to the Supabase database.").addButton((btn) => btn.setButtonText("Test Connection").onClick(async () => {
      if (this.plugin.supabaseService) {
        const isConnected = await this.plugin.supabaseService.testConnection();
        new import_obsidian9.Notice(isConnected ? "Database connection successful!" : "Database connection failed.");
      } else {
        new import_obsidian9.Notice("Supabase service not initialized.");
      }
    }));
    new import_obsidian9.Setting(containerEl).setName("Excluded Files").setDesc("Specific files to exclude from syncing (e.g., _mindmatrixsync.md). Separate multiple files with commas.").addText((text) => text.setValue(this.settings.exclusions.excludedFiles.join(", ")).onChange(async (value) => {
      this.settings.exclusions.excludedFiles = value.split(",").map((s) => s.trim()).filter((s) => s);
      await this.plugin.saveSettings();
      new import_obsidian9.Notice("Excluded files updated.");
    }));
    if (this.settings.debug.enableDebugLogs) {
      containerEl.createEl("h2", { text: "Debug Settings" });
      new import_obsidian9.Setting(containerEl).setName("Log Level").setDesc("Level of detail for debug logging. Higher levels include more information.").addDropdown((dropdown) => dropdown.addOption("error", "Error").addOption("warn", "Warning").addOption("info", "Info").addOption("debug", "Debug").setValue(this.settings.debug.logLevel).onChange(async (value) => {
        this.settings.debug.logLevel = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Log level updated.");
      }));
      new import_obsidian9.Setting(containerEl).setName("Log to File").setDesc("Save debug logs to a file in your .obsidian folder.").addToggle((toggle) => toggle.setValue(this.settings.debug.logToFile).onChange(async (value) => {
        this.settings.debug.logToFile = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Log to file setting updated.");
      }));
    }
  }
  async showResetConfirmation() {
    return new Promise((resolve) => {
      const modal = this.app.modal;
      modal.open((modal2) => {
        modal2.titleEl.setText("Reset Vault ID");
        modal2.contentEl.setText(
          "Warning: Resetting the vault ID will disconnect this vault from its existing database entries. This operation cannot be undone. Are you sure you want to continue?"
        );
        modal2.addButton((btn) => {
          btn.setButtonText("Cancel").onClick(() => {
            resolve(false);
            modal2.close();
          });
        });
        modal2.addButton((btn) => {
          btn.setButtonText("Reset").setWarning().onClick(() => {
            resolve(true);
            modal2.close();
          });
        });
      });
    });
  }
};

// services/InitialSyncManager.ts
var import_obsidian10 = require("obsidian");
var InitialSyncManager = class {
  constructor(vault, queueService, syncFileManager, metadataExtractor, errorHandler, notificationManager, options = {}) {
    this.vault = vault;
    this.queueService = queueService;
    this.syncFileManager = syncFileManager;
    this.metadataExtractor = metadataExtractor;
    this.errorHandler = errorHandler;
    this.notificationManager = notificationManager;
    this.batches = /* @__PURE__ */ new Map();
    this.isRunning = false;
    this.processingTimeout = null;
    this.options = {
      batchSize: 50,
      maxConcurrentBatches: 3,
      enableAutoInitialSync: true,
      priorityRules: [],
      ...options
    };
    this.progress = {
      totalFiles: 0,
      processedFiles: 0,
      currentBatch: 0,
      totalBatches: 0,
      startTime: 0
    };
  }
  /**
   * Start the initial sync process
   */
  async startSync() {
    if (this.isRunning) {
      console.log("Initial sync already running");
      return;
    }
    try {
      this.isRunning = true;
      this.progress.startTime = Date.now();
      const files = this.vault.getMarkdownFiles();
      this.progress.totalFiles = files.length;
      const sortedFiles = await this.sortFilesByPriority(files);
      const batches = this.createBatches(sortedFiles);
      this.progress.totalBatches = batches.length;
      batches.forEach((batch, index2) => {
        this.batches.set(batch.id, {
          ...batch,
          status: "pending",
          progress: 0
        });
      });
      await this.processBatches();
      new import_obsidian10.Notice("Initial sync completed successfully");
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "InitialSyncManager.startSync"
      });
      new import_obsidian10.Notice("Initial sync failed. Check console for details.");
    } finally {
      this.isRunning = false;
    }
  }
  /**
   * Sort files by priority based on rules
   */
  async sortFilesByPriority(files) {
    return files.sort((a, b) => {
      const priorityA = this.getFilePriority(a.path);
      const priorityB = this.getFilePriority(b.path);
      return priorityB - priorityA;
    });
  }
  /**
   * Get priority for a file based on rules
   */
  getFilePriority(path) {
    for (const rule of this.options.priorityRules) {
      if (path.includes(rule.pattern)) {
        return rule.priority;
      }
    }
    return 1;
  }
  /**
   * Create batches of files for processing
   */
  createBatches(files) {
    const batches = [];
    for (let i = 0; i < files.length; i += this.options.batchSize) {
      const batchFiles = files.slice(i, i + this.options.batchSize);
      batches.push({
        id: `batch-${Math.floor(i / this.options.batchSize)}`,
        files: batchFiles,
        status: "pending",
        progress: 0
      });
    }
    return batches;
  }
  /**
   * Process batches of files
   */
  async processBatches() {
    const activeBatches = /* @__PURE__ */ new Set();
    while (this.hasUnprocessedBatches() && this.isRunning) {
      if (activeBatches.size < this.options.maxConcurrentBatches) {
        const nextBatch = this.getNextPendingBatch();
        if (nextBatch) {
          activeBatches.add(nextBatch.id);
          this.processBatch(nextBatch).then(() => {
            activeBatches.delete(nextBatch.id);
          }).catch((error) => {
            this.errorHandler.handleError(error, {
              context: "InitialSyncManager.processBatch",
              metadata: { batchId: nextBatch.id }
            });
            activeBatches.delete(nextBatch.id);
          });
        }
      }
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }
  /**
   * Process a single batch of files
   */
  async processBatch(batch) {
    try {
      batch.status = "processing";
      batch.startTime = Date.now();
      for (const file of batch.files) {
        try {
          await this.processFile(file);
          this.progress.processedFiles++;
          batch.progress = this.progress.processedFiles / this.progress.totalFiles * 100;
          this.updateProgressNotification();
        } catch (error) {
          this.errorHandler.handleError(error, {
            context: "InitialSyncManager.processFile",
            metadata: { filePath: file.path }
          });
        }
      }
      batch.status = "completed";
      batch.endTime = Date.now();
    } catch (error) {
      batch.status = "failed";
      throw error;
    }
  }
  /**
   * Process a single file
   */
  // In InitialSyncManager.ts, modify the processFile method:
  async processFile(file) {
    try {
      const metadata = await this.metadataExtractor.extractMetadata(file);
      await this.updateFrontmatter(file, metadata);
      const fileHash = await this.calculateFileHash(file);
      await this.syncFileManager.updateSyncStatus(file.path, "PENDING", {
        lastModified: file.stat.mtime,
        hash: fileHash
      });
      await new Promise((resolve, reject) => {
        this.queueService.addTask({
          id: file.path,
          type: "CREATE",
          priority: this.getFilePriority(file.path),
          maxRetries: 3,
          retryCount: 0,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          status: "PENDING",
          metadata,
          data: {}
        }).then(async () => {
          await this.syncFileManager.updateSyncStatus(file.path, "OK", {
            lastModified: file.stat.mtime,
            hash: fileHash
          });
          resolve();
        }).catch(reject);
      });
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "InitialSyncManager.processFile",
        metadata: { filePath: file.path }
      });
      throw error;
    }
  }
  /**
   * Calculate file hash
   */
  async calculateFileHash(file) {
    const content = await this.vault.read(file);
    const encoder = new TextEncoder();
    const data = encoder.encode(content);
    const buffer = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(buffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  /**
   * Update file frontmatter with sync information
   */
  async updateFrontmatter(file, metadata) {
    const content = await this.vault.read(file);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    const frontmatter = frontmatterMatch ? this.parseFrontmatter(frontmatterMatch[1]) : {};
    frontmatter.vectorized_last = new Date().toISOString();
    frontmatter.vectorized_version = "1.0";
    const newFrontmatter = Object.entries(frontmatter).map(([key, value]) => `${key}: ${JSON.stringify(value)}`).join("\n");
    const newContent = frontmatterMatch ? content.replace(/^---\n[\s\S]*?\n---/, `---
${newFrontmatter}
---`) : `---
${newFrontmatter}
---

${content}`;
    await this.vault.modify(file, newContent);
  }
  /**
   * Parse frontmatter YAML
   */
  parseFrontmatter(yaml) {
    try {
      const frontmatter = {};
      const lines = yaml.split("\n");
      for (const line of lines) {
        const [key, ...valueParts] = line.split(":");
        if (key && valueParts.length) {
          frontmatter[key.trim()] = valueParts.join(":").trim();
        }
      }
      return frontmatter;
    } catch (error) {
      console.warn("Error parsing frontmatter:", error);
      return {};
    }
  }
  /**
   * Update progress notification
   */
  updateProgressNotification() {
    const progress = this.calculateProgress();
    this.notificationManager.updateProgress({
      taskId: "initial-sync",
      progress: progress.percentage,
      currentStep: `Processing files (${this.progress.processedFiles}/${this.progress.totalFiles})`,
      totalSteps: this.progress.totalBatches,
      currentStepNumber: this.progress.currentBatch + 1,
      estimatedTimeRemaining: progress.estimatedTimeRemaining,
      details: {
        processedFiles: this.progress.processedFiles,
        totalFiles: this.progress.totalFiles
      }
    });
  }
  /**
   * Calculate current progress and estimated time remaining
   */
  calculateProgress() {
    const percentage = this.progress.processedFiles / this.progress.totalFiles * 100;
    const elapsed = Date.now() - this.progress.startTime;
    const filesPerMs = this.progress.processedFiles / elapsed;
    const remainingFiles = this.progress.totalFiles - this.progress.processedFiles;
    const estimatedTimeRemaining = filesPerMs > 0 ? remainingFiles / filesPerMs : 0;
    return {
      percentage,
      estimatedTimeRemaining
    };
  }
  /**
   * Check if there are unprocessed batches
   */
  hasUnprocessedBatches() {
    return Array.from(this.batches.values()).some(
      (batch) => batch.status === "pending" || batch.status === "processing"
    );
  }
  /**
   * Get next pending batch
   */
  getNextPendingBatch() {
    return Array.from(this.batches.values()).find(
      (batch) => batch.status === "pending"
    ) || null;
  }
  /**
   * Stop the sync process
   */
  stop() {
    this.isRunning = false;
    if (this.processingTimeout) {
      clearTimeout(this.processingTimeout);
      this.processingTimeout = null;
    }
  }
  /**
   * Get current sync progress
   */
  getProgress() {
    return { ...this.progress };
  }
  /**
   * Update sync options
   */
  updateOptions(options) {
    Object.assign(this.options, options);
  }
};

// services/StatusManager.ts
var import_obsidian11 = require("obsidian");
var StatusManager = class {
  constructor(statusBarItem) {
    this.statusBarItem = statusBarItem;
    this.currentStatus = "initializing" /* INITIALIZING */;
    this.statusDetails = {
      message: "Initializing plugin...",
      timestamp: Date.now()
    };
    this.subscribers = /* @__PURE__ */ new Set();
    this.updateStatusBar();
  }
  /**
   * Update the current status with new details
   */
  setStatus(status, details = {}) {
    const oldStatus = this.currentStatus;
    this.currentStatus = status;
    this.statusDetails = {
      ...this.statusDetails,
      ...details,
      timestamp: Date.now()
    };
    this.updateStatusBar();
    if (oldStatus !== status) {
      this.notifySubscribers();
    }
    if (status === "error" /* ERROR */ && details.message) {
      new import_obsidian11.Notice(`Mind Matrix: ${details.message}`);
    }
  }
  /**
   * Get the current status and details
   */
  getStatus() {
    return {
      status: this.currentStatus,
      details: { ...this.statusDetails }
    };
  }
  /**
   * Subscribe to status changes
   */
  subscribe(callback) {
    this.subscribers.add(callback);
    return () => {
      this.subscribers.delete(callback);
    };
  }
  /**
   * Update the status bar UI
   */
  updateStatusBar() {
    this.statusBarItem.empty();
    const statusIcon = this.createStatusIcon();
    this.statusBarItem.appendChild(statusIcon);
    this.statusBarItem.setAttribute("aria-label", this.statusDetails.message);
    this.statusBarItem.onclick = () => {
      new import_obsidian11.Notice(this.statusDetails.message);
    };
  }
  /**
   * Create status icon element
   */
  createStatusIcon() {
    const icon = document.createElement("span");
    icon.addClass("mind-matrix-status-icon");
    switch (this.currentStatus) {
      case "ready" /* READY */:
        icon.addClass("is-ready");
        icon.innerHTML = "\u25CF";
        break;
      case "error" /* ERROR */:
        icon.addClass("is-error");
        icon.innerHTML = "\u26A0";
        break;
      case "waiting_sync" /* WAITING_FOR_SYNC */:
      case "checking_file" /* CHECKING_FILE */:
        icon.addClass("is-working");
        icon.innerHTML = "\u21BB";
        break;
      default:
        icon.addClass("is-initializing");
        icon.innerHTML = "\u25CB";
    }
    return icon;
  }
  /**
   * Notify all subscribers of status change
   */
  notifySubscribers() {
    this.subscribers.forEach((callback) => {
      try {
        callback(this.currentStatus, this.statusDetails);
      } catch (error) {
        console.error("Error in status change subscriber:", error);
      }
    });
  }
  /**
   * Check if plugin is in a specific status
   */
  isInStatus(status) {
    return this.currentStatus === status;
  }
  /**
   * Update progress for current status
   */
  updateProgress(progress) {
    this.statusDetails.progress = progress;
    this.updateStatusBar();
  }
};

// services/SyncDetectionManager.ts
var SyncDetectionManager = class {
  // 5 seconds
  constructor(plugin, statusManager, onQuietPeriodReached) {
    this.plugin = plugin;
    this.statusManager = statusManager;
    this.onQuietPeriodReached = onQuietPeriodReached;
    this.lastSyncActivity = 0;
    this.syncCheckInterval = null;
    this.quietPeriodReached = false;
    this.isWaitingForQuietPeriod = false;
    this.QUIET_PERIOD_MS = 5e3;
  }
  /**
   * Start monitoring for sync activity
   */
  startMonitoring() {
    this.plugin.registerEvent(
      this.plugin.app.vault.on("modify", () => this.recordSyncActivity())
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("create", () => this.recordSyncActivity())
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("delete", () => this.recordSyncActivity())
    );
    this.startQuietPeriodCheck();
  }
  /**
   * Record sync activity and reset quiet period
   */
  recordSyncActivity() {
    this.lastSyncActivity = Date.now();
    this.quietPeriodReached = false;
    if (this.isWaitingForQuietPeriod) {
      this.statusManager.setStatus("waiting_sync" /* WAITING_FOR_SYNC */, {
        message: "Waiting for Obsidian sync to settle..."
      });
    }
  }
  /**
   * Start checking for quiet period
   */
  startQuietPeriodCheck() {
    if (this.syncCheckInterval) {
      clearInterval(this.syncCheckInterval);
    }
    this.isWaitingForQuietPeriod = true;
    this.syncCheckInterval = setInterval(() => {
      const timeSinceLastSync = Date.now() - this.lastSyncActivity;
      if (timeSinceLastSync >= this.QUIET_PERIOD_MS && !this.quietPeriodReached) {
        this.quietPeriodReached = true;
        this.isWaitingForQuietPeriod = false;
        if (this.syncCheckInterval) {
          clearInterval(this.syncCheckInterval);
          this.syncCheckInterval = null;
        }
        this.onQuietPeriodReached();
      }
    }, 1e3);
  }
  /**
   * Stop monitoring for sync activity
   */
  stopMonitoring() {
    if (this.syncCheckInterval) {
      clearInterval(this.syncCheckInterval);
      this.syncCheckInterval = null;
    }
    this.isWaitingForQuietPeriod = false;
  }
  /**
   * Check if currently waiting for quiet period
   */
  isWaiting() {
    return this.isWaitingForQuietPeriod;
  }
  /**
   * Get time since last sync activity
   */
  getTimeSinceLastSync() {
    return Date.now() - this.lastSyncActivity;
  }
};

// main.ts
var MindMatrixPlugin = class extends import_obsidian12.Plugin {
  constructor() {
    super(...arguments);
    this.supabaseService = null;
    this.openAIService = null;
    this.queueService = null;
    this.fileTracker = null;
    this.errorHandler = null;
    this.notificationManager = null;
    this.isInitializing = false;
    this.syncManager = null;
    this.syncCheckInterval = null;
    this.initializationTimeout = null;
    this.syncCheckAttempts = 0;
    this.initialSyncManager = null;
    this.metadataExtractor = null;
    this.statusManager = null;
    this.syncDetectionManager = null;
  }
  async onload() {
    var _a2;
    console.log("Loading Mind Matrix Plugin...");
    try {
      this.statusManager = new StatusManager(this.addStatusBarItem());
      this.statusManager.setStatus("initializing" /* INITIALIZING */, {
        message: "Loading Mind Matrix Plugin..."
      });
      await this.loadSettings();
      await this.initializeCoreServices();
      await this.initializeVaultIfNeeded();
      this.addSettingTab(new MindMatrixSettingsTab(this.app, this));
      if (isVaultInitialized(this.settings)) {
        this.statusManager.setStatus("waiting_sync" /* WAITING_FOR_SYNC */, {
          message: "Waiting for Obsidian sync to settle..."
        });
        this.syncDetectionManager = new SyncDetectionManager(
          this,
          this.statusManager,
          this.onSyncQuietPeriodReached.bind(this)
        );
        this.syncDetectionManager.startMonitoring();
      } else {
        await this.completeInitialization();
      }
    } catch (error) {
      console.error("Failed to initialize Mind Matrix Plugin:", error);
      (_a2 = this.statusManager) == null ? void 0 : _a2.setStatus("error" /* ERROR */, {
        message: "Failed to initialize plugin. Check console for details.",
        error
      });
    }
  }
  async onSyncQuietPeriodReached() {
    var _a2, _b, _c;
    try {
      (_a2 = this.syncDetectionManager) == null ? void 0 : _a2.stopMonitoring();
      (_b = this.statusManager) == null ? void 0 : _b.setStatus("checking_file" /* CHECKING_FILE */, {
        message: "Initializing sync manager..."
      });
      await this.initializeSyncManager();
      await this.startSyncProcess();
      await this.completeInitialization();
    } catch (error) {
      console.error("Error during quiet period initialization:", error);
      (_c = this.statusManager) == null ? void 0 : _c.setStatus("error" /* ERROR */, {
        message: "Failed to initialize after sync quiet period",
        error
      });
    }
  }
  async completeInitialization() {
    var _a2, _b;
    try {
      this.registerEventHandlers();
      this.addCommands();
      (_a2 = this.statusManager) == null ? void 0 : _a2.setStatus("ready" /* READY */, {
        message: "Mind Matrix is ready"
      });
    } catch (error) {
      console.error("Error completing initialization:", error);
      (_b = this.statusManager) == null ? void 0 : _b.setStatus("error" /* ERROR */, {
        message: "Failed to complete initialization",
        error
      });
    }
  }
  async onunload() {
    var _a2, _b, _c, _d;
    console.log("Unloading Mind Matrix Plugin...");
    (_a2 = this.syncDetectionManager) == null ? void 0 : _a2.stopMonitoring();
    if (this.initializationTimeout) {
      clearTimeout(this.initializationTimeout);
    }
    if (this.syncCheckInterval) {
      clearInterval(this.syncCheckInterval);
    }
    (_b = this.queueService) == null ? void 0 : _b.stop();
    (_c = this.notificationManager) == null ? void 0 : _c.clear();
    (_d = this.initialSyncManager) == null ? void 0 : _d.stop();
  }
  async startSyncProcess() {
    var _a2, _b, _c, _d, _e, _f;
    if (!this.syncManager) {
      throw new Error("Sync manager not initialized");
    }
    try {
      (_a2 = this.statusManager) == null ? void 0 : _a2.setStatus("checking_file" /* CHECKING_FILE */, {
        message: "Checking sync file status..."
      });
      const syncStatus = await this.syncManager.validateSyncState();
      if (!syncStatus.isValid) {
        if (this.settings.sync.requireSync) {
          (_b = this.statusManager) == null ? void 0 : _b.setStatus("error" /* ERROR */, {
            message: `Sync validation failed: ${syncStatus.error}`
          });
          throw new Error(`Sync validation failed: ${syncStatus.error}`);
        } else {
          console.warn(`Sync validation warning: ${syncStatus.error}`);
          new import_obsidian12.Notice(`Sync warning: ${syncStatus.error}`);
        }
      }
      (_c = this.statusManager) == null ? void 0 : _c.setStatus("initializing" /* INITIALIZING */, {
        message: "Initializing services..."
      });
      await this.initializeServices();
      this.startPeriodicSyncChecks();
      if (this.settings.initialSync.enableAutoInitialSync && this.initialSyncManager) {
        (_d = this.statusManager) == null ? void 0 : _d.setStatus("initializing" /* INITIALIZING */, {
          message: "Starting initial vault sync..."
        });
        await this.initialSyncManager.startSync();
      }
      (_e = this.statusManager) == null ? void 0 : _e.setStatus("ready" /* READY */, {
        message: "Sync process completed"
      });
    } catch (error) {
      if (this.settings.sync.requireSync) {
        (_f = this.statusManager) == null ? void 0 : _f.setStatus("error" /* ERROR */, {
          message: "Sync process failed",
          error
        });
        throw error;
      } else {
        console.error("Sync process error:", error);
        new import_obsidian12.Notice("Sync process error. Continuing with limited functionality.");
        await this.initializeServices();
      }
    }
  }
  async initializeSyncManager() {
    if (!this.errorHandler) {
      throw new Error("Error handler must be initialized before sync manager");
    }
    try {
      this.syncManager = new SyncFileManager(
        this.app.vault,
        this.errorHandler,
        this.settings.sync.syncFilePath,
        this.settings.sync.backupInterval
      );
      await this.syncManager.initialize();
      console.log("Sync manager initialized successfully");
    } catch (error) {
      console.error("Failed to initialize sync manager:", error);
      if (this.settings.enableNotifications) {
        new import_obsidian12.Notice("Failed to initialize sync system. Some features may be unavailable.");
      }
      throw error;
    }
  }
  async initializeCoreServices() {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    (_a2 = this.statusManager) == null ? void 0 : _a2.setStatus("initializing" /* INITIALIZING */, {
      message: "Initializing core services..."
    });
    this.errorHandler = new ErrorHandler(
      (_c = (_b = this.settings) == null ? void 0 : _b.debug) != null ? _c : DEFAULT_SETTINGS.debug,
      this.app.vault.adapter.getBasePath()
    );
    this.notificationManager = new NotificationManager(
      this.addStatusBarItem(),
      (_e = (_d = this.settings) == null ? void 0 : _d.enableNotifications) != null ? _e : true,
      (_g = (_f = this.settings) == null ? void 0 : _f.enableProgressBar) != null ? _g : true
    );
    (_h = this.statusManager) == null ? void 0 : _h.setStatus("initializing" /* INITIALIZING */, {
      message: "Core services initialized"
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    var _a2, _b;
    await this.saveData(this.settings);
    (_a2 = this.notificationManager) == null ? void 0 : _a2.updateSettings(
      this.settings.enableNotifications,
      this.settings.enableProgressBar
    );
    (_b = this.errorHandler) == null ? void 0 : _b.updateSettings(this.settings.debug);
    if (isVaultInitialized(this.settings)) {
      await this.initializeServices();
    }
  }
  startPeriodicSyncChecks() {
    if (this.syncCheckInterval) {
      clearInterval(this.syncCheckInterval);
    }
    this.syncCheckInterval = setInterval(async () => {
      await this.performSyncCheck();
    }, this.settings.sync.checkInterval);
  }
  async performSyncCheck() {
    var _a2;
    if (!this.syncManager)
      return;
    try {
      const syncStatus = await this.syncManager.validateSyncState();
      if (!syncStatus.isValid) {
        console.warn(`Sync check failed: ${syncStatus.error}`);
        if (this.settings.enableNotifications) {
          new import_obsidian12.Notice(`Sync issue detected: ${syncStatus.error}`);
        }
        const recovered = await this.syncManager.attemptRecovery();
        if (!recovered && this.settings.sync.requireSync) {
          await this.restartServices();
        }
      }
      await this.syncManager.updateLastSync();
    } catch (error) {
      (_a2 = this.errorHandler) == null ? void 0 : _a2.handleError(error, {
        context: "performSyncCheck",
        metadata: { timestamp: Date.now() }
      });
    }
  }
  async restartServices() {
    var _a2;
    (_a2 = this.queueService) == null ? void 0 : _a2.stop();
    if (this.syncCheckInterval) {
      clearInterval(this.syncCheckInterval);
    }
    try {
      await this.initializeSyncManager();
      await this.startSyncProcess();
    } catch (error) {
      console.error("Failed to restart services:", error);
      if (this.settings.enableNotifications) {
        new import_obsidian12.Notice("Failed to restart services after sync error");
      }
    }
  }
  async initializeVaultIfNeeded() {
    if (this.isInitializing)
      return;
    this.isInitializing = true;
    try {
      if (!isVaultInitialized(this.settings)) {
        this.settings.vaultId = generateVaultId();
        this.settings.lastKnownVaultName = this.app.vault.getName();
        await this.saveSettings();
        if (this.settings.enableNotifications) {
          new import_obsidian12.Notice("Vault initialized with new ID");
        }
      } else if (this.settings.lastKnownVaultName !== this.app.vault.getName()) {
        this.settings.lastKnownVaultName = this.app.vault.getName();
        await this.saveSettings();
      }
    } finally {
      this.isInitializing = false;
    }
  }
  async initializeServices() {
    console.log("Initializing services...", {
      hasVault: !!this.app.vault,
      hasErrorHandler: !!this.errorHandler
    });
    if (!this.errorHandler) {
      throw new Error("Core services not initialized");
    }
    try {
      this.fileTracker = new FileTracker(this.app.vault, this.errorHandler, this.settings.sync.syncFilePath);
      await this.fileTracker.initialize();
      console.log("FileTracker initialized.");
      try {
        this.supabaseService = await SupabaseService.getInstance(this.settings);
        if (!this.supabaseService) {
          new import_obsidian12.Notice("Supabase service not initialized. Please configure your API settings.");
          console.error("Supabase service initialization failed: Missing configuration.");
          return;
        }
        console.log("Supabase service initialized.");
      } catch (error) {
        console.error("Supabase initialization error:", error);
        new import_obsidian12.Notice(`Failed to initialize Supabase service: ${error.message}`);
        return;
      }
      this.openAIService = new OpenAIService(this.settings.openai, this.errorHandler);
      console.log("OpenAI service initialized.");
      if (!this.app.vault) {
        throw new Error("Vault is not available");
      }
      if (this.notificationManager && this.supabaseService && this.openAIService) {
        try {
          this.queueService = new QueueService(
            this.settings.queue.maxConcurrent,
            this.settings.queue.retryAttempts,
            this.supabaseService,
            this.openAIService,
            this.errorHandler,
            this.notificationManager,
            this.app.vault,
            this.settings.chunking
          );
          this.queueService.start();
          console.log("Queue service initialized and started.");
        } catch (error) {
          console.error("Failed to initialize QueueService:", error);
          new import_obsidian12.Notice(`Failed to initialize queue service: ${error.message}`);
          throw error;
        }
      } else {
        throw new Error("Required services not available for QueueService initialization");
      }
      this.metadataExtractor = new MetadataExtractor();
      console.log("MetadataExtractor initialized.");
      if (this.queueService && this.syncManager && this.metadataExtractor) {
        this.initialSyncManager = new InitialSyncManager(
          this.app.vault,
          this.queueService,
          this.syncManager,
          this.metadataExtractor,
          this.errorHandler,
          this.notificationManager,
          this.settings.initialSync
        );
        console.log("InitialSyncManager initialized.");
      }
    } catch (error) {
      console.error("Failed to initialize services:", error);
      throw error;
    }
  }
  checkRequiredConfigurations() {
    if (!this.settings.openai.apiKey) {
      new import_obsidian12.Notice("OpenAI API key is missing. AI features are disabled. Configure it in the settings.");
    }
    if (!this.settings.supabase.url || !this.settings.supabase.apiKey) {
      new import_obsidian12.Notice("Supabase configuration is incomplete. Database features are disabled. Configure it in the settings.");
    }
  }
  registerEventHandlers() {
    this.registerEvent(
      this.app.vault.on("create", async (file) => {
        var _a2;
        if (!(file instanceof import_obsidian12.TFile))
          return;
        if (!await this.ensureSyncFileExists()) {
          new import_obsidian12.Notice("Failed to create sync file. Plugin functionality limited.");
          return;
        }
        if (!this.shouldProcessFile(file))
          return;
        await ((_a2 = this.fileTracker) == null ? void 0 : _a2.handleCreate(file));
        await this.queueFileProcessing(file, "CREATE");
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", async (file) => {
        var _a2;
        if (!(file instanceof import_obsidian12.TFile))
          return;
        if (!await this.ensureSyncFileExists()) {
          new import_obsidian12.Notice("Failed to create sync file. Plugin functionality limited.");
          return;
        }
        if (!this.shouldProcessFile(file))
          return;
        await ((_a2 = this.fileTracker) == null ? void 0 : _a2.handleModify(file));
        await this.queueFileProcessing(file, "UPDATE");
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", async (file) => {
        var _a2;
        if (!(file instanceof import_obsidian12.TFile))
          return;
        if (file.path === this.settings.sync.syncFilePath) {
          console.log("Sync file was deleted, will recreate on next operation");
          return;
        }
        if (!await this.ensureSyncFileExists()) {
          new import_obsidian12.Notice("Failed to create sync file. Plugin functionality limited.");
          return;
        }
        if (!this.shouldProcessFile(file))
          return;
        await ((_a2 = this.fileTracker) == null ? void 0 : _a2.handleDelete(file));
        await this.queueFileProcessing(file, "DELETE");
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", async (file, oldPath) => {
        var _a2;
        if (!(file instanceof import_obsidian12.TFile))
          return;
        if (!await this.ensureSyncFileExists()) {
          new import_obsidian12.Notice("Failed to create sync file. Plugin functionality limited.");
          return;
        }
        if (!this.shouldProcessFile(file))
          return;
        await ((_a2 = this.fileTracker) == null ? void 0 : _a2.handleRename(file, oldPath));
        await this.handleFileRename(file, oldPath);
      })
    );
  }
  shouldProcessFile(file) {
    if (!this.queueService || !isVaultInitialized(this.settings)) {
      return false;
    }
    if (!this.settings.enableAutoSync) {
      return false;
    }
    const exclusions = this.settings.exclusions || {
      excludedFiles: [],
      excludedFolders: [],
      excludedFileTypes: [],
      excludedFilePrefixes: []
    };
    const filePath = file.path;
    const fileName = file.name;
    if (Array.isArray(exclusions.excludedFiles) && exclusions.excludedFiles.includes(fileName)) {
      console.log("Skipping excluded file:", fileName);
      return false;
    }
    if (Array.isArray(exclusions.excludedFolders)) {
      const isExcludedFolder = exclusions.excludedFolders.some((folder) => {
        const normalizedFolder = folder.endsWith("/") ? folder : folder + "/";
        return filePath.startsWith(normalizedFolder);
      });
      if (isExcludedFolder) {
        console.log("Skipping file in excluded folder:", filePath);
        return false;
      }
    }
    if (Array.isArray(exclusions.excludedFileTypes)) {
      const isExcludedType = exclusions.excludedFileTypes.some(
        (ext) => filePath.toLowerCase().endsWith(ext.toLowerCase())
      );
      if (isExcludedType) {
        console.log("Skipping excluded file type:", filePath);
        return false;
      }
    }
    if (Array.isArray(exclusions.excludedFilePrefixes)) {
      const isExcludedPrefix = exclusions.excludedFilePrefixes.some(
        (prefix) => fileName.startsWith(prefix)
      );
      if (isExcludedPrefix) {
        console.log("Skipping file with excluded prefix:", fileName);
        return false;
      }
    }
    return true;
  }
  async ensureSyncFileExists() {
    if (!this.syncManager) {
      console.error("Sync manager not initialized");
      return false;
    }
    try {
      const syncFile = this.app.vault.getAbstractFileByPath(this.settings.sync.syncFilePath);
      if (!syncFile) {
        console.log("Sync file missing, recreating...");
        await this.syncManager.initialize();
        new import_obsidian12.Notice("Recreated sync file");
        return true;
      }
      return true;
    } catch (error) {
      console.error("Error ensuring sync file exists:", error);
      return false;
    }
  }
  async queueFileProcessing(file, type) {
    var _a2;
    try {
      if (!this.queueService || !this.fileTracker) {
        console.error("Required services not initialized:", {
          queueService: !!this.queueService,
          fileTracker: !!this.fileTracker
        });
        return;
      }
      console.log("Starting file processing:", {
        fileName: file.name,
        type,
        path: file.path
      });
      const metadata = await this.fileTracker.createFileMetadata(file);
      console.log("Created metadata:", metadata);
      const task = {
        id: file.path,
        type,
        priority: type === "DELETE" ? 2 : 1,
        maxRetries: this.settings.queue.retryAttempts,
        retryCount: 0,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        status: "PENDING",
        metadata,
        data: {}
      };
      console.log("Created task:", task);
      await this.queueService.addTask(task);
      console.log("Task added to queue");
      if (this.settings.enableNotifications) {
        const action = type.toLowerCase();
        new import_obsidian12.Notice(`Queued ${action} for processing: ${file.name}`);
      }
    } catch (error) {
      console.error("Error in queueFileProcessing:", error);
      (_a2 = this.errorHandler) == null ? void 0 : _a2.handleError(error, {
        context: "queueFileProcessing",
        metadata: { filePath: file.path, type }
      });
      if (this.settings.enableNotifications) {
        new import_obsidian12.Notice(`Failed to queue ${file.name} for processing`);
      }
    }
  }
  async handleFileRename(file, oldPath) {
    var _a2;
    try {
      if (!this.supabaseService)
        return;
      const chunks = await this.supabaseService.getDocumentChunks(oldPath);
      if (chunks.length > 0) {
        const updatedChunks = chunks.map((chunk) => ({
          ...chunk,
          metadata: {
            ...chunk.metadata,
            obsidianId: file.path,
            path: file.path
          }
        }));
        await this.supabaseService.deleteDocumentChunks(oldPath);
        await this.supabaseService.upsertChunks(updatedChunks);
        if (this.settings.enableNotifications) {
          new import_obsidian12.Notice(`Updated database entries for renamed file: ${file.name}`);
        }
      }
    } catch (error) {
      (_a2 = this.errorHandler) == null ? void 0 : _a2.handleError(error, {
        context: "handleFileRename",
        metadata: { filePath: file.path, oldPath }
      });
      if (this.settings.enableNotifications) {
        new import_obsidian12.Notice(`Failed to update database for renamed file: ${file.name}`);
      }
    }
  }
  addCommands() {
    this.addCommand({
      id: "force-sync-current-file",
      name: "Force sync current file",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          if (!checking) {
            this.queueFileProcessing(file, "UPDATE");
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "force-sync-all-files",
      name: "Force sync all files",
      callback: async () => {
        const files = this.app.vault.getMarkdownFiles();
        for (const file of files) {
          if (this.shouldProcessFile(file)) {
            await this.queueFileProcessing(file, "UPDATE");
          }
        }
      }
    });
    this.addCommand({
      id: "clear-sync-queue",
      name: "Clear sync queue",
      callback: () => {
        var _a2;
        (_a2 = this.queueService) == null ? void 0 : _a2.clear();
        if (this.settings.enableNotifications) {
          new import_obsidian12.Notice("Sync queue cleared");
        }
      }
    });
    this.addCommand({
      id: "reset-file-tracker",
      name: "Reset file tracker cache",
      callback: async () => {
        var _a2, _b;
        (_a2 = this.fileTracker) == null ? void 0 : _a2.clearCache();
        await ((_b = this.fileTracker) == null ? void 0 : _b.initialize());
        if (this.settings.enableNotifications) {
          new import_obsidian12.Notice("File tracker cache reset");
        }
      }
    });
    this.addCommand({
      id: "start-initial-sync",
      name: "Start initial vault sync",
      callback: async () => {
        if (this.initialSyncManager) {
          await this.initialSyncManager.startSync();
        } else {
          new import_obsidian12.Notice("Initial sync manager not initialized");
        }
      }
    });
    this.addCommand({
      id: "stop-initial-sync",
      name: "Stop initial vault sync",
      callback: () => {
        var _a2;
        (_a2 = this.initialSyncManager) == null ? void 0 : _a2.stop();
        new import_obsidian12.Notice("Initial sync stopped");
      }
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9ub2RlLWZldGNoL2Jyb3dzZXIuanMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL1Bvc3RncmVzdEVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RCdWlsZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9zcmMvUG9zdGdyZXN0Q2xpZW50LnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9pbmRleC50cyIsICJub2RlX21vZHVsZXMvd3MvYnJvd3Nlci5qcyIsICJtYWluLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL3NyYy9oZWxwZXIudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9mdW5jdGlvbnMtanMvc3JjL3R5cGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL3NyYy9GdW5jdGlvbnNDbGllbnQudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9lc20vd3JhcHBlci5tanMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvc2VyaWFsaXplci50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvdGltZXIudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL3RyYW5zZm9ybWVycy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvcHVzaC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9SZWFsdGltZVByZXNlbmNlLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvc3JjL1JlYWx0aW1lQ2hhbm5lbC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9SZWFsdGltZUNsaWVudC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL2xpYi9lcnJvcnMudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL3NyYy9saWIvaGVscGVycy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL2xpYi9mZXRjaC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL3BhY2thZ2VzL1N0b3JhZ2VGaWxlQXBpLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL3NyYy9saWIvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9zcmMvcGFja2FnZXMvU3RvcmFnZUJ1Y2tldEFwaS50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL1N0b3JhZ2VDbGllbnQudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9saWIvZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL2hlbHBlcnMudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvdmVyc2lvbi50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvaGVscGVycy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9lcnJvcnMudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9Hb1RydWVBZG1pbkFwaS50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9sb2NhbC1zdG9yYWdlLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9zcmMvbGliL3BvbHlmaWxscy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9sb2Nrcy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL0dvVHJ1ZUNsaWVudC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL0F1dGhDbGllbnQudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL1N1cGFiYXNlQXV0aENsaWVudC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9TdXBhYmFzZUNsaWVudC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9pbmRleC50cyIsICJzZXR0aW5ncy9TZXR0aW5ncy50cyIsICJzZXJ2aWNlcy9TdXBhYmFzZVNlcnZpY2UudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvaW50ZXJuYWwvcXMvZm9ybWF0cy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9pbnRlcm5hbC9xcy91dGlscy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9pbnRlcm5hbC9xcy9zdHJpbmdpZnkudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvdmVyc2lvbi50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9fc2hpbXMvcmVnaXN0cnkudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvX3NoaW1zL011bHRpcGFydEJvZHkudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvX3NoaW1zL3dlYi1ydW50aW1lLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvX3NoaW1zL2luZGV4Lm1qcyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9lcnJvci50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9pbnRlcm5hbC9kZWNvZGVycy9saW5lLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3N0cmVhbWluZy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy91cGxvYWRzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2NvcmUudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcGFnaW5hdGlvbi50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZS50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvY2hhdC9jaGF0LnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9hdWRpby9zcGVlY2gudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2F1ZGlvL3RyYW5zY3JpcHRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9hdWRpby90cmFuc2xhdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2F1ZGlvL2F1ZGlvLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iYXRjaGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL2Fzc2lzdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL1J1bm5hYmxlRnVuY3Rpb24udHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL2NoYXRDb21wbGV0aW9uVXRpbHMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0V2ZW50U3RyZWFtLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2xpYi9wYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXIudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0NoYXRDb21wbGV0aW9uUnVubmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL192ZW5kb3IvcGFydGlhbC1qc29uLXBhcnNlci9wYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2xpYi9DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lci50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9jaGF0L2NvbXBsZXRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL2NoYXQvY2hhdC50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9yZWFsdGltZS9zZXNzaW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9yZWFsdGltZS9yZWFsdGltZS50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9saWIvQXNzaXN0YW50U3RyZWFtLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvbWVzc2FnZXMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2JldGEvdGhyZWFkcy9ydW5zL3N0ZXBzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvcnVucy9ydW5zLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvdGhyZWFkcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9saWIvVXRpbC50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS92ZWN0b3Itc3RvcmVzL2ZpbGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3ZlY3Rvci1zdG9yZXMvZmlsZS1iYXRjaGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3ZlY3Rvci1zdG9yZXMvdmVjdG9yLXN0b3Jlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9iZXRhLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9jb21wbGV0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZW1iZWRkaW5ncy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmlsZXMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ZpbmUtdHVuaW5nL2pvYnMvY2hlY2twb2ludHMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ZpbmUtdHVuaW5nL2pvYnMvam9icy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmluZS10dW5pbmcvZmluZS10dW5pbmcudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ltYWdlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvbW9kZWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9tb2RlcmF0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvdXBsb2Fkcy9wYXJ0cy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvdXBsb2Fkcy91cGxvYWRzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2luZGV4LnRzIiwgInNlcnZpY2VzL09wZW5BSVNlcnZpY2UudHMiLCAic2VydmljZXMvUXVldWVTZXJ2aWNlLnRzIiwgInNlcnZpY2VzL01ldGFkYXRhRXh0cmFjdG9yLnRzIiwgInV0aWxzL1RleHRTcGxpdHRlci50cyIsICJ1dGlscy9GaWxlVHJhY2tlci50cyIsICJzZXJ2aWNlcy9TeW5jRmlsZU1hbmFnZXIudHMiLCAidXRpbHMvRXJyb3JIYW5kbGVyLnRzIiwgInV0aWxzL05vdGlmaWNhdGlvbk1hbmFnZXIudHMiLCAic2V0dGluZ3MvU2V0dGluZ3NUYWIudHMiLCAic2VydmljZXMvSW5pdGlhbFN5bmNNYW5hZ2VyLnRzIiwgInNlcnZpY2VzL1N0YXR1c01hbmFnZXIudHMiLCAic2VydmljZXMvU3luY0RldGVjdGlvbk1hbmFnZXIudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIlwidXNlIHN0cmljdFwiO1xuXG4vLyByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHRoZSBvbmx5IHJlbGlhYmxlIG1lYW5zIHRvIGdldCB0aGUgZ2xvYmFsIG9iamVjdCBpc1xuICAgIC8vIGBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpYFxuICAgIC8vIEhvd2V2ZXIsIHRoaXMgY2F1c2VzIENTUCB2aW9sYXRpb25zIGluIENocm9tZSBhcHBzLlxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHNlbGY7IH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHdpbmRvdzsgfVxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZ2xvYmFsOyB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QnKTtcbn1cblxudmFyIGdsb2JhbE9iamVjdCA9IGdldEdsb2JhbCgpO1xuXG5leHBvcnQgY29uc3QgZmV0Y2ggPSBnbG9iYWxPYmplY3QuZmV0Y2g7XG5cbmV4cG9ydCBkZWZhdWx0IGdsb2JhbE9iamVjdC5mZXRjaC5iaW5kKGdsb2JhbE9iamVjdCk7XG5cbmV4cG9ydCBjb25zdCBIZWFkZXJzID0gZ2xvYmFsT2JqZWN0LkhlYWRlcnM7XG5leHBvcnQgY29uc3QgUmVxdWVzdCA9IGdsb2JhbE9iamVjdC5SZXF1ZXN0O1xuZXhwb3J0IGNvbnN0IFJlc3BvbnNlID0gZ2xvYmFsT2JqZWN0LlJlc3BvbnNlO1xuIiwgIi8qKlxuICogRXJyb3IgZm9ybWF0XG4gKlxuICoge0BsaW5rIGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWw/aGlnaGxpZ2h0PW9wdGlvbnMjZXJyb3JzLWFuZC1odHRwLXN0YXR1cy1jb2Rlc31cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zdGdyZXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGRldGFpbHM6IHN0cmluZ1xuICBoaW50OiBzdHJpbmdcbiAgY29kZTogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IoY29udGV4dDogeyBtZXNzYWdlOiBzdHJpbmc7IGRldGFpbHM6IHN0cmluZzsgaGludDogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfSkge1xuICAgIHN1cGVyKGNvbnRleHQubWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnUG9zdGdyZXN0RXJyb3InXG4gICAgdGhpcy5kZXRhaWxzID0gY29udGV4dC5kZXRhaWxzXG4gICAgdGhpcy5oaW50ID0gY29udGV4dC5oaW50XG4gICAgdGhpcy5jb2RlID0gY29udGV4dC5jb2RlXG4gIH1cbn1cbiIsICIvLyBAdHMtaWdub3JlXG5pbXBvcnQgbm9kZUZldGNoIGZyb20gJ0BzdXBhYmFzZS9ub2RlLWZldGNoJ1xuXG5pbXBvcnQgdHlwZSB7IEZldGNoLCBQb3N0Z3Jlc3RTaW5nbGVSZXNwb25zZSwgUG9zdGdyZXN0UmVzcG9uc2VTdWNjZXNzIH0gZnJvbSAnLi90eXBlcydcbmltcG9ydCBQb3N0Z3Jlc3RFcnJvciBmcm9tICcuL1Bvc3RncmVzdEVycm9yJ1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdCwgVGhyb3dPbkVycm9yIGV4dGVuZHMgYm9vbGVhbiA9IGZhbHNlPlxuICBpbXBsZW1lbnRzXG4gICAgUHJvbWlzZUxpa2U8XG4gICAgICBUaHJvd09uRXJyb3IgZXh0ZW5kcyB0cnVlID8gUG9zdGdyZXN0UmVzcG9uc2VTdWNjZXNzPFJlc3VsdD4gOiBQb3N0Z3Jlc3RTaW5nbGVSZXNwb25zZTxSZXN1bHQ+XG4gICAgPlxue1xuICBwcm90ZWN0ZWQgbWV0aG9kOiAnR0VUJyB8ICdIRUFEJyB8ICdQT1NUJyB8ICdQQVRDSCcgfCAnREVMRVRFJ1xuICBwcm90ZWN0ZWQgdXJsOiBVUkxcbiAgcHJvdGVjdGVkIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgcHJvdGVjdGVkIHNjaGVtYT86IHN0cmluZ1xuICBwcm90ZWN0ZWQgYm9keT86IHVua25vd25cbiAgcHJvdGVjdGVkIHNob3VsZFRocm93T25FcnJvciA9IGZhbHNlXG4gIHByb3RlY3RlZCBzaWduYWw/OiBBYm9ydFNpZ25hbFxuICBwcm90ZWN0ZWQgZmV0Y2g6IEZldGNoXG4gIHByb3RlY3RlZCBpc01heWJlU2luZ2xlOiBib29sZWFuXG5cbiAgY29uc3RydWN0b3IoYnVpbGRlcjogUG9zdGdyZXN0QnVpbGRlcjxSZXN1bHQ+KSB7XG4gICAgdGhpcy5tZXRob2QgPSBidWlsZGVyLm1ldGhvZFxuICAgIHRoaXMudXJsID0gYnVpbGRlci51cmxcbiAgICB0aGlzLmhlYWRlcnMgPSBidWlsZGVyLmhlYWRlcnNcbiAgICB0aGlzLnNjaGVtYSA9IGJ1aWxkZXIuc2NoZW1hXG4gICAgdGhpcy5ib2R5ID0gYnVpbGRlci5ib2R5XG4gICAgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBidWlsZGVyLnNob3VsZFRocm93T25FcnJvclxuICAgIHRoaXMuc2lnbmFsID0gYnVpbGRlci5zaWduYWxcbiAgICB0aGlzLmlzTWF5YmVTaW5nbGUgPSBidWlsZGVyLmlzTWF5YmVTaW5nbGVcblxuICAgIGlmIChidWlsZGVyLmZldGNoKSB7XG4gICAgICB0aGlzLmZldGNoID0gYnVpbGRlci5mZXRjaFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5mZXRjaCA9IG5vZGVGZXRjaFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZldGNoID0gZmV0Y2hcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlcmUncyBhbiBlcnJvciB3aXRoIHRoZSBxdWVyeSwgdGhyb3dPbkVycm9yIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlIGJ5XG4gICAqIHRocm93aW5nIHRoZSBlcnJvciBpbnN0ZWFkIG9mIHJldHVybmluZyBpdCBhcyBwYXJ0IG9mIGEgc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAgICpcbiAgICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9zdXBhYmFzZS1qcy9pc3N1ZXMvOTJ9XG4gICAqL1xuICB0aHJvd09uRXJyb3IoKTogdGhpcyAmIFBvc3RncmVzdEJ1aWxkZXI8UmVzdWx0LCB0cnVlPiB7XG4gICAgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlXG4gICAgcmV0dXJuIHRoaXMgYXMgdGhpcyAmIFBvc3RncmVzdEJ1aWxkZXI8UmVzdWx0LCB0cnVlPlxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhbiBIVFRQIGhlYWRlciBmb3IgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBzZXRIZWFkZXIobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy5oZWFkZXJzID0geyAuLi50aGlzLmhlYWRlcnMgfVxuICAgIHRoaXMuaGVhZGVyc1tuYW1lXSA9IHZhbHVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRoZW48XG4gICAgVFJlc3VsdDEgPSBUaHJvd09uRXJyb3IgZXh0ZW5kcyB0cnVlXG4gICAgICA/IFBvc3RncmVzdFJlc3BvbnNlU3VjY2VzczxSZXN1bHQ+XG4gICAgICA6IFBvc3RncmVzdFNpbmdsZVJlc3BvbnNlPFJlc3VsdD4sXG4gICAgVFJlc3VsdDIgPSBuZXZlclxuICA+KFxuICAgIG9uZnVsZmlsbGVkPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB2YWx1ZTogVGhyb3dPbkVycm9yIGV4dGVuZHMgdHJ1ZVxuICAgICAgICAgICAgPyBQb3N0Z3Jlc3RSZXNwb25zZVN1Y2Nlc3M8UmVzdWx0PlxuICAgICAgICAgICAgOiBQb3N0Z3Jlc3RTaW5nbGVSZXNwb25zZTxSZXN1bHQ+XG4gICAgICAgICkgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4pXG4gICAgICB8IHVuZGVmaW5lZFxuICAgICAgfCBudWxsLFxuICAgIG9ucmVqZWN0ZWQ/OiAoKHJlYXNvbjogYW55KSA9PiBUUmVzdWx0MiB8IFByb21pc2VMaWtlPFRSZXN1bHQyPikgfCB1bmRlZmluZWQgfCBudWxsXG4gICk6IFByb21pc2VMaWtlPFRSZXN1bHQxIHwgVFJlc3VsdDI+IHtcbiAgICAvLyBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI3N3aXRjaGluZy1zY2hlbWFzXG4gICAgaWYgKHRoaXMuc2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHNraXBcbiAgICB9IGVsc2UgaWYgKFsnR0VUJywgJ0hFQUQnXS5pbmNsdWRlcyh0aGlzLm1ldGhvZCkpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0LVByb2ZpbGUnXSA9IHRoaXMuc2NoZW1hXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snQ29udGVudC1Qcm9maWxlJ10gPSB0aGlzLnNjaGVtYVxuICAgIH1cbiAgICBpZiAodGhpcy5tZXRob2QgIT09ICdHRVQnICYmIHRoaXMubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbidcbiAgICB9XG5cbiAgICAvLyBOT1RFOiBJbnZva2Ugdy9vIGB0aGlzYCB0byBhdm9pZCBpbGxlZ2FsIGludm9jYXRpb24gZXJyb3IuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9wdWxsLzI0N1xuICAgIGNvbnN0IF9mZXRjaCA9IHRoaXMuZmV0Y2hcbiAgICBsZXQgcmVzID0gX2ZldGNoKHRoaXMudXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh0aGlzLmJvZHkpLFxuICAgICAgc2lnbmFsOiB0aGlzLnNpZ25hbCxcbiAgICB9KS50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgIGxldCBlcnJvciA9IG51bGxcbiAgICAgIGxldCBkYXRhID0gbnVsbFxuICAgICAgbGV0IGNvdW50OiBudW1iZXIgfCBudWxsID0gbnVsbFxuICAgICAgbGV0IHN0YXR1cyA9IHJlcy5zdGF0dXNcbiAgICAgIGxldCBzdGF0dXNUZXh0ID0gcmVzLnN0YXR1c1RleHRcblxuICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICBpZiAodGhpcy5tZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXMudGV4dCgpXG4gICAgICAgICAgaWYgKGJvZHkgPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBQcmVmZXI6IHJldHVybj1taW5pbWFsXG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID09PSAndGV4dC9jc3YnKSB7XG4gICAgICAgICAgICBkYXRhID0gYm9keVxuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddICYmXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi92bmQucGdyc3QucGxhbit0ZXh0JylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGRhdGEgPSBib2R5XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGJvZHkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY291bnRIZWFkZXIgPSB0aGlzLmhlYWRlcnNbJ1ByZWZlciddPy5tYXRjaCgvY291bnQ9KGV4YWN0fHBsYW5uZWR8ZXN0aW1hdGVkKS8pXG4gICAgICAgIGNvbnN0IGNvbnRlbnRSYW5nZSA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC1yYW5nZScpPy5zcGxpdCgnLycpXG4gICAgICAgIGlmIChjb3VudEhlYWRlciAmJiBjb250ZW50UmFuZ2UgJiYgY29udGVudFJhbmdlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb3VudCA9IHBhcnNlSW50KGNvbnRlbnRSYW5nZVsxXSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlbXBvcmFyeSBwYXJ0aWFsIGZpeCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9pc3N1ZXMvMzYxXG4gICAgICAgIC8vIElzc3VlIHBlcnNpc3RzIGUuZy4gZm9yIGAuaW5zZXJ0KFsuLi5dKS5zZWxlY3QoKS5tYXliZVNpbmdsZSgpYFxuICAgICAgICBpZiAodGhpcy5pc01heWJlU2luZ2xlICYmIHRoaXMubWV0aG9kID09PSAnR0VUJyAmJiBBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb3N0Z1JFU1QvcG9zdGdyZXN0L2Jsb2IvYTg2N2Q3OWM0MjQxOWFmMTZjMThjM2ZiMDE5ZWJhOGRmOTkyNjI2Zi9zcmMvUG9zdGdSRVNUL0Vycm9yLmhzI0w1NTNcbiAgICAgICAgICAgICAgY29kZTogJ1BHUlNUMTE2JyxcbiAgICAgICAgICAgICAgZGV0YWlsczogYFJlc3VsdHMgY29udGFpbiAke2RhdGEubGVuZ3RofSByb3dzLCBhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24gcmVxdWlyZXMgMSByb3dgLFxuICAgICAgICAgICAgICBoaW50OiBudWxsLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnSlNPTiBvYmplY3QgcmVxdWVzdGVkLCBtdWx0aXBsZSAob3Igbm8pIHJvd3MgcmV0dXJuZWQnLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YSA9IG51bGxcbiAgICAgICAgICAgIGNvdW50ID0gbnVsbFxuICAgICAgICAgICAgc3RhdHVzID0gNDA2XG4gICAgICAgICAgICBzdGF0dXNUZXh0ID0gJ05vdCBBY2NlcHRhYmxlJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhWzBdXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzLnRleHQoKVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXJyb3IgPSBKU09OLnBhcnNlKGJvZHkpXG5cbiAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy8yOTVcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlcnJvcikgJiYgcmVzLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICBkYXRhID0gW11cbiAgICAgICAgICAgIGVycm9yID0gbnVsbFxuICAgICAgICAgICAgc3RhdHVzID0gMjAwXG4gICAgICAgICAgICBzdGF0dXNUZXh0ID0gJ09LJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9pc3N1ZXMvMjk1XG4gICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCAmJiBib2R5ID09PSAnJykge1xuICAgICAgICAgICAgc3RhdHVzID0gMjA0XG4gICAgICAgICAgICBzdGF0dXNUZXh0ID0gJ05vIENvbnRlbnQnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICBtZXNzYWdlOiBib2R5LFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciAmJiB0aGlzLmlzTWF5YmVTaW5nbGUgJiYgZXJyb3I/LmRldGFpbHM/LmluY2x1ZGVzKCcwIHJvd3MnKSkge1xuICAgICAgICAgIGVycm9yID0gbnVsbFxuICAgICAgICAgIHN0YXR1cyA9IDIwMFxuICAgICAgICAgIHN0YXR1c1RleHQgPSAnT0snXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IgJiYgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUG9zdGdyZXN0RXJyb3IoZXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcG9zdGdyZXN0UmVzcG9uc2UgPSB7XG4gICAgICAgIGVycm9yLFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb3VudCxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zdGdyZXN0UmVzcG9uc2VcbiAgICB9KVxuICAgIGlmICghdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgIHJlcyA9IHJlcy5jYXRjaCgoZmV0Y2hFcnJvcikgPT4gKHtcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBtZXNzYWdlOiBgJHtmZXRjaEVycm9yPy5uYW1lID8/ICdGZXRjaEVycm9yJ306ICR7ZmV0Y2hFcnJvcj8ubWVzc2FnZX1gLFxuICAgICAgICAgIGRldGFpbHM6IGAke2ZldGNoRXJyb3I/LnN0YWNrID8/ICcnfWAsXG4gICAgICAgICAgaGludDogJycsXG4gICAgICAgICAgY29kZTogYCR7ZmV0Y2hFcnJvcj8uY29kZSA/PyAnJ31gLFxuICAgICAgICB9LFxuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBjb3VudDogbnVsbCxcbiAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgIH0pKVxuICAgIH1cblxuICAgIHJldHVybiByZXMudGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZClcbiAgfVxufVxuIiwgImltcG9ydCBQb3N0Z3Jlc3RCdWlsZGVyIGZyb20gJy4vUG9zdGdyZXN0QnVpbGRlcidcbmltcG9ydCB7IEdldFJlc3VsdCB9IGZyb20gJy4vc2VsZWN0LXF1ZXJ5LXBhcnNlci9yZXN1bHQnXG5pbXBvcnQgeyBHZW5lcmljU2NoZW1hIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcjxcbiAgU2NoZW1hIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSxcbiAgUm93IGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIFJlc3VsdCxcbiAgUmVsYXRpb25OYW1lID0gdW5rbm93bixcbiAgUmVsYXRpb25zaGlwcyA9IHVua25vd25cbj4gZXh0ZW5kcyBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdD4ge1xuICAvKipcbiAgICogUGVyZm9ybSBhIFNFTEVDVCBvbiB0aGUgcXVlcnkgcmVzdWx0LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBgLmluc2VydCgpYCwgYC51cGRhdGUoKWAsIGAudXBzZXJ0KClgLCBhbmQgYC5kZWxldGUoKWAgZG8gbm90XG4gICAqIHJldHVybiBtb2RpZmllZCByb3dzLiBCeSBjYWxsaW5nIHRoaXMgbWV0aG9kLCBtb2RpZmllZCByb3dzIGFyZSByZXR1cm5lZCBpblxuICAgKiBgZGF0YWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW5zIC0gVGhlIGNvbHVtbnMgdG8gcmV0cmlldmUsIHNlcGFyYXRlZCBieSBjb21tYXNcbiAgICovXG4gIHNlbGVjdDxcbiAgICBRdWVyeSBleHRlbmRzIHN0cmluZyA9ICcqJyxcbiAgICBOZXdSZXN1bHRPbmUgPSBHZXRSZXN1bHQ8U2NoZW1hLCBSb3csIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcywgUXVlcnk+XG4gID4oXG4gICAgY29sdW1ucz86IFF1ZXJ5XG4gICk6IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXI8U2NoZW1hLCBSb3csIE5ld1Jlc3VsdE9uZVtdLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+IHtcbiAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZXMgZXhjZXB0IHdoZW4gcXVvdGVkXG4gICAgbGV0IHF1b3RlZCA9IGZhbHNlXG4gICAgY29uc3QgY2xlYW5lZENvbHVtbnMgPSAoY29sdW1ucyA/PyAnKicpXG4gICAgICAuc3BsaXQoJycpXG4gICAgICAubWFwKChjKSA9PiB7XG4gICAgICAgIGlmICgvXFxzLy50ZXN0KGMpICYmICFxdW90ZWQpIHtcbiAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICAgIHF1b3RlZCA9ICFxdW90ZWRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY1xuICAgICAgfSlcbiAgICAgIC5qb2luKCcnKVxuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3NlbGVjdCcsIGNsZWFuZWRDb2x1bW5zKVxuICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ1ByZWZlciddICs9ICcsJ1xuICAgIH1cbiAgICB0aGlzLmhlYWRlcnNbJ1ByZWZlciddICs9ICdyZXR1cm49cmVwcmVzZW50YXRpb24nXG4gICAgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyPFxuICAgICAgU2NoZW1hLFxuICAgICAgUm93LFxuICAgICAgTmV3UmVzdWx0T25lW10sXG4gICAgICBSZWxhdGlvbk5hbWUsXG4gICAgICBSZWxhdGlvbnNoaXBzXG4gICAgPlxuICB9XG5cbiAgb3JkZXI8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIG9wdGlvbnM/OiB7IGFzY2VuZGluZz86IGJvb2xlYW47IG51bGxzRmlyc3Q/OiBib29sZWFuOyByZWZlcmVuY2VkVGFibGU/OiB1bmRlZmluZWQgfVxuICApOiB0aGlzXG4gIG9yZGVyKFxuICAgIGNvbHVtbjogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IGFzY2VuZGluZz86IGJvb2xlYW47IG51bGxzRmlyc3Q/OiBib29sZWFuOyByZWZlcmVuY2VkVGFibGU/OiBzdHJpbmcgfVxuICApOiB0aGlzXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYCBpbnN0ZWFkIG9mIGBvcHRpb25zLmZvcmVpZ25UYWJsZWBcbiAgICovXG4gIG9yZGVyPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBvcHRpb25zPzogeyBhc2NlbmRpbmc/OiBib29sZWFuOyBudWxsc0ZpcnN0PzogYm9vbGVhbjsgZm9yZWlnblRhYmxlPzogdW5kZWZpbmVkIH1cbiAgKTogdGhpc1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWAgaW5zdGVhZCBvZiBgb3B0aW9ucy5mb3JlaWduVGFibGVgXG4gICAqL1xuICBvcmRlcihcbiAgICBjb2x1bW46IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyBhc2NlbmRpbmc/OiBib29sZWFuOyBudWxsc0ZpcnN0PzogYm9vbGVhbjsgZm9yZWlnblRhYmxlPzogc3RyaW5nIH1cbiAgKTogdGhpc1xuICAvKipcbiAgICogT3JkZXIgdGhlIHF1ZXJ5IHJlc3VsdCBieSBgY29sdW1uYC5cbiAgICpcbiAgICogWW91IGNhbiBjYWxsIHRoaXMgbWV0aG9kIG11bHRpcGxlIHRpbWVzIHRvIG9yZGVyIGJ5IG11bHRpcGxlIGNvbHVtbnMuXG4gICAqXG4gICAqIFlvdSBjYW4gb3JkZXIgcmVmZXJlbmNlZCB0YWJsZXMsIGJ1dCBpdCBvbmx5IGFmZmVjdHMgdGhlIG9yZGVyaW5nIG9mIHRoZVxuICAgKiBwYXJlbnQgdGFibGUgaWYgeW91IHVzZSBgIWlubmVyYCBpbiB0aGUgcXVlcnkuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIG9yZGVyIGJ5XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5hc2NlbmRpbmcgLSBJZiBgdHJ1ZWAsIHRoZSByZXN1bHQgd2lsbCBiZSBpbiBhc2NlbmRpbmcgb3JkZXJcbiAgICogQHBhcmFtIG9wdGlvbnMubnVsbHNGaXJzdCAtIElmIGB0cnVlYCwgYG51bGxgcyBhcHBlYXIgZmlyc3QuIElmIGBmYWxzZWAsXG4gICAqIGBudWxsYHMgYXBwZWFyIGxhc3QuXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIG9yZGVyIGEgcmVmZXJlbmNlZCB0YWJsZSBieVxuICAgKiBpdHMgY29sdW1uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuICAgKiBpbnN0ZWFkXG4gICAqL1xuICBvcmRlcihcbiAgICBjb2x1bW46IHN0cmluZyxcbiAgICB7XG4gICAgICBhc2NlbmRpbmcgPSB0cnVlLFxuICAgICAgbnVsbHNGaXJzdCxcbiAgICAgIGZvcmVpZ25UYWJsZSxcbiAgICAgIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSxcbiAgICB9OiB7XG4gICAgICBhc2NlbmRpbmc/OiBib29sZWFuXG4gICAgICBudWxsc0ZpcnN0PzogYm9vbGVhblxuICAgICAgZm9yZWlnblRhYmxlPzogc3RyaW5nXG4gICAgICByZWZlcmVuY2VkVGFibGU/OiBzdHJpbmdcbiAgICB9ID0ge31cbiAgKTogdGhpcyB7XG4gICAgY29uc3Qga2V5ID0gcmVmZXJlbmNlZFRhYmxlID8gYCR7cmVmZXJlbmNlZFRhYmxlfS5vcmRlcmAgOiAnb3JkZXInXG4gICAgY29uc3QgZXhpc3RpbmdPcmRlciA9IHRoaXMudXJsLnNlYXJjaFBhcmFtcy5nZXQoa2V5KVxuXG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChcbiAgICAgIGtleSxcbiAgICAgIGAke2V4aXN0aW5nT3JkZXIgPyBgJHtleGlzdGluZ09yZGVyfSxgIDogJyd9JHtjb2x1bW59LiR7YXNjZW5kaW5nID8gJ2FzYycgOiAnZGVzYyd9JHtcbiAgICAgICAgbnVsbHNGaXJzdCA9PT0gdW5kZWZpbmVkID8gJycgOiBudWxsc0ZpcnN0ID8gJy5udWxsc2ZpcnN0JyA6ICcubnVsbHNsYXN0J1xuICAgICAgfWBcbiAgICApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBMaW1pdCB0aGUgcXVlcnkgcmVzdWx0IGJ5IGBjb3VudGAuXG4gICAqXG4gICAqIEBwYXJhbSBjb3VudCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzIHRvIHJldHVyblxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gbGltaXQgcm93cyBvZiByZWZlcmVuY2VkXG4gICAqIHRhYmxlcyBpbnN0ZWFkIG9mIHRoZSBwYXJlbnQgdGFibGVcbiAgICogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWBcbiAgICogaW5zdGVhZFxuICAgKi9cbiAgbGltaXQoXG4gICAgY291bnQ6IG51bWJlcixcbiAgICB7XG4gICAgICBmb3JlaWduVGFibGUsXG4gICAgICByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUsXG4gICAgfTogeyBmb3JlaWduVGFibGU/OiBzdHJpbmc7IHJlZmVyZW5jZWRUYWJsZT86IHN0cmluZyB9ID0ge31cbiAgKTogdGhpcyB7XG4gICAgY29uc3Qga2V5ID0gdHlwZW9mIHJlZmVyZW5jZWRUYWJsZSA9PT0gJ3VuZGVmaW5lZCcgPyAnbGltaXQnIDogYCR7cmVmZXJlbmNlZFRhYmxlfS5saW1pdGBcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgYCR7Y291bnR9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIExpbWl0IHRoZSBxdWVyeSByZXN1bHQgYnkgc3RhcnRpbmcgYXQgYW4gb2Zmc2V0IGBmcm9tYCBhbmQgZW5kaW5nIGF0IHRoZSBvZmZzZXQgYHRvYC5cbiAgICogT25seSByZWNvcmRzIHdpdGhpbiB0aGlzIHJhbmdlIGFyZSByZXR1cm5lZC5cbiAgICogVGhpcyByZXNwZWN0cyB0aGUgcXVlcnkgb3JkZXIgYW5kIGlmIHRoZXJlIGlzIG5vIG9yZGVyIGNsYXVzZSB0aGUgcmFuZ2UgY291bGQgYmVoYXZlIHVuZXhwZWN0ZWRseS5cbiAgICogVGhlIGBmcm9tYCBhbmQgYHRvYCB2YWx1ZXMgYXJlIDAtYmFzZWQgYW5kIGluY2x1c2l2ZTogYHJhbmdlKDEsIDMpYCB3aWxsIGluY2x1ZGUgdGhlIHNlY29uZCwgdGhpcmRcbiAgICogYW5kIGZvdXJ0aCByb3dzIG9mIHRoZSBxdWVyeS5cbiAgICpcbiAgICogQHBhcmFtIGZyb20gLSBUaGUgc3RhcnRpbmcgaW5kZXggZnJvbSB3aGljaCB0byBsaW1pdCB0aGUgcmVzdWx0XG4gICAqIEBwYXJhbSB0byAtIFRoZSBsYXN0IGluZGV4IHRvIHdoaWNoIHRvIGxpbWl0IHRoZSByZXN1bHRcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGxpbWl0IHJvd3Mgb2YgcmVmZXJlbmNlZFxuICAgKiB0YWJsZXMgaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG4gICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgXG4gICAqIGluc3RlYWRcbiAgICovXG4gIHJhbmdlKFxuICAgIGZyb206IG51bWJlcixcbiAgICB0bzogbnVtYmVyLFxuICAgIHtcbiAgICAgIGZvcmVpZ25UYWJsZSxcbiAgICAgIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSxcbiAgICB9OiB7IGZvcmVpZ25UYWJsZT86IHN0cmluZzsgcmVmZXJlbmNlZFRhYmxlPzogc3RyaW5nIH0gPSB7fVxuICApOiB0aGlzIHtcbiAgICBjb25zdCBrZXlPZmZzZXQgPVxuICAgICAgdHlwZW9mIHJlZmVyZW5jZWRUYWJsZSA9PT0gJ3VuZGVmaW5lZCcgPyAnb2Zmc2V0JyA6IGAke3JlZmVyZW5jZWRUYWJsZX0ub2Zmc2V0YFxuICAgIGNvbnN0IGtleUxpbWl0ID0gdHlwZW9mIHJlZmVyZW5jZWRUYWJsZSA9PT0gJ3VuZGVmaW5lZCcgPyAnbGltaXQnIDogYCR7cmVmZXJlbmNlZFRhYmxlfS5saW1pdGBcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleU9mZnNldCwgYCR7ZnJvbX1gKVxuICAgIC8vIFJhbmdlIGlzIGluY2x1c2l2ZSwgc28gYWRkIDFcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleUxpbWl0LCBgJHt0byAtIGZyb20gKyAxfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIEFib3J0U2lnbmFsIGZvciB0aGUgZmV0Y2ggcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHNpZ25hbCAtIFRoZSBBYm9ydFNpZ25hbCB0byB1c2UgZm9yIHRoZSBmZXRjaCByZXF1ZXN0XG4gICAqL1xuICBhYm9ydFNpZ25hbChzaWduYWw6IEFib3J0U2lnbmFsKTogdGhpcyB7XG4gICAgdGhpcy5zaWduYWwgPSBzaWduYWxcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBgZGF0YWAgYXMgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAgICpcbiAgICogUXVlcnkgcmVzdWx0IG11c3QgYmUgb25lIHJvdyAoZS5nLiB1c2luZyBgLmxpbWl0KDEpYCksIG90aGVyd2lzZSB0aGlzXG4gICAqIHJldHVybnMgYW4gZXJyb3IuXG4gICAqL1xuICBzaW5nbGU8XG4gICAgUmVzdWx0T25lID0gUmVzdWx0IGV4dGVuZHMgKGluZmVyIFJlc3VsdE9uZSlbXSA/IFJlc3VsdE9uZSA6IG5ldmVyXG4gID4oKTogUG9zdGdyZXN0QnVpbGRlcjxSZXN1bHRPbmU+IHtcbiAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID0gJ2FwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5vYmplY3QranNvbidcbiAgICByZXR1cm4gdGhpcyBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8UmVzdWx0T25lPlxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBgZGF0YWAgYXMgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAgICpcbiAgICogUXVlcnkgcmVzdWx0IG11c3QgYmUgemVybyBvciBvbmUgcm93IChlLmcuIHVzaW5nIGAubGltaXQoMSlgKSwgb3RoZXJ3aXNlXG4gICAqIHRoaXMgcmV0dXJucyBhbiBlcnJvci5cbiAgICovXG4gIG1heWJlU2luZ2xlPFxuICAgIFJlc3VsdE9uZSA9IFJlc3VsdCBleHRlbmRzIChpbmZlciBSZXN1bHRPbmUpW10gPyBSZXN1bHRPbmUgOiBuZXZlclxuICA+KCk6IFBvc3RncmVzdEJ1aWxkZXI8UmVzdWx0T25lIHwgbnVsbD4ge1xuICAgIC8vIFRlbXBvcmFyeSBwYXJ0aWFsIGZpeCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9pc3N1ZXMvMzYxXG4gICAgLy8gSXNzdWUgcGVyc2lzdHMgZS5nLiBmb3IgYC5pbnNlcnQoWy4uLl0pLnNlbGVjdCgpLm1heWJlU2luZ2xlKClgXG4gICAgaWYgKHRoaXMubWV0aG9kID09PSAnR0VUJykge1xuICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID0gJ2FwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5vYmplY3QranNvbidcbiAgICB9XG4gICAgdGhpcy5pc01heWJlU2luZ2xlID0gdHJ1ZVxuICAgIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxSZXN1bHRPbmUgfCBudWxsPlxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBgZGF0YWAgYXMgYSBzdHJpbmcgaW4gQ1NWIGZvcm1hdC5cbiAgICovXG4gIGNzdigpOiBQb3N0Z3Jlc3RCdWlsZGVyPHN0cmluZz4ge1xuICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0J10gPSAndGV4dC9jc3YnXG4gICAgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPHN0cmluZz5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYGRhdGFgIGFzIGFuIG9iamVjdCBpbiBbR2VvSlNPTl0oaHR0cHM6Ly9nZW9qc29uLm9yZykgZm9ybWF0LlxuICAgKi9cbiAgZ2VvanNvbigpOiBQb3N0Z3Jlc3RCdWlsZGVyPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiB7XG4gICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi9nZW8ranNvbidcbiAgICByZXR1cm4gdGhpcyBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGBkYXRhYCBhcyB0aGUgRVhQTEFJTiBwbGFuIGZvciB0aGUgcXVlcnkuXG4gICAqXG4gICAqIFlvdSBuZWVkIHRvIGVuYWJsZSB0aGVcbiAgICogW2RiX3BsYW5fZW5hYmxlZF0oaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9ndWlkZXMvZGF0YWJhc2UvZGVidWdnaW5nLXBlcmZvcm1hbmNlI2VuYWJsaW5nLWV4cGxhaW4pXG4gICAqIHNldHRpbmcgYmVmb3JlIHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuYW5hbHl6ZSAtIElmIGB0cnVlYCwgdGhlIHF1ZXJ5IHdpbGwgYmUgZXhlY3V0ZWQgYW5kIHRoZVxuICAgKiBhY3R1YWwgcnVuIHRpbWUgd2lsbCBiZSByZXR1cm5lZFxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy52ZXJib3NlIC0gSWYgYHRydWVgLCB0aGUgcXVlcnkgaWRlbnRpZmllciB3aWxsIGJlIHJldHVybmVkXG4gICAqIGFuZCBgZGF0YWAgd2lsbCBpbmNsdWRlIHRoZSBvdXRwdXQgY29sdW1ucyBvZiB0aGUgcXVlcnlcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuc2V0dGluZ3MgLSBJZiBgdHJ1ZWAsIGluY2x1ZGUgaW5mb3JtYXRpb24gb24gY29uZmlndXJhdGlvblxuICAgKiBwYXJhbWV0ZXJzIHRoYXQgYWZmZWN0IHF1ZXJ5IHBsYW5uaW5nXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmJ1ZmZlcnMgLSBJZiBgdHJ1ZWAsIGluY2x1ZGUgaW5mb3JtYXRpb24gb24gYnVmZmVyIHVzYWdlXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLndhbCAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBXQUwgcmVjb3JkIGdlbmVyYXRpb25cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuZm9ybWF0IC0gVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0LCBjYW4gYmUgYFwidGV4dFwiYCAoZGVmYXVsdClcbiAgICogb3IgYFwianNvblwiYFxuICAgKi9cbiAgZXhwbGFpbih7XG4gICAgYW5hbHl6ZSA9IGZhbHNlLFxuICAgIHZlcmJvc2UgPSBmYWxzZSxcbiAgICBzZXR0aW5ncyA9IGZhbHNlLFxuICAgIGJ1ZmZlcnMgPSBmYWxzZSxcbiAgICB3YWwgPSBmYWxzZSxcbiAgICBmb3JtYXQgPSAndGV4dCcsXG4gIH06IHtcbiAgICBhbmFseXplPzogYm9vbGVhblxuICAgIHZlcmJvc2U/OiBib29sZWFuXG4gICAgc2V0dGluZ3M/OiBib29sZWFuXG4gICAgYnVmZmVycz86IGJvb2xlYW5cbiAgICB3YWw/OiBib29sZWFuXG4gICAgZm9ybWF0PzogJ2pzb24nIHwgJ3RleHQnXG4gIH0gPSB7fSk6IFBvc3RncmVzdEJ1aWxkZXI8UmVjb3JkPHN0cmluZywgdW5rbm93bj5bXT4gfCBQb3N0Z3Jlc3RCdWlsZGVyPHN0cmluZz4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBbXG4gICAgICBhbmFseXplID8gJ2FuYWx5emUnIDogbnVsbCxcbiAgICAgIHZlcmJvc2UgPyAndmVyYm9zZScgOiBudWxsLFxuICAgICAgc2V0dGluZ3MgPyAnc2V0dGluZ3MnIDogbnVsbCxcbiAgICAgIGJ1ZmZlcnMgPyAnYnVmZmVycycgOiBudWxsLFxuICAgICAgd2FsID8gJ3dhbCcgOiBudWxsLFxuICAgIF1cbiAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgIC5qb2luKCd8JylcbiAgICAvLyBBbiBBY2NlcHQgaGVhZGVyIGNhbiBjYXJyeSBtdWx0aXBsZSBtZWRpYSB0eXBlcyBidXQgcG9zdGdyZXN0LWpzIGFsd2F5cyBzZW5kcyBvbmVcbiAgICBjb25zdCBmb3JNZWRpYXR5cGUgPSB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID8/ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgIHRoaXMuaGVhZGVyc1tcbiAgICAgICdBY2NlcHQnXG4gICAgXSA9IGBhcHBsaWNhdGlvbi92bmQucGdyc3QucGxhbiske2Zvcm1hdH07IGZvcj1cIiR7Zm9yTWVkaWF0eXBlfVwiOyBvcHRpb25zPSR7b3B0aW9uc307YFxuICAgIGlmIChmb3JtYXQgPT09ICdqc29uJykgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPFJlY29yZDxzdHJpbmcsIHVua25vd24+W10+XG4gICAgZWxzZSByZXR1cm4gdGhpcyBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8c3RyaW5nPlxuICB9XG5cbiAgLyoqXG4gICAqIFJvbGxiYWNrIHRoZSBxdWVyeS5cbiAgICpcbiAgICogYGRhdGFgIHdpbGwgc3RpbGwgYmUgcmV0dXJuZWQsIGJ1dCB0aGUgcXVlcnkgaXMgbm90IGNvbW1pdHRlZC5cbiAgICovXG4gIHJvbGxiYWNrKCk6IHRoaXMge1xuICAgIGlmICgodGhpcy5oZWFkZXJzWydQcmVmZXInXSA/PyAnJykudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gKz0gJyx0eD1yb2xsYmFjaydcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9ICd0eD1yb2xsYmFjaydcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgdHlwZSBvZiB0aGUgcmV0dXJuZWQgYGRhdGFgLlxuICAgKlxuICAgKiBAdHlwZVBhcmFtIE5ld1Jlc3VsdCAtIFRoZSBuZXcgcmVzdWx0IHR5cGUgdG8gb3ZlcnJpZGUgd2l0aFxuICAgKi9cbiAgcmV0dXJuczxOZXdSZXN1bHQ+KCk6IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXI8XG4gICAgU2NoZW1hLFxuICAgIFJvdyxcbiAgICBOZXdSZXN1bHQsXG4gICAgUmVsYXRpb25OYW1lLFxuICAgIFJlbGF0aW9uc2hpcHNcbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyPFxuICAgICAgU2NoZW1hLFxuICAgICAgUm93LFxuICAgICAgTmV3UmVzdWx0LFxuICAgICAgUmVsYXRpb25OYW1lLFxuICAgICAgUmVsYXRpb25zaGlwc1xuICAgID5cbiAgfVxufVxuIiwgImltcG9ydCBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyIGZyb20gJy4vUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcidcbmltcG9ydCB7IEdlbmVyaWNTY2hlbWEgfSBmcm9tICcuL3R5cGVzJ1xuXG50eXBlIEZpbHRlck9wZXJhdG9yID1cbiAgfCAnZXEnXG4gIHwgJ25lcSdcbiAgfCAnZ3QnXG4gIHwgJ2d0ZSdcbiAgfCAnbHQnXG4gIHwgJ2x0ZSdcbiAgfCAnbGlrZSdcbiAgfCAnaWxpa2UnXG4gIHwgJ2lzJ1xuICB8ICdpbidcbiAgfCAnY3MnXG4gIHwgJ2NkJ1xuICB8ICdzbCdcbiAgfCAnc3InXG4gIHwgJ254bCdcbiAgfCAnbnhyJ1xuICB8ICdhZGonXG4gIHwgJ292J1xuICB8ICdmdHMnXG4gIHwgJ3BsZnRzJ1xuICB8ICdwaGZ0cydcbiAgfCAnd2Z0cydcblxuLy8gTWF0Y2ggcmVsYXRpb25zaGlwIGZpbHRlcnMgd2l0aCBgdGFibGUuY29sdW1uYCBzeW50YXggYW5kIHJlc29sdmUgdW5kZXJseWluZ1xuLy8gY29sdW1uIHZhbHVlLiBJZiBub3QgbWF0Y2hlZCwgZmFsbGJhY2sgdG8gZ2VuZXJpYyB0eXBlLlxuLy8gVE9ETzogVmFsaWRhdGUgdGhlIHJlbGF0aW9uc2hpcCBpdHNlbGYgYWxhIHNlbGVjdC1xdWVyeS1wYXJzZXIuIEN1cnJlbnRseSB3ZVxuLy8gYXNzdW1lIHRoYXQgYWxsIHRhYmxlcyBoYXZlIHZhbGlkIHJlbGF0aW9uc2hpcHMgdG8gZWFjaCBvdGhlciwgZGVzcGl0ZVxuLy8gbm9uZXhpc3RlbnQgZm9yZWlnbiBrZXlzLlxudHlwZSBSZXNvbHZlRmlsdGVyVmFsdWU8XG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEsXG4gIFJvdyBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nXG4+ID0gQ29sdW1uTmFtZSBleHRlbmRzIGAke2luZmVyIFJlbGF0aW9uc2hpcFRhYmxlfS4ke2luZmVyIFJlbWFpbmRlcn1gXG4gID8gUmVtYWluZGVyIGV4dGVuZHMgYCR7aW5mZXIgX30uJHtpbmZlciBffWBcbiAgICA/IFJlc29sdmVGaWx0ZXJWYWx1ZTxTY2hlbWEsIFJvdywgUmVtYWluZGVyPlxuICAgIDogUmVzb2x2ZUZpbHRlclJlbGF0aW9uc2hpcFZhbHVlPFNjaGVtYSwgUmVsYXRpb25zaGlwVGFibGUsIFJlbWFpbmRlcj5cbiAgOiBDb2x1bW5OYW1lIGV4dGVuZHMga2V5b2YgUm93XG4gID8gUm93W0NvbHVtbk5hbWVdXG4gIDogbmV2ZXJcblxudHlwZSBSZXNvbHZlRmlsdGVyUmVsYXRpb25zaGlwVmFsdWU8XG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEsXG4gIFJlbGF0aW9uc2hpcFRhYmxlIGV4dGVuZHMgc3RyaW5nLFxuICBSZWxhdGlvbnNoaXBDb2x1bW4gZXh0ZW5kcyBzdHJpbmdcbj4gPSBTY2hlbWFbJ1RhYmxlcyddICYgU2NoZW1hWydWaWV3cyddIGV4dGVuZHMgaW5mZXIgVGFibGVzQW5kVmlld3NcbiAgPyBSZWxhdGlvbnNoaXBUYWJsZSBleHRlbmRzIGtleW9mIFRhYmxlc0FuZFZpZXdzXG4gICAgPyAnUm93JyBleHRlbmRzIGtleW9mIFRhYmxlc0FuZFZpZXdzW1JlbGF0aW9uc2hpcFRhYmxlXVxuICAgICAgPyBSZWxhdGlvbnNoaXBDb2x1bW4gZXh0ZW5kcyBrZXlvZiBUYWJsZXNBbmRWaWV3c1tSZWxhdGlvbnNoaXBUYWJsZV1bJ1JvdyddXG4gICAgICAgID8gVGFibGVzQW5kVmlld3NbUmVsYXRpb25zaGlwVGFibGVdWydSb3cnXVtSZWxhdGlvbnNoaXBDb2x1bW5dXG4gICAgICAgIDogdW5rbm93blxuICAgICAgOiB1bmtub3duXG4gICAgOiB1bmtub3duXG4gIDogbmV2ZXJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxcbiAgU2NoZW1hIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSxcbiAgUm93IGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIFJlc3VsdCxcbiAgUmVsYXRpb25OYW1lID0gdW5rbm93bixcbiAgUmVsYXRpb25zaGlwcyA9IHVua25vd25cbj4gZXh0ZW5kcyBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyPFNjaGVtYSwgUm93LCBSZXN1bHQsIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcz4ge1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIFRvIGNoZWNrIGlmIHRoZSB2YWx1ZSBvZiBgY29sdW1uYCBpcyBOVUxMLCB5b3Ugc2hvdWxkIHVzZSBgLmlzKClgIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGVxPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmc+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZTogUmVzb2x2ZUZpbHRlclZhbHVlPFNjaGVtYSwgUm93LCBDb2x1bW5OYW1lPiBleHRlbmRzIG5ldmVyXG4gICAgICA/IE5vbk51bGxhYmxlPHVua25vd24+XG4gICAgICA6IE5vbk51bGxhYmxlPFJlc29sdmVGaWx0ZXJWYWx1ZTxTY2hlbWEsIFJvdywgQ29sdW1uTmFtZT4+XG4gICk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZXEuJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIG5vdCBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBuZXE8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHZhbHVlOiBSZXNvbHZlRmlsdGVyVmFsdWU8U2NoZW1hLCBSb3csIENvbHVtbk5hbWU+IGV4dGVuZHMgbmV2ZXJcbiAgICAgID8gdW5rbm93blxuICAgICAgOiBSZXNvbHZlRmlsdGVyVmFsdWU8U2NoZW1hLCBSb3csIENvbHVtbk5hbWU+XG4gICk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbmVxLiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ3Q8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCB2YWx1ZTogUm93W0NvbHVtbk5hbWVdKTogdGhpc1xuICBndChjb2x1bW46IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGd0KGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZ3QuJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBndGU8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCB2YWx1ZTogUm93W0NvbHVtbk5hbWVdKTogdGhpc1xuICBndGUoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBndGUoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBndGUuJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsdDxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHZhbHVlOiBSb3dbQ29sdW1uTmFtZV0pOiB0aGlzXG4gIGx0KGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBsZXNzIHRoYW4gYHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgbHQoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsdC4ke3ZhbHVlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGx0ZTxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHZhbHVlOiBSb3dbQ29sdW1uTmFtZV0pOiB0aGlzXG4gIGx0ZShjb2x1bW46IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGx0ZShjb2x1bW46IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGx0ZS4ke3ZhbHVlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGxpa2U8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCBwYXR0ZXJuOiBzdHJpbmcpOiB0aGlzXG4gIGxpa2UoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm46IHN0cmluZyk6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGBwYXR0ZXJuYCBjYXNlLXNlbnNpdGl2ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHBhdHRlcm4gLSBUaGUgcGF0dGVybiB0byBtYXRjaCB3aXRoXG4gICAqL1xuICBsaWtlKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGxpa2UuJHtwYXR0ZXJufWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGxpa2VBbGxPZjxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdXG4gICk6IHRoaXNcbiAgbGlrZUFsbE9mKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW10pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbGwgb2YgYHBhdHRlcm5zYCBjYXNlLXNlbnNpdGl2ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcbiAgICovXG4gIGxpa2VBbGxPZihjb2x1bW46IHN0cmluZywgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsaWtlKGFsbCkueyR7cGF0dGVybnMuam9pbignLCcpfX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsaWtlQW55T2Y8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXVxuICApOiB0aGlzXG4gIGxpa2VBbnlPZihjb2x1bW46IHN0cmluZywgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYW55IG9mIGBwYXR0ZXJuc2AgY2FzZS1zZW5zaXRpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG4gICAqL1xuICBsaWtlQW55T2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZShhbnkpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaWxpa2U8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCBwYXR0ZXJuOiBzdHJpbmcpOiB0aGlzXG4gIGlsaWtlKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuOiBzdHJpbmcpOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBgcGF0dGVybmAgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHBhdHRlcm4gLSBUaGUgcGF0dGVybiB0byBtYXRjaCB3aXRoXG4gICAqL1xuICBpbGlrZShjb2x1bW46IHN0cmluZywgcGF0dGVybjogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbGlrZS4ke3BhdHRlcm59YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaWxpa2VBbGxPZjxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdXG4gICk6IHRoaXNcbiAgaWxpa2VBbGxPZihjb2x1bW46IHN0cmluZywgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYWxsIG9mIGBwYXR0ZXJuc2AgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcbiAgICovXG4gIGlsaWtlQWxsT2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UoYWxsKS57JHtwYXR0ZXJucy5qb2luKCcsJyl9fWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlsaWtlQW55T2Y8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXVxuICApOiB0aGlzXG4gIGlsaWtlQW55T2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFueSBvZiBgcGF0dGVybnNgIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG4gICAqL1xuICBpbGlrZUFueU9mKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW10pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlsaWtlKGFueSkueyR7cGF0dGVybnMuam9pbignLCcpfX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBpczxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgdmFsdWU6IFJvd1tDb2x1bW5OYW1lXSAmIChib29sZWFuIHwgbnVsbClcbiAgKTogdGhpc1xuICBpcyhjb2x1bW46IHN0cmluZywgdmFsdWU6IGJvb2xlYW4gfCBudWxsKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIElTIGB2YWx1ZWAuXG4gICAqXG4gICAqIEZvciBub24tYm9vbGVhbiBjb2x1bW5zLCB0aGlzIGlzIG9ubHkgcmVsZXZhbnQgZm9yIGNoZWNraW5nIGlmIHRoZSB2YWx1ZSBvZlxuICAgKiBgY29sdW1uYCBpcyBOVUxMIGJ5IHNldHRpbmcgYHZhbHVlYCB0byBgbnVsbGAuXG4gICAqXG4gICAqIEZvciBib29sZWFuIGNvbHVtbnMsIHlvdSBjYW4gYWxzbyBzZXQgYHZhbHVlYCB0byBgdHJ1ZWAgb3IgYGZhbHNlYCBhbmQgaXRcbiAgICogd2lsbCBiZWhhdmUgdGhlIHNhbWUgd2F5IGFzIGAuZXEoKWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGlzKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogYm9vbGVhbiB8IG51bGwpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlzLiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBpbmNsdWRlZCBpbiB0aGUgYHZhbHVlc2AgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyBhcnJheSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgaW48Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHZhbHVlczogUmVzb2x2ZUZpbHRlclZhbHVlPFNjaGVtYSwgUm93LCBDb2x1bW5OYW1lPiBleHRlbmRzIG5ldmVyXG4gICAgICA/IHVua25vd25bXVxuICAgICAgOiBSZWFkb25seUFycmF5PFJlc29sdmVGaWx0ZXJWYWx1ZTxTY2hlbWEsIFJvdywgQ29sdW1uTmFtZT4+XG4gICk6IHRoaXMge1xuICAgIGNvbnN0IGNsZWFuZWRWYWx1ZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodmFsdWVzKSlcbiAgICAgIC5tYXAoKHMpID0+IHtcbiAgICAgICAgLy8gaGFuZGxlIHBvc3RncmVzdCByZXNlcnZlZCBjaGFyYWN0ZXJzXG4gICAgICAgIC8vIGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi92Ny4wLjAvYXBpLmh0bWwjcmVzZXJ2ZWQtY2hhcmFjdGVyc1xuICAgICAgICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnICYmIG5ldyBSZWdFeHAoJ1ssKCldJykudGVzdChzKSkgcmV0dXJuIGBcIiR7c31cImBcbiAgICAgICAgZWxzZSByZXR1cm4gYCR7c31gXG4gICAgICB9KVxuICAgICAgLmpvaW4oJywnKVxuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaW4uKCR7Y2xlYW5lZFZhbHVlc30pYClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgY29udGFpbnM8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBSZWFkb25seUFycmF5PFJvd1tDb2x1bW5OYW1lXT4gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICApOiB0aGlzXG4gIGNvbnRhaW5zKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgcmVhZG9ubHkgdW5rbm93bltdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB0aGlzXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGZvciBqc29uYiwgYXJyYXksIGFuZCByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcbiAgICogYGNvbHVtbmAgY29udGFpbnMgZXZlcnkgZWxlbWVudCBhcHBlYXJpbmcgaW4gYHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGNvbnRhaW5zKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgcmVhZG9ubHkgdW5rbm93bltdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB0aGlzIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gcmFuZ2UgdHlwZXMgY2FuIGJlIGluY2x1c2l2ZSAnWycsICddJyBvciBleGNsdXNpdmUgJygnLCAnKScgc28ganVzdFxuICAgICAgLy8ga2VlcCBpdCBzaW1wbGUgYW5kIGFjY2VwdCBhIHN0cmluZ1xuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjcy4ke3ZhbHVlfWApXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgLy8gYXJyYXlcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MueyR7dmFsdWUuam9pbignLCcpfX1gKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBqc29uXG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNzLiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjb250YWluZWRCeTxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgdmFsdWU6IHN0cmluZyB8IFJlYWRvbmx5QXJyYXk8Um93W0NvbHVtbk5hbWVdPiB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gICk6IHRoaXNcbiAgY29udGFpbmVkQnkoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCByZWFkb25seSB1bmtub3duW10gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHRoaXNcbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgZm9yIGpzb25iLCBhcnJheSwgYW5kIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuICAgKiBldmVyeSBlbGVtZW50IGFwcGVhcmluZyBpbiBgY29sdW1uYCBpcyBjb250YWluZWQgYnkgYHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGNvbnRhaW5lZEJ5KGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgcmVhZG9ubHkgdW5rbm93bltdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB0aGlzIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gcmFuZ2VcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY2QuJHt2YWx1ZX1gKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIC8vIGFycmF5XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLnske3ZhbHVlLmpvaW4oJywnKX19YClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganNvblxuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjZC4ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmFuZ2VHdDxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIHJhbmdlR3QoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuICAgKiBgY29sdW1uYCBpcyBncmVhdGVyIHRoYW4gYW55IGVsZW1lbnQgaW4gYHJhbmdlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgcmFuZ2VHdChjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgc3IuJHtyYW5nZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByYW5nZUd0ZTxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIHJhbmdlR3RlKGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICogYGNvbHVtbmAgaXMgZWl0aGVyIGNvbnRhaW5lZCBpbiBgcmFuZ2VgIG9yIGdyZWF0ZXIgdGhhbiBhbnkgZWxlbWVudCBpblxuICAgKiBgcmFuZ2VgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICByYW5nZUd0ZShjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbnhsLiR7cmFuZ2V9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmFuZ2VMdDxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIHJhbmdlTHQoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuICAgKiBgY29sdW1uYCBpcyBsZXNzIHRoYW4gYW55IGVsZW1lbnQgaW4gYHJhbmdlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgcmFuZ2VMdChjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgc2wuJHtyYW5nZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByYW5nZUx0ZTxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIHJhbmdlTHRlKGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICogYGNvbHVtbmAgaXMgZWl0aGVyIGNvbnRhaW5lZCBpbiBgcmFuZ2VgIG9yIGxlc3MgdGhhbiBhbnkgZWxlbWVudCBpblxuICAgKiBgcmFuZ2VgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICByYW5nZUx0ZShjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbnhyLiR7cmFuZ2V9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmFuZ2VBZGphY2VudDxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93Pihjb2x1bW46IENvbHVtbk5hbWUsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIHJhbmdlQWRqYWNlbnQoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXNcbiAgICogbXV0dWFsbHkgZXhjbHVzaXZlIHRvIGByYW5nZWAgYW5kIHRoZXJlIGNhbiBiZSBubyBlbGVtZW50IGJldHdlZW4gdGhlIHR3b1xuICAgKiByYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIHJhbmdlQWRqYWNlbnQoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGFkai4ke3JhbmdlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG92ZXJsYXBzPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZTogc3RyaW5nIHwgUmVhZG9ubHlBcnJheTxSb3dbQ29sdW1uTmFtZV0+XG4gICk6IHRoaXNcbiAgb3ZlcmxhcHMoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCByZWFkb25seSB1bmtub3duW10pOiB0aGlzXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGZvciBhcnJheSBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAqIGBjb2x1bW5gIGFuZCBgdmFsdWVgIGhhdmUgYW4gZWxlbWVudCBpbiBjb21tb24uXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgYXJyYXkgb3IgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgYXJyYXkgb3IgcmFuZ2UgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIG92ZXJsYXBzKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgcmVhZG9ubHkgdW5rbm93bltdKTogdGhpcyB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIHJhbmdlXG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG92LiR7dmFsdWV9YClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXJyYXlcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgb3YueyR7dmFsdWUuam9pbignLCcpfX1gKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdGV4dFNlYXJjaDxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgcXVlcnk6IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyBjb25maWc/OiBzdHJpbmc7IHR5cGU/OiAncGxhaW4nIHwgJ3BocmFzZScgfCAnd2Vic2VhcmNoJyB9XG4gICk6IHRoaXNcbiAgdGV4dFNlYXJjaChcbiAgICBjb2x1bW46IHN0cmluZyxcbiAgICBxdWVyeTogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IGNvbmZpZz86IHN0cmluZzsgdHlwZT86ICdwbGFpbicgfCAncGhyYXNlJyB8ICd3ZWJzZWFyY2gnIH1cbiAgKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgdGV4dCBhbmQgdHN2ZWN0b3IgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAqIGBjb2x1bW5gIG1hdGNoZXMgdGhlIHF1ZXJ5IHN0cmluZyBpbiBgcXVlcnlgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHRleHQgb3IgdHN2ZWN0b3IgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkgdGV4dCB0byBtYXRjaCB3aXRoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5jb25maWcgLSBUaGUgdGV4dCBzZWFyY2ggY29uZmlndXJhdGlvbiB0byB1c2VcbiAgICogQHBhcmFtIG9wdGlvbnMudHlwZSAtIENoYW5nZSBob3cgdGhlIGBxdWVyeWAgdGV4dCBpcyBpbnRlcnByZXRlZFxuICAgKi9cbiAgdGV4dFNlYXJjaChcbiAgICBjb2x1bW46IHN0cmluZyxcbiAgICBxdWVyeTogc3RyaW5nLFxuICAgIHsgY29uZmlnLCB0eXBlIH06IHsgY29uZmlnPzogc3RyaW5nOyB0eXBlPzogJ3BsYWluJyB8ICdwaHJhc2UnIHwgJ3dlYnNlYXJjaCcgfSA9IHt9XG4gICk6IHRoaXMge1xuICAgIGxldCB0eXBlUGFydCA9ICcnXG4gICAgaWYgKHR5cGUgPT09ICdwbGFpbicpIHtcbiAgICAgIHR5cGVQYXJ0ID0gJ3BsJ1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3BocmFzZScpIHtcbiAgICAgIHR5cGVQYXJ0ID0gJ3BoJ1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3dlYnNlYXJjaCcpIHtcbiAgICAgIHR5cGVQYXJ0ID0gJ3cnXG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZ1BhcnQgPSBjb25maWcgPT09IHVuZGVmaW5lZCA/ICcnIDogYCgke2NvbmZpZ30pYFxuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgJHt0eXBlUGFydH1mdHMke2NvbmZpZ1BhcnR9LiR7cXVlcnl9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbWF0Y2g8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4ocXVlcnk6IFJlY29yZDxDb2x1bW5OYW1lLCBSb3dbQ29sdW1uTmFtZV0+KTogdGhpc1xuICBtYXRjaChxdWVyeTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZWFjaCBjb2x1bW4gaW4gYHF1ZXJ5YCBrZXlzIGlzIGVxdWFsIHRvIGl0c1xuICAgKiBhc3NvY2lhdGVkIHZhbHVlLiBTaG9ydGhhbmQgZm9yIG11bHRpcGxlIGAuZXEoKWBzLlxuICAgKlxuICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgb2JqZWN0IHRvIGZpbHRlciB3aXRoLCB3aXRoIGNvbHVtbiBuYW1lcyBhcyBrZXlzIG1hcHBlZFxuICAgKiB0byB0aGVpciBmaWx0ZXIgdmFsdWVzXG4gICAqL1xuICBtYXRjaChxdWVyeTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB0aGlzIHtcbiAgICBPYmplY3QuZW50cmllcyhxdWVyeSkuZm9yRWFjaCgoW2NvbHVtbiwgdmFsdWVdKSA9PiB7XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGVxLiR7dmFsdWV9YClcbiAgICB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBub3Q8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIG9wZXJhdG9yOiBGaWx0ZXJPcGVyYXRvcixcbiAgICB2YWx1ZTogUm93W0NvbHVtbk5hbWVdXG4gICk6IHRoaXNcbiAgbm90KGNvbHVtbjogc3RyaW5nLCBvcGVyYXRvcjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBkb2Vzbid0IHNhdGlzZnkgdGhlIGZpbHRlci5cbiAgICpcbiAgICogVW5saWtlIG1vc3QgZmlsdGVycywgYG9wZWFyYXRvcmAgYW5kIGB2YWx1ZWAgYXJlIHVzZWQgYXMtaXMgYW5kIG5lZWQgdG9cbiAgICogZm9sbG93IFtQb3N0Z1JFU1RcbiAgICogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcbiAgICogdG8gbWFrZSBzdXJlIHRoZXkgYXJlIHByb3Blcmx5IHNhbml0aXplZC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBvcGVyYXRvciAtIFRoZSBvcGVyYXRvciB0byBiZSBuZWdhdGVkIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmdcbiAgICogUG9zdGdSRVNUIHN5bnRheFxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGgsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG4gICAqL1xuICBub3QoY29sdW1uOiBzdHJpbmcsIG9wZXJhdG9yOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBub3QuJHtvcGVyYXRvcn0uJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoaWNoIHNhdGlzZnkgYXQgbGVhc3Qgb25lIG9mIHRoZSBmaWx0ZXJzLlxuICAgKlxuICAgKiBVbmxpa2UgbW9zdCBmaWx0ZXJzLCBgZmlsdGVyc2AgaXMgdXNlZCBhcy1pcyBhbmQgbmVlZHMgdG8gZm9sbG93IFtQb3N0Z1JFU1RcbiAgICogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcbiAgICogdG8gbWFrZSBzdXJlIGl0J3MgcHJvcGVybHkgc2FuaXRpemVkLlxuICAgKlxuICAgKiBJdCdzIGN1cnJlbnRseSBub3QgcG9zc2libGUgdG8gZG8gYW4gYC5vcigpYCBmaWx0ZXIgYWNyb3NzIG11bHRpcGxlIHRhYmxlcy5cbiAgICpcbiAgICogQHBhcmFtIGZpbHRlcnMgLSBUaGUgZmlsdGVycyB0byB1c2UsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBmaWx0ZXIgb24gcmVmZXJlbmNlZCB0YWJsZXNcbiAgICogaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG4gICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgcmVmZXJlbmNlZFRhYmxlYCBpbnN0ZWFkXG4gICAqL1xuICBvcihcbiAgICBmaWx0ZXJzOiBzdHJpbmcsXG4gICAge1xuICAgICAgZm9yZWlnblRhYmxlLFxuICAgICAgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlLFxuICAgIH06IHsgZm9yZWlnblRhYmxlPzogc3RyaW5nOyByZWZlcmVuY2VkVGFibGU/OiBzdHJpbmcgfSA9IHt9XG4gICk6IHRoaXMge1xuICAgIGNvbnN0IGtleSA9IHJlZmVyZW5jZWRUYWJsZSA/IGAke3JlZmVyZW5jZWRUYWJsZX0ub3JgIDogJ29yJ1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBgKCR7ZmlsdGVyc30pYClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZmlsdGVyPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBvcGVyYXRvcjogYCR7JycgfCAnbm90Lid9JHtGaWx0ZXJPcGVyYXRvcn1gLFxuICAgIHZhbHVlOiB1bmtub3duXG4gICk6IHRoaXNcbiAgZmlsdGVyKGNvbHVtbjogc3RyaW5nLCBvcGVyYXRvcjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBzYXRpc2Z5IHRoZSBmaWx0ZXIuIFRoaXMgaXMgYW4gZXNjYXBlIGhhdGNoIC0geW91XG4gICAqIHNob3VsZCB1c2UgdGhlIHNwZWNpZmljIGZpbHRlciBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLlxuICAgKlxuICAgKiBVbmxpa2UgbW9zdCBmaWx0ZXJzLCBgb3BlYXJhdG9yYCBhbmQgYHZhbHVlYCBhcmUgdXNlZCBhcy1pcyBhbmQgbmVlZCB0b1xuICAgKiBmb2xsb3cgW1Bvc3RnUkVTVFxuICAgKiBzeW50YXhdKGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjb3BlcmF0b3JzKS4gWW91IGFsc28gbmVlZFxuICAgKiB0byBtYWtlIHN1cmUgdGhleSBhcmUgcHJvcGVybHkgc2FuaXRpemVkLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIG9wZXJhdG9yIC0gVGhlIG9wZXJhdG9yIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGgsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG4gICAqL1xuICBmaWx0ZXIoY29sdW1uOiBzdHJpbmcsIG9wZXJhdG9yOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGAke29wZXJhdG9yfS4ke3ZhbHVlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuIiwgImltcG9ydCBQb3N0Z3Jlc3RCdWlsZGVyIGZyb20gJy4vUG9zdGdyZXN0QnVpbGRlcidcbmltcG9ydCBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyIGZyb20gJy4vUG9zdGdyZXN0RmlsdGVyQnVpbGRlcidcbmltcG9ydCB7IEdldFJlc3VsdCB9IGZyb20gJy4vc2VsZWN0LXF1ZXJ5LXBhcnNlci9yZXN1bHQnXG5pbXBvcnQgeyBGZXRjaCwgR2VuZXJpY1NjaGVtYSwgR2VuZXJpY1RhYmxlLCBHZW5lcmljVmlldyB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjxcbiAgU2NoZW1hIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSxcbiAgUmVsYXRpb24gZXh0ZW5kcyBHZW5lcmljVGFibGUgfCBHZW5lcmljVmlldyxcbiAgUmVsYXRpb25OYW1lID0gdW5rbm93bixcbiAgUmVsYXRpb25zaGlwcyA9IFJlbGF0aW9uIGV4dGVuZHMgeyBSZWxhdGlvbnNoaXBzOiBpbmZlciBSIH0gPyBSIDogdW5rbm93blxuPiB7XG4gIHVybDogVVJMXG4gIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgc2NoZW1hPzogc3RyaW5nXG4gIHNpZ25hbD86IEFib3J0U2lnbmFsXG4gIGZldGNoPzogRmV0Y2hcblxuICBjb25zdHJ1Y3RvcihcbiAgICB1cmw6IFVSTCxcbiAgICB7XG4gICAgICBoZWFkZXJzID0ge30sXG4gICAgICBzY2hlbWEsXG4gICAgICBmZXRjaCxcbiAgICB9OiB7XG4gICAgICBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgICAgc2NoZW1hPzogc3RyaW5nXG4gICAgICBmZXRjaD86IEZldGNoXG4gICAgfVxuICApIHtcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnNcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYVxuICAgIHRoaXMuZmV0Y2ggPSBmZXRjaFxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBTRUxFQ1QgcXVlcnkgb24gdGhlIHRhYmxlIG9yIHZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW5zIC0gVGhlIGNvbHVtbnMgdG8gcmV0cmlldmUsIHNlcGFyYXRlZCBieSBjb21tYXMuIENvbHVtbnMgY2FuIGJlIHJlbmFtZWQgd2hlbiByZXR1cm5lZCB3aXRoIGBjdXN0b21OYW1lOmNvbHVtbk5hbWVgXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG4gICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHJvd3MgaW4gdGhlIHRhYmxlIG9yIHZpZXcuXG4gICAqXG4gICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICogaG9vZC5cbiAgICpcbiAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICpcbiAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgKiBudW1iZXJzLlxuICAgKi9cbiAgc2VsZWN0PFxuICAgIFF1ZXJ5IGV4dGVuZHMgc3RyaW5nID0gJyonLFxuICAgIFJlc3VsdE9uZSA9IEdldFJlc3VsdDxTY2hlbWEsIFJlbGF0aW9uWydSb3cnXSwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzLCBRdWVyeT5cbiAgPihcbiAgICBjb2x1bW5zPzogUXVlcnksXG4gICAge1xuICAgICAgaGVhZCA9IGZhbHNlLFxuICAgICAgY291bnQsXG4gICAgfToge1xuICAgICAgaGVhZD86IGJvb2xlYW5cbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfSA9IHt9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8U2NoZW1hLCBSZWxhdGlvblsnUm93J10sIFJlc3VsdE9uZVtdLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+IHtcbiAgICBjb25zdCBtZXRob2QgPSBoZWFkID8gJ0hFQUQnIDogJ0dFVCdcbiAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZXMgZXhjZXB0IHdoZW4gcXVvdGVkXG4gICAgbGV0IHF1b3RlZCA9IGZhbHNlXG4gICAgY29uc3QgY2xlYW5lZENvbHVtbnMgPSAoY29sdW1ucyA/PyAnKicpXG4gICAgICAuc3BsaXQoJycpXG4gICAgICAubWFwKChjKSA9PiB7XG4gICAgICAgIGlmICgvXFxzLy50ZXN0KGMpICYmICFxdW90ZWQpIHtcbiAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICAgIHF1b3RlZCA9ICFxdW90ZWRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY1xuICAgICAgfSlcbiAgICAgIC5qb2luKCcnKVxuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3NlbGVjdCcsIGNsZWFuZWRDb2x1bW5zKVxuICAgIGlmIChjb3VudCkge1xuICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9IGBjb3VudD0ke2NvdW50fWBcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuICAgICAgbWV0aG9kLFxuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgIGFsbG93RW1wdHk6IGZhbHNlLFxuICAgIH0gYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdE9uZVtdPilcbiAgfVxuXG4gIC8vIFRPRE8odjMpOiBNYWtlIGBkZWZhdWx0VG9OdWxsYCBjb25zaXN0ZW50IGZvciBib3RoIHNpbmdsZSAmIGJ1bGsgaW5zZXJ0cy5cbiAgaW5zZXJ0PFJvdyBleHRlbmRzIFJlbGF0aW9uIGV4dGVuZHMgeyBJbnNlcnQ6IHVua25vd24gfSA/IFJlbGF0aW9uWydJbnNlcnQnXSA6IG5ldmVyPihcbiAgICB2YWx1ZXM6IFJvdyxcbiAgICBvcHRpb25zPzoge1xuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICB9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8U2NoZW1hLCBSZWxhdGlvblsnUm93J10sIG51bGwsIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcz5cbiAgaW5zZXJ0PFJvdyBleHRlbmRzIFJlbGF0aW9uIGV4dGVuZHMgeyBJbnNlcnQ6IHVua25vd24gfSA/IFJlbGF0aW9uWydJbnNlcnQnXSA6IG5ldmVyPihcbiAgICB2YWx1ZXM6IFJvd1tdLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICBjb3VudD86ICdleGFjdCcgfCAncGxhbm5lZCcgfCAnZXN0aW1hdGVkJ1xuICAgICAgZGVmYXVsdFRvTnVsbD86IGJvb2xlYW5cbiAgICB9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8U2NoZW1hLCBSZWxhdGlvblsnUm93J10sIG51bGwsIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcz5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYW4gSU5TRVJUIGludG8gdGhlIHRhYmxlIG9yIHZpZXcuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGluc2VydGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuICAgKiB3aXRoIGAuc2VsZWN0KClgLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBpbnNlcnQuIFBhc3MgYW4gb2JqZWN0IHRvIGluc2VydCBhIHNpbmdsZSByb3dcbiAgICogb3IgYW4gYXJyYXkgdG8gaW5zZXJ0IG11bHRpcGxlIHJvd3MuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgaW5zZXJ0ZWQgcm93cy5cbiAgICpcbiAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgKiBob29kLlxuICAgKlxuICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgKlxuICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAqIG51bWJlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmRlZmF1bHRUb051bGwgLSBNYWtlIG1pc3NpbmcgZmllbGRzIGRlZmF1bHQgdG8gYG51bGxgLlxuICAgKiBPdGhlcndpc2UsIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbHVtbi4gT25seSBhcHBsaWVzIGZvciBidWxrXG4gICAqIGluc2VydHMuXG4gICAqL1xuICBpbnNlcnQ8Um93IGV4dGVuZHMgUmVsYXRpb24gZXh0ZW5kcyB7IEluc2VydDogdW5rbm93biB9ID8gUmVsYXRpb25bJ0luc2VydCddIDogbmV2ZXI+KFxuICAgIHZhbHVlczogUm93IHwgUm93W10sXG4gICAge1xuICAgICAgY291bnQsXG4gICAgICBkZWZhdWx0VG9OdWxsID0gdHJ1ZSxcbiAgICB9OiB7XG4gICAgICBjb3VudD86ICdleGFjdCcgfCAncGxhbm5lZCcgfCAnZXN0aW1hdGVkJ1xuICAgICAgZGVmYXVsdFRvTnVsbD86IGJvb2xlYW5cbiAgICB9ID0ge31cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxTY2hlbWEsIFJlbGF0aW9uWydSb3cnXSwgbnVsbCwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnXG5cbiAgICBjb25zdCBwcmVmZXJzSGVhZGVycyA9IFtdXG4gICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2godGhpcy5oZWFkZXJzWydQcmVmZXInXSlcbiAgICB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApXG4gICAgfVxuICAgIGlmICghZGVmYXVsdFRvTnVsbCkge1xuICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaCgnbWlzc2luZz1kZWZhdWx0JylcbiAgICB9XG4gICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9IHByZWZlcnNIZWFkZXJzLmpvaW4oJywnKVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgY29uc3QgY29sdW1ucyA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjLmNvbmNhdChPYmplY3Qua2V5cyh4KSksIFtdIGFzIHN0cmluZ1tdKVxuICAgICAgaWYgKGNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB1bmlxdWVDb2x1bW5zID0gWy4uLm5ldyBTZXQoY29sdW1ucyldLm1hcCgoY29sdW1uKSA9PiBgXCIke2NvbHVtbn1cImApXG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NvbHVtbnMnLCB1bmlxdWVDb2x1bW5zLmpvaW4oJywnKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuICAgICAgbWV0aG9kLFxuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICBib2R5OiB2YWx1ZXMsXG4gICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgIGFsbG93RW1wdHk6IGZhbHNlLFxuICAgIH0gYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPG51bGw+KVxuICB9XG5cbiAgLy8gVE9ETyh2Myk6IE1ha2UgYGRlZmF1bHRUb051bGxgIGNvbnNpc3RlbnQgZm9yIGJvdGggc2luZ2xlICYgYnVsayB1cHNlcnRzLlxuICB1cHNlcnQ8Um93IGV4dGVuZHMgUmVsYXRpb24gZXh0ZW5kcyB7IEluc2VydDogdW5rbm93biB9ID8gUmVsYXRpb25bJ0luc2VydCddIDogbmV2ZXI+KFxuICAgIHZhbHVlczogUm93LFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICBvbkNvbmZsaWN0Pzogc3RyaW5nXG4gICAgICBpZ25vcmVEdXBsaWNhdGVzPzogYm9vbGVhblxuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICB9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8U2NoZW1hLCBSZWxhdGlvblsnUm93J10sIG51bGwsIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcz5cbiAgdXBzZXJ0PFJvdyBleHRlbmRzIFJlbGF0aW9uIGV4dGVuZHMgeyBJbnNlcnQ6IHVua25vd24gfSA/IFJlbGF0aW9uWydJbnNlcnQnXSA6IG5ldmVyPihcbiAgICB2YWx1ZXM6IFJvd1tdLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICBvbkNvbmZsaWN0Pzogc3RyaW5nXG4gICAgICBpZ25vcmVEdXBsaWNhdGVzPzogYm9vbGVhblxuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICAgIGRlZmF1bHRUb051bGw/OiBib29sZWFuXG4gICAgfVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBudWxsLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+XG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIFVQU0VSVCBvbiB0aGUgdGFibGUgb3Igdmlldy4gRGVwZW5kaW5nIG9uIHRoZSBjb2x1bW4ocykgcGFzc2VkXG4gICAqIHRvIGBvbkNvbmZsaWN0YCwgYC51cHNlcnQoKWAgYWxsb3dzIHlvdSB0byBwZXJmb3JtIHRoZSBlcXVpdmFsZW50IG9mXG4gICAqIGAuaW5zZXJ0KClgIGlmIGEgcm93IHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgYG9uQ29uZmxpY3RgIGNvbHVtbnMgZG9lc24ndFxuICAgKiBleGlzdCwgb3IgaWYgaXQgZG9lcyBleGlzdCwgcGVyZm9ybSBhbiBhbHRlcm5hdGl2ZSBhY3Rpb24gZGVwZW5kaW5nIG9uXG4gICAqIGBpZ25vcmVEdXBsaWNhdGVzYC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdXBzZXJ0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAqIHdpdGggYC5zZWxlY3QoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIHVwc2VydCB3aXRoLiBQYXNzIGFuIG9iamVjdCB0byB1cHNlcnQgYVxuICAgKiBzaW5nbGUgcm93IG9yIGFuIGFycmF5IHRvIHVwc2VydCBtdWx0aXBsZSByb3dzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMub25Db25mbGljdCAtIENvbW1hLXNlcGFyYXRlZCBVTklRVUUgY29sdW1uKHMpIHRvIHNwZWNpZnkgaG93XG4gICAqIGR1cGxpY2F0ZSByb3dzIGFyZSBkZXRlcm1pbmVkLiBUd28gcm93cyBhcmUgZHVwbGljYXRlcyBpZiBhbGwgdGhlXG4gICAqIGBvbkNvbmZsaWN0YCBjb2x1bW5zIGFyZSBlcXVhbC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyAtIElmIGB0cnVlYCwgZHVwbGljYXRlIHJvd3MgYXJlIGlnbm9yZWQuIElmXG4gICAqIGBmYWxzZWAsIGR1cGxpY2F0ZSByb3dzIGFyZSBtZXJnZWQgd2l0aCBleGlzdGluZyByb3dzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgdXBzZXJ0ZWQgcm93cy5cbiAgICpcbiAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgKiBob29kLlxuICAgKlxuICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgKlxuICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAqIG51bWJlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmRlZmF1bHRUb051bGwgLSBNYWtlIG1pc3NpbmcgZmllbGRzIGRlZmF1bHQgdG8gYG51bGxgLlxuICAgKiBPdGhlcndpc2UsIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbHVtbi4gVGhpcyBvbmx5IGFwcGxpZXMgd2hlblxuICAgKiBpbnNlcnRpbmcgbmV3IHJvd3MsIG5vdCB3aGVuIG1lcmdpbmcgd2l0aCBleGlzdGluZyByb3dzIHVuZGVyXG4gICAqIGBpZ25vcmVEdXBsaWNhdGVzOiBmYWxzZWAuIFRoaXMgYWxzbyBvbmx5IGFwcGxpZXMgd2hlbiBkb2luZyBidWxrIHVwc2VydHMuXG4gICAqL1xuICB1cHNlcnQ8Um93IGV4dGVuZHMgUmVsYXRpb24gZXh0ZW5kcyB7IEluc2VydDogdW5rbm93biB9ID8gUmVsYXRpb25bJ0luc2VydCddIDogbmV2ZXI+KFxuICAgIHZhbHVlczogUm93IHwgUm93W10sXG4gICAge1xuICAgICAgb25Db25mbGljdCxcbiAgICAgIGlnbm9yZUR1cGxpY2F0ZXMgPSBmYWxzZSxcbiAgICAgIGNvdW50LFxuICAgICAgZGVmYXVsdFRvTnVsbCA9IHRydWUsXG4gICAgfToge1xuICAgICAgb25Db25mbGljdD86IHN0cmluZ1xuICAgICAgaWdub3JlRHVwbGljYXRlcz86IGJvb2xlYW5cbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgICBkZWZhdWx0VG9OdWxsPzogYm9vbGVhblxuICAgIH0gPSB7fVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBudWxsLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+IHtcbiAgICBjb25zdCBtZXRob2QgPSAnUE9TVCdcblxuICAgIGNvbnN0IHByZWZlcnNIZWFkZXJzID0gW2ByZXNvbHV0aW9uPSR7aWdub3JlRHVwbGljYXRlcyA/ICdpZ25vcmUnIDogJ21lcmdlJ30tZHVwbGljYXRlc2BdXG5cbiAgICBpZiAob25Db25mbGljdCAhPT0gdW5kZWZpbmVkKSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdvbl9jb25mbGljdCcsIG9uQ29uZmxpY3QpXG4gICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2godGhpcy5oZWFkZXJzWydQcmVmZXInXSlcbiAgICB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApXG4gICAgfVxuICAgIGlmICghZGVmYXVsdFRvTnVsbCkge1xuICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaCgnbWlzc2luZz1kZWZhdWx0JylcbiAgICB9XG4gICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9IHByZWZlcnNIZWFkZXJzLmpvaW4oJywnKVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgY29uc3QgY29sdW1ucyA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjLmNvbmNhdChPYmplY3Qua2V5cyh4KSksIFtdIGFzIHN0cmluZ1tdKVxuICAgICAgaWYgKGNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB1bmlxdWVDb2x1bW5zID0gWy4uLm5ldyBTZXQoY29sdW1ucyldLm1hcCgoY29sdW1uKSA9PiBgXCIke2NvbHVtbn1cImApXG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NvbHVtbnMnLCB1bmlxdWVDb2x1bW5zLmpvaW4oJywnKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuICAgICAgbWV0aG9kLFxuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICBib2R5OiB2YWx1ZXMsXG4gICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgIGFsbG93RW1wdHk6IGZhbHNlLFxuICAgIH0gYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPG51bGw+KVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYW4gVVBEQVRFIG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB1cGRhdGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuICAgKiB3aXRoIGAuc2VsZWN0KClgIGFmdGVyIGZpbHRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIHVwZGF0ZSB3aXRoXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgdXBkYXRlZCByb3dzLlxuICAgKlxuICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAqIGhvb2QuXG4gICAqXG4gICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAqXG4gICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICogbnVtYmVycy5cbiAgICovXG4gIHVwZGF0ZTxSb3cgZXh0ZW5kcyBSZWxhdGlvbiBleHRlbmRzIHsgVXBkYXRlOiB1bmtub3duIH0gPyBSZWxhdGlvblsnVXBkYXRlJ10gOiBuZXZlcj4oXG4gICAgdmFsdWVzOiBSb3csXG4gICAge1xuICAgICAgY291bnQsXG4gICAgfToge1xuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICB9ID0ge31cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxTY2hlbWEsIFJlbGF0aW9uWydSb3cnXSwgbnVsbCwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgY29uc3QgbWV0aG9kID0gJ1BBVENIJ1xuICAgIGNvbnN0IHByZWZlcnNIZWFkZXJzID0gW11cbiAgICBpZiAodGhpcy5oZWFkZXJzWydQcmVmZXInXSkge1xuICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaCh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKVxuICAgIH1cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2goYGNvdW50PSR7Y291bnR9YClcbiAgICB9XG4gICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9IHByZWZlcnNIZWFkZXJzLmpvaW4oJywnKVxuXG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgYm9keTogdmFsdWVzLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICB9IGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxudWxsPilcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgREVMRVRFIG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBkZWxldGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuICAgKiB3aXRoIGAuc2VsZWN0KClgIGFmdGVyIGZpbHRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgZGVsZXRlZCByb3dzLlxuICAgKlxuICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAqIGhvb2QuXG4gICAqXG4gICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAqXG4gICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICogbnVtYmVycy5cbiAgICovXG4gIGRlbGV0ZSh7XG4gICAgY291bnQsXG4gIH06IHtcbiAgICBjb3VudD86ICdleGFjdCcgfCAncGxhbm5lZCcgfCAnZXN0aW1hdGVkJ1xuICB9ID0ge30pOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBudWxsLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+IHtcbiAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJ1xuICAgIGNvbnN0IHByZWZlcnNIZWFkZXJzID0gW11cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2goYGNvdW50PSR7Y291bnR9YClcbiAgICB9XG4gICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnVuc2hpZnQodGhpcy5oZWFkZXJzWydQcmVmZXInXSlcbiAgICB9XG4gICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9IHByZWZlcnNIZWFkZXJzLmpvaW4oJywnKVxuXG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICB9IGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxudWxsPilcbiAgfVxufVxuIiwgImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzEuMTcuMTEnXG4iLCAiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbidcbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYHBvc3RncmVzdC1qcy8ke3ZlcnNpb259YCB9XG4iLCAiaW1wb3J0IFBvc3RncmVzdFF1ZXJ5QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdFF1ZXJ5QnVpbGRlcidcbmltcG9ydCBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyIGZyb20gJy4vUG9zdGdyZXN0RmlsdGVyQnVpbGRlcidcbmltcG9ydCBQb3N0Z3Jlc3RCdWlsZGVyIGZyb20gJy4vUG9zdGdyZXN0QnVpbGRlcidcbmltcG9ydCB7IERFRkFVTFRfSEVBREVSUyB9IGZyb20gJy4vY29uc3RhbnRzJ1xuaW1wb3J0IHsgRmV0Y2gsIEdlbmVyaWNTY2hlbWEgfSBmcm9tICcuL3R5cGVzJ1xuXG4vKipcbiAqIFBvc3RnUkVTVCBjbGllbnQuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRhYmFzZSAtIFR5cGVzIGZvciB0aGUgc2NoZW1hIGZyb20gdGhlIFt0eXBlXG4gKiBnZW5lcmF0b3JdKGh0dHBzOi8vc3VwYWJhc2UuY29tL2RvY3MvcmVmZXJlbmNlL2phdmFzY3JpcHQvbmV4dC90eXBlc2NyaXB0LXN1cHBvcnQpXG4gKlxuICogQHR5cGVQYXJhbSBTY2hlbWFOYW1lIC0gUG9zdGdyZXMgc2NoZW1hIHRvIHN3aXRjaCB0by4gTXVzdCBiZSBhIHN0cmluZ1xuICogbGl0ZXJhbCwgdGhlIHNhbWUgb25lIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuIElmIHRoZSBzY2hlbWEgaXMgbm90XG4gKiBgXCJwdWJsaWNcImAsIHRoaXMgbXVzdCBiZSBzdXBwbGllZCBtYW51YWxseS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zdGdyZXN0Q2xpZW50PFxuICBEYXRhYmFzZSA9IGFueSxcbiAgU2NoZW1hTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIERhdGFiYXNlID0gJ3B1YmxpYycgZXh0ZW5kcyBrZXlvZiBEYXRhYmFzZVxuICAgID8gJ3B1YmxpYydcbiAgICA6IHN0cmluZyAmIGtleW9mIERhdGFiYXNlLFxuICBTY2hlbWEgZXh0ZW5kcyBHZW5lcmljU2NoZW1hID0gRGF0YWJhc2VbU2NoZW1hTmFtZV0gZXh0ZW5kcyBHZW5lcmljU2NoZW1hXG4gICAgPyBEYXRhYmFzZVtTY2hlbWFOYW1lXVxuICAgIDogYW55XG4+IHtcbiAgdXJsOiBzdHJpbmdcbiAgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBzY2hlbWFOYW1lPzogU2NoZW1hTmFtZVxuICBmZXRjaD86IEZldGNoXG5cbiAgLy8gVE9ETzogQWRkIGJhY2sgc2hvdWxkVGhyb3dPbkVycm9yIG9uY2Ugd2UgZmlndXJlIG91dCB0aGUgdHlwaW5nc1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBvc3RnUkVTVCBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSB1cmwgLSBVUkwgb2YgdGhlIFBvc3RnUkVTVCBlbmRwb2ludFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMuaGVhZGVycyAtIEN1c3RvbSBoZWFkZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLnNjaGVtYSAtIFBvc3RncmVzIHNjaGVtYSB0byBzd2l0Y2ggdG9cbiAgICogQHBhcmFtIG9wdGlvbnMuZmV0Y2ggLSBDdXN0b20gZmV0Y2hcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHVybDogc3RyaW5nLFxuICAgIHtcbiAgICAgIGhlYWRlcnMgPSB7fSxcbiAgICAgIHNjaGVtYSxcbiAgICAgIGZldGNoLFxuICAgIH06IHtcbiAgICAgIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICAgICBzY2hlbWE/OiBTY2hlbWFOYW1lXG4gICAgICBmZXRjaD86IEZldGNoXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHRoaXMudXJsID0gdXJsXG4gICAgdGhpcy5oZWFkZXJzID0geyAuLi5ERUZBVUxUX0hFQURFUlMsIC4uLmhlYWRlcnMgfVxuICAgIHRoaXMuc2NoZW1hTmFtZSA9IHNjaGVtYVxuICAgIHRoaXMuZmV0Y2ggPSBmZXRjaFxuICB9XG5cbiAgZnJvbTxcbiAgICBUYWJsZU5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBTY2hlbWFbJ1RhYmxlcyddLFxuICAgIFRhYmxlIGV4dGVuZHMgU2NoZW1hWydUYWJsZXMnXVtUYWJsZU5hbWVdXG4gID4ocmVsYXRpb246IFRhYmxlTmFtZSk6IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjxTY2hlbWEsIFRhYmxlLCBUYWJsZU5hbWU+XG4gIGZyb208Vmlld05hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBTY2hlbWFbJ1ZpZXdzJ10sIFZpZXcgZXh0ZW5kcyBTY2hlbWFbJ1ZpZXdzJ11bVmlld05hbWVdPihcbiAgICByZWxhdGlvbjogVmlld05hbWVcbiAgKTogUG9zdGdyZXN0UXVlcnlCdWlsZGVyPFNjaGVtYSwgVmlldywgVmlld05hbWU+XG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgcXVlcnkgb24gYSB0YWJsZSBvciBhIHZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSByZWxhdGlvbiAtIFRoZSB0YWJsZSBvciB2aWV3IG5hbWUgdG8gcXVlcnlcbiAgICovXG4gIGZyb20ocmVsYXRpb246IHN0cmluZyk6IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjxTY2hlbWEsIGFueSwgYW55PiB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHt0aGlzLnVybH0vJHtyZWxhdGlvbn1gKVxuICAgIHJldHVybiBuZXcgUG9zdGdyZXN0UXVlcnlCdWlsZGVyKHVybCwge1xuICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMgfSxcbiAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWFOYW1lLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgYSBzY2hlbWEgdG8gcXVlcnkgb3IgcGVyZm9ybSBhbiBmdW5jdGlvbiAocnBjKSBjYWxsLlxuICAgKlxuICAgKiBUaGUgc2NoZW1hIG5lZWRzIHRvIGJlIG9uIHRoZSBsaXN0IG9mIGV4cG9zZWQgc2NoZW1hcyBpbnNpZGUgU3VwYWJhc2UuXG4gICAqXG4gICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIHF1ZXJ5XG4gICAqL1xuICBzY2hlbWE8RHluYW1pY1NjaGVtYSBleHRlbmRzIHN0cmluZyAmIGtleW9mIERhdGFiYXNlPihcbiAgICBzY2hlbWE6IER5bmFtaWNTY2hlbWFcbiAgKTogUG9zdGdyZXN0Q2xpZW50PFxuICAgIERhdGFiYXNlLFxuICAgIER5bmFtaWNTY2hlbWEsXG4gICAgRGF0YWJhc2VbRHluYW1pY1NjaGVtYV0gZXh0ZW5kcyBHZW5lcmljU2NoZW1hID8gRGF0YWJhc2VbRHluYW1pY1NjaGVtYV0gOiBhbnlcbiAgPiB7XG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RDbGllbnQodGhpcy51cmwsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIHNjaGVtYSxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhIGZ1bmN0aW9uIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiBuYW1lIHRvIGNhbGxcbiAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9uIGNhbGxcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLmhlYWQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIGBkYXRhYCB3aWxsIG5vdCBiZSByZXR1cm5lZC5cbiAgICogVXNlZnVsIGlmIHlvdSBvbmx5IG5lZWQgdGhlIGNvdW50LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5nZXQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoXG4gICAqIHJlYWQtb25seSBhY2Nlc3MgbW9kZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHJvd3MgcmV0dXJuZWQgYnkgdGhlXG4gICAqIGZ1bmN0aW9uLiBPbmx5IGFwcGxpY2FibGUgZm9yIFtzZXQtcmV0dXJuaW5nXG4gICAqIGZ1bmN0aW9uc10oaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9jdXJyZW50L2Z1bmN0aW9ucy1zcmYuaHRtbCkuXG4gICAqXG4gICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICogaG9vZC5cbiAgICpcbiAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICpcbiAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgKiBudW1iZXJzLlxuICAgKi9cbiAgcnBjPEZuTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFNjaGVtYVsnRnVuY3Rpb25zJ10sIEZuIGV4dGVuZHMgU2NoZW1hWydGdW5jdGlvbnMnXVtGbk5hbWVdPihcbiAgICBmbjogRm5OYW1lLFxuICAgIGFyZ3M6IEZuWydBcmdzJ10gPSB7fSxcbiAgICB7XG4gICAgICBoZWFkID0gZmFsc2UsXG4gICAgICBnZXQgPSBmYWxzZSxcbiAgICAgIGNvdW50LFxuICAgIH06IHtcbiAgICAgIGhlYWQ/OiBib29sZWFuXG4gICAgICBnZXQ/OiBib29sZWFuXG4gICAgICBjb3VudD86ICdleGFjdCcgfCAncGxhbm5lZCcgfCAnZXN0aW1hdGVkJ1xuICAgIH0gPSB7fVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFxuICAgIFNjaGVtYSxcbiAgICBGblsnUmV0dXJucyddIGV4dGVuZHMgYW55W11cbiAgICAgID8gRm5bJ1JldHVybnMnXVtudW1iZXJdIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICAgICAgPyBGblsnUmV0dXJucyddW251bWJlcl1cbiAgICAgICAgOiBuZXZlclxuICAgICAgOiBuZXZlcixcbiAgICBGblsnUmV0dXJucyddLFxuICAgIEZuTmFtZSxcbiAgICBudWxsXG4gID4ge1xuICAgIGxldCBtZXRob2Q6ICdIRUFEJyB8ICdHRVQnIHwgJ1BPU1QnXG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHt0aGlzLnVybH0vcnBjLyR7Zm59YClcbiAgICBsZXQgYm9keTogdW5rbm93biB8IHVuZGVmaW5lZFxuICAgIGlmIChoZWFkIHx8IGdldCkge1xuICAgICAgbWV0aG9kID0gaGVhZCA/ICdIRUFEJyA6ICdHRVQnXG4gICAgICBPYmplY3QuZW50cmllcyhhcmdzKVxuICAgICAgICAvLyBwYXJhbXMgd2l0aCB1bmRlZmluZWQgdmFsdWUgbmVlZHMgdG8gYmUgZmlsdGVyZWQgb3V0LCBvdGhlcndpc2UgaXQnbGxcbiAgICAgICAgLy8gc2hvdyB1cCBhcyBgP3BhcmFtPXVuZGVmaW5lZGBcbiAgICAgICAgLmZpbHRlcigoW18sIHZhbHVlXSkgPT4gdmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgLy8gYXJyYXkgdmFsdWVzIG5lZWQgc3BlY2lhbCBzeW50YXhcbiAgICAgICAgLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gW25hbWUsIEFycmF5LmlzQXJyYXkodmFsdWUpID8gYHske3ZhbHVlLmpvaW4oJywnKX19YCA6IGAke3ZhbHVlfWBdKVxuICAgICAgICAuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXRob2QgPSAnUE9TVCdcbiAgICAgIGJvZHkgPSBhcmdzXG4gICAgfVxuXG4gICAgY29uc3QgaGVhZGVycyA9IHsgLi4udGhpcy5oZWFkZXJzIH1cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGhlYWRlcnNbJ1ByZWZlciddID0gYGNvdW50PSR7Y291bnR9YFxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYU5hbWUsXG4gICAgICBib2R5LFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICB9IGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxGblsnUmV0dXJucyddPilcbiAgfVxufVxuIiwgIi8vIEFsd2F5cyB1cGRhdGUgd3JhcHBlci5tanMgd2hlbiB1cGRhdGluZyB0aGlzIGZpbGUuXG5pbXBvcnQgUG9zdGdyZXN0Q2xpZW50IGZyb20gJy4vUG9zdGdyZXN0Q2xpZW50J1xuaW1wb3J0IFBvc3RncmVzdFF1ZXJ5QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdFF1ZXJ5QnVpbGRlcidcbmltcG9ydCBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyIGZyb20gJy4vUG9zdGdyZXN0RmlsdGVyQnVpbGRlcidcbmltcG9ydCBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyIGZyb20gJy4vUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcidcbmltcG9ydCBQb3N0Z3Jlc3RCdWlsZGVyIGZyb20gJy4vUG9zdGdyZXN0QnVpbGRlcidcbmltcG9ydCBQb3N0Z3Jlc3RFcnJvciBmcm9tICcuL1Bvc3RncmVzdEVycm9yJ1xuXG5leHBvcnQge1xuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbiAgUG9zdGdyZXN0QnVpbGRlcixcbiAgUG9zdGdyZXN0RXJyb3IsXG59XG5leHBvcnQgZGVmYXVsdCB7XG4gIFBvc3RncmVzdENsaWVudCxcbiAgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxuICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLFxuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RFcnJvcixcbn1cbmV4cG9ydCB0eXBlIHtcbiAgUG9zdGdyZXN0UmVzcG9uc2UsXG4gIFBvc3RncmVzdFJlc3BvbnNlRmFpbHVyZSxcbiAgUG9zdGdyZXN0UmVzcG9uc2VTdWNjZXNzLFxuICBQb3N0Z3Jlc3RTaW5nbGVSZXNwb25zZSxcbiAgUG9zdGdyZXN0TWF5YmVTaW5nbGVSZXNwb25zZSxcbn0gZnJvbSAnLi90eXBlcydcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzU1MVxuLy8gVG8gYmUgcmVwbGFjZWQgd2l0aCBhIGhlbHBlciB0eXBlIHRoYXQgb25seSB1c2VzIHB1YmxpYyB0eXBlc1xuZXhwb3J0IHR5cGUgeyBHZXRSZXN1bHQgYXMgVW5zdGFibGVHZXRSZXN1bHQgfSBmcm9tICcuL3NlbGVjdC1xdWVyeS1wYXJzZXIvcmVzdWx0J1xuIiwgIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnd3MgZG9lcyBub3Qgd29yayBpbiB0aGUgYnJvd3Nlci4gQnJvd3NlciBjbGllbnRzIG11c3QgdXNlIHRoZSBuYXRpdmUgJyArXG4gICAgICAnV2ViU29ja2V0IG9iamVjdCdcbiAgKTtcbn07XG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBURmlsZSwgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgU3VwYWJhc2VTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy9TdXBhYmFzZVNlcnZpY2UnO1xuaW1wb3J0IHsgT3BlbkFJU2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvT3BlbkFJU2VydmljZSc7XG5pbXBvcnQgeyBRdWV1ZVNlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL1F1ZXVlU2VydmljZSc7XG5pbXBvcnQgeyBGaWxlVHJhY2tlciB9IGZyb20gJy4vdXRpbHMvRmlsZVRyYWNrZXInO1xuaW1wb3J0IHsgRXJyb3JIYW5kbGVyIH0gZnJvbSAnLi91dGlscy9FcnJvckhhbmRsZXInO1xuaW1wb3J0IHsgTm90aWZpY2F0aW9uTWFuYWdlciB9IGZyb20gJy4vdXRpbHMvTm90aWZpY2F0aW9uTWFuYWdlcic7XG5pbXBvcnQgeyBNaW5kTWF0cml4U2V0dGluZ3NUYWIgfSBmcm9tICcuL3NldHRpbmdzL1NldHRpbmdzVGFiJztcbmltcG9ydCB7IFN5bmNGaWxlTWFuYWdlciB9IGZyb20gJy4vc2VydmljZXMvU3luY0ZpbGVNYW5hZ2VyJztcbmltcG9ydCB7IEluaXRpYWxTeW5jTWFuYWdlciB9IGZyb20gJy4vc2VydmljZXMvSW5pdGlhbFN5bmNNYW5hZ2VyJztcbmltcG9ydCB7IE1ldGFkYXRhRXh0cmFjdG9yIH0gZnJvbSAnLi9zZXJ2aWNlcy9NZXRhZGF0YUV4dHJhY3Rvcic7XG5pbXBvcnQgeyBTdGF0dXNNYW5hZ2VyLCBQbHVnaW5TdGF0dXMgfSBmcm9tICcuL3NlcnZpY2VzL1N0YXR1c01hbmFnZXInO1xuaW1wb3J0IHsgU3luY0RldGVjdGlvbk1hbmFnZXIgfSBmcm9tICcuL3NlcnZpY2VzL1N5bmNEZXRlY3Rpb25NYW5hZ2VyJztcblxuaW1wb3J0IHtcblx0TWluZE1hdHJpeFNldHRpbmdzLFxuXHRERUZBVUxUX1NFVFRJTkdTLFxuXHRpc1ZhdWx0SW5pdGlhbGl6ZWQsXG5cdGdlbmVyYXRlVmF1bHRJZFxufSBmcm9tICcuL3NldHRpbmdzL1NldHRpbmdzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWluZE1hdHJpeFBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG5cdHNldHRpbmdzOiBNaW5kTWF0cml4U2V0dGluZ3M7XG5cdHByaXZhdGUgc3VwYWJhc2VTZXJ2aWNlOiBTdXBhYmFzZVNlcnZpY2UgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBvcGVuQUlTZXJ2aWNlOiBPcGVuQUlTZXJ2aWNlIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgcXVldWVTZXJ2aWNlOiBRdWV1ZVNlcnZpY2UgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBmaWxlVHJhY2tlcjogRmlsZVRyYWNrZXIgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBlcnJvckhhbmRsZXI6IEVycm9ySGFuZGxlciB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIG5vdGlmaWNhdGlvbk1hbmFnZXI6IE5vdGlmaWNhdGlvbk1hbmFnZXIgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBpc0luaXRpYWxpemluZyA9IGZhbHNlO1xuXHRwcml2YXRlIHN5bmNNYW5hZ2VyOiBTeW5jRmlsZU1hbmFnZXIgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBzeW5jQ2hlY2tJbnRlcnZhbDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBpbml0aWFsaXphdGlvblRpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgc3luY0NoZWNrQXR0ZW1wdHMgPSAwO1xuXHRwcml2YXRlIGluaXRpYWxTeW5jTWFuYWdlcjogSW5pdGlhbFN5bmNNYW5hZ2VyIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgbWV0YWRhdGFFeHRyYWN0b3I6IE1ldGFkYXRhRXh0cmFjdG9yIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgc3RhdHVzTWFuYWdlcjogU3RhdHVzTWFuYWdlciB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIHN5bmNEZXRlY3Rpb25NYW5hZ2VyOiBTeW5jRGV0ZWN0aW9uTWFuYWdlciB8IG51bGwgPSBudWxsO1xuXG5cdGFzeW5jIG9ubG9hZCgpIHtcblx0XHRjb25zb2xlLmxvZygnTG9hZGluZyBNaW5kIE1hdHJpeCBQbHVnaW4uLi4nKTtcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBJbml0aWFsaXplIHN0YXR1cyBtYW5hZ2VyIGZpcnN0XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXIgPSBuZXcgU3RhdHVzTWFuYWdlcih0aGlzLmFkZFN0YXR1c0Jhckl0ZW0oKSk7XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXIuc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5JTklUSUFMSVpJTkcsIHtcblx0XHRcdFx0bWVzc2FnZTogJ0xvYWRpbmcgTWluZCBNYXRyaXggUGx1Z2luLi4uJ1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIExvYWQgc2V0dGluZ3Ncblx0XHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cblx0XHRcdC8vIEluaXRpYWxpemUgY29yZSBzZXJ2aWNlc1xuXHRcdFx0YXdhaXQgdGhpcy5pbml0aWFsaXplQ29yZVNlcnZpY2VzKCk7XG5cblx0XHRcdC8vIEluaXRpYWxpemUgdmF1bHQgaWYgbmVlZGVkXG5cdFx0XHRhd2FpdCB0aGlzLmluaXRpYWxpemVWYXVsdElmTmVlZGVkKCk7XG5cblx0XHRcdC8vIEFkZCBzZXR0aW5ncyB0YWJcblx0XHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgTWluZE1hdHJpeFNldHRpbmdzVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cblx0XHRcdGlmIChpc1ZhdWx0SW5pdGlhbGl6ZWQodGhpcy5zZXR0aW5ncykpIHtcblx0XHRcdFx0Ly8gSW5pdGlhbGl6ZSBzeW5jIGRldGVjdGlvblxuXHRcdFx0XHR0aGlzLnN0YXR1c01hbmFnZXIuc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5XQUlUSU5HX0ZPUl9TWU5DLCB7XG5cdFx0XHRcdFx0bWVzc2FnZTogJ1dhaXRpbmcgZm9yIE9ic2lkaWFuIHN5bmMgdG8gc2V0dGxlLi4uJ1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBDcmVhdGUgYW5kIHN0YXJ0IHN5bmMgZGV0ZWN0aW9uXG5cdFx0XHRcdHRoaXMuc3luY0RldGVjdGlvbk1hbmFnZXIgPSBuZXcgU3luY0RldGVjdGlvbk1hbmFnZXIoXG5cdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHR0aGlzLnN0YXR1c01hbmFnZXIsXG5cdFx0XHRcdFx0dGhpcy5vblN5bmNRdWlldFBlcmlvZFJlYWNoZWQuYmluZCh0aGlzKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHR0aGlzLnN5bmNEZXRlY3Rpb25NYW5hZ2VyLnN0YXJ0TW9uaXRvcmluZygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSWYgdmF1bHQgaXNuJ3QgaW5pdGlhbGl6ZWQsIHByb2NlZWQgbm9ybWFsbHlcblx0XHRcdFx0YXdhaXQgdGhpcy5jb21wbGV0ZUluaXRpYWxpemF0aW9uKCk7XG5cdFx0XHR9XG5cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgTWluZCBNYXRyaXggUGx1Z2luOicsIGVycm9yKTtcblx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlcj8uc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5FUlJPUiwge1xuXHRcdFx0XHRtZXNzYWdlOiAnRmFpbGVkIHRvIGluaXRpYWxpemUgcGx1Z2luLiBDaGVjayBjb25zb2xlIGZvciBkZXRhaWxzLicsXG5cdFx0XHRcdGVycm9yOiBlcnJvciBhcyBFcnJvclxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBvblN5bmNRdWlldFBlcmlvZFJlYWNoZWQoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFN0b3AgbW9uaXRvcmluZyBhcyB3ZSd2ZSByZWFjaGVkIHF1aWV0IHBlcmlvZFxuXHRcdFx0dGhpcy5zeW5jRGV0ZWN0aW9uTWFuYWdlcj8uc3RvcE1vbml0b3JpbmcoKTtcblxuXHRcdFx0dGhpcy5zdGF0dXNNYW5hZ2VyPy5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLkNIRUNLSU5HX0ZJTEUsIHtcblx0XHRcdFx0bWVzc2FnZTogJ0luaXRpYWxpemluZyBzeW5jIG1hbmFnZXIuLi4nXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBzeW5jIG1hbmFnZXJcblx0XHRcdGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVN5bmNNYW5hZ2VyKCk7XG5cdFx0XHRhd2FpdCB0aGlzLnN0YXJ0U3luY1Byb2Nlc3MoKTtcblxuXHRcdFx0Ly8gQ29tcGxldGUgcmVtYWluaW5nIGluaXRpYWxpemF0aW9uXG5cdFx0XHRhd2FpdCB0aGlzLmNvbXBsZXRlSW5pdGlhbGl6YXRpb24oKTtcblxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgcXVpZXQgcGVyaW9kIGluaXRpYWxpemF0aW9uOicsIGVycm9yKTtcblx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlcj8uc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5FUlJPUiwge1xuXHRcdFx0XHRtZXNzYWdlOiAnRmFpbGVkIHRvIGluaXRpYWxpemUgYWZ0ZXIgc3luYyBxdWlldCBwZXJpb2QnLFxuXHRcdFx0XHRlcnJvcjogZXJyb3IgYXMgRXJyb3Jcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgY29tcGxldGVJbml0aWFsaXphdGlvbigpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gUmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnMgYW5kIGNvbW1hbmRzXG5cdFx0XHR0aGlzLnJlZ2lzdGVyRXZlbnRIYW5kbGVycygpO1xuXHRcdFx0dGhpcy5hZGRDb21tYW5kcygpO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3RhdHVzIHRvIHJlYWR5XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuUkVBRFksIHtcblx0XHRcdFx0bWVzc2FnZTogJ01pbmQgTWF0cml4IGlzIHJlYWR5J1xuXHRcdFx0fSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvbXBsZXRpbmcgaW5pdGlhbGl6YXRpb246JywgZXJyb3IpO1xuXHRcdFx0dGhpcy5zdGF0dXNNYW5hZ2VyPy5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLkVSUk9SLCB7XG5cdFx0XHRcdG1lc3NhZ2U6ICdGYWlsZWQgdG8gY29tcGxldGUgaW5pdGlhbGl6YXRpb24nLFxuXHRcdFx0XHRlcnJvcjogZXJyb3IgYXMgRXJyb3Jcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIG9udW5sb2FkKCkge1xuXHRcdGNvbnNvbGUubG9nKCdVbmxvYWRpbmcgTWluZCBNYXRyaXggUGx1Z2luLi4uJyk7XG5cblx0XHQvLyBTdG9wIHN5bmMgZGV0ZWN0aW9uXG5cdFx0dGhpcy5zeW5jRGV0ZWN0aW9uTWFuYWdlcj8uc3RvcE1vbml0b3JpbmcoKTtcblxuXHRcdGlmICh0aGlzLmluaXRpYWxpemF0aW9uVGltZW91dCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuaW5pdGlhbGl6YXRpb25UaW1lb3V0KTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwpIHtcblx0XHRcdGNsZWFySW50ZXJ2YWwodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5xdWV1ZVNlcnZpY2U/LnN0b3AoKTtcblx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXI/LmNsZWFyKCk7XG5cdFx0dGhpcy5pbml0aWFsU3luY01hbmFnZXI/LnN0b3AoKTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgc3RhcnRTeW5jUHJvY2VzcygpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuc3luY01hbmFnZXIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignU3luYyBtYW5hZ2VyIG5vdCBpbml0aWFsaXplZCcpO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuQ0hFQ0tJTkdfRklMRSwge1xuXHRcdFx0XHRtZXNzYWdlOiAnQ2hlY2tpbmcgc3luYyBmaWxlIHN0YXR1cy4uLidcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBJbml0aWFsIHN5bmMgY2hlY2tcblx0XHRcdGNvbnN0IHN5bmNTdGF0dXMgPSBhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLnZhbGlkYXRlU3luY1N0YXRlKCk7XG5cblx0XHRcdGlmICghc3luY1N0YXR1cy5pc1ZhbGlkKSB7XG5cdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLnN5bmMucmVxdWlyZVN5bmMpIHtcblx0XHRcdFx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuRVJST1IsIHtcblx0XHRcdFx0XHRcdG1lc3NhZ2U6IGBTeW5jIHZhbGlkYXRpb24gZmFpbGVkOiAke3N5bmNTdGF0dXMuZXJyb3J9YFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgU3luYyB2YWxpZGF0aW9uIGZhaWxlZDogJHtzeW5jU3RhdHVzLmVycm9yfWApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybihgU3luYyB2YWxpZGF0aW9uIHdhcm5pbmc6ICR7c3luY1N0YXR1cy5lcnJvcn1gKTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBTeW5jIHdhcm5pbmc6ICR7c3luY1N0YXR1cy5lcnJvcn1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbml0aWFsaXplIHJlbWFpbmluZyBzZXJ2aWNlc1xuXHRcdFx0dGhpcy5zdGF0dXNNYW5hZ2VyPy5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLklOSVRJQUxJWklORywge1xuXHRcdFx0XHRtZXNzYWdlOiAnSW5pdGlhbGl6aW5nIHNlcnZpY2VzLi4uJ1xuXHRcdFx0fSk7XG5cdFx0XHRhd2FpdCB0aGlzLmluaXRpYWxpemVTZXJ2aWNlcygpO1xuXG5cdFx0XHQvLyBTdGFydCBwZXJpb2RpYyBzeW5jIGNoZWNrc1xuXHRcdFx0dGhpcy5zdGFydFBlcmlvZGljU3luY0NoZWNrcygpO1xuXG5cdFx0XHQvLyBTdGFydCBpbml0aWFsIHN5bmMgaWYgZW5hYmxlZFxuXHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuaW5pdGlhbFN5bmMuZW5hYmxlQXV0b0luaXRpYWxTeW5jICYmIHRoaXMuaW5pdGlhbFN5bmNNYW5hZ2VyKSB7XG5cdFx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlcj8uc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5JTklUSUFMSVpJTkcsIHtcblx0XHRcdFx0XHRtZXNzYWdlOiAnU3RhcnRpbmcgaW5pdGlhbCB2YXVsdCBzeW5jLi4uJ1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0YXdhaXQgdGhpcy5pbml0aWFsU3luY01hbmFnZXIuc3RhcnRTeW5jKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlcj8uc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5SRUFEWSwge1xuXHRcdFx0XHRtZXNzYWdlOiAnU3luYyBwcm9jZXNzIGNvbXBsZXRlZCdcblx0XHRcdH0pO1xuXG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLnN5bmMucmVxdWlyZVN5bmMpIHtcblx0XHRcdFx0dGhpcy5zdGF0dXNNYW5hZ2VyPy5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLkVSUk9SLCB7XG5cdFx0XHRcdFx0bWVzc2FnZTogJ1N5bmMgcHJvY2VzcyBmYWlsZWQnLFxuXHRcdFx0XHRcdGVycm9yOiBlcnJvciBhcyBFcnJvclxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdTeW5jIHByb2Nlc3MgZXJyb3I6JywgZXJyb3IpO1xuXHRcdFx0XHRuZXcgTm90aWNlKCdTeW5jIHByb2Nlc3MgZXJyb3IuIENvbnRpbnVpbmcgd2l0aCBsaW1pdGVkIGZ1bmN0aW9uYWxpdHkuJyk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVNlcnZpY2VzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblxuXHRwcml2YXRlIGFzeW5jIGluaXRpYWxpemVTeW5jTWFuYWdlcigpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuZXJyb3JIYW5kbGVyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGhhbmRsZXIgbXVzdCBiZSBpbml0aWFsaXplZCBiZWZvcmUgc3luYyBtYW5hZ2VyJyk7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMuc3luY01hbmFnZXIgPSBuZXcgU3luY0ZpbGVNYW5hZ2VyKFxuXHRcdFx0XHR0aGlzLmFwcC52YXVsdCxcblx0XHRcdFx0dGhpcy5lcnJvckhhbmRsZXIsXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3luYy5zeW5jRmlsZVBhdGgsXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3luYy5iYWNrdXBJbnRlcnZhbFxuXHRcdFx0KTtcblxuXHRcdFx0YXdhaXQgdGhpcy5zeW5jTWFuYWdlci5pbml0aWFsaXplKCk7XG5cdFx0XHRjb25zb2xlLmxvZygnU3luYyBtYW5hZ2VyIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseScpO1xuXG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIHN5bmMgbWFuYWdlcjonLCBlcnJvcik7XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoJ0ZhaWxlZCB0byBpbml0aWFsaXplIHN5bmMgc3lzdGVtLiBTb21lIGZlYXR1cmVzIG1heSBiZSB1bmF2YWlsYWJsZS4nKTtcblx0XHRcdH1cblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZUNvcmVTZXJ2aWNlcygpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuSU5JVElBTElaSU5HLCB7XG5cdFx0XHRtZXNzYWdlOiAnSW5pdGlhbGl6aW5nIGNvcmUgc2VydmljZXMuLi4nXG5cdFx0fSk7XG5cblx0XHQvLyBJbml0aWFsaXplIGVycm9yIGhhbmRsZXJcblx0XHR0aGlzLmVycm9ySGFuZGxlciA9IG5ldyBFcnJvckhhbmRsZXIoXG5cdFx0XHR0aGlzLnNldHRpbmdzPy5kZWJ1ZyA/PyBERUZBVUxUX1NFVFRJTkdTLmRlYnVnLFxuXHRcdFx0dGhpcy5hcHAudmF1bHQuYWRhcHRlci5nZXRCYXNlUGF0aCgpXG5cdFx0KTtcblxuXHRcdC8vIEluaXRpYWxpemUgbm90aWZpY2F0aW9uIG1hbmFnZXJcblx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIgPSBuZXcgTm90aWZpY2F0aW9uTWFuYWdlcihcblx0XHRcdHRoaXMuYWRkU3RhdHVzQmFySXRlbSgpLFxuXHRcdFx0dGhpcy5zZXR0aW5ncz8uZW5hYmxlTm90aWZpY2F0aW9ucyA/PyB0cnVlLFxuXHRcdFx0dGhpcy5zZXR0aW5ncz8uZW5hYmxlUHJvZ3Jlc3NCYXIgPz8gdHJ1ZVxuXHRcdCk7XG5cblx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuSU5JVElBTElaSU5HLCB7XG5cdFx0XHRtZXNzYWdlOiAnQ29yZSBzZXJ2aWNlcyBpbml0aWFsaXplZCdcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuXHR9XG5cblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG5cblx0XHQvLyBVcGRhdGUgc2VydmljZSBzZXR0aW5nc1xuXHRcdHRoaXMubm90aWZpY2F0aW9uTWFuYWdlcj8udXBkYXRlU2V0dGluZ3MoXG5cdFx0XHR0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMsXG5cdFx0XHR0aGlzLnNldHRpbmdzLmVuYWJsZVByb2dyZXNzQmFyXG5cdFx0KTtcblx0XHR0aGlzLmVycm9ySGFuZGxlcj8udXBkYXRlU2V0dGluZ3ModGhpcy5zZXR0aW5ncy5kZWJ1Zyk7XG5cblx0XHQvLyBSZWluaXRpYWxpemUgc2VydmljZXMgaWYgc2V0dGluZ3MgaGF2ZSBjaGFuZ2VkXG5cdFx0aWYgKGlzVmF1bHRJbml0aWFsaXplZCh0aGlzLnNldHRpbmdzKSkge1xuXHRcdFx0YXdhaXQgdGhpcy5pbml0aWFsaXplU2VydmljZXMoKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHN0YXJ0UGVyaW9kaWNTeW5jQ2hlY2tzKCk6IHZvaWQge1xuXHRcdGlmICh0aGlzLnN5bmNDaGVja0ludGVydmFsKSB7XG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG5cdFx0XHRhd2FpdCB0aGlzLnBlcmZvcm1TeW5jQ2hlY2soKTtcblx0XHR9LCB0aGlzLnNldHRpbmdzLnN5bmMuY2hlY2tJbnRlcnZhbCk7XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIHBlcmZvcm1TeW5jQ2hlY2soKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCF0aGlzLnN5bmNNYW5hZ2VyKSByZXR1cm47XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3Qgc3luY1N0YXR1cyA9IGF3YWl0IHRoaXMuc3luY01hbmFnZXIudmFsaWRhdGVTeW5jU3RhdGUoKTtcblxuXHRcdFx0aWYgKCFzeW5jU3RhdHVzLmlzVmFsaWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKGBTeW5jIGNoZWNrIGZhaWxlZDogJHtzeW5jU3RhdHVzLmVycm9yfWApO1xuXG5cdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBTeW5jIGlzc3VlIGRldGVjdGVkOiAke3N5bmNTdGF0dXMuZXJyb3J9YCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHJlY292ZXJ5XG5cdFx0XHRcdGNvbnN0IHJlY292ZXJlZCA9IGF3YWl0IHRoaXMuc3luY01hbmFnZXIuYXR0ZW1wdFJlY292ZXJ5KCk7XG5cdFx0XHRcdGlmICghcmVjb3ZlcmVkICYmIHRoaXMuc2V0dGluZ3Muc3luYy5yZXF1aXJlU3luYykge1xuXHRcdFx0XHRcdC8vIElmIHJlY292ZXJ5IGZhaWxlZCBhbmQgc3luYyBpcyByZXF1aXJlZCwgcmVzdGFydCBzZXJ2aWNlc1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucmVzdGFydFNlcnZpY2VzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIGxhc3Qgc3luYyB0aW1lc3RhbXBcblx0XHRcdGF3YWl0IHRoaXMuc3luY01hbmFnZXIudXBkYXRlTGFzdFN5bmMoKTtcblxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlcj8uaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ3BlcmZvcm1TeW5jQ2hlY2snLFxuXHRcdFx0XHRtZXRhZGF0YTogeyB0aW1lc3RhbXA6IERhdGUubm93KCkgfVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyByZXN0YXJ0U2VydmljZXMoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Ly8gU3RvcCBleGlzdGluZyBzZXJ2aWNlc1xuXHRcdHRoaXMucXVldWVTZXJ2aWNlPy5zdG9wKCk7XG5cblx0XHQvLyBDbGVhciBpbnRlcnZhbHNcblx0XHRpZiAodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCkge1xuXHRcdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLnN5bmNDaGVja0ludGVydmFsKTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gUmVpbml0aWFsaXplIGV2ZXJ5dGhpbmdcblx0XHRcdGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVN5bmNNYW5hZ2VyKCk7XG5cdFx0XHRhd2FpdCB0aGlzLnN0YXJ0U3luY1Byb2Nlc3MoKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlc3RhcnQgc2VydmljZXM6JywgZXJyb3IpO1xuXHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuZW5hYmxlTm90aWZpY2F0aW9ucykge1xuXHRcdFx0XHRuZXcgTm90aWNlKCdGYWlsZWQgdG8gcmVzdGFydCBzZXJ2aWNlcyBhZnRlciBzeW5jIGVycm9yJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBpbml0aWFsaXplVmF1bHRJZk5lZWRlZCgpIHtcblx0XHRpZiAodGhpcy5pc0luaXRpYWxpemluZykgcmV0dXJuO1xuXHRcdHRoaXMuaXNJbml0aWFsaXppbmcgPSB0cnVlO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGlmICghaXNWYXVsdEluaXRpYWxpemVkKHRoaXMuc2V0dGluZ3MpKSB7XG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MudmF1bHRJZCA9IGdlbmVyYXRlVmF1bHRJZCgpO1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmxhc3RLbm93blZhdWx0TmFtZSA9IHRoaXMuYXBwLnZhdWx0LmdldE5hbWUoKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTtcblxuXHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnVmF1bHQgaW5pdGlhbGl6ZWQgd2l0aCBuZXcgSUQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLmxhc3RLbm93blZhdWx0TmFtZSAhPT0gdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpKSB7XG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MubGFzdEtub3duVmF1bHROYW1lID0gdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0fVxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0aGlzLmlzSW5pdGlhbGl6aW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBpbml0aWFsaXplU2VydmljZXMoKSB7XG5cdFx0Y29uc29sZS5sb2coJ0luaXRpYWxpemluZyBzZXJ2aWNlcy4uLicsIHtcblx0XHRcdGhhc1ZhdWx0OiAhIXRoaXMuYXBwLnZhdWx0LFxuXHRcdFx0aGFzRXJyb3JIYW5kbGVyOiAhIXRoaXMuZXJyb3JIYW5kbGVyXG5cdFx0fSk7XG5cblx0XHRpZiAoIXRoaXMuZXJyb3JIYW5kbGVyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvcmUgc2VydmljZXMgbm90IGluaXRpYWxpemVkJyk7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIEluaXRpYWxpemUgRmlsZVRyYWNrZXJcblx0XHRcdHRoaXMuZmlsZVRyYWNrZXIgPSBuZXcgRmlsZVRyYWNrZXIodGhpcy5hcHAudmF1bHQsIHRoaXMuZXJyb3JIYW5kbGVyLCB0aGlzLnNldHRpbmdzLnN5bmMuc3luY0ZpbGVQYXRoKTtcblx0XHRcdGF3YWl0IHRoaXMuZmlsZVRyYWNrZXIuaW5pdGlhbGl6ZSgpO1xuXHRcdFx0Y29uc29sZS5sb2coJ0ZpbGVUcmFja2VyIGluaXRpYWxpemVkLicpO1xuXG5cdFx0XHQvLyBJbml0aWFsaXplIFN1cGFiYXNlIHNlcnZpY2Vcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuc3VwYWJhc2VTZXJ2aWNlID0gYXdhaXQgU3VwYWJhc2VTZXJ2aWNlLmdldEluc3RhbmNlKHRoaXMuc2V0dGluZ3MpO1xuXHRcdFx0XHRpZiAoIXRoaXMuc3VwYWJhc2VTZXJ2aWNlKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnU3VwYWJhc2Ugc2VydmljZSBub3QgaW5pdGlhbGl6ZWQuIFBsZWFzZSBjb25maWd1cmUgeW91ciBBUEkgc2V0dGluZ3MuJyk7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignU3VwYWJhc2Ugc2VydmljZSBpbml0aWFsaXphdGlvbiBmYWlsZWQ6IE1pc3NpbmcgY29uZmlndXJhdGlvbi4nKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc29sZS5sb2coJ1N1cGFiYXNlIHNlcnZpY2UgaW5pdGlhbGl6ZWQuJyk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBpbml0aWFsaXphdGlvbiBlcnJvcjonLCBlcnJvcik7XG5cdFx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byBpbml0aWFsaXplIFN1cGFiYXNlIHNlcnZpY2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbml0aWFsaXplIE9wZW5BSSBzZXJ2aWNlXG5cdFx0XHR0aGlzLm9wZW5BSVNlcnZpY2UgPSBuZXcgT3BlbkFJU2VydmljZSh0aGlzLnNldHRpbmdzLm9wZW5haSwgdGhpcy5lcnJvckhhbmRsZXIpO1xuXHRcdFx0Y29uc29sZS5sb2coJ09wZW5BSSBzZXJ2aWNlIGluaXRpYWxpemVkLicpO1xuXG5cdFx0XHQvLyBWZXJpZnkgdmF1bHQgYWNjZXNzXG5cdFx0XHRpZiAoIXRoaXMuYXBwLnZhdWx0KSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVmF1bHQgaXMgbm90IGF2YWlsYWJsZScpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbml0aWFsaXplIHF1ZXVlIHNlcnZpY2Vcblx0XHRcdGlmICh0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIgJiYgdGhpcy5zdXBhYmFzZVNlcnZpY2UgJiYgdGhpcy5vcGVuQUlTZXJ2aWNlKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dGhpcy5xdWV1ZVNlcnZpY2UgPSBuZXcgUXVldWVTZXJ2aWNlKFxuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5xdWV1ZS5tYXhDb25jdXJyZW50LFxuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5xdWV1ZS5yZXRyeUF0dGVtcHRzLFxuXHRcdFx0XHRcdFx0dGhpcy5zdXBhYmFzZVNlcnZpY2UsXG5cdFx0XHRcdFx0XHR0aGlzLm9wZW5BSVNlcnZpY2UsXG5cdFx0XHRcdFx0XHR0aGlzLmVycm9ySGFuZGxlcixcblx0XHRcdFx0XHRcdHRoaXMubm90aWZpY2F0aW9uTWFuYWdlcixcblx0XHRcdFx0XHRcdHRoaXMuYXBwLnZhdWx0LFxuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jaHVua2luZ1xuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBTdGFydCB0aGUgcXVldWUgc2VydmljZVxuXHRcdFx0XHRcdHRoaXMucXVldWVTZXJ2aWNlLnN0YXJ0KCk7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ1F1ZXVlIHNlcnZpY2UgaW5pdGlhbGl6ZWQgYW5kIHN0YXJ0ZWQuJyk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgUXVldWVTZXJ2aWNlOicsIGVycm9yKTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBxdWV1ZSBzZXJ2aWNlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgc2VydmljZXMgbm90IGF2YWlsYWJsZSBmb3IgUXVldWVTZXJ2aWNlIGluaXRpYWxpemF0aW9uJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWV0YWRhdGFFeHRyYWN0b3IgPSBuZXcgTWV0YWRhdGFFeHRyYWN0b3IoKTtcblx0XHRcdGNvbnNvbGUubG9nKCdNZXRhZGF0YUV4dHJhY3RvciBpbml0aWFsaXplZC4nKTtcblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBJbml0aWFsU3luY01hbmFnZXJcblx0XHRcdGlmICh0aGlzLnF1ZXVlU2VydmljZSAmJiB0aGlzLnN5bmNNYW5hZ2VyICYmIHRoaXMubWV0YWRhdGFFeHRyYWN0b3IpIHtcblx0XHRcdFx0dGhpcy5pbml0aWFsU3luY01hbmFnZXIgPSBuZXcgSW5pdGlhbFN5bmNNYW5hZ2VyKFxuXHRcdFx0XHRcdHRoaXMuYXBwLnZhdWx0LFxuXHRcdFx0XHRcdHRoaXMucXVldWVTZXJ2aWNlLFxuXHRcdFx0XHRcdHRoaXMuc3luY01hbmFnZXIsXG5cdFx0XHRcdFx0dGhpcy5tZXRhZGF0YUV4dHJhY3Rvcixcblx0XHRcdFx0XHR0aGlzLmVycm9ySGFuZGxlcixcblx0XHRcdFx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIsXG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5pbml0aWFsU3luY1xuXHRcdFx0XHQpO1xuXHRcdFx0XHRjb25zb2xlLmxvZygnSW5pdGlhbFN5bmNNYW5hZ2VyIGluaXRpYWxpemVkLicpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBzZXJ2aWNlczonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGNoZWNrUmVxdWlyZWRDb25maWd1cmF0aW9ucygpOiB2b2lkIHtcblx0XHRpZiAoIXRoaXMuc2V0dGluZ3Mub3BlbmFpLmFwaUtleSkge1xuXHRcdFx0bmV3IE5vdGljZSgnT3BlbkFJIEFQSSBrZXkgaXMgbWlzc2luZy4gQUkgZmVhdHVyZXMgYXJlIGRpc2FibGVkLiBDb25maWd1cmUgaXQgaW4gdGhlIHNldHRpbmdzLicpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5zdXBhYmFzZS51cmwgfHwgIXRoaXMuc2V0dGluZ3Muc3VwYWJhc2UuYXBpS2V5KSB7XG5cdFx0XHRuZXcgTm90aWNlKCdTdXBhYmFzZSBjb25maWd1cmF0aW9uIGlzIGluY29tcGxldGUuIERhdGFiYXNlIGZlYXR1cmVzIGFyZSBkaXNhYmxlZC4gQ29uZmlndXJlIGl0IGluIHRoZSBzZXR0aW5ncy4nKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHJlZ2lzdGVyRXZlbnRIYW5kbGVycygpIHtcblx0XHQvLyBGaWxlIGNyZWF0aW9uIGV2ZW50c1xuXHRcdHRoaXMucmVnaXN0ZXJFdmVudChcblx0XHRcdHRoaXMuYXBwLnZhdWx0Lm9uKCdjcmVhdGUnLCBhc3luYyAoZmlsZSkgPT4ge1xuXHRcdFx0XHRpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSByZXR1cm47XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHN5bmMgZmlsZSBleGlzdHMgYmVmb3JlIHByb2Nlc3Npbmdcblx0XHRcdFx0aWYgKCFhd2FpdCB0aGlzLmVuc3VyZVN5bmNGaWxlRXhpc3RzKCkpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKCdGYWlsZWQgdG8gY3JlYXRlIHN5bmMgZmlsZS4gUGx1Z2luIGZ1bmN0aW9uYWxpdHkgbGltaXRlZC4nKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIXRoaXMuc2hvdWxkUHJvY2Vzc0ZpbGUoZmlsZSkpIHJldHVybjtcblxuXHRcdFx0XHRhd2FpdCB0aGlzLmZpbGVUcmFja2VyPy5oYW5kbGVDcmVhdGUoZmlsZSk7XG5cdFx0XHRcdGF3YWl0IHRoaXMucXVldWVGaWxlUHJvY2Vzc2luZyhmaWxlLCAnQ1JFQVRFJyk7XG5cdFx0XHR9KSk7XG5cblx0XHQvLyBGaWxlIG1vZGlmaWNhdGlvbiBldmVudHNcblx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQoXG5cdFx0XHR0aGlzLmFwcC52YXVsdC5vbignbW9kaWZ5JywgYXN5bmMgKGZpbGUpID0+IHtcblx0XHRcdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkgcmV0dXJuO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBzeW5jIGZpbGUgZXhpc3RzIGJlZm9yZSBwcm9jZXNzaW5nXG5cdFx0XHRcdGlmICghYXdhaXQgdGhpcy5lbnN1cmVTeW5jRmlsZUV4aXN0cygpKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnRmFpbGVkIHRvIGNyZWF0ZSBzeW5jIGZpbGUuIFBsdWdpbiBmdW5jdGlvbmFsaXR5IGxpbWl0ZWQuJyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCF0aGlzLnNob3VsZFByb2Nlc3NGaWxlKGZpbGUpKSByZXR1cm47XG5cblx0XHRcdFx0YXdhaXQgdGhpcy5maWxlVHJhY2tlcj8uaGFuZGxlTW9kaWZ5KGZpbGUpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnF1ZXVlRmlsZVByb2Nlc3NpbmcoZmlsZSwgJ1VQREFURScpO1xuXHRcdFx0fSkpO1xuXG5cdFx0Ly8gRmlsZSBkZWxldGlvbiBldmVudHNcblx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQoXG5cdFx0XHR0aGlzLmFwcC52YXVsdC5vbignZGVsZXRlJywgYXN5bmMgKGZpbGUpID0+IHtcblx0XHRcdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkgcmV0dXJuO1xuXG5cdFx0XHRcdC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIHN5bmMgZmlsZSBkZWxldGlvblxuXHRcdFx0XHRpZiAoZmlsZS5wYXRoID09PSB0aGlzLnNldHRpbmdzLnN5bmMuc3luY0ZpbGVQYXRoKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ1N5bmMgZmlsZSB3YXMgZGVsZXRlZCwgd2lsbCByZWNyZWF0ZSBvbiBuZXh0IG9wZXJhdGlvbicpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEVuc3VyZSBzeW5jIGZpbGUgZXhpc3RzIGJlZm9yZSBwcm9jZXNzaW5nXG5cdFx0XHRcdGlmICghYXdhaXQgdGhpcy5lbnN1cmVTeW5jRmlsZUV4aXN0cygpKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnRmFpbGVkIHRvIGNyZWF0ZSBzeW5jIGZpbGUuIFBsdWdpbiBmdW5jdGlvbmFsaXR5IGxpbWl0ZWQuJyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCF0aGlzLnNob3VsZFByb2Nlc3NGaWxlKGZpbGUpKSByZXR1cm47XG5cblx0XHRcdFx0YXdhaXQgdGhpcy5maWxlVHJhY2tlcj8uaGFuZGxlRGVsZXRlKGZpbGUpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnF1ZXVlRmlsZVByb2Nlc3NpbmcoZmlsZSwgJ0RFTEVURScpO1xuXHRcdFx0fSkpO1xuXG5cdFx0Ly8gRmlsZSByZW5hbWUgZXZlbnRzXG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50KFxuXHRcdFx0dGhpcy5hcHAudmF1bHQub24oJ3JlbmFtZScsIGFzeW5jIChmaWxlLCBvbGRQYXRoKSA9PiB7XG5cdFx0XHRcdGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHJldHVybjtcblxuXHRcdFx0XHQvLyBFbnN1cmUgc3luYyBmaWxlIGV4aXN0cyBiZWZvcmUgcHJvY2Vzc2luZ1xuXHRcdFx0XHRpZiAoIWF3YWl0IHRoaXMuZW5zdXJlU3luY0ZpbGVFeGlzdHMoKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0ZhaWxlZCB0byBjcmVhdGUgc3luYyBmaWxlLiBQbHVnaW4gZnVuY3Rpb25hbGl0eSBsaW1pdGVkLicpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghdGhpcy5zaG91bGRQcm9jZXNzRmlsZShmaWxlKSkgcmV0dXJuO1xuXG5cdFx0XHRcdGF3YWl0IHRoaXMuZmlsZVRyYWNrZXI/LmhhbmRsZVJlbmFtZShmaWxlLCBvbGRQYXRoKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5oYW5kbGVGaWxlUmVuYW1lKGZpbGUsIG9sZFBhdGgpO1xuXHRcdFx0fSkpO1xuXHR9XG5cblx0cHJpdmF0ZSBzaG91bGRQcm9jZXNzRmlsZShmaWxlOiBURmlsZSk6IGJvb2xlYW4ge1xuXHRcdC8vIEZpcnN0IGNoZWNrIGlmIGJhc2ljIHJlcXVpcmVtZW50cyBhcmUgbWV0XG5cdFx0aWYgKCF0aGlzLnF1ZXVlU2VydmljZSB8fCAhaXNWYXVsdEluaXRpYWxpemVkKHRoaXMuc2V0dGluZ3MpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLmVuYWJsZUF1dG9TeW5jKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIGV4Y2x1c2lvbnMgc2V0dGluZ3MgZXhpc3Qgd2l0aCBmYWxsYmFja3Ncblx0XHRjb25zdCBleGNsdXNpb25zID0gdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zIHx8IHtcblx0XHRcdGV4Y2x1ZGVkRmlsZXM6IFtdLFxuXHRcdFx0ZXhjbHVkZWRGb2xkZXJzOiBbXSxcblx0XHRcdGV4Y2x1ZGVkRmlsZVR5cGVzOiBbXSxcblx0XHRcdGV4Y2x1ZGVkRmlsZVByZWZpeGVzOiBbXVxuXHRcdH07XG5cblx0XHRjb25zdCBmaWxlUGF0aCA9IGZpbGUucGF0aDtcblx0XHRjb25zdCBmaWxlTmFtZSA9IGZpbGUubmFtZTtcblxuXHRcdC8vIENoZWNrIHNwZWNpZmljIGV4Y2x1ZGVkIGZpbGVzXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVzKSAmJlxuXHRcdFx0ZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVzLmluY2x1ZGVzKGZpbGVOYW1lKSkge1xuXHRcdFx0Y29uc29sZS5sb2coJ1NraXBwaW5nIGV4Y2x1ZGVkIGZpbGU6JywgZmlsZU5hbWUpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGV4Y2x1ZGVkIGZvbGRlcnNcblx0XHRpZiAoQXJyYXkuaXNBcnJheShleGNsdXNpb25zLmV4Y2x1ZGVkRm9sZGVycykpIHtcblx0XHRcdGNvbnN0IGlzRXhjbHVkZWRGb2xkZXIgPSBleGNsdXNpb25zLmV4Y2x1ZGVkRm9sZGVycy5zb21lKGZvbGRlciA9PiB7XG5cdFx0XHRcdGNvbnN0IG5vcm1hbGl6ZWRGb2xkZXIgPSBmb2xkZXIuZW5kc1dpdGgoJy8nKSA/IGZvbGRlciA6IGZvbGRlciArICcvJztcblx0XHRcdFx0cmV0dXJuIGZpbGVQYXRoLnN0YXJ0c1dpdGgobm9ybWFsaXplZEZvbGRlcik7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChpc0V4Y2x1ZGVkRm9sZGVyKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdTa2lwcGluZyBmaWxlIGluIGV4Y2x1ZGVkIGZvbGRlcjonLCBmaWxlUGF0aCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDaGVjayBleGNsdWRlZCBmaWxlIHR5cGVzXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcykpIHtcblx0XHRcdGNvbnN0IGlzRXhjbHVkZWRUeXBlID0gZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcy5zb21lKFxuXHRcdFx0XHRleHQgPT4gZmlsZVBhdGgudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQudG9Mb3dlckNhc2UoKSlcblx0XHRcdCk7XG5cdFx0XHRpZiAoaXNFeGNsdWRlZFR5cGUpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ1NraXBwaW5nIGV4Y2x1ZGVkIGZpbGUgdHlwZTonLCBmaWxlUGF0aCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDaGVjayBleGNsdWRlZCBmaWxlIHByZWZpeGVzXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVQcmVmaXhlcykpIHtcblx0XHRcdGNvbnN0IGlzRXhjbHVkZWRQcmVmaXggPSBleGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVByZWZpeGVzLnNvbWUoXG5cdFx0XHRcdHByZWZpeCA9PiBmaWxlTmFtZS5zdGFydHNXaXRoKHByZWZpeClcblx0XHRcdCk7XG5cdFx0XHRpZiAoaXNFeGNsdWRlZFByZWZpeCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnU2tpcHBpbmcgZmlsZSB3aXRoIGV4Y2x1ZGVkIHByZWZpeDonLCBmaWxlTmFtZSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgZW5zdXJlU3luY0ZpbGVFeGlzdHMoKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0aWYgKCF0aGlzLnN5bmNNYW5hZ2VyKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdTeW5jIG1hbmFnZXIgbm90IGluaXRpYWxpemVkJyk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHN5bmNGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMuc2V0dGluZ3Muc3luYy5zeW5jRmlsZVBhdGgpO1xuXHRcdFx0aWYgKCFzeW5jRmlsZSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnU3luYyBmaWxlIG1pc3NpbmcsIHJlY3JlYXRpbmcuLi4nKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5zeW5jTWFuYWdlci5pbml0aWFsaXplKCk7XG5cdFx0XHRcdG5ldyBOb3RpY2UoJ1JlY3JlYXRlZCBzeW5jIGZpbGUnKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgZW5zdXJpbmcgc3luYyBmaWxlIGV4aXN0czonLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBxdWV1ZUZpbGVQcm9jZXNzaW5nKGZpbGU6IFRGaWxlLCB0eXBlOiAnQ1JFQVRFJyB8ICdVUERBVEUnIHwgJ0RFTEVURScpIHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCF0aGlzLnF1ZXVlU2VydmljZSB8fCAhdGhpcy5maWxlVHJhY2tlcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdSZXF1aXJlZCBzZXJ2aWNlcyBub3QgaW5pdGlhbGl6ZWQ6Jywge1xuXHRcdFx0XHRcdHF1ZXVlU2VydmljZTogISF0aGlzLnF1ZXVlU2VydmljZSxcblx0XHRcdFx0XHRmaWxlVHJhY2tlcjogISF0aGlzLmZpbGVUcmFja2VyXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnNvbGUubG9nKCdTdGFydGluZyBmaWxlIHByb2Nlc3Npbmc6Jywge1xuXHRcdFx0XHRmaWxlTmFtZTogZmlsZS5uYW1lLFxuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRwYXRoOiBmaWxlLnBhdGhcblx0XHRcdH0pO1xuXG5cdFx0XHRjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuZmlsZVRyYWNrZXIuY3JlYXRlRmlsZU1ldGFkYXRhKGZpbGUpO1xuXHRcdFx0Y29uc29sZS5sb2coJ0NyZWF0ZWQgbWV0YWRhdGE6JywgbWV0YWRhdGEpO1xuXG5cdFx0XHRjb25zdCB0YXNrID0ge1xuXHRcdFx0XHRpZDogZmlsZS5wYXRoLFxuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRwcmlvcml0eTogdHlwZSA9PT0gJ0RFTEVURScgPyAyIDogMSxcblx0XHRcdFx0bWF4UmV0cmllczogdGhpcy5zZXR0aW5ncy5xdWV1ZS5yZXRyeUF0dGVtcHRzLFxuXHRcdFx0XHRyZXRyeUNvdW50OiAwLFxuXHRcdFx0XHRjcmVhdGVkQXQ6IERhdGUubm93KCksXG5cdFx0XHRcdHVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcblx0XHRcdFx0c3RhdHVzOiAnUEVORElORycsXG5cdFx0XHRcdG1ldGFkYXRhLFxuXHRcdFx0XHRkYXRhOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0Y29uc29sZS5sb2coJ0NyZWF0ZWQgdGFzazonLCB0YXNrKTtcblx0XHRcdGF3YWl0IHRoaXMucXVldWVTZXJ2aWNlLmFkZFRhc2sodGFzayk7XG5cdFx0XHRjb25zb2xlLmxvZygnVGFzayBhZGRlZCB0byBxdWV1ZScpO1xuXG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSB7XG5cdFx0XHRcdGNvbnN0IGFjdGlvbiA9IHR5cGUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0bmV3IE5vdGljZShgUXVldWVkICR7YWN0aW9ufSBmb3IgcHJvY2Vzc2luZzogJHtmaWxlLm5hbWV9YCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHF1ZXVlRmlsZVByb2Nlc3Npbmc6JywgZXJyb3IpO1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXI/LmhhbmRsZUVycm9yKGVycm9yLCB7XG5cdFx0XHRcdGNvbnRleHQ6ICdxdWV1ZUZpbGVQcm9jZXNzaW5nJyxcblx0XHRcdFx0bWV0YWRhdGE6IHsgZmlsZVBhdGg6IGZpbGUucGF0aCwgdHlwZSB9XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuZW5hYmxlTm90aWZpY2F0aW9ucykge1xuXHRcdFx0XHRuZXcgTm90aWNlKGBGYWlsZWQgdG8gcXVldWUgJHtmaWxlLm5hbWV9IGZvciBwcm9jZXNzaW5nYCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBoYW5kbGVGaWxlUmVuYW1lKGZpbGU6IFRGaWxlLCBvbGRQYXRoOiBzdHJpbmcpIHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCF0aGlzLnN1cGFiYXNlU2VydmljZSkgcmV0dXJuO1xuXG5cdFx0XHRjb25zdCBjaHVua3MgPSBhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS5nZXREb2N1bWVudENodW5rcyhvbGRQYXRoKTtcblx0XHRcdGlmIChjaHVua3MubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRjb25zdCB1cGRhdGVkQ2h1bmtzID0gY2h1bmtzLm1hcChjaHVuayA9PiAoe1xuXHRcdFx0XHRcdC4uLmNodW5rLFxuXHRcdFx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdFx0XHQuLi5jaHVuay5tZXRhZGF0YSxcblx0XHRcdFx0XHRcdG9ic2lkaWFuSWQ6IGZpbGUucGF0aCxcblx0XHRcdFx0XHRcdHBhdGg6IGZpbGUucGF0aFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkpO1xuXG5cdFx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLmRlbGV0ZURvY3VtZW50Q2h1bmtzKG9sZFBhdGgpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS51cHNlcnRDaHVua3ModXBkYXRlZENodW5rcyk7XG5cblx0XHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuZW5hYmxlTm90aWZpY2F0aW9ucykge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYFVwZGF0ZWQgZGF0YWJhc2UgZW50cmllcyBmb3IgcmVuYW1lZCBmaWxlOiAke2ZpbGUubmFtZX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlcj8uaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ2hhbmRsZUZpbGVSZW5hbWUnLFxuXHRcdFx0XHRtZXRhZGF0YTogeyBmaWxlUGF0aDogZmlsZS5wYXRoLCBvbGRQYXRoIH1cblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byB1cGRhdGUgZGF0YWJhc2UgZm9yIHJlbmFtZWQgZmlsZTogJHtmaWxlLm5hbWV9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhZGRDb21tYW5kcygpIHtcblx0XHQvLyBGb3JjZSBzeW5jIGN1cnJlbnQgZmlsZVxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ2ZvcmNlLXN5bmMtY3VycmVudC1maWxlJyxcblx0XHRcdG5hbWU6ICdGb3JjZSBzeW5jIGN1cnJlbnQgZmlsZScsXG5cdFx0XHRjaGVja0NhbGxiYWNrOiAoY2hlY2tpbmc6IGJvb2xlYW4pID0+IHtcblx0XHRcdFx0Y29uc3QgZmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG5cdFx0XHRcdGlmIChmaWxlKSB7XG5cdFx0XHRcdFx0aWYgKCFjaGVja2luZykge1xuXHRcdFx0XHRcdFx0dGhpcy5xdWV1ZUZpbGVQcm9jZXNzaW5nKGZpbGUsICdVUERBVEUnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRm9yY2Ugc3luYyBhbGwgZmlsZXNcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6ICdmb3JjZS1zeW5jLWFsbC1maWxlcycsXG5cdFx0XHRuYW1lOiAnRm9yY2Ugc3luYyBhbGwgZmlsZXMnLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0Y29uc3QgZmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG5cdFx0XHRcdGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuXHRcdFx0XHRcdGlmICh0aGlzLnNob3VsZFByb2Nlc3NGaWxlKGZpbGUpKSB7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnF1ZXVlRmlsZVByb2Nlc3NpbmcoZmlsZSwgJ1VQREFURScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQ2xlYXIgc3luYyBxdWV1ZVxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ2NsZWFyLXN5bmMtcXVldWUnLFxuXHRcdFx0bmFtZTogJ0NsZWFyIHN5bmMgcXVldWUnLFxuXHRcdFx0Y2FsbGJhY2s6ICgpID0+IHtcblx0XHRcdFx0dGhpcy5xdWV1ZVNlcnZpY2U/LmNsZWFyKCk7XG5cdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKCdTeW5jIHF1ZXVlIGNsZWFyZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gUmVzZXQgZmlsZSB0cmFja2VyIGNhY2hlXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAncmVzZXQtZmlsZS10cmFja2VyJyxcblx0XHRcdG5hbWU6ICdSZXNldCBmaWxlIHRyYWNrZXIgY2FjaGUnLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0dGhpcy5maWxlVHJhY2tlcj8uY2xlYXJDYWNoZSgpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLmZpbGVUcmFja2VyPy5pbml0aWFsaXplKCk7XG5cdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKCdGaWxlIHRyYWNrZXIgY2FjaGUgcmVzZXQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gU3RhcnQgaW5pdGlhbCBzeW5jXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAnc3RhcnQtaW5pdGlhbC1zeW5jJyxcblx0XHRcdG5hbWU6ICdTdGFydCBpbml0aWFsIHZhdWx0IHN5bmMnLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0aWYgKHRoaXMuaW5pdGlhbFN5bmNNYW5hZ2VyKSB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5pbml0aWFsU3luY01hbmFnZXIuc3RhcnRTeW5jKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnSW5pdGlhbCBzeW5jIG1hbmFnZXIgbm90IGluaXRpYWxpemVkJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIFN0b3AgaW5pdGlhbCBzeW5jXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAnc3RvcC1pbml0aWFsLXN5bmMnLFxuXHRcdFx0bmFtZTogJ1N0b3AgaW5pdGlhbCB2YXVsdCBzeW5jJyxcblx0XHRcdGNhbGxiYWNrOiAoKSA9PiB7XG5cdFx0XHRcdHRoaXMuaW5pdGlhbFN5bmNNYW5hZ2VyPy5zdG9wKCk7XG5cdFx0XHRcdG5ldyBOb3RpY2UoJ0luaXRpYWwgc3luYyBzdG9wcGVkJyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBGZXRjaCB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2g/OiBGZXRjaCk6IEZldGNoID0+IHtcbiAgbGV0IF9mZXRjaDogRmV0Y2hcbiAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgX2ZldGNoID0gY3VzdG9tRmV0Y2hcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgX2ZldGNoID0gKC4uLmFyZ3MpID0+XG4gICAgICBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJyBhcyBhbnkpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT4gZmV0Y2goLi4uYXJncykpXG4gIH0gZWxzZSB7XG4gICAgX2ZldGNoID0gZmV0Y2hcbiAgfVxuICByZXR1cm4gKC4uLmFyZ3MpID0+IF9mZXRjaCguLi5hcmdzKVxufVxuIiwgImV4cG9ydCB0eXBlIEZldGNoID0gdHlwZW9mIGZldGNoXG5cbi8qKlxuICogUmVzcG9uc2UgZm9ybWF0XG4gKlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uc1Jlc3BvbnNlU3VjY2VzczxUPiB7XG4gIGRhdGE6IFRcbiAgZXJyb3I6IG51bGxcbn1cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25zUmVzcG9uc2VGYWlsdXJlIHtcbiAgZGF0YTogbnVsbFxuICBlcnJvcjogYW55XG59XG5leHBvcnQgdHlwZSBGdW5jdGlvbnNSZXNwb25zZTxUPiA9IEZ1bmN0aW9uc1Jlc3BvbnNlU3VjY2VzczxUPiB8IEZ1bmN0aW9uc1Jlc3BvbnNlRmFpbHVyZVxuXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnRleHQ6IGFueVxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIG5hbWUgPSAnRnVuY3Rpb25zRXJyb3InLCBjb250ZXh0PzogYW55KSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dFxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNGZXRjaEVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0OiBhbnkpIHtcbiAgICBzdXBlcignRmFpbGVkIHRvIHNlbmQgYSByZXF1ZXN0IHRvIHRoZSBFZGdlIEZ1bmN0aW9uJywgJ0Z1bmN0aW9uc0ZldGNoRXJyb3InLCBjb250ZXh0KVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNSZWxheUVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0OiBhbnkpIHtcbiAgICBzdXBlcignUmVsYXkgRXJyb3IgaW52b2tpbmcgdGhlIEVkZ2UgRnVuY3Rpb24nLCAnRnVuY3Rpb25zUmVsYXlFcnJvcicsIGNvbnRleHQpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0h0dHBFcnJvciBleHRlbmRzIEZ1bmN0aW9uc0Vycm9yIHtcbiAgY29uc3RydWN0b3IoY29udGV4dDogYW55KSB7XG4gICAgc3VwZXIoJ0VkZ2UgRnVuY3Rpb24gcmV0dXJuZWQgYSBub24tMnh4IHN0YXR1cyBjb2RlJywgJ0Z1bmN0aW9uc0h0dHBFcnJvcicsIGNvbnRleHQpXG4gIH1cbn1cbi8vIERlZmluZSB0aGUgZW51bSBmb3IgdGhlICdyZWdpb24nIHByb3BlcnR5XG5leHBvcnQgZW51bSBGdW5jdGlvblJlZ2lvbiB7XG4gIEFueSA9ICdhbnknLFxuICBBcE5vcnRoZWFzdDEgPSAnYXAtbm9ydGhlYXN0LTEnLFxuICBBcE5vcnRoZWFzdDIgPSAnYXAtbm9ydGhlYXN0LTInLFxuICBBcFNvdXRoMSA9ICdhcC1zb3V0aC0xJyxcbiAgQXBTb3V0aGVhc3QxID0gJ2FwLXNvdXRoZWFzdC0xJyxcbiAgQXBTb3V0aGVhc3QyID0gJ2FwLXNvdXRoZWFzdC0yJyxcbiAgQ2FDZW50cmFsMSA9ICdjYS1jZW50cmFsLTEnLFxuICBFdUNlbnRyYWwxID0gJ2V1LWNlbnRyYWwtMScsXG4gIEV1V2VzdDEgPSAnZXUtd2VzdC0xJyxcbiAgRXVXZXN0MiA9ICdldS13ZXN0LTInLFxuICBFdVdlc3QzID0gJ2V1LXdlc3QtMycsXG4gIFNhRWFzdDEgPSAnc2EtZWFzdC0xJyxcbiAgVXNFYXN0MSA9ICd1cy1lYXN0LTEnLFxuICBVc1dlc3QxID0gJ3VzLXdlc3QtMScsXG4gIFVzV2VzdDIgPSAndXMtd2VzdC0yJyxcbn1cblxuZXhwb3J0IHR5cGUgRnVuY3Rpb25JbnZva2VPcHRpb25zID0ge1xuICAvKipcbiAgICogT2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaGVhZGVycyB0byBzZW5kIHdpdGggdGhlIHJlcXVlc3QuXG4gICAqICovXG4gIGhlYWRlcnM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gIC8qKlxuICAgKiBUaGUgSFRUUCB2ZXJiIG9mIHRoZSByZXF1ZXN0XG4gICAqL1xuICBtZXRob2Q/OiAnUE9TVCcgfCAnR0VUJyB8ICdQVVQnIHwgJ1BBVENIJyB8ICdERUxFVEUnXG4gIC8qKlxuICAgKiBUaGUgUmVnaW9uIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gaW4uXG4gICAqL1xuICByZWdpb24/OiBGdW5jdGlvblJlZ2lvblxuICAvKipcbiAgICogVGhlIGJvZHkgb2YgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBib2R5PzpcbiAgICB8IEZpbGVcbiAgICB8IEJsb2JcbiAgICB8IEFycmF5QnVmZmVyXG4gICAgfCBGb3JtRGF0YVxuICAgIHwgUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbiAgICB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICB8IHN0cmluZ1xufVxuIiwgImltcG9ydCB7IHJlc29sdmVGZXRjaCB9IGZyb20gJy4vaGVscGVyJ1xuaW1wb3J0IHtcbiAgRmV0Y2gsXG4gIEZ1bmN0aW9uc0ZldGNoRXJyb3IsXG4gIEZ1bmN0aW9uc0h0dHBFcnJvcixcbiAgRnVuY3Rpb25zUmVsYXlFcnJvcixcbiAgRnVuY3Rpb25zUmVzcG9uc2UsXG4gIEZ1bmN0aW9uSW52b2tlT3B0aW9ucyxcbiAgRnVuY3Rpb25SZWdpb24sXG59IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNDbGllbnQge1xuICBwcm90ZWN0ZWQgdXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgcHJvdGVjdGVkIHJlZ2lvbjogRnVuY3Rpb25SZWdpb25cbiAgcHJvdGVjdGVkIGZldGNoOiBGZXRjaFxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHVybDogc3RyaW5nLFxuICAgIHtcbiAgICAgIGhlYWRlcnMgPSB7fSxcbiAgICAgIGN1c3RvbUZldGNoLFxuICAgICAgcmVnaW9uID0gRnVuY3Rpb25SZWdpb24uQW55LFxuICAgIH06IHtcbiAgICAgIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICAgICBjdXN0b21GZXRjaD86IEZldGNoXG4gICAgICByZWdpb24/OiBGdW5jdGlvblJlZ2lvblxuICAgIH0gPSB7fVxuICApIHtcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnNcbiAgICB0aGlzLnJlZ2lvbiA9IHJlZ2lvblxuICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goY3VzdG9tRmV0Y2gpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICogQHBhcmFtIHRva2VuIC0gdGhlIG5ldyBqd3QgdG9rZW4gc2VudCBpbiB0aGUgYXV0aG9yaXNhdGlvbiBoZWFkZXJcbiAgICovXG4gIHNldEF1dGgodG9rZW46IHN0cmluZykge1xuICAgIHRoaXMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWBcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGEgZnVuY3Rpb25cbiAgICogQHBhcmFtIGZ1bmN0aW9uTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBGdW5jdGlvbiB0byBpbnZva2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgaW52b2tpbmcgdGhlIEZ1bmN0aW9uLlxuICAgKi9cbiAgYXN5bmMgaW52b2tlPFQgPSBhbnk+KFxuICAgIGZ1bmN0aW9uTmFtZTogc3RyaW5nLFxuICAgIG9wdGlvbnM6IEZ1bmN0aW9uSW52b2tlT3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8RnVuY3Rpb25zUmVzcG9uc2U8VD4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBoZWFkZXJzLCBtZXRob2QsIGJvZHk6IGZ1bmN0aW9uQXJncyB9ID0gb3B0aW9uc1xuICAgICAgbGV0IF9oZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbiAgICAgIGxldCB7IHJlZ2lvbiB9ID0gb3B0aW9uc1xuICAgICAgaWYgKCFyZWdpb24pIHtcbiAgICAgICAgcmVnaW9uID0gdGhpcy5yZWdpb25cbiAgICAgIH1cbiAgICAgIGlmIChyZWdpb24gJiYgcmVnaW9uICE9PSAnYW55Jykge1xuICAgICAgICBfaGVhZGVyc1sneC1yZWdpb24nXSA9IHJlZ2lvblxuICAgICAgfVxuICAgICAgbGV0IGJvZHk6IGFueVxuICAgICAgaWYgKFxuICAgICAgICBmdW5jdGlvbkFyZ3MgJiZcbiAgICAgICAgKChoZWFkZXJzICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpKSB8fCAhaGVhZGVycylcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAgIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIHdpbGwgd29yayBmb3IgRmlsZSBhcyBGaWxlIGluaGVyaXRzIEJsb2JcbiAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBBcnJheUJ1ZmZlciBhcyBpdCBpcyB0aGUgc2FtZSB1bmRlcmx5aW5nIHN0cnVjdHVyZSBhcyBhIEJsb2JcbiAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ1xuICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3NcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZnVuY3Rpb25BcmdzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIHBsYWluIHN0cmluZ1xuICAgICAgICAgIF9oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICd0ZXh0L3BsYWluJ1xuICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3NcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgLy8gZG9uJ3Qgc2V0IGNvbnRlbnQtdHlwZSBoZWFkZXJzXG4gICAgICAgICAgLy8gUmVxdWVzdCB3aWxsIGF1dG9tYXRpY2FsbHkgYWRkIHRoZSByaWdodCBib3VuZGFyeSB2YWx1ZVxuICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3NcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWZhdWx0LCBhc3N1bWUgdGhpcyBpcyBKU09OXG4gICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KGZ1bmN0aW9uQXJncylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2goYCR7dGhpcy51cmx9LyR7ZnVuY3Rpb25OYW1lfWAsIHtcbiAgICAgICAgbWV0aG9kOiBtZXRob2QgfHwgJ1BPU1QnLFxuICAgICAgICAvLyBoZWFkZXJzIHByaW9yaXR5IGlzIChoaWdoIHRvIGxvdyk6XG4gICAgICAgIC8vIDEuIGludm9rZS1sZXZlbCBoZWFkZXJzXG4gICAgICAgIC8vIDIuIGNsaWVudC1sZXZlbCBoZWFkZXJzXG4gICAgICAgIC8vIDMuIGRlZmF1bHQgQ29udGVudC1UeXBlIGhlYWRlclxuICAgICAgICBoZWFkZXJzOiB7IC4uLl9oZWFkZXJzLCAuLi50aGlzLmhlYWRlcnMsIC4uLmhlYWRlcnMgfSxcbiAgICAgICAgYm9keSxcbiAgICAgIH0pLmNhdGNoKChmZXRjaEVycm9yKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNGZXRjaEVycm9yKGZldGNoRXJyb3IpXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBpc1JlbGF5RXJyb3IgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1yZWxheS1lcnJvcicpXG4gICAgICBpZiAoaXNSZWxheUVycm9yICYmIGlzUmVsYXlFcnJvciA9PT0gJ3RydWUnKSB7XG4gICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNSZWxheUVycm9yKHJlc3BvbnNlKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNIdHRwRXJyb3IocmVzcG9uc2UpXG4gICAgICB9XG5cbiAgICAgIGxldCByZXNwb25zZVR5cGUgPSAocmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpID8/ICd0ZXh0L3BsYWluJykuc3BsaXQoJzsnKVswXS50cmltKClcbiAgICAgIGxldCBkYXRhOiBhbnlcbiAgICAgIGlmIChyZXNwb25zZVR5cGUgPT09ICdhcHBsaWNhdGlvbi9qc29uJykge1xuICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKVxuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICd0ZXh0L2V2ZW50LXN0cmVhbScpIHtcbiAgICAgICAgZGF0YSA9IHJlc3BvbnNlXG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ211bHRpcGFydC9mb3JtLWRhdGEnKSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5mb3JtRGF0YSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IHRvIHRleHRcbiAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgaW5kZXggZnJvbSAnLi4vY2pzL2luZGV4LmpzJ1xuY29uc3Qge1xuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbiAgUG9zdGdyZXN0QnVpbGRlcixcbiAgUG9zdGdyZXN0RXJyb3IsXG59ID0gaW5kZXhcblxuZXhwb3J0IHtcbiAgUG9zdGdyZXN0QnVpbGRlcixcbiAgUG9zdGdyZXN0Q2xpZW50LFxuICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuICBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIsXG4gIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIsXG4gIFBvc3RncmVzdEVycm9yLFxufVxuXG4vLyBjb21wYXRpYmlsaXR5IHdpdGggQ0pTIG91dHB1dFxuZXhwb3J0IGRlZmF1bHQge1xuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbiAgUG9zdGdyZXN0QnVpbGRlcixcbiAgUG9zdGdyZXN0RXJyb3IsXG59XG4iLCAiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMi4xMS4yJ1xuIiwgImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nXG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYHJlYWx0aW1lLWpzLyR7dmVyc2lvbn1gIH1cblxuZXhwb3J0IGNvbnN0IFZTTjogc3RyaW5nID0gJzEuMC4wJ1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9USU1FT1VUID0gMTAwMDBcblxuZXhwb3J0IGNvbnN0IFdTX0NMT1NFX05PUk1BTCA9IDEwMDBcblxuZXhwb3J0IGVudW0gU09DS0VUX1NUQVRFUyB7XG4gIGNvbm5lY3RpbmcgPSAwLFxuICBvcGVuID0gMSxcbiAgY2xvc2luZyA9IDIsXG4gIGNsb3NlZCA9IDMsXG59XG5cbmV4cG9ydCBlbnVtIENIQU5ORUxfU1RBVEVTIHtcbiAgY2xvc2VkID0gJ2Nsb3NlZCcsXG4gIGVycm9yZWQgPSAnZXJyb3JlZCcsXG4gIGpvaW5lZCA9ICdqb2luZWQnLFxuICBqb2luaW5nID0gJ2pvaW5pbmcnLFxuICBsZWF2aW5nID0gJ2xlYXZpbmcnLFxufVxuXG5leHBvcnQgZW51bSBDSEFOTkVMX0VWRU5UUyB7XG4gIGNsb3NlID0gJ3BoeF9jbG9zZScsXG4gIGVycm9yID0gJ3BoeF9lcnJvcicsXG4gIGpvaW4gPSAncGh4X2pvaW4nLFxuICByZXBseSA9ICdwaHhfcmVwbHknLFxuICBsZWF2ZSA9ICdwaHhfbGVhdmUnLFxuICBhY2Nlc3NfdG9rZW4gPSAnYWNjZXNzX3Rva2VuJyxcbn1cblxuZXhwb3J0IGVudW0gVFJBTlNQT1JUUyB7XG4gIHdlYnNvY2tldCA9ICd3ZWJzb2NrZXQnLFxufVxuXG5leHBvcnQgZW51bSBDT05ORUNUSU9OX1NUQVRFIHtcbiAgQ29ubmVjdGluZyA9ICdjb25uZWN0aW5nJyxcbiAgT3BlbiA9ICdvcGVuJyxcbiAgQ2xvc2luZyA9ICdjbG9zaW5nJyxcbiAgQ2xvc2VkID0gJ2Nsb3NlZCcsXG59XG4iLCAiLy8gVGhpcyBmaWxlIGRyYXdzIGhlYXZpbHkgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2NvbW1pdC9jZjA5OGU5Y2Y3YTQ0ZWU2NDc5ZDMxZDkxMWE5N2QzYzc0MzBjNmZlXG4vLyBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VyaWFsaXplciB7XG4gIEhFQURFUl9MRU5HVEggPSAxXG5cbiAgZGVjb2RlKHJhd1BheWxvYWQ6IEFycmF5QnVmZmVyIHwgc3RyaW5nLCBjYWxsYmFjazogRnVuY3Rpb24pIHtcbiAgICBpZiAocmF3UGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9iaW5hcnlEZWNvZGUocmF3UGF5bG9hZCkpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByYXdQYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKEpTT04ucGFyc2UocmF3UGF5bG9hZCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGxiYWNrKHt9KVxuICB9XG5cbiAgcHJpdmF0ZSBfYmluYXJ5RGVjb2RlKGJ1ZmZlcjogQXJyYXlCdWZmZXIpIHtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcilcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcblxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVCcm9hZGNhc3QoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKVxuICB9XG5cbiAgcHJpdmF0ZSBfZGVjb2RlQnJvYWRjYXN0KFxuICAgIGJ1ZmZlcjogQXJyYXlCdWZmZXIsXG4gICAgdmlldzogRGF0YVZpZXcsXG4gICAgZGVjb2RlcjogVGV4dERlY29kZXJcbiAgKToge1xuICAgIHJlZjogbnVsbFxuICAgIHRvcGljOiBzdHJpbmdcbiAgICBldmVudDogc3RyaW5nXG4gICAgcGF5bG9hZDogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICB9IHtcbiAgICBjb25zdCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDEpXG4gICAgY29uc3QgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCgyKVxuICAgIGxldCBvZmZzZXQgPSB0aGlzLkhFQURFUl9MRU5HVEggKyAyXG4gICAgY29uc3QgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZVxuICAgIGNvbnN0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemVcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShcbiAgICAgIGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKSlcbiAgICApXG5cbiAgICByZXR1cm4geyByZWY6IG51bGwsIHRvcGljOiB0b3BpYywgZXZlbnQ6IGV2ZW50LCBwYXlsb2FkOiBkYXRhIH1cbiAgfVxufVxuIiwgIi8qKlxuICogQ3JlYXRlcyBhIHRpbWVyIHRoYXQgYWNjZXB0cyBhIGB0aW1lckNhbGNgIGZ1bmN0aW9uIHRvIHBlcmZvcm0gY2FsY3VsYXRlZCB0aW1lb3V0IHJldHJpZXMsIHN1Y2ggYXMgZXhwb25lbnRpYWwgYmFja29mZi5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgbGV0IHJlY29ubmVjdFRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHRoaXMuY29ubmVjdCgpLCBmdW5jdGlvbih0cmllcyl7XG4gKiAgICAgIHJldHVybiBbMTAwMCwgNTAwMCwgMTAwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAqICAgIH0pXG4gKiAgICByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciAxMDAwXG4gKiAgICByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciA1MDAwXG4gKiAgICByZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gKiAgICByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciAxMDAwXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVyIHtcbiAgdGltZXI6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICB0cmllczogbnVtYmVyID0gMFxuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBjYWxsYmFjazogRnVuY3Rpb24sIHB1YmxpYyB0aW1lckNhbGM6IEZ1bmN0aW9uKSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy50aW1lckNhbGMgPSB0aW1lckNhbGNcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMudHJpZXMgPSAwXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpXG4gIH1cblxuICAvLyBDYW5jZWxzIGFueSBwcmV2aW91cyBzY2hlZHVsZVRpbWVvdXQgYW5kIHNjaGVkdWxlcyBjYWxsYmFja1xuICBzY2hlZHVsZVRpbWVvdXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpXG5cbiAgICB0aGlzLnRpbWVyID0gPGFueT5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJpZXMgPSB0aGlzLnRyaWVzICsgMVxuICAgICAgdGhpcy5jYWxsYmFjaygpXG4gICAgfSwgdGhpcy50aW1lckNhbGModGhpcy50cmllcyArIDEpKVxuICB9XG59XG4iLCAiLyoqXG4gKiBIZWxwZXJzIHRvIGNvbnZlcnQgdGhlIGNoYW5nZSBQYXlsb2FkIGludG8gbmF0aXZlIEpTIHR5cGVzLlxuICovXG5cbi8vIEFkYXB0ZWQgZnJvbSBlcGdzcWwgKHNyYy9lcGdzcWxfYmluYXJ5LmVybCksIHRoaXMgbW9kdWxlIGxpY2Vuc2VkIHVuZGVyXG4vLyAzLWNsYXVzZSBCU0QgZm91bmQgaGVyZTogaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2VwZ3NxbC9lcGdzcWwvZGV2ZWwvTElDRU5TRVxuXG5leHBvcnQgZW51bSBQb3N0Z3Jlc1R5cGVzIHtcbiAgYWJzdGltZSA9ICdhYnN0aW1lJyxcbiAgYm9vbCA9ICdib29sJyxcbiAgZGF0ZSA9ICdkYXRlJyxcbiAgZGF0ZXJhbmdlID0gJ2RhdGVyYW5nZScsXG4gIGZsb2F0NCA9ICdmbG9hdDQnLFxuICBmbG9hdDggPSAnZmxvYXQ4JyxcbiAgaW50MiA9ICdpbnQyJyxcbiAgaW50NCA9ICdpbnQ0JyxcbiAgaW50NHJhbmdlID0gJ2ludDRyYW5nZScsXG4gIGludDggPSAnaW50OCcsXG4gIGludDhyYW5nZSA9ICdpbnQ4cmFuZ2UnLFxuICBqc29uID0gJ2pzb24nLFxuICBqc29uYiA9ICdqc29uYicsXG4gIG1vbmV5ID0gJ21vbmV5JyxcbiAgbnVtZXJpYyA9ICdudW1lcmljJyxcbiAgb2lkID0gJ29pZCcsXG4gIHJlbHRpbWUgPSAncmVsdGltZScsXG4gIHRleHQgPSAndGV4dCcsXG4gIHRpbWUgPSAndGltZScsXG4gIHRpbWVzdGFtcCA9ICd0aW1lc3RhbXAnLFxuICB0aW1lc3RhbXB0eiA9ICd0aW1lc3RhbXB0eicsXG4gIHRpbWV0eiA9ICd0aW1ldHonLFxuICB0c3JhbmdlID0gJ3RzcmFuZ2UnLFxuICB0c3R6cmFuZ2UgPSAndHN0enJhbmdlJyxcbn1cblxudHlwZSBDb2x1bW5zID0ge1xuICBuYW1lOiBzdHJpbmcgLy8gdGhlIGNvbHVtbiBuYW1lLiBlZzogXCJ1c2VyX2lkXCJcbiAgdHlwZTogc3RyaW5nIC8vIHRoZSBjb2x1bW4gdHlwZS4gZWc6IFwidXVpZFwiXG4gIGZsYWdzPzogc3RyaW5nW10gLy8gYW55IHNwZWNpYWwgZmxhZ3MgZm9yIHRoZSBjb2x1bW4uIGVnOiBbXCJrZXlcIl1cbiAgdHlwZV9tb2RpZmllcj86IG51bWJlciAvLyB0aGUgdHlwZSBtb2RpZmllci4gZWc6IDQyOTQ5NjcyOTVcbn1bXVxuXG50eXBlIEJhc2VWYWx1ZSA9IG51bGwgfCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuXG50eXBlIFJlY29yZFZhbHVlID0gQmFzZVZhbHVlIHwgQmFzZVZhbHVlW11cblxudHlwZSBSZWNvcmQgPSB7XG4gIFtrZXk6IHN0cmluZ106IFJlY29yZFZhbHVlXG59XG5cbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgY29sdW1ucyBhbmQgYW4gb2JqZWN0IG9mIHN0cmluZyB2YWx1ZXMgdGhlbiBjb252ZXJ0cyBlYWNoIHN0cmluZyB2YWx1ZVxuICogdG8gaXRzIG1hcHBlZCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7e25hbWU6IFN0cmluZywgdHlwZTogU3RyaW5nfVtdfSBjb2x1bW5zXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgbWFwIG9mIHZhcmlvdXMgb3B0aW9ucyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIHRoZSBtYXBwZXJcbiAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMuc2tpcFR5cGVzIFRoZSBhcnJheSBvZiB0eXBlcyB0aGF0IHNob3VsZCBub3QgYmUgY29udmVydGVkXG4gKlxuICogQGV4YW1wbGUgY29udmVydENoYW5nZURhdGEoW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTonMzMnfSwge30pXG4gKiAvLz0+eyBmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogMzMgfVxuICovXG5leHBvcnQgY29uc3QgY29udmVydENoYW5nZURhdGEgPSAoXG4gIGNvbHVtbnM6IENvbHVtbnMsXG4gIHJlY29yZDogUmVjb3JkLFxuICBvcHRpb25zOiB7IHNraXBUeXBlcz86IHN0cmluZ1tdIH0gPSB7fVxuKTogUmVjb3JkID0+IHtcbiAgY29uc3Qgc2tpcFR5cGVzID0gb3B0aW9ucy5za2lwVHlwZXMgPz8gW11cblxuICByZXR1cm4gT2JqZWN0LmtleXMocmVjb3JkKS5yZWR1Y2UoKGFjYywgcmVjX2tleSkgPT4ge1xuICAgIGFjY1tyZWNfa2V5XSA9IGNvbnZlcnRDb2x1bW4ocmVjX2tleSwgY29sdW1ucywgcmVjb3JkLCBza2lwVHlwZXMpXG4gICAgcmV0dXJuIGFjY1xuICB9LCB7fSBhcyBSZWNvcmQpXG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHZhbHVlIG9mIGFuIGluZGl2aWR1YWwgY29sdW1uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW5OYW1lIFRoZSBjb2x1bW4gdGhhdCB5b3Ugd2FudCB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge3tuYW1lOiBTdHJpbmcsIHR5cGU6IFN0cmluZ31bXX0gY29sdW1ucyBBbGwgb2YgdGhlIGNvbHVtbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQgVGhlIG1hcCBvZiBzdHJpbmcgdmFsdWVzXG4gKiBAcGFyYW0ge0FycmF5fSBza2lwVHlwZXMgQW4gYXJyYXkgb2YgdHlwZXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbnZlcnRlZFxuICogQHJldHVybiB7b2JqZWN0fSBVc2VsZXNzIGluZm9ybWF0aW9uXG4gKlxuICogQGV4YW1wbGUgY29udmVydENvbHVtbignYWdlJywgW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogJzMzJ30sIFtdKVxuICogLy89PiAzM1xuICogQGV4YW1wbGUgY29udmVydENvbHVtbignYWdlJywgW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogJzMzJ30sIFsnaW50NCddKVxuICogLy89PiBcIjMzXCJcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRDb2x1bW4gPSAoXG4gIGNvbHVtbk5hbWU6IHN0cmluZyxcbiAgY29sdW1uczogQ29sdW1ucyxcbiAgcmVjb3JkOiBSZWNvcmQsXG4gIHNraXBUeXBlczogc3RyaW5nW11cbik6IFJlY29yZFZhbHVlID0+IHtcbiAgY29uc3QgY29sdW1uID0gY29sdW1ucy5maW5kKCh4KSA9PiB4Lm5hbWUgPT09IGNvbHVtbk5hbWUpXG4gIGNvbnN0IGNvbFR5cGUgPSBjb2x1bW4/LnR5cGVcbiAgY29uc3QgdmFsdWUgPSByZWNvcmRbY29sdW1uTmFtZV1cblxuICBpZiAoY29sVHlwZSAmJiAhc2tpcFR5cGVzLmluY2x1ZGVzKGNvbFR5cGUpKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRDZWxsKGNvbFR5cGUsIHZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIG5vb3AodmFsdWUpXG59XG5cbi8qKlxuICogSWYgdGhlIHZhbHVlIG9mIHRoZSBjZWxsIGlzIGBudWxsYCwgcmV0dXJucyBudWxsLlxuICogT3RoZXJ3aXNlIGNvbnZlcnRzIHRoZSBzdHJpbmcgdmFsdWUgdG8gdGhlIGNvcnJlY3QgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgcG9zdGdyZXMgY29sdW1uIHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgY2VsbCB2YWx1ZVxuICpcbiAqIEBleGFtcGxlIGNvbnZlcnRDZWxsKCdib29sJywgJ3QnKVxuICogLy89PiB0cnVlXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnaW50OCcsICcxMCcpXG4gKiAvLz0+IDEwXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnX2ludDQnLCAnezEsMiwzLDR9JylcbiAqIC8vPT4gWzEsMiwzLDRdXG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0Q2VsbCA9ICh0eXBlOiBzdHJpbmcsIHZhbHVlOiBSZWNvcmRWYWx1ZSk6IFJlY29yZFZhbHVlID0+IHtcbiAgLy8gaWYgZGF0YSB0eXBlIGlzIGFuIGFycmF5XG4gIGlmICh0eXBlLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgY29uc3QgZGF0YVR5cGUgPSB0eXBlLnNsaWNlKDEsIHR5cGUubGVuZ3RoKVxuICAgIHJldHVybiB0b0FycmF5KHZhbHVlLCBkYXRhVHlwZSlcbiAgfVxuXG4gIC8vIElmIG5vdCBudWxsLCBjb252ZXJ0IHRvIGNvcnJlY3QgdHlwZS5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmJvb2w6XG4gICAgICByZXR1cm4gdG9Cb29sZWFuKHZhbHVlKVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5mbG9hdDQ6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmZsb2F0ODpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50MjpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50NDpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50ODpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMubnVtZXJpYzpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMub2lkOlxuICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5qc29uOlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5qc29uYjpcbiAgICAgIHJldHVybiB0b0pzb24odmFsdWUpXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWVzdGFtcDpcbiAgICAgIHJldHVybiB0b1RpbWVzdGFtcFN0cmluZyh2YWx1ZSkgLy8gRm9ybWF0IHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBQb3N0Z1JFU1RcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuYWJzdGltZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5kYXRlOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmRhdGVyYW5nZTpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50NHJhbmdlOlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ4cmFuZ2U6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLm1vbmV5OlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5yZWx0aW1lOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRleHQ6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZXN0YW1wdHo6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZXR6OiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRzcmFuZ2U6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRzdHpyYW5nZTpcbiAgICAgIHJldHVybiBub29wKHZhbHVlKVxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciByZW1haW5pbmcgdHlwZXNcbiAgICAgIHJldHVybiBub29wKHZhbHVlKVxuICB9XG59XG5cbmNvbnN0IG5vb3AgPSAodmFsdWU6IFJlY29yZFZhbHVlKTogUmVjb3JkVmFsdWUgPT4ge1xuICByZXR1cm4gdmFsdWVcbn1cbmV4cG9ydCBjb25zdCB0b0Jvb2xlYW4gPSAodmFsdWU6IFJlY29yZFZhbHVlKTogUmVjb3JkVmFsdWUgPT4ge1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSAndCc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGNhc2UgJ2YnOlxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2YWx1ZVxuICB9XG59XG5leHBvcnQgY29uc3QgdG9OdW1iZXIgPSAodmFsdWU6IFJlY29yZFZhbHVlKTogUmVjb3JkVmFsdWUgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSlcbiAgICBpZiAoIU51bWJlci5pc05hTihwYXJzZWRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZWRWYWx1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cbmV4cG9ydCBjb25zdCB0b0pzb24gPSAodmFsdWU6IFJlY29yZFZhbHVlKTogUmVjb3JkVmFsdWUgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coYEpTT04gcGFyc2UgZXJyb3I6ICR7ZXJyb3J9YClcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBvc3RncmVzIEFycmF5IGludG8gYSBuYXRpdmUgSlMgYXJyYXlcbiAqXG4gKiBAZXhhbXBsZSB0b0FycmF5KCd7fScsICdpbnQ0JylcbiAqIC8vPT4gW11cbiAqIEBleGFtcGxlIHRvQXJyYXkoJ3tcIlsyMDIxLTAxLTAxLDIwMjEtMTItMzEpXCIsXCIoMjAyMS0wMS0wMSwyMDIxLTEyLTMyXVwifScsICdkYXRlcmFuZ2UnKVxuICogLy89PiBbJ1syMDIxLTAxLTAxLDIwMjEtMTItMzEpJywgJygyMDIxLTAxLTAxLDIwMjEtMTItMzJdJ11cbiAqIEBleGFtcGxlIHRvQXJyYXkoWzEsMiwzLDRdLCAnaW50NCcpXG4gKiAvLz0+IFsxLDIsMyw0XVxuICovXG5leHBvcnQgY29uc3QgdG9BcnJheSA9ICh2YWx1ZTogUmVjb3JkVmFsdWUsIHR5cGU6IHN0cmluZyk6IFJlY29yZFZhbHVlID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGNvbnN0IGxhc3RJZHggPSB2YWx1ZS5sZW5ndGggLSAxXG4gIGNvbnN0IGNsb3NlQnJhY2UgPSB2YWx1ZVtsYXN0SWR4XVxuICBjb25zdCBvcGVuQnJhY2UgPSB2YWx1ZVswXVxuXG4gIC8vIENvbmZpcm0gdmFsdWUgaXMgYSBQb3N0Z3JlcyBhcnJheSBieSBjaGVja2luZyBjdXJseSBicmFja2V0c1xuICBpZiAob3BlbkJyYWNlID09PSAneycgJiYgY2xvc2VCcmFjZSA9PT0gJ30nKSB7XG4gICAgbGV0IGFyclxuICAgIGNvbnN0IHZhbFRyaW0gPSB2YWx1ZS5zbGljZSgxLCBsYXN0SWR4KVxuXG4gICAgLy8gVE9ETzogZmluZCBhIGJldHRlciBzb2x1dGlvbiB0byBzZXBhcmF0ZSBQb3N0Z3JlcyBhcnJheSBkYXRhXG4gICAgdHJ5IHtcbiAgICAgIGFyciA9IEpTT04ucGFyc2UoJ1snICsgdmFsVHJpbSArICddJylcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAvLyBXQVJOSU5HOiBzcGxpdHRpbmcgb24gY29tbWEgZG9lcyBub3QgY292ZXIgYWxsIGVkZ2UgY2FzZXNcbiAgICAgIGFyciA9IHZhbFRyaW0gPyB2YWxUcmltLnNwbGl0KCcsJykgOiBbXVxuICAgIH1cblxuICAgIHJldHVybiBhcnIubWFwKCh2YWw6IEJhc2VWYWx1ZSkgPT4gY29udmVydENlbGwodHlwZSwgdmFsKSlcbiAgfVxuXG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEZpeGVzIHRpbWVzdGFtcCB0byBiZSBJU08tODYwMS4gU3dhcHMgdGhlIHNwYWNlIGJldHdlZW4gdGhlIGRhdGUgYW5kIHRpbWUgZm9yIGEgJ1QnXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3N1cGFiYXNlL2lzc3Vlcy8xOFxuICpcbiAqIEBleGFtcGxlIHRvVGltZXN0YW1wU3RyaW5nKCcyMDE5LTA5LTEwIDAwOjAwOjAwJylcbiAqIC8vPT4gJzIwMTktMDktMTBUMDA6MDA6MDAnXG4gKi9cbmV4cG9ydCBjb25zdCB0b1RpbWVzdGFtcFN0cmluZyA9ICh2YWx1ZTogUmVjb3JkVmFsdWUpOiBSZWNvcmRWYWx1ZSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoJyAnLCAnVCcpXG4gIH1cblxuICByZXR1cm4gdmFsdWVcbn1cblxuZXhwb3J0IGNvbnN0IGh0dHBFbmRwb2ludFVSTCA9IChzb2NrZXRVcmw6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGxldCB1cmwgPSBzb2NrZXRVcmxcbiAgdXJsID0gdXJsLnJlcGxhY2UoL153cy9pLCAnaHR0cCcpXG4gIHVybCA9IHVybC5yZXBsYWNlKC8oXFwvc29ja2V0XFwvd2Vic29ja2V0fFxcL3NvY2tldHxcXC93ZWJzb2NrZXQpXFwvPyQvaSwgJycpXG4gIHJldHVybiB1cmwucmVwbGFjZSgvXFwvKyQvLCAnJylcbn1cbiIsICJpbXBvcnQgeyBERUZBVUxUX1RJTUVPVVQgfSBmcm9tICcuLi9saWIvY29uc3RhbnRzJ1xuaW1wb3J0IHR5cGUgUmVhbHRpbWVDaGFubmVsIGZyb20gJy4uL1JlYWx0aW1lQ2hhbm5lbCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHVzaCB7XG4gIHNlbnQ6IGJvb2xlYW4gPSBmYWxzZVxuICB0aW1lb3V0VGltZXI6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICByZWY6IHN0cmluZyA9ICcnXG4gIHJlY2VpdmVkUmVzcDoge1xuICAgIHN0YXR1czogc3RyaW5nXG4gICAgcmVzcG9uc2U6IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgfSB8IG51bGwgPSBudWxsXG4gIHJlY0hvb2tzOiB7XG4gICAgc3RhdHVzOiBzdHJpbmdcbiAgICBjYWxsYmFjazogRnVuY3Rpb25cbiAgfVtdID0gW11cbiAgcmVmRXZlbnQ6IHN0cmluZyB8IG51bGwgPSBudWxsXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBQdXNoXG4gICAqXG4gICAqIEBwYXJhbSBjaGFubmVsIFRoZSBDaGFubmVsXG4gICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQsIGZvciBleGFtcGxlIGBcInBoeF9qb2luXCJgXG4gICAqIEBwYXJhbSBwYXlsb2FkIFRoZSBwYXlsb2FkLCBmb3IgZXhhbXBsZSBge3VzZXJfaWQ6IDEyM31gXG4gICAqIEBwYXJhbSB0aW1lb3V0IFRoZSBwdXNoIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsLFxuICAgIHB1YmxpYyBldmVudDogc3RyaW5nLFxuICAgIHB1YmxpYyBwYXlsb2FkOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge30sXG4gICAgcHVibGljIHRpbWVvdXQ6IG51bWJlciA9IERFRkFVTFRfVElNRU9VVFxuICApIHt9XG5cbiAgcmVzZW5kKHRpbWVvdXQ6IG51bWJlcikge1xuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXRcbiAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpXG4gICAgdGhpcy5yZWYgPSAnJ1xuICAgIHRoaXMucmVmRXZlbnQgPSBudWxsXG4gICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsXG4gICAgdGhpcy5zZW50ID0gZmFsc2VcbiAgICB0aGlzLnNlbmQoKVxuICB9XG5cbiAgc2VuZCgpIHtcbiAgICBpZiAodGhpcy5faGFzUmVjZWl2ZWQoJ3RpbWVvdXQnKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuc3RhcnRUaW1lb3V0KClcbiAgICB0aGlzLnNlbnQgPSB0cnVlXG4gICAgdGhpcy5jaGFubmVsLnNvY2tldC5wdXNoKHtcbiAgICAgIHRvcGljOiB0aGlzLmNoYW5uZWwudG9waWMsXG4gICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZCxcbiAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICBqb2luX3JlZjogdGhpcy5jaGFubmVsLl9qb2luUmVmKCksXG4gICAgfSlcbiAgfVxuXG4gIHVwZGF0ZVBheWxvYWQocGF5bG9hZDogeyBba2V5OiBzdHJpbmddOiBhbnkgfSk6IHZvaWQge1xuICAgIHRoaXMucGF5bG9hZCA9IHsgLi4udGhpcy5wYXlsb2FkLCAuLi5wYXlsb2FkIH1cbiAgfVxuXG4gIHJlY2VpdmUoc3RhdHVzOiBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIGlmICh0aGlzLl9oYXNSZWNlaXZlZChzdGF0dXMpKSB7XG4gICAgICBjYWxsYmFjayh0aGlzLnJlY2VpdmVkUmVzcD8ucmVzcG9uc2UpXG4gICAgfVxuXG4gICAgdGhpcy5yZWNIb29rcy5wdXNoKHsgc3RhdHVzLCBjYWxsYmFjayB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydFRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMudGltZW91dFRpbWVyKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5yZWYgPSB0aGlzLmNoYW5uZWwuc29ja2V0Ll9tYWtlUmVmKClcbiAgICB0aGlzLnJlZkV2ZW50ID0gdGhpcy5jaGFubmVsLl9yZXBseUV2ZW50TmFtZSh0aGlzLnJlZilcblxuICAgIGNvbnN0IGNhbGxiYWNrID0gKHBheWxvYWQ6IGFueSkgPT4ge1xuICAgICAgdGhpcy5fY2FuY2VsUmVmRXZlbnQoKVxuICAgICAgdGhpcy5fY2FuY2VsVGltZW91dCgpXG4gICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IHBheWxvYWRcbiAgICAgIHRoaXMuX21hdGNoUmVjZWl2ZShwYXlsb2FkKVxuICAgIH1cblxuICAgIHRoaXMuY2hhbm5lbC5fb24odGhpcy5yZWZFdmVudCwge30sIGNhbGxiYWNrKVxuXG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSA8YW55PnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKCd0aW1lb3V0Jywge30pXG4gICAgfSwgdGhpcy50aW1lb3V0KVxuICB9XG5cbiAgdHJpZ2dlcihzdGF0dXM6IHN0cmluZywgcmVzcG9uc2U6IGFueSkge1xuICAgIGlmICh0aGlzLnJlZkV2ZW50KVxuICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKHRoaXMucmVmRXZlbnQsIHsgc3RhdHVzLCByZXNwb25zZSB9KVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpXG4gICAgdGhpcy5fY2FuY2VsVGltZW91dCgpXG4gIH1cblxuICBwcml2YXRlIF9jYW5jZWxSZWZFdmVudCgpIHtcbiAgICBpZiAoIXRoaXMucmVmRXZlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY2hhbm5lbC5fb2ZmKHRoaXMucmVmRXZlbnQsIHt9KVxuICB9XG5cbiAgcHJpdmF0ZSBfY2FuY2VsVGltZW91dCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0VGltZXIpXG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHByaXZhdGUgX21hdGNoUmVjZWl2ZSh7XG4gICAgc3RhdHVzLFxuICAgIHJlc3BvbnNlLFxuICB9OiB7XG4gICAgc3RhdHVzOiBzdHJpbmdcbiAgICByZXNwb25zZTogRnVuY3Rpb25cbiAgfSkge1xuICAgIHRoaXMucmVjSG9va3NcbiAgICAgIC5maWx0ZXIoKGgpID0+IGguc3RhdHVzID09PSBzdGF0dXMpXG4gICAgICAuZm9yRWFjaCgoaCkgPT4gaC5jYWxsYmFjayhyZXNwb25zZSkpXG4gIH1cblxuICBwcml2YXRlIF9oYXNSZWNlaXZlZChzdGF0dXM6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLnJlY2VpdmVkUmVzcCAmJiB0aGlzLnJlY2VpdmVkUmVzcC5zdGF0dXMgPT09IHN0YXR1c1xuICB9XG59XG4iLCAiLypcbiAgVGhpcyBmaWxlIGRyYXdzIGhlYXZpbHkgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2Jsb2IvZDM0NGVjMGE3MzJhYjRlZTIwNDIxNWIzMWRlNjljZjRiZTcyZTNiZi9hc3NldHMvanMvcGhvZW5peC9wcmVzZW5jZS5qc1xuICBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2Jsb2IvZDM0NGVjMGE3MzJhYjRlZTIwNDIxNWIzMWRlNjljZjRiZTcyZTNiZi9MSUNFTlNFLm1kXG4qL1xuXG5pbXBvcnQgdHlwZSB7XG4gIFByZXNlbmNlT3B0cyxcbiAgUHJlc2VuY2VPbkpvaW5DYWxsYmFjayxcbiAgUHJlc2VuY2VPbkxlYXZlQ2FsbGJhY2ssXG59IGZyb20gJ3Bob2VuaXgnXG5pbXBvcnQgdHlwZSBSZWFsdGltZUNoYW5uZWwgZnJvbSAnLi9SZWFsdGltZUNoYW5uZWwnXG5cbnR5cGUgUHJlc2VuY2U8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fT4gPSB7XG4gIHByZXNlbmNlX3JlZjogc3RyaW5nXG59ICYgVFxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVByZXNlbmNlU3RhdGU8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fT4gPSB7XG4gIFtrZXk6IHN0cmluZ106IFByZXNlbmNlPFQ+W11cbn1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVQcmVzZW5jZUpvaW5QYXlsb2FkPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PiA9IHtcbiAgZXZlbnQ6IGAke1JFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMuSk9JTn1gXG4gIGtleTogc3RyaW5nXG4gIGN1cnJlbnRQcmVzZW5jZXM6IFByZXNlbmNlPFQ+W11cbiAgbmV3UHJlc2VuY2VzOiBQcmVzZW5jZTxUPltdXG59XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUHJlc2VuY2VMZWF2ZVBheWxvYWQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+ID0ge1xuICBldmVudDogYCR7UkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUy5MRUFWRX1gXG4gIGtleTogc3RyaW5nXG4gIGN1cnJlbnRQcmVzZW5jZXM6IFByZXNlbmNlPFQ+W11cbiAgbGVmdFByZXNlbmNlczogUHJlc2VuY2U8VD5bXVxufVxuXG5leHBvcnQgZW51bSBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTIHtcbiAgU1lOQyA9ICdzeW5jJyxcbiAgSk9JTiA9ICdqb2luJyxcbiAgTEVBVkUgPSAnbGVhdmUnLFxufVxuXG50eXBlIFByZXNlbmNlRGlmZiA9IHtcbiAgam9pbnM6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZVxuICBsZWF2ZXM6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZVxufVxuXG50eXBlIFJhd1ByZXNlbmNlU3RhdGUgPSB7XG4gIFtrZXk6IHN0cmluZ106IHtcbiAgICBtZXRhczoge1xuICAgICAgcGh4X3JlZj86IHN0cmluZ1xuICAgICAgcGh4X3JlZl9wcmV2Pzogc3RyaW5nXG4gICAgICBba2V5OiBzdHJpbmddOiBhbnlcbiAgICB9W11cbiAgfVxufVxuXG50eXBlIFJhd1ByZXNlbmNlRGlmZiA9IHtcbiAgam9pbnM6IFJhd1ByZXNlbmNlU3RhdGVcbiAgbGVhdmVzOiBSYXdQcmVzZW5jZVN0YXRlXG59XG5cbnR5cGUgUHJlc2VuY2VDaG9vc2VyPFQ+ID0gKGtleTogc3RyaW5nLCBwcmVzZW5jZXM6IFByZXNlbmNlW10pID0+IFRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhbHRpbWVQcmVzZW5jZSB7XG4gIHN0YXRlOiBSZWFsdGltZVByZXNlbmNlU3RhdGUgPSB7fVxuICBwZW5kaW5nRGlmZnM6IFJhd1ByZXNlbmNlRGlmZltdID0gW11cbiAgam9pblJlZjogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgY2FsbGVyOiB7XG4gICAgb25Kb2luOiBQcmVzZW5jZU9uSm9pbkNhbGxiYWNrXG4gICAgb25MZWF2ZTogUHJlc2VuY2VPbkxlYXZlQ2FsbGJhY2tcbiAgICBvblN5bmM6ICgpID0+IHZvaWRcbiAgfSA9IHtcbiAgICBvbkpvaW46ICgpID0+IHt9LFxuICAgIG9uTGVhdmU6ICgpID0+IHt9LFxuICAgIG9uU3luYzogKCkgPT4ge30sXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIFByZXNlbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gY2hhbm5lbCAtIFRoZSBSZWFsdGltZUNoYW5uZWxcbiAgICogQHBhcmFtIG9wdHMgLSBUaGUgb3B0aW9ucyxcbiAgICogICAgICAgIGZvciBleGFtcGxlIGB7ZXZlbnRzOiB7c3RhdGU6ICdzdGF0ZScsIGRpZmY6ICdkaWZmJ319YFxuICAgKi9cbiAgY29uc3RydWN0b3IocHVibGljIGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCwgb3B0cz86IFByZXNlbmNlT3B0cykge1xuICAgIGNvbnN0IGV2ZW50cyA9IG9wdHM/LmV2ZW50cyB8fCB7XG4gICAgICBzdGF0ZTogJ3ByZXNlbmNlX3N0YXRlJyxcbiAgICAgIGRpZmY6ICdwcmVzZW5jZV9kaWZmJyxcbiAgICB9XG5cbiAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5zdGF0ZSwge30sIChuZXdTdGF0ZTogUmF3UHJlc2VuY2VTdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXJcblxuICAgICAgdGhpcy5qb2luUmVmID0gdGhpcy5jaGFubmVsLl9qb2luUmVmKClcblxuICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY1N0YXRlKFxuICAgICAgICB0aGlzLnN0YXRlLFxuICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgb25Kb2luLFxuICAgICAgICBvbkxlYXZlXG4gICAgICApXG5cbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goKGRpZmYpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY0RpZmYoXG4gICAgICAgICAgdGhpcy5zdGF0ZSxcbiAgICAgICAgICBkaWZmLFxuICAgICAgICAgIG9uSm9pbixcbiAgICAgICAgICBvbkxlYXZlXG4gICAgICAgIClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cblxuICAgICAgb25TeW5jKClcbiAgICB9KVxuXG4gICAgdGhpcy5jaGFubmVsLl9vbihldmVudHMuZGlmZiwge30sIChkaWZmOiBSYXdQcmVzZW5jZURpZmYpID0+IHtcbiAgICAgIGNvbnN0IHsgb25Kb2luLCBvbkxlYXZlLCBvblN5bmMgfSA9IHRoaXMuY2FsbGVyXG5cbiAgICAgIGlmICh0aGlzLmluUGVuZGluZ1N5bmNTdGF0ZSgpKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goZGlmZilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBSZWFsdGltZVByZXNlbmNlLnN5bmNEaWZmKFxuICAgICAgICAgIHRoaXMuc3RhdGUsXG4gICAgICAgICAgZGlmZixcbiAgICAgICAgICBvbkpvaW4sXG4gICAgICAgICAgb25MZWF2ZVxuICAgICAgICApXG5cbiAgICAgICAgb25TeW5jKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5vbkpvaW4oKGtleSwgY3VycmVudFByZXNlbmNlcywgbmV3UHJlc2VuY2VzKSA9PiB7XG4gICAgICB0aGlzLmNoYW5uZWwuX3RyaWdnZXIoJ3ByZXNlbmNlJywge1xuICAgICAgICBldmVudDogJ2pvaW4nLFxuICAgICAgICBrZXksXG4gICAgICAgIGN1cnJlbnRQcmVzZW5jZXMsXG4gICAgICAgIG5ld1ByZXNlbmNlcyxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMub25MZWF2ZSgoa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBsZWZ0UHJlc2VuY2VzKSA9PiB7XG4gICAgICB0aGlzLmNoYW5uZWwuX3RyaWdnZXIoJ3ByZXNlbmNlJywge1xuICAgICAgICBldmVudDogJ2xlYXZlJyxcbiAgICAgICAga2V5LFxuICAgICAgICBjdXJyZW50UHJlc2VuY2VzLFxuICAgICAgICBsZWZ0UHJlc2VuY2VzLFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5vblN5bmMoKCkgPT4ge1xuICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHsgZXZlbnQ6ICdzeW5jJyB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBzeW5jIHRoZSBsaXN0IG9mIHByZXNlbmNlcyBvbiB0aGUgc2VydmVyIHdpdGggdGhlXG4gICAqIGNsaWVudCdzIHN0YXRlLlxuICAgKlxuICAgKiBBbiBvcHRpb25hbCBgb25Kb2luYCBhbmQgYG9uTGVhdmVgIGNhbGxiYWNrIGNhbiBiZSBwcm92aWRlZCB0b1xuICAgKiByZWFjdCB0byBjaGFuZ2VzIGluIHRoZSBjbGllbnQncyBsb2NhbCBwcmVzZW5jZXMgYWNyb3NzXG4gICAqIGRpc2Nvbm5lY3RzIGFuZCByZWNvbm5lY3RzIHdpdGggdGhlIHNlcnZlci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBzeW5jU3RhdGUoXG4gICAgY3VycmVudFN0YXRlOiBSZWFsdGltZVByZXNlbmNlU3RhdGUsXG4gICAgbmV3U3RhdGU6IFJhd1ByZXNlbmNlU3RhdGUgfCBSZWFsdGltZVByZXNlbmNlU3RhdGUsXG4gICAgb25Kb2luOiBQcmVzZW5jZU9uSm9pbkNhbGxiYWNrLFxuICAgIG9uTGVhdmU6IFByZXNlbmNlT25MZWF2ZUNhbGxiYWNrXG4gICk6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmNsb25lRGVlcChjdXJyZW50U3RhdGUpXG4gICAgY29uc3QgdHJhbnNmb3JtZWRTdGF0ZSA9IHRoaXMudHJhbnNmb3JtU3RhdGUobmV3U3RhdGUpXG4gICAgY29uc3Qgam9pbnM6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSA9IHt9XG4gICAgY29uc3QgbGVhdmVzOiBSZWFsdGltZVByZXNlbmNlU3RhdGUgPSB7fVxuXG4gICAgdGhpcy5tYXAoc3RhdGUsIChrZXk6IHN0cmluZywgcHJlc2VuY2VzOiBQcmVzZW5jZVtdKSA9PiB7XG4gICAgICBpZiAoIXRyYW5zZm9ybWVkU3RhdGVba2V5XSkge1xuICAgICAgICBsZWF2ZXNba2V5XSA9IHByZXNlbmNlc1xuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLm1hcCh0cmFuc2Zvcm1lZFN0YXRlLCAoa2V5LCBuZXdQcmVzZW5jZXM6IFByZXNlbmNlW10pID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRQcmVzZW5jZXM6IFByZXNlbmNlW10gPSBzdGF0ZVtrZXldXG5cbiAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzKSB7XG4gICAgICAgIGNvbnN0IG5ld1ByZXNlbmNlUmVmcyA9IG5ld1ByZXNlbmNlcy5tYXAoXG4gICAgICAgICAgKG06IFByZXNlbmNlKSA9PiBtLnByZXNlbmNlX3JlZlxuICAgICAgICApXG4gICAgICAgIGNvbnN0IGN1clByZXNlbmNlUmVmcyA9IGN1cnJlbnRQcmVzZW5jZXMubWFwKFxuICAgICAgICAgIChtOiBQcmVzZW5jZSkgPT4gbS5wcmVzZW5jZV9yZWZcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBqb2luZWRQcmVzZW5jZXM6IFByZXNlbmNlW10gPSBuZXdQcmVzZW5jZXMuZmlsdGVyKFxuICAgICAgICAgIChtOiBQcmVzZW5jZSkgPT4gY3VyUHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMFxuICAgICAgICApXG4gICAgICAgIGNvbnN0IGxlZnRQcmVzZW5jZXM6IFByZXNlbmNlW10gPSBjdXJyZW50UHJlc2VuY2VzLmZpbHRlcihcbiAgICAgICAgICAobTogUHJlc2VuY2UpID0+IG5ld1ByZXNlbmNlUmVmcy5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDBcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChqb2luZWRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGpvaW5zW2tleV0gPSBqb2luZWRQcmVzZW5jZXNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZWZ0UHJlc2VuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsZWF2ZXNba2V5XSA9IGxlZnRQcmVzZW5jZXNcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgam9pbnNba2V5XSA9IG5ld1ByZXNlbmNlc1xuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gdGhpcy5zeW5jRGlmZihzdGF0ZSwgeyBqb2lucywgbGVhdmVzIH0sIG9uSm9pbiwgb25MZWF2ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHN5bmMgYSBkaWZmIG9mIHByZXNlbmNlIGpvaW4gYW5kIGxlYXZlIGV2ZW50cyBmcm9tIHRoZVxuICAgKiBzZXJ2ZXIsIGFzIHRoZXkgaGFwcGVuLlxuICAgKlxuICAgKiBMaWtlIGBzeW5jU3RhdGVgLCBgc3luY0RpZmZgIGFjY2VwdHMgb3B0aW9uYWwgYG9uSm9pbmAgYW5kXG4gICAqIGBvbkxlYXZlYCBjYWxsYmFja3MgdG8gcmVhY3QgdG8gYSB1c2VyIGpvaW5pbmcgb3IgbGVhdmluZyBmcm9tIGFcbiAgICogZGV2aWNlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHN5bmNEaWZmKFxuICAgIHN0YXRlOiBSZWFsdGltZVByZXNlbmNlU3RhdGUsXG4gICAgZGlmZjogUmF3UHJlc2VuY2VEaWZmIHwgUHJlc2VuY2VEaWZmLFxuICAgIG9uSm9pbjogUHJlc2VuY2VPbkpvaW5DYWxsYmFjayxcbiAgICBvbkxlYXZlOiBQcmVzZW5jZU9uTGVhdmVDYWxsYmFja1xuICApOiBSZWFsdGltZVByZXNlbmNlU3RhdGUge1xuICAgIGNvbnN0IHsgam9pbnMsIGxlYXZlcyB9ID0ge1xuICAgICAgam9pbnM6IHRoaXMudHJhbnNmb3JtU3RhdGUoZGlmZi5qb2lucyksXG4gICAgICBsZWF2ZXM6IHRoaXMudHJhbnNmb3JtU3RhdGUoZGlmZi5sZWF2ZXMpLFxuICAgIH1cblxuICAgIGlmICghb25Kb2luKSB7XG4gICAgICBvbkpvaW4gPSAoKSA9PiB7fVxuICAgIH1cblxuICAgIGlmICghb25MZWF2ZSkge1xuICAgICAgb25MZWF2ZSA9ICgpID0+IHt9XG4gICAgfVxuXG4gICAgdGhpcy5tYXAoam9pbnMsIChrZXksIG5ld1ByZXNlbmNlczogUHJlc2VuY2VbXSkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFByZXNlbmNlczogUHJlc2VuY2VbXSA9IHN0YXRlW2tleV0gPz8gW11cbiAgICAgIHN0YXRlW2tleV0gPSB0aGlzLmNsb25lRGVlcChuZXdQcmVzZW5jZXMpXG5cbiAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgam9pbmVkUHJlc2VuY2VSZWZzID0gc3RhdGVba2V5XS5tYXAoXG4gICAgICAgICAgKG06IFByZXNlbmNlKSA9PiBtLnByZXNlbmNlX3JlZlxuICAgICAgICApXG4gICAgICAgIGNvbnN0IGN1clByZXNlbmNlczogUHJlc2VuY2VbXSA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKFxuICAgICAgICAgIChtOiBQcmVzZW5jZSkgPT4gam9pbmVkUHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMFxuICAgICAgICApXG5cbiAgICAgICAgc3RhdGVba2V5XS51bnNoaWZ0KC4uLmN1clByZXNlbmNlcylcbiAgICAgIH1cblxuICAgICAgb25Kb2luKGtleSwgY3VycmVudFByZXNlbmNlcywgbmV3UHJlc2VuY2VzKVxuICAgIH0pXG5cbiAgICB0aGlzLm1hcChsZWF2ZXMsIChrZXksIGxlZnRQcmVzZW5jZXM6IFByZXNlbmNlW10pID0+IHtcbiAgICAgIGxldCBjdXJyZW50UHJlc2VuY2VzOiBQcmVzZW5jZVtdID0gc3RhdGVba2V5XVxuXG4gICAgICBpZiAoIWN1cnJlbnRQcmVzZW5jZXMpIHJldHVyblxuXG4gICAgICBjb25zdCBwcmVzZW5jZVJlZnNUb1JlbW92ZSA9IGxlZnRQcmVzZW5jZXMubWFwKFxuICAgICAgICAobTogUHJlc2VuY2UpID0+IG0ucHJlc2VuY2VfcmVmXG4gICAgICApXG4gICAgICBjdXJyZW50UHJlc2VuY2VzID0gY3VycmVudFByZXNlbmNlcy5maWx0ZXIoXG4gICAgICAgIChtOiBQcmVzZW5jZSkgPT4gcHJlc2VuY2VSZWZzVG9SZW1vdmUuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwXG4gICAgICApXG5cbiAgICAgIHN0YXRlW2tleV0gPSBjdXJyZW50UHJlc2VuY2VzXG5cbiAgICAgIG9uTGVhdmUoa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBsZWZ0UHJlc2VuY2VzKVxuXG4gICAgICBpZiAoY3VycmVudFByZXNlbmNlcy5sZW5ndGggPT09IDApIGRlbGV0ZSBzdGF0ZVtrZXldXG4gICAgfSlcblxuICAgIHJldHVybiBzdGF0ZVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHN0YXRpYyBtYXA8VCA9IGFueT4oXG4gICAgb2JqOiBSZWFsdGltZVByZXNlbmNlU3RhdGUsXG4gICAgZnVuYzogUHJlc2VuY2VDaG9vc2VyPFQ+XG4gICk6IFRbXSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubWFwKChrZXkpID0+IGZ1bmMoa2V5LCBvYmpba2V5XSkpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlICdtZXRhcycga2V5XG4gICAqIENoYW5nZSAncGh4X3JlZicgdG8gJ3ByZXNlbmNlX3JlZidcbiAgICogUmVtb3ZlICdwaHhfcmVmJyBhbmQgJ3BoeF9yZWZfcHJldidcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gcmV0dXJucyB7XG4gICAqICBhYmMxMjM6IFtcbiAgICogICAgeyBwcmVzZW5jZV9yZWY6ICcyJywgdXNlcl9pZDogMSB9LFxuICAgKiAgICB7IHByZXNlbmNlX3JlZjogJzMnLCB1c2VyX2lkOiAyIH1cbiAgICogIF1cbiAgICogfVxuICAgKiBSZWFsdGltZVByZXNlbmNlLnRyYW5zZm9ybVN0YXRlKHtcbiAgICogIGFiYzEyMzoge1xuICAgKiAgICBtZXRhczogW1xuICAgKiAgICAgIHsgcGh4X3JlZjogJzInLCBwaHhfcmVmX3ByZXY6ICcxJyB1c2VyX2lkOiAxIH0sXG4gICAqICAgICAgeyBwaHhfcmVmOiAnMycsIHVzZXJfaWQ6IDIgfVxuICAgKiAgICBdXG4gICAqICB9XG4gICAqIH0pXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgdHJhbnNmb3JtU3RhdGUoXG4gICAgc3RhdGU6IFJhd1ByZXNlbmNlU3RhdGUgfCBSZWFsdGltZVByZXNlbmNlU3RhdGVcbiAgKTogUmVhbHRpbWVQcmVzZW5jZVN0YXRlIHtcbiAgICBzdGF0ZSA9IHRoaXMuY2xvbmVEZWVwKHN0YXRlKVxuXG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0YXRlKS5yZWR1Y2UoKG5ld1N0YXRlLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IHByZXNlbmNlcyA9IHN0YXRlW2tleV1cblxuICAgICAgaWYgKCdtZXRhcycgaW4gcHJlc2VuY2VzKSB7XG4gICAgICAgIG5ld1N0YXRlW2tleV0gPSBwcmVzZW5jZXMubWV0YXMubWFwKChwcmVzZW5jZSkgPT4ge1xuICAgICAgICAgIHByZXNlbmNlWydwcmVzZW5jZV9yZWYnXSA9IHByZXNlbmNlWydwaHhfcmVmJ11cblxuICAgICAgICAgIGRlbGV0ZSBwcmVzZW5jZVsncGh4X3JlZiddXG4gICAgICAgICAgZGVsZXRlIHByZXNlbmNlWydwaHhfcmVmX3ByZXYnXVxuXG4gICAgICAgICAgcmV0dXJuIHByZXNlbmNlXG4gICAgICAgIH0pIGFzIFByZXNlbmNlW11cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1N0YXRlW2tleV0gPSBwcmVzZW5jZXNcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1N0YXRlXG4gICAgfSwge30gYXMgUmVhbHRpbWVQcmVzZW5jZVN0YXRlKVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHN0YXRpYyBjbG9uZURlZXAob2JqOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSlcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBvbkpvaW4oY2FsbGJhY2s6IFByZXNlbmNlT25Kb2luQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLmNhbGxlci5vbkpvaW4gPSBjYWxsYmFja1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIG9uTGVhdmUoY2FsbGJhY2s6IFByZXNlbmNlT25MZWF2ZUNhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5jYWxsZXIub25MZWF2ZSA9IGNhbGxiYWNrXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgb25TeW5jKGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5jYWxsZXIub25TeW5jID0gY2FsbGJhY2tcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBpblBlbmRpbmdTeW5jU3RhdGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLmpvaW5SZWYgfHwgdGhpcy5qb2luUmVmICE9PSB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKVxuICB9XG59XG4iLCAiaW1wb3J0IHsgQ0hBTk5FTF9FVkVOVFMsIENIQU5ORUxfU1RBVEVTIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJ1xuaW1wb3J0IFB1c2ggZnJvbSAnLi9saWIvcHVzaCdcbmltcG9ydCB0eXBlIFJlYWx0aW1lQ2xpZW50IGZyb20gJy4vUmVhbHRpbWVDbGllbnQnXG5pbXBvcnQgVGltZXIgZnJvbSAnLi9saWIvdGltZXInXG5pbXBvcnQgUmVhbHRpbWVQcmVzZW5jZSwge1xuICBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLFxufSBmcm9tICcuL1JlYWx0aW1lUHJlc2VuY2UnXG5pbXBvcnQgdHlwZSB7XG4gIFJlYWx0aW1lUHJlc2VuY2VKb2luUGF5bG9hZCxcbiAgUmVhbHRpbWVQcmVzZW5jZUxlYXZlUGF5bG9hZCxcbiAgUmVhbHRpbWVQcmVzZW5jZVN0YXRlLFxufSBmcm9tICcuL1JlYWx0aW1lUHJlc2VuY2UnXG5pbXBvcnQgKiBhcyBUcmFuc2Zvcm1lcnMgZnJvbSAnLi9saWIvdHJhbnNmb3JtZXJzJ1xuaW1wb3J0IHsgaHR0cEVuZHBvaW50VVJMIH0gZnJvbSAnLi9saWIvdHJhbnNmb3JtZXJzJ1xuXG5leHBvcnQgdHlwZSBSZWFsdGltZUNoYW5uZWxPcHRpb25zID0ge1xuICBjb25maWc6IHtcbiAgICAvKipcbiAgICAgKiBzZWxmIG9wdGlvbiBlbmFibGVzIGNsaWVudCB0byByZWNlaXZlIG1lc3NhZ2UgaXQgYnJvYWRjYXN0XG4gICAgICogYWNrIG9wdGlvbiBpbnN0cnVjdHMgc2VydmVyIHRvIGFja25vd2xlZGdlIHRoYXQgYnJvYWRjYXN0IG1lc3NhZ2Ugd2FzIHJlY2VpdmVkXG4gICAgICovXG4gICAgYnJvYWRjYXN0PzogeyBzZWxmPzogYm9vbGVhbjsgYWNrPzogYm9vbGVhbiB9XG4gICAgLyoqXG4gICAgICoga2V5IG9wdGlvbiBpcyB1c2VkIHRvIHRyYWNrIHByZXNlbmNlIHBheWxvYWQgYWNyb3NzIGNsaWVudHNcbiAgICAgKi9cbiAgICBwcmVzZW5jZT86IHsga2V5Pzogc3RyaW5nIH1cbiAgICAvKipcbiAgICAgKiBkZWZpbmVzIGlmIHRoZSBjaGFubmVsIGlzIHByaXZhdGUgb3Igbm90IGFuZCBpZiBSTFMgcG9saWNpZXMgd2lsbCBiZSB1c2VkIHRvIGNoZWNrIGRhdGFcbiAgICAgKi9cbiAgICBwcml2YXRlPzogYm9vbGVhblxuICB9XG59XG5cbnR5cGUgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkQmFzZSA9IHtcbiAgc2NoZW1hOiBzdHJpbmdcbiAgdGFibGU6IHN0cmluZ1xuICBjb21taXRfdGltZXN0YW1wOiBzdHJpbmdcbiAgZXJyb3JzOiBzdHJpbmdbXVxufVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVBvc3RncmVzSW5zZXJ0UGF5bG9hZDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4gPVxuICBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc1BheWxvYWRCYXNlICYge1xuICAgIGV2ZW50VHlwZTogYCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuSU5TRVJUfWBcbiAgICBuZXc6IFRcbiAgICBvbGQ6IHt9XG4gIH1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVQb3N0Z3Jlc1VwZGF0ZVBheWxvYWQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+ID1cbiAgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkQmFzZSAmIHtcbiAgICBldmVudFR5cGU6IGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULlVQREFURX1gXG4gICAgbmV3OiBUXG4gICAgb2xkOiBQYXJ0aWFsPFQ+XG4gIH1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVQb3N0Z3Jlc0RlbGV0ZVBheWxvYWQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+ID1cbiAgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkQmFzZSAmIHtcbiAgICBldmVudFR5cGU6IGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULkRFTEVURX1gXG4gICAgbmV3OiB7fVxuICAgIG9sZDogUGFydGlhbDxUPlxuICB9XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4gPVxuICB8IFJlYWx0aW1lUG9zdGdyZXNJbnNlcnRQYXlsb2FkPFQ+XG4gIHwgUmVhbHRpbWVQb3N0Z3Jlc1VwZGF0ZVBheWxvYWQ8VD5cbiAgfCBSZWFsdGltZVBvc3RncmVzRGVsZXRlUGF5bG9hZDxUPlxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc0ZpbHRlcjxcbiAgVCBleHRlbmRzIGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UfWBcbj4gPSB7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBkYXRhYmFzZSBjaGFuZ2UgdG8gbGlzdGVuIHRvLlxuICAgKi9cbiAgZXZlbnQ6IFRcbiAgLyoqXG4gICAqIFRoZSBkYXRhYmFzZSBzY2hlbWEgdG8gbGlzdGVuIHRvLlxuICAgKi9cbiAgc2NoZW1hOiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBkYXRhYmFzZSB0YWJsZSB0byBsaXN0ZW4gdG8uXG4gICAqL1xuICB0YWJsZT86IHN0cmluZ1xuICAvKipcbiAgICogUmVjZWl2ZSBkYXRhYmFzZSBjaGFuZ2VzIHdoZW4gZmlsdGVyIGlzIG1hdGNoZWQuXG4gICAqL1xuICBmaWx0ZXI/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVDaGFubmVsU2VuZFJlc3BvbnNlID0gJ29rJyB8ICd0aW1lZCBvdXQnIHwgJ2Vycm9yJ1xuXG5leHBvcnQgZW51bSBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCB7XG4gIEFMTCA9ICcqJyxcbiAgSU5TRVJUID0gJ0lOU0VSVCcsXG4gIFVQREFURSA9ICdVUERBVEUnLFxuICBERUxFVEUgPSAnREVMRVRFJyxcbn1cblxuZXhwb3J0IGVudW0gUkVBTFRJTUVfTElTVEVOX1RZUEVTIHtcbiAgQlJPQURDQVNUID0gJ2Jyb2FkY2FzdCcsXG4gIFBSRVNFTkNFID0gJ3ByZXNlbmNlJyxcbiAgUE9TVEdSRVNfQ0hBTkdFUyA9ICdwb3N0Z3Jlc19jaGFuZ2VzJyxcbiAgU1lTVEVNID0gJ3N5c3RlbScsXG59XG5cbmV4cG9ydCBlbnVtIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMge1xuICBTVUJTQ1JJQkVEID0gJ1NVQlNDUklCRUQnLFxuICBUSU1FRF9PVVQgPSAnVElNRURfT1VUJyxcbiAgQ0xPU0VEID0gJ0NMT1NFRCcsXG4gIENIQU5ORUxfRVJST1IgPSAnQ0hBTk5FTF9FUlJPUicsXG59XG5cbmV4cG9ydCBjb25zdCBSRUFMVElNRV9DSEFOTkVMX1NUQVRFUyA9IENIQU5ORUxfU1RBVEVTXG5cbmludGVyZmFjZSBQb3N0Z3Jlc0NoYW5nZXNGaWx0ZXJzIHtcbiAgcG9zdGdyZXNfY2hhbmdlczoge1xuICAgIGlkOiBzdHJpbmdcbiAgICBldmVudDogc3RyaW5nXG4gICAgc2NoZW1hPzogc3RyaW5nXG4gICAgdGFibGU/OiBzdHJpbmdcbiAgICBmaWx0ZXI/OiBzdHJpbmdcbiAgfVtdXG59XG4vKiogQSBjaGFubmVsIGlzIHRoZSBiYXNpYyBidWlsZGluZyBibG9jayBvZiBSZWFsdGltZVxuICogYW5kIG5hcnJvd3MgdGhlIHNjb3BlIG9mIGRhdGEgZmxvdyB0byBzdWJzY3JpYmVkIGNsaWVudHMuXG4gKiBZb3UgY2FuIHRoaW5rIG9mIGEgY2hhbm5lbCBhcyBhIGNoYXRyb29tIHdoZXJlIHBhcnRpY2lwYW50cyBhcmUgYWJsZSB0byBzZWUgd2hvJ3Mgb25saW5lXG4gKiBhbmQgc2VuZCBhbmQgcmVjZWl2ZSBtZXNzYWdlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhbHRpbWVDaGFubmVsIHtcbiAgYmluZGluZ3M6IHtcbiAgICBba2V5OiBzdHJpbmddOiB7XG4gICAgICB0eXBlOiBzdHJpbmdcbiAgICAgIGZpbHRlcjogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICAgICAgY2FsbGJhY2s6IEZ1bmN0aW9uXG4gICAgICBpZD86IHN0cmluZ1xuICAgIH1bXVxuICB9ID0ge31cbiAgdGltZW91dDogbnVtYmVyXG4gIHN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkXG4gIGpvaW5lZE9uY2UgPSBmYWxzZVxuICBqb2luUHVzaDogUHVzaFxuICByZWpvaW5UaW1lcjogVGltZXJcbiAgcHVzaEJ1ZmZlcjogUHVzaFtdID0gW11cbiAgcHJlc2VuY2U6IFJlYWx0aW1lUHJlc2VuY2VcbiAgYnJvYWRjYXN0RW5kcG9pbnRVUkw6IHN0cmluZ1xuICBzdWJUb3BpYzogc3RyaW5nXG4gIHByaXZhdGU6IGJvb2xlYW5cblxuICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVG9waWMgbmFtZSBjYW4gYmUgYW55IHN0cmluZy4gKi9cbiAgICBwdWJsaWMgdG9waWM6IHN0cmluZyxcbiAgICBwdWJsaWMgcGFyYW1zOiBSZWFsdGltZUNoYW5uZWxPcHRpb25zID0geyBjb25maWc6IHt9IH0sXG4gICAgcHVibGljIHNvY2tldDogUmVhbHRpbWVDbGllbnRcbiAgKSB7XG4gICAgdGhpcy5zdWJUb3BpYyA9IHRvcGljLnJlcGxhY2UoL15yZWFsdGltZTovaSwgJycpXG4gICAgdGhpcy5wYXJhbXMuY29uZmlnID0ge1xuICAgICAgLi4ue1xuICAgICAgICBicm9hZGNhc3Q6IHsgYWNrOiBmYWxzZSwgc2VsZjogZmFsc2UgfSxcbiAgICAgICAgcHJlc2VuY2U6IHsga2V5OiAnJyB9LFxuICAgICAgICBwcml2YXRlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICAuLi5wYXJhbXMuY29uZmlnLFxuICAgIH1cbiAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLnNvY2tldC50aW1lb3V0XG4gICAgdGhpcy5qb2luUHVzaCA9IG5ldyBQdXNoKFxuICAgICAgdGhpcyxcbiAgICAgIENIQU5ORUxfRVZFTlRTLmpvaW4sXG4gICAgICB0aGlzLnBhcmFtcyxcbiAgICAgIHRoaXMudGltZW91dFxuICAgIClcbiAgICB0aGlzLnJlam9pblRpbWVyID0gbmV3IFRpbWVyKFxuICAgICAgKCkgPT4gdGhpcy5fcmVqb2luVW50aWxDb25uZWN0ZWQoKSxcbiAgICAgIHRoaXMuc29ja2V0LnJlY29ubmVjdEFmdGVyTXNcbiAgICApXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKCdvaycsICgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luZWRcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyLmZvckVhY2goKHB1c2hFdmVudDogUHVzaCkgPT4gcHVzaEV2ZW50LnNlbmQoKSlcbiAgICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdXG4gICAgfSlcbiAgICB0aGlzLl9vbkNsb3NlKCgpID0+IHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGNsb3NlICR7dGhpcy50b3BpY30gJHt0aGlzLl9qb2luUmVmKCl9YClcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgICAgIHRoaXMuc29ja2V0Ll9yZW1vdmUodGhpcylcbiAgICB9KVxuICAgIHRoaXMuX29uRXJyb3IoKHJlYXNvbjogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAodGhpcy5faXNMZWF2aW5nKCkgfHwgdGhpcy5faXNDbG9zZWQoKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBlcnJvciAke3RoaXMudG9waWN9YCwgcmVhc29uKVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KClcbiAgICB9KVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5faXNKb2luaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgdGltZW91dCAke3RoaXMudG9waWN9YCwgdGhpcy5qb2luUHVzaC50aW1lb3V0KVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KClcbiAgICB9KVxuICAgIHRoaXMuX29uKENIQU5ORUxfRVZFTlRTLnJlcGx5LCB7fSwgKHBheWxvYWQ6IGFueSwgcmVmOiBzdHJpbmcpID0+IHtcbiAgICAgIHRoaXMuX3RyaWdnZXIodGhpcy5fcmVwbHlFdmVudE5hbWUocmVmKSwgcGF5bG9hZClcbiAgICB9KVxuXG4gICAgdGhpcy5wcmVzZW5jZSA9IG5ldyBSZWFsdGltZVByZXNlbmNlKHRoaXMpXG5cbiAgICB0aGlzLmJyb2FkY2FzdEVuZHBvaW50VVJMID1cbiAgICAgIGh0dHBFbmRwb2ludFVSTCh0aGlzLnNvY2tldC5lbmRQb2ludCkgKyAnL2FwaS9icm9hZGNhc3QnXG4gICAgdGhpcy5wcml2YXRlID0gdGhpcy5wYXJhbXMuY29uZmlnLnByaXZhdGUgfHwgZmFsc2VcbiAgfVxuXG4gIC8qKiBTdWJzY3JpYmUgcmVnaXN0ZXJzIHlvdXIgY2xpZW50IHdpdGggdGhlIHNlcnZlciAqL1xuICBzdWJzY3JpYmUoXG4gICAgY2FsbGJhY2s/OiAoc3RhdHVzOiBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLCBlcnI/OiBFcnJvcikgPT4gdm9pZCxcbiAgICB0aW1lb3V0ID0gdGhpcy50aW1lb3V0XG4gICk6IFJlYWx0aW1lQ2hhbm5lbCB7XG4gICAgaWYgKCF0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICB0aGlzLnNvY2tldC5jb25uZWN0KClcbiAgICB9XG4gICAgaWYgKHRoaXMuam9pbmVkT25jZSkge1xuICAgICAgdGhyb3cgYHRyaWVkIHRvIHN1YnNjcmliZSBtdWx0aXBsZSB0aW1lcy4gJ3N1YnNjcmliZScgY2FuIG9ubHkgYmUgY2FsbGVkIGEgc2luZ2xlIHRpbWUgcGVyIGNoYW5uZWwgaW5zdGFuY2VgXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29uZmlnOiB7IGJyb2FkY2FzdCwgcHJlc2VuY2UsIHByaXZhdGU6IGlzUHJpdmF0ZSB9LFxuICAgICAgfSA9IHRoaXMucGFyYW1zXG5cbiAgICAgIHRoaXMuX29uRXJyb3IoKGU6IEVycm9yKSA9PlxuICAgICAgICBjYWxsYmFjaz8uKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0hBTk5FTF9FUlJPUiwgZSlcbiAgICAgIClcbiAgICAgIHRoaXMuX29uQ2xvc2UoKCkgPT4gY2FsbGJhY2s/LihSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNMT1NFRCkpXG5cbiAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuUGF5bG9hZDogeyBhY2Nlc3NfdG9rZW4/OiBzdHJpbmcgfSA9IHt9XG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIGJyb2FkY2FzdCxcbiAgICAgICAgcHJlc2VuY2UsXG4gICAgICAgIHBvc3RncmVzX2NoYW5nZXM6XG4gICAgICAgICAgdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzPy5tYXAoKHIpID0+IHIuZmlsdGVyKSA/PyBbXSxcbiAgICAgICAgcHJpdmF0ZTogaXNQcml2YXRlLFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZSkge1xuICAgICAgICBhY2Nlc3NUb2tlblBheWxvYWQuYWNjZXNzX3Rva2VuID0gdGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZVxuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUpvaW5QYXlsb2FkKHsgLi4ueyBjb25maWcgfSwgLi4uYWNjZXNzVG9rZW5QYXlsb2FkIH0pXG5cbiAgICAgIHRoaXMuam9pbmVkT25jZSA9IHRydWVcbiAgICAgIHRoaXMuX3Jlam9pbih0aW1lb3V0KVxuXG4gICAgICB0aGlzLmpvaW5QdXNoXG4gICAgICAgIC5yZWNlaXZlKCdvaycsIGFzeW5jICh7IHBvc3RncmVzX2NoYW5nZXMgfTogUG9zdGdyZXNDaGFuZ2VzRmlsdGVycykgPT4ge1xuICAgICAgICAgIHRoaXMuc29ja2V0LnNldEF1dGgoKVxuICAgICAgICAgIGlmIChwb3N0Z3Jlc19jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrPy4oUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5TVUJTQ1JJQkVEKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudFBvc3RncmVzQmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXNcbiAgICAgICAgICAgIGNvbnN0IGJpbmRpbmdzTGVuID0gY2xpZW50UG9zdGdyZXNCaW5kaW5ncz8ubGVuZ3RoID8/IDBcbiAgICAgICAgICAgIGNvbnN0IG5ld1Bvc3RncmVzQmluZGluZ3MgPSBbXVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmRpbmdzTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgY2xpZW50UG9zdGdyZXNCaW5kaW5nID0gY2xpZW50UG9zdGdyZXNCaW5kaW5nc1tpXVxuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZmlsdGVyOiB7IGV2ZW50LCBzY2hlbWEsIHRhYmxlLCBmaWx0ZXIgfSxcbiAgICAgICAgICAgICAgfSA9IGNsaWVudFBvc3RncmVzQmluZGluZ1xuICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlciA9XG4gICAgICAgICAgICAgICAgcG9zdGdyZXNfY2hhbmdlcyAmJiBwb3N0Z3Jlc19jaGFuZ2VzW2ldXG5cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHNlcnZlclBvc3RncmVzRmlsdGVyICYmXG4gICAgICAgICAgICAgICAgc2VydmVyUG9zdGdyZXNGaWx0ZXIuZXZlbnQgPT09IGV2ZW50ICYmXG4gICAgICAgICAgICAgICAgc2VydmVyUG9zdGdyZXNGaWx0ZXIuc2NoZW1hID09PSBzY2hlbWEgJiZcbiAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci50YWJsZSA9PT0gdGFibGUgJiZcbiAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5maWx0ZXIgPT09IGZpbHRlclxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBuZXdQb3N0Z3Jlc0JpbmRpbmdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgLi4uY2xpZW50UG9zdGdyZXNCaW5kaW5nLFxuICAgICAgICAgICAgICAgICAgaWQ6IHNlcnZlclBvc3RncmVzRmlsdGVyLmlkLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s/LihcbiAgICAgICAgICAgICAgICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0hBTk5FTF9FUlJPUixcbiAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ21pc21hdGNoIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgYmluZGluZ3MgZm9yIHBvc3RncmVzIGNoYW5nZXMnXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcyA9IG5ld1Bvc3RncmVzQmluZGluZ3NcblxuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5TVUJTQ1JJQkVEKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAucmVjZWl2ZSgnZXJyb3InLCAoZXJyb3I6IHsgW2tleTogc3RyaW5nXTogYW55IH0pID0+IHtcbiAgICAgICAgICBjYWxsYmFjaz8uKFxuICAgICAgICAgICAgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DSEFOTkVMX0VSUk9SLFxuICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShPYmplY3QudmFsdWVzKGVycm9yKS5qb2luKCcsICcpIHx8ICdlcnJvcicpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9KVxuICAgICAgICAucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgICAgICBjYWxsYmFjaz8uKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuVElNRURfT1VUKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJlc2VuY2VTdGF0ZTxcbiAgICBUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9XG4gID4oKTogUmVhbHRpbWVQcmVzZW5jZVN0YXRlPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5wcmVzZW5jZS5zdGF0ZSBhcyBSZWFsdGltZVByZXNlbmNlU3RhdGU8VD5cbiAgfVxuXG4gIGFzeW5jIHRyYWNrKFxuICAgIHBheWxvYWQ6IHsgW2tleTogc3RyaW5nXTogYW55IH0sXG4gICAgb3B0czogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9XG4gICk6IFByb21pc2U8UmVhbHRpbWVDaGFubmVsU2VuZFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZChcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgZXZlbnQ6ICd0cmFjaycsXG4gICAgICAgIHBheWxvYWQsXG4gICAgICB9LFxuICAgICAgb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dFxuICAgIClcbiAgfVxuXG4gIGFzeW5jIHVudHJhY2soXG4gICAgb3B0czogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9XG4gICk6IFByb21pc2U8UmVhbHRpbWVDaGFubmVsU2VuZFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZChcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgZXZlbnQ6ICd1bnRyYWNrJyxcbiAgICAgIH0sXG4gICAgICBvcHRzXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZXZlbnQgaGFuZGxlciB0aGF0IGxpc3RlbnMgdG8gY2hhbmdlcy5cbiAgICovXG4gIG9uKFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QUkVTRU5DRX1gLFxuICAgIGZpbHRlcjogeyBldmVudDogYCR7UkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUy5TWU5DfWAgfSxcbiAgICBjYWxsYmFjazogKCkgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb248VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QUkVTRU5DRX1gLFxuICAgIGZpbHRlcjogeyBldmVudDogYCR7UkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUy5KT0lOfWAgfSxcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IFJlYWx0aW1lUHJlc2VuY2VKb2luUGF5bG9hZDxUPikgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb248VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QUkVTRU5DRX1gLFxuICAgIGZpbHRlcjogeyBldmVudDogYCR7UkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUy5MRUFWRX1gIH0sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiBSZWFsdGltZVByZXNlbmNlTGVhdmVQYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBPU1RHUkVTX0NIQU5HRVN9YCxcbiAgICBmaWx0ZXI6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzRmlsdGVyPGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULkFMTH1gPixcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZDxUPikgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb248VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QT1NUR1JFU19DSEFOR0VTfWAsXG4gICAgZmlsdGVyOiBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc0ZpbHRlcjxgJHtSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVC5JTlNFUlR9YD4sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiBSZWFsdGltZVBvc3RncmVzSW5zZXJ0UGF5bG9hZDxUPikgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb248VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QT1NUR1JFU19DSEFOR0VTfWAsXG4gICAgZmlsdGVyOiBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc0ZpbHRlcjxgJHtSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVC5VUERBVEV9YD4sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiBSZWFsdGltZVBvc3RncmVzVXBkYXRlUGF5bG9hZDxUPikgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb248VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QT1NUR1JFU19DSEFOR0VTfWAsXG4gICAgZmlsdGVyOiBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc0ZpbHRlcjxgJHtSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVC5ERUxFVEV9YD4sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiBSZWFsdGltZVBvc3RncmVzRGVsZXRlUGF5bG9hZDxUPikgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgLyoqXG4gICAqIFRoZSBmb2xsb3dpbmcgaXMgcGxhY2VkIGhlcmUgdG8gZGlzcGxheSBvbiBzdXBhYmFzZS5jb20vZG9jcy9yZWZlcmVuY2UvamF2YXNjcmlwdC9zdWJzY3JpYmUuXG4gICAqIEBwYXJhbSB0eXBlIE9uZSBvZiBcImJyb2FkY2FzdFwiLCBcInByZXNlbmNlXCIsIG9yIFwicG9zdGdyZXNfY2hhbmdlc1wiLlxuICAgKiBAcGFyYW0gZmlsdGVyIEN1c3RvbSBvYmplY3Qgc3BlY2lmaWMgdG8gdGhlIFJlYWx0aW1lIGZlYXR1cmUgZGV0YWlsaW5nIHdoaWNoIHBheWxvYWRzIHRvIHJlY2VpdmUuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gZXZlbnQgaGFuZGxlciBpcyB0cmlnZ2VyZWQuXG4gICAqL1xuICBvbihcbiAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuQlJPQURDQVNUfWAsXG4gICAgZmlsdGVyOiB7IGV2ZW50OiBzdHJpbmcgfSxcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IHtcbiAgICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5CUk9BRENBU1R9YFxuICAgICAgZXZlbnQ6IHN0cmluZ1xuICAgICAgW2tleTogc3RyaW5nXTogYW55XG4gICAgfSkgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb248VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5CUk9BRENBU1R9YCxcbiAgICBmaWx0ZXI6IHsgZXZlbnQ6IHN0cmluZyB9LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDoge1xuICAgICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLkJST0FEQ0FTVH1gXG4gICAgICBldmVudDogc3RyaW5nXG4gICAgICBwYXlsb2FkOiBUXG4gICAgfSkgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWxcbiAgb248VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5TWVNURU19YCxcbiAgICBmaWx0ZXI6IHt9LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDogYW55KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbihcbiAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVN9YCxcbiAgICBmaWx0ZXI6IHsgZXZlbnQ6IHN0cmluZzsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiBhbnkpID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsIHtcbiAgICByZXR1cm4gdGhpcy5fb24odHlwZSwgZmlsdGVyLCBjYWxsYmFjaylcbiAgfVxuICAvKipcbiAgICogU2VuZHMgYSBtZXNzYWdlIGludG8gdGhlIGNoYW5uZWwuXG4gICAqXG4gICAqIEBwYXJhbSBhcmdzIEFyZ3VtZW50cyB0byBzZW5kIHRvIGNoYW5uZWxcbiAgICogQHBhcmFtIGFyZ3MudHlwZSBUaGUgdHlwZSBvZiBldmVudCB0byBzZW5kXG4gICAqIEBwYXJhbSBhcmdzLmV2ZW50IFRoZSBuYW1lIG9mIHRoZSBldmVudCBiZWluZyBzZW50XG4gICAqIEBwYXJhbSBhcmdzLnBheWxvYWQgUGF5bG9hZCB0byBiZSBzZW50XG4gICAqIEBwYXJhbSBvcHRzIE9wdGlvbnMgdG8gYmUgdXNlZCBkdXJpbmcgdGhlIHNlbmQgcHJvY2Vzc1xuICAgKi9cbiAgYXN5bmMgc2VuZChcbiAgICBhcmdzOiB7XG4gICAgICB0eXBlOiAnYnJvYWRjYXN0JyB8ICdwcmVzZW5jZScgfCAncG9zdGdyZXNfY2hhbmdlcydcbiAgICAgIGV2ZW50OiBzdHJpbmdcbiAgICAgIHBheWxvYWQ/OiBhbnlcbiAgICAgIFtrZXk6IHN0cmluZ106IGFueVxuICAgIH0sXG4gICAgb3B0czogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9XG4gICk6IFByb21pc2U8UmVhbHRpbWVDaGFubmVsU2VuZFJlc3BvbnNlPiB7XG4gICAgaWYgKCF0aGlzLl9jYW5QdXNoKCkgJiYgYXJncy50eXBlID09PSAnYnJvYWRjYXN0Jykge1xuICAgICAgY29uc3QgeyBldmVudCwgcGF5bG9hZDogZW5kcG9pbnRfcGF5bG9hZCB9ID0gYXJnc1xuICAgICAgY29uc3QgYXV0aG9yaXphdGlvbiA9IHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWVcbiAgICAgICAgPyBgQmVhcmVyICR7dGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZX1gXG4gICAgICAgIDogJydcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYXV0aG9yaXphdGlvbixcbiAgICAgICAgICBhcGlrZXk6IHRoaXMuc29ja2V0LmFwaUtleSA/IHRoaXMuc29ja2V0LmFwaUtleSA6ICcnLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0b3BpYzogdGhpcy5zdWJUb3BpYyxcbiAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IGVuZHBvaW50X3BheWxvYWQsXG4gICAgICAgICAgICAgIHByaXZhdGU6IHRoaXMucHJpdmF0ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfSksXG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZmV0Y2hXaXRoVGltZW91dChcbiAgICAgICAgICB0aGlzLmJyb2FkY2FzdEVuZHBvaW50VVJMLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgb3B0cy50aW1lb3V0ID8/IHRoaXMudGltZW91dFxuICAgICAgICApXG5cbiAgICAgICAgYXdhaXQgcmVzcG9uc2UuYm9keT8uY2FuY2VsKClcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rID8gJ29rJyA6ICdlcnJvcidcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgIHJldHVybiAndGltZWQgb3V0J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAnZXJyb3InXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IHB1c2ggPSB0aGlzLl9wdXNoKGFyZ3MudHlwZSwgYXJncywgb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dClcblxuICAgICAgICBpZiAoYXJncy50eXBlID09PSAnYnJvYWRjYXN0JyAmJiAhdGhpcy5wYXJhbXM/LmNvbmZpZz8uYnJvYWRjYXN0Py5hY2spIHtcbiAgICAgICAgICByZXNvbHZlKCdvaycpXG4gICAgICAgIH1cblxuICAgICAgICBwdXNoLnJlY2VpdmUoJ29rJywgKCkgPT4gcmVzb2x2ZSgnb2snKSlcbiAgICAgICAgcHVzaC5yZWNlaXZlKCdlcnJvcicsICgpID0+IHJlc29sdmUoJ2Vycm9yJykpXG4gICAgICAgIHB1c2gucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHJlc29sdmUoJ3RpbWVkIG91dCcpKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICB1cGRhdGVKb2luUGF5bG9hZChwYXlsb2FkOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KTogdm9pZCB7XG4gICAgdGhpcy5qb2luUHVzaC51cGRhdGVQYXlsb2FkKHBheWxvYWQpXG4gIH1cblxuICAvKipcbiAgICogTGVhdmVzIHRoZSBjaGFubmVsLlxuICAgKlxuICAgKiBVbnN1YnNjcmliZXMgZnJvbSBzZXJ2ZXIgZXZlbnRzLCBhbmQgaW5zdHJ1Y3RzIGNoYW5uZWwgdG8gdGVybWluYXRlIG9uIHNlcnZlci5cbiAgICogVHJpZ2dlcnMgb25DbG9zZSgpIGhvb2tzLlxuICAgKlxuICAgKiBUbyByZWNlaXZlIGxlYXZlIGFja25vd2xlZGdlbWVudHMsIHVzZSB0aGUgYSBgcmVjZWl2ZWAgaG9vayB0byBiaW5kIHRvIHRoZSBzZXJ2ZXIgYWNrLCBpZTpcbiAgICogY2hhbm5lbC51bnN1YnNjcmliZSgpLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBhbGVydChcImxlZnQhXCIpIClcbiAgICovXG4gIHVuc3Vic2NyaWJlKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpOiBQcm9taXNlPCdvaycgfCAndGltZWQgb3V0JyB8ICdlcnJvcic+IHtcbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMubGVhdmluZ1xuICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgbGVhdmUgJHt0aGlzLnRvcGljfWApXG4gICAgICB0aGlzLl90cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmNsb3NlLCAnbGVhdmUnLCB0aGlzLl9qb2luUmVmKCkpXG4gICAgfVxuXG4gICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgLy8gRGVzdHJveSBqb2luUHVzaCB0byBhdm9pZCBjb25uZWN0aW9uIHRpbWVvdXRzIGR1cmluZyB1bnNjcmlwdGlvbiBwaGFzZVxuICAgIHRoaXMuam9pblB1c2guZGVzdHJveSgpXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGxlYXZlUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmxlYXZlLCB7fSwgdGltZW91dClcbiAgICAgIGxlYXZlUHVzaFxuICAgICAgICAucmVjZWl2ZSgnb2snLCAoKSA9PiB7XG4gICAgICAgICAgb25DbG9zZSgpXG4gICAgICAgICAgcmVzb2x2ZSgnb2snKVxuICAgICAgICB9KVxuICAgICAgICAucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgICAgICBvbkNsb3NlKClcbiAgICAgICAgICByZXNvbHZlKCd0aW1lZCBvdXQnKVxuICAgICAgICB9KVxuICAgICAgICAucmVjZWl2ZSgnZXJyb3InLCAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSgnZXJyb3InKVxuICAgICAgICB9KVxuXG4gICAgICBsZWF2ZVB1c2guc2VuZCgpXG4gICAgICBpZiAoIXRoaXMuX2NhblB1c2goKSkge1xuICAgICAgICBsZWF2ZVB1c2gudHJpZ2dlcignb2snLCB7fSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIGFzeW5jIF9mZXRjaFdpdGhUaW1lb3V0KFxuICAgIHVybDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IHsgW2tleTogc3RyaW5nXTogYW55IH0sXG4gICAgdGltZW91dDogbnVtYmVyXG4gICkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNvY2tldC5mZXRjaCh1cmwsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgIH0pXG5cbiAgICBjbGVhclRpbWVvdXQoaWQpXG5cbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3B1c2goXG4gICAgZXZlbnQ6IHN0cmluZyxcbiAgICBwYXlsb2FkOiB7IFtrZXk6IHN0cmluZ106IGFueSB9LFxuICAgIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXRcbiAgKSB7XG4gICAgaWYgKCF0aGlzLmpvaW5lZE9uY2UpIHtcbiAgICAgIHRocm93IGB0cmllZCB0byBwdXNoICcke2V2ZW50fScgdG8gJyR7dGhpcy50b3BpY30nIGJlZm9yZSBqb2luaW5nLiBVc2UgY2hhbm5lbC5zdWJzY3JpYmUoKSBiZWZvcmUgcHVzaGluZyBldmVudHNgXG4gICAgfVxuICAgIGxldCBwdXNoRXZlbnQgPSBuZXcgUHVzaCh0aGlzLCBldmVudCwgcGF5bG9hZCwgdGltZW91dClcbiAgICBpZiAodGhpcy5fY2FuUHVzaCgpKSB7XG4gICAgICBwdXNoRXZlbnQuc2VuZCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2hFdmVudC5zdGFydFRpbWVvdXQoKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KVxuICAgIH1cblxuICAgIHJldHVybiBwdXNoRXZlbnRcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkYWJsZSBtZXNzYWdlIGhvb2tcbiAgICpcbiAgICogUmVjZWl2ZXMgYWxsIGV2ZW50cyBmb3Igc3BlY2lhbGl6ZWQgbWVzc2FnZSBoYW5kbGluZyBiZWZvcmUgZGlzcGF0Y2hpbmcgdG8gdGhlIGNoYW5uZWwgY2FsbGJhY2tzLlxuICAgKiBNdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfb25NZXNzYWdlKF9ldmVudDogc3RyaW5nLCBwYXlsb2FkOiBhbnksIF9yZWY/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gcGF5bG9hZFxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaXNNZW1iZXIodG9waWM6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnRvcGljID09PSB0b3BpY1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfam9pblJlZigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmpvaW5QdXNoLnJlZlxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdHJpZ2dlcih0eXBlOiBzdHJpbmcsIHBheWxvYWQ/OiBhbnksIHJlZj86IHN0cmluZykge1xuICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKVxuICAgIGNvbnN0IHsgY2xvc2UsIGVycm9yLCBsZWF2ZSwgam9pbiB9ID0gQ0hBTk5FTF9FVkVOVFNcbiAgICBjb25zdCBldmVudHM6IHN0cmluZ1tdID0gW2Nsb3NlLCBlcnJvciwgbGVhdmUsIGpvaW5dXG4gICAgaWYgKHJlZiAmJiBldmVudHMuaW5kZXhPZih0eXBlTG93ZXIpID49IDAgJiYgcmVmICE9PSB0aGlzLl9qb2luUmVmKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBsZXQgaGFuZGxlZFBheWxvYWQgPSB0aGlzLl9vbk1lc3NhZ2UodHlwZUxvd2VyLCBwYXlsb2FkLCByZWYpXG4gICAgaWYgKHBheWxvYWQgJiYgIWhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICB0aHJvdyAnY2hhbm5lbCBvbk1lc3NhZ2UgY2FsbGJhY2tzIG11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkJ1xuICAgIH1cblxuICAgIGlmIChbJ2luc2VydCcsICd1cGRhdGUnLCAnZGVsZXRlJ10uaW5jbHVkZXModHlwZUxvd2VyKSkge1xuICAgICAgdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzXG4gICAgICAgID8uZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGJpbmQuZmlsdGVyPy5ldmVudCA9PT0gJyonIHx8XG4gICAgICAgICAgICBiaW5kLmZpbHRlcj8uZXZlbnQ/LnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IHR5cGVMb3dlclxuICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICAgICAgLm1hcCgoYmluZCkgPT4gYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdXG4gICAgICAgID8uZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgWydicm9hZGNhc3QnLCAncHJlc2VuY2UnLCAncG9zdGdyZXNfY2hhbmdlcyddLmluY2x1ZGVzKHR5cGVMb3dlcilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICgnaWQnIGluIGJpbmQpIHtcbiAgICAgICAgICAgICAgY29uc3QgYmluZElkID0gYmluZC5pZFxuICAgICAgICAgICAgICBjb25zdCBiaW5kRXZlbnQgPSBiaW5kLmZpbHRlcj8uZXZlbnRcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBiaW5kSWQgJiZcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmlkcz8uaW5jbHVkZXMoYmluZElkKSAmJlxuICAgICAgICAgICAgICAgIChiaW5kRXZlbnQgPT09ICcqJyB8fFxuICAgICAgICAgICAgICAgICAgYmluZEV2ZW50Py50b0xvY2FsZUxvd2VyQ2FzZSgpID09PVxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmRhdGE/LnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgYmluZEV2ZW50ID0gYmluZD8uZmlsdGVyPy5ldmVudD8udG9Mb2NhbGVMb3dlckNhc2UoKVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIGJpbmRFdmVudCA9PT0gJyonIHx8XG4gICAgICAgICAgICAgICAgYmluZEV2ZW50ID09PSBwYXlsb2FkPy5ldmVudD8udG9Mb2NhbGVMb3dlckNhc2UoKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0gdHlwZUxvd2VyXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAubWFwKChiaW5kKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVkUGF5bG9hZCA9PT0gJ29iamVjdCcgJiYgJ2lkcycgaW4gaGFuZGxlZFBheWxvYWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc3RncmVzQ2hhbmdlcyA9IGhhbmRsZWRQYXlsb2FkLmRhdGFcbiAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hLCB0YWJsZSwgY29tbWl0X3RpbWVzdGFtcCwgdHlwZSwgZXJyb3JzIH0gPVxuICAgICAgICAgICAgICBwb3N0Z3Jlc0NoYW5nZXNcbiAgICAgICAgICAgIGNvbnN0IGVucmljaGVkUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWEsXG4gICAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgICAgICAgY29tbWl0X3RpbWVzdGFtcDogY29tbWl0X3RpbWVzdGFtcCxcbiAgICAgICAgICAgICAgZXZlbnRUeXBlOiB0eXBlLFxuICAgICAgICAgICAgICBuZXc6IHt9LFxuICAgICAgICAgICAgICBvbGQ6IHt9LFxuICAgICAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZWRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAuLi5lbnJpY2hlZFBheWxvYWQsXG4gICAgICAgICAgICAgIC4uLnRoaXMuX2dldFBheWxvYWRSZWNvcmRzKHBvc3RncmVzQ2hhbmdlcyksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZilcbiAgICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9pc0Nsb3NlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9pc0pvaW5lZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmVkXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9pc0pvaW5pbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5pbmdcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2lzTGVhdmluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMubGVhdmluZ1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVwbHlFdmVudE5hbWUocmVmOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgY2hhbl9yZXBseV8ke3JlZn1gXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9vbih0eXBlOiBzdHJpbmcsIGZpbHRlcjogeyBba2V5OiBzdHJpbmddOiBhbnkgfSwgY2FsbGJhY2s6IEZ1bmN0aW9uKSB7XG4gICAgY29uc3QgdHlwZUxvd2VyID0gdHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpXG5cbiAgICBjb25zdCBiaW5kaW5nID0ge1xuICAgICAgdHlwZTogdHlwZUxvd2VyLFxuICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSkge1xuICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdLnB1c2goYmluZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdID0gW2JpbmRpbmddXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX29mZih0eXBlOiBzdHJpbmcsIGZpbHRlcjogeyBba2V5OiBzdHJpbmddOiBhbnkgfSkge1xuICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKVxuXG4gICAgdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdID0gdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgcmV0dXJuICEoXG4gICAgICAgIGJpbmQudHlwZT8udG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0gdHlwZUxvd2VyICYmXG4gICAgICAgIFJlYWx0aW1lQ2hhbm5lbC5pc0VxdWFsKGJpbmQuZmlsdGVyLCBmaWx0ZXIpXG4gICAgICApXG4gICAgfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIHN0YXRpYyBpc0VxdWFsKFxuICAgIG9iajE6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sXG4gICAgb2JqMjogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxuICApIHtcbiAgICBpZiAoT2JqZWN0LmtleXMob2JqMSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhvYmoyKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgayBpbiBvYmoxKSB7XG4gICAgICBpZiAob2JqMVtrXSAhPT0gb2JqMltrXSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9yZWpvaW5VbnRpbENvbm5lY3RlZCgpIHtcbiAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpXG4gICAgaWYgKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRoaXMuX3Jlam9pbigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjaGFubmVsIGNsb3Nlcy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIF9vbkNsb3NlKGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIHRoaXMuX29uKENIQU5ORUxfRVZFTlRTLmNsb3NlLCB7fSwgY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYW5uZWwgZW5jb3VudGVyZXMgYW4gZXJyb3IuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBfb25FcnJvcihjYWxsYmFjazogRnVuY3Rpb24pIHtcbiAgICB0aGlzLl9vbihDSEFOTkVMX0VWRU5UUy5lcnJvciwge30sIChyZWFzb246IHN0cmluZykgPT4gY2FsbGJhY2socmVhc29uKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZCBhbmQgdGhlIGNoYW5uZWwgaGFzIGJlZW4gam9pbmVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgX2NhblB1c2goKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5faXNKb2luZWQoKVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9yZWpvaW4odGltZW91dCA9IHRoaXMudGltZW91dCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9pc0xlYXZpbmcoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuc29ja2V0Ll9sZWF2ZU9wZW5Ub3BpYyh0aGlzLnRvcGljKVxuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nXG4gICAgdGhpcy5qb2luUHVzaC5yZXNlbmQodGltZW91dClcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfZ2V0UGF5bG9hZFJlY29yZHMocGF5bG9hZDogYW55KSB7XG4gICAgY29uc3QgcmVjb3JkcyA9IHtcbiAgICAgIG5ldzoge30sXG4gICAgICBvbGQ6IHt9LFxuICAgIH1cblxuICAgIGlmIChwYXlsb2FkLnR5cGUgPT09ICdJTlNFUlQnIHx8IHBheWxvYWQudHlwZSA9PT0gJ1VQREFURScpIHtcbiAgICAgIHJlY29yZHMubmV3ID0gVHJhbnNmb3JtZXJzLmNvbnZlcnRDaGFuZ2VEYXRhKFxuICAgICAgICBwYXlsb2FkLmNvbHVtbnMsXG4gICAgICAgIHBheWxvYWQucmVjb3JkXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHBheWxvYWQudHlwZSA9PT0gJ1VQREFURScgfHwgcGF5bG9hZC50eXBlID09PSAnREVMRVRFJykge1xuICAgICAgcmVjb3Jkcy5vbGQgPSBUcmFuc2Zvcm1lcnMuY29udmVydENoYW5nZURhdGEoXG4gICAgICAgIHBheWxvYWQuY29sdW1ucyxcbiAgICAgICAgcGF5bG9hZC5vbGRfcmVjb3JkXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY29yZHNcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgV2ViU29ja2V0IGFzIFdTV2ViU29ja2V0IH0gZnJvbSAnd3MnXG5cbmltcG9ydCB7XG4gIENIQU5ORUxfRVZFTlRTLFxuICBDT05ORUNUSU9OX1NUQVRFLFxuICBERUZBVUxUX0hFQURFUlMsXG4gIERFRkFVTFRfVElNRU9VVCxcbiAgU09DS0VUX1NUQVRFUyxcbiAgVFJBTlNQT1JUUyxcbiAgVlNOLFxuICBXU19DTE9TRV9OT1JNQUwsXG59IGZyb20gJy4vbGliL2NvbnN0YW50cydcbmltcG9ydCBTZXJpYWxpemVyIGZyb20gJy4vbGliL3NlcmlhbGl6ZXInXG5pbXBvcnQgVGltZXIgZnJvbSAnLi9saWIvdGltZXInXG5cbmltcG9ydCB7IGh0dHBFbmRwb2ludFVSTCB9IGZyb20gJy4vbGliL3RyYW5zZm9ybWVycydcbmltcG9ydCBSZWFsdGltZUNoYW5uZWwgZnJvbSAnLi9SZWFsdGltZUNoYW5uZWwnXG5pbXBvcnQgdHlwZSB7IFJlYWx0aW1lQ2hhbm5lbE9wdGlvbnMgfSBmcm9tICcuL1JlYWx0aW1lQ2hhbm5lbCdcblxudHlwZSBGZXRjaCA9IHR5cGVvZiBmZXRjaFxuXG5leHBvcnQgdHlwZSBDaGFubmVsID0ge1xuICBuYW1lOiBzdHJpbmdcbiAgaW5zZXJ0ZWRfYXQ6IHN0cmluZ1xuICB1cGRhdGVkX2F0OiBzdHJpbmdcbiAgaWQ6IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZUNsaWVudE9wdGlvbnMgPSB7XG4gIHRyYW5zcG9ydD86IFdlYlNvY2tldExpa2VDb25zdHJ1Y3RvclxuICB0aW1lb3V0PzogbnVtYmVyXG4gIGhlYXJ0YmVhdEludGVydmFsTXM/OiBudW1iZXJcbiAgbG9nZ2VyPzogRnVuY3Rpb25cbiAgZW5jb2RlPzogRnVuY3Rpb25cbiAgZGVjb2RlPzogRnVuY3Rpb25cbiAgcmVjb25uZWN0QWZ0ZXJNcz86IEZ1bmN0aW9uXG4gIGhlYWRlcnM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gIHBhcmFtcz86IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgbG9nX2xldmVsPzogJ2luZm8nIHwgJ2RlYnVnJyB8ICd3YXJuJyB8ICdlcnJvcidcbiAgZmV0Y2g/OiBGZXRjaFxuICB3b3JrZXI/OiBib29sZWFuXG4gIHdvcmtlclVybD86IHN0cmluZ1xuICBhY2Nlc3NUb2tlbj86ICgpID0+IFByb21pc2U8c3RyaW5nIHwgbnVsbD5cbn1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVNZXNzYWdlID0ge1xuICB0b3BpYzogc3RyaW5nXG4gIGV2ZW50OiBzdHJpbmdcbiAgcGF5bG9hZDogYW55XG4gIHJlZjogc3RyaW5nXG4gIGpvaW5fcmVmPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUmVtb3ZlQ2hhbm5lbFJlc3BvbnNlID0gJ29rJyB8ICd0aW1lZCBvdXQnIHwgJ2Vycm9yJ1xuXG5jb25zdCBub29wID0gKCkgPT4ge31cblxuZXhwb3J0IGludGVyZmFjZSBXZWJTb2NrZXRMaWtlQ29uc3RydWN0b3Ige1xuICBuZXcgKFxuICAgIGFkZHJlc3M6IHN0cmluZyB8IFVSTCxcbiAgICBfaWdub3JlZD86IGFueSxcbiAgICBvcHRpb25zPzogeyBoZWFkZXJzOiBPYmplY3QgfCB1bmRlZmluZWQgfVxuICApOiBXZWJTb2NrZXRMaWtlXG59XG5cbmV4cG9ydCB0eXBlIFdlYlNvY2tldExpa2UgPSBXZWJTb2NrZXQgfCBXU1dlYlNvY2tldCB8IFdTV2ViU29ja2V0RHVtbXlcblxuZXhwb3J0IGludGVyZmFjZSBXZWJTb2NrZXRMaWtlRXJyb3Ige1xuICBlcnJvcjogYW55XG4gIG1lc3NhZ2U6IHN0cmluZ1xuICB0eXBlOiBzdHJpbmdcbn1cblxuY29uc3QgTkFUSVZFX1dFQlNPQ0tFVF9BVkFJTEFCTEUgPSB0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJ1xuY29uc3QgV09SS0VSX1NDUklQVCA9IGBcbiAgYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGUpID0+IHtcbiAgICBpZiAoZS5kYXRhLmV2ZW50ID09PSBcInN0YXJ0XCIpIHtcbiAgICAgIHNldEludGVydmFsKCgpID0+IHBvc3RNZXNzYWdlKHsgZXZlbnQ6IFwia2VlcEFsaXZlXCIgfSksIGUuZGF0YS5pbnRlcnZhbCk7XG4gICAgfVxuICB9KTtgXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFsdGltZUNsaWVudCB7XG4gIGFjY2Vzc1Rva2VuVmFsdWU6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gIGFwaUtleTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgY2hhbm5lbHM6IFJlYWx0aW1lQ2hhbm5lbFtdID0gW11cbiAgZW5kUG9pbnQ6IHN0cmluZyA9ICcnXG4gIGh0dHBFbmRwb2ludDogc3RyaW5nID0gJydcbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSBERUZBVUxUX0hFQURFUlNcbiAgcGFyYW1zPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9XG4gIHRpbWVvdXQ6IG51bWJlciA9IERFRkFVTFRfVElNRU9VVFxuICB0cmFuc3BvcnQ6IFdlYlNvY2tldExpa2VDb25zdHJ1Y3RvciB8IG51bGxcbiAgaGVhcnRiZWF0SW50ZXJ2YWxNczogbnVtYmVyID0gMzAwMDBcbiAgaGVhcnRiZWF0VGltZXI6IFJldHVyblR5cGU8dHlwZW9mIHNldEludGVydmFsPiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICBwZW5kaW5nSGVhcnRiZWF0UmVmOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICByZWY6IG51bWJlciA9IDBcbiAgcmVjb25uZWN0VGltZXI6IFRpbWVyXG4gIGxvZ2dlcjogRnVuY3Rpb24gPSBub29wXG4gIGVuY29kZTogRnVuY3Rpb25cbiAgZGVjb2RlOiBGdW5jdGlvblxuICByZWNvbm5lY3RBZnRlck1zOiBGdW5jdGlvblxuICBjb25uOiBXZWJTb2NrZXRMaWtlIHwgbnVsbCA9IG51bGxcbiAgc2VuZEJ1ZmZlcjogRnVuY3Rpb25bXSA9IFtdXG4gIHNlcmlhbGl6ZXI6IFNlcmlhbGl6ZXIgPSBuZXcgU2VyaWFsaXplcigpXG4gIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzOiB7XG4gICAgb3BlbjogRnVuY3Rpb25bXVxuICAgIGNsb3NlOiBGdW5jdGlvbltdXG4gICAgZXJyb3I6IEZ1bmN0aW9uW11cbiAgICBtZXNzYWdlOiBGdW5jdGlvbltdXG4gIH0gPSB7XG4gICAgb3BlbjogW10sXG4gICAgY2xvc2U6IFtdLFxuICAgIGVycm9yOiBbXSxcbiAgICBtZXNzYWdlOiBbXSxcbiAgfVxuICBmZXRjaDogRmV0Y2hcbiAgYWNjZXNzVG9rZW46ICgoKSA9PiBQcm9taXNlPHN0cmluZyB8IG51bGw+KSB8IG51bGwgPSBudWxsXG4gIHdvcmtlcj86IGJvb2xlYW5cbiAgd29ya2VyVXJsPzogc3RyaW5nXG4gIHdvcmtlclJlZj86IFdvcmtlclxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gZW5kUG9pbnQgVGhlIHN0cmluZyBXZWJTb2NrZXQgZW5kcG9pbnQsIGllLCBcIndzOi8vZXhhbXBsZS5jb20vc29ja2V0XCIsIFwid3NzOi8vZXhhbXBsZS5jb21cIiwgXCIvc29ja2V0XCIgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gICAqIEBwYXJhbSBodHRwRW5kcG9pbnQgVGhlIHN0cmluZyBIVFRQIGVuZHBvaW50LCBpZSwgXCJodHRwczovL2V4YW1wbGUuY29tXCIsIFwiL1wiIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc3BvcnQgVGhlIFdlYnNvY2tldCBUcmFuc3BvcnQsIGZvciBleGFtcGxlIFdlYlNvY2tldC5cbiAgICogQHBhcmFtIG9wdGlvbnMudGltZW91dCBUaGUgZGVmYXVsdCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byB0cmlnZ2VyIHB1c2ggdGltZW91dHMuXG4gICAqIEBwYXJhbSBvcHRpb25zLnBhcmFtcyBUaGUgb3B0aW9uYWwgcGFyYW1zIHRvIHBhc3Mgd2hlbiBjb25uZWN0aW5nLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkZXJzIFRoZSBvcHRpb25hbCBoZWFkZXJzIHRvIHBhc3Mgd2hlbiBjb25uZWN0aW5nLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFydGJlYXRJbnRlcnZhbE1zIFRoZSBtaWxsaXNlYyBpbnRlcnZhbCB0byBzZW5kIGEgaGVhcnRiZWF0IG1lc3NhZ2UuXG4gICAqIEBwYXJhbSBvcHRpb25zLmxvZ2dlciBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gZm9yIHNwZWNpYWxpemVkIGxvZ2dpbmcsIGllOiBsb2dnZXI6IChraW5kLCBtc2csIGRhdGEpID0+IHsgY29uc29sZS5sb2coYCR7a2luZH06ICR7bXNnfWAsIGRhdGEpIH1cbiAgICogQHBhcmFtIG9wdGlvbnMuZW5jb2RlIFRoZSBmdW5jdGlvbiB0byBlbmNvZGUgb3V0Z29pbmcgbWVzc2FnZXMuIERlZmF1bHRzIHRvIEpTT046IChwYXlsb2FkLCBjYWxsYmFjaykgPT4gY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpXG4gICAqIEBwYXJhbSBvcHRpb25zLmRlY29kZSBUaGUgZnVuY3Rpb24gdG8gZGVjb2RlIGluY29taW5nIG1lc3NhZ2VzLiBEZWZhdWx0cyB0byBTZXJpYWxpemVyJ3MgZGVjb2RlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWNvbm5lY3RBZnRlck1zIGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWlsbHNlYyByZWNvbm5lY3QgaW50ZXJ2YWwuIERlZmF1bHRzIHRvIHN0ZXBwZWQgYmFja29mZiBvZmYuXG4gICAqIEBwYXJhbSBvcHRpb25zLndvcmtlciBVc2UgV2ViIFdvcmtlciB0byBzZXQgYSBzaWRlIGZsb3cuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy53b3JrZXJVcmwgVGhlIFVSTCBvZiB0aGUgd29ya2VyIHNjcmlwdC4gRGVmYXVsdHMgdG8gaHR0cHM6Ly9yZWFsdGltZS5zdXBhYmFzZS5jb20vd29ya2VyLmpzIHRoYXQgaW5jbHVkZXMgYSBoZWFydGJlYXQgZXZlbnQgY2FsbCB0byBrZWVwIHRoZSBjb25uZWN0aW9uIGFsaXZlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZW5kUG9pbnQ6IHN0cmluZywgb3B0aW9ucz86IFJlYWx0aW1lQ2xpZW50T3B0aW9ucykge1xuICAgIHRoaXMuZW5kUG9pbnQgPSBgJHtlbmRQb2ludH0vJHtUUkFOU1BPUlRTLndlYnNvY2tldH1gXG4gICAgdGhpcy5odHRwRW5kcG9pbnQgPSBodHRwRW5kcG9pbnRVUkwoZW5kUG9pbnQpXG4gICAgaWYgKG9wdGlvbnM/LnRyYW5zcG9ydCkge1xuICAgICAgdGhpcy50cmFuc3BvcnQgPSBvcHRpb25zLnRyYW5zcG9ydFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGxcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LnBhcmFtcykgdGhpcy5wYXJhbXMgPSBvcHRpb25zLnBhcmFtc1xuICAgIGlmIChvcHRpb25zPy5oZWFkZXJzKSB0aGlzLmhlYWRlcnMgPSB7IC4uLnRoaXMuaGVhZGVycywgLi4ub3B0aW9ucy5oZWFkZXJzIH1cbiAgICBpZiAob3B0aW9ucz8udGltZW91dCkgdGhpcy50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0XG4gICAgaWYgKG9wdGlvbnM/LmxvZ2dlcikgdGhpcy5sb2dnZXIgPSBvcHRpb25zLmxvZ2dlclxuICAgIGlmIChvcHRpb25zPy5oZWFydGJlYXRJbnRlcnZhbE1zKVxuICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zID0gb3B0aW9ucy5oZWFydGJlYXRJbnRlcnZhbE1zXG5cbiAgICBjb25zdCBhY2Nlc3NUb2tlblZhbHVlID0gb3B0aW9ucz8ucGFyYW1zPy5hcGlrZXlcbiAgICBpZiAoYWNjZXNzVG9rZW5WYWx1ZSkge1xuICAgICAgdGhpcy5hY2Nlc3NUb2tlblZhbHVlID0gYWNjZXNzVG9rZW5WYWx1ZVxuICAgICAgdGhpcy5hcGlLZXkgPSBhY2Nlc3NUb2tlblZhbHVlXG4gICAgfVxuXG4gICAgdGhpcy5yZWNvbm5lY3RBZnRlck1zID0gb3B0aW9ucz8ucmVjb25uZWN0QWZ0ZXJNc1xuICAgICAgPyBvcHRpb25zLnJlY29ubmVjdEFmdGVyTXNcbiAgICAgIDogKHRyaWVzOiBudW1iZXIpID0+IHtcbiAgICAgICAgICByZXR1cm4gWzEwMDAsIDIwMDAsIDUwMDAsIDEwMDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gICAgICAgIH1cbiAgICB0aGlzLmVuY29kZSA9IG9wdGlvbnM/LmVuY29kZVxuICAgICAgPyBvcHRpb25zLmVuY29kZVxuICAgICAgOiAocGF5bG9hZDogSlNPTiwgY2FsbGJhY2s6IEZ1bmN0aW9uKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKVxuICAgICAgICB9XG4gICAgdGhpcy5kZWNvZGUgPSBvcHRpb25zPy5kZWNvZGVcbiAgICAgID8gb3B0aW9ucy5kZWNvZGVcbiAgICAgIDogdGhpcy5zZXJpYWxpemVyLmRlY29kZS5iaW5kKHRoaXMuc2VyaWFsaXplcilcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbmV3IFRpbWVyKGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgICB0aGlzLmNvbm5lY3QoKVxuICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcylcblxuICAgIHRoaXMuZmV0Y2ggPSB0aGlzLl9yZXNvbHZlRmV0Y2gob3B0aW9ucz8uZmV0Y2gpXG4gICAgaWYgKG9wdGlvbnM/Lndvcmtlcikge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuV29ya2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViIFdvcmtlciBpcyBub3Qgc3VwcG9ydGVkJylcbiAgICAgIH1cbiAgICAgIHRoaXMud29ya2VyID0gb3B0aW9ucz8ud29ya2VyIHx8IGZhbHNlXG4gICAgICB0aGlzLndvcmtlclVybCA9IG9wdGlvbnM/LndvcmtlclVybFxuICAgIH1cbiAgICB0aGlzLmFjY2Vzc1Rva2VuID0gb3B0aW9ucz8uYWNjZXNzVG9rZW4gfHwgbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRoZSBzb2NrZXQsIHVubGVzcyBhbHJlYWR5IGNvbm5lY3RlZC5cbiAgICovXG4gIGNvbm5lY3QoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICB0aGlzLmNvbm4gPSBuZXcgdGhpcy50cmFuc3BvcnQodGhpcy5lbmRwb2ludFVSTCgpLCB1bmRlZmluZWQsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChOQVRJVkVfV0VCU09DS0VUX0FWQUlMQUJMRSkge1xuICAgICAgdGhpcy5jb25uID0gbmV3IFdlYlNvY2tldCh0aGlzLmVuZHBvaW50VVJMKCkpXG4gICAgICB0aGlzLnNldHVwQ29ubmVjdGlvbigpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmNvbm4gPSBuZXcgV1NXZWJTb2NrZXREdW1teSh0aGlzLmVuZHBvaW50VVJMKCksIHVuZGVmaW5lZCwge1xuICAgICAgY2xvc2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy5jb25uID0gbnVsbFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgaW1wb3J0KCd3cycpLnRoZW4oKHsgZGVmYXVsdDogV1MgfSkgPT4ge1xuICAgICAgdGhpcy5jb25uID0gbmV3IFdTKHRoaXMuZW5kcG9pbnRVUkwoKSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIH0pXG4gICAgICB0aGlzLnNldHVwQ29ubmVjdGlvbigpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBVUkwgb2YgdGhlIHdlYnNvY2tldC5cbiAgICogQHJldHVybnMgc3RyaW5nIFRoZSBVUkwgb2YgdGhlIHdlYnNvY2tldC5cbiAgICovXG4gIGVuZHBvaW50VVJMKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2FwcGVuZFBhcmFtcyhcbiAgICAgIHRoaXMuZW5kUG9pbnQsXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBhcmFtcywgeyB2c246IFZTTiB9KVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gY29kZSBBIG51bWVyaWMgc3RhdHVzIGNvZGUgdG8gc2VuZCBvbiBkaXNjb25uZWN0LlxuICAgKiBAcGFyYW0gcmVhc29uIEEgY3VzdG9tIHJlYXNvbiBmb3IgdGhlIGRpc2Nvbm5lY3QuXG4gICAqL1xuICBkaXNjb25uZWN0KGNvZGU/OiBudW1iZXIsIHJlYXNvbj86IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZnVuY3Rpb24gKCkge30gLy8gbm9vcFxuICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgdGhpcy5jb25uLmNsb3NlKGNvZGUsIHJlYXNvbiA/PyAnJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29ubi5jbG9zZSgpXG4gICAgICB9XG4gICAgICB0aGlzLmNvbm4gPSBudWxsXG4gICAgICAvLyByZW1vdmUgb3BlbiBoYW5kbGVzXG4gICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyICYmIGNsZWFySW50ZXJ2YWwodGhpcy5oZWFydGJlYXRUaW1lcilcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBjcmVhdGVkIGNoYW5uZWxzXG4gICAqL1xuICBnZXRDaGFubmVscygpOiBSZWFsdGltZUNoYW5uZWxbXSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgYSBzaW5nbGUgY2hhbm5lbFxuICAgKiBAcGFyYW0gY2hhbm5lbCBBIFJlYWx0aW1lQ2hhbm5lbCBpbnN0YW5jZVxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQ2hhbm5lbChcbiAgICBjaGFubmVsOiBSZWFsdGltZUNoYW5uZWxcbiAgKTogUHJvbWlzZTxSZWFsdGltZVJlbW92ZUNoYW5uZWxSZXNwb25zZT4ge1xuICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IGNoYW5uZWwudW5zdWJzY3JpYmUoKVxuICAgIGlmICh0aGlzLmNoYW5uZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICB9XG4gICAgcmV0dXJuIHN0YXR1c1xuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhbGwgY2hhbm5lbHNcbiAgICovXG4gIGFzeW5jIHJlbW92ZUFsbENoYW5uZWxzKCk6IFByb21pc2U8UmVhbHRpbWVSZW1vdmVDaGFubmVsUmVzcG9uc2VbXT4ge1xuICAgIGNvbnN0IHZhbHVlc18xID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICB0aGlzLmNoYW5uZWxzLm1hcCgoY2hhbm5lbCkgPT4gY2hhbm5lbC51bnN1YnNjcmliZSgpKVxuICAgIClcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIHJldHVybiB2YWx1ZXNfMVxuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgdGhlIG1lc3NhZ2UuXG4gICAqXG4gICAqIEZvciBjdXN0b21pemVkIGxvZ2dpbmcsIGB0aGlzLmxvZ2dlcmAgY2FuIGJlIG92ZXJyaWRkZW4uXG4gICAqL1xuICBsb2coa2luZDogc3RyaW5nLCBtc2c6IHN0cmluZywgZGF0YT86IGFueSkge1xuICAgIHRoaXMubG9nZ2VyKGtpbmQsIG1zZywgZGF0YSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzb2NrZXQuXG4gICAqL1xuICBjb25uZWN0aW9uU3RhdGUoKTogQ09OTkVDVElPTl9TVEFURSB7XG4gICAgc3dpdGNoICh0aGlzLmNvbm4gJiYgdGhpcy5jb25uLnJlYWR5U3RhdGUpIHtcbiAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nOlxuICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5Db25uZWN0aW5nXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMub3BlbjpcbiAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuT3BlblxuICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLmNsb3Npbmc6XG4gICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLkNsb3NpbmdcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLkNsb3NlZFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGB0cnVlYCBpcyB0aGUgY29ubmVjdGlvbiBpcyBvcGVuLlxuICAgKi9cbiAgaXNDb25uZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblN0YXRlKCkgPT09IENPTk5FQ1RJT05fU1RBVEUuT3BlblxuICB9XG5cbiAgY2hhbm5lbChcbiAgICB0b3BpYzogc3RyaW5nLFxuICAgIHBhcmFtczogUmVhbHRpbWVDaGFubmVsT3B0aW9ucyA9IHsgY29uZmlnOiB7fSB9XG4gICk6IFJlYWx0aW1lQ2hhbm5lbCB7XG4gICAgY29uc3QgY2hhbiA9IG5ldyBSZWFsdGltZUNoYW5uZWwoYHJlYWx0aW1lOiR7dG9waWN9YCwgcGFyYW1zLCB0aGlzKVxuICAgIHRoaXMuY2hhbm5lbHMucHVzaChjaGFuKVxuICAgIHJldHVybiBjaGFuXG4gIH1cblxuICAvKipcbiAgICogUHVzaCBvdXQgYSBtZXNzYWdlIGlmIHRoZSBzb2NrZXQgaXMgY29ubmVjdGVkLlxuICAgKlxuICAgKiBJZiB0aGUgc29ja2V0IGlzIG5vdCBjb25uZWN0ZWQsIHRoZSBtZXNzYWdlIGdldHMgZW5xdWV1ZWQgd2l0aGluIGEgbG9jYWwgYnVmZmVyLCBhbmQgc2VudCBvdXQgd2hlbiBhIGNvbm5lY3Rpb24gaXMgbmV4dCBlc3RhYmxpc2hlZC5cbiAgICovXG4gIHB1c2goZGF0YTogUmVhbHRpbWVNZXNzYWdlKTogdm9pZCB7XG4gICAgY29uc3QgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiB9ID0gZGF0YVxuICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5lbmNvZGUoZGF0YSwgKHJlc3VsdDogYW55KSA9PiB7XG4gICAgICAgIHRoaXMuY29ubj8uc2VuZChyZXN1bHQpXG4gICAgICB9KVxuICAgIH1cbiAgICB0aGlzLmxvZygncHVzaCcsIGAke3RvcGljfSAke2V2ZW50fSAoJHtyZWZ9KWAsIHBheWxvYWQpXG4gICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgY2FsbGJhY2soKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgSldUIGFjY2VzcyB0b2tlbiB1c2VkIGZvciBjaGFubmVsIHN1YnNjcmlwdGlvbiBhdXRob3JpemF0aW9uIGFuZCBSZWFsdGltZSBSTFMuXG4gICAqXG4gICAqIElmIHBhcmFtIGlzIG51bGwgaXQgd2lsbCB1c2UgdGhlIGBhY2Nlc3NUb2tlbmAgY2FsbGJhY2sgZnVuY3Rpb24gb3IgdGhlIHRva2VuIHNldCBvbiB0aGUgY2xpZW50LlxuICAgKlxuICAgKiBPbiBjYWxsYmFjayB1c2VkLCBpdCB3aWxsIHNldCB0aGUgdmFsdWUgb2YgdGhlIHRva2VuIGludGVybmFsIHRvIHRoZSBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSB0b2tlbiBBIEpXVCBzdHJpbmcgdG8gb3ZlcnJpZGUgdGhlIHRva2VuIHNldCBvbiB0aGUgY2xpZW50LlxuICAgKi9cbiAgYXN5bmMgc2V0QXV0aCh0b2tlbjogc3RyaW5nIHwgbnVsbCA9IG51bGwpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsZXQgdG9rZW5Ub1NlbmQgPVxuICAgICAgdG9rZW4gfHxcbiAgICAgICh0aGlzLmFjY2Vzc1Rva2VuICYmIChhd2FpdCB0aGlzLmFjY2Vzc1Rva2VuKCkpKSB8fFxuICAgICAgdGhpcy5hY2Nlc3NUb2tlblZhbHVlXG5cbiAgICBpZiAodG9rZW5Ub1NlbmQpIHtcbiAgICAgIGxldCBwYXJzZWQgPSBudWxsXG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKGF0b2IodG9rZW5Ub1NlbmQuc3BsaXQoJy4nKVsxXSkpXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICBpZiAocGFyc2VkICYmIHBhcnNlZC5leHApIHtcbiAgICAgICAgbGV0IG5vdyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApXG4gICAgICAgIGxldCB2YWxpZCA9IG5vdyAtIHBhcnNlZC5leHAgPCAwXG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICAgICdhdXRoJyxcbiAgICAgICAgICAgIGBJbnZhbGlkSldUVG9rZW46IEludmFsaWQgdmFsdWUgZm9yIEpXVCBjbGFpbSBcImV4cFwiIHdpdGggdmFsdWUgJHtwYXJzZWQuZXhwfWBcbiAgICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgYEludmFsaWRKV1RUb2tlbjogSW52YWxpZCB2YWx1ZSBmb3IgSldUIGNsYWltIFwiZXhwXCIgd2l0aCB2YWx1ZSAke3BhcnNlZC5leHB9YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmFjY2Vzc1Rva2VuVmFsdWUgPSB0b2tlblRvU2VuZFxuICAgICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgIHRva2VuVG9TZW5kICYmIGNoYW5uZWwudXBkYXRlSm9pblBheWxvYWQoeyBhY2Nlc3NfdG9rZW46IHRva2VuVG9TZW5kIH0pXG5cbiAgICAgICAgaWYgKGNoYW5uZWwuam9pbmVkT25jZSAmJiBjaGFubmVsLl9pc0pvaW5lZCgpKSB7XG4gICAgICAgICAgY2hhbm5lbC5fcHVzaChDSEFOTkVMX0VWRU5UUy5hY2Nlc3NfdG9rZW4sIHtcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogdG9rZW5Ub1NlbmQsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgaGVhcnRiZWF0IG1lc3NhZ2UgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQuXG4gICAqL1xuICBhc3luYyBzZW5kSGVhcnRiZWF0KCkge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZikge1xuICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbFxuICAgICAgdGhpcy5sb2coXG4gICAgICAgICd0cmFuc3BvcnQnLFxuICAgICAgICAnaGVhcnRiZWF0IHRpbWVvdXQuIEF0dGVtcHRpbmcgdG8gcmUtZXN0YWJsaXNoIGNvbm5lY3Rpb24nXG4gICAgICApXG4gICAgICB0aGlzLmNvbm4/LmNsb3NlKFdTX0NMT1NFX05PUk1BTCwgJ2hlYXJiZWF0IHRpbWVvdXQnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IHRoaXMuX21ha2VSZWYoKVxuICAgIHRoaXMucHVzaCh7XG4gICAgICB0b3BpYzogJ3Bob2VuaXgnLFxuICAgICAgZXZlbnQ6ICdoZWFydGJlYXQnLFxuICAgICAgcGF5bG9hZDoge30sXG4gICAgICByZWY6IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZixcbiAgICB9KVxuICAgIHRoaXMuc2V0QXV0aCgpXG4gIH1cblxuICAvKipcbiAgICogRmx1c2hlcyBzZW5kIGJ1ZmZlclxuICAgKi9cbiAgZmx1c2hTZW5kQnVmZmVyKCkge1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlci5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSlcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZSBlaXRoZXIgY3VzdG9tIGZldGNoLCBpZiBwcm92aWRlZCwgb3IgZGVmYXVsdCBmZXRjaCB0byBtYWtlIEhUVFAgcmVxdWVzdHNcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoPzogRmV0Y2gpOiBGZXRjaCA9PiB7XG4gICAgbGV0IF9mZXRjaDogRmV0Y2hcbiAgICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICAgIF9mZXRjaCA9IGN1c3RvbUZldGNoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT5cbiAgICAgICAgaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcgYXMgYW55KS50aGVuKCh7IGRlZmF1bHQ6IGZldGNoIH0pID0+XG4gICAgICAgICAgZmV0Y2goLi4uYXJncylcbiAgICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICBfZmV0Y2ggPSBmZXRjaFxuICAgIH1cbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IF9mZXRjaCguLi5hcmdzKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmV4dCBtZXNzYWdlIHJlZiwgYWNjb3VudGluZyBmb3Igb3ZlcmZsb3dzXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX21ha2VSZWYoKTogc3RyaW5nIHtcbiAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYgKyAxXG4gICAgaWYgKG5ld1JlZiA9PT0gdGhpcy5yZWYpIHtcbiAgICAgIHRoaXMucmVmID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZiA9IG5ld1JlZlxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlZi50b1N0cmluZygpXG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBjaGFubmVscyB3aXRoIHRoZSBzcGVjaWZpZWQgdG9waWMuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2xlYXZlT3BlblRvcGljKHRvcGljOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBsZXQgZHVwQ2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZmluZChcbiAgICAgIChjKSA9PiBjLnRvcGljID09PSB0b3BpYyAmJiAoYy5faXNKb2luZWQoKSB8fCBjLl9pc0pvaW5pbmcoKSlcbiAgICApXG4gICAgaWYgKGR1cENoYW5uZWwpIHtcbiAgICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCBgbGVhdmluZyBkdXBsaWNhdGUgdG9waWMgXCIke3RvcGljfVwiYClcbiAgICAgIGR1cENoYW5uZWwudW5zdWJzY3JpYmUoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgc3Vic2NyaXB0aW9uIGZyb20gdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIGNoYW5uZWwgQW4gb3BlbiBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3JlbW92ZShjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwpIHtcbiAgICB0aGlzLmNoYW5uZWxzID0gdGhpcy5jaGFubmVscy5maWx0ZXIoXG4gICAgICAoYzogUmVhbHRpbWVDaGFubmVsKSA9PiBjLl9qb2luUmVmKCkgIT09IGNoYW5uZWwuX2pvaW5SZWYoKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIGNvbm5lY3Rpb24gaGFuZGxlcnMuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBzZXR1cENvbm5lY3Rpb24oKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgdGhpcy5jb25uLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInXG4gICAgICB0aGlzLmNvbm4ub25vcGVuID0gKCkgPT4gdGhpcy5fb25Db25uT3BlbigpXG4gICAgICB0aGlzLmNvbm4ub25lcnJvciA9IChlcnJvcjogV2ViU29ja2V0TGlrZUVycm9yKSA9PlxuICAgICAgICB0aGlzLl9vbkNvbm5FcnJvcihlcnJvciBhcyBXZWJTb2NrZXRMaWtlRXJyb3IpXG4gICAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gKGV2ZW50OiBhbnkpID0+IHRoaXMuX29uQ29ubk1lc3NhZ2UoZXZlbnQpXG4gICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IChldmVudDogYW55KSA9PiB0aGlzLl9vbkNvbm5DbG9zZShldmVudClcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX29uQ29ubk1lc3NhZ2UocmF3TWVzc2FnZTogeyBkYXRhOiBhbnkgfSkge1xuICAgIHRoaXMuZGVjb2RlKHJhd01lc3NhZ2UuZGF0YSwgKG1zZzogUmVhbHRpbWVNZXNzYWdlKSA9PiB7XG4gICAgICBsZXQgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiB9ID0gbXNnXG5cbiAgICAgIGlmIChyZWYgJiYgcmVmID09PSB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbFxuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZyhcbiAgICAgICAgJ3JlY2VpdmUnLFxuICAgICAgICBgJHtwYXlsb2FkLnN0YXR1cyB8fCAnJ30gJHt0b3BpY30gJHtldmVudH0gJHtcbiAgICAgICAgICAocmVmICYmICcoJyArIHJlZiArICcpJykgfHwgJydcbiAgICAgICAgfWAsXG4gICAgICAgIHBheWxvYWRcbiAgICAgIClcbiAgICAgIHRoaXMuY2hhbm5lbHNcbiAgICAgICAgLmZpbHRlcigoY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsKSA9PiBjaGFubmVsLl9pc01lbWJlcih0b3BpYykpXG4gICAgICAgIC5mb3JFYWNoKChjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwpID0+XG4gICAgICAgICAgY2hhbm5lbC5fdHJpZ2dlcihldmVudCwgcGF5bG9hZCwgcmVmKVxuICAgICAgICApXG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKG1zZykpXG4gICAgfSlcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBhc3luYyBfb25Db25uT3BlbigpIHtcbiAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgYGNvbm5lY3RlZCB0byAke3RoaXMuZW5kcG9pbnRVUkwoKX1gKVxuICAgIHRoaXMuZmx1c2hTZW5kQnVmZmVyKClcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyICYmIGNsZWFySW50ZXJ2YWwodGhpcy5oZWFydGJlYXRUaW1lcilcbiAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksXG4gICAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNc1xuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy53b3JrZXJVcmwpIHtcbiAgICAgICAgdGhpcy5sb2coJ3dvcmtlcicsIGBzdGFydGluZyB3b3JrZXIgZm9yIGZyb20gJHt0aGlzLndvcmtlclVybH1gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2coJ3dvcmtlcicsIGBzdGFydGluZyBkZWZhdWx0IHdvcmtlcmApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9iamVjdFVybCA9IHRoaXMuX3dvcmtlck9iamVjdFVybCh0aGlzLndvcmtlclVybCEpXG4gICAgICB0aGlzLndvcmtlclJlZiA9IG5ldyBXb3JrZXIob2JqZWN0VXJsKVxuICAgICAgdGhpcy53b3JrZXJSZWYub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICB0aGlzLmxvZygnd29ya2VyJywgJ3dvcmtlciBlcnJvcicsIGVycm9yLm1lc3NhZ2UpXG4gICAgICAgIHRoaXMud29ya2VyUmVmIS50ZXJtaW5hdGUoKVxuICAgICAgfVxuICAgICAgdGhpcy53b3JrZXJSZWYub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5kYXRhLmV2ZW50ID09PSAna2VlcEFsaXZlJykge1xuICAgICAgICAgIHRoaXMuc2VuZEhlYXJ0YmVhdCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMud29ya2VyUmVmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgZXZlbnQ6ICdzdGFydCcsXG4gICAgICAgIGludGVydmFsOiB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMsXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSkhXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG5cbiAgcHJpdmF0ZSBfb25Db25uQ2xvc2UoZXZlbnQ6IGFueSkge1xuICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCAnY2xvc2UnLCBldmVudClcbiAgICB0aGlzLl90cmlnZ2VyQ2hhbkVycm9yKClcbiAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyICYmIGNsZWFySW50ZXJ2YWwodGhpcy5oZWFydGJlYXRUaW1lcilcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5jbG9zZS5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soZXZlbnQpKVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9vbkNvbm5FcnJvcihlcnJvcjogV2ViU29ja2V0TGlrZUVycm9yKSB7XG4gICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIGVycm9yLm1lc3NhZ2UpXG4gICAgdGhpcy5fdHJpZ2dlckNoYW5FcnJvcigpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soZXJyb3IpKVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF90cmlnZ2VyQ2hhbkVycm9yKCkge1xuICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsKSA9PlxuICAgICAgY2hhbm5lbC5fdHJpZ2dlcihDSEFOTkVMX0VWRU5UUy5lcnJvcilcbiAgICApXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX2FwcGVuZFBhcmFtcyhcbiAgICB1cmw6IHN0cmluZyxcbiAgICBwYXJhbXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgKTogc3RyaW5nIHtcbiAgICBpZiAoT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB1cmxcbiAgICB9XG4gICAgY29uc3QgcHJlZml4ID0gdXJsLm1hdGNoKC9cXD8vKSA/ICcmJyA6ICc/J1xuICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpXG5cbiAgICByZXR1cm4gYCR7dXJsfSR7cHJlZml4fSR7cXVlcnl9YFxuICB9XG5cbiAgcHJpdmF0ZSBfd29ya2VyT2JqZWN0VXJsKHVybDogc3RyaW5nIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgICBsZXQgcmVzdWx0X3VybDogc3RyaW5nXG4gICAgaWYgKHVybCkge1xuICAgICAgcmVzdWx0X3VybCA9IHVybFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW1dPUktFUl9TQ1JJUFRdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KVxuICAgICAgcmVzdWx0X3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdF91cmxcbiAgfVxufVxuXG5jbGFzcyBXU1dlYlNvY2tldER1bW15IHtcbiAgYmluYXJ5VHlwZTogc3RyaW5nID0gJ2FycmF5YnVmZmVyJ1xuICBjbG9zZTogRnVuY3Rpb25cbiAgb25jbG9zZTogRnVuY3Rpb24gPSAoKSA9PiB7fVxuICBvbmVycm9yOiBGdW5jdGlvbiA9ICgpID0+IHt9XG4gIG9ubWVzc2FnZTogRnVuY3Rpb24gPSAoKSA9PiB7fVxuICBvbm9wZW46IEZ1bmN0aW9uID0gKCkgPT4ge31cbiAgcmVhZHlTdGF0ZTogbnVtYmVyID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nXG4gIHNlbmQ6IEZ1bmN0aW9uID0gKCkgPT4ge31cbiAgdXJsOiBzdHJpbmcgfCBVUkwgfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICBfcHJvdG9jb2xzOiB1bmRlZmluZWQsXG4gICAgb3B0aW9uczogeyBjbG9zZTogRnVuY3Rpb24gfVxuICApIHtcbiAgICB0aGlzLnVybCA9IGFkZHJlc3NcbiAgICB0aGlzLmNsb3NlID0gb3B0aW9ucy5jbG9zZVxuICB9XG59XG4iLCAiZXhwb3J0IGNsYXNzIFN0b3JhZ2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHJvdGVjdGVkIF9faXNTdG9yYWdlRXJyb3IgPSB0cnVlXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnU3RvcmFnZUVycm9yJ1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0b3JhZ2VFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIFN0b3JhZ2VFcnJvciB7XG4gIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdfX2lzU3RvcmFnZUVycm9yJyBpbiBlcnJvclxufVxuXG5leHBvcnQgY2xhc3MgU3RvcmFnZUFwaUVycm9yIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcbiAgc3RhdHVzOiBudW1iZXJcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnU3RvcmFnZUFwaUVycm9yJ1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzXG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTdG9yYWdlVW5rbm93bkVycm9yIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcbiAgb3JpZ2luYWxFcnJvcjogdW5rbm93blxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgb3JpZ2luYWxFcnJvcjogdW5rbm93bikge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1N0b3JhZ2VVbmtub3duRXJyb3InXG4gICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvclxuICB9XG59XG4iLCAidHlwZSBGZXRjaCA9IHR5cGVvZiBmZXRjaFxuXG5leHBvcnQgY29uc3QgcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoPzogRmV0Y2gpOiBGZXRjaCA9PiB7XG4gIGxldCBfZmV0Y2g6IEZldGNoXG4gIGlmIChjdXN0b21GZXRjaCkge1xuICAgIF9mZXRjaCA9IGN1c3RvbUZldGNoXG4gIH0gZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgIF9mZXRjaCA9ICguLi5hcmdzKSA9PlxuICAgICAgaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcgYXMgYW55KS50aGVuKCh7IGRlZmF1bHQ6IGZldGNoIH0pID0+IGZldGNoKC4uLmFyZ3MpKVxuICB9IGVsc2Uge1xuICAgIF9mZXRjaCA9IGZldGNoXG4gIH1cbiAgcmV0dXJuICguLi5hcmdzKSA9PiBfZmV0Y2goLi4uYXJncylcbn1cblxuZXhwb3J0IGNvbnN0IHJlc29sdmVSZXNwb25zZSA9IGFzeW5jICgpOiBQcm9taXNlPHR5cGVvZiBSZXNwb25zZT4gPT4ge1xuICBpZiAodHlwZW9mIFJlc3BvbnNlID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gKGF3YWl0IGltcG9ydCgnQHN1cGFiYXNlL25vZGUtZmV0Y2gnIGFzIGFueSkpLlJlc3BvbnNlXG4gIH1cblxuICByZXR1cm4gUmVzcG9uc2Vcbn1cblxuZXhwb3J0IGNvbnN0IHJlY3Vyc2l2ZVRvQ2FtZWwgPSAoaXRlbTogUmVjb3JkPHN0cmluZywgYW55Pik6IHVua25vd24gPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgIHJldHVybiBpdGVtLm1hcCgoZWwpID0+IHJlY3Vyc2l2ZVRvQ2FtZWwoZWwpKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSAnZnVuY3Rpb24nIHx8IGl0ZW0gIT09IE9iamVjdChpdGVtKSkge1xuICAgIHJldHVybiBpdGVtXG4gIH1cblxuICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fVxuICBPYmplY3QuZW50cmllcyhpdGVtKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBuZXdLZXkgPSBrZXkucmVwbGFjZSgvKFstX11bYS16XSkvZ2ksIChjKSA9PiBjLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvWy1fXS9nLCAnJykpXG4gICAgcmVzdWx0W25ld0tleV0gPSByZWN1cnNpdmVUb0NhbWVsKHZhbHVlKVxuICB9KVxuXG4gIHJldHVybiByZXN1bHRcbn1cbiIsICJpbXBvcnQgeyBTdG9yYWdlQXBpRXJyb3IsIFN0b3JhZ2VVbmtub3duRXJyb3IgfSBmcm9tICcuL2Vycm9ycydcbmltcG9ydCB7IHJlc29sdmVSZXNwb25zZSB9IGZyb20gJy4vaGVscGVycydcbmltcG9ydCB7IEZldGNoUGFyYW1ldGVycyB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCB0eXBlIEZldGNoID0gdHlwZW9mIGZldGNoXG5cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hPcHRpb25zIHtcbiAgaGVhZGVycz86IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuICBub1Jlc29sdmVKc29uPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBSZXF1ZXN0TWV0aG9kVHlwZSA9ICdHRVQnIHwgJ1BPU1QnIHwgJ1BVVCcgfCAnREVMRVRFJyB8ICdIRUFEJ1xuXG5jb25zdCBfZ2V0RXJyb3JNZXNzYWdlID0gKGVycjogYW55KTogc3RyaW5nID0+XG4gIGVyci5tc2cgfHwgZXJyLm1lc3NhZ2UgfHwgZXJyLmVycm9yX2Rlc2NyaXB0aW9uIHx8IGVyci5lcnJvciB8fCBKU09OLnN0cmluZ2lmeShlcnIpXG5cbmNvbnN0IGhhbmRsZUVycm9yID0gYXN5bmMgKFxuICBlcnJvcjogdW5rbm93bixcbiAgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkLFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zXG4pID0+IHtcbiAgY29uc3QgUmVzID0gYXdhaXQgcmVzb2x2ZVJlc3BvbnNlKClcblxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBSZXMgJiYgIW9wdGlvbnM/Lm5vUmVzb2x2ZUpzb24pIHtcbiAgICBlcnJvclxuICAgICAgLmpzb24oKVxuICAgICAgLnRoZW4oKGVycikgPT4ge1xuICAgICAgICByZWplY3QobmV3IFN0b3JhZ2VBcGlFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVyciksIGVycm9yLnN0YXR1cyB8fCA1MDApKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgU3RvcmFnZVVua25vd25FcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVyciksIGVycikpXG4gICAgICB9KVxuICB9IGVsc2Uge1xuICAgIHJlamVjdChuZXcgU3RvcmFnZVVua25vd25FcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSwgZXJyb3IpKVxuICB9XG59XG5cbmNvbnN0IF9nZXRSZXF1ZXN0UGFyYW1zID0gKFxuICBtZXRob2Q6IFJlcXVlc3RNZXRob2RUeXBlLFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzLFxuICBib2R5Pzogb2JqZWN0XG4pID0+IHtcbiAgY29uc3QgcGFyYW1zOiB7IFtrOiBzdHJpbmddOiBhbnkgfSA9IHsgbWV0aG9kLCBoZWFkZXJzOiBvcHRpb25zPy5oZWFkZXJzIHx8IHt9IH1cblxuICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgIHJldHVybiBwYXJhbXNcbiAgfVxuXG4gIHBhcmFtcy5oZWFkZXJzID0geyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLCAuLi5vcHRpb25zPy5oZWFkZXJzIH1cblxuICBpZiAoYm9keSkge1xuICAgIHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgfVxuICByZXR1cm4geyAuLi5wYXJhbXMsIC4uLnBhcmFtZXRlcnMgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBfaGFuZGxlUmVxdWVzdChcbiAgZmV0Y2hlcjogRmV0Y2gsXG4gIG1ldGhvZDogUmVxdWVzdE1ldGhvZFR5cGUsXG4gIHVybDogc3RyaW5nLFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzLFxuICBib2R5Pzogb2JqZWN0XG4pOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZldGNoZXIodXJsLCBfZ2V0UmVxdWVzdFBhcmFtcyhtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpKVxuICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoIXJlc3VsdC5vaykgdGhyb3cgcmVzdWx0XG4gICAgICAgIGlmIChvcHRpb25zPy5ub1Jlc29sdmVKc29uKSByZXR1cm4gcmVzdWx0XG4gICAgICAgIHJldHVybiByZXN1bHQuanNvbigpXG4gICAgICB9KVxuICAgICAgLnRoZW4oKGRhdGEpID0+IHJlc29sdmUoZGF0YSkpXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiBoYW5kbGVFcnJvcihlcnJvciwgcmVqZWN0LCBvcHRpb25zKSlcbiAgfSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldChcbiAgZmV0Y2hlcjogRmV0Y2gsXG4gIHVybDogc3RyaW5nLFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzXG4pOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ0dFVCcsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycylcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBvc3QoXG4gIGZldGNoZXI6IEZldGNoLFxuICB1cmw6IHN0cmluZyxcbiAgYm9keTogb2JqZWN0LFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzXG4pOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ1BPU1QnLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwdXQoXG4gIGZldGNoZXI6IEZldGNoLFxuICB1cmw6IHN0cmluZyxcbiAgYm9keTogb2JqZWN0LFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzXG4pOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ1BVVCcsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhlYWQoXG4gIGZldGNoZXI6IEZldGNoLFxuICB1cmw6IHN0cmluZyxcbiAgb3B0aW9ucz86IEZldGNoT3B0aW9ucyxcbiAgcGFyYW1ldGVycz86IEZldGNoUGFyYW1ldGVyc1xuKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KFxuICAgIGZldGNoZXIsXG4gICAgJ0hFQUQnLFxuICAgIHVybCxcbiAgICB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICB9LFxuICAgIHBhcmFtZXRlcnNcbiAgKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVtb3ZlKFxuICBmZXRjaGVyOiBGZXRjaCxcbiAgdXJsOiBzdHJpbmcsXG4gIGJvZHk6IG9iamVjdCxcbiAgb3B0aW9ucz86IEZldGNoT3B0aW9ucyxcbiAgcGFyYW1ldGVycz86IEZldGNoUGFyYW1ldGVyc1xuKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdERUxFVEUnLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpXG59XG4iLCAiaW1wb3J0IHsgaXNTdG9yYWdlRXJyb3IsIFN0b3JhZ2VFcnJvciwgU3RvcmFnZVVua25vd25FcnJvciB9IGZyb20gJy4uL2xpYi9lcnJvcnMnXG5pbXBvcnQgeyBGZXRjaCwgZ2V0LCBoZWFkLCBwb3N0LCByZW1vdmUgfSBmcm9tICcuLi9saWIvZmV0Y2gnXG5pbXBvcnQgeyByZWN1cnNpdmVUb0NhbWVsLCByZXNvbHZlRmV0Y2ggfSBmcm9tICcuLi9saWIvaGVscGVycydcbmltcG9ydCB7XG4gIEZpbGVPYmplY3QsXG4gIEZpbGVPcHRpb25zLFxuICBTZWFyY2hPcHRpb25zLFxuICBGZXRjaFBhcmFtZXRlcnMsXG4gIFRyYW5zZm9ybU9wdGlvbnMsXG4gIERlc3RpbmF0aW9uT3B0aW9ucyxcbiAgRmlsZU9iamVjdFYyLFxuICBDYW1lbGl6ZSxcbn0gZnJvbSAnLi4vbGliL3R5cGVzJ1xuXG5jb25zdCBERUZBVUxUX1NFQVJDSF9PUFRJT05TID0ge1xuICBsaW1pdDogMTAwLFxuICBvZmZzZXQ6IDAsXG4gIHNvcnRCeToge1xuICAgIGNvbHVtbjogJ25hbWUnLFxuICAgIG9yZGVyOiAnYXNjJyxcbiAgfSxcbn1cblxuY29uc3QgREVGQVVMVF9GSUxFX09QVElPTlM6IEZpbGVPcHRpb25zID0ge1xuICBjYWNoZUNvbnRyb2w6ICczNjAwJyxcbiAgY29udGVudFR5cGU6ICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnLFxuICB1cHNlcnQ6IGZhbHNlLFxufVxuXG50eXBlIEZpbGVCb2R5ID1cbiAgfCBBcnJheUJ1ZmZlclxuICB8IEFycmF5QnVmZmVyVmlld1xuICB8IEJsb2JcbiAgfCBCdWZmZXJcbiAgfCBGaWxlXG4gIHwgRm9ybURhdGFcbiAgfCBOb2RlSlMuUmVhZGFibGVTdHJlYW1cbiAgfCBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxuICB8IFVSTFNlYXJjaFBhcmFtc1xuICB8IHN0cmluZ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdG9yYWdlRmlsZUFwaSB7XG4gIHByb3RlY3RlZCB1cmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxuICBwcm90ZWN0ZWQgYnVja2V0SWQ/OiBzdHJpbmdcbiAgcHJvdGVjdGVkIGZldGNoOiBGZXRjaFxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fSxcbiAgICBidWNrZXRJZD86IHN0cmluZyxcbiAgICBmZXRjaD86IEZldGNoXG4gICkge1xuICAgIHRoaXMudXJsID0gdXJsXG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVyc1xuICAgIHRoaXMuYnVja2V0SWQgPSBidWNrZXRJZFxuICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goZmV0Y2gpXG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkcyBhIGZpbGUgdG8gYW4gZXhpc3RpbmcgYnVja2V0IG9yIHJlcGxhY2VzIGFuIGV4aXN0aW5nIGZpbGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoIHdpdGggYSBuZXcgb25lLlxuICAgKlxuICAgKiBAcGFyYW0gbWV0aG9kIEhUVFAgbWV0aG9kLlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgcmVsYXRpdmUgZmlsZSBwYXRoLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG4gICAqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgdXBsb2FkT3JVcGRhdGUoXG4gICAgbWV0aG9kOiAnUE9TVCcgfCAnUFVUJyxcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgZmlsZUJvZHk6IEZpbGVCb2R5LFxuICAgIGZpbGVPcHRpb25zPzogRmlsZU9wdGlvbnNcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBpZDogc3RyaW5nOyBwYXRoOiBzdHJpbmc7IGZ1bGxQYXRoOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBib2R5XG4gICAgICBjb25zdCBvcHRpb25zID0geyAuLi5ERUZBVUxUX0ZJTEVfT1BUSU9OUywgLi4uZmlsZU9wdGlvbnMgfVxuICAgICAgbGV0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgLi4uKG1ldGhvZCA9PT0gJ1BPU1QnICYmIHsgJ3gtdXBzZXJ0JzogU3RyaW5nKG9wdGlvbnMudXBzZXJ0IGFzIGJvb2xlYW4pIH0pLFxuICAgICAgfVxuXG4gICAgICBjb25zdCBtZXRhZGF0YSA9IG9wdGlvbnMubWV0YWRhdGFcblxuICAgICAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgYm9keSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCBhcyBzdHJpbmcpXG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgIGJvZHkuYXBwZW5kKCdtZXRhZGF0YScsIHRoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKVxuICAgICAgICB9XG4gICAgICAgIGJvZHkuYXBwZW5kKCcnLCBmaWxlQm9keSlcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgIGJvZHkgPSBmaWxlQm9keVxuICAgICAgICBib2R5LmFwcGVuZCgnY2FjaGVDb250cm9sJywgb3B0aW9ucy5jYWNoZUNvbnRyb2wgYXMgc3RyaW5nKVxuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICBib2R5LmFwcGVuZCgnbWV0YWRhdGEnLCB0aGlzLmVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYm9keSA9IGZpbGVCb2R5XG4gICAgICAgIGhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSA9IGBtYXgtYWdlPSR7b3B0aW9ucy5jYWNoZUNvbnRyb2x9YFxuICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IG9wdGlvbnMuY29udGVudFR5cGUgYXMgc3RyaW5nXG5cbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgaGVhZGVyc1sneC1tZXRhZGF0YSddID0gdGhpcy50b0Jhc2U2NCh0aGlzLmVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmlsZU9wdGlvbnM/LmhlYWRlcnMpIHtcbiAgICAgICAgaGVhZGVycyA9IHsgLi4uaGVhZGVycywgLi4uZmlsZU9wdGlvbnMuaGVhZGVycyB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNsZWFuUGF0aCA9IHRoaXMuX3JlbW92ZUVtcHR5Rm9sZGVycyhwYXRoKVxuICAgICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgoY2xlYW5QYXRoKVxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5mZXRjaChgJHt0aGlzLnVybH0vb2JqZWN0LyR7X3BhdGh9YCwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGJvZHk6IGJvZHkgYXMgQm9keUluaXQsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIC4uLihvcHRpb25zPy5kdXBsZXggPyB7IGR1cGxleDogb3B0aW9ucy5kdXBsZXggfSA6IHt9KSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpXG5cbiAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7IHBhdGg6IGNsZWFuUGF0aCwgaWQ6IGRhdGEuSWQsIGZ1bGxQYXRoOiBkYXRhLktleSB9LFxuICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlcnJvciA9IGRhdGFcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkcyBhIGZpbGUgdG8gYW4gZXhpc3RpbmcgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAqL1xuICBhc3luYyB1cGxvYWQoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGZpbGVCb2R5OiBGaWxlQm9keSxcbiAgICBmaWxlT3B0aW9ucz86IEZpbGVPcHRpb25zXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgaWQ6IHN0cmluZzsgcGF0aDogc3RyaW5nOyBmdWxsUGF0aDogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHJldHVybiB0aGlzLnVwbG9hZE9yVXBkYXRlKCdQT1NUJywgcGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwbG9hZCBhIGZpbGUgd2l0aCBhIHRva2VuIGdlbmVyYXRlZCBmcm9tIGBjcmVhdGVTaWduZWRVcGxvYWRVcmxgLlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuICAgKiBAcGFyYW0gdG9rZW4gVGhlIHRva2VuIGdlbmVyYXRlZCBmcm9tIGBjcmVhdGVTaWduZWRVcGxvYWRVcmxgXG4gICAqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cbiAgICovXG4gIGFzeW5jIHVwbG9hZFRvU2lnbmVkVXJsKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICB0b2tlbjogc3RyaW5nLFxuICAgIGZpbGVCb2R5OiBGaWxlQm9keSxcbiAgICBmaWxlT3B0aW9ucz86IEZpbGVPcHRpb25zXG4gICkge1xuICAgIGNvbnN0IGNsZWFuUGF0aCA9IHRoaXMuX3JlbW92ZUVtcHR5Rm9sZGVycyhwYXRoKVxuICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKGNsZWFuUGF0aClcblxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGhpcy51cmwgKyBgL29iamVjdC91cGxvYWQvc2lnbi8ke19wYXRofWApXG4gICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3Rva2VuJywgdG9rZW4pXG5cbiAgICB0cnkge1xuICAgICAgbGV0IGJvZHlcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IHVwc2VydDogREVGQVVMVF9GSUxFX09QVElPTlMudXBzZXJ0LCAuLi5maWxlT3B0aW9ucyB9XG4gICAgICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgIC4uLnsgJ3gtdXBzZXJ0JzogU3RyaW5nKG9wdGlvbnMudXBzZXJ0IGFzIGJvb2xlYW4pIH0sXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGJvZHkgPSBuZXcgRm9ybURhdGEoKVxuICAgICAgICBib2R5LmFwcGVuZCgnY2FjaGVDb250cm9sJywgb3B0aW9ucy5jYWNoZUNvbnRyb2wgYXMgc3RyaW5nKVxuICAgICAgICBib2R5LmFwcGVuZCgnJywgZmlsZUJvZHkpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICBib2R5ID0gZmlsZUJvZHlcbiAgICAgICAgYm9keS5hcHBlbmQoJ2NhY2hlQ29udHJvbCcsIG9wdGlvbnMuY2FjaGVDb250cm9sIGFzIHN0cmluZylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvZHkgPSBmaWxlQm9keVxuICAgICAgICBoZWFkZXJzWydjYWNoZS1jb250cm9sJ10gPSBgbWF4LWFnZT0ke29wdGlvbnMuY2FjaGVDb250cm9sfWBcbiAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBvcHRpb25zLmNvbnRlbnRUeXBlIGFzIHN0cmluZ1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIGJvZHk6IGJvZHkgYXMgQm9keUluaXQsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKVxuXG4gICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogeyBwYXRoOiBjbGVhblBhdGgsIGZ1bGxQYXRoOiBkYXRhLktleSB9LFxuICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlcnJvciA9IGRhdGFcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNpZ25lZCB1cGxvYWQgVVJMLlxuICAgKiBTaWduZWQgdXBsb2FkIFVSTHMgY2FuIGJlIHVzZWQgdG8gdXBsb2FkIGZpbGVzIHRvIHRoZSBidWNrZXQgd2l0aG91dCBmdXJ0aGVyIGF1dGhlbnRpY2F0aW9uLlxuICAgKiBUaGV5IGFyZSB2YWxpZCBmb3IgMiBob3Vycy5cbiAgICogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgKiBAcGFyYW0gb3B0aW9ucy51cHNlcnQgSWYgc2V0IHRvIHRydWUsIGFsbG93cyB0aGUgZmlsZSB0byBiZSBvdmVyd3JpdHRlbiBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNpZ25lZFVwbG9hZFVybChcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgdXBzZXJ0OiBib29sZWFuIH1cbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBzaWduZWRVcmw6IHN0cmluZzsgdG9rZW46IHN0cmluZzsgcGF0aDogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aClcblxuICAgICAgY29uc3QgaGVhZGVycyA9IHsgLi4udGhpcy5oZWFkZXJzIH1cblxuICAgICAgaWYgKG9wdGlvbnM/LnVwc2VydCkge1xuICAgICAgICBoZWFkZXJzWyd4LXVwc2VydCddID0gJ3RydWUnXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vb2JqZWN0L3VwbG9hZC9zaWduLyR7X3BhdGh9YCxcbiAgICAgICAge30sXG4gICAgICAgIHsgaGVhZGVycyB9XG4gICAgICApXG5cbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGhpcy51cmwgKyBkYXRhLnVybClcblxuICAgICAgY29uc3QgdG9rZW4gPSB1cmwuc2VhcmNoUGFyYW1zLmdldCgndG9rZW4nKVxuXG4gICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoJ05vIHRva2VuIHJldHVybmVkIGJ5IEFQSScpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgc2lnbmVkVXJsOiB1cmwudG9TdHJpbmcoKSwgcGF0aCwgdG9rZW4gfSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYW4gZXhpc3RpbmcgZmlsZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggd2l0aCBhIG5ldyBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIFRoZSByZWxhdGl2ZSBmaWxlIHBhdGguIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBmaWxlQm9keTpcbiAgICAgIHwgQXJyYXlCdWZmZXJcbiAgICAgIHwgQXJyYXlCdWZmZXJWaWV3XG4gICAgICB8IEJsb2JcbiAgICAgIHwgQnVmZmVyXG4gICAgICB8IEZpbGVcbiAgICAgIHwgRm9ybURhdGFcbiAgICAgIHwgTm9kZUpTLlJlYWRhYmxlU3RyZWFtXG4gICAgICB8IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+XG4gICAgICB8IFVSTFNlYXJjaFBhcmFtc1xuICAgICAgfCBzdHJpbmcsXG4gICAgZmlsZU9wdGlvbnM/OiBGaWxlT3B0aW9uc1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IGlkOiBzdHJpbmc7IHBhdGg6IHN0cmluZzsgZnVsbFBhdGg6IHN0cmluZyB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICByZXR1cm4gdGhpcy51cGxvYWRPclVwZGF0ZSgnUFVUJywgcGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIGV4aXN0aW5nIGZpbGUgdG8gYSBuZXcgcGF0aCBpbiB0aGUgc2FtZSBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tUGF0aCBUaGUgb3JpZ2luYWwgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAqIEBwYXJhbSB0b1BhdGggVGhlIG5ldyBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgbmV3IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS1uZXcucG5nYC5cbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGRlc3RpbmF0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBhc3luYyBtb3ZlKFxuICAgIGZyb21QYXRoOiBzdHJpbmcsXG4gICAgdG9QYXRoOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IERlc3RpbmF0aW9uT3B0aW9uc1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IG1lc3NhZ2U6IHN0cmluZyB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9vYmplY3QvbW92ZWAsXG4gICAgICAgIHtcbiAgICAgICAgICBidWNrZXRJZDogdGhpcy5idWNrZXRJZCxcbiAgICAgICAgICBzb3VyY2VLZXk6IGZyb21QYXRoLFxuICAgICAgICAgIGRlc3RpbmF0aW9uS2V5OiB0b1BhdGgsXG4gICAgICAgICAgZGVzdGluYXRpb25CdWNrZXQ6IG9wdGlvbnM/LmRlc3RpbmF0aW9uQnVja2V0LFxuICAgICAgICB9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgYW4gZXhpc3RpbmcgZmlsZSB0byBhIG5ldyBwYXRoIGluIHRoZSBzYW1lIGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtIGZyb21QYXRoIFRoZSBvcmlnaW5hbCBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICogQHBhcmFtIHRvUGF0aCBUaGUgbmV3IGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBuZXcgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLWNvcHkucG5nYC5cbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGRlc3RpbmF0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBhc3luYyBjb3B5KFxuICAgIGZyb21QYXRoOiBzdHJpbmcsXG4gICAgdG9QYXRoOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IERlc3RpbmF0aW9uT3B0aW9uc1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IHBhdGg6IHN0cmluZyB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9vYmplY3QvY29weWAsXG4gICAgICAgIHtcbiAgICAgICAgICBidWNrZXRJZDogdGhpcy5idWNrZXRJZCxcbiAgICAgICAgICBzb3VyY2VLZXk6IGZyb21QYXRoLFxuICAgICAgICAgIGRlc3RpbmF0aW9uS2V5OiB0b1BhdGgsXG4gICAgICAgICAgZGVzdGluYXRpb25CdWNrZXQ6IG9wdGlvbnM/LmRlc3RpbmF0aW9uQnVja2V0LFxuICAgICAgICB9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG4gICAgICByZXR1cm4geyBkYXRhOiB7IHBhdGg6IGRhdGEuS2V5IH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaWduZWQgVVJMLiBVc2UgYSBzaWduZWQgVVJMIHRvIHNoYXJlIGEgZmlsZSBmb3IgYSBmaXhlZCBhbW91bnQgb2YgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgKiBAcGFyYW0gZXhwaXJlc0luIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCB0aGUgc2lnbmVkIFVSTCBleHBpcmVzLiBGb3IgZXhhbXBsZSwgYDYwYCBmb3IgYSBVUkwgd2hpY2ggaXMgdmFsaWQgZm9yIG9uZSBtaW51dGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLmRvd25sb2FkIHRyaWdnZXJzIHRoZSBmaWxlIGFzIGEgZG93bmxvYWQgaWYgc2V0IHRvIHRydWUuIFNldCB0aGlzIHBhcmFtZXRlciBhcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBpZiB5b3Ugd2FudCB0byB0cmlnZ2VyIHRoZSBkb3dubG9hZCB3aXRoIGEgZGlmZmVyZW50IGZpbGVuYW1lLlxuICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlU2lnbmVkVXJsKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBleHBpcmVzSW46IG51bWJlcixcbiAgICBvcHRpb25zPzogeyBkb3dubG9hZD86IHN0cmluZyB8IGJvb2xlYW47IHRyYW5zZm9ybT86IFRyYW5zZm9ybU9wdGlvbnMgfVxuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IHNpZ25lZFVybDogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aClcblxuICAgICAgbGV0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vb2JqZWN0L3NpZ24vJHtfcGF0aH1gLFxuICAgICAgICB7IGV4cGlyZXNJbiwgLi4uKG9wdGlvbnM/LnRyYW5zZm9ybSA/IHsgdHJhbnNmb3JtOiBvcHRpb25zLnRyYW5zZm9ybSB9IDoge30pIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIGNvbnN0IGRvd25sb2FkUXVlcnlQYXJhbSA9IG9wdGlvbnM/LmRvd25sb2FkXG4gICAgICAgID8gYCZkb3dubG9hZD0ke29wdGlvbnMuZG93bmxvYWQgPT09IHRydWUgPyAnJyA6IG9wdGlvbnMuZG93bmxvYWR9YFxuICAgICAgICA6ICcnXG4gICAgICBjb25zdCBzaWduZWRVcmwgPSBlbmNvZGVVUkkoYCR7dGhpcy51cmx9JHtkYXRhLnNpZ25lZFVSTH0ke2Rvd25sb2FkUXVlcnlQYXJhbX1gKVxuICAgICAgZGF0YSA9IHsgc2lnbmVkVXJsIH1cbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbXVsdGlwbGUgc2lnbmVkIFVSTHMuIFVzZSBhIHNpZ25lZCBVUkwgdG8gc2hhcmUgYSBmaWxlIGZvciBhIGZpeGVkIGFtb3VudCBvZiB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aHMgVGhlIGZpbGUgcGF0aHMgdG8gYmUgZG93bmxvYWRlZCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZXMuIEZvciBleGFtcGxlIGBbJ2ZvbGRlci9pbWFnZS5wbmcnLCAnZm9sZGVyMi9pbWFnZTIucG5nJ11gLlxuICAgKiBAcGFyYW0gZXhwaXJlc0luIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCB0aGUgc2lnbmVkIFVSTHMgZXhwaXJlLiBGb3IgZXhhbXBsZSwgYDYwYCBmb3IgVVJMcyB3aGljaCBhcmUgdmFsaWQgZm9yIG9uZSBtaW51dGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLmRvd25sb2FkIHRyaWdnZXJzIHRoZSBmaWxlIGFzIGEgZG93bmxvYWQgaWYgc2V0IHRvIHRydWUuIFNldCB0aGlzIHBhcmFtZXRlciBhcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBpZiB5b3Ugd2FudCB0byB0cmlnZ2VyIHRoZSBkb3dubG9hZCB3aXRoIGEgZGlmZmVyZW50IGZpbGVuYW1lLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlU2lnbmVkVXJscyhcbiAgICBwYXRoczogc3RyaW5nW10sXG4gICAgZXhwaXJlc0luOiBudW1iZXIsXG4gICAgb3B0aW9ucz86IHsgZG93bmxvYWQ6IHN0cmluZyB8IGJvb2xlYW4gfVxuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IGVycm9yOiBzdHJpbmcgfCBudWxsOyBwYXRoOiBzdHJpbmcgfCBudWxsOyBzaWduZWRVcmw6IHN0cmluZyB9W11cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L29iamVjdC9zaWduLyR7dGhpcy5idWNrZXRJZH1gLFxuICAgICAgICB7IGV4cGlyZXNJbiwgcGF0aHMgfSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuXG4gICAgICBjb25zdCBkb3dubG9hZFF1ZXJ5UGFyYW0gPSBvcHRpb25zPy5kb3dubG9hZFxuICAgICAgICA/IGAmZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gJycgOiBvcHRpb25zLmRvd25sb2FkfWBcbiAgICAgICAgOiAnJ1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogZGF0YS5tYXAoKGRhdHVtOiB7IHNpZ25lZFVSTDogc3RyaW5nIH0pID0+ICh7XG4gICAgICAgICAgLi4uZGF0dW0sXG4gICAgICAgICAgc2lnbmVkVXJsOiBkYXR1bS5zaWduZWRVUkxcbiAgICAgICAgICAgID8gZW5jb2RlVVJJKGAke3RoaXMudXJsfSR7ZGF0dW0uc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApXG4gICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIH0pKSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEb3dubG9hZHMgYSBmaWxlIGZyb20gYSBwcml2YXRlIGJ1Y2tldC4gRm9yIHB1YmxpYyBidWNrZXRzLCBtYWtlIGEgcmVxdWVzdCB0byB0aGUgVVJMIHJldHVybmVkIGZyb20gYGdldFB1YmxpY1VybGAgaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggVGhlIGZ1bGwgcGF0aCBhbmQgZmlsZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGJlIGRvd25sb2FkZWQuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cbiAgICovXG4gIGFzeW5jIGRvd25sb2FkKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyB0cmFuc2Zvcm0/OiBUcmFuc2Zvcm1PcHRpb25zIH1cbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogQmxvYlxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgY29uc3Qgd2FudHNUcmFuc2Zvcm1hdGlvbiA9IHR5cGVvZiBvcHRpb25zPy50cmFuc2Zvcm0gIT09ICd1bmRlZmluZWQnXG4gICAgY29uc3QgcmVuZGVyUGF0aCA9IHdhbnRzVHJhbnNmb3JtYXRpb24gPyAncmVuZGVyL2ltYWdlL2F1dGhlbnRpY2F0ZWQnIDogJ29iamVjdCdcbiAgICBjb25zdCB0cmFuc2Zvcm1hdGlvblF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZyhvcHRpb25zPy50cmFuc2Zvcm0gfHwge30pXG4gICAgY29uc3QgcXVlcnlTdHJpbmcgPSB0cmFuc2Zvcm1hdGlvblF1ZXJ5ID8gYD8ke3RyYW5zZm9ybWF0aW9uUXVlcnl9YCA6ICcnXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aClcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vJHtyZW5kZXJQYXRofS8ke19wYXRofSR7cXVlcnlTdHJpbmd9YCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICB9KVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5ibG9iKClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbiBleGlzdGluZyBmaWxlLlxuICAgKiBAcGFyYW0gcGF0aFxuICAgKi9cbiAgYXN5bmMgaW5mbyhcbiAgICBwYXRoOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogQ2FtZWxpemU8RmlsZU9iamVjdFYyPlxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aClcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvaW5mby8ke19wYXRofWAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHsgZGF0YTogcmVjdXJzaXZlVG9DYW1lbChkYXRhKSBhcyBDYW1lbGl6ZTxGaWxlT2JqZWN0VjI+LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIGV4aXN0ZW5jZSBvZiBhIGZpbGUuXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqL1xuICBhc3luYyBleGlzdHMoXG4gICAgcGF0aDogc3RyaW5nXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IGJvb2xlYW5cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogYm9vbGVhblxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpXG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgaGVhZCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vb2JqZWN0LyR7X3BhdGh9YCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4geyBkYXRhOiB0cnVlLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikgJiYgZXJyb3IgaW5zdGFuY2VvZiBTdG9yYWdlVW5rbm93bkVycm9yKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRXJyb3IgPSAoZXJyb3Iub3JpZ2luYWxFcnJvciBhcyB1bmtub3duKSBhcyB7IHN0YXR1czogbnVtYmVyIH1cblxuICAgICAgICBpZiAoWzQwMCwgNDA0XS5pbmNsdWRlcyhvcmlnaW5hbEVycm9yPy5zdGF0dXMpKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogZmFsc2UsIGVycm9yIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNpbXBsZSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgdGhlIFVSTCBmb3IgYW4gYXNzZXQgaW4gYSBwdWJsaWMgYnVja2V0LiBJZiB5b3UgZG8gbm90IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24sIHlvdSBjYW4gY29uc3RydWN0IHRoZSBwdWJsaWMgVVJMIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGJ1Y2tldCBVUkwgd2l0aCB0aGUgcGF0aCB0byB0aGUgYXNzZXQuXG4gICAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgdmVyaWZ5IGlmIHRoZSBidWNrZXQgaXMgcHVibGljLiBJZiBhIHB1YmxpYyBVUkwgaXMgY3JlYXRlZCBmb3IgYSBidWNrZXQgd2hpY2ggaXMgbm90IHB1YmxpYywgeW91IHdpbGwgbm90IGJlIGFibGUgdG8gZG93bmxvYWQgdGhlIGFzc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBhbmQgbmFtZSBvZiB0aGUgZmlsZSB0byBnZW5lcmF0ZSB0aGUgcHVibGljIFVSTCBmb3IuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgVHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG4gICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG4gICAqL1xuICBnZXRQdWJsaWNVcmwoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IGRvd25sb2FkPzogc3RyaW5nIHwgYm9vbGVhbjsgdHJhbnNmb3JtPzogVHJhbnNmb3JtT3B0aW9ucyB9XG4gICk6IHsgZGF0YTogeyBwdWJsaWNVcmw6IHN0cmluZyB9IH0ge1xuICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpXG4gICAgY29uc3QgX3F1ZXJ5U3RyaW5nID0gW11cblxuICAgIGNvbnN0IGRvd25sb2FkUXVlcnlQYXJhbSA9IG9wdGlvbnM/LmRvd25sb2FkXG4gICAgICA/IGBkb3dubG9hZD0ke29wdGlvbnMuZG93bmxvYWQgPT09IHRydWUgPyAnJyA6IG9wdGlvbnMuZG93bmxvYWR9YFxuICAgICAgOiAnJ1xuXG4gICAgaWYgKGRvd25sb2FkUXVlcnlQYXJhbSAhPT0gJycpIHtcbiAgICAgIF9xdWVyeVN0cmluZy5wdXNoKGRvd25sb2FkUXVlcnlQYXJhbSlcbiAgICB9XG5cbiAgICBjb25zdCB3YW50c1RyYW5zZm9ybWF0aW9uID0gdHlwZW9mIG9wdGlvbnM/LnRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCdcbiAgICBjb25zdCByZW5kZXJQYXRoID0gd2FudHNUcmFuc2Zvcm1hdGlvbiA/ICdyZW5kZXIvaW1hZ2UnIDogJ29iamVjdCdcbiAgICBjb25zdCB0cmFuc2Zvcm1hdGlvblF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZyhvcHRpb25zPy50cmFuc2Zvcm0gfHwge30pXG5cbiAgICBpZiAodHJhbnNmb3JtYXRpb25RdWVyeSAhPT0gJycpIHtcbiAgICAgIF9xdWVyeVN0cmluZy5wdXNoKHRyYW5zZm9ybWF0aW9uUXVlcnkpXG4gICAgfVxuXG4gICAgbGV0IHF1ZXJ5U3RyaW5nID0gX3F1ZXJ5U3RyaW5nLmpvaW4oJyYnKVxuICAgIGlmIChxdWVyeVN0cmluZyAhPT0gJycpIHtcbiAgICAgIHF1ZXJ5U3RyaW5nID0gYD8ke3F1ZXJ5U3RyaW5nfWBcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogeyBwdWJsaWNVcmw6IGVuY29kZVVSSShgJHt0aGlzLnVybH0vJHtyZW5kZXJQYXRofS9wdWJsaWMvJHtfcGF0aH0ke3F1ZXJ5U3RyaW5nfWApIH0sXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgZmlsZXMgd2l0aGluIHRoZSBzYW1lIGJ1Y2tldFxuICAgKlxuICAgKiBAcGFyYW0gcGF0aHMgQW4gYXJyYXkgb2YgZmlsZXMgdG8gZGVsZXRlLCBpbmNsdWRpbmcgdGhlIHBhdGggYW5kIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgW2AnZm9sZGVyL2ltYWdlLnBuZydgXS5cbiAgICovXG4gIGFzeW5jIHJlbW92ZShcbiAgICBwYXRoczogc3RyaW5nW11cbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogRmlsZU9iamVjdFtdXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlbW92ZShcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L29iamVjdC8ke3RoaXMuYnVja2V0SWR9YCxcbiAgICAgICAgeyBwcmVmaXhlczogcGF0aHMgfSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGZpbGUgbWV0YWRhdGFcbiAgICogQHBhcmFtIGlkIHRoZSBmaWxlIGlkIHRvIHJldHJpZXZlIG1ldGFkYXRhXG4gICAqL1xuICAvLyBhc3luYyBnZXRNZXRhZGF0YShcbiAgLy8gICBpZDogc3RyaW5nXG4gIC8vICk6IFByb21pc2U8XG4gIC8vICAgfCB7XG4gIC8vICAgICAgIGRhdGE6IE1ldGFkYXRhXG4gIC8vICAgICAgIGVycm9yOiBudWxsXG4gIC8vICAgICB9XG4gIC8vICAgfCB7XG4gIC8vICAgICAgIGRhdGE6IG51bGxcbiAgLy8gICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAvLyAgICAgfVxuICAvLyA+IHtcbiAgLy8gICB0cnkge1xuICAvLyAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vbWV0YWRhdGEvJHtpZH1gLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KVxuICAvLyAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAvLyAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gIC8vICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gIC8vICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgLy8gICAgIH1cblxuICAvLyAgICAgdGhyb3cgZXJyb3JcbiAgLy8gICB9XG4gIC8vIH1cblxuICAvKipcbiAgICogVXBkYXRlIGZpbGUgbWV0YWRhdGFcbiAgICogQHBhcmFtIGlkIHRoZSBmaWxlIGlkIHRvIHVwZGF0ZSBtZXRhZGF0YVxuICAgKiBAcGFyYW0gbWV0YSB0aGUgbmV3IGZpbGUgbWV0YWRhdGFcbiAgICovXG4gIC8vIGFzeW5jIHVwZGF0ZU1ldGFkYXRhKFxuICAvLyAgIGlkOiBzdHJpbmcsXG4gIC8vICAgbWV0YTogTWV0YWRhdGFcbiAgLy8gKTogUHJvbWlzZTxcbiAgLy8gICB8IHtcbiAgLy8gICAgICAgZGF0YTogTWV0YWRhdGFcbiAgLy8gICAgICAgZXJyb3I6IG51bGxcbiAgLy8gICAgIH1cbiAgLy8gICB8IHtcbiAgLy8gICAgICAgZGF0YTogbnVsbFxuICAvLyAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gIC8vICAgICB9XG4gIC8vID4ge1xuICAvLyAgIHRyeSB7XG4gIC8vICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgLy8gICAgICAgdGhpcy5mZXRjaCxcbiAgLy8gICAgICAgYCR7dGhpcy51cmx9L21ldGFkYXRhLyR7aWR9YCxcbiAgLy8gICAgICAgeyAuLi5tZXRhIH0sXG4gIC8vICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgLy8gICAgIClcbiAgLy8gICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgLy8gICB9IGNhdGNoIChlcnJvcikge1xuICAvLyAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAvLyAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gIC8vICAgICB9XG5cbiAgLy8gICAgIHRocm93IGVycm9yXG4gIC8vICAgfVxuICAvLyB9XG5cbiAgLyoqXG4gICAqIExpc3RzIGFsbCB0aGUgZmlsZXMgd2l0aGluIGEgYnVja2V0LlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgZm9sZGVyIHBhdGguXG4gICAqL1xuICBhc3luYyBsaXN0KFxuICAgIHBhdGg/OiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IFNlYXJjaE9wdGlvbnMsXG4gICAgcGFyYW1ldGVycz86IEZldGNoUGFyYW1ldGVyc1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBGaWxlT2JqZWN0W11cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBib2R5ID0geyAuLi5ERUZBVUxUX1NFQVJDSF9PUFRJT05TLCAuLi5vcHRpb25zLCBwcmVmaXg6IHBhdGggfHwgJycgfVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9vYmplY3QvbGlzdC8ke3RoaXMuYnVja2V0SWR9YCxcbiAgICAgICAgYm9keSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSxcbiAgICAgICAgcGFyYW1ldGVyc1xuICAgICAgKVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZW5jb2RlTWV0YWRhdGEobWV0YWRhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpXG4gIH1cblxuICB0b0Jhc2U2NChkYXRhOiBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZygnYmFzZTY0JylcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EoZGF0YSlcbiAgfVxuXG4gIHByaXZhdGUgX2dldEZpbmFsUGF0aChwYXRoOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5idWNrZXRJZH0vJHtwYXRofWBcbiAgfVxuXG4gIHByaXZhdGUgX3JlbW92ZUVtcHR5Rm9sZGVycyhwYXRoOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9eXFwvfFxcLyQvZywgJycpLnJlcGxhY2UoL1xcLysvZywgJy8nKVxuICB9XG5cbiAgcHJpdmF0ZSB0cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZyh0cmFuc2Zvcm06IFRyYW5zZm9ybU9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBbXVxuICAgIGlmICh0cmFuc2Zvcm0ud2lkdGgpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGB3aWR0aD0ke3RyYW5zZm9ybS53aWR0aH1gKVxuICAgIH1cblxuICAgIGlmICh0cmFuc2Zvcm0uaGVpZ2h0KSB7XG4gICAgICBwYXJhbXMucHVzaChgaGVpZ2h0PSR7dHJhbnNmb3JtLmhlaWdodH1gKVxuICAgIH1cblxuICAgIGlmICh0cmFuc2Zvcm0ucmVzaXplKSB7XG4gICAgICBwYXJhbXMucHVzaChgcmVzaXplPSR7dHJhbnNmb3JtLnJlc2l6ZX1gKVxuICAgIH1cblxuICAgIGlmICh0cmFuc2Zvcm0uZm9ybWF0KSB7XG4gICAgICBwYXJhbXMucHVzaChgZm9ybWF0PSR7dHJhbnNmb3JtLmZvcm1hdH1gKVxuICAgIH1cblxuICAgIGlmICh0cmFuc2Zvcm0ucXVhbGl0eSkge1xuICAgICAgcGFyYW1zLnB1c2goYHF1YWxpdHk9JHt0cmFuc2Zvcm0ucXVhbGl0eX1gKVxuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXMuam9pbignJicpXG4gIH1cbn1cbiIsICIvLyBnZW5lcmF0ZWQgYnkgZ2VudmVyc2lvblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMi43LjEnXG4iLCAiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbidcbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYHN0b3JhZ2UtanMvJHt2ZXJzaW9ufWAgfVxuIiwgImltcG9ydCB7IERFRkFVTFRfSEVBREVSUyB9IGZyb20gJy4uL2xpYi9jb25zdGFudHMnXG5pbXBvcnQgeyBpc1N0b3JhZ2VFcnJvciwgU3RvcmFnZUVycm9yIH0gZnJvbSAnLi4vbGliL2Vycm9ycydcbmltcG9ydCB7IEZldGNoLCBnZXQsIHBvc3QsIHB1dCwgcmVtb3ZlIH0gZnJvbSAnLi4vbGliL2ZldGNoJ1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi4vbGliL2hlbHBlcnMnXG5pbXBvcnQgeyBCdWNrZXQgfSBmcm9tICcuLi9saWIvdHlwZXMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JhZ2VCdWNrZXRBcGkge1xuICBwcm90ZWN0ZWQgdXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgcHJvdGVjdGVkIGZldGNoOiBGZXRjaFxuXG4gIGNvbnN0cnVjdG9yKHVybDogc3RyaW5nLCBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge30sIGZldGNoPzogRmV0Y2gpIHtcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMuaGVhZGVycyA9IHsgLi4uREVGQVVMVF9IRUFERVJTLCAuLi5oZWFkZXJzIH1cbiAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbGwgU3RvcmFnZSBidWNrZXRzIHdpdGhpbiBhbiBleGlzdGluZyBwcm9qZWN0LlxuICAgKi9cbiAgYXN5bmMgbGlzdEJ1Y2tldHMoKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogQnVja2V0W11cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXRgLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFuIGV4aXN0aW5nIFN0b3JhZ2UgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gcmV0cmlldmUuXG4gICAqL1xuICBhc3luYyBnZXRCdWNrZXQoXG4gICAgaWQ6IHN0cmluZ1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBCdWNrZXRcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH1gLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTdG9yYWdlIGJ1Y2tldFxuICAgKlxuICAgKiBAcGFyYW0gaWQgQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIGNyZWF0aW5nLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5wdWJsaWMgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGJ1Y2tldC4gUHVibGljIGJ1Y2tldHMgZG9uJ3QgcmVxdWlyZSBhbiBhdXRob3JpemF0aW9uIHRva2VuIHRvIGRvd25sb2FkIG9iamVjdHMsIGJ1dCBzdGlsbCByZXF1aXJlIGEgdmFsaWQgdG9rZW4gZm9yIGFsbCBvdGhlciBvcGVyYXRpb25zLiBCeSBkZWZhdWx0LCBidWNrZXRzIGFyZSBwcml2YXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5maWxlU2l6ZUxpbWl0IHNwZWNpZmllcyB0aGUgbWF4IGZpbGUgc2l6ZSBpbiBieXRlcyB0aGF0IGNhbiBiZSB1cGxvYWRlZCB0byB0aGlzIGJ1Y2tldC5cbiAgICogVGhlIGdsb2JhbCBmaWxlIHNpemUgbGltaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgdmFsdWUuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGRvZXNuJ3Qgc2V0IGEgcGVyIGJ1Y2tldCBmaWxlIHNpemUgbGltaXQuXG4gICAqIEBwYXJhbSBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXMgc3BlY2lmaWVzIHRoZSBhbGxvd2VkIG1pbWUgdHlwZXMgdGhhdCB0aGlzIGJ1Y2tldCBjYW4gYWNjZXB0IGR1cmluZyB1cGxvYWQuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGFsbG93cyBmaWxlcyB3aXRoIGFsbCBtaW1lIHR5cGVzIHRvIGJlIHVwbG9hZGVkLlxuICAgKiBFYWNoIG1pbWUgdHlwZSBzcGVjaWZpZWQgY2FuIGJlIGEgd2lsZGNhcmQsIGUuZy4gaW1hZ2UvKiwgb3IgYSBzcGVjaWZpYyBtaW1lIHR5cGUsIGUuZy4gaW1hZ2UvcG5nLlxuICAgKiBAcmV0dXJucyBuZXdseSBjcmVhdGVkIGJ1Y2tldCBpZFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQnVja2V0KFxuICAgIGlkOiBzdHJpbmcsXG4gICAgb3B0aW9uczoge1xuICAgICAgcHVibGljOiBib29sZWFuXG4gICAgICBmaWxlU2l6ZUxpbWl0PzogbnVtYmVyIHwgc3RyaW5nIHwgbnVsbFxuICAgICAgYWxsb3dlZE1pbWVUeXBlcz86IHN0cmluZ1tdIHwgbnVsbFxuICAgIH0gPSB7XG4gICAgICBwdWJsaWM6IGZhbHNlLFxuICAgIH1cbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogUGljazxCdWNrZXQsICduYW1lJz5cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L2J1Y2tldGAsXG4gICAgICAgIHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBuYW1lOiBpZCxcbiAgICAgICAgICBwdWJsaWM6IG9wdGlvbnMucHVibGljLFxuICAgICAgICAgIGZpbGVfc2l6ZV9saW1pdDogb3B0aW9ucy5maWxlU2l6ZUxpbWl0LFxuICAgICAgICAgIGFsbG93ZWRfbWltZV90eXBlczogb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzLFxuICAgICAgICB9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgU3RvcmFnZSBidWNrZXRcbiAgICpcbiAgICogQHBhcmFtIGlkIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBidWNrZXQgeW91IGFyZSB1cGRhdGluZy5cbiAgICogQHBhcmFtIG9wdGlvbnMucHVibGljIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidWNrZXQuIFB1YmxpYyBidWNrZXRzIGRvbid0IHJlcXVpcmUgYW4gYXV0aG9yaXphdGlvbiB0b2tlbiB0byBkb3dubG9hZCBvYmplY3RzLCBidXQgc3RpbGwgcmVxdWlyZSBhIHZhbGlkIHRva2VuIGZvciBhbGwgb3RoZXIgb3BlcmF0aW9ucy5cbiAgICogQHBhcmFtIG9wdGlvbnMuZmlsZVNpemVMaW1pdCBzcGVjaWZpZXMgdGhlIG1heCBmaWxlIHNpemUgaW4gYnl0ZXMgdGhhdCBjYW4gYmUgdXBsb2FkZWQgdG8gdGhpcyBidWNrZXQuXG4gICAqIFRoZSBnbG9iYWwgZmlsZSBzaXplIGxpbWl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHZhbHVlLlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBkb2Vzbid0IHNldCBhIHBlciBidWNrZXQgZmlsZSBzaXplIGxpbWl0LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzIHNwZWNpZmllcyB0aGUgYWxsb3dlZCBtaW1lIHR5cGVzIHRoYXQgdGhpcyBidWNrZXQgY2FuIGFjY2VwdCBkdXJpbmcgdXBsb2FkLlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBhbGxvd3MgZmlsZXMgd2l0aCBhbGwgbWltZSB0eXBlcyB0byBiZSB1cGxvYWRlZC5cbiAgICogRWFjaCBtaW1lIHR5cGUgc3BlY2lmaWVkIGNhbiBiZSBhIHdpbGRjYXJkLCBlLmcuIGltYWdlLyosIG9yIGEgc3BlY2lmaWMgbWltZSB0eXBlLCBlLmcuIGltYWdlL3BuZy5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZUJ1Y2tldChcbiAgICBpZDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHB1YmxpYzogYm9vbGVhblxuICAgICAgZmlsZVNpemVMaW1pdD86IG51bWJlciB8IHN0cmluZyB8IG51bGxcbiAgICAgIGFsbG93ZWRNaW1lVHlwZXM/OiBzdHJpbmdbXSB8IG51bGxcbiAgICB9XG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgbWVzc2FnZTogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcHV0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9YCxcbiAgICAgICAge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIG5hbWU6IGlkLFxuICAgICAgICAgIHB1YmxpYzogb3B0aW9ucy5wdWJsaWMsXG4gICAgICAgICAgZmlsZV9zaXplX2xpbWl0OiBvcHRpb25zLmZpbGVTaXplTGltaXQsXG4gICAgICAgICAgYWxsb3dlZF9taW1lX3R5cGVzOiBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXMsXG4gICAgICAgIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIG9iamVjdHMgaW5zaWRlIGEgc2luZ2xlIGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGVtcHR5LlxuICAgKi9cbiAgYXN5bmMgZW1wdHlCdWNrZXQoXG4gICAgaWQ6IHN0cmluZ1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IG1lc3NhZ2U6IHN0cmluZyB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH0vZW1wdHlgLFxuICAgICAgICB7fSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBleGlzdGluZyBidWNrZXQuIEEgYnVja2V0IGNhbid0IGJlIGRlbGV0ZWQgd2l0aCBleGlzdGluZyBvYmplY3RzIGluc2lkZSBpdC5cbiAgICogWW91IG11c3QgZmlyc3QgYGVtcHR5KClgIHRoZSBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byBkZWxldGUuXG4gICAqL1xuICBhc3luYyBkZWxldGVCdWNrZXQoXG4gICAgaWQ6IHN0cmluZ1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IG1lc3NhZ2U6IHN0cmluZyB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlbW92ZShcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L2J1Y2tldC8ke2lkfWAsXG4gICAgICAgIHt9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCBTdG9yYWdlRmlsZUFwaSBmcm9tICcuL3BhY2thZ2VzL1N0b3JhZ2VGaWxlQXBpJ1xuaW1wb3J0IFN0b3JhZ2VCdWNrZXRBcGkgZnJvbSAnLi9wYWNrYWdlcy9TdG9yYWdlQnVja2V0QXBpJ1xuaW1wb3J0IHsgRmV0Y2ggfSBmcm9tICcuL2xpYi9mZXRjaCdcblxuZXhwb3J0IGNsYXNzIFN0b3JhZ2VDbGllbnQgZXh0ZW5kcyBTdG9yYWdlQnVja2V0QXBpIHtcbiAgY29uc3RydWN0b3IodXJsOiBzdHJpbmcsIGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fSwgZmV0Y2g/OiBGZXRjaCkge1xuICAgIHN1cGVyKHVybCwgaGVhZGVycywgZmV0Y2gpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBmaWxlIG9wZXJhdGlvbiBpbiBhIGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtIGlkIFRoZSBidWNrZXQgaWQgdG8gb3BlcmF0ZSBvbi5cbiAgICovXG4gIGZyb20oaWQ6IHN0cmluZyk6IFN0b3JhZ2VGaWxlQXBpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VGaWxlQXBpKHRoaXMudXJsLCB0aGlzLmhlYWRlcnMsIGlkLCB0aGlzLmZldGNoKVxuICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMi40Ny4xNidcbiIsICIvLyBjb25zdGFudHMudHNcbmltcG9ydCB7IFJlYWx0aW1lQ2xpZW50T3B0aW9ucyB9IGZyb20gJ0BzdXBhYmFzZS9yZWFsdGltZS1qcydcbmltcG9ydCB7IFN1cGFiYXNlQXV0aENsaWVudE9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbidcblxubGV0IEpTX0VOViA9ICcnXG4vLyBAdHMtaWdub3JlXG5pZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnKSB7XG4gIEpTX0VOViA9ICdkZW5vJ1xufSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gIEpTX0VOViA9ICd3ZWInXG59IGVsc2UgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gIEpTX0VOViA9ICdyZWFjdC1uYXRpdmUnXG59IGVsc2Uge1xuICBKU19FTlYgPSAnbm9kZSdcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfSEVBREVSUyA9IHsgJ1gtQ2xpZW50LUluZm8nOiBgc3VwYWJhc2UtanMtJHtKU19FTlZ9LyR7dmVyc2lvbn1gIH1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfR0xPQkFMX09QVElPTlMgPSB7XG4gIGhlYWRlcnM6IERFRkFVTFRfSEVBREVSUyxcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfREJfT1BUSU9OUyA9IHtcbiAgc2NoZW1hOiAncHVibGljJyxcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfQVVUSF9PUFRJT05TOiBTdXBhYmFzZUF1dGhDbGllbnRPcHRpb25zID0ge1xuICBhdXRvUmVmcmVzaFRva2VuOiB0cnVlLFxuICBwZXJzaXN0U2Vzc2lvbjogdHJ1ZSxcbiAgZGV0ZWN0U2Vzc2lvbkluVXJsOiB0cnVlLFxuICBmbG93VHlwZTogJ2ltcGxpY2l0Jyxcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUzogUmVhbHRpbWVDbGllbnRPcHRpb25zID0ge31cbiIsICIvLyBAdHMtaWdub3JlXG5pbXBvcnQgbm9kZUZldGNoLCB7IEhlYWRlcnMgYXMgTm9kZUZldGNoSGVhZGVycyB9IGZyb20gJ0BzdXBhYmFzZS9ub2RlLWZldGNoJ1xuXG50eXBlIEZldGNoID0gdHlwZW9mIGZldGNoXG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2g/OiBGZXRjaCk6IEZldGNoID0+IHtcbiAgbGV0IF9mZXRjaDogRmV0Y2hcbiAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgX2ZldGNoID0gY3VzdG9tRmV0Y2hcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgX2ZldGNoID0gbm9kZUZldGNoIGFzIHVua25vd24gYXMgRmV0Y2hcbiAgfSBlbHNlIHtcbiAgICBfZmV0Y2ggPSBmZXRjaFxuICB9XG4gIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxGZXRjaD4pID0+IF9mZXRjaCguLi5hcmdzKVxufVxuXG5leHBvcnQgY29uc3QgcmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvciA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiBIZWFkZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBOb2RlRmV0Y2hIZWFkZXJzXG4gIH1cblxuICByZXR1cm4gSGVhZGVyc1xufVxuXG5leHBvcnQgY29uc3QgZmV0Y2hXaXRoQXV0aCA9IChcbiAgc3VwYWJhc2VLZXk6IHN0cmluZyxcbiAgZ2V0QWNjZXNzVG9rZW46ICgpID0+IFByb21pc2U8c3RyaW5nIHwgbnVsbD4sXG4gIGN1c3RvbUZldGNoPzogRmV0Y2hcbik6IEZldGNoID0+IHtcbiAgY29uc3QgZmV0Y2ggPSByZXNvbHZlRmV0Y2goY3VzdG9tRmV0Y2gpXG4gIGNvbnN0IEhlYWRlcnNDb25zdHJ1Y3RvciA9IHJlc29sdmVIZWFkZXJzQ29uc3RydWN0b3IoKVxuXG4gIHJldHVybiBhc3luYyAoaW5wdXQsIGluaXQpID0+IHtcbiAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IChhd2FpdCBnZXRBY2Nlc3NUb2tlbigpKSA/PyBzdXBhYmFzZUtleVxuICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnNDb25zdHJ1Y3Rvcihpbml0Py5oZWFkZXJzKVxuXG4gICAgaWYgKCFoZWFkZXJzLmhhcygnYXBpa2V5JykpIHtcbiAgICAgIGhlYWRlcnMuc2V0KCdhcGlrZXknLCBzdXBhYmFzZUtleSlcbiAgICB9XG5cbiAgICBpZiAoIWhlYWRlcnMuaGFzKCdBdXRob3JpemF0aW9uJykpIHtcbiAgICAgIGhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgYEJlYXJlciAke2FjY2Vzc1Rva2VufWApXG4gICAgfVxuXG4gICAgcmV0dXJuIGZldGNoKGlucHV0LCB7IC4uLmluaXQsIGhlYWRlcnMgfSlcbiAgfVxufVxuIiwgIi8vIGhlbHBlcnMudHNcbmltcG9ydCB7IFN1cGFiYXNlQ2xpZW50T3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCBmdW5jdGlvbiB1dWlkKCkge1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHZhciByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLFxuICAgICAgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4OFxuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBUcmFpbGluZ1NsYXNoKHVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXC8kLywgJycpXG59XG5cbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTZXR0aW5nRGVmYXVsdHM8XG4gIERhdGFiYXNlID0gYW55LFxuICBTY2hlbWFOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgRGF0YWJhc2UgPSAncHVibGljJyBleHRlbmRzIGtleW9mIERhdGFiYXNlXG4gICAgPyAncHVibGljJ1xuICAgIDogc3RyaW5nICYga2V5b2YgRGF0YWJhc2Vcbj4oXG4gIG9wdGlvbnM6IFN1cGFiYXNlQ2xpZW50T3B0aW9uczxTY2hlbWFOYW1lPixcbiAgZGVmYXVsdHM6IFN1cGFiYXNlQ2xpZW50T3B0aW9uczxhbnk+XG4pOiBSZXF1aXJlZDxTdXBhYmFzZUNsaWVudE9wdGlvbnM8U2NoZW1hTmFtZT4+IHtcbiAgY29uc3Qge1xuICAgIGRiOiBkYk9wdGlvbnMsXG4gICAgYXV0aDogYXV0aE9wdGlvbnMsXG4gICAgcmVhbHRpbWU6IHJlYWx0aW1lT3B0aW9ucyxcbiAgICBnbG9iYWw6IGdsb2JhbE9wdGlvbnMsXG4gIH0gPSBvcHRpb25zXG4gIGNvbnN0IHtcbiAgICBkYjogREVGQVVMVF9EQl9PUFRJT05TLFxuICAgIGF1dGg6IERFRkFVTFRfQVVUSF9PUFRJT05TLFxuICAgIHJlYWx0aW1lOiBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsXG4gICAgZ2xvYmFsOiBERUZBVUxUX0dMT0JBTF9PUFRJT05TLFxuICB9ID0gZGVmYXVsdHNcblxuICBjb25zdCByZXN1bHQ6IFJlcXVpcmVkPFN1cGFiYXNlQ2xpZW50T3B0aW9uczxTY2hlbWFOYW1lPj4gPSB7XG4gICAgZGI6IHtcbiAgICAgIC4uLkRFRkFVTFRfREJfT1BUSU9OUyxcbiAgICAgIC4uLmRiT3B0aW9ucyxcbiAgICB9LFxuICAgIGF1dGg6IHtcbiAgICAgIC4uLkRFRkFVTFRfQVVUSF9PUFRJT05TLFxuICAgICAgLi4uYXV0aE9wdGlvbnMsXG4gICAgfSxcbiAgICByZWFsdGltZToge1xuICAgICAgLi4uREVGQVVMVF9SRUFMVElNRV9PUFRJT05TLFxuICAgICAgLi4ucmVhbHRpbWVPcHRpb25zLFxuICAgIH0sXG4gICAgZ2xvYmFsOiB7XG4gICAgICAuLi5ERUZBVUxUX0dMT0JBTF9PUFRJT05TLFxuICAgICAgLi4uZ2xvYmFsT3B0aW9ucyxcbiAgICB9LFxuICAgIGFjY2Vzc1Rva2VuOiBhc3luYyAoKSA9PiAnJyxcbiAgfVxuXG4gIGlmIChvcHRpb25zLmFjY2Vzc1Rva2VuKSB7XG4gICAgcmVzdWx0LmFjY2Vzc1Rva2VuID0gb3B0aW9ucy5hY2Nlc3NUb2tlblxuICB9IGVsc2Uge1xuICAgIC8vIGhhY2sgYXJvdW5kIFJlcXVpcmVkPD5cbiAgICBkZWxldGUgKHJlc3VsdCBhcyBhbnkpLmFjY2Vzc1Rva2VuXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG4iLCAiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMi42Ny4zJ1xuIiwgImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nXG5leHBvcnQgY29uc3QgR09UUlVFX1VSTCA9ICdodHRwOi8vbG9jYWxob3N0Ojk5OTknXG5leHBvcnQgY29uc3QgU1RPUkFHRV9LRVkgPSAnc3VwYWJhc2UuYXV0aC50b2tlbidcbmV4cG9ydCBjb25zdCBBVURJRU5DRSA9ICcnXG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBnb3RydWUtanMvJHt2ZXJzaW9ufWAgfVxuZXhwb3J0IGNvbnN0IEVYUElSWV9NQVJHSU4gPSAxMCAvLyBpbiBzZWNvbmRzXG5leHBvcnQgY29uc3QgTkVUV09SS19GQUlMVVJFID0ge1xuICBNQVhfUkVUUklFUzogMTAsXG4gIFJFVFJZX0lOVEVSVkFMOiAyLCAvLyBpbiBkZWNpc2Vjb25kc1xufVxuXG5leHBvcnQgY29uc3QgQVBJX1ZFUlNJT05fSEVBREVSX05BTUUgPSAnWC1TdXBhYmFzZS1BcGktVmVyc2lvbidcbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTlMgPSB7XG4gICcyMDI0LTAxLTAxJzoge1xuICAgIHRpbWVzdGFtcDogRGF0ZS5wYXJzZSgnMjAyNC0wMS0wMVQwMDowMDowMC4wWicpLFxuICAgIG5hbWU6ICcyMDI0LTAxLTAxJyxcbiAgfSxcbn1cbiIsICJpbXBvcnQgeyBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSB9IGZyb20gJy4vY29uc3RhbnRzJ1xuaW1wb3J0IHsgU3VwcG9ydGVkU3RvcmFnZSB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCBmdW5jdGlvbiBleHBpcmVzQXQoZXhwaXJlc0luOiBudW1iZXIpIHtcbiAgY29uc3QgdGltZU5vdyA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApXG4gIHJldHVybiB0aW1lTm93ICsgZXhwaXJlc0luXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1dWlkKCkge1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsXG4gICAgICB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpXG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmNvbnN0IGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMgPSB7XG4gIHRlc3RlZDogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBsb2NhbFN0b3JhZ2UgaXMgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzTG9jYWxTdG9yYWdlID0gKCkgPT4ge1xuICBpZiAoIWlzQnJvd3NlcigpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB0cnkge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBET00gZXhjZXB0aW9uIHdoZW4gYWNjZXNzaW5nIGBsb2NhbFN0b3JhZ2VgXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAobG9jYWxTdG9yYWdlV3JpdGVUZXN0cy50ZXN0ZWQpIHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZVxuICB9XG5cbiAgY29uc3QgcmFuZG9tS2V5ID0gYGxzd3QtJHtNYXRoLnJhbmRvbSgpfSR7TWF0aC5yYW5kb20oKX1gXG5cbiAgdHJ5IHtcbiAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHJhbmRvbUtleSwgcmFuZG9tS2V5KVxuICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0ocmFuZG9tS2V5KVxuXG4gICAgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy50ZXN0ZWQgPSB0cnVlXG4gICAgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZSA9IHRydWVcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGxvY2FsU3RvcmFnZSBjYW4ndCBiZSB3cml0dGVuIHRvXG4gICAgLy8gaHR0cHM6Ly93d3cuY2hyb21pdW0ub3JnL2Zvci10ZXN0ZXJzL2J1Zy1yZXBvcnRpbmctZ3VpZGVsaW5lcy91bmNhdWdodC1zZWN1cml0eWVycm9yLWZhaWxlZC10by1yZWFkLXRoZS1sb2NhbHN0b3JhZ2UtcHJvcGVydHktZnJvbS13aW5kb3ctYWNjZXNzLWlzLWRlbmllZC1mb3ItdGhpcy1kb2N1bWVudFxuXG4gICAgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy50ZXN0ZWQgPSB0cnVlXG4gICAgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZSA9IGZhbHNlXG4gIH1cblxuICByZXR1cm4gbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZVxufVxuXG4vKipcbiAqIEV4dHJhY3RzIHBhcmFtZXRlcnMgZW5jb2RlZCBpbiB0aGUgVVJMIGJvdGggaW4gdGhlIHF1ZXJ5IGFuZCBmcmFnbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwoaHJlZjogc3RyaW5nKSB7XG4gIGNvbnN0IHJlc3VsdDogeyBbcGFyYW1ldGVyOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9XG5cbiAgY29uc3QgdXJsID0gbmV3IFVSTChocmVmKVxuXG4gIGlmICh1cmwuaGFzaCAmJiB1cmwuaGFzaFswXSA9PT0gJyMnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhhc2hTZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5oYXNoLnN1YnN0cmluZygxKSlcbiAgICAgIGhhc2hTZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgLy8gaGFzaCBpcyBub3QgYSBxdWVyeSBzdHJpbmdcbiAgICB9XG4gIH1cblxuICAvLyBzZWFyY2ggcGFyYW1ldGVycyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBoYXNoIHBhcmFtZXRlcnNcbiAgdXJsLnNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZVxuICB9KVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxudHlwZSBGZXRjaCA9IHR5cGVvZiBmZXRjaFxuXG5leHBvcnQgY29uc3QgcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoPzogRmV0Y2gpOiBGZXRjaCA9PiB7XG4gIGxldCBfZmV0Y2g6IEZldGNoXG4gIGlmIChjdXN0b21GZXRjaCkge1xuICAgIF9mZXRjaCA9IGN1c3RvbUZldGNoXG4gIH0gZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgIF9mZXRjaCA9ICguLi5hcmdzKSA9PlxuICAgICAgaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcgYXMgYW55KS50aGVuKCh7IGRlZmF1bHQ6IGZldGNoIH0pID0+IGZldGNoKC4uLmFyZ3MpKVxuICB9IGVsc2Uge1xuICAgIF9mZXRjaCA9IGZldGNoXG4gIH1cbiAgcmV0dXJuICguLi5hcmdzKSA9PiBfZmV0Y2goLi4uYXJncylcbn1cblxuZXhwb3J0IGNvbnN0IGxvb2tzTGlrZUZldGNoUmVzcG9uc2UgPSAobWF5YmVSZXNwb25zZTogdW5rbm93bik6IG1heWJlUmVzcG9uc2UgaXMgUmVzcG9uc2UgPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBtYXliZVJlc3BvbnNlID09PSAnb2JqZWN0JyAmJlxuICAgIG1heWJlUmVzcG9uc2UgIT09IG51bGwgJiZcbiAgICAnc3RhdHVzJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgJ29rJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgJ2pzb24nIGluIG1heWJlUmVzcG9uc2UgJiZcbiAgICB0eXBlb2YgKG1heWJlUmVzcG9uc2UgYXMgYW55KS5qc29uID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuLy8gU3RvcmFnZSBoZWxwZXJzXG5leHBvcnQgY29uc3Qgc2V0SXRlbUFzeW5jID0gYXN5bmMgKFxuICBzdG9yYWdlOiBTdXBwb3J0ZWRTdG9yYWdlLFxuICBrZXk6IHN0cmluZyxcbiAgZGF0YTogYW55XG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgYXdhaXQgc3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpXG59XG5cbmV4cG9ydCBjb25zdCBnZXRJdGVtQXN5bmMgPSBhc3luYyAoc3RvcmFnZTogU3VwcG9ydGVkU3RvcmFnZSwga2V5OiBzdHJpbmcpOiBQcm9taXNlPHVua25vd24+ID0+IHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBzdG9yYWdlLmdldEl0ZW0oa2V5KVxuXG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSlcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlbW92ZUl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlOiBTdXBwb3J0ZWRTdG9yYWdlLCBrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBhd2FpdCBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQmFzZTY0VVJMKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBrZXkgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXG4gIGxldCBiYXNlNjQgPSAnJ1xuICBsZXQgY2hyMSwgY2hyMiwgY2hyM1xuICBsZXQgZW5jMSwgZW5jMiwgZW5jMywgZW5jNFxuICBsZXQgaSA9IDBcbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCctJywgJysnKS5yZXBsYWNlKCdfJywgJy8nKVxuXG4gIHdoaWxlIChpIDwgdmFsdWUubGVuZ3RoKSB7XG4gICAgZW5jMSA9IGtleS5pbmRleE9mKHZhbHVlLmNoYXJBdChpKyspKVxuICAgIGVuYzIgPSBrZXkuaW5kZXhPZih2YWx1ZS5jaGFyQXQoaSsrKSlcbiAgICBlbmMzID0ga2V5LmluZGV4T2YodmFsdWUuY2hhckF0KGkrKykpXG4gICAgZW5jNCA9IGtleS5pbmRleE9mKHZhbHVlLmNoYXJBdChpKyspKVxuICAgIGNocjEgPSAoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpXG4gICAgY2hyMiA9ICgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpXG4gICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNFxuICAgIGJhc2U2NCA9IGJhc2U2NCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMSlcblxuICAgIGlmIChlbmMzICE9IDY0ICYmIGNocjIgIT0gMCkge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIyKVxuICAgIH1cbiAgICBpZiAoZW5jNCAhPSA2NCAmJiBjaHIzICE9IDApIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2U2NFxufVxuXG4vKipcbiAqIEEgZGVmZXJyZWQgcmVwcmVzZW50cyBzb21lIGFzeW5jaHJvbm91cyB3b3JrIHRoYXQgaXMgbm90IHlldCBmaW5pc2hlZCwgd2hpY2hcbiAqIG1heSBvciBtYXkgbm90IGN1bG1pbmF0ZSBpbiBhIHZhbHVlLlxuICogVGFrZW4gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL21pa2Utbm9ydGgvdHlwZXMvYmxvYi9tYXN0ZXIvc3JjL2FzeW5jLnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZlcnJlZDxUID0gYW55PiB7XG4gIHB1YmxpYyBzdGF0aWMgcHJvbWlzZUNvbnN0cnVjdG9yOiBQcm9taXNlQ29uc3RydWN0b3IgPSBQcm9taXNlXG5cbiAgcHVibGljIHJlYWRvbmx5IHByb21pc2UhOiBQcm9taXNlTGlrZTxUPlxuXG4gIHB1YmxpYyByZWFkb25seSByZXNvbHZlITogKHZhbHVlPzogVCB8IFByb21pc2VMaWtlPFQ+KSA9PiB2b2lkXG5cbiAgcHVibGljIHJlYWRvbmx5IHJlamVjdCE6IChyZWFzb24/OiBhbnkpID0+IGFueVxuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICA7KHRoaXMgYXMgYW55KS5wcm9taXNlID0gbmV3IERlZmVycmVkLnByb21pc2VDb25zdHJ1Y3RvcigocmVzLCByZWopID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgICAgOyh0aGlzIGFzIGFueSkucmVzb2x2ZSA9IHJlc1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gICAgICA7KHRoaXMgYXMgYW55KS5yZWplY3QgPSByZWpcbiAgICB9KVxuICB9XG59XG5cbi8vIFRha2VuIGZyb206IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM4NTUyMDAzL2hvdy10by1kZWNvZGUtand0LXRva2VuLWluLWphdmFzY3JpcHQtd2l0aG91dC11c2luZy1hLWxpYnJhcnlcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVKV1RQYXlsb2FkKHRva2VuOiBzdHJpbmcpIHtcbiAgLy8gUmVnZXggY2hlY2tzIGZvciBiYXNlNjR1cmwgZm9ybWF0XG4gIGNvbnN0IGJhc2U2NFVybFJlZ2V4ID0gL14oW2EtejAtOV8tXXs0fSkqKCR8W2EtejAtOV8tXXszfT0/JHxbYS16MC05Xy1dezJ9KD09KT8kKSQvaVxuXG4gIGNvbnN0IHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKVxuXG4gIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVCBpcyBub3QgdmFsaWQ6IG5vdCBhIEpXVCBzdHJ1Y3R1cmUnKVxuICB9XG5cbiAgaWYgKCFiYXNlNjRVcmxSZWdleC50ZXN0KHBhcnRzWzFdKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSldUIGlzIG5vdCB2YWxpZDogcGF5bG9hZCBpcyBub3QgaW4gYmFzZTY0dXJsIGZvcm1hdCcpXG4gIH1cblxuICBjb25zdCBiYXNlNjRVcmwgPSBwYXJ0c1sxXVxuICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVCYXNlNjRVUkwoYmFzZTY0VXJsKSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIG51bGwgYWZ0ZXIgc29tZSB0aW1lLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2xlZXAodGltZTogbnVtYmVyKTogUHJvbWlzZTxudWxsPiB7XG4gIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgoYWNjZXB0KSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiBhY2NlcHQobnVsbCksIHRpbWUpXG4gIH0pXG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHByb3ZpZGVkIGFzeW5jIGZ1bmN0aW9uIGludG8gYSByZXRyeWFibGUgZnVuY3Rpb24uIEVhY2ggcmVzdWx0XG4gKiBvciB0aHJvd24gZXJyb3IgaXMgc2VudCB0byB0aGUgaXNSZXRyeWFibGUgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIHJldHVybiB0cnVlXG4gKiBpZiB0aGUgZnVuY3Rpb24gc2hvdWxkIHJ1biBhZ2Fpbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldHJ5YWJsZTxUPihcbiAgZm46IChhdHRlbXB0OiBudW1iZXIpID0+IFByb21pc2U8VD4sXG4gIGlzUmV0cnlhYmxlOiAoYXR0ZW1wdDogbnVtYmVyLCBlcnJvcjogYW55IHwgbnVsbCwgcmVzdWx0PzogVCkgPT4gYm9vbGVhblxuKTogUHJvbWlzZTxUPiB7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxUPigoYWNjZXB0LCByZWplY3QpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICA7KGFzeW5jICgpID0+IHtcbiAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgSW5maW5pdHk7IGF0dGVtcHQrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKGF0dGVtcHQpXG5cbiAgICAgICAgICBpZiAoIWlzUmV0cnlhYmxlKGF0dGVtcHQsIG51bGwsIHJlc3VsdCkpIHtcbiAgICAgICAgICAgIGFjY2VwdChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgIGlmICghaXNSZXRyeWFibGUoYXR0ZW1wdCwgZSkpIHtcbiAgICAgICAgICAgIHJlamVjdChlKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkoKVxuICB9KVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIGRlYzJoZXgoZGVjOiBudW1iZXIpIHtcbiAgcmV0dXJuICgnMCcgKyBkZWMudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTIpXG59XG5cbi8vIEZ1bmN0aW9ucyBiZWxvdyB0YWtlbiBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MzMwOTQwOS9jcmVhdGluZy1hLWNvZGUtdmVyaWZpZXItYW5kLWNoYWxsZW5nZS1mb3ItcGtjZS1hdXRoLW9uLXNwb3RpZnktYXBpLWluLXJlYWN0anNcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVBLQ0VWZXJpZmllcigpIHtcbiAgY29uc3QgdmVyaWZpZXJMZW5ndGggPSA1NlxuICBjb25zdCBhcnJheSA9IG5ldyBVaW50MzJBcnJheSh2ZXJpZmllckxlbmd0aClcbiAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgY2hhclNldCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS0uX34nXG4gICAgY29uc3QgY2hhclNldExlbiA9IGNoYXJTZXQubGVuZ3RoXG4gICAgbGV0IHZlcmlmaWVyID0gJydcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcmlmaWVyTGVuZ3RoOyBpKyspIHtcbiAgICAgIHZlcmlmaWVyICs9IGNoYXJTZXQuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJTZXRMZW4pKVxuICAgIH1cbiAgICByZXR1cm4gdmVyaWZpZXJcbiAgfVxuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KVxuICByZXR1cm4gQXJyYXkuZnJvbShhcnJheSwgZGVjMmhleCkuam9pbignJylcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2hhMjU2KHJhbmRvbVN0cmluZzogc3RyaW5nKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuICBjb25zdCBlbmNvZGVkRGF0YSA9IGVuY29kZXIuZW5jb2RlKHJhbmRvbVN0cmluZylcbiAgY29uc3QgaGFzaCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgZW5jb2RlZERhdGEpXG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaGFzaClcblxuICByZXR1cm4gQXJyYXkuZnJvbShieXRlcylcbiAgICAubWFwKChjKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKVxuICAgIC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBiYXNlNjR1cmxlbmNvZGUoc3RyOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGJ0b2Eoc3RyKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC89KyQvLCAnJylcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlUEtDRUNoYWxsZW5nZSh2ZXJpZmllcjogc3RyaW5nKSB7XG4gIGNvbnN0IGhhc0NyeXB0b1N1cHBvcnQgPVxuICAgIHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNyeXB0by5zdWJ0bGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIFRleHRFbmNvZGVyICE9PSAndW5kZWZpbmVkJ1xuXG4gIGlmICghaGFzQ3J5cHRvU3VwcG9ydCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdXZWJDcnlwdG8gQVBJIGlzIG5vdCBzdXBwb3J0ZWQuIENvZGUgY2hhbGxlbmdlIG1ldGhvZCB3aWxsIGRlZmF1bHQgdG8gdXNlIHBsYWluIGluc3RlYWQgb2Ygc2hhMjU2LidcbiAgICApXG4gICAgcmV0dXJuIHZlcmlmaWVyXG4gIH1cbiAgY29uc3QgaGFzaGVkID0gYXdhaXQgc2hhMjU2KHZlcmlmaWVyKVxuICByZXR1cm4gYmFzZTY0dXJsZW5jb2RlKGhhc2hlZClcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QoXG4gIHN0b3JhZ2U6IFN1cHBvcnRlZFN0b3JhZ2UsXG4gIHN0b3JhZ2VLZXk6IHN0cmluZyxcbiAgaXNQYXNzd29yZFJlY292ZXJ5ID0gZmFsc2Vcbikge1xuICBjb25zdCBjb2RlVmVyaWZpZXIgPSBnZW5lcmF0ZVBLQ0VWZXJpZmllcigpXG4gIGxldCBzdG9yZWRDb2RlVmVyaWZpZXIgPSBjb2RlVmVyaWZpZXJcbiAgaWYgKGlzUGFzc3dvcmRSZWNvdmVyeSkge1xuICAgIHN0b3JlZENvZGVWZXJpZmllciArPSAnL1BBU1NXT1JEX1JFQ09WRVJZJ1xuICB9XG4gIGF3YWl0IHNldEl0ZW1Bc3luYyhzdG9yYWdlLCBgJHtzdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCwgc3RvcmVkQ29kZVZlcmlmaWVyKVxuICBjb25zdCBjb2RlQ2hhbGxlbmdlID0gYXdhaXQgZ2VuZXJhdGVQS0NFQ2hhbGxlbmdlKGNvZGVWZXJpZmllcilcbiAgY29uc3QgY29kZUNoYWxsZW5nZU1ldGhvZCA9IGNvZGVWZXJpZmllciA9PT0gY29kZUNoYWxsZW5nZSA/ICdwbGFpbicgOiAnczI1NidcbiAgcmV0dXJuIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXVxufVxuXG4vKiogUGFyc2VzIHRoZSBBUEkgdmVyc2lvbiB3aGljaCBpcyAyWVlZLU1NLURELiAqL1xuY29uc3QgQVBJX1ZFUlNJT05fUkVHRVggPSAvXjJbMC05XXszfS0oMFsxLTldfDFbMC0yXSktKDBbMS05XXwxWzAtOV18MlswLTldfDNbMC0xXSkkL2lcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uKHJlc3BvbnNlOiBSZXNwb25zZSkge1xuICBjb25zdCBhcGlWZXJzaW9uID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoQVBJX1ZFUlNJT05fSEVBREVSX05BTUUpXG5cbiAgaWYgKCFhcGlWZXJzaW9uKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGlmICghYXBpVmVyc2lvbi5tYXRjaChBUElfVkVSU0lPTl9SRUdFWCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoYCR7YXBpVmVyc2lvbn1UMDA6MDA6MDAuMFpgKVxuICAgIHJldHVybiBkYXRlXG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBXZWFrUGFzc3dvcmRSZWFzb25zIH0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB7IEVycm9yQ29kZSB9IGZyb20gJy4vZXJyb3ItY29kZXMnXG5cbmV4cG9ydCBjbGFzcyBBdXRoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBFcnJvciBjb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXJyb3IuIE1vc3QgZXJyb3JzIGNvbWluZyBmcm9tXG4gICAqIEhUVFAgcmVzcG9uc2VzIHdpbGwgaGF2ZSBhIGNvZGUsIHRob3VnaCBzb21lIGVycm9ycyB0aGF0IG9jY3VyXG4gICAqIGJlZm9yZSBhIHJlc3BvbnNlIGlzIHJlY2VpdmVkIHdpbGwgbm90IGhhdmUgb25lIHByZXNlbnQuIEluIHRoYXRcbiAgICogY2FzZSB7QGxpbmsgI3N0YXR1c30gd2lsbCBhbHNvIGJlIHVuZGVmaW5lZC5cbiAgICovXG4gIGNvZGU6IEVycm9yQ29kZSB8IChzdHJpbmcgJiB7fSkgfCB1bmRlZmluZWRcblxuICAvKiogSFRUUCBzdGF0dXMgY29kZSB0aGF0IGNhdXNlZCB0aGUgZXJyb3IuICovXG4gIHN0YXR1czogbnVtYmVyIHwgdW5kZWZpbmVkXG5cbiAgcHJvdGVjdGVkIF9faXNBdXRoRXJyb3IgPSB0cnVlXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBzdGF0dXM/OiBudW1iZXIsIGNvZGU/OiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdBdXRoRXJyb3InXG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXNcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aEVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgQXV0aEVycm9yIHtcbiAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ19faXNBdXRoRXJyb3InIGluIGVycm9yXG59XG5cbmV4cG9ydCBjbGFzcyBBdXRoQXBpRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xuICBzdGF0dXM6IG51bWJlclxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgc3RhdHVzOiBudW1iZXIsIGNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHN0YXR1cywgY29kZSlcbiAgICB0aGlzLm5hbWUgPSAnQXV0aEFwaUVycm9yJ1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzXG4gICAgdGhpcy5jb2RlID0gY29kZVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhBcGlFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEF1dGhBcGlFcnJvciB7XG4gIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhBcGlFcnJvcidcbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhVbmtub3duRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xuICBvcmlnaW5hbEVycm9yOiB1bmtub3duXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBvcmlnaW5hbEVycm9yOiB1bmtub3duKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQXV0aFVua25vd25FcnJvcidcbiAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEN1c3RvbUF1dGhFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gIG5hbWU6IHN0cmluZ1xuICBzdGF0dXM6IG51bWJlclxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgbmFtZTogc3RyaW5nLCBzdGF0dXM6IG51bWJlciwgY29kZTogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgc3RhdHVzLCBjb2RlKVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdBdXRoIHNlc3Npb24gbWlzc2luZyEnLCAnQXV0aFNlc3Npb25NaXNzaW5nRXJyb3InLCA0MDAsIHVuZGVmaW5lZClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcihlcnJvcjogYW55KTogZXJyb3IgaXMgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3Ige1xuICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcidcbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ0F1dGggc2Vzc2lvbiBvciB1c2VyIG1pc3NpbmcnLCAnQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3InLCA1MDAsIHVuZGVmaW5lZClcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcicsIDQwMCwgdW5kZWZpbmVkKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICBkZXRhaWxzOiB7IGVycm9yOiBzdHJpbmc7IGNvZGU6IHN0cmluZyB9IHwgbnVsbCA9IG51bGxcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBkZXRhaWxzOiB7IGVycm9yOiBzdHJpbmc7IGNvZGU6IHN0cmluZyB9IHwgbnVsbCA9IG51bGwpIHtcbiAgICBzdXBlcihtZXNzYWdlLCAnQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yJywgNTAwLCB1bmRlZmluZWQpXG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlsc1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgZGV0YWlsczogdGhpcy5kZXRhaWxzLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoXG4gIGVycm9yOiBhbnlcbik6IGVycm9yIGlzIEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciB7XG4gIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcidcbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gIGRldGFpbHM6IHsgZXJyb3I6IHN0cmluZzsgY29kZTogc3RyaW5nIH0gfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgZGV0YWlsczogeyBlcnJvcjogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcicsIDUwMCwgdW5kZWZpbmVkKVxuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHNcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIGRldGFpbHM6IHRoaXMuZGV0YWlscyxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhSZXRyeWFibGVGZXRjaEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBzdGF0dXM6IG51bWJlcikge1xuICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcicsIHN0YXR1cywgdW5kZWZpbmVkKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3Ige1xuICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcidcbn1cblxuLyoqXG4gKiBUaGlzIGVycm9yIGlzIHRocm93biBvbiBjZXJ0YWluIG1ldGhvZHMgd2hlbiB0aGUgcGFzc3dvcmQgdXNlZCBpcyBkZWVtZWRcbiAqIHdlYWsuIEluc3BlY3QgdGhlIHJlYXNvbnMgdG8gaWRlbnRpZnkgd2hhdCBwYXNzd29yZCBzdHJlbmd0aCBydWxlcyBhcmVcbiAqIGluYWRlcXVhdGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoV2Vha1Bhc3N3b3JkRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAvKipcbiAgICogUmVhc29ucyB3aHkgdGhlIHBhc3N3b3JkIGlzIGRlZW1lZCB3ZWFrLlxuICAgKi9cbiAgcmVhc29uczogV2Vha1Bhc3N3b3JkUmVhc29uc1tdXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBzdGF0dXM6IG51bWJlciwgcmVhc29uczogc3RyaW5nW10pIHtcbiAgICBzdXBlcihtZXNzYWdlLCAnQXV0aFdlYWtQYXNzd29yZEVycm9yJywgc3RhdHVzLCAnd2Vha19wYXNzd29yZCcpXG5cbiAgICB0aGlzLnJlYXNvbnMgPSByZWFzb25zXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFdlYWtQYXNzd29yZEVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgQXV0aFdlYWtQYXNzd29yZEVycm9yIHtcbiAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aFdlYWtQYXNzd29yZEVycm9yJ1xufVxuIiwgImltcG9ydCB7IEFQSV9WRVJTSU9OUywgQVBJX1ZFUlNJT05fSEVBREVSX05BTUUgfSBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB7IGV4cGlyZXNBdCwgbG9va3NMaWtlRmV0Y2hSZXNwb25zZSwgcGFyc2VSZXNwb25zZUFQSVZlcnNpb24gfSBmcm9tICcuL2hlbHBlcnMnXG5pbXBvcnQge1xuICBBdXRoUmVzcG9uc2UsXG4gIEF1dGhSZXNwb25zZVBhc3N3b3JkLFxuICBTU09SZXNwb25zZSxcbiAgR2VuZXJhdGVMaW5rUHJvcGVydGllcyxcbiAgR2VuZXJhdGVMaW5rUmVzcG9uc2UsXG4gIFVzZXIsXG4gIFVzZXJSZXNwb25zZSxcbn0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB7XG4gIEF1dGhBcGlFcnJvcixcbiAgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IsXG4gIEF1dGhXZWFrUGFzc3dvcmRFcnJvcixcbiAgQXV0aFVua25vd25FcnJvcixcbiAgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IsXG59IGZyb20gJy4vZXJyb3JzJ1xuXG5leHBvcnQgdHlwZSBGZXRjaCA9IHR5cGVvZiBmZXRjaFxuXG5leHBvcnQgaW50ZXJmYWNlIEZldGNoT3B0aW9ucyB7XG4gIGhlYWRlcnM/OiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gIH1cbiAgbm9SZXNvbHZlSnNvbj86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGZXRjaFBhcmFtZXRlcnMge1xuICBzaWduYWw/OiBBYm9ydFNpZ25hbFxufVxuXG5leHBvcnQgdHlwZSBSZXF1ZXN0TWV0aG9kVHlwZSA9ICdHRVQnIHwgJ1BPU1QnIHwgJ1BVVCcgfCAnREVMRVRFJ1xuXG5jb25zdCBfZ2V0RXJyb3JNZXNzYWdlID0gKGVycjogYW55KTogc3RyaW5nID0+XG4gIGVyci5tc2cgfHwgZXJyLm1lc3NhZ2UgfHwgZXJyLmVycm9yX2Rlc2NyaXB0aW9uIHx8IGVyci5lcnJvciB8fCBKU09OLnN0cmluZ2lmeShlcnIpXG5cbmNvbnN0IE5FVFdPUktfRVJST1JfQ09ERVMgPSBbNTAyLCA1MDMsIDUwNF1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yOiB1bmtub3duKSB7XG4gIGlmICghbG9va3NMaWtlRmV0Y2hSZXNwb25zZShlcnJvcikpIHtcbiAgICB0aHJvdyBuZXcgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIDApXG4gIH1cblxuICBpZiAoTkVUV09SS19FUlJPUl9DT0RFUy5pbmNsdWRlcyhlcnJvci5zdGF0dXMpKSB7XG4gICAgLy8gc3RhdHVzIGluIDUwMC4uLjU5OSByYW5nZSAtIHNlcnZlciBoYWQgYW4gZXJyb3IsIHJlcXVlc3QgbWlnaHQgYmUgcmV0cnllZC5cbiAgICB0aHJvdyBuZXcgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yLnN0YXR1cylcbiAgfVxuXG4gIGxldCBkYXRhOiBhbnlcbiAgdHJ5IHtcbiAgICBkYXRhID0gYXdhaXQgZXJyb3IuanNvbigpXG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIHRocm93IG5ldyBBdXRoVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZSksIGUpXG4gIH1cblxuICBsZXQgZXJyb3JDb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcblxuICBjb25zdCByZXNwb25zZUFQSVZlcnNpb24gPSBwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbihlcnJvcilcbiAgaWYgKFxuICAgIHJlc3BvbnNlQVBJVmVyc2lvbiAmJlxuICAgIHJlc3BvbnNlQVBJVmVyc2lvbi5nZXRUaW1lKCkgPj0gQVBJX1ZFUlNJT05TWycyMDI0LTAxLTAxJ10udGltZXN0YW1wICYmXG4gICAgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgZGF0YSAmJlxuICAgIHR5cGVvZiBkYXRhLmNvZGUgPT09ICdzdHJpbmcnXG4gICkge1xuICAgIGVycm9yQ29kZSA9IGRhdGEuY29kZVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhICYmIHR5cGVvZiBkYXRhLmVycm9yX2NvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZXJyb3JDb2RlID0gZGF0YS5lcnJvcl9jb2RlXG4gIH1cblxuICBpZiAoIWVycm9yQ29kZSkge1xuICAgIC8vIExlZ2FjeSBzdXBwb3J0IGZvciB3ZWFrIHBhc3N3b3JkIGVycm9ycywgd2hlbiB0aGVyZSB3ZXJlIG5vIGVycm9yIGNvZGVzXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICBkYXRhICYmXG4gICAgICB0eXBlb2YgZGF0YS53ZWFrX3Bhc3N3b3JkID09PSAnb2JqZWN0JyAmJlxuICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkICYmXG4gICAgICBBcnJheS5pc0FycmF5KGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKSAmJlxuICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMubGVuZ3RoICYmXG4gICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5yZWR1Y2UoKGE6IGJvb2xlYW4sIGk6IGFueSkgPT4gYSAmJiB0eXBlb2YgaSA9PT0gJ3N0cmluZycsIHRydWUpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgQXV0aFdlYWtQYXNzd29yZEVycm9yKFxuICAgICAgICBfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLFxuICAgICAgICBlcnJvci5zdGF0dXMsXG4gICAgICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zXG4gICAgICApXG4gICAgfVxuICB9IGVsc2UgaWYgKGVycm9yQ29kZSA9PT0gJ3dlYWtfcGFzc3dvcmQnKSB7XG4gICAgdGhyb3cgbmV3IEF1dGhXZWFrUGFzc3dvcmRFcnJvcihcbiAgICAgIF9nZXRFcnJvck1lc3NhZ2UoZGF0YSksXG4gICAgICBlcnJvci5zdGF0dXMsXG4gICAgICBkYXRhLndlYWtfcGFzc3dvcmQ/LnJlYXNvbnMgfHwgW11cbiAgICApXG4gIH0gZWxzZSBpZiAoZXJyb3JDb2RlID09PSAnc2Vzc2lvbl9ub3RfZm91bmQnKSB7XG4gICAgLy8gVGhlIGBzZXNzaW9uX2lkYCBpbnNpZGUgdGhlIEpXVCBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIGEgcm93IGluIHRoZVxuICAgIC8vIGBzZXNzaW9uc2AgdGFibGUuIFRoaXMgdXN1YWxseSBtZWFucyB0aGUgdXNlciBoYXMgc2lnbmVkIG91dCwgaGFzIGJlZW5cbiAgICAvLyBkZWxldGVkLCBvciB0aGVpciBzZXNzaW9uIGhhcyBzb21laG93IGJlZW4gdGVybWluYXRlZC5cbiAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKVxuICB9XG5cbiAgdGhyb3cgbmV3IEF1dGhBcGlFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLCBlcnJvci5zdGF0dXMgfHwgNTAwLCBlcnJvckNvZGUpXG59XG5cbmNvbnN0IF9nZXRSZXF1ZXN0UGFyYW1zID0gKFxuICBtZXRob2Q6IFJlcXVlc3RNZXRob2RUeXBlLFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzLFxuICBib2R5Pzogb2JqZWN0XG4pID0+IHtcbiAgY29uc3QgcGFyYW1zOiB7IFtrOiBzdHJpbmddOiBhbnkgfSA9IHsgbWV0aG9kLCBoZWFkZXJzOiBvcHRpb25zPy5oZWFkZXJzIHx8IHt9IH1cblxuICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgIHJldHVybiBwYXJhbXNcbiAgfVxuXG4gIHBhcmFtcy5oZWFkZXJzID0geyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD1VVEYtOCcsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfVxuICBwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gIHJldHVybiB7IC4uLnBhcmFtcywgLi4ucGFyYW1ldGVycyB9XG59XG5cbmludGVyZmFjZSBHb3RydWVSZXF1ZXN0T3B0aW9ucyBleHRlbmRzIEZldGNoT3B0aW9ucyB7XG4gIGp3dD86IHN0cmluZ1xuICByZWRpcmVjdFRvPzogc3RyaW5nXG4gIGJvZHk/OiBvYmplY3RcbiAgcXVlcnk/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgYXBpIHJlc3BvbnNlIGZyb20gZ290cnVlIGludG8gYSBkZXNpcmFibGUgLyBzdGFuZGFyZGlzZWQgZm9ybWF0XG4gICAqL1xuICB4Zm9ybT86IChkYXRhOiBhbnkpID0+IGFueVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX3JlcXVlc3QoXG4gIGZldGNoZXI6IEZldGNoLFxuICBtZXRob2Q6IFJlcXVlc3RNZXRob2RUeXBlLFxuICB1cmw6IHN0cmluZyxcbiAgb3B0aW9ucz86IEdvdHJ1ZVJlcXVlc3RPcHRpb25zXG4pIHtcbiAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICB9XG5cbiAgaWYgKCFoZWFkZXJzW0FQSV9WRVJTSU9OX0hFQURFUl9OQU1FXSkge1xuICAgIGhlYWRlcnNbQVBJX1ZFUlNJT05fSEVBREVSX05BTUVdID0gQVBJX1ZFUlNJT05TWycyMDI0LTAxLTAxJ10ubmFtZVxuICB9XG5cbiAgaWYgKG9wdGlvbnM/Lmp3dCkge1xuICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHtvcHRpb25zLmp3dH1gXG4gIH1cblxuICBjb25zdCBxcyA9IG9wdGlvbnM/LnF1ZXJ5ID8/IHt9XG4gIGlmIChvcHRpb25zPy5yZWRpcmVjdFRvKSB7XG4gICAgcXNbJ3JlZGlyZWN0X3RvJ10gPSBvcHRpb25zLnJlZGlyZWN0VG9cbiAgfVxuXG4gIGNvbnN0IHF1ZXJ5U3RyaW5nID0gT2JqZWN0LmtleXMocXMpLmxlbmd0aCA/ICc/JyArIG5ldyBVUkxTZWFyY2hQYXJhbXMocXMpLnRvU3RyaW5nKCkgOiAnJ1xuICBjb25zdCBkYXRhID0gYXdhaXQgX2hhbmRsZVJlcXVlc3QoXG4gICAgZmV0Y2hlcixcbiAgICBtZXRob2QsXG4gICAgdXJsICsgcXVlcnlTdHJpbmcsXG4gICAge1xuICAgICAgaGVhZGVycyxcbiAgICAgIG5vUmVzb2x2ZUpzb246IG9wdGlvbnM/Lm5vUmVzb2x2ZUpzb24sXG4gICAgfSxcbiAgICB7fSxcbiAgICBvcHRpb25zPy5ib2R5XG4gIClcbiAgcmV0dXJuIG9wdGlvbnM/Lnhmb3JtID8gb3B0aW9ucz8ueGZvcm0oZGF0YSkgOiB7IGRhdGE6IHsgLi4uZGF0YSB9LCBlcnJvcjogbnVsbCB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9oYW5kbGVSZXF1ZXN0KFxuICBmZXRjaGVyOiBGZXRjaCxcbiAgbWV0aG9kOiBSZXF1ZXN0TWV0aG9kVHlwZSxcbiAgdXJsOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnMsXG4gIGJvZHk/OiBvYmplY3Rcbik6IFByb21pc2U8YW55PiB7XG4gIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSBfZ2V0UmVxdWVzdFBhcmFtcyhtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpXG5cbiAgbGV0IHJlc3VsdDogYW55XG5cbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBhd2FpdCBmZXRjaGVyKHVybCwge1xuICAgICAgLi4ucmVxdWVzdFBhcmFtcyxcbiAgICB9KVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKVxuXG4gICAgLy8gZmV0Y2ggZmFpbGVkLCBsaWtlbHkgZHVlIHRvIGEgbmV0d29yayBvciBDT1JTIGVycm9yXG4gICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZSksIDApXG4gIH1cblxuICBpZiAoIXJlc3VsdC5vaykge1xuICAgIGF3YWl0IGhhbmRsZUVycm9yKHJlc3VsdClcbiAgfVxuXG4gIGlmIChvcHRpb25zPy5ub1Jlc29sdmVKc29uKSB7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcmVzdWx0Lmpzb24oKVxuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICBhd2FpdCBoYW5kbGVFcnJvcihlKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfc2Vzc2lvblJlc3BvbnNlKGRhdGE6IGFueSk6IEF1dGhSZXNwb25zZSB7XG4gIGxldCBzZXNzaW9uID0gbnVsbFxuICBpZiAoaGFzU2Vzc2lvbihkYXRhKSkge1xuICAgIHNlc3Npb24gPSB7IC4uLmRhdGEgfVxuXG4gICAgaWYgKCFkYXRhLmV4cGlyZXNfYXQpIHtcbiAgICAgIHNlc3Npb24uZXhwaXJlc19hdCA9IGV4cGlyZXNBdChkYXRhLmV4cGlyZXNfaW4pXG4gICAgfVxuICB9XG5cbiAgY29uc3QgdXNlcjogVXNlciA9IGRhdGEudXNlciA/PyAoZGF0YSBhcyBVc2VyKVxuICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb24sIHVzZXIgfSwgZXJyb3I6IG51bGwgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkKGRhdGE6IGFueSk6IEF1dGhSZXNwb25zZVBhc3N3b3JkIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBfc2Vzc2lvblJlc3BvbnNlKGRhdGEpIGFzIEF1dGhSZXNwb25zZVBhc3N3b3JkXG5cbiAgaWYgKFxuICAgICFyZXNwb25zZS5lcnJvciAmJlxuICAgIGRhdGEud2Vha19wYXNzd29yZCAmJlxuICAgIHR5cGVvZiBkYXRhLndlYWtfcGFzc3dvcmQgPT09ICdvYmplY3QnICYmXG4gICAgQXJyYXkuaXNBcnJheShkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucykgJiZcbiAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5sZW5ndGggJiZcbiAgICBkYXRhLndlYWtfcGFzc3dvcmQubWVzc2FnZSAmJlxuICAgIHR5cGVvZiBkYXRhLndlYWtfcGFzc3dvcmQubWVzc2FnZSA9PT0gJ3N0cmluZycgJiZcbiAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5yZWR1Y2UoKGE6IGJvb2xlYW4sIGk6IGFueSkgPT4gYSAmJiB0eXBlb2YgaSA9PT0gJ3N0cmluZycsIHRydWUpXG4gICkge1xuICAgIHJlc3BvbnNlLmRhdGEud2Vha19wYXNzd29yZCA9IGRhdGEud2Vha19wYXNzd29yZFxuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfdXNlclJlc3BvbnNlKGRhdGE6IGFueSk6IFVzZXJSZXNwb25zZSB7XG4gIGNvbnN0IHVzZXI6IFVzZXIgPSBkYXRhLnVzZXIgPz8gKGRhdGEgYXMgVXNlcilcbiAgcmV0dXJuIHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiBudWxsIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9zc29SZXNwb25zZShkYXRhOiBhbnkpOiBTU09SZXNwb25zZSB7XG4gIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZW5lcmF0ZUxpbmtSZXNwb25zZShkYXRhOiBhbnkpOiBHZW5lcmF0ZUxpbmtSZXNwb25zZSB7XG4gIGNvbnN0IHsgYWN0aW9uX2xpbmssIGVtYWlsX290cCwgaGFzaGVkX3Rva2VuLCByZWRpcmVjdF90bywgdmVyaWZpY2F0aW9uX3R5cGUsIC4uLnJlc3QgfSA9IGRhdGFcblxuICBjb25zdCBwcm9wZXJ0aWVzOiBHZW5lcmF0ZUxpbmtQcm9wZXJ0aWVzID0ge1xuICAgIGFjdGlvbl9saW5rLFxuICAgIGVtYWlsX290cCxcbiAgICBoYXNoZWRfdG9rZW4sXG4gICAgcmVkaXJlY3RfdG8sXG4gICAgdmVyaWZpY2F0aW9uX3R5cGUsXG4gIH1cblxuICBjb25zdCB1c2VyOiBVc2VyID0geyAuLi5yZXN0IH1cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiB7XG4gICAgICBwcm9wZXJ0aWVzLFxuICAgICAgdXNlcixcbiAgICB9LFxuICAgIGVycm9yOiBudWxsLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfbm9SZXNvbHZlSnNvblJlc3BvbnNlKGRhdGE6IGFueSk6IFJlc3BvbnNlIHtcbiAgcmV0dXJuIGRhdGFcbn1cblxuLyoqXG4gKiBoYXNTZXNzaW9uIGNoZWNrcyBpZiB0aGUgcmVzcG9uc2Ugb2JqZWN0IGNvbnRhaW5zIGEgdmFsaWQgc2Vzc2lvblxuICogQHBhcmFtIGRhdGEgQSByZXNwb25zZSBvYmplY3RcbiAqIEByZXR1cm5zIHRydWUgaWYgYSBzZXNzaW9uIGlzIGluIHRoZSByZXNwb25zZVxuICovXG5mdW5jdGlvbiBoYXNTZXNzaW9uKGRhdGE6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gZGF0YS5hY2Nlc3NfdG9rZW4gJiYgZGF0YS5yZWZyZXNoX3Rva2VuICYmIGRhdGEuZXhwaXJlc19pblxufVxuIiwgImltcG9ydCB7XG4gIEZldGNoLFxuICBfZ2VuZXJhdGVMaW5rUmVzcG9uc2UsXG4gIF9ub1Jlc29sdmVKc29uUmVzcG9uc2UsXG4gIF9yZXF1ZXN0LFxuICBfdXNlclJlc3BvbnNlLFxufSBmcm9tICcuL2xpYi9mZXRjaCdcbmltcG9ydCB7IHJlc29sdmVGZXRjaCB9IGZyb20gJy4vbGliL2hlbHBlcnMnXG5pbXBvcnQge1xuICBBZG1pblVzZXJBdHRyaWJ1dGVzLFxuICBHZW5lcmF0ZUxpbmtQYXJhbXMsXG4gIEdlbmVyYXRlTGlua1Jlc3BvbnNlLFxuICBQYWdpbmF0aW9uLFxuICBVc2VyLFxuICBVc2VyUmVzcG9uc2UsXG4gIEdvVHJ1ZUFkbWluTUZBQXBpLFxuICBBdXRoTUZBQWRtaW5EZWxldGVGYWN0b3JQYXJhbXMsXG4gIEF1dGhNRkFBZG1pbkRlbGV0ZUZhY3RvclJlc3BvbnNlLFxuICBBdXRoTUZBQWRtaW5MaXN0RmFjdG9yc1BhcmFtcyxcbiAgQXV0aE1GQUFkbWluTGlzdEZhY3RvcnNSZXNwb25zZSxcbiAgUGFnZVBhcmFtcyxcbn0gZnJvbSAnLi9saWIvdHlwZXMnXG5pbXBvcnQgeyBBdXRoRXJyb3IsIGlzQXV0aEVycm9yIH0gZnJvbSAnLi9saWIvZXJyb3JzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHb1RydWVBZG1pbkFwaSB7XG4gIC8qKiBDb250YWlucyBhbGwgTUZBIGFkbWluaXN0cmF0aW9uIG1ldGhvZHMuICovXG4gIG1mYTogR29UcnVlQWRtaW5NRkFBcGlcblxuICBwcm90ZWN0ZWQgdXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIGhlYWRlcnM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuICBwcm90ZWN0ZWQgZmV0Y2g6IEZldGNoXG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHVybCA9ICcnLFxuICAgIGhlYWRlcnMgPSB7fSxcbiAgICBmZXRjaCxcbiAgfToge1xuICAgIHVybDogc3RyaW5nXG4gICAgaGVhZGVycz86IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICAgIH1cbiAgICBmZXRjaD86IEZldGNoXG4gIH0pIHtcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnNcbiAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoKVxuICAgIHRoaXMubWZhID0ge1xuICAgICAgbGlzdEZhY3RvcnM6IHRoaXMuX2xpc3RGYWN0b3JzLmJpbmQodGhpcyksXG4gICAgICBkZWxldGVGYWN0b3I6IHRoaXMuX2RlbGV0ZUZhY3Rvci5iaW5kKHRoaXMpLFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgbG9nZ2VkLWluIHNlc3Npb24uXG4gICAqIEBwYXJhbSBqd3QgQSB2YWxpZCwgbG9nZ2VkLWluIEpXVC5cbiAgICogQHBhcmFtIHNjb3BlIFRoZSBsb2dvdXQgc29wZS5cbiAgICovXG4gIGFzeW5jIHNpZ25PdXQoXG4gICAgand0OiBzdHJpbmcsXG4gICAgc2NvcGU6ICdnbG9iYWwnIHwgJ2xvY2FsJyB8ICdvdGhlcnMnID0gJ2dsb2JhbCdcbiAgKTogUHJvbWlzZTx7IGRhdGE6IG51bGw7IGVycm9yOiBBdXRoRXJyb3IgfCBudWxsIH0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vbG9nb3V0P3Njb3BlPSR7c2NvcGV9YCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIGp3dCxcbiAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhbiBpbnZpdGUgbGluayB0byBhbiBlbWFpbCBhZGRyZXNzLlxuICAgKiBAcGFyYW0gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBiZSBpbmNsdWRlZCB3aGVuIGludml0aW5nLlxuICAgKi9cbiAgYXN5bmMgaW52aXRlVXNlckJ5RW1haWwoXG4gICAgZW1haWw6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7XG4gICAgICAvKiogQSBjdXN0b20gZGF0YSBvYmplY3QgdG8gc3RvcmUgYWRkaXRpb25hbCBtZXRhZGF0YSBhYm91dCB0aGUgdXNlci4gVGhpcyBtYXBzIHRvIHRoZSBgYXV0aC51c2Vycy51c2VyX21ldGFkYXRhYCBjb2x1bW4uICovXG4gICAgICBkYXRhPzogb2JqZWN0XG5cbiAgICAgIC8qKiBUaGUgVVJMIHdoaWNoIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIGVtYWlsIGxpbmsgc2VudCB0byB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuIE9uY2UgY2xpY2tlZCB0aGUgdXNlciB3aWxsIGVuZCB1cCBvbiB0aGlzIFVSTC4gKi9cbiAgICAgIHJlZGlyZWN0VG8/OiBzdHJpbmdcbiAgICB9ID0ge31cbiAgKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ludml0ZWAsIHtcbiAgICAgICAgYm9keTogeyBlbWFpbCwgZGF0YTogb3B0aW9ucy5kYXRhIH0sXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGVtYWlsIGxpbmtzIGFuZCBPVFBzIHRvIGJlIHNlbnQgdmlhIGEgY3VzdG9tIGVtYWlsIHByb3ZpZGVyLlxuICAgKiBAcGFyYW0gZW1haWwgVGhlIHVzZXIncyBlbWFpbC5cbiAgICogQHBhcmFtIG9wdGlvbnMucGFzc3dvcmQgVXNlciBwYXNzd29yZC4gRm9yIHNpZ251cCBvbmx5LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kYXRhIE9wdGlvbmFsIHVzZXIgbWV0YWRhdGEuIEZvciBzaWdudXAgb25seS5cbiAgICogQHBhcmFtIG9wdGlvbnMucmVkaXJlY3RUbyBUaGUgcmVkaXJlY3QgdXJsIHdoaWNoIHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZ2VuZXJhdGVkIGxpbmtcbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlTGluayhwYXJhbXM6IEdlbmVyYXRlTGlua1BhcmFtcyk6IFByb21pc2U8R2VuZXJhdGVMaW5rUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBvcHRpb25zLCAuLi5yZXN0IH0gPSBwYXJhbXNcbiAgICAgIGNvbnN0IGJvZHk6IGFueSA9IHsgLi4ucmVzdCwgLi4ub3B0aW9ucyB9XG4gICAgICBpZiAoJ25ld0VtYWlsJyBpbiByZXN0KSB7XG4gICAgICAgIC8vIHJlcGxhY2UgbmV3RW1haWwgd2l0aCBuZXdfZW1haWwgaW4gcmVxdWVzdCBib2R5XG4gICAgICAgIGJvZHkubmV3X2VtYWlsID0gcmVzdD8ubmV3RW1haWxcbiAgICAgICAgZGVsZXRlIGJvZHlbJ25ld0VtYWlsJ11cbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9hZG1pbi9nZW5lcmF0ZV9saW5rYCwge1xuICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHhmb3JtOiBfZ2VuZXJhdGVMaW5rUmVzcG9uc2UsXG4gICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnM/LnJlZGlyZWN0VG8sXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgICAgIHVzZXI6IG51bGwsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvLyBVc2VyIEFkbWluIEFQSVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlVXNlcihhdHRyaWJ1dGVzOiBBZG1pblVzZXJBdHRyaWJ1dGVzKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzYCwge1xuICAgICAgICBib2R5OiBhdHRyaWJ1dGVzLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIHVzZXJzLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9iamVjdCB3aGljaCBzdXBwb3J0cyBgcGFnZWAgYW5kIGBwZXJQYWdlYCBhcyBudW1iZXJzLCB0byBhbHRlciB0aGUgcGFnaW5hdGVkIHJlc3VsdHMuXG4gICAqL1xuICBhc3luYyBsaXN0VXNlcnMoXG4gICAgcGFyYW1zPzogUGFnZVBhcmFtc1xuICApOiBQcm9taXNlPFxuICAgIHwgeyBkYXRhOiB7IHVzZXJzOiBVc2VyW107IGF1ZDogc3RyaW5nIH0gJiBQYWdpbmF0aW9uOyBlcnJvcjogbnVsbCB9XG4gICAgfCB7IGRhdGE6IHsgdXNlcnM6IFtdIH07IGVycm9yOiBBdXRoRXJyb3IgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFnaW5hdGlvbjogUGFnaW5hdGlvbiA9IHsgbmV4dFBhZ2U6IG51bGwsIGxhc3RQYWdlOiAwLCB0b3RhbDogMCB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnNgLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICBwYWdlOiBwYXJhbXM/LnBhZ2U/LnRvU3RyaW5nKCkgPz8gJycsXG4gICAgICAgICAgcGVyX3BhZ2U6IHBhcmFtcz8ucGVyUGFnZT8udG9TdHJpbmcoKSA/PyAnJyxcbiAgICAgICAgfSxcbiAgICAgICAgeGZvcm06IF9ub1Jlc29sdmVKc29uUmVzcG9uc2UsXG4gICAgICB9KVxuICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB0aHJvdyByZXNwb25zZS5lcnJvclxuXG4gICAgICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgY29uc3QgdG90YWwgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC10b3RhbC1jb3VudCcpID8/IDBcbiAgICAgIGNvbnN0IGxpbmtzID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2xpbmsnKT8uc3BsaXQoJywnKSA/PyBbXVxuICAgICAgaWYgKGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGlua3MuZm9yRWFjaCgobGluazogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFnZSA9IHBhcnNlSW50KGxpbmsuc3BsaXQoJzsnKVswXS5zcGxpdCgnPScpWzFdLnN1YnN0cmluZygwLCAxKSlcbiAgICAgICAgICBjb25zdCByZWwgPSBKU09OLnBhcnNlKGxpbmsuc3BsaXQoJzsnKVsxXS5zcGxpdCgnPScpWzFdKVxuICAgICAgICAgIHBhZ2luYXRpb25bYCR7cmVsfVBhZ2VgXSA9IHBhZ2VcbiAgICAgICAgfSlcblxuICAgICAgICBwYWdpbmF0aW9uLnRvdGFsID0gcGFyc2VJbnQodG90YWwpXG4gICAgICB9XG4gICAgICByZXR1cm4geyBkYXRhOiB7IC4uLnVzZXJzLCAuLi5wYWdpbmF0aW9uIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXJzOiBbXSB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdXNlciBieSBpZC5cbiAgICpcbiAgICogQHBhcmFtIHVpZCBUaGUgdXNlcidzIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAqL1xuICBhc3luYyBnZXRVc2VyQnlJZCh1aWQ6IHN0cmluZyk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7dWlkfWAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdXNlciBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gYXR0cmlidXRlcyBUaGUgZGF0YSB5b3Ugd2FudCB0byB1cGRhdGUuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAqL1xuICBhc3luYyB1cGRhdGVVc2VyQnlJZCh1aWQ6IHN0cmluZywgYXR0cmlidXRlczogQWRtaW5Vc2VyQXR0cmlidXRlcyk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUFVUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7dWlkfWAsIHtcbiAgICAgICAgYm9keTogYXR0cmlidXRlcyxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgdXNlci4gUmVxdWlyZXMgYSBgc2VydmljZV9yb2xlYCBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBpZCBUaGUgdXNlciBpZCB5b3Ugd2FudCB0byByZW1vdmUuXG4gICAqIEBwYXJhbSBzaG91bGRTb2Z0RGVsZXRlIElmIHRydWUsIHRoZW4gdGhlIHVzZXIgd2lsbCBiZSBzb2Z0LWRlbGV0ZWQgZnJvbSB0aGUgYXV0aCBzY2hlbWEuIFNvZnQgZGVsZXRpb24gYWxsb3dzIHVzZXIgaWRlbnRpZmljYXRpb24gZnJvbSB0aGUgaGFzaGVkIHVzZXIgSUQgYnV0IGlzIG5vdCByZXZlcnNpYmxlLlxuICAgKiBEZWZhdWx0cyB0byBmYWxzZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZVVzZXIoaWQ6IHN0cmluZywgc2hvdWxkU29mdERlbGV0ZSA9IGZhbHNlKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHtpZH1gLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIHNob3VsZF9zb2Z0X2RlbGV0ZTogc2hvdWxkU29mdERlbGV0ZSxcbiAgICAgICAgfSxcbiAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfbGlzdEZhY3RvcnMoXG4gICAgcGFyYW1zOiBBdXRoTUZBQWRtaW5MaXN0RmFjdG9yc1BhcmFtc1xuICApOiBQcm9taXNlPEF1dGhNRkFBZG1pbkxpc3RGYWN0b3JzUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgICdHRVQnLFxuICAgICAgICBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHtwYXJhbXMudXNlcklkfS9mYWN0b3JzYCxcbiAgICAgICAge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICB4Zm9ybTogKGZhY3RvcnM6IGFueSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBmYWN0b3JzIH0sIGVycm9yOiBudWxsIH1cbiAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICApXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvciB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2RlbGV0ZUZhY3RvcihcbiAgICBwYXJhbXM6IEF1dGhNRkFBZG1pbkRlbGV0ZUZhY3RvclBhcmFtc1xuICApOiBQcm9taXNlPEF1dGhNRkFBZG1pbkRlbGV0ZUZhY3RvclJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBfcmVxdWVzdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgJ0RFTEVURScsXG4gICAgICAgIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3BhcmFtcy51c2VySWR9L2ZhY3RvcnMvJHtwYXJhbXMuaWR9YCxcbiAgICAgICAge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgfVxuICAgICAgKVxuXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IHN1cHBvcnRzTG9jYWxTdG9yYWdlIH0gZnJvbSAnLi9oZWxwZXJzJ1xuaW1wb3J0IHsgU3VwcG9ydGVkU3RvcmFnZSB9IGZyb20gJy4vdHlwZXMnXG5cbi8qKlxuICogUHJvdmlkZXMgc2FmZSBhY2Nlc3MgdG8gdGhlIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlIHByb3BlcnR5LlxuICovXG5leHBvcnQgY29uc3QgbG9jYWxTdG9yYWdlQWRhcHRlcjogU3VwcG9ydGVkU3RvcmFnZSA9IHtcbiAgZ2V0SXRlbTogKGtleSkgPT4ge1xuICAgIGlmICghc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpXG4gIH0sXG4gIHNldEl0ZW06IChrZXksIHZhbHVlKSA9PiB7XG4gICAgaWYgKCFzdXBwb3J0c0xvY2FsU3RvcmFnZSgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpXG4gIH0sXG4gIHJlbW92ZUl0ZW06IChrZXkpID0+IHtcbiAgICBpZiAoIXN1cHBvcnRzTG9jYWxTdG9yYWdlKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxuICB9LFxufVxuXG4vKipcbiAqIFJldHVybnMgYSBsb2NhbFN0b3JhZ2UtbGlrZSBvYmplY3QgdGhhdCBzdG9yZXMgdGhlIGtleS12YWx1ZSBwYWlycyBpblxuICogbWVtb3J5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlcihzdG9yZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9KTogU3VwcG9ydGVkU3RvcmFnZSB7XG4gIHJldHVybiB7XG4gICAgZ2V0SXRlbTogKGtleSkgPT4ge1xuICAgICAgcmV0dXJuIHN0b3JlW2tleV0gfHwgbnVsbFxuICAgIH0sXG5cbiAgICBzZXRJdGVtOiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgc3RvcmVba2V5XSA9IHZhbHVlXG4gICAgfSxcblxuICAgIHJlbW92ZUl0ZW06IChrZXkpID0+IHtcbiAgICAgIGRlbGV0ZSBzdG9yZVtrZXldXG4gICAgfSxcbiAgfVxufVxuIiwgIi8qKlxuICogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2dsb2JhbHRoaXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvbHlmaWxsR2xvYmFsVGhpcygpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuXG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsICdfX21hZ2ljX18nLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSlcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gbWFnaWMnXG4gICAgX19tYWdpY19fLmdsb2JhbFRoaXMgPSBfX21hZ2ljX19cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gbWFnaWMnXG4gICAgZGVsZXRlIE9iamVjdC5wcm90b3R5cGUuX19tYWdpY19fXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gZ2xvYmFscydcbiAgICAgIHNlbGYuZ2xvYmFsVGhpcyA9IHNlbGZcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBzdXBwb3J0c0xvY2FsU3RvcmFnZSB9IGZyb20gJy4vaGVscGVycydcblxuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcm5hbHMgPSB7XG4gIC8qKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBkZWJ1ZzogISEoXG4gICAgZ2xvYmFsVGhpcyAmJlxuICAgIHN1cHBvcnRzTG9jYWxTdG9yYWdlKCkgJiZcbiAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSAmJlxuICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3N1cGFiYXNlLmdvdHJ1ZS1qcy5sb2Nrcy5kZWJ1ZycpID09PSAndHJ1ZSdcbiAgKSxcbn1cblxuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBhIGxvY2sgY2Fubm90IGJlIGFjcXVpcmVkIGFmdGVyIHNvbWUgYW1vdW50IG9mIHRpbWUuXG4gKlxuICogVXNlIHRoZSB7QGxpbmsgI2lzQWNxdWlyZVRpbWVvdXR9IHByb3BlcnR5IGluc3RlYWQgb2YgY2hlY2tpbmcgd2l0aCBgaW5zdGFuY2VvZmAuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHVibGljIHJlYWRvbmx5IGlzQWNxdWlyZVRpbWVvdXQgPSB0cnVlXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgZXh0ZW5kcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciB7fVxuZXhwb3J0IGNsYXNzIFByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIHt9XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIGdsb2JhbCBleGNsdXNpdmUgbG9jayB1c2luZyB0aGUgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIEFQSS4gSXRcbiAqIGlzIGF2YWlsYWJsZSBvbiBhbGwgYnJvd3NlcnMgcmVsZWFzZWQgYWZ0ZXIgMjAyMi0wMy0xNSB3aXRoIFNhZmFyaSBiZWluZyB0aGVcbiAqIGxhc3Qgb25lIHRvIHJlbGVhc2Ugc3VwcG9ydC4gSWYgdGhlIEFQSSBpcyBub3QgYXZhaWxhYmxlLCB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAqIHRocm93LiBNYWtlIHN1cmUgeW91IGNoZWNrIGF2YWlsYWJsaWxpdHkgYmVmb3JlIGNvbmZpZ3VyaW5nIHtAbGlua1xuICogR29UcnVlQ2xpZW50fS5cbiAqXG4gKiBZb3UgY2FuIHR1cm4gb24gZGVidWdnaW5nIGJ5IHNldHRpbmcgdGhlIGBzdXBhYmFzZS5nb3RydWUtanMubG9ja3MuZGVidWdgXG4gKiBsb2NhbCBzdG9yYWdlIGl0ZW0gdG8gYHRydWVgLlxuICpcbiAqIEludGVybmFsczpcbiAqXG4gKiBTaW5jZSB0aGUgTG9ja01hbmFnZXIgQVBJIGRvZXMgbm90IHByZXNlcnZlIHN0YWNrIHRyYWNlcyBmb3IgdGhlIGFzeW5jXG4gKiBmdW5jdGlvbiBwYXNzZWQgaW4gdGhlIGByZXF1ZXN0YCBtZXRob2QsIGEgdHJpY2sgaXMgdXNlZCB3aGVyZSBhY3F1aXJpbmcgdGhlXG4gKiBsb2NrIHJlbGVhc2VzIGEgcHJldmlvdXNseSBzdGFydGVkIHByb21pc2UgdG8gcnVuIHRoZSBvcGVyYXRpb24gaW4gdGhlIGBmbmBcbiAqIGZ1bmN0aW9uLiBUaGUgbG9jayB3YWl0cyBmb3IgdGhhdCBwcm9taXNlIHRvIGZpbmlzaCAod2l0aCBvciB3aXRob3V0IGVycm9yKSxcbiAqIHdoaWxlIHRoZSBmdW5jdGlvbiB3aWxsIGZpbmFsbHkgd2FpdCBmb3IgdGhlIHJlc3VsdCBhbnl3YXkuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgbG9jayB0byBiZSBhY3F1aXJlZC5cbiAqIEBwYXJhbSBhY3F1aXJlVGltZW91dCBJZiBuZWdhdGl2ZSwgbm8gdGltZW91dC4gSWYgMCBhbiBlcnJvciBpcyB0aHJvd24gaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICB0aGUgbG9jayBjYW4ndCBiZSBhY3F1aXJlZCB3aXRob3V0IHdhaXRpbmcuIElmIHBvc2l0aXZlLCB0aGUgbG9jayBhY3F1aXJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCB0aW1lIG91dCBhZnRlciBzbyBtYW55IG1pbGxpc2Vjb25kcy4gQW4gZXJyb3IgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICBhIHRpbWVvdXQgaWYgaXQgaGFzIGBpc0FjcXVpcmVUaW1lb3V0YCBzZXQgdG8gdHJ1ZS5cbiAqIEBwYXJhbSBmbiBUaGUgb3BlcmF0aW9uIHRvIHJ1biBvbmNlIHRoZSBsb2NrIGlzIGFjcXVpcmVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbmF2aWdhdG9yTG9jazxSPihcbiAgbmFtZTogc3RyaW5nLFxuICBhY3F1aXJlVGltZW91dDogbnVtYmVyLFxuICBmbjogKCkgPT4gUHJvbWlzZTxSPlxuKTogUHJvbWlzZTxSPiB7XG4gIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogYWNxdWlyZSBsb2NrJywgbmFtZSwgYWNxdWlyZVRpbWVvdXQpXG4gIH1cblxuICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXIoKVxuXG4gIGlmIChhY3F1aXJlVGltZW91dCA+IDApIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpXG4gICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrIGFjcXVpcmUgdGltZWQgb3V0JywgbmFtZSlcbiAgICAgIH1cbiAgICB9LCBhY3F1aXJlVGltZW91dClcbiAgfVxuXG4gIC8vIE1ETiBhcnRpY2xlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTG9ja01hbmFnZXIvcmVxdWVzdFxuXG4gIC8vIFdyYXBwaW5nIG5hdmlnYXRvci5sb2Nrcy5yZXF1ZXN0KCkgd2l0aCBhIHBsYWluIFByb21pc2UgaXMgZG9uZSBhcyBzb21lXG4gIC8vIGxpYnJhcmllcyBsaWtlIHpvbmUuanMgcGF0Y2ggdGhlIFByb21pc2Ugb2JqZWN0IHRvIHRyYWNrIHRoZSBleGVjdXRpb25cbiAgLy8gY29udGV4dC4gSG93ZXZlciwgaXQgYXBwZWFycyB0aGF0IG1vc3QgYnJvd3NlcnMgdXNlIGFuIGludGVybmFsIHByb21pc2VcbiAgLy8gaW1wbGVtZW50YXRpb24gd2hlbiB1c2luZyB0aGUgbmF2aWdhdG9yLmxvY2tzLnJlcXVlc3QoKSBBUEkgY2F1c2luZyB0aGVtXG4gIC8vIHRvIGxvc2UgY29udGV4dCBhbmQgZW1pdCBjb25mdXNpbmcgbG9nIG1lc3NhZ2VzIG9yIGJyZWFrIGNlcnRhaW4gZmVhdHVyZXMuXG4gIC8vIFRoaXMgd3JhcHBpbmcgaXMgYmVsaWV2ZWQgdG8gaGVscCB6b25lLmpzIHRyYWNrIHRoZSBleGVjdXRpb24gY29udGV4dFxuICAvLyBiZXR0ZXIuXG4gIHJldHVybiBhd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+XG4gICAgZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubG9ja3MucmVxdWVzdChcbiAgICAgIG5hbWUsXG4gICAgICBhY3F1aXJlVGltZW91dCA9PT0gMFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIG1vZGU6ICdleGNsdXNpdmUnLFxuICAgICAgICAgICAgaWZBdmFpbGFibGU6IHRydWUsXG4gICAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIG1vZGU6ICdleGNsdXNpdmUnLFxuICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgIH0sXG4gICAgICBhc3luYyAobG9jaykgPT4ge1xuICAgICAgICBpZiAobG9jaykge1xuICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBhY3F1aXJlZCcsIG5hbWUsIGxvY2submFtZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKClcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogcmVsZWFzZWQnLCBuYW1lLCBsb2NrLm5hbWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhY3F1aXJlVGltZW91dCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogbm90IGltbWVkaWF0ZWx5IGF2YWlsYWJsZScsIG5hbWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcihcbiAgICAgICAgICAgICAgYEFjcXVpcmluZyBhbiBleGNsdXNpdmUgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIGxvY2sgXCIke25hbWV9XCIgaW1tZWRpYXRlbHkgZmFpbGVkYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubG9ja3MucXVlcnkoKVxuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAnQHN1cGFiYXNlL2dvdHJ1ZS1qczogTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHN0YXRlJyxcbiAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgJyAgJylcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICdAc3VwYWJhc2UvZ290cnVlLWpzOiBFcnJvciB3aGVuIHF1ZXJ5aW5nIE5hdmlnYXRvciBMb2NrTWFuYWdlciBzdGF0ZScsXG4gICAgICAgICAgICAgICAgICBlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEJyb3dzZXIgaXMgbm90IGZvbGxvd2luZyB0aGUgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHNwZWMsIGl0XG4gICAgICAgICAgICAvLyByZXR1cm5lZCBhIG51bGwgbG9jayB3aGVuIHdlIGRpZG4ndCB1c2UgaWZBdmFpbGFibGUuIFNvIHdlIGNhblxuICAgICAgICAgICAgLy8gcHJldGVuZCB0aGUgbG9jayBpcyBhY3F1aXJlZCBpbiB0aGUgbmFtZSBvZiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAvLyBhbmQgdXNlciBleHBlcmllbmNlIGFuZCBqdXN0IHJ1biB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICdAc3VwYWJhc2UvZ290cnVlLWpzOiBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgcmV0dXJuZWQgYSBudWxsIGxvY2sgd2hlbiB1c2luZyAjcmVxdWVzdCB3aXRob3V0IGlmQXZhaWxhYmxlIHNldCB0byB0cnVlLCBpdCBhcHBlYXJzIHRoaXMgYnJvd3NlciBpcyBub3QgZm9sbG93aW5nIHRoZSBMb2NrTWFuYWdlciBzcGVjIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Mb2NrTWFuYWdlci9yZXF1ZXN0J1xuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcbiAgKVxufVxuXG5jb25zdCBQUk9DRVNTX0xPQ0tTOiB7IFtuYW1lOiBzdHJpbmddOiBQcm9taXNlPGFueT4gfSA9IHt9XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIGdsb2JhbCBleGNsdXNpdmUgbG9jayB0aGF0IHdvcmtzIG9ubHkgaW4gdGhlIGN1cnJlbnQgcHJvY2Vzcy5cbiAqIFVzZWZ1bCBmb3IgZW52aXJvbm1lbnRzIGxpa2UgUmVhY3QgTmF0aXZlIG9yIG90aGVyIG5vbi1icm93c2VyXG4gKiBzaW5nbGUtcHJvY2VzcyAoaS5lLiBubyBjb25jZXB0IG9mIFwidGFic1wiKSBlbnZpcm9ubWVudHMuXG4gKlxuICogVXNlIHtAbGluayAjbmF2aWdhdG9yTG9ja30gaW4gYnJvd3NlciBlbnZpcm9ubWVudHMuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgbG9jayB0byBiZSBhY3F1aXJlZC5cbiAqIEBwYXJhbSBhY3F1aXJlVGltZW91dCBJZiBuZWdhdGl2ZSwgbm8gdGltZW91dC4gSWYgMCBhbiBlcnJvciBpcyB0aHJvd24gaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICB0aGUgbG9jayBjYW4ndCBiZSBhY3F1aXJlZCB3aXRob3V0IHdhaXRpbmcuIElmIHBvc2l0aXZlLCB0aGUgbG9jayBhY3F1aXJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCB0aW1lIG91dCBhZnRlciBzbyBtYW55IG1pbGxpc2Vjb25kcy4gQW4gZXJyb3IgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICBhIHRpbWVvdXQgaWYgaXQgaGFzIGBpc0FjcXVpcmVUaW1lb3V0YCBzZXQgdG8gdHJ1ZS5cbiAqIEBwYXJhbSBmbiBUaGUgb3BlcmF0aW9uIHRvIHJ1biBvbmNlIHRoZSBsb2NrIGlzIGFjcXVpcmVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0xvY2s8Uj4oXG4gIG5hbWU6IHN0cmluZyxcbiAgYWNxdWlyZVRpbWVvdXQ6IG51bWJlcixcbiAgZm46ICgpID0+IFByb21pc2U8Uj5cbik6IFByb21pc2U8Uj4ge1xuICBjb25zdCBwcmV2aW91c09wZXJhdGlvbiA9IFBST0NFU1NfTE9DS1NbbmFtZV0gPz8gUHJvbWlzZS5yZXNvbHZlKClcblxuICBjb25zdCBjdXJyZW50T3BlcmF0aW9uID0gUHJvbWlzZS5yYWNlKFxuICAgIFtcbiAgICAgIHByZXZpb3VzT3BlcmF0aW9uLmNhdGNoKCgpID0+IHtcbiAgICAgICAgLy8gaWdub3JlIGVycm9yIG9mIHByZXZpb3VzIG9wZXJhdGlvbiB0aGF0IHdlJ3JlIHdhaXRpbmcgdG8gZmluaXNoXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9KSxcbiAgICAgIGFjcXVpcmVUaW1lb3V0ID49IDBcbiAgICAgICAgPyBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIG5ldyBQcm9jZXNzTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IoXG4gICAgICAgICAgICAgICAgICBgQWNxdXJpbmcgcHJvY2VzcyBsb2NrIHdpdGggbmFtZSBcIiR7bmFtZX1cIiB0aW1lZCBvdXRgXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9LCBhY3F1aXJlVGltZW91dClcbiAgICAgICAgICB9KVxuICAgICAgICA6IG51bGwsXG4gICAgXS5maWx0ZXIoKHgpID0+IHgpXG4gIClcbiAgICAuY2F0Y2goKGU6IGFueSkgPT4ge1xuICAgICAgaWYgKGUgJiYgZS5pc0FjcXVpcmVUaW1lb3V0KSB7XG4gICAgICAgIHRocm93IGVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9KVxuICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgIC8vIHByZXZpb3VzIG9wZXJhdGlvbnMgZmluaXNoZWQgYW5kIHdlIGRpZG4ndCBnZXQgYSByYWNlIG9uIHRoZSBhY3F1aXJlXG4gICAgICAvLyB0aW1lb3V0LCBzbyB0aGUgY3VycmVudCBvcGVyYXRpb24gY2FuIGZpbmFsbHkgc3RhcnRcbiAgICAgIHJldHVybiBhd2FpdCBmbigpXG4gICAgfSlcblxuICBQUk9DRVNTX0xPQ0tTW25hbWVdID0gY3VycmVudE9wZXJhdGlvbi5jYXRjaChhc3luYyAoZTogYW55KSA9PiB7XG4gICAgaWYgKGUgJiYgZS5pc0FjcXVpcmVUaW1lb3V0KSB7XG4gICAgICAvLyBpZiB0aGUgY3VycmVudCBvcGVyYXRpb24gdGltZWQgb3V0LCBpdCBkb2Vzbid0IG1lYW4gdGhhdCB0aGUgcHJldmlvdXNcbiAgICAgIC8vIG9wZXJhdGlvbiBmaW5pc2hlZCwgc28gd2UgbmVlZCBjb250bnVlIHdhaXRpbmcgZm9yIGl0IHRvIGZpbmlzaFxuICAgICAgYXdhaXQgcHJldmlvdXNPcGVyYXRpb25cblxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICB0aHJvdyBlXG4gIH0pXG5cbiAgLy8gZmluYWxseSB3YWl0IGZvciB0aGUgY3VycmVudCBvcGVyYXRpb24gdG8gZmluaXNoIHN1Y2Nlc3NmdWxseSwgd2l0aCBhblxuICAvLyBlcnJvciBvciB3aXRoIGFuIGFjcXVpcmUgdGltZW91dCBlcnJvclxuICByZXR1cm4gYXdhaXQgY3VycmVudE9wZXJhdGlvblxufVxuIiwgImltcG9ydCBHb1RydWVBZG1pbkFwaSBmcm9tICcuL0dvVHJ1ZUFkbWluQXBpJ1xuaW1wb3J0IHsgREVGQVVMVF9IRUFERVJTLCBFWFBJUllfTUFSR0lOLCBHT1RSVUVfVVJMLCBTVE9SQUdFX0tFWSB9IGZyb20gJy4vbGliL2NvbnN0YW50cydcbmltcG9ydCB7XG4gIEF1dGhFcnJvcixcbiAgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yLFxuICBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IsXG4gIEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcixcbiAgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IsXG4gIEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yLFxuICBBdXRoVW5rbm93bkVycm9yLFxuICBpc0F1dGhBcGlFcnJvcixcbiAgaXNBdXRoRXJyb3IsXG4gIGlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IsXG4gIGlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IsXG4gIGlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yLFxufSBmcm9tICcuL2xpYi9lcnJvcnMnXG5pbXBvcnQge1xuICBGZXRjaCxcbiAgX3JlcXVlc3QsXG4gIF9zZXNzaW9uUmVzcG9uc2UsXG4gIF9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZCxcbiAgX3VzZXJSZXNwb25zZSxcbiAgX3Nzb1Jlc3BvbnNlLFxufSBmcm9tICcuL2xpYi9mZXRjaCdcbmltcG9ydCB7XG4gIGRlY29kZUpXVFBheWxvYWQsXG4gIERlZmVycmVkLFxuICBnZXRJdGVtQXN5bmMsXG4gIGlzQnJvd3NlcixcbiAgcmVtb3ZlSXRlbUFzeW5jLFxuICByZXNvbHZlRmV0Y2gsXG4gIHNldEl0ZW1Bc3luYyxcbiAgdXVpZCxcbiAgcmV0cnlhYmxlLFxuICBzbGVlcCxcbiAgc3VwcG9ydHNMb2NhbFN0b3JhZ2UsXG4gIHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwsXG4gIGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QsXG59IGZyb20gJy4vbGliL2hlbHBlcnMnXG5pbXBvcnQgeyBsb2NhbFN0b3JhZ2VBZGFwdGVyLCBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyIH0gZnJvbSAnLi9saWIvbG9jYWwtc3RvcmFnZSdcbmltcG9ydCB7IHBvbHlmaWxsR2xvYmFsVGhpcyB9IGZyb20gJy4vbGliL3BvbHlmaWxscydcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL2xpYi92ZXJzaW9uJ1xuaW1wb3J0IHsgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IsIG5hdmlnYXRvckxvY2sgfSBmcm9tICcuL2xpYi9sb2NrcydcblxuaW1wb3J0IHR5cGUge1xuICBBdXRoQ2hhbmdlRXZlbnQsXG4gIEF1dGhSZXNwb25zZSxcbiAgQXV0aFJlc3BvbnNlUGFzc3dvcmQsXG4gIEF1dGhUb2tlblJlc3BvbnNlLFxuICBBdXRoVG9rZW5SZXNwb25zZVBhc3N3b3JkLFxuICBBdXRoT3RwUmVzcG9uc2UsXG4gIENhbGxSZWZyZXNoVG9rZW5SZXN1bHQsXG4gIEdvVHJ1ZUNsaWVudE9wdGlvbnMsXG4gIEluaXRpYWxpemVSZXN1bHQsXG4gIE9BdXRoUmVzcG9uc2UsXG4gIFNTT1Jlc3BvbnNlLFxuICBQcm92aWRlcixcbiAgU2Vzc2lvbixcbiAgU2lnbkluV2l0aElkVG9rZW5DcmVkZW50aWFscyxcbiAgU2lnbkluV2l0aE9BdXRoQ3JlZGVudGlhbHMsXG4gIFNpZ25JbldpdGhQYXNzd29yZENyZWRlbnRpYWxzLFxuICBTaWduSW5XaXRoUGFzc3dvcmRsZXNzQ3JlZGVudGlhbHMsXG4gIFNpZ25VcFdpdGhQYXNzd29yZENyZWRlbnRpYWxzLFxuICBTaWduSW5XaXRoU1NPLFxuICBTaWduT3V0LFxuICBTdWJzY3JpcHRpb24sXG4gIFN1cHBvcnRlZFN0b3JhZ2UsXG4gIFVzZXIsXG4gIFVzZXJBdHRyaWJ1dGVzLFxuICBVc2VyUmVzcG9uc2UsXG4gIFZlcmlmeU90cFBhcmFtcyxcbiAgR29UcnVlTUZBQXBpLFxuICBNRkFFbnJvbGxQYXJhbXMsXG4gIEF1dGhNRkFFbnJvbGxSZXNwb25zZSxcbiAgTUZBQ2hhbGxlbmdlUGFyYW1zLFxuICBBdXRoTUZBQ2hhbGxlbmdlUmVzcG9uc2UsXG4gIE1GQVVuZW5yb2xsUGFyYW1zLFxuICBBdXRoTUZBVW5lbnJvbGxSZXNwb25zZSxcbiAgTUZBVmVyaWZ5UGFyYW1zLFxuICBBdXRoTUZBVmVyaWZ5UmVzcG9uc2UsXG4gIEF1dGhNRkFMaXN0RmFjdG9yc1Jlc3BvbnNlLFxuICBBTVJFbnRyeSxcbiAgQXV0aE1GQUdldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbFJlc3BvbnNlLFxuICBBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWxzLFxuICBGYWN0b3IsXG4gIE1GQUNoYWxsZW5nZUFuZFZlcmlmeVBhcmFtcyxcbiAgUmVzZW5kUGFyYW1zLFxuICBBdXRoRmxvd1R5cGUsXG4gIExvY2tGdW5jLFxuICBVc2VySWRlbnRpdHksXG4gIFNpZ25JbkFub255bW91c2x5Q3JlZGVudGlhbHMsXG59IGZyb20gJy4vbGliL3R5cGVzJ1xuaW1wb3J0IHtcbiAgTUZBRW5yb2xsVE9UUFBhcmFtcyxcbiAgTUZBRW5yb2xsUGhvbmVQYXJhbXMsXG4gIEF1dGhNRkFFbnJvbGxUT1RQUmVzcG9uc2UsXG4gIEF1dGhNRkFFbnJvbGxQaG9uZVJlc3BvbnNlLFxufSBmcm9tICcuL2xpYi9pbnRlcm5hbC10eXBlcydcblxucG9seWZpbGxHbG9iYWxUaGlzKCkgLy8gTWFrZSBcImdsb2JhbFRoaXNcIiBhdmFpbGFibGVcblxuY29uc3QgREVGQVVMVF9PUFRJT05TOiBPbWl0PFJlcXVpcmVkPEdvVHJ1ZUNsaWVudE9wdGlvbnM+LCAnZmV0Y2gnIHwgJ3N0b3JhZ2UnIHwgJ2xvY2snPiA9IHtcbiAgdXJsOiBHT1RSVUVfVVJMLFxuICBzdG9yYWdlS2V5OiBTVE9SQUdFX0tFWSxcbiAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcbiAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gIGRldGVjdFNlc3Npb25JblVybDogdHJ1ZSxcbiAgaGVhZGVyczogREVGQVVMVF9IRUFERVJTLFxuICBmbG93VHlwZTogJ2ltcGxpY2l0JyxcbiAgZGVidWc6IGZhbHNlLFxuICBoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyOiBmYWxzZSxcbn1cblxuLyoqIEN1cnJlbnQgc2Vzc2lvbiB3aWxsIGJlIGNoZWNrZWQgZm9yIHJlZnJlc2ggYXQgdGhpcyBpbnRlcnZhbC4gKi9cbmNvbnN0IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OID0gMzAgKiAxMDAwXG5cbi8qKlxuICogQSB0b2tlbiByZWZyZXNoIHdpbGwgYmUgYXR0ZW1wdGVkIHRoaXMgbWFueSB0aWNrcyBiZWZvcmUgdGhlIGN1cnJlbnQgc2Vzc2lvbiBleHBpcmVzLiAqL1xuY29uc3QgQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEID0gM1xuXG5hc3luYyBmdW5jdGlvbiBsb2NrTm9PcDxSPihuYW1lOiBzdHJpbmcsIGFjcXVpcmVUaW1lb3V0OiBudW1iZXIsIGZuOiAoKSA9PiBQcm9taXNlPFI+KTogUHJvbWlzZTxSPiB7XG4gIHJldHVybiBhd2FpdCBmbigpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdvVHJ1ZUNsaWVudCB7XG4gIHByaXZhdGUgc3RhdGljIG5leHRJbnN0YW5jZUlEID0gMFxuXG4gIHByaXZhdGUgaW5zdGFuY2VJRDogbnVtYmVyXG5cbiAgLyoqXG4gICAqIE5hbWVzcGFjZSBmb3IgdGhlIEdvVHJ1ZSBhZG1pbiBtZXRob2RzLlxuICAgKiBUaGVzZSBtZXRob2RzIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gYSB0cnVzdGVkIHNlcnZlci1zaWRlIGVudmlyb25tZW50LlxuICAgKi9cbiAgYWRtaW46IEdvVHJ1ZUFkbWluQXBpXG4gIC8qKlxuICAgKiBOYW1lc3BhY2UgZm9yIHRoZSBNRkEgbWV0aG9kcy5cbiAgICovXG4gIG1mYTogR29UcnVlTUZBQXBpXG4gIC8qKlxuICAgKiBUaGUgc3RvcmFnZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGUgdmFsdWVzIHNhdmVkIGluIGxvY2FsU3RvcmFnZVxuICAgKi9cbiAgcHJvdGVjdGVkIHN0b3JhZ2VLZXk6IHN0cmluZ1xuXG4gIHByb3RlY3RlZCBmbG93VHlwZTogQXV0aEZsb3dUeXBlXG5cbiAgcHJvdGVjdGVkIGF1dG9SZWZyZXNoVG9rZW46IGJvb2xlYW5cbiAgcHJvdGVjdGVkIHBlcnNpc3RTZXNzaW9uOiBib29sZWFuXG4gIHByb3RlY3RlZCBzdG9yYWdlOiBTdXBwb3J0ZWRTdG9yYWdlXG4gIHByb3RlY3RlZCBtZW1vcnlTdG9yYWdlOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9IHwgbnVsbCA9IG51bGxcbiAgcHJvdGVjdGVkIHN0YXRlQ2hhbmdlRW1pdHRlcnM6IE1hcDxzdHJpbmcsIFN1YnNjcmlwdGlvbj4gPSBuZXcgTWFwKClcbiAgcHJvdGVjdGVkIGF1dG9SZWZyZXNoVGlja2VyOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRJbnRlcnZhbD4gfCBudWxsID0gbnVsbFxuICBwcm90ZWN0ZWQgdmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjazogKCgpID0+IFByb21pc2U8YW55PikgfCBudWxsID0gbnVsbFxuICBwcm90ZWN0ZWQgcmVmcmVzaGluZ0RlZmVycmVkOiBEZWZlcnJlZDxDYWxsUmVmcmVzaFRva2VuUmVzdWx0PiB8IG51bGwgPSBudWxsXG4gIC8qKlxuICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgYXN5bmMgY2xpZW50IGluaXRpYWxpemF0aW9uLlxuICAgKiBXaGVuIG51bGwgb3Igbm90IHlldCByZXNvbHZlZCB0aGUgYXV0aCBzdGF0ZSBpcyBgdW5rbm93bmBcbiAgICogT25jZSByZXNvbHZlZCB0aGUgdGhlIGF1dGggc3RhdGUgaXMga25vd24gYW5kIGl0J3Mgc2F2ZSB0byBjYWxsIGFueSBmdXJ0aGVyIGNsaWVudCBtZXRob2RzLlxuICAgKiBLZWVwIGV4dHJhIGNhcmUgdG8gbmV2ZXIgcmVqZWN0IG9yIHRocm93IHVuY2F1Z2h0IGVycm9yc1xuICAgKi9cbiAgcHJvdGVjdGVkIGluaXRpYWxpemVQcm9taXNlOiBQcm9taXNlPEluaXRpYWxpemVSZXN1bHQ+IHwgbnVsbCA9IG51bGxcbiAgcHJvdGVjdGVkIGRldGVjdFNlc3Npb25JblVybCA9IHRydWVcbiAgcHJvdGVjdGVkIHVybDogc3RyaW5nXG4gIHByb3RlY3RlZCBoZWFkZXJzOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gIH1cbiAgcHJvdGVjdGVkIGhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIgPSBmYWxzZVxuICBwcm90ZWN0ZWQgc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IGZhbHNlXG4gIHByb3RlY3RlZCBmZXRjaDogRmV0Y2hcbiAgcHJvdGVjdGVkIGxvY2s6IExvY2tGdW5jXG4gIHByb3RlY3RlZCBsb2NrQWNxdWlyZWQgPSBmYWxzZVxuICBwcm90ZWN0ZWQgcGVuZGluZ0luTG9jazogUHJvbWlzZTxhbnk+W10gPSBbXVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGJyb2FkY2FzdCBzdGF0ZSBjaGFuZ2UgZXZlbnRzIHRvIG90aGVyIHRhYnMgbGlzdGVuaW5nLlxuICAgKi9cbiAgcHJvdGVjdGVkIGJyb2FkY2FzdENoYW5uZWw6IEJyb2FkY2FzdENoYW5uZWwgfCBudWxsID0gbnVsbFxuXG4gIHByb3RlY3RlZCBsb2dEZWJ1Z01lc3NhZ2VzOiBib29sZWFuXG4gIHByb3RlY3RlZCBsb2dnZXI6IChtZXNzYWdlOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkID0gY29uc29sZS5sb2dcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGNsaWVudCBmb3IgdXNlIGluIHRoZSBicm93c2VyLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9uczogR29UcnVlQ2xpZW50T3B0aW9ucykge1xuICAgIHRoaXMuaW5zdGFuY2VJRCA9IEdvVHJ1ZUNsaWVudC5uZXh0SW5zdGFuY2VJRFxuICAgIEdvVHJ1ZUNsaWVudC5uZXh0SW5zdGFuY2VJRCArPSAxXG5cbiAgICBpZiAodGhpcy5pbnN0YW5jZUlEID4gMCAmJiBpc0Jyb3dzZXIoKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnTXVsdGlwbGUgR29UcnVlQ2xpZW50IGluc3RhbmNlcyBkZXRlY3RlZCBpbiB0aGUgc2FtZSBicm93c2VyIGNvbnRleHQuIEl0IGlzIG5vdCBhbiBlcnJvciwgYnV0IHRoaXMgc2hvdWxkIGJlIGF2b2lkZWQgYXMgaXQgbWF5IHByb2R1Y2UgdW5kZWZpbmVkIGJlaGF2aW9yIHdoZW4gdXNlZCBjb25jdXJyZW50bHkgdW5kZXIgdGhlIHNhbWUgc3RvcmFnZSBrZXkuJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHNldHRpbmdzID0geyAuLi5ERUZBVUxUX09QVElPTlMsIC4uLm9wdGlvbnMgfVxuXG4gICAgdGhpcy5sb2dEZWJ1Z01lc3NhZ2VzID0gISFzZXR0aW5ncy5kZWJ1Z1xuICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuZGVidWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMubG9nZ2VyID0gc2V0dGluZ3MuZGVidWdcbiAgICB9XG5cbiAgICB0aGlzLnBlcnNpc3RTZXNzaW9uID0gc2V0dGluZ3MucGVyc2lzdFNlc3Npb25cbiAgICB0aGlzLnN0b3JhZ2VLZXkgPSBzZXR0aW5ncy5zdG9yYWdlS2V5XG4gICAgdGhpcy5hdXRvUmVmcmVzaFRva2VuID0gc2V0dGluZ3MuYXV0b1JlZnJlc2hUb2tlblxuICAgIHRoaXMuYWRtaW4gPSBuZXcgR29UcnVlQWRtaW5BcGkoe1xuICAgICAgdXJsOiBzZXR0aW5ncy51cmwsXG4gICAgICBoZWFkZXJzOiBzZXR0aW5ncy5oZWFkZXJzLFxuICAgICAgZmV0Y2g6IHNldHRpbmdzLmZldGNoLFxuICAgIH0pXG5cbiAgICB0aGlzLnVybCA9IHNldHRpbmdzLnVybFxuICAgIHRoaXMuaGVhZGVycyA9IHNldHRpbmdzLmhlYWRlcnNcbiAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKHNldHRpbmdzLmZldGNoKVxuICAgIHRoaXMubG9jayA9IHNldHRpbmdzLmxvY2sgfHwgbG9ja05vT3BcbiAgICB0aGlzLmRldGVjdFNlc3Npb25JblVybCA9IHNldHRpbmdzLmRldGVjdFNlc3Npb25JblVybFxuICAgIHRoaXMuZmxvd1R5cGUgPSBzZXR0aW5ncy5mbG93VHlwZVxuICAgIHRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciA9IHNldHRpbmdzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXJcblxuICAgIGlmIChzZXR0aW5ncy5sb2NrKSB7XG4gICAgICB0aGlzLmxvY2sgPSBzZXR0aW5ncy5sb2NrXG4gICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIoKSAmJiBnbG9iYWxUaGlzPy5uYXZpZ2F0b3I/LmxvY2tzKSB7XG4gICAgICB0aGlzLmxvY2sgPSBuYXZpZ2F0b3JMb2NrXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9jayA9IGxvY2tOb09wXG4gICAgfVxuXG4gICAgdGhpcy5tZmEgPSB7XG4gICAgICB2ZXJpZnk6IHRoaXMuX3ZlcmlmeS5iaW5kKHRoaXMpLFxuICAgICAgZW5yb2xsOiB0aGlzLl9lbnJvbGwuYmluZCh0aGlzKSxcbiAgICAgIHVuZW5yb2xsOiB0aGlzLl91bmVucm9sbC5iaW5kKHRoaXMpLFxuICAgICAgY2hhbGxlbmdlOiB0aGlzLl9jaGFsbGVuZ2UuYmluZCh0aGlzKSxcbiAgICAgIGxpc3RGYWN0b3JzOiB0aGlzLl9saXN0RmFjdG9ycy5iaW5kKHRoaXMpLFxuICAgICAgY2hhbGxlbmdlQW5kVmVyaWZ5OiB0aGlzLl9jaGFsbGVuZ2VBbmRWZXJpZnkuYmluZCh0aGlzKSxcbiAgICAgIGdldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbDogdGhpcy5fZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsLmJpbmQodGhpcyksXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGVyc2lzdFNlc3Npb24pIHtcbiAgICAgIGlmIChzZXR0aW5ncy5zdG9yYWdlKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHNldHRpbmdzLnN0b3JhZ2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdXBwb3J0c0xvY2FsU3RvcmFnZSgpKSB7XG4gICAgICAgICAgdGhpcy5zdG9yYWdlID0gbG9jYWxTdG9yYWdlQWRhcHRlclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubWVtb3J5U3RvcmFnZSA9IHt9XG4gICAgICAgICAgdGhpcy5zdG9yYWdlID0gbWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlcih0aGlzLm1lbW9yeVN0b3JhZ2UpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0ge31cbiAgICAgIHRoaXMuc3RvcmFnZSA9IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIodGhpcy5tZW1vcnlTdG9yYWdlKVxuICAgIH1cblxuICAgIGlmIChpc0Jyb3dzZXIoKSAmJiBnbG9iYWxUaGlzLkJyb2FkY2FzdENoYW5uZWwgJiYgdGhpcy5wZXJzaXN0U2Vzc2lvbiAmJiB0aGlzLnN0b3JhZ2VLZXkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCA9IG5ldyBnbG9iYWxUaGlzLkJyb2FkY2FzdENoYW5uZWwodGhpcy5zdG9yYWdlS2V5KVxuICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ0ZhaWxlZCB0byBjcmVhdGUgYSBuZXcgQnJvYWRjYXN0Q2hhbm5lbCwgbXVsdGktdGFiIHN0YXRlIGNoYW5nZXMgd2lsbCBub3QgYmUgYXZhaWxhYmxlJyxcbiAgICAgICAgICBlXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsPy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdyZWNlaXZlZCBicm9hZGNhc3Qgbm90aWZpY2F0aW9uIGZyb20gb3RoZXIgdGFiIG9yIGNsaWVudCcsIGV2ZW50KVxuXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKGV2ZW50LmRhdGEuZXZlbnQsIGV2ZW50LmRhdGEuc2Vzc2lvbiwgZmFsc2UpIC8vIGJyb2FkY2FzdCA9IGZhbHNlIHNvIHdlIGRvbid0IGdldCBhbiBlbmRsZXNzIGxvb3Agb2YgbWVzc2FnZXNcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXplKClcbiAgfVxuXG4gIHByaXZhdGUgX2RlYnVnKC4uLmFyZ3M6IGFueVtdKTogR29UcnVlQ2xpZW50IHtcbiAgICBpZiAodGhpcy5sb2dEZWJ1Z01lc3NhZ2VzKSB7XG4gICAgICB0aGlzLmxvZ2dlcihcbiAgICAgICAgYEdvVHJ1ZUNsaWVudEAke3RoaXMuaW5zdGFuY2VJRH0gKCR7dmVyc2lvbn0pICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfWAsXG4gICAgICAgIC4uLmFyZ3NcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjbGllbnQgc2Vzc2lvbiBlaXRoZXIgZnJvbSB0aGUgdXJsIG9yIGZyb20gc3RvcmFnZS5cbiAgICogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiBpbnN0YW50aWF0aW5nIHRoZSBjbGllbnQsIGJ1dCBzaG91bGQgYWxzbyBiZSBjYWxsZWRcbiAgICogbWFudWFsbHkgd2hlbiBjaGVja2luZyBmb3IgYW4gZXJyb3IgZnJvbSBhbiBhdXRoIHJlZGlyZWN0IChvYXV0aCwgbWFnaWNsaW5rLCBwYXNzd29yZCByZWNvdmVyeSwgZXRjKS5cbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTxJbml0aWFsaXplUmVzdWx0PiB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZVByb21pc2UpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXplUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2luaXRpYWxpemUoKVxuICAgICAgfSlcbiAgICB9KSgpXG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIElNUE9SVEFOVDpcbiAgICogMS4gTmV2ZXIgdGhyb3cgaW4gdGhpcyBtZXRob2QsIGFzIGl0IGlzIGNhbGxlZCBmcm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgKiAyLiBOZXZlciByZXR1cm4gYSBzZXNzaW9uIGZyb20gdGhpcyBtZXRob2QgYXMgaXQgd291bGQgYmUgY2FjaGVkIG92ZXJcbiAgICogICAgdGhlIHdob2xlIGxpZmV0aW1lIG9mIHRoZSBjbGllbnRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2luaXRpYWxpemUoKTogUHJvbWlzZTxJbml0aWFsaXplUmVzdWx0PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwod2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgICBsZXQgY2FsbGJhY2tVcmxUeXBlID0gJ25vbmUnXG4gICAgICBpZiAodGhpcy5faXNJbXBsaWNpdEdyYW50Q2FsbGJhY2socGFyYW1zKSkge1xuICAgICAgICBjYWxsYmFja1VybFR5cGUgPSAnaW1wbGljaXQnXG4gICAgICB9IGVsc2UgaWYgKGF3YWl0IHRoaXMuX2lzUEtDRUNhbGxiYWNrKHBhcmFtcykpIHtcbiAgICAgICAgY2FsbGJhY2tVcmxUeXBlID0gJ3BrY2UnXG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQXR0ZW1wdCB0byBnZXQgdGhlIHNlc3Npb24gZnJvbSB0aGUgVVJMIG9ubHkgaWYgdGhlc2UgY29uZGl0aW9ucyBhcmUgZnVsZmlsbGVkXG4gICAgICAgKlxuICAgICAgICogTm90ZTogSWYgdGhlIFVSTCBpc24ndCBvbmUgb2YgdGhlIGNhbGxiYWNrIHVybCB0eXBlcyAoaW1wbGljaXQgb3IgcGtjZSksXG4gICAgICAgKiB0aGVuIHRoZXJlIGNvdWxkIGJlIGFuIGV4aXN0aW5nIHNlc3Npb24gc28gd2UgZG9uJ3Qgd2FudCB0byBwcmVtYXR1cmVseSByZW1vdmUgaXRcbiAgICAgICAqL1xuICAgICAgaWYgKGlzQnJvd3NlcigpICYmIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsICYmIGNhbGxiYWNrVXJsVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFNlc3Npb25Gcm9tVVJMKHBhcmFtcywgY2FsbGJhY2tVcmxUeXBlKVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZXJyb3IgZGV0ZWN0aW5nIHNlc3Npb24gZnJvbSBVUkwnLCBlcnJvcilcblxuICAgICAgICAgIGlmIChpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IGVycm9yLmRldGFpbHM/LmNvZGVcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZXJyb3JDb2RlID09PSAnaWRlbnRpdHlfYWxyZWFkeV9leGlzdHMnIHx8XG4gICAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gJ2lkZW50aXR5X25vdF9mb3VuZCcgfHxcbiAgICAgICAgICAgICAgZXJyb3JDb2RlID09PSAnc2luZ2xlX2lkZW50aXR5X25vdF9kZWxldGFibGUnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3IgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGZhaWxlZCBsb2dpbiBhdHRlbXB0IHZpYSB1cmwsXG4gICAgICAgICAgLy8gcmVtb3ZlIG9sZCBzZXNzaW9uIGFzIGluIHZlcmlmeU90cCwgc2lnblVwIGFuZCBzaWduSW5XaXRoKlxuICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKVxuXG4gICAgICAgICAgcmV0dXJuIHsgZXJyb3IgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBzZXNzaW9uLCByZWRpcmVjdFR5cGUgfSA9IGRhdGFcblxuICAgICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgICAnI19pbml0aWFsaXplKCknLFxuICAgICAgICAgICdkZXRlY3RlZCBzZXNzaW9uIGluIFVSTCcsXG4gICAgICAgICAgc2Vzc2lvbixcbiAgICAgICAgICAncmVkaXJlY3QgdHlwZScsXG4gICAgICAgICAgcmVkaXJlY3RUeXBlXG4gICAgICAgIClcblxuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKVxuXG4gICAgICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmIChyZWRpcmVjdFR5cGUgPT09ICdyZWNvdmVyeScpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdQQVNTV09SRF9SRUNPVkVSWScsIHNlc3Npb24pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBzZXNzaW9uKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgMClcblxuICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9XG4gICAgICB9XG4gICAgICAvLyBubyBsb2dpbiBhdHRlbXB0IHZpYSBjYWxsYmFjayB1cmwgdHJ5IHRvIHJlY292ZXIgc2Vzc2lvbiBmcm9tIHN0b3JhZ2VcbiAgICAgIGF3YWl0IHRoaXMuX3JlY292ZXJBbmRSZWZyZXNoKClcbiAgICAgIHJldHVybiB7IGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBuZXcgQXV0aFVua25vd25FcnJvcignVW5leHBlY3RlZCBlcnJvciBkdXJpbmcgaW5pdGlhbGl6YXRpb24nLCBlcnJvciksXG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IHRoaXMuX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKVxuICAgICAgdGhpcy5fZGVidWcoJyNfaW5pdGlhbGl6ZSgpJywgJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYW5vbnltb3VzIHVzZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgc2Vzc2lvbiB3aGVyZSB0aGUgaXNfYW5vbnltb3VzIGNsYWltIGluIHRoZSBhY2Nlc3MgdG9rZW4gSldUIHNldCB0byB0cnVlXG4gICAqL1xuICBhc3luYyBzaWduSW5Bbm9ueW1vdXNseShjcmVkZW50aWFscz86IFNpZ25JbkFub255bW91c2x5Q3JlZGVudGlhbHMpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIGRhdGE6IGNyZWRlbnRpYWxzPy5vcHRpb25zPy5kYXRhID8/IHt9LFxuICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IGNyZWRlbnRpYWxzPy5vcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgfSxcbiAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICB9KVxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzXG5cbiAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlc3Npb246IFNlc3Npb24gfCBudWxsID0gZGF0YS5zZXNzaW9uXG4gICAgICBjb25zdCB1c2VyOiBVc2VyIHwgbnVsbCA9IGRhdGEudXNlclxuXG4gICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbilcbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgKlxuICAgKiBCZSBhd2FyZSB0aGF0IGlmIGEgdXNlciBhY2NvdW50IGV4aXN0cyBpbiB0aGUgc3lzdGVtIHlvdSBtYXkgZ2V0IGJhY2sgYW5cbiAgICogZXJyb3IgbWVzc2FnZSB0aGF0IGF0dGVtcHRzIHRvIGhpZGUgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIHRoZSB1c2VyLlxuICAgKiBUaGlzIG1ldGhvZCBoYXMgc3VwcG9ydCBmb3IgUEtDRSB2aWEgZW1haWwgc2lnbnVwcy4gVGhlIFBLQ0UgZmxvdyBjYW5ub3QgYmUgdXNlZCB3aGVuIGF1dG9jb25maXJtIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgbG9nZ2VkLWluIHNlc3Npb24gaWYgdGhlIHNlcnZlciBoYXMgXCJhdXRvY29uZmlybVwiIE9OXG4gICAqIEByZXR1cm5zIEEgdXNlciBpZiB0aGUgc2VydmVyIGhhcyBcImF1dG9jb25maXJtXCIgT0ZGXG4gICAqL1xuICBhc3luYyBzaWduVXAoY3JlZGVudGlhbHM6IFNpZ25VcFdpdGhQYXNzd29yZENyZWRlbnRpYWxzKTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IHJlczogQXV0aFJlc3BvbnNlXG4gICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCB7IGVtYWlsLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHNcbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2U6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgO1tjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QoXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UsXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2VLZXlcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc2lnbnVwYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zPy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgIGRhdGE6IG9wdGlvbnM/LmRhdGEgPz8ge30sXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLFxuICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBwaG9uZSwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgIGRhdGE6IG9wdGlvbnM/LmRhdGEgPz8ge30sXG4gICAgICAgICAgICBjaGFubmVsOiBvcHRpb25zPy5jaGFubmVsID8/ICdzbXMnLFxuICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoXG4gICAgICAgICAgJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlciBhbmQgYSBwYXNzd29yZCdcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXNcblxuICAgICAgaWYgKGVycm9yIHx8ICFkYXRhKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXNzaW9uOiBTZXNzaW9uIHwgbnVsbCA9IGRhdGEuc2Vzc2lvblxuICAgICAgY29uc3QgdXNlcjogVXNlciB8IG51bGwgPSBkYXRhLnVzZXJcblxuICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBzZXNzaW9uKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIHdpdGggYW4gZW1haWwgYW5kIHBhc3N3b3JkIG9yIHBob25lIGFuZCBwYXNzd29yZC5cbiAgICpcbiAgICogQmUgYXdhcmUgdGhhdCB5b3UgbWF5IGdldCBiYWNrIGFuIGVycm9yIG1lc3NhZ2UgdGhhdCB3aWxsIG5vdCBkaXN0aW5ndWlzaFxuICAgKiBiZXR3ZWVuIHRoZSBjYXNlcyB3aGVyZSB0aGUgYWNjb3VudCBkb2VzIG5vdCBleGlzdCBvciB0aGF0IHRoZVxuICAgKiBlbWFpbC9waG9uZSBhbmQgcGFzc3dvcmQgY29tYmluYXRpb24gaXMgd3Jvbmcgb3IgdGhhdCB0aGUgYWNjb3VudCBjYW4gb25seVxuICAgKiBiZSBhY2Nlc3NlZCB2aWEgc29jaWFsIGxvZ2luLlxuICAgKi9cbiAgYXN5bmMgc2lnbkluV2l0aFBhc3N3b3JkKFxuICAgIGNyZWRlbnRpYWxzOiBTaWduSW5XaXRoUGFzc3dvcmRDcmVkZW50aWFsc1xuICApOiBQcm9taXNlPEF1dGhUb2tlblJlc3BvbnNlUGFzc3dvcmQ+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IHJlczogQXV0aFJlc3BvbnNlUGFzc3dvcmRcbiAgICAgIGlmICgnZW1haWwnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFsc1xuICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXBhc3N3b3JkYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkLFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgcGhvbmUsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFsc1xuICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXBhc3N3b3JkYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkLFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcihcbiAgICAgICAgICAnWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gZW1haWwgb3IgcGhvbmUgbnVtYmVyIGFuZCBhIHBhc3N3b3JkJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXNcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9IGVsc2UgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpIH1cbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHVzZXI6IGRhdGEudXNlcixcbiAgICAgICAgICBzZXNzaW9uOiBkYXRhLnNlc3Npb24sXG4gICAgICAgICAgLi4uKGRhdGEud2Vha19wYXNzd29yZCA/IHsgd2Vha1Bhc3N3b3JkOiBkYXRhLndlYWtfcGFzc3dvcmQgfSA6IG51bGwpLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcixcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9nIGluIGFuIGV4aXN0aW5nIHVzZXIgdmlhIGEgdGhpcmQtcGFydHkgcHJvdmlkZXIuXG4gICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAqL1xuICBhc3luYyBzaWduSW5XaXRoT0F1dGgoY3JlZGVudGlhbHM6IFNpZ25JbldpdGhPQXV0aENyZWRlbnRpYWxzKTogUHJvbWlzZTxPQXV0aFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2hhbmRsZVByb3ZpZGVyU2lnbkluKGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB7XG4gICAgICByZWRpcmVjdFRvOiBjcmVkZW50aWFscy5vcHRpb25zPy5yZWRpcmVjdFRvLFxuICAgICAgc2NvcGVzOiBjcmVkZW50aWFscy5vcHRpb25zPy5zY29wZXMsXG4gICAgICBxdWVyeVBhcmFtczogY3JlZGVudGlhbHMub3B0aW9ucz8ucXVlcnlQYXJhbXMsXG4gICAgICBza2lwQnJvd3NlclJlZGlyZWN0OiBjcmVkZW50aWFscy5vcHRpb25zPy5za2lwQnJvd3NlclJlZGlyZWN0LFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogTG9nIGluIGFuIGV4aXN0aW5nIHVzZXIgYnkgZXhjaGFuZ2luZyBhbiBBdXRoIENvZGUgaXNzdWVkIGR1cmluZyB0aGUgUEtDRSBmbG93LlxuICAgKi9cbiAgYXN5bmMgZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihhdXRoQ29kZTogc3RyaW5nKTogUHJvbWlzZTxBdXRoVG9rZW5SZXNwb25zZT4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGUpXG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGU6IHN0cmluZyk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgc2Vzc2lvbjogU2Vzc2lvbjsgdXNlcjogVXNlcjsgcmVkaXJlY3RUeXBlOiBzdHJpbmcgfCBudWxsIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHsgZGF0YTogeyBzZXNzaW9uOiBudWxsOyB1c2VyOiBudWxsOyByZWRpcmVjdFR5cGU6IG51bGwgfTsgZXJyb3I6IEF1dGhFcnJvciB9XG4gID4ge1xuICAgIGNvbnN0IHN0b3JhZ2VJdGVtID0gYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYClcbiAgICBjb25zdCBbY29kZVZlcmlmaWVyLCByZWRpcmVjdFR5cGVdID0gKChzdG9yYWdlSXRlbSA/PyAnJykgYXMgc3RyaW5nKS5zcGxpdCgnLycpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgICdQT1NUJyxcbiAgICAgICAgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGtjZWAsXG4gICAgICAgIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgYXV0aF9jb2RlOiBhdXRoQ29kZSxcbiAgICAgICAgICAgIGNvZGVfdmVyaWZpZXI6IGNvZGVWZXJpZmllcixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICB9XG4gICAgICApXG4gICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKVxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsLCByZWRpcmVjdFR5cGU6IG51bGwgfSxcbiAgICAgICAgICBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCksXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0YTogeyAuLi5kYXRhLCByZWRpcmVjdFR5cGU6IHJlZGlyZWN0VHlwZSA/PyBudWxsIH0sIGVycm9yIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyBzaWduaW5nIGluIHdpdGggYW4gT0lEQyBJRCB0b2tlbi4gVGhlIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHVzZWRcbiAgICogc2hvdWxkIGJlIGVuYWJsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gICAqL1xuICBhc3luYyBzaWduSW5XaXRoSWRUb2tlbihjcmVkZW50aWFsczogU2lnbkluV2l0aElkVG9rZW5DcmVkZW50aWFscyk6IFByb21pc2U8QXV0aFRva2VuUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBvcHRpb25zLCBwcm92aWRlciwgdG9rZW4sIGFjY2Vzc190b2tlbiwgbm9uY2UgfSA9IGNyZWRlbnRpYWxzXG5cbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9aWRfdG9rZW5gLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgIGlkX3Rva2VuOiB0b2tlbixcbiAgICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH0gZWxzZSBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sXG4gICAgICAgICAgZXJyb3I6IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbilcbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGRhdGEuc2Vzc2lvbilcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9nIGluIGEgdXNlciB1c2luZyBtYWdpY2xpbmsgb3IgYSBvbmUtdGltZSBwYXNzd29yZCAoT1RQKS5cbiAgICpcbiAgICogSWYgdGhlIGB7eyAuQ29uZmlybWF0aW9uVVJMIH19YCB2YXJpYWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGVtYWlsIHRlbXBsYXRlLCBhIG1hZ2ljbGluayB3aWxsIGJlIHNlbnQuXG4gICAqIElmIHRoZSBge3sgLlRva2VuIH19YCB2YXJpYWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGVtYWlsIHRlbXBsYXRlLCBhbiBPVFAgd2lsbCBiZSBzZW50LlxuICAgKiBJZiB5b3UncmUgdXNpbmcgcGhvbmUgc2lnbi1pbnMsIG9ubHkgYW4gT1RQIHdpbGwgYmUgc2VudC4gWW91IHdvbid0IGJlIGFibGUgdG8gc2VuZCBhIG1hZ2ljbGluayBmb3IgcGhvbmUgc2lnbi1pbnMuXG4gICAqXG4gICAqIEJlIGF3YXJlIHRoYXQgeW91IG1heSBnZXQgYmFjayBhbiBlcnJvciBtZXNzYWdlIHRoYXQgd2lsbCBub3QgZGlzdGluZ3Vpc2hcbiAgICogYmV0d2VlbiB0aGUgY2FzZXMgd2hlcmUgdGhlIGFjY291bnQgZG9lcyBub3QgZXhpc3Qgb3IsIHRoYXQgdGhlIGFjY291bnRcbiAgICogY2FuIG9ubHkgYmUgYWNjZXNzZWQgdmlhIHNvY2lhbCBsb2dpbi5cbiAgICpcbiAgICogRG8gbm90ZSB0aGF0IHlvdSB3aWxsIG5lZWQgdG8gY29uZmlndXJlIGEgV2hhdHNhcHAgc2VuZGVyIG9uIFR3aWxpb1xuICAgKiBpZiB5b3UgYXJlIHVzaW5nIHBob25lIHNpZ24gaW4gd2l0aCB0aGUgJ3doYXRzYXBwJyBjaGFubmVsLiBUaGUgd2hhdHNhcHBcbiAgICogY2hhbm5lbCBpcyBub3Qgc3VwcG9ydGVkIG9uIG90aGVyIHByb3ZpZGVyc1xuICAgKiBhdCB0aGlzIHRpbWUuXG4gICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIFBLQ0Ugd2hlbiBhbiBlbWFpbCBpcyBwYXNzZWQuXG4gICAqL1xuICBhc3luYyBzaWduSW5XaXRoT3RwKGNyZWRlbnRpYWxzOiBTaWduSW5XaXRoUGFzc3dvcmRsZXNzQ3JlZGVudGlhbHMpOiBQcm9taXNlPEF1dGhPdHBSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCB7IGVtYWlsLCBvcHRpb25zIH0gPSBjcmVkZW50aWFsc1xuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2Q6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICA7W2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZUtleVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9vdHBgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgZGF0YTogb3B0aW9ucz8uZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIGNyZWF0ZV91c2VyOiBvcHRpb25zPy5zaG91bGRDcmVhdGVVc2VyID8/IHRydWUsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLFxuICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucz8uZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBwaG9uZSwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHNcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vb3RwYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgIGRhdGE6IG9wdGlvbnM/LmRhdGEgPz8ge30sXG4gICAgICAgICAgICBjcmVhdGVfdXNlcjogb3B0aW9ucz8uc2hvdWxkQ3JlYXRlVXNlciA/PyB0cnVlLFxuICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICBjaGFubmVsOiBvcHRpb25zPy5jaGFubmVsID8/ICdzbXMnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgbWVzc2FnZUlkOiBkYXRhPy5tZXNzYWdlX2lkIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlci4nKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvZyBpbiBhIHVzZXIgZ2l2ZW4gYSBVc2VyIHN1cHBsaWVkIE9UUCBvciBUb2tlbkhhc2ggcmVjZWl2ZWQgdGhyb3VnaCBtb2JpbGUgb3IgZW1haWwuXG4gICAqL1xuICBhc3luYyB2ZXJpZnlPdHAocGFyYW1zOiBWZXJpZnlPdHBQYXJhbXMpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgcmVkaXJlY3RUbzogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gICAgICBsZXQgY2FwdGNoYVRva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgICAgIGlmICgnb3B0aW9ucycgaW4gcGFyYW1zKSB7XG4gICAgICAgIHJlZGlyZWN0VG8gPSBwYXJhbXMub3B0aW9ucz8ucmVkaXJlY3RUb1xuICAgICAgICBjYXB0Y2hhVG9rZW4gPSBwYXJhbXMub3B0aW9ucz8uY2FwdGNoYVRva2VuXG4gICAgICB9XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS92ZXJpZnlgLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBjYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgfSxcbiAgICAgICAgcmVkaXJlY3RUbyxcbiAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICB9KVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgb24gdG9rZW4gdmVyaWZpY2F0aW9uLicpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlc3Npb246IFNlc3Npb24gfCBudWxsID0gZGF0YS5zZXNzaW9uXG4gICAgICBjb25zdCB1c2VyOiBVc2VyID0gZGF0YS51c2VyXG5cbiAgICAgIGlmIChzZXNzaW9uPy5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbiBhcyBTZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycyhcbiAgICAgICAgICBwYXJhbXMudHlwZSA9PSAncmVjb3ZlcnknID8gJ1BBU1NXT1JEX1JFQ09WRVJZJyA6ICdTSUdORURfSU4nLFxuICAgICAgICAgIHNlc3Npb25cbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIGEgc2luZ2xlLXNpZ24gb24gdXNpbmcgYW4gZW50ZXJwcmlzZSBJZGVudGl0eSBQcm92aWRlci4gQVxuICAgKiBzdWNjZXNzZnVsIFNTTyBhdHRlbXB0IHdpbGwgcmVkaXJlY3QgdGhlIGN1cnJlbnQgcGFnZSB0byB0aGUgaWRlbnRpdHlcbiAgICogcHJvdmlkZXIgYXV0aG9yaXphdGlvbiBwYWdlLiBUaGUgcmVkaXJlY3QgVVJMIGlzIGltcGxlbWVudGF0aW9uIGFuZCBTU09cbiAgICogcHJvdG9jb2wgc3BlY2lmaWMuXG4gICAqXG4gICAqIFlvdSBjYW4gdXNlIGl0IGJ5IHByb3ZpZGluZyBhIFNTTyBkb21haW4uIFR5cGljYWxseSB5b3UgY2FuIGV4dHJhY3QgdGhpc1xuICAgKiBkb21haW4gYnkgYXNraW5nIHVzZXJzIGZvciB0aGVpciBlbWFpbCBhZGRyZXNzLiBJZiB0aGlzIGRvbWFpbiBpc1xuICAgKiByZWdpc3RlcmVkIG9uIHRoZSBBdXRoIGluc3RhbmNlIHRoZSByZWRpcmVjdCB3aWxsIHVzZSB0aGF0IG9yZ2FuaXphdGlvbidzXG4gICAqIGN1cnJlbnRseSBhY3RpdmUgU1NPIElkZW50aXR5IFByb3ZpZGVyIGZvciB0aGUgbG9naW4uXG4gICAqXG4gICAqIElmIHlvdSBoYXZlIGJ1aWx0IGFuIG9yZ2FuaXphdGlvbi1zcGVjaWZpYyBsb2dpbiBwYWdlLCB5b3UgY2FuIHVzZSB0aGVcbiAgICogb3JnYW5pemF0aW9uJ3MgU1NPIElkZW50aXR5IFByb3ZpZGVyIFVVSUQgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhTU08ocGFyYW1zOiBTaWduSW5XaXRoU1NPKTogUHJvbWlzZTxTU09SZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgY29kZUNoYWxsZW5nZTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICA7W2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChcbiAgICAgICAgICB0aGlzLnN0b3JhZ2UsXG4gICAgICAgICAgdGhpcy5zdG9yYWdlS2V5XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Nzb2AsIHtcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIC4uLigncHJvdmlkZXJJZCcgaW4gcGFyYW1zID8geyBwcm92aWRlcl9pZDogcGFyYW1zLnByb3ZpZGVySWQgfSA6IG51bGwpLFxuICAgICAgICAgIC4uLignZG9tYWluJyBpbiBwYXJhbXMgPyB7IGRvbWFpbjogcGFyYW1zLmRvbWFpbiB9IDogbnVsbCksXG4gICAgICAgICAgcmVkaXJlY3RfdG86IHBhcmFtcy5vcHRpb25zPy5yZWRpcmVjdFRvID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAuLi4ocGFyYW1zPy5vcHRpb25zPy5jYXB0Y2hhVG9rZW5cbiAgICAgICAgICAgID8geyBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBwYXJhbXMub3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSB9XG4gICAgICAgICAgICA6IG51bGwpLFxuICAgICAgICAgIHNraXBfaHR0cF9yZWRpcmVjdDogdHJ1ZSwgLy8gZmV0Y2ggZG9lcyBub3QgaGFuZGxlIHJlZGlyZWN0c1xuICAgICAgICAgIGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLFxuICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICB4Zm9ybTogX3Nzb1Jlc3BvbnNlLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHJlYXV0aGVudGljYXRpb24gT1RQIHRvIHRoZSB1c2VyJ3MgZW1haWwgb3IgcGhvbmUgbnVtYmVyLlxuICAgKiBSZXF1aXJlcyB0aGUgdXNlciB0byBiZSBzaWduZWQtaW4uXG4gICAqL1xuICBhc3luYyByZWF1dGhlbnRpY2F0ZSgpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JlYXV0aGVudGljYXRlKClcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfcmVhdXRoZW50aWNhdGUoKTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGF0YTogeyBzZXNzaW9uIH0sXG4gICAgICAgICAgZXJyb3I6IHNlc3Npb25FcnJvcixcbiAgICAgICAgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB0aHJvdyBzZXNzaW9uRXJyb3JcbiAgICAgICAgaWYgKCFzZXNzaW9uKSB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKVxuXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vcmVhdXRoZW50aWNhdGVgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNlbmRzIGFuIGV4aXN0aW5nIHNpZ251cCBjb25maXJtYXRpb24gZW1haWwsIGVtYWlsIGNoYW5nZSBlbWFpbCwgU01TIE9UUCBvciBwaG9uZSBjaGFuZ2UgT1RQLlxuICAgKi9cbiAgYXN5bmMgcmVzZW5kKGNyZWRlbnRpYWxzOiBSZXNlbmRQYXJhbXMpOiBQcm9taXNlPEF1dGhPdHBSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMudXJsfS9yZXNlbmRgXG4gICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCB7IGVtYWlsLCB0eXBlLCBvcHRpb25zIH0gPSBjcmVkZW50aWFsc1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGVuZHBvaW50LCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucz8uZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfSBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgcGhvbmUsIHR5cGUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgZW5kcG9pbnQsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsLCBtZXNzYWdlSWQ6IGRhdGE/Lm1lc3NhZ2VfaWQgfSwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcihcbiAgICAgICAgJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlciBhbmQgYSB0eXBlJ1xuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzZXNzaW9uLCByZWZyZXNoaW5nIGl0IGlmIG5lY2Vzc2FyeS5cbiAgICpcbiAgICogVGhlIHNlc3Npb24gcmV0dXJuZWQgY2FuIGJlIG51bGwgaWYgdGhlIHNlc3Npb24gaXMgbm90IGRldGVjdGVkIHdoaWNoIGNhbiBoYXBwZW4gaW4gdGhlIGV2ZW50IGEgdXNlciBpcyBub3Qgc2lnbmVkLWluIG9yIGhhcyBsb2dnZWQgb3V0LlxuICAgKlxuICAgKiAqKklNUE9SVEFOVDoqKiBUaGlzIG1ldGhvZCBsb2FkcyB2YWx1ZXMgZGlyZWN0bHkgZnJvbSB0aGUgc3RvcmFnZSBhdHRhY2hlZFxuICAgKiB0byB0aGUgY2xpZW50LiBJZiB0aGF0IHN0b3JhZ2UgaXMgYmFzZWQgb24gcmVxdWVzdCBjb29raWVzIGZvciBleGFtcGxlLFxuICAgKiB0aGUgdmFsdWVzIGluIGl0IG1heSBub3QgYmUgYXV0aGVudGljIGFuZCB0aGVyZWZvcmUgaXQncyBzdHJvbmdseSBhZHZpc2VkXG4gICAqIGFnYWluc3QgdXNpbmcgdGhpcyBtZXRob2QgYW5kIGl0cyByZXN1bHRzIGluIHN1Y2ggY2lyY3Vtc3RhbmNlcy4gQSB3YXJuaW5nXG4gICAqIHdpbGwgYmUgZW1pdHRlZCBpZiB0aGlzIGlzIGRldGVjdGVkLiBVc2Uge0BsaW5rICNnZXRVc2VyKCl9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRTZXNzaW9uKCkge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3F1aXJlcyBhIGdsb2JhbCBsb2NrIGJhc2VkIG9uIHRoZSBzdG9yYWdlIGtleS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2FjcXVpcmVMb2NrPFI+KGFjcXVpcmVUaW1lb3V0OiBudW1iZXIsIGZuOiAoKSA9PiBQcm9taXNlPFI+KTogUHJvbWlzZTxSPiB7XG4gICAgdGhpcy5fZGVidWcoJyNfYWNxdWlyZUxvY2snLCAnYmVnaW4nLCBhY3F1aXJlVGltZW91dClcblxuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5sb2NrQWNxdWlyZWQpIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMucGVuZGluZ0luTG9jay5sZW5ndGhcbiAgICAgICAgICA/IHRoaXMucGVuZGluZ0luTG9ja1t0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoIC0gMV1cbiAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSgpXG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBsYXN0XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKClcbiAgICAgICAgfSkoKVxuXG4gICAgICAgIHRoaXMucGVuZGluZ0luTG9jay5wdXNoKFxuICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhd2FpdCByZXN1bHRcbiAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGNhcmUgaWYgaXQgZmluaXNoZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpXG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvY2soYGxvY2s6JHt0aGlzLnN0b3JhZ2VLZXl9YCwgYWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfYWNxdWlyZUxvY2snLCAnbG9jayBhY3F1aXJlZCBmb3Igc3RvcmFnZSBrZXknLCB0aGlzLnN0b3JhZ2VLZXkpXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmxvY2tBY3F1aXJlZCA9IHRydWVcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKClcblxuICAgICAgICAgIHRoaXMucGVuZGluZ0luTG9jay5wdXNoKFxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZXN1bHRcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICAgICAgLy8gd2UganVzdCBjYXJlIGlmIGl0IGZpbmlzaGVkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKClcbiAgICAgICAgICApXG5cbiAgICAgICAgICBhd2FpdCByZXN1bHRcblxuICAgICAgICAgIC8vIGtlZXAgZHJhaW5pbmcgdGhlIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm90aGluZyB0byB3YWl0IG9uXG4gICAgICAgICAgd2hpbGUgKHRoaXMucGVuZGluZ0luTG9jay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHdhaXRPbiA9IFsuLi50aGlzLnBlbmRpbmdJbkxvY2tdXG5cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHdhaXRPbilcblxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnNwbGljZSgwLCB3YWl0T24ubGVuZ3RoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhd2FpdCByZXN1bHRcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdsb2NrIHJlbGVhc2VkIGZvciBzdG9yYWdlIGtleScsIHRoaXMuc3RvcmFnZUtleSlcblxuICAgICAgICAgIHRoaXMubG9ja0FjcXVpcmVkID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fZGVidWcoJyNfYWNxdWlyZUxvY2snLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlIGluc3RlYWQgb2Yge0BsaW5rICNnZXRTZXNzaW9ufSBpbnNpZGUgdGhlIGxpYnJhcnkuIEl0IGlzXG4gICAqIHNlbWFudGljYWxseSB1c3VhbGx5IHdoYXQgeW91IHdhbnQsIGFzIGdldHRpbmcgYSBzZXNzaW9uIGludm9sdmVzIHNvbWVcbiAgICogcHJvY2Vzc2luZyBhZnRlcndhcmRzIHRoYXQgcmVxdWlyZXMgb25seSBvbmUgY2xpZW50IG9wZXJhdGluZyBvbiB0aGVcbiAgICogc2Vzc2lvbiBhdCBvbmNlIGFjcm9zcyBtdWx0aXBsZSB0YWJzIG9yIHByb2Nlc3Nlcy5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3VzZVNlc3Npb248Uj4oXG4gICAgZm46IChcbiAgICAgIHJlc3VsdDpcbiAgICAgICAgfCB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNlc3Npb246IFNlc3Npb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB8IHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc2Vzc2lvbjogbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3I6IEF1dGhFcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfCB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgfVxuICAgICkgPT4gUHJvbWlzZTxSPlxuICApOiBQcm9taXNlPFI+IHtcbiAgICB0aGlzLl9kZWJ1ZygnI191c2VTZXNzaW9uJywgJ2JlZ2luJylcblxuICAgIHRyeSB7XG4gICAgICAvLyB0aGUgdXNlIG9mIF9fbG9hZFNlc3Npb24gaGVyZSBpcyB0aGUgb25seSBjb3JyZWN0IHVzZSBvZiB0aGUgZnVuY3Rpb24hXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9fbG9hZFNlc3Npb24oKVxuXG4gICAgICByZXR1cm4gYXdhaXQgZm4ocmVzdWx0KVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnI191c2VTZXNzaW9uJywgJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5FVkVSIFVTRSBESVJFQ1RMWSFcbiAgICpcbiAgICogQWx3YXlzIHVzZSB7QGxpbmsgI191c2VTZXNzaW9ufS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX19sb2FkU2Vzc2lvbigpOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc2Vzc2lvbjogU2Vzc2lvblxuICAgICAgICB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzZXNzaW9uOiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgZXJyb3I6IEF1dGhFcnJvclxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc2Vzc2lvbjogbnVsbFxuICAgICAgICB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gID4ge1xuICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ2JlZ2luJylcblxuICAgIGlmICghdGhpcy5sb2NrQWNxdWlyZWQpIHtcbiAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ3VzZWQgb3V0c2lkZSBvZiBhbiBhY3F1aXJlZCBsb2NrIScsIG5ldyBFcnJvcigpLnN0YWNrKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBsZXQgY3VycmVudFNlc3Npb246IFNlc3Npb24gfCBudWxsID0gbnVsbFxuXG4gICAgICBjb25zdCBtYXliZVNlc3Npb24gPSBhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpXG5cbiAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlJywgbWF5YmVTZXNzaW9uKVxuXG4gICAgICBpZiAobWF5YmVTZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkU2Vzc2lvbihtYXliZVNlc3Npb24pKSB7XG4gICAgICAgICAgY3VycmVudFNlc3Npb24gPSBtYXliZVNlc3Npb25cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9kZWJ1ZygnI2dldFNlc3Npb24oKScsICdzZXNzaW9uIGZyb20gc3RvcmFnZSBpcyBub3QgdmFsaWQnKVxuICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBudWxsIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaGFzRXhwaXJlZCA9IGN1cnJlbnRTZXNzaW9uLmV4cGlyZXNfYXRcbiAgICAgICAgPyBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0IDw9IERhdGUubm93KCkgLyAxMDAwXG4gICAgICAgIDogZmFsc2VcblxuICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgICcjX19sb2FkU2Vzc2lvbigpJyxcbiAgICAgICAgYHNlc3Npb24gaGFzJHtoYXNFeHBpcmVkID8gJycgOiAnIG5vdCd9IGV4cGlyZWRgLFxuICAgICAgICAnZXhwaXJlc19hdCcsXG4gICAgICAgIGN1cnJlbnRTZXNzaW9uLmV4cGlyZXNfYXRcbiAgICAgIClcblxuICAgICAgaWYgKCFoYXNFeHBpcmVkKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3JhZ2UuaXNTZXJ2ZXIpIHtcbiAgICAgICAgICBsZXQgc3VwcHJlc3NXYXJuaW5nID0gdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nXG4gICAgICAgICAgY29uc3QgcHJveHlTZXNzaW9uOiBTZXNzaW9uID0gbmV3IFByb3h5KGN1cnJlbnRTZXNzaW9uLCB7XG4gICAgICAgICAgICBnZXQ6ICh0YXJnZXQ6IGFueSwgcHJvcDogc3RyaW5nLCByZWNlaXZlcjogYW55KSA9PiB7XG4gICAgICAgICAgICAgIGlmICghc3VwcHJlc3NXYXJuaW5nICYmIHByb3AgPT09ICd1c2VyJykge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgc2hvdyB3YXJuaW5nIHdoZW4gdGhlIHVzZXIgb2JqZWN0IGlzIGJlaW5nIGFjY2Vzc2VkIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICdVc2luZyB0aGUgdXNlciBvYmplY3QgYXMgcmV0dXJuZWQgZnJvbSBzdXBhYmFzZS5hdXRoLmdldFNlc3Npb24oKSBvciBmcm9tIHNvbWUgc3VwYWJhc2UuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZSgpIGV2ZW50cyBjb3VsZCBiZSBpbnNlY3VyZSEgVGhpcyB2YWx1ZSBjb21lcyBkaXJlY3RseSBmcm9tIHRoZSBzdG9yYWdlIG1lZGl1bSAodXN1YWxseSBjb29raWVzIG9uIHRoZSBzZXJ2ZXIpIGFuZCBtYXkgbm90IGJlIGF1dGhlbnRpYy4gVXNlIHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpIGluc3RlYWQgd2hpY2ggYXV0aGVudGljYXRlcyB0aGUgZGF0YSBieSBjb250YWN0aW5nIHRoZSBTdXBhYmFzZSBBdXRoIHNlcnZlci4nXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHN1cHByZXNzV2FybmluZyA9IHRydWUgLy8ga2VlcHMgdGhpcyBwcm94eSBpbnN0YW5jZSBmcm9tIGxvZ2dpbmcgYWRkaXRpb25hbCB3YXJuaW5nc1xuICAgICAgICAgICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWUgLy8ga2VlcHMgdGhpcyBjbGllbnQncyBmdXR1cmUgcHJveHkgaW5zdGFuY2VzIGZyb20gd2FybmluZ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gcHJveHlTZXNzaW9uXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IGN1cnJlbnRTZXNzaW9uIH0sIGVycm9yOiBudWxsIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBzZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKVxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdXNlciBkZXRhaWxzIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHNlc3Npb24uIFRoaXMgbWV0aG9kXG4gICAqIHBlcmZvcm1zIGEgbmV0d29yayByZXF1ZXN0IHRvIHRoZSBTdXBhYmFzZSBBdXRoIHNlcnZlciwgc28gdGhlIHJldHVybmVkXG4gICAqIHZhbHVlIGlzIGF1dGhlbnRpYyBhbmQgY2FuIGJlIHVzZWQgdG8gYmFzZSBhdXRob3JpemF0aW9uIHJ1bGVzIG9uLlxuICAgKlxuICAgKiBAcGFyYW0gand0IFRha2VzIGluIGFuIG9wdGlvbmFsIGFjY2VzcyB0b2tlbiBKV1QuIElmIG5vIEpXVCBpcyBwcm92aWRlZCwgdGhlIEpXVCBmcm9tIHRoZSBjdXJyZW50IHNlc3Npb24gaXMgdXNlZC5cbiAgICovXG4gIGFzeW5jIGdldFVzZXIoand0Pzogc3RyaW5nKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICBpZiAoand0KSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZ2V0VXNlcihqd3QpXG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0VXNlcihqd3Q/OiBzdHJpbmcpOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoand0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGp3dDogand0LFxuICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJucyBhbiBlcnJvciBpZiB0aGVyZSBpcyBubyBhY2Nlc3NfdG9rZW4gb3IgY3VzdG9tIGF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAgICAgIGlmICghZGF0YS5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4gJiYgIXRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvcjogbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCkgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vdXNlcmAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgand0OiBkYXRhLnNlc3Npb24/LmFjY2Vzc190b2tlbiA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIGlmIChpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKGVycm9yKSkge1xuICAgICAgICAgIC8vIEpXVCBjb250YWlucyBhIGBzZXNzaW9uX2lkYCB3aGljaCBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIGFuIGFjdGl2ZVxuICAgICAgICAgIC8vIHNlc3Npb24gaW4gdGhlIGRhdGFiYXNlLCBpbmRpY2F0aW5nIHRoZSB1c2VyIGlzIHNpZ25lZCBvdXQuXG5cbiAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKClcbiAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB1c2VyIGRhdGEgZm9yIGEgbG9nZ2VkIGluIHVzZXIuXG4gICAqL1xuICBhc3luYyB1cGRhdGVVc2VyKFxuICAgIGF0dHJpYnV0ZXM6IFVzZXJBdHRyaWJ1dGVzLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGVtYWlsUmVkaXJlY3RUbz86IHN0cmluZyB8IHVuZGVmaW5lZFxuICAgIH0gPSB7fVxuICApOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucylcbiAgICB9KVxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF91cGRhdGVVc2VyKFxuICAgIGF0dHJpYnV0ZXM6IFVzZXJBdHRyaWJ1dGVzLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGVtYWlsUmVkaXJlY3RUbz86IHN0cmluZyB8IHVuZGVmaW5lZFxuICAgIH0gPSB7fVxuICApOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgc2Vzc2lvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZXNzaW9uRGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXNzaW9uOiBTZXNzaW9uID0gc2Vzc2lvbkRhdGEuc2Vzc2lvblxuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2Q6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScgJiYgYXR0cmlidXRlcy5lbWFpbCAhPSBudWxsKSB7XG4gICAgICAgICAgO1tjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QoXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UsXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2VLZXlcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQVVQnLCBgJHt0aGlzLnVybH0vdXNlcmAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucz8uZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgIH0pXG4gICAgICAgIGlmICh1c2VyRXJyb3IpIHRocm93IHVzZXJFcnJvclxuICAgICAgICBzZXNzaW9uLnVzZXIgPSBkYXRhLnVzZXIgYXMgVXNlclxuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnVVNFUl9VUERBVEVEJywgc2Vzc2lvbilcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBzZXNzaW9uLnVzZXIgfSwgZXJyb3I6IG51bGwgfVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGVzIGEgSldUICh3aXRob3V0IHBlcmZvcm1pbmcgYW55IHZhbGlkYXRpb24pLlxuICAgKi9cbiAgcHJpdmF0ZSBfZGVjb2RlSldUKGp3dDogc3RyaW5nKToge1xuICAgIGV4cD86IG51bWJlclxuICAgIGFhbD86IEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbHMgfCBudWxsXG4gICAgYW1yPzogQU1SRW50cnlbXSB8IG51bGxcbiAgfSB7XG4gICAgcmV0dXJuIGRlY29kZUpXVFBheWxvYWQoand0KVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlc3Npb24gZGF0YSBmcm9tIHRoZSBjdXJyZW50IHNlc3Npb24uIElmIHRoZSBjdXJyZW50IHNlc3Npb24gaXMgZXhwaXJlZCwgc2V0U2Vzc2lvbiB3aWxsIHRha2UgY2FyZSBvZiByZWZyZXNoaW5nIGl0IHRvIG9idGFpbiBhIG5ldyBzZXNzaW9uLlxuICAgKiBJZiB0aGUgcmVmcmVzaCB0b2tlbiBvciBhY2Nlc3MgdG9rZW4gaW4gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyBpbnZhbGlkLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICogQHBhcmFtIGN1cnJlbnRTZXNzaW9uIFRoZSBjdXJyZW50IHNlc3Npb24gdGhhdCBtaW5pbWFsbHkgY29udGFpbnMgYW4gYWNjZXNzIHRva2VuIGFuZCByZWZyZXNoIHRva2VuLlxuICAgKi9cbiAgYXN5bmMgc2V0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbjoge1xuICAgIGFjY2Vzc190b2tlbjogc3RyaW5nXG4gICAgcmVmcmVzaF90b2tlbjogc3RyaW5nXG4gIH0pOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NldFNlc3Npb24oY3VycmVudFNlc3Npb24pXG4gICAgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfc2V0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbjoge1xuICAgIGFjY2Vzc190b2tlbjogc3RyaW5nXG4gICAgcmVmcmVzaF90b2tlbjogc3RyaW5nXG4gIH0pOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbiB8fCAhY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB0aW1lTm93ID0gRGF0ZS5ub3coKSAvIDEwMDBcbiAgICAgIGxldCBleHBpcmVzQXQgPSB0aW1lTm93XG4gICAgICBsZXQgaGFzRXhwaXJlZCA9IHRydWVcbiAgICAgIGxldCBzZXNzaW9uOiBTZXNzaW9uIHwgbnVsbCA9IG51bGxcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBkZWNvZGVKV1RQYXlsb2FkKGN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbilcbiAgICAgIGlmIChwYXlsb2FkLmV4cCkge1xuICAgICAgICBleHBpcmVzQXQgPSBwYXlsb2FkLmV4cFxuICAgICAgICBoYXNFeHBpcmVkID0gZXhwaXJlc0F0IDw9IHRpbWVOb3dcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0V4cGlyZWQpIHtcbiAgICAgICAgY29uc3QgeyBzZXNzaW9uOiByZWZyZXNoZWRTZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihcbiAgICAgICAgICBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuXG4gICAgICAgIClcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlZnJlc2hlZFNlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IG51bGwgfVxuICAgICAgICB9XG4gICAgICAgIHNlc3Npb24gPSByZWZyZXNoZWRTZXNzaW9uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9nZXRVc2VyKGN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbilcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfVxuICAgICAgICBzZXNzaW9uID0ge1xuICAgICAgICAgIGFjY2Vzc190b2tlbjogY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgIHJlZnJlc2hfdG9rZW46IGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgdXNlcjogZGF0YS51c2VyLFxuICAgICAgICAgIHRva2VuX3R5cGU6ICdiZWFyZXInLFxuICAgICAgICAgIGV4cGlyZXNfaW46IGV4cGlyZXNBdCAtIHRpbWVOb3csXG4gICAgICAgICAgZXhwaXJlc19hdDogZXhwaXJlc0F0LFxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBzZXNzaW9uKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IHNlc3Npb24udXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsLCB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBzZXNzaW9uLCByZWdhcmRsZXNzIG9mIGV4cGlyeSBzdGF0dXMuXG4gICAqIFRha2VzIGluIGFuIG9wdGlvbmFsIGN1cnJlbnQgc2Vzc2lvbi4gSWYgbm90IHBhc3NlZCBpbiwgdGhlbiByZWZyZXNoU2Vzc2lvbigpIHdpbGwgYXR0ZW1wdCB0byByZXRyaWV2ZSBpdCBmcm9tIGdldFNlc3Npb24oKS5cbiAgICogSWYgdGhlIGN1cnJlbnQgc2Vzc2lvbidzIHJlZnJlc2ggdG9rZW4gaXMgaW52YWxpZCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqIEBwYXJhbSBjdXJyZW50U2Vzc2lvbiBUaGUgY3VycmVudCBzZXNzaW9uLiBJZiBwYXNzZWQgaW4sIGl0IG11c3QgY29udGFpbiBhIHJlZnJlc2ggdG9rZW4uXG4gICAqL1xuICBhc3luYyByZWZyZXNoU2Vzc2lvbihjdXJyZW50U2Vzc2lvbj86IHsgcmVmcmVzaF90b2tlbjogc3RyaW5nIH0pOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKVxuICAgIH0pXG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX3JlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uPzoge1xuICAgIHJlZnJlc2hfdG9rZW46IHN0cmluZ1xuICB9KTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gZGF0YS5zZXNzaW9uID8/IHVuZGVmaW5lZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbj8ucmVmcmVzaF90b2tlbikge1xuICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBudWxsIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH1cbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2Vzc2lvbiBkYXRhIGZyb20gYSBVUkwgc3RyaW5nXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9nZXRTZXNzaW9uRnJvbVVSTChcbiAgICBwYXJhbXM6IHsgW3BhcmFtZXRlcjogc3RyaW5nXTogc3RyaW5nIH0sXG4gICAgY2FsbGJhY2tVcmxUeXBlOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBzZXNzaW9uOiBTZXNzaW9uOyByZWRpcmVjdFR5cGU6IHN0cmluZyB8IG51bGwgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwgeyBkYXRhOiB7IHNlc3Npb246IG51bGw7IHJlZGlyZWN0VHlwZTogbnVsbCB9OyBlcnJvcjogQXV0aEVycm9yIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghaXNCcm93c2VyKCkpIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vIGJyb3dzZXIgZGV0ZWN0ZWQuJylcblxuICAgICAgLy8gSWYgdGhlcmUncyBhbiBlcnJvciBpbiB0aGUgVVJMLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IGZsb3cgaXQgaXMsIHdlIGp1c3QgcmV0dXJuIHRoZSBlcnJvci5cbiAgICAgIGlmIChwYXJhbXMuZXJyb3IgfHwgcGFyYW1zLmVycm9yX2Rlc2NyaXB0aW9uIHx8IHBhcmFtcy5lcnJvcl9jb2RlKSB7XG4gICAgICAgIC8vIFRoZSBlcnJvciBjbGFzcyByZXR1cm5lZCBpbXBsaWVzIHRoYXQgdGhlIHJlZGlyZWN0IGlzIGZyb20gYW4gaW1wbGljaXQgZ3JhbnQgZmxvd1xuICAgICAgICAvLyBidXQgaXQgY291bGQgYWxzbyBiZSBmcm9tIGEgcmVkaXJlY3QgZXJyb3IgZnJvbSBhIFBLQ0UgZmxvdy5cbiAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihcbiAgICAgICAgICBwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24gfHwgJ0Vycm9yIGluIFVSTCB3aXRoIHVuc3BlY2lmaWVkIGVycm9yX2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlcnJvcjogcGFyYW1zLmVycm9yIHx8ICd1bnNwZWNpZmllZF9lcnJvcicsXG4gICAgICAgICAgICBjb2RlOiBwYXJhbXMuZXJyb3JfY29kZSB8fCAndW5zcGVjaWZpZWRfY29kZScsXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrcyBmb3IgbWlzbWF0Y2hlcyBiZXR3ZWVuIHRoZSBmbG93VHlwZSBpbml0aWFsaXNlZCBpbiB0aGUgY2xpZW50IGFuZCB0aGUgVVJMIHBhcmFtZXRlcnNcbiAgICAgIHN3aXRjaCAoY2FsbGJhY2tVcmxUeXBlKSB7XG4gICAgICAgIGNhc2UgJ2ltcGxpY2l0JzpcbiAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yKCdOb3QgYSB2YWxpZCBQS0NFIGZsb3cgdXJsLicpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3BrY2UnOlxuICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAnaW1wbGljaXQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdOb3QgYSB2YWxpZCBpbXBsaWNpdCBncmFudCBmbG93IHVybC4nKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAvLyB0aGVyZSdzIG5vIG1pc21hdGNoIHNvIHdlIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSByZWRpcmVjdCBmb3IgUEtDRSwgd2UgYXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgY29kZSBmcm9tIHRoZSBVUkwgZm9yIHRoZSBjb2RlIGV4Y2hhbmdlXG4gICAgICBpZiAoY2FsbGJhY2tVcmxUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfaW5pdGlhbGl6ZSgpJywgJ2JlZ2luJywgJ2lzIFBLQ0UgZmxvdycsIHRydWUpXG4gICAgICAgIGlmICghcGFyYW1zLmNvZGUpIHRocm93IG5ldyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IoJ05vIGNvZGUgZGV0ZWN0ZWQuJylcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihwYXJhbXMuY29kZSlcbiAgICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCdjb2RlJylcblxuICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUod2luZG93Lmhpc3Rvcnkuc3RhdGUsICcnLCB1cmwudG9TdHJpbmcoKSlcblxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IGRhdGEuc2Vzc2lvbiwgcmVkaXJlY3RUeXBlOiBudWxsIH0sIGVycm9yOiBudWxsIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBwcm92aWRlcl90b2tlbixcbiAgICAgICAgcHJvdmlkZXJfcmVmcmVzaF90b2tlbixcbiAgICAgICAgYWNjZXNzX3Rva2VuLFxuICAgICAgICByZWZyZXNoX3Rva2VuLFxuICAgICAgICBleHBpcmVzX2luLFxuICAgICAgICBleHBpcmVzX2F0LFxuICAgICAgICB0b2tlbl90eXBlLFxuICAgICAgfSA9IHBhcmFtc1xuXG4gICAgICBpZiAoIWFjY2Vzc190b2tlbiB8fCAhZXhwaXJlc19pbiB8fCAhcmVmcmVzaF90b2tlbiB8fCAhdG9rZW5fdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdObyBzZXNzaW9uIGRlZmluZWQgaW4gVVJMJylcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGltZU5vdyA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApXG4gICAgICBjb25zdCBleHBpcmVzSW4gPSBwYXJzZUludChleHBpcmVzX2luKVxuICAgICAgbGV0IGV4cGlyZXNBdCA9IHRpbWVOb3cgKyBleHBpcmVzSW5cblxuICAgICAgaWYgKGV4cGlyZXNfYXQpIHtcbiAgICAgICAgZXhwaXJlc0F0ID0gcGFyc2VJbnQoZXhwaXJlc19hdClcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWN0dWFsbHlFeHBpcmVzSW4gPSBleHBpcmVzQXQgLSB0aW1lTm93XG4gICAgICBpZiAoYWN0dWFsbHlFeHBpcmVzSW4gKiAxMDAwIDw9IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgQHN1cGFiYXNlL2dvdHJ1ZS1qczogU2Vzc2lvbiBhcyByZXRyaWV2ZWQgZnJvbSBVUkwgZXhwaXJlcyBpbiAke2FjdHVhbGx5RXhwaXJlc0lufXMsIHNob3VsZCBoYXZlIGJlZW4gY2xvc2VyIHRvICR7ZXhwaXJlc0lufXNgXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNzdWVkQXQgPSBleHBpcmVzQXQgLSBleHBpcmVzSW5cbiAgICAgIGlmICh0aW1lTm93IC0gaXNzdWVkQXQgPj0gMTIwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnQHN1cGFiYXNlL2dvdHJ1ZS1qczogU2Vzc2lvbiBhcyByZXRyaWV2ZWQgZnJvbSBVUkwgd2FzIGlzc3VlZCBvdmVyIDEyMHMgYWdvLCBVUkwgY291bGQgYmUgc3RhbGUnLFxuICAgICAgICAgIGlzc3VlZEF0LFxuICAgICAgICAgIGV4cGlyZXNBdCxcbiAgICAgICAgICB0aW1lTm93XG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAodGltZU5vdyAtIGlzc3VlZEF0IDwgMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ0BzdXBhYmFzZS9nb3RydWUtanM6IFNlc3Npb24gYXMgcmV0cmlldmVkIGZyb20gVVJMIHdhcyBpc3N1ZWQgaW4gdGhlIGZ1dHVyZT8gQ2hlY2sgdGhlIGRldmljZSBjbG9jayBmb3Igc2tldycsXG4gICAgICAgICAgaXNzdWVkQXQsXG4gICAgICAgICAgZXhwaXJlc0F0LFxuICAgICAgICAgIHRpbWVOb3dcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9nZXRVc2VyKGFjY2Vzc190b2tlbilcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgY29uc3Qgc2Vzc2lvbjogU2Vzc2lvbiA9IHtcbiAgICAgICAgcHJvdmlkZXJfdG9rZW4sXG4gICAgICAgIHByb3ZpZGVyX3JlZnJlc2hfdG9rZW4sXG4gICAgICAgIGFjY2Vzc190b2tlbixcbiAgICAgICAgZXhwaXJlc19pbjogZXhwaXJlc0luLFxuICAgICAgICBleHBpcmVzX2F0OiBleHBpcmVzQXQsXG4gICAgICAgIHJlZnJlc2hfdG9rZW4sXG4gICAgICAgIHRva2VuX3R5cGUsXG4gICAgICAgIHVzZXI6IGRhdGEudXNlcixcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRva2VucyBmcm9tIFVSTFxuICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSAnJ1xuICAgICAgdGhpcy5fZGVidWcoJyNfZ2V0U2Vzc2lvbkZyb21VUkwoKScsICdjbGVhcmluZyB3aW5kb3cubG9jYXRpb24uaGFzaCcpXG5cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbiwgcmVkaXJlY3RUeXBlOiBwYXJhbXMudHlwZSB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgVVJMIGNvbnRhaW5zIHBhcmFtZXRlcnMgZ2l2ZW4gYnkgYW4gaW1wbGljaXQgb2F1dGggZ3JhbnQgZmxvdyAoaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzY3NDkuaHRtbCNzZWN0aW9uLTQuMilcbiAgICovXG4gIHByaXZhdGUgX2lzSW1wbGljaXRHcmFudENhbGxiYWNrKHBhcmFtczogeyBbcGFyYW1ldGVyOiBzdHJpbmddOiBzdHJpbmcgfSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBCb29sZWFuKHBhcmFtcy5hY2Nlc3NfdG9rZW4gfHwgcGFyYW1zLmVycm9yX2Rlc2NyaXB0aW9uKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBVUkwgYW5kIGJhY2tpbmcgc3RvcmFnZSBjb250YWluIHBhcmFtZXRlcnMgZ2l2ZW4gYnkgYSBQS0NFIGZsb3dcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2lzUEtDRUNhbGxiYWNrKHBhcmFtczogeyBbcGFyYW1ldGVyOiBzdHJpbmddOiBzdHJpbmcgfSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGN1cnJlbnRTdG9yYWdlQ29udGVudCA9IGF3YWl0IGdldEl0ZW1Bc3luYyhcbiAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmBcbiAgICApXG5cbiAgICByZXR1cm4gISEocGFyYW1zLmNvZGUgJiYgY3VycmVudFN0b3JhZ2VDb250ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2lkZSBhIGJyb3dzZXIgY29udGV4dCwgYHNpZ25PdXQoKWAgd2lsbCByZW1vdmUgdGhlIGxvZ2dlZCBpbiB1c2VyIGZyb20gdGhlIGJyb3dzZXIgc2Vzc2lvbiBhbmQgbG9nIHRoZW0gb3V0IC0gcmVtb3ZpbmcgYWxsIGl0ZW1zIGZyb20gbG9jYWxzdG9yYWdlIGFuZCB0aGVuIHRyaWdnZXIgYSBgXCJTSUdORURfT1VUXCJgIGV2ZW50LlxuICAgKlxuICAgKiBGb3Igc2VydmVyLXNpZGUgbWFuYWdlbWVudCwgeW91IGNhbiByZXZva2UgYWxsIHJlZnJlc2ggdG9rZW5zIGZvciBhIHVzZXIgYnkgcGFzc2luZyBhIHVzZXIncyBKV1QgdGhyb3VnaCB0byBgYXV0aC5hcGkuc2lnbk91dChKV1Q6IHN0cmluZylgLlxuICAgKiBUaGVyZSBpcyBubyB3YXkgdG8gcmV2b2tlIGEgdXNlcidzIGFjY2VzcyB0b2tlbiBqd3QgdW50aWwgaXQgZXhwaXJlcy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gc2V0IGEgc2hvcnRlciBleHBpcnkgb24gdGhlIGp3dCBmb3IgdGhpcyByZWFzb24uXG4gICAqXG4gICAqIElmIHVzaW5nIGBvdGhlcnNgIHNjb3BlLCBubyBgU0lHTkVEX09VVGAgZXZlbnQgaXMgZmlyZWQhXG4gICAqL1xuICBhc3luYyBzaWduT3V0KG9wdGlvbnM6IFNpZ25PdXQgPSB7IHNjb3BlOiAnZ2xvYmFsJyB9KTogUHJvbWlzZTx7IGVycm9yOiBBdXRoRXJyb3IgfCBudWxsIH0+IHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9zaWduT3V0KG9wdGlvbnMpXG4gICAgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfc2lnbk91dChcbiAgICB7IHNjb3BlIH06IFNpZ25PdXQgPSB7IHNjb3BlOiAnZ2xvYmFsJyB9XG4gICk6IFByb21pc2U8eyBlcnJvcjogQXV0aEVycm9yIHwgbnVsbCB9PiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHRcbiAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHNlc3Npb25FcnJvciB9XG4gICAgICB9XG4gICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IGRhdGEuc2Vzc2lvbj8uYWNjZXNzX3Rva2VuXG4gICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5hZG1pbi5zaWduT3V0KGFjY2Vzc1Rva2VuLCBzY29wZSlcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgLy8gaWdub3JlIDQwNHMgc2luY2UgdXNlciBtaWdodCBub3QgZXhpc3QgYW55bW9yZVxuICAgICAgICAgIC8vIGlnbm9yZSA0MDFzIHNpbmNlIGFuIGludmFsaWQgb3IgZXhwaXJlZCBKV1Qgc2hvdWxkIHNpZ24gb3V0IHRoZSBjdXJyZW50IHNlc3Npb25cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICBpc0F1dGhBcGlFcnJvcihlcnJvcikgJiZcbiAgICAgICAgICAgICAgKGVycm9yLnN0YXR1cyA9PT0gNDA0IHx8IGVycm9yLnN0YXR1cyA9PT0gNDAxIHx8IGVycm9yLnN0YXR1cyA9PT0gNDAzKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3IgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNjb3BlICE9PSAnb3RoZXJzJykge1xuICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKClcbiAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYClcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGVycm9yOiBudWxsIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY2VpdmUgYSBub3RpZmljYXRpb24gZXZlcnkgdGltZSBhbiBhdXRoIGV2ZW50IGhhcHBlbnMuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiBhbiBhdXRoIGV2ZW50IGhhcHBlbnMuXG4gICAqL1xuICBvbkF1dGhTdGF0ZUNoYW5nZShcbiAgICBjYWxsYmFjazogKGV2ZW50OiBBdXRoQ2hhbmdlRXZlbnQsIHNlc3Npb246IFNlc3Npb24gfCBudWxsKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPlxuICApOiB7XG4gICAgZGF0YTogeyBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiB9XG4gIH0ge1xuICAgIGNvbnN0IGlkOiBzdHJpbmcgPSB1dWlkKClcbiAgICBjb25zdCBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiA9IHtcbiAgICAgIGlkLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI3Vuc3Vic2NyaWJlKCknLCAnc3RhdGUgY2hhbmdlIGNhbGxiYWNrIHdpdGggaWQgcmVtb3ZlZCcsIGlkKVxuXG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5kZWxldGUoaWQpXG4gICAgICB9LFxuICAgIH1cblxuICAgIHRoaXMuX2RlYnVnKCcjb25BdXRoU3RhdGVDaGFuZ2UoKScsICdyZWdpc3RlcmVkIGNhbGxiYWNrIHdpdGggaWQnLCBpZClcblxuICAgIHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5zZXQoaWQsIHN1YnNjcmlwdGlvbilcbiAgICA7KGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgdGhpcy5fZW1pdEluaXRpYWxTZXNzaW9uKGlkKVxuICAgICAgfSlcbiAgICB9KSgpXG5cbiAgICByZXR1cm4geyBkYXRhOiB7IHN1YnNjcmlwdGlvbiB9IH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2VtaXRJbml0aWFsU2Vzc2lvbihpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRhdGE6IHsgc2Vzc2lvbiB9LFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgICBhd2FpdCB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZ2V0KGlkKT8uY2FsbGJhY2soJ0lOSVRJQUxfU0VTU0lPTicsIHNlc3Npb24pXG4gICAgICAgIHRoaXMuX2RlYnVnKCdJTklUSUFMX1NFU1NJT04nLCAnY2FsbGJhY2sgaWQnLCBpZCwgJ3Nlc3Npb24nLCBzZXNzaW9uKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5nZXQoaWQpPy5jYWxsYmFjaygnSU5JVElBTF9TRVNTSU9OJywgbnVsbClcbiAgICAgICAgdGhpcy5fZGVidWcoJ0lOSVRJQUxfU0VTU0lPTicsICdjYWxsYmFjayBpZCcsIGlkLCAnZXJyb3InLCBlcnIpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwYXNzd29yZCByZXNldCByZXF1ZXN0IHRvIGFuIGVtYWlsIGFkZHJlc3MuIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAqXG4gICAqIEBwYXJhbSBlbWFpbCBUaGUgZW1haWwgYWRkcmVzcyBvZiB0aGUgdXNlci5cbiAgICogQHBhcmFtIG9wdGlvbnMucmVkaXJlY3RUbyBUaGUgVVJMIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBjbGljayB0aGUgcGFzc3dvcmQgcmVzZXQgbGluay5cbiAgICogQHBhcmFtIG9wdGlvbnMuY2FwdGNoYVRva2VuIFZlcmlmaWNhdGlvbiB0b2tlbiByZWNlaXZlZCB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgY2FwdGNoYSBvbiB0aGUgc2l0ZS5cbiAgICovXG4gIGFzeW5jIHJlc2V0UGFzc3dvcmRGb3JFbWFpbChcbiAgICBlbWFpbDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHJlZGlyZWN0VG8/OiBzdHJpbmdcbiAgICAgIGNhcHRjaGFUb2tlbj86IHN0cmluZ1xuICAgIH0gPSB7fVxuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7fVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwgeyBkYXRhOiBudWxsOyBlcnJvcjogQXV0aEVycm9yIH1cbiAgPiB7XG4gICAgbGV0IGNvZGVDaGFsbGVuZ2U6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2Q6IHN0cmluZyB8IG51bGwgPSBudWxsXG5cbiAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICA7W2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChcbiAgICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgICB0aGlzLnN0b3JhZ2VLZXksXG4gICAgICAgIHRydWUgLy8gaXNQYXNzd29yZFJlY292ZXJ5XG4gICAgICApXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vcmVjb3ZlcmAsIHtcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgIGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLFxuICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMucmVkaXJlY3RUbyxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFsbCB0aGUgaWRlbnRpdGllcyBsaW5rZWQgdG8gYSB1c2VyLlxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlcklkZW50aXRpZXMoKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkZW50aXRpZXM6IFVzZXJJZGVudGl0eVtdXG4gICAgICAgIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHsgZGF0YTogbnVsbDsgZXJyb3I6IEF1dGhFcnJvciB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLmdldFVzZXIoKVxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgcmV0dXJuIHsgZGF0YTogeyBpZGVudGl0aWVzOiBkYXRhLnVzZXIuaWRlbnRpdGllcyA/PyBbXSB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIExpbmtzIGFuIG9hdXRoIGlkZW50aXR5IHRvIGFuIGV4aXN0aW5nIHVzZXIuXG4gICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAqL1xuICBhc3luYyBsaW5rSWRlbnRpdHkoY3JlZGVudGlhbHM6IFNpZ25JbldpdGhPQXV0aENyZWRlbnRpYWxzKTogUHJvbWlzZTxPQXV0aFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgICBjb25zdCB1cmw6IHN0cmluZyA9IGF3YWl0IHRoaXMuX2dldFVybEZvclByb3ZpZGVyKFxuICAgICAgICAgIGAke3RoaXMudXJsfS91c2VyL2lkZW50aXRpZXMvYXV0aG9yaXplYCxcbiAgICAgICAgICBjcmVkZW50aWFscy5wcm92aWRlcixcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZWRpcmVjdFRvOiBjcmVkZW50aWFscy5vcHRpb25zPy5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgc2NvcGVzOiBjcmVkZW50aWFscy5vcHRpb25zPy5zY29wZXMsXG4gICAgICAgICAgICBxdWVyeVBhcmFtczogY3JlZGVudGlhbHMub3B0aW9ucz8ucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICBza2lwQnJvd3NlclJlZGlyZWN0OiB0cnVlLFxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIHVybCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBqd3Q6IGRhdGEuc2Vzc2lvbj8uYWNjZXNzX3Rva2VuID8/IHVuZGVmaW5lZCxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICBpZiAoaXNCcm93c2VyKCkgJiYgIWNyZWRlbnRpYWxzLm9wdGlvbnM/LnNraXBCcm93c2VyUmVkaXJlY3QpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihkYXRhPy51cmwpXG4gICAgICB9XG4gICAgICByZXR1cm4geyBkYXRhOiB7IHByb3ZpZGVyOiBjcmVkZW50aWFscy5wcm92aWRlciwgdXJsOiBkYXRhPy51cmwgfSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgcHJvdmlkZXI6IGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB1cmw6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVW5saW5rcyBhbiBpZGVudGl0eSBmcm9tIGEgdXNlciBieSBkZWxldGluZyBpdC4gVGhlIHVzZXIgd2lsbCBubyBsb25nZXIgYmUgYWJsZSB0byBzaWduIGluIHdpdGggdGhhdCBpZGVudGl0eSBvbmNlIGl0J3MgdW5saW5rZWQuXG4gICAqL1xuICBhc3luYyB1bmxpbmtJZGVudGl0eShpZGVudGl0eTogVXNlcklkZW50aXR5KTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YToge31cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHsgZGF0YTogbnVsbDsgZXJyb3I6IEF1dGhFcnJvciB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdChcbiAgICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICAgICdERUxFVEUnLFxuICAgICAgICAgIGAke3RoaXMudXJsfS91c2VyL2lkZW50aXRpZXMvJHtpZGVudGl0eS5pZGVudGl0eV9pZH1gLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGp3dDogZGF0YS5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4gPz8gdW5kZWZpbmVkLFxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBuZXcgSldULlxuICAgKiBAcGFyYW0gcmVmcmVzaFRva2VuIEEgdmFsaWQgcmVmcmVzaCB0b2tlbiB0aGF0IHdhcyByZXR1cm5lZCBvbiBsb2dpbi5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3JlZnJlc2hBY2Nlc3NUb2tlbihyZWZyZXNoVG9rZW46IHN0cmluZyk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgY29uc3QgZGVidWdOYW1lID0gYCNfcmVmcmVzaEFjY2Vzc1Rva2VuKCR7cmVmcmVzaFRva2VuLnN1YnN0cmluZygwLCA1KX0uLi4pYFxuICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJylcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGFydGVkQXQgPSBEYXRlLm5vdygpXG5cbiAgICAgIC8vIHdpbGwgYXR0ZW1wdCB0byByZWZyZXNoIHRoZSB0b2tlbiB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgIHJldHVybiBhd2FpdCByZXRyeWFibGUoXG4gICAgICAgIGFzeW5jIChhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgaWYgKGF0dGVtcHQgPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcCgyMDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0IC0gMSkpIC8vIDIwMCwgNDAwLCA4MDAsIC4uLlxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3JlZnJlc2hpbmcgYXR0ZW1wdCcsIGF0dGVtcHQpXG5cbiAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1yZWZyZXNoX3Rva2VuYCwge1xuICAgICAgICAgICAgYm9keTogeyByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4gfSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIChhdHRlbXB0LCBlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnN0IG5leHRCYWNrT2ZmSW50ZXJ2YWwgPSAyMDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0KVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBlcnJvciAmJlxuICAgICAgICAgICAgaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikgJiZcbiAgICAgICAgICAgIC8vIHJldHJ5YWJsZSBvbmx5IGlmIHRoZSByZXF1ZXN0IGNhbiBiZSBzZW50IGJlZm9yZSB0aGUgYmFja29mZiBvdmVyZmxvd3MgdGhlIHRpY2sgZHVyYXRpb25cbiAgICAgICAgICAgIERhdGUubm93KCkgKyBuZXh0QmFja09mZkludGVydmFsIC0gc3RhcnRlZEF0IDwgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnJvcilcblxuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwsIHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9pc1ZhbGlkU2Vzc2lvbihtYXliZVNlc3Npb246IHVua25vd24pOiBtYXliZVNlc3Npb24gaXMgU2Vzc2lvbiB7XG4gICAgY29uc3QgaXNWYWxpZFNlc3Npb24gPVxuICAgICAgdHlwZW9mIG1heWJlU2Vzc2lvbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG1heWJlU2Vzc2lvbiAhPT0gbnVsbCAmJlxuICAgICAgJ2FjY2Vzc190b2tlbicgaW4gbWF5YmVTZXNzaW9uICYmXG4gICAgICAncmVmcmVzaF90b2tlbicgaW4gbWF5YmVTZXNzaW9uICYmXG4gICAgICAnZXhwaXJlc19hdCcgaW4gbWF5YmVTZXNzaW9uXG5cbiAgICByZXR1cm4gaXNWYWxpZFNlc3Npb25cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2hhbmRsZVByb3ZpZGVyU2lnbkluKFxuICAgIHByb3ZpZGVyOiBQcm92aWRlcixcbiAgICBvcHRpb25zOiB7XG4gICAgICByZWRpcmVjdFRvPzogc3RyaW5nXG4gICAgICBzY29wZXM/OiBzdHJpbmdcbiAgICAgIHF1ZXJ5UGFyYW1zPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxuICAgICAgc2tpcEJyb3dzZXJSZWRpcmVjdD86IGJvb2xlYW5cbiAgICB9XG4gICkge1xuICAgIGNvbnN0IHVybDogc3RyaW5nID0gYXdhaXQgdGhpcy5fZ2V0VXJsRm9yUHJvdmlkZXIoYCR7dGhpcy51cmx9L2F1dGhvcml6ZWAsIHByb3ZpZGVyLCB7XG4gICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICBzY29wZXM6IG9wdGlvbnMuc2NvcGVzLFxuICAgICAgcXVlcnlQYXJhbXM6IG9wdGlvbnMucXVlcnlQYXJhbXMsXG4gICAgfSlcblxuICAgIHRoaXMuX2RlYnVnKCcjX2hhbmRsZVByb3ZpZGVyU2lnbkluKCknLCAncHJvdmlkZXInLCBwcm92aWRlciwgJ29wdGlvbnMnLCBvcHRpb25zLCAndXJsJywgdXJsKVxuXG4gICAgLy8gdHJ5IHRvIG9wZW4gb24gdGhlIGJyb3dzZXJcbiAgICBpZiAoaXNCcm93c2VyKCkgJiYgIW9wdGlvbnMuc2tpcEJyb3dzZXJSZWRpcmVjdCkge1xuICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZGF0YTogeyBwcm92aWRlciwgdXJsIH0sIGVycm9yOiBudWxsIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvdmVycyB0aGUgc2Vzc2lvbiBmcm9tIExvY2FsU3RvcmFnZSBhbmQgcmVmcmVzaGVzIHRoZSB0b2tlblxuICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBpcyBhc3luYyB0byBhY2NvbW1vZGF0ZSBmb3IgQXN5bmNTdG9yYWdlIGUuZy4gaW4gUmVhY3QgbmF0aXZlLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfcmVjb3ZlckFuZFJlZnJlc2goKSB7XG4gICAgY29uc3QgZGVidWdOYW1lID0gJyNfcmVjb3ZlckFuZFJlZnJlc2goKSdcbiAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY3VycmVudFNlc3Npb24gPSBhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpXG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdzZXNzaW9uIGZyb20gc3RvcmFnZScsIGN1cnJlbnRTZXNzaW9uKVxuXG4gICAgICBpZiAoIXRoaXMuX2lzVmFsaWRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSkge1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdzZXNzaW9uIGlzIG5vdCB2YWxpZCcpXG4gICAgICAgIGlmIChjdXJyZW50U2Vzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRpbWVOb3cgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKVxuICAgICAgY29uc3QgZXhwaXJlc1dpdGhNYXJnaW4gPSAoY3VycmVudFNlc3Npb24uZXhwaXJlc19hdCA/PyBJbmZpbml0eSkgPCB0aW1lTm93ICsgRVhQSVJZX01BUkdJTlxuXG4gICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgZGVidWdOYW1lLFxuICAgICAgICBgc2Vzc2lvbiBoYXMke2V4cGlyZXNXaXRoTWFyZ2luID8gJycgOiAnIG5vdCd9IGV4cGlyZWQgd2l0aCBtYXJnaW4gb2YgJHtFWFBJUllfTUFSR0lOfXNgXG4gICAgICApXG5cbiAgICAgIGlmIChleHBpcmVzV2l0aE1hcmdpbikge1xuICAgICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuICYmIGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pXG5cbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG5cbiAgICAgICAgICAgIGlmICghaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgICAgICAgICAgZGVidWdOYW1lLFxuICAgICAgICAgICAgICAgICdyZWZyZXNoIGZhaWxlZCB3aXRoIGEgbm9uLXJldHJ5YWJsZSBlcnJvciwgcmVtb3ZpbmcgdGhlIHNlc3Npb24nLFxuICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBuZWVkIHRvIHBlcnNpc3QgY3VycmVudFNlc3Npb24gYWdhaW4sIGFzIHdlIGp1c3QgbG9hZGVkIGl0IGZyb21cbiAgICAgICAgLy8gbG9jYWwgc3RvcmFnZTsgcGVyc2lzdGluZyBpdCBhZ2FpbiBtYXkgb3ZlcndyaXRlIGEgdmFsdWUgc2F2ZWQgYnlcbiAgICAgICAgLy8gYW5vdGhlciBjbGllbnQgd2l0aCBhY2Nlc3MgdG8gdGhlIHNhbWUgbG9jYWwgc3RvcmFnZVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgY3VycmVudFNlc3Npb24pXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycilcblxuICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICByZXR1cm5cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9jYWxsUmVmcmVzaFRva2VuKHJlZnJlc2hUb2tlbjogc3RyaW5nKTogUHJvbWlzZTxDYWxsUmVmcmVzaFRva2VuUmVzdWx0PiB7XG4gICAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG4gICAgfVxuXG4gICAgLy8gcmVmcmVzaGluZyBpcyBhbHJlYWR5IGluIHByb2dyZXNzXG4gICAgaWYgKHRoaXMucmVmcmVzaGluZ0RlZmVycmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQucHJvbWlzZVxuICAgIH1cblxuICAgIGNvbnN0IGRlYnVnTmFtZSA9IGAjX2NhbGxSZWZyZXNoVG9rZW4oJHtyZWZyZXNoVG9rZW4uc3Vic3RyaW5nKDAsIDUpfS4uLilgXG5cbiAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpXG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQ8Q2FsbFJlZnJlc2hUb2tlblJlc3VsdD4oKVxuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9yZWZyZXNoQWNjZXNzVG9rZW4ocmVmcmVzaFRva2VuKVxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgaWYgKCFkYXRhLnNlc3Npb24pIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG5cbiAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbilcbiAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdUT0tFTl9SRUZSRVNIRUQnLCBkYXRhLnNlc3Npb24pXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHsgc2Vzc2lvbjogZGF0YS5zZXNzaW9uLCBlcnJvcjogbnVsbCB9XG5cbiAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkLnJlc29sdmUocmVzdWx0KVxuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2Vycm9yJywgZXJyb3IpXG5cbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBzZXNzaW9uOiBudWxsLCBlcnJvciB9XG5cbiAgICAgICAgaWYgKCFpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yKSkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQ/LnJlc29sdmUocmVzdWx0KVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQ/LnJlamVjdChlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkID0gbnVsbFxuICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9ub3RpZnlBbGxTdWJzY3JpYmVycyhcbiAgICBldmVudDogQXV0aENoYW5nZUV2ZW50LFxuICAgIHNlc3Npb246IFNlc3Npb24gfCBudWxsLFxuICAgIGJyb2FkY2FzdCA9IHRydWVcbiAgKSB7XG4gICAgY29uc3QgZGVidWdOYW1lID0gYCNfbm90aWZ5QWxsU3Vic2NyaWJlcnMoJHtldmVudH0pYFxuICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJywgc2Vzc2lvbiwgYGJyb2FkY2FzdCA9ICR7YnJvYWRjYXN0fWApXG5cbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCAmJiBicm9hZGNhc3QpIHtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLnBvc3RNZXNzYWdlKHsgZXZlbnQsIHNlc3Npb24gfSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXJyb3JzOiBhbnlbXSA9IFtdXG4gICAgICBjb25zdCBwcm9taXNlcyA9IEFycmF5LmZyb20odGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLnZhbHVlcygpKS5tYXAoYXN5bmMgKHgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB4LmNhbGxiYWNrKGV2ZW50LCBzZXNzaW9uKVxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChlKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcylcblxuICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcnNbaV0pXG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnJvcnNbMF1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogc2V0IGN1cnJlbnRTZXNzaW9uIGFuZCBjdXJyZW50VXNlclxuICAgKiBwcm9jZXNzIHRvIF9zdGFydEF1dG9SZWZyZXNoVG9rZW4gaWYgcG9zc2libGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3NhdmVTZXNzaW9uKHNlc3Npb246IFNlc3Npb24pIHtcbiAgICB0aGlzLl9kZWJ1ZygnI19zYXZlU2Vzc2lvbigpJywgc2Vzc2lvbilcbiAgICAvLyBfc2F2ZVNlc3Npb24gaXMgYWx3YXlzIGNhbGxlZCB3aGVuZXZlciBhIG5ldyBzZXNzaW9uIGhhcyBiZWVuIGFjcXVpcmVkXG4gICAgLy8gc28gd2UgY2FuIHNhZmVseSBzdXBwcmVzcyB0aGUgd2FybmluZyByZXR1cm5lZCBieSBmdXR1cmUgZ2V0U2Vzc2lvbiBjYWxsc1xuICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWVcbiAgICBhd2FpdCBzZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXksIHNlc3Npb24pXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9yZW1vdmVTZXNzaW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCcjX3JlbW92ZVNlc3Npb24oKScpXG5cbiAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpXG4gICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9PVVQnLCBudWxsKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW55IHJlZ2lzdGVyZWQgdmlzaWJpbGl0eWNoYW5nZSBjYWxsYmFjay5cbiAgICpcbiAgICoge0BzZWUgI3N0YXJ0QXV0b1JlZnJlc2h9XG4gICAqIHtAc2VlICNzdG9wQXV0b1JlZnJlc2h9XG4gICAqL1xuICBwcml2YXRlIF9yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2RlYnVnKCcjX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKScpXG5cbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFja1xuICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IG51bGxcblxuICAgIHRyeSB7XG4gICAgICBpZiAoY2FsbGJhY2sgJiYgaXNCcm93c2VyKCkgJiYgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgY2FsbGJhY2spXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcigncmVtb3ZpbmcgdmlzaWJpbGl0eWNoYW5nZSBjYWxsYmFjayBmYWlsZWQnLCBlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayAjc3RhcnRBdXRvUmVmcmVzaH0uIFVzZSB0aGlzXG4gICAqIHdpdGhpbiB0aGUgbGlicmFyeS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3N0YXJ0QXV0b1JlZnJlc2goKSB7XG4gICAgYXdhaXQgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKClcblxuICAgIHRoaXMuX2RlYnVnKCcjX3N0YXJ0QXV0b1JlZnJlc2goKScpXG5cbiAgICBjb25zdCB0aWNrZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLl9hdXRvUmVmcmVzaFRva2VuVGljaygpLCBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTilcbiAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gdGlja2VyXG5cbiAgICBpZiAodGlja2VyICYmIHR5cGVvZiB0aWNrZXIgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aWNrZXIudW5yZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIHRpY2tlciBpcyBhIE5vZGVKUyBUaW1lb3V0IG9iamVjdCB0aGF0IGhhcyBhbiBgdW5yZWZgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCN0aW1lb3V0dW5yZWZcbiAgICAgIC8vIFdoZW4gYXV0byByZWZyZXNoIGlzIHVzZWQgaW4gTm9kZUpTIChsaWtlIGZvciB0ZXN0aW5nKSB0aGVcbiAgICAgIC8vIGBzZXRJbnRlcnZhbGAgaXMgcHJldmVudGluZyB0aGUgcHJvY2VzcyBmcm9tIGJlaW5nIG1hcmtlZCBhc1xuICAgICAgLy8gZmluaXNoZWQgYW5kIHRlc3RzIHJ1biBlbmRsZXNzbHkuIFRoaXMgY2FuIGJlIHByZXZlbnRlZCBieSBjYWxsaW5nXG4gICAgICAvLyBgdW5yZWYoKWAgb24gdGhlIHJldHVybmVkIG9iamVjdC5cbiAgICAgIHRpY2tlci51bnJlZigpXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGhhcyBubyBjb250ZXh0IG9mIERlbm9cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgRGVuby51bnJlZlRpbWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBzaW1pbGFyIGxpa2UgZm9yIE5vZGVKUywgYnV0IHdpdGggdGhlIERlbm8gQVBJXG4gICAgICAvLyBodHRwczovL2Rlbm8ubGFuZC9hcGlAbGF0ZXN0P3Vuc3RhYmxlJnM9RGVuby51bnJlZlRpbWVyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGhhcyBubyBjb250ZXh0IG9mIERlbm9cbiAgICAgIERlbm8udW5yZWZUaW1lcih0aWNrZXIpXG4gICAgfVxuXG4gICAgLy8gcnVuIHRoZSB0aWNrIGltbWVkaWF0ZWx5LCBidXQgaW4gdGhlIG5leHQgcGFzcyBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0XG4gICAgLy8gI19pbml0aWFsaXplIGNhbiBiZSBhbGxvd2VkIHRvIGNvbXBsZXRlIHdpdGhvdXQgcmVjdXJzaXZlbHkgd2FpdGluZyBvblxuICAgIC8vIGl0c2VsZlxuICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuICAgICAgYXdhaXQgdGhpcy5fYXV0b1JlZnJlc2hUb2tlblRpY2soKVxuICAgIH0sIDApXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgcHJpdmF0ZSBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgI3N0b3BBdXRvUmVmcmVzaH0uIFVzZSB0aGlzXG4gICAqIHdpdGhpbiB0aGUgbGlicmFyeS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3N0b3BBdXRvUmVmcmVzaCgpIHtcbiAgICB0aGlzLl9kZWJ1ZygnI19zdG9wQXV0b1JlZnJlc2goKScpXG5cbiAgICBjb25zdCB0aWNrZXIgPSB0aGlzLmF1dG9SZWZyZXNoVGlja2VyXG4gICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tlciA9IG51bGxcblxuICAgIGlmICh0aWNrZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGlja2VyKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgYW4gYXV0by1yZWZyZXNoIHByb2Nlc3MgaW4gdGhlIGJhY2tncm91bmQuIFRoZSBzZXNzaW9uIGlzIGNoZWNrZWRcbiAgICogZXZlcnkgZmV3IHNlY29uZHMuIENsb3NlIHRvIHRoZSB0aW1lIG9mIGV4cGlyYXRpb24gYSBwcm9jZXNzIGlzIHN0YXJ0ZWQgdG9cbiAgICogcmVmcmVzaCB0aGUgc2Vzc2lvbi4gSWYgcmVmcmVzaGluZyBmYWlscyBpdCB3aWxsIGJlIHJldHJpZWQgZm9yIGFzIGxvbmcgYXNcbiAgICogbmVjZXNzYXJ5LlxuICAgKlxuICAgKiBJZiB5b3Ugc2V0IHRoZSB7QGxpbmsgR29UcnVlQ2xpZW50T3B0aW9ucyNhdXRvUmVmcmVzaFRva2VufSB5b3UgZG9uJ3QgbmVlZFxuICAgKiB0byBjYWxsIHRoaXMgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkIGZvciB5b3UuXG4gICAqXG4gICAqIE9uIGJyb3dzZXJzIHRoZSByZWZyZXNoIHByb2Nlc3Mgd29ya3Mgb25seSB3aGVuIHRoZSB0YWIvd2luZG93IGlzIGluIHRoZVxuICAgKiBmb3JlZ3JvdW5kIHRvIGNvbnNlcnZlIHJlc291cmNlcyBhcyB3ZWxsIGFzIHByZXZlbnQgcmFjZSBjb25kaXRpb25zIGFuZFxuICAgKiBmbG9vZGluZyBhdXRoIHdpdGggcmVxdWVzdHMuIElmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIGFueSBtYW5hZ2VkXG4gICAqIHZpc2liaWxpdHkgY2hhbmdlIGNhbGxiYWNrIHdpbGwgYmUgcmVtb3ZlZCBhbmQgeW91IG11c3QgbWFuYWdlIHZpc2liaWxpdHlcbiAgICogY2hhbmdlcyBvbiB5b3VyIG93bi5cbiAgICpcbiAgICogT24gbm9uLWJyb3dzZXIgcGxhdGZvcm1zIHRoZSByZWZyZXNoIHByb2Nlc3Mgd29ya3MgKmNvbnRpbnVvdXNseSogaW4gdGhlXG4gICAqIGJhY2tncm91bmQsIHdoaWNoIG1heSBub3QgYmUgZGVzaXJhYmxlLiBZb3Ugc2hvdWxkIGhvb2sgaW50byB5b3VyXG4gICAqIHBsYXRmb3JtJ3MgZm9yZWdyb3VuZCBpbmRpY2F0aW9uIG1lY2hhbmlzbSBhbmQgY2FsbCB0aGVzZSBtZXRob2RzXG4gICAqIGFwcHJvcHJpYXRlbHkgdG8gY29uc2VydmUgcmVzb3VyY2VzLlxuICAgKlxuICAgKiB7QHNlZSAjc3RvcEF1dG9SZWZyZXNofVxuICAgKi9cbiAgYXN5bmMgc3RhcnRBdXRvUmVmcmVzaCgpIHtcbiAgICB0aGlzLl9yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKClcbiAgICBhd2FpdCB0aGlzLl9zdGFydEF1dG9SZWZyZXNoKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBhbiBhY3RpdmUgYXV0byByZWZyZXNoIHByb2Nlc3MgcnVubmluZyBpbiB0aGUgYmFja2dyb3VuZCAoaWYgYW55KS5cbiAgICpcbiAgICogSWYgeW91IGNhbGwgdGhpcyBtZXRob2QgYW55IG1hbmFnZWQgdmlzaWJpbGl0eSBjaGFuZ2UgY2FsbGJhY2sgd2lsbCBiZVxuICAgKiByZW1vdmVkIGFuZCB5b3UgbXVzdCBtYW5hZ2UgdmlzaWJpbGl0eSBjaGFuZ2VzIG9uIHlvdXIgb3duLlxuICAgKlxuICAgKiBTZWUge0BsaW5rICNzdGFydEF1dG9SZWZyZXNofSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgYXN5bmMgc3RvcEF1dG9SZWZyZXNoKCkge1xuICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKVxuICAgIGF3YWl0IHRoaXMuX3N0b3BBdXRvUmVmcmVzaCgpXG4gIH1cblxuICAvKipcbiAgICogUnVucyB0aGUgYXV0byByZWZyZXNoIHRva2VuIHRpY2suXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9hdXRvUmVmcmVzaFRva2VuVGljaygpIHtcbiAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgJ2JlZ2luJylcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygwLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGRhdGE6IHsgc2Vzc2lvbiB9LFxuICAgICAgICAgICAgICB9ID0gcmVzdWx0XG5cbiAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uIHx8ICFzZXNzaW9uLnJlZnJlc2hfdG9rZW4gfHwgIXNlc3Npb24uZXhwaXJlc19hdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCAnbm8gc2Vzc2lvbicpXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBzZXNzaW9uIHdpbGwgZXhwaXJlIGluIHRoaXMgbWFueSB0aWNrcyAob3IgaGFzIGFscmVhZHkgZXhwaXJlZCBpZiA8PSAwKVxuICAgICAgICAgICAgICBjb25zdCBleHBpcmVzSW5UaWNrcyA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgICAgICAgKHNlc3Npb24uZXhwaXJlc19hdCAqIDEwMDAgLSBub3cpIC8gQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05cbiAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgIHRoaXMuX2RlYnVnKFxuICAgICAgICAgICAgICAgICcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLFxuICAgICAgICAgICAgICAgIGBhY2Nlc3MgdG9rZW4gZXhwaXJlcyBpbiAke2V4cGlyZXNJblRpY2tzfSB0aWNrcywgYSB0aWNrIGxhc3RzICR7QVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT059bXMsIHJlZnJlc2ggdGhyZXNob2xkIGlzICR7QVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEfSB0aWNrc2BcbiAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgIGlmIChleHBpcmVzSW5UaWNrcyA8PSBBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKHNlc3Npb24ucmVmcmVzaF90b2tlbilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdBdXRvIHJlZnJlc2ggdGljayBmYWlsZWQgd2l0aCBlcnJvci4gVGhpcyBpcyBsaWtlbHkgYSB0cmFuc2llbnQgZXJyb3IuJyxcbiAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgJ2VuZCcpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBpZiAoZS5pc0FjcXVpcmVUaW1lb3V0IHx8IGUgaW5zdGFuY2VvZiBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcikge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnYXV0byByZWZyZXNoIHRva2VuIHRpY2sgbG9jayBub3QgYXZhaWxhYmxlJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBvbiB0aGUgYnJvd3NlciAvIHBsYXRmb3JtLCB3aGljaCBpbi10dXJuIHJ1blxuICAgKiBhbGdvcml0aG1zIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93L3RhYiBhcmUgaW4gZm9yZWdyb3VuZC4gT24gbm9uLWJyb3dzZXJcbiAgICogcGxhdGZvcm1zIGl0IGFzc3VtZXMgYWx3YXlzIGZvcmVncm91bmQuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgIHRoaXMuX2RlYnVnKCcjX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKScpXG5cbiAgICBpZiAoIWlzQnJvd3NlcigpIHx8ICF3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgLy8gaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzIHRoZSByZWZyZXNoIHRva2VuIHRpY2tlciBydW5zIGFsd2F5c1xuICAgICAgICB0aGlzLnN0YXJ0QXV0b1JlZnJlc2goKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrID0gYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlZChmYWxzZSlcblxuICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKVxuXG4gICAgICAvLyBub3cgaW1tZWRpYXRlbHkgY2FsbCB0aGUgdmlzYmlsaXR5IGNoYW5nZWQgY2FsbGJhY2sgdG8gc2V0dXAgd2l0aCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgdmlzYmlsaXR5IHN0YXRlXG4gICAgICBhd2FpdCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2VkKHRydWUpIC8vIGluaXRpYWwgY2FsbFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZScsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayByZWdpc3RlcmVkIHdpdGggYHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJylgLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfb25WaXNpYmlsaXR5Q2hhbmdlZChjYWxsZWRGcm9tSW5pdGlhbGl6ZTogYm9vbGVhbikge1xuICAgIGNvbnN0IG1ldGhvZE5hbWUgPSBgI19vblZpc2liaWxpdHlDaGFuZ2VkKCR7Y2FsbGVkRnJvbUluaXRpYWxpemV9KWBcbiAgICB0aGlzLl9kZWJ1ZyhtZXRob2ROYW1lLCAndmlzaWJpbGl0eVN0YXRlJywgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlKVxuXG4gICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuKSB7XG4gICAgICAgIC8vIGluIGJyb3dzZXIgZW52aXJvbm1lbnRzIHRoZSByZWZyZXNoIHRva2VuIHRpY2tlciBydW5zIG9ubHkgb24gZm9jdXNlZCB0YWJzXG4gICAgICAgIC8vIHdoaWNoIHByZXZlbnRzIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICB0aGlzLl9zdGFydEF1dG9SZWZyZXNoKClcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYWxsZWRGcm9tSW5pdGlhbGl6ZSkge1xuICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCwgaS5lLiB0aGUgYnJvd3NlclxuICAgICAgICAvLyB0cmFuc2l0aW9uZWQgZnJvbSBoaWRkZW4gLT4gdmlzaWJsZSBzbyB3ZSBuZWVkIHRvIHNlZSBpZiB0aGUgc2Vzc2lvblxuICAgICAgICAvLyBzaG91bGQgYmUgcmVjb3ZlcmVkIGltbWVkaWF0ZWx5Li4uIGJ1dCB0byBkbyB0aGF0IHdlIG5lZWQgdG8gYWNxdWlyZVxuICAgICAgICAvLyB0aGUgbG9jayBmaXJzdCBhc3luY2hyb25vdXNseVxuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlICE9PSAndmlzaWJsZScpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKFxuICAgICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAnYWNxdWlyZWQgdGhlIGxvY2sgdG8gcmVjb3ZlciB0aGUgc2Vzc2lvbiwgYnV0IHRoZSBicm93c2VyIHZpc2liaWxpdHlTdGF0ZSBpcyBubyBsb25nZXIgdmlzaWJsZSwgYWJvcnRpbmcnXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIC8vIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQgd2hpbGUgd2FpdGluZyBmb3IgdGhlIGxvY2ssIGFib3J0XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZWNvdmVyIHRoZSBzZXNzaW9uXG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVjb3ZlckFuZFJlZnJlc2goKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJykge1xuICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbikge1xuICAgICAgICB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIHJlbGV2YW50IGxvZ2luIFVSTCBmb3IgYSB0aGlyZC1wYXJ0eSBwcm92aWRlci5cbiAgICogQHBhcmFtIG9wdGlvbnMucmVkaXJlY3RUbyBBIFVSTCBvciBtb2JpbGUgYWRkcmVzcyB0byBzZW5kIHRoZSB1c2VyIHRvIGFmdGVyIHRoZXkgYXJlIGNvbmZpcm1lZC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2NvcGVzIEEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2Ygc2NvcGVzIGdyYW50ZWQgdG8gdGhlIE9BdXRoIGFwcGxpY2F0aW9uLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5xdWVyeVBhcmFtcyBBbiBvYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIGNvbnRhaW5pbmcgcXVlcnkgcGFyYW1ldGVycyBncmFudGVkIHRvIHRoZSBPQXV0aCBhcHBsaWNhdGlvbi5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2dldFVybEZvclByb3ZpZGVyKFxuICAgIHVybDogc3RyaW5nLFxuICAgIHByb3ZpZGVyOiBQcm92aWRlcixcbiAgICBvcHRpb25zOiB7XG4gICAgICByZWRpcmVjdFRvPzogc3RyaW5nXG4gICAgICBzY29wZXM/OiBzdHJpbmdcbiAgICAgIHF1ZXJ5UGFyYW1zPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxuICAgICAgc2tpcEJyb3dzZXJSZWRpcmVjdD86IGJvb2xlYW5cbiAgICB9XG4gICkge1xuICAgIGNvbnN0IHVybFBhcmFtczogc3RyaW5nW10gPSBbYHByb3ZpZGVyPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHByb3ZpZGVyKX1gXVxuICAgIGlmIChvcHRpb25zPy5yZWRpcmVjdFRvKSB7XG4gICAgICB1cmxQYXJhbXMucHVzaChgcmVkaXJlY3RfdG89JHtlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5yZWRpcmVjdFRvKX1gKVxuICAgIH1cbiAgICBpZiAob3B0aW9ucz8uc2NvcGVzKSB7XG4gICAgICB1cmxQYXJhbXMucHVzaChgc2NvcGVzPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMuc2NvcGVzKX1gKVxuICAgIH1cbiAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICBjb25zdCBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKFxuICAgICAgICB0aGlzLnN0b3JhZ2UsXG4gICAgICAgIHRoaXMuc3RvcmFnZUtleVxuICAgICAgKVxuXG4gICAgICBjb25zdCBmbG93UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGNvZGVfY2hhbGxlbmdlOiBgJHtlbmNvZGVVUklDb21wb25lbnQoY29kZUNoYWxsZW5nZSl9YCxcbiAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBgJHtlbmNvZGVVUklDb21wb25lbnQoY29kZUNoYWxsZW5nZU1ldGhvZCl9YCxcbiAgICAgIH0pXG4gICAgICB1cmxQYXJhbXMucHVzaChmbG93UGFyYW1zLnRvU3RyaW5nKCkpXG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5xdWVyeVBhcmFtcykge1xuICAgICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnMucXVlcnlQYXJhbXMpXG4gICAgICB1cmxQYXJhbXMucHVzaChxdWVyeS50b1N0cmluZygpKVxuICAgIH1cbiAgICBpZiAob3B0aW9ucz8uc2tpcEJyb3dzZXJSZWRpcmVjdCkge1xuICAgICAgdXJsUGFyYW1zLnB1c2goYHNraXBfaHR0cF9yZWRpcmVjdD0ke29wdGlvbnMuc2tpcEJyb3dzZXJSZWRpcmVjdH1gKVxuICAgIH1cblxuICAgIHJldHVybiBgJHt1cmx9PyR7dXJsUGFyYW1zLmpvaW4oJyYnKX1gXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF91bmVucm9sbChwYXJhbXM6IE1GQVVuZW5yb2xsUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBVW5lbnJvbGxSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfWAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgand0OiBzZXNzaW9uRGF0YT8uc2Vzc2lvbj8uYWNjZXNzX3Rva2VuLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjZW5yb2xsfVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZW5yb2xsKHBhcmFtczogTUZBRW5yb2xsVE9UUFBhcmFtcyk6IFByb21pc2U8QXV0aE1GQUVucm9sbFRPVFBSZXNwb25zZT5cbiAgcHJpdmF0ZSBhc3luYyBfZW5yb2xsKHBhcmFtczogTUZBRW5yb2xsUGhvbmVQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFFbnJvbGxQaG9uZVJlc3BvbnNlPlxuICBwcml2YXRlIGFzeW5jIF9lbnJvbGwocGFyYW1zOiBNRkFFbnJvbGxQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFFbnJvbGxSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgIGZyaWVuZGx5X25hbWU6IHBhcmFtcy5mcmllbmRseU5hbWUsXG4gICAgICAgICAgZmFjdG9yX3R5cGU6IHBhcmFtcy5mYWN0b3JUeXBlLFxuICAgICAgICAgIC4uLihwYXJhbXMuZmFjdG9yVHlwZSA9PT0gJ3Bob25lJyA/IHsgcGhvbmU6IHBhcmFtcy5waG9uZSB9IDogeyBpc3N1ZXI6IHBhcmFtcy5pc3N1ZXIgfSksXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9mYWN0b3JzYCwge1xuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGp3dDogc2Vzc2lvbkRhdGE/LnNlc3Npb24/LmFjY2Vzc190b2tlbixcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLmZhY3RvclR5cGUgPT09ICd0b3RwJyAmJiBkYXRhPy50b3RwPy5xcl9jb2RlKSB7XG4gICAgICAgICAgZGF0YS50b3RwLnFyX2NvZGUgPSBgZGF0YTppbWFnZS9zdmcreG1sO3V0Zi04LCR7ZGF0YS50b3RwLnFyX2NvZGV9YFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjdmVyaWZ5fVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfdmVyaWZ5KHBhcmFtczogTUZBVmVyaWZ5UGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBVmVyaWZ5UmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdChcbiAgICAgICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICAnUE9TVCcsXG4gICAgICAgICAgICBgJHt0aGlzLnVybH0vZmFjdG9ycy8ke3BhcmFtcy5mYWN0b3JJZH0vdmVyaWZ5YCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYm9keTogeyBjb2RlOiBwYXJhbXMuY29kZSwgY2hhbGxlbmdlX2lkOiBwYXJhbXMuY2hhbGxlbmdlSWQgfSxcbiAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICBqd3Q6IHNlc3Npb25EYXRhPy5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHtcbiAgICAgICAgICAgIGV4cGlyZXNfYXQ6IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApICsgZGF0YS5leHBpcmVzX2luLFxuICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdNRkFfQ0hBTExFTkdFX1ZFUklGSUVEJywgZGF0YSlcblxuICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH1cbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNjaGFsbGVuZ2V9XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9jaGFsbGVuZ2UocGFyYW1zOiBNRkFDaGFsbGVuZ2VQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFDaGFsbGVuZ2VSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdChcbiAgICAgICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICAnUE9TVCcsXG4gICAgICAgICAgICBgJHt0aGlzLnVybH0vZmFjdG9ycy8ke3BhcmFtcy5mYWN0b3JJZH0vY2hhbGxlbmdlYCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYm9keTogeyBjaGFubmVsOiBwYXJhbXMuY2hhbm5lbCB9LFxuICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgIGp3dDogc2Vzc2lvbkRhdGE/LnNlc3Npb24/LmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjY2hhbGxlbmdlQW5kVmVyaWZ5fVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfY2hhbGxlbmdlQW5kVmVyaWZ5KFxuICAgIHBhcmFtczogTUZBQ2hhbGxlbmdlQW5kVmVyaWZ5UGFyYW1zXG4gICk6IFByb21pc2U8QXV0aE1GQVZlcmlmeVJlc3BvbnNlPiB7XG4gICAgLy8gYm90aCBfY2hhbGxlbmdlIGFuZCBfdmVyaWZ5IGluZGVwZW5kZW50bHkgYWNxdWlyZSB0aGUgbG9jaywgc28gbm8gbmVlZFxuICAgIC8vIHRvIGFjcXVpcmUgaXQgaGVyZVxuXG4gICAgY29uc3QgeyBkYXRhOiBjaGFsbGVuZ2VEYXRhLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NoYWxsZW5nZSh7XG4gICAgICBmYWN0b3JJZDogcGFyYW1zLmZhY3RvcklkLFxuICAgIH0pXG4gICAgaWYgKGNoYWxsZW5nZUVycm9yKSB7XG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfVxuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLl92ZXJpZnkoe1xuICAgICAgZmFjdG9ySWQ6IHBhcmFtcy5mYWN0b3JJZCxcbiAgICAgIGNoYWxsZW5nZUlkOiBjaGFsbGVuZ2VEYXRhLmlkLFxuICAgICAgY29kZTogcGFyYW1zLmNvZGUsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjbGlzdEZhY3RvcnN9XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9saXN0RmFjdG9ycygpOiBQcm9taXNlPEF1dGhNRkFMaXN0RmFjdG9yc1Jlc3BvbnNlPiB7XG4gICAgLy8gdXNlICNnZXRVc2VyIGluc3RlYWQgb2YgI19nZXRVc2VyIGFzIHRoZSBmb3JtZXIgYWNxdWlyZXMgYSBsb2NrXG4gICAgY29uc3Qge1xuICAgICAgZGF0YTogeyB1c2VyIH0sXG4gICAgICBlcnJvcjogdXNlckVycm9yLFxuICAgIH0gPSBhd2FpdCB0aGlzLmdldFVzZXIoKVxuICAgIGlmICh1c2VyRXJyb3IpIHtcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiB1c2VyRXJyb3IgfVxuICAgIH1cblxuICAgIGNvbnN0IGZhY3RvcnMgPSB1c2VyPy5mYWN0b3JzIHx8IFtdXG4gICAgY29uc3QgdG90cCA9IGZhY3RvcnMuZmlsdGVyKFxuICAgICAgKGZhY3RvcikgPT4gZmFjdG9yLmZhY3Rvcl90eXBlID09PSAndG90cCcgJiYgZmFjdG9yLnN0YXR1cyA9PT0gJ3ZlcmlmaWVkJ1xuICAgIClcbiAgICBjb25zdCBwaG9uZSA9IGZhY3RvcnMuZmlsdGVyKFxuICAgICAgKGZhY3RvcikgPT4gZmFjdG9yLmZhY3Rvcl90eXBlID09PSAncGhvbmUnICYmIGZhY3Rvci5zdGF0dXMgPT09ICd2ZXJpZmllZCdcbiAgICApXG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YToge1xuICAgICAgICBhbGw6IGZhY3RvcnMsXG4gICAgICAgIHRvdHAsXG4gICAgICAgIHBob25lLFxuICAgICAgfSxcbiAgICAgIGVycm9yOiBudWxsLFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsfVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsKCk6IFByb21pc2U8QXV0aE1GQUdldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkYXRhOiB7IHNlc3Npb24gfSxcbiAgICAgICAgICBlcnJvcjogc2Vzc2lvbkVycm9yLFxuICAgICAgICB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogeyBjdXJyZW50TGV2ZWw6IG51bGwsIG5leHRMZXZlbDogbnVsbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kczogW10gfSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLl9kZWNvZGVKV1Qoc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pXG5cbiAgICAgICAgbGV0IGN1cnJlbnRMZXZlbDogQXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVscyB8IG51bGwgPSBudWxsXG5cbiAgICAgICAgaWYgKHBheWxvYWQuYWFsKSB7XG4gICAgICAgICAgY3VycmVudExldmVsID0gcGF5bG9hZC5hYWxcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuZXh0TGV2ZWw6IEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbHMgfCBudWxsID0gY3VycmVudExldmVsXG5cbiAgICAgICAgY29uc3QgdmVyaWZpZWRGYWN0b3JzID1cbiAgICAgICAgICBzZXNzaW9uLnVzZXIuZmFjdG9ycz8uZmlsdGVyKChmYWN0b3I6IEZhY3RvcikgPT4gZmFjdG9yLnN0YXR1cyA9PT0gJ3ZlcmlmaWVkJykgPz8gW11cblxuICAgICAgICBpZiAodmVyaWZpZWRGYWN0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBuZXh0TGV2ZWwgPSAnYWFsMidcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMgPSBwYXlsb2FkLmFtciB8fCBbXVxuXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgY3VycmVudExldmVsLCBuZXh0TGV2ZWwsIGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMgfSwgZXJyb3I6IG51bGwgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG4iLCAiaW1wb3J0IEdvVHJ1ZUNsaWVudCBmcm9tICcuL0dvVHJ1ZUNsaWVudCdcblxuY29uc3QgQXV0aENsaWVudCA9IEdvVHJ1ZUNsaWVudFxuXG5leHBvcnQgZGVmYXVsdCBBdXRoQ2xpZW50XG4iLCAiaW1wb3J0IHsgQXV0aENsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuaW1wb3J0IHsgU3VwYWJhc2VBdXRoQ2xpZW50T3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCBjbGFzcyBTdXBhYmFzZUF1dGhDbGllbnQgZXh0ZW5kcyBBdXRoQ2xpZW50IHtcbiAgY29uc3RydWN0b3Iob3B0aW9uczogU3VwYWJhc2VBdXRoQ2xpZW50T3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBGdW5jdGlvbnNDbGllbnQgfSBmcm9tICdAc3VwYWJhc2UvZnVuY3Rpb25zLWpzJ1xuaW1wb3J0IHsgQXV0aENoYW5nZUV2ZW50IH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG5pbXBvcnQge1xuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbn0gZnJvbSAnQHN1cGFiYXNlL3Bvc3RncmVzdC1qcydcbmltcG9ydCB7XG4gIFJlYWx0aW1lQ2hhbm5lbCxcbiAgUmVhbHRpbWVDaGFubmVsT3B0aW9ucyxcbiAgUmVhbHRpbWVDbGllbnQsXG4gIFJlYWx0aW1lQ2xpZW50T3B0aW9ucyxcbn0gZnJvbSAnQHN1cGFiYXNlL3JlYWx0aW1lLWpzJ1xuaW1wb3J0IHsgU3RvcmFnZUNsaWVudCBhcyBTdXBhYmFzZVN0b3JhZ2VDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3RvcmFnZS1qcydcbmltcG9ydCB7XG4gIERFRkFVTFRfR0xPQkFMX09QVElPTlMsXG4gIERFRkFVTFRfREJfT1BUSU9OUyxcbiAgREVGQVVMVF9BVVRIX09QVElPTlMsXG4gIERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyxcbn0gZnJvbSAnLi9saWIvY29uc3RhbnRzJ1xuaW1wb3J0IHsgZmV0Y2hXaXRoQXV0aCB9IGZyb20gJy4vbGliL2ZldGNoJ1xuaW1wb3J0IHsgc3RyaXBUcmFpbGluZ1NsYXNoLCBhcHBseVNldHRpbmdEZWZhdWx0cyB9IGZyb20gJy4vbGliL2hlbHBlcnMnXG5pbXBvcnQgeyBTdXBhYmFzZUF1dGhDbGllbnQgfSBmcm9tICcuL2xpYi9TdXBhYmFzZUF1dGhDbGllbnQnXG5pbXBvcnQgeyBGZXRjaCwgR2VuZXJpY1NjaGVtYSwgU3VwYWJhc2VDbGllbnRPcHRpb25zLCBTdXBhYmFzZUF1dGhDbGllbnRPcHRpb25zIH0gZnJvbSAnLi9saWIvdHlwZXMnXG5cbi8qKlxuICogU3VwYWJhc2UgQ2xpZW50LlxuICpcbiAqIEFuIGlzb21vcnBoaWMgSmF2YXNjcmlwdCBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggUG9zdGdyZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1cGFiYXNlQ2xpZW50PFxuICBEYXRhYmFzZSA9IGFueSxcbiAgU2NoZW1hTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIERhdGFiYXNlID0gJ3B1YmxpYycgZXh0ZW5kcyBrZXlvZiBEYXRhYmFzZVxuICAgID8gJ3B1YmxpYydcbiAgICA6IHN0cmluZyAmIGtleW9mIERhdGFiYXNlLFxuICBTY2hlbWEgZXh0ZW5kcyBHZW5lcmljU2NoZW1hID0gRGF0YWJhc2VbU2NoZW1hTmFtZV0gZXh0ZW5kcyBHZW5lcmljU2NoZW1hXG4gICAgPyBEYXRhYmFzZVtTY2hlbWFOYW1lXVxuICAgIDogYW55XG4+IHtcbiAgLyoqXG4gICAqIFN1cGFiYXNlIEF1dGggYWxsb3dzIHlvdSB0byBjcmVhdGUgYW5kIG1hbmFnZSB1c2VyIHNlc3Npb25zIGZvciBhY2Nlc3MgdG8gZGF0YSB0aGF0IGlzIHNlY3VyZWQgYnkgYWNjZXNzIHBvbGljaWVzLlxuICAgKi9cbiAgYXV0aDogU3VwYWJhc2VBdXRoQ2xpZW50XG4gIHJlYWx0aW1lOiBSZWFsdGltZUNsaWVudFxuXG4gIHByb3RlY3RlZCByZWFsdGltZVVybDogc3RyaW5nXG4gIHByb3RlY3RlZCBhdXRoVXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIHN0b3JhZ2VVcmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgZnVuY3Rpb25zVXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIHJlc3Q6IFBvc3RncmVzdENsaWVudDxEYXRhYmFzZSwgU2NoZW1hTmFtZSwgU2NoZW1hPlxuICBwcm90ZWN0ZWQgc3RvcmFnZUtleTogc3RyaW5nXG4gIHByb3RlY3RlZCBmZXRjaD86IEZldGNoXG4gIHByb3RlY3RlZCBjaGFuZ2VkQWNjZXNzVG9rZW4/OiBzdHJpbmdcbiAgcHJvdGVjdGVkIGFjY2Vzc1Rva2VuPzogKCkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsPlxuXG4gIHByb3RlY3RlZCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBjbGllbnQgZm9yIHVzZSBpbiB0aGUgYnJvd3Nlci5cbiAgICogQHBhcmFtIHN1cGFiYXNlVXJsIFRoZSB1bmlxdWUgU3VwYWJhc2UgVVJMIHdoaWNoIGlzIHN1cHBsaWVkIHdoZW4geW91IGNyZWF0ZSBhIG5ldyBwcm9qZWN0IGluIHlvdXIgcHJvamVjdCBkYXNoYm9hcmQuXG4gICAqIEBwYXJhbSBzdXBhYmFzZUtleSBUaGUgdW5pcXVlIFN1cGFiYXNlIEtleSB3aGljaCBpcyBzdXBwbGllZCB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgcHJvamVjdCBpbiB5b3VyIHByb2plY3QgZGFzaGJvYXJkLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kYi5zY2hlbWEgWW91IGNhbiBzd2l0Y2ggaW4gYmV0d2VlbiBzY2hlbWFzLiBUaGUgc2NoZW1hIG5lZWRzIHRvIGJlIG9uIHRoZSBsaXN0IG9mIGV4cG9zZWQgc2NoZW1hcyBpbnNpZGUgU3VwYWJhc2UuXG4gICAqIEBwYXJhbSBvcHRpb25zLmF1dGguYXV0b1JlZnJlc2hUb2tlbiBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZWZyZXNoIHRoZSB0b2tlbiBiZWZvcmUgZXhwaXJpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zLmF1dGgucGVyc2lzdFNlc3Npb24gU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgc2F2ZSB0aGUgdXNlciBzZXNzaW9uIGludG8gbG9jYWwgc3RvcmFnZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuYXV0aC5kZXRlY3RTZXNzaW9uSW5VcmwgU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgZGV0ZWN0cyBPQXV0aCBncmFudHMgaW4gdGhlIFVSTCBhbmQgc2lnbnMgaW4gdGhlIHVzZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlYWx0aW1lIE9wdGlvbnMgcGFzc2VkIGFsb25nIHRvIHJlYWx0aW1lLWpzIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5nbG9iYWwuZmV0Y2ggQSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24uXG4gICAqIEBwYXJhbSBvcHRpb25zLmdsb2JhbC5oZWFkZXJzIEFueSBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gc2VuZCB3aXRoIGVhY2ggbmV0d29yayByZXF1ZXN0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIHN1cGFiYXNlVXJsOiBzdHJpbmcsXG4gICAgcHJvdGVjdGVkIHN1cGFiYXNlS2V5OiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IFN1cGFiYXNlQ2xpZW50T3B0aW9uczxTY2hlbWFOYW1lPlxuICApIHtcbiAgICBpZiAoIXN1cGFiYXNlVXJsKSB0aHJvdyBuZXcgRXJyb3IoJ3N1cGFiYXNlVXJsIGlzIHJlcXVpcmVkLicpXG4gICAgaWYgKCFzdXBhYmFzZUtleSkgdGhyb3cgbmV3IEVycm9yKCdzdXBhYmFzZUtleSBpcyByZXF1aXJlZC4nKVxuXG4gICAgY29uc3QgX3N1cGFiYXNlVXJsID0gc3RyaXBUcmFpbGluZ1NsYXNoKHN1cGFiYXNlVXJsKVxuXG4gICAgdGhpcy5yZWFsdGltZVVybCA9IGAke19zdXBhYmFzZVVybH0vcmVhbHRpbWUvdjFgLnJlcGxhY2UoL15odHRwL2ksICd3cycpXG4gICAgdGhpcy5hdXRoVXJsID0gYCR7X3N1cGFiYXNlVXJsfS9hdXRoL3YxYFxuICAgIHRoaXMuc3RvcmFnZVVybCA9IGAke19zdXBhYmFzZVVybH0vc3RvcmFnZS92MWBcbiAgICB0aGlzLmZ1bmN0aW9uc1VybCA9IGAke19zdXBhYmFzZVVybH0vZnVuY3Rpb25zL3YxYFxuXG4gICAgLy8gZGVmYXVsdCBzdG9yYWdlIGtleSB1c2VzIHRoZSBzdXBhYmFzZSBwcm9qZWN0IHJlZiBhcyBhIG5hbWVzcGFjZVxuICAgIGNvbnN0IGRlZmF1bHRTdG9yYWdlS2V5ID0gYHNiLSR7bmV3IFVSTCh0aGlzLmF1dGhVcmwpLmhvc3RuYW1lLnNwbGl0KCcuJylbMF19LWF1dGgtdG9rZW5gXG4gICAgY29uc3QgREVGQVVMVFMgPSB7XG4gICAgICBkYjogREVGQVVMVF9EQl9PUFRJT05TLFxuICAgICAgcmVhbHRpbWU6IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyxcbiAgICAgIGF1dGg6IHsgLi4uREVGQVVMVF9BVVRIX09QVElPTlMsIHN0b3JhZ2VLZXk6IGRlZmF1bHRTdG9yYWdlS2V5IH0sXG4gICAgICBnbG9iYWw6IERFRkFVTFRfR0xPQkFMX09QVElPTlMsXG4gICAgfVxuXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBhcHBseVNldHRpbmdEZWZhdWx0cyhvcHRpb25zID8/IHt9LCBERUZBVUxUUylcblxuICAgIHRoaXMuc3RvcmFnZUtleSA9IHNldHRpbmdzLmF1dGguc3RvcmFnZUtleSA/PyAnJ1xuICAgIHRoaXMuaGVhZGVycyA9IHNldHRpbmdzLmdsb2JhbC5oZWFkZXJzID8/IHt9XG5cbiAgICBpZiAoIXNldHRpbmdzLmFjY2Vzc1Rva2VuKSB7XG4gICAgICB0aGlzLmF1dGggPSB0aGlzLl9pbml0U3VwYWJhc2VBdXRoQ2xpZW50KFxuICAgICAgICBzZXR0aW5ncy5hdXRoID8/IHt9LFxuICAgICAgICB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHNldHRpbmdzLmdsb2JhbC5mZXRjaFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gc2V0dGluZ3MuYWNjZXNzVG9rZW5cblxuICAgICAgdGhpcy5hdXRoID0gbmV3IFByb3h5PFN1cGFiYXNlQXV0aENsaWVudD4oe30gYXMgYW55LCB7XG4gICAgICAgIGdldDogKF8sIHByb3ApID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQHN1cGFiYXNlL3N1cGFiYXNlLWpzOiBTdXBhYmFzZSBDbGllbnQgaXMgY29uZmlndXJlZCB3aXRoIHRoZSBhY2Nlc3NUb2tlbiBvcHRpb24sIGFjY2Vzc2luZyBzdXBhYmFzZS5hdXRoLiR7U3RyaW5nKFxuICAgICAgICAgICAgICBwcm9wXG4gICAgICAgICAgICApfSBpcyBub3QgcG9zc2libGVgXG4gICAgICAgICAgKVxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmZldGNoID0gZmV0Y2hXaXRoQXV0aChzdXBhYmFzZUtleSwgdGhpcy5fZ2V0QWNjZXNzVG9rZW4uYmluZCh0aGlzKSwgc2V0dGluZ3MuZ2xvYmFsLmZldGNoKVxuICAgIHRoaXMucmVhbHRpbWUgPSB0aGlzLl9pbml0UmVhbHRpbWVDbGllbnQoe1xuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgYWNjZXNzVG9rZW46IHRoaXMuX2dldEFjY2Vzc1Rva2VuLmJpbmQodGhpcyksXG4gICAgICAuLi5zZXR0aW5ncy5yZWFsdGltZSxcbiAgICB9KVxuICAgIHRoaXMucmVzdCA9IG5ldyBQb3N0Z3Jlc3RDbGllbnQoYCR7X3N1cGFiYXNlVXJsfS9yZXN0L3YxYCwge1xuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgc2NoZW1hOiBzZXR0aW5ncy5kYi5zY2hlbWEsXG4gICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICB9KVxuXG4gICAgaWYgKCFzZXR0aW5ncy5hY2Nlc3NUb2tlbikge1xuICAgICAgdGhpcy5fbGlzdGVuRm9yQXV0aEV2ZW50cygpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN1cGFiYXNlIEZ1bmN0aW9ucyBhbGxvd3MgeW91IHRvIGRlcGxveSBhbmQgaW52b2tlIGVkZ2UgZnVuY3Rpb25zLlxuICAgKi9cbiAgZ2V0IGZ1bmN0aW9ucygpOiBGdW5jdGlvbnNDbGllbnQge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25zQ2xpZW50KHRoaXMuZnVuY3Rpb25zVXJsLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBjdXN0b21GZXRjaDogdGhpcy5mZXRjaCxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFN1cGFiYXNlIFN0b3JhZ2UgYWxsb3dzIHlvdSB0byBtYW5hZ2UgdXNlci1nZW5lcmF0ZWQgY29udGVudCwgc3VjaCBhcyBwaG90b3Mgb3IgdmlkZW9zLlxuICAgKi9cbiAgZ2V0IHN0b3JhZ2UoKTogU3VwYWJhc2VTdG9yYWdlQ2xpZW50IHtcbiAgICByZXR1cm4gbmV3IFN1cGFiYXNlU3RvcmFnZUNsaWVudCh0aGlzLnN0b3JhZ2VVcmwsIHRoaXMuaGVhZGVycywgdGhpcy5mZXRjaClcbiAgfVxuXG4gIC8vIE5PVEU6IHNpZ25hdHVyZXMgbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCBQb3N0Z3Jlc3RDbGllbnQuZnJvbVxuICBmcm9tPFxuICAgIFRhYmxlTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFNjaGVtYVsnVGFibGVzJ10sXG4gICAgVGFibGUgZXh0ZW5kcyBTY2hlbWFbJ1RhYmxlcyddW1RhYmxlTmFtZV1cbiAgPihyZWxhdGlvbjogVGFibGVOYW1lKTogUG9zdGdyZXN0UXVlcnlCdWlsZGVyPFNjaGVtYSwgVGFibGUsIFRhYmxlTmFtZT5cbiAgZnJvbTxWaWV3TmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFNjaGVtYVsnVmlld3MnXSwgVmlldyBleHRlbmRzIFNjaGVtYVsnVmlld3MnXVtWaWV3TmFtZV0+KFxuICAgIHJlbGF0aW9uOiBWaWV3TmFtZVxuICApOiBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8U2NoZW1hLCBWaWV3LCBWaWV3TmFtZT5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBxdWVyeSBvbiBhIHRhYmxlIG9yIGEgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHJlbGF0aW9uIC0gVGhlIHRhYmxlIG9yIHZpZXcgbmFtZSB0byBxdWVyeVxuICAgKi9cbiAgZnJvbShyZWxhdGlvbjogc3RyaW5nKTogUG9zdGdyZXN0UXVlcnlCdWlsZGVyPFNjaGVtYSwgYW55LCBhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LmZyb20ocmVsYXRpb24pXG4gIH1cblxuICAvLyBOT1RFOiBzaWduYXR1cmVzIG11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggUG9zdGdyZXN0Q2xpZW50LnNjaGVtYVxuICAvKipcbiAgICogU2VsZWN0IGEgc2NoZW1hIHRvIHF1ZXJ5IG9yIHBlcmZvcm0gYW4gZnVuY3Rpb24gKHJwYykgY2FsbC5cbiAgICpcbiAgICogVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuICAgKlxuICAgKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSB0byBxdWVyeVxuICAgKi9cbiAgc2NoZW1hPER5bmFtaWNTY2hlbWEgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZT4oXG4gICAgc2NoZW1hOiBEeW5hbWljU2NoZW1hXG4gICk6IFBvc3RncmVzdENsaWVudDxcbiAgICBEYXRhYmFzZSxcbiAgICBEeW5hbWljU2NoZW1hLFxuICAgIERhdGFiYXNlW0R5bmFtaWNTY2hlbWFdIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSA/IERhdGFiYXNlW0R5bmFtaWNTY2hlbWFdIDogYW55XG4gID4ge1xuICAgIHJldHVybiB0aGlzLnJlc3Quc2NoZW1hPER5bmFtaWNTY2hlbWE+KHNjaGVtYSlcbiAgfVxuXG4gIC8vIE5PVEU6IHNpZ25hdHVyZXMgbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCBQb3N0Z3Jlc3RDbGllbnQucnBjXG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgZnVuY3Rpb24gY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIG5hbWUgdG8gY2FsbFxuICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24gY2FsbFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgKiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG4gICAqIEBwYXJhbSBvcHRpb25zLmdldCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGhcbiAgICogcmVhZC1vbmx5IGFjY2VzcyBtb2RlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgcm93cyByZXR1cm5lZCBieSB0aGVcbiAgICogZnVuY3Rpb24uIE9ubHkgYXBwbGljYWJsZSBmb3IgW3NldC1yZXR1cm5pbmdcbiAgICogZnVuY3Rpb25zXShodHRwczovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzL2N1cnJlbnQvZnVuY3Rpb25zLXNyZi5odG1sKS5cbiAgICpcbiAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgKiBob29kLlxuICAgKlxuICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgKlxuICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAqIG51bWJlcnMuXG4gICAqL1xuICBycGM8Rm5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgU2NoZW1hWydGdW5jdGlvbnMnXSwgRm4gZXh0ZW5kcyBTY2hlbWFbJ0Z1bmN0aW9ucyddW0ZuTmFtZV0+KFxuICAgIGZuOiBGbk5hbWUsXG4gICAgYXJnczogRm5bJ0FyZ3MnXSA9IHt9LFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGhlYWQ/OiBib29sZWFuXG4gICAgICBnZXQ/OiBib29sZWFuXG4gICAgICBjb3VudD86ICdleGFjdCcgfCAncGxhbm5lZCcgfCAnZXN0aW1hdGVkJ1xuICAgIH0gPSB7fVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFxuICAgIFNjaGVtYSxcbiAgICBGblsnUmV0dXJucyddIGV4dGVuZHMgYW55W11cbiAgICAgID8gRm5bJ1JldHVybnMnXVtudW1iZXJdIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICAgICAgPyBGblsnUmV0dXJucyddW251bWJlcl1cbiAgICAgICAgOiBuZXZlclxuICAgICAgOiBuZXZlcixcbiAgICBGblsnUmV0dXJucyddLFxuICAgIEZuTmFtZSxcbiAgICBudWxsXG4gID4ge1xuICAgIHJldHVybiB0aGlzLnJlc3QucnBjKGZuLCBhcmdzLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSZWFsdGltZSBjaGFubmVsIHdpdGggQnJvYWRjYXN0LCBQcmVzZW5jZSwgYW5kIFBvc3RncmVzIENoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cbiAgICpcbiAgICovXG4gIGNoYW5uZWwobmFtZTogc3RyaW5nLCBvcHRzOiBSZWFsdGltZUNoYW5uZWxPcHRpb25zID0geyBjb25maWc6IHt9IH0pOiBSZWFsdGltZUNoYW5uZWwge1xuICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLmNoYW5uZWwobmFtZSwgb3B0cylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBSZWFsdGltZSBjaGFubmVscy5cbiAgICovXG4gIGdldENoYW5uZWxzKCk6IFJlYWx0aW1lQ2hhbm5lbFtdIHtcbiAgICByZXR1cm4gdGhpcy5yZWFsdGltZS5nZXRDaGFubmVscygpXG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIFJlYWx0aW1lIGNoYW5uZWwgZnJvbSBSZWFsdGltZSBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhbHRpbWVDaGFubmVsfSBjaGFubmVsIC0gVGhlIG5hbWUgb2YgdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG4gICAqXG4gICAqL1xuICByZW1vdmVDaGFubmVsKGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCk6IFByb21pc2U8J29rJyB8ICd0aW1lZCBvdXQnIHwgJ2Vycm9yJz4ge1xuICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLnJlbW92ZUNoYW5uZWwoY2hhbm5lbClcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgYWxsIFJlYWx0aW1lIGNoYW5uZWxzIGZyb20gUmVhbHRpbWUgY2xpZW50LlxuICAgKi9cbiAgcmVtb3ZlQWxsQ2hhbm5lbHMoKTogUHJvbWlzZTwoJ29rJyB8ICd0aW1lZCBvdXQnIHwgJ2Vycm9yJylbXT4ge1xuICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLnJlbW92ZUFsbENoYW5uZWxzKClcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2dldEFjY2Vzc1Rva2VuKCkge1xuICAgIGlmICh0aGlzLmFjY2Vzc1Rva2VuKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5hY2Nlc3NUb2tlbigpXG4gICAgfVxuXG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCB0aGlzLmF1dGguZ2V0U2Vzc2lvbigpXG5cbiAgICByZXR1cm4gZGF0YS5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4gPz8gbnVsbFxuICB9XG5cbiAgcHJpdmF0ZSBfaW5pdFN1cGFiYXNlQXV0aENsaWVudChcbiAgICB7XG4gICAgICBhdXRvUmVmcmVzaFRva2VuLFxuICAgICAgcGVyc2lzdFNlc3Npb24sXG4gICAgICBkZXRlY3RTZXNzaW9uSW5VcmwsXG4gICAgICBzdG9yYWdlLFxuICAgICAgc3RvcmFnZUtleSxcbiAgICAgIGZsb3dUeXBlLFxuICAgICAgbG9jayxcbiAgICAgIGRlYnVnLFxuICAgIH06IFN1cGFiYXNlQXV0aENsaWVudE9wdGlvbnMsXG4gICAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gICAgZmV0Y2g/OiBGZXRjaFxuICApIHtcbiAgICBjb25zdCBhdXRoSGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLnN1cGFiYXNlS2V5fWAsXG4gICAgICBhcGlrZXk6IGAke3RoaXMuc3VwYWJhc2VLZXl9YCxcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdXBhYmFzZUF1dGhDbGllbnQoe1xuICAgICAgdXJsOiB0aGlzLmF1dGhVcmwsXG4gICAgICBoZWFkZXJzOiB7IC4uLmF1dGhIZWFkZXJzLCAuLi5oZWFkZXJzIH0sXG4gICAgICBzdG9yYWdlS2V5OiBzdG9yYWdlS2V5LFxuICAgICAgYXV0b1JlZnJlc2hUb2tlbixcbiAgICAgIHBlcnNpc3RTZXNzaW9uLFxuICAgICAgZGV0ZWN0U2Vzc2lvbkluVXJsLFxuICAgICAgc3RvcmFnZSxcbiAgICAgIGZsb3dUeXBlLFxuICAgICAgbG9jayxcbiAgICAgIGRlYnVnLFxuICAgICAgZmV0Y2gsXG4gICAgICAvLyBhdXRoIGNoZWNrcyBpZiB0aGVyZSBpcyBhIGN1c3RvbSBhdXRob3JpemFpdG9uIGhlYWRlciB1c2luZyB0aGlzIGZsYWdcbiAgICAgIC8vIHNvIGl0IGtub3dzIHdoZXRoZXIgdG8gcmV0dXJuIGFuIGVycm9yIHdoZW4gZ2V0VXNlciBpcyBjYWxsZWQgd2l0aCBubyBzZXNzaW9uXG4gICAgICBoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyOiAnQXV0aG9yaXphdGlvbicgaW4gdGhpcy5oZWFkZXJzLFxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIF9pbml0UmVhbHRpbWVDbGllbnQob3B0aW9uczogUmVhbHRpbWVDbGllbnRPcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSZWFsdGltZUNsaWVudCh0aGlzLnJlYWx0aW1lVXJsLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcGFyYW1zOiB7IC4uLnsgYXBpa2V5OiB0aGlzLnN1cGFiYXNlS2V5IH0sIC4uLm9wdGlvbnM/LnBhcmFtcyB9LFxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIF9saXN0ZW5Gb3JBdXRoRXZlbnRzKCkge1xuICAgIGxldCBkYXRhID0gdGhpcy5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKChldmVudCwgc2Vzc2lvbikgPT4ge1xuICAgICAgdGhpcy5faGFuZGxlVG9rZW5DaGFuZ2VkKGV2ZW50LCAnQ0xJRU5UJywgc2Vzc2lvbj8uYWNjZXNzX3Rva2VuKVxuICAgIH0pXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIHByaXZhdGUgX2hhbmRsZVRva2VuQ2hhbmdlZChcbiAgICBldmVudDogQXV0aENoYW5nZUV2ZW50LFxuICAgIHNvdXJjZTogJ0NMSUVOVCcgfCAnU1RPUkFHRScsXG4gICAgdG9rZW4/OiBzdHJpbmdcbiAgKSB7XG4gICAgaWYgKFxuICAgICAgKGV2ZW50ID09PSAnVE9LRU5fUkVGUkVTSEVEJyB8fCBldmVudCA9PT0gJ1NJR05FRF9JTicpICYmXG4gICAgICB0aGlzLmNoYW5nZWRBY2Nlc3NUb2tlbiAhPT0gdG9rZW5cbiAgICApIHtcbiAgICAgIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuID0gdG9rZW5cbiAgICB9IGVsc2UgaWYgKGV2ZW50ID09PSAnU0lHTkVEX09VVCcpIHtcbiAgICAgIHRoaXMucmVhbHRpbWUuc2V0QXV0aCgpXG4gICAgICBpZiAoc291cmNlID09ICdTVE9SQUdFJykgdGhpcy5hdXRoLnNpZ25PdXQoKVxuICAgICAgdGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gPSB1bmRlZmluZWRcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgU3VwYWJhc2VDbGllbnQgZnJvbSAnLi9TdXBhYmFzZUNsaWVudCdcbmltcG9ydCB0eXBlIHsgR2VuZXJpY1NjaGVtYSwgU3VwYWJhc2VDbGllbnRPcHRpb25zIH0gZnJvbSAnLi9saWIvdHlwZXMnXG5cbmV4cG9ydCAqIGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuZXhwb3J0IHR5cGUgeyBVc2VyIGFzIEF1dGhVc2VyLCBTZXNzaW9uIGFzIEF1dGhTZXNzaW9uIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG5leHBvcnQge1xuICB0eXBlIFBvc3RncmVzdFJlc3BvbnNlLFxuICB0eXBlIFBvc3RncmVzdFNpbmdsZVJlc3BvbnNlLFxuICB0eXBlIFBvc3RncmVzdE1heWJlU2luZ2xlUmVzcG9uc2UsXG4gIFBvc3RncmVzdEVycm9yLFxufSBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJ1xuZXhwb3J0IHtcbiAgRnVuY3Rpb25zSHR0cEVycm9yLFxuICBGdW5jdGlvbnNGZXRjaEVycm9yLFxuICBGdW5jdGlvbnNSZWxheUVycm9yLFxuICBGdW5jdGlvbnNFcnJvcixcbiAgdHlwZSBGdW5jdGlvbkludm9rZU9wdGlvbnMsXG4gIEZ1bmN0aW9uUmVnaW9uLFxufSBmcm9tICdAc3VwYWJhc2UvZnVuY3Rpb25zLWpzJ1xuZXhwb3J0ICogZnJvbSAnQHN1cGFiYXNlL3JlYWx0aW1lLWpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdXBhYmFzZUNsaWVudCB9IGZyb20gJy4vU3VwYWJhc2VDbGllbnQnXG5leHBvcnQgdHlwZSB7IFN1cGFiYXNlQ2xpZW50T3B0aW9ucywgUXVlcnlSZXN1bHQsIFF1ZXJ5RGF0YSwgUXVlcnlFcnJvciB9IGZyb20gJy4vbGliL3R5cGVzJ1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU3VwYWJhc2UgQ2xpZW50LlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQ2xpZW50ID0gPFxuICBEYXRhYmFzZSA9IGFueSxcbiAgU2NoZW1hTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIERhdGFiYXNlID0gJ3B1YmxpYycgZXh0ZW5kcyBrZXlvZiBEYXRhYmFzZVxuICAgID8gJ3B1YmxpYydcbiAgICA6IHN0cmluZyAmIGtleW9mIERhdGFiYXNlLFxuICBTY2hlbWEgZXh0ZW5kcyBHZW5lcmljU2NoZW1hID0gRGF0YWJhc2VbU2NoZW1hTmFtZV0gZXh0ZW5kcyBHZW5lcmljU2NoZW1hXG4gICAgPyBEYXRhYmFzZVtTY2hlbWFOYW1lXVxuICAgIDogYW55XG4+KFxuICBzdXBhYmFzZVVybDogc3RyaW5nLFxuICBzdXBhYmFzZUtleTogc3RyaW5nLFxuICBvcHRpb25zPzogU3VwYWJhc2VDbGllbnRPcHRpb25zPFNjaGVtYU5hbWU+XG4pOiBTdXBhYmFzZUNsaWVudDxEYXRhYmFzZSwgU2NoZW1hTmFtZSwgU2NoZW1hPiA9PiB7XG4gIHJldHVybiBuZXcgU3VwYWJhc2VDbGllbnQ8RGF0YWJhc2UsIFNjaGVtYU5hbWUsIFNjaGVtYT4oc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5LCBvcHRpb25zKVxufVxuIiwgIi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBjaHVua2luZyB0ZXh0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2h1bmtTZXR0aW5ncyB7XG5cdGNodW5rU2l6ZTogbnVtYmVyOyAgICAgICAvLyBTaXplIG9mIGVhY2ggY2h1bmsgaW4gY2hhcmFjdGVyc1xuXHRjaHVua092ZXJsYXA6IG51bWJlcjsgICAgLy8gT3ZlcmxhcCBiZXR3ZWVuIGNodW5rc1xuXHRtaW5DaHVua1NpemU6IG51bWJlcjsgICAgLy8gTWluaW11bSBzaXplIG9mIGEgY2h1bmtcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBleGNsdWRlZCBwYXRoc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEV4Y2x1c2lvblNldHRpbmdzIHtcblx0ZXhjbHVkZWRGb2xkZXJzOiBzdHJpbmdbXTsgICAgICAvLyBGb2xkZXJzIHRvIGV4Y2x1ZGUgZnJvbSBwcm9jZXNzaW5nXG5cdGV4Y2x1ZGVkRmlsZVR5cGVzOiBzdHJpbmdbXTsgICAgLy8gRmlsZSBleHRlbnNpb25zIHRvIGV4Y2x1ZGVcblx0ZXhjbHVkZWRGaWxlUHJlZml4ZXM6IHN0cmluZ1tdOyAvLyBGaWxlIG5hbWUgcHJlZml4ZXMgdG8gZXhjbHVkZVxuXHRleGNsdWRlZEZpbGVzOiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBPcGVuQUkgQVBJIHNldHRpbmdzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3BlbkFJU2V0dGluZ3Mge1xuXHRhcGlLZXk6IHN0cmluZzsgICAgICAgICAvLyBBUEkga2V5IGZvciBPcGVuQUlcblx0bW9kZWw6IHN0cmluZzsgICAgICAgICAgLy8gTW9kZWwgdG8gdXNlIGZvciBlbWJlZGRpbmdzXG5cdG1heFRva2VuczogbnVtYmVyOyAgICAgIC8vIE1heGltdW0gdG9rZW5zIGZvciBhIHNpbmdsZSByZXF1ZXN0XG5cdHRlbXBlcmF0dXJlOiBudW1iZXI7ICAgIC8vIFNhbXBsaW5nIHRlbXBlcmF0dXJlIGZvciBnZW5lcmF0aW9uXG59XG5cbi8qKlxuICogU3VwYWJhc2UgY29ubmVjdGlvbiBzZXR0aW5nc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFN1cGFiYXNlU2V0dGluZ3Mge1xuXHR1cmw6IHN0cmluZzsgICAgICAgICAgICAgIC8vIFN1cGFiYXNlIHByb2plY3QgVVJMXG5cdGFwaUtleTogc3RyaW5nOyAgICAgICAgICAvLyBTdXBhYmFzZSBBUEkga2V5XG5cdGluaXRpYWxpemVkPzogYm9vbGVhbjsgICAgLy8gV2hldGhlciBkYXRhYmFzZSBpcyBpbml0aWFsaXplZFxuXHRsYXN0U2V0dXBBdHRlbXB0PzogbnVtYmVyOyAvLyBUaW1lc3RhbXAgb2YgbGFzdCBzZXR1cCBhdHRlbXB0XG5cdHNldHVwUmV0cmllcz86IG51bWJlcjsgICAgLy8gTnVtYmVyIG9mIHNldHVwIGF0dGVtcHRzXG59XG5cbi8qKlxuICogUHJvY2Vzc2luZyBxdWV1ZSBzZXR0aW5nc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXVlU2V0dGluZ3Mge1xuXHRtYXhDb25jdXJyZW50OiBudW1iZXI7ICAvLyBNYXhpbXVtIGNvbmN1cnJlbnQgdGFza3Ncblx0cmV0cnlBdHRlbXB0czogbnVtYmVyOyAgLy8gTnVtYmVyIG9mIHJldHJ5IGF0dGVtcHRzXG5cdHJldHJ5RGVsYXk6IG51bWJlcjsgICAgIC8vIERlbGF5IGJldHdlZW4gcmV0cmllcyBpbiBtaWxsaXNlY29uZHNcbn1cblxuLyoqXG4gKiBEZWJ1ZyBhbmQgbG9nZ2luZyBzZXR0aW5nc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIERlYnVnU2V0dGluZ3Mge1xuXHRlbmFibGVEZWJ1Z0xvZ3M6IGJvb2xlYW47ICAvLyBFbmFibGUgZGV0YWlsZWQgZGVidWcgbG9nc1xuXHRsb2dMZXZlbDogJ2Vycm9yJyB8ICd3YXJuJyB8ICdpbmZvJyB8ICdkZWJ1Zyc7ICAvLyBMb2dnaW5nIGxldmVsXG5cdGxvZ1RvRmlsZTogYm9vbGVhbjsgICAgICAgIC8vIFdoZXRoZXIgdG8gbG9nIHRvIGEgZmlsZVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNTZXR0aW5ncyB7XG5cdHN5bmNGaWxlUGF0aDogc3RyaW5nO1xuXHRiYWNrdXBJbnRlcnZhbDogbnVtYmVyO1xuXHRjaGVja0ludGVydmFsOiBudW1iZXI7XG5cdGNoZWNrQXR0ZW1wdHM6IG51bWJlcjtcblx0cmVxdWlyZVN5bmM6IGJvb2xlYW47XG59XG5cbi8qKlxuICogSW5pdGlhbCBzeW5jIHNldHRpbmdzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5pdGlhbFN5bmNTZXR0aW5ncyB7XG5cdGJhdGNoU2l6ZTogbnVtYmVyOyAgICAgICAgICAgICAvLyBOdW1iZXIgb2YgZmlsZXMgcGVyIGJhdGNoXG5cdG1heENvbmN1cnJlbnRCYXRjaGVzOiBudW1iZXI7ICAvLyBNYXhpbXVtIGNvbmN1cnJlbnQgYmF0Y2ggcHJvY2Vzc2luZ1xuXHRlbmFibGVBdXRvSW5pdGlhbFN5bmM6IGJvb2xlYW47IC8vIEF1dG8tc3RhcnQgaW5pdGlhbCBzeW5jXG5cdHByaW9yaXR5UnVsZXM6IFByaW9yaXR5UnVsZVtdOyAvLyBSdWxlcyBmb3IgZmlsZSBwcm9jZXNzaW5nIHByaW9yaXR5XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJpb3JpdHlSdWxlIHtcblx0cGF0dGVybjogc3RyaW5nOyAgIC8vIFBhdHRlcm4gdG8gbWF0Y2ggaW4gZmlsZSBwYXRoXG5cdHByaW9yaXR5OiBudW1iZXI7ICAvLyBQcmlvcml0eSBsZXZlbCAoaGlnaGVyID0gcHJvY2Vzc2VkIGZpcnN0KVxufVxuXG4vKipcbiAqIE1haW4gc2V0dGluZ3MgaW50ZXJmYWNlIGZvciB0aGUgcGx1Z2luXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWluZE1hdHJpeFNldHRpbmdzIHtcblx0Ly8gVmF1bHQgaWRlbnRpZmljYXRpb25cblx0dmF1bHRJZDogc3RyaW5nIHwgbnVsbDsgICAgICAvLyBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHZhdWx0XG5cdGxhc3RLbm93blZhdWx0TmFtZTogc3RyaW5nOyAgLy8gTGFzdCBrbm93biBuYW1lIG9mIHRoZSB2YXVsdFxuXG5cdC8vIEFQSSBDb25maWd1cmF0aW9uXG5cdHN1cGFiYXNlOiBTdXBhYmFzZVNldHRpbmdzOyAgLy8gU3VwYWJhc2UgY29uZmlndXJhdGlvblxuXHRvcGVuYWk6IE9wZW5BSVNldHRpbmdzOyAgICAgIC8vIE9wZW5BSSBjb25maWd1cmF0aW9uXG5cblx0Ly8gUHJvY2Vzc2luZyBzZXR0aW5nc1xuXHRjaHVua2luZzogQ2h1bmtTZXR0aW5nczsgICAgIC8vIFRleHQgY2h1bmtpbmcgc2V0dGluZ3Ncblx0cXVldWU6IFF1ZXVlU2V0dGluZ3M7ICAgICAgICAvLyBRdWV1ZSBwcm9jZXNzaW5nIHNldHRpbmdzXG5cblx0Ly8gRXhjbHVzaW9uIHBhdHRlcm5zXG5cdGV4Y2x1c2lvbnM6IEV4Y2x1c2lvblNldHRpbmdzOyAgLy8gUGF0aHMgYW5kIGZpbGUgdHlwZXMgdG8gZXhjbHVkZVxuXG5cdC8vIERlYnVnIHNldHRpbmdzXG5cdGRlYnVnOiBEZWJ1Z1NldHRpbmdzOyAgICAgICAgLy8gRGVidWdnaW5nIGFuZCBsb2dnaW5nIGNvbmZpZ3VyYXRpb25cblxuXHQvLyBGZWF0dXJlIGZsYWdzXG5cdGVuYWJsZUF1dG9TeW5jOiBib29sZWFuOyAgICAgIC8vIEVuYWJsZSBhdXRvbWF0aWMgc3luY2hyb25pemF0aW9uXG5cdGVuYWJsZU5vdGlmaWNhdGlvbnM6IGJvb2xlYW47IC8vIFNob3cgbm90aWZpY2F0aW9ucyBmb3IgYWN0aW9uc1xuXHRlbmFibGVQcm9ncmVzc0JhcjogYm9vbGVhbjsgICAvLyBTaG93IGEgcHJvZ3Jlc3MgYmFyIGR1cmluZyB0YXNrc1xuXG5cdC8vIFN5bmMgc2V0dGluZ3Ncblx0c3luYzogU3luY1NldHRpbmdzO1xuXG5cdC8vIEluaXRpYWwgc3luYyBzZXR0aW5nc1xuXHRpbml0aWFsU3luYzogSW5pdGlhbFN5bmNTZXR0aW5ncztcbn1cblxuLyoqXG4gKiBEZWZhdWx0IGNodW5raW5nIG9wdGlvbnMgZm9yIHRleHQgcHJvY2Vzc2luZ1xuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9DSFVOS0lOR19PUFRJT05TOiBDaHVua1NldHRpbmdzID0ge1xuXHRjaHVua1NpemU6IDEwMDAsICAgICAgIC8vIERlZmF1bHQgc2l6ZSBvZiBlYWNoIGNodW5rIGluIGNoYXJhY3RlcnNcblx0Y2h1bmtPdmVybGFwOiAyMDAsICAgICAvLyBEZWZhdWx0IG92ZXJsYXAgYmV0d2VlbiBjaHVua3Ncblx0bWluQ2h1bmtTaXplOiAxMDAsICAgICAvLyBNaW5pbXVtIGNodW5rIHNpemUgdG8gZW5zdXJlIHVzYWJpbGl0eVxufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNldHRpbmdzIHdoZW4gcGx1Z2luIGlzIGZpcnN0IGluaXRpYWxpemVkXG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBNaW5kTWF0cml4U2V0dGluZ3MgPSB7XG5cdHZhdWx0SWQ6IG51bGwsXG5cdGxhc3RLbm93blZhdWx0TmFtZTogJycsXG5cblx0c3VwYWJhc2U6IHtcblx0XHR1cmw6ICcnLFxuXHRcdGFwaUtleTogJycsXG5cdFx0aW5pdGlhbGl6ZWQ6IGZhbHNlLFxuXHRcdGxhc3RTZXR1cEF0dGVtcHQ6IDAsXG5cdFx0c2V0dXBSZXRyaWVzOiAwLFxuXHR9LFxuXG5cdG9wZW5haToge1xuXHRcdGFwaUtleTogJycsXG5cdFx0bW9kZWw6ICd0ZXh0LWVtYmVkZGluZy1hZGEtMDAyJyxcblx0XHRtYXhUb2tlbnM6IDgwMDAsXG5cdFx0dGVtcGVyYXR1cmU6IDAuMCxcblx0fSxcblxuXHRjaHVua2luZzogeyAuLi5ERUZBVUxUX0NIVU5LSU5HX09QVElPTlMgfSwgLy8gVXNlIGRlZmF1bHQgY2h1bmtpbmcgb3B0aW9uc1xuXG5cdHF1ZXVlOiB7XG5cdFx0bWF4Q29uY3VycmVudDogMyxcblx0XHRyZXRyeUF0dGVtcHRzOiAzLFxuXHRcdHJldHJ5RGVsYXk6IDEwMDAsXG5cdH0sXG5cblx0ZXhjbHVzaW9uczoge1xuXHRcdGV4Y2x1ZGVkRm9sZGVyczogW1xuXHRcdFx0Jy5vYnNpZGlhbicsICAgICAgICAgICAvLyBPYnNpZGlhbiBjb25maWcgZm9sZGVyXG5cdFx0XHQnLnRyYXNoJywgICAgICAgICAgICAgLy8gT2JzaWRpYW4gdHJhc2ggZm9sZGVyXG5cdFx0XHQnLmdpdCcsICAgICAgICAgICAgICAvLyBHaXQgZm9sZGVyIGlmIHVzZWRcblx0XHRcdCdub2RlX21vZHVsZXMnICAgICAgIC8vIE5vZGUgbW9kdWxlcyBpZiB1c2VkXG5cdFx0XSxcblx0XHRleGNsdWRlZEZpbGVUeXBlczogW1xuXHRcdFx0Jy5tcDMnLCAnLmpwZycsICcucG5nJywgJy5wZGYnLCAvLyBOb24tbWFya2Rvd24gZmlsZXNcblx0XHRcdCcuZXhjYWxpZHJhdycgICAgICAgICAgICAgICAgICAgIC8vIEV4Y2FsaWRyYXcgZmlsZXNcblx0XHRdLFxuXHRcdGV4Y2x1ZGVkRmlsZVByZWZpeGVzOiBbJ18nLCAnLiddLCAgIC8vIEhpZGRlbiBhbmQgc3BlY2lhbCBmaWxlc1xuXHRcdGV4Y2x1ZGVkRmlsZXM6IFtcblx0XHRcdCdfbWluZG1hdHJpeHN5bmMubWQnLCAgICAgICAgICAgLy8gU3luYyBmaWxlXG5cdFx0XHQnX21pbmRtYXRyaXhzeW5jLm1kLmJhY2t1cCcgICAgIC8vIFN5bmMgYmFja3VwIGZpbGVcblx0XHRdXG5cdH0sXG5cdGRlYnVnOiB7XG5cdFx0ZW5hYmxlRGVidWdMb2dzOiBmYWxzZSxcblx0XHRsb2dMZXZlbDogJ2luZm8nLFxuXHRcdGxvZ1RvRmlsZTogZmFsc2UsXG5cdH0sXG5cblx0ZW5hYmxlQXV0b1N5bmM6IHRydWUsXG5cdGVuYWJsZU5vdGlmaWNhdGlvbnM6IHRydWUsXG5cdGVuYWJsZVByb2dyZXNzQmFyOiB0cnVlLFxuXG5cdHN5bmM6IHtcblx0XHRzeW5jRmlsZVBhdGg6ICdfbWluZG1hdHJpeHN5bmMubWQnLFxuXHRcdGJhY2t1cEludGVydmFsOiAzNjAwMDAwLCAgLy8gMSBob3VyIGluIG1pbGxpc2Vjb25kc1xuXHRcdGNoZWNrSW50ZXJ2YWw6IDMwMDAwMCwgICAgLy8gNSBtaW51dGVzIGluIG1pbGxpc2Vjb25kc1xuXHRcdGNoZWNrQXR0ZW1wdHM6IDMsXG5cdFx0cmVxdWlyZVN5bmM6IHRydWUsXG5cdH0sXG5cblx0aW5pdGlhbFN5bmM6IHtcblx0XHRiYXRjaFNpemU6IDUwLFxuXHRcdG1heENvbmN1cnJlbnRCYXRjaGVzOiAzLFxuXHRcdGVuYWJsZUF1dG9Jbml0aWFsU3luYzogdHJ1ZSxcblx0XHRwcmlvcml0eVJ1bGVzOiBbXG5cdFx0XHR7IHBhdHRlcm46ICdkYWlseS8nLCBwcmlvcml0eTogMyB9LFxuXHRcdFx0eyBwYXR0ZXJuOiAncHJvamVjdHMvJywgcHJpb3JpdHk6IDIgfSxcblx0XHRcdHsgcGF0dGVybjogJ2FyY2hpdmUvJywgcHJpb3JpdHk6IDEgfVxuXHRcdF1cblx0fVxufTtcblxuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGEgdmF1bHQgaXMgaW5pdGlhbGl6ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmF1bHRJbml0aWFsaXplZChzZXR0aW5nczogTWluZE1hdHJpeFNldHRpbmdzKTogYm9vbGVhbiB7XG5cdHJldHVybiBzZXR0aW5ncy52YXVsdElkICE9PSBudWxsICYmIHNldHRpbmdzLnZhdWx0SWQgIT09IHVuZGVmaW5lZCAmJiBzZXR0aW5ncy52YXVsdElkICE9PSAnJztcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gY3JlYXRlIGEgbmV3IHZhdWx0IElEXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVZhdWx0SWQoKTogc3RyaW5nIHtcblx0cmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGNoZWNrIGlmIGRhdGFiYXNlIGluaXRpYWxpemF0aW9uIGlzIG5lZWRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbmVlZHNEYXRhYmFzZVNldHVwKHNldHRpbmdzOiBNaW5kTWF0cml4U2V0dGluZ3MpOiBib29sZWFuIHtcblx0aWYgKCFzZXR0aW5ncy5zdXBhYmFzZS5pbml0aWFsaXplZCkgcmV0dXJuIHRydWU7XG5cblx0Ly8gSWYgbGFzdCBhdHRlbXB0IHdhcyBtb3JlIHRoYW4gYW4gaG91ciBhZ28gYW5kIHdlIGhhdmVuJ3QgZXhjZWVkZWQgcmV0cnkgbGltaXRcblx0Y29uc3Qgb25lSG91ciA9IDYwICogNjAgKiAxMDAwOyAvLyBtc1xuXHRjb25zdCB0aW1lU2luY2VMYXN0QXR0ZW1wdCA9IERhdGUubm93KCkgLSAoc2V0dGluZ3Muc3VwYWJhc2UubGFzdFNldHVwQXR0ZW1wdCB8fCAwKTtcblx0cmV0dXJuIHRpbWVTaW5jZUxhc3RBdHRlbXB0ID4gb25lSG91ciAmJiAoc2V0dGluZ3Muc3VwYWJhc2Uuc2V0dXBSZXRyaWVzIHx8IDApIDwgMztcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gdXBkYXRlIGRhdGFiYXNlIHNldHVwIHN0YXR1c1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlRGF0YWJhc2VTZXR1cFN0YXR1cyhzZXR0aW5nczogTWluZE1hdHJpeFNldHRpbmdzLCBzdWNjZXNzOiBib29sZWFuKTogdm9pZCB7XG5cdHNldHRpbmdzLnN1cGFiYXNlLmxhc3RTZXR1cEF0dGVtcHQgPSBEYXRlLm5vdygpO1xuXHRpZiAoc3VjY2Vzcykge1xuXHRcdHNldHRpbmdzLnN1cGFiYXNlLmluaXRpYWxpemVkID0gdHJ1ZTtcblx0XHRzZXR0aW5ncy5zdXBhYmFzZS5zZXR1cFJldHJpZXMgPSAwO1xuXHR9IGVsc2Uge1xuXHRcdHNldHRpbmdzLnN1cGFiYXNlLnNldHVwUmV0cmllcyA9IChzZXR0aW5ncy5zdXBhYmFzZS5zZXR1cFJldHJpZXMgfHwgMCkgKyAxO1xuXHR9XG59XG5cbi8qKlxuICogVmFsaWRhdGUgc2V0dGluZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlU2V0dGluZ3Moc2V0dGluZ3M6IE1pbmRNYXRyaXhTZXR0aW5ncyk6IHN0cmluZ1tdIHtcblx0Y29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG5cdC8vIENoZWNrIGNodW5rIHNldHRpbmdzXG5cdGlmIChzZXR0aW5ncy5jaHVua2luZy5jaHVua1NpemUgPCBzZXR0aW5ncy5jaHVua2luZy5taW5DaHVua1NpemUpIHtcblx0XHRlcnJvcnMucHVzaCgnQ2h1bmsgc2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBtaW5pbXVtIGNodW5rIHNpemUnKTtcblx0fVxuXHRpZiAoc2V0dGluZ3MuY2h1bmtpbmcuY2h1bmtPdmVybGFwID49IHNldHRpbmdzLmNodW5raW5nLmNodW5rU2l6ZSkge1xuXHRcdGVycm9ycy5wdXNoKCdDaHVuayBvdmVybGFwIG11c3QgYmUgbGVzcyB0aGFuIGNodW5rIHNpemUnKTtcblx0fVxuXG5cdC8vIENoZWNrIHF1ZXVlIHNldHRpbmdzXG5cdGlmIChzZXR0aW5ncy5xdWV1ZS5tYXhDb25jdXJyZW50IDwgMSkge1xuXHRcdGVycm9ycy5wdXNoKCdNYXhpbXVtIGNvbmN1cnJlbnQgdGFza3MgbXVzdCBiZSBhdCBsZWFzdCAxJyk7XG5cdH1cblx0aWYgKHNldHRpbmdzLnF1ZXVlLnJldHJ5QXR0ZW1wdHMgPCAwKSB7XG5cdFx0ZXJyb3JzLnB1c2goJ1JldHJ5IGF0dGVtcHRzIGNhbm5vdCBiZSBuZWdhdGl2ZScpO1xuXHR9XG5cdGlmIChzZXR0aW5ncy5xdWV1ZS5yZXRyeURlbGF5IDwgMCkge1xuXHRcdGVycm9ycy5wdXNoKCdSZXRyeSBkZWxheSBjYW5ub3QgYmUgbmVnYXRpdmUnKTtcblx0fVxuXG5cdC8vIENoZWNrIGluaXRpYWwgc3luYyBzZXR0aW5nc1xuXHRpZiAoc2V0dGluZ3MuaW5pdGlhbFN5bmMuYmF0Y2hTaXplIDwgMSkge1xuXHRcdGVycm9ycy5wdXNoKCdJbml0aWFsIHN5bmMgYmF0Y2ggc2l6ZSBtdXN0IGJlIGF0IGxlYXN0IDEnKTtcblx0fVxuXHRpZiAoc2V0dGluZ3MuaW5pdGlhbFN5bmMubWF4Q29uY3VycmVudEJhdGNoZXMgPCAxKSB7XG5cdFx0ZXJyb3JzLnB1c2goJ01heGltdW0gY29uY3VycmVudCBiYXRjaGVzIG11c3QgYmUgYXQgbGVhc3QgMScpO1xuXHR9XG5cblx0cmV0dXJuIGVycm9ycztcbn1cblxuLy8gSW4gU2V0dGluZ3MudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRXhjbHVzaW9uU2V0dGluZ3Moc2V0dGluZ3M6IEV4Y2x1c2lvblNldHRpbmdzKTogc3RyaW5nW10ge1xuXHRjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG5cblx0Ly8gVmFsaWRhdGUgZm9sZGVyIHBhdGhzXG5cdHNldHRpbmdzLmV4Y2x1ZGVkRm9sZGVycy5mb3JFYWNoKGZvbGRlciA9PiB7XG5cdFx0aWYgKGZvbGRlci5pbmNsdWRlcygnLi4nKSkge1xuXHRcdFx0ZXJyb3JzLnB1c2goYEludmFsaWQgZm9sZGVyIHBhdGg6ICR7Zm9sZGVyfSAoY2Fubm90IGNvbnRhaW4gLi4pYCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBWYWxpZGF0ZSBmaWxlIGV4dGVuc2lvbnNcblx0c2V0dGluZ3MuZXhjbHVkZWRGaWxlVHlwZXMuZm9yRWFjaChleHQgPT4ge1xuXHRcdGlmICghZXh0LnN0YXJ0c1dpdGgoJy4nKSkge1xuXHRcdFx0ZXJyb3JzLnB1c2goYEludmFsaWQgZmlsZSBleHRlbnNpb246ICR7ZXh0fSAobXVzdCBzdGFydCB3aXRoIC4pYCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBFbnN1cmUgc3luYyBmaWxlcyBhcmUgYWx3YXlzIGV4Y2x1ZGVkXG5cdGNvbnN0IHJlcXVpcmVkRXhjbHVzaW9ucyA9IFsnX21pbmRtYXRyaXhzeW5jLm1kJywgJ19taW5kbWF0cml4c3luYy5tZC5iYWNrdXAnXTtcblx0cmVxdWlyZWRFeGNsdXNpb25zLmZvckVhY2goZmlsZSA9PiB7XG5cdFx0aWYgKCFzZXR0aW5ncy5leGNsdWRlZEZpbGVzLmluY2x1ZGVzKGZpbGUpKSB7XG5cdFx0XHRzZXR0aW5ncy5leGNsdWRlZEZpbGVzLnB1c2goZmlsZSk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gZXJyb3JzO1xufVxuXG4vKipcbiAqIFJlc2V0IHNldHRpbmdzIHRvIGRlZmF1bHRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNldFNldHRpbmdzKHNldHRpbmdzOiBNaW5kTWF0cml4U2V0dGluZ3MpOiB2b2lkIHtcblx0T2JqZWN0LmFzc2lnbihzZXR0aW5ncywgREVGQVVMVF9TRVRUSU5HUyk7XG5cdHNldHRpbmdzLnZhdWx0SWQgPSBudWxsOyAvLyBFbnN1cmUgdmF1bHQgbmVlZHMgdG8gYmUgcmVpbml0aWFsaXplZFxuXHRzZXR0aW5ncy5zdXBhYmFzZS5pbml0aWFsaXplZCA9IGZhbHNlOyAvLyBGb3JjZSBkYXRhYmFzZSByZWluaXRpYWxpemF0aW9uXG59XG4iLCAiaW1wb3J0IHsgY3JlYXRlQ2xpZW50LCBTdXBhYmFzZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5pbXBvcnQgeyBEb2N1bWVudENodW5rLCBEb2N1bWVudE1ldGFkYXRhIH0gZnJvbSAnLi4vbW9kZWxzL0RvY3VtZW50Q2h1bmsnO1xuaW1wb3J0IHsgTWluZE1hdHJpeFNldHRpbmdzLCBpc1ZhdWx0SW5pdGlhbGl6ZWQgfSBmcm9tICcuLi9zZXR0aW5ncy9TZXR0aW5ncyc7XG5pbXBvcnQgeyBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5cbmV4cG9ydCBjbGFzcyBTdXBhYmFzZVNlcnZpY2Uge1xuICAgIHByaXZhdGUgY2xpZW50OiBTdXBhYmFzZUNsaWVudCB8IG51bGw7XG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFN1cGFiYXNlU2VydmljZSB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgc2V0dGluZ3M6IE1pbmRNYXRyaXhTZXR0aW5ncztcbiAgICBwcml2YXRlIHJlYWRvbmx5IFRBQkxFX05BTUUgPSAnb2JzaWRpYW5fZG9jdW1lbnRzJztcblxuICAgIHByaXZhdGUgY29uc3RydWN0b3Ioc2V0dGluZ3M6IE1pbmRNYXRyaXhTZXR0aW5ncykge1xuICAgICAgICBpZiAoIXNldHRpbmdzLnN1cGFiYXNlLnVybCB8fCAhc2V0dGluZ3Muc3VwYWJhc2UuYXBpS2V5KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNvbmZpZ3VyYXRpb24gaXMgaW5jb21wbGV0ZS4gU3VwYWJhc2Ugc2VydmljZSB3aWxsIG5vdCBiZSBpbml0aWFsaXplZC4nKTtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWYXVsdEluaXRpYWxpemVkKHNldHRpbmdzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYXVsdCBpcyBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjcmVhdGVDbGllbnQoc2V0dGluZ3Muc3VwYWJhc2UudXJsLCBzZXR0aW5ncy5zdXBhYmFzZS5hcGlLZXkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZ2V0SW5zdGFuY2Uoc2V0dGluZ3M6IE1pbmRNYXRyaXhTZXR0aW5ncyk6IFByb21pc2U8U3VwYWJhc2VTZXJ2aWNlIHwgbnVsbD4ge1xuICAgICAgICBpZiAoIXNldHRpbmdzLnN1cGFiYXNlLnVybCB8fCAhc2V0dGluZ3Muc3VwYWJhc2UuYXBpS2V5KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNvbmZpZ3VyYXRpb24gaXMgaW5jb21wbGV0ZS4gUmV0dXJuaW5nIG51bGwuJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghU3VwYWJhc2VTZXJ2aWNlLmluc3RhbmNlKSB7XG4gICAgICAgICAgICBTdXBhYmFzZVNlcnZpY2UuaW5zdGFuY2UgPSBuZXcgU3VwYWJhc2VTZXJ2aWNlKHNldHRpbmdzKTtcbiAgICAgICAgICAgIGF3YWl0IFN1cGFiYXNlU2VydmljZS5pbnN0YW5jZS5pbml0aWFsaXplRGF0YWJhc2UoKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIFN1cGFiYXNlU2VydmljZS5pbnN0YW5jZS5zZXR0aW5ncy5zdXBhYmFzZS51cmwgIT09IHNldHRpbmdzLnN1cGFiYXNlLnVybCB8fFxuICAgICAgICAgICAgU3VwYWJhc2VTZXJ2aWNlLmluc3RhbmNlLnNldHRpbmdzLnN1cGFiYXNlLmFwaUtleSAhPT0gc2V0dGluZ3Muc3VwYWJhc2UuYXBpS2V5IHx8XG4gICAgICAgICAgICBTdXBhYmFzZVNlcnZpY2UuaW5zdGFuY2Uuc2V0dGluZ3MudmF1bHRJZCAhPT0gc2V0dGluZ3MudmF1bHRJZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIFN1cGFiYXNlU2VydmljZS5pbnN0YW5jZSA9IG5ldyBTdXBhYmFzZVNlcnZpY2Uoc2V0dGluZ3MpO1xuICAgICAgICAgICAgYXdhaXQgU3VwYWJhc2VTZXJ2aWNlLmluc3RhbmNlLmluaXRpYWxpemVEYXRhYmFzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdXBhYmFzZVNlcnZpY2UuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBpbml0aWFsaXplRGF0YWJhc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICghdGhpcy5jbGllbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignU3VwYWJhc2UgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZC4gU2tpcHBpbmcgZGF0YWJhc2UgaW5pdGlhbGl6YXRpb24uJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnQ2hlY2tpbmcgZGF0YWJhc2UgY29ubmVjdGlvbi4uLicpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgd2UgY2FuIGFjY2VzcyB0aGUgZGF0YWJhc2VcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdGVzdERhdGEsIGVycm9yOiB0ZXN0RXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG4gICAgICAgICAgICAgICAgLmZyb20odGhpcy5UQUJMRV9OQU1FKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgICAgICAgICAgICAubGltaXQoMSk7XG5cbiAgICAgICAgICAgIGlmICh0ZXN0RXJyb3IgJiYgIXRlc3RFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdkb2VzIG5vdCBleGlzdCcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZDogJHt0ZXN0RXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGF0YWJhc2Ugc2NoZW1hXG4gICAgICAgICAgICBjb25zdCB7IGVycm9yOiBpbml0RXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG4gICAgICAgICAgICAgICAgLnJwYygnaW5pdF9vYnNpZGlhbl9kb2N1bWVudHMnKTtcblxuICAgICAgICAgICAgaWYgKGluaXRFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGluaXRpYWxpemUgZGF0YWJhc2U6ICR7aW5pdEVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gdmVyaWZpZWQnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc3VwYWJhc2UuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdEYXRhYmFzZSBpbml0aWFsaXphdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBEYXRhYmFzZSBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgdXBzZXJ0Q2h1bmtzKGNodW5rczogRG9jdW1lbnRDaHVua1tdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICghdGhpcy5jbGllbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignU3VwYWJhc2UgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZC4gU2tpcHBpbmcgdXBzZXJ0Q2h1bmtzLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ05vIGNodW5rcyB0byB1cHNlcnQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCB0aGUgb2JzaWRpYW5faWQgZnJvbSB0aGUgZmlyc3QgY2h1bmtcbiAgICAgICAgICAgIGNvbnN0IG9ic2lkaWFuSWQgPSBjaHVua3NbMF0ubWV0YWRhdGEub2JzaWRpYW5JZDtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gZGVsZXRlIGV4aXN0aW5nIGNodW5rcyBmb3I6Jywgb2JzaWRpYW5JZCk7XG5cbiAgICAgICAgICAgIC8vIEZpcnN0IGRlbGV0ZSBleGlzdGluZyBjaHVua3MgZm9yIHRoaXMgZmlsZVxuICAgICAgICAgICAgY29uc3QgeyBlcnJvcjogZGVsZXRlRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG4gICAgICAgICAgICAgICAgLmZyb20odGhpcy5UQUJMRV9OQU1FKVxuICAgICAgICAgICAgICAgIC5kZWxldGUoKVxuICAgICAgICAgICAgICAgIC5lcSgndmF1bHRfaWQnLCB0aGlzLnNldHRpbmdzLnZhdWx0SWQpXG4gICAgICAgICAgICAgICAgLmVxKCdvYnNpZGlhbl9pZCcsIG9ic2lkaWFuSWQpO1xuXG4gICAgICAgICAgICBpZiAoZGVsZXRlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBleGlzdGluZyBjaHVua3M6JywgZGVsZXRlRXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGRlbGV0ZUVycm9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRoZSBuZXcgY2h1bmtzIGZvciBpbnNlcnRpb25cbiAgICAgICAgICAgIGNvbnN0IGNodW5rc1RvSW5zZXJ0ID0gY2h1bmtzLm1hcChjaHVuayA9PiAoe1xuICAgICAgICAgICAgICAgIHZhdWx0X2lkOiB0aGlzLnNldHRpbmdzLnZhdWx0SWQsXG4gICAgICAgICAgICAgICAgb2JzaWRpYW5faWQ6IGNodW5rLm1ldGFkYXRhLm9ic2lkaWFuSWQsXG4gICAgICAgICAgICAgICAgY2h1bmtfaW5kZXg6IGNodW5rLmNodW5rSW5kZXgsXG4gICAgICAgICAgICAgICAgY29udGVudDogY2h1bmsuY29udGVudCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogY2h1bmsubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgZW1iZWRkaW5nOiBjaHVuay5lbWJlZGRpbmcsXG4gICAgICAgICAgICAgICAgbGFzdF91cGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBuZXcgY2h1bmtzXG4gICAgICAgICAgICBjb25zdCB7IGVycm9yOiBpbnNlcnRFcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcbiAgICAgICAgICAgICAgICAuZnJvbSh0aGlzLlRBQkxFX05BTUUpXG4gICAgICAgICAgICAgICAgLmluc2VydChjaHVua3NUb0luc2VydCk7XG5cbiAgICAgICAgICAgIGlmIChpbnNlcnRFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluc2VydGluZyBuZXcgY2h1bmtzOicsIGluc2VydEVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBpbnNlcnRFcnJvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSB1cGRhdGVkIGNodW5rczonLCB7XG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZDaHVua3M6IGNodW5rcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdmF1bHRJZDogdGhpcy5zZXR0aW5ncy52YXVsdElkLFxuICAgICAgICAgICAgICAgIG9ic2lkaWFuSWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHVwc2VydCBjaHVua3M6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZGVsZXRlRG9jdW1lbnRDaHVua3Mob2JzaWRpYW5JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICghdGhpcy5jbGllbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignU3VwYWJhc2UgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZC4gU2tpcHBpbmcgZGVsZXRlRG9jdW1lbnRDaHVua3MuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcbiAgICAgICAgICAgICAgICAuZnJvbSh0aGlzLlRBQkxFX05BTUUpXG4gICAgICAgICAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgICAgICAgICAgLmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcbiAgICAgICAgICAgICAgICAuZXEoJ29ic2lkaWFuX2lkJywgb2JzaWRpYW5JZCk7XG5cbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBjaHVua3M6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZ2V0RG9jdW1lbnRDaHVua3Mob2JzaWRpYW5JZDogc3RyaW5nKTogUHJvbWlzZTxEb2N1bWVudENodW5rW10+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdTdXBhYmFzZSBjbGllbnQgaXMgbm90IGluaXRpYWxpemVkLiBTa2lwcGluZyBnZXREb2N1bWVudENodW5rcy4nKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuICAgICAgICAgICAgICAgIC5mcm9tKHRoaXMuVEFCTEVfTkFNRSlcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAuZXEoJ3ZhdWx0X2lkJywgdGhpcy5zZXR0aW5ncy52YXVsdElkKVxuICAgICAgICAgICAgICAgIC5lcSgnb2JzaWRpYW5faWQnLCBvYnNpZGlhbklkKVxuICAgICAgICAgICAgICAgIC5vcmRlcignY2h1bmtfaW5kZXgnKTtcblxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkYXRhLm1hcChyb3cgPT4gKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiByb3cuY29udGVudCxcbiAgICAgICAgICAgICAgICBjaHVua0luZGV4OiByb3cuY2h1bmtfaW5kZXgsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJvdy5tZXRhZGF0YSBhcyBEb2N1bWVudE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGVtYmVkZGluZzogcm93LmVtYmVkZGluZ1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBjaHVua3M6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgc2VtYW50aWNTZWFyY2goZW1iZWRkaW5nOiBudW1iZXJbXSwgbGltaXQ6IG51bWJlciA9IDUpOiBQcm9taXNlPEFycmF5PHtcbiAgICAgICAgY29udGVudDogc3RyaW5nO1xuICAgICAgICBtZXRhZGF0YTogRG9jdW1lbnRNZXRhZGF0YTtcbiAgICAgICAgc2ltaWxhcml0eTogbnVtYmVyO1xuICAgIH0+PiB7XG4gICAgICAgIGlmICghdGhpcy5jbGllbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignU3VwYWJhc2UgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZC4gU2tpcHBpbmcgc2VtYW50aWNTZWFyY2guJyk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnQucnBjKCdtYXRjaF9kb2N1bWVudHMnLCB7XG4gICAgICAgICAgICAgICAgcXVlcnlfZW1iZWRkaW5nOiBlbWJlZGRpbmcsXG4gICAgICAgICAgICAgICAgc2VhcmNoX3ZhdWx0X2lkOiB0aGlzLnNldHRpbmdzLnZhdWx0SWQsXG4gICAgICAgICAgICAgICAgbWF0Y2hfY291bnQ6IGxpbWl0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkYXRhLm1hcChyb3cgPT4gKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiByb3cuY29udGVudCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogcm93Lm1ldGFkYXRhIGFzIERvY3VtZW50TWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgc2ltaWxhcml0eTogcm93LnNpbWlsYXJpdHlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwZXJmb3JtIHNlbWFudGljIHNlYXJjaDonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyB0ZXN0Q29ubmVjdGlvbigpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG4gICAgICAgICAgICAgICAgLmZyb20odGhpcy5UQUJMRV9OQU1FKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgICAgICAgICAgICAubGltaXQoMSk7XG5cbiAgICAgICAgICAgIHJldHVybiAhZXJyb3I7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZ2V0QWxsRG9jdW1lbnRJZHMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICBpZiAoIXRoaXMuY2xpZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNsaWVudCBpcyBub3QgaW5pdGlhbGl6ZWQuIFNraXBwaW5nIGdldEFsbERvY3VtZW50SWRzLicpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG4gICAgICAgICAgICAgICAgLmZyb20odGhpcy5UQUJMRV9OQU1FKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJ29ic2lkaWFuX2lkJylcbiAgICAgICAgICAgICAgICAuZXEoJ3ZhdWx0X2lkJywgdGhpcy5zZXR0aW5ncy52YXVsdElkKVxuICAgICAgICAgICAgICAgIC5kaXN0aW5jdCgpO1xuXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwKHJvdyA9PiByb3cub2JzaWRpYW5faWQpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBkb2N1bWVudCBJRHM6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBGb3JtYXQgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRfZm9ybWF0OiBGb3JtYXQgPSAnUkZDMzk4Nic7XG5leHBvcnQgY29uc3QgZm9ybWF0dGVyczogUmVjb3JkPEZvcm1hdCwgKHN0cjogUHJvcGVydHlLZXkpID0+IHN0cmluZz4gPSB7XG4gIFJGQzE3Mzg6ICh2OiBQcm9wZXJ0eUtleSkgPT4gU3RyaW5nKHYpLnJlcGxhY2UoLyUyMC9nLCAnKycpLFxuICBSRkMzOTg2OiAodjogUHJvcGVydHlLZXkpID0+IFN0cmluZyh2KSxcbn07XG5leHBvcnQgY29uc3QgUkZDMTczOCA9ICdSRkMxNzM4JztcbmV4cG9ydCBjb25zdCBSRkMzOTg2ID0gJ1JGQzM5ODYnO1xuIiwgImltcG9ydCB7IFJGQzE3MzggfSBmcm9tICcuL2Zvcm1hdHMnO1xuaW1wb3J0IHR5cGUgeyBEZWZhdWx0RW5jb2RlciwgRm9ybWF0IH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCBpc19hcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbmNvbnN0IGhleF90YWJsZSA9ICgoKSA9PiB7XG4gIGNvbnN0IGFycmF5ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICBhcnJheS5wdXNoKCclJyArICgoaSA8IDE2ID8gJzAnIDogJycpICsgaS50b1N0cmluZygxNikpLnRvVXBwZXJDYXNlKCkpO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufSkoKTtcblxuZnVuY3Rpb24gY29tcGFjdF9xdWV1ZTxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4ocXVldWU6IEFycmF5PHsgb2JqOiBUOyBwcm9wOiBzdHJpbmcgfT4pIHtcbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBpdGVtID0gcXVldWUucG9wKCk7XG4gICAgaWYgKCFpdGVtKSBjb250aW51ZTtcblxuICAgIGNvbnN0IG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICBpZiAoaXNfYXJyYXkob2JqKSkge1xuICAgICAgY29uc3QgY29tcGFjdGVkOiB1bmtub3duW10gPSBbXTtcblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvYmoubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmpbal0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29tcGFjdGVkLnB1c2gob2JqW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpdGVtLm9ialtpdGVtLnByb3BdID0gY29tcGFjdGVkO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcnJheV90b19vYmplY3Qoc291cmNlOiBhbnlbXSwgb3B0aW9uczogeyBwbGFpbk9iamVjdHM6IGJvb2xlYW4gfSkge1xuICBjb25zdCBvYmogPSBvcHRpb25zICYmIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlW2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgb2JqW2ldID0gc291cmNlW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZShcbiAgdGFyZ2V0OiBhbnksXG4gIHNvdXJjZTogYW55LFxuICBvcHRpb25zOiB7IHBsYWluT2JqZWN0cz86IGJvb2xlYW47IGFsbG93UHJvdG90eXBlcz86IGJvb2xlYW4gfSA9IHt9LFxuKSB7XG4gIGlmICghc291cmNlKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgIGlmIChpc19hcnJheSh0YXJnZXQpKSB7XG4gICAgICB0YXJnZXQucHVzaChzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRpb25zICYmIChvcHRpb25zLnBsYWluT2JqZWN0cyB8fCBvcHRpb25zLmFsbG93UHJvdG90eXBlcykpIHx8XG4gICAgICAgICFoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBzb3VyY2UpXG4gICAgICApIHtcbiAgICAgICAgdGFyZ2V0W3NvdXJjZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3RhcmdldCwgc291cmNlXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgaWYgKCF0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gW3RhcmdldF0uY29uY2F0KHNvdXJjZSk7XG4gIH1cblxuICBsZXQgbWVyZ2VUYXJnZXQgPSB0YXJnZXQ7XG4gIGlmIChpc19hcnJheSh0YXJnZXQpICYmICFpc19hcnJheShzb3VyY2UpKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIG1lcmdlVGFyZ2V0ID0gYXJyYXlfdG9fb2JqZWN0KHRhcmdldCwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoaXNfYXJyYXkodGFyZ2V0KSAmJiBpc19hcnJheShzb3VyY2UpKSB7XG4gICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgIGlmIChoYXMuY2FsbCh0YXJnZXQsIGkpKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEl0ZW0gPSB0YXJnZXRbaV07XG4gICAgICAgIGlmICh0YXJnZXRJdGVtICYmIHR5cGVvZiB0YXJnZXRJdGVtID09PSAnb2JqZWN0JyAmJiBpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRhcmdldFtpXSA9IG1lcmdlKHRhcmdldEl0ZW0sIGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRbaV0gPSBpdGVtO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgY29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgIGlmIChoYXMuY2FsbChhY2MsIGtleSkpIHtcbiAgICAgIGFjY1trZXldID0gbWVyZ2UoYWNjW2tleV0sIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgbWVyZ2VUYXJnZXQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduX3NpbmdsZV9zb3VyY2UodGFyZ2V0OiBhbnksIHNvdXJjZTogYW55KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICBhY2Nba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHRhcmdldCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoc3RyOiBzdHJpbmcsIF86IGFueSwgY2hhcnNldDogc3RyaW5nKSB7XG4gIGNvbnN0IHN0cldpdGhvdXRQbHVzID0gc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICBpZiAoY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgLy8gdW5lc2NhcGUgbmV2ZXIgdGhyb3dzLCBubyB0cnkuLi5jYXRjaCBuZWVkZWQ6XG4gICAgcmV0dXJuIHN0cldpdGhvdXRQbHVzLnJlcGxhY2UoLyVbMC05YS1mXXsyfS9naSwgdW5lc2NhcGUpO1xuICB9XG4gIC8vIHV0Zi04XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHJXaXRob3V0UGx1cyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gc3RyV2l0aG91dFBsdXM7XG4gIH1cbn1cblxuY29uc3QgbGltaXQgPSAxMDI0O1xuXG5leHBvcnQgY29uc3QgZW5jb2RlOiAoXG4gIHN0cjogYW55LFxuICBkZWZhdWx0RW5jb2RlcjogRGVmYXVsdEVuY29kZXIsXG4gIGNoYXJzZXQ6IHN0cmluZyxcbiAgdHlwZTogJ2tleScgfCAndmFsdWUnLFxuICBmb3JtYXQ6IEZvcm1hdCxcbikgPT4gc3RyaW5nID0gKHN0ciwgX2RlZmF1bHRFbmNvZGVyLCBjaGFyc2V0LCBfa2luZCwgZm9ybWF0OiBGb3JtYXQpID0+IHtcbiAgLy8gVGhpcyBjb2RlIHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gYnkgQnJpYW4gV2hpdGUgZm9yIHRoZSBpby5qcyBjb3JlIHF1ZXJ5c3RyaW5nIGxpYnJhcnkuXG4gIC8vIEl0IGhhcyBiZWVuIGFkYXB0ZWQgaGVyZSBmb3Igc3RyaWN0ZXIgYWRoZXJlbmNlIHRvIFJGQyAzOTg2XG4gIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGxldCBzdHJpbmcgPSBzdHI7XG4gIGlmICh0eXBlb2Ygc3RyID09PSAnc3ltYm9sJykge1xuICAgIHN0cmluZyA9IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdHIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gU3RyaW5nKHN0cik7XG4gIH1cblxuICBpZiAoY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgcmV0dXJuIGVzY2FwZShzdHJpbmcpLnJlcGxhY2UoLyV1WzAtOWEtZl17NH0vZ2ksIGZ1bmN0aW9uICgkMCkge1xuICAgICAgcmV0dXJuICclMjYlMjMnICsgcGFyc2VJbnQoJDAuc2xpY2UoMiksIDE2KSArICclM0InO1xuICAgIH0pO1xuICB9XG5cbiAgbGV0IG91dCA9ICcnO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IHN0cmluZy5sZW5ndGg7IGogKz0gbGltaXQpIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc3RyaW5nLmxlbmd0aCA+PSBsaW1pdCA/IHN0cmluZy5zbGljZShqLCBqICsgbGltaXQpIDogc3RyaW5nO1xuICAgIGNvbnN0IGFyciA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZXQgYyA9IHNlZ21lbnQuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChcbiAgICAgICAgYyA9PT0gMHgyZCB8fCAvLyAtXG4gICAgICAgIGMgPT09IDB4MmUgfHwgLy8gLlxuICAgICAgICBjID09PSAweDVmIHx8IC8vIF9cbiAgICAgICAgYyA9PT0gMHg3ZSB8fCAvLyB+XG4gICAgICAgIChjID49IDB4MzAgJiYgYyA8PSAweDM5KSB8fCAvLyAwLTlcbiAgICAgICAgKGMgPj0gMHg0MSAmJiBjIDw9IDB4NWEpIHx8IC8vIGEtelxuICAgICAgICAoYyA+PSAweDYxICYmIGMgPD0gMHg3YSkgfHwgLy8gQS1aXG4gICAgICAgIChmb3JtYXQgPT09IFJGQzE3MzggJiYgKGMgPT09IDB4MjggfHwgYyA9PT0gMHgyOSkpIC8vICggKVxuICAgICAgKSB7XG4gICAgICAgIGFyclthcnIubGVuZ3RoXSA9IHNlZ21lbnQuY2hhckF0KGkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgIGFyclthcnIubGVuZ3RoXSA9IGhleF90YWJsZVtjXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgYXJyW2Fyci5sZW5ndGhdID0gaGV4X3RhYmxlWzB4YzAgfCAoYyA+PiA2KV0hICsgaGV4X3RhYmxlWzB4ODAgfCAoYyAmIDB4M2YpXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhlMDAwKSB7XG4gICAgICAgIGFyclthcnIubGVuZ3RoXSA9XG4gICAgICAgICAgaGV4X3RhYmxlWzB4ZTAgfCAoYyA+PiAxMildISArIGhleF90YWJsZVsweDgwIHwgKChjID4+IDYpICYgMHgzZildICsgaGV4X3RhYmxlWzB4ODAgfCAoYyAmIDB4M2YpXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICAgIGMgPSAweDEwMDAwICsgKCgoYyAmIDB4M2ZmKSA8PCAxMCkgfCAoc2VnbWVudC5jaGFyQ29kZUF0KGkpICYgMHgzZmYpKTtcblxuICAgICAgYXJyW2Fyci5sZW5ndGhdID1cbiAgICAgICAgaGV4X3RhYmxlWzB4ZjAgfCAoYyA+PiAxOCldISArXG4gICAgICAgIGhleF90YWJsZVsweDgwIHwgKChjID4+IDEyKSAmIDB4M2YpXSArXG4gICAgICAgIGhleF90YWJsZVsweDgwIHwgKChjID4+IDYpICYgMHgzZildICtcbiAgICAgICAgaGV4X3RhYmxlWzB4ODAgfCAoYyAmIDB4M2YpXTtcbiAgICB9XG5cbiAgICBvdXQgKz0gYXJyLmpvaW4oJycpO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYWN0KHZhbHVlOiBhbnkpIHtcbiAgY29uc3QgcXVldWUgPSBbeyBvYmo6IHsgbzogdmFsdWUgfSwgcHJvcDogJ28nIH1dO1xuICBjb25zdCByZWZzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGl0ZW0gPSBxdWV1ZVtpXTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgb2JqID0gaXRlbS5vYmpbaXRlbS5wcm9wXTtcblxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7ICsraikge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tqXSE7XG4gICAgICBjb25zdCB2YWwgPSBvYmpba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgJiYgcmVmcy5pbmRleE9mKHZhbCkgPT09IC0xKSB7XG4gICAgICAgIHF1ZXVlLnB1c2goeyBvYmo6IG9iaiwgcHJvcDoga2V5IH0pO1xuICAgICAgICByZWZzLnB1c2godmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb21wYWN0X3F1ZXVlKHF1ZXVlKTtcblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc19yZWdleHAob2JqOiBhbnkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzX2J1ZmZlcihvYmo6IGFueSkge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhIShvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmUoYTogYW55LCBiOiBhbnkpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdChhLCBiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlX21hcDxUPih2YWw6IFRbXSwgZm46ICh2OiBUKSA9PiBUKSB7XG4gIGlmIChpc19hcnJheSh2YWwpKSB7XG4gICAgY29uc3QgbWFwcGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIG1hcHBlZC5wdXNoKGZuKHZhbFtpXSEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcHBlZDtcbiAgfVxuICByZXR1cm4gZm4odmFsKTtcbn1cbiIsICJpbXBvcnQgeyBlbmNvZGUsIGlzX2J1ZmZlciwgbWF5YmVfbWFwIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBkZWZhdWx0X2Zvcm1hdCwgZm9ybWF0dGVycyB9IGZyb20gJy4vZm9ybWF0cyc7XG5pbXBvcnQgdHlwZSB7IE5vbk51bGxhYmxlUHJvcGVydGllcywgU3RyaW5naWZ5T3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5jb25zdCBhcnJheV9wcmVmaXhfZ2VuZXJhdG9ycyA9IHtcbiAgYnJhY2tldHMocHJlZml4OiBQcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBTdHJpbmcocHJlZml4KSArICdbXSc7XG4gIH0sXG4gIGNvbW1hOiAnY29tbWEnLFxuICBpbmRpY2VzKHByZWZpeDogUHJvcGVydHlLZXksIGtleTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIFN0cmluZyhwcmVmaXgpICsgJ1snICsga2V5ICsgJ10nO1xuICB9LFxuICByZXBlYXQocHJlZml4OiBQcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBTdHJpbmcocHJlZml4KTtcbiAgfSxcbn07XG5cbmNvbnN0IGlzX2FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmNvbnN0IHB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbmNvbnN0IHB1c2hfdG9fYXJyYXkgPSBmdW5jdGlvbiAoYXJyOiBhbnlbXSwgdmFsdWVfb3JfYXJyYXk6IGFueSkge1xuICBwdXNoLmFwcGx5KGFyciwgaXNfYXJyYXkodmFsdWVfb3JfYXJyYXkpID8gdmFsdWVfb3JfYXJyYXkgOiBbdmFsdWVfb3JfYXJyYXldKTtcbn07XG5cbmNvbnN0IHRvX0lTTyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nO1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgYWRkUXVlcnlQcmVmaXg6IGZhbHNlLFxuICBhbGxvd0RvdHM6IGZhbHNlLFxuICBhbGxvd0VtcHR5QXJyYXlzOiBmYWxzZSxcbiAgYXJyYXlGb3JtYXQ6ICdpbmRpY2VzJyxcbiAgY2hhcnNldDogJ3V0Zi04JyxcbiAgY2hhcnNldFNlbnRpbmVsOiBmYWxzZSxcbiAgZGVsaW1pdGVyOiAnJicsXG4gIGVuY29kZTogdHJ1ZSxcbiAgZW5jb2RlRG90SW5LZXlzOiBmYWxzZSxcbiAgZW5jb2RlcjogZW5jb2RlLFxuICBlbmNvZGVWYWx1ZXNPbmx5OiBmYWxzZSxcbiAgZm9ybWF0OiBkZWZhdWx0X2Zvcm1hdCxcbiAgZm9ybWF0dGVyOiBmb3JtYXR0ZXJzW2RlZmF1bHRfZm9ybWF0XSxcbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIGluZGljZXM6IGZhbHNlLFxuICBzZXJpYWxpemVEYXRlKGRhdGUpIHtcbiAgICByZXR1cm4gdG9fSVNPLmNhbGwoZGF0ZSk7XG4gIH0sXG4gIHNraXBOdWxsczogZmFsc2UsXG4gIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2UsXG59IGFzIE5vbk51bGxhYmxlUHJvcGVydGllczxTdHJpbmdpZnlPcHRpb25zICYgeyBmb3JtYXR0ZXI6ICh0eXBlb2YgZm9ybWF0dGVycylbJ1JGQzE3MzgnXSB9PjtcblxuZnVuY3Rpb24gaXNfbm9uX251bGxpc2hfcHJpbWl0aXZlKHY6IHVua25vd24pOiB2IGlzIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBzeW1ib2wgfCBiaWdpbnQge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fFxuICAgIHR5cGVvZiB2ID09PSAnYm9vbGVhbicgfHxcbiAgICB0eXBlb2YgdiA9PT0gJ3N5bWJvbCcgfHxcbiAgICB0eXBlb2YgdiA9PT0gJ2JpZ2ludCdcbiAgKTtcbn1cblxuY29uc3Qgc2VudGluZWwgPSB7fTtcblxuZnVuY3Rpb24gaW5uZXJfc3RyaW5naWZ5KFxuICBvYmplY3Q6IGFueSxcbiAgcHJlZml4OiBQcm9wZXJ0eUtleSxcbiAgZ2VuZXJhdGVBcnJheVByZWZpeDogU3RyaW5naWZ5T3B0aW9uc1snYXJyYXlGb3JtYXQnXSB8ICgocHJlZml4OiBzdHJpbmcsIGtleTogc3RyaW5nKSA9PiBzdHJpbmcpLFxuICBjb21tYVJvdW5kVHJpcDogYm9vbGVhbixcbiAgYWxsb3dFbXB0eUFycmF5czogYm9vbGVhbixcbiAgc3RyaWN0TnVsbEhhbmRsaW5nOiBib29sZWFuLFxuICBza2lwTnVsbHM6IGJvb2xlYW4sXG4gIGVuY29kZURvdEluS2V5czogYm9vbGVhbixcbiAgZW5jb2RlcjogU3RyaW5naWZ5T3B0aW9uc1snZW5jb2RlciddLFxuICBmaWx0ZXI6IFN0cmluZ2lmeU9wdGlvbnNbJ2ZpbHRlciddLFxuICBzb3J0OiBTdHJpbmdpZnlPcHRpb25zWydzb3J0J10sXG4gIGFsbG93RG90czogU3RyaW5naWZ5T3B0aW9uc1snYWxsb3dEb3RzJ10sXG4gIHNlcmlhbGl6ZURhdGU6IFN0cmluZ2lmeU9wdGlvbnNbJ3NlcmlhbGl6ZURhdGUnXSxcbiAgZm9ybWF0OiBTdHJpbmdpZnlPcHRpb25zWydmb3JtYXQnXSxcbiAgZm9ybWF0dGVyOiBTdHJpbmdpZnlPcHRpb25zWydmb3JtYXR0ZXInXSxcbiAgZW5jb2RlVmFsdWVzT25seTogYm9vbGVhbixcbiAgY2hhcnNldDogU3RyaW5naWZ5T3B0aW9uc1snY2hhcnNldCddLFxuICBzaWRlQ2hhbm5lbDogV2Vha01hcDxhbnksIGFueT4sXG4pIHtcbiAgbGV0IG9iaiA9IG9iamVjdDtcblxuICBsZXQgdG1wX3NjID0gc2lkZUNoYW5uZWw7XG4gIGxldCBzdGVwID0gMDtcbiAgbGV0IGZpbmRfZmxhZyA9IGZhbHNlO1xuICB3aGlsZSAoKHRtcF9zYyA9IHRtcF9zYy5nZXQoc2VudGluZWwpKSAhPT0gdm9pZCB1bmRlZmluZWQgJiYgIWZpbmRfZmxhZykge1xuICAgIC8vIFdoZXJlIG9iamVjdCBsYXN0IGFwcGVhcmVkIGluIHRoZSByZWYgdHJlZVxuICAgIGNvbnN0IHBvcyA9IHRtcF9zYy5nZXQob2JqZWN0KTtcbiAgICBzdGVwICs9IDE7XG4gICAgaWYgKHR5cGVvZiBwb3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAocG9zID09PSBzdGVwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDeWNsaWMgb2JqZWN0IHZhbHVlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5kX2ZsYWcgPSB0cnVlOyAvLyBCcmVhayB3aGlsZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHRtcF9zYy5nZXQoc2VudGluZWwpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgc3RlcCA9IDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvYmogPSBmaWx0ZXIocHJlZml4LCBvYmopO1xuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICBvYmogPSBzZXJpYWxpemVEYXRlPy4ob2JqKTtcbiAgfSBlbHNlIGlmIChnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIGlzX2FycmF5KG9iaikpIHtcbiAgICBvYmogPSBtYXliZV9tYXAob2JqLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZURhdGU/Lih2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgaWYgKHN0cmljdE51bGxIYW5kbGluZykge1xuICAgICAgcmV0dXJuIGVuY29kZXIgJiYgIWVuY29kZVZhbHVlc09ubHkgP1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ2tleScsIGZvcm1hdClcbiAgICAgICAgOiBwcmVmaXg7XG4gICAgfVxuXG4gICAgb2JqID0gJyc7XG4gIH1cblxuICBpZiAoaXNfbm9uX251bGxpc2hfcHJpbWl0aXZlKG9iaikgfHwgaXNfYnVmZmVyKG9iaikpIHtcbiAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgY29uc3Qga2V5X3ZhbHVlID1cbiAgICAgICAgZW5jb2RlVmFsdWVzT25seSA/IHByZWZpeFxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgOiBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ2tleScsIGZvcm1hdCk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBmb3JtYXR0ZXI/LihrZXlfdmFsdWUpICtcbiAgICAgICAgICAnPScgK1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICBmb3JtYXR0ZXI/LihlbmNvZGVyKG9iaiwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ3ZhbHVlJywgZm9ybWF0KSksXG4gICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW2Zvcm1hdHRlcj8uKHByZWZpeCkgKyAnPScgKyBmb3JtYXR0ZXI/LihTdHJpbmcob2JqKSldO1xuICB9XG5cbiAgY29uc3QgdmFsdWVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICBsZXQgb2JqX2tleXM7XG4gIGlmIChnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIGlzX2FycmF5KG9iaikpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIGpvaW4gZWxlbWVudHMgaW5cbiAgICBpZiAoZW5jb2RlVmFsdWVzT25seSAmJiBlbmNvZGVyKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHZhbHVlcyBvbmx5XG4gICAgICBvYmogPSBtYXliZV9tYXAob2JqLCBlbmNvZGVyKTtcbiAgICB9XG4gICAgb2JqX2tleXMgPSBbeyB2YWx1ZTogb2JqLmxlbmd0aCA+IDAgPyBvYmouam9pbignLCcpIHx8IG51bGwgOiB2b2lkIHVuZGVmaW5lZCB9XTtcbiAgfSBlbHNlIGlmIChpc19hcnJheShmaWx0ZXIpKSB7XG4gICAgb2JqX2tleXMgPSBmaWx0ZXI7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgb2JqX2tleXMgPSBzb3J0ID8ga2V5cy5zb3J0KHNvcnQpIDoga2V5cztcbiAgfVxuXG4gIGNvbnN0IGVuY29kZWRfcHJlZml4ID0gZW5jb2RlRG90SW5LZXlzID8gU3RyaW5nKHByZWZpeCkucmVwbGFjZSgvXFwuL2csICclMkUnKSA6IFN0cmluZyhwcmVmaXgpO1xuXG4gIGNvbnN0IGFkanVzdGVkX3ByZWZpeCA9XG4gICAgY29tbWFSb3VuZFRyaXAgJiYgaXNfYXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID09PSAxID8gZW5jb2RlZF9wcmVmaXggKyAnW10nIDogZW5jb2RlZF9wcmVmaXg7XG5cbiAgaWYgKGFsbG93RW1wdHlBcnJheXMgJiYgaXNfYXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGFkanVzdGVkX3ByZWZpeCArICdbXSc7XG4gIH1cblxuICBmb3IgKGxldCBqID0gMDsgaiA8IG9ial9rZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgY29uc3Qga2V5ID0gb2JqX2tleXNbal07XG4gICAgY29uc3QgdmFsdWUgPVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGtleS52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyBrZXkudmFsdWUgOiBvYmpba2V5IGFzIGFueV07XG5cbiAgICBpZiAoc2tpcE51bGxzICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgZW5jb2RlZF9rZXkgPSBhbGxvd0RvdHMgJiYgZW5jb2RlRG90SW5LZXlzID8gKGtleSBhcyBhbnkpLnJlcGxhY2UoL1xcLi9nLCAnJTJFJykgOiBrZXk7XG4gICAgY29uc3Qga2V5X3ByZWZpeCA9XG4gICAgICBpc19hcnJheShvYmopID9cbiAgICAgICAgdHlwZW9mIGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgoYWRqdXN0ZWRfcHJlZml4LCBlbmNvZGVkX2tleSlcbiAgICAgICAgOiBhZGp1c3RlZF9wcmVmaXhcbiAgICAgIDogYWRqdXN0ZWRfcHJlZml4ICsgKGFsbG93RG90cyA/ICcuJyArIGVuY29kZWRfa2V5IDogJ1snICsgZW5jb2RlZF9rZXkgKyAnXScpO1xuXG4gICAgc2lkZUNoYW5uZWwuc2V0KG9iamVjdCwgc3RlcCk7XG4gICAgY29uc3QgdmFsdWVTaWRlQ2hhbm5lbCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdmFsdWVTaWRlQ2hhbm5lbC5zZXQoc2VudGluZWwsIHNpZGVDaGFubmVsKTtcbiAgICBwdXNoX3RvX2FycmF5KFxuICAgICAgdmFsdWVzLFxuICAgICAgaW5uZXJfc3RyaW5naWZ5KFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAga2V5X3ByZWZpeCxcbiAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgY29tbWFSb3VuZFRyaXAsXG4gICAgICAgIGFsbG93RW1wdHlBcnJheXMsXG4gICAgICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICBlbmNvZGVEb3RJbktleXMsXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBlbmNvZGVWYWx1ZXNPbmx5ICYmIGlzX2FycmF5KG9iaikgPyBudWxsIDogZW5jb2RlcixcbiAgICAgICAgZmlsdGVyLFxuICAgICAgICBzb3J0LFxuICAgICAgICBhbGxvd0RvdHMsXG4gICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgIGZvcm1hdCxcbiAgICAgICAgZm9ybWF0dGVyLFxuICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICBjaGFyc2V0LFxuICAgICAgICB2YWx1ZVNpZGVDaGFubmVsLFxuICAgICAgKSxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplX3N0cmluZ2lmeV9vcHRpb25zKFxuICBvcHRzOiBTdHJpbmdpZnlPcHRpb25zID0gZGVmYXVsdHMsXG4pOiBOb25OdWxsYWJsZVByb3BlcnRpZXM8T21pdDxTdHJpbmdpZnlPcHRpb25zLCAnaW5kaWNlcyc+PiAmIHsgaW5kaWNlcz86IGJvb2xlYW4gfSB7XG4gIGlmICh0eXBlb2Ygb3B0cy5hbGxvd0VtcHR5QXJyYXlzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0cy5hbGxvd0VtcHR5QXJyYXlzICE9PSAnYm9vbGVhbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgYWxsb3dFbXB0eUFycmF5c2Agb3B0aW9uIGNhbiBvbmx5IGJlIGB0cnVlYCBvciBgZmFsc2VgLCB3aGVuIHByb3ZpZGVkJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdHMuZW5jb2RlRG90SW5LZXlzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0cy5lbmNvZGVEb3RJbktleXMgIT09ICdib29sZWFuJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BlbmNvZGVEb3RJbktleXNgIG9wdGlvbiBjYW4gb25seSBiZSBgdHJ1ZWAgb3IgYGZhbHNlYCwgd2hlbiBwcm92aWRlZCcpO1xuICB9XG5cbiAgaWYgKG9wdHMuZW5jb2RlciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0cy5lbmNvZGVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0cy5lbmNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5jb2RlciBoYXMgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIGNvbnN0IGNoYXJzZXQgPSBvcHRzLmNoYXJzZXQgfHwgZGVmYXVsdHMuY2hhcnNldDtcbiAgaWYgKHR5cGVvZiBvcHRzLmNoYXJzZXQgIT09ICd1bmRlZmluZWQnICYmIG9wdHMuY2hhcnNldCAhPT0gJ3V0Zi04JyAmJiBvcHRzLmNoYXJzZXQgIT09ICdpc28tODg1OS0xJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjaGFyc2V0IG9wdGlvbiBtdXN0IGJlIGVpdGhlciB1dGYtOCwgaXNvLTg4NTktMSwgb3IgdW5kZWZpbmVkJyk7XG4gIH1cblxuICBsZXQgZm9ybWF0ID0gZGVmYXVsdF9mb3JtYXQ7XG4gIGlmICh0eXBlb2Ygb3B0cy5mb3JtYXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKCFoYXMuY2FsbChmb3JtYXR0ZXJzLCBvcHRzLmZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZm9ybWF0IG9wdGlvbiBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgZm9ybWF0ID0gb3B0cy5mb3JtYXQ7XG4gIH1cbiAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0dGVyc1tmb3JtYXRdO1xuXG4gIGxldCBmaWx0ZXIgPSBkZWZhdWx0cy5maWx0ZXI7XG4gIGlmICh0eXBlb2Ygb3B0cy5maWx0ZXIgPT09ICdmdW5jdGlvbicgfHwgaXNfYXJyYXkob3B0cy5maWx0ZXIpKSB7XG4gICAgZmlsdGVyID0gb3B0cy5maWx0ZXI7XG4gIH1cblxuICBsZXQgYXJyYXlGb3JtYXQ6IFN0cmluZ2lmeU9wdGlvbnNbJ2FycmF5Rm9ybWF0J107XG4gIGlmIChvcHRzLmFycmF5Rm9ybWF0ICYmIG9wdHMuYXJyYXlGb3JtYXQgaW4gYXJyYXlfcHJlZml4X2dlbmVyYXRvcnMpIHtcbiAgICBhcnJheUZvcm1hdCA9IG9wdHMuYXJyYXlGb3JtYXQ7XG4gIH0gZWxzZSBpZiAoJ2luZGljZXMnIGluIG9wdHMpIHtcbiAgICBhcnJheUZvcm1hdCA9IG9wdHMuaW5kaWNlcyA/ICdpbmRpY2VzJyA6ICdyZXBlYXQnO1xuICB9IGVsc2Uge1xuICAgIGFycmF5Rm9ybWF0ID0gZGVmYXVsdHMuYXJyYXlGb3JtYXQ7XG4gIH1cblxuICBpZiAoJ2NvbW1hUm91bmRUcmlwJyBpbiBvcHRzICYmIHR5cGVvZiBvcHRzLmNvbW1hUm91bmRUcmlwICE9PSAnYm9vbGVhbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgY29tbWFSb3VuZFRyaXBgIG11c3QgYmUgYSBib29sZWFuLCBvciBhYnNlbnQnKTtcbiAgfVxuXG4gIGNvbnN0IGFsbG93RG90cyA9XG4gICAgdHlwZW9mIG9wdHMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/XG4gICAgICAhIW9wdHMuZW5jb2RlRG90SW5LZXlzID09PSB0cnVlID9cbiAgICAgICAgdHJ1ZVxuICAgICAgOiBkZWZhdWx0cy5hbGxvd0RvdHNcbiAgICA6ICEhb3B0cy5hbGxvd0RvdHM7XG5cbiAgcmV0dXJuIHtcbiAgICBhZGRRdWVyeVByZWZpeDogdHlwZW9mIG9wdHMuYWRkUXVlcnlQcmVmaXggPT09ICdib29sZWFuJyA/IG9wdHMuYWRkUXVlcnlQcmVmaXggOiBkZWZhdWx0cy5hZGRRdWVyeVByZWZpeCxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYWxsb3dEb3RzOiBhbGxvd0RvdHMsXG4gICAgYWxsb3dFbXB0eUFycmF5czpcbiAgICAgIHR5cGVvZiBvcHRzLmFsbG93RW1wdHlBcnJheXMgPT09ICdib29sZWFuJyA/ICEhb3B0cy5hbGxvd0VtcHR5QXJyYXlzIDogZGVmYXVsdHMuYWxsb3dFbXB0eUFycmF5cyxcbiAgICBhcnJheUZvcm1hdDogYXJyYXlGb3JtYXQsXG4gICAgY2hhcnNldDogY2hhcnNldCxcbiAgICBjaGFyc2V0U2VudGluZWw6XG4gICAgICB0eXBlb2Ygb3B0cy5jaGFyc2V0U2VudGluZWwgPT09ICdib29sZWFuJyA/IG9wdHMuY2hhcnNldFNlbnRpbmVsIDogZGVmYXVsdHMuY2hhcnNldFNlbnRpbmVsLFxuICAgIGNvbW1hUm91bmRUcmlwOiAhIW9wdHMuY29tbWFSb3VuZFRyaXAsXG4gICAgZGVsaW1pdGVyOiB0eXBlb2Ygb3B0cy5kZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuZGVsaW1pdGVyIDogb3B0cy5kZWxpbWl0ZXIsXG4gICAgZW5jb2RlOiB0eXBlb2Ygb3B0cy5lbmNvZGUgPT09ICdib29sZWFuJyA/IG9wdHMuZW5jb2RlIDogZGVmYXVsdHMuZW5jb2RlLFxuICAgIGVuY29kZURvdEluS2V5czpcbiAgICAgIHR5cGVvZiBvcHRzLmVuY29kZURvdEluS2V5cyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5lbmNvZGVEb3RJbktleXMgOiBkZWZhdWx0cy5lbmNvZGVEb3RJbktleXMsXG4gICAgZW5jb2RlcjogdHlwZW9mIG9wdHMuZW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuZW5jb2RlciA6IGRlZmF1bHRzLmVuY29kZXIsXG4gICAgZW5jb2RlVmFsdWVzT25seTpcbiAgICAgIHR5cGVvZiBvcHRzLmVuY29kZVZhbHVlc09ubHkgPT09ICdib29sZWFuJyA/IG9wdHMuZW5jb2RlVmFsdWVzT25seSA6IGRlZmF1bHRzLmVuY29kZVZhbHVlc09ubHksXG4gICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG4gICAgc2VyaWFsaXplRGF0ZTogdHlwZW9mIG9wdHMuc2VyaWFsaXplRGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuc2VyaWFsaXplRGF0ZSA6IGRlZmF1bHRzLnNlcmlhbGl6ZURhdGUsXG4gICAgc2tpcE51bGxzOiB0eXBlb2Ygb3B0cy5za2lwTnVsbHMgPT09ICdib29sZWFuJyA/IG9wdHMuc2tpcE51bGxzIDogZGVmYXVsdHMuc2tpcE51bGxzLFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBzb3J0OiB0eXBlb2Ygb3B0cy5zb3J0ID09PSAnZnVuY3Rpb24nID8gb3B0cy5zb3J0IDogbnVsbCxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6XG4gICAgICB0eXBlb2Ygb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgPT09ICdib29sZWFuJyA/IG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nIDogZGVmYXVsdHMuc3RyaWN0TnVsbEhhbmRsaW5nLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5KG9iamVjdDogYW55LCBvcHRzOiBTdHJpbmdpZnlPcHRpb25zID0ge30pIHtcbiAgbGV0IG9iaiA9IG9iamVjdDtcbiAgY29uc3Qgb3B0aW9ucyA9IG5vcm1hbGl6ZV9zdHJpbmdpZnlfb3B0aW9ucyhvcHRzKTtcblxuICBsZXQgb2JqX2tleXM6IFByb3BlcnR5S2V5W10gfCB1bmRlZmluZWQ7XG4gIGxldCBmaWx0ZXI7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgIG9iaiA9IGZpbHRlcignJywgb2JqKTtcbiAgfSBlbHNlIGlmIChpc19hcnJheShvcHRpb25zLmZpbHRlcikpIHtcbiAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICBvYmpfa2V5cyA9IGZpbHRlcjtcbiAgfVxuXG4gIGNvbnN0IGtleXM6IHN0cmluZ1tdID0gW107XG5cbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGNvbnN0IGdlbmVyYXRlQXJyYXlQcmVmaXggPSBhcnJheV9wcmVmaXhfZ2VuZXJhdG9yc1tvcHRpb25zLmFycmF5Rm9ybWF0XTtcbiAgY29uc3QgY29tbWFSb3VuZFRyaXAgPSBnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIG9wdGlvbnMuY29tbWFSb3VuZFRyaXA7XG5cbiAgaWYgKCFvYmpfa2V5cykge1xuICAgIG9ial9rZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnNvcnQpIHtcbiAgICBvYmpfa2V5cy5zb3J0KG9wdGlvbnMuc29ydCk7XG4gIH1cblxuICBjb25zdCBzaWRlQ2hhbm5lbCA9IG5ldyBXZWFrTWFwKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqX2tleXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBrZXkgPSBvYmpfa2V5c1tpXSE7XG5cbiAgICBpZiAob3B0aW9ucy5za2lwTnVsbHMgJiYgb2JqW2tleV0gPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwdXNoX3RvX2FycmF5KFxuICAgICAga2V5cyxcbiAgICAgIGlubmVyX3N0cmluZ2lmeShcbiAgICAgICAgb2JqW2tleV0sXG4gICAgICAgIGtleSxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICBjb21tYVJvdW5kVHJpcCxcbiAgICAgICAgb3B0aW9ucy5hbGxvd0VtcHR5QXJyYXlzLFxuICAgICAgICBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgb3B0aW9ucy5za2lwTnVsbHMsXG4gICAgICAgIG9wdGlvbnMuZW5jb2RlRG90SW5LZXlzLFxuICAgICAgICBvcHRpb25zLmVuY29kZSA/IG9wdGlvbnMuZW5jb2RlciA6IG51bGwsXG4gICAgICAgIG9wdGlvbnMuZmlsdGVyLFxuICAgICAgICBvcHRpb25zLnNvcnQsXG4gICAgICAgIG9wdGlvbnMuYWxsb3dEb3RzLFxuICAgICAgICBvcHRpb25zLnNlcmlhbGl6ZURhdGUsXG4gICAgICAgIG9wdGlvbnMuZm9ybWF0LFxuICAgICAgICBvcHRpb25zLmZvcm1hdHRlcixcbiAgICAgICAgb3B0aW9ucy5lbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICBvcHRpb25zLmNoYXJzZXQsXG4gICAgICAgIHNpZGVDaGFubmVsLFxuICAgICAgKSxcbiAgICApO1xuICB9XG5cbiAgY29uc3Qgam9pbmVkID0ga2V5cy5qb2luKG9wdGlvbnMuZGVsaW1pdGVyKTtcbiAgbGV0IHByZWZpeCA9IG9wdGlvbnMuYWRkUXVlcnlQcmVmaXggPT09IHRydWUgPyAnPycgOiAnJztcblxuICBpZiAob3B0aW9ucy5jaGFyc2V0U2VudGluZWwpIHtcbiAgICBpZiAob3B0aW9ucy5jaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgIC8vIGVuY29kZVVSSUNvbXBvbmVudCgnJiMxMDAwMzsnKSwgdGhlIFwibnVtZXJpYyBlbnRpdHlcIiByZXByZXNlbnRhdGlvbiBvZiBhIGNoZWNrbWFya1xuICAgICAgcHJlZml4ICs9ICd1dGY4PSUyNiUyMzEwMDAzJTNCJic7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVuY29kZVVSSUNvbXBvbmVudCgnXHUyNzEzJylcbiAgICAgIHByZWZpeCArPSAndXRmOD0lRTIlOUMlOTMmJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gam9pbmVkLmxlbmd0aCA+IDAgPyBwcmVmaXggKyBqb2luZWQgOiAnJztcbn1cbiIsICJleHBvcnQgY29uc3QgVkVSU0lPTiA9ICc0Ljc5LjEnOyAvLyB4LXJlbGVhc2UtcGxlYXNlLXZlcnNpb25cbiIsICIvKipcbiAqIERpc2NsYWltZXI6IG1vZHVsZXMgaW4gX3NoaW1zIGFyZW4ndCBpbnRlbmRlZCB0byBiZSBpbXBvcnRlZCBieSBTREsgdXNlcnMuXG4gKi9cbmltcG9ydCB7IHR5cGUgUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi9jb3JlJztcblxuZXhwb3J0IGludGVyZmFjZSBTaGltcyB7XG4gIGtpbmQ6IHN0cmluZztcbiAgZmV0Y2g6IGFueTtcbiAgUmVxdWVzdDogYW55O1xuICBSZXNwb25zZTogYW55O1xuICBIZWFkZXJzOiBhbnk7XG4gIEZvcm1EYXRhOiBhbnk7XG4gIEJsb2I6IGFueTtcbiAgRmlsZTogYW55O1xuICBSZWFkYWJsZVN0cmVhbTogYW55O1xuICBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9uczogPFQgPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gICAgZm9ybTogU2hpbXNbJ0Zvcm1EYXRhJ10sXG4gICAgb3B0czogUmVxdWVzdE9wdGlvbnM8VD4sXG4gICkgPT4gUHJvbWlzZTxSZXF1ZXN0T3B0aW9uczxUPj47XG4gIGdldERlZmF1bHRBZ2VudDogKHVybDogc3RyaW5nKSA9PiBhbnk7XG4gIGZpbGVGcm9tUGF0aDpcbiAgICB8ICgocGF0aDogc3RyaW5nLCBmaWxlbmFtZT86IHN0cmluZywgb3B0aW9ucz86IHt9KSA9PiBQcm9taXNlPFNoaW1zWydGaWxlJ10+KVxuICAgIHwgKChwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiB7fSkgPT4gUHJvbWlzZTxTaGltc1snRmlsZSddPik7XG4gIGlzRnNSZWFkU3RyZWFtOiAodmFsdWU6IGFueSkgPT4gYm9vbGVhbjtcbn1cblxuZXhwb3J0IGxldCBhdXRvID0gZmFsc2U7XG5leHBvcnQgbGV0IGtpbmQ6IFNoaW1zWydraW5kJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGZldGNoOiBTaGltc1snZmV0Y2gnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgUmVxdWVzdDogU2hpbXNbJ1JlcXVlc3QnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgUmVzcG9uc2U6IFNoaW1zWydSZXNwb25zZSddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBIZWFkZXJzOiBTaGltc1snSGVhZGVycyddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBGb3JtRGF0YTogU2hpbXNbJ0Zvcm1EYXRhJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IEJsb2I6IFNoaW1zWydCbG9iJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IEZpbGU6IFNoaW1zWydGaWxlJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IFJlYWRhYmxlU3RyZWFtOiBTaGltc1snUmVhZGFibGVTdHJlYW0nXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnM6IFNoaW1zWydnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucyddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBnZXREZWZhdWx0QWdlbnQ6IFNoaW1zWydnZXREZWZhdWx0QWdlbnQnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgZmlsZUZyb21QYXRoOiBTaGltc1snZmlsZUZyb21QYXRoJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGlzRnNSZWFkU3RyZWFtOiBTaGltc1snaXNGc1JlYWRTdHJlYW0nXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldFNoaW1zKHNoaW1zOiBTaGltcywgb3B0aW9uczogeyBhdXRvOiBib29sZWFuIH0gPSB7IGF1dG86IGZhbHNlIH0pIHtcbiAgaWYgKGF1dG8pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgeW91IG11c3QgXFxgaW1wb3J0ICdvcGVuYWkvc2hpbXMvJHtzaGltcy5raW5kfSdcXGAgYmVmb3JlIGltcG9ydGluZyBhbnl0aGluZyBlbHNlIGZyb20gb3BlbmFpYCxcbiAgICApO1xuICB9XG4gIGlmIChraW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBjYW4ndCBcXGBpbXBvcnQgJ29wZW5haS9zaGltcy8ke3NoaW1zLmtpbmR9J1xcYCBhZnRlciBcXGBpbXBvcnQgJ29wZW5haS9zaGltcy8ke2tpbmR9J1xcYGApO1xuICB9XG4gIGF1dG8gPSBvcHRpb25zLmF1dG87XG4gIGtpbmQgPSBzaGltcy5raW5kO1xuICBmZXRjaCA9IHNoaW1zLmZldGNoO1xuICBSZXF1ZXN0ID0gc2hpbXMuUmVxdWVzdDtcbiAgUmVzcG9uc2UgPSBzaGltcy5SZXNwb25zZTtcbiAgSGVhZGVycyA9IHNoaW1zLkhlYWRlcnM7XG4gIEZvcm1EYXRhID0gc2hpbXMuRm9ybURhdGE7XG4gIEJsb2IgPSBzaGltcy5CbG9iO1xuICBGaWxlID0gc2hpbXMuRmlsZTtcbiAgUmVhZGFibGVTdHJlYW0gPSBzaGltcy5SZWFkYWJsZVN0cmVhbTtcbiAgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMgPSBzaGltcy5nZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucztcbiAgZ2V0RGVmYXVsdEFnZW50ID0gc2hpbXMuZ2V0RGVmYXVsdEFnZW50O1xuICBmaWxlRnJvbVBhdGggPSBzaGltcy5maWxlRnJvbVBhdGg7XG4gIGlzRnNSZWFkU3RyZWFtID0gc2hpbXMuaXNGc1JlYWRTdHJlYW07XG59XG4iLCAiLyoqXG4gKiBEaXNjbGFpbWVyOiBtb2R1bGVzIGluIF9zaGltcyBhcmVuJ3QgaW50ZW5kZWQgdG8gYmUgaW1wb3J0ZWQgYnkgU0RLIHVzZXJzLlxuICovXG5leHBvcnQgY2xhc3MgTXVsdGlwYXJ0Qm9keSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBib2R5OiBhbnkpIHt9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnTXVsdGlwYXJ0Qm9keSc7XG4gIH1cbn1cbiIsICIvKipcbiAqIERpc2NsYWltZXI6IG1vZHVsZXMgaW4gX3NoaW1zIGFyZW4ndCBpbnRlbmRlZCB0byBiZSBpbXBvcnRlZCBieSBTREsgdXNlcnMuXG4gKi9cbmltcG9ydCB7IE11bHRpcGFydEJvZHkgfSBmcm9tICcuL011bHRpcGFydEJvZHknO1xuaW1wb3J0IHsgdHlwZSBSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0IHsgdHlwZSBTaGltcyB9IGZyb20gJy4vcmVnaXN0cnknO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UnVudGltZSh7IG1hbnVhbGx5SW1wb3J0ZWQgfTogeyBtYW51YWxseUltcG9ydGVkPzogYm9vbGVhbiB9ID0ge30pOiBTaGltcyB7XG4gIGNvbnN0IHJlY29tbWVuZGF0aW9uID1cbiAgICBtYW51YWxseUltcG9ydGVkID9cbiAgICAgIGBZb3UgbWF5IG5lZWQgdG8gdXNlIHBvbHlmaWxsc2BcbiAgICA6IGBBZGQgb25lIG9mIHRoZXNlIGltcG9ydHMgYmVmb3JlIHlvdXIgZmlyc3QgXFxgaW1wb3J0IFx1MjAyNiBmcm9tICdvcGVuYWknXFxgOlxuLSBcXGBpbXBvcnQgJ29wZW5haS9zaGltcy9ub2RlJ1xcYCAoaWYgeW91J3JlIHJ1bm5pbmcgb24gTm9kZSlcbi0gXFxgaW1wb3J0ICdvcGVuYWkvc2hpbXMvd2ViJ1xcYCAob3RoZXJ3aXNlKVxuYDtcblxuICBsZXQgX2ZldGNoLCBfUmVxdWVzdCwgX1Jlc3BvbnNlLCBfSGVhZGVycztcbiAgdHJ5IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgX2ZldGNoID0gZmV0Y2g7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIF9SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgX1Jlc3BvbnNlID0gUmVzcG9uc2U7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIF9IZWFkZXJzID0gSGVhZGVycztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgdGhpcyBlbnZpcm9ubWVudCBpcyBtaXNzaW5nIHRoZSBmb2xsb3dpbmcgV2ViIEZldGNoIEFQSSB0eXBlOiAke1xuICAgICAgICAoZXJyb3IgYXMgYW55KS5tZXNzYWdlXG4gICAgICB9LiAke3JlY29tbWVuZGF0aW9ufWAsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAga2luZDogJ3dlYicsXG4gICAgZmV0Y2g6IF9mZXRjaCxcbiAgICBSZXF1ZXN0OiBfUmVxdWVzdCxcbiAgICBSZXNwb25zZTogX1Jlc3BvbnNlLFxuICAgIEhlYWRlcnM6IF9IZWFkZXJzLFxuICAgIEZvcm1EYXRhOlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyA/IEZvcm1EYXRhIDogKFxuICAgICAgICBjbGFzcyBGb3JtRGF0YSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgZmlsZSB1cGxvYWRzIGFyZW4ndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCB5ZXQgYXMgJ0Zvcm1EYXRhJyBpcyB1bmRlZmluZWQuICR7cmVjb21tZW5kYXRpb259YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgIEJsb2I6XG4gICAgICB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iIDogKFxuICAgICAgICBjbGFzcyBCbG9iIHtcbiAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYGZpbGUgdXBsb2FkcyBhcmVuJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQgeWV0IGFzICdCbG9iJyBpcyB1bmRlZmluZWQuICR7cmVjb21tZW5kYXRpb259YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgIEZpbGU6XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgPyBGaWxlIDogKFxuICAgICAgICBjbGFzcyBGaWxlIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBmaWxlIHVwbG9hZHMgYXJlbid0IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50IHlldCBhcyAnRmlsZScgaXMgdW5kZWZpbmVkLiAke3JlY29tbWVuZGF0aW9ufWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICBSZWFkYWJsZVN0cmVhbTpcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHR5cGVvZiBSZWFkYWJsZVN0cmVhbSAhPT0gJ3VuZGVmaW5lZCcgPyBSZWFkYWJsZVN0cmVhbSA6IChcbiAgICAgICAgY2xhc3MgUmVhZGFibGVTdHJlYW0ge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYHN0cmVhbWluZyBpc24ndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCB5ZXQgYXMgJ1JlYWRhYmxlU3RyZWFtJyBpcyB1bmRlZmluZWQuICR7cmVjb21tZW5kYXRpb259YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgIGdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zOiBhc3luYyA8VCA9IFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGZvcm06IEZvcm1EYXRhLFxuICAgICAgb3B0czogUmVxdWVzdE9wdGlvbnM8VD4sXG4gICAgKTogUHJvbWlzZTxSZXF1ZXN0T3B0aW9uczxUPj4gPT4gKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBib2R5OiBuZXcgTXVsdGlwYXJ0Qm9keShmb3JtKSBhcyBhbnksXG4gICAgfSksXG4gICAgZ2V0RGVmYXVsdEFnZW50OiAodXJsOiBzdHJpbmcpID0+IHVuZGVmaW5lZCxcbiAgICBmaWxlRnJvbVBhdGg6ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSBgZmlsZUZyb21QYXRoYCBmdW5jdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBpbiBOb2RlLiBTZWUgdGhlIFJFQURNRSBmb3IgbW9yZSBkZXRhaWxzOiBodHRwczovL3d3dy5naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZSNmaWxlLXVwbG9hZHMnLFxuICAgICAgKTtcbiAgICB9LFxuICAgIGlzRnNSZWFkU3RyZWFtOiAodmFsdWU6IGFueSkgPT4gZmFsc2UsXG4gIH07XG59XG4iLCAiLyoqXG4gKiBEaXNjbGFpbWVyOiBtb2R1bGVzIGluIF9zaGltcyBhcmVuJ3QgaW50ZW5kZWQgdG8gYmUgaW1wb3J0ZWQgYnkgU0RLIHVzZXJzLlxuICovXG5pbXBvcnQgKiBhcyBzaGltcyBmcm9tICcuL3JlZ2lzdHJ5Lm1qcyc7XG5pbXBvcnQgKiBhcyBhdXRvIGZyb20gJ29wZW5haS9fc2hpbXMvYXV0by9ydW50aW1lJztcbmlmICghc2hpbXMua2luZCkgc2hpbXMuc2V0U2hpbXMoYXV0by5nZXRSdW50aW1lKCksIHsgYXV0bzogdHJ1ZSB9KTtcbmV4cG9ydCAqIGZyb20gJy4vcmVnaXN0cnkubWpzJztcbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBjYXN0VG9FcnJvciwgSGVhZGVycyB9IGZyb20gJy4vY29yZSc7XG5cbmV4cG9ydCBjbGFzcyBPcGVuQUlFcnJvciBleHRlbmRzIEVycm9yIHt9XG5cbmV4cG9ydCBjbGFzcyBBUElFcnJvcjxcbiAgVFN0YXR1cyBleHRlbmRzIG51bWJlciB8IHVuZGVmaW5lZCA9IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgVEhlYWRlcnMgZXh0ZW5kcyBIZWFkZXJzIHwgdW5kZWZpbmVkID0gSGVhZGVycyB8IHVuZGVmaW5lZCxcbiAgVEVycm9yIGV4dGVuZHMgT2JqZWN0IHwgdW5kZWZpbmVkID0gT2JqZWN0IHwgdW5kZWZpbmVkLFxuPiBleHRlbmRzIE9wZW5BSUVycm9yIHtcbiAgLyoqIEhUVFAgc3RhdHVzIGZvciB0aGUgcmVzcG9uc2UgdGhhdCBjYXVzZWQgdGhlIGVycm9yICovXG4gIHJlYWRvbmx5IHN0YXR1czogVFN0YXR1cztcbiAgLyoqIEhUVFAgaGVhZGVycyBmb3IgdGhlIHJlc3BvbnNlIHRoYXQgY2F1c2VkIHRoZSBlcnJvciAqL1xuICByZWFkb25seSBoZWFkZXJzOiBUSGVhZGVycztcbiAgLyoqIEpTT04gYm9keSBvZiB0aGUgcmVzcG9uc2UgdGhhdCBjYXVzZWQgdGhlIGVycm9yICovXG4gIHJlYWRvbmx5IGVycm9yOiBURXJyb3I7XG5cbiAgcmVhZG9ubHkgY29kZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgcmVhZG9ubHkgcGFyYW06IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG4gIHJlYWRvbmx5IHR5cGU6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICByZWFkb25seSByZXF1ZXN0X2lkOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKHN0YXR1czogVFN0YXR1cywgZXJyb3I6IFRFcnJvciwgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBoZWFkZXJzOiBUSGVhZGVycykge1xuICAgIHN1cGVyKGAke0FQSUVycm9yLm1ha2VNZXNzYWdlKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UpfWApO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5yZXF1ZXN0X2lkID0gaGVhZGVycz8uWyd4LXJlcXVlc3QtaWQnXTtcbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XG5cbiAgICBjb25zdCBkYXRhID0gZXJyb3IgYXMgUmVjb3JkPHN0cmluZywgYW55PjtcbiAgICB0aGlzLmNvZGUgPSBkYXRhPy5bJ2NvZGUnXTtcbiAgICB0aGlzLnBhcmFtID0gZGF0YT8uWydwYXJhbSddO1xuICAgIHRoaXMudHlwZSA9IGRhdGE/LlsndHlwZSddO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgbWFrZU1lc3NhZ2Uoc3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWQsIGVycm9yOiBhbnksIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG1zZyA9XG4gICAgICBlcnJvcj8ubWVzc2FnZSA/XG4gICAgICAgIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgZXJyb3IubWVzc2FnZVxuICAgICAgICA6IEpTT04uc3RyaW5naWZ5KGVycm9yLm1lc3NhZ2UpXG4gICAgICA6IGVycm9yID8gSlNPTi5zdHJpbmdpZnkoZXJyb3IpXG4gICAgICA6IG1lc3NhZ2U7XG5cbiAgICBpZiAoc3RhdHVzICYmIG1zZykge1xuICAgICAgcmV0dXJuIGAke3N0YXR1c30gJHttc2d9YDtcbiAgICB9XG4gICAgaWYgKHN0YXR1cykge1xuICAgICAgcmV0dXJuIGAke3N0YXR1c30gc3RhdHVzIGNvZGUgKG5vIGJvZHkpYDtcbiAgICB9XG4gICAgaWYgKG1zZykge1xuICAgICAgcmV0dXJuIG1zZztcbiAgICB9XG4gICAgcmV0dXJuICcobm8gc3RhdHVzIGNvZGUgb3IgYm9keSknO1xuICB9XG5cbiAgc3RhdGljIGdlbmVyYXRlKFxuICAgIHN0YXR1czogbnVtYmVyIHwgdW5kZWZpbmVkLFxuICAgIGVycm9yUmVzcG9uc2U6IE9iamVjdCB8IHVuZGVmaW5lZCxcbiAgICBtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgaGVhZGVyczogSGVhZGVycyB8IHVuZGVmaW5lZCxcbiAgKTogQVBJRXJyb3Ige1xuICAgIGlmICghc3RhdHVzIHx8ICFoZWFkZXJzKSB7XG4gICAgICByZXR1cm4gbmV3IEFQSUNvbm5lY3Rpb25FcnJvcih7IG1lc3NhZ2UsIGNhdXNlOiBjYXN0VG9FcnJvcihlcnJvclJlc3BvbnNlKSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvciA9IChlcnJvclJlc3BvbnNlIGFzIFJlY29yZDxzdHJpbmcsIGFueT4pPy5bJ2Vycm9yJ107XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MDApIHtcbiAgICAgIHJldHVybiBuZXcgQmFkUmVxdWVzdEVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IDQwMSkge1xuICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IDQwMykge1xuICAgICAgcmV0dXJuIG5ldyBQZXJtaXNzaW9uRGVuaWVkRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDA5KSB7XG4gICAgICByZXR1cm4gbmV3IENvbmZsaWN0RXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDIyKSB7XG4gICAgICByZXR1cm4gbmV3IFVucHJvY2Vzc2FibGVFbnRpdHlFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MjkpIHtcbiAgICAgIHJldHVybiBuZXcgUmF0ZUxpbWl0RXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA+PSA1MDApIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJuYWxTZXJ2ZXJFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFQSUVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBUElVc2VyQWJvcnRFcnJvciBleHRlbmRzIEFQSUVycm9yPHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQ+IHtcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlIH06IHsgbWVzc2FnZT86IHN0cmluZyB9ID0ge30pIHtcbiAgICBzdXBlcih1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWVzc2FnZSB8fCAnUmVxdWVzdCB3YXMgYWJvcnRlZC4nLCB1bmRlZmluZWQpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBUElDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBBUElFcnJvcjx1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkPiB7XG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSwgY2F1c2UgfTogeyBtZXNzYWdlPzogc3RyaW5nIHwgdW5kZWZpbmVkOyBjYXVzZT86IEVycm9yIHwgdW5kZWZpbmVkIH0pIHtcbiAgICBzdXBlcih1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWVzc2FnZSB8fCAnQ29ubmVjdGlvbiBlcnJvci4nLCB1bmRlZmluZWQpO1xuICAgIC8vIGluIHNvbWUgZW52aXJvbm1lbnRzIHRoZSAnY2F1c2UnIHByb3BlcnR5IGlzIGFscmVhZHkgZGVjbGFyZWRcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGNhdXNlKSB0aGlzLmNhdXNlID0gY2F1c2U7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IgZXh0ZW5kcyBBUElDb25uZWN0aW9uRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfTogeyBtZXNzYWdlPzogc3RyaW5nIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbWVzc2FnZTogbWVzc2FnZSA/PyAnUmVxdWVzdCB0aW1lZCBvdXQuJyB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmFkUmVxdWVzdEVycm9yIGV4dGVuZHMgQVBJRXJyb3I8NDAwLCBIZWFkZXJzPiB7fVxuXG5leHBvcnQgY2xhc3MgQXV0aGVudGljYXRpb25FcnJvciBleHRlbmRzIEFQSUVycm9yPDQwMSwgSGVhZGVycz4ge31cblxuZXhwb3J0IGNsYXNzIFBlcm1pc3Npb25EZW5pZWRFcnJvciBleHRlbmRzIEFQSUVycm9yPDQwMywgSGVhZGVycz4ge31cblxuZXhwb3J0IGNsYXNzIE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBBUElFcnJvcjw0MDQsIEhlYWRlcnM+IHt9XG5cbmV4cG9ydCBjbGFzcyBDb25mbGljdEVycm9yIGV4dGVuZHMgQVBJRXJyb3I8NDA5LCBIZWFkZXJzPiB7fVxuXG5leHBvcnQgY2xhc3MgVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yIGV4dGVuZHMgQVBJRXJyb3I8NDIyLCBIZWFkZXJzPiB7fVxuXG5leHBvcnQgY2xhc3MgUmF0ZUxpbWl0RXJyb3IgZXh0ZW5kcyBBUElFcnJvcjw0MjksIEhlYWRlcnM+IHt9XG5cbmV4cG9ydCBjbGFzcyBJbnRlcm5hbFNlcnZlckVycm9yIGV4dGVuZHMgQVBJRXJyb3I8bnVtYmVyLCBIZWFkZXJzPiB7fVxuXG5leHBvcnQgY2xhc3MgTGVuZ3RoRmluaXNoUmVhc29uRXJyb3IgZXh0ZW5kcyBPcGVuQUlFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGBDb3VsZCBub3QgcGFyc2UgcmVzcG9uc2UgY29udGVudCBhcyB0aGUgbGVuZ3RoIGxpbWl0IHdhcyByZWFjaGVkYCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIENvbnRlbnRGaWx0ZXJGaW5pc2hSZWFzb25FcnJvciBleHRlbmRzIE9wZW5BSUVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYENvdWxkIG5vdCBwYXJzZSByZXNwb25zZSBjb250ZW50IGFzIHRoZSByZXF1ZXN0IHdhcyByZWplY3RlZCBieSB0aGUgY29udGVudCBmaWx0ZXJgKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IE9wZW5BSUVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3InO1xuXG50eXBlIEJ5dGVzID0gc3RyaW5nIHwgQXJyYXlCdWZmZXIgfCBVaW50OEFycmF5IHwgQnVmZmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHJlLWltcGxlbWVudGF0aW9uIG9mIGh0dHB4J3MgYExpbmVEZWNvZGVyYCBpbiBQeXRob24gdGhhdCBoYW5kbGVzIGluY3JlbWVudGFsbHlcbiAqIHJlYWRpbmcgbGluZXMgZnJvbSB0ZXh0LlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lbmNvZGUvaHR0cHgvYmxvYi85MjAzMzNlYTk4MTE4ZTljZjYxN2YyNDY5MDVkN2IyMDI1MTA5NDFjL2h0dHB4L19kZWNvZGVycy5weSNMMjU4XG4gKi9cbmV4cG9ydCBjbGFzcyBMaW5lRGVjb2RlciB7XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBzdGF0aWMgTkVXTElORV9DSEFSUyA9IG5ldyBTZXQoWydcXG4nLCAnXFxyJ10pO1xuICBzdGF0aWMgTkVXTElORV9SRUdFWFAgPSAvXFxyXFxufFtcXG5cXHJdL2c7XG5cbiAgYnVmZmVyOiBzdHJpbmdbXTtcbiAgdHJhaWxpbmdDUjogYm9vbGVhbjtcbiAgdGV4dERlY29kZXI6IGFueTsgLy8gVGV4dERlY29kZXIgZm91bmQgaW4gYnJvd3NlcnM7IG5vdCB0eXBlZCB0byBhdm9pZCBwdWxsaW5nIGluIGVpdGhlciBcImRvbVwiIG9yIFwibm9kZVwiIHR5cGVzLlxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgdGhpcy50cmFpbGluZ0NSID0gZmFsc2U7XG4gIH1cblxuICBkZWNvZGUoY2h1bms6IEJ5dGVzKTogc3RyaW5nW10ge1xuICAgIGxldCB0ZXh0ID0gdGhpcy5kZWNvZGVUZXh0KGNodW5rKTtcblxuICAgIGlmICh0aGlzLnRyYWlsaW5nQ1IpIHtcbiAgICAgIHRleHQgPSAnXFxyJyArIHRleHQ7XG4gICAgICB0aGlzLnRyYWlsaW5nQ1IgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRleHQuZW5kc1dpdGgoJ1xccicpKSB7XG4gICAgICB0aGlzLnRyYWlsaW5nQ1IgPSB0cnVlO1xuICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgLTEpO1xuICAgIH1cblxuICAgIGlmICghdGV4dCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYWlsaW5nTmV3bGluZSA9IExpbmVEZWNvZGVyLk5FV0xJTkVfQ0hBUlMuaGFzKHRleHRbdGV4dC5sZW5ndGggLSAxXSB8fCAnJyk7XG4gICAgbGV0IGxpbmVzID0gdGV4dC5zcGxpdChMaW5lRGVjb2Rlci5ORVdMSU5FX1JFR0VYUCk7XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBhIHRyYWlsaW5nIG5ldyBsaW5lIHRoZW4gdGhlIGxhc3QgZW50cnkgd2lsbCBiZSBhbiBlbXB0eVxuICAgIC8vIHN0cmluZyB3aGljaCB3ZSBkb24ndCBjYXJlIGFib3V0XG4gICAgaWYgKHRyYWlsaW5nTmV3bGluZSkge1xuICAgICAgbGluZXMucG9wKCk7XG4gICAgfVxuXG4gICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSAmJiAhdHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKGxpbmVzWzBdISk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgIGxpbmVzID0gW3RoaXMuYnVmZmVyLmpvaW4oJycpICsgbGluZXNbMF0sIC4uLmxpbmVzLnNsaWNlKDEpXTtcbiAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgfVxuXG4gICAgaWYgKCF0cmFpbGluZ05ld2xpbmUpIHtcbiAgICAgIHRoaXMuYnVmZmVyID0gW2xpbmVzLnBvcCgpIHx8ICcnXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGluZXM7XG4gIH1cblxuICBkZWNvZGVUZXh0KGJ5dGVzOiBCeXRlcyk6IHN0cmluZyB7XG4gICAgaWYgKGJ5dGVzID09IG51bGwpIHJldHVybiAnJztcbiAgICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykgcmV0dXJuIGJ5dGVzO1xuXG4gICAgLy8gTm9kZTpcbiAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChieXRlcyBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gYnl0ZXMudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzKS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoXG4gICAgICAgIGBVbmV4cGVjdGVkOiByZWNlaXZlZCBub24tVWludDhBcnJheSAoJHtieXRlcy5jb25zdHJ1Y3Rvci5uYW1lfSkgc3RyZWFtIGNodW5rIGluIGFuIGVudmlyb25tZW50IHdpdGggYSBnbG9iYWwgXCJCdWZmZXJcIiBkZWZpbmVkLCB3aGljaCB0aGlzIGxpYnJhcnkgYXNzdW1lcyB0byBiZSBOb2RlLiBQbGVhc2UgcmVwb3J0IHRoaXMgZXJyb3IuYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQnJvd3NlclxuICAgIGlmICh0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IGJ5dGVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdGhpcy50ZXh0RGVjb2RlciA/Pz0gbmV3IFRleHREZWNvZGVyKCd1dGY4Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHREZWNvZGVyLmRlY29kZShieXRlcyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihcbiAgICAgICAgYFVuZXhwZWN0ZWQ6IHJlY2VpdmVkIG5vbi1VaW50OEFycmF5L0FycmF5QnVmZmVyICgke1xuICAgICAgICAgIChieXRlcyBhcyBhbnkpLmNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgfSkgaW4gYSB3ZWIgcGxhdGZvcm0uIFBsZWFzZSByZXBvcnQgdGhpcyBlcnJvci5gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoXG4gICAgICBgVW5leHBlY3RlZDogbmVpdGhlciBCdWZmZXIgbm9yIFRleHREZWNvZGVyIGFyZSBhdmFpbGFibGUgYXMgZ2xvYmFscy4gUGxlYXNlIHJlcG9ydCB0aGlzIGVycm9yLmAsXG4gICAgKTtcbiAgfVxuXG4gIGZsdXNoKCk6IHN0cmluZ1tdIHtcbiAgICBpZiAoIXRoaXMuYnVmZmVyLmxlbmd0aCAmJiAhdGhpcy50cmFpbGluZ0NSKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgbGluZXMgPSBbdGhpcy5idWZmZXIuam9pbignJyldO1xuICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgdGhpcy50cmFpbGluZ0NSID0gZmFsc2U7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgUmVhZGFibGVTdHJlYW0sIHR5cGUgUmVzcG9uc2UgfSBmcm9tICcuL19zaGltcy9pbmRleCc7XG5pbXBvcnQgeyBPcGVuQUlFcnJvciB9IGZyb20gJy4vZXJyb3InO1xuaW1wb3J0IHsgTGluZURlY29kZXIgfSBmcm9tICcuL2ludGVybmFsL2RlY29kZXJzL2xpbmUnO1xuXG5pbXBvcnQgeyBBUElFcnJvciB9IGZyb20gJy4vZXJyb3InO1xuXG50eXBlIEJ5dGVzID0gc3RyaW5nIHwgQXJyYXlCdWZmZXIgfCBVaW50OEFycmF5IHwgQnVmZmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuZXhwb3J0IHR5cGUgU2VydmVyU2VudEV2ZW50ID0ge1xuICBldmVudDogc3RyaW5nIHwgbnVsbDtcbiAgZGF0YTogc3RyaW5nO1xuICByYXc6IHN0cmluZ1tdO1xufTtcblxuZXhwb3J0IGNsYXNzIFN0cmVhbTxJdGVtPiBpbXBsZW1lbnRzIEFzeW5jSXRlcmFibGU8SXRlbT4ge1xuICBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpdGVyYXRvcjogKCkgPT4gQXN5bmNJdGVyYXRvcjxJdGVtPixcbiAgICBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIsXG4gICkge1xuICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gIH1cblxuICBzdGF0aWMgZnJvbVNTRVJlc3BvbnNlPEl0ZW0+KHJlc3BvbnNlOiBSZXNwb25zZSwgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyKTogU3RyZWFtPEl0ZW0+IHtcbiAgICBsZXQgY29uc3VtZWQgPSBmYWxzZTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uKiBpdGVyYXRvcigpOiBBc3luY0l0ZXJhdG9yPEl0ZW0sIGFueSwgdW5kZWZpbmVkPiB7XG4gICAgICBpZiAoY29uc3VtZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaXRlcmF0ZSBvdmVyIGEgY29uc3VtZWQgc3RyZWFtLCB1c2UgYC50ZWUoKWAgdG8gc3BsaXQgdGhlIHN0cmVhbS4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN1bWVkID0gdHJ1ZTtcbiAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHNzZSBvZiBfaXRlclNTRU1lc3NhZ2VzKHJlc3BvbnNlLCBjb250cm9sbGVyKSkge1xuICAgICAgICAgIGlmIChkb25lKSBjb250aW51ZTtcblxuICAgICAgICAgIGlmIChzc2UuZGF0YS5zdGFydHNXaXRoKCdbRE9ORV0nKSkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3NlLmV2ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgZGF0YTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2Uoc3NlLmRhdGEpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgcGFyc2UgbWVzc2FnZSBpbnRvIEpTT046YCwgc3NlLmRhdGEpO1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGcm9tIGNodW5rOmAsIHNzZS5yYXcpO1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmVycm9yKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBBUElFcnJvcih1bmRlZmluZWQsIGRhdGEuZXJyb3IsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeWllbGQgZGF0YTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShzc2UuZGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBwYXJzZSBtZXNzYWdlIGludG8gSlNPTjpgLCBzc2UuZGF0YSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZyb20gY2h1bms6YCwgc3NlLnJhdyk7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIHdoZXJlIHRoZSBlcnJvciBzaG91bGQgYmUgdGhyb3duP1xuICAgICAgICAgICAgaWYgKHNzZS5ldmVudCA9PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBBUElFcnJvcih1bmRlZmluZWQsIGRhdGEuZXJyb3IsIGRhdGEubWVzc2FnZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHsgZXZlbnQ6IHNzZS5ldmVudCwgZGF0YTogZGF0YSB9IGFzIGFueTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGNhbGxzIGBzdHJlYW0uY29udHJvbGxlci5hYm9ydCgpYCwgd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCB0aHJvd2luZy5cbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm5hbWUgPT09ICdBYm9ydEVycm9yJykgcmV0dXJuO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgYGJyZWFrYHMsIGFib3J0IHRoZSBvbmdvaW5nIHJlcXVlc3QuXG4gICAgICAgIGlmICghZG9uZSkgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3RyZWFtKGl0ZXJhdG9yLCBjb250cm9sbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBTdHJlYW0gZnJvbSBhIG5ld2xpbmUtc2VwYXJhdGVkIFJlYWRhYmxlU3RyZWFtXG4gICAqIHdoZXJlIGVhY2ggaXRlbSBpcyBhIEpTT04gdmFsdWUuXG4gICAqL1xuICBzdGF0aWMgZnJvbVJlYWRhYmxlU3RyZWFtPEl0ZW0+KHJlYWRhYmxlU3RyZWFtOiBSZWFkYWJsZVN0cmVhbSwgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyKTogU3RyZWFtPEl0ZW0+IHtcbiAgICBsZXQgY29uc3VtZWQgPSBmYWxzZTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uKiBpdGVyTGluZXMoKTogQXN5bmNHZW5lcmF0b3I8c3RyaW5nLCB2b2lkLCB1bmtub3duPiB7XG4gICAgICBjb25zdCBsaW5lRGVjb2RlciA9IG5ldyBMaW5lRGVjb2RlcigpO1xuXG4gICAgICBjb25zdCBpdGVyID0gcmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhYmxlPEJ5dGVzPihyZWFkYWJsZVN0cmVhbSk7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGl0ZXIpIHtcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVEZWNvZGVyLmRlY29kZShjaHVuaykpIHtcbiAgICAgICAgICB5aWVsZCBsaW5lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5mbHVzaCgpKSB7XG4gICAgICAgIHlpZWxkIGxpbmU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24qIGl0ZXJhdG9yKCk6IEFzeW5jSXRlcmF0b3I8SXRlbSwgYW55LCB1bmRlZmluZWQ+IHtcbiAgICAgIGlmIChjb25zdW1lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpdGVyYXRlIG92ZXIgYSBjb25zdW1lZCBzdHJlYW0sIHVzZSBgLnRlZSgpYCB0byBzcGxpdCB0aGUgc3RyZWFtLicpO1xuICAgICAgfVxuICAgICAgY29uc3VtZWQgPSB0cnVlO1xuICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgbGluZSBvZiBpdGVyTGluZXMoKSkge1xuICAgICAgICAgIGlmIChkb25lKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAobGluZSkgeWllbGQgSlNPTi5wYXJzZShsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgY2FsbHMgYHN0cmVhbS5jb250cm9sbGVyLmFib3J0KClgLCB3ZSBzaG91bGQgZXhpdCB3aXRob3V0IHRocm93aW5nLlxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSByZXR1cm47XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBgYnJlYWtgcywgYWJvcnQgdGhlIG9uZ29pbmcgcmVxdWVzdC5cbiAgICAgICAgaWYgKCFkb25lKSBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTdHJlYW0oaXRlcmF0b3IsIGNvbnRyb2xsZXIpO1xuICB9XG5cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpOiBBc3luY0l0ZXJhdG9yPEl0ZW0+IHtcbiAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyB0aGUgc3RyZWFtIGludG8gdHdvIHN0cmVhbXMgd2hpY2ggY2FuIGJlXG4gICAqIGluZGVwZW5kZW50bHkgcmVhZCBmcm9tIGF0IGRpZmZlcmVudCBzcGVlZHMuXG4gICAqL1xuICB0ZWUoKTogW1N0cmVhbTxJdGVtPiwgU3RyZWFtPEl0ZW0+XSB7XG4gICAgY29uc3QgbGVmdDogQXJyYXk8UHJvbWlzZTxJdGVyYXRvclJlc3VsdDxJdGVtPj4+ID0gW107XG4gICAgY29uc3QgcmlnaHQ6IEFycmF5PFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8SXRlbT4+PiA9IFtdO1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcigpO1xuXG4gICAgY29uc3QgdGVlSXRlcmF0b3IgPSAocXVldWU6IEFycmF5PFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8SXRlbT4+Pik6IEFzeW5jSXRlcmF0b3I8SXRlbT4gPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGxlZnQucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgcmlnaHQucHVzaChyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcXVldWUuc2hpZnQoKSE7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH07XG5cbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFN0cmVhbSgoKSA9PiB0ZWVJdGVyYXRvcihsZWZ0KSwgdGhpcy5jb250cm9sbGVyKSxcbiAgICAgIG5ldyBTdHJlYW0oKCkgPT4gdGVlSXRlcmF0b3IocmlnaHQpLCB0aGlzLmNvbnRyb2xsZXIpLFxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBzdHJlYW0gdG8gYSBuZXdsaW5lLXNlcGFyYXRlZCBSZWFkYWJsZVN0cmVhbSBvZlxuICAgKiBKU09OIHN0cmluZ2lmaWVkIHZhbHVlcyBpbiB0aGUgc3RyZWFtXG4gICAqIHdoaWNoIGNhbiBiZSB0dXJuZWQgYmFjayBpbnRvIGEgU3RyZWFtIHdpdGggYFN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW0oKWAuXG4gICAqL1xuICB0b1JlYWRhYmxlU3RyZWFtKCk6IFJlYWRhYmxlU3RyZWFtIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgaXRlcjogQXN5bmNJdGVyYXRvcjxJdGVtPjtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5cbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICBpdGVyID0gc2VsZltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBwdWxsKGN0cmw6IGFueSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGl0ZXIubmV4dCgpO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm4gY3RybC5jbG9zZSgpO1xuXG4gICAgICAgICAgY29uc3QgYnl0ZXMgPSBlbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnXFxuJyk7XG5cbiAgICAgICAgICBjdHJsLmVucXVldWUoYnl0ZXMpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjdHJsLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhc3luYyBjYW5jZWwoKSB7XG4gICAgICAgIGF3YWl0IGl0ZXIucmV0dXJuPy4oKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiBfaXRlclNTRU1lc3NhZ2VzKFxuICByZXNwb25zZTogUmVzcG9uc2UsXG4gIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcixcbik6IEFzeW5jR2VuZXJhdG9yPFNlcnZlclNlbnRFdmVudCwgdm9pZCwgdW5rbm93bj4ge1xuICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBBdHRlbXB0ZWQgdG8gaXRlcmF0ZSBvdmVyIGEgcmVzcG9uc2Ugd2l0aCBubyBib2R5YCk7XG4gIH1cblxuICBjb25zdCBzc2VEZWNvZGVyID0gbmV3IFNTRURlY29kZXIoKTtcbiAgY29uc3QgbGluZURlY29kZXIgPSBuZXcgTGluZURlY29kZXIoKTtcblxuICBjb25zdCBpdGVyID0gcmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhYmxlPEJ5dGVzPihyZXNwb25zZS5ib2R5KTtcbiAgZm9yIGF3YWl0IChjb25zdCBzc2VDaHVuayBvZiBpdGVyU1NFQ2h1bmtzKGl0ZXIpKSB7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVEZWNvZGVyLmRlY29kZShzc2VDaHVuaykpIHtcbiAgICAgIGNvbnN0IHNzZSA9IHNzZURlY29kZXIuZGVjb2RlKGxpbmUpO1xuICAgICAgaWYgKHNzZSkgeWllbGQgc3NlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5mbHVzaCgpKSB7XG4gICAgY29uc3Qgc3NlID0gc3NlRGVjb2Rlci5kZWNvZGUobGluZSk7XG4gICAgaWYgKHNzZSkgeWllbGQgc3NlO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gYXN5bmMgaXRlcmFibGUgaXRlcmF0b3IsIGl0ZXJhdGVzIG92ZXIgaXQgYW5kIHlpZWxkcyBmdWxsXG4gKiBTU0UgY2h1bmtzLCBpLmUuIHlpZWxkcyB3aGVuIGEgZG91YmxlIG5ldy1saW5lIGlzIGVuY291bnRlcmVkLlxuICovXG5hc3luYyBmdW5jdGlvbiogaXRlclNTRUNodW5rcyhpdGVyYXRvcjogQXN5bmNJdGVyYWJsZUl0ZXJhdG9yPEJ5dGVzPik6IEFzeW5jR2VuZXJhdG9yPFVpbnQ4QXJyYXk+IHtcbiAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheSgpO1xuXG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaXRlcmF0b3IpIHtcbiAgICBpZiAoY2h1bmsgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgYmluYXJ5Q2h1bmsgPVxuICAgICAgY2h1bmsgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBVaW50OEFycmF5KGNodW5rKVxuICAgICAgOiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnID8gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGNodW5rKVxuICAgICAgOiBjaHVuaztcblxuICAgIGxldCBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBiaW5hcnlDaHVuay5sZW5ndGgpO1xuICAgIG5ld0RhdGEuc2V0KGRhdGEpO1xuICAgIG5ld0RhdGEuc2V0KGJpbmFyeUNodW5rLCBkYXRhLmxlbmd0aCk7XG4gICAgZGF0YSA9IG5ld0RhdGE7XG5cbiAgICBsZXQgcGF0dGVybkluZGV4O1xuICAgIHdoaWxlICgocGF0dGVybkluZGV4ID0gZmluZERvdWJsZU5ld2xpbmVJbmRleChkYXRhKSkgIT09IC0xKSB7XG4gICAgICB5aWVsZCBkYXRhLnNsaWNlKDAsIHBhdHRlcm5JbmRleCk7XG4gICAgICBkYXRhID0gZGF0YS5zbGljZShwYXR0ZXJuSW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcbiAgICB5aWVsZCBkYXRhO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmREb3VibGVOZXdsaW5lSW5kZXgoYnVmZmVyOiBVaW50OEFycmF5KTogbnVtYmVyIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBzZWFyY2hlcyB0aGUgYnVmZmVyIGZvciB0aGUgZW5kIHBhdHRlcm5zIChcXHJcXHIsIFxcblxcbiwgXFxyXFxuXFxyXFxuKVxuICAvLyBhbmQgcmV0dXJucyB0aGUgaW5kZXggcmlnaHQgYWZ0ZXIgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW55IHBhdHRlcm4sXG4gIC8vIG9yIC0xIGlmIG5vbmUgb2YgdGhlIHBhdHRlcm5zIGFyZSBmb3VuZC5cbiAgY29uc3QgbmV3bGluZSA9IDB4MGE7IC8vIFxcblxuICBjb25zdCBjYXJyaWFnZSA9IDB4MGQ7IC8vIFxcclxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aCAtIDI7IGkrKykge1xuICAgIGlmIChidWZmZXJbaV0gPT09IG5ld2xpbmUgJiYgYnVmZmVyW2kgKyAxXSA9PT0gbmV3bGluZSkge1xuICAgICAgLy8gXFxuXFxuXG4gICAgICByZXR1cm4gaSArIDI7XG4gICAgfVxuICAgIGlmIChidWZmZXJbaV0gPT09IGNhcnJpYWdlICYmIGJ1ZmZlcltpICsgMV0gPT09IGNhcnJpYWdlKSB7XG4gICAgICAvLyBcXHJcXHJcbiAgICAgIHJldHVybiBpICsgMjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgYnVmZmVyW2ldID09PSBjYXJyaWFnZSAmJlxuICAgICAgYnVmZmVyW2kgKyAxXSA9PT0gbmV3bGluZSAmJlxuICAgICAgaSArIDMgPCBidWZmZXIubGVuZ3RoICYmXG4gICAgICBidWZmZXJbaSArIDJdID09PSBjYXJyaWFnZSAmJlxuICAgICAgYnVmZmVyW2kgKyAzXSA9PT0gbmV3bGluZVxuICAgICkge1xuICAgICAgLy8gXFxyXFxuXFxyXFxuXG4gICAgICByZXR1cm4gaSArIDQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5jbGFzcyBTU0VEZWNvZGVyIHtcbiAgcHJpdmF0ZSBkYXRhOiBzdHJpbmdbXTtcbiAgcHJpdmF0ZSBldmVudDogc3RyaW5nIHwgbnVsbDtcbiAgcHJpdmF0ZSBjaHVua3M6IHN0cmluZ1tdO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZXZlbnQgPSBudWxsO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMuY2h1bmtzID0gW107XG4gIH1cblxuICBkZWNvZGUobGluZTogc3RyaW5nKSB7XG4gICAgaWYgKGxpbmUuZW5kc1dpdGgoJ1xccicpKSB7XG4gICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcoMCwgbGluZS5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICBpZiAoIWxpbmUpIHtcbiAgICAgIC8vIGVtcHR5IGxpbmUgYW5kIHdlIGRpZG4ndCBwcmV2aW91c2x5IGVuY291bnRlciBhbnkgbWVzc2FnZXNcbiAgICAgIGlmICghdGhpcy5ldmVudCAmJiAhdGhpcy5kYXRhLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIGNvbnN0IHNzZTogU2VydmVyU2VudEV2ZW50ID0ge1xuICAgICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhLmpvaW4oJ1xcbicpLFxuICAgICAgICByYXc6IHRoaXMuY2h1bmtzLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5ldmVudCA9IG51bGw7XG4gICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgIHRoaXMuY2h1bmtzID0gW107XG5cbiAgICAgIHJldHVybiBzc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jaHVua3MucHVzaChsaW5lKTtcblxuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJzonKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IFtmaWVsZG5hbWUsIF8sIHZhbHVlXSA9IHBhcnRpdGlvbihsaW5lLCAnOicpO1xuXG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJyAnKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuXG4gICAgaWYgKGZpZWxkbmFtZSA9PT0gJ2V2ZW50Jykge1xuICAgICAgdGhpcy5ldmVudCA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoZmllbGRuYW1lID09PSAnZGF0YScpIHtcbiAgICAgIHRoaXMuZGF0YS5wdXNoKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKiogVGhpcyBpcyBhbiBpbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdGhhdCdzIGp1c3QgdXNlZCBmb3IgdGVzdGluZyAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZWNvZGVDaHVua3MoY2h1bmtzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBMaW5lRGVjb2RlcigpO1xuICBjb25zdCBsaW5lczogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBsaW5lcy5wdXNoKC4uLmRlY29kZXIuZGVjb2RlKGNodW5rKSk7XG4gIH1cblxuICByZXR1cm4gbGluZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnRpdGlvbihzdHI6IHN0cmluZywgZGVsaW1pdGVyOiBzdHJpbmcpOiBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZ10ge1xuICBjb25zdCBpbmRleCA9IHN0ci5pbmRleE9mKGRlbGltaXRlcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICByZXR1cm4gW3N0ci5zdWJzdHJpbmcoMCwgaW5kZXgpLCBkZWxpbWl0ZXIsIHN0ci5zdWJzdHJpbmcoaW5kZXggKyBkZWxpbWl0ZXIubGVuZ3RoKV07XG4gIH1cblxuICByZXR1cm4gW3N0ciwgJycsICcnXTtcbn1cblxuLyoqXG4gKiBNb3N0IGJyb3dzZXJzIGRvbid0IHlldCBoYXZlIGFzeW5jIGl0ZXJhYmxlIHN1cHBvcnQgZm9yIFJlYWRhYmxlU3RyZWFtLFxuICogYW5kIE5vZGUgaGFzIGEgdmVyeSBkaWZmZXJlbnQgd2F5IG9mIHJlYWRpbmcgYnl0ZXMgZnJvbSBpdHMgXCJSZWFkYWJsZVN0cmVhbVwiLlxuICpcbiAqIFRoaXMgcG9seWZpbGwgd2FzIHB1bGxlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9NYXR0aWFzQnVlbGVucy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9wdWxsLzEyMiNpc3N1ZWNvbW1lbnQtMTYyNzM1NDQ5MFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhYmxlPFQ+KHN0cmVhbTogYW55KTogQXN5bmNJdGVyYWJsZUl0ZXJhdG9yPFQ+IHtcbiAgaWYgKHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHJldHVybiBzdHJlYW07XG5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICByZXR1cm4ge1xuICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAocmVzdWx0Py5kb25lKSByZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgY2xvc2VkXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgd2hlbiBzdHJlYW0gYmVjb21lcyBlcnJvcmVkXG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyByZXR1cm4oKSB7XG4gICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICBhd2FpdCBjYW5jZWxQcm9taXNlO1xuICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgIH0sXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIH07XG59XG4iLCAiaW1wb3J0IHsgdHlwZSBSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4vY29yZSc7XG5pbXBvcnQge1xuICBGb3JtRGF0YSxcbiAgRmlsZSxcbiAgdHlwZSBCbG9iLFxuICB0eXBlIEZpbGVQcm9wZXJ0eUJhZyxcbiAgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMsXG4gIHR5cGUgRnNSZWFkU3RyZWFtLFxuICBpc0ZzUmVhZFN0cmVhbSxcbn0gZnJvbSAnLi9fc2hpbXMvaW5kZXgnO1xuaW1wb3J0IHsgTXVsdGlwYXJ0Qm9keSB9IGZyb20gJy4vX3NoaW1zL011bHRpcGFydEJvZHknO1xuZXhwb3J0IHsgZmlsZUZyb21QYXRoIH0gZnJvbSAnLi9fc2hpbXMvaW5kZXgnO1xuXG50eXBlIEJsb2JMaWtlUGFydCA9IHN0cmluZyB8IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3IHwgQmxvYkxpa2UgfCBVaW50OEFycmF5IHwgRGF0YVZpZXc7XG5leHBvcnQgdHlwZSBCbG9iUGFydCA9IHN0cmluZyB8IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3IHwgQmxvYiB8IFVpbnQ4QXJyYXkgfCBEYXRhVmlldztcblxuLyoqXG4gKiBUeXBpY2FsbHksIHRoaXMgaXMgYSBuYXRpdmUgXCJGaWxlXCIgY2xhc3MuXG4gKlxuICogV2UgcHJvdmlkZSB0aGUge0BsaW5rIHRvRmlsZX0gdXRpbGl0eSB0byBjb252ZXJ0IGEgdmFyaWV0eSBvZiBvYmplY3RzXG4gKiBpbnRvIHRoZSBGaWxlIGNsYXNzLlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgeW91IGNhbiBhbHNvIHBhc3MgYSBmZXRjaCBSZXNwb25zZSwgb3IgaW4gTm9kZSxcbiAqIHRoZSByZXN1bHQgb2YgZnMuY3JlYXRlUmVhZFN0cmVhbSgpLlxuICovXG5leHBvcnQgdHlwZSBVcGxvYWRhYmxlID0gRmlsZUxpa2UgfCBSZXNwb25zZUxpa2UgfCBGc1JlYWRTdHJlYW07XG5cbi8qKlxuICogSW50ZW5kZWQgdG8gbWF0Y2ggd2ViLkJsb2IsIG5vZGUuQmxvYiwgbm9kZS1mZXRjaC5CbG9iLCBldGMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmxvYkxpa2Uge1xuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9CbG9iL3NpemUpICovXG4gIHJlYWRvbmx5IHNpemU6IG51bWJlcjtcbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQmxvYi90eXBlKSAqL1xuICByZWFkb25seSB0eXBlOiBzdHJpbmc7XG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0Jsb2IvdGV4dCkgKi9cbiAgdGV4dCgpOiBQcm9taXNlPHN0cmluZz47XG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0Jsb2Ivc2xpY2UpICovXG4gIHNsaWNlKHN0YXJ0PzogbnVtYmVyLCBlbmQ/OiBudW1iZXIpOiBCbG9iTGlrZTtcbiAgLy8gdW5mb3J0dW5hdGVseSBAdHlwZXMvbm9kZS1mZXRjaEBeMi42LjQgZG9lc24ndCB0eXBlIHRoZSBhcnJheUJ1ZmZlciBtZXRob2Rcbn1cblxuLyoqXG4gKiBJbnRlbmRlZCB0byBtYXRjaCB3ZWIuRmlsZSwgbm9kZS5GaWxlLCBub2RlLWZldGNoLkZpbGUsIGV0Yy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaWxlTGlrZSBleHRlbmRzIEJsb2JMaWtlIHtcbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRmlsZS9sYXN0TW9kaWZpZWQpICovXG4gIHJlYWRvbmx5IGxhc3RNb2RpZmllZDogbnVtYmVyO1xuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9GaWxlL25hbWUpICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBJbnRlbmRlZCB0byBtYXRjaCB3ZWIuUmVzcG9uc2UsIG5vZGUuUmVzcG9uc2UsIG5vZGUtZmV0Y2guUmVzcG9uc2UsIGV0Yy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUxpa2Uge1xuICB1cmw6IHN0cmluZztcbiAgYmxvYigpOiBQcm9taXNlPEJsb2JMaWtlPjtcbn1cblxuZXhwb3J0IGNvbnN0IGlzUmVzcG9uc2VMaWtlID0gKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBSZXNwb25zZUxpa2UgPT5cbiAgdmFsdWUgIT0gbnVsbCAmJlxuICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gIHR5cGVvZiB2YWx1ZS51cmwgPT09ICdzdHJpbmcnICYmXG4gIHR5cGVvZiB2YWx1ZS5ibG9iID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgaXNGaWxlTGlrZSA9ICh2YWx1ZTogYW55KTogdmFsdWUgaXMgRmlsZUxpa2UgPT5cbiAgdmFsdWUgIT0gbnVsbCAmJlxuICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gIHR5cGVvZiB2YWx1ZS5uYW1lID09PSAnc3RyaW5nJyAmJlxuICB0eXBlb2YgdmFsdWUubGFzdE1vZGlmaWVkID09PSAnbnVtYmVyJyAmJlxuICBpc0Jsb2JMaWtlKHZhbHVlKTtcblxuLyoqXG4gKiBUaGUgQmxvYkxpa2UgdHlwZSBvbWl0cyBhcnJheUJ1ZmZlcigpIGJlY2F1c2UgQHR5cGVzL25vZGUtZmV0Y2hAXjIuNi40IGxhY2tzIGl0OyBidXQgdGhpcyBjaGVja1xuICogYWRkcyB0aGUgYXJyYXlCdWZmZXIoKSBtZXRob2QgdHlwZSBiZWNhdXNlIGl0IGlzIGF2YWlsYWJsZSBhbmQgdXNlZCBhdCBydW50aW1lXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Jsb2JMaWtlID0gKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBCbG9iTGlrZSAmIHsgYXJyYXlCdWZmZXIoKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj4gfSA9PlxuICB2YWx1ZSAhPSBudWxsICYmXG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgdHlwZW9mIHZhbHVlLnNpemUgPT09ICdudW1iZXInICYmXG4gIHR5cGVvZiB2YWx1ZS50eXBlID09PSAnc3RyaW5nJyAmJlxuICB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgdmFsdWUuc2xpY2UgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIHZhbHVlLmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgaXNVcGxvYWRhYmxlID0gKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBVcGxvYWRhYmxlID0+IHtcbiAgcmV0dXJuIGlzRmlsZUxpa2UodmFsdWUpIHx8IGlzUmVzcG9uc2VMaWtlKHZhbHVlKSB8fCBpc0ZzUmVhZFN0cmVhbSh2YWx1ZSk7XG59O1xuXG5leHBvcnQgdHlwZSBUb0ZpbGVJbnB1dCA9IFVwbG9hZGFibGUgfCBFeGNsdWRlPEJsb2JMaWtlUGFydCwgc3RyaW5nPiB8IEFzeW5jSXRlcmFibGU8QmxvYkxpa2VQYXJ0PjtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIGNyZWF0aW5nIGEge0BsaW5rIEZpbGV9IHRvIHBhc3MgdG8gYW4gU0RLIHVwbG9hZCBtZXRob2QgZnJvbSBhIHZhcmlldHkgb2YgZGlmZmVyZW50IGRhdGEgZm9ybWF0c1xuICogQHBhcmFtIHZhbHVlIHRoZSByYXcgY29udGVudCBvZiB0aGUgZmlsZS4gIENhbiBiZSBhbiB7QGxpbmsgVXBsb2FkYWJsZX0sIHtAbGluayBCbG9iTGlrZVBhcnR9LCBvciB7QGxpbmsgQXN5bmNJdGVyYWJsZX0gb2Yge0BsaW5rIEJsb2JMaWtlUGFydH1zXG4gKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGUuIElmIG9taXR0ZWQsIHRvRmlsZSB3aWxsIHRyeSB0byBkZXRlcm1pbmUgYSBmaWxlIG5hbWUgZnJvbSBiaXRzIGlmIHBvc3NpYmxlXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMudHlwZSB0aGUgTUlNRSB0eXBlIG9mIHRoZSBjb250ZW50XG4gKiBAcGFyYW0ge251bWJlcj19IG9wdGlvbnMubGFzdE1vZGlmaWVkIHRoZSBsYXN0IG1vZGlmaWVkIHRpbWVzdGFtcFxuICogQHJldHVybnMgYSB7QGxpbmsgRmlsZX0gd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydGllc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdG9GaWxlKFxuICB2YWx1ZTogVG9GaWxlSW5wdXQgfCBQcm9taXNlTGlrZTxUb0ZpbGVJbnB1dD4sXG4gIG5hbWU/OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLFxuICBvcHRpb25zPzogRmlsZVByb3BlcnR5QmFnIHwgdW5kZWZpbmVkLFxuKTogUHJvbWlzZTxGaWxlTGlrZT4ge1xuICAvLyBJZiBpdCdzIGEgcHJvbWlzZSwgcmVzb2x2ZSBpdC5cbiAgdmFsdWUgPSBhd2FpdCB2YWx1ZTtcblxuICAvLyBJZiB3ZSd2ZSBiZWVuIGdpdmVuIGEgYEZpbGVgIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcbiAgaWYgKGlzRmlsZUxpa2UodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKGlzUmVzcG9uc2VMaWtlKHZhbHVlKSkge1xuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCB2YWx1ZS5ibG9iKCk7XG4gICAgbmFtZSB8fD0gbmV3IFVSTCh2YWx1ZS51cmwpLnBhdGhuYW1lLnNwbGl0KC9bXFxcXC9dLykucG9wKCkgPz8gJ3Vua25vd25fZmlsZSc7XG5cbiAgICAvLyB3ZSBuZWVkIHRvIGNvbnZlcnQgdGhlIGBCbG9iYCBpbnRvIGFuIGFycmF5IGJ1ZmZlciBiZWNhdXNlIHRoZSBgQmxvYmAgY2xhc3NcbiAgICAvLyB0aGF0IGBub2RlLWZldGNoYCBkZWZpbmVzIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSB3ZWIgc3RhbmRhcmQgd2hpY2ggcmVzdWx0c1xuICAgIC8vIGluIGBuZXcgRmlsZWAgaW50ZXJwcmV0aW5nIGl0IGFzIGEgc3RyaW5nIGluc3RlYWQgb2YgYmluYXJ5IGRhdGEuXG4gICAgY29uc3QgZGF0YSA9IGlzQmxvYkxpa2UoYmxvYikgPyBbKGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKSkgYXMgYW55XSA6IFtibG9iXTtcblxuICAgIHJldHVybiBuZXcgRmlsZShkYXRhLCBuYW1lLCBvcHRpb25zKTtcbiAgfVxuXG4gIGNvbnN0IGJpdHMgPSBhd2FpdCBnZXRCeXRlcyh2YWx1ZSk7XG5cbiAgbmFtZSB8fD0gZ2V0TmFtZSh2YWx1ZSkgPz8gJ3Vua25vd25fZmlsZSc7XG5cbiAgaWYgKCFvcHRpb25zPy50eXBlKSB7XG4gICAgY29uc3QgdHlwZSA9IChiaXRzWzBdIGFzIGFueSk/LnR5cGU7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgdHlwZSB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgRmlsZShiaXRzLCBuYW1lLCBvcHRpb25zKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0Qnl0ZXModmFsdWU6IFRvRmlsZUlucHV0KTogUHJvbWlzZTxBcnJheTxCbG9iUGFydD4+IHtcbiAgbGV0IHBhcnRzOiBBcnJheTxCbG9iUGFydD4gPSBbXTtcbiAgaWYgKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpIHx8IC8vIGluY2x1ZGVzIFVpbnQ4QXJyYXksIEJ1ZmZlciwgZXRjLlxuICAgIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJcbiAgKSB7XG4gICAgcGFydHMucHVzaCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNCbG9iTGlrZSh2YWx1ZSkpIHtcbiAgICBwYXJ0cy5wdXNoKGF3YWl0IHZhbHVlLmFycmF5QnVmZmVyKCkpO1xuICB9IGVsc2UgaWYgKFxuICAgIGlzQXN5bmNJdGVyYWJsZUl0ZXJhdG9yKHZhbHVlKSAvLyBpbmNsdWRlcyBSZWFkYWJsZSwgUmVhZGFibGVTdHJlYW0sIGV0Yy5cbiAgKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiB2YWx1ZSkge1xuICAgICAgcGFydHMucHVzaChjaHVuayBhcyBCbG9iUGFydCk7IC8vIFRPRE8sIGNvbnNpZGVyIHZhbGlkYXRpbmc/XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBVbmV4cGVjdGVkIGRhdGEgdHlwZTogJHt0eXBlb2YgdmFsdWV9OyBjb25zdHJ1Y3RvcjogJHt2YWx1ZT8uY29uc3RydWN0b3JcbiAgICAgICAgPy5uYW1lfTsgcHJvcHM6ICR7cHJvcHNGb3JFcnJvcih2YWx1ZSl9YCxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5mdW5jdGlvbiBwcm9wc0ZvckVycm9yKHZhbHVlOiBhbnkpOiBzdHJpbmcge1xuICBjb25zdCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgcmV0dXJuIGBbJHtwcm9wcy5tYXAoKHApID0+IGBcIiR7cH1cImApLmpvaW4oJywgJyl9XWA7XG59XG5cbmZ1bmN0aW9uIGdldE5hbWUodmFsdWU6IGFueSk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiAoXG4gICAgZ2V0U3RyaW5nRnJvbU1heWJlQnVmZmVyKHZhbHVlLm5hbWUpIHx8XG4gICAgZ2V0U3RyaW5nRnJvbU1heWJlQnVmZmVyKHZhbHVlLmZpbGVuYW1lKSB8fFxuICAgIC8vIEZvciBmcy5SZWFkU3RyZWFtXG4gICAgZ2V0U3RyaW5nRnJvbU1heWJlQnVmZmVyKHZhbHVlLnBhdGgpPy5zcGxpdCgvW1xcXFwvXS8pLnBvcCgpXG4gICk7XG59XG5cbmNvbnN0IGdldFN0cmluZ0Zyb21NYXliZUJ1ZmZlciA9ICh4OiBzdHJpbmcgfCBCdWZmZXIgfCB1bmtub3duKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykgcmV0dXJuIHg7XG4gIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgQnVmZmVyKSByZXR1cm4gU3RyaW5nKHgpO1xuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgaXNBc3luY0l0ZXJhYmxlSXRlcmF0b3IgPSAodmFsdWU6IGFueSk6IHZhbHVlIGlzIEFzeW5jSXRlcmFibGVJdGVyYXRvcjx1bmtub3duPiA9PlxuICB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcblxuZXhwb3J0IGNvbnN0IGlzTXVsdGlwYXJ0Qm9keSA9IChib2R5OiBhbnkpOiBib2R5IGlzIE11bHRpcGFydEJvZHkgPT5cbiAgYm9keSAmJiB0eXBlb2YgYm9keSA9PT0gJ29iamVjdCcgJiYgYm9keS5ib2R5ICYmIGJvZHlbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ011bHRpcGFydEJvZHknO1xuXG4vKipcbiAqIFJldHVybnMgYSBtdWx0aXBhcnQvZm9ybS1kYXRhIHJlcXVlc3QgaWYgYW55IHBhcnQgb2YgdGhlIGdpdmVuIHJlcXVlc3QgYm9keSBjb250YWlucyBhIEZpbGUgLyBCbG9iIHZhbHVlLlxuICogT3RoZXJ3aXNlIHJldHVybnMgdGhlIHJlcXVlc3QgYXMgaXMuXG4gKi9cbmV4cG9ydCBjb25zdCBtYXliZU11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyA9IGFzeW5jIDxUID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KFxuICBvcHRzOiBSZXF1ZXN0T3B0aW9uczxUPixcbik6IFByb21pc2U8UmVxdWVzdE9wdGlvbnM8VCB8IE11bHRpcGFydEJvZHk+PiA9PiB7XG4gIGlmICghaGFzVXBsb2FkYWJsZVZhbHVlKG9wdHMuYm9keSkpIHJldHVybiBvcHRzO1xuXG4gIGNvbnN0IGZvcm0gPSBhd2FpdCBjcmVhdGVGb3JtKG9wdHMuYm9keSk7XG4gIHJldHVybiBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucyhmb3JtLCBvcHRzKTtcbn07XG5cbmV4cG9ydCBjb25zdCBtdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMgPSBhc3luYyA8VCA9IFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgb3B0czogUmVxdWVzdE9wdGlvbnM8VD4sXG4pOiBQcm9taXNlPFJlcXVlc3RPcHRpb25zPFQgfCBNdWx0aXBhcnRCb2R5Pj4gPT4ge1xuICBjb25zdCBmb3JtID0gYXdhaXQgY3JlYXRlRm9ybShvcHRzLmJvZHkpO1xuICByZXR1cm4gZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMoZm9ybSwgb3B0cyk7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlRm9ybSA9IGFzeW5jIDxUID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KGJvZHk6IFQgfCB1bmRlZmluZWQpOiBQcm9taXNlPEZvcm1EYXRhPiA9PiB7XG4gIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmVudHJpZXMoYm9keSB8fCB7fSkubWFwKChba2V5LCB2YWx1ZV0pID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBrZXksIHZhbHVlKSkpO1xuICByZXR1cm4gZm9ybTtcbn07XG5cbmNvbnN0IGhhc1VwbG9hZGFibGVWYWx1ZSA9ICh2YWx1ZTogdW5rbm93bik6IGJvb2xlYW4gPT4ge1xuICBpZiAoaXNVcGxvYWRhYmxlKHZhbHVlKSkgcmV0dXJuIHRydWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlLnNvbWUoaGFzVXBsb2FkYWJsZVZhbHVlKTtcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICAgIGlmIChoYXNVcGxvYWRhYmxlVmFsdWUoKHZhbHVlIGFzIGFueSlba10pKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgYWRkRm9ybVZhbHVlID0gYXN5bmMgKGZvcm06IEZvcm1EYXRhLCBrZXk6IHN0cmluZywgdmFsdWU6IHVua25vd24pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYFJlY2VpdmVkIG51bGwgZm9yIFwiJHtrZXl9XCI7IHRvIHBhc3MgbnVsbCBpbiBGb3JtRGF0YSwgeW91IG11c3QgdXNlIHRoZSBzdHJpbmcgJ251bGwnYCxcbiAgICApO1xuICB9XG5cbiAgLy8gVE9ETzogbWFrZSBuZXN0ZWQgZm9ybWF0cyBjb25maWd1cmFibGVcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgIGZvcm0uYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoaXNVcGxvYWRhYmxlKHZhbHVlKSkge1xuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0b0ZpbGUodmFsdWUpO1xuICAgIGZvcm0uYXBwZW5kKGtleSwgZmlsZSBhcyBGaWxlKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHZhbHVlLm1hcCgoZW50cnkpID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBrZXkgKyAnW10nLCBlbnRyeSkpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKChbbmFtZSwgcHJvcF0pID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBgJHtrZXl9WyR7bmFtZX1dYCwgcHJvcCkpLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIGdpdmVuIHRvIGZvcm0sIGV4cGVjdGVkIGEgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9iamVjdCwgQXJyYXksIEZpbGUgb3IgQmxvYiBidXQgZ290ICR7dmFsdWV9IGluc3RlYWRgLFxuICAgICk7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gJy4vdmVyc2lvbic7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tICcuL3N0cmVhbWluZyc7XG5pbXBvcnQge1xuICBPcGVuQUlFcnJvcixcbiAgQVBJRXJyb3IsXG4gIEFQSUNvbm5lY3Rpb25FcnJvcixcbiAgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcixcbiAgQVBJVXNlckFib3J0RXJyb3IsXG59IGZyb20gJy4vZXJyb3InO1xuaW1wb3J0IHtcbiAga2luZCBhcyBzaGltc0tpbmQsXG4gIHR5cGUgUmVhZGFibGUsXG4gIGdldERlZmF1bHRBZ2VudCxcbiAgdHlwZSBBZ2VudCxcbiAgZmV0Y2gsXG4gIHR5cGUgUmVxdWVzdEluZm8sXG4gIHR5cGUgUmVxdWVzdEluaXQsXG4gIHR5cGUgUmVzcG9uc2UsXG4gIHR5cGUgSGVhZGVyc0luaXQsXG59IGZyb20gJy4vX3NoaW1zL2luZGV4JztcbmV4cG9ydCB7IHR5cGUgUmVzcG9uc2UgfTtcbmltcG9ydCB7IEJsb2JMaWtlLCBpc0Jsb2JMaWtlLCBpc011bHRpcGFydEJvZHkgfSBmcm9tICcuL3VwbG9hZHMnO1xuZXhwb3J0IHtcbiAgbWF5YmVNdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMsXG4gIG11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyxcbiAgY3JlYXRlRm9ybSxcbiAgdHlwZSBVcGxvYWRhYmxlLFxufSBmcm9tICcuL3VwbG9hZHMnO1xuXG5leHBvcnQgdHlwZSBGZXRjaCA9ICh1cmw6IFJlcXVlc3RJbmZvLCBpbml0PzogUmVxdWVzdEluaXQpID0+IFByb21pc2U8UmVzcG9uc2U+O1xuXG50eXBlIFByb21pc2VPclZhbHVlPFQ+ID0gVCB8IFByb21pc2U8VD47XG5cbnR5cGUgQVBJUmVzcG9uc2VQcm9wcyA9IHtcbiAgcmVzcG9uc2U6IFJlc3BvbnNlO1xuICBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zO1xuICBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXI7XG59O1xuXG5hc3luYyBmdW5jdGlvbiBkZWZhdWx0UGFyc2VSZXNwb25zZTxUPihwcm9wczogQVBJUmVzcG9uc2VQcm9wcyk6IFByb21pc2U8V2l0aFJlcXVlc3RJRDxUPj4ge1xuICBjb25zdCB7IHJlc3BvbnNlIH0gPSBwcm9wcztcbiAgaWYgKHByb3BzLm9wdGlvbnMuc3RyZWFtKSB7XG4gICAgZGVidWcoJ3Jlc3BvbnNlJywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS51cmwsIHJlc3BvbnNlLmhlYWRlcnMsIHJlc3BvbnNlLmJvZHkpO1xuXG4gICAgLy8gTm90ZTogdGhlcmUgaXMgYW4gaW52YXJpYW50IGhlcmUgdGhhdCBpc24ndCByZXByZXNlbnRlZCBpbiB0aGUgdHlwZSBzeXN0ZW1cbiAgICAvLyB0aGF0IGlmIHlvdSBzZXQgYHN0cmVhbTogdHJ1ZWAgdGhlIHJlc3BvbnNlIHR5cGUgbXVzdCBhbHNvIGJlIGBTdHJlYW08VD5gXG5cbiAgICBpZiAocHJvcHMub3B0aW9ucy5fX3N0cmVhbUNsYXNzKSB7XG4gICAgICByZXR1cm4gcHJvcHMub3B0aW9ucy5fX3N0cmVhbUNsYXNzLmZyb21TU0VSZXNwb25zZShyZXNwb25zZSwgcHJvcHMuY29udHJvbGxlcikgYXMgYW55O1xuICAgIH1cblxuICAgIHJldHVybiBTdHJlYW0uZnJvbVNTRVJlc3BvbnNlKHJlc3BvbnNlLCBwcm9wcy5jb250cm9sbGVyKSBhcyBhbnk7XG4gIH1cblxuICAvLyBmZXRjaCByZWZ1c2VzIHRvIHJlYWQgdGhlIGJvZHkgd2hlbiB0aGUgc3RhdHVzIGNvZGUgaXMgMjA0LlxuICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQpIHtcbiAgICByZXR1cm4gbnVsbCBhcyBXaXRoUmVxdWVzdElEPFQ+O1xuICB9XG5cbiAgaWYgKHByb3BzLm9wdGlvbnMuX19iaW5hcnlSZXNwb25zZSkge1xuICAgIHJldHVybiByZXNwb25zZSBhcyB1bmtub3duIGFzIFdpdGhSZXF1ZXN0SUQ8VD47XG4gIH1cblxuICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgY29uc3QgaXNKU09OID1cbiAgICBjb250ZW50VHlwZT8uaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSB8fCBjb250ZW50VHlwZT8uaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL3ZuZC5hcGkranNvbicpO1xuICBpZiAoaXNKU09OKSB7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgIGRlYnVnKCdyZXNwb25zZScsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UudXJsLCByZXNwb25zZS5oZWFkZXJzLCBqc29uKTtcblxuICAgIHJldHVybiBfYWRkUmVxdWVzdElEKGpzb24sIHJlc3BvbnNlKTtcbiAgfVxuXG4gIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIGRlYnVnKCdyZXNwb25zZScsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UudXJsLCByZXNwb25zZS5oZWFkZXJzLCB0ZXh0KTtcblxuICAvLyBUT0RPIGhhbmRsZSBibG9iLCBhcnJheWJ1ZmZlciwgb3RoZXIgY29udGVudCB0eXBlcywgZXRjLlxuICByZXR1cm4gdGV4dCBhcyB1bmtub3duIGFzIFdpdGhSZXF1ZXN0SUQ8VD47XG59XG5cbnR5cGUgV2l0aFJlcXVlc3RJRDxUPiA9XG4gIFQgZXh0ZW5kcyBBcnJheTxhbnk+IHwgUmVzcG9uc2UgfCBBYnN0cmFjdFBhZ2U8YW55PiA/IFRcbiAgOiBUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiA/IFQgJiB7IF9yZXF1ZXN0X2lkPzogc3RyaW5nIHwgbnVsbCB9XG4gIDogVDtcblxuZnVuY3Rpb24gX2FkZFJlcXVlc3RJRDxUPih2YWx1ZTogVCwgcmVzcG9uc2U6IFJlc3BvbnNlKTogV2l0aFJlcXVlc3RJRDxUPiB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZSBhcyBXaXRoUmVxdWVzdElEPFQ+O1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgJ19yZXF1ZXN0X2lkJywge1xuICAgIHZhbHVlOiByZXNwb25zZS5oZWFkZXJzLmdldCgneC1yZXF1ZXN0LWlkJyksXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gIH0pIGFzIFdpdGhSZXF1ZXN0SUQ8VD47XG59XG5cbi8qKlxuICogQSBzdWJjbGFzcyBvZiBgUHJvbWlzZWAgcHJvdmlkaW5nIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHNcbiAqIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBTREsuXG4gKi9cbmV4cG9ydCBjbGFzcyBBUElQcm9taXNlPFQ+IGV4dGVuZHMgUHJvbWlzZTxXaXRoUmVxdWVzdElEPFQ+PiB7XG4gIHByaXZhdGUgcGFyc2VkUHJvbWlzZTogUHJvbWlzZTxXaXRoUmVxdWVzdElEPFQ+PiB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlc3BvbnNlUHJvbWlzZTogUHJvbWlzZTxBUElSZXNwb25zZVByb3BzPixcbiAgICBwcml2YXRlIHBhcnNlUmVzcG9uc2U6IChcbiAgICAgIHByb3BzOiBBUElSZXNwb25zZVByb3BzLFxuICAgICkgPT4gUHJvbWlzZU9yVmFsdWU8V2l0aFJlcXVlc3RJRDxUPj4gPSBkZWZhdWx0UGFyc2VSZXNwb25zZSxcbiAgKSB7XG4gICAgc3VwZXIoKHJlc29sdmUpID0+IHtcbiAgICAgIC8vIHRoaXMgaXMgbWF5YmUgYSBiaXQgd2VpcmQgYnV0IHRoaXMgaGFzIHRvIGJlIGEgbm8tb3AgdG8gbm90IGltcGxpY2l0bHlcbiAgICAgIC8vIHBhcnNlIHRoZSByZXNwb25zZSBib2R5OyBpbnN0ZWFkIC50aGVuLCAuY2F0Y2gsIC5maW5hbGx5IGFyZSBvdmVycmlkZGVuXG4gICAgICAvLyB0byBwYXJzZSB0aGUgcmVzcG9uc2VcbiAgICAgIHJlc29sdmUobnVsbCBhcyBhbnkpO1xuICAgIH0pO1xuICB9XG5cbiAgX3RoZW5VbndyYXA8VT4odHJhbnNmb3JtOiAoZGF0YTogVCwgcHJvcHM6IEFQSVJlc3BvbnNlUHJvcHMpID0+IFUpOiBBUElQcm9taXNlPFU+IHtcbiAgICByZXR1cm4gbmV3IEFQSVByb21pc2UodGhpcy5yZXNwb25zZVByb21pc2UsIGFzeW5jIChwcm9wcykgPT5cbiAgICAgIF9hZGRSZXF1ZXN0SUQodHJhbnNmb3JtKGF3YWl0IHRoaXMucGFyc2VSZXNwb25zZShwcm9wcyksIHByb3BzKSwgcHJvcHMucmVzcG9uc2UpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcmF3IGBSZXNwb25zZWAgaW5zdGFuY2UgaW5zdGVhZCBvZiBwYXJzaW5nIHRoZSByZXNwb25zZVxuICAgKiBkYXRhLlxuICAgKlxuICAgKiBJZiB5b3Ugd2FudCB0byBwYXJzZSB0aGUgcmVzcG9uc2UgYm9keSBidXQgc3RpbGwgZ2V0IHRoZSBgUmVzcG9uc2VgXG4gICAqIGluc3RhbmNlLCB5b3UgY2FuIHVzZSB7QGxpbmsgd2l0aFJlc3BvbnNlKCl9LlxuICAgKlxuICAgKiBcdUQ4M0RcdURDNEIgR2V0dGluZyB0aGUgd3JvbmcgVHlwZVNjcmlwdCB0eXBlIGZvciBgUmVzcG9uc2VgP1xuICAgKiBUcnkgc2V0dGluZyBgXCJtb2R1bGVSZXNvbHV0aW9uXCI6IFwiTm9kZU5leHRcImAgaWYgeW91IGNhbixcbiAgICogb3IgYWRkIG9uZSBvZiB0aGVzZSBpbXBvcnRzIGJlZm9yZSB5b3VyIGZpcnN0IGBpbXBvcnQgXHUyMDI2IGZyb20gJ29wZW5haSdgOlxuICAgKiAtIGBpbXBvcnQgJ29wZW5haS9zaGltcy9ub2RlJ2AgKGlmIHlvdSdyZSBydW5uaW5nIG9uIE5vZGUpXG4gICAqIC0gYGltcG9ydCAnb3BlbmFpL3NoaW1zL3dlYidgIChvdGhlcndpc2UpXG4gICAqL1xuICBhc1Jlc3BvbnNlKCk6IFByb21pc2U8UmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZVByb21pc2UudGhlbigocCkgPT4gcC5yZXNwb25zZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcGFyc2VkIHJlc3BvbnNlIGRhdGEsIHRoZSByYXcgYFJlc3BvbnNlYCBpbnN0YW5jZSBhbmQgdGhlIElEIG9mIHRoZSByZXF1ZXN0LFxuICAgKiByZXR1cm5lZCB2aWEgdGhlIFgtUmVxdWVzdC1JRCBoZWFkZXIgd2hpY2ggaXMgdXNlZnVsIGZvciBkZWJ1Z2dpbmcgcmVxdWVzdHMgYW5kIHJlcG9ydGluZ1xuICAgKiBpc3N1ZXMgdG8gT3BlbkFJLlxuICAgKlxuICAgKiBJZiB5b3UganVzdCB3YW50IHRvIGdldCB0aGUgcmF3IGBSZXNwb25zZWAgaW5zdGFuY2Ugd2l0aG91dCBwYXJzaW5nIGl0LFxuICAgKiB5b3UgY2FuIHVzZSB7QGxpbmsgYXNSZXNwb25zZSgpfS5cbiAgICpcbiAgICpcbiAgICogXHVEODNEXHVEQzRCIEdldHRpbmcgdGhlIHdyb25nIFR5cGVTY3JpcHQgdHlwZSBmb3IgYFJlc3BvbnNlYD9cbiAgICogVHJ5IHNldHRpbmcgYFwibW9kdWxlUmVzb2x1dGlvblwiOiBcIk5vZGVOZXh0XCJgIGlmIHlvdSBjYW4sXG4gICAqIG9yIGFkZCBvbmUgb2YgdGhlc2UgaW1wb3J0cyBiZWZvcmUgeW91ciBmaXJzdCBgaW1wb3J0IFx1MjAyNiBmcm9tICdvcGVuYWknYDpcbiAgICogLSBgaW1wb3J0ICdvcGVuYWkvc2hpbXMvbm9kZSdgIChpZiB5b3UncmUgcnVubmluZyBvbiBOb2RlKVxuICAgKiAtIGBpbXBvcnQgJ29wZW5haS9zaGltcy93ZWInYCAob3RoZXJ3aXNlKVxuICAgKi9cbiAgYXN5bmMgd2l0aFJlc3BvbnNlKCk6IFByb21pc2U8eyBkYXRhOiBUOyByZXNwb25zZTogUmVzcG9uc2U7IHJlcXVlc3RfaWQ6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQgfT4ge1xuICAgIGNvbnN0IFtkYXRhLCByZXNwb25zZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5wYXJzZSgpLCB0aGlzLmFzUmVzcG9uc2UoKV0pO1xuICAgIHJldHVybiB7IGRhdGEsIHJlc3BvbnNlLCByZXF1ZXN0X2lkOiByZXNwb25zZS5oZWFkZXJzLmdldCgneC1yZXF1ZXN0LWlkJykgfTtcbiAgfVxuXG4gIHByaXZhdGUgcGFyc2UoKTogUHJvbWlzZTxXaXRoUmVxdWVzdElEPFQ+PiB7XG4gICAgaWYgKCF0aGlzLnBhcnNlZFByb21pc2UpIHtcbiAgICAgIHRoaXMucGFyc2VkUHJvbWlzZSA9IHRoaXMucmVzcG9uc2VQcm9taXNlLnRoZW4odGhpcy5wYXJzZVJlc3BvbnNlKSBhcyBhbnkgYXMgUHJvbWlzZTxXaXRoUmVxdWVzdElEPFQ+PjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VkUHJvbWlzZTtcbiAgfVxuXG4gIG92ZXJyaWRlIHRoZW48VFJlc3VsdDEgPSBXaXRoUmVxdWVzdElEPFQ+LCBUUmVzdWx0MiA9IG5ldmVyPihcbiAgICBvbmZ1bGZpbGxlZD86ICgodmFsdWU6IFdpdGhSZXF1ZXN0SUQ8VD4pID0+IFRSZXN1bHQxIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDE+KSB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICAgb25yZWplY3RlZD86ICgocmVhc29uOiBhbnkpID0+IFRSZXN1bHQyIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDI+KSB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICk6IFByb21pc2U8VFJlc3VsdDEgfCBUUmVzdWx0Mj4ge1xuICAgIHJldHVybiB0aGlzLnBhcnNlKCkudGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCk7XG4gIH1cblxuICBvdmVycmlkZSBjYXRjaDxUUmVzdWx0ID0gbmV2ZXI+KFxuICAgIG9ucmVqZWN0ZWQ/OiAoKHJlYXNvbjogYW55KSA9PiBUUmVzdWx0IHwgUHJvbWlzZUxpa2U8VFJlc3VsdD4pIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgKTogUHJvbWlzZTxXaXRoUmVxdWVzdElEPFQ+IHwgVFJlc3VsdD4ge1xuICAgIHJldHVybiB0aGlzLnBhcnNlKCkuY2F0Y2gob25yZWplY3RlZCk7XG4gIH1cblxuICBvdmVycmlkZSBmaW5hbGx5KG9uZmluYWxseT86ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZCB8IG51bGwpOiBQcm9taXNlPFdpdGhSZXF1ZXN0SUQ8VD4+IHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZSgpLmZpbmFsbHkob25maW5hbGx5KTtcbiAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQVBJQ2xpZW50IHtcbiAgYmFzZVVSTDogc3RyaW5nO1xuICBtYXhSZXRyaWVzOiBudW1iZXI7XG4gIHRpbWVvdXQ6IG51bWJlcjtcbiAgaHR0cEFnZW50OiBBZ2VudCB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGZldGNoOiBGZXRjaDtcbiAgcHJvdGVjdGVkIGlkZW1wb3RlbmN5SGVhZGVyPzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVVJMLFxuICAgIG1heFJldHJpZXMgPSAyLFxuICAgIHRpbWVvdXQgPSA2MDAwMDAsIC8vIDEwIG1pbnV0ZXNcbiAgICBodHRwQWdlbnQsXG4gICAgZmV0Y2g6IG92ZXJyaWRkZW5GZXRjaCxcbiAgfToge1xuICAgIGJhc2VVUkw6IHN0cmluZztcbiAgICBtYXhSZXRyaWVzPzogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIHRpbWVvdXQ6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICBodHRwQWdlbnQ6IEFnZW50IHwgdW5kZWZpbmVkO1xuICAgIGZldGNoOiBGZXRjaCB8IHVuZGVmaW5lZDtcbiAgfSkge1xuICAgIHRoaXMuYmFzZVVSTCA9IGJhc2VVUkw7XG4gICAgdGhpcy5tYXhSZXRyaWVzID0gdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoJ21heFJldHJpZXMnLCBtYXhSZXRyaWVzKTtcbiAgICB0aGlzLnRpbWVvdXQgPSB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcigndGltZW91dCcsIHRpbWVvdXQpO1xuICAgIHRoaXMuaHR0cEFnZW50ID0gaHR0cEFnZW50O1xuXG4gICAgdGhpcy5mZXRjaCA9IG92ZXJyaWRkZW5GZXRjaCA/PyBmZXRjaDtcbiAgfVxuXG4gIHByb3RlY3RlZCBhdXRoSGVhZGVycyhvcHRzOiBGaW5hbFJlcXVlc3RPcHRpb25zKTogSGVhZGVycyB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoaXMgdG8gYWRkIHlvdXIgb3duIGRlZmF1bHQgaGVhZGVycywgZm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB7XG4gICAqICAgIC4uLnN1cGVyLmRlZmF1bHRIZWFkZXJzKCksXG4gICAqICAgIEF1dGhvcml6YXRpb246ICdCZWFyZXIgMTIzJyxcbiAgICogIH1cbiAgICovXG4gIHByb3RlY3RlZCBkZWZhdWx0SGVhZGVycyhvcHRzOiBGaW5hbFJlcXVlc3RPcHRpb25zKTogSGVhZGVycyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdVc2VyLUFnZW50JzogdGhpcy5nZXRVc2VyQWdlbnQoKSxcbiAgICAgIC4uLmdldFBsYXRmb3JtSGVhZGVycygpLFxuICAgICAgLi4udGhpcy5hdXRoSGVhZGVycyhvcHRzKSxcbiAgICB9O1xuICB9XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGRlZmF1bHRRdWVyeSgpOiBEZWZhdWx0UXVlcnkgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoaXMgdG8gYWRkIHlvdXIgb3duIGhlYWRlcnMgdmFsaWRhdGlvbjpcbiAgICovXG4gIHByb3RlY3RlZCB2YWxpZGF0ZUhlYWRlcnMoaGVhZGVyczogSGVhZGVycywgY3VzdG9tSGVhZGVyczogSGVhZGVycykge31cblxuICBwcm90ZWN0ZWQgZGVmYXVsdElkZW1wb3RlbmN5S2V5KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBzdGFpbmxlc3Mtbm9kZS1yZXRyeS0ke3V1aWQ0KCl9YDtcbiAgfVxuXG4gIGdldDxSZXEsIFJzcD4ocGF0aDogc3RyaW5nLCBvcHRzPzogUHJvbWlzZU9yVmFsdWU8UmVxdWVzdE9wdGlvbnM8UmVxPj4pOiBBUElQcm9taXNlPFJzcD4ge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoJ2dldCcsIHBhdGgsIG9wdHMpO1xuICB9XG5cbiAgcG9zdDxSZXEsIFJzcD4ocGF0aDogc3RyaW5nLCBvcHRzPzogUHJvbWlzZU9yVmFsdWU8UmVxdWVzdE9wdGlvbnM8UmVxPj4pOiBBUElQcm9taXNlPFJzcD4ge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoJ3Bvc3QnLCBwYXRoLCBvcHRzKTtcbiAgfVxuXG4gIHBhdGNoPFJlcSwgUnNwPihwYXRoOiBzdHJpbmcsIG9wdHM/OiBQcm9taXNlT3JWYWx1ZTxSZXF1ZXN0T3B0aW9uczxSZXE+Pik6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kUmVxdWVzdCgncGF0Y2gnLCBwYXRoLCBvcHRzKTtcbiAgfVxuXG4gIHB1dDxSZXEsIFJzcD4ocGF0aDogc3RyaW5nLCBvcHRzPzogUHJvbWlzZU9yVmFsdWU8UmVxdWVzdE9wdGlvbnM8UmVxPj4pOiBBUElQcm9taXNlPFJzcD4ge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoJ3B1dCcsIHBhdGgsIG9wdHMpO1xuICB9XG5cbiAgZGVsZXRlPFJlcSwgUnNwPihwYXRoOiBzdHJpbmcsIG9wdHM/OiBQcm9taXNlT3JWYWx1ZTxSZXF1ZXN0T3B0aW9uczxSZXE+Pik6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kUmVxdWVzdCgnZGVsZXRlJywgcGF0aCwgb3B0cyk7XG4gIH1cblxuICBwcml2YXRlIG1ldGhvZFJlcXVlc3Q8UmVxLCBSc3A+KFxuICAgIG1ldGhvZDogSFRUUE1ldGhvZCxcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+LFxuICApOiBBUElQcm9taXNlPFJzcD4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXG4gICAgICBQcm9taXNlLnJlc29sdmUob3B0cykudGhlbihhc3luYyAob3B0cykgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID1cbiAgICAgICAgICBvcHRzICYmIGlzQmxvYkxpa2Uob3B0cz8uYm9keSkgPyBuZXcgRGF0YVZpZXcoYXdhaXQgb3B0cy5ib2R5LmFycmF5QnVmZmVyKCkpXG4gICAgICAgICAgOiBvcHRzPy5ib2R5IGluc3RhbmNlb2YgRGF0YVZpZXcgPyBvcHRzLmJvZHlcbiAgICAgICAgICA6IG9wdHM/LmJvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBEYXRhVmlldyhvcHRzLmJvZHkpXG4gICAgICAgICAgOiBvcHRzICYmIEFycmF5QnVmZmVyLmlzVmlldyhvcHRzPy5ib2R5KSA/IG5ldyBEYXRhVmlldyhvcHRzLmJvZHkuYnVmZmVyKVxuICAgICAgICAgIDogb3B0cz8uYm9keTtcbiAgICAgICAgcmV0dXJuIHsgbWV0aG9kLCBwYXRoLCAuLi5vcHRzLCBib2R5IH07XG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgZ2V0QVBJTGlzdDxJdGVtLCBQYWdlQ2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFBhZ2U8SXRlbT4gPSBBYnN0cmFjdFBhZ2U8SXRlbT4+KFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBQYWdlOiBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBQYWdlQ2xhc3MsXG4gICAgb3B0cz86IFJlcXVlc3RPcHRpb25zPGFueT4sXG4gICk6IFBhZ2VQcm9taXNlPFBhZ2VDbGFzcywgSXRlbT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RBUElMaXN0KFBhZ2UsIHsgbWV0aG9kOiAnZ2V0JywgcGF0aCwgLi4ub3B0cyB9KTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlQ29udGVudExlbmd0aChib2R5OiB1bmtub3duKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChib2R5LCAndXRmOCcpLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZXIuZW5jb2RlKGJvZHkpO1xuICAgICAgICByZXR1cm4gZW5jb2RlZC5sZW5ndGgudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhib2R5KSkge1xuICAgICAgcmV0dXJuIGJvZHkuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYnVpbGRSZXF1ZXN0PFJlcT4oXG4gICAgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9uczxSZXE+LFxuICAgIHsgcmV0cnlDb3VudCA9IDAgfTogeyByZXRyeUNvdW50PzogbnVtYmVyIH0gPSB7fSxcbiAgKTogeyByZXE6IFJlcXVlc3RJbml0OyB1cmw6IHN0cmluZzsgdGltZW91dDogbnVtYmVyIH0ge1xuICAgIGNvbnN0IHsgbWV0aG9kLCBwYXRoLCBxdWVyeSwgaGVhZGVyczogaGVhZGVycyA9IHt9IH0gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgYm9keSA9XG4gICAgICBBcnJheUJ1ZmZlci5pc1ZpZXcob3B0aW9ucy5ib2R5KSB8fCAob3B0aW9ucy5fX2JpbmFyeVJlcXVlc3QgJiYgdHlwZW9mIG9wdGlvbnMuYm9keSA9PT0gJ3N0cmluZycpID9cbiAgICAgICAgb3B0aW9ucy5ib2R5XG4gICAgICA6IGlzTXVsdGlwYXJ0Qm9keShvcHRpb25zLmJvZHkpID8gb3B0aW9ucy5ib2R5LmJvZHlcbiAgICAgIDogb3B0aW9ucy5ib2R5ID8gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ib2R5LCBudWxsLCAyKVxuICAgICAgOiBudWxsO1xuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSB0aGlzLmNhbGN1bGF0ZUNvbnRlbnRMZW5ndGgoYm9keSk7XG5cbiAgICBjb25zdCB1cmwgPSB0aGlzLmJ1aWxkVVJMKHBhdGghLCBxdWVyeSk7XG4gICAgaWYgKCd0aW1lb3V0JyBpbiBvcHRpb25zKSB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcigndGltZW91dCcsIG9wdGlvbnMudGltZW91dCk7XG4gICAgY29uc3QgdGltZW91dCA9IG9wdGlvbnMudGltZW91dCA/PyB0aGlzLnRpbWVvdXQ7XG4gICAgY29uc3QgaHR0cEFnZW50ID0gb3B0aW9ucy5odHRwQWdlbnQgPz8gdGhpcy5odHRwQWdlbnQgPz8gZ2V0RGVmYXVsdEFnZW50KHVybCk7XG4gICAgY29uc3QgbWluQWdlbnRUaW1lb3V0ID0gdGltZW91dCArIDEwMDA7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIChodHRwQWdlbnQgYXMgYW55KT8ub3B0aW9ucz8udGltZW91dCA9PT0gJ251bWJlcicgJiZcbiAgICAgIG1pbkFnZW50VGltZW91dCA+ICgoaHR0cEFnZW50IGFzIGFueSkub3B0aW9ucy50aW1lb3V0ID8/IDApXG4gICAgKSB7XG4gICAgICAvLyBBbGxvdyBhbnkgZ2l2ZW4gcmVxdWVzdCB0byBidW1wIG91ciBhZ2VudCBhY3RpdmUgc29ja2V0IHRpbWVvdXQuXG4gICAgICAvLyBUaGlzIG1heSBzZWVtIHN0cmFuZ2UsIGJ1dCBsZWFraW5nIGFjdGl2ZSBzb2NrZXRzIHNob3VsZCBiZSByYXJlIGFuZCBub3QgcGFydGljdWxhcmx5IHByb2JsZW1hdGljLFxuICAgICAgLy8gYW5kIHdpdGhvdXQgbXV0YXRpbmcgYWdlbnQgd2Ugd291bGQgbmVlZCB0byBjcmVhdGUgbW9yZSBvZiB0aGVtLlxuICAgICAgLy8gVGhpcyB0cmFkZW9mZiBvcHRpbWl6ZXMgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgKGh0dHBBZ2VudCBhcyBhbnkpLm9wdGlvbnMudGltZW91dCA9IG1pbkFnZW50VGltZW91dDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pZGVtcG90ZW5jeUhlYWRlciAmJiBtZXRob2QgIT09ICdnZXQnKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuaWRlbXBvdGVuY3lLZXkpIG9wdGlvbnMuaWRlbXBvdGVuY3lLZXkgPSB0aGlzLmRlZmF1bHRJZGVtcG90ZW5jeUtleSgpO1xuICAgICAgaGVhZGVyc1t0aGlzLmlkZW1wb3RlbmN5SGVhZGVyXSA9IG9wdGlvbnMuaWRlbXBvdGVuY3lLZXk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVxSGVhZGVycyA9IHRoaXMuYnVpbGRIZWFkZXJzKHsgb3B0aW9ucywgaGVhZGVycywgY29udGVudExlbmd0aCwgcmV0cnlDb3VudCB9KTtcblxuICAgIGNvbnN0IHJlcTogUmVxdWVzdEluaXQgPSB7XG4gICAgICBtZXRob2QsXG4gICAgICAuLi4oYm9keSAmJiB7IGJvZHk6IGJvZHkgYXMgYW55IH0pLFxuICAgICAgaGVhZGVyczogcmVxSGVhZGVycyxcbiAgICAgIC4uLihodHRwQWdlbnQgJiYgeyBhZ2VudDogaHR0cEFnZW50IH0pLFxuICAgICAgLy8gQHRzLWlnbm9yZSBub2RlLWZldGNoIHVzZXMgYSBjdXN0b20gQWJvcnRTaWduYWwgdHlwZSB0aGF0IGlzXG4gICAgICAvLyBub3QgY29tcGF0aWJsZSB3aXRoIHN0YW5kYXJkIHdlYiB0eXBlc1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCA/PyBudWxsLFxuICAgIH07XG5cbiAgICByZXR1cm4geyByZXEsIHVybCwgdGltZW91dCB9O1xuICB9XG5cbiAgcHJpdmF0ZSBidWlsZEhlYWRlcnMoe1xuICAgIG9wdGlvbnMsXG4gICAgaGVhZGVycyxcbiAgICBjb250ZW50TGVuZ3RoLFxuICAgIHJldHJ5Q291bnQsXG4gIH06IHtcbiAgICBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zO1xuICAgIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ+O1xuICAgIGNvbnRlbnRMZW5ndGg6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgcmV0cnlDb3VudDogbnVtYmVyO1xuICB9KTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgY29uc3QgcmVxSGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgIGlmIChjb250ZW50TGVuZ3RoKSB7XG4gICAgICByZXFIZWFkZXJzWydjb250ZW50LWxlbmd0aCddID0gY29udGVudExlbmd0aDtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZhdWx0SGVhZGVycyA9IHRoaXMuZGVmYXVsdEhlYWRlcnMob3B0aW9ucyk7XG4gICAgYXBwbHlIZWFkZXJzTXV0KHJlcUhlYWRlcnMsIGRlZmF1bHRIZWFkZXJzKTtcbiAgICBhcHBseUhlYWRlcnNNdXQocmVxSGVhZGVycywgaGVhZGVycyk7XG5cbiAgICAvLyBsZXQgYnVpbHRpbiBmZXRjaCBzZXQgdGhlIENvbnRlbnQtVHlwZSBmb3IgbXVsdGlwYXJ0IGJvZGllc1xuICAgIGlmIChpc011bHRpcGFydEJvZHkob3B0aW9ucy5ib2R5KSAmJiBzaGltc0tpbmQgIT09ICdub2RlJykge1xuICAgICAgZGVsZXRlIHJlcUhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICAgIH1cblxuICAgIC8vIERvbid0IHNldCB0aGUgcmV0cnkgY291bnQgaGVhZGVyIGlmIGl0IHdhcyBhbHJlYWR5IHNldCBvciByZW1vdmVkIHRocm91Z2ggZGVmYXVsdCBoZWFkZXJzIG9yIGJ5IHRoZVxuICAgIC8vIGNhbGxlci4gV2UgY2hlY2sgYGRlZmF1bHRIZWFkZXJzYCBhbmQgYGhlYWRlcnNgLCB3aGljaCBjYW4gY29udGFpbiBudWxscywgaW5zdGVhZCBvZiBgcmVxSGVhZGVyc2AgdG9cbiAgICAvLyBhY2NvdW50IGZvciB0aGUgcmVtb3ZhbCBjYXNlLlxuICAgIGlmIChcbiAgICAgIGdldEhlYWRlcihkZWZhdWx0SGVhZGVycywgJ3gtc3RhaW5sZXNzLXJldHJ5LWNvdW50JykgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgZ2V0SGVhZGVyKGhlYWRlcnMsICd4LXN0YWlubGVzcy1yZXRyeS1jb3VudCcpID09PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIHJlcUhlYWRlcnNbJ3gtc3RhaW5sZXNzLXJldHJ5LWNvdW50J10gPSBTdHJpbmcocmV0cnlDb3VudCk7XG4gICAgfVxuXG4gICAgdGhpcy52YWxpZGF0ZUhlYWRlcnMocmVxSGVhZGVycywgaGVhZGVycyk7XG5cbiAgICByZXR1cm4gcmVxSGVhZGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGFzIGEgY2FsbGJhY2sgZm9yIG11dGF0aW5nIHRoZSBnaXZlbiBgRmluYWxSZXF1ZXN0T3B0aW9uc2Agb2JqZWN0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIHByZXBhcmVPcHRpb25zKG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHt9XG5cbiAgLyoqXG4gICAqIFVzZWQgYXMgYSBjYWxsYmFjayBmb3IgbXV0YXRpbmcgdGhlIGdpdmVuIGBSZXF1ZXN0SW5pdGAgb2JqZWN0LlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgY2FzZXMgd2hlcmUgeW91IHdhbnQgdG8gYWRkIGNlcnRhaW4gaGVhZGVycyBiYXNlZCBvZmYgb2ZcbiAgICogdGhlIHJlcXVlc3QgcHJvcGVydGllcywgZS5nLiBgbWV0aG9kYCBvciBgdXJsYC5cbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBwcmVwYXJlUmVxdWVzdChcbiAgICByZXF1ZXN0OiBSZXF1ZXN0SW5pdCxcbiAgICB7IHVybCwgb3B0aW9ucyB9OiB7IHVybDogc3RyaW5nOyBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zIH0sXG4gICk6IFByb21pc2U8dm9pZD4ge31cblxuICBwcm90ZWN0ZWQgcGFyc2VIZWFkZXJzKGhlYWRlcnM6IEhlYWRlcnNJbml0IHwgbnVsbCB8IHVuZGVmaW5lZCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIHJldHVybiAoXG4gICAgICAhaGVhZGVycyA/IHt9XG4gICAgICA6IFN5bWJvbC5pdGVyYXRvciBpbiBoZWFkZXJzID9cbiAgICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKEFycmF5LmZyb20oaGVhZGVycyBhcyBJdGVyYWJsZTxzdHJpbmdbXT4pLm1hcCgoaGVhZGVyKSA9PiBbLi4uaGVhZGVyXSkpXG4gICAgICA6IHsgLi4uaGVhZGVycyB9XG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtYWtlU3RhdHVzRXJyb3IoXG4gICAgc3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gICAgZXJyb3I6IE9iamVjdCB8IHVuZGVmaW5lZCxcbiAgICBtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgaGVhZGVyczogSGVhZGVycyB8IHVuZGVmaW5lZCxcbiAgKTogQVBJRXJyb3Ige1xuICAgIHJldHVybiBBUElFcnJvci5nZW5lcmF0ZShzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgfVxuXG4gIHJlcXVlc3Q8UmVxLCBSc3A+KFxuICAgIG9wdGlvbnM6IFByb21pc2VPclZhbHVlPEZpbmFsUmVxdWVzdE9wdGlvbnM8UmVxPj4sXG4gICAgcmVtYWluaW5nUmV0cmllczogbnVtYmVyIHwgbnVsbCA9IG51bGwsXG4gICk6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIG5ldyBBUElQcm9taXNlKHRoaXMubWFrZVJlcXVlc3Qob3B0aW9ucywgcmVtYWluaW5nUmV0cmllcykpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBtYWtlUmVxdWVzdDxSZXE+KFxuICAgIG9wdGlvbnNJbnB1dDogUHJvbWlzZU9yVmFsdWU8RmluYWxSZXF1ZXN0T3B0aW9uczxSZXE+PixcbiAgICByZXRyaWVzUmVtYWluaW5nOiBudW1iZXIgfCBudWxsLFxuICApOiBQcm9taXNlPEFQSVJlc3BvbnNlUHJvcHM+IHtcbiAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgb3B0aW9uc0lucHV0O1xuICAgIGNvbnN0IG1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXMgPz8gdGhpcy5tYXhSZXRyaWVzO1xuICAgIGlmIChyZXRyaWVzUmVtYWluaW5nID09IG51bGwpIHtcbiAgICAgIHJldHJpZXNSZW1haW5pbmcgPSBtYXhSZXRyaWVzO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMucHJlcGFyZU9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBjb25zdCB7IHJlcSwgdXJsLCB0aW1lb3V0IH0gPSB0aGlzLmJ1aWxkUmVxdWVzdChvcHRpb25zLCB7IHJldHJ5Q291bnQ6IG1heFJldHJpZXMgLSByZXRyaWVzUmVtYWluaW5nIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5wcmVwYXJlUmVxdWVzdChyZXEsIHsgdXJsLCBvcHRpb25zIH0pO1xuXG4gICAgZGVidWcoJ3JlcXVlc3QnLCB1cmwsIG9wdGlvbnMsIHJlcS5oZWFkZXJzKTtcblxuICAgIGlmIChvcHRpb25zLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgfVxuXG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hXaXRoVGltZW91dCh1cmwsIHJlcSwgdGltZW91dCwgY29udHJvbGxlcikuY2F0Y2goY2FzdFRvRXJyb3IpO1xuXG4gICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGlmIChvcHRpb25zLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXRyaWVzUmVtYWluaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChvcHRpb25zLCByZXRyaWVzUmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNwb25zZS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBBUElDb25uZWN0aW9uRXJyb3IoeyBjYXVzZTogcmVzcG9uc2UgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gY3JlYXRlUmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlLmhlYWRlcnMpO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgaWYgKHJldHJpZXNSZW1haW5pbmcgJiYgdGhpcy5zaG91bGRSZXRyeShyZXNwb25zZSkpIHtcbiAgICAgICAgY29uc3QgcmV0cnlNZXNzYWdlID0gYHJldHJ5aW5nLCAke3JldHJpZXNSZW1haW5pbmd9IGF0dGVtcHRzIHJlbWFpbmluZ2A7XG4gICAgICAgIGRlYnVnKGByZXNwb25zZSAoZXJyb3I7ICR7cmV0cnlNZXNzYWdlfSlgLCByZXNwb25zZS5zdGF0dXMsIHVybCwgcmVzcG9uc2VIZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KG9wdGlvbnMsIHJldHJpZXNSZW1haW5pbmcsIHJlc3BvbnNlSGVhZGVycyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVyclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkuY2F0Y2goKGUpID0+IGNhc3RUb0Vycm9yKGUpLm1lc3NhZ2UpO1xuICAgICAgY29uc3QgZXJySlNPTiA9IHNhZmVKU09OKGVyclRleHQpO1xuICAgICAgY29uc3QgZXJyTWVzc2FnZSA9IGVyckpTT04gPyB1bmRlZmluZWQgOiBlcnJUZXh0O1xuICAgICAgY29uc3QgcmV0cnlNZXNzYWdlID0gcmV0cmllc1JlbWFpbmluZyA/IGAoZXJyb3I7IG5vIG1vcmUgcmV0cmllcyBsZWZ0KWAgOiBgKGVycm9yOyBub3QgcmV0cnlhYmxlKWA7XG5cbiAgICAgIGRlYnVnKGByZXNwb25zZSAoZXJyb3I7ICR7cmV0cnlNZXNzYWdlfSlgLCByZXNwb25zZS5zdGF0dXMsIHVybCwgcmVzcG9uc2VIZWFkZXJzLCBlcnJNZXNzYWdlKTtcblxuICAgICAgY29uc3QgZXJyID0gdGhpcy5tYWtlU3RhdHVzRXJyb3IocmVzcG9uc2Uuc3RhdHVzLCBlcnJKU09OLCBlcnJNZXNzYWdlLCByZXNwb25zZUhlYWRlcnMpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIHJldHVybiB7IHJlc3BvbnNlLCBvcHRpb25zLCBjb250cm9sbGVyIH07XG4gIH1cblxuICByZXF1ZXN0QVBJTGlzdDxJdGVtID0gdW5rbm93biwgUGFnZUNsYXNzIGV4dGVuZHMgQWJzdHJhY3RQYWdlPEl0ZW0+ID0gQWJzdHJhY3RQYWdlPEl0ZW0+PihcbiAgICBQYWdlOiBuZXcgKC4uLmFyZ3M6IENvbnN0cnVjdG9yUGFyYW1ldGVyczx0eXBlb2YgQWJzdHJhY3RQYWdlPikgPT4gUGFnZUNsYXNzLFxuICAgIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnMsXG4gICk6IFBhZ2VQcm9taXNlPFBhZ2VDbGFzcywgSXRlbT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLm1ha2VSZXF1ZXN0KG9wdGlvbnMsIG51bGwpO1xuICAgIHJldHVybiBuZXcgUGFnZVByb21pc2U8UGFnZUNsYXNzLCBJdGVtPih0aGlzLCByZXF1ZXN0LCBQYWdlKTtcbiAgfVxuXG4gIGJ1aWxkVVJMPFJlcT4ocGF0aDogc3RyaW5nLCBxdWVyeTogUmVxIHwgbnVsbCB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG4gICAgY29uc3QgdXJsID1cbiAgICAgIGlzQWJzb2x1dGVVUkwocGF0aCkgP1xuICAgICAgICBuZXcgVVJMKHBhdGgpXG4gICAgICA6IG5ldyBVUkwodGhpcy5iYXNlVVJMICsgKHRoaXMuYmFzZVVSTC5lbmRzV2l0aCgnLycpICYmIHBhdGguc3RhcnRzV2l0aCgnLycpID8gcGF0aC5zbGljZSgxKSA6IHBhdGgpKTtcblxuICAgIGNvbnN0IGRlZmF1bHRRdWVyeSA9IHRoaXMuZGVmYXVsdFF1ZXJ5KCk7XG4gICAgaWYgKCFpc0VtcHR5T2JqKGRlZmF1bHRRdWVyeSkpIHtcbiAgICAgIHF1ZXJ5ID0geyAuLi5kZWZhdWx0UXVlcnksIC4uLnF1ZXJ5IH0gYXMgUmVxO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnICYmIHF1ZXJ5ICYmICFBcnJheS5pc0FycmF5KHF1ZXJ5KSkge1xuICAgICAgdXJsLnNlYXJjaCA9IHRoaXMuc3RyaW5naWZ5UXVlcnkocXVlcnkgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pO1xuICAgIH1cblxuICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzdHJpbmdpZnlRdWVyeShxdWVyeTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBzdHJpbmcge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhxdWVyeSlcbiAgICAgIC5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfT1gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihcbiAgICAgICAgICBgQ2Fubm90IHN0cmluZ2lmeSB0eXBlICR7dHlwZW9mIHZhbHVlfTsgRXhwZWN0ZWQgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9yIG51bGwuIElmIHlvdSBuZWVkIHRvIHBhc3MgbmVzdGVkIHF1ZXJ5IHBhcmFtZXRlcnMsIHlvdSBjYW4gbWFudWFsbHkgZW5jb2RlIHRoZW0sIGUuZy4geyBxdWVyeTogeyAnZm9vW2tleTFdJzogdmFsdWUxLCAnZm9vW2tleTJdJzogdmFsdWUyIH0gfSwgYW5kIHBsZWFzZSBvcGVuIGEgR2l0SHViIGlzc3VlIHJlcXVlc3RpbmcgYmV0dGVyIHN1cHBvcnQgZm9yIHlvdXIgdXNlIGNhc2UuYCxcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgICAuam9pbignJicpO1xuICB9XG5cbiAgYXN5bmMgZmV0Y2hXaXRoVGltZW91dChcbiAgICB1cmw6IFJlcXVlc3RJbmZvLFxuICAgIGluaXQ6IFJlcXVlc3RJbml0IHwgdW5kZWZpbmVkLFxuICAgIG1zOiBudW1iZXIsXG4gICAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyLFxuICApOiBQcm9taXNlPFJlc3BvbnNlPiB7XG4gICAgY29uc3QgeyBzaWduYWwsIC4uLm9wdGlvbnMgfSA9IGluaXQgfHwge307XG4gICAgaWYgKHNpZ25hbCkgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gY29udHJvbGxlci5hYm9ydCgpKTtcblxuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgbXMpO1xuXG4gICAgY29uc3QgZmV0Y2hPcHRpb25zID0ge1xuICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCBhcyBhbnksXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gICAgaWYgKGZldGNoT3B0aW9ucy5tZXRob2QpIHtcbiAgICAgIC8vIEN1c3RvbSBtZXRob2RzIGxpa2UgJ3BhdGNoJyBuZWVkIHRvIGJlIHVwcGVyY2FzZWRcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjI5NFxuICAgICAgZmV0Y2hPcHRpb25zLm1ldGhvZCA9IGZldGNoT3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgLy8gdXNlIHVuZGVmaW5lZCB0aGlzIGJpbmRpbmc7IGZldGNoIGVycm9ycyBpZiBib3VuZCB0byBzb21ldGhpbmcgZWxzZSBpbiBicm93c2VyL2Nsb3VkZmxhcmVcbiAgICAgIHRoaXMuZmV0Y2guY2FsbCh1bmRlZmluZWQsIHVybCwgZmV0Y2hPcHRpb25zKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzaG91bGRSZXRyeShyZXNwb25zZTogUmVzcG9uc2UpOiBib29sZWFuIHtcbiAgICAvLyBOb3RlIHRoaXMgaXMgbm90IGEgc3RhbmRhcmQgaGVhZGVyLlxuICAgIGNvbnN0IHNob3VsZFJldHJ5SGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtc2hvdWxkLXJldHJ5Jyk7XG5cbiAgICAvLyBJZiB0aGUgc2VydmVyIGV4cGxpY2l0bHkgc2F5cyB3aGV0aGVyIG9yIG5vdCB0byByZXRyeSwgb2JleS5cbiAgICBpZiAoc2hvdWxkUmV0cnlIZWFkZXIgPT09ICd0cnVlJykgcmV0dXJuIHRydWU7XG4gICAgaWYgKHNob3VsZFJldHJ5SGVhZGVyID09PSAnZmFsc2UnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBSZXRyeSBvbiByZXF1ZXN0IHRpbWVvdXRzLlxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwOCkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBSZXRyeSBvbiBsb2NrIHRpbWVvdXRzLlxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwOSkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBSZXRyeSBvbiByYXRlIGxpbWl0cy5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHJldHVybiB0cnVlO1xuXG4gICAgLy8gUmV0cnkgaW50ZXJuYWwgZXJyb3JzLlxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNTAwKSByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmV0cnlSZXF1ZXN0KFxuICAgIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnMsXG4gICAgcmV0cmllc1JlbWFpbmluZzogbnVtYmVyLFxuICAgIHJlc3BvbnNlSGVhZGVycz86IEhlYWRlcnMgfCB1bmRlZmluZWQsXG4gICk6IFByb21pc2U8QVBJUmVzcG9uc2VQcm9wcz4ge1xuICAgIGxldCB0aW1lb3V0TWlsbGlzOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgICAvLyBOb3RlIHRoZSBgcmV0cnktYWZ0ZXItbXNgIGhlYWRlciBtYXkgbm90IGJlIHN0YW5kYXJkLCBidXQgaXMgYSBnb29kIGlkZWEgYW5kIHdlJ2QgbGlrZSBwcm9hY3RpdmUgc3VwcG9ydCBmb3IgaXQuXG4gICAgY29uc3QgcmV0cnlBZnRlck1pbGxpc0hlYWRlciA9IHJlc3BvbnNlSGVhZGVycz8uWydyZXRyeS1hZnRlci1tcyddO1xuICAgIGlmIChyZXRyeUFmdGVyTWlsbGlzSGVhZGVyKSB7XG4gICAgICBjb25zdCB0aW1lb3V0TXMgPSBwYXJzZUZsb2F0KHJldHJ5QWZ0ZXJNaWxsaXNIZWFkZXIpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odGltZW91dE1zKSkge1xuICAgICAgICB0aW1lb3V0TWlsbGlzID0gdGltZW91dE1zO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFib3V0IHRoZSBSZXRyeS1BZnRlciBoZWFkZXI6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9SZXRyeS1BZnRlclxuICAgIGNvbnN0IHJldHJ5QWZ0ZXJIZWFkZXIgPSByZXNwb25zZUhlYWRlcnM/LlsncmV0cnktYWZ0ZXInXTtcbiAgICBpZiAocmV0cnlBZnRlckhlYWRlciAmJiAhdGltZW91dE1pbGxpcykge1xuICAgICAgY29uc3QgdGltZW91dFNlY29uZHMgPSBwYXJzZUZsb2F0KHJldHJ5QWZ0ZXJIZWFkZXIpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odGltZW91dFNlY29uZHMpKSB7XG4gICAgICAgIHRpbWVvdXRNaWxsaXMgPSB0aW1lb3V0U2Vjb25kcyAqIDEwMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0TWlsbGlzID0gRGF0ZS5wYXJzZShyZXRyeUFmdGVySGVhZGVyKSAtIERhdGUubm93KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIEFQSSBhc2tzIHVzIHRvIHdhaXQgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lIChhbmQgaXQncyBhIHJlYXNvbmFibGUgYW1vdW50KSxcbiAgICAvLyBqdXN0IGRvIHdoYXQgaXQgc2F5cywgYnV0IG90aGVyd2lzZSBjYWxjdWxhdGUgYSBkZWZhdWx0XG4gICAgaWYgKCEodGltZW91dE1pbGxpcyAmJiAwIDw9IHRpbWVvdXRNaWxsaXMgJiYgdGltZW91dE1pbGxpcyA8IDYwICogMTAwMCkpIHtcbiAgICAgIGNvbnN0IG1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXMgPz8gdGhpcy5tYXhSZXRyaWVzO1xuICAgICAgdGltZW91dE1pbGxpcyA9IHRoaXMuY2FsY3VsYXRlRGVmYXVsdFJldHJ5VGltZW91dE1pbGxpcyhyZXRyaWVzUmVtYWluaW5nLCBtYXhSZXRyaWVzKTtcbiAgICB9XG4gICAgYXdhaXQgc2xlZXAodGltZW91dE1pbGxpcyk7XG5cbiAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdChvcHRpb25zLCByZXRyaWVzUmVtYWluaW5nIC0gMSk7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZURlZmF1bHRSZXRyeVRpbWVvdXRNaWxsaXMocmV0cmllc1JlbWFpbmluZzogbnVtYmVyLCBtYXhSZXRyaWVzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGluaXRpYWxSZXRyeURlbGF5ID0gMC41O1xuICAgIGNvbnN0IG1heFJldHJ5RGVsYXkgPSA4LjA7XG5cbiAgICBjb25zdCBudW1SZXRyaWVzID0gbWF4UmV0cmllcyAtIHJldHJpZXNSZW1haW5pbmc7XG5cbiAgICAvLyBBcHBseSBleHBvbmVudGlhbCBiYWNrb2ZmLCBidXQgbm90IG1vcmUgdGhhbiB0aGUgbWF4LlxuICAgIGNvbnN0IHNsZWVwU2Vjb25kcyA9IE1hdGgubWluKGluaXRpYWxSZXRyeURlbGF5ICogTWF0aC5wb3coMiwgbnVtUmV0cmllcyksIG1heFJldHJ5RGVsYXkpO1xuXG4gICAgLy8gQXBwbHkgc29tZSBqaXR0ZXIsIHRha2UgdXAgdG8gYXQgbW9zdCAyNSBwZXJjZW50IG9mIHRoZSByZXRyeSB0aW1lLlxuICAgIGNvbnN0IGppdHRlciA9IDEgLSBNYXRoLnJhbmRvbSgpICogMC4yNTtcblxuICAgIHJldHVybiBzbGVlcFNlY29uZHMgKiBqaXR0ZXIgKiAxMDAwO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRVc2VyQWdlbnQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfS9KUyAke1ZFUlNJT059YDtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBQYWdlSW5mbyA9IHsgdXJsOiBVUkwgfSB8IHsgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IG51bGwgfTtcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0UGFnZTxJdGVtPiBpbXBsZW1lbnRzIEFzeW5jSXRlcmFibGU8SXRlbT4ge1xuICAjY2xpZW50OiBBUElDbGllbnQ7XG4gIHByb3RlY3RlZCBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zO1xuXG4gIHByb3RlY3RlZCByZXNwb25zZTogUmVzcG9uc2U7XG4gIHByb3RlY3RlZCBib2R5OiB1bmtub3duO1xuXG4gIGNvbnN0cnVjdG9yKGNsaWVudDogQVBJQ2xpZW50LCByZXNwb25zZTogUmVzcG9uc2UsIGJvZHk6IHVua25vd24sIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnMpIHtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbmV4dFBhZ2VJbmZvIGluc3RlYWRcbiAgICovXG4gIGFic3RyYWN0IG5leHRQYWdlUGFyYW1zKCk6IFBhcnRpYWw8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+IHwgbnVsbDtcbiAgYWJzdHJhY3QgbmV4dFBhZ2VJbmZvKCk6IFBhZ2VJbmZvIHwgbnVsbDtcblxuICBhYnN0cmFjdCBnZXRQYWdpbmF0ZWRJdGVtcygpOiBJdGVtW107XG5cbiAgaGFzTmV4dFBhZ2UoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLmdldFBhZ2luYXRlZEl0ZW1zKCk7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5uZXh0UGFnZUluZm8oKSAhPSBudWxsO1xuICB9XG5cbiAgYXN5bmMgZ2V0TmV4dFBhZ2UoKTogUHJvbWlzZTx0aGlzPiB7XG4gICAgY29uc3QgbmV4dEluZm8gPSB0aGlzLm5leHRQYWdlSW5mbygpO1xuICAgIGlmICghbmV4dEluZm8pIHtcbiAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihcbiAgICAgICAgJ05vIG5leHQgcGFnZSBleHBlY3RlZDsgcGxlYXNlIGNoZWNrIGAuaGFzTmV4dFBhZ2UoKWAgYmVmb3JlIGNhbGxpbmcgYC5nZXROZXh0UGFnZSgpYC4nLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgbmV4dE9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucyB9O1xuICAgIGlmICgncGFyYW1zJyBpbiBuZXh0SW5mbyAmJiB0eXBlb2YgbmV4dE9wdGlvbnMucXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgICBuZXh0T3B0aW9ucy5xdWVyeSA9IHsgLi4ubmV4dE9wdGlvbnMucXVlcnksIC4uLm5leHRJbmZvLnBhcmFtcyB9O1xuICAgIH0gZWxzZSBpZiAoJ3VybCcgaW4gbmV4dEluZm8pIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsuLi5PYmplY3QuZW50cmllcyhuZXh0T3B0aW9ucy5xdWVyeSB8fCB7fSksIC4uLm5leHRJbmZvLnVybC5zZWFyY2hQYXJhbXMuZW50cmllcygpXTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHBhcmFtcykge1xuICAgICAgICBuZXh0SW5mby51cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIHZhbHVlIGFzIGFueSk7XG4gICAgICB9XG4gICAgICBuZXh0T3B0aW9ucy5xdWVyeSA9IHVuZGVmaW5lZDtcbiAgICAgIG5leHRPcHRpb25zLnBhdGggPSBuZXh0SW5mby51cmwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NsaWVudC5yZXF1ZXN0QVBJTGlzdCh0aGlzLmNvbnN0cnVjdG9yIGFzIGFueSwgbmV4dE9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgKml0ZXJQYWdlcygpOiBBc3luY0dlbmVyYXRvcjx0aGlzPiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgbGV0IHBhZ2U6IHRoaXMgPSB0aGlzO1xuICAgIHlpZWxkIHBhZ2U7XG4gICAgd2hpbGUgKHBhZ2UuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAgcGFnZSA9IGF3YWl0IHBhZ2UuZ2V0TmV4dFBhZ2UoKTtcbiAgICAgIHlpZWxkIHBhZ2U7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTogQXN5bmNHZW5lcmF0b3I8SXRlbT4ge1xuICAgIGZvciBhd2FpdCAoY29uc3QgcGFnZSBvZiB0aGlzLml0ZXJQYWdlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcGFnZS5nZXRQYWdpbmF0ZWRJdGVtcygpKSB7XG4gICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBzdWJjbGFzcyBvZiBQcm9taXNlIHdpbGwgcmVzb2x2ZSB0byBhbiBpbnN0YW50aWF0ZWQgUGFnZSBvbmNlIHRoZSByZXF1ZXN0IGNvbXBsZXRlcy5cbiAqXG4gKiBJdCBhbHNvIGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZSB0byBhbGxvdyBhdXRvLXBhZ2luYXRpbmcgaXRlcmF0aW9uIG9uIGFuIHVuYXdhaXRlZCBsaXN0IGNhbGwsIGVnOlxuICpcbiAqICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBjbGllbnQuaXRlbXMubGlzdCgpKSB7XG4gKiAgICAgIGNvbnNvbGUubG9nKGl0ZW0pXG4gKiAgICB9XG4gKi9cbmV4cG9ydCBjbGFzcyBQYWdlUHJvbWlzZTxcbiAgICBQYWdlQ2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFBhZ2U8SXRlbT4sXG4gICAgSXRlbSA9IFJldHVyblR5cGU8UGFnZUNsYXNzWydnZXRQYWdpbmF0ZWRJdGVtcyddPltudW1iZXJdLFxuICA+XG4gIGV4dGVuZHMgQVBJUHJvbWlzZTxQYWdlQ2xhc3M+XG4gIGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZTxJdGVtPlxue1xuICBjb25zdHJ1Y3RvcihcbiAgICBjbGllbnQ6IEFQSUNsaWVudCxcbiAgICByZXF1ZXN0OiBQcm9taXNlPEFQSVJlc3BvbnNlUHJvcHM+LFxuICAgIFBhZ2U6IG5ldyAoLi4uYXJnczogQ29uc3RydWN0b3JQYXJhbWV0ZXJzPHR5cGVvZiBBYnN0cmFjdFBhZ2U+KSA9PiBQYWdlQ2xhc3MsXG4gICkge1xuICAgIHN1cGVyKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGFzeW5jIChwcm9wcykgPT5cbiAgICAgICAgbmV3IFBhZ2UoXG4gICAgICAgICAgY2xpZW50LFxuICAgICAgICAgIHByb3BzLnJlc3BvbnNlLFxuICAgICAgICAgIGF3YWl0IGRlZmF1bHRQYXJzZVJlc3BvbnNlKHByb3BzKSxcbiAgICAgICAgICBwcm9wcy5vcHRpb25zLFxuICAgICAgICApIGFzIFdpdGhSZXF1ZXN0SUQ8UGFnZUNsYXNzPixcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IGF1dG8tcGFnaW5hdGluZyBpdGVyYXRpb24gb24gYW4gdW5hd2FpdGVkIGxpc3QgY2FsbCwgZWc6XG4gICAqXG4gICAqICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBjbGllbnQuaXRlbXMubGlzdCgpKSB7XG4gICAqICAgICAgY29uc29sZS5sb2coaXRlbSlcbiAgICogICAgfVxuICAgKi9cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTogQXN5bmNHZW5lcmF0b3I8SXRlbT4ge1xuICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCB0aGlzO1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBwYWdlKSB7XG4gICAgICB5aWVsZCBpdGVtO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlUmVzcG9uc2VIZWFkZXJzID0gKFxuICBoZWFkZXJzOiBBd2FpdGVkPFJldHVyblR5cGU8RmV0Y2g+PlsnaGVhZGVycyddLFxuKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9PiB7XG4gIHJldHVybiBuZXcgUHJveHkoXG4gICAgT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaGVhZGVycy5lbnRyaWVzKCksXG4gICAgKSxcbiAgICB7XG4gICAgICBnZXQodGFyZ2V0LCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG5hbWUudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFtrZXkudG9Mb3dlckNhc2UoKV0gfHwgdGFyZ2V0W2tleV07XG4gICAgICB9LFxuICAgIH0sXG4gICk7XG59O1xuXG50eXBlIEhUVFBNZXRob2QgPSAnZ2V0JyB8ICdwb3N0JyB8ICdwdXQnIHwgJ3BhdGNoJyB8ICdkZWxldGUnO1xuXG5leHBvcnQgdHlwZSBSZXF1ZXN0Q2xpZW50ID0geyBmZXRjaDogRmV0Y2ggfTtcbmV4cG9ydCB0eXBlIEhlYWRlcnMgPSBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPjtcbmV4cG9ydCB0eXBlIERlZmF1bHRRdWVyeSA9IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD47XG5leHBvcnQgdHlwZSBLZXlzRW51bTxUPiA9IHsgW1AgaW4ga2V5b2YgUmVxdWlyZWQ8VD5dOiB0cnVlIH07XG5cbmV4cG9ydCB0eXBlIFJlcXVlc3RPcHRpb25zPFxuICBSZXEgPSB1bmtub3duIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBSZWFkYWJsZSB8IEJsb2JMaWtlIHwgQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXIsXG4+ID0ge1xuICBtZXRob2Q/OiBIVFRQTWV0aG9kO1xuICBwYXRoPzogc3RyaW5nO1xuICBxdWVyeT86IFJlcSB8IHVuZGVmaW5lZDtcbiAgYm9keT86IFJlcSB8IG51bGwgfCB1bmRlZmluZWQ7XG4gIGhlYWRlcnM/OiBIZWFkZXJzIHwgdW5kZWZpbmVkO1xuXG4gIG1heFJldHJpZXM/OiBudW1iZXI7XG4gIHN0cmVhbT86IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gIHRpbWVvdXQ/OiBudW1iZXI7XG4gIGh0dHBBZ2VudD86IEFnZW50O1xuICBzaWduYWw/OiBBYm9ydFNpZ25hbCB8IHVuZGVmaW5lZCB8IG51bGw7XG4gIGlkZW1wb3RlbmN5S2V5Pzogc3RyaW5nO1xuXG4gIF9fYmluYXJ5UmVxdWVzdD86IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gIF9fYmluYXJ5UmVzcG9uc2U/OiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICBfX3N0cmVhbUNsYXNzPzogdHlwZW9mIFN0cmVhbTtcbn07XG5cbi8vIFRoaXMgaXMgcmVxdWlyZWQgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIGlmIGEgZ2l2ZW4gb2JqZWN0IG1hdGNoZXMgdGhlIFJlcXVlc3RPcHRpb25zXG4vLyB0eXBlIGF0IHJ1bnRpbWUuIFdoaWxlIHRoaXMgcmVxdWlyZXMgZHVwbGljYXRpb24sIGl0IGlzIGVuZm9yY2VkIGJ5IHRoZSBUeXBlU2NyaXB0XG4vLyBjb21waWxlciBzdWNoIHRoYXQgYW55IG1pc3NpbmcgLyBleHRyYW5lb3VzIGtleXMgd2lsbCBjYXVzZSBhbiBlcnJvci5cbmNvbnN0IHJlcXVlc3RPcHRpb25zS2V5czogS2V5c0VudW08UmVxdWVzdE9wdGlvbnM+ID0ge1xuICBtZXRob2Q6IHRydWUsXG4gIHBhdGg6IHRydWUsXG4gIHF1ZXJ5OiB0cnVlLFxuICBib2R5OiB0cnVlLFxuICBoZWFkZXJzOiB0cnVlLFxuXG4gIG1heFJldHJpZXM6IHRydWUsXG4gIHN0cmVhbTogdHJ1ZSxcbiAgdGltZW91dDogdHJ1ZSxcbiAgaHR0cEFnZW50OiB0cnVlLFxuICBzaWduYWw6IHRydWUsXG4gIGlkZW1wb3RlbmN5S2V5OiB0cnVlLFxuXG4gIF9fYmluYXJ5UmVxdWVzdDogdHJ1ZSxcbiAgX19iaW5hcnlSZXNwb25zZTogdHJ1ZSxcbiAgX19zdHJlYW1DbGFzczogdHJ1ZSxcbn07XG5cbmV4cG9ydCBjb25zdCBpc1JlcXVlc3RPcHRpb25zID0gKG9iajogdW5rbm93bik6IG9iaiBpcyBSZXF1ZXN0T3B0aW9ucyA9PiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiZcbiAgICBvYmogIT09IG51bGwgJiZcbiAgICAhaXNFbXB0eU9iaihvYmopICYmXG4gICAgT2JqZWN0LmtleXMob2JqKS5ldmVyeSgoaykgPT4gaGFzT3duKHJlcXVlc3RPcHRpb25zS2V5cywgaykpXG4gICk7XG59O1xuXG5leHBvcnQgdHlwZSBGaW5hbFJlcXVlc3RPcHRpb25zPFJlcSA9IHVua25vd24gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IFJlYWRhYmxlIHwgRGF0YVZpZXc+ID1cbiAgUmVxdWVzdE9wdGlvbnM8UmVxPiAmIHtcbiAgICBtZXRob2Q6IEhUVFBNZXRob2Q7XG4gICAgcGF0aDogc3RyaW5nO1xuICB9O1xuXG5kZWNsYXJlIGNvbnN0IERlbm86IGFueTtcbmRlY2xhcmUgY29uc3QgRWRnZVJ1bnRpbWU6IGFueTtcbnR5cGUgQXJjaCA9ICd4MzInIHwgJ3g2NCcgfCAnYXJtJyB8ICdhcm02NCcgfCBgb3RoZXI6JHtzdHJpbmd9YCB8ICd1bmtub3duJztcbnR5cGUgUGxhdGZvcm1OYW1lID1cbiAgfCAnTWFjT1MnXG4gIHwgJ0xpbnV4J1xuICB8ICdXaW5kb3dzJ1xuICB8ICdGcmVlQlNEJ1xuICB8ICdPcGVuQlNEJ1xuICB8ICdpT1MnXG4gIHwgJ0FuZHJvaWQnXG4gIHwgYE90aGVyOiR7c3RyaW5nfWBcbiAgfCAnVW5rbm93bic7XG50eXBlIEJyb3dzZXIgPSAnaWUnIHwgJ2VkZ2UnIHwgJ2Nocm9tZScgfCAnZmlyZWZveCcgfCAnc2FmYXJpJztcbnR5cGUgUGxhdGZvcm1Qcm9wZXJ0aWVzID0ge1xuICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcyc7XG4gICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBzdHJpbmc7XG4gICdYLVN0YWlubGVzcy1PUyc6IFBsYXRmb3JtTmFtZTtcbiAgJ1gtU3RhaW5sZXNzLUFyY2gnOiBBcmNoO1xuICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICdub2RlJyB8ICdkZW5vJyB8ICdlZGdlJyB8IGBicm93c2VyOiR7QnJvd3Nlcn1gIHwgJ3Vua25vd24nO1xuICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogc3RyaW5nO1xufTtcbmNvbnN0IGdldFBsYXRmb3JtUHJvcGVydGllcyA9ICgpOiBQbGF0Zm9ybVByb3BlcnRpZXMgPT4ge1xuICBpZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnICYmIERlbm8uYnVpbGQgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICdYLVN0YWlubGVzcy1PUyc6IG5vcm1hbGl6ZVBsYXRmb3JtKERlbm8uYnVpbGQub3MpLFxuICAgICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiBub3JtYWxpemVBcmNoKERlbm8uYnVpbGQuYXJjaCksXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICdkZW5vJyxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOlxuICAgICAgICB0eXBlb2YgRGVuby52ZXJzaW9uID09PSAnc3RyaW5nJyA/IERlbm8udmVyc2lvbiA6IERlbm8udmVyc2lvbj8uZGVubyA/PyAndW5rbm93bicsXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIEVkZ2VSdW50aW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB7XG4gICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICdYLVN0YWlubGVzcy1PUyc6ICdVbmtub3duJyxcbiAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogYG90aGVyOiR7RWRnZVJ1bnRpbWV9YCxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ2VkZ2UnLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IHByb2Nlc3MudmVyc2lvbixcbiAgICB9O1xuICB9XG4gIC8vIENoZWNrIGlmIE5vZGUuanNcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9jZXNzIDogMCkgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgIHJldHVybiB7XG4gICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICdYLVN0YWlubGVzcy1PUyc6IG5vcm1hbGl6ZVBsYXRmb3JtKHByb2Nlc3MucGxhdGZvcm0pLFxuICAgICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiBub3JtYWxpemVBcmNoKHByb2Nlc3MuYXJjaCksXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICdub2RlJyxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiBwcm9jZXNzLnZlcnNpb24sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGJyb3dzZXJJbmZvID0gZ2V0QnJvd3NlckluZm8oKTtcbiAgaWYgKGJyb3dzZXJJbmZvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJyxcbiAgICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICAgJ1gtU3RhaW5sZXNzLU9TJzogJ1Vua25vd24nLFxuICAgICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiAndW5rbm93bicsXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6IGBicm93c2VyOiR7YnJvd3NlckluZm8uYnJvd3Nlcn1gLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IGJyb3dzZXJJbmZvLnZlcnNpb24sXG4gICAgfTtcbiAgfVxuXG4gIC8vIFRPRE8gYWRkIHN1cHBvcnQgZm9yIENsb3VkZmxhcmUgd29ya2VycywgZXRjLlxuICByZXR1cm4ge1xuICAgICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJyxcbiAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAnWC1TdGFpbmxlc3MtT1MnOiAnVW5rbm93bicsXG4gICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiAndW5rbm93bicsXG4gICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAndW5rbm93bicsXG4gICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6ICd1bmtub3duJyxcbiAgfTtcbn07XG5cbnR5cGUgQnJvd3NlckluZm8gPSB7XG4gIGJyb3dzZXI6IEJyb3dzZXI7XG4gIHZlcnNpb246IHN0cmluZztcbn07XG5cbmRlY2xhcmUgY29uc3QgbmF2aWdhdG9yOiB7IHVzZXJBZ2VudDogc3RyaW5nIH0gfCB1bmRlZmluZWQ7XG5cbi8vIE5vdGU6IG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0pTLURldlRvb2xzL2hvc3QtZW52aXJvbm1lbnQvYmxvYi9iMWFiNzllY2RlMzdkYjVkNmUxNjNjMDUwZTU0ZmU3ZDI4N2Q3YzkyL3NyYy9pc29tb3JwaGljLmJyb3dzZXIudHNcbmZ1bmN0aW9uIGdldEJyb3dzZXJJbmZvKCk6IEJyb3dzZXJJbmZvIHwgbnVsbCB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOT1RFOiBUaGUgb3JkZXIgbWF0dGVycyBoZXJlIVxuICBjb25zdCBicm93c2VyUGF0dGVybnMgPSBbXG4gICAgeyBrZXk6ICdlZGdlJyBhcyBjb25zdCwgcGF0dGVybjogL0VkZ2UoPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICB7IGtleTogJ2llJyBhcyBjb25zdCwgcGF0dGVybjogL01TSUUoPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICB7IGtleTogJ2llJyBhcyBjb25zdCwgcGF0dGVybjogL1RyaWRlbnQoPzouKnJ2XFw6KFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICB7IGtleTogJ2Nocm9tZScgYXMgY29uc3QsIHBhdHRlcm46IC9DaHJvbWUoPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICB7IGtleTogJ2ZpcmVmb3gnIGFzIGNvbnN0LCBwYXR0ZXJuOiAvRmlyZWZveCg/OlxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgIHsga2V5OiAnc2FmYXJpJyBhcyBjb25zdCwgcGF0dGVybjogLyg/OlZlcnNpb25cXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPyg/OlxcVytNb2JpbGVcXFMqKT9cXFcrU2FmYXJpLyB9LFxuICBdO1xuXG4gIC8vIEZpbmQgdGhlIEZJUlNUIG1hdGNoaW5nIGJyb3dzZXJcbiAgZm9yIChjb25zdCB7IGtleSwgcGF0dGVybiB9IG9mIGJyb3dzZXJQYXR0ZXJucykge1xuICAgIGNvbnN0IG1hdGNoID0gcGF0dGVybi5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgY29uc3QgbWFqb3IgPSBtYXRjaFsxXSB8fCAwO1xuICAgICAgY29uc3QgbWlub3IgPSBtYXRjaFsyXSB8fCAwO1xuICAgICAgY29uc3QgcGF0Y2ggPSBtYXRjaFszXSB8fCAwO1xuXG4gICAgICByZXR1cm4geyBicm93c2VyOiBrZXksIHZlcnNpb246IGAke21ham9yfS4ke21pbm9yfS4ke3BhdGNofWAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3Qgbm9ybWFsaXplQXJjaCA9IChhcmNoOiBzdHJpbmcpOiBBcmNoID0+IHtcbiAgLy8gTm9kZSBkb2NzOlxuICAvLyAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NhcmNoXG4gIC8vIERlbm8gZG9jczpcbiAgLy8gLSBodHRwczovL2RvYy5kZW5vLmxhbmQvZGVuby9zdGFibGUvfi9EZW5vLmJ1aWxkXG4gIGlmIChhcmNoID09PSAneDMyJykgcmV0dXJuICd4MzInO1xuICBpZiAoYXJjaCA9PT0gJ3g4Nl82NCcgfHwgYXJjaCA9PT0gJ3g2NCcpIHJldHVybiAneDY0JztcbiAgaWYgKGFyY2ggPT09ICdhcm0nKSByZXR1cm4gJ2FybSc7XG4gIGlmIChhcmNoID09PSAnYWFyY2g2NCcgfHwgYXJjaCA9PT0gJ2FybTY0JykgcmV0dXJuICdhcm02NCc7XG4gIGlmIChhcmNoKSByZXR1cm4gYG90aGVyOiR7YXJjaH1gO1xuICByZXR1cm4gJ3Vua25vd24nO1xufTtcblxuY29uc3Qgbm9ybWFsaXplUGxhdGZvcm0gPSAocGxhdGZvcm06IHN0cmluZyk6IFBsYXRmb3JtTmFtZSA9PiB7XG4gIC8vIE5vZGUgcGxhdGZvcm1zOlxuICAvLyAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NwbGF0Zm9ybVxuICAvLyBEZW5vIHBsYXRmb3JtczpcbiAgLy8gLSBodHRwczovL2RvYy5kZW5vLmxhbmQvZGVuby9zdGFibGUvfi9EZW5vLmJ1aWxkXG4gIC8vIC0gaHR0cHM6Ly9naXRodWIuY29tL2Rlbm9sYW5kL2Rlbm8vaXNzdWVzLzE0Nzk5XG5cbiAgcGxhdGZvcm0gPSBwbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIE5PVEU6IHRoaXMgaU9TIGNoZWNrIGlzIHVudGVzdGVkIGFuZCBtYXkgbm90IHdvcmtcbiAgLy8gTm9kZSBkb2VzIG5vdCB3b3JrIG5hdGl2ZWx5IG9uIElPUywgdGhlcmUgaXMgYSBmb3JrIGF0XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMtbW9iaWxlL25vZGVqcy1tb2JpbGVcbiAgLy8gaG93ZXZlciBpdCBpcyB1bmtub3duIGF0IHRoZSB0aW1lIG9mIHdyaXRpbmcgaG93IHRvIGRldGVjdCBpZiBpdCBpcyBydW5uaW5nXG4gIGlmIChwbGF0Zm9ybS5pbmNsdWRlcygnaW9zJykpIHJldHVybiAnaU9TJztcbiAgaWYgKHBsYXRmb3JtID09PSAnYW5kcm9pZCcpIHJldHVybiAnQW5kcm9pZCc7XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHJldHVybiAnTWFjT1MnO1xuICBpZiAocGxhdGZvcm0gPT09ICd3aW4zMicpIHJldHVybiAnV2luZG93cyc7XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKSByZXR1cm4gJ0ZyZWVCU0QnO1xuICBpZiAocGxhdGZvcm0gPT09ICdvcGVuYnNkJykgcmV0dXJuICdPcGVuQlNEJztcbiAgaWYgKHBsYXRmb3JtID09PSAnbGludXgnKSByZXR1cm4gJ0xpbnV4JztcbiAgaWYgKHBsYXRmb3JtKSByZXR1cm4gYE90aGVyOiR7cGxhdGZvcm19YDtcbiAgcmV0dXJuICdVbmtub3duJztcbn07XG5cbmxldCBfcGxhdGZvcm1IZWFkZXJzOiBQbGF0Zm9ybVByb3BlcnRpZXM7XG5jb25zdCBnZXRQbGF0Zm9ybUhlYWRlcnMgPSAoKSA9PiB7XG4gIHJldHVybiAoX3BsYXRmb3JtSGVhZGVycyA/Pz0gZ2V0UGxhdGZvcm1Qcm9wZXJ0aWVzKCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHNhZmVKU09OID0gKHRleHQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1zY2hlbWUtc3RyaW5nXG5jb25zdCBzdGFydHNXaXRoU2NoZW1lUmVnZXhwID0gL15bYS16XVthLXowLTkrLi1dKjovaTtcbmNvbnN0IGlzQWJzb2x1dGVVUkwgPSAodXJsOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgcmV0dXJuIHN0YXJ0c1dpdGhTY2hlbWVSZWdleHAudGVzdCh1cmwpO1xufTtcblxuZXhwb3J0IGNvbnN0IHNsZWVwID0gKG1zOiBudW1iZXIpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG5cbmNvbnN0IHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyID0gKG5hbWU6IHN0cmluZywgbjogdW5rbm93bik6IG51bWJlciA9PiB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIobikpIHtcbiAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBhbiBpbnRlZ2VyYCk7XG4gIH1cbiAgaWYgKG4gPCAwKSB7XG4gICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGAke25hbWV9IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyYCk7XG4gIH1cbiAgcmV0dXJuIG47XG59O1xuXG5leHBvcnQgY29uc3QgY2FzdFRvRXJyb3IgPSAoZXJyOiBhbnkpOiBFcnJvciA9PiB7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIGVycjtcbiAgaWYgKHR5cGVvZiBlcnIgPT09ICdvYmplY3QnICYmIGVyciAhPT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KGVycikpO1xuICAgIH0gY2F0Y2gge31cbiAgfVxuICByZXR1cm4gbmV3IEVycm9yKGVycik7XG59O1xuXG5leHBvcnQgY29uc3QgZW5zdXJlUHJlc2VudCA9IDxUPih2YWx1ZTogVCB8IG51bGwgfCB1bmRlZmluZWQpOiBUID0+IHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHRocm93IG5ldyBPcGVuQUlFcnJvcihgRXhwZWN0ZWQgYSB2YWx1ZSB0byBiZSBnaXZlbiBidXQgcmVjZWl2ZWQgJHt2YWx1ZX0gaW5zdGVhZC5gKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkIGFuIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICpcbiAqIFRyaW1zIGJlZ2lubmluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS5cbiAqXG4gKiBXaWxsIHJldHVybiB1bmRlZmluZWQgaWYgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIGRvZXNuJ3QgZXhpc3Qgb3IgY2Fubm90IGJlIGFjY2Vzc2VkLlxuICovXG5leHBvcnQgY29uc3QgcmVhZEVudiA9IChlbnY6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnY/LltlbnZdPy50cmltKCkgPz8gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gRGVuby5lbnY/LmdldD8uKGVudik/LnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvZXJjZUludGVnZXIgPSAodmFsdWU6IHVua25vd24pOiBudW1iZXIgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG5cbiAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBDb3VsZCBub3QgY29lcmNlICR7dmFsdWV9ICh0eXBlOiAke3R5cGVvZiB2YWx1ZX0pIGludG8gYSBudW1iZXJgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjb2VyY2VGbG9hdCA9ICh2YWx1ZTogdW5rbm93bik6IG51bWJlciA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSByZXR1cm4gdmFsdWU7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBDb3VsZCBub3QgY29lcmNlICR7dmFsdWV9ICh0eXBlOiAke3R5cGVvZiB2YWx1ZX0pIGludG8gYSBudW1iZXJgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjb2VyY2VCb29sZWFuID0gKHZhbHVlOiB1bmtub3duKTogYm9vbGVhbiA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykgcmV0dXJuIHZhbHVlO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgcmV0dXJuIHZhbHVlID09PSAndHJ1ZSc7XG4gIHJldHVybiBCb29sZWFuKHZhbHVlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBtYXliZUNvZXJjZUludGVnZXIgPSAodmFsdWU6IHVua25vd24pOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGNvZXJjZUludGVnZXIodmFsdWUpO1xufTtcblxuZXhwb3J0IGNvbnN0IG1heWJlQ29lcmNlRmxvYXQgPSAodmFsdWU6IHVua25vd24pOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGNvZXJjZUZsb2F0KHZhbHVlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBtYXliZUNvZXJjZUJvb2xlYW4gPSAodmFsdWU6IHVua25vd24pOiBib29sZWFuIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBjb2VyY2VCb29sZWFuKHZhbHVlKTtcbn07XG5cbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNDQ5MTI4N1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHlPYmoob2JqOiBPYmplY3QgfCBudWxsIHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gIGlmICghb2JqKSByZXR1cm4gdHJ1ZTtcbiAgZm9yIChjb25zdCBfayBpbiBvYmopIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGh0dHBzOi8vZXNsaW50Lm9yZy9kb2NzL2xhdGVzdC9ydWxlcy9uby1wcm90b3R5cGUtYnVpbHRpbnNcbmV4cG9ydCBmdW5jdGlvbiBoYXNPd24ob2JqOiBPYmplY3QsIGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG4vKipcbiAqIENvcGllcyBoZWFkZXJzIGZyb20gXCJuZXdIZWFkZXJzXCIgb250byBcInRhcmdldEhlYWRlcnNcIixcbiAqIHVzaW5nIGxvd2VyLWNhc2UgZm9yIGFsbCBwcm9wZXJ0aWVzLFxuICogaWdub3JpbmcgYW55IGtleXMgd2l0aCB1bmRlZmluZWQgdmFsdWVzLFxuICogYW5kIGRlbGV0aW5nIGFueSBrZXlzIHdpdGggbnVsbCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5SGVhZGVyc011dCh0YXJnZXRIZWFkZXJzOiBIZWFkZXJzLCBuZXdIZWFkZXJzOiBIZWFkZXJzKTogdm9pZCB7XG4gIGZvciAoY29uc3QgayBpbiBuZXdIZWFkZXJzKSB7XG4gICAgaWYgKCFoYXNPd24obmV3SGVhZGVycywgaykpIGNvbnRpbnVlO1xuICAgIGNvbnN0IGxvd2VyS2V5ID0gay50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghbG93ZXJLZXkpIGNvbnRpbnVlO1xuXG4gICAgY29uc3QgdmFsID0gbmV3SGVhZGVyc1trXTtcblxuICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRIZWFkZXJzW2xvd2VyS2V5XTtcbiAgICB9IGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXRIZWFkZXJzW2xvd2VyS2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgU0VOU0lUSVZFX0hFQURFUlMgPSBuZXcgU2V0KFsnYXV0aG9yaXphdGlvbicsICdhcGkta2V5J10pO1xuXG5leHBvcnQgZnVuY3Rpb24gZGVidWcoYWN0aW9uOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKSB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcz8uZW52Py5bJ0RFQlVHJ10gPT09ICd0cnVlJykge1xuICAgIGNvbnN0IG1vZGlmaWVkQXJncyA9IGFyZ3MubWFwKChhcmcpID0+IHtcbiAgICAgIGlmICghYXJnKSB7XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBzZW5zaXRpdmUgaGVhZGVycyBpbiByZXF1ZXN0IGJvZHkgJ2hlYWRlcnMnIG9iamVjdFxuICAgICAgaWYgKGFyZ1snaGVhZGVycyddKSB7XG4gICAgICAgIC8vIGNsb25lIHNvIHdlIGRvbid0IG11dGF0ZVxuICAgICAgICBjb25zdCBtb2RpZmllZEFyZyA9IHsgLi4uYXJnLCBoZWFkZXJzOiB7IC4uLmFyZ1snaGVhZGVycyddIH0gfTtcblxuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBpbiBhcmdbJ2hlYWRlcnMnXSkge1xuICAgICAgICAgIGlmIChTRU5TSVRJVkVfSEVBREVSUy5oYXMoaGVhZGVyLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICBtb2RpZmllZEFyZ1snaGVhZGVycyddW2hlYWRlcl0gPSAnUkVEQUNURUQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb2RpZmllZEFyZztcbiAgICAgIH1cblxuICAgICAgbGV0IG1vZGlmaWVkQXJnID0gbnVsbDtcblxuICAgICAgLy8gQ2hlY2sgZm9yIHNlbnNpdGl2ZSBoZWFkZXJzIGluIGhlYWRlcnMgb2JqZWN0XG4gICAgICBmb3IgKGNvbnN0IGhlYWRlciBpbiBhcmcpIHtcbiAgICAgICAgaWYgKFNFTlNJVElWRV9IRUFERVJTLmhhcyhoZWFkZXIudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAvLyBhdm9pZCBtYWtpbmcgYSBjb3B5IHVudGlsIHdlIG5lZWQgdG9cbiAgICAgICAgICBtb2RpZmllZEFyZyA/Pz0geyAuLi5hcmcgfTtcbiAgICAgICAgICBtb2RpZmllZEFyZ1toZWFkZXJdID0gJ1JFREFDVEVEJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW9kaWZpZWRBcmcgPz8gYXJnO1xuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKGBPcGVuQUk6REVCVUc6JHthY3Rpb259YCwgLi4ubW9kaWZpZWRBcmdzKTtcbiAgfVxufVxuXG4vKipcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMTE3NTIzXG4gKi9cbmNvbnN0IHV1aWQ0ID0gKCkgPT4ge1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCAoYykgPT4ge1xuICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDA7XG4gICAgY29uc3QgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDg7XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc1J1bm5pbmdJbkJyb3dzZXIgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnXG4gICk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEhlYWRlcnNQcm90b2NvbCB7XG4gIGdldDogKGhlYWRlcjogc3RyaW5nKSA9PiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xufVxuZXhwb3J0IHR5cGUgSGVhZGVyc0xpa2UgPSBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZD4gfCBIZWFkZXJzUHJvdG9jb2w7XG5cbmV4cG9ydCBjb25zdCBpc0hlYWRlcnNQcm90b2NvbCA9IChoZWFkZXJzOiBhbnkpOiBoZWFkZXJzIGlzIEhlYWRlcnNQcm90b2NvbCA9PiB7XG4gIHJldHVybiB0eXBlb2YgaGVhZGVycz8uZ2V0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFJlcXVpcmVkSGVhZGVyID0gKGhlYWRlcnM6IEhlYWRlcnNMaWtlIHwgSGVhZGVycywgaGVhZGVyOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBmb3VuZEhlYWRlciA9IGdldEhlYWRlcihoZWFkZXJzLCBoZWFkZXIpO1xuICBpZiAoZm91bmRIZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgJHtoZWFkZXJ9IGhlYWRlcmApO1xuICB9XG4gIHJldHVybiBmb3VuZEhlYWRlcjtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRIZWFkZXIgPSAoaGVhZGVyczogSGVhZGVyc0xpa2UgfCBIZWFkZXJzLCBoZWFkZXI6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IGxvd2VyQ2FzZWRIZWFkZXIgPSBoZWFkZXIudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGlzSGVhZGVyc1Byb3RvY29sKGhlYWRlcnMpKSB7XG4gICAgLy8gdG8gZGVhbCB3aXRoIHRoZSBjYXNlIHdoZXJlIHRoZSBoZWFkZXIgbG9va3MgbGlrZSBTdGFpbmxlc3MtRXZlbnQtSWRcbiAgICBjb25zdCBpbnRlcmNhcHNIZWFkZXIgPVxuICAgICAgaGVhZGVyWzBdPy50b1VwcGVyQ2FzZSgpICtcbiAgICAgIGhlYWRlci5zdWJzdHJpbmcoMSkucmVwbGFjZSgvKFteXFx3XSkoXFx3KS9nLCAoX20sIGcxLCBnMikgPT4gZzEgKyBnMi50b1VwcGVyQ2FzZSgpKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBbaGVhZGVyLCBsb3dlckNhc2VkSGVhZGVyLCBoZWFkZXIudG9VcHBlckNhc2UoKSwgaW50ZXJjYXBzSGVhZGVyXSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBoZWFkZXJzLmdldChrZXkpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xuICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gbG93ZXJDYXNlZEhlYWRlcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPD0gMSkgcmV0dXJuIHZhbHVlWzBdO1xuICAgICAgICBjb25zb2xlLndhcm4oYFJlY2VpdmVkICR7dmFsdWUubGVuZ3RofSBlbnRyaWVzIGZvciB0aGUgJHtoZWFkZXJ9IGhlYWRlciwgdXNpbmcgdGhlIGZpcnN0IGVudHJ5LmApO1xuICAgICAgICByZXR1cm4gdmFsdWVbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIHN0cmluZyB0byBCYXNlNjQgZm9ybWF0LlxuICovXG5leHBvcnQgY29uc3QgdG9CYXNlNjQgPSAoc3RyOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKTogc3RyaW5nID0+IHtcbiAgaWYgKCFzdHIpIHJldHVybiAnJztcbiAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBidG9hKHN0cik7XG4gIH1cblxuICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoJ0Nhbm5vdCBnZW5lcmF0ZSBiNjQgc3RyaW5nOyBFeHBlY3RlZCBgQnVmZmVyYCBvciBgYnRvYWAgdG8gYmUgZGVmaW5lZCcpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqKG9iajogdW5rbm93bik6IG9iaiBpcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmopO1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFic3RyYWN0UGFnZSwgUmVzcG9uc2UsIEFQSUNsaWVudCwgRmluYWxSZXF1ZXN0T3B0aW9ucywgUGFnZUluZm8gfSBmcm9tICcuL2NvcmUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2VSZXNwb25zZTxJdGVtPiB7XG4gIGRhdGE6IEFycmF5PEl0ZW0+O1xuXG4gIG9iamVjdDogc3RyaW5nO1xufVxuXG4vKipcbiAqIE5vdGU6IG5vIHBhZ2luYXRpb24gYWN0dWFsbHkgb2NjdXJzIHlldCwgdGhpcyBpcyBmb3IgZm9yd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2U8SXRlbT4gZXh0ZW5kcyBBYnN0cmFjdFBhZ2U8SXRlbT4gaW1wbGVtZW50cyBQYWdlUmVzcG9uc2U8SXRlbT4ge1xuICBkYXRhOiBBcnJheTxJdGVtPjtcblxuICBvYmplY3Q6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihjbGllbnQ6IEFQSUNsaWVudCwgcmVzcG9uc2U6IFJlc3BvbnNlLCBib2R5OiBQYWdlUmVzcG9uc2U8SXRlbT4sIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnMpIHtcbiAgICBzdXBlcihjbGllbnQsIHJlc3BvbnNlLCBib2R5LCBvcHRpb25zKTtcblxuICAgIHRoaXMuZGF0YSA9IGJvZHkuZGF0YSB8fCBbXTtcbiAgICB0aGlzLm9iamVjdCA9IGJvZHkub2JqZWN0O1xuICB9XG5cbiAgZ2V0UGFnaW5hdGVkSXRlbXMoKTogSXRlbVtdIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhID8/IFtdO1xuICB9XG5cbiAgLy8gQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBgbmV4dFBhZ2VJbmZvKClgIGluc3RlYWRcbiAgLyoqXG4gICAqIFRoaXMgcGFnZSByZXByZXNlbnRzIGEgcmVzcG9uc2UgdGhhdCBpc24ndCBhY3R1YWxseSBwYWdpbmF0ZWQgYXQgdGhlIEFQSSBsZXZlbFxuICAgKiBzbyB0aGVyZSB3aWxsIG5ldmVyIGJlIGFueSBuZXh0IHBhZ2UgcGFyYW1zLlxuICAgKi9cbiAgbmV4dFBhZ2VQYXJhbXMoKTogbnVsbCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuZXh0UGFnZUluZm8oKTogbnVsbCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDdXJzb3JQYWdlUmVzcG9uc2U8SXRlbT4ge1xuICBkYXRhOiBBcnJheTxJdGVtPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDdXJzb3JQYWdlUGFyYW1zIHtcbiAgYWZ0ZXI/OiBzdHJpbmc7XG5cbiAgbGltaXQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBDdXJzb3JQYWdlPEl0ZW0gZXh0ZW5kcyB7IGlkOiBzdHJpbmcgfT5cbiAgZXh0ZW5kcyBBYnN0cmFjdFBhZ2U8SXRlbT5cbiAgaW1wbGVtZW50cyBDdXJzb3JQYWdlUmVzcG9uc2U8SXRlbT5cbntcbiAgZGF0YTogQXJyYXk8SXRlbT47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgY2xpZW50OiBBUElDbGllbnQsXG4gICAgcmVzcG9uc2U6IFJlc3BvbnNlLFxuICAgIGJvZHk6IEN1cnNvclBhZ2VSZXNwb25zZTxJdGVtPixcbiAgICBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zLFxuICApIHtcbiAgICBzdXBlcihjbGllbnQsIHJlc3BvbnNlLCBib2R5LCBvcHRpb25zKTtcblxuICAgIHRoaXMuZGF0YSA9IGJvZHkuZGF0YSB8fCBbXTtcbiAgfVxuXG4gIGdldFBhZ2luYXRlZEl0ZW1zKCk6IEl0ZW1bXSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YSA/PyBbXTtcbiAgfVxuXG4gIC8vIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYG5leHRQYWdlSW5mbygpYCBpbnN0ZWFkXG4gIG5leHRQYWdlUGFyYW1zKCk6IFBhcnRpYWw8Q3Vyc29yUGFnZVBhcmFtcz4gfCBudWxsIHtcbiAgICBjb25zdCBpbmZvID0gdGhpcy5uZXh0UGFnZUluZm8oKTtcbiAgICBpZiAoIWluZm8pIHJldHVybiBudWxsO1xuICAgIGlmICgncGFyYW1zJyBpbiBpbmZvKSByZXR1cm4gaW5mby5wYXJhbXM7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmZyb21FbnRyaWVzKGluZm8udXJsLnNlYXJjaFBhcmFtcyk7XG4gICAgaWYgKCFPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIG5leHRQYWdlSW5mbygpOiBQYWdlSW5mbyB8IG51bGwge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldFBhZ2luYXRlZEl0ZW1zKCk7XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0/LmlkO1xuICAgIGlmICghaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7IHBhcmFtczogeyBhZnRlcjogaWQgfSB9O1xuICB9XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHR5cGUgeyBPcGVuQUkgfSBmcm9tICcuL2luZGV4JztcblxuZXhwb3J0IGNsYXNzIEFQSVJlc291cmNlIHtcbiAgcHJvdGVjdGVkIF9jbGllbnQ6IE9wZW5BSTtcblxuICBjb25zdHJ1Y3RvcihjbGllbnQ6IE9wZW5BSSkge1xuICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgfVxufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgQVBJUHJvbWlzZSB9IGZyb20gJy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIENoYXRDb21wbGV0aW9uc0FQSSBmcm9tICcuL2NvbXBsZXRpb25zJztcbmltcG9ydCAqIGFzIENvbXBsZXRpb25zQVBJIGZyb20gJy4uL2NvbXBsZXRpb25zJztcbmltcG9ydCAqIGFzIFNoYXJlZCBmcm9tICcuLi9zaGFyZWQnO1xuaW1wb3J0ICogYXMgQ2hhdEFQSSBmcm9tICcuL2NoYXQnO1xuaW1wb3J0IHsgU3RyZWFtIH0gZnJvbSAnLi4vLi4vc3RyZWFtaW5nJztcblxuZXhwb3J0IGNsYXNzIENvbXBsZXRpb25zIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG1vZGVsIHJlc3BvbnNlIGZvciB0aGUgZ2l2ZW4gY2hhdCBjb252ZXJzYXRpb24uIExlYXJuIG1vcmUgaW4gdGhlXG4gICAqIFt0ZXh0IGdlbmVyYXRpb25dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy90ZXh0LWdlbmVyYXRpb24pLFxuICAgKiBbdmlzaW9uXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvdmlzaW9uKSwgYW5kXG4gICAqIFthdWRpb10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2F1ZGlvKSBndWlkZXMuXG4gICAqXG4gICAqIFBhcmFtZXRlciBzdXBwb3J0IGNhbiBkaWZmZXIgZGVwZW5kaW5nIG9uIHRoZSBtb2RlbCB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiByZXNwb25zZSwgcGFydGljdWxhcmx5IGZvciBuZXdlciByZWFzb25pbmcgbW9kZWxzLiBQYXJhbWV0ZXJzIHRoYXQgYXJlIG9ubHlcbiAgICogc3VwcG9ydGVkIGZvciByZWFzb25pbmcgbW9kZWxzIGFyZSBub3RlZCBiZWxvdy4gRm9yIHRoZSBjdXJyZW50IHN0YXRlIG9mXG4gICAqIHVuc3VwcG9ydGVkIHBhcmFtZXRlcnMgaW4gcmVhc29uaW5nIG1vZGVscyxcbiAgICogW3JlZmVyIHRvIHRoZSByZWFzb25pbmcgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9yZWFzb25pbmcpLlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIGJvZHk6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPENoYXRDb21wbGV0aW9uPjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxDaGF0Q29tcGxldGlvbkNodW5rPj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2UsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8U3RyZWFtPENoYXRDb21wbGV0aW9uQ2h1bms+IHwgQ2hhdENvbXBsZXRpb24+O1xuICBjcmVhdGUoXG4gICAgYm9keTogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8Q2hhdENvbXBsZXRpb24+IHwgQVBJUHJvbWlzZTxTdHJlYW08Q2hhdENvbXBsZXRpb25DaHVuaz4+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9jaGF0L2NvbXBsZXRpb25zJywgeyBib2R5LCAuLi5vcHRpb25zLCBzdHJlYW06IGJvZHkuc3RyZWFtID8/IGZhbHNlIH0pIGFzXG4gICAgICB8IEFQSVByb21pc2U8Q2hhdENvbXBsZXRpb24+XG4gICAgICB8IEFQSVByb21pc2U8U3RyZWFtPENoYXRDb21wbGV0aW9uQ2h1bms+PjtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaGF0IGNvbXBsZXRpb24gcmVzcG9uc2UgcmV0dXJuZWQgYnkgbW9kZWwsIGJhc2VkIG9uIHRoZSBwcm92aWRlZFxuICogaW5wdXQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb24ge1xuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNoYXQgY29tcGxldGlvbi5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBjaGF0IGNvbXBsZXRpb24gY2hvaWNlcy4gQ2FuIGJlIG1vcmUgdGhhbiBvbmUgaWYgYG5gIGlzIGdyZWF0ZXJcbiAgICogdGhhbiAxLlxuICAgKi9cbiAgY2hvaWNlczogQXJyYXk8Q2hhdENvbXBsZXRpb24uQ2hvaWNlPjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBvZiB3aGVuIHRoZSBjaGF0IGNvbXBsZXRpb24gd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlbCB1c2VkIGZvciB0aGUgY2hhdCBjb21wbGV0aW9uLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYGNoYXQuY29tcGxldGlvbmAuXG4gICAqL1xuICBvYmplY3Q6ICdjaGF0LmNvbXBsZXRpb24nO1xuXG4gIC8qKlxuICAgKiBUaGUgc2VydmljZSB0aWVyIHVzZWQgZm9yIHByb2Nlc3NpbmcgdGhlIHJlcXVlc3QuIFRoaXMgZmllbGQgaXMgb25seSBpbmNsdWRlZCBpZlxuICAgKiB0aGUgYHNlcnZpY2VfdGllcmAgcGFyYW1ldGVyIGlzIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdC5cbiAgICovXG4gIHNlcnZpY2VfdGllcj86ICdzY2FsZScgfCAnZGVmYXVsdCcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZpbmdlcnByaW50IHJlcHJlc2VudHMgdGhlIGJhY2tlbmQgY29uZmlndXJhdGlvbiB0aGF0IHRoZSBtb2RlbCBydW5zIHdpdGguXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGBzZWVkYCByZXF1ZXN0IHBhcmFtZXRlciB0byB1bmRlcnN0YW5kIHdoZW5cbiAgICogYmFja2VuZCBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlIHRoYXQgbWlnaHQgaW1wYWN0IGRldGVybWluaXNtLlxuICAgKi9cbiAgc3lzdGVtX2ZpbmdlcnByaW50Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBVc2FnZSBzdGF0aXN0aWNzIGZvciB0aGUgY29tcGxldGlvbiByZXF1ZXN0LlxuICAgKi9cbiAgdXNhZ2U/OiBDb21wbGV0aW9uc0FQSS5Db21wbGV0aW9uVXNhZ2U7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdENvbXBsZXRpb24ge1xuICBleHBvcnQgaW50ZXJmYWNlIENob2ljZSB7XG4gICAgLyoqXG4gICAgICogVGhlIHJlYXNvbiB0aGUgbW9kZWwgc3RvcHBlZCBnZW5lcmF0aW5nIHRva2Vucy4gVGhpcyB3aWxsIGJlIGBzdG9wYCBpZiB0aGUgbW9kZWxcbiAgICAgKiBoaXQgYSBuYXR1cmFsIHN0b3AgcG9pbnQgb3IgYSBwcm92aWRlZCBzdG9wIHNlcXVlbmNlLCBgbGVuZ3RoYCBpZiB0aGUgbWF4aW11bVxuICAgICAqIG51bWJlciBvZiB0b2tlbnMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0IHdhcyByZWFjaGVkLCBgY29udGVudF9maWx0ZXJgIGlmXG4gICAgICogY29udGVudCB3YXMgb21pdHRlZCBkdWUgdG8gYSBmbGFnIGZyb20gb3VyIGNvbnRlbnQgZmlsdGVycywgYHRvb2xfY2FsbHNgIGlmIHRoZVxuICAgICAqIG1vZGVsIGNhbGxlZCBhIHRvb2wsIG9yIGBmdW5jdGlvbl9jYWxsYCAoZGVwcmVjYXRlZCkgaWYgdGhlIG1vZGVsIGNhbGxlZCBhXG4gICAgICogZnVuY3Rpb24uXG4gICAgICovXG4gICAgZmluaXNoX3JlYXNvbjogJ3N0b3AnIHwgJ2xlbmd0aCcgfCAndG9vbF9jYWxscycgfCAnY29udGVudF9maWx0ZXInIHwgJ2Z1bmN0aW9uX2NhbGwnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBjaG9pY2UgaW4gdGhlIGxpc3Qgb2YgY2hvaWNlcy5cbiAgICAgKi9cbiAgICBpbmRleDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogTG9nIHByb2JhYmlsaXR5IGluZm9ybWF0aW9uIGZvciB0aGUgY2hvaWNlLlxuICAgICAqL1xuICAgIGxvZ3Byb2JzOiBDaG9pY2UuTG9ncHJvYnMgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBjaGF0IGNvbXBsZXRpb24gbWVzc2FnZSBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIG1lc3NhZ2U6IENoYXRDb21wbGV0aW9uc0FQSS5DaGF0Q29tcGxldGlvbk1lc3NhZ2U7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIENob2ljZSB7XG4gICAgLyoqXG4gICAgICogTG9nIHByb2JhYmlsaXR5IGluZm9ybWF0aW9uIGZvciB0aGUgY2hvaWNlLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgTG9ncHJvYnMge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgbWVzc2FnZSBjb250ZW50IHRva2VucyB3aXRoIGxvZyBwcm9iYWJpbGl0eSBpbmZvcm1hdGlvbi5cbiAgICAgICAqL1xuICAgICAgY29udGVudDogQXJyYXk8Q2hhdENvbXBsZXRpb25zQVBJLkNoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iPiB8IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIG1lc3NhZ2UgcmVmdXNhbCB0b2tlbnMgd2l0aCBsb2cgcHJvYmFiaWxpdHkgaW5mb3JtYXRpb24uXG4gICAgICAgKi9cbiAgICAgIHJlZnVzYWw6IEFycmF5PENoYXRDb21wbGV0aW9uc0FQSS5DaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYj4gfCBudWxsO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lc3NhZ2VzIHNlbnQgYnkgdGhlIG1vZGVsIGluIHJlc3BvbnNlIHRvIHVzZXIgbWVzc2FnZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0ge1xuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIG1lc3NhZ2VzIGF1dGhvciwgaW4gdGhpcyBjYXNlIGBhc3Npc3RhbnRgLlxuICAgKi9cbiAgcm9sZTogJ2Fzc2lzdGFudCc7XG5cbiAgLyoqXG4gICAqIERhdGEgYWJvdXQgYSBwcmV2aW91cyBhdWRpbyByZXNwb25zZSBmcm9tIHRoZSBtb2RlbC5cbiAgICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9hdWRpbykuXG4gICAqL1xuICBhdWRpbz86IENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtLkF1ZGlvIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSBhc3Npc3RhbnQgbWVzc2FnZS4gUmVxdWlyZWQgdW5sZXNzIGB0b29sX2NhbGxzYCBvclxuICAgKiBgZnVuY3Rpb25fY2FsbGAgaXMgc3BlY2lmaWVkLlxuICAgKi9cbiAgY29udGVudD86IHN0cmluZyB8IEFycmF5PENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0IHwgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFJlZnVzYWw+IHwgbnVsbDtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQ6IERlcHJlY2F0ZWQgYW5kIHJlcGxhY2VkIGJ5IGB0b29sX2NhbGxzYC4gVGhlIG5hbWUgYW5kIGFyZ3VtZW50cyBvZlxuICAgKiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIGZ1bmN0aW9uX2NhbGw/OiBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbS5GdW5jdGlvbkNhbGwgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBuYW1lIGZvciB0aGUgcGFydGljaXBhbnQuIFByb3ZpZGVzIHRoZSBtb2RlbCBpbmZvcm1hdGlvbiB0b1xuICAgKiBkaWZmZXJlbnRpYXRlIGJldHdlZW4gcGFydGljaXBhbnRzIG9mIHRoZSBzYW1lIHJvbGUuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVmdXNhbCBtZXNzYWdlIGJ5IHRoZSBhc3Npc3RhbnQuXG4gICAqL1xuICByZWZ1c2FsPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHRvb2wgY2FsbHMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCwgc3VjaCBhcyBmdW5jdGlvbiBjYWxscy5cbiAgICovXG4gIHRvb2xfY2FsbHM/OiBBcnJheTxDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbD47XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0ge1xuICAvKipcbiAgICogRGF0YSBhYm91dCBhIHByZXZpb3VzIGF1ZGlvIHJlc3BvbnNlIGZyb20gdGhlIG1vZGVsLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2F1ZGlvKS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQXVkaW8ge1xuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBpZGVudGlmaWVyIGZvciBhIHByZXZpb3VzIGF1ZGlvIHJlc3BvbnNlIGZyb20gdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGlkOiBzdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQ6IERlcHJlY2F0ZWQgYW5kIHJlcGxhY2VkIGJ5IGB0b29sX2NhbGxzYC4gVGhlIG5hbWUgYW5kIGFyZ3VtZW50cyBvZlxuICAgKiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25DYWxsIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGgsIGFzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaW4gSlNPTlxuICAgICAqIGZvcm1hdC4gTm90ZSB0aGF0IHRoZSBtb2RlbCBkb2VzIG5vdCBhbHdheXMgZ2VuZXJhdGUgdmFsaWQgSlNPTiwgYW5kIG1heVxuICAgICAqIGhhbGx1Y2luYXRlIHBhcmFtZXRlcnMgbm90IGRlZmluZWQgYnkgeW91ciBmdW5jdGlvbiBzY2hlbWEuIFZhbGlkYXRlIHRoZVxuICAgICAqIGFyZ3VtZW50cyBpbiB5b3VyIGNvZGUgYmVmb3JlIGNhbGxpbmcgeW91ciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBhcmd1bWVudHM6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIElmIHRoZSBhdWRpbyBvdXRwdXQgbW9kYWxpdHkgaXMgcmVxdWVzdGVkLCB0aGlzIG9iamVjdCBjb250YWlucyBkYXRhIGFib3V0IHRoZVxuICogYXVkaW8gcmVzcG9uc2UgZnJvbSB0aGUgbW9kZWwuXG4gKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2F1ZGlvKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkF1ZGlvIHtcbiAgLyoqXG4gICAqIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGF1ZGlvIHJlc3BvbnNlLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQmFzZTY0IGVuY29kZWQgYXVkaW8gYnl0ZXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCwgaW4gdGhlIGZvcm1hdCBzcGVjaWZpZWQgaW5cbiAgICogdGhlIHJlcXVlc3QuXG4gICAqL1xuICBkYXRhOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhpcyBhdWRpbyByZXNwb25zZSB3aWxsIG5vIGxvbmdlciBiZVxuICAgKiBhY2Nlc3NpYmxlIG9uIHRoZSBzZXJ2ZXIgZm9yIHVzZSBpbiBtdWx0aS10dXJuIGNvbnZlcnNhdGlvbnMuXG4gICAqL1xuICBleHBpcmVzX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRyYW5zY3JpcHQgb2YgdGhlIGF1ZGlvIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICB0cmFuc2NyaXB0OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUGFyYW1ldGVycyBmb3IgYXVkaW8gb3V0cHV0LiBSZXF1aXJlZCB3aGVuIGF1ZGlvIG91dHB1dCBpcyByZXF1ZXN0ZWQgd2l0aFxuICogYG1vZGFsaXRpZXM6IFtcImF1ZGlvXCJdYC5cbiAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYXVkaW8pLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQXVkaW9QYXJhbSB7XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIG91dHB1dCBhdWRpbyBmb3JtYXQuIE11c3QgYmUgb25lIG9mIGB3YXZgLCBgbXAzYCwgYGZsYWNgLCBgb3B1c2AsXG4gICAqIG9yIGBwY20xNmAuXG4gICAqL1xuICBmb3JtYXQ6ICd3YXYnIHwgJ21wMycgfCAnZmxhYycgfCAnb3B1cycgfCAncGNtMTYnO1xuXG4gIC8qKlxuICAgKiBUaGUgdm9pY2UgdGhlIG1vZGVsIHVzZXMgdG8gcmVzcG9uZC4gU3VwcG9ydGVkIHZvaWNlcyBhcmUgYGFzaGAsIGBiYWxsYWRgLFxuICAgKiBgY29yYWxgLCBgc2FnZWAsIGFuZCBgdmVyc2VgIChhbHNvIHN1cHBvcnRlZCBidXQgbm90IHJlY29tbWVuZGVkIGFyZSBgYWxsb3lgLFxuICAgKiBgZWNob2AsIGFuZCBgc2hpbW1lcmA7IHRoZXNlIHZvaWNlcyBhcmUgbGVzcyBleHByZXNzaXZlKS5cbiAgICovXG4gIHZvaWNlOiAnYWxsb3knIHwgJ2FzaCcgfCAnYmFsbGFkJyB8ICdjb3JhbCcgfCAnZWNobycgfCAnc2FnZScgfCAnc2hpbW1lcicgfCAndmVyc2UnO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdHJlYW1lZCBjaHVuayBvZiBhIGNoYXQgY29tcGxldGlvbiByZXNwb25zZSByZXR1cm5lZCBieSBtb2RlbCxcbiAqIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBpbnB1dC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNodW5rIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjaGF0IGNvbXBsZXRpb24uIEVhY2ggY2h1bmsgaGFzIHRoZSBzYW1lIElELlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGNoYXQgY29tcGxldGlvbiBjaG9pY2VzLiBDYW4gY29udGFpbiBtb3JlIHRoYW4gb25lIGVsZW1lbnRzIGlmIGBuYCBpc1xuICAgKiBncmVhdGVyIHRoYW4gMS4gQ2FuIGFsc28gYmUgZW1wdHkgZm9yIHRoZSBsYXN0IGNodW5rIGlmIHlvdSBzZXRcbiAgICogYHN0cmVhbV9vcHRpb25zOiB7XCJpbmNsdWRlX3VzYWdlXCI6IHRydWV9YC5cbiAgICovXG4gIGNob2ljZXM6IEFycmF5PENoYXRDb21wbGV0aW9uQ2h1bmsuQ2hvaWNlPjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBvZiB3aGVuIHRoZSBjaGF0IGNvbXBsZXRpb24gd2FzIGNyZWF0ZWQuIEVhY2hcbiAgICogY2h1bmsgaGFzIHRoZSBzYW1lIHRpbWVzdGFtcC5cbiAgICovXG4gIGNyZWF0ZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHRvIGdlbmVyYXRlIHRoZSBjb21wbGV0aW9uLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYGNoYXQuY29tcGxldGlvbi5jaHVua2AuXG4gICAqL1xuICBvYmplY3Q6ICdjaGF0LmNvbXBsZXRpb24uY2h1bmsnO1xuXG4gIC8qKlxuICAgKiBUaGUgc2VydmljZSB0aWVyIHVzZWQgZm9yIHByb2Nlc3NpbmcgdGhlIHJlcXVlc3QuIFRoaXMgZmllbGQgaXMgb25seSBpbmNsdWRlZCBpZlxuICAgKiB0aGUgYHNlcnZpY2VfdGllcmAgcGFyYW1ldGVyIGlzIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdC5cbiAgICovXG4gIHNlcnZpY2VfdGllcj86ICdzY2FsZScgfCAnZGVmYXVsdCcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZpbmdlcnByaW50IHJlcHJlc2VudHMgdGhlIGJhY2tlbmQgY29uZmlndXJhdGlvbiB0aGF0IHRoZSBtb2RlbCBydW5zIHdpdGguXG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGBzZWVkYCByZXF1ZXN0IHBhcmFtZXRlciB0byB1bmRlcnN0YW5kIHdoZW5cbiAgICogYmFja2VuZCBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlIHRoYXQgbWlnaHQgaW1wYWN0IGRldGVybWluaXNtLlxuICAgKi9cbiAgc3lzdGVtX2ZpbmdlcnByaW50Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBmaWVsZCB0aGF0IHdpbGwgb25seSBiZSBwcmVzZW50IHdoZW4geW91IHNldFxuICAgKiBgc3RyZWFtX29wdGlvbnM6IHtcImluY2x1ZGVfdXNhZ2VcIjogdHJ1ZX1gIGluIHlvdXIgcmVxdWVzdC4gV2hlbiBwcmVzZW50LCBpdFxuICAgKiBjb250YWlucyBhIG51bGwgdmFsdWUgZXhjZXB0IGZvciB0aGUgbGFzdCBjaHVuayB3aGljaCBjb250YWlucyB0aGUgdG9rZW4gdXNhZ2VcbiAgICogc3RhdGlzdGljcyBmb3IgdGhlIGVudGlyZSByZXF1ZXN0LlxuICAgKi9cbiAgdXNhZ2U/OiBDb21wbGV0aW9uc0FQSS5Db21wbGV0aW9uVXNhZ2UgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uQ2h1bmsge1xuICBleHBvcnQgaW50ZXJmYWNlIENob2ljZSB7XG4gICAgLyoqXG4gICAgICogQSBjaGF0IGNvbXBsZXRpb24gZGVsdGEgZ2VuZXJhdGVkIGJ5IHN0cmVhbWVkIG1vZGVsIHJlc3BvbnNlcy5cbiAgICAgKi9cbiAgICBkZWx0YTogQ2hvaWNlLkRlbHRhO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlYXNvbiB0aGUgbW9kZWwgc3RvcHBlZCBnZW5lcmF0aW5nIHRva2Vucy4gVGhpcyB3aWxsIGJlIGBzdG9wYCBpZiB0aGUgbW9kZWxcbiAgICAgKiBoaXQgYSBuYXR1cmFsIHN0b3AgcG9pbnQgb3IgYSBwcm92aWRlZCBzdG9wIHNlcXVlbmNlLCBgbGVuZ3RoYCBpZiB0aGUgbWF4aW11bVxuICAgICAqIG51bWJlciBvZiB0b2tlbnMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0IHdhcyByZWFjaGVkLCBgY29udGVudF9maWx0ZXJgIGlmXG4gICAgICogY29udGVudCB3YXMgb21pdHRlZCBkdWUgdG8gYSBmbGFnIGZyb20gb3VyIGNvbnRlbnQgZmlsdGVycywgYHRvb2xfY2FsbHNgIGlmIHRoZVxuICAgICAqIG1vZGVsIGNhbGxlZCBhIHRvb2wsIG9yIGBmdW5jdGlvbl9jYWxsYCAoZGVwcmVjYXRlZCkgaWYgdGhlIG1vZGVsIGNhbGxlZCBhXG4gICAgICogZnVuY3Rpb24uXG4gICAgICovXG4gICAgZmluaXNoX3JlYXNvbjogJ3N0b3AnIHwgJ2xlbmd0aCcgfCAndG9vbF9jYWxscycgfCAnY29udGVudF9maWx0ZXInIHwgJ2Z1bmN0aW9uX2NhbGwnIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgY2hvaWNlIGluIHRoZSBsaXN0IG9mIGNob2ljZXMuXG4gICAgICovXG4gICAgaW5kZXg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIExvZyBwcm9iYWJpbGl0eSBpbmZvcm1hdGlvbiBmb3IgdGhlIGNob2ljZS5cbiAgICAgKi9cbiAgICBsb2dwcm9icz86IENob2ljZS5Mb2dwcm9icyB8IG51bGw7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIENob2ljZSB7XG4gICAgLyoqXG4gICAgICogQSBjaGF0IGNvbXBsZXRpb24gZGVsdGEgZ2VuZXJhdGVkIGJ5IHN0cmVhbWVkIG1vZGVsIHJlc3BvbnNlcy5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIERlbHRhIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSBjaHVuayBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICBjb250ZW50Pzogc3RyaW5nIHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAZGVwcmVjYXRlZDogRGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgYnkgYHRvb2xfY2FsbHNgLiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mXG4gICAgICAgKiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb25fY2FsbD86IERlbHRhLkZ1bmN0aW9uQ2FsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcmVmdXNhbCBtZXNzYWdlIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gICAgICAgKi9cbiAgICAgIHJlZnVzYWw/OiBzdHJpbmcgfCBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSByb2xlIG9mIHRoZSBhdXRob3Igb2YgdGhpcyBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICByb2xlPzogJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50JyB8ICd0b29sJztcblxuICAgICAgdG9vbF9jYWxscz86IEFycmF5PERlbHRhLlRvb2xDYWxsPjtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIERlbHRhIHtcbiAgICAgIC8qKlxuICAgICAgICogQGRlcHJlY2F0ZWQ6IERlcHJlY2F0ZWQgYW5kIHJlcGxhY2VkIGJ5IGB0b29sX2NhbGxzYC4gVGhlIG5hbWUgYW5kIGFyZ3VtZW50cyBvZlxuICAgICAgICogYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQsIGFzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gICAgICAgKi9cbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25DYWxsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhcmd1bWVudHMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpbiBKU09OXG4gICAgICAgICAqIGZvcm1hdC4gTm90ZSB0aGF0IHRoZSBtb2RlbCBkb2VzIG5vdCBhbHdheXMgZ2VuZXJhdGUgdmFsaWQgSlNPTiwgYW5kIG1heVxuICAgICAgICAgKiBoYWxsdWNpbmF0ZSBwYXJhbWV0ZXJzIG5vdCBkZWZpbmVkIGJ5IHlvdXIgZnVuY3Rpb24gc2NoZW1hLiBWYWxpZGF0ZSB0aGVcbiAgICAgICAgICogYXJndW1lbnRzIGluIHlvdXIgY29kZSBiZWZvcmUgY2FsbGluZyB5b3VyIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgYXJndW1lbnRzPzogc3RyaW5nO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgICAgICovXG4gICAgICAgIG5hbWU/OiBzdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgVG9vbENhbGwge1xuICAgICAgICBpbmRleDogbnVtYmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbC5cbiAgICAgICAgICovXG4gICAgICAgIGlkPzogc3RyaW5nO1xuXG4gICAgICAgIGZ1bmN0aW9uPzogVG9vbENhbGwuRnVuY3Rpb247XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSB0b29sLiBDdXJyZW50bHksIG9ubHkgYGZ1bmN0aW9uYCBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlPzogJ2Z1bmN0aW9uJztcbiAgICAgIH1cblxuICAgICAgZXhwb3J0IG5hbWVzcGFjZSBUb29sQ2FsbCB7XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb24ge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBhcmd1bWVudHMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpbiBKU09OXG4gICAgICAgICAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAgICAgICAgICogaGFsbHVjaW5hdGUgcGFyYW1ldGVycyBub3QgZGVmaW5lZCBieSB5b3VyIGZ1bmN0aW9uIHNjaGVtYS4gVmFsaWRhdGUgdGhlXG4gICAgICAgICAgICogYXJndW1lbnRzIGluIHlvdXIgY29kZSBiZWZvcmUgY2FsbGluZyB5b3VyIGZ1bmN0aW9uLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGFyZ3VtZW50cz86IHN0cmluZztcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIG5hbWU/OiBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2cgcHJvYmFiaWxpdHkgaW5mb3JtYXRpb24gZm9yIHRoZSBjaG9pY2UuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBMb2dwcm9icyB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBtZXNzYWdlIGNvbnRlbnQgdG9rZW5zIHdpdGggbG9nIHByb2JhYmlsaXR5IGluZm9ybWF0aW9uLlxuICAgICAgICovXG4gICAgICBjb250ZW50OiBBcnJheTxDaGF0Q29tcGxldGlvbnNBUEkuQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2I+IHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgbWVzc2FnZSByZWZ1c2FsIHRva2VucyB3aXRoIGxvZyBwcm9iYWJpbGl0eSBpbmZvcm1hdGlvbi5cbiAgICAgICAqL1xuICAgICAgcmVmdXNhbDogQXJyYXk8Q2hhdENvbXBsZXRpb25zQVBJLkNoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iPiB8IG51bGw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTGVhcm4gYWJvdXRcbiAqIFt0ZXh0IGlucHV0c10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3RleHQtZ2VuZXJhdGlvbikuXG4gKi9cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnQgPVxuICB8IENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0XG4gIHwgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydEltYWdlXG4gIHwgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydElucHV0QXVkaW87XG5cbi8qKlxuICogTGVhcm4gYWJvdXQgW2ltYWdlIGlucHV0c10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3Zpc2lvbikuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydEltYWdlIHtcbiAgaW1hZ2VfdXJsOiBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2UuSW1hZ2VVUkw7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBjb250ZW50IHBhcnQuXG4gICAqL1xuICB0eXBlOiAnaW1hZ2VfdXJsJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2Uge1xuICBleHBvcnQgaW50ZXJmYWNlIEltYWdlVVJMIHtcbiAgICAvKipcbiAgICAgKiBFaXRoZXIgYSBVUkwgb2YgdGhlIGltYWdlIG9yIHRoZSBiYXNlNjQgZW5jb2RlZCBpbWFnZSBkYXRhLlxuICAgICAqL1xuICAgIHVybDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBkZXRhaWwgbGV2ZWwgb2YgdGhlIGltYWdlLiBMZWFybiBtb3JlIGluIHRoZVxuICAgICAqIFtWaXNpb24gZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy92aXNpb24jbG93LW9yLWhpZ2gtZmlkZWxpdHktaW1hZ2UtdW5kZXJzdGFuZGluZykuXG4gICAgICovXG4gICAgZGV0YWlsPzogJ2F1dG8nIHwgJ2xvdycgfCAnaGlnaCc7XG4gIH1cbn1cblxuLyoqXG4gKiBMZWFybiBhYm91dCBbYXVkaW8gaW5wdXRzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYXVkaW8pLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbnB1dEF1ZGlvIHtcbiAgaW5wdXRfYXVkaW86IENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbnB1dEF1ZGlvLklucHV0QXVkaW87XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBjb250ZW50IHBhcnQuIEFsd2F5cyBgaW5wdXRfYXVkaW9gLlxuICAgKi9cbiAgdHlwZTogJ2lucHV0X2F1ZGlvJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW5wdXRBdWRpbyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpbyB7XG4gICAgLyoqXG4gICAgICogQmFzZTY0IGVuY29kZWQgYXVkaW8gZGF0YS5cbiAgICAgKi9cbiAgICBkYXRhOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybWF0IG9mIHRoZSBlbmNvZGVkIGF1ZGlvIGRhdGEuIEN1cnJlbnRseSBzdXBwb3J0cyBcIndhdlwiIGFuZCBcIm1wM1wiLlxuICAgICAqL1xuICAgIGZvcm1hdDogJ3dhdicgfCAnbXAzJztcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRSZWZ1c2FsIHtcbiAgLyoqXG4gICAqIFRoZSByZWZ1c2FsIG1lc3NhZ2UgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIHJlZnVzYWw6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIGNvbnRlbnQgcGFydC5cbiAgICovXG4gIHR5cGU6ICdyZWZ1c2FsJztcbn1cblxuLyoqXG4gKiBMZWFybiBhYm91dFxuICogW3RleHQgaW5wdXRzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvdGV4dC1nZW5lcmF0aW9uKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dCB7XG4gIC8qKlxuICAgKiBUaGUgdGV4dCBjb250ZW50LlxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgY29udGVudCBwYXJ0LlxuICAgKi9cbiAgdHlwZTogJ3RleHQnO1xufVxuXG4vKipcbiAqIERldmVsb3Blci1wcm92aWRlZCBpbnN0cnVjdGlvbnMgdGhhdCB0aGUgbW9kZWwgc2hvdWxkIGZvbGxvdywgcmVnYXJkbGVzcyBvZlxuICogbWVzc2FnZXMgc2VudCBieSB0aGUgdXNlci4gV2l0aCBvMSBtb2RlbHMgYW5kIG5ld2VyLCBgZGV2ZWxvcGVyYCBtZXNzYWdlc1xuICogcmVwbGFjZSB0aGUgcHJldmlvdXMgYHN5c3RlbWAgbWVzc2FnZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25EZXZlbG9wZXJNZXNzYWdlUGFyYW0ge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSBkZXZlbG9wZXIgbWVzc2FnZS5cbiAgICovXG4gIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0PjtcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIG1lc3NhZ2VzIGF1dGhvciwgaW4gdGhpcyBjYXNlIGBkZXZlbG9wZXJgLlxuICAgKi9cbiAgcm9sZTogJ2RldmVsb3Blcic7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIG5hbWUgZm9yIHRoZSBwYXJ0aWNpcGFudC4gUHJvdmlkZXMgdGhlIG1vZGVsIGluZm9ybWF0aW9uIHRvXG4gICAqIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBwYXJ0aWNpcGFudHMgb2YgdGhlIHNhbWUgcm9sZS5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgZnVuY3Rpb24gdmlhIGB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn1gIGZvcmNlcyB0aGUgbW9kZWxcbiAqIHRvIGNhbGwgdGhhdCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uQ2FsbE9wdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICovXG4gIG5hbWU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW0ge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSBmdW5jdGlvbiBtZXNzYWdlLlxuICAgKi9cbiAgY29udGVudDogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAqL1xuICBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSByb2xlIG9mIHRoZSBtZXNzYWdlcyBhdXRob3IsIGluIHRoaXMgY2FzZSBgZnVuY3Rpb25gLlxuICAgKi9cbiAgcm9sZTogJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBBIGNoYXQgY29tcGxldGlvbiBtZXNzYWdlIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25NZXNzYWdlIHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgbWVzc2FnZS5cbiAgICovXG4gIGNvbnRlbnQ6IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSByZWZ1c2FsIG1lc3NhZ2UgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIHJlZnVzYWw6IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSByb2xlIG9mIHRoZSBhdXRob3Igb2YgdGhpcyBtZXNzYWdlLlxuICAgKi9cbiAgcm9sZTogJ2Fzc2lzdGFudCc7XG5cbiAgLyoqXG4gICAqIElmIHRoZSBhdWRpbyBvdXRwdXQgbW9kYWxpdHkgaXMgcmVxdWVzdGVkLCB0aGlzIG9iamVjdCBjb250YWlucyBkYXRhIGFib3V0IHRoZVxuICAgKiBhdWRpbyByZXNwb25zZSBmcm9tIHRoZSBtb2RlbC5cbiAgICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9hdWRpbykuXG4gICAqL1xuICBhdWRpbz86IENoYXRDb21wbGV0aW9uQXVkaW8gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZDogRGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgYnkgYHRvb2xfY2FsbHNgLiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mXG4gICAqIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgZnVuY3Rpb25fY2FsbD86IENoYXRDb21wbGV0aW9uTWVzc2FnZS5GdW5jdGlvbkNhbGwgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgdG9vbCBjYWxscyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLCBzdWNoIGFzIGZ1bmN0aW9uIGNhbGxzLlxuICAgKi9cbiAgdG9vbF9jYWxscz86IEFycmF5PENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsPjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2Uge1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQ6IERlcHJlY2F0ZWQgYW5kIHJlcGxhY2VkIGJ5IGB0b29sX2NhbGxzYC4gVGhlIG5hbWUgYW5kIGFyZ3VtZW50cyBvZlxuICAgKiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25DYWxsIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGgsIGFzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaW4gSlNPTlxuICAgICAqIGZvcm1hdC4gTm90ZSB0aGF0IHRoZSBtb2RlbCBkb2VzIG5vdCBhbHdheXMgZ2VuZXJhdGUgdmFsaWQgSlNPTiwgYW5kIG1heVxuICAgICAqIGhhbGx1Y2luYXRlIHBhcmFtZXRlcnMgbm90IGRlZmluZWQgYnkgeW91ciBmdW5jdGlvbiBzY2hlbWEuIFZhbGlkYXRlIHRoZVxuICAgICAqIGFyZ3VtZW50cyBpbiB5b3VyIGNvZGUgYmVmb3JlIGNhbGxpbmcgeW91ciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBhcmd1bWVudHM6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIERldmVsb3Blci1wcm92aWRlZCBpbnN0cnVjdGlvbnMgdGhhdCB0aGUgbW9kZWwgc2hvdWxkIGZvbGxvdywgcmVnYXJkbGVzcyBvZlxuICogbWVzc2FnZXMgc2VudCBieSB0aGUgdXNlci4gV2l0aCBvMSBtb2RlbHMgYW5kIG5ld2VyLCBgZGV2ZWxvcGVyYCBtZXNzYWdlc1xuICogcmVwbGFjZSB0aGUgcHJldmlvdXMgYHN5c3RlbWAgbWVzc2FnZXMuXG4gKi9cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtID1cbiAgfCBDaGF0Q29tcGxldGlvbkRldmVsb3Blck1lc3NhZ2VQYXJhbVxuICB8IENoYXRDb21wbGV0aW9uU3lzdGVtTWVzc2FnZVBhcmFtXG4gIHwgQ2hhdENvbXBsZXRpb25Vc2VyTWVzc2FnZVBhcmFtXG4gIHwgQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW1cbiAgfCBDaGF0Q29tcGxldGlvblRvb2xNZXNzYWdlUGFyYW1cbiAgfCBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uTWVzc2FnZVBhcmFtO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsIHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIHRoYXQgdGhlIG1vZGVsIGNhbGxlZC5cbiAgICovXG4gIGZ1bmN0aW9uOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbC5GdW5jdGlvbjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wuIEN1cnJlbnRseSwgb25seSBgZnVuY3Rpb25gIGlzIHN1cHBvcnRlZC5cbiAgICovXG4gIHR5cGU6ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwge1xuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIHRoYXQgdGhlIG1vZGVsIGNhbGxlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBhcmd1bWVudHMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpbiBKU09OXG4gICAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAgICogaGFsbHVjaW5hdGUgcGFyYW1ldGVycyBub3QgZGVmaW5lZCBieSB5b3VyIGZ1bmN0aW9uIHNjaGVtYS4gVmFsaWRhdGUgdGhlXG4gICAgICogYXJndW1lbnRzIGluIHlvdXIgY29kZSBiZWZvcmUgY2FsbGluZyB5b3VyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGFyZ3VtZW50czogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uTW9kYWxpdHkgPSAndGV4dCcgfCAnYXVkaW8nO1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIHRvb2wgdGhlIG1vZGVsIHNob3VsZCB1c2UuIFVzZSB0byBmb3JjZSB0aGUgbW9kZWwgdG8gY2FsbCBhIHNwZWNpZmljXG4gKiBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbk5hbWVkVG9vbENob2ljZSB7XG4gIGZ1bmN0aW9uOiBDaGF0Q29tcGxldGlvbk5hbWVkVG9vbENob2ljZS5GdW5jdGlvbjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wuIEN1cnJlbnRseSwgb25seSBgZnVuY3Rpb25gIGlzIHN1cHBvcnRlZC5cbiAgICovXG4gIHR5cGU6ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdENvbXBsZXRpb25OYW1lZFRvb2xDaG9pY2Uge1xuICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBTdGF0aWMgcHJlZGljdGVkIG91dHB1dCBjb250ZW50LCBzdWNoIGFzIHRoZSBjb250ZW50IG9mIGEgdGV4dCBmaWxlIHRoYXQgaXNcbiAqIGJlaW5nIHJlZ2VuZXJhdGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uUHJlZGljdGlvbkNvbnRlbnQge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnQgdGhhdCBzaG91bGQgYmUgbWF0Y2hlZCB3aGVuIGdlbmVyYXRpbmcgYSBtb2RlbCByZXNwb25zZS4gSWZcbiAgICogZ2VuZXJhdGVkIHRva2VucyB3b3VsZCBtYXRjaCB0aGlzIGNvbnRlbnQsIHRoZSBlbnRpcmUgbW9kZWwgcmVzcG9uc2UgY2FuIGJlXG4gICAqIHJldHVybmVkIG11Y2ggbW9yZSBxdWlja2x5LlxuICAgKi9cbiAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8Q2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgcHJlZGljdGVkIGNvbnRlbnQgeW91IHdhbnQgdG8gcHJvdmlkZS4gVGhpcyB0eXBlIGlzIGN1cnJlbnRseVxuICAgKiBhbHdheXMgYGNvbnRlbnRgLlxuICAgKi9cbiAgdHlwZTogJ2NvbnRlbnQnO1xufVxuXG4vKipcbiAqICoqbzEgbW9kZWxzIG9ubHkqKlxuICpcbiAqIENvbnN0cmFpbnMgZWZmb3J0IG9uIHJlYXNvbmluZyBmb3JcbiAqIFtyZWFzb25pbmcgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvcmVhc29uaW5nKS4gQ3VycmVudGx5XG4gKiBzdXBwb3J0ZWQgdmFsdWVzIGFyZSBgbG93YCwgYG1lZGl1bWAsIGFuZCBgaGlnaGAuIFJlZHVjaW5nIHJlYXNvbmluZyBlZmZvcnQgY2FuXG4gKiByZXN1bHQgaW4gZmFzdGVyIHJlc3BvbnNlcyBhbmQgZmV3ZXIgdG9rZW5zIHVzZWQgb24gcmVhc29uaW5nIGluIGEgcmVzcG9uc2UuXG4gKi9cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uUmVhc29uaW5nRWZmb3J0ID0gJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJztcblxuLyoqXG4gKiBUaGUgcm9sZSBvZiB0aGUgYXV0aG9yIG9mIGEgbWVzc2FnZVxuICovXG5leHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvblJvbGUgPSAnc3lzdGVtJyB8ICd1c2VyJyB8ICdhc3Npc3RhbnQnIHwgJ3Rvb2wnIHwgJ2Z1bmN0aW9uJztcblxuLyoqXG4gKiBPcHRpb25zIGZvciBzdHJlYW1pbmcgcmVzcG9uc2UuIE9ubHkgc2V0IHRoaXMgd2hlbiB5b3Ugc2V0IGBzdHJlYW06IHRydWVgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uU3RyZWFtT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBJZiBzZXQsIGFuIGFkZGl0aW9uYWwgY2h1bmsgd2lsbCBiZSBzdHJlYW1lZCBiZWZvcmUgdGhlIGBkYXRhOiBbRE9ORV1gIG1lc3NhZ2UuXG4gICAqIFRoZSBgdXNhZ2VgIGZpZWxkIG9uIHRoaXMgY2h1bmsgc2hvd3MgdGhlIHRva2VuIHVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBlbnRpcmVcbiAgICogcmVxdWVzdCwgYW5kIHRoZSBgY2hvaWNlc2AgZmllbGQgd2lsbCBhbHdheXMgYmUgYW4gZW1wdHkgYXJyYXkuIEFsbCBvdGhlciBjaHVua3NcbiAgICogd2lsbCBhbHNvIGluY2x1ZGUgYSBgdXNhZ2VgIGZpZWxkLCBidXQgd2l0aCBhIG51bGwgdmFsdWUuXG4gICAqL1xuICBpbmNsdWRlX3VzYWdlPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBEZXZlbG9wZXItcHJvdmlkZWQgaW5zdHJ1Y3Rpb25zIHRoYXQgdGhlIG1vZGVsIHNob3VsZCBmb2xsb3csIHJlZ2FyZGxlc3Mgb2ZcbiAqIG1lc3NhZ2VzIHNlbnQgYnkgdGhlIHVzZXIuIFdpdGggbzEgbW9kZWxzIGFuZCBuZXdlciwgdXNlIGBkZXZlbG9wZXJgIG1lc3NhZ2VzXG4gKiBmb3IgdGhpcyBwdXJwb3NlIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25TeXN0ZW1NZXNzYWdlUGFyYW0ge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSBzeXN0ZW0gbWVzc2FnZS5cbiAgICovXG4gIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0PjtcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIG1lc3NhZ2VzIGF1dGhvciwgaW4gdGhpcyBjYXNlIGBzeXN0ZW1gLlxuICAgKi9cbiAgcm9sZTogJ3N5c3RlbSc7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIG5hbWUgZm9yIHRoZSBwYXJ0aWNpcGFudC4gUHJvdmlkZXMgdGhlIG1vZGVsIGluZm9ybWF0aW9uIHRvXG4gICAqIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBwYXJ0aWNpcGFudHMgb2YgdGhlIHNhbWUgcm9sZS5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2Ige1xuICAvKipcbiAgICogVGhlIHRva2VuLlxuICAgKi9cbiAgdG9rZW46IHN0cmluZztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGludGVnZXJzIHJlcHJlc2VudGluZyB0aGUgVVRGLTggYnl0ZXMgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRva2VuLlxuICAgKiBVc2VmdWwgaW4gaW5zdGFuY2VzIHdoZXJlIGNoYXJhY3RlcnMgYXJlIHJlcHJlc2VudGVkIGJ5IG11bHRpcGxlIHRva2VucyBhbmRcbiAgICogdGhlaXIgYnl0ZSByZXByZXNlbnRhdGlvbnMgbXVzdCBiZSBjb21iaW5lZCB0byBnZW5lcmF0ZSB0aGUgY29ycmVjdCB0ZXh0XG4gICAqIHJlcHJlc2VudGF0aW9uLiBDYW4gYmUgYG51bGxgIGlmIHRoZXJlIGlzIG5vIGJ5dGVzIHJlcHJlc2VudGF0aW9uIGZvciB0aGUgdG9rZW4uXG4gICAqL1xuICBieXRlczogQXJyYXk8bnVtYmVyPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBsb2cgcHJvYmFiaWxpdHkgb2YgdGhpcyB0b2tlbiwgaWYgaXQgaXMgd2l0aGluIHRoZSB0b3AgMjAgbW9zdCBsaWtlbHlcbiAgICogdG9rZW5zLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBgLTk5OTkuMGAgaXMgdXNlZCB0byBzaWduaWZ5IHRoYXQgdGhlIHRva2VuIGlzIHZlcnlcbiAgICogdW5saWtlbHkuXG4gICAqL1xuICBsb2dwcm9iOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgdGhlIG1vc3QgbGlrZWx5IHRva2VucyBhbmQgdGhlaXIgbG9nIHByb2JhYmlsaXR5LCBhdCB0aGlzIHRva2VuXG4gICAqIHBvc2l0aW9uLiBJbiByYXJlIGNhc2VzLCB0aGVyZSBtYXkgYmUgZmV3ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHJlcXVlc3RlZFxuICAgKiBgdG9wX2xvZ3Byb2JzYCByZXR1cm5lZC5cbiAgICovXG4gIHRvcF9sb2dwcm9iczogQXJyYXk8Q2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2IuVG9wTG9ncHJvYj47XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2Ige1xuICBleHBvcnQgaW50ZXJmYWNlIFRvcExvZ3Byb2Ige1xuICAgIC8qKlxuICAgICAqIFRoZSB0b2tlbi5cbiAgICAgKi9cbiAgICB0b2tlbjogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGludGVnZXJzIHJlcHJlc2VudGluZyB0aGUgVVRGLTggYnl0ZXMgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRva2VuLlxuICAgICAqIFVzZWZ1bCBpbiBpbnN0YW5jZXMgd2hlcmUgY2hhcmFjdGVycyBhcmUgcmVwcmVzZW50ZWQgYnkgbXVsdGlwbGUgdG9rZW5zIGFuZFxuICAgICAqIHRoZWlyIGJ5dGUgcmVwcmVzZW50YXRpb25zIG11c3QgYmUgY29tYmluZWQgdG8gZ2VuZXJhdGUgdGhlIGNvcnJlY3QgdGV4dFxuICAgICAqIHJlcHJlc2VudGF0aW9uLiBDYW4gYmUgYG51bGxgIGlmIHRoZXJlIGlzIG5vIGJ5dGVzIHJlcHJlc2VudGF0aW9uIGZvciB0aGUgdG9rZW4uXG4gICAgICovXG4gICAgYnl0ZXM6IEFycmF5PG51bWJlcj4gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvZyBwcm9iYWJpbGl0eSBvZiB0aGlzIHRva2VuLCBpZiBpdCBpcyB3aXRoaW4gdGhlIHRvcCAyMCBtb3N0IGxpa2VseVxuICAgICAqIHRva2Vucy4gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgYC05OTk5LjBgIGlzIHVzZWQgdG8gc2lnbmlmeSB0aGF0IHRoZSB0b2tlbiBpcyB2ZXJ5XG4gICAgICogdW5saWtlbHkuXG4gICAgICovXG4gICAgbG9ncHJvYjogbnVtYmVyO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25Ub29sIHtcbiAgZnVuY3Rpb246IFNoYXJlZC5GdW5jdGlvbkRlZmluaXRpb247XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSB0b29sLiBDdXJyZW50bHksIG9ubHkgYGZ1bmN0aW9uYCBpcyBzdXBwb3J0ZWQuXG4gICAqL1xuICB0eXBlOiAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIENvbnRyb2xzIHdoaWNoIChpZiBhbnkpIHRvb2wgaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC4gYG5vbmVgIG1lYW5zIHRoZSBtb2RlbCB3aWxsXG4gKiBub3QgY2FsbCBhbnkgdG9vbCBhbmQgaW5zdGVhZCBnZW5lcmF0ZXMgYSBtZXNzYWdlLiBgYXV0b2AgbWVhbnMgdGhlIG1vZGVsIGNhblxuICogcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yIGNhbGxpbmcgb25lIG9yIG1vcmUgdG9vbHMuIGByZXF1aXJlZGAgbWVhbnNcbiAqIHRoZSBtb2RlbCBtdXN0IGNhbGwgb25lIG9yIG1vcmUgdG9vbHMuIFNwZWNpZnlpbmcgYSBwYXJ0aWN1bGFyIHRvb2wgdmlhXG4gKiBge1widHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIm15X2Z1bmN0aW9uXCJ9fWAgZm9yY2VzIHRoZSBtb2RlbCB0b1xuICogY2FsbCB0aGF0IHRvb2wuXG4gKlxuICogYG5vbmVgIGlzIHRoZSBkZWZhdWx0IHdoZW4gbm8gdG9vbHMgYXJlIHByZXNlbnQuIGBhdXRvYCBpcyB0aGUgZGVmYXVsdCBpZiB0b29sc1xuICogYXJlIHByZXNlbnQuXG4gKi9cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uVG9vbENob2ljZU9wdGlvbiA9ICdub25lJyB8ICdhdXRvJyB8ICdyZXF1aXJlZCcgfCBDaGF0Q29tcGxldGlvbk5hbWVkVG9vbENob2ljZTtcblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvblRvb2xNZXNzYWdlUGFyYW0ge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSB0b29sIG1lc3NhZ2UuXG4gICAqL1xuICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dD47XG5cbiAgLyoqXG4gICAqIFRoZSByb2xlIG9mIHRoZSBtZXNzYWdlcyBhdXRob3IsIGluIHRoaXMgY2FzZSBgdG9vbGAuXG4gICAqL1xuICByb2xlOiAndG9vbCc7XG5cbiAgLyoqXG4gICAqIFRvb2wgY2FsbCB0aGF0IHRoaXMgbWVzc2FnZSBpcyByZXNwb25kaW5nIHRvLlxuICAgKi9cbiAgdG9vbF9jYWxsX2lkOiBzdHJpbmc7XG59XG5cbi8qKlxuICogTWVzc2FnZXMgc2VudCBieSBhbiBlbmQgdXNlciwgY29udGFpbmluZyBwcm9tcHRzIG9yIGFkZGl0aW9uYWwgY29udGV4dFxuICogaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25Vc2VyTWVzc2FnZVBhcmFtIHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgdXNlciBtZXNzYWdlLlxuICAgKi9cbiAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8Q2hhdENvbXBsZXRpb25Db250ZW50UGFydD47XG5cbiAgLyoqXG4gICAqIFRoZSByb2xlIG9mIHRoZSBtZXNzYWdlcyBhdXRob3IsIGluIHRoaXMgY2FzZSBgdXNlcmAuXG4gICAqL1xuICByb2xlOiAndXNlcic7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIG5hbWUgZm9yIHRoZSBwYXJ0aWNpcGFudC4gUHJvdmlkZXMgdGhlIG1vZGVsIGluZm9ybWF0aW9uIHRvXG4gICAqIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBwYXJ0aWNpcGFudHMgb2YgdGhlIHNhbWUgcm9sZS5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0gc2hvdWxkIGJlIHVzZWQgaW5zdGVhZFxuICovXG5leHBvcnQgdHlwZSBDcmVhdGVDaGF0Q29tcGxldGlvblJlcXVlc3RNZXNzYWdlID0gQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW07XG5cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zID1cbiAgfCBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZ1xuICB8IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgbWVzc2FnZXMgY29tcHJpc2luZyB0aGUgY29udmVyc2F0aW9uIHNvIGZhci4gRGVwZW5kaW5nIG9uIHRoZVxuICAgKiBbbW9kZWxdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscykgeW91IHVzZSwgZGlmZmVyZW50IG1lc3NhZ2VcbiAgICogdHlwZXMgKG1vZGFsaXRpZXMpIGFyZSBzdXBwb3J0ZWQsIGxpa2VcbiAgICogW3RleHRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy90ZXh0LWdlbmVyYXRpb24pLFxuICAgKiBbaW1hZ2VzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvdmlzaW9uKSwgYW5kXG4gICAqIFthdWRpb10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2F1ZGlvKS5cbiAgICovXG4gIG1lc3NhZ2VzOiBBcnJheTxDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbT47XG5cbiAgLyoqXG4gICAqIElEIG9mIHRoZSBtb2RlbCB0byB1c2UuIFNlZSB0aGVcbiAgICogW21vZGVsIGVuZHBvaW50IGNvbXBhdGliaWxpdHldKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNtb2RlbC1lbmRwb2ludC1jb21wYXRpYmlsaXR5KVxuICAgKiB0YWJsZSBmb3IgZGV0YWlscyBvbiB3aGljaCBtb2RlbHMgd29yayB3aXRoIHRoZSBDaGF0IEFQSS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgQ2hhdEFQSS5DaGF0TW9kZWw7XG5cbiAgLyoqXG4gICAqIFBhcmFtZXRlcnMgZm9yIGF1ZGlvIG91dHB1dC4gUmVxdWlyZWQgd2hlbiBhdWRpbyBvdXRwdXQgaXMgcmVxdWVzdGVkIHdpdGhcbiAgICogYG1vZGFsaXRpZXM6IFtcImF1ZGlvXCJdYC5cbiAgICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9hdWRpbykuXG4gICAqL1xuICBhdWRpbz86IENoYXRDb21wbGV0aW9uQXVkaW9QYXJhbSB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE51bWJlciBiZXR3ZWVuIC0yLjAgYW5kIDIuMC4gUG9zaXRpdmUgdmFsdWVzIHBlbmFsaXplIG5ldyB0b2tlbnMgYmFzZWQgb24gdGhlaXJcbiAgICogZXhpc3RpbmcgZnJlcXVlbmN5IGluIHRoZSB0ZXh0IHNvIGZhciwgZGVjcmVhc2luZyB0aGUgbW9kZWwncyBsaWtlbGlob29kIHRvXG4gICAqIHJlcGVhdCB0aGUgc2FtZSBsaW5lIHZlcmJhdGltLlxuICAgKi9cbiAgZnJlcXVlbmN5X3BlbmFsdHk/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIGluIGZhdm9yIG9mIGB0b29sX2Nob2ljZWAuXG4gICAqXG4gICAqIENvbnRyb2xzIHdoaWNoIChpZiBhbnkpIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSB0aGUgbW9kZWwuXG4gICAqXG4gICAqIGBub25lYCBtZWFucyB0aGUgbW9kZWwgd2lsbCBub3QgY2FsbCBhIGZ1bmN0aW9uIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuXG4gICAqXG4gICAqIGBhdXRvYCBtZWFucyB0aGUgbW9kZWwgY2FuIHBpY2sgYmV0d2VlbiBnZW5lcmF0aW5nIGEgbWVzc2FnZSBvciBjYWxsaW5nIGFcbiAgICogZnVuY3Rpb24uXG4gICAqXG4gICAqIFNwZWNpZnlpbmcgYSBwYXJ0aWN1bGFyIGZ1bmN0aW9uIHZpYSBge1wibmFtZVwiOiBcIm15X2Z1bmN0aW9uXCJ9YCBmb3JjZXMgdGhlIG1vZGVsXG4gICAqIHRvIGNhbGwgdGhhdCBmdW5jdGlvbi5cbiAgICpcbiAgICogYG5vbmVgIGlzIHRoZSBkZWZhdWx0IHdoZW4gbm8gZnVuY3Rpb25zIGFyZSBwcmVzZW50LiBgYXV0b2AgaXMgdGhlIGRlZmF1bHQgaWZcbiAgICogZnVuY3Rpb25zIGFyZSBwcmVzZW50LlxuICAgKi9cbiAgZnVuY3Rpb25fY2FsbD86ICdub25lJyB8ICdhdXRvJyB8IENoYXRDb21wbGV0aW9uRnVuY3Rpb25DYWxsT3B0aW9uO1xuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIGluIGZhdm9yIG9mIGB0b29sc2AuXG4gICAqXG4gICAqIEEgbGlzdCBvZiBmdW5jdGlvbnMgdGhlIG1vZGVsIG1heSBnZW5lcmF0ZSBKU09OIGlucHV0cyBmb3IuXG4gICAqL1xuICBmdW5jdGlvbnM/OiBBcnJheTxDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcy5GdW5jdGlvbj47XG5cbiAgLyoqXG4gICAqIE1vZGlmeSB0aGUgbGlrZWxpaG9vZCBvZiBzcGVjaWZpZWQgdG9rZW5zIGFwcGVhcmluZyBpbiB0aGUgY29tcGxldGlvbi5cbiAgICpcbiAgICogQWNjZXB0cyBhIEpTT04gb2JqZWN0IHRoYXQgbWFwcyB0b2tlbnMgKHNwZWNpZmllZCBieSB0aGVpciB0b2tlbiBJRCBpbiB0aGVcbiAgICogdG9rZW5pemVyKSB0byBhbiBhc3NvY2lhdGVkIGJpYXMgdmFsdWUgZnJvbSAtMTAwIHRvIDEwMC4gTWF0aGVtYXRpY2FsbHksIHRoZVxuICAgKiBiaWFzIGlzIGFkZGVkIHRvIHRoZSBsb2dpdHMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBwcmlvciB0byBzYW1wbGluZy4gVGhlIGV4YWN0XG4gICAqIGVmZmVjdCB3aWxsIHZhcnkgcGVyIG1vZGVsLCBidXQgdmFsdWVzIGJldHdlZW4gLTEgYW5kIDEgc2hvdWxkIGRlY3JlYXNlIG9yXG4gICAqIGluY3JlYXNlIGxpa2VsaWhvb2Qgb2Ygc2VsZWN0aW9uOyB2YWx1ZXMgbGlrZSAtMTAwIG9yIDEwMCBzaG91bGQgcmVzdWx0IGluIGEgYmFuXG4gICAqIG9yIGV4Y2x1c2l2ZSBzZWxlY3Rpb24gb2YgdGhlIHJlbGV2YW50IHRva2VuLlxuICAgKi9cbiAgbG9naXRfYmlhcz86IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJldHVybiBsb2cgcHJvYmFiaWxpdGllcyBvZiB0aGUgb3V0cHV0IHRva2VucyBvciBub3QuIElmIHRydWUsXG4gICAqIHJldHVybnMgdGhlIGxvZyBwcm9iYWJpbGl0aWVzIG9mIGVhY2ggb3V0cHV0IHRva2VuIHJldHVybmVkIGluIHRoZSBgY29udGVudGAgb2ZcbiAgICogYG1lc3NhZ2VgLlxuICAgKi9cbiAgbG9ncHJvYnM/OiBib29sZWFuIHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gdXBwZXIgYm91bmQgZm9yIHRoZSBudW1iZXIgb2YgdG9rZW5zIHRoYXQgY2FuIGJlIGdlbmVyYXRlZCBmb3IgYSBjb21wbGV0aW9uLFxuICAgKiBpbmNsdWRpbmcgdmlzaWJsZSBvdXRwdXQgdG9rZW5zIGFuZFxuICAgKiBbcmVhc29uaW5nIHRva2Vuc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3JlYXNvbmluZykuXG4gICAqL1xuICBtYXhfY29tcGxldGlvbl90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgW3Rva2Vuc10oL3Rva2VuaXplcikgdGhhdCBjYW4gYmUgZ2VuZXJhdGVkIGluIHRoZSBjaGF0XG4gICAqIGNvbXBsZXRpb24uIFRoaXMgdmFsdWUgY2FuIGJlIHVzZWQgdG8gY29udHJvbFxuICAgKiBbY29zdHNdKGh0dHBzOi8vb3BlbmFpLmNvbS9hcGkvcHJpY2luZy8pIGZvciB0ZXh0IGdlbmVyYXRlZCB2aWEgQVBJLlxuICAgKlxuICAgKiBUaGlzIHZhbHVlIGlzIG5vdyBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGBtYXhfY29tcGxldGlvbl90b2tlbnNgLCBhbmQgaXMgbm90XG4gICAqIGNvbXBhdGlibGUgd2l0aFxuICAgKiBbbzEgc2VyaWVzIG1vZGVsc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3JlYXNvbmluZykuXG4gICAqL1xuICBtYXhfdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogRGV2ZWxvcGVyLWRlZmluZWQgdGFncyBhbmQgdmFsdWVzIHVzZWQgZm9yIGZpbHRlcmluZyBjb21wbGV0aW9ucyBpbiB0aGVcbiAgICogW2Rhc2hib2FyZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2NoYXQtY29tcGxldGlvbnMpLlxuICAgKi9cbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgbnVsbDtcblxuICAvKipcbiAgICogT3V0cHV0IHR5cGVzIHRoYXQgeW91IHdvdWxkIGxpa2UgdGhlIG1vZGVsIHRvIGdlbmVyYXRlIGZvciB0aGlzIHJlcXVlc3QuIE1vc3RcbiAgICogbW9kZWxzIGFyZSBjYXBhYmxlIG9mIGdlbmVyYXRpbmcgdGV4dCwgd2hpY2ggaXMgdGhlIGRlZmF1bHQ6XG4gICAqXG4gICAqIGBbXCJ0ZXh0XCJdYFxuICAgKlxuICAgKiBUaGUgYGdwdC00by1hdWRpby1wcmV2aWV3YCBtb2RlbCBjYW4gYWxzbyBiZSB1c2VkIHRvXG4gICAqIFtnZW5lcmF0ZSBhdWRpb10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2F1ZGlvKS4gVG8gcmVxdWVzdCB0aGF0XG4gICAqIHRoaXMgbW9kZWwgZ2VuZXJhdGUgYm90aCB0ZXh0IGFuZCBhdWRpbyByZXNwb25zZXMsIHlvdSBjYW4gdXNlOlxuICAgKlxuICAgKiBgW1widGV4dFwiLCBcImF1ZGlvXCJdYFxuICAgKi9cbiAgbW9kYWxpdGllcz86IEFycmF5PENoYXRDb21wbGV0aW9uTW9kYWxpdHk+IHwgbnVsbDtcblxuICAvKipcbiAgICogSG93IG1hbnkgY2hhdCBjb21wbGV0aW9uIGNob2ljZXMgdG8gZ2VuZXJhdGUgZm9yIGVhY2ggaW5wdXQgbWVzc2FnZS4gTm90ZSB0aGF0XG4gICAqIHlvdSB3aWxsIGJlIGNoYXJnZWQgYmFzZWQgb24gdGhlIG51bWJlciBvZiBnZW5lcmF0ZWQgdG9rZW5zIGFjcm9zcyBhbGwgb2YgdGhlXG4gICAqIGNob2ljZXMuIEtlZXAgYG5gIGFzIGAxYCB0byBtaW5pbWl6ZSBjb3N0cy5cbiAgICovXG4gIG4/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZVxuICAgKiBbcGFyYWxsZWwgZnVuY3Rpb24gY2FsbGluZ10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2Z1bmN0aW9uLWNhbGxpbmcjY29uZmlndXJpbmctcGFyYWxsZWwtZnVuY3Rpb24tY2FsbGluZylcbiAgICogZHVyaW5nIHRvb2wgdXNlLlxuICAgKi9cbiAgcGFyYWxsZWxfdG9vbF9jYWxscz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBwcmVkaWN0ZWQgb3V0cHV0IGNvbnRlbnQsIHN1Y2ggYXMgdGhlIGNvbnRlbnQgb2YgYSB0ZXh0IGZpbGUgdGhhdCBpc1xuICAgKiBiZWluZyByZWdlbmVyYXRlZC5cbiAgICovXG4gIHByZWRpY3Rpb24/OiBDaGF0Q29tcGxldGlvblByZWRpY3Rpb25Db250ZW50IHwgbnVsbDtcblxuICAvKipcbiAgICogTnVtYmVyIGJldHdlZW4gLTIuMCBhbmQgMi4wLiBQb3NpdGl2ZSB2YWx1ZXMgcGVuYWxpemUgbmV3IHRva2VucyBiYXNlZCBvblxuICAgKiB3aGV0aGVyIHRoZXkgYXBwZWFyIGluIHRoZSB0ZXh0IHNvIGZhciwgaW5jcmVhc2luZyB0aGUgbW9kZWwncyBsaWtlbGlob29kIHRvXG4gICAqIHRhbGsgYWJvdXQgbmV3IHRvcGljcy5cbiAgICovXG4gIHByZXNlbmNlX3BlbmFsdHk/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiAqKm8xIG1vZGVscyBvbmx5KipcbiAgICpcbiAgICogQ29uc3RyYWlucyBlZmZvcnQgb24gcmVhc29uaW5nIGZvclxuICAgKiBbcmVhc29uaW5nIG1vZGVsc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3JlYXNvbmluZykuIEN1cnJlbnRseVxuICAgKiBzdXBwb3J0ZWQgdmFsdWVzIGFyZSBgbG93YCwgYG1lZGl1bWAsIGFuZCBgaGlnaGAuIFJlZHVjaW5nIHJlYXNvbmluZyBlZmZvcnQgY2FuXG4gICAqIHJlc3VsdCBpbiBmYXN0ZXIgcmVzcG9uc2VzIGFuZCBmZXdlciB0b2tlbnMgdXNlZCBvbiByZWFzb25pbmcgaW4gYSByZXNwb25zZS5cbiAgICovXG4gIHJlYXNvbmluZ19lZmZvcnQ/OiBDaGF0Q29tcGxldGlvblJlYXNvbmluZ0VmZm9ydDtcblxuICAvKipcbiAgICogQW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX3NjaGVtYVwiLCBcImpzb25fc2NoZW1hXCI6IHsuLi59IH1gIGVuYWJsZXMgU3RydWN0dXJlZFxuICAgKiBPdXRwdXRzIHdoaWNoIGVuc3VyZXMgdGhlIG1vZGVsIHdpbGwgbWF0Y2ggeW91ciBzdXBwbGllZCBKU09OIHNjaGVtYS4gTGVhcm4gbW9yZVxuICAgKiBpbiB0aGVcbiAgICogW1N0cnVjdHVyZWQgT3V0cHV0cyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3N0cnVjdHVyZWQtb3V0cHV0cykuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9vYmplY3RcIiB9YCBlbmFibGVzIEpTT04gbW9kZSwgd2hpY2ggZW5zdXJlcyB0aGVcbiAgICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gICAqXG4gICAqICoqSW1wb3J0YW50OioqIHdoZW4gdXNpbmcgSlNPTiBtb2RlLCB5b3UgKiptdXN0KiogYWxzbyBpbnN0cnVjdCB0aGUgbW9kZWwgdG9cbiAgICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICAgKiBnZW5lcmF0ZSBhbiB1bmVuZGluZyBzdHJlYW0gb2Ygd2hpdGVzcGFjZSB1bnRpbCB0aGUgZ2VuZXJhdGlvbiByZWFjaGVzIHRoZSB0b2tlblxuICAgKiBsaW1pdCwgcmVzdWx0aW5nIGluIGEgbG9uZy1ydW5uaW5nIGFuZCBzZWVtaW5nbHkgXCJzdHVja1wiIHJlcXVlc3QuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICAgKiBpbmRpY2F0ZXMgdGhlIGdlbmVyYXRpb24gZXhjZWVkZWQgYG1heF90b2tlbnNgIG9yIHRoZSBjb252ZXJzYXRpb24gZXhjZWVkZWQgdGhlXG4gICAqIG1heCBjb250ZXh0IGxlbmd0aC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86XG4gICAgfCBTaGFyZWQuUmVzcG9uc2VGb3JtYXRUZXh0XG4gICAgfCBTaGFyZWQuUmVzcG9uc2VGb3JtYXRKU09OT2JqZWN0XG4gICAgfCBTaGFyZWQuUmVzcG9uc2VGb3JtYXRKU09OU2NoZW1hO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZlYXR1cmUgaXMgaW4gQmV0YS4gSWYgc3BlY2lmaWVkLCBvdXIgc3lzdGVtIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvXG4gICAqIHNhbXBsZSBkZXRlcm1pbmlzdGljYWxseSwgc3VjaCB0aGF0IHJlcGVhdGVkIHJlcXVlc3RzIHdpdGggdGhlIHNhbWUgYHNlZWRgIGFuZFxuICAgKiBwYXJhbWV0ZXJzIHNob3VsZCByZXR1cm4gdGhlIHNhbWUgcmVzdWx0LiBEZXRlcm1pbmlzbSBpcyBub3QgZ3VhcmFudGVlZCwgYW5kIHlvdVxuICAgKiBzaG91bGQgcmVmZXIgdG8gdGhlIGBzeXN0ZW1fZmluZ2VycHJpbnRgIHJlc3BvbnNlIHBhcmFtZXRlciB0byBtb25pdG9yIGNoYW5nZXNcbiAgICogaW4gdGhlIGJhY2tlbmQuXG4gICAqL1xuICBzZWVkPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBsYXRlbmN5IHRpZXIgdG8gdXNlIGZvciBwcm9jZXNzaW5nIHRoZSByZXF1ZXN0LiBUaGlzIHBhcmFtZXRlciBpc1xuICAgKiByZWxldmFudCBmb3IgY3VzdG9tZXJzIHN1YnNjcmliZWQgdG8gdGhlIHNjYWxlIHRpZXIgc2VydmljZTpcbiAgICpcbiAgICogLSBJZiBzZXQgdG8gJ2F1dG8nLCBhbmQgdGhlIFByb2plY3QgaXMgU2NhbGUgdGllciBlbmFibGVkLCB0aGUgc3lzdGVtIHdpbGxcbiAgICogICB1dGlsaXplIHNjYWxlIHRpZXIgY3JlZGl0cyB1bnRpbCB0aGV5IGFyZSBleGhhdXN0ZWQuXG4gICAqIC0gSWYgc2V0IHRvICdhdXRvJywgYW5kIHRoZSBQcm9qZWN0IGlzIG5vdCBTY2FsZSB0aWVyIGVuYWJsZWQsIHRoZSByZXF1ZXN0IHdpbGxcbiAgICogICBiZSBwcm9jZXNzZWQgdXNpbmcgdGhlIGRlZmF1bHQgc2VydmljZSB0aWVyIHdpdGggYSBsb3dlciB1cHRpbWUgU0xBIGFuZCBub1xuICAgKiAgIGxhdGVuY3kgZ3VhcmVudGVlLlxuICAgKiAtIElmIHNldCB0byAnZGVmYXVsdCcsIHRoZSByZXF1ZXN0IHdpbGwgYmUgcHJvY2Vzc2VkIHVzaW5nIHRoZSBkZWZhdWx0IHNlcnZpY2VcbiAgICogICB0aWVyIHdpdGggYSBsb3dlciB1cHRpbWUgU0xBIGFuZCBubyBsYXRlbmN5IGd1YXJlbnRlZS5cbiAgICogLSBXaGVuIG5vdCBzZXQsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzICdhdXRvJy5cbiAgICpcbiAgICogV2hlbiB0aGlzIHBhcmFtZXRlciBpcyBzZXQsIHRoZSByZXNwb25zZSBib2R5IHdpbGwgaW5jbHVkZSB0aGUgYHNlcnZpY2VfdGllcmBcbiAgICogdXRpbGl6ZWQuXG4gICAqL1xuICBzZXJ2aWNlX3RpZXI/OiAnYXV0bycgfCAnZGVmYXVsdCcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBVcCB0byA0IHNlcXVlbmNlcyB3aGVyZSB0aGUgQVBJIHdpbGwgc3RvcCBnZW5lcmF0aW5nIGZ1cnRoZXIgdG9rZW5zLlxuICAgKi9cbiAgc3RvcD86IHN0cmluZyB8IG51bGwgfCBBcnJheTxzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0byBzdG9yZSB0aGUgb3V0cHV0IG9mIHRoaXMgY2hhdCBjb21wbGV0aW9uIHJlcXVlc3QgZm9yIHVzZSBpblxuICAgKiBvdXIgW21vZGVsIGRpc3RpbGxhdGlvbl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2Rpc3RpbGxhdGlvbilcbiAgICogb3IgW2V2YWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZXZhbHMpIHByb2R1Y3RzLlxuICAgKi9cbiAgc3RvcmU/OiBib29sZWFuIHwgbnVsbDtcblxuICAvKipcbiAgICogSWYgc2V0LCBwYXJ0aWFsIG1lc3NhZ2UgZGVsdGFzIHdpbGwgYmUgc2VudCwgbGlrZSBpbiBDaGF0R1BULiBUb2tlbnMgd2lsbCBiZVxuICAgKiBzZW50IGFzIGRhdGEtb25seVxuICAgKiBbc2VydmVyLXNlbnQgZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmVyLXNlbnRfZXZlbnRzL1VzaW5nX3NlcnZlci1zZW50X2V2ZW50cyNFdmVudF9zdHJlYW1fZm9ybWF0KVxuICAgKiBhcyB0aGV5IGJlY29tZSBhdmFpbGFibGUsIHdpdGggdGhlIHN0cmVhbSB0ZXJtaW5hdGVkIGJ5IGEgYGRhdGE6IFtET05FXWBcbiAgICogbWVzc2FnZS5cbiAgICogW0V4YW1wbGUgUHl0aG9uIGNvZGVdKGh0dHBzOi8vY29va2Jvb2sub3BlbmFpLmNvbS9leGFtcGxlcy9ob3dfdG9fc3RyZWFtX2NvbXBsZXRpb25zKS5cbiAgICovXG4gIHN0cmVhbT86IGJvb2xlYW4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciBzdHJlYW1pbmcgcmVzcG9uc2UuIE9ubHkgc2V0IHRoaXMgd2hlbiB5b3Ugc2V0IGBzdHJlYW06IHRydWVgLlxuICAgKi9cbiAgc3RyZWFtX29wdGlvbnM/OiBDaGF0Q29tcGxldGlvblN0cmVhbU9wdGlvbnMgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy4gV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIGB0b3BfcGAgYnV0XG4gICAqIG5vdCBib3RoLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyB3aGljaCAoaWYgYW55KSB0b29sIGlzIGNhbGxlZCBieSB0aGUgbW9kZWwuIGBub25lYCBtZWFucyB0aGUgbW9kZWwgd2lsbFxuICAgKiBub3QgY2FsbCBhbnkgdG9vbCBhbmQgaW5zdGVhZCBnZW5lcmF0ZXMgYSBtZXNzYWdlLiBgYXV0b2AgbWVhbnMgdGhlIG1vZGVsIGNhblxuICAgKiBwaWNrIGJldHdlZW4gZ2VuZXJhdGluZyBhIG1lc3NhZ2Ugb3IgY2FsbGluZyBvbmUgb3IgbW9yZSB0b29scy4gYHJlcXVpcmVkYCBtZWFuc1xuICAgKiB0aGUgbW9kZWwgbXVzdCBjYWxsIG9uZSBvciBtb3JlIHRvb2xzLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciB0b29sIHZpYVxuICAgKiBge1widHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIm15X2Z1bmN0aW9uXCJ9fWAgZm9yY2VzIHRoZSBtb2RlbCB0b1xuICAgKiBjYWxsIHRoYXQgdG9vbC5cbiAgICpcbiAgICogYG5vbmVgIGlzIHRoZSBkZWZhdWx0IHdoZW4gbm8gdG9vbHMgYXJlIHByZXNlbnQuIGBhdXRvYCBpcyB0aGUgZGVmYXVsdCBpZiB0b29sc1xuICAgKiBhcmUgcHJlc2VudC5cbiAgICovXG4gIHRvb2xfY2hvaWNlPzogQ2hhdENvbXBsZXRpb25Ub29sQ2hvaWNlT3B0aW9uO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdG9vbHMgdGhlIG1vZGVsIG1heSBjYWxsLiBDdXJyZW50bHksIG9ubHkgZnVuY3Rpb25zIGFyZSBzdXBwb3J0ZWQgYXMgYVxuICAgKiB0b29sLiBVc2UgdGhpcyB0byBwcm92aWRlIGEgbGlzdCBvZiBmdW5jdGlvbnMgdGhlIG1vZGVsIG1heSBnZW5lcmF0ZSBKU09OIGlucHV0c1xuICAgKiBmb3IuIEEgbWF4IG9mIDEyOCBmdW5jdGlvbnMgYXJlIHN1cHBvcnRlZC5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8Q2hhdENvbXBsZXRpb25Ub29sPjtcblxuICAvKipcbiAgICogQW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDIwIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBtb3N0IGxpa2VseSB0b2tlbnMgdG9cbiAgICogcmV0dXJuIGF0IGVhY2ggdG9rZW4gcG9zaXRpb24sIGVhY2ggd2l0aCBhbiBhc3NvY2lhdGVkIGxvZyBwcm9iYWJpbGl0eS5cbiAgICogYGxvZ3Byb2JzYCBtdXN0IGJlIHNldCB0byBgdHJ1ZWAgaWYgdGhpcyBwYXJhbWV0ZXIgaXMgdXNlZC5cbiAgICovXG4gIHRvcF9sb2dwcm9icz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEFuIGFsdGVybmF0aXZlIHRvIHNhbXBsaW5nIHdpdGggdGVtcGVyYXR1cmUsIGNhbGxlZCBudWNsZXVzIHNhbXBsaW5nLCB3aGVyZSB0aGVcbiAgICogbW9kZWwgY29uc2lkZXJzIHRoZSByZXN1bHRzIG9mIHRoZSB0b2tlbnMgd2l0aCB0b3BfcCBwcm9iYWJpbGl0eSBtYXNzLiBTbyAwLjFcbiAgICogbWVhbnMgb25seSB0aGUgdG9rZW5zIGNvbXByaXNpbmcgdGhlIHRvcCAxMCUgcHJvYmFiaWxpdHkgbWFzcyBhcmUgY29uc2lkZXJlZC5cbiAgICpcbiAgICogV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIGB0ZW1wZXJhdHVyZWAgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdG9wX3A/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIHJlcHJlc2VudGluZyB5b3VyIGVuZC11c2VyLCB3aGljaCBjYW4gaGVscCBPcGVuQUkgdG8gbW9uaXRvclxuICAgKiBhbmQgZGV0ZWN0IGFidXNlLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3NhZmV0eS1iZXN0LXByYWN0aWNlcyNlbmQtdXNlci1pZHMpLlxuICAgKi9cbiAgdXNlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC4gTXVzdCBiZSBhLXosIEEtWiwgMC05LCBvciBjb250YWluXG4gICAgICogdW5kZXJzY29yZXMgYW5kIGRhc2hlcywgd2l0aCBhIG1heGltdW0gbGVuZ3RoIG9mIDY0LlxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgZnVuY3Rpb24gZG9lcywgdXNlZCBieSB0aGUgbW9kZWwgdG8gY2hvb3NlIHdoZW4gYW5kXG4gICAgICogaG93IHRvIGNhbGwgdGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcmFtZXRlcnMgdGhlIGZ1bmN0aW9ucyBhY2NlcHRzLCBkZXNjcmliZWQgYXMgYSBKU09OIFNjaGVtYSBvYmplY3QuIFNlZSB0aGVcbiAgICAgKiBbZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9mdW5jdGlvbi1jYWxsaW5nKSBmb3IgZXhhbXBsZXMsXG4gICAgICogYW5kIHRoZVxuICAgICAqIFtKU09OIFNjaGVtYSByZWZlcmVuY2VdKGh0dHBzOi8vanNvbi1zY2hlbWEub3JnL3VuZGVyc3RhbmRpbmctanNvbi1zY2hlbWEvKSBmb3JcbiAgICAgKiBkb2N1bWVudGF0aW9uIGFib3V0IHRoZSBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBPbWl0dGluZyBgcGFyYW1ldGVyc2AgZGVmaW5lcyBhIGZ1bmN0aW9uIHdpdGggYW4gZW1wdHkgcGFyYW1ldGVyIGxpc3QuXG4gICAgICovXG4gICAgcGFyYW1ldGVycz86IFNoYXJlZC5GdW5jdGlvblBhcmFtZXRlcnM7XG4gIH1cblxuICBleHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyA9XG4gICAgQ2hhdENvbXBsZXRpb25zQVBJLkNoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nO1xuICBleHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyA9IENoYXRDb21wbGV0aW9uc0FQSS5DaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMgaW5zdGVhZFxuICovXG5leHBvcnQgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zID0gQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXM7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgZXh0ZW5kcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogSWYgc2V0LCBwYXJ0aWFsIG1lc3NhZ2UgZGVsdGFzIHdpbGwgYmUgc2VudCwgbGlrZSBpbiBDaGF0R1BULiBUb2tlbnMgd2lsbCBiZVxuICAgKiBzZW50IGFzIGRhdGEtb25seVxuICAgKiBbc2VydmVyLXNlbnQgZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmVyLXNlbnRfZXZlbnRzL1VzaW5nX3NlcnZlci1zZW50X2V2ZW50cyNFdmVudF9zdHJlYW1fZm9ybWF0KVxuICAgKiBhcyB0aGV5IGJlY29tZSBhdmFpbGFibGUsIHdpdGggdGhlIHN0cmVhbSB0ZXJtaW5hdGVkIGJ5IGEgYGRhdGE6IFtET05FXWBcbiAgICogbWVzc2FnZS5cbiAgICogW0V4YW1wbGUgUHl0aG9uIGNvZGVdKGh0dHBzOi8vY29va2Jvb2sub3BlbmFpLmNvbS9leGFtcGxlcy9ob3dfdG9fc3RyZWFtX2NvbXBsZXRpb25zKS5cbiAgICovXG4gIHN0cmVhbT86IGZhbHNlIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgaW5zdGVhZFxuICovXG5leHBvcnQgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nID0gQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgZXh0ZW5kcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogSWYgc2V0LCBwYXJ0aWFsIG1lc3NhZ2UgZGVsdGFzIHdpbGwgYmUgc2VudCwgbGlrZSBpbiBDaGF0R1BULiBUb2tlbnMgd2lsbCBiZVxuICAgKiBzZW50IGFzIGRhdGEtb25seVxuICAgKiBbc2VydmVyLXNlbnQgZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmVyLXNlbnRfZXZlbnRzL1VzaW5nX3NlcnZlci1zZW50X2V2ZW50cyNFdmVudF9zdHJlYW1fZm9ybWF0KVxuICAgKiBhcyB0aGV5IGJlY29tZSBhdmFpbGFibGUsIHdpdGggdGhlIHN0cmVhbSB0ZXJtaW5hdGVkIGJ5IGEgYGRhdGE6IFtET05FXWBcbiAgICogbWVzc2FnZS5cbiAgICogW0V4YW1wbGUgUHl0aG9uIGNvZGVdKGh0dHBzOi8vY29va2Jvb2sub3BlbmFpLmNvbS9leGFtcGxlcy9ob3dfdG9fc3RyZWFtX2NvbXBsZXRpb25zKS5cbiAgICovXG4gIHN0cmVhbTogdHJ1ZTtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgaW5zdGVhZFxuICovXG5leHBvcnQgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nID0gQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmc7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBDb21wbGV0aW9ucyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbiBhcyBDaGF0Q29tcGxldGlvbixcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25BdWRpbyBhcyBDaGF0Q29tcGxldGlvbkF1ZGlvLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25BdWRpb1BhcmFtIGFzIENoYXRDb21wbGV0aW9uQXVkaW9QYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ2h1bmsgYXMgQ2hhdENvbXBsZXRpb25DaHVuayxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnQgYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbWFnZSBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2UsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW5wdXRBdWRpbyBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW5wdXRBdWRpbyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRSZWZ1c2FsIGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRSZWZ1c2FsLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQgYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkRldmVsb3Blck1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvbkRldmVsb3Blck1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uRnVuY3Rpb25DYWxsT3B0aW9uIGFzIENoYXRDb21wbGV0aW9uRnVuY3Rpb25DYWxsT3B0aW9uLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25GdW5jdGlvbk1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlIGFzIENoYXRDb21wbGV0aW9uTWVzc2FnZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwgYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk1vZGFsaXR5IGFzIENoYXRDb21wbGV0aW9uTW9kYWxpdHksXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk5hbWVkVG9vbENob2ljZSBhcyBDaGF0Q29tcGxldGlvbk5hbWVkVG9vbENob2ljZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uUHJlZGljdGlvbkNvbnRlbnQgYXMgQ2hhdENvbXBsZXRpb25QcmVkaWN0aW9uQ29udGVudCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uUmVhc29uaW5nRWZmb3J0IGFzIENoYXRDb21wbGV0aW9uUmVhc29uaW5nRWZmb3J0LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Sb2xlIGFzIENoYXRDb21wbGV0aW9uUm9sZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uU3RyZWFtT3B0aW9ucyBhcyBDaGF0Q29tcGxldGlvblN0cmVhbU9wdGlvbnMsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblN5c3RlbU1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvblN5c3RlbU1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iIGFzIENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sIGFzIENoYXRDb21wbGV0aW9uVG9vbCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVG9vbENob2ljZU9wdGlvbiBhcyBDaGF0Q29tcGxldGlvblRvb2xDaG9pY2VPcHRpb24sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblRvb2xNZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25Ub29sTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Vc2VyTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uVXNlck1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENyZWF0ZUNoYXRDb21wbGV0aW9uUmVxdWVzdE1lc3NhZ2UgYXMgQ3JlYXRlQ2hhdENvbXBsZXRpb25SZXF1ZXN0TWVzc2FnZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIGFzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyBhcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgYXMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGFzIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBhcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvbXBsZXRpb25zQVBJIGZyb20gJy4vY29tcGxldGlvbnMnO1xuaW1wb3J0IHtcbiAgQ2hhdENvbXBsZXRpb24sXG4gIENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtLFxuICBDaGF0Q29tcGxldGlvbkF1ZGlvLFxuICBDaGF0Q29tcGxldGlvbkF1ZGlvUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uQ2h1bmssXG4gIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnQsXG4gIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbWFnZSxcbiAgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydElucHV0QXVkaW8sXG4gIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRSZWZ1c2FsLFxuICBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dCxcbiAgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgQ2hhdENvbXBsZXRpb25EZXZlbG9wZXJNZXNzYWdlUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uRnVuY3Rpb25DYWxsT3B0aW9uLFxuICBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uTWVzc2FnZVBhcmFtLFxuICBDaGF0Q29tcGxldGlvbk1lc3NhZ2UsXG4gIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtLFxuICBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCxcbiAgQ2hhdENvbXBsZXRpb25Nb2RhbGl0eSxcbiAgQ2hhdENvbXBsZXRpb25OYW1lZFRvb2xDaG9pY2UsXG4gIENoYXRDb21wbGV0aW9uUHJlZGljdGlvbkNvbnRlbnQsXG4gIENoYXRDb21wbGV0aW9uUmVhc29uaW5nRWZmb3J0LFxuICBDaGF0Q29tcGxldGlvblJvbGUsXG4gIENoYXRDb21wbGV0aW9uU3RyZWFtT3B0aW9ucyxcbiAgQ2hhdENvbXBsZXRpb25TeXN0ZW1NZXNzYWdlUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iLFxuICBDaGF0Q29tcGxldGlvblRvb2wsXG4gIENoYXRDb21wbGV0aW9uVG9vbENob2ljZU9wdGlvbixcbiAgQ2hhdENvbXBsZXRpb25Ub29sTWVzc2FnZVBhcmFtLFxuICBDaGF0Q29tcGxldGlvblVzZXJNZXNzYWdlUGFyYW0sXG4gIENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gIENvbXBsZXRpb25zLFxuICBDcmVhdGVDaGF0Q29tcGxldGlvblJlcXVlc3RNZXNzYWdlLFxufSBmcm9tICcuL2NvbXBsZXRpb25zJztcblxuZXhwb3J0IGNsYXNzIENoYXQgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIGNvbXBsZXRpb25zOiBDb21wbGV0aW9uc0FQSS5Db21wbGV0aW9ucyA9IG5ldyBDb21wbGV0aW9uc0FQSS5Db21wbGV0aW9ucyh0aGlzLl9jbGllbnQpO1xufVxuXG5leHBvcnQgdHlwZSBDaGF0TW9kZWwgPVxuICB8ICdvMSdcbiAgfCAnbzEtMjAyNC0xMi0xNydcbiAgfCAnbzEtcHJldmlldydcbiAgfCAnbzEtcHJldmlldy0yMDI0LTA5LTEyJ1xuICB8ICdvMS1taW5pJ1xuICB8ICdvMS1taW5pLTIwMjQtMDktMTInXG4gIHwgJ2dwdC00bydcbiAgfCAnZ3B0LTRvLTIwMjQtMTEtMjAnXG4gIHwgJ2dwdC00by0yMDI0LTA4LTA2J1xuICB8ICdncHQtNG8tMjAyNC0wNS0xMydcbiAgfCAnZ3B0LTRvLWF1ZGlvLXByZXZpZXcnXG4gIHwgJ2dwdC00by1hdWRpby1wcmV2aWV3LTIwMjQtMTAtMDEnXG4gIHwgJ2dwdC00by1hdWRpby1wcmV2aWV3LTIwMjQtMTItMTcnXG4gIHwgJ2dwdC00by1taW5pLWF1ZGlvLXByZXZpZXcnXG4gIHwgJ2dwdC00by1taW5pLWF1ZGlvLXByZXZpZXctMjAyNC0xMi0xNydcbiAgfCAnY2hhdGdwdC00by1sYXRlc3QnXG4gIHwgJ2dwdC00by1taW5pJ1xuICB8ICdncHQtNG8tbWluaS0yMDI0LTA3LTE4J1xuICB8ICdncHQtNC10dXJibydcbiAgfCAnZ3B0LTQtdHVyYm8tMjAyNC0wNC0wOSdcbiAgfCAnZ3B0LTQtMDEyNS1wcmV2aWV3J1xuICB8ICdncHQtNC10dXJiby1wcmV2aWV3J1xuICB8ICdncHQtNC0xMTA2LXByZXZpZXcnXG4gIHwgJ2dwdC00LXZpc2lvbi1wcmV2aWV3J1xuICB8ICdncHQtNCdcbiAgfCAnZ3B0LTQtMDMxNCdcbiAgfCAnZ3B0LTQtMDYxMydcbiAgfCAnZ3B0LTQtMzJrJ1xuICB8ICdncHQtNC0zMmstMDMxNCdcbiAgfCAnZ3B0LTQtMzJrLTA2MTMnXG4gIHwgJ2dwdC0zLjUtdHVyYm8nXG4gIHwgJ2dwdC0zLjUtdHVyYm8tMTZrJ1xuICB8ICdncHQtMy41LXR1cmJvLTAzMDEnXG4gIHwgJ2dwdC0zLjUtdHVyYm8tMDYxMydcbiAgfCAnZ3B0LTMuNS10dXJiby0xMTA2J1xuICB8ICdncHQtMy41LXR1cmJvLTAxMjUnXG4gIHwgJ2dwdC0zLjUtdHVyYm8tMTZrLTA2MTMnO1xuXG5DaGF0LkNvbXBsZXRpb25zID0gQ29tcGxldGlvbnM7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBDaGF0IHtcbiAgZXhwb3J0IHsgdHlwZSBDaGF0TW9kZWwgYXMgQ2hhdE1vZGVsIH07XG5cbiAgZXhwb3J0IHtcbiAgICBDb21wbGV0aW9ucyBhcyBDb21wbGV0aW9ucyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uIGFzIENoYXRDb21wbGV0aW9uLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkF1ZGlvIGFzIENoYXRDb21wbGV0aW9uQXVkaW8sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkF1ZGlvUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25BdWRpb1BhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25DaHVuayBhcyBDaGF0Q29tcGxldGlvbkNodW5rLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydCBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydEltYWdlIGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbWFnZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbnB1dEF1ZGlvIGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbnB1dEF1ZGlvLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFJlZnVzYWwgYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFJlZnVzYWwsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dCBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uRGV2ZWxvcGVyTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uRGV2ZWxvcGVyTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25GdW5jdGlvbkNhbGxPcHRpb24gYXMgQ2hhdENvbXBsZXRpb25GdW5jdGlvbkNhbGxPcHRpb24sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2UgYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCBhcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTW9kYWxpdHkgYXMgQ2hhdENvbXBsZXRpb25Nb2RhbGl0eSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlIGFzIENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25QcmVkaWN0aW9uQ29udGVudCBhcyBDaGF0Q29tcGxldGlvblByZWRpY3Rpb25Db250ZW50LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25SZWFzb25pbmdFZmZvcnQgYXMgQ2hhdENvbXBsZXRpb25SZWFzb25pbmdFZmZvcnQsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblJvbGUgYXMgQ2hhdENvbXBsZXRpb25Sb2xlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25TdHJlYW1PcHRpb25zIGFzIENoYXRDb21wbGV0aW9uU3RyZWFtT3B0aW9ucyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uU3lzdGVtTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uU3lzdGVtTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2IgYXMgQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2IsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblRvb2wgYXMgQ2hhdENvbXBsZXRpb25Ub29sLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sQ2hvaWNlT3B0aW9uIGFzIENoYXRDb21wbGV0aW9uVG9vbENob2ljZU9wdGlvbixcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvblRvb2xNZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblVzZXJNZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25Vc2VyTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ3JlYXRlQ2hhdENvbXBsZXRpb25SZXF1ZXN0TWVzc2FnZSBhcyBDcmVhdGVDaGF0Q29tcGxldGlvblJlcXVlc3RNZXNzYWdlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMgYXMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIGFzIENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBhcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGFzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICAgIHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBhcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi9jb3JlJztcbmltcG9ydCB7IHR5cGUgUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9fc2hpbXMvaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgU3BlZWNoIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGF1ZGlvIGZyb20gdGhlIGlucHV0IHRleHQuXG4gICAqL1xuICBjcmVhdGUoYm9keTogU3BlZWNoQ3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2F1ZGlvL3NwZWVjaCcsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICBfX2JpbmFyeVJlc3BvbnNlOiB0cnVlLFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFNwZWVjaE1vZGVsID0gJ3R0cy0xJyB8ICd0dHMtMS1oZCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3BlZWNoQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSB0ZXh0IHRvIGdlbmVyYXRlIGF1ZGlvIGZvci4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDQwOTYgY2hhcmFjdGVycy5cbiAgICovXG4gIGlucHV0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE9uZSBvZiB0aGUgYXZhaWxhYmxlIFtUVFMgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjdHRzKTpcbiAgICogYHR0cy0xYCBvciBgdHRzLTEtaGRgXG4gICAqL1xuICBtb2RlbDogKHN0cmluZyAmIHt9KSB8IFNwZWVjaE1vZGVsO1xuXG4gIC8qKlxuICAgKiBUaGUgdm9pY2UgdG8gdXNlIHdoZW4gZ2VuZXJhdGluZyB0aGUgYXVkaW8uIFN1cHBvcnRlZCB2b2ljZXMgYXJlIGBhbGxveWAsXG4gICAqIGBlY2hvYCwgYGZhYmxlYCwgYG9ueXhgLCBgbm92YWAsIGFuZCBgc2hpbW1lcmAuIFByZXZpZXdzIG9mIHRoZSB2b2ljZXMgYXJlXG4gICAqIGF2YWlsYWJsZSBpbiB0aGVcbiAgICogW1RleHQgdG8gc3BlZWNoIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvdGV4dC10by1zcGVlY2gjdm9pY2Utb3B0aW9ucykuXG4gICAqL1xuICB2b2ljZTogJ2FsbG95JyB8ICdlY2hvJyB8ICdmYWJsZScgfCAnb255eCcgfCAnbm92YScgfCAnc2hpbW1lcic7XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgdG8gYXVkaW8gaW4uIFN1cHBvcnRlZCBmb3JtYXRzIGFyZSBgbXAzYCwgYG9wdXNgLCBgYWFjYCwgYGZsYWNgLFxuICAgKiBgd2F2YCwgYW5kIGBwY21gLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogJ21wMycgfCAnb3B1cycgfCAnYWFjJyB8ICdmbGFjJyB8ICd3YXYnIHwgJ3BjbSc7XG5cbiAgLyoqXG4gICAqIFRoZSBzcGVlZCBvZiB0aGUgZ2VuZXJhdGVkIGF1ZGlvLiBTZWxlY3QgYSB2YWx1ZSBmcm9tIGAwLjI1YCB0byBgNC4wYC4gYDEuMGAgaXNcbiAgICogdGhlIGRlZmF1bHQuXG4gICAqL1xuICBzcGVlZD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFNwZWVjaCB7XG4gIGV4cG9ydCB7IHR5cGUgU3BlZWNoTW9kZWwgYXMgU3BlZWNoTW9kZWwsIHR5cGUgU3BlZWNoQ3JlYXRlUGFyYW1zIGFzIFNwZWVjaENyZWF0ZVBhcmFtcyB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIEF1ZGlvQVBJIGZyb20gJy4vYXVkaW8nO1xuXG5leHBvcnQgY2xhc3MgVHJhbnNjcmlwdGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBUcmFuc2NyaWJlcyBhdWRpbyBpbnRvIHRoZSBpbnB1dCBsYW5ndWFnZS5cbiAgICovXG4gIGNyZWF0ZShcbiAgICBib2R5OiBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zPCdqc29uJyB8IHVuZGVmaW5lZD4sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxUcmFuc2NyaXB0aW9uPjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXM8J3ZlcmJvc2VfanNvbic+LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VHJhbnNjcmlwdGlvblZlcmJvc2U+O1xuICBjcmVhdGUoXG4gICAgYm9keTogVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtczwnc3J0JyB8ICd2dHQnIHwgJ3RleHQnPixcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPHN0cmluZz47XG4gIGNyZWF0ZShib2R5OiBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxUcmFuc2NyaXB0aW9uPjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxUcmFuc2NyaXB0aW9uQ3JlYXRlUmVzcG9uc2UgfCBzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9hdWRpby90cmFuc2NyaXB0aW9ucycsIENvcmUubXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zKHsgYm9keSwgLi4ub3B0aW9ucyB9KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNjcmlwdGlvbiByZXNwb25zZSByZXR1cm5lZCBieSBtb2RlbCwgYmFzZWQgb24gdGhlIHByb3ZpZGVkXG4gKiBpbnB1dC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFuc2NyaXB0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSB0cmFuc2NyaWJlZCB0ZXh0LlxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zY3JpcHRpb25TZWdtZW50IHtcbiAgLyoqXG4gICAqIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBzZWdtZW50LlxuICAgKi9cbiAgaWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogQXZlcmFnZSBsb2dwcm9iIG9mIHRoZSBzZWdtZW50LiBJZiB0aGUgdmFsdWUgaXMgbG93ZXIgdGhhbiAtMSwgY29uc2lkZXIgdGhlXG4gICAqIGxvZ3Byb2JzIGZhaWxlZC5cbiAgICovXG4gIGF2Z19sb2dwcm9iOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIENvbXByZXNzaW9uIHJhdGlvIG9mIHRoZSBzZWdtZW50LiBJZiB0aGUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIDIuNCwgY29uc2lkZXIgdGhlXG4gICAqIGNvbXByZXNzaW9uIGZhaWxlZC5cbiAgICovXG4gIGNvbXByZXNzaW9uX3JhdGlvOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEVuZCB0aW1lIG9mIHRoZSBzZWdtZW50IGluIHNlY29uZHMuXG4gICAqL1xuICBlbmQ6IG51bWJlcjtcblxuICAvKipcbiAgICogUHJvYmFiaWxpdHkgb2Ygbm8gc3BlZWNoIGluIHRoZSBzZWdtZW50LiBJZiB0aGUgdmFsdWUgaXMgaGlnaGVyIHRoYW4gMS4wIGFuZCB0aGVcbiAgICogYGF2Z19sb2dwcm9iYCBpcyBiZWxvdyAtMSwgY29uc2lkZXIgdGhpcyBzZWdtZW50IHNpbGVudC5cbiAgICovXG4gIG5vX3NwZWVjaF9wcm9iOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNlZWsgb2Zmc2V0IG9mIHRoZSBzZWdtZW50LlxuICAgKi9cbiAgc2VlazogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBTdGFydCB0aW1lIG9mIHRoZSBzZWdtZW50IGluIHNlY29uZHMuXG4gICAqL1xuICBzdGFydDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUZW1wZXJhdHVyZSBwYXJhbWV0ZXIgdXNlZCBmb3IgZ2VuZXJhdGluZyB0aGUgc2VnbWVudC5cbiAgICovXG4gIHRlbXBlcmF0dXJlOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRleHQgY29udGVudCBvZiB0aGUgc2VnbWVudC5cbiAgICovXG4gIHRleHQ6IHN0cmluZztcblxuICAvKipcbiAgICogQXJyYXkgb2YgdG9rZW4gSURzIGZvciB0aGUgdGV4dCBjb250ZW50LlxuICAgKi9cbiAgdG9rZW5zOiBBcnJheTxudW1iZXI+O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB2ZXJib3NlIGpzb24gdHJhbnNjcmlwdGlvbiByZXNwb25zZSByZXR1cm5lZCBieSBtb2RlbCwgYmFzZWQgb24gdGhlXG4gKiBwcm92aWRlZCBpbnB1dC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFuc2NyaXB0aW9uVmVyYm9zZSB7XG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24gb2YgdGhlIGlucHV0IGF1ZGlvLlxuICAgKi9cbiAgZHVyYXRpb246IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGxhbmd1YWdlIG9mIHRoZSBpbnB1dCBhdWRpby5cbiAgICovXG4gIGxhbmd1YWdlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0cmFuc2NyaWJlZCB0ZXh0LlxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTZWdtZW50cyBvZiB0aGUgdHJhbnNjcmliZWQgdGV4dCBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBkZXRhaWxzLlxuICAgKi9cbiAgc2VnbWVudHM/OiBBcnJheTxUcmFuc2NyaXB0aW9uU2VnbWVudD47XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RlZCB3b3JkcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyB0aW1lc3RhbXBzLlxuICAgKi9cbiAgd29yZHM/OiBBcnJheTxUcmFuc2NyaXB0aW9uV29yZD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNjcmlwdGlvbldvcmQge1xuICAvKipcbiAgICogRW5kIHRpbWUgb2YgdGhlIHdvcmQgaW4gc2Vjb25kcy5cbiAgICovXG4gIGVuZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBTdGFydCB0aW1lIG9mIHRoZSB3b3JkIGluIHNlY29uZHMuXG4gICAqL1xuICBzdGFydDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdGV4dCBjb250ZW50IG9mIHRoZSB3b3JkLlxuICAgKi9cbiAgd29yZDogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0cmFuc2NyaXB0aW9uIHJlc3BvbnNlIHJldHVybmVkIGJ5IG1vZGVsLCBiYXNlZCBvbiB0aGUgcHJvdmlkZWRcbiAqIGlucHV0LlxuICovXG5leHBvcnQgdHlwZSBUcmFuc2NyaXB0aW9uQ3JlYXRlUmVzcG9uc2UgPSBUcmFuc2NyaXB0aW9uIHwgVHJhbnNjcmlwdGlvblZlcmJvc2U7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtczxcbiAgUmVzcG9uc2VGb3JtYXQgZXh0ZW5kcyBBdWRpb0FQSS5BdWRpb1Jlc3BvbnNlRm9ybWF0IHwgdW5kZWZpbmVkID0gQXVkaW9BUEkuQXVkaW9SZXNwb25zZUZvcm1hdCB8IHVuZGVmaW5lZCxcbj4ge1xuICAvKipcbiAgICogVGhlIGF1ZGlvIGZpbGUgb2JqZWN0IChub3QgZmlsZSBuYW1lKSB0byB0cmFuc2NyaWJlLCBpbiBvbmUgb2YgdGhlc2UgZm9ybWF0czpcbiAgICogZmxhYywgbXAzLCBtcDQsIG1wZWcsIG1wZ2EsIG00YSwgb2dnLCB3YXYsIG9yIHdlYm0uXG4gICAqL1xuICBmaWxlOiBDb3JlLlVwbG9hZGFibGU7XG5cbiAgLyoqXG4gICAqIElEIG9mIHRoZSBtb2RlbCB0byB1c2UuIE9ubHkgYHdoaXNwZXItMWAgKHdoaWNoIGlzIHBvd2VyZWQgYnkgb3VyIG9wZW4gc291cmNlXG4gICAqIFdoaXNwZXIgVjIgbW9kZWwpIGlzIGN1cnJlbnRseSBhdmFpbGFibGUuXG4gICAqL1xuICBtb2RlbDogKHN0cmluZyAmIHt9KSB8IEF1ZGlvQVBJLkF1ZGlvTW9kZWw7XG5cbiAgLyoqXG4gICAqIFRoZSBsYW5ndWFnZSBvZiB0aGUgaW5wdXQgYXVkaW8uIFN1cHBseWluZyB0aGUgaW5wdXQgbGFuZ3VhZ2UgaW5cbiAgICogW0lTTy02MzktMV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9JU09fNjM5LTFfY29kZXMpIGZvcm1hdCB3aWxsXG4gICAqIGltcHJvdmUgYWNjdXJhY3kgYW5kIGxhdGVuY3kuXG4gICAqL1xuICBsYW5ndWFnZT86IHN0cmluZztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgdGV4dCB0byBndWlkZSB0aGUgbW9kZWwncyBzdHlsZSBvciBjb250aW51ZSBhIHByZXZpb3VzIGF1ZGlvXG4gICAqIHNlZ21lbnQuIFRoZVxuICAgKiBbcHJvbXB0XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc3BlZWNoLXRvLXRleHQjcHJvbXB0aW5nKVxuICAgKiBzaG91bGQgbWF0Y2ggdGhlIGF1ZGlvIGxhbmd1YWdlLlxuICAgKi9cbiAgcHJvbXB0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IG9mIHRoZSBvdXRwdXQsIGluIG9uZSBvZiB0aGVzZSBvcHRpb25zOiBganNvbmAsIGB0ZXh0YCwgYHNydGAsXG4gICAqIGB2ZXJib3NlX2pzb25gLCBvciBgdnR0YC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86IFJlc3BvbnNlRm9ybWF0O1xuXG4gIC8qKlxuICAgKiBUaGUgc2FtcGxpbmcgdGVtcGVyYXR1cmUsIGJldHdlZW4gMCBhbmQgMS4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsIG1ha2UgdGhlXG4gICAqIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlIGZvY3VzZWQgYW5kXG4gICAqIGRldGVybWluaXN0aWMuIElmIHNldCB0byAwLCB0aGUgbW9kZWwgd2lsbCB1c2VcbiAgICogW2xvZyBwcm9iYWJpbGl0eV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9nX3Byb2JhYmlsaXR5KSB0b1xuICAgKiBhdXRvbWF0aWNhbGx5IGluY3JlYXNlIHRoZSB0ZW1wZXJhdHVyZSB1bnRpbCBjZXJ0YWluIHRocmVzaG9sZHMgYXJlIGhpdC5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdGltZXN0YW1wIGdyYW51bGFyaXRpZXMgdG8gcG9wdWxhdGUgZm9yIHRoaXMgdHJhbnNjcmlwdGlvbi5cbiAgICogYHJlc3BvbnNlX2Zvcm1hdGAgbXVzdCBiZSBzZXQgYHZlcmJvc2VfanNvbmAgdG8gdXNlIHRpbWVzdGFtcCBncmFudWxhcml0aWVzLlxuICAgKiBFaXRoZXIgb3IgYm90aCBvZiB0aGVzZSBvcHRpb25zIGFyZSBzdXBwb3J0ZWQ6IGB3b3JkYCwgb3IgYHNlZ21lbnRgLiBOb3RlOiBUaGVyZVxuICAgKiBpcyBubyBhZGRpdGlvbmFsIGxhdGVuY3kgZm9yIHNlZ21lbnQgdGltZXN0YW1wcywgYnV0IGdlbmVyYXRpbmcgd29yZCB0aW1lc3RhbXBzXG4gICAqIGluY3VycyBhZGRpdGlvbmFsIGxhdGVuY3kuXG4gICAqL1xuICB0aW1lc3RhbXBfZ3JhbnVsYXJpdGllcz86IEFycmF5PCd3b3JkJyB8ICdzZWdtZW50Jz47XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBUcmFuc2NyaXB0aW9ucyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uIGFzIFRyYW5zY3JpcHRpb24sXG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uU2VnbWVudCBhcyBUcmFuc2NyaXB0aW9uU2VnbWVudCxcbiAgICB0eXBlIFRyYW5zY3JpcHRpb25WZXJib3NlIGFzIFRyYW5zY3JpcHRpb25WZXJib3NlLFxuICAgIHR5cGUgVHJhbnNjcmlwdGlvbldvcmQgYXMgVHJhbnNjcmlwdGlvbldvcmQsXG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uQ3JlYXRlUmVzcG9uc2UgYXMgVHJhbnNjcmlwdGlvbkNyZWF0ZVJlc3BvbnNlLFxuICAgIHR5cGUgVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtcyBhcyBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIEF1ZGlvQVBJIGZyb20gJy4vYXVkaW8nO1xuaW1wb3J0ICogYXMgVHJhbnNjcmlwdGlvbnNBUEkgZnJvbSAnLi90cmFuc2NyaXB0aW9ucyc7XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2xhdGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBUcmFuc2xhdGVzIGF1ZGlvIGludG8gRW5nbGlzaC5cbiAgICovXG4gIGNyZWF0ZShcbiAgICBib2R5OiBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtczwnanNvbicgfCB1bmRlZmluZWQ+LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VHJhbnNsYXRpb24+O1xuICBjcmVhdGUoXG4gICAgYm9keTogVHJhbnNsYXRpb25DcmVhdGVQYXJhbXM8J3ZlcmJvc2VfanNvbic+LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VHJhbnNsYXRpb25WZXJib3NlPjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zPCd0ZXh0JyB8ICdzcnQnIHwgJ3Z0dCc+LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8c3RyaW5nPjtcbiAgY3JlYXRlKGJvZHk6IFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxUcmFuc2xhdGlvbj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFRyYW5zbGF0aW9uQ3JlYXRlUmVzcG9uc2UgfCBzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9hdWRpby90cmFuc2xhdGlvbnMnLCBDb3JlLm11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyh7IGJvZHksIC4uLm9wdGlvbnMgfSkpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNsYXRpb24ge1xuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNsYXRpb25WZXJib3NlIHtcbiAgLyoqXG4gICAqIFRoZSBkdXJhdGlvbiBvZiB0aGUgaW5wdXQgYXVkaW8uXG4gICAqL1xuICBkdXJhdGlvbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbGFuZ3VhZ2Ugb2YgdGhlIG91dHB1dCB0cmFuc2xhdGlvbiAoYWx3YXlzIGBlbmdsaXNoYCkuXG4gICAqL1xuICBsYW5ndWFnZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNsYXRlZCB0ZXh0LlxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTZWdtZW50cyBvZiB0aGUgdHJhbnNsYXRlZCB0ZXh0IGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIGRldGFpbHMuXG4gICAqL1xuICBzZWdtZW50cz86IEFycmF5PFRyYW5zY3JpcHRpb25zQVBJLlRyYW5zY3JpcHRpb25TZWdtZW50Pjtcbn1cblxuZXhwb3J0IHR5cGUgVHJhbnNsYXRpb25DcmVhdGVSZXNwb25zZSA9IFRyYW5zbGF0aW9uIHwgVHJhbnNsYXRpb25WZXJib3NlO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zPFxuICBSZXNwb25zZUZvcm1hdCBleHRlbmRzIEF1ZGlvQVBJLkF1ZGlvUmVzcG9uc2VGb3JtYXQgfCB1bmRlZmluZWQgPSBBdWRpb0FQSS5BdWRpb1Jlc3BvbnNlRm9ybWF0IHwgdW5kZWZpbmVkLFxuPiB7XG4gIC8qKlxuICAgKiBUaGUgYXVkaW8gZmlsZSBvYmplY3QgKG5vdCBmaWxlIG5hbWUpIHRyYW5zbGF0ZSwgaW4gb25lIG9mIHRoZXNlIGZvcm1hdHM6IGZsYWMsXG4gICAqIG1wMywgbXA0LCBtcGVnLCBtcGdhLCBtNGEsIG9nZywgd2F2LCBvciB3ZWJtLlxuICAgKi9cbiAgZmlsZTogQ29yZS5VcGxvYWRhYmxlO1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBPbmx5IGB3aGlzcGVyLTFgICh3aGljaCBpcyBwb3dlcmVkIGJ5IG91ciBvcGVuIHNvdXJjZVxuICAgKiBXaGlzcGVyIFYyIG1vZGVsKSBpcyBjdXJyZW50bHkgYXZhaWxhYmxlLlxuICAgKi9cbiAgbW9kZWw6IChzdHJpbmcgJiB7fSkgfCBBdWRpb0FQSS5BdWRpb01vZGVsO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCB0ZXh0IHRvIGd1aWRlIHRoZSBtb2RlbCdzIHN0eWxlIG9yIGNvbnRpbnVlIGEgcHJldmlvdXMgYXVkaW9cbiAgICogc2VnbWVudC4gVGhlXG4gICAqIFtwcm9tcHRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zcGVlY2gtdG8tdGV4dCNwcm9tcHRpbmcpXG4gICAqIHNob3VsZCBiZSBpbiBFbmdsaXNoLlxuICAgKi9cbiAgcHJvbXB0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IG9mIHRoZSBvdXRwdXQsIGluIG9uZSBvZiB0aGVzZSBvcHRpb25zOiBganNvbmAsIGB0ZXh0YCwgYHNydGAsXG4gICAqIGB2ZXJib3NlX2pzb25gLCBvciBgdnR0YC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86IFJlc3BvbnNlRm9ybWF0O1xuXG4gIC8qKlxuICAgKiBUaGUgc2FtcGxpbmcgdGVtcGVyYXR1cmUsIGJldHdlZW4gMCBhbmQgMS4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsIG1ha2UgdGhlXG4gICAqIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlIGZvY3VzZWQgYW5kXG4gICAqIGRldGVybWluaXN0aWMuIElmIHNldCB0byAwLCB0aGUgbW9kZWwgd2lsbCB1c2VcbiAgICogW2xvZyBwcm9iYWJpbGl0eV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9nX3Byb2JhYmlsaXR5KSB0b1xuICAgKiBhdXRvbWF0aWNhbGx5IGluY3JlYXNlIHRoZSB0ZW1wZXJhdHVyZSB1bnRpbCBjZXJ0YWluIHRocmVzaG9sZHMgYXJlIGhpdC5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVHJhbnNsYXRpb25zIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIFRyYW5zbGF0aW9uIGFzIFRyYW5zbGF0aW9uLFxuICAgIHR5cGUgVHJhbnNsYXRpb25WZXJib3NlIGFzIFRyYW5zbGF0aW9uVmVyYm9zZSxcbiAgICB0eXBlIFRyYW5zbGF0aW9uQ3JlYXRlUmVzcG9uc2UgYXMgVHJhbnNsYXRpb25DcmVhdGVSZXNwb25zZSxcbiAgICB0eXBlIFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zIGFzIFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgU3BlZWNoQVBJIGZyb20gJy4vc3BlZWNoJztcbmltcG9ydCB7IFNwZWVjaCwgU3BlZWNoQ3JlYXRlUGFyYW1zLCBTcGVlY2hNb2RlbCB9IGZyb20gJy4vc3BlZWNoJztcbmltcG9ydCAqIGFzIFRyYW5zY3JpcHRpb25zQVBJIGZyb20gJy4vdHJhbnNjcmlwdGlvbnMnO1xuaW1wb3J0IHtcbiAgVHJhbnNjcmlwdGlvbixcbiAgVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtcyxcbiAgVHJhbnNjcmlwdGlvbkNyZWF0ZVJlc3BvbnNlLFxuICBUcmFuc2NyaXB0aW9uU2VnbWVudCxcbiAgVHJhbnNjcmlwdGlvblZlcmJvc2UsXG4gIFRyYW5zY3JpcHRpb25Xb3JkLFxuICBUcmFuc2NyaXB0aW9ucyxcbn0gZnJvbSAnLi90cmFuc2NyaXB0aW9ucyc7XG5pbXBvcnQgKiBhcyBUcmFuc2xhdGlvbnNBUEkgZnJvbSAnLi90cmFuc2xhdGlvbnMnO1xuaW1wb3J0IHtcbiAgVHJhbnNsYXRpb24sXG4gIFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zLFxuICBUcmFuc2xhdGlvbkNyZWF0ZVJlc3BvbnNlLFxuICBUcmFuc2xhdGlvblZlcmJvc2UsXG4gIFRyYW5zbGF0aW9ucyxcbn0gZnJvbSAnLi90cmFuc2xhdGlvbnMnO1xuXG5leHBvcnQgY2xhc3MgQXVkaW8gZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIHRyYW5zY3JpcHRpb25zOiBUcmFuc2NyaXB0aW9uc0FQSS5UcmFuc2NyaXB0aW9ucyA9IG5ldyBUcmFuc2NyaXB0aW9uc0FQSS5UcmFuc2NyaXB0aW9ucyh0aGlzLl9jbGllbnQpO1xuICB0cmFuc2xhdGlvbnM6IFRyYW5zbGF0aW9uc0FQSS5UcmFuc2xhdGlvbnMgPSBuZXcgVHJhbnNsYXRpb25zQVBJLlRyYW5zbGF0aW9ucyh0aGlzLl9jbGllbnQpO1xuICBzcGVlY2g6IFNwZWVjaEFQSS5TcGVlY2ggPSBuZXcgU3BlZWNoQVBJLlNwZWVjaCh0aGlzLl9jbGllbnQpO1xufVxuXG5leHBvcnQgdHlwZSBBdWRpb01vZGVsID0gJ3doaXNwZXItMSc7XG5cbi8qKlxuICogVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0LCBpbiBvbmUgb2YgdGhlc2Ugb3B0aW9uczogYGpzb25gLCBgdGV4dGAsIGBzcnRgLFxuICogYHZlcmJvc2VfanNvbmAsIG9yIGB2dHRgLlxuICovXG5leHBvcnQgdHlwZSBBdWRpb1Jlc3BvbnNlRm9ybWF0ID0gJ2pzb24nIHwgJ3RleHQnIHwgJ3NydCcgfCAndmVyYm9zZV9qc29uJyB8ICd2dHQnO1xuXG5BdWRpby5UcmFuc2NyaXB0aW9ucyA9IFRyYW5zY3JpcHRpb25zO1xuQXVkaW8uVHJhbnNsYXRpb25zID0gVHJhbnNsYXRpb25zO1xuQXVkaW8uU3BlZWNoID0gU3BlZWNoO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgQXVkaW8ge1xuICBleHBvcnQgeyB0eXBlIEF1ZGlvTW9kZWwgYXMgQXVkaW9Nb2RlbCwgdHlwZSBBdWRpb1Jlc3BvbnNlRm9ybWF0IGFzIEF1ZGlvUmVzcG9uc2VGb3JtYXQgfTtcblxuICBleHBvcnQge1xuICAgIFRyYW5zY3JpcHRpb25zIGFzIFRyYW5zY3JpcHRpb25zLFxuICAgIHR5cGUgVHJhbnNjcmlwdGlvbiBhcyBUcmFuc2NyaXB0aW9uLFxuICAgIHR5cGUgVHJhbnNjcmlwdGlvblNlZ21lbnQgYXMgVHJhbnNjcmlwdGlvblNlZ21lbnQsXG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uVmVyYm9zZSBhcyBUcmFuc2NyaXB0aW9uVmVyYm9zZSxcbiAgICB0eXBlIFRyYW5zY3JpcHRpb25Xb3JkIGFzIFRyYW5zY3JpcHRpb25Xb3JkLFxuICAgIHR5cGUgVHJhbnNjcmlwdGlvbkNyZWF0ZVJlc3BvbnNlIGFzIFRyYW5zY3JpcHRpb25DcmVhdGVSZXNwb25zZSxcbiAgICB0eXBlIFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXMgYXMgVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIFRyYW5zbGF0aW9ucyBhcyBUcmFuc2xhdGlvbnMsXG4gICAgdHlwZSBUcmFuc2xhdGlvbiBhcyBUcmFuc2xhdGlvbixcbiAgICB0eXBlIFRyYW5zbGF0aW9uVmVyYm9zZSBhcyBUcmFuc2xhdGlvblZlcmJvc2UsXG4gICAgdHlwZSBUcmFuc2xhdGlvbkNyZWF0ZVJlc3BvbnNlIGFzIFRyYW5zbGF0aW9uQ3JlYXRlUmVzcG9uc2UsXG4gICAgdHlwZSBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcyBhcyBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQgeyBTcGVlY2ggYXMgU3BlZWNoLCB0eXBlIFNwZWVjaE1vZGVsIGFzIFNwZWVjaE1vZGVsLCB0eXBlIFNwZWVjaENyZWF0ZVBhcmFtcyBhcyBTcGVlY2hDcmVhdGVQYXJhbXMgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBCYXRjaGVzQVBJIGZyb20gJy4vYmF0Y2hlcyc7XG5pbXBvcnQgeyBDdXJzb3JQYWdlLCB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgfSBmcm9tICcuLi9wYWdpbmF0aW9uJztcblxuZXhwb3J0IGNsYXNzIEJhdGNoZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBleGVjdXRlcyBhIGJhdGNoIGZyb20gYW4gdXBsb2FkZWQgZmlsZSBvZiByZXF1ZXN0c1xuICAgKi9cbiAgY3JlYXRlKGJvZHk6IEJhdGNoQ3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxCYXRjaD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2JhdGNoZXMnLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgYmF0Y2guXG4gICAqL1xuICByZXRyaWV2ZShiYXRjaElkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEJhdGNoPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC9iYXRjaGVzLyR7YmF0Y2hJZH1gLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHlvdXIgb3JnYW5pemF0aW9uJ3MgYmF0Y2hlcy5cbiAgICovXG4gIGxpc3QocXVlcnk/OiBCYXRjaExpc3RQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5QYWdlUHJvbWlzZTxCYXRjaGVzUGFnZSwgQmF0Y2g+O1xuICBsaXN0KG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5QYWdlUHJvbWlzZTxCYXRjaGVzUGFnZSwgQmF0Y2g+O1xuICBsaXN0KFxuICAgIHF1ZXJ5OiBCYXRjaExpc3RQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8QmF0Y2hlc1BhZ2UsIEJhdGNoPiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0KHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdCgnL2JhdGNoZXMnLCBCYXRjaGVzUGFnZSwgeyBxdWVyeSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGFuIGluLXByb2dyZXNzIGJhdGNoLiBUaGUgYmF0Y2ggd2lsbCBiZSBpbiBzdGF0dXMgYGNhbmNlbGxpbmdgIGZvciB1cCB0b1xuICAgKiAxMCBtaW51dGVzLCBiZWZvcmUgY2hhbmdpbmcgdG8gYGNhbmNlbGxlZGAsIHdoZXJlIGl0IHdpbGwgaGF2ZSBwYXJ0aWFsIHJlc3VsdHNcbiAgICogKGlmIGFueSkgYXZhaWxhYmxlIGluIHRoZSBvdXRwdXQgZmlsZS5cbiAgICovXG4gIGNhbmNlbChiYXRjaElkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEJhdGNoPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvYmF0Y2hlcy8ke2JhdGNoSWR9L2NhbmNlbGAsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCYXRjaGVzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8QmF0Y2g+IHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmF0Y2gge1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdGltZSBmcmFtZSB3aXRoaW4gd2hpY2ggdGhlIGJhdGNoIHNob3VsZCBiZSBwcm9jZXNzZWQuXG4gICAqL1xuICBjb21wbGV0aW9uX3dpbmRvdzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBiYXRjaCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIE9wZW5BSSBBUEkgZW5kcG9pbnQgdXNlZCBieSB0aGUgYmF0Y2guXG4gICAqL1xuICBlbmRwb2ludDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGlucHV0IGZpbGUgZm9yIHRoZSBiYXRjaC5cbiAgICovXG4gIGlucHV0X2ZpbGVfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYGJhdGNoYC5cbiAgICovXG4gIG9iamVjdDogJ2JhdGNoJztcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBiYXRjaC5cbiAgICovXG4gIHN0YXR1czpcbiAgICB8ICd2YWxpZGF0aW5nJ1xuICAgIHwgJ2ZhaWxlZCdcbiAgICB8ICdpbl9wcm9ncmVzcydcbiAgICB8ICdmaW5hbGl6aW5nJ1xuICAgIHwgJ2NvbXBsZXRlZCdcbiAgICB8ICdleHBpcmVkJ1xuICAgIHwgJ2NhbmNlbGxpbmcnXG4gICAgfCAnY2FuY2VsbGVkJztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgYmF0Y2ggd2FzIGNhbmNlbGxlZC5cbiAgICovXG4gIGNhbmNlbGxlZF9hdD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgYmF0Y2ggc3RhcnRlZCBjYW5jZWxsaW5nLlxuICAgKi9cbiAgY2FuY2VsbGluZ19hdD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgYmF0Y2ggd2FzIGNvbXBsZXRlZC5cbiAgICovXG4gIGNvbXBsZXRlZF9hdD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBmaWxlIGNvbnRhaW5pbmcgdGhlIG91dHB1dHMgb2YgcmVxdWVzdHMgd2l0aCBlcnJvcnMuXG4gICAqL1xuICBlcnJvcl9maWxlX2lkPzogc3RyaW5nO1xuXG4gIGVycm9ycz86IEJhdGNoLkVycm9ycztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgYmF0Y2ggZXhwaXJlZC5cbiAgICovXG4gIGV4cGlyZWRfYXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGJhdGNoIHdpbGwgZXhwaXJlLlxuICAgKi9cbiAgZXhwaXJlc19hdD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgYmF0Y2ggZmFpbGVkLlxuICAgKi9cbiAgZmFpbGVkX2F0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBiYXRjaCBzdGFydGVkIGZpbmFsaXppbmcuXG4gICAqL1xuICBmaW5hbGl6aW5nX2F0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBiYXRjaCBzdGFydGVkIHByb2Nlc3NpbmcuXG4gICAqL1xuICBpbl9wcm9ncmVzc19hdD86IG51bWJlcjtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBmaWxlIGNvbnRhaW5pbmcgdGhlIG91dHB1dHMgb2Ygc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkIHJlcXVlc3RzLlxuICAgKi9cbiAgb3V0cHV0X2ZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSByZXF1ZXN0IGNvdW50cyBmb3IgZGlmZmVyZW50IHN0YXR1c2VzIHdpdGhpbiB0aGUgYmF0Y2guXG4gICAqL1xuICByZXF1ZXN0X2NvdW50cz86IEJhdGNoUmVxdWVzdENvdW50cztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBCYXRjaCB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRXJyb3JzIHtcbiAgICBkYXRhPzogQXJyYXk8QmF0Y2hlc0FQSS5CYXRjaEVycm9yPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGBsaXN0YC5cbiAgICAgKi9cbiAgICBvYmplY3Q/OiBzdHJpbmc7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXRjaEVycm9yIHtcbiAgLyoqXG4gICAqIEFuIGVycm9yIGNvZGUgaWRlbnRpZnlpbmcgdGhlIGVycm9yIHR5cGUuXG4gICAqL1xuICBjb2RlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbGluZSBudW1iZXIgb2YgdGhlIGlucHV0IGZpbGUgd2hlcmUgdGhlIGVycm9yIG9jY3VycmVkLCBpZiBhcHBsaWNhYmxlLlxuICAgKi9cbiAgbGluZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgaHVtYW4tcmVhZGFibGUgbWVzc2FnZSBwcm92aWRpbmcgbW9yZSBkZXRhaWxzIGFib3V0IHRoZSBlcnJvci5cbiAgICovXG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgdGhhdCBjYXVzZWQgdGhlIGVycm9yLCBpZiBhcHBsaWNhYmxlLlxuICAgKi9cbiAgcGFyYW0/OiBzdHJpbmcgfCBudWxsO1xufVxuXG4vKipcbiAqIFRoZSByZXF1ZXN0IGNvdW50cyBmb3IgZGlmZmVyZW50IHN0YXR1c2VzIHdpdGhpbiB0aGUgYmF0Y2guXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmF0Y2hSZXF1ZXN0Q291bnRzIHtcbiAgLyoqXG4gICAqIE51bWJlciBvZiByZXF1ZXN0cyB0aGF0IGhhdmUgYmVlbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgKi9cbiAgY29tcGxldGVkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiByZXF1ZXN0cyB0aGF0IGhhdmUgZmFpbGVkLlxuICAgKi9cbiAgZmFpbGVkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRvdGFsIG51bWJlciBvZiByZXF1ZXN0cyBpbiB0aGUgYmF0Y2guXG4gICAqL1xuICB0b3RhbDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhdGNoQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSB0aW1lIGZyYW1lIHdpdGhpbiB3aGljaCB0aGUgYmF0Y2ggc2hvdWxkIGJlIHByb2Nlc3NlZC4gQ3VycmVudGx5IG9ubHkgYDI0aGBcbiAgICogaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgY29tcGxldGlvbl93aW5kb3c6ICcyNGgnO1xuXG4gIC8qKlxuICAgKiBUaGUgZW5kcG9pbnQgdG8gYmUgdXNlZCBmb3IgYWxsIHJlcXVlc3RzIGluIHRoZSBiYXRjaC4gQ3VycmVudGx5XG4gICAqIGAvdjEvY2hhdC9jb21wbGV0aW9uc2AsIGAvdjEvZW1iZWRkaW5nc2AsIGFuZCBgL3YxL2NvbXBsZXRpb25zYCBhcmUgc3VwcG9ydGVkLlxuICAgKiBOb3RlIHRoYXQgYC92MS9lbWJlZGRpbmdzYCBiYXRjaGVzIGFyZSBhbHNvIHJlc3RyaWN0ZWQgdG8gYSBtYXhpbXVtIG9mIDUwLDAwMFxuICAgKiBlbWJlZGRpbmcgaW5wdXRzIGFjcm9zcyBhbGwgcmVxdWVzdHMgaW4gdGhlIGJhdGNoLlxuICAgKi9cbiAgZW5kcG9pbnQ6ICcvdjEvY2hhdC9jb21wbGV0aW9ucycgfCAnL3YxL2VtYmVkZGluZ3MnIHwgJy92MS9jb21wbGV0aW9ucyc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiBhbiB1cGxvYWRlZCBmaWxlIHRoYXQgY29udGFpbnMgcmVxdWVzdHMgZm9yIHRoZSBuZXcgYmF0Y2guXG4gICAqXG4gICAqIFNlZSBbdXBsb2FkIGZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMvY3JlYXRlKVxuICAgKiBmb3IgaG93IHRvIHVwbG9hZCBhIGZpbGUuXG4gICAqXG4gICAqIFlvdXIgaW5wdXQgZmlsZSBtdXN0IGJlIGZvcm1hdHRlZCBhcyBhXG4gICAqIFtKU09OTCBmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2JhdGNoL3JlcXVlc3QtaW5wdXQpLFxuICAgKiBhbmQgbXVzdCBiZSB1cGxvYWRlZCB3aXRoIHRoZSBwdXJwb3NlIGBiYXRjaGAuIFRoZSBmaWxlIGNhbiBjb250YWluIHVwIHRvIDUwLDAwMFxuICAgKiByZXF1ZXN0cywgYW5kIGNhbiBiZSB1cCB0byAyMDAgTUIgaW4gc2l6ZS5cbiAgICovXG4gIGlucHV0X2ZpbGVfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogT3B0aW9uYWwgY3VzdG9tIG1ldGFkYXRhIGZvciB0aGUgYmF0Y2guXG4gICAqL1xuICBtZXRhZGF0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhdGNoTGlzdFBhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge31cblxuQmF0Y2hlcy5CYXRjaGVzUGFnZSA9IEJhdGNoZXNQYWdlO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgQmF0Y2hlcyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBCYXRjaCBhcyBCYXRjaCxcbiAgICB0eXBlIEJhdGNoRXJyb3IgYXMgQmF0Y2hFcnJvcixcbiAgICB0eXBlIEJhdGNoUmVxdWVzdENvdW50cyBhcyBCYXRjaFJlcXVlc3RDb3VudHMsXG4gICAgQmF0Y2hlc1BhZ2UgYXMgQmF0Y2hlc1BhZ2UsXG4gICAgdHlwZSBCYXRjaENyZWF0ZVBhcmFtcyBhcyBCYXRjaENyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIEJhdGNoTGlzdFBhcmFtcyBhcyBCYXRjaExpc3RQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgU2hhcmVkIGZyb20gJy4uL3NoYXJlZCc7XG5pbXBvcnQgKiBhcyBDaGF0QVBJIGZyb20gJy4uL2NoYXQvY2hhdCc7XG5pbXBvcnQgKiBhcyBNZXNzYWdlc0FQSSBmcm9tICcuL3RocmVhZHMvbWVzc2FnZXMnO1xuaW1wb3J0ICogYXMgVGhyZWFkc0FQSSBmcm9tICcuL3RocmVhZHMvdGhyZWFkcyc7XG5pbXBvcnQgKiBhcyBWZWN0b3JTdG9yZXNBUEkgZnJvbSAnLi92ZWN0b3Itc3RvcmVzL3ZlY3Rvci1zdG9yZXMnO1xuaW1wb3J0ICogYXMgUnVuc0FQSSBmcm9tICcuL3RocmVhZHMvcnVucy9ydW5zJztcbmltcG9ydCAqIGFzIFN0ZXBzQVBJIGZyb20gJy4vdGhyZWFkcy9ydW5zL3N0ZXBzJztcbmltcG9ydCB7IEN1cnNvclBhZ2UsIHR5cGUgQ3Vyc29yUGFnZVBhcmFtcyB9IGZyb20gJy4uLy4uL3BhZ2luYXRpb24nO1xuXG5leHBvcnQgY2xhc3MgQXNzaXN0YW50cyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhc3Npc3RhbnQgd2l0aCBhIG1vZGVsIGFuZCBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICBjcmVhdGUoYm9keTogQXNzaXN0YW50Q3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxBc3Npc3RhbnQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9hc3Npc3RhbnRzJywge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbiBhc3Npc3RhbnQuXG4gICAqL1xuICByZXRyaWV2ZShhc3Npc3RhbnRJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxBc3Npc3RhbnQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZmllcyBhbiBhc3Npc3RhbnQuXG4gICAqL1xuICB1cGRhdGUoXG4gICAgYXNzaXN0YW50SWQ6IHN0cmluZyxcbiAgICBib2R5OiBBc3Npc3RhbnRVcGRhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxBc3Npc3RhbnQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC9hc3Npc3RhbnRzLyR7YXNzaXN0YW50SWR9YCwge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIGFzc2lzdGFudHMuXG4gICAqL1xuICBsaXN0KFxuICAgIHF1ZXJ5PzogQXNzaXN0YW50TGlzdFBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxBc3Npc3RhbnRzUGFnZSwgQXNzaXN0YW50PjtcbiAgbGlzdChvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuUGFnZVByb21pc2U8QXNzaXN0YW50c1BhZ2UsIEFzc2lzdGFudD47XG4gIGxpc3QoXG4gICAgcXVlcnk6IEFzc2lzdGFudExpc3RQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8QXNzaXN0YW50c1BhZ2UsIEFzc2lzdGFudD4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdCh7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy9hc3Npc3RhbnRzJywgQXNzaXN0YW50c1BhZ2UsIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGFuIGFzc2lzdGFudC5cbiAgICovXG4gIGRlbChhc3Npc3RhbnRJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxBc3Npc3RhbnREZWxldGVkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5kZWxldGUoYC9hc3Npc3RhbnRzLyR7YXNzaXN0YW50SWR9YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFzc2lzdGFudHNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxBc3Npc3RhbnQ+IHt9XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBgYXNzaXN0YW50YCB0aGF0IGNhbiBjYWxsIHRoZSBtb2RlbCBhbmQgdXNlIHRvb2xzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFzc2lzdGFudCB7XG4gIC8qKlxuICAgKiBUaGUgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGFzc2lzdGFudCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBhc3Npc3RhbnQuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyA1MTIgY2hhcmFjdGVycy5cbiAgICovXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIGluc3RydWN0aW9ucyB0aGF0IHRoZSBhc3Npc3RhbnQgdXNlcy4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDI1NiwwMDBcbiAgICogY2hhcmFjdGVycy5cbiAgICovXG4gIGluc3RydWN0aW9uczogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE6IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBZb3UgY2FuIHVzZSB0aGVcbiAgICogW0xpc3QgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscy9saXN0KSBBUEkgdG9cbiAgICogc2VlIGFsbCBvZiB5b3VyIGF2YWlsYWJsZSBtb2RlbHMsIG9yIHNlZSBvdXJcbiAgICogW01vZGVsIG92ZXJ2aWV3XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMpIGZvciBkZXNjcmlwdGlvbnMgb2ZcbiAgICogdGhlbS5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBhc3Npc3RhbnQuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyAyNTYgY2hhcmFjdGVycy5cbiAgICovXG4gIG5hbWU6IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGBhc3Npc3RhbnRgLlxuICAgKi9cbiAgb2JqZWN0OiAnYXNzaXN0YW50JztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIHRvb2wgZW5hYmxlZCBvbiB0aGUgYXNzaXN0YW50LiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEyOCB0b29scyBwZXJcbiAgICogYXNzaXN0YW50LiBUb29scyBjYW4gYmUgb2YgdHlwZXMgYGNvZGVfaW50ZXJwcmV0ZXJgLCBgZmlsZV9zZWFyY2hgLCBvclxuICAgKiBgZnVuY3Rpb25gLlxuICAgKi9cbiAgdG9vbHM6IEFycmF5PEFzc2lzdGFudFRvb2w+O1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gICAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNG8pLFxuICAgKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICAgKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fc2NoZW1hXCIsIFwianNvbl9zY2hlbWFcIjogey4uLn0gfWAgZW5hYmxlcyBTdHJ1Y3R1cmVkXG4gICAqIE91dHB1dHMgd2hpY2ggZW5zdXJlcyB0aGUgbW9kZWwgd2lsbCBtYXRjaCB5b3VyIHN1cHBsaWVkIEpTT04gc2NoZW1hLiBMZWFybiBtb3JlXG4gICAqIGluIHRoZVxuICAgKiBbU3RydWN0dXJlZCBPdXRwdXRzIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc3RydWN0dXJlZC1vdXRwdXRzKS5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBlbnN1cmVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogVGhyZWFkc0FQSS5Bc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoYXQgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdG8gdXNlLCBiZXR3ZWVuIDAgYW5kIDIuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbFxuICAgKiBtYWtlIHRoZSBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZVxuICAgKiBmb2N1c2VkIGFuZCBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgdXNlZCBieSB0aGUgYXNzaXN0YW50J3MgdG9vbHMuIFRoZSByZXNvdXJjZXMgYXJlXG4gICAqIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXNcbiAgICogYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVcbiAgICogSURzLlxuICAgKi9cbiAgdG9vbF9yZXNvdXJjZXM/OiBBc3Npc3RhbnQuVG9vbFJlc291cmNlcyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEFuIGFsdGVybmF0aXZlIHRvIHNhbXBsaW5nIHdpdGggdGVtcGVyYXR1cmUsIGNhbGxlZCBudWNsZXVzIHNhbXBsaW5nLCB3aGVyZSB0aGVcbiAgICogbW9kZWwgY29uc2lkZXJzIHRoZSByZXN1bHRzIG9mIHRoZSB0b2tlbnMgd2l0aCB0b3BfcCBwcm9iYWJpbGl0eSBtYXNzLiBTbyAwLjFcbiAgICogbWVhbnMgb25seSB0aGUgdG9rZW5zIGNvbXByaXNpbmcgdGhlIHRvcCAxMCUgcHJvYmFiaWxpdHkgbWFzcyBhcmUgY29uc2lkZXJlZC5cbiAgICpcbiAgICogV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIHRlbXBlcmF0dXJlIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRvcF9wPzogbnVtYmVyIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBBc3Npc3RhbnQge1xuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIGFzc2lzdGFudCdzIHRvb2xzLiBUaGUgcmVzb3VyY2VzIGFyZVxuICAgKiBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzXG4gICAqIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlXG4gICAqIElEcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgY29kZV9pbnRlcnByZXRlcj86IFRvb2xSZXNvdXJjZXMuQ29kZUludGVycHJldGVyO1xuXG4gICAgZmlsZV9zZWFyY2g/OiBUb29sUmVzb3VyY2VzLkZpbGVTZWFyY2g7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgbWFkZVxuICAgICAgICogYXZhaWxhYmxlIHRvIHRoZSBgY29kZV9pbnRlcnByZXRlcmBgIHRvb2wuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMjAgZmlsZXNcbiAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9vbC5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBJRCBvZiB0aGVcbiAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgKiBhdHRhY2hlZCB0byB0aGlzIGFzc2lzdGFudC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvciBzdG9yZSBhdHRhY2hlZCB0b1xuICAgICAgICogdGhlIGFzc2lzdGFudC5cbiAgICAgICAqL1xuICAgICAgdmVjdG9yX3N0b3JlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXNzaXN0YW50RGVsZXRlZCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgZGVsZXRlZDogYm9vbGVhbjtcblxuICBvYmplY3Q6ICdhc3Npc3RhbnQuZGVsZXRlZCc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBldmVudCBlbWl0dGVkIHdoZW4gc3RyZWFtaW5nIGEgUnVuLlxuICpcbiAqIEVhY2ggZXZlbnQgaW4gYSBzZXJ2ZXItc2VudCBldmVudHMgc3RyZWFtIGhhcyBhbiBgZXZlbnRgIGFuZCBgZGF0YWAgcHJvcGVydHk6XG4gKlxuICogYGBgXG4gKiBldmVudDogdGhyZWFkLmNyZWF0ZWRcbiAqIGRhdGE6IHtcImlkXCI6IFwidGhyZWFkXzEyM1wiLCBcIm9iamVjdFwiOiBcInRocmVhZFwiLCAuLi59XG4gKiBgYGBcbiAqXG4gKiBXZSBlbWl0IGV2ZW50cyB3aGVuZXZlciBhIG5ldyBvYmplY3QgaXMgY3JlYXRlZCwgdHJhbnNpdGlvbnMgdG8gYSBuZXcgc3RhdGUsIG9yXG4gKiBpcyBiZWluZyBzdHJlYW1lZCBpbiBwYXJ0cyAoZGVsdGFzKS4gRm9yIGV4YW1wbGUsIHdlIGVtaXQgYHRocmVhZC5ydW4uY3JlYXRlZGBcbiAqIHdoZW4gYSBuZXcgcnVuIGlzIGNyZWF0ZWQsIGB0aHJlYWQucnVuLmNvbXBsZXRlZGAgd2hlbiBhIHJ1biBjb21wbGV0ZXMsIGFuZCBzb1xuICogb24uIFdoZW4gYW4gQXNzaXN0YW50IGNob29zZXMgdG8gY3JlYXRlIGEgbWVzc2FnZSBkdXJpbmcgYSBydW4sIHdlIGVtaXQgYVxuICogYHRocmVhZC5tZXNzYWdlLmNyZWF0ZWQgZXZlbnRgLCBhIGB0aHJlYWQubWVzc2FnZS5pbl9wcm9ncmVzc2AgZXZlbnQsIG1hbnlcbiAqIGB0aHJlYWQubWVzc2FnZS5kZWx0YWAgZXZlbnRzLCBhbmQgZmluYWxseSBhIGB0aHJlYWQubWVzc2FnZS5jb21wbGV0ZWRgIGV2ZW50LlxuICpcbiAqIFdlIG1heSBhZGQgYWRkaXRpb25hbCBldmVudHMgb3ZlciB0aW1lLCBzbyB3ZSByZWNvbW1lbmQgaGFuZGxpbmcgdW5rbm93biBldmVudHNcbiAqIGdyYWNlZnVsbHkgaW4geW91ciBjb2RlLiBTZWUgdGhlXG4gKiBbQXNzaXN0YW50cyBBUEkgcXVpY2tzdGFydF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy9vdmVydmlldylcbiAqIHRvIGxlYXJuIGhvdyB0byBpbnRlZ3JhdGUgdGhlIEFzc2lzdGFudHMgQVBJIHdpdGggc3RyZWFtaW5nLlxuICovXG5leHBvcnQgdHlwZSBBc3Npc3RhbnRTdHJlYW1FdmVudCA9XG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkQ3JlYXRlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1bkNyZWF0ZWRcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5RdWV1ZWRcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5JblByb2dyZXNzXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuUmVxdWlyZXNBY3Rpb25cbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5Db21wbGV0ZWRcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5JbmNvbXBsZXRlXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuRmFpbGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuQ2FuY2VsbGluZ1xuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1bkNhbmNlbGxlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1bkV4cGlyZWRcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwQ3JlYXRlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBJblByb2dyZXNzXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcERlbHRhXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcENvbXBsZXRlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBGYWlsZWRcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwQ2FuY2VsbGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcEV4cGlyZWRcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRNZXNzYWdlQ3JlYXRlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZE1lc3NhZ2VJblByb2dyZXNzXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkTWVzc2FnZURlbHRhXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkTWVzc2FnZUNvbXBsZXRlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZE1lc3NhZ2VJbmNvbXBsZXRlXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuRXJyb3JFdmVudDtcblxuZXhwb3J0IG5hbWVzcGFjZSBBc3Npc3RhbnRTdHJlYW1FdmVudCB7XG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIG5ld1xuICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMvb2JqZWN0KSBpc1xuICAgKiBjcmVhdGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRDcmVhdGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgdGhyZWFkIHRoYXQgY29udGFpbnNcbiAgICAgKiBbbWVzc2FnZXNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMpLlxuICAgICAqL1xuICAgIGRhdGE6IFRocmVhZHNBUEkuVGhyZWFkO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQuY3JlYXRlZCc7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBpbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uLlxuICAgICAqL1xuICAgIGVuYWJsZWQ/OiBib29sZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgbmV3XG4gICAqIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpIGlzIGNyZWF0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkNyZWF0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5jcmVhdGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIG1vdmVzIHRvIGEgYHF1ZXVlZGAgc3RhdHVzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5RdWV1ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5xdWV1ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogbW92ZXMgdG8gYW4gYGluX3Byb2dyZXNzYCBzdGF0dXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkluUHJvZ3Jlc3Mge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5pbl9wcm9ncmVzcyc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBtb3ZlcyB0byBhIGByZXF1aXJlc19hY3Rpb25gIHN0YXR1cy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuUmVxdWlyZXNBY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5yZXF1aXJlc19hY3Rpb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogaXMgY29tcGxldGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5Db21wbGV0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5jb21wbGV0ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogZW5kcyB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkluY29tcGxldGUge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5pbmNvbXBsZXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIGZhaWxzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5GYWlsZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5mYWlsZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogbW92ZXMgdG8gYSBgY2FuY2VsbGluZ2Agc3RhdHVzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5DYW5jZWxsaW5nIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uY2FuY2VsbGluZyc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBpcyBjYW5jZWxsZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkNhbmNlbGxlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmNhbmNlbGxlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBleHBpcmVzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5FeHBpcmVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uZXhwaXJlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBpcyBjcmVhdGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwQ3JlYXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5jcmVhdGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIG1vdmVzIHRvIGFuIGBpbl9wcm9ncmVzc2Agc3RhdGUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBJblByb2dyZXNzIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc3RlcCBpbiBleGVjdXRpb24gb2YgYSBydW4uXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmluX3Byb2dyZXNzJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBwYXJ0cyBvZiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIGFyZSBiZWluZyBzdHJlYW1lZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcERlbHRhIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgcnVuIHN0ZXAgZGVsdGEgaS5lLiBhbnkgY2hhbmdlZCBmaWVsZHMgb24gYSBydW4gc3RlcCBkdXJpbmdcbiAgICAgKiBzdHJlYW1pbmcuXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcERlbHRhRXZlbnQ7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5kZWx0YSc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBpcyBjb21wbGV0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBDb21wbGV0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuY29tcGxldGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIGZhaWxzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwRmFpbGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc3RlcCBpbiBleGVjdXRpb24gb2YgYSBydW4uXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmZhaWxlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBpcyBjYW5jZWxsZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBDYW5jZWxsZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuY2FuY2VsbGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIGV4cGlyZXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBFeHBpcmVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc3RlcCBpbiBleGVjdXRpb24gb2YgYSBydW4uXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmV4cGlyZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW21lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMvb2JqZWN0KSBpc1xuICAgKiBjcmVhdGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRNZXNzYWdlQ3JlYXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIG1lc3NhZ2Ugd2l0aGluIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IE1lc3NhZ2VzQVBJLk1lc3NhZ2U7XG5cbiAgICBldmVudDogJ3RocmVhZC5tZXNzYWdlLmNyZWF0ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW21lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMvb2JqZWN0KSBtb3Zlc1xuICAgKiB0byBhbiBgaW5fcHJvZ3Jlc3NgIHN0YXRlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRNZXNzYWdlSW5Qcm9ncmVzcyB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIG1lc3NhZ2Ugd2l0aGluIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IE1lc3NhZ2VzQVBJLk1lc3NhZ2U7XG5cbiAgICBldmVudDogJ3RocmVhZC5tZXNzYWdlLmluX3Byb2dyZXNzJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBwYXJ0cyBvZiBhXG4gICAqIFtNZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzL29iamVjdCkgYXJlXG4gICAqIGJlaW5nIHN0cmVhbWVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRNZXNzYWdlRGVsdGEge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIGRlbHRhIGkuZS4gYW55IGNoYW5nZWQgZmllbGRzIG9uIGEgbWVzc2FnZSBkdXJpbmdcbiAgICAgKiBzdHJlYW1pbmcuXG4gICAgICovXG4gICAgZGF0YTogTWVzc2FnZXNBUEkuTWVzc2FnZURlbHRhRXZlbnQ7XG5cbiAgICBldmVudDogJ3RocmVhZC5tZXNzYWdlLmRlbHRhJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFttZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzL29iamVjdCkgaXNcbiAgICogY29tcGxldGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRNZXNzYWdlQ29tcGxldGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgbWVzc2FnZSB3aXRoaW4gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogTWVzc2FnZXNBUEkuTWVzc2FnZTtcblxuICAgIGV2ZW50OiAndGhyZWFkLm1lc3NhZ2UuY29tcGxldGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFttZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzL29iamVjdCkgZW5kc1xuICAgKiBiZWZvcmUgaXQgaXMgY29tcGxldGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRNZXNzYWdlSW5jb21wbGV0ZSB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIG1lc3NhZ2Ugd2l0aGluIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IE1lc3NhZ2VzQVBJLk1lc3NhZ2U7XG5cbiAgICBldmVudDogJ3RocmVhZC5tZXNzYWdlLmluY29tcGxldGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFuXG4gICAqIFtlcnJvcl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2Vycm9yLWNvZGVzI2FwaS1lcnJvcnMpIG9jY3Vycy5cbiAgICogVGhpcyBjYW4gaGFwcGVuIGR1ZSB0byBhbiBpbnRlcm5hbCBzZXJ2ZXIgZXJyb3Igb3IgYSB0aW1lb3V0LlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBFcnJvckV2ZW50IHtcbiAgICBkYXRhOiBTaGFyZWQuRXJyb3JPYmplY3Q7XG5cbiAgICBldmVudDogJ2Vycm9yJztcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBBc3Npc3RhbnRUb29sID0gQ29kZUludGVycHJldGVyVG9vbCB8IEZpbGVTZWFyY2hUb29sIHwgRnVuY3Rpb25Ub29sO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlclRvb2wge1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdG9vbCBiZWluZyBkZWZpbmVkOiBgY29kZV9pbnRlcnByZXRlcmBcbiAgICovXG4gIHR5cGU6ICdjb2RlX2ludGVycHJldGVyJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoVG9vbCB7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0b29sIGJlaW5nIGRlZmluZWQ6IGBmaWxlX3NlYXJjaGBcbiAgICovXG4gIHR5cGU6ICdmaWxlX3NlYXJjaCc7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBmb3IgdGhlIGZpbGUgc2VhcmNoIHRvb2wuXG4gICAqL1xuICBmaWxlX3NlYXJjaD86IEZpbGVTZWFyY2hUb29sLkZpbGVTZWFyY2g7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRmlsZVNlYXJjaFRvb2wge1xuICAvKipcbiAgICogT3ZlcnJpZGVzIGZvciB0aGUgZmlsZSBzZWFyY2ggdG9vbC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlc3VsdHMgdGhlIGZpbGUgc2VhcmNoIHRvb2wgc2hvdWxkIG91dHB1dC4gVGhlIGRlZmF1bHQgaXNcbiAgICAgKiAyMCBmb3IgYGdwdC00KmAgbW9kZWxzIGFuZCA1IGZvciBgZ3B0LTMuNS10dXJib2AuIFRoaXMgbnVtYmVyIHNob3VsZCBiZSBiZXR3ZWVuXG4gICAgICogMSBhbmQgNTAgaW5jbHVzaXZlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBmaWxlIHNlYXJjaCB0b29sIG1heSBvdXRwdXQgZmV3ZXIgdGhhbiBgbWF4X251bV9yZXN1bHRzYCByZXN1bHRzLlxuICAgICAqIFNlZSB0aGVcbiAgICAgKiBbZmlsZSBzZWFyY2ggdG9vbCBkb2N1bWVudGF0aW9uXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL3Rvb2xzL2ZpbGUtc2VhcmNoI2N1c3RvbWl6aW5nLWZpbGUtc2VhcmNoLXNldHRpbmdzKVxuICAgICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIG1heF9udW1fcmVzdWx0cz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSByYW5raW5nIG9wdGlvbnMgZm9yIHRoZSBmaWxlIHNlYXJjaC4gSWYgbm90IHNwZWNpZmllZCwgdGhlIGZpbGUgc2VhcmNoIHRvb2xcbiAgICAgKiB3aWxsIHVzZSB0aGUgYGF1dG9gIHJhbmtlciBhbmQgYSBzY29yZV90aHJlc2hvbGQgb2YgMC5cbiAgICAgKlxuICAgICAqIFNlZSB0aGVcbiAgICAgKiBbZmlsZSBzZWFyY2ggdG9vbCBkb2N1bWVudGF0aW9uXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL3Rvb2xzL2ZpbGUtc2VhcmNoI2N1c3RvbWl6aW5nLWZpbGUtc2VhcmNoLXNldHRpbmdzKVxuICAgICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIHJhbmtpbmdfb3B0aW9ucz86IEZpbGVTZWFyY2guUmFua2luZ09wdGlvbnM7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIEZpbGVTZWFyY2gge1xuICAgIC8qKlxuICAgICAqIFRoZSByYW5raW5nIG9wdGlvbnMgZm9yIHRoZSBmaWxlIHNlYXJjaC4gSWYgbm90IHNwZWNpZmllZCwgdGhlIGZpbGUgc2VhcmNoIHRvb2xcbiAgICAgKiB3aWxsIHVzZSB0aGUgYGF1dG9gIHJhbmtlciBhbmQgYSBzY29yZV90aHJlc2hvbGQgb2YgMC5cbiAgICAgKlxuICAgICAqIFNlZSB0aGVcbiAgICAgKiBbZmlsZSBzZWFyY2ggdG9vbCBkb2N1bWVudGF0aW9uXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL3Rvb2xzL2ZpbGUtc2VhcmNoI2N1c3RvbWl6aW5nLWZpbGUtc2VhcmNoLXNldHRpbmdzKVxuICAgICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgUmFua2luZ09wdGlvbnMge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgc2NvcmUgdGhyZXNob2xkIGZvciB0aGUgZmlsZSBzZWFyY2guIEFsbCB2YWx1ZXMgbXVzdCBiZSBhIGZsb2F0aW5nIHBvaW50XG4gICAgICAgKiBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAgICovXG4gICAgICBzY29yZV90aHJlc2hvbGQ6IG51bWJlcjtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcmFua2VyIHRvIHVzZSBmb3IgdGhlIGZpbGUgc2VhcmNoLiBJZiBub3Qgc3BlY2lmaWVkIHdpbGwgdXNlIHRoZSBgYXV0b2BcbiAgICAgICAqIHJhbmtlci5cbiAgICAgICAqL1xuICAgICAgcmFua2VyPzogJ2F1dG8nIHwgJ2RlZmF1bHRfMjAyNF8wOF8yMSc7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25Ub29sIHtcbiAgZnVuY3Rpb246IFNoYXJlZC5GdW5jdGlvbkRlZmluaXRpb247XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRvb2wgYmVpbmcgZGVmaW5lZDogYGZ1bmN0aW9uYFxuICAgKi9cbiAgdHlwZTogJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBPY2N1cnMgd2hlbiBhXG4gKiBbbWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcy9vYmplY3QpIGlzXG4gKiBjcmVhdGVkLlxuICovXG5leHBvcnQgdHlwZSBNZXNzYWdlU3RyZWFtRXZlbnQgPVxuICB8IE1lc3NhZ2VTdHJlYW1FdmVudC5UaHJlYWRNZXNzYWdlQ3JlYXRlZFxuICB8IE1lc3NhZ2VTdHJlYW1FdmVudC5UaHJlYWRNZXNzYWdlSW5Qcm9ncmVzc1xuICB8IE1lc3NhZ2VTdHJlYW1FdmVudC5UaHJlYWRNZXNzYWdlRGVsdGFcbiAgfCBNZXNzYWdlU3RyZWFtRXZlbnQuVGhyZWFkTWVzc2FnZUNvbXBsZXRlZFxuICB8IE1lc3NhZ2VTdHJlYW1FdmVudC5UaHJlYWRNZXNzYWdlSW5jb21wbGV0ZTtcblxuZXhwb3J0IG5hbWVzcGFjZSBNZXNzYWdlU3RyZWFtRXZlbnQge1xuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbbWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcy9vYmplY3QpIGlzXG4gICAqIGNyZWF0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZE1lc3NhZ2VDcmVhdGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgbWVzc2FnZSB3aXRoaW4gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogTWVzc2FnZXNBUEkuTWVzc2FnZTtcblxuICAgIGV2ZW50OiAndGhyZWFkLm1lc3NhZ2UuY3JlYXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbbWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcy9vYmplY3QpIG1vdmVzXG4gICAqIHRvIGFuIGBpbl9wcm9ncmVzc2Agc3RhdGUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZE1lc3NhZ2VJblByb2dyZXNzIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgbWVzc2FnZSB3aXRoaW4gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogTWVzc2FnZXNBUEkuTWVzc2FnZTtcblxuICAgIGV2ZW50OiAndGhyZWFkLm1lc3NhZ2UuaW5fcHJvZ3Jlc3MnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIHBhcnRzIG9mIGFcbiAgICogW01lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMvb2JqZWN0KSBhcmVcbiAgICogYmVpbmcgc3RyZWFtZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZE1lc3NhZ2VEZWx0YSB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIG1lc3NhZ2UgZGVsdGEgaS5lLiBhbnkgY2hhbmdlZCBmaWVsZHMgb24gYSBtZXNzYWdlIGR1cmluZ1xuICAgICAqIHN0cmVhbWluZy5cbiAgICAgKi9cbiAgICBkYXRhOiBNZXNzYWdlc0FQSS5NZXNzYWdlRGVsdGFFdmVudDtcblxuICAgIGV2ZW50OiAndGhyZWFkLm1lc3NhZ2UuZGVsdGEnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW21lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMvb2JqZWN0KSBpc1xuICAgKiBjb21wbGV0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZE1lc3NhZ2VDb21wbGV0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIHdpdGhpbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBNZXNzYWdlc0FQSS5NZXNzYWdlO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQubWVzc2FnZS5jb21wbGV0ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW21lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMvb2JqZWN0KSBlbmRzXG4gICAqIGJlZm9yZSBpdCBpcyBjb21wbGV0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZE1lc3NhZ2VJbmNvbXBsZXRlIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgbWVzc2FnZSB3aXRoaW4gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogTWVzc2FnZXNBUEkuTWVzc2FnZTtcblxuICAgIGV2ZW50OiAndGhyZWFkLm1lc3NhZ2UuaW5jb21wbGV0ZSc7XG4gIH1cbn1cblxuLyoqXG4gKiBPY2N1cnMgd2hlbiBhXG4gKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICogaXMgY3JlYXRlZC5cbiAqL1xuZXhwb3J0IHR5cGUgUnVuU3RlcFN0cmVhbUV2ZW50ID1cbiAgfCBSdW5TdGVwU3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcENyZWF0ZWRcbiAgfCBSdW5TdGVwU3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcEluUHJvZ3Jlc3NcbiAgfCBSdW5TdGVwU3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcERlbHRhXG4gIHwgUnVuU3RlcFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBDb21wbGV0ZWRcbiAgfCBSdW5TdGVwU3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcEZhaWxlZFxuICB8IFJ1blN0ZXBTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwQ2FuY2VsbGVkXG4gIHwgUnVuU3RlcFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBFeHBpcmVkO1xuXG5leHBvcnQgbmFtZXNwYWNlIFJ1blN0ZXBTdHJlYW1FdmVudCB7XG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIGlzIGNyZWF0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBDcmVhdGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc3RlcCBpbiBleGVjdXRpb24gb2YgYSBydW4uXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmNyZWF0ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogbW92ZXMgdG8gYW4gYGluX3Byb2dyZXNzYCBzdGF0ZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcEluUHJvZ3Jlc3Mge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuaW5fcHJvZ3Jlc3MnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIHBhcnRzIG9mIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogYXJlIGJlaW5nIHN0cmVhbWVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwRGVsdGEge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBydW4gc3RlcCBkZWx0YSBpLmUuIGFueSBjaGFuZ2VkIGZpZWxkcyBvbiBhIHJ1biBzdGVwIGR1cmluZ1xuICAgICAqIHN0cmVhbWluZy5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwRGVsdGFFdmVudDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmRlbHRhJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIGlzIGNvbXBsZXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcENvbXBsZXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5jb21wbGV0ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogZmFpbHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBGYWlsZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuZmFpbGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIGlzIGNhbmNlbGxlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcENhbmNlbGxlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5jYW5jZWxsZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogZXhwaXJlcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcEV4cGlyZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuZXhwaXJlZCc7XG4gIH1cbn1cblxuLyoqXG4gKiBPY2N1cnMgd2hlbiBhIG5ld1xuICogW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdCkgaXMgY3JlYXRlZC5cbiAqL1xuZXhwb3J0IHR5cGUgUnVuU3RyZWFtRXZlbnQgPVxuICB8IFJ1blN0cmVhbUV2ZW50LlRocmVhZFJ1bkNyZWF0ZWRcbiAgfCBSdW5TdHJlYW1FdmVudC5UaHJlYWRSdW5RdWV1ZWRcbiAgfCBSdW5TdHJlYW1FdmVudC5UaHJlYWRSdW5JblByb2dyZXNzXG4gIHwgUnVuU3RyZWFtRXZlbnQuVGhyZWFkUnVuUmVxdWlyZXNBY3Rpb25cbiAgfCBSdW5TdHJlYW1FdmVudC5UaHJlYWRSdW5Db21wbGV0ZWRcbiAgfCBSdW5TdHJlYW1FdmVudC5UaHJlYWRSdW5JbmNvbXBsZXRlXG4gIHwgUnVuU3RyZWFtRXZlbnQuVGhyZWFkUnVuRmFpbGVkXG4gIHwgUnVuU3RyZWFtRXZlbnQuVGhyZWFkUnVuQ2FuY2VsbGluZ1xuICB8IFJ1blN0cmVhbUV2ZW50LlRocmVhZFJ1bkNhbmNlbGxlZFxuICB8IFJ1blN0cmVhbUV2ZW50LlRocmVhZFJ1bkV4cGlyZWQ7XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuU3RyZWFtRXZlbnQge1xuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBuZXdcbiAgICogW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdCkgaXMgY3JlYXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuQ3JlYXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmNyZWF0ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogbW92ZXMgdG8gYSBgcXVldWVkYCBzdGF0dXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blF1ZXVlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnF1ZXVlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBtb3ZlcyB0byBhbiBgaW5fcHJvZ3Jlc3NgIHN0YXR1cy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuSW5Qcm9ncmVzcyB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmluX3Byb2dyZXNzJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIG1vdmVzIHRvIGEgYHJlcXVpcmVzX2FjdGlvbmAgc3RhdHVzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5SZXF1aXJlc0FjdGlvbiB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnJlcXVpcmVzX2FjdGlvbic7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBpcyBjb21wbGV0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkNvbXBsZXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmNvbXBsZXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBlbmRzIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuSW5jb21wbGV0ZSB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmluY29tcGxldGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogZmFpbHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkZhaWxlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmZhaWxlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBtb3ZlcyB0byBhIGBjYW5jZWxsaW5nYCBzdGF0dXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkNhbmNlbGxpbmcge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5jYW5jZWxsaW5nJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIGlzIGNhbmNlbGxlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuQ2FuY2VsbGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uY2FuY2VsbGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIGV4cGlyZXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkV4cGlyZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5leHBpcmVkJztcbiAgfVxufVxuXG4vKipcbiAqIE9jY3VycyB3aGVuIGEgbmV3XG4gKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMvb2JqZWN0KSBpc1xuICogY3JlYXRlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUaHJlYWRTdHJlYW1FdmVudCB7XG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgdGhyZWFkIHRoYXQgY29udGFpbnNcbiAgICogW21lc3NhZ2VzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzKS5cbiAgICovXG4gIGRhdGE6IFRocmVhZHNBUEkuVGhyZWFkO1xuXG4gIGV2ZW50OiAndGhyZWFkLmNyZWF0ZWQnO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBpbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uLlxuICAgKi9cbiAgZW5hYmxlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXNzaXN0YW50Q3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIElEIG9mIHRoZSBtb2RlbCB0byB1c2UuIFlvdSBjYW4gdXNlIHRoZVxuICAgKiBbTGlzdCBtb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzL2xpc3QpIEFQSSB0b1xuICAgKiBzZWUgYWxsIG9mIHlvdXIgYXZhaWxhYmxlIG1vZGVscywgb3Igc2VlIG91clxuICAgKiBbTW9kZWwgb3ZlcnZpZXddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscykgZm9yIGRlc2NyaXB0aW9ucyBvZlxuICAgKiB0aGVtLlxuICAgKi9cbiAgbW9kZWw6IChzdHJpbmcgJiB7fSkgfCBDaGF0QVBJLkNoYXRNb2RlbDtcblxuICAvKipcbiAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBhc3Npc3RhbnQuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyA1MTIgY2hhcmFjdGVycy5cbiAgICovXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHN5c3RlbSBpbnN0cnVjdGlvbnMgdGhhdCB0aGUgYXNzaXN0YW50IHVzZXMuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyAyNTYsMDAwXG4gICAqIGNoYXJhY3RlcnMuXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgYXNzaXN0YW50LiBUaGUgbWF4aW11bSBsZW5ndGggaXMgMjU2IGNoYXJhY3RlcnMuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBmb3JtYXQgdGhhdCB0aGUgbW9kZWwgbXVzdCBvdXRwdXQuIENvbXBhdGlibGUgd2l0aFxuICAgKiBbR1BULTRvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTRvKSxcbiAgICogW0dQVC00IFR1cmJvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTQtdHVyYm8tYW5kLWdwdC00KSxcbiAgICogYW5kIGFsbCBHUFQtMy41IFR1cmJvIG1vZGVscyBzaW5jZSBgZ3B0LTMuNS10dXJiby0xMTA2YC5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX3NjaGVtYVwiLCBcImpzb25fc2NoZW1hXCI6IHsuLi59IH1gIGVuYWJsZXMgU3RydWN0dXJlZFxuICAgKiBPdXRwdXRzIHdoaWNoIGVuc3VyZXMgdGhlIG1vZGVsIHdpbGwgbWF0Y2ggeW91ciBzdXBwbGllZCBKU09OIHNjaGVtYS4gTGVhcm4gbW9yZVxuICAgKiBpbiB0aGVcbiAgICogW1N0cnVjdHVyZWQgT3V0cHV0cyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3N0cnVjdHVyZWQtb3V0cHV0cykuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9vYmplY3RcIiB9YCBlbmFibGVzIEpTT04gbW9kZSwgd2hpY2ggZW5zdXJlcyB0aGVcbiAgICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gICAqXG4gICAqICoqSW1wb3J0YW50OioqIHdoZW4gdXNpbmcgSlNPTiBtb2RlLCB5b3UgKiptdXN0KiogYWxzbyBpbnN0cnVjdCB0aGUgbW9kZWwgdG9cbiAgICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICAgKiBnZW5lcmF0ZSBhbiB1bmVuZGluZyBzdHJlYW0gb2Ygd2hpdGVzcGFjZSB1bnRpbCB0aGUgZ2VuZXJhdGlvbiByZWFjaGVzIHRoZSB0b2tlblxuICAgKiBsaW1pdCwgcmVzdWx0aW5nIGluIGEgbG9uZy1ydW5uaW5nIGFuZCBzZWVtaW5nbHkgXCJzdHVja1wiIHJlcXVlc3QuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICAgKiBpbmRpY2F0ZXMgdGhlIGdlbmVyYXRpb24gZXhjZWVkZWQgYG1heF90b2tlbnNgIG9yIHRoZSBjb252ZXJzYXRpb24gZXhjZWVkZWQgdGhlXG4gICAqIG1heCBjb250ZXh0IGxlbmd0aC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86IFRocmVhZHNBUEkuQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIGFzc2lzdGFudCdzIHRvb2xzLiBUaGUgcmVzb3VyY2VzIGFyZVxuICAgKiBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzXG4gICAqIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlXG4gICAqIElEcy5cbiAgICovXG4gIHRvb2xfcmVzb3VyY2VzPzogQXNzaXN0YW50Q3JlYXRlUGFyYW1zLlRvb2xSZXNvdXJjZXMgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdG9vbCBlbmFibGVkIG9uIHRoZSBhc3Npc3RhbnQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMTI4IHRvb2xzIHBlclxuICAgKiBhc3Npc3RhbnQuIFRvb2xzIGNhbiBiZSBvZiB0eXBlcyBgY29kZV9pbnRlcnByZXRlcmAsIGBmaWxlX3NlYXJjaGAsIG9yXG4gICAqIGBmdW5jdGlvbmAuXG4gICAqL1xuICB0b29scz86IEFycmF5PEFzc2lzdGFudFRvb2w+O1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQXNzaXN0YW50Q3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBhc3Npc3RhbnQncyB0b29scy4gVGhlIHJlc291cmNlcyBhcmVcbiAgICogc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlc1xuICAgKiBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZVxuICAgKiBJRHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGNvZGVfaW50ZXJwcmV0ZXI/OiBUb29sUmVzb3VyY2VzLkNvZGVJbnRlcnByZXRlcjtcblxuICAgIGZpbGVfc2VhcmNoPzogVG9vbFJlc291cmNlcy5GaWxlU2VhcmNoO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIG1hZGVcbiAgICAgICAqIGF2YWlsYWJsZSB0byB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMjAgZmlsZXNcbiAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9vbC5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZVxuICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgYXNzaXN0YW50LiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvXG4gICAgICAgKiB0aGUgYXNzaXN0YW50LlxuICAgICAgICovXG4gICAgICB2ZWN0b3Jfc3RvcmVfaWRzPzogQXJyYXk8c3RyaW5nPjtcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGhlbHBlciB0byBjcmVhdGUgYVxuICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAqIHdpdGggZmlsZV9pZHMgYW5kIGF0dGFjaCBpdCB0byB0aGlzIGFzc2lzdGFudC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxXG4gICAgICAgKiB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG8gdGhlIGFzc2lzdGFudC5cbiAgICAgICAqL1xuICAgICAgdmVjdG9yX3N0b3Jlcz86IEFycmF5PEZpbGVTZWFyY2guVmVjdG9yU3RvcmU+O1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgRmlsZVNlYXJjaCB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjaHVua2luZyBzdHJhdGVneSB1c2VkIHRvIGNodW5rIHRoZSBmaWxlKHMpLiBJZiBub3Qgc2V0LCB3aWxsIHVzZSB0aGUgYGF1dG9gXG4gICAgICAgICAqIHN0cmF0ZWd5LiBPbmx5IGFwcGxpY2FibGUgaWYgYGZpbGVfaWRzYCBpcyBub24tZW1wdHkuXG4gICAgICAgICAqL1xuICAgICAgICBjaHVua2luZ19zdHJhdGVneT86IFZlY3RvclN0b3Jlc0FQSS5GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyB0b1xuICAgICAgICAgKiBhZGQgdG8gdGhlIHZlY3RvciBzdG9yZS4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxMDAwMCBmaWxlcyBpbiBhIHZlY3RvclxuICAgICAgICAgKiBzdG9yZS5cbiAgICAgICAgICovXG4gICAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIHZlY3RvciBzdG9yZS4gVGhpcyBjYW4gYmVcbiAgICAgICAgICogdXNlZnVsIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZlY3RvciBzdG9yZSBpbiBhIHN0cnVjdHVyZWRcbiAgICAgICAgICogZm9ybWF0LiBLZXlzIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtXG4gICAgICAgICAqIG9mIDUxMiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICAgICAqL1xuICAgICAgICBtZXRhZGF0YT86IHVua25vd247XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXNzaXN0YW50VXBkYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYXNzaXN0YW50LiBUaGUgbWF4aW11bSBsZW5ndGggaXMgNTEyIGNoYXJhY3RlcnMuXG4gICAqL1xuICBkZXNjcmlwdGlvbj86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzeXN0ZW0gaW5zdHJ1Y3Rpb25zIHRoYXQgdGhlIGFzc2lzdGFudCB1c2VzLiBUaGUgbWF4aW11bSBsZW5ndGggaXMgMjU2LDAwMFxuICAgKiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogSUQgb2YgdGhlIG1vZGVsIHRvIHVzZS4gWW91IGNhbiB1c2UgdGhlXG4gICAqIFtMaXN0IG1vZGVsc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tb2RlbHMvbGlzdCkgQVBJIHRvXG4gICAqIHNlZSBhbGwgb2YgeW91ciBhdmFpbGFibGUgbW9kZWxzLCBvciBzZWUgb3VyXG4gICAqIFtNb2RlbCBvdmVydmlld10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzKSBmb3IgZGVzY3JpcHRpb25zIG9mXG4gICAqIHRoZW0uXG4gICAqL1xuICBtb2RlbD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGFzc2lzdGFudC4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDI1NiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAgICogW0dQVC00b10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00byksXG4gICAqIFtHUFQtNCBUdXJib10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00LXR1cmJvLWFuZC1ncHQtNCksXG4gICAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9zY2hlbWFcIiwgXCJqc29uX3NjaGVtYVwiOiB7Li4ufSB9YCBlbmFibGVzIFN0cnVjdHVyZWRcbiAgICogT3V0cHV0cyB3aGljaCBlbnN1cmVzIHRoZSBtb2RlbCB3aWxsIG1hdGNoIHlvdXIgc3VwcGxpZWQgSlNPTiBzY2hlbWEuIExlYXJuIG1vcmVcbiAgICogaW4gdGhlXG4gICAqIFtTdHJ1Y3R1cmVkIE91dHB1dHMgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zdHJ1Y3R1cmVkLW91dHB1dHMpLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGVuc3VyZXMgdGhlXG4gICAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICAgKlxuICAgKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gICAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAgICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAgICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAgICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICAgKiBtYXggY29udGV4dCBsZW5ndGguXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBUaHJlYWRzQVBJLkFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBhc3Npc3RhbnQncyB0b29scy4gVGhlIHJlc291cmNlcyBhcmVcbiAgICogc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlc1xuICAgKiBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZVxuICAgKiBJRHMuXG4gICAqL1xuICB0b29sX3Jlc291cmNlcz86IEFzc2lzdGFudFVwZGF0ZVBhcmFtcy5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIHRvb2wgZW5hYmxlZCBvbiB0aGUgYXNzaXN0YW50LiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEyOCB0b29scyBwZXJcbiAgICogYXNzaXN0YW50LiBUb29scyBjYW4gYmUgb2YgdHlwZXMgYGNvZGVfaW50ZXJwcmV0ZXJgLCBgZmlsZV9zZWFyY2hgLCBvclxuICAgKiBgZnVuY3Rpb25gLlxuICAgKi9cbiAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRUb29sPjtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgdGVtcGVyYXR1cmUgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdG9wX3A/OiBudW1iZXIgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEFzc2lzdGFudFVwZGF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgdXNlZCBieSB0aGUgYXNzaXN0YW50J3MgdG9vbHMuIFRoZSByZXNvdXJjZXMgYXJlXG4gICAqIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXNcbiAgICogYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVcbiAgICogSURzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgdGhlIGxpc3Qgb2ZcbiAgICAgICAqIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgbWFkZSBhdmFpbGFibGVcbiAgICAgICAqIHRvIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlcyBhc3NvY2lhdGVkXG4gICAgICAgKiB3aXRoIHRoZSB0b29sLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIHRoZVxuICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgYXNzaXN0YW50LiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvXG4gICAgICAgKiB0aGUgYXNzaXN0YW50LlxuICAgICAgICovXG4gICAgICB2ZWN0b3Jfc3RvcmVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBc3Npc3RhbnRMaXN0UGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIGN1cnNvciBmb3IgdXNlIGluIHBhZ2luYXRpb24uIGBiZWZvcmVgIGlzIGFuIG9iamVjdCBJRCB0aGF0IGRlZmluZXMgeW91ciBwbGFjZVxuICAgKiBpbiB0aGUgbGlzdC4gRm9yIGluc3RhbmNlLCBpZiB5b3UgbWFrZSBhIGxpc3QgcmVxdWVzdCBhbmQgcmVjZWl2ZSAxMDAgb2JqZWN0cyxcbiAgICogc3RhcnRpbmcgd2l0aCBvYmpfZm9vLCB5b3VyIHN1YnNlcXVlbnQgY2FsbCBjYW4gaW5jbHVkZSBiZWZvcmU9b2JqX2ZvbyBpbiBvcmRlclxuICAgKiB0byBmZXRjaCB0aGUgcHJldmlvdXMgcGFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGJlZm9yZT86IHN0cmluZztcblxuICAvKipcbiAgICogU29ydCBvcmRlciBieSB0aGUgYGNyZWF0ZWRfYXRgIHRpbWVzdGFtcCBvZiB0aGUgb2JqZWN0cy4gYGFzY2AgZm9yIGFzY2VuZGluZ1xuICAgKiBvcmRlciBhbmQgYGRlc2NgIGZvciBkZXNjZW5kaW5nIG9yZGVyLlxuICAgKi9cbiAgb3JkZXI/OiAnYXNjJyB8ICdkZXNjJztcbn1cblxuQXNzaXN0YW50cy5Bc3Npc3RhbnRzUGFnZSA9IEFzc2lzdGFudHNQYWdlO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgQXNzaXN0YW50cyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBBc3Npc3RhbnQgYXMgQXNzaXN0YW50LFxuICAgIHR5cGUgQXNzaXN0YW50RGVsZXRlZCBhcyBBc3Npc3RhbnREZWxldGVkLFxuICAgIHR5cGUgQXNzaXN0YW50U3RyZWFtRXZlbnQgYXMgQXNzaXN0YW50U3RyZWFtRXZlbnQsXG4gICAgdHlwZSBBc3Npc3RhbnRUb29sIGFzIEFzc2lzdGFudFRvb2wsXG4gICAgdHlwZSBDb2RlSW50ZXJwcmV0ZXJUb29sIGFzIENvZGVJbnRlcnByZXRlclRvb2wsXG4gICAgdHlwZSBGaWxlU2VhcmNoVG9vbCBhcyBGaWxlU2VhcmNoVG9vbCxcbiAgICB0eXBlIEZ1bmN0aW9uVG9vbCBhcyBGdW5jdGlvblRvb2wsXG4gICAgdHlwZSBNZXNzYWdlU3RyZWFtRXZlbnQgYXMgTWVzc2FnZVN0cmVhbUV2ZW50LFxuICAgIHR5cGUgUnVuU3RlcFN0cmVhbUV2ZW50IGFzIFJ1blN0ZXBTdHJlYW1FdmVudCxcbiAgICB0eXBlIFJ1blN0cmVhbUV2ZW50IGFzIFJ1blN0cmVhbUV2ZW50LFxuICAgIHR5cGUgVGhyZWFkU3RyZWFtRXZlbnQgYXMgVGhyZWFkU3RyZWFtRXZlbnQsXG4gICAgQXNzaXN0YW50c1BhZ2UgYXMgQXNzaXN0YW50c1BhZ2UsXG4gICAgdHlwZSBBc3Npc3RhbnRDcmVhdGVQYXJhbXMgYXMgQXNzaXN0YW50Q3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgQXNzaXN0YW50VXBkYXRlUGFyYW1zIGFzIEFzc2lzdGFudFVwZGF0ZVBhcmFtcyxcbiAgICB0eXBlIEFzc2lzdGFudExpc3RQYXJhbXMgYXMgQXNzaXN0YW50TGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyB0eXBlIENoYXRDb21wbGV0aW9uUnVubmVyIH0gZnJvbSAnLi9DaGF0Q29tcGxldGlvblJ1bm5lcic7XG5pbXBvcnQgeyB0eXBlIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyIH0gZnJvbSAnLi9DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcic7XG5pbXBvcnQgeyBKU09OU2NoZW1hIH0gZnJvbSAnLi9qc29uc2NoZW1hJztcblxudHlwZSBQcm9taXNlT3JWYWx1ZTxUPiA9IFQgfCBQcm9taXNlPFQ+O1xuXG5leHBvcnQgdHlwZSBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3MgZXh0ZW5kcyBvYmplY3Q+ID0ge1xuICAvKipcbiAgICogQHBhcmFtIGFyZ3MgdGhlIHJldHVybiB2YWx1ZSBmcm9tIGBwYXJzZWAuXG4gICAqIEBwYXJhbSBydW5uZXIgdGhlIHJ1bm5lciBldmFsdWF0aW5nIHRoaXMgY2FsbGJhY2suXG4gICAqIEByZXR1cm5zIGEgc3RyaW5nIHRvIHNlbmQgYmFjayB0byBPcGVuQUkuXG4gICAqL1xuICBmdW5jdGlvbjogKFxuICAgIGFyZ3M6IEFyZ3MsXG4gICAgcnVubmVyOiBDaGF0Q29tcGxldGlvblJ1bm5lcjx1bmtub3duPiB8IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyPHVua25vd24+LFxuICApID0+IFByb21pc2VPclZhbHVlPHVua25vd24+O1xuICAvKipcbiAgICogQHBhcmFtIGlucHV0IHRoZSByYXcgYXJncyBmcm9tIHRoZSBPcGVuQUkgZnVuY3Rpb24gY2FsbC5cbiAgICogQHJldHVybnMgdGhlIHBhcnNlZCBhcmd1bWVudHMgdG8gcGFzcyB0byBgZnVuY3Rpb25gXG4gICAqL1xuICBwYXJzZTogKGlucHV0OiBzdHJpbmcpID0+IFByb21pc2VPclZhbHVlPEFyZ3M+O1xuICAvKipcbiAgICogVGhlIHBhcmFtZXRlcnMgdGhlIGZ1bmN0aW9uIGFjY2VwdHMsIGRlc2NyaWJlcyBhcyBhIEpTT04gU2NoZW1hIG9iamVjdC5cbiAgICovXG4gIHBhcmFtZXRlcnM6IEpTT05TY2hlbWE7XG4gIC8qKlxuICAgKiBBIGRlc2NyaXB0aW9uIG9mIHdoYXQgdGhlIGZ1bmN0aW9uIGRvZXMsIHVzZWQgYnkgdGhlIG1vZGVsIHRvIGNob29zZSB3aGVuIGFuZCBob3cgdG8gY2FsbCB0aGUgZnVuY3Rpb24uXG4gICAqL1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC4gV2lsbCBkZWZhdWx0IHRvIGZ1bmN0aW9uLm5hbWUgaWYgb21pdHRlZC5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHN0cmljdD86IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgdHlwZSBSdW5uYWJsZUZ1bmN0aW9uV2l0aG91dFBhcnNlID0ge1xuICAvKipcbiAgICogQHBhcmFtIGFyZ3MgdGhlIHJhdyBhcmdzIGZyb20gdGhlIE9wZW5BSSBmdW5jdGlvbiBjYWxsLlxuICAgKiBAcmV0dXJucyBhIHN0cmluZyB0byBzZW5kIGJhY2sgdG8gT3BlbkFJXG4gICAqL1xuICBmdW5jdGlvbjogKFxuICAgIGFyZ3M6IHN0cmluZyxcbiAgICBydW5uZXI6IENoYXRDb21wbGV0aW9uUnVubmVyPHVua25vd24+IHwgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXI8dW5rbm93bj4sXG4gICkgPT4gUHJvbWlzZU9yVmFsdWU8dW5rbm93bj47XG4gIC8qKlxuICAgKiBUaGUgcGFyYW1ldGVycyB0aGUgZnVuY3Rpb24gYWNjZXB0cywgZGVzY3JpYmVzIGFzIGEgSlNPTiBTY2hlbWEgb2JqZWN0LlxuICAgKi9cbiAgcGFyYW1ldGVyczogSlNPTlNjaGVtYTtcbiAgLyoqXG4gICAqIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgZnVuY3Rpb24gZG9lcywgdXNlZCBieSB0aGUgbW9kZWwgdG8gY2hvb3NlIHdoZW4gYW5kIGhvdyB0byBjYWxsIHRoZSBmdW5jdGlvbi5cbiAgICovXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLiBXaWxsIGRlZmF1bHQgdG8gZnVuY3Rpb24ubmFtZSBpZiBvbWl0dGVkLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgc3RyaWN0PzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCB0eXBlIFJ1bm5hYmxlRnVuY3Rpb248QXJncyBleHRlbmRzIG9iamVjdCB8IHN0cmluZz4gPVxuICBBcmdzIGV4dGVuZHMgc3RyaW5nID8gUnVubmFibGVGdW5jdGlvbldpdGhvdXRQYXJzZVxuICA6IEFyZ3MgZXh0ZW5kcyBvYmplY3QgPyBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3M+XG4gIDogbmV2ZXI7XG5cbmV4cG9ydCB0eXBlIFJ1bm5hYmxlVG9vbEZ1bmN0aW9uPEFyZ3MgZXh0ZW5kcyBvYmplY3QgfCBzdHJpbmc+ID1cbiAgQXJncyBleHRlbmRzIHN0cmluZyA/IFJ1bm5hYmxlVG9vbEZ1bmN0aW9uV2l0aG91dFBhcnNlXG4gIDogQXJncyBleHRlbmRzIG9iamVjdCA/IFJ1bm5hYmxlVG9vbEZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3M+XG4gIDogbmV2ZXI7XG5cbmV4cG9ydCB0eXBlIFJ1bm5hYmxlVG9vbEZ1bmN0aW9uV2l0aG91dFBhcnNlID0ge1xuICB0eXBlOiAnZnVuY3Rpb24nO1xuICBmdW5jdGlvbjogUnVubmFibGVGdW5jdGlvbldpdGhvdXRQYXJzZTtcbn07XG5leHBvcnQgdHlwZSBSdW5uYWJsZVRvb2xGdW5jdGlvbldpdGhQYXJzZTxBcmdzIGV4dGVuZHMgb2JqZWN0PiA9IHtcbiAgdHlwZTogJ2Z1bmN0aW9uJztcbiAgZnVuY3Rpb246IFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncz47XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3MgZXh0ZW5kcyBvYmplY3Q+KFxuICBmbjogYW55LFxuKTogZm4gaXMgUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzPiB7XG4gIHJldHVybiB0eXBlb2YgKGZuIGFzIGFueSkucGFyc2UgPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCB0eXBlIEJhc2VGdW5jdGlvbnNBcmdzID0gcmVhZG9ubHkgKG9iamVjdCB8IHN0cmluZylbXTtcblxuZXhwb3J0IHR5cGUgUnVubmFibGVGdW5jdGlvbnM8RnVuY3Rpb25zQXJncyBleHRlbmRzIEJhc2VGdW5jdGlvbnNBcmdzPiA9XG4gIFthbnlbXV0gZXh0ZW5kcyBbRnVuY3Rpb25zQXJnc10gPyByZWFkb25seSBSdW5uYWJsZUZ1bmN0aW9uPGFueT5bXVxuICA6IHtcbiAgICAgIFtJbmRleCBpbiBrZXlvZiBGdW5jdGlvbnNBcmdzXTogSW5kZXggZXh0ZW5kcyBudW1iZXIgPyBSdW5uYWJsZUZ1bmN0aW9uPEZ1bmN0aW9uc0FyZ3NbSW5kZXhdPlxuICAgICAgOiBGdW5jdGlvbnNBcmdzW0luZGV4XTtcbiAgICB9O1xuXG5leHBvcnQgdHlwZSBSdW5uYWJsZVRvb2xzPEZ1bmN0aW9uc0FyZ3MgZXh0ZW5kcyBCYXNlRnVuY3Rpb25zQXJncz4gPVxuICBbYW55W11dIGV4dGVuZHMgW0Z1bmN0aW9uc0FyZ3NdID8gcmVhZG9ubHkgUnVubmFibGVUb29sRnVuY3Rpb248YW55PltdXG4gIDoge1xuICAgICAgW0luZGV4IGluIGtleW9mIEZ1bmN0aW9uc0FyZ3NdOiBJbmRleCBleHRlbmRzIG51bWJlciA/IFJ1bm5hYmxlVG9vbEZ1bmN0aW9uPEZ1bmN0aW9uc0FyZ3NbSW5kZXhdPlxuICAgICAgOiBGdW5jdGlvbnNBcmdzW0luZGV4XTtcbiAgICB9O1xuXG4vKipcbiAqIFRoaXMgaXMgaGVscGVyIGNsYXNzIGZvciBwYXNzaW5nIGEgYGZ1bmN0aW9uYCBhbmQgYHBhcnNlYCB3aGVyZSB0aGUgYGZ1bmN0aW9uYFxuICogYXJndW1lbnQgdHlwZSBtYXRjaGVzIHRoZSBgcGFyc2VgIHJldHVybiB0eXBlLlxuICpcbiAqIEBkZXByZWNhdGVkIC0gcGxlYXNlIHVzZSBQYXJzaW5nVG9vbEZ1bmN0aW9uIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJzaW5nRnVuY3Rpb248QXJncyBleHRlbmRzIG9iamVjdD4ge1xuICBmdW5jdGlvbjogUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzPlsnZnVuY3Rpb24nXTtcbiAgcGFyc2U6IFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncz5bJ3BhcnNlJ107XG4gIHBhcmFtZXRlcnM6IFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncz5bJ3BhcmFtZXRlcnMnXTtcbiAgZGVzY3JpcHRpb246IFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncz5bJ2Rlc2NyaXB0aW9uJ107XG4gIG5hbWU/OiBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3M+WyduYW1lJ107XG5cbiAgY29uc3RydWN0b3IoaW5wdXQ6IFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncz4pIHtcbiAgICB0aGlzLmZ1bmN0aW9uID0gaW5wdXQuZnVuY3Rpb247XG4gICAgdGhpcy5wYXJzZSA9IGlucHV0LnBhcnNlO1xuICAgIHRoaXMucGFyYW1ldGVycyA9IGlucHV0LnBhcmFtZXRlcnM7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGlucHV0LmRlc2NyaXB0aW9uO1xuICAgIHRoaXMubmFtZSA9IGlucHV0Lm5hbWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGhlbHBlciBjbGFzcyBmb3IgcGFzc2luZyBhIGBmdW5jdGlvbmAgYW5kIGBwYXJzZWAgd2hlcmUgdGhlIGBmdW5jdGlvbmBcbiAqIGFyZ3VtZW50IHR5cGUgbWF0Y2hlcyB0aGUgYHBhcnNlYCByZXR1cm4gdHlwZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnNpbmdUb29sRnVuY3Rpb248QXJncyBleHRlbmRzIG9iamVjdD4ge1xuICB0eXBlOiAnZnVuY3Rpb24nO1xuICBmdW5jdGlvbjogUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzPjtcblxuICBjb25zdHJ1Y3RvcihpbnB1dDogUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzPikge1xuICAgIHRoaXMudHlwZSA9ICdmdW5jdGlvbic7XG4gICAgdGhpcy5mdW5jdGlvbiA9IGlucHV0O1xuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgdHlwZSBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSxcbiAgdHlwZSBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uTWVzc2FnZVBhcmFtLFxuICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtLFxuICB0eXBlIENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbSxcbn0gZnJvbSAnLi4vcmVzb3VyY2VzJztcblxuZXhwb3J0IGNvbnN0IGlzQXNzaXN0YW50TWVzc2FnZSA9IChcbiAgbWVzc2FnZTogQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0gfCBudWxsIHwgdW5kZWZpbmVkLFxuKTogbWVzc2FnZSBpcyBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSA9PiB7XG4gIHJldHVybiBtZXNzYWdlPy5yb2xlID09PSAnYXNzaXN0YW50Jztcbn07XG5cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uTWVzc2FnZSA9IChcbiAgbWVzc2FnZTogQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0gfCBudWxsIHwgdW5kZWZpbmVkLFxuKTogbWVzc2FnZSBpcyBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uTWVzc2FnZVBhcmFtID0+IHtcbiAgcmV0dXJuIG1lc3NhZ2U/LnJvbGUgPT09ICdmdW5jdGlvbic7XG59O1xuXG5leHBvcnQgY29uc3QgaXNUb29sTWVzc2FnZSA9IChcbiAgbWVzc2FnZTogQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0gfCBudWxsIHwgdW5kZWZpbmVkLFxuKTogbWVzc2FnZSBpcyBDaGF0Q29tcGxldGlvblRvb2xNZXNzYWdlUGFyYW0gPT4ge1xuICByZXR1cm4gbWVzc2FnZT8ucm9sZSA9PT0gJ3Rvb2wnO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJlc2VudDxUPihvYmo6IFQgfCBudWxsIHwgdW5kZWZpbmVkKTogb2JqIGlzIFQge1xuICByZXR1cm4gb2JqICE9IG51bGw7XG59XG4iLCAiaW1wb3J0IHsgQVBJVXNlckFib3J0RXJyb3IsIE9wZW5BSUVycm9yIH0gZnJvbSAnLi4vZXJyb3InO1xuXG5leHBvcnQgY2xhc3MgRXZlbnRTdHJlYW08RXZlbnRUeXBlcyBleHRlbmRzIEJhc2VFdmVudHM+IHtcbiAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXG4gICNjb25uZWN0ZWRQcm9taXNlOiBQcm9taXNlPHZvaWQ+O1xuICAjcmVzb2x2ZUNvbm5lY3RlZFByb21pc2U6ICgpID0+IHZvaWQgPSAoKSA9PiB7fTtcbiAgI3JlamVjdENvbm5lY3RlZFByb21pc2U6IChlcnJvcjogT3BlbkFJRXJyb3IpID0+IHZvaWQgPSAoKSA9PiB7fTtcblxuICAjZW5kUHJvbWlzZTogUHJvbWlzZTx2b2lkPjtcbiAgI3Jlc29sdmVFbmRQcm9taXNlOiAoKSA9PiB2b2lkID0gKCkgPT4ge307XG4gICNyZWplY3RFbmRQcm9taXNlOiAoZXJyb3I6IE9wZW5BSUVycm9yKSA9PiB2b2lkID0gKCkgPT4ge307XG5cbiAgI2xpc3RlbmVyczoge1xuICAgIFtFdmVudCBpbiBrZXlvZiBFdmVudFR5cGVzXT86IEV2ZW50TGlzdGVuZXJzPEV2ZW50VHlwZXMsIEV2ZW50PjtcbiAgfSA9IHt9O1xuXG4gICNlbmRlZCA9IGZhbHNlO1xuICAjZXJyb3JlZCA9IGZhbHNlO1xuICAjYWJvcnRlZCA9IGZhbHNlO1xuICAjY2F0Y2hpbmdQcm9taXNlQ3JlYXRlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuI2Nvbm5lY3RlZFByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLiNyZXNvbHZlQ29ubmVjdGVkUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLiNyZWplY3RDb25uZWN0ZWRQcm9taXNlID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdGhpcy4jZW5kUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuI3Jlc29sdmVFbmRQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMuI3JlamVjdEVuZFByb21pc2UgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICAvLyBEb24ndCBsZXQgdGhlc2UgcHJvbWlzZXMgY2F1c2UgdW5oYW5kbGVkIHJlamVjdGlvbiBlcnJvcnMuXG4gICAgLy8gd2Ugd2lsbCBtYW51YWxseSBjYXVzZSBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uIGVycm9yIGxhdGVyXG4gICAgLy8gaWYgdGhlIHVzZXIgaGFzbid0IHJlZ2lzdGVyZWQgYW55IGVycm9yIGxpc3RlbmVyIG9yIGNhbGxlZFxuICAgIC8vIGFueSBwcm9taXNlLXJldHVybmluZyBtZXRob2QuXG4gICAgdGhpcy4jY29ubmVjdGVkUHJvbWlzZS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgdGhpcy4jZW5kUHJvbWlzZS5jYXRjaCgoKSA9PiB7fSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3J1bih0aGlzOiBFdmVudFN0cmVhbTxFdmVudFR5cGVzPiwgZXhlY3V0b3I6ICgpID0+IFByb21pc2U8YW55Pikge1xuICAgIC8vIFVuZm9ydHVuYXRlbHkgaWYgd2UgY2FsbCBgZXhlY3V0b3IoKWAgaW1tZWRpYXRlbHkgd2UgZ2V0IHJ1bnRpbWUgZXJyb3JzIGFib3V0XG4gICAgLy8gcmVmZXJlbmNlcyB0byBgdGhpc2AgYmVmb3JlIHRoZSBgc3VwZXIoKWAgY29uc3RydWN0b3IgY2FsbCByZXR1cm5zLlxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZXhlY3V0b3IoKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fZW1pdEZpbmFsKCk7XG4gICAgICAgIHRoaXMuX2VtaXQoJ2VuZCcpO1xuICAgICAgfSwgdGhpcy4jaGFuZGxlRXJyb3IuYmluZCh0aGlzKSk7XG4gICAgfSwgMCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2Nvbm5lY3RlZCh0aGlzOiBFdmVudFN0cmVhbTxFdmVudFR5cGVzPikge1xuICAgIGlmICh0aGlzLmVuZGVkKSByZXR1cm47XG4gICAgdGhpcy4jcmVzb2x2ZUNvbm5lY3RlZFByb21pc2UoKTtcbiAgICB0aGlzLl9lbWl0KCdjb25uZWN0Jyk7XG4gIH1cblxuICBnZXQgZW5kZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuI2VuZGVkO1xuICB9XG5cbiAgZ2V0IGVycm9yZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuI2Vycm9yZWQ7XG4gIH1cblxuICBnZXQgYWJvcnRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy4jYWJvcnRlZDtcbiAgfVxuXG4gIGFib3J0KCkge1xuICAgIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIGV2ZW50LlxuICAgKiBObyBjaGVja3MgYXJlIG1hZGUgdG8gc2VlIGlmIHRoZSBsaXN0ZW5lciBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkLiBNdWx0aXBsZSBjYWxscyBwYXNzaW5nXG4gICAqIHRoZSBzYW1lIGNvbWJpbmF0aW9uIG9mIGV2ZW50IGFuZCBsaXN0ZW5lciB3aWxsIHJlc3VsdCBpbiB0aGUgbGlzdGVuZXIgYmVpbmcgYWRkZWQsIGFuZFxuICAgKiBjYWxsZWQsIG11bHRpcGxlIHRpbWVzLlxuICAgKiBAcmV0dXJucyB0aGlzIENoYXRDb21wbGV0aW9uU3RyZWFtLCBzbyB0aGF0IGNhbGxzIGNhbiBiZSBjaGFpbmVkXG4gICAqL1xuICBvbjxFdmVudCBleHRlbmRzIGtleW9mIEV2ZW50VHlwZXM+KGV2ZW50OiBFdmVudCwgbGlzdGVuZXI6IEV2ZW50TGlzdGVuZXI8RXZlbnRUeXBlcywgRXZlbnQ+KTogdGhpcyB7XG4gICAgY29uc3QgbGlzdGVuZXJzOiBFdmVudExpc3RlbmVyczxFdmVudFR5cGVzLCBFdmVudD4gPVxuICAgICAgdGhpcy4jbGlzdGVuZXJzW2V2ZW50XSB8fCAodGhpcy4jbGlzdGVuZXJzW2V2ZW50XSA9IFtdKTtcbiAgICBsaXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBmcm9tIHRoZSBsaXN0ZW5lciBhcnJheSBmb3IgdGhlIGV2ZW50LlxuICAgKiBvZmYoKSB3aWxsIHJlbW92ZSwgYXQgbW9zdCwgb25lIGluc3RhbmNlIG9mIGEgbGlzdGVuZXIgZnJvbSB0aGUgbGlzdGVuZXIgYXJyYXkuIElmIGFueSBzaW5nbGVcbiAgICogbGlzdGVuZXIgaGFzIGJlZW4gYWRkZWQgbXVsdGlwbGUgdGltZXMgdG8gdGhlIGxpc3RlbmVyIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LCB0aGVuXG4gICAqIG9mZigpIG11c3QgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIHJlbW92ZSBlYWNoIGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyB0aGlzIENoYXRDb21wbGV0aW9uU3RyZWFtLCBzbyB0aGF0IGNhbGxzIGNhbiBiZSBjaGFpbmVkXG4gICAqL1xuICBvZmY8RXZlbnQgZXh0ZW5kcyBrZXlvZiBFdmVudFR5cGVzPihldmVudDogRXZlbnQsIGxpc3RlbmVyOiBFdmVudExpc3RlbmVyPEV2ZW50VHlwZXMsIEV2ZW50Pik6IHRoaXMge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuI2xpc3RlbmVyc1tldmVudF07XG4gICAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmZpbmRJbmRleCgobCkgPT4gbC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpO1xuICAgIGlmIChpbmRleCA+PSAwKSBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgb25lLXRpbWUgbGlzdGVuZXIgZnVuY3Rpb24gZm9yIHRoZSBldmVudC4gVGhlIG5leHQgdGltZSB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLFxuICAgKiB0aGlzIGxpc3RlbmVyIGlzIHJlbW92ZWQgYW5kIHRoZW4gaW52b2tlZC5cbiAgICogQHJldHVybnMgdGhpcyBDaGF0Q29tcGxldGlvblN0cmVhbSwgc28gdGhhdCBjYWxscyBjYW4gYmUgY2hhaW5lZFxuICAgKi9cbiAgb25jZTxFdmVudCBleHRlbmRzIGtleW9mIEV2ZW50VHlwZXM+KGV2ZW50OiBFdmVudCwgbGlzdGVuZXI6IEV2ZW50TGlzdGVuZXI8RXZlbnRUeXBlcywgRXZlbnQ+KTogdGhpcyB7XG4gICAgY29uc3QgbGlzdGVuZXJzOiBFdmVudExpc3RlbmVyczxFdmVudFR5cGVzLCBFdmVudD4gPVxuICAgICAgdGhpcy4jbGlzdGVuZXJzW2V2ZW50XSB8fCAodGhpcy4jbGlzdGVuZXJzW2V2ZW50XSA9IFtdKTtcbiAgICBsaXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiB0cnVlIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgc2ltaWxhciB0byBgLm9uY2UoKWAsIGJ1dCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRoZSBuZXh0IHRpbWVcbiAgICogdGhlIGV2ZW50IGlzIHRyaWdnZXJlZCwgaW5zdGVhZCBvZiBjYWxsaW5nIGEgbGlzdGVuZXIgY2FsbGJhY2suXG4gICAqIEByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRoZSBuZXh0IHRpbWUgZ2l2ZW4gZXZlbnQgaXMgdHJpZ2dlcmVkLFxuICAgKiBvciByZWplY3RzIGlmIGFuIGVycm9yIGlzIGVtaXR0ZWQuICAoSWYgeW91IHJlcXVlc3QgdGhlICdlcnJvcicgZXZlbnQsXG4gICAqIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXJyb3IpLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCBzdHJlYW0uZW1pdHRlZCgnbWVzc2FnZScpIC8vIHJlamVjdHMgaWYgdGhlIHN0cmVhbSBlcnJvcnNcbiAgICovXG4gIGVtaXR0ZWQ8RXZlbnQgZXh0ZW5kcyBrZXlvZiBFdmVudFR5cGVzPihcbiAgICBldmVudDogRXZlbnQsXG4gICk6IFByb21pc2U8XG4gICAgRXZlbnRQYXJhbWV0ZXJzPEV2ZW50VHlwZXMsIEV2ZW50PiBleHRlbmRzIFtpbmZlciBQYXJhbV0gPyBQYXJhbVxuICAgIDogRXZlbnRQYXJhbWV0ZXJzPEV2ZW50VHlwZXMsIEV2ZW50PiBleHRlbmRzIFtdID8gdm9pZFxuICAgIDogRXZlbnRQYXJhbWV0ZXJzPEV2ZW50VHlwZXMsIEV2ZW50PlxuICA+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy4jY2F0Y2hpbmdQcm9taXNlQ3JlYXRlZCA9IHRydWU7XG4gICAgICBpZiAoZXZlbnQgIT09ICdlcnJvcicpIHRoaXMub25jZSgnZXJyb3InLCByZWplY3QpO1xuICAgICAgdGhpcy5vbmNlKGV2ZW50LCByZXNvbHZlIGFzIGFueSk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBkb25lKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuI2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQgPSB0cnVlO1xuICAgIGF3YWl0IHRoaXMuI2VuZFByb21pc2U7XG4gIH1cblxuICAjaGFuZGxlRXJyb3IodGhpczogRXZlbnRTdHJlYW08RXZlbnRUeXBlcz4sIGVycm9yOiB1bmtub3duKSB7XG4gICAgdGhpcy4jZXJyb3JlZCA9IHRydWU7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICBlcnJvciA9IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBUElVc2VyQWJvcnRFcnJvcikge1xuICAgICAgdGhpcy4jYWJvcnRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5fZW1pdCgnYWJvcnQnLCBlcnJvcik7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE9wZW5BSUVycm9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBjb25zdCBvcGVuQUlFcnJvcjogT3BlbkFJRXJyb3IgPSBuZXcgT3BlbkFJRXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBvcGVuQUlFcnJvci5jYXVzZSA9IGVycm9yO1xuICAgICAgcmV0dXJuIHRoaXMuX2VtaXQoJ2Vycm9yJywgb3BlbkFJRXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZW1pdCgnZXJyb3InLCBuZXcgT3BlbkFJRXJyb3IoU3RyaW5nKGVycm9yKSkpO1xuICB9XG5cbiAgX2VtaXQ8RXZlbnQgZXh0ZW5kcyBrZXlvZiBCYXNlRXZlbnRzPihldmVudDogRXZlbnQsIC4uLmFyZ3M6IEV2ZW50UGFyYW1ldGVyczxCYXNlRXZlbnRzLCBFdmVudD4pOiB2b2lkO1xuICBfZW1pdDxFdmVudCBleHRlbmRzIGtleW9mIEV2ZW50VHlwZXM+KGV2ZW50OiBFdmVudCwgLi4uYXJnczogRXZlbnRQYXJhbWV0ZXJzPEV2ZW50VHlwZXMsIEV2ZW50Pik6IHZvaWQ7XG4gIF9lbWl0PEV2ZW50IGV4dGVuZHMga2V5b2YgRXZlbnRUeXBlcz4oXG4gICAgdGhpczogRXZlbnRTdHJlYW08RXZlbnRUeXBlcz4sXG4gICAgZXZlbnQ6IEV2ZW50LFxuICAgIC4uLmFyZ3M6IEV2ZW50UGFyYW1ldGVyczxFdmVudFR5cGVzLCBFdmVudD5cbiAgKSB7XG4gICAgLy8gbWFrZSBzdXJlIHdlIGRvbid0IGVtaXQgYW55IGV2ZW50cyBhZnRlciBlbmRcbiAgICBpZiAodGhpcy4jZW5kZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQgPT09ICdlbmQnKSB7XG4gICAgICB0aGlzLiNlbmRlZCA9IHRydWU7XG4gICAgICB0aGlzLiNyZXNvbHZlRW5kUHJvbWlzZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGxpc3RlbmVyczogRXZlbnRMaXN0ZW5lcnM8RXZlbnRUeXBlcywgRXZlbnQ+IHwgdW5kZWZpbmVkID0gdGhpcy4jbGlzdGVuZXJzW2V2ZW50XTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLiNsaXN0ZW5lcnNbZXZlbnRdID0gbGlzdGVuZXJzLmZpbHRlcigobCkgPT4gIWwub25jZSkgYXMgYW55O1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goKHsgbGlzdGVuZXIgfTogYW55KSA9PiBsaXN0ZW5lciguLi4oYXJncyBhcyBhbnkpKSk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50ID09PSAnYWJvcnQnKSB7XG4gICAgICBjb25zdCBlcnJvciA9IGFyZ3NbMF0gYXMgQVBJVXNlckFib3J0RXJyb3I7XG4gICAgICBpZiAoIXRoaXMuI2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQgJiYgIWxpc3RlbmVycz8ubGVuZ3RoKSB7XG4gICAgICAgIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3JlamVjdENvbm5lY3RlZFByb21pc2UoZXJyb3IpO1xuICAgICAgdGhpcy4jcmVqZWN0RW5kUHJvbWlzZShlcnJvcik7XG4gICAgICB0aGlzLl9lbWl0KCdlbmQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQgPT09ICdlcnJvcicpIHtcbiAgICAgIC8vIE5PVEU6IF9lbWl0KCdlcnJvcicsIGVycm9yKSBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSAjaGFuZGxlRXJyb3IoKS5cblxuICAgICAgY29uc3QgZXJyb3IgPSBhcmdzWzBdIGFzIE9wZW5BSUVycm9yO1xuICAgICAgaWYgKCF0aGlzLiNjYXRjaGluZ1Byb21pc2VDcmVhdGVkICYmICFsaXN0ZW5lcnM/Lmxlbmd0aCkge1xuICAgICAgICAvLyBUcmlnZ2VyIGFuIHVuaGFuZGxlZCByZWplY3Rpb24gaWYgdGhlIHVzZXIgaGFzbid0IHJlZ2lzdGVyZWQgYW55IGVycm9yIGhhbmRsZXJzLlxuICAgICAgICAvLyBJZiB5b3UgYXJlIHNlZWluZyBzdGFjayB0cmFjZXMgaGVyZSwgbWFrZSBzdXJlIHRvIGhhbmRsZSBlcnJvcnMgdmlhIGVpdGhlcjpcbiAgICAgICAgLy8gLSBydW5uZXIub24oJ2Vycm9yJywgKCkgPT4gLi4uKVxuICAgICAgICAvLyAtIGF3YWl0IHJ1bm5lci5kb25lKClcbiAgICAgICAgLy8gLSBhd2FpdCBydW5uZXIuZmluYWxDaGF0Q29tcGxldGlvbigpXG4gICAgICAgIC8vIC0gZXRjLlxuICAgICAgICBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgICB0aGlzLiNyZWplY3RDb25uZWN0ZWRQcm9taXNlKGVycm9yKTtcbiAgICAgIHRoaXMuI3JlamVjdEVuZFByb21pc2UoZXJyb3IpO1xuICAgICAgdGhpcy5fZW1pdCgnZW5kJyk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9lbWl0RmluYWwoKTogdm9pZCB7fVxufVxuXG50eXBlIEV2ZW50TGlzdGVuZXI8RXZlbnRzLCBFdmVudFR5cGUgZXh0ZW5kcyBrZXlvZiBFdmVudHM+ID0gRXZlbnRzW0V2ZW50VHlwZV07XG5cbnR5cGUgRXZlbnRMaXN0ZW5lcnM8RXZlbnRzLCBFdmVudFR5cGUgZXh0ZW5kcyBrZXlvZiBFdmVudHM+ID0gQXJyYXk8e1xuICBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjxFdmVudHMsIEV2ZW50VHlwZT47XG4gIG9uY2U/OiBib29sZWFuO1xufT47XG5cbmV4cG9ydCB0eXBlIEV2ZW50UGFyYW1ldGVyczxFdmVudHMsIEV2ZW50VHlwZSBleHRlbmRzIGtleW9mIEV2ZW50cz4gPSB7XG4gIFtFdmVudCBpbiBFdmVudFR5cGVdOiBFdmVudExpc3RlbmVyPEV2ZW50cywgRXZlbnRUeXBlPiBleHRlbmRzICguLi5hcmdzOiBpbmZlciBQKSA9PiBhbnkgPyBQIDogbmV2ZXI7XG59W0V2ZW50VHlwZV07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFzZUV2ZW50cyB7XG4gIGNvbm5lY3Q6ICgpID0+IHZvaWQ7XG4gIGVycm9yOiAoZXJyb3I6IE9wZW5BSUVycm9yKSA9PiB2b2lkO1xuICBhYm9ydDogKGVycm9yOiBBUElVc2VyQWJvcnRFcnJvcikgPT4gdm9pZDtcbiAgZW5kOiAoKSA9PiB2b2lkO1xufVxuIiwgImltcG9ydCB7XG4gIENoYXRDb21wbGV0aW9uLFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwsXG4gIENoYXRDb21wbGV0aW9uVG9vbCxcbn0gZnJvbSAnLi4vcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMnO1xuaW1wb3J0IHtcbiAgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdUb29sUnVubmVyUGFyYW1zLFxuICBDaGF0Q29tcGxldGlvblN0cmVhbVBhcmFtcyxcbiAgQ2hhdENvbXBsZXRpb25Ub29sUnVubmVyUGFyYW1zLFxuICBQYXJzZWRDaGF0Q29tcGxldGlvbixcbiAgUGFyc2VkQ2hvaWNlLFxuICBQYXJzZWRGdW5jdGlvblRvb2xDYWxsLFxufSBmcm9tICcuLi9yZXNvdXJjZXMvYmV0YS9jaGF0L2NvbXBsZXRpb25zJztcbmltcG9ydCB7IFJlc3BvbnNlRm9ybWF0SlNPTlNjaGVtYSB9IGZyb20gJy4uL3Jlc291cmNlcy9zaGFyZWQnO1xuaW1wb3J0IHsgQ29udGVudEZpbHRlckZpbmlzaFJlYXNvbkVycm9yLCBMZW5ndGhGaW5pc2hSZWFzb25FcnJvciwgT3BlbkFJRXJyb3IgfSBmcm9tICcuLi9lcnJvcic7XG5cbnR5cGUgQW55Q2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMgPVxuICB8IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zXG4gIHwgQ2hhdENvbXBsZXRpb25Ub29sUnVubmVyUGFyYW1zPGFueT5cbiAgfCBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1Rvb2xSdW5uZXJQYXJhbXM8YW55PlxuICB8IENoYXRDb21wbGV0aW9uU3RyZWFtUGFyYW1zO1xuXG5leHBvcnQgdHlwZSBFeHRyYWN0UGFyc2VkQ29udGVudEZyb21QYXJhbXM8UGFyYW1zIGV4dGVuZHMgQW55Q2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXM+ID1cbiAgUGFyYW1zWydyZXNwb25zZV9mb3JtYXQnXSBleHRlbmRzIEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdDxpbmZlciBQPiA/IFAgOiBudWxsO1xuXG5leHBvcnQgdHlwZSBBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQ8UGFyc2VkVD4gPSBSZXNwb25zZUZvcm1hdEpTT05TY2hlbWEgJiB7XG4gIF9fb3V0cHV0OiBQYXJzZWRUOyAvLyB0eXBlLWxldmVsIG9ubHlcblxuICAkYnJhbmQ6ICdhdXRvLXBhcnNlYWJsZS1yZXNwb25zZS1mb3JtYXQnO1xuICAkcGFyc2VSYXcoY29udGVudDogc3RyaW5nKTogUGFyc2VkVDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQ8UGFyc2VkVD4oXG4gIHJlc3BvbnNlX2Zvcm1hdDogUmVzcG9uc2VGb3JtYXRKU09OU2NoZW1hLFxuICBwYXJzZXI6IChjb250ZW50OiBzdHJpbmcpID0+IFBhcnNlZFQsXG4pOiBBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQ8UGFyc2VkVD4ge1xuICBjb25zdCBvYmogPSB7IC4uLnJlc3BvbnNlX2Zvcm1hdCB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iaiwge1xuICAgICRicmFuZDoge1xuICAgICAgdmFsdWU6ICdhdXRvLXBhcnNlYWJsZS1yZXNwb25zZS1mb3JtYXQnLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICAkcGFyc2VSYXc6IHtcbiAgICAgIHZhbHVlOiBwYXJzZXIsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9LFxuICB9KTtcblxuICByZXR1cm4gb2JqIGFzIEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdDxQYXJzZWRUPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0b1BhcnNhYmxlUmVzcG9uc2VGb3JtYXQ8UGFyc2VkVD4oXG4gIHJlc3BvbnNlX2Zvcm1hdDogYW55LFxuKTogcmVzcG9uc2VfZm9ybWF0IGlzIEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdDxQYXJzZWRUPiB7XG4gIHJldHVybiByZXNwb25zZV9mb3JtYXQ/LlsnJGJyYW5kJ10gPT09ICdhdXRvLXBhcnNlYWJsZS1yZXNwb25zZS1mb3JtYXQnO1xufVxuXG50eXBlIFRvb2xPcHRpb25zID0ge1xuICBuYW1lOiBzdHJpbmc7XG4gIGFyZ3VtZW50czogYW55O1xuICBmdW5jdGlvbj86ICgoYXJnczogYW55KSA9PiBhbnkpIHwgdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IHR5cGUgQXV0b1BhcnNlYWJsZVRvb2w8XG4gIE9wdGlvbnNUIGV4dGVuZHMgVG9vbE9wdGlvbnMsXG4gIEhhc0Z1bmN0aW9uID0gT3B0aW9uc1RbJ2Z1bmN0aW9uJ10gZXh0ZW5kcyBGdW5jdGlvbiA/IHRydWUgOiBmYWxzZSxcbj4gPSBDaGF0Q29tcGxldGlvblRvb2wgJiB7XG4gIF9fYXJndW1lbnRzOiBPcHRpb25zVFsnYXJndW1lbnRzJ107IC8vIHR5cGUtbGV2ZWwgb25seVxuICBfX25hbWU6IE9wdGlvbnNUWyduYW1lJ107IC8vIHR5cGUtbGV2ZWwgb25seVxuICBfX2hhc0Z1bmN0aW9uOiBIYXNGdW5jdGlvbjsgLy8gdHlwZS1sZXZlbCBvbmx5XG5cbiAgJGJyYW5kOiAnYXV0by1wYXJzZWFibGUtdG9vbCc7XG4gICRjYWxsYmFjazogKChhcmdzOiBPcHRpb25zVFsnYXJndW1lbnRzJ10pID0+IGFueSkgfCB1bmRlZmluZWQ7XG4gICRwYXJzZVJhdyhhcmdzOiBzdHJpbmcpOiBPcHRpb25zVFsnYXJndW1lbnRzJ107XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVBhcnNlYWJsZVRvb2w8T3B0aW9uc1QgZXh0ZW5kcyBUb29sT3B0aW9ucz4oXG4gIHRvb2w6IENoYXRDb21wbGV0aW9uVG9vbCxcbiAge1xuICAgIHBhcnNlcixcbiAgICBjYWxsYmFjayxcbiAgfToge1xuICAgIHBhcnNlcjogKGNvbnRlbnQ6IHN0cmluZykgPT4gT3B0aW9uc1RbJ2FyZ3VtZW50cyddO1xuICAgIGNhbGxiYWNrOiAoKGFyZ3M6IGFueSkgPT4gYW55KSB8IHVuZGVmaW5lZDtcbiAgfSxcbik6IEF1dG9QYXJzZWFibGVUb29sPE9wdGlvbnNUWydhcmd1bWVudHMnXT4ge1xuICBjb25zdCBvYmogPSB7IC4uLnRvb2wgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmosIHtcbiAgICAkYnJhbmQ6IHtcbiAgICAgIHZhbHVlOiAnYXV0by1wYXJzZWFibGUtdG9vbCcsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgICRwYXJzZVJhdzoge1xuICAgICAgdmFsdWU6IHBhcnNlcixcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgJGNhbGxiYWNrOiB7XG4gICAgICB2YWx1ZTogY2FsbGJhY2ssXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9LFxuICB9KTtcblxuICByZXR1cm4gb2JqIGFzIEF1dG9QYXJzZWFibGVUb29sPE9wdGlvbnNUWydhcmd1bWVudHMnXT47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dG9QYXJzYWJsZVRvb2wodG9vbDogYW55KTogdG9vbCBpcyBBdXRvUGFyc2VhYmxlVG9vbDxhbnk+IHtcbiAgcmV0dXJuIHRvb2w/LlsnJGJyYW5kJ10gPT09ICdhdXRvLXBhcnNlYWJsZS10b29sJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlUGFyc2VDaGF0Q29tcGxldGlvbjxcbiAgUGFyYW1zIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMgfCBudWxsLFxuICBQYXJzZWRUID0gUGFyYW1zIGV4dGVuZHMgbnVsbCA/IG51bGwgOiBFeHRyYWN0UGFyc2VkQ29udGVudEZyb21QYXJhbXM8Tm9uTnVsbGFibGU8UGFyYW1zPj4sXG4+KGNvbXBsZXRpb246IENoYXRDb21wbGV0aW9uLCBwYXJhbXM6IFBhcmFtcyk6IFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+IHtcbiAgaWYgKCFwYXJhbXMgfHwgIWhhc0F1dG9QYXJzZWFibGVJbnB1dChwYXJhbXMpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbXBsZXRpb24sXG4gICAgICBjaG9pY2VzOiBjb21wbGV0aW9uLmNob2ljZXMubWFwKChjaG9pY2UpID0+ICh7XG4gICAgICAgIC4uLmNob2ljZSxcbiAgICAgICAgbWVzc2FnZTogeyAuLi5jaG9pY2UubWVzc2FnZSwgcGFyc2VkOiBudWxsLCB0b29sX2NhbGxzOiBjaG9pY2UubWVzc2FnZS50b29sX2NhbGxzID8/IFtdIH0sXG4gICAgICB9KSksXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUNoYXRDb21wbGV0aW9uKGNvbXBsZXRpb24sIHBhcmFtcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNoYXRDb21wbGV0aW9uPFxuICBQYXJhbXMgZXh0ZW5kcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgUGFyc2VkVCA9IEV4dHJhY3RQYXJzZWRDb250ZW50RnJvbVBhcmFtczxQYXJhbXM+LFxuPihjb21wbGV0aW9uOiBDaGF0Q29tcGxldGlvbiwgcGFyYW1zOiBQYXJhbXMpOiBQYXJzZWRDaGF0Q29tcGxldGlvbjxQYXJzZWRUPiB7XG4gIGNvbnN0IGNob2ljZXM6IEFycmF5PFBhcnNlZENob2ljZTxQYXJzZWRUPj4gPSBjb21wbGV0aW9uLmNob2ljZXMubWFwKChjaG9pY2UpOiBQYXJzZWRDaG9pY2U8UGFyc2VkVD4gPT4ge1xuICAgIGlmIChjaG9pY2UuZmluaXNoX3JlYXNvbiA9PT0gJ2xlbmd0aCcpIHtcbiAgICAgIHRocm93IG5ldyBMZW5ndGhGaW5pc2hSZWFzb25FcnJvcigpO1xuICAgIH1cblxuICAgIGlmIChjaG9pY2UuZmluaXNoX3JlYXNvbiA9PT0gJ2NvbnRlbnRfZmlsdGVyJykge1xuICAgICAgdGhyb3cgbmV3IENvbnRlbnRGaWx0ZXJGaW5pc2hSZWFzb25FcnJvcigpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5jaG9pY2UsXG4gICAgICBtZXNzYWdlOiB7XG4gICAgICAgIC4uLmNob2ljZS5tZXNzYWdlLFxuICAgICAgICB0b29sX2NhbGxzOiBjaG9pY2UubWVzc2FnZS50b29sX2NhbGxzPy5tYXAoKHRvb2xDYWxsKSA9PiBwYXJzZVRvb2xDYWxsKHBhcmFtcywgdG9vbENhbGwpKSA/PyBbXSxcbiAgICAgICAgcGFyc2VkOlxuICAgICAgICAgIGNob2ljZS5tZXNzYWdlLmNvbnRlbnQgJiYgIWNob2ljZS5tZXNzYWdlLnJlZnVzYWwgP1xuICAgICAgICAgICAgcGFyc2VSZXNwb25zZUZvcm1hdChwYXJhbXMsIGNob2ljZS5tZXNzYWdlLmNvbnRlbnQpXG4gICAgICAgICAgOiBudWxsLFxuICAgICAgfSxcbiAgICB9O1xuICB9KTtcblxuICByZXR1cm4geyAuLi5jb21wbGV0aW9uLCBjaG9pY2VzIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VGb3JtYXQ8XG4gIFBhcmFtcyBleHRlbmRzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICBQYXJzZWRUID0gRXh0cmFjdFBhcnNlZENvbnRlbnRGcm9tUGFyYW1zPFBhcmFtcz4sXG4+KHBhcmFtczogUGFyYW1zLCBjb250ZW50OiBzdHJpbmcpOiBQYXJzZWRUIHwgbnVsbCB7XG4gIGlmIChwYXJhbXMucmVzcG9uc2VfZm9ybWF0Py50eXBlICE9PSAnanNvbl9zY2hlbWEnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocGFyYW1zLnJlc3BvbnNlX2Zvcm1hdD8udHlwZSA9PT0gJ2pzb25fc2NoZW1hJykge1xuICAgIGlmICgnJHBhcnNlUmF3JyBpbiBwYXJhbXMucmVzcG9uc2VfZm9ybWF0KSB7XG4gICAgICBjb25zdCByZXNwb25zZV9mb3JtYXQgPSBwYXJhbXMucmVzcG9uc2VfZm9ybWF0IGFzIEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdDxQYXJzZWRUPjtcblxuICAgICAgcmV0dXJuIHJlc3BvbnNlX2Zvcm1hdC4kcGFyc2VSYXcoY29udGVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoY29udGVudCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGFyc2VUb29sQ2FsbDxQYXJhbXMgZXh0ZW5kcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcz4oXG4gIHBhcmFtczogUGFyYW1zLFxuICB0b29sQ2FsbDogQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwsXG4pOiBQYXJzZWRGdW5jdGlvblRvb2xDYWxsIHtcbiAgY29uc3QgaW5wdXRUb29sID0gcGFyYW1zLnRvb2xzPy5maW5kKChpbnB1dFRvb2wpID0+IGlucHV0VG9vbC5mdW5jdGlvbj8ubmFtZSA9PT0gdG9vbENhbGwuZnVuY3Rpb24ubmFtZSk7XG4gIHJldHVybiB7XG4gICAgLi4udG9vbENhbGwsXG4gICAgZnVuY3Rpb246IHtcbiAgICAgIC4uLnRvb2xDYWxsLmZ1bmN0aW9uLFxuICAgICAgcGFyc2VkX2FyZ3VtZW50czpcbiAgICAgICAgaXNBdXRvUGFyc2FibGVUb29sKGlucHV0VG9vbCkgPyBpbnB1dFRvb2wuJHBhcnNlUmF3KHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cylcbiAgICAgICAgOiBpbnB1dFRvb2w/LmZ1bmN0aW9uLnN0cmljdCA/IEpTT04ucGFyc2UodG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKVxuICAgICAgICA6IG51bGwsXG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFBhcnNlVG9vbENhbGwoXG4gIHBhcmFtczogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMgfCBudWxsIHwgdW5kZWZpbmVkLFxuICB0b29sQ2FsbDogQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwsXG4pOiBib29sZWFuIHtcbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBpbnB1dFRvb2wgPSBwYXJhbXMudG9vbHM/LmZpbmQoKGlucHV0VG9vbCkgPT4gaW5wdXRUb29sLmZ1bmN0aW9uPy5uYW1lID09PSB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lKTtcbiAgcmV0dXJuIGlzQXV0b1BhcnNhYmxlVG9vbChpbnB1dFRvb2wpIHx8IGlucHV0VG9vbD8uZnVuY3Rpb24uc3RyaWN0IHx8IGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzQXV0b1BhcnNlYWJsZUlucHV0KHBhcmFtczogQW55Q2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMpOiBib29sZWFuIHtcbiAgaWYgKGlzQXV0b1BhcnNhYmxlUmVzcG9uc2VGb3JtYXQocGFyYW1zLnJlc3BvbnNlX2Zvcm1hdCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgcGFyYW1zLnRvb2xzPy5zb21lKFxuICAgICAgKHQpID0+IGlzQXV0b1BhcnNhYmxlVG9vbCh0KSB8fCAodC50eXBlID09PSAnZnVuY3Rpb24nICYmIHQuZnVuY3Rpb24uc3RyaWN0ID09PSB0cnVlKSxcbiAgICApID8/IGZhbHNlXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUlucHV0VG9vbHModG9vbHM6IENoYXRDb21wbGV0aW9uVG9vbFtdIHwgdW5kZWZpbmVkKSB7XG4gIGZvciAoY29uc3QgdG9vbCBvZiB0b29scyA/PyBbXSkge1xuICAgIGlmICh0b29sLnR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihcbiAgICAgICAgYEN1cnJlbnRseSBvbmx5IFxcYGZ1bmN0aW9uXFxgIHRvb2wgdHlwZXMgc3VwcG9ydCBhdXRvLXBhcnNpbmc7IFJlY2VpdmVkIFxcYCR7dG9vbC50eXBlfVxcYGAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0b29sLmZ1bmN0aW9uLnN0cmljdCAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICBgVGhlIFxcYCR7dG9vbC5mdW5jdGlvbi5uYW1lfVxcYCB0b29sIGlzIG5vdCBtYXJrZWQgd2l0aCBcXGBzdHJpY3Q6IHRydWVcXGAuIE9ubHkgc3RyaWN0IGZ1bmN0aW9uIHRvb2xzIGNhbiBiZSBhdXRvLXBhcnNlZGAsXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgeyB0eXBlIENvbXBsZXRpb25Vc2FnZSB9IGZyb20gJy4uL3Jlc291cmNlcy9jb21wbGV0aW9ucyc7XG5pbXBvcnQge1xuICB0eXBlIENoYXRDb21wbGV0aW9uLFxuICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZSxcbiAgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSxcbiAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgdHlwZSBDaGF0Q29tcGxldGlvblRvb2wsXG59IGZyb20gJy4uL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zJztcbmltcG9ydCB7IE9wZW5BSUVycm9yIH0gZnJvbSAnLi4vZXJyb3InO1xuaW1wb3J0IHtcbiAgdHlwZSBSdW5uYWJsZUZ1bmN0aW9uLFxuICBpc1J1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2UsXG4gIHR5cGUgQmFzZUZ1bmN0aW9uc0FyZ3MsXG4gIFJ1bm5hYmxlVG9vbEZ1bmN0aW9uLFxufSBmcm9tICcuL1J1bm5hYmxlRnVuY3Rpb24nO1xuaW1wb3J0IHsgQ2hhdENvbXBsZXRpb25GdW5jdGlvblJ1bm5lclBhcmFtcywgQ2hhdENvbXBsZXRpb25Ub29sUnVubmVyUGFyYW1zIH0gZnJvbSAnLi9DaGF0Q29tcGxldGlvblJ1bm5lcic7XG5pbXBvcnQge1xuICBDaGF0Q29tcGxldGlvblN0cmVhbWluZ0Z1bmN0aW9uUnVubmVyUGFyYW1zLFxuICBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1Rvb2xSdW5uZXJQYXJhbXMsXG59IGZyb20gJy4vQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXInO1xuaW1wb3J0IHsgaXNBc3Npc3RhbnRNZXNzYWdlLCBpc0Z1bmN0aW9uTWVzc2FnZSwgaXNUb29sTWVzc2FnZSB9IGZyb20gJy4vY2hhdENvbXBsZXRpb25VdGlscyc7XG5pbXBvcnQgeyBCYXNlRXZlbnRzLCBFdmVudFN0cmVhbSB9IGZyb20gJy4vRXZlbnRTdHJlYW0nO1xuaW1wb3J0IHsgUGFyc2VkQ2hhdENvbXBsZXRpb24gfSBmcm9tICcuLi9yZXNvdXJjZXMvYmV0YS9jaGF0L2NvbXBsZXRpb25zJztcbmltcG9ydCBPcGVuQUkgZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHsgaXNBdXRvUGFyc2FibGVUb29sLCBwYXJzZUNoYXRDb21wbGV0aW9uIH0gZnJvbSAnLi4vbGliL3BhcnNlcic7XG5cbmNvbnN0IERFRkFVTFRfTUFYX0NIQVRfQ09NUExFVElPTlMgPSAxMDtcbmV4cG9ydCBpbnRlcmZhY2UgUnVubmVyT3B0aW9ucyBleHRlbmRzIENvcmUuUmVxdWVzdE9wdGlvbnMge1xuICAvKiogSG93IG1hbnkgcmVxdWVzdHMgdG8gbWFrZSBiZWZvcmUgY2FuY2VsaW5nLiBEZWZhdWx0IDEwLiAqL1xuICBtYXhDaGF0Q29tcGxldGlvbnM/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyPFxuICBFdmVudFR5cGVzIGV4dGVuZHMgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cyxcbiAgUGFyc2VkVCxcbj4gZXh0ZW5kcyBFdmVudFN0cmVhbTxFdmVudFR5cGVzPiB7XG4gIHByb3RlY3RlZCBfY2hhdENvbXBsZXRpb25zOiBQYXJzZWRDaGF0Q29tcGxldGlvbjxQYXJzZWRUPltdID0gW107XG4gIG1lc3NhZ2VzOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbVtdID0gW107XG5cbiAgcHJvdGVjdGVkIF9hZGRDaGF0Q29tcGxldGlvbihcbiAgICB0aGlzOiBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyPEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMsIFBhcnNlZFQ+LFxuICAgIGNoYXRDb21wbGV0aW9uOiBQYXJzZWRDaGF0Q29tcGxldGlvbjxQYXJzZWRUPixcbiAgKTogUGFyc2VkQ2hhdENvbXBsZXRpb248UGFyc2VkVD4ge1xuICAgIHRoaXMuX2NoYXRDb21wbGV0aW9ucy5wdXNoKGNoYXRDb21wbGV0aW9uKTtcbiAgICB0aGlzLl9lbWl0KCdjaGF0Q29tcGxldGlvbicsIGNoYXRDb21wbGV0aW9uKTtcbiAgICBjb25zdCBtZXNzYWdlID0gY2hhdENvbXBsZXRpb24uY2hvaWNlc1swXT8ubWVzc2FnZTtcbiAgICBpZiAobWVzc2FnZSkgdGhpcy5fYWRkTWVzc2FnZShtZXNzYWdlIGFzIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtKTtcbiAgICByZXR1cm4gY2hhdENvbXBsZXRpb247XG4gIH1cblxuICBwcm90ZWN0ZWQgX2FkZE1lc3NhZ2UoXG4gICAgdGhpczogQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcjxBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzLCBQYXJzZWRUPixcbiAgICBtZXNzYWdlOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSxcbiAgICBlbWl0ID0gdHJ1ZSxcbiAgKSB7XG4gICAgaWYgKCEoJ2NvbnRlbnQnIGluIG1lc3NhZ2UpKSBtZXNzYWdlLmNvbnRlbnQgPSBudWxsO1xuXG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuXG4gICAgaWYgKGVtaXQpIHtcbiAgICAgIHRoaXMuX2VtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICAgIGlmICgoaXNGdW5jdGlvbk1lc3NhZ2UobWVzc2FnZSkgfHwgaXNUb29sTWVzc2FnZShtZXNzYWdlKSkgJiYgbWVzc2FnZS5jb250ZW50KSB7XG4gICAgICAgIC8vIE5vdGUsIHRoaXMgYXNzdW1lcyB0aGF0IHtyb2xlOiAndG9vbCcsIGNvbnRlbnQ6IFx1MjAyNn0gaXMgYWx3YXlzIHRoZSByZXN1bHQgb2YgYSBjYWxsIG9mIHRvb2wgb2YgdHlwZT1mdW5jdGlvbi5cbiAgICAgICAgdGhpcy5fZW1pdCgnZnVuY3Rpb25DYWxsUmVzdWx0JywgbWVzc2FnZS5jb250ZW50IGFzIHN0cmluZyk7XG4gICAgICB9IGVsc2UgaWYgKGlzQXNzaXN0YW50TWVzc2FnZShtZXNzYWdlKSAmJiBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwpIHtcbiAgICAgICAgdGhpcy5fZW1pdCgnZnVuY3Rpb25DYWxsJywgbWVzc2FnZS5mdW5jdGlvbl9jYWxsKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBc3Npc3RhbnRNZXNzYWdlKG1lc3NhZ2UpICYmIG1lc3NhZ2UudG9vbF9jYWxscykge1xuICAgICAgICBmb3IgKGNvbnN0IHRvb2xfY2FsbCBvZiBtZXNzYWdlLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICBpZiAodG9vbF9jYWxsLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2Z1bmN0aW9uQ2FsbCcsIHRvb2xfY2FsbC5mdW5jdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGZpbmFsIENoYXRDb21wbGV0aW9uLCBvciByZWplY3RzXG4gICAqIGlmIGFuIGVycm9yIG9jY3VycmVkIG9yIHRoZSBzdHJlYW0gZW5kZWQgcHJlbWF0dXJlbHkgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbi5cbiAgICovXG4gIGFzeW5jIGZpbmFsQ2hhdENvbXBsZXRpb24oKTogUHJvbWlzZTxQYXJzZWRDaGF0Q29tcGxldGlvbjxQYXJzZWRUPj4ge1xuICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgIGNvbnN0IGNvbXBsZXRpb24gPSB0aGlzLl9jaGF0Q29tcGxldGlvbnNbdGhpcy5fY2hhdENvbXBsZXRpb25zLmxlbmd0aCAtIDFdO1xuICAgIGlmICghY29tcGxldGlvbikgdGhyb3cgbmV3IE9wZW5BSUVycm9yKCdzdHJlYW0gZW5kZWQgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbicpO1xuICAgIHJldHVybiBjb21wbGV0aW9uO1xuICB9XG5cbiAgI2dldEZpbmFsQ29udGVudCgpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy4jZ2V0RmluYWxNZXNzYWdlKCkuY29udGVudCA/PyBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGNvbnRlbnQgb2YgdGhlIGZpbmFsIENoYXRDb21wbGV0aW9uTWVzc2FnZSwgb3IgcmVqZWN0c1xuICAgKiBpZiBhbiBlcnJvciBvY2N1cnJlZCBvciB0aGUgc3RyZWFtIGVuZGVkIHByZW1hdHVyZWx5IHdpdGhvdXQgcHJvZHVjaW5nIGEgQ2hhdENvbXBsZXRpb25NZXNzYWdlLlxuICAgKi9cbiAgYXN5bmMgZmluYWxDb250ZW50KCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgIHJldHVybiB0aGlzLiNnZXRGaW5hbENvbnRlbnQoKTtcbiAgfVxuXG4gICNnZXRGaW5hbE1lc3NhZ2UoKTogQ2hhdENvbXBsZXRpb25NZXNzYWdlIHtcbiAgICBsZXQgaSA9IHRoaXMubWVzc2FnZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlc1tpXTtcbiAgICAgIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2UobWVzc2FnZSkpIHtcbiAgICAgICAgY29uc3QgeyBmdW5jdGlvbl9jYWxsLCAuLi5yZXN0IH0gPSBtZXNzYWdlO1xuXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgYXVkaW8gaGVyZVxuICAgICAgICBjb25zdCByZXQ6IE9taXQ8Q2hhdENvbXBsZXRpb25NZXNzYWdlLCAnYXVkaW8nPiA9IHtcbiAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgIGNvbnRlbnQ6IChtZXNzYWdlIGFzIENoYXRDb21wbGV0aW9uTWVzc2FnZSkuY29udGVudCA/PyBudWxsLFxuICAgICAgICAgIHJlZnVzYWw6IChtZXNzYWdlIGFzIENoYXRDb21wbGV0aW9uTWVzc2FnZSkucmVmdXNhbCA/PyBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZnVuY3Rpb25fY2FsbCkge1xuICAgICAgICAgIHJldC5mdW5jdGlvbl9jYWxsID0gZnVuY3Rpb25fY2FsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoJ3N0cmVhbSBlbmRlZCB3aXRob3V0IHByb2R1Y2luZyBhIENoYXRDb21wbGV0aW9uTWVzc2FnZSB3aXRoIHJvbGU9YXNzaXN0YW50Jyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgdGhlIGZpbmFsIGFzc2lzdGFudCBDaGF0Q29tcGxldGlvbk1lc3NhZ2UgcmVzcG9uc2UsXG4gICAqIG9yIHJlamVjdHMgaWYgYW4gZXJyb3Igb2NjdXJyZWQgb3IgdGhlIHN0cmVhbSBlbmRlZCBwcmVtYXR1cmVseSB3aXRob3V0IHByb2R1Y2luZyBhIENoYXRDb21wbGV0aW9uTWVzc2FnZS5cbiAgICovXG4gIGFzeW5jIGZpbmFsTWVzc2FnZSgpOiBQcm9taXNlPENoYXRDb21wbGV0aW9uTWVzc2FnZT4ge1xuICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgIHJldHVybiB0aGlzLiNnZXRGaW5hbE1lc3NhZ2UoKTtcbiAgfVxuXG4gICNnZXRGaW5hbEZ1bmN0aW9uQ2FsbCgpOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2UuRnVuY3Rpb25DYWxsIHwgdW5kZWZpbmVkIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5tZXNzYWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbaV07XG4gICAgICBpZiAoaXNBc3Npc3RhbnRNZXNzYWdlKG1lc3NhZ2UpICYmIG1lc3NhZ2U/LmZ1bmN0aW9uX2NhbGwpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2UobWVzc2FnZSkgJiYgbWVzc2FnZT8udG9vbF9jYWxscz8ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLnRvb2xfY2FsbHMuYXQoLTEpPy5mdW5jdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY29udGVudCBvZiB0aGUgZmluYWwgRnVuY3Rpb25DYWxsLCBvciByZWplY3RzXG4gICAqIGlmIGFuIGVycm9yIG9jY3VycmVkIG9yIHRoZSBzdHJlYW0gZW5kZWQgcHJlbWF0dXJlbHkgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbk1lc3NhZ2UuXG4gICAqL1xuICBhc3luYyBmaW5hbEZ1bmN0aW9uQ2FsbCgpOiBQcm9taXNlPENoYXRDb21wbGV0aW9uTWVzc2FnZS5GdW5jdGlvbkNhbGwgfCB1bmRlZmluZWQ+IHtcbiAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICByZXR1cm4gdGhpcy4jZ2V0RmluYWxGdW5jdGlvbkNhbGwoKTtcbiAgfVxuXG4gICNnZXRGaW5hbEZ1bmN0aW9uQ2FsbFJlc3VsdCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLm1lc3NhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlc1tpXTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uTWVzc2FnZShtZXNzYWdlKSAmJiBtZXNzYWdlLmNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZS5jb250ZW50O1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBpc1Rvb2xNZXNzYWdlKG1lc3NhZ2UpICYmXG4gICAgICAgIG1lc3NhZ2UuY29udGVudCAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIHRoaXMubWVzc2FnZXMuc29tZShcbiAgICAgICAgICAoeCkgPT5cbiAgICAgICAgICAgIHgucm9sZSA9PT0gJ2Fzc2lzdGFudCcgJiZcbiAgICAgICAgICAgIHgudG9vbF9jYWxscz8uc29tZSgoeSkgPT4geS50eXBlID09PSAnZnVuY3Rpb24nICYmIHkuaWQgPT09IG1lc3NhZ2UudG9vbF9jYWxsX2lkKSxcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXN5bmMgZmluYWxGdW5jdGlvbkNhbGxSZXN1bHQoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICByZXR1cm4gdGhpcy4jZ2V0RmluYWxGdW5jdGlvbkNhbGxSZXN1bHQoKTtcbiAgfVxuXG4gICNjYWxjdWxhdGVUb3RhbFVzYWdlKCk6IENvbXBsZXRpb25Vc2FnZSB7XG4gICAgY29uc3QgdG90YWw6IENvbXBsZXRpb25Vc2FnZSA9IHtcbiAgICAgIGNvbXBsZXRpb25fdG9rZW5zOiAwLFxuICAgICAgcHJvbXB0X3Rva2VuczogMCxcbiAgICAgIHRvdGFsX3Rva2VuczogMCxcbiAgICB9O1xuICAgIGZvciAoY29uc3QgeyB1c2FnZSB9IG9mIHRoaXMuX2NoYXRDb21wbGV0aW9ucykge1xuICAgICAgaWYgKHVzYWdlKSB7XG4gICAgICAgIHRvdGFsLmNvbXBsZXRpb25fdG9rZW5zICs9IHVzYWdlLmNvbXBsZXRpb25fdG9rZW5zO1xuICAgICAgICB0b3RhbC5wcm9tcHRfdG9rZW5zICs9IHVzYWdlLnByb21wdF90b2tlbnM7XG4gICAgICAgIHRvdGFsLnRvdGFsX3Rva2VucyArPSB1c2FnZS50b3RhbF90b2tlbnM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuXG4gIGFzeW5jIHRvdGFsVXNhZ2UoKTogUHJvbWlzZTxDb21wbGV0aW9uVXNhZ2U+IHtcbiAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICByZXR1cm4gdGhpcy4jY2FsY3VsYXRlVG90YWxVc2FnZSgpO1xuICB9XG5cbiAgYWxsQ2hhdENvbXBsZXRpb25zKCk6IENoYXRDb21wbGV0aW9uW10ge1xuICAgIHJldHVybiBbLi4udGhpcy5fY2hhdENvbXBsZXRpb25zXTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBfZW1pdEZpbmFsKFxuICAgIHRoaXM6IEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXI8QWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cywgUGFyc2VkVD4sXG4gICkge1xuICAgIGNvbnN0IGNvbXBsZXRpb24gPSB0aGlzLl9jaGF0Q29tcGxldGlvbnNbdGhpcy5fY2hhdENvbXBsZXRpb25zLmxlbmd0aCAtIDFdO1xuICAgIGlmIChjb21wbGV0aW9uKSB0aGlzLl9lbWl0KCdmaW5hbENoYXRDb21wbGV0aW9uJywgY29tcGxldGlvbik7XG4gICAgY29uc3QgZmluYWxNZXNzYWdlID0gdGhpcy4jZ2V0RmluYWxNZXNzYWdlKCk7XG4gICAgaWYgKGZpbmFsTWVzc2FnZSkgdGhpcy5fZW1pdCgnZmluYWxNZXNzYWdlJywgZmluYWxNZXNzYWdlKTtcbiAgICBjb25zdCBmaW5hbENvbnRlbnQgPSB0aGlzLiNnZXRGaW5hbENvbnRlbnQoKTtcbiAgICBpZiAoZmluYWxDb250ZW50KSB0aGlzLl9lbWl0KCdmaW5hbENvbnRlbnQnLCBmaW5hbENvbnRlbnQpO1xuXG4gICAgY29uc3QgZmluYWxGdW5jdGlvbkNhbGwgPSB0aGlzLiNnZXRGaW5hbEZ1bmN0aW9uQ2FsbCgpO1xuICAgIGlmIChmaW5hbEZ1bmN0aW9uQ2FsbCkgdGhpcy5fZW1pdCgnZmluYWxGdW5jdGlvbkNhbGwnLCBmaW5hbEZ1bmN0aW9uQ2FsbCk7XG5cbiAgICBjb25zdCBmaW5hbEZ1bmN0aW9uQ2FsbFJlc3VsdCA9IHRoaXMuI2dldEZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0KCk7XG4gICAgaWYgKGZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0ICE9IG51bGwpIHRoaXMuX2VtaXQoJ2ZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0JywgZmluYWxGdW5jdGlvbkNhbGxSZXN1bHQpO1xuXG4gICAgaWYgKHRoaXMuX2NoYXRDb21wbGV0aW9ucy5zb21lKChjKSA9PiBjLnVzYWdlKSkge1xuICAgICAgdGhpcy5fZW1pdCgndG90YWxVc2FnZScsIHRoaXMuI2NhbGN1bGF0ZVRvdGFsVXNhZ2UoKSk7XG4gICAgfVxuICB9XG5cbiAgI3ZhbGlkYXRlUGFyYW1zKHBhcmFtczogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMpOiB2b2lkIHtcbiAgICBpZiAocGFyYW1zLm4gIT0gbnVsbCAmJiBwYXJhbXMubiA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihcbiAgICAgICAgJ0NoYXRDb21wbGV0aW9uIGNvbnZlbmllbmNlIGhlbHBlcnMgb25seSBzdXBwb3J0IG49MSBhdCB0aGlzIHRpbWUuIFRvIHVzZSBuPjEsIHBsZWFzZSB1c2UgY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoKSBkaXJlY3RseS4nLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX2NyZWF0ZUNoYXRDb21wbGV0aW9uKFxuICAgIGNsaWVudDogT3BlbkFJLFxuICAgIHBhcmFtczogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IFByb21pc2U8UGFyc2VkQ2hhdENvbXBsZXRpb248UGFyc2VkVD4+IHtcbiAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXMuY29udHJvbGxlci5hYm9ydCgpKTtcbiAgICB9XG4gICAgdGhpcy4jdmFsaWRhdGVQYXJhbXMocGFyYW1zKTtcblxuICAgIGNvbnN0IGNoYXRDb21wbGV0aW9uID0gYXdhaXQgY2xpZW50LmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKFxuICAgICAgeyAuLi5wYXJhbXMsIHN0cmVhbTogZmFsc2UgfSxcbiAgICAgIHsgLi4ub3B0aW9ucywgc2lnbmFsOiB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsIH0sXG4gICAgKTtcbiAgICB0aGlzLl9jb25uZWN0ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hhdENvbXBsZXRpb24ocGFyc2VDaGF0Q29tcGxldGlvbihjaGF0Q29tcGxldGlvbiwgcGFyYW1zKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX3J1bkNoYXRDb21wbGV0aW9uKFxuICAgIGNsaWVudDogT3BlbkFJLFxuICAgIHBhcmFtczogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IFByb21pc2U8Q2hhdENvbXBsZXRpb24+IHtcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcGFyYW1zLm1lc3NhZ2VzKSB7XG4gICAgICB0aGlzLl9hZGRNZXNzYWdlKG1lc3NhZ2UsIGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2NyZWF0ZUNoYXRDb21wbGV0aW9uKGNsaWVudCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfcnVuRnVuY3Rpb25zPEZ1bmN0aW9uc0FyZ3MgZXh0ZW5kcyBCYXNlRnVuY3Rpb25zQXJncz4oXG4gICAgY2xpZW50OiBPcGVuQUksXG4gICAgcGFyYW1zOlxuICAgICAgfCBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3M+XG4gICAgICB8IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nRnVuY3Rpb25SdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncz4sXG4gICAgb3B0aW9ucz86IFJ1bm5lck9wdGlvbnMsXG4gICkge1xuICAgIGNvbnN0IHJvbGUgPSAnZnVuY3Rpb24nIGFzIGNvbnN0O1xuICAgIGNvbnN0IHsgZnVuY3Rpb25fY2FsbCA9ICdhdXRvJywgc3RyZWFtLCAuLi5yZXN0UGFyYW1zIH0gPSBwYXJhbXM7XG4gICAgY29uc3Qgc2luZ2xlRnVuY3Rpb25Ub0NhbGwgPSB0eXBlb2YgZnVuY3Rpb25fY2FsbCAhPT0gJ3N0cmluZycgJiYgZnVuY3Rpb25fY2FsbD8ubmFtZTtcbiAgICBjb25zdCB7IG1heENoYXRDb21wbGV0aW9ucyA9IERFRkFVTFRfTUFYX0NIQVRfQ09NUExFVElPTlMgfSA9IG9wdGlvbnMgfHwge307XG5cbiAgICBjb25zdCBmdW5jdGlvbnNCeU5hbWU6IFJlY29yZDxzdHJpbmcsIFJ1bm5hYmxlRnVuY3Rpb248YW55Pj4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGYgb2YgcGFyYW1zLmZ1bmN0aW9ucykge1xuICAgICAgZnVuY3Rpb25zQnlOYW1lW2YubmFtZSB8fCBmLmZ1bmN0aW9uLm5hbWVdID0gZjtcbiAgICB9XG5cbiAgICBjb25zdCBmdW5jdGlvbnM6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLkZ1bmN0aW9uW10gPSBwYXJhbXMuZnVuY3Rpb25zLm1hcChcbiAgICAgIChmKTogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMuRnVuY3Rpb24gPT4gKHtcbiAgICAgICAgbmFtZTogZi5uYW1lIHx8IGYuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgcGFyYW1ldGVyczogZi5wYXJhbWV0ZXJzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgICAgICBkZXNjcmlwdGlvbjogZi5kZXNjcmlwdGlvbixcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcGFyYW1zLm1lc3NhZ2VzKSB7XG4gICAgICB0aGlzLl9hZGRNZXNzYWdlKG1lc3NhZ2UsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heENoYXRDb21wbGV0aW9uczsgKytpKSB7XG4gICAgICBjb25zdCBjaGF0Q29tcGxldGlvbjogQ2hhdENvbXBsZXRpb24gPSBhd2FpdCB0aGlzLl9jcmVhdGVDaGF0Q29tcGxldGlvbihcbiAgICAgICAgY2xpZW50LFxuICAgICAgICB7XG4gICAgICAgICAgLi4ucmVzdFBhcmFtcyxcbiAgICAgICAgICBmdW5jdGlvbl9jYWxsLFxuICAgICAgICAgIGZ1bmN0aW9ucyxcbiAgICAgICAgICBtZXNzYWdlczogWy4uLnRoaXMubWVzc2FnZXNdLFxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjaGF0Q29tcGxldGlvbi5jaG9pY2VzWzBdPy5tZXNzYWdlO1xuICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBtZXNzYWdlIGluIENoYXRDb21wbGV0aW9uIHJlc3BvbnNlYCk7XG4gICAgICB9XG4gICAgICBpZiAoIW1lc3NhZ2UuZnVuY3Rpb25fY2FsbCkgcmV0dXJuO1xuICAgICAgY29uc3QgeyBuYW1lLCBhcmd1bWVudHM6IGFyZ3MgfSA9IG1lc3NhZ2UuZnVuY3Rpb25fY2FsbDtcbiAgICAgIGNvbnN0IGZuID0gZnVuY3Rpb25zQnlOYW1lW25hbWVdO1xuICAgICAgaWYgKCFmbikge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gYEludmFsaWQgZnVuY3Rpb25fY2FsbDogJHtKU09OLnN0cmluZ2lmeShuYW1lKX0uIEF2YWlsYWJsZSBvcHRpb25zIGFyZTogJHtmdW5jdGlvbnNcbiAgICAgICAgICAubWFwKChmKSA9PiBKU09OLnN0cmluZ2lmeShmLm5hbWUpKVxuICAgICAgICAgIC5qb2luKCcsICcpfS4gUGxlYXNlIHRyeSBhZ2FpbmA7XG5cbiAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGUsIG5hbWUsIGNvbnRlbnQgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChzaW5nbGVGdW5jdGlvblRvQ2FsbCAmJiBzaW5nbGVGdW5jdGlvblRvQ2FsbCAhPT0gbmFtZSkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gYEludmFsaWQgZnVuY3Rpb25fY2FsbDogJHtKU09OLnN0cmluZ2lmeShuYW1lKX0uICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgc2luZ2xlRnVuY3Rpb25Ub0NhbGwsXG4gICAgICAgICl9IHJlcXVlc3RlZC4gUGxlYXNlIHRyeSBhZ2FpbmA7XG5cbiAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGUsIG5hbWUsIGNvbnRlbnQgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgcGFyc2VkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkID0gaXNSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlKGZuKSA/IGF3YWl0IGZuLnBhcnNlKGFyZ3MpIDogYXJncztcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuX2FkZE1lc3NhZ2Uoe1xuICAgICAgICAgIHJvbGUsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjb250ZW50OiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvciksXG4gICAgICAgIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBpdCBjYW4ndCBydWxlIG91dCBgbmV2ZXJgIHR5cGUuXG4gICAgICBjb25zdCByYXdDb250ZW50ID0gYXdhaXQgZm4uZnVuY3Rpb24ocGFyc2VkLCB0aGlzKTtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLiNzdHJpbmdpZnlGdW5jdGlvbkNhbGxSZXN1bHQocmF3Q29udGVudCk7XG5cbiAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoeyByb2xlLCBuYW1lLCBjb250ZW50IH0pO1xuXG4gICAgICBpZiAoc2luZ2xlRnVuY3Rpb25Ub0NhbGwpIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX3J1blRvb2xzPEZ1bmN0aW9uc0FyZ3MgZXh0ZW5kcyBCYXNlRnVuY3Rpb25zQXJncz4oXG4gICAgY2xpZW50OiBPcGVuQUksXG4gICAgcGFyYW1zOlxuICAgICAgfCBDaGF0Q29tcGxldGlvblRvb2xSdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncz5cbiAgICAgIHwgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdUb29sUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3M+LFxuICAgIG9wdGlvbnM/OiBSdW5uZXJPcHRpb25zLFxuICApIHtcbiAgICBjb25zdCByb2xlID0gJ3Rvb2wnIGFzIGNvbnN0O1xuICAgIGNvbnN0IHsgdG9vbF9jaG9pY2UgPSAnYXV0bycsIHN0cmVhbSwgLi4ucmVzdFBhcmFtcyB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHNpbmdsZUZ1bmN0aW9uVG9DYWxsID0gdHlwZW9mIHRvb2xfY2hvaWNlICE9PSAnc3RyaW5nJyAmJiB0b29sX2Nob2ljZT8uZnVuY3Rpb24/Lm5hbWU7XG4gICAgY29uc3QgeyBtYXhDaGF0Q29tcGxldGlvbnMgPSBERUZBVUxUX01BWF9DSEFUX0NPTVBMRVRJT05TIH0gPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gVE9ETyhzb21lZGF5KTogY2xlYW4gdGhpcyBsb2dpYyB1cFxuICAgIGNvbnN0IGlucHV0VG9vbHMgPSBwYXJhbXMudG9vbHMubWFwKCh0b29sKTogUnVubmFibGVUb29sRnVuY3Rpb248YW55PiA9PiB7XG4gICAgICBpZiAoaXNBdXRvUGFyc2FibGVUb29sKHRvb2wpKSB7XG4gICAgICAgIGlmICghdG9vbC4kY2FsbGJhY2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoJ1Rvb2wgZ2l2ZW4gdG8gYC5ydW5Ub29scygpYCB0aGF0IGRvZXMgbm90IGhhdmUgYW4gYXNzb2NpYXRlZCBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICBmdW5jdGlvbjogdG9vbC4kY2FsbGJhY2ssXG4gICAgICAgICAgICBuYW1lOiB0b29sLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5mdW5jdGlvbi5kZXNjcmlwdGlvbiB8fCAnJyxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHRvb2wuZnVuY3Rpb24ucGFyYW1ldGVycyBhcyBhbnksXG4gICAgICAgICAgICBwYXJzZTogdG9vbC4kcGFyc2VSYXcsXG4gICAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvb2wgYXMgYW55IGFzIFJ1bm5hYmxlVG9vbEZ1bmN0aW9uPGFueT47XG4gICAgfSk7XG5cbiAgICBjb25zdCBmdW5jdGlvbnNCeU5hbWU6IFJlY29yZDxzdHJpbmcsIFJ1bm5hYmxlRnVuY3Rpb248YW55Pj4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGYgb2YgaW5wdXRUb29scykge1xuICAgICAgaWYgKGYudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmdW5jdGlvbnNCeU5hbWVbZi5mdW5jdGlvbi5uYW1lIHx8IGYuZnVuY3Rpb24uZnVuY3Rpb24ubmFtZV0gPSBmLmZ1bmN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRvb2xzOiBDaGF0Q29tcGxldGlvblRvb2xbXSA9XG4gICAgICAndG9vbHMnIGluIHBhcmFtcyA/XG4gICAgICAgIGlucHV0VG9vbHMubWFwKCh0KSA9PlxuICAgICAgICAgIHQudHlwZSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogdC5mdW5jdGlvbi5uYW1lIHx8IHQuZnVuY3Rpb24uZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB0LmZ1bmN0aW9uLnBhcmFtZXRlcnMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHQuZnVuY3Rpb24uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RyaWN0OiB0LmZ1bmN0aW9uLnN0cmljdCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6ICh0IGFzIHVua25vd24gYXMgQ2hhdENvbXBsZXRpb25Ub29sKSxcbiAgICAgICAgKVxuICAgICAgOiAodW5kZWZpbmVkIGFzIGFueSk7XG5cbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcGFyYW1zLm1lc3NhZ2VzKSB7XG4gICAgICB0aGlzLl9hZGRNZXNzYWdlKG1lc3NhZ2UsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heENoYXRDb21wbGV0aW9uczsgKytpKSB7XG4gICAgICBjb25zdCBjaGF0Q29tcGxldGlvbjogQ2hhdENvbXBsZXRpb24gPSBhd2FpdCB0aGlzLl9jcmVhdGVDaGF0Q29tcGxldGlvbihcbiAgICAgICAgY2xpZW50LFxuICAgICAgICB7XG4gICAgICAgICAgLi4ucmVzdFBhcmFtcyxcbiAgICAgICAgICB0b29sX2Nob2ljZSxcbiAgICAgICAgICB0b29scyxcbiAgICAgICAgICBtZXNzYWdlczogWy4uLnRoaXMubWVzc2FnZXNdLFxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjaGF0Q29tcGxldGlvbi5jaG9pY2VzWzBdPy5tZXNzYWdlO1xuICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBtZXNzYWdlIGluIENoYXRDb21wbGV0aW9uIHJlc3BvbnNlYCk7XG4gICAgICB9XG4gICAgICBpZiAoIW1lc3NhZ2UudG9vbF9jYWxscz8ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCB0b29sX2NhbGwgb2YgbWVzc2FnZS50b29sX2NhbGxzKSB7XG4gICAgICAgIGlmICh0b29sX2NhbGwudHlwZSAhPT0gJ2Z1bmN0aW9uJykgY29udGludWU7XG4gICAgICAgIGNvbnN0IHRvb2xfY2FsbF9pZCA9IHRvb2xfY2FsbC5pZDtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBhcmd1bWVudHM6IGFyZ3MgfSA9IHRvb2xfY2FsbC5mdW5jdGlvbjtcbiAgICAgICAgY29uc3QgZm4gPSBmdW5jdGlvbnNCeU5hbWVbbmFtZV07XG5cbiAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBgSW52YWxpZCB0b29sX2NhbGw6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9LiBBdmFpbGFibGUgb3B0aW9ucyBhcmU6ICR7T2JqZWN0LmtleXMoXG4gICAgICAgICAgICBmdW5jdGlvbnNCeU5hbWUsXG4gICAgICAgICAgKVxuICAgICAgICAgICAgLm1hcCgobmFtZSkgPT4gSlNPTi5zdHJpbmdpZnkobmFtZSkpXG4gICAgICAgICAgICAuam9pbignLCAnKX0uIFBsZWFzZSB0cnkgYWdhaW5gO1xuXG4gICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGUsIHRvb2xfY2FsbF9pZCwgY29udGVudCB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzaW5nbGVGdW5jdGlvblRvQ2FsbCAmJiBzaW5nbGVGdW5jdGlvblRvQ2FsbCAhPT0gbmFtZSkge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBgSW52YWxpZCB0b29sX2NhbGw6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9LiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgc2luZ2xlRnVuY3Rpb25Ub0NhbGwsXG4gICAgICAgICAgKX0gcmVxdWVzdGVkLiBQbGVhc2UgdHJ5IGFnYWluYDtcblxuICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoeyByb2xlLCB0b29sX2NhbGxfaWQsIGNvbnRlbnQgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGFyc2VkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcnNlZCA9IGlzUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZShmbikgPyBhd2FpdCBmbi5wYXJzZShhcmdzKSA6IGFyZ3M7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgdG9vbF9jYWxsX2lkLCBjb250ZW50IH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBpdCBjYW4ndCBydWxlIG91dCBgbmV2ZXJgIHR5cGUuXG4gICAgICAgIGNvbnN0IHJhd0NvbnRlbnQgPSBhd2FpdCBmbi5mdW5jdGlvbihwYXJzZWQsIHRoaXMpO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy4jc3RyaW5naWZ5RnVuY3Rpb25DYWxsUmVzdWx0KHJhd0NvbnRlbnQpO1xuICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgdG9vbF9jYWxsX2lkLCBjb250ZW50IH0pO1xuXG4gICAgICAgIGlmIChzaW5nbGVGdW5jdGlvblRvQ2FsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gICNzdHJpbmdpZnlGdW5jdGlvbkNhbGxSZXN1bHQocmF3Q29udGVudDogdW5rbm93bik6IHN0cmluZyB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiByYXdDb250ZW50ID09PSAnc3RyaW5nJyA/IHJhd0NvbnRlbnRcbiAgICAgIDogcmF3Q29udGVudCA9PT0gdW5kZWZpbmVkID8gJ3VuZGVmaW5lZCdcbiAgICAgIDogSlNPTi5zdHJpbmdpZnkocmF3Q29udGVudClcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cyBleHRlbmRzIEJhc2VFdmVudHMge1xuICBmdW5jdGlvbkNhbGw6IChmdW5jdGlvbkNhbGw6IENoYXRDb21wbGV0aW9uTWVzc2FnZS5GdW5jdGlvbkNhbGwpID0+IHZvaWQ7XG4gIG1lc3NhZ2U6IChtZXNzYWdlOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSkgPT4gdm9pZDtcbiAgY2hhdENvbXBsZXRpb246IChjb21wbGV0aW9uOiBDaGF0Q29tcGxldGlvbikgPT4gdm9pZDtcbiAgZmluYWxDb250ZW50OiAoY29udGVudFNuYXBzaG90OiBzdHJpbmcpID0+IHZvaWQ7XG4gIGZpbmFsTWVzc2FnZTogKG1lc3NhZ2U6IENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtKSA9PiB2b2lkO1xuICBmaW5hbENoYXRDb21wbGV0aW9uOiAoY29tcGxldGlvbjogQ2hhdENvbXBsZXRpb24pID0+IHZvaWQ7XG4gIGZpbmFsRnVuY3Rpb25DYWxsOiAoZnVuY3Rpb25DYWxsOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2UuRnVuY3Rpb25DYWxsKSA9PiB2b2lkO1xuICBmdW5jdGlvbkNhbGxSZXN1bHQ6IChjb250ZW50OiBzdHJpbmcpID0+IHZvaWQ7XG4gIGZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0OiAoY29udGVudDogc3RyaW5nKSA9PiB2b2lkO1xuICB0b3RhbFVzYWdlOiAodXNhZ2U6IENvbXBsZXRpb25Vc2FnZSkgPT4gdm9pZDtcbn1cbiIsICJpbXBvcnQge1xuICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtLFxuICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxufSBmcm9tICcuLi9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucyc7XG5pbXBvcnQgeyB0eXBlIFJ1bm5hYmxlRnVuY3Rpb25zLCB0eXBlIEJhc2VGdW5jdGlvbnNBcmdzLCBSdW5uYWJsZVRvb2xzIH0gZnJvbSAnLi9SdW5uYWJsZUZ1bmN0aW9uJztcbmltcG9ydCB7XG4gIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXIsXG4gIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMsXG4gIFJ1bm5lck9wdGlvbnMsXG59IGZyb20gJy4vQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcic7XG5pbXBvcnQgeyBpc0Fzc2lzdGFudE1lc3NhZ2UgfSBmcm9tICcuL2NoYXRDb21wbGV0aW9uVXRpbHMnO1xuaW1wb3J0IE9wZW5BSSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyBBdXRvUGFyc2VhYmxlVG9vbCB9IGZyb20gJy4uL2xpYi9wYXJzZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzIGV4dGVuZHMgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cyB7XG4gIGNvbnRlbnQ6IChjb250ZW50OiBzdHJpbmcpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uRnVuY3Rpb25SdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncyBleHRlbmRzIEJhc2VGdW5jdGlvbnNBcmdzPiA9IE9taXQ8XG4gIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAnZnVuY3Rpb25zJ1xuPiAmIHtcbiAgZnVuY3Rpb25zOiBSdW5uYWJsZUZ1bmN0aW9uczxGdW5jdGlvbnNBcmdzPjtcbn07XG5cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uVG9vbFJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzIGV4dGVuZHMgQmFzZUZ1bmN0aW9uc0FyZ3M+ID0gT21pdDxcbiAgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICd0b29scydcbj4gJiB7XG4gIHRvb2xzOiBSdW5uYWJsZVRvb2xzPEZ1bmN0aW9uc0FyZ3M+IHwgQXV0b1BhcnNlYWJsZVRvb2w8YW55LCB0cnVlPltdO1xufTtcblxuZXhwb3J0IGNsYXNzIENoYXRDb21wbGV0aW9uUnVubmVyPFBhcnNlZFQgPSBudWxsPiBleHRlbmRzIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXI8XG4gIENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzLFxuICBQYXJzZWRUXG4+IHtcbiAgLyoqIEBkZXByZWNhdGVkIC0gcGxlYXNlIHVzZSBgcnVuVG9vbHNgIGluc3RlYWQuICovXG4gIHN0YXRpYyBydW5GdW5jdGlvbnMoXG4gICAgY2xpZW50OiBPcGVuQUksXG4gICAgcGFyYW1zOiBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uUnVubmVyUGFyYW1zPGFueVtdPixcbiAgICBvcHRpb25zPzogUnVubmVyT3B0aW9ucyxcbiAgKTogQ2hhdENvbXBsZXRpb25SdW5uZXI8bnVsbD4ge1xuICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBDaGF0Q29tcGxldGlvblJ1bm5lcigpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtSGVscGVyLU1ldGhvZCc6ICdydW5GdW5jdGlvbnMnIH0sXG4gICAgfTtcbiAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX3J1bkZ1bmN0aW9ucyhjbGllbnQsIHBhcmFtcywgb3B0cykpO1xuICAgIHJldHVybiBydW5uZXI7XG4gIH1cblxuICBzdGF0aWMgcnVuVG9vbHM8UGFyc2VkVD4oXG4gICAgY2xpZW50OiBPcGVuQUksXG4gICAgcGFyYW1zOiBDaGF0Q29tcGxldGlvblRvb2xSdW5uZXJQYXJhbXM8YW55W10+LFxuICAgIG9wdGlvbnM/OiBSdW5uZXJPcHRpb25zLFxuICApOiBDaGF0Q29tcGxldGlvblJ1bm5lcjxQYXJzZWRUPiB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IENoYXRDb21wbGV0aW9uUnVubmVyPFBhcnNlZFQ+KCk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3J1blRvb2xzJyB9LFxuICAgIH07XG4gICAgcnVubmVyLl9ydW4oKCkgPT4gcnVubmVyLl9ydW5Ub29scyhjbGllbnQsIHBhcmFtcywgb3B0cykpO1xuICAgIHJldHVybiBydW5uZXI7XG4gIH1cblxuICBvdmVycmlkZSBfYWRkTWVzc2FnZShcbiAgICB0aGlzOiBDaGF0Q29tcGxldGlvblJ1bm5lcjxQYXJzZWRUPixcbiAgICBtZXNzYWdlOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSxcbiAgICBlbWl0OiBib29sZWFuID0gdHJ1ZSxcbiAgKSB7XG4gICAgc3VwZXIuX2FkZE1lc3NhZ2UobWVzc2FnZSwgZW1pdCk7XG4gICAgaWYgKGlzQXNzaXN0YW50TWVzc2FnZShtZXNzYWdlKSAmJiBtZXNzYWdlLmNvbnRlbnQpIHtcbiAgICAgIHRoaXMuX2VtaXQoJ2NvbnRlbnQnLCBtZXNzYWdlLmNvbnRlbnQgYXMgc3RyaW5nKTtcbiAgICB9XG4gIH1cbn1cbiIsICJjb25zdCBTVFIgPSAwYjAwMDAwMDAwMTtcbmNvbnN0IE5VTSA9IDBiMDAwMDAwMDEwO1xuY29uc3QgQVJSID0gMGIwMDAwMDAxMDA7XG5jb25zdCBPQkogPSAwYjAwMDAwMTAwMDtcbmNvbnN0IE5VTEwgPSAwYjAwMDAxMDAwMDtcbmNvbnN0IEJPT0wgPSAwYjAwMDEwMDAwMDtcbmNvbnN0IE5BTiA9IDBiMDAxMDAwMDAwO1xuY29uc3QgSU5GSU5JVFkgPSAwYjAxMDAwMDAwMDtcbmNvbnN0IE1JTlVTX0lORklOSVRZID0gMGIxMDAwMDAwMDA7XG5cbmNvbnN0IElORiA9IElORklOSVRZIHwgTUlOVVNfSU5GSU5JVFk7XG5jb25zdCBTUEVDSUFMID0gTlVMTCB8IEJPT0wgfCBJTkYgfCBOQU47XG5jb25zdCBBVE9NID0gU1RSIHwgTlVNIHwgU1BFQ0lBTDtcbmNvbnN0IENPTExFQ1RJT04gPSBBUlIgfCBPQko7XG5jb25zdCBBTEwgPSBBVE9NIHwgQ09MTEVDVElPTjtcblxuY29uc3QgQWxsb3cgPSB7XG4gIFNUUixcbiAgTlVNLFxuICBBUlIsXG4gIE9CSixcbiAgTlVMTCxcbiAgQk9PTCxcbiAgTkFOLFxuICBJTkZJTklUWSxcbiAgTUlOVVNfSU5GSU5JVFksXG4gIElORixcbiAgU1BFQ0lBTCxcbiAgQVRPTSxcbiAgQ09MTEVDVElPTixcbiAgQUxMLFxufTtcblxuLy8gVGhlIEpTT04gc3RyaW5nIHNlZ21lbnQgd2FzIHVuYWJsZSB0byBiZSBwYXJzZWQgY29tcGxldGVseVxuY2xhc3MgUGFydGlhbEpTT04gZXh0ZW5kcyBFcnJvciB7fVxuXG5jbGFzcyBNYWxmb3JtZWRKU09OIGV4dGVuZHMgRXJyb3Ige31cblxuLyoqXG4gKiBQYXJzZSBpbmNvbXBsZXRlIEpTT05cbiAqIEBwYXJhbSB7c3RyaW5nfSBqc29uU3RyaW5nIFBhcnRpYWwgSlNPTiB0byBiZSBwYXJzZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbGxvd1BhcnRpYWwgU3BlY2lmeSB3aGF0IHR5cGVzIGFyZSBhbGxvd2VkIHRvIGJlIHBhcnRpYWwsIHNlZSB7QGxpbmsgQWxsb3d9IGZvciBkZXRhaWxzXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIEpTT05cbiAqIEB0aHJvd3Mge1BhcnRpYWxKU09OfSBJZiB0aGUgSlNPTiBpcyBpbmNvbXBsZXRlIChyZWxhdGVkIHRvIHRoZSBgYWxsb3dgIHBhcmFtZXRlcilcbiAqIEB0aHJvd3Mge01hbGZvcm1lZEpTT059IElmIHRoZSBKU09OIGlzIG1hbGZvcm1lZFxuICovXG5mdW5jdGlvbiBwYXJzZUpTT04oanNvblN0cmluZzogc3RyaW5nLCBhbGxvd1BhcnRpYWw6IG51bWJlciA9IEFsbG93LkFMTCk6IGFueSB7XG4gIGlmICh0eXBlb2YganNvblN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3Rpbmcgc3RyLCBnb3QgJHt0eXBlb2YganNvblN0cmluZ31gKTtcbiAgfVxuICBpZiAoIWpzb25TdHJpbmcudHJpbSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke2pzb25TdHJpbmd9IGlzIGVtcHR5YCk7XG4gIH1cbiAgcmV0dXJuIF9wYXJzZUpTT04oanNvblN0cmluZy50cmltKCksIGFsbG93UGFydGlhbCk7XG59XG5cbmNvbnN0IF9wYXJzZUpTT04gPSAoanNvblN0cmluZzogc3RyaW5nLCBhbGxvdzogbnVtYmVyKSA9PiB7XG4gIGNvbnN0IGxlbmd0aCA9IGpzb25TdHJpbmcubGVuZ3RoO1xuICBsZXQgaW5kZXggPSAwO1xuXG4gIGNvbnN0IG1hcmtQYXJ0aWFsSlNPTiA9IChtc2c6IHN0cmluZykgPT4ge1xuICAgIHRocm93IG5ldyBQYXJ0aWFsSlNPTihgJHttc2d9IGF0IHBvc2l0aW9uICR7aW5kZXh9YCk7XG4gIH07XG5cbiAgY29uc3QgdGhyb3dNYWxmb3JtZWRFcnJvciA9IChtc2c6IHN0cmluZykgPT4ge1xuICAgIHRocm93IG5ldyBNYWxmb3JtZWRKU09OKGAke21zZ30gYXQgcG9zaXRpb24gJHtpbmRleH1gKTtcbiAgfTtcblxuICBjb25zdCBwYXJzZUFueTogKCkgPT4gYW55ID0gKCkgPT4ge1xuICAgIHNraXBCbGFuaygpO1xuICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIG1hcmtQYXJ0aWFsSlNPTignVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnKTtcbiAgICBpZiAoanNvblN0cmluZ1tpbmRleF0gPT09ICdcIicpIHJldHVybiBwYXJzZVN0cigpO1xuICAgIGlmIChqc29uU3RyaW5nW2luZGV4XSA9PT0gJ3snKSByZXR1cm4gcGFyc2VPYmooKTtcbiAgICBpZiAoanNvblN0cmluZ1tpbmRleF0gPT09ICdbJykgcmV0dXJuIHBhcnNlQXJyKCk7XG4gICAgaWYgKFxuICAgICAganNvblN0cmluZy5zdWJzdHJpbmcoaW5kZXgsIGluZGV4ICsgNCkgPT09ICdudWxsJyB8fFxuICAgICAgKEFsbG93Lk5VTEwgJiBhbGxvdyAmJiBsZW5ndGggLSBpbmRleCA8IDQgJiYgJ251bGwnLnN0YXJ0c1dpdGgoanNvblN0cmluZy5zdWJzdHJpbmcoaW5kZXgpKSlcbiAgICApIHtcbiAgICAgIGluZGV4ICs9IDQ7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKFxuICAgICAganNvblN0cmluZy5zdWJzdHJpbmcoaW5kZXgsIGluZGV4ICsgNCkgPT09ICd0cnVlJyB8fFxuICAgICAgKEFsbG93LkJPT0wgJiBhbGxvdyAmJiBsZW5ndGggLSBpbmRleCA8IDQgJiYgJ3RydWUnLnN0YXJ0c1dpdGgoanNvblN0cmluZy5zdWJzdHJpbmcoaW5kZXgpKSlcbiAgICApIHtcbiAgICAgIGluZGV4ICs9IDQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAganNvblN0cmluZy5zdWJzdHJpbmcoaW5kZXgsIGluZGV4ICsgNSkgPT09ICdmYWxzZScgfHxcbiAgICAgIChBbGxvdy5CT09MICYgYWxsb3cgJiYgbGVuZ3RoIC0gaW5kZXggPCA1ICYmICdmYWxzZScuc3RhcnRzV2l0aChqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCkpKVxuICAgICkge1xuICAgICAgaW5kZXggKz0gNTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAganNvblN0cmluZy5zdWJzdHJpbmcoaW5kZXgsIGluZGV4ICsgOCkgPT09ICdJbmZpbml0eScgfHxcbiAgICAgIChBbGxvdy5JTkZJTklUWSAmIGFsbG93ICYmIGxlbmd0aCAtIGluZGV4IDwgOCAmJiAnSW5maW5pdHknLnN0YXJ0c1dpdGgoanNvblN0cmluZy5zdWJzdHJpbmcoaW5kZXgpKSlcbiAgICApIHtcbiAgICAgIGluZGV4ICs9IDg7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGpzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4LCBpbmRleCArIDkpID09PSAnLUluZmluaXR5JyB8fFxuICAgICAgKEFsbG93Lk1JTlVTX0lORklOSVRZICYgYWxsb3cgJiZcbiAgICAgICAgMSA8IGxlbmd0aCAtIGluZGV4ICYmXG4gICAgICAgIGxlbmd0aCAtIGluZGV4IDwgOSAmJlxuICAgICAgICAnLUluZmluaXR5Jy5zdGFydHNXaXRoKGpzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4KSkpXG4gICAgKSB7XG4gICAgICBpbmRleCArPSA5O1xuICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAganNvblN0cmluZy5zdWJzdHJpbmcoaW5kZXgsIGluZGV4ICsgMykgPT09ICdOYU4nIHx8XG4gICAgICAoQWxsb3cuTkFOICYgYWxsb3cgJiYgbGVuZ3RoIC0gaW5kZXggPCAzICYmICdOYU4nLnN0YXJ0c1dpdGgoanNvblN0cmluZy5zdWJzdHJpbmcoaW5kZXgpKSlcbiAgICApIHtcbiAgICAgIGluZGV4ICs9IDM7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VOdW0oKTtcbiAgfTtcblxuICBjb25zdCBwYXJzZVN0cjogKCkgPT4gc3RyaW5nID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXg7XG4gICAgbGV0IGVzY2FwZSA9IGZhbHNlO1xuICAgIGluZGV4Kys7IC8vIHNraXAgaW5pdGlhbCBxdW90ZVxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCAmJiAoanNvblN0cmluZ1tpbmRleF0gIT09ICdcIicgfHwgKGVzY2FwZSAmJiBqc29uU3RyaW5nW2luZGV4IC0gMV0gPT09ICdcXFxcJykpKSB7XG4gICAgICBlc2NhcGUgPSBqc29uU3RyaW5nW2luZGV4XSA9PT0gJ1xcXFwnID8gIWVzY2FwZSA6IGZhbHNlO1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgaWYgKGpzb25TdHJpbmcuY2hhckF0KGluZGV4KSA9PSAnXCInKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgKytpbmRleCAtIE51bWJlcihlc2NhcGUpKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93TWFsZm9ybWVkRXJyb3IoU3RyaW5nKGUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEFsbG93LlNUUiAmIGFsbG93KSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgaW5kZXggLSBOdW1iZXIoZXNjYXBlKSkgKyAnXCInKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gU3ludGF4RXJyb3I6IEludmFsaWQgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBqc29uU3RyaW5nLmxhc3RJbmRleE9mKCdcXFxcJykpICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtQYXJ0aWFsSlNPTignVW50ZXJtaW5hdGVkIHN0cmluZyBsaXRlcmFsJyk7XG4gIH07XG5cbiAgY29uc3QgcGFyc2VPYmogPSAoKSA9PiB7XG4gICAgaW5kZXgrKzsgLy8gc2tpcCBpbml0aWFsIGJyYWNlXG4gICAgc2tpcEJsYW5rKCk7XG4gICAgY29uc3Qgb2JqOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlIChqc29uU3RyaW5nW2luZGV4XSAhPT0gJ30nKSB7XG4gICAgICAgIHNraXBCbGFuaygpO1xuICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoICYmIEFsbG93Lk9CSiAmIGFsbG93KSByZXR1cm4gb2JqO1xuICAgICAgICBjb25zdCBrZXkgPSBwYXJzZVN0cigpO1xuICAgICAgICBza2lwQmxhbmsoKTtcbiAgICAgICAgaW5kZXgrKzsgLy8gc2tpcCBjb2xvblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VBbnkoKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWUsIHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoQWxsb3cuT0JKICYgYWxsb3cpIHJldHVybiBvYmo7XG4gICAgICAgICAgZWxzZSB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHNraXBCbGFuaygpO1xuICAgICAgICBpZiAoanNvblN0cmluZ1tpbmRleF0gPT09ICcsJykgaW5kZXgrKzsgLy8gc2tpcCBjb21tYVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChBbGxvdy5PQkogJiBhbGxvdykgcmV0dXJuIG9iajtcbiAgICAgIGVsc2UgbWFya1BhcnRpYWxKU09OKFwiRXhwZWN0ZWQgJ30nIGF0IGVuZCBvZiBvYmplY3RcIik7XG4gICAgfVxuICAgIGluZGV4Kys7IC8vIHNraXAgZmluYWwgYnJhY2VcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlQXJyID0gKCkgPT4ge1xuICAgIGluZGV4Kys7IC8vIHNraXAgaW5pdGlhbCBicmFja2V0XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlIChqc29uU3RyaW5nW2luZGV4XSAhPT0gJ10nKSB7XG4gICAgICAgIGFyci5wdXNoKHBhcnNlQW55KCkpO1xuICAgICAgICBza2lwQmxhbmsoKTtcbiAgICAgICAgaWYgKGpzb25TdHJpbmdbaW5kZXhdID09PSAnLCcpIHtcbiAgICAgICAgICBpbmRleCsrOyAvLyBza2lwIGNvbW1hXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoQWxsb3cuQVJSICYgYWxsb3cpIHtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cbiAgICAgIG1hcmtQYXJ0aWFsSlNPTihcIkV4cGVjdGVkICddJyBhdCBlbmQgb2YgYXJyYXlcIik7XG4gICAgfVxuICAgIGluZGV4Kys7IC8vIHNraXAgZmluYWwgYnJhY2tldFxuICAgIHJldHVybiBhcnI7XG4gIH07XG5cbiAgY29uc3QgcGFyc2VOdW0gPSAoKSA9PiB7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBpZiAoanNvblN0cmluZyA9PT0gJy0nICYmIEFsbG93Lk5VTSAmIGFsbG93KSBtYXJrUGFydGlhbEpTT04oXCJOb3Qgc3VyZSB3aGF0ICctJyBpc1wiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoQWxsb3cuTlVNICYgYWxsb3cpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCcuJyA9PT0ganNvblN0cmluZ1tqc29uU3RyaW5nLmxlbmd0aCAtIDFdKVxuICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uU3RyaW5nLnN1YnN0cmluZygwLCBqc29uU3RyaW5nLmxhc3RJbmRleE9mKCcuJykpKTtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcuc3Vic3RyaW5nKDAsIGpzb25TdHJpbmcubGFzdEluZGV4T2YoJ2UnKSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3dNYWxmb3JtZWRFcnJvcihTdHJpbmcoZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXg7XG5cbiAgICBpZiAoanNvblN0cmluZ1tpbmRleF0gPT09ICctJykgaW5kZXgrKztcbiAgICB3aGlsZSAoanNvblN0cmluZ1tpbmRleF0gJiYgIScsXX0nLmluY2x1ZGVzKGpzb25TdHJpbmdbaW5kZXhdISkpIGluZGV4Kys7XG5cbiAgICBpZiAoaW5kZXggPT0gbGVuZ3RoICYmICEoQWxsb3cuTlVNICYgYWxsb3cpKSBtYXJrUGFydGlhbEpTT04oJ1VudGVybWluYXRlZCBudW1iZXIgbGl0ZXJhbCcpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBpbmRleCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChqc29uU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgaW5kZXgpID09PSAnLScgJiYgQWxsb3cuTlVNICYgYWxsb3cpXG4gICAgICAgIG1hcmtQYXJ0aWFsSlNPTihcIk5vdCBzdXJlIHdoYXQgJy0nIGlzXCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGpzb25TdHJpbmcubGFzdEluZGV4T2YoJ2UnKSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvd01hbGZvcm1lZEVycm9yKFN0cmluZyhlKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHNraXBCbGFuayA9ICgpID0+IHtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGggJiYgJyBcXG5cXHJcXHQnLmluY2x1ZGVzKGpzb25TdHJpbmdbaW5kZXhdISkpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBwYXJzZUFueSgpO1xufTtcblxuLy8gdXNpbmcgdGhpcyBmdW5jdGlvbiB3aXRoIG1hbGZvcm1lZCBKU09OIGlzIHVuZGVmaW5lZCBiZWhhdmlvclxuY29uc3QgcGFydGlhbFBhcnNlID0gKGlucHV0OiBzdHJpbmcpID0+IHBhcnNlSlNPTihpbnB1dCwgQWxsb3cuQUxMIF4gQWxsb3cuTlVNKTtcblxuZXhwb3J0IHsgcGFydGlhbFBhcnNlLCBQYXJ0aWFsSlNPTiwgTWFsZm9ybWVkSlNPTiB9O1xuIiwgImltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQge1xuICBPcGVuQUlFcnJvcixcbiAgQVBJVXNlckFib3J0RXJyb3IsXG4gIExlbmd0aEZpbmlzaFJlYXNvbkVycm9yLFxuICBDb250ZW50RmlsdGVyRmluaXNoUmVhc29uRXJyb3IsXG59IGZyb20gJy4uL2Vycm9yJztcbmltcG9ydCB7XG4gIENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iLFxuICB0eXBlIENoYXRDb21wbGV0aW9uLFxuICB0eXBlIENoYXRDb21wbGV0aW9uQ2h1bmssXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlLFxufSBmcm9tICcuLi9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucyc7XG5pbXBvcnQge1xuICBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyLFxuICB0eXBlIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMsXG59IGZyb20gJy4vQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcic7XG5pbXBvcnQgeyB0eXBlIFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vX3NoaW1zL2luZGV4JztcbmltcG9ydCB7IFN0cmVhbSB9IGZyb20gJy4uL3N0cmVhbWluZyc7XG5pbXBvcnQgT3BlbkFJIGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IFBhcnNlZENoYXRDb21wbGV0aW9uIH0gZnJvbSAnLi4vcmVzb3VyY2VzL2JldGEvY2hhdC9jb21wbGV0aW9ucyc7XG5pbXBvcnQge1xuICBBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQsXG4gIGhhc0F1dG9QYXJzZWFibGVJbnB1dCxcbiAgaXNBdXRvUGFyc2FibGVSZXNwb25zZUZvcm1hdCxcbiAgaXNBdXRvUGFyc2FibGVUb29sLFxuICBtYXliZVBhcnNlQ2hhdENvbXBsZXRpb24sXG4gIHNob3VsZFBhcnNlVG9vbENhbGwsXG59IGZyb20gJy4uL2xpYi9wYXJzZXInO1xuaW1wb3J0IHsgcGFydGlhbFBhcnNlIH0gZnJvbSAnLi4vX3ZlbmRvci9wYXJ0aWFsLWpzb24tcGFyc2VyL3BhcnNlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGVudERlbHRhRXZlbnQge1xuICBkZWx0YTogc3RyaW5nO1xuICBzbmFwc2hvdDogc3RyaW5nO1xuICBwYXJzZWQ6IHVua25vd24gfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRlbnREb25lRXZlbnQ8UGFyc2VkVCA9IG51bGw+IHtcbiAgY29udGVudDogc3RyaW5nO1xuICBwYXJzZWQ6IFBhcnNlZFQgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlZnVzYWxEZWx0YUV2ZW50IHtcbiAgZGVsdGE6IHN0cmluZztcbiAgc25hcHNob3Q6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWZ1c2FsRG9uZUV2ZW50IHtcbiAgcmVmdXNhbDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uVG9vbENhbGxBcmd1bWVudHNEZWx0YUV2ZW50IHtcbiAgbmFtZTogc3RyaW5nO1xuXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgYXJndW1lbnRzOiBzdHJpbmc7XG5cbiAgcGFyc2VkX2FyZ3VtZW50czogdW5rbm93bjtcblxuICBhcmd1bWVudHNfZGVsdGE6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvblRvb2xDYWxsQXJndW1lbnRzRG9uZUV2ZW50IHtcbiAgbmFtZTogc3RyaW5nO1xuXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgYXJndW1lbnRzOiBzdHJpbmc7XG5cbiAgcGFyc2VkX2FyZ3VtZW50czogdW5rbm93bjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dQcm9ic0NvbnRlbnREZWx0YUV2ZW50IHtcbiAgY29udGVudDogQXJyYXk8Q2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2I+O1xuICBzbmFwc2hvdDogQXJyYXk8Q2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2I+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ1Byb2JzQ29udGVudERvbmVFdmVudCB7XG4gIGNvbnRlbnQ6IEFycmF5PENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dQcm9ic1JlZnVzYWxEZWx0YUV2ZW50IHtcbiAgcmVmdXNhbDogQXJyYXk8Q2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2I+O1xuICBzbmFwc2hvdDogQXJyYXk8Q2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2I+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ1Byb2JzUmVmdXNhbERvbmVFdmVudCB7XG4gIHJlZnVzYWw6IEFycmF5PENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvblN0cmVhbUV2ZW50czxQYXJzZWRUID0gbnVsbD4gZXh0ZW5kcyBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzIHtcbiAgY29udGVudDogKGNvbnRlbnREZWx0YTogc3RyaW5nLCBjb250ZW50U25hcHNob3Q6IHN0cmluZykgPT4gdm9pZDtcbiAgY2h1bms6IChjaHVuazogQ2hhdENvbXBsZXRpb25DaHVuaywgc25hcHNob3Q6IENoYXRDb21wbGV0aW9uU25hcHNob3QpID0+IHZvaWQ7XG5cbiAgJ2NvbnRlbnQuZGVsdGEnOiAocHJvcHM6IENvbnRlbnREZWx0YUV2ZW50KSA9PiB2b2lkO1xuICAnY29udGVudC5kb25lJzogKHByb3BzOiBDb250ZW50RG9uZUV2ZW50PFBhcnNlZFQ+KSA9PiB2b2lkO1xuXG4gICdyZWZ1c2FsLmRlbHRhJzogKHByb3BzOiBSZWZ1c2FsRGVsdGFFdmVudCkgPT4gdm9pZDtcbiAgJ3JlZnVzYWwuZG9uZSc6IChwcm9wczogUmVmdXNhbERvbmVFdmVudCkgPT4gdm9pZDtcblxuICAndG9vbF9jYWxscy5mdW5jdGlvbi5hcmd1bWVudHMuZGVsdGEnOiAocHJvcHM6IEZ1bmN0aW9uVG9vbENhbGxBcmd1bWVudHNEZWx0YUV2ZW50KSA9PiB2b2lkO1xuICAndG9vbF9jYWxscy5mdW5jdGlvbi5hcmd1bWVudHMuZG9uZSc6IChwcm9wczogRnVuY3Rpb25Ub29sQ2FsbEFyZ3VtZW50c0RvbmVFdmVudCkgPT4gdm9pZDtcblxuICAnbG9ncHJvYnMuY29udGVudC5kZWx0YSc6IChwcm9wczogTG9nUHJvYnNDb250ZW50RGVsdGFFdmVudCkgPT4gdm9pZDtcbiAgJ2xvZ3Byb2JzLmNvbnRlbnQuZG9uZSc6IChwcm9wczogTG9nUHJvYnNDb250ZW50RG9uZUV2ZW50KSA9PiB2b2lkO1xuXG4gICdsb2dwcm9icy5yZWZ1c2FsLmRlbHRhJzogKHByb3BzOiBMb2dQcm9ic1JlZnVzYWxEZWx0YUV2ZW50KSA9PiB2b2lkO1xuICAnbG9ncHJvYnMucmVmdXNhbC5kb25lJzogKHByb3BzOiBMb2dQcm9ic1JlZnVzYWxEb25lRXZlbnQpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uU3RyZWFtUGFyYW1zID0gT21pdDxDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2UsICdzdHJlYW0nPiAmIHtcbiAgc3RyZWFtPzogdHJ1ZTtcbn07XG5cbmludGVyZmFjZSBDaG9pY2VFdmVudFN0YXRlIHtcbiAgY29udGVudF9kb25lOiBib29sZWFuO1xuICByZWZ1c2FsX2RvbmU6IGJvb2xlYW47XG4gIGxvZ3Byb2JzX2NvbnRlbnRfZG9uZTogYm9vbGVhbjtcbiAgbG9ncHJvYnNfcmVmdXNhbF9kb25lOiBib29sZWFuO1xuICBjdXJyZW50X3Rvb2xfY2FsbF9pbmRleDogbnVtYmVyIHwgbnVsbDtcbiAgZG9uZV90b29sX2NhbGxzOiBTZXQ8bnVtYmVyPjtcbn1cblxuZXhwb3J0IGNsYXNzIENoYXRDb21wbGV0aW9uU3RyZWFtPFBhcnNlZFQgPSBudWxsPlxuICBleHRlbmRzIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXI8Q2hhdENvbXBsZXRpb25TdHJlYW1FdmVudHM8UGFyc2VkVD4sIFBhcnNlZFQ+XG4gIGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZTxDaGF0Q29tcGxldGlvbkNodW5rPlxue1xuICAjcGFyYW1zOiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyB8IG51bGw7XG4gICNjaG9pY2VFdmVudFN0YXRlczogQ2hvaWNlRXZlbnRTdGF0ZVtdO1xuICAjY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3Q6IENoYXRDb21wbGV0aW9uU25hcHNob3QgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IocGFyYW1zOiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyB8IG51bGwpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI3BhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLiNjaG9pY2VFdmVudFN0YXRlcyA9IFtdO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90KCk6IENoYXRDb21wbGV0aW9uU25hcHNob3QgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlbmRlZCBmb3IgdXNlIG9uIHRoZSBmcm9udGVuZCwgY29uc3VtaW5nIGEgc3RyZWFtIHByb2R1Y2VkIHdpdGhcbiAgICogYC50b1JlYWRhYmxlU3RyZWFtKClgIG9uIHRoZSBiYWNrZW5kLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgbWVzc2FnZXMgc2VudCB0byB0aGUgbW9kZWwgZG8gbm90IGFwcGVhciBpbiBgLm9uKCdtZXNzYWdlJylgXG4gICAqIGluIHRoaXMgY29udGV4dC5cbiAgICovXG4gIHN0YXRpYyBmcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSk6IENoYXRDb21wbGV0aW9uU3RyZWFtPG51bGw+IHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgQ2hhdENvbXBsZXRpb25TdHJlYW0obnVsbCk7XG4gICAgcnVubmVyLl9ydW4oKCkgPT4gcnVubmVyLl9mcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVDaGF0Q29tcGxldGlvbjxQYXJzZWRUPihcbiAgICBjbGllbnQ6IE9wZW5BSSxcbiAgICBwYXJhbXM6IENoYXRDb21wbGV0aW9uU3RyZWFtUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDaGF0Q29tcGxldGlvblN0cmVhbTxQYXJzZWRUPiB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IENoYXRDb21wbGV0aW9uU3RyZWFtPFBhcnNlZFQ+KHBhcmFtcyBhcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyk7XG4gICAgcnVubmVyLl9ydW4oKCkgPT5cbiAgICAgIHJ1bm5lci5fcnVuQ2hhdENvbXBsZXRpb24oXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgeyAuLi5wYXJhbXMsIHN0cmVhbTogdHJ1ZSB9LFxuICAgICAgICB7IC4uLm9wdGlvbnMsIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAnc3RyZWFtJyB9IH0sXG4gICAgICApLFxuICAgICk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxuXG4gICNiZWdpblJlcXVlc3QoKSB7XG4gICAgaWYgKHRoaXMuZW5kZWQpIHJldHVybjtcbiAgICB0aGlzLiNjdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gICNnZXRDaG9pY2VFdmVudFN0YXRlKGNob2ljZTogQ2hhdENvbXBsZXRpb25TbmFwc2hvdC5DaG9pY2UpOiBDaG9pY2VFdmVudFN0YXRlIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLiNjaG9pY2VFdmVudFN0YXRlc1tjaG9pY2UuaW5kZXhdO1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIHN0YXRlID0ge1xuICAgICAgY29udGVudF9kb25lOiBmYWxzZSxcbiAgICAgIHJlZnVzYWxfZG9uZTogZmFsc2UsXG4gICAgICBsb2dwcm9ic19jb250ZW50X2RvbmU6IGZhbHNlLFxuICAgICAgbG9ncHJvYnNfcmVmdXNhbF9kb25lOiBmYWxzZSxcbiAgICAgIGRvbmVfdG9vbF9jYWxsczogbmV3IFNldCgpLFxuICAgICAgY3VycmVudF90b29sX2NhbGxfaW5kZXg6IG51bGwsXG4gICAgfTtcbiAgICB0aGlzLiNjaG9pY2VFdmVudFN0YXRlc1tjaG9pY2UuaW5kZXhdID0gc3RhdGU7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgI2FkZENodW5rKHRoaXM6IENoYXRDb21wbGV0aW9uU3RyZWFtPFBhcnNlZFQ+LCBjaHVuazogQ2hhdENvbXBsZXRpb25DaHVuaykge1xuICAgIGlmICh0aGlzLmVuZGVkKSByZXR1cm47XG5cbiAgICBjb25zdCBjb21wbGV0aW9uID0gdGhpcy4jYWNjdW11bGF0ZUNoYXRDb21wbGV0aW9uKGNodW5rKTtcbiAgICB0aGlzLl9lbWl0KCdjaHVuaycsIGNodW5rLCBjb21wbGV0aW9uKTtcblxuICAgIGZvciAoY29uc3QgY2hvaWNlIG9mIGNodW5rLmNob2ljZXMpIHtcbiAgICAgIGNvbnN0IGNob2ljZVNuYXBzaG90ID0gY29tcGxldGlvbi5jaG9pY2VzW2Nob2ljZS5pbmRleF0hO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGNob2ljZS5kZWx0YS5jb250ZW50ICE9IG51bGwgJiZcbiAgICAgICAgY2hvaWNlU25hcHNob3QubWVzc2FnZT8ucm9sZSA9PT0gJ2Fzc2lzdGFudCcgJiZcbiAgICAgICAgY2hvaWNlU25hcHNob3QubWVzc2FnZT8uY29udGVudFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJ2NvbnRlbnQnLCBjaG9pY2UuZGVsdGEuY29udGVudCwgY2hvaWNlU25hcHNob3QubWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgdGhpcy5fZW1pdCgnY29udGVudC5kZWx0YScsIHtcbiAgICAgICAgICBkZWx0YTogY2hvaWNlLmRlbHRhLmNvbnRlbnQsXG4gICAgICAgICAgc25hcHNob3Q6IGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgICBwYXJzZWQ6IGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UucGFyc2VkLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBjaG9pY2UuZGVsdGEucmVmdXNhbCAhPSBudWxsICYmXG4gICAgICAgIGNob2ljZVNuYXBzaG90Lm1lc3NhZ2U/LnJvbGUgPT09ICdhc3Npc3RhbnQnICYmXG4gICAgICAgIGNob2ljZVNuYXBzaG90Lm1lc3NhZ2U/LnJlZnVzYWxcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9lbWl0KCdyZWZ1c2FsLmRlbHRhJywge1xuICAgICAgICAgIGRlbHRhOiBjaG9pY2UuZGVsdGEucmVmdXNhbCxcbiAgICAgICAgICBzbmFwc2hvdDogY2hvaWNlU25hcHNob3QubWVzc2FnZS5yZWZ1c2FsLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNob2ljZS5sb2dwcm9icz8uY29udGVudCAhPSBudWxsICYmIGNob2ljZVNuYXBzaG90Lm1lc3NhZ2U/LnJvbGUgPT09ICdhc3Npc3RhbnQnKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJ2xvZ3Byb2JzLmNvbnRlbnQuZGVsdGEnLCB7XG4gICAgICAgICAgY29udGVudDogY2hvaWNlLmxvZ3Byb2JzPy5jb250ZW50LFxuICAgICAgICAgIHNuYXBzaG90OiBjaG9pY2VTbmFwc2hvdC5sb2dwcm9icz8uY29udGVudCA/PyBbXSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaG9pY2UubG9ncHJvYnM/LnJlZnVzYWwgIT0gbnVsbCAmJiBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlPy5yb2xlID09PSAnYXNzaXN0YW50Jykge1xuICAgICAgICB0aGlzLl9lbWl0KCdsb2dwcm9icy5yZWZ1c2FsLmRlbHRhJywge1xuICAgICAgICAgIHJlZnVzYWw6IGNob2ljZS5sb2dwcm9icz8ucmVmdXNhbCxcbiAgICAgICAgICBzbmFwc2hvdDogY2hvaWNlU25hcHNob3QubG9ncHJvYnM/LnJlZnVzYWwgPz8gW10sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuI2dldENob2ljZUV2ZW50U3RhdGUoY2hvaWNlU25hcHNob3QpO1xuXG4gICAgICBpZiAoY2hvaWNlU25hcHNob3QuZmluaXNoX3JlYXNvbikge1xuICAgICAgICB0aGlzLiNlbWl0Q29udGVudERvbmVFdmVudHMoY2hvaWNlU25hcHNob3QpO1xuXG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50X3Rvb2xfY2FsbF9pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy4jZW1pdFRvb2xDYWxsRG9uZUV2ZW50KGNob2ljZVNuYXBzaG90LCBzdGF0ZS5jdXJyZW50X3Rvb2xfY2FsbF9pbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBjaG9pY2UuZGVsdGEudG9vbF9jYWxscyA/PyBbXSkge1xuICAgICAgICBpZiAoc3RhdGUuY3VycmVudF90b29sX2NhbGxfaW5kZXggIT09IHRvb2xDYWxsLmluZGV4KSB7XG4gICAgICAgICAgdGhpcy4jZW1pdENvbnRlbnREb25lRXZlbnRzKGNob2ljZVNuYXBzaG90KTtcblxuICAgICAgICAgIC8vIG5ldyB0b29sIGNhbGwgc3RhcnRlZCwgdGhlIHByZXZpb3VzIG9uZSBpcyBkb25lXG4gICAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRfdG9vbF9jYWxsX2luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI2VtaXRUb29sQ2FsbERvbmVFdmVudChjaG9pY2VTbmFwc2hvdCwgc3RhdGUuY3VycmVudF90b29sX2NhbGxfaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmN1cnJlbnRfdG9vbF9jYWxsX2luZGV4ID0gdG9vbENhbGwuaW5kZXg7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgdG9vbENhbGxEZWx0YSBvZiBjaG9pY2UuZGVsdGEudG9vbF9jYWxscyA/PyBbXSkge1xuICAgICAgICBjb25zdCB0b29sQ2FsbFNuYXBzaG90ID0gY2hvaWNlU25hcHNob3QubWVzc2FnZS50b29sX2NhbGxzPy5bdG9vbENhbGxEZWx0YS5pbmRleF07XG4gICAgICAgIGlmICghdG9vbENhbGxTbmFwc2hvdD8udHlwZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvb2xDYWxsU25hcHNob3Q/LnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0KCd0b29sX2NhbGxzLmZ1bmN0aW9uLmFyZ3VtZW50cy5kZWx0YScsIHtcbiAgICAgICAgICAgIG5hbWU6IHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24/Lm5hbWUsXG4gICAgICAgICAgICBpbmRleDogdG9vbENhbGxEZWx0YS5pbmRleCxcbiAgICAgICAgICAgIGFyZ3VtZW50czogdG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICBwYXJzZWRfYXJndW1lbnRzOiB0b29sQ2FsbFNuYXBzaG90LmZ1bmN0aW9uLnBhcnNlZF9hcmd1bWVudHMsXG4gICAgICAgICAgICBhcmd1bWVudHNfZGVsdGE6IHRvb2xDYWxsRGVsdGEuZnVuY3Rpb24/LmFyZ3VtZW50cyA/PyAnJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NlcnROZXZlcih0b29sQ2FsbFNuYXBzaG90Py50eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gICNlbWl0VG9vbENhbGxEb25lRXZlbnQoY2hvaWNlU25hcHNob3Q6IENoYXRDb21wbGV0aW9uU25hcHNob3QuQ2hvaWNlLCB0b29sQ2FsbEluZGV4OiBudW1iZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuI2dldENob2ljZUV2ZW50U3RhdGUoY2hvaWNlU25hcHNob3QpO1xuICAgIGlmIChzdGF0ZS5kb25lX3Rvb2xfY2FsbHMuaGFzKHRvb2xDYWxsSW5kZXgpKSB7XG4gICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGZpcmVkIHRoZSBkb25lIGV2ZW50XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdG9vbENhbGxTbmFwc2hvdCA9IGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UudG9vbF9jYWxscz8uW3Rvb2xDYWxsSW5kZXhdO1xuICAgIGlmICghdG9vbENhbGxTbmFwc2hvdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyB0b29sIGNhbGwgc25hcHNob3QnKTtcbiAgICB9XG4gICAgaWYgKCF0b29sQ2FsbFNuYXBzaG90LnR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndG9vbCBjYWxsIHNuYXBzaG90IG1pc3NpbmcgYHR5cGVgJyk7XG4gICAgfVxuXG4gICAgaWYgKHRvb2xDYWxsU25hcHNob3QudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgaW5wdXRUb29sID0gdGhpcy4jcGFyYW1zPy50b29scz8uZmluZChcbiAgICAgICAgKHRvb2wpID0+IHRvb2wudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0b29sLmZ1bmN0aW9uLm5hbWUgPT09IHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24ubmFtZSxcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuX2VtaXQoJ3Rvb2xfY2FsbHMuZnVuY3Rpb24uYXJndW1lbnRzLmRvbmUnLCB7XG4gICAgICAgIG5hbWU6IHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgaW5kZXg6IHRvb2xDYWxsSW5kZXgsXG4gICAgICAgIGFyZ3VtZW50czogdG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgIHBhcnNlZF9hcmd1bWVudHM6XG4gICAgICAgICAgaXNBdXRvUGFyc2FibGVUb29sKGlucHV0VG9vbCkgPyBpbnB1dFRvb2wuJHBhcnNlUmF3KHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24uYXJndW1lbnRzKVxuICAgICAgICAgIDogaW5wdXRUb29sPy5mdW5jdGlvbi5zdHJpY3QgPyBKU09OLnBhcnNlKHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24uYXJndW1lbnRzKVxuICAgICAgICAgIDogbnVsbCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnROZXZlcih0b29sQ2FsbFNuYXBzaG90LnR5cGUpO1xuICAgIH1cbiAgfVxuXG4gICNlbWl0Q29udGVudERvbmVFdmVudHMoY2hvaWNlU25hcHNob3Q6IENoYXRDb21wbGV0aW9uU25hcHNob3QuQ2hvaWNlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLiNnZXRDaG9pY2VFdmVudFN0YXRlKGNob2ljZVNuYXBzaG90KTtcblxuICAgIGlmIChjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLmNvbnRlbnQgJiYgIXN0YXRlLmNvbnRlbnRfZG9uZSkge1xuICAgICAgc3RhdGUuY29udGVudF9kb25lID0gdHJ1ZTtcblxuICAgICAgY29uc3QgcmVzcG9uc2VGb3JtYXQgPSB0aGlzLiNnZXRBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQoKTtcblxuICAgICAgdGhpcy5fZW1pdCgnY29udGVudC5kb25lJywge1xuICAgICAgICBjb250ZW50OiBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgIHBhcnNlZDogcmVzcG9uc2VGb3JtYXQgPyByZXNwb25zZUZvcm1hdC4kcGFyc2VSYXcoY2hvaWNlU25hcHNob3QubWVzc2FnZS5jb250ZW50KSA6IChudWxsIGFzIGFueSksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY2hvaWNlU25hcHNob3QubWVzc2FnZS5yZWZ1c2FsICYmICFzdGF0ZS5yZWZ1c2FsX2RvbmUpIHtcbiAgICAgIHN0YXRlLnJlZnVzYWxfZG9uZSA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2VtaXQoJ3JlZnVzYWwuZG9uZScsIHsgcmVmdXNhbDogY2hvaWNlU25hcHNob3QubWVzc2FnZS5yZWZ1c2FsIH0pO1xuICAgIH1cblxuICAgIGlmIChjaG9pY2VTbmFwc2hvdC5sb2dwcm9icz8uY29udGVudCAmJiAhc3RhdGUubG9ncHJvYnNfY29udGVudF9kb25lKSB7XG4gICAgICBzdGF0ZS5sb2dwcm9ic19jb250ZW50X2RvbmUgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9lbWl0KCdsb2dwcm9icy5jb250ZW50LmRvbmUnLCB7IGNvbnRlbnQ6IGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzLmNvbnRlbnQgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzPy5yZWZ1c2FsICYmICFzdGF0ZS5sb2dwcm9ic19yZWZ1c2FsX2RvbmUpIHtcbiAgICAgIHN0YXRlLmxvZ3Byb2JzX3JlZnVzYWxfZG9uZSA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2VtaXQoJ2xvZ3Byb2JzLnJlZnVzYWwuZG9uZScsIHsgcmVmdXNhbDogY2hvaWNlU25hcHNob3QubG9ncHJvYnMucmVmdXNhbCB9KTtcbiAgICB9XG4gIH1cblxuICAjZW5kUmVxdWVzdCgpOiBQYXJzZWRDaGF0Q29tcGxldGlvbjxQYXJzZWRUPiB7XG4gICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgc3RyZWFtIGhhcyBlbmRlZCwgdGhpcyBzaG91bGRuJ3QgaGFwcGVuYCk7XG4gICAgfVxuICAgIGNvbnN0IHNuYXBzaG90ID0gdGhpcy4jY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3Q7XG4gICAgaWYgKCFzbmFwc2hvdCkge1xuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGByZXF1ZXN0IGVuZGVkIHdpdGhvdXQgc2VuZGluZyBhbnkgY2h1bmtzYCk7XG4gICAgfVxuICAgIHRoaXMuI2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuI2Nob2ljZUV2ZW50U3RhdGVzID0gW107XG4gICAgcmV0dXJuIGZpbmFsaXplQ2hhdENvbXBsZXRpb24oc25hcHNob3QsIHRoaXMuI3BhcmFtcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgYXN5bmMgX2NyZWF0ZUNoYXRDb21wbGV0aW9uKFxuICAgIGNsaWVudDogT3BlbkFJLFxuICAgIHBhcmFtczogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IFByb21pc2U8UGFyc2VkQ2hhdENvbXBsZXRpb248UGFyc2VkVD4+IHtcbiAgICBzdXBlci5fY3JlYXRlQ2hhdENvbXBsZXRpb247XG4gICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgIGlmIChzaWduYWwpIHtcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgfVxuICAgIHRoaXMuI2JlZ2luUmVxdWVzdCgpO1xuXG4gICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgY2xpZW50LmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKFxuICAgICAgeyAuLi5wYXJhbXMsIHN0cmVhbTogdHJ1ZSB9LFxuICAgICAgeyAuLi5vcHRpb25zLCBzaWduYWw6IHRoaXMuY29udHJvbGxlci5zaWduYWwgfSxcbiAgICApO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCgpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICB0aGlzLiNhZGRDaHVuayhjaHVuayk7XG4gICAgfVxuICAgIGlmIChzdHJlYW0uY29udHJvbGxlci5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hhdENvbXBsZXRpb24odGhpcy4jZW5kUmVxdWVzdCgpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfZnJvbVJlYWRhYmxlU3RyZWFtKFxuICAgIHJlYWRhYmxlU3RyZWFtOiBSZWFkYWJsZVN0cmVhbSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxDaGF0Q29tcGxldGlvbj4ge1xuICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbDtcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gdGhpcy5jb250cm9sbGVyLmFib3J0KCkpO1xuICAgIH1cbiAgICB0aGlzLiNiZWdpblJlcXVlc3QoKTtcbiAgICB0aGlzLl9jb25uZWN0ZWQoKTtcbiAgICBjb25zdCBzdHJlYW0gPSBTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtPENoYXRDb21wbGV0aW9uQ2h1bms+KHJlYWRhYmxlU3RyZWFtLCB0aGlzLmNvbnRyb2xsZXIpO1xuICAgIGxldCBjaGF0SWQ7XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgIGlmIChjaGF0SWQgJiYgY2hhdElkICE9PSBjaHVuay5pZCkge1xuICAgICAgICAvLyBBIG5ldyByZXF1ZXN0IGhhcyBiZWVuIG1hZGUuXG4gICAgICAgIHRoaXMuX2FkZENoYXRDb21wbGV0aW9uKHRoaXMuI2VuZFJlcXVlc3QoKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuI2FkZENodW5rKGNodW5rKTtcbiAgICAgIGNoYXRJZCA9IGNodW5rLmlkO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLmNvbnRyb2xsZXIuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoYXRDb21wbGV0aW9uKHRoaXMuI2VuZFJlcXVlc3QoKSk7XG4gIH1cblxuICAjZ2V0QXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0KCk6IEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdDxQYXJzZWRUPiB8IG51bGwge1xuICAgIGNvbnN0IHJlc3BvbnNlRm9ybWF0ID0gdGhpcy4jcGFyYW1zPy5yZXNwb25zZV9mb3JtYXQ7XG4gICAgaWYgKGlzQXV0b1BhcnNhYmxlUmVzcG9uc2VGb3JtYXQ8UGFyc2VkVD4ocmVzcG9uc2VGb3JtYXQpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2VGb3JtYXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAjYWNjdW11bGF0ZUNoYXRDb21wbGV0aW9uKGNodW5rOiBDaGF0Q29tcGxldGlvbkNodW5rKTogQ2hhdENvbXBsZXRpb25TbmFwc2hvdCB7XG4gICAgbGV0IHNuYXBzaG90ID0gdGhpcy4jY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3Q7XG4gICAgY29uc3QgeyBjaG9pY2VzLCAuLi5yZXN0IH0gPSBjaHVuaztcbiAgICBpZiAoIXNuYXBzaG90KSB7XG4gICAgICBzbmFwc2hvdCA9IHRoaXMuI2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90ID0ge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICBjaG9pY2VzOiBbXSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oc25hcHNob3QsIHJlc3QpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgeyBkZWx0YSwgZmluaXNoX3JlYXNvbiwgaW5kZXgsIGxvZ3Byb2JzID0gbnVsbCwgLi4ub3RoZXIgfSBvZiBjaHVuay5jaG9pY2VzKSB7XG4gICAgICBsZXQgY2hvaWNlID0gc25hcHNob3QuY2hvaWNlc1tpbmRleF07XG4gICAgICBpZiAoIWNob2ljZSkge1xuICAgICAgICBjaG9pY2UgPSBzbmFwc2hvdC5jaG9pY2VzW2luZGV4XSA9IHsgZmluaXNoX3JlYXNvbiwgaW5kZXgsIG1lc3NhZ2U6IHt9LCBsb2dwcm9icywgLi4ub3RoZXIgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvZ3Byb2JzKSB7XG4gICAgICAgIGlmICghY2hvaWNlLmxvZ3Byb2JzKSB7XG4gICAgICAgICAgY2hvaWNlLmxvZ3Byb2JzID0gT2JqZWN0LmFzc2lnbih7fSwgbG9ncHJvYnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHsgY29udGVudCwgcmVmdXNhbCwgLi4ucmVzdCB9ID0gbG9ncHJvYnM7XG4gICAgICAgICAgYXNzZXJ0SXNFbXB0eShyZXN0KTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGNob2ljZS5sb2dwcm9icywgcmVzdCk7XG5cbiAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgY2hvaWNlLmxvZ3Byb2JzLmNvbnRlbnQgPz89IFtdO1xuICAgICAgICAgICAgY2hvaWNlLmxvZ3Byb2JzLmNvbnRlbnQucHVzaCguLi5jb250ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVmdXNhbCkge1xuICAgICAgICAgICAgY2hvaWNlLmxvZ3Byb2JzLnJlZnVzYWwgPz89IFtdO1xuICAgICAgICAgICAgY2hvaWNlLmxvZ3Byb2JzLnJlZnVzYWwucHVzaCguLi5yZWZ1c2FsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmlzaF9yZWFzb24pIHtcbiAgICAgICAgY2hvaWNlLmZpbmlzaF9yZWFzb24gPSBmaW5pc2hfcmVhc29uO1xuXG4gICAgICAgIGlmICh0aGlzLiNwYXJhbXMgJiYgaGFzQXV0b1BhcnNlYWJsZUlucHV0KHRoaXMuI3BhcmFtcykpIHtcbiAgICAgICAgICBpZiAoZmluaXNoX3JlYXNvbiA9PT0gJ2xlbmd0aCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBMZW5ndGhGaW5pc2hSZWFzb25FcnJvcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmaW5pc2hfcmVhc29uID09PSAnY29udGVudF9maWx0ZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29udGVudEZpbHRlckZpbmlzaFJlYXNvbkVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oY2hvaWNlLCBvdGhlcik7XG5cbiAgICAgIGlmICghZGVsdGEpIGNvbnRpbnVlOyAvLyBTaG91bGRuJ3QgaGFwcGVuOyBqdXN0IGluIGNhc2UuXG5cbiAgICAgIGNvbnN0IHsgY29udGVudCwgcmVmdXNhbCwgZnVuY3Rpb25fY2FsbCwgcm9sZSwgdG9vbF9jYWxscywgLi4ucmVzdCB9ID0gZGVsdGE7XG4gICAgICBhc3NlcnRJc0VtcHR5KHJlc3QpO1xuICAgICAgT2JqZWN0LmFzc2lnbihjaG9pY2UubWVzc2FnZSwgcmVzdCk7XG5cbiAgICAgIGlmIChyZWZ1c2FsKSB7XG4gICAgICAgIGNob2ljZS5tZXNzYWdlLnJlZnVzYWwgPSAoY2hvaWNlLm1lc3NhZ2UucmVmdXNhbCB8fCAnJykgKyByZWZ1c2FsO1xuICAgICAgfVxuXG4gICAgICBpZiAocm9sZSkgY2hvaWNlLm1lc3NhZ2Uucm9sZSA9IHJvbGU7XG4gICAgICBpZiAoZnVuY3Rpb25fY2FsbCkge1xuICAgICAgICBpZiAoIWNob2ljZS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwpIHtcbiAgICAgICAgICBjaG9pY2UubWVzc2FnZS5mdW5jdGlvbl9jYWxsID0gZnVuY3Rpb25fY2FsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZnVuY3Rpb25fY2FsbC5uYW1lKSBjaG9pY2UubWVzc2FnZS5mdW5jdGlvbl9jYWxsLm5hbWUgPSBmdW5jdGlvbl9jYWxsLm5hbWU7XG4gICAgICAgICAgaWYgKGZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzKSB7XG4gICAgICAgICAgICBjaG9pY2UubWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyA/Pz0gJyc7XG4gICAgICAgICAgICBjaG9pY2UubWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyArPSBmdW5jdGlvbl9jYWxsLmFyZ3VtZW50cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIGNob2ljZS5tZXNzYWdlLmNvbnRlbnQgPSAoY2hvaWNlLm1lc3NhZ2UuY29udGVudCB8fCAnJykgKyBjb250ZW50O1xuXG4gICAgICAgIGlmICghY2hvaWNlLm1lc3NhZ2UucmVmdXNhbCAmJiB0aGlzLiNnZXRBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQoKSkge1xuICAgICAgICAgIGNob2ljZS5tZXNzYWdlLnBhcnNlZCA9IHBhcnRpYWxQYXJzZShjaG9pY2UubWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodG9vbF9jYWxscykge1xuICAgICAgICBpZiAoIWNob2ljZS5tZXNzYWdlLnRvb2xfY2FsbHMpIGNob2ljZS5tZXNzYWdlLnRvb2xfY2FsbHMgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IHsgaW5kZXgsIGlkLCB0eXBlLCBmdW5jdGlvbjogZm4sIC4uLnJlc3QgfSBvZiB0b29sX2NhbGxzKSB7XG4gICAgICAgICAgY29uc3QgdG9vbF9jYWxsID0gKGNob2ljZS5tZXNzYWdlLnRvb2xfY2FsbHNbaW5kZXhdID8/PVxuICAgICAgICAgICAge30gYXMgQ2hhdENvbXBsZXRpb25TbmFwc2hvdC5DaG9pY2UuTWVzc2FnZS5Ub29sQ2FsbCk7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih0b29sX2NhbGwsIHJlc3QpO1xuICAgICAgICAgIGlmIChpZCkgdG9vbF9jYWxsLmlkID0gaWQ7XG4gICAgICAgICAgaWYgKHR5cGUpIHRvb2xfY2FsbC50eXBlID0gdHlwZTtcbiAgICAgICAgICBpZiAoZm4pIHRvb2xfY2FsbC5mdW5jdGlvbiA/Pz0geyBuYW1lOiBmbi5uYW1lID8/ICcnLCBhcmd1bWVudHM6ICcnIH07XG4gICAgICAgICAgaWYgKGZuPy5uYW1lKSB0b29sX2NhbGwuZnVuY3Rpb24hLm5hbWUgPSBmbi5uYW1lO1xuICAgICAgICAgIGlmIChmbj8uYXJndW1lbnRzKSB7XG4gICAgICAgICAgICB0b29sX2NhbGwuZnVuY3Rpb24hLmFyZ3VtZW50cyArPSBmbi5hcmd1bWVudHM7XG5cbiAgICAgICAgICAgIGlmIChzaG91bGRQYXJzZVRvb2xDYWxsKHRoaXMuI3BhcmFtcywgdG9vbF9jYWxsKSkge1xuICAgICAgICAgICAgICB0b29sX2NhbGwuZnVuY3Rpb24hLnBhcnNlZF9hcmd1bWVudHMgPSBwYXJ0aWFsUGFyc2UodG9vbF9jYWxsLmZ1bmN0aW9uIS5hcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc25hcHNob3Q7XG4gIH1cblxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKHRoaXM6IENoYXRDb21wbGV0aW9uU3RyZWFtPFBhcnNlZFQ+KTogQXN5bmNJdGVyYXRvcjxDaGF0Q29tcGxldGlvbkNodW5rPiB7XG4gICAgY29uc3QgcHVzaFF1ZXVlOiBDaGF0Q29tcGxldGlvbkNodW5rW10gPSBbXTtcbiAgICBjb25zdCByZWFkUXVldWU6IHtcbiAgICAgIHJlc29sdmU6IChjaHVuazogQ2hhdENvbXBsZXRpb25DaHVuayB8IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgICAgIHJlamVjdDogKGVycjogdW5rbm93bikgPT4gdm9pZDtcbiAgICB9W10gPSBbXTtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5vbignY2h1bmsnLCAoY2h1bmspID0+IHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlYWRRdWV1ZS5zaGlmdCgpO1xuICAgICAgaWYgKHJlYWRlcikge1xuICAgICAgICByZWFkZXIucmVzb2x2ZShjaHVuayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoUXVldWUucHVzaChjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHJlYWRRdWV1ZSkge1xuICAgICAgICByZWFkZXIucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgcmVhZFF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdhYm9ydCcsIChlcnIpID0+IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgcmVhZFF1ZXVlKSB7XG4gICAgICAgIHJlYWRlci5yZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlYWRRdWV1ZS5sZW5ndGggPSAwO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHJlYWRRdWV1ZSkge1xuICAgICAgICByZWFkZXIucmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBhc3luYyAoKTogUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxDaGF0Q29tcGxldGlvbkNodW5rPj4gPT4ge1xuICAgICAgICBpZiAoIXB1c2hRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8Q2hhdENvbXBsZXRpb25DaHVuayB8IHVuZGVmaW5lZD4oKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgICAgICAgIHJlYWRRdWV1ZS5wdXNoKHsgcmVzb2x2ZSwgcmVqZWN0IH0pLFxuICAgICAgICAgICkudGhlbigoY2h1bmspID0+IChjaHVuayA/IHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9IDogeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaHVuayA9IHB1c2hRdWV1ZS5zaGlmdCgpITtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9O1xuICAgICAgfSxcbiAgICAgIHJldHVybjogYXN5bmMgKCkgPT4ge1xuICAgICAgICB0aGlzLmFib3J0KCk7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHRvUmVhZGFibGVTdHJlYW0oKTogUmVhZGFibGVTdHJlYW0ge1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBTdHJlYW0odGhpc1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0uYmluZCh0aGlzKSwgdGhpcy5jb250cm9sbGVyKTtcbiAgICByZXR1cm4gc3RyZWFtLnRvUmVhZGFibGVTdHJlYW0oKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZUNoYXRDb21wbGV0aW9uPFBhcnNlZFQ+KFxuICBzbmFwc2hvdDogQ2hhdENvbXBsZXRpb25TbmFwc2hvdCxcbiAgcGFyYW1zOiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyB8IG51bGwsXG4pOiBQYXJzZWRDaGF0Q29tcGxldGlvbjxQYXJzZWRUPiB7XG4gIGNvbnN0IHsgaWQsIGNob2ljZXMsIGNyZWF0ZWQsIG1vZGVsLCBzeXN0ZW1fZmluZ2VycHJpbnQsIC4uLnJlc3QgfSA9IHNuYXBzaG90O1xuICBjb25zdCBjb21wbGV0aW9uOiBDaGF0Q29tcGxldGlvbiA9IHtcbiAgICAuLi5yZXN0LFxuICAgIGlkLFxuICAgIGNob2ljZXM6IGNob2ljZXMubWFwKFxuICAgICAgKHsgbWVzc2FnZSwgZmluaXNoX3JlYXNvbiwgaW5kZXgsIGxvZ3Byb2JzLCAuLi5jaG9pY2VSZXN0IH0pOiBDaGF0Q29tcGxldGlvbi5DaG9pY2UgPT4ge1xuICAgICAgICBpZiAoIWZpbmlzaF9yZWFzb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYG1pc3NpbmcgZmluaXNoX3JlYXNvbiBmb3IgY2hvaWNlICR7aW5kZXh9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGNvbnRlbnQgPSBudWxsLCBmdW5jdGlvbl9jYWxsLCB0b29sX2NhbGxzLCAuLi5tZXNzYWdlUmVzdCB9ID0gbWVzc2FnZTtcbiAgICAgICAgY29uc3Qgcm9sZSA9IG1lc3NhZ2Uucm9sZSBhcyAnYXNzaXN0YW50JzsgLy8gdGhpcyBpcyB3aGF0IHdlIGV4cGVjdDsgaW4gdGhlb3J5IGl0IGNvdWxkIGJlIGRpZmZlcmVudCB3aGljaCB3b3VsZCBtYWtlIG91ciB0eXBlcyBhIHNsaWdodCBsaWUgYnV0IHdvdWxkIGJlIGZpbmUuXG4gICAgICAgIGlmICghcm9sZSkge1xuICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyByb2xlIGZvciBjaG9pY2UgJHtpbmRleH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmdW5jdGlvbl9jYWxsKSB7XG4gICAgICAgICAgY29uc3QgeyBhcmd1bWVudHM6IGFyZ3MsIG5hbWUgfSA9IGZ1bmN0aW9uX2NhbGw7XG4gICAgICAgICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIGZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzIGZvciBjaG9pY2UgJHtpbmRleH1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBmdW5jdGlvbl9jYWxsLm5hbWUgZm9yIGNob2ljZSAke2luZGV4fWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jaG9pY2VSZXN0LFxuICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiB7IGFyZ3VtZW50czogYXJncywgbmFtZSB9LFxuICAgICAgICAgICAgICByb2xlLFxuICAgICAgICAgICAgICByZWZ1c2FsOiBtZXNzYWdlLnJlZnVzYWwgPz8gbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5pc2hfcmVhc29uLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBsb2dwcm9icyxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvb2xfY2FsbHMpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY2hvaWNlUmVzdCxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgZmluaXNoX3JlYXNvbixcbiAgICAgICAgICAgIGxvZ3Byb2JzLFxuICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAuLi5tZXNzYWdlUmVzdCxcbiAgICAgICAgICAgICAgcm9sZSxcbiAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgcmVmdXNhbDogbWVzc2FnZS5yZWZ1c2FsID8/IG51bGwsXG4gICAgICAgICAgICAgIHRvb2xfY2FsbHM6IHRvb2xfY2FsbHMubWFwKCh0b29sX2NhbGwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZ1bmN0aW9uOiBmbiwgdHlwZSwgaWQsIC4uLnRvb2xSZXN0IH0gPSB0b29sX2NhbGw7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhcmd1bWVudHM6IGFyZ3MsIG5hbWUsIC4uLmZuUmVzdCB9ID0gZm4gfHwge307XG4gICAgICAgICAgICAgICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBjaG9pY2VzWyR7aW5kZXh9XS50b29sX2NhbGxzWyR7aX1dLmlkXFxuJHtzdHIoc25hcHNob3QpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYG1pc3NpbmcgY2hvaWNlc1ske2luZGV4fV0udG9vbF9jYWxsc1ske2l9XS50eXBlXFxuJHtzdHIoc25hcHNob3QpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBtaXNzaW5nIGNob2ljZXNbJHtpbmRleH1dLnRvb2xfY2FsbHNbJHtpfV0uZnVuY3Rpb24ubmFtZVxcbiR7c3RyKHNuYXBzaG90KX1gLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgbWlzc2luZyBjaG9pY2VzWyR7aW5kZXh9XS50b29sX2NhbGxzWyR7aX1dLmZ1bmN0aW9uLmFyZ3VtZW50c1xcbiR7c3RyKHNuYXBzaG90KX1gLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi50b29sUmVzdCwgaWQsIHR5cGUsIGZ1bmN0aW9uOiB7IC4uLmZuUmVzdCwgbmFtZSwgYXJndW1lbnRzOiBhcmdzIH0gfTtcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5jaG9pY2VSZXN0LFxuICAgICAgICAgIG1lc3NhZ2U6IHsgLi4ubWVzc2FnZVJlc3QsIGNvbnRlbnQsIHJvbGUsIHJlZnVzYWw6IG1lc3NhZ2UucmVmdXNhbCA/PyBudWxsIH0sXG4gICAgICAgICAgZmluaXNoX3JlYXNvbixcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBsb2dwcm9icyxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgKSxcbiAgICBjcmVhdGVkLFxuICAgIG1vZGVsLFxuICAgIG9iamVjdDogJ2NoYXQuY29tcGxldGlvbicsXG4gICAgLi4uKHN5c3RlbV9maW5nZXJwcmludCA/IHsgc3lzdGVtX2ZpbmdlcnByaW50IH0gOiB7fSksXG4gIH07XG5cbiAgcmV0dXJuIG1heWJlUGFyc2VDaGF0Q29tcGxldGlvbihjb21wbGV0aW9uLCBwYXJhbXMpO1xufVxuXG5mdW5jdGlvbiBzdHIoeDogdW5rbm93bikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeCk7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHN0cmVhbWVkIGNodW5rIG9mIGEgY2hhdCBjb21wbGV0aW9uIHJlc3BvbnNlIHJldHVybmVkIGJ5IG1vZGVsLFxuICogYmFzZWQgb24gdGhlIHByb3ZpZGVkIGlucHV0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uU25hcHNob3Qge1xuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNoYXQgY29tcGxldGlvbi5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBjaGF0IGNvbXBsZXRpb24gY2hvaWNlcy4gQ2FuIGJlIG1vcmUgdGhhbiBvbmUgaWYgYG5gIGlzIGdyZWF0ZXJcbiAgICogdGhhbiAxLlxuICAgKi9cbiAgY2hvaWNlczogQXJyYXk8Q2hhdENvbXBsZXRpb25TbmFwc2hvdC5DaG9pY2U+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIG9mIHdoZW4gdGhlIGNoYXQgY29tcGxldGlvbiB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHRvIGdlbmVyYXRlIHRoZSBjb21wbGV0aW9uLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvLyBOb3RlIHdlIGRvIG5vdCBpbmNsdWRlIGFuIFwib2JqZWN0XCIgdHlwZSBvbiB0aGUgc25hcHNob3QsXG4gIC8vIGJlY2F1c2UgdGhlIG9iamVjdCBpcyBub3QgYSB2YWxpZCBcImNoYXQuY29tcGxldGlvblwiIHVudGlsIGZpbmFsaXplZC5cbiAgLy8gb2JqZWN0OiAnY2hhdC5jb21wbGV0aW9uJztcblxuICAvKipcbiAgICogVGhpcyBmaW5nZXJwcmludCByZXByZXNlbnRzIHRoZSBiYWNrZW5kIGNvbmZpZ3VyYXRpb24gdGhhdCB0aGUgbW9kZWwgcnVucyB3aXRoLlxuICAgKlxuICAgKiBDYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBgc2VlZGAgcmVxdWVzdCBwYXJhbWV0ZXIgdG8gdW5kZXJzdGFuZCB3aGVuXG4gICAqIGJhY2tlbmQgY2hhbmdlcyBoYXZlIGJlZW4gbWFkZSB0aGF0IG1pZ2h0IGltcGFjdCBkZXRlcm1pbmlzbS5cbiAgICovXG4gIHN5c3RlbV9maW5nZXJwcmludD86IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0Q29tcGxldGlvblNuYXBzaG90IHtcbiAgZXhwb3J0IGludGVyZmFjZSBDaG9pY2Uge1xuICAgIC8qKlxuICAgICAqIEEgY2hhdCBjb21wbGV0aW9uIGRlbHRhIGdlbmVyYXRlZCBieSBzdHJlYW1lZCBtb2RlbCByZXNwb25zZXMuXG4gICAgICovXG4gICAgbWVzc2FnZTogQ2hvaWNlLk1lc3NhZ2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVhc29uIHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLiBUaGlzIHdpbGwgYmUgYHN0b3BgIGlmIHRoZSBtb2RlbFxuICAgICAqIGhpdCBhIG5hdHVyYWwgc3RvcCBwb2ludCBvciBhIHByb3ZpZGVkIHN0b3Agc2VxdWVuY2UsIGBsZW5ndGhgIGlmIHRoZSBtYXhpbXVtXG4gICAgICogbnVtYmVyIG9mIHRva2VucyBzcGVjaWZpZWQgaW4gdGhlIHJlcXVlc3Qgd2FzIHJlYWNoZWQsIGBjb250ZW50X2ZpbHRlcmAgaWZcbiAgICAgKiBjb250ZW50IHdhcyBvbWl0dGVkIGR1ZSB0byBhIGZsYWcgZnJvbSBvdXIgY29udGVudCBmaWx0ZXJzLCBvciBgZnVuY3Rpb25fY2FsbGBcbiAgICAgKiBpZiB0aGUgbW9kZWwgY2FsbGVkIGEgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZmluaXNoX3JlYXNvbjogQ2hhdENvbXBsZXRpb24uQ2hvaWNlWydmaW5pc2hfcmVhc29uJ10gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogTG9nIHByb2JhYmlsaXR5IGluZm9ybWF0aW9uIGZvciB0aGUgY2hvaWNlLlxuICAgICAqL1xuICAgIGxvZ3Byb2JzOiBDaGF0Q29tcGxldGlvbi5DaG9pY2UuTG9ncHJvYnMgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBjaG9pY2UgaW4gdGhlIGxpc3Qgb2YgY2hvaWNlcy5cbiAgICAgKi9cbiAgICBpbmRleDogbnVtYmVyO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBDaG9pY2Uge1xuICAgIC8qKlxuICAgICAqIEEgY2hhdCBjb21wbGV0aW9uIGRlbHRhIGdlbmVyYXRlZCBieSBzdHJlYW1lZCBtb2RlbCByZXNwb25zZXMuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSBjaHVuayBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICBjb250ZW50Pzogc3RyaW5nIHwgbnVsbDtcblxuICAgICAgcmVmdXNhbD86IHN0cmluZyB8IG51bGw7XG5cbiAgICAgIHBhcnNlZD86IHVua25vd24gfCBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuYW1lIGFuZCBhcmd1bWVudHMgb2YgYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQsIGFzIGdlbmVyYXRlZCBieSB0aGVcbiAgICAgICAqIG1vZGVsLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbl9jYWxsPzogTWVzc2FnZS5GdW5jdGlvbkNhbGw7XG5cbiAgICAgIHRvb2xfY2FsbHM/OiBBcnJheTxNZXNzYWdlLlRvb2xDYWxsPjtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcm9sZSBvZiB0aGUgYXV0aG9yIG9mIHRoaXMgbWVzc2FnZS5cbiAgICAgICAqL1xuICAgICAgcm9sZT86ICdzeXN0ZW0nIHwgJ3VzZXInIHwgJ2Fzc2lzdGFudCcgfCAnZnVuY3Rpb24nIHwgJ3Rvb2wnO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgTWVzc2FnZSB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIFRvb2xDYWxsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgaWQ6IHN0cmluZztcblxuICAgICAgICBmdW5jdGlvbjogVG9vbENhbGwuRnVuY3Rpb247XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSB0b29sLlxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJztcbiAgICAgIH1cblxuICAgICAgZXhwb3J0IG5hbWVzcGFjZSBUb29sQ2FsbCB7XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb24ge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBhcmd1bWVudHMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpbiBKU09OXG4gICAgICAgICAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAgICAgICAgICogaGFsbHVjaW5hdGUgcGFyYW1ldGVycyBub3QgZGVmaW5lZCBieSB5b3VyIGZ1bmN0aW9uIHNjaGVtYS4gVmFsaWRhdGUgdGhlXG4gICAgICAgICAgICogYXJndW1lbnRzIGluIHlvdXIgY29kZSBiZWZvcmUgY2FsbGluZyB5b3VyIGZ1bmN0aW9uLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGFyZ3VtZW50czogc3RyaW5nO1xuXG4gICAgICAgICAgcGFyc2VkX2FyZ3VtZW50cz86IHVua25vd247XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlXG4gICAgICAgKiBtb2RlbC5cbiAgICAgICAqL1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkNhbGwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICAgICAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAgICAgICAqIGhhbGx1Y2luYXRlIHBhcmFtZXRlcnMgbm90IGRlZmluZWQgYnkgeW91ciBmdW5jdGlvbiBzY2hlbWEuIFZhbGlkYXRlIHRoZVxuICAgICAgICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBhcmd1bWVudHM/OiBzdHJpbmc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgbmFtZT86IHN0cmluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudHlwZSBBc3NlcnRJc0VtcHR5PFQgZXh0ZW5kcyB7fT4gPSBrZXlvZiBUIGV4dGVuZHMgbmV2ZXIgPyBUIDogbmV2ZXI7XG5cbi8qKlxuICogRW5zdXJlcyB0aGUgZ2l2ZW4gYXJndW1lbnQgaXMgYW4gZW1wdHkgb2JqZWN0LCB1c2VmdWwgZm9yXG4gKiBhc3NlcnRpbmcgdGhhdCBhbGwga25vd24gcHJvcGVydGllcyBvbiBhbiBvYmplY3QgaGF2ZSBiZWVuXG4gKiBkZXN0cnVjdHVyZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzRW1wdHk8VCBleHRlbmRzIHt9PihvYmo6IEFzc2VydElzRW1wdHk8VD4pOiBhc3NlcnRzIG9iaiBpcyBBc3NlcnRJc0VtcHR5PFQ+IHtcbiAgcmV0dXJuO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROZXZlcihfeDogbmV2ZXIpIHt9XG4iLCAiaW1wb3J0IHtcbiAgdHlwZSBDaGF0Q29tcGxldGlvbkNodW5rLFxuICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxufSBmcm9tICcuLi9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucyc7XG5pbXBvcnQgeyBSdW5uZXJPcHRpb25zLCB0eXBlIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMgfSBmcm9tICcuL0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXInO1xuaW1wb3J0IHsgdHlwZSBSZWFkYWJsZVN0cmVhbSB9IGZyb20gJy4uL19zaGltcy9pbmRleCc7XG5pbXBvcnQgeyBSdW5uYWJsZVRvb2xzLCB0eXBlIEJhc2VGdW5jdGlvbnNBcmdzLCB0eXBlIFJ1bm5hYmxlRnVuY3Rpb25zIH0gZnJvbSAnLi9SdW5uYWJsZUZ1bmN0aW9uJztcbmltcG9ydCB7IENoYXRDb21wbGV0aW9uU25hcHNob3QsIENoYXRDb21wbGV0aW9uU3RyZWFtIH0gZnJvbSAnLi9DaGF0Q29tcGxldGlvblN0cmVhbSc7XG5pbXBvcnQgT3BlbkFJIGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IEF1dG9QYXJzZWFibGVUb29sIH0gZnJvbSAnLi4vbGliL3BhcnNlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25TdHJlYW1FdmVudHMgZXh0ZW5kcyBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzIHtcbiAgY29udGVudDogKGNvbnRlbnREZWx0YTogc3RyaW5nLCBjb250ZW50U25hcHNob3Q6IHN0cmluZykgPT4gdm9pZDtcbiAgY2h1bms6IChjaHVuazogQ2hhdENvbXBsZXRpb25DaHVuaywgc25hcHNob3Q6IENoYXRDb21wbGV0aW9uU25hcHNob3QpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nRnVuY3Rpb25SdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncyBleHRlbmRzIEJhc2VGdW5jdGlvbnNBcmdzPiA9IE9taXQ8XG4gIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICAnZnVuY3Rpb25zJ1xuPiAmIHtcbiAgZnVuY3Rpb25zOiBSdW5uYWJsZUZ1bmN0aW9uczxGdW5jdGlvbnNBcmdzPjtcbn07XG5cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nVG9vbFJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzIGV4dGVuZHMgQmFzZUZ1bmN0aW9uc0FyZ3M+ID0gT21pdDxcbiAgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gICd0b29scydcbj4gJiB7XG4gIHRvb2xzOiBSdW5uYWJsZVRvb2xzPEZ1bmN0aW9uc0FyZ3M+IHwgQXV0b1BhcnNlYWJsZVRvb2w8YW55LCB0cnVlPltdO1xufTtcblxuZXhwb3J0IGNsYXNzIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyPFBhcnNlZFQgPSBudWxsPlxuICBleHRlbmRzIENoYXRDb21wbGV0aW9uU3RyZWFtPFBhcnNlZFQ+XG4gIGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZTxDaGF0Q29tcGxldGlvbkNodW5rPlxue1xuICBzdGF0aWMgb3ZlcnJpZGUgZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pOiBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcjxudWxsPiB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyKG51bGwpO1xuICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuICAgIHJldHVybiBydW5uZXI7XG4gIH1cblxuICAvKiogQGRlcHJlY2F0ZWQgLSBwbGVhc2UgdXNlIGBydW5Ub29sc2AgaW5zdGVhZC4gKi9cbiAgc3RhdGljIHJ1bkZ1bmN0aW9uczxUIGV4dGVuZHMgKHN0cmluZyB8IG9iamVjdClbXT4oXG4gICAgY2xpZW50OiBPcGVuQUksXG4gICAgcGFyYW1zOiBDaGF0Q29tcGxldGlvblN0cmVhbWluZ0Z1bmN0aW9uUnVubmVyUGFyYW1zPFQ+LFxuICAgIG9wdGlvbnM/OiBSdW5uZXJPcHRpb25zLFxuICApOiBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcjxudWxsPiB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyKG51bGwpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtSGVscGVyLU1ldGhvZCc6ICdydW5GdW5jdGlvbnMnIH0sXG4gICAgfTtcbiAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX3J1bkZ1bmN0aW9ucyhjbGllbnQsIHBhcmFtcywgb3B0cykpO1xuICAgIHJldHVybiBydW5uZXI7XG4gIH1cblxuICBzdGF0aWMgcnVuVG9vbHM8VCBleHRlbmRzIChzdHJpbmcgfCBvYmplY3QpW10sIFBhcnNlZFQgPSBudWxsPihcbiAgICBjbGllbnQ6IE9wZW5BSSxcbiAgICBwYXJhbXM6IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nVG9vbFJ1bm5lclBhcmFtczxUPixcbiAgICBvcHRpb25zPzogUnVubmVyT3B0aW9ucyxcbiAgKTogQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXI8UGFyc2VkVD4ge1xuICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcjxQYXJzZWRUPihcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETyB0aGVzZSB0eXBlcyBhcmUgaW5jb21wYXRpYmxlXG4gICAgICBwYXJhbXMsXG4gICAgKTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAncnVuVG9vbHMnIH0sXG4gICAgfTtcbiAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX3J1blRvb2xzKGNsaWVudCwgcGFyYW1zLCBvcHRzKSk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IENoYXRDb21wbGV0aW9uUnVubmVyLCBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uUnVubmVyUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uUnVubmVyJztcbmltcG9ydCB7XG4gIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyLFxuICBDaGF0Q29tcGxldGlvblN0cmVhbWluZ0Z1bmN0aW9uUnVubmVyUGFyYW1zLFxufSBmcm9tICcuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXInO1xuaW1wb3J0IHsgQmFzZUZ1bmN0aW9uc0FyZ3MgfSBmcm9tICcuLi8uLi8uLi9saWIvUnVubmFibGVGdW5jdGlvbic7XG5pbXBvcnQgeyBSdW5uZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vbGliL0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXInO1xuaW1wb3J0IHsgQ2hhdENvbXBsZXRpb25Ub29sUnVubmVyUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uUnVubmVyJztcbmltcG9ydCB7IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nVG9vbFJ1bm5lclBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL2xpYi9DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcic7XG5pbXBvcnQgeyBDaGF0Q29tcGxldGlvblN0cmVhbSwgdHlwZSBDaGF0Q29tcGxldGlvblN0cmVhbVBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL2xpYi9DaGF0Q29tcGxldGlvblN0cmVhbSc7XG5pbXBvcnQge1xuICBDaGF0Q29tcGxldGlvbixcbiAgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gIENoYXRDb21wbGV0aW9uTWVzc2FnZSxcbiAgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwsXG59IGZyb20gJy4uLy4uL2NoYXQvY29tcGxldGlvbnMnO1xuaW1wb3J0IHsgRXh0cmFjdFBhcnNlZENvbnRlbnRGcm9tUGFyYW1zLCBwYXJzZUNoYXRDb21wbGV0aW9uLCB2YWxpZGF0ZUlucHV0VG9vbHMgfSBmcm9tICcuLi8uLi8uLi9saWIvcGFyc2VyJztcblxuZXhwb3J0IHtcbiAgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIsXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdGdW5jdGlvblJ1bm5lclBhcmFtcyxcbn0gZnJvbSAnLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyJztcbmV4cG9ydCB7XG4gIHR5cGUgUnVubmFibGVGdW5jdGlvbixcbiAgdHlwZSBSdW5uYWJsZUZ1bmN0aW9ucyxcbiAgdHlwZSBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlLFxuICB0eXBlIFJ1bm5hYmxlRnVuY3Rpb25XaXRob3V0UGFyc2UsXG4gIFBhcnNpbmdGdW5jdGlvbixcbiAgUGFyc2luZ1Rvb2xGdW5jdGlvbixcbn0gZnJvbSAnLi4vLi4vLi4vbGliL1J1bm5hYmxlRnVuY3Rpb24nO1xuZXhwb3J0IHsgdHlwZSBDaGF0Q29tcGxldGlvblRvb2xSdW5uZXJQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25SdW5uZXInO1xuZXhwb3J0IHsgdHlwZSBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1Rvb2xSdW5uZXJQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXInO1xuZXhwb3J0IHsgQ2hhdENvbXBsZXRpb25TdHJlYW0sIHR5cGUgQ2hhdENvbXBsZXRpb25TdHJlYW1QYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25TdHJlYW0nO1xuZXhwb3J0IHtcbiAgQ2hhdENvbXBsZXRpb25SdW5uZXIsXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25GdW5jdGlvblJ1bm5lclBhcmFtcyxcbn0gZnJvbSAnLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uUnVubmVyJztcblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRGdW5jdGlvbiBleHRlbmRzIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsLkZ1bmN0aW9uIHtcbiAgcGFyc2VkX2FyZ3VtZW50cz86IHVua25vd247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkRnVuY3Rpb25Ub29sQ2FsbCBleHRlbmRzIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsIHtcbiAgZnVuY3Rpb246IFBhcnNlZEZ1bmN0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnNlZENoYXRDb21wbGV0aW9uTWVzc2FnZTxQYXJzZWRUPiBleHRlbmRzIENoYXRDb21wbGV0aW9uTWVzc2FnZSB7XG4gIHBhcnNlZDogUGFyc2VkVCB8IG51bGw7XG4gIHRvb2xfY2FsbHM6IEFycmF5PFBhcnNlZEZ1bmN0aW9uVG9vbENhbGw+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnNlZENob2ljZTxQYXJzZWRUPiBleHRlbmRzIENoYXRDb21wbGV0aW9uLkNob2ljZSB7XG4gIG1lc3NhZ2U6IFBhcnNlZENoYXRDb21wbGV0aW9uTWVzc2FnZTxQYXJzZWRUPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRDaGF0Q29tcGxldGlvbjxQYXJzZWRUPiBleHRlbmRzIENoYXRDb21wbGV0aW9uIHtcbiAgY2hvaWNlczogQXJyYXk8UGFyc2VkQ2hvaWNlPFBhcnNlZFQ+Pjtcbn1cblxuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25QYXJzZVBhcmFtcyA9IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nO1xuXG5leHBvcnQgY2xhc3MgQ29tcGxldGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIHBhcnNlPFBhcmFtcyBleHRlbmRzIENoYXRDb21wbGV0aW9uUGFyc2VQYXJhbXMsIFBhcnNlZFQgPSBFeHRyYWN0UGFyc2VkQ29udGVudEZyb21QYXJhbXM8UGFyYW1zPj4oXG4gICAgYm9keTogUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8UGFyc2VkQ2hhdENvbXBsZXRpb248UGFyc2VkVD4+IHtcbiAgICB2YWxpZGF0ZUlucHV0VG9vbHMoYm9keS50b29scyk7XG5cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmNoYXQuY29tcGxldGlvbnNcbiAgICAgIC5jcmVhdGUoYm9keSwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVycyxcbiAgICAgICAgICAnWC1TdGFpbmxlc3MtSGVscGVyLU1ldGhvZCc6ICdiZXRhLmNoYXQuY29tcGxldGlvbnMucGFyc2UnLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICAgIC5fdGhlblVud3JhcCgoY29tcGxldGlvbikgPT4gcGFyc2VDaGF0Q29tcGxldGlvbihjb21wbGV0aW9uLCBib2R5KSk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgLSB1c2UgYHJ1blRvb2xzYCBpbnN0ZWFkLlxuICAgKi9cbiAgcnVuRnVuY3Rpb25zPEZ1bmN0aW9uc0FyZ3MgZXh0ZW5kcyBCYXNlRnVuY3Rpb25zQXJncz4oXG4gICAgYm9keTogQ2hhdENvbXBsZXRpb25GdW5jdGlvblJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzPixcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ2hhdENvbXBsZXRpb25SdW5uZXI8bnVsbD47XG4gIHJ1bkZ1bmN0aW9uczxGdW5jdGlvbnNBcmdzIGV4dGVuZHMgQmFzZUZ1bmN0aW9uc0FyZ3M+KFxuICAgIGJvZHk6IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nRnVuY3Rpb25SdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncz4sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyPG51bGw+O1xuICBydW5GdW5jdGlvbnM8RnVuY3Rpb25zQXJncyBleHRlbmRzIEJhc2VGdW5jdGlvbnNBcmdzPihcbiAgICBib2R5OlxuICAgICAgfCBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3M+XG4gICAgICB8IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nRnVuY3Rpb25SdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncz4sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENoYXRDb21wbGV0aW9uUnVubmVyPG51bGw+IHwgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXI8bnVsbD4ge1xuICAgIGlmIChib2R5LnN0cmVhbSkge1xuICAgICAgcmV0dXJuIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyLnJ1bkZ1bmN0aW9ucyhcbiAgICAgICAgdGhpcy5fY2xpZW50LFxuICAgICAgICBib2R5IGFzIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nRnVuY3Rpb25SdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncz4sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gQ2hhdENvbXBsZXRpb25SdW5uZXIucnVuRnVuY3Rpb25zKFxuICAgICAgdGhpcy5fY2xpZW50LFxuICAgICAgYm9keSBhcyBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3M+LFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgaGVscGVyIGZvciB1c2luZyB0b29sIGNhbGxzIHdpdGggdGhlIC9jaGF0L2NvbXBsZXRpb25zIGVuZHBvaW50XG4gICAqIHdoaWNoIGF1dG9tYXRpY2FsbHkgY2FsbHMgdGhlIEphdmFTY3JpcHQgZnVuY3Rpb25zIHlvdSBwcm92aWRlIGFuZCBzZW5kcyB0aGVpclxuICAgKiByZXN1bHRzIGJhY2sgdG8gdGhlIC9jaGF0L2NvbXBsZXRpb25zIGVuZHBvaW50LCBsb29waW5nIGFzIGxvbmcgYXMgdGhlIG1vZGVsXG4gICAqIHJlcXVlc3RzIGZ1bmN0aW9uIGNhbGxzLlxuICAgKlxuICAgKiBGb3IgbW9yZSBkZXRhaWxzIGFuZCBleGFtcGxlcywgc2VlXG4gICAqIFt0aGUgZG9jc10oaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZSNhdXRvbWF0ZWQtZnVuY3Rpb24tY2FsbHMpXG4gICAqL1xuICBydW5Ub29sczxcbiAgICBQYXJhbXMgZXh0ZW5kcyBDaGF0Q29tcGxldGlvblRvb2xSdW5uZXJQYXJhbXM8YW55PixcbiAgICBQYXJzZWRUID0gRXh0cmFjdFBhcnNlZENvbnRlbnRGcm9tUGFyYW1zPFBhcmFtcz4sXG4gID4oYm9keTogUGFyYW1zLCBvcHRpb25zPzogUnVubmVyT3B0aW9ucyk6IENoYXRDb21wbGV0aW9uUnVubmVyPFBhcnNlZFQ+O1xuXG4gIHJ1blRvb2xzPFxuICAgIFBhcmFtcyBleHRlbmRzIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nVG9vbFJ1bm5lclBhcmFtczxhbnk+LFxuICAgIFBhcnNlZFQgPSBFeHRyYWN0UGFyc2VkQ29udGVudEZyb21QYXJhbXM8UGFyYW1zPixcbiAgPihib2R5OiBQYXJhbXMsIG9wdGlvbnM/OiBSdW5uZXJPcHRpb25zKTogQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXI8UGFyc2VkVD47XG5cbiAgcnVuVG9vbHM8XG4gICAgUGFyYW1zIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25Ub29sUnVubmVyUGFyYW1zPGFueT4gfCBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1Rvb2xSdW5uZXJQYXJhbXM8YW55PixcbiAgICBQYXJzZWRUID0gRXh0cmFjdFBhcnNlZENvbnRlbnRGcm9tUGFyYW1zPFBhcmFtcz4sXG4gID4oXG4gICAgYm9keTogUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBSdW5uZXJPcHRpb25zLFxuICApOiBDaGF0Q29tcGxldGlvblJ1bm5lcjxQYXJzZWRUPiB8IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyPFBhcnNlZFQ+IHtcbiAgICBpZiAoYm9keS5zdHJlYW0pIHtcbiAgICAgIHJldHVybiBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lci5ydW5Ub29scyhcbiAgICAgICAgdGhpcy5fY2xpZW50LFxuICAgICAgICBib2R5IGFzIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nVG9vbFJ1bm5lclBhcmFtczxhbnk+LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQ2hhdENvbXBsZXRpb25SdW5uZXIucnVuVG9vbHModGhpcy5fY2xpZW50LCBib2R5IGFzIENoYXRDb21wbGV0aW9uVG9vbFJ1bm5lclBhcmFtczxhbnk+LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2hhdCBjb21wbGV0aW9uIHN0cmVhbVxuICAgKi9cbiAgc3RyZWFtPFBhcmFtcyBleHRlbmRzIENoYXRDb21wbGV0aW9uU3RyZWFtUGFyYW1zLCBQYXJzZWRUID0gRXh0cmFjdFBhcnNlZENvbnRlbnRGcm9tUGFyYW1zPFBhcmFtcz4+KFxuICAgIGJvZHk6IFBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ2hhdENvbXBsZXRpb25TdHJlYW08UGFyc2VkVD4ge1xuICAgIHJldHVybiBDaGF0Q29tcGxldGlvblN0cmVhbS5jcmVhdGVDaGF0Q29tcGxldGlvbih0aGlzLl9jbGllbnQsIGJvZHksIG9wdGlvbnMpO1xuICB9XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBDb21wbGV0aW9uc0FQSSBmcm9tICcuL2NvbXBsZXRpb25zJztcblxuZXhwb3J0IGNsYXNzIENoYXQgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIGNvbXBsZXRpb25zOiBDb21wbGV0aW9uc0FQSS5Db21wbGV0aW9ucyA9IG5ldyBDb21wbGV0aW9uc0FQSS5Db21wbGV0aW9ucyh0aGlzLl9jbGllbnQpO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXQge1xuICBleHBvcnQgaW1wb3J0IENvbXBsZXRpb25zID0gQ29tcGxldGlvbnNBUEkuQ29tcGxldGlvbnM7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuXG5leHBvcnQgY2xhc3MgU2Vzc2lvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZXBoZW1lcmFsIEFQSSB0b2tlbiBmb3IgdXNlIGluIGNsaWVudC1zaWRlIGFwcGxpY2F0aW9ucyB3aXRoIHRoZVxuICAgKiBSZWFsdGltZSBBUEkuIENhbiBiZSBjb25maWd1cmVkIHdpdGggdGhlIHNhbWUgc2Vzc2lvbiBwYXJhbWV0ZXJzIGFzIHRoZVxuICAgKiBgc2Vzc2lvbi51cGRhdGVgIGNsaWVudCBldmVudC5cbiAgICpcbiAgICogSXQgcmVzcG9uZHMgd2l0aCBhIHNlc3Npb24gb2JqZWN0LCBwbHVzIGEgYGNsaWVudF9zZWNyZXRgIGtleSB3aGljaCBjb250YWlucyBhXG4gICAqIHVzYWJsZSBlcGhlbWVyYWwgQVBJIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXV0aGVudGljYXRlIGJyb3dzZXIgY2xpZW50cyBmb3JcbiAgICogdGhlIFJlYWx0aW1lIEFQSS5cbiAgICovXG4gIGNyZWF0ZShib2R5OiBTZXNzaW9uQ3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxTZXNzaW9uQ3JlYXRlUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9yZWFsdGltZS9zZXNzaW9ucycsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFJlYWx0aW1lIHNlc3Npb24gb2JqZWN0IGNvbmZpZ3VyYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbiB7XG4gIC8qKlxuICAgKiBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgaWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgb2YgaW5wdXQgYXVkaW8uIE9wdGlvbnMgYXJlIGBwY20xNmAsIGBnNzExX3VsYXdgLCBvciBgZzcxMV9hbGF3YC5cbiAgICovXG4gIGlucHV0X2F1ZGlvX2Zvcm1hdD86ICdwY20xNicgfCAnZzcxMV91bGF3JyB8ICdnNzExX2FsYXcnO1xuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciBpbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uLCBkZWZhdWx0cyB0byBvZmYgYW5kIGNhbiBiZSBzZXQgdG9cbiAgICogYG51bGxgIHRvIHR1cm4gb2ZmIG9uY2Ugb24uIElucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24gaXMgbm90IG5hdGl2ZSB0byB0aGVcbiAgICogbW9kZWwsIHNpbmNlIHRoZSBtb2RlbCBjb25zdW1lcyBhdWRpbyBkaXJlY3RseS4gVHJhbnNjcmlwdGlvbiBydW5zXG4gICAqIGFzeW5jaHJvbm91c2x5IHRocm91Z2ggV2hpc3BlciBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgcm91Z2ggZ3VpZGFuY2UgcmF0aGVyXG4gICAqIHRoYW4gdGhlIHJlcHJlc2VudGF0aW9uIHVuZGVyc3Rvb2QgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbj86IFNlc3Npb24uSW5wdXRBdWRpb1RyYW5zY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHN5c3RlbSBpbnN0cnVjdGlvbnMgKGkuZS4gc3lzdGVtIG1lc3NhZ2UpIHByZXBlbmRlZCB0byBtb2RlbCBjYWxscy5cbiAgICogVGhpcyBmaWVsZCBhbGxvd3MgdGhlIGNsaWVudCB0byBndWlkZSB0aGUgbW9kZWwgb24gZGVzaXJlZCByZXNwb25zZXMuIFRoZSBtb2RlbFxuICAgKiBjYW4gYmUgaW5zdHJ1Y3RlZCBvbiByZXNwb25zZSBjb250ZW50IGFuZCBmb3JtYXQsIChlLmcuIFwiYmUgZXh0cmVtZWx5IHN1Y2NpbmN0XCIsXG4gICAqIFwiYWN0IGZyaWVuZGx5XCIsIFwiaGVyZSBhcmUgZXhhbXBsZXMgb2YgZ29vZCByZXNwb25zZXNcIikgYW5kIG9uIGF1ZGlvIGJlaGF2aW9yXG4gICAqIChlLmcuIFwidGFsayBxdWlja2x5XCIsIFwiaW5qZWN0IGVtb3Rpb24gaW50byB5b3VyIHZvaWNlXCIsIFwibGF1Z2ggZnJlcXVlbnRseVwiKS4gVGhlXG4gICAqIGluc3RydWN0aW9ucyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gYmUgZm9sbG93ZWQgYnkgdGhlIG1vZGVsLCBidXQgdGhleSBwcm92aWRlXG4gICAqIGd1aWRhbmNlIHRvIHRoZSBtb2RlbCBvbiB0aGUgZGVzaXJlZCBiZWhhdmlvci5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBzZXJ2ZXIgc2V0cyBkZWZhdWx0IGluc3RydWN0aW9ucyB3aGljaCB3aWxsIGJlIHVzZWQgaWYgdGhpcyBmaWVsZFxuICAgKiBpcyBub3Qgc2V0IGFuZCBhcmUgdmlzaWJsZSBpbiB0aGUgYHNlc3Npb24uY3JlYXRlZGAgZXZlbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZVxuICAgKiBzZXNzaW9uLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiBvdXRwdXQgdG9rZW5zIGZvciBhIHNpbmdsZSBhc3Npc3RhbnQgcmVzcG9uc2UsIGluY2x1c2l2ZSBvZlxuICAgKiB0b29sIGNhbGxzLiBQcm92aWRlIGFuIGludGVnZXIgYmV0d2VlbiAxIGFuZCA0MDk2IHRvIGxpbWl0IG91dHB1dCB0b2tlbnMsIG9yXG4gICAqIGBpbmZgIGZvciB0aGUgbWF4aW11bSBhdmFpbGFibGUgdG9rZW5zIGZvciBhIGdpdmVuIG1vZGVsLiBEZWZhdWx0cyB0byBgaW5mYC5cbiAgICovXG4gIG1heF9yZXNwb25zZV9vdXRwdXRfdG9rZW5zPzogbnVtYmVyIHwgJ2luZic7XG5cbiAgLyoqXG4gICAqIFRoZSBzZXQgb2YgbW9kYWxpdGllcyB0aGUgbW9kZWwgY2FuIHJlc3BvbmQgd2l0aC4gVG8gZGlzYWJsZSBhdWRpbywgc2V0IHRoaXMgdG9cbiAgICogW1widGV4dFwiXS5cbiAgICovXG4gIG1vZGFsaXRpZXM/OiBBcnJheTwndGV4dCcgfCAnYXVkaW8nPjtcblxuICAvKipcbiAgICogVGhlIFJlYWx0aW1lIG1vZGVsIHVzZWQgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICovXG4gIG1vZGVsPzpcbiAgICB8IChzdHJpbmcgJiB7fSlcbiAgICB8ICdncHQtNG8tcmVhbHRpbWUtcHJldmlldydcbiAgICB8ICdncHQtNG8tcmVhbHRpbWUtcHJldmlldy0yMDI0LTEwLTAxJ1xuICAgIHwgJ2dwdC00by1yZWFsdGltZS1wcmV2aWV3LTIwMjQtMTItMTcnXG4gICAgfCAnZ3B0LTRvLW1pbmktcmVhbHRpbWUtcHJldmlldydcbiAgICB8ICdncHQtNG8tbWluaS1yZWFsdGltZS1wcmV2aWV3LTIwMjQtMTItMTcnO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IG9mIG91dHB1dCBhdWRpby4gT3B0aW9ucyBhcmUgYHBjbTE2YCwgYGc3MTFfdWxhd2AsIG9yIGBnNzExX2FsYXdgLlxuICAgKi9cbiAgb3V0cHV0X2F1ZGlvX2Zvcm1hdD86ICdwY20xNicgfCAnZzcxMV91bGF3JyB8ICdnNzExX2FsYXcnO1xuXG4gIC8qKlxuICAgKiBTYW1wbGluZyB0ZW1wZXJhdHVyZSBmb3IgdGhlIG1vZGVsLCBsaW1pdGVkIHRvIFswLjYsIDEuMl0uIERlZmF1bHRzIHRvIDAuOC5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBIb3cgdGhlIG1vZGVsIGNob29zZXMgdG9vbHMuIE9wdGlvbnMgYXJlIGBhdXRvYCwgYG5vbmVgLCBgcmVxdWlyZWRgLCBvciBzcGVjaWZ5XG4gICAqIGEgZnVuY3Rpb24uXG4gICAqL1xuICB0b29sX2Nob2ljZT86IHN0cmluZztcblxuICAvKipcbiAgICogVG9vbHMgKGZ1bmN0aW9ucykgYXZhaWxhYmxlIHRvIHRoZSBtb2RlbC5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8U2Vzc2lvbi5Ub29sPjtcblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgdHVybiBkZXRlY3Rpb24uIENhbiBiZSBzZXQgdG8gYG51bGxgIHRvIHR1cm4gb2ZmLiBTZXJ2ZXIgVkFEXG4gICAqIG1lYW5zIHRoYXQgdGhlIG1vZGVsIHdpbGwgZGV0ZWN0IHRoZSBzdGFydCBhbmQgZW5kIG9mIHNwZWVjaCBiYXNlZCBvbiBhdWRpb1xuICAgKiB2b2x1bWUgYW5kIHJlc3BvbmQgYXQgdGhlIGVuZCBvZiB1c2VyIHNwZWVjaC5cbiAgICovXG4gIHR1cm5fZGV0ZWN0aW9uPzogU2Vzc2lvbi5UdXJuRGV0ZWN0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHZvaWNlIHRoZSBtb2RlbCB1c2VzIHRvIHJlc3BvbmQuIFZvaWNlIGNhbm5vdCBiZSBjaGFuZ2VkIGR1cmluZyB0aGUgc2Vzc2lvblxuICAgKiBvbmNlIHRoZSBtb2RlbCBoYXMgcmVzcG9uZGVkIHdpdGggYXVkaW8gYXQgbGVhc3Qgb25jZS4gQ3VycmVudCB2b2ljZSBvcHRpb25zIGFyZVxuICAgKiBgYWxsb3lgLCBgYXNoYCwgYGJhbGxhZGAsIGBjb3JhbGAsIGBlY2hvYCBgc2FnZWAsIGBzaGltbWVyYCBhbmQgYHZlcnNlYC5cbiAgICovXG4gIHZvaWNlPzogJ2FsbG95JyB8ICdhc2gnIHwgJ2JhbGxhZCcgfCAnY29yYWwnIHwgJ2VjaG8nIHwgJ3NhZ2UnIHwgJ3NoaW1tZXInIHwgJ3ZlcnNlJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBTZXNzaW9uIHtcbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gZm9yIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24sIGRlZmF1bHRzIHRvIG9mZiBhbmQgY2FuIGJlIHNldCB0b1xuICAgKiBgbnVsbGAgdG8gdHVybiBvZmYgb25jZSBvbi4gSW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiBpcyBub3QgbmF0aXZlIHRvIHRoZVxuICAgKiBtb2RlbCwgc2luY2UgdGhlIG1vZGVsIGNvbnN1bWVzIGF1ZGlvIGRpcmVjdGx5LiBUcmFuc2NyaXB0aW9uIHJ1bnNcbiAgICogYXN5bmNocm9ub3VzbHkgdGhyb3VnaCBXaGlzcGVyIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyByb3VnaCBndWlkYW5jZSByYXRoZXJcbiAgICogdGhhbiB0aGUgcmVwcmVzZW50YXRpb24gdW5kZXJzdG9vZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9UcmFuc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwgdG8gdXNlIGZvciB0cmFuc2NyaXB0aW9uLCBgd2hpc3Blci0xYCBpcyB0aGUgb25seSBjdXJyZW50bHkgc3VwcG9ydGVkXG4gICAgICogbW9kZWwuXG4gICAgICovXG4gICAgbW9kZWw/OiBzdHJpbmc7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFRvb2wge1xuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgZnVuY3Rpb24sIGluY2x1ZGluZyBndWlkYW5jZSBvbiB3aGVuIGFuZCBob3cgdG8gY2FsbCBpdCxcbiAgICAgKiBhbmQgZ3VpZGFuY2UgYWJvdXQgd2hhdCB0byB0ZWxsIHRoZSB1c2VyIHdoZW4gY2FsbGluZyAoaWYgYW55dGhpbmcpLlxuICAgICAqL1xuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG5hbWU/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBQYXJhbWV0ZXJzIG9mIHRoZSBmdW5jdGlvbiBpbiBKU09OIFNjaGVtYS5cbiAgICAgKi9cbiAgICBwYXJhbWV0ZXJzPzogdW5rbm93bjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSB0b29sLCBpLmUuIGBmdW5jdGlvbmAuXG4gICAgICovXG4gICAgdHlwZT86ICdmdW5jdGlvbic7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgdHVybiBkZXRlY3Rpb24uIENhbiBiZSBzZXQgdG8gYG51bGxgIHRvIHR1cm4gb2ZmLiBTZXJ2ZXIgVkFEXG4gICAqIG1lYW5zIHRoYXQgdGhlIG1vZGVsIHdpbGwgZGV0ZWN0IHRoZSBzdGFydCBhbmQgZW5kIG9mIHNwZWVjaCBiYXNlZCBvbiBhdWRpb1xuICAgKiB2b2x1bWUgYW5kIHJlc3BvbmQgYXQgdGhlIGVuZCBvZiB1c2VyIHNwZWVjaC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVHVybkRldGVjdGlvbiB7XG4gICAgLyoqXG4gICAgICogQW1vdW50IG9mIGF1ZGlvIHRvIGluY2x1ZGUgYmVmb3JlIHRoZSBWQUQgZGV0ZWN0ZWQgc3BlZWNoIChpbiBtaWxsaXNlY29uZHMpLlxuICAgICAqIERlZmF1bHRzIHRvIDMwMG1zLlxuICAgICAqL1xuICAgIHByZWZpeF9wYWRkaW5nX21zPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogRHVyYXRpb24gb2Ygc2lsZW5jZSB0byBkZXRlY3Qgc3BlZWNoIHN0b3AgKGluIG1pbGxpc2Vjb25kcykuIERlZmF1bHRzIHRvIDUwMG1zLlxuICAgICAqIFdpdGggc2hvcnRlciB2YWx1ZXMgdGhlIG1vZGVsIHdpbGwgcmVzcG9uZCBtb3JlIHF1aWNrbHksIGJ1dCBtYXkganVtcCBpbiBvblxuICAgICAqIHNob3J0IHBhdXNlcyBmcm9tIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIHNpbGVuY2VfZHVyYXRpb25fbXM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0aW9uIHRocmVzaG9sZCBmb3IgVkFEICgwLjAgdG8gMS4wKSwgdGhpcyBkZWZhdWx0cyB0byAwLjUuIEEgaGlnaGVyXG4gICAgICogdGhyZXNob2xkIHdpbGwgcmVxdWlyZSBsb3VkZXIgYXVkaW8gdG8gYWN0aXZhdGUgdGhlIG1vZGVsLCBhbmQgdGh1cyBtaWdodFxuICAgICAqIHBlcmZvcm0gYmV0dGVyIGluIG5vaXN5IGVudmlyb25tZW50cy5cbiAgICAgKi9cbiAgICB0aHJlc2hvbGQ/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIHR1cm4gZGV0ZWN0aW9uLCBvbmx5IGBzZXJ2ZXJfdmFkYCBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIHR5cGU/OiAnc2VydmVyX3ZhZCc7XG4gIH1cbn1cblxuLyoqXG4gKiBBIG5ldyBSZWFsdGltZSBzZXNzaW9uIGNvbmZpZ3VyYXRpb24sIHdpdGggYW4gZXBoZXJtZXJhbCBrZXkuIERlZmF1bHQgVFRMIGZvclxuICoga2V5cyBpcyBvbmUgbWludXRlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlc3Npb25DcmVhdGVSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBFcGhlbWVyYWwga2V5IHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAqL1xuICBjbGllbnRfc2VjcmV0PzogU2Vzc2lvbkNyZWF0ZVJlc3BvbnNlLkNsaWVudFNlY3JldDtcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCBvZiBpbnB1dCBhdWRpby4gT3B0aW9ucyBhcmUgYHBjbTE2YCwgYGc3MTFfdWxhd2AsIG9yIGBnNzExX2FsYXdgLlxuICAgKi9cbiAgaW5wdXRfYXVkaW9fZm9ybWF0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciBpbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uLCBkZWZhdWx0cyB0byBvZmYgYW5kIGNhbiBiZSBzZXQgdG9cbiAgICogYG51bGxgIHRvIHR1cm4gb2ZmIG9uY2Ugb24uIElucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24gaXMgbm90IG5hdGl2ZSB0byB0aGVcbiAgICogbW9kZWwsIHNpbmNlIHRoZSBtb2RlbCBjb25zdW1lcyBhdWRpbyBkaXJlY3RseS4gVHJhbnNjcmlwdGlvbiBydW5zXG4gICAqIGFzeW5jaHJvbm91c2x5IHRocm91Z2ggV2hpc3BlciBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgcm91Z2ggZ3VpZGFuY2UgcmF0aGVyXG4gICAqIHRoYW4gdGhlIHJlcHJlc2VudGF0aW9uIHVuZGVyc3Rvb2QgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbj86IFNlc3Npb25DcmVhdGVSZXNwb25zZS5JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgc3lzdGVtIGluc3RydWN0aW9ucyAoaS5lLiBzeXN0ZW0gbWVzc2FnZSkgcHJlcGVuZGVkIHRvIG1vZGVsIGNhbGxzLlxuICAgKiBUaGlzIGZpZWxkIGFsbG93cyB0aGUgY2xpZW50IHRvIGd1aWRlIHRoZSBtb2RlbCBvbiBkZXNpcmVkIHJlc3BvbnNlcy4gVGhlIG1vZGVsXG4gICAqIGNhbiBiZSBpbnN0cnVjdGVkIG9uIHJlc3BvbnNlIGNvbnRlbnQgYW5kIGZvcm1hdCwgKGUuZy4gXCJiZSBleHRyZW1lbHkgc3VjY2luY3RcIixcbiAgICogXCJhY3QgZnJpZW5kbHlcIiwgXCJoZXJlIGFyZSBleGFtcGxlcyBvZiBnb29kIHJlc3BvbnNlc1wiKSBhbmQgb24gYXVkaW8gYmVoYXZpb3JcbiAgICogKGUuZy4gXCJ0YWxrIHF1aWNrbHlcIiwgXCJpbmplY3QgZW1vdGlvbiBpbnRvIHlvdXIgdm9pY2VcIiwgXCJsYXVnaCBmcmVxdWVudGx5XCIpLiBUaGVcbiAgICogaW5zdHJ1Y3Rpb25zIGFyZSBub3QgZ3VhcmFudGVlZCB0byBiZSBmb2xsb3dlZCBieSB0aGUgbW9kZWwsIGJ1dCB0aGV5IHByb3ZpZGVcbiAgICogZ3VpZGFuY2UgdG8gdGhlIG1vZGVsIG9uIHRoZSBkZXNpcmVkIGJlaGF2aW9yLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIHNlcnZlciBzZXRzIGRlZmF1bHQgaW5zdHJ1Y3Rpb25zIHdoaWNoIHdpbGwgYmUgdXNlZCBpZiB0aGlzIGZpZWxkXG4gICAqIGlzIG5vdCBzZXQgYW5kIGFyZSB2aXNpYmxlIGluIHRoZSBgc2Vzc2lvbi5jcmVhdGVkYCBldmVudCBhdCB0aGUgc3RhcnQgb2YgdGhlXG4gICAqIHNlc3Npb24uXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIG91dHB1dCB0b2tlbnMgZm9yIGEgc2luZ2xlIGFzc2lzdGFudCByZXNwb25zZSwgaW5jbHVzaXZlIG9mXG4gICAqIHRvb2wgY2FsbHMuIFByb3ZpZGUgYW4gaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDQwOTYgdG8gbGltaXQgb3V0cHV0IHRva2Vucywgb3JcbiAgICogYGluZmAgZm9yIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSB0b2tlbnMgZm9yIGEgZ2l2ZW4gbW9kZWwuIERlZmF1bHRzIHRvIGBpbmZgLlxuICAgKi9cbiAgbWF4X3Jlc3BvbnNlX291dHB1dF90b2tlbnM/OiBudW1iZXIgfCAnaW5mJztcblxuICAvKipcbiAgICogVGhlIHNldCBvZiBtb2RhbGl0aWVzIHRoZSBtb2RlbCBjYW4gcmVzcG9uZCB3aXRoLiBUbyBkaXNhYmxlIGF1ZGlvLCBzZXQgdGhpcyB0b1xuICAgKiBbXCJ0ZXh0XCJdLlxuICAgKi9cbiAgbW9kYWxpdGllcz86IEFycmF5PCd0ZXh0JyB8ICdhdWRpbyc+O1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IG9mIG91dHB1dCBhdWRpby4gT3B0aW9ucyBhcmUgYHBjbTE2YCwgYGc3MTFfdWxhd2AsIG9yIGBnNzExX2FsYXdgLlxuICAgKi9cbiAgb3V0cHV0X2F1ZGlvX2Zvcm1hdD86IHN0cmluZztcblxuICAvKipcbiAgICogU2FtcGxpbmcgdGVtcGVyYXR1cmUgZm9yIHRoZSBtb2RlbCwgbGltaXRlZCB0byBbMC42LCAxLjJdLiBEZWZhdWx0cyB0byAwLjguXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcblxuICAvKipcbiAgICogSG93IHRoZSBtb2RlbCBjaG9vc2VzIHRvb2xzLiBPcHRpb25zIGFyZSBgYXV0b2AsIGBub25lYCwgYHJlcXVpcmVkYCwgb3Igc3BlY2lmeVxuICAgKiBhIGZ1bmN0aW9uLlxuICAgKi9cbiAgdG9vbF9jaG9pY2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRvb2xzIChmdW5jdGlvbnMpIGF2YWlsYWJsZSB0byB0aGUgbW9kZWwuXG4gICAqL1xuICB0b29scz86IEFycmF5PFNlc3Npb25DcmVhdGVSZXNwb25zZS5Ub29sPjtcblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgdHVybiBkZXRlY3Rpb24uIENhbiBiZSBzZXQgdG8gYG51bGxgIHRvIHR1cm4gb2ZmLiBTZXJ2ZXIgVkFEXG4gICAqIG1lYW5zIHRoYXQgdGhlIG1vZGVsIHdpbGwgZGV0ZWN0IHRoZSBzdGFydCBhbmQgZW5kIG9mIHNwZWVjaCBiYXNlZCBvbiBhdWRpb1xuICAgKiB2b2x1bWUgYW5kIHJlc3BvbmQgYXQgdGhlIGVuZCBvZiB1c2VyIHNwZWVjaC5cbiAgICovXG4gIHR1cm5fZGV0ZWN0aW9uPzogU2Vzc2lvbkNyZWF0ZVJlc3BvbnNlLlR1cm5EZXRlY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSB2b2ljZSB0aGUgbW9kZWwgdXNlcyB0byByZXNwb25kLiBWb2ljZSBjYW5ub3QgYmUgY2hhbmdlZCBkdXJpbmcgdGhlIHNlc3Npb25cbiAgICogb25jZSB0aGUgbW9kZWwgaGFzIHJlc3BvbmRlZCB3aXRoIGF1ZGlvIGF0IGxlYXN0IG9uY2UuIEN1cnJlbnQgdm9pY2Ugb3B0aW9ucyBhcmVcbiAgICogYGFsbG95YCwgYGFzaGAsIGBiYWxsYWRgLCBgY29yYWxgLCBgZWNob2AgYHNhZ2VgLCBgc2hpbW1lcmAgYW5kIGB2ZXJzZWAuXG4gICAqL1xuICB2b2ljZT86ICdhbGxveScgfCAnYXNoJyB8ICdiYWxsYWQnIHwgJ2NvcmFsJyB8ICdlY2hvJyB8ICdzYWdlJyB8ICdzaGltbWVyJyB8ICd2ZXJzZSc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgU2Vzc2lvbkNyZWF0ZVJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIEVwaGVtZXJhbCBrZXkgcmV0dXJuZWQgYnkgdGhlIEFQSS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ2xpZW50U2VjcmV0IHtcbiAgICAvKipcbiAgICAgKiBUaW1lc3RhbXAgZm9yIHdoZW4gdGhlIHRva2VuIGV4cGlyZXMuIEN1cnJlbnRseSwgYWxsIHRva2VucyBleHBpcmUgYWZ0ZXIgb25lXG4gICAgICogbWludXRlLlxuICAgICAqL1xuICAgIGV4cGlyZXNfYXQ/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBFcGhlbWVyYWwga2V5IHVzYWJsZSBpbiBjbGllbnQgZW52aXJvbm1lbnRzIHRvIGF1dGhlbnRpY2F0ZSBjb25uZWN0aW9ucyB0byB0aGVcbiAgICAgKiBSZWFsdGltZSBBUEkuIFVzZSB0aGlzIGluIGNsaWVudC1zaWRlIGVudmlyb25tZW50cyByYXRoZXIgdGhhbiBhIHN0YW5kYXJkIEFQSVxuICAgICAqIHRva2VuLCB3aGljaCBzaG91bGQgb25seSBiZSB1c2VkIHNlcnZlci1zaWRlLlxuICAgICAqL1xuICAgIHZhbHVlPzogc3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gZm9yIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24sIGRlZmF1bHRzIHRvIG9mZiBhbmQgY2FuIGJlIHNldCB0b1xuICAgKiBgbnVsbGAgdG8gdHVybiBvZmYgb25jZSBvbi4gSW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiBpcyBub3QgbmF0aXZlIHRvIHRoZVxuICAgKiBtb2RlbCwgc2luY2UgdGhlIG1vZGVsIGNvbnN1bWVzIGF1ZGlvIGRpcmVjdGx5LiBUcmFuc2NyaXB0aW9uIHJ1bnNcbiAgICogYXN5bmNocm9ub3VzbHkgdGhyb3VnaCBXaGlzcGVyIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyByb3VnaCBndWlkYW5jZSByYXRoZXJcbiAgICogdGhhbiB0aGUgcmVwcmVzZW50YXRpb24gdW5kZXJzdG9vZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9UcmFuc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwgdG8gdXNlIGZvciB0cmFuc2NyaXB0aW9uLCBgd2hpc3Blci0xYCBpcyB0aGUgb25seSBjdXJyZW50bHkgc3VwcG9ydGVkXG4gICAgICogbW9kZWwuXG4gICAgICovXG4gICAgbW9kZWw/OiBzdHJpbmc7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFRvb2wge1xuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgZnVuY3Rpb24sIGluY2x1ZGluZyBndWlkYW5jZSBvbiB3aGVuIGFuZCBob3cgdG8gY2FsbCBpdCxcbiAgICAgKiBhbmQgZ3VpZGFuY2UgYWJvdXQgd2hhdCB0byB0ZWxsIHRoZSB1c2VyIHdoZW4gY2FsbGluZyAoaWYgYW55dGhpbmcpLlxuICAgICAqL1xuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG5hbWU/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBQYXJhbWV0ZXJzIG9mIHRoZSBmdW5jdGlvbiBpbiBKU09OIFNjaGVtYS5cbiAgICAgKi9cbiAgICBwYXJhbWV0ZXJzPzogdW5rbm93bjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSB0b29sLCBpLmUuIGBmdW5jdGlvbmAuXG4gICAgICovXG4gICAgdHlwZT86ICdmdW5jdGlvbic7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgdHVybiBkZXRlY3Rpb24uIENhbiBiZSBzZXQgdG8gYG51bGxgIHRvIHR1cm4gb2ZmLiBTZXJ2ZXIgVkFEXG4gICAqIG1lYW5zIHRoYXQgdGhlIG1vZGVsIHdpbGwgZGV0ZWN0IHRoZSBzdGFydCBhbmQgZW5kIG9mIHNwZWVjaCBiYXNlZCBvbiBhdWRpb1xuICAgKiB2b2x1bWUgYW5kIHJlc3BvbmQgYXQgdGhlIGVuZCBvZiB1c2VyIHNwZWVjaC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVHVybkRldGVjdGlvbiB7XG4gICAgLyoqXG4gICAgICogQW1vdW50IG9mIGF1ZGlvIHRvIGluY2x1ZGUgYmVmb3JlIHRoZSBWQUQgZGV0ZWN0ZWQgc3BlZWNoIChpbiBtaWxsaXNlY29uZHMpLlxuICAgICAqIERlZmF1bHRzIHRvIDMwMG1zLlxuICAgICAqL1xuICAgIHByZWZpeF9wYWRkaW5nX21zPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogRHVyYXRpb24gb2Ygc2lsZW5jZSB0byBkZXRlY3Qgc3BlZWNoIHN0b3AgKGluIG1pbGxpc2Vjb25kcykuIERlZmF1bHRzIHRvIDUwMG1zLlxuICAgICAqIFdpdGggc2hvcnRlciB2YWx1ZXMgdGhlIG1vZGVsIHdpbGwgcmVzcG9uZCBtb3JlIHF1aWNrbHksIGJ1dCBtYXkganVtcCBpbiBvblxuICAgICAqIHNob3J0IHBhdXNlcyBmcm9tIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIHNpbGVuY2VfZHVyYXRpb25fbXM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0aW9uIHRocmVzaG9sZCBmb3IgVkFEICgwLjAgdG8gMS4wKSwgdGhpcyBkZWZhdWx0cyB0byAwLjUuIEEgaGlnaGVyXG4gICAgICogdGhyZXNob2xkIHdpbGwgcmVxdWlyZSBsb3VkZXIgYXVkaW8gdG8gYWN0aXZhdGUgdGhlIG1vZGVsLCBhbmQgdGh1cyBtaWdodFxuICAgICAqIHBlcmZvcm0gYmV0dGVyIGluIG5vaXN5IGVudmlyb25tZW50cy5cbiAgICAgKi9cbiAgICB0aHJlc2hvbGQ/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIHR1cm4gZGV0ZWN0aW9uLCBvbmx5IGBzZXJ2ZXJfdmFkYCBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIHR5cGU/OiBzdHJpbmc7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBSZWFsdGltZSBtb2RlbCB1c2VkIGZvciB0aGlzIHNlc3Npb24uXG4gICAqL1xuICBtb2RlbDpcbiAgICB8ICdncHQtNG8tcmVhbHRpbWUtcHJldmlldydcbiAgICB8ICdncHQtNG8tcmVhbHRpbWUtcHJldmlldy0yMDI0LTEwLTAxJ1xuICAgIHwgJ2dwdC00by1yZWFsdGltZS1wcmV2aWV3LTIwMjQtMTItMTcnXG4gICAgfCAnZ3B0LTRvLW1pbmktcmVhbHRpbWUtcHJldmlldydcbiAgICB8ICdncHQtNG8tbWluaS1yZWFsdGltZS1wcmV2aWV3LTIwMjQtMTItMTcnO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IG9mIGlucHV0IGF1ZGlvLiBPcHRpb25zIGFyZSBgcGNtMTZgLCBgZzcxMV91bGF3YCwgb3IgYGc3MTFfYWxhd2AuXG4gICAqL1xuICBpbnB1dF9hdWRpb19mb3JtYXQ/OiAncGNtMTYnIHwgJ2c3MTFfdWxhdycgfCAnZzcxMV9hbGF3JztcblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiwgZGVmYXVsdHMgdG8gb2ZmIGFuZCBjYW4gYmUgc2V0IHRvXG4gICAqIGBudWxsYCB0byB0dXJuIG9mZiBvbmNlIG9uLiBJbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uIGlzIG5vdCBuYXRpdmUgdG8gdGhlXG4gICAqIG1vZGVsLCBzaW5jZSB0aGUgbW9kZWwgY29uc3VtZXMgYXVkaW8gZGlyZWN0bHkuIFRyYW5zY3JpcHRpb24gcnVuc1xuICAgKiBhc3luY2hyb25vdXNseSB0aHJvdWdoIFdoaXNwZXIgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIHJvdWdoIGd1aWRhbmNlIHJhdGhlclxuICAgKiB0aGFuIHRoZSByZXByZXNlbnRhdGlvbiB1bmRlcnN0b29kIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIGlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24/OiBTZXNzaW9uQ3JlYXRlUGFyYW1zLklucHV0QXVkaW9UcmFuc2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBzeXN0ZW0gaW5zdHJ1Y3Rpb25zIChpLmUuIHN5c3RlbSBtZXNzYWdlKSBwcmVwZW5kZWQgdG8gbW9kZWwgY2FsbHMuXG4gICAqIFRoaXMgZmllbGQgYWxsb3dzIHRoZSBjbGllbnQgdG8gZ3VpZGUgdGhlIG1vZGVsIG9uIGRlc2lyZWQgcmVzcG9uc2VzLiBUaGUgbW9kZWxcbiAgICogY2FuIGJlIGluc3RydWN0ZWQgb24gcmVzcG9uc2UgY29udGVudCBhbmQgZm9ybWF0LCAoZS5nLiBcImJlIGV4dHJlbWVseSBzdWNjaW5jdFwiLFxuICAgKiBcImFjdCBmcmllbmRseVwiLCBcImhlcmUgYXJlIGV4YW1wbGVzIG9mIGdvb2QgcmVzcG9uc2VzXCIpIGFuZCBvbiBhdWRpbyBiZWhhdmlvclxuICAgKiAoZS5nLiBcInRhbGsgcXVpY2tseVwiLCBcImluamVjdCBlbW90aW9uIGludG8geW91ciB2b2ljZVwiLCBcImxhdWdoIGZyZXF1ZW50bHlcIikuIFRoZVxuICAgKiBpbnN0cnVjdGlvbnMgYXJlIG5vdCBndWFyYW50ZWVkIHRvIGJlIGZvbGxvd2VkIGJ5IHRoZSBtb2RlbCwgYnV0IHRoZXkgcHJvdmlkZVxuICAgKiBndWlkYW5jZSB0byB0aGUgbW9kZWwgb24gdGhlIGRlc2lyZWQgYmVoYXZpb3IuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgc2VydmVyIHNldHMgZGVmYXVsdCBpbnN0cnVjdGlvbnMgd2hpY2ggd2lsbCBiZSB1c2VkIGlmIHRoaXMgZmllbGRcbiAgICogaXMgbm90IHNldCBhbmQgYXJlIHZpc2libGUgaW4gdGhlIGBzZXNzaW9uLmNyZWF0ZWRgIGV2ZW50IGF0IHRoZSBzdGFydCBvZiB0aGVcbiAgICogc2Vzc2lvbi5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZztcblxuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2Ygb3V0cHV0IHRva2VucyBmb3IgYSBzaW5nbGUgYXNzaXN0YW50IHJlc3BvbnNlLCBpbmNsdXNpdmUgb2ZcbiAgICogdG9vbCBjYWxscy4gUHJvdmlkZSBhbiBpbnRlZ2VyIGJldHdlZW4gMSBhbmQgNDA5NiB0byBsaW1pdCBvdXRwdXQgdG9rZW5zLCBvclxuICAgKiBgaW5mYCBmb3IgdGhlIG1heGltdW0gYXZhaWxhYmxlIHRva2VucyBmb3IgYSBnaXZlbiBtb2RlbC4gRGVmYXVsdHMgdG8gYGluZmAuXG4gICAqL1xuICBtYXhfcmVzcG9uc2Vfb3V0cHV0X3Rva2Vucz86IG51bWJlciB8ICdpbmYnO1xuXG4gIC8qKlxuICAgKiBUaGUgc2V0IG9mIG1vZGFsaXRpZXMgdGhlIG1vZGVsIGNhbiByZXNwb25kIHdpdGguIFRvIGRpc2FibGUgYXVkaW8sIHNldCB0aGlzIHRvXG4gICAqIFtcInRleHRcIl0uXG4gICAqL1xuICBtb2RhbGl0aWVzPzogQXJyYXk8J3RleHQnIHwgJ2F1ZGlvJz47XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgb2Ygb3V0cHV0IGF1ZGlvLiBPcHRpb25zIGFyZSBgcGNtMTZgLCBgZzcxMV91bGF3YCwgb3IgYGc3MTFfYWxhd2AuXG4gICAqL1xuICBvdXRwdXRfYXVkaW9fZm9ybWF0PzogJ3BjbTE2JyB8ICdnNzExX3VsYXcnIHwgJ2c3MTFfYWxhdyc7XG5cbiAgLyoqXG4gICAqIFNhbXBsaW5nIHRlbXBlcmF0dXJlIGZvciB0aGUgbW9kZWwsIGxpbWl0ZWQgdG8gWzAuNiwgMS4yXS4gRGVmYXVsdHMgdG8gMC44LlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEhvdyB0aGUgbW9kZWwgY2hvb3NlcyB0b29scy4gT3B0aW9ucyBhcmUgYGF1dG9gLCBgbm9uZWAsIGByZXF1aXJlZGAsIG9yIHNwZWNpZnlcbiAgICogYSBmdW5jdGlvbi5cbiAgICovXG4gIHRvb2xfY2hvaWNlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUb29scyAoZnVuY3Rpb25zKSBhdmFpbGFibGUgdG8gdGhlIG1vZGVsLlxuICAgKi9cbiAgdG9vbHM/OiBBcnJheTxTZXNzaW9uQ3JlYXRlUGFyYW1zLlRvb2w+O1xuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciB0dXJuIGRldGVjdGlvbi4gQ2FuIGJlIHNldCB0byBgbnVsbGAgdG8gdHVybiBvZmYuIFNlcnZlciBWQURcbiAgICogbWVhbnMgdGhhdCB0aGUgbW9kZWwgd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IGFuZCBlbmQgb2Ygc3BlZWNoIGJhc2VkIG9uIGF1ZGlvXG4gICAqIHZvbHVtZSBhbmQgcmVzcG9uZCBhdCB0aGUgZW5kIG9mIHVzZXIgc3BlZWNoLlxuICAgKi9cbiAgdHVybl9kZXRlY3Rpb24/OiBTZXNzaW9uQ3JlYXRlUGFyYW1zLlR1cm5EZXRlY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSB2b2ljZSB0aGUgbW9kZWwgdXNlcyB0byByZXNwb25kLiBWb2ljZSBjYW5ub3QgYmUgY2hhbmdlZCBkdXJpbmcgdGhlIHNlc3Npb25cbiAgICogb25jZSB0aGUgbW9kZWwgaGFzIHJlc3BvbmRlZCB3aXRoIGF1ZGlvIGF0IGxlYXN0IG9uY2UuIEN1cnJlbnQgdm9pY2Ugb3B0aW9ucyBhcmVcbiAgICogYGFsbG95YCwgYGFzaGAsIGBiYWxsYWRgLCBgY29yYWxgLCBgZWNob2AgYHNhZ2VgLCBgc2hpbW1lcmAgYW5kIGB2ZXJzZWAuXG4gICAqL1xuICB2b2ljZT86ICdhbGxveScgfCAnYXNoJyB8ICdiYWxsYWQnIHwgJ2NvcmFsJyB8ICdlY2hvJyB8ICdzYWdlJyB8ICdzaGltbWVyJyB8ICd2ZXJzZSc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgU2Vzc2lvbkNyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciBpbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uLCBkZWZhdWx0cyB0byBvZmYgYW5kIGNhbiBiZSBzZXQgdG9cbiAgICogYG51bGxgIHRvIHR1cm4gb2ZmIG9uY2Ugb24uIElucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24gaXMgbm90IG5hdGl2ZSB0byB0aGVcbiAgICogbW9kZWwsIHNpbmNlIHRoZSBtb2RlbCBjb25zdW1lcyBhdWRpbyBkaXJlY3RseS4gVHJhbnNjcmlwdGlvbiBydW5zXG4gICAqIGFzeW5jaHJvbm91c2x5IHRocm91Z2ggV2hpc3BlciBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgcm91Z2ggZ3VpZGFuY2UgcmF0aGVyXG4gICAqIHRoYW4gdGhlIHJlcHJlc2VudGF0aW9uIHVuZGVyc3Rvb2QgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsIHRvIHVzZSBmb3IgdHJhbnNjcmlwdGlvbiwgYHdoaXNwZXItMWAgaXMgdGhlIG9ubHkgY3VycmVudGx5IHN1cHBvcnRlZFxuICAgICAqIG1vZGVsLlxuICAgICAqL1xuICAgIG1vZGVsPzogc3RyaW5nO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGZ1bmN0aW9uLCBpbmNsdWRpbmcgZ3VpZGFuY2Ugb24gd2hlbiBhbmQgaG93IHRvIGNhbGwgaXQsXG4gICAgICogYW5kIGd1aWRhbmNlIGFib3V0IHdoYXQgdG8gdGVsbCB0aGUgdXNlciB3aGVuIGNhbGxpbmcgKGlmIGFueXRoaW5nKS5cbiAgICAgKi9cbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBuYW1lPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUGFyYW1ldGVycyBvZiB0aGUgZnVuY3Rpb24gaW4gSlNPTiBTY2hlbWEuXG4gICAgICovXG4gICAgcGFyYW1ldGVycz86IHVua25vd247XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbCwgaS5lLiBgZnVuY3Rpb25gLlxuICAgICAqL1xuICAgIHR5cGU/OiAnZnVuY3Rpb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gZm9yIHR1cm4gZGV0ZWN0aW9uLiBDYW4gYmUgc2V0IHRvIGBudWxsYCB0byB0dXJuIG9mZi4gU2VydmVyIFZBRFxuICAgKiBtZWFucyB0aGF0IHRoZSBtb2RlbCB3aWxsIGRldGVjdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiBzcGVlY2ggYmFzZWQgb24gYXVkaW9cbiAgICogdm9sdW1lIGFuZCByZXNwb25kIGF0IHRoZSBlbmQgb2YgdXNlciBzcGVlY2guXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFR1cm5EZXRlY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgYSByZXNwb25zZSB3aGVuIFZBRCBpcyBlbmFibGVkLiBgdHJ1ZWBcbiAgICAgKiBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIGNyZWF0ZV9yZXNwb25zZT86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgYXVkaW8gdG8gaW5jbHVkZSBiZWZvcmUgdGhlIFZBRCBkZXRlY3RlZCBzcGVlY2ggKGluIG1pbGxpc2Vjb25kcykuXG4gICAgICogRGVmYXVsdHMgdG8gMzAwbXMuXG4gICAgICovXG4gICAgcHJlZml4X3BhZGRpbmdfbXM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBEdXJhdGlvbiBvZiBzaWxlbmNlIHRvIGRldGVjdCBzcGVlY2ggc3RvcCAoaW4gbWlsbGlzZWNvbmRzKS4gRGVmYXVsdHMgdG8gNTAwbXMuXG4gICAgICogV2l0aCBzaG9ydGVyIHZhbHVlcyB0aGUgbW9kZWwgd2lsbCByZXNwb25kIG1vcmUgcXVpY2tseSwgYnV0IG1heSBqdW1wIGluIG9uXG4gICAgICogc2hvcnQgcGF1c2VzIGZyb20gdGhlIHVzZXIuXG4gICAgICovXG4gICAgc2lsZW5jZV9kdXJhdGlvbl9tcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRpb24gdGhyZXNob2xkIGZvciBWQUQgKDAuMCB0byAxLjApLCB0aGlzIGRlZmF1bHRzIHRvIDAuNS4gQSBoaWdoZXJcbiAgICAgKiB0aHJlc2hvbGQgd2lsbCByZXF1aXJlIGxvdWRlciBhdWRpbyB0byBhY3RpdmF0ZSB0aGUgbW9kZWwsIGFuZCB0aHVzIG1pZ2h0XG4gICAgICogcGVyZm9ybSBiZXR0ZXIgaW4gbm9pc3kgZW52aXJvbm1lbnRzLlxuICAgICAqL1xuICAgIHRocmVzaG9sZD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgdHVybiBkZXRlY3Rpb24sIG9ubHkgYHNlcnZlcl92YWRgIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgdHlwZT86IHN0cmluZztcbiAgfVxufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgU2Vzc2lvbnMge1xuICBleHBvcnQge1xuICAgIHR5cGUgU2Vzc2lvbiBhcyBTZXNzaW9uLFxuICAgIHR5cGUgU2Vzc2lvbkNyZWF0ZVJlc3BvbnNlIGFzIFNlc3Npb25DcmVhdGVSZXNwb25zZSxcbiAgICB0eXBlIFNlc3Npb25DcmVhdGVQYXJhbXMgYXMgU2Vzc2lvbkNyZWF0ZVBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIFJlYWx0aW1lQVBJIGZyb20gJy4vcmVhbHRpbWUnO1xuaW1wb3J0ICogYXMgU2Vzc2lvbnNBUEkgZnJvbSAnLi9zZXNzaW9ucyc7XG5pbXBvcnQge1xuICBTZXNzaW9uIGFzIFNlc3Npb25zQVBJU2Vzc2lvbixcbiAgU2Vzc2lvbkNyZWF0ZVBhcmFtcyxcbiAgU2Vzc2lvbkNyZWF0ZVJlc3BvbnNlLFxuICBTZXNzaW9ucyxcbn0gZnJvbSAnLi9zZXNzaW9ucyc7XG5cbmV4cG9ydCBjbGFzcyBSZWFsdGltZSBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgc2Vzc2lvbnM6IFNlc3Npb25zQVBJLlNlc3Npb25zID0gbmV3IFNlc3Npb25zQVBJLlNlc3Npb25zKHRoaXMuX2NsaWVudCk7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhIGNvbnZlcnNhdGlvbiBpcyBjcmVhdGVkLiBFbWl0dGVkIHJpZ2h0IGFmdGVyIHNlc3Npb24gY3JlYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uQ3JlYXRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBjb252ZXJzYXRpb24gcmVzb3VyY2UuXG4gICAqL1xuICBjb252ZXJzYXRpb246IENvbnZlcnNhdGlvbkNyZWF0ZWRFdmVudC5Db252ZXJzYXRpb247XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBjb252ZXJzYXRpb24uY3JlYXRlZGAuXG4gICAqL1xuICB0eXBlOiAnY29udmVyc2F0aW9uLmNyZWF0ZWQnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENvbnZlcnNhdGlvbkNyZWF0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgY29udmVyc2F0aW9uIHJlc291cmNlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgKi9cbiAgICBpZD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBvYmplY3QgdHlwZSwgbXVzdCBiZSBgcmVhbHRpbWUuY29udmVyc2F0aW9uYC5cbiAgICAgKi9cbiAgICBvYmplY3Q/OiAncmVhbHRpbWUuY29udmVyc2F0aW9uJztcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBpdGVtIHRvIGFkZCB0byB0aGUgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbkl0ZW0ge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgaXRlbSwgdGhpcyBjYW4gYmUgZ2VuZXJhdGVkIGJ5IHRoZSBjbGllbnQgdG8gaGVscCBtYW5hZ2VcbiAgICogc2VydmVyLXNpZGUgY29udGV4dCwgYnV0IGlzIG5vdCByZXF1aXJlZCBiZWNhdXNlIHRoZSBzZXJ2ZXIgd2lsbCBnZW5lcmF0ZSBvbmUgaWZcbiAgICogbm90IHByb3ZpZGVkLlxuICAgKi9cbiAgaWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBhcmd1bWVudHMgb2YgdGhlIGZ1bmN0aW9uIGNhbGwgKGZvciBgZnVuY3Rpb25fY2FsbGAgaXRlbXMpLlxuICAgKi9cbiAgYXJndW1lbnRzPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwgKGZvciBgZnVuY3Rpb25fY2FsbGAgYW5kIGBmdW5jdGlvbl9jYWxsX291dHB1dGBcbiAgICogaXRlbXMpLiBJZiBwYXNzZWQgb24gYSBgZnVuY3Rpb25fY2FsbF9vdXRwdXRgIGl0ZW0sIHRoZSBzZXJ2ZXIgd2lsbCBjaGVjayB0aGF0IGFcbiAgICogYGZ1bmN0aW9uX2NhbGxgIGl0ZW0gd2l0aCB0aGUgc2FtZSBJRCBleGlzdHMgaW4gdGhlIGNvbnZlcnNhdGlvbiBoaXN0b3J5LlxuICAgKi9cbiAgY2FsbF9pZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIG1lc3NhZ2UsIGFwcGxpY2FibGUgZm9yIGBtZXNzYWdlYCBpdGVtcy5cbiAgICpcbiAgICogLSBNZXNzYWdlIGl0ZW1zIG9mIHJvbGUgYHN5c3RlbWAgc3VwcG9ydCBvbmx5IGBpbnB1dF90ZXh0YCBjb250ZW50XG4gICAqIC0gTWVzc2FnZSBpdGVtcyBvZiByb2xlIGB1c2VyYCBzdXBwb3J0IGBpbnB1dF90ZXh0YCBhbmQgYGlucHV0X2F1ZGlvYCBjb250ZW50XG4gICAqIC0gTWVzc2FnZSBpdGVtcyBvZiByb2xlIGBhc3Npc3RhbnRgIHN1cHBvcnQgYHRleHRgIGNvbnRlbnQuXG4gICAqL1xuICBjb250ZW50PzogQXJyYXk8Q29udmVyc2F0aW9uSXRlbUNvbnRlbnQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIChmb3IgYGZ1bmN0aW9uX2NhbGxgIGl0ZW1zKS5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElkZW50aWZpZXIgZm9yIHRoZSBBUEkgb2JqZWN0IGJlaW5nIHJldHVybmVkIC0gYWx3YXlzIGByZWFsdGltZS5pdGVtYC5cbiAgICovXG4gIG9iamVjdD86ICdyZWFsdGltZS5pdGVtJztcblxuICAvKipcbiAgICogVGhlIG91dHB1dCBvZiB0aGUgZnVuY3Rpb24gY2FsbCAoZm9yIGBmdW5jdGlvbl9jYWxsX291dHB1dGAgaXRlbXMpLlxuICAgKi9cbiAgb3V0cHV0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgbWVzc2FnZSBzZW5kZXIgKGB1c2VyYCwgYGFzc2lzdGFudGAsIGBzeXN0ZW1gKSwgb25seSBhcHBsaWNhYmxlXG4gICAqIGZvciBgbWVzc2FnZWAgaXRlbXMuXG4gICAqL1xuICByb2xlPzogJ3VzZXInIHwgJ2Fzc2lzdGFudCcgfCAnc3lzdGVtJztcblxuICAvKipcbiAgICogVGhlIHN0YXR1cyBvZiB0aGUgaXRlbSAoYGNvbXBsZXRlZGAsIGBpbmNvbXBsZXRlYCkuIFRoZXNlIGhhdmUgbm8gZWZmZWN0IG9uIHRoZVxuICAgKiBjb252ZXJzYXRpb24sIGJ1dCBhcmUgYWNjZXB0ZWQgZm9yIGNvbnNpc3RlbmN5IHdpdGggdGhlXG4gICAqIGBjb252ZXJzYXRpb24uaXRlbS5jcmVhdGVkYCBldmVudC5cbiAgICovXG4gIHN0YXR1cz86ICdjb21wbGV0ZWQnIHwgJ2luY29tcGxldGUnO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgaXRlbSAoYG1lc3NhZ2VgLCBgZnVuY3Rpb25fY2FsbGAsIGBmdW5jdGlvbl9jYWxsX291dHB1dGApLlxuICAgKi9cbiAgdHlwZT86ICdtZXNzYWdlJyB8ICdmdW5jdGlvbl9jYWxsJyB8ICdmdW5jdGlvbl9jYWxsX291dHB1dCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uSXRlbUNvbnRlbnQge1xuICAvKipcbiAgICogSUQgb2YgYSBwcmV2aW91cyBjb252ZXJzYXRpb24gaXRlbSB0byByZWZlcmVuY2UgKGZvciBgaXRlbV9yZWZlcmVuY2VgIGNvbnRlbnRcbiAgICogdHlwZXMgaW4gYHJlc3BvbnNlLmNyZWF0ZWAgZXZlbnRzKS4gVGhlc2UgY2FuIHJlZmVyZW5jZSBib3RoIGNsaWVudCBhbmQgc2VydmVyXG4gICAqIGNyZWF0ZWQgaXRlbXMuXG4gICAqL1xuICBpZD86IHN0cmluZztcblxuICAvKipcbiAgICogQmFzZTY0LWVuY29kZWQgYXVkaW8gYnl0ZXMsIHVzZWQgZm9yIGBpbnB1dF9hdWRpb2AgY29udGVudCB0eXBlLlxuICAgKi9cbiAgYXVkaW8/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGNvbnRlbnQsIHVzZWQgZm9yIGBpbnB1dF90ZXh0YCBhbmQgYHRleHRgIGNvbnRlbnQgdHlwZXMuXG4gICAqL1xuICB0ZXh0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNjcmlwdCBvZiB0aGUgYXVkaW8sIHVzZWQgZm9yIGBpbnB1dF9hdWRpb2AgY29udGVudCB0eXBlLlxuICAgKi9cbiAgdHJhbnNjcmlwdD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgdHlwZSAoYGlucHV0X3RleHRgLCBgaW5wdXRfYXVkaW9gLCBgaXRlbV9yZWZlcmVuY2VgLCBgdGV4dGApLlxuICAgKi9cbiAgdHlwZT86ICdpbnB1dF90ZXh0JyB8ICdpbnB1dF9hdWRpbycgfCAnaXRlbV9yZWZlcmVuY2UnIHwgJ3RleHQnO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBJdGVtIHRvIHRoZSBDb252ZXJzYXRpb24ncyBjb250ZXh0LCBpbmNsdWRpbmcgbWVzc2FnZXMsIGZ1bmN0aW9uXG4gKiBjYWxscywgYW5kIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2VzLiBUaGlzIGV2ZW50IGNhbiBiZSB1c2VkIGJvdGggdG8gcG9wdWxhdGUgYVxuICogXCJoaXN0b3J5XCIgb2YgdGhlIGNvbnZlcnNhdGlvbiBhbmQgdG8gYWRkIG5ldyBpdGVtcyBtaWQtc3RyZWFtLCBidXQgaGFzIHRoZVxuICogY3VycmVudCBsaW1pdGF0aW9uIHRoYXQgaXQgY2Fubm90IHBvcHVsYXRlIGFzc2lzdGFudCBhdWRpbyBtZXNzYWdlcy5cbiAqXG4gKiBJZiBzdWNjZXNzZnVsLCB0aGUgc2VydmVyIHdpbGwgcmVzcG9uZCB3aXRoIGEgYGNvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZWRgIGV2ZW50LFxuICogb3RoZXJ3aXNlIGFuIGBlcnJvcmAgZXZlbnQgd2lsbCBiZSBzZW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbkl0ZW1DcmVhdGVFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICovXG4gIGl0ZW06IENvbnZlcnNhdGlvbkl0ZW07XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBjb252ZXJzYXRpb24uaXRlbS5jcmVhdGVgLlxuICAgKi9cbiAgdHlwZTogJ2NvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZSc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGNsaWVudC1nZW5lcmF0ZWQgSUQgdXNlZCB0byBpZGVudGlmeSB0aGlzIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcHJlY2VkaW5nIGl0ZW0gYWZ0ZXIgd2hpY2ggdGhlIG5ldyBpdGVtIHdpbGwgYmUgaW5zZXJ0ZWQuIElmIG5vdFxuICAgKiBzZXQsIHRoZSBuZXcgaXRlbSB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGNvbnZlcnNhdGlvbi4gSWYgc2V0LCBpdFxuICAgKiBhbGxvd3MgYW4gaXRlbSB0byBiZSBpbnNlcnRlZCBtaWQtY29udmVyc2F0aW9uLiBJZiB0aGUgSUQgY2Fubm90IGJlIGZvdW5kLCBhblxuICAgKiBlcnJvciB3aWxsIGJlIHJldHVybmVkIGFuZCB0aGUgaXRlbSB3aWxsIG5vdCBiZSBhZGRlZC5cbiAgICovXG4gIHByZXZpb3VzX2l0ZW1faWQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhIGNvbnZlcnNhdGlvbiBpdGVtIGlzIGNyZWF0ZWQuIFRoZXJlIGFyZSBzZXZlcmFsIHNjZW5hcmlvcyB0aGF0XG4gKiBwcm9kdWNlIHRoaXMgZXZlbnQ6XG4gKlxuICogLSBUaGUgc2VydmVyIGlzIGdlbmVyYXRpbmcgYSBSZXNwb25zZSwgd2hpY2ggaWYgc3VjY2Vzc2Z1bCB3aWxsIHByb2R1Y2UgZWl0aGVyXG4gKiAgIG9uZSBvciB0d28gSXRlbXMsIHdoaWNoIHdpbGwgYmUgb2YgdHlwZSBgbWVzc2FnZWAgKHJvbGUgYGFzc2lzdGFudGApIG9yIHR5cGVcbiAqICAgYGZ1bmN0aW9uX2NhbGxgLlxuICogLSBUaGUgaW5wdXQgYXVkaW8gYnVmZmVyIGhhcyBiZWVuIGNvbW1pdHRlZCwgZWl0aGVyIGJ5IHRoZSBjbGllbnQgb3IgdGhlIHNlcnZlclxuICogICAoaW4gYHNlcnZlcl92YWRgIG1vZGUpLiBUaGUgc2VydmVyIHdpbGwgdGFrZSB0aGUgY29udGVudCBvZiB0aGUgaW5wdXQgYXVkaW9cbiAqICAgYnVmZmVyIGFuZCBhZGQgaXQgdG8gYSBuZXcgdXNlciBtZXNzYWdlIEl0ZW0uXG4gKiAtIFRoZSBjbGllbnQgaGFzIHNlbnQgYSBgY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlYCBldmVudCB0byBhZGQgYSBuZXcgSXRlbSB0b1xuICogICB0aGUgQ29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbkl0ZW1DcmVhdGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGl0ZW0gdG8gYWRkIHRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAqL1xuICBpdGVtOiBDb252ZXJzYXRpb25JdGVtO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHByZWNlZGluZyBpdGVtIGluIHRoZSBDb252ZXJzYXRpb24gY29udGV4dCwgYWxsb3dzIHRoZSBjbGllbnQgdG9cbiAgICogdW5kZXJzdGFuZCB0aGUgb3JkZXIgb2YgdGhlIGNvbnZlcnNhdGlvbi5cbiAgICovXG4gIHByZXZpb3VzX2l0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGNvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZWRgLlxuICAgKi9cbiAgdHlwZTogJ2NvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZWQnO1xufVxuXG4vKipcbiAqIFNlbmQgdGhpcyBldmVudCB3aGVuIHlvdSB3YW50IHRvIHJlbW92ZSBhbnkgaXRlbSBmcm9tIHRoZSBjb252ZXJzYXRpb24gaGlzdG9yeS5cbiAqIFRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kIHdpdGggYSBgY29udmVyc2F0aW9uLml0ZW0uZGVsZXRlZGAgZXZlbnQsIHVubGVzcyB0aGVcbiAqIGl0ZW0gZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNvbnZlcnNhdGlvbiBoaXN0b3J5LCBpbiB3aGljaCBjYXNlIHRoZSBzZXJ2ZXIgd2lsbFxuICogcmVzcG9uZCB3aXRoIGFuIGVycm9yLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbkl0ZW1EZWxldGVFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGl0ZW0gdG8gZGVsZXRlLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgY29udmVyc2F0aW9uLml0ZW0uZGVsZXRlYC5cbiAgICovXG4gIHR5cGU6ICdjb252ZXJzYXRpb24uaXRlbS5kZWxldGUnO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjbGllbnQtZ2VuZXJhdGVkIElEIHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYW4gaXRlbSBpbiB0aGUgY29udmVyc2F0aW9uIGlzIGRlbGV0ZWQgYnkgdGhlIGNsaWVudCB3aXRoIGFcbiAqIGBjb252ZXJzYXRpb24uaXRlbS5kZWxldGVgIGV2ZW50LiBUaGlzIGV2ZW50IGlzIHVzZWQgdG8gc3luY2hyb25pemUgdGhlIHNlcnZlcidzXG4gKiB1bmRlcnN0YW5kaW5nIG9mIHRoZSBjb252ZXJzYXRpb24gaGlzdG9yeSB3aXRoIHRoZSBjbGllbnQncyB2aWV3LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbkl0ZW1EZWxldGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBpdGVtIHRoYXQgd2FzIGRlbGV0ZWQuXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBjb252ZXJzYXRpb24uaXRlbS5kZWxldGVkYC5cbiAgICovXG4gIHR5cGU6ICdjb252ZXJzYXRpb24uaXRlbS5kZWxldGVkJztcbn1cblxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHRoZSBvdXRwdXQgb2YgYXVkaW8gdHJhbnNjcmlwdGlvbiBmb3IgdXNlciBhdWRpbyB3cml0dGVuIHRvIHRoZVxuICogdXNlciBhdWRpbyBidWZmZXIuIFRyYW5zY3JpcHRpb24gYmVnaW5zIHdoZW4gdGhlIGlucHV0IGF1ZGlvIGJ1ZmZlciBpcyBjb21taXR0ZWRcbiAqIGJ5IHRoZSBjbGllbnQgb3Igc2VydmVyIChpbiBgc2VydmVyX3ZhZGAgbW9kZSkuIFRyYW5zY3JpcHRpb24gcnVuc1xuICogYXN5bmNocm9ub3VzbHkgd2l0aCBSZXNwb25zZSBjcmVhdGlvbiwgc28gdGhpcyBldmVudCBtYXkgY29tZSBiZWZvcmUgb3IgYWZ0ZXJcbiAqIHRoZSBSZXNwb25zZSBldmVudHMuXG4gKlxuICogUmVhbHRpbWUgQVBJIG1vZGVscyBhY2NlcHQgYXVkaW8gbmF0aXZlbHksIGFuZCB0aHVzIGlucHV0IHRyYW5zY3JpcHRpb24gaXMgYVxuICogc2VwYXJhdGUgcHJvY2VzcyBydW4gb24gYSBzZXBhcmF0ZSBBU1IgKEF1dG9tYXRpYyBTcGVlY2ggUmVjb2duaXRpb24pIG1vZGVsLFxuICogY3VycmVudGx5IGFsd2F5cyBgd2hpc3Blci0xYC4gVGh1cyB0aGUgdHJhbnNjcmlwdCBtYXkgZGl2ZXJnZSBzb21ld2hhdCBmcm9tIHRoZVxuICogbW9kZWwncyBpbnRlcnByZXRhdGlvbiwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgcm91Z2ggZ3VpZGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uSXRlbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uQ29tcGxldGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgY29udGFpbmluZyB0aGUgYXVkaW8uXG4gICAqL1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdXNlciBtZXNzYWdlIGl0ZW0gY29udGFpbmluZyB0aGUgYXVkaW8uXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0cmFuc2NyaWJlZCB0ZXh0LlxuICAgKi9cbiAgdHJhbnNjcmlwdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgY29udmVyc2F0aW9uLml0ZW0uaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbi5jb21wbGV0ZWRgLlxuICAgKi9cbiAgdHlwZTogJ2NvbnZlcnNhdGlvbi5pdGVtLmlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24uY29tcGxldGVkJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24gaXMgY29uZmlndXJlZCwgYW5kIGEgdHJhbnNjcmlwdGlvblxuICogcmVxdWVzdCBmb3IgYSB1c2VyIG1lc3NhZ2UgZmFpbGVkLiBUaGVzZSBldmVudHMgYXJlIHNlcGFyYXRlIGZyb20gb3RoZXIgYGVycm9yYFxuICogZXZlbnRzIHNvIHRoYXQgdGhlIGNsaWVudCBjYW4gaWRlbnRpZnkgdGhlIHJlbGF0ZWQgSXRlbS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb25JdGVtSW5wdXRBdWRpb1RyYW5zY3JpcHRpb25GYWlsZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCBjb250YWluaW5nIHRoZSBhdWRpby5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogRGV0YWlscyBvZiB0aGUgdHJhbnNjcmlwdGlvbiBlcnJvci5cbiAgICovXG4gIGVycm9yOiBDb252ZXJzYXRpb25JdGVtSW5wdXRBdWRpb1RyYW5zY3JpcHRpb25GYWlsZWRFdmVudC5FcnJvcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB1c2VyIG1lc3NhZ2UgaXRlbS5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGNvbnZlcnNhdGlvbi5pdGVtLmlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24uZmFpbGVkYC5cbiAgICovXG4gIHR5cGU6ICdjb252ZXJzYXRpb24uaXRlbS5pbnB1dF9hdWRpb190cmFuc2NyaXB0aW9uLmZhaWxlZCc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29udmVyc2F0aW9uSXRlbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uRmFpbGVkRXZlbnQge1xuICAvKipcbiAgICogRGV0YWlscyBvZiB0aGUgdHJhbnNjcmlwdGlvbiBlcnJvci5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUsIGlmIGFueS5cbiAgICAgKi9cbiAgICBjb2RlPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQSBodW1hbi1yZWFkYWJsZSBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIG1lc3NhZ2U/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBQYXJhbWV0ZXIgcmVsYXRlZCB0byB0aGUgZXJyb3IsIGlmIGFueS5cbiAgICAgKi9cbiAgICBwYXJhbT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIGVycm9yLlxuICAgICAqL1xuICAgIHR5cGU/OiBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBTZW5kIHRoaXMgZXZlbnQgdG8gdHJ1bmNhdGUgYSBwcmV2aW91cyBhc3Npc3RhbnQgbWVzc2FnZVx1MjAxOXMgYXVkaW8uIFRoZSBzZXJ2ZXJcbiAqIHdpbGwgcHJvZHVjZSBhdWRpbyBmYXN0ZXIgdGhhbiByZWFsdGltZSwgc28gdGhpcyBldmVudCBpcyB1c2VmdWwgd2hlbiB0aGUgdXNlclxuICogaW50ZXJydXB0cyB0byB0cnVuY2F0ZSBhdWRpbyB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gc2VudCB0byB0aGUgY2xpZW50IGJ1dCBub3RcbiAqIHlldCBwbGF5ZWQuIFRoaXMgd2lsbCBzeW5jaHJvbml6ZSB0aGUgc2VydmVyJ3MgdW5kZXJzdGFuZGluZyBvZiB0aGUgYXVkaW8gd2l0aFxuICogdGhlIGNsaWVudCdzIHBsYXliYWNrLlxuICpcbiAqIFRydW5jYXRpbmcgYXVkaW8gd2lsbCBkZWxldGUgdGhlIHNlcnZlci1zaWRlIHRleHQgdHJhbnNjcmlwdCB0byBlbnN1cmUgdGhlcmUgaXNcbiAqIG5vdCB0ZXh0IGluIHRoZSBjb250ZXh0IHRoYXQgaGFzbid0IGJlZW4gaGVhcmQgYnkgdGhlIHVzZXIuXG4gKlxuICogSWYgc3VjY2Vzc2Z1bCwgdGhlIHNlcnZlciB3aWxsIHJlc3BvbmQgd2l0aCBhIGBjb252ZXJzYXRpb24uaXRlbS50cnVuY2F0ZWRgXG4gKiBldmVudC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb25JdGVtVHJ1bmNhdGVFdmVudCB7XG4gIC8qKlxuICAgKiBJbmNsdXNpdmUgZHVyYXRpb24gdXAgdG8gd2hpY2ggYXVkaW8gaXMgdHJ1bmNhdGVkLCBpbiBtaWxsaXNlY29uZHMuIElmIHRoZVxuICAgKiBhdWRpb19lbmRfbXMgaXMgZ3JlYXRlciB0aGFuIHRoZSBhY3R1YWwgYXVkaW8gZHVyYXRpb24sIHRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kXG4gICAqIHdpdGggYW4gZXJyb3IuXG4gICAqL1xuICBhdWRpb19lbmRfbXM6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgdG8gdHJ1bmNhdGUuIFNldCB0aGlzIHRvIDAuXG4gICAqL1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgYXNzaXN0YW50IG1lc3NhZ2UgaXRlbSB0byB0cnVuY2F0ZS4gT25seSBhc3Npc3RhbnQgbWVzc2FnZSBpdGVtc1xuICAgKiBjYW4gYmUgdHJ1bmNhdGVkLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgY29udmVyc2F0aW9uLml0ZW0udHJ1bmNhdGVgLlxuICAgKi9cbiAgdHlwZTogJ2NvbnZlcnNhdGlvbi5pdGVtLnRydW5jYXRlJztcblxuICAvKipcbiAgICogT3B0aW9uYWwgY2xpZW50LWdlbmVyYXRlZCBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGFuIGVhcmxpZXIgYXNzaXN0YW50IGF1ZGlvIG1lc3NhZ2UgaXRlbSBpcyB0cnVuY2F0ZWQgYnkgdGhlIGNsaWVudFxuICogd2l0aCBhIGBjb252ZXJzYXRpb24uaXRlbS50cnVuY2F0ZWAgZXZlbnQuIFRoaXMgZXZlbnQgaXMgdXNlZCB0byBzeW5jaHJvbml6ZSB0aGVcbiAqIHNlcnZlcidzIHVuZGVyc3RhbmRpbmcgb2YgdGhlIGF1ZGlvIHdpdGggdGhlIGNsaWVudCdzIHBsYXliYWNrLlxuICpcbiAqIFRoaXMgYWN0aW9uIHdpbGwgdHJ1bmNhdGUgdGhlIGF1ZGlvIGFuZCByZW1vdmUgdGhlIHNlcnZlci1zaWRlIHRleHQgdHJhbnNjcmlwdFxuICogdG8gZW5zdXJlIHRoZXJlIGlzIG5vIHRleHQgaW4gdGhlIGNvbnRleHQgdGhhdCBoYXNuJ3QgYmVlbiBoZWFyZCBieSB0aGUgdXNlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb25JdGVtVHJ1bmNhdGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIGR1cmF0aW9uIHVwIHRvIHdoaWNoIHRoZSBhdWRpbyB3YXMgdHJ1bmNhdGVkLCBpbiBtaWxsaXNlY29uZHMuXG4gICAqL1xuICBhdWRpb19lbmRfbXM6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgdGhhdCB3YXMgdHJ1bmNhdGVkLlxuICAgKi9cbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGFzc2lzdGFudCBtZXNzYWdlIGl0ZW0gdGhhdCB3YXMgdHJ1bmNhdGVkLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgY29udmVyc2F0aW9uLml0ZW0udHJ1bmNhdGVkYC5cbiAgICovXG4gIHR5cGU6ICdjb252ZXJzYXRpb24uaXRlbS50cnVuY2F0ZWQnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzLCB3aGljaCBjb3VsZCBiZSBhIGNsaWVudCBwcm9ibGVtIG9yIGEgc2VydmVyXG4gKiBwcm9ibGVtLiBNb3N0IGVycm9ycyBhcmUgcmVjb3ZlcmFibGUgYW5kIHRoZSBzZXNzaW9uIHdpbGwgc3RheSBvcGVuLCB3ZVxuICogcmVjb21tZW5kIHRvIGltcGxlbWVudG9ycyB0byBtb25pdG9yIGFuZCBsb2cgZXJyb3IgbWVzc2FnZXMgYnkgZGVmYXVsdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFcnJvckV2ZW50IHtcbiAgLyoqXG4gICAqIERldGFpbHMgb2YgdGhlIGVycm9yLlxuICAgKi9cbiAgZXJyb3I6IEVycm9yRXZlbnQuRXJyb3I7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBlcnJvcmAuXG4gICAqL1xuICB0eXBlOiAnZXJyb3InO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEVycm9yRXZlbnQge1xuICAvKipcbiAgICogRGV0YWlscyBvZiB0aGUgZXJyb3IuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgbWVzc2FnZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgZXJyb3IgKGUuZy4sIFwiaW52YWxpZF9yZXF1ZXN0X2Vycm9yXCIsIFwic2VydmVyX2Vycm9yXCIpLlxuICAgICAqL1xuICAgIHR5cGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUsIGlmIGFueS5cbiAgICAgKi9cbiAgICBjb2RlPzogc3RyaW5nIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudF9pZCBvZiB0aGUgY2xpZW50IGV2ZW50IHRoYXQgY2F1c2VkIHRoZSBlcnJvciwgaWYgYXBwbGljYWJsZS5cbiAgICAgKi9cbiAgICBldmVudF9pZD86IHN0cmluZyB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBQYXJhbWV0ZXIgcmVsYXRlZCB0byB0aGUgZXJyb3IsIGlmIGFueS5cbiAgICAgKi9cbiAgICBwYXJhbT86IHN0cmluZyB8IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTZW5kIHRoaXMgZXZlbnQgdG8gYXBwZW5kIGF1ZGlvIGJ5dGVzIHRvIHRoZSBpbnB1dCBhdWRpbyBidWZmZXIuIFRoZSBhdWRpb1xuICogYnVmZmVyIGlzIHRlbXBvcmFyeSBzdG9yYWdlIHlvdSBjYW4gd3JpdGUgdG8gYW5kIGxhdGVyIGNvbW1pdC4gSW4gU2VydmVyIFZBRFxuICogbW9kZSwgdGhlIGF1ZGlvIGJ1ZmZlciBpcyB1c2VkIHRvIGRldGVjdCBzcGVlY2ggYW5kIHRoZSBzZXJ2ZXIgd2lsbCBkZWNpZGUgd2hlblxuICogdG8gY29tbWl0LiBXaGVuIFNlcnZlciBWQUQgaXMgZGlzYWJsZWQsIHlvdSBtdXN0IGNvbW1pdCB0aGUgYXVkaW8gYnVmZmVyXG4gKiBtYW51YWxseS5cbiAqXG4gKiBUaGUgY2xpZW50IG1heSBjaG9vc2UgaG93IG11Y2ggYXVkaW8gdG8gcGxhY2UgaW4gZWFjaCBldmVudCB1cCB0byBhIG1heGltdW0gb2ZcbiAqIDE1IE1pQiwgZm9yIGV4YW1wbGUgc3RyZWFtaW5nIHNtYWxsZXIgY2h1bmtzIGZyb20gdGhlIGNsaWVudCBtYXkgYWxsb3cgdGhlIFZBRFxuICogdG8gYmUgbW9yZSByZXNwb25zaXZlLiBVbmxpa2UgbWFkZSBvdGhlciBjbGllbnQgZXZlbnRzLCB0aGUgc2VydmVyIHdpbGwgbm90IHNlbmRcbiAqIGEgY29uZmlybWF0aW9uIHJlc3BvbnNlIHRvIHRoaXMgZXZlbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb0J1ZmZlckFwcGVuZEV2ZW50IHtcbiAgLyoqXG4gICAqIEJhc2U2NC1lbmNvZGVkIGF1ZGlvIGJ5dGVzLiBUaGlzIG11c3QgYmUgaW4gdGhlIGZvcm1hdCBzcGVjaWZpZWQgYnkgdGhlXG4gICAqIGBpbnB1dF9hdWRpb19mb3JtYXRgIGZpZWxkIGluIHRoZSBzZXNzaW9uIGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBhdWRpbzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgaW5wdXRfYXVkaW9fYnVmZmVyLmFwcGVuZGAuXG4gICAqL1xuICB0eXBlOiAnaW5wdXRfYXVkaW9fYnVmZmVyLmFwcGVuZCc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGNsaWVudC1nZW5lcmF0ZWQgSUQgdXNlZCB0byBpZGVudGlmeSB0aGlzIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogU2VuZCB0aGlzIGV2ZW50IHRvIGNsZWFyIHRoZSBhdWRpbyBieXRlcyBpbiB0aGUgYnVmZmVyLiBUaGUgc2VydmVyIHdpbGwgcmVzcG9uZFxuICogd2l0aCBhbiBgaW5wdXRfYXVkaW9fYnVmZmVyLmNsZWFyZWRgIGV2ZW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9CdWZmZXJDbGVhckV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBpbnB1dF9hdWRpb19idWZmZXIuY2xlYXJgLlxuICAgKi9cbiAgdHlwZTogJ2lucHV0X2F1ZGlvX2J1ZmZlci5jbGVhcic7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGNsaWVudC1nZW5lcmF0ZWQgSUQgdXNlZCB0byBpZGVudGlmeSB0aGlzIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiB0aGUgaW5wdXQgYXVkaW8gYnVmZmVyIGlzIGNsZWFyZWQgYnkgdGhlIGNsaWVudCB3aXRoIGFcbiAqIGBpbnB1dF9hdWRpb19idWZmZXIuY2xlYXJgIGV2ZW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9CdWZmZXJDbGVhcmVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGlucHV0X2F1ZGlvX2J1ZmZlci5jbGVhcmVkYC5cbiAgICovXG4gIHR5cGU6ICdpbnB1dF9hdWRpb19idWZmZXIuY2xlYXJlZCc7XG59XG5cbi8qKlxuICogU2VuZCB0aGlzIGV2ZW50IHRvIGNvbW1pdCB0aGUgdXNlciBpbnB1dCBhdWRpbyBidWZmZXIsIHdoaWNoIHdpbGwgY3JlYXRlIGEgbmV3XG4gKiB1c2VyIG1lc3NhZ2UgaXRlbSBpbiB0aGUgY29udmVyc2F0aW9uLiBUaGlzIGV2ZW50IHdpbGwgcHJvZHVjZSBhbiBlcnJvciBpZiB0aGVcbiAqIGlucHV0IGF1ZGlvIGJ1ZmZlciBpcyBlbXB0eS4gV2hlbiBpbiBTZXJ2ZXIgVkFEIG1vZGUsIHRoZSBjbGllbnQgZG9lcyBub3QgbmVlZFxuICogdG8gc2VuZCB0aGlzIGV2ZW50LCB0aGUgc2VydmVyIHdpbGwgY29tbWl0IHRoZSBhdWRpbyBidWZmZXIgYXV0b21hdGljYWxseS5cbiAqXG4gKiBDb21taXR0aW5nIHRoZSBpbnB1dCBhdWRpbyBidWZmZXIgd2lsbCB0cmlnZ2VyIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24gKGlmXG4gKiBlbmFibGVkIGluIHNlc3Npb24gY29uZmlndXJhdGlvbiksIGJ1dCBpdCB3aWxsIG5vdCBjcmVhdGUgYSByZXNwb25zZSBmcm9tIHRoZVxuICogbW9kZWwuIFRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kIHdpdGggYW4gYGlucHV0X2F1ZGlvX2J1ZmZlci5jb21taXR0ZWRgIGV2ZW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9CdWZmZXJDb21taXRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgaW5wdXRfYXVkaW9fYnVmZmVyLmNvbW1pdGAuXG4gICAqL1xuICB0eXBlOiAnaW5wdXRfYXVkaW9fYnVmZmVyLmNvbW1pdCc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGNsaWVudC1nZW5lcmF0ZWQgSUQgdXNlZCB0byBpZGVudGlmeSB0aGlzIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhbiBpbnB1dCBhdWRpbyBidWZmZXIgaXMgY29tbWl0dGVkLCBlaXRoZXIgYnkgdGhlIGNsaWVudCBvclxuICogYXV0b21hdGljYWxseSBpbiBzZXJ2ZXIgVkFEIG1vZGUuIFRoZSBgaXRlbV9pZGAgcHJvcGVydHkgaXMgdGhlIElEIG9mIHRoZSB1c2VyXG4gKiBtZXNzYWdlIGl0ZW0gdGhhdCB3aWxsIGJlIGNyZWF0ZWQsIHRodXMgYSBgY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlZGAgZXZlbnQgd2lsbFxuICogYWxzbyBiZSBzZW50IHRvIHRoZSBjbGllbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb0J1ZmZlckNvbW1pdHRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdXNlciBtZXNzYWdlIGl0ZW0gdGhhdCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcHJlY2VkaW5nIGl0ZW0gYWZ0ZXIgd2hpY2ggdGhlIG5ldyBpdGVtIHdpbGwgYmUgaW5zZXJ0ZWQuXG4gICAqL1xuICBwcmV2aW91c19pdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBpbnB1dF9hdWRpb19idWZmZXIuY29tbWl0dGVkYC5cbiAgICovXG4gIHR5cGU6ICdpbnB1dF9hdWRpb19idWZmZXIuY29tbWl0dGVkJztcbn1cblxuLyoqXG4gKiBTZW50IGJ5IHRoZSBzZXJ2ZXIgd2hlbiBpbiBgc2VydmVyX3ZhZGAgbW9kZSB0byBpbmRpY2F0ZSB0aGF0IHNwZWVjaCBoYXMgYmVlblxuICogZGV0ZWN0ZWQgaW4gdGhlIGF1ZGlvIGJ1ZmZlci4gVGhpcyBjYW4gaGFwcGVuIGFueSB0aW1lIGF1ZGlvIGlzIGFkZGVkIHRvIHRoZVxuICogYnVmZmVyICh1bmxlc3Mgc3BlZWNoIGlzIGFscmVhZHkgZGV0ZWN0ZWQpLiBUaGUgY2xpZW50IG1heSB3YW50IHRvIHVzZSB0aGlzXG4gKiBldmVudCB0byBpbnRlcnJ1cHQgYXVkaW8gcGxheWJhY2sgb3IgcHJvdmlkZSB2aXN1YWwgZmVlZGJhY2sgdG8gdGhlIHVzZXIuXG4gKlxuICogVGhlIGNsaWVudCBzaG91bGQgZXhwZWN0IHRvIHJlY2VpdmUgYSBgaW5wdXRfYXVkaW9fYnVmZmVyLnNwZWVjaF9zdG9wcGVkYCBldmVudFxuICogd2hlbiBzcGVlY2ggc3RvcHMuIFRoZSBgaXRlbV9pZGAgcHJvcGVydHkgaXMgdGhlIElEIG9mIHRoZSB1c2VyIG1lc3NhZ2UgaXRlbVxuICogdGhhdCB3aWxsIGJlIGNyZWF0ZWQgd2hlbiBzcGVlY2ggc3RvcHMgYW5kIHdpbGwgYWxzbyBiZSBpbmNsdWRlZCBpbiB0aGVcbiAqIGBpbnB1dF9hdWRpb19idWZmZXIuc3BlZWNoX3N0b3BwZWRgIGV2ZW50ICh1bmxlc3MgdGhlIGNsaWVudCBtYW51YWxseSBjb21taXRzXG4gKiB0aGUgYXVkaW8gYnVmZmVyIGR1cmluZyBWQUQgYWN0aXZhdGlvbikuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb0J1ZmZlclNwZWVjaFN0YXJ0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBNaWxsaXNlY29uZHMgZnJvbSB0aGUgc3RhcnQgb2YgYWxsIGF1ZGlvIHdyaXR0ZW4gdG8gdGhlIGJ1ZmZlciBkdXJpbmcgdGhlXG4gICAqIHNlc3Npb24gd2hlbiBzcGVlY2ggd2FzIGZpcnN0IGRldGVjdGVkLiBUaGlzIHdpbGwgY29ycmVzcG9uZCB0byB0aGUgYmVnaW5uaW5nIG9mXG4gICAqIGF1ZGlvIHNlbnQgdG8gdGhlIG1vZGVsLCBhbmQgdGh1cyBpbmNsdWRlcyB0aGUgYHByZWZpeF9wYWRkaW5nX21zYCBjb25maWd1cmVkIGluXG4gICAqIHRoZSBTZXNzaW9uLlxuICAgKi9cbiAgYXVkaW9fc3RhcnRfbXM6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB1c2VyIG1lc3NhZ2UgaXRlbSB0aGF0IHdpbGwgYmUgY3JlYXRlZCB3aGVuIHNwZWVjaCBzdG9wcy5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGlucHV0X2F1ZGlvX2J1ZmZlci5zcGVlY2hfc3RhcnRlZGAuXG4gICAqL1xuICB0eXBlOiAnaW5wdXRfYXVkaW9fYnVmZmVyLnNwZWVjaF9zdGFydGVkJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCBpbiBgc2VydmVyX3ZhZGAgbW9kZSB3aGVuIHRoZSBzZXJ2ZXIgZGV0ZWN0cyB0aGUgZW5kIG9mIHNwZWVjaCBpbiB0aGVcbiAqIGF1ZGlvIGJ1ZmZlci4gVGhlIHNlcnZlciB3aWxsIGFsc28gc2VuZCBhbiBgY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlZGAgZXZlbnRcbiAqIHdpdGggdGhlIHVzZXIgbWVzc2FnZSBpdGVtIHRoYXQgaXMgY3JlYXRlZCBmcm9tIHRoZSBhdWRpbyBidWZmZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb0J1ZmZlclNwZWVjaFN0b3BwZWRFdmVudCB7XG4gIC8qKlxuICAgKiBNaWxsaXNlY29uZHMgc2luY2UgdGhlIHNlc3Npb24gc3RhcnRlZCB3aGVuIHNwZWVjaCBzdG9wcGVkLiBUaGlzIHdpbGwgY29ycmVzcG9uZFxuICAgKiB0byB0aGUgZW5kIG9mIGF1ZGlvIHNlbnQgdG8gdGhlIG1vZGVsLCBhbmQgdGh1cyBpbmNsdWRlcyB0aGVcbiAgICogYG1pbl9zaWxlbmNlX2R1cmF0aW9uX21zYCBjb25maWd1cmVkIGluIHRoZSBTZXNzaW9uLlxuICAgKi9cbiAgYXVkaW9fZW5kX21zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdXNlciBtZXNzYWdlIGl0ZW0gdGhhdCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBpbnB1dF9hdWRpb19idWZmZXIuc3BlZWNoX3N0b3BwZWRgLlxuICAgKi9cbiAgdHlwZTogJ2lucHV0X2F1ZGlvX2J1ZmZlci5zcGVlY2hfc3RvcHBlZCc7XG59XG5cbi8qKlxuICogRW1pdHRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgUmVzcG9uc2UgdG8gaW5kaWNhdGUgdGhlIHVwZGF0ZWQgcmF0ZSBsaW1pdHMuIFdoZW5cbiAqIGEgUmVzcG9uc2UgaXMgY3JlYXRlZCBzb21lIHRva2VucyB3aWxsIGJlIFwicmVzZXJ2ZWRcIiBmb3IgdGhlIG91dHB1dCB0b2tlbnMsIHRoZVxuICogcmF0ZSBsaW1pdHMgc2hvd24gaGVyZSByZWZsZWN0IHRoYXQgcmVzZXJ2YXRpb24sIHdoaWNoIGlzIHRoZW4gYWRqdXN0ZWRcbiAqIGFjY29yZGluZ2x5IG9uY2UgdGhlIFJlc3BvbnNlIGlzIGNvbXBsZXRlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSYXRlTGltaXRzVXBkYXRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgcmF0ZSBsaW1pdCBpbmZvcm1hdGlvbi5cbiAgICovXG4gIHJhdGVfbGltaXRzOiBBcnJheTxSYXRlTGltaXRzVXBkYXRlZEV2ZW50LlJhdGVMaW1pdD47XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByYXRlX2xpbWl0cy51cGRhdGVkYC5cbiAgICovXG4gIHR5cGU6ICdyYXRlX2xpbWl0cy51cGRhdGVkJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSYXRlTGltaXRzVXBkYXRlZEV2ZW50IHtcbiAgZXhwb3J0IGludGVyZmFjZSBSYXRlTGltaXQge1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgZm9yIHRoZSByYXRlIGxpbWl0LlxuICAgICAqL1xuICAgIGxpbWl0PzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHJhdGUgbGltaXQgKGByZXF1ZXN0c2AsIGB0b2tlbnNgKS5cbiAgICAgKi9cbiAgICBuYW1lPzogJ3JlcXVlc3RzJyB8ICd0b2tlbnMnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlbWFpbmluZyB2YWx1ZSBiZWZvcmUgdGhlIGxpbWl0IGlzIHJlYWNoZWQuXG4gICAgICovXG4gICAgcmVtYWluaW5nPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU2Vjb25kcyB1bnRpbCB0aGUgcmF0ZSBsaW1pdCByZXNldHMuXG4gICAgICovXG4gICAgcmVzZXRfc2Vjb25kcz86IG51bWJlcjtcbiAgfVxufVxuXG4vKipcbiAqIEFsbCBldmVudHMgdGhhdCB0aGUgY2xpZW50IGNhbiBzZW5kIHRvIHRoZSBSZWFsdGltZSBBUElcbiAqL1xuZXhwb3J0IHR5cGUgUmVhbHRpbWVDbGllbnRFdmVudCA9XG4gIHwgU2Vzc2lvblVwZGF0ZUV2ZW50XG4gIHwgSW5wdXRBdWRpb0J1ZmZlckFwcGVuZEV2ZW50XG4gIHwgSW5wdXRBdWRpb0J1ZmZlckNvbW1pdEV2ZW50XG4gIHwgSW5wdXRBdWRpb0J1ZmZlckNsZWFyRXZlbnRcbiAgfCBDb252ZXJzYXRpb25JdGVtQ3JlYXRlRXZlbnRcbiAgfCBDb252ZXJzYXRpb25JdGVtVHJ1bmNhdGVFdmVudFxuICB8IENvbnZlcnNhdGlvbkl0ZW1EZWxldGVFdmVudFxuICB8IFJlc3BvbnNlQ3JlYXRlRXZlbnRcbiAgfCBSZXNwb25zZUNhbmNlbEV2ZW50O1xuXG4vKipcbiAqIFRoZSByZXNwb25zZSByZXNvdXJjZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWFsdGltZVJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgaWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERldmVsb3Blci1wcm92aWRlZCBzdHJpbmcga2V5LXZhbHVlIHBhaXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJlc3BvbnNlLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCBtdXN0IGJlIGByZWFsdGltZS5yZXNwb25zZWAuXG4gICAqL1xuICBvYmplY3Q/OiAncmVhbHRpbWUucmVzcG9uc2UnO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBvdXRwdXQgaXRlbXMgZ2VuZXJhdGVkIGJ5IHRoZSByZXNwb25zZS5cbiAgICovXG4gIG91dHB1dD86IEFycmF5PENvbnZlcnNhdGlvbkl0ZW0+O1xuXG4gIC8qKlxuICAgKiBUaGUgZmluYWwgc3RhdHVzIG9mIHRoZSByZXNwb25zZSAoYGNvbXBsZXRlZGAsIGBjYW5jZWxsZWRgLCBgZmFpbGVkYCwgb3JcbiAgICogYGluY29tcGxldGVgKS5cbiAgICovXG4gIHN0YXR1cz86ICdjb21wbGV0ZWQnIHwgJ2NhbmNlbGxlZCcgfCAnZmFpbGVkJyB8ICdpbmNvbXBsZXRlJztcblxuICAvKipcbiAgICogQWRkaXRpb25hbCBkZXRhaWxzIGFib3V0IHRoZSBzdGF0dXMuXG4gICAqL1xuICBzdGF0dXNfZGV0YWlscz86IFJlYWx0aW1lUmVzcG9uc2VTdGF0dXM7XG5cbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBSZXNwb25zZSwgdGhpcyB3aWxsIGNvcnJlc3BvbmQgdG8gYmlsbGluZy4gQSBSZWFsdGltZVxuICAgKiBBUEkgc2Vzc2lvbiB3aWxsIG1haW50YWluIGEgY29udmVyc2F0aW9uIGNvbnRleHQgYW5kIGFwcGVuZCBuZXcgSXRlbXMgdG8gdGhlXG4gICAqIENvbnZlcnNhdGlvbiwgdGh1cyBvdXRwdXQgZnJvbSBwcmV2aW91cyB0dXJucyAodGV4dCBhbmQgYXVkaW8gdG9rZW5zKSB3aWxsXG4gICAqIGJlY29tZSB0aGUgaW5wdXQgZm9yIGxhdGVyIHR1cm5zLlxuICAgKi9cbiAgdXNhZ2U/OiBSZWFsdGltZVJlc3BvbnNlVXNhZ2U7XG59XG5cbi8qKlxuICogQWRkaXRpb25hbCBkZXRhaWxzIGFib3V0IHRoZSBzdGF0dXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVhbHRpbWVSZXNwb25zZVN0YXR1cyB7XG4gIC8qKlxuICAgKiBBIGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvciB0aGF0IGNhdXNlZCB0aGUgcmVzcG9uc2UgdG8gZmFpbCwgcG9wdWxhdGVkIHdoZW4gdGhlXG4gICAqIGBzdGF0dXNgIGlzIGBmYWlsZWRgLlxuICAgKi9cbiAgZXJyb3I/OiBSZWFsdGltZVJlc3BvbnNlU3RhdHVzLkVycm9yO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVhc29uIHRoZSBSZXNwb25zZSBkaWQgbm90IGNvbXBsZXRlLiBGb3IgYSBgY2FuY2VsbGVkYCBSZXNwb25zZSwgb25lIG9mXG4gICAqIGB0dXJuX2RldGVjdGVkYCAodGhlIHNlcnZlciBWQUQgZGV0ZWN0ZWQgYSBuZXcgc3RhcnQgb2Ygc3BlZWNoKSBvclxuICAgKiBgY2xpZW50X2NhbmNlbGxlZGAgKHRoZSBjbGllbnQgc2VudCBhIGNhbmNlbCBldmVudCkuIEZvciBhbiBgaW5jb21wbGV0ZWBcbiAgICogUmVzcG9uc2UsIG9uZSBvZiBgbWF4X291dHB1dF90b2tlbnNgIG9yIGBjb250ZW50X2ZpbHRlcmAgKHRoZSBzZXJ2ZXItc2lkZSBzYWZldHlcbiAgICogZmlsdGVyIGFjdGl2YXRlZCBhbmQgY3V0IG9mZiB0aGUgcmVzcG9uc2UpLlxuICAgKi9cbiAgcmVhc29uPzogJ3R1cm5fZGV0ZWN0ZWQnIHwgJ2NsaWVudF9jYW5jZWxsZWQnIHwgJ21heF9vdXRwdXRfdG9rZW5zJyB8ICdjb250ZW50X2ZpbHRlcic7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGVycm9yIHRoYXQgY2F1c2VkIHRoZSByZXNwb25zZSB0byBmYWlsLCBjb3JyZXNwb25kaW5nIHdpdGggdGhlXG4gICAqIGBzdGF0dXNgIGZpZWxkIChgY29tcGxldGVkYCwgYGNhbmNlbGxlZGAsIGBpbmNvbXBsZXRlYCwgYGZhaWxlZGApLlxuICAgKi9cbiAgdHlwZT86ICdjb21wbGV0ZWQnIHwgJ2NhbmNlbGxlZCcgfCAnaW5jb21wbGV0ZScgfCAnZmFpbGVkJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSZWFsdGltZVJlc3BvbnNlU3RhdHVzIHtcbiAgLyoqXG4gICAqIEEgZGVzY3JpcHRpb24gb2YgdGhlIGVycm9yIHRoYXQgY2F1c2VkIHRoZSByZXNwb25zZSB0byBmYWlsLCBwb3B1bGF0ZWQgd2hlbiB0aGVcbiAgICogYHN0YXR1c2AgaXMgYGZhaWxlZGAuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlLCBpZiBhbnkuXG4gICAgICovXG4gICAgY29kZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIGVycm9yLlxuICAgICAqL1xuICAgIHR5cGU/OiBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBVc2FnZSBzdGF0aXN0aWNzIGZvciB0aGUgUmVzcG9uc2UsIHRoaXMgd2lsbCBjb3JyZXNwb25kIHRvIGJpbGxpbmcuIEEgUmVhbHRpbWVcbiAqIEFQSSBzZXNzaW9uIHdpbGwgbWFpbnRhaW4gYSBjb252ZXJzYXRpb24gY29udGV4dCBhbmQgYXBwZW5kIG5ldyBJdGVtcyB0byB0aGVcbiAqIENvbnZlcnNhdGlvbiwgdGh1cyBvdXRwdXQgZnJvbSBwcmV2aW91cyB0dXJucyAodGV4dCBhbmQgYXVkaW8gdG9rZW5zKSB3aWxsXG4gKiBiZWNvbWUgdGhlIGlucHV0IGZvciBsYXRlciB0dXJucy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWFsdGltZVJlc3BvbnNlVXNhZ2Uge1xuICAvKipcbiAgICogRGV0YWlscyBhYm91dCB0aGUgaW5wdXQgdG9rZW5zIHVzZWQgaW4gdGhlIFJlc3BvbnNlLlxuICAgKi9cbiAgaW5wdXRfdG9rZW5fZGV0YWlscz86IFJlYWx0aW1lUmVzcG9uc2VVc2FnZS5JbnB1dFRva2VuRGV0YWlscztcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBpbnB1dCB0b2tlbnMgdXNlZCBpbiB0aGUgUmVzcG9uc2UsIGluY2x1ZGluZyB0ZXh0IGFuZCBhdWRpb1xuICAgKiB0b2tlbnMuXG4gICAqL1xuICBpbnB1dF90b2tlbnM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIERldGFpbHMgYWJvdXQgdGhlIG91dHB1dCB0b2tlbnMgdXNlZCBpbiB0aGUgUmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXRfdG9rZW5fZGV0YWlscz86IFJlYWx0aW1lUmVzcG9uc2VVc2FnZS5PdXRwdXRUb2tlbkRldGFpbHM7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2Ygb3V0cHV0IHRva2VucyBzZW50IGluIHRoZSBSZXNwb25zZSwgaW5jbHVkaW5nIHRleHQgYW5kIGF1ZGlvXG4gICAqIHRva2Vucy5cbiAgICovXG4gIG91dHB1dF90b2tlbnM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBSZXNwb25zZSBpbmNsdWRpbmcgaW5wdXQgYW5kIG91dHB1dCB0ZXh0IGFuZFxuICAgKiBhdWRpbyB0b2tlbnMuXG4gICAqL1xuICB0b3RhbF90b2tlbnM/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUmVhbHRpbWVSZXNwb25zZVVzYWdlIHtcbiAgLyoqXG4gICAqIERldGFpbHMgYWJvdXQgdGhlIGlucHV0IHRva2VucyB1c2VkIGluIHRoZSBSZXNwb25zZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSW5wdXRUb2tlbkRldGFpbHMge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgYXVkaW8gdG9rZW5zIHVzZWQgaW4gdGhlIFJlc3BvbnNlLlxuICAgICAqL1xuICAgIGF1ZGlvX3Rva2Vucz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgY2FjaGVkIHRva2VucyB1c2VkIGluIHRoZSBSZXNwb25zZS5cbiAgICAgKi9cbiAgICBjYWNoZWRfdG9rZW5zPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiB0ZXh0IHRva2VucyB1c2VkIGluIHRoZSBSZXNwb25zZS5cbiAgICAgKi9cbiAgICB0ZXh0X3Rva2Vucz86IG51bWJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRhaWxzIGFib3V0IHRoZSBvdXRwdXQgdG9rZW5zIHVzZWQgaW4gdGhlIFJlc3BvbnNlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBPdXRwdXRUb2tlbkRldGFpbHMge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgYXVkaW8gdG9rZW5zIHVzZWQgaW4gdGhlIFJlc3BvbnNlLlxuICAgICAqL1xuICAgIGF1ZGlvX3Rva2Vucz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgdGV4dCB0b2tlbnMgdXNlZCBpbiB0aGUgUmVzcG9uc2UuXG4gICAgICovXG4gICAgdGV4dF90b2tlbnM/OiBudW1iZXI7XG4gIH1cbn1cblxuLyoqXG4gKiBBbGwgZXZlbnRzIHRoYXQgdGhlIFJlYWx0aW1lIEFQSSBjYW4gc2VuZCBiYWNrXG4gKi9cbmV4cG9ydCB0eXBlIFJlYWx0aW1lU2VydmVyRXZlbnQgPVxuICB8IEVycm9yRXZlbnRcbiAgfCBTZXNzaW9uQ3JlYXRlZEV2ZW50XG4gIHwgU2Vzc2lvblVwZGF0ZWRFdmVudFxuICB8IENvbnZlcnNhdGlvbkNyZWF0ZWRFdmVudFxuICB8IElucHV0QXVkaW9CdWZmZXJDb21taXR0ZWRFdmVudFxuICB8IElucHV0QXVkaW9CdWZmZXJDbGVhcmVkRXZlbnRcbiAgfCBJbnB1dEF1ZGlvQnVmZmVyU3BlZWNoU3RhcnRlZEV2ZW50XG4gIHwgSW5wdXRBdWRpb0J1ZmZlclNwZWVjaFN0b3BwZWRFdmVudFxuICB8IENvbnZlcnNhdGlvbkl0ZW1DcmVhdGVkRXZlbnRcbiAgfCBDb252ZXJzYXRpb25JdGVtSW5wdXRBdWRpb1RyYW5zY3JpcHRpb25Db21wbGV0ZWRFdmVudFxuICB8IENvbnZlcnNhdGlvbkl0ZW1JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbkZhaWxlZEV2ZW50XG4gIHwgQ29udmVyc2F0aW9uSXRlbVRydW5jYXRlZEV2ZW50XG4gIHwgQ29udmVyc2F0aW9uSXRlbURlbGV0ZWRFdmVudFxuICB8IFJlc3BvbnNlQ3JlYXRlZEV2ZW50XG4gIHwgUmVzcG9uc2VEb25lRXZlbnRcbiAgfCBSZXNwb25zZU91dHB1dEl0ZW1BZGRlZEV2ZW50XG4gIHwgUmVzcG9uc2VPdXRwdXRJdGVtRG9uZUV2ZW50XG4gIHwgUmVzcG9uc2VDb250ZW50UGFydEFkZGVkRXZlbnRcbiAgfCBSZXNwb25zZUNvbnRlbnRQYXJ0RG9uZUV2ZW50XG4gIHwgUmVzcG9uc2VUZXh0RGVsdGFFdmVudFxuICB8IFJlc3BvbnNlVGV4dERvbmVFdmVudFxuICB8IFJlc3BvbnNlQXVkaW9UcmFuc2NyaXB0RGVsdGFFdmVudFxuICB8IFJlc3BvbnNlQXVkaW9UcmFuc2NyaXB0RG9uZUV2ZW50XG4gIHwgUmVzcG9uc2VBdWRpb0RlbHRhRXZlbnRcbiAgfCBSZXNwb25zZUF1ZGlvRG9uZUV2ZW50XG4gIHwgUmVzcG9uc2VGdW5jdGlvbkNhbGxBcmd1bWVudHNEZWx0YUV2ZW50XG4gIHwgUmVzcG9uc2VGdW5jdGlvbkNhbGxBcmd1bWVudHNEb25lRXZlbnRcbiAgfCBSYXRlTGltaXRzVXBkYXRlZEV2ZW50O1xuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gdGhlIG1vZGVsLWdlbmVyYXRlZCBhdWRpbyBpcyB1cGRhdGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQXVkaW9EZWx0YUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGluIHRoZSBpdGVtJ3MgY29udGVudCBhcnJheS5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogQmFzZTY0LWVuY29kZWQgYXVkaW8gZGF0YSBkZWx0YS5cbiAgICovXG4gIGRlbHRhOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgaXRlbS5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaXRlbSBpbiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSByZXNwb25zZS5cbiAgICovXG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5hdWRpby5kZWx0YWAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UuYXVkaW8uZGVsdGEnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gdGhlIG1vZGVsLWdlbmVyYXRlZCBhdWRpbyBpcyBkb25lLiBBbHNvIGVtaXR0ZWQgd2hlbiBhIFJlc3BvbnNlIGlzXG4gKiBpbnRlcnJ1cHRlZCwgaW5jb21wbGV0ZSwgb3IgY2FuY2VsbGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQXVkaW9Eb25lRXZlbnQge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgaW4gdGhlIGl0ZW0ncyBjb250ZW50IGFycmF5LlxuICAgKi9cbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGl0ZW0uXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGl0ZW0gaW4gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UuYXVkaW8uZG9uZWAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UuYXVkaW8uZG9uZSc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiB0aGUgbW9kZWwtZ2VuZXJhdGVkIHRyYW5zY3JpcHRpb24gb2YgYXVkaW8gb3V0cHV0IGlzIHVwZGF0ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VBdWRpb1RyYW5zY3JpcHREZWx0YUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGluIHRoZSBpdGVtJ3MgY29udGVudCBhcnJheS5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHRyYW5zY3JpcHQgZGVsdGEuXG4gICAqL1xuICBkZWx0YTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGl0ZW0uXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGl0ZW0gaW4gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UuYXVkaW9fdHJhbnNjcmlwdC5kZWx0YWAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UuYXVkaW9fdHJhbnNjcmlwdC5kZWx0YSc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiB0aGUgbW9kZWwtZ2VuZXJhdGVkIHRyYW5zY3JpcHRpb24gb2YgYXVkaW8gb3V0cHV0IGlzIGRvbmVcbiAqIHN0cmVhbWluZy4gQWxzbyBlbWl0dGVkIHdoZW4gYSBSZXNwb25zZSBpcyBpbnRlcnJ1cHRlZCwgaW5jb21wbGV0ZSwgb3JcbiAqIGNhbmNlbGxlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUF1ZGlvVHJhbnNjcmlwdERvbmVFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCBpbiB0aGUgaXRlbSdzIGNvbnRlbnQgYXJyYXkuXG4gICAqL1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgaXRlbS5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaXRlbSBpbiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSByZXNwb25zZS5cbiAgICovXG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBmaW5hbCB0cmFuc2NyaXB0IG9mIHRoZSBhdWRpby5cbiAgICovXG4gIHRyYW5zY3JpcHQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLmF1ZGlvX3RyYW5zY3JpcHQuZG9uZWAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UuYXVkaW9fdHJhbnNjcmlwdC5kb25lJztcbn1cblxuLyoqXG4gKiBTZW5kIHRoaXMgZXZlbnQgdG8gY2FuY2VsIGFuIGluLXByb2dyZXNzIHJlc3BvbnNlLiBUaGUgc2VydmVyIHdpbGwgcmVzcG9uZCB3aXRoXG4gKiBhIGByZXNwb25zZS5jYW5jZWxsZWRgIGV2ZW50IG9yIGFuIGVycm9yIGlmIHRoZXJlIGlzIG5vIHJlc3BvbnNlIHRvIGNhbmNlbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUNhbmNlbEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5jYW5jZWxgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLmNhbmNlbCc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGNsaWVudC1nZW5lcmF0ZWQgSUQgdXNlZCB0byBpZGVudGlmeSB0aGlzIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lmaWMgcmVzcG9uc2UgSUQgdG8gY2FuY2VsIC0gaWYgbm90IHByb3ZpZGVkLCB3aWxsIGNhbmNlbCBhbiBpbi1wcm9ncmVzc1xuICAgKiByZXNwb25zZSBpbiB0aGUgZGVmYXVsdCBjb252ZXJzYXRpb24uXG4gICAqL1xuICByZXNwb25zZV9pZD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGEgbmV3IGNvbnRlbnQgcGFydCBpcyBhZGRlZCB0byBhbiBhc3Npc3RhbnQgbWVzc2FnZSBpdGVtIGR1cmluZ1xuICogcmVzcG9uc2UgZ2VuZXJhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUNvbnRlbnRQYXJ0QWRkZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCBpbiB0aGUgaXRlbSdzIGNvbnRlbnQgYXJyYXkuXG4gICAqL1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgaXRlbSB0byB3aGljaCB0aGUgY29udGVudCBwYXJ0IHdhcyBhZGRlZC5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaXRlbSBpbiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgcGFydCB0aGF0IHdhcyBhZGRlZC5cbiAgICovXG4gIHBhcnQ6IFJlc3BvbnNlQ29udGVudFBhcnRBZGRlZEV2ZW50LlBhcnQ7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UuY29udGVudF9wYXJ0LmFkZGVkYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5jb250ZW50X3BhcnQuYWRkZWQnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJlc3BvbnNlQ29udGVudFBhcnRBZGRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IHBhcnQgdGhhdCB3YXMgYWRkZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFBhcnQge1xuICAgIC8qKlxuICAgICAqIEJhc2U2NC1lbmNvZGVkIGF1ZGlvIGRhdGEgKGlmIHR5cGUgaXMgXCJhdWRpb1wiKS5cbiAgICAgKi9cbiAgICBhdWRpbz86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IGNvbnRlbnQgKGlmIHR5cGUgaXMgXCJ0ZXh0XCIpLlxuICAgICAqL1xuICAgIHRleHQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNjcmlwdCBvZiB0aGUgYXVkaW8gKGlmIHR5cGUgaXMgXCJhdWRpb1wiKS5cbiAgICAgKi9cbiAgICB0cmFuc2NyaXB0Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRlbnQgdHlwZSAoXCJ0ZXh0XCIsIFwiYXVkaW9cIikuXG4gICAgICovXG4gICAgdHlwZT86ICd0ZXh0JyB8ICdhdWRpbyc7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGEgY29udGVudCBwYXJ0IGlzIGRvbmUgc3RyZWFtaW5nIGluIGFuIGFzc2lzdGFudCBtZXNzYWdlIGl0ZW0uXG4gKiBBbHNvIGVtaXR0ZWQgd2hlbiBhIFJlc3BvbnNlIGlzIGludGVycnVwdGVkLCBpbmNvbXBsZXRlLCBvciBjYW5jZWxsZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VDb250ZW50UGFydERvbmVFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCBpbiB0aGUgaXRlbSdzIGNvbnRlbnQgYXJyYXkuXG4gICAqL1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgaXRlbS5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaXRlbSBpbiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgcGFydCB0aGF0IGlzIGRvbmUuXG4gICAqL1xuICBwYXJ0OiBSZXNwb25zZUNvbnRlbnRQYXJ0RG9uZUV2ZW50LlBhcnQ7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UuY29udGVudF9wYXJ0LmRvbmVgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLmNvbnRlbnRfcGFydC5kb25lJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSZXNwb25zZUNvbnRlbnRQYXJ0RG9uZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IHBhcnQgdGhhdCBpcyBkb25lLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBQYXJ0IHtcbiAgICAvKipcbiAgICAgKiBCYXNlNjQtZW5jb2RlZCBhdWRpbyBkYXRhIChpZiB0eXBlIGlzIFwiYXVkaW9cIikuXG4gICAgICovXG4gICAgYXVkaW8/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCBjb250ZW50IChpZiB0eXBlIGlzIFwidGV4dFwiKS5cbiAgICAgKi9cbiAgICB0ZXh0Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zY3JpcHQgb2YgdGhlIGF1ZGlvIChpZiB0eXBlIGlzIFwiYXVkaW9cIikuXG4gICAgICovXG4gICAgdHJhbnNjcmlwdD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZW50IHR5cGUgKFwidGV4dFwiLCBcImF1ZGlvXCIpLlxuICAgICAqL1xuICAgIHR5cGU/OiAndGV4dCcgfCAnYXVkaW8nO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBldmVudCBpbnN0cnVjdHMgdGhlIHNlcnZlciB0byBjcmVhdGUgYSBSZXNwb25zZSwgd2hpY2ggbWVhbnMgdHJpZ2dlcmluZ1xuICogbW9kZWwgaW5mZXJlbmNlLiBXaGVuIGluIFNlcnZlciBWQUQgbW9kZSwgdGhlIHNlcnZlciB3aWxsIGNyZWF0ZSBSZXNwb25zZXNcbiAqIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogQSBSZXNwb25zZSB3aWxsIGluY2x1ZGUgYXQgbGVhc3Qgb25lIEl0ZW0sIGFuZCBtYXkgaGF2ZSB0d28sIGluIHdoaWNoIGNhc2UgdGhlXG4gKiBzZWNvbmQgd2lsbCBiZSBhIGZ1bmN0aW9uIGNhbGwuIFRoZXNlIEl0ZW1zIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIGNvbnZlcnNhdGlvblxuICogaGlzdG9yeS5cbiAqXG4gKiBUaGUgc2VydmVyIHdpbGwgcmVzcG9uZCB3aXRoIGEgYHJlc3BvbnNlLmNyZWF0ZWRgIGV2ZW50LCBldmVudHMgZm9yIEl0ZW1zIGFuZFxuICogY29udGVudCBjcmVhdGVkLCBhbmQgZmluYWxseSBhIGByZXNwb25zZS5kb25lYCBldmVudCB0byBpbmRpY2F0ZSB0aGUgUmVzcG9uc2UgaXNcbiAqIGNvbXBsZXRlLlxuICpcbiAqIFRoZSBgcmVzcG9uc2UuY3JlYXRlYCBldmVudCBpbmNsdWRlcyBpbmZlcmVuY2UgY29uZmlndXJhdGlvbiBsaWtlXG4gKiBgaW5zdHJ1Y3Rpb25zYCwgYW5kIGB0ZW1wZXJhdHVyZWAuIFRoZXNlIGZpZWxkcyB3aWxsIG92ZXJyaWRlIHRoZSBTZXNzaW9uJ3NcbiAqIGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgUmVzcG9uc2Ugb25seS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUNyZWF0ZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5jcmVhdGVgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLmNyZWF0ZSc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGNsaWVudC1nZW5lcmF0ZWQgSUQgdXNlZCB0byBpZGVudGlmeSB0aGlzIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSZWFsdGltZSByZXNwb25zZSB3aXRoIHRoZXNlIHBhcmFtZXRlcnNcbiAgICovXG4gIHJlc3BvbnNlPzogUmVzcG9uc2VDcmVhdGVFdmVudC5SZXNwb25zZTtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSZXNwb25zZUNyZWF0ZUV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSZWFsdGltZSByZXNwb25zZSB3aXRoIHRoZXNlIHBhcmFtZXRlcnNcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2Uge1xuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIHdoaWNoIGNvbnZlcnNhdGlvbiB0aGUgcmVzcG9uc2UgaXMgYWRkZWQgdG8uIEN1cnJlbnRseSBzdXBwb3J0cyBgYXV0b2BcbiAgICAgKiBhbmQgYG5vbmVgLCB3aXRoIGBhdXRvYCBhcyB0aGUgZGVmYXVsdCB2YWx1ZS4gVGhlIGBhdXRvYCB2YWx1ZSBtZWFucyB0aGF0IHRoZVxuICAgICAqIGNvbnRlbnRzIG9mIHRoZSByZXNwb25zZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBkZWZhdWx0IGNvbnZlcnNhdGlvbi4gU2V0IHRoaXMgdG9cbiAgICAgKiBgbm9uZWAgdG8gY3JlYXRlIGFuIG91dC1vZi1iYW5kIHJlc3BvbnNlIHdoaWNoIHdpbGwgbm90IGFkZCBpdGVtcyB0byBkZWZhdWx0XG4gICAgICogY29udmVyc2F0aW9uLlxuICAgICAqL1xuICAgIGNvbnZlcnNhdGlvbj86IChzdHJpbmcgJiB7fSkgfCAnYXV0bycgfCAnbm9uZSc7XG5cbiAgICAvKipcbiAgICAgKiBJbnB1dCBpdGVtcyB0byBpbmNsdWRlIGluIHRoZSBwcm9tcHQgZm9yIHRoZSBtb2RlbC4gQ3JlYXRlcyBhIG5ldyBjb250ZXh0IGZvclxuICAgICAqIHRoaXMgcmVzcG9uc2UsIHdpdGhvdXQgaW5jbHVkaW5nIHRoZSBkZWZhdWx0IGNvbnZlcnNhdGlvbi4gQ2FuIGluY2x1ZGVcbiAgICAgKiByZWZlcmVuY2VzIHRvIGl0ZW1zIGZyb20gdGhlIGRlZmF1bHQgY29udmVyc2F0aW9uLlxuICAgICAqL1xuICAgIGlucHV0PzogQXJyYXk8UmVhbHRpbWVBUEkuQ29udmVyc2F0aW9uSXRlbT47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBzeXN0ZW0gaW5zdHJ1Y3Rpb25zIChpLmUuIHN5c3RlbSBtZXNzYWdlKSBwcmVwZW5kZWQgdG8gbW9kZWwgY2FsbHMuXG4gICAgICogVGhpcyBmaWVsZCBhbGxvd3MgdGhlIGNsaWVudCB0byBndWlkZSB0aGUgbW9kZWwgb24gZGVzaXJlZCByZXNwb25zZXMuIFRoZSBtb2RlbFxuICAgICAqIGNhbiBiZSBpbnN0cnVjdGVkIG9uIHJlc3BvbnNlIGNvbnRlbnQgYW5kIGZvcm1hdCwgKGUuZy4gXCJiZSBleHRyZW1lbHkgc3VjY2luY3RcIixcbiAgICAgKiBcImFjdCBmcmllbmRseVwiLCBcImhlcmUgYXJlIGV4YW1wbGVzIG9mIGdvb2QgcmVzcG9uc2VzXCIpIGFuZCBvbiBhdWRpbyBiZWhhdmlvclxuICAgICAqIChlLmcuIFwidGFsayBxdWlja2x5XCIsIFwiaW5qZWN0IGVtb3Rpb24gaW50byB5b3VyIHZvaWNlXCIsIFwibGF1Z2ggZnJlcXVlbnRseVwiKS4gVGhlXG4gICAgICogaW5zdHJ1Y3Rpb25zIGFyZSBub3QgZ3VhcmFudGVlZCB0byBiZSBmb2xsb3dlZCBieSB0aGUgbW9kZWwsIGJ1dCB0aGV5IHByb3ZpZGVcbiAgICAgKiBndWlkYW5jZSB0byB0aGUgbW9kZWwgb24gdGhlIGRlc2lyZWQgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIHNlcnZlciBzZXRzIGRlZmF1bHQgaW5zdHJ1Y3Rpb25zIHdoaWNoIHdpbGwgYmUgdXNlZCBpZiB0aGlzIGZpZWxkXG4gICAgICogaXMgbm90IHNldCBhbmQgYXJlIHZpc2libGUgaW4gdGhlIGBzZXNzaW9uLmNyZWF0ZWRgIGV2ZW50IGF0IHRoZSBzdGFydCBvZiB0aGVcbiAgICAgKiBzZXNzaW9uLlxuICAgICAqL1xuICAgIGluc3RydWN0aW9ucz86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIE1heGltdW0gbnVtYmVyIG9mIG91dHB1dCB0b2tlbnMgZm9yIGEgc2luZ2xlIGFzc2lzdGFudCByZXNwb25zZSwgaW5jbHVzaXZlIG9mXG4gICAgICogdG9vbCBjYWxscy4gUHJvdmlkZSBhbiBpbnRlZ2VyIGJldHdlZW4gMSBhbmQgNDA5NiB0byBsaW1pdCBvdXRwdXQgdG9rZW5zLCBvclxuICAgICAqIGBpbmZgIGZvciB0aGUgbWF4aW11bSBhdmFpbGFibGUgdG9rZW5zIGZvciBhIGdpdmVuIG1vZGVsLiBEZWZhdWx0cyB0byBgaW5mYC5cbiAgICAgKi9cbiAgICBtYXhfcmVzcG9uc2Vfb3V0cHV0X3Rva2Vucz86IG51bWJlciB8ICdpbmYnO1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpbXVtIG9mIDUxMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgKi9cbiAgICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNldCBvZiBtb2RhbGl0aWVzIHRoZSBtb2RlbCBjYW4gcmVzcG9uZCB3aXRoLiBUbyBkaXNhYmxlIGF1ZGlvLCBzZXQgdGhpcyB0b1xuICAgICAqIFtcInRleHRcIl0uXG4gICAgICovXG4gICAgbW9kYWxpdGllcz86IEFycmF5PCd0ZXh0JyB8ICdhdWRpbyc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcm1hdCBvZiBvdXRwdXQgYXVkaW8uIE9wdGlvbnMgYXJlIGBwY20xNmAsIGBnNzExX3VsYXdgLCBvciBgZzcxMV9hbGF3YC5cbiAgICAgKi9cbiAgICBvdXRwdXRfYXVkaW9fZm9ybWF0PzogJ3BjbTE2JyB8ICdnNzExX3VsYXcnIHwgJ2c3MTFfYWxhdyc7XG5cbiAgICAvKipcbiAgICAgKiBTYW1wbGluZyB0ZW1wZXJhdHVyZSBmb3IgdGhlIG1vZGVsLCBsaW1pdGVkIHRvIFswLjYsIDEuMl0uIERlZmF1bHRzIHRvIDAuOC5cbiAgICAgKi9cbiAgICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEhvdyB0aGUgbW9kZWwgY2hvb3NlcyB0b29scy4gT3B0aW9ucyBhcmUgYGF1dG9gLCBgbm9uZWAsIGByZXF1aXJlZGAsIG9yIHNwZWNpZnlcbiAgICAgKiBhIGZ1bmN0aW9uLCBsaWtlIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YC5cbiAgICAgKi9cbiAgICB0b29sX2Nob2ljZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRvb2xzIChmdW5jdGlvbnMpIGF2YWlsYWJsZSB0byB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgdG9vbHM/OiBBcnJheTxSZXNwb25zZS5Ub29sPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2b2ljZSB0aGUgbW9kZWwgdXNlcyB0byByZXNwb25kLiBWb2ljZSBjYW5ub3QgYmUgY2hhbmdlZCBkdXJpbmcgdGhlIHNlc3Npb25cbiAgICAgKiBvbmNlIHRoZSBtb2RlbCBoYXMgcmVzcG9uZGVkIHdpdGggYXVkaW8gYXQgbGVhc3Qgb25jZS4gQ3VycmVudCB2b2ljZSBvcHRpb25zIGFyZVxuICAgICAqIGBhbGxveWAsIGBhc2hgLCBgYmFsbGFkYCwgYGNvcmFsYCwgYGVjaG9gIGBzYWdlYCwgYHNoaW1tZXJgIGFuZCBgdmVyc2VgLlxuICAgICAqL1xuICAgIHZvaWNlPzogJ2FsbG95JyB8ICdhc2gnIHwgJ2JhbGxhZCcgfCAnY29yYWwnIHwgJ2VjaG8nIHwgJ3NhZ2UnIHwgJ3NoaW1tZXInIHwgJ3ZlcnNlJztcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgUmVzcG9uc2Uge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgVG9vbCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgZnVuY3Rpb24sIGluY2x1ZGluZyBndWlkYW5jZSBvbiB3aGVuIGFuZCBob3cgdG8gY2FsbCBpdCxcbiAgICAgICAqIGFuZCBndWlkYW5jZSBhYm91dCB3aGF0IHRvIHRlbGwgdGhlIHVzZXIgd2hlbiBjYWxsaW5nIChpZiBhbnl0aGluZykuXG4gICAgICAgKi9cbiAgICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgICAqL1xuICAgICAgbmFtZT86IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBQYXJhbWV0ZXJzIG9mIHRoZSBmdW5jdGlvbiBpbiBKU09OIFNjaGVtYS5cbiAgICAgICAqL1xuICAgICAgcGFyYW1ldGVycz86IHVua25vd247XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wsIGkuZS4gYGZ1bmN0aW9uYC5cbiAgICAgICAqL1xuICAgICAgdHlwZT86ICdmdW5jdGlvbic7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhIG5ldyBSZXNwb25zZSBpcyBjcmVhdGVkLiBUaGUgZmlyc3QgZXZlbnQgb2YgcmVzcG9uc2UgY3JlYXRpb24sXG4gKiB3aGVyZSB0aGUgcmVzcG9uc2UgaXMgaW4gYW4gaW5pdGlhbCBzdGF0ZSBvZiBgaW5fcHJvZ3Jlc3NgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQ3JlYXRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSByZXNwb25zZSByZXNvdXJjZS5cbiAgICovXG4gIHJlc3BvbnNlOiBSZWFsdGltZVJlc3BvbnNlO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UuY3JlYXRlZGAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UuY3JlYXRlZCc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhIFJlc3BvbnNlIGlzIGRvbmUgc3RyZWFtaW5nLiBBbHdheXMgZW1pdHRlZCwgbm8gbWF0dGVyIHRoZSBmaW5hbFxuICogc3RhdGUuIFRoZSBSZXNwb25zZSBvYmplY3QgaW5jbHVkZWQgaW4gdGhlIGByZXNwb25zZS5kb25lYCBldmVudCB3aWxsIGluY2x1ZGVcbiAqIGFsbCBvdXRwdXQgSXRlbXMgaW4gdGhlIFJlc3BvbnNlIGJ1dCB3aWxsIG9taXQgdGhlIHJhdyBhdWRpbyBkYXRhLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlRG9uZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSByZXNwb25zZSByZXNvdXJjZS5cbiAgICovXG4gIHJlc3BvbnNlOiBSZWFsdGltZVJlc3BvbnNlO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UuZG9uZWAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UuZG9uZSc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiB0aGUgbW9kZWwtZ2VuZXJhdGVkIGZ1bmN0aW9uIGNhbGwgYXJndW1lbnRzIGFyZSB1cGRhdGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlRnVuY3Rpb25DYWxsQXJndW1lbnRzRGVsdGFFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwuXG4gICAqL1xuICBjYWxsX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBhcmd1bWVudHMgZGVsdGEgYXMgYSBKU09OIHN0cmluZy5cbiAgICovXG4gIGRlbHRhOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgZnVuY3Rpb24gY2FsbCBpdGVtLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSByZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLmZ1bmN0aW9uX2NhbGxfYXJndW1lbnRzLmRlbHRhYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5mdW5jdGlvbl9jYWxsX2FyZ3VtZW50cy5kZWx0YSc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiB0aGUgbW9kZWwtZ2VuZXJhdGVkIGZ1bmN0aW9uIGNhbGwgYXJndW1lbnRzIGFyZSBkb25lIHN0cmVhbWluZy5cbiAqIEFsc28gZW1pdHRlZCB3aGVuIGEgUmVzcG9uc2UgaXMgaW50ZXJydXB0ZWQsIGluY29tcGxldGUsIG9yIGNhbmNlbGxlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUZ1bmN0aW9uQ2FsbEFyZ3VtZW50c0RvbmVFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgZmluYWwgYXJndW1lbnRzIGFzIGEgSlNPTiBzdHJpbmcuXG4gICAqL1xuICBhcmd1bWVudHM6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBmdW5jdGlvbiBjYWxsLlxuICAgKi9cbiAgY2FsbF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwgaXRlbS5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaXRlbSBpbiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSByZXNwb25zZS5cbiAgICovXG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5mdW5jdGlvbl9jYWxsX2FyZ3VtZW50cy5kb25lYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5mdW5jdGlvbl9jYWxsX2FyZ3VtZW50cy5kb25lJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGEgbmV3IEl0ZW0gaXMgY3JlYXRlZCBkdXJpbmcgUmVzcG9uc2UgZ2VuZXJhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZU91dHB1dEl0ZW1BZGRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpdGVtIHRvIGFkZCB0byB0aGUgY29udmVyc2F0aW9uLlxuICAgKi9cbiAgaXRlbTogQ29udmVyc2F0aW9uSXRlbTtcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaXRlbSBpbiB0aGUgUmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBSZXNwb25zZSB0byB3aGljaCB0aGUgaXRlbSBiZWxvbmdzLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLm91dHB1dF9pdGVtLmFkZGVkYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5vdXRwdXRfaXRlbS5hZGRlZCc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhbiBJdGVtIGlzIGRvbmUgc3RyZWFtaW5nLiBBbHNvIGVtaXR0ZWQgd2hlbiBhIFJlc3BvbnNlIGlzXG4gKiBpbnRlcnJ1cHRlZCwgaW5jb21wbGV0ZSwgb3IgY2FuY2VsbGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlT3V0cHV0SXRlbURvbmVFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICovXG4gIGl0ZW06IENvbnZlcnNhdGlvbkl0ZW07XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGl0ZW0gaW4gdGhlIFJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgUmVzcG9uc2UgdG8gd2hpY2ggdGhlIGl0ZW0gYmVsb25ncy5cbiAgICovXG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5vdXRwdXRfaXRlbS5kb25lYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5vdXRwdXRfaXRlbS5kb25lJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIHRoZSB0ZXh0IHZhbHVlIG9mIGEgXCJ0ZXh0XCIgY29udGVudCBwYXJ0IGlzIHVwZGF0ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VUZXh0RGVsdGFFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCBpbiB0aGUgaXRlbSdzIGNvbnRlbnQgYXJyYXkuXG4gICAqL1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGRlbHRhLlxuICAgKi9cbiAgZGVsdGE6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBpdGVtLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSByZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLnRleHQuZGVsdGFgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLnRleHQuZGVsdGEnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gdGhlIHRleHQgdmFsdWUgb2YgYSBcInRleHRcIiBjb250ZW50IHBhcnQgaXMgZG9uZSBzdHJlYW1pbmcuIEFsc29cbiAqIGVtaXR0ZWQgd2hlbiBhIFJlc3BvbnNlIGlzIGludGVycnVwdGVkLCBpbmNvbXBsZXRlLCBvciBjYW5jZWxsZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VUZXh0RG9uZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGluIHRoZSBpdGVtJ3MgY29udGVudCBhcnJheS5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBpdGVtLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSByZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGZpbmFsIHRleHQgY29udGVudC5cbiAgICovXG4gIHRleHQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLnRleHQuZG9uZWAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UudGV4dC5kb25lJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGEgU2Vzc2lvbiBpcyBjcmVhdGVkLiBFbWl0dGVkIGF1dG9tYXRpY2FsbHkgd2hlbiBhIG5ldyBjb25uZWN0aW9uXG4gKiBpcyBlc3RhYmxpc2hlZCBhcyB0aGUgZmlyc3Qgc2VydmVyIGV2ZW50LiBUaGlzIGV2ZW50IHdpbGwgY29udGFpbiB0aGUgZGVmYXVsdFxuICogU2Vzc2lvbiBjb25maWd1cmF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlc3Npb25DcmVhdGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogUmVhbHRpbWUgc2Vzc2lvbiBvYmplY3QgY29uZmlndXJhdGlvbi5cbiAgICovXG4gIHNlc3Npb246IFNlc3Npb25zQVBJLlNlc3Npb247XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBzZXNzaW9uLmNyZWF0ZWRgLlxuICAgKi9cbiAgdHlwZTogJ3Nlc3Npb24uY3JlYXRlZCc7XG59XG5cbi8qKlxuICogU2VuZCB0aGlzIGV2ZW50IHRvIHVwZGF0ZSB0aGUgc2Vzc2lvblx1MjAxOXMgZGVmYXVsdCBjb25maWd1cmF0aW9uLiBUaGUgY2xpZW50IG1heVxuICogc2VuZCB0aGlzIGV2ZW50IGF0IGFueSB0aW1lIHRvIHVwZGF0ZSB0aGUgc2Vzc2lvbiBjb25maWd1cmF0aW9uLCBhbmQgYW55IGZpZWxkXG4gKiBtYXkgYmUgdXBkYXRlZCBhdCBhbnkgdGltZSwgZXhjZXB0IGZvciBcInZvaWNlXCIuIFRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kIHdpdGggYVxuICogYHNlc3Npb24udXBkYXRlZGAgZXZlbnQgdGhhdCBzaG93cyB0aGUgZnVsbCBlZmZlY3RpdmUgY29uZmlndXJhdGlvbi4gT25seSBmaWVsZHNcbiAqIHRoYXQgYXJlIHByZXNlbnQgYXJlIHVwZGF0ZWQsIHRodXMgdGhlIGNvcnJlY3Qgd2F5IHRvIGNsZWFyIGEgZmllbGQgbGlrZVxuICogXCJpbnN0cnVjdGlvbnNcIiBpcyB0byBwYXNzIGFuIGVtcHR5IHN0cmluZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uVXBkYXRlRXZlbnQge1xuICAvKipcbiAgICogUmVhbHRpbWUgc2Vzc2lvbiBvYmplY3QgY29uZmlndXJhdGlvbi5cbiAgICovXG4gIHNlc3Npb246IFNlc3Npb25VcGRhdGVFdmVudC5TZXNzaW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgc2Vzc2lvbi51cGRhdGVgLlxuICAgKi9cbiAgdHlwZTogJ3Nlc3Npb24udXBkYXRlJztcblxuICAvKipcbiAgICogT3B0aW9uYWwgY2xpZW50LWdlbmVyYXRlZCBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZD86IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBTZXNzaW9uVXBkYXRlRXZlbnQge1xuICAvKipcbiAgICogUmVhbHRpbWUgc2Vzc2lvbiBvYmplY3QgY29uZmlndXJhdGlvbi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIFJlYWx0aW1lIG1vZGVsIHVzZWQgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBtb2RlbDpcbiAgICAgIHwgJ2dwdC00by1yZWFsdGltZS1wcmV2aWV3J1xuICAgICAgfCAnZ3B0LTRvLXJlYWx0aW1lLXByZXZpZXctMjAyNC0xMC0wMSdcbiAgICAgIHwgJ2dwdC00by1yZWFsdGltZS1wcmV2aWV3LTIwMjQtMTItMTcnXG4gICAgICB8ICdncHQtNG8tbWluaS1yZWFsdGltZS1wcmV2aWV3J1xuICAgICAgfCAnZ3B0LTRvLW1pbmktcmVhbHRpbWUtcHJldmlldy0yMDI0LTEyLTE3JztcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb3JtYXQgb2YgaW5wdXQgYXVkaW8uIE9wdGlvbnMgYXJlIGBwY20xNmAsIGBnNzExX3VsYXdgLCBvciBgZzcxMV9hbGF3YC5cbiAgICAgKi9cbiAgICBpbnB1dF9hdWRpb19mb3JtYXQ/OiAncGNtMTYnIHwgJ2c3MTFfdWxhdycgfCAnZzcxMV9hbGF3JztcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24sIGRlZmF1bHRzIHRvIG9mZiBhbmQgY2FuIGJlIHNldCB0b1xuICAgICAqIGBudWxsYCB0byB0dXJuIG9mZiBvbmNlIG9uLiBJbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uIGlzIG5vdCBuYXRpdmUgdG8gdGhlXG4gICAgICogbW9kZWwsIHNpbmNlIHRoZSBtb2RlbCBjb25zdW1lcyBhdWRpbyBkaXJlY3RseS4gVHJhbnNjcmlwdGlvbiBydW5zXG4gICAgICogYXN5bmNocm9ub3VzbHkgdGhyb3VnaCBXaGlzcGVyIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyByb3VnaCBndWlkYW5jZSByYXRoZXJcbiAgICAgKiB0aGFuIHRoZSByZXByZXNlbnRhdGlvbiB1bmRlcnN0b29kIGJ5IHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBpbnB1dF9hdWRpb190cmFuc2NyaXB0aW9uPzogU2Vzc2lvbi5JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHN5c3RlbSBpbnN0cnVjdGlvbnMgKGkuZS4gc3lzdGVtIG1lc3NhZ2UpIHByZXBlbmRlZCB0byBtb2RlbCBjYWxscy5cbiAgICAgKiBUaGlzIGZpZWxkIGFsbG93cyB0aGUgY2xpZW50IHRvIGd1aWRlIHRoZSBtb2RlbCBvbiBkZXNpcmVkIHJlc3BvbnNlcy4gVGhlIG1vZGVsXG4gICAgICogY2FuIGJlIGluc3RydWN0ZWQgb24gcmVzcG9uc2UgY29udGVudCBhbmQgZm9ybWF0LCAoZS5nLiBcImJlIGV4dHJlbWVseSBzdWNjaW5jdFwiLFxuICAgICAqIFwiYWN0IGZyaWVuZGx5XCIsIFwiaGVyZSBhcmUgZXhhbXBsZXMgb2YgZ29vZCByZXNwb25zZXNcIikgYW5kIG9uIGF1ZGlvIGJlaGF2aW9yXG4gICAgICogKGUuZy4gXCJ0YWxrIHF1aWNrbHlcIiwgXCJpbmplY3QgZW1vdGlvbiBpbnRvIHlvdXIgdm9pY2VcIiwgXCJsYXVnaCBmcmVxdWVudGx5XCIpLiBUaGVcbiAgICAgKiBpbnN0cnVjdGlvbnMgYXJlIG5vdCBndWFyYW50ZWVkIHRvIGJlIGZvbGxvd2VkIGJ5IHRoZSBtb2RlbCwgYnV0IHRoZXkgcHJvdmlkZVxuICAgICAqIGd1aWRhbmNlIHRvIHRoZSBtb2RlbCBvbiB0aGUgZGVzaXJlZCBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGUgc2VydmVyIHNldHMgZGVmYXVsdCBpbnN0cnVjdGlvbnMgd2hpY2ggd2lsbCBiZSB1c2VkIGlmIHRoaXMgZmllbGRcbiAgICAgKiBpcyBub3Qgc2V0IGFuZCBhcmUgdmlzaWJsZSBpbiB0aGUgYHNlc3Npb24uY3JlYXRlZGAgZXZlbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAqIHNlc3Npb24uXG4gICAgICovXG4gICAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBudW1iZXIgb2Ygb3V0cHV0IHRva2VucyBmb3IgYSBzaW5nbGUgYXNzaXN0YW50IHJlc3BvbnNlLCBpbmNsdXNpdmUgb2ZcbiAgICAgKiB0b29sIGNhbGxzLiBQcm92aWRlIGFuIGludGVnZXIgYmV0d2VlbiAxIGFuZCA0MDk2IHRvIGxpbWl0IG91dHB1dCB0b2tlbnMsIG9yXG4gICAgICogYGluZmAgZm9yIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSB0b2tlbnMgZm9yIGEgZ2l2ZW4gbW9kZWwuIERlZmF1bHRzIHRvIGBpbmZgLlxuICAgICAqL1xuICAgIG1heF9yZXNwb25zZV9vdXRwdXRfdG9rZW5zPzogbnVtYmVyIHwgJ2luZic7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2V0IG9mIG1vZGFsaXRpZXMgdGhlIG1vZGVsIGNhbiByZXNwb25kIHdpdGguIFRvIGRpc2FibGUgYXVkaW8sIHNldCB0aGlzIHRvXG4gICAgICogW1widGV4dFwiXS5cbiAgICAgKi9cbiAgICBtb2RhbGl0aWVzPzogQXJyYXk8J3RleHQnIHwgJ2F1ZGlvJz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybWF0IG9mIG91dHB1dCBhdWRpby4gT3B0aW9ucyBhcmUgYHBjbTE2YCwgYGc3MTFfdWxhd2AsIG9yIGBnNzExX2FsYXdgLlxuICAgICAqL1xuICAgIG91dHB1dF9hdWRpb19mb3JtYXQ/OiAncGNtMTYnIHwgJ2c3MTFfdWxhdycgfCAnZzcxMV9hbGF3JztcblxuICAgIC8qKlxuICAgICAqIFNhbXBsaW5nIHRlbXBlcmF0dXJlIGZvciB0aGUgbW9kZWwsIGxpbWl0ZWQgdG8gWzAuNiwgMS4yXS4gRGVmYXVsdHMgdG8gMC44LlxuICAgICAqL1xuICAgIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogSG93IHRoZSBtb2RlbCBjaG9vc2VzIHRvb2xzLiBPcHRpb25zIGFyZSBgYXV0b2AsIGBub25lYCwgYHJlcXVpcmVkYCwgb3Igc3BlY2lmeVxuICAgICAqIGEgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdG9vbF9jaG9pY2U/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUb29scyAoZnVuY3Rpb25zKSBhdmFpbGFibGUgdG8gdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIHRvb2xzPzogQXJyYXk8U2Vzc2lvbi5Ub29sPjtcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIHR1cm4gZGV0ZWN0aW9uLiBDYW4gYmUgc2V0IHRvIGBudWxsYCB0byB0dXJuIG9mZi4gU2VydmVyIFZBRFxuICAgICAqIG1lYW5zIHRoYXQgdGhlIG1vZGVsIHdpbGwgZGV0ZWN0IHRoZSBzdGFydCBhbmQgZW5kIG9mIHNwZWVjaCBiYXNlZCBvbiBhdWRpb1xuICAgICAqIHZvbHVtZSBhbmQgcmVzcG9uZCBhdCB0aGUgZW5kIG9mIHVzZXIgc3BlZWNoLlxuICAgICAqL1xuICAgIHR1cm5fZGV0ZWN0aW9uPzogU2Vzc2lvbi5UdXJuRGV0ZWN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZvaWNlIHRoZSBtb2RlbCB1c2VzIHRvIHJlc3BvbmQuIFZvaWNlIGNhbm5vdCBiZSBjaGFuZ2VkIGR1cmluZyB0aGUgc2Vzc2lvblxuICAgICAqIG9uY2UgdGhlIG1vZGVsIGhhcyByZXNwb25kZWQgd2l0aCBhdWRpbyBhdCBsZWFzdCBvbmNlLiBDdXJyZW50IHZvaWNlIG9wdGlvbnMgYXJlXG4gICAgICogYGFsbG95YCwgYGFzaGAsIGBiYWxsYWRgLCBgY29yYWxgLCBgZWNob2AgYHNhZ2VgLCBgc2hpbW1lcmAgYW5kIGB2ZXJzZWAuXG4gICAgICovXG4gICAgdm9pY2U/OiAnYWxsb3knIHwgJ2FzaCcgfCAnYmFsbGFkJyB8ICdjb3JhbCcgfCAnZWNobycgfCAnc2FnZScgfCAnc2hpbW1lcicgfCAndmVyc2UnO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBTZXNzaW9uIHtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGZvciBpbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uLCBkZWZhdWx0cyB0byBvZmYgYW5kIGNhbiBiZSBzZXQgdG9cbiAgICAgKiBgbnVsbGAgdG8gdHVybiBvZmYgb25jZSBvbi4gSW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiBpcyBub3QgbmF0aXZlIHRvIHRoZVxuICAgICAqIG1vZGVsLCBzaW5jZSB0aGUgbW9kZWwgY29uc3VtZXMgYXVkaW8gZGlyZWN0bHkuIFRyYW5zY3JpcHRpb24gcnVuc1xuICAgICAqIGFzeW5jaHJvbm91c2x5IHRocm91Z2ggV2hpc3BlciBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgcm91Z2ggZ3VpZGFuY2UgcmF0aGVyXG4gICAgICogdGhhbiB0aGUgcmVwcmVzZW50YXRpb24gdW5kZXJzdG9vZCBieSB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtb2RlbCB0byB1c2UgZm9yIHRyYW5zY3JpcHRpb24sIGB3aGlzcGVyLTFgIGlzIHRoZSBvbmx5IGN1cnJlbnRseSBzdXBwb3J0ZWRcbiAgICAgICAqIG1vZGVsLlxuICAgICAgICovXG4gICAgICBtb2RlbD86IHN0cmluZztcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIFRvb2wge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGZ1bmN0aW9uLCBpbmNsdWRpbmcgZ3VpZGFuY2Ugb24gd2hlbiBhbmQgaG93IHRvIGNhbGwgaXQsXG4gICAgICAgKiBhbmQgZ3VpZGFuY2UgYWJvdXQgd2hhdCB0byB0ZWxsIHRoZSB1c2VyIHdoZW4gY2FsbGluZyAoaWYgYW55dGhpbmcpLlxuICAgICAgICovXG4gICAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICAgKi9cbiAgICAgIG5hbWU/OiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogUGFyYW1ldGVycyBvZiB0aGUgZnVuY3Rpb24gaW4gSlNPTiBTY2hlbWEuXG4gICAgICAgKi9cbiAgICAgIHBhcmFtZXRlcnM/OiB1bmtub3duO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSB0b29sLCBpLmUuIGBmdW5jdGlvbmAuXG4gICAgICAgKi9cbiAgICAgIHR5cGU/OiAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIHR1cm4gZGV0ZWN0aW9uLiBDYW4gYmUgc2V0IHRvIGBudWxsYCB0byB0dXJuIG9mZi4gU2VydmVyIFZBRFxuICAgICAqIG1lYW5zIHRoYXQgdGhlIG1vZGVsIHdpbGwgZGV0ZWN0IHRoZSBzdGFydCBhbmQgZW5kIG9mIHNwZWVjaCBiYXNlZCBvbiBhdWRpb1xuICAgICAqIHZvbHVtZSBhbmQgcmVzcG9uZCBhdCB0aGUgZW5kIG9mIHVzZXIgc3BlZWNoLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgVHVybkRldGVjdGlvbiB7XG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgYSByZXNwb25zZSB3aGVuIFZBRCBpcyBlbmFibGVkLiBgdHJ1ZWBcbiAgICAgICAqIGJ5IGRlZmF1bHQuXG4gICAgICAgKi9cbiAgICAgIGNyZWF0ZV9yZXNwb25zZT86IGJvb2xlYW47XG5cbiAgICAgIC8qKlxuICAgICAgICogQW1vdW50IG9mIGF1ZGlvIHRvIGluY2x1ZGUgYmVmb3JlIHRoZSBWQUQgZGV0ZWN0ZWQgc3BlZWNoIChpbiBtaWxsaXNlY29uZHMpLlxuICAgICAgICogRGVmYXVsdHMgdG8gMzAwbXMuXG4gICAgICAgKi9cbiAgICAgIHByZWZpeF9wYWRkaW5nX21zPzogbnVtYmVyO1xuXG4gICAgICAvKipcbiAgICAgICAqIER1cmF0aW9uIG9mIHNpbGVuY2UgdG8gZGV0ZWN0IHNwZWVjaCBzdG9wIChpbiBtaWxsaXNlY29uZHMpLiBEZWZhdWx0cyB0byA1MDBtcy5cbiAgICAgICAqIFdpdGggc2hvcnRlciB2YWx1ZXMgdGhlIG1vZGVsIHdpbGwgcmVzcG9uZCBtb3JlIHF1aWNrbHksIGJ1dCBtYXkganVtcCBpbiBvblxuICAgICAgICogc2hvcnQgcGF1c2VzIGZyb20gdGhlIHVzZXIuXG4gICAgICAgKi9cbiAgICAgIHNpbGVuY2VfZHVyYXRpb25fbXM/OiBudW1iZXI7XG5cbiAgICAgIC8qKlxuICAgICAgICogQWN0aXZhdGlvbiB0aHJlc2hvbGQgZm9yIFZBRCAoMC4wIHRvIDEuMCksIHRoaXMgZGVmYXVsdHMgdG8gMC41LiBBIGhpZ2hlclxuICAgICAgICogdGhyZXNob2xkIHdpbGwgcmVxdWlyZSBsb3VkZXIgYXVkaW8gdG8gYWN0aXZhdGUgdGhlIG1vZGVsLCBhbmQgdGh1cyBtaWdodFxuICAgICAgICogcGVyZm9ybSBiZXR0ZXIgaW4gbm9pc3kgZW52aXJvbm1lbnRzLlxuICAgICAgICovXG4gICAgICB0aHJlc2hvbGQ/OiBudW1iZXI7XG5cbiAgICAgIC8qKlxuICAgICAgICogVHlwZSBvZiB0dXJuIGRldGVjdGlvbiwgb25seSBgc2VydmVyX3ZhZGAgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cbiAgICAgICAqL1xuICAgICAgdHlwZT86IHN0cmluZztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGEgc2Vzc2lvbiBpcyB1cGRhdGVkIHdpdGggYSBgc2Vzc2lvbi51cGRhdGVgIGV2ZW50LCB1bmxlc3MgdGhlcmVcbiAqIGlzIGFuIGVycm9yLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlc3Npb25VcGRhdGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogUmVhbHRpbWUgc2Vzc2lvbiBvYmplY3QgY29uZmlndXJhdGlvbi5cbiAgICovXG4gIHNlc3Npb246IFNlc3Npb25zQVBJLlNlc3Npb247XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBzZXNzaW9uLnVwZGF0ZWRgLlxuICAgKi9cbiAgdHlwZTogJ3Nlc3Npb24udXBkYXRlZCc7XG59XG5cblJlYWx0aW1lLlNlc3Npb25zID0gU2Vzc2lvbnM7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBSZWFsdGltZSB7XG4gIGV4cG9ydCB7XG4gICAgU2Vzc2lvbnMgYXMgU2Vzc2lvbnMsXG4gICAgdHlwZSBTZXNzaW9uc0FQSVNlc3Npb24gYXMgU2Vzc2lvbixcbiAgICB0eXBlIFNlc3Npb25DcmVhdGVSZXNwb25zZSBhcyBTZXNzaW9uQ3JlYXRlUmVzcG9uc2UsXG4gICAgdHlwZSBTZXNzaW9uQ3JlYXRlUGFyYW1zIGFzIFNlc3Npb25DcmVhdGVQYXJhbXMsXG4gIH07XG59XG4iLCAiaW1wb3J0IHtcbiAgVGV4dENvbnRlbnRCbG9jayxcbiAgSW1hZ2VGaWxlQ29udGVudEJsb2NrLFxuICBNZXNzYWdlLFxuICBNZXNzYWdlQ29udGVudERlbHRhLFxuICBUZXh0LFxuICBJbWFnZUZpbGUsXG4gIFRleHREZWx0YSxcbiAgTWVzc2FnZURlbHRhLFxuICBNZXNzYWdlQ29udGVudCxcbn0gZnJvbSAnLi4vcmVzb3VyY2VzL2JldGEvdGhyZWFkcy9tZXNzYWdlcyc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0IHsgUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7XG4gIFJ1bixcbiAgUnVuQ3JlYXRlUGFyYW1zQmFzZSxcbiAgUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICBSdW5zLFxuICBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc0Jhc2UsXG4gIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtaW5nLFxufSBmcm9tICcuLi9yZXNvdXJjZXMvYmV0YS90aHJlYWRzL3J1bnMvcnVucyc7XG5pbXBvcnQgeyB0eXBlIFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vX3NoaW1zL2luZGV4JztcbmltcG9ydCB7IFN0cmVhbSB9IGZyb20gJy4uL3N0cmVhbWluZyc7XG5pbXBvcnQgeyBBUElVc2VyQWJvcnRFcnJvciwgT3BlbkFJRXJyb3IgfSBmcm9tICcuLi9lcnJvcic7XG5pbXBvcnQge1xuICBBc3Npc3RhbnRTdHJlYW1FdmVudCxcbiAgTWVzc2FnZVN0cmVhbUV2ZW50LFxuICBSdW5TdGVwU3RyZWFtRXZlbnQsXG4gIFJ1blN0cmVhbUV2ZW50LFxufSBmcm9tICcuLi9yZXNvdXJjZXMvYmV0YS9hc3Npc3RhbnRzJztcbmltcG9ydCB7IFJ1blN0ZXAsIFJ1blN0ZXBEZWx0YSwgVG9vbENhbGwsIFRvb2xDYWxsRGVsdGEgfSBmcm9tICcuLi9yZXNvdXJjZXMvYmV0YS90aHJlYWRzL3J1bnMvc3RlcHMnO1xuaW1wb3J0IHsgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zQmFzZSwgVGhyZWFkcyB9IGZyb20gJy4uL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvdGhyZWFkcyc7XG5pbXBvcnQgeyBCYXNlRXZlbnRzLCBFdmVudFN0cmVhbSB9IGZyb20gJy4vRXZlbnRTdHJlYW0nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFzc2lzdGFudFN0cmVhbUV2ZW50cyBleHRlbmRzIEJhc2VFdmVudHMge1xuICBydW46IChydW46IFJ1bikgPT4gdm9pZDtcblxuICAvL05ldyBldmVudCBzdHJ1Y3R1cmVcbiAgbWVzc2FnZUNyZWF0ZWQ6IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB2b2lkO1xuICBtZXNzYWdlRGVsdGE6IChtZXNzYWdlOiBNZXNzYWdlRGVsdGEsIHNuYXBzaG90OiBNZXNzYWdlKSA9PiB2b2lkO1xuICBtZXNzYWdlRG9uZTogKG1lc3NhZ2U6IE1lc3NhZ2UpID0+IHZvaWQ7XG5cbiAgcnVuU3RlcENyZWF0ZWQ6IChydW5TdGVwOiBSdW5TdGVwKSA9PiB2b2lkO1xuICBydW5TdGVwRGVsdGE6IChkZWx0YTogUnVuU3RlcERlbHRhLCBzbmFwc2hvdDogUnVucy5SdW5TdGVwKSA9PiB2b2lkO1xuICBydW5TdGVwRG9uZTogKHJ1blN0ZXA6IFJ1bnMuUnVuU3RlcCwgc25hcHNob3Q6IFJ1bnMuUnVuU3RlcCkgPT4gdm9pZDtcblxuICB0b29sQ2FsbENyZWF0ZWQ6ICh0b29sQ2FsbDogVG9vbENhbGwpID0+IHZvaWQ7XG4gIHRvb2xDYWxsRGVsdGE6IChkZWx0YTogVG9vbENhbGxEZWx0YSwgc25hcHNob3Q6IFRvb2xDYWxsKSA9PiB2b2lkO1xuICB0b29sQ2FsbERvbmU6ICh0b29sQ2FsbDogVG9vbENhbGwpID0+IHZvaWQ7XG5cbiAgdGV4dENyZWF0ZWQ6IChjb250ZW50OiBUZXh0KSA9PiB2b2lkO1xuICB0ZXh0RGVsdGE6IChkZWx0YTogVGV4dERlbHRhLCBzbmFwc2hvdDogVGV4dCkgPT4gdm9pZDtcbiAgdGV4dERvbmU6IChjb250ZW50OiBUZXh0LCBzbmFwc2hvdDogTWVzc2FnZSkgPT4gdm9pZDtcblxuICAvL05vIGNyZWF0ZWQgb3IgZGVsdGEgYXMgdGhpcyBpcyBub3Qgc3RyZWFtZWRcbiAgaW1hZ2VGaWxlRG9uZTogKGNvbnRlbnQ6IEltYWdlRmlsZSwgc25hcHNob3Q6IE1lc3NhZ2UpID0+IHZvaWQ7XG5cbiAgZXZlbnQ6IChldmVudDogQXNzaXN0YW50U3RyZWFtRXZlbnQpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc0Jhc2VTdHJlYW0gPSBPbWl0PFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc0Jhc2UsICdzdHJlYW0nPiAmIHtcbiAgc3RyZWFtPzogdHJ1ZTtcbn07XG5cbmV4cG9ydCB0eXBlIFJ1bkNyZWF0ZVBhcmFtc0Jhc2VTdHJlYW0gPSBPbWl0PFJ1bkNyZWF0ZVBhcmFtc0Jhc2UsICdzdHJlYW0nPiAmIHtcbiAgc3RyZWFtPzogdHJ1ZTtcbn07XG5cbmV4cG9ydCB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtID0gT21pdDxSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc0Jhc2UsICdzdHJlYW0nPiAmIHtcbiAgc3RyZWFtPzogdHJ1ZTtcbn07XG5cbmV4cG9ydCBjbGFzcyBBc3Npc3RhbnRTdHJlYW1cbiAgZXh0ZW5kcyBFdmVudFN0cmVhbTxBc3Npc3RhbnRTdHJlYW1FdmVudHM+XG4gIGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZTxBc3Npc3RhbnRTdHJlYW1FdmVudD5cbntcbiAgLy9UcmFjayBhbGwgZXZlbnRzIGluIGEgc2luZ2xlIGxpc3QgZm9yIHJlZmVyZW5jZVxuICAjZXZlbnRzOiBBc3Npc3RhbnRTdHJlYW1FdmVudFtdID0gW107XG5cbiAgLy9Vc2VkIHRvIGFjY3VtdWxhdGUgZGVsdGFzXG4gIC8vV2UgYXJlIGFjY3VtdWxhdGluZyBtYW55IHR5cGVzIHNvIHRoZSB2YWx1ZSBoZXJlIGlzIG5vdCBzdHJpY3RcbiAgI3J1blN0ZXBTbmFwc2hvdHM6IHsgW2lkOiBzdHJpbmddOiBSdW5zLlJ1blN0ZXAgfSA9IHt9O1xuICAjbWVzc2FnZVNuYXBzaG90czogeyBbaWQ6IHN0cmluZ106IE1lc3NhZ2UgfSA9IHt9O1xuICAjbWVzc2FnZVNuYXBzaG90OiBNZXNzYWdlIHwgdW5kZWZpbmVkO1xuICAjZmluYWxSdW46IFJ1biB8IHVuZGVmaW5lZDtcbiAgI2N1cnJlbnRDb250ZW50SW5kZXg6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgI2N1cnJlbnRDb250ZW50OiBNZXNzYWdlQ29udGVudCB8IHVuZGVmaW5lZDtcbiAgI2N1cnJlbnRUb29sQ2FsbEluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICNjdXJyZW50VG9vbENhbGw6IFRvb2xDYWxsIHwgdW5kZWZpbmVkO1xuXG4gIC8vRm9yIGN1cnJlbnQgc25hcHNob3QgbWV0aG9kc1xuICAjY3VycmVudEV2ZW50OiBBc3Npc3RhbnRTdHJlYW1FdmVudCB8IHVuZGVmaW5lZDtcbiAgI2N1cnJlbnRSdW5TbmFwc2hvdDogUnVuIHwgdW5kZWZpbmVkO1xuICAjY3VycmVudFJ1blN0ZXBTbmFwc2hvdDogUnVucy5SdW5TdGVwIHwgdW5kZWZpbmVkO1xuXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTogQXN5bmNJdGVyYXRvcjxBc3Npc3RhbnRTdHJlYW1FdmVudD4ge1xuICAgIGNvbnN0IHB1c2hRdWV1ZTogQXNzaXN0YW50U3RyZWFtRXZlbnRbXSA9IFtdO1xuICAgIGNvbnN0IHJlYWRRdWV1ZToge1xuICAgICAgcmVzb2x2ZTogKGNodW5rOiBBc3Npc3RhbnRTdHJlYW1FdmVudCB8IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgICAgIHJlamVjdDogKGVycjogdW5rbm93bikgPT4gdm9pZDtcbiAgICB9W10gPSBbXTtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuXG4gICAgLy9DYXRjaCBhbGwgZm9yIHBhc3NpbmcgYWxvbmcgYWxsIGV2ZW50c1xuICAgIHRoaXMub24oJ2V2ZW50JywgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCByZWFkZXIgPSByZWFkUXVldWUuc2hpZnQoKTtcbiAgICAgIGlmIChyZWFkZXIpIHtcbiAgICAgICAgcmVhZGVyLnJlc29sdmUoZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaFF1ZXVlLnB1c2goZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5vbignZW5kJywgKCkgPT4ge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiByZWFkUXVldWUpIHtcbiAgICAgICAgcmVhZGVyLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIHJlYWRRdWV1ZS5sZW5ndGggPSAwO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbignYWJvcnQnLCAoZXJyKSA9PiB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHJlYWRRdWV1ZSkge1xuICAgICAgICByZWFkZXIucmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICB9KTtcblxuICAgIHRoaXMub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiByZWFkUXVldWUpIHtcbiAgICAgICAgcmVhZGVyLnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVhZFF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogYXN5bmMgKCk6IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8QXNzaXN0YW50U3RyZWFtRXZlbnQ+PiA9PiB7XG4gICAgICAgIGlmICghcHVzaFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxBc3Npc3RhbnRTdHJlYW1FdmVudCB8IHVuZGVmaW5lZD4oKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgICAgICAgIHJlYWRRdWV1ZS5wdXNoKHsgcmVzb2x2ZSwgcmVqZWN0IH0pLFxuICAgICAgICAgICkudGhlbigoY2h1bmspID0+IChjaHVuayA/IHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9IDogeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaHVuayA9IHB1c2hRdWV1ZS5zaGlmdCgpITtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9O1xuICAgICAgfSxcbiAgICAgIHJldHVybjogYXN5bmMgKCkgPT4ge1xuICAgICAgICB0aGlzLmFib3J0KCk7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSk6IEFzc2lzdGFudFN0cmVhbSB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IEFzc2lzdGFudFN0cmVhbSgpO1xuICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuICAgIHJldHVybiBydW5uZXI7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX2Zyb21SZWFkYWJsZVN0cmVhbShcbiAgICByZWFkYWJsZVN0cmVhbTogUmVhZGFibGVTdHJlYW0sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IFByb21pc2U8UnVuPiB7XG4gICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgIGlmIChzaWduYWwpIHtcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgfVxuICAgIHRoaXMuX2Nvbm5lY3RlZCgpO1xuICAgIGNvbnN0IHN0cmVhbSA9IFN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW08QXNzaXN0YW50U3RyZWFtRXZlbnQ+KHJlYWRhYmxlU3RyZWFtLCB0aGlzLmNvbnRyb2xsZXIpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2Ygc3RyZWFtKSB7XG4gICAgICB0aGlzLiNhZGRFdmVudChldmVudCk7XG4gICAgfVxuICAgIGlmIChzdHJlYW0uY29udHJvbGxlci5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkUnVuKHRoaXMuI2VuZFJlcXVlc3QoKSk7XG4gIH1cblxuICB0b1JlYWRhYmxlU3RyZWFtKCk6IFJlYWRhYmxlU3RyZWFtIHtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgU3RyZWFtKHRoaXNbU3ltYm9sLmFzeW5jSXRlcmF0b3JdLmJpbmQodGhpcyksIHRoaXMuY29udHJvbGxlcik7XG4gICAgcmV0dXJuIHN0cmVhbS50b1JlYWRhYmxlU3RyZWFtKCk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlVG9vbEFzc2lzdGFudFN0cmVhbShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgcnVuczogUnVucyxcbiAgICBwYXJhbXM6IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtLFxuICAgIG9wdGlvbnM6IFJlcXVlc3RPcHRpb25zIHwgdW5kZWZpbmVkLFxuICApOiBBc3Npc3RhbnRTdHJlYW0ge1xuICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBBc3Npc3RhbnRTdHJlYW0oKTtcbiAgICBydW5uZXIuX3J1bigoKSA9PlxuICAgICAgcnVubmVyLl9ydW5Ub29sQXNzaXN0YW50U3RyZWFtKHRocmVhZElkLCBydW5JZCwgcnVucywgcGFyYW1zLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAnc3RyZWFtJyB9LFxuICAgICAgfSksXG4gICAgKTtcbiAgICByZXR1cm4gcnVubmVyO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9jcmVhdGVUb29sQXNzaXN0YW50U3RyZWFtKFxuICAgIHJ1bjogUnVucyxcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgcGFyYW1zOiBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxSdW4+IHtcbiAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXMuY29udHJvbGxlci5hYm9ydCgpKTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5OiBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbWluZyA9IHsgLi4ucGFyYW1zLCBzdHJlYW06IHRydWUgfTtcbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBydW4uc3VibWl0VG9vbE91dHB1dHModGhyZWFkSWQsIHJ1bklkLCBib2R5LCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgc2lnbmFsOiB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLFxuICAgIH0pO1xuXG4gICAgdGhpcy5fY29ubmVjdGVkKCk7XG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGV2ZW50IG9mIHN0cmVhbSkge1xuICAgICAgdGhpcy4jYWRkRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLmNvbnRyb2xsZXIuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fYWRkUnVuKHRoaXMuI2VuZFJlcXVlc3QoKSk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlVGhyZWFkQXNzaXN0YW50U3RyZWFtKFxuICAgIHBhcmFtczogVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zQmFzZVN0cmVhbSxcbiAgICB0aHJlYWQ6IFRocmVhZHMsXG4gICAgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zLFxuICApOiBBc3Npc3RhbnRTdHJlYW0ge1xuICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBBc3Npc3RhbnRTdHJlYW0oKTtcbiAgICBydW5uZXIuX3J1bigoKSA9PlxuICAgICAgcnVubmVyLl90aHJlYWRBc3Npc3RhbnRTdHJlYW0ocGFyYW1zLCB0aHJlYWQsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtSGVscGVyLU1ldGhvZCc6ICdzdHJlYW0nIH0sXG4gICAgICB9KSxcbiAgICApO1xuICAgIHJldHVybiBydW5uZXI7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlQXNzaXN0YW50U3RyZWFtKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuczogUnVucyxcbiAgICBwYXJhbXM6IFJ1bkNyZWF0ZVBhcmFtc0Jhc2VTdHJlYW0sXG4gICAgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zLFxuICApOiBBc3Npc3RhbnRTdHJlYW0ge1xuICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBBc3Npc3RhbnRTdHJlYW0oKTtcbiAgICBydW5uZXIuX3J1bigoKSA9PlxuICAgICAgcnVubmVyLl9ydW5Bc3Npc3RhbnRTdHJlYW0odGhyZWFkSWQsIHJ1bnMsIHBhcmFtcywge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3N0cmVhbScgfSxcbiAgICAgIH0pLFxuICAgICk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxuXG4gIGN1cnJlbnRFdmVudCgpOiBBc3Npc3RhbnRTdHJlYW1FdmVudCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRFdmVudDtcbiAgfVxuXG4gIGN1cnJlbnRSdW4oKTogUnVuIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudFJ1blNuYXBzaG90O1xuICB9XG5cbiAgY3VycmVudE1lc3NhZ2VTbmFwc2hvdCgpOiBNZXNzYWdlIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy4jbWVzc2FnZVNuYXBzaG90O1xuICB9XG5cbiAgY3VycmVudFJ1blN0ZXBTbmFwc2hvdCgpOiBSdW5zLlJ1blN0ZXAgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50UnVuU3RlcFNuYXBzaG90O1xuICB9XG5cbiAgYXN5bmMgZmluYWxSdW5TdGVwcygpOiBQcm9taXNlPFJ1bnMuUnVuU3RlcFtdPiB7XG4gICAgYXdhaXQgdGhpcy5kb25lKCk7XG5cbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLiNydW5TdGVwU25hcHNob3RzKTtcbiAgfVxuXG4gIGFzeW5jIGZpbmFsTWVzc2FnZXMoKTogUHJvbWlzZTxNZXNzYWdlW10+IHtcbiAgICBhd2FpdCB0aGlzLmRvbmUoKTtcblxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuI21lc3NhZ2VTbmFwc2hvdHMpO1xuICB9XG5cbiAgYXN5bmMgZmluYWxSdW4oKTogUHJvbWlzZTxSdW4+IHtcbiAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICBpZiAoIXRoaXMuI2ZpbmFsUnVuKSB0aHJvdyBFcnJvcignRmluYWwgcnVuIHdhcyBub3QgcmVjZWl2ZWQuJyk7XG5cbiAgICByZXR1cm4gdGhpcy4jZmluYWxSdW47XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX2NyZWF0ZVRocmVhZEFzc2lzdGFudFN0cmVhbShcbiAgICB0aHJlYWQ6IFRocmVhZHMsXG4gICAgcGFyYW1zOiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBQcm9taXNlPFJ1bj4ge1xuICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbDtcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gdGhpcy5jb250cm9sbGVyLmFib3J0KCkpO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHk6IFJ1bkNyZWF0ZVBhcmFtc1N0cmVhbWluZyA9IHsgLi4ucGFyYW1zLCBzdHJlYW06IHRydWUgfTtcbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0aHJlYWQuY3JlYXRlQW5kUnVuKGJvZHksIHsgLi4ub3B0aW9ucywgc2lnbmFsOiB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsIH0pO1xuXG4gICAgdGhpcy5fY29ubmVjdGVkKCk7XG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGV2ZW50IG9mIHN0cmVhbSkge1xuICAgICAgdGhpcy4jYWRkRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLmNvbnRyb2xsZXIuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fYWRkUnVuKHRoaXMuI2VuZFJlcXVlc3QoKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX2NyZWF0ZUFzc2lzdGFudFN0cmVhbShcbiAgICBydW46IFJ1bnMsXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBwYXJhbXM6IFJ1bkNyZWF0ZVBhcmFtc0Jhc2UsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IFByb21pc2U8UnVuPiB7XG4gICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgIGlmIChzaWduYWwpIHtcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keTogUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nID0geyAuLi5wYXJhbXMsIHN0cmVhbTogdHJ1ZSB9O1xuICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHJ1bi5jcmVhdGUodGhyZWFkSWQsIGJvZHksIHsgLi4ub3B0aW9ucywgc2lnbmFsOiB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsIH0pO1xuXG4gICAgdGhpcy5fY29ubmVjdGVkKCk7XG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGV2ZW50IG9mIHN0cmVhbSkge1xuICAgICAgdGhpcy4jYWRkRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLmNvbnRyb2xsZXIuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fYWRkUnVuKHRoaXMuI2VuZFJlcXVlc3QoKSk7XG4gIH1cblxuICAjYWRkRXZlbnQoZXZlbnQ6IEFzc2lzdGFudFN0cmVhbUV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZW5kZWQpIHJldHVybjtcblxuICAgIHRoaXMuI2N1cnJlbnRFdmVudCA9IGV2ZW50O1xuXG4gICAgdGhpcy4jaGFuZGxlRXZlbnQoZXZlbnQpO1xuXG4gICAgc3dpdGNoIChldmVudC5ldmVudCkge1xuICAgICAgY2FzZSAndGhyZWFkLmNyZWF0ZWQnOlxuICAgICAgICAvL05vIGFjdGlvbiBvbiB0aGlzIGV2ZW50LlxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jcmVhdGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4ucXVldWVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uaW5fcHJvZ3Jlc3MnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5yZXF1aXJlc19hY3Rpb24nOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jb21wbGV0ZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5mYWlsZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jYW5jZWxsaW5nJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uY2FuY2VsbGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uZXhwaXJlZCc6XG4gICAgICAgIHRoaXMuI2hhbmRsZVJ1bihldmVudCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY3JlYXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuaW5fcHJvZ3Jlc3MnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmRlbHRhJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jb21wbGV0ZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmZhaWxlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY2FuY2VsbGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5leHBpcmVkJzpcbiAgICAgICAgdGhpcy4jaGFuZGxlUnVuU3RlcChldmVudCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5jcmVhdGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmluX3Byb2dyZXNzJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmRlbHRhJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmNvbXBsZXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5pbmNvbXBsZXRlJzpcbiAgICAgICAgdGhpcy4jaGFuZGxlTWVzc2FnZShldmVudCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIC8vVGhpcyBpcyBpbmNsdWRlZCBmb3IgY29tcGxldGVuZXNzLCBidXQgZXJyb3JzIGFyZSBwcm9jZXNzZWQgaW4gdGhlIFNTRSBldmVudCBwcm9jZXNzaW5nIHNvIHRoaXMgc2hvdWxkIG5vdCBvY2N1clxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0VuY291bnRlcmVkIGFuIGVycm9yIGV2ZW50IGluIGV2ZW50IHByb2Nlc3NpbmcgLSBlcnJvcnMgc2hvdWxkIGJlIHByb2Nlc3NlZCBlYXJsaWVyJyxcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAjZW5kUmVxdWVzdCgpOiBSdW4ge1xuICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYHN0cmVhbSBoYXMgZW5kZWQsIHRoaXMgc2hvdWxkbid0IGhhcHBlbmApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy4jZmluYWxSdW4pIHRocm93IEVycm9yKCdGaW5hbCBydW4gaGFzIG5vdCBiZWVuIHJlY2VpdmVkJyk7XG5cbiAgICByZXR1cm4gdGhpcy4jZmluYWxSdW47XG4gIH1cblxuICAjaGFuZGxlTWVzc2FnZSh0aGlzOiBBc3Npc3RhbnRTdHJlYW0sIGV2ZW50OiBNZXNzYWdlU3RyZWFtRXZlbnQpIHtcbiAgICBjb25zdCBbYWNjdW11bGF0ZWRNZXNzYWdlLCBuZXdDb250ZW50XSA9IHRoaXMuI2FjY3VtdWxhdGVNZXNzYWdlKGV2ZW50LCB0aGlzLiNtZXNzYWdlU25hcHNob3QpO1xuICAgIHRoaXMuI21lc3NhZ2VTbmFwc2hvdCA9IGFjY3VtdWxhdGVkTWVzc2FnZTtcbiAgICB0aGlzLiNtZXNzYWdlU25hcHNob3RzW2FjY3VtdWxhdGVkTWVzc2FnZS5pZF0gPSBhY2N1bXVsYXRlZE1lc3NhZ2U7XG5cbiAgICBmb3IgKGNvbnN0IGNvbnRlbnQgb2YgbmV3Q29udGVudCkge1xuICAgICAgY29uc3Qgc25hcHNob3RDb250ZW50ID0gYWNjdW11bGF0ZWRNZXNzYWdlLmNvbnRlbnRbY29udGVudC5pbmRleF07XG4gICAgICBpZiAoc25hcHNob3RDb250ZW50Py50eXBlID09ICd0ZXh0Jykge1xuICAgICAgICB0aGlzLl9lbWl0KCd0ZXh0Q3JlYXRlZCcsIHNuYXBzaG90Q29udGVudC50ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKGV2ZW50LmV2ZW50KSB7XG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5jcmVhdGVkJzpcbiAgICAgICAgdGhpcy5fZW1pdCgnbWVzc2FnZUNyZWF0ZWQnLCBldmVudC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmluX3Byb2dyZXNzJzpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmRlbHRhJzpcbiAgICAgICAgdGhpcy5fZW1pdCgnbWVzc2FnZURlbHRhJywgZXZlbnQuZGF0YS5kZWx0YSwgYWNjdW11bGF0ZWRNZXNzYWdlKTtcblxuICAgICAgICBpZiAoZXZlbnQuZGF0YS5kZWx0YS5jb250ZW50KSB7XG4gICAgICAgICAgZm9yIChjb25zdCBjb250ZW50IG9mIGV2ZW50LmRhdGEuZGVsdGEuY29udGVudCkge1xuICAgICAgICAgICAgLy9JZiBpdCBpcyB0ZXh0IGRlbHRhLCBlbWl0IGEgdGV4dCBkZWx0YSBldmVudFxuICAgICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PSAndGV4dCcgJiYgY29udGVudC50ZXh0KSB7XG4gICAgICAgICAgICAgIGxldCB0ZXh0RGVsdGEgPSBjb250ZW50LnRleHQ7XG4gICAgICAgICAgICAgIGxldCBzbmFwc2hvdCA9IGFjY3VtdWxhdGVkTWVzc2FnZS5jb250ZW50W2NvbnRlbnQuaW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgJiYgc25hcHNob3QudHlwZSA9PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCd0ZXh0RGVsdGEnLCB0ZXh0RGVsdGEsIHNuYXBzaG90LnRleHQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdUaGUgc25hcHNob3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGV4dCBkZWx0YSBpcyBub3QgdGV4dCBvciBtaXNzaW5nJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbnRlbnQuaW5kZXggIT0gdGhpcy4jY3VycmVudENvbnRlbnRJbmRleCkge1xuICAgICAgICAgICAgICAvL1NlZSBpZiB3ZSBoYXZlIGluIHByb2dyZXNzIGNvbnRlbnRcbiAgICAgICAgICAgICAgaWYgKHRoaXMuI2N1cnJlbnRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLiNjdXJyZW50Q29udGVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgndGV4dERvbmUnLCB0aGlzLiNjdXJyZW50Q29udGVudC50ZXh0LCB0aGlzLiNtZXNzYWdlU25hcHNob3QpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2ltYWdlX2ZpbGUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCdpbWFnZUZpbGVEb25lJywgdGhpcy4jY3VycmVudENvbnRlbnQuaW1hZ2VfZmlsZSwgdGhpcy4jbWVzc2FnZVNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy4jY3VycmVudENvbnRlbnRJbmRleCA9IGNvbnRlbnQuaW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuI2N1cnJlbnRDb250ZW50ID0gYWNjdW11bGF0ZWRNZXNzYWdlLmNvbnRlbnRbY29udGVudC5pbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmNvbXBsZXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5pbmNvbXBsZXRlJzpcbiAgICAgICAgLy9XZSBlbWl0IHRoZSBsYXRlc3QgY29udGVudCB3ZSB3ZXJlIHdvcmtpbmcgb24gb24gY29tcGxldGlvbiAoaW5jbHVkaW5nIGluY29tcGxldGUpXG4gICAgICAgIGlmICh0aGlzLiNjdXJyZW50Q29udGVudEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50Q29udGVudCA9IGV2ZW50LmRhdGEuY29udGVudFt0aGlzLiNjdXJyZW50Q29udGVudEluZGV4XTtcbiAgICAgICAgICBpZiAoY3VycmVudENvbnRlbnQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY3VycmVudENvbnRlbnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlICdpbWFnZV9maWxlJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCdpbWFnZUZpbGVEb25lJywgY3VycmVudENvbnRlbnQuaW1hZ2VfZmlsZSwgdGhpcy4jbWVzc2FnZVNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgndGV4dERvbmUnLCBjdXJyZW50Q29udGVudC50ZXh0LCB0aGlzLiNtZXNzYWdlU25hcHNob3QpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLiNtZXNzYWdlU25hcHNob3QpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0KCdtZXNzYWdlRG9uZScsIGV2ZW50LmRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4jbWVzc2FnZVNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gICNoYW5kbGVSdW5TdGVwKHRoaXM6IEFzc2lzdGFudFN0cmVhbSwgZXZlbnQ6IFJ1blN0ZXBTdHJlYW1FdmVudCkge1xuICAgIGNvbnN0IGFjY3VtdWxhdGVkUnVuU3RlcCA9IHRoaXMuI2FjY3VtdWxhdGVSdW5TdGVwKGV2ZW50KTtcbiAgICB0aGlzLiNjdXJyZW50UnVuU3RlcFNuYXBzaG90ID0gYWNjdW11bGF0ZWRSdW5TdGVwO1xuXG4gICAgc3dpdGNoIChldmVudC5ldmVudCkge1xuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmNyZWF0ZWQnOlxuICAgICAgICB0aGlzLl9lbWl0KCdydW5TdGVwQ3JlYXRlZCcsIGV2ZW50LmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5kZWx0YSc6XG4gICAgICAgIGNvbnN0IGRlbHRhID0gZXZlbnQuZGF0YS5kZWx0YTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGRlbHRhLnN0ZXBfZGV0YWlscyAmJlxuICAgICAgICAgIGRlbHRhLnN0ZXBfZGV0YWlscy50eXBlID09ICd0b29sX2NhbGxzJyAmJlxuICAgICAgICAgIGRlbHRhLnN0ZXBfZGV0YWlscy50b29sX2NhbGxzICYmXG4gICAgICAgICAgYWNjdW11bGF0ZWRSdW5TdGVwLnN0ZXBfZGV0YWlscy50eXBlID09ICd0b29sX2NhbGxzJ1xuICAgICAgICApIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIGRlbHRhLnN0ZXBfZGV0YWlscy50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICBpZiAodG9vbENhbGwuaW5kZXggPT0gdGhpcy4jY3VycmVudFRvb2xDYWxsSW5kZXgpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZW1pdChcbiAgICAgICAgICAgICAgICAndG9vbENhbGxEZWx0YScsXG4gICAgICAgICAgICAgICAgdG9vbENhbGwsXG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRSdW5TdGVwLnN0ZXBfZGV0YWlscy50b29sX2NhbGxzW3Rvb2xDYWxsLmluZGV4XSBhcyBUb29sQ2FsbCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLiNjdXJyZW50VG9vbENhbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCd0b29sQ2FsbERvbmUnLCB0aGlzLiNjdXJyZW50VG9vbENhbGwpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy4jY3VycmVudFRvb2xDYWxsSW5kZXggPSB0b29sQ2FsbC5pbmRleDtcbiAgICAgICAgICAgICAgdGhpcy4jY3VycmVudFRvb2xDYWxsID0gYWNjdW11bGF0ZWRSdW5TdGVwLnN0ZXBfZGV0YWlscy50b29sX2NhbGxzW3Rvb2xDYWxsLmluZGV4XTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuI2N1cnJlbnRUb29sQ2FsbCkgdGhpcy5fZW1pdCgndG9vbENhbGxDcmVhdGVkJywgdGhpcy4jY3VycmVudFRvb2xDYWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbWl0KCdydW5TdGVwRGVsdGEnLCBldmVudC5kYXRhLmRlbHRhLCBhY2N1bXVsYXRlZFJ1blN0ZXApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jb21wbGV0ZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmZhaWxlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY2FuY2VsbGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5leHBpcmVkJzpcbiAgICAgICAgdGhpcy4jY3VycmVudFJ1blN0ZXBTbmFwc2hvdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IGV2ZW50LmRhdGEuc3RlcF9kZXRhaWxzO1xuICAgICAgICBpZiAoZGV0YWlscy50eXBlID09ICd0b29sX2NhbGxzJykge1xuICAgICAgICAgIGlmICh0aGlzLiNjdXJyZW50VG9vbENhbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3Rvb2xDYWxsRG9uZScsIHRoaXMuI2N1cnJlbnRUb29sQ2FsbCBhcyBUb29sQ2FsbCk7XG4gICAgICAgICAgICB0aGlzLiNjdXJyZW50VG9vbENhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VtaXQoJ3J1blN0ZXBEb25lJywgZXZlbnQuZGF0YSwgYWNjdW11bGF0ZWRSdW5TdGVwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuaW5fcHJvZ3Jlc3MnOlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAjaGFuZGxlRXZlbnQodGhpczogQXNzaXN0YW50U3RyZWFtLCBldmVudDogQXNzaXN0YW50U3RyZWFtRXZlbnQpIHtcbiAgICB0aGlzLiNldmVudHMucHVzaChldmVudCk7XG4gICAgdGhpcy5fZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gIH1cblxuICAjYWNjdW11bGF0ZVJ1blN0ZXAoZXZlbnQ6IFJ1blN0ZXBTdHJlYW1FdmVudCk6IFJ1bnMuUnVuU3RlcCB7XG4gICAgc3dpdGNoIChldmVudC5ldmVudCkge1xuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmNyZWF0ZWQnOlxuICAgICAgICB0aGlzLiNydW5TdGVwU25hcHNob3RzW2V2ZW50LmRhdGEuaWRdID0gZXZlbnQuZGF0YTtcbiAgICAgICAgcmV0dXJuIGV2ZW50LmRhdGE7XG5cbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5kZWx0YSc6XG4gICAgICAgIGxldCBzbmFwc2hvdCA9IHRoaXMuI3J1blN0ZXBTbmFwc2hvdHNbZXZlbnQuZGF0YS5pZF0gYXMgUnVucy5SdW5TdGVwO1xuICAgICAgICBpZiAoIXNuYXBzaG90KSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlY2VpdmVkIGEgUnVuU3RlcERlbHRhIGJlZm9yZSBjcmVhdGlvbiBvZiBhIHNuYXBzaG90Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGF0YSA9IGV2ZW50LmRhdGE7XG5cbiAgICAgICAgaWYgKGRhdGEuZGVsdGEpIHtcbiAgICAgICAgICBjb25zdCBhY2N1bXVsYXRlZCA9IEFzc2lzdGFudFN0cmVhbS5hY2N1bXVsYXRlRGVsdGEoc25hcHNob3QsIGRhdGEuZGVsdGEpIGFzIFJ1bnMuUnVuU3RlcDtcbiAgICAgICAgICB0aGlzLiNydW5TdGVwU25hcHNob3RzW2V2ZW50LmRhdGEuaWRdID0gYWNjdW11bGF0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy4jcnVuU3RlcFNuYXBzaG90c1tldmVudC5kYXRhLmlkXSBhcyBSdW5zLlJ1blN0ZXA7XG5cbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jb21wbGV0ZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmZhaWxlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY2FuY2VsbGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5leHBpcmVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5pbl9wcm9ncmVzcyc6XG4gICAgICAgIHRoaXMuI3J1blN0ZXBTbmFwc2hvdHNbZXZlbnQuZGF0YS5pZF0gPSBldmVudC5kYXRhO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAodGhpcy4jcnVuU3RlcFNuYXBzaG90c1tldmVudC5kYXRhLmlkXSkgcmV0dXJuIHRoaXMuI3J1blN0ZXBTbmFwc2hvdHNbZXZlbnQuZGF0YS5pZF0gYXMgUnVucy5SdW5TdGVwO1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gc25hcHNob3QgYXZhaWxhYmxlJyk7XG4gIH1cblxuICAjYWNjdW11bGF0ZU1lc3NhZ2UoXG4gICAgZXZlbnQ6IEFzc2lzdGFudFN0cmVhbUV2ZW50LFxuICAgIHNuYXBzaG90OiBNZXNzYWdlIHwgdW5kZWZpbmVkLFxuICApOiBbTWVzc2FnZSwgTWVzc2FnZUNvbnRlbnREZWx0YVtdXSB7XG4gICAgbGV0IG5ld0NvbnRlbnQ6IE1lc3NhZ2VDb250ZW50RGVsdGFbXSA9IFtdO1xuXG4gICAgc3dpdGNoIChldmVudC5ldmVudCkge1xuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuY3JlYXRlZCc6XG4gICAgICAgIC8vT24gY3JlYXRpb24gdGhlIHNuYXBzaG90IGlzIGp1c3QgdGhlIGluaXRpYWwgbWVzc2FnZVxuICAgICAgICByZXR1cm4gW2V2ZW50LmRhdGEsIG5ld0NvbnRlbnRdO1xuXG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5kZWx0YSc6XG4gICAgICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICdSZWNlaXZlZCBhIGRlbHRhIHdpdGggbm8gZXhpc3Rpbmcgc25hcHNob3QgKHRoZXJlIHNob3VsZCBiZSBvbmUgZnJvbSBtZXNzYWdlIGNyZWF0aW9uKScsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkYXRhID0gZXZlbnQuZGF0YTtcblxuICAgICAgICAvL0lmIHRoaXMgZGVsdGEgZG9lcyBub3QgaGF2ZSBjb250ZW50LCBub3RoaW5nIHRvIHByb2Nlc3NcbiAgICAgICAgaWYgKGRhdGEuZGVsdGEuY29udGVudCkge1xuICAgICAgICAgIGZvciAoY29uc3QgY29udGVudEVsZW1lbnQgb2YgZGF0YS5kZWx0YS5jb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoY29udGVudEVsZW1lbnQuaW5kZXggaW4gc25hcHNob3QuY29udGVudCkge1xuICAgICAgICAgICAgICBsZXQgY3VycmVudENvbnRlbnQgPSBzbmFwc2hvdC5jb250ZW50W2NvbnRlbnRFbGVtZW50LmluZGV4XTtcbiAgICAgICAgICAgICAgc25hcHNob3QuY29udGVudFtjb250ZW50RWxlbWVudC5pbmRleF0gPSB0aGlzLiNhY2N1bXVsYXRlQ29udGVudChcbiAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGVudCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNuYXBzaG90LmNvbnRlbnRbY29udGVudEVsZW1lbnQuaW5kZXhdID0gY29udGVudEVsZW1lbnQgYXMgTWVzc2FnZUNvbnRlbnQ7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgZWxlbWVudFxuICAgICAgICAgICAgICBuZXdDb250ZW50LnB1c2goY29udGVudEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbc25hcHNob3QsIG5ld0NvbnRlbnRdO1xuXG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5pbl9wcm9ncmVzcyc6XG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5jb21wbGV0ZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuaW5jb21wbGV0ZSc6XG4gICAgICAgIC8vTm8gY2hhbmdlcyBvbiBvdGhlciB0aHJlYWQgZXZlbnRzXG4gICAgICAgIGlmIChzbmFwc2hvdCkge1xuICAgICAgICAgIHJldHVybiBbc25hcHNob3QsIG5ld0NvbnRlbnRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IEVycm9yKCdSZWNlaXZlZCB0aHJlYWQgbWVzc2FnZSBldmVudCB3aXRoIG5vIGV4aXN0aW5nIHNuYXBzaG90Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoJ1RyaWVkIHRvIGFjY3VtdWxhdGUgYSBub24tbWVzc2FnZSBldmVudCcpO1xuICB9XG5cbiAgI2FjY3VtdWxhdGVDb250ZW50KFxuICAgIGNvbnRlbnRFbGVtZW50OiBNZXNzYWdlQ29udGVudERlbHRhLFxuICAgIGN1cnJlbnRDb250ZW50OiBNZXNzYWdlQ29udGVudCB8IHVuZGVmaW5lZCxcbiAgKTogVGV4dENvbnRlbnRCbG9jayB8IEltYWdlRmlsZUNvbnRlbnRCbG9jayB7XG4gICAgcmV0dXJuIEFzc2lzdGFudFN0cmVhbS5hY2N1bXVsYXRlRGVsdGEoY3VycmVudENvbnRlbnQgYXMgdW5rbm93biBhcyBSZWNvcmQ8YW55LCBhbnk+LCBjb250ZW50RWxlbWVudCkgYXNcbiAgICAgIHwgVGV4dENvbnRlbnRCbG9ja1xuICAgICAgfCBJbWFnZUZpbGVDb250ZW50QmxvY2s7XG4gIH1cblxuICBzdGF0aWMgYWNjdW11bGF0ZURlbHRhKGFjYzogUmVjb3JkPHN0cmluZywgYW55PiwgZGVsdGE6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGRlbHRhVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRlbHRhKSkge1xuICAgICAgaWYgKCFhY2MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBhY2Nba2V5XSA9IGRlbHRhVmFsdWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgYWNjVmFsdWUgPSBhY2Nba2V5XTtcbiAgICAgIGlmIChhY2NWYWx1ZSA9PT0gbnVsbCB8fCBhY2NWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFjY1trZXldID0gZGVsdGFWYWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGRvbid0IGFjY3VtdWxhdGUgdGhlc2Ugc3BlY2lhbCBwcm9wZXJ0aWVzXG4gICAgICBpZiAoa2V5ID09PSAnaW5kZXgnIHx8IGtleSA9PT0gJ3R5cGUnKSB7XG4gICAgICAgIGFjY1trZXldID0gZGVsdGFWYWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFR5cGUtc3BlY2lmaWMgYWNjdW11bGF0aW9uIGxvZ2ljXG4gICAgICBpZiAodHlwZW9mIGFjY1ZhbHVlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGVsdGFWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYWNjVmFsdWUgKz0gZGVsdGFWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjY1ZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgZGVsdGFWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYWNjVmFsdWUgKz0gZGVsdGFWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoQ29yZS5pc09iaihhY2NWYWx1ZSkgJiYgQ29yZS5pc09iaihkZWx0YVZhbHVlKSkge1xuICAgICAgICBhY2NWYWx1ZSA9IHRoaXMuYWNjdW11bGF0ZURlbHRhKGFjY1ZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIGFueT4sIGRlbHRhVmFsdWUgYXMgUmVjb3JkPHN0cmluZywgYW55Pik7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYWNjVmFsdWUpICYmIEFycmF5LmlzQXJyYXkoZGVsdGFWYWx1ZSkpIHtcbiAgICAgICAgaWYgKGFjY1ZhbHVlLmV2ZXJ5KCh4KSA9PiB0eXBlb2YgeCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHggPT09ICdudW1iZXInKSkge1xuICAgICAgICAgIGFjY1ZhbHVlLnB1c2goLi4uZGVsdGFWYWx1ZSk7IC8vIFVzZSBzcHJlYWQgc3ludGF4IGZvciBlZmZpY2llbnQgYWRkaXRpb25cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgZGVsdGFFbnRyeSBvZiBkZWx0YVZhbHVlKSB7XG4gICAgICAgICAgaWYgKCFDb3JlLmlzT2JqKGRlbHRhRW50cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFycmF5IGRlbHRhIGVudHJ5IHRvIGJlIGFuIG9iamVjdCBidXQgZ290OiAke2RlbHRhRW50cnl9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaW5kZXggPSBkZWx0YUVudHJ5WydpbmRleCddO1xuICAgICAgICAgIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGRlbHRhRW50cnkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhcnJheSBkZWx0YSBlbnRyeSB0byBoYXZlIGFuIGBpbmRleGAgcHJvcGVydHknKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhcnJheSBkZWx0YSBlbnRyeSBcXGBpbmRleFxcYCBwcm9wZXJ0eSB0byBiZSBhIG51bWJlciBidXQgZ290ICR7aW5kZXh9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYWNjRW50cnkgPSBhY2NWYWx1ZVtpbmRleF07XG4gICAgICAgICAgaWYgKGFjY0VudHJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFjY1ZhbHVlLnB1c2goZGVsdGFFbnRyeSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY1ZhbHVlW2luZGV4XSA9IHRoaXMuYWNjdW11bGF0ZURlbHRhKGFjY0VudHJ5LCBkZWx0YUVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihgVW5oYW5kbGVkIHJlY29yZCB0eXBlOiAke2tleX0sIGRlbHRhVmFsdWU6ICR7ZGVsdGFWYWx1ZX0sIGFjY1ZhbHVlOiAke2FjY1ZhbHVlfWApO1xuICAgICAgfVxuICAgICAgYWNjW2tleV0gPSBhY2NWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9XG5cbiAgI2hhbmRsZVJ1bih0aGlzOiBBc3Npc3RhbnRTdHJlYW0sIGV2ZW50OiBSdW5TdHJlYW1FdmVudCkge1xuICAgIHRoaXMuI2N1cnJlbnRSdW5TbmFwc2hvdCA9IGV2ZW50LmRhdGE7XG4gICAgc3dpdGNoIChldmVudC5ldmVudCkge1xuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jcmVhdGVkJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnF1ZXVlZCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5pbl9wcm9ncmVzcyc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5yZXF1aXJlc19hY3Rpb24nOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jYW5jZWxsZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5mYWlsZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jb21wbGV0ZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5leHBpcmVkJzpcbiAgICAgICAgdGhpcy4jZmluYWxSdW4gPSBldmVudC5kYXRhO1xuICAgICAgICBpZiAodGhpcy4jY3VycmVudFRvb2xDYWxsKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdCgndG9vbENhbGxEb25lJywgdGhpcy4jY3VycmVudFRvb2xDYWxsKTtcbiAgICAgICAgICB0aGlzLiNjdXJyZW50VG9vbENhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmNhbmNlbGxpbmcnOlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2FkZFJ1bihydW46IFJ1bik6IFJ1biB7XG4gICAgcmV0dXJuIHJ1bjtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfdGhyZWFkQXNzaXN0YW50U3RyZWFtKFxuICAgIHBhcmFtczogVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zQmFzZSxcbiAgICB0aHJlYWQ6IFRocmVhZHMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IFByb21pc2U8UnVuPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2NyZWF0ZVRocmVhZEFzc2lzdGFudFN0cmVhbSh0aHJlYWQsIHBhcmFtcywgb3B0aW9ucyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX3J1bkFzc2lzdGFudFN0cmVhbShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bnM6IFJ1bnMsXG4gICAgcGFyYW1zOiBSdW5DcmVhdGVQYXJhbXNCYXNlLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBQcm9taXNlPFJ1bj4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9jcmVhdGVBc3Npc3RhbnRTdHJlYW0ocnVucywgdGhyZWFkSWQsIHBhcmFtcywgb3B0aW9ucyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX3J1blRvb2xBc3Npc3RhbnRTdHJlYW0oXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIHJ1bnM6IFJ1bnMsXG4gICAgcGFyYW1zOiBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxSdW4+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fY3JlYXRlVG9vbEFzc2lzdGFudFN0cmVhbShydW5zLCB0aHJlYWRJZCwgcnVuSWQsIHBhcmFtcywgb3B0aW9ucyk7XG4gIH1cbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBBc3Npc3RhbnRzQVBJIGZyb20gJy4uL2Fzc2lzdGFudHMnO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSwgdHlwZSBDdXJzb3JQYWdlUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vcGFnaW5hdGlvbic7XG5cbmV4cG9ydCBjbGFzcyBNZXNzYWdlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1lc3NhZ2UuXG4gICAqL1xuICBjcmVhdGUoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBib2R5OiBNZXNzYWdlQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8TWVzc2FnZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vbWVzc2FnZXNgLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgYSBtZXNzYWdlLlxuICAgKi9cbiAgcmV0cmlldmUodGhyZWFkSWQ6IHN0cmluZywgbWVzc2FnZUlkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPE1lc3NhZ2U+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL3RocmVhZHMvJHt0aHJlYWRJZH0vbWVzc2FnZXMvJHttZXNzYWdlSWR9YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZpZXMgYSBtZXNzYWdlLlxuICAgKi9cbiAgdXBkYXRlKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgbWVzc2FnZUlkOiBzdHJpbmcsXG4gICAgYm9keTogTWVzc2FnZVVwZGF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPE1lc3NhZ2U+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L21lc3NhZ2VzLyR7bWVzc2FnZUlkfWAsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBtZXNzYWdlcyBmb3IgYSBnaXZlbiB0aHJlYWQuXG4gICAqL1xuICBsaXN0KFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcXVlcnk/OiBNZXNzYWdlTGlzdFBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxNZXNzYWdlc1BhZ2UsIE1lc3NhZ2U+O1xuICBsaXN0KHRocmVhZElkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5QYWdlUHJvbWlzZTxNZXNzYWdlc1BhZ2UsIE1lc3NhZ2U+O1xuICBsaXN0KFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcXVlcnk6IE1lc3NhZ2VMaXN0UGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPE1lc3NhZ2VzUGFnZSwgTWVzc2FnZT4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdCh0aHJlYWRJZCwge30sIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9tZXNzYWdlc2AsIE1lc3NhZ2VzUGFnZSwge1xuICAgICAgcXVlcnksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbWVzc2FnZS5cbiAgICovXG4gIGRlbCh0aHJlYWRJZDogc3RyaW5nLCBtZXNzYWdlSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8TWVzc2FnZURlbGV0ZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL3RocmVhZHMvJHt0aHJlYWRJZH0vbWVzc2FnZXMvJHttZXNzYWdlSWR9YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1lc3NhZ2VzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8TWVzc2FnZT4ge31cblxuLyoqXG4gKiBBIGNpdGF0aW9uIHdpdGhpbiB0aGUgbWVzc2FnZSB0aGF0IHBvaW50cyB0byBhIHNwZWNpZmljIHF1b3RlIGZyb20gYSBzcGVjaWZpY1xuICogRmlsZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2lzdGFudCBvciB0aGUgbWVzc2FnZS4gR2VuZXJhdGVkIHdoZW4gdGhlIGFzc2lzdGFudFxuICogdXNlcyB0aGUgXCJmaWxlX3NlYXJjaFwiIHRvb2wgdG8gc2VhcmNoIGZpbGVzLlxuICovXG5leHBvcnQgdHlwZSBBbm5vdGF0aW9uID0gRmlsZUNpdGF0aW9uQW5ub3RhdGlvbiB8IEZpbGVQYXRoQW5ub3RhdGlvbjtcblxuLyoqXG4gKiBBIGNpdGF0aW9uIHdpdGhpbiB0aGUgbWVzc2FnZSB0aGF0IHBvaW50cyB0byBhIHNwZWNpZmljIHF1b3RlIGZyb20gYSBzcGVjaWZpY1xuICogRmlsZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2lzdGFudCBvciB0aGUgbWVzc2FnZS4gR2VuZXJhdGVkIHdoZW4gdGhlIGFzc2lzdGFudFxuICogdXNlcyB0aGUgXCJmaWxlX3NlYXJjaFwiIHRvb2wgdG8gc2VhcmNoIGZpbGVzLlxuICovXG5leHBvcnQgdHlwZSBBbm5vdGF0aW9uRGVsdGEgPSBGaWxlQ2l0YXRpb25EZWx0YUFubm90YXRpb24gfCBGaWxlUGF0aERlbHRhQW5ub3RhdGlvbjtcblxuLyoqXG4gKiBBIGNpdGF0aW9uIHdpdGhpbiB0aGUgbWVzc2FnZSB0aGF0IHBvaW50cyB0byBhIHNwZWNpZmljIHF1b3RlIGZyb20gYSBzcGVjaWZpY1xuICogRmlsZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2lzdGFudCBvciB0aGUgbWVzc2FnZS4gR2VuZXJhdGVkIHdoZW4gdGhlIGFzc2lzdGFudFxuICogdXNlcyB0aGUgXCJmaWxlX3NlYXJjaFwiIHRvb2wgdG8gc2VhcmNoIGZpbGVzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVDaXRhdGlvbkFubm90YXRpb24ge1xuICBlbmRfaW5kZXg6IG51bWJlcjtcblxuICBmaWxlX2NpdGF0aW9uOiBGaWxlQ2l0YXRpb25Bbm5vdGF0aW9uLkZpbGVDaXRhdGlvbjtcblxuICBzdGFydF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdGV4dCBpbiB0aGUgbWVzc2FnZSBjb250ZW50IHRoYXQgbmVlZHMgdG8gYmUgcmVwbGFjZWQuXG4gICAqL1xuICB0ZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgZmlsZV9jaXRhdGlvbmAuXG4gICAqL1xuICB0eXBlOiAnZmlsZV9jaXRhdGlvbic7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRmlsZUNpdGF0aW9uQW5ub3RhdGlvbiB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRmlsZUNpdGF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIHNwZWNpZmljIEZpbGUgdGhlIGNpdGF0aW9uIGlzIGZyb20uXG4gICAgICovXG4gICAgZmlsZV9pZDogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogQSBjaXRhdGlvbiB3aXRoaW4gdGhlIG1lc3NhZ2UgdGhhdCBwb2ludHMgdG8gYSBzcGVjaWZpYyBxdW90ZSBmcm9tIGEgc3BlY2lmaWNcbiAqIEZpbGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3Npc3RhbnQgb3IgdGhlIG1lc3NhZ2UuIEdlbmVyYXRlZCB3aGVuIHRoZSBhc3Npc3RhbnRcbiAqIHVzZXMgdGhlIFwiZmlsZV9zZWFyY2hcIiB0b29sIHRvIHNlYXJjaCBmaWxlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaWxlQ2l0YXRpb25EZWx0YUFubm90YXRpb24ge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBhbm5vdGF0aW9uIGluIHRoZSB0ZXh0IGNvbnRlbnQgcGFydC5cbiAgICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgZmlsZV9jaXRhdGlvbmAuXG4gICAqL1xuICB0eXBlOiAnZmlsZV9jaXRhdGlvbic7XG5cbiAgZW5kX2luZGV4PzogbnVtYmVyO1xuXG4gIGZpbGVfY2l0YXRpb24/OiBGaWxlQ2l0YXRpb25EZWx0YUFubm90YXRpb24uRmlsZUNpdGF0aW9uO1xuXG4gIHN0YXJ0X2luZGV4PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdGV4dCBpbiB0aGUgbWVzc2FnZSBjb250ZW50IHRoYXQgbmVlZHMgdG8gYmUgcmVwbGFjZWQuXG4gICAqL1xuICB0ZXh0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZpbGVDaXRhdGlvbkRlbHRhQW5ub3RhdGlvbiB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRmlsZUNpdGF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIHNwZWNpZmljIEZpbGUgdGhlIGNpdGF0aW9uIGlzIGZyb20uXG4gICAgICovXG4gICAgZmlsZV9pZD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBzcGVjaWZpYyBxdW90ZSBpbiB0aGUgZmlsZS5cbiAgICAgKi9cbiAgICBxdW90ZT86IHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIEEgVVJMIGZvciB0aGUgZmlsZSB0aGF0J3MgZ2VuZXJhdGVkIHdoZW4gdGhlIGFzc2lzdGFudCB1c2VkIHRoZVxuICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgdG8gZ2VuZXJhdGUgYSBmaWxlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVQYXRoQW5ub3RhdGlvbiB7XG4gIGVuZF9pbmRleDogbnVtYmVyO1xuXG4gIGZpbGVfcGF0aDogRmlsZVBhdGhBbm5vdGF0aW9uLkZpbGVQYXRoO1xuXG4gIHN0YXJ0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGluIHRoZSBtZXNzYWdlIGNvbnRlbnQgdGhhdCBuZWVkcyB0byBiZSByZXBsYWNlZC5cbiAgICovXG4gIHRleHQ6IHN0cmluZztcblxuICAvKipcbiAgICogQWx3YXlzIGBmaWxlX3BhdGhgLlxuICAgKi9cbiAgdHlwZTogJ2ZpbGVfcGF0aCc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRmlsZVBhdGhBbm5vdGF0aW9uIHtcbiAgZXhwb3J0IGludGVyZmFjZSBGaWxlUGF0aCB7XG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBmaWxlIHRoYXQgd2FzIGdlbmVyYXRlZC5cbiAgICAgKi9cbiAgICBmaWxlX2lkOiBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBBIFVSTCBmb3IgdGhlIGZpbGUgdGhhdCdzIGdlbmVyYXRlZCB3aGVuIHRoZSBhc3Npc3RhbnQgdXNlZCB0aGVcbiAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHRvIGdlbmVyYXRlIGEgZmlsZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaWxlUGF0aERlbHRhQW5ub3RhdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGFubm90YXRpb24gaW4gdGhlIHRleHQgY29udGVudCBwYXJ0LlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogQWx3YXlzIGBmaWxlX3BhdGhgLlxuICAgKi9cbiAgdHlwZTogJ2ZpbGVfcGF0aCc7XG5cbiAgZW5kX2luZGV4PzogbnVtYmVyO1xuXG4gIGZpbGVfcGF0aD86IEZpbGVQYXRoRGVsdGFBbm5vdGF0aW9uLkZpbGVQYXRoO1xuXG4gIHN0YXJ0X2luZGV4PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdGV4dCBpbiB0aGUgbWVzc2FnZSBjb250ZW50IHRoYXQgbmVlZHMgdG8gYmUgcmVwbGFjZWQuXG4gICAqL1xuICB0ZXh0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZpbGVQYXRoRGVsdGFBbm5vdGF0aW9uIHtcbiAgZXhwb3J0IGludGVyZmFjZSBGaWxlUGF0aCB7XG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBmaWxlIHRoYXQgd2FzIGdlbmVyYXRlZC5cbiAgICAgKi9cbiAgICBmaWxlX2lkPzogc3RyaW5nO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VGaWxlIHtcbiAgLyoqXG4gICAqIFRoZSBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSUQgb2YgdGhlIGltYWdlXG4gICAqIGluIHRoZSBtZXNzYWdlIGNvbnRlbnQuIFNldCBgcHVycG9zZT1cInZpc2lvblwiYCB3aGVuIHVwbG9hZGluZyB0aGUgRmlsZSBpZiB5b3VcbiAgICogbmVlZCB0byBsYXRlciBkaXNwbGF5IHRoZSBmaWxlIGNvbnRlbnQuXG4gICAqL1xuICBmaWxlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZGV0YWlsIGxldmVsIG9mIHRoZSBpbWFnZSBpZiBzcGVjaWZpZWQgYnkgdGhlIHVzZXIuIGBsb3dgIHVzZXNcbiAgICogZmV3ZXIgdG9rZW5zLCB5b3UgY2FuIG9wdCBpbiB0byBoaWdoIHJlc29sdXRpb24gdXNpbmcgYGhpZ2hgLlxuICAgKi9cbiAgZGV0YWlsPzogJ2F1dG8nIHwgJ2xvdycgfCAnaGlnaCc7XG59XG5cbi8qKlxuICogUmVmZXJlbmNlcyBhbiBpbWFnZSBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcylcbiAqIGluIHRoZSBjb250ZW50IG9mIGEgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbWFnZUZpbGVDb250ZW50QmxvY2sge1xuICBpbWFnZV9maWxlOiBJbWFnZUZpbGU7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgaW1hZ2VfZmlsZWAuXG4gICAqL1xuICB0eXBlOiAnaW1hZ2VfZmlsZSc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VGaWxlRGVsdGEge1xuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkZXRhaWwgbGV2ZWwgb2YgdGhlIGltYWdlIGlmIHNwZWNpZmllZCBieSB0aGUgdXNlci4gYGxvd2AgdXNlc1xuICAgKiBmZXdlciB0b2tlbnMsIHlvdSBjYW4gb3B0IGluIHRvIGhpZ2ggcmVzb2x1dGlvbiB1c2luZyBgaGlnaGAuXG4gICAqL1xuICBkZXRhaWw/OiAnYXV0bycgfCAnbG93JyB8ICdoaWdoJztcblxuICAvKipcbiAgICogVGhlIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRCBvZiB0aGUgaW1hZ2VcbiAgICogaW4gdGhlIG1lc3NhZ2UgY29udGVudC4gU2V0IGBwdXJwb3NlPVwidmlzaW9uXCJgIHdoZW4gdXBsb2FkaW5nIHRoZSBGaWxlIGlmIHlvdVxuICAgKiBuZWVkIHRvIGxhdGVyIGRpc3BsYXkgdGhlIGZpbGUgY29udGVudC5cbiAgICovXG4gIGZpbGVfaWQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVmZXJlbmNlcyBhbiBpbWFnZSBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcylcbiAqIGluIHRoZSBjb250ZW50IG9mIGEgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbWFnZUZpbGVEZWx0YUJsb2NrIHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGluIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogQWx3YXlzIGBpbWFnZV9maWxlYC5cbiAgICovXG4gIHR5cGU6ICdpbWFnZV9maWxlJztcblxuICBpbWFnZV9maWxlPzogSW1hZ2VGaWxlRGVsdGE7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VVUkwge1xuICAvKipcbiAgICogVGhlIGV4dGVybmFsIFVSTCBvZiB0aGUgaW1hZ2UsIG11c3QgYmUgYSBzdXBwb3J0ZWQgaW1hZ2UgdHlwZXM6IGpwZWcsIGpwZywgcG5nLFxuICAgKiBnaWYsIHdlYnAuXG4gICAqL1xuICB1cmw6IHN0cmluZztcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkZXRhaWwgbGV2ZWwgb2YgdGhlIGltYWdlLiBgbG93YCB1c2VzIGZld2VyIHRva2VucywgeW91IGNhbiBvcHQgaW5cbiAgICogdG8gaGlnaCByZXNvbHV0aW9uIHVzaW5nIGBoaWdoYC4gRGVmYXVsdCB2YWx1ZSBpcyBgYXV0b2BcbiAgICovXG4gIGRldGFpbD86ICdhdXRvJyB8ICdsb3cnIHwgJ2hpZ2gnO1xufVxuXG4vKipcbiAqIFJlZmVyZW5jZXMgYW4gaW1hZ2UgVVJMIGluIHRoZSBjb250ZW50IG9mIGEgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbWFnZVVSTENvbnRlbnRCbG9jayB7XG4gIGltYWdlX3VybDogSW1hZ2VVUkw7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBjb250ZW50IHBhcnQuXG4gICAqL1xuICB0eXBlOiAnaW1hZ2VfdXJsJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZVVSTERlbHRhIHtcbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZGV0YWlsIGxldmVsIG9mIHRoZSBpbWFnZS4gYGxvd2AgdXNlcyBmZXdlciB0b2tlbnMsIHlvdSBjYW4gb3B0IGluXG4gICAqIHRvIGhpZ2ggcmVzb2x1dGlvbiB1c2luZyBgaGlnaGAuXG4gICAqL1xuICBkZXRhaWw/OiAnYXV0bycgfCAnbG93JyB8ICdoaWdoJztcblxuICAvKipcbiAgICogVGhlIFVSTCBvZiB0aGUgaW1hZ2UsIG11c3QgYmUgYSBzdXBwb3J0ZWQgaW1hZ2UgdHlwZXM6IGpwZWcsIGpwZywgcG5nLCBnaWYsXG4gICAqIHdlYnAuXG4gICAqL1xuICB1cmw/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVmZXJlbmNlcyBhbiBpbWFnZSBVUkwgaW4gdGhlIGNvbnRlbnQgb2YgYSBtZXNzYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlVVJMRGVsdGFCbG9jayB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCBpbiB0aGUgbWVzc2FnZS5cbiAgICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgaW1hZ2VfdXJsYC5cbiAgICovXG4gIHR5cGU6ICdpbWFnZV91cmwnO1xuXG4gIGltYWdlX3VybD86IEltYWdlVVJMRGVsdGE7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIG1lc3NhZ2Ugd2l0aGluIGFcbiAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBUaGUgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElmIGFwcGxpY2FibGUsIHRoZSBJRCBvZiB0aGVcbiAgICogW2Fzc2lzdGFudF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSB0aGF0XG4gICAqIGF1dGhvcmVkIHRoaXMgbWVzc2FnZS5cbiAgICovXG4gIGFzc2lzdGFudF9pZDogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIHRoZSBtZXNzYWdlLCBhbmQgdGhlIHRvb2xzIHRoZXkgd2VyZSBhZGRlZCB0by5cbiAgICovXG4gIGF0dGFjaG1lbnRzOiBBcnJheTxNZXNzYWdlLkF0dGFjaG1lbnQ+IHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgbWVzc2FnZSB3YXMgY29tcGxldGVkLlxuICAgKi9cbiAgY29tcGxldGVkX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZSBpbiBhcnJheSBvZiB0ZXh0IGFuZC9vciBpbWFnZXMuXG4gICAqL1xuICBjb250ZW50OiBBcnJheTxNZXNzYWdlQ29udGVudD47XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIG1lc3NhZ2Ugd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIG1lc3NhZ2Ugd2FzIG1hcmtlZCBhcyBpbmNvbXBsZXRlLlxuICAgKi9cbiAgaW5jb21wbGV0ZV9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogT24gYW4gaW5jb21wbGV0ZSBtZXNzYWdlLCBkZXRhaWxzIGFib3V0IHdoeSB0aGUgbWVzc2FnZSBpcyBpbmNvbXBsZXRlLlxuICAgKi9cbiAgaW5jb21wbGV0ZV9kZXRhaWxzOiBNZXNzYWdlLkluY29tcGxldGVEZXRhaWxzIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE6IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgdGhyZWFkLm1lc3NhZ2VgLlxuICAgKi9cbiAgb2JqZWN0OiAndGhyZWFkLm1lc3NhZ2UnO1xuXG4gIC8qKlxuICAgKiBUaGUgZW50aXR5IHRoYXQgcHJvZHVjZWQgdGhlIG1lc3NhZ2UuIE9uZSBvZiBgdXNlcmAgb3IgYGFzc2lzdGFudGAuXG4gICAqL1xuICByb2xlOiAndXNlcicgfCAnYXNzaXN0YW50JztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMpXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3JlYXRpb24gb2YgdGhpcyBtZXNzYWdlLiBWYWx1ZSBpcyBgbnVsbGAgd2hlbiBtZXNzYWdlcyBhcmVcbiAgICogY3JlYXRlZCBtYW51YWxseSB1c2luZyB0aGUgY3JlYXRlIG1lc3NhZ2Ugb3IgY3JlYXRlIHRocmVhZCBlbmRwb2ludHMuXG4gICAqL1xuICBydW5faWQ6IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzdGF0dXMgb2YgdGhlIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBlaXRoZXIgYGluX3Byb2dyZXNzYCwgYGluY29tcGxldGVgLCBvclxuICAgKiBgY29tcGxldGVkYC5cbiAgICovXG4gIHN0YXR1czogJ2luX3Byb2dyZXNzJyB8ICdpbmNvbXBsZXRlJyB8ICdjb21wbGV0ZWQnO1xuXG4gIC8qKlxuICAgKiBUaGUgW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKSBJRCB0aGF0XG4gICAqIHRoaXMgbWVzc2FnZSBiZWxvbmdzIHRvLlxuICAgKi9cbiAgdGhyZWFkX2lkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgTWVzc2FnZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudCB7XG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBmaWxlIHRvIGF0dGFjaCB0byB0aGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBmaWxlX2lkPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvb2xzIHRvIGFkZCB0aGlzIGZpbGUgdG8uXG4gICAgICovXG4gICAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkNvZGVJbnRlcnByZXRlclRvb2wgfCBBdHRhY2htZW50LkFzc2lzdGFudFRvb2xzRmlsZVNlYXJjaFR5cGVPbmx5PjtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgQXR0YWNobWVudCB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBBc3Npc3RhbnRUb29sc0ZpbGVTZWFyY2hUeXBlT25seSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0eXBlIG9mIHRvb2wgYmVpbmcgZGVmaW5lZDogYGZpbGVfc2VhcmNoYFxuICAgICAgICovXG4gICAgICB0eXBlOiAnZmlsZV9zZWFyY2gnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBhbiBpbmNvbXBsZXRlIG1lc3NhZ2UsIGRldGFpbHMgYWJvdXQgd2h5IHRoZSBtZXNzYWdlIGlzIGluY29tcGxldGUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEluY29tcGxldGVEZXRhaWxzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVhc29uIHRoZSBtZXNzYWdlIGlzIGluY29tcGxldGUuXG4gICAgICovXG4gICAgcmVhc29uOiAnY29udGVudF9maWx0ZXInIHwgJ21heF90b2tlbnMnIHwgJ3J1bl9jYW5jZWxsZWQnIHwgJ3J1bl9leHBpcmVkJyB8ICdydW5fZmFpbGVkJztcbiAgfVxufVxuXG4vKipcbiAqIFJlZmVyZW5jZXMgYW4gaW1hZ2UgW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpXG4gKiBpbiB0aGUgY29udGVudCBvZiBhIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCB0eXBlIE1lc3NhZ2VDb250ZW50ID1cbiAgfCBJbWFnZUZpbGVDb250ZW50QmxvY2tcbiAgfCBJbWFnZVVSTENvbnRlbnRCbG9ja1xuICB8IFRleHRDb250ZW50QmxvY2tcbiAgfCBSZWZ1c2FsQ29udGVudEJsb2NrO1xuXG4vKipcbiAqIFJlZmVyZW5jZXMgYW4gaW1hZ2UgW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpXG4gKiBpbiB0aGUgY29udGVudCBvZiBhIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCB0eXBlIE1lc3NhZ2VDb250ZW50RGVsdGEgPVxuICB8IEltYWdlRmlsZURlbHRhQmxvY2tcbiAgfCBUZXh0RGVsdGFCbG9ja1xuICB8IFJlZnVzYWxEZWx0YUJsb2NrXG4gIHwgSW1hZ2VVUkxEZWx0YUJsb2NrO1xuXG4vKipcbiAqIFJlZmVyZW5jZXMgYW4gaW1hZ2UgW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpXG4gKiBpbiB0aGUgY29udGVudCBvZiBhIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCB0eXBlIE1lc3NhZ2VDb250ZW50UGFydFBhcmFtID0gSW1hZ2VGaWxlQ29udGVudEJsb2NrIHwgSW1hZ2VVUkxDb250ZW50QmxvY2sgfCBUZXh0Q29udGVudEJsb2NrUGFyYW07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZURlbGV0ZWQge1xuICBpZDogc3RyaW5nO1xuXG4gIGRlbGV0ZWQ6IGJvb2xlYW47XG5cbiAgb2JqZWN0OiAndGhyZWFkLm1lc3NhZ2UuZGVsZXRlZCc7XG59XG5cbi8qKlxuICogVGhlIGRlbHRhIGNvbnRhaW5pbmcgdGhlIGZpZWxkcyB0aGF0IGhhdmUgY2hhbmdlZCBvbiB0aGUgTWVzc2FnZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlRGVsdGEge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIG1lc3NhZ2UgaW4gYXJyYXkgb2YgdGV4dCBhbmQvb3IgaW1hZ2VzLlxuICAgKi9cbiAgY29udGVudD86IEFycmF5PE1lc3NhZ2VDb250ZW50RGVsdGE+O1xuXG4gIC8qKlxuICAgKiBUaGUgZW50aXR5IHRoYXQgcHJvZHVjZWQgdGhlIG1lc3NhZ2UuIE9uZSBvZiBgdXNlcmAgb3IgYGFzc2lzdGFudGAuXG4gICAqL1xuICByb2xlPzogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIG1lc3NhZ2UgZGVsdGEgaS5lLiBhbnkgY2hhbmdlZCBmaWVsZHMgb24gYSBtZXNzYWdlIGR1cmluZ1xuICogc3RyZWFtaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VEZWx0YUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBtZXNzYWdlLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGRlbHRhIGNvbnRhaW5pbmcgdGhlIGZpZWxkcyB0aGF0IGhhdmUgY2hhbmdlZCBvbiB0aGUgTWVzc2FnZS5cbiAgICovXG4gIGRlbHRhOiBNZXNzYWdlRGVsdGE7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGB0aHJlYWQubWVzc2FnZS5kZWx0YWAuXG4gICAqL1xuICBvYmplY3Q6ICd0aHJlYWQubWVzc2FnZS5kZWx0YSc7XG59XG5cbi8qKlxuICogVGhlIHJlZnVzYWwgY29udGVudCBnZW5lcmF0ZWQgYnkgdGhlIGFzc2lzdGFudC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWZ1c2FsQ29udGVudEJsb2NrIHtcbiAgcmVmdXNhbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYHJlZnVzYWxgLlxuICAgKi9cbiAgdHlwZTogJ3JlZnVzYWwnO1xufVxuXG4vKipcbiAqIFRoZSByZWZ1c2FsIGNvbnRlbnQgdGhhdCBpcyBwYXJ0IG9mIGEgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWZ1c2FsRGVsdGFCbG9jayB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIHJlZnVzYWwgcGFydCBpbiB0aGUgbWVzc2FnZS5cbiAgICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgcmVmdXNhbGAuXG4gICAqL1xuICB0eXBlOiAncmVmdXNhbCc7XG5cbiAgcmVmdXNhbD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZXh0IHtcbiAgYW5ub3RhdGlvbnM6IEFycmF5PEFubm90YXRpb24+O1xuXG4gIC8qKlxuICAgKiBUaGUgZGF0YSB0aGF0IG1ha2VzIHVwIHRoZSB0ZXh0LlxuICAgKi9cbiAgdmFsdWU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBUaGUgdGV4dCBjb250ZW50IHRoYXQgaXMgcGFydCBvZiBhIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dENvbnRlbnRCbG9jayB7XG4gIHRleHQ6IFRleHQ7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgdGV4dGAuXG4gICAqL1xuICB0eXBlOiAndGV4dCc7XG59XG5cbi8qKlxuICogVGhlIHRleHQgY29udGVudCB0aGF0IGlzIHBhcnQgb2YgYSBtZXNzYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRleHRDb250ZW50QmxvY2tQYXJhbSB7XG4gIC8qKlxuICAgKiBUZXh0IGNvbnRlbnQgdG8gYmUgc2VudCB0byB0aGUgbW9kZWxcbiAgICovXG4gIHRleHQ6IHN0cmluZztcblxuICAvKipcbiAgICogQWx3YXlzIGB0ZXh0YC5cbiAgICovXG4gIHR5cGU6ICd0ZXh0Jztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZXh0RGVsdGEge1xuICBhbm5vdGF0aW9ucz86IEFycmF5PEFubm90YXRpb25EZWx0YT47XG5cbiAgLyoqXG4gICAqIFRoZSBkYXRhIHRoYXQgbWFrZXMgdXAgdGhlIHRleHQuXG4gICAqL1xuICB2YWx1ZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBUaGUgdGV4dCBjb250ZW50IHRoYXQgaXMgcGFydCBvZiBhIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dERlbHRhQmxvY2sge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgaW4gdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYHRleHRgLlxuICAgKi9cbiAgdHlwZTogJ3RleHQnO1xuXG4gIHRleHQ/OiBUZXh0RGVsdGE7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZUNyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgdGV4dCBjb250ZW50cyBvZiB0aGUgbWVzc2FnZS5cbiAgICovXG4gIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PE1lc3NhZ2VDb250ZW50UGFydFBhcmFtPjtcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIGVudGl0eSB0aGF0IGlzIGNyZWF0aW5nIHRoZSBtZXNzYWdlLiBBbGxvd2VkIHZhbHVlcyBpbmNsdWRlOlxuICAgKlxuICAgKiAtIGB1c2VyYDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIHNlbnQgYnkgYW4gYWN0dWFsIHVzZXIgYW5kIHNob3VsZCBiZSB1c2VkIGluXG4gICAqICAgbW9zdCBjYXNlcyB0byByZXByZXNlbnQgdXNlci1nZW5lcmF0ZWQgbWVzc2FnZXMuXG4gICAqIC0gYGFzc2lzdGFudGA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBnZW5lcmF0ZWQgYnkgdGhlIGFzc2lzdGFudC4gVXNlIHRoaXNcbiAgICogICB2YWx1ZSB0byBpbnNlcnQgbWVzc2FnZXMgZnJvbSB0aGUgYXNzaXN0YW50IGludG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICovXG4gIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgZmlsZXMgYXR0YWNoZWQgdG8gdGhlIG1lc3NhZ2UsIGFuZCB0aGUgdG9vbHMgdGhleSBzaG91bGQgYmUgYWRkZWQgdG8uXG4gICAqL1xuICBhdHRhY2htZW50cz86IEFycmF5PE1lc3NhZ2VDcmVhdGVQYXJhbXMuQXR0YWNobWVudD4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIE1lc3NhZ2VDcmVhdGVQYXJhbXMge1xuICBleHBvcnQgaW50ZXJmYWNlIEF0dGFjaG1lbnQge1xuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBhdHRhY2ggdG8gdGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgZmlsZV9pZD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b29scyB0byBhZGQgdGhpcyBmaWxlIHRvLlxuICAgICAqL1xuICAgIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXR0YWNobWVudC5GaWxlU2VhcmNoPjtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgQXR0YWNobWVudCB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHR5cGUgb2YgdG9vbCBiZWluZyBkZWZpbmVkOiBgZmlsZV9zZWFyY2hgXG4gICAgICAgKi9cbiAgICAgIHR5cGU6ICdmaWxlX3NlYXJjaCc7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZVVwZGF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VMaXN0UGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIGN1cnNvciBmb3IgdXNlIGluIHBhZ2luYXRpb24uIGBiZWZvcmVgIGlzIGFuIG9iamVjdCBJRCB0aGF0IGRlZmluZXMgeW91ciBwbGFjZVxuICAgKiBpbiB0aGUgbGlzdC4gRm9yIGluc3RhbmNlLCBpZiB5b3UgbWFrZSBhIGxpc3QgcmVxdWVzdCBhbmQgcmVjZWl2ZSAxMDAgb2JqZWN0cyxcbiAgICogc3RhcnRpbmcgd2l0aCBvYmpfZm9vLCB5b3VyIHN1YnNlcXVlbnQgY2FsbCBjYW4gaW5jbHVkZSBiZWZvcmU9b2JqX2ZvbyBpbiBvcmRlclxuICAgKiB0byBmZXRjaCB0aGUgcHJldmlvdXMgcGFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGJlZm9yZT86IHN0cmluZztcblxuICAvKipcbiAgICogU29ydCBvcmRlciBieSB0aGUgYGNyZWF0ZWRfYXRgIHRpbWVzdGFtcCBvZiB0aGUgb2JqZWN0cy4gYGFzY2AgZm9yIGFzY2VuZGluZ1xuICAgKiBvcmRlciBhbmQgYGRlc2NgIGZvciBkZXNjZW5kaW5nIG9yZGVyLlxuICAgKi9cbiAgb3JkZXI/OiAnYXNjJyB8ICdkZXNjJztcblxuICAvKipcbiAgICogRmlsdGVyIG1lc3NhZ2VzIGJ5IHRoZSBydW4gSUQgdGhhdCBnZW5lcmF0ZWQgdGhlbS5cbiAgICovXG4gIHJ1bl9pZD86IHN0cmluZztcbn1cblxuTWVzc2FnZXMuTWVzc2FnZXNQYWdlID0gTWVzc2FnZXNQYWdlO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgTWVzc2FnZXMge1xuICBleHBvcnQge1xuICAgIHR5cGUgQW5ub3RhdGlvbiBhcyBBbm5vdGF0aW9uLFxuICAgIHR5cGUgQW5ub3RhdGlvbkRlbHRhIGFzIEFubm90YXRpb25EZWx0YSxcbiAgICB0eXBlIEZpbGVDaXRhdGlvbkFubm90YXRpb24gYXMgRmlsZUNpdGF0aW9uQW5ub3RhdGlvbixcbiAgICB0eXBlIEZpbGVDaXRhdGlvbkRlbHRhQW5ub3RhdGlvbiBhcyBGaWxlQ2l0YXRpb25EZWx0YUFubm90YXRpb24sXG4gICAgdHlwZSBGaWxlUGF0aEFubm90YXRpb24gYXMgRmlsZVBhdGhBbm5vdGF0aW9uLFxuICAgIHR5cGUgRmlsZVBhdGhEZWx0YUFubm90YXRpb24gYXMgRmlsZVBhdGhEZWx0YUFubm90YXRpb24sXG4gICAgdHlwZSBJbWFnZUZpbGUgYXMgSW1hZ2VGaWxlLFxuICAgIHR5cGUgSW1hZ2VGaWxlQ29udGVudEJsb2NrIGFzIEltYWdlRmlsZUNvbnRlbnRCbG9jayxcbiAgICB0eXBlIEltYWdlRmlsZURlbHRhIGFzIEltYWdlRmlsZURlbHRhLFxuICAgIHR5cGUgSW1hZ2VGaWxlRGVsdGFCbG9jayBhcyBJbWFnZUZpbGVEZWx0YUJsb2NrLFxuICAgIHR5cGUgSW1hZ2VVUkwgYXMgSW1hZ2VVUkwsXG4gICAgdHlwZSBJbWFnZVVSTENvbnRlbnRCbG9jayBhcyBJbWFnZVVSTENvbnRlbnRCbG9jayxcbiAgICB0eXBlIEltYWdlVVJMRGVsdGEgYXMgSW1hZ2VVUkxEZWx0YSxcbiAgICB0eXBlIEltYWdlVVJMRGVsdGFCbG9jayBhcyBJbWFnZVVSTERlbHRhQmxvY2ssXG4gICAgdHlwZSBNZXNzYWdlIGFzIE1lc3NhZ2UsXG4gICAgdHlwZSBNZXNzYWdlQ29udGVudCBhcyBNZXNzYWdlQ29udGVudCxcbiAgICB0eXBlIE1lc3NhZ2VDb250ZW50RGVsdGEgYXMgTWVzc2FnZUNvbnRlbnREZWx0YSxcbiAgICB0eXBlIE1lc3NhZ2VDb250ZW50UGFydFBhcmFtIGFzIE1lc3NhZ2VDb250ZW50UGFydFBhcmFtLFxuICAgIHR5cGUgTWVzc2FnZURlbGV0ZWQgYXMgTWVzc2FnZURlbGV0ZWQsXG4gICAgdHlwZSBNZXNzYWdlRGVsdGEgYXMgTWVzc2FnZURlbHRhLFxuICAgIHR5cGUgTWVzc2FnZURlbHRhRXZlbnQgYXMgTWVzc2FnZURlbHRhRXZlbnQsXG4gICAgdHlwZSBSZWZ1c2FsQ29udGVudEJsb2NrIGFzIFJlZnVzYWxDb250ZW50QmxvY2ssXG4gICAgdHlwZSBSZWZ1c2FsRGVsdGFCbG9jayBhcyBSZWZ1c2FsRGVsdGFCbG9jayxcbiAgICB0eXBlIFRleHQgYXMgVGV4dCxcbiAgICB0eXBlIFRleHRDb250ZW50QmxvY2sgYXMgVGV4dENvbnRlbnRCbG9jayxcbiAgICB0eXBlIFRleHRDb250ZW50QmxvY2tQYXJhbSBhcyBUZXh0Q29udGVudEJsb2NrUGFyYW0sXG4gICAgdHlwZSBUZXh0RGVsdGEgYXMgVGV4dERlbHRhLFxuICAgIHR5cGUgVGV4dERlbHRhQmxvY2sgYXMgVGV4dERlbHRhQmxvY2ssXG4gICAgTWVzc2FnZXNQYWdlIGFzIE1lc3NhZ2VzUGFnZSxcbiAgICB0eXBlIE1lc3NhZ2VDcmVhdGVQYXJhbXMgYXMgTWVzc2FnZUNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIE1lc3NhZ2VVcGRhdGVQYXJhbXMgYXMgTWVzc2FnZVVwZGF0ZVBhcmFtcyxcbiAgICB0eXBlIE1lc3NhZ2VMaXN0UGFyYW1zIGFzIE1lc3NhZ2VMaXN0UGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIFN0ZXBzQVBJIGZyb20gJy4vc3RlcHMnO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSwgdHlwZSBDdXJzb3JQYWdlUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vLi4vcGFnaW5hdGlvbic7XG5cbmV4cG9ydCBjbGFzcyBTdGVwcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIHJ1biBzdGVwLlxuICAgKi9cbiAgcmV0cmlldmUoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIHN0ZXBJZDogc3RyaW5nLFxuICAgIHF1ZXJ5PzogU3RlcFJldHJpZXZlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8UnVuU3RlcD47XG4gIHJldHJpZXZlKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBzdGVwSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFJ1blN0ZXA+O1xuICByZXRyaWV2ZShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgc3RlcElkOiBzdHJpbmcsXG4gICAgcXVlcnk6IFN0ZXBSZXRyaWV2ZVBhcmFtcyB8IENvcmUuUmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFJ1blN0ZXA+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldHJpZXZlKHRocmVhZElkLCBydW5JZCwgc3RlcElkLCB7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfS9zdGVwcy8ke3N0ZXBJZH1gLCB7XG4gICAgICBxdWVyeSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHJ1biBzdGVwcyBiZWxvbmdpbmcgdG8gYSBydW4uXG4gICAqL1xuICBsaXN0KFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBxdWVyeT86IFN0ZXBMaXN0UGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFJ1blN0ZXBzUGFnZSwgUnVuU3RlcD47XG4gIGxpc3QoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFJ1blN0ZXBzUGFnZSwgUnVuU3RlcD47XG4gIGxpc3QoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIHF1ZXJ5OiBTdGVwTGlzdFBhcmFtcyB8IENvcmUuUmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxSdW5TdGVwc1BhZ2UsIFJ1blN0ZXA+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3QodGhyZWFkSWQsIHJ1bklkLCB7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH0vc3RlcHNgLCBSdW5TdGVwc1BhZ2UsIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJ1blN0ZXBzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8UnVuU3RlcD4ge31cblxuLyoqXG4gKiBUZXh0IG91dHB1dCBmcm9tIHRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbCBhcyBwYXJ0IG9mIGEgcnVuIHN0ZXAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyTG9ncyB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpbiB0aGUgb3V0cHV0cyBhcnJheS5cbiAgICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgbG9nc2AuXG4gICAqL1xuICB0eXBlOiAnbG9ncyc7XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IG91dHB1dCBmcm9tIHRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbC5cbiAgICovXG4gIGxvZ3M/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyT3V0cHV0SW1hZ2Uge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaW4gdGhlIG91dHB1dHMgYXJyYXkuXG4gICAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYGltYWdlYC5cbiAgICovXG4gIHR5cGU6ICdpbWFnZSc7XG5cbiAgaW1hZ2U/OiBDb2RlSW50ZXJwcmV0ZXJPdXRwdXRJbWFnZS5JbWFnZTtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDb2RlSW50ZXJwcmV0ZXJPdXRwdXRJbWFnZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgSW1hZ2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSUQgb2YgdGhlXG4gICAgICogaW1hZ2UuXG4gICAgICovXG4gICAgZmlsZV9pZD86IHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIERldGFpbHMgb2YgdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsIHRoZSBydW4gc3RlcCB3YXMgaW52b2x2ZWQgaW4uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyVG9vbENhbGwge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwgZGVmaW5pdGlvbi5cbiAgICovXG4gIGNvZGVfaW50ZXJwcmV0ZXI6IENvZGVJbnRlcnByZXRlclRvb2xDYWxsLkNvZGVJbnRlcnByZXRlcjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdG9vbCBjYWxsLiBUaGlzIGlzIGFsd2F5cyBnb2luZyB0byBiZSBgY29kZV9pbnRlcnByZXRlcmAgZm9yIHRoaXNcbiAgICogdHlwZSBvZiB0b29sIGNhbGwuXG4gICAqL1xuICB0eXBlOiAnY29kZV9pbnRlcnByZXRlcic7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29kZUludGVycHJldGVyVG9vbENhbGwge1xuICAvKipcbiAgICogVGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsIGRlZmluaXRpb24uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgLyoqXG4gICAgICogVGhlIGlucHV0IHRvIHRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbC5cbiAgICAgKi9cbiAgICBpbnB1dDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dHMgZnJvbSB0aGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwuIENvZGUgSW50ZXJwcmV0ZXIgY2FuIG91dHB1dCBvbmVcbiAgICAgKiBvciBtb3JlIGl0ZW1zLCBpbmNsdWRpbmcgdGV4dCAoYGxvZ3NgKSBvciBpbWFnZXMgKGBpbWFnZWApLiBFYWNoIG9mIHRoZXNlIGFyZVxuICAgICAqIHJlcHJlc2VudGVkIGJ5IGEgZGlmZmVyZW50IG9iamVjdCB0eXBlLlxuICAgICAqL1xuICAgIG91dHB1dHM6IEFycmF5PENvZGVJbnRlcnByZXRlci5Mb2dzIHwgQ29kZUludGVycHJldGVyLkltYWdlPjtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAvKipcbiAgICAgKiBUZXh0IG91dHB1dCBmcm9tIHRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbCBhcyBwYXJ0IG9mIGEgcnVuIHN0ZXAuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBMb2dzIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRleHQgb3V0cHV0IGZyb20gdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsLlxuICAgICAgICovXG4gICAgICBsb2dzOiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogQWx3YXlzIGBsb2dzYC5cbiAgICAgICAqL1xuICAgICAgdHlwZTogJ2xvZ3MnO1xuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgSW1hZ2Uge1xuICAgICAgaW1hZ2U6IEltYWdlLkltYWdlO1xuXG4gICAgICAvKipcbiAgICAgICAqIEFsd2F5cyBgaW1hZ2VgLlxuICAgICAgICovXG4gICAgICB0eXBlOiAnaW1hZ2UnO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgSW1hZ2Uge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBJbWFnZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEIG9mIHRoZVxuICAgICAgICAgKiBpbWFnZS5cbiAgICAgICAgICovXG4gICAgICAgIGZpbGVfaWQ6IHN0cmluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRhaWxzIG9mIHRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbCB0aGUgcnVuIHN0ZXAgd2FzIGludm9sdmVkIGluLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlclRvb2xDYWxsRGVsdGEge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSB0b29sIGNhbGwgaW4gdGhlIHRvb2wgY2FsbHMgYXJyYXkuXG4gICAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0b29sIGNhbGwuIFRoaXMgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIGBjb2RlX2ludGVycHJldGVyYCBmb3IgdGhpc1xuICAgKiB0eXBlIG9mIHRvb2wgY2FsbC5cbiAgICovXG4gIHR5cGU6ICdjb2RlX2ludGVycHJldGVyJztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwuXG4gICAqL1xuICBpZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsIGRlZmluaXRpb24uXG4gICAqL1xuICBjb2RlX2ludGVycHJldGVyPzogQ29kZUludGVycHJldGVyVG9vbENhbGxEZWx0YS5Db2RlSW50ZXJwcmV0ZXI7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29kZUludGVycHJldGVyVG9vbENhbGxEZWx0YSB7XG4gIC8qKlxuICAgKiBUaGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwgZGVmaW5pdGlvbi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5wdXQgdG8gdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsLlxuICAgICAqL1xuICAgIGlucHV0Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dHMgZnJvbSB0aGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwuIENvZGUgSW50ZXJwcmV0ZXIgY2FuIG91dHB1dCBvbmVcbiAgICAgKiBvciBtb3JlIGl0ZW1zLCBpbmNsdWRpbmcgdGV4dCAoYGxvZ3NgKSBvciBpbWFnZXMgKGBpbWFnZWApLiBFYWNoIG9mIHRoZXNlIGFyZVxuICAgICAqIHJlcHJlc2VudGVkIGJ5IGEgZGlmZmVyZW50IG9iamVjdCB0eXBlLlxuICAgICAqL1xuICAgIG91dHB1dHM/OiBBcnJheTxTdGVwc0FQSS5Db2RlSW50ZXJwcmV0ZXJMb2dzIHwgU3RlcHNBUEkuQ29kZUludGVycHJldGVyT3V0cHV0SW1hZ2U+O1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaFRvb2xDYWxsIHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsIG9iamVjdC5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZvciBub3csIHRoaXMgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIGFuIGVtcHR5IG9iamVjdC5cbiAgICovXG4gIGZpbGVfc2VhcmNoOiBGaWxlU2VhcmNoVG9vbENhbGwuRmlsZVNlYXJjaDtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdG9vbCBjYWxsLiBUaGlzIGlzIGFsd2F5cyBnb2luZyB0byBiZSBgZmlsZV9zZWFyY2hgIGZvciB0aGlzIHR5cGUgb2ZcbiAgICogdG9vbCBjYWxsLlxuICAgKi9cbiAgdHlwZTogJ2ZpbGVfc2VhcmNoJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaWxlU2VhcmNoVG9vbENhbGwge1xuICAvKipcbiAgICogRm9yIG5vdywgdGhpcyBpcyBhbHdheXMgZ29pbmcgdG8gYmUgYW4gZW1wdHkgb2JqZWN0LlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcmFua2luZyBvcHRpb25zIGZvciB0aGUgZmlsZSBzZWFyY2guXG4gICAgICovXG4gICAgcmFua2luZ19vcHRpb25zPzogRmlsZVNlYXJjaC5SYW5raW5nT3B0aW9ucztcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHRzIG9mIHRoZSBmaWxlIHNlYXJjaC5cbiAgICAgKi9cbiAgICByZXN1bHRzPzogQXJyYXk8RmlsZVNlYXJjaC5SZXN1bHQ+O1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBGaWxlU2VhcmNoIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcmFua2luZyBvcHRpb25zIGZvciB0aGUgZmlsZSBzZWFyY2guXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBSYW5raW5nT3B0aW9ucyB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSByYW5rZXIgdXNlZCBmb3IgdGhlIGZpbGUgc2VhcmNoLlxuICAgICAgICovXG4gICAgICByYW5rZXI6ICdkZWZhdWx0XzIwMjRfMDhfMjEnO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBzY29yZSB0aHJlc2hvbGQgZm9yIHRoZSBmaWxlIHNlYXJjaC4gQWxsIHZhbHVlcyBtdXN0IGJlIGEgZmxvYXRpbmcgcG9pbnRcbiAgICAgICAqIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICAgKi9cbiAgICAgIHNjb3JlX3RocmVzaG9sZDogbnVtYmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgcmVzdWx0IGluc3RhbmNlIG9mIHRoZSBmaWxlIHNlYXJjaC5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIFJlc3VsdCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBJRCBvZiB0aGUgZmlsZSB0aGF0IHJlc3VsdCB3YXMgZm91bmQgaW4uXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWQ6IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0aGF0IHJlc3VsdCB3YXMgZm91bmQgaW4uXG4gICAgICAgKi9cbiAgICAgIGZpbGVfbmFtZTogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBzY29yZSBvZiB0aGUgcmVzdWx0LiBBbGwgdmFsdWVzIG11c3QgYmUgYSBmbG9hdGluZyBwb2ludCBudW1iZXIgYmV0d2VlbiAwXG4gICAgICAgKiBhbmQgMS5cbiAgICAgICAqL1xuICAgICAgc2NvcmU6IG51bWJlcjtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY29udGVudCBvZiB0aGUgcmVzdWx0IHRoYXQgd2FzIGZvdW5kLiBUaGUgY29udGVudCBpcyBvbmx5IGluY2x1ZGVkIGlmXG4gICAgICAgKiByZXF1ZXN0ZWQgdmlhIHRoZSBpbmNsdWRlIHF1ZXJ5IHBhcmFtZXRlci5cbiAgICAgICAqL1xuICAgICAgY29udGVudD86IEFycmF5PFJlc3VsdC5Db250ZW50PjtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIFJlc3VsdCB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIENvbnRlbnQge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgY29udGVudCBvZiB0aGUgZmlsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRleHQ/OiBzdHJpbmc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBjb250ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZT86ICd0ZXh0JztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoVG9vbENhbGxEZWx0YSB7XG4gIC8qKlxuICAgKiBGb3Igbm93LCB0aGlzIGlzIGFsd2F5cyBnb2luZyB0byBiZSBhbiBlbXB0eSBvYmplY3QuXG4gICAqL1xuICBmaWxlX3NlYXJjaDogdW5rbm93bjtcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSB0b29sIGNhbGwgaW4gdGhlIHRvb2wgY2FsbHMgYXJyYXkuXG4gICAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0b29sIGNhbGwuIFRoaXMgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIGBmaWxlX3NlYXJjaGAgZm9yIHRoaXMgdHlwZSBvZlxuICAgKiB0b29sIGNhbGwuXG4gICAqL1xuICB0eXBlOiAnZmlsZV9zZWFyY2gnO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbCBvYmplY3QuXG4gICAqL1xuICBpZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvblRvb2xDYWxsIHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsIG9iamVjdC5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZpbml0aW9uIG9mIHRoZSBmdW5jdGlvbiB0aGF0IHdhcyBjYWxsZWQuXG4gICAqL1xuICBmdW5jdGlvbjogRnVuY3Rpb25Ub29sQ2FsbC5GdW5jdGlvbjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdG9vbCBjYWxsLiBUaGlzIGlzIGFsd2F5cyBnb2luZyB0byBiZSBgZnVuY3Rpb25gIGZvciB0aGlzIHR5cGUgb2ZcbiAgICogdG9vbCBjYWxsLlxuICAgKi9cbiAgdHlwZTogJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGdW5jdGlvblRvb2xDYWxsIHtcbiAgLyoqXG4gICAqIFRoZSBkZWZpbml0aW9uIG9mIHRoZSBmdW5jdGlvbiB0aGF0IHdhcyBjYWxsZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXJndW1lbnRzOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dCBvZiB0aGUgZnVuY3Rpb24uIFRoaXMgd2lsbCBiZSBgbnVsbGAgaWYgdGhlIG91dHB1dHMgaGF2ZSBub3QgYmVlblxuICAgICAqIFtzdWJtaXR0ZWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9zdWJtaXRUb29sT3V0cHV0cylcbiAgICAgKiB5ZXQuXG4gICAgICovXG4gICAgb3V0cHV0OiBzdHJpbmcgfCBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25Ub29sQ2FsbERlbHRhIHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgdG9vbCBjYWxsIGluIHRoZSB0b29sIGNhbGxzIGFycmF5LlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdG9vbCBjYWxsLiBUaGlzIGlzIGFsd2F5cyBnb2luZyB0byBiZSBgZnVuY3Rpb25gIGZvciB0aGlzIHR5cGUgb2ZcbiAgICogdG9vbCBjYWxsLlxuICAgKi9cbiAgdHlwZTogJ2Z1bmN0aW9uJztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwgb2JqZWN0LlxuICAgKi9cbiAgaWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZpbml0aW9uIG9mIHRoZSBmdW5jdGlvbiB0aGF0IHdhcyBjYWxsZWQuXG4gICAqL1xuICBmdW5jdGlvbj86IEZ1bmN0aW9uVG9vbENhbGxEZWx0YS5GdW5jdGlvbjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGdW5jdGlvblRvb2xDYWxsRGVsdGEge1xuICAvKipcbiAgICogVGhlIGRlZmluaXRpb24gb2YgdGhlIGZ1bmN0aW9uIHRoYXQgd2FzIGNhbGxlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBhcmd1bWVudHM/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbmFtZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBvdXRwdXQgb2YgdGhlIGZ1bmN0aW9uLiBUaGlzIHdpbGwgYmUgYG51bGxgIGlmIHRoZSBvdXRwdXRzIGhhdmUgbm90IGJlZW5cbiAgICAgKiBbc3VibWl0dGVkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvc3VibWl0VG9vbE91dHB1dHMpXG4gICAgICogeWV0LlxuICAgICAqL1xuICAgIG91dHB1dD86IHN0cmluZyB8IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRhaWxzIG9mIHRoZSBtZXNzYWdlIGNyZWF0aW9uIGJ5IHRoZSBydW4gc3RlcC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlQ3JlYXRpb25TdGVwRGV0YWlscyB7XG4gIG1lc3NhZ2VfY3JlYXRpb246IE1lc3NhZ2VDcmVhdGlvblN0ZXBEZXRhaWxzLk1lc3NhZ2VDcmVhdGlvbjtcblxuICAvKipcbiAgICogQWx3YXlzIGBtZXNzYWdlX2NyZWF0aW9uYC5cbiAgICovXG4gIHR5cGU6ICdtZXNzYWdlX2NyZWF0aW9uJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBNZXNzYWdlQ3JlYXRpb25TdGVwRGV0YWlscyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZUNyZWF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIG1lc3NhZ2UgdGhhdCB3YXMgY3JlYXRlZCBieSB0aGlzIHJ1biBzdGVwLlxuICAgICAqL1xuICAgIG1lc3NhZ2VfaWQ6IHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSdW5TdGVwIHtcbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBydW4gc3RlcCwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGVcbiAgICogW2Fzc2lzdGFudF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKVxuICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHJ1biBzdGVwLlxuICAgKi9cbiAgYXNzaXN0YW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHJ1biBzdGVwIHdhcyBjYW5jZWxsZWQuXG4gICAqL1xuICBjYW5jZWxsZWRfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHJ1biBzdGVwIGNvbXBsZXRlZC5cbiAgICovXG4gIGNvbXBsZXRlZF9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHN0ZXAgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHJ1biBzdGVwIGV4cGlyZWQuIEEgc3RlcCBpc1xuICAgKiBjb25zaWRlcmVkIGV4cGlyZWQgaWYgdGhlIHBhcmVudCBydW4gaXMgZXhwaXJlZC5cbiAgICovXG4gIGV4cGlyZWRfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHJ1biBzdGVwIGZhaWxlZC5cbiAgICovXG4gIGZhaWxlZF9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGxhc3QgZXJyb3IgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcnVuIHN0ZXAuIFdpbGwgYmUgYG51bGxgIGlmIHRoZXJlIGFyZSBub1xuICAgKiBlcnJvcnMuXG4gICAqL1xuICBsYXN0X2Vycm9yOiBSdW5TdGVwLkxhc3RFcnJvciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhOiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYHRocmVhZC5ydW4uc3RlcGAuXG4gICAqL1xuICBvYmplY3Q6ICd0aHJlYWQucnVuLnN0ZXAnO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucykgdGhhdFxuICAgKiB0aGlzIHJ1biBzdGVwIGlzIGEgcGFydCBvZi5cbiAgICovXG4gIHJ1bl9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhdHVzIG9mIHRoZSBydW4gc3RlcCwgd2hpY2ggY2FuIGJlIGVpdGhlciBgaW5fcHJvZ3Jlc3NgLCBgY2FuY2VsbGVkYCxcbiAgICogYGZhaWxlZGAsIGBjb21wbGV0ZWRgLCBvciBgZXhwaXJlZGAuXG4gICAqL1xuICBzdGF0dXM6ICdpbl9wcm9ncmVzcycgfCAnY2FuY2VsbGVkJyB8ICdmYWlsZWQnIHwgJ2NvbXBsZXRlZCcgfCAnZXhwaXJlZCc7XG5cbiAgLyoqXG4gICAqIFRoZSBkZXRhaWxzIG9mIHRoZSBydW4gc3RlcC5cbiAgICovXG4gIHN0ZXBfZGV0YWlsczogTWVzc2FnZUNyZWF0aW9uU3RlcERldGFpbHMgfCBUb29sQ2FsbHNTdGVwRGV0YWlscztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpXG4gICAqIHRoYXQgd2FzIHJ1bi5cbiAgICovXG4gIHRocmVhZF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBydW4gc3RlcCwgd2hpY2ggY2FuIGJlIGVpdGhlciBgbWVzc2FnZV9jcmVhdGlvbmAgb3IgYHRvb2xfY2FsbHNgLlxuICAgKi9cbiAgdHlwZTogJ21lc3NhZ2VfY3JlYXRpb24nIHwgJ3Rvb2xfY2FsbHMnO1xuXG4gIC8qKlxuICAgKiBVc2FnZSBzdGF0aXN0aWNzIHJlbGF0ZWQgdG8gdGhlIHJ1biBzdGVwLiBUaGlzIHZhbHVlIHdpbGwgYmUgYG51bGxgIHdoaWxlIHRoZVxuICAgKiBydW4gc3RlcCdzIHN0YXR1cyBpcyBgaW5fcHJvZ3Jlc3NgLlxuICAgKi9cbiAgdXNhZ2U6IFJ1blN0ZXAuVXNhZ2UgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJ1blN0ZXAge1xuICAvKipcbiAgICogVGhlIGxhc3QgZXJyb3IgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcnVuIHN0ZXAuIFdpbGwgYmUgYG51bGxgIGlmIHRoZXJlIGFyZSBub1xuICAgKiBlcnJvcnMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIExhc3RFcnJvciB7XG4gICAgLyoqXG4gICAgICogT25lIG9mIGBzZXJ2ZXJfZXJyb3JgIG9yIGByYXRlX2xpbWl0X2V4Y2VlZGVkYC5cbiAgICAgKi9cbiAgICBjb2RlOiAnc2VydmVyX2Vycm9yJyB8ICdyYXRlX2xpbWl0X2V4Y2VlZGVkJztcblxuICAgIC8qKlxuICAgICAqIEEgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGVycm9yLlxuICAgICAqL1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2FnZSBzdGF0aXN0aWNzIHJlbGF0ZWQgdG8gdGhlIHJ1biBzdGVwLiBUaGlzIHZhbHVlIHdpbGwgYmUgYG51bGxgIHdoaWxlIHRoZVxuICAgKiBydW4gc3RlcCdzIHN0YXR1cyBpcyBgaW5fcHJvZ3Jlc3NgLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBVc2FnZSB7XG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBydW4gc3RlcC5cbiAgICAgKi9cbiAgICBjb21wbGV0aW9uX3Rva2VuczogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHByb21wdCB0b2tlbnMgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1biBzdGVwLlxuICAgICAqL1xuICAgIHByb21wdF90b2tlbnM6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRvdGFsIG51bWJlciBvZiB0b2tlbnMgdXNlZCAocHJvbXB0ICsgY29tcGxldGlvbikuXG4gICAgICovXG4gICAgdG90YWxfdG9rZW5zOiBudW1iZXI7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgZGVsdGEgY29udGFpbmluZyB0aGUgZmllbGRzIHRoYXQgaGF2ZSBjaGFuZ2VkIG9uIHRoZSBydW4gc3RlcC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSdW5TdGVwRGVsdGEge1xuICAvKipcbiAgICogVGhlIGRldGFpbHMgb2YgdGhlIHJ1biBzdGVwLlxuICAgKi9cbiAgc3RlcF9kZXRhaWxzPzogUnVuU3RlcERlbHRhTWVzc2FnZURlbHRhIHwgVG9vbENhbGxEZWx0YU9iamVjdDtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcnVuIHN0ZXAgZGVsdGEgaS5lLiBhbnkgY2hhbmdlZCBmaWVsZHMgb24gYSBydW4gc3RlcCBkdXJpbmdcbiAqIHN0cmVhbWluZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSdW5TdGVwRGVsdGFFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgcnVuIHN0ZXAsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVsdGEgY29udGFpbmluZyB0aGUgZmllbGRzIHRoYXQgaGF2ZSBjaGFuZ2VkIG9uIHRoZSBydW4gc3RlcC5cbiAgICovXG4gIGRlbHRhOiBSdW5TdGVwRGVsdGE7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGB0aHJlYWQucnVuLnN0ZXAuZGVsdGFgLlxuICAgKi9cbiAgb2JqZWN0OiAndGhyZWFkLnJ1bi5zdGVwLmRlbHRhJztcbn1cblxuLyoqXG4gKiBEZXRhaWxzIG9mIHRoZSBtZXNzYWdlIGNyZWF0aW9uIGJ5IHRoZSBydW4gc3RlcC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSdW5TdGVwRGVsdGFNZXNzYWdlRGVsdGEge1xuICAvKipcbiAgICogQWx3YXlzIGBtZXNzYWdlX2NyZWF0aW9uYC5cbiAgICovXG4gIHR5cGU6ICdtZXNzYWdlX2NyZWF0aW9uJztcblxuICBtZXNzYWdlX2NyZWF0aW9uPzogUnVuU3RlcERlbHRhTWVzc2FnZURlbHRhLk1lc3NhZ2VDcmVhdGlvbjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSdW5TdGVwRGVsdGFNZXNzYWdlRGVsdGEge1xuICBleHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VDcmVhdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBtZXNzYWdlIHRoYXQgd2FzIGNyZWF0ZWQgYnkgdGhpcyBydW4gc3RlcC5cbiAgICAgKi9cbiAgICBtZXNzYWdlX2lkPzogc3RyaW5nO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFJ1blN0ZXBJbmNsdWRlID0gJ3N0ZXBfZGV0YWlscy50b29sX2NhbGxzWypdLmZpbGVfc2VhcmNoLnJlc3VsdHNbKl0uY29udGVudCc7XG5cbi8qKlxuICogRGV0YWlscyBvZiB0aGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwgdGhlIHJ1biBzdGVwIHdhcyBpbnZvbHZlZCBpbi5cbiAqL1xuZXhwb3J0IHR5cGUgVG9vbENhbGwgPSBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbCB8IEZpbGVTZWFyY2hUb29sQ2FsbCB8IEZ1bmN0aW9uVG9vbENhbGw7XG5cbi8qKlxuICogRGV0YWlscyBvZiB0aGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwgdGhlIHJ1biBzdGVwIHdhcyBpbnZvbHZlZCBpbi5cbiAqL1xuZXhwb3J0IHR5cGUgVG9vbENhbGxEZWx0YSA9IENvZGVJbnRlcnByZXRlclRvb2xDYWxsRGVsdGEgfCBGaWxlU2VhcmNoVG9vbENhbGxEZWx0YSB8IEZ1bmN0aW9uVG9vbENhbGxEZWx0YTtcblxuLyoqXG4gKiBEZXRhaWxzIG9mIHRoZSB0b29sIGNhbGwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbENhbGxEZWx0YU9iamVjdCB7XG4gIC8qKlxuICAgKiBBbHdheXMgYHRvb2xfY2FsbHNgLlxuICAgKi9cbiAgdHlwZTogJ3Rvb2xfY2FsbHMnO1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiB0b29sIGNhbGxzIHRoZSBydW4gc3RlcCB3YXMgaW52b2x2ZWQgaW4uIFRoZXNlIGNhbiBiZSBhc3NvY2lhdGVkXG4gICAqIHdpdGggb25lIG9mIHRocmVlIHR5cGVzIG9mIHRvb2xzOiBgY29kZV9pbnRlcnByZXRlcmAsIGBmaWxlX3NlYXJjaGAsIG9yXG4gICAqIGBmdW5jdGlvbmAuXG4gICAqL1xuICB0b29sX2NhbGxzPzogQXJyYXk8VG9vbENhbGxEZWx0YT47XG59XG5cbi8qKlxuICogRGV0YWlscyBvZiB0aGUgdG9vbCBjYWxsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRvb2xDYWxsc1N0ZXBEZXRhaWxzIHtcbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIHRvb2wgY2FsbHMgdGhlIHJ1biBzdGVwIHdhcyBpbnZvbHZlZCBpbi4gVGhlc2UgY2FuIGJlIGFzc29jaWF0ZWRcbiAgICogd2l0aCBvbmUgb2YgdGhyZWUgdHlwZXMgb2YgdG9vbHM6IGBjb2RlX2ludGVycHJldGVyYCwgYGZpbGVfc2VhcmNoYCwgb3JcbiAgICogYGZ1bmN0aW9uYC5cbiAgICovXG4gIHRvb2xfY2FsbHM6IEFycmF5PFRvb2xDYWxsPjtcblxuICAvKipcbiAgICogQWx3YXlzIGB0b29sX2NhbGxzYC5cbiAgICovXG4gIHR5cGU6ICd0b29sX2NhbGxzJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGVwUmV0cmlldmVQYXJhbXMge1xuICAvKipcbiAgICogQSBsaXN0IG9mIGFkZGl0aW9uYWwgZmllbGRzIHRvIGluY2x1ZGUgaW4gdGhlIHJlc3BvbnNlLiBDdXJyZW50bHkgdGhlIG9ubHlcbiAgICogc3VwcG9ydGVkIHZhbHVlIGlzIGBzdGVwX2RldGFpbHMudG9vbF9jYWxsc1sqXS5maWxlX3NlYXJjaC5yZXN1bHRzWypdLmNvbnRlbnRgXG4gICAqIHRvIGZldGNoIHRoZSBmaWxlIHNlYXJjaCByZXN1bHQgY29udGVudC5cbiAgICpcbiAgICogU2VlIHRoZVxuICAgKiBbZmlsZSBzZWFyY2ggdG9vbCBkb2N1bWVudGF0aW9uXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL3Rvb2xzL2ZpbGUtc2VhcmNoI2N1c3RvbWl6aW5nLWZpbGUtc2VhcmNoLXNldHRpbmdzKVxuICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGluY2x1ZGU/OiBBcnJheTxSdW5TdGVwSW5jbHVkZT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RlcExpc3RQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgY3Vyc29yIGZvciB1c2UgaW4gcGFnaW5hdGlvbi4gYGJlZm9yZWAgaXMgYW4gb2JqZWN0IElEIHRoYXQgZGVmaW5lcyB5b3VyIHBsYWNlXG4gICAqIGluIHRoZSBsaXN0LiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBtYWtlIGEgbGlzdCByZXF1ZXN0IGFuZCByZWNlaXZlIDEwMCBvYmplY3RzLFxuICAgKiBzdGFydGluZyB3aXRoIG9ial9mb28sIHlvdXIgc3Vic2VxdWVudCBjYWxsIGNhbiBpbmNsdWRlIGJlZm9yZT1vYmpfZm9vIGluIG9yZGVyXG4gICAqIHRvIGZldGNoIHRoZSBwcmV2aW91cyBwYWdlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgYmVmb3JlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgYWRkaXRpb25hbCBmaWVsZHMgdG8gaW5jbHVkZSBpbiB0aGUgcmVzcG9uc2UuIEN1cnJlbnRseSB0aGUgb25seVxuICAgKiBzdXBwb3J0ZWQgdmFsdWUgaXMgYHN0ZXBfZGV0YWlscy50b29sX2NhbGxzWypdLmZpbGVfc2VhcmNoLnJlc3VsdHNbKl0uY29udGVudGBcbiAgICogdG8gZmV0Y2ggdGhlIGZpbGUgc2VhcmNoIHJlc3VsdCBjb250ZW50LlxuICAgKlxuICAgKiBTZWUgdGhlXG4gICAqIFtmaWxlIHNlYXJjaCB0b29sIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvdG9vbHMvZmlsZS1zZWFyY2gjY3VzdG9taXppbmctZmlsZS1zZWFyY2gtc2V0dGluZ3MpXG4gICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgaW5jbHVkZT86IEFycmF5PFJ1blN0ZXBJbmNsdWRlPjtcblxuICAvKipcbiAgICogU29ydCBvcmRlciBieSB0aGUgYGNyZWF0ZWRfYXRgIHRpbWVzdGFtcCBvZiB0aGUgb2JqZWN0cy4gYGFzY2AgZm9yIGFzY2VuZGluZ1xuICAgKiBvcmRlciBhbmQgYGRlc2NgIGZvciBkZXNjZW5kaW5nIG9yZGVyLlxuICAgKi9cbiAgb3JkZXI/OiAnYXNjJyB8ICdkZXNjJztcbn1cblxuU3RlcHMuUnVuU3RlcHNQYWdlID0gUnVuU3RlcHNQYWdlO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgU3RlcHMge1xuICBleHBvcnQge1xuICAgIHR5cGUgQ29kZUludGVycHJldGVyTG9ncyBhcyBDb2RlSW50ZXJwcmV0ZXJMb2dzLFxuICAgIHR5cGUgQ29kZUludGVycHJldGVyT3V0cHV0SW1hZ2UgYXMgQ29kZUludGVycHJldGVyT3V0cHV0SW1hZ2UsXG4gICAgdHlwZSBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbCBhcyBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbCxcbiAgICB0eXBlIENvZGVJbnRlcnByZXRlclRvb2xDYWxsRGVsdGEgYXMgQ29kZUludGVycHJldGVyVG9vbENhbGxEZWx0YSxcbiAgICB0eXBlIEZpbGVTZWFyY2hUb29sQ2FsbCBhcyBGaWxlU2VhcmNoVG9vbENhbGwsXG4gICAgdHlwZSBGaWxlU2VhcmNoVG9vbENhbGxEZWx0YSBhcyBGaWxlU2VhcmNoVG9vbENhbGxEZWx0YSxcbiAgICB0eXBlIEZ1bmN0aW9uVG9vbENhbGwgYXMgRnVuY3Rpb25Ub29sQ2FsbCxcbiAgICB0eXBlIEZ1bmN0aW9uVG9vbENhbGxEZWx0YSBhcyBGdW5jdGlvblRvb2xDYWxsRGVsdGEsXG4gICAgdHlwZSBNZXNzYWdlQ3JlYXRpb25TdGVwRGV0YWlscyBhcyBNZXNzYWdlQ3JlYXRpb25TdGVwRGV0YWlscyxcbiAgICB0eXBlIFJ1blN0ZXAgYXMgUnVuU3RlcCxcbiAgICB0eXBlIFJ1blN0ZXBEZWx0YSBhcyBSdW5TdGVwRGVsdGEsXG4gICAgdHlwZSBSdW5TdGVwRGVsdGFFdmVudCBhcyBSdW5TdGVwRGVsdGFFdmVudCxcbiAgICB0eXBlIFJ1blN0ZXBEZWx0YU1lc3NhZ2VEZWx0YSBhcyBSdW5TdGVwRGVsdGFNZXNzYWdlRGVsdGEsXG4gICAgdHlwZSBSdW5TdGVwSW5jbHVkZSBhcyBSdW5TdGVwSW5jbHVkZSxcbiAgICB0eXBlIFRvb2xDYWxsIGFzIFRvb2xDYWxsLFxuICAgIHR5cGUgVG9vbENhbGxEZWx0YSBhcyBUb29sQ2FsbERlbHRhLFxuICAgIHR5cGUgVG9vbENhbGxEZWx0YU9iamVjdCBhcyBUb29sQ2FsbERlbHRhT2JqZWN0LFxuICAgIHR5cGUgVG9vbENhbGxzU3RlcERldGFpbHMgYXMgVG9vbENhbGxzU3RlcERldGFpbHMsXG4gICAgUnVuU3RlcHNQYWdlIGFzIFJ1blN0ZXBzUGFnZSxcbiAgICB0eXBlIFN0ZXBSZXRyaWV2ZVBhcmFtcyBhcyBTdGVwUmV0cmlldmVQYXJhbXMsXG4gICAgdHlwZSBTdGVwTGlzdFBhcmFtcyBhcyBTdGVwTGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi8uLi9jb3JlJztcbmltcG9ydCB7IEFQSVByb21pc2UgfSBmcm9tICcuLi8uLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgeyBBc3Npc3RhbnRTdHJlYW0sIFJ1bkNyZWF0ZVBhcmFtc0Jhc2VTdHJlYW0gfSBmcm9tICcuLi8uLi8uLi8uLi9saWIvQXNzaXN0YW50U3RyZWFtJztcbmltcG9ydCB7IHNsZWVwIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgeyBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbSB9IGZyb20gJy4uLy4uLy4uLy4uL2xpYi9Bc3Npc3RhbnRTdHJlYW0nO1xuaW1wb3J0ICogYXMgUnVuc0FQSSBmcm9tICcuL3J1bnMnO1xuaW1wb3J0ICogYXMgQXNzaXN0YW50c0FQSSBmcm9tICcuLi8uLi9hc3Npc3RhbnRzJztcbmltcG9ydCAqIGFzIENoYXRBUEkgZnJvbSAnLi4vLi4vLi4vY2hhdC9jaGF0JztcbmltcG9ydCAqIGFzIE1lc3NhZ2VzQVBJIGZyb20gJy4uL21lc3NhZ2VzJztcbmltcG9ydCAqIGFzIFRocmVhZHNBUEkgZnJvbSAnLi4vdGhyZWFkcyc7XG5pbXBvcnQgKiBhcyBTdGVwc0FQSSBmcm9tICcuL3N0ZXBzJztcbmltcG9ydCB7XG4gIENvZGVJbnRlcnByZXRlckxvZ3MsXG4gIENvZGVJbnRlcnByZXRlck91dHB1dEltYWdlLFxuICBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbCxcbiAgQ29kZUludGVycHJldGVyVG9vbENhbGxEZWx0YSxcbiAgRmlsZVNlYXJjaFRvb2xDYWxsLFxuICBGaWxlU2VhcmNoVG9vbENhbGxEZWx0YSxcbiAgRnVuY3Rpb25Ub29sQ2FsbCxcbiAgRnVuY3Rpb25Ub29sQ2FsbERlbHRhLFxuICBNZXNzYWdlQ3JlYXRpb25TdGVwRGV0YWlscyxcbiAgUnVuU3RlcCxcbiAgUnVuU3RlcERlbHRhLFxuICBSdW5TdGVwRGVsdGFFdmVudCxcbiAgUnVuU3RlcERlbHRhTWVzc2FnZURlbHRhLFxuICBSdW5TdGVwSW5jbHVkZSxcbiAgUnVuU3RlcHNQYWdlLFxuICBTdGVwTGlzdFBhcmFtcyxcbiAgU3RlcFJldHJpZXZlUGFyYW1zLFxuICBTdGVwcyxcbiAgVG9vbENhbGwsXG4gIFRvb2xDYWxsRGVsdGEsXG4gIFRvb2xDYWxsRGVsdGFPYmplY3QsXG4gIFRvb2xDYWxsc1N0ZXBEZXRhaWxzLFxufSBmcm9tICcuL3N0ZXBzJztcbmltcG9ydCB7IEN1cnNvclBhZ2UsIHR5cGUgQ3Vyc29yUGFnZVBhcmFtcyB9IGZyb20gJy4uLy4uLy4uLy4uL3BhZ2luYXRpb24nO1xuaW1wb3J0IHsgU3RyZWFtIH0gZnJvbSAnLi4vLi4vLi4vLi4vc3RyZWFtaW5nJztcblxuZXhwb3J0IGNsYXNzIFJ1bnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIHN0ZXBzOiBTdGVwc0FQSS5TdGVwcyA9IG5ldyBTdGVwc0FQSS5TdGVwcyh0aGlzLl9jbGllbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBydW4uXG4gICAqL1xuICBjcmVhdGUoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBwYXJhbXM6IFJ1bkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxSdW4+O1xuICBjcmVhdGUoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBwYXJhbXM6IFJ1bkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4+O1xuICBjcmVhdGUoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBwYXJhbXM6IFJ1bkNyZWF0ZVBhcmFtc0Jhc2UsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8U3RyZWFtPEFzc2lzdGFudHNBUEkuQXNzaXN0YW50U3RyZWFtRXZlbnQ+IHwgUnVuPjtcbiAgY3JlYXRlKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcGFyYW1zOiBSdW5DcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8UnVuPiB8IEFQSVByb21pc2U8U3RyZWFtPEFzc2lzdGFudHNBUEkuQXNzaXN0YW50U3RyZWFtRXZlbnQ+PiB7XG4gICAgY29uc3QgeyBpbmNsdWRlLCAuLi5ib2R5IH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zYCwge1xuICAgICAgcXVlcnk6IHsgaW5jbHVkZSB9LFxuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgc3RyZWFtOiBwYXJhbXMuc3RyZWFtID8/IGZhbHNlLFxuICAgIH0pIGFzIEFQSVByb21pc2U8UnVuPiB8IEFQSVByb21pc2U8U3RyZWFtPEFzc2lzdGFudHNBUEkuQXNzaXN0YW50U3RyZWFtRXZlbnQ+PjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBydW4uXG4gICAqL1xuICByZXRyaWV2ZSh0aHJlYWRJZDogc3RyaW5nLCBydW5JZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxSdW4+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfWAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIGEgcnVuLlxuICAgKi9cbiAgdXBkYXRlKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBib2R5OiBSdW5VcGRhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxSdW4+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH1gLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgcnVucyBiZWxvbmdpbmcgdG8gYSB0aHJlYWQuXG4gICAqL1xuICBsaXN0KFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcXVlcnk/OiBSdW5MaXN0UGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFJ1bnNQYWdlLCBSdW4+O1xuICBsaXN0KHRocmVhZElkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5QYWdlUHJvbWlzZTxSdW5zUGFnZSwgUnVuPjtcbiAgbGlzdChcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHF1ZXJ5OiBSdW5MaXN0UGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFJ1bnNQYWdlLCBSdW4+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3QodGhyZWFkSWQsIHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVuc2AsIFJ1bnNQYWdlLCB7XG4gICAgICBxdWVyeSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYSBydW4gdGhhdCBpcyBgaW5fcHJvZ3Jlc3NgLlxuICAgKi9cbiAgY2FuY2VsKHRocmVhZElkOiBzdHJpbmcsIHJ1bklkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFJ1bj4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfS9jYW5jZWxgLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGhlbHBlciB0byBjcmVhdGUgYSBydW4gYW4gcG9sbCBmb3IgYSB0ZXJtaW5hbCBzdGF0ZS4gTW9yZSBpbmZvcm1hdGlvbiBvbiBSdW5cbiAgICogbGlmZWN5Y2xlcyBjYW4gYmUgZm91bmQgaGVyZTpcbiAgICogaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy9ob3ctaXQtd29ya3MvcnVucy1hbmQtcnVuLXN0ZXBzXG4gICAqL1xuICBhc3luYyBjcmVhdGVBbmRQb2xsKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgYm9keTogUnVuQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zICYgeyBwb2xsSW50ZXJ2YWxNcz86IG51bWJlciB9LFxuICApOiBQcm9taXNlPFJ1bj4ge1xuICAgIGNvbnN0IHJ1biA9IGF3YWl0IHRoaXMuY3JlYXRlKHRocmVhZElkLCBib2R5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5wb2xsKHRocmVhZElkLCBydW4uaWQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFJ1biBzdHJlYW1cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBzdHJlYW1gIGluc3RlYWRcbiAgICovXG4gIGNyZWF0ZUFuZFN0cmVhbShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIGJvZHk6IFJ1bkNyZWF0ZVBhcmFtc0Jhc2VTdHJlYW0sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFzc2lzdGFudFN0cmVhbSB7XG4gICAgcmV0dXJuIEFzc2lzdGFudFN0cmVhbS5jcmVhdGVBc3Npc3RhbnRTdHJlYW0odGhyZWFkSWQsIHRoaXMuX2NsaWVudC5iZXRhLnRocmVhZHMucnVucywgYm9keSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQSBoZWxwZXIgdG8gcG9sbCBhIHJ1biBzdGF0dXMgdW50aWwgaXQgcmVhY2hlcyBhIHRlcm1pbmFsIHN0YXRlLiBNb3JlXG4gICAqIGluZm9ybWF0aW9uIG9uIFJ1biBsaWZlY3ljbGVzIGNhbiBiZSBmb3VuZCBoZXJlOlxuICAgKiBodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL2hvdy1pdC13b3Jrcy9ydW5zLWFuZC1ydW4tc3RlcHNcbiAgICovXG4gIGFzeW5jIHBvbGwoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zICYgeyBwb2xsSW50ZXJ2YWxNcz86IG51bWJlciB9LFxuICApOiBQcm9taXNlPFJ1bj4ge1xuICAgIGNvbnN0IGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1Qb2xsLUhlbHBlcic6ICd0cnVlJyB9O1xuXG4gICAgaWYgKG9wdGlvbnM/LnBvbGxJbnRlcnZhbE1zKSB7XG4gICAgICBoZWFkZXJzWydYLVN0YWlubGVzcy1DdXN0b20tUG9sbC1JbnRlcnZhbCddID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNcy50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRhdGE6IHJ1biwgcmVzcG9uc2UgfSA9IGF3YWl0IHRoaXMucmV0cmlldmUodGhyZWFkSWQsIHJ1bklkLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgLi4uaGVhZGVycyB9LFxuICAgICAgfSkud2l0aFJlc3BvbnNlKCk7XG5cbiAgICAgIHN3aXRjaCAocnVuLnN0YXR1cykge1xuICAgICAgICAvL0lmIHdlIGFyZSBpbiBhbnkgc29ydCBvZiBpbnRlcm1lZGlhdGUgc3RhdGUgd2UgcG9sbFxuICAgICAgICBjYXNlICdxdWV1ZWQnOlxuICAgICAgICBjYXNlICdpbl9wcm9ncmVzcyc6XG4gICAgICAgIGNhc2UgJ2NhbmNlbGxpbmcnOlxuICAgICAgICAgIGxldCBzbGVlcEludGVydmFsID0gNTAwMDtcblxuICAgICAgICAgIGlmIChvcHRpb25zPy5wb2xsSW50ZXJ2YWxNcykge1xuICAgICAgICAgICAgc2xlZXBJbnRlcnZhbCA9IG9wdGlvbnMucG9sbEludGVydmFsTXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlckludGVydmFsID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ29wZW5haS1wb2xsLWFmdGVyLW1zJyk7XG4gICAgICAgICAgICBpZiAoaGVhZGVySW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgY29uc3QgaGVhZGVySW50ZXJ2YWxNcyA9IHBhcnNlSW50KGhlYWRlckludGVydmFsKTtcbiAgICAgICAgICAgICAgaWYgKCFpc05hTihoZWFkZXJJbnRlcnZhbE1zKSkge1xuICAgICAgICAgICAgICAgIHNsZWVwSW50ZXJ2YWwgPSBoZWFkZXJJbnRlcnZhbE1zO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IHNsZWVwKHNsZWVwSW50ZXJ2YWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvL1dlIHJldHVybiB0aGUgcnVuIGluIGFueSB0ZXJtaW5hbCBzdGF0ZS5cbiAgICAgICAgY2FzZSAncmVxdWlyZXNfYWN0aW9uJzpcbiAgICAgICAgY2FzZSAnaW5jb21wbGV0ZSc6XG4gICAgICAgIGNhc2UgJ2NhbmNlbGxlZCc6XG4gICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgIGNhc2UgJ2V4cGlyZWQnOlxuICAgICAgICAgIHJldHVybiBydW47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFJ1biBzdHJlYW1cbiAgICovXG4gIHN0cmVhbSh0aHJlYWRJZDogc3RyaW5nLCBib2R5OiBSdW5DcmVhdGVQYXJhbXNCYXNlU3RyZWFtLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IEFzc2lzdGFudFN0cmVhbSB7XG4gICAgcmV0dXJuIEFzc2lzdGFudFN0cmVhbS5jcmVhdGVBc3Npc3RhbnRTdHJlYW0odGhyZWFkSWQsIHRoaXMuX2NsaWVudC5iZXRhLnRocmVhZHMucnVucywgYm9keSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBhIHJ1biBoYXMgdGhlIGBzdGF0dXM6IFwicmVxdWlyZXNfYWN0aW9uXCJgIGFuZCBgcmVxdWlyZWRfYWN0aW9uLnR5cGVgIGlzXG4gICAqIGBzdWJtaXRfdG9vbF9vdXRwdXRzYCwgdGhpcyBlbmRwb2ludCBjYW4gYmUgdXNlZCB0byBzdWJtaXQgdGhlIG91dHB1dHMgZnJvbSB0aGVcbiAgICogdG9vbCBjYWxscyBvbmNlIHRoZXkncmUgYWxsIGNvbXBsZXRlZC4gQWxsIG91dHB1dHMgbXVzdCBiZSBzdWJtaXR0ZWQgaW4gYSBzaW5nbGVcbiAgICogcmVxdWVzdC5cbiAgICovXG4gIHN1Ym1pdFRvb2xPdXRwdXRzKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBib2R5OiBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc05vblN0cmVhbWluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxSdW4+O1xuICBzdWJtaXRUb29sT3V0cHV0cyhcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgYm9keTogUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8U3RyZWFtPEFzc2lzdGFudHNBUEkuQXNzaXN0YW50U3RyZWFtRXZlbnQ+PjtcbiAgc3VibWl0VG9vbE91dHB1dHMoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIGJvZHk6IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zQmFzZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4gfCBSdW4+O1xuICBzdWJtaXRUb29sT3V0cHV0cyhcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgYm9keTogUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8UnVuPiB8IEFQSVByb21pc2U8U3RyZWFtPEFzc2lzdGFudHNBUEkuQXNzaXN0YW50U3RyZWFtRXZlbnQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9L3N1Ym1pdF90b29sX291dHB1dHNgLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICBzdHJlYW06IGJvZHkuc3RyZWFtID8/IGZhbHNlLFxuICAgIH0pIGFzIEFQSVByb21pc2U8UnVuPiB8IEFQSVByb21pc2U8U3RyZWFtPEFzc2lzdGFudHNBUEkuQXNzaXN0YW50U3RyZWFtRXZlbnQ+PjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGhlbHBlciB0byBzdWJtaXQgYSB0b29sIG91dHB1dCB0byBhIHJ1biBhbmQgcG9sbCBmb3IgYSB0ZXJtaW5hbCBydW4gc3RhdGUuXG4gICAqIE1vcmUgaW5mb3JtYXRpb24gb24gUnVuIGxpZmVjeWNsZXMgY2FuIGJlIGZvdW5kIGhlcmU6XG4gICAqIGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvaG93LWl0LXdvcmtzL3J1bnMtYW5kLXJ1bi1zdGVwc1xuICAgKi9cbiAgYXN5bmMgc3VibWl0VG9vbE91dHB1dHNBbmRQb2xsKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBib2R5OiBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc05vblN0cmVhbWluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyAmIHsgcG9sbEludGVydmFsTXM/OiBudW1iZXIgfSxcbiAgKTogUHJvbWlzZTxSdW4+IHtcbiAgICBjb25zdCBydW4gPSBhd2FpdCB0aGlzLnN1Ym1pdFRvb2xPdXRwdXRzKHRocmVhZElkLCBydW5JZCwgYm9keSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucG9sbCh0aHJlYWRJZCwgcnVuLmlkLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJtaXQgdGhlIHRvb2wgb3V0cHV0cyBmcm9tIGEgcHJldmlvdXMgcnVuIGFuZCBzdHJlYW0gdGhlIHJ1biB0byBhIHRlcm1pbmFsXG4gICAqIHN0YXRlLiBNb3JlIGluZm9ybWF0aW9uIG9uIFJ1biBsaWZlY3ljbGVzIGNhbiBiZSBmb3VuZCBoZXJlOlxuICAgKiBodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL2hvdy1pdC13b3Jrcy9ydW5zLWFuZC1ydW4tc3RlcHNcbiAgICovXG4gIHN1Ym1pdFRvb2xPdXRwdXRzU3RyZWFtKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBib2R5OiBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQXNzaXN0YW50U3RyZWFtIHtcbiAgICByZXR1cm4gQXNzaXN0YW50U3RyZWFtLmNyZWF0ZVRvb2xBc3Npc3RhbnRTdHJlYW0oXG4gICAgICB0aHJlYWRJZCxcbiAgICAgIHJ1bklkLFxuICAgICAgdGhpcy5fY2xpZW50LmJldGEudGhyZWFkcy5ydW5zLFxuICAgICAgYm9keSxcbiAgICAgIG9wdGlvbnMsXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUnVuc1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlPFJ1bj4ge31cblxuLyoqXG4gKiBUb29sIGNhbGwgb2JqZWN0c1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlcXVpcmVkQWN0aW9uRnVuY3Rpb25Ub29sQ2FsbCB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbC4gVGhpcyBJRCBtdXN0IGJlIHJlZmVyZW5jZWQgd2hlbiB5b3Ugc3VibWl0IHRoZSB0b29sXG4gICAqIG91dHB1dHMgaW4gdXNpbmcgdGhlXG4gICAqIFtTdWJtaXQgdG9vbCBvdXRwdXRzIHRvIHJ1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL3N1Ym1pdFRvb2xPdXRwdXRzKVxuICAgKiBlbmRwb2ludC5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBmdW5jdGlvbiBkZWZpbml0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb246IFJlcXVpcmVkQWN0aW9uRnVuY3Rpb25Ub29sQ2FsbC5GdW5jdGlvbjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdG9vbCBjYWxsIHRoZSBvdXRwdXQgaXMgcmVxdWlyZWQgZm9yLiBGb3Igbm93LCB0aGlzIGlzIGFsd2F5c1xuICAgKiBgZnVuY3Rpb25gLlxuICAgKi9cbiAgdHlwZTogJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSZXF1aXJlZEFjdGlvbkZ1bmN0aW9uVG9vbENhbGwge1xuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIGRlZmluaXRpb24uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYXJndW1lbnRzIHRoYXQgdGhlIG1vZGVsIGV4cGVjdHMgeW91IHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGFyZ3VtZW50czogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJ1biB7XG4gIC8qKlxuICAgKiBUaGUgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGVcbiAgICogW2Fzc2lzdGFudF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSB1c2VkIGZvclxuICAgKiBleGVjdXRpb24gb2YgdGhpcyBydW4uXG4gICAqL1xuICBhc3Npc3RhbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHdhcyBjYW5jZWxsZWQuXG4gICAqL1xuICBjYW5jZWxsZWRfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHJ1biB3YXMgY29tcGxldGVkLlxuICAgKi9cbiAgY29tcGxldGVkX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBydW4gd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHJ1biB3aWxsIGV4cGlyZS5cbiAgICovXG4gIGV4cGlyZXNfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHJ1biBmYWlsZWQuXG4gICAqL1xuICBmYWlsZWRfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIERldGFpbHMgb24gd2h5IHRoZSBydW4gaXMgaW5jb21wbGV0ZS4gV2lsbCBiZSBgbnVsbGAgaWYgdGhlIHJ1biBpcyBub3RcbiAgICogaW5jb21wbGV0ZS5cbiAgICovXG4gIGluY29tcGxldGVfZGV0YWlsczogUnVuLkluY29tcGxldGVEZXRhaWxzIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGluc3RydWN0aW9ucyB0aGF0IHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIHVzZWQgZm9yXG4gICAqIHRoaXMgcnVuLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBsYXN0IGVycm9yIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJ1bi4gV2lsbCBiZSBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIGVycm9ycy5cbiAgICovXG4gIGxhc3RfZXJyb3I6IFJ1bi5MYXN0RXJyb3IgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgc3BlY2lmaWVkIHRvIGhhdmUgYmVlbiB1c2VkIG92ZXIgdGhlXG4gICAqIGNvdXJzZSBvZiB0aGUgcnVuLlxuICAgKi9cbiAgbWF4X2NvbXBsZXRpb25fdG9rZW5zOiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcHJvbXB0IHRva2VucyBzcGVjaWZpZWQgdG8gaGF2ZSBiZWVuIHVzZWQgb3ZlciB0aGUgY291cnNlXG4gICAqIG9mIHRoZSBydW4uXG4gICAqL1xuICBtYXhfcHJvbXB0X3Rva2VuczogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE6IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdGhhdCB0aGVcbiAgICogW2Fzc2lzdGFudF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSB1c2VkIGZvclxuICAgKiB0aGlzIHJ1bi5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGB0aHJlYWQucnVuYC5cbiAgICovXG4gIG9iamVjdDogJ3RocmVhZC5ydW4nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZVxuICAgKiBbcGFyYWxsZWwgZnVuY3Rpb24gY2FsbGluZ10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2Z1bmN0aW9uLWNhbGxpbmcjY29uZmlndXJpbmctcGFyYWxsZWwtZnVuY3Rpb24tY2FsbGluZylcbiAgICogZHVyaW5nIHRvb2wgdXNlLlxuICAgKi9cbiAgcGFyYWxsZWxfdG9vbF9jYWxsczogYm9vbGVhbjtcblxuICAvKipcbiAgICogRGV0YWlscyBvbiB0aGUgYWN0aW9uIHJlcXVpcmVkIHRvIGNvbnRpbnVlIHRoZSBydW4uIFdpbGwgYmUgYG51bGxgIGlmIG5vIGFjdGlvblxuICAgKiBpcyByZXF1aXJlZC5cbiAgICovXG4gIHJlcXVpcmVkX2FjdGlvbjogUnVuLlJlcXVpcmVkQWN0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBmb3JtYXQgdGhhdCB0aGUgbW9kZWwgbXVzdCBvdXRwdXQuIENvbXBhdGlibGUgd2l0aFxuICAgKiBbR1BULTRvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTRvKSxcbiAgICogW0dQVC00IFR1cmJvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTQtdHVyYm8tYW5kLWdwdC00KSxcbiAgICogYW5kIGFsbCBHUFQtMy41IFR1cmJvIG1vZGVscyBzaW5jZSBgZ3B0LTMuNS10dXJiby0xMTA2YC5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX3NjaGVtYVwiLCBcImpzb25fc2NoZW1hXCI6IHsuLi59IH1gIGVuYWJsZXMgU3RydWN0dXJlZFxuICAgKiBPdXRwdXRzIHdoaWNoIGVuc3VyZXMgdGhlIG1vZGVsIHdpbGwgbWF0Y2ggeW91ciBzdXBwbGllZCBKU09OIHNjaGVtYS4gTGVhcm4gbW9yZVxuICAgKiBpbiB0aGVcbiAgICogW1N0cnVjdHVyZWQgT3V0cHV0cyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3N0cnVjdHVyZWQtb3V0cHV0cykuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9vYmplY3RcIiB9YCBlbmFibGVzIEpTT04gbW9kZSwgd2hpY2ggZW5zdXJlcyB0aGVcbiAgICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gICAqXG4gICAqICoqSW1wb3J0YW50OioqIHdoZW4gdXNpbmcgSlNPTiBtb2RlLCB5b3UgKiptdXN0KiogYWxzbyBpbnN0cnVjdCB0aGUgbW9kZWwgdG9cbiAgICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICAgKiBnZW5lcmF0ZSBhbiB1bmVuZGluZyBzdHJlYW0gb2Ygd2hpdGVzcGFjZSB1bnRpbCB0aGUgZ2VuZXJhdGlvbiByZWFjaGVzIHRoZSB0b2tlblxuICAgKiBsaW1pdCwgcmVzdWx0aW5nIGluIGEgbG9uZy1ydW5uaW5nIGFuZCBzZWVtaW5nbHkgXCJzdHVja1wiIHJlcXVlc3QuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICAgKiBpbmRpY2F0ZXMgdGhlIGdlbmVyYXRpb24gZXhjZWVkZWQgYG1heF90b2tlbnNgIG9yIHRoZSBjb252ZXJzYXRpb24gZXhjZWVkZWQgdGhlXG4gICAqIG1heCBjb250ZXh0IGxlbmd0aC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdDogVGhyZWFkc0FQSS5Bc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHJ1biB3YXMgc3RhcnRlZC5cbiAgICovXG4gIHN0YXJ0ZWRfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzdGF0dXMgb2YgdGhlIHJ1biwgd2hpY2ggY2FuIGJlIGVpdGhlciBgcXVldWVkYCwgYGluX3Byb2dyZXNzYCxcbiAgICogYHJlcXVpcmVzX2FjdGlvbmAsIGBjYW5jZWxsaW5nYCwgYGNhbmNlbGxlZGAsIGBmYWlsZWRgLCBgY29tcGxldGVkYCxcbiAgICogYGluY29tcGxldGVgLCBvciBgZXhwaXJlZGAuXG4gICAqL1xuICBzdGF0dXM6IFJ1blN0YXR1cztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpXG4gICAqIHRoYXQgd2FzIGV4ZWN1dGVkIG9uIGFzIGEgcGFydCBvZiB0aGlzIHJ1bi5cbiAgICovXG4gIHRocmVhZF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyB3aGljaCAoaWYgYW55KSB0b29sIGlzIGNhbGxlZCBieSB0aGUgbW9kZWwuIGBub25lYCBtZWFucyB0aGUgbW9kZWwgd2lsbFxuICAgKiBub3QgY2FsbCBhbnkgdG9vbHMgYW5kIGluc3RlYWQgZ2VuZXJhdGVzIGEgbWVzc2FnZS4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAqIGFuZCBtZWFucyB0aGUgbW9kZWwgY2FuIHBpY2sgYmV0d2VlbiBnZW5lcmF0aW5nIGEgbWVzc2FnZSBvciBjYWxsaW5nIG9uZSBvciBtb3JlXG4gICAqIHRvb2xzLiBgcmVxdWlyZWRgIG1lYW5zIHRoZSBtb2RlbCBtdXN0IGNhbGwgb25lIG9yIG1vcmUgdG9vbHMgYmVmb3JlIHJlc3BvbmRpbmdcbiAgICogdG8gdGhlIHVzZXIuIFNwZWNpZnlpbmcgYSBwYXJ0aWN1bGFyIHRvb2wgbGlrZSBge1widHlwZVwiOiBcImZpbGVfc2VhcmNoXCJ9YCBvclxuICAgKiBge1widHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIm15X2Z1bmN0aW9uXCJ9fWAgZm9yY2VzIHRoZSBtb2RlbCB0b1xuICAgKiBjYWxsIHRoYXQgdG9vbC5cbiAgICovXG4gIHRvb2xfY2hvaWNlOiBUaHJlYWRzQVBJLkFzc2lzdGFudFRvb2xDaG9pY2VPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiB0b29scyB0aGF0IHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIHVzZWQgZm9yXG4gICAqIHRoaXMgcnVuLlxuICAgKi9cbiAgdG9vbHM6IEFycmF5PEFzc2lzdGFudHNBUEkuQXNzaXN0YW50VG9vbD47XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICB0cnVuY2F0aW9uX3N0cmF0ZWd5OiBSdW4uVHJ1bmNhdGlvblN0cmF0ZWd5IHwgbnVsbDtcblxuICAvKipcbiAgICogVXNhZ2Ugc3RhdGlzdGljcyByZWxhdGVkIHRvIHRoZSBydW4uIFRoaXMgdmFsdWUgd2lsbCBiZSBgbnVsbGAgaWYgdGhlIHJ1biBpcyBub3RcbiAgICogaW4gYSB0ZXJtaW5hbCBzdGF0ZSAoaS5lLiBgaW5fcHJvZ3Jlc3NgLCBgcXVldWVkYCwgZXRjLikuXG4gICAqL1xuICB1c2FnZTogUnVuLlVzYWdlIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHNhbXBsaW5nIHRlbXBlcmF0dXJlIHVzZWQgZm9yIHRoaXMgcnVuLiBJZiBub3Qgc2V0LCBkZWZhdWx0cyB0byAxLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVjbGV1cyBzYW1wbGluZyB2YWx1ZSB1c2VkIGZvciB0aGlzIHJ1bi4gSWYgbm90IHNldCwgZGVmYXVsdHMgdG8gMS5cbiAgICovXG4gIHRvcF9wPzogbnVtYmVyIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSdW4ge1xuICAvKipcbiAgICogRGV0YWlscyBvbiB3aHkgdGhlIHJ1biBpcyBpbmNvbXBsZXRlLiBXaWxsIGJlIGBudWxsYCBpZiB0aGUgcnVuIGlzIG5vdFxuICAgKiBpbmNvbXBsZXRlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBJbmNvbXBsZXRlRGV0YWlscyB7XG4gICAgLyoqXG4gICAgICogVGhlIHJlYXNvbiB3aHkgdGhlIHJ1biBpcyBpbmNvbXBsZXRlLiBUaGlzIHdpbGwgcG9pbnQgdG8gd2hpY2ggc3BlY2lmaWMgdG9rZW5cbiAgICAgKiBsaW1pdCB3YXMgcmVhY2hlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICByZWFzb24/OiAnbWF4X2NvbXBsZXRpb25fdG9rZW5zJyB8ICdtYXhfcHJvbXB0X3Rva2Vucyc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGxhc3QgZXJyb3IgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcnVuLiBXaWxsIGJlIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gZXJyb3JzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBMYXN0RXJyb3Ige1xuICAgIC8qKlxuICAgICAqIE9uZSBvZiBgc2VydmVyX2Vycm9yYCwgYHJhdGVfbGltaXRfZXhjZWVkZWRgLCBvciBgaW52YWxpZF9wcm9tcHRgLlxuICAgICAqL1xuICAgIGNvZGU6ICdzZXJ2ZXJfZXJyb3InIHwgJ3JhdGVfbGltaXRfZXhjZWVkZWQnIHwgJ2ludmFsaWRfcHJvbXB0JztcblxuICAgIC8qKlxuICAgICAqIEEgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGVycm9yLlxuICAgICAqL1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRhaWxzIG9uIHRoZSBhY3Rpb24gcmVxdWlyZWQgdG8gY29udGludWUgdGhlIHJ1bi4gV2lsbCBiZSBgbnVsbGAgaWYgbm8gYWN0aW9uXG4gICAqIGlzIHJlcXVpcmVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBSZXF1aXJlZEFjdGlvbiB7XG4gICAgLyoqXG4gICAgICogRGV0YWlscyBvbiB0aGUgdG9vbCBvdXRwdXRzIG5lZWRlZCBmb3IgdGhpcyBydW4gdG8gY29udGludWUuXG4gICAgICovXG4gICAgc3VibWl0X3Rvb2xfb3V0cHV0czogUmVxdWlyZWRBY3Rpb24uU3VibWl0VG9vbE91dHB1dHM7XG5cbiAgICAvKipcbiAgICAgKiBGb3Igbm93LCB0aGlzIGlzIGFsd2F5cyBgc3VibWl0X3Rvb2xfb3V0cHV0c2AuXG4gICAgICovXG4gICAgdHlwZTogJ3N1Ym1pdF90b29sX291dHB1dHMnO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBSZXF1aXJlZEFjdGlvbiB7XG4gICAgLyoqXG4gICAgICogRGV0YWlscyBvbiB0aGUgdG9vbCBvdXRwdXRzIG5lZWRlZCBmb3IgdGhpcyBydW4gdG8gY29udGludWUuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBTdWJtaXRUb29sT3V0cHV0cyB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiB0aGUgcmVsZXZhbnQgdG9vbCBjYWxscy5cbiAgICAgICAqL1xuICAgICAgdG9vbF9jYWxsczogQXJyYXk8UnVuc0FQSS5SZXF1aXJlZEFjdGlvbkZ1bmN0aW9uVG9vbENhbGw+O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUcnVuY2F0aW9uU3RyYXRlZ3kge1xuICAgIC8qKlxuICAgICAqIFRoZSB0cnVuY2F0aW9uIHN0cmF0ZWd5IHRvIHVzZSBmb3IgdGhlIHRocmVhZC4gVGhlIGRlZmF1bHQgaXMgYGF1dG9gLiBJZiBzZXQgdG9cbiAgICAgKiBgbGFzdF9tZXNzYWdlc2AsIHRoZSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgdG8gdGhlIG4gbW9zdCByZWNlbnQgbWVzc2FnZXMgaW5cbiAgICAgKiB0aGUgdGhyZWFkLiBXaGVuIHNldCB0byBgYXV0b2AsIG1lc3NhZ2VzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHRocmVhZCB3aWxsIGJlXG4gICAgICogZHJvcHBlZCB0byBmaXQgdGhlIGNvbnRleHQgbGVuZ3RoIG9mIHRoZSBtb2RlbCwgYG1heF9wcm9tcHRfdG9rZW5zYC5cbiAgICAgKi9cbiAgICB0eXBlOiAnYXV0bycgfCAnbGFzdF9tZXNzYWdlcyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGZyb20gdGhlIHRocmVhZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgY29udGV4dFxuICAgICAqIGZvciB0aGUgcnVuLlxuICAgICAqL1xuICAgIGxhc3RfbWVzc2FnZXM/OiBudW1iZXIgfCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgcmVsYXRlZCB0byB0aGUgcnVuLiBUaGlzIHZhbHVlIHdpbGwgYmUgYG51bGxgIGlmIHRoZSBydW4gaXMgbm90XG4gICAqIGluIGEgdGVybWluYWwgc3RhdGUgKGkuZS4gYGluX3Byb2dyZXNzYCwgYHF1ZXVlZGAsIGV0Yy4pLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBVc2FnZSB7XG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBydW4uXG4gICAgICovXG4gICAgY29tcGxldGlvbl90b2tlbnM6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBwcm9tcHQgdG9rZW5zIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBydW4uXG4gICAgICovXG4gICAgcHJvbXB0X3Rva2VuczogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVG90YWwgbnVtYmVyIG9mIHRva2VucyB1c2VkIChwcm9tcHQgKyBjb21wbGV0aW9uKS5cbiAgICAgKi9cbiAgICB0b3RhbF90b2tlbnM6IG51bWJlcjtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBzdGF0dXMgb2YgdGhlIHJ1biwgd2hpY2ggY2FuIGJlIGVpdGhlciBgcXVldWVkYCwgYGluX3Byb2dyZXNzYCxcbiAqIGByZXF1aXJlc19hY3Rpb25gLCBgY2FuY2VsbGluZ2AsIGBjYW5jZWxsZWRgLCBgZmFpbGVkYCwgYGNvbXBsZXRlZGAsXG4gKiBgaW5jb21wbGV0ZWAsIG9yIGBleHBpcmVkYC5cbiAqL1xuZXhwb3J0IHR5cGUgUnVuU3RhdHVzID1cbiAgfCAncXVldWVkJ1xuICB8ICdpbl9wcm9ncmVzcydcbiAgfCAncmVxdWlyZXNfYWN0aW9uJ1xuICB8ICdjYW5jZWxsaW5nJ1xuICB8ICdjYW5jZWxsZWQnXG4gIHwgJ2ZhaWxlZCdcbiAgfCAnY29tcGxldGVkJ1xuICB8ICdpbmNvbXBsZXRlJ1xuICB8ICdleHBpcmVkJztcblxuZXhwb3J0IHR5cGUgUnVuQ3JlYXRlUGFyYW1zID0gUnVuQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIHwgUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJ1bkNyZWF0ZVBhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogQm9keSBwYXJhbTogVGhlIElEIG9mIHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIHRvIHVzZSB0b1xuICAgKiBleGVjdXRlIHRoaXMgcnVuLlxuICAgKi9cbiAgYXNzaXN0YW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFF1ZXJ5IHBhcmFtOiBBIGxpc3Qgb2YgYWRkaXRpb25hbCBmaWVsZHMgdG8gaW5jbHVkZSBpbiB0aGUgcmVzcG9uc2UuIEN1cnJlbnRseVxuICAgKiB0aGUgb25seSBzdXBwb3J0ZWQgdmFsdWUgaXNcbiAgICogYHN0ZXBfZGV0YWlscy50b29sX2NhbGxzWypdLmZpbGVfc2VhcmNoLnJlc3VsdHNbKl0uY29udGVudGAgdG8gZmV0Y2ggdGhlIGZpbGVcbiAgICogc2VhcmNoIHJlc3VsdCBjb250ZW50LlxuICAgKlxuICAgKiBTZWUgdGhlXG4gICAqIFtmaWxlIHNlYXJjaCB0b29sIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvdG9vbHMvZmlsZS1zZWFyY2gjY3VzdG9taXppbmctZmlsZS1zZWFyY2gtc2V0dGluZ3MpXG4gICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgaW5jbHVkZT86IEFycmF5PFN0ZXBzQVBJLlJ1blN0ZXBJbmNsdWRlPjtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogQXBwZW5kcyBhZGRpdGlvbmFsIGluc3RydWN0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSBpbnN0cnVjdGlvbnMgZm9yXG4gICAqIHRoZSBydW4uIFRoaXMgaXMgdXNlZnVsIGZvciBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcyB3aXRob3V0XG4gICAqIG92ZXJyaWRpbmcgb3RoZXIgaW5zdHJ1Y3Rpb25zLlxuICAgKi9cbiAgYWRkaXRpb25hbF9pbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBBZGRzIGFkZGl0aW9uYWwgbWVzc2FnZXMgdG8gdGhlIHRocmVhZCBiZWZvcmUgY3JlYXRpbmcgdGhlIHJ1bi5cbiAgICovXG4gIGFkZGl0aW9uYWxfbWVzc2FnZXM/OiBBcnJheTxSdW5DcmVhdGVQYXJhbXMuQWRkaXRpb25hbE1lc3NhZ2U+IHwgbnVsbDtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogT3ZlcnJpZGVzIHRoZVxuICAgKiBbaW5zdHJ1Y3Rpb25zXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMvY3JlYXRlQXNzaXN0YW50KVxuICAgKiBvZiB0aGUgYXNzaXN0YW50LiBUaGlzIGlzIHVzZWZ1bCBmb3IgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZVxuICAgKiBjb3Vyc2Ugb2YgdGhlIHJ1bi4gVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mXG4gICAqIGNvbXBsZXRpb24gdG9rZW5zIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW5cbiAgICogZXhjZWVkcyB0aGUgbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1c1xuICAgKiBgaW5jb21wbGV0ZWAuIFNlZSBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X2NvbXBsZXRpb25fdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogVGhlIG1heGltdW0gbnVtYmVyIG9mIHByb21wdCB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2VcbiAgICogb2YgdGhlIHJ1bi4gVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIHByb21wdFxuICAgKiB0b2tlbnMgc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZVxuICAgKiBudW1iZXIgb2YgcHJvbXB0IHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLlxuICAgKiBTZWUgYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9wcm9tcHRfdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXNcbiAgICogY2FuIGJlIHVzZWZ1bCBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYVxuICAgKiBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5cyBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZVxuICAgKiBhIG1heGl1bSBvZiA1MTIgY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogVGhlIElEIG9mIHRoZVxuICAgKiBbTW9kZWxdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzKSB0byBiZSB1c2VkIHRvXG4gICAqIGV4ZWN1dGUgdGhpcyBydW4uIElmIGEgdmFsdWUgaXMgcHJvdmlkZWQgaGVyZSwgaXQgd2lsbCBvdmVycmlkZSB0aGUgbW9kZWxcbiAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3Npc3RhbnQuIElmIG5vdCwgdGhlIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzaXN0YW50XG4gICAqIHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIG1vZGVsPzogKHN0cmluZyAmIHt9KSB8IENoYXRBUEkuQ2hhdE1vZGVsIHwgbnVsbDtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogV2hldGhlciB0byBlbmFibGVcbiAgICogW3BhcmFsbGVsIGZ1bmN0aW9uIGNhbGxpbmddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9mdW5jdGlvbi1jYWxsaW5nI2NvbmZpZ3VyaW5nLXBhcmFsbGVsLWZ1bmN0aW9uLWNhbGxpbmcpXG4gICAqIGR1cmluZyB0b29sIHVzZS5cbiAgICovXG4gIHBhcmFsbGVsX3Rvb2xfY2FsbHM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gICAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNG8pLFxuICAgKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICAgKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fc2NoZW1hXCIsIFwianNvbl9zY2hlbWFcIjogey4uLn0gfWAgZW5hYmxlcyBTdHJ1Y3R1cmVkXG4gICAqIE91dHB1dHMgd2hpY2ggZW5zdXJlcyB0aGUgbW9kZWwgd2lsbCBtYXRjaCB5b3VyIHN1cHBsaWVkIEpTT04gc2NoZW1hLiBMZWFybiBtb3JlXG4gICAqIGluIHRoZVxuICAgKiBbU3RydWN0dXJlZCBPdXRwdXRzIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc3RydWN0dXJlZC1vdXRwdXRzKS5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBlbnN1cmVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogVGhyZWFkc0FQSS5Bc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IElmIGB0cnVlYCwgcmV0dXJucyBhIHN0cmVhbSBvZiBldmVudHMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoZSBSdW4gYXNcbiAgICogc2VydmVyLXNlbnQgZXZlbnRzLCB0ZXJtaW5hdGluZyB3aGVuIHRoZSBSdW4gZW50ZXJzIGEgdGVybWluYWwgc3RhdGUgd2l0aCBhXG4gICAqIGBkYXRhOiBbRE9ORV1gIG1lc3NhZ2UuXG4gICAqL1xuICBzdHJlYW0/OiBib29sZWFuIHwgbnVsbDtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlc1xuICAgKiBsaWtlIDAuOCB3aWxsIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZVxuICAgKiBpdCBtb3JlIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IENvbnRyb2xzIHdoaWNoIChpZiBhbnkpIHRvb2wgaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC4gYG5vbmVgIG1lYW5zXG4gICAqIHRoZSBtb2RlbCB3aWxsIG5vdCBjYWxsIGFueSB0b29scyBhbmQgaW5zdGVhZCBnZW5lcmF0ZXMgYSBtZXNzYWdlLiBgYXV0b2AgaXMgdGhlXG4gICAqIGRlZmF1bHQgdmFsdWUgYW5kIG1lYW5zIHRoZSBtb2RlbCBjYW4gcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yXG4gICAqIGNhbGxpbmcgb25lIG9yIG1vcmUgdG9vbHMuIGByZXF1aXJlZGAgbWVhbnMgdGhlIG1vZGVsIG11c3QgY2FsbCBvbmUgb3IgbW9yZVxuICAgKiB0b29scyBiZWZvcmUgcmVzcG9uZGluZyB0byB0aGUgdXNlci4gU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgdG9vbCBsaWtlXG4gICAqIGB7XCJ0eXBlXCI6IFwiZmlsZV9zZWFyY2hcIn1gIG9yXG4gICAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gICAqIGNhbGwgdGhhdCB0b29sLlxuICAgKi9cbiAgdG9vbF9jaG9pY2U/OiBUaHJlYWRzQVBJLkFzc2lzdGFudFRvb2xDaG9pY2VPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBPdmVycmlkZSB0aGUgdG9vbHMgdGhlIGFzc2lzdGFudCBjYW4gdXNlIGZvciB0aGlzIHJ1bi4gVGhpcyBpc1xuICAgKiB1c2VmdWwgZm9yIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzLlxuICAgKi9cbiAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFRvb2w+IHwgbnVsbDtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXNcbiAgICogc2FtcGxpbmcsIHdoZXJlIHRoZSBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wXG4gICAqIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMSBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJVxuICAgKiBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgdGVtcGVyYXR1cmUgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdG9wX3A/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZVxuICAgKiB0aGlzIHRvIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgdHJ1bmNhdGlvbl9zdHJhdGVneT86IFJ1bkNyZWF0ZVBhcmFtcy5UcnVuY2F0aW9uU3RyYXRlZ3kgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJ1bkNyZWF0ZVBhcmFtcyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQWRkaXRpb25hbE1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PE1lc3NhZ2VzQVBJLk1lc3NhZ2VDb250ZW50UGFydFBhcmFtPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSByb2xlIG9mIHRoZSBlbnRpdHkgdGhhdCBpcyBjcmVhdGluZyB0aGUgbWVzc2FnZS4gQWxsb3dlZCB2YWx1ZXMgaW5jbHVkZTpcbiAgICAgKlxuICAgICAqIC0gYHVzZXJgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgc2VudCBieSBhbiBhY3R1YWwgdXNlciBhbmQgc2hvdWxkIGJlIHVzZWQgaW5cbiAgICAgKiAgIG1vc3QgY2FzZXMgdG8gcmVwcmVzZW50IHVzZXItZ2VuZXJhdGVkIG1lc3NhZ2VzLlxuICAgICAqIC0gYGFzc2lzdGFudGA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBnZW5lcmF0ZWQgYnkgdGhlIGFzc2lzdGFudC4gVXNlIHRoaXNcbiAgICAgKiAgIHZhbHVlIHRvIGluc2VydCBtZXNzYWdlcyBmcm9tIHRoZSBhc3Npc3RhbnQgaW50byB0aGUgY29udmVyc2F0aW9uLlxuICAgICAqL1xuICAgIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xuXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIHRoZSBtZXNzYWdlLCBhbmQgdGhlIHRvb2xzIHRoZXkgc2hvdWxkIGJlIGFkZGVkIHRvLlxuICAgICAqL1xuICAgIGF0dGFjaG1lbnRzPzogQXJyYXk8QWRkaXRpb25hbE1lc3NhZ2UuQXR0YWNobWVudD4gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAgICogY2hhcmFjdGVycyBsb25nLlxuICAgICAqL1xuICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIEFkZGl0aW9uYWxNZXNzYWdlIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIEF0dGFjaG1lbnQge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gYXR0YWNoIHRvIHRoZSBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkPzogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0b29scyB0byBhZGQgdGhpcyBmaWxlIHRvLlxuICAgICAgICovXG4gICAgICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEF0dGFjaG1lbnQuRmlsZVNlYXJjaD47XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBBdHRhY2htZW50IHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0b29sIGJlaW5nIGRlZmluZWQ6IGBmaWxlX3NlYXJjaGBcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdmaWxlX3NlYXJjaCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRydW5jYXRpb25TdHJhdGVneSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRydW5jYXRpb24gc3RyYXRlZ3kgdG8gdXNlIGZvciB0aGUgdGhyZWFkLiBUaGUgZGVmYXVsdCBpcyBgYXV0b2AuIElmIHNldCB0b1xuICAgICAqIGBsYXN0X21lc3NhZ2VzYCwgdGhlIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCB0byB0aGUgbiBtb3N0IHJlY2VudCBtZXNzYWdlcyBpblxuICAgICAqIHRoZSB0aHJlYWQuIFdoZW4gc2V0IHRvIGBhdXRvYCwgbWVzc2FnZXMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdGhyZWFkIHdpbGwgYmVcbiAgICAgKiBkcm9wcGVkIHRvIGZpdCB0aGUgY29udGV4dCBsZW5ndGggb2YgdGhlIG1vZGVsLCBgbWF4X3Byb21wdF90b2tlbnNgLlxuICAgICAqL1xuICAgIHR5cGU6ICdhdXRvJyB8ICdsYXN0X21lc3NhZ2VzJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbW9zdCByZWNlbnQgbWVzc2FnZXMgZnJvbSB0aGUgdGhyZWFkIHdoZW4gY29uc3RydWN0aW5nIHRoZSBjb250ZXh0XG4gICAgICogZm9yIHRoZSBydW4uXG4gICAgICovXG4gICAgbGFzdF9tZXNzYWdlcz86IG51bWJlciB8IG51bGw7XG4gIH1cblxuICBleHBvcnQgdHlwZSBSdW5DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgPSBSdW5zQVBJLlJ1bkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZztcbiAgZXhwb3J0IHR5cGUgUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nID0gUnVuc0FQSS5SdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGV4dGVuZHMgUnVuQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBJZiBgdHJ1ZWAsIHJldHVybnMgYSBzdHJlYW0gb2YgZXZlbnRzIHRoYXQgaGFwcGVuIGR1cmluZyB0aGUgUnVuIGFzXG4gICAqIHNlcnZlci1zZW50IGV2ZW50cywgdGVybWluYXRpbmcgd2hlbiB0aGUgUnVuIGVudGVycyBhIHRlcm1pbmFsIHN0YXRlIHdpdGggYVxuICAgKiBgZGF0YTogW0RPTkVdYCBtZXNzYWdlLlxuICAgKi9cbiAgc3RyZWFtPzogZmFsc2UgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1bkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBleHRlbmRzIFJ1bkNyZWF0ZVBhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogQm9keSBwYXJhbTogSWYgYHRydWVgLCByZXR1cm5zIGEgc3RyZWFtIG9mIGV2ZW50cyB0aGF0IGhhcHBlbiBkdXJpbmcgdGhlIFJ1biBhc1xuICAgKiBzZXJ2ZXItc2VudCBldmVudHMsIHRlcm1pbmF0aW5nIHdoZW4gdGhlIFJ1biBlbnRlcnMgYSB0ZXJtaW5hbCBzdGF0ZSB3aXRoIGFcbiAgICogYGRhdGE6IFtET05FXWAgbWVzc2FnZS5cbiAgICovXG4gIHN0cmVhbTogdHJ1ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSdW5VcGRhdGVQYXJhbXMge1xuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSdW5MaXN0UGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIGN1cnNvciBmb3IgdXNlIGluIHBhZ2luYXRpb24uIGBiZWZvcmVgIGlzIGFuIG9iamVjdCBJRCB0aGF0IGRlZmluZXMgeW91ciBwbGFjZVxuICAgKiBpbiB0aGUgbGlzdC4gRm9yIGluc3RhbmNlLCBpZiB5b3UgbWFrZSBhIGxpc3QgcmVxdWVzdCBhbmQgcmVjZWl2ZSAxMDAgb2JqZWN0cyxcbiAgICogc3RhcnRpbmcgd2l0aCBvYmpfZm9vLCB5b3VyIHN1YnNlcXVlbnQgY2FsbCBjYW4gaW5jbHVkZSBiZWZvcmU9b2JqX2ZvbyBpbiBvcmRlclxuICAgKiB0byBmZXRjaCB0aGUgcHJldmlvdXMgcGFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGJlZm9yZT86IHN0cmluZztcblxuICAvKipcbiAgICogU29ydCBvcmRlciBieSB0aGUgYGNyZWF0ZWRfYXRgIHRpbWVzdGFtcCBvZiB0aGUgb2JqZWN0cy4gYGFzY2AgZm9yIGFzY2VuZGluZ1xuICAgKiBvcmRlciBhbmQgYGRlc2NgIGZvciBkZXNjZW5kaW5nIG9yZGVyLlxuICAgKi9cbiAgb3JkZXI/OiAnYXNjJyB8ICdkZXNjJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSdW5DcmVhdGVBbmRQb2xsUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGVcbiAgICogW2Fzc2lzdGFudF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSB0byB1c2UgdG9cbiAgICogZXhlY3V0ZSB0aGlzIHJ1bi5cbiAgICovXG4gIGFzc2lzdGFudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBcHBlbmRzIGFkZGl0aW9uYWwgaW5zdHJ1Y3Rpb25zIGF0IHRoZSBlbmQgb2YgdGhlIGluc3RydWN0aW9ucyBmb3IgdGhlIHJ1bi4gVGhpc1xuICAgKiBpcyB1c2VmdWwgZm9yIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzIHdpdGhvdXQgb3ZlcnJpZGluZyBvdGhlclxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICBhZGRpdGlvbmFsX2luc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEFkZHMgYWRkaXRpb25hbCBtZXNzYWdlcyB0byB0aGUgdGhyZWFkIGJlZm9yZSBjcmVhdGluZyB0aGUgcnVuLlxuICAgKi9cbiAgYWRkaXRpb25hbF9tZXNzYWdlcz86IEFycmF5PFJ1bkNyZWF0ZUFuZFBvbGxQYXJhbXMuQWRkaXRpb25hbE1lc3NhZ2U+IHwgbnVsbDtcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIHRoZVxuICAgKiBbaW5zdHJ1Y3Rpb25zXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMvY3JlYXRlQXNzaXN0YW50KVxuICAgKiBvZiB0aGUgYXNzaXN0YW50LiBUaGlzIGlzIHVzZWZ1bCBmb3IgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlXG4gICAqIHJ1bi4gVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zXG4gICAqIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGUgbnVtYmVyIG9mXG4gICAqIGNvbXBsZXRpb24gdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X2NvbXBsZXRpb25fdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHByb21wdCB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1bi5cbiAgICogVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIHByb21wdCB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogcHJvbXB0IHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLiBTZWVcbiAgICogYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9wcm9tcHRfdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBbTW9kZWxdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzKSB0b1xuICAgKiBiZSB1c2VkIHRvIGV4ZWN1dGUgdGhpcyBydW4uIElmIGEgdmFsdWUgaXMgcHJvdmlkZWQgaGVyZSwgaXQgd2lsbCBvdmVycmlkZSB0aGVcbiAgICogbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3Npc3RhbnQuIElmIG5vdCwgdGhlIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICogYXNzaXN0YW50IHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIG1vZGVsPzpcbiAgICB8IChzdHJpbmcgJiB7fSlcbiAgICB8ICdncHQtNG8nXG4gICAgfCAnZ3B0LTRvLTIwMjQtMDUtMTMnXG4gICAgfCAnZ3B0LTQtdHVyYm8nXG4gICAgfCAnZ3B0LTQtdHVyYm8tMjAyNC0wNC0wOSdcbiAgICB8ICdncHQtNC0wMTI1LXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtdHVyYm8tcHJldmlldydcbiAgICB8ICdncHQtNC0xMTA2LXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtdmlzaW9uLXByZXZpZXcnXG4gICAgfCAnZ3B0LTQnXG4gICAgfCAnZ3B0LTQtMDMxNCdcbiAgICB8ICdncHQtNC0wNjEzJ1xuICAgIHwgJ2dwdC00LTMyaydcbiAgICB8ICdncHQtNC0zMmstMDMxNCdcbiAgICB8ICdncHQtNC0zMmstMDYxMydcbiAgICB8ICdncHQtMy41LXR1cmJvJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTZrJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMDYxMydcbiAgICB8ICdncHQtMy41LXR1cmJvLTExMDYnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0wMTI1J1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTZrLTA2MTMnXG4gICAgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gICAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscy9ncHQtNG8pLFxuICAgKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscy9ncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICAgKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGd1YXJhbnRlZXMgdGhlXG4gICAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICAgKlxuICAgKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gICAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAgICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAgICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAgICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICAgKiBtYXggY29udGV4dCBsZW5ndGguXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBUaHJlYWRzQVBJLkFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIHdoaWNoIChpZiBhbnkpIHRvb2wgaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC4gYG5vbmVgIG1lYW5zIHRoZSBtb2RlbCB3aWxsXG4gICAqIG5vdCBjYWxsIGFueSB0b29scyBhbmQgaW5zdGVhZCBnZW5lcmF0ZXMgYSBtZXNzYWdlLiBgYXV0b2AgaXMgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICogYW5kIG1lYW5zIHRoZSBtb2RlbCBjYW4gcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yIGNhbGxpbmcgb25lIG9yIG1vcmVcbiAgICogdG9vbHMuIGByZXF1aXJlZGAgbWVhbnMgdGhlIG1vZGVsIG11c3QgY2FsbCBvbmUgb3IgbW9yZSB0b29scyBiZWZvcmUgcmVzcG9uZGluZ1xuICAgKiB0byB0aGUgdXNlci4gU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgdG9vbCBsaWtlIGB7XCJ0eXBlXCI6IFwiZmlsZV9zZWFyY2hcIn1gIG9yXG4gICAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gICAqIGNhbGwgdGhhdCB0b29sLlxuICAgKi9cbiAgdG9vbF9jaG9pY2U/OiBUaHJlYWRzQVBJLkFzc2lzdGFudFRvb2xDaG9pY2VPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgdG9vbHMgdGhlIGFzc2lzdGFudCBjYW4gdXNlIGZvciB0aGlzIHJ1bi4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzLlxuICAgKi9cbiAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFRvb2w+IHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgdGVtcGVyYXR1cmUgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdG9wX3A/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgdHJ1bmNhdGlvbl9zdHJhdGVneT86IFJ1bkNyZWF0ZUFuZFBvbGxQYXJhbXMuVHJ1bmNhdGlvblN0cmF0ZWd5IHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSdW5DcmVhdGVBbmRQb2xsUGFyYW1zIHtcbiAgZXhwb3J0IGludGVyZmFjZSBBZGRpdGlvbmFsTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8TWVzc2FnZXNBUEkuTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJvbGUgb2YgdGhlIGVudGl0eSB0aGF0IGlzIGNyZWF0aW5nIHRoZSBtZXNzYWdlLiBBbGxvd2VkIHZhbHVlcyBpbmNsdWRlOlxuICAgICAqXG4gICAgICogLSBgdXNlcmA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBzZW50IGJ5IGFuIGFjdHVhbCB1c2VyIGFuZCBzaG91bGQgYmUgdXNlZCBpblxuICAgICAqICAgbW9zdCBjYXNlcyB0byByZXByZXNlbnQgdXNlci1nZW5lcmF0ZWQgbWVzc2FnZXMuXG4gICAgICogLSBgYXNzaXN0YW50YDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGdlbmVyYXRlZCBieSB0aGUgYXNzaXN0YW50LiBVc2UgdGhpc1xuICAgICAqICAgdmFsdWUgdG8gaW5zZXJ0IG1lc3NhZ2VzIGZyb20gdGhlIGFzc2lzdGFudCBpbnRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgZmlsZXMgYXR0YWNoZWQgdG8gdGhlIG1lc3NhZ2UsIGFuZCB0aGUgdG9vbHMgdGhleSBzaG91bGQgYmUgYWRkZWQgdG8uXG4gICAgICovXG4gICAgYXR0YWNobWVudHM/OiBBcnJheTxBZGRpdGlvbmFsTWVzc2FnZS5BdHRhY2htZW50PiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICovXG4gICAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgQWRkaXRpb25hbE1lc3NhZ2Uge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBhdHRhY2ggdG8gdGhlIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRvb2xzIHRvIGFkZCB0aGlzIGZpbGUgdG8uXG4gICAgICAgKi9cbiAgICAgIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXNzaXN0YW50c0FQSS5GaWxlU2VhcmNoVG9vbD47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRydW5jYXRpb25TdHJhdGVneSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRydW5jYXRpb24gc3RyYXRlZ3kgdG8gdXNlIGZvciB0aGUgdGhyZWFkLiBUaGUgZGVmYXVsdCBpcyBgYXV0b2AuIElmIHNldCB0b1xuICAgICAqIGBsYXN0X21lc3NhZ2VzYCwgdGhlIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCB0byB0aGUgbiBtb3N0IHJlY2VudCBtZXNzYWdlcyBpblxuICAgICAqIHRoZSB0aHJlYWQuIFdoZW4gc2V0IHRvIGBhdXRvYCwgbWVzc2FnZXMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdGhyZWFkIHdpbGwgYmVcbiAgICAgKiBkcm9wcGVkIHRvIGZpdCB0aGUgY29udGV4dCBsZW5ndGggb2YgdGhlIG1vZGVsLCBgbWF4X3Byb21wdF90b2tlbnNgLlxuICAgICAqL1xuICAgIHR5cGU6ICdhdXRvJyB8ICdsYXN0X21lc3NhZ2VzJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbW9zdCByZWNlbnQgbWVzc2FnZXMgZnJvbSB0aGUgdGhyZWFkIHdoZW4gY29uc3RydWN0aW5nIHRoZSBjb250ZXh0XG4gICAgICogZm9yIHRoZSBydW4uXG4gICAgICovXG4gICAgbGFzdF9tZXNzYWdlcz86IG51bWJlciB8IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSdW5DcmVhdGVBbmRTdHJlYW1QYXJhbXMge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIHRvIHVzZSB0b1xuICAgKiBleGVjdXRlIHRoaXMgcnVuLlxuICAgKi9cbiAgYXNzaXN0YW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgYWRkaXRpb25hbCBpbnN0cnVjdGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgaW5zdHJ1Y3Rpb25zIGZvciB0aGUgcnVuLiBUaGlzXG4gICAqIGlzIHVzZWZ1bCBmb3IgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMgd2l0aG91dCBvdmVycmlkaW5nIG90aGVyXG4gICAqIGluc3RydWN0aW9ucy5cbiAgICovXG4gIGFkZGl0aW9uYWxfaW5zdHJ1Y3Rpb25zPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogQWRkcyBhZGRpdGlvbmFsIG1lc3NhZ2VzIHRvIHRoZSB0aHJlYWQgYmVmb3JlIGNyZWF0aW5nIHRoZSBydW4uXG4gICAqL1xuICBhZGRpdGlvbmFsX21lc3NhZ2VzPzogQXJyYXk8UnVuQ3JlYXRlQW5kU3RyZWFtUGFyYW1zLkFkZGl0aW9uYWxNZXNzYWdlPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyB0aGVcbiAgICogW2luc3RydWN0aW9uc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzL2NyZWF0ZUFzc2lzdGFudClcbiAgICogb2YgdGhlIGFzc2lzdGFudC4gVGhpcyBpcyB1c2VmdWwgZm9yIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zIHRoYXQgbWF5IGJlIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZVxuICAgKiBydW4uIFRoZSBydW4gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdXNlIG9ubHkgdGhlIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2Vuc1xuICAgKiBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlIG51bWJlciBvZlxuICAgKiBjb21wbGV0aW9uIHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLiBTZWVcbiAgICogYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9jb21wbGV0aW9uX3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zIHRoYXQgbWF5IGJlIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBydW4uXG4gICAqIFRoZSBydW4gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdXNlIG9ubHkgdGhlIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zXG4gICAqIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGUgbnVtYmVyIG9mXG4gICAqIHByb21wdCB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC4gU2VlXG4gICAqIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfcHJvbXB0X3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgW01vZGVsXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscykgdG9cbiAgICogYmUgdXNlZCB0byBleGVjdXRlIHRoaXMgcnVuLiBJZiBhIHZhbHVlIGlzIHByb3ZpZGVkIGhlcmUsIGl0IHdpbGwgb3ZlcnJpZGUgdGhlXG4gICAqIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzaXN0YW50LiBJZiBub3QsIHRoZSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAqIGFzc2lzdGFudCB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICBtb2RlbD86XG4gICAgfCAoc3RyaW5nICYge30pXG4gICAgfCAnZ3B0LTRvJ1xuICAgIHwgJ2dwdC00by0yMDI0LTA1LTEzJ1xuICAgIHwgJ2dwdC00LXR1cmJvJ1xuICAgIHwgJ2dwdC00LXR1cmJvLTIwMjQtMDQtMDknXG4gICAgfCAnZ3B0LTQtMDEyNS1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LXR1cmJvLXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtMTEwNi1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LXZpc2lvbi1wcmV2aWV3J1xuICAgIHwgJ2dwdC00J1xuICAgIHwgJ2dwdC00LTAzMTQnXG4gICAgfCAnZ3B0LTQtMDYxMydcbiAgICB8ICdncHQtNC0zMmsnXG4gICAgfCAnZ3B0LTQtMzJrLTAzMTQnXG4gICAgfCAnZ3B0LTQtMzJrLTA2MTMnXG4gICAgfCAnZ3B0LTMuNS10dXJibydcbiAgICB8ICdncHQtMy41LXR1cmJvLTE2aydcbiAgICB8ICdncHQtMy41LXR1cmJvLTA2MTMnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xMTA2J1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMDEyNSdcbiAgICB8ICdncHQtMy41LXR1cmJvLTE2ay0wNjEzJ1xuICAgIHwgbnVsbDtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBmb3JtYXQgdGhhdCB0aGUgbW9kZWwgbXVzdCBvdXRwdXQuIENvbXBhdGlibGUgd2l0aFxuICAgKiBbR1BULTRvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMvZ3B0LTRvKSxcbiAgICogW0dQVC00IFR1cmJvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMvZ3B0LTQtdHVyYm8tYW5kLWdwdC00KSxcbiAgICogYW5kIGFsbCBHUFQtMy41IFR1cmJvIG1vZGVscyBzaW5jZSBgZ3B0LTMuNS10dXJiby0xMTA2YC5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBndWFyYW50ZWVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogVGhyZWFkc0FQSS5Bc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoYXQgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdG8gdXNlLCBiZXR3ZWVuIDAgYW5kIDIuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbFxuICAgKiBtYWtlIHRoZSBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZVxuICAgKiBmb2N1c2VkIGFuZCBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyB3aGljaCAoaWYgYW55KSB0b29sIGlzIGNhbGxlZCBieSB0aGUgbW9kZWwuIGBub25lYCBtZWFucyB0aGUgbW9kZWwgd2lsbFxuICAgKiBub3QgY2FsbCBhbnkgdG9vbHMgYW5kIGluc3RlYWQgZ2VuZXJhdGVzIGEgbWVzc2FnZS4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAqIGFuZCBtZWFucyB0aGUgbW9kZWwgY2FuIHBpY2sgYmV0d2VlbiBnZW5lcmF0aW5nIGEgbWVzc2FnZSBvciBjYWxsaW5nIG9uZSBvciBtb3JlXG4gICAqIHRvb2xzLiBgcmVxdWlyZWRgIG1lYW5zIHRoZSBtb2RlbCBtdXN0IGNhbGwgb25lIG9yIG1vcmUgdG9vbHMgYmVmb3JlIHJlc3BvbmRpbmdcbiAgICogdG8gdGhlIHVzZXIuIFNwZWNpZnlpbmcgYSBwYXJ0aWN1bGFyIHRvb2wgbGlrZSBge1widHlwZVwiOiBcImZpbGVfc2VhcmNoXCJ9YCBvclxuICAgKiBge1widHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIm15X2Z1bmN0aW9uXCJ9fWAgZm9yY2VzIHRoZSBtb2RlbCB0b1xuICAgKiBjYWxsIHRoYXQgdG9vbC5cbiAgICovXG4gIHRvb2xfY2hvaWNlPzogVGhyZWFkc0FQSS5Bc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHRvb2xzIHRoZSBhc3Npc3RhbnQgY2FuIHVzZSBmb3IgdGhpcyBydW4uIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRUb29sPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEFuIGFsdGVybmF0aXZlIHRvIHNhbXBsaW5nIHdpdGggdGVtcGVyYXR1cmUsIGNhbGxlZCBudWNsZXVzIHNhbXBsaW5nLCB3aGVyZSB0aGVcbiAgICogbW9kZWwgY29uc2lkZXJzIHRoZSByZXN1bHRzIG9mIHRoZSB0b2tlbnMgd2l0aCB0b3BfcCBwcm9iYWJpbGl0eSBtYXNzLiBTbyAwLjFcbiAgICogbWVhbnMgb25seSB0aGUgdG9rZW5zIGNvbXByaXNpbmcgdGhlIHRvcCAxMCUgcHJvYmFiaWxpdHkgbWFzcyBhcmUgY29uc2lkZXJlZC5cbiAgICpcbiAgICogV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIHRlbXBlcmF0dXJlIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRvcF9wPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIHRydW5jYXRpb25fc3RyYXRlZ3k/OiBSdW5DcmVhdGVBbmRTdHJlYW1QYXJhbXMuVHJ1bmNhdGlvblN0cmF0ZWd5IHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSdW5DcmVhdGVBbmRTdHJlYW1QYXJhbXMge1xuICBleHBvcnQgaW50ZXJmYWNlIEFkZGl0aW9uYWxNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCBjb250ZW50cyBvZiB0aGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxNZXNzYWdlc0FQSS5NZXNzYWdlQ29udGVudFBhcnRQYXJhbT47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm9sZSBvZiB0aGUgZW50aXR5IHRoYXQgaXMgY3JlYXRpbmcgdGhlIG1lc3NhZ2UuIEFsbG93ZWQgdmFsdWVzIGluY2x1ZGU6XG4gICAgICpcbiAgICAgKiAtIGB1c2VyYDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIHNlbnQgYnkgYW4gYWN0dWFsIHVzZXIgYW5kIHNob3VsZCBiZSB1c2VkIGluXG4gICAgICogICBtb3N0IGNhc2VzIHRvIHJlcHJlc2VudCB1c2VyLWdlbmVyYXRlZCBtZXNzYWdlcy5cbiAgICAgKiAtIGBhc3Npc3RhbnRgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBhc3Npc3RhbnQuIFVzZSB0aGlzXG4gICAgICogICB2YWx1ZSB0byBpbnNlcnQgbWVzc2FnZXMgZnJvbSB0aGUgYXNzaXN0YW50IGludG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgKi9cbiAgICByb2xlOiAndXNlcicgfCAnYXNzaXN0YW50JztcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byB0aGUgbWVzc2FnZSwgYW5kIHRoZSB0b29scyB0aGV5IHNob3VsZCBiZSBhZGRlZCB0by5cbiAgICAgKi9cbiAgICBhdHRhY2htZW50cz86IEFycmF5PEFkZGl0aW9uYWxNZXNzYWdlLkF0dGFjaG1lbnQ+IHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgKi9cbiAgICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBBZGRpdGlvbmFsTWVzc2FnZSB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBBdHRhY2htZW50IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIElEIG9mIHRoZSBmaWxlIHRvIGF0dGFjaCB0byB0aGUgbWVzc2FnZS5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZD86IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdG9vbHMgdG8gYWRkIHRoaXMgZmlsZSB0by5cbiAgICAgICAqL1xuICAgICAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkNvZGVJbnRlcnByZXRlclRvb2wgfCBBc3Npc3RhbnRzQVBJLkZpbGVTZWFyY2hUb29sPjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVHJ1bmNhdGlvblN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJ1bmNhdGlvbiBzdHJhdGVneSB0byB1c2UgZm9yIHRoZSB0aHJlYWQuIFRoZSBkZWZhdWx0IGlzIGBhdXRvYC4gSWYgc2V0IHRvXG4gICAgICogYGxhc3RfbWVzc2FnZXNgLCB0aGUgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHRvIHRoZSBuIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGluXG4gICAgICogdGhlIHRocmVhZC4gV2hlbiBzZXQgdG8gYGF1dG9gLCBtZXNzYWdlcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSB0aHJlYWQgd2lsbCBiZVxuICAgICAqIGRyb3BwZWQgdG8gZml0IHRoZSBjb250ZXh0IGxlbmd0aCBvZiB0aGUgbW9kZWwsIGBtYXhfcHJvbXB0X3Rva2Vuc2AuXG4gICAgICovXG4gICAgdHlwZTogJ2F1dG8nIHwgJ2xhc3RfbWVzc2FnZXMnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtb3N0IHJlY2VudCBtZXNzYWdlcyBmcm9tIHRoZSB0aHJlYWQgd2hlbiBjb25zdHJ1Y3RpbmcgdGhlIGNvbnRleHRcbiAgICAgKiBmb3IgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBsYXN0X21lc3NhZ2VzPzogbnVtYmVyIHwgbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1blN0cmVhbVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdG8gdXNlIHRvXG4gICAqIGV4ZWN1dGUgdGhpcyBydW4uXG4gICAqL1xuICBhc3Npc3RhbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQXBwZW5kcyBhZGRpdGlvbmFsIGluc3RydWN0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSBpbnN0cnVjdGlvbnMgZm9yIHRoZSBydW4uIFRoaXNcbiAgICogaXMgdXNlZnVsIGZvciBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcyB3aXRob3V0IG92ZXJyaWRpbmcgb3RoZXJcbiAgICogaW5zdHJ1Y3Rpb25zLlxuICAgKi9cbiAgYWRkaXRpb25hbF9pbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBZGRzIGFkZGl0aW9uYWwgbWVzc2FnZXMgdG8gdGhlIHRocmVhZCBiZWZvcmUgY3JlYXRpbmcgdGhlIHJ1bi5cbiAgICovXG4gIGFkZGl0aW9uYWxfbWVzc2FnZXM/OiBBcnJheTxSdW5TdHJlYW1QYXJhbXMuQWRkaXRpb25hbE1lc3NhZ2U+IHwgbnVsbDtcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIHRoZVxuICAgKiBbaW5zdHJ1Y3Rpb25zXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMvY3JlYXRlQXNzaXN0YW50KVxuICAgKiBvZiB0aGUgYXNzaXN0YW50LiBUaGlzIGlzIHVzZWZ1bCBmb3IgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlXG4gICAqIHJ1bi4gVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zXG4gICAqIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGUgbnVtYmVyIG9mXG4gICAqIGNvbXBsZXRpb24gdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X2NvbXBsZXRpb25fdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHByb21wdCB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1bi5cbiAgICogVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIHByb21wdCB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogcHJvbXB0IHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLiBTZWVcbiAgICogYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9wcm9tcHRfdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBbTW9kZWxdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzKSB0b1xuICAgKiBiZSB1c2VkIHRvIGV4ZWN1dGUgdGhpcyBydW4uIElmIGEgdmFsdWUgaXMgcHJvdmlkZWQgaGVyZSwgaXQgd2lsbCBvdmVycmlkZSB0aGVcbiAgICogbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3Npc3RhbnQuIElmIG5vdCwgdGhlIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICogYXNzaXN0YW50IHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIG1vZGVsPzpcbiAgICB8IChzdHJpbmcgJiB7fSlcbiAgICB8ICdncHQtNG8nXG4gICAgfCAnZ3B0LTRvLTIwMjQtMDUtMTMnXG4gICAgfCAnZ3B0LTQtdHVyYm8nXG4gICAgfCAnZ3B0LTQtdHVyYm8tMjAyNC0wNC0wOSdcbiAgICB8ICdncHQtNC0wMTI1LXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtdHVyYm8tcHJldmlldydcbiAgICB8ICdncHQtNC0xMTA2LXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtdmlzaW9uLXByZXZpZXcnXG4gICAgfCAnZ3B0LTQnXG4gICAgfCAnZ3B0LTQtMDMxNCdcbiAgICB8ICdncHQtNC0wNjEzJ1xuICAgIHwgJ2dwdC00LTMyaydcbiAgICB8ICdncHQtNC0zMmstMDMxNCdcbiAgICB8ICdncHQtNC0zMmstMDYxMydcbiAgICB8ICdncHQtMy41LXR1cmJvJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTZrJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMDYxMydcbiAgICB8ICdncHQtMy41LXR1cmJvLTExMDYnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0wMTI1J1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTZrLTA2MTMnXG4gICAgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gICAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscy9ncHQtNG8pLFxuICAgKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscy9ncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICAgKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGd1YXJhbnRlZXMgdGhlXG4gICAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICAgKlxuICAgKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gICAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAgICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAgICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAgICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICAgKiBtYXggY29udGV4dCBsZW5ndGguXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBUaHJlYWRzQVBJLkFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIHdoaWNoIChpZiBhbnkpIHRvb2wgaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC4gYG5vbmVgIG1lYW5zIHRoZSBtb2RlbCB3aWxsXG4gICAqIG5vdCBjYWxsIGFueSB0b29scyBhbmQgaW5zdGVhZCBnZW5lcmF0ZXMgYSBtZXNzYWdlLiBgYXV0b2AgaXMgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICogYW5kIG1lYW5zIHRoZSBtb2RlbCBjYW4gcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yIGNhbGxpbmcgb25lIG9yIG1vcmVcbiAgICogdG9vbHMuIGByZXF1aXJlZGAgbWVhbnMgdGhlIG1vZGVsIG11c3QgY2FsbCBvbmUgb3IgbW9yZSB0b29scyBiZWZvcmUgcmVzcG9uZGluZ1xuICAgKiB0byB0aGUgdXNlci4gU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgdG9vbCBsaWtlIGB7XCJ0eXBlXCI6IFwiZmlsZV9zZWFyY2hcIn1gIG9yXG4gICAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gICAqIGNhbGwgdGhhdCB0b29sLlxuICAgKi9cbiAgdG9vbF9jaG9pY2U/OiBUaHJlYWRzQVBJLkFzc2lzdGFudFRvb2xDaG9pY2VPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgdG9vbHMgdGhlIGFzc2lzdGFudCBjYW4gdXNlIGZvciB0aGlzIHJ1bi4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzLlxuICAgKi9cbiAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFRvb2w+IHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgdGVtcGVyYXR1cmUgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdG9wX3A/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgdHJ1bmNhdGlvbl9zdHJhdGVneT86IFJ1blN0cmVhbVBhcmFtcy5UcnVuY2F0aW9uU3RyYXRlZ3kgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJ1blN0cmVhbVBhcmFtcyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQWRkaXRpb25hbE1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PE1lc3NhZ2VzQVBJLk1lc3NhZ2VDb250ZW50UGFydFBhcmFtPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSByb2xlIG9mIHRoZSBlbnRpdHkgdGhhdCBpcyBjcmVhdGluZyB0aGUgbWVzc2FnZS4gQWxsb3dlZCB2YWx1ZXMgaW5jbHVkZTpcbiAgICAgKlxuICAgICAqIC0gYHVzZXJgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgc2VudCBieSBhbiBhY3R1YWwgdXNlciBhbmQgc2hvdWxkIGJlIHVzZWQgaW5cbiAgICAgKiAgIG1vc3QgY2FzZXMgdG8gcmVwcmVzZW50IHVzZXItZ2VuZXJhdGVkIG1lc3NhZ2VzLlxuICAgICAqIC0gYGFzc2lzdGFudGA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBnZW5lcmF0ZWQgYnkgdGhlIGFzc2lzdGFudC4gVXNlIHRoaXNcbiAgICAgKiAgIHZhbHVlIHRvIGluc2VydCBtZXNzYWdlcyBmcm9tIHRoZSBhc3Npc3RhbnQgaW50byB0aGUgY29udmVyc2F0aW9uLlxuICAgICAqL1xuICAgIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xuXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIHRoZSBtZXNzYWdlLCBhbmQgdGhlIHRvb2xzIHRoZXkgc2hvdWxkIGJlIGFkZGVkIHRvLlxuICAgICAqL1xuICAgIGF0dGFjaG1lbnRzPzogQXJyYXk8QWRkaXRpb25hbE1lc3NhZ2UuQXR0YWNobWVudD4gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAgICogY2hhcmFjdGVycyBsb25nLlxuICAgICAqL1xuICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIEFkZGl0aW9uYWxNZXNzYWdlIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIEF0dGFjaG1lbnQge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gYXR0YWNoIHRvIHRoZSBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkPzogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0b29scyB0byBhZGQgdGhpcyBmaWxlIHRvLlxuICAgICAgICovXG4gICAgICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEFzc2lzdGFudHNBUEkuRmlsZVNlYXJjaFRvb2w+O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUcnVuY2F0aW9uU3RyYXRlZ3kge1xuICAgIC8qKlxuICAgICAqIFRoZSB0cnVuY2F0aW9uIHN0cmF0ZWd5IHRvIHVzZSBmb3IgdGhlIHRocmVhZC4gVGhlIGRlZmF1bHQgaXMgYGF1dG9gLiBJZiBzZXQgdG9cbiAgICAgKiBgbGFzdF9tZXNzYWdlc2AsIHRoZSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgdG8gdGhlIG4gbW9zdCByZWNlbnQgbWVzc2FnZXMgaW5cbiAgICAgKiB0aGUgdGhyZWFkLiBXaGVuIHNldCB0byBgYXV0b2AsIG1lc3NhZ2VzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHRocmVhZCB3aWxsIGJlXG4gICAgICogZHJvcHBlZCB0byBmaXQgdGhlIGNvbnRleHQgbGVuZ3RoIG9mIHRoZSBtb2RlbCwgYG1heF9wcm9tcHRfdG9rZW5zYC5cbiAgICAgKi9cbiAgICB0eXBlOiAnYXV0bycgfCAnbGFzdF9tZXNzYWdlcyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGZyb20gdGhlIHRocmVhZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgY29udGV4dFxuICAgICAqIGZvciB0aGUgcnVuLlxuICAgICAqL1xuICAgIGxhc3RfbWVzc2FnZXM/OiBudW1iZXIgfCBudWxsO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zID1cbiAgfCBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc05vblN0cmVhbWluZ1xuICB8IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdG9vbHMgZm9yIHdoaWNoIHRoZSBvdXRwdXRzIGFyZSBiZWluZyBzdWJtaXR0ZWQuXG4gICAqL1xuICB0b29sX291dHB1dHM6IEFycmF5PFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zLlRvb2xPdXRwdXQ+O1xuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHJldHVybnMgYSBzdHJlYW0gb2YgZXZlbnRzIHRoYXQgaGFwcGVuIGR1cmluZyB0aGUgUnVuIGFzIHNlcnZlci1zZW50XG4gICAqIGV2ZW50cywgdGVybWluYXRpbmcgd2hlbiB0aGUgUnVuIGVudGVycyBhIHRlcm1pbmFsIHN0YXRlIHdpdGggYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKi9cbiAgc3RyZWFtPzogYm9vbGVhbiB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXMge1xuICBleHBvcnQgaW50ZXJmYWNlIFRvb2xPdXRwdXQge1xuICAgIC8qKlxuICAgICAqIFRoZSBvdXRwdXQgb2YgdGhlIHRvb2wgY2FsbCB0byBiZSBzdWJtaXR0ZWQgdG8gY29udGludWUgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBvdXRwdXQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbCBpbiB0aGUgYHJlcXVpcmVkX2FjdGlvbmAgb2JqZWN0IHdpdGhpbiB0aGUgcnVuIG9iamVjdFxuICAgICAqIHRoZSBvdXRwdXQgaXMgYmVpbmcgc3VibWl0dGVkIGZvci5cbiAgICAgKi9cbiAgICB0b29sX2NhbGxfaWQ/OiBzdHJpbmc7XG4gIH1cblxuICBleHBvcnQgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc05vblN0cmVhbWluZyA9IFJ1bnNBUEkuUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNOb25TdHJlYW1pbmc7XG4gIGV4cG9ydCB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtaW5nID0gUnVuc0FQSS5SdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbWluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc05vblN0cmVhbWluZyBleHRlbmRzIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHJldHVybnMgYSBzdHJlYW0gb2YgZXZlbnRzIHRoYXQgaGFwcGVuIGR1cmluZyB0aGUgUnVuIGFzIHNlcnZlci1zZW50XG4gICAqIGV2ZW50cywgdGVybWluYXRpbmcgd2hlbiB0aGUgUnVuIGVudGVycyBhIHRlcm1pbmFsIHN0YXRlIHdpdGggYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKi9cbiAgc3RyZWFtPzogZmFsc2UgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtaW5nIGV4dGVuZHMgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgcmV0dXJucyBhIHN0cmVhbSBvZiBldmVudHMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoZSBSdW4gYXMgc2VydmVyLXNlbnRcbiAgICogZXZlbnRzLCB0ZXJtaW5hdGluZyB3aGVuIHRoZSBSdW4gZW50ZXJzIGEgdGVybWluYWwgc3RhdGUgd2l0aCBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqL1xuICBzdHJlYW06IHRydWU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuU3VibWl0VG9vbE91dHB1dHNBbmRQb2xsUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0b29scyBmb3Igd2hpY2ggdGhlIG91dHB1dHMgYXJlIGJlaW5nIHN1Ym1pdHRlZC5cbiAgICovXG4gIHRvb2xfb3V0cHV0czogQXJyYXk8UnVuU3VibWl0VG9vbE91dHB1dHNBbmRQb2xsUGFyYW1zLlRvb2xPdXRwdXQ+O1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzQW5kUG9sbFBhcmFtcyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbE91dHB1dCB7XG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dCBvZiB0aGUgdG9vbCBjYWxsIHRvIGJlIHN1Ym1pdHRlZCB0byBjb250aW51ZSB0aGUgcnVuLlxuICAgICAqL1xuICAgIG91dHB1dD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsIGluIHRoZSBgcmVxdWlyZWRfYWN0aW9uYCBvYmplY3Qgd2l0aGluIHRoZSBydW4gb2JqZWN0XG4gICAgICogdGhlIG91dHB1dCBpcyBiZWluZyBzdWJtaXR0ZWQgZm9yLlxuICAgICAqL1xuICAgIHRvb2xfY2FsbF9pZD86IHN0cmluZztcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzU3RyZWFtUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0b29scyBmb3Igd2hpY2ggdGhlIG91dHB1dHMgYXJlIGJlaW5nIHN1Ym1pdHRlZC5cbiAgICovXG4gIHRvb2xfb3V0cHV0czogQXJyYXk8UnVuU3VibWl0VG9vbE91dHB1dHNTdHJlYW1QYXJhbXMuVG9vbE91dHB1dD47XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuU3VibWl0VG9vbE91dHB1dHNTdHJlYW1QYXJhbXMge1xuICBleHBvcnQgaW50ZXJmYWNlIFRvb2xPdXRwdXQge1xuICAgIC8qKlxuICAgICAqIFRoZSBvdXRwdXQgb2YgdGhlIHRvb2wgY2FsbCB0byBiZSBzdWJtaXR0ZWQgdG8gY29udGludWUgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBvdXRwdXQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbCBpbiB0aGUgYHJlcXVpcmVkX2FjdGlvbmAgb2JqZWN0IHdpdGhpbiB0aGUgcnVuIG9iamVjdFxuICAgICAqIHRoZSBvdXRwdXQgaXMgYmVpbmcgc3VibWl0dGVkIGZvci5cbiAgICAgKi9cbiAgICB0b29sX2NhbGxfaWQ/OiBzdHJpbmc7XG4gIH1cbn1cblxuUnVucy5SdW5zUGFnZSA9IFJ1bnNQYWdlO1xuUnVucy5TdGVwcyA9IFN0ZXBzO1xuUnVucy5SdW5TdGVwc1BhZ2UgPSBSdW5TdGVwc1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBSdW5zIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIFJlcXVpcmVkQWN0aW9uRnVuY3Rpb25Ub29sQ2FsbCBhcyBSZXF1aXJlZEFjdGlvbkZ1bmN0aW9uVG9vbENhbGwsXG4gICAgdHlwZSBSdW4gYXMgUnVuLFxuICAgIHR5cGUgUnVuU3RhdHVzIGFzIFJ1blN0YXR1cyxcbiAgICBSdW5zUGFnZSBhcyBSdW5zUGFnZSxcbiAgICB0eXBlIFJ1bkNyZWF0ZVBhcmFtcyBhcyBSdW5DcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBSdW5DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgYXMgUnVuQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGFzIFJ1bkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgICB0eXBlIFJ1blVwZGF0ZVBhcmFtcyBhcyBSdW5VcGRhdGVQYXJhbXMsXG4gICAgdHlwZSBSdW5MaXN0UGFyYW1zIGFzIFJ1bkxpc3RQYXJhbXMsXG4gICAgdHlwZSBSdW5DcmVhdGVBbmRQb2xsUGFyYW1zLFxuICAgIHR5cGUgUnVuQ3JlYXRlQW5kU3RyZWFtUGFyYW1zLFxuICAgIHR5cGUgUnVuU3RyZWFtUGFyYW1zLFxuICAgIHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXMgYXMgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXMsXG4gICAgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc05vblN0cmVhbWluZyBhcyBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtaW5nIGFzIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtaW5nLFxuICAgIHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNBbmRQb2xsUGFyYW1zLFxuICAgIHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNTdHJlYW1QYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHtcbiAgICBTdGVwcyBhcyBTdGVwcyxcbiAgICB0eXBlIENvZGVJbnRlcnByZXRlckxvZ3MgYXMgQ29kZUludGVycHJldGVyTG9ncyxcbiAgICB0eXBlIENvZGVJbnRlcnByZXRlck91dHB1dEltYWdlIGFzIENvZGVJbnRlcnByZXRlck91dHB1dEltYWdlLFxuICAgIHR5cGUgQ29kZUludGVycHJldGVyVG9vbENhbGwgYXMgQ29kZUludGVycHJldGVyVG9vbENhbGwsXG4gICAgdHlwZSBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbERlbHRhIGFzIENvZGVJbnRlcnByZXRlclRvb2xDYWxsRGVsdGEsXG4gICAgdHlwZSBGaWxlU2VhcmNoVG9vbENhbGwgYXMgRmlsZVNlYXJjaFRvb2xDYWxsLFxuICAgIHR5cGUgRmlsZVNlYXJjaFRvb2xDYWxsRGVsdGEgYXMgRmlsZVNlYXJjaFRvb2xDYWxsRGVsdGEsXG4gICAgdHlwZSBGdW5jdGlvblRvb2xDYWxsIGFzIEZ1bmN0aW9uVG9vbENhbGwsXG4gICAgdHlwZSBGdW5jdGlvblRvb2xDYWxsRGVsdGEgYXMgRnVuY3Rpb25Ub29sQ2FsbERlbHRhLFxuICAgIHR5cGUgTWVzc2FnZUNyZWF0aW9uU3RlcERldGFpbHMgYXMgTWVzc2FnZUNyZWF0aW9uU3RlcERldGFpbHMsXG4gICAgdHlwZSBSdW5TdGVwIGFzIFJ1blN0ZXAsXG4gICAgdHlwZSBSdW5TdGVwRGVsdGEgYXMgUnVuU3RlcERlbHRhLFxuICAgIHR5cGUgUnVuU3RlcERlbHRhRXZlbnQgYXMgUnVuU3RlcERlbHRhRXZlbnQsXG4gICAgdHlwZSBSdW5TdGVwRGVsdGFNZXNzYWdlRGVsdGEgYXMgUnVuU3RlcERlbHRhTWVzc2FnZURlbHRhLFxuICAgIHR5cGUgUnVuU3RlcEluY2x1ZGUgYXMgUnVuU3RlcEluY2x1ZGUsXG4gICAgdHlwZSBUb29sQ2FsbCBhcyBUb29sQ2FsbCxcbiAgICB0eXBlIFRvb2xDYWxsRGVsdGEgYXMgVG9vbENhbGxEZWx0YSxcbiAgICB0eXBlIFRvb2xDYWxsRGVsdGFPYmplY3QgYXMgVG9vbENhbGxEZWx0YU9iamVjdCxcbiAgICB0eXBlIFRvb2xDYWxsc1N0ZXBEZXRhaWxzIGFzIFRvb2xDYWxsc1N0ZXBEZXRhaWxzLFxuICAgIFJ1blN0ZXBzUGFnZSBhcyBSdW5TdGVwc1BhZ2UsXG4gICAgdHlwZSBTdGVwUmV0cmlldmVQYXJhbXMgYXMgU3RlcFJldHJpZXZlUGFyYW1zLFxuICAgIHR5cGUgU3RlcExpc3RQYXJhbXMgYXMgU3RlcExpc3RQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgeyBBc3Npc3RhbnRTdHJlYW0sIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc0Jhc2VTdHJlYW0gfSBmcm9tICcuLi8uLi8uLi9saWIvQXNzaXN0YW50U3RyZWFtJztcbmltcG9ydCB7IEFQSVByb21pc2UgfSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBUaHJlYWRzQVBJIGZyb20gJy4vdGhyZWFkcyc7XG5pbXBvcnQgKiBhcyBTaGFyZWQgZnJvbSAnLi4vLi4vc2hhcmVkJztcbmltcG9ydCAqIGFzIEFzc2lzdGFudHNBUEkgZnJvbSAnLi4vYXNzaXN0YW50cyc7XG5pbXBvcnQgKiBhcyBDaGF0QVBJIGZyb20gJy4uLy4uL2NoYXQvY2hhdCc7XG5pbXBvcnQgKiBhcyBNZXNzYWdlc0FQSSBmcm9tICcuL21lc3NhZ2VzJztcbmltcG9ydCB7XG4gIEFubm90YXRpb24sXG4gIEFubm90YXRpb25EZWx0YSxcbiAgRmlsZUNpdGF0aW9uQW5ub3RhdGlvbixcbiAgRmlsZUNpdGF0aW9uRGVsdGFBbm5vdGF0aW9uLFxuICBGaWxlUGF0aEFubm90YXRpb24sXG4gIEZpbGVQYXRoRGVsdGFBbm5vdGF0aW9uLFxuICBJbWFnZUZpbGUsXG4gIEltYWdlRmlsZUNvbnRlbnRCbG9jayxcbiAgSW1hZ2VGaWxlRGVsdGEsXG4gIEltYWdlRmlsZURlbHRhQmxvY2ssXG4gIEltYWdlVVJMLFxuICBJbWFnZVVSTENvbnRlbnRCbG9jayxcbiAgSW1hZ2VVUkxEZWx0YSxcbiAgSW1hZ2VVUkxEZWx0YUJsb2NrLFxuICBNZXNzYWdlIGFzIE1lc3NhZ2VzQVBJTWVzc2FnZSxcbiAgTWVzc2FnZUNvbnRlbnQsXG4gIE1lc3NhZ2VDb250ZW50RGVsdGEsXG4gIE1lc3NhZ2VDb250ZW50UGFydFBhcmFtLFxuICBNZXNzYWdlQ3JlYXRlUGFyYW1zLFxuICBNZXNzYWdlRGVsZXRlZCxcbiAgTWVzc2FnZURlbHRhLFxuICBNZXNzYWdlRGVsdGFFdmVudCxcbiAgTWVzc2FnZUxpc3RQYXJhbXMsXG4gIE1lc3NhZ2VVcGRhdGVQYXJhbXMsXG4gIE1lc3NhZ2VzLFxuICBNZXNzYWdlc1BhZ2UsXG4gIFJlZnVzYWxDb250ZW50QmxvY2ssXG4gIFJlZnVzYWxEZWx0YUJsb2NrLFxuICBUZXh0LFxuICBUZXh0Q29udGVudEJsb2NrLFxuICBUZXh0Q29udGVudEJsb2NrUGFyYW0sXG4gIFRleHREZWx0YSxcbiAgVGV4dERlbHRhQmxvY2ssXG59IGZyb20gJy4vbWVzc2FnZXMnO1xuaW1wb3J0ICogYXMgVmVjdG9yU3RvcmVzQVBJIGZyb20gJy4uL3ZlY3Rvci1zdG9yZXMvdmVjdG9yLXN0b3Jlcyc7XG5pbXBvcnQgKiBhcyBSdW5zQVBJIGZyb20gJy4vcnVucy9ydW5zJztcbmltcG9ydCB7XG4gIFJlcXVpcmVkQWN0aW9uRnVuY3Rpb25Ub29sQ2FsbCxcbiAgUnVuLFxuICBSdW5DcmVhdGVBbmRQb2xsUGFyYW1zLFxuICBSdW5DcmVhdGVBbmRTdHJlYW1QYXJhbXMsXG4gIFJ1bkNyZWF0ZVBhcmFtcyxcbiAgUnVuQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gIFJ1bkxpc3RQYXJhbXMsXG4gIFJ1blN0YXR1cyxcbiAgUnVuU3RyZWFtUGFyYW1zLFxuICBSdW5TdWJtaXRUb29sT3V0cHV0c0FuZFBvbGxQYXJhbXMsXG4gIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zLFxuICBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc05vblN0cmVhbWluZyxcbiAgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmcsXG4gIFJ1blN1Ym1pdFRvb2xPdXRwdXRzU3RyZWFtUGFyYW1zLFxuICBSdW5VcGRhdGVQYXJhbXMsXG4gIFJ1bnMsXG4gIFJ1bnNQYWdlLFxufSBmcm9tICcuL3J1bnMvcnVucyc7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tICcuLi8uLi8uLi9zdHJlYW1pbmcnO1xuXG5leHBvcnQgY2xhc3MgVGhyZWFkcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgcnVuczogUnVuc0FQSS5SdW5zID0gbmV3IFJ1bnNBUEkuUnVucyh0aGlzLl9jbGllbnQpO1xuICBtZXNzYWdlczogTWVzc2FnZXNBUEkuTWVzc2FnZXMgPSBuZXcgTWVzc2FnZXNBUEkuTWVzc2FnZXModGhpcy5fY2xpZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGhyZWFkLlxuICAgKi9cbiAgY3JlYXRlKGJvZHk/OiBUaHJlYWRDcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFRocmVhZD47XG4gIGNyZWF0ZShvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxUaHJlYWQ+O1xuICBjcmVhdGUoXG4gICAgYm9keTogVGhyZWFkQ3JlYXRlUGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VGhyZWFkPiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMoYm9keSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh7fSwgYm9keSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL3RocmVhZHMnLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgdGhyZWFkLlxuICAgKi9cbiAgcmV0cmlldmUodGhyZWFkSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8VGhyZWFkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC90aHJlYWRzLyR7dGhyZWFkSWR9YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZpZXMgYSB0aHJlYWQuXG4gICAqL1xuICB1cGRhdGUodGhyZWFkSWQ6IHN0cmluZywgYm9keTogVGhyZWFkVXBkYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxUaHJlYWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9YCwge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHRocmVhZC5cbiAgICovXG4gIGRlbCh0aHJlYWRJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxUaHJlYWREZWxldGVkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5kZWxldGUoYC90aHJlYWRzLyR7dGhyZWFkSWR9YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGhyZWFkIGFuZCBydW4gaXQgaW4gb25lIHJlcXVlc3QuXG4gICAqL1xuICBjcmVhdGVBbmRSdW4oXG4gICAgYm9keTogVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFJ1bnNBUEkuUnVuPjtcbiAgY3JlYXRlQW5kUnVuKFxuICAgIGJvZHk6IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc1N0cmVhbWluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4+O1xuICBjcmVhdGVBbmRSdW4oXG4gICAgYm9keTogVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zQmFzZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4gfCBSdW5zQVBJLlJ1bj47XG4gIGNyZWF0ZUFuZFJ1bihcbiAgICBib2R5OiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8UnVuc0FQSS5SdW4+IHwgQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy90aHJlYWRzL3J1bnMnLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICBzdHJlYW06IGJvZHkuc3RyZWFtID8/IGZhbHNlLFxuICAgIH0pIGFzIEFQSVByb21pc2U8UnVuc0FQSS5SdW4+IHwgQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4+O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIHRvIGNyZWF0ZSBhIHRocmVhZCwgc3RhcnQgYSBydW4gYW5kIHRoZW4gcG9sbCBmb3IgYSB0ZXJtaW5hbCBzdGF0ZS5cbiAgICogTW9yZSBpbmZvcm1hdGlvbiBvbiBSdW4gbGlmZWN5Y2xlcyBjYW4gYmUgZm91bmQgaGVyZTpcbiAgICogaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy9ob3ctaXQtd29ya3MvcnVucy1hbmQtcnVuLXN0ZXBzXG4gICAqL1xuICBhc3luYyBjcmVhdGVBbmRSdW5Qb2xsKFxuICAgIGJvZHk6IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc05vblN0cmVhbWluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyAmIHsgcG9sbEludGVydmFsTXM/OiBudW1iZXIgfSxcbiAgKTogUHJvbWlzZTxUaHJlYWRzLlJ1bj4ge1xuICAgIGNvbnN0IHJ1biA9IGF3YWl0IHRoaXMuY3JlYXRlQW5kUnVuKGJvZHksIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnJ1bnMucG9sbChydW4udGhyZWFkX2lkLCBydW4uaWQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRocmVhZCBhbmQgc3RyZWFtIHRoZSBydW4gYmFja1xuICAgKi9cbiAgY3JlYXRlQW5kUnVuU3RyZWFtKFxuICAgIGJvZHk6IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc0Jhc2VTdHJlYW0sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFzc2lzdGFudFN0cmVhbSB7XG4gICAgcmV0dXJuIEFzc2lzdGFudFN0cmVhbS5jcmVhdGVUaHJlYWRBc3Npc3RhbnRTdHJlYW0oYm9keSwgdGhpcy5fY2xpZW50LmJldGEudGhyZWFkcywgb3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gKiBbR1BULTRvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTRvKSxcbiAqIFtHUFQtNCBUdXJib10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00LXR1cmJvLWFuZC1ncHQtNCksXG4gKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICpcbiAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9zY2hlbWFcIiwgXCJqc29uX3NjaGVtYVwiOiB7Li4ufSB9YCBlbmFibGVzIFN0cnVjdHVyZWRcbiAqIE91dHB1dHMgd2hpY2ggZW5zdXJlcyB0aGUgbW9kZWwgd2lsbCBtYXRjaCB5b3VyIHN1cHBsaWVkIEpTT04gc2NoZW1hLiBMZWFybiBtb3JlXG4gKiBpbiB0aGVcbiAqIFtTdHJ1Y3R1cmVkIE91dHB1dHMgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zdHJ1Y3R1cmVkLW91dHB1dHMpLlxuICpcbiAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9vYmplY3RcIiB9YCBlbmFibGVzIEpTT04gbW9kZSwgd2hpY2ggZW5zdXJlcyB0aGVcbiAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICpcbiAqICoqSW1wb3J0YW50OioqIHdoZW4gdXNpbmcgSlNPTiBtb2RlLCB5b3UgKiptdXN0KiogYWxzbyBpbnN0cnVjdCB0aGUgbW9kZWwgdG9cbiAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gKiBsaW1pdCwgcmVzdWx0aW5nIGluIGEgbG9uZy1ydW5uaW5nIGFuZCBzZWVtaW5nbHkgXCJzdHVja1wiIHJlcXVlc3QuIEFsc28gbm90ZSB0aGF0XG4gKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAqIG1heCBjb250ZXh0IGxlbmd0aC5cbiAqL1xuZXhwb3J0IHR5cGUgQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gPVxuICB8ICdhdXRvJ1xuICB8IFNoYXJlZC5SZXNwb25zZUZvcm1hdFRleHRcbiAgfCBTaGFyZWQuUmVzcG9uc2VGb3JtYXRKU09OT2JqZWN0XG4gIHwgU2hhcmVkLlJlc3BvbnNlRm9ybWF0SlNPTlNjaGVtYTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSB0b29sIHRoZSBtb2RlbCBzaG91bGQgdXNlLiBVc2UgdG8gZm9yY2UgdGhlIG1vZGVsIHRvIGNhbGwgYSBzcGVjaWZpY1xuICogdG9vbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBc3Npc3RhbnRUb29sQ2hvaWNlIHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSB0b29sLiBJZiB0eXBlIGlzIGBmdW5jdGlvbmAsIHRoZSBmdW5jdGlvbiBuYW1lIG11c3QgYmUgc2V0XG4gICAqL1xuICB0eXBlOiAnZnVuY3Rpb24nIHwgJ2NvZGVfaW50ZXJwcmV0ZXInIHwgJ2ZpbGVfc2VhcmNoJztcblxuICBmdW5jdGlvbj86IEFzc2lzdGFudFRvb2xDaG9pY2VGdW5jdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBc3Npc3RhbnRUb29sQ2hvaWNlRnVuY3Rpb24ge1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAqL1xuICBuYW1lOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgdG9vbCBpcyBjYWxsZWQgYnkgdGhlIG1vZGVsLiBgbm9uZWAgbWVhbnMgdGhlIG1vZGVsIHdpbGxcbiAqIG5vdCBjYWxsIGFueSB0b29scyBhbmQgaW5zdGVhZCBnZW5lcmF0ZXMgYSBtZXNzYWdlLiBgYXV0b2AgaXMgdGhlIGRlZmF1bHQgdmFsdWVcbiAqIGFuZCBtZWFucyB0aGUgbW9kZWwgY2FuIHBpY2sgYmV0d2VlbiBnZW5lcmF0aW5nIGEgbWVzc2FnZSBvciBjYWxsaW5nIG9uZSBvciBtb3JlXG4gKiB0b29scy4gYHJlcXVpcmVkYCBtZWFucyB0aGUgbW9kZWwgbXVzdCBjYWxsIG9uZSBvciBtb3JlIHRvb2xzIGJlZm9yZSByZXNwb25kaW5nXG4gKiB0byB0aGUgdXNlci4gU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgdG9vbCBsaWtlIGB7XCJ0eXBlXCI6IFwiZmlsZV9zZWFyY2hcIn1gIG9yXG4gKiBge1widHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIm15X2Z1bmN0aW9uXCJ9fWAgZm9yY2VzIHRoZSBtb2RlbCB0b1xuICogY2FsbCB0aGF0IHRvb2wuXG4gKi9cbmV4cG9ydCB0eXBlIEFzc2lzdGFudFRvb2xDaG9pY2VPcHRpb24gPSAnbm9uZScgfCAnYXV0bycgfCAncmVxdWlyZWQnIHwgQXNzaXN0YW50VG9vbENob2ljZTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdGhyZWFkIHRoYXQgY29udGFpbnNcbiAqIFttZXNzYWdlc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcykuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkIHtcbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgdGhyZWFkIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YTogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGB0aHJlYWRgLlxuICAgKi9cbiAgb2JqZWN0OiAndGhyZWFkJztcblxuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBhc3Npc3RhbnQncyB0b29scyBpbiB0aGlzXG4gICAqIHRocmVhZC4gVGhlIHJlc291cmNlcyBhcmUgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZVxuICAgKiBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgXG4gICAqIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBJRHMuXG4gICAqL1xuICB0b29sX3Jlc291cmNlczogVGhyZWFkLlRvb2xSZXNvdXJjZXMgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFRocmVhZCB7XG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgY29kZV9pbnRlcnByZXRlcj86IFRvb2xSZXNvdXJjZXMuQ29kZUludGVycHJldGVyO1xuXG4gICAgZmlsZV9zZWFyY2g/OiBUb29sUmVzb3VyY2VzLkZpbGVTZWFyY2g7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgbWFkZVxuICAgICAgICogYXZhaWxhYmxlIHRvIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlc1xuICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyB0aHJlYWQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAqIHRoZSB0aHJlYWQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRocmVhZERlbGV0ZWQge1xuICBpZDogc3RyaW5nO1xuXG4gIGRlbGV0ZWQ6IGJvb2xlYW47XG5cbiAgb2JqZWN0OiAndGhyZWFkLmRlbGV0ZWQnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRocmVhZENyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgW21lc3NhZ2VzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzKSB0b1xuICAgKiBzdGFydCB0aGUgdGhyZWFkIHdpdGguXG4gICAqL1xuICBtZXNzYWdlcz86IEFycmF5PFRocmVhZENyZWF0ZVBhcmFtcy5NZXNzYWdlPjtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBhc3Npc3RhbnQncyB0b29scyBpbiB0aGlzXG4gICAqIHRocmVhZC4gVGhlIHJlc291cmNlcyBhcmUgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZVxuICAgKiBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgXG4gICAqIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBJRHMuXG4gICAqL1xuICB0b29sX3Jlc291cmNlcz86IFRocmVhZENyZWF0ZVBhcmFtcy5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBUaHJlYWRDcmVhdGVQYXJhbXMge1xuICBleHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PE1lc3NhZ2VzQVBJLk1lc3NhZ2VDb250ZW50UGFydFBhcmFtPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSByb2xlIG9mIHRoZSBlbnRpdHkgdGhhdCBpcyBjcmVhdGluZyB0aGUgbWVzc2FnZS4gQWxsb3dlZCB2YWx1ZXMgaW5jbHVkZTpcbiAgICAgKlxuICAgICAqIC0gYHVzZXJgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgc2VudCBieSBhbiBhY3R1YWwgdXNlciBhbmQgc2hvdWxkIGJlIHVzZWQgaW5cbiAgICAgKiAgIG1vc3QgY2FzZXMgdG8gcmVwcmVzZW50IHVzZXItZ2VuZXJhdGVkIG1lc3NhZ2VzLlxuICAgICAqIC0gYGFzc2lzdGFudGA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBnZW5lcmF0ZWQgYnkgdGhlIGFzc2lzdGFudC4gVXNlIHRoaXNcbiAgICAgKiAgIHZhbHVlIHRvIGluc2VydCBtZXNzYWdlcyBmcm9tIHRoZSBhc3Npc3RhbnQgaW50byB0aGUgY29udmVyc2F0aW9uLlxuICAgICAqL1xuICAgIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xuXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIHRoZSBtZXNzYWdlLCBhbmQgdGhlIHRvb2xzIHRoZXkgc2hvdWxkIGJlIGFkZGVkIHRvLlxuICAgICAqL1xuICAgIGF0dGFjaG1lbnRzPzogQXJyYXk8TWVzc2FnZS5BdHRhY2htZW50PiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICovXG4gICAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgTWVzc2FnZSB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBBdHRhY2htZW50IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIElEIG9mIHRoZSBmaWxlIHRvIGF0dGFjaCB0byB0aGUgbWVzc2FnZS5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZD86IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdG9vbHMgdG8gYWRkIHRoaXMgZmlsZSB0by5cbiAgICAgICAqL1xuICAgICAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkNvZGVJbnRlcnByZXRlclRvb2wgfCBBdHRhY2htZW50LkZpbGVTZWFyY2g+O1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgQXR0YWNobWVudCB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdG9vbCBiZWluZyBkZWZpbmVkOiBgZmlsZV9zZWFyY2hgXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnZmlsZV9zZWFyY2gnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgY29kZV9pbnRlcnByZXRlcj86IFRvb2xSZXNvdXJjZXMuQ29kZUludGVycHJldGVyO1xuXG4gICAgZmlsZV9zZWFyY2g/OiBUb29sUmVzb3VyY2VzLkZpbGVTZWFyY2g7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgbWFkZVxuICAgICAgICogYXZhaWxhYmxlIHRvIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlc1xuICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyB0aHJlYWQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAqIHRoZSB0aHJlYWQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgaGVscGVyIHRvIGNyZWF0ZSBhXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogd2l0aCBmaWxlX2lkcyBhbmQgYXR0YWNoIGl0IHRvIHRoaXMgdGhyZWFkLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yXG4gICAgICAgKiBzdG9yZSBhdHRhY2hlZCB0byB0aGUgdGhyZWFkLlxuICAgICAgICovXG4gICAgICB2ZWN0b3Jfc3RvcmVzPzogQXJyYXk8RmlsZVNlYXJjaC5WZWN0b3JTdG9yZT47XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmUge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNodW5raW5nIHN0cmF0ZWd5IHVzZWQgdG8gY2h1bmsgdGhlIGZpbGUocykuIElmIG5vdCBzZXQsIHdpbGwgdXNlIHRoZSBgYXV0b2BcbiAgICAgICAgICogc3RyYXRlZ3kuIE9ubHkgYXBwbGljYWJsZSBpZiBgZmlsZV9pZHNgIGlzIG5vbi1lbXB0eS5cbiAgICAgICAgICovXG4gICAgICAgIGNodW5raW5nX3N0cmF0ZWd5PzogVmVjdG9yU3RvcmVzQVBJLkZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIHRvXG4gICAgICAgICAqIGFkZCB0byB0aGUgdmVjdG9yIHN0b3JlLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEwMDAwIGZpbGVzIGluIGEgdmVjdG9yXG4gICAgICAgICAqIHN0b3JlLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdmVjdG9yIHN0b3JlLiBUaGlzIGNhbiBiZVxuICAgICAgICAgKiB1c2VmdWwgZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdmVjdG9yIHN0b3JlIGluIGEgc3RydWN0dXJlZFxuICAgICAgICAgKiBmb3JtYXQuIEtleXMgY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW1cbiAgICAgICAgICogb2YgNTEyIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgICAgICovXG4gICAgICAgIG1ldGFkYXRhPzogdW5rbm93bjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaHJlYWRVcGRhdGVQYXJhbXMge1xuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBhc3Npc3RhbnQncyB0b29scyBpbiB0aGlzXG4gICAqIHRocmVhZC4gVGhlIHJlc291cmNlcyBhcmUgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZVxuICAgKiBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgXG4gICAqIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBJRHMuXG4gICAqL1xuICB0b29sX3Jlc291cmNlcz86IFRocmVhZFVwZGF0ZVBhcmFtcy5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBUaHJlYWRVcGRhdGVQYXJhbXMge1xuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBhc3Npc3RhbnQncyB0b29scyBpbiB0aGlzXG4gICAqIHRocmVhZC4gVGhlIHJlc291cmNlcyBhcmUgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZVxuICAgKiBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgXG4gICAqIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBJRHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGNvZGVfaW50ZXJwcmV0ZXI/OiBUb29sUmVzb3VyY2VzLkNvZGVJbnRlcnByZXRlcjtcblxuICAgIGZpbGVfc2VhcmNoPzogVG9vbFJlc291cmNlcy5GaWxlU2VhcmNoO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIG1hZGVcbiAgICAgICAqIGF2YWlsYWJsZSB0byB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMjAgZmlsZXNcbiAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9vbC5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZVxuICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgdGhyZWFkLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvXG4gICAgICAgKiB0aGUgdGhyZWFkLlxuICAgICAgICovXG4gICAgICB2ZWN0b3Jfc3RvcmVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zID1cbiAgfCBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNOb25TdHJlYW1pbmdcbiAgfCBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNTdHJlYW1pbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdG8gdXNlIHRvXG4gICAqIGV4ZWN1dGUgdGhpcyBydW4uXG4gICAqL1xuICBhc3Npc3RhbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgc3lzdGVtIG1lc3NhZ2Ugb2YgdGhlIGFzc2lzdGFudC4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zIHRoYXQgbWF5IGJlIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZVxuICAgKiBydW4uIFRoZSBydW4gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdXNlIG9ubHkgdGhlIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2Vuc1xuICAgKiBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlIG51bWJlciBvZlxuICAgKiBjb21wbGV0aW9uIHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLiBTZWVcbiAgICogYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9jb21wbGV0aW9uX3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zIHRoYXQgbWF5IGJlIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBydW4uXG4gICAqIFRoZSBydW4gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdXNlIG9ubHkgdGhlIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zXG4gICAqIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGUgbnVtYmVyIG9mXG4gICAqIHByb21wdCB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC4gU2VlXG4gICAqIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfcHJvbXB0X3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgW01vZGVsXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscykgdG9cbiAgICogYmUgdXNlZCB0byBleGVjdXRlIHRoaXMgcnVuLiBJZiBhIHZhbHVlIGlzIHByb3ZpZGVkIGhlcmUsIGl0IHdpbGwgb3ZlcnJpZGUgdGhlXG4gICAqIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzaXN0YW50LiBJZiBub3QsIHRoZSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAqIGFzc2lzdGFudCB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICBtb2RlbD86IChzdHJpbmcgJiB7fSkgfCBDaGF0QVBJLkNoYXRNb2RlbCB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlXG4gICAqIFtwYXJhbGxlbCBmdW5jdGlvbiBjYWxsaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZnVuY3Rpb24tY2FsbGluZyNjb25maWd1cmluZy1wYXJhbGxlbC1mdW5jdGlvbi1jYWxsaW5nKVxuICAgKiBkdXJpbmcgdG9vbCB1c2UuXG4gICAqL1xuICBwYXJhbGxlbF90b29sX2NhbGxzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBmb3JtYXQgdGhhdCB0aGUgbW9kZWwgbXVzdCBvdXRwdXQuIENvbXBhdGlibGUgd2l0aFxuICAgKiBbR1BULTRvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTRvKSxcbiAgICogW0dQVC00IFR1cmJvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTQtdHVyYm8tYW5kLWdwdC00KSxcbiAgICogYW5kIGFsbCBHUFQtMy41IFR1cmJvIG1vZGVscyBzaW5jZSBgZ3B0LTMuNS10dXJiby0xMTA2YC5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX3NjaGVtYVwiLCBcImpzb25fc2NoZW1hXCI6IHsuLi59IH1gIGVuYWJsZXMgU3RydWN0dXJlZFxuICAgKiBPdXRwdXRzIHdoaWNoIGVuc3VyZXMgdGhlIG1vZGVsIHdpbGwgbWF0Y2ggeW91ciBzdXBwbGllZCBKU09OIHNjaGVtYS4gTGVhcm4gbW9yZVxuICAgKiBpbiB0aGVcbiAgICogW1N0cnVjdHVyZWQgT3V0cHV0cyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3N0cnVjdHVyZWQtb3V0cHV0cykuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9vYmplY3RcIiB9YCBlbmFibGVzIEpTT04gbW9kZSwgd2hpY2ggZW5zdXJlcyB0aGVcbiAgICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gICAqXG4gICAqICoqSW1wb3J0YW50OioqIHdoZW4gdXNpbmcgSlNPTiBtb2RlLCB5b3UgKiptdXN0KiogYWxzbyBpbnN0cnVjdCB0aGUgbW9kZWwgdG9cbiAgICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICAgKiBnZW5lcmF0ZSBhbiB1bmVuZGluZyBzdHJlYW0gb2Ygd2hpdGVzcGFjZSB1bnRpbCB0aGUgZ2VuZXJhdGlvbiByZWFjaGVzIHRoZSB0b2tlblxuICAgKiBsaW1pdCwgcmVzdWx0aW5nIGluIGEgbG9uZy1ydW5uaW5nIGFuZCBzZWVtaW5nbHkgXCJzdHVja1wiIHJlcXVlc3QuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICAgKiBpbmRpY2F0ZXMgdGhlIGdlbmVyYXRpb24gZXhjZWVkZWQgYG1heF90b2tlbnNgIG9yIHRoZSBjb252ZXJzYXRpb24gZXhjZWVkZWQgdGhlXG4gICAqIG1heCBjb250ZXh0IGxlbmd0aC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86IEFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogSWYgYHRydWVgLCByZXR1cm5zIGEgc3RyZWFtIG9mIGV2ZW50cyB0aGF0IGhhcHBlbiBkdXJpbmcgdGhlIFJ1biBhcyBzZXJ2ZXItc2VudFxuICAgKiBldmVudHMsIHRlcm1pbmF0aW5nIHdoZW4gdGhlIFJ1biBlbnRlcnMgYSB0ZXJtaW5hbCBzdGF0ZSB3aXRoIGEgYGRhdGE6IFtET05FXWBcbiAgICogbWVzc2FnZS5cbiAgICovXG4gIHN0cmVhbT86IGJvb2xlYW4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogSWYgbm8gdGhyZWFkIGlzIHByb3ZpZGVkLCBhbiBlbXB0eSB0aHJlYWQgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgdGhyZWFkPzogVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zLlRocmVhZDtcblxuICAvKipcbiAgICogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgdG9vbCBpcyBjYWxsZWQgYnkgdGhlIG1vZGVsLiBgbm9uZWAgbWVhbnMgdGhlIG1vZGVsIHdpbGxcbiAgICogbm90IGNhbGwgYW55IHRvb2xzIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBpcyB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgKiBhbmQgbWVhbnMgdGhlIG1vZGVsIGNhbiBwaWNrIGJldHdlZW4gZ2VuZXJhdGluZyBhIG1lc3NhZ2Ugb3IgY2FsbGluZyBvbmUgb3IgbW9yZVxuICAgKiB0b29scy4gYHJlcXVpcmVkYCBtZWFucyB0aGUgbW9kZWwgbXVzdCBjYWxsIG9uZSBvciBtb3JlIHRvb2xzIGJlZm9yZSByZXNwb25kaW5nXG4gICAqIHRvIHRoZSB1c2VyLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciB0b29sIGxpa2UgYHtcInR5cGVcIjogXCJmaWxlX3NlYXJjaFwifWAgb3JcbiAgICogYHtcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifX1gIGZvcmNlcyB0aGUgbW9kZWwgdG9cbiAgICogY2FsbCB0aGF0IHRvb2wuXG4gICAqL1xuICB0b29sX2Nob2ljZT86IEFzc2lzdGFudFRvb2xDaG9pY2VPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgdXNlZCBieSB0aGUgYXNzaXN0YW50J3MgdG9vbHMuIFRoZSByZXNvdXJjZXMgYXJlXG4gICAqIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXNcbiAgICogYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVcbiAgICogSURzLlxuICAgKi9cbiAgdG9vbF9yZXNvdXJjZXM/OiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXMuVG9vbFJlc291cmNlcyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSB0b29scyB0aGUgYXNzaXN0YW50IGNhbiB1c2UgZm9yIHRoaXMgcnVuLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICB0b29scz86IEFycmF5PFxuICAgIEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEFzc2lzdGFudHNBUEkuRmlsZVNlYXJjaFRvb2wgfCBBc3Npc3RhbnRzQVBJLkZ1bmN0aW9uVG9vbFxuICA+IHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgdGVtcGVyYXR1cmUgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdG9wX3A/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgdHJ1bmNhdGlvbl9zdHJhdGVneT86IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtcy5UcnVuY2F0aW9uU3RyYXRlZ3kgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtcyB7XG4gIC8qKlxuICAgKiBJZiBubyB0aHJlYWQgaXMgcHJvdmlkZWQsIGFuIGVtcHR5IHRocmVhZCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZCB7XG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIFttZXNzYWdlc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcykgdG9cbiAgICAgKiBzdGFydCB0aGUgdGhyZWFkIHdpdGguXG4gICAgICovXG4gICAgbWVzc2FnZXM/OiBBcnJheTxUaHJlYWQuTWVzc2FnZT47XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICovXG4gICAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYXNzaXN0YW50J3MgdG9vbHMgaW4gdGhpc1xuICAgICAqIHRocmVhZC4gVGhlIHJlc291cmNlcyBhcmUgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZVxuICAgICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICAgKiB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgSURzLlxuICAgICAqL1xuICAgIHRvb2xfcmVzb3VyY2VzPzogVGhyZWFkLlRvb2xSZXNvdXJjZXMgfCBudWxsO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBUaHJlYWQge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxNZXNzYWdlc0FQSS5NZXNzYWdlQ29udGVudFBhcnRQYXJhbT47XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHJvbGUgb2YgdGhlIGVudGl0eSB0aGF0IGlzIGNyZWF0aW5nIHRoZSBtZXNzYWdlLiBBbGxvd2VkIHZhbHVlcyBpbmNsdWRlOlxuICAgICAgICpcbiAgICAgICAqIC0gYHVzZXJgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgc2VudCBieSBhbiBhY3R1YWwgdXNlciBhbmQgc2hvdWxkIGJlIHVzZWQgaW5cbiAgICAgICAqICAgbW9zdCBjYXNlcyB0byByZXByZXNlbnQgdXNlci1nZW5lcmF0ZWQgbWVzc2FnZXMuXG4gICAgICAgKiAtIGBhc3Npc3RhbnRgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBhc3Npc3RhbnQuIFVzZSB0aGlzXG4gICAgICAgKiAgIHZhbHVlIHRvIGluc2VydCBtZXNzYWdlcyBmcm9tIHRoZSBhc3Npc3RhbnQgaW50byB0aGUgY29udmVyc2F0aW9uLlxuICAgICAgICovXG4gICAgICByb2xlOiAndXNlcicgfCAnYXNzaXN0YW50JztcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgZmlsZXMgYXR0YWNoZWQgdG8gdGhlIG1lc3NhZ2UsIGFuZCB0aGUgdG9vbHMgdGhleSBzaG91bGQgYmUgYWRkZWQgdG8uXG4gICAgICAgKi9cbiAgICAgIGF0dGFjaG1lbnRzPzogQXJyYXk8TWVzc2FnZS5BdHRhY2htZW50PiB8IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgICAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICAgICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgICAgICogY2hhcmFjdGVycyBsb25nLlxuICAgICAgICovXG4gICAgICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgTWVzc2FnZSB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEF0dGFjaG1lbnQge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSBmaWxlIHRvIGF0dGFjaCB0byB0aGUgbWVzc2FnZS5cbiAgICAgICAgICovXG4gICAgICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b29scyB0byBhZGQgdGhpcyBmaWxlIHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkNvZGVJbnRlcnByZXRlclRvb2wgfCBBdHRhY2htZW50LkZpbGVTZWFyY2g+O1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgbmFtZXNwYWNlIEF0dGFjaG1lbnQge1xuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSB0eXBlIG9mIHRvb2wgYmVpbmcgZGVmaW5lZDogYGZpbGVfc2VhcmNoYFxuICAgICAgICAgICAqL1xuICAgICAgICAgIHR5cGU6ICdmaWxlX3NlYXJjaCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICAgKiB0aHJlYWQuIFRoZSByZXNvdXJjZXMgYXJlIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGVcbiAgICAgKiBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgXG4gICAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgICAgY29kZV9pbnRlcnByZXRlcj86IFRvb2xSZXNvdXJjZXMuQ29kZUludGVycHJldGVyO1xuXG4gICAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgbWFkZVxuICAgICAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzXG4gICAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9vbC5cbiAgICAgICAgICovXG4gICAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICAgIH1cblxuICAgICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZVxuICAgICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICAgKiBhdHRhY2hlZCB0byB0aGlzIHRocmVhZC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvciBzdG9yZSBhdHRhY2hlZCB0b1xuICAgICAgICAgKiB0aGUgdGhyZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgdmVjdG9yX3N0b3JlX2lkcz86IEFycmF5PHN0cmluZz47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgaGVscGVyIHRvIGNyZWF0ZSBhXG4gICAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgICAqIHdpdGggZmlsZV9pZHMgYW5kIGF0dGFjaCBpdCB0byB0aGlzIHRocmVhZC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvclxuICAgICAgICAgKiBzdG9yZSBhdHRhY2hlZCB0byB0aGUgdGhyZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgdmVjdG9yX3N0b3Jlcz86IEFycmF5PEZpbGVTZWFyY2guVmVjdG9yU3RvcmU+O1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgbmFtZXNwYWNlIEZpbGVTZWFyY2gge1xuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgY2h1bmtpbmcgc3RyYXRlZ3kgdXNlZCB0byBjaHVuayB0aGUgZmlsZShzKS4gSWYgbm90IHNldCwgd2lsbCB1c2UgdGhlIGBhdXRvYFxuICAgICAgICAgICAqIHN0cmF0ZWd5LiBPbmx5IGFwcGxpY2FibGUgaWYgYGZpbGVfaWRzYCBpcyBub24tZW1wdHkuXG4gICAgICAgICAgICovXG4gICAgICAgICAgY2h1bmtpbmdfc3RyYXRlZ3k/OiBWZWN0b3JTdG9yZXNBUEkuRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbTtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIHRvXG4gICAgICAgICAgICogYWRkIHRvIHRoZSB2ZWN0b3Igc3RvcmUuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMTAwMDAgZmlsZXMgaW4gYSB2ZWN0b3JcbiAgICAgICAgICAgKiBzdG9yZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdmVjdG9yIHN0b3JlLiBUaGlzIGNhbiBiZVxuICAgICAgICAgICAqIHVzZWZ1bCBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2ZWN0b3Igc3RvcmUgaW4gYSBzdHJ1Y3R1cmVkXG4gICAgICAgICAgICogZm9ybWF0LiBLZXlzIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtXG4gICAgICAgICAgICogb2YgNTEyIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBtZXRhZGF0YT86IHVua25vd247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIGFzc2lzdGFudCdzIHRvb2xzLiBUaGUgcmVzb3VyY2VzIGFyZVxuICAgKiBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzXG4gICAqIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlXG4gICAqIElEcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgY29kZV9pbnRlcnByZXRlcj86IFRvb2xSZXNvdXJjZXMuQ29kZUludGVycHJldGVyO1xuXG4gICAgZmlsZV9zZWFyY2g/OiBUb29sUmVzb3VyY2VzLkZpbGVTZWFyY2g7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgbWFkZVxuICAgICAgICogYXZhaWxhYmxlIHRvIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlc1xuICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIElEIG9mIHRoZVxuICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgYXNzaXN0YW50LiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvXG4gICAgICAgKiB0aGUgYXNzaXN0YW50LlxuICAgICAgICovXG4gICAgICB2ZWN0b3Jfc3RvcmVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVHJ1bmNhdGlvblN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJ1bmNhdGlvbiBzdHJhdGVneSB0byB1c2UgZm9yIHRoZSB0aHJlYWQuIFRoZSBkZWZhdWx0IGlzIGBhdXRvYC4gSWYgc2V0IHRvXG4gICAgICogYGxhc3RfbWVzc2FnZXNgLCB0aGUgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHRvIHRoZSBuIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGluXG4gICAgICogdGhlIHRocmVhZC4gV2hlbiBzZXQgdG8gYGF1dG9gLCBtZXNzYWdlcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSB0aHJlYWQgd2lsbCBiZVxuICAgICAqIGRyb3BwZWQgdG8gZml0IHRoZSBjb250ZXh0IGxlbmd0aCBvZiB0aGUgbW9kZWwsIGBtYXhfcHJvbXB0X3Rva2Vuc2AuXG4gICAgICovXG4gICAgdHlwZTogJ2F1dG8nIHwgJ2xhc3RfbWVzc2FnZXMnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtb3N0IHJlY2VudCBtZXNzYWdlcyBmcm9tIHRoZSB0aHJlYWQgd2hlbiBjb25zdHJ1Y3RpbmcgdGhlIGNvbnRleHRcbiAgICAgKiBmb3IgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBsYXN0X21lc3NhZ2VzPzogbnVtYmVyIHwgbnVsbDtcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc05vblN0cmVhbWluZyA9IFRocmVhZHNBUEkuVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zTm9uU3RyZWFtaW5nO1xuICBleHBvcnQgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNTdHJlYW1pbmcgPSBUaHJlYWRzQVBJLlRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc1N0cmVhbWluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNOb25TdHJlYW1pbmcgZXh0ZW5kcyBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgcmV0dXJucyBhIHN0cmVhbSBvZiBldmVudHMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoZSBSdW4gYXMgc2VydmVyLXNlbnRcbiAgICogZXZlbnRzLCB0ZXJtaW5hdGluZyB3aGVuIHRoZSBSdW4gZW50ZXJzIGEgdGVybWluYWwgc3RhdGUgd2l0aCBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqL1xuICBzdHJlYW0/OiBmYWxzZSB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zU3RyZWFtaW5nIGV4dGVuZHMgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHJldHVybnMgYSBzdHJlYW0gb2YgZXZlbnRzIHRoYXQgaGFwcGVuIGR1cmluZyB0aGUgUnVuIGFzIHNlcnZlci1zZW50XG4gICAqIGV2ZW50cywgdGVybWluYXRpbmcgd2hlbiB0aGUgUnVuIGVudGVycyBhIHRlcm1pbmFsIHN0YXRlIHdpdGggYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKi9cbiAgc3RyZWFtOiB0cnVlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRocmVhZENyZWF0ZUFuZFJ1blBvbGxQYXJhbXMge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIHRvIHVzZSB0b1xuICAgKiBleGVjdXRlIHRoaXMgcnVuLlxuICAgKi9cbiAgYXNzaXN0YW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHN5c3RlbSBtZXNzYWdlIG9mIHRoZSBhc3Npc3RhbnQuIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGVcbiAgICogcnVuLiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogY29tcGxldGlvbiB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC4gU2VlXG4gICAqIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfY29tcGxldGlvbl90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcHJvbXB0IHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgcnVuLlxuICAgKiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgcHJvbXB0IHRva2Vuc1xuICAgKiBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlIG51bWJlciBvZlxuICAgKiBwcm9tcHQgdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X3Byb21wdF90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFtNb2RlbF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tb2RlbHMpIHRvXG4gICAqIGJlIHVzZWQgdG8gZXhlY3V0ZSB0aGlzIHJ1bi4gSWYgYSB2YWx1ZSBpcyBwcm92aWRlZCBoZXJlLCBpdCB3aWxsIG92ZXJyaWRlIHRoZVxuICAgKiBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2lzdGFudC4gSWYgbm90LCB0aGUgbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgKiBhc3Npc3RhbnQgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgbW9kZWw/OlxuICAgIHwgKHN0cmluZyAmIHt9KVxuICAgIHwgJ2dwdC00bydcbiAgICB8ICdncHQtNG8tMjAyNC0wNS0xMydcbiAgICB8ICdncHQtNC10dXJibydcbiAgICB8ICdncHQtNC10dXJiby0yMDI0LTA0LTA5J1xuICAgIHwgJ2dwdC00LTAxMjUtcHJldmlldydcbiAgICB8ICdncHQtNC10dXJiby1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LTExMDYtcHJldmlldydcbiAgICB8ICdncHQtNC12aXNpb24tcHJldmlldydcbiAgICB8ICdncHQtNCdcbiAgICB8ICdncHQtNC0wMzE0J1xuICAgIHwgJ2dwdC00LTA2MTMnXG4gICAgfCAnZ3B0LTQtMzJrJ1xuICAgIHwgJ2dwdC00LTMyay0wMzE0J1xuICAgIHwgJ2dwdC00LTMyay0wNjEzJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8nXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xNmsnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0wNjEzJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTEwNidcbiAgICB8ICdncHQtMy41LXR1cmJvLTAxMjUnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xNmstMDYxMydcbiAgICB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAgICogW0dQVC00b10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzL2dwdC00byksXG4gICAqIFtHUFQtNCBUdXJib10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzL2dwdC00LXR1cmJvLWFuZC1ncHQtNCksXG4gICAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9vYmplY3RcIiB9YCBlbmFibGVzIEpTT04gbW9kZSwgd2hpY2ggZ3VhcmFudGVlcyB0aGVcbiAgICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gICAqXG4gICAqICoqSW1wb3J0YW50OioqIHdoZW4gdXNpbmcgSlNPTiBtb2RlLCB5b3UgKiptdXN0KiogYWxzbyBpbnN0cnVjdCB0aGUgbW9kZWwgdG9cbiAgICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICAgKiBnZW5lcmF0ZSBhbiB1bmVuZGluZyBzdHJlYW0gb2Ygd2hpdGVzcGFjZSB1bnRpbCB0aGUgZ2VuZXJhdGlvbiByZWFjaGVzIHRoZSB0b2tlblxuICAgKiBsaW1pdCwgcmVzdWx0aW5nIGluIGEgbG9uZy1ydW5uaW5nIGFuZCBzZWVtaW5nbHkgXCJzdHVja1wiIHJlcXVlc3QuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICAgKiBpbmRpY2F0ZXMgdGhlIGdlbmVyYXRpb24gZXhjZWVkZWQgYG1heF90b2tlbnNgIG9yIHRoZSBjb252ZXJzYXRpb24gZXhjZWVkZWQgdGhlXG4gICAqIG1heCBjb250ZXh0IGxlbmd0aC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86IEFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIElmIG5vIHRocmVhZCBpcyBwcm92aWRlZCwgYW4gZW1wdHkgdGhyZWFkIHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIHRocmVhZD86IFRocmVhZENyZWF0ZUFuZFJ1blBvbGxQYXJhbXMuVGhyZWFkO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyB3aGljaCAoaWYgYW55KSB0b29sIGlzIGNhbGxlZCBieSB0aGUgbW9kZWwuIGBub25lYCBtZWFucyB0aGUgbW9kZWwgd2lsbFxuICAgKiBub3QgY2FsbCBhbnkgdG9vbHMgYW5kIGluc3RlYWQgZ2VuZXJhdGVzIGEgbWVzc2FnZS4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAqIGFuZCBtZWFucyB0aGUgbW9kZWwgY2FuIHBpY2sgYmV0d2VlbiBnZW5lcmF0aW5nIGEgbWVzc2FnZSBvciBjYWxsaW5nIG9uZSBvciBtb3JlXG4gICAqIHRvb2xzLiBgcmVxdWlyZWRgIG1lYW5zIHRoZSBtb2RlbCBtdXN0IGNhbGwgb25lIG9yIG1vcmUgdG9vbHMgYmVmb3JlIHJlc3BvbmRpbmdcbiAgICogdG8gdGhlIHVzZXIuIFNwZWNpZnlpbmcgYSBwYXJ0aWN1bGFyIHRvb2wgbGlrZSBge1widHlwZVwiOiBcImZpbGVfc2VhcmNoXCJ9YCBvclxuICAgKiBge1widHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIm15X2Z1bmN0aW9uXCJ9fWAgZm9yY2VzIHRoZSBtb2RlbCB0b1xuICAgKiBjYWxsIHRoYXQgdG9vbC5cbiAgICovXG4gIHRvb2xfY2hvaWNlPzogQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBhc3Npc3RhbnQncyB0b29scy4gVGhlIHJlc291cmNlcyBhcmVcbiAgICogc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlc1xuICAgKiBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZVxuICAgKiBJRHMuXG4gICAqL1xuICB0b29sX3Jlc291cmNlcz86IFRocmVhZENyZWF0ZUFuZFJ1blBvbGxQYXJhbXMuVG9vbFJlc291cmNlcyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSB0b29scyB0aGUgYXNzaXN0YW50IGNhbiB1c2UgZm9yIHRoaXMgcnVuLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICB0b29scz86IEFycmF5PFxuICAgIEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEFzc2lzdGFudHNBUEkuRmlsZVNlYXJjaFRvb2wgfCBBc3Npc3RhbnRzQVBJLkZ1bmN0aW9uVG9vbFxuICA+IHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgdGVtcGVyYXR1cmUgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdG9wX3A/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgdHJ1bmNhdGlvbl9zdHJhdGVneT86IFRocmVhZENyZWF0ZUFuZFJ1blBvbGxQYXJhbXMuVHJ1bmNhdGlvblN0cmF0ZWd5IHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBUaHJlYWRDcmVhdGVBbmRSdW5Qb2xsUGFyYW1zIHtcbiAgLyoqXG4gICAqIElmIG5vIHRocmVhZCBpcyBwcm92aWRlZCwgYW4gZW1wdHkgdGhyZWFkIHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkIHtcbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgW21lc3NhZ2VzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzKSB0b1xuICAgICAqIHN0YXJ0IHRoZSB0aHJlYWQgd2l0aC5cbiAgICAgKi9cbiAgICBtZXNzYWdlcz86IEFycmF5PFRocmVhZC5NZXNzYWdlPjtcblxuICAgIC8qKlxuICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgKi9cbiAgICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBhc3Npc3RhbnQncyB0b29scyBpbiB0aGlzXG4gICAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgICAqIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBJRHMuXG4gICAgICovXG4gICAgdG9vbF9yZXNvdXJjZXM/OiBUaHJlYWQuVG9vbFJlc291cmNlcyB8IG51bGw7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRocmVhZCB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRleHQgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PE1lc3NhZ2VzQVBJLk1lc3NhZ2VDb250ZW50UGFydFBhcmFtPjtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcm9sZSBvZiB0aGUgZW50aXR5IHRoYXQgaXMgY3JlYXRpbmcgdGhlIG1lc3NhZ2UuIEFsbG93ZWQgdmFsdWVzIGluY2x1ZGU6XG4gICAgICAgKlxuICAgICAgICogLSBgdXNlcmA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBzZW50IGJ5IGFuIGFjdHVhbCB1c2VyIGFuZCBzaG91bGQgYmUgdXNlZCBpblxuICAgICAgICogICBtb3N0IGNhc2VzIHRvIHJlcHJlc2VudCB1c2VyLWdlbmVyYXRlZCBtZXNzYWdlcy5cbiAgICAgICAqIC0gYGFzc2lzdGFudGA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBnZW5lcmF0ZWQgYnkgdGhlIGFzc2lzdGFudC4gVXNlIHRoaXNcbiAgICAgICAqICAgdmFsdWUgdG8gaW5zZXJ0IG1lc3NhZ2VzIGZyb20gdGhlIGFzc2lzdGFudCBpbnRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICAgKi9cbiAgICAgIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byB0aGUgbWVzc2FnZSwgYW5kIHRoZSB0b29scyB0aGV5IHNob3VsZCBiZSBhZGRlZCB0by5cbiAgICAgICAqL1xuICAgICAgYXR0YWNobWVudHM/OiBBcnJheTxNZXNzYWdlLkF0dGFjaG1lbnQ+IHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAgICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICAgKi9cbiAgICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBNZXNzYWdlIHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gYXR0YWNoIHRvIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZV9pZD86IHN0cmluZztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvb2xzIHRvIGFkZCB0aGlzIGZpbGUgdG8uXG4gICAgICAgICAqL1xuICAgICAgICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEFzc2lzdGFudHNBUEkuRmlsZVNlYXJjaFRvb2w+O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYXNzaXN0YW50J3MgdG9vbHMgaW4gdGhpc1xuICAgICAqIHRocmVhZC4gVGhlIHJlc291cmNlcyBhcmUgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZVxuICAgICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICAgKiB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgSURzLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICAgIGZpbGVfc2VhcmNoPzogVG9vbFJlc291cmNlcy5GaWxlU2VhcmNoO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgICAqIGF2YWlsYWJsZSB0byB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMjAgZmlsZXNcbiAgICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlXG4gICAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgdGhyZWFkLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvXG4gICAgICAgICAqIHRoZSB0aHJlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB2ZWN0b3Jfc3RvcmVfaWRzPzogQXJyYXk8c3RyaW5nPjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBoZWxwZXIgdG8gY3JlYXRlIGFcbiAgICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAgICogd2l0aCBmaWxlX2lkcyBhbmQgYXR0YWNoIGl0IHRvIHRoaXMgdGhyZWFkLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yXG4gICAgICAgICAqIHN0b3JlIGF0dGFjaGVkIHRvIHRoZSB0aHJlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB2ZWN0b3Jfc3RvcmVzPzogQXJyYXk8RmlsZVNlYXJjaC5WZWN0b3JTdG9yZT47XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydCBuYW1lc3BhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmUge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIHRvXG4gICAgICAgICAgICogYWRkIHRvIHRoZSB2ZWN0b3Igc3RvcmUuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMTAwMDAgZmlsZXMgaW4gYSB2ZWN0b3JcbiAgICAgICAgICAgKiBzdG9yZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdmVjdG9yIHN0b3JlLiBUaGlzIGNhbiBiZVxuICAgICAgICAgICAqIHVzZWZ1bCBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2ZWN0b3Igc3RvcmUgaW4gYSBzdHJ1Y3R1cmVkXG4gICAgICAgICAgICogZm9ybWF0LiBLZXlzIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtXG4gICAgICAgICAgICogb2YgNTEyIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBtZXRhZGF0YT86IHVua25vd247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIGFzc2lzdGFudCdzIHRvb2xzLiBUaGUgcmVzb3VyY2VzIGFyZVxuICAgKiBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzXG4gICAqIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlXG4gICAqIElEcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgY29kZV9pbnRlcnByZXRlcj86IFRvb2xSZXNvdXJjZXMuQ29kZUludGVycHJldGVyO1xuXG4gICAgZmlsZV9zZWFyY2g/OiBUb29sUmVzb3VyY2VzLkZpbGVTZWFyY2g7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgbWFkZVxuICAgICAgICogYXZhaWxhYmxlIHRvIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlc1xuICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIElEIG9mIHRoZVxuICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgYXNzaXN0YW50LiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvXG4gICAgICAgKiB0aGUgYXNzaXN0YW50LlxuICAgICAgICovXG4gICAgICB2ZWN0b3Jfc3RvcmVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVHJ1bmNhdGlvblN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJ1bmNhdGlvbiBzdHJhdGVneSB0byB1c2UgZm9yIHRoZSB0aHJlYWQuIFRoZSBkZWZhdWx0IGlzIGBhdXRvYC4gSWYgc2V0IHRvXG4gICAgICogYGxhc3RfbWVzc2FnZXNgLCB0aGUgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHRvIHRoZSBuIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGluXG4gICAgICogdGhlIHRocmVhZC4gV2hlbiBzZXQgdG8gYGF1dG9gLCBtZXNzYWdlcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSB0aHJlYWQgd2lsbCBiZVxuICAgICAqIGRyb3BwZWQgdG8gZml0IHRoZSBjb250ZXh0IGxlbmd0aCBvZiB0aGUgbW9kZWwsIGBtYXhfcHJvbXB0X3Rva2Vuc2AuXG4gICAgICovXG4gICAgdHlwZTogJ2F1dG8nIHwgJ2xhc3RfbWVzc2FnZXMnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtb3N0IHJlY2VudCBtZXNzYWdlcyBmcm9tIHRoZSB0aHJlYWQgd2hlbiBjb25zdHJ1Y3RpbmcgdGhlIGNvbnRleHRcbiAgICAgKiBmb3IgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBsYXN0X21lc3NhZ2VzPzogbnVtYmVyIHwgbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRocmVhZENyZWF0ZUFuZFJ1blN0cmVhbVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdG8gdXNlIHRvXG4gICAqIGV4ZWN1dGUgdGhpcyBydW4uXG4gICAqL1xuICBhc3Npc3RhbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgc3lzdGVtIG1lc3NhZ2Ugb2YgdGhlIGFzc2lzdGFudC4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zIHRoYXQgbWF5IGJlIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZVxuICAgKiBydW4uIFRoZSBydW4gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdXNlIG9ubHkgdGhlIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2Vuc1xuICAgKiBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlIG51bWJlciBvZlxuICAgKiBjb21wbGV0aW9uIHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLiBTZWVcbiAgICogYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9jb21wbGV0aW9uX3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zIHRoYXQgbWF5IGJlIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBydW4uXG4gICAqIFRoZSBydW4gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdXNlIG9ubHkgdGhlIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zXG4gICAqIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGUgbnVtYmVyIG9mXG4gICAqIHByb21wdCB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC4gU2VlXG4gICAqIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfcHJvbXB0X3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgW01vZGVsXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscykgdG9cbiAgICogYmUgdXNlZCB0byBleGVjdXRlIHRoaXMgcnVuLiBJZiBhIHZhbHVlIGlzIHByb3ZpZGVkIGhlcmUsIGl0IHdpbGwgb3ZlcnJpZGUgdGhlXG4gICAqIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzaXN0YW50LiBJZiBub3QsIHRoZSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAqIGFzc2lzdGFudCB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICBtb2RlbD86XG4gICAgfCAoc3RyaW5nICYge30pXG4gICAgfCAnZ3B0LTRvJ1xuICAgIHwgJ2dwdC00by0yMDI0LTA1LTEzJ1xuICAgIHwgJ2dwdC00LXR1cmJvJ1xuICAgIHwgJ2dwdC00LXR1cmJvLTIwMjQtMDQtMDknXG4gICAgfCAnZ3B0LTQtMDEyNS1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LXR1cmJvLXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtMTEwNi1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LXZpc2lvbi1wcmV2aWV3J1xuICAgIHwgJ2dwdC00J1xuICAgIHwgJ2dwdC00LTAzMTQnXG4gICAgfCAnZ3B0LTQtMDYxMydcbiAgICB8ICdncHQtNC0zMmsnXG4gICAgfCAnZ3B0LTQtMzJrLTAzMTQnXG4gICAgfCAnZ3B0LTQtMzJrLTA2MTMnXG4gICAgfCAnZ3B0LTMuNS10dXJibydcbiAgICB8ICdncHQtMy41LXR1cmJvLTE2aydcbiAgICB8ICdncHQtMy41LXR1cmJvLTA2MTMnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xMTA2J1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMDEyNSdcbiAgICB8ICdncHQtMy41LXR1cmJvLTE2ay0wNjEzJ1xuICAgIHwgbnVsbDtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBmb3JtYXQgdGhhdCB0aGUgbW9kZWwgbXVzdCBvdXRwdXQuIENvbXBhdGlibGUgd2l0aFxuICAgKiBbR1BULTRvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMvZ3B0LTRvKSxcbiAgICogW0dQVC00IFR1cmJvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMvZ3B0LTQtdHVyYm8tYW5kLWdwdC00KSxcbiAgICogYW5kIGFsbCBHUFQtMy41IFR1cmJvIG1vZGVscyBzaW5jZSBgZ3B0LTMuNS10dXJiby0xMTA2YC5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBndWFyYW50ZWVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogSWYgbm8gdGhyZWFkIGlzIHByb3ZpZGVkLCBhbiBlbXB0eSB0aHJlYWQgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgdGhyZWFkPzogVGhyZWFkQ3JlYXRlQW5kUnVuU3RyZWFtUGFyYW1zLlRocmVhZDtcblxuICAvKipcbiAgICogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgdG9vbCBpcyBjYWxsZWQgYnkgdGhlIG1vZGVsLiBgbm9uZWAgbWVhbnMgdGhlIG1vZGVsIHdpbGxcbiAgICogbm90IGNhbGwgYW55IHRvb2xzIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBpcyB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgKiBhbmQgbWVhbnMgdGhlIG1vZGVsIGNhbiBwaWNrIGJldHdlZW4gZ2VuZXJhdGluZyBhIG1lc3NhZ2Ugb3IgY2FsbGluZyBvbmUgb3IgbW9yZVxuICAgKiB0b29scy4gYHJlcXVpcmVkYCBtZWFucyB0aGUgbW9kZWwgbXVzdCBjYWxsIG9uZSBvciBtb3JlIHRvb2xzIGJlZm9yZSByZXNwb25kaW5nXG4gICAqIHRvIHRoZSB1c2VyLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciB0b29sIGxpa2UgYHtcInR5cGVcIjogXCJmaWxlX3NlYXJjaFwifWAgb3JcbiAgICogYHtcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifX1gIGZvcmNlcyB0aGUgbW9kZWwgdG9cbiAgICogY2FsbCB0aGF0IHRvb2wuXG4gICAqL1xuICB0b29sX2Nob2ljZT86IEFzc2lzdGFudFRvb2xDaG9pY2VPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgdXNlZCBieSB0aGUgYXNzaXN0YW50J3MgdG9vbHMuIFRoZSByZXNvdXJjZXMgYXJlXG4gICAqIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXNcbiAgICogYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVcbiAgICogSURzLlxuICAgKi9cbiAgdG9vbF9yZXNvdXJjZXM/OiBUaHJlYWRDcmVhdGVBbmRSdW5TdHJlYW1QYXJhbXMuVG9vbFJlc291cmNlcyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSB0b29scyB0aGUgYXNzaXN0YW50IGNhbiB1c2UgZm9yIHRoaXMgcnVuLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICB0b29scz86IEFycmF5PFxuICAgIEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEFzc2lzdGFudHNBUEkuRmlsZVNlYXJjaFRvb2wgfCBBc3Npc3RhbnRzQVBJLkZ1bmN0aW9uVG9vbFxuICA+IHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgdGVtcGVyYXR1cmUgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdG9wX3A/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgdHJ1bmNhdGlvbl9zdHJhdGVneT86IFRocmVhZENyZWF0ZUFuZFJ1blN0cmVhbVBhcmFtcy5UcnVuY2F0aW9uU3RyYXRlZ3kgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFRocmVhZENyZWF0ZUFuZFJ1blN0cmVhbVBhcmFtcyB7XG4gIC8qKlxuICAgKiBJZiBubyB0aHJlYWQgaXMgcHJvdmlkZWQsIGFuIGVtcHR5IHRocmVhZCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZCB7XG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIFttZXNzYWdlc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcykgdG9cbiAgICAgKiBzdGFydCB0aGUgdGhyZWFkIHdpdGguXG4gICAgICovXG4gICAgbWVzc2FnZXM/OiBBcnJheTxUaHJlYWQuTWVzc2FnZT47XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICovXG4gICAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYXNzaXN0YW50J3MgdG9vbHMgaW4gdGhpc1xuICAgICAqIHRocmVhZC4gVGhlIHJlc291cmNlcyBhcmUgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZVxuICAgICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICAgKiB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgSURzLlxuICAgICAqL1xuICAgIHRvb2xfcmVzb3VyY2VzPzogVGhyZWFkLlRvb2xSZXNvdXJjZXMgfCBudWxsO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBUaHJlYWQge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxNZXNzYWdlc0FQSS5NZXNzYWdlQ29udGVudFBhcnRQYXJhbT47XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHJvbGUgb2YgdGhlIGVudGl0eSB0aGF0IGlzIGNyZWF0aW5nIHRoZSBtZXNzYWdlLiBBbGxvd2VkIHZhbHVlcyBpbmNsdWRlOlxuICAgICAgICpcbiAgICAgICAqIC0gYHVzZXJgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgc2VudCBieSBhbiBhY3R1YWwgdXNlciBhbmQgc2hvdWxkIGJlIHVzZWQgaW5cbiAgICAgICAqICAgbW9zdCBjYXNlcyB0byByZXByZXNlbnQgdXNlci1nZW5lcmF0ZWQgbWVzc2FnZXMuXG4gICAgICAgKiAtIGBhc3Npc3RhbnRgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBhc3Npc3RhbnQuIFVzZSB0aGlzXG4gICAgICAgKiAgIHZhbHVlIHRvIGluc2VydCBtZXNzYWdlcyBmcm9tIHRoZSBhc3Npc3RhbnQgaW50byB0aGUgY29udmVyc2F0aW9uLlxuICAgICAgICovXG4gICAgICByb2xlOiAndXNlcicgfCAnYXNzaXN0YW50JztcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgZmlsZXMgYXR0YWNoZWQgdG8gdGhlIG1lc3NhZ2UsIGFuZCB0aGUgdG9vbHMgdGhleSBzaG91bGQgYmUgYWRkZWQgdG8uXG4gICAgICAgKi9cbiAgICAgIGF0dGFjaG1lbnRzPzogQXJyYXk8TWVzc2FnZS5BdHRhY2htZW50PiB8IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgICAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICAgICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgICAgICogY2hhcmFjdGVycyBsb25nLlxuICAgICAgICovXG4gICAgICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgTWVzc2FnZSB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEF0dGFjaG1lbnQge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSBmaWxlIHRvIGF0dGFjaCB0byB0aGUgbWVzc2FnZS5cbiAgICAgICAgICovXG4gICAgICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b29scyB0byBhZGQgdGhpcyBmaWxlIHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkNvZGVJbnRlcnByZXRlclRvb2wgfCBBc3Npc3RhbnRzQVBJLkZpbGVTZWFyY2hUb29sPjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICAgKiB0aHJlYWQuIFRoZSByZXNvdXJjZXMgYXJlIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGVcbiAgICAgKiBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgXG4gICAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgICAgY29kZV9pbnRlcnByZXRlcj86IFRvb2xSZXNvdXJjZXMuQ29kZUludGVycHJldGVyO1xuXG4gICAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgbWFkZVxuICAgICAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzXG4gICAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9vbC5cbiAgICAgICAgICovXG4gICAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICAgIH1cblxuICAgICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZVxuICAgICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICAgKiBhdHRhY2hlZCB0byB0aGlzIHRocmVhZC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvciBzdG9yZSBhdHRhY2hlZCB0b1xuICAgICAgICAgKiB0aGUgdGhyZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgdmVjdG9yX3N0b3JlX2lkcz86IEFycmF5PHN0cmluZz47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgaGVscGVyIHRvIGNyZWF0ZSBhXG4gICAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgICAqIHdpdGggZmlsZV9pZHMgYW5kIGF0dGFjaCBpdCB0byB0aGlzIHRocmVhZC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvclxuICAgICAgICAgKiBzdG9yZSBhdHRhY2hlZCB0byB0aGUgdGhyZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgdmVjdG9yX3N0b3Jlcz86IEFycmF5PEZpbGVTZWFyY2guVmVjdG9yU3RvcmU+O1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgbmFtZXNwYWNlIEZpbGVTZWFyY2gge1xuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyB0b1xuICAgICAgICAgICAqIGFkZCB0byB0aGUgdmVjdG9yIHN0b3JlLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEwMDAwIGZpbGVzIGluIGEgdmVjdG9yXG4gICAgICAgICAgICogc3RvcmUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIHZlY3RvciBzdG9yZS4gVGhpcyBjYW4gYmVcbiAgICAgICAgICAgKiB1c2VmdWwgZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdmVjdG9yIHN0b3JlIGluIGEgc3RydWN0dXJlZFxuICAgICAgICAgICAqIGZvcm1hdC4gS2V5cyBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bVxuICAgICAgICAgICAqIG9mIDUxMiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICAgICAgICovXG4gICAgICAgICAgbWV0YWRhdGE/OiB1bmtub3duO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBhc3Npc3RhbnQncyB0b29scy4gVGhlIHJlc291cmNlcyBhcmVcbiAgICogc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlc1xuICAgKiBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZVxuICAgKiBJRHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGNvZGVfaW50ZXJwcmV0ZXI/OiBUb29sUmVzb3VyY2VzLkNvZGVJbnRlcnByZXRlcjtcblxuICAgIGZpbGVfc2VhcmNoPzogVG9vbFJlc291cmNlcy5GaWxlU2VhcmNoO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIG1hZGVcbiAgICAgICAqIGF2YWlsYWJsZSB0byB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMjAgZmlsZXNcbiAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9vbC5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBJRCBvZiB0aGVcbiAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgKiBhdHRhY2hlZCB0byB0aGlzIGFzc2lzdGFudC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvciBzdG9yZSBhdHRhY2hlZCB0b1xuICAgICAgICogdGhlIGFzc2lzdGFudC5cbiAgICAgICAqL1xuICAgICAgdmVjdG9yX3N0b3JlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRydW5jYXRpb25TdHJhdGVneSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRydW5jYXRpb24gc3RyYXRlZ3kgdG8gdXNlIGZvciB0aGUgdGhyZWFkLiBUaGUgZGVmYXVsdCBpcyBgYXV0b2AuIElmIHNldCB0b1xuICAgICAqIGBsYXN0X21lc3NhZ2VzYCwgdGhlIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCB0byB0aGUgbiBtb3N0IHJlY2VudCBtZXNzYWdlcyBpblxuICAgICAqIHRoZSB0aHJlYWQuIFdoZW4gc2V0IHRvIGBhdXRvYCwgbWVzc2FnZXMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdGhyZWFkIHdpbGwgYmVcbiAgICAgKiBkcm9wcGVkIHRvIGZpdCB0aGUgY29udGV4dCBsZW5ndGggb2YgdGhlIG1vZGVsLCBgbWF4X3Byb21wdF90b2tlbnNgLlxuICAgICAqL1xuICAgIHR5cGU6ICdhdXRvJyB8ICdsYXN0X21lc3NhZ2VzJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbW9zdCByZWNlbnQgbWVzc2FnZXMgZnJvbSB0aGUgdGhyZWFkIHdoZW4gY29uc3RydWN0aW5nIHRoZSBjb250ZXh0XG4gICAgICogZm9yIHRoZSBydW4uXG4gICAgICovXG4gICAgbGFzdF9tZXNzYWdlcz86IG51bWJlciB8IG51bGw7XG4gIH1cbn1cblxuVGhyZWFkcy5SdW5zID0gUnVucztcblRocmVhZHMuUnVuc1BhZ2UgPSBSdW5zUGFnZTtcblRocmVhZHMuTWVzc2FnZXMgPSBNZXNzYWdlcztcblRocmVhZHMuTWVzc2FnZXNQYWdlID0gTWVzc2FnZXNQYWdlO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVGhyZWFkcyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBBc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiBhcyBBc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbixcbiAgICB0eXBlIEFzc2lzdGFudFRvb2xDaG9pY2UgYXMgQXNzaXN0YW50VG9vbENob2ljZSxcbiAgICB0eXBlIEFzc2lzdGFudFRvb2xDaG9pY2VGdW5jdGlvbiBhcyBBc3Npc3RhbnRUb29sQ2hvaWNlRnVuY3Rpb24sXG4gICAgdHlwZSBBc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uIGFzIEFzc2lzdGFudFRvb2xDaG9pY2VPcHRpb24sXG4gICAgdHlwZSBUaHJlYWQgYXMgVGhyZWFkLFxuICAgIHR5cGUgVGhyZWFkRGVsZXRlZCBhcyBUaHJlYWREZWxldGVkLFxuICAgIHR5cGUgVGhyZWFkQ3JlYXRlUGFyYW1zIGFzIFRocmVhZENyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIFRocmVhZFVwZGF0ZVBhcmFtcyBhcyBUaHJlYWRVcGRhdGVQYXJhbXMsXG4gICAgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXMgYXMgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zLFxuICAgIHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zTm9uU3RyZWFtaW5nIGFzIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc1N0cmVhbWluZyBhcyBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNTdHJlYW1pbmcsXG4gICAgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5Qb2xsUGFyYW1zLFxuICAgIHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuU3RyZWFtUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgUnVucyBhcyBSdW5zLFxuICAgIHR5cGUgUmVxdWlyZWRBY3Rpb25GdW5jdGlvblRvb2xDYWxsIGFzIFJlcXVpcmVkQWN0aW9uRnVuY3Rpb25Ub29sQ2FsbCxcbiAgICB0eXBlIFJ1biBhcyBSdW4sXG4gICAgdHlwZSBSdW5TdGF0dXMgYXMgUnVuU3RhdHVzLFxuICAgIFJ1bnNQYWdlIGFzIFJ1bnNQYWdlLFxuICAgIHR5cGUgUnVuQ3JlYXRlUGFyYW1zIGFzIFJ1bkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIFJ1bkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBhcyBSdW5DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmcgYXMgUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICAgIHR5cGUgUnVuVXBkYXRlUGFyYW1zIGFzIFJ1blVwZGF0ZVBhcmFtcyxcbiAgICB0eXBlIFJ1bkxpc3RQYXJhbXMgYXMgUnVuTGlzdFBhcmFtcyxcbiAgICB0eXBlIFJ1bkNyZWF0ZUFuZFBvbGxQYXJhbXMsXG4gICAgdHlwZSBSdW5DcmVhdGVBbmRTdHJlYW1QYXJhbXMsXG4gICAgdHlwZSBSdW5TdHJlYW1QYXJhbXMsXG4gICAgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtcyBhcyBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtcyxcbiAgICB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nIGFzIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmcgYXMgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmcsXG4gICAgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c0FuZFBvbGxQYXJhbXMsXG4gICAgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c1N0cmVhbVBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIE1lc3NhZ2VzIGFzIE1lc3NhZ2VzLFxuICAgIHR5cGUgQW5ub3RhdGlvbiBhcyBBbm5vdGF0aW9uLFxuICAgIHR5cGUgQW5ub3RhdGlvbkRlbHRhIGFzIEFubm90YXRpb25EZWx0YSxcbiAgICB0eXBlIEZpbGVDaXRhdGlvbkFubm90YXRpb24gYXMgRmlsZUNpdGF0aW9uQW5ub3RhdGlvbixcbiAgICB0eXBlIEZpbGVDaXRhdGlvbkRlbHRhQW5ub3RhdGlvbiBhcyBGaWxlQ2l0YXRpb25EZWx0YUFubm90YXRpb24sXG4gICAgdHlwZSBGaWxlUGF0aEFubm90YXRpb24gYXMgRmlsZVBhdGhBbm5vdGF0aW9uLFxuICAgIHR5cGUgRmlsZVBhdGhEZWx0YUFubm90YXRpb24gYXMgRmlsZVBhdGhEZWx0YUFubm90YXRpb24sXG4gICAgdHlwZSBJbWFnZUZpbGUgYXMgSW1hZ2VGaWxlLFxuICAgIHR5cGUgSW1hZ2VGaWxlQ29udGVudEJsb2NrIGFzIEltYWdlRmlsZUNvbnRlbnRCbG9jayxcbiAgICB0eXBlIEltYWdlRmlsZURlbHRhIGFzIEltYWdlRmlsZURlbHRhLFxuICAgIHR5cGUgSW1hZ2VGaWxlRGVsdGFCbG9jayBhcyBJbWFnZUZpbGVEZWx0YUJsb2NrLFxuICAgIHR5cGUgSW1hZ2VVUkwgYXMgSW1hZ2VVUkwsXG4gICAgdHlwZSBJbWFnZVVSTENvbnRlbnRCbG9jayBhcyBJbWFnZVVSTENvbnRlbnRCbG9jayxcbiAgICB0eXBlIEltYWdlVVJMRGVsdGEgYXMgSW1hZ2VVUkxEZWx0YSxcbiAgICB0eXBlIEltYWdlVVJMRGVsdGFCbG9jayBhcyBJbWFnZVVSTERlbHRhQmxvY2ssXG4gICAgdHlwZSBNZXNzYWdlc0FQSU1lc3NhZ2UgYXMgTWVzc2FnZSxcbiAgICB0eXBlIE1lc3NhZ2VDb250ZW50IGFzIE1lc3NhZ2VDb250ZW50LFxuICAgIHR5cGUgTWVzc2FnZUNvbnRlbnREZWx0YSBhcyBNZXNzYWdlQ29udGVudERlbHRhLFxuICAgIHR5cGUgTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0gYXMgTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0sXG4gICAgdHlwZSBNZXNzYWdlRGVsZXRlZCBhcyBNZXNzYWdlRGVsZXRlZCxcbiAgICB0eXBlIE1lc3NhZ2VEZWx0YSBhcyBNZXNzYWdlRGVsdGEsXG4gICAgdHlwZSBNZXNzYWdlRGVsdGFFdmVudCBhcyBNZXNzYWdlRGVsdGFFdmVudCxcbiAgICB0eXBlIFJlZnVzYWxDb250ZW50QmxvY2sgYXMgUmVmdXNhbENvbnRlbnRCbG9jayxcbiAgICB0eXBlIFJlZnVzYWxEZWx0YUJsb2NrIGFzIFJlZnVzYWxEZWx0YUJsb2NrLFxuICAgIHR5cGUgVGV4dCBhcyBUZXh0LFxuICAgIHR5cGUgVGV4dENvbnRlbnRCbG9jayBhcyBUZXh0Q29udGVudEJsb2NrLFxuICAgIHR5cGUgVGV4dENvbnRlbnRCbG9ja1BhcmFtIGFzIFRleHRDb250ZW50QmxvY2tQYXJhbSxcbiAgICB0eXBlIFRleHREZWx0YSBhcyBUZXh0RGVsdGEsXG4gICAgdHlwZSBUZXh0RGVsdGFCbG9jayBhcyBUZXh0RGVsdGFCbG9jayxcbiAgICBNZXNzYWdlc1BhZ2UgYXMgTWVzc2FnZXNQYWdlLFxuICAgIHR5cGUgTWVzc2FnZUNyZWF0ZVBhcmFtcyBhcyBNZXNzYWdlQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgTWVzc2FnZVVwZGF0ZVBhcmFtcyBhcyBNZXNzYWdlVXBkYXRlUGFyYW1zLFxuICAgIHR5cGUgTWVzc2FnZUxpc3RQYXJhbXMgYXMgTWVzc2FnZUxpc3RQYXJhbXMsXG4gIH07XG59XG4iLCAiLyoqXG4gKiBMaWtlIGBQcm9taXNlLmFsbFNldHRsZWQoKWAgYnV0IHRocm93cyBhbiBlcnJvciBpZiBhbnkgcHJvbWlzZXMgYXJlIHJlamVjdGVkLlxuICovXG5leHBvcnQgY29uc3QgYWxsU2V0dGxlZFdpdGhUaHJvdyA9IGFzeW5jIDxSPihwcm9taXNlczogUHJvbWlzZTxSPltdKTogUHJvbWlzZTxSW10+ID0+IHtcbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChwcm9taXNlcyk7XG4gIGNvbnN0IHJlamVjdGVkID0gcmVzdWx0cy5maWx0ZXIoKHJlc3VsdCk6IHJlc3VsdCBpcyBQcm9taXNlUmVqZWN0ZWRSZXN1bHQgPT4gcmVzdWx0LnN0YXR1cyA9PT0gJ3JlamVjdGVkJyk7XG4gIGlmIChyZWplY3RlZC5sZW5ndGgpIHtcbiAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZWplY3RlZCkge1xuICAgICAgY29uc29sZS5lcnJvcihyZXN1bHQucmVhc29uKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVqZWN0ZWQubGVuZ3RofSBwcm9taXNlKHMpIGZhaWxlZCAtIHNlZSB0aGUgYWJvdmUgZXJyb3JzYCk7XG4gIH1cblxuICAvLyBOb3RlOiBUUyB3YXMgY29tcGxhaW5pbmcgYWJvdXQgdXNpbmcgYC5maWx0ZXIoKS5tYXAoKWAgaGVyZSBmb3Igc29tZSByZWFzb25cbiAgY29uc3QgdmFsdWVzOiBSW10gPSBbXTtcbiAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZnVsZmlsbGVkJykge1xuICAgICAgdmFsdWVzLnB1c2gocmVzdWx0LnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn07XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBzbGVlcCwgVXBsb2FkYWJsZSwgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIFZlY3RvclN0b3Jlc0FQSSBmcm9tICcuL3ZlY3Rvci1zdG9yZXMnO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSwgdHlwZSBDdXJzb3JQYWdlUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vcGFnaW5hdGlvbic7XG5cbmV4cG9ydCBjbGFzcyBGaWxlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIHZlY3RvciBzdG9yZSBmaWxlIGJ5IGF0dGFjaGluZyBhXG4gICAqIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSB0byBhXG4gICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpLlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBib2R5OiBGaWxlQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VmVjdG9yU3RvcmVGaWxlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9L2ZpbGVzYCwge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIHZlY3RvciBzdG9yZSBmaWxlLlxuICAgKi9cbiAgcmV0cmlldmUoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGZpbGVJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VmVjdG9yU3RvcmVGaWxlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH0vZmlsZXMvJHtmaWxlSWR9YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIGZpbGVzLlxuICAgKi9cbiAgbGlzdChcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgcXVlcnk/OiBGaWxlTGlzdFBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVzUGFnZSwgVmVjdG9yU3RvcmVGaWxlPjtcbiAgbGlzdChcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8VmVjdG9yU3RvcmVGaWxlc1BhZ2UsIFZlY3RvclN0b3JlRmlsZT47XG4gIGxpc3QoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIHF1ZXJ5OiBGaWxlTGlzdFBhcmFtcyB8IENvcmUuUmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVzUGFnZSwgVmVjdG9yU3RvcmVGaWxlPiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0KHZlY3RvclN0b3JlSWQsIHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlc2AsIFZlY3RvclN0b3JlRmlsZXNQYWdlLCB7XG4gICAgICBxdWVyeSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHZlY3RvciBzdG9yZSBmaWxlLiBUaGlzIHdpbGwgcmVtb3ZlIHRoZSBmaWxlIGZyb20gdGhlIHZlY3RvciBzdG9yZSBidXRcbiAgICogdGhlIGZpbGUgaXRzZWxmIHdpbGwgbm90IGJlIGRlbGV0ZWQuIFRvIGRlbGV0ZSB0aGUgZmlsZSwgdXNlIHRoZVxuICAgKiBbZGVsZXRlIGZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMvZGVsZXRlKVxuICAgKiBlbmRwb2ludC5cbiAgICovXG4gIGRlbChcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgZmlsZUlkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVEZWxldGVkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5kZWxldGUoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH0vZmlsZXMvJHtmaWxlSWR9YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIGEgZmlsZSB0byB0aGUgZ2l2ZW4gdmVjdG9yIHN0b3JlIGFuZCB3YWl0IGZvciBpdCB0byBiZSBwcm9jZXNzZWQuXG4gICAqL1xuICBhc3luYyBjcmVhdGVBbmRQb2xsKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBib2R5OiBGaWxlQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zICYgeyBwb2xsSW50ZXJ2YWxNcz86IG51bWJlciB9LFxuICApOiBQcm9taXNlPFZlY3RvclN0b3JlRmlsZT4ge1xuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLmNyZWF0ZSh2ZWN0b3JTdG9yZUlkLCBib2R5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5wb2xsKHZlY3RvclN0b3JlSWQsIGZpbGUuaWQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhaXQgZm9yIHRoZSB2ZWN0b3Igc3RvcmUgZmlsZSB0byBmaW5pc2ggcHJvY2Vzc2luZy5cbiAgICpcbiAgICogTm90ZTogdGhpcyB3aWxsIHJldHVybiBldmVuIGlmIHRoZSBmaWxlIGZhaWxlZCB0byBwcm9jZXNzLCB5b3UgbmVlZCB0byBjaGVja1xuICAgKiBmaWxlLmxhc3RfZXJyb3IgYW5kIGZpbGUuc3RhdHVzIHRvIGhhbmRsZSB0aGVzZSBjYXNlc1xuICAgKi9cbiAgYXN5bmMgcG9sbChcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgZmlsZUlkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMgJiB7IHBvbGxJbnRlcnZhbE1zPzogbnVtYmVyIH0sXG4gICk6IFByb21pc2U8VmVjdG9yU3RvcmVGaWxlPiB7XG4gICAgY29uc3QgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLVBvbGwtSGVscGVyJzogJ3RydWUnIH07XG4gICAgaWYgKG9wdGlvbnM/LnBvbGxJbnRlcnZhbE1zKSB7XG4gICAgICBoZWFkZXJzWydYLVN0YWlubGVzcy1DdXN0b20tUG9sbC1JbnRlcnZhbCddID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNcy50b1N0cmluZygpO1xuICAgIH1cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgZmlsZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXRyaWV2ZSh2ZWN0b3JTdG9yZUlkLCBmaWxlSWQsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgIH0pLndpdGhSZXNwb25zZSgpO1xuXG4gICAgICBjb25zdCBmaWxlID0gZmlsZVJlc3BvbnNlLmRhdGE7XG5cbiAgICAgIHN3aXRjaCAoZmlsZS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSAnaW5fcHJvZ3Jlc3MnOlxuICAgICAgICAgIGxldCBzbGVlcEludGVydmFsID0gNTAwMDtcblxuICAgICAgICAgIGlmIChvcHRpb25zPy5wb2xsSW50ZXJ2YWxNcykge1xuICAgICAgICAgICAgc2xlZXBJbnRlcnZhbCA9IG9wdGlvbnMucG9sbEludGVydmFsTXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlckludGVydmFsID0gZmlsZVJlc3BvbnNlLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdvcGVuYWktcG9sbC1hZnRlci1tcycpO1xuICAgICAgICAgICAgaWYgKGhlYWRlckludGVydmFsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGhlYWRlckludGVydmFsTXMgPSBwYXJzZUludChoZWFkZXJJbnRlcnZhbCk7XG4gICAgICAgICAgICAgIGlmICghaXNOYU4oaGVhZGVySW50ZXJ2YWxNcykpIHtcbiAgICAgICAgICAgICAgICBzbGVlcEludGVydmFsID0gaGVhZGVySW50ZXJ2YWxNcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBzbGVlcChzbGVlcEludGVydmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkIGEgZmlsZSB0byB0aGUgYGZpbGVzYCBBUEkgYW5kIHRoZW4gYXR0YWNoIGl0IHRvIHRoZSBnaXZlbiB2ZWN0b3Igc3RvcmUuXG4gICAqXG4gICAqIE5vdGUgdGhlIGZpbGUgd2lsbCBiZSBhc3luY2hyb25vdXNseSBwcm9jZXNzZWQgKHlvdSBjYW4gdXNlIHRoZSBhbHRlcm5hdGl2ZVxuICAgKiBwb2xsaW5nIGhlbHBlciBtZXRob2QgdG8gd2FpdCBmb3IgcHJvY2Vzc2luZyB0byBjb21wbGV0ZSkuXG4gICAqL1xuICBhc3luYyB1cGxvYWQoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGZpbGU6IFVwbG9hZGFibGUsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IFByb21pc2U8VmVjdG9yU3RvcmVGaWxlPiB7XG4gICAgY29uc3QgZmlsZUluZm8gPSBhd2FpdCB0aGlzLl9jbGllbnQuZmlsZXMuY3JlYXRlKHsgZmlsZTogZmlsZSwgcHVycG9zZTogJ2Fzc2lzdGFudHMnIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZSh2ZWN0b3JTdG9yZUlkLCB7IGZpbGVfaWQ6IGZpbGVJbmZvLmlkIH0sIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGZpbGUgdG8gYSB2ZWN0b3Igc3RvcmUgYW5kIHBvbGwgdW50aWwgcHJvY2Vzc2luZyBpcyBjb21wbGV0ZS5cbiAgICovXG4gIGFzeW5jIHVwbG9hZEFuZFBvbGwoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGZpbGU6IFVwbG9hZGFibGUsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMgJiB7IHBvbGxJbnRlcnZhbE1zPzogbnVtYmVyIH0sXG4gICk6IFByb21pc2U8VmVjdG9yU3RvcmVGaWxlPiB7XG4gICAgY29uc3QgZmlsZUluZm8gPSBhd2FpdCB0aGlzLnVwbG9hZCh2ZWN0b3JTdG9yZUlkLCBmaWxlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5wb2xsKHZlY3RvclN0b3JlSWQsIGZpbGVJbmZvLmlkLCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVmVjdG9yU3RvcmVGaWxlc1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlPFZlY3RvclN0b3JlRmlsZT4ge31cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZmlsZXMgYXR0YWNoZWQgdG8gYSB2ZWN0b3Igc3RvcmUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmVGaWxlIHtcbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgdmVjdG9yIHN0b3JlIGZpbGUgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBsYXN0IGVycm9yIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHZlY3RvciBzdG9yZSBmaWxlLiBXaWxsIGJlIGBudWxsYCBpZiB0aGVyZVxuICAgKiBhcmUgbm8gZXJyb3JzLlxuICAgKi9cbiAgbGFzdF9lcnJvcjogVmVjdG9yU3RvcmVGaWxlLkxhc3RFcnJvciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGB2ZWN0b3Jfc3RvcmUuZmlsZWAuXG4gICAqL1xuICBvYmplY3Q6ICd2ZWN0b3Jfc3RvcmUuZmlsZSc7XG5cbiAgLyoqXG4gICAqIFRoZSBzdGF0dXMgb2YgdGhlIHZlY3RvciBzdG9yZSBmaWxlLCB3aGljaCBjYW4gYmUgZWl0aGVyIGBpbl9wcm9ncmVzc2AsXG4gICAqIGBjb21wbGV0ZWRgLCBgY2FuY2VsbGVkYCwgb3IgYGZhaWxlZGAuIFRoZSBzdGF0dXMgYGNvbXBsZXRlZGAgaW5kaWNhdGVzIHRoYXQgdGhlXG4gICAqIHZlY3RvciBzdG9yZSBmaWxlIGlzIHJlYWR5IGZvciB1c2UuXG4gICAqL1xuICBzdGF0dXM6ICdpbl9wcm9ncmVzcycgfCAnY29tcGxldGVkJyB8ICdjYW5jZWxsZWQnIHwgJ2ZhaWxlZCc7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3RhbCB2ZWN0b3Igc3RvcmUgdXNhZ2UgaW4gYnl0ZXMuIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBkaWZmZXJlbnQgZnJvbSB0aGVcbiAgICogb3JpZ2luYWwgZmlsZSBzaXplLlxuICAgKi9cbiAgdXNhZ2VfYnl0ZXM6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZVxuICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgKiB0aGF0IHRoZSBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgaXNcbiAgICogYXR0YWNoZWQgdG8uXG4gICAqL1xuICB2ZWN0b3Jfc3RvcmVfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHN0cmF0ZWd5IHVzZWQgdG8gY2h1bmsgdGhlIGZpbGUuXG4gICAqL1xuICBjaHVua2luZ19zdHJhdGVneT86IFZlY3RvclN0b3Jlc0FQSS5GaWxlQ2h1bmtpbmdTdHJhdGVneTtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBWZWN0b3JTdG9yZUZpbGUge1xuICAvKipcbiAgICogVGhlIGxhc3QgZXJyb3IgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdmVjdG9yIHN0b3JlIGZpbGUuIFdpbGwgYmUgYG51bGxgIGlmIHRoZXJlXG4gICAqIGFyZSBubyBlcnJvcnMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIExhc3RFcnJvciB7XG4gICAgLyoqXG4gICAgICogT25lIG9mIGBzZXJ2ZXJfZXJyb3JgIG9yIGByYXRlX2xpbWl0X2V4Y2VlZGVkYC5cbiAgICAgKi9cbiAgICBjb2RlOiAnc2VydmVyX2Vycm9yJyB8ICd1bnN1cHBvcnRlZF9maWxlJyB8ICdpbnZhbGlkX2ZpbGUnO1xuXG4gICAgLyoqXG4gICAgICogQSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3IuXG4gICAgICovXG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmVGaWxlRGVsZXRlZCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgZGVsZXRlZDogYm9vbGVhbjtcblxuICBvYmplY3Q6ICd2ZWN0b3Jfc3RvcmUuZmlsZS5kZWxldGVkJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEIHRoYXQgdGhlXG4gICAqIHZlY3RvciBzdG9yZSBzaG91bGQgdXNlLiBVc2VmdWwgZm9yIHRvb2xzIGxpa2UgYGZpbGVfc2VhcmNoYCB0aGF0IGNhbiBhY2Nlc3NcbiAgICogZmlsZXMuXG4gICAqL1xuICBmaWxlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBjaHVua2luZyBzdHJhdGVneSB1c2VkIHRvIGNodW5rIHRoZSBmaWxlKHMpLiBJZiBub3Qgc2V0LCB3aWxsIHVzZSB0aGUgYGF1dG9gXG4gICAqIHN0cmF0ZWd5LiBPbmx5IGFwcGxpY2FibGUgaWYgYGZpbGVfaWRzYCBpcyBub24tZW1wdHkuXG4gICAqL1xuICBjaHVua2luZ19zdHJhdGVneT86IFZlY3RvclN0b3Jlc0FQSS5GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVMaXN0UGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIGN1cnNvciBmb3IgdXNlIGluIHBhZ2luYXRpb24uIGBiZWZvcmVgIGlzIGFuIG9iamVjdCBJRCB0aGF0IGRlZmluZXMgeW91ciBwbGFjZVxuICAgKiBpbiB0aGUgbGlzdC4gRm9yIGluc3RhbmNlLCBpZiB5b3UgbWFrZSBhIGxpc3QgcmVxdWVzdCBhbmQgcmVjZWl2ZSAxMDAgb2JqZWN0cyxcbiAgICogc3RhcnRpbmcgd2l0aCBvYmpfZm9vLCB5b3VyIHN1YnNlcXVlbnQgY2FsbCBjYW4gaW5jbHVkZSBiZWZvcmU9b2JqX2ZvbyBpbiBvcmRlclxuICAgKiB0byBmZXRjaCB0aGUgcHJldmlvdXMgcGFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGJlZm9yZT86IHN0cmluZztcblxuICAvKipcbiAgICogRmlsdGVyIGJ5IGZpbGUgc3RhdHVzLiBPbmUgb2YgYGluX3Byb2dyZXNzYCwgYGNvbXBsZXRlZGAsIGBmYWlsZWRgLCBgY2FuY2VsbGVkYC5cbiAgICovXG4gIGZpbHRlcj86ICdpbl9wcm9ncmVzcycgfCAnY29tcGxldGVkJyB8ICdmYWlsZWQnIHwgJ2NhbmNlbGxlZCc7XG5cbiAgLyoqXG4gICAqIFNvcnQgb3JkZXIgYnkgdGhlIGBjcmVhdGVkX2F0YCB0aW1lc3RhbXAgb2YgdGhlIG9iamVjdHMuIGBhc2NgIGZvciBhc2NlbmRpbmdcbiAgICogb3JkZXIgYW5kIGBkZXNjYCBmb3IgZGVzY2VuZGluZyBvcmRlci5cbiAgICovXG4gIG9yZGVyPzogJ2FzYycgfCAnZGVzYyc7XG59XG5cbkZpbGVzLlZlY3RvclN0b3JlRmlsZXNQYWdlID0gVmVjdG9yU3RvcmVGaWxlc1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBGaWxlcyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBWZWN0b3JTdG9yZUZpbGUgYXMgVmVjdG9yU3RvcmVGaWxlLFxuICAgIHR5cGUgVmVjdG9yU3RvcmVGaWxlRGVsZXRlZCBhcyBWZWN0b3JTdG9yZUZpbGVEZWxldGVkLFxuICAgIFZlY3RvclN0b3JlRmlsZXNQYWdlIGFzIFZlY3RvclN0b3JlRmlsZXNQYWdlLFxuICAgIHR5cGUgRmlsZUNyZWF0ZVBhcmFtcyBhcyBGaWxlQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgRmlsZUxpc3RQYXJhbXMgYXMgRmlsZUxpc3RQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0IHsgVXBsb2FkYWJsZSB9IGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0IHsgYWxsU2V0dGxlZFdpdGhUaHJvdyB9IGZyb20gJy4uLy4uLy4uL2xpYi9VdGlsJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBGaWxlc0FQSSBmcm9tICcuL2ZpbGVzJztcbmltcG9ydCB7IFZlY3RvclN0b3JlRmlsZXNQYWdlIH0gZnJvbSAnLi9maWxlcyc7XG5pbXBvcnQgKiBhcyBWZWN0b3JTdG9yZXNBUEkgZnJvbSAnLi92ZWN0b3Itc3RvcmVzJztcbmltcG9ydCB7IHR5cGUgQ3Vyc29yUGFnZVBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL3BhZ2luYXRpb24nO1xuXG5leHBvcnQgY2xhc3MgRmlsZUJhdGNoZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB2ZWN0b3Igc3RvcmUgZmlsZSBiYXRjaC5cbiAgICovXG4gIGNyZWF0ZShcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgYm9keTogRmlsZUJhdGNoQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VmVjdG9yU3RvcmVGaWxlQmF0Y2g+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH0vZmlsZV9iYXRjaGVzYCwge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIHZlY3RvciBzdG9yZSBmaWxlIGJhdGNoLlxuICAgKi9cbiAgcmV0cmlldmUoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGJhdGNoSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFZlY3RvclN0b3JlRmlsZUJhdGNoPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH0vZmlsZV9iYXRjaGVzLyR7YmF0Y2hJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgYSB2ZWN0b3Igc3RvcmUgZmlsZSBiYXRjaC4gVGhpcyBhdHRlbXB0cyB0byBjYW5jZWwgdGhlIHByb2Nlc3Npbmcgb2ZcbiAgICogZmlsZXMgaW4gdGhpcyBiYXRjaCBhcyBzb29uIGFzIHBvc3NpYmxlLlxuICAgKi9cbiAgY2FuY2VsKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBiYXRjaElkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVCYXRjaD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlX2JhdGNoZXMvJHtiYXRjaElkfS9jYW5jZWxgLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB2ZWN0b3Igc3RvcmUgYmF0Y2ggYW5kIHBvbGwgdW50aWwgYWxsIGZpbGVzIGhhdmUgYmVlbiBwcm9jZXNzZWQuXG4gICAqL1xuICBhc3luYyBjcmVhdGVBbmRQb2xsKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBib2R5OiBGaWxlQmF0Y2hDcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMgJiB7IHBvbGxJbnRlcnZhbE1zPzogbnVtYmVyIH0sXG4gICk6IFByb21pc2U8VmVjdG9yU3RvcmVGaWxlQmF0Y2g+IHtcbiAgICBjb25zdCBiYXRjaCA9IGF3YWl0IHRoaXMuY3JlYXRlKHZlY3RvclN0b3JlSWQsIGJvZHkpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnBvbGwodmVjdG9yU3RvcmVJZCwgYmF0Y2guaWQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBmaWxlcyBpbiBhIGJhdGNoLlxuICAgKi9cbiAgbGlzdEZpbGVzKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBiYXRjaElkOiBzdHJpbmcsXG4gICAgcXVlcnk/OiBGaWxlQmF0Y2hMaXN0RmlsZXNQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8VmVjdG9yU3RvcmVGaWxlc1BhZ2UsIEZpbGVzQVBJLlZlY3RvclN0b3JlRmlsZT47XG4gIGxpc3RGaWxlcyhcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgYmF0Y2hJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFZlY3RvclN0b3JlRmlsZXNQYWdlLCBGaWxlc0FQSS5WZWN0b3JTdG9yZUZpbGU+O1xuICBsaXN0RmlsZXMoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGJhdGNoSWQ6IHN0cmluZyxcbiAgICBxdWVyeTogRmlsZUJhdGNoTGlzdEZpbGVzUGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFZlY3RvclN0b3JlRmlsZXNQYWdlLCBGaWxlc0FQSS5WZWN0b3JTdG9yZUZpbGU+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3RGaWxlcyh2ZWN0b3JTdG9yZUlkLCBiYXRjaElkLCB7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoXG4gICAgICBgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlX2JhdGNoZXMvJHtiYXRjaElkfS9maWxlc2AsXG4gICAgICBWZWN0b3JTdG9yZUZpbGVzUGFnZSxcbiAgICAgIHsgcXVlcnksIC4uLm9wdGlvbnMsIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0gfSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhaXQgZm9yIHRoZSBnaXZlbiBmaWxlIGJhdGNoIHRvIGJlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogTm90ZTogdGhpcyB3aWxsIHJldHVybiBldmVuIGlmIG9uZSBvZiB0aGUgZmlsZXMgZmFpbGVkIHRvIHByb2Nlc3MsIHlvdSBuZWVkIHRvXG4gICAqIGNoZWNrIGJhdGNoLmZpbGVfY291bnRzLmZhaWxlZF9jb3VudCB0byBoYW5kbGUgdGhpcyBjYXNlLlxuICAgKi9cbiAgYXN5bmMgcG9sbChcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgYmF0Y2hJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zICYgeyBwb2xsSW50ZXJ2YWxNcz86IG51bWJlciB9LFxuICApOiBQcm9taXNlPFZlY3RvclN0b3JlRmlsZUJhdGNoPiB7XG4gICAgY29uc3QgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLVBvbGwtSGVscGVyJzogJ3RydWUnIH07XG4gICAgaWYgKG9wdGlvbnM/LnBvbGxJbnRlcnZhbE1zKSB7XG4gICAgICBoZWFkZXJzWydYLVN0YWlubGVzcy1DdXN0b20tUG9sbC1JbnRlcnZhbCddID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNcy50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRhdGE6IGJhdGNoLCByZXNwb25zZSB9ID0gYXdhaXQgdGhpcy5yZXRyaWV2ZSh2ZWN0b3JTdG9yZUlkLCBiYXRjaElkLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICB9KS53aXRoUmVzcG9uc2UoKTtcblxuICAgICAgc3dpdGNoIChiYXRjaC5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSAnaW5fcHJvZ3Jlc3MnOlxuICAgICAgICAgIGxldCBzbGVlcEludGVydmFsID0gNTAwMDtcblxuICAgICAgICAgIGlmIChvcHRpb25zPy5wb2xsSW50ZXJ2YWxNcykge1xuICAgICAgICAgICAgc2xlZXBJbnRlcnZhbCA9IG9wdGlvbnMucG9sbEludGVydmFsTXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlckludGVydmFsID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ29wZW5haS1wb2xsLWFmdGVyLW1zJyk7XG4gICAgICAgICAgICBpZiAoaGVhZGVySW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgY29uc3QgaGVhZGVySW50ZXJ2YWxNcyA9IHBhcnNlSW50KGhlYWRlckludGVydmFsKTtcbiAgICAgICAgICAgICAgaWYgKCFpc05hTihoZWFkZXJJbnRlcnZhbE1zKSkge1xuICAgICAgICAgICAgICAgIHNsZWVwSW50ZXJ2YWwgPSBoZWFkZXJJbnRlcnZhbE1zO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IHNsZWVwKHNsZWVwSW50ZXJ2YWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICBjYXNlICdjYW5jZWxsZWQnOlxuICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgIHJldHVybiBiYXRjaDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkcyB0aGUgZ2l2ZW4gZmlsZXMgY29uY3VycmVudGx5IGFuZCB0aGVuIGNyZWF0ZXMgYSB2ZWN0b3Igc3RvcmUgZmlsZSBiYXRjaC5cbiAgICpcbiAgICogVGhlIGNvbmN1cnJlbmN5IGxpbWl0IGlzIGNvbmZpZ3VyYWJsZSB1c2luZyB0aGUgYG1heENvbmN1cnJlbmN5YCBwYXJhbWV0ZXIuXG4gICAqL1xuICBhc3luYyB1cGxvYWRBbmRQb2xsKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICB7IGZpbGVzLCBmaWxlSWRzID0gW10gfTogeyBmaWxlczogVXBsb2FkYWJsZVtdOyBmaWxlSWRzPzogc3RyaW5nW10gfSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyAmIHsgcG9sbEludGVydmFsTXM/OiBudW1iZXI7IG1heENvbmN1cnJlbmN5PzogbnVtYmVyIH0sXG4gICk6IFByb21pc2U8VmVjdG9yU3RvcmVGaWxlQmF0Y2g+IHtcbiAgICBpZiAoZmlsZXMgPT0gbnVsbCB8fCBmaWxlcy5sZW5ndGggPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTm8gXFxgZmlsZXNcXGAgcHJvdmlkZWQgdG8gcHJvY2Vzcy4gSWYgeW91J3ZlIGFscmVhZHkgdXBsb2FkZWQgZmlsZXMgeW91IHNob3VsZCB1c2UgXFxgLmNyZWF0ZUFuZFBvbGwoKVxcYCBpbnN0ZWFkYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgY29uZmlndXJlZENvbmN1cnJlbmN5ID0gb3B0aW9ucz8ubWF4Q29uY3VycmVuY3kgPz8gNTtcblxuICAgIC8vIFdlIGNhcCB0aGUgbnVtYmVyIG9mIHdvcmtlcnMgYXQgdGhlIG51bWJlciBvZiBmaWxlcyAoc28gd2UgZG9uJ3Qgc3RhcnQgYW55IHVubmVjZXNzYXJ5IHdvcmtlcnMpXG4gICAgY29uc3QgY29uY3VycmVuY3lMaW1pdCA9IE1hdGgubWluKGNvbmZpZ3VyZWRDb25jdXJyZW5jeSwgZmlsZXMubGVuZ3RoKTtcblxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuX2NsaWVudDtcbiAgICBjb25zdCBmaWxlSXRlcmF0b3IgPSBmaWxlcy52YWx1ZXMoKTtcbiAgICBjb25zdCBhbGxGaWxlSWRzOiBzdHJpbmdbXSA9IFsuLi5maWxlSWRzXTtcblxuICAgIC8vIFRoaXMgY29kZSBpcyBiYXNlZCBvbiB0aGlzIGRlc2lnbi4gVGhlIGxpYnJhcmllcyBkb24ndCBhY2NvbW1vZGF0ZSBvdXIgZW52aXJvbm1lbnQgbGltaXRzLlxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQwNjM5NDMyL3doYXQtaXMtdGhlLWJlc3Qtd2F5LXRvLWxpbWl0LWNvbmN1cnJlbmN5LXdoZW4tdXNpbmctZXM2cy1wcm9taXNlLWFsbFxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NGaWxlcyhpdGVyYXRvcjogSXRlcmFibGVJdGVyYXRvcjxVcGxvYWRhYmxlPikge1xuICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVyYXRvcikge1xuICAgICAgICBjb25zdCBmaWxlT2JqID0gYXdhaXQgY2xpZW50LmZpbGVzLmNyZWF0ZSh7IGZpbGU6IGl0ZW0sIHB1cnBvc2U6ICdhc3Npc3RhbnRzJyB9LCBvcHRpb25zKTtcbiAgICAgICAgYWxsRmlsZUlkcy5wdXNoKGZpbGVPYmouaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0YXJ0IHdvcmtlcnMgdG8gcHJvY2VzcyByZXN1bHRzXG4gICAgY29uc3Qgd29ya2VycyA9IEFycmF5KGNvbmN1cnJlbmN5TGltaXQpLmZpbGwoZmlsZUl0ZXJhdG9yKS5tYXAocHJvY2Vzc0ZpbGVzKTtcblxuICAgIC8vIFdhaXQgZm9yIGFsbCBwcm9jZXNzaW5nIHRvIGNvbXBsZXRlLlxuICAgIGF3YWl0IGFsbFNldHRsZWRXaXRoVGhyb3cod29ya2Vycyk7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jcmVhdGVBbmRQb2xsKHZlY3RvclN0b3JlSWQsIHtcbiAgICAgIGZpbGVfaWRzOiBhbGxGaWxlSWRzLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQSBiYXRjaCBvZiBmaWxlcyBhdHRhY2hlZCB0byBhIHZlY3RvciBzdG9yZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZUZpbGVCYXRjaCB7XG4gIC8qKlxuICAgKiBUaGUgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHZlY3RvciBzdG9yZSBmaWxlcyBiYXRjaCB3YXNcbiAgICogY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICBmaWxlX2NvdW50czogVmVjdG9yU3RvcmVGaWxlQmF0Y2guRmlsZUNvdW50cztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYHZlY3Rvcl9zdG9yZS5maWxlX2JhdGNoYC5cbiAgICovXG4gIG9iamVjdDogJ3ZlY3Rvcl9zdG9yZS5maWxlc19iYXRjaCc7XG5cbiAgLyoqXG4gICAqIFRoZSBzdGF0dXMgb2YgdGhlIHZlY3RvciBzdG9yZSBmaWxlcyBiYXRjaCwgd2hpY2ggY2FuIGJlIGVpdGhlciBgaW5fcHJvZ3Jlc3NgLFxuICAgKiBgY29tcGxldGVkYCwgYGNhbmNlbGxlZGAgb3IgYGZhaWxlZGAuXG4gICAqL1xuICBzdGF0dXM6ICdpbl9wcm9ncmVzcycgfCAnY29tcGxldGVkJyB8ICdjYW5jZWxsZWQnIHwgJ2ZhaWxlZCc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGVcbiAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICogdGhhdCB0aGUgW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIGlzXG4gICAqIGF0dGFjaGVkIHRvLlxuICAgKi9cbiAgdmVjdG9yX3N0b3JlX2lkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVmVjdG9yU3RvcmVGaWxlQmF0Y2gge1xuICBleHBvcnQgaW50ZXJmYWNlIEZpbGVDb3VudHMge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZmlsZXMgdGhhdCB3aGVyZSBjYW5jZWxsZWQuXG4gICAgICovXG4gICAgY2FuY2VsbGVkOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGZpbGVzIHRoYXQgaGF2ZSBiZWVuIHByb2Nlc3NlZC5cbiAgICAgKi9cbiAgICBjb21wbGV0ZWQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZmlsZXMgdGhhdCBoYXZlIGZhaWxlZCB0byBwcm9jZXNzLlxuICAgICAqL1xuICAgIGZhaWxlZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBmaWxlcyB0aGF0IGFyZSBjdXJyZW50bHkgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAqL1xuICAgIGluX3Byb2dyZXNzOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIGZpbGVzLlxuICAgICAqL1xuICAgIHRvdGFsOiBudW1iZXI7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlQmF0Y2hDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogQSBsaXN0IG9mIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgdGhhdFxuICAgKiB0aGUgdmVjdG9yIHN0b3JlIHNob3VsZCB1c2UuIFVzZWZ1bCBmb3IgdG9vbHMgbGlrZSBgZmlsZV9zZWFyY2hgIHRoYXQgY2FuIGFjY2Vzc1xuICAgKiBmaWxlcy5cbiAgICovXG4gIGZpbGVfaWRzOiBBcnJheTxzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBUaGUgY2h1bmtpbmcgc3RyYXRlZ3kgdXNlZCB0byBjaHVuayB0aGUgZmlsZShzKS4gSWYgbm90IHNldCwgd2lsbCB1c2UgdGhlIGBhdXRvYFxuICAgKiBzdHJhdGVneS4gT25seSBhcHBsaWNhYmxlIGlmIGBmaWxlX2lkc2AgaXMgbm9uLWVtcHR5LlxuICAgKi9cbiAgY2h1bmtpbmdfc3RyYXRlZ3k/OiBWZWN0b3JTdG9yZXNBUEkuRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlQmF0Y2hMaXN0RmlsZXNQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgY3Vyc29yIGZvciB1c2UgaW4gcGFnaW5hdGlvbi4gYGJlZm9yZWAgaXMgYW4gb2JqZWN0IElEIHRoYXQgZGVmaW5lcyB5b3VyIHBsYWNlXG4gICAqIGluIHRoZSBsaXN0LiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBtYWtlIGEgbGlzdCByZXF1ZXN0IGFuZCByZWNlaXZlIDEwMCBvYmplY3RzLFxuICAgKiBzdGFydGluZyB3aXRoIG9ial9mb28sIHlvdXIgc3Vic2VxdWVudCBjYWxsIGNhbiBpbmNsdWRlIGJlZm9yZT1vYmpfZm9vIGluIG9yZGVyXG4gICAqIHRvIGZldGNoIHRoZSBwcmV2aW91cyBwYWdlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgYmVmb3JlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGaWx0ZXIgYnkgZmlsZSBzdGF0dXMuIE9uZSBvZiBgaW5fcHJvZ3Jlc3NgLCBgY29tcGxldGVkYCwgYGZhaWxlZGAsIGBjYW5jZWxsZWRgLlxuICAgKi9cbiAgZmlsdGVyPzogJ2luX3Byb2dyZXNzJyB8ICdjb21wbGV0ZWQnIHwgJ2ZhaWxlZCcgfCAnY2FuY2VsbGVkJztcblxuICAvKipcbiAgICogU29ydCBvcmRlciBieSB0aGUgYGNyZWF0ZWRfYXRgIHRpbWVzdGFtcCBvZiB0aGUgb2JqZWN0cy4gYGFzY2AgZm9yIGFzY2VuZGluZ1xuICAgKiBvcmRlciBhbmQgYGRlc2NgIGZvciBkZXNjZW5kaW5nIG9yZGVyLlxuICAgKi9cbiAgb3JkZXI/OiAnYXNjJyB8ICdkZXNjJztcbn1cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEZpbGVCYXRjaGVzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIFZlY3RvclN0b3JlRmlsZUJhdGNoIGFzIFZlY3RvclN0b3JlRmlsZUJhdGNoLFxuICAgIHR5cGUgRmlsZUJhdGNoQ3JlYXRlUGFyYW1zIGFzIEZpbGVCYXRjaENyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIEZpbGVCYXRjaExpc3RGaWxlc1BhcmFtcyBhcyBGaWxlQmF0Y2hMaXN0RmlsZXNQYXJhbXMsXG4gIH07XG59XG5cbmV4cG9ydCB7IFZlY3RvclN0b3JlRmlsZXNQYWdlIH07XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgRmlsZUJhdGNoZXNBUEkgZnJvbSAnLi9maWxlLWJhdGNoZXMnO1xuaW1wb3J0IHtcbiAgRmlsZUJhdGNoQ3JlYXRlUGFyYW1zLFxuICBGaWxlQmF0Y2hMaXN0RmlsZXNQYXJhbXMsXG4gIEZpbGVCYXRjaGVzLFxuICBWZWN0b3JTdG9yZUZpbGVCYXRjaCxcbn0gZnJvbSAnLi9maWxlLWJhdGNoZXMnO1xuaW1wb3J0ICogYXMgRmlsZXNBUEkgZnJvbSAnLi9maWxlcyc7XG5pbXBvcnQge1xuICBGaWxlQ3JlYXRlUGFyYW1zLFxuICBGaWxlTGlzdFBhcmFtcyxcbiAgRmlsZXMsXG4gIFZlY3RvclN0b3JlRmlsZSxcbiAgVmVjdG9yU3RvcmVGaWxlRGVsZXRlZCxcbiAgVmVjdG9yU3RvcmVGaWxlc1BhZ2UsXG59IGZyb20gJy4vZmlsZXMnO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSwgdHlwZSBDdXJzb3JQYWdlUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vcGFnaW5hdGlvbic7XG5cbmV4cG9ydCBjbGFzcyBWZWN0b3JTdG9yZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIGZpbGVzOiBGaWxlc0FQSS5GaWxlcyA9IG5ldyBGaWxlc0FQSS5GaWxlcyh0aGlzLl9jbGllbnQpO1xuICBmaWxlQmF0Y2hlczogRmlsZUJhdGNoZXNBUEkuRmlsZUJhdGNoZXMgPSBuZXcgRmlsZUJhdGNoZXNBUEkuRmlsZUJhdGNoZXModGhpcy5fY2xpZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgdmVjdG9yIHN0b3JlLlxuICAgKi9cbiAgY3JlYXRlKGJvZHk6IFZlY3RvclN0b3JlQ3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxWZWN0b3JTdG9yZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL3ZlY3Rvcl9zdG9yZXMnLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgdmVjdG9yIHN0b3JlLlxuICAgKi9cbiAgcmV0cmlldmUodmVjdG9yU3RvcmVJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxWZWN0b3JTdG9yZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZpZXMgYSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICB1cGRhdGUoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGJvZHk6IFZlY3RvclN0b3JlVXBkYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VmVjdG9yU3RvcmU+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH1gLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3Jlcy5cbiAgICovXG4gIGxpc3QoXG4gICAgcXVlcnk/OiBWZWN0b3JTdG9yZUxpc3RQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8VmVjdG9yU3RvcmVzUGFnZSwgVmVjdG9yU3RvcmU+O1xuICBsaXN0KG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5QYWdlUHJvbWlzZTxWZWN0b3JTdG9yZXNQYWdlLCBWZWN0b3JTdG9yZT47XG4gIGxpc3QoXG4gICAgcXVlcnk6IFZlY3RvclN0b3JlTGlzdFBhcmFtcyB8IENvcmUuUmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxWZWN0b3JTdG9yZXNQYWdlLCBWZWN0b3JTdG9yZT4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdCh7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy92ZWN0b3Jfc3RvcmVzJywgVmVjdG9yU3RvcmVzUGFnZSwge1xuICAgICAgcXVlcnksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICBkZWwodmVjdG9yU3RvcmVJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxWZWN0b3JTdG9yZURlbGV0ZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfWAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBWZWN0b3JTdG9yZXNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxWZWN0b3JTdG9yZT4ge31cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzdHJhdGVneS4gVGhpcyBzdHJhdGVneSBjdXJyZW50bHkgdXNlcyBhIGBtYXhfY2h1bmtfc2l6ZV90b2tlbnNgIG9mXG4gKiBgODAwYCBhbmQgYGNodW5rX292ZXJsYXBfdG9rZW5zYCBvZiBgNDAwYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBdXRvRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbSB7XG4gIC8qKlxuICAgKiBBbHdheXMgYGF1dG9gLlxuICAgKi9cbiAgdHlwZTogJ2F1dG8nO1xufVxuXG4vKipcbiAqIFRoZSBzdHJhdGVneSB1c2VkIHRvIGNodW5rIHRoZSBmaWxlLlxuICovXG5leHBvcnQgdHlwZSBGaWxlQ2h1bmtpbmdTdHJhdGVneSA9IFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0IHwgT3RoZXJGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdDtcblxuLyoqXG4gKiBUaGUgY2h1bmtpbmcgc3RyYXRlZ3kgdXNlZCB0byBjaHVuayB0aGUgZmlsZShzKS4gSWYgbm90IHNldCwgd2lsbCB1c2UgdGhlIGBhdXRvYFxuICogc3RyYXRlZ3kuIE9ubHkgYXBwbGljYWJsZSBpZiBgZmlsZV9pZHNgIGlzIG5vbi1lbXB0eS5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbSA9IEF1dG9GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtIHwgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3RQYXJhbTtcblxuLyoqXG4gKiBUaGlzIGlzIHJldHVybmVkIHdoZW4gdGhlIGNodW5raW5nIHN0cmF0ZWd5IGlzIHVua25vd24uIFR5cGljYWxseSwgdGhpcyBpc1xuICogYmVjYXVzZSB0aGUgZmlsZSB3YXMgaW5kZXhlZCBiZWZvcmUgdGhlIGBjaHVua2luZ19zdHJhdGVneWAgY29uY2VwdCB3YXNcbiAqIGludHJvZHVjZWQgaW4gdGhlIEFQSS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPdGhlckZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0IHtcbiAgLyoqXG4gICAqIEFsd2F5cyBgb3RoZXJgLlxuICAgKi9cbiAgdHlwZTogJ290aGVyJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneSB7XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHRva2VucyB0aGF0IG92ZXJsYXAgYmV0d2VlbiBjaHVua3MuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGA0MDBgLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIG92ZXJsYXAgbXVzdCBub3QgZXhjZWVkIGhhbGYgb2YgYG1heF9jaHVua19zaXplX3Rva2Vuc2AuXG4gICAqL1xuICBjaHVua19vdmVybGFwX3Rva2VuczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgdG9rZW5zIGluIGVhY2ggY2h1bmsuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGA4MDBgLiBUaGVcbiAgICogbWluaW11bSB2YWx1ZSBpcyBgMTAwYCBhbmQgdGhlIG1heGltdW0gdmFsdWUgaXMgYDQwOTZgLlxuICAgKi9cbiAgbWF4X2NodW5rX3NpemVfdG9rZW5zOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3Qge1xuICBzdGF0aWM6IFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5O1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYHN0YXRpY2AuXG4gICAqL1xuICB0eXBlOiAnc3RhdGljJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdFBhcmFtIHtcbiAgc3RhdGljOiBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneTtcblxuICAvKipcbiAgICogQWx3YXlzIGBzdGF0aWNgLlxuICAgKi9cbiAgdHlwZTogJ3N0YXRpYyc7XG59XG5cbi8qKlxuICogQSB2ZWN0b3Igc3RvcmUgaXMgYSBjb2xsZWN0aW9uIG9mIHByb2Nlc3NlZCBmaWxlcyBjYW4gYmUgdXNlZCBieSB0aGVcbiAqIGBmaWxlX3NlYXJjaGAgdG9vbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZSB7XG4gIC8qKlxuICAgKiBUaGUgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHZlY3RvciBzdG9yZSB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICBmaWxlX2NvdW50czogVmVjdG9yU3RvcmUuRmlsZUNvdW50cztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgdmVjdG9yIHN0b3JlIHdhcyBsYXN0IGFjdGl2ZS5cbiAgICovXG4gIGxhc3RfYWN0aXZlX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YTogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGB2ZWN0b3Jfc3RvcmVgLlxuICAgKi9cbiAgb2JqZWN0OiAndmVjdG9yX3N0b3JlJztcblxuICAvKipcbiAgICogVGhlIHN0YXR1cyBvZiB0aGUgdmVjdG9yIHN0b3JlLCB3aGljaCBjYW4gYmUgZWl0aGVyIGBleHBpcmVkYCwgYGluX3Byb2dyZXNzYCwgb3JcbiAgICogYGNvbXBsZXRlZGAuIEEgc3RhdHVzIG9mIGBjb21wbGV0ZWRgIGluZGljYXRlcyB0aGF0IHRoZSB2ZWN0b3Igc3RvcmUgaXMgcmVhZHlcbiAgICogZm9yIHVzZS5cbiAgICovXG4gIHN0YXR1czogJ2V4cGlyZWQnIHwgJ2luX3Byb2dyZXNzJyB8ICdjb21wbGV0ZWQnO1xuXG4gIC8qKlxuICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHVzZWQgYnkgdGhlIGZpbGVzIGluIHRoZSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICB1c2FnZV9ieXRlczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgZXhwaXJhdGlvbiBwb2xpY3kgZm9yIGEgdmVjdG9yIHN0b3JlLlxuICAgKi9cbiAgZXhwaXJlc19hZnRlcj86IFZlY3RvclN0b3JlLkV4cGlyZXNBZnRlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgdmVjdG9yIHN0b3JlIHdpbGwgZXhwaXJlLlxuICAgKi9cbiAgZXhwaXJlc19hdD86IG51bWJlciB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVmVjdG9yU3RvcmUge1xuICBleHBvcnQgaW50ZXJmYWNlIEZpbGVDb3VudHMge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZmlsZXMgdGhhdCB3ZXJlIGNhbmNlbGxlZC5cbiAgICAgKi9cbiAgICBjYW5jZWxsZWQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZmlsZXMgdGhhdCBoYXZlIGJlZW4gc3VjY2Vzc2Z1bGx5IHByb2Nlc3NlZC5cbiAgICAgKi9cbiAgICBjb21wbGV0ZWQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZmlsZXMgdGhhdCBoYXZlIGZhaWxlZCB0byBwcm9jZXNzLlxuICAgICAqL1xuICAgIGZhaWxlZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBmaWxlcyB0aGF0IGFyZSBjdXJyZW50bHkgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAqL1xuICAgIGluX3Byb2dyZXNzOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIGZpbGVzLlxuICAgICAqL1xuICAgIHRvdGFsOiBudW1iZXI7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGV4cGlyYXRpb24gcG9saWN5IGZvciBhIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXhwaXJlc0FmdGVyIHtcbiAgICAvKipcbiAgICAgKiBBbmNob3IgdGltZXN0YW1wIGFmdGVyIHdoaWNoIHRoZSBleHBpcmF0aW9uIHBvbGljeSBhcHBsaWVzLiBTdXBwb3J0ZWQgYW5jaG9yczpcbiAgICAgKiBgbGFzdF9hY3RpdmVfYXRgLlxuICAgICAqL1xuICAgIGFuY2hvcjogJ2xhc3RfYWN0aXZlX2F0JztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZGF5cyBhZnRlciB0aGUgYW5jaG9yIHRpbWUgdGhhdCB0aGUgdmVjdG9yIHN0b3JlIHdpbGwgZXhwaXJlLlxuICAgICAqL1xuICAgIGRheXM6IG51bWJlcjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlRGVsZXRlZCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgZGVsZXRlZDogYm9vbGVhbjtcblxuICBvYmplY3Q6ICd2ZWN0b3Jfc3RvcmUuZGVsZXRlZCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmVDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIGNodW5raW5nIHN0cmF0ZWd5IHVzZWQgdG8gY2h1bmsgdGhlIGZpbGUocykuIElmIG5vdCBzZXQsIHdpbGwgdXNlIHRoZSBgYXV0b2BcbiAgICogc3RyYXRlZ3kuIE9ubHkgYXBwbGljYWJsZSBpZiBgZmlsZV9pZHNgIGlzIG5vbi1lbXB0eS5cbiAgICovXG4gIGNodW5raW5nX3N0cmF0ZWd5PzogRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbTtcblxuICAvKipcbiAgICogVGhlIGV4cGlyYXRpb24gcG9saWN5IGZvciBhIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIGV4cGlyZXNfYWZ0ZXI/OiBWZWN0b3JTdG9yZUNyZWF0ZVBhcmFtcy5FeHBpcmVzQWZ0ZXI7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIHRoYXRcbiAgICogdGhlIHZlY3RvciBzdG9yZSBzaG91bGQgdXNlLiBVc2VmdWwgZm9yIHRvb2xzIGxpa2UgYGZpbGVfc2VhcmNoYCB0aGF0IGNhbiBhY2Nlc3NcbiAgICogZmlsZXMuXG4gICAqL1xuICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFZlY3RvclN0b3JlQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBleHBpcmF0aW9uIHBvbGljeSBmb3IgYSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEV4cGlyZXNBZnRlciB7XG4gICAgLyoqXG4gICAgICogQW5jaG9yIHRpbWVzdGFtcCBhZnRlciB3aGljaCB0aGUgZXhwaXJhdGlvbiBwb2xpY3kgYXBwbGllcy4gU3VwcG9ydGVkIGFuY2hvcnM6XG4gICAgICogYGxhc3RfYWN0aXZlX2F0YC5cbiAgICAgKi9cbiAgICBhbmNob3I6ICdsYXN0X2FjdGl2ZV9hdCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRheXMgYWZ0ZXIgdGhlIGFuY2hvciB0aW1lIHRoYXQgdGhlIHZlY3RvciBzdG9yZSB3aWxsIGV4cGlyZS5cbiAgICAgKi9cbiAgICBkYXlzOiBudW1iZXI7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZVVwZGF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgZXhwaXJhdGlvbiBwb2xpY3kgZm9yIGEgdmVjdG9yIHN0b3JlLlxuICAgKi9cbiAgZXhwaXJlc19hZnRlcj86IFZlY3RvclN0b3JlVXBkYXRlUGFyYW1zLkV4cGlyZXNBZnRlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBWZWN0b3JTdG9yZVVwZGF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgZXhwaXJhdGlvbiBwb2xpY3kgZm9yIGEgdmVjdG9yIHN0b3JlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBFeHBpcmVzQWZ0ZXIge1xuICAgIC8qKlxuICAgICAqIEFuY2hvciB0aW1lc3RhbXAgYWZ0ZXIgd2hpY2ggdGhlIGV4cGlyYXRpb24gcG9saWN5IGFwcGxpZXMuIFN1cHBvcnRlZCBhbmNob3JzOlxuICAgICAqIGBsYXN0X2FjdGl2ZV9hdGAuXG4gICAgICovXG4gICAgYW5jaG9yOiAnbGFzdF9hY3RpdmVfYXQnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBkYXlzIGFmdGVyIHRoZSBhbmNob3IgdGltZSB0aGF0IHRoZSB2ZWN0b3Igc3RvcmUgd2lsbCBleHBpcmUuXG4gICAgICovXG4gICAgZGF5czogbnVtYmVyO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmVMaXN0UGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIGN1cnNvciBmb3IgdXNlIGluIHBhZ2luYXRpb24uIGBiZWZvcmVgIGlzIGFuIG9iamVjdCBJRCB0aGF0IGRlZmluZXMgeW91ciBwbGFjZVxuICAgKiBpbiB0aGUgbGlzdC4gRm9yIGluc3RhbmNlLCBpZiB5b3UgbWFrZSBhIGxpc3QgcmVxdWVzdCBhbmQgcmVjZWl2ZSAxMDAgb2JqZWN0cyxcbiAgICogc3RhcnRpbmcgd2l0aCBvYmpfZm9vLCB5b3VyIHN1YnNlcXVlbnQgY2FsbCBjYW4gaW5jbHVkZSBiZWZvcmU9b2JqX2ZvbyBpbiBvcmRlclxuICAgKiB0byBmZXRjaCB0aGUgcHJldmlvdXMgcGFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGJlZm9yZT86IHN0cmluZztcblxuICAvKipcbiAgICogU29ydCBvcmRlciBieSB0aGUgYGNyZWF0ZWRfYXRgIHRpbWVzdGFtcCBvZiB0aGUgb2JqZWN0cy4gYGFzY2AgZm9yIGFzY2VuZGluZ1xuICAgKiBvcmRlciBhbmQgYGRlc2NgIGZvciBkZXNjZW5kaW5nIG9yZGVyLlxuICAgKi9cbiAgb3JkZXI/OiAnYXNjJyB8ICdkZXNjJztcbn1cblxuVmVjdG9yU3RvcmVzLlZlY3RvclN0b3Jlc1BhZ2UgPSBWZWN0b3JTdG9yZXNQYWdlO1xuVmVjdG9yU3RvcmVzLkZpbGVzID0gRmlsZXM7XG5WZWN0b3JTdG9yZXMuVmVjdG9yU3RvcmVGaWxlc1BhZ2UgPSBWZWN0b3JTdG9yZUZpbGVzUGFnZTtcblZlY3RvclN0b3Jlcy5GaWxlQmF0Y2hlcyA9IEZpbGVCYXRjaGVzO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVmVjdG9yU3RvcmVzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIEF1dG9GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtIGFzIEF1dG9GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtLFxuICAgIHR5cGUgRmlsZUNodW5raW5nU3RyYXRlZ3kgYXMgRmlsZUNodW5raW5nU3RyYXRlZ3ksXG4gICAgdHlwZSBGaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtIGFzIEZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0sXG4gICAgdHlwZSBPdGhlckZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0IGFzIE90aGVyRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QsXG4gICAgdHlwZSBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneSBhcyBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneSxcbiAgICB0eXBlIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0IGFzIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0LFxuICAgIHR5cGUgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3RQYXJhbSBhcyBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdFBhcmFtLFxuICAgIHR5cGUgVmVjdG9yU3RvcmUgYXMgVmVjdG9yU3RvcmUsXG4gICAgdHlwZSBWZWN0b3JTdG9yZURlbGV0ZWQgYXMgVmVjdG9yU3RvcmVEZWxldGVkLFxuICAgIFZlY3RvclN0b3Jlc1BhZ2UgYXMgVmVjdG9yU3RvcmVzUGFnZSxcbiAgICB0eXBlIFZlY3RvclN0b3JlQ3JlYXRlUGFyYW1zIGFzIFZlY3RvclN0b3JlQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgVmVjdG9yU3RvcmVVcGRhdGVQYXJhbXMgYXMgVmVjdG9yU3RvcmVVcGRhdGVQYXJhbXMsXG4gICAgdHlwZSBWZWN0b3JTdG9yZUxpc3RQYXJhbXMgYXMgVmVjdG9yU3RvcmVMaXN0UGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgRmlsZXMgYXMgRmlsZXMsXG4gICAgdHlwZSBWZWN0b3JTdG9yZUZpbGUgYXMgVmVjdG9yU3RvcmVGaWxlLFxuICAgIHR5cGUgVmVjdG9yU3RvcmVGaWxlRGVsZXRlZCBhcyBWZWN0b3JTdG9yZUZpbGVEZWxldGVkLFxuICAgIFZlY3RvclN0b3JlRmlsZXNQYWdlIGFzIFZlY3RvclN0b3JlRmlsZXNQYWdlLFxuICAgIHR5cGUgRmlsZUNyZWF0ZVBhcmFtcyBhcyBGaWxlQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgRmlsZUxpc3RQYXJhbXMgYXMgRmlsZUxpc3RQYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHtcbiAgICBGaWxlQmF0Y2hlcyBhcyBGaWxlQmF0Y2hlcyxcbiAgICB0eXBlIFZlY3RvclN0b3JlRmlsZUJhdGNoIGFzIFZlY3RvclN0b3JlRmlsZUJhdGNoLFxuICAgIHR5cGUgRmlsZUJhdGNoQ3JlYXRlUGFyYW1zIGFzIEZpbGVCYXRjaENyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIEZpbGVCYXRjaExpc3RGaWxlc1BhcmFtcyBhcyBGaWxlQmF0Y2hMaXN0RmlsZXNQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBBc3Npc3RhbnRzQVBJIGZyb20gJy4vYXNzaXN0YW50cyc7XG5pbXBvcnQgKiBhcyBDaGF0QVBJIGZyb20gJy4vY2hhdC9jaGF0JztcbmltcG9ydCB7XG4gIEFzc2lzdGFudCxcbiAgQXNzaXN0YW50Q3JlYXRlUGFyYW1zLFxuICBBc3Npc3RhbnREZWxldGVkLFxuICBBc3Npc3RhbnRMaXN0UGFyYW1zLFxuICBBc3Npc3RhbnRTdHJlYW1FdmVudCxcbiAgQXNzaXN0YW50VG9vbCxcbiAgQXNzaXN0YW50VXBkYXRlUGFyYW1zLFxuICBBc3Npc3RhbnRzLFxuICBBc3Npc3RhbnRzUGFnZSxcbiAgQ29kZUludGVycHJldGVyVG9vbCxcbiAgRmlsZVNlYXJjaFRvb2wsXG4gIEZ1bmN0aW9uVG9vbCxcbiAgTWVzc2FnZVN0cmVhbUV2ZW50LFxuICBSdW5TdGVwU3RyZWFtRXZlbnQsXG4gIFJ1blN0cmVhbUV2ZW50LFxuICBUaHJlYWRTdHJlYW1FdmVudCxcbn0gZnJvbSAnLi9hc3Npc3RhbnRzJztcbmltcG9ydCAqIGFzIFJlYWx0aW1lQVBJIGZyb20gJy4vcmVhbHRpbWUvcmVhbHRpbWUnO1xuaW1wb3J0IHsgUmVhbHRpbWUgfSBmcm9tICcuL3JlYWx0aW1lL3JlYWx0aW1lJztcbmltcG9ydCAqIGFzIFRocmVhZHNBUEkgZnJvbSAnLi90aHJlYWRzL3RocmVhZHMnO1xuaW1wb3J0IHtcbiAgQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24sXG4gIEFzc2lzdGFudFRvb2xDaG9pY2UsXG4gIEFzc2lzdGFudFRvb2xDaG9pY2VGdW5jdGlvbixcbiAgQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbixcbiAgVGhyZWFkLFxuICBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXMsXG4gIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc05vblN0cmVhbWluZyxcbiAgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zU3RyZWFtaW5nLFxuICBUaHJlYWRDcmVhdGVBbmRSdW5Qb2xsUGFyYW1zLFxuICBUaHJlYWRDcmVhdGVBbmRSdW5TdHJlYW1QYXJhbXMsXG4gIFRocmVhZENyZWF0ZVBhcmFtcyxcbiAgVGhyZWFkRGVsZXRlZCxcbiAgVGhyZWFkVXBkYXRlUGFyYW1zLFxuICBUaHJlYWRzLFxufSBmcm9tICcuL3RocmVhZHMvdGhyZWFkcyc7XG5pbXBvcnQgKiBhcyBWZWN0b3JTdG9yZXNBUEkgZnJvbSAnLi92ZWN0b3Itc3RvcmVzL3ZlY3Rvci1zdG9yZXMnO1xuaW1wb3J0IHtcbiAgQXV0b0ZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0sXG4gIEZpbGVDaHVua2luZ1N0cmF0ZWd5LFxuICBGaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtLFxuICBPdGhlckZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0LFxuICBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneSxcbiAgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QsXG4gIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0UGFyYW0sXG4gIFZlY3RvclN0b3JlLFxuICBWZWN0b3JTdG9yZUNyZWF0ZVBhcmFtcyxcbiAgVmVjdG9yU3RvcmVEZWxldGVkLFxuICBWZWN0b3JTdG9yZUxpc3RQYXJhbXMsXG4gIFZlY3RvclN0b3JlVXBkYXRlUGFyYW1zLFxuICBWZWN0b3JTdG9yZXMsXG4gIFZlY3RvclN0b3Jlc1BhZ2UsXG59IGZyb20gJy4vdmVjdG9yLXN0b3Jlcy92ZWN0b3Itc3RvcmVzJztcbmltcG9ydCB7IENoYXQgfSBmcm9tICcuL2NoYXQvY2hhdCc7XG5cbmV4cG9ydCBjbGFzcyBCZXRhIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICByZWFsdGltZTogUmVhbHRpbWVBUEkuUmVhbHRpbWUgPSBuZXcgUmVhbHRpbWVBUEkuUmVhbHRpbWUodGhpcy5fY2xpZW50KTtcbiAgdmVjdG9yU3RvcmVzOiBWZWN0b3JTdG9yZXNBUEkuVmVjdG9yU3RvcmVzID0gbmV3IFZlY3RvclN0b3Jlc0FQSS5WZWN0b3JTdG9yZXModGhpcy5fY2xpZW50KTtcbiAgY2hhdDogQ2hhdEFQSS5DaGF0ID0gbmV3IENoYXRBUEkuQ2hhdCh0aGlzLl9jbGllbnQpO1xuICBhc3Npc3RhbnRzOiBBc3Npc3RhbnRzQVBJLkFzc2lzdGFudHMgPSBuZXcgQXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRzKHRoaXMuX2NsaWVudCk7XG4gIHRocmVhZHM6IFRocmVhZHNBUEkuVGhyZWFkcyA9IG5ldyBUaHJlYWRzQVBJLlRocmVhZHModGhpcy5fY2xpZW50KTtcbn1cblxuQmV0YS5SZWFsdGltZSA9IFJlYWx0aW1lO1xuQmV0YS5WZWN0b3JTdG9yZXMgPSBWZWN0b3JTdG9yZXM7XG5CZXRhLlZlY3RvclN0b3Jlc1BhZ2UgPSBWZWN0b3JTdG9yZXNQYWdlO1xuQmV0YS5Bc3Npc3RhbnRzID0gQXNzaXN0YW50cztcbkJldGEuQXNzaXN0YW50c1BhZ2UgPSBBc3Npc3RhbnRzUGFnZTtcbkJldGEuVGhyZWFkcyA9IFRocmVhZHM7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBCZXRhIHtcbiAgZXhwb3J0IHsgUmVhbHRpbWUgYXMgUmVhbHRpbWUgfTtcblxuICBleHBvcnQge1xuICAgIFZlY3RvclN0b3JlcyBhcyBWZWN0b3JTdG9yZXMsXG4gICAgdHlwZSBBdXRvRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbSBhcyBBdXRvRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbSxcbiAgICB0eXBlIEZpbGVDaHVua2luZ1N0cmF0ZWd5IGFzIEZpbGVDaHVua2luZ1N0cmF0ZWd5LFxuICAgIHR5cGUgRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbSBhcyBGaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtLFxuICAgIHR5cGUgT3RoZXJGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdCBhcyBPdGhlckZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0LFxuICAgIHR5cGUgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3kgYXMgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3ksXG4gICAgdHlwZSBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdCBhcyBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdCxcbiAgICB0eXBlIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0UGFyYW0gYXMgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3RQYXJhbSxcbiAgICB0eXBlIFZlY3RvclN0b3JlIGFzIFZlY3RvclN0b3JlLFxuICAgIHR5cGUgVmVjdG9yU3RvcmVEZWxldGVkIGFzIFZlY3RvclN0b3JlRGVsZXRlZCxcbiAgICBWZWN0b3JTdG9yZXNQYWdlIGFzIFZlY3RvclN0b3Jlc1BhZ2UsXG4gICAgdHlwZSBWZWN0b3JTdG9yZUNyZWF0ZVBhcmFtcyBhcyBWZWN0b3JTdG9yZUNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIFZlY3RvclN0b3JlVXBkYXRlUGFyYW1zIGFzIFZlY3RvclN0b3JlVXBkYXRlUGFyYW1zLFxuICAgIHR5cGUgVmVjdG9yU3RvcmVMaXN0UGFyYW1zIGFzIFZlY3RvclN0b3JlTGlzdFBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQgeyBDaGF0IH07XG5cbiAgZXhwb3J0IHtcbiAgICBBc3Npc3RhbnRzIGFzIEFzc2lzdGFudHMsXG4gICAgdHlwZSBBc3Npc3RhbnQgYXMgQXNzaXN0YW50LFxuICAgIHR5cGUgQXNzaXN0YW50RGVsZXRlZCBhcyBBc3Npc3RhbnREZWxldGVkLFxuICAgIHR5cGUgQXNzaXN0YW50U3RyZWFtRXZlbnQgYXMgQXNzaXN0YW50U3RyZWFtRXZlbnQsXG4gICAgdHlwZSBBc3Npc3RhbnRUb29sIGFzIEFzc2lzdGFudFRvb2wsXG4gICAgdHlwZSBDb2RlSW50ZXJwcmV0ZXJUb29sIGFzIENvZGVJbnRlcnByZXRlclRvb2wsXG4gICAgdHlwZSBGaWxlU2VhcmNoVG9vbCBhcyBGaWxlU2VhcmNoVG9vbCxcbiAgICB0eXBlIEZ1bmN0aW9uVG9vbCBhcyBGdW5jdGlvblRvb2wsXG4gICAgdHlwZSBNZXNzYWdlU3RyZWFtRXZlbnQgYXMgTWVzc2FnZVN0cmVhbUV2ZW50LFxuICAgIHR5cGUgUnVuU3RlcFN0cmVhbUV2ZW50IGFzIFJ1blN0ZXBTdHJlYW1FdmVudCxcbiAgICB0eXBlIFJ1blN0cmVhbUV2ZW50IGFzIFJ1blN0cmVhbUV2ZW50LFxuICAgIHR5cGUgVGhyZWFkU3RyZWFtRXZlbnQgYXMgVGhyZWFkU3RyZWFtRXZlbnQsXG4gICAgQXNzaXN0YW50c1BhZ2UgYXMgQXNzaXN0YW50c1BhZ2UsXG4gICAgdHlwZSBBc3Npc3RhbnRDcmVhdGVQYXJhbXMgYXMgQXNzaXN0YW50Q3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgQXNzaXN0YW50VXBkYXRlUGFyYW1zIGFzIEFzc2lzdGFudFVwZGF0ZVBhcmFtcyxcbiAgICB0eXBlIEFzc2lzdGFudExpc3RQYXJhbXMgYXMgQXNzaXN0YW50TGlzdFBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIFRocmVhZHMgYXMgVGhyZWFkcyxcbiAgICB0eXBlIEFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIGFzIEFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uLFxuICAgIHR5cGUgQXNzaXN0YW50VG9vbENob2ljZSBhcyBBc3Npc3RhbnRUb29sQ2hvaWNlLFxuICAgIHR5cGUgQXNzaXN0YW50VG9vbENob2ljZUZ1bmN0aW9uIGFzIEFzc2lzdGFudFRvb2xDaG9pY2VGdW5jdGlvbixcbiAgICB0eXBlIEFzc2lzdGFudFRvb2xDaG9pY2VPcHRpb24gYXMgQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbixcbiAgICB0eXBlIFRocmVhZCBhcyBUaHJlYWQsXG4gICAgdHlwZSBUaHJlYWREZWxldGVkIGFzIFRocmVhZERlbGV0ZWQsXG4gICAgdHlwZSBUaHJlYWRDcmVhdGVQYXJhbXMgYXMgVGhyZWFkQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgVGhyZWFkVXBkYXRlUGFyYW1zIGFzIFRocmVhZFVwZGF0ZVBhcmFtcyxcbiAgICB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtcyBhcyBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXMsXG4gICAgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNOb25TdHJlYW1pbmcgYXMgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zU3RyZWFtaW5nIGFzIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc1N0cmVhbWluZyxcbiAgICB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blBvbGxQYXJhbXMsXG4gICAgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5TdHJlYW1QYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBBUElQcm9taXNlIH0gZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29tcGxldGlvbnNBUEkgZnJvbSAnLi9jb21wbGV0aW9ucyc7XG5pbXBvcnQgKiBhcyBDaGF0Q29tcGxldGlvbnNBUEkgZnJvbSAnLi9jaGF0L2NvbXBsZXRpb25zJztcbmltcG9ydCB7IFN0cmVhbSB9IGZyb20gJy4uL3N0cmVhbWluZyc7XG5cbmV4cG9ydCBjbGFzcyBDb21wbGV0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21wbGV0aW9uIGZvciB0aGUgcHJvdmlkZWQgcHJvbXB0IGFuZCBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgY3JlYXRlKGJvZHk6IENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQVBJUHJvbWlzZTxDb21wbGV0aW9uPjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8U3RyZWFtPENvbXBsZXRpb24+PjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxDb21wbGV0aW9uPiB8IENvbXBsZXRpb24+O1xuICBjcmVhdGUoXG4gICAgYm9keTogQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxDb21wbGV0aW9uPiB8IEFQSVByb21pc2U8U3RyZWFtPENvbXBsZXRpb24+PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvY29tcGxldGlvbnMnLCB7IGJvZHksIC4uLm9wdGlvbnMsIHN0cmVhbTogYm9keS5zdHJlYW0gPz8gZmFsc2UgfSkgYXNcbiAgICAgIHwgQVBJUHJvbWlzZTxDb21wbGV0aW9uPlxuICAgICAgfCBBUElQcm9taXNlPFN0cmVhbTxDb21wbGV0aW9uPj47XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29tcGxldGlvbiByZXNwb25zZSBmcm9tIHRoZSBBUEkuIE5vdGU6IGJvdGggdGhlIHN0cmVhbWVkIGFuZFxuICogbm9uLXN0cmVhbWVkIHJlc3BvbnNlIG9iamVjdHMgc2hhcmUgdGhlIHNhbWUgc2hhcGUgKHVubGlrZSB0aGUgY2hhdCBlbmRwb2ludCkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvbiB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY29tcGxldGlvbi5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIGNvbXBsZXRpb24gY2hvaWNlcyB0aGUgbW9kZWwgZ2VuZXJhdGVkIGZvciB0aGUgaW5wdXQgcHJvbXB0LlxuICAgKi9cbiAgY2hvaWNlczogQXJyYXk8Q29tcGxldGlvbkNob2ljZT47XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgb2Ygd2hlbiB0aGUgY29tcGxldGlvbiB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHVzZWQgZm9yIGNvbXBsZXRpb24uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcInRleHRfY29tcGxldGlvblwiXG4gICAqL1xuICBvYmplY3Q6ICd0ZXh0X2NvbXBsZXRpb24nO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZpbmdlcnByaW50IHJlcHJlc2VudHMgdGhlIGJhY2tlbmQgY29uZmlndXJhdGlvbiB0aGF0IHRoZSBtb2RlbCBydW5zIHdpdGguXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGBzZWVkYCByZXF1ZXN0IHBhcmFtZXRlciB0byB1bmRlcnN0YW5kIHdoZW5cbiAgICogYmFja2VuZCBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlIHRoYXQgbWlnaHQgaW1wYWN0IGRldGVybWluaXNtLlxuICAgKi9cbiAgc3lzdGVtX2ZpbmdlcnByaW50Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBVc2FnZSBzdGF0aXN0aWNzIGZvciB0aGUgY29tcGxldGlvbiByZXF1ZXN0LlxuICAgKi9cbiAgdXNhZ2U/OiBDb21wbGV0aW9uVXNhZ2U7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvbkNob2ljZSB7XG4gIC8qKlxuICAgKiBUaGUgcmVhc29uIHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLiBUaGlzIHdpbGwgYmUgYHN0b3BgIGlmIHRoZSBtb2RlbFxuICAgKiBoaXQgYSBuYXR1cmFsIHN0b3AgcG9pbnQgb3IgYSBwcm92aWRlZCBzdG9wIHNlcXVlbmNlLCBgbGVuZ3RoYCBpZiB0aGUgbWF4aW11bVxuICAgKiBudW1iZXIgb2YgdG9rZW5zIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdCB3YXMgcmVhY2hlZCwgb3IgYGNvbnRlbnRfZmlsdGVyYCBpZlxuICAgKiBjb250ZW50IHdhcyBvbWl0dGVkIGR1ZSB0byBhIGZsYWcgZnJvbSBvdXIgY29udGVudCBmaWx0ZXJzLlxuICAgKi9cbiAgZmluaXNoX3JlYXNvbjogJ3N0b3AnIHwgJ2xlbmd0aCcgfCAnY29udGVudF9maWx0ZXInO1xuXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgbG9ncHJvYnM6IENvbXBsZXRpb25DaG9pY2UuTG9ncHJvYnMgfCBudWxsO1xuXG4gIHRleHQ6IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDb21wbGV0aW9uQ2hvaWNlIHtcbiAgZXhwb3J0IGludGVyZmFjZSBMb2dwcm9icyB7XG4gICAgdGV4dF9vZmZzZXQ/OiBBcnJheTxudW1iZXI+O1xuXG4gICAgdG9rZW5fbG9ncHJvYnM/OiBBcnJheTxudW1iZXI+O1xuXG4gICAgdG9rZW5zPzogQXJyYXk8c3RyaW5nPjtcblxuICAgIHRvcF9sb2dwcm9icz86IEFycmF5PFJlY29yZDxzdHJpbmcsIG51bWJlcj4+O1xuICB9XG59XG5cbi8qKlxuICogVXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIGNvbXBsZXRpb24gcmVxdWVzdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uVXNhZ2Uge1xuICAvKipcbiAgICogTnVtYmVyIG9mIHRva2VucyBpbiB0aGUgZ2VuZXJhdGVkIGNvbXBsZXRpb24uXG4gICAqL1xuICBjb21wbGV0aW9uX3Rva2VuczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgdG9rZW5zIGluIHRoZSBwcm9tcHQuXG4gICAqL1xuICBwcm9tcHRfdG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRvdGFsIG51bWJlciBvZiB0b2tlbnMgdXNlZCBpbiB0aGUgcmVxdWVzdCAocHJvbXB0ICsgY29tcGxldGlvbikuXG4gICAqL1xuICB0b3RhbF90b2tlbnM6IG51bWJlcjtcblxuICAvKipcbiAgICogQnJlYWtkb3duIG9mIHRva2VucyB1c2VkIGluIGEgY29tcGxldGlvbi5cbiAgICovXG4gIGNvbXBsZXRpb25fdG9rZW5zX2RldGFpbHM/OiBDb21wbGV0aW9uVXNhZ2UuQ29tcGxldGlvblRva2Vuc0RldGFpbHM7XG5cbiAgLyoqXG4gICAqIEJyZWFrZG93biBvZiB0b2tlbnMgdXNlZCBpbiB0aGUgcHJvbXB0LlxuICAgKi9cbiAgcHJvbXB0X3Rva2Vuc19kZXRhaWxzPzogQ29tcGxldGlvblVzYWdlLlByb21wdFRva2Vuc0RldGFpbHM7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29tcGxldGlvblVzYWdlIHtcbiAgLyoqXG4gICAqIEJyZWFrZG93biBvZiB0b2tlbnMgdXNlZCBpbiBhIGNvbXBsZXRpb24uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25Ub2tlbnNEZXRhaWxzIHtcbiAgICAvKipcbiAgICAgKiBXaGVuIHVzaW5nIFByZWRpY3RlZCBPdXRwdXRzLCB0aGUgbnVtYmVyIG9mIHRva2VucyBpbiB0aGUgcHJlZGljdGlvbiB0aGF0XG4gICAgICogYXBwZWFyZWQgaW4gdGhlIGNvbXBsZXRpb24uXG4gICAgICovXG4gICAgYWNjZXB0ZWRfcHJlZGljdGlvbl90b2tlbnM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBBdWRpbyBpbnB1dCB0b2tlbnMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBhdWRpb190b2tlbnM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUb2tlbnMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBmb3IgcmVhc29uaW5nLlxuICAgICAqL1xuICAgIHJlYXNvbmluZ190b2tlbnM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzaW5nIFByZWRpY3RlZCBPdXRwdXRzLCB0aGUgbnVtYmVyIG9mIHRva2VucyBpbiB0aGUgcHJlZGljdGlvbiB0aGF0IGRpZFxuICAgICAqIG5vdCBhcHBlYXIgaW4gdGhlIGNvbXBsZXRpb24uIEhvd2V2ZXIsIGxpa2UgcmVhc29uaW5nIHRva2VucywgdGhlc2UgdG9rZW5zIGFyZVxuICAgICAqIHN0aWxsIGNvdW50ZWQgaW4gdGhlIHRvdGFsIGNvbXBsZXRpb24gdG9rZW5zIGZvciBwdXJwb3NlcyBvZiBiaWxsaW5nLCBvdXRwdXQsXG4gICAgICogYW5kIGNvbnRleHQgd2luZG93IGxpbWl0cy5cbiAgICAgKi9cbiAgICByZWplY3RlZF9wcmVkaWN0aW9uX3Rva2Vucz86IG51bWJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCcmVha2Rvd24gb2YgdG9rZW5zIHVzZWQgaW4gdGhlIHByb21wdC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvbXB0VG9rZW5zRGV0YWlscyB7XG4gICAgLyoqXG4gICAgICogQXVkaW8gaW5wdXQgdG9rZW5zIHByZXNlbnQgaW4gdGhlIHByb21wdC5cbiAgICAgKi9cbiAgICBhdWRpb190b2tlbnM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgdG9rZW5zIHByZXNlbnQgaW4gdGhlIHByb21wdC5cbiAgICAgKi9cbiAgICBjYWNoZWRfdG9rZW5zPzogbnVtYmVyO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXMgPSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIHwgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcblxuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBZb3UgY2FuIHVzZSB0aGVcbiAgICogW0xpc3QgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscy9saXN0KSBBUEkgdG9cbiAgICogc2VlIGFsbCBvZiB5b3VyIGF2YWlsYWJsZSBtb2RlbHMsIG9yIHNlZSBvdXJcbiAgICogW01vZGVsIG92ZXJ2aWV3XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMpIGZvciBkZXNjcmlwdGlvbnMgb2ZcbiAgICogdGhlbS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgJ2dwdC0zLjUtdHVyYm8taW5zdHJ1Y3QnIHwgJ2RhdmluY2ktMDAyJyB8ICdiYWJiYWdlLTAwMic7XG5cbiAgLyoqXG4gICAqIFRoZSBwcm9tcHQocykgdG8gZ2VuZXJhdGUgY29tcGxldGlvbnMgZm9yLCBlbmNvZGVkIGFzIGEgc3RyaW5nLCBhcnJheSBvZlxuICAgKiBzdHJpbmdzLCBhcnJheSBvZiB0b2tlbnMsIG9yIGFycmF5IG9mIHRva2VuIGFycmF5cy5cbiAgICpcbiAgICogTm90ZSB0aGF0IDx8ZW5kb2Z0ZXh0fD4gaXMgdGhlIGRvY3VtZW50IHNlcGFyYXRvciB0aGF0IHRoZSBtb2RlbCBzZWVzIGR1cmluZ1xuICAgKiB0cmFpbmluZywgc28gaWYgYSBwcm9tcHQgaXMgbm90IHNwZWNpZmllZCB0aGUgbW9kZWwgd2lsbCBnZW5lcmF0ZSBhcyBpZiBmcm9tIHRoZVxuICAgKiBiZWdpbm5pbmcgb2YgYSBuZXcgZG9jdW1lbnQuXG4gICAqL1xuICBwcm9tcHQ6IHN0cmluZyB8IEFycmF5PHN0cmluZz4gfCBBcnJheTxudW1iZXI+IHwgQXJyYXk8QXJyYXk8bnVtYmVyPj4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYGJlc3Rfb2ZgIGNvbXBsZXRpb25zIHNlcnZlci1zaWRlIGFuZCByZXR1cm5zIHRoZSBcImJlc3RcIiAodGhlIG9uZSB3aXRoXG4gICAqIHRoZSBoaWdoZXN0IGxvZyBwcm9iYWJpbGl0eSBwZXIgdG9rZW4pLiBSZXN1bHRzIGNhbm5vdCBiZSBzdHJlYW1lZC5cbiAgICpcbiAgICogV2hlbiB1c2VkIHdpdGggYG5gLCBgYmVzdF9vZmAgY29udHJvbHMgdGhlIG51bWJlciBvZiBjYW5kaWRhdGUgY29tcGxldGlvbnMgYW5kXG4gICAqIGBuYCBzcGVjaWZpZXMgaG93IG1hbnkgdG8gcmV0dXJuIFx1MjAxMyBgYmVzdF9vZmAgbXVzdCBiZSBncmVhdGVyIHRoYW4gYG5gLlxuICAgKlxuICAgKiAqKk5vdGU6KiogQmVjYXVzZSB0aGlzIHBhcmFtZXRlciBnZW5lcmF0ZXMgbWFueSBjb21wbGV0aW9ucywgaXQgY2FuIHF1aWNrbHlcbiAgICogY29uc3VtZSB5b3VyIHRva2VuIHF1b3RhLiBVc2UgY2FyZWZ1bGx5IGFuZCBlbnN1cmUgdGhhdCB5b3UgaGF2ZSByZWFzb25hYmxlXG4gICAqIHNldHRpbmdzIGZvciBgbWF4X3Rva2Vuc2AgYW5kIGBzdG9wYC5cbiAgICovXG4gIGJlc3Rfb2Y/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBFY2hvIGJhY2sgdGhlIHByb21wdCBpbiBhZGRpdGlvbiB0byB0aGUgY29tcGxldGlvblxuICAgKi9cbiAgZWNobz86IGJvb2xlYW4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgYmV0d2VlbiAtMi4wIGFuZCAyLjAuIFBvc2l0aXZlIHZhbHVlcyBwZW5hbGl6ZSBuZXcgdG9rZW5zIGJhc2VkIG9uIHRoZWlyXG4gICAqIGV4aXN0aW5nIGZyZXF1ZW5jeSBpbiB0aGUgdGV4dCBzbyBmYXIsIGRlY3JlYXNpbmcgdGhlIG1vZGVsJ3MgbGlrZWxpaG9vZCB0b1xuICAgKiByZXBlYXQgdGhlIHNhbWUgbGluZSB2ZXJiYXRpbS5cbiAgICpcbiAgICogW1NlZSBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGZyZXF1ZW5jeSBhbmQgcHJlc2VuY2UgcGVuYWx0aWVzLl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3RleHQtZ2VuZXJhdGlvbilcbiAgICovXG4gIGZyZXF1ZW5jeV9wZW5hbHR5PzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogTW9kaWZ5IHRoZSBsaWtlbGlob29kIG9mIHNwZWNpZmllZCB0b2tlbnMgYXBwZWFyaW5nIGluIHRoZSBjb21wbGV0aW9uLlxuICAgKlxuICAgKiBBY2NlcHRzIGEgSlNPTiBvYmplY3QgdGhhdCBtYXBzIHRva2VucyAoc3BlY2lmaWVkIGJ5IHRoZWlyIHRva2VuIElEIGluIHRoZSBHUFRcbiAgICogdG9rZW5pemVyKSB0byBhbiBhc3NvY2lhdGVkIGJpYXMgdmFsdWUgZnJvbSAtMTAwIHRvIDEwMC4gWW91IGNhbiB1c2UgdGhpc1xuICAgKiBbdG9rZW5pemVyIHRvb2xdKC90b2tlbml6ZXI/dmlldz1icGUpIHRvIGNvbnZlcnQgdGV4dCB0byB0b2tlbiBJRHMuXG4gICAqIE1hdGhlbWF0aWNhbGx5LCB0aGUgYmlhcyBpcyBhZGRlZCB0byB0aGUgbG9naXRzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgcHJpb3IgdG9cbiAgICogc2FtcGxpbmcuIFRoZSBleGFjdCBlZmZlY3Qgd2lsbCB2YXJ5IHBlciBtb2RlbCwgYnV0IHZhbHVlcyBiZXR3ZWVuIC0xIGFuZCAxXG4gICAqIHNob3VsZCBkZWNyZWFzZSBvciBpbmNyZWFzZSBsaWtlbGlob29kIG9mIHNlbGVjdGlvbjsgdmFsdWVzIGxpa2UgLTEwMCBvciAxMDBcbiAgICogc2hvdWxkIHJlc3VsdCBpbiBhIGJhbiBvciBleGNsdXNpdmUgc2VsZWN0aW9uIG9mIHRoZSByZWxldmFudCB0b2tlbi5cbiAgICpcbiAgICogQXMgYW4gZXhhbXBsZSwgeW91IGNhbiBwYXNzIGB7XCI1MDI1NlwiOiAtMTAwfWAgdG8gcHJldmVudCB0aGUgPHxlbmRvZnRleHR8PiB0b2tlblxuICAgKiBmcm9tIGJlaW5nIGdlbmVyYXRlZC5cbiAgICovXG4gIGxvZ2l0X2JpYXM/OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IHwgbnVsbDtcblxuICAvKipcbiAgICogSW5jbHVkZSB0aGUgbG9nIHByb2JhYmlsaXRpZXMgb24gdGhlIGBsb2dwcm9ic2AgbW9zdCBsaWtlbHkgb3V0cHV0IHRva2VucywgYXNcbiAgICogd2VsbCB0aGUgY2hvc2VuIHRva2Vucy4gRm9yIGV4YW1wbGUsIGlmIGBsb2dwcm9ic2AgaXMgNSwgdGhlIEFQSSB3aWxsIHJldHVybiBhXG4gICAqIGxpc3Qgb2YgdGhlIDUgbW9zdCBsaWtlbHkgdG9rZW5zLiBUaGUgQVBJIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgYGxvZ3Byb2JgIG9mXG4gICAqIHRoZSBzYW1wbGVkIHRva2VuLCBzbyB0aGVyZSBtYXkgYmUgdXAgdG8gYGxvZ3Byb2JzKzFgIGVsZW1lbnRzIGluIHRoZSByZXNwb25zZS5cbiAgICpcbiAgICogVGhlIG1heGltdW0gdmFsdWUgZm9yIGBsb2dwcm9ic2AgaXMgNS5cbiAgICovXG4gIGxvZ3Byb2JzPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIFt0b2tlbnNdKC90b2tlbml6ZXIpIHRoYXQgY2FuIGJlIGdlbmVyYXRlZCBpbiB0aGVcbiAgICogY29tcGxldGlvbi5cbiAgICpcbiAgICogVGhlIHRva2VuIGNvdW50IG9mIHlvdXIgcHJvbXB0IHBsdXMgYG1heF90b2tlbnNgIGNhbm5vdCBleGNlZWQgdGhlIG1vZGVsJ3NcbiAgICogY29udGV4dCBsZW5ndGguXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2Nvb2tib29rLm9wZW5haS5jb20vZXhhbXBsZXMvaG93X3RvX2NvdW50X3Rva2Vuc193aXRoX3Rpa3Rva2VuKVxuICAgKiBmb3IgY291bnRpbmcgdG9rZW5zLlxuICAgKi9cbiAgbWF4X3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEhvdyBtYW55IGNvbXBsZXRpb25zIHRvIGdlbmVyYXRlIGZvciBlYWNoIHByb21wdC5cbiAgICpcbiAgICogKipOb3RlOioqIEJlY2F1c2UgdGhpcyBwYXJhbWV0ZXIgZ2VuZXJhdGVzIG1hbnkgY29tcGxldGlvbnMsIGl0IGNhbiBxdWlja2x5XG4gICAqIGNvbnN1bWUgeW91ciB0b2tlbiBxdW90YS4gVXNlIGNhcmVmdWxseSBhbmQgZW5zdXJlIHRoYXQgeW91IGhhdmUgcmVhc29uYWJsZVxuICAgKiBzZXR0aW5ncyBmb3IgYG1heF90b2tlbnNgIGFuZCBgc3RvcGAuXG4gICAqL1xuICBuPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogTnVtYmVyIGJldHdlZW4gLTIuMCBhbmQgMi4wLiBQb3NpdGl2ZSB2YWx1ZXMgcGVuYWxpemUgbmV3IHRva2VucyBiYXNlZCBvblxuICAgKiB3aGV0aGVyIHRoZXkgYXBwZWFyIGluIHRoZSB0ZXh0IHNvIGZhciwgaW5jcmVhc2luZyB0aGUgbW9kZWwncyBsaWtlbGlob29kIHRvXG4gICAqIHRhbGsgYWJvdXQgbmV3IHRvcGljcy5cbiAgICpcbiAgICogW1NlZSBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGZyZXF1ZW5jeSBhbmQgcHJlc2VuY2UgcGVuYWx0aWVzLl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3RleHQtZ2VuZXJhdGlvbilcbiAgICovXG4gIHByZXNlbmNlX3BlbmFsdHk/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJZiBzcGVjaWZpZWQsIG91ciBzeXN0ZW0gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gc2FtcGxlIGRldGVybWluaXN0aWNhbGx5LFxuICAgKiBzdWNoIHRoYXQgcmVwZWF0ZWQgcmVxdWVzdHMgd2l0aCB0aGUgc2FtZSBgc2VlZGAgYW5kIHBhcmFtZXRlcnMgc2hvdWxkIHJldHVyblxuICAgKiB0aGUgc2FtZSByZXN1bHQuXG4gICAqXG4gICAqIERldGVybWluaXNtIGlzIG5vdCBndWFyYW50ZWVkLCBhbmQgeW91IHNob3VsZCByZWZlciB0byB0aGUgYHN5c3RlbV9maW5nZXJwcmludGBcbiAgICogcmVzcG9uc2UgcGFyYW1ldGVyIHRvIG1vbml0b3IgY2hhbmdlcyBpbiB0aGUgYmFja2VuZC5cbiAgICovXG4gIHNlZWQ/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBVcCB0byA0IHNlcXVlbmNlcyB3aGVyZSB0aGUgQVBJIHdpbGwgc3RvcCBnZW5lcmF0aW5nIGZ1cnRoZXIgdG9rZW5zLiBUaGVcbiAgICogcmV0dXJuZWQgdGV4dCB3aWxsIG5vdCBjb250YWluIHRoZSBzdG9wIHNlcXVlbmNlLlxuICAgKi9cbiAgc3RvcD86IHN0cmluZyB8IG51bGwgfCBBcnJheTxzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN0cmVhbSBiYWNrIHBhcnRpYWwgcHJvZ3Jlc3MuIElmIHNldCwgdG9rZW5zIHdpbGwgYmUgc2VudCBhc1xuICAgKiBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLCB3aXRoIHRoZSBzdHJlYW0gdGVybWluYXRlZCBieSBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2Nvb2tib29rLm9wZW5haS5jb20vZXhhbXBsZXMvaG93X3RvX3N0cmVhbV9jb21wbGV0aW9ucykuXG4gICAqL1xuICBzdHJlYW0/OiBib29sZWFuIHwgbnVsbDtcblxuICAvKipcbiAgICogT3B0aW9ucyBmb3Igc3RyZWFtaW5nIHJlc3BvbnNlLiBPbmx5IHNldCB0aGlzIHdoZW4geW91IHNldCBgc3RyZWFtOiB0cnVlYC5cbiAgICovXG4gIHN0cmVhbV9vcHRpb25zPzogQ2hhdENvbXBsZXRpb25zQVBJLkNoYXRDb21wbGV0aW9uU3RyZWFtT3B0aW9ucyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzdWZmaXggdGhhdCBjb21lcyBhZnRlciBhIGNvbXBsZXRpb24gb2YgaW5zZXJ0ZWQgdGV4dC5cbiAgICpcbiAgICogVGhpcyBwYXJhbWV0ZXIgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGBncHQtMy41LXR1cmJvLWluc3RydWN0YC5cbiAgICovXG4gIHN1ZmZpeD86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoYXQgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdG8gdXNlLCBiZXR3ZWVuIDAgYW5kIDIuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbFxuICAgKiBtYWtlIHRoZSBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZVxuICAgKiBmb2N1c2VkIGFuZCBkZXRlcm1pbmlzdGljLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgYHRvcF9wYCBidXQgbm90IGJvdGguXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEFuIGFsdGVybmF0aXZlIHRvIHNhbXBsaW5nIHdpdGggdGVtcGVyYXR1cmUsIGNhbGxlZCBudWNsZXVzIHNhbXBsaW5nLCB3aGVyZSB0aGVcbiAgICogbW9kZWwgY29uc2lkZXJzIHRoZSByZXN1bHRzIG9mIHRoZSB0b2tlbnMgd2l0aCB0b3BfcCBwcm9iYWJpbGl0eSBtYXNzLiBTbyAwLjFcbiAgICogbWVhbnMgb25seSB0aGUgdG9rZW5zIGNvbXByaXNpbmcgdGhlIHRvcCAxMCUgcHJvYmFiaWxpdHkgbWFzcyBhcmUgY29uc2lkZXJlZC5cbiAgICpcbiAgICogV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIGB0ZW1wZXJhdHVyZWAgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdG9wX3A/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIHJlcHJlc2VudGluZyB5b3VyIGVuZC11c2VyLCB3aGljaCBjYW4gaGVscCBPcGVuQUkgdG8gbW9uaXRvclxuICAgKiBhbmQgZGV0ZWN0IGFidXNlLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3NhZmV0eS1iZXN0LXByYWN0aWNlcyNlbmQtdXNlci1pZHMpLlxuICAgKi9cbiAgdXNlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIHtcbiAgZXhwb3J0IHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyA9IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmc7XG4gIGV4cG9ydCB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSBDb21wbGV0aW9uc0FQSS5Db21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgZXh0ZW5kcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN0cmVhbSBiYWNrIHBhcnRpYWwgcHJvZ3Jlc3MuIElmIHNldCwgdG9rZW5zIHdpbGwgYmUgc2VudCBhc1xuICAgKiBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLCB3aXRoIHRoZSBzdHJlYW0gdGVybWluYXRlZCBieSBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2Nvb2tib29rLm9wZW5haS5jb20vZXhhbXBsZXMvaG93X3RvX3N0cmVhbV9jb21wbGV0aW9ucykuXG4gICAqL1xuICBzdHJlYW0/OiBmYWxzZSB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBleHRlbmRzIENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3RyZWFtIGJhY2sgcGFydGlhbCBwcm9ncmVzcy4gSWYgc2V0LCB0b2tlbnMgd2lsbCBiZSBzZW50IGFzXG4gICAqIGRhdGEtb25seVxuICAgKiBbc2VydmVyLXNlbnQgZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmVyLXNlbnRfZXZlbnRzL1VzaW5nX3NlcnZlci1zZW50X2V2ZW50cyNFdmVudF9zdHJlYW1fZm9ybWF0KVxuICAgKiBhcyB0aGV5IGJlY29tZSBhdmFpbGFibGUsIHdpdGggdGhlIHN0cmVhbSB0ZXJtaW5hdGVkIGJ5IGEgYGRhdGE6IFtET05FXWBcbiAgICogbWVzc2FnZS5cbiAgICogW0V4YW1wbGUgUHl0aG9uIGNvZGVdKGh0dHBzOi8vY29va2Jvb2sub3BlbmFpLmNvbS9leGFtcGxlcy9ob3dfdG9fc3RyZWFtX2NvbXBsZXRpb25zKS5cbiAgICovXG4gIHN0cmVhbTogdHJ1ZTtcbn1cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIENvbXBsZXRpb25zIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIENvbXBsZXRpb24gYXMgQ29tcGxldGlvbixcbiAgICB0eXBlIENvbXBsZXRpb25DaG9pY2UgYXMgQ29tcGxldGlvbkNob2ljZSxcbiAgICB0eXBlIENvbXBsZXRpb25Vc2FnZSBhcyBDb21wbGV0aW9uVXNhZ2UsXG4gICAgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIGFzIENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGFzIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGFzIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uL2NvcmUnO1xuXG5leHBvcnQgY2xhc3MgRW1iZWRkaW5ncyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZW1iZWRkaW5nIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGlucHV0IHRleHQuXG4gICAqL1xuICBjcmVhdGUoXG4gICAgYm9keTogRW1iZWRkaW5nQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8Q3JlYXRlRW1iZWRkaW5nUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9lbWJlZGRpbmdzJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlRW1iZWRkaW5nUmVzcG9uc2Uge1xuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgZW1iZWRkaW5ncyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgZGF0YTogQXJyYXk8RW1iZWRkaW5nPjtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIG1vZGVsIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGVtYmVkZGluZy5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwibGlzdFwiLlxuICAgKi9cbiAgb2JqZWN0OiAnbGlzdCc7XG5cbiAgLyoqXG4gICAqIFRoZSB1c2FnZSBpbmZvcm1hdGlvbiBmb3IgdGhlIHJlcXVlc3QuXG4gICAqL1xuICB1c2FnZTogQ3JlYXRlRW1iZWRkaW5nUmVzcG9uc2UuVXNhZ2U7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ3JlYXRlRW1iZWRkaW5nUmVzcG9uc2Uge1xuICAvKipcbiAgICogVGhlIHVzYWdlIGluZm9ybWF0aW9uIGZvciB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVXNhZ2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgdG9rZW5zIHVzZWQgYnkgdGhlIHByb21wdC5cbiAgICAgKi9cbiAgICBwcm9tcHRfdG9rZW5zOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIHRva2VucyB1c2VkIGJ5IHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIHRvdGFsX3Rva2VuczogbnVtYmVyO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBlbWJlZGRpbmcgdmVjdG9yIHJldHVybmVkIGJ5IGVtYmVkZGluZyBlbmRwb2ludC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbWJlZGRpbmcge1xuICAvKipcbiAgICogVGhlIGVtYmVkZGluZyB2ZWN0b3IsIHdoaWNoIGlzIGEgbGlzdCBvZiBmbG9hdHMuIFRoZSBsZW5ndGggb2YgdmVjdG9yIGRlcGVuZHMgb25cbiAgICogdGhlIG1vZGVsIGFzIGxpc3RlZCBpbiB0aGVcbiAgICogW2VtYmVkZGluZyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2VtYmVkZGluZ3MpLlxuICAgKi9cbiAgZW1iZWRkaW5nOiBBcnJheTxudW1iZXI+O1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGVtYmVkZGluZyBpbiB0aGUgbGlzdCBvZiBlbWJlZGRpbmdzLlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgXCJlbWJlZGRpbmdcIi5cbiAgICovXG4gIG9iamVjdDogJ2VtYmVkZGluZyc7XG59XG5cbmV4cG9ydCB0eXBlIEVtYmVkZGluZ01vZGVsID0gJ3RleHQtZW1iZWRkaW5nLWFkYS0wMDInIHwgJ3RleHQtZW1iZWRkaW5nLTMtc21hbGwnIHwgJ3RleHQtZW1iZWRkaW5nLTMtbGFyZ2UnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEVtYmVkZGluZ0NyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBJbnB1dCB0ZXh0IHRvIGVtYmVkLCBlbmNvZGVkIGFzIGEgc3RyaW5nIG9yIGFycmF5IG9mIHRva2Vucy4gVG8gZW1iZWQgbXVsdGlwbGVcbiAgICogaW5wdXRzIGluIGEgc2luZ2xlIHJlcXVlc3QsIHBhc3MgYW4gYXJyYXkgb2Ygc3RyaW5ncyBvciBhcnJheSBvZiB0b2tlbiBhcnJheXMuXG4gICAqIFRoZSBpbnB1dCBtdXN0IG5vdCBleGNlZWQgdGhlIG1heCBpbnB1dCB0b2tlbnMgZm9yIHRoZSBtb2RlbCAoODE5MiB0b2tlbnMgZm9yXG4gICAqIGB0ZXh0LWVtYmVkZGluZy1hZGEtMDAyYCksIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmcsIGFuZCBhbnkgYXJyYXkgbXVzdCBiZSAyMDQ4XG4gICAqIGRpbWVuc2lvbnMgb3IgbGVzcy5cbiAgICogW0V4YW1wbGUgUHl0aG9uIGNvZGVdKGh0dHBzOi8vY29va2Jvb2sub3BlbmFpLmNvbS9leGFtcGxlcy9ob3dfdG9fY291bnRfdG9rZW5zX3dpdGhfdGlrdG9rZW4pXG4gICAqIGZvciBjb3VudGluZyB0b2tlbnMuXG4gICAqL1xuICBpbnB1dDogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPiB8IEFycmF5PG51bWJlcj4gfCBBcnJheTxBcnJheTxudW1iZXI+PjtcblxuICAvKipcbiAgICogSUQgb2YgdGhlIG1vZGVsIHRvIHVzZS4gWW91IGNhbiB1c2UgdGhlXG4gICAqIFtMaXN0IG1vZGVsc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tb2RlbHMvbGlzdCkgQVBJIHRvXG4gICAqIHNlZSBhbGwgb2YgeW91ciBhdmFpbGFibGUgbW9kZWxzLCBvciBzZWUgb3VyXG4gICAqIFtNb2RlbCBvdmVydmlld10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzKSBmb3IgZGVzY3JpcHRpb25zIG9mXG4gICAqIHRoZW0uXG4gICAqL1xuICBtb2RlbDogKHN0cmluZyAmIHt9KSB8IEVtYmVkZGluZ01vZGVsO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGRpbWVuc2lvbnMgdGhlIHJlc3VsdGluZyBvdXRwdXQgZW1iZWRkaW5ncyBzaG91bGQgaGF2ZS4gT25seVxuICAgKiBzdXBwb3J0ZWQgaW4gYHRleHQtZW1iZWRkaW5nLTNgIGFuZCBsYXRlciBtb2RlbHMuXG4gICAqL1xuICBkaW1lbnNpb25zPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IHRvIHJldHVybiB0aGUgZW1iZWRkaW5ncyBpbi4gQ2FuIGJlIGVpdGhlciBgZmxvYXRgIG9yXG4gICAqIFtgYmFzZTY0YF0oaHR0cHM6Ly9weXBpLm9yZy9wcm9qZWN0L3B5YmFzZTY0LykuXG4gICAqL1xuICBlbmNvZGluZ19mb3JtYXQ/OiAnZmxvYXQnIHwgJ2Jhc2U2NCc7XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgcmVwcmVzZW50aW5nIHlvdXIgZW5kLXVzZXIsIHdoaWNoIGNhbiBoZWxwIE9wZW5BSSB0byBtb25pdG9yXG4gICAqIGFuZCBkZXRlY3QgYWJ1c2UuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc2FmZXR5LWJlc3QtcHJhY3RpY2VzI2VuZC11c2VyLWlkcykuXG4gICAqL1xuICB1c2VyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgRW1iZWRkaW5ncyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBDcmVhdGVFbWJlZGRpbmdSZXNwb25zZSBhcyBDcmVhdGVFbWJlZGRpbmdSZXNwb25zZSxcbiAgICB0eXBlIEVtYmVkZGluZyBhcyBFbWJlZGRpbmcsXG4gICAgdHlwZSBFbWJlZGRpbmdNb2RlbCBhcyBFbWJlZGRpbmdNb2RlbCxcbiAgICB0eXBlIEVtYmVkZGluZ0NyZWF0ZVBhcmFtcyBhcyBFbWJlZGRpbmdDcmVhdGVQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0IHsgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvciB9IGZyb20gJy4uL2Vycm9yJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgeyBDdXJzb3JQYWdlLCB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgfSBmcm9tICcuLi9wYWdpbmF0aW9uJztcbmltcG9ydCB7IHR5cGUgUmVzcG9uc2UgfSBmcm9tICcuLi9fc2hpbXMvaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgRmlsZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBVcGxvYWQgYSBmaWxlIHRoYXQgY2FuIGJlIHVzZWQgYWNyb3NzIHZhcmlvdXMgZW5kcG9pbnRzLiBJbmRpdmlkdWFsIGZpbGVzIGNhbiBiZVxuICAgKiB1cCB0byA1MTIgTUIsIGFuZCB0aGUgc2l6ZSBvZiBhbGwgZmlsZXMgdXBsb2FkZWQgYnkgb25lIG9yZ2FuaXphdGlvbiBjYW4gYmUgdXBcbiAgICogdG8gMTAwIEdCLlxuICAgKlxuICAgKiBUaGUgQXNzaXN0YW50cyBBUEkgc3VwcG9ydHMgZmlsZXMgdXAgdG8gMiBtaWxsaW9uIHRva2VucyBhbmQgb2Ygc3BlY2lmaWMgZmlsZVxuICAgKiB0eXBlcy4gU2VlIHRoZVxuICAgKiBbQXNzaXN0YW50cyBUb29scyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy90b29scykgZm9yXG4gICAqIGRldGFpbHMuXG4gICAqXG4gICAqIFRoZSBGaW5lLXR1bmluZyBBUEkgb25seSBzdXBwb3J0cyBgLmpzb25sYCBmaWxlcy4gVGhlIGlucHV0IGFsc28gaGFzIGNlcnRhaW5cbiAgICogcmVxdWlyZWQgZm9ybWF0cyBmb3IgZmluZS10dW5pbmdcbiAgICogW2NoYXRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmluZS10dW5pbmcvY2hhdC1pbnB1dCkgb3JcbiAgICogW2NvbXBsZXRpb25zXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuaW5nL2NvbXBsZXRpb25zLWlucHV0KVxuICAgKiBtb2RlbHMuXG4gICAqXG4gICAqIFRoZSBCYXRjaCBBUEkgb25seSBzdXBwb3J0cyBgLmpzb25sYCBmaWxlcyB1cCB0byAyMDAgTUIgaW4gc2l6ZS4gVGhlIGlucHV0IGFsc29cbiAgICogaGFzIGEgc3BlY2lmaWMgcmVxdWlyZWRcbiAgICogW2Zvcm1hdF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9iYXRjaC9yZXF1ZXN0LWlucHV0KS5cbiAgICpcbiAgICogUGxlYXNlIFtjb250YWN0IHVzXShodHRwczovL2hlbHAub3BlbmFpLmNvbS8pIGlmIHlvdSBuZWVkIHRvIGluY3JlYXNlIHRoZXNlXG4gICAqIHN0b3JhZ2UgbGltaXRzLlxuICAgKi9cbiAgY3JlYXRlKGJvZHk6IEZpbGVDcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEZpbGVPYmplY3Q+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9maWxlcycsIENvcmUubXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zKHsgYm9keSwgLi4ub3B0aW9ucyB9KSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCBhIHNwZWNpZmljIGZpbGUuXG4gICAqL1xuICByZXRyaWV2ZShmaWxlSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8RmlsZU9iamVjdD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvZmlsZXMvJHtmaWxlSWR9YCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgZmlsZXMuXG4gICAqL1xuICBsaXN0KHF1ZXJ5PzogRmlsZUxpc3RQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5QYWdlUHJvbWlzZTxGaWxlT2JqZWN0c1BhZ2UsIEZpbGVPYmplY3Q+O1xuICBsaXN0KG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5QYWdlUHJvbWlzZTxGaWxlT2JqZWN0c1BhZ2UsIEZpbGVPYmplY3Q+O1xuICBsaXN0KFxuICAgIHF1ZXJ5OiBGaWxlTGlzdFBhcmFtcyB8IENvcmUuUmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxGaWxlT2JqZWN0c1BhZ2UsIEZpbGVPYmplY3Q+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3Qoe30sIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KCcvZmlsZXMnLCBGaWxlT2JqZWN0c1BhZ2UsIHsgcXVlcnksIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgZmlsZS5cbiAgICovXG4gIGRlbChmaWxlSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8RmlsZURlbGV0ZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL2ZpbGVzLyR7ZmlsZUlkfWAsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRlbnRzIG9mIHRoZSBzcGVjaWZpZWQgZmlsZS5cbiAgICovXG4gIGNvbnRlbnQoZmlsZUlkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC9maWxlcy8ke2ZpbGVJZH0vY29udGVudGAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2JpbmFyeScsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgIF9fYmluYXJ5UmVzcG9uc2U6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIHNwZWNpZmllZCBmaWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBUaGUgYC5jb250ZW50KClgIG1ldGhvZCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkXG4gICAqL1xuICByZXRyaWV2ZUNvbnRlbnQoZmlsZUlkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvZmlsZXMvJHtmaWxlSWR9L2NvbnRlbnRgLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgdGhlIGdpdmVuIGZpbGUgdG8gYmUgcHJvY2Vzc2VkLCBkZWZhdWx0IHRpbWVvdXQgaXMgMzAgbWlucy5cbiAgICovXG4gIGFzeW5jIHdhaXRGb3JQcm9jZXNzaW5nKFxuICAgIGlkOiBzdHJpbmcsXG4gICAgeyBwb2xsSW50ZXJ2YWwgPSA1MDAwLCBtYXhXYWl0ID0gMzAgKiA2MCAqIDEwMDAgfTogeyBwb2xsSW50ZXJ2YWw/OiBudW1iZXI7IG1heFdhaXQ/OiBudW1iZXIgfSA9IHt9LFxuICApOiBQcm9taXNlPEZpbGVPYmplY3Q+IHtcbiAgICBjb25zdCBURVJNSU5BTF9TVEFURVMgPSBuZXcgU2V0KFsncHJvY2Vzc2VkJywgJ2Vycm9yJywgJ2RlbGV0ZWQnXSk7XG5cbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgbGV0IGZpbGUgPSBhd2FpdCB0aGlzLnJldHJpZXZlKGlkKTtcblxuICAgIHdoaWxlICghZmlsZS5zdGF0dXMgfHwgIVRFUk1JTkFMX1NUQVRFUy5oYXMoZmlsZS5zdGF0dXMpKSB7XG4gICAgICBhd2FpdCBzbGVlcChwb2xsSW50ZXJ2YWwpO1xuXG4gICAgICBmaWxlID0gYXdhaXQgdGhpcy5yZXRyaWV2ZShpZCk7XG4gICAgICBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0ID4gbWF4V2FpdCkge1xuICAgICAgICB0aHJvdyBuZXcgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogYEdpdmluZyB1cCBvbiB3YWl0aW5nIGZvciBmaWxlICR7aWR9IHRvIGZpbmlzaCBwcm9jZXNzaW5nIGFmdGVyICR7bWF4V2FpdH0gbWlsbGlzZWNvbmRzLmAsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmaWxlO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGaWxlT2JqZWN0c1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlPEZpbGVPYmplY3Q+IHt9XG5cbmV4cG9ydCB0eXBlIEZpbGVDb250ZW50ID0gc3RyaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVEZWxldGVkIHtcbiAgaWQ6IHN0cmluZztcblxuICBkZWxldGVkOiBib29sZWFuO1xuXG4gIG9iamVjdDogJ2ZpbGUnO1xufVxuXG4vKipcbiAqIFRoZSBgRmlsZWAgb2JqZWN0IHJlcHJlc2VudHMgYSBkb2N1bWVudCB0aGF0IGhhcyBiZWVuIHVwbG9hZGVkIHRvIE9wZW5BSS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaWxlT2JqZWN0IHtcbiAgLyoqXG4gICAqIFRoZSBmaWxlIGlkZW50aWZpZXIsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIHRoZSBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIGZpbGUsIGluIGJ5dGVzLlxuICAgKi9cbiAgYnl0ZXM6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgZmlsZSB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZpbGUuXG4gICAqL1xuICBmaWxlbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgZmlsZWAuXG4gICAqL1xuICBvYmplY3Q6ICdmaWxlJztcblxuICAvKipcbiAgICogVGhlIGludGVuZGVkIHB1cnBvc2Ugb2YgdGhlIGZpbGUuIFN1cHBvcnRlZCB2YWx1ZXMgYXJlIGBhc3Npc3RhbnRzYCxcbiAgICogYGFzc2lzdGFudHNfb3V0cHV0YCwgYGJhdGNoYCwgYGJhdGNoX291dHB1dGAsIGBmaW5lLXR1bmVgLCBgZmluZS10dW5lLXJlc3VsdHNgXG4gICAqIGFuZCBgdmlzaW9uYC5cbiAgICovXG4gIHB1cnBvc2U6XG4gICAgfCAnYXNzaXN0YW50cydcbiAgICB8ICdhc3Npc3RhbnRzX291dHB1dCdcbiAgICB8ICdiYXRjaCdcbiAgICB8ICdiYXRjaF9vdXRwdXQnXG4gICAgfCAnZmluZS10dW5lJ1xuICAgIHwgJ2ZpbmUtdHVuZS1yZXN1bHRzJ1xuICAgIHwgJ3Zpc2lvbic7XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkOiBEZXByZWNhdGVkLiBUaGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIGZpbGUsIHdoaWNoIGNhbiBiZSBlaXRoZXJcbiAgICogYHVwbG9hZGVkYCwgYHByb2Nlc3NlZGAsIG9yIGBlcnJvcmAuXG4gICAqL1xuICBzdGF0dXM6ICd1cGxvYWRlZCcgfCAncHJvY2Vzc2VkJyB8ICdlcnJvcic7XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkOiBEZXByZWNhdGVkLiBGb3IgZGV0YWlscyBvbiB3aHkgYSBmaW5lLXR1bmluZyB0cmFpbmluZyBmaWxlIGZhaWxlZFxuICAgKiB2YWxpZGF0aW9uLCBzZWUgdGhlIGBlcnJvcmAgZmllbGQgb24gYGZpbmVfdHVuaW5nLmpvYmAuXG4gICAqL1xuICBzdGF0dXNfZGV0YWlscz86IHN0cmluZztcbn1cblxuLyoqXG4gKiBUaGUgaW50ZW5kZWQgcHVycG9zZSBvZiB0aGUgdXBsb2FkZWQgZmlsZS5cbiAqXG4gKiBVc2UgXCJhc3Npc3RhbnRzXCIgZm9yXG4gKiBbQXNzaXN0YW50c10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSBhbmRcbiAqIFtNZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzKSBmaWxlcyxcbiAqIFwidmlzaW9uXCIgZm9yIEFzc2lzdGFudHMgaW1hZ2UgZmlsZSBpbnB1dHMsIFwiYmF0Y2hcIiBmb3JcbiAqIFtCYXRjaCBBUEldKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9iYXRjaCksIGFuZCBcImZpbmUtdHVuZVwiIGZvclxuICogW0ZpbmUtdHVuaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuaW5nKS5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsZVB1cnBvc2UgPSAnYXNzaXN0YW50cycgfCAnYmF0Y2gnIHwgJ2ZpbmUtdHVuZScgfCAndmlzaW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBGaWxlQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBGaWxlIG9iamVjdCAobm90IGZpbGUgbmFtZSkgdG8gYmUgdXBsb2FkZWQuXG4gICAqL1xuICBmaWxlOiBDb3JlLlVwbG9hZGFibGU7XG5cbiAgLyoqXG4gICAqIFRoZSBpbnRlbmRlZCBwdXJwb3NlIG9mIHRoZSB1cGxvYWRlZCBmaWxlLlxuICAgKlxuICAgKiBVc2UgXCJhc3Npc3RhbnRzXCIgZm9yXG4gICAqIFtBc3Npc3RhbnRzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIGFuZFxuICAgKiBbTWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcykgZmlsZXMsXG4gICAqIFwidmlzaW9uXCIgZm9yIEFzc2lzdGFudHMgaW1hZ2UgZmlsZSBpbnB1dHMsIFwiYmF0Y2hcIiBmb3JcbiAgICogW0JhdGNoIEFQSV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2JhdGNoKSwgYW5kIFwiZmluZS10dW5lXCIgZm9yXG4gICAqIFtGaW5lLXR1bmluZ10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maW5lLXR1bmluZykuXG4gICAqL1xuICBwdXJwb3NlOiBGaWxlUHVycG9zZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlTGlzdFBhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge1xuICAvKipcbiAgICogU29ydCBvcmRlciBieSB0aGUgYGNyZWF0ZWRfYXRgIHRpbWVzdGFtcCBvZiB0aGUgb2JqZWN0cy4gYGFzY2AgZm9yIGFzY2VuZGluZ1xuICAgKiBvcmRlciBhbmQgYGRlc2NgIGZvciBkZXNjZW5kaW5nIG9yZGVyLlxuICAgKi9cbiAgb3JkZXI/OiAnYXNjJyB8ICdkZXNjJztcblxuICAvKipcbiAgICogT25seSByZXR1cm4gZmlsZXMgd2l0aCB0aGUgZ2l2ZW4gcHVycG9zZS5cbiAgICovXG4gIHB1cnBvc2U/OiBzdHJpbmc7XG59XG5cbkZpbGVzLkZpbGVPYmplY3RzUGFnZSA9IEZpbGVPYmplY3RzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEZpbGVzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIEZpbGVDb250ZW50IGFzIEZpbGVDb250ZW50LFxuICAgIHR5cGUgRmlsZURlbGV0ZWQgYXMgRmlsZURlbGV0ZWQsXG4gICAgdHlwZSBGaWxlT2JqZWN0IGFzIEZpbGVPYmplY3QsXG4gICAgdHlwZSBGaWxlUHVycG9zZSBhcyBGaWxlUHVycG9zZSxcbiAgICBGaWxlT2JqZWN0c1BhZ2UgYXMgRmlsZU9iamVjdHNQYWdlLFxuICAgIHR5cGUgRmlsZUNyZWF0ZVBhcmFtcyBhcyBGaWxlQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgRmlsZUxpc3RQYXJhbXMgYXMgRmlsZUxpc3RQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSwgdHlwZSBDdXJzb3JQYWdlUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vcGFnaW5hdGlvbic7XG5cbmV4cG9ydCBjbGFzcyBDaGVja3BvaW50cyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIExpc3QgY2hlY2twb2ludHMgZm9yIGEgZmluZS10dW5pbmcgam9iLlxuICAgKi9cbiAgbGlzdChcbiAgICBmaW5lVHVuaW5nSm9iSWQ6IHN0cmluZyxcbiAgICBxdWVyeT86IENoZWNrcG9pbnRMaXN0UGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UsIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50PjtcbiAgbGlzdChcbiAgICBmaW5lVHVuaW5nSm9iSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxGaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlLCBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludD47XG4gIGxpc3QoXG4gICAgZmluZVR1bmluZ0pvYklkOiBzdHJpbmcsXG4gICAgcXVlcnk6IENoZWNrcG9pbnRMaXN0UGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UsIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50PiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0KGZpbmVUdW5pbmdKb2JJZCwge30sIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KFxuICAgICAgYC9maW5lX3R1bmluZy9qb2JzLyR7ZmluZVR1bmluZ0pvYklkfS9jaGVja3BvaW50c2AsXG4gICAgICBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlLFxuICAgICAgeyBxdWVyeSwgLi4ub3B0aW9ucyB9LFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlPEZpbmVUdW5pbmdKb2JDaGVja3BvaW50PiB7fVxuXG4vKipcbiAqIFRoZSBgZmluZV90dW5pbmcuam9iLmNoZWNrcG9pbnRgIG9iamVjdCByZXByZXNlbnRzIGEgbW9kZWwgY2hlY2twb2ludCBmb3IgYVxuICogZmluZS10dW5pbmcgam9iIHRoYXQgaXMgcmVhZHkgdG8gdXNlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50IHtcbiAgLyoqXG4gICAqIFRoZSBjaGVja3BvaW50IGlkZW50aWZpZXIsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIHRoZSBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgY2hlY2twb2ludCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZpbmUtdHVuZWQgY2hlY2twb2ludCBtb2RlbCB0aGF0IGlzIGNyZWF0ZWQuXG4gICAqL1xuICBmaW5lX3R1bmVkX21vZGVsX2NoZWNrcG9pbnQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZpbmUtdHVuaW5nIGpvYiB0aGF0IHRoaXMgY2hlY2twb2ludCB3YXMgY3JlYXRlZCBmcm9tLlxuICAgKi9cbiAgZmluZV90dW5pbmdfam9iX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE1ldHJpY3MgYXQgdGhlIHN0ZXAgbnVtYmVyIGR1cmluZyB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgKi9cbiAgbWV0cmljczogRmluZVR1bmluZ0pvYkNoZWNrcG9pbnQuTWV0cmljcztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgXCJmaW5lX3R1bmluZy5qb2IuY2hlY2twb2ludFwiLlxuICAgKi9cbiAgb2JqZWN0OiAnZmluZV90dW5pbmcuam9iLmNoZWNrcG9pbnQnO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RlcCBudW1iZXIgdGhhdCB0aGUgY2hlY2twb2ludCB3YXMgY3JlYXRlZCBhdC5cbiAgICovXG4gIHN0ZXBfbnVtYmVyOiBudW1iZXI7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnQge1xuICAvKipcbiAgICogTWV0cmljcyBhdCB0aGUgc3RlcCBudW1iZXIgZHVyaW5nIHRoZSBmaW5lLXR1bmluZyBqb2IuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIE1ldHJpY3Mge1xuICAgIGZ1bGxfdmFsaWRfbG9zcz86IG51bWJlcjtcblxuICAgIGZ1bGxfdmFsaWRfbWVhbl90b2tlbl9hY2N1cmFjeT86IG51bWJlcjtcblxuICAgIHN0ZXA/OiBudW1iZXI7XG5cbiAgICB0cmFpbl9sb3NzPzogbnVtYmVyO1xuXG4gICAgdHJhaW5fbWVhbl90b2tlbl9hY2N1cmFjeT86IG51bWJlcjtcblxuICAgIHZhbGlkX2xvc3M/OiBudW1iZXI7XG5cbiAgICB2YWxpZF9tZWFuX3Rva2VuX2FjY3VyYWN5PzogbnVtYmVyO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2twb2ludExpc3RQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHt9XG5cbkNoZWNrcG9pbnRzLkZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UgPSBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgQ2hlY2twb2ludHMge1xuICBleHBvcnQge1xuICAgIHR5cGUgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnQgYXMgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnQsXG4gICAgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSBhcyBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlLFxuICAgIHR5cGUgQ2hlY2twb2ludExpc3RQYXJhbXMgYXMgQ2hlY2twb2ludExpc3RQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ2hlY2twb2ludHNBUEkgZnJvbSAnLi9jaGVja3BvaW50cyc7XG5pbXBvcnQge1xuICBDaGVja3BvaW50TGlzdFBhcmFtcyxcbiAgQ2hlY2twb2ludHMsXG4gIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50LFxuICBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlLFxufSBmcm9tICcuL2NoZWNrcG9pbnRzJztcbmltcG9ydCB7IEN1cnNvclBhZ2UsIHR5cGUgQ3Vyc29yUGFnZVBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL3BhZ2luYXRpb24nO1xuXG5leHBvcnQgY2xhc3MgSm9icyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgY2hlY2twb2ludHM6IENoZWNrcG9pbnRzQVBJLkNoZWNrcG9pbnRzID0gbmV3IENoZWNrcG9pbnRzQVBJLkNoZWNrcG9pbnRzKHRoaXMuX2NsaWVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmaW5lLXR1bmluZyBqb2Igd2hpY2ggYmVnaW5zIHRoZSBwcm9jZXNzIG9mIGNyZWF0aW5nIGEgbmV3IG1vZGVsIGZyb21cbiAgICogYSBnaXZlbiBkYXRhc2V0LlxuICAgKlxuICAgKiBSZXNwb25zZSBpbmNsdWRlcyBkZXRhaWxzIG9mIHRoZSBlbnF1ZXVlZCBqb2IgaW5jbHVkaW5nIGpvYiBzdGF0dXMgYW5kIHRoZSBuYW1lXG4gICAqIG9mIHRoZSBmaW5lLXR1bmVkIG1vZGVscyBvbmNlIGNvbXBsZXRlLlxuICAgKlxuICAgKiBbTGVhcm4gbW9yZSBhYm91dCBmaW5lLXR1bmluZ10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2ZpbmUtdHVuaW5nKVxuICAgKi9cbiAgY3JlYXRlKGJvZHk6IEpvYkNyZWF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8RmluZVR1bmluZ0pvYj4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2ZpbmVfdHVuaW5nL2pvYnMnLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGluZm8gYWJvdXQgYSBmaW5lLXR1bmluZyBqb2IuXG4gICAqXG4gICAqIFtMZWFybiBtb3JlIGFib3V0IGZpbmUtdHVuaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAqL1xuICByZXRyaWV2ZShmaW5lVHVuaW5nSm9iSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8RmluZVR1bmluZ0pvYj4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvZmluZV90dW5pbmcvam9icy8ke2ZpbmVUdW5pbmdKb2JJZH1gLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHlvdXIgb3JnYW5pemF0aW9uJ3MgZmluZS10dW5pbmcgam9ic1xuICAgKi9cbiAgbGlzdChcbiAgICBxdWVyeT86IEpvYkxpc3RQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmluZ0pvYnNQYWdlLCBGaW5lVHVuaW5nSm9iPjtcbiAgbGlzdChvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmluZ0pvYnNQYWdlLCBGaW5lVHVuaW5nSm9iPjtcbiAgbGlzdChcbiAgICBxdWVyeTogSm9iTGlzdFBhcmFtcyB8IENvcmUuUmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxGaW5lVHVuaW5nSm9ic1BhZ2UsIEZpbmVUdW5pbmdKb2I+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3Qoe30sIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KCcvZmluZV90dW5pbmcvam9icycsIEZpbmVUdW5pbmdKb2JzUGFnZSwgeyBxdWVyeSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbW1lZGlhdGVseSBjYW5jZWwgYSBmaW5lLXR1bmUgam9iLlxuICAgKi9cbiAgY2FuY2VsKGZpbmVUdW5pbmdKb2JJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxGaW5lVHVuaW5nSm9iPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvZmluZV90dW5pbmcvam9icy8ke2ZpbmVUdW5pbmdKb2JJZH0vY2FuY2VsYCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHN0YXR1cyB1cGRhdGVzIGZvciBhIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIGxpc3RFdmVudHMoXG4gICAgZmluZVR1bmluZ0pvYklkOiBzdHJpbmcsXG4gICAgcXVlcnk/OiBKb2JMaXN0RXZlbnRzUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlLCBGaW5lVHVuaW5nSm9iRXZlbnQ+O1xuICBsaXN0RXZlbnRzKFxuICAgIGZpbmVUdW5pbmdKb2JJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlLCBGaW5lVHVuaW5nSm9iRXZlbnQ+O1xuICBsaXN0RXZlbnRzKFxuICAgIGZpbmVUdW5pbmdKb2JJZDogc3RyaW5nLFxuICAgIHF1ZXJ5OiBKb2JMaXN0RXZlbnRzUGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlLCBGaW5lVHVuaW5nSm9iRXZlbnQ+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3RFdmVudHMoZmluZVR1bmluZ0pvYklkLCB7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoYC9maW5lX3R1bmluZy9qb2JzLyR7ZmluZVR1bmluZ0pvYklkfS9ldmVudHNgLCBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSwge1xuICAgICAgcXVlcnksXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGaW5lVHVuaW5nSm9ic1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlPEZpbmVUdW5pbmdKb2I+IHt9XG5cbmV4cG9ydCBjbGFzcyBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8RmluZVR1bmluZ0pvYkV2ZW50PiB7fVxuXG4vKipcbiAqIFRoZSBgZmluZV90dW5pbmcuam9iYCBvYmplY3QgcmVwcmVzZW50cyBhIGZpbmUtdHVuaW5nIGpvYiB0aGF0IGhhcyBiZWVuIGNyZWF0ZWRcbiAqIHRocm91Z2ggdGhlIEFQSS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaW5lVHVuaW5nSm9iIHtcbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gdGhlIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBmaW5lLXR1bmluZyBqb2Igd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEZvciBmaW5lLXR1bmluZyBqb2JzIHRoYXQgaGF2ZSBgZmFpbGVkYCwgdGhpcyB3aWxsIGNvbnRhaW4gbW9yZSBpbmZvcm1hdGlvbiBvblxuICAgKiB0aGUgY2F1c2Ugb2YgdGhlIGZhaWx1cmUuXG4gICAqL1xuICBlcnJvcjogRmluZVR1bmluZ0pvYi5FcnJvciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmaW5lLXR1bmVkIG1vZGVsIHRoYXQgaXMgYmVpbmcgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmUgbnVsbFxuICAgKiBpZiB0aGUgZmluZS10dW5pbmcgam9iIGlzIHN0aWxsIHJ1bm5pbmcuXG4gICAqL1xuICBmaW5lX3R1bmVkX21vZGVsOiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBmaW5lLXR1bmluZyBqb2Igd2FzIGZpbmlzaGVkLiBUaGVcbiAgICogdmFsdWUgd2lsbCBiZSBudWxsIGlmIHRoZSBmaW5lLXR1bmluZyBqb2IgaXMgc3RpbGwgcnVubmluZy5cbiAgICovXG4gIGZpbmlzaGVkX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuIFRoaXMgdmFsdWUgd2lsbCBvbmx5IGJlXG4gICAqIHJldHVybmVkIHdoZW4gcnVubmluZyBgc3VwZXJ2aXNlZGAgam9icy5cbiAgICovXG4gIGh5cGVycGFyYW1ldGVyczogRmluZVR1bmluZ0pvYi5IeXBlcnBhcmFtZXRlcnM7XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIG1vZGVsIHRoYXQgaXMgYmVpbmcgZmluZS10dW5lZC5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwiZmluZV90dW5pbmcuam9iXCIuXG4gICAqL1xuICBvYmplY3Q6ICdmaW5lX3R1bmluZy5qb2InO1xuXG4gIC8qKlxuICAgKiBUaGUgb3JnYW5pemF0aW9uIHRoYXQgb3ducyB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgKi9cbiAgb3JnYW5pemF0aW9uX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBjb21waWxlZCByZXN1bHRzIGZpbGUgSUQocykgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuIFlvdSBjYW4gcmV0cmlldmUgdGhlXG4gICAqIHJlc3VsdHMgd2l0aCB0aGVcbiAgICogW0ZpbGVzIEFQSV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9yZXRyaWV2ZS1jb250ZW50cykuXG4gICAqL1xuICByZXN1bHRfZmlsZXM6IEFycmF5PHN0cmluZz47XG5cbiAgLyoqXG4gICAqIFRoZSBzZWVkIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuXG4gICAqL1xuICBzZWVkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgZmluZS10dW5pbmcgam9iLCB3aGljaCBjYW4gYmUgZWl0aGVyXG4gICAqIGB2YWxpZGF0aW5nX2ZpbGVzYCwgYHF1ZXVlZGAsIGBydW5uaW5nYCwgYHN1Y2NlZWRlZGAsIGBmYWlsZWRgLCBvciBgY2FuY2VsbGVkYC5cbiAgICovXG4gIHN0YXR1czogJ3ZhbGlkYXRpbmdfZmlsZXMnIHwgJ3F1ZXVlZCcgfCAncnVubmluZycgfCAnc3VjY2VlZGVkJyB8ICdmYWlsZWQnIHwgJ2NhbmNlbGxlZCc7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgYmlsbGFibGUgdG9rZW5zIHByb2Nlc3NlZCBieSB0aGlzIGZpbmUtdHVuaW5nIGpvYi4gVGhlIHZhbHVlXG4gICAqIHdpbGwgYmUgbnVsbCBpZiB0aGUgZmluZS10dW5pbmcgam9iIGlzIHN0aWxsIHJ1bm5pbmcuXG4gICAqL1xuICB0cmFpbmVkX3Rva2VuczogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGZpbGUgSUQgdXNlZCBmb3IgdHJhaW5pbmcuIFlvdSBjYW4gcmV0cmlldmUgdGhlIHRyYWluaW5nIGRhdGEgd2l0aCB0aGVcbiAgICogW0ZpbGVzIEFQSV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9yZXRyaWV2ZS1jb250ZW50cykuXG4gICAqL1xuICB0cmFpbmluZ19maWxlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBmaWxlIElEIHVzZWQgZm9yIHZhbGlkYXRpb24uIFlvdSBjYW4gcmV0cmlldmUgdGhlIHZhbGlkYXRpb24gcmVzdWx0cyB3aXRoXG4gICAqIHRoZVxuICAgKiBbRmlsZXMgQVBJXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL3JldHJpZXZlLWNvbnRlbnRzKS5cbiAgICovXG4gIHZhbGlkYXRpb25fZmlsZTogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgZmluZS10dW5pbmcgam9iIGlzIGVzdGltYXRlZCB0b1xuICAgKiBmaW5pc2guIFRoZSB2YWx1ZSB3aWxsIGJlIG51bGwgaWYgdGhlIGZpbmUtdHVuaW5nIGpvYiBpcyBub3QgcnVubmluZy5cbiAgICovXG4gIGVzdGltYXRlZF9maW5pc2g/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgaW50ZWdyYXRpb25zIHRvIGVuYWJsZSBmb3IgdGhpcyBmaW5lLXR1bmluZyBqb2IuXG4gICAqL1xuICBpbnRlZ3JhdGlvbnM/OiBBcnJheTxGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbk9iamVjdD4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWV0aG9kIHVzZWQgZm9yIGZpbmUtdHVuaW5nLlxuICAgKi9cbiAgbWV0aG9kPzogRmluZVR1bmluZ0pvYi5NZXRob2Q7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRmluZVR1bmluZ0pvYiB7XG4gIC8qKlxuICAgKiBGb3IgZmluZS10dW5pbmcgam9icyB0aGF0IGhhdmUgYGZhaWxlZGAsIHRoaXMgd2lsbCBjb250YWluIG1vcmUgaW5mb3JtYXRpb24gb25cbiAgICogdGhlIGNhdXNlIG9mIHRoZSBmYWlsdXJlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBFcnJvciB7XG4gICAgLyoqXG4gICAgICogQSBtYWNoaW5lLXJlYWRhYmxlIGVycm9yIGNvZGUuXG4gICAgICovXG4gICAgY29kZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQSBodW1hbi1yZWFkYWJsZSBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIG1lc3NhZ2U6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBwYXJhbWV0ZXIgdGhhdCB3YXMgaW52YWxpZCwgdXN1YWxseSBgdHJhaW5pbmdfZmlsZWAgb3IgYHZhbGlkYXRpb25fZmlsZWAuXG4gICAgICogVGhpcyBmaWVsZCB3aWxsIGJlIG51bGwgaWYgdGhlIGZhaWx1cmUgd2FzIG5vdCBwYXJhbWV0ZXItc3BlY2lmaWMuXG4gICAgICovXG4gICAgcGFyYW06IHN0cmluZyB8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLiBUaGlzIHZhbHVlIHdpbGwgb25seSBiZVxuICAgKiByZXR1cm5lZCB3aGVuIHJ1bm5pbmcgYHN1cGVydmlzZWRgIGpvYnMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEh5cGVycGFyYW1ldGVycyB7XG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGV4YW1wbGVzIGluIGVhY2ggYmF0Y2guIEEgbGFyZ2VyIGJhdGNoIHNpemUgbWVhbnMgdGhhdCBtb2RlbFxuICAgICAqIHBhcmFtZXRlcnMgYXJlIHVwZGF0ZWQgbGVzcyBmcmVxdWVudGx5LCBidXQgd2l0aCBsb3dlciB2YXJpYW5jZS5cbiAgICAgKi9cbiAgICBiYXRjaF9zaXplPzogJ2F1dG8nIHwgbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU2NhbGluZyBmYWN0b3IgZm9yIHRoZSBsZWFybmluZyByYXRlLiBBIHNtYWxsZXIgbGVhcm5pbmcgcmF0ZSBtYXkgYmUgdXNlZnVsIHRvXG4gICAgICogYXZvaWQgb3ZlcmZpdHRpbmcuXG4gICAgICovXG4gICAgbGVhcm5pbmdfcmF0ZV9tdWx0aXBsaWVyPzogJ2F1dG8nIHwgbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBlcG9jaHMgdG8gdHJhaW4gdGhlIG1vZGVsIGZvci4gQW4gZXBvY2ggcmVmZXJzIHRvIG9uZSBmdWxsIGN5Y2xlXG4gICAgICogdGhyb3VnaCB0aGUgdHJhaW5pbmcgZGF0YXNldC5cbiAgICAgKi9cbiAgICBuX2Vwb2Nocz86ICdhdXRvJyB8IG51bWJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbWV0aG9kIHVzZWQgZm9yIGZpbmUtdHVuaW5nLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBNZXRob2Qge1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBEUE8gZmluZS10dW5pbmcgbWV0aG9kLlxuICAgICAqL1xuICAgIGRwbz86IE1ldGhvZC5EcG87XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGZvciB0aGUgc3VwZXJ2aXNlZCBmaW5lLXR1bmluZyBtZXRob2QuXG4gICAgICovXG4gICAgc3VwZXJ2aXNlZD86IE1ldGhvZC5TdXBlcnZpc2VkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgbWV0aG9kLiBJcyBlaXRoZXIgYHN1cGVydmlzZWRgIG9yIGBkcG9gLlxuICAgICAqL1xuICAgIHR5cGU/OiAnc3VwZXJ2aXNlZCcgfCAnZHBvJztcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgTWV0aG9kIHtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGZvciB0aGUgRFBPIGZpbmUtdHVuaW5nIG1ldGhvZC5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIERwbyB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICAgICAqL1xuICAgICAgaHlwZXJwYXJhbWV0ZXJzPzogRHBvLkh5cGVycGFyYW1ldGVycztcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIERwbyB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICAgICAqL1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBIeXBlcnBhcmFtZXRlcnMge1xuICAgICAgICAvKipcbiAgICAgICAgICogTnVtYmVyIG9mIGV4YW1wbGVzIGluIGVhY2ggYmF0Y2guIEEgbGFyZ2VyIGJhdGNoIHNpemUgbWVhbnMgdGhhdCBtb2RlbFxuICAgICAgICAgKiBwYXJhbWV0ZXJzIGFyZSB1cGRhdGVkIGxlc3MgZnJlcXVlbnRseSwgYnV0IHdpdGggbG93ZXIgdmFyaWFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBiYXRjaF9zaXplPzogJ2F1dG8nIHwgbnVtYmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYmV0YSB2YWx1ZSBmb3IgdGhlIERQTyBtZXRob2QuIEEgaGlnaGVyIGJldGEgdmFsdWUgd2lsbCBpbmNyZWFzZSB0aGUgd2VpZ2h0XG4gICAgICAgICAqIG9mIHRoZSBwZW5hbHR5IGJldHdlZW4gdGhlIHBvbGljeSBhbmQgcmVmZXJlbmNlIG1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgYmV0YT86ICdhdXRvJyB8IG51bWJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2NhbGluZyBmYWN0b3IgZm9yIHRoZSBsZWFybmluZyByYXRlLiBBIHNtYWxsZXIgbGVhcm5pbmcgcmF0ZSBtYXkgYmUgdXNlZnVsIHRvXG4gICAgICAgICAqIGF2b2lkIG92ZXJmaXR0aW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgbGVhcm5pbmdfcmF0ZV9tdWx0aXBsaWVyPzogJ2F1dG8nIHwgbnVtYmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGVwb2NocyB0byB0cmFpbiB0aGUgbW9kZWwgZm9yLiBBbiBlcG9jaCByZWZlcnMgdG8gb25lIGZ1bGwgY3ljbGVcbiAgICAgICAgICogdGhyb3VnaCB0aGUgdHJhaW5pbmcgZGF0YXNldC5cbiAgICAgICAgICovXG4gICAgICAgIG5fZXBvY2hzPzogJ2F1dG8nIHwgbnVtYmVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBlcnZpc2VkIGZpbmUtdHVuaW5nIG1ldGhvZC5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIFN1cGVydmlzZWQge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuXG4gICAgICAgKi9cbiAgICAgIGh5cGVycGFyYW1ldGVycz86IFN1cGVydmlzZWQuSHlwZXJwYXJhbWV0ZXJzO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgU3VwZXJ2aXNlZCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICAgICAqL1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBIeXBlcnBhcmFtZXRlcnMge1xuICAgICAgICAvKipcbiAgICAgICAgICogTnVtYmVyIG9mIGV4YW1wbGVzIGluIGVhY2ggYmF0Y2guIEEgbGFyZ2VyIGJhdGNoIHNpemUgbWVhbnMgdGhhdCBtb2RlbFxuICAgICAgICAgKiBwYXJhbWV0ZXJzIGFyZSB1cGRhdGVkIGxlc3MgZnJlcXVlbnRseSwgYnV0IHdpdGggbG93ZXIgdmFyaWFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBiYXRjaF9zaXplPzogJ2F1dG8nIHwgbnVtYmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY2FsaW5nIGZhY3RvciBmb3IgdGhlIGxlYXJuaW5nIHJhdGUuIEEgc21hbGxlciBsZWFybmluZyByYXRlIG1heSBiZSB1c2VmdWwgdG9cbiAgICAgICAgICogYXZvaWQgb3ZlcmZpdHRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBsZWFybmluZ19yYXRlX211bHRpcGxpZXI/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgZXBvY2hzIHRvIHRyYWluIHRoZSBtb2RlbCBmb3IuIEFuIGVwb2NoIHJlZmVycyB0byBvbmUgZnVsbCBjeWNsZVxuICAgICAgICAgKiB0aHJvdWdoIHRoZSB0cmFpbmluZyBkYXRhc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgbl9lcG9jaHM/OiAnYXV0bycgfCBudW1iZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRmluZS10dW5pbmcgam9iIGV2ZW50IG9iamVjdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbmVUdW5pbmdKb2JFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IGlkZW50aWZpZXIuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBmaW5lLXR1bmluZyBqb2Igd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBsb2cgbGV2ZWwgb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgbGV2ZWw6ICdpbmZvJyB8ICd3YXJuJyB8ICdlcnJvcic7XG5cbiAgLyoqXG4gICAqIFRoZSBtZXNzYWdlIG9mIHRoZSBldmVudC5cbiAgICovXG4gIG1lc3NhZ2U6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgXCJmaW5lX3R1bmluZy5qb2IuZXZlbnRcIi5cbiAgICovXG4gIG9iamVjdDogJ2ZpbmVfdHVuaW5nLmpvYi5ldmVudCc7XG5cbiAgLyoqXG4gICAqIFRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG4gICAqL1xuICBkYXRhPzogdW5rbm93bjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXZlbnQuXG4gICAqL1xuICB0eXBlPzogJ21lc3NhZ2UnIHwgJ21ldHJpY3MnO1xufVxuXG5leHBvcnQgdHlwZSBGaW5lVHVuaW5nSm9iSW50ZWdyYXRpb24gPSBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbk9iamVjdDtcblxuLyoqXG4gKiBUaGUgc2V0dGluZ3MgZm9yIHlvdXIgaW50ZWdyYXRpb24gd2l0aCBXZWlnaHRzIGFuZCBCaWFzZXMuIFRoaXMgcGF5bG9hZFxuICogc3BlY2lmaWVzIHRoZSBwcm9qZWN0IHRoYXQgbWV0cmljcyB3aWxsIGJlIHNlbnQgdG8uIE9wdGlvbmFsbHksIHlvdSBjYW4gc2V0IGFuXG4gKiBleHBsaWNpdCBkaXNwbGF5IG5hbWUgZm9yIHlvdXIgcnVuLCBhZGQgdGFncyB0byB5b3VyIHJ1biwgYW5kIHNldCBhIGRlZmF1bHRcbiAqIGVudGl0eSAodGVhbSwgdXNlcm5hbWUsIGV0YykgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHlvdXIgcnVuLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9qZWN0IHRoYXQgdGhlIG5ldyBydW4gd2lsbCBiZSBjcmVhdGVkIHVuZGVyLlxuICAgKi9cbiAgcHJvamVjdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZW50aXR5IHRvIHVzZSBmb3IgdGhlIHJ1bi4gVGhpcyBhbGxvd3MgeW91IHRvIHNldCB0aGUgdGVhbSBvciB1c2VybmFtZSBvZlxuICAgKiB0aGUgV2FuZEIgdXNlciB0aGF0IHlvdSB3b3VsZCBsaWtlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcnVuLiBJZiBub3Qgc2V0LCB0aGVcbiAgICogZGVmYXVsdCBlbnRpdHkgZm9yIHRoZSByZWdpc3RlcmVkIFdhbmRCIEFQSSBrZXkgaXMgdXNlZC5cbiAgICovXG4gIGVudGl0eT86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgZGlzcGxheSBuYW1lIHRvIHNldCBmb3IgdGhlIHJ1bi4gSWYgbm90IHNldCwgd2Ugd2lsbCB1c2UgdGhlIEpvYiBJRCBhcyB0aGVcbiAgICogbmFtZS5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdGFncyB0byBiZSBhdHRhY2hlZCB0byB0aGUgbmV3bHkgY3JlYXRlZCBydW4uIFRoZXNlIHRhZ3MgYXJlIHBhc3NlZFxuICAgKiB0aHJvdWdoIGRpcmVjdGx5IHRvIFdhbmRCLiBTb21lIGRlZmF1bHQgdGFncyBhcmUgZ2VuZXJhdGVkIGJ5IE9wZW5BSTpcbiAgICogXCJvcGVuYWkvZmluZXR1bmVcIiwgXCJvcGVuYWkve2Jhc2UtbW9kZWx9XCIsIFwib3BlbmFpL3tmdGpvYi1hYmNkZWZ9XCIuXG4gICAqL1xuICB0YWdzPzogQXJyYXk8c3RyaW5nPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbk9iamVjdCB7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgaW50ZWdyYXRpb24gYmVpbmcgZW5hYmxlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYlxuICAgKi9cbiAgdHlwZTogJ3dhbmRiJztcblxuICAvKipcbiAgICogVGhlIHNldHRpbmdzIGZvciB5b3VyIGludGVncmF0aW9uIHdpdGggV2VpZ2h0cyBhbmQgQmlhc2VzLiBUaGlzIHBheWxvYWRcbiAgICogc3BlY2lmaWVzIHRoZSBwcm9qZWN0IHRoYXQgbWV0cmljcyB3aWxsIGJlIHNlbnQgdG8uIE9wdGlvbmFsbHksIHlvdSBjYW4gc2V0IGFuXG4gICAqIGV4cGxpY2l0IGRpc3BsYXkgbmFtZSBmb3IgeW91ciBydW4sIGFkZCB0YWdzIHRvIHlvdXIgcnVuLCBhbmQgc2V0IGEgZGVmYXVsdFxuICAgKiBlbnRpdHkgKHRlYW0sIHVzZXJuYW1lLCBldGMpIHRvIGJlIGFzc29jaWF0ZWQgd2l0aCB5b3VyIHJ1bi5cbiAgICovXG4gIHdhbmRiOiBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBKb2JDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIG1vZGVsIHRvIGZpbmUtdHVuZS4gWW91IGNhbiBzZWxlY3Qgb25lIG9mIHRoZVxuICAgKiBbc3VwcG9ydGVkIG1vZGVsc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2ZpbmUtdHVuaW5nI3doaWNoLW1vZGVscy1jYW4tYmUtZmluZS10dW5lZCkuXG4gICAqL1xuICBtb2RlbDogKHN0cmluZyAmIHt9KSB8ICdiYWJiYWdlLTAwMicgfCAnZGF2aW5jaS0wMDInIHwgJ2dwdC0zLjUtdHVyYm8nIHwgJ2dwdC00by1taW5pJztcblxuICAvKipcbiAgICogVGhlIElEIG9mIGFuIHVwbG9hZGVkIGZpbGUgdGhhdCBjb250YWlucyB0cmFpbmluZyBkYXRhLlxuICAgKlxuICAgKiBTZWUgW3VwbG9hZCBmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL2NyZWF0ZSlcbiAgICogZm9yIGhvdyB0byB1cGxvYWQgYSBmaWxlLlxuICAgKlxuICAgKiBZb3VyIGRhdGFzZXQgbXVzdCBiZSBmb3JtYXR0ZWQgYXMgYSBKU09OTCBmaWxlLiBBZGRpdGlvbmFsbHksIHlvdSBtdXN0IHVwbG9hZFxuICAgKiB5b3VyIGZpbGUgd2l0aCB0aGUgcHVycG9zZSBgZmluZS10dW5lYC5cbiAgICpcbiAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSBmaWxlIHNob3VsZCBkaWZmZXIgZGVwZW5kaW5nIG9uIGlmIHRoZSBtb2RlbCB1c2VzIHRoZVxuICAgKiBbY2hhdF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maW5lLXR1bmluZy9jaGF0LWlucHV0KSxcbiAgICogW2NvbXBsZXRpb25zXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuaW5nL2NvbXBsZXRpb25zLWlucHV0KVxuICAgKiBmb3JtYXQsIG9yIGlmIHRoZSBmaW5lLXR1bmluZyBtZXRob2QgdXNlcyB0aGVcbiAgICogW3ByZWZlcmVuY2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmluZS10dW5pbmcvcHJlZmVyZW5jZS1pbnB1dClcbiAgICogZm9ybWF0LlxuICAgKlxuICAgKiBTZWUgdGhlIFtmaW5lLXR1bmluZyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2ZpbmUtdHVuaW5nKVxuICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgdHJhaW5pbmdfZmlsZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuIFRoaXMgdmFsdWUgaXMgbm93IGRlcHJlY2F0ZWRcbiAgICogaW4gZmF2b3Igb2YgYG1ldGhvZGAsIGFuZCBzaG91bGQgYmUgcGFzc2VkIGluIHVuZGVyIHRoZSBgbWV0aG9kYCBwYXJhbWV0ZXIuXG4gICAqL1xuICBoeXBlcnBhcmFtZXRlcnM/OiBKb2JDcmVhdGVQYXJhbXMuSHlwZXJwYXJhbWV0ZXJzO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgaW50ZWdyYXRpb25zIHRvIGVuYWJsZSBmb3IgeW91ciBmaW5lLXR1bmluZyBqb2IuXG4gICAqL1xuICBpbnRlZ3JhdGlvbnM/OiBBcnJheTxKb2JDcmVhdGVQYXJhbXMuSW50ZWdyYXRpb24+IHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1ldGhvZCB1c2VkIGZvciBmaW5lLXR1bmluZy5cbiAgICovXG4gIG1ldGhvZD86IEpvYkNyZWF0ZVBhcmFtcy5NZXRob2Q7XG5cbiAgLyoqXG4gICAqIFRoZSBzZWVkIGNvbnRyb2xzIHRoZSByZXByb2R1Y2liaWxpdHkgb2YgdGhlIGpvYi4gUGFzc2luZyBpbiB0aGUgc2FtZSBzZWVkIGFuZFxuICAgKiBqb2IgcGFyYW1ldGVycyBzaG91bGQgcHJvZHVjZSB0aGUgc2FtZSByZXN1bHRzLCBidXQgbWF5IGRpZmZlciBpbiByYXJlIGNhc2VzLiBJZlxuICAgKiBhIHNlZWQgaXMgbm90IHNwZWNpZmllZCwgb25lIHdpbGwgYmUgZ2VuZXJhdGVkIGZvciB5b3UuXG4gICAqL1xuICBzZWVkPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBzdHJpbmcgb2YgdXAgdG8gNjQgY2hhcmFjdGVycyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8geW91ciBmaW5lLXR1bmVkIG1vZGVsXG4gICAqIG5hbWUuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBhIGBzdWZmaXhgIG9mIFwiY3VzdG9tLW1vZGVsLW5hbWVcIiB3b3VsZCBwcm9kdWNlIGEgbW9kZWwgbmFtZSBsaWtlXG4gICAqIGBmdDpncHQtNG8tbWluaTpvcGVuYWk6Y3VzdG9tLW1vZGVsLW5hbWU6N3A0bFVSZWxgLlxuICAgKi9cbiAgc3VmZml4Pzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIGFuIHVwbG9hZGVkIGZpbGUgdGhhdCBjb250YWlucyB2YWxpZGF0aW9uIGRhdGEuXG4gICAqXG4gICAqIElmIHlvdSBwcm92aWRlIHRoaXMgZmlsZSwgdGhlIGRhdGEgaXMgdXNlZCB0byBnZW5lcmF0ZSB2YWxpZGF0aW9uIG1ldHJpY3NcbiAgICogcGVyaW9kaWNhbGx5IGR1cmluZyBmaW5lLXR1bmluZy4gVGhlc2UgbWV0cmljcyBjYW4gYmUgdmlld2VkIGluIHRoZSBmaW5lLXR1bmluZ1xuICAgKiByZXN1bHRzIGZpbGUuIFRoZSBzYW1lIGRhdGEgc2hvdWxkIG5vdCBiZSBwcmVzZW50IGluIGJvdGggdHJhaW4gYW5kIHZhbGlkYXRpb25cbiAgICogZmlsZXMuXG4gICAqXG4gICAqIFlvdXIgZGF0YXNldCBtdXN0IGJlIGZvcm1hdHRlZCBhcyBhIEpTT05MIGZpbGUuIFlvdSBtdXN0IHVwbG9hZCB5b3VyIGZpbGUgd2l0aFxuICAgKiB0aGUgcHVycG9zZSBgZmluZS10dW5lYC5cbiAgICpcbiAgICogU2VlIHRoZSBbZmluZS10dW5pbmcgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9maW5lLXR1bmluZylcbiAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIHZhbGlkYXRpb25fZmlsZT86IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgSm9iQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkOiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuIFRoaXMgdmFsdWUgaXMgbm93XG4gICAqIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgYG1ldGhvZGAsIGFuZCBzaG91bGQgYmUgcGFzc2VkIGluIHVuZGVyIHRoZSBgbWV0aG9kYFxuICAgKiBwYXJhbWV0ZXIuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEh5cGVycGFyYW1ldGVycyB7XG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGV4YW1wbGVzIGluIGVhY2ggYmF0Y2guIEEgbGFyZ2VyIGJhdGNoIHNpemUgbWVhbnMgdGhhdCBtb2RlbFxuICAgICAqIHBhcmFtZXRlcnMgYXJlIHVwZGF0ZWQgbGVzcyBmcmVxdWVudGx5LCBidXQgd2l0aCBsb3dlciB2YXJpYW5jZS5cbiAgICAgKi9cbiAgICBiYXRjaF9zaXplPzogJ2F1dG8nIHwgbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU2NhbGluZyBmYWN0b3IgZm9yIHRoZSBsZWFybmluZyByYXRlLiBBIHNtYWxsZXIgbGVhcm5pbmcgcmF0ZSBtYXkgYmUgdXNlZnVsIHRvXG4gICAgICogYXZvaWQgb3ZlcmZpdHRpbmcuXG4gICAgICovXG4gICAgbGVhcm5pbmdfcmF0ZV9tdWx0aXBsaWVyPzogJ2F1dG8nIHwgbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBlcG9jaHMgdG8gdHJhaW4gdGhlIG1vZGVsIGZvci4gQW4gZXBvY2ggcmVmZXJzIHRvIG9uZSBmdWxsIGN5Y2xlXG4gICAgICogdGhyb3VnaCB0aGUgdHJhaW5pbmcgZGF0YXNldC5cbiAgICAgKi9cbiAgICBuX2Vwb2Nocz86ICdhdXRvJyB8IG51bWJlcjtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgSW50ZWdyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIGludGVncmF0aW9uIHRvIGVuYWJsZS4gQ3VycmVudGx5LCBvbmx5IFwid2FuZGJcIiAoV2VpZ2h0cyBhbmQgQmlhc2VzKVxuICAgICAqIGlzIHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICB0eXBlOiAnd2FuZGInO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNldHRpbmdzIGZvciB5b3VyIGludGVncmF0aW9uIHdpdGggV2VpZ2h0cyBhbmQgQmlhc2VzLiBUaGlzIHBheWxvYWRcbiAgICAgKiBzcGVjaWZpZXMgdGhlIHByb2plY3QgdGhhdCBtZXRyaWNzIHdpbGwgYmUgc2VudCB0by4gT3B0aW9uYWxseSwgeW91IGNhbiBzZXQgYW5cbiAgICAgKiBleHBsaWNpdCBkaXNwbGF5IG5hbWUgZm9yIHlvdXIgcnVuLCBhZGQgdGFncyB0byB5b3VyIHJ1biwgYW5kIHNldCBhIGRlZmF1bHRcbiAgICAgKiBlbnRpdHkgKHRlYW0sIHVzZXJuYW1lLCBldGMpIHRvIGJlIGFzc29jaWF0ZWQgd2l0aCB5b3VyIHJ1bi5cbiAgICAgKi9cbiAgICB3YW5kYjogSW50ZWdyYXRpb24uV2FuZGI7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIEludGVncmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2V0dGluZ3MgZm9yIHlvdXIgaW50ZWdyYXRpb24gd2l0aCBXZWlnaHRzIGFuZCBCaWFzZXMuIFRoaXMgcGF5bG9hZFxuICAgICAqIHNwZWNpZmllcyB0aGUgcHJvamVjdCB0aGF0IG1ldHJpY3Mgd2lsbCBiZSBzZW50IHRvLiBPcHRpb25hbGx5LCB5b3UgY2FuIHNldCBhblxuICAgICAqIGV4cGxpY2l0IGRpc3BsYXkgbmFtZSBmb3IgeW91ciBydW4sIGFkZCB0YWdzIHRvIHlvdXIgcnVuLCBhbmQgc2V0IGEgZGVmYXVsdFxuICAgICAqIGVudGl0eSAodGVhbSwgdXNlcm5hbWUsIGV0YykgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHlvdXIgcnVuLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgV2FuZGIge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcHJvamVjdCB0aGF0IHRoZSBuZXcgcnVuIHdpbGwgYmUgY3JlYXRlZCB1bmRlci5cbiAgICAgICAqL1xuICAgICAgcHJvamVjdDogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBlbnRpdHkgdG8gdXNlIGZvciB0aGUgcnVuLiBUaGlzIGFsbG93cyB5b3UgdG8gc2V0IHRoZSB0ZWFtIG9yIHVzZXJuYW1lIG9mXG4gICAgICAgKiB0aGUgV2FuZEIgdXNlciB0aGF0IHlvdSB3b3VsZCBsaWtlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcnVuLiBJZiBub3Qgc2V0LCB0aGVcbiAgICAgICAqIGRlZmF1bHQgZW50aXR5IGZvciB0aGUgcmVnaXN0ZXJlZCBXYW5kQiBBUEkga2V5IGlzIHVzZWQuXG4gICAgICAgKi9cbiAgICAgIGVudGl0eT86IHN0cmluZyB8IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBkaXNwbGF5IG5hbWUgdG8gc2V0IGZvciB0aGUgcnVuLiBJZiBub3Qgc2V0LCB3ZSB3aWxsIHVzZSB0aGUgSm9iIElEIGFzIHRoZVxuICAgICAgICogbmFtZS5cbiAgICAgICAqL1xuICAgICAgbmFtZT86IHN0cmluZyB8IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIHRhZ3MgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgcnVuLiBUaGVzZSB0YWdzIGFyZSBwYXNzZWRcbiAgICAgICAqIHRocm91Z2ggZGlyZWN0bHkgdG8gV2FuZEIuIFNvbWUgZGVmYXVsdCB0YWdzIGFyZSBnZW5lcmF0ZWQgYnkgT3BlbkFJOlxuICAgICAgICogXCJvcGVuYWkvZmluZXR1bmVcIiwgXCJvcGVuYWkve2Jhc2UtbW9kZWx9XCIsIFwib3BlbmFpL3tmdGpvYi1hYmNkZWZ9XCIuXG4gICAgICAgKi9cbiAgICAgIHRhZ3M/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbWV0aG9kIHVzZWQgZm9yIGZpbmUtdHVuaW5nLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBNZXRob2Qge1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBEUE8gZmluZS10dW5pbmcgbWV0aG9kLlxuICAgICAqL1xuICAgIGRwbz86IE1ldGhvZC5EcG87XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGZvciB0aGUgc3VwZXJ2aXNlZCBmaW5lLXR1bmluZyBtZXRob2QuXG4gICAgICovXG4gICAgc3VwZXJ2aXNlZD86IE1ldGhvZC5TdXBlcnZpc2VkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgbWV0aG9kLiBJcyBlaXRoZXIgYHN1cGVydmlzZWRgIG9yIGBkcG9gLlxuICAgICAqL1xuICAgIHR5cGU/OiAnc3VwZXJ2aXNlZCcgfCAnZHBvJztcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgTWV0aG9kIHtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGZvciB0aGUgRFBPIGZpbmUtdHVuaW5nIG1ldGhvZC5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIERwbyB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICAgICAqL1xuICAgICAgaHlwZXJwYXJhbWV0ZXJzPzogRHBvLkh5cGVycGFyYW1ldGVycztcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIERwbyB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICAgICAqL1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBIeXBlcnBhcmFtZXRlcnMge1xuICAgICAgICAvKipcbiAgICAgICAgICogTnVtYmVyIG9mIGV4YW1wbGVzIGluIGVhY2ggYmF0Y2guIEEgbGFyZ2VyIGJhdGNoIHNpemUgbWVhbnMgdGhhdCBtb2RlbFxuICAgICAgICAgKiBwYXJhbWV0ZXJzIGFyZSB1cGRhdGVkIGxlc3MgZnJlcXVlbnRseSwgYnV0IHdpdGggbG93ZXIgdmFyaWFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBiYXRjaF9zaXplPzogJ2F1dG8nIHwgbnVtYmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYmV0YSB2YWx1ZSBmb3IgdGhlIERQTyBtZXRob2QuIEEgaGlnaGVyIGJldGEgdmFsdWUgd2lsbCBpbmNyZWFzZSB0aGUgd2VpZ2h0XG4gICAgICAgICAqIG9mIHRoZSBwZW5hbHR5IGJldHdlZW4gdGhlIHBvbGljeSBhbmQgcmVmZXJlbmNlIG1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgYmV0YT86ICdhdXRvJyB8IG51bWJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2NhbGluZyBmYWN0b3IgZm9yIHRoZSBsZWFybmluZyByYXRlLiBBIHNtYWxsZXIgbGVhcm5pbmcgcmF0ZSBtYXkgYmUgdXNlZnVsIHRvXG4gICAgICAgICAqIGF2b2lkIG92ZXJmaXR0aW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgbGVhcm5pbmdfcmF0ZV9tdWx0aXBsaWVyPzogJ2F1dG8nIHwgbnVtYmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGVwb2NocyB0byB0cmFpbiB0aGUgbW9kZWwgZm9yLiBBbiBlcG9jaCByZWZlcnMgdG8gb25lIGZ1bGwgY3ljbGVcbiAgICAgICAgICogdGhyb3VnaCB0aGUgdHJhaW5pbmcgZGF0YXNldC5cbiAgICAgICAgICovXG4gICAgICAgIG5fZXBvY2hzPzogJ2F1dG8nIHwgbnVtYmVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBlcnZpc2VkIGZpbmUtdHVuaW5nIG1ldGhvZC5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIFN1cGVydmlzZWQge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuXG4gICAgICAgKi9cbiAgICAgIGh5cGVycGFyYW1ldGVycz86IFN1cGVydmlzZWQuSHlwZXJwYXJhbWV0ZXJzO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgU3VwZXJ2aXNlZCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICAgICAqL1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBIeXBlcnBhcmFtZXRlcnMge1xuICAgICAgICAvKipcbiAgICAgICAgICogTnVtYmVyIG9mIGV4YW1wbGVzIGluIGVhY2ggYmF0Y2guIEEgbGFyZ2VyIGJhdGNoIHNpemUgbWVhbnMgdGhhdCBtb2RlbFxuICAgICAgICAgKiBwYXJhbWV0ZXJzIGFyZSB1cGRhdGVkIGxlc3MgZnJlcXVlbnRseSwgYnV0IHdpdGggbG93ZXIgdmFyaWFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBiYXRjaF9zaXplPzogJ2F1dG8nIHwgbnVtYmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY2FsaW5nIGZhY3RvciBmb3IgdGhlIGxlYXJuaW5nIHJhdGUuIEEgc21hbGxlciBsZWFybmluZyByYXRlIG1heSBiZSB1c2VmdWwgdG9cbiAgICAgICAgICogYXZvaWQgb3ZlcmZpdHRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBsZWFybmluZ19yYXRlX211bHRpcGxpZXI/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgZXBvY2hzIHRvIHRyYWluIHRoZSBtb2RlbCBmb3IuIEFuIGVwb2NoIHJlZmVycyB0byBvbmUgZnVsbCBjeWNsZVxuICAgICAgICAgKiB0aHJvdWdoIHRoZSB0cmFpbmluZyBkYXRhc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgbl9lcG9jaHM/OiAnYXV0bycgfCBudW1iZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSm9iTGlzdFBhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge31cblxuZXhwb3J0IGludGVyZmFjZSBKb2JMaXN0RXZlbnRzUGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7fVxuXG5Kb2JzLkZpbmVUdW5pbmdKb2JzUGFnZSA9IEZpbmVUdW5pbmdKb2JzUGFnZTtcbkpvYnMuRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UgPSBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZTtcbkpvYnMuQ2hlY2twb2ludHMgPSBDaGVja3BvaW50cztcbkpvYnMuRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSA9IEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBKb2JzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIEZpbmVUdW5pbmdKb2IgYXMgRmluZVR1bmluZ0pvYixcbiAgICB0eXBlIEZpbmVUdW5pbmdKb2JFdmVudCBhcyBGaW5lVHVuaW5nSm9iRXZlbnQsXG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iSW50ZWdyYXRpb24gYXMgRmluZVR1bmluZ0pvYkludGVncmF0aW9uLFxuICAgIHR5cGUgRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb24gYXMgRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb24sXG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbk9iamVjdCBhcyBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbk9iamVjdCxcbiAgICBGaW5lVHVuaW5nSm9ic1BhZ2UgYXMgRmluZVR1bmluZ0pvYnNQYWdlLFxuICAgIEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlIGFzIEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlLFxuICAgIHR5cGUgSm9iQ3JlYXRlUGFyYW1zIGFzIEpvYkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIEpvYkxpc3RQYXJhbXMgYXMgSm9iTGlzdFBhcmFtcyxcbiAgICB0eXBlIEpvYkxpc3RFdmVudHNQYXJhbXMgYXMgSm9iTGlzdEV2ZW50c1BhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIENoZWNrcG9pbnRzIGFzIENoZWNrcG9pbnRzLFxuICAgIHR5cGUgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnQgYXMgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnQsXG4gICAgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSBhcyBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlLFxuICAgIHR5cGUgQ2hlY2twb2ludExpc3RQYXJhbXMgYXMgQ2hlY2twb2ludExpc3RQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBKb2JzQVBJIGZyb20gJy4vam9icy9qb2JzJztcbmltcG9ydCB7XG4gIEZpbmVUdW5pbmdKb2IsXG4gIEZpbmVUdW5pbmdKb2JFdmVudCxcbiAgRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UsXG4gIEZpbmVUdW5pbmdKb2JJbnRlZ3JhdGlvbixcbiAgRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb24sXG4gIEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uT2JqZWN0LFxuICBGaW5lVHVuaW5nSm9ic1BhZ2UsXG4gIEpvYkNyZWF0ZVBhcmFtcyxcbiAgSm9iTGlzdEV2ZW50c1BhcmFtcyxcbiAgSm9iTGlzdFBhcmFtcyxcbiAgSm9icyxcbn0gZnJvbSAnLi9qb2JzL2pvYnMnO1xuXG5leHBvcnQgY2xhc3MgRmluZVR1bmluZyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgam9iczogSm9ic0FQSS5Kb2JzID0gbmV3IEpvYnNBUEkuSm9icyh0aGlzLl9jbGllbnQpO1xufVxuXG5GaW5lVHVuaW5nLkpvYnMgPSBKb2JzO1xuRmluZVR1bmluZy5GaW5lVHVuaW5nSm9ic1BhZ2UgPSBGaW5lVHVuaW5nSm9ic1BhZ2U7XG5GaW5lVHVuaW5nLkZpbmVUdW5pbmdKb2JFdmVudHNQYWdlID0gRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBGaW5lVHVuaW5nIHtcbiAgZXhwb3J0IHtcbiAgICBKb2JzIGFzIEpvYnMsXG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iIGFzIEZpbmVUdW5pbmdKb2IsXG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iRXZlbnQgYXMgRmluZVR1bmluZ0pvYkV2ZW50LFxuICAgIHR5cGUgRmluZVR1bmluZ0pvYkludGVncmF0aW9uIGFzIEZpbmVUdW5pbmdKb2JJbnRlZ3JhdGlvbixcbiAgICB0eXBlIEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uIGFzIEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uLFxuICAgIHR5cGUgRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb25PYmplY3QgYXMgRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb25PYmplY3QsXG4gICAgRmluZVR1bmluZ0pvYnNQYWdlIGFzIEZpbmVUdW5pbmdKb2JzUGFnZSxcbiAgICBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSBhcyBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSxcbiAgICB0eXBlIEpvYkNyZWF0ZVBhcmFtcyBhcyBKb2JDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBKb2JMaXN0UGFyYW1zIGFzIEpvYkxpc3RQYXJhbXMsXG4gICAgdHlwZSBKb2JMaXN0RXZlbnRzUGFyYW1zIGFzIEpvYkxpc3RFdmVudHNQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uL2NvcmUnO1xuXG5leHBvcnQgY2xhc3MgSW1hZ2VzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIHZhcmlhdGlvbiBvZiBhIGdpdmVuIGltYWdlLlxuICAgKi9cbiAgY3JlYXRlVmFyaWF0aW9uKFxuICAgIGJvZHk6IEltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8SW1hZ2VzUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9pbWFnZXMvdmFyaWF0aW9ucycsIENvcmUubXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zKHsgYm9keSwgLi4ub3B0aW9ucyB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBlZGl0ZWQgb3IgZXh0ZW5kZWQgaW1hZ2UgZ2l2ZW4gYW4gb3JpZ2luYWwgaW1hZ2UgYW5kIGEgcHJvbXB0LlxuICAgKi9cbiAgZWRpdChib2R5OiBJbWFnZUVkaXRQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEltYWdlc1Jlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvaW1hZ2VzL2VkaXRzJywgQ29yZS5tdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGltYWdlIGdpdmVuIGEgcHJvbXB0LlxuICAgKi9cbiAgZ2VuZXJhdGUoYm9keTogSW1hZ2VHZW5lcmF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8SW1hZ2VzUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9pbWFnZXMvZ2VuZXJhdGlvbnMnLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB1cmwgb3IgdGhlIGNvbnRlbnQgb2YgYW4gaW1hZ2UgZ2VuZXJhdGVkIGJ5IHRoZSBPcGVuQUkgQVBJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlIHtcbiAgLyoqXG4gICAqIFRoZSBiYXNlNjQtZW5jb2RlZCBKU09OIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2UsIGlmIGByZXNwb25zZV9mb3JtYXRgIGlzXG4gICAqIGBiNjRfanNvbmAuXG4gICAqL1xuICBiNjRfanNvbj86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHByb21wdCB0aGF0IHdhcyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBpbWFnZSwgaWYgdGhlcmUgd2FzIGFueSByZXZpc2lvbiB0byB0aGVcbiAgICogcHJvbXB0LlxuICAgKi9cbiAgcmV2aXNlZF9wcm9tcHQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVUkwgb2YgdGhlIGdlbmVyYXRlZCBpbWFnZSwgaWYgYHJlc3BvbnNlX2Zvcm1hdGAgaXMgYHVybGAgKGRlZmF1bHQpLlxuICAgKi9cbiAgdXJsPzogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBJbWFnZU1vZGVsID0gJ2RhbGwtZS0yJyB8ICdkYWxsLWUtMyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VzUmVzcG9uc2Uge1xuICBjcmVhdGVkOiBudW1iZXI7XG5cbiAgZGF0YTogQXJyYXk8SW1hZ2U+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBpbWFnZSB0byB1c2UgYXMgdGhlIGJhc2lzIGZvciB0aGUgdmFyaWF0aW9uKHMpLiBNdXN0IGJlIGEgdmFsaWQgUE5HIGZpbGUsXG4gICAqIGxlc3MgdGhhbiA0TUIsIGFuZCBzcXVhcmUuXG4gICAqL1xuICBpbWFnZTogQ29yZS5VcGxvYWRhYmxlO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdG8gdXNlIGZvciBpbWFnZSBnZW5lcmF0aW9uLiBPbmx5IGBkYWxsLWUtMmAgaXMgc3VwcG9ydGVkIGF0IHRoaXNcbiAgICogdGltZS5cbiAgICovXG4gIG1vZGVsPzogKHN0cmluZyAmIHt9KSB8IEltYWdlTW9kZWwgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGltYWdlcyB0byBnZW5lcmF0ZS4gTXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDEwLiBGb3IgYGRhbGwtZS0zYCwgb25seVxuICAgKiBgbj0xYCBpcyBzdXBwb3J0ZWQuXG4gICAqL1xuICBuPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCBpbiB3aGljaCB0aGUgZ2VuZXJhdGVkIGltYWdlcyBhcmUgcmV0dXJuZWQuIE11c3QgYmUgb25lIG9mIGB1cmxgIG9yXG4gICAqIGBiNjRfanNvbmAuIFVSTHMgYXJlIG9ubHkgdmFsaWQgZm9yIDYwIG1pbnV0ZXMgYWZ0ZXIgdGhlIGltYWdlIGhhcyBiZWVuXG4gICAqIGdlbmVyYXRlZC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86ICd1cmwnIHwgJ2I2NF9qc29uJyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBNdXN0IGJlIG9uZSBvZiBgMjU2eDI1NmAsIGA1MTJ4NTEyYCwgb3JcbiAgICogYDEwMjR4MTAyNGAuXG4gICAqL1xuICBzaXplPzogJzI1NngyNTYnIHwgJzUxMng1MTInIHwgJzEwMjR4MTAyNCcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIHJlcHJlc2VudGluZyB5b3VyIGVuZC11c2VyLCB3aGljaCBjYW4gaGVscCBPcGVuQUkgdG8gbW9uaXRvclxuICAgKiBhbmQgZGV0ZWN0IGFidXNlLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3NhZmV0eS1iZXN0LXByYWN0aWNlcyNlbmQtdXNlci1pZHMpLlxuICAgKi9cbiAgdXNlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZUVkaXRQYXJhbXMge1xuICAvKipcbiAgICogVGhlIGltYWdlIHRvIGVkaXQuIE11c3QgYmUgYSB2YWxpZCBQTkcgZmlsZSwgbGVzcyB0aGFuIDRNQiwgYW5kIHNxdWFyZS4gSWYgbWFza1xuICAgKiBpcyBub3QgcHJvdmlkZWQsIGltYWdlIG11c3QgaGF2ZSB0cmFuc3BhcmVuY3ksIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyB0aGUgbWFzay5cbiAgICovXG4gIGltYWdlOiBDb3JlLlVwbG9hZGFibGU7XG5cbiAgLyoqXG4gICAqIEEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgZGVzaXJlZCBpbWFnZShzKS4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDEwMDBcbiAgICogY2hhcmFjdGVycy5cbiAgICovXG4gIHByb21wdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbiBhZGRpdGlvbmFsIGltYWdlIHdob3NlIGZ1bGx5IHRyYW5zcGFyZW50IGFyZWFzIChlLmcuIHdoZXJlIGFscGhhIGlzIHplcm8pXG4gICAqIGluZGljYXRlIHdoZXJlIGBpbWFnZWAgc2hvdWxkIGJlIGVkaXRlZC4gTXVzdCBiZSBhIHZhbGlkIFBORyBmaWxlLCBsZXNzIHRoYW5cbiAgICogNE1CLCBhbmQgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zIGFzIGBpbWFnZWAuXG4gICAqL1xuICBtYXNrPzogQ29yZS5VcGxvYWRhYmxlO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdG8gdXNlIGZvciBpbWFnZSBnZW5lcmF0aW9uLiBPbmx5IGBkYWxsLWUtMmAgaXMgc3VwcG9ydGVkIGF0IHRoaXNcbiAgICogdGltZS5cbiAgICovXG4gIG1vZGVsPzogKHN0cmluZyAmIHt9KSB8IEltYWdlTW9kZWwgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGltYWdlcyB0byBnZW5lcmF0ZS4gTXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDEwLlxuICAgKi9cbiAgbj86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgaW4gd2hpY2ggdGhlIGdlbmVyYXRlZCBpbWFnZXMgYXJlIHJldHVybmVkLiBNdXN0IGJlIG9uZSBvZiBgdXJsYCBvclxuICAgKiBgYjY0X2pzb25gLiBVUkxzIGFyZSBvbmx5IHZhbGlkIGZvciA2MCBtaW51dGVzIGFmdGVyIHRoZSBpbWFnZSBoYXMgYmVlblxuICAgKiBnZW5lcmF0ZWQuXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiAndXJsJyB8ICdiNjRfanNvbicgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIGltYWdlcy4gTXVzdCBiZSBvbmUgb2YgYDI1NngyNTZgLCBgNTEyeDUxMmAsIG9yXG4gICAqIGAxMDI0eDEwMjRgLlxuICAgKi9cbiAgc2l6ZT86ICcyNTZ4MjU2JyB8ICc1MTJ4NTEyJyB8ICcxMDI0eDEwMjQnIHwgbnVsbDtcblxuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciByZXByZXNlbnRpbmcgeW91ciBlbmQtdXNlciwgd2hpY2ggY2FuIGhlbHAgT3BlbkFJIHRvIG1vbml0b3JcbiAgICogYW5kIGRldGVjdCBhYnVzZS5cbiAgICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zYWZldHktYmVzdC1wcmFjdGljZXMjZW5kLXVzZXItaWRzKS5cbiAgICovXG4gIHVzZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VHZW5lcmF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGRlc2lyZWQgaW1hZ2UocykuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyAxMDAwXG4gICAqIGNoYXJhY3RlcnMgZm9yIGBkYWxsLWUtMmAgYW5kIDQwMDAgY2hhcmFjdGVycyBmb3IgYGRhbGwtZS0zYC5cbiAgICovXG4gIHByb21wdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdG8gdXNlIGZvciBpbWFnZSBnZW5lcmF0aW9uLlxuICAgKi9cbiAgbW9kZWw/OiAoc3RyaW5nICYge30pIHwgSW1hZ2VNb2RlbCB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgaW1hZ2VzIHRvIGdlbmVyYXRlLiBNdXN0IGJlIGJldHdlZW4gMSBhbmQgMTAuIEZvciBgZGFsbC1lLTNgLCBvbmx5XG4gICAqIGBuPTFgIGlzIHN1cHBvcnRlZC5cbiAgICovXG4gIG4/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgcXVhbGl0eSBvZiB0aGUgaW1hZ2UgdGhhdCB3aWxsIGJlIGdlbmVyYXRlZC4gYGhkYCBjcmVhdGVzIGltYWdlcyB3aXRoIGZpbmVyXG4gICAqIGRldGFpbHMgYW5kIGdyZWF0ZXIgY29uc2lzdGVuY3kgYWNyb3NzIHRoZSBpbWFnZS4gVGhpcyBwYXJhbSBpcyBvbmx5IHN1cHBvcnRlZFxuICAgKiBmb3IgYGRhbGwtZS0zYC5cbiAgICovXG4gIHF1YWxpdHk/OiAnc3RhbmRhcmQnIHwgJ2hkJztcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCBpbiB3aGljaCB0aGUgZ2VuZXJhdGVkIGltYWdlcyBhcmUgcmV0dXJuZWQuIE11c3QgYmUgb25lIG9mIGB1cmxgIG9yXG4gICAqIGBiNjRfanNvbmAuIFVSTHMgYXJlIG9ubHkgdmFsaWQgZm9yIDYwIG1pbnV0ZXMgYWZ0ZXIgdGhlIGltYWdlIGhhcyBiZWVuXG4gICAqIGdlbmVyYXRlZC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86ICd1cmwnIHwgJ2I2NF9qc29uJyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBNdXN0IGJlIG9uZSBvZiBgMjU2eDI1NmAsIGA1MTJ4NTEyYCwgb3JcbiAgICogYDEwMjR4MTAyNGAgZm9yIGBkYWxsLWUtMmAuIE11c3QgYmUgb25lIG9mIGAxMDI0eDEwMjRgLCBgMTc5MngxMDI0YCwgb3JcbiAgICogYDEwMjR4MTc5MmAgZm9yIGBkYWxsLWUtM2AgbW9kZWxzLlxuICAgKi9cbiAgc2l6ZT86ICcyNTZ4MjU2JyB8ICc1MTJ4NTEyJyB8ICcxMDI0eDEwMjQnIHwgJzE3OTJ4MTAyNCcgfCAnMTAyNHgxNzkyJyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzdHlsZSBvZiB0aGUgZ2VuZXJhdGVkIGltYWdlcy4gTXVzdCBiZSBvbmUgb2YgYHZpdmlkYCBvciBgbmF0dXJhbGAuIFZpdmlkXG4gICAqIGNhdXNlcyB0aGUgbW9kZWwgdG8gbGVhbiB0b3dhcmRzIGdlbmVyYXRpbmcgaHlwZXItcmVhbCBhbmQgZHJhbWF0aWMgaW1hZ2VzLlxuICAgKiBOYXR1cmFsIGNhdXNlcyB0aGUgbW9kZWwgdG8gcHJvZHVjZSBtb3JlIG5hdHVyYWwsIGxlc3MgaHlwZXItcmVhbCBsb29raW5nXG4gICAqIGltYWdlcy4gVGhpcyBwYXJhbSBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgYGRhbGwtZS0zYC5cbiAgICovXG4gIHN0eWxlPzogJ3ZpdmlkJyB8ICduYXR1cmFsJyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgcmVwcmVzZW50aW5nIHlvdXIgZW5kLXVzZXIsIHdoaWNoIGNhbiBoZWxwIE9wZW5BSSB0byBtb25pdG9yXG4gICAqIGFuZCBkZXRlY3QgYWJ1c2UuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc2FmZXR5LWJlc3QtcHJhY3RpY2VzI2VuZC11c2VyLWlkcykuXG4gICAqL1xuICB1c2VyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgSW1hZ2VzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIEltYWdlIGFzIEltYWdlLFxuICAgIHR5cGUgSW1hZ2VNb2RlbCBhcyBJbWFnZU1vZGVsLFxuICAgIHR5cGUgSW1hZ2VzUmVzcG9uc2UgYXMgSW1hZ2VzUmVzcG9uc2UsXG4gICAgdHlwZSBJbWFnZUNyZWF0ZVZhcmlhdGlvblBhcmFtcyBhcyBJbWFnZUNyZWF0ZVZhcmlhdGlvblBhcmFtcyxcbiAgICB0eXBlIEltYWdlRWRpdFBhcmFtcyBhcyBJbWFnZUVkaXRQYXJhbXMsXG4gICAgdHlwZSBJbWFnZUdlbmVyYXRlUGFyYW1zIGFzIEltYWdlR2VuZXJhdGVQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gJy4uL3BhZ2luYXRpb24nO1xuXG5leHBvcnQgY2xhc3MgTW9kZWxzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogUmV0cmlldmVzIGEgbW9kZWwgaW5zdGFuY2UsIHByb3ZpZGluZyBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbW9kZWwgc3VjaCBhc1xuICAgKiB0aGUgb3duZXIgYW5kIHBlcm1pc3Npb25pbmcuXG4gICAqL1xuICByZXRyaWV2ZShtb2RlbDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxNb2RlbD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvbW9kZWxzLyR7bW9kZWx9YCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdHMgdGhlIGN1cnJlbnRseSBhdmFpbGFibGUgbW9kZWxzLCBhbmQgcHJvdmlkZXMgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgZWFjaFxuICAgKiBvbmUgc3VjaCBhcyB0aGUgb3duZXIgYW5kIGF2YWlsYWJpbGl0eS5cbiAgICovXG4gIGxpc3Qob3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPE1vZGVsc1BhZ2UsIE1vZGVsPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KCcvbW9kZWxzJywgTW9kZWxzUGFnZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgZmluZS10dW5lZCBtb2RlbC4gWW91IG11c3QgaGF2ZSB0aGUgT3duZXIgcm9sZSBpbiB5b3VyIG9yZ2FuaXphdGlvbiB0b1xuICAgKiBkZWxldGUgYSBtb2RlbC5cbiAgICovXG4gIGRlbChtb2RlbDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxNb2RlbERlbGV0ZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL21vZGVscy8ke21vZGVsfWAsIG9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogTm90ZTogbm8gcGFnaW5hdGlvbiBhY3R1YWxseSBvY2N1cnMgeWV0LCB0aGlzIGlzIGZvciBmb3J3YXJkcy1jb21wYXRpYmlsaXR5LlxuICovXG5leHBvcnQgY2xhc3MgTW9kZWxzUGFnZSBleHRlbmRzIFBhZ2U8TW9kZWw+IHt9XG5cbi8qKlxuICogRGVzY3JpYmVzIGFuIE9wZW5BSSBtb2RlbCBvZmZlcmluZyB0aGF0IGNhbiBiZSB1c2VkIHdpdGggdGhlIEFQSS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNb2RlbCB7XG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gdGhlIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIHdoZW4gdGhlIG1vZGVsIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcIm1vZGVsXCIuXG4gICAqL1xuICBvYmplY3Q6ICdtb2RlbCc7XG5cbiAgLyoqXG4gICAqIFRoZSBvcmdhbml6YXRpb24gdGhhdCBvd25zIHRoZSBtb2RlbC5cbiAgICovXG4gIG93bmVkX2J5OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZWxEZWxldGVkIHtcbiAgaWQ6IHN0cmluZztcblxuICBkZWxldGVkOiBib29sZWFuO1xuXG4gIG9iamVjdDogc3RyaW5nO1xufVxuXG5Nb2RlbHMuTW9kZWxzUGFnZSA9IE1vZGVsc1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBNb2RlbHMge1xuICBleHBvcnQgeyB0eXBlIE1vZGVsIGFzIE1vZGVsLCB0eXBlIE1vZGVsRGVsZXRlZCBhcyBNb2RlbERlbGV0ZWQsIE1vZGVsc1BhZ2UgYXMgTW9kZWxzUGFnZSB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi9jb3JlJztcblxuZXhwb3J0IGNsYXNzIE1vZGVyYXRpb25zIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ2xhc3NpZmllcyBpZiB0ZXh0IGFuZC9vciBpbWFnZSBpbnB1dHMgYXJlIHBvdGVudGlhbGx5IGhhcm1mdWwuIExlYXJuIG1vcmUgaW5cbiAgICogdGhlIFttb2RlcmF0aW9uIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvbW9kZXJhdGlvbikuXG4gICAqL1xuICBjcmVhdGUoXG4gICAgYm9keTogTW9kZXJhdGlvbkNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPE1vZGVyYXRpb25DcmVhdGVSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL21vZGVyYXRpb25zJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZXJhdGlvbiB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdGhlIGNhdGVnb3JpZXMsIGFuZCB3aGV0aGVyIHRoZXkgYXJlIGZsYWdnZWQgb3Igbm90LlxuICAgKi9cbiAgY2F0ZWdvcmllczogTW9kZXJhdGlvbi5DYXRlZ29yaWVzO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdGhlIGNhdGVnb3JpZXMgYWxvbmcgd2l0aCB0aGUgaW5wdXQgdHlwZShzKSB0aGF0IHRoZSBzY29yZSBhcHBsaWVzIHRvLlxuICAgKi9cbiAgY2F0ZWdvcnlfYXBwbGllZF9pbnB1dF90eXBlczogTW9kZXJhdGlvbi5DYXRlZ29yeUFwcGxpZWRJbnB1dFR5cGVzO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdGhlIGNhdGVnb3JpZXMgYWxvbmcgd2l0aCB0aGVpciBzY29yZXMgYXMgcHJlZGljdGVkIGJ5IG1vZGVsLlxuICAgKi9cbiAgY2F0ZWdvcnlfc2NvcmVzOiBNb2RlcmF0aW9uLkNhdGVnb3J5U2NvcmVzO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGFueSBvZiB0aGUgYmVsb3cgY2F0ZWdvcmllcyBhcmUgZmxhZ2dlZC5cbiAgICovXG4gIGZsYWdnZWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgTW9kZXJhdGlvbiB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdGhlIGNhdGVnb3JpZXMsIGFuZCB3aGV0aGVyIHRoZXkgYXJlIGZsYWdnZWQgb3Igbm90LlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDYXRlZ29yaWVzIHtcbiAgICAvKipcbiAgICAgKiBDb250ZW50IHRoYXQgZXhwcmVzc2VzLCBpbmNpdGVzLCBvciBwcm9tb3RlcyBoYXJhc3NpbmcgbGFuZ3VhZ2UgdG93YXJkcyBhbnlcbiAgICAgKiB0YXJnZXQuXG4gICAgICovXG4gICAgaGFyYXNzbWVudDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEhhcmFzc21lbnQgY29udGVudCB0aGF0IGFsc28gaW5jbHVkZXMgdmlvbGVuY2Ugb3Igc2VyaW91cyBoYXJtIHRvd2FyZHMgYW55XG4gICAgICogdGFyZ2V0LlxuICAgICAqL1xuICAgICdoYXJhc3NtZW50L3RocmVhdGVuaW5nJzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgdGhhdCBleHByZXNzZXMsIGluY2l0ZXMsIG9yIHByb21vdGVzIGhhdGUgYmFzZWQgb24gcmFjZSwgZ2VuZGVyLFxuICAgICAqIGV0aG5pY2l0eSwgcmVsaWdpb24sIG5hdGlvbmFsaXR5LCBzZXh1YWwgb3JpZW50YXRpb24sIGRpc2FiaWxpdHkgc3RhdHVzLCBvclxuICAgICAqIGNhc3RlLiBIYXRlZnVsIGNvbnRlbnQgYWltZWQgYXQgbm9uLXByb3RlY3RlZCBncm91cHMgKGUuZy4sIGNoZXNzIHBsYXllcnMpIGlzXG4gICAgICogaGFyYXNzbWVudC5cbiAgICAgKi9cbiAgICBoYXRlOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogSGF0ZWZ1bCBjb250ZW50IHRoYXQgYWxzbyBpbmNsdWRlcyB2aW9sZW5jZSBvciBzZXJpb3VzIGhhcm0gdG93YXJkcyB0aGUgdGFyZ2V0ZWRcbiAgICAgKiBncm91cCBiYXNlZCBvbiByYWNlLCBnZW5kZXIsIGV0aG5pY2l0eSwgcmVsaWdpb24sIG5hdGlvbmFsaXR5LCBzZXh1YWxcbiAgICAgKiBvcmllbnRhdGlvbiwgZGlzYWJpbGl0eSBzdGF0dXMsIG9yIGNhc3RlLlxuICAgICAqL1xuICAgICdoYXRlL3RocmVhdGVuaW5nJzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgdGhhdCBpbmNsdWRlcyBpbnN0cnVjdGlvbnMgb3IgYWR2aWNlIHRoYXQgZmFjaWxpdGF0ZSB0aGUgcGxhbm5pbmcgb3JcbiAgICAgKiBleGVjdXRpb24gb2Ygd3Jvbmdkb2luZywgb3IgdGhhdCBnaXZlcyBhZHZpY2Ugb3IgaW5zdHJ1Y3Rpb24gb24gaG93IHRvIGNvbW1pdFxuICAgICAqIGlsbGljaXQgYWN0cy4gRm9yIGV4YW1wbGUsIFwiaG93IHRvIHNob3BsaWZ0XCIgd291bGQgZml0IHRoaXMgY2F0ZWdvcnkuXG4gICAgICovXG4gICAgaWxsaWNpdDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgdGhhdCBpbmNsdWRlcyBpbnN0cnVjdGlvbnMgb3IgYWR2aWNlIHRoYXQgZmFjaWxpdGF0ZSB0aGUgcGxhbm5pbmcgb3JcbiAgICAgKiBleGVjdXRpb24gb2Ygd3Jvbmdkb2luZyB0aGF0IGFsc28gaW5jbHVkZXMgdmlvbGVuY2UsIG9yIHRoYXQgZ2l2ZXMgYWR2aWNlIG9yXG4gICAgICogaW5zdHJ1Y3Rpb24gb24gdGhlIHByb2N1cmVtZW50IG9mIGFueSB3ZWFwb24uXG4gICAgICovXG4gICAgJ2lsbGljaXQvdmlvbGVudCc6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IHRoYXQgcHJvbW90ZXMsIGVuY291cmFnZXMsIG9yIGRlcGljdHMgYWN0cyBvZiBzZWxmLWhhcm0sIHN1Y2ggYXNcbiAgICAgKiBzdWljaWRlLCBjdXR0aW5nLCBhbmQgZWF0aW5nIGRpc29yZGVycy5cbiAgICAgKi9cbiAgICAnc2VsZi1oYXJtJzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgdGhhdCBlbmNvdXJhZ2VzIHBlcmZvcm1pbmcgYWN0cyBvZiBzZWxmLWhhcm0sIHN1Y2ggYXMgc3VpY2lkZSwgY3V0dGluZyxcbiAgICAgKiBhbmQgZWF0aW5nIGRpc29yZGVycywgb3IgdGhhdCBnaXZlcyBpbnN0cnVjdGlvbnMgb3IgYWR2aWNlIG9uIGhvdyB0byBjb21taXQgc3VjaFxuICAgICAqIGFjdHMuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybS9pbnN0cnVjdGlvbnMnOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB3aGVyZSB0aGUgc3BlYWtlciBleHByZXNzZXMgdGhhdCB0aGV5IGFyZSBlbmdhZ2luZyBvciBpbnRlbmQgdG8gZW5nYWdlXG4gICAgICogaW4gYWN0cyBvZiBzZWxmLWhhcm0sIHN1Y2ggYXMgc3VpY2lkZSwgY3V0dGluZywgYW5kIGVhdGluZyBkaXNvcmRlcnMuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybS9pbnRlbnQnOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCBtZWFudCB0byBhcm91c2Ugc2V4dWFsIGV4Y2l0ZW1lbnQsIHN1Y2ggYXMgdGhlIGRlc2NyaXB0aW9uIG9mIHNleHVhbFxuICAgICAqIGFjdGl2aXR5LCBvciB0aGF0IHByb21vdGVzIHNleHVhbCBzZXJ2aWNlcyAoZXhjbHVkaW5nIHNleCBlZHVjYXRpb24gYW5kXG4gICAgICogd2VsbG5lc3MpLlxuICAgICAqL1xuICAgIHNleHVhbDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFNleHVhbCBjb250ZW50IHRoYXQgaW5jbHVkZXMgYW4gaW5kaXZpZHVhbCB3aG8gaXMgdW5kZXIgMTggeWVhcnMgb2xkLlxuICAgICAqL1xuICAgICdzZXh1YWwvbWlub3JzJzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgdGhhdCBkZXBpY3RzIGRlYXRoLCB2aW9sZW5jZSwgb3IgcGh5c2ljYWwgaW5qdXJ5LlxuICAgICAqL1xuICAgIHZpb2xlbmNlOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB0aGF0IGRlcGljdHMgZGVhdGgsIHZpb2xlbmNlLCBvciBwaHlzaWNhbCBpbmp1cnkgaW4gZ3JhcGhpYyBkZXRhaWwuXG4gICAgICovXG4gICAgJ3Zpb2xlbmNlL2dyYXBoaWMnOiBib29sZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0aGUgY2F0ZWdvcmllcyBhbG9uZyB3aXRoIHRoZSBpbnB1dCB0eXBlKHMpIHRoYXQgdGhlIHNjb3JlIGFwcGxpZXMgdG8uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIENhdGVnb3J5QXBwbGllZElucHV0VHlwZXMge1xuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAnaGFyYXNzbWVudCcuXG4gICAgICovXG4gICAgaGFyYXNzbWVudDogQXJyYXk8J3RleHQnPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAnaGFyYXNzbWVudC90aHJlYXRlbmluZycuXG4gICAgICovXG4gICAgJ2hhcmFzc21lbnQvdGhyZWF0ZW5pbmcnOiBBcnJheTwndGV4dCc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICdoYXRlJy5cbiAgICAgKi9cbiAgICBoYXRlOiBBcnJheTwndGV4dCc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICdoYXRlL3RocmVhdGVuaW5nJy5cbiAgICAgKi9cbiAgICAnaGF0ZS90aHJlYXRlbmluZyc6IEFycmF5PCd0ZXh0Jz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ2lsbGljaXQnLlxuICAgICAqL1xuICAgIGlsbGljaXQ6IEFycmF5PCd0ZXh0Jz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ2lsbGljaXQvdmlvbGVudCcuXG4gICAgICovXG4gICAgJ2lsbGljaXQvdmlvbGVudCc6IEFycmF5PCd0ZXh0Jz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ3NlbGYtaGFybScuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybSc6IEFycmF5PCd0ZXh0JyB8ICdpbWFnZSc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICdzZWxmLWhhcm0vaW5zdHJ1Y3Rpb25zJy5cbiAgICAgKi9cbiAgICAnc2VsZi1oYXJtL2luc3RydWN0aW9ucyc6IEFycmF5PCd0ZXh0JyB8ICdpbWFnZSc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICdzZWxmLWhhcm0vaW50ZW50Jy5cbiAgICAgKi9cbiAgICAnc2VsZi1oYXJtL2ludGVudCc6IEFycmF5PCd0ZXh0JyB8ICdpbWFnZSc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICdzZXh1YWwnLlxuICAgICAqL1xuICAgIHNleHVhbDogQXJyYXk8J3RleHQnIHwgJ2ltYWdlJz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ3NleHVhbC9taW5vcnMnLlxuICAgICAqL1xuICAgICdzZXh1YWwvbWlub3JzJzogQXJyYXk8J3RleHQnPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAndmlvbGVuY2UnLlxuICAgICAqL1xuICAgIHZpb2xlbmNlOiBBcnJheTwndGV4dCcgfCAnaW1hZ2UnPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAndmlvbGVuY2UvZ3JhcGhpYycuXG4gICAgICovXG4gICAgJ3Zpb2xlbmNlL2dyYXBoaWMnOiBBcnJheTwndGV4dCcgfCAnaW1hZ2UnPjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdGhlIGNhdGVnb3JpZXMgYWxvbmcgd2l0aCB0aGVpciBzY29yZXMgYXMgcHJlZGljdGVkIGJ5IG1vZGVsLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDYXRlZ29yeVNjb3JlcyB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ2hhcmFzc21lbnQnLlxuICAgICAqL1xuICAgIGhhcmFzc21lbnQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdoYXJhc3NtZW50L3RocmVhdGVuaW5nJy5cbiAgICAgKi9cbiAgICAnaGFyYXNzbWVudC90aHJlYXRlbmluZyc6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdoYXRlJy5cbiAgICAgKi9cbiAgICBoYXRlOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnaGF0ZS90aHJlYXRlbmluZycuXG4gICAgICovXG4gICAgJ2hhdGUvdGhyZWF0ZW5pbmcnOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnaWxsaWNpdCcuXG4gICAgICovXG4gICAgaWxsaWNpdDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ2lsbGljaXQvdmlvbGVudCcuXG4gICAgICovXG4gICAgJ2lsbGljaXQvdmlvbGVudCc6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdzZWxmLWhhcm0nLlxuICAgICAqL1xuICAgICdzZWxmLWhhcm0nOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnc2VsZi1oYXJtL2luc3RydWN0aW9ucycuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybS9pbnN0cnVjdGlvbnMnOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnc2VsZi1oYXJtL2ludGVudCcuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybS9pbnRlbnQnOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnc2V4dWFsJy5cbiAgICAgKi9cbiAgICBzZXh1YWw6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdzZXh1YWwvbWlub3JzJy5cbiAgICAgKi9cbiAgICAnc2V4dWFsL21pbm9ycyc6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICd2aW9sZW5jZScuXG4gICAgICovXG4gICAgdmlvbGVuY2U6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICd2aW9sZW5jZS9ncmFwaGljJy5cbiAgICAgKi9cbiAgICAndmlvbGVuY2UvZ3JhcGhpYyc6IG51bWJlcjtcbiAgfVxufVxuXG4vKipcbiAqIEFuIG9iamVjdCBkZXNjcmliaW5nIGFuIGltYWdlIHRvIGNsYXNzaWZ5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVyYXRpb25JbWFnZVVSTElucHV0IHtcbiAgLyoqXG4gICAqIENvbnRhaW5zIGVpdGhlciBhbiBpbWFnZSBVUkwgb3IgYSBkYXRhIFVSTCBmb3IgYSBiYXNlNjQgZW5jb2RlZCBpbWFnZS5cbiAgICovXG4gIGltYWdlX3VybDogTW9kZXJhdGlvbkltYWdlVVJMSW5wdXQuSW1hZ2VVUkw7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgaW1hZ2VfdXJsYC5cbiAgICovXG4gIHR5cGU6ICdpbWFnZV91cmwnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIE1vZGVyYXRpb25JbWFnZVVSTElucHV0IHtcbiAgLyoqXG4gICAqIENvbnRhaW5zIGVpdGhlciBhbiBpbWFnZSBVUkwgb3IgYSBkYXRhIFVSTCBmb3IgYSBiYXNlNjQgZW5jb2RlZCBpbWFnZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VVUkwge1xuICAgIC8qKlxuICAgICAqIEVpdGhlciBhIFVSTCBvZiB0aGUgaW1hZ2Ugb3IgdGhlIGJhc2U2NCBlbmNvZGVkIGltYWdlIGRhdGEuXG4gICAgICovXG4gICAgdXJsOiBzdHJpbmc7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgTW9kZXJhdGlvbk1vZGVsID1cbiAgfCAnb21uaS1tb2RlcmF0aW9uLWxhdGVzdCdcbiAgfCAnb21uaS1tb2RlcmF0aW9uLTIwMjQtMDktMjYnXG4gIHwgJ3RleHQtbW9kZXJhdGlvbi1sYXRlc3QnXG4gIHwgJ3RleHQtbW9kZXJhdGlvbi1zdGFibGUnO1xuXG4vKipcbiAqIEFuIG9iamVjdCBkZXNjcmliaW5nIGFuIGltYWdlIHRvIGNsYXNzaWZ5LlxuICovXG5leHBvcnQgdHlwZSBNb2RlcmF0aW9uTXVsdGlNb2RhbElucHV0ID0gTW9kZXJhdGlvbkltYWdlVVJMSW5wdXQgfCBNb2RlcmF0aW9uVGV4dElucHV0O1xuXG4vKipcbiAqIEFuIG9iamVjdCBkZXNjcmliaW5nIHRleHQgdG8gY2xhc3NpZnkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZXJhdGlvblRleHRJbnB1dCB7XG4gIC8qKlxuICAgKiBBIHN0cmluZyBvZiB0ZXh0IHRvIGNsYXNzaWZ5LlxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYHRleHRgLlxuICAgKi9cbiAgdHlwZTogJ3RleHQnO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgaWYgYSBnaXZlbiB0ZXh0IGlucHV0IGlzIHBvdGVudGlhbGx5IGhhcm1mdWwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZXJhdGlvbkNyZWF0ZVJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIG1vZGVyYXRpb24gcmVxdWVzdC5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlbCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBtb2RlcmF0aW9uIHJlc3VsdHMuXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgbW9kZXJhdGlvbiBvYmplY3RzLlxuICAgKi9cbiAgcmVzdWx0czogQXJyYXk8TW9kZXJhdGlvbj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZXJhdGlvbkNyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBJbnB1dCAob3IgaW5wdXRzKSB0byBjbGFzc2lmeS4gQ2FuIGJlIGEgc2luZ2xlIHN0cmluZywgYW4gYXJyYXkgb2Ygc3RyaW5ncywgb3JcbiAgICogYW4gYXJyYXkgb2YgbXVsdGktbW9kYWwgaW5wdXQgb2JqZWN0cyBzaW1pbGFyIHRvIG90aGVyIG1vZGVscy5cbiAgICovXG4gIGlucHV0OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+IHwgQXJyYXk8TW9kZXJhdGlvbk11bHRpTW9kYWxJbnB1dD47XG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG1vZGVyYXRpb24gbW9kZWwgeW91IHdvdWxkIGxpa2UgdG8gdXNlLiBMZWFybiBtb3JlIGluXG4gICAqIFt0aGUgbW9kZXJhdGlvbiBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL21vZGVyYXRpb24pLCBhbmRcbiAgICogbGVhcm4gYWJvdXQgYXZhaWxhYmxlIG1vZGVsc1xuICAgKiBbaGVyZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI21vZGVyYXRpb24pLlxuICAgKi9cbiAgbW9kZWw/OiAoc3RyaW5nICYge30pIHwgTW9kZXJhdGlvbk1vZGVsO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgTW9kZXJhdGlvbnMge1xuICBleHBvcnQge1xuICAgIHR5cGUgTW9kZXJhdGlvbiBhcyBNb2RlcmF0aW9uLFxuICAgIHR5cGUgTW9kZXJhdGlvbkltYWdlVVJMSW5wdXQgYXMgTW9kZXJhdGlvbkltYWdlVVJMSW5wdXQsXG4gICAgdHlwZSBNb2RlcmF0aW9uTW9kZWwgYXMgTW9kZXJhdGlvbk1vZGVsLFxuICAgIHR5cGUgTW9kZXJhdGlvbk11bHRpTW9kYWxJbnB1dCBhcyBNb2RlcmF0aW9uTXVsdGlNb2RhbElucHV0LFxuICAgIHR5cGUgTW9kZXJhdGlvblRleHRJbnB1dCBhcyBNb2RlcmF0aW9uVGV4dElucHV0LFxuICAgIHR5cGUgTW9kZXJhdGlvbkNyZWF0ZVJlc3BvbnNlIGFzIE1vZGVyYXRpb25DcmVhdGVSZXNwb25zZSxcbiAgICB0eXBlIE1vZGVyYXRpb25DcmVhdGVQYXJhbXMgYXMgTW9kZXJhdGlvbkNyZWF0ZVBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vY29yZSc7XG5cbmV4cG9ydCBjbGFzcyBQYXJ0cyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIEFkZHMgYVxuICAgKiBbUGFydF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS91cGxvYWRzL3BhcnQtb2JqZWN0KSB0byBhblxuICAgKiBbVXBsb2FkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3VwbG9hZHMvb2JqZWN0KSBvYmplY3QuXG4gICAqIEEgUGFydCByZXByZXNlbnRzIGEgY2h1bmsgb2YgYnl0ZXMgZnJvbSB0aGUgZmlsZSB5b3UgYXJlIHRyeWluZyB0byB1cGxvYWQuXG4gICAqXG4gICAqIEVhY2ggUGFydCBjYW4gYmUgYXQgbW9zdCA2NCBNQiwgYW5kIHlvdSBjYW4gYWRkIFBhcnRzIHVudGlsIHlvdSBoaXQgdGhlIFVwbG9hZFxuICAgKiBtYXhpbXVtIG9mIDggR0IuXG4gICAqXG4gICAqIEl0IGlzIHBvc3NpYmxlIHRvIGFkZCBtdWx0aXBsZSBQYXJ0cyBpbiBwYXJhbGxlbC4gWW91IGNhbiBkZWNpZGUgdGhlIGludGVuZGVkXG4gICAqIG9yZGVyIG9mIHRoZSBQYXJ0cyB3aGVuIHlvdVxuICAgKiBbY29tcGxldGUgdGhlIFVwbG9hZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS91cGxvYWRzL2NvbXBsZXRlKS5cbiAgICovXG4gIGNyZWF0ZShcbiAgICB1cGxvYWRJZDogc3RyaW5nLFxuICAgIGJvZHk6IFBhcnRDcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxVcGxvYWRQYXJ0PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KFxuICAgICAgYC91cGxvYWRzLyR7dXBsb2FkSWR9L3BhcnRzYCxcbiAgICAgIENvcmUubXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zKHsgYm9keSwgLi4ub3B0aW9ucyB9KSxcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHVwbG9hZCBQYXJ0IHJlcHJlc2VudHMgYSBjaHVuayBvZiBieXRlcyB3ZSBjYW4gYWRkIHRvIGFuIFVwbG9hZCBvYmplY3QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXBsb2FkUGFydCB7XG4gIC8qKlxuICAgKiBUaGUgdXBsb2FkIFBhcnQgdW5pcXVlIGlkZW50aWZpZXIsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBQYXJ0IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgdXBsb2FkLnBhcnRgLlxuICAgKi9cbiAgb2JqZWN0OiAndXBsb2FkLnBhcnQnO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFVwbG9hZCBvYmplY3QgdGhhdCB0aGlzIFBhcnQgd2FzIGFkZGVkIHRvLlxuICAgKi9cbiAgdXBsb2FkX2lkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFydENyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgY2h1bmsgb2YgYnl0ZXMgZm9yIHRoaXMgUGFydC5cbiAgICovXG4gIGRhdGE6IENvcmUuVXBsb2FkYWJsZTtcbn1cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFBhcnRzIHtcbiAgZXhwb3J0IHsgdHlwZSBVcGxvYWRQYXJ0IGFzIFVwbG9hZFBhcnQsIHR5cGUgUGFydENyZWF0ZVBhcmFtcyBhcyBQYXJ0Q3JlYXRlUGFyYW1zIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgRmlsZXNBUEkgZnJvbSAnLi4vZmlsZXMnO1xuaW1wb3J0ICogYXMgUGFydHNBUEkgZnJvbSAnLi9wYXJ0cyc7XG5pbXBvcnQgeyBQYXJ0Q3JlYXRlUGFyYW1zLCBQYXJ0cywgVXBsb2FkUGFydCB9IGZyb20gJy4vcGFydHMnO1xuXG5leHBvcnQgY2xhc3MgVXBsb2FkcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgcGFydHM6IFBhcnRzQVBJLlBhcnRzID0gbmV3IFBhcnRzQVBJLlBhcnRzKHRoaXMuX2NsaWVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW50ZXJtZWRpYXRlXG4gICAqIFtVcGxvYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdXBsb2Fkcy9vYmplY3QpIG9iamVjdFxuICAgKiB0aGF0IHlvdSBjYW4gYWRkXG4gICAqIFtQYXJ0c10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS91cGxvYWRzL3BhcnQtb2JqZWN0KSB0by5cbiAgICogQ3VycmVudGx5LCBhbiBVcGxvYWQgY2FuIGFjY2VwdCBhdCBtb3N0IDggR0IgaW4gdG90YWwgYW5kIGV4cGlyZXMgYWZ0ZXIgYW4gaG91clxuICAgKiBhZnRlciB5b3UgY3JlYXRlIGl0LlxuICAgKlxuICAgKiBPbmNlIHlvdSBjb21wbGV0ZSB0aGUgVXBsb2FkLCB3ZSB3aWxsIGNyZWF0ZSBhXG4gICAqIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL29iamVjdCkgb2JqZWN0IHRoYXRcbiAgICogY29udGFpbnMgYWxsIHRoZSBwYXJ0cyB5b3UgdXBsb2FkZWQuIFRoaXMgRmlsZSBpcyB1c2FibGUgaW4gdGhlIHJlc3Qgb2Ygb3VyXG4gICAqIHBsYXRmb3JtIGFzIGEgcmVndWxhciBGaWxlIG9iamVjdC5cbiAgICpcbiAgICogRm9yIGNlcnRhaW4gYHB1cnBvc2VgcywgdGhlIGNvcnJlY3QgYG1pbWVfdHlwZWAgbXVzdCBiZSBzcGVjaWZpZWQuIFBsZWFzZSByZWZlclxuICAgKiB0byBkb2N1bWVudGF0aW9uIGZvciB0aGUgc3VwcG9ydGVkIE1JTUUgdHlwZXMgZm9yIHlvdXIgdXNlIGNhc2U6XG4gICAqXG4gICAqIC0gW0Fzc2lzdGFudHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvdG9vbHMvZmlsZS1zZWFyY2gjc3VwcG9ydGVkLWZpbGVzKVxuICAgKlxuICAgKiBGb3IgZ3VpZGFuY2Ugb24gdGhlIHByb3BlciBmaWxlbmFtZSBleHRlbnNpb25zIGZvciBlYWNoIHB1cnBvc2UsIHBsZWFzZSBmb2xsb3dcbiAgICogdGhlIGRvY3VtZW50YXRpb24gb25cbiAgICogW2NyZWF0aW5nIGEgRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9jcmVhdGUpLlxuICAgKi9cbiAgY3JlYXRlKGJvZHk6IFVwbG9hZENyZWF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8VXBsb2FkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvdXBsb2FkcycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIHRoZSBVcGxvYWQuIE5vIFBhcnRzIG1heSBiZSBhZGRlZCBhZnRlciBhbiBVcGxvYWQgaXMgY2FuY2VsbGVkLlxuICAgKi9cbiAgY2FuY2VsKHVwbG9hZElkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFVwbG9hZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3VwbG9hZHMvJHt1cGxvYWRJZH0vY2FuY2VsYCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGxldGVzIHRoZVxuICAgKiBbVXBsb2FkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3VwbG9hZHMvb2JqZWN0KS5cbiAgICpcbiAgICogV2l0aGluIHRoZSByZXR1cm5lZCBVcGxvYWQgb2JqZWN0LCB0aGVyZSBpcyBhIG5lc3RlZFxuICAgKiBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9vYmplY3QpIG9iamVjdCB0aGF0XG4gICAqIGlzIHJlYWR5IHRvIHVzZSBpbiB0aGUgcmVzdCBvZiB0aGUgcGxhdGZvcm0uXG4gICAqXG4gICAqIFlvdSBjYW4gc3BlY2lmeSB0aGUgb3JkZXIgb2YgdGhlIFBhcnRzIGJ5IHBhc3NpbmcgaW4gYW4gb3JkZXJlZCBsaXN0IG9mIHRoZSBQYXJ0XG4gICAqIElEcy5cbiAgICpcbiAgICogVGhlIG51bWJlciBvZiBieXRlcyB1cGxvYWRlZCB1cG9uIGNvbXBsZXRpb24gbXVzdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4gICAqIGluaXRpYWxseSBzcGVjaWZpZWQgd2hlbiBjcmVhdGluZyB0aGUgVXBsb2FkIG9iamVjdC4gTm8gUGFydHMgbWF5IGJlIGFkZGVkIGFmdGVyXG4gICAqIGFuIFVwbG9hZCBpcyBjb21wbGV0ZWQuXG4gICAqL1xuICBjb21wbGV0ZShcbiAgICB1cGxvYWRJZDogc3RyaW5nLFxuICAgIGJvZHk6IFVwbG9hZENvbXBsZXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VXBsb2FkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdXBsb2Fkcy8ke3VwbG9hZElkfS9jb21wbGV0ZWAsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBVcGxvYWQgb2JqZWN0IGNhbiBhY2NlcHQgYnl0ZSBjaHVua3MgaW4gdGhlIGZvcm0gb2YgUGFydHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXBsb2FkIHtcbiAgLyoqXG4gICAqIFRoZSBVcGxvYWQgdW5pcXVlIGlkZW50aWZpZXIsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW50ZW5kZWQgbnVtYmVyIG9mIGJ5dGVzIHRvIGJlIHVwbG9hZGVkLlxuICAgKi9cbiAgYnl0ZXM6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgVXBsb2FkIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBVcGxvYWQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBleHBpcmVzX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkLlxuICAgKi9cbiAgZmlsZW5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgXCJ1cGxvYWRcIi5cbiAgICovXG4gIG9iamVjdDogJ3VwbG9hZCc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbnRlbmRlZCBwdXJwb3NlIG9mIHRoZSBmaWxlLlxuICAgKiBbUGxlYXNlIHJlZmVyIGhlcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMvb2JqZWN0I2ZpbGVzL29iamVjdC1wdXJwb3NlKVxuICAgKiBmb3IgYWNjZXB0YWJsZSB2YWx1ZXMuXG4gICAqL1xuICBwdXJwb3NlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBzdGF0dXMgb2YgdGhlIFVwbG9hZC5cbiAgICovXG4gIHN0YXR1czogJ3BlbmRpbmcnIHwgJ2NvbXBsZXRlZCcgfCAnY2FuY2VsbGVkJyB8ICdleHBpcmVkJztcblxuICAvKipcbiAgICogVGhlIHJlYWR5IEZpbGUgb2JqZWN0IGFmdGVyIHRoZSBVcGxvYWQgaXMgY29tcGxldGVkLlxuICAgKi9cbiAgZmlsZT86IEZpbGVzQVBJLkZpbGVPYmplY3QgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwbG9hZENyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSBmaWxlIHlvdSBhcmUgdXBsb2FkaW5nLlxuICAgKi9cbiAgYnl0ZXM6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gdXBsb2FkLlxuICAgKi9cbiAgZmlsZW5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIE1JTUUgdHlwZSBvZiB0aGUgZmlsZS5cbiAgICpcbiAgICogVGhpcyBtdXN0IGZhbGwgd2l0aGluIHRoZSBzdXBwb3J0ZWQgTUlNRSB0eXBlcyBmb3IgeW91ciBmaWxlIHB1cnBvc2UuIFNlZSB0aGVcbiAgICogc3VwcG9ydGVkIE1JTUUgdHlwZXMgZm9yIGFzc2lzdGFudHMgYW5kIHZpc2lvbi5cbiAgICovXG4gIG1pbWVfdHlwZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW50ZW5kZWQgcHVycG9zZSBvZiB0aGUgdXBsb2FkZWQgZmlsZS5cbiAgICpcbiAgICogU2VlIHRoZVxuICAgKiBbZG9jdW1lbnRhdGlvbiBvbiBGaWxlIHB1cnBvc2VzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL2NyZWF0ZSNmaWxlcy1jcmVhdGUtcHVycG9zZSkuXG4gICAqL1xuICBwdXJwb3NlOiBGaWxlc0FQSS5GaWxlUHVycG9zZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVcGxvYWRDb21wbGV0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgb3JkZXJlZCBsaXN0IG9mIFBhcnQgSURzLlxuICAgKi9cbiAgcGFydF9pZHM6IEFycmF5PHN0cmluZz47XG5cbiAgLyoqXG4gICAqIFRoZSBvcHRpb25hbCBtZDUgY2hlY2tzdW0gZm9yIHRoZSBmaWxlIGNvbnRlbnRzIHRvIHZlcmlmeSBpZiB0aGUgYnl0ZXMgdXBsb2FkZWRcbiAgICogbWF0Y2hlcyB3aGF0IHlvdSBleHBlY3QuXG4gICAqL1xuICBtZDU/OiBzdHJpbmc7XG59XG5cblVwbG9hZHMuUGFydHMgPSBQYXJ0cztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFVwbG9hZHMge1xuICBleHBvcnQge1xuICAgIHR5cGUgVXBsb2FkIGFzIFVwbG9hZCxcbiAgICB0eXBlIFVwbG9hZENyZWF0ZVBhcmFtcyBhcyBVcGxvYWRDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBVcGxvYWRDb21wbGV0ZVBhcmFtcyBhcyBVcGxvYWRDb21wbGV0ZVBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQgeyBQYXJ0cyBhcyBQYXJ0cywgdHlwZSBVcGxvYWRQYXJ0IGFzIFVwbG9hZFBhcnQsIHR5cGUgUGFydENyZWF0ZVBhcmFtcyBhcyBQYXJ0Q3JlYXRlUGFyYW1zIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgdHlwZSBBZ2VudCwgdHlwZSBSZXF1ZXN0SW5pdCB9IGZyb20gJy4vX3NoaW1zL2luZGV4JztcbmltcG9ydCAqIGFzIHFzIGZyb20gJy4vaW50ZXJuYWwvcXMnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuL2NvcmUnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vZXJyb3InO1xuaW1wb3J0ICogYXMgUGFnaW5hdGlvbiBmcm9tICcuL3BhZ2luYXRpb24nO1xuaW1wb3J0IHsgdHlwZSBDdXJzb3JQYWdlUGFyYW1zLCBDdXJzb3JQYWdlUmVzcG9uc2UsIFBhZ2VSZXNwb25zZSB9IGZyb20gJy4vcGFnaW5hdGlvbic7XG5pbXBvcnQgKiBhcyBVcGxvYWRzIGZyb20gJy4vdXBsb2Fkcyc7XG5pbXBvcnQgKiBhcyBBUEkgZnJvbSAnLi9yZXNvdXJjZXMvaW5kZXgnO1xuaW1wb3J0IHtcbiAgQmF0Y2gsXG4gIEJhdGNoQ3JlYXRlUGFyYW1zLFxuICBCYXRjaEVycm9yLFxuICBCYXRjaExpc3RQYXJhbXMsXG4gIEJhdGNoUmVxdWVzdENvdW50cyxcbiAgQmF0Y2hlcyxcbiAgQmF0Y2hlc1BhZ2UsXG59IGZyb20gJy4vcmVzb3VyY2VzL2JhdGNoZXMnO1xuaW1wb3J0IHtcbiAgQ29tcGxldGlvbixcbiAgQ29tcGxldGlvbkNob2ljZSxcbiAgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgQ29tcGxldGlvblVzYWdlLFxuICBDb21wbGV0aW9ucyxcbn0gZnJvbSAnLi9yZXNvdXJjZXMvY29tcGxldGlvbnMnO1xuaW1wb3J0IHtcbiAgQ3JlYXRlRW1iZWRkaW5nUmVzcG9uc2UsXG4gIEVtYmVkZGluZyxcbiAgRW1iZWRkaW5nQ3JlYXRlUGFyYW1zLFxuICBFbWJlZGRpbmdNb2RlbCxcbiAgRW1iZWRkaW5ncyxcbn0gZnJvbSAnLi9yZXNvdXJjZXMvZW1iZWRkaW5ncyc7XG5pbXBvcnQge1xuICBGaWxlQ29udGVudCxcbiAgRmlsZUNyZWF0ZVBhcmFtcyxcbiAgRmlsZURlbGV0ZWQsXG4gIEZpbGVMaXN0UGFyYW1zLFxuICBGaWxlT2JqZWN0LFxuICBGaWxlT2JqZWN0c1BhZ2UsXG4gIEZpbGVQdXJwb3NlLFxuICBGaWxlcyxcbn0gZnJvbSAnLi9yZXNvdXJjZXMvZmlsZXMnO1xuaW1wb3J0IHtcbiAgSW1hZ2UsXG4gIEltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zLFxuICBJbWFnZUVkaXRQYXJhbXMsXG4gIEltYWdlR2VuZXJhdGVQYXJhbXMsXG4gIEltYWdlTW9kZWwsXG4gIEltYWdlcyxcbiAgSW1hZ2VzUmVzcG9uc2UsXG59IGZyb20gJy4vcmVzb3VyY2VzL2ltYWdlcyc7XG5pbXBvcnQgeyBNb2RlbCwgTW9kZWxEZWxldGVkLCBNb2RlbHMsIE1vZGVsc1BhZ2UgfSBmcm9tICcuL3Jlc291cmNlcy9tb2RlbHMnO1xuaW1wb3J0IHtcbiAgTW9kZXJhdGlvbixcbiAgTW9kZXJhdGlvbkNyZWF0ZVBhcmFtcyxcbiAgTW9kZXJhdGlvbkNyZWF0ZVJlc3BvbnNlLFxuICBNb2RlcmF0aW9uSW1hZ2VVUkxJbnB1dCxcbiAgTW9kZXJhdGlvbk1vZGVsLFxuICBNb2RlcmF0aW9uTXVsdGlNb2RhbElucHV0LFxuICBNb2RlcmF0aW9uVGV4dElucHV0LFxuICBNb2RlcmF0aW9ucyxcbn0gZnJvbSAnLi9yZXNvdXJjZXMvbW9kZXJhdGlvbnMnO1xuaW1wb3J0IHsgQXVkaW8sIEF1ZGlvTW9kZWwsIEF1ZGlvUmVzcG9uc2VGb3JtYXQgfSBmcm9tICcuL3Jlc291cmNlcy9hdWRpby9hdWRpbyc7XG5pbXBvcnQgeyBCZXRhIH0gZnJvbSAnLi9yZXNvdXJjZXMvYmV0YS9iZXRhJztcbmltcG9ydCB7IENoYXQsIENoYXRNb2RlbCB9IGZyb20gJy4vcmVzb3VyY2VzL2NoYXQvY2hhdCc7XG5pbXBvcnQge1xuICBDaGF0Q29tcGxldGlvbixcbiAgQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uQXVkaW8sXG4gIENoYXRDb21wbGV0aW9uQXVkaW9QYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25DaHVuayxcbiAgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydCxcbiAgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydEltYWdlLFxuICBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW5wdXRBdWRpbyxcbiAgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFJlZnVzYWwsXG4gIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0LFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICBDaGF0Q29tcGxldGlvbkRldmVsb3Blck1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25GdW5jdGlvbkNhbGxPcHRpb24sXG4gIENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uTWVzc2FnZSxcbiAgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsLFxuICBDaGF0Q29tcGxldGlvbk1vZGFsaXR5LFxuICBDaGF0Q29tcGxldGlvbk5hbWVkVG9vbENob2ljZSxcbiAgQ2hhdENvbXBsZXRpb25QcmVkaWN0aW9uQ29udGVudCxcbiAgQ2hhdENvbXBsZXRpb25SZWFzb25pbmdFZmZvcnQsXG4gIENoYXRDb21wbGV0aW9uUm9sZSxcbiAgQ2hhdENvbXBsZXRpb25TdHJlYW1PcHRpb25zLFxuICBDaGF0Q29tcGxldGlvblN5c3RlbU1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2IsXG4gIENoYXRDb21wbGV0aW9uVG9vbCxcbiAgQ2hhdENvbXBsZXRpb25Ub29sQ2hvaWNlT3B0aW9uLFxuICBDaGF0Q29tcGxldGlvblRvb2xNZXNzYWdlUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uVXNlck1lc3NhZ2VQYXJhbSxcbn0gZnJvbSAnLi9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucyc7XG5pbXBvcnQgeyBGaW5lVHVuaW5nIH0gZnJvbSAnLi9yZXNvdXJjZXMvZmluZS10dW5pbmcvZmluZS10dW5pbmcnO1xuaW1wb3J0IHtcbiAgVXBsb2FkLFxuICBVcGxvYWRDb21wbGV0ZVBhcmFtcyxcbiAgVXBsb2FkQ3JlYXRlUGFyYW1zLFxuICBVcGxvYWRzIGFzIFVwbG9hZHNBUElVcGxvYWRzLFxufSBmcm9tICcuL3Jlc291cmNlcy91cGxvYWRzL3VwbG9hZHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENsaWVudE9wdGlvbnMge1xuICAvKipcbiAgICogRGVmYXVsdHMgdG8gcHJvY2Vzcy5lbnZbJ09QRU5BSV9BUElfS0VZJ10uXG4gICAqL1xuICBhcGlLZXk/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIHByb2Nlc3MuZW52WydPUEVOQUlfT1JHX0lEJ10uXG4gICAqL1xuICBvcmdhbml6YXRpb24/OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBwcm9jZXNzLmVudlsnT1BFTkFJX1BST0pFQ1RfSUQnXS5cbiAgICovXG4gIHByb2plY3Q/OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBiYXNlIFVSTCBmb3IgdGhlIEFQSSwgZS5nLiwgXCJodHRwczovL2FwaS5leGFtcGxlLmNvbS92Mi9cIlxuICAgKlxuICAgKiBEZWZhdWx0cyB0byBwcm9jZXNzLmVudlsnT1BFTkFJX0JBU0VfVVJMJ10uXG4gICAqL1xuICBiYXNlVVJMPzogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdGhhdCB0aGUgY2xpZW50IHNob3VsZCB3YWl0IGZvciBhIHJlc3BvbnNlXG4gICAqIGZyb20gdGhlIHNlcnZlciBiZWZvcmUgdGltaW5nIG91dCBhIHNpbmdsZSByZXF1ZXN0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgcmVxdWVzdCB0aW1lb3V0cyBhcmUgcmV0cmllZCBieSBkZWZhdWx0LCBzbyBpbiBhIHdvcnN0LWNhc2Ugc2NlbmFyaW8geW91IG1heSB3YWl0XG4gICAqIG11Y2ggbG9uZ2VyIHRoYW4gdGhpcyB0aW1lb3V0IGJlZm9yZSB0aGUgcHJvbWlzZSBzdWNjZWVkcyBvciBmYWlscy5cbiAgICovXG4gIHRpbWVvdXQ/OiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEFuIEhUVFAgYWdlbnQgdXNlZCB0byBtYW5hZ2UgSFRUUChTKSBjb25uZWN0aW9ucy5cbiAgICpcbiAgICogSWYgbm90IHByb3ZpZGVkLCBhbiBhZ2VudCB3aWxsIGJlIGNvbnN0cnVjdGVkIGJ5IGRlZmF1bHQgaW4gdGhlIE5vZGUuanMgZW52aXJvbm1lbnQsXG4gICAqIG90aGVyd2lzZSBubyBhZ2VudCBpcyB1c2VkLlxuICAgKi9cbiAgaHR0cEFnZW50PzogQWdlbnQgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgYSBjdXN0b20gYGZldGNoYCBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogSWYgbm90IHByb3ZpZGVkLCB3ZSB1c2UgYG5vZGUtZmV0Y2hgIG9uIE5vZGUuanMgYW5kIG90aGVyd2lzZSBleHBlY3QgdGhhdCBgZmV0Y2hgIGlzXG4gICAqIGRlZmluZWQgZ2xvYmFsbHkuXG4gICAqL1xuICBmZXRjaD86IENvcmUuRmV0Y2ggfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0aGF0IHRoZSBjbGllbnQgd2lsbCByZXRyeSBhIHJlcXVlc3QgaW4gY2FzZSBvZiBhXG4gICAqIHRlbXBvcmFyeSBmYWlsdXJlLCBsaWtlIGEgbmV0d29yayBlcnJvciBvciBhIDVYWCBlcnJvciBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBkZWZhdWx0IDJcbiAgICovXG4gIG1heFJldHJpZXM/OiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgaGVhZGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgKlxuICAgKiBUaGVzZSBjYW4gYmUgcmVtb3ZlZCBpbiBpbmRpdmlkdWFsIHJlcXVlc3RzIGJ5IGV4cGxpY2l0bHkgc2V0dGluZyB0aGVcbiAgICogaGVhZGVyIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbiByZXF1ZXN0IG9wdGlvbnMuXG4gICAqL1xuICBkZWZhdWx0SGVhZGVycz86IENvcmUuSGVhZGVycyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogRGVmYXVsdCBxdWVyeSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAqXG4gICAqIFRoZXNlIGNhbiBiZSByZW1vdmVkIGluIGluZGl2aWR1YWwgcmVxdWVzdHMgYnkgZXhwbGljaXRseSBzZXR0aW5nIHRoZVxuICAgKiBwYXJhbSB0byBgdW5kZWZpbmVkYCBpbiByZXF1ZXN0IG9wdGlvbnMuXG4gICAqL1xuICBkZWZhdWx0UXVlcnk/OiBDb3JlLkRlZmF1bHRRdWVyeSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQnkgZGVmYXVsdCwgY2xpZW50LXNpZGUgdXNlIG9mIHRoaXMgbGlicmFyeSBpcyBub3QgYWxsb3dlZCwgYXMgaXQgcmlza3MgZXhwb3NpbmcgeW91ciBzZWNyZXQgQVBJIGNyZWRlbnRpYWxzIHRvIGF0dGFja2Vycy5cbiAgICogT25seSBzZXQgdGhpcyBvcHRpb24gdG8gYHRydWVgIGlmIHlvdSB1bmRlcnN0YW5kIHRoZSByaXNrcyBhbmQgaGF2ZSBhcHByb3ByaWF0ZSBtaXRpZ2F0aW9ucyBpbiBwbGFjZS5cbiAgICovXG4gIGRhbmdlcm91c2x5QWxsb3dCcm93c2VyPzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBUEkgQ2xpZW50IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBPcGVuQUkgQVBJLlxuICovXG5leHBvcnQgY2xhc3MgT3BlbkFJIGV4dGVuZHMgQ29yZS5BUElDbGllbnQge1xuICBhcGlLZXk6IHN0cmluZztcbiAgb3JnYW5pemF0aW9uOiBzdHJpbmcgfCBudWxsO1xuICBwcm9qZWN0OiBzdHJpbmcgfCBudWxsO1xuXG4gIHByaXZhdGUgX29wdGlvbnM6IENsaWVudE9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIEFQSSBDbGllbnQgZm9yIGludGVyZmFjaW5nIHdpdGggdGhlIE9wZW5BSSBBUEkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbb3B0cy5hcGlLZXk9cHJvY2Vzcy5lbnZbJ09QRU5BSV9BUElfS0VZJ10gPz8gdW5kZWZpbmVkXVxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRzLm9yZ2FuaXphdGlvbj1wcm9jZXNzLmVudlsnT1BFTkFJX09SR19JRCddID8/IG51bGxdXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdHMucHJvamVjdD1wcm9jZXNzLmVudlsnT1BFTkFJX1BST0pFQ1RfSUQnXSA/PyBudWxsXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFzZVVSTD1wcm9jZXNzLmVudlsnT1BFTkFJX0JBU0VfVVJMJ10gPz8gaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MV0gLSBPdmVycmlkZSB0aGUgZGVmYXVsdCBiYXNlIFVSTCBmb3IgdGhlIEFQSS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVvdXQ9MTAgbWludXRlc10gLSBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSB0aGUgY2xpZW50IHdpbGwgd2FpdCBmb3IgYSByZXNwb25zZSBiZWZvcmUgdGltaW5nIG91dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmh0dHBBZ2VudF0gLSBBbiBIVFRQIGFnZW50IHVzZWQgdG8gbWFuYWdlIEhUVFAocykgY29ubmVjdGlvbnMuXG4gICAqIEBwYXJhbSB7Q29yZS5GZXRjaH0gW29wdHMuZmV0Y2hdIC0gU3BlY2lmeSBhIGN1c3RvbSBgZmV0Y2hgIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMubWF4UmV0cmllcz0yXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0aGUgY2xpZW50IHdpbGwgcmV0cnkgYSByZXF1ZXN0LlxuICAgKiBAcGFyYW0ge0NvcmUuSGVhZGVyc30gb3B0cy5kZWZhdWx0SGVhZGVycyAtIERlZmF1bHQgaGVhZGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge0NvcmUuRGVmYXVsdFF1ZXJ5fSBvcHRzLmRlZmF1bHRRdWVyeSAtIERlZmF1bHQgcXVlcnkgcGFyYW1ldGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmRhbmdlcm91c2x5QWxsb3dCcm93c2VyPWZhbHNlXSAtIEJ5IGRlZmF1bHQsIGNsaWVudC1zaWRlIHVzZSBvZiB0aGlzIGxpYnJhcnkgaXMgbm90IGFsbG93ZWQsIGFzIGl0IHJpc2tzIGV4cG9zaW5nIHlvdXIgc2VjcmV0IEFQSSBjcmVkZW50aWFscyB0byBhdHRhY2tlcnMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmFzZVVSTCA9IENvcmUucmVhZEVudignT1BFTkFJX0JBU0VfVVJMJyksXG4gICAgYXBpS2V5ID0gQ29yZS5yZWFkRW52KCdPUEVOQUlfQVBJX0tFWScpLFxuICAgIG9yZ2FuaXphdGlvbiA9IENvcmUucmVhZEVudignT1BFTkFJX09SR19JRCcpID8/IG51bGwsXG4gICAgcHJvamVjdCA9IENvcmUucmVhZEVudignT1BFTkFJX1BST0pFQ1RfSUQnKSA/PyBudWxsLFxuICAgIC4uLm9wdHNcbiAgfTogQ2xpZW50T3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKGFwaUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKFxuICAgICAgICBcIlRoZSBPUEVOQUlfQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtaXNzaW5nIG9yIGVtcHR5OyBlaXRoZXIgcHJvdmlkZSBpdCwgb3IgaW5zdGFudGlhdGUgdGhlIE9wZW5BSSBjbGllbnQgd2l0aCBhbiBhcGlLZXkgb3B0aW9uLCBsaWtlIG5ldyBPcGVuQUkoeyBhcGlLZXk6ICdNeSBBUEkgS2V5JyB9KS5cIixcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9uczogQ2xpZW50T3B0aW9ucyA9IHtcbiAgICAgIGFwaUtleSxcbiAgICAgIG9yZ2FuaXphdGlvbixcbiAgICAgIHByb2plY3QsXG4gICAgICAuLi5vcHRzLFxuICAgICAgYmFzZVVSTDogYmFzZVVSTCB8fCBgaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MWAsXG4gICAgfTtcblxuICAgIGlmICghb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93QnJvd3NlciAmJiBDb3JlLmlzUnVubmluZ0luQnJvd3NlcigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKFxuICAgICAgICBcIkl0IGxvb2tzIGxpa2UgeW91J3JlIHJ1bm5pbmcgaW4gYSBicm93c2VyLWxpa2UgZW52aXJvbm1lbnQuXFxuXFxuVGhpcyBpcyBkaXNhYmxlZCBieSBkZWZhdWx0LCBhcyBpdCByaXNrcyBleHBvc2luZyB5b3VyIHNlY3JldCBBUEkgY3JlZGVudGlhbHMgdG8gYXR0YWNrZXJzLlxcbklmIHlvdSB1bmRlcnN0YW5kIHRoZSByaXNrcyBhbmQgaGF2ZSBhcHByb3ByaWF0ZSBtaXRpZ2F0aW9ucyBpbiBwbGFjZSxcXG55b3UgY2FuIHNldCB0aGUgYGRhbmdlcm91c2x5QWxsb3dCcm93c2VyYCBvcHRpb24gdG8gYHRydWVgLCBlLmcuLFxcblxcbm5ldyBPcGVuQUkoeyBhcGlLZXksIGRhbmdlcm91c2x5QWxsb3dCcm93c2VyOiB0cnVlIH0pO1xcblxcbmh0dHBzOi8vaGVscC5vcGVuYWkuY29tL2VuL2FydGljbGVzLzUxMTI1OTUtYmVzdC1wcmFjdGljZXMtZm9yLWFwaS1rZXktc2FmZXR5XFxuXCIsXG4gICAgICApO1xuICAgIH1cblxuICAgIHN1cGVyKHtcbiAgICAgIGJhc2VVUkw6IG9wdGlvbnMuYmFzZVVSTCEsXG4gICAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQgPz8gNjAwMDAwIC8qIDEwIG1pbnV0ZXMgKi8sXG4gICAgICBodHRwQWdlbnQ6IG9wdGlvbnMuaHR0cEFnZW50LFxuICAgICAgbWF4UmV0cmllczogb3B0aW9ucy5tYXhSZXRyaWVzLFxuICAgICAgZmV0Y2g6IG9wdGlvbnMuZmV0Y2gsXG4gICAgfSk7XG5cbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICAgIHRoaXMub3JnYW5pemF0aW9uID0gb3JnYW5pemF0aW9uO1xuICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gIH1cblxuICBjb21wbGV0aW9uczogQVBJLkNvbXBsZXRpb25zID0gbmV3IEFQSS5Db21wbGV0aW9ucyh0aGlzKTtcbiAgY2hhdDogQVBJLkNoYXQgPSBuZXcgQVBJLkNoYXQodGhpcyk7XG4gIGVtYmVkZGluZ3M6IEFQSS5FbWJlZGRpbmdzID0gbmV3IEFQSS5FbWJlZGRpbmdzKHRoaXMpO1xuICBmaWxlczogQVBJLkZpbGVzID0gbmV3IEFQSS5GaWxlcyh0aGlzKTtcbiAgaW1hZ2VzOiBBUEkuSW1hZ2VzID0gbmV3IEFQSS5JbWFnZXModGhpcyk7XG4gIGF1ZGlvOiBBUEkuQXVkaW8gPSBuZXcgQVBJLkF1ZGlvKHRoaXMpO1xuICBtb2RlcmF0aW9uczogQVBJLk1vZGVyYXRpb25zID0gbmV3IEFQSS5Nb2RlcmF0aW9ucyh0aGlzKTtcbiAgbW9kZWxzOiBBUEkuTW9kZWxzID0gbmV3IEFQSS5Nb2RlbHModGhpcyk7XG4gIGZpbmVUdW5pbmc6IEFQSS5GaW5lVHVuaW5nID0gbmV3IEFQSS5GaW5lVHVuaW5nKHRoaXMpO1xuICBiZXRhOiBBUEkuQmV0YSA9IG5ldyBBUEkuQmV0YSh0aGlzKTtcbiAgYmF0Y2hlczogQVBJLkJhdGNoZXMgPSBuZXcgQVBJLkJhdGNoZXModGhpcyk7XG4gIHVwbG9hZHM6IEFQSS5VcGxvYWRzID0gbmV3IEFQSS5VcGxvYWRzKHRoaXMpO1xuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBkZWZhdWx0UXVlcnkoKTogQ29yZS5EZWZhdWx0UXVlcnkgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmRlZmF1bHRRdWVyeTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBkZWZhdWx0SGVhZGVycyhvcHRzOiBDb3JlLkZpbmFsUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkhlYWRlcnMge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5kZWZhdWx0SGVhZGVycyhvcHRzKSxcbiAgICAgICdPcGVuQUktT3JnYW5pemF0aW9uJzogdGhpcy5vcmdhbml6YXRpb24sXG4gICAgICAnT3BlbkFJLVByb2plY3QnOiB0aGlzLnByb2plY3QsXG4gICAgICAuLi50aGlzLl9vcHRpb25zLmRlZmF1bHRIZWFkZXJzLFxuICAgIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgYXV0aEhlYWRlcnMob3B0czogQ29yZS5GaW5hbFJlcXVlc3RPcHRpb25zKTogQ29yZS5IZWFkZXJzIHtcbiAgICByZXR1cm4geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5hcGlLZXl9YCB9O1xuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHN0cmluZyB7XG4gICAgcmV0dXJuIHFzLnN0cmluZ2lmeShxdWVyeSwgeyBhcnJheUZvcm1hdDogJ2JyYWNrZXRzJyB9KTtcbiAgfVxuXG4gIHN0YXRpYyBPcGVuQUkgPSB0aGlzO1xuICBzdGF0aWMgREVGQVVMVF9USU1FT1VUID0gNjAwMDAwOyAvLyAxMCBtaW51dGVzXG5cbiAgc3RhdGljIE9wZW5BSUVycm9yID0gRXJyb3JzLk9wZW5BSUVycm9yO1xuICBzdGF0aWMgQVBJRXJyb3IgPSBFcnJvcnMuQVBJRXJyb3I7XG4gIHN0YXRpYyBBUElDb25uZWN0aW9uRXJyb3IgPSBFcnJvcnMuQVBJQ29ubmVjdGlvbkVycm9yO1xuICBzdGF0aWMgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvciA9IEVycm9ycy5BUElDb25uZWN0aW9uVGltZW91dEVycm9yO1xuICBzdGF0aWMgQVBJVXNlckFib3J0RXJyb3IgPSBFcnJvcnMuQVBJVXNlckFib3J0RXJyb3I7XG4gIHN0YXRpYyBOb3RGb3VuZEVycm9yID0gRXJyb3JzLk5vdEZvdW5kRXJyb3I7XG4gIHN0YXRpYyBDb25mbGljdEVycm9yID0gRXJyb3JzLkNvbmZsaWN0RXJyb3I7XG4gIHN0YXRpYyBSYXRlTGltaXRFcnJvciA9IEVycm9ycy5SYXRlTGltaXRFcnJvcjtcbiAgc3RhdGljIEJhZFJlcXVlc3RFcnJvciA9IEVycm9ycy5CYWRSZXF1ZXN0RXJyb3I7XG4gIHN0YXRpYyBBdXRoZW50aWNhdGlvbkVycm9yID0gRXJyb3JzLkF1dGhlbnRpY2F0aW9uRXJyb3I7XG4gIHN0YXRpYyBJbnRlcm5hbFNlcnZlckVycm9yID0gRXJyb3JzLkludGVybmFsU2VydmVyRXJyb3I7XG4gIHN0YXRpYyBQZXJtaXNzaW9uRGVuaWVkRXJyb3IgPSBFcnJvcnMuUGVybWlzc2lvbkRlbmllZEVycm9yO1xuICBzdGF0aWMgVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yID0gRXJyb3JzLlVucHJvY2Vzc2FibGVFbnRpdHlFcnJvcjtcblxuICBzdGF0aWMgdG9GaWxlID0gVXBsb2Fkcy50b0ZpbGU7XG4gIHN0YXRpYyBmaWxlRnJvbVBhdGggPSBVcGxvYWRzLmZpbGVGcm9tUGF0aDtcbn1cblxuT3BlbkFJLkNvbXBsZXRpb25zID0gQ29tcGxldGlvbnM7XG5PcGVuQUkuQ2hhdCA9IENoYXQ7XG5PcGVuQUkuRW1iZWRkaW5ncyA9IEVtYmVkZGluZ3M7XG5PcGVuQUkuRmlsZXMgPSBGaWxlcztcbk9wZW5BSS5GaWxlT2JqZWN0c1BhZ2UgPSBGaWxlT2JqZWN0c1BhZ2U7XG5PcGVuQUkuSW1hZ2VzID0gSW1hZ2VzO1xuT3BlbkFJLkF1ZGlvID0gQXVkaW87XG5PcGVuQUkuTW9kZXJhdGlvbnMgPSBNb2RlcmF0aW9ucztcbk9wZW5BSS5Nb2RlbHMgPSBNb2RlbHM7XG5PcGVuQUkuTW9kZWxzUGFnZSA9IE1vZGVsc1BhZ2U7XG5PcGVuQUkuRmluZVR1bmluZyA9IEZpbmVUdW5pbmc7XG5PcGVuQUkuQmV0YSA9IEJldGE7XG5PcGVuQUkuQmF0Y2hlcyA9IEJhdGNoZXM7XG5PcGVuQUkuQmF0Y2hlc1BhZ2UgPSBCYXRjaGVzUGFnZTtcbk9wZW5BSS5VcGxvYWRzID0gVXBsb2Fkc0FQSVVwbG9hZHM7XG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgT3BlbkFJIHtcbiAgZXhwb3J0IHR5cGUgUmVxdWVzdE9wdGlvbnMgPSBDb3JlLlJlcXVlc3RPcHRpb25zO1xuXG4gIGV4cG9ydCBpbXBvcnQgUGFnZSA9IFBhZ2luYXRpb24uUGFnZTtcbiAgZXhwb3J0IHsgdHlwZSBQYWdlUmVzcG9uc2UgYXMgUGFnZVJlc3BvbnNlIH07XG5cbiAgZXhwb3J0IGltcG9ydCBDdXJzb3JQYWdlID0gUGFnaW5hdGlvbi5DdXJzb3JQYWdlO1xuICBleHBvcnQgeyB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgYXMgQ3Vyc29yUGFnZVBhcmFtcywgdHlwZSBDdXJzb3JQYWdlUmVzcG9uc2UgYXMgQ3Vyc29yUGFnZVJlc3BvbnNlIH07XG5cbiAgZXhwb3J0IHtcbiAgICBDb21wbGV0aW9ucyBhcyBDb21wbGV0aW9ucyxcbiAgICB0eXBlIENvbXBsZXRpb24gYXMgQ29tcGxldGlvbixcbiAgICB0eXBlIENvbXBsZXRpb25DaG9pY2UgYXMgQ29tcGxldGlvbkNob2ljZSxcbiAgICB0eXBlIENvbXBsZXRpb25Vc2FnZSBhcyBDb21wbGV0aW9uVXNhZ2UsXG4gICAgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIGFzIENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGFzIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGFzIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gIH07XG5cbiAgZXhwb3J0IHtcbiAgICBDaGF0IGFzIENoYXQsXG4gICAgdHlwZSBDaGF0TW9kZWwgYXMgQ2hhdE1vZGVsLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb24gYXMgQ2hhdENvbXBsZXRpb24sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQXVkaW8gYXMgQ2hhdENvbXBsZXRpb25BdWRpbyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQXVkaW9QYXJhbSBhcyBDaGF0Q29tcGxldGlvbkF1ZGlvUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNodW5rIGFzIENoYXRDb21wbGV0aW9uQ2h1bmssXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0IGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnQsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2UgYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydEltYWdlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydElucHV0QXVkaW8gYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydElucHV0QXVkaW8sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0UmVmdXNhbCBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0UmVmdXNhbCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0IGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25EZXZlbG9wZXJNZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25EZXZlbG9wZXJNZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uQ2FsbE9wdGlvbiBhcyBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uQ2FsbE9wdGlvbixcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25GdW5jdGlvbk1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZSBhcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2UsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsIGFzIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Nb2RhbGl0eSBhcyBDaGF0Q29tcGxldGlvbk1vZGFsaXR5LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25OYW1lZFRvb2xDaG9pY2UgYXMgQ2hhdENvbXBsZXRpb25OYW1lZFRvb2xDaG9pY2UsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblByZWRpY3Rpb25Db250ZW50IGFzIENoYXRDb21wbGV0aW9uUHJlZGljdGlvbkNvbnRlbnQsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblJlYXNvbmluZ0VmZm9ydCBhcyBDaGF0Q29tcGxldGlvblJlYXNvbmluZ0VmZm9ydCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uUm9sZSBhcyBDaGF0Q29tcGxldGlvblJvbGUsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblN0cmVhbU9wdGlvbnMgYXMgQ2hhdENvbXBsZXRpb25TdHJlYW1PcHRpb25zLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25TeXN0ZW1NZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25TeXN0ZW1NZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYiBhcyBDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYixcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVG9vbCBhcyBDaGF0Q29tcGxldGlvblRvb2wsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblRvb2xDaG9pY2VPcHRpb24gYXMgQ2hhdENvbXBsZXRpb25Ub29sQ2hvaWNlT3B0aW9uLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVXNlck1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvblVzZXJNZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyBhcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGFzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgYXMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gIH07XG5cbiAgZXhwb3J0IHtcbiAgICBFbWJlZGRpbmdzIGFzIEVtYmVkZGluZ3MsXG4gICAgdHlwZSBDcmVhdGVFbWJlZGRpbmdSZXNwb25zZSBhcyBDcmVhdGVFbWJlZGRpbmdSZXNwb25zZSxcbiAgICB0eXBlIEVtYmVkZGluZyBhcyBFbWJlZGRpbmcsXG4gICAgdHlwZSBFbWJlZGRpbmdNb2RlbCBhcyBFbWJlZGRpbmdNb2RlbCxcbiAgICB0eXBlIEVtYmVkZGluZ0NyZWF0ZVBhcmFtcyBhcyBFbWJlZGRpbmdDcmVhdGVQYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHtcbiAgICBGaWxlcyBhcyBGaWxlcyxcbiAgICB0eXBlIEZpbGVDb250ZW50IGFzIEZpbGVDb250ZW50LFxuICAgIHR5cGUgRmlsZURlbGV0ZWQgYXMgRmlsZURlbGV0ZWQsXG4gICAgdHlwZSBGaWxlT2JqZWN0IGFzIEZpbGVPYmplY3QsXG4gICAgdHlwZSBGaWxlUHVycG9zZSBhcyBGaWxlUHVycG9zZSxcbiAgICBGaWxlT2JqZWN0c1BhZ2UgYXMgRmlsZU9iamVjdHNQYWdlLFxuICAgIHR5cGUgRmlsZUNyZWF0ZVBhcmFtcyBhcyBGaWxlQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgRmlsZUxpc3RQYXJhbXMgYXMgRmlsZUxpc3RQYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHtcbiAgICBJbWFnZXMgYXMgSW1hZ2VzLFxuICAgIHR5cGUgSW1hZ2UgYXMgSW1hZ2UsXG4gICAgdHlwZSBJbWFnZU1vZGVsIGFzIEltYWdlTW9kZWwsXG4gICAgdHlwZSBJbWFnZXNSZXNwb25zZSBhcyBJbWFnZXNSZXNwb25zZSxcbiAgICB0eXBlIEltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zIGFzIEltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zLFxuICAgIHR5cGUgSW1hZ2VFZGl0UGFyYW1zIGFzIEltYWdlRWRpdFBhcmFtcyxcbiAgICB0eXBlIEltYWdlR2VuZXJhdGVQYXJhbXMgYXMgSW1hZ2VHZW5lcmF0ZVBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQgeyBBdWRpbyBhcyBBdWRpbywgdHlwZSBBdWRpb01vZGVsIGFzIEF1ZGlvTW9kZWwsIHR5cGUgQXVkaW9SZXNwb25zZUZvcm1hdCBhcyBBdWRpb1Jlc3BvbnNlRm9ybWF0IH07XG5cbiAgZXhwb3J0IHtcbiAgICBNb2RlcmF0aW9ucyBhcyBNb2RlcmF0aW9ucyxcbiAgICB0eXBlIE1vZGVyYXRpb24gYXMgTW9kZXJhdGlvbixcbiAgICB0eXBlIE1vZGVyYXRpb25JbWFnZVVSTElucHV0IGFzIE1vZGVyYXRpb25JbWFnZVVSTElucHV0LFxuICAgIHR5cGUgTW9kZXJhdGlvbk1vZGVsIGFzIE1vZGVyYXRpb25Nb2RlbCxcbiAgICB0eXBlIE1vZGVyYXRpb25NdWx0aU1vZGFsSW5wdXQgYXMgTW9kZXJhdGlvbk11bHRpTW9kYWxJbnB1dCxcbiAgICB0eXBlIE1vZGVyYXRpb25UZXh0SW5wdXQgYXMgTW9kZXJhdGlvblRleHRJbnB1dCxcbiAgICB0eXBlIE1vZGVyYXRpb25DcmVhdGVSZXNwb25zZSBhcyBNb2RlcmF0aW9uQ3JlYXRlUmVzcG9uc2UsXG4gICAgdHlwZSBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zIGFzIE1vZGVyYXRpb25DcmVhdGVQYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHtcbiAgICBNb2RlbHMgYXMgTW9kZWxzLFxuICAgIHR5cGUgTW9kZWwgYXMgTW9kZWwsXG4gICAgdHlwZSBNb2RlbERlbGV0ZWQgYXMgTW9kZWxEZWxldGVkLFxuICAgIE1vZGVsc1BhZ2UgYXMgTW9kZWxzUGFnZSxcbiAgfTtcblxuICBleHBvcnQgeyBGaW5lVHVuaW5nIGFzIEZpbmVUdW5pbmcgfTtcblxuICBleHBvcnQgeyBCZXRhIGFzIEJldGEgfTtcblxuICBleHBvcnQge1xuICAgIEJhdGNoZXMgYXMgQmF0Y2hlcyxcbiAgICB0eXBlIEJhdGNoIGFzIEJhdGNoLFxuICAgIHR5cGUgQmF0Y2hFcnJvciBhcyBCYXRjaEVycm9yLFxuICAgIHR5cGUgQmF0Y2hSZXF1ZXN0Q291bnRzIGFzIEJhdGNoUmVxdWVzdENvdW50cyxcbiAgICBCYXRjaGVzUGFnZSBhcyBCYXRjaGVzUGFnZSxcbiAgICB0eXBlIEJhdGNoQ3JlYXRlUGFyYW1zIGFzIEJhdGNoQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgQmF0Y2hMaXN0UGFyYW1zIGFzIEJhdGNoTGlzdFBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIFVwbG9hZHNBUElVcGxvYWRzIGFzIFVwbG9hZHMsXG4gICAgdHlwZSBVcGxvYWQgYXMgVXBsb2FkLFxuICAgIHR5cGUgVXBsb2FkQ3JlYXRlUGFyYW1zIGFzIFVwbG9hZENyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIFVwbG9hZENvbXBsZXRlUGFyYW1zIGFzIFVwbG9hZENvbXBsZXRlUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB0eXBlIEVycm9yT2JqZWN0ID0gQVBJLkVycm9yT2JqZWN0O1xuICBleHBvcnQgdHlwZSBGdW5jdGlvbkRlZmluaXRpb24gPSBBUEkuRnVuY3Rpb25EZWZpbml0aW9uO1xuICBleHBvcnQgdHlwZSBGdW5jdGlvblBhcmFtZXRlcnMgPSBBUEkuRnVuY3Rpb25QYXJhbWV0ZXJzO1xuICBleHBvcnQgdHlwZSBSZXNwb25zZUZvcm1hdEpTT05PYmplY3QgPSBBUEkuUmVzcG9uc2VGb3JtYXRKU09OT2JqZWN0O1xuICBleHBvcnQgdHlwZSBSZXNwb25zZUZvcm1hdEpTT05TY2hlbWEgPSBBUEkuUmVzcG9uc2VGb3JtYXRKU09OU2NoZW1hO1xuICBleHBvcnQgdHlwZSBSZXNwb25zZUZvcm1hdFRleHQgPSBBUEkuUmVzcG9uc2VGb3JtYXRUZXh0O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEF6dXJlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqIEFQSSBDbGllbnQgZm9yIGludGVyZmFjaW5nIHdpdGggdGhlIEF6dXJlIE9wZW5BSSBBUEkuICovXG5leHBvcnQgaW50ZXJmYWNlIEF6dXJlQ2xpZW50T3B0aW9ucyBleHRlbmRzIENsaWVudE9wdGlvbnMge1xuICAvKipcbiAgICogRGVmYXVsdHMgdG8gcHJvY2Vzcy5lbnZbJ09QRU5BSV9BUElfVkVSU0lPTiddLlxuICAgKi9cbiAgYXBpVmVyc2lvbj86IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogWW91ciBBenVyZSBlbmRwb2ludCwgaW5jbHVkaW5nIHRoZSByZXNvdXJjZSwgZS5nLiBgaHR0cHM6Ly9leGFtcGxlLXJlc291cmNlLmF6dXJlLm9wZW5haS5jb20vYFxuICAgKi9cbiAgZW5kcG9pbnQ/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEEgbW9kZWwgZGVwbG95bWVudCwgaWYgZ2l2ZW4sIHNldHMgdGhlIGJhc2UgY2xpZW50IFVSTCB0byBpbmNsdWRlIGAvZGVwbG95bWVudHMve2RlcGxveW1lbnR9YC5cbiAgICogTm90ZTogdGhpcyBtZWFucyB5b3Ugd29uJ3QgYmUgYWJsZSB0byB1c2Ugbm9uLWRlcGxveW1lbnQgZW5kcG9pbnRzLiBOb3Qgc3VwcG9ydGVkIHdpdGggQXNzaXN0YW50cyBBUElzLlxuICAgKi9cbiAgZGVwbG95bWVudD86IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogRGVmYXVsdHMgdG8gcHJvY2Vzcy5lbnZbJ0FaVVJFX09QRU5BSV9BUElfS0VZJ10uXG4gICAqL1xuICBhcGlLZXk/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGFjY2VzcyB0b2tlbiBmb3IgTWljcm9zb2Z0IEVudHJhIChmb3JtZXJseSBrbm93biBhcyBBenVyZSBBY3RpdmUgRGlyZWN0b3J5KSxcbiAgICogd2hpY2ggd2lsbCBiZSBpbnZva2VkIG9uIGV2ZXJ5IHJlcXVlc3QuXG4gICAqL1xuICBhenVyZUFEVG9rZW5Qcm92aWRlcj86ICgoKSA9PiBQcm9taXNlPHN0cmluZz4pIHwgdW5kZWZpbmVkO1xufVxuXG4vKiogQVBJIENsaWVudCBmb3IgaW50ZXJmYWNpbmcgd2l0aCB0aGUgQXp1cmUgT3BlbkFJIEFQSS4gKi9cbmV4cG9ydCBjbGFzcyBBenVyZU9wZW5BSSBleHRlbmRzIE9wZW5BSSB7XG4gIHByaXZhdGUgX2F6dXJlQURUb2tlblByb3ZpZGVyOiAoKCkgPT4gUHJvbWlzZTxzdHJpbmc+KSB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBfZGVwbG95bWVudDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBhcGlWZXJzaW9uOiBzdHJpbmcgPSAnJztcbiAgLyoqXG4gICAqIEFQSSBDbGllbnQgZm9yIGludGVyZmFjaW5nIHdpdGggdGhlIEF6dXJlIE9wZW5BSSBBUEkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbb3B0cy5hcGlWZXJzaW9uPXByb2Nlc3MuZW52WydPUEVOQUlfQVBJX1ZFUlNJT04nXSA/PyB1bmRlZmluZWRdXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbb3B0cy5lbmRwb2ludD1wcm9jZXNzLmVudlsnQVpVUkVfT1BFTkFJX0VORFBPSU5UJ10gPz8gdW5kZWZpbmVkXSAtIFlvdXIgQXp1cmUgZW5kcG9pbnQsIGluY2x1ZGluZyB0aGUgcmVzb3VyY2UsIGUuZy4gYGh0dHBzOi8vZXhhbXBsZS1yZXNvdXJjZS5henVyZS5vcGVuYWkuY29tL2BcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtvcHRzLmFwaUtleT1wcm9jZXNzLmVudlsnQVpVUkVfT1BFTkFJX0FQSV9LRVknXSA/PyB1bmRlZmluZWRdXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBvcHRzLmRlcGxveW1lbnQgLSBBIG1vZGVsIGRlcGxveW1lbnQsIGlmIGdpdmVuLCBzZXRzIHRoZSBiYXNlIGNsaWVudCBVUkwgdG8gaW5jbHVkZSBgL2RlcGxveW1lbnRzL3tkZXBsb3ltZW50fWAuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdHMub3JnYW5pemF0aW9uPXByb2Nlc3MuZW52WydPUEVOQUlfT1JHX0lEJ10gPz8gbnVsbF1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhc2VVUkw9cHJvY2Vzcy5lbnZbJ09QRU5BSV9CQVNFX1VSTCddXSAtIFNldHMgdGhlIGJhc2UgVVJMIGZvciB0aGUgQVBJLCBlLmcuIGBodHRwczovL2V4YW1wbGUtcmVzb3VyY2UuYXp1cmUub3BlbmFpLmNvbS9vcGVuYWkvYC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVvdXQ9MTAgbWludXRlc10gLSBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSB0aGUgY2xpZW50IHdpbGwgd2FpdCBmb3IgYSByZXNwb25zZSBiZWZvcmUgdGltaW5nIG91dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmh0dHBBZ2VudF0gLSBBbiBIVFRQIGFnZW50IHVzZWQgdG8gbWFuYWdlIEhUVFAocykgY29ubmVjdGlvbnMuXG4gICAqIEBwYXJhbSB7Q29yZS5GZXRjaH0gW29wdHMuZmV0Y2hdIC0gU3BlY2lmeSBhIGN1c3RvbSBgZmV0Y2hgIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMubWF4UmV0cmllcz0yXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0aGUgY2xpZW50IHdpbGwgcmV0cnkgYSByZXF1ZXN0LlxuICAgKiBAcGFyYW0ge0NvcmUuSGVhZGVyc30gb3B0cy5kZWZhdWx0SGVhZGVycyAtIERlZmF1bHQgaGVhZGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge0NvcmUuRGVmYXVsdFF1ZXJ5fSBvcHRzLmRlZmF1bHRRdWVyeSAtIERlZmF1bHQgcXVlcnkgcGFyYW1ldGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmRhbmdlcm91c2x5QWxsb3dCcm93c2VyPWZhbHNlXSAtIEJ5IGRlZmF1bHQsIGNsaWVudC1zaWRlIHVzZSBvZiB0aGlzIGxpYnJhcnkgaXMgbm90IGFsbG93ZWQsIGFzIGl0IHJpc2tzIGV4cG9zaW5nIHlvdXIgc2VjcmV0IEFQSSBjcmVkZW50aWFscyB0byBhdHRhY2tlcnMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmFzZVVSTCA9IENvcmUucmVhZEVudignT1BFTkFJX0JBU0VfVVJMJyksXG4gICAgYXBpS2V5ID0gQ29yZS5yZWFkRW52KCdBWlVSRV9PUEVOQUlfQVBJX0tFWScpLFxuICAgIGFwaVZlcnNpb24gPSBDb3JlLnJlYWRFbnYoJ09QRU5BSV9BUElfVkVSU0lPTicpLFxuICAgIGVuZHBvaW50LFxuICAgIGRlcGxveW1lbnQsXG4gICAgYXp1cmVBRFRva2VuUHJvdmlkZXIsXG4gICAgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXIsXG4gICAgLi4ub3B0c1xuICB9OiBBenVyZUNsaWVudE9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghYXBpVmVyc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcihcbiAgICAgICAgXCJUaGUgT1BFTkFJX0FQSV9WRVJTSU9OIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG1pc3Npbmcgb3IgZW1wdHk7IGVpdGhlciBwcm92aWRlIGl0LCBvciBpbnN0YW50aWF0ZSB0aGUgQXp1cmVPcGVuQUkgY2xpZW50IHdpdGggYW4gYXBpVmVyc2lvbiBvcHRpb24sIGxpa2UgbmV3IEF6dXJlT3BlbkFJKHsgYXBpVmVyc2lvbjogJ015IEFQSSBWZXJzaW9uJyB9KS5cIixcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhenVyZUFEVG9rZW5Qcm92aWRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXIgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYXp1cmVBRFRva2VuUHJvdmlkZXIgJiYgIWFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcihcbiAgICAgICAgJ01pc3NpbmcgY3JlZGVudGlhbHMuIFBsZWFzZSBwYXNzIG9uZSBvZiBgYXBpS2V5YCBhbmQgYGF6dXJlQURUb2tlblByb3ZpZGVyYCwgb3Igc2V0IHRoZSBgQVpVUkVfT1BFTkFJX0FQSV9LRVlgIGVudmlyb25tZW50IHZhcmlhYmxlLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChhenVyZUFEVG9rZW5Qcm92aWRlciAmJiBhcGlLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuT3BlbkFJRXJyb3IoXG4gICAgICAgICdUaGUgYGFwaUtleWAgYW5kIGBhenVyZUFEVG9rZW5Qcm92aWRlcmAgYXJndW1lbnRzIGFyZSBtdXR1YWxseSBleGNsdXNpdmU7IG9ubHkgb25lIGNhbiBiZSBwYXNzZWQgYXQgYSB0aW1lLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGRlZmluZSBhIHNlbnRpbmVsIHZhbHVlIHRvIGF2b2lkIGFueSB0eXBpbmcgaXNzdWVzXG4gICAgYXBpS2V5ID8/PSBBUElfS0VZX1NFTlRJTkVMO1xuXG4gICAgb3B0cy5kZWZhdWx0UXVlcnkgPSB7IC4uLm9wdHMuZGVmYXVsdFF1ZXJ5LCAnYXBpLXZlcnNpb24nOiBhcGlWZXJzaW9uIH07XG5cbiAgICBpZiAoIWJhc2VVUkwpIHtcbiAgICAgIGlmICghZW5kcG9pbnQpIHtcbiAgICAgICAgZW5kcG9pbnQgPSBwcm9jZXNzLmVudlsnQVpVUkVfT1BFTkFJX0VORFBPSU5UJ107XG4gICAgICB9XG5cbiAgICAgIGlmICghZW5kcG9pbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcihcbiAgICAgICAgICAnTXVzdCBwcm92aWRlIG9uZSBvZiB0aGUgYGJhc2VVUkxgIG9yIGBlbmRwb2ludGAgYXJndW1lbnRzLCBvciB0aGUgYEFaVVJFX09QRU5BSV9FTkRQT0lOVGAgZW52aXJvbm1lbnQgdmFyaWFibGUnLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBiYXNlVVJMID0gYCR7ZW5kcG9pbnR9L29wZW5haWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbmRwb2ludCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKCdiYXNlVVJMIGFuZCBlbmRwb2ludCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3VwZXIoe1xuICAgICAgYXBpS2V5LFxuICAgICAgYmFzZVVSTCxcbiAgICAgIC4uLm9wdHMsXG4gICAgICAuLi4oZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXIgIT09IHVuZGVmaW5lZCA/IHsgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXIgfSA6IHt9KSxcbiAgICB9KTtcblxuICAgIHRoaXMuX2F6dXJlQURUb2tlblByb3ZpZGVyID0gYXp1cmVBRFRva2VuUHJvdmlkZXI7XG4gICAgdGhpcy5hcGlWZXJzaW9uID0gYXBpVmVyc2lvbjtcbiAgICB0aGlzLl9kZXBsb3ltZW50ID0gZGVwbG95bWVudDtcbiAgfVxuXG4gIG92ZXJyaWRlIGJ1aWxkUmVxdWVzdChvcHRpb25zOiBDb3JlLkZpbmFsUmVxdWVzdE9wdGlvbnM8dW5rbm93bj4pOiB7XG4gICAgcmVxOiBSZXF1ZXN0SW5pdDtcbiAgICB1cmw6IHN0cmluZztcbiAgICB0aW1lb3V0OiBudW1iZXI7XG4gIH0ge1xuICAgIGlmIChfZGVwbG95bWVudHNfZW5kcG9pbnRzLmhhcyhvcHRpb25zLnBhdGgpICYmIG9wdGlvbnMubWV0aG9kID09PSAncG9zdCcgJiYgb3B0aW9ucy5ib2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghQ29yZS5pc09iaihvcHRpb25zLmJvZHkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVxdWVzdCBib2R5IHRvIGJlIGFuIG9iamVjdCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9kZXBsb3ltZW50IHx8IG9wdGlvbnMuYm9keVsnbW9kZWwnXTtcbiAgICAgIGlmIChtb2RlbCAhPT0gdW5kZWZpbmVkICYmICF0aGlzLmJhc2VVUkwuaW5jbHVkZXMoJy9kZXBsb3ltZW50cycpKSB7XG4gICAgICAgIG9wdGlvbnMucGF0aCA9IGAvZGVwbG95bWVudHMvJHttb2RlbH0ke29wdGlvbnMucGF0aH1gO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuYnVpbGRSZXF1ZXN0KG9wdGlvbnMpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0QXp1cmVBRFRva2VuKCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9henVyZUFEVG9rZW5Qcm92aWRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLl9henVyZUFEVG9rZW5Qcm92aWRlcigpO1xuICAgICAgaWYgKCF0b2tlbiB8fCB0eXBlb2YgdG9rZW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcnMuT3BlbkFJRXJyb3IoXG4gICAgICAgICAgYEV4cGVjdGVkICdhenVyZUFEVG9rZW5Qcm92aWRlcicgYXJndW1lbnQgdG8gcmV0dXJuIGEgc3RyaW5nIGJ1dCBpdCByZXR1cm5lZCAke3Rva2VufWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgYXV0aEhlYWRlcnMob3B0czogQ29yZS5GaW5hbFJlcXVlc3RPcHRpb25zKTogQ29yZS5IZWFkZXJzIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgYXN5bmMgcHJlcGFyZU9wdGlvbnMob3B0czogQ29yZS5GaW5hbFJlcXVlc3RPcHRpb25zPHVua25vd24+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLyoqXG4gICAgICogVGhlIHVzZXIgc2hvdWxkIHByb3ZpZGUgYSBiZWFyZXIgdG9rZW4gcHJvdmlkZXIgaWYgdGhleSB3YW50XG4gICAgICogdG8gdXNlIEF6dXJlIEFEIGF1dGhlbnRpY2F0aW9uLiBUaGUgdXNlciBzaG91bGRuJ3Qgc2V0IHRoZVxuICAgICAqIEF1dGhvcml6YXRpb24gaGVhZGVyIG1hbnVhbGx5IGJlY2F1c2UgdGhlIGhlYWRlciBpcyBvdmVyd3JpdHRlblxuICAgICAqIHdpdGggdGhlIEF6dXJlIEFEIHRva2VuIGlmIGEgYmVhcmVyIHRva2VuIHByb3ZpZGVyIGlzIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIGlmIChvcHRzLmhlYWRlcnM/LlsnYXBpLWtleSddKSB7XG4gICAgICByZXR1cm4gc3VwZXIucHJlcGFyZU9wdGlvbnMob3B0cyk7XG4gICAgfVxuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdGhpcy5fZ2V0QXp1cmVBRFRva2VuKCk7XG4gICAgb3B0cy5oZWFkZXJzID8/PSB7fTtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIG9wdHMuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3Rva2VufWA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFwaUtleSAhPT0gQVBJX0tFWV9TRU5USU5FTCkge1xuICAgICAgb3B0cy5oZWFkZXJzWydhcGkta2V5J10gPSB0aGlzLmFwaUtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcignVW5hYmxlIHRvIGhhbmRsZSBhdXRoJyk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wcmVwYXJlT3B0aW9ucyhvcHRzKTtcbiAgfVxufVxuXG5jb25zdCBfZGVwbG95bWVudHNfZW5kcG9pbnRzID0gbmV3IFNldChbXG4gICcvY29tcGxldGlvbnMnLFxuICAnL2NoYXQvY29tcGxldGlvbnMnLFxuICAnL2VtYmVkZGluZ3MnLFxuICAnL2F1ZGlvL3RyYW5zY3JpcHRpb25zJyxcbiAgJy9hdWRpby90cmFuc2xhdGlvbnMnLFxuICAnL2F1ZGlvL3NwZWVjaCcsXG4gICcvaW1hZ2VzL2dlbmVyYXRpb25zJyxcbl0pO1xuXG5jb25zdCBBUElfS0VZX1NFTlRJTkVMID0gJzxNaXNzaW5nIEtleT4nO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVuZCBBenVyZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCB7IHRvRmlsZSwgZmlsZUZyb21QYXRoIH0gZnJvbSAnLi91cGxvYWRzJztcbmV4cG9ydCB7XG4gIE9wZW5BSUVycm9yLFxuICBBUElFcnJvcixcbiAgQVBJQ29ubmVjdGlvbkVycm9yLFxuICBBUElDb25uZWN0aW9uVGltZW91dEVycm9yLFxuICBBUElVc2VyQWJvcnRFcnJvcixcbiAgTm90Rm91bmRFcnJvcixcbiAgQ29uZmxpY3RFcnJvcixcbiAgUmF0ZUxpbWl0RXJyb3IsXG4gIEJhZFJlcXVlc3RFcnJvcixcbiAgQXV0aGVudGljYXRpb25FcnJvcixcbiAgSW50ZXJuYWxTZXJ2ZXJFcnJvcixcbiAgUGVybWlzc2lvbkRlbmllZEVycm9yLFxuICBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IsXG59IGZyb20gJy4vZXJyb3InO1xuXG5leHBvcnQgZGVmYXVsdCBPcGVuQUk7XG4iLCAiaW1wb3J0IE9wZW5BSSBmcm9tICdvcGVuYWknO1xuaW1wb3J0IHsgRW1iZWRkaW5nUmVzcG9uc2UgfSBmcm9tICcuLi9tb2RlbHMvRG9jdW1lbnRDaHVuayc7XG5pbXBvcnQgeyBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBFcnJvckhhbmRsZXIgfSBmcm9tICcuLi91dGlscy9FcnJvckhhbmRsZXInO1xuaW1wb3J0IHsgT3BlbkFJU2V0dGluZ3MgfSBmcm9tICcuLi9zZXR0aW5ncy9TZXR0aW5ncyc7XG5cbmV4cG9ydCBjbGFzcyBPcGVuQUlTZXJ2aWNlIHtcblx0cHJpdmF0ZSBjbGllbnQ6IE9wZW5BSSB8IG51bGw7XG5cdHByaXZhdGUgcmF0ZUxpbWl0RGVsYXk6IG51bWJlciA9IDIwOyAvLyBtcyBiZXR3ZWVuIHJlcXVlc3RzXG5cdHByaXZhdGUgbGFzdFJlcXVlc3RUaW1lOiBudW1iZXIgPSAwO1xuXHRwcml2YXRlIHJlYWRvbmx5IGVycm9ySGFuZGxlcjogRXJyb3JIYW5kbGVyO1xuXHRwcml2YXRlIHNldHRpbmdzOiBPcGVuQUlTZXR0aW5ncztcblxuXHRjb25zdHJ1Y3RvcihzZXR0aW5nczogT3BlbkFJU2V0dGluZ3MsIGVycm9ySGFuZGxlcjogRXJyb3JIYW5kbGVyKSB7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuXHRcdHRoaXMuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuXG5cdFx0aWYgKCFzZXR0aW5ncy5hcGlLZXkpIHtcblx0XHRcdGNvbnNvbGUud2FybignT3BlbkFJIEFQSSBrZXkgaXMgbWlzc2luZy4gT3BlbkFJU2VydmljZSB3aWxsIG5vdCBiZSBpbml0aWFsaXplZC4nKTtcblx0XHRcdHRoaXMuY2xpZW50ID0gbnVsbDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJbml0aWFsaXplIE9wZW5BSSBjbGllbnQgd2l0aCBicm93c2VyIHN1cHBvcnRcblx0XHR0aGlzLmNsaWVudCA9IG5ldyBPcGVuQUkoe1xuXHRcdFx0YXBpS2V5OiBzZXR0aW5ncy5hcGlLZXksXG5cdFx0XHRkYW5nZXJvdXNseUFsbG93QnJvd3NlcjogdHJ1ZSwgLy8gRW5hYmxlIGJyb3dzZXItbGlrZSBlbnZpcm9ubWVudCB1c2FnZVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoZSBzZXJ2aWNlIGlzIGluaXRpYWxpemVkXG5cdCAqL1xuXHRwdWJsaWMgaXNJbml0aWFsaXplZCgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5jbGllbnQgIT09IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBlbWJlZGRpbmdzIGZvciB0aGUgZ2l2ZW4gdGV4dCBjaHVua3Mgd2l0aCByYXRlIGxpbWl0aW5nIGFuZCByZXRyaWVzXG5cdCAqL1xuXHRhc3luYyBjcmVhdGVFbWJlZGRpbmdzKGNodW5rczogc3RyaW5nW10pOiBQcm9taXNlPEVtYmVkZGluZ1Jlc3BvbnNlW10+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ09wZW5BSVNlcnZpY2UgaXMgbm90IGluaXRpYWxpemVkLiBDYW5ub3QgY3JlYXRlIGVtYmVkZGluZ3MuJyk7XG5cdFx0XHRuZXcgTm90aWNlKCdPcGVuQUkgQVBJIGtleSBpcyBtaXNzaW5nLiBQbGVhc2Ugc2V0IGl0IGluIHRoZSBwbHVnaW4gc2V0dGluZ3MuJyk7XG5cdFx0XHRyZXR1cm4gY2h1bmtzLm1hcCgoKSA9PiAoe1xuXHRcdFx0XHRkYXRhOiBbXSxcblx0XHRcdFx0dXNhZ2U6IHsgcHJvbXB0X3Rva2VuczogMCwgdG90YWxfdG9rZW5zOiAwIH0sXG5cdFx0XHRcdG1vZGVsOiBcInRleHQtZW1iZWRkaW5nLWFkYS0wMDJcIiwgLy8gRGVmYXVsdCBtb2RlbCB0byBtYWludGFpbiBvdXRwdXQgY29uc2lzdGVuY3lcblx0XHRcdH0pKTtcblx0XHR9XG5cblx0XHRjb25zdCBlbWJlZGRpbmdzOiBFbWJlZGRpbmdSZXNwb25zZVtdID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IHRpbWVTaW5jZUxhc3RSZXF1ZXN0ID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdFJlcXVlc3RUaW1lO1xuXHRcdFx0XHRpZiAodGltZVNpbmNlTGFzdFJlcXVlc3QgPCB0aGlzLnJhdGVMaW1pdERlbGF5KSB7XG5cdFx0XHRcdFx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PlxuXHRcdFx0XHRcdFx0c2V0VGltZW91dChyZXNvbHZlLCB0aGlzLnJhdGVMaW1pdERlbGF5IC0gdGltZVNpbmNlTGFzdFJlcXVlc3QpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEV4cGxpY2l0bHkgc2V0IHRoZSBtb2RlbCB0byBgdGV4dC1lbWJlZGRpbmctYWRhLTAwMmBcblx0XHRcdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5lbWJlZGRpbmdzLmNyZWF0ZSh7XG5cdFx0XHRcdFx0bW9kZWw6IFwidGV4dC1lbWJlZGRpbmctYWRhLTAwMlwiLCAvLyBVc2UgdGhlIGNvcnJlY3QgbW9kZWxcblx0XHRcdFx0XHRpbnB1dDogY2h1bmtzW2ldLFxuXHRcdFx0XHRcdGVuY29kaW5nX2Zvcm1hdDogXCJmbG9hdFwiLFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0aGlzLmxhc3RSZXF1ZXN0VGltZSA9IERhdGUubm93KCk7XG5cblx0XHRcdFx0ZW1iZWRkaW5ncy5wdXNoKHtcblx0XHRcdFx0XHRkYXRhOiBbXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGVtYmVkZGluZzogcmVzcG9uc2UuZGF0YVswXS5lbWJlZGRpbmcsXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBpLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdHVzYWdlOiB7XG5cdFx0XHRcdFx0XHRwcm9tcHRfdG9rZW5zOiByZXNwb25zZS51c2FnZS5wcm9tcHRfdG9rZW5zLFxuXHRcdFx0XHRcdFx0dG90YWxfdG9rZW5zOiByZXNwb25zZS51c2FnZS50b3RhbF90b2tlbnMsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRtb2RlbDogcmVzcG9uc2UubW9kZWwsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0dGhpcy5oYW5kbGVFbWJlZGRpbmdFcnJvcihlcnJvciwgY2h1bmtzW2ldKTtcblx0XHRcdFx0ZW1iZWRkaW5ncy5wdXNoKHtcblx0XHRcdFx0XHRkYXRhOiBbXSxcblx0XHRcdFx0XHR1c2FnZTogeyBwcm9tcHRfdG9rZW5zOiAwLCB0b3RhbF90b2tlbnM6IDAgfSxcblx0XHRcdFx0XHRtb2RlbDogXCJ0ZXh0LWVtYmVkZGluZy1hZGEtMDAyXCIsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBlbWJlZGRpbmdzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgdmFyaW91cyB0eXBlcyBvZiBPcGVuQUkgQVBJIGVycm9yc1xuXHQgKi9cblx0cHJpdmF0ZSBoYW5kbGVFbWJlZGRpbmdFcnJvcihlcnJvcjogYW55LCBjaHVuazogc3RyaW5nKTogdm9pZCB7XG5cdFx0bGV0IGVycm9yTWVzc2FnZTogc3RyaW5nO1xuXG5cdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgT3BlbkFJLkFQSUVycm9yKSB7XG5cdFx0XHRzd2l0Y2ggKGVycm9yLnN0YXR1cykge1xuXHRcdFx0XHRjYXNlIDQyOTpcblx0XHRcdFx0XHRlcnJvck1lc3NhZ2UgPSAnUmF0ZSBsaW1pdCBleGNlZWRlZC4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4nO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDQwMTpcblx0XHRcdFx0XHRlcnJvck1lc3NhZ2UgPSAnSW52YWxpZCBBUEkga2V5LiBQbGVhc2UgY2hlY2sgeW91ciBzZXR0aW5ncy4nO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDQxMzpcblx0XHRcdFx0XHRlcnJvck1lc3NhZ2UgPSAnVGV4dCBjaHVuayB0b28gbGFyZ2UgZm9yIGVtYmVkZGluZy4nO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGVycm9yTWVzc2FnZSA9IGBPcGVuQUkgQVBJIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXJyb3JNZXNzYWdlID0gYFVuZXhwZWN0ZWQgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gO1xuXHRcdH1cblxuXHRcdC8vIExvZyB0aGUgZXJyb3IgdGhyb3VnaCB0aGUgY2VudHJhbGl6ZWQgZXJyb3IgaGFuZGxlclxuXHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7XG5cdFx0XHRjb250ZXh0OiAnT3BlbkFJU2VydmljZS5jcmVhdGVFbWJlZGRpbmdzJyxcblx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdGNodW5rUHJldmlldzogY2h1bmsuc3Vic3RyaW5nKDAsIDEwMCkgKyAnLi4uJyAvLyBGaXJzdCAxMDAgY2hhcnMgZm9yIGNvbnRleHRcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdG5ldyBOb3RpY2UoYEVycm9yIGNyZWF0aW5nIGVtYmVkZGluZzogJHtlcnJvck1lc3NhZ2V9YCk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyBzZXJ2aWNlIHNldHRpbmdzXG5cdCAqL1xuXHR1cGRhdGVTZXR0aW5ncyhzZXR0aW5nczogT3BlbkFJU2V0dGluZ3MpOiB2b2lkIHtcblx0XHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG5cblx0XHRpZiAoIXNldHRpbmdzLmFwaUtleSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdPcGVuQUkgQVBJIGtleSBpcyBtaXNzaW5nLiBPcGVuQUlTZXJ2aWNlIHdpbGwgbm90IGJlIGluaXRpYWxpemVkLicpO1xuXHRcdFx0dGhpcy5jbGllbnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlaW5pdGlhbGl6ZSB0aGUgT3BlbkFJIGNsaWVudCB3aXRoIHVwZGF0ZWQgc2V0dGluZ3Ncblx0XHR0aGlzLmNsaWVudCA9IG5ldyBPcGVuQUkoe1xuXHRcdFx0YXBpS2V5OiBzZXR0aW5ncy5hcGlLZXksXG5cdFx0XHRkYW5nZXJvdXNseUFsbG93QnJvd3NlcjogdHJ1ZSwgLy8gRW5zdXJlIHRoaXMgcmVtYWlucyBlbmFibGVkXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyByYXRlIGxpbWl0aW5nIHBhcmFtZXRlcnNcblx0ICovXG5cdHVwZGF0ZVJhdGVMaW1pdChkZWxheU1zOiBudW1iZXIpOiB2b2lkIHtcblx0XHR0aGlzLnJhdGVMaW1pdERlbGF5ID0gZGVsYXlNcztcblx0fVxufVxuIiwgImltcG9ydCB7IFZhdWx0LCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IFRleHRTcGxpdHRlciB9IGZyb20gJy4uL3V0aWxzL1RleHRTcGxpdHRlcic7XG5pbXBvcnQge1xuXHRQcm9jZXNzaW5nVGFzayxcblx0VGFza1N0YXR1cyxcblx0VGFza1R5cGUsXG5cdFF1ZXVlU3RhdHMsXG5cdFRhc2tQcm9ncmVzcyxcblx0VGFza1Byb2Nlc3NpbmdFcnJvcixcbn0gZnJvbSAnLi4vbW9kZWxzL1Byb2Nlc3NpbmdUYXNrJztcbmltcG9ydCB7IEVycm9ySGFuZGxlciB9IGZyb20gJy4uL3V0aWxzL0Vycm9ySGFuZGxlcic7XG5pbXBvcnQgeyBOb3RpZmljYXRpb25NYW5hZ2VyIH0gZnJvbSAnLi4vdXRpbHMvTm90aWZpY2F0aW9uTWFuYWdlcic7XG5pbXBvcnQgeyBTdXBhYmFzZVNlcnZpY2UgfSBmcm9tICcuL1N1cGFiYXNlU2VydmljZSc7XG5pbXBvcnQgeyBPcGVuQUlTZXJ2aWNlIH0gZnJvbSAnLi9PcGVuQUlTZXJ2aWNlJztcbmltcG9ydCB7IERFRkFVTFRfQ0hVTktJTkdfT1BUSU9OUyB9IGZyb20gJy4uL3NldHRpbmdzL1NldHRpbmdzJztcblxuZXhwb3J0IGNsYXNzIFF1ZXVlU2VydmljZSB7XG5cdHByaXZhdGUgcXVldWU6IFByb2Nlc3NpbmdUYXNrW10gPSBbXTtcblx0cHJpdmF0ZSBwcm9jZXNzaW5nUXVldWU6IFByb2Nlc3NpbmdUYXNrW10gPSBbXTtcblx0cHJpdmF0ZSBpc1Byb2Nlc3Npbmc6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHJpdmF0ZSBpc1N0b3BwZWQ6IGJvb2xlYW4gPSB0cnVlO1xuXHRwcml2YXRlIGlzSW5pdGlhbGl6ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHJpdmF0ZSBwcm9jZXNzaW5nSW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgdGV4dFNwbGl0dGVyOiBUZXh0U3BsaXR0ZXI7XG5cdHByaXZhdGUgdmF1bHQ6IFZhdWx0O1xuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByaXZhdGUgbWF4Q29uY3VycmVudDogbnVtYmVyLFxuXHRcdHByaXZhdGUgbWF4UmV0cmllczogbnVtYmVyLFxuXHRcdHByaXZhdGUgc3VwYWJhc2VTZXJ2aWNlOiBTdXBhYmFzZVNlcnZpY2UgfCBudWxsLFxuXHRcdHByaXZhdGUgb3BlbkFJU2VydmljZTogT3BlbkFJU2VydmljZSB8IG51bGwsXG5cdFx0cHJpdmF0ZSBlcnJvckhhbmRsZXI6IEVycm9ySGFuZGxlcixcblx0XHRwcml2YXRlIG5vdGlmaWNhdGlvbk1hbmFnZXI6IE5vdGlmaWNhdGlvbk1hbmFnZXIsXG5cdFx0dmF1bHQ6IFZhdWx0LFxuXHRcdGNodW5rU2V0dGluZ3M/OiB7IGNodW5rU2l6ZTogbnVtYmVyOyBjaHVua092ZXJsYXA6IG51bWJlcjsgbWluQ2h1bmtTaXplOiBudW1iZXIgfVxuXHQpIHtcblx0XHR0aGlzLnZhdWx0ID0gdmF1bHQ7XG5cdFx0Y29uc3QgdmFsaWRhdGVkQ2h1bmtTZXR0aW5ncyA9IGNodW5rU2V0dGluZ3MgfHwgeyAuLi5ERUZBVUxUX0NIVU5LSU5HX09QVElPTlMgfTtcblxuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLnRleHRTcGxpdHRlciA9IG5ldyBUZXh0U3BsaXR0ZXIodmFsaWRhdGVkQ2h1bmtTZXR0aW5ncyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7XG5cdFx0XHRcdGNvbnRleHQ6ICdRdWV1ZVNlcnZpY2UuY29uc3RydWN0b3InLFxuXHRcdFx0XHRtZXRhZGF0YTogdmFsaWRhdGVkQ2h1bmtTZXR0aW5ncyxcblx0XHRcdH0pO1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBUZXh0U3BsaXR0ZXIgd2l0aCBwcm92aWRlZCBzZXR0aW5ncy4nKTtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgc3RhcnQoKTogdm9pZCB7XG5cdFx0aWYgKCF0aGlzLmlzU3RvcHBlZCkgcmV0dXJuO1xuXG5cdFx0dGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcblx0XHR0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuXG5cdFx0dGhpcy5wcm9jZXNzaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG5cdFx0XHRpZiAoIXRoaXMuaXNQcm9jZXNzaW5nKSB7XG5cdFx0XHRcdHRoaXMucHJvY2Vzc1F1ZXVlKCk7XG5cdFx0XHR9XG5cdFx0fSwgMTAwMCk7XG5cdH1cblxuXHRwdWJsaWMgc3RvcCgpOiB2b2lkIHtcblx0XHR0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG5cdFx0aWYgKHRoaXMucHJvY2Vzc2luZ0ludGVydmFsKSB7XG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMucHJvY2Vzc2luZ0ludGVydmFsKTtcblx0XHRcdHRoaXMucHJvY2Vzc2luZ0ludGVydmFsID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRhc3luYyBhZGRUYXNrKHRhc2s6IFByb2Nlc3NpbmdUYXNrKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKHRoaXMucXVldWUubGVuZ3RoID49IDEwMDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihUYXNrUHJvY2Vzc2luZ0Vycm9yLlFVRVVFX0ZVTEwpO1xuXHRcdH1cblxuXHRcdGNvbnNvbGUubG9nKCdBZGRpbmcgdGFzayB0byBxdWV1ZTonLCB7XG5cdFx0XHRpZDogdGFzay5pZCxcblx0XHRcdHR5cGU6IHRhc2sudHlwZSxcblx0XHRcdHByaW9yaXR5OiB0YXNrLnByaW9yaXR5XG5cdFx0fSk7XG5cblx0XHRpZiAodGFzay5wcmlvcml0eSA+IDEpIHtcblx0XHRcdHRoaXMucXVldWUudW5zaGlmdCh0YXNrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5xdWV1ZS5wdXNoKHRhc2spO1xuXHRcdH1cblxuXHRcdHRoaXMubm90aWZ5UHJvZ3Jlc3ModGFzay5pZCwgMCwgJ1Rhc2sgcXVldWVkJyk7XG5cblx0XHRpZiAoIXRoaXMuaXNQcm9jZXNzaW5nICYmICF0aGlzLmlzU3RvcHBlZCkge1xuXHRcdFx0dGhpcy5wcm9jZXNzUXVldWUoKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIHByb2Nlc3NRdWV1ZSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAodGhpcy5pc1Byb2Nlc3NpbmcgfHwgdGhpcy5pc1N0b3BwZWQgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLmlzUHJvY2Vzc2luZyA9IHRydWU7XG5cblx0XHR0cnkge1xuXHRcdFx0d2hpbGUgKHRoaXMucXVldWUubGVuZ3RoID4gMCAmJiB0aGlzLnByb2Nlc3NpbmdRdWV1ZS5sZW5ndGggPCB0aGlzLm1heENvbmN1cnJlbnQpIHtcblx0XHRcdFx0Y29uc3QgdGFzayA9IHRoaXMucXVldWUuc2hpZnQoKTtcblx0XHRcdFx0aWYgKHRhc2spIHtcblx0XHRcdFx0XHR0aGlzLnByb2Nlc3NpbmdRdWV1ZS5wdXNoKHRhc2spO1xuXHRcdFx0XHRcdHRoaXMucHJvY2Vzc1Rhc2sodGFzaykuY2F0Y2goKGVycm9yKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLmhhbmRsZVRhc2tFcnJvcih0YXNrLCBlcnJvcik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ1F1ZXVlU2VydmljZS5wcm9jZXNzUXVldWUnLFxuXHRcdFx0fSk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBwcm9jZXNzVGFzayh0YXNrOiBQcm9jZXNzaW5nVGFzayk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIHRhc2s6Jywge1xuXHRcdFx0aWQ6IHRhc2suaWQsXG5cdFx0XHR0eXBlOiB0YXNrLnR5cGUsXG5cdFx0XHRzdGF0dXM6IHRhc2suc3RhdHVzXG5cdFx0fSk7XG5cblx0XHR0cnkge1xuXHRcdFx0dGFzay5zdGF0dXMgPSBUYXNrU3RhdHVzLlBST0NFU1NJTkc7XG5cdFx0XHR0YXNrLnN0YXJ0ZWRBdCA9IERhdGUubm93KCk7XG5cdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDAsIGBTdGFydGluZyAke3Rhc2sudHlwZS50b0xvd2VyQ2FzZSgpfWApO1xuXG5cdFx0XHRzd2l0Y2ggKHRhc2sudHlwZSkge1xuXHRcdFx0XHRjYXNlIFRhc2tUeXBlLkNSRUFURTpcblx0XHRcdFx0Y2FzZSBUYXNrVHlwZS5VUERBVEU6XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wcm9jZXNzQ3JlYXRlVXBkYXRlVGFzayh0YXNrKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBUYXNrVHlwZS5ERUxFVEU6XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wcm9jZXNzRGVsZXRlVGFzayh0YXNrKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHRhc2sgdHlwZTogJHt0YXNrLnR5cGV9YCk7XG5cdFx0XHR9XG5cblx0XHRcdHRhc2suc3RhdHVzID0gVGFza1N0YXR1cy5DT01QTEVURUQ7XG5cdFx0XHR0YXNrLmNvbXBsZXRlZEF0ID0gRGF0ZS5ub3coKTtcblx0XHRcdHRoaXMubm90aWZ5UHJvZ3Jlc3ModGFzay5pZCwgMTAwLCAnVGFzayBjb21wbGV0ZWQnKTtcblx0XHRcdGNvbnNvbGUubG9nKCdUYXNrIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHk6JywgdGFzay5pZCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHByb2Nlc3NpbmcgdGFzazonLCB7XG5cdFx0XHRcdHRhc2tJZDogdGFzay5pZCxcblx0XHRcdFx0ZXJyb3I6IGVycm9yXG5cdFx0XHR9KTtcblx0XHRcdGF3YWl0IHRoaXMuaGFuZGxlVGFza0Vycm9yKHRhc2ssIGVycm9yKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dGhpcy5yZW1vdmVGcm9tUHJvY2Vzc2luZ1F1ZXVlKHRhc2spO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc0NyZWF0ZVVwZGF0ZVRhc2sodGFzazogUHJvY2Vzc2luZ1Rhc2spOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuc3VwYWJhc2VTZXJ2aWNlIHx8ICF0aGlzLm9wZW5BSVNlcnZpY2UpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgc2VydmljZXMgbm90IGluaXRpYWxpemVkJyk7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdGNvbnNvbGUubG9nKCdSZWFkaW5nIGZpbGU6JywgdGFzay5pZCk7XG5cblx0XHRcdC8vIEdldCBmaWxlIGZyb20gdGFzayBwYXRoXG5cdFx0XHRjb25zdCBmaWxlID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGFzay5pZCk7XG5cdFx0XHRpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgRmlsZSBub3QgZm91bmQgb3Igbm90IGEgVEZpbGU6ICR7dGFzay5pZH1gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVhZCBmaWxlIGNvbnRlbnRcblx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLnZhdWx0LnJlYWQoZmlsZSk7XG5cdFx0XHRjb25zb2xlLmxvZygnRmlsZSBjb250ZW50IHJlYWQgc3VjY2Vzc2Z1bGx5OicsIHtcblx0XHRcdFx0ZmlsZUlkOiB0YXNrLmlkLFxuXHRcdFx0XHRjb250ZW50TGVuZ3RoOiBjb250ZW50Lmxlbmd0aCxcblx0XHRcdFx0Y29udGVudFByZXZpZXc6IGNvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMClcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBTcGxpdCB0aGUgY29udGVudCBpbnRvIGNodW5rc1xuXHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCAyMCwgJ1NwbGl0dGluZyBjb250ZW50Jyk7XG5cdFx0XHRjb25zdCBjaHVua3MgPSB0aGlzLnRleHRTcGxpdHRlci5zcGxpdERvY3VtZW50KGNvbnRlbnQsIHRhc2subWV0YWRhdGEpO1xuXG5cdFx0XHQvLyBBZGQgbnVsbCBjaGVjayBmb3IgY2h1bmtzXG5cdFx0XHRpZiAoIWNodW5rcyB8fCAhQXJyYXkuaXNBcnJheShjaHVua3MpIHx8IGNodW5rcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ05vIHZhbGlkIGNodW5rcyBjcmVhdGVkIGZvciBmaWxlOicsIHtcblx0XHRcdFx0XHRmaWxlSWQ6IHRhc2suaWQsXG5cdFx0XHRcdFx0Y29udGVudExlbmd0aDogY29udGVudC5sZW5ndGgsXG5cdFx0XHRcdFx0c2V0dGluZ3M6IHRoaXMudGV4dFNwbGl0dGVyLmdldFNldHRpbmdzKClcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjsgLy8gRXhpdCBncmFjZWZ1bGx5IGluc3RlYWQgb2YgdGhyb3dpbmcgZXJyb3Jcblx0XHRcdH1cblx0XHRcdGNvbnNvbGUubG9nKCdDb250ZW50IHNwbGl0IGludG8gY2h1bmtzOicsIHtcblx0XHRcdFx0bnVtYmVyT2ZDaHVua3M6IGNodW5rcy5sZW5ndGgsXG5cdFx0XHRcdGNodW5rU2l6ZXM6IGNodW5rcy5tYXAoYyA9PiBjLmNvbnRlbnQubGVuZ3RoKSxcblx0XHRcdFx0Zmlyc3RDaHVua1ByZXZpZXc6IGNodW5rc1swXT8uY29udGVudC5zdWJzdHJpbmcoMCwgMTAwKVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignTm8gY2h1bmtzIGNyZWF0ZWQgZm9yIGZpbGU6Jywge1xuXHRcdFx0XHRcdGZpbGVJZDogdGFzay5pZCxcblx0XHRcdFx0XHRjb250ZW50TGVuZ3RoOiBjb250ZW50Lmxlbmd0aCxcblx0XHRcdFx0XHRzZXR0aW5nczogdGhpcy50ZXh0U3BsaXR0ZXIuZ2V0U2V0dGluZ3MoKVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyBjaHVua3MgY3JlYXRlZCBmcm9tIGZpbGUgY29udGVudCcpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBHZW5lcmF0ZSBlbWJlZGRpbmdzIGZvciBlYWNoIGNodW5rXG5cdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDQwLCAnR2VuZXJhdGluZyBlbWJlZGRpbmdzJyk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMub3BlbkFJU2VydmljZS5jcmVhdGVFbWJlZGRpbmdzKFtjaHVua3NbaV0uY29udGVudF0pO1xuXHRcdFx0XHRpZiAocmVzcG9uc2UubGVuZ3RoID4gMCAmJiByZXNwb25zZVswXS5kYXRhLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRjaHVua3NbaV0uZW1iZWRkaW5nID0gcmVzcG9uc2VbMF0uZGF0YVswXS5lbWJlZGRpbmc7XG5cdFx0XHRcdFx0Ly8gQWRkIHZlY3Rvcml6ZWRfYXQgdGltZXN0YW1wIHdoZW4gZW1iZWRkaW5nIGlzIGdlbmVyYXRlZFxuXHRcdFx0XHRcdGNodW5rc1tpXS52ZWN0b3JpemVkX2F0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGBHZW5lcmF0ZWQgZW1iZWRkaW5nIGZvciBjaHVuayAke2kgKyAxfS8ke2NodW5rcy5sZW5ndGh9YCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUgZW1iZWRkaW5nIGZvciBjaHVuayAke2kgKyAxfWApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyhcblx0XHRcdFx0XHR0YXNrLmlkLFxuXHRcdFx0XHRcdDQwICsgTWF0aC5mbG9vcigoaSAvIGNodW5rcy5sZW5ndGgpICogMzApLFxuXHRcdFx0XHRcdGBQcm9jZXNzZWQgJHtpICsgMX0gb2YgJHtjaHVua3MubGVuZ3RofSBjaHVua3NgXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFByZXBhcmUgY2h1bmtzIHdpdGggY29tcGxldGUgbWV0YWRhdGEgZm9yIGRhdGFiYXNlXG5cdFx0XHRjb25zdCBlbmhhbmNlZENodW5rcyA9IGNodW5rcy5tYXAoY2h1bmsgPT4gKHtcblx0XHRcdFx0Li4uY2h1bmssXG5cdFx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdFx0Li4uY2h1bmsubWV0YWRhdGEsXG5cdFx0XHRcdFx0Ly8gRW5zdXJlIGFsbCBtZXRhZGF0YSBmaWVsZHMgYXJlIHByZXNlbnRcblx0XHRcdFx0XHRhbGlhc2VzOiBjaHVuay5tZXRhZGF0YS5hbGlhc2VzIHx8IFtdLFxuXHRcdFx0XHRcdGxpbmtzOiBjaHVuay5tZXRhZGF0YS5saW5rcyB8fCBbXSxcblx0XHRcdFx0XHR0YWdzOiBjaHVuay5tZXRhZGF0YS50YWdzIHx8IFtdXG5cdFx0XHRcdH1cblx0XHRcdH0pKTtcblxuXHRcdFx0Ly8gU2F2ZSBjaHVua3MgdG8gZGF0YWJhc2Vcblx0XHRcdHRoaXMubm90aWZ5UHJvZ3Jlc3ModGFzay5pZCwgNzAsICdTYXZpbmcgdG8gZGF0YWJhc2UnKTtcblx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLnVwc2VydENodW5rcyhlbmhhbmNlZENodW5rcyk7XG5cdFx0XHRjb25zb2xlLmxvZygnQ2h1bmtzIHNhdmVkIHRvIGRhdGFiYXNlOicsIHtcblx0XHRcdFx0bnVtYmVyT2ZDaHVua3M6IGVuaGFuY2VkQ2h1bmtzLmxlbmd0aCxcblx0XHRcdFx0ZmlsZUlkOiB0YXNrLmlkXG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCAxMDAsICdQcm9jZXNzaW5nIGNvbXBsZXRlZCcpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBpbiBwcm9jZXNzQ3JlYXRlVXBkYXRlVGFzazonLCB7XG5cdFx0XHRcdGVycm9yLFxuXHRcdFx0XHR0YXNrSWQ6IHRhc2suaWQsXG5cdFx0XHRcdG1ldGFkYXRhOiB0YXNrLm1ldGFkYXRhXG5cdFx0XHR9KTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc0RlbGV0ZVRhc2sodGFzazogUHJvY2Vzc2luZ1Rhc2spOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuc3VwYWJhc2VTZXJ2aWNlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1N1cGFiYXNlIHNlcnZpY2Ugbm90IGluaXRpYWxpemVkJyk7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMubm90aWZ5UHJvZ3Jlc3ModGFzay5pZCwgNTAsICdEZWxldGluZyBmcm9tIGRhdGFiYXNlJyk7XG5cdFx0XHRhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS5kZWxldGVEb2N1bWVudENodW5rcyh0YXNrLm1ldGFkYXRhLm9ic2lkaWFuSWQpO1xuXHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCAxMDAsICdEZWxldGUgY29tcGxldGVkJyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHByb2Nlc3NEZWxldGVUYXNrOicsIHtcblx0XHRcdFx0ZXJyb3IsXG5cdFx0XHRcdHRhc2tJZDogdGFzay5pZCxcblx0XHRcdFx0bWV0YWRhdGE6IHRhc2subWV0YWRhdGFcblx0XHRcdH0pO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBoYW5kbGVUYXNrRXJyb3IodGFzazogUHJvY2Vzc2luZ1Rhc2ssIGVycm9yOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0YXNrLnJldHJ5Q291bnQgPSAodGFzay5yZXRyeUNvdW50IHx8IDApICsgMTtcblx0XHR0YXNrLnVwZGF0ZWRBdCA9IERhdGUubm93KCk7XG5cblx0XHRpZiAodGFzay5yZXRyeUNvdW50IDwgdGhpcy5tYXhSZXRyaWVzKSB7XG5cdFx0XHR0YXNrLnN0YXR1cyA9IFRhc2tTdGF0dXMuUkVUUllJTkc7XG5cdFx0XHR0aGlzLnF1ZXVlLnVuc2hpZnQodGFzayk7XG5cblx0XHRcdHRoaXMubm90aWZ5UHJvZ3Jlc3ModGFzay5pZCwgMCwgYFJldHJ5IGF0dGVtcHQgJHt0YXNrLnJldHJ5Q291bnR9YCk7XG5cdFx0XHRjb25zb2xlLmxvZygnVGFzayBxdWV1ZWQgZm9yIHJldHJ5OicsIHtcblx0XHRcdFx0dGFza0lkOiB0YXNrLmlkLFxuXHRcdFx0XHRyZXRyeUNvdW50OiB0YXNrLnJldHJ5Q291bnQsXG5cdFx0XHRcdG1heFJldHJpZXM6IHRoaXMubWF4UmV0cmllc1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhc2suc3RhdHVzID0gVGFza1N0YXR1cy5GQUlMRUQ7XG5cdFx0XHR0YXNrLmVycm9yID0ge1xuXHRcdFx0XHRtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuXHRcdFx0XHRjb2RlOiBlcnJvci5jb2RlIHx8ICdVTktOT1dOX0VSUk9SJyxcblx0XHRcdFx0c3RhY2s6IGVycm9yLnN0YWNrLFxuXHRcdFx0fTtcblx0XHRcdHRhc2suY29tcGxldGVkQXQgPSBEYXRlLm5vdygpO1xuXHRcdFx0Y29uc29sZS5lcnJvcignVGFzayBmYWlsZWQgYWZ0ZXIgbWF4IHJldHJpZXM6Jywge1xuXHRcdFx0XHR0YXNrSWQ6IHRhc2suaWQsXG5cdFx0XHRcdGVycm9yOiB0YXNrLmVycm9yXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0Y29udGV4dDogJ1F1ZXVlU2VydmljZS5wcm9jZXNzVGFzaycsXG5cdFx0XHR0YXNrSWQ6IHRhc2suaWQsXG5cdFx0XHR0YXNrVHlwZTogdGFzay50eXBlLFxuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSByZW1vdmVGcm9tUHJvY2Vzc2luZ1F1ZXVlKHRhc2s6IFByb2Nlc3NpbmdUYXNrKTogdm9pZCB7XG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLnByb2Nlc3NpbmdRdWV1ZS5maW5kSW5kZXgoKHQpID0+IHQuaWQgPT09IHRhc2suaWQpO1xuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdHRoaXMucHJvY2Vzc2luZ1F1ZXVlLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBub3RpZnlQcm9ncmVzcyh0YXNrSWQ6IHN0cmluZywgcHJvZ3Jlc3M6IG51bWJlciwgbWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG5cdFx0dGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyLnVwZGF0ZVByb2dyZXNzKHtcblx0XHRcdHRhc2tJZCxcblx0XHRcdHByb2dyZXNzLFxuXHRcdFx0Y3VycmVudFN0ZXA6IG1lc3NhZ2UsXG5cdFx0XHR0b3RhbFN0ZXBzOiAxLFxuXHRcdFx0Y3VycmVudFN0ZXBOdW1iZXI6IDEsXG5cdFx0fSk7XG5cdH1cblxuXHRwdWJsaWMgZ2V0UXVldWVTdGF0cygpOiBRdWV1ZVN0YXRzIHtcblx0XHRjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXHRcdGNvbnN0IG9uZUhvdXIgPSA2MCAqIDYwICogMTAwMDtcblxuXHRcdGNvbnN0IHRhc2tzQnlTdGF0dXMgPSB0aGlzLnF1ZXVlLnJlZHVjZSgoYWNjLCB0YXNrKSA9PiB7XG5cdFx0XHRhY2NbdGFzay5zdGF0dXNdID0gKGFjY1t0YXNrLnN0YXR1c10gfHwgMCkgKyAxO1xuXHRcdFx0cmV0dXJuIGFjYztcblx0XHR9LCB7fSBhcyBSZWNvcmQ8VGFza1N0YXR1cywgbnVtYmVyPik7XG5cblx0XHRjb25zdCB0YXNrc0J5VHlwZSA9IHRoaXMucXVldWUucmVkdWNlKChhY2MsIHRhc2spID0+IHtcblx0XHRcdGFjY1t0YXNrLnR5cGVdID0gKGFjY1t0YXNrLnR5cGVdIHx8IDApICsgMTtcblx0XHRcdHJldHVybiBhY2M7XG5cdFx0fSwge30gYXMgUmVjb3JkPFRhc2tUeXBlLCBudW1iZXI+KTtcblxuXHRcdGNvbnN0IGNvbXBsZXRlZFRhc2tzID0gdGhpcy5xdWV1ZS5maWx0ZXIoXG5cdFx0XHR0YXNrID0+IHRhc2suc3RhdHVzID09PSBUYXNrU3RhdHVzLkNPTVBMRVRFRCAmJiB0YXNrLmNvbXBsZXRlZEF0XG5cdFx0KTtcblxuXHRcdGNvbnN0IGF2ZXJhZ2VUaW1lID0gY29tcGxldGVkVGFza3MubGVuZ3RoID4gMFxuXHRcdFx0PyBjb21wbGV0ZWRUYXNrcy5yZWR1Y2UoKHN1bSwgdGFzaykgPT4gc3VtICsgKHRhc2suY29tcGxldGVkQXQhIC0gdGFzay5zdGFydGVkQXQhKSwgMCkgLyBjb21wbGV0ZWRUYXNrcy5sZW5ndGhcblx0XHRcdDogMDtcblxuXHRcdGNvbnN0IHRhc2tzTGFzdEhvdXIgPSBjb21wbGV0ZWRUYXNrcy5maWx0ZXIoXG5cdFx0XHR0YXNrID0+IHRhc2suY29tcGxldGVkQXQhID4gbm93IC0gb25lSG91clxuXHRcdCkubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvdGFsVGFza3M6IHRoaXMucXVldWUubGVuZ3RoLFxuXHRcdFx0dGFza3NCeVN0YXR1cyxcblx0XHRcdHRhc2tzQnlUeXBlLFxuXHRcdFx0YXZlcmFnZVByb2Nlc3NpbmdUaW1lOiBhdmVyYWdlVGltZSxcblx0XHRcdGZhaWxlZFRhc2tzOiB0YXNrc0J5U3RhdHVzW1Rhc2tTdGF0dXMuRkFJTEVEXSB8fCAwLFxuXHRcdFx0cmV0cnlpbmdUYXNrczogdGFza3NCeVN0YXR1c1tUYXNrU3RhdHVzLlJFVFJZSU5HXSB8fCAwLFxuXHRcdFx0dGFza3NMYXN0SG91cixcblx0XHR9O1xuXHR9XG5cblx0cHVibGljIGNsZWFyKCk6IHZvaWQge1xuXHRcdHRoaXMucXVldWUgPSBbXTtcblx0XHR0aGlzLnByb2Nlc3NpbmdRdWV1ZSA9IFtdO1xuXHRcdHRoaXMubm90aWZpY2F0aW9uTWFuYWdlci5jbGVhcigpO1xuXHR9XG5cblx0cHVibGljIHVwZGF0ZVNldHRpbmdzKHNldHRpbmdzOiB7XG5cdFx0bWF4Q29uY3VycmVudDogbnVtYmVyO1xuXHRcdG1heFJldHJpZXM6IG51bWJlcjtcblx0XHRjaHVua1NldHRpbmdzPzogeyBjaHVua1NpemU6IG51bWJlcjsgY2h1bmtPdmVybGFwOiBudW1iZXI7IG1pbkNodW5rU2l6ZTogbnVtYmVyIH07XG5cdH0pOiB2b2lkIHtcblx0XHR0aGlzLm1heENvbmN1cnJlbnQgPSBzZXR0aW5ncy5tYXhDb25jdXJyZW50O1xuXHRcdHRoaXMubWF4UmV0cmllcyA9IHNldHRpbmdzLm1heFJldHJpZXM7XG5cblx0XHRpZiAoc2V0dGluZ3MuY2h1bmtTZXR0aW5ncykge1xuXHRcdFx0dGhpcy50ZXh0U3BsaXR0ZXIgPSBuZXcgVGV4dFNwbGl0dGVyKHNldHRpbmdzLmNodW5rU2V0dGluZ3MpO1xuXHRcdH1cblx0fVxufVxuIiwgIi8vIHNyYy9zZXJ2aWNlcy9NZXRhZGF0YUV4dHJhY3Rvci50c1xuXG5pbXBvcnQgeyBURmlsZSwgcGFyc2VZYW1sIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgRG9jdW1lbnRNZXRhZGF0YSwgRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IgfSBmcm9tICcuLi9tb2RlbHMvRG9jdW1lbnRDaHVuayc7XG5cbmV4cG9ydCBjbGFzcyBNZXRhZGF0YUV4dHJhY3RvciB7XG5cdC8qKlxuXHQgKiBFeHRyYWN0cyBhbGwgbWV0YWRhdGEgZnJvbSBhbiBPYnNpZGlhbiBmaWxlXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgZXh0cmFjdE1ldGFkYXRhKGZpbGU6IFRGaWxlLCBjb250ZW50Pzogc3RyaW5nKTogUHJvbWlzZTxEb2N1bWVudE1ldGFkYXRhPiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGZpbGVDb250ZW50ID0gY29udGVudCB8fCBhd2FpdCBmaWxlLnZhdWx0LnJlYWQoZmlsZSk7XG5cdFx0XHRjb25zdCBmcm9udE1hdHRlciA9IHRoaXMuZXh0cmFjdEZyb250TWF0dGVyKGZpbGVDb250ZW50KTtcblxuXHRcdFx0Y29uc3QgbWV0YWRhdGE6IERvY3VtZW50TWV0YWRhdGEgPSB7XG5cdFx0XHRcdG9ic2lkaWFuSWQ6IGZpbGUucGF0aCxcblx0XHRcdFx0cGF0aDogZmlsZS5wYXRoLFxuXHRcdFx0XHRsYXN0TW9kaWZpZWQ6IGZpbGUuc3RhdC5tdGltZSxcblx0XHRcdFx0Y3JlYXRlZDogZmlsZS5zdGF0LmN0aW1lLFxuXHRcdFx0XHRzaXplOiBmaWxlLnN0YXQuc2l6ZSxcblx0XHRcdFx0ZnJvbnRNYXR0ZXI6IGZyb250TWF0dGVyLFxuXHRcdFx0XHR0YWdzOiB0aGlzLmV4dHJhY3RUYWdzKGZpbGVDb250ZW50LCBmcm9udE1hdHRlciksXG5cdFx0XHRcdGxpbmtzOiB0aGlzLmV4dHJhY3RMaW5rcyhmaWxlQ29udGVudCksXG5cdFx0XHRcdGN1c3RvbU1ldGFkYXRhOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gRXh0cmFjdCBvcHRpb25hbCBtZXRhZGF0YVxuXHRcdFx0Y29uc3QgYWxpYXNlcyA9IHRoaXMuZXh0cmFjdEFsaWFzZXMoZnJvbnRNYXR0ZXIpO1xuXHRcdFx0aWYgKGFsaWFzZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRtZXRhZGF0YS5jdXN0b21NZXRhZGF0YS5hbGlhc2VzID0gYWxpYXNlcztcblx0XHRcdH1cblxuXHRcdFx0Ly8gRXh0cmFjdCBzb3VyY2UgbG9jYXRpb24gaWYgYXZhaWxhYmxlXG5cdFx0XHRjb25zdCBsb2MgPSB0aGlzLmV4dHJhY3RTb3VyY2VMb2NhdGlvbihmcm9udE1hdHRlcik7XG5cdFx0XHRpZiAobG9jKSB7XG5cdFx0XHRcdG1ldGFkYXRhLmxvYyA9IGxvYztcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG44biBjb21wYXRpYmlsaXR5IG1ldGFkYXRhIGlmIHByZXNlbnRcblx0XHRcdGlmIChmcm9udE1hdHRlcj8uc291cmNlKSB7XG5cdFx0XHRcdG1ldGFkYXRhLnNvdXJjZSA9IGZyb250TWF0dGVyLnNvdXJjZTtcblx0XHRcdH1cblx0XHRcdGlmIChmcm9udE1hdHRlcj8uZmlsZV9pZCkge1xuXHRcdFx0XHRtZXRhZGF0YS5maWxlX2lkID0gZnJvbnRNYXR0ZXIuZmlsZV9pZDtcblx0XHRcdH1cblx0XHRcdGlmIChmcm9udE1hdHRlcj8uYmxvYlR5cGUpIHtcblx0XHRcdFx0bWV0YWRhdGEuYmxvYlR5cGUgPSBmcm9udE1hdHRlci5ibG9iVHlwZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1ldGFkYXRhO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBleHRyYWN0aW5nIG1ldGFkYXRhOicsIGVycm9yKTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgJHtEb2N1bWVudFByb2Nlc3NpbmdFcnJvci5JTlZBTElEX01FVEFEQVRBfTogJHtlcnJvci5tZXNzYWdlfWApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFeHRyYWN0cyBZQU1MIGZyb250bWF0dGVyIGZyb20gZG9jdW1lbnQgY29udGVudFxuXHQgKi9cblx0cHJpdmF0ZSBleHRyYWN0RnJvbnRNYXR0ZXIoY29udGVudDogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGZyb250TWF0dGVyTWF0Y2ggPSBjb250ZW50Lm1hdGNoKC9eLS0tXFxuKFtcXHNcXFNdKj8pXFxuLS0tLyk7XG5cdFx0XHRpZiAoIWZyb250TWF0dGVyTWF0Y2gpIHJldHVybiB1bmRlZmluZWQ7XG5cblx0XHRcdGNvbnN0IHlhbWwgPSBmcm9udE1hdHRlck1hdGNoWzFdO1xuXHRcdFx0cmV0dXJuIHBhcnNlWWFtbCh5YW1sKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBmcm9udG1hdHRlcjonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYCR7RG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IuWUFNTF9QQVJTRV9FUlJPUn06ICR7ZXJyb3IubWVzc2FnZX1gKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRXh0cmFjdHMgaW50ZXJuYWwgbGlua3MgZnJvbSBkb2N1bWVudCBjb250ZW50XG5cdCAqIEhhbmRsZXMgYm90aCBzdGFuZGFyZCBsaW5rcyBbW1BhZ2VdXSBhbmQgYWxpYXNlZCBsaW5rcyBbW1BhZ2V8QWxpYXNdXVxuXHQgKi9cblx0cHJpdmF0ZSBleHRyYWN0TGlua3MoY29udGVudDogc3RyaW5nKTogc3RyaW5nW10ge1xuXHRcdGNvbnN0IGxpbmtSZWdleCA9IC9cXFtcXFsoLio/KSg/OlxcfC4qPyk/XFxdXFxdL2c7XG5cdFx0Y29uc3QgbGlua3MgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuXHRcdGxldCBtYXRjaDtcblx0XHR3aGlsZSAoKG1hdGNoID0gbGlua1JlZ2V4LmV4ZWMoY29udGVudCkpICE9PSBudWxsKSB7XG5cdFx0XHQvLyBFeHRyYWN0IHRoZSBsaW5rIHRhcmdldCwgcmVtb3ZpbmcgYW55IGFsaWFzIGFmdGVyIHxcblx0XHRcdGNvbnN0IGxpbmsgPSBtYXRjaFsxXS5zcGxpdCgnfCcpWzBdO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3VicGF0aHMgYW5kIGNsZWFuIHRoZSBsaW5rXG5cdFx0XHRjb25zdCBjbGVhbkxpbmsgPSB0aGlzLmNsZWFuTGluayhsaW5rKTtcblx0XHRcdGlmIChjbGVhbkxpbmspIHtcblx0XHRcdFx0bGlua3MuYWRkKGNsZWFuTGluayk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIEFycmF5LmZyb20obGlua3MpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFucyBhbmQgbm9ybWFsaXplcyBhIGxpbmsgcGF0aFxuXHQgKi9cblx0cHJpdmF0ZSBjbGVhbkxpbmsobGluazogc3RyaW5nKTogc3RyaW5nIHtcblx0XHQvLyBSZW1vdmUgaGVhZGluZy9ibG9jayByZWZlcmVuY2VzXG5cdFx0bGV0IGNsZWFuTGluayA9IGxpbmsuc3BsaXQoJyMnKVswXTtcblx0XHQvLyBSZW1vdmUgcXVlcnkgcGFyYW1ldGVyc1xuXHRcdGNsZWFuTGluayA9IGNsZWFuTGluay5zcGxpdCgnPycpWzBdO1xuXHRcdC8vIFRyaW0gd2hpdGVzcGFjZVxuXHRcdGNsZWFuTGluayA9IGNsZWFuTGluay50cmltKCk7XG5cblx0XHRyZXR1cm4gY2xlYW5MaW5rO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4dHJhY3RzIHRhZ3MgZnJvbSBib3RoIGNvbnRlbnQgYW5kIGZyb250bWF0dGVyXG5cdCAqL1xuXHRwcml2YXRlIGV4dHJhY3RUYWdzKGNvbnRlbnQ6IHN0cmluZywgZnJvbnRNYXR0ZXI/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogc3RyaW5nW10ge1xuXHRcdGNvbnN0IHRhZ3MgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuXHRcdC8vIEV4dHJhY3QgaW5saW5lIHRhZ3Ncblx0XHRjb25zdCB0YWdSZWdleCA9IC8jKFtBLVphLXowLTkvXy1dKykvZztcblx0XHRsZXQgbWF0Y2g7XG5cdFx0d2hpbGUgKChtYXRjaCA9IHRhZ1JlZ2V4LmV4ZWMoY29udGVudCkpICE9PSBudWxsKSB7XG5cdFx0XHR0YWdzLmFkZChtYXRjaFsxXSk7XG5cdFx0fVxuXG5cdFx0Ly8gRXh0cmFjdCBmcm9udG1hdHRlciB0YWdzXG5cdFx0aWYgKGZyb250TWF0dGVyPy50YWdzKSB7XG5cdFx0XHRjb25zdCBmcm9udE1hdHRlclRhZ3MgPSBBcnJheS5pc0FycmF5KGZyb250TWF0dGVyLnRhZ3MpXG5cdFx0XHRcdD8gZnJvbnRNYXR0ZXIudGFnc1xuXHRcdFx0XHQ6IFtmcm9udE1hdHRlci50YWdzXTtcblxuXHRcdFx0ZnJvbnRNYXR0ZXJUYWdzLmZvckVhY2godGFnID0+IHtcblx0XHRcdFx0aWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0Ly8gUmVtb3ZlIGxlYWRpbmcgIyBpZiBwcmVzZW50XG5cdFx0XHRcdFx0Y29uc3QgY2xlYW5UYWcgPSB0YWcuc3RhcnRzV2l0aCgnIycpID8gdGFnLnNsaWNlKDEpIDogdGFnO1xuXHRcdFx0XHRcdHRhZ3MuYWRkKGNsZWFuVGFnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIEFycmF5LmZyb20odGFncyk7XG5cdH1cblxuXHQvKipcblx0ICogRXh0cmFjdHMgYWxpYXNlcyBmcm9tIGZyb250bWF0dGVyXG5cdCAqL1xuXHRwcml2YXRlIGV4dHJhY3RBbGlhc2VzKGZyb250TWF0dGVyPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHN0cmluZ1tdIHtcblx0XHRpZiAoIWZyb250TWF0dGVyPy5hbGlhc2VzKSByZXR1cm4gW107XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheShmcm9udE1hdHRlci5hbGlhc2VzKSkge1xuXHRcdFx0cmV0dXJuIGZyb250TWF0dGVyLmFsaWFzZXMuZmlsdGVyKGFsaWFzID0+IHR5cGVvZiBhbGlhcyA9PT0gJ3N0cmluZycpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgZnJvbnRNYXR0ZXIuYWxpYXNlcyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBbZnJvbnRNYXR0ZXIuYWxpYXNlc107XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4dHJhY3RzIHNvdXJjZSBsb2NhdGlvbiBpbmZvcm1hdGlvbiBmcm9tIGZyb250bWF0dGVyXG5cdCAqL1xuXHRwcml2YXRlIGV4dHJhY3RTb3VyY2VMb2NhdGlvbihmcm9udE1hdHRlcj86IFJlY29yZDxzdHJpbmcsIGFueT4pOiB7IGxpbmVzOiB7IGZyb206IG51bWJlcjsgdG86IG51bWJlciB9IH0gfCB1bmRlZmluZWQge1xuXHRcdGlmICghZnJvbnRNYXR0ZXI/LmxvYz8ubGluZXM/LmZyb20gfHwgIWZyb250TWF0dGVyPy5sb2M/LmxpbmVzPy50bykge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bGluZXM6IHtcblx0XHRcdFx0ZnJvbTogTnVtYmVyKGZyb250TWF0dGVyLmxvYy5saW5lcy5mcm9tKSxcblx0XHRcdFx0dG86IE51bWJlcihmcm9udE1hdHRlci5sb2MubGluZXMudG8pXG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufVxuIiwgIi8vIHNyYy91dGlscy9UZXh0U3BsaXR0ZXIudHNcblxuaW1wb3J0IHtcblx0RG9jdW1lbnRDaHVuayxcblx0RG9jdW1lbnRNZXRhZGF0YSxcblx0RG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IsXG59IGZyb20gJy4uL21vZGVscy9Eb2N1bWVudENodW5rJztcbmltcG9ydCB7IERFRkFVTFRfQ0hVTktJTkdfT1BUSU9OUyB9IGZyb20gJy4uL3NldHRpbmdzL1NldHRpbmdzJztcbmltcG9ydCB7IE1ldGFkYXRhRXh0cmFjdG9yIH0gZnJvbSAnLi4vc2VydmljZXMvTWV0YWRhdGFFeHRyYWN0b3InO1xuXG5leHBvcnQgY2xhc3MgVGV4dFNwbGl0dGVyIHtcblx0cHJpdmF0ZSBzZXR0aW5nczoge1xuXHRcdGNodW5rU2l6ZTogbnVtYmVyO1xuXHRcdGNodW5rT3ZlcmxhcDogbnVtYmVyO1xuXHRcdG1pbkNodW5rU2l6ZTogbnVtYmVyO1xuXHR9O1xuXHRwcml2YXRlIG1ldGFkYXRhRXh0cmFjdG9yOiBNZXRhZGF0YUV4dHJhY3RvcjtcblxuXHQvLyBSZWdleCBwYXR0ZXJucyBmb3Igc3BsaXR0aW5nXG5cdHByaXZhdGUgcmVhZG9ubHkgU0VOVEVOQ0VfQk9VTkRBUlkgPSAvWy4hP11cXHMrLztcblx0cHJpdmF0ZSByZWFkb25seSBQQVJBR1JBUEhfQk9VTkRBUlkgPSAvXFxuXFxzKlxcbi87XG5cdHByaXZhdGUgcmVhZG9ubHkgWUFNTF9GUk9OVF9NQVRURVIgPSAvXi0tLVxcbihbXFxzXFxTXSo/KVxcbi0tLS87XG5cblx0Y29uc3RydWN0b3IoXG5cdFx0c2V0dGluZ3M/OiB7IGNodW5rU2l6ZTogbnVtYmVyOyBjaHVua092ZXJsYXA6IG51bWJlcjsgbWluQ2h1bmtTaXplOiBudW1iZXIgfSxcblx0XHRtZXRhZGF0YUV4dHJhY3Rvcj86IE1ldGFkYXRhRXh0cmFjdG9yXG5cdCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7IC4uLkRFRkFVTFRfQ0hVTktJTkdfT1BUSU9OUyB9O1xuXHRcdHRoaXMudmFsaWRhdGVTZXR0aW5ncyh0aGlzLnNldHRpbmdzKTtcblx0XHR0aGlzLm1ldGFkYXRhRXh0cmFjdG9yID0gbWV0YWRhdGFFeHRyYWN0b3IgfHwgbmV3IE1ldGFkYXRhRXh0cmFjdG9yKCk7XG5cdH1cblxuXHRwcml2YXRlIHZhbGlkYXRlU2V0dGluZ3Moc2V0dGluZ3M6IHsgY2h1bmtTaXplOiBudW1iZXI7IGNodW5rT3ZlcmxhcDogbnVtYmVyOyBtaW5DaHVua1NpemU6IG51bWJlciB9KSB7XG5cdFx0aWYgKHNldHRpbmdzLmNodW5rU2l6ZSA8PSAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NodW5rIHNpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcblx0XHR9XG5cdFx0aWYgKHNldHRpbmdzLmNodW5rT3ZlcmxhcCA+PSBzZXR0aW5ncy5jaHVua1NpemUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ2h1bmsgb3ZlcmxhcCBtdXN0IGJlIGxlc3MgdGhhbiBjaHVuayBzaXplLicpO1xuXHRcdH1cblx0XHRpZiAoc2V0dGluZ3MubWluQ2h1bmtTaXplID4gc2V0dGluZ3MuY2h1bmtTaXplKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01pbmltdW0gY2h1bmsgc2l6ZSBtdXN0IG5vdCBleGNlZWQgY2h1bmsgc2l6ZS4nKTtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgc3BsaXREb2N1bWVudChjb250ZW50OiBzdHJpbmcsIG1ldGFkYXRhOiBEb2N1bWVudE1ldGFkYXRhKTogUHJvbWlzZTxEb2N1bWVudENodW5rW10+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc29sZS5sb2coJ1N0YXJ0aW5nIGRvY3VtZW50IHNwbGl0OicsIHtcblx0XHRcdFx0Y29udGVudExlbmd0aDogY29udGVudC5sZW5ndGgsXG5cdFx0XHRcdHNldHRpbmdzOiB0aGlzLnNldHRpbmdzXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKCFjb250ZW50Py50cmltKCkpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0VtcHR5IGNvbnRlbnQgcmVjZWl2ZWQnKTtcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBFeHRyYWN0IGFuZCByZW1vdmUgWUFNTCBmcm9udCBtYXR0ZXJcblx0XHRcdGxldCBmcm9udE1hdHRlciA9IG51bGw7XG5cdFx0XHRjb25zdCBmcm9udE1hdHRlck1hdGNoID0gdGhpcy5ZQU1MX0ZST05UX01BVFRFUi5leGVjKGNvbnRlbnQpO1xuXHRcdFx0aWYgKGZyb250TWF0dGVyTWF0Y2gpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmcm9udE1hdHRlciA9IHRoaXMucGFyc2VGcm9udE1hdHRlcihmcm9udE1hdHRlck1hdGNoWzFdKTtcblx0XHRcdFx0XHQvLyBFbmhhbmNlIG1ldGFkYXRhIHVzaW5nIE1ldGFkYXRhRXh0cmFjdG9yIGZvciB0aGUgY29tcGxldGUgY29udGVudFxuXHRcdFx0XHRcdGNvbnN0IGVuaGFuY2VkTWV0YWRhdGEgPSBhd2FpdCB0aGlzLmVuaGFuY2VNZXRhZGF0YShjb250ZW50LCBtZXRhZGF0YSwgZnJvbnRNYXR0ZXIpO1xuXHRcdFx0XHRcdG1ldGFkYXRhID0gZW5oYW5jZWRNZXRhZGF0YTtcblx0XHRcdFx0XHRjb250ZW50ID0gY29udGVudC5yZXBsYWNlKHRoaXMuWUFNTF9GUk9OVF9NQVRURVIsICcnKS50cmltKCk7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ0Zyb250IG1hdHRlciBleHRyYWN0ZWQgYW5kIG1ldGFkYXRhIGVuaGFuY2VkOicsIHsgZnJvbnRNYXR0ZXIgfSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgZnJvbnQgbWF0dGVyOicsIGVycm9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBjb250ZW50IGlzIHNtYWxsZXIgdGhhbiBjaHVua1NpemUgb3IgbWluQ2h1bmtTaXplLCByZXR1cm4gaXQgYXMgYSBzaW5nbGUgY2h1bmtcblx0XHRcdGNvbnN0IHRyaW1tZWRDb250ZW50ID0gY29udGVudC50cmltKCk7XG5cdFx0XHRpZiAodHJpbW1lZENvbnRlbnQubGVuZ3RoIDw9IE1hdGgubWF4KHRoaXMuc2V0dGluZ3MubWluQ2h1bmtTaXplLCB0aGlzLnNldHRpbmdzLmNodW5rU2l6ZSkpIHtcblx0XHRcdFx0aWYgKHRyaW1tZWRDb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdObyBjb250ZW50IGFmdGVyIHRyaW1taW5nLCByZXR1cm5pbmcgZW1wdHkgYXJyYXknKTtcblx0XHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zb2xlLmxvZygnQ29udGVudCBpcyBzbWFsbGVyIHRoYW4gY2h1bmsgc2l6ZSwgY3JlYXRpbmcgc2luZ2xlIGNodW5rOicsIHtcblx0XHRcdFx0XHRjb250ZW50TGVuZ3RoOiB0cmltbWVkQ29udGVudC5sZW5ndGgsXG5cdFx0XHRcdFx0Y2h1bmtTaXplOiB0aGlzLnNldHRpbmdzLmNodW5rU2l6ZSxcblx0XHRcdFx0XHRtaW5DaHVua1NpemU6IHRoaXMuc2V0dGluZ3MubWluQ2h1bmtTaXplXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGNvbnN0IHNpbmdsZUNodW5rID0gdGhpcy5jcmVhdGVDaHVuayh0cmltbWVkQ29udGVudCwgMCwgbWV0YWRhdGEpO1xuXHRcdFx0XHRjb25zb2xlLmxvZygnQ3JlYXRlZCBzaW5nbGUgY2h1bms6Jywge1xuXHRcdFx0XHRcdGNodW5rU2l6ZTogc2luZ2xlQ2h1bmsuY29udGVudC5sZW5ndGgsXG5cdFx0XHRcdFx0cHJldmlldzogc2luZ2xlQ2h1bmsuY29udGVudC5zdWJzdHJpbmcoMCwgMTAwKVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gW3NpbmdsZUNodW5rXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3BsaXQgaW50byBwYXJhZ3JhcGhzIGZpcnN0XG5cdFx0XHRjb25zdCBwYXJhZ3JhcGhzID0gY29udGVudC5zcGxpdCh0aGlzLlBBUkFHUkFQSF9CT1VOREFSWSlcblx0XHRcdFx0Lm1hcChwID0+IHAudHJpbSgpKVxuXHRcdFx0XHQuZmlsdGVyKHAgPT4gcC5sZW5ndGggPiAwKTtcblxuXHRcdFx0Y29uc29sZS5sb2coJ1NwbGl0IGludG8gcGFyYWdyYXBoczonLCB7XG5cdFx0XHRcdHBhcmFncmFwaENvdW50OiBwYXJhZ3JhcGhzLmxlbmd0aCxcblx0XHRcdFx0cGFyYWdyYXBoczogcGFyYWdyYXBocy5tYXAocCA9PiBwLnN1YnN0cmluZygwLCAxMDApKSAvLyBMb2cgcHJldmlldyBvZiBlYWNoIHBhcmFncmFwaFxuXHRcdFx0fSk7XG5cblx0XHRcdGNvbnN0IGNodW5rczogRG9jdW1lbnRDaHVua1tdID0gW107XG5cdFx0XHRsZXQgY3VycmVudENodW5rID0gJyc7XG5cdFx0XHRsZXQgY2h1bmtJbmRleCA9IDA7XG5cblx0XHRcdGZvciAoY29uc3QgcGFyYWdyYXBoIG9mIHBhcmFncmFwaHMpIHtcblx0XHRcdFx0Ly8gSWYgcGFyYWdyYXBoIGlzIGxhcmdlciB0aGFuIGNodW5rIHNpemUsIHNwbGl0IGl0XG5cdFx0XHRcdGlmIChwYXJhZ3JhcGgubGVuZ3RoID49IHRoaXMuc2V0dGluZ3MuY2h1bmtTaXplKSB7XG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhY2N1bXVsYXRlZCBjb250ZW50LCBjcmVhdGUgYSBjaHVua1xuXHRcdFx0XHRcdGlmIChjdXJyZW50Q2h1bmspIHtcblx0XHRcdFx0XHRcdGNodW5rcy5wdXNoKHRoaXMuY3JlYXRlQ2h1bmsoY3VycmVudENodW5rLCBjaHVua0luZGV4KyssIG1ldGFkYXRhKSk7XG5cdFx0XHRcdFx0XHRjdXJyZW50Q2h1bmsgPSAnJztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTcGxpdCBsYXJnZSBwYXJhZ3JhcGggaW50byBzZW50ZW5jZXNcblx0XHRcdFx0XHRjb25zdCBzZW50ZW5jZXMgPSBwYXJhZ3JhcGguc3BsaXQodGhpcy5TRU5URU5DRV9CT1VOREFSWSk7XG5cdFx0XHRcdFx0bGV0IHNlbnRlbmNlQ2h1bmsgPSAnJztcblxuXHRcdFx0XHRcdGZvciAoY29uc3Qgc2VudGVuY2Ugb2Ygc2VudGVuY2VzKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB0cmltbWVkU2VudGVuY2UgPSBzZW50ZW5jZS50cmltKCk7XG5cdFx0XHRcdFx0XHRpZiAoIXRyaW1tZWRTZW50ZW5jZSkgY29udGludWU7XG5cblx0XHRcdFx0XHRcdC8vIElmIGFkZGluZyB0aGlzIHNlbnRlbmNlIHdvdWxkIGV4Y2VlZCBjaHVuayBzaXplXG5cdFx0XHRcdFx0XHRpZiAoKHNlbnRlbmNlQ2h1bmsgKyAnICcgKyB0cmltbWVkU2VudGVuY2UpLmxlbmd0aCA+IHRoaXMuc2V0dGluZ3MuY2h1bmtTaXplKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChzZW50ZW5jZUNodW5rKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2h1bmtzLnB1c2godGhpcy5jcmVhdGVDaHVuayhzZW50ZW5jZUNodW5rLCBjaHVua0luZGV4KyssIG1ldGFkYXRhKSk7XG5cdFx0XHRcdFx0XHRcdFx0c2VudGVuY2VDaHVuayA9IHRyaW1tZWRTZW50ZW5jZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBTaW5nbGUgc2VudGVuY2UgaXMgdG9vIGxvbmcsIGZvcmNlIHNwbGl0IGl0XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHBvc2l0aW9uID0gMDtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAocG9zaXRpb24gPCB0cmltbWVkU2VudGVuY2UubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBjaHVuayA9IHRyaW1tZWRTZW50ZW5jZS5zbGljZShwb3NpdGlvbixcblx0XHRcdFx0XHRcdFx0XHRcdFx0TWF0aC5taW4ocG9zaXRpb24gKyB0aGlzLnNldHRpbmdzLmNodW5rU2l6ZSwgdHJpbW1lZFNlbnRlbmNlLmxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2h1bmtzLnB1c2godGhpcy5jcmVhdGVDaHVuayhjaHVuaywgY2h1bmtJbmRleCsrLCBtZXRhZGF0YSkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gdGhpcy5zZXR0aW5ncy5jaHVua1NpemU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHNlbnRlbmNlQ2h1bmsgPSAnJztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c2VudGVuY2VDaHVuayArPSAoc2VudGVuY2VDaHVuayA/ICcgJyA6ICcnKSArIHRyaW1tZWRTZW50ZW5jZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBBZGQgYW55IHJlbWFpbmluZyBzZW50ZW5jZSBjaHVua1xuXHRcdFx0XHRcdGlmIChzZW50ZW5jZUNodW5rKSB7XG5cdFx0XHRcdFx0XHRjaHVua3MucHVzaCh0aGlzLmNyZWF0ZUNodW5rKHNlbnRlbmNlQ2h1bmssIGNodW5rSW5kZXgrKywgbWV0YWRhdGEpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSGFuZGxlIG5vcm1hbC1zaXplZCBwYXJhZ3JhcGhzXG5cdFx0XHRcdFx0Y29uc3QgcG90ZW50aWFsQ2h1bmtTaXplID0gY3VycmVudENodW5rXG5cdFx0XHRcdFx0XHQ/IGN1cnJlbnRDaHVuay5sZW5ndGggKyAyICsgcGFyYWdyYXBoLmxlbmd0aCAgLy8gKzIgZm9yICdcXG5cXG4nXG5cdFx0XHRcdFx0XHQ6IHBhcmFncmFwaC5sZW5ndGg7XG5cblx0XHRcdFx0XHRpZiAocG90ZW50aWFsQ2h1bmtTaXplIDw9IHRoaXMuc2V0dGluZ3MuY2h1bmtTaXplKSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50Q2h1bmsgKz0gKGN1cnJlbnRDaHVuayA/ICdcXG5cXG4nIDogJycpICsgcGFyYWdyYXBoO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudENodW5rKSB7XG5cdFx0XHRcdFx0XHRcdGNodW5rcy5wdXNoKHRoaXMuY3JlYXRlQ2h1bmsoY3VycmVudENodW5rLCBjaHVua0luZGV4KyssIG1ldGFkYXRhKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjdXJyZW50Q2h1bmsgPSBwYXJhZ3JhcGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0aGUgbGFzdCBjaHVuayBpZiB0aGVyZSdzIHJlbWFpbmluZyBjb250ZW50XG5cdFx0XHRpZiAoY3VycmVudENodW5rKSB7XG5cdFx0XHRcdGNodW5rcy5wdXNoKHRoaXMuY3JlYXRlQ2h1bmsoY3VycmVudENodW5rLCBjaHVua0luZGV4KyssIG1ldGFkYXRhKSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEVuc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBjaHVuayBpZiB3ZSBoYXZlIGNvbnRlbnRcblx0XHRcdGlmIChjaHVua3MubGVuZ3RoID09PSAwICYmIHRyaW1tZWRDb250ZW50Lmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0NyZWF0aW5nIGZhbGxiYWNrIGNodW5rIGZvciBjb250ZW50OicsIHtcblx0XHRcdFx0XHRjb250ZW50TGVuZ3RoOiB0cmltbWVkQ29udGVudC5sZW5ndGhcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGNodW5rcy5wdXNoKHRoaXMuY3JlYXRlQ2h1bmsodHJpbW1lZENvbnRlbnQsIDAsIG1ldGFkYXRhKSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IG92ZXJsYXAgaWYgbmVlZGVkXG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5jaHVua092ZXJsYXAgPiAwICYmIGNodW5rcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdHRoaXMuYXBwbHlPdmVybGFwKGNodW5rcyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnNvbGUubG9nKCdGaW5pc2hlZCBjcmVhdGluZyBjaHVua3M6Jywge1xuXHRcdFx0XHRjaHVua0NvdW50OiBjaHVua3MubGVuZ3RoLFxuXHRcdFx0XHRjaHVua1NpemVzOiBjaHVua3MubWFwKGMgPT4gYy5jb250ZW50Lmxlbmd0aCksXG5cdFx0XHRcdGNodW5rUHJldmlld3M6IGNodW5rcy5tYXAoYyA9PiAoe1xuXHRcdFx0XHRcdGluZGV4OiBjLmNodW5rSW5kZXgsXG5cdFx0XHRcdFx0c2l6ZTogYy5jb250ZW50Lmxlbmd0aCxcblx0XHRcdFx0XHRwcmV2aWV3OiBjLmNvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMClcblx0XHRcdFx0fSkpXG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGNodW5rcztcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgaW4gc3BsaXREb2N1bWVudDonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyB7XG5cdFx0XHRcdHR5cGU6IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLkNIVU5LSU5HX0VSUk9SLFxuXHRcdFx0XHRtZXNzYWdlOiAnRXJyb3Igb2NjdXJyZWQgZHVyaW5nIGRvY3VtZW50IGNodW5raW5nJyxcblx0XHRcdFx0ZGV0YWlsczogZXJyb3IubWVzc2FnZSxcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBjcmVhdGVDaHVuayhjb250ZW50OiBzdHJpbmcsIGluZGV4OiBudW1iZXIsIG1ldGFkYXRhOiBEb2N1bWVudE1ldGFkYXRhKTogRG9jdW1lbnRDaHVuayB7XG5cdFx0Y29uc3QgdHJpbW1lZENvbnRlbnQgPSBjb250ZW50LnRyaW0oKTtcblx0XHRpZiAodHJpbW1lZENvbnRlbnQubGVuZ3RoIDwgdGhpcy5zZXR0aW5ncy5taW5DaHVua1NpemUpIHtcblx0XHRcdGNvbnNvbGUud2FybignQ2h1bmsgc21hbGxlciB0aGFuIG1pbkNodW5rU2l6ZTonLCB7XG5cdFx0XHRcdHNpemU6IHRyaW1tZWRDb250ZW50Lmxlbmd0aCxcblx0XHRcdFx0bWluU2l6ZTogdGhpcy5zZXR0aW5ncy5taW5DaHVua1NpemVcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRjb250ZW50OiB0cmltbWVkQ29udGVudCxcblx0XHRcdGNodW5rSW5kZXg6IGluZGV4LFxuXHRcdFx0bWV0YWRhdGE6IHsgLi4ubWV0YWRhdGEgfVxuXHRcdH07XG5cdH1cblxuXHRwcml2YXRlIGFwcGx5T3ZlcmxhcChjaHVua3M6IERvY3VtZW50Q2h1bmtbXSk6IHZvaWQge1xuXHRcdGlmIChjaHVua3MubGVuZ3RoIDw9IDEpIHJldHVybjtcblxuXHRcdGZvciAobGV0IGkgPSBjaHVua3MubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuXHRcdFx0Y29uc3QgY3VycmVudENodW5rID0gY2h1bmtzW2ldO1xuXHRcdFx0Y29uc3QgcHJldmlvdXNDaHVuayA9IGNodW5rc1tpIC0gMV07XG5cblx0XHRcdC8vIEdldCBvdmVybGFwIHRleHQgZnJvbSBlbmQgb2YgcHJldmlvdXMgY2h1bmtcblx0XHRcdGNvbnN0IG92ZXJsYXBUZXh0ID0gcHJldmlvdXNDaHVuay5jb250ZW50LnNsaWNlKC10aGlzLnNldHRpbmdzLmNodW5rT3ZlcmxhcCk7XG5cdFx0XHRpZiAob3ZlcmxhcFRleHQpIHtcblx0XHRcdFx0Y3VycmVudENodW5rLmNvbnRlbnQgPSBvdmVybGFwVGV4dCArICdcXG5cXG4nICsgY3VycmVudENodW5rLmNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBlbmhhbmNlTWV0YWRhdGEoXG5cdFx0Y29udGVudDogc3RyaW5nLFxuXHRcdGJhc2VNZXRhZGF0YTogRG9jdW1lbnRNZXRhZGF0YSxcblx0XHRmcm9udE1hdHRlcjogUmVjb3JkPHN0cmluZywgYW55PiB8IG51bGxcblx0KTogUHJvbWlzZTxEb2N1bWVudE1ldGFkYXRhPiB7XG5cdFx0Ly8gU3RhcnQgd2l0aCB0aGUgYmFzZSBtZXRhZGF0YVxuXHRcdGNvbnN0IGVuaGFuY2VkTWV0YWRhdGEgPSB7IC4uLmJhc2VNZXRhZGF0YSB9O1xuXG5cdFx0Ly8gRXh0cmFjdCB0YWdzLCBsaW5rcywgYW5kIGFsaWFzZXMgZnJvbSB0aGUgY29udGVudFxuXHRcdGNvbnN0IHRhZ3MgPSBuZXcgU2V0KGVuaGFuY2VkTWV0YWRhdGEudGFncyB8fCBbXSk7XG5cdFx0Y29uc3QgbGlua3MgPSBuZXcgU2V0KGVuaGFuY2VkTWV0YWRhdGEubGlua3MgfHwgW10pO1xuXHRcdGxldCBhbGlhc2VzID0gZW5oYW5jZWRNZXRhZGF0YS5jdXN0b21NZXRhZGF0YT8uYWxpYXNlcyB8fCBbXTtcblxuXHRcdC8vIEV4dHJhY3QgYWxsIG1ldGFkYXRhIGNvbXBvbmVudHMgdXNpbmcgTWV0YWRhdGFFeHRyYWN0b3Jcblx0XHRjb25zdCBjb250ZW50TWV0YWRhdGEgPSBhd2FpdCB0aGlzLm1ldGFkYXRhRXh0cmFjdG9yLmV4dHJhY3RNZXRhZGF0YSh7XG5cdFx0XHRwYXRoOiBiYXNlTWV0YWRhdGEub2JzaWRpYW5JZCxcblx0XHRcdHN0YXQ6IHtcblx0XHRcdFx0bXRpbWU6IGJhc2VNZXRhZGF0YS5sYXN0TW9kaWZpZWQsXG5cdFx0XHRcdGN0aW1lOiBiYXNlTWV0YWRhdGEuY3JlYXRlZCxcblx0XHRcdFx0c2l6ZTogYmFzZU1ldGFkYXRhLnNpemVcblx0XHRcdH0sXG5cdFx0XHR2YXVsdDogYmFzZU1ldGFkYXRhLnZhdWx0XG5cdFx0fSBhcyBhbnksIGNvbnRlbnQpO1xuXG5cdFx0Ly8gTWVyZ2UgdGhlIGV4dHJhY3RlZCBtZXRhZGF0YVxuXHRcdGNvbnRlbnRNZXRhZGF0YS50YWdzPy5mb3JFYWNoKHRhZyA9PiB0YWdzLmFkZCh0YWcpKTtcblx0XHRjb250ZW50TWV0YWRhdGEubGlua3M/LmZvckVhY2gobGluayA9PiBsaW5rcy5hZGQobGluaykpO1xuXHRcdGlmIChjb250ZW50TWV0YWRhdGEuY3VzdG9tTWV0YWRhdGE/LmFsaWFzZXMpIHtcblx0XHRcdGFsaWFzZXMgPSBbLi4ubmV3IFNldChbLi4uYWxpYXNlcywgLi4uY29udGVudE1ldGFkYXRhLmN1c3RvbU1ldGFkYXRhLmFsaWFzZXNdKV07XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlIHRoZSBtZXRhZGF0YVxuXHRcdGVuaGFuY2VkTWV0YWRhdGEudGFncyA9IEFycmF5LmZyb20odGFncyk7XG5cdFx0ZW5oYW5jZWRNZXRhZGF0YS5jdXN0b21NZXRhZGF0YSA9IHtcblx0XHRcdC4uLmVuaGFuY2VkTWV0YWRhdGEuY3VzdG9tTWV0YWRhdGEsXG5cdFx0XHRhbGlhc2VzXG5cdFx0fTtcblx0XHRlbmhhbmNlZE1ldGFkYXRhLmZyb250TWF0dGVyID0gZnJvbnRNYXR0ZXIgfHwgZW5oYW5jZWRNZXRhZGF0YS5mcm9udE1hdHRlcjtcblxuXHRcdHJldHVybiBlbmhhbmNlZE1ldGFkYXRhO1xuXHR9XG5cblx0cHJpdmF0ZSBwYXJzZUZyb250TWF0dGVyKGZyb250TWF0dGVyOiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gU2ltcGxlIFlBTUwtbGlrZSBwYXJzaW5nXG5cdFx0XHRjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcblx0XHRcdGNvbnN0IGxpbmVzID0gZnJvbnRNYXR0ZXIuc3BsaXQoJ1xcbicpO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcblx0XHRcdFx0Y29uc3QgdHJpbW1lZExpbmUgPSBsaW5lLnRyaW0oKTtcblx0XHRcdFx0aWYgKCF0cmltbWVkTGluZSB8fCB0cmltbWVkTGluZS5zdGFydHNXaXRoKCcjJykpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGNvbnN0IHNlcGFyYXRvckluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG5cdFx0XHRcdGlmIChzZXBhcmF0b3JJbmRleCA9PT0gLTEpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGNvbnN0IGtleSA9IGxpbmUuc2xpY2UoMCwgc2VwYXJhdG9ySW5kZXgpLnRyaW0oKTtcblx0XHRcdFx0bGV0IHZhbHVlID0gbGluZS5zbGljZShzZXBhcmF0b3JJbmRleCArIDEpLnRyaW0oKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgcXVvdGVzIGlmIHByZXNlbnRcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eW1wiJ10oLiopW1wiJ10kLywgJyQxJyk7XG5cblx0XHRcdFx0Ly8gUGFyc2UgbGlzdHNcblx0XHRcdFx0aWYgKHZhbHVlLnN0YXJ0c1dpdGgoJy0gJykpIHtcblx0XHRcdFx0XHRyZXN1bHRba2V5XSA9IHZhbHVlXG5cdFx0XHRcdFx0XHQuc3BsaXQoJ1xcbicpXG5cdFx0XHRcdFx0XHQubWFwKGl0ZW0gPT4gaXRlbS5yZXBsYWNlKCctICcsICcnKS50cmltKCkpXG5cdFx0XHRcdFx0XHQuZmlsdGVyKEJvb2xlYW4pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc3VsdFtrZXldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgZnJvbnQgbWF0dGVyOicsIGVycm9yKTtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgZ2V0U2V0dGluZ3MoKSB7XG5cdFx0cmV0dXJuIHsgLi4udGhpcy5zZXR0aW5ncyB9O1xuXHR9XG59XG4iLCAiLy8gc3JjL3V0aWxzL0ZpbGVUcmFja2VyLnRzXG5cbmltcG9ydCB7IFRBYnN0cmFjdEZpbGUsIFRGaWxlLCBWYXVsdCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEVycm9ySGFuZGxlciB9IGZyb20gJy4vRXJyb3JIYW5kbGVyJztcbmltcG9ydCB7IERvY3VtZW50TWV0YWRhdGEgfSBmcm9tICcuLi9tb2RlbHMvRG9jdW1lbnRDaHVuayc7XG5pbXBvcnQgeyBTeW5jRmlsZU1hbmFnZXIgfSBmcm9tICcuLi9zZXJ2aWNlcy9TeW5jRmlsZU1hbmFnZXInO1xuXG5pbnRlcmZhY2UgRmlsZUV2ZW50IHtcblx0dHlwZTogJ2NyZWF0ZScgfCAnbW9kaWZ5JyB8ICdkZWxldGUnIHwgJ3JlbmFtZSc7XG5cdGZpbGU6IFRGaWxlO1xuXHRvbGRQYXRoPzogc3RyaW5nO1xuXHR0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEZpbGVDYWNoZSB7XG5cdHBhdGg6IHN0cmluZztcblx0aGFzaDogc3RyaW5nO1xuXHRsYXN0TW9kaWZpZWQ6IG51bWJlcjtcblx0bGFzdFN5bmNlZD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEZpbGVUcmFja2VyIHtcblx0cHJpdmF0ZSBmaWxlQ2FjaGU6IE1hcDxzdHJpbmcsIEZpbGVDYWNoZT4gPSBuZXcgTWFwKCk7XG5cdHByaXZhdGUgZXZlbnRRdWV1ZTogRmlsZUV2ZW50W10gPSBbXTtcblx0cHJpdmF0ZSBpc1Byb2Nlc3Npbmc6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHJpdmF0ZSBwcm9jZXNzaW5nVGltZW91dDogbnVtYmVyID0gMTAwMDsgLy8gRGVib3VuY2UgdGltZSBpbiBtc1xuXHRwcml2YXRlIHN5bmNNYW5hZ2VyOiBTeW5jRmlsZU1hbmFnZXI7XG5cblx0Y29uc3RydWN0b3IoXG5cdFx0cHJpdmF0ZSB2YXVsdDogVmF1bHQsXG5cdFx0cHJpdmF0ZSBlcnJvckhhbmRsZXI6IEVycm9ySGFuZGxlcixcblx0XHRzeW5jRmlsZVBhdGg6IHN0cmluZyA9ICdfbWluZG1hdHJpeHN5bmMubWQnXG5cdCkge1xuXHRcdHRoaXMuc3luY01hbmFnZXIgPSBuZXcgU3luY0ZpbGVNYW5hZ2VyKHZhdWx0LCBlcnJvckhhbmRsZXIsIHN5bmNGaWxlUGF0aCk7XG5cdH1cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgZmlsZSB0cmFja2VyIGFuZCBzeW5jIG1hbmFnZXJcblx0ICovXG5cdGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIEluaXRpYWxpemUgc3luYyBtYW5hZ2VyIGZpcnN0XG5cdFx0XHRhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLmluaXRpYWxpemUoKTtcblxuXHRcdFx0Ly8gR2V0IGV4aXN0aW5nIHN5bmMgZW50cmllc1xuXHRcdFx0Y29uc3Qgc3luY0VudHJpZXMgPSBhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLmdldEFsbFN5bmNFbnRyaWVzKCk7XG5cblx0XHRcdC8vIEluaXRpYWxpemUgY2FjaGUgZnJvbSBzeW5jIGVudHJpZXMsIGV4Y2x1ZGluZyBzeW5jIGZpbGVzXG5cdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIHN5bmNFbnRyaWVzKSB7XG5cdFx0XHRcdGlmICh0aGlzLnNob3VsZFRyYWNrRmlsZShlbnRyeS5maWxlUGF0aCkpIHtcblx0XHRcdFx0XHR0aGlzLmZpbGVDYWNoZS5zZXQoZW50cnkuZmlsZVBhdGgsIHtcblx0XHRcdFx0XHRcdHBhdGg6IGVudHJ5LmZpbGVQYXRoLFxuXHRcdFx0XHRcdFx0aGFzaDogZW50cnkuaGFzaCxcblx0XHRcdFx0XHRcdGxhc3RNb2RpZmllZDogZW50cnkubGFzdE1vZGlmaWVkLFxuXHRcdFx0XHRcdFx0bGFzdFN5bmNlZDogZW50cnkubGFzdFN5bmNlZFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNjYW4gdmF1bHQgZm9yIG5ldyBvciBtb2RpZmllZCBmaWxlc1xuXHRcdFx0Y29uc3QgZmlsZXMgPSB0aGlzLnZhdWx0LmdldEZpbGVzKCk7XG5cdFx0XHRmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoIXRoaXMuc2hvdWxkVHJhY2tGaWxlKGZpbGUucGF0aCkpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IGhhc2ggPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUZpbGVIYXNoKGZpbGUpO1xuXHRcdFx0XHRcdGNvbnN0IGV4aXN0aW5nID0gdGhpcy5maWxlQ2FjaGUuZ2V0KGZpbGUucGF0aCk7XG5cblx0XHRcdFx0XHRpZiAoIWV4aXN0aW5nIHx8IGV4aXN0aW5nLmhhc2ggIT09IGhhc2gpIHtcblx0XHRcdFx0XHRcdHRoaXMuZmlsZUNhY2hlLnNldChmaWxlLnBhdGgsIHtcblx0XHRcdFx0XHRcdFx0cGF0aDogZmlsZS5wYXRoLFxuXHRcdFx0XHRcdFx0XHRoYXNoLFxuXHRcdFx0XHRcdFx0XHRsYXN0TW9kaWZpZWQ6IGZpbGUuc3RhdC5tdGltZVxuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdC8vIFVwZGF0ZSBzeW5jIHN0YXR1cyBmb3IgbW9kaWZpZWQgZmlsZXNcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuc3luY01hbmFnZXIudXBkYXRlU3luY1N0YXR1cyhmaWxlLnBhdGgsICdQRU5ESU5HJywge1xuXHRcdFx0XHRcdFx0XHRsYXN0TW9kaWZpZWQ6IGZpbGUuc3RhdC5tdGltZSxcblx0XHRcdFx0XHRcdFx0aGFzaFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7XG5cdFx0XHRcdFx0XHRjb250ZXh0OiAnRmlsZVRyYWNrZXIuaW5pdGlhbGl6ZScsXG5cdFx0XHRcdFx0XHRtZXRhZGF0YTogeyBmaWxlUGF0aDogZmlsZS5wYXRoIH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhbiB1cCBlbnRyaWVzIGZvciBmaWxlcyB0aGF0IG5vIGxvbmdlciBleGlzdFxuXHRcdFx0Y29uc3QgYWxsUGF0aHMgPSBuZXcgU2V0KGZpbGVzLm1hcChmID0+IGYucGF0aCkpO1xuXHRcdFx0Zm9yIChjb25zdCBbcGF0aCwgY2FjaGVdIG9mIHRoaXMuZmlsZUNhY2hlLmVudHJpZXMoKSkge1xuXHRcdFx0XHRpZiAoIWFsbFBhdGhzLmhhcyhwYXRoKSkge1xuXHRcdFx0XHRcdHRoaXMuZmlsZUNhY2hlLmRlbGV0ZShwYXRoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7XG5cdFx0XHRcdGNvbnRleHQ6ICdGaWxlVHJhY2tlci5pbml0aWFsaXplJ1xuXHRcdFx0fSk7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlIGZpbGUgY3JlYXRpb24gZXZlbnRzXG5cdCAqL1xuXHRhc3luYyBoYW5kbGVDcmVhdGUoZmlsZTogVEFic3RyYWN0RmlsZSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkgfHwgIXRoaXMuc2hvdWxkVHJhY2tGaWxlKGZpbGUucGF0aCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBldmVudDogRmlsZUV2ZW50ID0ge1xuXHRcdFx0dHlwZTogJ2NyZWF0ZScsXG5cdFx0XHRmaWxlLFxuXHRcdFx0dGltZXN0YW1wOiBEYXRlLm5vdygpXG5cdFx0fTtcblxuXHRcdGF3YWl0IHRoaXMucXVldWVFdmVudChldmVudCk7XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlIGZpbGUgbW9kaWZpY2F0aW9uIGV2ZW50c1xuXHQgKi9cblx0YXN5bmMgaGFuZGxlTW9kaWZ5KGZpbGU6IFRBYnN0cmFjdEZpbGUpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHx8ICF0aGlzLnNob3VsZFRyYWNrRmlsZShmaWxlLnBhdGgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgZXZlbnQ6IEZpbGVFdmVudCA9IHtcblx0XHRcdHR5cGU6ICdtb2RpZnknLFxuXHRcdFx0ZmlsZSxcblx0XHRcdHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuXHRcdH07XG5cblx0XHRhd2FpdCB0aGlzLnF1ZXVlRXZlbnQoZXZlbnQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZSBmaWxlIGRlbGV0aW9uIGV2ZW50c1xuXHQgKi9cblx0YXN5bmMgaGFuZGxlRGVsZXRlKGZpbGU6IFRBYnN0cmFjdEZpbGUpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHx8ICF0aGlzLnNob3VsZFRyYWNrRmlsZShmaWxlLnBhdGgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgZXZlbnQ6IEZpbGVFdmVudCA9IHtcblx0XHRcdHR5cGU6ICdkZWxldGUnLFxuXHRcdFx0ZmlsZSxcblx0XHRcdHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuXHRcdH07XG5cblx0XHRhd2FpdCB0aGlzLnF1ZXVlRXZlbnQoZXZlbnQpO1xuXHRcdHRoaXMuZmlsZUNhY2hlLmRlbGV0ZShmaWxlLnBhdGgpO1xuXG5cdFx0Ly8gVXBkYXRlIHN5bmMgc3RhdHVzIHRvIHJlZmxlY3QgZGVsZXRpb25cblx0XHRhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLnVwZGF0ZVN5bmNTdGF0dXMoZmlsZS5wYXRoLCAnT0snLCB7XG5cdFx0XHRsYXN0TW9kaWZpZWQ6IERhdGUubm93KCksXG5cdFx0XHRoYXNoOiAnJyAgLy8gRW1wdHkgaGFzaCBpbmRpY2F0ZXMgZGVsZXRpb25cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgZmlsZSByZW5hbWUgZXZlbnRzXG5cdCAqL1xuXHRhc3luYyBoYW5kbGVSZW5hbWUoZmlsZTogVEFic3RyYWN0RmlsZSwgb2xkUGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB8fCAhdGhpcy5zaG91bGRUcmFja0ZpbGUoZmlsZS5wYXRoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGV2ZW50OiBGaWxlRXZlbnQgPSB7XG5cdFx0XHR0eXBlOiAncmVuYW1lJyxcblx0XHRcdGZpbGUsXG5cdFx0XHRvbGRQYXRoLFxuXHRcdFx0dGltZXN0YW1wOiBEYXRlLm5vdygpXG5cdFx0fTtcblxuXHRcdGF3YWl0IHRoaXMucXVldWVFdmVudChldmVudCk7XG5cblx0XHQvLyBVcGRhdGUgY2FjaGUgYW5kIHN5bmMgc3RhdHVzIGZvciByZW5hbWVkIGZpbGVcblx0XHRpZiAodGhpcy5maWxlQ2FjaGUuaGFzKG9sZFBhdGgpKSB7XG5cdFx0XHRjb25zdCBjYWNoZSA9IHRoaXMuZmlsZUNhY2hlLmdldChvbGRQYXRoKTtcblx0XHRcdGlmIChjYWNoZSkge1xuXHRcdFx0XHR0aGlzLmZpbGVDYWNoZS5kZWxldGUob2xkUGF0aCk7XG5cdFx0XHRcdGNvbnN0IG5ld0hhc2ggPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUZpbGVIYXNoKGZpbGUpO1xuXHRcdFx0XHR0aGlzLmZpbGVDYWNoZS5zZXQoZmlsZS5wYXRoLCB7XG5cdFx0XHRcdFx0Li4uY2FjaGUsXG5cdFx0XHRcdFx0cGF0aDogZmlsZS5wYXRoLFxuXHRcdFx0XHRcdGhhc2g6IG5ld0hhc2gsXG5cdFx0XHRcdFx0bGFzdE1vZGlmaWVkOiBmaWxlLnN0YXQubXRpbWVcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gVXBkYXRlIHN5bmMgc3RhdHVzIGZvciBib3RoIG9sZCBhbmQgbmV3IHBhdGhzXG5cdFx0XHRcdGF3YWl0IHRoaXMuc3luY01hbmFnZXIudXBkYXRlU3luY1N0YXR1cyhvbGRQYXRoLCAnT0snLCB7XG5cdFx0XHRcdFx0bGFzdE1vZGlmaWVkOiBEYXRlLm5vdygpLFxuXHRcdFx0XHRcdGhhc2g6ICcnICAvLyBFbXB0eSBoYXNoIGluZGljYXRlcyBkZWxldGlvbi9tb3ZlXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGF3YWl0IHRoaXMuc3luY01hbmFnZXIudXBkYXRlU3luY1N0YXR1cyhmaWxlLnBhdGgsICdQRU5ESU5HJywge1xuXHRcdFx0XHRcdGxhc3RNb2RpZmllZDogZmlsZS5zdGF0Lm10aW1lLFxuXHRcdFx0XHRcdGhhc2g6IG5ld0hhc2hcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBzaG91bGRUcmFja0ZpbGUoZmlsZVBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRcdC8vIE5ldmVyIHRyYWNrIHN5bmMgZmlsZXNcblx0XHRpZiAoZmlsZVBhdGggPT09IHRoaXMuc3luY0ZpbGVQYXRoIHx8XG5cdFx0XHRmaWxlUGF0aC5lbmRzV2l0aCgnX21pbmRtYXRyaXhzeW5jLm1kJykgfHxcblx0XHRcdGZpbGVQYXRoLmVuZHNXaXRoKCdfbWluZG1hdHJpeHN5bmMubWQuYmFja3VwJykpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogUXVldWUgYW4gZXZlbnQgZm9yIHByb2Nlc3Npbmdcblx0ICovXG5cdHByaXZhdGUgYXN5bmMgcXVldWVFdmVudChldmVudDogRmlsZUV2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dGhpcy5ldmVudFF1ZXVlLnB1c2goZXZlbnQpO1xuXG5cdFx0aWYgKCF0aGlzLmlzUHJvY2Vzc2luZykge1xuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB0aGlzLnByb2Nlc3NFdmVudFF1ZXVlKCksIHRoaXMucHJvY2Vzc2luZ1RpbWVvdXQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBQcm9jZXNzIHF1ZXVlZCBldmVudHMgd2l0aCBkZWJvdW5jaW5nXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIHByb2Nlc3NFdmVudFF1ZXVlKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICh0aGlzLmlzUHJvY2Vzc2luZyB8fCB0aGlzLmV2ZW50UXVldWUubGVuZ3RoID09PSAwKSByZXR1cm47XG5cblx0XHR0aGlzLmlzUHJvY2Vzc2luZyA9IHRydWU7XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gR3JvdXAgZXZlbnRzIGJ5IGZpbGUgcGF0aFxuXHRcdFx0Y29uc3QgZXZlbnRzQnlQYXRoID0gbmV3IE1hcDxzdHJpbmcsIEZpbGVFdmVudFtdPigpO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGV2ZW50IG9mIHRoaXMuZXZlbnRRdWV1ZSkge1xuXHRcdFx0XHRjb25zdCBwYXRoID0gZXZlbnQuZmlsZS5wYXRoO1xuXHRcdFx0XHRpZiAoIWV2ZW50c0J5UGF0aC5oYXMocGF0aCkpIHtcblx0XHRcdFx0XHRldmVudHNCeVBhdGguc2V0KHBhdGgsIFtdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRldmVudHNCeVBhdGguZ2V0KHBhdGgpPy5wdXNoKGV2ZW50KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHJvY2VzcyBlYWNoIGZpbGUncyBldmVudHNcblx0XHRcdGZvciAoY29uc3QgW3BhdGgsIGV2ZW50c10gb2YgZXZlbnRzQnlQYXRoKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMucHJvY2Vzc0ZpbGVFdmVudHMocGF0aCwgZXZlbnRzKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdGhlIHF1ZXVlXG5cdFx0XHR0aGlzLmV2ZW50UXVldWUgPSBbXTtcblxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0XHRjb250ZXh0OiAnRmlsZVRyYWNrZXIucHJvY2Vzc0V2ZW50UXVldWUnXG5cdFx0XHR9KTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dGhpcy5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUHJvY2VzcyBhbGwgZXZlbnRzIGZvciBhIHNpbmdsZSBmaWxlXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIHByb2Nlc3NGaWxlRXZlbnRzKHBhdGg6IHN0cmluZywgZXZlbnRzOiBGaWxlRXZlbnRbXSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdC8vIFNvcnQgZXZlbnRzIGJ5IHRpbWVzdGFtcFxuXHRcdGV2ZW50cy5zb3J0KChhLCBiKSA9PiBhLnRpbWVzdGFtcCAtIGIudGltZXN0YW1wKTtcblxuXHRcdC8vIEdldCB0aGUgZmluYWwgc3RhdGUgYWZ0ZXIgYWxsIGV2ZW50c1xuXHRcdGNvbnN0IGZpbmFsRXZlbnQgPSBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdO1xuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIENhbGN1bGF0ZSBuZXcgaGFzaCBmb3IgZXhpc3RpbmcgZmlsZXNcblx0XHRcdGlmIChmaW5hbEV2ZW50LnR5cGUgIT09ICdkZWxldGUnKSB7XG5cdFx0XHRcdGNvbnN0IG5ld0hhc2ggPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUZpbGVIYXNoKGZpbmFsRXZlbnQuZmlsZSk7XG5cdFx0XHRcdGNvbnN0IGV4aXN0aW5nQ2FjaGUgPSB0aGlzLmZpbGVDYWNoZS5nZXQocGF0aCk7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgZmlsZSBhY3R1YWxseSBjaGFuZ2VkXG5cdFx0XHRcdGlmIChleGlzdGluZ0NhY2hlICYmIGV4aXN0aW5nQ2FjaGUuaGFzaCA9PT0gbmV3SGFzaCkge1xuXHRcdFx0XHRcdHJldHVybjsgLy8gTm8gcmVhbCBjaGFuZ2Vcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFVwZGF0ZSBjYWNoZVxuXHRcdFx0XHR0aGlzLmZpbGVDYWNoZS5zZXQocGF0aCwge1xuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0aGFzaDogbmV3SGFzaCxcblx0XHRcdFx0XHRsYXN0TW9kaWZpZWQ6IGZpbmFsRXZlbnQuZmlsZS5zdGF0Lm10aW1lXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSBzeW5jIHN0YXR1c1xuXHRcdFx0XHRhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLnVwZGF0ZVN5bmNTdGF0dXMocGF0aCwgJ1BFTkRJTkcnLCB7XG5cdFx0XHRcdFx0bGFzdE1vZGlmaWVkOiBmaW5hbEV2ZW50LmZpbGUuc3RhdC5tdGltZSxcblx0XHRcdFx0XHRoYXNoOiBuZXdIYXNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0XHRjb250ZXh0OiAnRmlsZVRyYWNrZXIucHJvY2Vzc0ZpbGVFdmVudHMnLFxuXHRcdFx0XHRtZXRhZGF0YTogeyBwYXRoLCBldmVudFR5cGU6IGZpbmFsRXZlbnQudHlwZSB9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlIGEgaGFzaCBvZiBmaWxlIGNvbnRlbnRzXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIGNhbGN1bGF0ZUZpbGVIYXNoKGZpbGU6IFRGaWxlKTogUHJvbWlzZTxzdHJpbmc+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHQucmVhZChmaWxlKTtcblx0XHRcdHJldHVybiBhd2FpdCB0aGlzLmhhc2hTdHJpbmcoY29udGVudCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7XG5cdFx0XHRcdGNvbnRleHQ6ICdGaWxlVHJhY2tlci5jYWxjdWxhdGVGaWxlSGFzaCcsXG5cdFx0XHRcdG1ldGFkYXRhOiB7IGZpbGVQYXRoOiBmaWxlLnBhdGggfVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGhhc2ggZnJvbSBhIHN0cmluZ1xuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBoYXNoU3RyaW5nKHN0cjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcblx0XHRjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5cdFx0Y29uc3QgZGF0YSA9IGVuY29kZXIuZW5jb2RlKHN0cik7XG5cdFx0Y29uc3QgYnVmZmVyID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBkYXRhKTtcblx0XHRyZXR1cm4gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShidWZmZXIpKVxuXHRcdFx0Lm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpXG5cdFx0XHQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIG1ldGFkYXRhIGZvciBhIGZpbGVcblx0ICovXG5cdHB1YmxpYyBhc3luYyBjcmVhdGVGaWxlTWV0YWRhdGEoZmlsZTogVEZpbGUpOiBQcm9taXNlPERvY3VtZW50TWV0YWRhdGE+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHQucmVhZChmaWxlKTtcblx0XHRcdGNvbnN0IGxpbmVDb3VudCA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpLmxlbmd0aDtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0b2JzaWRpYW5JZDogZmlsZS5wYXRoLFxuXHRcdFx0XHRwYXRoOiBmaWxlLnBhdGgsXG5cdFx0XHRcdGxhc3RNb2RpZmllZDogZmlsZS5zdGF0Lm10aW1lLFxuXHRcdFx0XHRjcmVhdGVkOiBmaWxlLnN0YXQuY3RpbWUsXG5cdFx0XHRcdHNpemU6IGZpbGUuc3RhdC5zaXplLFxuXHRcdFx0XHRjdXN0b21NZXRhZGF0YToge30sXG5cdFx0XHRcdC8vIEFkZCBuOG4gY29tcGF0aWJsZSBtZXRhZGF0YVxuXHRcdFx0XHRsb2M6IHtcblx0XHRcdFx0XHRsaW5lczoge1xuXHRcdFx0XHRcdFx0ZnJvbTogMSxcblx0XHRcdFx0XHRcdHRvOiBsaW5lQ291bnRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNvdXJjZTogXCJvYnNpZGlhblwiLFxuXHRcdFx0XHRmaWxlX2lkOiBmaWxlLnBhdGgsXG5cdFx0XHRcdGJsb2JUeXBlOiBcInRleHQvbWFya2Rvd25cIlxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ0ZpbGVUcmFja2VyLmNyZWF0ZUZpbGVNZXRhZGF0YScsXG5cdFx0XHRcdG1ldGFkYXRhOiB7IGZpbGVQYXRoOiBmaWxlLnBhdGggfVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRvYnNpZGlhbklkOiBmaWxlLnBhdGgsXG5cdFx0XHRcdHBhdGg6IGZpbGUucGF0aCxcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiBmaWxlLnN0YXQubXRpbWUsXG5cdFx0XHRcdGNyZWF0ZWQ6IGZpbGUuc3RhdC5jdGltZSxcblx0XHRcdFx0c2l6ZTogZmlsZS5zdGF0LnNpemUsXG5cdFx0XHRcdGN1c3RvbU1ldGFkYXRhOiB7fVxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXIgZmlsZSBjYWNoZSBhbmQgcXVldWVcblx0ICovXG5cdHB1YmxpYyBjbGVhckNhY2hlKCk6IHZvaWQge1xuXHRcdHRoaXMuZmlsZUNhY2hlLmNsZWFyKCk7XG5cdFx0dGhpcy5ldmVudFF1ZXVlID0gW107XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHByb2Nlc3NpbmcgdGltZW91dFxuXHQgKi9cblx0cHVibGljIHNldFByb2Nlc3NpbmdUaW1lb3V0KHRpbWVvdXQ6IG51bWJlcik6IHZvaWQge1xuXHRcdHRoaXMucHJvY2Vzc2luZ1RpbWVvdXQgPSB0aW1lb3V0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBzeW5jIHN0YXR1cyBmb3IgYSBmaWxlXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgZ2V0U3luY1N0YXR1cyhwYXRoOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gYXdhaXQgdGhpcy5zeW5jTWFuYWdlci5nZXRTeW5jU3RhdHVzKHBhdGgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBhbGwgc3luYyBzdGF0dXNlc1xuXHQgKi9cblx0cHVibGljIGFzeW5jIGdldEFsbFN5bmNTdGF0dXNlcygpIHtcblx0XHRyZXR1cm4gYXdhaXQgdGhpcy5zeW5jTWFuYWdlci5nZXRBbGxTeW5jRW50cmllcygpO1xuXHR9XG59XG4iLCAiLy8gc3JjL3NlcnZpY2VzL1N5bmNGaWxlTWFuYWdlci50c1xuXG5pbXBvcnQgeyBURmlsZSwgVmF1bHQgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBFcnJvckhhbmRsZXIgfSBmcm9tICcuLi91dGlscy9FcnJvckhhbmRsZXInO1xuaW1wb3J0IHsgRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IgfSBmcm9tICcuLi9tb2RlbHMvRG9jdW1lbnRDaHVuayc7XG5cbmludGVyZmFjZSBTeW5jU3RhdGUge1xuXHRpc1ZhbGlkOiBib29sZWFuO1xuXHRlcnJvcj86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFN5bmNFbnRyeSB7XG5cdGZpbGVQYXRoOiBzdHJpbmc7XG5cdGxhc3RNb2RpZmllZDogbnVtYmVyO1xuXHRsYXN0U3luY2VkOiBudW1iZXI7XG5cdGhhc2g6IHN0cmluZztcblx0c3RhdHVzOiAnT0snIHwgJ1BFTkRJTkcnIHwgJ0VSUk9SJztcbn1cblxuaW50ZXJmYWNlIFN5bmNGaWxlQ29udGVudCB7XG5cdGxhc3RTeW5jOiBudW1iZXI7XG5cdGVudHJpZXM6IFN5bmNFbnRyeVtdO1xufVxuXG5leHBvcnQgY2xhc3MgU3luY0ZpbGVNYW5hZ2VyIHtcblx0cHJpdmF0ZSBzeW5jRmlsZVBhdGg6IHN0cmluZztcblx0cHJpdmF0ZSBiYWNrdXBQYXRoOiBzdHJpbmc7XG5cdHByaXZhdGUgbGFzdEJhY2t1cDogbnVtYmVyID0gMDtcblx0cHJpdmF0ZSBiYWNrdXBJbnRlcnZhbDogbnVtYmVyO1xuXHRwcml2YXRlIHN5bmNGaWxlOiBURmlsZSB8IG51bGwgPSBudWxsO1xuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByaXZhdGUgdmF1bHQ6IFZhdWx0LFxuXHRcdHByaXZhdGUgZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXIsXG5cdFx0c3luY0ZpbGVQYXRoOiBzdHJpbmcgPSAnX21pbmRtYXRyaXhzeW5jLm1kJyxcblx0XHRiYWNrdXBJbnRlcnZhbDogbnVtYmVyID0gMzYwMDAwMCAvLyAxIGhvdXIgaW4gbWlsbGlzZWNvbmRzXG5cdCkge1xuXHRcdHRoaXMuc3luY0ZpbGVQYXRoID0gc3luY0ZpbGVQYXRoO1xuXHRcdHRoaXMuYmFja3VwUGF0aCA9IGAke3N5bmNGaWxlUGF0aH0uYmFja3VwYDtcblx0XHR0aGlzLmJhY2t1cEludGVydmFsID0gYmFja3VwSW50ZXJ2YWw7XG5cdH1cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSBvciB2YWxpZGF0ZSB0aGUgc3luYyBmaWxlXG5cdCAqL1xuXHRhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBDaGVjayBpZiBzeW5jIGZpbGUgZXhpc3RzXG5cdFx0XHRjb25zdCBleGlzdGluZ0ZpbGUgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLnN5bmNGaWxlUGF0aCk7XG5cblx0XHRcdGlmIChleGlzdGluZ0ZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0XHR0aGlzLnN5bmNGaWxlID0gZXhpc3RpbmdGaWxlO1xuXHRcdFx0XHQvLyBWYWxpZGF0ZSBleGlzdGluZyBmaWxlXG5cdFx0XHRcdGNvbnN0IGlzVmFsaWQgPSBhd2FpdCB0aGlzLnZhbGlkYXRlU3luY0ZpbGUoKTtcblx0XHRcdFx0aWYgKCFpc1ZhbGlkKSB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5yZXBhaXJTeW5jRmlsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBDcmVhdGUgbmV3IHN5bmMgZmlsZVxuXHRcdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZVN5bmNGaWxlKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENyZWF0ZSBpbml0aWFsIGJhY2t1cFxuXHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVCYWNrdXAoKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci5pbml0aWFsaXplJyxcblx0XHRcdFx0bWV0YWRhdGE6IHsgc3luY0ZpbGVQYXRoOiB0aGlzLnN5bmNGaWxlUGF0aCB9XG5cdFx0XHR9KTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgc3luYyBmaWxlIHdpdGggaW5pdGlhbCBzdHJ1Y3R1cmVcblx0ICovXG5cdHByaXZhdGUgYXN5bmMgY3JlYXRlU3luY0ZpbGUoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc29sZS5sb2coJ1N0YXJ0aW5nIHN5bmMgZmlsZSBjcmVhdGlvbiB3aXRoIHdhaXQgcGVyaW9kcy4uLicpO1xuXHRcdGNvbnN0IGluaXRpYWxDb250ZW50ID0gdGhpcy5nZW5lcmF0ZUluaXRpYWxDb250ZW50KCk7XG5cblx0XHQvLyBGaXJzdCB3YWl0IHBlcmlvZCAtIDIwIHNlY29uZHMgYmVmb3JlIGNyZWF0aW9uXG5cdFx0Y29uc29sZS5sb2coJ1dhaXRpbmcgMjAgc2Vjb25kcyBiZWZvcmUgY3JlYXRpbmcgc3luYyBmaWxlLi4uJyk7XG5cdFx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDAwKSk7XG5cblx0XHQvLyBDcmVhdGUgdGhlIGZpbGVcblx0XHR0aGlzLnN5bmNGaWxlID0gYXdhaXQgdGhpcy52YXVsdC5jcmVhdGUodGhpcy5zeW5jRmlsZVBhdGgsIGluaXRpYWxDb250ZW50KTtcblx0XHRjb25zb2xlLmxvZygnU3luYyBmaWxlIGNyZWF0ZWQsIHN0YXJ0aW5nIHN0YWJpbGl0eSB3YWl0IHBlcmlvZC4uLicpO1xuXG5cdFx0Ly8gU2Vjb25kIHdhaXQgcGVyaW9kIC0gNSBzZWNvbmRzIGFmdGVyIGNyZWF0aW9uXG5cdFx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMDApKTtcblxuXHRcdC8vIFZlcmlmeSBmaWxlIGV4aXN0cyBhbmQgaXMgcmVhZGFibGVcblx0XHRjb25zdCBmaWxlRXhpc3RzID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5zeW5jRmlsZVBhdGgpO1xuXHRcdGlmICghZmlsZUV4aXN0cykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTeW5jIGZpbGUgY3JlYXRpb24gZmFpbGVkIC0gZmlsZSBub3QgZm91bmQgYWZ0ZXIgd2FpdCBwZXJpb2QnKTtcblx0XHR9XG5cblx0XHRjb25zb2xlLmxvZygnU3luYyBmaWxlIGNyZWF0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBpbml0aWFsIGNvbnRlbnQgZm9yIHN5bmMgZmlsZVxuXHQgKi9cblx0cHJpdmF0ZSBnZW5lcmF0ZUluaXRpYWxDb250ZW50KCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIGAtLS1cbmxhc3Rfc3luYzogJHtEYXRlLm5vdygpfVxuLS0tXG5cbiMjIFN5bmNlZCBGaWxlc1xufCBGaWxlIFBhdGggfCBMYXN0IE1vZGlmaWVkIHwgTGFzdCBTeW5jZWQgfCBIYXNoIHwgU3RhdHVzIHxcbnwtLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tfC0tLS0tLXwtLS0tLS0tLXxcbmA7XG5cdH1cblxuXHQvKipcblx0ICogVmFsaWRhdGUgc3luYyBmaWxlIHN0cnVjdHVyZSBhbmQgY29udGVudFxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyB2YWxpZGF0ZVN5bmNGaWxlKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdGlmICghdGhpcy5zeW5jRmlsZSkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLnZhdWx0LnJlYWQodGhpcy5zeW5jRmlsZSk7XG5cblx0XHRcdC8vIENoZWNrIGJhc2ljIHN0cnVjdHVyZVxuXHRcdFx0Y29uc3QgaGFzWWFtbEZyb250bWF0dGVyID0gL14tLS1cXG5bXFxzXFxTXSo/XFxuLS0tLy50ZXN0KGNvbnRlbnQpO1xuXHRcdFx0Y29uc3QgaGFzVGFibGVIZWFkZXIgPSBjb250ZW50LmluY2x1ZGVzKCd8IEZpbGUgUGF0aCB8IExhc3QgTW9kaWZpZWQgfCBMYXN0IFN5bmNlZCB8IEhhc2ggfCBTdGF0dXMgfCcpO1xuXHRcdFx0Y29uc3QgaGFzVGFibGVEZWxpbWl0ZXIgPSBjb250ZW50LmluY2x1ZGVzKCd8LS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLXwtLS0tLS18LS0tLS0tLS18Jyk7XG5cblx0XHRcdGlmICghaGFzWWFtbEZyb250bWF0dGVyIHx8ICFoYXNUYWJsZUhlYWRlciB8fCAhaGFzVGFibGVEZWxpbWl0ZXIpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXJzZSBhbmQgdmFsaWRhdGUgZW50cmllc1xuXHRcdFx0Y29uc3QgZW50cmllcyA9IGF3YWl0IHRoaXMucGFyc2VTeW5jRmlsZSgpO1xuXHRcdFx0Zm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG5cdFx0XHRcdGlmICghdGhpcy52YWxpZGF0ZUVudHJ5KGVudHJ5KSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci52YWxpZGF0ZVN5bmNGaWxlJyxcblx0XHRcdFx0bWV0YWRhdGE6IHsgc3luY0ZpbGVQYXRoOiB0aGlzLnN5bmNGaWxlUGF0aCB9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVmFsaWRhdGUgYSBzaW5nbGUgc3luYyBlbnRyeVxuXHQgKi9cblx0cHJpdmF0ZSB2YWxpZGF0ZUVudHJ5KGVudHJ5OiBTeW5jRW50cnkpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dHlwZW9mIGVudHJ5LmZpbGVQYXRoID09PSAnc3RyaW5nJyAmJlxuXHRcdFx0dHlwZW9mIGVudHJ5Lmxhc3RNb2RpZmllZCA9PT0gJ251bWJlcicgJiZcblx0XHRcdHR5cGVvZiBlbnRyeS5sYXN0U3luY2VkID09PSAnbnVtYmVyJyAmJlxuXHRcdFx0dHlwZW9mIGVudHJ5Lmhhc2ggPT09ICdzdHJpbmcnICYmXG5cdFx0XHRbJ09LJywgJ1BFTkRJTkcnLCAnRVJST1InXS5pbmNsdWRlcyhlbnRyeS5zdGF0dXMpXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXBhaXIgY29ycnVwdGVkIHN5bmMgZmlsZVxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyByZXBhaXJTeW5jRmlsZSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gVHJ5IHRvIHJlc3RvcmUgZnJvbSBiYWNrdXAgZmlyc3Rcblx0XHRcdGNvbnN0IHJlc3RvcmVkID0gYXdhaXQgdGhpcy5yZXN0b3JlRnJvbUJhY2t1cCgpO1xuXHRcdFx0aWYgKCFyZXN0b3JlZCkge1xuXHRcdFx0XHQvLyBJZiByZXN0b3JhdGlvbiBmYWlscywgY3JlYXRlIG5ldyBzeW5jIGZpbGVcblx0XHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVTeW5jRmlsZSgpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0XHRjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLnJlcGFpclN5bmNGaWxlJyxcblx0XHRcdFx0bWV0YWRhdGE6IHsgc3luY0ZpbGVQYXRoOiB0aGlzLnN5bmNGaWxlUGF0aCB9XG5cdFx0XHR9KTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZSBzeW5jIGZpbGUgY29udGVudFxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBwYXJzZVN5bmNGaWxlKCk6IFByb21pc2U8U3luY0VudHJ5W10+IHtcblx0XHRpZiAoIXRoaXMuc3luY0ZpbGUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihEb2N1bWVudFByb2Nlc3NpbmdFcnJvci5TWU5DX0VSUk9SKTtcblx0XHR9XG5cblx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkKHRoaXMuc3luY0ZpbGUpO1xuXHRcdGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XG5cdFx0Y29uc3QgZW50cmllczogU3luY0VudHJ5W10gPSBbXTtcblxuXHRcdGxldCB0YWJsZVN0YXJ0SW5kZXggPSAtMTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAobGluZXNbaV0uaW5jbHVkZXMoJ3wgRmlsZSBQYXRoIHwgTGFzdCBNb2RpZmllZCB8JykpIHtcblx0XHRcdFx0dGFibGVTdGFydEluZGV4ID0gaSArIDI7IC8vIFNraXAgaGVhZGVyIGFuZCBkZWxpbWl0ZXJcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRhYmxlU3RhcnRJbmRleCA9PT0gLTEpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzeW5jIGZpbGUgZm9ybWF0Jyk7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgaSA9IHRhYmxlU3RhcnRJbmRleDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBsaW5lID0gbGluZXNbaV0udHJpbSgpO1xuXHRcdFx0aWYgKCFsaW5lIHx8IGxpbmUuc3RhcnRzV2l0aCgnIycpKSBjb250aW51ZTtcblxuXHRcdFx0Y29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCd8JykubWFwKHBhcnQgPT4gcGFydC50cmltKCkpO1xuXHRcdFx0aWYgKHBhcnRzLmxlbmd0aCA+PSA2KSB7XG5cdFx0XHRcdGVudHJpZXMucHVzaCh7XG5cdFx0XHRcdFx0ZmlsZVBhdGg6IHBhcnRzWzFdLFxuXHRcdFx0XHRcdGxhc3RNb2RpZmllZDogcGFyc2VJbnQocGFydHNbMl0pLFxuXHRcdFx0XHRcdGxhc3RTeW5jZWQ6IHBhcnNlSW50KHBhcnRzWzNdKSxcblx0XHRcdFx0XHRoYXNoOiBwYXJ0c1s0XSxcblx0XHRcdFx0XHRzdGF0dXM6IHBhcnRzWzVdIGFzICdPSycgfCAnUEVORElORycgfCAnRVJST1InXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBlbnRyaWVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBzeW5jIHN0YXR1cyBmb3IgYSBmaWxlXG5cdCAqL1xuXHRhc3luYyB1cGRhdGVTeW5jU3RhdHVzKFxuXHRcdGZpbGVQYXRoOiBzdHJpbmcsXG5cdFx0c3RhdHVzOiAnT0snIHwgJ1BFTkRJTkcnIHwgJ0VSUk9SJyxcblx0XHRtZXRhZGF0YTogeyBsYXN0TW9kaWZpZWQ6IG51bWJlcjsgaGFzaDogc3RyaW5nIH1cblx0KTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghdGhpcy5zeW5jRmlsZSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1N5bmMgZmlsZSBub3QgaW5pdGlhbGl6ZWQnKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZW50cmllcyA9IGF3YWl0IHRoaXMucGFyc2VTeW5jRmlsZSgpO1xuXHRcdFx0Y29uc3QgZXhpc3RpbmdFbnRyeUluZGV4ID0gZW50cmllcy5maW5kSW5kZXgoZSA9PiBlLmZpbGVQYXRoID09PSBmaWxlUGF0aCk7XG5cdFx0XHRjb25zdCBuZXdFbnRyeTogU3luY0VudHJ5ID0ge1xuXHRcdFx0XHRmaWxlUGF0aCxcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiBtZXRhZGF0YS5sYXN0TW9kaWZpZWQsXG5cdFx0XHRcdGxhc3RTeW5jZWQ6IERhdGUubm93KCksXG5cdFx0XHRcdGhhc2g6IG1ldGFkYXRhLmhhc2gsXG5cdFx0XHRcdHN0YXR1c1xuXHRcdFx0fTtcblxuXHRcdFx0aWYgKGV4aXN0aW5nRW50cnlJbmRleCA+PSAwKSB7XG5cdFx0XHRcdGVudHJpZXNbZXhpc3RpbmdFbnRyeUluZGV4XSA9IG5ld0VudHJ5O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZW50cmllcy5wdXNoKG5ld0VudHJ5KTtcblx0XHRcdH1cblxuXHRcdFx0YXdhaXQgdGhpcy53cml0ZVN5bmNGaWxlKGVudHJpZXMpO1xuXG5cdFx0XHQvLyBDcmVhdGUgYmFja3VwIGlmIG5lZWRlZFxuXHRcdFx0aWYgKERhdGUubm93KCkgLSB0aGlzLmxhc3RCYWNrdXAgPj0gdGhpcy5iYWNrdXBJbnRlcnZhbCkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZUJhY2t1cCgpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0XHRjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLnVwZGF0ZVN5bmNTdGF0dXMnLFxuXHRcdFx0XHRtZXRhZGF0YTogeyBmaWxlUGF0aCwgc3RhdHVzIH1cblx0XHRcdH0pO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFdyaXRlIGVudHJpZXMgdG8gc3luYyBmaWxlXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIHdyaXRlU3luY0ZpbGUoZW50cmllczogU3luY0VudHJ5W10pOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuc3luY0ZpbGUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignU3luYyBmaWxlIG5vdCBpbml0aWFsaXplZCcpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGhlYWRlciA9IGAtLS1cbmxhc3Rfc3luYzogJHtEYXRlLm5vdygpfVxuLS0tXG5cbiMjIFN5bmNlZCBGaWxlc1xufCBGaWxlIFBhdGggfCBMYXN0IE1vZGlmaWVkIHwgTGFzdCBTeW5jZWQgfCBIYXNoIHwgU3RhdHVzIHxcbnwtLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tfC0tLS0tLXwtLS0tLS0tLXxcbmA7XG5cblx0XHRjb25zdCBjb250ZW50ID0gZW50cmllc1xuXHRcdFx0Lm1hcChlbnRyeSA9PiBgfCAke2VudHJ5LmZpbGVQYXRofSB8ICR7ZW50cnkubGFzdE1vZGlmaWVkfSB8ICR7ZW50cnkubGFzdFN5bmNlZH0gfCAke2VudHJ5Lmhhc2h9IHwgJHtlbnRyeS5zdGF0dXN9IHxgKVxuXHRcdFx0LmpvaW4oJ1xcbicpO1xuXG5cdFx0YXdhaXQgdGhpcy52YXVsdC5tb2RpZnkodGhpcy5zeW5jRmlsZSwgaGVhZGVyICsgY29udGVudCk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIGEgYmFja3VwIG9mIHRoZSBzeW5jIGZpbGVcblx0ICovXG5cdHByaXZhdGUgYXN5bmMgY3JlYXRlQmFja3VwKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghdGhpcy5zeW5jRmlsZSkgcmV0dXJuO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLnZhdWx0LnJlYWQodGhpcy5zeW5jRmlsZSk7XG5cdFx0XHRjb25zdCBiYWNrdXBGaWxlID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5iYWNrdXBQYXRoKTtcblxuXHRcdFx0aWYgKGJhY2t1cEZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnZhdWx0Lm1vZGlmeShiYWNrdXBGaWxlLCBjb250ZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMudmF1bHQuY3JlYXRlKHRoaXMuYmFja3VwUGF0aCwgY29udGVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubGFzdEJhY2t1cCA9IERhdGUubm93KCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7XG5cdFx0XHRcdGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIuY3JlYXRlQmFja3VwJ1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlc3RvcmUgc3luYyBmaWxlIGZyb20gYmFja3VwXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIHJlc3RvcmVGcm9tQmFja3VwKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdGNvbnN0IGJhY2t1cEZpbGUgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLmJhY2t1cFBhdGgpO1xuXHRcdGlmICghKGJhY2t1cEZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHQucmVhZChiYWNrdXBGaWxlKTtcblx0XHRcdGlmICh0aGlzLnN5bmNGaWxlKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMudmF1bHQubW9kaWZ5KHRoaXMuc3luY0ZpbGUsIGNvbnRlbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zeW5jRmlsZSA9IGF3YWl0IHRoaXMudmF1bHQuY3JlYXRlKHRoaXMuc3luY0ZpbGVQYXRoLCBjb250ZW50KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0XHRjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLnJlc3RvcmVGcm9tQmFja3VwJ1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBzeW5jIHN0YXR1cyBmb3IgYSBmaWxlXG5cdCAqL1xuXHRhc3luYyBnZXRTeW5jU3RhdHVzKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPFN5bmNFbnRyeSB8IG51bGw+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgZW50cmllcyA9IGF3YWl0IHRoaXMucGFyc2VTeW5jRmlsZSgpO1xuXHRcdFx0cmV0dXJuIGVudHJpZXMuZmluZChlID0+IGUuZmlsZVBhdGggPT09IGZpbGVQYXRoKSB8fCBudWxsO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0XHRjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLmdldFN5bmNTdGF0dXMnLFxuXHRcdFx0XHRtZXRhZGF0YTogeyBmaWxlUGF0aCB9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgYWxsIHN5bmMgZW50cmllc1xuXHQgKi9cblx0YXN5bmMgZ2V0QWxsU3luY0VudHJpZXMoKTogUHJvbWlzZTxTeW5jRW50cnlbXT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgdGhpcy5wYXJzZVN5bmNGaWxlKCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7XG5cdFx0XHRcdGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIuZ2V0QWxsU3luY0VudHJpZXMnXG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdH1cblxuXHRhc3luYyB2YWxpZGF0ZVN5bmNTdGF0ZSgpOiBQcm9taXNlPFN5bmNTdGF0ZT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXRoaXMuc3luY0ZpbGUpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpc1ZhbGlkOiBmYWxzZSxcblx0XHRcdFx0XHRlcnJvcjogJ1N5bmMgZmlsZSBub3QgaW5pdGlhbGl6ZWQnXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLnZhdWx0LnJlYWQodGhpcy5zeW5jRmlsZSk7XG5cblx0XHRcdC8vIENoZWNrIGJhc2ljIHN0cnVjdHVyZVxuXHRcdFx0Y29uc3QgaGFzWWFtbEZyb250bWF0dGVyID0gL14tLS1cXG5bXFxzXFxTXSo/XFxuLS0tLy50ZXN0KGNvbnRlbnQpO1xuXHRcdFx0Y29uc3QgaGFzVGFibGVIZWFkZXIgPSBjb250ZW50LmluY2x1ZGVzKCd8IEZpbGUgUGF0aCB8IExhc3QgTW9kaWZpZWQgfCBMYXN0IFN5bmNlZCB8IEhhc2ggfCBTdGF0dXMgfCcpO1xuXHRcdFx0Y29uc3QgaGFzVGFibGVEZWxpbWl0ZXIgPSBjb250ZW50LmluY2x1ZGVzKCd8LS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLXwtLS0tLS18LS0tLS0tLS18Jyk7XG5cblx0XHRcdGlmICghaGFzWWFtbEZyb250bWF0dGVyIHx8ICFoYXNUYWJsZUhlYWRlciB8fCAhaGFzVGFibGVEZWxpbWl0ZXIpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpc1ZhbGlkOiBmYWxzZSxcblx0XHRcdFx0XHRlcnJvcjogJ0ludmFsaWQgc3luYyBmaWxlIHN0cnVjdHVyZSdcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFyc2UgYW5kIHZhbGlkYXRlIGVudHJpZXNcblx0XHRcdGNvbnN0IGVudHJpZXMgPSBhd2FpdCB0aGlzLnBhcnNlU3luY0ZpbGUoKTtcblx0XHRcdGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuXHRcdFx0XHRpZiAoIXRoaXMudmFsaWRhdGVFbnRyeShlbnRyeSkpIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0aXNWYWxpZDogZmFsc2UsXG5cdFx0XHRcdFx0XHRlcnJvcjogJ0ludmFsaWQgc3luYyBlbnRyeSBmb3VuZCdcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci52YWxpZGF0ZVN5bmNTdGF0ZSdcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aXNWYWxpZDogZmFsc2UsXG5cdFx0XHRcdGVycm9yOiBlcnJvci5tZXNzYWdlXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIGF0dGVtcHRSZWNvdmVyeSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gVHJ5IHRvIHJlc3RvcmUgZnJvbSBiYWNrdXAgZmlyc3Rcblx0XHRcdGNvbnN0IHJlc3RvcmVkID0gYXdhaXQgdGhpcy5yZXN0b3JlRnJvbUJhY2t1cCgpO1xuXHRcdFx0aWYgKHJlc3RvcmVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXN0b3JhdGlvbiBmYWlscywgY3JlYXRlIG5ldyBzeW5jIGZpbGVcblx0XHRcdGF3YWl0IHRoaXMuY3JlYXRlU3luY0ZpbGUoKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0XHRjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLmF0dGVtcHRSZWNvdmVyeSdcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIHVwZGF0ZUxhc3RTeW5jKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXRoaXMuc3luY0ZpbGUpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTeW5jIGZpbGUgbm90IGluaXRpYWxpemVkJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLnZhdWx0LnJlYWQodGhpcy5zeW5jRmlsZSk7XG5cdFx0XHRjb25zdCB1cGRhdGVkQ29udGVudCA9IGNvbnRlbnQucmVwbGFjZShcblx0XHRcdFx0L14tLS1cXG5sYXN0X3N5bmM6IFxcZCsvbSxcblx0XHRcdFx0YC0tLVxcbmxhc3Rfc3luYzogJHtEYXRlLm5vdygpfWBcblx0XHRcdCk7XG5cblx0XHRcdGF3YWl0IHRoaXMudmF1bHQubW9kaWZ5KHRoaXMuc3luY0ZpbGUsIHVwZGF0ZWRDb250ZW50KTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci51cGRhdGVMYXN0U3luYydcblx0XHRcdH0pO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59XG4iLCAiaW1wb3J0IHsgRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IgfSBmcm9tICcuLi9tb2RlbHMvRG9jdW1lbnRDaHVuayc7XG5pbXBvcnQgeyBUYXNrUHJvY2Vzc2luZ0Vycm9yIH0gZnJvbSAnLi4vbW9kZWxzL1Byb2Nlc3NpbmdUYXNrJztcbmltcG9ydCB7IERlYnVnU2V0dGluZ3MgfSBmcm9tICcuLi9zZXR0aW5ncy9TZXR0aW5ncyc7XG5pbXBvcnQgeyBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBQb3N0Z3Jlc3RFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JDb250ZXh0IHtcbiAgICBjb250ZXh0OiBzdHJpbmc7XG4gICAgdGFza0lkPzogc3RyaW5nO1xuICAgIHRhc2tUeXBlPzogc3RyaW5nO1xuICAgIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgYW55Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFcnJvckxvZyB7XG4gICAgdGltZXN0YW1wOiBudW1iZXI7XG4gICAgZXJyb3I6IEVycm9yO1xuICAgIGNvbnRleHQ6IEVycm9yQ29udGV4dDtcbiAgICBsZXZlbDogJ2Vycm9yJyB8ICd3YXJuJyB8ICdpbmZvJyB8ICdkZWJ1Zyc7XG4gICAgaGFuZGxlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdXBhYmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvZGU6IHN0cmluZztcbiAgICBkZXRhaWxzOiBzdHJpbmc7XG4gICAgaGludD86IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIEVycm9ySGFuZGxlciB7XG4gICAgcHJpdmF0ZSBlcnJvckxvZ3M6IEVycm9yTG9nW10gPSBbXTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1heExvZ3M6IG51bWJlciA9IDEwMDtcbiAgICBwcml2YXRlIHNldHRpbmdzOiBEZWJ1Z1NldHRpbmdzO1xuICAgIHByaXZhdGUgbG9nRmlsZVBhdGg/OiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5nczogRGVidWdTZXR0aW5ncywgdmF1bHRQYXRoPzogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgaWYgKHNldHRpbmdzLmxvZ1RvRmlsZSAmJiB2YXVsdFBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMubG9nRmlsZVBhdGggPSBgJHt2YXVsdFBhdGh9Ly5vYnNpZGlhbi9taW5kLW1hdHJpeC5sb2dgO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBlcnJvcnMgd2l0aCBjb250ZXh0IGFuZCBvcHRpb25hbCByZWNvdmVyeVxuICAgICAqL1xuICAgIGhhbmRsZUVycm9yKGVycm9yOiBhbnksIGNvbnRleHQ6IEVycm9yQ29udGV4dCwgbGV2ZWw6ICdlcnJvcicgfCAnd2FybicgfCAnaW5mbycgfCAnZGVidWcnID0gJ2Vycm9yJyk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkTG9nKGxldmVsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyb3JMb2c6IEVycm9yTG9nID0ge1xuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZXJyb3I6IHRoaXMubm9ybWFsaXplRXJyb3IoZXJyb3IpLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgaGFuZGxlZDogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBZGQgdG8gZXJyb3IgbG9ncyB3aXRoIHJvdGF0aW9uXG4gICAgICAgIHRoaXMuZXJyb3JMb2dzLnVuc2hpZnQoZXJyb3JMb2cpO1xuICAgICAgICBpZiAodGhpcy5lcnJvckxvZ3MubGVuZ3RoID4gdGhpcy5tYXhMb2dzKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yTG9ncy5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3cgbm90aWZpY2F0aW9uIGlmIGFwcHJvcHJpYXRlXG4gICAgICAgIGlmIChsZXZlbCA9PT0gJ2Vycm9yJyB8fCAobGV2ZWwgPT09ICd3YXJuJyAmJiB0aGlzLnNldHRpbmdzLmxvZ0xldmVsID09PSAnZGVidWcnKSkge1xuICAgICAgICAgICAgdGhpcy5zaG93RXJyb3JOb3RpZmljYXRpb24oZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVidWcgbG9nZ2luZ1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVEZWJ1Z0xvZ3MpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXAoYFske2xldmVsLnRvVXBwZXJDYXNlKCl9XSAke2NvbnRleHQuY29udGV4dH1gKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgZXJyb3IpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ29udGV4dDonLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChlcnJvci5zdGFjaykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N0YWNrIHRyYWNlOicsIGVycm9yLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbGUgbG9nZ2luZ1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5sb2dUb0ZpbGUgJiYgdGhpcy5sb2dGaWxlUGF0aCkge1xuICAgICAgICAgICAgdGhpcy53cml0ZVRvTG9nRmlsZShlcnJvckxvZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGVycm9yIGxldmVsIHNob3VsZCBiZSBsb2dnZWRcbiAgICAgKi9cbiAgICBwcml2YXRlIHNob3VsZExvZyhsZXZlbDogJ2Vycm9yJyB8ICd3YXJuJyB8ICdpbmZvJyB8ICdkZWJ1ZycpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgbGV2ZWxzID0ge1xuICAgICAgICAgICAgJ2Vycm9yJzogMCxcbiAgICAgICAgICAgICd3YXJuJzogMSxcbiAgICAgICAgICAgICdpbmZvJzogMixcbiAgICAgICAgICAgICdkZWJ1Zyc6IDNcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbGV2ZWxzW2xldmVsXSA8PSBsZXZlbHNbdGhpcy5zZXR0aW5ncy5sb2dMZXZlbF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyBkaWZmZXJlbnQgZXJyb3IgZm9ybWF0c1xuICAgICAqL1xuICAgIHByaXZhdGUgbm9ybWFsaXplRXJyb3IoZXJyb3I6IGFueSk6IEVycm9yIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBTdXBhYmFzZSBlcnJvcnNcbiAgICAgICAgaWYgKHRoaXMuaXNTdXBhYmFzZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgRGF0YWJhc2UgZXJyb3IgKCR7ZXJyb3IuY29kZX0pOiAke2Vycm9yLm1lc3NhZ2V9JHtlcnJvci5oaW50ID8gYCAtICR7ZXJyb3IuaGludH1gIDogJyd9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihub3JtYWxpemVkRXJyb3IsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkRXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdVbmtub3duIGVycm9yIG9jY3VycmVkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHlwZSBndWFyZCBmb3IgU3VwYWJhc2UgZXJyb3JzXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc1N1cGFiYXNlRXJyb3IoZXJyb3I6IGFueSk6IGVycm9yIGlzIFBvc3RncmVzdEVycm9yIHtcbiAgICAgICAgcmV0dXJuIGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgJ2NvZGUnIGluIGVycm9yICYmICdkZXRhaWxzJyBpbiBlcnJvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBhcHByb3ByaWF0ZSBub3RpZmljYXRpb24gYmFzZWQgb24gZXJyb3IgdHlwZVxuICAgICAqL1xuICAgIHByaXZhdGUgc2hvd0Vycm9yTm90aWZpY2F0aW9uKGVycm9yOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSAnQW4gZXJyb3Igb2NjdXJyZWQnO1xuICAgICAgICBsZXQgZHVyYXRpb24gPSA0MDAwO1xuXG4gICAgICAgIC8vIEhhbmRsZSBTdXBhYmFzZSBzcGVjaWZpYyBlcnJvcnNcbiAgICAgICAgaWYgKHRoaXMuaXNTdXBhYmFzZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnNDJQMDEnOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gJ0RhdGFiYXNlIHRhYmxlIG5vdCBmb3VuZC4gUGxlYXNlIHJ1biBzZXR1cCBTUUwuJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnNDI1MDEnOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gJ0luc3VmZmljaWVudCBkYXRhYmFzZSBwZXJtaXNzaW9ucy4nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcyMzUwNSc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAnRHVwbGljYXRlIGVudHJ5IGZvdW5kLic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0YWJhc2UgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHVyYXRpb24gPSA2MDAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBEb2N1bWVudCBQcm9jZXNzaW5nIEVycm9yc1xuICAgICAgICBlbHNlIGlmIChlcnJvci50eXBlID09PSBEb2N1bWVudFByb2Nlc3NpbmdFcnJvci5DSFVOS0lOR19FUlJPUikge1xuICAgICAgICAgICAgbWVzc2FnZSA9ICdFcnJvciBzcGxpdHRpbmcgZG9jdW1lbnQgaW50byBjaHVua3MnO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLkVNQkVERElOR19FUlJPUikge1xuICAgICAgICAgICAgbWVzc2FnZSA9ICdFcnJvciBnZW5lcmF0aW5nIGVtYmVkZGluZ3MnO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLkRBVEFCQVNFX0VSUk9SKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gJ0RhdGFiYXNlIG9wZXJhdGlvbiBmYWlsZWQnO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLklOVkFMSURfTUVUQURBVEEpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnSW52YWxpZCBkb2N1bWVudCBtZXRhZGF0YSc7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IuRklMRV9BQ0NFU1NfRVJST1IpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnRXJyb3IgYWNjZXNzaW5nIGZpbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLllBTUxfUEFSU0VfRVJST1IpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnRXJyb3IgcGFyc2luZyBZQU1MIGZyb250IG1hdHRlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IuVkVDVE9SX0VYVEVOU0lPTl9FUlJPUikge1xuICAgICAgICAgICAgbWVzc2FnZSA9ICdWZWN0b3IgZXh0ZW5zaW9uIG5vdCBhdmFpbGFibGUnO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLlNZTkNfRVJST1IpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnU3luYyBvcGVyYXRpb24gZmFpbGVkJztcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgVGFzayBQcm9jZXNzaW5nIEVycm9yc1xuICAgICAgICBlbHNlIGlmIChlcnJvci50eXBlID09PSBUYXNrUHJvY2Vzc2luZ0Vycm9yLlFVRVVFX0ZVTEwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnVGFzayBxdWV1ZSBpcyBmdWxsJztcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci50eXBlID09PSBUYXNrUHJvY2Vzc2luZ0Vycm9yLlRBU0tfVElNRU9VVCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9ICdUYXNrIHRpbWVkIG91dCc7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gVGFza1Byb2Nlc3NpbmdFcnJvci5UQVNLX0NBTkNFTExFRCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9ICdUYXNrIHdhcyBjYW5jZWxsZWQnO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IFRhc2tQcm9jZXNzaW5nRXJyb3IuTUFYX1JFVFJJRVNfRVhDRUVERUQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnTWF4aW11bSByZXRyeSBhdHRlbXB0cyBleGNlZWRlZCc7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gVGFza1Byb2Nlc3NpbmdFcnJvci5JTlZBTElEX1RBU0tfU1RBVEUpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnSW52YWxpZCB0YXNrIHN0YXRlJztcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci50eXBlID09PSBUYXNrUHJvY2Vzc2luZ0Vycm9yLlRBU0tfTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gJ1Rhc2sgbm90IGZvdW5kJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSBwcm92aWRlZCBtZXNzYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9OiAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ldyBOb3RpY2UobWVzc2FnZSwgZHVyYXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBlcnJvciBsb2cgdG8gZmlsZVxuICAgICAqL1xuICAgIHByaXZhdGUgd3JpdGVUb0xvZ0ZpbGUobG9nOiBFcnJvckxvZyk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMubG9nRmlsZVBhdGgpIHJldHVybjtcblxuICAgICAgICBjb25zdCBsb2dFbnRyeSA9IHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUobG9nLnRpbWVzdGFtcCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGxldmVsOiBsb2cubGV2ZWwudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgIGNvbnRleHQ6IGxvZy5jb250ZXh0LmNvbnRleHQsXG4gICAgICAgICAgICBlcnJvcjogbG9nLmVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGFjazogbG9nLmVycm9yLnN0YWNrLFxuICAgICAgICAgICAgbWV0YWRhdGE6IGxvZy5jb250ZXh0Lm1ldGFkYXRhXG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcD8udmF1bHQ/LmFkYXB0ZXI/LmFwcGVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ0ZpbGVQYXRoLFxuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShsb2dFbnRyeSkgKyAnXFxuJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gd3JpdGUgdG8gbG9nIGZpbGU6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBkZWJ1ZyBzZXR0aW5nc1xuICAgICAqL1xuICAgIHVwZGF0ZVNldHRpbmdzKHNldHRpbmdzOiBEZWJ1Z1NldHRpbmdzKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHJlY2VudCBlcnJvciBsb2dzXG4gICAgICovXG4gICAgZ2V0UmVjZW50TG9ncyhjb3VudDogbnVtYmVyID0gMTApOiBFcnJvckxvZ1tdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JMb2dzLnNsaWNlKDAsIGNvdW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgZXJyb3IgbG9nc1xuICAgICAqL1xuICAgIGNsZWFyTG9ncygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5lcnJvckxvZ3MgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGVycm9yIHN0YXRpc3RpY3NcbiAgICAgKi9cbiAgICBnZXRFcnJvclN0YXRzKCk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckxvZ3MucmVkdWNlKChhY2MsIGxvZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JUeXBlID0gbG9nLmVycm9yLm5hbWUgfHwgJ1Vua25vd24nO1xuICAgICAgICAgICAgYWNjW2Vycm9yVHlwZV0gPSAoYWNjW2Vycm9yVHlwZV0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPik7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IFRhc2tQcm9ncmVzcyB9IGZyb20gJy4uL21vZGVscy9Qcm9jZXNzaW5nVGFzayc7XG5cbmludGVyZmFjZSBQcm9ncmVzc0JhciB7XG4gICAgY29udGFpbmVyOiBIVE1MRWxlbWVudDtcbiAgICBmaWxsOiBIVE1MRWxlbWVudDtcbiAgICB0ZXh0OiBIVE1MRWxlbWVudDtcbiAgICBsYXN0VXBkYXRlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBOb3RpZmljYXRpb25NYW5hZ2VyIHtcbiAgICBwcml2YXRlIHByb2dyZXNzQmFyczogTWFwPHN0cmluZywgUHJvZ3Jlc3NCYXI+ID0gbmV3IE1hcCgpO1xuICAgIHByaXZhdGUgc3RhdHVzQmFySXRlbTogSFRNTEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSBlbmFibGVOb3RpZmljYXRpb25zOiBib29sZWFuO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZW5hYmxlUHJvZ3Jlc3NCYXI6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBub3RpZmljYXRpb25RdWV1ZTogc3RyaW5nW10gPSBbXTtcbiAgICBwcml2YXRlIGlzUHJvY2Vzc2luZ1F1ZXVlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgc3RhdHVzQmFyRWw6IEhUTUxFbGVtZW50LFxuICAgICAgICBlbmFibGVOb3RpZmljYXRpb25zOiBib29sZWFuLFxuICAgICAgICBlbmFibGVQcm9ncmVzc0JhcjogYm9vbGVhblxuICAgICkge1xuICAgICAgICB0aGlzLnN0YXR1c0Jhckl0ZW0gPSBzdGF0dXNCYXJFbDtcbiAgICAgICAgdGhpcy5lbmFibGVOb3RpZmljYXRpb25zID0gZW5hYmxlTm90aWZpY2F0aW9ucztcbiAgICAgICAgdGhpcy5lbmFibGVQcm9ncmVzc0JhciA9IGVuYWJsZVByb2dyZXNzQmFyO1xuXG4gICAgICAgIC8vIENyZWF0ZSBzdGF0dXMgYmFyIGNvbnRhaW5lclxuICAgICAgICB0aGlzLmluaXRpYWxpemVTdGF0dXNCYXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIG5vdGlmaWNhdGlvbiBtZXNzYWdlXG4gICAgICovXG4gICAgc2hvd05vdGlmaWNhdGlvbihtZXNzYWdlOiBzdHJpbmcsIGR1cmF0aW9uOiBudW1iZXIgPSA0MDAwKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVOb3RpZmljYXRpb25zKSByZXR1cm47XG5cbiAgICAgICAgLy8gUXVldWUgbm90aWZpY2F0aW9uXG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9uUXVldWUucHVzaChtZXNzYWdlKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NOb3RpZmljYXRpb25RdWV1ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBwcm9ncmVzcyBmb3IgYSB0YXNrXG4gICAgICovXG4gICAgdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3M6IFRhc2tQcm9ncmVzcyk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlUHJvZ3Jlc3NCYXIpIHJldHVybjtcblxuICAgICAgICBjb25zdCBwcm9ncmVzc0JhcklkID0gYHByb2dyZXNzLSR7cHJvZ3Jlc3MudGFza0lkfWA7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIHByb2dyZXNzIHBlcmNlbnRhZ2VcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NQZXJjZW50YWdlID0gTWF0aC5yb3VuZChwcm9ncmVzcy5wcm9ncmVzcyk7XG5cbiAgICAgICAgLy8gVXBkYXRlIG9yIGNyZWF0ZSBwcm9ncmVzcyBiYXJcbiAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzc0Jhcihwcm9ncmVzc0JhcklkLCB7XG4gICAgICAgICAgICBwcm9ncmVzczogcHJvZ3Jlc3NQZXJjZW50YWdlLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5mb3JtYXRQcm9ncmVzc01lc3NhZ2UocHJvZ3Jlc3MpLFxuICAgICAgICAgICAgdG90YWw6IHByb2dyZXNzLnRvdGFsU3RlcHMsXG4gICAgICAgICAgICBjdXJyZW50OiBwcm9ncmVzcy5jdXJyZW50U3RlcE51bWJlclxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTaG93IGFkZGl0aW9uYWwgZGV0YWlscyBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKHByb2dyZXNzLmRldGFpbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSB0aGlzLmZvcm1hdFByb2dyZXNzRGV0YWlscyhwcm9ncmVzcy5kZXRhaWxzKTtcbiAgICAgICAgICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93Tm90aWZpY2F0aW9uKGRldGFpbHMsIDIwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIGNvbXBsZXRlZCBwcm9ncmVzcyBiYXJzXG4gICAgICAgIGlmIChwcm9ncmVzc1BlcmNlbnRhZ2UgPj0gMTAwKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVByb2dyZXNzQmFyKHByb2dyZXNzQmFySWQpO1xuICAgICAgICAgICAgfSwgMjAwMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgc3RhdHVzIGJhclxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdGlhbGl6ZVN0YXR1c0JhcigpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRhaW5lci5hZGRDbGFzcygnbWluZC1tYXRyaXgtc3RhdHVzJyk7XG4gICAgICAgIHRoaXMuc3RhdHVzQmFySXRlbS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgb3IgY3JlYXRlcyBhIHByb2dyZXNzIGJhclxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlUHJvZ3Jlc3NCYXIoaWQ6IHN0cmluZywgb3B0aW9uczoge1xuICAgICAgICBwcm9ncmVzczogbnVtYmVyO1xuICAgICAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgICAgIHRvdGFsOiBudW1iZXI7XG4gICAgICAgIGN1cnJlbnQ6IG51bWJlcjtcbiAgICB9KTogdm9pZCB7XG4gICAgICAgIGxldCBwcm9ncmVzc0JhciA9IHRoaXMucHJvZ3Jlc3NCYXJzLmdldChpZCk7XG5cbiAgICAgICAgaWYgKCFwcm9ncmVzc0Jhcikge1xuICAgICAgICAgICAgcHJvZ3Jlc3NCYXIgPSB0aGlzLmNyZWF0ZVByb2dyZXNzQmFyKGlkKTtcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NCYXJzLnNldChpZCwgcHJvZ3Jlc3NCYXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHByb2dyZXNzIGJhciBlbGVtZW50c1xuICAgICAgICBwcm9ncmVzc0Jhci5maWxsLnN0eWxlLndpZHRoID0gYCR7b3B0aW9ucy5wcm9ncmVzc30lYDtcbiAgICAgICAgcHJvZ3Jlc3NCYXIudGV4dC50ZXh0Q29udGVudCA9IHRoaXMuZm9ybWF0UHJvZ3Jlc3NNZXNzYWdlKHtcbiAgICAgICAgICAgIHRhc2tJZDogaWQsXG4gICAgICAgICAgICBwcm9ncmVzczogb3B0aW9ucy5wcm9ncmVzcyxcbiAgICAgICAgICAgIGN1cnJlbnRTdGVwOiBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgICAgICB0b3RhbFN0ZXBzOiBvcHRpb25zLnRvdGFsLFxuICAgICAgICAgICAgY3VycmVudFN0ZXBOdW1iZXI6IG9wdGlvbnMuY3VycmVudFxuICAgICAgICB9KTtcblxuICAgICAgICBwcm9ncmVzc0Jhci5sYXN0VXBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHByb2dyZXNzIGJhclxuICAgICAqL1xuICAgIHByaXZhdGUgY3JlYXRlUHJvZ3Jlc3NCYXIoaWQ6IHN0cmluZyk6IFByb2dyZXNzQmFyIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRhaW5lci5hZGRDbGFzcygncHJvZ3Jlc3MtY29udGFpbmVyJyk7XG4gICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCBpZCk7XG5cbiAgICAgICAgY29uc3QgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGJhci5hZGRDbGFzcygncHJvZ3Jlc3MtYmFyJyk7XG5cbiAgICAgICAgY29uc3QgZmlsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBmaWxsLmFkZENsYXNzKCdwcm9ncmVzcy1maWxsJyk7XG5cbiAgICAgICAgY29uc3QgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0ZXh0LmFkZENsYXNzKCdwcm9ncmVzcy10ZXh0Jyk7XG5cbiAgICAgICAgYmFyLmFwcGVuZENoaWxkKGZpbGwpO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYmFyKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRleHQpO1xuICAgICAgICB0aGlzLnN0YXR1c0Jhckl0ZW0uYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgZmlsbCxcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICBsYXN0VXBkYXRlOiBEYXRlLm5vdygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHByb2dyZXNzIGJhclxuICAgICAqL1xuICAgIHByaXZhdGUgcmVtb3ZlUHJvZ3Jlc3NCYXIoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBwcm9ncmVzc0JhciA9IHRoaXMucHJvZ3Jlc3NCYXJzLmdldChpZCk7XG4gICAgICAgIGlmIChwcm9ncmVzc0Jhcikge1xuICAgICAgICAgICAgcHJvZ3Jlc3NCYXIuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmVzc0JhcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgcHJvZ3Jlc3MgbWVzc2FnZVxuICAgICAqL1xuICAgIHByaXZhdGUgZm9ybWF0UHJvZ3Jlc3NNZXNzYWdlKHByb2dyZXNzOiBUYXNrUHJvZ3Jlc3MpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7cHJvZ3Jlc3MuY3VycmVudFN0ZXB9ICgke3Byb2dyZXNzLmN1cnJlbnRTdGVwTnVtYmVyfS8ke3Byb2dyZXNzLnRvdGFsU3RlcHN9KWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBwcm9ncmVzcyBkZXRhaWxzXG4gICAgICovXG4gICAgcHJpdmF0ZSBmb3JtYXRQcm9ncmVzc0RldGFpbHMoZGV0YWlsczogVGFza1Byb2dyZXNzWydkZXRhaWxzJ10pOiBzdHJpbmcgfCBudWxsIHtcbiAgICAgICAgaWYgKCFkZXRhaWxzKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICBpZiAoZGV0YWlscy5wcm9jZXNzZWRDaHVua3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChgQ2h1bmtzOiAke2RldGFpbHMucHJvY2Vzc2VkQ2h1bmtzfS8ke2RldGFpbHMudG90YWxDaHVua3N9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRldGFpbHMucHJvY2Vzc2VkVG9rZW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goYFRva2VuczogJHtkZXRhaWxzLnByb2Nlc3NlZFRva2Vuc30vJHtkZXRhaWxzLnRvdGFsVG9rZW5zfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcgfCAnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgbm90aWZpY2F0aW9uIHF1ZXVlXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBwcm9jZXNzTm90aWZpY2F0aW9uUXVldWUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICh0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlIHx8IHRoaXMubm90aWZpY2F0aW9uUXVldWUubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5pc1Byb2Nlc3NpbmdRdWV1ZSA9IHRydWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLm5vdGlmaWNhdGlvblF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5ub3RpZmljYXRpb25RdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgYSBiaXQgYmV0d2VlbiBub3RpZmljYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIG5vdGlmaWNhdGlvbiBzZXR0aW5nc1xuICAgICAqL1xuICAgIHVwZGF0ZVNldHRpbmdzKGVuYWJsZU5vdGlmaWNhdGlvbnM6IGJvb2xlYW4sIGVuYWJsZVByb2dyZXNzQmFyOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZW5hYmxlTm90aWZpY2F0aW9ucyA9IGVuYWJsZU5vdGlmaWNhdGlvbnM7XG4gICAgICAgIHRoaXMuZW5hYmxlUHJvZ3Jlc3NCYXIgPSBlbmFibGVQcm9ncmVzc0JhcjtcblxuICAgICAgICAvLyBDbGVhciBwcm9ncmVzcyBiYXJzIGlmIGRpc2FibGVkXG4gICAgICAgIGlmICghZW5hYmxlUHJvZ3Jlc3NCYXIpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2lkXSBvZiB0aGlzLnByb2dyZXNzQmFycykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUHJvZ3Jlc3NCYXIoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBwcm9ncmVzcyBiYXJzXG4gICAgICovXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIGZvciAoY29uc3QgW2lkXSBvZiB0aGlzLnByb2dyZXNzQmFycykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVQcm9ncmVzc0JhcihpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25RdWV1ZSA9IFtdO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBBcHAsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBNaW5kTWF0cml4UGx1Z2luIGZyb20gJy4uL21haW4nO1xuaW1wb3J0IHtcblx0TWluZE1hdHJpeFNldHRpbmdzLFxuXHRnZW5lcmF0ZVZhdWx0SWQsXG5cdGlzVmF1bHRJbml0aWFsaXplZFxufSBmcm9tICcuL1NldHRpbmdzJztcblxuZXhwb3J0IGNsYXNzIE1pbmRNYXRyaXhTZXR0aW5nc1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuXHRwbHVnaW46IE1pbmRNYXRyaXhQbHVnaW47XG5cdHNldHRpbmdzOiBNaW5kTWF0cml4U2V0dGluZ3M7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogTWluZE1hdHJpeFBsdWdpbikge1xuXHRcdHN1cGVyKGFwcCwgcGx1Z2luKTtcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcblx0XHR0aGlzLnNldHRpbmdzID0gcGx1Z2luLnNldHRpbmdzO1xuXHR9XG5cblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHQvLyBWYXVsdCBJZGVudGlmaWNhdGlvbiBTZWN0aW9uXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnVmF1bHQgSWRlbnRpZmljYXRpb24nIH0pO1xuXG5cdFx0aWYgKGlzVmF1bHRJbml0aWFsaXplZCh0aGlzLnNldHRpbmdzKSkge1xuXHRcdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXROYW1lKCdWYXVsdCBJRCcpXG5cdFx0XHRcdC5zZXREZXNjKCdVbmlxdWUgaWRlbnRpZmllciB1c2VkIHRvIHRyYWNrIHRoaXMgdmF1bHQgaW4gdGhlIGRhdGFiYXNlLiBUaGlzIGVuc3VyZXMgeW91ciBub3RlcyBhcmUgY29ycmVjdGx5IHN5bmNocm9uaXplZC4nKVxuXHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy52YXVsdElkISlcblx0XHRcdFx0XHQuc2V0RGlzYWJsZWQodHJ1ZSlcblx0XHRcdFx0KTtcblxuXHRcdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXROYW1lKCdWYXVsdCBOYW1lJylcblx0XHRcdFx0LnNldERlc2MoJ1RoZSBjdXJyZW50IG5hbWUgb2YgeW91ciBPYnNpZGlhbiB2YXVsdCAoZGlzcGxheWVkIGZvciByZWZlcmVuY2UpLicpXG5cdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzLmxhc3RLbm93blZhdWx0TmFtZSlcblx0XHRcdFx0XHQuc2V0RGlzYWJsZWQodHJ1ZSlcblx0XHRcdFx0KTtcblxuXHRcdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXROYW1lKCdSZXNldCBWYXVsdCBJRCcpXG5cdFx0XHRcdC5zZXREZXNjKCdHZW5lcmF0ZXMgYSBuZXcgdmF1bHQgSUQuIFdhcm5pbmc6IFRoaXMgd2lsbCBkaXNjb25uZWN0IHRoZSB2YXVsdCBmcm9tIGl0cyBleGlzdGluZyBkYXRhYmFzZSBlbnRyaWVzIGFuZCByZXF1aXJlIGEgZnVsbCByZXN5bmMuJylcblx0XHRcdFx0LmFkZEJ1dHRvbihidG4gPT4gYnRuXG5cdFx0XHRcdFx0LnNldEJ1dHRvblRleHQoJ1Jlc2V0Jylcblx0XHRcdFx0XHQuc2V0V2FybmluZygpXG5cdFx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgY29uZmlybWVkID0gYXdhaXQgdGhpcy5zaG93UmVzZXRDb25maXJtYXRpb24oKTtcblx0XHRcdFx0XHRcdGlmIChjb25maXJtZWQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy52YXVsdElkID0gZ2VuZXJhdGVWYXVsdElkKCk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MubGFzdEtub3duVmF1bHROYW1lID0gdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpO1xuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnVmF1bHQgSUQgaGFzIGJlZW4gcmVzZXQuJyk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZGlzcGxheSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXROYW1lKCdJbml0aWFsaXplIFZhdWx0Jylcblx0XHRcdFx0LnNldERlc2MoJ0dlbmVyYXRlIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgdmF1bHQgdG8gYmVnaW4gc3luY2luZyB3aXRoIHRoZSBkYXRhYmFzZS4nKVxuXHRcdFx0XHQuYWRkQnV0dG9uKGJ0biA9PiBidG5cblx0XHRcdFx0XHQuc2V0QnV0dG9uVGV4dCgnSW5pdGlhbGl6ZScpXG5cdFx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy52YXVsdElkID0gZ2VuZXJhdGVWYXVsdElkKCk7XG5cdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmxhc3RLbm93blZhdWx0TmFtZSA9IHRoaXMuYXBwLnZhdWx0LmdldE5hbWUoKTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnVmF1bHQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuJyk7XG5cdFx0XHRcdFx0XHR0aGlzLmRpc3BsYXkoKTtcblx0XHRcdFx0XHR9KSk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwYWJhc2UgU2V0dGluZ3Ncblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdTdXBhYmFzZSBDb25maWd1cmF0aW9uJyB9KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ1N1cGFiYXNlIFVSTCcpXG5cdFx0XHQuc2V0RGVzYygnVGhlIFVSTCBmb3IgeW91ciBTdXBhYmFzZSBwcm9qZWN0LiBGaW5kIHRoaXMgaW4geW91ciBTdXBhYmFzZSBkYXNoYm9hcmQgdW5kZXIgUHJvamVjdCBTZXR0aW5ncyA+IEFQSSA+IFByb2plY3QgVVJMLiBTaG91bGQgbG9vayBsaWtlOiBodHRwczovL3h4eC5zdXBhYmFzZS5jbycpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKCdodHRwczovL3lvdXItcHJvamVjdC5zdXBhYmFzZS5jbycpXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzLnN1cGFiYXNlLnVybClcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3VwYWJhc2UudXJsID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnU3VwYWJhc2UgVVJMIHVwZGF0ZWQuJyk7XG5cdFx0XHRcdH0pKTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ1N1cGFiYXNlIEFQSSBLZXknKVxuXHRcdFx0LnNldERlc2MoJ1lvdXIgU3VwYWJhc2UgcHJvamVjdCBBUEkga2V5LiBGaW5kIHRoaXMgaW4gUHJvamVjdCBTZXR0aW5ncyA+IEFQSSA+IFByb2plY3QgQVBJIGtleXMuIFVzZSB0aGUgXCJzZXJ2aWNlX3JvbGVcIiBrZXkgZm9yIGZ1bGwgZGF0YWJhc2UgYWNjZXNzLiBLZWVwIHRoaXMga2V5IHNlY3VyZS4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRW50ZXIgeW91ciBBUEkga2V5Jylcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc2V0dGluZ3Muc3VwYWJhc2UuYXBpS2V5KVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5zdXBhYmFzZS5hcGlLZXkgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKCdTdXBhYmFzZSBBUEkga2V5IHVwZGF0ZWQuJyk7XG5cdFx0XHRcdH0pKTtcblxuXHRcdC8vIE9wZW5BSSBTZXR0aW5nc1xuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ09wZW5BSSBDb25maWd1cmF0aW9uJyB9KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ09wZW5BSSBBUEkgS2V5Jylcblx0XHRcdC5zZXREZXNjKCdZb3VyIE9wZW5BSSBBUEkga2V5IGZvciBnZW5lcmF0aW5nIGVtYmVkZGluZ3MuIENyZWF0ZSBvbmUgYXQgaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2FwaS1rZXlzLiBFc3RpbWF0ZWQgY29zdDogfiQwLjAwMDEgcGVyIHBhZ2UuIEtlZXAgdGhpcyBrZXkgc2VjdXJlLicpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKCdFbnRlciB5b3VyIEFQSSBrZXknKVxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5vcGVuYWkuYXBpS2V5KVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5vcGVuYWkuYXBpS2V5ID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnT3BlbkFJIEFQSSBrZXkgdXBkYXRlZC4nKTtcblx0XHRcdFx0fSkpO1xuXG5cdFx0Ly8gRG9jdW1lbnQgUHJvY2Vzc2luZyBTZXR0aW5nc1xuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0RvY3VtZW50IFByb2Nlc3NpbmcnIH0pO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnQ2h1bmsgU2l6ZScpXG5cdFx0XHQuc2V0RGVzYygnTWF4aW11bSBzaXplIG9mIHRleHQgY2h1bmtzIGluIGNoYXJhY3RlcnMuIExhcmdlciBjaHVua3MgcHJvdmlkZSBtb3JlIGNvbnRleHQgYnV0IGNvc3QgbW9yZSB0b2tlbnMuIFJlY29tbWVuZGVkOiAxMDAwLTE1MDAgY2hhcmFjdGVycyBmb3Igb3B0aW1hbCBzZW1hbnRpYyBzZWFyY2ggcmVzdWx0cy4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRWYWx1ZShTdHJpbmcodGhpcy5zZXR0aW5ncy5jaHVua2luZy5jaHVua1NpemUpKVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgbnVtVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHRcdFx0XHRcdGlmICghaXNOYU4obnVtVmFsdWUpICYmIG51bVZhbHVlID4gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jaHVua2luZy5jaHVua1NpemUgPSBudW1WYWx1ZTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnQ2h1bmsgc2l6ZSB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkpO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnQ2h1bmsgT3ZlcmxhcCcpXG5cdFx0XHQuc2V0RGVzYygnTnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gb3ZlcmxhcCBiZXR3ZWVuIGNodW5rcy4gSGVscHMgbWFpbnRhaW4gY29udGV4dCBhY3Jvc3MgY2h1bmsgYm91bmRhcmllcy4gUmVjb21tZW5kZWQ6IDEwLTIwJSBvZiBjaHVuayBzaXplICgxMDAtMjAwIGNoYXJhY3RlcnMgZm9yIGRlZmF1bHQgc2V0dGluZ3MpLicpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0LnNldFZhbHVlKFN0cmluZyh0aGlzLnNldHRpbmdzLmNodW5raW5nLmNodW5rT3ZlcmxhcCkpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRjb25zdCBudW1WYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cdFx0XHRcdFx0aWYgKCFpc05hTihudW1WYWx1ZSkgJiYgbnVtVmFsdWUgPj0gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jaHVua2luZy5jaHVua092ZXJsYXAgPSBudW1WYWx1ZTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnQ2h1bmsgb3ZlcmxhcCB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkpO1xuXG5cdFx0Ly8gRXhjbHVzaW9uIFNldHRpbmdzXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnRXhjbHVzaW9ucycgfSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdFeGNsdWRlZCBGb2xkZXJzJylcblx0XHRcdC5zZXREZXNjKCdGb2xkZXJzIHRvIGV4Y2x1ZGUgZnJvbSBzeW5jaW5nLiBDb21tb24gZXhhbXBsZXM6IC5naXQsIC5vYnNpZGlhbiwgbm9kZV9tb2R1bGVzLCBhdHRhY2htZW50cy4gU2VwYXJhdGUgbXVsdGlwbGUgZm9sZGVycyB3aXRoIGNvbW1hcy4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuZXhjbHVkZWRGb2xkZXJzLmpvaW4oJywgJykpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuZXhjbHVkZWRGb2xkZXJzID0gdmFsdWUuc3BsaXQoJywnKS5tYXAocyA9PiBzLnRyaW0oKSkuZmlsdGVyKHMgPT4gcyk7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnRXhjbHVkZWQgZm9sZGVycyB1cGRhdGVkLicpO1xuXHRcdFx0XHR9KSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdFeGNsdWRlZCBGaWxlIFR5cGVzJylcblx0XHRcdC5zZXREZXNjKCdGaWxlIGV4dGVuc2lvbnMgdG8gZXhjbHVkZSBmcm9tIHN5bmNpbmcgKGUuZy4sIC5tcDMsIC5qcGcsIC5wbmcpLiBJbmNsdWRlIHRoZSBkb3QgcHJlZml4LiBPbmx5IG1hcmtkb3duIGZpbGVzIGFyZSByZWNvbW1lbmRlZCBmb3IgZW1iZWRkaW5nLicpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcy5qb2luKCcsICcpKVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVR5cGVzID0gdmFsdWUuc3BsaXQoJywnKS5tYXAocyA9PiBzLnRyaW0oKSkuZmlsdGVyKHMgPT4gcyk7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnRXhjbHVkZWQgZmlsZSB0eXBlcyB1cGRhdGVkLicpO1xuXHRcdFx0XHR9KSk7XG5cblx0XHQvLyBRdWV1ZSBTZXR0aW5nc1xuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1Byb2Nlc3NpbmcgUXVldWUnIH0pO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnQ29uY3VycmVudCBUYXNrcycpXG5cdFx0XHQuc2V0RGVzYygnTWF4aW11bSBudW1iZXIgb2YgdGFza3MgdG8gcHJvY2VzcyBzaW11bHRhbmVvdXNseS4gSGlnaGVyIHZhbHVlcyBtYXkgaW1wcm92ZSBzcGVlZCBidXQgaW5jcmVhc2UgQVBJIHVzYWdlLiBEZWZhdWx0OiAzJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHQuc2V0VmFsdWUoU3RyaW5nKHRoaXMuc2V0dGluZ3MucXVldWUubWF4Q29uY3VycmVudCkpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRjb25zdCBudW1WYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cdFx0XHRcdFx0aWYgKCFpc05hTihudW1WYWx1ZSkgJiYgbnVtVmFsdWUgPiAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLnF1ZXVlLm1heENvbmN1cnJlbnQgPSBudW1WYWx1ZTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnQ29uY3VycmVudCB0YXNrcyBsaW1pdCB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkpO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnUmV0cnkgQXR0ZW1wdHMnKVxuXHRcdFx0LnNldERlc2MoJ051bWJlciBvZiB0aW1lcyB0byByZXRyeSBmYWlsZWQgb3BlcmF0aW9ucyBiZWZvcmUgZ2l2aW5nIHVwLiBIZWxwcyBoYW5kbGUgdGVtcG9yYXJ5IEFQSSBvciBuZXR3b3JrIGlzc3Vlcy4gRGVmYXVsdDogMycpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0LnNldFZhbHVlKFN0cmluZyh0aGlzLnNldHRpbmdzLnF1ZXVlLnJldHJ5QXR0ZW1wdHMpKVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgbnVtVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHRcdFx0XHRcdGlmICghaXNOYU4obnVtVmFsdWUpICYmIG51bVZhbHVlID49IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MucXVldWUucmV0cnlBdHRlbXB0cyA9IG51bVZhbHVlO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdSZXRyeSBhdHRlbXB0cyB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkpO1xuXG5cdFx0Ly8gRmVhdHVyZSBGbGFnc1xuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0ZlYXR1cmVzJyB9KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0F1dG8gU3luYycpXG5cdFx0XHQuc2V0RGVzYygnQXV0b21hdGljYWxseSBzeW5jIGNoYW5nZXMgdG8gdGhlIGRhdGFiYXNlIHdoZW4gZmlsZXMgYXJlIGNyZWF0ZWQsIG1vZGlmaWVkLCBvciBkZWxldGVkLiBEaXNhYmxlIHRoaXMgaWYgeW91IHByZWZlciB0byBtYW51YWxseSBjb250cm9sIHdoZW4gZmlsZXMgYXJlIHN5bmNlZC4nKVxuXHRcdFx0LmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzLmVuYWJsZUF1dG9TeW5jKVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5lbmFibGVBdXRvU3luYyA9IHZhbHVlO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0F1dG8gc3luYyB1cGRhdGVkLicpO1xuXHRcdFx0XHR9KSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdTaG93IE5vdGlmaWNhdGlvbnMnKVxuXHRcdFx0LnNldERlc2MoJ0Rpc3BsYXkgbm90aWZpY2F0aW9ucyBmb3Igc3luYyBldmVudHMsIGVycm9ycywgYW5kIGltcG9ydGFudCB1cGRhdGVzLiBIZWxwcyB0cmFjayB0aGUgc3RhdHVzIG9mIGJhY2tncm91bmQgb3BlcmF0aW9ucy4nKVxuXHRcdFx0LmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKCdOb3RpZmljYXRpb24gc2V0dGluZ3MgdXBkYXRlZC4nKTtcblx0XHRcdFx0fSkpO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnU2hvdyBQcm9ncmVzcyBCYXInKVxuXHRcdFx0LnNldERlc2MoJ0Rpc3BsYXkgYSBwcm9ncmVzcyBiYXIgaW4gdGhlIHN0YXR1cyBiYXIgZHVyaW5nIHN5bmMgb3BlcmF0aW9ucy4gVXNlZnVsIGZvciBtb25pdG9yaW5nIGxvbmctcnVubmluZyB0YXNrcyBhbmQgbGFyZ2UgdmF1bHQgc3luY2hyb25pemF0aW9ucy4nKVxuXHRcdFx0LmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzLmVuYWJsZVByb2dyZXNzQmFyKVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5lbmFibGVQcm9ncmVzc0JhciA9IHZhbHVlO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1Byb2dyZXNzIGJhciBzZXR0aW5nIHVwZGF0ZWQuJyk7XG5cdFx0XHRcdH0pKTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ1Rlc3QgRGF0YWJhc2UgQ29ubmVjdGlvbicpXG5cdFx0XHQuc2V0RGVzYygnQ2xpY2sgdG8gdGVzdCB0aGUgY29ubmVjdGlvbiB0byB0aGUgU3VwYWJhc2UgZGF0YWJhc2UuJylcblx0XHRcdC5hZGRCdXR0b24oYnRuID0+IGJ0blxuXHRcdFx0XHQuc2V0QnV0dG9uVGV4dCgnVGVzdCBDb25uZWN0aW9uJylcblx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdGlmICh0aGlzLnBsdWdpbi5zdXBhYmFzZVNlcnZpY2UpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGlzQ29ubmVjdGVkID0gYXdhaXQgdGhpcy5wbHVnaW4uc3VwYWJhc2VTZXJ2aWNlLnRlc3RDb25uZWN0aW9uKCk7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGlzQ29ubmVjdGVkID8gJ0RhdGFiYXNlIGNvbm5lY3Rpb24gc3VjY2Vzc2Z1bCEnIDogJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkLicpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdTdXBhYmFzZSBzZXJ2aWNlIG5vdCBpbml0aWFsaXplZC4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0V4Y2x1ZGVkIEZpbGVzJylcblx0XHRcdC5zZXREZXNjKCdTcGVjaWZpYyBmaWxlcyB0byBleGNsdWRlIGZyb20gc3luY2luZyAoZS5nLiwgX21pbmRtYXRyaXhzeW5jLm1kKS4gU2VwYXJhdGUgbXVsdGlwbGUgZmlsZXMgd2l0aCBjb21tYXMuJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMuam9pbignLCAnKSlcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVzID0gdmFsdWVcblx0XHRcdFx0XHRcdC5zcGxpdCgnLCcpXG5cdFx0XHRcdFx0XHQubWFwKHMgPT4gcy50cmltKCkpXG5cdFx0XHRcdFx0XHQuZmlsdGVyKHMgPT4gcyk7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnRXhjbHVkZWQgZmlsZXMgdXBkYXRlZC4nKTtcblx0XHRcdFx0fSkpO1xuXG5cdFx0Ly8gRGVidWcgU2V0dGluZ3Ncblx0XHRpZiAodGhpcy5zZXR0aW5ncy5kZWJ1Zy5lbmFibGVEZWJ1Z0xvZ3MpIHtcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0RlYnVnIFNldHRpbmdzJyB9KTtcblxuXHRcdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXROYW1lKCdMb2cgTGV2ZWwnKVxuXHRcdFx0XHQuc2V0RGVzYygnTGV2ZWwgb2YgZGV0YWlsIGZvciBkZWJ1ZyBsb2dnaW5nLiBIaWdoZXIgbGV2ZWxzIGluY2x1ZGUgbW9yZSBpbmZvcm1hdGlvbi4nKVxuXHRcdFx0XHQuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cblx0XHRcdFx0XHQuYWRkT3B0aW9uKCdlcnJvcicsICdFcnJvcicpXG5cdFx0XHRcdFx0LmFkZE9wdGlvbignd2FybicsICdXYXJuaW5nJylcblx0XHRcdFx0XHQuYWRkT3B0aW9uKCdpbmZvJywgJ0luZm8nKVxuXHRcdFx0XHRcdC5hZGRPcHRpb24oJ2RlYnVnJywgJ0RlYnVnJylcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5kZWJ1Zy5sb2dMZXZlbClcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmRlYnVnLmxvZ0xldmVsID0gdmFsdWUgYXMgJ2Vycm9yJyB8ICd3YXJuJyB8ICdpbmZvJyB8ICdkZWJ1Zyc7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0xvZyBsZXZlbCB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH0pKTtcblxuXHRcdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXROYW1lKCdMb2cgdG8gRmlsZScpXG5cdFx0XHRcdC5zZXREZXNjKCdTYXZlIGRlYnVnIGxvZ3MgdG8gYSBmaWxlIGluIHlvdXIgLm9ic2lkaWFuIGZvbGRlci4nKVxuXHRcdFx0XHQuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5kZWJ1Zy5sb2dUb0ZpbGUpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5kZWJ1Zy5sb2dUb0ZpbGUgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnTG9nIHRvIGZpbGUgc2V0dGluZyB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH0pKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIHNob3dSZXNldENvbmZpcm1hdGlvbigpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcblx0XHRcdGNvbnN0IG1vZGFsID0gdGhpcy5hcHAubW9kYWw7XG5cdFx0XHRtb2RhbC5vcGVuKChtb2RhbCkgPT4ge1xuXHRcdFx0XHRtb2RhbC50aXRsZUVsLnNldFRleHQoJ1Jlc2V0IFZhdWx0IElEJyk7XG5cdFx0XHRcdG1vZGFsLmNvbnRlbnRFbC5zZXRUZXh0KFxuXHRcdFx0XHRcdCdXYXJuaW5nOiBSZXNldHRpbmcgdGhlIHZhdWx0IElEIHdpbGwgZGlzY29ubmVjdCB0aGlzIHZhdWx0IGZyb20gaXRzIGV4aXN0aW5nIGRhdGFiYXNlIGVudHJpZXMuICcgK1xuXHRcdFx0XHRcdCdUaGlzIG9wZXJhdGlvbiBjYW5ub3QgYmUgdW5kb25lLiBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gY29udGludWU/J1xuXHRcdFx0XHQpO1xuXHRcdFx0XHRtb2RhbC5hZGRCdXR0b24oKGJ0bikgPT4ge1xuXHRcdFx0XHRcdGJ0bi5zZXRCdXR0b25UZXh0KCdDYW5jZWwnKS5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHRcdHJlc29sdmUoZmFsc2UpO1xuXHRcdFx0XHRcdFx0bW9kYWwuY2xvc2UoKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdG1vZGFsLmFkZEJ1dHRvbigoYnRuKSA9PiB7XG5cdFx0XHRcdFx0YnRuXG5cdFx0XHRcdFx0XHQuc2V0QnV0dG9uVGV4dCgnUmVzZXQnKVxuXHRcdFx0XHRcdFx0LnNldFdhcm5pbmcoKVxuXHRcdFx0XHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKHRydWUpO1xuXHRcdFx0XHRcdFx0XHRtb2RhbC5jbG9zZSgpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cbn1cbiIsICIvLyBzcmMvc2VydmljZXMvSW5pdGlhbFN5bmNNYW5hZ2VyLnRzXG5cbmltcG9ydCB7IFRGaWxlLCBWYXVsdCwgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgRXJyb3JIYW5kbGVyIH0gZnJvbSAnLi4vdXRpbHMvRXJyb3JIYW5kbGVyJztcbmltcG9ydCB7IE5vdGlmaWNhdGlvbk1hbmFnZXIgfSBmcm9tICcuLi91dGlscy9Ob3RpZmljYXRpb25NYW5hZ2VyJztcbmltcG9ydCB7IFF1ZXVlU2VydmljZSB9IGZyb20gJy4vUXVldWVTZXJ2aWNlJztcbmltcG9ydCB7IFN5bmNGaWxlTWFuYWdlciB9IGZyb20gJy4vU3luY0ZpbGVNYW5hZ2VyJztcbmltcG9ydCB7IE1ldGFkYXRhRXh0cmFjdG9yIH0gZnJvbSAnLi9NZXRhZGF0YUV4dHJhY3Rvcic7XG5pbXBvcnQgeyBEb2N1bWVudE1ldGFkYXRhIH0gZnJvbSAnLi4vbW9kZWxzL0RvY3VtZW50Q2h1bmsnO1xuXG5pbnRlcmZhY2UgSW5pdGlhbFN5bmNPcHRpb25zIHtcblx0YmF0Y2hTaXplOiBudW1iZXI7XG5cdG1heENvbmN1cnJlbnRCYXRjaGVzOiBudW1iZXI7XG5cdGVuYWJsZUF1dG9Jbml0aWFsU3luYzogYm9vbGVhbjtcblx0cHJpb3JpdHlSdWxlczogUHJpb3JpdHlSdWxlW107XG59XG5cbmludGVyZmFjZSBQcmlvcml0eVJ1bGUge1xuXHRwYXR0ZXJuOiBzdHJpbmc7XG5cdHByaW9yaXR5OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBTeW5jQmF0Y2gge1xuXHRpZDogc3RyaW5nO1xuXHRmaWxlczogVEZpbGVbXTtcblx0c3RhdHVzOiAncGVuZGluZycgfCAncHJvY2Vzc2luZycgfCAnY29tcGxldGVkJyB8ICdmYWlsZWQnO1xuXHRwcm9ncmVzczogbnVtYmVyO1xuXHRzdGFydFRpbWU/OiBudW1iZXI7XG5cdGVuZFRpbWU/OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBTeW5jUHJvZ3Jlc3Mge1xuXHR0b3RhbEZpbGVzOiBudW1iZXI7XG5cdHByb2Nlc3NlZEZpbGVzOiBudW1iZXI7XG5cdGN1cnJlbnRCYXRjaDogbnVtYmVyO1xuXHR0b3RhbEJhdGNoZXM6IG51bWJlcjtcblx0c3RhcnRUaW1lOiBudW1iZXI7XG5cdGVzdGltYXRlZFRpbWVSZW1haW5pbmc/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBJbml0aWFsU3luY01hbmFnZXIge1xuXHRwcml2YXRlIGJhdGNoZXM6IE1hcDxzdHJpbmcsIFN5bmNCYXRjaD4gPSBuZXcgTWFwKCk7XG5cdHByaXZhdGUgcHJvZ3Jlc3M6IFN5bmNQcm9ncmVzcztcblx0cHJpdmF0ZSBpc1J1bm5pbmc6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHJpdmF0ZSBwcm9jZXNzaW5nVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBJbml0aWFsU3luY09wdGlvbnM7XG5cblx0Y29uc3RydWN0b3IoXG5cdFx0cHJpdmF0ZSB2YXVsdDogVmF1bHQsXG5cdFx0cHJpdmF0ZSBxdWV1ZVNlcnZpY2U6IFF1ZXVlU2VydmljZSxcblx0XHRwcml2YXRlIHN5bmNGaWxlTWFuYWdlcjogU3luY0ZpbGVNYW5hZ2VyLFxuXHRcdHByaXZhdGUgbWV0YWRhdGFFeHRyYWN0b3I6IE1ldGFkYXRhRXh0cmFjdG9yLFxuXHRcdHByaXZhdGUgZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXIsXG5cdFx0cHJpdmF0ZSBub3RpZmljYXRpb25NYW5hZ2VyOiBOb3RpZmljYXRpb25NYW5hZ2VyLFxuXHRcdG9wdGlvbnM6IFBhcnRpYWw8SW5pdGlhbFN5bmNPcHRpb25zPiA9IHt9XG5cdCkge1xuXHRcdC8vIFNldCBkZWZhdWx0IG9wdGlvbnNcblx0XHR0aGlzLm9wdGlvbnMgPSB7XG5cdFx0XHRiYXRjaFNpemU6IDUwLFxuXHRcdFx0bWF4Q29uY3VycmVudEJhdGNoZXM6IDMsXG5cdFx0XHRlbmFibGVBdXRvSW5pdGlhbFN5bmM6IHRydWUsXG5cdFx0XHRwcmlvcml0eVJ1bGVzOiBbXSxcblx0XHRcdC4uLm9wdGlvbnNcblx0XHR9O1xuXG5cdFx0dGhpcy5wcm9ncmVzcyA9IHtcblx0XHRcdHRvdGFsRmlsZXM6IDAsXG5cdFx0XHRwcm9jZXNzZWRGaWxlczogMCxcblx0XHRcdGN1cnJlbnRCYXRjaDogMCxcblx0XHRcdHRvdGFsQmF0Y2hlczogMCxcblx0XHRcdHN0YXJ0VGltZTogMFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogU3RhcnQgdGhlIGluaXRpYWwgc3luYyBwcm9jZXNzXG5cdCAqL1xuXHRhc3luYyBzdGFydFN5bmMoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKHRoaXMuaXNSdW5uaW5nKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnSW5pdGlhbCBzeW5jIGFscmVhZHkgcnVubmluZycpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLmlzUnVubmluZyA9IHRydWU7XG5cdFx0XHR0aGlzLnByb2dyZXNzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cblx0XHRcdC8vIEdldCBhbGwgbWFya2Rvd24gZmlsZXNcblx0XHRcdGNvbnN0IGZpbGVzID0gdGhpcy52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG5cdFx0XHR0aGlzLnByb2dyZXNzLnRvdGFsRmlsZXMgPSBmaWxlcy5sZW5ndGg7XG5cblx0XHRcdC8vIENyZWF0ZSBiYXRjaGVzXG5cdFx0XHRjb25zdCBzb3J0ZWRGaWxlcyA9IGF3YWl0IHRoaXMuc29ydEZpbGVzQnlQcmlvcml0eShmaWxlcyk7XG5cdFx0XHRjb25zdCBiYXRjaGVzID0gdGhpcy5jcmVhdGVCYXRjaGVzKHNvcnRlZEZpbGVzKTtcblx0XHRcdHRoaXMucHJvZ3Jlc3MudG90YWxCYXRjaGVzID0gYmF0Y2hlcy5sZW5ndGg7XG5cblx0XHRcdC8vIEluaXRpYWxpemUgYmF0Y2hlc1xuXHRcdFx0YmF0Y2hlcy5mb3JFYWNoKChiYXRjaCwgaW5kZXgpID0+IHtcblx0XHRcdFx0dGhpcy5iYXRjaGVzLnNldChiYXRjaC5pZCwge1xuXHRcdFx0XHRcdC4uLmJhdGNoLFxuXHRcdFx0XHRcdHN0YXR1czogJ3BlbmRpbmcnLFxuXHRcdFx0XHRcdHByb2dyZXNzOiAwXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIFN0YXJ0IHByb2Nlc3NpbmcgYmF0Y2hlc1xuXHRcdFx0YXdhaXQgdGhpcy5wcm9jZXNzQmF0Y2hlcygpO1xuXG5cdFx0XHRuZXcgTm90aWNlKCdJbml0aWFsIHN5bmMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseScpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0XHRjb250ZXh0OiAnSW5pdGlhbFN5bmNNYW5hZ2VyLnN0YXJ0U3luYydcblx0XHRcdH0pO1xuXHRcdFx0bmV3IE5vdGljZSgnSW5pdGlhbCBzeW5jIGZhaWxlZC4gQ2hlY2sgY29uc29sZSBmb3IgZGV0YWlscy4nKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU29ydCBmaWxlcyBieSBwcmlvcml0eSBiYXNlZCBvbiBydWxlc1xuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBzb3J0RmlsZXNCeVByaW9yaXR5KGZpbGVzOiBURmlsZVtdKTogUHJvbWlzZTxURmlsZVtdPiB7XG5cdFx0cmV0dXJuIGZpbGVzLnNvcnQoKGEsIGIpID0+IHtcblx0XHRcdGNvbnN0IHByaW9yaXR5QSA9IHRoaXMuZ2V0RmlsZVByaW9yaXR5KGEucGF0aCk7XG5cdFx0XHRjb25zdCBwcmlvcml0eUIgPSB0aGlzLmdldEZpbGVQcmlvcml0eShiLnBhdGgpO1xuXHRcdFx0cmV0dXJuIHByaW9yaXR5QiAtIHByaW9yaXR5QTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgcHJpb3JpdHkgZm9yIGEgZmlsZSBiYXNlZCBvbiBydWxlc1xuXHQgKi9cblx0cHJpdmF0ZSBnZXRGaWxlUHJpb3JpdHkocGF0aDogc3RyaW5nKTogbnVtYmVyIHtcblx0XHRmb3IgKGNvbnN0IHJ1bGUgb2YgdGhpcy5vcHRpb25zLnByaW9yaXR5UnVsZXMpIHtcblx0XHRcdGlmIChwYXRoLmluY2x1ZGVzKHJ1bGUucGF0dGVybikpIHtcblx0XHRcdFx0cmV0dXJuIHJ1bGUucHJpb3JpdHk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAxOyAvLyBEZWZhdWx0IHByaW9yaXR5XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIGJhdGNoZXMgb2YgZmlsZXMgZm9yIHByb2Nlc3Npbmdcblx0ICovXG5cdHByaXZhdGUgY3JlYXRlQmF0Y2hlcyhmaWxlczogVEZpbGVbXSk6IFN5bmNCYXRjaFtdIHtcblx0XHRjb25zdCBiYXRjaGVzOiBTeW5jQmF0Y2hbXSA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpICs9IHRoaXMub3B0aW9ucy5iYXRjaFNpemUpIHtcblx0XHRcdGNvbnN0IGJhdGNoRmlsZXMgPSBmaWxlcy5zbGljZShpLCBpICsgdGhpcy5vcHRpb25zLmJhdGNoU2l6ZSk7XG5cdFx0XHRiYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRpZDogYGJhdGNoLSR7TWF0aC5mbG9vcihpIC8gdGhpcy5vcHRpb25zLmJhdGNoU2l6ZSl9YCxcblx0XHRcdFx0ZmlsZXM6IGJhdGNoRmlsZXMsXG5cdFx0XHRcdHN0YXR1czogJ3BlbmRpbmcnLFxuXHRcdFx0XHRwcm9ncmVzczogMFxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBiYXRjaGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgYmF0Y2hlcyBvZiBmaWxlc1xuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBwcm9jZXNzQmF0Y2hlcygpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBhY3RpdmVCYXRjaGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cblx0XHQvLyBQcm9jZXNzIGJhdGNoZXMgdW50aWwgYWxsIGFyZSBjb21wbGV0ZVxuXHRcdHdoaWxlICh0aGlzLmhhc1VucHJvY2Vzc2VkQmF0Y2hlcygpICYmIHRoaXMuaXNSdW5uaW5nKSB7XG5cdFx0XHQvLyBHZXQgbmV4dCBiYXRjaCBpZiB3ZSBoYXZlIGNhcGFjaXR5XG5cdFx0XHRpZiAoYWN0aXZlQmF0Y2hlcy5zaXplIDwgdGhpcy5vcHRpb25zLm1heENvbmN1cnJlbnRCYXRjaGVzKSB7XG5cdFx0XHRcdGNvbnN0IG5leHRCYXRjaCA9IHRoaXMuZ2V0TmV4dFBlbmRpbmdCYXRjaCgpO1xuXHRcdFx0XHRpZiAobmV4dEJhdGNoKSB7XG5cdFx0XHRcdFx0YWN0aXZlQmF0Y2hlcy5hZGQobmV4dEJhdGNoLmlkKTtcblx0XHRcdFx0XHR0aGlzLnByb2Nlc3NCYXRjaChuZXh0QmF0Y2gpXG5cdFx0XHRcdFx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGFjdGl2ZUJhdGNoZXMuZGVsZXRlKG5leHRCYXRjaC5pZCk7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LmNhdGNoKChlcnJvcikgPT4ge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRleHQ6ICdJbml0aWFsU3luY01hbmFnZXIucHJvY2Vzc0JhdGNoJyxcblx0XHRcdFx0XHRcdFx0XHRtZXRhZGF0YTogeyBiYXRjaElkOiBuZXh0QmF0Y2guaWQgfVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0YWN0aXZlQmF0Y2hlcy5kZWxldGUobmV4dEJhdGNoLmlkKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdhaXQgYmVmb3JlIGNoZWNraW5nIGFnYWluXG5cdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgYSBzaW5nbGUgYmF0Y2ggb2YgZmlsZXNcblx0ICovXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc0JhdGNoKGJhdGNoOiBTeW5jQmF0Y2gpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0cnkge1xuXHRcdFx0YmF0Y2guc3RhdHVzID0gJ3Byb2Nlc3NpbmcnO1xuXHRcdFx0YmF0Y2guc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuXHRcdFx0Zm9yIChjb25zdCBmaWxlIG9mIGJhdGNoLmZpbGVzKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wcm9jZXNzRmlsZShmaWxlKTtcblx0XHRcdFx0XHR0aGlzLnByb2dyZXNzLnByb2Nlc3NlZEZpbGVzKys7XG5cdFx0XHRcdFx0YmF0Y2gucHJvZ3Jlc3MgPSAodGhpcy5wcm9ncmVzcy5wcm9jZXNzZWRGaWxlcyAvIHRoaXMucHJvZ3Jlc3MudG90YWxGaWxlcykgKiAxMDA7XG5cblx0XHRcdFx0XHQvLyBVcGRhdGUgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXG5cdFx0XHRcdFx0dGhpcy51cGRhdGVQcm9ncmVzc05vdGlmaWNhdGlvbigpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7XG5cdFx0XHRcdFx0XHRjb250ZXh0OiAnSW5pdGlhbFN5bmNNYW5hZ2VyLnByb2Nlc3NGaWxlJyxcblx0XHRcdFx0XHRcdG1ldGFkYXRhOiB7IGZpbGVQYXRoOiBmaWxlLnBhdGggfVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGJhdGNoLnN0YXR1cyA9ICdjb21wbGV0ZWQnO1xuXHRcdFx0YmF0Y2guZW5kVGltZSA9IERhdGUubm93KCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGJhdGNoLnN0YXR1cyA9ICdmYWlsZWQnO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgYSBzaW5nbGUgZmlsZVxuXHQgKi9cblx0Ly8gSW4gSW5pdGlhbFN5bmNNYW5hZ2VyLnRzLCBtb2RpZnkgdGhlIHByb2Nlc3NGaWxlIG1ldGhvZDpcblx0cHJpdmF0ZSBhc3luYyBwcm9jZXNzRmlsZShmaWxlOiBURmlsZSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBFeHRyYWN0IG1ldGFkYXRhXG5cdFx0XHRjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMubWV0YWRhdGFFeHRyYWN0b3IuZXh0cmFjdE1ldGFkYXRhKGZpbGUpO1xuXG5cdFx0XHQvLyBDcmVhdGUgb3IgdXBkYXRlIGZyb250bWF0dGVyXG5cdFx0XHRhd2FpdCB0aGlzLnVwZGF0ZUZyb250bWF0dGVyKGZpbGUsIG1ldGFkYXRhKTtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIGZpbGUgaGFzaCBvbmNlXG5cdFx0XHRjb25zdCBmaWxlSGFzaCA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlRmlsZUhhc2goZmlsZSk7XG5cblx0XHRcdC8vIFVwZGF0ZSBpbml0aWFsIHN5bmMgc3RhdHVzXG5cdFx0XHRhd2FpdCB0aGlzLnN5bmNGaWxlTWFuYWdlci51cGRhdGVTeW5jU3RhdHVzKGZpbGUucGF0aCwgJ1BFTkRJTkcnLCB7XG5cdFx0XHRcdGxhc3RNb2RpZmllZDogZmlsZS5zdGF0Lm10aW1lLFxuXHRcdFx0XHRoYXNoOiBmaWxlSGFzaFxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIFF1ZXVlIGZpbGUgZm9yIHByb2Nlc3NpbmcgYW5kIHdhaXQgZm9yIGNvbXBsZXRpb25cblx0XHRcdGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdFx0dGhpcy5xdWV1ZVNlcnZpY2UuYWRkVGFzayh7XG5cdFx0XHRcdFx0aWQ6IGZpbGUucGF0aCxcblx0XHRcdFx0XHR0eXBlOiAnQ1JFQVRFJyxcblx0XHRcdFx0XHRwcmlvcml0eTogdGhpcy5nZXRGaWxlUHJpb3JpdHkoZmlsZS5wYXRoKSxcblx0XHRcdFx0XHRtYXhSZXRyaWVzOiAzLFxuXHRcdFx0XHRcdHJldHJ5Q291bnQ6IDAsXG5cdFx0XHRcdFx0Y3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuXHRcdFx0XHRcdHVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcblx0XHRcdFx0XHRzdGF0dXM6ICdQRU5ESU5HJyxcblx0XHRcdFx0XHRtZXRhZGF0YSxcblx0XHRcdFx0XHRkYXRhOiB7fVxuXHRcdFx0XHR9KS50aGVuKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHQvLyBVcGRhdGUgc3luYyBzdGF0dXMgdG8gT0sgYWZ0ZXIgc3VjY2Vzc2Z1bCBwcm9jZXNzaW5nXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5zeW5jRmlsZU1hbmFnZXIudXBkYXRlU3luY1N0YXR1cyhmaWxlLnBhdGgsICdPSycsIHtcblx0XHRcdFx0XHRcdGxhc3RNb2RpZmllZDogZmlsZS5zdGF0Lm10aW1lLFxuXHRcdFx0XHRcdFx0aGFzaDogZmlsZUhhc2hcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdH0pLmNhdGNoKHJlamVjdCk7XG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ0luaXRpYWxTeW5jTWFuYWdlci5wcm9jZXNzRmlsZScsXG5cdFx0XHRcdG1ldGFkYXRhOiB7IGZpbGVQYXRoOiBmaWxlLnBhdGggfVxuXHRcdFx0fSk7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlIGZpbGUgaGFzaFxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBjYWxjdWxhdGVGaWxlSGFzaChmaWxlOiBURmlsZSk6IFByb21pc2U8c3RyaW5nPiB7XG5cdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHQucmVhZChmaWxlKTtcblx0XHRjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5cdFx0Y29uc3QgZGF0YSA9IGVuY29kZXIuZW5jb2RlKGNvbnRlbnQpO1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgZGF0YSk7XG5cdFx0cmV0dXJuIEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSlcblx0XHRcdC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKVxuXHRcdFx0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBmaWxlIGZyb250bWF0dGVyIHdpdGggc3luYyBpbmZvcm1hdGlvblxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyB1cGRhdGVGcm9udG1hdHRlcihmaWxlOiBURmlsZSwgbWV0YWRhdGE6IERvY3VtZW50TWV0YWRhdGEpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkKGZpbGUpO1xuXG5cdFx0Ly8gRXh0cmFjdCBleGlzdGluZyBmcm9udG1hdHRlclxuXHRcdGNvbnN0IGZyb250bWF0dGVyTWF0Y2ggPSBjb250ZW50Lm1hdGNoKC9eLS0tXFxuKFtcXHNcXFNdKj8pXFxuLS0tLyk7XG5cdFx0Y29uc3QgZnJvbnRtYXR0ZXIgPSBmcm9udG1hdHRlck1hdGNoXG5cdFx0XHQ/IHRoaXMucGFyc2VGcm9udG1hdHRlcihmcm9udG1hdHRlck1hdGNoWzFdKVxuXHRcdFx0OiB7fTtcblxuXHRcdC8vIFVwZGF0ZSBzeW5jIG1ldGFkYXRhXG5cdFx0ZnJvbnRtYXR0ZXIudmVjdG9yaXplZF9sYXN0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuXHRcdGZyb250bWF0dGVyLnZlY3Rvcml6ZWRfdmVyc2lvbiA9ICcxLjAnO1xuXG5cdFx0Ly8gQ3JlYXRlIG5ldyBmcm9udG1hdHRlciBzdHJpbmdcblx0XHRjb25zdCBuZXdGcm9udG1hdHRlciA9IE9iamVjdC5lbnRyaWVzKGZyb250bWF0dGVyKVxuXHRcdFx0Lm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtrZXl9OiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKVxuXHRcdFx0LmpvaW4oJ1xcbicpO1xuXG5cdFx0Ly8gVXBkYXRlIGZpbGUgY29udGVudFxuXHRcdGNvbnN0IG5ld0NvbnRlbnQgPSBmcm9udG1hdHRlck1hdGNoXG5cdFx0XHQ/IGNvbnRlbnQucmVwbGFjZSgvXi0tLVxcbltcXHNcXFNdKj9cXG4tLS0vLCBgLS0tXFxuJHtuZXdGcm9udG1hdHRlcn1cXG4tLS1gKVxuXHRcdFx0OiBgLS0tXFxuJHtuZXdGcm9udG1hdHRlcn1cXG4tLS1cXG5cXG4ke2NvbnRlbnR9YDtcblxuXHRcdGF3YWl0IHRoaXMudmF1bHQubW9kaWZ5KGZpbGUsIG5ld0NvbnRlbnQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlIGZyb250bWF0dGVyIFlBTUxcblx0ICovXG5cdHByaXZhdGUgcGFyc2VGcm9udG1hdHRlcih5YW1sOiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgZnJvbnRtYXR0ZXI6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcblx0XHRcdGNvbnN0IGxpbmVzID0geWFtbC5zcGxpdCgnXFxuJyk7XG5cblx0XHRcdGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuXHRcdFx0XHRjb25zdCBba2V5LCAuLi52YWx1ZVBhcnRzXSA9IGxpbmUuc3BsaXQoJzonKTtcblx0XHRcdFx0aWYgKGtleSAmJiB2YWx1ZVBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGZyb250bWF0dGVyW2tleS50cmltKCldID0gdmFsdWVQYXJ0cy5qb2luKCc6JykudHJpbSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmcm9udG1hdHRlcjtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS53YXJuKCdFcnJvciBwYXJzaW5nIGZyb250bWF0dGVyOicsIGVycm9yKTtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHQgKi9cblx0cHJpdmF0ZSB1cGRhdGVQcm9ncmVzc05vdGlmaWNhdGlvbigpOiB2b2lkIHtcblx0XHRjb25zdCBwcm9ncmVzcyA9IHRoaXMuY2FsY3VsYXRlUHJvZ3Jlc3MoKTtcblx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIudXBkYXRlUHJvZ3Jlc3Moe1xuXHRcdFx0dGFza0lkOiAnaW5pdGlhbC1zeW5jJyxcblx0XHRcdHByb2dyZXNzOiBwcm9ncmVzcy5wZXJjZW50YWdlLFxuXHRcdFx0Y3VycmVudFN0ZXA6IGBQcm9jZXNzaW5nIGZpbGVzICgke3RoaXMucHJvZ3Jlc3MucHJvY2Vzc2VkRmlsZXN9LyR7dGhpcy5wcm9ncmVzcy50b3RhbEZpbGVzfSlgLFxuXHRcdFx0dG90YWxTdGVwczogdGhpcy5wcm9ncmVzcy50b3RhbEJhdGNoZXMsXG5cdFx0XHRjdXJyZW50U3RlcE51bWJlcjogdGhpcy5wcm9ncmVzcy5jdXJyZW50QmF0Y2ggKyAxLFxuXHRcdFx0ZXN0aW1hdGVkVGltZVJlbWFpbmluZzogcHJvZ3Jlc3MuZXN0aW1hdGVkVGltZVJlbWFpbmluZyxcblx0XHRcdGRldGFpbHM6IHtcblx0XHRcdFx0cHJvY2Vzc2VkRmlsZXM6IHRoaXMucHJvZ3Jlc3MucHJvY2Vzc2VkRmlsZXMsXG5cdFx0XHRcdHRvdGFsRmlsZXM6IHRoaXMucHJvZ3Jlc3MudG90YWxGaWxlc1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSBjdXJyZW50IHByb2dyZXNzIGFuZCBlc3RpbWF0ZWQgdGltZSByZW1haW5pbmdcblx0ICovXG5cdHByaXZhdGUgY2FsY3VsYXRlUHJvZ3Jlc3MoKTogeyBwZXJjZW50YWdlOiBudW1iZXI7IGVzdGltYXRlZFRpbWVSZW1haW5pbmc6IG51bWJlciB9IHtcblx0XHRjb25zdCBwZXJjZW50YWdlID0gKHRoaXMucHJvZ3Jlc3MucHJvY2Vzc2VkRmlsZXMgLyB0aGlzLnByb2dyZXNzLnRvdGFsRmlsZXMpICogMTAwO1xuXG5cdFx0Ly8gQ2FsY3VsYXRlIGVzdGltYXRlZCB0aW1lIHJlbWFpbmluZ1xuXHRcdGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gdGhpcy5wcm9ncmVzcy5zdGFydFRpbWU7XG5cdFx0Y29uc3QgZmlsZXNQZXJNcyA9IHRoaXMucHJvZ3Jlc3MucHJvY2Vzc2VkRmlsZXMgLyBlbGFwc2VkO1xuXHRcdGNvbnN0IHJlbWFpbmluZ0ZpbGVzID0gdGhpcy5wcm9ncmVzcy50b3RhbEZpbGVzIC0gdGhpcy5wcm9ncmVzcy5wcm9jZXNzZWRGaWxlcztcblx0XHRjb25zdCBlc3RpbWF0ZWRUaW1lUmVtYWluaW5nID0gZmlsZXNQZXJNcyA+IDBcblx0XHRcdD8gcmVtYWluaW5nRmlsZXMgLyBmaWxlc1Blck1zXG5cdFx0XHQ6IDA7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0cGVyY2VudGFnZSxcblx0XHRcdGVzdGltYXRlZFRpbWVSZW1haW5pbmdcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoZXJlIGFyZSB1bnByb2Nlc3NlZCBiYXRjaGVzXG5cdCAqL1xuXHRwcml2YXRlIGhhc1VucHJvY2Vzc2VkQmF0Y2hlcygpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmJhdGNoZXMudmFsdWVzKCkpLnNvbWUoXG5cdFx0XHRiYXRjaCA9PiBiYXRjaC5zdGF0dXMgPT09ICdwZW5kaW5nJyB8fCBiYXRjaC5zdGF0dXMgPT09ICdwcm9jZXNzaW5nJ1xuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IG5leHQgcGVuZGluZyBiYXRjaFxuXHQgKi9cblx0cHJpdmF0ZSBnZXROZXh0UGVuZGluZ0JhdGNoKCk6IFN5bmNCYXRjaCB8IG51bGwge1xuXHRcdHJldHVybiBBcnJheS5mcm9tKHRoaXMuYmF0Y2hlcy52YWx1ZXMoKSkuZmluZChcblx0XHRcdGJhdGNoID0+IGJhdGNoLnN0YXR1cyA9PT0gJ3BlbmRpbmcnXG5cdFx0KSB8fCBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0b3AgdGhlIHN5bmMgcHJvY2Vzc1xuXHQgKi9cblx0c3RvcCgpOiB2b2lkIHtcblx0XHR0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuXHRcdGlmICh0aGlzLnByb2Nlc3NpbmdUaW1lb3V0KSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5wcm9jZXNzaW5nVGltZW91dCk7XG5cdFx0XHR0aGlzLnByb2Nlc3NpbmdUaW1lb3V0ID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGN1cnJlbnQgc3luYyBwcm9ncmVzc1xuXHQgKi9cblx0Z2V0UHJvZ3Jlc3MoKTogU3luY1Byb2dyZXNzIHtcblx0XHRyZXR1cm4geyAuLi50aGlzLnByb2dyZXNzIH07XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHN5bmMgb3B0aW9uc1xuXHQgKi9cblx0dXBkYXRlT3B0aW9ucyhvcHRpb25zOiBQYXJ0aWFsPEluaXRpYWxTeW5jT3B0aW9ucz4pOiB2b2lkIHtcblx0XHRPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5cbmV4cG9ydCBlbnVtIFBsdWdpblN0YXR1cyB7XG4gICAgSU5JVElBTElaSU5HID0gJ2luaXRpYWxpemluZycsXG4gICAgV0FJVElOR19GT1JfU1lOQyA9ICd3YWl0aW5nX3N5bmMnLFxuICAgIENIRUNLSU5HX0ZJTEUgPSAnY2hlY2tpbmdfZmlsZScsXG4gICAgUkVBRFkgPSAncmVhZHknLFxuICAgIEVSUk9SID0gJ2Vycm9yJyxcblx0UVVFVUlORyA9ICdxdWV1aW5nJywgIC8vIFdoZW4gdGFza3MgYXJlIGJlaW5nIHF1ZXVlZCBidXQgbm90IHByb2Nlc3NlZFxuICAgIFBST0NFU1NJTkdfUVVFVUUgPSAncHJvY2Vzc2luZ19xdWV1ZScgIC8vIFdoZW4gd29ya2luZyB0aHJvdWdoIHF1ZXVlZCB0YXNrc1xufVxuXG5pbnRlcmZhY2UgU3RhdHVzRGV0YWlscyB7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIHRpbWVzdGFtcDogbnVtYmVyO1xuICAgIGVycm9yPzogRXJyb3I7XG4gICAgcHJvZ3Jlc3M/OiBudW1iZXI7XG5cdHF1ZXVlU2l6ZT86IG51bWJlcjsgICAgIC8vIE51bWJlciBvZiB0YXNrcyBpbiBxdWV1ZVxuICAgIHBlbmRpbmdDaGFuZ2VzPzogbnVtYmVyOyAvLyBOdW1iZXIgb2YgY2hhbmdlcyB3YWl0aW5nXG59XG5cbnR5cGUgU3RhdHVzQ2hhbmdlQ2FsbGJhY2sgPSAoc3RhdHVzOiBQbHVnaW5TdGF0dXMsIGRldGFpbHM6IFN0YXR1c0RldGFpbHMpID0+IHZvaWQ7XG5cbmV4cG9ydCBjbGFzcyBTdGF0dXNNYW5hZ2VyIHtcbiAgICBwcml2YXRlIGN1cnJlbnRTdGF0dXM6IFBsdWdpblN0YXR1cztcbiAgICBwcml2YXRlIHN0YXR1c0RldGFpbHM6IFN0YXR1c0RldGFpbHM7XG4gICAgcHJpdmF0ZSBzdGF0dXNCYXJJdGVtOiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIHN1YnNjcmliZXJzOiBTZXQ8U3RhdHVzQ2hhbmdlQ2FsbGJhY2s+O1xuXG4gICAgY29uc3RydWN0b3Ioc3RhdHVzQmFySXRlbTogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNCYXJJdGVtID0gc3RhdHVzQmFySXRlbTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdHVzID0gUGx1Z2luU3RhdHVzLklOSVRJQUxJWklORztcbiAgICAgICAgdGhpcy5zdGF0dXNEZXRhaWxzID0ge1xuICAgICAgICAgICAgbWVzc2FnZTogJ0luaXRpYWxpemluZyBwbHVnaW4uLi4nLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBzdGF0dXMgYmFyXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBjdXJyZW50IHN0YXR1cyB3aXRoIG5ldyBkZXRhaWxzXG4gICAgICovXG4gICAgcHVibGljIHNldFN0YXR1cyhzdGF0dXM6IFBsdWdpblN0YXR1cywgZGV0YWlsczogUGFydGlhbDxTdGF0dXNEZXRhaWxzPiA9IHt9KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG9sZFN0YXR1cyA9IHRoaXMuY3VycmVudFN0YXR1cztcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdHVzID0gc3RhdHVzO1xuXG4gICAgICAgIHRoaXMuc3RhdHVzRGV0YWlscyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuc3RhdHVzRGV0YWlscyxcbiAgICAgICAgICAgIC4uLmRldGFpbHMsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBVcGRhdGUgVUlcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoKTtcblxuICAgICAgICAvLyBOb3RpZnkgc3Vic2NyaWJlcnMgaWYgc3RhdHVzIGNoYW5nZWRcbiAgICAgICAgaWYgKG9sZFN0YXR1cyAhPT0gc3RhdHVzKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG93IG5vdGljZSBmb3IgaW1wb3J0YW50IHN0YXR1cyBjaGFuZ2VzXG4gICAgICAgIGlmIChzdGF0dXMgPT09IFBsdWdpblN0YXR1cy5FUlJPUiAmJiBkZXRhaWxzLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYE1pbmQgTWF0cml4OiAke2RldGFpbHMubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBzdGF0dXMgYW5kIGRldGFpbHNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U3RhdHVzKCk6IHsgc3RhdHVzOiBQbHVnaW5TdGF0dXM7IGRldGFpbHM6IFN0YXR1c0RldGFpbHMgfSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuY3VycmVudFN0YXR1cyxcbiAgICAgICAgICAgIGRldGFpbHM6IHsgLi4udGhpcy5zdGF0dXNEZXRhaWxzIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gc3RhdHVzIGNoYW5nZXNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3Vic2NyaWJlKGNhbGxiYWNrOiBTdGF0dXNDaGFuZ2VDYWxsYmFjayk6ICgpID0+IHZvaWQge1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmFkZChjYWxsYmFjayk7XG4gICAgICAgIC8vIFJldHVybiB1bnN1YnNjcmliZSBmdW5jdGlvblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc3RhdHVzIGJhciBVSVxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlU3RhdHVzQmFyKCk6IHZvaWQge1xuICAgICAgICAvLyBDbGVhciBleGlzdGluZyBjb250ZW50XG4gICAgICAgIHRoaXMuc3RhdHVzQmFySXRlbS5lbXB0eSgpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBzdGF0dXMgaWNvbiBiYXNlZCBvbiBjdXJyZW50IHN0YXR1c1xuICAgICAgICBjb25zdCBzdGF0dXNJY29uID0gdGhpcy5jcmVhdGVTdGF0dXNJY29uKCk7XG4gICAgICAgIHRoaXMuc3RhdHVzQmFySXRlbS5hcHBlbmRDaGlsZChzdGF0dXNJY29uKTtcblxuICAgICAgICAvLyBBZGQgaG92ZXIgdG9vbHRpcFxuICAgICAgICB0aGlzLnN0YXR1c0Jhckl0ZW0uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGhpcy5zdGF0dXNEZXRhaWxzLm1lc3NhZ2UpO1xuXG4gICAgICAgIC8vIEFkZCBjbGljayBoYW5kbGVyIGZvciBtb3JlIGRldGFpbHNcbiAgICAgICAgdGhpcy5zdGF0dXNCYXJJdGVtLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKHRoaXMuc3RhdHVzRGV0YWlscy5tZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc3RhdHVzIGljb24gZWxlbWVudFxuICAgICAqL1xuICAgIHByaXZhdGUgY3JlYXRlU3RhdHVzSWNvbigpOiBIVE1MRWxlbWVudCB7XG4gICAgICAgIGNvbnN0IGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGljb24uYWRkQ2xhc3MoJ21pbmQtbWF0cml4LXN0YXR1cy1pY29uJyk7XG5cbiAgICAgICAgLy8gQWRkIHN0YXR1cy1zcGVjaWZpYyBjbGFzc2VzXG4gICAgICAgIHN3aXRjaCAodGhpcy5jdXJyZW50U3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFBsdWdpblN0YXR1cy5SRUFEWTpcbiAgICAgICAgICAgICAgICBpY29uLmFkZENsYXNzKCdpcy1yZWFkeScpO1xuICAgICAgICAgICAgICAgIGljb24uaW5uZXJIVE1MID0gJ1x1MjVDRic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFBsdWdpblN0YXR1cy5FUlJPUjpcbiAgICAgICAgICAgICAgICBpY29uLmFkZENsYXNzKCdpcy1lcnJvcicpO1xuICAgICAgICAgICAgICAgIGljb24uaW5uZXJIVE1MID0gJ1x1MjZBMCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFBsdWdpblN0YXR1cy5XQUlUSU5HX0ZPUl9TWU5DOlxuICAgICAgICAgICAgY2FzZSBQbHVnaW5TdGF0dXMuQ0hFQ0tJTkdfRklMRTpcbiAgICAgICAgICAgICAgICBpY29uLmFkZENsYXNzKCdpcy13b3JraW5nJyk7XG4gICAgICAgICAgICAgICAgaWNvbi5pbm5lckhUTUwgPSAnXHUyMUJCJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWNvbi5hZGRDbGFzcygnaXMtaW5pdGlhbGl6aW5nJyk7XG4gICAgICAgICAgICAgICAgaWNvbi5pbm5lckhUTUwgPSAnXHUyNUNCJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpY29uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGlmeSBhbGwgc3Vic2NyaWJlcnMgb2Ygc3RhdHVzIGNoYW5nZVxuICAgICAqL1xuICAgIHByaXZhdGUgbm90aWZ5U3Vic2NyaWJlcnMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlcnMuZm9yRWFjaChjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuY3VycmVudFN0YXR1cywgdGhpcy5zdGF0dXNEZXRhaWxzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gc3RhdHVzIGNoYW5nZSBzdWJzY3JpYmVyOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgcGx1Z2luIGlzIGluIGEgc3BlY2lmaWMgc3RhdHVzXG4gICAgICovXG4gICAgcHVibGljIGlzSW5TdGF0dXMoc3RhdHVzOiBQbHVnaW5TdGF0dXMpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFN0YXR1cyA9PT0gc3RhdHVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwcm9ncmVzcyBmb3IgY3VycmVudCBzdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3M6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnN0YXR1c0RldGFpbHMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBUQWJzdHJhY3RGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgU3RhdHVzTWFuYWdlciwgUGx1Z2luU3RhdHVzIH0gZnJvbSAnLi9TdGF0dXNNYW5hZ2VyJztcblxuZXhwb3J0IGNsYXNzIFN5bmNEZXRlY3Rpb25NYW5hZ2VyIHtcbiAgICBwcml2YXRlIGxhc3RTeW5jQWN0aXZpdHk6IG51bWJlciA9IDA7XG4gICAgcHJpdmF0ZSBzeW5jQ2hlY2tJbnRlcnZhbDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcbiAgICBwcml2YXRlIHF1aWV0UGVyaW9kUmVhY2hlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgaXNXYWl0aW5nRm9yUXVpZXRQZXJpb2Q6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IFFVSUVUX1BFUklPRF9NUyA9IDUwMDA7IC8vIDUgc2Vjb25kc1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgcGx1Z2luOiBQbHVnaW4sXG4gICAgICAgIHByaXZhdGUgc3RhdHVzTWFuYWdlcjogU3RhdHVzTWFuYWdlcixcbiAgICAgICAgcHJpdmF0ZSBvblF1aWV0UGVyaW9kUmVhY2hlZDogKCkgPT4gdm9pZFxuICAgICkge31cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IG1vbml0b3JpbmcgZm9yIHN5bmMgYWN0aXZpdHlcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhcnRNb25pdG9yaW5nKCk6IHZvaWQge1xuICAgICAgICAvLyBUcmFjayBmaWxlIGNoYW5nZXMgYXMgcG90ZW50aWFsIHN5bmMgYWN0aXZpdHlcbiAgICAgICAgdGhpcy5wbHVnaW4ucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLmFwcC52YXVsdC5vbignbW9kaWZ5JywgKCkgPT4gdGhpcy5yZWNvcmRTeW5jQWN0aXZpdHkoKSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wbHVnaW4ucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLmFwcC52YXVsdC5vbignY3JlYXRlJywgKCkgPT4gdGhpcy5yZWNvcmRTeW5jQWN0aXZpdHkoKSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wbHVnaW4ucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLmFwcC52YXVsdC5vbignZGVsZXRlJywgKCkgPT4gdGhpcy5yZWNvcmRTeW5jQWN0aXZpdHkoKSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTdGFydCBjaGVja2luZyBmb3IgcXVpZXQgcGVyaW9kXG4gICAgICAgIHRoaXMuc3RhcnRRdWlldFBlcmlvZENoZWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjb3JkIHN5bmMgYWN0aXZpdHkgYW5kIHJlc2V0IHF1aWV0IHBlcmlvZFxuICAgICAqL1xuICAgIHByaXZhdGUgcmVjb3JkU3luY0FjdGl2aXR5KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmxhc3RTeW5jQWN0aXZpdHkgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnF1aWV0UGVyaW9kUmVhY2hlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLmlzV2FpdGluZ0ZvclF1aWV0UGVyaW9kKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c01hbmFnZXIuc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5XQUlUSU5HX0ZPUl9TWU5DLCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1dhaXRpbmcgZm9yIE9ic2lkaWFuIHN5bmMgdG8gc2V0dGxlLi4uJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBjaGVja2luZyBmb3IgcXVpZXQgcGVyaW9kXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGFydFF1aWV0UGVyaW9kQ2hlY2soKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnN5bmNDaGVja0ludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc1dhaXRpbmdGb3JRdWlldFBlcmlvZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lU2luY2VMYXN0U3luYyA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RTeW5jQWN0aXZpdHk7XG5cbiAgICAgICAgICAgIGlmICh0aW1lU2luY2VMYXN0U3luYyA+PSB0aGlzLlFVSUVUX1BFUklPRF9NUyAmJiAhdGhpcy5xdWlldFBlcmlvZFJlYWNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1aWV0UGVyaW9kUmVhY2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1dhaXRpbmdGb3JRdWlldFBlcmlvZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnN5bmNDaGVja0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5vblF1aWV0UGVyaW9kUmVhY2hlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAxMDAwKTsgLy8gQ2hlY2sgZXZlcnkgc2Vjb25kXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcCBtb25pdG9yaW5nIGZvciBzeW5jIGFjdGl2aXR5XG4gICAgICovXG4gICAgcHVibGljIHN0b3BNb25pdG9yaW5nKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnN5bmNDaGVja0ludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNXYWl0aW5nRm9yUXVpZXRQZXJpb2QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjdXJyZW50bHkgd2FpdGluZyBmb3IgcXVpZXQgcGVyaW9kXG4gICAgICovXG4gICAgcHVibGljIGlzV2FpdGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNXYWl0aW5nRm9yUXVpZXRQZXJpb2Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRpbWUgc2luY2UgbGFzdCBzeW5jIGFjdGl2aXR5XG4gICAgICovXG4gICAgcHVibGljIGdldFRpbWVTaW5jZUxhc3RTeW5jKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5sYXN0U3luY0FjdGl2aXR5O1xuICAgIH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUEsaUJBQUFBO0FBQUEsRUFBQSxlQUFBQztBQUFBLEVBQUEsZ0JBQUFDO0FBQUEsRUFBQTtBQUFBLGVBQUFDO0FBQUE7QUFBQSxJQUdJLFdBVUEsY0FFU0Es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QkFBTyxzQkFBc0I7QUFBQSxNQUNsQztBQUFBLElBQ0QsQ0FBQztBQUFBLEVBQ0Y7QUFDRDsiLAogICJuYW1lcyI6IFsiSGVhZGVycyIsICJSZXF1ZXN0IiwgIlJlc3BvbnNlIiwgImZldGNoIiwgIlBvc3RncmVzdEVycm9yIiwgIlBvc3RncmVzdEJ1aWxkZXIiLCAicmVzIiwgIl9hIiwgIlBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIiLCAiX2EiLCAiUG9zdGdyZXN0RmlsdGVyQnVpbGRlciIsICJQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIiLCAiZmV0Y2giLCAiaGVhZCIsICJQb3N0Z3Jlc3RDbGllbnQiLCAiZmV0Y2giLCAiaGVhZCIsICJnZXQiLCAibW9kdWxlIiwgImltcG9ydF9vYnNpZGlhbiIsICJmZXRjaCIsICJGdW5jdGlvblJlZ2lvbiIsICJfYSIsICJpbmRleCIsICJTT0NLRVRfU1RBVEVTIiwgIkNIQU5ORUxfU1RBVEVTIiwgIkNIQU5ORUxfRVZFTlRTIiwgIlRSQU5TUE9SVFMiLCAiQ09OTkVDVElPTl9TVEFURSIsICJQb3N0Z3Jlc1R5cGVzIiwgIl9hIiwgIl9hIiwgIlJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMiLCAiX2EiLCAiUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQiLCAiUkVBTFRJTUVfTElTVEVOX1RZUEVTIiwgIlJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMiLCAiX2EiLCAicHVzaCIsICJfYiIsICJ0eXBlIiwgIm5vb3AiLCAiZmV0Y2giLCAiX2EiLCAia2luZCIsICJyZXNvbHZlRmV0Y2giLCAiZmV0Y2giLCAiX19hd2FpdGVyIiwgIl9fYXdhaXRlciIsICJmZXRjaCIsICJyZXNvbHZlRmV0Y2giLCAidmVyc2lvbiIsICJERUZBVUxUX0hFQURFUlMiLCAidmVyc2lvbiIsICJmZXRjaCIsICJERUZBVUxUX0hFQURFUlMiLCAicmVzb2x2ZUZldGNoIiwgImZldGNoIiwgInZlcnNpb24iLCAiREVGQVVMVF9IRUFERVJTIiwgInZlcnNpb24iLCAicmVzb2x2ZUZldGNoIiwgIkhlYWRlcnMiLCAiZmV0Y2giLCAiX19hd2FpdGVyIiwgIl9hIiwgImRlZmF1bHRzIiwgIkRFRkFVTFRfREJfT1BUSU9OUyIsICJERUZBVUxUX0FVVEhfT1BUSU9OUyIsICJERUZBVUxUX1JFQUxUSU1FX09QVElPTlMiLCAiREVGQVVMVF9HTE9CQUxfT1BUSU9OUyIsICJfX2F3YWl0ZXIiLCAidmVyc2lvbiIsICJERUZBVUxUX0hFQURFUlMiLCAidmVyc2lvbiIsICJyZXNvbHZlRmV0Y2giLCAiZmV0Y2giLCAiX2EiLCAic3RyIiwgIl9nZXRFcnJvck1lc3NhZ2UiLCAiaGFuZGxlRXJyb3IiLCAiX2EiLCAiX2dldFJlcXVlc3RQYXJhbXMiLCAiX2hhbmRsZVJlcXVlc3QiLCAiZmV0Y2giLCAicmVzb2x2ZUZldGNoIiwgIl9fcmVzdCIsICJfYSIsICJERUZBVUxUX0hFQURFUlMiLCAicmVzb2x2ZUZldGNoIiwgIl9hIiwgInZlcnNpb24iLCAicmVzdWx0IiwgImV4cGlyZXNBdCIsICJlcnJvciIsICJkYXRhIiwgIl9hIiwgImRlYnVnIiwgImZldGNoIiwgImxpbWl0IiwgInN0ciIsICJpc19hcnJheSIsICJmZXRjaCIsICJSZXF1ZXN0IiwgIlJlc3BvbnNlIiwgIkhlYWRlcnMiLCAiRm9ybURhdGEiLCAiQmxvYiIsICJGaWxlIiwgIlJlYWRhYmxlU3RyZWFtIiwgIl9hIiwgInNlbGYiLCAiUmVhZGFibGVTdHJlYW0iLCAiX2EiLCAic3RyIiwgImluZGV4IiwgIl9hIiwgIkZpbGUiLCAiRm9ybURhdGEiLCAiZmV0Y2giLCAib3B0cyIsICJQYWdlIiwgIl9hIiwgInJldHJ5TWVzc2FnZSIsICJzbGVlcCIsICJfYSIsICJfYSIsICJtb2RpZmllZEFyZyIsICJfYSIsICJfYSIsICJfYSIsICJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IiwgIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCAiaW5kZXgiLCAiX2EiLCAiaW5wdXRUb29sIiwgIl9hIiwgIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCAiY29udGVudCIsICJuYW1lIiwgIl9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsTWVzc2FnZSIsICJfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbEZ1bmN0aW9uQ2FsbCIsICJfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbEZ1bmN0aW9uQ2FsbFJlc3VsdCIsICJfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9jYWxjdWxhdGVUb3RhbFVzYWdlIiwgIl9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX3ZhbGlkYXRlUGFyYW1zIiwgIl9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX3N0cmluZ2lmeUZ1bmN0aW9uQ2FsbFJlc3VsdCIsICJpbmRleCIsICJlc2NhcGUiLCAiZSIsICJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IiwgIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCAiX2EiLCAiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2JlZ2luUmVxdWVzdCIsICJfQ2hhdENvbXBsZXRpb25TdHJlYW1fZ2V0Q2hvaWNlRXZlbnRTdGF0ZSIsICJfQ2hhdENvbXBsZXRpb25TdHJlYW1fYWRkQ2h1bmsiLCAiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRUb29sQ2FsbERvbmVFdmVudCIsICJfQ2hhdENvbXBsZXRpb25TdHJlYW1fZW1pdENvbnRlbnREb25lRXZlbnRzIiwgIl9DaGF0Q29tcGxldGlvblN0cmVhbV9lbmRSZXF1ZXN0IiwgIl9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQiLCAiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2FjY3VtdWxhdGVDaGF0Q29tcGxldGlvbiIsICJpbmRleCIsICJjb250ZW50IiwgInJlZnVzYWwiLCAicmVzdCIsICJfYiIsICJfYyIsICJfZCIsICJjaHVuayIsICJpZCIsICJDb21wbGV0aW9ucyIsICJDaGF0IiwgIkNvbXBsZXRpb25zIiwgImNodW5rIiwgIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCAiX2EiLCAiaW5kZXgiLCAiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsICJfQXNzaXN0YW50U3RyZWFtX2VuZFJlcXVlc3QiLCAiX0Fzc2lzdGFudFN0cmVhbV9oYW5kbGVNZXNzYWdlIiwgIl9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlUnVuU3RlcCIsICJfQXNzaXN0YW50U3RyZWFtX2hhbmRsZUV2ZW50IiwgIl9Bc3Npc3RhbnRTdHJlYW1fYWNjdW11bGF0ZVJ1blN0ZXAiLCAiX0Fzc2lzdGFudFN0cmVhbV9hY2N1bXVsYXRlTWVzc2FnZSIsICJfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVDb250ZW50IiwgIl9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlUnVuIiwgIl9hIiwgInNsZWVwIiwgIl9hIiwgInNsZWVwIiwgInNsZWVwIiwgIl9hIiwgIkNoYXQiLCAiQ29tcGxldGlvbnMiLCAiX2EiLCAiRmlsZXMiLCAic2xlZXAiLCAiX2EiLCAiQ29tcGxldGlvbnMiLCAiRmlsZXMiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiX2EiLCAiaW5kZXgiLCAiX2EiLCAiX2EiLCAiaW5kZXgiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJfYSIsICJzdHIiLCAiaW1wb3J0X29ic2lkaWFuIiwgIl9hIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAibW9kYWwiLCAiaW1wb3J0X29ic2lkaWFuIiwgImluZGV4IiwgImltcG9ydF9vYnNpZGlhbiIsICJfYSJdCn0K
