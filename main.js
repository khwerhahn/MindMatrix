/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the GitHub repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@supabase/node-fetch/browser.js
var browser_exports = {};
__export(browser_exports, {
  Headers: () => Headers2,
  Request: () => Request2,
  Response: () => Response2,
  default: () => browser_default,
  fetch: () => fetch2
});
var getGlobal, globalObject, fetch2, browser_default, Headers2, Request2, Response2;
var init_browser = __esm({
  "node_modules/@supabase/node-fetch/browser.js"() {
    "use strict";
    getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    globalObject = getGlobal();
    fetch2 = globalObject.fetch;
    browser_default = globalObject.fetch.bind(globalObject);
    Headers2 = globalObject.Headers;
    Request2 = globalObject.Request;
    Response2 = globalObject.Response;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js
var require_PostgrestError = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestError2 = class extends Error {
      constructor(context) {
        super(context.message);
        this.name = "PostgrestError";
        this.details = context.details;
        this.hint = context.hint;
        this.code = context.code;
      }
    };
    exports.default = PostgrestError2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js
var require_PostgrestBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var node_fetch_1 = __importDefault((init_browser(), __toCommonJS(browser_exports)));
    var PostgrestError_1 = __importDefault(require_PostgrestError());
    var PostgrestBuilder2 = class {
      constructor(builder) {
        this.shouldThrowOnError = false;
        this.method = builder.method;
        this.url = builder.url;
        this.headers = builder.headers;
        this.schema = builder.schema;
        this.body = builder.body;
        this.shouldThrowOnError = builder.shouldThrowOnError;
        this.signal = builder.signal;
        this.isMaybeSingle = builder.isMaybeSingle;
        if (builder.fetch) {
          this.fetch = builder.fetch;
        } else if (typeof fetch === "undefined") {
          this.fetch = node_fetch_1.default;
        } else {
          this.fetch = fetch;
        }
      }
      /**
       * If there's an error with the query, throwOnError will reject the promise by
       * throwing the error instead of returning it as part of a successful response.
       *
       * {@link https://github.com/supabase/supabase-js/issues/92}
       */
      throwOnError() {
        this.shouldThrowOnError = true;
        return this;
      }
      /**
       * Set an HTTP header for the request.
       */
      setHeader(name, value) {
        this.headers = Object.assign({}, this.headers);
        this.headers[name] = value;
        return this;
      }
      then(onfulfilled, onrejected) {
        if (this.schema === void 0) {
        } else if (["GET", "HEAD"].includes(this.method)) {
          this.headers["Accept-Profile"] = this.schema;
        } else {
          this.headers["Content-Profile"] = this.schema;
        }
        if (this.method !== "GET" && this.method !== "HEAD") {
          this.headers["Content-Type"] = "application/json";
        }
        const _fetch = this.fetch;
        let res = _fetch(this.url.toString(), {
          method: this.method,
          headers: this.headers,
          body: JSON.stringify(this.body),
          signal: this.signal
        }).then(async (res2) => {
          var _a2, _b, _c;
          let error = null;
          let data = null;
          let count = null;
          let status = res2.status;
          let statusText = res2.statusText;
          if (res2.ok) {
            if (this.method !== "HEAD") {
              const body = await res2.text();
              if (body === "") {
              } else if (this.headers["Accept"] === "text/csv") {
                data = body;
              } else if (this.headers["Accept"] && this.headers["Accept"].includes("application/vnd.pgrst.plan+text")) {
                data = body;
              } else {
                data = JSON.parse(body);
              }
            }
            const countHeader = (_a2 = this.headers["Prefer"]) === null || _a2 === void 0 ? void 0 : _a2.match(/count=(exact|planned|estimated)/);
            const contentRange = (_b = res2.headers.get("content-range")) === null || _b === void 0 ? void 0 : _b.split("/");
            if (countHeader && contentRange && contentRange.length > 1) {
              count = parseInt(contentRange[1]);
            }
            if (this.isMaybeSingle && this.method === "GET" && Array.isArray(data)) {
              if (data.length > 1) {
                error = {
                  // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553
                  code: "PGRST116",
                  details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                  hint: null,
                  message: "JSON object requested, multiple (or no) rows returned"
                };
                data = null;
                count = null;
                status = 406;
                statusText = "Not Acceptable";
              } else if (data.length === 1) {
                data = data[0];
              } else {
                data = null;
              }
            }
          } else {
            const body = await res2.text();
            try {
              error = JSON.parse(body);
              if (Array.isArray(error) && res2.status === 404) {
                data = [];
                error = null;
                status = 200;
                statusText = "OK";
              }
            } catch (_d) {
              if (res2.status === 404 && body === "") {
                status = 204;
                statusText = "No Content";
              } else {
                error = {
                  message: body
                };
              }
            }
            if (error && this.isMaybeSingle && ((_c = error === null || error === void 0 ? void 0 : error.details) === null || _c === void 0 ? void 0 : _c.includes("0 rows"))) {
              error = null;
              status = 200;
              statusText = "OK";
            }
            if (error && this.shouldThrowOnError) {
              throw new PostgrestError_1.default(error);
            }
          }
          const postgrestResponse = {
            error,
            data,
            count,
            status,
            statusText
          };
          return postgrestResponse;
        });
        if (!this.shouldThrowOnError) {
          res = res.catch((fetchError) => {
            var _a2, _b, _c;
            return {
              error: {
                message: `${(_a2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _a2 !== void 0 ? _a2 : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,
                details: `${(_b = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _b !== void 0 ? _b : ""}`,
                hint: "",
                code: `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) !== null && _c !== void 0 ? _c : ""}`
              },
              data: null,
              count: null,
              status: 0,
              statusText: ""
            };
          });
        }
        return res.then(onfulfilled, onrejected);
      }
    };
    exports.default = PostgrestBuilder2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js
var require_PostgrestTransformBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestBuilder_1 = __importDefault(require_PostgrestBuilder());
    var PostgrestTransformBuilder2 = class extends PostgrestBuilder_1.default {
      /**
       * Perform a SELECT on the query result.
       *
       * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
       * return modified rows. By calling this method, modified rows are returned in
       * `data`.
       *
       * @param columns - The columns to retrieve, separated by commas
       */
      select(columns) {
        let quoted = false;
        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c) => {
          if (/\s/.test(c) && !quoted) {
            return "";
          }
          if (c === '"') {
            quoted = !quoted;
          }
          return c;
        }).join("");
        this.url.searchParams.set("select", cleanedColumns);
        if (this.headers["Prefer"]) {
          this.headers["Prefer"] += ",";
        }
        this.headers["Prefer"] += "return=representation";
        return this;
      }
      /**
       * Order the query result by `column`.
       *
       * You can call this method multiple times to order by multiple columns.
       *
       * You can order referenced tables, but it only affects the ordering of the
       * parent table if you use `!inner` in the query.
       *
       * @param column - The column to order by
       * @param options - Named parameters
       * @param options.ascending - If `true`, the result will be in ascending order
       * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
       * `null`s appear last.
       * @param options.referencedTable - Set this to order a referenced table by
       * its columns
       * @param options.foreignTable - Deprecated, use `options.referencedTable`
       * instead
       */
      order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {
        const key = referencedTable ? `${referencedTable}.order` : "order";
        const existingOrder = this.url.searchParams.get(key);
        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ""}${column}.${ascending ? "asc" : "desc"}${nullsFirst === void 0 ? "" : nullsFirst ? ".nullsfirst" : ".nullslast"}`);
        return this;
      }
      /**
       * Limit the query result by `count`.
       *
       * @param count - The maximum number of rows to return
       * @param options - Named parameters
       * @param options.referencedTable - Set this to limit rows of referenced
       * tables instead of the parent table
       * @param options.foreignTable - Deprecated, use `options.referencedTable`
       * instead
       */
      limit(count, { foreignTable, referencedTable = foreignTable } = {}) {
        const key = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
        this.url.searchParams.set(key, `${count}`);
        return this;
      }
      /**
       * Limit the query result by starting at an offset `from` and ending at the offset `to`.
       * Only records within this range are returned.
       * This respects the query order and if there is no order clause the range could behave unexpectedly.
       * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
       * and fourth rows of the query.
       *
       * @param from - The starting index from which to limit the result
       * @param to - The last index to which to limit the result
       * @param options - Named parameters
       * @param options.referencedTable - Set this to limit rows of referenced
       * tables instead of the parent table
       * @param options.foreignTable - Deprecated, use `options.referencedTable`
       * instead
       */
      range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {
        const keyOffset = typeof referencedTable === "undefined" ? "offset" : `${referencedTable}.offset`;
        const keyLimit = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
        this.url.searchParams.set(keyOffset, `${from}`);
        this.url.searchParams.set(keyLimit, `${to - from + 1}`);
        return this;
      }
      /**
       * Set the AbortSignal for the fetch request.
       *
       * @param signal - The AbortSignal to use for the fetch request
       */
      abortSignal(signal) {
        this.signal = signal;
        return this;
      }
      /**
       * Return `data` as a single object instead of an array of objects.
       *
       * Query result must be one row (e.g. using `.limit(1)`), otherwise this
       * returns an error.
       */
      single() {
        this.headers["Accept"] = "application/vnd.pgrst.object+json";
        return this;
      }
      /**
       * Return `data` as a single object instead of an array of objects.
       *
       * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
       * this returns an error.
       */
      maybeSingle() {
        if (this.method === "GET") {
          this.headers["Accept"] = "application/json";
        } else {
          this.headers["Accept"] = "application/vnd.pgrst.object+json";
        }
        this.isMaybeSingle = true;
        return this;
      }
      /**
       * Return `data` as a string in CSV format.
       */
      csv() {
        this.headers["Accept"] = "text/csv";
        return this;
      }
      /**
       * Return `data` as an object in [GeoJSON](https://geojson.org) format.
       */
      geojson() {
        this.headers["Accept"] = "application/geo+json";
        return this;
      }
      /**
       * Return `data` as the EXPLAIN plan for the query.
       *
       * You need to enable the
       * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
       * setting before using this method.
       *
       * @param options - Named parameters
       *
       * @param options.analyze - If `true`, the query will be executed and the
       * actual run time will be returned
       *
       * @param options.verbose - If `true`, the query identifier will be returned
       * and `data` will include the output columns of the query
       *
       * @param options.settings - If `true`, include information on configuration
       * parameters that affect query planning
       *
       * @param options.buffers - If `true`, include information on buffer usage
       *
       * @param options.wal - If `true`, include information on WAL record generation
       *
       * @param options.format - The format of the output, can be `"text"` (default)
       * or `"json"`
       */
      explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = "text" } = {}) {
        var _a2;
        const options = [
          analyze ? "analyze" : null,
          verbose ? "verbose" : null,
          settings ? "settings" : null,
          buffers ? "buffers" : null,
          wal ? "wal" : null
        ].filter(Boolean).join("|");
        const forMediatype = (_a2 = this.headers["Accept"]) !== null && _a2 !== void 0 ? _a2 : "application/json";
        this.headers["Accept"] = `application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`;
        if (format === "json")
          return this;
        else
          return this;
      }
      /**
       * Rollback the query.
       *
       * `data` will still be returned, but the query is not committed.
       */
      rollback() {
        var _a2;
        if (((_a2 = this.headers["Prefer"]) !== null && _a2 !== void 0 ? _a2 : "").trim().length > 0) {
          this.headers["Prefer"] += ",tx=rollback";
        } else {
          this.headers["Prefer"] = "tx=rollback";
        }
        return this;
      }
      /**
       * Override the type of the returned `data`.
       *
       * @typeParam NewResult - The new result type to override with
       */
      returns() {
        return this;
      }
    };
    exports.default = PostgrestTransformBuilder2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js
var require_PostgrestFilterBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestTransformBuilder_1 = __importDefault(require_PostgrestTransformBuilder());
    var PostgrestFilterBuilder2 = class extends PostgrestTransformBuilder_1.default {
      /**
       * Match only rows where `column` is equal to `value`.
       *
       * To check if the value of `column` is NULL, you should use `.is()` instead.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      eq(column, value) {
        this.url.searchParams.append(column, `eq.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is not equal to `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      neq(column, value) {
        this.url.searchParams.append(column, `neq.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is greater than `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      gt(column, value) {
        this.url.searchParams.append(column, `gt.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is greater than or equal to `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      gte(column, value) {
        this.url.searchParams.append(column, `gte.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is less than `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      lt(column, value) {
        this.url.searchParams.append(column, `lt.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is less than or equal to `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      lte(column, value) {
        this.url.searchParams.append(column, `lte.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` matches `pattern` case-sensitively.
       *
       * @param column - The column to filter on
       * @param pattern - The pattern to match with
       */
      like(column, pattern) {
        this.url.searchParams.append(column, `like.${pattern}`);
        return this;
      }
      /**
       * Match only rows where `column` matches all of `patterns` case-sensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      likeAllOf(column, patterns) {
        this.url.searchParams.append(column, `like(all).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` matches any of `patterns` case-sensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      likeAnyOf(column, patterns) {
        this.url.searchParams.append(column, `like(any).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` matches `pattern` case-insensitively.
       *
       * @param column - The column to filter on
       * @param pattern - The pattern to match with
       */
      ilike(column, pattern) {
        this.url.searchParams.append(column, `ilike.${pattern}`);
        return this;
      }
      /**
       * Match only rows where `column` matches all of `patterns` case-insensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      ilikeAllOf(column, patterns) {
        this.url.searchParams.append(column, `ilike(all).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` matches any of `patterns` case-insensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      ilikeAnyOf(column, patterns) {
        this.url.searchParams.append(column, `ilike(any).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` IS `value`.
       *
       * For non-boolean columns, this is only relevant for checking if the value of
       * `column` is NULL by setting `value` to `null`.
       *
       * For boolean columns, you can also set `value` to `true` or `false` and it
       * will behave the same way as `.eq()`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      is(column, value) {
        this.url.searchParams.append(column, `is.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is included in the `values` array.
       *
       * @param column - The column to filter on
       * @param values - The values array to filter with
       */
      in(column, values) {
        const cleanedValues = Array.from(new Set(values)).map((s) => {
          if (typeof s === "string" && new RegExp("[,()]").test(s))
            return `"${s}"`;
          else
            return `${s}`;
        }).join(",");
        this.url.searchParams.append(column, `in.(${cleanedValues})`);
        return this;
      }
      /**
       * Only relevant for jsonb, array, and range columns. Match only rows where
       * `column` contains every element appearing in `value`.
       *
       * @param column - The jsonb, array, or range column to filter on
       * @param value - The jsonb, array, or range value to filter with
       */
      contains(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(column, `cs.${value}`);
        } else if (Array.isArray(value)) {
          this.url.searchParams.append(column, `cs.{${value.join(",")}}`);
        } else {
          this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);
        }
        return this;
      }
      /**
       * Only relevant for jsonb, array, and range columns. Match only rows where
       * every element appearing in `column` is contained by `value`.
       *
       * @param column - The jsonb, array, or range column to filter on
       * @param value - The jsonb, array, or range value to filter with
       */
      containedBy(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(column, `cd.${value}`);
        } else if (Array.isArray(value)) {
          this.url.searchParams.append(column, `cd.{${value.join(",")}}`);
        } else {
          this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);
        }
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is greater than any element in `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeGt(column, range) {
        this.url.searchParams.append(column, `sr.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is either contained in `range` or greater than any element in
       * `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeGte(column, range) {
        this.url.searchParams.append(column, `nxl.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is less than any element in `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeLt(column, range) {
        this.url.searchParams.append(column, `sl.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is either contained in `range` or less than any element in
       * `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeLte(column, range) {
        this.url.searchParams.append(column, `nxr.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where `column` is
       * mutually exclusive to `range` and there can be no element between the two
       * ranges.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeAdjacent(column, range) {
        this.url.searchParams.append(column, `adj.${range}`);
        return this;
      }
      /**
       * Only relevant for array and range columns. Match only rows where
       * `column` and `value` have an element in common.
       *
       * @param column - The array or range column to filter on
       * @param value - The array or range value to filter with
       */
      overlaps(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(column, `ov.${value}`);
        } else {
          this.url.searchParams.append(column, `ov.{${value.join(",")}}`);
        }
        return this;
      }
      /**
       * Only relevant for text and tsvector columns. Match only rows where
       * `column` matches the query string in `query`.
       *
       * @param column - The text or tsvector column to filter on
       * @param query - The query text to match with
       * @param options - Named parameters
       * @param options.config - The text search configuration to use
       * @param options.type - Change how the `query` text is interpreted
       */
      textSearch(column, query, { config, type } = {}) {
        let typePart = "";
        if (type === "plain") {
          typePart = "pl";
        } else if (type === "phrase") {
          typePart = "ph";
        } else if (type === "websearch") {
          typePart = "w";
        }
        const configPart = config === void 0 ? "" : `(${config})`;
        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);
        return this;
      }
      /**
       * Match only rows where each column in `query` keys is equal to its
       * associated value. Shorthand for multiple `.eq()`s.
       *
       * @param query - The object to filter with, with column names as keys mapped
       * to their filter values
       */
      match(query) {
        Object.entries(query).forEach(([column, value]) => {
          this.url.searchParams.append(column, `eq.${value}`);
        });
        return this;
      }
      /**
       * Match only rows which doesn't satisfy the filter.
       *
       * Unlike most filters, `opearator` and `value` are used as-is and need to
       * follow [PostgREST
       * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
       * to make sure they are properly sanitized.
       *
       * @param column - The column to filter on
       * @param operator - The operator to be negated to filter with, following
       * PostgREST syntax
       * @param value - The value to filter with, following PostgREST syntax
       */
      not(column, operator, value) {
        this.url.searchParams.append(column, `not.${operator}.${value}`);
        return this;
      }
      /**
       * Match only rows which satisfy at least one of the filters.
       *
       * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
       * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
       * to make sure it's properly sanitized.
       *
       * It's currently not possible to do an `.or()` filter across multiple tables.
       *
       * @param filters - The filters to use, following PostgREST syntax
       * @param options - Named parameters
       * @param options.referencedTable - Set this to filter on referenced tables
       * instead of the parent table
       * @param options.foreignTable - Deprecated, use `referencedTable` instead
       */
      or(filters, { foreignTable, referencedTable = foreignTable } = {}) {
        const key = referencedTable ? `${referencedTable}.or` : "or";
        this.url.searchParams.append(key, `(${filters})`);
        return this;
      }
      /**
       * Match only rows which satisfy the filter. This is an escape hatch - you
       * should use the specific filter methods wherever possible.
       *
       * Unlike most filters, `opearator` and `value` are used as-is and need to
       * follow [PostgREST
       * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
       * to make sure they are properly sanitized.
       *
       * @param column - The column to filter on
       * @param operator - The operator to filter with, following PostgREST syntax
       * @param value - The value to filter with, following PostgREST syntax
       */
      filter(column, operator, value) {
        this.url.searchParams.append(column, `${operator}.${value}`);
        return this;
      }
    };
    exports.default = PostgrestFilterBuilder2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js
var require_PostgrestQueryBuilder = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestFilterBuilder_1 = __importDefault(require_PostgrestFilterBuilder());
    var PostgrestQueryBuilder2 = class {
      constructor(url, { headers = {}, schema, fetch: fetch4 }) {
        this.url = url;
        this.headers = headers;
        this.schema = schema;
        this.fetch = fetch4;
      }
      /**
       * Perform a SELECT query on the table or view.
       *
       * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
       *
       * @param options - Named parameters
       *
       * @param options.head - When set to `true`, `data` will not be returned.
       * Useful if you only need the count.
       *
       * @param options.count - Count algorithm to use to count rows in the table or view.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      select(columns, { head: head2 = false, count } = {}) {
        const method = head2 ? "HEAD" : "GET";
        let quoted = false;
        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c) => {
          if (/\s/.test(c) && !quoted) {
            return "";
          }
          if (c === '"') {
            quoted = !quoted;
          }
          return c;
        }).join("");
        this.url.searchParams.set("select", cleanedColumns);
        if (count) {
          this.headers["Prefer"] = `count=${count}`;
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
      /**
       * Perform an INSERT into the table or view.
       *
       * By default, inserted rows are not returned. To return it, chain the call
       * with `.select()`.
       *
       * @param values - The values to insert. Pass an object to insert a single row
       * or an array to insert multiple rows.
       *
       * @param options - Named parameters
       *
       * @param options.count - Count algorithm to use to count inserted rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       *
       * @param options.defaultToNull - Make missing fields default to `null`.
       * Otherwise, use the default value for the column. Only applies for bulk
       * inserts.
       */
      insert(values, { count, defaultToNull = true } = {}) {
        const method = "POST";
        const prefersHeaders = [];
        if (this.headers["Prefer"]) {
          prefersHeaders.push(this.headers["Prefer"]);
        }
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        if (!defaultToNull) {
          prefersHeaders.push("missing=default");
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        if (Array.isArray(values)) {
          const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
          if (columns.length > 0) {
            const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
            this.url.searchParams.set("columns", uniqueColumns.join(","));
          }
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: values,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
      /**
       * Perform an UPSERT on the table or view. Depending on the column(s) passed
       * to `onConflict`, `.upsert()` allows you to perform the equivalent of
       * `.insert()` if a row with the corresponding `onConflict` columns doesn't
       * exist, or if it does exist, perform an alternative action depending on
       * `ignoreDuplicates`.
       *
       * By default, upserted rows are not returned. To return it, chain the call
       * with `.select()`.
       *
       * @param values - The values to upsert with. Pass an object to upsert a
       * single row or an array to upsert multiple rows.
       *
       * @param options - Named parameters
       *
       * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
       * duplicate rows are determined. Two rows are duplicates if all the
       * `onConflict` columns are equal.
       *
       * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
       * `false`, duplicate rows are merged with existing rows.
       *
       * @param options.count - Count algorithm to use to count upserted rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       *
       * @param options.defaultToNull - Make missing fields default to `null`.
       * Otherwise, use the default value for the column. This only applies when
       * inserting new rows, not when merging with existing rows under
       * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
       */
      upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {
        const method = "POST";
        const prefersHeaders = [`resolution=${ignoreDuplicates ? "ignore" : "merge"}-duplicates`];
        if (onConflict !== void 0)
          this.url.searchParams.set("on_conflict", onConflict);
        if (this.headers["Prefer"]) {
          prefersHeaders.push(this.headers["Prefer"]);
        }
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        if (!defaultToNull) {
          prefersHeaders.push("missing=default");
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        if (Array.isArray(values)) {
          const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
          if (columns.length > 0) {
            const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
            this.url.searchParams.set("columns", uniqueColumns.join(","));
          }
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: values,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
      /**
       * Perform an UPDATE on the table or view.
       *
       * By default, updated rows are not returned. To return it, chain the call
       * with `.select()` after filters.
       *
       * @param values - The values to update with
       *
       * @param options - Named parameters
       *
       * @param options.count - Count algorithm to use to count updated rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      update(values, { count } = {}) {
        const method = "PATCH";
        const prefersHeaders = [];
        if (this.headers["Prefer"]) {
          prefersHeaders.push(this.headers["Prefer"]);
        }
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: values,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
      /**
       * Perform a DELETE on the table or view.
       *
       * By default, deleted rows are not returned. To return it, chain the call
       * with `.select()` after filters.
       *
       * @param options - Named parameters
       *
       * @param options.count - Count algorithm to use to count deleted rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      delete({ count } = {}) {
        const method = "DELETE";
        const prefersHeaders = [];
        if (count) {
          prefersHeaders.push(`count=${count}`);
        }
        if (this.headers["Prefer"]) {
          prefersHeaders.unshift(this.headers["Prefer"]);
        }
        this.headers["Prefer"] = prefersHeaders.join(",");
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
    };
    exports.default = PostgrestQueryBuilder2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/version.js
var require_version = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "0.0.0-automated";
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/constants.js
var require_constants = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_HEADERS = void 0;
    var version_1 = require_version();
    exports.DEFAULT_HEADERS = { "X-Client-Info": `postgrest-js/${version_1.version}` };
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js
var require_PostgrestClient = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PostgrestQueryBuilder_1 = __importDefault(require_PostgrestQueryBuilder());
    var PostgrestFilterBuilder_1 = __importDefault(require_PostgrestFilterBuilder());
    var constants_1 = require_constants();
    var PostgrestClient2 = class {
      // TODO: Add back shouldThrowOnError once we figure out the typings
      /**
       * Creates a PostgREST client.
       *
       * @param url - URL of the PostgREST endpoint
       * @param options - Named parameters
       * @param options.headers - Custom headers
       * @param options.schema - Postgres schema to switch to
       * @param options.fetch - Custom fetch
       */
      constructor(url, { headers = {}, schema, fetch: fetch4 } = {}) {
        this.url = url;
        this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);
        this.schemaName = schema;
        this.fetch = fetch4;
      }
      /**
       * Perform a query on a table or a view.
       *
       * @param relation - The table or view name to query
       */
      from(relation) {
        const url = new URL(`${this.url}/${relation}`);
        return new PostgrestQueryBuilder_1.default(url, {
          headers: Object.assign({}, this.headers),
          schema: this.schemaName,
          fetch: this.fetch
        });
      }
      /**
       * Select a schema to query or perform an function (rpc) call.
       *
       * The schema needs to be on the list of exposed schemas inside Supabase.
       *
       * @param schema - The schema to query
       */
      schema(schema) {
        return new PostgrestClient2(this.url, {
          headers: this.headers,
          schema,
          fetch: this.fetch
        });
      }
      /**
       * Perform a function call.
       *
       * @param fn - The function name to call
       * @param args - The arguments to pass to the function call
       * @param options - Named parameters
       * @param options.head - When set to `true`, `data` will not be returned.
       * Useful if you only need the count.
       * @param options.get - When set to `true`, the function will be called with
       * read-only access mode.
       * @param options.count - Count algorithm to use to count rows returned by the
       * function. Only applicable for [set-returning
       * functions](https://www.postgresql.org/docs/current/functions-srf.html).
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      rpc(fn, args = {}, { head: head2 = false, get: get2 = false, count } = {}) {
        let method;
        const url = new URL(`${this.url}/rpc/${fn}`);
        let body;
        if (head2 || get2) {
          method = head2 ? "HEAD" : "GET";
          Object.entries(args).filter(([_, value]) => value !== void 0).map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(",")}}` : `${value}`]).forEach(([name, value]) => {
            url.searchParams.append(name, value);
          });
        } else {
          method = "POST";
          body = args;
        }
        const headers = Object.assign({}, this.headers);
        if (count) {
          headers["Prefer"] = `count=${count}`;
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url,
          headers,
          schema: this.schemaName,
          body,
          fetch: this.fetch,
          allowEmpty: false
        });
      }
    };
    exports.default = PostgrestClient2;
  }
});

// node_modules/@supabase/postgrest-js/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@supabase/postgrest-js/dist/cjs/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PostgrestError = exports.PostgrestBuilder = exports.PostgrestTransformBuilder = exports.PostgrestFilterBuilder = exports.PostgrestQueryBuilder = exports.PostgrestClient = void 0;
    var PostgrestClient_1 = __importDefault(require_PostgrestClient());
    exports.PostgrestClient = PostgrestClient_1.default;
    var PostgrestQueryBuilder_1 = __importDefault(require_PostgrestQueryBuilder());
    exports.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;
    var PostgrestFilterBuilder_1 = __importDefault(require_PostgrestFilterBuilder());
    exports.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;
    var PostgrestTransformBuilder_1 = __importDefault(require_PostgrestTransformBuilder());
    exports.PostgrestTransformBuilder = PostgrestTransformBuilder_1.default;
    var PostgrestBuilder_1 = __importDefault(require_PostgrestBuilder());
    exports.PostgrestBuilder = PostgrestBuilder_1.default;
    var PostgrestError_1 = __importDefault(require_PostgrestError());
    exports.PostgrestError = PostgrestError_1.default;
    exports.default = {
      PostgrestClient: PostgrestClient_1.default,
      PostgrestQueryBuilder: PostgrestQueryBuilder_1.default,
      PostgrestFilterBuilder: PostgrestFilterBuilder_1.default,
      PostgrestTransformBuilder: PostgrestTransformBuilder_1.default,
      PostgrestBuilder: PostgrestBuilder_1.default,
      PostgrestError: PostgrestError_1.default
    };
  }
});

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MindMatrixPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian12 = require("obsidian");

// node_modules/@supabase/functions-js/dist/module/helper.js
var resolveFetch = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => Promise.resolve().then(() => (init_browser(), browser_exports)).then(({ default: fetch4 }) => fetch4(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};

// node_modules/@supabase/functions-js/dist/module/types.js
var FunctionsError = class extends Error {
  constructor(message, name = "FunctionsError", context) {
    super(message);
    this.name = name;
    this.context = context;
  }
};
var FunctionsFetchError = class extends FunctionsError {
  constructor(context) {
    super("Failed to send a request to the Edge Function", "FunctionsFetchError", context);
  }
};
var FunctionsRelayError = class extends FunctionsError {
  constructor(context) {
    super("Relay Error invoking the Edge Function", "FunctionsRelayError", context);
  }
};
var FunctionsHttpError = class extends FunctionsError {
  constructor(context) {
    super("Edge Function returned a non-2xx status code", "FunctionsHttpError", context);
  }
};
var FunctionRegion;
(function(FunctionRegion2) {
  FunctionRegion2["Any"] = "any";
  FunctionRegion2["ApNortheast1"] = "ap-northeast-1";
  FunctionRegion2["ApNortheast2"] = "ap-northeast-2";
  FunctionRegion2["ApSouth1"] = "ap-south-1";
  FunctionRegion2["ApSoutheast1"] = "ap-southeast-1";
  FunctionRegion2["ApSoutheast2"] = "ap-southeast-2";
  FunctionRegion2["CaCentral1"] = "ca-central-1";
  FunctionRegion2["EuCentral1"] = "eu-central-1";
  FunctionRegion2["EuWest1"] = "eu-west-1";
  FunctionRegion2["EuWest2"] = "eu-west-2";
  FunctionRegion2["EuWest3"] = "eu-west-3";
  FunctionRegion2["SaEast1"] = "sa-east-1";
  FunctionRegion2["UsEast1"] = "us-east-1";
  FunctionRegion2["UsWest1"] = "us-west-1";
  FunctionRegion2["UsWest2"] = "us-west-2";
})(FunctionRegion || (FunctionRegion = {}));

// node_modules/@supabase/functions-js/dist/module/FunctionsClient.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FunctionsClient = class {
  constructor(url, { headers = {}, customFetch, region = FunctionRegion.Any } = {}) {
    this.url = url;
    this.headers = headers;
    this.region = region;
    this.fetch = resolveFetch(customFetch);
  }
  /**
   * Updates the authorization header
   * @param token - the new jwt token sent in the authorisation header
   */
  setAuth(token) {
    this.headers.Authorization = `Bearer ${token}`;
  }
  /**
   * Invokes a function
   * @param functionName - The name of the Function to invoke.
   * @param options - Options for invoking the Function.
   */
  invoke(functionName, options = {}) {
    var _a2;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const { headers, method, body: functionArgs } = options;
        let _headers = {};
        let { region } = options;
        if (!region) {
          region = this.region;
        }
        if (region && region !== "any") {
          _headers["x-region"] = region;
        }
        let body;
        if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, "Content-Type") || !headers)) {
          if (typeof Blob !== "undefined" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
            _headers["Content-Type"] = "application/octet-stream";
            body = functionArgs;
          } else if (typeof functionArgs === "string") {
            _headers["Content-Type"] = "text/plain";
            body = functionArgs;
          } else if (typeof FormData !== "undefined" && functionArgs instanceof FormData) {
            body = functionArgs;
          } else {
            _headers["Content-Type"] = "application/json";
            body = JSON.stringify(functionArgs);
          }
        }
        const response = yield this.fetch(`${this.url}/${functionName}`, {
          method: method || "POST",
          // headers priority is (high to low):
          // 1. invoke-level headers
          // 2. client-level headers
          // 3. default Content-Type header
          headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),
          body
        }).catch((fetchError) => {
          throw new FunctionsFetchError(fetchError);
        });
        const isRelayError = response.headers.get("x-relay-error");
        if (isRelayError && isRelayError === "true") {
          throw new FunctionsRelayError(response);
        }
        if (!response.ok) {
          throw new FunctionsHttpError(response);
        }
        let responseType = ((_a2 = response.headers.get("Content-Type")) !== null && _a2 !== void 0 ? _a2 : "text/plain").split(";")[0].trim();
        let data;
        if (responseType === "application/json") {
          data = yield response.json();
        } else if (responseType === "application/octet-stream") {
          data = yield response.blob();
        } else if (responseType === "text/event-stream") {
          data = response;
        } else if (responseType === "multipart/form-data") {
          data = yield response.formData();
        } else {
          data = yield response.text();
        }
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    });
  }
};

// node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs
var import_cjs = __toESM(require_cjs(), 1);
var {
  PostgrestClient,
  PostgrestQueryBuilder,
  PostgrestFilterBuilder,
  PostgrestTransformBuilder,
  PostgrestBuilder,
  PostgrestError
} = import_cjs.default;

// node_modules/@supabase/realtime-js/dist/module/lib/version.js
var version = "2.11.2";

// node_modules/@supabase/realtime-js/dist/module/lib/constants.js
var DEFAULT_HEADERS = { "X-Client-Info": `realtime-js/${version}` };
var VSN = "1.0.0";
var DEFAULT_TIMEOUT = 1e4;
var WS_CLOSE_NORMAL = 1e3;
var SOCKET_STATES;
(function(SOCKET_STATES2) {
  SOCKET_STATES2[SOCKET_STATES2["connecting"] = 0] = "connecting";
  SOCKET_STATES2[SOCKET_STATES2["open"] = 1] = "open";
  SOCKET_STATES2[SOCKET_STATES2["closing"] = 2] = "closing";
  SOCKET_STATES2[SOCKET_STATES2["closed"] = 3] = "closed";
})(SOCKET_STATES || (SOCKET_STATES = {}));
var CHANNEL_STATES;
(function(CHANNEL_STATES2) {
  CHANNEL_STATES2["closed"] = "closed";
  CHANNEL_STATES2["errored"] = "errored";
  CHANNEL_STATES2["joined"] = "joined";
  CHANNEL_STATES2["joining"] = "joining";
  CHANNEL_STATES2["leaving"] = "leaving";
})(CHANNEL_STATES || (CHANNEL_STATES = {}));
var CHANNEL_EVENTS;
(function(CHANNEL_EVENTS2) {
  CHANNEL_EVENTS2["close"] = "phx_close";
  CHANNEL_EVENTS2["error"] = "phx_error";
  CHANNEL_EVENTS2["join"] = "phx_join";
  CHANNEL_EVENTS2["reply"] = "phx_reply";
  CHANNEL_EVENTS2["leave"] = "phx_leave";
  CHANNEL_EVENTS2["access_token"] = "access_token";
})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));
var TRANSPORTS;
(function(TRANSPORTS2) {
  TRANSPORTS2["websocket"] = "websocket";
})(TRANSPORTS || (TRANSPORTS = {}));
var CONNECTION_STATE;
(function(CONNECTION_STATE2) {
  CONNECTION_STATE2["Connecting"] = "connecting";
  CONNECTION_STATE2["Open"] = "open";
  CONNECTION_STATE2["Closing"] = "closing";
  CONNECTION_STATE2["Closed"] = "closed";
})(CONNECTION_STATE || (CONNECTION_STATE = {}));

// node_modules/@supabase/realtime-js/dist/module/lib/serializer.js
var Serializer = class {
  constructor() {
    this.HEADER_LENGTH = 1;
  }
  decode(rawPayload, callback) {
    if (rawPayload.constructor === ArrayBuffer) {
      return callback(this._binaryDecode(rawPayload));
    }
    if (typeof rawPayload === "string") {
      return callback(JSON.parse(rawPayload));
    }
    return callback({});
  }
  _binaryDecode(buffer) {
    const view = new DataView(buffer);
    const decoder = new TextDecoder();
    return this._decodeBroadcast(buffer, view, decoder);
  }
  _decodeBroadcast(buffer, view, decoder) {
    const topicSize = view.getUint8(1);
    const eventSize = view.getUint8(2);
    let offset = this.HEADER_LENGTH + 2;
    const topic = decoder.decode(buffer.slice(offset, offset + topicSize));
    offset = offset + topicSize;
    const event = decoder.decode(buffer.slice(offset, offset + eventSize));
    offset = offset + eventSize;
    const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));
    return { ref: null, topic, event, payload: data };
  }
};

// node_modules/@supabase/realtime-js/dist/module/lib/timer.js
var Timer = class {
  constructor(callback, timerCalc) {
    this.callback = callback;
    this.timerCalc = timerCalc;
    this.timer = void 0;
    this.tries = 0;
    this.callback = callback;
    this.timerCalc = timerCalc;
  }
  reset() {
    this.tries = 0;
    clearTimeout(this.timer);
  }
  // Cancels any previous scheduleTimeout and schedules callback
  scheduleTimeout() {
    clearTimeout(this.timer);
    this.timer = setTimeout(() => {
      this.tries = this.tries + 1;
      this.callback();
    }, this.timerCalc(this.tries + 1));
  }
};

// node_modules/@supabase/realtime-js/dist/module/lib/transformers.js
var PostgresTypes;
(function(PostgresTypes2) {
  PostgresTypes2["abstime"] = "abstime";
  PostgresTypes2["bool"] = "bool";
  PostgresTypes2["date"] = "date";
  PostgresTypes2["daterange"] = "daterange";
  PostgresTypes2["float4"] = "float4";
  PostgresTypes2["float8"] = "float8";
  PostgresTypes2["int2"] = "int2";
  PostgresTypes2["int4"] = "int4";
  PostgresTypes2["int4range"] = "int4range";
  PostgresTypes2["int8"] = "int8";
  PostgresTypes2["int8range"] = "int8range";
  PostgresTypes2["json"] = "json";
  PostgresTypes2["jsonb"] = "jsonb";
  PostgresTypes2["money"] = "money";
  PostgresTypes2["numeric"] = "numeric";
  PostgresTypes2["oid"] = "oid";
  PostgresTypes2["reltime"] = "reltime";
  PostgresTypes2["text"] = "text";
  PostgresTypes2["time"] = "time";
  PostgresTypes2["timestamp"] = "timestamp";
  PostgresTypes2["timestamptz"] = "timestamptz";
  PostgresTypes2["timetz"] = "timetz";
  PostgresTypes2["tsrange"] = "tsrange";
  PostgresTypes2["tstzrange"] = "tstzrange";
})(PostgresTypes || (PostgresTypes = {}));
var convertChangeData = (columns, record, options = {}) => {
  var _a2;
  const skipTypes = (_a2 = options.skipTypes) !== null && _a2 !== void 0 ? _a2 : [];
  return Object.keys(record).reduce((acc, rec_key) => {
    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
    return acc;
  }, {});
};
var convertColumn = (columnName, columns, record, skipTypes) => {
  const column = columns.find((x) => x.name === columnName);
  const colType = column === null || column === void 0 ? void 0 : column.type;
  const value = record[columnName];
  if (colType && !skipTypes.includes(colType)) {
    return convertCell(colType, value);
  }
  return noop(value);
};
var convertCell = (type, value) => {
  if (type.charAt(0) === "_") {
    const dataType = type.slice(1, type.length);
    return toArray(value, dataType);
  }
  switch (type) {
    case PostgresTypes.bool:
      return toBoolean(value);
    case PostgresTypes.float4:
    case PostgresTypes.float8:
    case PostgresTypes.int2:
    case PostgresTypes.int4:
    case PostgresTypes.int8:
    case PostgresTypes.numeric:
    case PostgresTypes.oid:
      return toNumber(value);
    case PostgresTypes.json:
    case PostgresTypes.jsonb:
      return toJson(value);
    case PostgresTypes.timestamp:
      return toTimestampString(value);
    case PostgresTypes.abstime:
    case PostgresTypes.date:
    case PostgresTypes.daterange:
    case PostgresTypes.int4range:
    case PostgresTypes.int8range:
    case PostgresTypes.money:
    case PostgresTypes.reltime:
    case PostgresTypes.text:
    case PostgresTypes.time:
    case PostgresTypes.timestamptz:
    case PostgresTypes.timetz:
    case PostgresTypes.tsrange:
    case PostgresTypes.tstzrange:
      return noop(value);
    default:
      return noop(value);
  }
};
var noop = (value) => {
  return value;
};
var toBoolean = (value) => {
  switch (value) {
    case "t":
      return true;
    case "f":
      return false;
    default:
      return value;
  }
};
var toNumber = (value) => {
  if (typeof value === "string") {
    const parsedValue = parseFloat(value);
    if (!Number.isNaN(parsedValue)) {
      return parsedValue;
    }
  }
  return value;
};
var toJson = (value) => {
  if (typeof value === "string") {
    try {
      return JSON.parse(value);
    } catch (error) {
      console.log(`JSON parse error: ${error}`);
      return value;
    }
  }
  return value;
};
var toArray = (value, type) => {
  if (typeof value !== "string") {
    return value;
  }
  const lastIdx = value.length - 1;
  const closeBrace = value[lastIdx];
  const openBrace = value[0];
  if (openBrace === "{" && closeBrace === "}") {
    let arr;
    const valTrim = value.slice(1, lastIdx);
    try {
      arr = JSON.parse("[" + valTrim + "]");
    } catch (_) {
      arr = valTrim ? valTrim.split(",") : [];
    }
    return arr.map((val) => convertCell(type, val));
  }
  return value;
};
var toTimestampString = (value) => {
  if (typeof value === "string") {
    return value.replace(" ", "T");
  }
  return value;
};
var httpEndpointURL = (socketUrl) => {
  let url = socketUrl;
  url = url.replace(/^ws/i, "http");
  url = url.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, "");
  return url.replace(/\/+$/, "");
};

// node_modules/@supabase/realtime-js/dist/module/lib/push.js
var Push = class {
  /**
   * Initializes the Push
   *
   * @param channel The Channel
   * @param event The event, for example `"phx_join"`
   * @param payload The payload, for example `{user_id: 123}`
   * @param timeout The push timeout in milliseconds
   */
  constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {
    this.channel = channel;
    this.event = event;
    this.payload = payload;
    this.timeout = timeout;
    this.sent = false;
    this.timeoutTimer = void 0;
    this.ref = "";
    this.receivedResp = null;
    this.recHooks = [];
    this.refEvent = null;
  }
  resend(timeout) {
    this.timeout = timeout;
    this._cancelRefEvent();
    this.ref = "";
    this.refEvent = null;
    this.receivedResp = null;
    this.sent = false;
    this.send();
  }
  send() {
    if (this._hasReceived("timeout")) {
      return;
    }
    this.startTimeout();
    this.sent = true;
    this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload,
      ref: this.ref,
      join_ref: this.channel._joinRef()
    });
  }
  updatePayload(payload) {
    this.payload = Object.assign(Object.assign({}, this.payload), payload);
  }
  receive(status, callback) {
    var _a2;
    if (this._hasReceived(status)) {
      callback((_a2 = this.receivedResp) === null || _a2 === void 0 ? void 0 : _a2.response);
    }
    this.recHooks.push({ status, callback });
    return this;
  }
  startTimeout() {
    if (this.timeoutTimer) {
      return;
    }
    this.ref = this.channel.socket._makeRef();
    this.refEvent = this.channel._replyEventName(this.ref);
    const callback = (payload) => {
      this._cancelRefEvent();
      this._cancelTimeout();
      this.receivedResp = payload;
      this._matchReceive(payload);
    };
    this.channel._on(this.refEvent, {}, callback);
    this.timeoutTimer = setTimeout(() => {
      this.trigger("timeout", {});
    }, this.timeout);
  }
  trigger(status, response) {
    if (this.refEvent)
      this.channel._trigger(this.refEvent, { status, response });
  }
  destroy() {
    this._cancelRefEvent();
    this._cancelTimeout();
  }
  _cancelRefEvent() {
    if (!this.refEvent) {
      return;
    }
    this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer);
    this.timeoutTimer = void 0;
  }
  _matchReceive({ status, response }) {
    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
  }
  _hasReceived(status) {
    return this.receivedResp && this.receivedResp.status === status;
  }
};

// node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js
var REALTIME_PRESENCE_LISTEN_EVENTS;
(function(REALTIME_PRESENCE_LISTEN_EVENTS2) {
  REALTIME_PRESENCE_LISTEN_EVENTS2["SYNC"] = "sync";
  REALTIME_PRESENCE_LISTEN_EVENTS2["JOIN"] = "join";
  REALTIME_PRESENCE_LISTEN_EVENTS2["LEAVE"] = "leave";
})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));
var RealtimePresence = class {
  /**
   * Initializes the Presence.
   *
   * @param channel - The RealtimeChannel
   * @param opts - The options,
   *        for example `{events: {state: 'state', diff: 'diff'}}`
   */
  constructor(channel, opts) {
    this.channel = channel;
    this.state = {};
    this.pendingDiffs = [];
    this.joinRef = null;
    this.caller = {
      onJoin: () => {
      },
      onLeave: () => {
      },
      onSync: () => {
      }
    };
    const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {
      state: "presence_state",
      diff: "presence_diff"
    };
    this.channel._on(events.state, {}, (newState) => {
      const { onJoin, onLeave, onSync } = this.caller;
      this.joinRef = this.channel._joinRef();
      this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);
      this.pendingDiffs.forEach((diff) => {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
      });
      this.pendingDiffs = [];
      onSync();
    });
    this.channel._on(events.diff, {}, (diff) => {
      const { onJoin, onLeave, onSync } = this.caller;
      if (this.inPendingSyncState()) {
        this.pendingDiffs.push(diff);
      } else {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
        onSync();
      }
    });
    this.onJoin((key, currentPresences, newPresences) => {
      this.channel._trigger("presence", {
        event: "join",
        key,
        currentPresences,
        newPresences
      });
    });
    this.onLeave((key, currentPresences, leftPresences) => {
      this.channel._trigger("presence", {
        event: "leave",
        key,
        currentPresences,
        leftPresences
      });
    });
    this.onSync(() => {
      this.channel._trigger("presence", { event: "sync" });
    });
  }
  /**
   * Used to sync the list of presences on the server with the
   * client's state.
   *
   * An optional `onJoin` and `onLeave` callback can be provided to
   * react to changes in the client's local presences across
   * disconnects and reconnects with the server.
   *
   * @internal
   */
  static syncState(currentState, newState, onJoin, onLeave) {
    const state = this.cloneDeep(currentState);
    const transformedState = this.transformState(newState);
    const joins = {};
    const leaves = {};
    this.map(state, (key, presences) => {
      if (!transformedState[key]) {
        leaves[key] = presences;
      }
    });
    this.map(transformedState, (key, newPresences) => {
      const currentPresences = state[key];
      if (currentPresences) {
        const newPresenceRefs = newPresences.map((m) => m.presence_ref);
        const curPresenceRefs = currentPresences.map((m) => m.presence_ref);
        const joinedPresences = newPresences.filter((m) => curPresenceRefs.indexOf(m.presence_ref) < 0);
        const leftPresences = currentPresences.filter((m) => newPresenceRefs.indexOf(m.presence_ref) < 0);
        if (joinedPresences.length > 0) {
          joins[key] = joinedPresences;
        }
        if (leftPresences.length > 0) {
          leaves[key] = leftPresences;
        }
      } else {
        joins[key] = newPresences;
      }
    });
    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);
  }
  /**
   * Used to sync a diff of presence join and leave events from the
   * server, as they happen.
   *
   * Like `syncState`, `syncDiff` accepts optional `onJoin` and
   * `onLeave` callbacks to react to a user joining or leaving from a
   * device.
   *
   * @internal
   */
  static syncDiff(state, diff, onJoin, onLeave) {
    const { joins, leaves } = {
      joins: this.transformState(diff.joins),
      leaves: this.transformState(diff.leaves)
    };
    if (!onJoin) {
      onJoin = () => {
      };
    }
    if (!onLeave) {
      onLeave = () => {
      };
    }
    this.map(joins, (key, newPresences) => {
      var _a2;
      const currentPresences = (_a2 = state[key]) !== null && _a2 !== void 0 ? _a2 : [];
      state[key] = this.cloneDeep(newPresences);
      if (currentPresences.length > 0) {
        const joinedPresenceRefs = state[key].map((m) => m.presence_ref);
        const curPresences = currentPresences.filter((m) => joinedPresenceRefs.indexOf(m.presence_ref) < 0);
        state[key].unshift(...curPresences);
      }
      onJoin(key, currentPresences, newPresences);
    });
    this.map(leaves, (key, leftPresences) => {
      let currentPresences = state[key];
      if (!currentPresences)
        return;
      const presenceRefsToRemove = leftPresences.map((m) => m.presence_ref);
      currentPresences = currentPresences.filter((m) => presenceRefsToRemove.indexOf(m.presence_ref) < 0);
      state[key] = currentPresences;
      onLeave(key, currentPresences, leftPresences);
      if (currentPresences.length === 0)
        delete state[key];
    });
    return state;
  }
  /** @internal */
  static map(obj, func) {
    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));
  }
  /**
   * Remove 'metas' key
   * Change 'phx_ref' to 'presence_ref'
   * Remove 'phx_ref' and 'phx_ref_prev'
   *
   * @example
   * // returns {
   *  abc123: [
   *    { presence_ref: '2', user_id: 1 },
   *    { presence_ref: '3', user_id: 2 }
   *  ]
   * }
   * RealtimePresence.transformState({
   *  abc123: {
   *    metas: [
   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
   *      { phx_ref: '3', user_id: 2 }
   *    ]
   *  }
   * })
   *
   * @internal
   */
  static transformState(state) {
    state = this.cloneDeep(state);
    return Object.getOwnPropertyNames(state).reduce((newState, key) => {
      const presences = state[key];
      if ("metas" in presences) {
        newState[key] = presences.metas.map((presence) => {
          presence["presence_ref"] = presence["phx_ref"];
          delete presence["phx_ref"];
          delete presence["phx_ref_prev"];
          return presence;
        });
      } else {
        newState[key] = presences;
      }
      return newState;
    }, {});
  }
  /** @internal */
  static cloneDeep(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  /** @internal */
  onJoin(callback) {
    this.caller.onJoin = callback;
  }
  /** @internal */
  onLeave(callback) {
    this.caller.onLeave = callback;
  }
  /** @internal */
  onSync(callback) {
    this.caller.onSync = callback;
  }
  /** @internal */
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
};

// node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js
var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2) {
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["ALL"] = "*";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["INSERT"] = "INSERT";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["UPDATE"] = "UPDATE";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["DELETE"] = "DELETE";
})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
var REALTIME_LISTEN_TYPES;
(function(REALTIME_LISTEN_TYPES2) {
  REALTIME_LISTEN_TYPES2["BROADCAST"] = "broadcast";
  REALTIME_LISTEN_TYPES2["PRESENCE"] = "presence";
  REALTIME_LISTEN_TYPES2["POSTGRES_CHANGES"] = "postgres_changes";
  REALTIME_LISTEN_TYPES2["SYSTEM"] = "system";
})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));
var REALTIME_SUBSCRIBE_STATES;
(function(REALTIME_SUBSCRIBE_STATES2) {
  REALTIME_SUBSCRIBE_STATES2["SUBSCRIBED"] = "SUBSCRIBED";
  REALTIME_SUBSCRIBE_STATES2["TIMED_OUT"] = "TIMED_OUT";
  REALTIME_SUBSCRIBE_STATES2["CLOSED"] = "CLOSED";
  REALTIME_SUBSCRIBE_STATES2["CHANNEL_ERROR"] = "CHANNEL_ERROR";
})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));
var RealtimeChannel = class {
  constructor(topic, params = { config: {} }, socket) {
    this.topic = topic;
    this.params = params;
    this.socket = socket;
    this.bindings = {};
    this.state = CHANNEL_STATES.closed;
    this.joinedOnce = false;
    this.pushBuffer = [];
    this.subTopic = topic.replace(/^realtime:/i, "");
    this.params.config = Object.assign({
      broadcast: { ack: false, self: false },
      presence: { key: "" },
      private: false
    }, params.config);
    this.timeout = this.socket.timeout;
    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
    this.joinPush.receive("ok", () => {
      this.state = CHANNEL_STATES.joined;
      this.rejoinTimer.reset();
      this.pushBuffer.forEach((pushEvent) => pushEvent.send());
      this.pushBuffer = [];
    });
    this._onClose(() => {
      this.rejoinTimer.reset();
      this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`);
      this.state = CHANNEL_STATES.closed;
      this.socket._remove(this);
    });
    this._onError((reason) => {
      if (this._isLeaving() || this._isClosed()) {
        return;
      }
      this.socket.log("channel", `error ${this.topic}`, reason);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this.joinPush.receive("timeout", () => {
      if (!this._isJoining()) {
        return;
      }
      this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {
      this._trigger(this._replyEventName(ref), payload);
    });
    this.presence = new RealtimePresence(this);
    this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint) + "/api/broadcast";
    this.private = this.params.config.private || false;
  }
  /** Subscribe registers your client with the server */
  subscribe(callback, timeout = this.timeout) {
    var _a2, _b;
    if (!this.socket.isConnected()) {
      this.socket.connect();
    }
    if (this.joinedOnce) {
      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;
    } else {
      const { config: { broadcast, presence, private: isPrivate } } = this.params;
      this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));
      this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));
      const accessTokenPayload = {};
      const config = {
        broadcast,
        presence,
        postgres_changes: (_b = (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [],
        private: isPrivate
      };
      if (this.socket.accessTokenValue) {
        accessTokenPayload.access_token = this.socket.accessTokenValue;
      }
      this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));
      this.joinedOnce = true;
      this._rejoin(timeout);
      this.joinPush.receive("ok", async ({ postgres_changes }) => {
        var _a3;
        this.socket.setAuth();
        if (postgres_changes === void 0) {
          callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          return;
        } else {
          const clientPostgresBindings = this.bindings.postgres_changes;
          const bindingsLen = (_a3 = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a3 !== void 0 ? _a3 : 0;
          const newPostgresBindings = [];
          for (let i = 0; i < bindingsLen; i++) {
            const clientPostgresBinding = clientPostgresBindings[i];
            const { filter: { event, schema, table, filter } } = clientPostgresBinding;
            const serverPostgresFilter = postgres_changes && postgres_changes[i];
            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {
              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));
            } else {
              this.unsubscribe();
              callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
              return;
            }
          }
          this.bindings.postgres_changes = newPostgresBindings;
          callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          return;
        }
      }).receive("error", (error) => {
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(", ") || "error")));
        return;
      }).receive("timeout", () => {
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);
        return;
      });
    }
    return this;
  }
  presenceState() {
    return this.presence.state;
  }
  async track(payload, opts = {}) {
    return await this.send({
      type: "presence",
      event: "track",
      payload
    }, opts.timeout || this.timeout);
  }
  async untrack(opts = {}) {
    return await this.send({
      type: "presence",
      event: "untrack"
    }, opts);
  }
  on(type, filter, callback) {
    return this._on(type, filter, callback);
  }
  /**
   * Sends a message into the channel.
   *
   * @param args Arguments to send to channel
   * @param args.type The type of event to send
   * @param args.event The name of the event being sent
   * @param args.payload Payload to be sent
   * @param opts Options to be used during the send process
   */
  async send(args, opts = {}) {
    var _a2, _b;
    if (!this._canPush() && args.type === "broadcast") {
      const { event, payload: endpoint_payload } = args;
      const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
      const options = {
        method: "POST",
        headers: {
          Authorization: authorization,
          apikey: this.socket.apiKey ? this.socket.apiKey : "",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: [
            {
              topic: this.subTopic,
              event,
              payload: endpoint_payload,
              private: this.private
            }
          ]
        })
      };
      try {
        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a2 = opts.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout);
        await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());
        return response.ok ? "ok" : "error";
      } catch (error) {
        if (error.name === "AbortError") {
          return "timed out";
        } else {
          return "error";
        }
      }
    } else {
      return new Promise((resolve) => {
        var _a3, _b2, _c;
        const push2 = this._push(args.type, args, opts.timeout || this.timeout);
        if (args.type === "broadcast" && !((_c = (_b2 = (_a3 = this.params) === null || _a3 === void 0 ? void 0 : _a3.config) === null || _b2 === void 0 ? void 0 : _b2.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {
          resolve("ok");
        }
        push2.receive("ok", () => resolve("ok"));
        push2.receive("error", () => resolve("error"));
        push2.receive("timeout", () => resolve("timed out"));
      });
    }
  }
  updateJoinPayload(payload) {
    this.joinPush.updatePayload(payload);
  }
  /**
   * Leaves the channel.
   *
   * Unsubscribes from server events, and instructs channel to terminate on server.
   * Triggers onClose() hooks.
   *
   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
   * channel.unsubscribe().receive("ok", () => alert("left!") )
   */
  unsubscribe(timeout = this.timeout) {
    this.state = CHANNEL_STATES.leaving;
    const onClose = () => {
      this.socket.log("channel", `leave ${this.topic}`);
      this._trigger(CHANNEL_EVENTS.close, "leave", this._joinRef());
    };
    this.rejoinTimer.reset();
    this.joinPush.destroy();
    return new Promise((resolve) => {
      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);
      leavePush.receive("ok", () => {
        onClose();
        resolve("ok");
      }).receive("timeout", () => {
        onClose();
        resolve("timed out");
      }).receive("error", () => {
        resolve("error");
      });
      leavePush.send();
      if (!this._canPush()) {
        leavePush.trigger("ok", {});
      }
    });
  }
  /** @internal */
  async _fetchWithTimeout(url, options, timeout) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));
    clearTimeout(id);
    return response;
  }
  /** @internal */
  _push(event, payload, timeout = this.timeout) {
    if (!this.joinedOnce) {
      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    }
    let pushEvent = new Push(this, event, payload, timeout);
    if (this._canPush()) {
      pushEvent.send();
    } else {
      pushEvent.startTimeout();
      this.pushBuffer.push(pushEvent);
    }
    return pushEvent;
  }
  /**
   * Overridable message hook
   *
   * Receives all events for specialized message handling before dispatching to the channel callbacks.
   * Must return the payload, modified or unmodified.
   *
   * @internal
   */
  _onMessage(_event, payload, _ref) {
    return payload;
  }
  /** @internal */
  _isMember(topic) {
    return this.topic === topic;
  }
  /** @internal */
  _joinRef() {
    return this.joinPush.ref;
  }
  /** @internal */
  _trigger(type, payload, ref) {
    var _a2, _b;
    const typeLower = type.toLocaleLowerCase();
    const { close, error, leave, join } = CHANNEL_EVENTS;
    const events = [close, error, leave, join];
    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
      return;
    }
    let handledPayload = this._onMessage(typeLower, payload, ref);
    if (payload && !handledPayload) {
      throw "channel onMessage callbacks must return the payload, modified or unmodified";
    }
    if (["insert", "update", "delete"].includes(typeLower)) {
      (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.filter((bind) => {
        var _a3, _b2, _c;
        return ((_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event) === "*" || ((_c = (_b2 = bind.filter) === null || _b2 === void 0 ? void 0 : _b2.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
      }).map((bind) => bind.callback(handledPayload, ref));
    } else {
      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {
        var _a3, _b2, _c, _d, _e, _f;
        if (["broadcast", "presence", "postgres_changes"].includes(typeLower)) {
          if ("id" in bind) {
            const bindId = bind.id;
            const bindEvent = (_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event;
            return bindId && ((_b2 = payload.ids) === null || _b2 === void 0 ? void 0 : _b2.includes(bindId)) && (bindEvent === "*" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));
          } else {
            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();
            return bindEvent === "*" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());
          }
        } else {
          return bind.type.toLocaleLowerCase() === typeLower;
        }
      }).map((bind) => {
        if (typeof handledPayload === "object" && "ids" in handledPayload) {
          const postgresChanges = handledPayload.data;
          const { schema, table, commit_timestamp, type: type2, errors } = postgresChanges;
          const enrichedPayload = {
            schema,
            table,
            commit_timestamp,
            eventType: type2,
            new: {},
            old: {},
            errors
          };
          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));
        }
        bind.callback(handledPayload, ref);
      });
    }
  }
  /** @internal */
  _isClosed() {
    return this.state === CHANNEL_STATES.closed;
  }
  /** @internal */
  _isJoined() {
    return this.state === CHANNEL_STATES.joined;
  }
  /** @internal */
  _isJoining() {
    return this.state === CHANNEL_STATES.joining;
  }
  /** @internal */
  _isLeaving() {
    return this.state === CHANNEL_STATES.leaving;
  }
  /** @internal */
  _replyEventName(ref) {
    return `chan_reply_${ref}`;
  }
  /** @internal */
  _on(type, filter, callback) {
    const typeLower = type.toLocaleLowerCase();
    const binding = {
      type: typeLower,
      filter,
      callback
    };
    if (this.bindings[typeLower]) {
      this.bindings[typeLower].push(binding);
    } else {
      this.bindings[typeLower] = [binding];
    }
    return this;
  }
  /** @internal */
  _off(type, filter) {
    const typeLower = type.toLocaleLowerCase();
    this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {
      var _a2;
      return !(((_a2 = bind.type) === null || _a2 === void 0 ? void 0 : _a2.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
    });
    return this;
  }
  /** @internal */
  static isEqual(obj1, obj2) {
    if (Object.keys(obj1).length !== Object.keys(obj2).length) {
      return false;
    }
    for (const k in obj1) {
      if (obj1[k] !== obj2[k]) {
        return false;
      }
    }
    return true;
  }
  /** @internal */
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout();
    if (this.socket.isConnected()) {
      this._rejoin();
    }
  }
  /**
   * Registers a callback that will be executed when the channel closes.
   *
   * @internal
   */
  _onClose(callback) {
    this._on(CHANNEL_EVENTS.close, {}, callback);
  }
  /**
   * Registers a callback that will be executed when the channel encounteres an error.
   *
   * @internal
   */
  _onError(callback) {
    this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));
  }
  /**
   * Returns `true` if the socket is connected and the channel has been joined.
   *
   * @internal
   */
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  /** @internal */
  _rejoin(timeout = this.timeout) {
    if (this._isLeaving()) {
      return;
    }
    this.socket._leaveOpenTopic(this.topic);
    this.state = CHANNEL_STATES.joining;
    this.joinPush.resend(timeout);
  }
  /** @internal */
  _getPayloadRecords(payload) {
    const records = {
      new: {},
      old: {}
    };
    if (payload.type === "INSERT" || payload.type === "UPDATE") {
      records.new = convertChangeData(payload.columns, payload.record);
    }
    if (payload.type === "UPDATE" || payload.type === "DELETE") {
      records.old = convertChangeData(payload.columns, payload.old_record);
    }
    return records;
  }
};

// node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js
var noop2 = () => {
};
var NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket !== "undefined";
var WORKER_SCRIPT = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
var RealtimeClient = class {
  /**
   * Initializes the Socket.
   *
   * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
   * @param httpEndpoint The string HTTP endpoint, ie, "https://example.com", "/" (inherited host & protocol)
   * @param options.transport The Websocket Transport, for example WebSocket.
   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
   * @param options.params The optional params to pass when connecting.
   * @param options.headers The optional headers to pass when connecting.
   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
   * @param options.worker Use Web Worker to set a side flow. Defaults to false.
   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.
   */
  constructor(endPoint, options) {
    var _a2;
    this.accessTokenValue = null;
    this.apiKey = null;
    this.channels = [];
    this.endPoint = "";
    this.httpEndpoint = "";
    this.headers = DEFAULT_HEADERS;
    this.params = {};
    this.timeout = DEFAULT_TIMEOUT;
    this.heartbeatIntervalMs = 3e4;
    this.heartbeatTimer = void 0;
    this.pendingHeartbeatRef = null;
    this.ref = 0;
    this.logger = noop2;
    this.conn = null;
    this.sendBuffer = [];
    this.serializer = new Serializer();
    this.stateChangeCallbacks = {
      open: [],
      close: [],
      error: [],
      message: []
    };
    this.accessToken = null;
    this._resolveFetch = (customFetch) => {
      let _fetch;
      if (customFetch) {
        _fetch = customFetch;
      } else if (typeof fetch === "undefined") {
        _fetch = (...args) => Promise.resolve().then(() => (init_browser(), browser_exports)).then(({ default: fetch4 }) => fetch4(...args));
      } else {
        _fetch = fetch;
      }
      return (...args) => _fetch(...args);
    };
    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
    this.httpEndpoint = httpEndpointURL(endPoint);
    if (options === null || options === void 0 ? void 0 : options.transport) {
      this.transport = options.transport;
    } else {
      this.transport = null;
    }
    if (options === null || options === void 0 ? void 0 : options.params)
      this.params = options.params;
    if (options === null || options === void 0 ? void 0 : options.headers)
      this.headers = Object.assign(Object.assign({}, this.headers), options.headers);
    if (options === null || options === void 0 ? void 0 : options.timeout)
      this.timeout = options.timeout;
    if (options === null || options === void 0 ? void 0 : options.logger)
      this.logger = options.logger;
    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)
      this.heartbeatIntervalMs = options.heartbeatIntervalMs;
    const accessTokenValue = (_a2 = options === null || options === void 0 ? void 0 : options.params) === null || _a2 === void 0 ? void 0 : _a2.apikey;
    if (accessTokenValue) {
      this.accessTokenValue = accessTokenValue;
      this.apiKey = accessTokenValue;
    }
    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : (tries) => {
      return [1e3, 2e3, 5e3, 1e4][tries - 1] || 1e4;
    };
    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {
      return callback(JSON.stringify(payload));
    };
    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);
    this.reconnectTimer = new Timer(async () => {
      this.disconnect();
      this.connect();
    }, this.reconnectAfterMs);
    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);
    if (options === null || options === void 0 ? void 0 : options.worker) {
      if (typeof window !== "undefined" && !window.Worker) {
        throw new Error("Web Worker is not supported");
      }
      this.worker = (options === null || options === void 0 ? void 0 : options.worker) || false;
      this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;
    }
    this.accessToken = (options === null || options === void 0 ? void 0 : options.accessToken) || null;
  }
  /**
   * Connects the socket, unless already connected.
   */
  connect() {
    if (this.conn) {
      return;
    }
    if (this.transport) {
      this.conn = new this.transport(this.endpointURL(), void 0, {
        headers: this.headers
      });
      return;
    }
    if (NATIVE_WEBSOCKET_AVAILABLE) {
      this.conn = new WebSocket(this.endpointURL());
      this.setupConnection();
      return;
    }
    this.conn = new WSWebSocketDummy(this.endpointURL(), void 0, {
      close: () => {
        this.conn = null;
      }
    });
    Promise.resolve().then(() => __toESM(require_browser())).then(({ default: WS }) => {
      this.conn = new WS(this.endpointURL(), void 0, {
        headers: this.headers
      });
      this.setupConnection();
    });
  }
  /**
   * Returns the URL of the websocket.
   * @returns string The URL of the websocket.
   */
  endpointURL() {
    return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));
  }
  /**
   * Disconnects the socket.
   *
   * @param code A numeric status code to send on disconnect.
   * @param reason A custom reason for the disconnect.
   */
  disconnect(code, reason) {
    if (this.conn) {
      this.conn.onclose = function() {
      };
      if (code) {
        this.conn.close(code, reason !== null && reason !== void 0 ? reason : "");
      } else {
        this.conn.close();
      }
      this.conn = null;
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.reconnectTimer.reset();
    }
  }
  /**
   * Returns all created channels
   */
  getChannels() {
    return this.channels;
  }
  /**
   * Unsubscribes and removes a single channel
   * @param channel A RealtimeChannel instance
   */
  async removeChannel(channel) {
    const status = await channel.unsubscribe();
    if (this.channels.length === 0) {
      this.disconnect();
    }
    return status;
  }
  /**
   * Unsubscribes and removes all channels
   */
  async removeAllChannels() {
    const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));
    this.disconnect();
    return values_1;
  }
  /**
   * Logs the message.
   *
   * For customized logging, `this.logger` can be overridden.
   */
  log(kind2, msg, data) {
    this.logger(kind2, msg, data);
  }
  /**
   * Returns the current state of the socket.
   */
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case SOCKET_STATES.connecting:
        return CONNECTION_STATE.Connecting;
      case SOCKET_STATES.open:
        return CONNECTION_STATE.Open;
      case SOCKET_STATES.closing:
        return CONNECTION_STATE.Closing;
      default:
        return CONNECTION_STATE.Closed;
    }
  }
  /**
   * Returns `true` is the connection is open.
   */
  isConnected() {
    return this.connectionState() === CONNECTION_STATE.Open;
  }
  channel(topic, params = { config: {} }) {
    const chan = new RealtimeChannel(`realtime:${topic}`, params, this);
    this.channels.push(chan);
    return chan;
  }
  /**
   * Push out a message if the socket is connected.
   *
   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
   */
  push(data) {
    const { topic, event, payload, ref } = data;
    const callback = () => {
      this.encode(data, (result) => {
        var _a2;
        (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.send(result);
      });
    };
    this.log("push", `${topic} ${event} (${ref})`, payload);
    if (this.isConnected()) {
      callback();
    } else {
      this.sendBuffer.push(callback);
    }
  }
  /**
   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
   *
   * If param is null it will use the `accessToken` callback function or the token set on the client.
   *
   * On callback used, it will set the value of the token internal to the client.
   *
   * @param token A JWT string to override the token set on the client.
   */
  async setAuth(token = null) {
    let tokenToSend = token || this.accessToken && await this.accessToken() || this.accessTokenValue;
    if (tokenToSend) {
      let parsed = null;
      try {
        parsed = JSON.parse(atob(tokenToSend.split(".")[1]));
      } catch (_error) {
      }
      if (parsed && parsed.exp) {
        let now = Math.floor(Date.now() / 1e3);
        let valid = now - parsed.exp < 0;
        if (!valid) {
          this.log("auth", `InvalidJWTToken: Invalid value for JWT claim "exp" with value ${parsed.exp}`);
          return Promise.reject(`InvalidJWTToken: Invalid value for JWT claim "exp" with value ${parsed.exp}`);
        }
      }
      this.accessTokenValue = tokenToSend;
      this.channels.forEach((channel) => {
        tokenToSend && channel.updateJoinPayload({ access_token: tokenToSend });
        if (channel.joinedOnce && channel._isJoined()) {
          channel._push(CHANNEL_EVENTS.access_token, {
            access_token: tokenToSend
          });
        }
      });
    }
  }
  /**
   * Sends a heartbeat message if the socket is connected.
   */
  async sendHeartbeat() {
    var _a2;
    if (!this.isConnected()) {
      return;
    }
    if (this.pendingHeartbeatRef) {
      this.pendingHeartbeatRef = null;
      this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
      (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.close(WS_CLOSE_NORMAL, "hearbeat timeout");
      return;
    }
    this.pendingHeartbeatRef = this._makeRef();
    this.push({
      topic: "phoenix",
      event: "heartbeat",
      payload: {},
      ref: this.pendingHeartbeatRef
    });
    this.setAuth();
  }
  /**
   * Flushes send buffer
   */
  flushSendBuffer() {
    if (this.isConnected() && this.sendBuffer.length > 0) {
      this.sendBuffer.forEach((callback) => callback());
      this.sendBuffer = [];
    }
  }
  /**
   * Return the next message ref, accounting for overflows
   *
   * @internal
   */
  _makeRef() {
    let newRef = this.ref + 1;
    if (newRef === this.ref) {
      this.ref = 0;
    } else {
      this.ref = newRef;
    }
    return this.ref.toString();
  }
  /**
   * Unsubscribe from channels with the specified topic.
   *
   * @internal
   */
  _leaveOpenTopic(topic) {
    let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));
    if (dupChannel) {
      this.log("transport", `leaving duplicate topic "${topic}"`);
      dupChannel.unsubscribe();
    }
  }
  /**
   * Removes a subscription from the socket.
   *
   * @param channel An open subscription.
   *
   * @internal
   */
  _remove(channel) {
    this.channels = this.channels.filter((c) => c._joinRef() !== channel._joinRef());
  }
  /**
   * Sets up connection handlers.
   *
   * @internal
   */
  setupConnection() {
    if (this.conn) {
      this.conn.binaryType = "arraybuffer";
      this.conn.onopen = () => this._onConnOpen();
      this.conn.onerror = (error) => this._onConnError(error);
      this.conn.onmessage = (event) => this._onConnMessage(event);
      this.conn.onclose = (event) => this._onConnClose(event);
    }
  }
  /** @internal */
  _onConnMessage(rawMessage) {
    this.decode(rawMessage.data, (msg) => {
      let { topic, event, payload, ref } = msg;
      if (ref && ref === this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
      }
      this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
      this.channels.filter((channel) => channel._isMember(topic)).forEach((channel) => channel._trigger(event, payload, ref));
      this.stateChangeCallbacks.message.forEach((callback) => callback(msg));
    });
  }
  /** @internal */
  async _onConnOpen() {
    this.log("transport", `connected to ${this.endpointURL()}`);
    this.flushSendBuffer();
    this.reconnectTimer.reset();
    if (!this.worker) {
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    } else {
      if (this.workerUrl) {
        this.log("worker", `starting worker for from ${this.workerUrl}`);
      } else {
        this.log("worker", `starting default worker`);
      }
      const objectUrl = this._workerObjectUrl(this.workerUrl);
      this.workerRef = new Worker(objectUrl);
      this.workerRef.onerror = (error) => {
        this.log("worker", "worker error", error.message);
        this.workerRef.terminate();
      };
      this.workerRef.onmessage = (event) => {
        if (event.data.event === "keepAlive") {
          this.sendHeartbeat();
        }
      };
      this.workerRef.postMessage({
        event: "start",
        interval: this.heartbeatIntervalMs
      });
    }
    this.stateChangeCallbacks.open.forEach((callback) => callback());
  }
  /** @internal */
  _onConnClose(event) {
    this.log("transport", "close", event);
    this._triggerChanError();
    this.heartbeatTimer && clearInterval(this.heartbeatTimer);
    this.reconnectTimer.scheduleTimeout();
    this.stateChangeCallbacks.close.forEach((callback) => callback(event));
  }
  /** @internal */
  _onConnError(error) {
    this.log("transport", error.message);
    this._triggerChanError();
    this.stateChangeCallbacks.error.forEach((callback) => callback(error));
  }
  /** @internal */
  _triggerChanError() {
    this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));
  }
  /** @internal */
  _appendParams(url, params) {
    if (Object.keys(params).length === 0) {
      return url;
    }
    const prefix = url.match(/\?/) ? "&" : "?";
    const query = new URLSearchParams(params);
    return `${url}${prefix}${query}`;
  }
  _workerObjectUrl(url) {
    let result_url;
    if (url) {
      result_url = url;
    } else {
      const blob = new Blob([WORKER_SCRIPT], { type: "application/javascript" });
      result_url = URL.createObjectURL(blob);
    }
    return result_url;
  }
};
var WSWebSocketDummy = class {
  constructor(address, _protocols, options) {
    this.binaryType = "arraybuffer";
    this.onclose = () => {
    };
    this.onerror = () => {
    };
    this.onmessage = () => {
    };
    this.onopen = () => {
    };
    this.readyState = SOCKET_STATES.connecting;
    this.send = () => {
    };
    this.url = null;
    this.url = address;
    this.close = options.close;
  }
};

// node_modules/@supabase/storage-js/dist/module/lib/errors.js
var StorageError = class extends Error {
  constructor(message) {
    super(message);
    this.__isStorageError = true;
    this.name = "StorageError";
  }
};
function isStorageError(error) {
  return typeof error === "object" && error !== null && "__isStorageError" in error;
}
var StorageApiError = class extends StorageError {
  constructor(message, status) {
    super(message);
    this.name = "StorageApiError";
    this.status = status;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    };
  }
};
var StorageUnknownError = class extends StorageError {
  constructor(message, originalError) {
    super(message);
    this.name = "StorageUnknownError";
    this.originalError = originalError;
  }
};

// node_modules/@supabase/storage-js/dist/module/lib/helpers.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var resolveFetch2 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => Promise.resolve().then(() => (init_browser(), browser_exports)).then(({ default: fetch4 }) => fetch4(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
var resolveResponse = () => __awaiter2(void 0, void 0, void 0, function* () {
  if (typeof Response === "undefined") {
    return (yield Promise.resolve().then(() => (init_browser(), browser_exports))).Response;
  }
  return Response;
});
var recursiveToCamel = (item) => {
  if (Array.isArray(item)) {
    return item.map((el) => recursiveToCamel(el));
  } else if (typeof item === "function" || item !== Object(item)) {
    return item;
  }
  const result = {};
  Object.entries(item).forEach(([key, value]) => {
    const newKey = key.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ""));
    result[newKey] = recursiveToCamel(value);
  });
  return result;
};

// node_modules/@supabase/storage-js/dist/module/lib/fetch.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
var handleError = (error, reject, options) => __awaiter3(void 0, void 0, void 0, function* () {
  const Res = yield resolveResponse();
  if (error instanceof Res && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
    error.json().then((err) => {
      reject(new StorageApiError(_getErrorMessage(err), error.status || 500));
    }).catch((err) => {
      reject(new StorageUnknownError(_getErrorMessage(err), err));
    });
  } else {
    reject(new StorageUnknownError(_getErrorMessage(error), error));
  }
});
var _getRequestParams = (method, options, parameters, body) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET") {
    return params;
  }
  params.headers = Object.assign({ "Content-Type": "application/json" }, options === null || options === void 0 ? void 0 : options.headers);
  if (body) {
    params.body = JSON.stringify(body);
  }
  return Object.assign(Object.assign({}, params), parameters);
};
function _handleRequest(fetcher, method, url, options, parameters, body) {
  return __awaiter3(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      fetcher(url, _getRequestParams(method, options, parameters, body)).then((result) => {
        if (!result.ok)
          throw result;
        if (options === null || options === void 0 ? void 0 : options.noResolveJson)
          return result;
        return result.json();
      }).then((data) => resolve(data)).catch((error) => handleError(error, reject, options));
    });
  });
}
function get(fetcher, url, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "GET", url, options, parameters);
  });
}
function post(fetcher, url, body, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "POST", url, options, parameters, body);
  });
}
function put(fetcher, url, body, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "PUT", url, options, parameters, body);
  });
}
function head(fetcher, url, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "HEAD", url, Object.assign(Object.assign({}, options), { noResolveJson: true }), parameters);
  });
}
function remove(fetcher, url, body, options, parameters) {
  return __awaiter3(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, "DELETE", url, options, parameters, body);
  });
}

// node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_SEARCH_OPTIONS = {
  limit: 100,
  offset: 0,
  sortBy: {
    column: "name",
    order: "asc"
  }
};
var DEFAULT_FILE_OPTIONS = {
  cacheControl: "3600",
  contentType: "text/plain;charset=UTF-8",
  upsert: false
};
var StorageFileApi = class {
  constructor(url, headers = {}, bucketId, fetch4) {
    this.url = url;
    this.headers = headers;
    this.bucketId = bucketId;
    this.fetch = resolveFetch2(fetch4);
  }
  /**
   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
   *
   * @param method HTTP method.
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadOrUpdate(method, path, fileBody, fileOptions) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        let body;
        const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
        let headers = Object.assign(Object.assign({}, this.headers), method === "POST" && { "x-upsert": String(options.upsert) });
        const metadata = options.metadata;
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          body = new FormData();
          body.append("cacheControl", options.cacheControl);
          if (metadata) {
            body.append("metadata", this.encodeMetadata(metadata));
          }
          body.append("", fileBody);
        } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
          body = fileBody;
          body.append("cacheControl", options.cacheControl);
          if (metadata) {
            body.append("metadata", this.encodeMetadata(metadata));
          }
        } else {
          body = fileBody;
          headers["cache-control"] = `max-age=${options.cacheControl}`;
          headers["content-type"] = options.contentType;
          if (metadata) {
            headers["x-metadata"] = this.toBase64(this.encodeMetadata(metadata));
          }
        }
        if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) {
          headers = Object.assign(Object.assign({}, headers), fileOptions.headers);
        }
        const cleanPath = this._removeEmptyFolders(path);
        const _path = this._getFinalPath(cleanPath);
        const res = yield this.fetch(`${this.url}/object/${_path}`, Object.assign({ method, body, headers }, (options === null || options === void 0 ? void 0 : options.duplex) ? { duplex: options.duplex } : {}));
        const data = yield res.json();
        if (res.ok) {
          return {
            data: { path: cleanPath, id: data.Id, fullPath: data.Key },
            error: null
          };
        } else {
          const error = data;
          return { data: null, error };
        }
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Uploads a file to an existing bucket.
   *
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  upload(path, fileBody, fileOptions) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("POST", path, fileBody, fileOptions);
    });
  }
  /**
   * Upload a file with a token generated from `createSignedUploadUrl`.
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param token The token generated from `createSignedUploadUrl`
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadToSignedUrl(path, token, fileBody, fileOptions) {
    return __awaiter4(this, void 0, void 0, function* () {
      const cleanPath = this._removeEmptyFolders(path);
      const _path = this._getFinalPath(cleanPath);
      const url = new URL(this.url + `/object/upload/sign/${_path}`);
      url.searchParams.set("token", token);
      try {
        let body;
        const options = Object.assign({ upsert: DEFAULT_FILE_OPTIONS.upsert }, fileOptions);
        const headers = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(options.upsert) });
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          body = new FormData();
          body.append("cacheControl", options.cacheControl);
          body.append("", fileBody);
        } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
          body = fileBody;
          body.append("cacheControl", options.cacheControl);
        } else {
          body = fileBody;
          headers["cache-control"] = `max-age=${options.cacheControl}`;
          headers["content-type"] = options.contentType;
        }
        const res = yield this.fetch(url.toString(), {
          method: "PUT",
          body,
          headers
        });
        const data = yield res.json();
        if (res.ok) {
          return {
            data: { path: cleanPath, fullPath: data.Key },
            error: null
          };
        } else {
          const error = data;
          return { data: null, error };
        }
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a signed upload URL.
   * Signed upload URLs can be used to upload files to the bucket without further authentication.
   * They are valid for 2 hours.
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param options.upsert If set to true, allows the file to be overwritten if it already exists.
   */
  createSignedUploadUrl(path, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        const headers = Object.assign({}, this.headers);
        if (options === null || options === void 0 ? void 0 : options.upsert) {
          headers["x-upsert"] = "true";
        }
        const data = yield post(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, { headers });
        const url = new URL(this.url + data.url);
        const token = url.searchParams.get("token");
        if (!token) {
          throw new StorageError("No token returned by API");
        }
        return { data: { signedUrl: url.toString(), path, token }, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Replaces an existing file at the specified path with a new one.
   *
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  update(path, fileBody, fileOptions) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("PUT", path, fileBody, fileOptions);
    });
  }
  /**
   * Moves an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
   * @param options The destination options.
   */
  move(fromPath, toPath, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/object/move`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath,
          destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Copies an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
   * @param options The destination options.
   */
  copy(fromPath, toPath, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/object/copy`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath,
          destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
        }, { headers: this.headers });
        return { data: { path: data.Key }, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  createSignedUrl(path, expiresIn, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        let data = yield post(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({ expiresIn }, (options === null || options === void 0 ? void 0 : options.transform) ? { transform: options.transform } : {}), { headers: this.headers });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
        const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);
        data = { signedUrl };
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   */
  createSignedUrls(paths, expiresIn, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
        return {
          data: data.map((datum) => Object.assign(Object.assign({}, datum), { signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null })),
          error: null
        };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
   *
   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
   * @param options.transform Transform the asset before serving it to the client.
   */
  download(path, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
      const renderPath = wantsTransformation ? "render/image/authenticated" : "object";
      const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
      const queryString = transformationQuery ? `?${transformationQuery}` : "";
      try {
        const _path = this._getFinalPath(path);
        const res = yield get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {
          headers: this.headers,
          noResolveJson: true
        });
        const data = yield res.blob();
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the details of an existing file.
   * @param path
   */
  info(path) {
    return __awaiter4(this, void 0, void 0, function* () {
      const _path = this._getFinalPath(path);
      try {
        const data = yield get(this.fetch, `${this.url}/object/info/${_path}`, {
          headers: this.headers
        });
        return { data: recursiveToCamel(data), error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Checks the existence of a file.
   * @param path
   */
  exists(path) {
    return __awaiter4(this, void 0, void 0, function* () {
      const _path = this._getFinalPath(path);
      try {
        yield head(this.fetch, `${this.url}/object/${_path}`, {
          headers: this.headers
        });
        return { data: true, error: null };
      } catch (error) {
        if (isStorageError(error) && error instanceof StorageUnknownError) {
          const originalError = error.originalError;
          if ([400, 404].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) {
            return { data: false, error };
          }
        }
        throw error;
      }
    });
  }
  /**
   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
   *
   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  getPublicUrl(path, options) {
    const _path = this._getFinalPath(path);
    const _queryString = [];
    const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? "" : options.download}` : "";
    if (downloadQueryParam !== "") {
      _queryString.push(downloadQueryParam);
    }
    const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
    const renderPath = wantsTransformation ? "render/image" : "object";
    const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
    if (transformationQuery !== "") {
      _queryString.push(transformationQuery);
    }
    let queryString = _queryString.join("&");
    if (queryString !== "") {
      queryString = `?${queryString}`;
    }
    return {
      data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) }
    };
  }
  /**
   * Deletes files within the same bucket
   *
   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
   */
  remove(paths) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Get file metadata
   * @param id the file id to retrieve metadata
   */
  // async getMetadata(
  //   id: string
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Update file metadata
   * @param id the file id to update metadata
   * @param meta the new file metadata
   */
  // async updateMetadata(
  //   id: string,
  //   meta: Metadata
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await post(
  //       this.fetch,
  //       `${this.url}/metadata/${id}`,
  //       { ...meta },
  //       { headers: this.headers }
  //     )
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Lists all the files within a bucket.
   * @param path The folder path.
   */
  list(path, options, parameters) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || "" });
        const data = yield post(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  encodeMetadata(metadata) {
    return JSON.stringify(metadata);
  }
  toBase64(data) {
    if (typeof Buffer !== "undefined") {
      return Buffer.from(data).toString("base64");
    }
    return btoa(data);
  }
  _getFinalPath(path) {
    return `${this.bucketId}/${path}`;
  }
  _removeEmptyFolders(path) {
    return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
  }
  transformOptsToQueryString(transform) {
    const params = [];
    if (transform.width) {
      params.push(`width=${transform.width}`);
    }
    if (transform.height) {
      params.push(`height=${transform.height}`);
    }
    if (transform.resize) {
      params.push(`resize=${transform.resize}`);
    }
    if (transform.format) {
      params.push(`format=${transform.format}`);
    }
    if (transform.quality) {
      params.push(`quality=${transform.quality}`);
    }
    return params.join("&");
  }
};

// node_modules/@supabase/storage-js/dist/module/lib/version.js
var version2 = "2.7.1";

// node_modules/@supabase/storage-js/dist/module/lib/constants.js
var DEFAULT_HEADERS2 = { "X-Client-Info": `storage-js/${version2}` };

// node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var StorageBucketApi = class {
  constructor(url, headers = {}, fetch4) {
    this.url = url;
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS2), headers);
    this.fetch = resolveFetch2(fetch4);
  }
  /**
   * Retrieves the details of all Storage buckets within an existing project.
   */
  listBuckets() {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield get(this.fetch, `${this.url}/bucket`, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the details of an existing Storage bucket.
   *
   * @param id The unique identifier of the bucket you would like to retrieve.
   */
  getBucket(id) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a new Storage bucket
   *
   * @param id A unique identifier for the bucket you are creating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   * @returns newly created bucket id
   */
  createBucket(id, options = {
    public: false
  }) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/bucket`, {
          id,
          name: id,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Updates a Storage bucket
   *
   * @param id A unique identifier for the bucket you are updating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   */
  updateBucket(id, options) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield put(this.fetch, `${this.url}/bucket/${id}`, {
          id,
          name: id,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Removes all objects inside a single bucket.
   *
   * @param id The unique identifier of the bucket you would like to empty.
   */
  emptyBucket(id) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
   * You must first `empty()` the bucket.
   *
   * @param id The unique identifier of the bucket you would like to delete.
   */
  deleteBucket(id) {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
};

// node_modules/@supabase/storage-js/dist/module/StorageClient.js
var StorageClient = class extends StorageBucketApi {
  constructor(url, headers = {}, fetch4) {
    super(url, headers, fetch4);
  }
  /**
   * Perform file operation in a bucket.
   *
   * @param id The bucket id to operate on.
   */
  from(id) {
    return new StorageFileApi(this.url, this.headers, id, this.fetch);
  }
};

// node_modules/@supabase/supabase-js/dist/module/lib/version.js
var version3 = "2.47.16";

// node_modules/@supabase/supabase-js/dist/module/lib/constants.js
var JS_ENV = "";
if (typeof Deno !== "undefined") {
  JS_ENV = "deno";
} else if (typeof document !== "undefined") {
  JS_ENV = "web";
} else if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
  JS_ENV = "react-native";
} else {
  JS_ENV = "node";
}
var DEFAULT_HEADERS3 = { "X-Client-Info": `supabase-js-${JS_ENV}/${version3}` };
var DEFAULT_GLOBAL_OPTIONS = {
  headers: DEFAULT_HEADERS3
};
var DEFAULT_DB_OPTIONS = {
  schema: "public"
};
var DEFAULT_AUTH_OPTIONS = {
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  flowType: "implicit"
};
var DEFAULT_REALTIME_OPTIONS = {};

// node_modules/@supabase/supabase-js/dist/module/lib/fetch.js
init_browser();
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var resolveFetch3 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = browser_default;
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
var resolveHeadersConstructor = () => {
  if (typeof Headers === "undefined") {
    return Headers2;
  }
  return Headers;
};
var fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {
  const fetch4 = resolveFetch3(customFetch);
  const HeadersConstructor = resolveHeadersConstructor();
  return (input, init) => __awaiter6(void 0, void 0, void 0, function* () {
    var _a2;
    const accessToken = (_a2 = yield getAccessToken()) !== null && _a2 !== void 0 ? _a2 : supabaseKey;
    let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
    if (!headers.has("apikey")) {
      headers.set("apikey", supabaseKey);
    }
    if (!headers.has("Authorization")) {
      headers.set("Authorization", `Bearer ${accessToken}`);
    }
    return fetch4(input, Object.assign(Object.assign({}, init), { headers }));
  });
};

// node_modules/@supabase/supabase-js/dist/module/lib/helpers.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function stripTrailingSlash(url) {
  return url.replace(/\/$/, "");
}
function applySettingDefaults(options, defaults2) {
  const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;
  const { db: DEFAULT_DB_OPTIONS2, auth: DEFAULT_AUTH_OPTIONS2, realtime: DEFAULT_REALTIME_OPTIONS2, global: DEFAULT_GLOBAL_OPTIONS2 } = defaults2;
  const result = {
    db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS2), dbOptions),
    auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS2), authOptions),
    realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS2), realtimeOptions),
    global: Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS2), globalOptions),
    accessToken: () => __awaiter7(this, void 0, void 0, function* () {
      return "";
    })
  };
  if (options.accessToken) {
    result.accessToken = options.accessToken;
  } else {
    delete result.accessToken;
  }
  return result;
}

// node_modules/@supabase/auth-js/dist/module/lib/version.js
var version4 = "2.67.3";

// node_modules/@supabase/auth-js/dist/module/lib/constants.js
var GOTRUE_URL = "http://localhost:9999";
var STORAGE_KEY = "supabase.auth.token";
var DEFAULT_HEADERS4 = { "X-Client-Info": `gotrue-js/${version4}` };
var EXPIRY_MARGIN = 10;
var API_VERSION_HEADER_NAME = "X-Supabase-Api-Version";
var API_VERSIONS = {
  "2024-01-01": {
    timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
    name: "2024-01-01"
  }
};

// node_modules/@supabase/auth-js/dist/module/lib/helpers.js
function expiresAt(expiresIn) {
  const timeNow = Math.round(Date.now() / 1e3);
  return timeNow + expiresIn;
}
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
var isBrowser = () => typeof window !== "undefined" && typeof document !== "undefined";
var localStorageWriteTests = {
  tested: false,
  writable: false
};
var supportsLocalStorage = () => {
  if (!isBrowser()) {
    return false;
  }
  try {
    if (typeof globalThis.localStorage !== "object") {
      return false;
    }
  } catch (e) {
    return false;
  }
  if (localStorageWriteTests.tested) {
    return localStorageWriteTests.writable;
  }
  const randomKey = `lswt-${Math.random()}${Math.random()}`;
  try {
    globalThis.localStorage.setItem(randomKey, randomKey);
    globalThis.localStorage.removeItem(randomKey);
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = true;
  } catch (e) {
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = false;
  }
  return localStorageWriteTests.writable;
};
function parseParametersFromURL(href) {
  const result = {};
  const url = new URL(href);
  if (url.hash && url.hash[0] === "#") {
    try {
      const hashSearchParams = new URLSearchParams(url.hash.substring(1));
      hashSearchParams.forEach((value, key) => {
        result[key] = value;
      });
    } catch (e) {
    }
  }
  url.searchParams.forEach((value, key) => {
    result[key] = value;
  });
  return result;
}
var resolveFetch4 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => Promise.resolve().then(() => (init_browser(), browser_exports)).then(({ default: fetch4 }) => fetch4(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
var looksLikeFetchResponse = (maybeResponse) => {
  return typeof maybeResponse === "object" && maybeResponse !== null && "status" in maybeResponse && "ok" in maybeResponse && "json" in maybeResponse && typeof maybeResponse.json === "function";
};
var setItemAsync = async (storage, key, data) => {
  await storage.setItem(key, JSON.stringify(data));
};
var getItemAsync = async (storage, key) => {
  const value = await storage.getItem(key);
  if (!value) {
    return null;
  }
  try {
    return JSON.parse(value);
  } catch (_a2) {
    return value;
  }
};
var removeItemAsync = async (storage, key) => {
  await storage.removeItem(key);
};
function decodeBase64URL(value) {
  const key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let base64 = "";
  let chr1, chr2, chr3;
  let enc1, enc2, enc3, enc4;
  let i = 0;
  value = value.replace("-", "+").replace("_", "/");
  while (i < value.length) {
    enc1 = key.indexOf(value.charAt(i++));
    enc2 = key.indexOf(value.charAt(i++));
    enc3 = key.indexOf(value.charAt(i++));
    enc4 = key.indexOf(value.charAt(i++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    base64 = base64 + String.fromCharCode(chr1);
    if (enc3 != 64 && chr2 != 0) {
      base64 = base64 + String.fromCharCode(chr2);
    }
    if (enc4 != 64 && chr3 != 0) {
      base64 = base64 + String.fromCharCode(chr3);
    }
  }
  return base64;
}
var Deferred = class {
  constructor() {
    ;
    this.promise = new Deferred.promiseConstructor((res, rej) => {
      ;
      this.resolve = res;
      this.reject = rej;
    });
  }
};
Deferred.promiseConstructor = Promise;
function decodeJWTPayload(token) {
  const base64UrlRegex = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i;
  const parts = token.split(".");
  if (parts.length !== 3) {
    throw new Error("JWT is not valid: not a JWT structure");
  }
  if (!base64UrlRegex.test(parts[1])) {
    throw new Error("JWT is not valid: payload is not in base64url format");
  }
  const base64Url = parts[1];
  return JSON.parse(decodeBase64URL(base64Url));
}
async function sleep(time) {
  return await new Promise((accept) => {
    setTimeout(() => accept(null), time);
  });
}
function retryable(fn, isRetryable) {
  const promise = new Promise((accept, reject) => {
    ;
    (async () => {
      for (let attempt = 0; attempt < Infinity; attempt++) {
        try {
          const result = await fn(attempt);
          if (!isRetryable(attempt, null, result)) {
            accept(result);
            return;
          }
        } catch (e) {
          if (!isRetryable(attempt, e)) {
            reject(e);
            return;
          }
        }
      }
    })();
  });
  return promise;
}
function dec2hex(dec) {
  return ("0" + dec.toString(16)).substr(-2);
}
function generatePKCEVerifier() {
  const verifierLength = 56;
  const array = new Uint32Array(verifierLength);
  if (typeof crypto === "undefined") {
    const charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
    const charSetLen = charSet.length;
    let verifier = "";
    for (let i = 0; i < verifierLength; i++) {
      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));
    }
    return verifier;
  }
  crypto.getRandomValues(array);
  return Array.from(array, dec2hex).join("");
}
async function sha256(randomString) {
  const encoder = new TextEncoder();
  const encodedData = encoder.encode(randomString);
  const hash = await crypto.subtle.digest("SHA-256", encodedData);
  const bytes = new Uint8Array(hash);
  return Array.from(bytes).map((c) => String.fromCharCode(c)).join("");
}
function base64urlencode(str2) {
  return btoa(str2).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function generatePKCEChallenge(verifier) {
  const hasCryptoSupport = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined" && typeof TextEncoder !== "undefined";
  if (!hasCryptoSupport) {
    console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.");
    return verifier;
  }
  const hashed = await sha256(verifier);
  return base64urlencode(hashed);
}
async function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {
  const codeVerifier = generatePKCEVerifier();
  let storedCodeVerifier = codeVerifier;
  if (isPasswordRecovery) {
    storedCodeVerifier += "/PASSWORD_RECOVERY";
  }
  await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);
  const codeChallenge = await generatePKCEChallenge(codeVerifier);
  const codeChallengeMethod = codeVerifier === codeChallenge ? "plain" : "s256";
  return [codeChallenge, codeChallengeMethod];
}
var API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function parseResponseAPIVersion(response) {
  const apiVersion = response.headers.get(API_VERSION_HEADER_NAME);
  if (!apiVersion) {
    return null;
  }
  if (!apiVersion.match(API_VERSION_REGEX)) {
    return null;
  }
  try {
    const date = new Date(`${apiVersion}T00:00:00.0Z`);
    return date;
  } catch (e) {
    return null;
  }
}

// node_modules/@supabase/auth-js/dist/module/lib/errors.js
var AuthError = class extends Error {
  constructor(message, status, code) {
    super(message);
    this.__isAuthError = true;
    this.name = "AuthError";
    this.status = status;
    this.code = code;
  }
};
function isAuthError(error) {
  return typeof error === "object" && error !== null && "__isAuthError" in error;
}
var AuthApiError = class extends AuthError {
  constructor(message, status, code) {
    super(message, status, code);
    this.name = "AuthApiError";
    this.status = status;
    this.code = code;
  }
};
function isAuthApiError(error) {
  return isAuthError(error) && error.name === "AuthApiError";
}
var AuthUnknownError = class extends AuthError {
  constructor(message, originalError) {
    super(message);
    this.name = "AuthUnknownError";
    this.originalError = originalError;
  }
};
var CustomAuthError = class extends AuthError {
  constructor(message, name, status, code) {
    super(message, status, code);
    this.name = name;
    this.status = status;
  }
};
var AuthSessionMissingError = class extends CustomAuthError {
  constructor() {
    super("Auth session missing!", "AuthSessionMissingError", 400, void 0);
  }
};
function isAuthSessionMissingError(error) {
  return isAuthError(error) && error.name === "AuthSessionMissingError";
}
var AuthInvalidTokenResponseError = class extends CustomAuthError {
  constructor() {
    super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0);
  }
};
var AuthInvalidCredentialsError = class extends CustomAuthError {
  constructor(message) {
    super(message, "AuthInvalidCredentialsError", 400, void 0);
  }
};
var AuthImplicitGrantRedirectError = class extends CustomAuthError {
  constructor(message, details = null) {
    super(message, "AuthImplicitGrantRedirectError", 500, void 0);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
};
function isAuthImplicitGrantRedirectError(error) {
  return isAuthError(error) && error.name === "AuthImplicitGrantRedirectError";
}
var AuthPKCEGrantCodeExchangeError = class extends CustomAuthError {
  constructor(message, details = null) {
    super(message, "AuthPKCEGrantCodeExchangeError", 500, void 0);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
};
var AuthRetryableFetchError = class extends CustomAuthError {
  constructor(message, status) {
    super(message, "AuthRetryableFetchError", status, void 0);
  }
};
function isAuthRetryableFetchError(error) {
  return isAuthError(error) && error.name === "AuthRetryableFetchError";
}
var AuthWeakPasswordError = class extends CustomAuthError {
  constructor(message, status, reasons) {
    super(message, "AuthWeakPasswordError", status, "weak_password");
    this.reasons = reasons;
  }
};

// node_modules/@supabase/auth-js/dist/module/lib/fetch.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var _getErrorMessage2 = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
var NETWORK_ERROR_CODES = [502, 503, 504];
async function handleError2(error) {
  var _a2;
  if (!looksLikeFetchResponse(error)) {
    throw new AuthRetryableFetchError(_getErrorMessage2(error), 0);
  }
  if (NETWORK_ERROR_CODES.includes(error.status)) {
    throw new AuthRetryableFetchError(_getErrorMessage2(error), error.status);
  }
  let data;
  try {
    data = await error.json();
  } catch (e) {
    throw new AuthUnknownError(_getErrorMessage2(e), e);
  }
  let errorCode = void 0;
  const responseAPIVersion = parseResponseAPIVersion(error);
  if (responseAPIVersion && responseAPIVersion.getTime() >= API_VERSIONS["2024-01-01"].timestamp && typeof data === "object" && data && typeof data.code === "string") {
    errorCode = data.code;
  } else if (typeof data === "object" && data && typeof data.error_code === "string") {
    errorCode = data.error_code;
  }
  if (!errorCode) {
    if (typeof data === "object" && data && typeof data.weak_password === "object" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
      throw new AuthWeakPasswordError(_getErrorMessage2(data), error.status, data.weak_password.reasons);
    }
  } else if (errorCode === "weak_password") {
    throw new AuthWeakPasswordError(_getErrorMessage2(data), error.status, ((_a2 = data.weak_password) === null || _a2 === void 0 ? void 0 : _a2.reasons) || []);
  } else if (errorCode === "session_not_found") {
    throw new AuthSessionMissingError();
  }
  throw new AuthApiError(_getErrorMessage2(data), error.status || 500, errorCode);
}
var _getRequestParams2 = (method, options, parameters, body) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET") {
    return params;
  }
  params.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, options === null || options === void 0 ? void 0 : options.headers);
  params.body = JSON.stringify(body);
  return Object.assign(Object.assign({}, params), parameters);
};
async function _request(fetcher, method, url, options) {
  var _a2;
  const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
  if (!headers[API_VERSION_HEADER_NAME]) {
    headers[API_VERSION_HEADER_NAME] = API_VERSIONS["2024-01-01"].name;
  }
  if (options === null || options === void 0 ? void 0 : options.jwt) {
    headers["Authorization"] = `Bearer ${options.jwt}`;
  }
  const qs = (_a2 = options === null || options === void 0 ? void 0 : options.query) !== null && _a2 !== void 0 ? _a2 : {};
  if (options === null || options === void 0 ? void 0 : options.redirectTo) {
    qs["redirect_to"] = options.redirectTo;
  }
  const queryString = Object.keys(qs).length ? "?" + new URLSearchParams(qs).toString() : "";
  const data = await _handleRequest2(fetcher, method, url + queryString, {
    headers,
    noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson
  }, {}, options === null || options === void 0 ? void 0 : options.body);
  return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };
}
async function _handleRequest2(fetcher, method, url, options, parameters, body) {
  const requestParams = _getRequestParams2(method, options, parameters, body);
  let result;
  try {
    result = await fetcher(url, Object.assign({}, requestParams));
  } catch (e) {
    console.error(e);
    throw new AuthRetryableFetchError(_getErrorMessage2(e), 0);
  }
  if (!result.ok) {
    await handleError2(result);
  }
  if (options === null || options === void 0 ? void 0 : options.noResolveJson) {
    return result;
  }
  try {
    return await result.json();
  } catch (e) {
    await handleError2(e);
  }
}
function _sessionResponse(data) {
  var _a2;
  let session = null;
  if (hasSession(data)) {
    session = Object.assign({}, data);
    if (!data.expires_at) {
      session.expires_at = expiresAt(data.expires_in);
    }
  }
  const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
  return { data: { session, user }, error: null };
}
function _sessionResponsePassword(data) {
  const response = _sessionResponse(data);
  if (!response.error && data.weak_password && typeof data.weak_password === "object" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === "string" && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
    response.data.weak_password = data.weak_password;
  }
  return response;
}
function _userResponse(data) {
  var _a2;
  const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
  return { data: { user }, error: null };
}
function _ssoResponse(data) {
  return { data, error: null };
}
function _generateLinkResponse(data) {
  const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
  const properties = {
    action_link,
    email_otp,
    hashed_token,
    redirect_to,
    verification_type
  };
  const user = Object.assign({}, rest);
  return {
    data: {
      properties,
      user
    },
    error: null
  };
}
function _noResolveJsonResponse(data) {
  return data;
}
function hasSession(data) {
  return data.access_token && data.refresh_token && data.expires_in;
}

// node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var GoTrueAdminApi = class {
  constructor({ url = "", headers = {}, fetch: fetch4 }) {
    this.url = url;
    this.headers = headers;
    this.fetch = resolveFetch4(fetch4);
    this.mfa = {
      listFactors: this._listFactors.bind(this),
      deleteFactor: this._deleteFactor.bind(this)
    };
  }
  /**
   * Removes a logged-in session.
   * @param jwt A valid, logged-in JWT.
   * @param scope The logout sope.
   */
  async signOut(jwt, scope = "global") {
    try {
      await _request(this.fetch, "POST", `${this.url}/logout?scope=${scope}`, {
        headers: this.headers,
        jwt,
        noResolveJson: true
      });
      return { data: null, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Sends an invite link to an email address.
   * @param email The email address of the user.
   * @param options Additional options to be included when inviting.
   */
  async inviteUserByEmail(email, options = {}) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/invite`, {
        body: { email, data: options.data },
        headers: this.headers,
        redirectTo: options.redirectTo,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Generates email links and OTPs to be sent via a custom email provider.
   * @param email The user's email.
   * @param options.password User password. For signup only.
   * @param options.data Optional user metadata. For signup only.
   * @param options.redirectTo The redirect url which should be appended to the generated link
   */
  async generateLink(params) {
    try {
      const { options } = params, rest = __rest2(params, ["options"]);
      const body = Object.assign(Object.assign({}, rest), options);
      if ("newEmail" in rest) {
        body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;
        delete body["newEmail"];
      }
      return await _request(this.fetch, "POST", `${this.url}/admin/generate_link`, {
        body,
        headers: this.headers,
        xform: _generateLinkResponse,
        redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo
      });
    } catch (error) {
      if (isAuthError(error)) {
        return {
          data: {
            properties: null,
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  // User Admin API
  /**
   * Creates a new user.
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async createUser(attributes) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/admin/users`, {
        body: attributes,
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Get a list of users.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
   */
  async listUsers(params) {
    var _a2, _b, _c, _d, _e, _f, _g;
    try {
      const pagination = { nextPage: null, lastPage: 0, total: 0 };
      const response = await _request(this.fetch, "GET", `${this.url}/admin/users`, {
        headers: this.headers,
        noResolveJson: true,
        query: {
          page: (_b = (_a2 = params === null || params === void 0 ? void 0 : params.page) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : "",
          per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
        },
        xform: _noResolveJsonResponse
      });
      if (response.error)
        throw response.error;
      const users = await response.json();
      const total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
      const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
      if (links.length > 0) {
        links.forEach((link) => {
          const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
          const rel = JSON.parse(link.split(";")[1].split("=")[1]);
          pagination[`${rel}Page`] = page;
        });
        pagination.total = parseInt(total);
      }
      return { data: Object.assign(Object.assign({}, users), pagination), error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { users: [] }, error };
      }
      throw error;
    }
  }
  /**
   * Get user by id.
   *
   * @param uid The user's unique identifier
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async getUserById(uid) {
    try {
      return await _request(this.fetch, "GET", `${this.url}/admin/users/${uid}`, {
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Updates the user data.
   *
   * @param attributes The data you want to update.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async updateUserById(uid, attributes) {
    try {
      return await _request(this.fetch, "PUT", `${this.url}/admin/users/${uid}`, {
        body: attributes,
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Delete a user. Requires a `service_role` key.
   *
   * @param id The user id you want to remove.
   * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.
   * Defaults to false for backward compatibility.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async deleteUser(id, shouldSoftDelete = false) {
    try {
      return await _request(this.fetch, "DELETE", `${this.url}/admin/users/${id}`, {
        headers: this.headers,
        body: {
          should_soft_delete: shouldSoftDelete
        },
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  async _listFactors(params) {
    try {
      const { data, error } = await _request(this.fetch, "GET", `${this.url}/admin/users/${params.userId}/factors`, {
        headers: this.headers,
        xform: (factors) => {
          return { data: { factors }, error: null };
        }
      });
      return { data, error };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  async _deleteFactor(params) {
    try {
      const data = await _request(this.fetch, "DELETE", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {
        headers: this.headers
      });
      return { data, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
};

// node_modules/@supabase/auth-js/dist/module/lib/local-storage.js
var localStorageAdapter = {
  getItem: (key) => {
    if (!supportsLocalStorage()) {
      return null;
    }
    return globalThis.localStorage.getItem(key);
  },
  setItem: (key, value) => {
    if (!supportsLocalStorage()) {
      return;
    }
    globalThis.localStorage.setItem(key, value);
  },
  removeItem: (key) => {
    if (!supportsLocalStorage()) {
      return;
    }
    globalThis.localStorage.removeItem(key);
  }
};
function memoryLocalStorageAdapter(store = {}) {
  return {
    getItem: (key) => {
      return store[key] || null;
    },
    setItem: (key, value) => {
      store[key] = value;
    },
    removeItem: (key) => {
      delete store[key];
    }
  };
}

// node_modules/@supabase/auth-js/dist/module/lib/polyfills.js
function polyfillGlobalThis() {
  if (typeof globalThis === "object")
    return;
  try {
    Object.defineProperty(Object.prototype, "__magic__", {
      get: function() {
        return this;
      },
      configurable: true
    });
    __magic__.globalThis = __magic__;
    delete Object.prototype.__magic__;
  } catch (e) {
    if (typeof self !== "undefined") {
      self.globalThis = self;
    }
  }
}

// node_modules/@supabase/auth-js/dist/module/lib/locks.js
var internals = {
  /**
   * @experimental
   */
  debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
var LockAcquireTimeoutError = class extends Error {
  constructor(message) {
    super(message);
    this.isAcquireTimeout = true;
  }
};
var NavigatorLockAcquireTimeoutError = class extends LockAcquireTimeoutError {
};
async function navigatorLock(name, acquireTimeout, fn) {
  if (internals.debug) {
    console.log("@supabase/gotrue-js: navigatorLock: acquire lock", name, acquireTimeout);
  }
  const abortController = new globalThis.AbortController();
  if (acquireTimeout > 0) {
    setTimeout(() => {
      abortController.abort();
      if (internals.debug) {
        console.log("@supabase/gotrue-js: navigatorLock acquire timed out", name);
      }
    }, acquireTimeout);
  }
  return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {
    mode: "exclusive",
    ifAvailable: true
  } : {
    mode: "exclusive",
    signal: abortController.signal
  }, async (lock) => {
    if (lock) {
      if (internals.debug) {
        console.log("@supabase/gotrue-js: navigatorLock: acquired", name, lock.name);
      }
      try {
        return await fn();
      } finally {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: released", name, lock.name);
        }
      }
    } else {
      if (acquireTimeout === 0) {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: not immediately available", name);
        }
        throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock "${name}" immediately failed`);
      } else {
        if (internals.debug) {
          try {
            const result = await globalThis.navigator.locks.query();
            console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(result, null, "  "));
          } catch (e) {
            console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", e);
          }
        }
        console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request");
        return await fn();
      }
    }
  }));
}

// node_modules/@supabase/auth-js/dist/module/GoTrueClient.js
polyfillGlobalThis();
var DEFAULT_OPTIONS = {
  url: GOTRUE_URL,
  storageKey: STORAGE_KEY,
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  headers: DEFAULT_HEADERS4,
  flowType: "implicit",
  debug: false,
  hasCustomAuthorizationHeader: false
};
var AUTO_REFRESH_TICK_DURATION = 30 * 1e3;
var AUTO_REFRESH_TICK_THRESHOLD = 3;
async function lockNoOp(name, acquireTimeout, fn) {
  return await fn();
}
var GoTrueClient = class {
  /**
   * Create a new client for use in the browser.
   */
  constructor(options) {
    var _a2, _b;
    this.memoryStorage = null;
    this.stateChangeEmitters = /* @__PURE__ */ new Map();
    this.autoRefreshTicker = null;
    this.visibilityChangedCallback = null;
    this.refreshingDeferred = null;
    this.initializePromise = null;
    this.detectSessionInUrl = true;
    this.hasCustomAuthorizationHeader = false;
    this.suppressGetSessionWarning = false;
    this.lockAcquired = false;
    this.pendingInLock = [];
    this.broadcastChannel = null;
    this.logger = console.log;
    this.instanceID = GoTrueClient.nextInstanceID;
    GoTrueClient.nextInstanceID += 1;
    if (this.instanceID > 0 && isBrowser()) {
      console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");
    }
    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    this.logDebugMessages = !!settings.debug;
    if (typeof settings.debug === "function") {
      this.logger = settings.debug;
    }
    this.persistSession = settings.persistSession;
    this.storageKey = settings.storageKey;
    this.autoRefreshToken = settings.autoRefreshToken;
    this.admin = new GoTrueAdminApi({
      url: settings.url,
      headers: settings.headers,
      fetch: settings.fetch
    });
    this.url = settings.url;
    this.headers = settings.headers;
    this.fetch = resolveFetch4(settings.fetch);
    this.lock = settings.lock || lockNoOp;
    this.detectSessionInUrl = settings.detectSessionInUrl;
    this.flowType = settings.flowType;
    this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;
    if (settings.lock) {
      this.lock = settings.lock;
    } else if (isBrowser() && ((_a2 = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a2 === void 0 ? void 0 : _a2.locks)) {
      this.lock = navigatorLock;
    } else {
      this.lock = lockNoOp;
    }
    this.mfa = {
      verify: this._verify.bind(this),
      enroll: this._enroll.bind(this),
      unenroll: this._unenroll.bind(this),
      challenge: this._challenge.bind(this),
      listFactors: this._listFactors.bind(this),
      challengeAndVerify: this._challengeAndVerify.bind(this),
      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)
    };
    if (this.persistSession) {
      if (settings.storage) {
        this.storage = settings.storage;
      } else {
        if (supportsLocalStorage()) {
          this.storage = localStorageAdapter;
        } else {
          this.memoryStorage = {};
          this.storage = memoryLocalStorageAdapter(this.memoryStorage);
        }
      }
    } else {
      this.memoryStorage = {};
      this.storage = memoryLocalStorageAdapter(this.memoryStorage);
    }
    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
      } catch (e) {
        console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", e);
      }
      (_b = this.broadcastChannel) === null || _b === void 0 ? void 0 : _b.addEventListener("message", async (event) => {
        this._debug("received broadcast notification from other tab or client", event);
        await this._notifyAllSubscribers(event.data.event, event.data.session, false);
      });
    }
    this.initialize();
  }
  _debug(...args) {
    if (this.logDebugMessages) {
      this.logger(`GoTrueClient@${this.instanceID} (${version4}) ${new Date().toISOString()}`, ...args);
    }
    return this;
  }
  /**
   * Initializes the client session either from the url or from storage.
   * This method is automatically called when instantiating the client, but should also be called
   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
   */
  async initialize() {
    if (this.initializePromise) {
      return await this.initializePromise;
    }
    this.initializePromise = (async () => {
      return await this._acquireLock(-1, async () => {
        return await this._initialize();
      });
    })();
    return await this.initializePromise;
  }
  /**
   * IMPORTANT:
   * 1. Never throw in this method, as it is called from the constructor
   * 2. Never return a session from this method as it would be cached over
   *    the whole lifetime of the client
   */
  async _initialize() {
    var _a2;
    try {
      const params = parseParametersFromURL(window.location.href);
      let callbackUrlType = "none";
      if (this._isImplicitGrantCallback(params)) {
        callbackUrlType = "implicit";
      } else if (await this._isPKCECallback(params)) {
        callbackUrlType = "pkce";
      }
      if (isBrowser() && this.detectSessionInUrl && callbackUrlType !== "none") {
        const { data, error } = await this._getSessionFromURL(params, callbackUrlType);
        if (error) {
          this._debug("#_initialize()", "error detecting session from URL", error);
          if (isAuthImplicitGrantRedirectError(error)) {
            const errorCode = (_a2 = error.details) === null || _a2 === void 0 ? void 0 : _a2.code;
            if (errorCode === "identity_already_exists" || errorCode === "identity_not_found" || errorCode === "single_identity_not_deletable") {
              return { error };
            }
          }
          await this._removeSession();
          return { error };
        }
        const { session, redirectType } = data;
        this._debug("#_initialize()", "detected session in URL", session, "redirect type", redirectType);
        await this._saveSession(session);
        setTimeout(async () => {
          if (redirectType === "recovery") {
            await this._notifyAllSubscribers("PASSWORD_RECOVERY", session);
          } else {
            await this._notifyAllSubscribers("SIGNED_IN", session);
          }
        }, 0);
        return { error: null };
      }
      await this._recoverAndRefresh();
      return { error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { error };
      }
      return {
        error: new AuthUnknownError("Unexpected error during initialization", error)
      };
    } finally {
      await this._handleVisibilityChange();
      this._debug("#_initialize()", "end");
    }
  }
  /**
   * Creates a new anonymous user.
   *
   * @returns A session where the is_anonymous claim in the access token JWT set to true
   */
  async signInAnonymously(credentials) {
    var _a2, _b, _c;
    try {
      const res = await _request(this.fetch, "POST", `${this.url}/signup`, {
        headers: this.headers,
        body: {
          data: (_b = (_a2 = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a2 === void 0 ? void 0 : _a2.data) !== null && _b !== void 0 ? _b : {},
          gotrue_meta_security: { captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken }
        },
        xform: _sessionResponse
      });
      const { data, error } = res;
      if (error || !data) {
        return { data: { user: null, session: null }, error };
      }
      const session = data.session;
      const user = data.user;
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return { data: { user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Creates a new user.
   *
   * Be aware that if a user account exists in the system you may get back an
   * error message that attempts to hide this information from the user.
   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
   *
   * @returns A logged-in session if the server has "autoconfirm" ON
   * @returns A user if the server has "autoconfirm" OFF
   */
  async signUp(credentials) {
    var _a2, _b, _c;
    try {
      let res;
      if ("email" in credentials) {
        const { email, password, options } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        res = await _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: {
            email,
            password,
            data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          xform: _sessionResponse
        });
      } else if ("phone" in credentials) {
        const { phone, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone,
            password,
            data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},
            channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : "sms",
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponse
        });
      } else {
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
      }
      const { data, error } = res;
      if (error || !data) {
        return { data: { user: null, session: null }, error };
      }
      const session = data.session;
      const user = data.user;
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return { data: { user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in an existing user with an email and password or phone and password.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or that the
   * email/phone and password combination is wrong or that the account can only
   * be accessed via social login.
   */
  async signInWithPassword(credentials) {
    try {
      let res;
      if ("email" in credentials) {
        const { email, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            email,
            password,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponsePassword
        });
      } else if ("phone" in credentials) {
        const { phone, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            phone,
            password,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponsePassword
        });
      } else {
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
      }
      const { data, error } = res;
      if (error) {
        return { data: { user: null, session: null }, error };
      } else if (!data || !data.session || !data.user) {
        return { data: { user: null, session: null }, error: new AuthInvalidTokenResponseError() };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return {
        data: Object.assign({ user: data.user, session: data.session }, data.weak_password ? { weakPassword: data.weak_password } : null),
        error
      };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in an existing user via a third-party provider.
   * This method supports the PKCE flow.
   */
  async signInWithOAuth(credentials) {
    var _a2, _b, _c, _d;
    return await this._handleProviderSignIn(credentials.provider, {
      redirectTo: (_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo,
      scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
      queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
      skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect
    });
  }
  /**
   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
   */
  async exchangeCodeForSession(authCode) {
    await this.initializePromise;
    return this._acquireLock(-1, async () => {
      return this._exchangeCodeForSession(authCode);
    });
  }
  async _exchangeCodeForSession(authCode) {
    const storageItem = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : "").split("/");
    try {
      const { data, error } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
        headers: this.headers,
        body: {
          auth_code: authCode,
          code_verifier: codeVerifier
        },
        xform: _sessionResponse
      });
      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      if (error) {
        throw error;
      }
      if (!data || !data.session || !data.user) {
        return {
          data: { user: null, session: null, redirectType: null },
          error: new AuthInvalidTokenResponseError()
        };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return { data: Object.assign(Object.assign({}, data), { redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null }), error };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null, redirectType: null }, error };
      }
      throw error;
    }
  }
  /**
   * Allows signing in with an OIDC ID token. The authentication provider used
   * should be enabled and configured.
   */
  async signInWithIdToken(credentials) {
    try {
      const { options, provider, token, access_token, nonce } = credentials;
      const res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
        headers: this.headers,
        body: {
          provider,
          id_token: token,
          access_token,
          nonce,
          gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
        },
        xform: _sessionResponse
      });
      const { data, error } = res;
      if (error) {
        return { data: { user: null, session: null }, error };
      } else if (!data || !data.session || !data.user) {
        return {
          data: { user: null, session: null },
          error: new AuthInvalidTokenResponseError()
        };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return { data, error };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in a user using magiclink or a one-time password (OTP).
   *
   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or, that the account
   * can only be accessed via social login.
   *
   * Do note that you will need to configure a Whatsapp sender on Twilio
   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
   * channel is not supported on other providers
   * at this time.
   * This method supports PKCE when an email is passed.
   */
  async signInWithOtp(credentials) {
    var _a2, _b, _c, _d, _e;
    try {
      if ("email" in credentials) {
        const { email, options } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        const { error } = await _request(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email,
            data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
            create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return { data: { user: null, session: null }, error };
      }
      if ("phone" in credentials) {
        const { phone, options } = credentials;
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            phone,
            data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},
            create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : "sms"
          }
        });
        return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error };
      }
      throw new AuthInvalidCredentialsError("You must provide either an email or phone number.");
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in a user given a User supplied OTP or TokenHash received through mobile or email.
   */
  async verifyOtp(params) {
    var _a2, _b;
    try {
      let redirectTo = void 0;
      let captchaToken = void 0;
      if ("options" in params) {
        redirectTo = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo;
        captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;
      }
      const { data, error } = await _request(this.fetch, "POST", `${this.url}/verify`, {
        headers: this.headers,
        body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: captchaToken } }),
        redirectTo,
        xform: _sessionResponse
      });
      if (error) {
        throw error;
      }
      if (!data) {
        throw new Error("An error occurred on token verification.");
      }
      const session = data.session;
      const user = data.user;
      if (session === null || session === void 0 ? void 0 : session.access_token) {
        await this._saveSession(session);
        await this._notifyAllSubscribers(params.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", session);
      }
      return { data: { user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Attempts a single-sign on using an enterprise Identity Provider. A
   * successful SSO attempt will redirect the current page to the identity
   * provider authorization page. The redirect URL is implementation and SSO
   * protocol specific.
   *
   * You can use it by providing a SSO domain. Typically you can extract this
   * domain by asking users for their email address. If this domain is
   * registered on the Auth instance the redirect will use that organization's
   * currently active SSO Identity Provider for the login.
   *
   * If you have built an organization-specific login page, you can use the
   * organization's SSO Identity Provider UUID directly instead.
   */
  async signInWithSSO(params) {
    var _a2, _b, _c;
    try {
      let codeChallenge = null;
      let codeChallengeMethod = null;
      if (this.flowType === "pkce") {
        ;
        [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
      }
      return await _request(this.fetch, "POST", `${this.url}/sso`, {
        body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in params ? { provider_id: params.providerId } : null), "domain" in params ? { domain: params.domain } : null), { redirect_to: (_b = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo) !== null && _b !== void 0 ? _b : void 0 }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } } : null), { skip_http_redirect: true, code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
        headers: this.headers,
        xform: _ssoResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Sends a reauthentication OTP to the user's email or phone number.
   * Requires the user to be signed-in.
   */
  async reauthenticate() {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._reauthenticate();
    });
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError)
          throw sessionError;
        if (!session)
          throw new AuthSessionMissingError();
        const { error } = await _request(this.fetch, "GET", `${this.url}/reauthenticate`, {
          headers: this.headers,
          jwt: session.access_token
        });
        return { data: { user: null, session: null }, error };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
   */
  async resend(credentials) {
    try {
      const endpoint = `${this.url}/resend`;
      if ("email" in credentials) {
        const { email, type, options } = credentials;
        const { error } = await _request(this.fetch, "POST", endpoint, {
          headers: this.headers,
          body: {
            email,
            type,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return { data: { user: null, session: null }, error };
      } else if ("phone" in credentials) {
        const { phone, type, options } = credentials;
        const { data, error } = await _request(this.fetch, "POST", endpoint, {
          headers: this.headers,
          body: {
            phone,
            type,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          }
        });
        return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error };
      }
      throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a type");
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Returns the session, refreshing it if necessary.
   *
   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
   *
   * **IMPORTANT:** This method loads values directly from the storage attached
   * to the client. If that storage is based on request cookies for example,
   * the values in it may not be authentic and therefore it's strongly advised
   * against using this method and its results in such circumstances. A warning
   * will be emitted if this is detected. Use {@link #getUser()} instead.
   */
  async getSession() {
    await this.initializePromise;
    const result = await this._acquireLock(-1, async () => {
      return this._useSession(async (result2) => {
        return result2;
      });
    });
    return result;
  }
  /**
   * Acquires a global lock based on the storage key.
   */
  async _acquireLock(acquireTimeout, fn) {
    this._debug("#_acquireLock", "begin", acquireTimeout);
    try {
      if (this.lockAcquired) {
        const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
        const result = (async () => {
          await last;
          return await fn();
        })();
        this.pendingInLock.push((async () => {
          try {
            await result;
          } catch (e) {
          }
        })());
        return result;
      }
      return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async () => {
        this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
        try {
          this.lockAcquired = true;
          const result = fn();
          this.pendingInLock.push((async () => {
            try {
              await result;
            } catch (e) {
            }
          })());
          await result;
          while (this.pendingInLock.length) {
            const waitOn = [...this.pendingInLock];
            await Promise.all(waitOn);
            this.pendingInLock.splice(0, waitOn.length);
          }
          return await result;
        } finally {
          this._debug("#_acquireLock", "lock released for storage key", this.storageKey);
          this.lockAcquired = false;
        }
      });
    } finally {
      this._debug("#_acquireLock", "end");
    }
  }
  /**
   * Use instead of {@link #getSession} inside the library. It is
   * semantically usually what you want, as getting a session involves some
   * processing afterwards that requires only one client operating on the
   * session at once across multiple tabs or processes.
   */
  async _useSession(fn) {
    this._debug("#_useSession", "begin");
    try {
      const result = await this.__loadSession();
      return await fn(result);
    } finally {
      this._debug("#_useSession", "end");
    }
  }
  /**
   * NEVER USE DIRECTLY!
   *
   * Always use {@link #_useSession}.
   */
  async __loadSession() {
    this._debug("#__loadSession()", "begin");
    if (!this.lockAcquired) {
      this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
    }
    try {
      let currentSession = null;
      const maybeSession = await getItemAsync(this.storage, this.storageKey);
      this._debug("#getSession()", "session from storage", maybeSession);
      if (maybeSession !== null) {
        if (this._isValidSession(maybeSession)) {
          currentSession = maybeSession;
        } else {
          this._debug("#getSession()", "session from storage is not valid");
          await this._removeSession();
        }
      }
      if (!currentSession) {
        return { data: { session: null }, error: null };
      }
      const hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1e3 : false;
      this._debug("#__loadSession()", `session has${hasExpired ? "" : " not"} expired`, "expires_at", currentSession.expires_at);
      if (!hasExpired) {
        if (this.storage.isServer) {
          let suppressWarning = this.suppressGetSessionWarning;
          const proxySession = new Proxy(currentSession, {
            get: (target, prop, receiver) => {
              if (!suppressWarning && prop === "user") {
                console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.");
                suppressWarning = true;
                this.suppressGetSessionWarning = true;
              }
              return Reflect.get(target, prop, receiver);
            }
          });
          currentSession = proxySession;
        }
        return { data: { session: currentSession }, error: null };
      }
      const { session, error } = await this._callRefreshToken(currentSession.refresh_token);
      if (error) {
        return { data: { session: null }, error };
      }
      return { data: { session }, error: null };
    } finally {
      this._debug("#__loadSession()", "end");
    }
  }
  /**
   * Gets the current user details if there is an existing session. This method
   * performs a network request to the Supabase Auth server, so the returned
   * value is authentic and can be used to base authorization rules on.
   *
   * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.
   */
  async getUser(jwt) {
    if (jwt) {
      return await this._getUser(jwt);
    }
    await this.initializePromise;
    const result = await this._acquireLock(-1, async () => {
      return await this._getUser();
    });
    return result;
  }
  async _getUser(jwt) {
    try {
      if (jwt) {
        return await _request(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt,
          xform: _userResponse
        });
      }
      return await this._useSession(async (result) => {
        var _a2, _b, _c;
        const { data, error } = result;
        if (error) {
          throw error;
        }
        if (!((_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) && !this.hasCustomAuthorizationHeader) {
          return { data: { user: null }, error: new AuthSessionMissingError() };
        }
        return await _request(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : void 0,
          xform: _userResponse
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        if (isAuthSessionMissingError(error)) {
          await this._removeSession();
          await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        }
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Updates user data for a logged in user.
   */
  async updateUser(attributes, options = {}) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._updateUser(attributes, options);
    });
  }
  async _updateUser(attributes, options = {}) {
    try {
      return await this._useSession(async (result) => {
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          throw sessionError;
        }
        if (!sessionData.session) {
          throw new AuthSessionMissingError();
        }
        const session = sessionData.session;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce" && attributes.email != null) {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        const { data, error: userError } = await _request(this.fetch, "PUT", `${this.url}/user`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: Object.assign(Object.assign({}, attributes), { code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
          jwt: session.access_token,
          xform: _userResponse
        });
        if (userError)
          throw userError;
        session.user = data.user;
        await this._saveSession(session);
        await this._notifyAllSubscribers("USER_UPDATED", session);
        return { data: { user: session.user }, error: null };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Decodes a JWT (without performing any validation).
   */
  _decodeJWT(jwt) {
    return decodeJWTPayload(jwt);
  }
  /**
   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
   * If the refresh token or access token in the current session is invalid, an error will be thrown.
   * @param currentSession The current session that minimally contains an access token and refresh token.
   */
  async setSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._setSession(currentSession);
    });
  }
  async _setSession(currentSession) {
    try {
      if (!currentSession.access_token || !currentSession.refresh_token) {
        throw new AuthSessionMissingError();
      }
      const timeNow = Date.now() / 1e3;
      let expiresAt2 = timeNow;
      let hasExpired = true;
      let session = null;
      const payload = decodeJWTPayload(currentSession.access_token);
      if (payload.exp) {
        expiresAt2 = payload.exp;
        hasExpired = expiresAt2 <= timeNow;
      }
      if (hasExpired) {
        const { session: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return { data: { user: null, session: null }, error };
        }
        if (!refreshedSession) {
          return { data: { user: null, session: null }, error: null };
        }
        session = refreshedSession;
      } else {
        const { data, error } = await this._getUser(currentSession.access_token);
        if (error) {
          throw error;
        }
        session = {
          access_token: currentSession.access_token,
          refresh_token: currentSession.refresh_token,
          user: data.user,
          token_type: "bearer",
          expires_in: expiresAt2 - timeNow,
          expires_at: expiresAt2
        };
        await this._saveSession(session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return { data: { user: session.user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { session: null, user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Returns a new session, regardless of expiry status.
   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
   * If the current session's refresh token is invalid, an error will be thrown.
   * @param currentSession The current session. If passed in, it must contain a refresh token.
   */
  async refreshSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._refreshSession(currentSession);
    });
  }
  async _refreshSession(currentSession) {
    try {
      return await this._useSession(async (result) => {
        var _a2;
        if (!currentSession) {
          const { data, error: error2 } = result;
          if (error2) {
            throw error2;
          }
          currentSession = (_a2 = data.session) !== null && _a2 !== void 0 ? _a2 : void 0;
        }
        if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {
          throw new AuthSessionMissingError();
        }
        const { session, error } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return { data: { user: null, session: null }, error };
        }
        if (!session) {
          return { data: { user: null, session: null }, error: null };
        }
        return { data: { user: session.user, session }, error: null };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Gets the session data from a URL string
   */
  async _getSessionFromURL(params, callbackUrlType) {
    try {
      if (!isBrowser())
        throw new AuthImplicitGrantRedirectError("No browser detected.");
      if (params.error || params.error_description || params.error_code) {
        throw new AuthImplicitGrantRedirectError(params.error_description || "Error in URL with unspecified error_description", {
          error: params.error || "unspecified_error",
          code: params.error_code || "unspecified_code"
        });
      }
      switch (callbackUrlType) {
        case "implicit":
          if (this.flowType === "pkce") {
            throw new AuthPKCEGrantCodeExchangeError("Not a valid PKCE flow url.");
          }
          break;
        case "pkce":
          if (this.flowType === "implicit") {
            throw new AuthImplicitGrantRedirectError("Not a valid implicit grant flow url.");
          }
          break;
        default:
      }
      if (callbackUrlType === "pkce") {
        this._debug("#_initialize()", "begin", "is PKCE flow", true);
        if (!params.code)
          throw new AuthPKCEGrantCodeExchangeError("No code detected.");
        const { data: data2, error: error2 } = await this._exchangeCodeForSession(params.code);
        if (error2)
          throw error2;
        const url = new URL(window.location.href);
        url.searchParams.delete("code");
        window.history.replaceState(window.history.state, "", url.toString());
        return { data: { session: data2.session, redirectType: null }, error: null };
      }
      const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;
      if (!access_token || !expires_in || !refresh_token || !token_type) {
        throw new AuthImplicitGrantRedirectError("No session defined in URL");
      }
      const timeNow = Math.round(Date.now() / 1e3);
      const expiresIn = parseInt(expires_in);
      let expiresAt2 = timeNow + expiresIn;
      if (expires_at) {
        expiresAt2 = parseInt(expires_at);
      }
      const actuallyExpiresIn = expiresAt2 - timeNow;
      if (actuallyExpiresIn * 1e3 <= AUTO_REFRESH_TICK_DURATION) {
        console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);
      }
      const issuedAt = expiresAt2 - expiresIn;
      if (timeNow - issuedAt >= 120) {
        console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", issuedAt, expiresAt2, timeNow);
      } else if (timeNow - issuedAt < 0) {
        console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", issuedAt, expiresAt2, timeNow);
      }
      const { data, error } = await this._getUser(access_token);
      if (error)
        throw error;
      const session = {
        provider_token,
        provider_refresh_token,
        access_token,
        expires_in: expiresIn,
        expires_at: expiresAt2,
        refresh_token,
        token_type,
        user: data.user
      };
      window.location.hash = "";
      this._debug("#_getSessionFromURL()", "clearing window.location.hash");
      return { data: { session, redirectType: params.type }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { session: null, redirectType: null }, error };
      }
      throw error;
    }
  }
  /**
   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
   */
  _isImplicitGrantCallback(params) {
    return Boolean(params.access_token || params.error_description);
  }
  /**
   * Checks if the current URL and backing storage contain parameters given by a PKCE flow
   */
  async _isPKCECallback(params) {
    const currentStorageContent = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    return !!(params.code && currentStorageContent);
  }
  /**
   * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
   *
   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
   *
   * If using `others` scope, no `SIGNED_OUT` event is fired!
   */
  async signOut(options = { scope: "global" }) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._signOut(options);
    });
  }
  async _signOut({ scope } = { scope: "global" }) {
    return await this._useSession(async (result) => {
      var _a2;
      const { data, error: sessionError } = result;
      if (sessionError) {
        return { error: sessionError };
      }
      const accessToken = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token;
      if (accessToken) {
        const { error } = await this.admin.signOut(accessToken, scope);
        if (error) {
          if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401 || error.status === 403))) {
            return { error };
          }
        }
      }
      if (scope !== "others") {
        await this._removeSession();
        await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      }
      return { error: null };
    });
  }
  /**
   * Receive a notification every time an auth event happens.
   * @param callback A callback function to be invoked when an auth event happens.
   */
  onAuthStateChange(callback) {
    const id = uuid();
    const subscription = {
      id,
      callback,
      unsubscribe: () => {
        this._debug("#unsubscribe()", "state change callback with id removed", id);
        this.stateChangeEmitters.delete(id);
      }
    };
    this._debug("#onAuthStateChange()", "registered callback with id", id);
    this.stateChangeEmitters.set(id, subscription);
    (async () => {
      await this.initializePromise;
      await this._acquireLock(-1, async () => {
        this._emitInitialSession(id);
      });
    })();
    return { data: { subscription } };
  }
  async _emitInitialSession(id) {
    return await this._useSession(async (result) => {
      var _a2, _b;
      try {
        const { data: { session }, error } = result;
        if (error)
          throw error;
        await ((_a2 = this.stateChangeEmitters.get(id)) === null || _a2 === void 0 ? void 0 : _a2.callback("INITIAL_SESSION", session));
        this._debug("INITIAL_SESSION", "callback id", id, "session", session);
      } catch (err) {
        await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback("INITIAL_SESSION", null));
        this._debug("INITIAL_SESSION", "callback id", id, "error", err);
        console.error(err);
      }
    });
  }
  /**
   * Sends a password reset request to an email address. This method supports the PKCE flow.
   *
   * @param email The email address of the user.
   * @param options.redirectTo The URL to send the user to after they click the password reset link.
   * @param options.captchaToken Verification token received when the user completes the captcha on the site.
   */
  async resetPasswordForEmail(email, options = {}) {
    let codeChallenge = null;
    let codeChallengeMethod = null;
    if (this.flowType === "pkce") {
      ;
      [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(
        this.storage,
        this.storageKey,
        true
        // isPasswordRecovery
      );
    }
    try {
      return await _request(this.fetch, "POST", `${this.url}/recover`, {
        body: {
          email,
          code_challenge: codeChallenge,
          code_challenge_method: codeChallengeMethod,
          gotrue_meta_security: { captcha_token: options.captchaToken }
        },
        headers: this.headers,
        redirectTo: options.redirectTo
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Gets all the identities linked to a user.
   */
  async getUserIdentities() {
    var _a2;
    try {
      const { data, error } = await this.getUser();
      if (error)
        throw error;
      return { data: { identities: (_a2 = data.user.identities) !== null && _a2 !== void 0 ? _a2 : [] }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Links an oauth identity to an existing user.
   * This method supports the PKCE flow.
   */
  async linkIdentity(credentials) {
    var _a2;
    try {
      const { data, error } = await this._useSession(async (result) => {
        var _a3, _b, _c, _d, _e;
        const { data: data2, error: error2 } = result;
        if (error2)
          throw error2;
        const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {
          redirectTo: (_a3 = credentials.options) === null || _a3 === void 0 ? void 0 : _a3.redirectTo,
          scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
          queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
          skipBrowserRedirect: true
        });
        return await _request(this.fetch, "GET", url, {
          headers: this.headers,
          jwt: (_e = (_d = data2.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : void 0
        });
      });
      if (error)
        throw error;
      if (isBrowser() && !((_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.skipBrowserRedirect)) {
        window.location.assign(data === null || data === void 0 ? void 0 : data.url);
      }
      return { data: { provider: credentials.provider, url: data === null || data === void 0 ? void 0 : data.url }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { provider: credentials.provider, url: null }, error };
      }
      throw error;
    }
  }
  /**
   * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.
   */
  async unlinkIdentity(identity) {
    try {
      return await this._useSession(async (result) => {
        var _a2, _b;
        const { data, error } = result;
        if (error) {
          throw error;
        }
        return await _request(this.fetch, "DELETE", `${this.url}/user/identities/${identity.identity_id}`, {
          headers: this.headers,
          jwt: (_b = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b !== void 0 ? _b : void 0
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Generates a new JWT.
   * @param refreshToken A valid refresh token that was returned on login.
   */
  async _refreshAccessToken(refreshToken) {
    const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, "begin");
    try {
      const startedAt = Date.now();
      return await retryable(async (attempt) => {
        if (attempt > 0) {
          await sleep(200 * Math.pow(2, attempt - 1));
        }
        this._debug(debugName, "refreshing attempt", attempt);
        return await _request(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
          body: { refresh_token: refreshToken },
          headers: this.headers,
          xform: _sessionResponse
        });
      }, (attempt, error) => {
        const nextBackOffInterval = 200 * Math.pow(2, attempt);
        return error && isAuthRetryableFetchError(error) && // retryable only if the request can be sent before the backoff overflows the tick duration
        Date.now() + nextBackOffInterval - startedAt < AUTO_REFRESH_TICK_DURATION;
      });
    } catch (error) {
      this._debug(debugName, "error", error);
      if (isAuthError(error)) {
        return { data: { session: null, user: null }, error };
      }
      throw error;
    } finally {
      this._debug(debugName, "end");
    }
  }
  _isValidSession(maybeSession) {
    const isValidSession = typeof maybeSession === "object" && maybeSession !== null && "access_token" in maybeSession && "refresh_token" in maybeSession && "expires_at" in maybeSession;
    return isValidSession;
  }
  async _handleProviderSignIn(provider, options) {
    const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {
      redirectTo: options.redirectTo,
      scopes: options.scopes,
      queryParams: options.queryParams
    });
    this._debug("#_handleProviderSignIn()", "provider", provider, "options", options, "url", url);
    if (isBrowser() && !options.skipBrowserRedirect) {
      window.location.assign(url);
    }
    return { data: { provider, url }, error: null };
  }
  /**
   * Recovers the session from LocalStorage and refreshes the token
   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
   */
  async _recoverAndRefresh() {
    var _a2;
    const debugName = "#_recoverAndRefresh()";
    this._debug(debugName, "begin");
    try {
      const currentSession = await getItemAsync(this.storage, this.storageKey);
      this._debug(debugName, "session from storage", currentSession);
      if (!this._isValidSession(currentSession)) {
        this._debug(debugName, "session is not valid");
        if (currentSession !== null) {
          await this._removeSession();
        }
        return;
      }
      const timeNow = Math.round(Date.now() / 1e3);
      const expiresWithMargin = ((_a2 = currentSession.expires_at) !== null && _a2 !== void 0 ? _a2 : Infinity) < timeNow + EXPIRY_MARGIN;
      this._debug(debugName, `session has${expiresWithMargin ? "" : " not"} expired with margin of ${EXPIRY_MARGIN}s`);
      if (expiresWithMargin) {
        if (this.autoRefreshToken && currentSession.refresh_token) {
          const { error } = await this._callRefreshToken(currentSession.refresh_token);
          if (error) {
            console.error(error);
            if (!isAuthRetryableFetchError(error)) {
              this._debug(debugName, "refresh failed with a non-retryable error, removing the session", error);
              await this._removeSession();
            }
          }
        }
      } else {
        await this._notifyAllSubscribers("SIGNED_IN", currentSession);
      }
    } catch (err) {
      this._debug(debugName, "error", err);
      console.error(err);
      return;
    } finally {
      this._debug(debugName, "end");
    }
  }
  async _callRefreshToken(refreshToken) {
    var _a2, _b;
    if (!refreshToken) {
      throw new AuthSessionMissingError();
    }
    if (this.refreshingDeferred) {
      return this.refreshingDeferred.promise;
    }
    const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, "begin");
    try {
      this.refreshingDeferred = new Deferred();
      const { data, error } = await this._refreshAccessToken(refreshToken);
      if (error)
        throw error;
      if (!data.session)
        throw new AuthSessionMissingError();
      await this._saveSession(data.session);
      await this._notifyAllSubscribers("TOKEN_REFRESHED", data.session);
      const result = { session: data.session, error: null };
      this.refreshingDeferred.resolve(result);
      return result;
    } catch (error) {
      this._debug(debugName, "error", error);
      if (isAuthError(error)) {
        const result = { session: null, error };
        if (!isAuthRetryableFetchError(error)) {
          await this._removeSession();
        }
        (_a2 = this.refreshingDeferred) === null || _a2 === void 0 ? void 0 : _a2.resolve(result);
        return result;
      }
      (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);
      throw error;
    } finally {
      this.refreshingDeferred = null;
      this._debug(debugName, "end");
    }
  }
  async _notifyAllSubscribers(event, session, broadcast = true) {
    const debugName = `#_notifyAllSubscribers(${event})`;
    this._debug(debugName, "begin", session, `broadcast = ${broadcast}`);
    try {
      if (this.broadcastChannel && broadcast) {
        this.broadcastChannel.postMessage({ event, session });
      }
      const errors = [];
      const promises = Array.from(this.stateChangeEmitters.values()).map(async (x) => {
        try {
          await x.callback(event, session);
        } catch (e) {
          errors.push(e);
        }
      });
      await Promise.all(promises);
      if (errors.length > 0) {
        for (let i = 0; i < errors.length; i += 1) {
          console.error(errors[i]);
        }
        throw errors[0];
      }
    } finally {
      this._debug(debugName, "end");
    }
  }
  /**
   * set currentSession and currentUser
   * process to _startAutoRefreshToken if possible
   */
  async _saveSession(session) {
    this._debug("#_saveSession()", session);
    this.suppressGetSessionWarning = true;
    await setItemAsync(this.storage, this.storageKey, session);
  }
  async _removeSession() {
    this._debug("#_removeSession()");
    await removeItemAsync(this.storage, this.storageKey);
    await this._notifyAllSubscribers("SIGNED_OUT", null);
  }
  /**
   * Removes any registered visibilitychange callback.
   *
   * {@see #startAutoRefresh}
   * {@see #stopAutoRefresh}
   */
  _removeVisibilityChangedCallback() {
    this._debug("#_removeVisibilityChangedCallback()");
    const callback = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {
        window.removeEventListener("visibilitychange", callback);
      }
    } catch (e) {
      console.error("removing visibilitychange callback failed", e);
    }
  }
  /**
   * This is the private implementation of {@link #startAutoRefresh}. Use this
   * within the library.
   */
  async _startAutoRefresh() {
    await this._stopAutoRefresh();
    this._debug("#_startAutoRefresh()");
    const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION);
    this.autoRefreshTicker = ticker;
    if (ticker && typeof ticker === "object" && typeof ticker.unref === "function") {
      ticker.unref();
    } else if (typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function") {
      Deno.unrefTimer(ticker);
    }
    setTimeout(async () => {
      await this.initializePromise;
      await this._autoRefreshTokenTick();
    }, 0);
  }
  /**
   * This is the private implementation of {@link #stopAutoRefresh}. Use this
   * within the library.
   */
  async _stopAutoRefresh() {
    this._debug("#_stopAutoRefresh()");
    const ticker = this.autoRefreshTicker;
    this.autoRefreshTicker = null;
    if (ticker) {
      clearInterval(ticker);
    }
  }
  /**
   * Starts an auto-refresh process in the background. The session is checked
   * every few seconds. Close to the time of expiration a process is started to
   * refresh the session. If refreshing fails it will be retried for as long as
   * necessary.
   *
   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
   * to call this function, it will be called for you.
   *
   * On browsers the refresh process works only when the tab/window is in the
   * foreground to conserve resources as well as prevent race conditions and
   * flooding auth with requests. If you call this method any managed
   * visibility change callback will be removed and you must manage visibility
   * changes on your own.
   *
   * On non-browser platforms the refresh process works *continuously* in the
   * background, which may not be desirable. You should hook into your
   * platform's foreground indication mechanism and call these methods
   * appropriately to conserve resources.
   *
   * {@see #stopAutoRefresh}
   */
  async startAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._startAutoRefresh();
  }
  /**
   * Stops an active auto refresh process running in the background (if any).
   *
   * If you call this method any managed visibility change callback will be
   * removed and you must manage visibility changes on your own.
   *
   * See {@link #startAutoRefresh} for more details.
   */
  async stopAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._stopAutoRefresh();
  }
  /**
   * Runs the auto refresh token tick.
   */
  async _autoRefreshTokenTick() {
    this._debug("#_autoRefreshTokenTick()", "begin");
    try {
      await this._acquireLock(0, async () => {
        try {
          const now = Date.now();
          try {
            return await this._useSession(async (result) => {
              const { data: { session } } = result;
              if (!session || !session.refresh_token || !session.expires_at) {
                this._debug("#_autoRefreshTokenTick()", "no session");
                return;
              }
              const expiresInTicks = Math.floor((session.expires_at * 1e3 - now) / AUTO_REFRESH_TICK_DURATION);
              this._debug("#_autoRefreshTokenTick()", `access token expires in ${expiresInTicks} ticks, a tick lasts ${AUTO_REFRESH_TICK_DURATION}ms, refresh threshold is ${AUTO_REFRESH_TICK_THRESHOLD} ticks`);
              if (expiresInTicks <= AUTO_REFRESH_TICK_THRESHOLD) {
                await this._callRefreshToken(session.refresh_token);
              }
            });
          } catch (e) {
            console.error("Auto refresh tick failed with error. This is likely a transient error.", e);
          }
        } finally {
          this._debug("#_autoRefreshTokenTick()", "end");
        }
      });
    } catch (e) {
      if (e.isAcquireTimeout || e instanceof LockAcquireTimeoutError) {
        this._debug("auto refresh token tick lock not available");
      } else {
        throw e;
      }
    }
  }
  /**
   * Registers callbacks on the browser / platform, which in-turn run
   * algorithms when the browser window/tab are in foreground. On non-browser
   * platforms it assumes always foreground.
   */
  async _handleVisibilityChange() {
    this._debug("#_handleVisibilityChange()");
    if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
      if (this.autoRefreshToken) {
        this.startAutoRefresh();
      }
      return false;
    }
    try {
      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false);
      window === null || window === void 0 ? void 0 : window.addEventListener("visibilitychange", this.visibilityChangedCallback);
      await this._onVisibilityChanged(true);
    } catch (error) {
      console.error("_handleVisibilityChange", error);
    }
  }
  /**
   * Callback registered with `window.addEventListener('visibilitychange')`.
   */
  async _onVisibilityChanged(calledFromInitialize) {
    const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
    this._debug(methodName, "visibilityState", document.visibilityState);
    if (document.visibilityState === "visible") {
      if (this.autoRefreshToken) {
        this._startAutoRefresh();
      }
      if (!calledFromInitialize) {
        await this.initializePromise;
        await this._acquireLock(-1, async () => {
          if (document.visibilityState !== "visible") {
            this._debug(methodName, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
            return;
          }
          await this._recoverAndRefresh();
        });
      }
    } else if (document.visibilityState === "hidden") {
      if (this.autoRefreshToken) {
        this._stopAutoRefresh();
      }
    }
  }
  /**
   * Generates the relevant login URL for a third-party provider.
   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
   * @param options.scopes A space-separated list of scopes granted to the OAuth application.
   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
   */
  async _getUrlForProvider(url, provider, options) {
    const urlParams = [`provider=${encodeURIComponent(provider)}`];
    if (options === null || options === void 0 ? void 0 : options.redirectTo) {
      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
    }
    if (options === null || options === void 0 ? void 0 : options.scopes) {
      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
    }
    if (this.flowType === "pkce") {
      const [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
      const flowParams = new URLSearchParams({
        code_challenge: `${encodeURIComponent(codeChallenge)}`,
        code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`
      });
      urlParams.push(flowParams.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.queryParams) {
      const query = new URLSearchParams(options.queryParams);
      urlParams.push(query.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {
      urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);
    }
    return `${url}?${urlParams.join("&")}`;
  }
  async _unenroll(params) {
    try {
      return await this._useSession(async (result) => {
        var _a2;
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          return { data: null, error: sessionError };
        }
        return await _request(this.fetch, "DELETE", `${this.url}/factors/${params.factorId}`, {
          headers: this.headers,
          jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  async _enroll(params) {
    try {
      return await this._useSession(async (result) => {
        var _a2, _b;
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          return { data: null, error: sessionError };
        }
        const body = Object.assign({ friendly_name: params.friendlyName, factor_type: params.factorType }, params.factorType === "phone" ? { phone: params.phone } : { issuer: params.issuer });
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/factors`, {
          body,
          headers: this.headers,
          jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
        });
        if (error) {
          return { data: null, error };
        }
        if (params.factorType === "totp" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {
          data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;
        }
        return { data, error: null };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * {@see GoTrueMFAApi#verify}
   */
  async _verify(params) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (result) => {
          var _a2;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return { data: null, error: sessionError };
          }
          const { data, error } = await _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/verify`, {
            body: { code: params.code, challenge_id: params.challengeId },
            headers: this.headers,
            jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
          });
          if (error) {
            return { data: null, error };
          }
          await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + data.expires_in }, data));
          await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", data);
          return { data, error };
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challenge}
   */
  async _challenge(params) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (result) => {
          var _a2;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return { data: null, error: sessionError };
          }
          return await _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/challenge`, {
            body: { channel: params.channel },
            headers: this.headers,
            jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
          });
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challengeAndVerify}
   */
  async _challengeAndVerify(params) {
    const { data: challengeData, error: challengeError } = await this._challenge({
      factorId: params.factorId
    });
    if (challengeError) {
      return { data: null, error: challengeError };
    }
    return await this._verify({
      factorId: params.factorId,
      challengeId: challengeData.id,
      code: params.code
    });
  }
  /**
   * {@see GoTrueMFAApi#listFactors}
   */
  async _listFactors() {
    const { data: { user }, error: userError } = await this.getUser();
    if (userError) {
      return { data: null, error: userError };
    }
    const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];
    const totp = factors.filter((factor) => factor.factor_type === "totp" && factor.status === "verified");
    const phone = factors.filter((factor) => factor.factor_type === "phone" && factor.status === "verified");
    return {
      data: {
        all: factors,
        totp,
        phone
      },
      error: null
    };
  }
  /**
   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
   */
  async _getAuthenticatorAssuranceLevel() {
    return this._acquireLock(-1, async () => {
      return await this._useSession(async (result) => {
        var _a2, _b;
        const { data: { session }, error: sessionError } = result;
        if (sessionError) {
          return { data: null, error: sessionError };
        }
        if (!session) {
          return {
            data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },
            error: null
          };
        }
        const payload = this._decodeJWT(session.access_token);
        let currentLevel = null;
        if (payload.aal) {
          currentLevel = payload.aal;
        }
        let nextLevel = currentLevel;
        const verifiedFactors = (_b = (_a2 = session.user.factors) === null || _a2 === void 0 ? void 0 : _a2.filter((factor) => factor.status === "verified")) !== null && _b !== void 0 ? _b : [];
        if (verifiedFactors.length > 0) {
          nextLevel = "aal2";
        }
        const currentAuthenticationMethods = payload.amr || [];
        return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };
      });
    });
  }
};
GoTrueClient.nextInstanceID = 0;

// node_modules/@supabase/auth-js/dist/module/AuthClient.js
var AuthClient = GoTrueClient;
var AuthClient_default = AuthClient;

// node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js
var SupabaseAuthClient = class extends AuthClient_default {
  constructor(options) {
    super(options);
  }
};

// node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SupabaseClient = class {
  /**
   * Create a new client for use in the browser.
   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
   * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
   * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
   * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
   * @param options.realtime Options passed along to realtime-js constructor.
   * @param options.global.fetch A custom fetch implementation.
   * @param options.global.headers Any additional headers to send with each network request.
   */
  constructor(supabaseUrl, supabaseKey, options) {
    var _a2, _b, _c;
    this.supabaseUrl = supabaseUrl;
    this.supabaseKey = supabaseKey;
    if (!supabaseUrl)
      throw new Error("supabaseUrl is required.");
    if (!supabaseKey)
      throw new Error("supabaseKey is required.");
    const _supabaseUrl = stripTrailingSlash(supabaseUrl);
    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, "ws");
    this.authUrl = `${_supabaseUrl}/auth/v1`;
    this.storageUrl = `${_supabaseUrl}/storage/v1`;
    this.functionsUrl = `${_supabaseUrl}/functions/v1`;
    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split(".")[0]}-auth-token`;
    const DEFAULTS = {
      db: DEFAULT_DB_OPTIONS,
      realtime: DEFAULT_REALTIME_OPTIONS,
      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), { storageKey: defaultStorageKey }),
      global: DEFAULT_GLOBAL_OPTIONS
    };
    const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);
    this.storageKey = (_a2 = settings.auth.storageKey) !== null && _a2 !== void 0 ? _a2 : "";
    this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};
    if (!settings.accessToken) {
      this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);
    } else {
      this.accessToken = settings.accessToken;
      this.auth = new Proxy({}, {
        get: (_, prop) => {
          throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);
        }
      });
    }
    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);
    this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers, accessToken: this._getAccessToken.bind(this) }, settings.realtime));
    this.rest = new PostgrestClient(`${_supabaseUrl}/rest/v1`, {
      headers: this.headers,
      schema: settings.db.schema,
      fetch: this.fetch
    });
    if (!settings.accessToken) {
      this._listenForAuthEvents();
    }
  }
  /**
   * Supabase Functions allows you to deploy and invoke edge functions.
   */
  get functions() {
    return new FunctionsClient(this.functionsUrl, {
      headers: this.headers,
      customFetch: this.fetch
    });
  }
  /**
   * Supabase Storage allows you to manage user-generated content, such as photos or videos.
   */
  get storage() {
    return new StorageClient(this.storageUrl, this.headers, this.fetch);
  }
  /**
   * Perform a query on a table or a view.
   *
   * @param relation - The table or view name to query
   */
  from(relation) {
    return this.rest.from(relation);
  }
  // NOTE: signatures must be kept in sync with PostgrestClient.schema
  /**
   * Select a schema to query or perform an function (rpc) call.
   *
   * The schema needs to be on the list of exposed schemas inside Supabase.
   *
   * @param schema - The schema to query
   */
  schema(schema) {
    return this.rest.schema(schema);
  }
  // NOTE: signatures must be kept in sync with PostgrestClient.rpc
  /**
   * Perform a function call.
   *
   * @param fn - The function name to call
   * @param args - The arguments to pass to the function call
   * @param options - Named parameters
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   * @param options.get - When set to `true`, the function will be called with
   * read-only access mode.
   * @param options.count - Count algorithm to use to count rows returned by the
   * function. Only applicable for [set-returning
   * functions](https://www.postgresql.org/docs/current/functions-srf.html).
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  rpc(fn, args = {}, options = {}) {
    return this.rest.rpc(fn, args, options);
  }
  /**
   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
   *
   * @param {string} name - The name of the Realtime channel.
   * @param {Object} opts - The options to pass to the Realtime channel.
   *
   */
  channel(name, opts = { config: {} }) {
    return this.realtime.channel(name, opts);
  }
  /**
   * Returns all Realtime channels.
   */
  getChannels() {
    return this.realtime.getChannels();
  }
  /**
   * Unsubscribes and removes Realtime channel from Realtime client.
   *
   * @param {RealtimeChannel} channel - The name of the Realtime channel.
   *
   */
  removeChannel(channel) {
    return this.realtime.removeChannel(channel);
  }
  /**
   * Unsubscribes and removes all Realtime channels from Realtime client.
   */
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  _getAccessToken() {
    var _a2, _b;
    return __awaiter8(this, void 0, void 0, function* () {
      if (this.accessToken) {
        return yield this.accessToken();
      }
      const { data } = yield this.auth.getSession();
      return (_b = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b !== void 0 ? _b : null;
    });
  }
  _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, storageKey, flowType, lock, debug: debug2 }, headers, fetch4) {
    const authHeaders = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`
    };
    return new SupabaseAuthClient({
      url: this.authUrl,
      headers: Object.assign(Object.assign({}, authHeaders), headers),
      storageKey,
      autoRefreshToken,
      persistSession,
      detectSessionInUrl,
      storage,
      flowType,
      lock,
      debug: debug2,
      fetch: fetch4,
      // auth checks if there is a custom authorizaiton header using this flag
      // so it knows whether to return an error when getUser is called with no session
      hasCustomAuthorizationHeader: "Authorization" in this.headers
    });
  }
  _initRealtimeClient(options) {
    return new RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), { params: Object.assign({ apikey: this.supabaseKey }, options === null || options === void 0 ? void 0 : options.params) }));
  }
  _listenForAuthEvents() {
    let data = this.auth.onAuthStateChange((event, session) => {
      this._handleTokenChanged(event, "CLIENT", session === null || session === void 0 ? void 0 : session.access_token);
    });
    return data;
  }
  _handleTokenChanged(event, source, token) {
    if ((event === "TOKEN_REFRESHED" || event === "SIGNED_IN") && this.changedAccessToken !== token) {
      this.changedAccessToken = token;
    } else if (event === "SIGNED_OUT") {
      this.realtime.setAuth();
      if (source == "STORAGE")
        this.auth.signOut();
      this.changedAccessToken = void 0;
    }
  }
};

// node_modules/@supabase/supabase-js/dist/module/index.js
var createClient = (supabaseUrl, supabaseKey, options) => {
  return new SupabaseClient(supabaseUrl, supabaseKey, options);
};

// settings/Settings.ts
var DEFAULT_CHUNKING_OPTIONS = {
  chunkSize: 1e3,
  // Default size of each chunk in characters
  chunkOverlap: 200,
  // Default overlap between chunks
  minChunkSize: 100
  // Minimum chunk size to ensure usability
};
var DEFAULT_UPDATE_BEHAVIOR = {
  debounceTime: 1e3,
  // 1 second debounce delay by default
  processingMode: "instant",
  // Process updates instantly by default
  priorityOverride: 1
  // Default priority level for update operations
};
function generateDeviceId() {
  return crypto.randomUUID();
}
var SYSTEM_EXCLUSIONS = {
  folders: [
    ".obsidian",
    // Obsidian config folder
    ".trash",
    // Obsidian trash folder
    ".git",
    // Git folder if used
    "node_modules"
    // Node modules if used
  ],
  fileTypes: [
    ".mp3",
    ".jpg",
    ".png",
    ".pdf",
    // Non-markdown files
    ".excalidraw"
    // Excalidraw files
  ],
  filePrefixes: ["_", "."],
  // Hidden and special files
  files: [
    "_mindmatrixsync.md",
    // Sync file
    "_mindmatrixsync.md.backup"
    // Sync backup file
  ]
};
var DEFAULT_SETTINGS = {
  vaultId: null,
  lastKnownVaultName: "",
  supabase: {
    url: "",
    apiKey: "",
    initialized: false,
    lastSetupAttempt: 0,
    setupRetries: 0
  },
  openai: {
    apiKey: "",
    model: "text-embedding-ada-002",
    maxTokens: 8e3,
    temperature: 0
  },
  chunking: { ...DEFAULT_CHUNKING_OPTIONS },
  queue: {
    maxConcurrent: 3,
    retryAttempts: 3,
    retryDelay: 1e3
  },
  exclusions: {
    excludedFolders: [],
    excludedFileTypes: [],
    excludedFilePrefixes: [],
    excludedFiles: [],
    systemExcludedFolders: [...SYSTEM_EXCLUSIONS.folders],
    systemExcludedFileTypes: [...SYSTEM_EXCLUSIONS.fileTypes],
    systemExcludedFilePrefixes: [...SYSTEM_EXCLUSIONS.filePrefixes],
    systemExcludedFiles: [...SYSTEM_EXCLUSIONS.files]
  },
  debug: {
    enableDebugLogs: false,
    logLevel: "info",
    logToFile: false
  },
  enableAutoSync: true,
  enableNotifications: true,
  enableProgressBar: true,
  sync: {
    syncFilePath: "_mindmatrixsync.md",
    backupInterval: 36e5,
    // 1 hour in milliseconds
    checkInterval: 3e5,
    // 5 minutes in milliseconds
    checkAttempts: 3,
    timeout: 4e4,
    requireSync: true,
    deviceId: generateDeviceId(),
    deviceName: `Device-${Math.floor(Math.random() * 1e3)}`,
    knownDevices: [],
    connectionCheckInterval: 6e4,
    // 1 minute
    offlineQueueEnabled: true,
    conflictResolutionStrategy: "newest-wins"
  },
  initialSync: {
    batchSize: 50,
    maxConcurrentBatches: 3,
    enableAutoInitialSync: true,
    priorityRules: [
      { pattern: "daily/", priority: 3 },
      { pattern: "projects/", priority: 2 },
      { pattern: "archive/", priority: 1 }
    ]
  },
  updateBehavior: {
    ...DEFAULT_UPDATE_BEHAVIOR
  }
};
function getAllExclusions2(settings) {
  const exclusions = settings.exclusions;
  return {
    excludedFolders: [
      ...exclusions.systemExcludedFolders || SYSTEM_EXCLUSIONS.folders,
      ...exclusions.excludedFolders || []
    ],
    excludedFileTypes: [
      ...exclusions.systemExcludedFileTypes || SYSTEM_EXCLUSIONS.fileTypes,
      ...exclusions.excludedFileTypes || []
    ],
    excludedFilePrefixes: [
      ...exclusions.systemExcludedFilePrefixes || SYSTEM_EXCLUSIONS.filePrefixes,
      ...exclusions.excludedFilePrefixes || []
    ],
    excludedFiles: [
      ...exclusions.systemExcludedFiles || SYSTEM_EXCLUSIONS.files,
      ...exclusions.excludedFiles || []
    ]
  };
}
function getUserExclusions(settings) {
  const exclusions = settings.exclusions;
  return {
    excludedFolders: exclusions.excludedFolders || [],
    excludedFileTypes: exclusions.excludedFileTypes || [],
    excludedFilePrefixes: exclusions.excludedFilePrefixes || [],
    excludedFiles: exclusions.excludedFiles || []
  };
}
function isVaultInitialized2(settings) {
  return settings.vaultId !== null && settings.vaultId !== void 0 && settings.vaultId !== "";
}
function generateVaultId() {
  return crypto.randomUUID();
}

// services/SupabaseService.ts
var import_obsidian = require("obsidian");
var _SupabaseService = class {
  constructor(settings) {
    this.TABLE_NAME = "obsidian_documents";
    this.FILE_STATUS_TABLE = "obsidian_file_status";
    // Track deletion operations for a given file to avoid concurrent deletes
    this.deleteOperationsInProgress = /* @__PURE__ */ new Map();
    if (!settings.supabase.url || !settings.supabase.apiKey) {
      console.warn("Supabase configuration is incomplete. Supabase service will not be initialized.");
      this.client = null;
      return;
    }
    if (!isVaultInitialized2(settings)) {
      throw new Error("Vault is not initialized");
    }
    this.settings = settings;
    this.client = createClient(settings.supabase.url, settings.supabase.apiKey);
  }
  static async getInstance(settings) {
    if (!settings.supabase.url || !settings.supabase.apiKey) {
      console.warn("Supabase configuration is incomplete. Returning null.");
      return null;
    }
    if (!_SupabaseService.instance) {
      _SupabaseService.instance = new _SupabaseService(settings);
      await _SupabaseService.instance.initializeDatabase();
    } else if (_SupabaseService.instance.settings.supabase.url !== settings.supabase.url || _SupabaseService.instance.settings.supabase.apiKey !== settings.supabase.apiKey || _SupabaseService.instance.settings.vaultId !== settings.vaultId) {
      _SupabaseService.instance = new _SupabaseService(settings);
      await _SupabaseService.instance.initializeDatabase();
    }
    return _SupabaseService.instance;
  }
  async initializeDatabase() {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping database initialization.");
      return;
    }
    try {
      new import_obsidian.Notice("Checking database connection...");
      const { error: testError } = await this.client.from(this.TABLE_NAME).select("id").limit(1);
      if (testError && !testError.message.includes("does not exist")) {
        throw new Error(`Database connection failed: ${testError.message}`);
      }
      await this.initializeFileStatusTable();
      new import_obsidian.Notice("Database connection verified");
      this.settings.supabase.initialized = true;
    } catch (error) {
      console.error("Database initialization error:", error);
      new import_obsidian.Notice(`Database error: ${error.message}`);
      throw error;
    }
  }
  /**
   * Ensures that obsidian_file_status table exists.
   */
  async initializeFileStatusTable() {
    if (!this.client)
      return;
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.log("File status table missing. Please create it manually or run setup SQL.");
        new import_obsidian.Notice("Some database tables are missing. Plugin will work with limited functionality.", 5e3);
      } else {
        console.log("File status table exists and is accessible");
      }
    } catch (error) {
      console.error("Error initializing file status table:", error);
      throw new Error(`Failed to initialize file status table: ${error.message}`);
    }
  }
  /**
   * Inserts or updates document chunks in the obsidian_documents table using an atomic transaction.
   * Improvements:
   * - Transaction handling to ensure atomicity
   * - Verification of deletion success before insertion
   * - Proper error handling and retry logic
   * - Prevents concurrent deletions on the same file
   */
  async upsertChunks(chunks) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping upsertChunks.");
      return;
    }
    if (chunks.length === 0) {
      console.log("No chunks to upsert");
      return;
    }
    const obsidianId = chunks[0].metadata.obsidianId;
    if (this.deleteOperationsInProgress.get(obsidianId)) {
      console.warn(`Delete operation already in progress for ${obsidianId}. Queueing update.`);
      let retryCount = 0;
      const maxRetries = 5;
      const baseDelay = 500;
      while (this.deleteOperationsInProgress.get(obsidianId) && retryCount < maxRetries) {
        const delay = baseDelay * Math.pow(2, retryCount);
        await new Promise((resolve) => setTimeout(resolve, delay));
        retryCount++;
      }
      if (this.deleteOperationsInProgress.get(obsidianId)) {
        throw new Error(`Deletion operation timeout for ${obsidianId}`);
      }
    }
    this.deleteOperationsInProgress.set(obsidianId, true);
    try {
      const chunksToInsert = chunks.map((chunk) => ({
        vault_id: this.settings.vaultId,
        obsidian_id: chunk.metadata.obsidianId,
        chunk_index: chunk.chunkIndex,
        content: chunk.content,
        metadata: chunk.metadata,
        embedding: chunk.embedding,
        last_updated: new Date().toISOString(),
        vectorized_at: new Date().toISOString()
      }));
      const chunkCount = chunksToInsert.length;
      console.log(`Preparing to update ${chunkCount} chunks for file: ${obsidianId}`);
      const { error: deleteError, count: deletedCount } = await this.client.from(this.TABLE_NAME).delete().eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId).select("*", { head: true, count: "exact" });
      if (deleteError) {
        console.error("Error deleting existing chunks:", deleteError);
        throw deleteError;
      }
      console.log(`Successfully deleted ${deletedCount} existing chunks for ${obsidianId}`);
      const { data: remainingData, error: countError } = await this.client.from(this.TABLE_NAME).select("id", { count: "exact", head: true }).eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
      if (countError) {
        console.error("Error verifying deletion:", countError);
        throw countError;
      }
      const remainingCount = (remainingData == null ? void 0 : remainingData.length) || 0;
      if (remainingCount > 0) {
        console.warn(`Deletion verification failed: ${remainingCount} chunks still exist for ${obsidianId}`);
        const { error: retryError } = await this.client.from(this.TABLE_NAME).delete().eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
        if (retryError) {
          throw new Error(`Failed to clean up remaining chunks: ${retryError.message}`);
        }
      }
      const BATCH_SIZE = 50;
      const batches = [];
      for (let i = 0; i < chunksToInsert.length; i += BATCH_SIZE) {
        batches.push(chunksToInsert.slice(i, i + BATCH_SIZE));
      }
      console.log(`Inserting ${chunksToInsert.length} chunks in ${batches.length} batches`);
      for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        console.log(`Processing batch ${i + 1}/${batches.length} with ${batch.length} chunks`);
        const { error: insertError } = await this.client.from(this.TABLE_NAME).insert(batch);
        if (insertError) {
          console.error(`Error inserting batch ${i + 1}:`, insertError);
          await this.cleanupPartialInsert(obsidianId);
          throw insertError;
        }
      }
      const { data: insertedData, error: verifyError } = await this.client.from(this.TABLE_NAME).select("id", { count: "exact", head: true }).eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
      if (verifyError) {
        console.error("Error verifying insertion:", verifyError);
        throw verifyError;
      }
      const insertedCount = (insertedData == null ? void 0 : insertedData.length) || 0;
      if (insertedCount !== chunkCount) {
        console.warn(`Insertion verification: Expected ${chunkCount} chunks, found ${insertedCount}`);
      }
      await this.updateFileVectorizationStatus(chunks[0].metadata);
      console.log("Successfully updated chunks:", {
        numberOfChunks: chunks.length,
        vaultId: this.settings.vaultId,
        obsidianId
      });
    } catch (error) {
      console.error("Failed to upsert chunks:", error);
      throw error;
    } finally {
      this.deleteOperationsInProgress.set(obsidianId, false);
    }
  }
  /**
   * Cleans up partial inserts if an error occurs during batch insertion
   */
  async cleanupPartialInsert(obsidianId) {
    if (!this.client)
      return;
    try {
      console.log(`Cleaning up partial insert for ${obsidianId}`);
      const { error } = await this.client.from(this.TABLE_NAME).delete().eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
      if (error) {
        console.error("Error cleaning up partial insert:", error);
      } else {
        console.log(`Successfully cleaned up partial insert for ${obsidianId}`);
      }
    } catch (cleanupError) {
      console.error("Error during cleanup of partial insert:", cleanupError);
    }
  }
  /**
   * Bulk upsert method for file status records.
   * Improves performance for large vaults.
   */
  async bulkUpsertFileStatuses(statuses) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping bulkUpsertFileStatuses.");
      return;
    }
    try {
      if (statuses.length === 0)
        return;
      const { error } = await this.client.from(this.FILE_STATUS_TABLE).upsert(statuses, { onConflict: "vault_id,file_path" });
      if (error) {
        console.error("Error during bulk upsert of file statuses:", error);
        throw error;
      }
      console.log(`Bulk upsert of ${statuses.length} file statuses successful.`);
    } catch (error) {
      console.error("Failed to bulk upsert file statuses:", error);
      throw error;
    }
  }
  /**
   * Creates or updates a record in the obsidian_file_status table
   * to reflect the latest file status using provided metadata.
   */
  async updateFileVectorizationStatus(metadata) {
    var _a2, _b;
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping updateFileVectorizationStatus.");
      return;
    }
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Skipping status update.");
        return;
      }
      const fileStatus = {
        vault_id: this.settings.vaultId,
        file_path: metadata.obsidianId,
        last_modified: metadata.lastModified,
        last_vectorized: new Date().toISOString(),
        content_hash: ((_a2 = metadata.customMetadata) == null ? void 0 : _a2.contentHash) || "",
        status: "vectorized",
        // Mark as successfully vectorized
        tags: metadata.tags || [],
        aliases: ((_b = metadata.customMetadata) == null ? void 0 : _b.aliases) || [],
        links: metadata.links || [],
        updated_at: new Date().toISOString()
      };
      const { error } = await this.client.from(this.FILE_STATUS_TABLE).upsert(fileStatus, { onConflict: "vault_id,file_path" });
      if (error) {
        console.error("Error updating file vectorization status:", error);
        throw error;
      }
      console.log("File vectorization status updated:", metadata.obsidianId);
    } catch (error) {
      console.error("Failed to update file vectorization status:", error);
    }
  }
  /**
   * Marks a file as deleted in the obsidian_file_status table.
   */
  async updateFileStatusOnDelete(filePath) {
    if (!this.client)
      return;
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Skipping status update on delete.");
        return;
      }
      const { error } = await this.client.from(this.FILE_STATUS_TABLE).update({
        status: "deleted",
        updated_at: new Date().toISOString()
      }).eq("vault_id", this.settings.vaultId).eq("file_path", filePath);
      if (error) {
        console.error("Error updating file status on delete:", error);
        throw error;
      }
    } catch (error) {
      console.error("Failed to update file status on delete:", error);
    }
  }
  /**
   * Deletes document chunks for a given obsidianId from the obsidian_documents table.
   * Improved with tracking of operation progress and verification.
   */
  async deleteDocumentChunks(obsidianId) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping deleteDocumentChunks.");
      return;
    }
    if (this.deleteOperationsInProgress.get(obsidianId)) {
      console.warn(`Delete operation already in progress for ${obsidianId}. Waiting...`);
      await new Promise((resolve) => setTimeout(resolve, 500));
      if (this.deleteOperationsInProgress.get(obsidianId)) {
        console.log(`Still waiting for delete operation on ${obsidianId}...`);
        return;
      }
    }
    this.deleteOperationsInProgress.set(obsidianId, true);
    try {
      console.log(`Starting deletion of chunks for ${obsidianId}`);
      const { data: initialData, error: initialCountError } = await this.client.from(this.TABLE_NAME).select("id").eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
      if (initialCountError) {
        console.error("Error checking existing chunks:", initialCountError);
        throw initialCountError;
      }
      const initialCount = initialData ? initialData.length : 0;
      console.log(`Found ${initialCount} chunks to delete for ${obsidianId}`);
      if (initialCount === 0) {
        await this.purgeFileStatus(obsidianId);
        return;
      }
      const { error: deleteError } = await this.client.from(this.TABLE_NAME).delete().eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
      if (deleteError) {
        console.error("Error deleting chunks:", deleteError);
        throw deleteError;
      }
      await new Promise((resolve) => setTimeout(resolve, 500));
      const { data: remainingData, error: verifyError } = await this.client.from(this.TABLE_NAME).select("id").eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId);
      if (verifyError) {
        console.error("Error verifying deletion:", verifyError);
        throw verifyError;
      }
      const remainingCount = remainingData ? remainingData.length : 0;
      if (remainingCount > 0) {
        console.warn(`Deletion verification failed: ${remainingCount} chunks still exist for ${obsidianId}`);
        return;
      }
      await this.purgeFileStatus(obsidianId);
      console.log(`Successfully purged file status for ${obsidianId}`);
    } catch (error) {
      console.error("Failed to delete chunks:", error);
      throw error;
    } finally {
      this.deleteOperationsInProgress.set(obsidianId, false);
    }
  }
  /**
   * Retrieves document chunks for a given obsidianId.
   */
  async getDocumentChunks(obsidianId) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping getDocumentChunks.");
      return [];
    }
    try {
      const { data, error } = await this.client.from(this.TABLE_NAME).select("*").eq("vault_id", this.settings.vaultId).eq("obsidian_id", obsidianId).order("chunk_index");
      if (error)
        throw error;
      return data.map((row) => ({
        content: row.content,
        chunkIndex: row.chunk_index,
        metadata: row.metadata,
        embedding: row.embedding,
        vectorized_at: row.vectorized_at
      }));
    } catch (error) {
      console.error("Failed to get chunks:", error);
      throw error;
    }
  }
  /**
   * Checks if a file has been vectorized based on the obsidian_file_status table.
   */
  async isFileVectorized(filePath) {
    if (!this.client)
      return false;
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Assuming file is not vectorized.");
        return false;
      }
      const { data, error } = await this.client.from(this.FILE_STATUS_TABLE).select("status, last_vectorized").eq("vault_id", this.settings.vaultId).eq("file_path", filePath).single();
      if (error) {
        if (error.code === "PGRST116") {
          return false;
        }
        throw error;
      }
      return data && data.status === "vectorized" && !!data.last_vectorized;
    } catch (error) {
      console.error("Failed to check if file is vectorized:", error);
      return false;
    }
  }
  /**
   * Retrieves the vectorization status of a file from the database.
   */
  async getFileVectorizationStatus(filePath) {
    if (!this.client) {
      return {
        isVectorized: false,
        lastModified: 0,
        lastVectorized: null,
        contentHash: null,
        status: null
      };
    }
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Returning default status.");
        return {
          isVectorized: false,
          lastModified: 0,
          lastVectorized: null,
          contentHash: null,
          status: null
        };
      }
      const { data, error } = await this.client.from(this.FILE_STATUS_TABLE).select("*").eq("vault_id", this.settings.vaultId).eq("file_path", filePath).single();
      if (error) {
        if (error.code === "PGRST116") {
          return {
            isVectorized: false,
            lastModified: 0,
            lastVectorized: null,
            contentHash: null,
            status: null
          };
        }
        throw error;
      }
      return {
        isVectorized: data.status === "vectorized",
        lastModified: data.last_modified,
        lastVectorized: data.last_vectorized,
        contentHash: data.content_hash,
        status: data.status
      };
    } catch (error) {
      console.error("Failed to get file vectorization status:", error);
      return {
        isVectorized: false,
        lastModified: 0,
        lastVectorized: null,
        contentHash: null,
        status: null
      };
    }
  }
  /**
   * Determines if a file needs vectorizing based on last_modified and content_hash.
   */
  async needsVectorizing(filePath, lastModified, contentHash) {
    if (!this.client)
      return true;
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Assuming file needs vectorizing.");
        return true;
      }
      const status = await this.getFileVectorizationStatus(filePath);
      if (!status.status) {
        return true;
      }
      if (status.contentHash !== contentHash) {
        return true;
      }
      if (lastModified > status.lastModified) {
        return true;
      }
      return false;
    } catch (error) {
      console.error("Failed to check if file needs vectorizing:", error);
      return true;
    }
  }
  /**
   * Retrieves all files that do not have a status of 'vectorized' in the database.
   */
  async getFilesNeedingVectorization() {
    if (!this.client)
      return [];
    try {
      const { error: checkError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (checkError && checkError.message.includes("does not exist")) {
        console.warn("File status table does not exist. Unable to determine files needing vectorization.");
        return [];
      }
      const { data, error } = await this.client.from(this.FILE_STATUS_TABLE).select("file_path").eq("vault_id", this.settings.vaultId).not("status", "eq", "vectorized");
      if (error)
        throw error;
      return data.map((row) => row.file_path);
    } catch (error) {
      console.error("Failed to get files needing vectorization:", error);
      return [];
    }
  }
  /**
   * Performs a semantic search using the match_documents function.
   */
  async semanticSearch(embedding, limit2 = 5) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping semanticSearch.");
      return [];
    }
    try {
      const { data, error } = await this.client.rpc("match_documents", {
        query_embedding: embedding,
        search_vault_id: this.settings.vaultId,
        match_count: limit2
      });
      if (error)
        throw error;
      return data.map((row) => ({
        content: row.content,
        metadata: row.metadata,
        similarity: row.similarity
      }));
    } catch (error) {
      console.error("Failed to perform semantic search:", error);
      throw error;
    }
  }
  /**
   * Tests the connection by selecting from the obsidian_documents table.
   */
  async testConnection() {
    if (!this.client)
      return false;
    try {
      const { error } = await this.client.from(this.TABLE_NAME).select("id").limit(1);
      if (error && error.message && error.message.includes("does not exist")) {
        return true;
      }
      return !error;
    } catch (e) {
      return false;
    }
  }
  /**
   * Returns all unique obsidian_ids from the obsidian_documents table for the current vault.
   */
  async getAllDocumentIds() {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping getAllDocumentIds.");
      return [];
    }
    try {
      const { data, error } = await this.client.from(this.TABLE_NAME).select("obsidian_id").eq("vault_id", this.settings.vaultId).distinct();
      if (error) {
        if (error.message.includes("does not exist")) {
          return [];
        }
        throw error;
      }
      return data.map((row) => row.obsidian_id);
    } catch (error) {
      console.error("Failed to get document IDs:", error);
      throw error;
    }
  }
  /**
   * Creates the required database tables if needed (manual invocation).
   */
  async createRequiredTables() {
    if (!this.client) {
      return {
        success: false,
        message: "Supabase client not initialized"
      };
    }
    try {
      const createFileStatusTableSQL = `
				CREATE TABLE IF NOT EXISTS ${this.FILE_STATUS_TABLE} (
					id BIGSERIAL PRIMARY KEY,
					vault_id TEXT NOT NULL,
					file_path TEXT NOT NULL,
					last_modified BIGINT NOT NULL,
					last_vectorized TIMESTAMPTZ,
					content_hash TEXT,
					status TEXT,
					tags TEXT[],
					aliases TEXT[],
					links TEXT[],
					created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
					updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
					UNIQUE(vault_id, file_path)
				);
				CREATE INDEX IF NOT EXISTS idx_file_status_vault_path ON ${this.FILE_STATUS_TABLE}(vault_id, file_path);
			`;
      const { error } = await this.client.rpc("run_sql", { sql: createFileStatusTableSQL });
      if (error) {
        return { success: false, message: `Could not create tables: ${error.message}` };
      }
      return { success: true, message: "Tables created successfully" };
    } catch (error) {
      return { success: false, message: `Error creating tables: ${error.message}` };
    }
  }
  async updateFilePath(oldPath, newPath) {
    if (!this.client)
      return;
    try {
      const { error } = await this.client.from(this.FILE_STATUS_TABLE).update({ file_path: newPath, updated_at: new Date().toISOString() }).eq("vault_id", this.settings.vaultId).eq("file_path", oldPath);
      if (error) {
        throw error;
      }
      console.log(`File path updated from ${oldPath} to ${newPath}`);
    } catch (error) {
      console.error("Error updating file path:", error);
      throw error;
    }
  }
  async purgeFileStatus(filePath) {
    if (!this.client) {
      console.warn("Supabase client is not initialized. Skipping purgeFileStatus.");
      return;
    }
    try {
      const { error } = await this.client.from(this.FILE_STATUS_TABLE).delete().eq("vault_id", this.settings.vaultId).eq("file_path", filePath);
      if (error) {
        console.error("Error purging file status:", error);
        throw error;
      }
      console.log(`Purged file status record for ${filePath}`);
    } catch (error) {
      console.error("Failed to purge file status record:", error);
      throw error;
    }
  }
  /**
   * Checks if all required tables exist and are properly set up.
   * Returns an object with the status of each table and any missing tables.
   */
  async checkDatabaseSetup() {
    if (!this.client) {
      return {
        isComplete: false,
        missingTables: [this.TABLE_NAME, this.FILE_STATUS_TABLE],
        error: "Supabase client is not initialized"
      };
    }
    const missingTables = [];
    let error;
    try {
      const { error: documentsError } = await this.client.from(this.TABLE_NAME).select("id").limit(1);
      if (documentsError && documentsError.message.includes("does not exist")) {
        missingTables.push(this.TABLE_NAME);
      }
      const { error: statusError } = await this.client.from(this.FILE_STATUS_TABLE).select("id").limit(1);
      if (statusError && statusError.message.includes("does not exist")) {
        missingTables.push(this.FILE_STATUS_TABLE);
      }
      const { error: vectorError } = await this.client.rpc("vector_norm", { vector: [1, 0] });
      if (vectorError && vectorError.message.includes("function vector_norm")) {
        error = "Vector extension is not installed";
      }
      return {
        isComplete: missingTables.length === 0 && !error,
        missingTables,
        error
      };
    } catch (err) {
      console.error("Error checking database setup:", err);
      return {
        isComplete: false,
        missingTables: [this.TABLE_NAME, this.FILE_STATUS_TABLE],
        error: `Error checking database setup: ${err.message}`
      };
    }
  }
  /**
   * Resets the database by dropping and recreating all tables.
   * WARNING: This will delete all data in the tables.
   */
  async resetDatabase() {
    if (!this.client) {
      return {
        success: false,
        message: "Supabase client is not initialized"
      };
    }
    try {
      await this.client.rpc("drop_tables_if_exist");
      const { error: createError } = await this.client.rpc("create_required_tables");
      if (createError) {
        throw new Error(`Failed to create tables: ${createError.message}`);
      }
      return {
        success: true,
        message: "Database reset successfully"
      };
    } catch (err) {
      console.error("Error resetting database:", err);
      return {
        success: false,
        message: `Error resetting database: ${err.message}`
      };
    }
  }
};
var SupabaseService = _SupabaseService;
SupabaseService.instance = null;

// node_modules/openai/internal/qs/formats.mjs
var default_format = "RFC3986";
var formatters = {
  RFC1738: (v) => String(v).replace(/%20/g, "+"),
  RFC3986: (v) => String(v)
};
var RFC1738 = "RFC1738";

// node_modules/openai/internal/qs/utils.mjs
var is_array = Array.isArray;
var hex_table = (() => {
  const array = [];
  for (let i = 0; i < 256; ++i) {
    array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array;
})();
var limit = 1024;
var encode = (str2, _defaultEncoder, charset, _kind, format) => {
  if (str2.length === 0) {
    return str2;
  }
  let string = str2;
  if (typeof str2 === "symbol") {
    string = Symbol.prototype.toString.call(str2);
  } else if (typeof str2 !== "string") {
    string = String(str2);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  let out = "";
  for (let j = 0; j < string.length; j += limit) {
    const segment = string.length >= limit ? string.slice(j, j + limit) : string;
    const arr = [];
    for (let i = 0; i < segment.length; ++i) {
      let c = segment.charCodeAt(i);
      if (c === 45 || // -
      c === 46 || // .
      c === 95 || // _
      c === 126 || // ~
      c >= 48 && c <= 57 || // 0-9
      c >= 65 && c <= 90 || // a-z
      c >= 97 && c <= 122 || // A-Z
      format === RFC1738 && (c === 40 || c === 41)) {
        arr[arr.length] = segment.charAt(i);
        continue;
      }
      if (c < 128) {
        arr[arr.length] = hex_table[c];
        continue;
      }
      if (c < 2048) {
        arr[arr.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        arr[arr.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
      arr[arr.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
    }
    out += arr.join("");
  }
  return out;
};
function is_buffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn) {
  if (is_array(val)) {
    const mapped = [];
    for (let i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
}

// node_modules/openai/internal/qs/stringify.mjs
var has = Object.prototype.hasOwnProperty;
var array_prefix_generators = {
  brackets(prefix) {
    return String(prefix) + "[]";
  },
  comma: "comma",
  indices(prefix, key) {
    return String(prefix) + "[" + key + "]";
  },
  repeat(prefix) {
    return String(prefix);
  }
};
var is_array2 = Array.isArray;
var push = Array.prototype.push;
var push_to_array = function(arr, value_or_array) {
  push.apply(arr, is_array2(value_or_array) ? value_or_array : [value_or_array]);
};
var to_ISO = Date.prototype.toISOString;
var defaults = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: encode,
  encodeValuesOnly: false,
  format: default_format,
  formatter: formatters[default_format],
  /** @deprecated */
  indices: false,
  serializeDate(date) {
    return to_ISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
function is_non_nullish_primitive(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
}
var sentinel = {};
function inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
  let obj = object;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
    const pos = tmp_sc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate == null ? void 0 : serializeDate(obj);
  } else if (generateArrayPrefix === "comma" && is_array2(obj)) {
    obj = maybe_map(obj, function(value) {
      if (value instanceof Date) {
        return serializeDate == null ? void 0 : serializeDate(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? (
        // @ts-expect-error
        encoder(prefix, defaults.encoder, charset, "key", format)
      ) : prefix;
    }
    obj = "";
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder) {
      const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
      return [
        (formatter == null ? void 0 : formatter(key_value)) + "=" + // @ts-expect-error
        (formatter == null ? void 0 : formatter(encoder(obj, defaults.encoder, charset, "value", format)))
      ];
    }
    return [(formatter == null ? void 0 : formatter(prefix)) + "=" + (formatter == null ? void 0 : formatter(String(obj)))];
  }
  const values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && is_array2(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = maybe_map(obj, encoder);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (is_array2(filter)) {
    obj_keys = filter;
  } else {
    const keys = Object.keys(obj);
    obj_keys = sort ? keys.sort(sort) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && is_array2(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && is_array2(obj) && obj.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j = 0; j < obj_keys.length; ++j) {
    const key = obj_keys[j];
    const value = (
      // @ts-ignore
      typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
    );
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = is_array2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel.set(object, step);
    const valueSideChannel = /* @__PURE__ */ new WeakMap();
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(values, inner_stringify(
      value,
      key_prefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      // @ts-ignore
      generateArrayPrefix === "comma" && encodeValuesOnly && is_array2(obj) ? null : encoder,
      filter,
      sort,
      allowDots,
      serializeDate,
      format,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
}
function normalize_stringify_options(opts = defaults) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset = opts.charset || defaults.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has.call(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format = opts.format;
  }
  const formatter = formatters[format];
  let filter = defaults.filter;
  if (typeof opts.filter === "function" || is_array2(opts.filter)) {
    filter = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
    // @ts-ignore
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter,
    format,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
    // @ts-ignore
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
}
function stringify(object, opts = {}) {
  let obj = object;
  const options = normalize_stringify_options(opts);
  let obj_keys;
  let filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (is_array2(options.filter)) {
    filter = options.filter;
    obj_keys = filter;
  }
  const keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options.sort) {
    obj_keys.sort(options.sort);
  }
  const sideChannel = /* @__PURE__ */ new WeakMap();
  for (let i = 0; i < obj_keys.length; ++i) {
    const key = obj_keys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    push_to_array(keys, inner_stringify(
      obj[key],
      key,
      // @ts-expect-error
      generateArrayPrefix,
      commaRoundTrip,
      options.allowEmptyArrays,
      options.strictNullHandling,
      options.skipNulls,
      options.encodeDotInKeys,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel
    ));
  }
  const joined = keys.join(options.delimiter);
  let prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}

// node_modules/openai/version.mjs
var VERSION = "4.79.1";

// node_modules/openai/_shims/registry.mjs
var auto = false;
var kind = void 0;
var fetch3 = void 0;
var Request3 = void 0;
var Response3 = void 0;
var Headers3 = void 0;
var FormData2 = void 0;
var Blob2 = void 0;
var File2 = void 0;
var ReadableStream2 = void 0;
var getMultipartRequestOptions = void 0;
var getDefaultAgent = void 0;
var fileFromPath = void 0;
var isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
  }
  if (kind) {
    throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch3 = shims.fetch;
  Request3 = shims.Request;
  Response3 = shims.Response;
  Headers3 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}

// node_modules/openai/_shims/MultipartBody.mjs
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// node_modules/openai/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import \u2026 from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}

// node_modules/openai/_shims/index.mjs
if (!kind)
  setShims(getRuntime(), { auto: true });

// node_modules/openai/error.mjs
var OpenAIError = class extends Error {
};
var APIError = class extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.request_id = headers == null ? void 0 : headers["x-request-id"];
    this.error = error;
    const data = error;
    this.code = data == null ? void 0 : data["code"];
    this.param = data == null ? void 0 : data["param"];
    this.type = data == null ? void 0 : data["type"];
  }
  static makeMessage(status, error, message) {
    const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error = errorResponse == null ? void 0 : errorResponse["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message != null ? message : "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
};
var AuthenticationError = class extends APIError {
};
var PermissionDeniedError = class extends APIError {
};
var NotFoundError = class extends APIError {
};
var ConflictError = class extends APIError {
};
var UnprocessableEntityError = class extends APIError {
};
var RateLimitError = class extends APIError {
};
var InternalServerError = class extends APIError {
};
var LengthFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the length limit was reached`);
  }
};
var ContentFilterFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the request was rejected by the content filter`);
  }
};

// node_modules/openai/internal/decoders/line.mjs
var LineDecoder = class {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);
    if (trailingNewline) {
      lines.pop();
    }
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    var _a2;
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        (_a2 = this.textDecoder) != null ? _a2 : this.textDecoder = new TextDecoder("utf8");
        return this.textDecoder.decode(bytes);
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;

// node_modules/openai/streaming.mjs
var Stream = class {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError(void 0, data.error, void 0, void 0);
            }
            yield data;
          } else {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (sse.event == "error") {
              throw new APIError(void 0, data.error, data.message, void 0);
            }
            yield { event: sse.event, data };
          }
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = readableStreamAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new Stream(() => teeIterator(left), this.controller),
      new Stream(() => teeIterator(right), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self2 = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream2({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a2;
        await ((_a2 = iter.return) == null ? void 0 : _a2.call(iter));
      }
    });
  }
};
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = readableStreamAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 2; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition(str2, delimiter) {
  const index2 = str2.indexOf(delimiter);
  if (index2 !== -1) {
    return [str2.substring(0, index2), delimiter, str2.substring(index2 + delimiter.length)];
  }
  return [str2, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/openai/uploads.mjs
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isUploadable = (value) => {
  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};
async function toFile(value, name, options) {
  var _a2, _b, _c;
  value = await value;
  if (isFileLike(value)) {
    return value;
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = (_a2 = new URL(value.url).pathname.split(/[\\/]/).pop()) != null ? _a2 : "unknown_file");
    const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];
    return new File2(data, name, options);
  }
  const bits = await getBytes(value);
  name || (name = (_b = getName(value)) != null ? _b : "unknown_file");
  if (!(options == null ? void 0 : options.type)) {
    const type = (_c = bits[0]) == null ? void 0 : _c.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes(value) {
  var _a2;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a2 = value == null ? void 0 : value.constructor) == null ? void 0 : _a2.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a2;
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  ((_a2 = getStringFromMaybeBuffer(value.path)) == null ? void 0 : _a2.split(/[\\/]/).pop());
}
var getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return void 0;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
var createForm = async (body) => {
  const form = new FormData2();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/openai/core.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const isJSON = (contentType == null ? void 0 : contentType.includes("application/json")) || (contentType == null ? void 0 : contentType.includes("application/vnd.api+json"));
  if (isJSON) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return _addRequestID(json, response);
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
function _addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("x-request-id"),
    enumerable: false
  });
}
var APIPromise = class extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("x-request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 6e5,
    // 10 minutes
    httpAgent,
    fetch: overriddenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overriddenFetch != null ? overriddenFetch : fetch3;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then(async (opts2) => {
      const body = opts2 && isBlobLike(opts2 == null ? void 0 : opts2.body) ? new DataView(await opts2.body.arrayBuffer()) : (opts2 == null ? void 0 : opts2.body) instanceof DataView ? opts2.body : (opts2 == null ? void 0 : opts2.body) instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2 == null ? void 0 : opts2.body) ? new DataView(opts2.body.buffer) : opts2 == null ? void 0 : opts2.body;
      return { method, path, ...opts2, body };
    }));
  }
  getAPIList(path, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    } else if (ArrayBuffer.isView(body)) {
      return body.byteLength.toString();
    }
    return null;
  }
  buildRequest(options, { retryCount = 0 } = {}) {
    var _a2, _b, _c, _d, _e, _f;
    const { method, path, query, headers = {} } = options;
    const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    const timeout = (_a2 = options.timeout) != null ? _a2 : this.timeout;
    const httpAgent = (_c = (_b = options.httpAgent) != null ? _b : this.httpAgent) != null ? _c : getDefaultAgent(url);
    const minAgentTimeout = timeout + 1e3;
    if (typeof ((_d = httpAgent == null ? void 0 : httpAgent.options) == null ? void 0 : _d.timeout) === "number" && minAgentTimeout > ((_e = httpAgent.options.timeout) != null ? _e : 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: (_f = options.signal) != null ? _f : null
    };
    return { req, url, timeout };
  }
  buildHeaders({ options, headers, contentLength, retryCount }) {
    const reqHeaders = {};
    if (contentLength) {
      reqHeaders["content-length"] = contentLength;
    }
    const defaultHeaders = this.defaultHeaders(options);
    applyHeadersMut(reqHeaders, defaultHeaders);
    applyHeadersMut(reqHeaders, headers);
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["content-type"];
    }
    if (getHeader(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader(headers, "x-stainless-retry-count") === void 0) {
      reqHeaders["x-stainless-retry-count"] = String(retryCount);
    }
    this.validateHeaders(reqHeaders, headers);
    return reqHeaders;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    var _a2, _b, _c;
    const options = await optionsInput;
    const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if ((_b = options.signal) == null ? void 0 : _b.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if ((_c = options.signal) == null ? void 0 : _c.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e) => castToError(e).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page2);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const fetchOptions = {
      signal: controller.signal,
      ...options
    };
    if (fetchOptions.method) {
      fetchOptions.method = fetchOptions.method.toUpperCase();
    }
    return (
      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
      this.fetch.call(void 0, url, fetchOptions).finally(() => {
        clearTimeout(timeout);
      })
    );
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    var _a2;
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after-ms"];
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after"];
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep2(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
};
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo && typeof nextOptions.query === "object") {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page2) {
    super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
var requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true,
  __binaryRequest: true,
  __binaryResponse: true,
  __streamClass: true
};
var isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
};
var getPlatformProperties = () => {
  var _a2, _b;
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : (_b = (_a2 = Deno.version) == null ? void 0 : _a2.deno) != null ? _b : "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders != null ? _platformHeaders : _platformHeaders = getPlatformProperties();
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep2 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      return new Error(JSON.stringify(err));
    } catch (e) {
    }
  }
  return new Error(err);
};
var readEnv = (env) => {
  var _a2, _b, _c, _d, _e, _f;
  if (typeof process !== "undefined") {
    return (_c = (_b = (_a2 = process.env) == null ? void 0 : _a2[env]) == null ? void 0 : _b.trim()) != null ? _c : void 0;
  }
  if (typeof Deno !== "undefined") {
    return (_f = (_e = (_d = Deno.env) == null ? void 0 : _d.get) == null ? void 0 : _e.call(_d, env)) == null ? void 0 : _f.trim();
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k in newHeaders) {
    if (!hasOwn(newHeaders, k))
      continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
var SENSITIVE_HEADERS = /* @__PURE__ */ new Set(["authorization", "api-key"]);
function debug(action, ...args) {
  var _a2;
  if (typeof process !== "undefined" && ((_a2 = process == null ? void 0 : process.env) == null ? void 0 : _a2["DEBUG"]) === "true") {
    const modifiedArgs = args.map((arg) => {
      if (!arg) {
        return arg;
      }
      if (arg["headers"]) {
        const modifiedArg2 = { ...arg, headers: { ...arg["headers"] } };
        for (const header in arg["headers"]) {
          if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
            modifiedArg2["headers"][header] = "REDACTED";
          }
        }
        return modifiedArg2;
      }
      let modifiedArg = null;
      for (const header in arg) {
        if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
          modifiedArg != null ? modifiedArg : modifiedArg = { ...arg };
          modifiedArg[header] = "REDACTED";
        }
      }
      return modifiedArg != null ? modifiedArg : arg;
    });
    console.log(`OpenAI:DEBUG:${action}`, ...modifiedArgs);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
var isHeadersProtocol = (headers) => {
  return typeof (headers == null ? void 0 : headers.get) === "function";
};
var getHeader = (headers, header) => {
  var _a2;
  const lowerCasedHeader = header.toLowerCase();
  if (isHeadersProtocol(headers)) {
    const intercapsHeader = ((_a2 = header[0]) == null ? void 0 : _a2.toUpperCase()) + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
      const value = headers.get(key);
      if (value) {
        return value;
      }
    }
  }
  for (const [key, value] of Object.entries(headers)) {
    if (key.toLowerCase() === lowerCasedHeader) {
      if (Array.isArray(value)) {
        if (value.length <= 1)
          return value[0];
        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
        return value[0];
      }
      return value;
    }
  }
  return void 0;
};
function isObj(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj);
}

// node_modules/openai/pagination.mjs
var Page = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    var _a2;
    return (_a2 = this.data) != null ? _a2 : [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
};
var CursorPage = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
  }
  getPaginatedItems() {
    var _a2;
    return (_a2 = this.data) != null ? _a2 : [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info)
      return null;
    if ("params" in info)
      return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    var _a2;
    const data = this.getPaginatedItems();
    if (!data.length) {
      return null;
    }
    const id = (_a2 = data[data.length - 1]) == null ? void 0 : _a2.id;
    if (!id) {
      return null;
    }
    return { params: { after: id } };
  }
};

// node_modules/openai/resource.mjs
var APIResource = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/openai/resources/chat/completions.mjs
var Completions = class extends APIResource {
  create(body, options) {
    var _a2;
    return this._client.post("/chat/completions", { body, ...options, stream: (_a2 = body.stream) != null ? _a2 : false });
  }
};

// node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this._client);
  }
};
Chat.Completions = Completions;

// node_modules/openai/resources/audio/speech.mjs
var Speech = class extends APIResource {
  /**
   * Generates audio from the input text.
   */
  create(body, options) {
    return this._client.post("/audio/speech", {
      body,
      ...options,
      headers: { Accept: "application/octet-stream", ...options == null ? void 0 : options.headers },
      __binaryResponse: true
    });
  }
};

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource {
  create(body, options) {
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions({ body, ...options }));
  }
};

// node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource {
  create(body, options) {
    return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options }));
  }
};

// node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
};
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;
Audio.Speech = Speech;

// node_modules/openai/resources/batches.mjs
var Batches = class extends APIResource {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(body, options) {
    return this._client.post("/batches", { body, ...options });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(batchId, options) {
    return this._client.get(`/batches/${batchId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/batches", BatchesPage, { query, ...options });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(batchId, options) {
    return this._client.post(`/batches/${batchId}/cancel`, options);
  }
};
var BatchesPage = class extends CursorPage {
};
Batches.BatchesPage = BatchesPage;

// node_modules/openai/resources/beta/assistants.mjs
var Assistants = class extends APIResource {
  /**
   * Create an assistant with a model and instructions.
   */
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves an assistant.
   */
  retrieve(assistantId, options) {
    return this._client.get(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies an assistant.
   */
  update(assistantId, body, options) {
    return this._client.post(`/assistants/${assistantId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/assistants", AssistantsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete an assistant.
   */
  del(assistantId, options) {
    return this._client.delete(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};
var AssistantsPage = class extends CursorPage {
};
Assistants.AssistantsPage = AssistantsPage;

// node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}

// node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage = (message) => {
  return (message == null ? void 0 : message.role) === "assistant";
};
var isFunctionMessage = (message) => {
  return (message == null ? void 0 : message.role) === "function";
};
var isToolMessage = (message) => {
  return (message == null ? void 0 : message.role) === "tool";
};

// node_modules/openai/lib/EventStream.mjs
var __classPrivateFieldSet2 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EventStream_instances;
var _EventStream_connectedPromise;
var _EventStream_resolveConnectedPromise;
var _EventStream_rejectConnectedPromise;
var _EventStream_endPromise;
var _EventStream_resolveEndPromise;
var _EventStream_rejectEndPromise;
var _EventStream_listeners;
var _EventStream_ended;
var _EventStream_errored;
var _EventStream_aborted;
var _EventStream_catchingPromiseCreated;
var _EventStream_handleError;
var EventStream = class {
  constructor() {
    _EventStream_instances.add(this);
    this.controller = new AbortController();
    _EventStream_connectedPromise.set(this, void 0);
    _EventStream_resolveConnectedPromise.set(this, () => {
    });
    _EventStream_rejectConnectedPromise.set(this, () => {
    });
    _EventStream_endPromise.set(this, void 0);
    _EventStream_resolveEndPromise.set(this, () => {
    });
    _EventStream_rejectEndPromise.set(this, () => {
    });
    _EventStream_listeners.set(this, {});
    _EventStream_ended.set(this, false);
    _EventStream_errored.set(this, false);
    _EventStream_aborted.set(this, false);
    _EventStream_catchingPromiseCreated.set(this, false);
    __classPrivateFieldSet2(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _EventStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet2(this, _EventStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet2(this, _EventStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _EventStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet2(this, _EventStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet2(this, _EventStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet2(this, _EventStream_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet2(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
    }, 0);
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet2(this, _EventStream_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet2(this, _EventStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet2(this, _EventStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet2(this, _EventStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index2 = listeners.findIndex((l) => l.listener === listener);
    if (index2 >= 0)
      listeners.splice(index2, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _EventStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet2(this, _EventStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet2(this, _EventStream_endPromise, "f");
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet2(this, _EventStream_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet2(this, _EventStream_ended, true, "f");
      __classPrivateFieldGet2(this, _EventStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
  }
};
_EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error) {
  __classPrivateFieldSet2(this, _EventStream_errored, true, "f");
  if (error instanceof Error && error.name === "AbortError") {
    error = new APIUserAbortError();
  }
  if (error instanceof APIUserAbortError) {
    __classPrivateFieldSet2(this, _EventStream_aborted, true, "f");
    return this._emit("abort", error);
  }
  if (error instanceof OpenAIError) {
    return this._emit("error", error);
  }
  if (error instanceof Error) {
    const openAIError = new OpenAIError(error.message);
    openAIError.cause = error;
    return this._emit("error", openAIError);
  }
  return this._emit("error", new OpenAIError(String(error)));
};

// node_modules/openai/lib/parser.mjs
function isAutoParsableResponseFormat(response_format) {
  return (response_format == null ? void 0 : response_format["$brand"]) === "auto-parseable-response-format";
}
function isAutoParsableTool(tool) {
  return (tool == null ? void 0 : tool["$brand"]) === "auto-parseable-tool";
}
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => {
        var _a2;
        return {
          ...choice,
          message: { ...choice.message, parsed: null, tool_calls: (_a2 = choice.message.tool_calls) != null ? _a2 : [] }
        };
      })
    };
  }
  return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    var _a2, _b;
    if (choice.finish_reason === "length") {
      throw new LengthFinishReasonError();
    }
    if (choice.finish_reason === "content_filter") {
      throw new ContentFilterFinishReasonError();
    }
    return {
      ...choice,
      message: {
        ...choice.message,
        tool_calls: (_b = (_a2 = choice.message.tool_calls) == null ? void 0 : _a2.map((toolCall) => parseToolCall(params, toolCall))) != null ? _b : [],
        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
      }
    };
  });
  return { ...completion, choices };
}
function parseResponseFormat(params, content) {
  var _a2, _b;
  if (((_a2 = params.response_format) == null ? void 0 : _a2.type) !== "json_schema") {
    return null;
  }
  if (((_b = params.response_format) == null ? void 0 : _b.type) === "json_schema") {
    if ("$parseRaw" in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
function parseToolCall(params, toolCall) {
  var _a2;
  const inputTool = (_a2 = params.tools) == null ? void 0 : _a2.find((inputTool2) => {
    var _a3;
    return ((_a3 = inputTool2.function) == null ? void 0 : _a3.name) === toolCall.function.name;
  });
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCall.function.arguments) : null
    }
  };
}
function shouldParseToolCall(params, toolCall) {
  var _a2;
  if (!params) {
    return false;
  }
  const inputTool = (_a2 = params.tools) == null ? void 0 : _a2.find((inputTool2) => {
    var _a3;
    return ((_a3 = inputTool2.function) == null ? void 0 : _a3.name) === toolCall.function.name;
  });
  return isAutoParsableTool(inputTool) || (inputTool == null ? void 0 : inputTool.function.strict) || false;
}
function hasAutoParseableInput(params) {
  var _a2, _b;
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return (_b = (_a2 = params.tools) == null ? void 0 : _a2.some((t) => isAutoParsableTool(t) || t.type === "function" && t.function.strict === true)) != null ? _b : false;
}
function validateInputTools(tools) {
  for (const tool of tools != null ? tools : []) {
    if (tool.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
    }
    if (tool.function.strict !== true) {
      throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
    }
  }
}

// node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var __classPrivateFieldGet3 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractChatCompletionRunner_instances;
var _AbstractChatCompletionRunner_getFinalContent;
var _AbstractChatCompletionRunner_getFinalMessage;
var _AbstractChatCompletionRunner_getFinalFunctionCall;
var _AbstractChatCompletionRunner_getFinalFunctionCallResult;
var _AbstractChatCompletionRunner_calculateTotalUsage;
var _AbstractChatCompletionRunner_validateParams;
var _AbstractChatCompletionRunner_stringifyFunctionCallResult;
var DEFAULT_MAX_CHAT_COMPLETIONS = 10;
var AbstractChatCompletionRunner = class extends EventStream {
  constructor() {
    super(...arguments);
    _AbstractChatCompletionRunner_instances.add(this);
    this._chatCompletions = [];
    this.messages = [];
  }
  _addChatCompletion(chatCompletion) {
    var _a2;
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = (_a2 = chatCompletion.choices[0]) == null ? void 0 : _a2.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {
        this._emit("functionCallResult", message.content);
      } else if (isAssistantMessage(message) && message.function_call) {
        this._emit("functionCall", message.function_call);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionCall", tool_call.function);
          }
        }
      }
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionCall() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
  }
  async finalFunctionCallResult() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(client, params, options) {
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
  }
  async _runChatCompletion(client, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(client, params, options);
  }
  async _runFunctions(client, params, options) {
    var _a2;
    const role = "function";
    const { function_call = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof function_call !== "string" && (function_call == null ? void 0 : function_call.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const functionsByName = {};
    for (const f of params.functions) {
      functionsByName[f.name || f.function.name] = f;
    }
    const functions = params.functions.map((f) => ({
      name: f.name || f.function.name,
      parameters: f.parameters,
      description: f.description
    }));
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        function_call,
        functions,
        messages: [...this.messages]
      }, options);
      const message = (_a2 = chatCompletion.choices[0]) == null ? void 0 : _a2.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.function_call)
        return;
      const { name, arguments: args } = message.function_call;
      const fn = functionsByName[name];
      if (!fn) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f) => JSON.stringify(f.name)).join(", ")}. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      } else if (singleFunctionToCall && singleFunctionToCall !== name) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      }
      let parsed;
      try {
        parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
      } catch (error) {
        this._addMessage({
          role,
          name,
          content: error instanceof Error ? error.message : String(error)
        });
        continue;
      }
      const rawContent = await fn.function(parsed, this);
      const content = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
      this._addMessage({ role, name, content });
      if (singleFunctionToCall)
        return;
    }
  }
  async _runTools(client, params, options) {
    var _a2, _b, _c;
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && ((_a2 = tool_choice == null ? void 0 : tool_choice.function) == null ? void 0 : _a2.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const inputTools = params.tools.map((tool) => {
      if (isAutoParsableTool(tool)) {
        if (!tool.$callback) {
          throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
        }
        return {
          type: "function",
          function: {
            function: tool.$callback,
            name: tool.function.name,
            description: tool.function.description || "",
            parameters: tool.function.parameters,
            parse: tool.$parseRaw,
            strict: true
          }
        };
      }
      return tool;
    });
    const functionsByName = {};
    for (const f of inputTools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
      type: "function",
      function: {
        name: t.function.name || t.function.function.name,
        parameters: t.function.parameters,
        description: t.function.description,
        strict: t.function.strict
      }
    } : t) : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options);
      const message = (_b = chatCompletion.choices[0]) == null ? void 0 : _b.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!((_c = message.tool_calls) == null ? void 0 : _c.length)) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error) {
          const content2 = error instanceof Error ? error.message : String(error);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
};
_AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  var _a2;
  return (_a2 = __classPrivateFieldGet3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content) != null ? _a2 : null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  var _a2, _b;
  let i = this.messages.length;
  while (i-- > 0) {
    const message = this.messages[i];
    if (isAssistantMessage(message)) {
      const { function_call, ...rest } = message;
      const ret = {
        ...rest,
        content: (_a2 = message.content) != null ? _a2 : null,
        refusal: (_b = message.refusal) != null ? _b : null
      };
      if (function_call) {
        ret.function_call = function_call;
      }
      return ret;
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall2() {
  var _a2, _b;
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isAssistantMessage(message) && (message == null ? void 0 : message.function_call)) {
      return message.function_call;
    }
    if (isAssistantMessage(message) && ((_a2 = message == null ? void 0 : message.tool_calls) == null ? void 0 : _a2.length)) {
      return (_b = message.tool_calls.at(-1)) == null ? void 0 : _b.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isFunctionMessage(message) && message.content != null) {
      return message.content;
    }
    if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => {
      var _a2;
      return x.role === "assistant" && ((_a2 = x.tool_calls) == null ? void 0 : _a2.some((y) => y.type === "function" && y.id === message.tool_call_id));
    })) {
      return message.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
};

// node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner = class extends AbstractChatCompletionRunner {
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(client, params, options) {
    const runner = new ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(client, params, opts));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
  _addMessage(message, emit = true) {
    super._addMessage(message, emit);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
};

// node_modules/openai/_vendor/partial-json-parser/parser.mjs
var STR = 1;
var NUM = 2;
var ARR = 4;
var OBJ = 8;
var NULL = 16;
var BOOL = 32;
var NAN = 64;
var INFINITY = 128;
var MINUS_INFINITY = 256;
var INF = INFINITY | MINUS_INFINITY;
var SPECIAL = NULL | BOOL | INF | NAN;
var ATOM = STR | NUM | SPECIAL;
var COLLECTION = ARR | OBJ;
var ALL = ATOM | COLLECTION;
var Allow = {
  STR,
  NUM,
  ARR,
  OBJ,
  NULL,
  BOOL,
  NAN,
  INFINITY,
  MINUS_INFINITY,
  INF,
  SPECIAL,
  ATOM,
  COLLECTION,
  ALL
};
var PartialJSON = class extends Error {
};
var MalformedJSON = class extends Error {
};
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
var _parseJSON = (jsonString, allow) => {
  const length = jsonString.length;
  let index2 = 0;
  const markPartialJSON = (msg) => {
    throw new PartialJSON(`${msg} at position ${index2}`);
  };
  const throwMalformedError = (msg) => {
    throw new MalformedJSON(`${msg} at position ${index2}`);
  };
  const parseAny = () => {
    skipBlank();
    if (index2 >= length)
      markPartialJSON("Unexpected end of input");
    if (jsonString[index2] === '"')
      return parseStr();
    if (jsonString[index2] === "{")
      return parseObj();
    if (jsonString[index2] === "[")
      return parseArr();
    if (jsonString.substring(index2, index2 + 4) === "null" || Allow.NULL & allow && length - index2 < 4 && "null".startsWith(jsonString.substring(index2))) {
      index2 += 4;
      return null;
    }
    if (jsonString.substring(index2, index2 + 4) === "true" || Allow.BOOL & allow && length - index2 < 4 && "true".startsWith(jsonString.substring(index2))) {
      index2 += 4;
      return true;
    }
    if (jsonString.substring(index2, index2 + 5) === "false" || Allow.BOOL & allow && length - index2 < 5 && "false".startsWith(jsonString.substring(index2))) {
      index2 += 5;
      return false;
    }
    if (jsonString.substring(index2, index2 + 8) === "Infinity" || Allow.INFINITY & allow && length - index2 < 8 && "Infinity".startsWith(jsonString.substring(index2))) {
      index2 += 8;
      return Infinity;
    }
    if (jsonString.substring(index2, index2 + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index2 && length - index2 < 9 && "-Infinity".startsWith(jsonString.substring(index2))) {
      index2 += 9;
      return -Infinity;
    }
    if (jsonString.substring(index2, index2 + 3) === "NaN" || Allow.NAN & allow && length - index2 < 3 && "NaN".startsWith(jsonString.substring(index2))) {
      index2 += 3;
      return NaN;
    }
    return parseNum();
  };
  const parseStr = () => {
    const start = index2;
    let escape2 = false;
    index2++;
    while (index2 < length && (jsonString[index2] !== '"' || escape2 && jsonString[index2 - 1] === "\\")) {
      escape2 = jsonString[index2] === "\\" ? !escape2 : false;
      index2++;
    }
    if (jsonString.charAt(index2) == '"') {
      try {
        return JSON.parse(jsonString.substring(start, ++index2 - Number(escape2)));
      } catch (e) {
        throwMalformedError(String(e));
      }
    } else if (Allow.STR & allow) {
      try {
        return JSON.parse(jsonString.substring(start, index2 - Number(escape2)) + '"');
      } catch (e) {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
      }
    }
    markPartialJSON("Unterminated string literal");
  };
  const parseObj = () => {
    index2++;
    skipBlank();
    const obj = {};
    try {
      while (jsonString[index2] !== "}") {
        skipBlank();
        if (index2 >= length && Allow.OBJ & allow)
          return obj;
        const key = parseStr();
        skipBlank();
        index2++;
        try {
          const value = parseAny();
          Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
        } catch (e) {
          if (Allow.OBJ & allow)
            return obj;
          else
            throw e;
        }
        skipBlank();
        if (jsonString[index2] === ",")
          index2++;
      }
    } catch (e) {
      if (Allow.OBJ & allow)
        return obj;
      else
        markPartialJSON("Expected '}' at end of object");
    }
    index2++;
    return obj;
  };
  const parseArr = () => {
    index2++;
    const arr = [];
    try {
      while (jsonString[index2] !== "]") {
        arr.push(parseAny());
        skipBlank();
        if (jsonString[index2] === ",") {
          index2++;
        }
      }
    } catch (e) {
      if (Allow.ARR & allow) {
        return arr;
      }
      markPartialJSON("Expected ']' at end of array");
    }
    index2++;
    return arr;
  };
  const parseNum = () => {
    if (index2 === 0) {
      if (jsonString === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString);
      } catch (e) {
        if (Allow.NUM & allow) {
          try {
            if ("." === jsonString[jsonString.length - 1])
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
          } catch (e2) {
          }
        }
        throwMalformedError(String(e));
      }
    }
    const start = index2;
    if (jsonString[index2] === "-")
      index2++;
    while (jsonString[index2] && !",]}".includes(jsonString[index2]))
      index2++;
    if (index2 == length && !(Allow.NUM & allow))
      markPartialJSON("Unterminated number literal");
    try {
      return JSON.parse(jsonString.substring(start, index2));
    } catch (e) {
      if (jsonString.substring(start, index2) === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
      } catch (e2) {
        throwMalformedError(String(e2));
      }
    }
  };
  const skipBlank = () => {
    while (index2 < length && " \n\r	".includes(jsonString[index2])) {
      index2++;
    }
  };
  return parseAny();
};
var partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);

// node_modules/openai/lib/ChatCompletionStream.mjs
var __classPrivateFieldSet3 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet4 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ChatCompletionStream_instances;
var _ChatCompletionStream_params;
var _ChatCompletionStream_choiceEventStates;
var _ChatCompletionStream_currentChatCompletionSnapshot;
var _ChatCompletionStream_beginRequest;
var _ChatCompletionStream_getChoiceEventState;
var _ChatCompletionStream_addChunk;
var _ChatCompletionStream_emitToolCallDoneEvent;
var _ChatCompletionStream_emitContentDoneEvents;
var _ChatCompletionStream_endRequest;
var _ChatCompletionStream_getAutoParseableResponseFormat;
var _ChatCompletionStream_accumulateChatCompletion;
var ChatCompletionStream = class extends AbstractChatCompletionRunner {
  constructor(params) {
    super();
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_params.set(this, void 0);
    _ChatCompletionStream_choiceEventStates.set(this, void 0);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
    __classPrivateFieldSet3(this, _ChatCompletionStream_params, params, "f");
    __classPrivateFieldSet3(this, _ChatCompletionStream_choiceEventStates, [], "f");
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet4(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStream(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(client, params, options) {
    const runner = new ChatCompletionStream(params);
    runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(client, params, options) {
    var _a2;
    super._createChatCompletion;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
  }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
    let state = __classPrivateFieldGet4(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
    if (state) {
      return state;
    }
    state = {
      content_done: false,
      refusal_done: false,
      logprobs_content_done: false,
      logprobs_refusal_done: false,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    };
    __classPrivateFieldGet4(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
    return state;
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    for (const choice of chunk.choices) {
      const choiceSnapshot = completion.choices[choice.index];
      if (choice.delta.content != null && ((_a2 = choiceSnapshot.message) == null ? void 0 : _a2.role) === "assistant" && ((_b = choiceSnapshot.message) == null ? void 0 : _b.content)) {
        this._emit("content", choice.delta.content, choiceSnapshot.message.content);
        this._emit("content.delta", {
          delta: choice.delta.content,
          snapshot: choiceSnapshot.message.content,
          parsed: choiceSnapshot.message.parsed
        });
      }
      if (choice.delta.refusal != null && ((_c = choiceSnapshot.message) == null ? void 0 : _c.role) === "assistant" && ((_d = choiceSnapshot.message) == null ? void 0 : _d.refusal)) {
        this._emit("refusal.delta", {
          delta: choice.delta.refusal,
          snapshot: choiceSnapshot.message.refusal
        });
      }
      if (((_e = choice.logprobs) == null ? void 0 : _e.content) != null && ((_f = choiceSnapshot.message) == null ? void 0 : _f.role) === "assistant") {
        this._emit("logprobs.content.delta", {
          content: (_g = choice.logprobs) == null ? void 0 : _g.content,
          snapshot: (_i = (_h = choiceSnapshot.logprobs) == null ? void 0 : _h.content) != null ? _i : []
        });
      }
      if (((_j = choice.logprobs) == null ? void 0 : _j.refusal) != null && ((_k = choiceSnapshot.message) == null ? void 0 : _k.role) === "assistant") {
        this._emit("logprobs.refusal.delta", {
          refusal: (_l = choice.logprobs) == null ? void 0 : _l.refusal,
          snapshot: (_n = (_m = choiceSnapshot.logprobs) == null ? void 0 : _m.refusal) != null ? _n : []
        });
      }
      const state = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.finish_reason) {
        __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
        if (state.current_tool_call_index != null) {
          __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
        }
      }
      for (const toolCall of (_o = choice.delta.tool_calls) != null ? _o : []) {
        if (state.current_tool_call_index !== toolCall.index) {
          __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        state.current_tool_call_index = toolCall.index;
      }
      for (const toolCallDelta of (_p = choice.delta.tool_calls) != null ? _p : []) {
        const toolCallSnapshot = (_q = choiceSnapshot.message.tool_calls) == null ? void 0 : _q[toolCallDelta.index];
        if (!(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type)) {
          continue;
        }
        if ((toolCallSnapshot == null ? void 0 : toolCallSnapshot.type) === "function") {
          this._emit("tool_calls.function.arguments.delta", {
            name: (_r = toolCallSnapshot.function) == null ? void 0 : _r.name,
            index: toolCallDelta.index,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: toolCallSnapshot.function.parsed_arguments,
            arguments_delta: (_t = (_s = toolCallDelta.function) == null ? void 0 : _s.arguments) != null ? _t : ""
          });
        } else {
          assertNever(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type);
        }
      }
    }
  }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
    var _a2, _b, _c;
    const state = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (state.done_tool_calls.has(toolCallIndex)) {
      return;
    }
    const toolCallSnapshot = (_a2 = choiceSnapshot.message.tool_calls) == null ? void 0 : _a2[toolCallIndex];
    if (!toolCallSnapshot) {
      throw new Error("no tool call snapshot");
    }
    if (!toolCallSnapshot.type) {
      throw new Error("tool call snapshot missing `type`");
    }
    if (toolCallSnapshot.type === "function") {
      const inputTool = (_c = (_b = __classPrivateFieldGet4(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _b.tools) == null ? void 0 : _c.find((tool) => tool.type === "function" && tool.function.name === toolCallSnapshot.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: toolCallSnapshot.function.name,
        index: toolCallIndex,
        arguments: toolCallSnapshot.function.arguments,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCallSnapshot.function.arguments) : null
      });
    } else {
      assertNever(toolCallSnapshot.type);
    }
  }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
    var _a2, _b;
    const state = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (choiceSnapshot.message.content && !state.content_done) {
      state.content_done = true;
      const responseFormat = __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
      this._emit("content.done", {
        content: choiceSnapshot.message.content,
        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
      });
    }
    if (choiceSnapshot.message.refusal && !state.refusal_done) {
      state.refusal_done = true;
      this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
    }
    if (((_a2 = choiceSnapshot.logprobs) == null ? void 0 : _a2.content) && !state.logprobs_content_done) {
      state.logprobs_content_done = true;
      this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
    }
    if (((_b = choiceSnapshot.logprobs) == null ? void 0 : _b.refusal) && !state.logprobs_refusal_done) {
      state.logprobs_refusal_done = true;
      this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet4(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
    __classPrivateFieldSet3(this, _ChatCompletionStream_choiceEventStates, [], "f");
    return finalizeChatCompletion(snapshot, __classPrivateFieldGet4(this, _ChatCompletionStream_params, "f"));
  }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
    var _a2;
    const responseFormat = (_a2 = __classPrivateFieldGet4(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _a2.response_format;
    if (isAutoParsableResponseFormat(responseFormat)) {
      return responseFormat;
    }
    return null;
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
    var _a3, _b2, _c2, _d2, _e, _f;
    var _a2, _b, _c, _d;
    let snapshot = __classPrivateFieldGet4(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      }, "f");
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index: index2, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index2];
      if (!choice) {
        choice = snapshot.choices[index2] = { finish_reason, index: index2, message: {}, logprobs, ...other };
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = Object.assign({}, logprobs);
        } else {
          const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
          assertIsEmpty(rest3);
          Object.assign(choice.logprobs, rest3);
          if (content2) {
            (_a3 = (_a2 = choice.logprobs).content) != null ? _a3 : _a2.content = [];
            choice.logprobs.content.push(...content2);
          }
          if (refusal2) {
            (_b2 = (_b = choice.logprobs).refusal) != null ? _b2 : _b.refusal = [];
            choice.logprobs.refusal.push(...refusal2);
          }
        }
      }
      if (finish_reason) {
        choice.finish_reason = finish_reason;
        if (__classPrivateFieldGet4(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput(__classPrivateFieldGet4(this, _ChatCompletionStream_params, "f"))) {
          if (finish_reason === "length") {
            throw new LengthFinishReasonError();
          }
          if (finish_reason === "content_filter") {
            throw new ContentFilterFinishReasonError();
          }
        }
      }
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
      assertIsEmpty(rest2);
      Object.assign(choice.message, rest2);
      if (refusal) {
        choice.message.refusal = (choice.message.refusal || "") + refusal;
      }
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_c2 = (_c = choice.message.function_call).arguments) != null ? _c2 : _c.arguments = "";
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (content) {
        choice.message.content = (choice.message.content || "") + content;
        if (!choice.message.refusal && __classPrivateFieldGet4(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
          choice.message.parsed = partialParse(choice.message.content);
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index3, id, type, function: fn, ...rest3 } of tool_calls) {
          const tool_call = (_d2 = (_d = choice.message.tool_calls)[index3]) != null ? _d2 : _d[index3] = {};
          Object.assign(tool_call, rest3);
          if (id)
            tool_call.id = id;
          if (type)
            tool_call.type = type;
          if (fn)
            (_f = tool_call.function) != null ? _f : tool_call.function = { name: (_e = fn.name) != null ? _e : "", arguments: "" };
          if (fn == null ? void 0 : fn.name)
            tool_call.function.name = fn.name;
          if (fn == null ? void 0 : fn.arguments) {
            tool_call.function.arguments += fn.arguments;
            if (shouldParseToolCall(__classPrivateFieldGet4(this, _ChatCompletionStream_params, "f"), tool_call)) {
              tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
            }
          }
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function finalizeChatCompletion(snapshot, params) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index: index2, logprobs, ...choiceRest }) => {
      var _a2, _b, _c;
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index2}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index2}`);
      }
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index2}`);
        }
        if (!name) {
          throw new OpenAIError(`missing function_call.name for choice ${index2}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name },
            role,
            refusal: (_a2 = message.refusal) != null ? _a2 : null
          },
          finish_reason,
          index: index2,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index: index2,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: (_b = message.refusal) != null ? _b : null,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].id
${str(snapshot)}`);
              }
              if (type == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].type
${str(snapshot)}`);
              }
              if (name == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].function.name
${str(snapshot)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
              }
              return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: (_c = message.refusal) != null ? _c : null },
        finish_reason,
        index: index2,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
  return maybeParseChatCompletion(completion, params);
}
function str(x) {
  return JSON.stringify(x);
}
function assertIsEmpty(obj) {
  return;
}
function assertNever(_x) {
}

// node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner = class extends ChatCompletionStream {
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStreamingRunner(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(client, params, options) {
    const runner = new ChatCompletionStreamingRunner(null);
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(client, params, opts));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new ChatCompletionStreamingRunner(
      // @ts-expect-error TODO these types are incompatible
      params
    );
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
};

// node_modules/openai/resources/beta/chat/completions.mjs
var Completions2 = class extends APIResource {
  parse(body, options) {
    validateInputTools(body.tools);
    return this._client.chat.completions.create(body, {
      ...options,
      headers: {
        ...options == null ? void 0 : options.headers,
        "X-Stainless-Helper-Method": "beta.chat.completions.parse"
      }
    })._thenUnwrap((completion) => parseChatCompletion(completion, body));
  }
  runFunctions(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runFunctions(this._client, body, options);
    }
    return ChatCompletionRunner.runFunctions(this._client, body, options);
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client, body, options);
    }
    return ChatCompletionRunner.runTools(this._client, body, options);
  }
  /**
   * Creates a chat completion stream
   */
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(this._client, body, options);
  }
};

// node_modules/openai/resources/beta/chat/chat.mjs
var Chat2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions2(this._client);
  }
};
(function(Chat3) {
  Chat3.Completions = Completions2;
})(Chat2 || (Chat2 = {}));

// node_modules/openai/resources/beta/realtime/sessions.mjs
var Sessions = class extends APIResource {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   */
  create(body, options) {
    return this._client.post("/realtime/sessions", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};

// node_modules/openai/resources/beta/realtime/realtime.mjs
var Realtime = class extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions(this._client);
  }
};
Realtime.Sessions = Sessions;

// node_modules/openai/lib/AssistantStream.mjs
var __classPrivateFieldGet5 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet4 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _AssistantStream_instances;
var _AssistantStream_events;
var _AssistantStream_runStepSnapshots;
var _AssistantStream_messageSnapshots;
var _AssistantStream_messageSnapshot;
var _AssistantStream_finalRun;
var _AssistantStream_currentContentIndex;
var _AssistantStream_currentContent;
var _AssistantStream_currentToolCallIndex;
var _AssistantStream_currentToolCall;
var _AssistantStream_currentEvent;
var _AssistantStream_currentRunSnapshot;
var _AssistantStream_currentRunStepSnapshot;
var _AssistantStream_addEvent;
var _AssistantStream_endRequest;
var _AssistantStream_handleMessage;
var _AssistantStream_handleRunStep;
var _AssistantStream_handleEvent;
var _AssistantStream_accumulateRunStep;
var _AssistantStream_accumulateMessage;
var _AssistantStream_accumulateContent;
var _AssistantStream_handleRun;
var AssistantStream = class extends EventStream {
  constructor() {
    super(...arguments);
    _AssistantStream_instances.add(this);
    _AssistantStream_events.set(this, []);
    _AssistantStream_runStepSnapshots.set(this, {});
    _AssistantStream_messageSnapshots.set(this, {});
    _AssistantStream_messageSnapshot.set(this, void 0);
    _AssistantStream_finalRun.set(this, void 0);
    _AssistantStream_currentContentIndex.set(this, void 0);
    _AssistantStream_currentContent.set(this, void 0);
    _AssistantStream_currentToolCallIndex.set(this, void 0);
    _AssistantStream_currentToolCall.set(this, void 0);
    _AssistantStream_currentEvent.set(this, void 0);
    _AssistantStream_currentRunSnapshot.set(this, void 0);
    _AssistantStream_currentRunStepSnapshot.set(this, void 0);
  }
  [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  static fromReadableStream(stream) {
    const runner = new AssistantStream();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  async _fromReadableStream(readableStream, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
  static createToolAssistantStream(threadId, runId, runs, params, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createToolAssistantStream(run, threadId, runId, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.submitToolOutputs(threadId, runId, body, {
      ...options,
      signal: this.controller.signal
    });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static createThreadAssistantStream(params, thread, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._threadAssistantStream(params, thread, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  static createAssistantStream(threadId, runs, params, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._runAssistantStream(threadId, runs, params, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  currentEvent() {
    return __classPrivateFieldGet5(this, _AssistantStream_currentEvent, "f");
  }
  currentRun() {
    return __classPrivateFieldGet5(this, _AssistantStream_currentRunSnapshot, "f");
  }
  currentMessageSnapshot() {
    return __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f");
  }
  currentRunStepSnapshot() {
    return __classPrivateFieldGet5(this, _AssistantStream_currentRunStepSnapshot, "f");
  }
  async finalRunSteps() {
    await this.done();
    return Object.values(__classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f"));
  }
  async finalMessages() {
    await this.done();
    return Object.values(__classPrivateFieldGet5(this, _AssistantStream_messageSnapshots, "f"));
  }
  async finalRun() {
    await this.done();
    if (!__classPrivateFieldGet5(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run was not received.");
    return __classPrivateFieldGet5(this, _AssistantStream_finalRun, "f");
  }
  async _createThreadAssistantStream(thread, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  async _createAssistantStream(run, threadId, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static accumulateDelta(acc, delta) {
    for (const [key, deltaValue] of Object.entries(delta)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = deltaValue;
        continue;
      }
      let accValue = acc[key];
      if (accValue === null || accValue === void 0) {
        acc[key] = deltaValue;
        continue;
      }
      if (key === "index" || key === "type") {
        acc[key] = deltaValue;
        continue;
      }
      if (typeof accValue === "string" && typeof deltaValue === "string") {
        accValue += deltaValue;
      } else if (typeof accValue === "number" && typeof deltaValue === "number") {
        accValue += deltaValue;
      } else if (isObj(accValue) && isObj(deltaValue)) {
        accValue = this.accumulateDelta(accValue, deltaValue);
      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
        if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
          accValue.push(...deltaValue);
          continue;
        }
        for (const deltaEntry of deltaValue) {
          if (!isObj(deltaEntry)) {
            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
          }
          const index2 = deltaEntry["index"];
          if (index2 == null) {
            console.error(deltaEntry);
            throw new Error("Expected array delta entry to have an `index` property");
          }
          if (typeof index2 !== "number") {
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index2}`);
          }
          const accEntry = accValue[index2];
          if (accEntry == null) {
            accValue.push(deltaEntry);
          } else {
            accValue[index2] = this.accumulateDelta(accEntry, deltaEntry);
          }
        }
        continue;
      } else {
        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
      }
      acc[key] = accValue;
    }
    return acc;
  }
  _addRun(run) {
    return run;
  }
  async _threadAssistantStream(params, thread, options) {
    return await this._createThreadAssistantStream(thread, params, options);
  }
  async _runAssistantStream(threadId, runs, params, options) {
    return await this._createAssistantStream(runs, threadId, params, options);
  }
  async _runToolAssistantStream(threadId, runId, runs, params, options) {
    return await this._createToolAssistantStream(runs, threadId, runId, params, options);
  }
};
_AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
  if (this.ended)
    return;
  __classPrivateFieldSet4(this, _AssistantStream_currentEvent, event, "f");
  __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
  switch (event.event) {
    case "thread.created":
      break;
    case "thread.run.created":
    case "thread.run.queued":
    case "thread.run.in_progress":
    case "thread.run.requires_action":
    case "thread.run.completed":
    case "thread.run.failed":
    case "thread.run.cancelling":
    case "thread.run.cancelled":
    case "thread.run.expired":
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
      break;
    case "thread.run.step.created":
    case "thread.run.step.in_progress":
    case "thread.run.step.delta":
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
      break;
    case "thread.message.created":
    case "thread.message.in_progress":
    case "thread.message.delta":
    case "thread.message.completed":
    case "thread.message.incomplete":
      __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
      break;
    case "error":
      throw new Error("Encountered an error event in event processing - errors should be processed earlier");
  }
}, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
  if (this.ended) {
    throw new OpenAIError(`stream has ended, this shouldn't happen`);
  }
  if (!__classPrivateFieldGet5(this, _AssistantStream_finalRun, "f"))
    throw Error("Final run has not been received");
  return __classPrivateFieldGet5(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
  const [accumulatedMessage, newContent] = __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
  __classPrivateFieldSet4(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
  __classPrivateFieldGet5(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
  for (const content of newContent) {
    const snapshotContent = accumulatedMessage.content[content.index];
    if ((snapshotContent == null ? void 0 : snapshotContent.type) == "text") {
      this._emit("textCreated", snapshotContent.text);
    }
  }
  switch (event.event) {
    case "thread.message.created":
      this._emit("messageCreated", event.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      this._emit("messageDelta", event.data.delta, accumulatedMessage);
      if (event.data.delta.content) {
        for (const content of event.data.delta.content) {
          if (content.type == "text" && content.text) {
            let textDelta = content.text;
            let snapshot = accumulatedMessage.content[content.index];
            if (snapshot && snapshot.type == "text") {
              this._emit("textDelta", textDelta, snapshot.text);
            } else {
              throw Error("The snapshot associated with this text delta is not text or missing");
            }
          }
          if (content.index != __classPrivateFieldGet5(this, _AssistantStream_currentContentIndex, "f")) {
            if (__classPrivateFieldGet5(this, _AssistantStream_currentContent, "f")) {
              switch (__classPrivateFieldGet5(this, _AssistantStream_currentContent, "f").type) {
                case "text":
                  this._emit("textDone", __classPrivateFieldGet5(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", __classPrivateFieldGet5(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
            __classPrivateFieldSet4(this, _AssistantStream_currentContentIndex, content.index, "f");
          }
          __classPrivateFieldSet4(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
        }
      }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (__classPrivateFieldGet5(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
        const currentContent = event.data.content[__classPrivateFieldGet5(this, _AssistantStream_currentContentIndex, "f")];
        if (currentContent) {
          switch (currentContent.type) {
            case "image_file":
              this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
              break;
            case "text":
              this._emit("textDone", currentContent.text, __classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f"));
              break;
          }
        }
      }
      if (__classPrivateFieldGet5(this, _AssistantStream_messageSnapshot, "f")) {
        this._emit("messageDone", event.data);
      }
      __classPrivateFieldSet4(this, _AssistantStream_messageSnapshot, void 0, "f");
  }
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
  const accumulatedRunStep = __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
  __classPrivateFieldSet4(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
  switch (event.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", event.data);
      break;
    case "thread.run.step.delta":
      const delta = event.data.delta;
      if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
        for (const toolCall of delta.step_details.tool_calls) {
          if (toolCall.index == __classPrivateFieldGet5(this, _AssistantStream_currentToolCallIndex, "f")) {
            this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
          } else {
            if (__classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"));
            }
            __classPrivateFieldSet4(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
            __classPrivateFieldSet4(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
            if (__classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"))
              this._emit("toolCallCreated", __classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"));
          }
        }
      }
      this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldSet4(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
      const details = event.data.step_details;
      if (details.type == "tool_calls") {
        if (__classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet4(this, _AssistantStream_currentToolCall, void 0, "f");
        }
      }
      this._emit("runStepDone", event.data, accumulatedRunStep);
      break;
    case "thread.run.step.in_progress":
      break;
  }
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
  __classPrivateFieldGet5(this, _AssistantStream_events, "f").push(event);
  this._emit("event", event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
  switch (event.event) {
    case "thread.run.step.created":
      __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      return event.data;
    case "thread.run.step.delta":
      let snapshot = __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      if (!snapshot) {
        throw Error("Received a RunStepDelta before creation of a snapshot");
      }
      let data = event.data;
      if (data.delta) {
        const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);
        __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
      }
      return __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      break;
  }
  if (__classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
    return __classPrivateFieldGet5(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
  throw new Error("No snapshot available");
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
  let newContent = [];
  switch (event.event) {
    case "thread.message.created":
      return [event.data, newContent];
    case "thread.message.delta":
      if (!snapshot) {
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      }
      let data = event.data;
      if (data.delta.content) {
        for (const contentElement of data.delta.content) {
          if (contentElement.index in snapshot.content) {
            let currentContent = snapshot.content[contentElement.index];
            snapshot.content[contentElement.index] = __classPrivateFieldGet5(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
          } else {
            snapshot.content[contentElement.index] = contentElement;
            newContent.push(contentElement);
          }
        }
      }
      return [snapshot, newContent];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (snapshot) {
        return [snapshot, newContent];
      } else {
        throw Error("Received thread message event with no existing snapshot");
      }
  }
  throw Error("Tried to accumulate a non-message event");
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
  return AssistantStream.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
  __classPrivateFieldSet4(this, _AssistantStream_currentRunSnapshot, event.data, "f");
  switch (event.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
      __classPrivateFieldSet4(this, _AssistantStream_finalRun, event.data, "f");
      if (__classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f")) {
        this._emit("toolCallDone", __classPrivateFieldGet5(this, _AssistantStream_currentToolCall, "f"));
        __classPrivateFieldSet4(this, _AssistantStream_currentToolCall, void 0, "f");
      }
      break;
    case "thread.run.cancelling":
      break;
  }
};

// node_modules/openai/resources/beta/threads/messages.mjs
var Messages = class extends APIResource {
  /**
   * Create a message.
   */
  create(threadId, body, options) {
    return this._client.post(`/threads/${threadId}/messages`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieve a message.
   */
  retrieve(threadId, messageId, options) {
    return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a message.
   */
  update(threadId, messageId, body, options) {
    return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Deletes a message.
   */
  del(threadId, messageId, options) {
    return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};
var MessagesPage = class extends CursorPage {
};
Messages.MessagesPage = MessagesPage;

// node_modules/openai/resources/beta/threads/runs/steps.mjs
var Steps = class extends APIResource {
  retrieve(threadId, runId, stepId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.retrieve(threadId, runId, stepId, {}, query);
    }
    return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, runId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, runId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};
var RunStepsPage = class extends CursorPage {
};
Steps.RunStepsPage = RunStepsPage;

// node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs = class extends APIResource {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadId, params, options) {
    var _a2;
    const { include, ...body } = params;
    return this._client.post(`/threads/${threadId}/runs`, {
      query: { include },
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
      stream: (_a2 = params.stream) != null ? _a2 : false
    });
  }
  /**
   * Retrieves a run.
   */
  retrieve(threadId, runId, options) {
    return this._client.get(`/threads/${threadId}/runs/${runId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a run.
   */
  update(threadId, runId, body, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   */
  cancel(threadId, runId, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(threadId, body, options) {
    const run = await this.create(threadId, body, options);
    return await this.poll(threadId, run.id, options);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(threadId, runId, options) {
    const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
    if (options == null ? void 0 : options.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const { data: run, response } = await this.retrieve(threadId, runId, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, ...headers }
      }).withResponse();
      switch (run.status) {
        case "queued":
        case "in_progress":
        case "cancelling":
          let sleepInterval = 5e3;
          if (options == null ? void 0 : options.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return run;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  submitToolOutputs(threadId, runId, body, options) {
    var _a2;
    return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
      stream: (_a2 = body.stream) != null ? _a2 : false
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(threadId, runId, body, options) {
    const run = await this.submitToolOutputs(threadId, runId, body, options);
    return await this.poll(threadId, run.id, options);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(threadId, runId, body, options) {
    return AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);
  }
};
var RunsPage = class extends CursorPage {
};
Runs.RunsPage = RunsPage;
Runs.Steps = Steps;
Runs.RunStepsPage = RunStepsPage;

// node_modules/openai/resources/beta/threads/threads.mjs
var Threads = class extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs(this._client);
    this.messages = new Messages(this._client);
  }
  create(body = {}, options) {
    if (isRequestOptions(body)) {
      return this.create({}, body);
    }
    return this._client.post("/threads", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a thread.
   */
  retrieve(threadId, options) {
    return this._client.get(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a thread.
   */
  update(threadId, body, options) {
    return this._client.post(`/threads/${threadId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete a thread.
   */
  del(threadId, options) {
    return this._client.delete(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  createAndRun(body, options) {
    var _a2;
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
      stream: (_a2 = body.stream) != null ? _a2 : false
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(body, options) {
    const run = await this.createAndRun(body, options);
    return await this.runs.poll(run.thread_id, run.id, options);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(body, options) {
    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
  }
};
Threads.Runs = Runs;
Threads.RunsPage = RunsPage;
Threads.Messages = Messages;
Threads.MessagesPage = MessagesPage;

// node_modules/openai/lib/Util.mjs
var allSettledWithThrow = async (promises) => {
  const results = await Promise.allSettled(promises);
  const rejected = results.filter((result) => result.status === "rejected");
  if (rejected.length) {
    for (const result of rejected) {
      console.error(result.reason);
    }
    throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
  }
  const values = [];
  for (const result of results) {
    if (result.status === "fulfilled") {
      values.push(result.value);
    }
  }
  return values;
};

// node_modules/openai/resources/beta/vector-stores/files.mjs
var Files = class extends APIResource {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/files`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(vectorStoreId, fileId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(vectorStoreId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(vectorStoreId, {}, query);
    }
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  del(vectorStoreId, fileId, options) {
    return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const file = await this.create(vectorStoreId, body, options);
    return await this.poll(vectorStoreId, file.id, options);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(vectorStoreId, fileId, options) {
    const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
    if (options == null ? void 0 : options.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const fileResponse = await this.retrieve(vectorStoreId, fileId, {
        ...options,
        headers
      }).withResponse();
      const file = fileResponse.data;
      switch (file.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options == null ? void 0 : options.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "failed":
        case "completed":
          return file;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(vectorStoreId, file, options) {
    const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
    return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(vectorStoreId, file, options) {
    const fileInfo = await this.upload(vectorStoreId, file, options);
    return await this.poll(vectorStoreId, fileInfo.id, options);
  }
};
var VectorStoreFilesPage = class extends CursorPage {
};
Files.VectorStoreFilesPage = VectorStoreFilesPage;

// node_modules/openai/resources/beta/vector-stores/file-batches.mjs
var FileBatches = class extends APIResource {
  /**
   * Create a vector store file batch.
   */
  create(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(vectorStoreId, batchId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(vectorStoreId, batchId, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const batch = await this.create(vectorStoreId, body);
    return await this.poll(vectorStoreId, batch.id, options);
  }
  listFiles(vectorStoreId, batchId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listFiles(vectorStoreId, batchId, {}, query);
    }
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, VectorStoreFilesPage, { query, ...options, headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers } });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(vectorStoreId, batchId, options) {
    const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
    if (options == null ? void 0 : options.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {
        ...options,
        headers
      }).withResponse();
      switch (batch.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options == null ? void 0 : options.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return batch;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
    var _a2;
    if (files == null || files.length == 0) {
      throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
    }
    const configuredConcurrency = (_a2 = options == null ? void 0 : options.maxConcurrency) != null ? _a2 : 5;
    const concurrencyLimit = Math.min(configuredConcurrency, files.length);
    const client = this._client;
    const fileIterator = files.values();
    const allFileIds = [...fileIds];
    async function processFiles(iterator) {
      for (let item of iterator) {
        const fileObj = await client.files.create({ file: item, purpose: "assistants" }, options);
        allFileIds.push(fileObj.id);
      }
    }
    const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
    await allSettledWithThrow(workers);
    return await this.createAndPoll(vectorStoreId, {
      file_ids: allFileIds
    });
  }
};

// node_modules/openai/resources/beta/vector-stores/vector-stores.mjs
var VectorStores = class extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files(this._client);
    this.fileBatches = new FileBatches(this._client);
  }
  /**
   * Create a vector store.
   */
  create(body, options) {
    return this._client.post("/vector_stores", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(vectorStoreId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a vector store.
   */
  update(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/vector_stores", VectorStoresPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete a vector store.
   */
  del(vectorStoreId, options) {
    return this._client.delete(`/vector_stores/${vectorStoreId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
    });
  }
};
var VectorStoresPage = class extends CursorPage {
};
VectorStores.VectorStoresPage = VectorStoresPage;
VectorStores.Files = Files;
VectorStores.VectorStoreFilesPage = VectorStoreFilesPage;
VectorStores.FileBatches = FileBatches;

// node_modules/openai/resources/beta/beta.mjs
var Beta = class extends APIResource {
  constructor() {
    super(...arguments);
    this.realtime = new Realtime(this._client);
    this.vectorStores = new VectorStores(this._client);
    this.chat = new Chat2(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads(this._client);
  }
};
Beta.Realtime = Realtime;
Beta.VectorStores = VectorStores;
Beta.VectorStoresPage = VectorStoresPage;
Beta.Assistants = Assistants;
Beta.AssistantsPage = AssistantsPage;
Beta.Threads = Threads;

// node_modules/openai/resources/completions.mjs
var Completions3 = class extends APIResource {
  create(body, options) {
    var _a2;
    return this._client.post("/completions", { body, ...options, stream: (_a2 = body.stream) != null ? _a2 : false });
  }
};

// node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(body, options) {
    return this._client.post("/embeddings", { body, ...options });
  }
};

// node_modules/openai/resources/files.mjs
var Files2 = class extends APIResource {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 100 GB.
   *
   * The Assistants API supports files up to 2 million tokens and of specific file
   * types. See the
   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
   * details.
   *
   * The Fine-tuning API only supports `.jsonl` files. The input also has certain
   * required formats for fine-tuning
   * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
   * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   * models.
   *
   * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
   * has a specific required
   * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(body, options) {
    return this._client.post("/files", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileId, options) {
    return this._client.get(`/files/${fileId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/files", FileObjectsPage, { query, ...options });
  }
  /**
   * Delete a file.
   */
  del(fileId, options) {
    return this._client.delete(`/files/${fileId}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, {
      ...options,
      headers: { Accept: "application/binary", ...options == null ? void 0 : options.headers },
      __binaryResponse: true
    });
  }
  /**
   * Returns the contents of the specified file.
   *
   * @deprecated The `.content()` method should be used instead
   */
  retrieveContent(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, options);
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep2(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};
var FileObjectsPage = class extends CursorPage {
};
Files2.FileObjectsPage = FileObjectsPage;

// node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs
var Checkpoints = class extends APIResource {
  list(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, { query, ...options });
  }
};
var FineTuningJobCheckpointsPage = class extends CursorPage {
};
Checkpoints.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;

// node_modules/openai/resources/fine-tuning/jobs/jobs.mjs
var Jobs = class extends APIResource {
  constructor() {
    super(...arguments);
    this.checkpoints = new Checkpoints(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  retrieve(fineTuningJobId, options) {
    return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuningJobId, options) {
    return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
  }
  listEvents(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
      query,
      ...options
    });
  }
};
var FineTuningJobsPage = class extends CursorPage {
};
var FineTuningJobEventsPage = class extends CursorPage {
};
Jobs.FineTuningJobsPage = FineTuningJobsPage;
Jobs.FineTuningJobEventsPage = FineTuningJobEventsPage;
Jobs.Checkpoints = Checkpoints;
Jobs.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource {
  constructor() {
    super(...arguments);
    this.jobs = new Jobs(this._client);
  }
};
FineTuning.Jobs = Jobs;
FineTuning.FineTuningJobsPage = FineTuningJobsPage;
FineTuning.FineTuningJobEventsPage = FineTuningJobEventsPage;

// node_modules/openai/resources/images.mjs
var Images = class extends APIResource {
  /**
   * Creates a variation of a given image.
   */
  createVariation(body, options) {
    return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an edited or extended image given an original image and a prompt.
   */
  edit(body, options) {
    return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an image given a prompt.
   */
  generate(body, options) {
    return this._client.post("/images/generations", { body, ...options });
  }
};

// node_modules/openai/resources/models.mjs
var Models = class extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options) {
    return this._client.get(`/models/${model}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this._client.getAPIList("/models", ModelsPage, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(model, options) {
    return this._client.delete(`/models/${model}`, options);
  }
};
var ModelsPage = class extends Page {
};
Models.ModelsPage = ModelsPage;

// node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
};

// node_modules/openai/resources/uploads/parts.mjs
var Parts = class extends APIResource {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(uploadId, body, options) {
    return this._client.post(`/uploads/${uploadId}/parts`, multipartFormRequestOptions({ body, ...options }));
  }
};

// node_modules/openai/resources/uploads/uploads.mjs
var Uploads = class extends APIResource {
  constructor() {
    super(...arguments);
    this.parts = new Parts(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose`s, the correct `mime_type` must be specified. Please refer
   * to documentation for the supported MIME types for your use case:
   *
   * - [Assistants](https://platform.openai.com/docs/assistants/tools/file-search#supported-files)
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(body, options) {
    return this._client.post("/uploads", { body, ...options });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(uploadId, options) {
    return this._client.post(`/uploads/${uploadId}/cancel`, options);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(uploadId, body, options) {
    return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });
  }
};
Uploads.Parts = Parts;

// node_modules/openai/index.mjs
var _a;
var OpenAI = class extends APIClient {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = ((_a2) => (_a2 = readEnv("OPENAI_ORG_ID")) != null ? _a2 : null)(), project = ((_b) => (_b = readEnv("OPENAI_PROJECT_ID")) != null ? _b : null)(), ...opts } = {}) {
    var _a3;
    if (apiKey === void 0) {
      throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
    }
    const options = {
      apiKey,
      organization,
      project,
      ...opts,
      baseURL: baseURL || `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    super({
      baseURL: options.baseURL,
      timeout: (_a3 = options.timeout) != null ? _a3 : 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.completions = new Completions3(this);
    this.chat = new Chat(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files2(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.beta = new Beta(this);
    this.batches = new Batches(this);
    this.uploads = new Uploads(this);
    this._options = options;
    this.apiKey = apiKey;
    this.organization = organization;
    this.project = project;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      "OpenAI-Project": this.project,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
  stringifyQuery(query) {
    return stringify(query, { arrayFormat: "brackets" });
  }
};
_a = OpenAI;
OpenAI.OpenAI = _a;
OpenAI.DEFAULT_TIMEOUT = 6e5;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
OpenAI.toFile = toFile;
OpenAI.fileFromPath = fileFromPath;
OpenAI.Completions = Completions3;
OpenAI.Chat = Chat;
OpenAI.Embeddings = Embeddings;
OpenAI.Files = Files2;
OpenAI.FileObjectsPage = FileObjectsPage;
OpenAI.Images = Images;
OpenAI.Audio = Audio;
OpenAI.Moderations = Moderations;
OpenAI.Models = Models;
OpenAI.ModelsPage = ModelsPage;
OpenAI.FineTuning = FineTuning;
OpenAI.Beta = Beta;
OpenAI.Batches = Batches;
OpenAI.BatchesPage = BatchesPage;
OpenAI.Uploads = Uploads;
var openai_default = OpenAI;

// services/OpenAIService.ts
var import_obsidian2 = require("obsidian");
var OpenAIService = class {
  constructor(settings, errorHandler) {
    this.rateLimitDelay = 20;
    // ms between requests
    this.lastRequestTime = 0;
    this.settings = settings;
    this.errorHandler = errorHandler;
    if (!settings.apiKey) {
      console.warn("OpenAI API key is missing. OpenAIService will not be initialized.");
      this.client = null;
      return;
    }
    this.client = new openai_default({
      apiKey: settings.apiKey,
      dangerouslyAllowBrowser: true
      // Enable browser-like environment usage
    });
  }
  /**
   * Check if the service is initialized
   */
  isInitialized() {
    return this.client !== null;
  }
  /**
   * Creates embeddings for the given text chunks with rate limiting and retries
   */
  async createEmbeddings(chunks) {
    if (!this.client) {
      console.warn("OpenAIService is not initialized. Cannot create embeddings.");
      new import_obsidian2.Notice("OpenAI API key is missing. Please set it in the plugin settings.");
      return chunks.map(() => ({
        data: [],
        usage: { prompt_tokens: 0, total_tokens: 0 },
        model: "text-embedding-ada-002"
        // Default model to maintain output consistency
      }));
    }
    const embeddings = [];
    for (let i = 0; i < chunks.length; i++) {
      try {
        const timeSinceLastRequest = Date.now() - this.lastRequestTime;
        if (timeSinceLastRequest < this.rateLimitDelay) {
          await new Promise(
            (resolve) => setTimeout(resolve, this.rateLimitDelay - timeSinceLastRequest)
          );
        }
        const response = await this.client.embeddings.create({
          model: "text-embedding-ada-002",
          // Use the correct model
          input: chunks[i],
          encoding_format: "float"
        });
        this.lastRequestTime = Date.now();
        embeddings.push({
          data: [
            {
              embedding: response.data[0].embedding,
              index: i
            }
          ],
          usage: {
            prompt_tokens: response.usage.prompt_tokens,
            total_tokens: response.usage.total_tokens
          },
          model: response.model
        });
      } catch (error) {
        this.handleEmbeddingError(error, chunks[i]);
        embeddings.push({
          data: [],
          usage: { prompt_tokens: 0, total_tokens: 0 },
          model: "text-embedding-ada-002"
        });
      }
    }
    return embeddings;
  }
  /**
   * Handles various types of OpenAI API errors
   */
  handleEmbeddingError(error, chunk) {
    let errorMessage;
    if (error instanceof openai_default.APIError) {
      switch (error.status) {
        case 429:
          errorMessage = "Rate limit exceeded. Please try again later.";
          break;
        case 401:
          errorMessage = "Invalid API key. Please check your settings.";
          break;
        case 413:
          errorMessage = "Text chunk too large for embedding.";
          break;
        default:
          errorMessage = `OpenAI API error: ${error.message}`;
      }
    } else {
      errorMessage = `Unexpected error: ${error.message}`;
    }
    this.errorHandler.handleError(error, {
      context: "OpenAIService.createEmbeddings",
      metadata: {
        chunkPreview: chunk.substring(0, 100) + "..."
        // First 100 chars for context
      }
    });
    new import_obsidian2.Notice(`Error creating embedding: ${errorMessage}`);
  }
  /**
   * Updates service settings
   */
  updateSettings(settings) {
    this.settings = settings;
    if (!settings.apiKey) {
      console.warn("OpenAI API key is missing. OpenAIService will not be initialized.");
      this.client = null;
      return;
    }
    this.client = new openai_default({
      apiKey: settings.apiKey,
      dangerouslyAllowBrowser: true
      // Ensure this remains enabled
    });
  }
  /**
   * Updates rate limiting parameters
   */
  updateRateLimit(delayMs) {
    this.rateLimitDelay = delayMs;
  }
};

// services/QueueService.ts
var import_obsidian4 = require("obsidian");

// services/MetadataExtractor.ts
var import_obsidian3 = require("obsidian");
var MetadataExtractor = class {
  /**
   * Extracts all metadata from an Obsidian file
   */
  async extractMetadata(file, content) {
    const fileContent = content || await file.vault.read(file);
    const frontMatter = this.extractFrontMatter(fileContent);
    const metadata = {
      obsidianId: file.path,
      path: file.path,
      lastModified: file.stat.mtime,
      created: file.stat.ctime,
      size: file.stat.size,
      frontMatter,
      tags: this.extractTags(fileContent, frontMatter),
      links: this.extractLinks(fileContent),
      customMetadata: {}
    };
    const aliases = this.extractAliases(frontMatter);
    if (aliases.length > 0) {
      metadata.customMetadata.aliases = aliases;
    }
    const loc = this.extractSourceLocation(frontMatter);
    if (loc) {
      metadata.loc = loc;
    }
    if (frontMatter == null ? void 0 : frontMatter.source) {
      metadata.source = frontMatter.source;
    }
    if (frontMatter == null ? void 0 : frontMatter.file_id) {
      metadata.file_id = frontMatter.file_id;
    }
    if (frontMatter == null ? void 0 : frontMatter.blobType) {
      metadata.blobType = frontMatter.blobType;
    }
    return metadata;
  }
  /**
   * Extracts metadata from the provided content and merges it with the given base metadata and front matter.
   * This new method is used by the TextSplitter to enhance metadata based on parsed front matter.
   */
  async extractMetadataFromContent(content, baseMetadata, frontMatter) {
    const merged = { ...baseMetadata };
    if (frontMatter) {
      merged.frontMatter = frontMatter;
      if (frontMatter.tags) {
        merged.tags = Array.isArray(frontMatter.tags) ? frontMatter.tags : [frontMatter.tags];
      }
      if (frontMatter.aliases) {
        merged.customMetadata = merged.customMetadata || {};
        merged.customMetadata.aliases = Array.isArray(frontMatter.aliases) ? frontMatter.aliases : [frontMatter.aliases];
      }
    }
    return merged;
  }
  /**
   * Extracts YAML front matter from document content
   */
  extractFrontMatter(content) {
    try {
      const frontMatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if (!frontMatterMatch)
        return void 0;
      const yaml = frontMatterMatch[1];
      return (0, import_obsidian3.parseYaml)(yaml);
    } catch (error) {
      console.error("Error parsing frontmatter:", error);
      throw new Error(`${"YAML_PARSE_ERROR" /* YAML_PARSE_ERROR */}: ${error.message}`);
    }
  }
  /**
   * Extracts internal links from document content.
   */
  extractLinks(content) {
    const linkRegex = /\[\[(.*?)(?:\|.*?)?\]\]/g;
    const links = /* @__PURE__ */ new Set();
    let match;
    while ((match = linkRegex.exec(content)) !== null) {
      const link = match[1].split("|")[0];
      const cleanLink = this.cleanLink(link);
      if (cleanLink) {
        links.add(cleanLink);
      }
    }
    return Array.from(links);
  }
  /**
   * Cleans and normalizes a link path.
   */
  cleanLink(link) {
    let cleanLink = link.split("#")[0];
    cleanLink = cleanLink.split("?")[0];
    cleanLink = cleanLink.trim();
    return cleanLink;
  }
  /**
   * Extracts tags from both content and front matter.
   */
  extractTags(content, frontMatter) {
    const tags = /* @__PURE__ */ new Set();
    const tagRegex = /#([A-Za-z0-9/_-]+)/g;
    let match;
    while ((match = tagRegex.exec(content)) !== null) {
      tags.add(match[1]);
    }
    if (frontMatter == null ? void 0 : frontMatter.tags) {
      const frontMatterTags = Array.isArray(frontMatter.tags) ? frontMatter.tags : [frontMatter.tags];
      frontMatterTags.forEach((tag) => {
        if (typeof tag === "string") {
          const cleanTag = tag.startsWith("#") ? tag.slice(1) : tag;
          tags.add(cleanTag);
        }
      });
    }
    return Array.from(tags);
  }
  /**
   * Extracts aliases from front matter.
   */
  extractAliases(frontMatter) {
    if (!(frontMatter == null ? void 0 : frontMatter.aliases))
      return [];
    if (Array.isArray(frontMatter.aliases)) {
      return frontMatter.aliases.filter((alias) => typeof alias === "string");
    }
    if (typeof frontMatter.aliases === "string") {
      return [frontMatter.aliases];
    }
    return [];
  }
  /**
   * Extracts source location information from front matter.
   */
  extractSourceLocation(frontMatter) {
    var _a2, _b, _c, _d;
    if (!((_b = (_a2 = frontMatter == null ? void 0 : frontMatter.loc) == null ? void 0 : _a2.lines) == null ? void 0 : _b.from) || !((_d = (_c = frontMatter == null ? void 0 : frontMatter.loc) == null ? void 0 : _c.lines) == null ? void 0 : _d.to)) {
      return void 0;
    }
    return {
      lines: {
        from: Number(frontMatter.loc.lines.from),
        to: Number(frontMatter.loc.lines.to)
      }
    };
  }
};

// utils/TextSplitter.ts
var TextSplitter = class {
  constructor(settings, metadataExtractor) {
    // Regex patterns for splitting
    this.SENTENCE_BOUNDARY = /[.!?]\s+/;
    this.PARAGRAPH_BOUNDARY = /\n\s*\n/;
    this.YAML_FRONT_MATTER = /^---\n([\s\S]*?)\n---/;
    this.settings = settings || { ...DEFAULT_CHUNKING_OPTIONS };
    this.validateSettings(this.settings);
    this.metadataExtractor = metadataExtractor || new MetadataExtractor();
  }
  /** Returns the current chunking settings. */
  getSettings() {
    return this.settings;
  }
  validateSettings(settings) {
    if (settings.chunkSize <= 0) {
      throw new Error("Chunk size must be greater than 0.");
    }
    if (settings.chunkOverlap >= settings.chunkSize) {
      throw new Error("Chunk overlap must be less than chunk size.");
    }
    if (settings.minChunkSize > settings.chunkSize) {
      throw new Error("Minimum chunk size must not exceed chunk size.");
    }
  }
  /**
   * Splits a document into chunks while enhancing metadata.
   * Extracts YAML front matter if present, and then uses the MetadataExtractor
   * to merge additional metadata (e.g., tags, aliases, links) into the base metadata.
   *
   * @param content The full text content of the document.
   * @param metadata Base metadata for the document.
   * @param abortSignal Optional AbortSignal to cancel the operation.
   * @returns An array of DocumentChunk.
   */
  async splitDocument(content, metadata, abortSignal) {
    const performanceMetrics = {};
    const overallStart = performance.now();
    try {
      console.log("Starting document split", { contentLength: content.length, settings: this.settings });
      if (abortSignal == null ? void 0 : abortSignal.aborted) {
        throw new Error("Document splitting aborted before start");
      }
      if (!(content == null ? void 0 : content.trim())) {
        console.log("Empty content received");
        return [];
      }
      let frontMatter = null;
      const frontMatterMatch = this.YAML_FRONT_MATTER.exec(content);
      if (frontMatterMatch) {
        try {
          frontMatter = this.parseFrontMatter(frontMatterMatch[1]);
          const enhancedMetadata = await this.metadataExtractor.extractMetadataFromContent(
            content,
            metadata,
            frontMatter
          );
          metadata = { ...metadata, ...enhancedMetadata };
          console.log("Front matter extracted and metadata enhanced", { frontMatter });
        } catch (error) {
          console.warn("Failed to parse front matter", error);
        }
      }
      const trimmedContent = content.trim();
      if (abortSignal == null ? void 0 : abortSignal.aborted) {
        throw new Error("Document splitting aborted after front matter processing");
      }
      if (trimmedContent.length <= Math.max(this.settings.minChunkSize, this.settings.chunkSize)) {
        if (trimmedContent.length === 0) {
          console.log("No content after trimming, returning empty array");
          return [];
        }
        console.log("Content is smaller than chunk size, creating single chunk", {
          contentLength: trimmedContent.length,
          chunkSize: this.settings.chunkSize,
          minChunkSize: this.settings.minChunkSize
        });
        const singleChunk = this.createChunk(trimmedContent, 0, metadata);
        performanceMetrics.singleChunkTime = performance.now() - overallStart;
        console.log("Created single chunk", { chunkSize: singleChunk.content.length, preview: singleChunk.content.substring(0, 100) });
        console.log(`Document split completed in ${performance.now() - overallStart} ms`, performanceMetrics);
        return [singleChunk];
      }
      const paragraphs = content.split(this.PARAGRAPH_BOUNDARY).map((p) => p.trim()).filter((p) => p.length > 0);
      console.log("Split into paragraphs", { paragraphCount: paragraphs.length, paragraphs: paragraphs.map((p) => p.substring(0, 100)) });
      if (abortSignal == null ? void 0 : abortSignal.aborted) {
        throw new Error("Document splitting aborted after paragraph split");
      }
      let chunks = [];
      let currentChunk = "";
      let chunkIndex = 0;
      for (const paragraph of paragraphs) {
        if (abortSignal == null ? void 0 : abortSignal.aborted) {
          chunks = [];
          throw new Error("Document splitting aborted during processing");
        }
        if (paragraph.length >= this.settings.chunkSize) {
          if (currentChunk) {
            chunks.push(this.createChunk(currentChunk, chunkIndex++, metadata));
            currentChunk = "";
          }
          const sentences = paragraph.split(this.SENTENCE_BOUNDARY);
          let sentenceChunk = "";
          for (const sentence of sentences) {
            if (abortSignal == null ? void 0 : abortSignal.aborted) {
              chunks = [];
              throw new Error("Document splitting aborted during sentence processing");
            }
            const trimmedSentence = sentence.trim();
            if (!trimmedSentence)
              continue;
            if ((sentenceChunk + " " + trimmedSentence).length > this.settings.chunkSize) {
              if (sentenceChunk) {
                chunks.push(this.createChunk(sentenceChunk, chunkIndex++, metadata));
                sentenceChunk = trimmedSentence;
              } else {
                let position = 0;
                while (position < trimmedSentence.length) {
                  const chunkText = trimmedSentence.slice(
                    position,
                    Math.min(position + this.settings.chunkSize, trimmedSentence.length)
                  );
                  chunks.push(this.createChunk(chunkText, chunkIndex++, metadata));
                  position += this.settings.chunkSize;
                }
                sentenceChunk = "";
              }
            } else {
              sentenceChunk += (sentenceChunk ? " " : "") + trimmedSentence;
            }
          }
          if (sentenceChunk) {
            chunks.push(this.createChunk(sentenceChunk, chunkIndex++, metadata));
          }
        } else {
          const potentialChunkSize = currentChunk ? currentChunk.length + 2 + paragraph.length : paragraph.length;
          if (potentialChunkSize <= this.settings.chunkSize) {
            currentChunk += (currentChunk ? "\n\n" : "") + paragraph;
          } else {
            if (currentChunk) {
              chunks.push(this.createChunk(currentChunk, chunkIndex++, metadata));
            }
            currentChunk = paragraph;
          }
        }
      }
      if (currentChunk) {
        chunks.push(this.createChunk(currentChunk, chunkIndex++, metadata));
      }
      if (chunks.length === 0 && trimmedContent.length > 0) {
        console.log("Creating fallback chunk for content", { contentLength: trimmedContent.length });
        chunks.push(this.createChunk(trimmedContent, 0, metadata));
      }
      if (this.settings.chunkOverlap > 0 && chunks.length > 1) {
        chunks = this.applyOverlap(chunks);
      }
      performanceMetrics.totalSplittingTime = performance.now() - overallStart;
      console.log("Finished creating chunks", {
        chunkCount: chunks.length,
        chunkSizes: chunks.map((c) => c.content.length),
        chunkPreviews: chunks.map((c) => ({
          index: c.chunkIndex,
          size: c.content.length,
          preview: c.content.substring(0, 100)
        })),
        performanceMetrics
      });
      return chunks;
    } catch (error) {
      console.error("Error in splitDocument", error);
      throw {
        type: "CHUNKING_ERROR" /* CHUNKING_ERROR */,
        message: "Error occurred during document chunking",
        details: error.message
      };
    }
  }
  createChunk(content, index2, metadata) {
    const trimmedContent = content.trim();
    if (trimmedContent.length < this.settings.minChunkSize) {
      console.warn("Chunk smaller than minChunkSize", {
        size: trimmedContent.length,
        minSize: this.settings.minChunkSize
      });
    }
    return {
      content: trimmedContent,
      chunkIndex: index2,
      metadata: { ...metadata }
    };
  }
  applyOverlap(chunks) {
    if (chunks.length <= 1)
      return chunks;
    const chunksWithOverlap = [...chunks];
    for (let i = chunksWithOverlap.length - 1; i > 0; i--) {
      const currentChunk = { ...chunksWithOverlap[i] };
      const previousChunk = chunksWithOverlap[i - 1];
      const overlapText = previousChunk.content.slice(-this.settings.chunkOverlap);
      if (overlapText) {
        chunksWithOverlap[i] = {
          ...currentChunk,
          content: overlapText + "\n\n" + currentChunk.content
        };
      }
    }
    return chunksWithOverlap;
  }
  parseFrontMatter(frontMatter) {
    try {
      const result = {};
      const lines = frontMatter.split("\n");
      for (const line of lines) {
        const trimmedLine = line.trim();
        if (!trimmedLine || trimmedLine.startsWith("#"))
          continue;
        const separatorIndex = line.indexOf(":");
        if (separatorIndex === -1)
          continue;
        const key = line.slice(0, separatorIndex).trim();
        let value = line.slice(separatorIndex + 1).trim();
        value = value.replace(/^["'](.*)["']$/, "$1");
        if (value.startsWith("- ")) {
          result[key] = value.split("\n").map((item) => item.replace("- ", "").trim()).filter(Boolean);
        } else {
          result[key] = value;
        }
      }
      return result;
    } catch (error) {
      console.warn("Failed to parse front matter", error);
      return {};
    }
  }
};

// services/EventEmitter.ts
var EventEmitter = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
  }
  /**
   * Emit an event with associated data.
   * Listeners registered for this event will be called with the data.
   */
  emit(event, data) {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      for (const callback of callbacks) {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in listener for event "${event}":`, error);
        }
      }
    }
  }
  /**
   * Register a callback to be invoked when the specified event is emitted.
   * Returns an unsubscribe function.
   */
  on(event, callback) {
    var _a2;
    if (!this.listeners.has(event)) {
      this.listeners.set(event, /* @__PURE__ */ new Set());
    }
    (_a2 = this.listeners.get(event)) == null ? void 0 : _a2.add(callback);
    return () => {
      var _a3;
      (_a3 = this.listeners.get(event)) == null ? void 0 : _a3.delete(callback);
    };
  }
};

// services/QueueService.ts
var QueueService = class {
  constructor(maxConcurrent, maxRetries, supabaseService, openAIService, errorHandler, notificationManager, vault, chunkSettings) {
    this.maxConcurrent = maxConcurrent;
    this.maxRetries = maxRetries;
    this.supabaseService = supabaseService;
    this.openAIService = openAIService;
    this.errorHandler = errorHandler;
    this.notificationManager = notificationManager;
    this.queue = [];
    this.processingQueue = [];
    this.isProcessing = false;
    this.isStopped = true;
    this.processingInterval = null;
    this.vault = vault;
    const validatedChunkSettings = chunkSettings || { ...DEFAULT_CHUNKING_OPTIONS };
    try {
      this.textSplitter = new TextSplitter(validatedChunkSettings);
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "QueueService.constructor",
        metadata: validatedChunkSettings
      });
      throw new Error("Failed to initialize TextSplitter with provided settings.");
    }
    this.eventEmitter = new EventEmitter();
  }
  start() {
    if (!this.isStopped)
      return;
    this.isStopped = false;
    this.processQueue();
    this.processingInterval = setInterval(() => {
      if (!this.isProcessing) {
        this.processQueue();
      }
    }, 1e3);
    this.eventEmitter.emit("queue-status", {
      queueSize: this.queue.length,
      pendingChanges: 0,
      processingCount: this.processingQueue.length,
      status: "processing"
    });
  }
  stop() {
    this.isStopped = true;
    if (this.processingInterval) {
      clearInterval(this.processingInterval);
      this.processingInterval = null;
    }
    this.eventEmitter.emit("queue-status", {
      queueSize: this.queue.length,
      pendingChanges: 0,
      processingCount: this.processingQueue.length,
      status: "paused"
    });
  }
  async addTask(task) {
    if (this.queue.length >= 1e3) {
      throw new Error("QUEUE_FULL" /* QUEUE_FULL */);
    }
    console.log("Adding task to queue:", { id: task.id, type: task.type, priority: task.priority });
    const existingTaskIndex = this.queue.findIndex((t) => t.id === task.id);
    const processingTaskIndex = this.processingQueue.findIndex((t) => t.id === task.id);
    if (task.type === "DELETE" /* DELETE */) {
      task.priority = 3;
      if (processingTaskIndex >= 0) {
        const processingTask = this.processingQueue[processingTaskIndex];
        if (processingTask.type !== "DELETE" /* DELETE */) {
          console.log(`Conflict in processing for ${task.id}. Marking existing task as CANCELLED.`);
          processingTask.status = "CANCELLED" /* CANCELLED */;
        }
      }
      if (existingTaskIndex >= 0) {
        const existingTask = this.queue[existingTaskIndex];
        if (existingTask.type === "DELETE" /* DELETE */) {
          console.log(`Duplicate DELETE task for ${task.id}. Ignoring.`);
          return;
        } else {
          console.log(`Replacing existing ${existingTask.type} task for ${task.id} with DELETE task.`);
          this.queue.splice(existingTaskIndex, 1);
        }
      }
      this.queue.unshift(task);
    } else {
      const hasDeleteTask = this.queue.some((t) => t.id === task.id && t.type === "DELETE" /* DELETE */);
      if (hasDeleteTask) {
        console.log(`Skipping ${task.type} for ${task.id} as DELETE is pending.`);
        return;
      }
      if (existingTaskIndex >= 0) {
        console.log(`Replacing existing task for ${task.id} with new ${task.type} task.`);
        this.queue[existingTaskIndex] = task;
      } else {
        if (task.priority >= 2) {
          this.queue.unshift(task);
        } else {
          this.queue.push(task);
        }
      }
    }
    this.eventEmitter.emit("queue-progress", {
      processed: 0,
      total: this.queue.length,
      currentTask: task.id
    });
    if (!this.isProcessing && !this.isStopped) {
      this.processQueue();
    }
  }
  async processQueue() {
    if (this.isProcessing || this.isStopped || this.queue.length === 0) {
      return;
    }
    this.isProcessing = true;
    try {
      this.queue.sort((a, b) => {
        if (b.priority !== a.priority)
          return b.priority - a.priority;
        if (a.type === "DELETE" /* DELETE */ && b.type !== "DELETE" /* DELETE */)
          return -1;
        if (b.type === "DELETE" /* DELETE */ && a.type !== "DELETE" /* DELETE */)
          return 1;
        return a.createdAt - b.createdAt;
      });
      const tasksByFile = /* @__PURE__ */ new Map();
      this.queue.forEach((task) => {
        if (!tasksByFile.has(task.id)) {
          tasksByFile.set(task.id, []);
        }
        tasksByFile.get(task.id).push(task);
      });
      let tasksToProcess = [];
      for (const [fileId, fileTasks] of tasksByFile.entries()) {
        if (fileTasks.length > 1) {
          console.log(`Detected ${fileTasks.length} tasks for ${fileId}, resolving collisions.`);
          const deleteTask = fileTasks.find((t) => t.type === "DELETE" /* DELETE */);
          if (deleteTask) {
            tasksToProcess.push(deleteTask);
            this.queue = this.queue.filter((t) => t.id !== fileId);
            console.log(`Keeping only DELETE task for ${fileId}`);
          } else {
            const mostRecentTask = fileTasks.reduce((latest, current) => current.updatedAt > latest.updatedAt ? current : latest, fileTasks[0]);
            tasksToProcess.push(mostRecentTask);
            this.queue = this.queue.filter((t) => t.id !== fileId || t === mostRecentTask);
            console.log(`Keeping most recent task for ${fileId}`);
          }
        }
      }
      for (const task of this.queue) {
        if (tasksToProcess.some((t) => t.id === task.id))
          continue;
        tasksToProcess.push(task);
        if (tasksToProcess.length + this.processingQueue.length >= this.maxConcurrent) {
          break;
        }
      }
      for (const task of tasksToProcess) {
        const index2 = this.queue.indexOf(task);
        if (index2 !== -1) {
          this.queue.splice(index2, 1);
        }
      }
      for (const task of tasksToProcess) {
        if (this.processingQueue.length >= this.maxConcurrent) {
          this.queue.unshift(task);
          continue;
        }
        this.processingQueue.push(task);
        this.processTask(task).catch((error) => {
          this.handleTaskError(task, error);
        });
      }
      this.eventEmitter.emit("queue-status", {
        queueSize: this.queue.length,
        pendingChanges: this.queue.length + this.processingQueue.length,
        processingCount: this.processingQueue.length,
        status: "processing"
      });
    } catch (error) {
      this.errorHandler.handleError(error, { context: "QueueService.processQueue" });
    } finally {
      this.isProcessing = false;
      if (this.queue.length > 0 && !this.isStopped) {
        setTimeout(() => this.processQueue(), 100);
      }
    }
  }
  async processTask(task) {
    console.log("Processing task:", { id: task.id, type: task.type, status: task.status });
    try {
      task.status = "PROCESSING" /* PROCESSING */;
      task.startedAt = Date.now();
      this.notifyProgress(task.id, 0, `Starting ${task.type.toLowerCase()}`);
      switch (task.type) {
        case "CREATE" /* CREATE */:
        case "UPDATE" /* UPDATE */:
          await this.processCreateUpdateTask(task);
          break;
        case "DELETE" /* DELETE */:
          await this.processDeleteTask(task);
          break;
        default:
          throw new Error(`Unsupported task type: ${task.type}`);
      }
      task.status = "COMPLETED" /* COMPLETED */;
      task.completedAt = Date.now();
      this.notifyProgress(task.id, 100, "Task completed");
      console.log("Task completed successfully:", task.id);
      this.eventEmitter.emit("queue-progress", {
        processed: 1,
        total: this.queue.length + 1,
        currentTask: task.id
      });
    } catch (error) {
      console.error("Error processing task:", { taskId: task.id, error });
      await this.handleTaskError(task, error);
    } finally {
      this.removeFromProcessingQueue(task);
    }
  }
  async processCreateUpdateTask(task) {
    if (!this.supabaseService || !this.openAIService) {
      throw new Error("Required services not initialized");
    }
    try {
      console.log("Reading file:", task.id);
      const file = this.vault.getAbstractFileByPath(task.id);
      if (!(file instanceof import_obsidian4.TFile)) {
        throw new Error(`File not found or not a TFile: ${task.id}`);
      }
      const timings = {
        start: Date.now(),
        readComplete: 0,
        chunkingComplete: 0,
        embeddingComplete: 0,
        saveComplete: 0
      };
      const content = await this.vault.read(file);
      timings.readComplete = Date.now();
      console.log("File content read:", {
        fileId: task.id,
        contentLength: content.length,
        readTime: timings.readComplete - timings.start
      });
      this.notifyProgress(task.id, 20, "Splitting content");
      const chunks = await this.textSplitter.splitDocument(content, task.metadata);
      timings.chunkingComplete = Date.now();
      if (!chunks || !Array.isArray(chunks) || chunks.length === 0) {
        console.log("No valid chunks created for file:", {
          fileId: task.id,
          contentLength: content.length,
          settings: this.textSplitter.getSettings()
        });
        if (this.supabaseService) {
          await this.supabaseService.updateFileVectorizationStatus(task.metadata);
        }
        return;
      }
      console.log("Content split into chunks:", {
        numberOfChunks: chunks.length,
        chunkSizes: chunks.map((c) => c.content.length),
        chunkingTime: timings.chunkingComplete - timings.readComplete
      });
      this.notifyProgress(task.id, 40, "Generating embeddings");
      for (let i = 0; i < chunks.length; i++) {
        const embedProgress = Math.floor(40 + i / chunks.length * 30);
        this.notifyProgress(task.id, embedProgress, `Generating embedding ${i + 1}/${chunks.length}`);
        const response = await this.openAIService.createEmbeddings([chunks[i].content]);
        if (response.length > 0 && response[0].data.length > 0) {
          chunks[i].embedding = response[0].data[0].embedding;
          chunks[i].vectorized_at = new Date().toISOString();
          console.log(`Generated embedding for chunk ${i + 1}/${chunks.length}`);
        } else {
          throw new Error(`Failed to generate embedding for chunk ${i + 1}`);
        }
      }
      timings.embeddingComplete = Date.now();
      const enhancedChunks = chunks.map((chunk) => ({
        ...chunk,
        metadata: {
          ...chunk.metadata,
          aliases: chunk.metadata.aliases || [],
          links: chunk.metadata.links || [],
          tags: chunk.metadata.tags || []
        }
      }));
      this.notifyProgress(task.id, 70, "Saving to database");
      let saveAttempts = 0;
      const maxSaveAttempts = 3;
      let savedSuccessfully = false;
      while (!savedSuccessfully && saveAttempts < maxSaveAttempts) {
        try {
          await this.supabaseService.upsertChunks(enhancedChunks);
          savedSuccessfully = true;
        } catch (saveError) {
          saveAttempts++;
          console.error(`Error saving chunks (attempt ${saveAttempts}/${maxSaveAttempts}):`, saveError);
          if (saveAttempts >= maxSaveAttempts)
            throw saveError;
          const backoffTime = Math.pow(2, saveAttempts) * 1e3;
          this.notifyProgress(task.id, 70, `Retrying database save in ${backoffTime / 1e3}s`);
          await new Promise((resolve) => setTimeout(resolve, backoffTime));
        }
      }
      timings.saveComplete = Date.now();
      console.log("Chunks saved to database:", {
        numberOfChunks: enhancedChunks.length,
        fileId: task.id,
        timings: {
          total: timings.saveComplete - timings.start,
          read: timings.readComplete - timings.start,
          chunking: timings.chunkingComplete - timings.readComplete,
          embedding: timings.embeddingComplete - timings.chunkingComplete,
          save: timings.saveComplete - timings.embeddingComplete
        }
      });
      this.notifyProgress(task.id, 100, "Processing completed");
    } catch (error) {
      console.error("Error in processCreateUpdateTask:", { error, taskId: task.id, metadata: task.metadata });
      throw error;
    }
  }
  async processDeleteTask(task) {
    if (!this.supabaseService)
      throw new Error("Supabase service not initialized");
    try {
      this.notifyProgress(task.id, 10, "Starting deletion process");
      console.log(`Checking document before deletion: ${task.metadata.obsidianId}`);
      const chunks = await this.supabaseService.getDocumentChunks(task.metadata.obsidianId);
      const chunkCount = chunks.length;
      if (chunkCount > 0) {
        console.log(`Found ${chunkCount} chunks to delete for ${task.metadata.obsidianId}`);
        this.notifyProgress(task.id, 30, `Deleting ${chunkCount} chunks`);
      } else {
        console.log(`No chunks found for deletion: ${task.metadata.obsidianId}`);
        this.notifyProgress(task.id, 30, "No chunks to delete");
      }
      let deleteAttempts = 0;
      const maxDeleteAttempts = 3;
      let deletedSuccessfully = false;
      while (!deletedSuccessfully && deleteAttempts < maxDeleteAttempts) {
        try {
          this.notifyProgress(task.id, 50, deleteAttempts > 0 ? `Deletion attempt ${deleteAttempts + 1}/${maxDeleteAttempts}` : "Deleting from database");
          await this.supabaseService.deleteDocumentChunks(task.metadata.obsidianId);
          deletedSuccessfully = true;
          const remainingChunks = await this.supabaseService.getDocumentChunks(task.metadata.obsidianId);
          if (remainingChunks.length > 0) {
            console.warn(`Deletion verification failed: ${remainingChunks.length} chunks still exist`);
            deletedSuccessfully = false;
            throw new Error(`Deletion verification failed for ${task.metadata.obsidianId}`);
          }
        } catch (deleteError) {
          deleteAttempts++;
          console.error(`Error deleting chunks (attempt ${deleteAttempts}/${maxDeleteAttempts}):`, deleteError);
          if (deleteAttempts >= maxDeleteAttempts)
            throw deleteError;
          const backoffTime = Math.pow(2, deleteAttempts) * 1e3;
          this.notifyProgress(task.id, 50, `Will retry deletion in ${backoffTime / 1e3}s`);
          await new Promise((resolve) => setTimeout(resolve, backoffTime));
        }
      }
      this.notifyProgress(task.id, 80, "Updating file status");
      await this.supabaseService.updateFileStatusOnDelete(task.metadata.obsidianId);
      this.notifyProgress(task.id, 100, "Delete completed");
      console.log(`Successfully deleted document: ${task.metadata.obsidianId}`);
    } catch (error) {
      console.error("Error in processDeleteTask:", { error, taskId: task.id, metadata: task.metadata });
      throw error;
    }
  }
  async handleTaskError(task, error) {
    task.retryCount = (task.retryCount || 0) + 1;
    task.updatedAt = Date.now();
    if (task.retryCount < this.maxRetries) {
      task.status = "RETRYING" /* RETRYING */;
      this.queue.unshift(task);
      this.notifyProgress(task.id, 0, `Retry attempt ${task.retryCount}`);
      console.log("Task queued for retry:", { taskId: task.id, retryCount: task.retryCount, maxRetries: this.maxRetries });
    } else {
      task.status = "FAILED" /* FAILED */;
      task.error = {
        message: error.message,
        code: error.code || "UNKNOWN_ERROR",
        stack: error.stack
      };
      task.completedAt = Date.now();
      console.error("Task failed after max retries:", { taskId: task.id, error: task.error });
    }
    this.errorHandler.handleError(error, { context: "QueueService.processTask", taskId: task.id, taskType: task.type });
    this.eventEmitter.emit("queue-progress", { processed: 0, total: this.queue.length, currentTask: task.id });
  }
  removeFromProcessingQueue(task) {
    const index2 = this.processingQueue.findIndex((t) => t.id === task.id);
    if (index2 !== -1) {
      this.processingQueue.splice(index2, 1);
    }
  }
  notifyProgress(taskId, progress, message) {
    this.notificationManager.updateProgress({
      taskId,
      progress,
      currentStep: message,
      totalSteps: 1,
      currentStepNumber: 1
    });
    this.eventEmitter.emit("queue-progress", { processed: progress, total: 100, currentTask: taskId });
  }
  getQueueStats() {
    const now = Date.now();
    const oneHour = 60 * 60 * 1e3;
    const tasksByStatus = this.queue.reduce((acc, task) => {
      acc[task.status] = (acc[task.status] || 0) + 1;
      return acc;
    }, {});
    const tasksByType = this.queue.reduce((acc, task) => {
      acc[task.type] = (acc[task.type] || 0) + 1;
      return acc;
    }, {});
    const completedTasks = this.queue.filter((task) => task.status === "COMPLETED" /* COMPLETED */ && task.completedAt);
    const averageTime = completedTasks.length > 0 ? completedTasks.reduce((sum, task) => sum + (task.completedAt - task.startedAt), 0) / completedTasks.length : 0;
    const tasksLastHour = completedTasks.filter((task) => task.completedAt > now - oneHour).length;
    return {
      totalTasks: this.queue.length,
      tasksByStatus,
      tasksByType,
      averageProcessingTime: averageTime,
      failedTasks: tasksByStatus["FAILED" /* FAILED */] || 0,
      retryingTasks: tasksByStatus["RETRYING" /* RETRYING */] || 0,
      tasksLastHour
    };
  }
  clear() {
    this.queue = [];
    this.processingQueue = [];
    this.notificationManager.clear();
  }
  updateSettings(settings) {
    this.maxConcurrent = settings.maxConcurrent;
    this.maxRetries = settings.maxRetries;
    if (settings.chunkSettings) {
      this.textSplitter = new TextSplitter(settings.chunkSettings);
    }
  }
  /**
   * Subscribe to queue events.
   * @param eventName The event to subscribe to.
   * @param callback The callback function.
   */
  on(eventName, callback) {
    return this.eventEmitter.on(eventName, callback);
  }
};

// utils/FileTracker.ts
var import_obsidian6 = require("obsidian");

// services/SyncFileManager.ts
var import_obsidian5 = require("obsidian");

// models/SyncModels.ts
var SyncErrorType = /* @__PURE__ */ ((SyncErrorType2) => {
  SyncErrorType2["SYNC_FILE_MISSING"] = "sync_file_missing";
  SyncErrorType2["SYNC_FILE_CORRUPT"] = "sync_file_corrupt";
  SyncErrorType2["SYNC_FILE_OUTDATED"] = "sync_file_outdated";
  SyncErrorType2["DEVICE_MISMATCH"] = "device_mismatch";
  SyncErrorType2["CONFLICT_DETECTED"] = "conflict_detected";
  SyncErrorType2["DATABASE_UNAVAILABLE"] = "database_unavailable";
  SyncErrorType2["SYNC_INTERRUPTED"] = "sync_interrupted";
  SyncErrorType2["UNKNOWN_ERROR"] = "unknown_error";
  return SyncErrorType2;
})(SyncErrorType || {});
var MAX_CONNECTION_EVENTS = 20;
var MAX_PENDING_OPERATIONS = 100;
var MAX_CONFLICTS = 50;
function getPlatformInfo() {
  const userAgent = window.navigator.userAgent;
  if (userAgent.indexOf("Win") !== -1)
    return "Windows";
  if (userAgent.indexOf("Mac") !== -1)
    return "macOS";
  if (userAgent.indexOf("iPhone") !== -1 || userAgent.indexOf("iPad") !== -1)
    return "iOS";
  if (userAgent.indexOf("Android") !== -1)
    return "Android";
  if (userAgent.indexOf("Linux") !== -1)
    return "Linux";
  return "Unknown";
}
function createEmptySyncFileData(vaultId, deviceId, deviceName, pluginVersion) {
  const now = Date.now();
  const platform = getPlatformInfo();
  const device = {
    deviceId,
    name: deviceName,
    platform,
    lastSeen: now,
    lastSyncTime: now
  };
  const devices = {};
  devices[deviceId] = device;
  return {
    header: {
      lastGlobalSync: now,
      syncState: "initializing" /* INITIALIZING */,
      vaultId,
      pluginVersion,
      lastWriter: deviceId,
      devices
    },
    connectionEvents: [],
    pendingOperations: [],
    conflicts: [],
    lastDatabaseCheck: now,
    databaseStatus: "unknown"
  };
}
function trimSyncHistoryArrays(data) {
  return {
    ...data,
    connectionEvents: data.connectionEvents.slice(-MAX_CONNECTION_EVENTS),
    pendingOperations: data.pendingOperations.slice(-MAX_PENDING_OPERATIONS),
    conflicts: data.conflicts.slice(-MAX_CONFLICTS)
  };
}
function updateDeviceInSyncFile(data, deviceId, deviceName, pluginVersion) {
  const now = Date.now();
  const platform = getPlatformInfo();
  const newData = JSON.parse(JSON.stringify(data));
  if (!newData.header.devices) {
    newData.header.devices = {};
  }
  if (newData.header.devices[deviceId]) {
    newData.header.devices[deviceId] = {
      ...newData.header.devices[deviceId],
      name: deviceName,
      platform,
      lastSeen: now,
      pluginVersion: pluginVersion || newData.header.devices[deviceId].pluginVersion
    };
  } else {
    newData.header.devices[deviceId] = {
      deviceId,
      name: deviceName,
      platform,
      lastSeen: now,
      lastSyncTime: now,
      pluginVersion
    };
  }
  newData.header.lastWriter = deviceId;
  if (pluginVersion) {
    newData.header.pluginVersion = pluginVersion;
  }
  return newData;
}
function updateDatabaseStatus(data, status) {
  const newData = JSON.parse(JSON.stringify(data));
  newData.databaseStatus = status;
  newData.lastDatabaseCheck = Date.now();
  if (status === "unavailable") {
    newData.header.syncState = "offline" /* OFFLINE */;
  } else if (status === "available") {
    newData.header.syncState = "online" /* ONLINE */;
  }
  return newData;
}
function updateDeviceSyncTime(data, deviceId) {
  const newData = JSON.parse(JSON.stringify(data));
  const now = Date.now();
  if (newData.header.devices && newData.header.devices[deviceId]) {
    newData.header.devices[deviceId].lastSyncTime = now;
    newData.header.devices[deviceId].lastSeen = now;
    newData.header.lastGlobalSync = now;
  }
  return newData;
}

// services/SyncFileManager.ts
var SyncFileManager = class {
  constructor(vault, errorHandler, syncFilePath = "_mindmatrixsync.md", backupInterval = 36e5, vaultId, deviceId, deviceName, pluginVersion) {
    this.vault = vault;
    this.errorHandler = errorHandler;
    this.lastBackup = 0;
    this.syncFile = null;
    this.currentSyncData = null;
    this.syncFilePath = syncFilePath;
    this.backupPath = `${syncFilePath}.backup`;
    this.backupInterval = backupInterval;
    this.vaultId = vaultId;
    this.deviceId = deviceId;
    this.deviceName = deviceName;
    this.pluginVersion = pluginVersion;
  }
  /**
   * Initialize or validate the sync file
   */
  async initialize() {
    try {
      const existingFile = this.vault.getAbstractFileByPath(this.syncFilePath);
      if (existingFile instanceof import_obsidian5.TFile) {
        this.syncFile = existingFile;
        const validationResult = await this.validateSyncFile();
        if (!validationResult.isValid) {
          const recovered = await this.repairSyncFile();
          if (!recovered) {
            await this.createSyncFile();
          }
        }
      } else {
        await this.createSyncFile();
      }
      await this.createBackup();
      return await this.validateSyncFile();
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.initialize",
        metadata: { syncFilePath: this.syncFilePath }
      });
      try {
        await this.createSyncFile();
        return { isValid: true };
      } catch (createError) {
        return {
          isValid: false,
          error: `Failed to initialize sync file: ${createError.message}`
        };
      }
    }
  }
  /**
   * Create a new sync file with the new structure
   */
  async createSyncFile() {
    console.log("Starting sync file creation with wait periods...");
    const FILE_OP_DELAY = 1e3;
    const existingFile = this.vault.getAbstractFileByPath(this.syncFilePath);
    this.currentSyncData = createEmptySyncFileData(
      this.vaultId,
      this.deviceId,
      this.deviceName,
      this.pluginVersion
    );
    const initialContent = this.generateSyncFileContent(this.currentSyncData);
    if (existingFile instanceof import_obsidian5.TFile) {
      try {
        console.log("Existing sync file found, attempting to modify it");
        this.syncFile = existingFile;
        await this.vault.modify(existingFile, initialContent);
        console.log("Successfully modified existing sync file");
        await new Promise((resolve) => setTimeout(resolve, FILE_OP_DELAY));
        return;
      } catch (modifyError) {
        console.warn("Failed to modify existing sync file, will try delete and recreate:", modifyError);
        try {
          await this.vault.delete(existingFile);
          await new Promise((resolve) => setTimeout(resolve, FILE_OP_DELAY));
        } catch (deleteError) {
          console.error("Failed to delete existing sync file:", deleteError);
          throw new Error(`Cannot modify or delete sync file: ${modifyError.message}, ${deleteError.message}`);
        }
      }
    }
    console.log("Waiting before creating sync file...");
    await new Promise((resolve) => setTimeout(resolve, FILE_OP_DELAY));
    let createAttempts = 0;
    const maxAttempts = 3;
    while (createAttempts < maxAttempts) {
      try {
        this.syncFile = await this.vault.create(this.syncFilePath, initialContent);
        console.log("Sync file created successfully");
        break;
      } catch (createError) {
        createAttempts++;
        console.warn(`Create attempt ${createAttempts} failed:`, createError);
        if (createAttempts >= maxAttempts) {
          const finalCheck = this.vault.getAbstractFileByPath(this.syncFilePath);
          if (finalCheck instanceof import_obsidian5.TFile) {
            console.log("Sync file exists despite creation error, using it");
            this.syncFile = finalCheck;
            return;
          }
          throw new Error(`Failed to create sync file after ${maxAttempts} attempts: ${createError.message}`);
        }
        const waitTime = FILE_OP_DELAY * (createAttempts + 1);
        console.log(`Waiting ${waitTime}ms before retry...`);
        await new Promise((resolve) => setTimeout(resolve, waitTime));
      }
    }
    const fileExists = this.vault.getAbstractFileByPath(this.syncFilePath);
    if (!fileExists) {
      throw this.errorHandler.handleSyncError(
        "sync_file_missing" /* SYNC_FILE_MISSING */,
        "Sync file creation failed - file not found after wait period",
        { context: "SyncFileManager.createSyncFile" },
        void 0,
        this.deviceId,
        false
      );
    }
    console.log("Sync file creation completed successfully");
  }
  /**
   * Generate sync file content from data
   */
  generateSyncFileContent(data) {
    const yamlContent = (0, import_obsidian5.stringifyYaml)(data);
    return `---
${yamlContent}---

## Mind Matrix Sync File

This file manages cross-device coordination for the Mind Matrix plugin.
Do not modify this file manually.
`;
  }
  /**
   * Validate sync file structure and content
   */
  async validateSyncFile() {
    if (!this.syncFile) {
      return {
        isValid: false,
        error: "Sync file not initialized"
      };
    }
    try {
      const content = await this.vault.read(this.syncFile);
      const yamlMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if (!yamlMatch) {
        console.log("Invalid sync file format: Missing YAML front matter. Will recreate file.");
        await this.createSyncFile();
        return { isValid: true };
      }
      const yamlContent = yamlMatch[1];
      let parsedData;
      try {
        parsedData = (0, import_obsidian5.parseYaml)(yamlContent);
      } catch (parseError) {
        console.log("Failed to parse YAML content:", parseError);
        await this.createSyncFile();
        return { isValid: true };
      }
      if (!parsedData || typeof parsedData !== "object") {
        console.log("Invalid sync file format: Cannot parse YAML content. Will recreate file.");
        await this.createSyncFile();
        return { isValid: true };
      }
      if (content.includes("| File Path | Last Modified |")) {
        console.log("Detected old format sync file. Will convert to new format.");
        await this.createSyncFile();
        return { isValid: true };
      }
      if (!parsedData.header || !parsedData.header.vaultId || !parsedData.header.lastGlobalSync || !parsedData.header.devices) {
        console.log("Invalid sync file format: Missing required fields. Will recreate file.");
        await this.createSyncFile();
        return { isValid: true };
      }
      if (parsedData.header.vaultId !== this.vaultId) {
        console.log("Vault ID mismatch. Old ID:", parsedData.header.vaultId, "New ID:", this.vaultId);
        parsedData.header.vaultId = this.vaultId;
      }
      this.currentSyncData = parsedData;
      if (!this.currentSyncData.connectionEvents)
        this.currentSyncData.connectionEvents = [];
      if (!this.currentSyncData.pendingOperations)
        this.currentSyncData.pendingOperations = [];
      if (!this.currentSyncData.conflicts)
        this.currentSyncData.conflicts = [];
      if (!this.currentSyncData.lastDatabaseCheck)
        this.currentSyncData.lastDatabaseCheck = Date.now();
      if (!this.currentSyncData.databaseStatus)
        this.currentSyncData.databaseStatus = "unknown";
      if (!this.currentSyncData.header.fileStatuses)
        this.currentSyncData.header.fileStatuses = {};
      this.currentSyncData = updateDeviceInSyncFile(
        this.currentSyncData,
        this.deviceId,
        this.deviceName,
        this.pluginVersion
      );
      await this.writeSyncFile(this.currentSyncData);
      return { isValid: true };
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.validateSyncFile" });
      console.log("Failed to validate sync file, will recreate:", error);
      try {
        await this.createSyncFile();
        return { isValid: true };
      } catch (createError) {
        return {
          isValid: false,
          error: `Failed to validate and recreate sync file: ${createError.message}`
        };
      }
    }
  }
  /**
   * Alias for validateSyncFile() to support legacy calls.
   */
  async validateSyncState() {
    return await this.validateSyncFile();
  }
  /**
   * Repair corrupted sync file
   */
  async repairSyncFile() {
    try {
      const restored = await this.restoreFromBackup();
      if (restored) {
        return true;
      }
      await this.createSyncFile();
      return true;
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.repairSyncFile",
        metadata: { syncFilePath: this.syncFilePath }
      });
      return false;
    }
  }
  /**
   * Read and parse the sync file
   */
  async readSyncFile() {
    if (!this.syncFile) {
      throw this.errorHandler.handleSyncError(
        "sync_file_missing" /* SYNC_FILE_MISSING */,
        "Sync file not initialized",
        { context: "SyncFileManager.readSyncFile" },
        void 0,
        this.deviceId
      );
    }
    try {
      const content = await this.vault.read(this.syncFile);
      const yamlMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if (!yamlMatch) {
        throw this.errorHandler.handleSyncError(
          "sync_file_corrupt" /* SYNC_FILE_CORRUPT */,
          "Invalid sync file format: Missing YAML front matter",
          { context: "SyncFileManager.readSyncFile" },
          void 0,
          this.deviceId
        );
      }
      const yamlContent = yamlMatch[1];
      const parsedData = (0, import_obsidian5.parseYaml)(yamlContent);
      if (!parsedData || !parsedData.header) {
        throw this.errorHandler.handleSyncError(
          "sync_file_corrupt" /* SYNC_FILE_CORRUPT */,
          "Invalid sync file format: Missing required fields",
          { context: "SyncFileManager.readSyncFile" },
          void 0,
          this.deviceId
        );
      }
      this.currentSyncData = parsedData;
      return parsedData;
    } catch (error) {
      if (!this.errorHandler.isSyncError(error)) {
        throw this.errorHandler.handleSyncError(
          "sync_file_corrupt" /* SYNC_FILE_CORRUPT */,
          `Error reading sync file: ${error.message}`,
          { context: "SyncFileManager.readSyncFile" },
          void 0,
          this.deviceId
        );
      }
      throw error;
    }
  }
  /**
   * Write sync data to the sync file
   */
  async writeSyncFile(data) {
    if (!this.syncFile) {
      throw this.errorHandler.handleSyncError(
        "sync_file_missing" /* SYNC_FILE_MISSING */,
        "Sync file not initialized",
        { context: "SyncFileManager.writeSyncFile" },
        void 0,
        this.deviceId
      );
    }
    try {
      const content = this.generateSyncFileContent(data);
      await this.vault.modify(this.syncFile, content);
      this.currentSyncData = data;
      if (Date.now() - this.lastBackup >= this.backupInterval) {
        await this.createBackup();
      }
    } catch (error) {
      throw this.errorHandler.handleSyncError(
        "unknown_error" /* UNKNOWN_ERROR */,
        `Failed to write sync file: ${error.message}`,
        { context: "SyncFileManager.writeSyncFile" },
        void 0,
        this.deviceId
      );
    }
  }
  /**
   * Create a backup of the sync file
   */
  async createBackup() {
    if (!this.syncFile)
      return;
    try {
      const content = await this.vault.read(this.syncFile);
      const backupFile = this.vault.getAbstractFileByPath(this.backupPath);
      if (backupFile instanceof import_obsidian5.TFile) {
        await this.vault.modify(backupFile, content);
      } else {
        await this.vault.create(this.backupPath, content);
      }
      this.lastBackup = Date.now();
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.createBackup" });
    }
  }
  /**
   * Restore sync file from backup
   */
  async restoreFromBackup() {
    const backupFile = this.vault.getAbstractFileByPath(this.backupPath);
    if (!(backupFile instanceof import_obsidian5.TFile)) {
      return false;
    }
    try {
      const content = await this.vault.read(backupFile);
      if (this.syncFile) {
        await this.vault.modify(this.syncFile, content);
      } else {
        this.syncFile = await this.vault.create(this.syncFilePath, content);
      }
      const validationResult = await this.validateSyncFile();
      return validationResult.isValid;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.restoreFromBackup" });
      return false;
    }
  }
  /**
   * Update the database connection status
   */
  async updateDatabaseStatus(status) {
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      if (this.currentSyncData) {
        const updatedData = updateDatabaseStatus(this.currentSyncData, status);
        if (status === "unavailable" && this.currentSyncData.databaseStatus !== "unavailable") {
          updatedData.connectionEvents.push({
            timestamp: Date.now(),
            eventType: "disconnected",
            deviceId: this.deviceId,
            details: "Database connection lost"
          });
        }
        if (status === "available" && this.currentSyncData.databaseStatus !== "available") {
          updatedData.connectionEvents.push({
            timestamp: Date.now(),
            eventType: "connected",
            deviceId: this.deviceId,
            details: "Database connection established"
          });
        }
        const trimmedData = trimSyncHistoryArrays(updatedData);
        await this.writeSyncFile(trimmedData);
      }
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "SyncFileManager.updateDatabaseStatus",
        metadata: { status }
      });
    }
  }
  /**
   * Update device sync timestamp and status
   */
  async updateDeviceSyncTimestamp() {
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      if (this.currentSyncData) {
        const updatedData = updateDeviceSyncTime(this.currentSyncData, this.deviceId);
        await this.writeSyncFile(updatedData);
      }
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.updateDeviceSyncTimestamp" });
    }
  }
  /**
   * **New Method:**
   * Updates the sync status for a given file in the sync file.
   * This method is used as a fallback when the database isn't available.
   */
  async updateSyncStatus(filePath, status, additionalData) {
    if (!this.currentSyncData) {
      await this.readSyncFile();
    }
    if (this.currentSyncData) {
      this.currentSyncData.header.fileStatuses = this.currentSyncData.header.fileStatuses || {};
      this.currentSyncData.header.fileStatuses[filePath] = {
        status,
        lastModified: additionalData.lastModified,
        hash: additionalData.hash,
        updatedAt: Date.now()
      };
      await this.writeSyncFile(this.currentSyncData);
    } else {
      throw new Error("Sync file data unavailable for updateSyncStatus");
    }
  }
  /**
   * Gets the sync status for a specific file path.
   */
  async getSyncStatus(path) {
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      if (this.currentSyncData && this.currentSyncData.header.fileStatuses) {
        return this.currentSyncData.header.fileStatuses[path] || null;
      }
      return null;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.getSyncStatus", metadata: { path } });
      return null;
    }
  }
  /**
   * Get all pending operations
   */
  async getPendingOperations() {
    var _a2;
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      return ((_a2 = this.currentSyncData) == null ? void 0 : _a2.pendingOperations) || [];
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.getPendingOperations" });
      return [];
    }
  }
  /**
   * Get current sync state
   */
  async getSyncState() {
    var _a2;
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      return ((_a2 = this.currentSyncData) == null ? void 0 : _a2.header.syncState) || "unknown" /* UNKNOWN */;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.getSyncState" });
      return "unknown" /* UNKNOWN */;
    }
  }
  /**
   * Get information about all known devices
   */
  async getKnownDevices() {
    var _a2;
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      return ((_a2 = this.currentSyncData) == null ? void 0 : _a2.header.devices) || {};
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.getKnownDevices" });
      return {};
    }
  }
  /**
   * Check if there are conflicts that need resolution
   */
  async detectConflicts() {
    var _a2;
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      const pendingConflicts = ((_a2 = this.currentSyncData) == null ? void 0 : _a2.conflicts.filter(
        (conflict) => conflict.resolutionStatus === "pending"
      )) || [];
      return pendingConflicts;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.detectConflicts" });
      return [];
    }
  }
  /**
   * Attempt to resolve a conflict based on a given resolution strategy.
   * Supports strategies:
   * - "newest-wins": Automatically resolves by favoring the most recent update.
   * - "keep-both": Marks as resolved and leaves both versions intact.
   * - "manual": Flags the conflict for manual intervention (does not auto-resolve).
   */
  async resolveConflict(conflictId, resolutionStrategy) {
    var _a2;
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      const conflictIndex = (_a2 = this.currentSyncData) == null ? void 0 : _a2.conflicts.findIndex((c) => c.id === conflictId);
      if (conflictIndex === void 0 || conflictIndex < 0) {
        console.warn("Conflict not found:", conflictId);
        return false;
      }
      const conflict = this.currentSyncData.conflicts[conflictIndex];
      switch (resolutionStrategy) {
        case "newest-wins":
          conflict.resolutionStrategy = "newest-wins";
          conflict.resolutionStatus = "resolved";
          conflict.resolvedAt = Date.now();
          conflict.resolvedBy = this.deviceId;
          break;
        case "keep-both":
          conflict.resolutionStrategy = "keep-both";
          conflict.resolutionStatus = "resolved";
          conflict.resolvedAt = Date.now();
          conflict.resolvedBy = this.deviceId;
          break;
        case "manual":
          conflict.resolutionStrategy = "manual";
          console.log("Manual resolution required for conflict:", conflictId);
          return false;
        default:
          throw new Error("Unsupported resolution strategy");
      }
      await this.writeSyncFile(this.currentSyncData);
      return true;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.resolveConflict", metadata: { conflictId } });
      return false;
    }
  }
  /**
   * Attempt to resolve all detected conflicts using a default strategy.
   */
  async resolveAllConflicts(defaultStrategy = "newest-wins") {
    try {
      const conflicts = await this.detectConflicts();
      for (const conflict of conflicts) {
        await this.resolveConflict(conflict.id, defaultStrategy);
      }
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.resolveAllConflicts" });
    }
  }
  /**
   * Update the last sync timestamp in the sync file header.
   */
  async updateLastSync() {
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      if (this.currentSyncData) {
        this.currentSyncData.header.lastGlobalSync = Date.now();
        await this.writeSyncFile(this.currentSyncData);
      }
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.updateLastSync" });
    }
  }
  /**
   * Gets all sync entries from the sync file.
   */
  async getAllSyncEntries() {
    try {
      if (!this.currentSyncData) {
        await this.readSyncFile();
      }
      if (this.currentSyncData && this.currentSyncData.header.fileStatuses) {
        return Object.entries(this.currentSyncData.header.fileStatuses).map(([filePath, data]) => ({
          filePath,
          status: data.status,
          lastModified: data.lastModified,
          hash: data.hash
        }));
      }
      return [];
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.getAllSyncEntries" });
      return [];
    }
  }
  /**
   * Attempt recovery operations when sync issues are detected.
   */
  async attemptRecovery() {
    try {
      const recovered = await this.restoreFromBackup();
      if (recovered) {
        console.log("Successfully recovered from backup");
        return true;
      }
      console.log("Backup restoration failed, attempting to recreate sync file");
      await this.createSyncFile();
      const validationResult = await this.validateSyncFile();
      return validationResult.isValid;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "SyncFileManager.attemptRecovery" });
      return false;
    }
  }
};

// utils/FileTracker.ts
var FileTracker = class {
  /**
   * @param vault The Obsidian vault instance.
   * @param errorHandler Centralized error handler.
   * @param syncFilePath Path to the sync file.
   * @param supabaseService Optional Supabase service instance.
   * @param offlineQueueManager Optional OfflineQueueManager for offline mode.
   */
  constructor(vault, errorHandler, syncFilePath = "_mindmatrixsync.md", supabaseService = null, offlineQueueManager) {
    this.vault = vault;
    this.errorHandler = errorHandler;
    this.supabaseService = supabaseService;
    this.eventQueue = [];
    this.isProcessing = false;
    this.processingTimeout = 1e3;
    // Optional offline queue manager for offline operations
    this.offlineQueueManager = null;
    this.maxFileSizeBytes = 10 * 1024 * 1024;
    this.syncFilePath = syncFilePath;
    this.syncManager = new SyncFileManager(vault, errorHandler, syncFilePath);
    if (offlineQueueManager) {
      this.offlineQueueManager = offlineQueueManager;
    }
  }
  /**
   * Initialize the file tracker.
   * If a Supabase service is available, reconcile the database with the local sync file.
   */
  async initialize() {
    try {
      console.log("[FileTracker.initialize] Starting FileTracker initialization");
      console.log(`[FileTracker.initialize] Sync file path: ${this.syncFilePath}`);
      await this.syncManager.initialize();
      if (this.supabaseService) {
        await this.reconcileDatabaseWithSyncFile();
      } else {
        console.log("Supabase service not available. Using sync file only for tracking.");
      }
      console.log("FileTracker initialized.");
    } catch (error) {
      this.errorHandler.handleError(error, { context: "FileTracker.initialize" });
      throw error;
    }
  }
  /**
   * Reconcile database records with local sync file entries.
   * Ensures that each file in the vault has an up-to-date status in the database.
   */
  async reconcileDatabaseWithSyncFile() {
    try {
      if (!this.supabaseService)
        return;
      const syncEntries = await this.syncManager.getAllSyncEntries();
      const entriesMap = new Map(syncEntries.map((entry) => [entry.filePath, entry]));
      const files = this.vault.getFiles();
      for (const file of files) {
        if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path))
          continue;
        try {
          const dbStatus = await this.supabaseService.getFileVectorizationStatus(file.path);
          const currentHash = await this.calculateFileHash(file);
          if (dbStatus.isVectorized) {
            const fileModifiedSinceDb = file.stat.mtime > (dbStatus.lastModified || 0);
            if (fileModifiedSinceDb) {
              const metadata = await this.createFileMetadata(file);
              await this.supabaseService.updateFileVectorizationStatus(metadata);
              console.log(`Database record updated to PENDING for modified file: ${file.path}`);
            }
          } else {
            const metadata = await this.createFileMetadata(file);
            await this.supabaseService.updateFileVectorizationStatus(metadata);
            console.log(`Database record created/updated for file: ${file.path}`);
          }
        } catch (error) {
          this.errorHandler.handleError(error, {
            context: "FileTracker.reconcileDatabaseWithSyncFile",
            metadata: { filePath: file.path }
          });
        }
      }
      for (const entry of syncEntries) {
        const file = this.vault.getAbstractFileByPath(entry.filePath);
        if (!file && entry.status !== "ERROR" && this.supabaseService) {
          await this.supabaseService.updateFileStatusOnDelete(entry.filePath);
          console.log(`Database record marked as deleted for file: ${entry.filePath}`);
        }
      }
    } catch (error) {
      console.error("Error reconciling database with sync file:", error);
    }
  }
  async handleCreate(file) {
    if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path))
      return;
    const event = { type: "create", file, timestamp: Date.now() };
    await this.queueEvent(event);
  }
  /**
   * Handle file modification events.
   * Enhanced with change detection and intelligent debouncing.
   */
  async handleModify(file) {
    if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file))
      return;
    try {
      const recentChange = this.recentChanges.get(file.path);
      const currentTime = Date.now();
      const hash = await this.calculateFileHash(file);
      if (recentChange && recentChange.hash === hash && currentTime - recentChange.lastProcessed < this.processingTimeout * 2) {
        console.log(`Skipping redundant update for ${file.path} - content unchanged`);
        return;
      }
      if (recentChange) {
        console.log(`Content changed for ${file.path}. Previous hash: ${recentChange.hash.substring(0, 8)}..., New hash: ${hash.substring(0, 8)}...`);
      }
      this.recentChanges.set(file.path, {
        lastModified: file.stat.mtime,
        hash,
        lastProcessed: currentTime
      });
      const event = {
        type: "modify",
        file,
        timestamp: currentTime,
        hash
      };
      await this.queueEvent(event);
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "FileTracker.handleModify",
        metadata: { filePath: file.path }
      });
    }
  }
  async handleDelete(file) {
    if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path))
      return;
    const event = { type: "delete", file, timestamp: Date.now() };
    await this.queueEvent(event);
    if (this.offlineQueueManager) {
      await this.offlineQueueManager.queueOperation({
        operationType: "delete",
        fileId: file.path,
        timestamp: Date.now()
      });
    } else if (this.supabaseService) {
      try {
        await this.supabaseService.updateFileStatusOnDelete(file.path);
      } catch (error) {
        console.error("Error updating database for deleted file:", error);
      }
    } else {
      await this.syncManager.updateSyncStatus(file.path, "OK", {
        lastModified: Date.now(),
        hash: ""
      });
    }
  }
  async handleRename(file, oldPath) {
    if (!(file instanceof import_obsidian6.TFile) || !this.shouldTrackFile(file.path))
      return;
    const event = { type: "rename", file, oldPath, timestamp: Date.now() };
    await this.queueEvent(event);
    const newHash = await this.calculateFileHash(file);
    const metadata = await this.createFileMetadata(file);
    if (this.offlineQueueManager) {
      await this.offlineQueueManager.queueOperation({
        operationType: "rename",
        fileId: file.path,
        metadata: { oldPath },
        timestamp: Date.now()
      });
    } else if (this.supabaseService) {
      await this.supabaseService.updateFileVectorizationStatus(metadata);
      await this.supabaseService.updateFileStatusOnDelete(oldPath);
    } else {
      await this.syncManager.updateSyncStatus(file.path, "PENDING", {
        lastModified: file.stat.mtime,
        hash: newHash
      });
      await this.syncManager.updateSyncStatus(oldPath, "OK", {
        lastModified: Date.now(),
        hash: ""
      });
    }
  }
  /**
   * Queue an event for processing with intelligent debouncing.
   */
  async queueEvent(event) {
    this.eventQueue.push(event);
    if (!this.isProcessing) {
      let debounceTime = this.processingTimeout;
      if (event.type === "delete" || event.type === "rename") {
        debounceTime = Math.min(debounceTime / 2, 500);
      }
      if (event.type === "modify") {
        const recentEvents = this.eventQueue.filter(
          (e) => e.file.path === event.file.path && e.type === "modify" && event.timestamp - e.timestamp < 5e3
        );
        if (recentEvents.length > 3) {
          debounceTime = Math.max(debounceTime * 2, 3e3);
          console.log(`Increased debounce time to ${debounceTime}ms for rapid changes to ${event.file.path}`);
        }
      }
      setTimeout(() => this.processEventQueue(), debounceTime);
    }
  }
  /**
   * Process the event queue with improved conflict handling.
   */
  async processEventQueue() {
    var _a2;
    if (this.isProcessing || this.eventQueue.length === 0)
      return;
    this.isProcessing = true;
    console.log(`Processing ${this.eventQueue.length} queued events`);
    try {
      const eventsByPath = /* @__PURE__ */ new Map();
      for (const event of this.eventQueue) {
        const path = event.file.path;
        if (!eventsByPath.has(path)) {
          eventsByPath.set(path, []);
        }
        (_a2 = eventsByPath.get(path)) == null ? void 0 : _a2.push(event);
      }
      const paths = Array.from(eventsByPath.keys());
      const deleteFirst = paths.sort((a, b) => {
        var _a3, _b, _c, _d;
        const aHasDelete = (_b = (_a3 = eventsByPath.get(a)) == null ? void 0 : _a3.some((e) => e.type === "delete")) != null ? _b : false;
        const bHasDelete = (_d = (_c = eventsByPath.get(b)) == null ? void 0 : _c.some((e) => e.type === "delete")) != null ? _d : false;
        if (aHasDelete && !bHasDelete)
          return -1;
        if (!aHasDelete && bHasDelete)
          return 1;
        return 0;
      });
      for (const path of deleteFirst) {
        const events = eventsByPath.get(path);
        if (events) {
          await this.processFileEvents(path, events);
        }
      }
      this.eventQueue = [];
    } catch (error) {
      this.errorHandler.handleError(error, { context: "FileTracker.processEventQueue" });
    } finally {
      this.isProcessing = false;
      if (this.eventQueue.length > 0) {
        setTimeout(() => this.processEventQueue(), 100);
      }
    }
  }
  /**
   * Process all events for a single file with improved change detection.
   */
  async processFileEvents(path, events) {
    events.sort((a, b) => a.timestamp - b.timestamp);
    const finalEvent = events[events.length - 1];
    console.log(`Processing ${events.length} events for ${path}, final event: ${finalEvent.type}`);
    try {
      if (finalEvent.type === "delete") {
        console.log(`Skipping further processing for deleted file: ${path}`);
        return;
      }
      const newHash = finalEvent.hash || await this.calculateFileHash(finalEvent.file);
      let needsVectorizing = true;
      if (this.supabaseService) {
        try {
          needsVectorizing = await this.supabaseService.needsVectorizing(
            path,
            finalEvent.file.stat.mtime,
            newHash
          );
          if (!needsVectorizing) {
            console.log(`File ${path} does not need vectorizing - no significant changes`);
          }
        } catch (error) {
          console.error("Error checking if file needs vectorizing:", error);
          needsVectorizing = true;
        }
      } else {
        const syncStatus = await this.syncManager.getSyncStatus(path);
        if (syncStatus && syncStatus.hash === newHash && finalEvent.file.stat.mtime <= syncStatus.lastModified && syncStatus.status !== "PENDING") {
          needsVectorizing = false;
          console.log(`File ${path} does not need vectorizing according to sync file status`);
        }
      }
      this.recentChanges.set(path, {
        lastModified: finalEvent.file.stat.mtime,
        hash: newHash,
        lastProcessed: Date.now()
      });
      if (needsVectorizing) {
        console.log(`Updating status for ${path} with hash ${newHash.substring(0, 8)}...`);
        const metadata = await this.createFileMetadata(finalEvent.file);
        metadata.customMetadata.contentHash = newHash;
        if (this.supabaseService) {
          await this.supabaseService.updateFileVectorizationStatus(metadata);
        } else {
          await this.syncManager.updateSyncStatus(path, "PENDING", {
            lastModified: finalEvent.file.stat.mtime,
            hash: newHash
          });
        }
      }
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: "FileTracker.processFileEvents",
        metadata: { path, eventType: finalEvent.type }
      });
    }
  }
  async calculateFileHash(file) {
    try {
      const content = await this.vault.read(file);
      return await this.hashString(content);
    } catch (error) {
      this.errorHandler.handleError(error, { context: "FileTracker.calculateFileHash", metadata: { filePath: file.path } });
      return "";
    }
  }
  async hashString(str2) {
    const encoder = new TextEncoder();
    const data = encoder.encode(str2);
    const buffer = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(buffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  async createFileMetadata(file) {
    try {
      const content = await this.vault.read(file);
      const lineCount = content.split("\n").length;
      let additionalMetadata = {};
      if (this.supabaseService) {
        try {
          const status = await this.supabaseService.getFileVectorizationStatus(file.path);
          if (status.isVectorized) {
            additionalMetadata = {
              lastVectorized: status.lastVectorized,
              contentHash: status.contentHash
            };
          }
        } catch (error) {
          console.error("Error getting file status from database:", error);
        }
      }
      return {
        obsidianId: file.path,
        path: file.path,
        lastModified: file.stat.mtime,
        created: file.stat.ctime,
        size: file.stat.size,
        customMetadata: { ...additionalMetadata },
        loc: { lines: { from: 1, to: lineCount } },
        source: "obsidian",
        file_id: file.path,
        blobType: "text/markdown"
      };
    } catch (error) {
      this.errorHandler.handleError(error, { context: "FileTracker.createFileMetadata", metadata: { filePath: file.path } });
      return {
        obsidianId: file.path,
        path: file.path,
        lastModified: file.stat.mtime,
        created: file.stat.ctime,
        size: file.stat.size,
        customMetadata: {}
      };
    }
  }
  /**
   * Determine if a file should be tracked and processed.
   * Enhanced with additional exclusion logic.
   */
  shouldTrackFile(file) {
    if (!this.settings || !isVaultInitialized(this.settings)) {
      return false;
    }
    if (!this.settings.enableAutoSync) {
      return false;
    }
    const allExclusions = getAllExclusions(this.settings);
    const filePath = file.path;
    const fileName = file.name;
    if (filePath === this.settings.sync.syncFilePath || filePath === this.settings.sync.syncFilePath + ".backup") {
      return false;
    }
    const isBinaryFile = this.isBinaryFile(fileName);
    if (isBinaryFile) {
      console.log(`Skipping binary file: ${fileName}`);
      return false;
    }
    if (file.stat.size > this.maxFileSizeBytes) {
      console.log(`Skipping file exceeding size limit: ${fileName} (${file.stat.size} bytes)`);
      return false;
    }
    if (Array.isArray(allExclusions.excludedFiles) && allExclusions.excludedFiles.includes(fileName)) {
      console.log("Skipping excluded file:", fileName);
      return false;
    }
    if (Array.isArray(allExclusions.excludedFolders)) {
      const isExcludedFolder = allExclusions.excludedFolders.some((folder) => {
        const normalizedFolder = folder.endsWith("/") ? folder : folder + "/";
        return filePath.startsWith(normalizedFolder);
      });
      if (isExcludedFolder) {
        console.log("Skipping file in excluded folder:", filePath);
        return false;
      }
    }
    if (Array.isArray(allExclusions.excludedFileTypes)) {
      const isExcludedType = allExclusions.excludedFileTypes.some(
        (ext) => filePath.toLowerCase().endsWith(ext.toLowerCase())
      );
      if (isExcludedType) {
        console.log("Skipping excluded file type:", filePath);
        return false;
      }
    }
    if (Array.isArray(allExclusions.excludedFilePrefixes)) {
      const isExcludedPrefix = allExclusions.excludedFilePrefixes.some(
        (prefix) => fileName.startsWith(prefix)
      );
      if (isExcludedPrefix) {
        console.log("Skipping file with excluded prefix:", fileName);
        return false;
      }
    }
    return true;
  }
  /**
   * Retrieve sync status for a given file from the sync file.
   */
  async getSyncStatus(path) {
    return await this.syncManager.getSyncStatus(path);
  }
  /**
   * Retrieve all sync statuses.
   */
  async getAllSyncStatuses() {
    return await this.syncManager.getAllSyncEntries();
  }
  /**
   * Allows late binding of the Supabase service.
   */
  setSupabaseService(service) {
    this.supabaseService = service;
  }
  /**
   * Clear the event queue.
   */
  clearQueue() {
    this.eventQueue = [];
  }
  /**
   * Update the processing timeout.
   */
  setProcessingTimeout(timeout) {
    this.processingTimeout = timeout;
  }
  /**
      * Helper method to determine if a file is likely binary based on extension
     */
  isBinaryFile(fileName) {
    const binaryExtensions = [
      ".jpg",
      ".jpeg",
      ".png",
      ".gif",
      ".bmp",
      ".tiff",
      ".ico",
      ".pdf",
      ".zip",
      ".7z",
      ".rar",
      ".tar",
      ".gz",
      ".mp3",
      ".mp4",
      ".wav",
      ".ogg",
      ".flac",
      ".exe",
      ".dll",
      ".so",
      ".dylib",
      ".db",
      ".sqlite"
    ];
    return binaryExtensions.some(
      (ext) => fileName.toLowerCase().endsWith(ext)
    );
  }
};

// utils/ErrorHandler.ts
var import_obsidian7 = require("obsidian");
var ErrorHandler = class {
  constructor(settings, vaultPath) {
    this.errorLogs = [];
    this.maxLogs = 100;
    this.settings = settings;
    if (settings.logToFile && vaultPath) {
      this.logFilePath = `${vaultPath}/.obsidian/mind-matrix.log`;
    }
  }
  /**
   * Handles errors with context and optional recovery.
   */
  handleError(error, context, level = "error") {
    if (!this.shouldLog(level)) {
      return;
    }
    const errorLog = {
      timestamp: Date.now(),
      error: this.normalizeError(error),
      context,
      level,
      handled: false
    };
    this.errorLogs.unshift(errorLog);
    if (this.errorLogs.length > this.maxLogs) {
      this.errorLogs.pop();
    }
    if (level === "error" || level === "warn" && this.settings.logLevel === "debug") {
      new import_obsidian7.Notice(`Error: ${error.message}`);
    }
    if (this.settings.enableDebugLogs) {
      console.group(`[${level.toUpperCase()}] ${context.context}`);
      console.error("Error details:", error);
      console.error("Context:", context);
      if (error.stack) {
        console.error("Stack trace:", error.stack);
      }
      console.groupEnd();
    }
    if (this.settings.logToFile && this.logFilePath) {
      this.writeToLogFile(errorLog);
    }
  }
  /**
   * Creates and handles a sync error.
   */
  handleSyncError(type, message, context, details, deviceId, recoverable = true) {
    const error = {
      name: "SyncError",
      message,
      type,
      details,
      deviceId,
      recoverable,
      stack: new Error().stack
    };
    this.handleError(error, context, recoverable ? "warn" : "error");
    return error;
  }
  /**
   * Handles connection errors specifically for sync operations.
   */
  handleConnectionError(error, context, deviceId) {
    let syncError;
    if (error && error.type && Object.values(SyncErrorType).includes(error.type)) {
      syncError = error;
    } else {
      syncError = {
        name: "SyncError",
        message: error.message || "Database connection error",
        type: "database_unavailable" /* DATABASE_UNAVAILABLE */,
        details: { originalError: error },
        deviceId,
        recoverable: true,
        stack: error.stack || new Error().stack
      };
    }
    this.handleError(syncError, { context }, "warn");
  }
  /**
   * Checks if the given error level should be logged.
   */
  shouldLog(level) {
    const levels = { error: 0, warn: 1, info: 2, debug: 3 };
    return levels[level] <= levels[this.settings.logLevel];
  }
  /**
   * Normalizes different error formats.
   */
  normalizeError(error) {
    if (error instanceof Error) {
      return error;
    }
    if (error && error.type && Object.values(SyncErrorType).includes(error.type)) {
      const syncError = new Error(error.message || "Sync error");
      syncError.name = "SyncError";
      Object.assign(syncError, error);
      return syncError;
    }
    if (this.isSupabaseError(error)) {
      return new Error(`Database error (${error.code}): ${error.message}${error.hint ? ` - ${error.hint}` : ""}`);
    }
    if (typeof error === "string") {
      return new Error(error);
    }
    if (typeof error === "object") {
      const message = error.message || "Unknown error";
      const normalizedError = new Error(message);
      Object.assign(normalizedError, error);
      return normalizedError;
    }
    return new Error("Unknown error occurred");
  }
  /**
   * Type guard for Supabase errors.
   */
  isSupabaseError(error) {
    return error && typeof error === "object" && "code" in error && "details" in error;
  }
  /**
   * Type guard for Sync errors.
   */
  isSyncError(error) {
    return error && typeof error === "object" && "type" in error && Object.values(SyncErrorType).includes(error.type);
  }
  /**
   * Shows an appropriate notification based on error type.
   */
  showErrorNotification(error) {
    let message = "An error occurred";
    let duration = 4e3;
    if (this.isSyncError(error)) {
      switch (error.type) {
        case "sync_file_missing" /* SYNC_FILE_MISSING */:
          message = "Sync file is missing. Will attempt to recreate.";
          break;
        case "sync_file_corrupt" /* SYNC_FILE_CORRUPT */:
          message = "Sync file is corrupted. Will attempt to repair.";
          break;
        case "device_mismatch" /* DEVICE_MISMATCH */:
          message = "Device identification issue. Check plugin settings.";
          break;
        case "conflict_detected" /* CONFLICT_DETECTED */:
          message = "Sync conflict detected. Check sync status for details.";
          duration = 6e3;
          break;
        case "database_unavailable" /* DATABASE_UNAVAILABLE */:
          message = "Database connection unavailable. Operating in offline mode.";
          break;
        case "sync_interrupted" /* SYNC_INTERRUPTED */:
          message = "Sync operation was interrupted. Will retry.";
          break;
        default:
          message = `Sync error: ${error.message}`;
      }
    } else if (this.isSupabaseError(error)) {
      switch (error.code) {
        case "42P01":
          message = "Database table not found. Please run setup SQL.";
          break;
        case "42501":
          message = "Insufficient database permissions.";
          break;
        case "23505":
          message = "Duplicate entry found.";
          break;
        default:
          message = `Database error: ${error.message}`;
      }
      duration = 6e3;
    } else if (error.type === "CHUNKING_ERROR" /* CHUNKING_ERROR */) {
      message = "Error splitting document into chunks";
    } else if (error.type === "EMBEDDING_ERROR" /* EMBEDDING_ERROR */) {
      message = "Error generating embeddings";
    } else if (error.type === "DATABASE_ERROR" /* DATABASE_ERROR */) {
      message = "Database operation failed";
    } else if (error.type === "INVALID_METADATA" /* INVALID_METADATA */) {
      message = "Invalid document metadata";
    } else if (error.type === "FILE_ACCESS_ERROR" /* FILE_ACCESS_ERROR */) {
      message = "Error accessing file";
    } else if (error.type === "YAML_PARSE_ERROR" /* YAML_PARSE_ERROR */) {
      message = "Error parsing YAML front matter";
    } else if (error.type === "VECTOR_EXTENSION_ERROR" /* VECTOR_EXTENSION_ERROR */) {
      message = "Vector extension not available";
    } else if (error.type === "SYNC_ERROR" /* SYNC_ERROR */) {
      message = "Sync operation failed";
    } else if (error.type === "QUEUE_FULL" /* QUEUE_FULL */) {
      message = "Task queue is full";
    } else if (error.type === "TASK_TIMEOUT" /* TASK_TIMEOUT */) {
      message = "Task timed out";
    } else if (error.type === "TASK_CANCELLED" /* TASK_CANCELLED */) {
      message = "Task was cancelled";
    } else if (error.type === "MAX_RETRIES_EXCEEDED" /* MAX_RETRIES_EXCEEDED */) {
      message = "Maximum retry attempts exceeded";
    } else if (error.type === "INVALID_TASK_STATE" /* INVALID_TASK_STATE */) {
      message = "Invalid task state";
    } else if (error.type === "TASK_NOT_FOUND" /* TASK_NOT_FOUND */) {
      message = "Task not found";
    }
    if (error.message && !this.isSyncError(error)) {
      message = `${message}: ${error.message}`;
    }
    new import_obsidian7.Notice(message, duration);
  }
  /**
   * Writes error log to file.
   */
  writeToLogFile(log) {
    var _a2, _b, _c;
    if (!this.logFilePath)
      return;
    const logEntry = {
      timestamp: new Date(log.timestamp).toISOString(),
      level: log.level.toUpperCase(),
      context: log.context.context,
      error: log.error.message,
      stack: log.error.stack,
      metadata: log.context.metadata
    };
    try {
      if ((_c = (_b = (_a2 = window.app) == null ? void 0 : _a2.vault) == null ? void 0 : _b.adapter) == null ? void 0 : _c.append) {
        window.app.vault.adapter.append(
          this.logFilePath,
          JSON.stringify(logEntry) + "\n"
        );
      }
    } catch (error) {
      console.error("Failed to write to log file:", error);
    }
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  getRecentLogs(count = 10) {
    return this.errorLogs.slice(0, count);
  }
  clearLogs() {
    this.errorLogs = [];
  }
  getErrorStats() {
    return this.errorLogs.reduce((acc, log) => {
      const errorType = log.error.name || "Unknown";
      acc[errorType] = (acc[errorType] || 0) + 1;
      return acc;
    }, {});
  }
  getSyncErrorStats() {
    const stats = {};
    Object.values(SyncErrorType).forEach((type) => {
      stats[type] = 0;
    });
    this.errorLogs.forEach((log) => {
      if (this.isSyncError(log.error)) {
        stats[log.error.type] = (stats[log.error.type] || 0) + 1;
      }
    });
    return stats;
  }
};

// utils/NotificationManager.ts
var import_obsidian8 = require("obsidian");
var NotificationManager = class {
  constructor(statusBarEl, enableNotifications, enableProgressBar) {
    this.fixedProgressBar = null;
    this.notificationQueue = [];
    this.isProcessingQueue = false;
    this.statusBarItem = statusBarEl;
    this.enableNotifications = enableNotifications;
    this.enableProgressBar = enableProgressBar;
    this.initializeStatusBar();
  }
  /**
   * Shows a notification message.
   */
  showNotification(message, duration = 4e3) {
    if (!this.enableNotifications)
      return;
    this.notificationQueue.push(message);
    if (!this.isProcessingQueue) {
      this.processNotificationQueue();
    }
  }
  /**
   * Updates the fixed progress bar with the current progress (in percent) and status message.
   */
  updateProgress(progress) {
    if (!this.enableProgressBar)
      return;
    if (!this.fixedProgressBar) {
      this.fixedProgressBar = this.createFixedProgressBar();
    }
    const progressPercentage = Math.round(progress.progress);
    this.fixedProgressBar.fill.style.width = `${progressPercentage}%`;
    this.fixedProgressBar.text.textContent = `${progressPercentage}% - ${progress.currentStep} (${progress.currentStepNumber}/${progress.totalSteps})`;
  }
  /**
   * Initializes the status bar container.
   */
  initializeStatusBar() {
    this.statusBarItem.innerHTML = "";
    const container = document.createElement("div");
    container.addClass("fixed-progress-container");
    this.statusBarItem.appendChild(container);
  }
  /**
   * Creates a fixed progress bar element.
   */
  createFixedProgressBar() {
    const container = document.createElement("div");
    container.addClass("fixed-progress-bar-container");
    const bar = document.createElement("div");
    bar.addClass("fixed-progress-bar");
    const fill = document.createElement("div");
    fill.addClass("fixed-progress-fill");
    const text = document.createElement("div");
    text.addClass("fixed-progress-text");
    bar.appendChild(fill);
    container.appendChild(bar);
    container.appendChild(text);
    this.statusBarItem.appendChild(container);
    return { container, fill, text };
  }
  /**
   * Processes the notification queue sequentially.
   */
  async processNotificationQueue() {
    if (this.isProcessingQueue || this.notificationQueue.length === 0)
      return;
    this.isProcessingQueue = true;
    try {
      while (this.notificationQueue.length > 0) {
        const message = this.notificationQueue.shift();
        if (message) {
          new import_obsidian8.Notice(message);
          await new Promise((resolve) => setTimeout(resolve, 500));
        }
      }
    } finally {
      this.isProcessingQueue = false;
    }
  }
  /**
   * Updates notification settings.
   */
  updateSettings(enableNotifications, enableProgressBar) {
    this.enableNotifications = enableNotifications;
    this.enableProgressBar = enableProgressBar;
  }
  /**
   * Clears all notifications.
   */
  clear() {
    this.notificationQueue = [];
  }
};

// settings/SettingsTab.ts
var import_obsidian9 = require("obsidian");
var MindMatrixSettingsTab = class extends import_obsidian9.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.settings = plugin.settings;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    console.log("DEBUG - All Exclusion Settings:", {
      userSettings: this.settings.exclusions,
      systemDefaults: SYSTEM_EXCLUSIONS
    });
    containerEl.createEl("h2", { text: "Vault Identification" });
    if (isVaultInitialized2(this.settings)) {
      new import_obsidian9.Setting(containerEl).setName("Vault ID").setDesc("Unique identifier for this vault in the database.").addText(
        (text) => text.setValue(this.settings.vaultId).setDisabled(true)
      );
      new import_obsidian9.Setting(containerEl).setName("Vault Name").setDesc("The name of your current vault.").addText(
        (text) => text.setValue(this.settings.lastKnownVaultName).setDisabled(true)
      );
      new import_obsidian9.Setting(containerEl).setName("Reset Vault ID").setDesc("Generate a new vault ID (requires full resync).").addButton(
        (btn) => btn.setButtonText("Reset").setWarning().onClick(async () => {
          const confirmed = await this.showResetConfirmation();
          if (confirmed) {
            this.settings.vaultId = generateVaultId();
            this.settings.lastKnownVaultName = this.app.vault.getName();
            await this.plugin.saveSettings();
            new import_obsidian9.Notice("Vault ID has been reset. Please resync your vault.");
            this.display();
          }
        })
      );
    } else {
      new import_obsidian9.Setting(containerEl).setName("Initialize Vault").setDesc("Generate a unique identifier for this vault to begin syncing.").addButton(
        (btn) => btn.setButtonText("Initialize").onClick(async () => {
          this.settings.vaultId = generateVaultId();
          this.settings.lastKnownVaultName = this.app.vault.getName();
          await this.plugin.saveSettings();
          new import_obsidian9.Notice("Vault has been initialized.");
          this.display();
        })
      );
    }
    containerEl.createEl("h2", { text: "Supabase Configuration" });
    new import_obsidian9.Setting(containerEl).setName("Supabase URL").setDesc("The URL of your Supabase project (e.g., https://your-project.supabase.co).").addText(
      (text) => text.setPlaceholder("https://your-project.supabase.co").setValue(this.settings.supabase.url).onChange(async (value) => {
        this.settings.supabase.url = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Supabase URL updated.");
      })
    );
    new import_obsidian9.Setting(containerEl).setName("Supabase API Key").setDesc("Your Supabase API key (found in your Supabase dashboard).").addText(
      (text) => text.setPlaceholder("Enter your API key").setValue(this.settings.supabase.apiKey).onChange(async (value) => {
        this.settings.supabase.apiKey = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Supabase API key updated.");
      })
    );
    containerEl.createEl("h2", { text: "OpenAI Configuration" });
    new import_obsidian9.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key for generating embeddings.").addText(
      (text) => text.setPlaceholder("Enter your API key").setValue(this.settings.openai.apiKey).onChange(async (value) => {
        this.settings.openai.apiKey = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("OpenAI API key updated.");
      })
    );
    containerEl.createEl("h2", { text: "Document Processing" });
    new import_obsidian9.Setting(containerEl).setName("Chunk Size").setDesc("Maximum size of text chunks (in characters).").addText(
      (text) => text.setValue(String(this.settings.chunking.chunkSize)).onChange(async (value) => {
        const numValue = Number(value);
        if (!isNaN(numValue) && numValue > 0) {
          this.settings.chunking.chunkSize = numValue;
          await this.plugin.saveSettings();
          new import_obsidian9.Notice("Chunk size updated.");
        }
      })
    );
    new import_obsidian9.Setting(containerEl).setName("Chunk Overlap").setDesc("Overlap between text chunks (in characters).").addText(
      (text) => text.setValue(String(this.settings.chunking.chunkOverlap)).onChange(async (value) => {
        const numValue = Number(value);
        if (!isNaN(numValue) && numValue >= 0) {
          this.settings.chunking.chunkOverlap = numValue;
          await this.plugin.saveSettings();
          new import_obsidian9.Notice("Chunk overlap updated.");
        }
      })
    );
    containerEl.createEl("h2", { text: "Exclusions" });
    const userExclusions = getUserExclusions(this.settings);
    console.log("DEBUG - User Exclusions from getUserExclusions():", userExclusions);
    const systemFolders = new Set(SYSTEM_EXCLUSIONS.folders);
    const systemFileTypes = new Set(SYSTEM_EXCLUSIONS.fileTypes);
    const systemFilePrefixes = new Set(SYSTEM_EXCLUSIONS.filePrefixes);
    const systemFiles = new Set(SYSTEM_EXCLUSIONS.files);
    console.log("DEBUG - System Exclusion Sets:", {
      folders: Array.from(systemFolders),
      fileTypes: Array.from(systemFileTypes),
      filePrefixes: Array.from(systemFilePrefixes),
      files: Array.from(systemFiles)
    });
    const filteredUserFolders = userExclusions.excludedFolders.filter((folder) => !systemFolders.has(folder));
    const filteredUserFileTypes = userExclusions.excludedFileTypes.filter((type) => !systemFileTypes.has(type));
    const filteredUserFilePrefixes = userExclusions.excludedFilePrefixes.filter((prefix) => !systemFilePrefixes.has(prefix));
    const filteredUserFiles = userExclusions.excludedFiles.filter((file) => !systemFiles.has(file));
    console.log("DEBUG - Filtered User Exclusions:", {
      folders: filteredUserFolders,
      fileTypes: filteredUserFileTypes,
      filePrefixes: filteredUserFilePrefixes,
      files: filteredUserFiles
    });
    new import_obsidian9.Setting(containerEl).setName("Excluded Folders").setDesc("Folders to exclude from syncing (comma-separated).").addText((text) => {
      const value = filteredUserFolders.join(", ");
      console.log("DEBUG - Setting excluded folders field value:", value);
      return text.setPlaceholder("folder1, folder2").setValue(value).onChange(async (value2) => {
        console.log("DEBUG - Folders onChange event value:", value2);
        const userFolders = value2.split(",").map((s) => s.trim()).filter((s) => s);
        const finalFolders = userFolders.filter((folder) => !systemFolders.has(folder));
        console.log("DEBUG - Final folders to save:", finalFolders);
        this.settings.exclusions.excludedFolders = finalFolders;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Excluded folders updated.");
      });
    });
    new import_obsidian9.Setting(containerEl).setName("Excluded File Types").setDesc("File extensions to exclude (comma-separated, include the dot).").addText((text) => {
      const value = filteredUserFileTypes.join(", ");
      return text.setPlaceholder(".type1, .type2").setValue(value).onChange(async (value2) => {
        const userFileTypes = value2.split(",").map((s) => s.trim()).filter((s) => s);
        const finalFileTypes = userFileTypes.filter((type) => !systemFileTypes.has(type));
        this.settings.exclusions.excludedFileTypes = finalFileTypes;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Excluded file types updated.");
      });
    });
    new import_obsidian9.Setting(containerEl).setName("Excluded File Prefixes").setDesc("File name prefixes to exclude (comma-separated).").addText((text) => {
      const value = filteredUserFilePrefixes.join(", ");
      console.log("DEBUG - Setting excluded file prefixes field value:", value);
      return text.setPlaceholder("temp, draft").setValue(value).onChange(async (value2) => {
        console.log("DEBUG - File prefixes onChange event value:", value2);
        const userFilePrefixes = value2.split(",").map((s) => s.trim()).filter((s) => s);
        const finalFilePrefixes = userFilePrefixes.filter((prefix) => !systemFilePrefixes.has(prefix));
        console.log("DEBUG - Final file prefixes to save:", finalFilePrefixes);
        this.settings.exclusions.excludedFilePrefixes = finalFilePrefixes;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Excluded file prefixes updated.");
      });
    });
    new import_obsidian9.Setting(containerEl).setName("Excluded Files").setDesc("Specific files to exclude from syncing (comma-separated).").addText((text) => {
      const value = filteredUserFiles.join(", ");
      console.log("DEBUG - Setting excluded files field value:", value);
      return text.setPlaceholder("file1.md, file2.md").setValue(value).onChange(async (value2) => {
        console.log("DEBUG - Files onChange event value:", value2);
        const userFiles = value2.split(",").map((s) => s.trim()).filter((s) => s);
        const finalFiles = userFiles.filter((file) => !systemFiles.has(file));
        console.log("DEBUG - Final files to save:", finalFiles);
        this.settings.exclusions.excludedFiles = finalFiles;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Excluded files updated.");
      });
    });
    const infoDiv = containerEl.createEl("div", { cls: "setting-item-description" });
    infoDiv.innerHTML = `
			<p><strong>Note:</strong> The following items are automatically excluded by the system:</p>
			<p><strong>Folders:</strong> ${SYSTEM_EXCLUSIONS.folders.join(", ")}</p>
			<p><strong>File Types:</strong> ${SYSTEM_EXCLUSIONS.fileTypes.join(", ")}</p>
			<p><strong>File Prefixes:</strong> ${SYSTEM_EXCLUSIONS.filePrefixes.join(", ")}</p>
			<p><strong>Files:</strong> ${SYSTEM_EXCLUSIONS.files.join(", ")}</p>
		`;
    containerEl.createEl("h2", { text: "Queue & Sync Settings" });
    new import_obsidian9.Setting(containerEl).setName("Auto Sync").setDesc("Automatically sync changes to the database when files are modified.").addToggle(
      (toggle) => toggle.setValue(this.settings.enableAutoSync).onChange(async (value) => {
        this.settings.enableAutoSync = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Auto sync updated.");
      })
    );
    new import_obsidian9.Setting(containerEl).setName("Sync File Path").setDesc("The path for the dedicated sync file.").addText(
      (text) => text.setValue(this.settings.sync.syncFilePath).onChange(async (value) => {
        this.settings.sync.syncFilePath = value;
        const systemFiles2 = this.settings.exclusions.systemExcludedFiles;
        const oldSyncFileIndex = systemFiles2.findIndex((f) => f === "_mindmatrixsync.md");
        const oldSyncBackupIndex = systemFiles2.findIndex((f) => f === "_mindmatrixsync.md.backup");
        if (oldSyncFileIndex !== -1)
          systemFiles2.splice(oldSyncFileIndex, 1);
        if (oldSyncBackupIndex !== -1)
          systemFiles2.splice(oldSyncBackupIndex, 1);
        systemFiles2.push(value);
        systemFiles2.push(value + ".backup");
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Sync file path updated.");
      })
    );
    containerEl.createEl("h2", { text: "Debug Settings" });
    new import_obsidian9.Setting(containerEl).setName("Enable Debug Logs").setDesc("Enable detailed debug logs in the console.").addToggle(
      (toggle) => toggle.setValue(this.settings.debug.enableDebugLogs).onChange(async (value) => {
        this.settings.debug.enableDebugLogs = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Debug logs setting updated.");
      })
    );
    new import_obsidian9.Setting(containerEl).setName("Log Level").setDesc("Select the level of detail for debug logging.").addDropdown(
      (dropdown) => dropdown.addOption("error", "Error").addOption("warn", "Warning").addOption("info", "Info").addOption("debug", "Debug").setValue(this.settings.debug.logLevel).onChange(async (value) => {
        this.settings.debug.logLevel = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Log level updated.");
      })
    );
    new import_obsidian9.Setting(containerEl).setName("Log to File").setDesc("Save debug logs to a file in your vault.").addToggle(
      (toggle) => toggle.setValue(this.settings.debug.logToFile).onChange(async (value) => {
        this.settings.debug.logToFile = value;
        await this.plugin.saveSettings();
        new import_obsidian9.Notice("Log to file setting updated.");
      })
    );
    containerEl.createEl("h2", { text: "Database Management" });
    const statusContainer = containerEl.createDiv("database-status-container");
    const statusText = statusContainer.createEl("p", { text: "Checking database status..." });
    const testButton = containerEl.createEl("button", { text: "Test Database Connection" });
    testButton.onClickEvent(async () => {
      testButton.setAttr("disabled", "true");
      statusText.setText("Testing connection...");
      try {
        const supabase = await SupabaseService.getInstance(this.plugin.settings);
        if (!supabase) {
          statusText.setText("\u274C Database connection failed: Invalid credentials");
          return;
        }
        const setupStatus = await supabase.checkDatabaseSetup();
        if (setupStatus.isComplete) {
          statusText.setText("\u2705 Database connection successful and all tables are set up correctly");
        } else {
          let message = "\u26A0\uFE0F Database setup incomplete:";
          if (setupStatus.missingTables.length > 0) {
            message += `
Missing tables: ${setupStatus.missingTables.join(", ")}`;
          }
          if (setupStatus.error) {
            message += `
Error: ${setupStatus.error}`;
          }
          statusText.setText(message);
        }
      } catch (error) {
        statusText.setText(`\u274C Database connection failed: ${error.message}`);
      } finally {
        testButton.removeAttribute("disabled");
      }
    });
    const resetButton = containerEl.createEl("button", {
      text: "Reset Database",
      cls: "mod-warning"
    });
    resetButton.onClickEvent(async () => {
      const confirmed = await new Promise((resolve) => {
        const notice = new import_obsidian9.Notice("This will delete all data in the database. Are you sure?");
        notice.setMessage("This will delete all data in the database. Are you sure?", [
          {
            text: "Yes",
            callback: () => {
              notice.hide();
              resolve(true);
            }
          },
          {
            text: "No",
            callback: () => {
              notice.hide();
              resolve(false);
            }
          }
        ]);
      });
      if (!confirmed)
        return;
      resetButton.setAttr("disabled", "true");
      statusText.setText("Resetting database...");
      try {
        const supabase = await SupabaseService.getInstance(this.plugin.settings);
        if (!supabase) {
          statusText.setText("\u274C Database reset failed: Invalid credentials");
          return;
        }
        const result = await supabase.resetDatabase();
        if (result.success) {
          statusText.setText("\u2705 Database reset successfully");
        } else {
          statusText.setText(`\u274C Database reset failed: ${result.message}`);
        }
      } catch (error) {
        statusText.setText(`\u274C Database reset failed: ${error.message}`);
      } finally {
        resetButton.removeAttribute("disabled");
      }
    });
  }
  async showResetConfirmation() {
    return new Promise((resolve) => {
      const modal = this.app.modal;
      modal.open((modal2) => {
        modal2.titleEl.setText("Reset Vault ID");
        modal2.contentEl.setText(
          "Warning: Resetting the vault ID will disconnect this vault from its existing database entries. This operation cannot be undone. Are you sure you want to continue?"
        );
        modal2.addButton((btn) => {
          btn.setButtonText("Cancel").onClick(() => {
            resolve(false);
            modal2.close();
          });
        });
        modal2.addButton((btn) => {
          btn.setButtonText("Reset").setWarning().onClick(() => {
            resolve(true);
            modal2.close();
          });
        });
      });
    });
  }
};

// services/InitialSyncManager.ts
var import_obsidian10 = require("obsidian");
var InitialSyncManager = class {
  constructor(vault, queueService, syncManager, metadataExtractor, errorHandler, notificationManager, supabaseService, options = {}) {
    this.vault = vault;
    this.queueService = queueService;
    this.syncManager = syncManager;
    this.metadataExtractor = metadataExtractor;
    this.errorHandler = errorHandler;
    this.notificationManager = notificationManager;
    this.batches = [];
    this.isRunning = false;
    this.lastProcessedIndex = 0;
    // For resuming interrupted syncs
    this.processingTimeout = null;
    this.resumeFileList = [];
    this.options = {
      batchSize: 50,
      maxConcurrentBatches: 3,
      enableAutoInitialSync: true,
      priorityRules: [],
      syncFilePath: "_mindmatrixsync.md",
      exclusions: {
        excludedFolders: [],
        excludedFileTypes: [],
        excludedFilePrefixes: [],
        excludedFiles: []
      },
      ...options
    };
    this.progress = {
      totalFiles: 0,
      processedFiles: 0,
      currentBatch: 0,
      totalBatches: 0,
      startTime: 0
    };
    this.supabaseService = supabaseService;
  }
  /**
   * Filters files based on exclusion rules.
   */
  filterExcludedFiles(files) {
    const syncFilePath = this.options.syncFilePath || "_mindmatrixsync.md";
    const exclusions = this.options.exclusions || {
      excludedFolders: [],
      excludedFileTypes: [],
      excludedFilePrefixes: [],
      excludedFiles: []
    };
    return files.filter((file) => {
      const filePath = file.path;
      const fileName = file.name;
      if (filePath === syncFilePath || filePath === "_mindmatrixsync.md" || filePath === "_mindmatrixsync.md.backup") {
        return false;
      }
      if (exclusions.excludedFiles.includes(fileName))
        return false;
      if (exclusions.excludedFolders.some((folder) => filePath.startsWith(folder.endsWith("/") ? folder : folder + "/")))
        return false;
      if (exclusions.excludedFileTypes.some((ext) => filePath.toLowerCase().endsWith(ext.toLowerCase())))
        return false;
      if (exclusions.excludedFilePrefixes.some((prefix) => fileName.startsWith(prefix)))
        return false;
      return true;
    });
  }
  /**
   * Starts the initial sync process.
   * Scans all markdown files in the vault and updates their status in the database.
   * Resumes from the last processed file if the sync is interrupted.
   */
  async startSync() {
    if (this.isRunning) {
      console.log("Initial sync already running");
      return;
    }
    try {
      this.isRunning = true;
      this.progress.startTime = Date.now();
      console.log("Starting initial sync...");
      const allFiles = this.vault.getMarkdownFiles();
      const files = this.filterExcludedFiles(allFiles);
      this.resumeFileList = await this.sortFilesByPriority(files);
      this.progress.totalFiles = this.resumeFileList.length;
      console.log(`Total files to sync: ${this.progress.totalFiles}`);
      this.batches = this.createBatches(this.resumeFileList.slice(this.lastProcessedIndex));
      this.progress.totalBatches = this.batches.length;
      console.log(`Created ${this.progress.totalBatches} batches for syncing`);
      await this.processBatches();
      new import_obsidian10.Notice("Initial sync completed successfully");
      console.log("Initial sync completed");
      this.lastProcessedIndex = 0;
    } catch (error) {
      this.errorHandler.handleError(error, { context: "InitialSyncManager.startSync" });
      new import_obsidian10.Notice("Initial sync failed. Check console for details.");
    } finally {
      this.isRunning = false;
    }
  }
  /**
   * Sort files by priority based on rules.
   * Files matching higher priority rules are sorted to the front.
   */
  async sortFilesByPriority(files) {
    return files.sort((a, b) => {
      const priorityA = this.getFilePriority(a.path);
      const priorityB = this.getFilePriority(b.path);
      console.log(`Priority for ${a.path}: ${priorityA}, ${b.path}: ${priorityB}`);
      return priorityB - priorityA;
    });
  }
  /**
   * Determine the processing priority for a file.
   * Returns the highest matching rule priority or defaults to 1.
   */
  getFilePriority(path) {
    for (const rule of this.options.priorityRules) {
      if (path.includes(rule.pattern)) {
        return rule.priority;
      }
    }
    return 1;
  }
  /**
   * Create batches of files for processing.
   */
  createBatches(files) {
    const syncFilePath = this.options.syncFilePath || "_mindmatrixsync.md";
    files = files.filter((file) => file.path !== syncFilePath && file.path !== "_mindmatrixsync.md" && file.path !== "_mindmatrixsync.md.backup");
    const batches = [];
    for (let i = 0; i < files.length; i += this.options.batchSize) {
      const batchFiles = files.slice(i, i + this.options.batchSize);
      batches.push({
        id: `batch-${Math.floor(i / this.options.batchSize)}`,
        files: batchFiles,
        status: "pending",
        progress: 0
      });
    }
    return batches;
  }
  /**
   * Process batches concurrently with a limit.
   * Updates resume progress in case of interruption.
   */
  async processBatches() {
    const activeBatches = /* @__PURE__ */ new Set();
    for (const batch of this.batches) {
      while (activeBatches.size >= this.options.maxConcurrentBatches) {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
      activeBatches.add(batch.id);
      this.processBatch(batch).then(() => {
        activeBatches.delete(batch.id);
        this.lastProcessedIndex += batch.files.length;
        console.log(`Completed ${batch.id}, resuming at index ${this.lastProcessedIndex}`);
      }).catch((error) => {
        this.errorHandler.handleError(error, { context: "InitialSyncManager.processBatch", metadata: { batchId: batch.id } });
        activeBatches.delete(batch.id);
      });
    }
    while (activeBatches.size > 0) {
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }
  /**
   * Process a single batch of files.
   */
  async processBatch(batch) {
    try {
      batch.status = "processing";
      batch.startTime = Date.now();
      console.log(`Processing ${batch.id} with ${batch.files.length} files`);
      for (const file of batch.files) {
        try {
          await this.processFile(file);
          this.progress.processedFiles++;
          batch.progress = this.progress.processedFiles / this.progress.totalFiles * 100;
          this.updateProgressNotification();
        } catch (error) {
          this.errorHandler.handleError(error, { context: "InitialSyncManager.processFile", metadata: { filePath: file.path } });
        }
      }
      batch.status = "completed";
      batch.endTime = Date.now();
      console.log(`Batch ${batch.id} completed in ${batch.endTime - (batch.startTime || 0)} ms`);
    } catch (error) {
      batch.status = "failed";
      throw error;
    }
  }
  /**
   * Process a single file.
   * Extracts metadata, calculates file hash, and updates its status.
   */
  async processFile(file) {
    try {
      const syncFilePath = this.options.syncFilePath || "_mindmatrixsync.md";
      if (file.path === syncFilePath || file.path === "_mindmatrixsync.md" || file.path === "_mindmatrixsync.md.backup") {
        return;
      }
      const metadata = await this.metadataExtractor.extractMetadata(file);
      const fileHash = await this.calculateFileHash(file);
      if (this.supabaseService) {
        await this.supabaseService.updateFileVectorizationStatus(metadata);
      } else {
        await this.syncManager.updateSyncStatus(file.path, "PENDING", {
          lastModified: file.stat.mtime,
          hash: fileHash
        });
      }
      await new Promise((resolve, reject) => {
        this.queueService.addTask({
          id: file.path,
          type: "CREATE",
          priority: this.getFilePriority(file.path),
          maxRetries: 3,
          retryCount: 0,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          status: "PENDING",
          metadata,
          data: {}
        }).then(async () => {
          if (this.supabaseService) {
            await this.supabaseService.updateFileVectorizationStatus(metadata);
          } else {
            await this.syncManager.updateSyncStatus(file.path, "OK", {
              lastModified: file.stat.mtime,
              hash: fileHash
            });
          }
          resolve();
        }).catch(reject);
      });
      console.log(`Processed file: ${file.path}`);
    } catch (error) {
      this.errorHandler.handleError(error, { context: "InitialSyncManager.processFile", metadata: { filePath: file.path } });
      throw error;
    }
  }
  /**
   * Calculate SHA-256 hash of a file's content.
   */
  async calculateFileHash(file) {
    try {
      const content = await this.vault.read(file);
      const encoder = new TextEncoder();
      const data = encoder.encode(content);
      const buffer = await crypto.subtle.digest("SHA-256", data);
      return Array.from(new Uint8Array(buffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
    } catch (error) {
      this.errorHandler.handleError(error, { context: "InitialSyncManager.calculateFileHash", metadata: { filePath: file.path } });
      return "";
    }
  }
  /**
   * Update progress notifications.
   */
  updateProgressNotification() {
    const progressPercentage = this.progress.processedFiles / this.progress.totalFiles * 100;
    this.notificationManager.updateProgress({
      taskId: "initial-sync",
      progress: progressPercentage,
      currentStep: `Processing files (${this.progress.processedFiles}/${this.progress.totalFiles})`,
      totalSteps: this.progress.totalBatches,
      currentStepNumber: this.progress.currentBatch + 1,
      estimatedTimeRemaining: this.calculateEstimatedTimeRemaining(),
      details: {
        processedFiles: this.progress.processedFiles,
        totalFiles: this.progress.totalFiles
      }
    });
  }
  /**
   * Calculate estimated time remaining based on progress.
   */
  calculateEstimatedTimeRemaining() {
    const elapsed = Date.now() - this.progress.startTime;
    const filesPerMs = this.progress.processedFiles / elapsed;
    const remainingFiles = this.progress.totalFiles - this.progress.processedFiles;
    return filesPerMs > 0 ? remainingFiles / filesPerMs : 0;
  }
  /**
   * Stops the initial sync process.
   */
  stop() {
    this.isRunning = false;
    if (this.processingTimeout) {
      clearTimeout(this.processingTimeout);
      this.processingTimeout = null;
    }
    new import_obsidian10.Notice("Initial sync stopped");
  }
  /**
   * Get current sync progress.
   */
  getProgress() {
    return { ...this.progress };
  }
  /**
   * Update sync options.
   */
  updateOptions(options) {
    Object.assign(this.options, options);
  }
};

// services/StatusManager.ts
var import_obsidian11 = require("obsidian");
var StatusManager = class {
  constructor(statusBarItem) {
    this.statusBarItem = statusBarItem;
    this.currentStatus = "initializing" /* INITIALIZING */;
    this.statusDetails = {
      message: "Initializing plugin...",
      timestamp: Date.now(),
      connectivityStatus: "unknown"
    };
    this.subscribers = /* @__PURE__ */ new Set();
    this.updateStatusBar();
  }
  /**
   * Update the current status with new details.
   */
  setStatus(status, details = {}) {
    const oldStatus = this.currentStatus;
    this.currentStatus = status;
    this.statusDetails = {
      ...this.statusDetails,
      ...details,
      timestamp: Date.now()
    };
    this.updateStatusBar();
    if (oldStatus !== status) {
      this.notifySubscribers();
    }
    if (status === "error" /* ERROR */ && details.message) {
      new import_obsidian11.Notice(`Mind Matrix: ${details.message}`);
    }
  }
  /**
   * Get the current status and details.
   */
  getStatus() {
    return { status: this.currentStatus, details: { ...this.statusDetails } };
  }
  /**
   * Subscribe to status changes.
   */
  subscribe(callback) {
    this.subscribers.add(callback);
    return () => {
      this.subscribers.delete(callback);
    };
  }
  /**
   * Update the status bar UI.
   */
  updateStatusBar() {
    this.statusBarItem.innerHTML = "";
    const icon = this.createStatusIcon();
    this.statusBarItem.appendChild(icon);
    const detailsText = document.createElement("span");
    detailsText.addClass("mind-matrix-status-details");
    let displayText = this.statusDetails.message;
    if (this.statusDetails.operation) {
      displayText += ` [${this.statusDetails.operation}]`;
    }
    if (this.statusDetails.step) {
      displayText += ` - ${this.statusDetails.step}`;
    }
    if (this.statusDetails.progress !== void 0) {
      displayText += ` (${this.statusDetails.progress}%)`;
    }
    detailsText.textContent = displayText;
    this.statusBarItem.appendChild(detailsText);
    let tooltip = this.statusDetails.message;
    if (this.statusDetails.connectivityStatus) {
      tooltip += ` | Connectivity: ${this.statusDetails.connectivityStatus}`;
    }
    if (this.statusDetails.lastDatabaseCheck) {
      tooltip += ` | Last DB Check: ${new Date(this.statusDetails.lastDatabaseCheck).toLocaleTimeString()}`;
    }
    if (this.statusDetails.queueSize !== void 0) {
      tooltip += ` | Queue: ${this.statusDetails.queueSize}`;
    }
    if (this.statusDetails.pendingChanges !== void 0) {
      tooltip += ` | Pending: ${this.statusDetails.pendingChanges}`;
    }
    this.statusBarItem.setAttribute("aria-label", tooltip);
    this.statusBarItem.onclick = () => {
      new import_obsidian11.Notice(tooltip);
    };
  }
  /**
   * Create status icon element based on current status.
   */
  createStatusIcon() {
    const icon = document.createElement("span");
    icon.addClass("mind-matrix-status-icon");
    switch (this.currentStatus) {
      case "ready" /* READY */:
      case "completed" /* COMPLETED */:
        icon.addClass("is-ready");
        icon.innerHTML = "\u25CF";
        break;
      case "error" /* ERROR */:
        icon.addClass("is-error");
        icon.innerHTML = "\u26A0";
        break;
      case "waiting_sync" /* WAITING_FOR_SYNC */:
      case "checking_file" /* CHECKING_FILE */:
      case "queuing" /* QUEUING */:
      case "processing_queue" /* PROCESSING_QUEUE */:
      case "pending" /* PENDING */:
        icon.addClass("is-working");
        icon.innerHTML = "\u21BB";
        break;
      case "in_progress" /* IN_PROGRESS */:
        icon.addClass("is-in-progress");
        icon.innerHTML = "\u25CB";
        break;
      default:
        icon.addClass("is-initializing");
        icon.innerHTML = "\u25CB";
    }
    return icon;
  }
  /**
   * Notify all subscribers of a status change.
   */
  notifySubscribers() {
    this.subscribers.forEach((callback) => {
      try {
        callback(this.currentStatus, this.statusDetails);
      } catch (error) {
        console.error("Error in status change subscriber:", error);
      }
    });
  }
  /**
   * Check if the plugin is currently in a specific status.
   */
  isInStatus(status) {
    return this.currentStatus === status;
  }
  /**
   * Update progress for the current task with detailed step info.
   * @param progress Percentage of completion.
   * @param currentStep Description of the current step.
   * @param operation Optional operation name.
   * @param additionalDetails Optional extra details.
   */
  updateProgress(progress, currentStep, operation, additionalDetails) {
    this.statusDetails.progress = progress;
    this.statusDetails.step = currentStep;
    if (operation) {
      this.statusDetails.operation = operation;
    }
    if (additionalDetails) {
      this.statusDetails = { ...this.statusDetails, ...additionalDetails };
    }
    this.updateStatusBar();
  }
};

// services/SyncDetectionManager.ts
var SyncDetectionManager = class {
  // 5 seconds
  constructor(plugin, statusManager, onQuietPeriodReached) {
    this.plugin = plugin;
    this.statusManager = statusManager;
    this.onQuietPeriodReached = onQuietPeriodReached;
    this.lastSyncActivity = 0;
    this.syncCheckInterval = null;
    this.quietPeriodReached = false;
    this.isWaitingForQuietPeriod = false;
    this.QUIET_PERIOD_MS = 5e3;
  }
  /**
   * Start monitoring for sync activity
   */
  startMonitoring() {
    this.plugin.registerEvent(
      this.plugin.app.vault.on("modify", () => this.recordSyncActivity())
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("create", () => this.recordSyncActivity())
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("delete", () => this.recordSyncActivity())
    );
    this.startQuietPeriodCheck();
  }
  /**
   * Record sync activity and reset quiet period
   */
  recordSyncActivity() {
    this.lastSyncActivity = Date.now();
    this.quietPeriodReached = false;
    if (this.isWaitingForQuietPeriod) {
      this.statusManager.setStatus("waiting_sync" /* WAITING_FOR_SYNC */, {
        message: "Waiting for Obsidian sync to settle..."
      });
    }
  }
  /**
   * Start checking for quiet period
   */
  startQuietPeriodCheck() {
    if (this.syncCheckInterval) {
      clearInterval(this.syncCheckInterval);
    }
    this.isWaitingForQuietPeriod = true;
    this.syncCheckInterval = setInterval(() => {
      const timeSinceLastSync = Date.now() - this.lastSyncActivity;
      if (timeSinceLastSync >= this.QUIET_PERIOD_MS && !this.quietPeriodReached) {
        this.quietPeriodReached = true;
        this.isWaitingForQuietPeriod = false;
        if (this.syncCheckInterval) {
          clearInterval(this.syncCheckInterval);
          this.syncCheckInterval = null;
        }
        this.onQuietPeriodReached();
      }
    }, 1e3);
  }
  /**
   * Stop monitoring for sync activity
   */
  stopMonitoring() {
    if (this.syncCheckInterval) {
      clearInterval(this.syncCheckInterval);
      this.syncCheckInterval = null;
    }
    this.isWaitingForQuietPeriod = false;
  }
  /**
   * Check if currently waiting for quiet period
   */
  isWaiting() {
    return this.isWaitingForQuietPeriod;
  }
  /**
   * Get time since last sync activity
   */
  getTimeSinceLastSync() {
    return Date.now() - this.lastSyncActivity;
  }
};

// main.ts
var MindMatrixPlugin = class extends import_obsidian12.Plugin {
  constructor() {
    super(...arguments);
    this.supabaseService = null;
    this.openAIService = null;
    this.queueService = null;
    this.fileTracker = null;
    this.errorHandler = null;
    this.notificationManager = null;
    this.isInitializing = false;
    this.syncManager = null;
    this.syncCheckInterval = null;
    this.initializationTimeout = null;
    this.syncCheckAttempts = 0;
    this.initialSyncManager = null;
    this.metadataExtractor = null;
    this.statusManager = null;
    this.syncDetectionManager = null;
  }
  async onload() {
    var _a2;
    console.log("Loading Mind Matrix Plugin...");
    try {
      this.statusManager = new StatusManager(this.addStatusBarItem());
      this.statusManager.setStatus("initializing" /* INITIALIZING */, {
        message: "Loading Mind Matrix Plugin..."
      });
      await this.loadSettings();
      await this.initializeCoreServices();
      await this.initializeVaultIfNeeded();
      this.addSettingTab(new MindMatrixSettingsTab(this.app, this));
      if (isVaultInitialized2(this.settings)) {
        this.statusManager.setStatus("waiting_sync" /* WAITING_FOR_SYNC */, {
          message: "Waiting for Obsidian sync to settle..."
        });
        this.syncDetectionManager = new SyncDetectionManager(
          this,
          this.statusManager,
          this.onSyncQuietPeriodReached.bind(this)
        );
        this.syncDetectionManager.startMonitoring();
      } else {
        await this.completeInitialization();
      }
    } catch (error) {
      console.error("Failed to initialize Mind Matrix Plugin:", error);
      (_a2 = this.statusManager) == null ? void 0 : _a2.setStatus("error" /* ERROR */, {
        message: "Failed to initialize plugin. Check console for details.",
        error
      });
    }
  }
  async onSyncQuietPeriodReached() {
    var _a2, _b, _c;
    try {
      (_a2 = this.syncDetectionManager) == null ? void 0 : _a2.stopMonitoring();
      (_b = this.statusManager) == null ? void 0 : _b.setStatus("checking_file" /* CHECKING_FILE */, {
        message: "Initializing sync manager with updated sync file format..."
      });
      await this.initializeSyncManager();
      await this.startSyncProcess();
      await this.completeInitialization();
    } catch (error) {
      console.error("Error during quiet period initialization:", error);
      (_c = this.statusManager) == null ? void 0 : _c.setStatus("error" /* ERROR */, {
        message: "Failed to initialize after sync quiet period",
        error
      });
    }
  }
  async completeInitialization() {
    var _a2, _b;
    try {
      this.registerEventHandlers();
      this.addCommands();
      (_a2 = this.statusManager) == null ? void 0 : _a2.setStatus("ready" /* READY */, {
        message: "Mind Matrix is ready"
      });
    } catch (error) {
      console.error("Error completing initialization:", error);
      (_b = this.statusManager) == null ? void 0 : _b.setStatus("error" /* ERROR */, {
        message: "Failed to complete initialization",
        error
      });
    }
  }
  async onunload() {
    var _a2, _b, _c, _d;
    console.log("Unloading Mind Matrix Plugin...");
    (_a2 = this.syncDetectionManager) == null ? void 0 : _a2.stopMonitoring();
    if (this.initializationTimeout)
      clearTimeout(this.initializationTimeout);
    if (this.syncCheckInterval)
      clearInterval(this.syncCheckInterval);
    (_b = this.queueService) == null ? void 0 : _b.stop();
    (_c = this.notificationManager) == null ? void 0 : _c.clear();
    (_d = this.initialSyncManager) == null ? void 0 : _d.stop();
  }
  async startSyncProcess() {
    var _a2, _b, _c, _d, _e, _f;
    if (!this.syncManager)
      throw new Error("Sync manager not initialized");
    try {
      (_a2 = this.statusManager) == null ? void 0 : _a2.setStatus("checking_file" /* CHECKING_FILE */, {
        message: "Checking sync file status with new structure..."
      });
      const syncStatus = await this.syncManager.validateSyncState();
      if (!syncStatus.isValid) {
        if (this.settings.sync.requireSync) {
          (_b = this.statusManager) == null ? void 0 : _b.setStatus("error" /* ERROR */, {
            message: `Sync validation failed: ${syncStatus.error}`
          });
          throw new Error(`Sync validation failed: ${syncStatus.error}`);
        } else {
          console.warn(`Sync validation warning: ${syncStatus.error}`);
          new import_obsidian12.Notice(`Sync warning: ${syncStatus.error}`);
        }
      }
      (_c = this.statusManager) == null ? void 0 : _c.setStatus("initializing" /* INITIALIZING */, {
        message: "Initializing services..."
      });
      await this.initializeServices();
      this.startPeriodicSyncChecks();
      if (this.settings.initialSync.enableAutoInitialSync && this.initialSyncManager) {
        (_d = this.statusManager) == null ? void 0 : _d.setStatus("initializing" /* INITIALIZING */, {
          message: "Starting initial vault sync..."
        });
        await this.initialSyncManager.startSync();
      }
      (_e = this.statusManager) == null ? void 0 : _e.setStatus("ready" /* READY */, {
        message: "Sync process completed"
      });
    } catch (error) {
      if (this.settings.sync.requireSync) {
        (_f = this.statusManager) == null ? void 0 : _f.setStatus("error" /* ERROR */, {
          message: "Sync process failed",
          error
        });
        throw error;
      } else {
        console.error("Sync process error:", error);
        new import_obsidian12.Notice("Sync process error. Continuing with limited functionality.");
        await this.initializeServices();
      }
    }
  }
  async initializeSyncManager() {
    if (!this.errorHandler)
      throw new Error("Error handler must be initialized before sync manager");
    if (!this.settings.vaultId) {
      this.settings.vaultId = generateVaultId();
      await this.saveSettings();
    }
    try {
      this.syncManager = new SyncFileManager(
        this.app.vault,
        this.errorHandler,
        this.settings.sync.syncFilePath,
        this.settings.sync.backupInterval,
        this.settings.vaultId,
        this.settings.sync.deviceId,
        this.settings.sync.deviceName,
        this.manifest.version
      );
      await this.syncManager.initialize();
      console.log("Sync manager initialized successfully with new sync file format");
    } catch (error) {
      console.error("Failed to initialize sync manager:", error);
      if (this.settings.enableNotifications)
        new import_obsidian12.Notice("Failed to initialize sync system. Some features may be unavailable.");
      throw error;
    }
  }
  async initializeCoreServices() {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    (_a2 = this.statusManager) == null ? void 0 : _a2.setStatus("initializing" /* INITIALIZING */, { message: "Initializing core services..." });
    this.errorHandler = new ErrorHandler((_c = (_b = this.settings) == null ? void 0 : _b.debug) != null ? _c : DEFAULT_SETTINGS.debug, this.app.vault.adapter.getBasePath());
    this.notificationManager = new NotificationManager(this.addStatusBarItem(), (_e = (_d = this.settings) == null ? void 0 : _d.enableNotifications) != null ? _e : true, (_g = (_f = this.settings) == null ? void 0 : _f.enableProgressBar) != null ? _g : true);
    (_h = this.statusManager) == null ? void 0 : _h.setStatus("initializing" /* INITIALIZING */, { message: "Core services initialized" });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (!this.settings.exclusions)
      this.settings.exclusions = { ...DEFAULT_SETTINGS.exclusions };
    if (!this.settings.exclusions.excludedFolders)
      this.settings.exclusions.excludedFolders = [];
    if (!this.settings.exclusions.excludedFileTypes)
      this.settings.exclusions.excludedFileTypes = [];
    if (!this.settings.exclusions.excludedFilePrefixes)
      this.settings.exclusions.excludedFilePrefixes = [];
    if (!this.settings.exclusions.excludedFiles)
      this.settings.exclusions.excludedFiles = [];
    if (!this.settings.exclusions.systemExcludedFolders)
      this.settings.exclusions.systemExcludedFolders = [...SYSTEM_EXCLUSIONS.folders];
    if (!this.settings.exclusions.systemExcludedFileTypes)
      this.settings.exclusions.systemExcludedFileTypes = [...SYSTEM_EXCLUSIONS.fileTypes];
    if (!this.settings.exclusions.systemExcludedFilePrefixes)
      this.settings.exclusions.systemExcludedFilePrefixes = [...SYSTEM_EXCLUSIONS.filePrefixes];
    if (!this.settings.exclusions.systemExcludedFiles)
      this.settings.exclusions.systemExcludedFiles = [...SYSTEM_EXCLUSIONS.files];
  }
  async saveSettings() {
    var _a2, _b;
    await this.saveData(this.settings);
    (_a2 = this.notificationManager) == null ? void 0 : _a2.updateSettings(this.settings.enableNotifications, this.settings.enableProgressBar);
    (_b = this.errorHandler) == null ? void 0 : _b.updateSettings(this.settings.debug);
    if (isVaultInitialized2(this.settings))
      await this.initializeServices();
  }
  startPeriodicSyncChecks() {
    if (this.syncCheckInterval)
      clearInterval(this.syncCheckInterval);
    this.syncCheckInterval = setInterval(async () => {
      await this.performSyncCheck();
    }, this.settings.sync.checkInterval);
  }
  async performSyncCheck() {
    var _a2;
    if (!this.syncManager)
      return;
    try {
      const syncStatus = await this.syncManager.validateSyncState();
      if (!syncStatus.isValid) {
        console.warn(`Sync check failed: ${syncStatus.error}`);
        if (this.settings.enableNotifications)
          new import_obsidian12.Notice(`Sync issue detected: ${syncStatus.error}`);
        const recovered = await this.syncManager.attemptRecovery();
        if (!recovered && this.settings.sync.requireSync)
          await this.restartServices();
      }
      await this.syncManager.updateLastSync();
    } catch (error) {
      (_a2 = this.errorHandler) == null ? void 0 : _a2.handleError(error, { context: "performSyncCheck", metadata: { timestamp: Date.now() } });
    }
  }
  async restartServices() {
    var _a2;
    (_a2 = this.queueService) == null ? void 0 : _a2.stop();
    if (this.syncCheckInterval)
      clearInterval(this.syncCheckInterval);
    try {
      await this.initializeSyncManager();
      await this.startSyncProcess();
    } catch (error) {
      console.error("Failed to restart services:", error);
      if (this.settings.enableNotifications)
        new import_obsidian12.Notice("Failed to restart services after sync error");
    }
  }
  async initializeVaultIfNeeded() {
    if (this.isInitializing)
      return;
    this.isInitializing = true;
    try {
      if (!isVaultInitialized2(this.settings)) {
        this.settings.vaultId = generateVaultId();
        this.settings.lastKnownVaultName = this.app.vault.getName();
        await this.saveSettings();
        if (this.settings.enableNotifications)
          new import_obsidian12.Notice("Vault initialized with new ID");
      } else if (this.settings.lastKnownVaultName !== this.app.vault.getName()) {
        this.settings.lastKnownVaultName = this.app.vault.getName();
        await this.saveSettings();
      }
    } finally {
      this.isInitializing = false;
    }
  }
  async initializeServices() {
    console.log("Initializing services...", { hasVault: !!this.app.vault, hasErrorHandler: !!this.errorHandler });
    if (!this.errorHandler)
      throw new Error("Core services not initialized");
    try {
      this.fileTracker = new FileTracker(this.app.vault, this.errorHandler, this.settings.sync.syncFilePath);
      await this.fileTracker.initialize();
      console.log("FileTracker initialized.");
      try {
        this.supabaseService = await SupabaseService.getInstance(this.settings);
        if (!this.supabaseService) {
          new import_obsidian12.Notice("Supabase service not initialized. Please configure your API settings.");
          console.error("Supabase service initialization failed: Missing configuration.");
          return;
        }
        console.log("Supabase service initialized.");
      } catch (error) {
        console.error("Supabase initialization error:", error);
        new import_obsidian12.Notice(`Failed to initialize Supabase service: ${error.message}`);
        return;
      }
      this.openAIService = new OpenAIService(this.settings.openai, this.errorHandler);
      console.log("OpenAI service initialized.");
      if (!this.app.vault)
        throw new Error("Vault is not available");
      if (this.notificationManager && this.supabaseService && this.openAIService) {
        try {
          this.queueService = new QueueService(
            this.settings.queue.maxConcurrent,
            this.settings.queue.retryAttempts,
            this.supabaseService,
            this.openAIService,
            this.errorHandler,
            this.notificationManager,
            this.app.vault,
            this.settings.chunking
          );
          this.queueService.start();
          console.log("Queue service initialized and started.");
        } catch (error) {
          console.error("Failed to initialize QueueService:", error);
          new import_obsidian12.Notice(`Failed to initialize queue service: ${error.message}`);
          throw error;
        }
      } else {
        throw new Error("Required services not available for QueueService initialization");
      }
      this.metadataExtractor = new MetadataExtractor();
      console.log("MetadataExtractor initialized.");
      if (this.queueService && this.syncManager && this.metadataExtractor) {
        const initialSyncOptions = {
          ...this.settings.initialSync,
          syncFilePath: this.settings.sync.syncFilePath,
          exclusions: getAllExclusions2(this.settings)
        };
        this.initialSyncManager = new InitialSyncManager(
          this.app.vault,
          this.queueService,
          this.syncManager,
          this.metadataExtractor,
          this.errorHandler,
          this.notificationManager,
          this.supabaseService,
          initialSyncOptions
        );
        console.log("InitialSyncManager initialized.");
      }
    } catch (error) {
      console.error("Failed to initialize services:", error);
      throw error;
    }
  }
  checkRequiredConfigurations() {
    if (!this.settings.openai.apiKey) {
      new import_obsidian12.Notice("OpenAI API key is missing. AI features are disabled. Configure it in the settings.");
    }
    if (!this.settings.supabase.url || !this.settings.supabase.apiKey) {
      new import_obsidian12.Notice("Supabase configuration is incomplete. Database features are disabled. Configure it in the settings.");
    }
  }
  registerEventHandlers() {
    this.registerEvent(
      this.app.vault.on("create", async (file) => {
        var _a2;
        if (!(file instanceof import_obsidian12.TFile))
          return;
        if (!await this.ensureSyncFileExists()) {
          new import_obsidian12.Notice("Failed to create sync file. Plugin functionality limited.");
          return;
        }
        if (!this.shouldProcessFile(file))
          return;
        console.log(`File created: ${file.path}`);
        await ((_a2 = this.fileTracker) == null ? void 0 : _a2.handleCreate(file));
        await this.queueFileProcessing(file, "CREATE");
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", async (file) => {
        var _a2;
        if (!(file instanceof import_obsidian12.TFile))
          return;
        if (!await this.ensureSyncFileExists()) {
          new import_obsidian12.Notice("Failed to create sync file. Plugin functionality limited.");
          return;
        }
        if (!this.shouldProcessFile(file))
          return;
        console.log(`File modified: ${file.path}`);
        await ((_a2 = this.fileTracker) == null ? void 0 : _a2.handleModify(file));
        await this.queueFileProcessing(file, "UPDATE");
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", async (file) => {
        var _a2;
        if (!(file instanceof import_obsidian12.TFile))
          return;
        if (file.path === this.settings.sync.syncFilePath) {
          console.log("Sync file was deleted, will recreate on next operation");
          return;
        }
        if (!await this.ensureSyncFileExists()) {
          new import_obsidian12.Notice("Failed to create sync file. Plugin functionality limited.");
          return;
        }
        if (!this.shouldProcessFile(file))
          return;
        console.log(`File deleted: ${file.path}`);
        await ((_a2 = this.fileTracker) == null ? void 0 : _a2.handleDelete(file));
        await this.queueFileProcessing(file, "DELETE");
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", async (file, oldPath) => {
        var _a2;
        if (!(file instanceof import_obsidian12.TFile))
          return;
        if (!await this.ensureSyncFileExists()) {
          new import_obsidian12.Notice("Failed to create sync file. Plugin functionality limited.");
          return;
        }
        if (!this.shouldProcessFile(file))
          return;
        console.log(`File renamed from ${oldPath} to ${file.path}`);
        await ((_a2 = this.fileTracker) == null ? void 0 : _a2.handleRename(file, oldPath));
        await this.handleFileRename(file, oldPath);
      })
    );
  }
  shouldProcessFile(file) {
    if (!this.queueService || !isVaultInitialized2(this.settings))
      return false;
    if (!this.settings.enableAutoSync)
      return false;
    const allExclusions = getAllExclusions2(this.settings);
    const filePath = file.path;
    const fileName = file.name;
    if (filePath === this.settings.sync.syncFilePath || filePath === this.settings.sync.syncFilePath + ".backup") {
      console.log(`Skipping sync file: ${filePath}`);
      return false;
    }
    if (Array.isArray(allExclusions.excludedFiles) && allExclusions.excludedFiles.includes(fileName)) {
      console.log("Skipping excluded file:", fileName);
      return false;
    }
    if (Array.isArray(allExclusions.excludedFolders)) {
      const isExcludedFolder = allExclusions.excludedFolders.some((folder) => {
        const normalizedFolder = folder.endsWith("/") ? folder : folder + "/";
        return filePath.startsWith(normalizedFolder);
      });
      if (isExcludedFolder) {
        console.log("Skipping file in excluded folder:", filePath);
        return false;
      }
    }
    if (Array.isArray(allExclusions.excludedFileTypes)) {
      const isExcludedType = allExclusions.excludedFileTypes.some((ext) => filePath.toLowerCase().endsWith(ext.toLowerCase()));
      if (isExcludedType) {
        console.log("Skipping excluded file type:", filePath);
        return false;
      }
    }
    if (Array.isArray(allExclusions.excludedFilePrefixes)) {
      const isExcludedPrefix = allExclusions.excludedFilePrefixes.some((prefix) => fileName.startsWith(prefix));
      if (isExcludedPrefix) {
        console.log("Skipping file with excluded prefix:", fileName);
        return false;
      }
    }
    return true;
  }
  async ensureSyncFileExists() {
    if (!this.syncManager) {
      console.error("Sync manager not initialized");
      return false;
    }
    try {
      const syncFile = this.app.vault.getAbstractFileByPath(this.settings.sync.syncFilePath);
      if (!syncFile) {
        console.log("Sync file missing, recreating...");
        await this.syncManager.initialize();
        new import_obsidian12.Notice("Recreated sync file");
        return true;
      }
      return true;
    } catch (error) {
      console.error("Error ensuring sync file exists:", error);
      return false;
    }
  }
  async queueFileProcessing(file, type) {
    var _a2;
    try {
      if (!this.queueService || !this.fileTracker) {
        console.error("Required services not initialized:", { queueService: !!this.queueService, fileTracker: !!this.fileTracker });
        return;
      }
      console.log("Queueing file processing:", { fileName: file.name, type, path: file.path });
      const metadata = await this.fileTracker.createFileMetadata(file);
      console.log("Created metadata:", metadata);
      const task = {
        id: file.path,
        type,
        priority: type === "DELETE" ? 2 : 1,
        maxRetries: this.settings.queue.retryAttempts,
        retryCount: 0,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        status: "PENDING",
        metadata,
        data: {}
      };
      console.log("Created task:", task);
      await this.queueService.addTask(task);
      console.log("Task added to queue");
      if (this.settings.enableNotifications) {
        const action = type.toLowerCase();
        new import_obsidian12.Notice(`Queued ${action} for processing: ${file.name}`);
      }
    } catch (error) {
      console.error("Error in queueFileProcessing:", error);
      (_a2 = this.errorHandler) == null ? void 0 : _a2.handleError(error, { context: "queueFileProcessing", metadata: { filePath: file.path, type } });
      if (this.settings.enableNotifications) {
        new import_obsidian12.Notice(`Failed to queue ${file.name} for processing`);
      }
    }
  }
  async handleFileRename(file, oldPath) {
    var _a2;
    try {
      if (!this.supabaseService)
        return;
      await this.supabaseService.updateFilePath(oldPath, file.path);
      const chunks = await this.supabaseService.getDocumentChunks(oldPath);
      if (chunks.length > 0) {
        const updatedChunks = chunks.map((chunk) => ({
          ...chunk,
          metadata: {
            ...chunk.metadata,
            obsidianId: file.path,
            path: file.path
          }
        }));
        await this.supabaseService.deleteDocumentChunks(oldPath);
        await this.supabaseService.upsertChunks(updatedChunks);
      }
      if (this.settings.enableNotifications) {
        new import_obsidian12.Notice(`Updated database entries for renamed file: ${file.name}`);
      }
    } catch (error) {
      (_a2 = this.errorHandler) == null ? void 0 : _a2.handleError(error, { context: "handleFileRename", metadata: { filePath: file.path, oldPath } });
      if (this.settings.enableNotifications) {
        new import_obsidian12.Notice(`Failed to update database for renamed file: ${file.name}`);
      }
    }
  }
  addCommands() {
    this.addCommand({
      id: "force-sync-current-file",
      name: "Force sync current file",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          if (!checking) {
            this.queueFileProcessing(file, "UPDATE");
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "force-sync-all-files",
      name: "Force sync all files",
      callback: async () => {
        const files = this.app.vault.getMarkdownFiles();
        for (const file of files) {
          if (this.shouldProcessFile(file)) {
            await this.queueFileProcessing(file, "UPDATE");
          }
        }
      }
    });
    this.addCommand({
      id: "clear-sync-queue",
      name: "Clear sync queue",
      callback: () => {
        var _a2;
        (_a2 = this.queueService) == null ? void 0 : _a2.clear();
        if (this.settings.enableNotifications) {
          new import_obsidian12.Notice("Sync queue cleared");
        }
      }
    });
    this.addCommand({
      id: "reset-file-tracker",
      name: "Reset file tracker cache",
      callback: async () => {
        var _a2, _b;
        (_a2 = this.fileTracker) == null ? void 0 : _a2.clearQueue();
        await ((_b = this.fileTracker) == null ? void 0 : _b.initialize());
        if (this.settings.enableNotifications) {
          new import_obsidian12.Notice("File tracker cache reset");
        }
      }
    });
    this.addCommand({
      id: "start-initial-sync",
      name: "Start initial vault sync",
      callback: async () => {
        if (this.initialSyncManager) {
          await this.initialSyncManager.startSync();
        } else {
          new import_obsidian12.Notice("Initial sync manager not initialized");
        }
      }
    });
    this.addCommand({
      id: "stop-initial-sync",
      name: "Stop initial vault sync",
      callback: () => {
        var _a2;
        (_a2 = this.initialSyncManager) == null ? void 0 : _a2.stop();
        new import_obsidian12.Notice("Initial sync stopped");
      }
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9ub2RlLWZldGNoL2Jyb3dzZXIuanMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL1Bvc3RncmVzdEVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RCdWlsZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvc3JjL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9zcmMvUG9zdGdyZXN0Q2xpZW50LnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL3NyYy9pbmRleC50cyIsICJub2RlX21vZHVsZXMvd3MvYnJvd3Nlci5qcyIsICJtYWluLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL3NyYy9oZWxwZXIudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9mdW5jdGlvbnMtanMvc3JjL3R5cGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL3NyYy9GdW5jdGlvbnNDbGllbnQudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9lc20vd3JhcHBlci5tanMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvc2VyaWFsaXplci50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvdGltZXIudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9zcmMvbGliL3RyYW5zZm9ybWVycy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9saWIvcHVzaC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9SZWFsdGltZVByZXNlbmNlLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvc3JjL1JlYWx0aW1lQ2hhbm5lbC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL3NyYy9SZWFsdGltZUNsaWVudC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL2xpYi9lcnJvcnMudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL3NyYy9saWIvaGVscGVycy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL2xpYi9mZXRjaC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL3BhY2thZ2VzL1N0b3JhZ2VGaWxlQXBpLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL3NyYy9saWIvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9zcmMvcGFja2FnZXMvU3RvcmFnZUJ1Y2tldEFwaS50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvc3JjL1N0b3JhZ2VDbGllbnQudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL2NvbnN0YW50cy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9saWIvZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL2hlbHBlcnMudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvdmVyc2lvbi50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9jb25zdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvaGVscGVycy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9lcnJvcnMudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9saWIvZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL3NyYy9Hb1RydWVBZG1pbkFwaS50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9sb2NhbC1zdG9yYWdlLnRzIiwgIm5vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9zcmMvbGliL3BvbHlmaWxscy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL2xpYi9sb2Nrcy50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL0dvVHJ1ZUNsaWVudC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvc3JjL0F1dGhDbGllbnQudHMiLCAibm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9zcmMvbGliL1N1cGFiYXNlQXV0aENsaWVudC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9TdXBhYmFzZUNsaWVudC50cyIsICJub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL3NyYy9pbmRleC50cyIsICJzZXR0aW5ncy9TZXR0aW5ncy50cyIsICJzZXJ2aWNlcy9TdXBhYmFzZVNlcnZpY2UudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvaW50ZXJuYWwvcXMvZm9ybWF0cy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9pbnRlcm5hbC9xcy91dGlscy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9pbnRlcm5hbC9xcy9zdHJpbmdpZnkudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvdmVyc2lvbi50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9fc2hpbXMvcmVnaXN0cnkudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvX3NoaW1zL011bHRpcGFydEJvZHkudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvX3NoaW1zL3dlYi1ydW50aW1lLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvX3NoaW1zL2luZGV4Lm1qcyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9lcnJvci50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9pbnRlcm5hbC9kZWNvZGVycy9saW5lLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3N0cmVhbWluZy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy91cGxvYWRzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2NvcmUudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcGFnaW5hdGlvbi50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZS50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvY2hhdC9jaGF0LnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9hdWRpby9zcGVlY2gudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2F1ZGlvL3RyYW5zY3JpcHRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9hdWRpby90cmFuc2xhdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2F1ZGlvL2F1ZGlvLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iYXRjaGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL2Fzc2lzdGFudHMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL1J1bm5hYmxlRnVuY3Rpb24udHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL2NoYXRDb21wbGV0aW9uVXRpbHMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0V2ZW50U3RyZWFtLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2xpYi9wYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXIudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0NoYXRDb21wbGV0aW9uUnVubmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL192ZW5kb3IvcGFydGlhbC1qc29uLXBhcnNlci9wYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2xpYi9DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lci50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9jaGF0L2NvbXBsZXRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL2NoYXQvY2hhdC50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9yZWFsdGltZS9zZXNzaW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9yZWFsdGltZS9yZWFsdGltZS50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9saWIvQXNzaXN0YW50U3RyZWFtLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvbWVzc2FnZXMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2JldGEvdGhyZWFkcy9ydW5zL3N0ZXBzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvcnVucy9ydW5zLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvdGhyZWFkcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9saWIvVXRpbC50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS92ZWN0b3Itc3RvcmVzL2ZpbGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3ZlY3Rvci1zdG9yZXMvZmlsZS1iYXRjaGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9iZXRhL3ZlY3Rvci1zdG9yZXMvdmVjdG9yLXN0b3Jlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYmV0YS9iZXRhLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9jb21wbGV0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZW1iZWRkaW5ncy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmlsZXMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ZpbmUtdHVuaW5nL2pvYnMvY2hlY2twb2ludHMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ZpbmUtdHVuaW5nL2pvYnMvam9icy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmluZS10dW5pbmcvZmluZS10dW5pbmcudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ltYWdlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvbW9kZWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9tb2RlcmF0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvdXBsb2Fkcy9wYXJ0cy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvdXBsb2Fkcy91cGxvYWRzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2luZGV4LnRzIiwgInNlcnZpY2VzL09wZW5BSVNlcnZpY2UudHMiLCAic2VydmljZXMvUXVldWVTZXJ2aWNlLnRzIiwgInNlcnZpY2VzL01ldGFkYXRhRXh0cmFjdG9yLnRzIiwgInV0aWxzL1RleHRTcGxpdHRlci50cyIsICJzZXJ2aWNlcy9FdmVudEVtaXR0ZXIudHMiLCAidXRpbHMvRmlsZVRyYWNrZXIudHMiLCAic2VydmljZXMvU3luY0ZpbGVNYW5hZ2VyLnRzIiwgIm1vZGVscy9TeW5jTW9kZWxzLnRzIiwgInV0aWxzL0Vycm9ySGFuZGxlci50cyIsICJ1dGlscy9Ob3RpZmljYXRpb25NYW5hZ2VyLnRzIiwgInNldHRpbmdzL1NldHRpbmdzVGFiLnRzIiwgInNlcnZpY2VzL0luaXRpYWxTeW5jTWFuYWdlci50cyIsICJzZXJ2aWNlcy9TdGF0dXNNYW5hZ2VyLnRzIiwgInNlcnZpY2VzL1N5bmNEZXRlY3Rpb25NYW5hZ2VyLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJcInVzZSBzdHJpY3RcIjtcblxuLy8gcmVmOiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciBnZXRHbG9iYWwgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB0aGUgb25seSByZWxpYWJsZSBtZWFucyB0byBnZXQgdGhlIGdsb2JhbCBvYmplY3QgaXNcbiAgICAvLyBgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKWBcbiAgICAvLyBIb3dldmVyLCB0aGlzIGNhdXNlcyBDU1AgdmlvbGF0aW9ucyBpbiBDaHJvbWUgYXBwcy5cbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBzZWxmOyB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiB3aW5kb3c7IH1cbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGdsb2JhbDsgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jyk7XG59XG5cbnZhciBnbG9iYWxPYmplY3QgPSBnZXRHbG9iYWwoKTtcblxuZXhwb3J0IGNvbnN0IGZldGNoID0gZ2xvYmFsT2JqZWN0LmZldGNoO1xuXG5leHBvcnQgZGVmYXVsdCBnbG9iYWxPYmplY3QuZmV0Y2guYmluZChnbG9iYWxPYmplY3QpO1xuXG5leHBvcnQgY29uc3QgSGVhZGVycyA9IGdsb2JhbE9iamVjdC5IZWFkZXJzO1xuZXhwb3J0IGNvbnN0IFJlcXVlc3QgPSBnbG9iYWxPYmplY3QuUmVxdWVzdDtcbmV4cG9ydCBjb25zdCBSZXNwb25zZSA9IGdsb2JhbE9iamVjdC5SZXNwb25zZTtcbiIsICIvKipcbiAqIEVycm9yIGZvcm1hdFxuICpcbiAqIHtAbGluayBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sP2hpZ2hsaWdodD1vcHRpb25zI2Vycm9ycy1hbmQtaHR0cC1zdGF0dXMtY29kZXN9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBkZXRhaWxzOiBzdHJpbmdcbiAgaGludDogc3RyaW5nXG4gIGNvZGU6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IHsgbWVzc2FnZTogc3RyaW5nOyBkZXRhaWxzOiBzdHJpbmc7IGhpbnQ6IHN0cmluZzsgY29kZTogc3RyaW5nIH0pIHtcbiAgICBzdXBlcihjb250ZXh0Lm1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1Bvc3RncmVzdEVycm9yJ1xuICAgIHRoaXMuZGV0YWlscyA9IGNvbnRleHQuZGV0YWlsc1xuICAgIHRoaXMuaGludCA9IGNvbnRleHQuaGludFxuICAgIHRoaXMuY29kZSA9IGNvbnRleHQuY29kZVxuICB9XG59XG4iLCAiLy8gQHRzLWlnbm9yZVxuaW1wb3J0IG5vZGVGZXRjaCBmcm9tICdAc3VwYWJhc2Uvbm9kZS1mZXRjaCdcblxuaW1wb3J0IHR5cGUgeyBGZXRjaCwgUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2UsIFBvc3RncmVzdFJlc3BvbnNlU3VjY2VzcyB9IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQgUG9zdGdyZXN0RXJyb3IgZnJvbSAnLi9Qb3N0Z3Jlc3RFcnJvcidcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUG9zdGdyZXN0QnVpbGRlcjxSZXN1bHQsIFRocm93T25FcnJvciBleHRlbmRzIGJvb2xlYW4gPSBmYWxzZT5cbiAgaW1wbGVtZW50c1xuICAgIFByb21pc2VMaWtlPFxuICAgICAgVGhyb3dPbkVycm9yIGV4dGVuZHMgdHJ1ZSA/IFBvc3RncmVzdFJlc3BvbnNlU3VjY2VzczxSZXN1bHQ+IDogUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2U8UmVzdWx0PlxuICAgID5cbntcbiAgcHJvdGVjdGVkIG1ldGhvZDogJ0dFVCcgfCAnSEVBRCcgfCAnUE9TVCcgfCAnUEFUQ0gnIHwgJ0RFTEVURSdcbiAgcHJvdGVjdGVkIHVybDogVVJMXG4gIHByb3RlY3RlZCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIHByb3RlY3RlZCBzY2hlbWE/OiBzdHJpbmdcbiAgcHJvdGVjdGVkIGJvZHk/OiB1bmtub3duXG4gIHByb3RlY3RlZCBzaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZVxuICBwcm90ZWN0ZWQgc2lnbmFsPzogQWJvcnRTaWduYWxcbiAgcHJvdGVjdGVkIGZldGNoOiBGZXRjaFxuICBwcm90ZWN0ZWQgaXNNYXliZVNpbmdsZTogYm9vbGVhblxuXG4gIGNvbnN0cnVjdG9yKGJ1aWxkZXI6IFBvc3RncmVzdEJ1aWxkZXI8UmVzdWx0Pikge1xuICAgIHRoaXMubWV0aG9kID0gYnVpbGRlci5tZXRob2RcbiAgICB0aGlzLnVybCA9IGJ1aWxkZXIudXJsXG4gICAgdGhpcy5oZWFkZXJzID0gYnVpbGRlci5oZWFkZXJzXG4gICAgdGhpcy5zY2hlbWEgPSBidWlsZGVyLnNjaGVtYVxuICAgIHRoaXMuYm9keSA9IGJ1aWxkZXIuYm9keVxuICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gYnVpbGRlci5zaG91bGRUaHJvd09uRXJyb3JcbiAgICB0aGlzLnNpZ25hbCA9IGJ1aWxkZXIuc2lnbmFsXG4gICAgdGhpcy5pc01heWJlU2luZ2xlID0gYnVpbGRlci5pc01heWJlU2luZ2xlXG5cbiAgICBpZiAoYnVpbGRlci5mZXRjaCkge1xuICAgICAgdGhpcy5mZXRjaCA9IGJ1aWxkZXIuZmV0Y2hcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuZmV0Y2ggPSBub2RlRmV0Y2hcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mZXRjaCA9IGZldGNoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZXJlJ3MgYW4gZXJyb3Igd2l0aCB0aGUgcXVlcnksIHRocm93T25FcnJvciB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZSBieVxuICAgKiB0aHJvd2luZyB0aGUgZXJyb3IgaW5zdGVhZCBvZiByZXR1cm5pbmcgaXQgYXMgcGFydCBvZiBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gICAqXG4gICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2Uvc3VwYWJhc2UtanMvaXNzdWVzLzkyfVxuICAgKi9cbiAgdGhyb3dPbkVycm9yKCk6IHRoaXMgJiBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdCwgdHJ1ZT4ge1xuICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZVxuICAgIHJldHVybiB0aGlzIGFzIHRoaXMgJiBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdCwgdHJ1ZT5cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYW4gSFRUUCBoZWFkZXIgZm9yIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgc2V0SGVhZGVyKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMuaGVhZGVycyA9IHsgLi4udGhpcy5oZWFkZXJzIH1cbiAgICB0aGlzLmhlYWRlcnNbbmFtZV0gPSB2YWx1ZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0aGVuPFxuICAgIFRSZXN1bHQxID0gVGhyb3dPbkVycm9yIGV4dGVuZHMgdHJ1ZVxuICAgICAgPyBQb3N0Z3Jlc3RSZXNwb25zZVN1Y2Nlc3M8UmVzdWx0PlxuICAgICAgOiBQb3N0Z3Jlc3RTaW5nbGVSZXNwb25zZTxSZXN1bHQ+LFxuICAgIFRSZXN1bHQyID0gbmV2ZXJcbiAgPihcbiAgICBvbmZ1bGZpbGxlZD86XG4gICAgICB8ICgoXG4gICAgICAgICAgdmFsdWU6IFRocm93T25FcnJvciBleHRlbmRzIHRydWVcbiAgICAgICAgICAgID8gUG9zdGdyZXN0UmVzcG9uc2VTdWNjZXNzPFJlc3VsdD5cbiAgICAgICAgICAgIDogUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2U8UmVzdWx0PlxuICAgICAgICApID0+IFRSZXN1bHQxIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDE+KVxuICAgICAgfCB1bmRlZmluZWRcbiAgICAgIHwgbnVsbCxcbiAgICBvbnJlamVjdGVkPzogKChyZWFzb246IGFueSkgPT4gVFJlc3VsdDIgfCBQcm9taXNlTGlrZTxUUmVzdWx0Mj4pIHwgdW5kZWZpbmVkIHwgbnVsbFxuICApOiBQcm9taXNlTGlrZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiB7XG4gICAgLy8gaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNzd2l0Y2hpbmctc2NoZW1hc1xuICAgIGlmICh0aGlzLnNjaGVtYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBza2lwXG4gICAgfSBlbHNlIGlmIChbJ0dFVCcsICdIRUFEJ10uaW5jbHVkZXModGhpcy5tZXRob2QpKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdC1Qcm9maWxlJ10gPSB0aGlzLnNjaGVtYVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ0NvbnRlbnQtUHJvZmlsZSddID0gdGhpcy5zY2hlbWFcbiAgICB9XG4gICAgaWYgKHRoaXMubWV0aG9kICE9PSAnR0VUJyAmJiB0aGlzLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgfVxuXG4gICAgLy8gTk9URTogSW52b2tlIHcvbyBgdGhpc2AgdG8gYXZvaWQgaWxsZWdhbCBpbnZvY2F0aW9uIGVycm9yLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvcHVsbC8yNDdcbiAgICBjb25zdCBfZmV0Y2ggPSB0aGlzLmZldGNoXG4gICAgbGV0IHJlcyA9IF9mZXRjaCh0aGlzLnVybC50b1N0cmluZygpLCB7XG4gICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodGhpcy5ib2R5KSxcbiAgICAgIHNpZ25hbDogdGhpcy5zaWduYWwsXG4gICAgfSkudGhlbihhc3luYyAocmVzKSA9PiB7XG4gICAgICBsZXQgZXJyb3IgPSBudWxsXG4gICAgICBsZXQgZGF0YSA9IG51bGxcbiAgICAgIGxldCBjb3VudDogbnVtYmVyIHwgbnVsbCA9IG51bGxcbiAgICAgIGxldCBzdGF0dXMgPSByZXMuc3RhdHVzXG4gICAgICBsZXQgc3RhdHVzVGV4dCA9IHJlcy5zdGF0dXNUZXh0XG5cbiAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgaWYgKHRoaXMubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzLnRleHQoKVxuICAgICAgICAgIGlmIChib2R5ID09PSAnJykge1xuICAgICAgICAgICAgLy8gUHJlZmVyOiByZXR1cm49bWluaW1hbFxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9PT0gJ3RleHQvY3N2Jykge1xuICAgICAgICAgICAgZGF0YSA9IGJvZHlcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSAmJlxuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXS5pbmNsdWRlcygnYXBwbGljYXRpb24vdm5kLnBncnN0LnBsYW4rdGV4dCcpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkYXRhID0gYm9keVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShib2R5KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvdW50SGVhZGVyID0gdGhpcy5oZWFkZXJzWydQcmVmZXInXT8ubWF0Y2goL2NvdW50PShleGFjdHxwbGFubmVkfGVzdGltYXRlZCkvKVxuICAgICAgICBjb25zdCBjb250ZW50UmFuZ2UgPSByZXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtcmFuZ2UnKT8uc3BsaXQoJy8nKVxuICAgICAgICBpZiAoY291bnRIZWFkZXIgJiYgY29udGVudFJhbmdlICYmIGNvbnRlbnRSYW5nZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgY291bnQgPSBwYXJzZUludChjb250ZW50UmFuZ2VbMV0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZW1wb3JhcnkgcGFydGlhbCBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzM2MVxuICAgICAgICAvLyBJc3N1ZSBwZXJzaXN0cyBlLmcuIGZvciBgLmluc2VydChbLi4uXSkuc2VsZWN0KCkubWF5YmVTaW5nbGUoKWBcbiAgICAgICAgaWYgKHRoaXMuaXNNYXliZVNpbmdsZSAmJiB0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgJiYgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vUG9zdGdSRVNUL3Bvc3RncmVzdC9ibG9iL2E4NjdkNzljNDI0MTlhZjE2YzE4YzNmYjAxOWViYThkZjk5MjYyNmYvc3JjL1Bvc3RnUkVTVC9FcnJvci5ocyNMNTUzXG4gICAgICAgICAgICAgIGNvZGU6ICdQR1JTVDExNicsXG4gICAgICAgICAgICAgIGRldGFpbHM6IGBSZXN1bHRzIGNvbnRhaW4gJHtkYXRhLmxlbmd0aH0gcm93cywgYXBwbGljYXRpb24vdm5kLnBncnN0Lm9iamVjdCtqc29uIHJlcXVpcmVzIDEgcm93YCxcbiAgICAgICAgICAgICAgaGludDogbnVsbCxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ0pTT04gb2JqZWN0IHJlcXVlc3RlZCwgbXVsdGlwbGUgKG9yIG5vKSByb3dzIHJldHVybmVkJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBudWxsXG4gICAgICAgICAgICBjb3VudCA9IG51bGxcbiAgICAgICAgICAgIHN0YXR1cyA9IDQwNlxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdOb3QgQWNjZXB0YWJsZSdcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBkYXRhID0gZGF0YVswXVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcy50ZXh0KClcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGVycm9yID0gSlNPTi5wYXJzZShib2R5KVxuXG4gICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9pc3N1ZXMvMjk1XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXJyb3IpICYmIHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgZGF0YSA9IFtdXG4gICAgICAgICAgICBlcnJvciA9IG51bGxcbiAgICAgICAgICAgIHN0YXR1cyA9IDIwMFxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdPSydcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzI5NVxuICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQgJiYgYm9keSA9PT0gJycpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9IDIwNFxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdObyBDb250ZW50J1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYm9keSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IgJiYgdGhpcy5pc01heWJlU2luZ2xlICYmIGVycm9yPy5kZXRhaWxzPy5pbmNsdWRlcygnMCByb3dzJykpIHtcbiAgICAgICAgICBlcnJvciA9IG51bGxcbiAgICAgICAgICBzdGF0dXMgPSAyMDBcbiAgICAgICAgICBzdGF0dXNUZXh0ID0gJ09LJ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yICYmIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBvc3RncmVzdEVycm9yKGVycm9yKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvc3RncmVzdFJlc3BvbnNlID0ge1xuICAgICAgICBlcnJvcixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY291bnQsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dCxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvc3RncmVzdFJlc3BvbnNlXG4gICAgfSlcbiAgICBpZiAoIXRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICByZXMgPSByZXMuY2F0Y2goKGZldGNoRXJyb3IpID0+ICh7XG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgbWVzc2FnZTogYCR7ZmV0Y2hFcnJvcj8ubmFtZSA/PyAnRmV0Y2hFcnJvcid9OiAke2ZldGNoRXJyb3I/Lm1lc3NhZ2V9YCxcbiAgICAgICAgICBkZXRhaWxzOiBgJHtmZXRjaEVycm9yPy5zdGFjayA/PyAnJ31gLFxuICAgICAgICAgIGhpbnQ6ICcnLFxuICAgICAgICAgIGNvZGU6IGAke2ZldGNoRXJyb3I/LmNvZGUgPz8gJyd9YCxcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgY291bnQ6IG51bGwsXG4gICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgc3RhdHVzVGV4dDogJycsXG4gICAgICB9KSlcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpXG4gIH1cbn1cbiIsICJpbXBvcnQgUG9zdGdyZXN0QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEJ1aWxkZXInXG5pbXBvcnQgeyBHZXRSZXN1bHQgfSBmcm9tICcuL3NlbGVjdC1xdWVyeS1wYXJzZXIvcmVzdWx0J1xuaW1wb3J0IHsgR2VuZXJpY1NjaGVtYSB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXI8XG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEsXG4gIFJvdyBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBSZXN1bHQsXG4gIFJlbGF0aW9uTmFtZSA9IHVua25vd24sXG4gIFJlbGF0aW9uc2hpcHMgPSB1bmtub3duXG4+IGV4dGVuZHMgUG9zdGdyZXN0QnVpbGRlcjxSZXN1bHQ+IHtcbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBTRUxFQ1Qgb24gdGhlIHF1ZXJ5IHJlc3VsdC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYC5pbnNlcnQoKWAsIGAudXBkYXRlKClgLCBgLnVwc2VydCgpYCwgYW5kIGAuZGVsZXRlKClgIGRvIG5vdFxuICAgKiByZXR1cm4gbW9kaWZpZWQgcm93cy4gQnkgY2FsbGluZyB0aGlzIG1ldGhvZCwgbW9kaWZpZWQgcm93cyBhcmUgcmV0dXJuZWQgaW5cbiAgICogYGRhdGFgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1ucyAtIFRoZSBjb2x1bW5zIHRvIHJldHJpZXZlLCBzZXBhcmF0ZWQgYnkgY29tbWFzXG4gICAqL1xuICBzZWxlY3Q8XG4gICAgUXVlcnkgZXh0ZW5kcyBzdHJpbmcgPSAnKicsXG4gICAgTmV3UmVzdWx0T25lID0gR2V0UmVzdWx0PFNjaGVtYSwgUm93LCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHMsIFF1ZXJ5PlxuICA+KFxuICAgIGNvbHVtbnM/OiBRdWVyeVxuICApOiBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyPFNjaGVtYSwgUm93LCBOZXdSZXN1bHRPbmVbXSwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2VzIGV4Y2VwdCB3aGVuIHF1b3RlZFxuICAgIGxldCBxdW90ZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNsZWFuZWRDb2x1bW5zID0gKGNvbHVtbnMgPz8gJyonKVxuICAgICAgLnNwbGl0KCcnKVxuICAgICAgLm1hcCgoYykgPT4ge1xuICAgICAgICBpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSB7XG4gICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICBxdW90ZWQgPSAhcXVvdGVkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH0pXG4gICAgICAuam9pbignJylcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZWxlY3QnLCBjbGVhbmVkQ29sdW1ucylcbiAgICBpZiAodGhpcy5oZWFkZXJzWydQcmVmZXInXSkge1xuICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSArPSAnLCdcbiAgICB9XG4gICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSArPSAncmV0dXJuPXJlcHJlc2VudGF0aW9uJ1xuICAgIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcjxcbiAgICAgIFNjaGVtYSxcbiAgICAgIFJvdyxcbiAgICAgIE5ld1Jlc3VsdE9uZVtdLFxuICAgICAgUmVsYXRpb25OYW1lLFxuICAgICAgUmVsYXRpb25zaGlwc1xuICAgID5cbiAgfVxuXG4gIG9yZGVyPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBvcHRpb25zPzogeyBhc2NlbmRpbmc/OiBib29sZWFuOyBudWxsc0ZpcnN0PzogYm9vbGVhbjsgcmVmZXJlbmNlZFRhYmxlPzogdW5kZWZpbmVkIH1cbiAgKTogdGhpc1xuICBvcmRlcihcbiAgICBjb2x1bW46IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyBhc2NlbmRpbmc/OiBib29sZWFuOyBudWxsc0ZpcnN0PzogYm9vbGVhbjsgcmVmZXJlbmNlZFRhYmxlPzogc3RyaW5nIH1cbiAgKTogdGhpc1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWAgaW5zdGVhZCBvZiBgb3B0aW9ucy5mb3JlaWduVGFibGVgXG4gICAqL1xuICBvcmRlcjxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgb3B0aW9ucz86IHsgYXNjZW5kaW5nPzogYm9vbGVhbjsgbnVsbHNGaXJzdD86IGJvb2xlYW47IGZvcmVpZ25UYWJsZT86IHVuZGVmaW5lZCB9XG4gICk6IHRoaXNcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgIGluc3RlYWQgb2YgYG9wdGlvbnMuZm9yZWlnblRhYmxlYFxuICAgKi9cbiAgb3JkZXIoXG4gICAgY29sdW1uOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgYXNjZW5kaW5nPzogYm9vbGVhbjsgbnVsbHNGaXJzdD86IGJvb2xlYW47IGZvcmVpZ25UYWJsZT86IHN0cmluZyB9XG4gICk6IHRoaXNcbiAgLyoqXG4gICAqIE9yZGVyIHRoZSBxdWVyeSByZXN1bHQgYnkgYGNvbHVtbmAuXG4gICAqXG4gICAqIFlvdSBjYW4gY2FsbCB0aGlzIG1ldGhvZCBtdWx0aXBsZSB0aW1lcyB0byBvcmRlciBieSBtdWx0aXBsZSBjb2x1bW5zLlxuICAgKlxuICAgKiBZb3UgY2FuIG9yZGVyIHJlZmVyZW5jZWQgdGFibGVzLCBidXQgaXQgb25seSBhZmZlY3RzIHRoZSBvcmRlcmluZyBvZiB0aGVcbiAgICogcGFyZW50IHRhYmxlIGlmIHlvdSB1c2UgYCFpbm5lcmAgaW4gdGhlIHF1ZXJ5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBvcmRlciBieVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMuYXNjZW5kaW5nIC0gSWYgYHRydWVgLCB0aGUgcmVzdWx0IHdpbGwgYmUgaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAqIEBwYXJhbSBvcHRpb25zLm51bGxzRmlyc3QgLSBJZiBgdHJ1ZWAsIGBudWxsYHMgYXBwZWFyIGZpcnN0LiBJZiBgZmFsc2VgLFxuICAgKiBgbnVsbGBzIGFwcGVhciBsYXN0LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBvcmRlciBhIHJlZmVyZW5jZWQgdGFibGUgYnlcbiAgICogaXRzIGNvbHVtbnNcbiAgICogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWBcbiAgICogaW5zdGVhZFxuICAgKi9cbiAgb3JkZXIoXG4gICAgY29sdW1uOiBzdHJpbmcsXG4gICAge1xuICAgICAgYXNjZW5kaW5nID0gdHJ1ZSxcbiAgICAgIG51bGxzRmlyc3QsXG4gICAgICBmb3JlaWduVGFibGUsXG4gICAgICByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUsXG4gICAgfToge1xuICAgICAgYXNjZW5kaW5nPzogYm9vbGVhblxuICAgICAgbnVsbHNGaXJzdD86IGJvb2xlYW5cbiAgICAgIGZvcmVpZ25UYWJsZT86IHN0cmluZ1xuICAgICAgcmVmZXJlbmNlZFRhYmxlPzogc3RyaW5nXG4gICAgfSA9IHt9XG4gICk6IHRoaXMge1xuICAgIGNvbnN0IGtleSA9IHJlZmVyZW5jZWRUYWJsZSA/IGAke3JlZmVyZW5jZWRUYWJsZX0ub3JkZXJgIDogJ29yZGVyJ1xuICAgIGNvbnN0IGV4aXN0aW5nT3JkZXIgPSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuZ2V0KGtleSlcblxuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoXG4gICAgICBrZXksXG4gICAgICBgJHtleGlzdGluZ09yZGVyID8gYCR7ZXhpc3RpbmdPcmRlcn0sYCA6ICcnfSR7Y29sdW1ufS4ke2FzY2VuZGluZyA/ICdhc2MnIDogJ2Rlc2MnfSR7XG4gICAgICAgIG51bGxzRmlyc3QgPT09IHVuZGVmaW5lZCA/ICcnIDogbnVsbHNGaXJzdCA/ICcubnVsbHNmaXJzdCcgOiAnLm51bGxzbGFzdCdcbiAgICAgIH1gXG4gICAgKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogTGltaXQgdGhlIHF1ZXJ5IHJlc3VsdCBieSBgY291bnRgLlxuICAgKlxuICAgKiBAcGFyYW0gY291bnQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0byByZXR1cm5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGxpbWl0IHJvd3Mgb2YgcmVmZXJlbmNlZFxuICAgKiB0YWJsZXMgaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG4gICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgXG4gICAqIGluc3RlYWRcbiAgICovXG4gIGxpbWl0KFxuICAgIGNvdW50OiBudW1iZXIsXG4gICAge1xuICAgICAgZm9yZWlnblRhYmxlLFxuICAgICAgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlLFxuICAgIH06IHsgZm9yZWlnblRhYmxlPzogc3RyaW5nOyByZWZlcmVuY2VkVGFibGU/OiBzdHJpbmcgfSA9IHt9XG4gICk6IHRoaXMge1xuICAgIGNvbnN0IGtleSA9IHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09ICd1bmRlZmluZWQnID8gJ2xpbWl0JyA6IGAke3JlZmVyZW5jZWRUYWJsZX0ubGltaXRgXG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIGAke2NvdW50fWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBMaW1pdCB0aGUgcXVlcnkgcmVzdWx0IGJ5IHN0YXJ0aW5nIGF0IGFuIG9mZnNldCBgZnJvbWAgYW5kIGVuZGluZyBhdCB0aGUgb2Zmc2V0IGB0b2AuXG4gICAqIE9ubHkgcmVjb3JkcyB3aXRoaW4gdGhpcyByYW5nZSBhcmUgcmV0dXJuZWQuXG4gICAqIFRoaXMgcmVzcGVjdHMgdGhlIHF1ZXJ5IG9yZGVyIGFuZCBpZiB0aGVyZSBpcyBubyBvcmRlciBjbGF1c2UgdGhlIHJhbmdlIGNvdWxkIGJlaGF2ZSB1bmV4cGVjdGVkbHkuXG4gICAqIFRoZSBgZnJvbWAgYW5kIGB0b2AgdmFsdWVzIGFyZSAwLWJhc2VkIGFuZCBpbmNsdXNpdmU6IGByYW5nZSgxLCAzKWAgd2lsbCBpbmNsdWRlIHRoZSBzZWNvbmQsIHRoaXJkXG4gICAqIGFuZCBmb3VydGggcm93cyBvZiB0aGUgcXVlcnkuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHN0YXJ0aW5nIGluZGV4IGZyb20gd2hpY2ggdG8gbGltaXQgdGhlIHJlc3VsdFxuICAgKiBAcGFyYW0gdG8gLSBUaGUgbGFzdCBpbmRleCB0byB3aGljaCB0byBsaW1pdCB0aGUgcmVzdWx0XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBsaW1pdCByb3dzIG9mIHJlZmVyZW5jZWRcbiAgICogdGFibGVzIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuICAgKiBpbnN0ZWFkXG4gICAqL1xuICByYW5nZShcbiAgICBmcm9tOiBudW1iZXIsXG4gICAgdG86IG51bWJlcixcbiAgICB7XG4gICAgICBmb3JlaWduVGFibGUsXG4gICAgICByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUsXG4gICAgfTogeyBmb3JlaWduVGFibGU/OiBzdHJpbmc7IHJlZmVyZW5jZWRUYWJsZT86IHN0cmluZyB9ID0ge31cbiAgKTogdGhpcyB7XG4gICAgY29uc3Qga2V5T2Zmc2V0ID1cbiAgICAgIHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09ICd1bmRlZmluZWQnID8gJ29mZnNldCcgOiBgJHtyZWZlcmVuY2VkVGFibGV9Lm9mZnNldGBcbiAgICBjb25zdCBrZXlMaW1pdCA9IHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09ICd1bmRlZmluZWQnID8gJ2xpbWl0JyA6IGAke3JlZmVyZW5jZWRUYWJsZX0ubGltaXRgXG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXlPZmZzZXQsIGAke2Zyb219YClcbiAgICAvLyBSYW5nZSBpcyBpbmNsdXNpdmUsIHNvIGFkZCAxXG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXlMaW1pdCwgYCR7dG8gLSBmcm9tICsgMX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBBYm9ydFNpZ25hbCBmb3IgdGhlIGZldGNoIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBzaWduYWwgLSBUaGUgQWJvcnRTaWduYWwgdG8gdXNlIGZvciB0aGUgZmV0Y2ggcmVxdWVzdFxuICAgKi9cbiAgYWJvcnRTaWduYWwoc2lnbmFsOiBBYm9ydFNpZ25hbCk6IHRoaXMge1xuICAgIHRoaXMuc2lnbmFsID0gc2lnbmFsXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYGRhdGFgIGFzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gICAqXG4gICAqIFF1ZXJ5IHJlc3VsdCBtdXN0IGJlIG9uZSByb3cgKGUuZy4gdXNpbmcgYC5saW1pdCgxKWApLCBvdGhlcndpc2UgdGhpc1xuICAgKiByZXR1cm5zIGFuIGVycm9yLlxuICAgKi9cbiAgc2luZ2xlPFxuICAgIFJlc3VsdE9uZSA9IFJlc3VsdCBleHRlbmRzIChpbmZlciBSZXN1bHRPbmUpW10gPyBSZXN1bHRPbmUgOiBuZXZlclxuICA+KCk6IFBvc3RncmVzdEJ1aWxkZXI8UmVzdWx0T25lPiB7XG4gICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24nXG4gICAgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdE9uZT5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYGRhdGFgIGFzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gICAqXG4gICAqIFF1ZXJ5IHJlc3VsdCBtdXN0IGJlIHplcm8gb3Igb25lIHJvdyAoZS5nLiB1c2luZyBgLmxpbWl0KDEpYCksIG90aGVyd2lzZVxuICAgKiB0aGlzIHJldHVybnMgYW4gZXJyb3IuXG4gICAqL1xuICBtYXliZVNpbmdsZTxcbiAgICBSZXN1bHRPbmUgPSBSZXN1bHQgZXh0ZW5kcyAoaW5mZXIgUmVzdWx0T25lKVtdID8gUmVzdWx0T25lIDogbmV2ZXJcbiAgPigpOiBQb3N0Z3Jlc3RCdWlsZGVyPFJlc3VsdE9uZSB8IG51bGw+IHtcbiAgICAvLyBUZW1wb3JhcnkgcGFydGlhbCBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzM2MVxuICAgIC8vIElzc3VlIHBlcnNpc3RzIGUuZy4gZm9yIGAuaW5zZXJ0KFsuLi5dKS5zZWxlY3QoKS5tYXliZVNpbmdsZSgpYFxuICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vanNvbidcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24nXG4gICAgfVxuICAgIHRoaXMuaXNNYXliZVNpbmdsZSA9IHRydWVcbiAgICByZXR1cm4gdGhpcyBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8UmVzdWx0T25lIHwgbnVsbD5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYGRhdGFgIGFzIGEgc3RyaW5nIGluIENTViBmb3JtYXQuXG4gICAqL1xuICBjc3YoKTogUG9zdGdyZXN0QnVpbGRlcjxzdHJpbmc+IHtcbiAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID0gJ3RleHQvY3N2J1xuICAgIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxzdHJpbmc+XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGBkYXRhYCBhcyBhbiBvYmplY3QgaW4gW0dlb0pTT05dKGh0dHBzOi8vZ2VvanNvbi5vcmcpIGZvcm1hdC5cbiAgICovXG4gIGdlb2pzb24oKTogUG9zdGdyZXN0QnVpbGRlcjxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4ge1xuICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vZ2VvK2pzb24nXG4gICAgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPFJlY29yZDxzdHJpbmcsIHVua25vd24+PlxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBgZGF0YWAgYXMgdGhlIEVYUExBSU4gcGxhbiBmb3IgdGhlIHF1ZXJ5LlxuICAgKlxuICAgKiBZb3UgbmVlZCB0byBlbmFibGUgdGhlXG4gICAqIFtkYl9wbGFuX2VuYWJsZWRdKGh0dHBzOi8vc3VwYWJhc2UuY29tL2RvY3MvZ3VpZGVzL2RhdGFiYXNlL2RlYnVnZ2luZy1wZXJmb3JtYW5jZSNlbmFibGluZy1leHBsYWluKVxuICAgKiBzZXR0aW5nIGJlZm9yZSB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmFuYWx5emUgLSBJZiBgdHJ1ZWAsIHRoZSBxdWVyeSB3aWxsIGJlIGV4ZWN1dGVkIGFuZCB0aGVcbiAgICogYWN0dWFsIHJ1biB0aW1lIHdpbGwgYmUgcmV0dXJuZWRcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMudmVyYm9zZSAtIElmIGB0cnVlYCwgdGhlIHF1ZXJ5IGlkZW50aWZpZXIgd2lsbCBiZSByZXR1cm5lZFxuICAgKiBhbmQgYGRhdGFgIHdpbGwgaW5jbHVkZSB0aGUgb3V0cHV0IGNvbHVtbnMgb2YgdGhlIHF1ZXJ5XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLnNldHRpbmdzIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIGNvbmZpZ3VyYXRpb25cbiAgICogcGFyYW1ldGVycyB0aGF0IGFmZmVjdCBxdWVyeSBwbGFubmluZ1xuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5idWZmZXJzIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIGJ1ZmZlciB1c2FnZVxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy53YWwgLSBJZiBgdHJ1ZWAsIGluY2x1ZGUgaW5mb3JtYXRpb24gb24gV0FMIHJlY29yZCBnZW5lcmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmZvcm1hdCAtIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCwgY2FuIGJlIGBcInRleHRcImAgKGRlZmF1bHQpXG4gICAqIG9yIGBcImpzb25cImBcbiAgICovXG4gIGV4cGxhaW4oe1xuICAgIGFuYWx5emUgPSBmYWxzZSxcbiAgICB2ZXJib3NlID0gZmFsc2UsXG4gICAgc2V0dGluZ3MgPSBmYWxzZSxcbiAgICBidWZmZXJzID0gZmFsc2UsXG4gICAgd2FsID0gZmFsc2UsXG4gICAgZm9ybWF0ID0gJ3RleHQnLFxuICB9OiB7XG4gICAgYW5hbHl6ZT86IGJvb2xlYW5cbiAgICB2ZXJib3NlPzogYm9vbGVhblxuICAgIHNldHRpbmdzPzogYm9vbGVhblxuICAgIGJ1ZmZlcnM/OiBib29sZWFuXG4gICAgd2FsPzogYm9vbGVhblxuICAgIGZvcm1hdD86ICdqc29uJyB8ICd0ZXh0J1xuICB9ID0ge30pOiBQb3N0Z3Jlc3RCdWlsZGVyPFJlY29yZDxzdHJpbmcsIHVua25vd24+W10+IHwgUG9zdGdyZXN0QnVpbGRlcjxzdHJpbmc+IHtcbiAgICBjb25zdCBvcHRpb25zID0gW1xuICAgICAgYW5hbHl6ZSA/ICdhbmFseXplJyA6IG51bGwsXG4gICAgICB2ZXJib3NlID8gJ3ZlcmJvc2UnIDogbnVsbCxcbiAgICAgIHNldHRpbmdzID8gJ3NldHRpbmdzJyA6IG51bGwsXG4gICAgICBidWZmZXJzID8gJ2J1ZmZlcnMnIDogbnVsbCxcbiAgICAgIHdhbCA/ICd3YWwnIDogbnVsbCxcbiAgICBdXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAuam9pbignfCcpXG4gICAgLy8gQW4gQWNjZXB0IGhlYWRlciBjYW4gY2FycnkgbXVsdGlwbGUgbWVkaWEgdHlwZXMgYnV0IHBvc3RncmVzdC1qcyBhbHdheXMgc2VuZHMgb25lXG4gICAgY29uc3QgZm9yTWVkaWF0eXBlID0gdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA/PyAnYXBwbGljYXRpb24vanNvbidcbiAgICB0aGlzLmhlYWRlcnNbXG4gICAgICAnQWNjZXB0J1xuICAgIF0gPSBgYXBwbGljYXRpb24vdm5kLnBncnN0LnBsYW4rJHtmb3JtYXR9OyBmb3I9XCIke2Zvck1lZGlhdHlwZX1cIjsgb3B0aW9ucz0ke29wdGlvbnN9O2BcbiAgICBpZiAoZm9ybWF0ID09PSAnanNvbicpIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdPlxuICAgIGVsc2UgcmV0dXJuIHRoaXMgYXMgdW5rbm93biBhcyBQb3N0Z3Jlc3RCdWlsZGVyPHN0cmluZz5cbiAgfVxuXG4gIC8qKlxuICAgKiBSb2xsYmFjayB0aGUgcXVlcnkuXG4gICAqXG4gICAqIGBkYXRhYCB3aWxsIHN0aWxsIGJlIHJldHVybmVkLCBidXQgdGhlIHF1ZXJ5IGlzIG5vdCBjb21taXR0ZWQuXG4gICAqL1xuICByb2xsYmFjaygpOiB0aGlzIHtcbiAgICBpZiAoKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPz8gJycpLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ1ByZWZlciddICs9ICcsdHg9cm9sbGJhY2snXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSAndHg9cm9sbGJhY2snXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGBkYXRhYC5cbiAgICpcbiAgICogQHR5cGVQYXJhbSBOZXdSZXN1bHQgLSBUaGUgbmV3IHJlc3VsdCB0eXBlIHRvIG92ZXJyaWRlIHdpdGhcbiAgICovXG4gIHJldHVybnM8TmV3UmVzdWx0PigpOiBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyPFxuICAgIFNjaGVtYSxcbiAgICBSb3csXG4gICAgTmV3UmVzdWx0LFxuICAgIFJlbGF0aW9uTmFtZSxcbiAgICBSZWxhdGlvbnNoaXBzXG4gID4ge1xuICAgIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcjxcbiAgICAgIFNjaGVtYSxcbiAgICAgIFJvdyxcbiAgICAgIE5ld1Jlc3VsdCxcbiAgICAgIFJlbGF0aW9uTmFtZSxcbiAgICAgIFJlbGF0aW9uc2hpcHNcbiAgICA+XG4gIH1cbn1cbiIsICJpbXBvcnQgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXInXG5pbXBvcnQgeyBHZW5lcmljU2NoZW1hIH0gZnJvbSAnLi90eXBlcydcblxudHlwZSBGaWx0ZXJPcGVyYXRvciA9XG4gIHwgJ2VxJ1xuICB8ICduZXEnXG4gIHwgJ2d0J1xuICB8ICdndGUnXG4gIHwgJ2x0J1xuICB8ICdsdGUnXG4gIHwgJ2xpa2UnXG4gIHwgJ2lsaWtlJ1xuICB8ICdpcydcbiAgfCAnaW4nXG4gIHwgJ2NzJ1xuICB8ICdjZCdcbiAgfCAnc2wnXG4gIHwgJ3NyJ1xuICB8ICdueGwnXG4gIHwgJ254cidcbiAgfCAnYWRqJ1xuICB8ICdvdidcbiAgfCAnZnRzJ1xuICB8ICdwbGZ0cydcbiAgfCAncGhmdHMnXG4gIHwgJ3dmdHMnXG5cbi8vIE1hdGNoIHJlbGF0aW9uc2hpcCBmaWx0ZXJzIHdpdGggYHRhYmxlLmNvbHVtbmAgc3ludGF4IGFuZCByZXNvbHZlIHVuZGVybHlpbmdcbi8vIGNvbHVtbiB2YWx1ZS4gSWYgbm90IG1hdGNoZWQsIGZhbGxiYWNrIHRvIGdlbmVyaWMgdHlwZS5cbi8vIFRPRE86IFZhbGlkYXRlIHRoZSByZWxhdGlvbnNoaXAgaXRzZWxmIGFsYSBzZWxlY3QtcXVlcnktcGFyc2VyLiBDdXJyZW50bHkgd2Vcbi8vIGFzc3VtZSB0aGF0IGFsbCB0YWJsZXMgaGF2ZSB2YWxpZCByZWxhdGlvbnNoaXBzIHRvIGVhY2ggb3RoZXIsIGRlc3BpdGVcbi8vIG5vbmV4aXN0ZW50IGZvcmVpZ24ga2V5cy5cbnR5cGUgUmVzb2x2ZUZpbHRlclZhbHVlPFxuICBTY2hlbWEgZXh0ZW5kcyBHZW5lcmljU2NoZW1hLFxuICBSb3cgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgQ29sdW1uTmFtZSBleHRlbmRzIHN0cmluZ1xuPiA9IENvbHVtbk5hbWUgZXh0ZW5kcyBgJHtpbmZlciBSZWxhdGlvbnNoaXBUYWJsZX0uJHtpbmZlciBSZW1haW5kZXJ9YFxuICA/IFJlbWFpbmRlciBleHRlbmRzIGAke2luZmVyIF99LiR7aW5mZXIgX31gXG4gICAgPyBSZXNvbHZlRmlsdGVyVmFsdWU8U2NoZW1hLCBSb3csIFJlbWFpbmRlcj5cbiAgICA6IFJlc29sdmVGaWx0ZXJSZWxhdGlvbnNoaXBWYWx1ZTxTY2hlbWEsIFJlbGF0aW9uc2hpcFRhYmxlLCBSZW1haW5kZXI+XG4gIDogQ29sdW1uTmFtZSBleHRlbmRzIGtleW9mIFJvd1xuICA/IFJvd1tDb2x1bW5OYW1lXVxuICA6IG5ldmVyXG5cbnR5cGUgUmVzb2x2ZUZpbHRlclJlbGF0aW9uc2hpcFZhbHVlPFxuICBTY2hlbWEgZXh0ZW5kcyBHZW5lcmljU2NoZW1hLFxuICBSZWxhdGlvbnNoaXBUYWJsZSBleHRlbmRzIHN0cmluZyxcbiAgUmVsYXRpb25zaGlwQ29sdW1uIGV4dGVuZHMgc3RyaW5nXG4+ID0gU2NoZW1hWydUYWJsZXMnXSAmIFNjaGVtYVsnVmlld3MnXSBleHRlbmRzIGluZmVyIFRhYmxlc0FuZFZpZXdzXG4gID8gUmVsYXRpb25zaGlwVGFibGUgZXh0ZW5kcyBrZXlvZiBUYWJsZXNBbmRWaWV3c1xuICAgID8gJ1JvdycgZXh0ZW5kcyBrZXlvZiBUYWJsZXNBbmRWaWV3c1tSZWxhdGlvbnNoaXBUYWJsZV1cbiAgICAgID8gUmVsYXRpb25zaGlwQ29sdW1uIGV4dGVuZHMga2V5b2YgVGFibGVzQW5kVmlld3NbUmVsYXRpb25zaGlwVGFibGVdWydSb3cnXVxuICAgICAgICA/IFRhYmxlc0FuZFZpZXdzW1JlbGF0aW9uc2hpcFRhYmxlXVsnUm93J11bUmVsYXRpb25zaGlwQ29sdW1uXVxuICAgICAgICA6IHVua25vd25cbiAgICAgIDogdW5rbm93blxuICAgIDogdW5rbm93blxuICA6IG5ldmVyXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8XG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEsXG4gIFJvdyBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBSZXN1bHQsXG4gIFJlbGF0aW9uTmFtZSA9IHVua25vd24sXG4gIFJlbGF0aW9uc2hpcHMgPSB1bmtub3duXG4+IGV4dGVuZHMgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcjxTY2hlbWEsIFJvdywgUmVzdWx0LCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+IHtcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBUbyBjaGVjayBpZiB0aGUgdmFsdWUgb2YgYGNvbHVtbmAgaXMgTlVMTCwgeW91IHNob3VsZCB1c2UgYC5pcygpYCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBlcTxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nPihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgdmFsdWU6IFJlc29sdmVGaWx0ZXJWYWx1ZTxTY2hlbWEsIFJvdywgQ29sdW1uTmFtZT4gZXh0ZW5kcyBuZXZlclxuICAgICAgPyBOb25OdWxsYWJsZTx1bmtub3duPlxuICAgICAgOiBOb25OdWxsYWJsZTxSZXNvbHZlRmlsdGVyVmFsdWU8U2NoZW1hLCBSb3csIENvbHVtbk5hbWU+PlxuICApOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGVxLiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBub3QgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgbmVxPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmc+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZTogUmVzb2x2ZUZpbHRlclZhbHVlPFNjaGVtYSwgUm93LCBDb2x1bW5OYW1lPiBleHRlbmRzIG5ldmVyXG4gICAgICA/IHVua25vd25cbiAgICAgIDogUmVzb2x2ZUZpbHRlclZhbHVlPFNjaGVtYSwgUm93LCBDb2x1bW5OYW1lPlxuICApOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5lcS4ke3ZhbHVlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGd0PENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgdmFsdWU6IFJvd1tDb2x1bW5OYW1lXSk6IHRoaXNcbiAgZ3QoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBndChjb2x1bW46IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGd0LiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ3RlPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgdmFsdWU6IFJvd1tDb2x1bW5OYW1lXSk6IHRoaXNcbiAgZ3RlKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgZ3RlKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZ3RlLiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbHQ8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCB2YWx1ZTogUm93W0NvbHVtbk5hbWVdKTogdGhpc1xuICBsdChjb2x1bW46IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbGVzcyB0aGFuIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGx0KGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbHQuJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsdGU8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCB2YWx1ZTogUm93W0NvbHVtbk5hbWVdKTogdGhpc1xuICBsdGUoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBsdGUoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsdGUuJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsaWtlPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgcGF0dGVybjogc3RyaW5nKTogdGhpc1xuICBsaWtlKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuOiBzdHJpbmcpOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBgcGF0dGVybmAgY2FzZS1zZW5zaXRpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuICAgKi9cbiAgbGlrZShjb2x1bW46IHN0cmluZywgcGF0dGVybjogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsaWtlLiR7cGF0dGVybn1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsaWtlQWxsT2Y8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXVxuICApOiB0aGlzXG4gIGxpa2VBbGxPZihjb2x1bW46IHN0cmluZywgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYWxsIG9mIGBwYXR0ZXJuc2AgY2FzZS1zZW5zaXRpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG4gICAqL1xuICBsaWtlQWxsT2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZShhbGwpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbGlrZUFueU9mPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW11cbiAgKTogdGhpc1xuICBsaWtlQW55T2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFueSBvZiBgcGF0dGVybnNgIGNhc2Utc2Vuc2l0aXZlbHkuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuICAgKi9cbiAgbGlrZUFueU9mKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW10pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGxpa2UoYW55KS57JHtwYXR0ZXJucy5qb2luKCcsJyl9fWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlsaWtlPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KGNvbHVtbjogQ29sdW1uTmFtZSwgcGF0dGVybjogc3RyaW5nKTogdGhpc1xuICBpbGlrZShjb2x1bW46IHN0cmluZywgcGF0dGVybjogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYHBhdHRlcm5gIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuICAgKi9cbiAgaWxpa2UoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm46IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UuJHtwYXR0ZXJufWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlsaWtlQWxsT2Y8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXVxuICApOiB0aGlzXG4gIGlsaWtlQWxsT2YoY29sdW1uOiBzdHJpbmcsIHBhdHRlcm5zOiByZWFkb25seSBzdHJpbmdbXSk6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFsbCBvZiBgcGF0dGVybnNgIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG4gICAqL1xuICBpbGlrZUFsbE9mKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW10pOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlsaWtlKGFsbCkueyR7cGF0dGVybnMuam9pbignLCcpfX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBpbGlrZUFueU9mPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW11cbiAgKTogdGhpc1xuICBpbGlrZUFueU9mKGNvbHVtbjogc3RyaW5nLCBwYXR0ZXJuczogcmVhZG9ubHkgc3RyaW5nW10pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbnkgb2YgYHBhdHRlcm5zYCBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuICAgKi9cbiAgaWxpa2VBbnlPZihjb2x1bW46IHN0cmluZywgcGF0dGVybnM6IHJlYWRvbmx5IHN0cmluZ1tdKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbGlrZShhbnkpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaXM8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHZhbHVlOiBSb3dbQ29sdW1uTmFtZV0gJiAoYm9vbGVhbiB8IG51bGwpXG4gICk6IHRoaXNcbiAgaXMoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBib29sZWFuIHwgbnVsbCk6IHRoaXNcbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBJUyBgdmFsdWVgLlxuICAgKlxuICAgKiBGb3Igbm9uLWJvb2xlYW4gY29sdW1ucywgdGhpcyBpcyBvbmx5IHJlbGV2YW50IGZvciBjaGVja2luZyBpZiB0aGUgdmFsdWUgb2ZcbiAgICogYGNvbHVtbmAgaXMgTlVMTCBieSBzZXR0aW5nIGB2YWx1ZWAgdG8gYG51bGxgLlxuICAgKlxuICAgKiBGb3IgYm9vbGVhbiBjb2x1bW5zLCB5b3UgY2FuIGFsc28gc2V0IGB2YWx1ZWAgdG8gYHRydWVgIG9yIGBmYWxzZWAgYW5kIGl0XG4gICAqIHdpbGwgYmVoYXZlIHRoZSBzYW1lIHdheSBhcyBgLmVxKClgLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBpcyhjb2x1bW46IHN0cmluZywgdmFsdWU6IGJvb2xlYW4gfCBudWxsKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpcy4ke3ZhbHVlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgaW5jbHVkZWQgaW4gdGhlIGB2YWx1ZXNgIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgYXJyYXkgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIGluPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmc+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZXM6IFJlc29sdmVGaWx0ZXJWYWx1ZTxTY2hlbWEsIFJvdywgQ29sdW1uTmFtZT4gZXh0ZW5kcyBuZXZlclxuICAgICAgPyB1bmtub3duW11cbiAgICAgIDogUmVhZG9ubHlBcnJheTxSZXNvbHZlRmlsdGVyVmFsdWU8U2NoZW1hLCBSb3csIENvbHVtbk5hbWU+PlxuICApOiB0aGlzIHtcbiAgICBjb25zdCBjbGVhbmVkVmFsdWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KHZhbHVlcykpXG4gICAgICAubWFwKChzKSA9PiB7XG4gICAgICAgIC8vIGhhbmRsZSBwb3N0Z3Jlc3QgcmVzZXJ2ZWQgY2hhcmFjdGVyc1xuICAgICAgICAvLyBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vdjcuMC4wL2FwaS5odG1sI3Jlc2VydmVkLWNoYXJhY3RlcnNcbiAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJyAmJiBuZXcgUmVnRXhwKCdbLCgpXScpLnRlc3QocykpIHJldHVybiBgXCIke3N9XCJgXG4gICAgICAgIGVsc2UgcmV0dXJuIGAke3N9YFxuICAgICAgfSlcbiAgICAgIC5qb2luKCcsJylcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGluLigke2NsZWFuZWRWYWx1ZXN9KWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGNvbnRhaW5zPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICB2YWx1ZTogc3RyaW5nIHwgUmVhZG9ubHlBcnJheTxSb3dbQ29sdW1uTmFtZV0+IHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgKTogdGhpc1xuICBjb250YWlucyhjb2x1bW46IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHJlYWRvbmx5IHVua25vd25bXSB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IganNvbmIsIGFycmF5LCBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAqIGBjb2x1bW5gIGNvbnRhaW5zIGV2ZXJ5IGVsZW1lbnQgYXBwZWFyaW5nIGluIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBjb250YWlucyhjb2x1bW46IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHJlYWRvbmx5IHVua25vd25bXSB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdGhpcyB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIHJhbmdlIHR5cGVzIGNhbiBiZSBpbmNsdXNpdmUgJ1snLCAnXScgb3IgZXhjbHVzaXZlICcoJywgJyknIHNvIGp1c3RcbiAgICAgIC8vIGtlZXAgaXQgc2ltcGxlIGFuZCBhY2NlcHQgYSBzdHJpbmdcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MuJHt2YWx1ZX1gKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIC8vIGFycmF5XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNzLnske3ZhbHVlLmpvaW4oJywnKX19YClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganNvblxuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjcy4ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgY29udGFpbmVkQnk8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBSZWFkb25seUFycmF5PFJvd1tDb2x1bW5OYW1lXT4gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICApOiB0aGlzXG4gIGNvbnRhaW5lZEJ5KGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgcmVhZG9ubHkgdW5rbm93bltdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB0aGlzXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGZvciBqc29uYiwgYXJyYXksIGFuZCByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcbiAgICogZXZlcnkgZWxlbWVudCBhcHBlYXJpbmcgaW4gYGNvbHVtbmAgaXMgY29udGFpbmVkIGJ5IGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBjb250YWluZWRCeShjb2x1bW46IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHJlYWRvbmx5IHVua25vd25bXSB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdGhpcyB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIHJhbmdlXG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLiR7dmFsdWV9YClcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAvLyBhcnJheVxuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjZC57JHt2YWx1ZS5qb2luKCcsJyl9fWApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGpzb25cbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY2QuJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJhbmdlR3Q8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICByYW5nZUd0KGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICogYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIGFueSBlbGVtZW50IGluIGByYW5nZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIHJhbmdlR3QoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYHNyLiR7cmFuZ2V9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmFuZ2VHdGU8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICByYW5nZUd0ZShjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXNcbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAqIGBjb2x1bW5gIGlzIGVpdGhlciBjb250YWluZWQgaW4gYHJhbmdlYCBvciBncmVhdGVyIHRoYW4gYW55IGVsZW1lbnQgaW5cbiAgICogYHJhbmdlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgcmFuZ2VHdGUoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG54bC4ke3JhbmdlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJhbmdlTHQ8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICByYW5nZUx0KGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICogYGNvbHVtbmAgaXMgbGVzcyB0aGFuIGFueSBlbGVtZW50IGluIGByYW5nZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICovXG4gIHJhbmdlTHQoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYHNsLiR7cmFuZ2V9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmFuZ2VMdGU8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICByYW5nZUx0ZShjb2x1bW46IHN0cmluZywgcmFuZ2U6IHN0cmluZyk6IHRoaXNcbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAqIGBjb2x1bW5gIGlzIGVpdGhlciBjb250YWluZWQgaW4gYHJhbmdlYCBvciBsZXNzIHRoYW4gYW55IGVsZW1lbnQgaW5cbiAgICogYHJhbmdlYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgKi9cbiAgcmFuZ2VMdGUoY29sdW1uOiBzdHJpbmcsIHJhbmdlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG54ci4ke3JhbmdlfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJhbmdlQWRqYWNlbnQ8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oY29sdW1uOiBDb2x1bW5OYW1lLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICByYW5nZUFkamFjZW50KGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzXG4gICAqIG11dHVhbGx5IGV4Y2x1c2l2ZSB0byBgcmFuZ2VgIGFuZCB0aGVyZSBjYW4gYmUgbm8gZWxlbWVudCBiZXR3ZWVuIHRoZSB0d29cbiAgICogcmFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICByYW5nZUFkamFjZW50KGNvbHVtbjogc3RyaW5nLCByYW5nZTogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBhZGouJHtyYW5nZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBvdmVybGFwczxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgdmFsdWU6IHN0cmluZyB8IFJlYWRvbmx5QXJyYXk8Um93W0NvbHVtbk5hbWVdPlxuICApOiB0aGlzXG4gIG92ZXJsYXBzKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgcmVhZG9ubHkgdW5rbm93bltdKTogdGhpc1xuICAvKipcbiAgICogT25seSByZWxldmFudCBmb3IgYXJyYXkgYW5kIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuICAgKiBgY29sdW1uYCBhbmQgYHZhbHVlYCBoYXZlIGFuIGVsZW1lbnQgaW4gY29tbW9uLlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGFycmF5IG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGFycmF5IG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAqL1xuICBvdmVybGFwcyhjb2x1bW46IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHJlYWRvbmx5IHVua25vd25bXSk6IHRoaXMge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyByYW5nZVxuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBvdi4ke3ZhbHVlfWApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFycmF5XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG92Lnske3ZhbHVlLmpvaW4oJywnKX19YClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRleHRTZWFyY2g8Q29sdW1uTmFtZSBleHRlbmRzIHN0cmluZyAmIGtleW9mIFJvdz4oXG4gICAgY29sdW1uOiBDb2x1bW5OYW1lLFxuICAgIHF1ZXJ5OiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgY29uZmlnPzogc3RyaW5nOyB0eXBlPzogJ3BsYWluJyB8ICdwaHJhc2UnIHwgJ3dlYnNlYXJjaCcgfVxuICApOiB0aGlzXG4gIHRleHRTZWFyY2goXG4gICAgY29sdW1uOiBzdHJpbmcsXG4gICAgcXVlcnk6IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyBjb25maWc/OiBzdHJpbmc7IHR5cGU/OiAncGxhaW4nIHwgJ3BocmFzZScgfCAnd2Vic2VhcmNoJyB9XG4gICk6IHRoaXNcbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgZm9yIHRleHQgYW5kIHRzdmVjdG9yIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuICAgKiBgY29sdW1uYCBtYXRjaGVzIHRoZSBxdWVyeSBzdHJpbmcgaW4gYHF1ZXJ5YC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSB0ZXh0IG9yIHRzdmVjdG9yIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRleHQgdG8gbWF0Y2ggd2l0aFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMuY29uZmlnIC0gVGhlIHRleHQgc2VhcmNoIGNvbmZpZ3VyYXRpb24gdG8gdXNlXG4gICAqIEBwYXJhbSBvcHRpb25zLnR5cGUgLSBDaGFuZ2UgaG93IHRoZSBgcXVlcnlgIHRleHQgaXMgaW50ZXJwcmV0ZWRcbiAgICovXG4gIHRleHRTZWFyY2goXG4gICAgY29sdW1uOiBzdHJpbmcsXG4gICAgcXVlcnk6IHN0cmluZyxcbiAgICB7IGNvbmZpZywgdHlwZSB9OiB7IGNvbmZpZz86IHN0cmluZzsgdHlwZT86ICdwbGFpbicgfCAncGhyYXNlJyB8ICd3ZWJzZWFyY2gnIH0gPSB7fVxuICApOiB0aGlzIHtcbiAgICBsZXQgdHlwZVBhcnQgPSAnJ1xuICAgIGlmICh0eXBlID09PSAncGxhaW4nKSB7XG4gICAgICB0eXBlUGFydCA9ICdwbCdcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdwaHJhc2UnKSB7XG4gICAgICB0eXBlUGFydCA9ICdwaCdcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd3ZWJzZWFyY2gnKSB7XG4gICAgICB0eXBlUGFydCA9ICd3J1xuICAgIH1cbiAgICBjb25zdCBjb25maWdQYXJ0ID0gY29uZmlnID09PSB1bmRlZmluZWQgPyAnJyA6IGAoJHtjb25maWd9KWBcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYCR7dHlwZVBhcnR9ZnRzJHtjb25maWdQYXJ0fS4ke3F1ZXJ5fWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG1hdGNoPENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KHF1ZXJ5OiBSZWNvcmQ8Q29sdW1uTmFtZSwgUm93W0NvbHVtbk5hbWVdPik6IHRoaXNcbiAgbWF0Y2gocXVlcnk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdGhpc1xuICAvKipcbiAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGVhY2ggY29sdW1uIGluIGBxdWVyeWAga2V5cyBpcyBlcXVhbCB0byBpdHNcbiAgICogYXNzb2NpYXRlZCB2YWx1ZS4gU2hvcnRoYW5kIGZvciBtdWx0aXBsZSBgLmVxKClgcy5cbiAgICpcbiAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIG9iamVjdCB0byBmaWx0ZXIgd2l0aCwgd2l0aCBjb2x1bW4gbmFtZXMgYXMga2V5cyBtYXBwZWRcbiAgICogdG8gdGhlaXIgZmlsdGVyIHZhbHVlc1xuICAgKi9cbiAgbWF0Y2gocXVlcnk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdGhpcyB7XG4gICAgT2JqZWN0LmVudHJpZXMocXVlcnkpLmZvckVhY2goKFtjb2x1bW4sIHZhbHVlXSkgPT4ge1xuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBlcS4ke3ZhbHVlfWApXG4gICAgfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbm90PENvbHVtbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBSb3c+KFxuICAgIGNvbHVtbjogQ29sdW1uTmFtZSxcbiAgICBvcGVyYXRvcjogRmlsdGVyT3BlcmF0b3IsXG4gICAgdmFsdWU6IFJvd1tDb2x1bW5OYW1lXVxuICApOiB0aGlzXG4gIG5vdChjb2x1bW46IHN0cmluZywgb3BlcmF0b3I6IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hpY2ggZG9lc24ndCBzYXRpc2Z5IHRoZSBmaWx0ZXIuXG4gICAqXG4gICAqIFVubGlrZSBtb3N0IGZpbHRlcnMsIGBvcGVhcmF0b3JgIGFuZCBgdmFsdWVgIGFyZSB1c2VkIGFzLWlzIGFuZCBuZWVkIHRvXG4gICAqIGZvbGxvdyBbUG9zdGdSRVNUXG4gICAqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG4gICAqIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBwcm9wZXJseSBzYW5pdGl6ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgKiBAcGFyYW0gb3BlcmF0b3IgLSBUaGUgb3BlcmF0b3IgdG8gYmUgbmVnYXRlZCB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nXG4gICAqIFBvc3RnUkVTVCBzeW50YXhcbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgKi9cbiAgbm90KGNvbHVtbjogc3RyaW5nLCBvcGVyYXRvcjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbm90LiR7b3BlcmF0b3J9LiR7dmFsdWV9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBzYXRpc2Z5IGF0IGxlYXN0IG9uZSBvZiB0aGUgZmlsdGVycy5cbiAgICpcbiAgICogVW5saWtlIG1vc3QgZmlsdGVycywgYGZpbHRlcnNgIGlzIHVzZWQgYXMtaXMgYW5kIG5lZWRzIHRvIGZvbGxvdyBbUG9zdGdSRVNUXG4gICAqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG4gICAqIHRvIG1ha2Ugc3VyZSBpdCdzIHByb3Blcmx5IHNhbml0aXplZC5cbiAgICpcbiAgICogSXQncyBjdXJyZW50bHkgbm90IHBvc3NpYmxlIHRvIGRvIGFuIGAub3IoKWAgZmlsdGVyIGFjcm9zcyBtdWx0aXBsZSB0YWJsZXMuXG4gICAqXG4gICAqIEBwYXJhbSBmaWx0ZXJzIC0gVGhlIGZpbHRlcnMgdG8gdXNlLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gZmlsdGVyIG9uIHJlZmVyZW5jZWQgdGFibGVzXG4gICAqIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYHJlZmVyZW5jZWRUYWJsZWAgaW5zdGVhZFxuICAgKi9cbiAgb3IoXG4gICAgZmlsdGVyczogc3RyaW5nLFxuICAgIHtcbiAgICAgIGZvcmVpZ25UYWJsZSxcbiAgICAgIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSxcbiAgICB9OiB7IGZvcmVpZ25UYWJsZT86IHN0cmluZzsgcmVmZXJlbmNlZFRhYmxlPzogc3RyaW5nIH0gPSB7fVxuICApOiB0aGlzIHtcbiAgICBjb25zdCBrZXkgPSByZWZlcmVuY2VkVGFibGUgPyBgJHtyZWZlcmVuY2VkVGFibGV9Lm9yYCA6ICdvcidcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgYCgke2ZpbHRlcnN9KWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGZpbHRlcjxDb2x1bW5OYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgUm93PihcbiAgICBjb2x1bW46IENvbHVtbk5hbWUsXG4gICAgb3BlcmF0b3I6IGAkeycnIHwgJ25vdC4nfSR7RmlsdGVyT3BlcmF0b3J9YCxcbiAgICB2YWx1ZTogdW5rbm93blxuICApOiB0aGlzXG4gIGZpbHRlcihjb2x1bW46IHN0cmluZywgb3BlcmF0b3I6IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB0aGlzXG4gIC8qKlxuICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hpY2ggc2F0aXNmeSB0aGUgZmlsdGVyLiBUaGlzIGlzIGFuIGVzY2FwZSBoYXRjaCAtIHlvdVxuICAgKiBzaG91bGQgdXNlIHRoZSBzcGVjaWZpYyBmaWx0ZXIgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZS5cbiAgICpcbiAgICogVW5saWtlIG1vc3QgZmlsdGVycywgYG9wZWFyYXRvcmAgYW5kIGB2YWx1ZWAgYXJlIHVzZWQgYXMtaXMgYW5kIG5lZWQgdG9cbiAgICogZm9sbG93IFtQb3N0Z1JFU1RcbiAgICogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcbiAgICogdG8gbWFrZSBzdXJlIHRoZXkgYXJlIHByb3Blcmx5IHNhbml0aXplZC5cbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAqIEBwYXJhbSBvcGVyYXRvciAtIFRoZSBvcGVyYXRvciB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgKi9cbiAgZmlsdGVyKGNvbHVtbjogc3RyaW5nLCBvcGVyYXRvcjogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHRoaXMge1xuICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgJHtvcGVyYXRvcn0uJHt2YWx1ZX1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cbiIsICJpbXBvcnQgUG9zdGdyZXN0QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0RmlsdGVyQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXInXG5pbXBvcnQgeyBHZXRSZXN1bHQgfSBmcm9tICcuL3NlbGVjdC1xdWVyeS1wYXJzZXIvcmVzdWx0J1xuaW1wb3J0IHsgRmV0Y2gsIEdlbmVyaWNTY2hlbWEsIEdlbmVyaWNUYWJsZSwgR2VuZXJpY1ZpZXcgfSBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8XG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEsXG4gIFJlbGF0aW9uIGV4dGVuZHMgR2VuZXJpY1RhYmxlIHwgR2VuZXJpY1ZpZXcsXG4gIFJlbGF0aW9uTmFtZSA9IHVua25vd24sXG4gIFJlbGF0aW9uc2hpcHMgPSBSZWxhdGlvbiBleHRlbmRzIHsgUmVsYXRpb25zaGlwczogaW5mZXIgUiB9ID8gUiA6IHVua25vd25cbj4ge1xuICB1cmw6IFVSTFxuICBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIHNjaGVtYT86IHN0cmluZ1xuICBzaWduYWw/OiBBYm9ydFNpZ25hbFxuICBmZXRjaD86IEZldGNoXG5cbiAgY29uc3RydWN0b3IoXG4gICAgdXJsOiBVUkwsXG4gICAge1xuICAgICAgaGVhZGVycyA9IHt9LFxuICAgICAgc2NoZW1hLFxuICAgICAgZmV0Y2gsXG4gICAgfToge1xuICAgICAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICAgIHNjaGVtYT86IHN0cmluZ1xuICAgICAgZmV0Y2g/OiBGZXRjaFxuICAgIH1cbiAgKSB7XG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWFcbiAgICB0aGlzLmZldGNoID0gZmV0Y2hcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgU0VMRUNUIHF1ZXJ5IG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1ucyAtIFRoZSBjb2x1bW5zIHRvIHJldHJpZXZlLCBzZXBhcmF0ZWQgYnkgY29tbWFzLiBDb2x1bW5zIGNhbiBiZSByZW5hbWVkIHdoZW4gcmV0dXJuZWQgd2l0aCBgY3VzdG9tTmFtZTpjb2x1bW5OYW1lYFxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgKiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIGluIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgKlxuICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAqIGhvb2QuXG4gICAqXG4gICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAqXG4gICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICogbnVtYmVycy5cbiAgICovXG4gIHNlbGVjdDxcbiAgICBRdWVyeSBleHRlbmRzIHN0cmluZyA9ICcqJyxcbiAgICBSZXN1bHRPbmUgPSBHZXRSZXN1bHQ8U2NoZW1hLCBSZWxhdGlvblsnUm93J10sIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcywgUXVlcnk+XG4gID4oXG4gICAgY29sdW1ucz86IFF1ZXJ5LFxuICAgIHtcbiAgICAgIGhlYWQgPSBmYWxzZSxcbiAgICAgIGNvdW50LFxuICAgIH06IHtcbiAgICAgIGhlYWQ/OiBib29sZWFuXG4gICAgICBjb3VudD86ICdleGFjdCcgfCAncGxhbm5lZCcgfCAnZXN0aW1hdGVkJ1xuICAgIH0gPSB7fVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBSZXN1bHRPbmVbXSwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgY29uc3QgbWV0aG9kID0gaGVhZCA/ICdIRUFEJyA6ICdHRVQnXG4gICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2VzIGV4Y2VwdCB3aGVuIHF1b3RlZFxuICAgIGxldCBxdW90ZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNsZWFuZWRDb2x1bW5zID0gKGNvbHVtbnMgPz8gJyonKVxuICAgICAgLnNwbGl0KCcnKVxuICAgICAgLm1hcCgoYykgPT4ge1xuICAgICAgICBpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSB7XG4gICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICBxdW90ZWQgPSAhcXVvdGVkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH0pXG4gICAgICAuam9pbignJylcbiAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZWxlY3QnLCBjbGVhbmVkQ29sdW1ucylcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBgY291bnQ9JHtjb3VudH1gXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICB9IGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxSZXN1bHRPbmVbXT4pXG4gIH1cblxuICAvLyBUT0RPKHYzKTogTWFrZSBgZGVmYXVsdFRvTnVsbGAgY29uc2lzdGVudCBmb3IgYm90aCBzaW5nbGUgJiBidWxrIGluc2VydHMuXG4gIGluc2VydDxSb3cgZXh0ZW5kcyBSZWxhdGlvbiBleHRlbmRzIHsgSW5zZXJ0OiB1bmtub3duIH0gPyBSZWxhdGlvblsnSW5zZXJ0J10gOiBuZXZlcj4oXG4gICAgdmFsdWVzOiBSb3csXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBudWxsLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+XG4gIGluc2VydDxSb3cgZXh0ZW5kcyBSZWxhdGlvbiBleHRlbmRzIHsgSW5zZXJ0OiB1bmtub3duIH0gPyBSZWxhdGlvblsnSW5zZXJ0J10gOiBuZXZlcj4oXG4gICAgdmFsdWVzOiBSb3dbXSxcbiAgICBvcHRpb25zPzoge1xuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICAgIGRlZmF1bHRUb051bGw/OiBib29sZWFuXG4gICAgfVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBudWxsLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+XG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIElOU0VSVCBpbnRvIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBpbnNlcnRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcbiAgICogd2l0aCBgLnNlbGVjdCgpYC5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gaW5zZXJ0LiBQYXNzIGFuIG9iamVjdCB0byBpbnNlcnQgYSBzaW5nbGUgcm93XG4gICAqIG9yIGFuIGFycmF5IHRvIGluc2VydCBtdWx0aXBsZSByb3dzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGluc2VydGVkIHJvd3MuXG4gICAqXG4gICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICogaG9vZC5cbiAgICpcbiAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICpcbiAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgKiBudW1iZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cbiAgICogT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIE9ubHkgYXBwbGllcyBmb3IgYnVsa1xuICAgKiBpbnNlcnRzLlxuICAgKi9cbiAgaW5zZXJ0PFJvdyBleHRlbmRzIFJlbGF0aW9uIGV4dGVuZHMgeyBJbnNlcnQ6IHVua25vd24gfSA/IFJlbGF0aW9uWydJbnNlcnQnXSA6IG5ldmVyPihcbiAgICB2YWx1ZXM6IFJvdyB8IFJvd1tdLFxuICAgIHtcbiAgICAgIGNvdW50LFxuICAgICAgZGVmYXVsdFRvTnVsbCA9IHRydWUsXG4gICAgfToge1xuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICAgIGRlZmF1bHRUb051bGw/OiBib29sZWFuXG4gICAgfSA9IHt9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8U2NoZW1hLCBSZWxhdGlvblsnUm93J10sIG51bGwsIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcz4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJ1xuXG4gICAgY29uc3QgcHJlZmVyc0hlYWRlcnMgPSBbXVxuICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pXG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaChgY291bnQ9JHtjb3VudH1gKVxuICAgIH1cbiAgICBpZiAoIWRlZmF1bHRUb051bGwpIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2goJ21pc3Npbmc9ZGVmYXVsdCcpXG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJylcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYy5jb25jYXQoT2JqZWN0LmtleXMoeCkpLCBbXSBhcyBzdHJpbmdbXSlcbiAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdW5pcXVlQ29sdW1ucyA9IFsuLi5uZXcgU2V0KGNvbHVtbnMpXS5tYXAoKGNvbHVtbikgPT4gYFwiJHtjb2x1bW59XCJgKVxuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdjb2x1bW5zJywgdW5pcXVlQ29sdW1ucy5qb2luKCcsJykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgYm9keTogdmFsdWVzLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICB9IGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxudWxsPilcbiAgfVxuXG4gIC8vIFRPRE8odjMpOiBNYWtlIGBkZWZhdWx0VG9OdWxsYCBjb25zaXN0ZW50IGZvciBib3RoIHNpbmdsZSAmIGJ1bGsgdXBzZXJ0cy5cbiAgdXBzZXJ0PFJvdyBleHRlbmRzIFJlbGF0aW9uIGV4dGVuZHMgeyBJbnNlcnQ6IHVua25vd24gfSA/IFJlbGF0aW9uWydJbnNlcnQnXSA6IG5ldmVyPihcbiAgICB2YWx1ZXM6IFJvdyxcbiAgICBvcHRpb25zPzoge1xuICAgICAgb25Db25mbGljdD86IHN0cmluZ1xuICAgICAgaWdub3JlRHVwbGljYXRlcz86IGJvb2xlYW5cbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfVxuICApOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyPFNjaGVtYSwgUmVsYXRpb25bJ1JvdyddLCBudWxsLCBSZWxhdGlvbk5hbWUsIFJlbGF0aW9uc2hpcHM+XG4gIHVwc2VydDxSb3cgZXh0ZW5kcyBSZWxhdGlvbiBleHRlbmRzIHsgSW5zZXJ0OiB1bmtub3duIH0gPyBSZWxhdGlvblsnSW5zZXJ0J10gOiBuZXZlcj4oXG4gICAgdmFsdWVzOiBSb3dbXSxcbiAgICBvcHRpb25zPzoge1xuICAgICAgb25Db25mbGljdD86IHN0cmluZ1xuICAgICAgaWdub3JlRHVwbGljYXRlcz86IGJvb2xlYW5cbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgICBkZWZhdWx0VG9OdWxsPzogYm9vbGVhblxuICAgIH1cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxTY2hlbWEsIFJlbGF0aW9uWydSb3cnXSwgbnVsbCwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPlxuICAvKipcbiAgICogUGVyZm9ybSBhbiBVUFNFUlQgb24gdGhlIHRhYmxlIG9yIHZpZXcuIERlcGVuZGluZyBvbiB0aGUgY29sdW1uKHMpIHBhc3NlZFxuICAgKiB0byBgb25Db25mbGljdGAsIGAudXBzZXJ0KClgIGFsbG93cyB5b3UgdG8gcGVyZm9ybSB0aGUgZXF1aXZhbGVudCBvZlxuICAgKiBgLmluc2VydCgpYCBpZiBhIHJvdyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGBvbkNvbmZsaWN0YCBjb2x1bW5zIGRvZXNuJ3RcbiAgICogZXhpc3QsIG9yIGlmIGl0IGRvZXMgZXhpc3QsIHBlcmZvcm0gYW4gYWx0ZXJuYXRpdmUgYWN0aW9uIGRlcGVuZGluZyBvblxuICAgKiBgaWdub3JlRHVwbGljYXRlc2AuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHVwc2VydGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuICAgKiB3aXRoIGAuc2VsZWN0KClgLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cHNlcnQgd2l0aC4gUGFzcyBhbiBvYmplY3QgdG8gdXBzZXJ0IGFcbiAgICogc2luZ2xlIHJvdyBvciBhbiBhcnJheSB0byB1cHNlcnQgbXVsdGlwbGUgcm93cy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLm9uQ29uZmxpY3QgLSBDb21tYS1zZXBhcmF0ZWQgVU5JUVVFIGNvbHVtbihzKSB0byBzcGVjaWZ5IGhvd1xuICAgKiBkdXBsaWNhdGUgcm93cyBhcmUgZGV0ZXJtaW5lZC4gVHdvIHJvd3MgYXJlIGR1cGxpY2F0ZXMgaWYgYWxsIHRoZVxuICAgKiBgb25Db25mbGljdGAgY29sdW1ucyBhcmUgZXF1YWwuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgLSBJZiBgdHJ1ZWAsIGR1cGxpY2F0ZSByb3dzIGFyZSBpZ25vcmVkLiBJZlxuICAgKiBgZmFsc2VgLCBkdXBsaWNhdGUgcm93cyBhcmUgbWVyZ2VkIHdpdGggZXhpc3Rpbmcgcm93cy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwc2VydGVkIHJvd3MuXG4gICAqXG4gICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICogaG9vZC5cbiAgICpcbiAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICpcbiAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgKiBudW1iZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cbiAgICogT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIFRoaXMgb25seSBhcHBsaWVzIHdoZW5cbiAgICogaW5zZXJ0aW5nIG5ldyByb3dzLCBub3Qgd2hlbiBtZXJnaW5nIHdpdGggZXhpc3Rpbmcgcm93cyB1bmRlclxuICAgKiBgaWdub3JlRHVwbGljYXRlczogZmFsc2VgLiBUaGlzIGFsc28gb25seSBhcHBsaWVzIHdoZW4gZG9pbmcgYnVsayB1cHNlcnRzLlxuICAgKi9cbiAgdXBzZXJ0PFJvdyBleHRlbmRzIFJlbGF0aW9uIGV4dGVuZHMgeyBJbnNlcnQ6IHVua25vd24gfSA/IFJlbGF0aW9uWydJbnNlcnQnXSA6IG5ldmVyPihcbiAgICB2YWx1ZXM6IFJvdyB8IFJvd1tdLFxuICAgIHtcbiAgICAgIG9uQ29uZmxpY3QsXG4gICAgICBpZ25vcmVEdXBsaWNhdGVzID0gZmFsc2UsXG4gICAgICBjb3VudCxcbiAgICAgIGRlZmF1bHRUb051bGwgPSB0cnVlLFxuICAgIH06IHtcbiAgICAgIG9uQ29uZmxpY3Q/OiBzdHJpbmdcbiAgICAgIGlnbm9yZUR1cGxpY2F0ZXM/OiBib29sZWFuXG4gICAgICBjb3VudD86ICdleGFjdCcgfCAncGxhbm5lZCcgfCAnZXN0aW1hdGVkJ1xuICAgICAgZGVmYXVsdFRvTnVsbD86IGJvb2xlYW5cbiAgICB9ID0ge31cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxTY2hlbWEsIFJlbGF0aW9uWydSb3cnXSwgbnVsbCwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnXG5cbiAgICBjb25zdCBwcmVmZXJzSGVhZGVycyA9IFtgcmVzb2x1dGlvbj0ke2lnbm9yZUR1cGxpY2F0ZXMgPyAnaWdub3JlJyA6ICdtZXJnZSd9LWR1cGxpY2F0ZXNgXVxuXG4gICAgaWYgKG9uQ29uZmxpY3QgIT09IHVuZGVmaW5lZCkgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldCgnb25fY29uZmxpY3QnLCBvbkNvbmZsaWN0KVxuICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pXG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaChgY291bnQ9JHtjb3VudH1gKVxuICAgIH1cbiAgICBpZiAoIWRlZmF1bHRUb051bGwpIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2goJ21pc3Npbmc9ZGVmYXVsdCcpXG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJylcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYy5jb25jYXQoT2JqZWN0LmtleXMoeCkpLCBbXSBhcyBzdHJpbmdbXSlcbiAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdW5pcXVlQ29sdW1ucyA9IFsuLi5uZXcgU2V0KGNvbHVtbnMpXS5tYXAoKGNvbHVtbikgPT4gYFwiJHtjb2x1bW59XCJgKVxuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdjb2x1bW5zJywgdW5pcXVlQ29sdW1ucy5qb2luKCcsJykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgYm9keTogdmFsdWVzLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICB9IGFzIHVua25vd24gYXMgUG9zdGdyZXN0QnVpbGRlcjxudWxsPilcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIFVQREFURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdXBkYXRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcbiAgICogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cGRhdGUgd2l0aFxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwZGF0ZWQgcm93cy5cbiAgICpcbiAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgKiBob29kLlxuICAgKlxuICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgKlxuICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAqIG51bWJlcnMuXG4gICAqL1xuICB1cGRhdGU8Um93IGV4dGVuZHMgUmVsYXRpb24gZXh0ZW5kcyB7IFVwZGF0ZTogdW5rbm93biB9ID8gUmVsYXRpb25bJ1VwZGF0ZSddIDogbmV2ZXI+KFxuICAgIHZhbHVlczogUm93LFxuICAgIHtcbiAgICAgIGNvdW50LFxuICAgIH06IHtcbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfSA9IHt9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8U2NoZW1hLCBSZWxhdGlvblsnUm93J10sIG51bGwsIFJlbGF0aW9uTmFtZSwgUmVsYXRpb25zaGlwcz4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdQQVRDSCdcbiAgICBjb25zdCBwcmVmZXJzSGVhZGVycyA9IFtdXG4gICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2godGhpcy5oZWFkZXJzWydQcmVmZXInXSlcbiAgICB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApXG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJylcblxuICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgIGJvZHk6IHZhbHVlcyxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgfSBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8bnVsbD4pXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhIERFTEVURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgZGVsZXRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcbiAgICogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGRlbGV0ZWQgcm93cy5cbiAgICpcbiAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgKiBob29kLlxuICAgKlxuICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgKlxuICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAqIG51bWJlcnMuXG4gICAqL1xuICBkZWxldGUoe1xuICAgIGNvdW50LFxuICB9OiB7XG4gICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgfSA9IHt9KTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxTY2hlbWEsIFJlbGF0aW9uWydSb3cnXSwgbnVsbCwgUmVsYXRpb25OYW1lLCBSZWxhdGlvbnNoaXBzPiB7XG4gICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSdcbiAgICBjb25zdCBwcmVmZXJzSGVhZGVycyA9IFtdXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApXG4gICAgfVxuICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICBwcmVmZXJzSGVhZGVycy51bnNoaWZ0KHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pXG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJylcblxuICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgfSBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8bnVsbD4pXG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcxLjE3LjExJ1xuIiwgImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nXG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBwb3N0Z3Jlc3QtanMvJHt2ZXJzaW9ufWAgfVxuIiwgImltcG9ydCBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgZnJvbSAnLi9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0RmlsdGVyQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEJ1aWxkZXInXG5pbXBvcnQgeyBERUZBVUxUX0hFQURFUlMgfSBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB7IEZldGNoLCBHZW5lcmljU2NoZW1hIH0gZnJvbSAnLi90eXBlcydcblxuLyoqXG4gKiBQb3N0Z1JFU1QgY2xpZW50LlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0YWJhc2UgLSBUeXBlcyBmb3IgdGhlIHNjaGVtYSBmcm9tIHRoZSBbdHlwZVxuICogZ2VuZXJhdG9yXShodHRwczovL3N1cGFiYXNlLmNvbS9kb2NzL3JlZmVyZW5jZS9qYXZhc2NyaXB0L25leHQvdHlwZXNjcmlwdC1zdXBwb3J0KVxuICpcbiAqIEB0eXBlUGFyYW0gU2NoZW1hTmFtZSAtIFBvc3RncmVzIHNjaGVtYSB0byBzd2l0Y2ggdG8uIE11c3QgYmUgYSBzdHJpbmdcbiAqIGxpdGVyYWwsIHRoZSBzYW1lIG9uZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiBJZiB0aGUgc2NoZW1hIGlzIG5vdFxuICogYFwicHVibGljXCJgLCB0aGlzIG11c3QgYmUgc3VwcGxpZWQgbWFudWFsbHkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RncmVzdENsaWVudDxcbiAgRGF0YWJhc2UgPSBhbnksXG4gIFNjaGVtYU5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSA9ICdwdWJsaWMnIGV4dGVuZHMga2V5b2YgRGF0YWJhc2VcbiAgICA/ICdwdWJsaWMnXG4gICAgOiBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSxcbiAgU2NoZW1hIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSA9IERhdGFiYXNlW1NjaGVtYU5hbWVdIGV4dGVuZHMgR2VuZXJpY1NjaGVtYVxuICAgID8gRGF0YWJhc2VbU2NoZW1hTmFtZV1cbiAgICA6IGFueVxuPiB7XG4gIHVybDogc3RyaW5nXG4gIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgc2NoZW1hTmFtZT86IFNjaGVtYU5hbWVcbiAgZmV0Y2g/OiBGZXRjaFxuXG4gIC8vIFRPRE86IEFkZCBiYWNrIHNob3VsZFRocm93T25FcnJvciBvbmNlIHdlIGZpZ3VyZSBvdXQgdGhlIHR5cGluZ3NcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQb3N0Z1JFU1QgY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0gdXJsIC0gVVJMIG9mIHRoZSBQb3N0Z1JFU1QgZW5kcG9pbnRcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgLSBDdXN0b20gaGVhZGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5zY2hlbWEgLSBQb3N0Z3JlcyBzY2hlbWEgdG8gc3dpdGNoIHRvXG4gICAqIEBwYXJhbSBvcHRpb25zLmZldGNoIC0gQ3VzdG9tIGZldGNoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICB1cmw6IHN0cmluZyxcbiAgICB7XG4gICAgICBoZWFkZXJzID0ge30sXG4gICAgICBzY2hlbWEsXG4gICAgICBmZXRjaCxcbiAgICB9OiB7XG4gICAgICBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgICAgc2NoZW1hPzogU2NoZW1hTmFtZVxuICAgICAgZmV0Y2g/OiBGZXRjaFxuICAgIH0gPSB7fVxuICApIHtcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMuaGVhZGVycyA9IHsgLi4uREVGQVVMVF9IRUFERVJTLCAuLi5oZWFkZXJzIH1cbiAgICB0aGlzLnNjaGVtYU5hbWUgPSBzY2hlbWFcbiAgICB0aGlzLmZldGNoID0gZmV0Y2hcbiAgfVxuXG4gIGZyb208XG4gICAgVGFibGVOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgU2NoZW1hWydUYWJsZXMnXSxcbiAgICBUYWJsZSBleHRlbmRzIFNjaGVtYVsnVGFibGVzJ11bVGFibGVOYW1lXVxuICA+KHJlbGF0aW9uOiBUYWJsZU5hbWUpOiBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8U2NoZW1hLCBUYWJsZSwgVGFibGVOYW1lPlxuICBmcm9tPFZpZXdOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgU2NoZW1hWydWaWV3cyddLCBWaWV3IGV4dGVuZHMgU2NoZW1hWydWaWV3cyddW1ZpZXdOYW1lXT4oXG4gICAgcmVsYXRpb246IFZpZXdOYW1lXG4gICk6IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjxTY2hlbWEsIFZpZXcsIFZpZXdOYW1lPlxuICAvKipcbiAgICogUGVyZm9ybSBhIHF1ZXJ5IG9uIGEgdGFibGUgb3IgYSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gcmVsYXRpb24gLSBUaGUgdGFibGUgb3IgdmlldyBuYW1lIHRvIHF1ZXJ5XG4gICAqL1xuICBmcm9tKHJlbGF0aW9uOiBzdHJpbmcpOiBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8U2NoZW1hLCBhbnksIGFueT4ge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9LyR7cmVsYXRpb259YClcbiAgICByZXR1cm4gbmV3IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcih1cmwsIHtcbiAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzIH0sXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hTmFtZSxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGEgc2NoZW1hIHRvIHF1ZXJ5IG9yIHBlcmZvcm0gYW4gZnVuY3Rpb24gKHJwYykgY2FsbC5cbiAgICpcbiAgICogVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuICAgKlxuICAgKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSB0byBxdWVyeVxuICAgKi9cbiAgc2NoZW1hPER5bmFtaWNTY2hlbWEgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZT4oXG4gICAgc2NoZW1hOiBEeW5hbWljU2NoZW1hXG4gICk6IFBvc3RncmVzdENsaWVudDxcbiAgICBEYXRhYmFzZSxcbiAgICBEeW5hbWljU2NoZW1hLFxuICAgIERhdGFiYXNlW0R5bmFtaWNTY2hlbWFdIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSA/IERhdGFiYXNlW0R5bmFtaWNTY2hlbWFdIDogYW55XG4gID4ge1xuICAgIHJldHVybiBuZXcgUG9zdGdyZXN0Q2xpZW50KHRoaXMudXJsLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWEsXG4gICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBmdW5jdGlvbiBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gbmFtZSB0byBjYWxsXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBjYWxsXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG4gICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICogQHBhcmFtIG9wdGlvbnMuZ2V0IC0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aFxuICAgKiByZWFkLW9ubHkgYWNjZXNzIG1vZGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIHJldHVybmVkIGJ5IHRoZVxuICAgKiBmdW5jdGlvbi4gT25seSBhcHBsaWNhYmxlIGZvciBbc2V0LXJldHVybmluZ1xuICAgKiBmdW5jdGlvbnNdKGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9mdW5jdGlvbnMtc3JmLmh0bWwpLlxuICAgKlxuICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAqIGhvb2QuXG4gICAqXG4gICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAqXG4gICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICogbnVtYmVycy5cbiAgICovXG4gIHJwYzxGbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBTY2hlbWFbJ0Z1bmN0aW9ucyddLCBGbiBleHRlbmRzIFNjaGVtYVsnRnVuY3Rpb25zJ11bRm5OYW1lXT4oXG4gICAgZm46IEZuTmFtZSxcbiAgICBhcmdzOiBGblsnQXJncyddID0ge30sXG4gICAge1xuICAgICAgaGVhZCA9IGZhbHNlLFxuICAgICAgZ2V0ID0gZmFsc2UsXG4gICAgICBjb3VudCxcbiAgICB9OiB7XG4gICAgICBoZWFkPzogYm9vbGVhblxuICAgICAgZ2V0PzogYm9vbGVhblxuICAgICAgY291bnQ/OiAnZXhhY3QnIHwgJ3BsYW5uZWQnIHwgJ2VzdGltYXRlZCdcbiAgICB9ID0ge31cbiAgKTogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjxcbiAgICBTY2hlbWEsXG4gICAgRm5bJ1JldHVybnMnXSBleHRlbmRzIGFueVtdXG4gICAgICA/IEZuWydSZXR1cm5zJ11bbnVtYmVyXSBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gICAgICAgID8gRm5bJ1JldHVybnMnXVtudW1iZXJdXG4gICAgICAgIDogbmV2ZXJcbiAgICAgIDogbmV2ZXIsXG4gICAgRm5bJ1JldHVybnMnXSxcbiAgICBGbk5hbWUsXG4gICAgbnVsbFxuICA+IHtcbiAgICBsZXQgbWV0aG9kOiAnSEVBRCcgfCAnR0VUJyB8ICdQT1NUJ1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9L3JwYy8ke2ZufWApXG4gICAgbGV0IGJvZHk6IHVua25vd24gfCB1bmRlZmluZWRcbiAgICBpZiAoaGVhZCB8fCBnZXQpIHtcbiAgICAgIG1ldGhvZCA9IGhlYWQgPyAnSEVBRCcgOiAnR0VUJ1xuICAgICAgT2JqZWN0LmVudHJpZXMoYXJncylcbiAgICAgICAgLy8gcGFyYW1zIHdpdGggdW5kZWZpbmVkIHZhbHVlIG5lZWRzIHRvIGJlIGZpbHRlcmVkIG91dCwgb3RoZXJ3aXNlIGl0J2xsXG4gICAgICAgIC8vIHNob3cgdXAgYXMgYD9wYXJhbT11bmRlZmluZWRgXG4gICAgICAgIC5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIC8vIGFycmF5IHZhbHVlcyBuZWVkIHNwZWNpYWwgc3ludGF4XG4gICAgICAgIC5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IFtuYW1lLCBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGB7JHt2YWx1ZS5qb2luKCcsJyl9fWAgOiBgJHt2YWx1ZX1gXSlcbiAgICAgICAgLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbWV0aG9kID0gJ1BPU1QnXG4gICAgICBib2R5ID0gYXJnc1xuICAgIH1cblxuICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXMuaGVhZGVycyB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBoZWFkZXJzWydQcmVmZXInXSA9IGBjb3VudD0ke2NvdW50fWBcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuICAgICAgbWV0aG9kLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWFOYW1lLFxuICAgICAgYm9keSxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgfSBhcyB1bmtub3duIGFzIFBvc3RncmVzdEJ1aWxkZXI8Rm5bJ1JldHVybnMnXT4pXG4gIH1cbn1cbiIsICIvLyBBbHdheXMgdXBkYXRlIHdyYXBwZXIubWpzIHdoZW4gdXBkYXRpbmcgdGhpcyBmaWxlLlxuaW1wb3J0IFBvc3RncmVzdENsaWVudCBmcm9tICcuL1Bvc3RncmVzdENsaWVudCdcbmltcG9ydCBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgZnJvbSAnLi9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0RmlsdGVyQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0QnVpbGRlciBmcm9tICcuL1Bvc3RncmVzdEJ1aWxkZXInXG5pbXBvcnQgUG9zdGdyZXN0RXJyb3IgZnJvbSAnLi9Qb3N0Z3Jlc3RFcnJvcidcblxuZXhwb3J0IHtcbiAgUG9zdGdyZXN0Q2xpZW50LFxuICBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIsXG4gIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsXG4gIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIsXG4gIFBvc3RncmVzdEJ1aWxkZXIsXG4gIFBvc3RncmVzdEVycm9yLFxufVxuZXhwb3J0IGRlZmF1bHQge1xuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbiAgUG9zdGdyZXN0QnVpbGRlcixcbiAgUG9zdGdyZXN0RXJyb3IsXG59XG5leHBvcnQgdHlwZSB7XG4gIFBvc3RncmVzdFJlc3BvbnNlLFxuICBQb3N0Z3Jlc3RSZXNwb25zZUZhaWx1cmUsXG4gIFBvc3RncmVzdFJlc3BvbnNlU3VjY2VzcyxcbiAgUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2UsXG4gIFBvc3RncmVzdE1heWJlU2luZ2xlUmVzcG9uc2UsXG59IGZyb20gJy4vdHlwZXMnXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy81NTFcbi8vIFRvIGJlIHJlcGxhY2VkIHdpdGggYSBoZWxwZXIgdHlwZSB0aGF0IG9ubHkgdXNlcyBwdWJsaWMgdHlwZXNcbmV4cG9ydCB0eXBlIHsgR2V0UmVzdWx0IGFzIFVuc3RhYmxlR2V0UmVzdWx0IH0gZnJvbSAnLi9zZWxlY3QtcXVlcnktcGFyc2VyL3Jlc3VsdCdcbiIsICIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3dzIGRvZXMgbm90IHdvcmsgaW4gdGhlIGJyb3dzZXIuIEJyb3dzZXIgY2xpZW50cyBtdXN0IHVzZSB0aGUgbmF0aXZlICcgK1xuICAgICAgJ1dlYlNvY2tldCBvYmplY3QnXG4gICk7XG59O1xuIiwgIi8vIHNyYy9tYWluLnRzXG5pbXBvcnQgeyBQbHVnaW4sIFRGaWxlLCBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBTdXBhYmFzZVNlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL1N1cGFiYXNlU2VydmljZSc7XG5pbXBvcnQgeyBPcGVuQUlTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy9PcGVuQUlTZXJ2aWNlJztcbmltcG9ydCB7IFF1ZXVlU2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvUXVldWVTZXJ2aWNlJztcbmltcG9ydCB7IEZpbGVUcmFja2VyIH0gZnJvbSAnLi91dGlscy9GaWxlVHJhY2tlcic7XG5pbXBvcnQgeyBFcnJvckhhbmRsZXIgfSBmcm9tICcuL3V0aWxzL0Vycm9ySGFuZGxlcic7XG5pbXBvcnQgeyBOb3RpZmljYXRpb25NYW5hZ2VyIH0gZnJvbSAnLi91dGlscy9Ob3RpZmljYXRpb25NYW5hZ2VyJztcbmltcG9ydCB7IE1pbmRNYXRyaXhTZXR0aW5nc1RhYiB9IGZyb20gJy4vc2V0dGluZ3MvU2V0dGluZ3NUYWInO1xuaW1wb3J0IHsgU3luY0ZpbGVNYW5hZ2VyIH0gZnJvbSAnLi9zZXJ2aWNlcy9TeW5jRmlsZU1hbmFnZXInO1xuaW1wb3J0IHsgSW5pdGlhbFN5bmNNYW5hZ2VyIH0gZnJvbSAnLi9zZXJ2aWNlcy9Jbml0aWFsU3luY01hbmFnZXInO1xuaW1wb3J0IHsgTWV0YWRhdGFFeHRyYWN0b3IgfSBmcm9tICcuL3NlcnZpY2VzL01ldGFkYXRhRXh0cmFjdG9yJztcbmltcG9ydCB7IFN0YXR1c01hbmFnZXIsIFBsdWdpblN0YXR1cyB9IGZyb20gJy4vc2VydmljZXMvU3RhdHVzTWFuYWdlcic7XG5pbXBvcnQgeyBTeW5jRGV0ZWN0aW9uTWFuYWdlciB9IGZyb20gJy4vc2VydmljZXMvU3luY0RldGVjdGlvbk1hbmFnZXInO1xuaW1wb3J0IHtcblx0TWluZE1hdHJpeFNldHRpbmdzLFxuXHRERUZBVUxUX1NFVFRJTkdTLFxuXHRpc1ZhdWx0SW5pdGlhbGl6ZWQsXG5cdGdlbmVyYXRlVmF1bHRJZCxcblx0Z2V0QWxsRXhjbHVzaW9ucyxcblx0U1lTVEVNX0VYQ0xVU0lPTlNcbn0gZnJvbSAnLi9zZXR0aW5ncy9TZXR0aW5ncyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1pbmRNYXRyaXhQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuXHRzZXR0aW5nczogTWluZE1hdHJpeFNldHRpbmdzO1xuXHRwcml2YXRlIHN1cGFiYXNlU2VydmljZTogU3VwYWJhc2VTZXJ2aWNlIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgb3BlbkFJU2VydmljZTogT3BlbkFJU2VydmljZSB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIHF1ZXVlU2VydmljZTogUXVldWVTZXJ2aWNlIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgZmlsZVRyYWNrZXI6IEZpbGVUcmFja2VyIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXIgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBub3RpZmljYXRpb25NYW5hZ2VyOiBOb3RpZmljYXRpb25NYW5hZ2VyIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgaXNJbml0aWFsaXppbmcgPSBmYWxzZTtcblx0cHJpdmF0ZSBzeW5jTWFuYWdlcjogU3luY0ZpbGVNYW5hZ2VyIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgc3luY0NoZWNrSW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgaW5pdGlhbGl6YXRpb25UaW1lb3V0OiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIHN5bmNDaGVja0F0dGVtcHRzID0gMDtcblx0cHJpdmF0ZSBpbml0aWFsU3luY01hbmFnZXI6IEluaXRpYWxTeW5jTWFuYWdlciB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIG1ldGFkYXRhRXh0cmFjdG9yOiBNZXRhZGF0YUV4dHJhY3RvciB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIHN0YXR1c01hbmFnZXI6IFN0YXR1c01hbmFnZXIgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBzeW5jRGV0ZWN0aW9uTWFuYWdlcjogU3luY0RldGVjdGlvbk1hbmFnZXIgfCBudWxsID0gbnVsbDtcblxuXHRhc3luYyBvbmxvYWQoKSB7XG5cdFx0Y29uc29sZS5sb2coJ0xvYWRpbmcgTWluZCBNYXRyaXggUGx1Z2luLi4uJyk7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIEluaXRpYWxpemUgc3RhdHVzIG1hbmFnZXIgZmlyc3Rcblx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlciA9IG5ldyBTdGF0dXNNYW5hZ2VyKHRoaXMuYWRkU3RhdHVzQmFySXRlbSgpKTtcblx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlci5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLklOSVRJQUxJWklORywge1xuXHRcdFx0XHRtZXNzYWdlOiAnTG9hZGluZyBNaW5kIE1hdHJpeCBQbHVnaW4uLi4nXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gTG9hZCBzZXR0aW5nc1xuXHRcdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBjb3JlIHNlcnZpY2VzIGFuZCB2YXVsdCBpZiBuZWVkZWRcblx0XHRcdGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUNvcmVTZXJ2aWNlcygpO1xuXHRcdFx0YXdhaXQgdGhpcy5pbml0aWFsaXplVmF1bHRJZk5lZWRlZCgpO1xuXG5cdFx0XHQvLyBBZGQgc2V0dGluZ3MgdGFiXG5cdFx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IE1pbmRNYXRyaXhTZXR0aW5nc1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG5cdFx0XHRpZiAoaXNWYXVsdEluaXRpYWxpemVkKHRoaXMuc2V0dGluZ3MpKSB7XG5cdFx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlci5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLldBSVRJTkdfRk9SX1NZTkMsIHtcblx0XHRcdFx0XHRtZXNzYWdlOiAnV2FpdGluZyBmb3IgT2JzaWRpYW4gc3luYyB0byBzZXR0bGUuLi4nXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQvLyBDcmVhdGUgYW5kIHN0YXJ0IHN5bmMgZGV0ZWN0aW9uIHdpdGggaW1wcm92ZWQgbG9nZ2luZ1xuXHRcdFx0XHR0aGlzLnN5bmNEZXRlY3Rpb25NYW5hZ2VyID0gbmV3IFN5bmNEZXRlY3Rpb25NYW5hZ2VyKFxuXHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0dGhpcy5zdGF0dXNNYW5hZ2VyLFxuXHRcdFx0XHRcdHRoaXMub25TeW5jUXVpZXRQZXJpb2RSZWFjaGVkLmJpbmQodGhpcylcblx0XHRcdFx0KTtcblx0XHRcdFx0dGhpcy5zeW5jRGV0ZWN0aW9uTWFuYWdlci5zdGFydE1vbml0b3JpbmcoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMuY29tcGxldGVJbml0aWFsaXphdGlvbigpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBNaW5kIE1hdHJpeCBQbHVnaW46JywgZXJyb3IpO1xuXHRcdFx0dGhpcy5zdGF0dXNNYW5hZ2VyPy5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLkVSUk9SLCB7XG5cdFx0XHRcdG1lc3NhZ2U6ICdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBwbHVnaW4uIENoZWNrIGNvbnNvbGUgZm9yIGRldGFpbHMuJyxcblx0XHRcdFx0ZXJyb3I6IGVycm9yIGFzIEVycm9yXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIG9uU3luY1F1aWV0UGVyaW9kUmVhY2hlZCgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gU3RvcCBtb25pdG9yaW5nIGFzIHdlJ3ZlIHJlYWNoZWQgYSBxdWlldCBwZXJpb2Rcblx0XHRcdHRoaXMuc3luY0RldGVjdGlvbk1hbmFnZXI/LnN0b3BNb25pdG9yaW5nKCk7XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuQ0hFQ0tJTkdfRklMRSwge1xuXHRcdFx0XHRtZXNzYWdlOiAnSW5pdGlhbGl6aW5nIHN5bmMgbWFuYWdlciB3aXRoIHVwZGF0ZWQgc3luYyBmaWxlIGZvcm1hdC4uLidcblx0XHRcdH0pO1xuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBzeW5jIG1hbmFnZXJcblx0XHRcdGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVN5bmNNYW5hZ2VyKCk7XG5cdFx0XHQvLyBTdGFydCBzeW5jIHByb2Nlc3Ncblx0XHRcdGF3YWl0IHRoaXMuc3RhcnRTeW5jUHJvY2VzcygpO1xuXHRcdFx0Ly8gQ29tcGxldGUgcmVtYWluaW5nIGluaXRpYWxpemF0aW9uXG5cdFx0XHRhd2FpdCB0aGlzLmNvbXBsZXRlSW5pdGlhbGl6YXRpb24oKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIHF1aWV0IHBlcmlvZCBpbml0aWFsaXphdGlvbjonLCBlcnJvcik7XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuRVJST1IsIHtcblx0XHRcdFx0bWVzc2FnZTogJ0ZhaWxlZCB0byBpbml0aWFsaXplIGFmdGVyIHN5bmMgcXVpZXQgcGVyaW9kJyxcblx0XHRcdFx0ZXJyb3I6IGVycm9yIGFzIEVycm9yXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGNvbXBsZXRlSW5pdGlhbGl6YXRpb24oKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzIGFuZCBjb21tYW5kc1xuXHRcdFx0dGhpcy5yZWdpc3RlckV2ZW50SGFuZGxlcnMoKTtcblx0XHRcdHRoaXMuYWRkQ29tbWFuZHMoKTtcblx0XHRcdC8vIFVwZGF0ZSBzdGF0dXMgdG8gcmVhZHlcblx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlcj8uc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5SRUFEWSwge1xuXHRcdFx0XHRtZXNzYWdlOiAnTWluZCBNYXRyaXggaXMgcmVhZHknXG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgY29tcGxldGluZyBpbml0aWFsaXphdGlvbjonLCBlcnJvcik7XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuRVJST1IsIHtcblx0XHRcdFx0bWVzc2FnZTogJ0ZhaWxlZCB0byBjb21wbGV0ZSBpbml0aWFsaXphdGlvbicsXG5cdFx0XHRcdGVycm9yOiBlcnJvciBhcyBFcnJvclxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgb251bmxvYWQoKSB7XG5cdFx0Y29uc29sZS5sb2coJ1VubG9hZGluZyBNaW5kIE1hdHJpeCBQbHVnaW4uLi4nKTtcblx0XHQvLyBTdG9wIHN5bmMgZGV0ZWN0aW9uIGFuZCBjbGVhciBhbnkgaW50ZXJ2YWxzL3RpbWVvdXRzXG5cdFx0dGhpcy5zeW5jRGV0ZWN0aW9uTWFuYWdlcj8uc3RvcE1vbml0b3JpbmcoKTtcblx0XHRpZiAodGhpcy5pbml0aWFsaXphdGlvblRpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLmluaXRpYWxpemF0aW9uVGltZW91dCk7XG5cdFx0aWYgKHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwpIGNsZWFySW50ZXJ2YWwodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCk7XG5cdFx0dGhpcy5xdWV1ZVNlcnZpY2U/LnN0b3AoKTtcblx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXI/LmNsZWFyKCk7XG5cdFx0dGhpcy5pbml0aWFsU3luY01hbmFnZXI/LnN0b3AoKTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgc3RhcnRTeW5jUHJvY2VzcygpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuc3luY01hbmFnZXIpIHRocm93IG5ldyBFcnJvcignU3luYyBtYW5hZ2VyIG5vdCBpbml0aWFsaXplZCcpO1xuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLnN0YXR1c01hbmFnZXI/LnNldFN0YXR1cyhQbHVnaW5TdGF0dXMuQ0hFQ0tJTkdfRklMRSwge1xuXHRcdFx0XHRtZXNzYWdlOiAnQ2hlY2tpbmcgc3luYyBmaWxlIHN0YXR1cyB3aXRoIG5ldyBzdHJ1Y3R1cmUuLi4nXG5cdFx0XHR9KTtcblx0XHRcdGNvbnN0IHN5bmNTdGF0dXMgPSBhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLnZhbGlkYXRlU3luY1N0YXRlKCk7XG5cdFx0XHRpZiAoIXN5bmNTdGF0dXMuaXNWYWxpZCkge1xuXHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5zeW5jLnJlcXVpcmVTeW5jKSB7XG5cdFx0XHRcdFx0dGhpcy5zdGF0dXNNYW5hZ2VyPy5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLkVSUk9SLCB7XG5cdFx0XHRcdFx0XHRtZXNzYWdlOiBgU3luYyB2YWxpZGF0aW9uIGZhaWxlZDogJHtzeW5jU3RhdHVzLmVycm9yfWBcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFN5bmMgdmFsaWRhdGlvbiBmYWlsZWQ6ICR7c3luY1N0YXR1cy5lcnJvcn1gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oYFN5bmMgdmFsaWRhdGlvbiB3YXJuaW5nOiAke3N5bmNTdGF0dXMuZXJyb3J9YCk7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgU3luYyB3YXJuaW5nOiAke3N5bmNTdGF0dXMuZXJyb3J9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlcj8uc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5JTklUSUFMSVpJTkcsIHtcblx0XHRcdFx0bWVzc2FnZTogJ0luaXRpYWxpemluZyBzZXJ2aWNlcy4uLidcblx0XHRcdH0pO1xuXHRcdFx0YXdhaXQgdGhpcy5pbml0aWFsaXplU2VydmljZXMoKTtcblx0XHRcdC8vIFN0YXJ0IHBlcmlvZGljIHN5bmMgY2hlY2tzXG5cdFx0XHR0aGlzLnN0YXJ0UGVyaW9kaWNTeW5jQ2hlY2tzKCk7XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5pbml0aWFsU3luYy5lbmFibGVBdXRvSW5pdGlhbFN5bmMgJiYgdGhpcy5pbml0aWFsU3luY01hbmFnZXIpIHtcblx0XHRcdFx0dGhpcy5zdGF0dXNNYW5hZ2VyPy5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLklOSVRJQUxJWklORywge1xuXHRcdFx0XHRcdG1lc3NhZ2U6ICdTdGFydGluZyBpbml0aWFsIHZhdWx0IHN5bmMuLi4nXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRhd2FpdCB0aGlzLmluaXRpYWxTeW5jTWFuYWdlci5zdGFydFN5bmMoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlcj8uc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5SRUFEWSwge1xuXHRcdFx0XHRtZXNzYWdlOiAnU3luYyBwcm9jZXNzIGNvbXBsZXRlZCdcblx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5zeW5jLnJlcXVpcmVTeW5jKSB7XG5cdFx0XHRcdHRoaXMuc3RhdHVzTWFuYWdlcj8uc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5FUlJPUiwge1xuXHRcdFx0XHRcdG1lc3NhZ2U6ICdTeW5jIHByb2Nlc3MgZmFpbGVkJyxcblx0XHRcdFx0XHRlcnJvcjogZXJyb3IgYXMgRXJyb3Jcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignU3luYyBwcm9jZXNzIGVycm9yOicsIGVycm9yKTtcblx0XHRcdFx0bmV3IE5vdGljZSgnU3luYyBwcm9jZXNzIGVycm9yLiBDb250aW51aW5nIHdpdGggbGltaXRlZCBmdW5jdGlvbmFsaXR5LicpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLmluaXRpYWxpemVTZXJ2aWNlcygpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZVN5bmNNYW5hZ2VyKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghdGhpcy5lcnJvckhhbmRsZXIpIHRocm93IG5ldyBFcnJvcignRXJyb3IgaGFuZGxlciBtdXN0IGJlIGluaXRpYWxpemVkIGJlZm9yZSBzeW5jIG1hbmFnZXInKTtcblx0XHRpZiAoIXRoaXMuc2V0dGluZ3MudmF1bHRJZCkge1xuXHRcdFx0dGhpcy5zZXR0aW5ncy52YXVsdElkID0gZ2VuZXJhdGVWYXVsdElkKCk7XG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0dGhpcy5zeW5jTWFuYWdlciA9IG5ldyBTeW5jRmlsZU1hbmFnZXIoXG5cdFx0XHRcdHRoaXMuYXBwLnZhdWx0LFxuXHRcdFx0XHR0aGlzLmVycm9ySGFuZGxlcixcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5zeW5jLnN5bmNGaWxlUGF0aCxcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5zeW5jLmJhY2t1cEludGVydmFsLFxuXHRcdFx0XHR0aGlzLnNldHRpbmdzLnZhdWx0SWQsXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3luYy5kZXZpY2VJZCxcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5zeW5jLmRldmljZU5hbWUsXG5cdFx0XHRcdHRoaXMubWFuaWZlc3QudmVyc2lvblxuXHRcdFx0KTtcblx0XHRcdGF3YWl0IHRoaXMuc3luY01hbmFnZXIuaW5pdGlhbGl6ZSgpO1xuXHRcdFx0Y29uc29sZS5sb2coJ1N5bmMgbWFuYWdlciBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHkgd2l0aCBuZXcgc3luYyBmaWxlIGZvcm1hdCcpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBzeW5jIG1hbmFnZXI6JywgZXJyb3IpO1xuXHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuZW5hYmxlTm90aWZpY2F0aW9ucykgbmV3IE5vdGljZSgnRmFpbGVkIHRvIGluaXRpYWxpemUgc3luYyBzeXN0ZW0uIFNvbWUgZmVhdHVyZXMgbWF5IGJlIHVuYXZhaWxhYmxlLicpO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBpbml0aWFsaXplQ29yZVNlcnZpY2VzKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRoaXMuc3RhdHVzTWFuYWdlcj8uc2V0U3RhdHVzKFBsdWdpblN0YXR1cy5JTklUSUFMSVpJTkcsIHsgbWVzc2FnZTogJ0luaXRpYWxpemluZyBjb3JlIHNlcnZpY2VzLi4uJyB9KTtcblx0XHQvLyBJbml0aWFsaXplIGVycm9yIGhhbmRsZXJcblx0XHR0aGlzLmVycm9ySGFuZGxlciA9IG5ldyBFcnJvckhhbmRsZXIodGhpcy5zZXR0aW5ncz8uZGVidWcgPz8gREVGQVVMVF9TRVRUSU5HUy5kZWJ1ZywgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5nZXRCYXNlUGF0aCgpKTtcblx0XHQvLyBJbml0aWFsaXplIG5vdGlmaWNhdGlvbiBtYW5hZ2VyXG5cdFx0dGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyID0gbmV3IE5vdGlmaWNhdGlvbk1hbmFnZXIodGhpcy5hZGRTdGF0dXNCYXJJdGVtKCksIHRoaXMuc2V0dGluZ3M/LmVuYWJsZU5vdGlmaWNhdGlvbnMgPz8gdHJ1ZSwgdGhpcy5zZXR0aW5ncz8uZW5hYmxlUHJvZ3Jlc3NCYXIgPz8gdHJ1ZSk7XG5cdFx0dGhpcy5zdGF0dXNNYW5hZ2VyPy5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLklOSVRJQUxJWklORywgeyBtZXNzYWdlOiAnQ29yZSBzZXJ2aWNlcyBpbml0aWFsaXplZCcgfSk7XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcblx0XHQvLyBFbnN1cmUgZXhjbHVzaW9ucyBoYXZlIHRoZSBleHBlY3RlZCBzdHJ1Y3R1cmVcblx0XHRpZiAoIXRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucykgdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zID0geyAuLi5ERUZBVUxUX1NFVFRJTkdTLmV4Y2x1c2lvbnMgfTtcblx0XHRpZiAoIXRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZvbGRlcnMpIHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZvbGRlcnMgPSBbXTtcblx0XHRpZiAoIXRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcykgdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVR5cGVzID0gW107XG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlUHJlZml4ZXMpIHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVQcmVmaXhlcyA9IFtdO1xuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMpIHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVzID0gW107XG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuc3lzdGVtRXhjbHVkZWRGb2xkZXJzKSB0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuc3lzdGVtRXhjbHVkZWRGb2xkZXJzID0gWy4uLlNZU1RFTV9FWENMVVNJT05TLmZvbGRlcnNdO1xuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLnN5c3RlbUV4Y2x1ZGVkRmlsZVR5cGVzKSB0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuc3lzdGVtRXhjbHVkZWRGaWxlVHlwZXMgPSBbLi4uU1lTVEVNX0VYQ0xVU0lPTlMuZmlsZVR5cGVzXTtcblx0XHRpZiAoIXRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5zeXN0ZW1FeGNsdWRlZEZpbGVQcmVmaXhlcykgdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLnN5c3RlbUV4Y2x1ZGVkRmlsZVByZWZpeGVzID0gWy4uLlNZU1RFTV9FWENMVVNJT05TLmZpbGVQcmVmaXhlc107XG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMuc3lzdGVtRXhjbHVkZWRGaWxlcykgdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLnN5c3RlbUV4Y2x1ZGVkRmlsZXMgPSBbLi4uU1lTVEVNX0VYQ0xVU0lPTlMuZmlsZXNdO1xuXHR9XG5cblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG5cdFx0Ly8gVXBkYXRlIHNlcnZpY2Ugc2V0dGluZ3MgYWZ0ZXIgc2F2aW5nXG5cdFx0dGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyPy51cGRhdGVTZXR0aW5ncyh0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMsIHRoaXMuc2V0dGluZ3MuZW5hYmxlUHJvZ3Jlc3NCYXIpO1xuXHRcdHRoaXMuZXJyb3JIYW5kbGVyPy51cGRhdGVTZXR0aW5ncyh0aGlzLnNldHRpbmdzLmRlYnVnKTtcblx0XHRpZiAoaXNWYXVsdEluaXRpYWxpemVkKHRoaXMuc2V0dGluZ3MpKSBhd2FpdCB0aGlzLmluaXRpYWxpemVTZXJ2aWNlcygpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGFydFBlcmlvZGljU3luY0NoZWNrcygpOiB2b2lkIHtcblx0XHRpZiAodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCkgY2xlYXJJbnRlcnZhbCh0aGlzLnN5bmNDaGVja0ludGVydmFsKTtcblx0XHR0aGlzLnN5bmNDaGVja0ludGVydmFsID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuXHRcdFx0YXdhaXQgdGhpcy5wZXJmb3JtU3luY0NoZWNrKCk7XG5cdFx0fSwgdGhpcy5zZXR0aW5ncy5zeW5jLmNoZWNrSW50ZXJ2YWwpO1xuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBwZXJmb3JtU3luY0NoZWNrKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghdGhpcy5zeW5jTWFuYWdlcikgcmV0dXJuO1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBzeW5jU3RhdHVzID0gYXdhaXQgdGhpcy5zeW5jTWFuYWdlci52YWxpZGF0ZVN5bmNTdGF0ZSgpO1xuXHRcdFx0aWYgKCFzeW5jU3RhdHVzLmlzVmFsaWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKGBTeW5jIGNoZWNrIGZhaWxlZDogJHtzeW5jU3RhdHVzLmVycm9yfWApO1xuXHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSBuZXcgTm90aWNlKGBTeW5jIGlzc3VlIGRldGVjdGVkOiAke3N5bmNTdGF0dXMuZXJyb3J9YCk7XG5cdFx0XHRcdGNvbnN0IHJlY292ZXJlZCA9IGF3YWl0IHRoaXMuc3luY01hbmFnZXIuYXR0ZW1wdFJlY292ZXJ5KCk7XG5cdFx0XHRcdGlmICghcmVjb3ZlcmVkICYmIHRoaXMuc2V0dGluZ3Muc3luYy5yZXF1aXJlU3luYykgYXdhaXQgdGhpcy5yZXN0YXJ0U2VydmljZXMoKTtcblx0XHRcdH1cblx0XHRcdGF3YWl0IHRoaXMuc3luY01hbmFnZXIudXBkYXRlTGFzdFN5bmMoKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXI/LmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdwZXJmb3JtU3luY0NoZWNrJywgbWV0YWRhdGE6IHsgdGltZXN0YW1wOiBEYXRlLm5vdygpIH0gfSk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyByZXN0YXJ0U2VydmljZXMoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dGhpcy5xdWV1ZVNlcnZpY2U/LnN0b3AoKTtcblx0XHRpZiAodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCkgY2xlYXJJbnRlcnZhbCh0aGlzLnN5bmNDaGVja0ludGVydmFsKTtcblx0XHR0cnkge1xuXHRcdFx0YXdhaXQgdGhpcy5pbml0aWFsaXplU3luY01hbmFnZXIoKTtcblx0XHRcdGF3YWl0IHRoaXMuc3RhcnRTeW5jUHJvY2VzcygpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcmVzdGFydCBzZXJ2aWNlczonLCBlcnJvcik7XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSBuZXcgTm90aWNlKCdGYWlsZWQgdG8gcmVzdGFydCBzZXJ2aWNlcyBhZnRlciBzeW5jIGVycm9yJyk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBpbml0aWFsaXplVmF1bHRJZk5lZWRlZCgpIHtcblx0XHRpZiAodGhpcy5pc0luaXRpYWxpemluZykgcmV0dXJuO1xuXHRcdHRoaXMuaXNJbml0aWFsaXppbmcgPSB0cnVlO1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIWlzVmF1bHRJbml0aWFsaXplZCh0aGlzLnNldHRpbmdzKSkge1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLnZhdWx0SWQgPSBnZW5lcmF0ZVZhdWx0SWQoKTtcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5sYXN0S25vd25WYXVsdE5hbWUgPSB0aGlzLmFwcC52YXVsdC5nZXROYW1lKCk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMpIG5ldyBOb3RpY2UoJ1ZhdWx0IGluaXRpYWxpemVkIHdpdGggbmV3IElEJyk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MubGFzdEtub3duVmF1bHROYW1lICE9PSB0aGlzLmFwcC52YXVsdC5nZXROYW1lKCkpIHtcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5sYXN0S25vd25WYXVsdE5hbWUgPSB0aGlzLmFwcC52YXVsdC5nZXROYW1lKCk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRoaXMuaXNJbml0aWFsaXppbmcgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGluaXRpYWxpemVTZXJ2aWNlcygpIHtcblx0XHRjb25zb2xlLmxvZygnSW5pdGlhbGl6aW5nIHNlcnZpY2VzLi4uJywgeyBoYXNWYXVsdDogISF0aGlzLmFwcC52YXVsdCwgaGFzRXJyb3JIYW5kbGVyOiAhIXRoaXMuZXJyb3JIYW5kbGVyIH0pO1xuXHRcdGlmICghdGhpcy5lcnJvckhhbmRsZXIpIHRocm93IG5ldyBFcnJvcignQ29yZSBzZXJ2aWNlcyBub3QgaW5pdGlhbGl6ZWQnKTtcblx0XHR0cnkge1xuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBGaWxlVHJhY2tlciB3aXRoIHJlZmluZWQgY2hhbmdlIGRldGVjdGlvbiBhbmQgZGVib3VuY2luZy5cblx0XHRcdHRoaXMuZmlsZVRyYWNrZXIgPSBuZXcgRmlsZVRyYWNrZXIodGhpcy5hcHAudmF1bHQsIHRoaXMuZXJyb3JIYW5kbGVyLCB0aGlzLnNldHRpbmdzLnN5bmMuc3luY0ZpbGVQYXRoKTtcblx0XHRcdGF3YWl0IHRoaXMuZmlsZVRyYWNrZXIuaW5pdGlhbGl6ZSgpO1xuXHRcdFx0Y29uc29sZS5sb2coJ0ZpbGVUcmFja2VyIGluaXRpYWxpemVkLicpO1xuXG5cdFx0XHQvLyBJbml0aWFsaXplIFN1cGFiYXNlIHNlcnZpY2Vcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuc3VwYWJhc2VTZXJ2aWNlID0gYXdhaXQgU3VwYWJhc2VTZXJ2aWNlLmdldEluc3RhbmNlKHRoaXMuc2V0dGluZ3MpO1xuXHRcdFx0XHRpZiAoIXRoaXMuc3VwYWJhc2VTZXJ2aWNlKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnU3VwYWJhc2Ugc2VydmljZSBub3QgaW5pdGlhbGl6ZWQuIFBsZWFzZSBjb25maWd1cmUgeW91ciBBUEkgc2V0dGluZ3MuJyk7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignU3VwYWJhc2Ugc2VydmljZSBpbml0aWFsaXphdGlvbiBmYWlsZWQ6IE1pc3NpbmcgY29uZmlndXJhdGlvbi4nKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc29sZS5sb2coJ1N1cGFiYXNlIHNlcnZpY2UgaW5pdGlhbGl6ZWQuJyk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBpbml0aWFsaXphdGlvbiBlcnJvcjonLCBlcnJvcik7XG5cdFx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byBpbml0aWFsaXplIFN1cGFiYXNlIHNlcnZpY2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbml0aWFsaXplIE9wZW5BSSBzZXJ2aWNlXG5cdFx0XHR0aGlzLm9wZW5BSVNlcnZpY2UgPSBuZXcgT3BlbkFJU2VydmljZSh0aGlzLnNldHRpbmdzLm9wZW5haSwgdGhpcy5lcnJvckhhbmRsZXIpO1xuXHRcdFx0Y29uc29sZS5sb2coJ09wZW5BSSBzZXJ2aWNlIGluaXRpYWxpemVkLicpO1xuXG5cdFx0XHRpZiAoIXRoaXMuYXBwLnZhdWx0KSB0aHJvdyBuZXcgRXJyb3IoJ1ZhdWx0IGlzIG5vdCBhdmFpbGFibGUnKTtcblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBxdWV1ZSBzZXJ2aWNlIHdpdGggaW1wcm92ZWQgY29sbGlzaW9uIGhhbmRsaW5nIGFuZCBwcm9ncmVzcyByZXBvcnRpbmcuXG5cdFx0XHRpZiAodGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyICYmIHRoaXMuc3VwYWJhc2VTZXJ2aWNlICYmIHRoaXMub3BlbkFJU2VydmljZSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHRoaXMucXVldWVTZXJ2aWNlID0gbmV3IFF1ZXVlU2VydmljZShcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MucXVldWUubWF4Q29uY3VycmVudCxcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MucXVldWUucmV0cnlBdHRlbXB0cyxcblx0XHRcdFx0XHRcdHRoaXMuc3VwYWJhc2VTZXJ2aWNlLFxuXHRcdFx0XHRcdFx0dGhpcy5vcGVuQUlTZXJ2aWNlLFxuXHRcdFx0XHRcdFx0dGhpcy5lcnJvckhhbmRsZXIsXG5cdFx0XHRcdFx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIsXG5cdFx0XHRcdFx0XHR0aGlzLmFwcC52YXVsdCxcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuY2h1bmtpbmdcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHRoaXMucXVldWVTZXJ2aWNlLnN0YXJ0KCk7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ1F1ZXVlIHNlcnZpY2UgaW5pdGlhbGl6ZWQgYW5kIHN0YXJ0ZWQuJyk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgUXVldWVTZXJ2aWNlOicsIGVycm9yKTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBxdWV1ZSBzZXJ2aWNlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgc2VydmljZXMgbm90IGF2YWlsYWJsZSBmb3IgUXVldWVTZXJ2aWNlIGluaXRpYWxpemF0aW9uJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWV0YWRhdGFFeHRyYWN0b3IgPSBuZXcgTWV0YWRhdGFFeHRyYWN0b3IoKTtcblx0XHRcdGNvbnNvbGUubG9nKCdNZXRhZGF0YUV4dHJhY3RvciBpbml0aWFsaXplZC4nKTtcblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBJbml0aWFsU3luY01hbmFnZXJcblx0XHRcdGlmICh0aGlzLnF1ZXVlU2VydmljZSAmJiB0aGlzLnN5bmNNYW5hZ2VyICYmIHRoaXMubWV0YWRhdGFFeHRyYWN0b3IpIHtcblx0XHRcdFx0Y29uc3QgaW5pdGlhbFN5bmNPcHRpb25zID0ge1xuXHRcdFx0XHRcdC4uLnRoaXMuc2V0dGluZ3MuaW5pdGlhbFN5bmMsXG5cdFx0XHRcdFx0c3luY0ZpbGVQYXRoOiB0aGlzLnNldHRpbmdzLnN5bmMuc3luY0ZpbGVQYXRoLFxuXHRcdFx0XHRcdGV4Y2x1c2lvbnM6IGdldEFsbEV4Y2x1c2lvbnModGhpcy5zZXR0aW5ncylcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5pbml0aWFsU3luY01hbmFnZXIgPSBuZXcgSW5pdGlhbFN5bmNNYW5hZ2VyKFxuXHRcdFx0XHRcdHRoaXMuYXBwLnZhdWx0LFxuXHRcdFx0XHRcdHRoaXMucXVldWVTZXJ2aWNlLFxuXHRcdFx0XHRcdHRoaXMuc3luY01hbmFnZXIsXG5cdFx0XHRcdFx0dGhpcy5tZXRhZGF0YUV4dHJhY3Rvcixcblx0XHRcdFx0XHR0aGlzLmVycm9ySGFuZGxlcixcblx0XHRcdFx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIsXG5cdFx0XHRcdFx0dGhpcy5zdXBhYmFzZVNlcnZpY2UsXG5cdFx0XHRcdFx0aW5pdGlhbFN5bmNPcHRpb25zXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdJbml0aWFsU3luY01hbmFnZXIgaW5pdGlhbGl6ZWQuJyk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIHNlcnZpY2VzOicsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgY2hlY2tSZXF1aXJlZENvbmZpZ3VyYXRpb25zKCk6IHZvaWQge1xuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5vcGVuYWkuYXBpS2V5KSB7XG5cdFx0XHRuZXcgTm90aWNlKCdPcGVuQUkgQVBJIGtleSBpcyBtaXNzaW5nLiBBSSBmZWF0dXJlcyBhcmUgZGlzYWJsZWQuIENvbmZpZ3VyZSBpdCBpbiB0aGUgc2V0dGluZ3MuJyk7XG5cdFx0fVxuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5zdXBhYmFzZS51cmwgfHwgIXRoaXMuc2V0dGluZ3Muc3VwYWJhc2UuYXBpS2V5KSB7XG5cdFx0XHRuZXcgTm90aWNlKCdTdXBhYmFzZSBjb25maWd1cmF0aW9uIGlzIGluY29tcGxldGUuIERhdGFiYXNlIGZlYXR1cmVzIGFyZSBkaXNhYmxlZC4gQ29uZmlndXJlIGl0IGluIHRoZSBzZXR0aW5ncy4nKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHJlZ2lzdGVyRXZlbnRIYW5kbGVycygpIHtcblx0XHQvLyBFbmhhbmNlZCBmaWxlIGV2ZW50IGhhbmRsZXJzIHdpdGggaW1wcm92ZWQgZGVib3VuY2luZyBhbmQgbG9nZ2luZ1xuXG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50KFxuXHRcdFx0dGhpcy5hcHAudmF1bHQub24oJ2NyZWF0ZScsIGFzeW5jIChmaWxlKSA9PiB7XG5cdFx0XHRcdGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHJldHVybjtcblx0XHRcdFx0aWYgKCEoYXdhaXQgdGhpcy5lbnN1cmVTeW5jRmlsZUV4aXN0cygpKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0ZhaWxlZCB0byBjcmVhdGUgc3luYyBmaWxlLiBQbHVnaW4gZnVuY3Rpb25hbGl0eSBsaW1pdGVkLicpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRoaXMuc2hvdWxkUHJvY2Vzc0ZpbGUoZmlsZSkpIHJldHVybjtcblx0XHRcdFx0Y29uc29sZS5sb2coYEZpbGUgY3JlYXRlZDogJHtmaWxlLnBhdGh9YCk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuZmlsZVRyYWNrZXI/LmhhbmRsZUNyZWF0ZShmaWxlKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5xdWV1ZUZpbGVQcm9jZXNzaW5nKGZpbGUsICdDUkVBVEUnKTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXHRcdHRoaXMucmVnaXN0ZXJFdmVudChcblx0XHRcdHRoaXMuYXBwLnZhdWx0Lm9uKCdtb2RpZnknLCBhc3luYyAoZmlsZSkgPT4ge1xuXHRcdFx0XHRpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSByZXR1cm47XG5cdFx0XHRcdGlmICghKGF3YWl0IHRoaXMuZW5zdXJlU3luY0ZpbGVFeGlzdHMoKSkpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKCdGYWlsZWQgdG8gY3JlYXRlIHN5bmMgZmlsZS4gUGx1Z2luIGZ1bmN0aW9uYWxpdHkgbGltaXRlZC4nKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0aGlzLnNob3VsZFByb2Nlc3NGaWxlKGZpbGUpKSByZXR1cm47XG5cdFx0XHRcdGNvbnNvbGUubG9nKGBGaWxlIG1vZGlmaWVkOiAke2ZpbGUucGF0aH1gKTtcblx0XHRcdFx0Ly8gRW5oYW5jZWQgZGVib3VuY2luZyBpcyBoYW5kbGVkIGluIEZpbGVUcmFja2VyLmhhbmRsZU1vZGlmeVxuXHRcdFx0XHRhd2FpdCB0aGlzLmZpbGVUcmFja2VyPy5oYW5kbGVNb2RpZnkoZmlsZSk7XG5cdFx0XHRcdGF3YWl0IHRoaXMucXVldWVGaWxlUHJvY2Vzc2luZyhmaWxlLCAnVVBEQVRFJyk7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQoXG5cdFx0XHR0aGlzLmFwcC52YXVsdC5vbignZGVsZXRlJywgYXN5bmMgKGZpbGUpID0+IHtcblx0XHRcdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkgcmV0dXJuO1xuXHRcdFx0XHRpZiAoZmlsZS5wYXRoID09PSB0aGlzLnNldHRpbmdzLnN5bmMuc3luY0ZpbGVQYXRoKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ1N5bmMgZmlsZSB3YXMgZGVsZXRlZCwgd2lsbCByZWNyZWF0ZSBvbiBuZXh0IG9wZXJhdGlvbicpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIShhd2FpdCB0aGlzLmVuc3VyZVN5bmNGaWxlRXhpc3RzKCkpKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnRmFpbGVkIHRvIGNyZWF0ZSBzeW5jIGZpbGUuIFBsdWdpbiBmdW5jdGlvbmFsaXR5IGxpbWl0ZWQuJyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5zaG91bGRQcm9jZXNzRmlsZShmaWxlKSkgcmV0dXJuO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhgRmlsZSBkZWxldGVkOiAke2ZpbGUucGF0aH1gKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5maWxlVHJhY2tlcj8uaGFuZGxlRGVsZXRlKGZpbGUpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnF1ZXVlRmlsZVByb2Nlc3NpbmcoZmlsZSwgJ0RFTEVURScpO1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50KFxuXHRcdFx0dGhpcy5hcHAudmF1bHQub24oJ3JlbmFtZScsIGFzeW5jIChmaWxlLCBvbGRQYXRoKSA9PiB7XG5cdFx0XHRcdGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHJldHVybjtcblx0XHRcdFx0aWYgKCEoYXdhaXQgdGhpcy5lbnN1cmVTeW5jRmlsZUV4aXN0cygpKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0ZhaWxlZCB0byBjcmVhdGUgc3luYyBmaWxlLiBQbHVnaW4gZnVuY3Rpb25hbGl0eSBsaW1pdGVkLicpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRoaXMuc2hvdWxkUHJvY2Vzc0ZpbGUoZmlsZSkpIHJldHVybjtcblx0XHRcdFx0Y29uc29sZS5sb2coYEZpbGUgcmVuYW1lZCBmcm9tICR7b2xkUGF0aH0gdG8gJHtmaWxlLnBhdGh9YCk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuZmlsZVRyYWNrZXI/LmhhbmRsZVJlbmFtZShmaWxlLCBvbGRQYXRoKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5oYW5kbGVGaWxlUmVuYW1lKGZpbGUsIG9sZFBhdGgpO1xuXHRcdFx0fSlcblx0XHQpO1xuXHR9XG5cblx0cHJpdmF0ZSBzaG91bGRQcm9jZXNzRmlsZShmaWxlOiBURmlsZSk6IGJvb2xlYW4ge1xuXHRcdGlmICghdGhpcy5xdWV1ZVNlcnZpY2UgfHwgIWlzVmF1bHRJbml0aWFsaXplZCh0aGlzLnNldHRpbmdzKSkgcmV0dXJuIGZhbHNlO1xuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5lbmFibGVBdXRvU3luYykgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Y29uc3QgYWxsRXhjbHVzaW9ucyA9IGdldEFsbEV4Y2x1c2lvbnModGhpcy5zZXR0aW5ncyk7XG5cdFx0Y29uc3QgZmlsZVBhdGggPSBmaWxlLnBhdGg7XG5cdFx0Y29uc3QgZmlsZU5hbWUgPSBmaWxlLm5hbWU7XG5cblx0XHRpZiAoZmlsZVBhdGggPT09IHRoaXMuc2V0dGluZ3Muc3luYy5zeW5jRmlsZVBhdGggfHwgZmlsZVBhdGggPT09IHRoaXMuc2V0dGluZ3Muc3luYy5zeW5jRmlsZVBhdGggKyAnLmJhY2t1cCcpIHtcblx0XHRcdGNvbnNvbGUubG9nKGBTa2lwcGluZyBzeW5jIGZpbGU6ICR7ZmlsZVBhdGh9YCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmIChBcnJheS5pc0FycmF5KGFsbEV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlcykgJiYgYWxsRXhjbHVzaW9ucy5leGNsdWRlZEZpbGVzLmluY2x1ZGVzKGZpbGVOYW1lKSkge1xuXHRcdFx0Y29uc29sZS5sb2coJ1NraXBwaW5nIGV4Y2x1ZGVkIGZpbGU6JywgZmlsZU5hbWUpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoQXJyYXkuaXNBcnJheShhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRm9sZGVycykpIHtcblx0XHRcdGNvbnN0IGlzRXhjbHVkZWRGb2xkZXIgPSBhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRm9sZGVycy5zb21lKGZvbGRlciA9PiB7XG5cdFx0XHRcdGNvbnN0IG5vcm1hbGl6ZWRGb2xkZXIgPSBmb2xkZXIuZW5kc1dpdGgoJy8nKSA/IGZvbGRlciA6IGZvbGRlciArICcvJztcblx0XHRcdFx0cmV0dXJuIGZpbGVQYXRoLnN0YXJ0c1dpdGgobm9ybWFsaXplZEZvbGRlcik7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChpc0V4Y2x1ZGVkRm9sZGVyKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdTa2lwcGluZyBmaWxlIGluIGV4Y2x1ZGVkIGZvbGRlcjonLCBmaWxlUGF0aCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoYWxsRXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcykpIHtcblx0XHRcdGNvbnN0IGlzRXhjbHVkZWRUeXBlID0gYWxsRXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcy5zb21lKGV4dCA9PiBmaWxlUGF0aC50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dC50b0xvd2VyQ2FzZSgpKSk7XG5cdFx0XHRpZiAoaXNFeGNsdWRlZFR5cGUpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ1NraXBwaW5nIGV4Y2x1ZGVkIGZpbGUgdHlwZTonLCBmaWxlUGF0aCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoYWxsRXhjbHVzaW9ucy5leGNsdWRlZEZpbGVQcmVmaXhlcykpIHtcblx0XHRcdGNvbnN0IGlzRXhjbHVkZWRQcmVmaXggPSBhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVByZWZpeGVzLnNvbWUocHJlZml4ID0+IGZpbGVOYW1lLnN0YXJ0c1dpdGgocHJlZml4KSk7XG5cdFx0XHRpZiAoaXNFeGNsdWRlZFByZWZpeCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnU2tpcHBpbmcgZmlsZSB3aXRoIGV4Y2x1ZGVkIHByZWZpeDonLCBmaWxlTmFtZSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGVuc3VyZVN5bmNGaWxlRXhpc3RzKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdGlmICghdGhpcy5zeW5jTWFuYWdlcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignU3luYyBtYW5hZ2VyIG5vdCBpbml0aWFsaXplZCcpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0Y29uc3Qgc3luY0ZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5zZXR0aW5ncy5zeW5jLnN5bmNGaWxlUGF0aCk7XG5cdFx0XHRpZiAoIXN5bmNGaWxlKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdTeW5jIGZpbGUgbWlzc2luZywgcmVjcmVhdGluZy4uLicpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLmluaXRpYWxpemUoKTtcblx0XHRcdFx0bmV3IE5vdGljZSgnUmVjcmVhdGVkIHN5bmMgZmlsZScpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBlbnN1cmluZyBzeW5jIGZpbGUgZXhpc3RzOicsIGVycm9yKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIHF1ZXVlRmlsZVByb2Nlc3NpbmcoZmlsZTogVEZpbGUsIHR5cGU6ICdDUkVBVEUnIHwgJ1VQREFURScgfCAnREVMRVRFJyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXRoaXMucXVldWVTZXJ2aWNlIHx8ICF0aGlzLmZpbGVUcmFja2VyKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1JlcXVpcmVkIHNlcnZpY2VzIG5vdCBpbml0aWFsaXplZDonLCB7IHF1ZXVlU2VydmljZTogISF0aGlzLnF1ZXVlU2VydmljZSwgZmlsZVRyYWNrZXI6ICEhdGhpcy5maWxlVHJhY2tlciB9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5sb2coJ1F1ZXVlaW5nIGZpbGUgcHJvY2Vzc2luZzonLCB7IGZpbGVOYW1lOiBmaWxlLm5hbWUsIHR5cGUsIHBhdGg6IGZpbGUucGF0aCB9KTtcblx0XHRcdGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5maWxlVHJhY2tlci5jcmVhdGVGaWxlTWV0YWRhdGEoZmlsZSk7XG5cdFx0XHRjb25zb2xlLmxvZygnQ3JlYXRlZCBtZXRhZGF0YTonLCBtZXRhZGF0YSk7XG5cdFx0XHRjb25zdCB0YXNrID0ge1xuXHRcdFx0XHRpZDogZmlsZS5wYXRoLFxuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRwcmlvcml0eTogdHlwZSA9PT0gJ0RFTEVURScgPyAyIDogMSxcblx0XHRcdFx0bWF4UmV0cmllczogdGhpcy5zZXR0aW5ncy5xdWV1ZS5yZXRyeUF0dGVtcHRzLFxuXHRcdFx0XHRyZXRyeUNvdW50OiAwLFxuXHRcdFx0XHRjcmVhdGVkQXQ6IERhdGUubm93KCksXG5cdFx0XHRcdHVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcblx0XHRcdFx0c3RhdHVzOiAnUEVORElORycsXG5cdFx0XHRcdG1ldGFkYXRhLFxuXHRcdFx0XHRkYXRhOiB7fVxuXHRcdFx0fTtcblx0XHRcdGNvbnNvbGUubG9nKCdDcmVhdGVkIHRhc2s6JywgdGFzayk7XG5cdFx0XHRhd2FpdCB0aGlzLnF1ZXVlU2VydmljZS5hZGRUYXNrKHRhc2spO1xuXHRcdFx0Y29uc29sZS5sb2coJ1Rhc2sgYWRkZWQgdG8gcXVldWUnKTtcblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMpIHtcblx0XHRcdFx0Y29uc3QgYWN0aW9uID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRuZXcgTm90aWNlKGBRdWV1ZWQgJHthY3Rpb259IGZvciBwcm9jZXNzaW5nOiAke2ZpbGUubmFtZX1gKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgaW4gcXVldWVGaWxlUHJvY2Vzc2luZzonLCBlcnJvcik7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlcj8uaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ3F1ZXVlRmlsZVByb2Nlc3NpbmcnLCBtZXRhZGF0YTogeyBmaWxlUGF0aDogZmlsZS5wYXRoLCB0eXBlIH0gfSk7XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byBxdWV1ZSAke2ZpbGUubmFtZX0gZm9yIHByb2Nlc3NpbmdgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGhhbmRsZUZpbGVSZW5hbWUoZmlsZTogVEZpbGUsIG9sZFBhdGg6IHN0cmluZykge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXRoaXMuc3VwYWJhc2VTZXJ2aWNlKSByZXR1cm47XG5cdFx0XHQvLyBGaXJzdCB1cGRhdGUgdGhlIGZpbGUgc3RhdHVzIHJlY29yZCB0byB1c2UgdGhlIG5ldyBwYXRoLlxuXHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UudXBkYXRlRmlsZVBhdGgob2xkUGF0aCwgZmlsZS5wYXRoKTtcblxuXHRcdFx0Ly8gVGhlbiwgaWYgdGhlcmUgYXJlIGRvY3VtZW50IGNodW5rcyBmb3IgdGhlIG9sZCBwYXRoLCB1cGRhdGUgdGhlbSBhcyB3ZWxsLlxuXHRcdFx0Y29uc3QgY2h1bmtzID0gYXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UuZ2V0RG9jdW1lbnRDaHVua3Mob2xkUGF0aCk7XG5cdFx0XHRpZiAoY2h1bmtzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc3QgdXBkYXRlZENodW5rcyA9IGNodW5rcy5tYXAoY2h1bmsgPT4gKHtcblx0XHRcdFx0XHQuLi5jaHVuayxcblx0XHRcdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHRcdFx0Li4uY2h1bmsubWV0YWRhdGEsXG5cdFx0XHRcdFx0XHRvYnNpZGlhbklkOiBmaWxlLnBhdGgsXG5cdFx0XHRcdFx0XHRwYXRoOiBmaWxlLnBhdGhcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UuZGVsZXRlRG9jdW1lbnRDaHVua3Mob2xkUGF0aCk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLnVwc2VydENodW5rcyh1cGRhdGVkQ2h1bmtzKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmVuYWJsZU5vdGlmaWNhdGlvbnMpIHtcblx0XHRcdFx0bmV3IE5vdGljZShgVXBkYXRlZCBkYXRhYmFzZSBlbnRyaWVzIGZvciByZW5hbWVkIGZpbGU6ICR7ZmlsZS5uYW1lfWApO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlcj8uaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ2hhbmRsZUZpbGVSZW5hbWUnLCBtZXRhZGF0YTogeyBmaWxlUGF0aDogZmlsZS5wYXRoLCBvbGRQYXRoIH0gfSk7XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byB1cGRhdGUgZGF0YWJhc2UgZm9yIHJlbmFtZWQgZmlsZTogJHtmaWxlLm5hbWV9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhZGRDb21tYW5kcygpIHtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6ICdmb3JjZS1zeW5jLWN1cnJlbnQtZmlsZScsXG5cdFx0XHRuYW1lOiAnRm9yY2Ugc3luYyBjdXJyZW50IGZpbGUnLFxuXHRcdFx0Y2hlY2tDYWxsYmFjazogKGNoZWNraW5nOiBib29sZWFuKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuXHRcdFx0XHRpZiAoZmlsZSkge1xuXHRcdFx0XHRcdGlmICghY2hlY2tpbmcpIHtcblx0XHRcdFx0XHRcdHRoaXMucXVldWVGaWxlUHJvY2Vzc2luZyhmaWxlLCAnVVBEQVRFJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ2ZvcmNlLXN5bmMtYWxsLWZpbGVzJyxcblx0XHRcdG5hbWU6ICdGb3JjZSBzeW5jIGFsbCBmaWxlcycsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBmaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcblx0XHRcdFx0Zm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuc2hvdWxkUHJvY2Vzc0ZpbGUoZmlsZSkpIHtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucXVldWVGaWxlUHJvY2Vzc2luZyhmaWxlLCAnVVBEQVRFJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6ICdjbGVhci1zeW5jLXF1ZXVlJyxcblx0XHRcdG5hbWU6ICdDbGVhciBzeW5jIHF1ZXVlJyxcblx0XHRcdGNhbGxiYWNrOiAoKSA9PiB7XG5cdFx0XHRcdHRoaXMucXVldWVTZXJ2aWNlPy5jbGVhcigpO1xuXHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnU3luYyBxdWV1ZSBjbGVhcmVkJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ3Jlc2V0LWZpbGUtdHJhY2tlcicsXG5cdFx0XHRuYW1lOiAnUmVzZXQgZmlsZSB0cmFja2VyIGNhY2hlJyxcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdHRoaXMuZmlsZVRyYWNrZXI/LmNsZWFyUXVldWUoKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5maWxlVHJhY2tlcj8uaW5pdGlhbGl6ZSgpO1xuXHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVOb3RpZmljYXRpb25zKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnRmlsZSB0cmFja2VyIGNhY2hlIHJlc2V0Jyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ3N0YXJ0LWluaXRpYWwtc3luYycsXG5cdFx0XHRuYW1lOiAnU3RhcnQgaW5pdGlhbCB2YXVsdCBzeW5jJyxcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGlmICh0aGlzLmluaXRpYWxTeW5jTWFuYWdlcikge1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMuaW5pdGlhbFN5bmNNYW5hZ2VyLnN0YXJ0U3luYygpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0luaXRpYWwgc3luYyBtYW5hZ2VyIG5vdCBpbml0aWFsaXplZCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6ICdzdG9wLWluaXRpYWwtc3luYycsXG5cdFx0XHRuYW1lOiAnU3RvcCBpbml0aWFsIHZhdWx0IHN5bmMnLFxuXHRcdFx0Y2FsbGJhY2s6ICgpID0+IHtcblx0XHRcdFx0dGhpcy5pbml0aWFsU3luY01hbmFnZXI/LnN0b3AoKTtcblx0XHRcdFx0bmV3IE5vdGljZSgnSW5pdGlhbCBzeW5jIHN0b3BwZWQnKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufVxuIiwgImltcG9ydCB7IEZldGNoIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaD86IEZldGNoKTogRmV0Y2ggPT4ge1xuICBsZXQgX2ZldGNoOiBGZXRjaFxuICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaFxuICB9IGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT5cbiAgICAgIGltcG9ydCgnQHN1cGFiYXNlL25vZGUtZmV0Y2gnIGFzIGFueSkudGhlbigoeyBkZWZhdWx0OiBmZXRjaCB9KSA9PiBmZXRjaCguLi5hcmdzKSlcbiAgfSBlbHNlIHtcbiAgICBfZmV0Y2ggPSBmZXRjaFxuICB9XG4gIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpXG59XG4iLCAiZXhwb3J0IHR5cGUgRmV0Y2ggPSB0eXBlb2YgZmV0Y2hcblxuLyoqXG4gKiBSZXNwb25zZSBmb3JtYXRcbiAqXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25zUmVzcG9uc2VTdWNjZXNzPFQ+IHtcbiAgZGF0YTogVFxuICBlcnJvcjogbnVsbFxufVxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbnNSZXNwb25zZUZhaWx1cmUge1xuICBkYXRhOiBudWxsXG4gIGVycm9yOiBhbnlcbn1cbmV4cG9ydCB0eXBlIEZ1bmN0aW9uc1Jlc3BvbnNlPFQ+ID0gRnVuY3Rpb25zUmVzcG9uc2VTdWNjZXNzPFQ+IHwgRnVuY3Rpb25zUmVzcG9uc2VGYWlsdXJlXG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29udGV4dDogYW55XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgbmFtZSA9ICdGdW5jdGlvbnNFcnJvcicsIGNvbnRleHQ/OiBhbnkpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0ZldGNoRXJyb3IgZXh0ZW5kcyBGdW5jdGlvbnNFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IGFueSkge1xuICAgIHN1cGVyKCdGYWlsZWQgdG8gc2VuZCBhIHJlcXVlc3QgdG8gdGhlIEVkZ2UgRnVuY3Rpb24nLCAnRnVuY3Rpb25zRmV0Y2hFcnJvcicsIGNvbnRleHQpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc1JlbGF5RXJyb3IgZXh0ZW5kcyBGdW5jdGlvbnNFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IGFueSkge1xuICAgIHN1cGVyKCdSZWxheSBFcnJvciBpbnZva2luZyB0aGUgRWRnZSBGdW5jdGlvbicsICdGdW5jdGlvbnNSZWxheUVycm9yJywgY29udGV4dClcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zSHR0cEVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0OiBhbnkpIHtcbiAgICBzdXBlcignRWRnZSBGdW5jdGlvbiByZXR1cm5lZCBhIG5vbi0yeHggc3RhdHVzIGNvZGUnLCAnRnVuY3Rpb25zSHR0cEVycm9yJywgY29udGV4dClcbiAgfVxufVxuLy8gRGVmaW5lIHRoZSBlbnVtIGZvciB0aGUgJ3JlZ2lvbicgcHJvcGVydHlcbmV4cG9ydCBlbnVtIEZ1bmN0aW9uUmVnaW9uIHtcbiAgQW55ID0gJ2FueScsXG4gIEFwTm9ydGhlYXN0MSA9ICdhcC1ub3J0aGVhc3QtMScsXG4gIEFwTm9ydGhlYXN0MiA9ICdhcC1ub3J0aGVhc3QtMicsXG4gIEFwU291dGgxID0gJ2FwLXNvdXRoLTEnLFxuICBBcFNvdXRoZWFzdDEgPSAnYXAtc291dGhlYXN0LTEnLFxuICBBcFNvdXRoZWFzdDIgPSAnYXAtc291dGhlYXN0LTInLFxuICBDYUNlbnRyYWwxID0gJ2NhLWNlbnRyYWwtMScsXG4gIEV1Q2VudHJhbDEgPSAnZXUtY2VudHJhbC0xJyxcbiAgRXVXZXN0MSA9ICdldS13ZXN0LTEnLFxuICBFdVdlc3QyID0gJ2V1LXdlc3QtMicsXG4gIEV1V2VzdDMgPSAnZXUtd2VzdC0zJyxcbiAgU2FFYXN0MSA9ICdzYS1lYXN0LTEnLFxuICBVc0Vhc3QxID0gJ3VzLWVhc3QtMScsXG4gIFVzV2VzdDEgPSAndXMtd2VzdC0xJyxcbiAgVXNXZXN0MiA9ICd1cy13ZXN0LTInLFxufVxuXG5leHBvcnQgdHlwZSBGdW5jdGlvbkludm9rZU9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBoZWFkZXJzIHRvIHNlbmQgd2l0aCB0aGUgcmVxdWVzdC5cbiAgICogKi9cbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgLyoqXG4gICAqIFRoZSBIVFRQIHZlcmIgb2YgdGhlIHJlcXVlc3RcbiAgICovXG4gIG1ldGhvZD86ICdQT1NUJyB8ICdHRVQnIHwgJ1BVVCcgfCAnUEFUQ0gnIHwgJ0RFTEVURSdcbiAgLyoqXG4gICAqIFRoZSBSZWdpb24gdG8gaW52b2tlIHRoZSBmdW5jdGlvbiBpbi5cbiAgICovXG4gIHJlZ2lvbj86IEZ1bmN0aW9uUmVnaW9uXG4gIC8qKlxuICAgKiBUaGUgYm9keSBvZiB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGJvZHk/OlxuICAgIHwgRmlsZVxuICAgIHwgQmxvYlxuICAgIHwgQXJyYXlCdWZmZXJcbiAgICB8IEZvcm1EYXRhXG4gICAgfCBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxuICAgIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHwgc3RyaW5nXG59XG4iLCAiaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi9oZWxwZXInXG5pbXBvcnQge1xuICBGZXRjaCxcbiAgRnVuY3Rpb25zRmV0Y2hFcnJvcixcbiAgRnVuY3Rpb25zSHR0cEVycm9yLFxuICBGdW5jdGlvbnNSZWxheUVycm9yLFxuICBGdW5jdGlvbnNSZXNwb25zZSxcbiAgRnVuY3Rpb25JbnZva2VPcHRpb25zLFxuICBGdW5jdGlvblJlZ2lvbixcbn0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0NsaWVudCB7XG4gIHByb3RlY3RlZCB1cmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBwcm90ZWN0ZWQgcmVnaW9uOiBGdW5jdGlvblJlZ2lvblxuICBwcm90ZWN0ZWQgZmV0Y2g6IEZldGNoXG5cbiAgY29uc3RydWN0b3IoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAge1xuICAgICAgaGVhZGVycyA9IHt9LFxuICAgICAgY3VzdG9tRmV0Y2gsXG4gICAgICByZWdpb24gPSBGdW5jdGlvblJlZ2lvbi5BbnksXG4gICAgfToge1xuICAgICAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICAgIGN1c3RvbUZldGNoPzogRmV0Y2hcbiAgICAgIHJlZ2lvbj86IEZ1bmN0aW9uUmVnaW9uXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHRoaXMudXJsID0gdXJsXG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVyc1xuICAgIHRoaXMucmVnaW9uID0gcmVnaW9uXG4gICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChjdXN0b21GZXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBhdXRob3JpemF0aW9uIGhlYWRlclxuICAgKiBAcGFyYW0gdG9rZW4gLSB0aGUgbmV3IGp3dCB0b2tlbiBzZW50IGluIHRoZSBhdXRob3Jpc2F0aW9uIGhlYWRlclxuICAgKi9cbiAgc2V0QXV0aCh0b2tlbjogc3RyaW5nKSB7XG4gICAgdGhpcy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dG9rZW59YFxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZXMgYSBmdW5jdGlvblxuICAgKiBAcGFyYW0gZnVuY3Rpb25OYW1lIC0gVGhlIG5hbWUgb2YgdGhlIEZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBpbnZva2luZyB0aGUgRnVuY3Rpb24uXG4gICAqL1xuICBhc3luYyBpbnZva2U8VCA9IGFueT4oXG4gICAgZnVuY3Rpb25OYW1lOiBzdHJpbmcsXG4gICAgb3B0aW9uczogRnVuY3Rpb25JbnZva2VPcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTxGdW5jdGlvbnNSZXNwb25zZTxUPj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGhlYWRlcnMsIG1ldGhvZCwgYm9keTogZnVuY3Rpb25BcmdzIH0gPSBvcHRpb25zXG4gICAgICBsZXQgX2hlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICAgICAgbGV0IHsgcmVnaW9uIH0gPSBvcHRpb25zXG4gICAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgICByZWdpb24gPSB0aGlzLnJlZ2lvblxuICAgICAgfVxuICAgICAgaWYgKHJlZ2lvbiAmJiByZWdpb24gIT09ICdhbnknKSB7XG4gICAgICAgIF9oZWFkZXJzWyd4LXJlZ2lvbiddID0gcmVnaW9uXG4gICAgICB9XG4gICAgICBsZXQgYm9keTogYW55XG4gICAgICBpZiAoXG4gICAgICAgIGZ1bmN0aW9uQXJncyAmJlxuICAgICAgICAoKGhlYWRlcnMgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoZWFkZXJzLCAnQ29udGVudC1UeXBlJykpIHx8ICFoZWFkZXJzKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICAgZnVuY3Rpb25BcmdzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gd2lsbCB3b3JrIGZvciBGaWxlIGFzIEZpbGUgaW5oZXJpdHMgQmxvYlxuICAgICAgICAgIC8vIGFsc28gd29ya3MgZm9yIEFycmF5QnVmZmVyIGFzIGl0IGlzIHRoZSBzYW1lIHVuZGVybHlpbmcgc3RydWN0dXJlIGFzIGEgQmxvYlxuICAgICAgICAgIF9oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJnc1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jdGlvbkFyZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gcGxhaW4gc3RyaW5nXG4gICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ3RleHQvcGxhaW4nXG4gICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJnc1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgZnVuY3Rpb25BcmdzIGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgICAvLyBkb24ndCBzZXQgY29udGVudC10eXBlIGhlYWRlcnNcbiAgICAgICAgICAvLyBSZXF1ZXN0IHdpbGwgYXV0b21hdGljYWxseSBhZGQgdGhlIHJpZ2h0IGJvdW5kYXJ5IHZhbHVlXG4gICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJnc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRlZmF1bHQsIGFzc3VtZSB0aGlzIGlzIEpTT05cbiAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZnVuY3Rpb25BcmdzKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaChgJHt0aGlzLnVybH0vJHtmdW5jdGlvbk5hbWV9YCwge1xuICAgICAgICBtZXRob2Q6IG1ldGhvZCB8fCAnUE9TVCcsXG4gICAgICAgIC8vIGhlYWRlcnMgcHJpb3JpdHkgaXMgKGhpZ2ggdG8gbG93KTpcbiAgICAgICAgLy8gMS4gaW52b2tlLWxldmVsIGhlYWRlcnNcbiAgICAgICAgLy8gMi4gY2xpZW50LWxldmVsIGhlYWRlcnNcbiAgICAgICAgLy8gMy4gZGVmYXVsdCBDb250ZW50LVR5cGUgaGVhZGVyXG4gICAgICAgIGhlYWRlcnM6IHsgLi4uX2hlYWRlcnMsIC4uLnRoaXMuaGVhZGVycywgLi4uaGVhZGVycyB9LFxuICAgICAgICBib2R5LFxuICAgICAgfSkuY2F0Y2goKGZldGNoRXJyb3IpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc0ZldGNoRXJyb3IoZmV0Y2hFcnJvcilcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGlzUmVsYXlFcnJvciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXJlbGF5LWVycm9yJylcbiAgICAgIGlmIChpc1JlbGF5RXJyb3IgJiYgaXNSZWxheUVycm9yID09PSAndHJ1ZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc1JlbGF5RXJyb3IocmVzcG9uc2UpXG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc0h0dHBFcnJvcihyZXNwb25zZSlcbiAgICAgIH1cblxuICAgICAgbGV0IHJlc3BvbnNlVHlwZSA9IChyZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgPz8gJ3RleHQvcGxhaW4nKS5zcGxpdCgnOycpWzBdLnRyaW0oKVxuICAgICAgbGV0IGRhdGE6IGFueVxuICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpXG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQvZXZlbnQtc3RyZWFtJykge1xuICAgICAgICBkYXRhID0gcmVzcG9uc2VcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpIHtcbiAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmZvcm1EYXRhKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQgdG8gdGV4dFxuICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCBpbmRleCBmcm9tICcuLi9janMvaW5kZXguanMnXG5jb25zdCB7XG4gIFBvc3RncmVzdENsaWVudCxcbiAgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxuICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLFxuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RFcnJvcixcbn0gPSBpbmRleFxuXG5leHBvcnQge1xuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbiAgUG9zdGdyZXN0RXJyb3IsXG59XG5cbi8vIGNvbXBhdGliaWxpdHkgd2l0aCBDSlMgb3V0cHV0XG5leHBvcnQgZGVmYXVsdCB7XG4gIFBvc3RncmVzdENsaWVudCxcbiAgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxuICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLFxuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RFcnJvcixcbn1cbiIsICJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjExLjInXG4iLCAiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbidcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfSEVBREVSUyA9IHsgJ1gtQ2xpZW50LUluZm8nOiBgcmVhbHRpbWUtanMvJHt2ZXJzaW9ufWAgfVxuXG5leHBvcnQgY29uc3QgVlNOOiBzdHJpbmcgPSAnMS4wLjAnXG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1RJTUVPVVQgPSAxMDAwMFxuXG5leHBvcnQgY29uc3QgV1NfQ0xPU0VfTk9STUFMID0gMTAwMFxuXG5leHBvcnQgZW51bSBTT0NLRVRfU1RBVEVTIHtcbiAgY29ubmVjdGluZyA9IDAsXG4gIG9wZW4gPSAxLFxuICBjbG9zaW5nID0gMixcbiAgY2xvc2VkID0gMyxcbn1cblxuZXhwb3J0IGVudW0gQ0hBTk5FTF9TVEFURVMge1xuICBjbG9zZWQgPSAnY2xvc2VkJyxcbiAgZXJyb3JlZCA9ICdlcnJvcmVkJyxcbiAgam9pbmVkID0gJ2pvaW5lZCcsXG4gIGpvaW5pbmcgPSAnam9pbmluZycsXG4gIGxlYXZpbmcgPSAnbGVhdmluZycsXG59XG5cbmV4cG9ydCBlbnVtIENIQU5ORUxfRVZFTlRTIHtcbiAgY2xvc2UgPSAncGh4X2Nsb3NlJyxcbiAgZXJyb3IgPSAncGh4X2Vycm9yJyxcbiAgam9pbiA9ICdwaHhfam9pbicsXG4gIHJlcGx5ID0gJ3BoeF9yZXBseScsXG4gIGxlYXZlID0gJ3BoeF9sZWF2ZScsXG4gIGFjY2Vzc190b2tlbiA9ICdhY2Nlc3NfdG9rZW4nLFxufVxuXG5leHBvcnQgZW51bSBUUkFOU1BPUlRTIHtcbiAgd2Vic29ja2V0ID0gJ3dlYnNvY2tldCcsXG59XG5cbmV4cG9ydCBlbnVtIENPTk5FQ1RJT05fU1RBVEUge1xuICBDb25uZWN0aW5nID0gJ2Nvbm5lY3RpbmcnLFxuICBPcGVuID0gJ29wZW4nLFxuICBDbG9zaW5nID0gJ2Nsb3NpbmcnLFxuICBDbG9zZWQgPSAnY2xvc2VkJyxcbn1cbiIsICIvLyBUaGlzIGZpbGUgZHJhd3MgaGVhdmlseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvY29tbWl0L2NmMDk4ZTljZjdhNDRlZTY0NzlkMzFkOTExYTk3ZDNjNzQzMGM2ZmVcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXJpYWxpemVyIHtcbiAgSEVBREVSX0xFTkdUSCA9IDFcblxuICBkZWNvZGUocmF3UGF5bG9hZDogQXJyYXlCdWZmZXIgfCBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIGlmIChyYXdQYXlsb2FkLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2JpbmFyeURlY29kZShyYXdQYXlsb2FkKSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJhd1BheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5wYXJzZShyYXdQYXlsb2FkKSlcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbGJhY2soe30pXG4gIH1cblxuICBwcml2YXRlIF9iaW5hcnlEZWNvZGUoYnVmZmVyOiBBcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKVxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpXG4gIH1cblxuICBwcml2YXRlIF9kZWNvZGVCcm9hZGNhc3QoXG4gICAgYnVmZmVyOiBBcnJheUJ1ZmZlcixcbiAgICB2aWV3OiBEYXRhVmlldyxcbiAgICBkZWNvZGVyOiBUZXh0RGVjb2RlclxuICApOiB7XG4gICAgcmVmOiBudWxsXG4gICAgdG9waWM6IHN0cmluZ1xuICAgIGV2ZW50OiBzdHJpbmdcbiAgICBwYXlsb2FkOiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIH0ge1xuICAgIGNvbnN0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBjb25zdCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDIpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIDJcbiAgICBjb25zdCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgY29uc3QgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZVxuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKFxuICAgICAgZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpKVxuICAgIClcblxuICAgIHJldHVybiB7IHJlZjogbnVsbCwgdG9waWM6IHRvcGljLCBldmVudDogZXZlbnQsIHBheWxvYWQ6IGRhdGEgfVxuICB9XG59XG4iLCAiLyoqXG4gKiBDcmVhdGVzIGEgdGltZXIgdGhhdCBhY2NlcHRzIGEgYHRpbWVyQ2FsY2AgZnVuY3Rpb24gdG8gcGVyZm9ybSBjYWxjdWxhdGVkIHRpbWVvdXQgcmV0cmllcywgc3VjaCBhcyBleHBvbmVudGlhbCBiYWNrb2ZmLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICBsZXQgcmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoKCkgPT4gdGhpcy5jb25uZWN0KCksIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgICAgcmV0dXJuIFsxMDAwLCA1MDAwLCAxMDAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICogICAgfSlcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDUwMDBcbiAqICAgIHJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZXIge1xuICB0aW1lcjogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gIHRyaWVzOiBudW1iZXIgPSAwXG5cbiAgY29uc3RydWN0b3IocHVibGljIGNhbGxiYWNrOiBGdW5jdGlvbiwgcHVibGljIHRpbWVyQ2FsYzogRnVuY3Rpb24pIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsY1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy50cmllcyA9IDBcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcilcbiAgfVxuXG4gIC8vIENhbmNlbHMgYW55IHByZXZpb3VzIHNjaGVkdWxlVGltZW91dCBhbmQgc2NoZWR1bGVzIGNhbGxiYWNrXG4gIHNjaGVkdWxlVGltZW91dCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcilcblxuICAgIHRoaXMudGltZXIgPSA8YW55PnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmllcyA9IHRoaXMudHJpZXMgKyAxXG4gICAgICB0aGlzLmNhbGxiYWNrKClcbiAgICB9LCB0aGlzLnRpbWVyQ2FsYyh0aGlzLnRyaWVzICsgMSkpXG4gIH1cbn1cbiIsICIvKipcbiAqIEhlbHBlcnMgdG8gY29udmVydCB0aGUgY2hhbmdlIFBheWxvYWQgaW50byBuYXRpdmUgSlMgdHlwZXMuXG4gKi9cblxuLy8gQWRhcHRlZCBmcm9tIGVwZ3NxbCAoc3JjL2VwZ3NxbF9iaW5hcnkuZXJsKSwgdGhpcyBtb2R1bGUgbGljZW5zZWQgdW5kZXJcbi8vIDMtY2xhdXNlIEJTRCBmb3VuZCBoZXJlOiBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZXBnc3FsL2VwZ3NxbC9kZXZlbC9MSUNFTlNFXG5cbmV4cG9ydCBlbnVtIFBvc3RncmVzVHlwZXMge1xuICBhYnN0aW1lID0gJ2Fic3RpbWUnLFxuICBib29sID0gJ2Jvb2wnLFxuICBkYXRlID0gJ2RhdGUnLFxuICBkYXRlcmFuZ2UgPSAnZGF0ZXJhbmdlJyxcbiAgZmxvYXQ0ID0gJ2Zsb2F0NCcsXG4gIGZsb2F0OCA9ICdmbG9hdDgnLFxuICBpbnQyID0gJ2ludDInLFxuICBpbnQ0ID0gJ2ludDQnLFxuICBpbnQ0cmFuZ2UgPSAnaW50NHJhbmdlJyxcbiAgaW50OCA9ICdpbnQ4JyxcbiAgaW50OHJhbmdlID0gJ2ludDhyYW5nZScsXG4gIGpzb24gPSAnanNvbicsXG4gIGpzb25iID0gJ2pzb25iJyxcbiAgbW9uZXkgPSAnbW9uZXknLFxuICBudW1lcmljID0gJ251bWVyaWMnLFxuICBvaWQgPSAnb2lkJyxcbiAgcmVsdGltZSA9ICdyZWx0aW1lJyxcbiAgdGV4dCA9ICd0ZXh0JyxcbiAgdGltZSA9ICd0aW1lJyxcbiAgdGltZXN0YW1wID0gJ3RpbWVzdGFtcCcsXG4gIHRpbWVzdGFtcHR6ID0gJ3RpbWVzdGFtcHR6JyxcbiAgdGltZXR6ID0gJ3RpbWV0eicsXG4gIHRzcmFuZ2UgPSAndHNyYW5nZScsXG4gIHRzdHpyYW5nZSA9ICd0c3R6cmFuZ2UnLFxufVxuXG50eXBlIENvbHVtbnMgPSB7XG4gIG5hbWU6IHN0cmluZyAvLyB0aGUgY29sdW1uIG5hbWUuIGVnOiBcInVzZXJfaWRcIlxuICB0eXBlOiBzdHJpbmcgLy8gdGhlIGNvbHVtbiB0eXBlLiBlZzogXCJ1dWlkXCJcbiAgZmxhZ3M/OiBzdHJpbmdbXSAvLyBhbnkgc3BlY2lhbCBmbGFncyBmb3IgdGhlIGNvbHVtbi4gZWc6IFtcImtleVwiXVxuICB0eXBlX21vZGlmaWVyPzogbnVtYmVyIC8vIHRoZSB0eXBlIG1vZGlmaWVyLiBlZzogNDI5NDk2NzI5NVxufVtdXG5cbnR5cGUgQmFzZVZhbHVlID0gbnVsbCB8IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW5cbnR5cGUgUmVjb3JkVmFsdWUgPSBCYXNlVmFsdWUgfCBCYXNlVmFsdWVbXVxuXG50eXBlIFJlY29yZCA9IHtcbiAgW2tleTogc3RyaW5nXTogUmVjb3JkVmFsdWVcbn1cblxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBjb2x1bW5zIGFuZCBhbiBvYmplY3Qgb2Ygc3RyaW5nIHZhbHVlcyB0aGVuIGNvbnZlcnRzIGVhY2ggc3RyaW5nIHZhbHVlXG4gKiB0byBpdHMgbWFwcGVkIHR5cGUuXG4gKlxuICogQHBhcmFtIHt7bmFtZTogU3RyaW5nLCB0eXBlOiBTdHJpbmd9W119IGNvbHVtbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBtYXAgb2YgdmFyaW91cyBvcHRpb25zIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gdGhlIG1hcHBlclxuICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5za2lwVHlwZXMgVGhlIGFycmF5IG9mIHR5cGVzIHRoYXQgc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWRcbiAqXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2hhbmdlRGF0YShbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiczMyd9LCB7fSlcbiAqIC8vPT57IGZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAzMyB9XG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0Q2hhbmdlRGF0YSA9IChcbiAgY29sdW1uczogQ29sdW1ucyxcbiAgcmVjb3JkOiBSZWNvcmQsXG4gIG9wdGlvbnM6IHsgc2tpcFR5cGVzPzogc3RyaW5nW10gfSA9IHt9XG4pOiBSZWNvcmQgPT4ge1xuICBjb25zdCBza2lwVHlwZXMgPSBvcHRpb25zLnNraXBUeXBlcyA/PyBbXVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhyZWNvcmQpLnJlZHVjZSgoYWNjLCByZWNfa2V5KSA9PiB7XG4gICAgYWNjW3JlY19rZXldID0gY29udmVydENvbHVtbihyZWNfa2V5LCBjb2x1bW5zLCByZWNvcmQsIHNraXBUeXBlcylcbiAgICByZXR1cm4gYWNjXG4gIH0sIHt9IGFzIFJlY29yZClcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgdmFsdWUgb2YgYW4gaW5kaXZpZHVhbCBjb2x1bW4uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbk5hbWUgVGhlIGNvbHVtbiB0aGF0IHlvdSB3YW50IHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB7e25hbWU6IFN0cmluZywgdHlwZTogU3RyaW5nfVtdfSBjb2x1bW5zIEFsbCBvZiB0aGUgY29sdW1uc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCBUaGUgbWFwIG9mIHN0cmluZyB2YWx1ZXNcbiAqIEBwYXJhbSB7QXJyYXl9IHNraXBUeXBlcyBBbiBhcnJheSBvZiB0eXBlcyB0aGF0IHNob3VsZCBub3QgYmUgY29udmVydGVkXG4gKiBAcmV0dXJuIHtvYmplY3R9IFVzZWxlc3MgaW5mb3JtYXRpb25cbiAqXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q29sdW1uKCdhZ2UnLCBbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAnMzMnfSwgW10pXG4gKiAvLz0+IDMzXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q29sdW1uKCdhZ2UnLCBbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAnMzMnfSwgWydpbnQ0J10pXG4gKiAvLz0+IFwiMzNcIlxuICovXG5leHBvcnQgY29uc3QgY29udmVydENvbHVtbiA9IChcbiAgY29sdW1uTmFtZTogc3RyaW5nLFxuICBjb2x1bW5zOiBDb2x1bW5zLFxuICByZWNvcmQ6IFJlY29yZCxcbiAgc2tpcFR5cGVzOiBzdHJpbmdbXVxuKTogUmVjb3JkVmFsdWUgPT4ge1xuICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zLmZpbmQoKHgpID0+IHgubmFtZSA9PT0gY29sdW1uTmFtZSlcbiAgY29uc3QgY29sVHlwZSA9IGNvbHVtbj8udHlwZVxuICBjb25zdCB2YWx1ZSA9IHJlY29yZFtjb2x1bW5OYW1lXVxuXG4gIGlmIChjb2xUeXBlICYmICFza2lwVHlwZXMuaW5jbHVkZXMoY29sVHlwZSkpIHtcbiAgICByZXR1cm4gY29udmVydENlbGwoY29sVHlwZSwgdmFsdWUpXG4gIH1cblxuICByZXR1cm4gbm9vcCh2YWx1ZSlcbn1cblxuLyoqXG4gKiBJZiB0aGUgdmFsdWUgb2YgdGhlIGNlbGwgaXMgYG51bGxgLCByZXR1cm5zIG51bGwuXG4gKiBPdGhlcndpc2UgY29udmVydHMgdGhlIHN0cmluZyB2YWx1ZSB0byB0aGUgY29ycmVjdCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBwb3N0Z3JlcyBjb2x1bW4gdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBjZWxsIHZhbHVlXG4gKlxuICogQGV4YW1wbGUgY29udmVydENlbGwoJ2Jvb2wnLCAndCcpXG4gKiAvLz0+IHRydWVcbiAqIEBleGFtcGxlIGNvbnZlcnRDZWxsKCdpbnQ4JywgJzEwJylcbiAqIC8vPT4gMTBcbiAqIEBleGFtcGxlIGNvbnZlcnRDZWxsKCdfaW50NCcsICd7MSwyLDMsNH0nKVxuICogLy89PiBbMSwyLDMsNF1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRDZWxsID0gKHR5cGU6IHN0cmluZywgdmFsdWU6IFJlY29yZFZhbHVlKTogUmVjb3JkVmFsdWUgPT4ge1xuICAvLyBpZiBkYXRhIHR5cGUgaXMgYW4gYXJyYXlcbiAgaWYgKHR5cGUuY2hhckF0KDApID09PSAnXycpIHtcbiAgICBjb25zdCBkYXRhVHlwZSA9IHR5cGUuc2xpY2UoMSwgdHlwZS5sZW5ndGgpXG4gICAgcmV0dXJuIHRvQXJyYXkodmFsdWUsIGRhdGFUeXBlKVxuICB9XG5cbiAgLy8gSWYgbm90IG51bGwsIGNvbnZlcnQgdG8gY29ycmVjdCB0eXBlLlxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuYm9vbDpcbiAgICAgIHJldHVybiB0b0Jvb2xlYW4odmFsdWUpXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmZsb2F0NDpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuZmxvYXQ4OlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQyOlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ0OlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ4OlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5udW1lcmljOlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5vaWQ6XG4gICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmpzb246XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmpzb25iOlxuICAgICAgcmV0dXJuIHRvSnNvbih2YWx1ZSlcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZXN0YW1wOlxuICAgICAgcmV0dXJuIHRvVGltZXN0YW1wU3RyaW5nKHZhbHVlKSAvLyBGb3JtYXQgdG8gYmUgY29uc2lzdGVudCB3aXRoIFBvc3RnUkVTVFxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5hYnN0aW1lOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmRhdGU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuZGF0ZXJhbmdlOlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ0cmFuZ2U6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDhyYW5nZTpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMubW9uZXk6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnJlbHRpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudGV4dDpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1lc3RhbXB0ejogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1ldHo6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudHNyYW5nZTpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudHN0enJhbmdlOlxuICAgICAgcmV0dXJuIG5vb3AodmFsdWUpXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFJldHVybiB0aGUgdmFsdWUgZm9yIHJlbWFpbmluZyB0eXBlc1xuICAgICAgcmV0dXJuIG5vb3AodmFsdWUpXG4gIH1cbn1cblxuY29uc3Qgbm9vcCA9ICh2YWx1ZTogUmVjb3JkVmFsdWUpOiBSZWNvcmRWYWx1ZSA9PiB7XG4gIHJldHVybiB2YWx1ZVxufVxuZXhwb3J0IGNvbnN0IHRvQm9vbGVhbiA9ICh2YWx1ZTogUmVjb3JkVmFsdWUpOiBSZWNvcmRWYWx1ZSA9PiB7XG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlICd0JzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgY2FzZSAnZic6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZhbHVlXG4gIH1cbn1cbmV4cG9ydCBjb25zdCB0b051bWJlciA9ICh2YWx1ZTogUmVjb3JkVmFsdWUpOiBSZWNvcmRWYWx1ZSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKVxuICAgIGlmICghTnVtYmVyLmlzTmFOKHBhcnNlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHBhcnNlZFZhbHVlXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuZXhwb3J0IGNvbnN0IHRvSnNvbiA9ICh2YWx1ZTogUmVjb3JkVmFsdWUpOiBSZWNvcmRWYWx1ZSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhgSlNPTiBwYXJzZSBlcnJvcjogJHtlcnJvcn1gKVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgUG9zdGdyZXMgQXJyYXkgaW50byBhIG5hdGl2ZSBKUyBhcnJheVxuICpcbiAqIEBleGFtcGxlIHRvQXJyYXkoJ3t9JywgJ2ludDQnKVxuICogLy89PiBbXVxuICogQGV4YW1wbGUgdG9BcnJheSgne1wiWzIwMjEtMDEtMDEsMjAyMS0xMi0zMSlcIixcIigyMDIxLTAxLTAxLDIwMjEtMTItMzJdXCJ9JywgJ2RhdGVyYW5nZScpXG4gKiAvLz0+IFsnWzIwMjEtMDEtMDEsMjAyMS0xMi0zMSknLCAnKDIwMjEtMDEtMDEsMjAyMS0xMi0zMl0nXVxuICogQGV4YW1wbGUgdG9BcnJheShbMSwyLDMsNF0sICdpbnQ0JylcbiAqIC8vPT4gWzEsMiwzLDRdXG4gKi9cbmV4cG9ydCBjb25zdCB0b0FycmF5ID0gKHZhbHVlOiBSZWNvcmRWYWx1ZSwgdHlwZTogc3RyaW5nKTogUmVjb3JkVmFsdWUgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgY29uc3QgbGFzdElkeCA9IHZhbHVlLmxlbmd0aCAtIDFcbiAgY29uc3QgY2xvc2VCcmFjZSA9IHZhbHVlW2xhc3RJZHhdXG4gIGNvbnN0IG9wZW5CcmFjZSA9IHZhbHVlWzBdXG5cbiAgLy8gQ29uZmlybSB2YWx1ZSBpcyBhIFBvc3RncmVzIGFycmF5IGJ5IGNoZWNraW5nIGN1cmx5IGJyYWNrZXRzXG4gIGlmIChvcGVuQnJhY2UgPT09ICd7JyAmJiBjbG9zZUJyYWNlID09PSAnfScpIHtcbiAgICBsZXQgYXJyXG4gICAgY29uc3QgdmFsVHJpbSA9IHZhbHVlLnNsaWNlKDEsIGxhc3RJZHgpXG5cbiAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHNvbHV0aW9uIHRvIHNlcGFyYXRlIFBvc3RncmVzIGFycmF5IGRhdGFcbiAgICB0cnkge1xuICAgICAgYXJyID0gSlNPTi5wYXJzZSgnWycgKyB2YWxUcmltICsgJ10nKVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIC8vIFdBUk5JTkc6IHNwbGl0dGluZyBvbiBjb21tYSBkb2VzIG5vdCBjb3ZlciBhbGwgZWRnZSBjYXNlc1xuICAgICAgYXJyID0gdmFsVHJpbSA/IHZhbFRyaW0uc3BsaXQoJywnKSA6IFtdXG4gICAgfVxuXG4gICAgcmV0dXJuIGFyci5tYXAoKHZhbDogQmFzZVZhbHVlKSA9PiBjb252ZXJ0Q2VsbCh0eXBlLCB2YWwpKVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogRml4ZXMgdGltZXN0YW1wIHRvIGJlIElTTy04NjAxLiBTd2FwcyB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgZGF0ZSBhbmQgdGltZSBmb3IgYSAnVCdcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2Uvc3VwYWJhc2UvaXNzdWVzLzE4XG4gKlxuICogQGV4YW1wbGUgdG9UaW1lc3RhbXBTdHJpbmcoJzIwMTktMDktMTAgMDA6MDA6MDAnKVxuICogLy89PiAnMjAxOS0wOS0xMFQwMDowMDowMCdcbiAqL1xuZXhwb3J0IGNvbnN0IHRvVGltZXN0YW1wU3RyaW5nID0gKHZhbHVlOiBSZWNvcmRWYWx1ZSk6IFJlY29yZFZhbHVlID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgnICcsICdUJylcbiAgfVxuXG4gIHJldHVybiB2YWx1ZVxufVxuXG5leHBvcnQgY29uc3QgaHR0cEVuZHBvaW50VVJMID0gKHNvY2tldFVybDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgbGV0IHVybCA9IHNvY2tldFVybFxuICB1cmwgPSB1cmwucmVwbGFjZSgvXndzL2ksICdodHRwJylcbiAgdXJsID0gdXJsLnJlcGxhY2UoLyhcXC9zb2NrZXRcXC93ZWJzb2NrZXR8XFwvc29ja2V0fFxcL3dlYnNvY2tldClcXC8/JC9pLCAnJylcbiAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXC8rJC8sICcnKVxufVxuIiwgImltcG9ydCB7IERFRkFVTFRfVElNRU9VVCB9IGZyb20gJy4uL2xpYi9jb25zdGFudHMnXG5pbXBvcnQgdHlwZSBSZWFsdGltZUNoYW5uZWwgZnJvbSAnLi4vUmVhbHRpbWVDaGFubmVsJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdXNoIHtcbiAgc2VudDogYm9vbGVhbiA9IGZhbHNlXG4gIHRpbWVvdXRUaW1lcjogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gIHJlZjogc3RyaW5nID0gJydcbiAgcmVjZWl2ZWRSZXNwOiB7XG4gICAgc3RhdHVzOiBzdHJpbmdcbiAgICByZXNwb25zZTogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICB9IHwgbnVsbCA9IG51bGxcbiAgcmVjSG9va3M6IHtcbiAgICBzdGF0dXM6IHN0cmluZ1xuICAgIGNhbGxiYWNrOiBGdW5jdGlvblxuICB9W10gPSBbXVxuICByZWZFdmVudDogc3RyaW5nIHwgbnVsbCA9IG51bGxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIFB1c2hcbiAgICpcbiAgICogQHBhcmFtIGNoYW5uZWwgVGhlIENoYW5uZWxcbiAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCwgZm9yIGV4YW1wbGUgYFwicGh4X2pvaW5cImBcbiAgICogQHBhcmFtIHBheWxvYWQgVGhlIHBheWxvYWQsIGZvciBleGFtcGxlIGB7dXNlcl9pZDogMTIzfWBcbiAgICogQHBhcmFtIHRpbWVvdXQgVGhlIHB1c2ggdGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwsXG4gICAgcHVibGljIGV2ZW50OiBzdHJpbmcsXG4gICAgcHVibGljIHBheWxvYWQ6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fSxcbiAgICBwdWJsaWMgdGltZW91dDogbnVtYmVyID0gREVGQVVMVF9USU1FT1VUXG4gICkge31cblxuICByZXNlbmQodGltZW91dDogbnVtYmVyKSB7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgIHRoaXMuX2NhbmNlbFJlZkV2ZW50KClcbiAgICB0aGlzLnJlZiA9ICcnXG4gICAgdGhpcy5yZWZFdmVudCA9IG51bGxcbiAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IG51bGxcbiAgICB0aGlzLnNlbnQgPSBmYWxzZVxuICAgIHRoaXMuc2VuZCgpXG4gIH1cblxuICBzZW5kKCkge1xuICAgIGlmICh0aGlzLl9oYXNSZWNlaXZlZCgndGltZW91dCcpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5zdGFydFRpbWVvdXQoKVxuICAgIHRoaXMuc2VudCA9IHRydWVcbiAgICB0aGlzLmNoYW5uZWwuc29ja2V0LnB1c2goe1xuICAgICAgdG9waWM6IHRoaXMuY2hhbm5lbC50b3BpYyxcbiAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgcGF5bG9hZDogdGhpcy5wYXlsb2FkLFxuICAgICAgcmVmOiB0aGlzLnJlZixcbiAgICAgIGpvaW5fcmVmOiB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKSxcbiAgICB9KVxuICB9XG5cbiAgdXBkYXRlUGF5bG9hZChwYXlsb2FkOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KTogdm9pZCB7XG4gICAgdGhpcy5wYXlsb2FkID0geyAuLi50aGlzLnBheWxvYWQsIC4uLnBheWxvYWQgfVxuICB9XG5cbiAgcmVjZWl2ZShzdGF0dXM6IHN0cmluZywgY2FsbGJhY2s6IEZ1bmN0aW9uKSB7XG4gICAgaWYgKHRoaXMuX2hhc1JlY2VpdmVkKHN0YXR1cykpIHtcbiAgICAgIGNhbGxiYWNrKHRoaXMucmVjZWl2ZWRSZXNwPy5yZXNwb25zZSlcbiAgICB9XG5cbiAgICB0aGlzLnJlY0hvb2tzLnB1c2goeyBzdGF0dXMsIGNhbGxiYWNrIH0pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0VGltZW91dCgpIHtcbiAgICBpZiAodGhpcy50aW1lb3V0VGltZXIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLnJlZiA9IHRoaXMuY2hhbm5lbC5zb2NrZXQuX21ha2VSZWYoKVxuICAgIHRoaXMucmVmRXZlbnQgPSB0aGlzLmNoYW5uZWwuX3JlcGx5RXZlbnROYW1lKHRoaXMucmVmKVxuXG4gICAgY29uc3QgY2FsbGJhY2sgPSAocGF5bG9hZDogYW55KSA9PiB7XG4gICAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpXG4gICAgICB0aGlzLl9jYW5jZWxUaW1lb3V0KClcbiAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gcGF5bG9hZFxuICAgICAgdGhpcy5fbWF0Y2hSZWNlaXZlKHBheWxvYWQpXG4gICAgfVxuXG4gICAgdGhpcy5jaGFubmVsLl9vbih0aGlzLnJlZkV2ZW50LCB7fSwgY2FsbGJhY2spXG5cbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IDxhbnk+c2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3RpbWVvdXQnLCB7fSlcbiAgICB9LCB0aGlzLnRpbWVvdXQpXG4gIH1cblxuICB0cmlnZ2VyKHN0YXR1czogc3RyaW5nLCByZXNwb25zZTogYW55KSB7XG4gICAgaWYgKHRoaXMucmVmRXZlbnQpXG4gICAgICB0aGlzLmNoYW5uZWwuX3RyaWdnZXIodGhpcy5yZWZFdmVudCwgeyBzdGF0dXMsIHJlc3BvbnNlIH0pXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2NhbmNlbFJlZkV2ZW50KClcbiAgICB0aGlzLl9jYW5jZWxUaW1lb3V0KClcbiAgfVxuXG4gIHByaXZhdGUgX2NhbmNlbFJlZkV2ZW50KCkge1xuICAgIGlmICghdGhpcy5yZWZFdmVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jaGFubmVsLl9vZmYodGhpcy5yZWZFdmVudCwge30pXG4gIH1cblxuICBwcml2YXRlIF9jYW5jZWxUaW1lb3V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUaW1lcilcbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IHVuZGVmaW5lZFxuICB9XG5cbiAgcHJpdmF0ZSBfbWF0Y2hSZWNlaXZlKHtcbiAgICBzdGF0dXMsXG4gICAgcmVzcG9uc2UsXG4gIH06IHtcbiAgICBzdGF0dXM6IHN0cmluZ1xuICAgIHJlc3BvbnNlOiBGdW5jdGlvblxuICB9KSB7XG4gICAgdGhpcy5yZWNIb29rc1xuICAgICAgLmZpbHRlcigoaCkgPT4gaC5zdGF0dXMgPT09IHN0YXR1cylcbiAgICAgIC5mb3JFYWNoKChoKSA9PiBoLmNhbGxiYWNrKHJlc3BvbnNlKSlcbiAgfVxuXG4gIHByaXZhdGUgX2hhc1JlY2VpdmVkKHN0YXR1czogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjZWl2ZWRSZXNwICYmIHRoaXMucmVjZWl2ZWRSZXNwLnN0YXR1cyA9PT0gc3RhdHVzXG4gIH1cbn1cbiIsICIvKlxuICBUaGlzIGZpbGUgZHJhd3MgaGVhdmlseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9kMzQ0ZWMwYTczMmFiNGVlMjA0MjE1YjMxZGU2OWNmNGJlNzJlM2JmL2Fzc2V0cy9qcy9waG9lbml4L3ByZXNlbmNlLmpzXG4gIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9kMzQ0ZWMwYTczMmFiNGVlMjA0MjE1YjMxZGU2OWNmNGJlNzJlM2JmL0xJQ0VOU0UubWRcbiovXG5cbmltcG9ydCB0eXBlIHtcbiAgUHJlc2VuY2VPcHRzLFxuICBQcmVzZW5jZU9uSm9pbkNhbGxiYWNrLFxuICBQcmVzZW5jZU9uTGVhdmVDYWxsYmFjayxcbn0gZnJvbSAncGhvZW5peCdcbmltcG9ydCB0eXBlIFJlYWx0aW1lQ2hhbm5lbCBmcm9tICcuL1JlYWx0aW1lQ2hhbm5lbCdcblxudHlwZSBQcmVzZW5jZTxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9PiA9IHtcbiAgcHJlc2VuY2VfcmVmOiBzdHJpbmdcbn0gJiBUXG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUHJlc2VuY2VTdGF0ZTxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9PiA9IHtcbiAgW2tleTogc3RyaW5nXTogUHJlc2VuY2U8VD5bXVxufVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVByZXNlbmNlSm9pblBheWxvYWQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYW55IH0+ID0ge1xuICBldmVudDogYCR7UkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUy5KT0lOfWBcbiAga2V5OiBzdHJpbmdcbiAgY3VycmVudFByZXNlbmNlczogUHJlc2VuY2U8VD5bXVxuICBuZXdQcmVzZW5jZXM6IFByZXNlbmNlPFQ+W11cbn1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVQcmVzZW5jZUxlYXZlUGF5bG9hZDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4gPSB7XG4gIGV2ZW50OiBgJHtSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLkxFQVZFfWBcbiAga2V5OiBzdHJpbmdcbiAgY3VycmVudFByZXNlbmNlczogUHJlc2VuY2U8VD5bXVxuICBsZWZ0UHJlc2VuY2VzOiBQcmVzZW5jZTxUPltdXG59XG5cbmV4cG9ydCBlbnVtIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMge1xuICBTWU5DID0gJ3N5bmMnLFxuICBKT0lOID0gJ2pvaW4nLFxuICBMRUFWRSA9ICdsZWF2ZScsXG59XG5cbnR5cGUgUHJlc2VuY2VEaWZmID0ge1xuICBqb2luczogUmVhbHRpbWVQcmVzZW5jZVN0YXRlXG4gIGxlYXZlczogUmVhbHRpbWVQcmVzZW5jZVN0YXRlXG59XG5cbnR5cGUgUmF3UHJlc2VuY2VTdGF0ZSA9IHtcbiAgW2tleTogc3RyaW5nXToge1xuICAgIG1ldGFzOiB7XG4gICAgICBwaHhfcmVmPzogc3RyaW5nXG4gICAgICBwaHhfcmVmX3ByZXY/OiBzdHJpbmdcbiAgICAgIFtrZXk6IHN0cmluZ106IGFueVxuICAgIH1bXVxuICB9XG59XG5cbnR5cGUgUmF3UHJlc2VuY2VEaWZmID0ge1xuICBqb2luczogUmF3UHJlc2VuY2VTdGF0ZVxuICBsZWF2ZXM6IFJhd1ByZXNlbmNlU3RhdGVcbn1cblxudHlwZSBQcmVzZW5jZUNob29zZXI8VD4gPSAoa2V5OiBzdHJpbmcsIHByZXNlbmNlczogUHJlc2VuY2VbXSkgPT4gVFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFsdGltZVByZXNlbmNlIHtcbiAgc3RhdGU6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSA9IHt9XG4gIHBlbmRpbmdEaWZmczogUmF3UHJlc2VuY2VEaWZmW10gPSBbXVxuICBqb2luUmVmOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICBjYWxsZXI6IHtcbiAgICBvbkpvaW46IFByZXNlbmNlT25Kb2luQ2FsbGJhY2tcbiAgICBvbkxlYXZlOiBQcmVzZW5jZU9uTGVhdmVDYWxsYmFja1xuICAgIG9uU3luYzogKCkgPT4gdm9pZFxuICB9ID0ge1xuICAgIG9uSm9pbjogKCkgPT4ge30sXG4gICAgb25MZWF2ZTogKCkgPT4ge30sXG4gICAgb25TeW5jOiAoKSA9PiB7fSxcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgUHJlc2VuY2UuXG4gICAqXG4gICAqIEBwYXJhbSBjaGFubmVsIC0gVGhlIFJlYWx0aW1lQ2hhbm5lbFxuICAgKiBAcGFyYW0gb3B0cyAtIFRoZSBvcHRpb25zLFxuICAgKiAgICAgICAgZm9yIGV4YW1wbGUgYHtldmVudHM6IHtzdGF0ZTogJ3N0YXRlJywgZGlmZjogJ2RpZmYnfX1gXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsLCBvcHRzPzogUHJlc2VuY2VPcHRzKSB7XG4gICAgY29uc3QgZXZlbnRzID0gb3B0cz8uZXZlbnRzIHx8IHtcbiAgICAgIHN0YXRlOiAncHJlc2VuY2Vfc3RhdGUnLFxuICAgICAgZGlmZjogJ3ByZXNlbmNlX2RpZmYnLFxuICAgIH1cblxuICAgIHRoaXMuY2hhbm5lbC5fb24oZXZlbnRzLnN0YXRlLCB7fSwgKG5ld1N0YXRlOiBSYXdQcmVzZW5jZVN0YXRlKSA9PiB7XG4gICAgICBjb25zdCB7IG9uSm9pbiwgb25MZWF2ZSwgb25TeW5jIH0gPSB0aGlzLmNhbGxlclxuXG4gICAgICB0aGlzLmpvaW5SZWYgPSB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKVxuXG4gICAgICB0aGlzLnN0YXRlID0gUmVhbHRpbWVQcmVzZW5jZS5zeW5jU3RhdGUoXG4gICAgICAgIHRoaXMuc3RhdGUsXG4gICAgICAgIG5ld1N0YXRlLFxuICAgICAgICBvbkpvaW4sXG4gICAgICAgIG9uTGVhdmVcbiAgICAgIClcblxuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMuZm9yRWFjaCgoZGlmZikgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlID0gUmVhbHRpbWVQcmVzZW5jZS5zeW5jRGlmZihcbiAgICAgICAgICB0aGlzLnN0YXRlLFxuICAgICAgICAgIGRpZmYsXG4gICAgICAgICAgb25Kb2luLFxuICAgICAgICAgIG9uTGVhdmVcbiAgICAgICAgKVxuICAgICAgfSlcblxuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuXG4gICAgICBvblN5bmMoKVxuICAgIH0pXG5cbiAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5kaWZmLCB7fSwgKGRpZmY6IFJhd1ByZXNlbmNlRGlmZikgPT4ge1xuICAgICAgY29uc3QgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXJcblxuICAgICAgaWYgKHRoaXMuaW5QZW5kaW5nU3luY1N0YXRlKCkpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMucHVzaChkaWZmKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY0RpZmYoXG4gICAgICAgICAgdGhpcy5zdGF0ZSxcbiAgICAgICAgICBkaWZmLFxuICAgICAgICAgIG9uSm9pbixcbiAgICAgICAgICBvbkxlYXZlXG4gICAgICAgIClcblxuICAgICAgICBvblN5bmMoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLm9uSm9pbigoa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBuZXdQcmVzZW5jZXMpID0+IHtcbiAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcigncHJlc2VuY2UnLCB7XG4gICAgICAgIGV2ZW50OiAnam9pbicsXG4gICAgICAgIGtleSxcbiAgICAgICAgY3VycmVudFByZXNlbmNlcyxcbiAgICAgICAgbmV3UHJlc2VuY2VzLFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5vbkxlYXZlKChrZXksIGN1cnJlbnRQcmVzZW5jZXMsIGxlZnRQcmVzZW5jZXMpID0+IHtcbiAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcigncHJlc2VuY2UnLCB7XG4gICAgICAgIGV2ZW50OiAnbGVhdmUnLFxuICAgICAgICBrZXksXG4gICAgICAgIGN1cnJlbnRQcmVzZW5jZXMsXG4gICAgICAgIGxlZnRQcmVzZW5jZXMsXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uU3luYygoKSA9PiB7XG4gICAgICB0aGlzLmNoYW5uZWwuX3RyaWdnZXIoJ3ByZXNlbmNlJywgeyBldmVudDogJ3N5bmMnIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHN5bmMgdGhlIGxpc3Qgb2YgcHJlc2VuY2VzIG9uIHRoZSBzZXJ2ZXIgd2l0aCB0aGVcbiAgICogY2xpZW50J3Mgc3RhdGUuXG4gICAqXG4gICAqIEFuIG9wdGlvbmFsIGBvbkpvaW5gIGFuZCBgb25MZWF2ZWAgY2FsbGJhY2sgY2FuIGJlIHByb3ZpZGVkIHRvXG4gICAqIHJlYWN0IHRvIGNoYW5nZXMgaW4gdGhlIGNsaWVudCdzIGxvY2FsIHByZXNlbmNlcyBhY3Jvc3NcbiAgICogZGlzY29ubmVjdHMgYW5kIHJlY29ubmVjdHMgd2l0aCB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHN5bmNTdGF0ZShcbiAgICBjdXJyZW50U3RhdGU6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSxcbiAgICBuZXdTdGF0ZTogUmF3UHJlc2VuY2VTdGF0ZSB8IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSxcbiAgICBvbkpvaW46IFByZXNlbmNlT25Kb2luQ2FsbGJhY2ssXG4gICAgb25MZWF2ZTogUHJlc2VuY2VPbkxlYXZlQ2FsbGJhY2tcbiAgKTogUmVhbHRpbWVQcmVzZW5jZVN0YXRlIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuY2xvbmVEZWVwKGN1cnJlbnRTdGF0ZSlcbiAgICBjb25zdCB0cmFuc2Zvcm1lZFN0YXRlID0gdGhpcy50cmFuc2Zvcm1TdGF0ZShuZXdTdGF0ZSlcbiAgICBjb25zdCBqb2luczogUmVhbHRpbWVQcmVzZW5jZVN0YXRlID0ge31cbiAgICBjb25zdCBsZWF2ZXM6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSA9IHt9XG5cbiAgICB0aGlzLm1hcChzdGF0ZSwgKGtleTogc3RyaW5nLCBwcmVzZW5jZXM6IFByZXNlbmNlW10pID0+IHtcbiAgICAgIGlmICghdHJhbnNmb3JtZWRTdGF0ZVtrZXldKSB7XG4gICAgICAgIGxlYXZlc1trZXldID0gcHJlc2VuY2VzXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMubWFwKHRyYW5zZm9ybWVkU3RhdGUsIChrZXksIG5ld1ByZXNlbmNlczogUHJlc2VuY2VbXSkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFByZXNlbmNlczogUHJlc2VuY2VbXSA9IHN0YXRlW2tleV1cblxuICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZXMpIHtcbiAgICAgICAgY29uc3QgbmV3UHJlc2VuY2VSZWZzID0gbmV3UHJlc2VuY2VzLm1hcChcbiAgICAgICAgICAobTogUHJlc2VuY2UpID0+IG0ucHJlc2VuY2VfcmVmXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgY3VyUHJlc2VuY2VSZWZzID0gY3VycmVudFByZXNlbmNlcy5tYXAoXG4gICAgICAgICAgKG06IFByZXNlbmNlKSA9PiBtLnByZXNlbmNlX3JlZlxuICAgICAgICApXG4gICAgICAgIGNvbnN0IGpvaW5lZFByZXNlbmNlczogUHJlc2VuY2VbXSA9IG5ld1ByZXNlbmNlcy5maWx0ZXIoXG4gICAgICAgICAgKG06IFByZXNlbmNlKSA9PiBjdXJQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgbGVmdFByZXNlbmNlczogUHJlc2VuY2VbXSA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKFxuICAgICAgICAgIChtOiBQcmVzZW5jZSkgPT4gbmV3UHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGpvaW5lZFByZXNlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgam9pbnNba2V5XSA9IGpvaW5lZFByZXNlbmNlc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlZnRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxlYXZlc1trZXldID0gbGVmdFByZXNlbmNlc1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2VzXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzLnN5bmNEaWZmKHN0YXRlLCB7IGpvaW5zLCBsZWF2ZXMgfSwgb25Kb2luLCBvbkxlYXZlKVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gc3luYyBhIGRpZmYgb2YgcHJlc2VuY2Ugam9pbiBhbmQgbGVhdmUgZXZlbnRzIGZyb20gdGhlXG4gICAqIHNlcnZlciwgYXMgdGhleSBoYXBwZW4uXG4gICAqXG4gICAqIExpa2UgYHN5bmNTdGF0ZWAsIGBzeW5jRGlmZmAgYWNjZXB0cyBvcHRpb25hbCBgb25Kb2luYCBhbmRcbiAgICogYG9uTGVhdmVgIGNhbGxiYWNrcyB0byByZWFjdCB0byBhIHVzZXIgam9pbmluZyBvciBsZWF2aW5nIGZyb20gYVxuICAgKiBkZXZpY2UuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgc3luY0RpZmYoXG4gICAgc3RhdGU6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSxcbiAgICBkaWZmOiBSYXdQcmVzZW5jZURpZmYgfCBQcmVzZW5jZURpZmYsXG4gICAgb25Kb2luOiBQcmVzZW5jZU9uSm9pbkNhbGxiYWNrLFxuICAgIG9uTGVhdmU6IFByZXNlbmNlT25MZWF2ZUNhbGxiYWNrXG4gICk6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSB7XG4gICAgY29uc3QgeyBqb2lucywgbGVhdmVzIH0gPSB7XG4gICAgICBqb2luczogdGhpcy50cmFuc2Zvcm1TdGF0ZShkaWZmLmpvaW5zKSxcbiAgICAgIGxlYXZlczogdGhpcy50cmFuc2Zvcm1TdGF0ZShkaWZmLmxlYXZlcyksXG4gICAgfVxuXG4gICAgaWYgKCFvbkpvaW4pIHtcbiAgICAgIG9uSm9pbiA9ICgpID0+IHt9XG4gICAgfVxuXG4gICAgaWYgKCFvbkxlYXZlKSB7XG4gICAgICBvbkxlYXZlID0gKCkgPT4ge31cbiAgICB9XG5cbiAgICB0aGlzLm1hcChqb2lucywgKGtleSwgbmV3UHJlc2VuY2VzOiBQcmVzZW5jZVtdKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50UHJlc2VuY2VzOiBQcmVzZW5jZVtdID0gc3RhdGVba2V5XSA/PyBbXVxuICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmVEZWVwKG5ld1ByZXNlbmNlcylcblxuICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBqb2luZWRQcmVzZW5jZVJlZnMgPSBzdGF0ZVtrZXldLm1hcChcbiAgICAgICAgICAobTogUHJlc2VuY2UpID0+IG0ucHJlc2VuY2VfcmVmXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgY3VyUHJlc2VuY2VzOiBQcmVzZW5jZVtdID0gY3VycmVudFByZXNlbmNlcy5maWx0ZXIoXG4gICAgICAgICAgKG06IFByZXNlbmNlKSA9PiBqb2luZWRQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwXG4gICAgICAgIClcblxuICAgICAgICBzdGF0ZVtrZXldLnVuc2hpZnQoLi4uY3VyUHJlc2VuY2VzKVxuICAgICAgfVxuXG4gICAgICBvbkpvaW4oa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBuZXdQcmVzZW5jZXMpXG4gICAgfSlcblxuICAgIHRoaXMubWFwKGxlYXZlcywgKGtleSwgbGVmdFByZXNlbmNlczogUHJlc2VuY2VbXSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZXM6IFByZXNlbmNlW10gPSBzdGF0ZVtrZXldXG5cbiAgICAgIGlmICghY3VycmVudFByZXNlbmNlcykgcmV0dXJuXG5cbiAgICAgIGNvbnN0IHByZXNlbmNlUmVmc1RvUmVtb3ZlID0gbGVmdFByZXNlbmNlcy5tYXAoXG4gICAgICAgIChtOiBQcmVzZW5jZSkgPT4gbS5wcmVzZW5jZV9yZWZcbiAgICAgIClcbiAgICAgIGN1cnJlbnRQcmVzZW5jZXMgPSBjdXJyZW50UHJlc2VuY2VzLmZpbHRlcihcbiAgICAgICAgKG06IFByZXNlbmNlKSA9PiBwcmVzZW5jZVJlZnNUb1JlbW92ZS5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDBcbiAgICAgIClcblxuICAgICAgc3RhdGVba2V5XSA9IGN1cnJlbnRQcmVzZW5jZXNcblxuICAgICAgb25MZWF2ZShrZXksIGN1cnJlbnRQcmVzZW5jZXMsIGxlZnRQcmVzZW5jZXMpXG5cbiAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzLmxlbmd0aCA9PT0gMCkgZGVsZXRlIHN0YXRlW2tleV1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHN0YXRlXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgc3RhdGljIG1hcDxUID0gYW55PihcbiAgICBvYmo6IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZSxcbiAgICBmdW5jOiBQcmVzZW5jZUNob29zZXI8VD5cbiAgKTogVFtdIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5tYXAoKGtleSkgPT4gZnVuYyhrZXksIG9ialtrZXldKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgJ21ldGFzJyBrZXlcbiAgICogQ2hhbmdlICdwaHhfcmVmJyB0byAncHJlc2VuY2VfcmVmJ1xuICAgKiBSZW1vdmUgJ3BoeF9yZWYnIGFuZCAncGh4X3JlZl9wcmV2J1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyByZXR1cm5zIHtcbiAgICogIGFiYzEyMzogW1xuICAgKiAgICB7IHByZXNlbmNlX3JlZjogJzInLCB1c2VyX2lkOiAxIH0sXG4gICAqICAgIHsgcHJlc2VuY2VfcmVmOiAnMycsIHVzZXJfaWQ6IDIgfVxuICAgKiAgXVxuICAgKiB9XG4gICAqIFJlYWx0aW1lUHJlc2VuY2UudHJhbnNmb3JtU3RhdGUoe1xuICAgKiAgYWJjMTIzOiB7XG4gICAqICAgIG1ldGFzOiBbXG4gICAqICAgICAgeyBwaHhfcmVmOiAnMicsIHBoeF9yZWZfcHJldjogJzEnIHVzZXJfaWQ6IDEgfSxcbiAgICogICAgICB7IHBoeF9yZWY6ICczJywgdXNlcl9pZDogMiB9XG4gICAqICAgIF1cbiAgICogIH1cbiAgICogfSlcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyB0cmFuc2Zvcm1TdGF0ZShcbiAgICBzdGF0ZTogUmF3UHJlc2VuY2VTdGF0ZSB8IFJlYWx0aW1lUHJlc2VuY2VTdGF0ZVxuICApOiBSZWFsdGltZVByZXNlbmNlU3RhdGUge1xuICAgIHN0YXRlID0gdGhpcy5jbG9uZURlZXAoc3RhdGUpXG5cbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RhdGUpLnJlZHVjZSgobmV3U3RhdGUsIGtleSkgPT4ge1xuICAgICAgY29uc3QgcHJlc2VuY2VzID0gc3RhdGVba2V5XVxuXG4gICAgICBpZiAoJ21ldGFzJyBpbiBwcmVzZW5jZXMpIHtcbiAgICAgICAgbmV3U3RhdGVba2V5XSA9IHByZXNlbmNlcy5tZXRhcy5tYXAoKHByZXNlbmNlKSA9PiB7XG4gICAgICAgICAgcHJlc2VuY2VbJ3ByZXNlbmNlX3JlZiddID0gcHJlc2VuY2VbJ3BoeF9yZWYnXVxuXG4gICAgICAgICAgZGVsZXRlIHByZXNlbmNlWydwaHhfcmVmJ11cbiAgICAgICAgICBkZWxldGUgcHJlc2VuY2VbJ3BoeF9yZWZfcHJldiddXG5cbiAgICAgICAgICByZXR1cm4gcHJlc2VuY2VcbiAgICAgICAgfSkgYXMgUHJlc2VuY2VbXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3U3RhdGVba2V5XSA9IHByZXNlbmNlc1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3U3RhdGVcbiAgICB9LCB7fSBhcyBSZWFsdGltZVByZXNlbmNlU3RhdGUpXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgc3RhdGljIGNsb25lRGVlcChvYmo6IHsgW2tleTogc3RyaW5nXTogYW55IH0pIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIG9uSm9pbihjYWxsYmFjazogUHJlc2VuY2VPbkpvaW5DYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuY2FsbGVyLm9uSm9pbiA9IGNhbGxiYWNrXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgb25MZWF2ZShjYWxsYmFjazogUHJlc2VuY2VPbkxlYXZlQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLmNhbGxlci5vbkxlYXZlID0gY2FsbGJhY2tcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBvblN5bmMoY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFja1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIGluUGVuZGluZ1N5bmNTdGF0ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuam9pblJlZiB8fCB0aGlzLmpvaW5SZWYgIT09IHRoaXMuY2hhbm5lbC5fam9pblJlZigpXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBDSEFOTkVMX0VWRU5UUywgQ0hBTk5FTF9TVEFURVMgfSBmcm9tICcuL2xpYi9jb25zdGFudHMnXG5pbXBvcnQgUHVzaCBmcm9tICcuL2xpYi9wdXNoJ1xuaW1wb3J0IHR5cGUgUmVhbHRpbWVDbGllbnQgZnJvbSAnLi9SZWFsdGltZUNsaWVudCdcbmltcG9ydCBUaW1lciBmcm9tICcuL2xpYi90aW1lcidcbmltcG9ydCBSZWFsdGltZVByZXNlbmNlLCB7XG4gIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMsXG59IGZyb20gJy4vUmVhbHRpbWVQcmVzZW5jZSdcbmltcG9ydCB0eXBlIHtcbiAgUmVhbHRpbWVQcmVzZW5jZUpvaW5QYXlsb2FkLFxuICBSZWFsdGltZVByZXNlbmNlTGVhdmVQYXlsb2FkLFxuICBSZWFsdGltZVByZXNlbmNlU3RhdGUsXG59IGZyb20gJy4vUmVhbHRpbWVQcmVzZW5jZSdcbmltcG9ydCAqIGFzIFRyYW5zZm9ybWVycyBmcm9tICcuL2xpYi90cmFuc2Zvcm1lcnMnXG5pbXBvcnQgeyBodHRwRW5kcG9pbnRVUkwgfSBmcm9tICcuL2xpYi90cmFuc2Zvcm1lcnMnXG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lQ2hhbm5lbE9wdGlvbnMgPSB7XG4gIGNvbmZpZzoge1xuICAgIC8qKlxuICAgICAqIHNlbGYgb3B0aW9uIGVuYWJsZXMgY2xpZW50IHRvIHJlY2VpdmUgbWVzc2FnZSBpdCBicm9hZGNhc3RcbiAgICAgKiBhY2sgb3B0aW9uIGluc3RydWN0cyBzZXJ2ZXIgdG8gYWNrbm93bGVkZ2UgdGhhdCBicm9hZGNhc3QgbWVzc2FnZSB3YXMgcmVjZWl2ZWRcbiAgICAgKi9cbiAgICBicm9hZGNhc3Q/OiB7IHNlbGY/OiBib29sZWFuOyBhY2s/OiBib29sZWFuIH1cbiAgICAvKipcbiAgICAgKiBrZXkgb3B0aW9uIGlzIHVzZWQgdG8gdHJhY2sgcHJlc2VuY2UgcGF5bG9hZCBhY3Jvc3MgY2xpZW50c1xuICAgICAqL1xuICAgIHByZXNlbmNlPzogeyBrZXk/OiBzdHJpbmcgfVxuICAgIC8qKlxuICAgICAqIGRlZmluZXMgaWYgdGhlIGNoYW5uZWwgaXMgcHJpdmF0ZSBvciBub3QgYW5kIGlmIFJMUyBwb2xpY2llcyB3aWxsIGJlIHVzZWQgdG8gY2hlY2sgZGF0YVxuICAgICAqL1xuICAgIHByaXZhdGU/OiBib29sZWFuXG4gIH1cbn1cblxudHlwZSBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc1BheWxvYWRCYXNlID0ge1xuICBzY2hlbWE6IHN0cmluZ1xuICB0YWJsZTogc3RyaW5nXG4gIGNvbW1pdF90aW1lc3RhbXA6IHN0cmluZ1xuICBlcnJvcnM6IHN0cmluZ1tdXG59XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUG9zdGdyZXNJbnNlcnRQYXlsb2FkPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PiA9XG4gIFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzUGF5bG9hZEJhc2UgJiB7XG4gICAgZXZlbnRUeXBlOiBgJHtSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVC5JTlNFUlR9YFxuICAgIG5ldzogVFxuICAgIG9sZDoge31cbiAgfVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVBvc3RncmVzVXBkYXRlUGF5bG9hZDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4gPVxuICBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc1BheWxvYWRCYXNlICYge1xuICAgIGV2ZW50VHlwZTogYCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuVVBEQVRFfWBcbiAgICBuZXc6IFRcbiAgICBvbGQ6IFBhcnRpYWw8VD5cbiAgfVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZVBvc3RncmVzRGVsZXRlUGF5bG9hZDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4gPVxuICBSZWFsdGltZVBvc3RncmVzQ2hhbmdlc1BheWxvYWRCYXNlICYge1xuICAgIGV2ZW50VHlwZTogYCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuREVMRVRFfWBcbiAgICBuZXc6IHt9XG4gICAgb2xkOiBQYXJ0aWFsPFQ+XG4gIH1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PiA9XG4gIHwgUmVhbHRpbWVQb3N0Z3Jlc0luc2VydFBheWxvYWQ8VD5cbiAgfCBSZWFsdGltZVBvc3RncmVzVXBkYXRlUGF5bG9hZDxUPlxuICB8IFJlYWx0aW1lUG9zdGdyZXNEZWxldGVQYXlsb2FkPFQ+XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzRmlsdGVyPFxuICBUIGV4dGVuZHMgYCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlR9YFxuPiA9IHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGRhdGFiYXNlIGNoYW5nZSB0byBsaXN0ZW4gdG8uXG4gICAqL1xuICBldmVudDogVFxuICAvKipcbiAgICogVGhlIGRhdGFiYXNlIHNjaGVtYSB0byBsaXN0ZW4gdG8uXG4gICAqL1xuICBzY2hlbWE6IHN0cmluZ1xuICAvKipcbiAgICogVGhlIGRhdGFiYXNlIHRhYmxlIHRvIGxpc3RlbiB0by5cbiAgICovXG4gIHRhYmxlPzogc3RyaW5nXG4gIC8qKlxuICAgKiBSZWNlaXZlIGRhdGFiYXNlIGNoYW5nZXMgd2hlbiBmaWx0ZXIgaXMgbWF0Y2hlZC5cbiAgICovXG4gIGZpbHRlcj86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZUNoYW5uZWxTZW5kUmVzcG9uc2UgPSAnb2snIHwgJ3RpbWVkIG91dCcgfCAnZXJyb3InXG5cbmV4cG9ydCBlbnVtIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UIHtcbiAgQUxMID0gJyonLFxuICBJTlNFUlQgPSAnSU5TRVJUJyxcbiAgVVBEQVRFID0gJ1VQREFURScsXG4gIERFTEVURSA9ICdERUxFVEUnLFxufVxuXG5leHBvcnQgZW51bSBSRUFMVElNRV9MSVNURU5fVFlQRVMge1xuICBCUk9BRENBU1QgPSAnYnJvYWRjYXN0JyxcbiAgUFJFU0VOQ0UgPSAncHJlc2VuY2UnLFxuICBQT1NUR1JFU19DSEFOR0VTID0gJ3Bvc3RncmVzX2NoYW5nZXMnLFxuICBTWVNURU0gPSAnc3lzdGVtJyxcbn1cblxuZXhwb3J0IGVudW0gUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUyB7XG4gIFNVQlNDUklCRUQgPSAnU1VCU0NSSUJFRCcsXG4gIFRJTUVEX09VVCA9ICdUSU1FRF9PVVQnLFxuICBDTE9TRUQgPSAnQ0xPU0VEJyxcbiAgQ0hBTk5FTF9FUlJPUiA9ICdDSEFOTkVMX0VSUk9SJyxcbn1cblxuZXhwb3J0IGNvbnN0IFJFQUxUSU1FX0NIQU5ORUxfU1RBVEVTID0gQ0hBTk5FTF9TVEFURVNcblxuaW50ZXJmYWNlIFBvc3RncmVzQ2hhbmdlc0ZpbHRlcnMge1xuICBwb3N0Z3Jlc19jaGFuZ2VzOiB7XG4gICAgaWQ6IHN0cmluZ1xuICAgIGV2ZW50OiBzdHJpbmdcbiAgICBzY2hlbWE/OiBzdHJpbmdcbiAgICB0YWJsZT86IHN0cmluZ1xuICAgIGZpbHRlcj86IHN0cmluZ1xuICB9W11cbn1cbi8qKiBBIGNoYW5uZWwgaXMgdGhlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrIG9mIFJlYWx0aW1lXG4gKiBhbmQgbmFycm93cyB0aGUgc2NvcGUgb2YgZGF0YSBmbG93IHRvIHN1YnNjcmliZWQgY2xpZW50cy5cbiAqIFlvdSBjYW4gdGhpbmsgb2YgYSBjaGFubmVsIGFzIGEgY2hhdHJvb20gd2hlcmUgcGFydGljaXBhbnRzIGFyZSBhYmxlIHRvIHNlZSB3aG8ncyBvbmxpbmVcbiAqIGFuZCBzZW5kIGFuZCByZWNlaXZlIG1lc3NhZ2VzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFsdGltZUNoYW5uZWwge1xuICBiaW5kaW5nczoge1xuICAgIFtrZXk6IHN0cmluZ106IHtcbiAgICAgIHR5cGU6IHN0cmluZ1xuICAgICAgZmlsdGVyOiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gICAgICBjYWxsYmFjazogRnVuY3Rpb25cbiAgICAgIGlkPzogc3RyaW5nXG4gICAgfVtdXG4gIH0gPSB7fVxuICB0aW1lb3V0OiBudW1iZXJcbiAgc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgam9pbmVkT25jZSA9IGZhbHNlXG4gIGpvaW5QdXNoOiBQdXNoXG4gIHJlam9pblRpbWVyOiBUaW1lclxuICBwdXNoQnVmZmVyOiBQdXNoW10gPSBbXVxuICBwcmVzZW5jZTogUmVhbHRpbWVQcmVzZW5jZVxuICBicm9hZGNhc3RFbmRwb2ludFVSTDogc3RyaW5nXG4gIHN1YlRvcGljOiBzdHJpbmdcbiAgcHJpdmF0ZTogYm9vbGVhblxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUb3BpYyBuYW1lIGNhbiBiZSBhbnkgc3RyaW5nLiAqL1xuICAgIHB1YmxpYyB0b3BpYzogc3RyaW5nLFxuICAgIHB1YmxpYyBwYXJhbXM6IFJlYWx0aW1lQ2hhbm5lbE9wdGlvbnMgPSB7IGNvbmZpZzoge30gfSxcbiAgICBwdWJsaWMgc29ja2V0OiBSZWFsdGltZUNsaWVudFxuICApIHtcbiAgICB0aGlzLnN1YlRvcGljID0gdG9waWMucmVwbGFjZSgvXnJlYWx0aW1lOi9pLCAnJylcbiAgICB0aGlzLnBhcmFtcy5jb25maWcgPSB7XG4gICAgICAuLi57XG4gICAgICAgIGJyb2FkY2FzdDogeyBhY2s6IGZhbHNlLCBzZWxmOiBmYWxzZSB9LFxuICAgICAgICBwcmVzZW5jZTogeyBrZXk6ICcnIH0sXG4gICAgICAgIHByaXZhdGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIC4uLnBhcmFtcy5jb25maWcsXG4gICAgfVxuICAgIHRoaXMudGltZW91dCA9IHRoaXMuc29ja2V0LnRpbWVvdXRcbiAgICB0aGlzLmpvaW5QdXNoID0gbmV3IFB1c2goXG4gICAgICB0aGlzLFxuICAgICAgQ0hBTk5FTF9FVkVOVFMuam9pbixcbiAgICAgIHRoaXMucGFyYW1zLFxuICAgICAgdGhpcy50aW1lb3V0XG4gICAgKVxuICAgIHRoaXMucmVqb2luVGltZXIgPSBuZXcgVGltZXIoXG4gICAgICAoKSA9PiB0aGlzLl9yZWpvaW5VbnRpbENvbm5lY3RlZCgpLFxuICAgICAgdGhpcy5zb2NrZXQucmVjb25uZWN0QWZ0ZXJNc1xuICAgIClcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoJ29rJywgKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5lZFxuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaCgocHVzaEV2ZW50OiBQdXNoKSA9PiBwdXNoRXZlbnQuc2VuZCgpKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW11cbiAgICB9KVxuICAgIHRoaXMuX29uQ2xvc2UoKCkgPT4ge1xuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgY2xvc2UgJHt0aGlzLnRvcGljfSAke3RoaXMuX2pvaW5SZWYoKX1gKVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICAgICAgdGhpcy5zb2NrZXQuX3JlbW92ZSh0aGlzKVxuICAgIH0pXG4gICAgdGhpcy5fb25FcnJvcigocmVhc29uOiBzdHJpbmcpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pc0xlYXZpbmcoKSB8fCB0aGlzLl9pc0Nsb3NlZCgpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGVycm9yICR7dGhpcy50b3BpY31gLCByZWFzb24pXG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKVxuICAgIH0pXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9pc0pvaW5pbmcoKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGB0aW1lb3V0ICR7dGhpcy50b3BpY31gLCB0aGlzLmpvaW5QdXNoLnRpbWVvdXQpXG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKVxuICAgIH0pXG4gICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMucmVwbHksIHt9LCAocGF5bG9hZDogYW55LCByZWY6IHN0cmluZykgPT4ge1xuICAgICAgdGhpcy5fdHJpZ2dlcih0aGlzLl9yZXBseUV2ZW50TmFtZShyZWYpLCBwYXlsb2FkKVxuICAgIH0pXG5cbiAgICB0aGlzLnByZXNlbmNlID0gbmV3IFJlYWx0aW1lUHJlc2VuY2UodGhpcylcblxuICAgIHRoaXMuYnJvYWRjYXN0RW5kcG9pbnRVUkwgPVxuICAgICAgaHR0cEVuZHBvaW50VVJMKHRoaXMuc29ja2V0LmVuZFBvaW50KSArICcvYXBpL2Jyb2FkY2FzdCdcbiAgICB0aGlzLnByaXZhdGUgPSB0aGlzLnBhcmFtcy5jb25maWcucHJpdmF0ZSB8fCBmYWxzZVxuICB9XG5cbiAgLyoqIFN1YnNjcmliZSByZWdpc3RlcnMgeW91ciBjbGllbnQgd2l0aCB0aGUgc2VydmVyICovXG4gIHN1YnNjcmliZShcbiAgICBjYWxsYmFjaz86IChzdGF0dXM6IFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMsIGVycj86IEVycm9yKSA9PiB2b2lkLFxuICAgIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXRcbiAgKTogUmVhbHRpbWVDaGFubmVsIHtcbiAgICBpZiAoIXRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QoKVxuICAgIH1cbiAgICBpZiAodGhpcy5qb2luZWRPbmNlKSB7XG4gICAgICB0aHJvdyBgdHJpZWQgdG8gc3Vic2NyaWJlIG11bHRpcGxlIHRpbWVzLiAnc3Vic2NyaWJlJyBjYW4gb25seSBiZSBjYWxsZWQgYSBzaW5nbGUgdGltZSBwZXIgY2hhbm5lbCBpbnN0YW5jZWBcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb25maWc6IHsgYnJvYWRjYXN0LCBwcmVzZW5jZSwgcHJpdmF0ZTogaXNQcml2YXRlIH0sXG4gICAgICB9ID0gdGhpcy5wYXJhbXNcblxuICAgICAgdGhpcy5fb25FcnJvcigoZTogRXJyb3IpID0+XG4gICAgICAgIGNhbGxiYWNrPy4oUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DSEFOTkVMX0VSUk9SLCBlKVxuICAgICAgKVxuICAgICAgdGhpcy5fb25DbG9zZSgoKSA9PiBjYWxsYmFjaz8uKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0xPU0VEKSlcblxuICAgICAgY29uc3QgYWNjZXNzVG9rZW5QYXlsb2FkOiB7IGFjY2Vzc190b2tlbj86IHN0cmluZyB9ID0ge31cbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgYnJvYWRjYXN0LFxuICAgICAgICBwcmVzZW5jZSxcbiAgICAgICAgcG9zdGdyZXNfY2hhbmdlczpcbiAgICAgICAgICB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXM/Lm1hcCgocikgPT4gci5maWx0ZXIpID8/IFtdLFxuICAgICAgICBwcml2YXRlOiBpc1ByaXZhdGUsXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlKSB7XG4gICAgICAgIGFjY2Vzc1Rva2VuUGF5bG9hZC5hY2Nlc3NfdG9rZW4gPSB0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlXG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlSm9pblBheWxvYWQoeyAuLi57IGNvbmZpZyB9LCAuLi5hY2Nlc3NUb2tlblBheWxvYWQgfSlcblxuICAgICAgdGhpcy5qb2luZWRPbmNlID0gdHJ1ZVxuICAgICAgdGhpcy5fcmVqb2luKHRpbWVvdXQpXG5cbiAgICAgIHRoaXMuam9pblB1c2hcbiAgICAgICAgLnJlY2VpdmUoJ29rJywgYXN5bmMgKHsgcG9zdGdyZXNfY2hhbmdlcyB9OiBQb3N0Z3Jlc0NoYW5nZXNGaWx0ZXJzKSA9PiB7XG4gICAgICAgICAgdGhpcy5zb2NrZXQuc2V0QXV0aCgpXG4gICAgICAgICAgaWYgKHBvc3RncmVzX2NoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2FsbGJhY2s/LihSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLlNVQlNDUklCRUQpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50UG9zdGdyZXNCaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlc1xuICAgICAgICAgICAgY29uc3QgYmluZGluZ3NMZW4gPSBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzPy5sZW5ndGggPz8gMFxuICAgICAgICAgICAgY29uc3QgbmV3UG9zdGdyZXNCaW5kaW5ncyA9IFtdXG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3NMZW47IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBjbGllbnRQb3N0Z3Jlc0JpbmRpbmcgPSBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzW2ldXG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHsgZXZlbnQsIHNjaGVtYSwgdGFibGUsIGZpbHRlciB9LFxuICAgICAgICAgICAgICB9ID0gY2xpZW50UG9zdGdyZXNCaW5kaW5nXG4gICAgICAgICAgICAgIGNvbnN0IHNlcnZlclBvc3RncmVzRmlsdGVyID1cbiAgICAgICAgICAgICAgICBwb3N0Z3Jlc19jaGFuZ2VzICYmIHBvc3RncmVzX2NoYW5nZXNbaV1cblxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc2VydmVyUG9zdGdyZXNGaWx0ZXIgJiZcbiAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5ldmVudCA9PT0gZXZlbnQgJiZcbiAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5zY2hlbWEgPT09IHNjaGVtYSAmJlxuICAgICAgICAgICAgICAgIHNlcnZlclBvc3RncmVzRmlsdGVyLnRhYmxlID09PSB0YWJsZSAmJlxuICAgICAgICAgICAgICAgIHNlcnZlclBvc3RncmVzRmlsdGVyLmZpbHRlciA9PT0gZmlsdGVyXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG5ld1Bvc3RncmVzQmluZGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAuLi5jbGllbnRQb3N0Z3Jlc0JpbmRpbmcsXG4gICAgICAgICAgICAgICAgICBpZDogc2VydmVyUG9zdGdyZXNGaWx0ZXIuaWQsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKClcbiAgICAgICAgICAgICAgICBjYWxsYmFjaz8uKFxuICAgICAgICAgICAgICAgICAgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DSEFOTkVMX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnbWlzbWF0Y2ggYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCBiaW5kaW5ncyBmb3IgcG9zdGdyZXMgY2hhbmdlcydcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzID0gbmV3UG9zdGdyZXNCaW5kaW5nc1xuXG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLlNVQlNDUklCRUQpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5yZWNlaXZlKCdlcnJvcicsIChlcnJvcjogeyBba2V5OiBzdHJpbmddOiBhbnkgfSkgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrPy4oXG4gICAgICAgICAgICBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNIQU5ORUxfRVJST1IsXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KE9iamVjdC52YWx1ZXMoZXJyb3IpLmpvaW4oJywgJykgfHwgJ2Vycm9yJylcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0pXG4gICAgICAgIC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrPy4oUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5USU1FRF9PVVQpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcmVzZW5jZVN0YXRlPFxuICAgIFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge31cbiAgPigpOiBSZWFsdGltZVByZXNlbmNlU3RhdGU8VD4ge1xuICAgIHJldHVybiB0aGlzLnByZXNlbmNlLnN0YXRlIGFzIFJlYWx0aW1lUHJlc2VuY2VTdGF0ZTxUPlxuICB9XG5cbiAgYXN5bmMgdHJhY2soXG4gICAgcGF5bG9hZDogeyBba2V5OiBzdHJpbmddOiBhbnkgfSxcbiAgICBvcHRzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge31cbiAgKTogUHJvbWlzZTxSZWFsdGltZUNoYW5uZWxTZW5kUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kKFxuICAgICAge1xuICAgICAgICB0eXBlOiAncHJlc2VuY2UnLFxuICAgICAgICBldmVudDogJ3RyYWNrJyxcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgIH0sXG4gICAgICBvcHRzLnRpbWVvdXQgfHwgdGhpcy50aW1lb3V0XG4gICAgKVxuICB9XG5cbiAgYXN5bmMgdW50cmFjayhcbiAgICBvcHRzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge31cbiAgKTogUHJvbWlzZTxSZWFsdGltZUNoYW5uZWxTZW5kUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kKFxuICAgICAge1xuICAgICAgICB0eXBlOiAncHJlc2VuY2UnLFxuICAgICAgICBldmVudDogJ3VudHJhY2snLFxuICAgICAgfSxcbiAgICAgIG9wdHNcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBldmVudCBoYW5kbGVyIHRoYXQgbGlzdGVucyB0byBjaGFuZ2VzLlxuICAgKi9cbiAgb24oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFfWAsXG4gICAgZmlsdGVyOiB7IGV2ZW50OiBgJHtSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLlNZTkN9YCB9LFxuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFfWAsXG4gICAgZmlsdGVyOiB7IGV2ZW50OiBgJHtSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLkpPSU59YCB9LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDogUmVhbHRpbWVQcmVzZW5jZUpvaW5QYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFfWAsXG4gICAgZmlsdGVyOiB7IGV2ZW50OiBgJHtSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLkxFQVZFfWAgfSxcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IFJlYWx0aW1lUHJlc2VuY2VMZWF2ZVBheWxvYWQ8VD4pID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsXG4gIG9uPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFueSB9PihcbiAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuUE9TVEdSRVNfQ0hBTkdFU31gLFxuICAgIGZpbHRlcjogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNGaWx0ZXI8YCR7UkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQuQUxMfWA+LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDogUmVhbHRpbWVQb3N0Z3Jlc0NoYW5nZXNQYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBPU1RHUkVTX0NIQU5HRVN9YCxcbiAgICBmaWx0ZXI6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzRmlsdGVyPGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULklOU0VSVH1gPixcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IFJlYWx0aW1lUG9zdGdyZXNJbnNlcnRQYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBPU1RHUkVTX0NIQU5HRVN9YCxcbiAgICBmaWx0ZXI6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzRmlsdGVyPGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULlVQREFURX1gPixcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IFJlYWx0aW1lUG9zdGdyZXNVcGRhdGVQYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlBPU1RHUkVTX0NIQU5HRVN9YCxcbiAgICBmaWx0ZXI6IFJlYWx0aW1lUG9zdGdyZXNDaGFuZ2VzRmlsdGVyPGAke1JFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULkRFTEVURX1gPixcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IFJlYWx0aW1lUG9zdGdyZXNEZWxldGVQYXlsb2FkPFQ+KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICAvKipcbiAgICogVGhlIGZvbGxvd2luZyBpcyBwbGFjZWQgaGVyZSB0byBkaXNwbGF5IG9uIHN1cGFiYXNlLmNvbS9kb2NzL3JlZmVyZW5jZS9qYXZhc2NyaXB0L3N1YnNjcmliZS5cbiAgICogQHBhcmFtIHR5cGUgT25lIG9mIFwiYnJvYWRjYXN0XCIsIFwicHJlc2VuY2VcIiwgb3IgXCJwb3N0Z3Jlc19jaGFuZ2VzXCIuXG4gICAqIEBwYXJhbSBmaWx0ZXIgQ3VzdG9tIG9iamVjdCBzcGVjaWZpYyB0byB0aGUgUmVhbHRpbWUgZmVhdHVyZSBkZXRhaWxpbmcgd2hpY2ggcGF5bG9hZHMgdG8gcmVjZWl2ZS5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiBldmVudCBoYW5kbGVyIGlzIHRyaWdnZXJlZC5cbiAgICovXG4gIG9uKFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5CUk9BRENBU1R9YCxcbiAgICBmaWx0ZXI6IHsgZXZlbnQ6IHN0cmluZyB9LFxuICAgIGNhbGxiYWNrOiAocGF5bG9hZDoge1xuICAgICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLkJST0FEQ0FTVH1gXG4gICAgICBldmVudDogc3RyaW5nXG4gICAgICBba2V5OiBzdHJpbmddOiBhbnlcbiAgICB9KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLkJST0FEQ0FTVH1gLFxuICAgIGZpbHRlcjogeyBldmVudDogc3RyaW5nIH0sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiB7XG4gICAgICB0eXBlOiBgJHtSRUFMVElNRV9MSVNURU5fVFlQRVMuQlJPQURDQVNUfWBcbiAgICAgIGV2ZW50OiBzdHJpbmdcbiAgICAgIHBheWxvYWQ6IFRcbiAgICB9KSA9PiB2b2lkXG4gICk6IFJlYWx0aW1lQ2hhbm5lbFxuICBvbjxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4oXG4gICAgdHlwZTogYCR7UkVBTFRJTUVfTElTVEVOX1RZUEVTLlNZU1RFTX1gLFxuICAgIGZpbHRlcjoge30sXG4gICAgY2FsbGJhY2s6IChwYXlsb2FkOiBhbnkpID0+IHZvaWRcbiAgKTogUmVhbHRpbWVDaGFubmVsXG4gIG9uKFxuICAgIHR5cGU6IGAke1JFQUxUSU1FX0xJU1RFTl9UWVBFU31gLFxuICAgIGZpbHRlcjogeyBldmVudDogc3RyaW5nOyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSxcbiAgICBjYWxsYmFjazogKHBheWxvYWQ6IGFueSkgPT4gdm9pZFxuICApOiBSZWFsdGltZUNoYW5uZWwge1xuICAgIHJldHVybiB0aGlzLl9vbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKVxuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIG1lc3NhZ2UgaW50byB0aGUgY2hhbm5lbC5cbiAgICpcbiAgICogQHBhcmFtIGFyZ3MgQXJndW1lbnRzIHRvIHNlbmQgdG8gY2hhbm5lbFxuICAgKiBAcGFyYW0gYXJncy50eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHRvIHNlbmRcbiAgICogQHBhcmFtIGFyZ3MuZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IGJlaW5nIHNlbnRcbiAgICogQHBhcmFtIGFyZ3MucGF5bG9hZCBQYXlsb2FkIHRvIGJlIHNlbnRcbiAgICogQHBhcmFtIG9wdHMgT3B0aW9ucyB0byBiZSB1c2VkIGR1cmluZyB0aGUgc2VuZCBwcm9jZXNzXG4gICAqL1xuICBhc3luYyBzZW5kKFxuICAgIGFyZ3M6IHtcbiAgICAgIHR5cGU6ICdicm9hZGNhc3QnIHwgJ3ByZXNlbmNlJyB8ICdwb3N0Z3Jlc19jaGFuZ2VzJ1xuICAgICAgZXZlbnQ6IHN0cmluZ1xuICAgICAgcGF5bG9hZD86IGFueVxuICAgICAgW2tleTogc3RyaW5nXTogYW55XG4gICAgfSxcbiAgICBvcHRzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge31cbiAgKTogUHJvbWlzZTxSZWFsdGltZUNoYW5uZWxTZW5kUmVzcG9uc2U+IHtcbiAgICBpZiAoIXRoaXMuX2NhblB1c2goKSAmJiBhcmdzLnR5cGUgPT09ICdicm9hZGNhc3QnKSB7XG4gICAgICBjb25zdCB7IGV2ZW50LCBwYXlsb2FkOiBlbmRwb2ludF9wYXlsb2FkIH0gPSBhcmdzXG4gICAgICBjb25zdCBhdXRob3JpemF0aW9uID0gdGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZVxuICAgICAgICA/IGBCZWFyZXIgJHt0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlfWBcbiAgICAgICAgOiAnJ1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uLFxuICAgICAgICAgIGFwaWtleTogdGhpcy5zb2NrZXQuYXBpS2V5ID8gdGhpcy5zb2NrZXQuYXBpS2V5IDogJycsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRvcGljOiB0aGlzLnN1YlRvcGljLFxuICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgcGF5bG9hZDogZW5kcG9pbnRfcGF5bG9hZCxcbiAgICAgICAgICAgICAgcHJpdmF0ZTogdGhpcy5wcml2YXRlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9KSxcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9mZXRjaFdpdGhUaW1lb3V0KFxuICAgICAgICAgIHRoaXMuYnJvYWRjYXN0RW5kcG9pbnRVUkwsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBvcHRzLnRpbWVvdXQgPz8gdGhpcy50aW1lb3V0XG4gICAgICAgIClcblxuICAgICAgICBhd2FpdCByZXNwb25zZS5ib2R5Py5jYW5jZWwoKVxuICAgICAgICByZXR1cm4gcmVzcG9uc2Uub2sgPyAnb2snIDogJ2Vycm9yJ1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgcmV0dXJuICd0aW1lZCBvdXQnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICdlcnJvcidcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgcHVzaCA9IHRoaXMuX3B1c2goYXJncy50eXBlLCBhcmdzLCBvcHRzLnRpbWVvdXQgfHwgdGhpcy50aW1lb3V0KVxuXG4gICAgICAgIGlmIChhcmdzLnR5cGUgPT09ICdicm9hZGNhc3QnICYmICF0aGlzLnBhcmFtcz8uY29uZmlnPy5icm9hZGNhc3Q/LmFjaykge1xuICAgICAgICAgIHJlc29sdmUoJ29rJylcbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2gucmVjZWl2ZSgnb2snLCAoKSA9PiByZXNvbHZlKCdvaycpKVxuICAgICAgICBwdXNoLnJlY2VpdmUoJ2Vycm9yJywgKCkgPT4gcmVzb2x2ZSgnZXJyb3InKSlcbiAgICAgICAgcHVzaC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4gcmVzb2x2ZSgndGltZWQgb3V0JykpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUpvaW5QYXlsb2FkKHBheWxvYWQ6IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiB2b2lkIHtcbiAgICB0aGlzLmpvaW5QdXNoLnVwZGF0ZVBheWxvYWQocGF5bG9hZClcbiAgfVxuXG4gIC8qKlxuICAgKiBMZWF2ZXMgdGhlIGNoYW5uZWwuXG4gICAqXG4gICAqIFVuc3Vic2NyaWJlcyBmcm9tIHNlcnZlciBldmVudHMsIGFuZCBpbnN0cnVjdHMgY2hhbm5lbCB0byB0ZXJtaW5hdGUgb24gc2VydmVyLlxuICAgKiBUcmlnZ2VycyBvbkNsb3NlKCkgaG9va3MuXG4gICAqXG4gICAqIFRvIHJlY2VpdmUgbGVhdmUgYWNrbm93bGVkZ2VtZW50cywgdXNlIHRoZSBhIGByZWNlaXZlYCBob29rIHRvIGJpbmQgdG8gdGhlIHNlcnZlciBhY2ssIGllOlxuICAgKiBjaGFubmVsLnVuc3Vic2NyaWJlKCkucmVjZWl2ZShcIm9rXCIsICgpID0+IGFsZXJ0KFwibGVmdCFcIikgKVxuICAgKi9cbiAgdW5zdWJzY3JpYmUodGltZW91dCA9IHRoaXMudGltZW91dCk6IFByb21pc2U8J29rJyB8ICd0aW1lZCBvdXQnIHwgJ2Vycm9yJz4ge1xuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nXG4gICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBsZWF2ZSAke3RoaXMudG9waWN9YClcbiAgICAgIHRoaXMuX3RyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuY2xvc2UsICdsZWF2ZScsIHRoaXMuX2pvaW5SZWYoKSlcbiAgICB9XG5cbiAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICAvLyBEZXN0cm95IGpvaW5QdXNoIHRvIGF2b2lkIGNvbm5lY3Rpb24gdGltZW91dHMgZHVyaW5nIHVuc2NyaXB0aW9uIHBoYXNlXG4gICAgdGhpcy5qb2luUHVzaC5kZXN0cm95KClcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIHt9LCB0aW1lb3V0KVxuICAgICAgbGVhdmVQdXNoXG4gICAgICAgIC5yZWNlaXZlKCdvaycsICgpID0+IHtcbiAgICAgICAgICBvbkNsb3NlKClcbiAgICAgICAgICByZXNvbHZlKCdvaycpXG4gICAgICAgIH0pXG4gICAgICAgIC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgICAgIG9uQ2xvc2UoKVxuICAgICAgICAgIHJlc29sdmUoJ3RpbWVkIG91dCcpXG4gICAgICAgIH0pXG4gICAgICAgIC5yZWNlaXZlKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCdlcnJvcicpXG4gICAgICAgIH0pXG5cbiAgICAgIGxlYXZlUHVzaC5zZW5kKClcbiAgICAgIGlmICghdGhpcy5fY2FuUHVzaCgpKSB7XG4gICAgICAgIGxlYXZlUHVzaC50cmlnZ2VyKCdvaycsIHt9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG5cbiAgYXN5bmMgX2ZldGNoV2l0aFRpbWVvdXQoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgb3B0aW9uczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSxcbiAgICB0aW1lb3V0OiBudW1iZXJcbiAgKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIGNvbnN0IGlkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpXG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc29ja2V0LmZldGNoKHVybCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgfSlcblxuICAgIGNsZWFyVGltZW91dChpZClcblxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcHVzaChcbiAgICBldmVudDogc3RyaW5nLFxuICAgIHBheWxvYWQ6IHsgW2tleTogc3RyaW5nXTogYW55IH0sXG4gICAgdGltZW91dCA9IHRoaXMudGltZW91dFxuICApIHtcbiAgICBpZiAoIXRoaXMuam9pbmVkT25jZSkge1xuICAgICAgdGhyb3cgYHRyaWVkIHRvIHB1c2ggJyR7ZXZlbnR9JyB0byAnJHt0aGlzLnRvcGljfScgYmVmb3JlIGpvaW5pbmcuIFVzZSBjaGFubmVsLnN1YnNjcmliZSgpIGJlZm9yZSBwdXNoaW5nIGV2ZW50c2BcbiAgICB9XG4gICAgbGV0IHB1c2hFdmVudCA9IG5ldyBQdXNoKHRoaXMsIGV2ZW50LCBwYXlsb2FkLCB0aW1lb3V0KVxuICAgIGlmICh0aGlzLl9jYW5QdXNoKCkpIHtcbiAgICAgIHB1c2hFdmVudC5zZW5kKClcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaEV2ZW50LnN0YXJ0VGltZW91dCgpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIucHVzaChwdXNoRXZlbnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHB1c2hFdmVudFxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRhYmxlIG1lc3NhZ2UgaG9va1xuICAgKlxuICAgKiBSZWNlaXZlcyBhbGwgZXZlbnRzIGZvciBzcGVjaWFsaXplZCBtZXNzYWdlIGhhbmRsaW5nIGJlZm9yZSBkaXNwYXRjaGluZyB0byB0aGUgY2hhbm5lbCBjYWxsYmFja3MuXG4gICAqIE11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9vbk1lc3NhZ2UoX2V2ZW50OiBzdHJpbmcsIHBheWxvYWQ6IGFueSwgX3JlZj86IHN0cmluZykge1xuICAgIHJldHVybiBwYXlsb2FkXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9pc01lbWJlcih0b3BpYzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudG9waWMgPT09IHRvcGljXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9qb2luUmVmKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuam9pblB1c2gucmVmXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF90cmlnZ2VyKHR5cGU6IHN0cmluZywgcGF5bG9hZD86IGFueSwgcmVmPzogc3RyaW5nKSB7XG4gICAgY29uc3QgdHlwZUxvd2VyID0gdHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpXG4gICAgY29uc3QgeyBjbG9zZSwgZXJyb3IsIGxlYXZlLCBqb2luIH0gPSBDSEFOTkVMX0VWRU5UU1xuICAgIGNvbnN0IGV2ZW50czogc3RyaW5nW10gPSBbY2xvc2UsIGVycm9yLCBsZWF2ZSwgam9pbl1cbiAgICBpZiAocmVmICYmIGV2ZW50cy5pbmRleE9mKHR5cGVMb3dlcikgPj0gMCAmJiByZWYgIT09IHRoaXMuX2pvaW5SZWYoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGxldCBoYW5kbGVkUGF5bG9hZCA9IHRoaXMuX29uTWVzc2FnZSh0eXBlTG93ZXIsIHBheWxvYWQsIHJlZilcbiAgICBpZiAocGF5bG9hZCAmJiAhaGFuZGxlZFBheWxvYWQpIHtcbiAgICAgIHRocm93ICdjaGFubmVsIG9uTWVzc2FnZSBjYWxsYmFja3MgbXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWQnXG4gICAgfVxuXG4gICAgaWYgKFsnaW5zZXJ0JywgJ3VwZGF0ZScsICdkZWxldGUnXS5pbmNsdWRlcyh0eXBlTG93ZXIpKSB7XG4gICAgICB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXNcbiAgICAgICAgPy5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgYmluZC5maWx0ZXI/LmV2ZW50ID09PSAnKicgfHxcbiAgICAgICAgICAgIGJpbmQuZmlsdGVyPy5ldmVudD8udG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0gdHlwZUxvd2VyXG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgICAubWFwKChiaW5kKSA9PiBiaW5kLmNhbGxiYWNrKGhhbmRsZWRQYXlsb2FkLCByZWYpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl1cbiAgICAgICAgPy5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBbJ2Jyb2FkY2FzdCcsICdwcmVzZW5jZScsICdwb3N0Z3Jlc19jaGFuZ2VzJ10uaW5jbHVkZXModHlwZUxvd2VyKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKCdpZCcgaW4gYmluZCkge1xuICAgICAgICAgICAgICBjb25zdCBiaW5kSWQgPSBiaW5kLmlkXG4gICAgICAgICAgICAgIGNvbnN0IGJpbmRFdmVudCA9IGJpbmQuZmlsdGVyPy5ldmVudFxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIGJpbmRJZCAmJlxuICAgICAgICAgICAgICAgIHBheWxvYWQuaWRzPy5pbmNsdWRlcyhiaW5kSWQpICYmXG4gICAgICAgICAgICAgICAgKGJpbmRFdmVudCA9PT0gJyonIHx8XG4gICAgICAgICAgICAgICAgICBiaW5kRXZlbnQ/LnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuZGF0YT8udHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBiaW5kRXZlbnQgPSBiaW5kPy5maWx0ZXI/LmV2ZW50Py50b0xvY2FsZUxvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgYmluZEV2ZW50ID09PSAnKicgfHxcbiAgICAgICAgICAgICAgICBiaW5kRXZlbnQgPT09IHBheWxvYWQ/LmV2ZW50Py50b0xvY2FsZUxvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmQudHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSB0eXBlTG93ZXJcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5tYXAoKGJpbmQpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZWRQYXlsb2FkID09PSAnb2JqZWN0JyAmJiAnaWRzJyBpbiBoYW5kbGVkUGF5bG9hZCkge1xuICAgICAgICAgICAgY29uc3QgcG9zdGdyZXNDaGFuZ2VzID0gaGFuZGxlZFBheWxvYWQuZGF0YVxuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWEsIHRhYmxlLCBjb21taXRfdGltZXN0YW1wLCB0eXBlLCBlcnJvcnMgfSA9XG4gICAgICAgICAgICAgIHBvc3RncmVzQ2hhbmdlc1xuICAgICAgICAgICAgY29uc3QgZW5yaWNoZWRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICBzY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgICBjb21taXRfdGltZXN0YW1wOiBjb21taXRfdGltZXN0YW1wLFxuICAgICAgICAgICAgICBldmVudFR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIG5ldzoge30sXG4gICAgICAgICAgICAgIG9sZDoge30sXG4gICAgICAgICAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlZFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgIC4uLmVucmljaGVkUGF5bG9hZCxcbiAgICAgICAgICAgICAgLi4udGhpcy5fZ2V0UGF5bG9hZFJlY29yZHMocG9zdGdyZXNDaGFuZ2VzKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmKVxuICAgICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2lzQ2xvc2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2lzSm9pbmVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luZWRcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2lzSm9pbmluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmluZ1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaXNMZWF2aW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9yZXBseUV2ZW50TmFtZShyZWY6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBjaGFuX3JlcGx5XyR7cmVmfWBcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX29uKHR5cGU6IHN0cmluZywgZmlsdGVyOiB7IFtrZXk6IHN0cmluZ106IGFueSB9LCBjYWxsYmFjazogRnVuY3Rpb24pIHtcbiAgICBjb25zdCB0eXBlTG93ZXIgPSB0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKClcblxuICAgIGNvbnN0IGJpbmRpbmcgPSB7XG4gICAgICB0eXBlOiB0eXBlTG93ZXIsXG4gICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdKSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0ucHVzaChiaW5kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0gPSBbYmluZGluZ11cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfb2ZmKHR5cGU6IHN0cmluZywgZmlsdGVyOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KSB7XG4gICAgY29uc3QgdHlwZUxvd2VyID0gdHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpXG5cbiAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0gPSB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0uZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICByZXR1cm4gIShcbiAgICAgICAgYmluZC50eXBlPy50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSB0eXBlTG93ZXIgJiZcbiAgICAgICAgUmVhbHRpbWVDaGFubmVsLmlzRXF1YWwoYmluZC5maWx0ZXIsIGZpbHRlcilcbiAgICAgIClcbiAgICB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgc3RhdGljIGlzRXF1YWwoXG4gICAgb2JqMTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSxcbiAgICBvYmoyOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gICkge1xuICAgIGlmIChPYmplY3Qua2V5cyhvYmoxKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG9iajIpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrIGluIG9iajEpIHtcbiAgICAgIGlmIChvYmoxW2tdICE9PSBvYmoyW2tdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX3Jlam9pblVudGlsQ29ubmVjdGVkKCkge1xuICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KClcbiAgICBpZiAodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgdGhpcy5fcmVqb2luKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYW5uZWwgY2xvc2VzLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgX29uQ2xvc2UoY2FsbGJhY2s6IEZ1bmN0aW9uKSB7XG4gICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIHt9LCBjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2hhbm5lbCBlbmNvdW50ZXJlcyBhbiBlcnJvci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIF9vbkVycm9yKGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIHRoaXMuX29uKENIQU5ORUxfRVZFTlRTLmVycm9yLCB7fSwgKHJlYXNvbjogc3RyaW5nKSA9PiBjYWxsYmFjayhyZWFzb24pKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzb2NrZXQgaXMgY29ubmVjdGVkIGFuZCB0aGUgY2hhbm5lbCBoYXMgYmVlbiBqb2luZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBfY2FuUHVzaCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLl9pc0pvaW5lZCgpXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX3Jlam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2lzTGVhdmluZygpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5zb2NrZXQuX2xlYXZlT3BlblRvcGljKHRoaXMudG9waWMpXG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5pbmdcbiAgICB0aGlzLmpvaW5QdXNoLnJlc2VuZCh0aW1lb3V0KVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIF9nZXRQYXlsb2FkUmVjb3JkcyhwYXlsb2FkOiBhbnkpIHtcbiAgICBjb25zdCByZWNvcmRzID0ge1xuICAgICAgbmV3OiB7fSxcbiAgICAgIG9sZDoge30sXG4gICAgfVxuXG4gICAgaWYgKHBheWxvYWQudHlwZSA9PT0gJ0lOU0VSVCcgfHwgcGF5bG9hZC50eXBlID09PSAnVVBEQVRFJykge1xuICAgICAgcmVjb3Jkcy5uZXcgPSBUcmFuc2Zvcm1lcnMuY29udmVydENoYW5nZURhdGEoXG4gICAgICAgIHBheWxvYWQuY29sdW1ucyxcbiAgICAgICAgcGF5bG9hZC5yZWNvcmRcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAocGF5bG9hZC50eXBlID09PSAnVVBEQVRFJyB8fCBwYXlsb2FkLnR5cGUgPT09ICdERUxFVEUnKSB7XG4gICAgICByZWNvcmRzLm9sZCA9IFRyYW5zZm9ybWVycy5jb252ZXJ0Q2hhbmdlRGF0YShcbiAgICAgICAgcGF5bG9hZC5jb2x1bW5zLFxuICAgICAgICBwYXlsb2FkLm9sZF9yZWNvcmRcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjb3Jkc1xuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBXZWJTb2NrZXQgYXMgV1NXZWJTb2NrZXQgfSBmcm9tICd3cydcblxuaW1wb3J0IHtcbiAgQ0hBTk5FTF9FVkVOVFMsXG4gIENPTk5FQ1RJT05fU1RBVEUsXG4gIERFRkFVTFRfSEVBREVSUyxcbiAgREVGQVVMVF9USU1FT1VULFxuICBTT0NLRVRfU1RBVEVTLFxuICBUUkFOU1BPUlRTLFxuICBWU04sXG4gIFdTX0NMT1NFX05PUk1BTCxcbn0gZnJvbSAnLi9saWIvY29uc3RhbnRzJ1xuaW1wb3J0IFNlcmlhbGl6ZXIgZnJvbSAnLi9saWIvc2VyaWFsaXplcidcbmltcG9ydCBUaW1lciBmcm9tICcuL2xpYi90aW1lcidcblxuaW1wb3J0IHsgaHR0cEVuZHBvaW50VVJMIH0gZnJvbSAnLi9saWIvdHJhbnNmb3JtZXJzJ1xuaW1wb3J0IFJlYWx0aW1lQ2hhbm5lbCBmcm9tICcuL1JlYWx0aW1lQ2hhbm5lbCdcbmltcG9ydCB0eXBlIHsgUmVhbHRpbWVDaGFubmVsT3B0aW9ucyB9IGZyb20gJy4vUmVhbHRpbWVDaGFubmVsJ1xuXG50eXBlIEZldGNoID0gdHlwZW9mIGZldGNoXG5cbmV4cG9ydCB0eXBlIENoYW5uZWwgPSB7XG4gIG5hbWU6IHN0cmluZ1xuICBpbnNlcnRlZF9hdDogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xuICBpZDogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lQ2xpZW50T3B0aW9ucyA9IHtcbiAgdHJhbnNwb3J0PzogV2ViU29ja2V0TGlrZUNvbnN0cnVjdG9yXG4gIHRpbWVvdXQ/OiBudW1iZXJcbiAgaGVhcnRiZWF0SW50ZXJ2YWxNcz86IG51bWJlclxuICBsb2dnZXI/OiBGdW5jdGlvblxuICBlbmNvZGU/OiBGdW5jdGlvblxuICBkZWNvZGU/OiBGdW5jdGlvblxuICByZWNvbm5lY3RBZnRlck1zPzogRnVuY3Rpb25cbiAgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgcGFyYW1zPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICBsb2dfbGV2ZWw/OiAnaW5mbycgfCAnZGVidWcnIHwgJ3dhcm4nIHwgJ2Vycm9yJ1xuICBmZXRjaD86IEZldGNoXG4gIHdvcmtlcj86IGJvb2xlYW5cbiAgd29ya2VyVXJsPzogc3RyaW5nXG4gIGFjY2Vzc1Rva2VuPzogKCkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsPlxufVxuXG5leHBvcnQgdHlwZSBSZWFsdGltZU1lc3NhZ2UgPSB7XG4gIHRvcGljOiBzdHJpbmdcbiAgZXZlbnQ6IHN0cmluZ1xuICBwYXlsb2FkOiBhbnlcbiAgcmVmOiBzdHJpbmdcbiAgam9pbl9yZWY/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgUmVhbHRpbWVSZW1vdmVDaGFubmVsUmVzcG9uc2UgPSAnb2snIHwgJ3RpbWVkIG91dCcgfCAnZXJyb3InXG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFdlYlNvY2tldExpa2VDb25zdHJ1Y3RvciB7XG4gIG5ldyAoXG4gICAgYWRkcmVzczogc3RyaW5nIHwgVVJMLFxuICAgIF9pZ25vcmVkPzogYW55LFxuICAgIG9wdGlvbnM/OiB7IGhlYWRlcnM6IE9iamVjdCB8IHVuZGVmaW5lZCB9XG4gICk6IFdlYlNvY2tldExpa2Vcbn1cblxuZXhwb3J0IHR5cGUgV2ViU29ja2V0TGlrZSA9IFdlYlNvY2tldCB8IFdTV2ViU29ja2V0IHwgV1NXZWJTb2NrZXREdW1teVxuXG5leHBvcnQgaW50ZXJmYWNlIFdlYlNvY2tldExpa2VFcnJvciB7XG4gIGVycm9yOiBhbnlcbiAgbWVzc2FnZTogc3RyaW5nXG4gIHR5cGU6IHN0cmluZ1xufVxuXG5jb25zdCBOQVRJVkVfV0VCU09DS0VUX0FWQUlMQUJMRSA9IHR5cGVvZiBXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnXG5jb25zdCBXT1JLRVJfU0NSSVBUID0gYFxuICBhZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZSkgPT4ge1xuICAgIGlmIChlLmRhdGEuZXZlbnQgPT09IFwic3RhcnRcIikge1xuICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gcG9zdE1lc3NhZ2UoeyBldmVudDogXCJrZWVwQWxpdmVcIiB9KSwgZS5kYXRhLmludGVydmFsKTtcbiAgICB9XG4gIH0pO2BcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWx0aW1lQ2xpZW50IHtcbiAgYWNjZXNzVG9rZW5WYWx1ZTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgYXBpS2V5OiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICBjaGFubmVsczogUmVhbHRpbWVDaGFubmVsW10gPSBbXVxuICBlbmRQb2ludDogc3RyaW5nID0gJydcbiAgaHR0cEVuZHBvaW50OiBzdHJpbmcgPSAnJ1xuICBoZWFkZXJzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IERFRkFVTFRfSEVBREVSU1xuICBwYXJhbXM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge31cbiAgdGltZW91dDogbnVtYmVyID0gREVGQVVMVF9USU1FT1VUXG4gIHRyYW5zcG9ydDogV2ViU29ja2V0TGlrZUNvbnN0cnVjdG9yIHwgbnVsbFxuICBoZWFydGJlYXRJbnRlcnZhbE1zOiBudW1iZXIgPSAzMDAwMFxuICBoZWFydGJlYXRUaW1lcjogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gIHBlbmRpbmdIZWFydGJlYXRSZWY6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gIHJlZjogbnVtYmVyID0gMFxuICByZWNvbm5lY3RUaW1lcjogVGltZXJcbiAgbG9nZ2VyOiBGdW5jdGlvbiA9IG5vb3BcbiAgZW5jb2RlOiBGdW5jdGlvblxuICBkZWNvZGU6IEZ1bmN0aW9uXG4gIHJlY29ubmVjdEFmdGVyTXM6IEZ1bmN0aW9uXG4gIGNvbm46IFdlYlNvY2tldExpa2UgfCBudWxsID0gbnVsbFxuICBzZW5kQnVmZmVyOiBGdW5jdGlvbltdID0gW11cbiAgc2VyaWFsaXplcjogU2VyaWFsaXplciA9IG5ldyBTZXJpYWxpemVyKClcbiAgc3RhdGVDaGFuZ2VDYWxsYmFja3M6IHtcbiAgICBvcGVuOiBGdW5jdGlvbltdXG4gICAgY2xvc2U6IEZ1bmN0aW9uW11cbiAgICBlcnJvcjogRnVuY3Rpb25bXVxuICAgIG1lc3NhZ2U6IEZ1bmN0aW9uW11cbiAgfSA9IHtcbiAgICBvcGVuOiBbXSxcbiAgICBjbG9zZTogW10sXG4gICAgZXJyb3I6IFtdLFxuICAgIG1lc3NhZ2U6IFtdLFxuICB9XG4gIGZldGNoOiBGZXRjaFxuICBhY2Nlc3NUb2tlbjogKCgpID0+IFByb21pc2U8c3RyaW5nIHwgbnVsbD4pIHwgbnVsbCA9IG51bGxcbiAgd29ya2VyPzogYm9vbGVhblxuICB3b3JrZXJVcmw/OiBzdHJpbmdcbiAgd29ya2VyUmVmPzogV29ya2VyXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBlbmRQb2ludCBUaGUgc3RyaW5nIFdlYlNvY2tldCBlbmRwb2ludCwgaWUsIFwid3M6Ly9leGFtcGxlLmNvbS9zb2NrZXRcIiwgXCJ3c3M6Ly9leGFtcGxlLmNvbVwiLCBcIi9zb2NrZXRcIiAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAgICogQHBhcmFtIGh0dHBFbmRwb2ludCBUaGUgc3RyaW5nIEhUVFAgZW5kcG9pbnQsIGllLCBcImh0dHBzOi8vZXhhbXBsZS5jb21cIiwgXCIvXCIgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zcG9ydCBUaGUgV2Vic29ja2V0IFRyYW5zcG9ydCwgZm9yIGV4YW1wbGUgV2ViU29ja2V0LlxuICAgKiBAcGFyYW0gb3B0aW9ucy50aW1lb3V0IFRoZSBkZWZhdWx0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHRyaWdnZXIgcHVzaCB0aW1lb3V0cy5cbiAgICogQHBhcmFtIG9wdGlvbnMucGFyYW1zIFRoZSBvcHRpb25hbCBwYXJhbXMgdG8gcGFzcyB3aGVuIGNvbm5lY3RpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgVGhlIG9wdGlvbmFsIGhlYWRlcnMgdG8gcGFzcyB3aGVuIGNvbm5lY3RpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zLmhlYXJ0YmVhdEludGVydmFsTXMgVGhlIG1pbGxpc2VjIGludGVydmFsIHRvIHNlbmQgYSBoZWFydGJlYXQgbWVzc2FnZS5cbiAgICogQHBhcmFtIG9wdGlvbnMubG9nZ2VyIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZywgaWU6IGxvZ2dlcjogKGtpbmQsIG1zZywgZGF0YSkgPT4geyBjb25zb2xlLmxvZyhgJHtraW5kfTogJHttc2d9YCwgZGF0YSkgfVxuICAgKiBAcGFyYW0gb3B0aW9ucy5lbmNvZGUgVGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBvdXRnb2luZyBtZXNzYWdlcy4gRGVmYXVsdHMgdG8gSlNPTjogKHBheWxvYWQsIGNhbGxiYWNrKSA9PiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSlcbiAgICogQHBhcmFtIG9wdGlvbnMuZGVjb2RlIFRoZSBmdW5jdGlvbiB0byBkZWNvZGUgaW5jb21pbmcgbWVzc2FnZXMuIERlZmF1bHRzIHRvIFNlcmlhbGl6ZXIncyBkZWNvZGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlY29ubmVjdEFmdGVyTXMgaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsc2VjIHJlY29ubmVjdCBpbnRlcnZhbC4gRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mZi5cbiAgICogQHBhcmFtIG9wdGlvbnMud29ya2VyIFVzZSBXZWIgV29ya2VyIHRvIHNldCBhIHNpZGUgZmxvdy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqIEBwYXJhbSBvcHRpb25zLndvcmtlclVybCBUaGUgVVJMIG9mIHRoZSB3b3JrZXIgc2NyaXB0LiBEZWZhdWx0cyB0byBodHRwczovL3JlYWx0aW1lLnN1cGFiYXNlLmNvbS93b3JrZXIuanMgdGhhdCBpbmNsdWRlcyBhIGhlYXJ0YmVhdCBldmVudCBjYWxsIHRvIGtlZXAgdGhlIGNvbm5lY3Rpb24gYWxpdmUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbmRQb2ludDogc3RyaW5nLCBvcHRpb25zPzogUmVhbHRpbWVDbGllbnRPcHRpb25zKSB7XG4gICAgdGhpcy5lbmRQb2ludCA9IGAke2VuZFBvaW50fS8ke1RSQU5TUE9SVFMud2Vic29ja2V0fWBcbiAgICB0aGlzLmh0dHBFbmRwb2ludCA9IGh0dHBFbmRwb2ludFVSTChlbmRQb2ludClcbiAgICBpZiAob3B0aW9ucz8udHJhbnNwb3J0KSB7XG4gICAgICB0aGlzLnRyYW5zcG9ydCA9IG9wdGlvbnMudHJhbnNwb3J0XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbFxuICAgIH1cbiAgICBpZiAob3B0aW9ucz8ucGFyYW1zKSB0aGlzLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zXG4gICAgaWYgKG9wdGlvbnM/LmhlYWRlcnMpIHRoaXMuaGVhZGVycyA9IHsgLi4udGhpcy5oZWFkZXJzLCAuLi5vcHRpb25zLmhlYWRlcnMgfVxuICAgIGlmIChvcHRpb25zPy50aW1lb3V0KSB0aGlzLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXRcbiAgICBpZiAob3B0aW9ucz8ubG9nZ2VyKSB0aGlzLmxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyXG4gICAgaWYgKG9wdGlvbnM/LmhlYXJ0YmVhdEludGVydmFsTXMpXG4gICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMgPSBvcHRpb25zLmhlYXJ0YmVhdEludGVydmFsTXNcblxuICAgIGNvbnN0IGFjY2Vzc1Rva2VuVmFsdWUgPSBvcHRpb25zPy5wYXJhbXM/LmFwaWtleVxuICAgIGlmIChhY2Nlc3NUb2tlblZhbHVlKSB7XG4gICAgICB0aGlzLmFjY2Vzc1Rva2VuVmFsdWUgPSBhY2Nlc3NUb2tlblZhbHVlXG4gICAgICB0aGlzLmFwaUtleSA9IGFjY2Vzc1Rva2VuVmFsdWVcbiAgICB9XG5cbiAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPSBvcHRpb25zPy5yZWNvbm5lY3RBZnRlck1zXG4gICAgICA/IG9wdGlvbnMucmVjb25uZWN0QWZ0ZXJNc1xuICAgICAgOiAodHJpZXM6IG51bWJlcikgPT4ge1xuICAgICAgICAgIHJldHVybiBbMTAwMCwgMjAwMCwgNTAwMCwgMTAwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAgICAgICAgfVxuICAgIHRoaXMuZW5jb2RlID0gb3B0aW9ucz8uZW5jb2RlXG4gICAgICA/IG9wdGlvbnMuZW5jb2RlXG4gICAgICA6IChwYXlsb2FkOiBKU09OLCBjYWxsYmFjazogRnVuY3Rpb24pID0+IHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpXG4gICAgICAgIH1cbiAgICB0aGlzLmRlY29kZSA9IG9wdGlvbnM/LmRlY29kZVxuICAgICAgPyBvcHRpb25zLmRlY29kZVxuICAgICAgOiB0aGlzLnNlcmlhbGl6ZXIuZGVjb2RlLmJpbmQodGhpcy5zZXJpYWxpemVyKVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICAgIHRoaXMuY29ubmVjdCgpXG4gICAgfSwgdGhpcy5yZWNvbm5lY3RBZnRlck1zKVxuXG4gICAgdGhpcy5mZXRjaCA9IHRoaXMuX3Jlc29sdmVGZXRjaChvcHRpb25zPy5mZXRjaClcbiAgICBpZiAob3B0aW9ucz8ud29ya2VyKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5Xb3JrZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWIgV29ya2VyIGlzIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgfVxuICAgICAgdGhpcy53b3JrZXIgPSBvcHRpb25zPy53b3JrZXIgfHwgZmFsc2VcbiAgICAgIHRoaXMud29ya2VyVXJsID0gb3B0aW9ucz8ud29ya2VyVXJsXG4gICAgfVxuICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBvcHRpb25zPy5hY2Nlc3NUb2tlbiB8fCBudWxsXG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdHMgdGhlIHNvY2tldCwgdW5sZXNzIGFscmVhZHkgY29ubmVjdGVkLlxuICAgKi9cbiAgY29ubmVjdCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICAgIHRoaXMuY29ubiA9IG5ldyB0aGlzLnRyYW5zcG9ydCh0aGlzLmVuZHBvaW50VVJMKCksIHVuZGVmaW5lZCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKE5BVElWRV9XRUJTT0NLRVRfQVZBSUxBQkxFKSB7XG4gICAgICB0aGlzLmNvbm4gPSBuZXcgV2ViU29ja2V0KHRoaXMuZW5kcG9pbnRVUkwoKSlcbiAgICAgIHRoaXMuc2V0dXBDb25uZWN0aW9uKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY29ubiA9IG5ldyBXU1dlYlNvY2tldER1bW15KHRoaXMuZW5kcG9pbnRVUkwoKSwgdW5kZWZpbmVkLCB7XG4gICAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgICB0aGlzLmNvbm4gPSBudWxsXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICBpbXBvcnQoJ3dzJykudGhlbigoeyBkZWZhdWx0OiBXUyB9KSA9PiB7XG4gICAgICB0aGlzLmNvbm4gPSBuZXcgV1ModGhpcy5lbmRwb2ludFVSTCgpLCB1bmRlZmluZWQsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgfSlcbiAgICAgIHRoaXMuc2V0dXBDb25uZWN0aW9uKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFVSTCBvZiB0aGUgd2Vic29ja2V0LlxuICAgKiBAcmV0dXJucyBzdHJpbmcgVGhlIFVSTCBvZiB0aGUgd2Vic29ja2V0LlxuICAgKi9cbiAgZW5kcG9pbnRVUkwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fYXBwZW5kUGFyYW1zKFxuICAgICAgdGhpcy5lbmRQb2ludCxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGFyYW1zLCB7IHZzbjogVlNOIH0pXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBjb2RlIEEgbnVtZXJpYyBzdGF0dXMgY29kZSB0byBzZW5kIG9uIGRpc2Nvbm5lY3QuXG4gICAqIEBwYXJhbSByZWFzb24gQSBjdXN0b20gcmVhc29uIGZvciB0aGUgZGlzY29ubmVjdC5cbiAgICovXG4gIGRpc2Nvbm5lY3QoY29kZT86IG51bWJlciwgcmVhc29uPzogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7fSAvLyBub29wXG4gICAgICBpZiAoY29kZSkge1xuICAgICAgICB0aGlzLmNvbm4uY2xvc2UoY29kZSwgcmVhc29uID8/ICcnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb25uLmNsb3NlKClcbiAgICAgIH1cbiAgICAgIHRoaXMuY29ubiA9IG51bGxcbiAgICAgIC8vIHJlbW92ZSBvcGVuIGhhbmRsZXNcbiAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKVxuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGNyZWF0ZWQgY2hhbm5lbHNcbiAgICovXG4gIGdldENoYW5uZWxzKCk6IFJlYWx0aW1lQ2hhbm5lbFtdIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsc1xuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhIHNpbmdsZSBjaGFubmVsXG4gICAqIEBwYXJhbSBjaGFubmVsIEEgUmVhbHRpbWVDaGFubmVsIGluc3RhbmNlXG4gICAqL1xuICBhc3luYyByZW1vdmVDaGFubmVsKFxuICAgIGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbFxuICApOiBQcm9taXNlPFJlYWx0aW1lUmVtb3ZlQ2hhbm5lbFJlc3BvbnNlPiB7XG4gICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgY2hhbm5lbC51bnN1YnNjcmliZSgpXG4gICAgaWYgKHRoaXMuY2hhbm5lbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIH1cbiAgICByZXR1cm4gc3RhdHVzXG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIGFsbCBjaGFubmVsc1xuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQWxsQ2hhbm5lbHMoKTogUHJvbWlzZTxSZWFsdGltZVJlbW92ZUNoYW5uZWxSZXNwb25zZVtdPiB7XG4gICAgY29uc3QgdmFsdWVzXzEgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMuY2hhbm5lbHMubWFwKChjaGFubmVsKSA9PiBjaGFubmVsLnVuc3Vic2NyaWJlKCkpXG4gICAgKVxuICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgcmV0dXJuIHZhbHVlc18xXG4gIH1cblxuICAvKipcbiAgICogTG9ncyB0aGUgbWVzc2FnZS5cbiAgICpcbiAgICogRm9yIGN1c3RvbWl6ZWQgbG9nZ2luZywgYHRoaXMubG9nZ2VyYCBjYW4gYmUgb3ZlcnJpZGRlbi5cbiAgICovXG4gIGxvZyhraW5kOiBzdHJpbmcsIG1zZzogc3RyaW5nLCBkYXRhPzogYW55KSB7XG4gICAgdGhpcy5sb2dnZXIoa2luZCwgbXNnLCBkYXRhKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNvY2tldC5cbiAgICovXG4gIGNvbm5lY3Rpb25TdGF0ZSgpOiBDT05ORUNUSU9OX1NUQVRFIHtcbiAgICBzd2l0Y2ggKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4ucmVhZHlTdGF0ZSkge1xuICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLmNvbm5lY3Rpbmc6XG4gICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLkNvbm5lY3RpbmdcbiAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5vcGVuOlxuICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5PcGVuXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY2xvc2luZzpcbiAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuQ2xvc2luZ1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuQ2xvc2VkXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlzIHRoZSBjb25uZWN0aW9uIGlzIG9wZW4uXG4gICAqL1xuICBpc0Nvbm5lY3RlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uU3RhdGUoKSA9PT0gQ09OTkVDVElPTl9TVEFURS5PcGVuXG4gIH1cblxuICBjaGFubmVsKFxuICAgIHRvcGljOiBzdHJpbmcsXG4gICAgcGFyYW1zOiBSZWFsdGltZUNoYW5uZWxPcHRpb25zID0geyBjb25maWc6IHt9IH1cbiAgKTogUmVhbHRpbWVDaGFubmVsIHtcbiAgICBjb25zdCBjaGFuID0gbmV3IFJlYWx0aW1lQ2hhbm5lbChgcmVhbHRpbWU6JHt0b3BpY31gLCBwYXJhbXMsIHRoaXMpXG4gICAgdGhpcy5jaGFubmVscy5wdXNoKGNoYW4pXG4gICAgcmV0dXJuIGNoYW5cbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIG91dCBhIG1lc3NhZ2UgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQuXG4gICAqXG4gICAqIElmIHRoZSBzb2NrZXQgaXMgbm90IGNvbm5lY3RlZCwgdGhlIG1lc3NhZ2UgZ2V0cyBlbnF1ZXVlZCB3aXRoaW4gYSBsb2NhbCBidWZmZXIsIGFuZCBzZW50IG91dCB3aGVuIGEgY29ubmVjdGlvbiBpcyBuZXh0IGVzdGFibGlzaGVkLlxuICAgKi9cbiAgcHVzaChkYXRhOiBSZWFsdGltZU1lc3NhZ2UpOiB2b2lkIHtcbiAgICBjb25zdCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmIH0gPSBkYXRhXG4gICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLmVuY29kZShkYXRhLCAocmVzdWx0OiBhbnkpID0+IHtcbiAgICAgICAgdGhpcy5jb25uPy5zZW5kKHJlc3VsdClcbiAgICAgIH0pXG4gICAgfVxuICAgIHRoaXMubG9nKCdwdXNoJywgYCR7dG9waWN9ICR7ZXZlbnR9ICgke3JlZn0pYCwgcGF5bG9hZClcbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICBjYWxsYmFjaygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBKV1QgYWNjZXNzIHRva2VuIHVzZWQgZm9yIGNoYW5uZWwgc3Vic2NyaXB0aW9uIGF1dGhvcml6YXRpb24gYW5kIFJlYWx0aW1lIFJMUy5cbiAgICpcbiAgICogSWYgcGFyYW0gaXMgbnVsbCBpdCB3aWxsIHVzZSB0aGUgYGFjY2Vzc1Rva2VuYCBjYWxsYmFjayBmdW5jdGlvbiBvciB0aGUgdG9rZW4gc2V0IG9uIHRoZSBjbGllbnQuXG4gICAqXG4gICAqIE9uIGNhbGxiYWNrIHVzZWQsIGl0IHdpbGwgc2V0IHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4gaW50ZXJuYWwgdG8gdGhlIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIHRva2VuIEEgSldUIHN0cmluZyB0byBvdmVycmlkZSB0aGUgdG9rZW4gc2V0IG9uIHRoZSBjbGllbnQuXG4gICAqL1xuICBhc3luYyBzZXRBdXRoKHRva2VuOiBzdHJpbmcgfCBudWxsID0gbnVsbCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCB0b2tlblRvU2VuZCA9XG4gICAgICB0b2tlbiB8fFxuICAgICAgKHRoaXMuYWNjZXNzVG9rZW4gJiYgKGF3YWl0IHRoaXMuYWNjZXNzVG9rZW4oKSkpIHx8XG4gICAgICB0aGlzLmFjY2Vzc1Rva2VuVmFsdWVcblxuICAgIGlmICh0b2tlblRvU2VuZCkge1xuICAgICAgbGV0IHBhcnNlZCA9IG51bGxcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UoYXRvYih0b2tlblRvU2VuZC5zcGxpdCgnLicpWzFdKSlcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIGlmIChwYXJzZWQgJiYgcGFyc2VkLmV4cCkge1xuICAgICAgICBsZXQgbm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMClcbiAgICAgICAgbGV0IHZhbGlkID0gbm93IC0gcGFyc2VkLmV4cCA8IDBcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgICAgJ2F1dGgnLFxuICAgICAgICAgICAgYEludmFsaWRKV1RUb2tlbjogSW52YWxpZCB2YWx1ZSBmb3IgSldUIGNsYWltIFwiZXhwXCIgd2l0aCB2YWx1ZSAke3BhcnNlZC5leHB9YFxuICAgICAgICAgIClcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICBgSW52YWxpZEpXVFRva2VuOiBJbnZhbGlkIHZhbHVlIGZvciBKV1QgY2xhaW0gXCJleHBcIiB3aXRoIHZhbHVlICR7cGFyc2VkLmV4cH1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWNjZXNzVG9rZW5WYWx1ZSA9IHRva2VuVG9TZW5kXG4gICAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IHtcbiAgICAgICAgdG9rZW5Ub1NlbmQgJiYgY2hhbm5lbC51cGRhdGVKb2luUGF5bG9hZCh7IGFjY2Vzc190b2tlbjogdG9rZW5Ub1NlbmQgfSlcblxuICAgICAgICBpZiAoY2hhbm5lbC5qb2luZWRPbmNlICYmIGNoYW5uZWwuX2lzSm9pbmVkKCkpIHtcbiAgICAgICAgICBjaGFubmVsLl9wdXNoKENIQU5ORUxfRVZFTlRTLmFjY2Vzc190b2tlbiwge1xuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB0b2tlblRvU2VuZCxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2VuZHMgYSBoZWFydGJlYXQgbWVzc2FnZSBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZC5cbiAgICovXG4gIGFzeW5jIHNlbmRIZWFydGJlYXQoKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKSB7XG4gICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgICB0aGlzLmxvZyhcbiAgICAgICAgJ3RyYW5zcG9ydCcsXG4gICAgICAgICdoZWFydGJlYXQgdGltZW91dC4gQXR0ZW1wdGluZyB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvbidcbiAgICAgIClcbiAgICAgIHRoaXMuY29ubj8uY2xvc2UoV1NfQ0xPU0VfTk9STUFMLCAnaGVhcmJlYXQgdGltZW91dCcpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gdGhpcy5fbWFrZVJlZigpXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgIHRvcGljOiAncGhvZW5peCcsXG4gICAgICBldmVudDogJ2hlYXJ0YmVhdCcsXG4gICAgICBwYXlsb2FkOiB7fSxcbiAgICAgIHJlZjogdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmLFxuICAgIH0pXG4gICAgdGhpcy5zZXRBdXRoKClcbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaGVzIHNlbmQgYnVmZmVyXG4gICAqL1xuICBmbHVzaFNlbmRCdWZmZXIoKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zZW5kQnVmZmVyLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKVxuICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW11cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlIGVpdGhlciBjdXN0b20gZmV0Y2gsIGlmIHByb3ZpZGVkLCBvciBkZWZhdWx0IGZldGNoIHRvIG1ha2UgSFRUUCByZXF1ZXN0c1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9yZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2g/OiBGZXRjaCk6IEZldGNoID0+IHtcbiAgICBsZXQgX2ZldGNoOiBGZXRjaFxuICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgX2ZldGNoID0gY3VzdG9tRmV0Y2hcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIF9mZXRjaCA9ICguLi5hcmdzKSA9PlxuICAgICAgICBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJyBhcyBhbnkpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT5cbiAgICAgICAgICBmZXRjaCguLi5hcmdzKVxuICAgICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIF9mZXRjaCA9IGZldGNoXG4gICAgfVxuICAgIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuZXh0IG1lc3NhZ2UgcmVmLCBhY2NvdW50aW5nIGZvciBvdmVyZmxvd3NcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfbWFrZVJlZigpOiBzdHJpbmcge1xuICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZiArIDFcbiAgICBpZiAobmV3UmVmID09PSB0aGlzLnJlZikge1xuICAgICAgdGhpcy5yZWYgPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVmID0gbmV3UmVmXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVmLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBmcm9tIGNoYW5uZWxzIHdpdGggdGhlIHNwZWNpZmllZCB0b3BpYy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfbGVhdmVPcGVuVG9waWModG9waWM6IHN0cmluZyk6IHZvaWQge1xuICAgIGxldCBkdXBDaGFubmVsID0gdGhpcy5jaGFubmVscy5maW5kKFxuICAgICAgKGMpID0+IGMudG9waWMgPT09IHRvcGljICYmIChjLl9pc0pvaW5lZCgpIHx8IGMuX2lzSm9pbmluZygpKVxuICAgIClcbiAgICBpZiAoZHVwQ2hhbm5lbCkge1xuICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIGBsZWF2aW5nIGR1cGxpY2F0ZSB0b3BpYyBcIiR7dG9waWN9XCJgKVxuICAgICAgZHVwQ2hhbm5lbC51bnN1YnNjcmliZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBzdWJzY3JpcHRpb24gZnJvbSB0aGUgc29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gY2hhbm5lbCBBbiBvcGVuIHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfcmVtb3ZlKGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCkge1xuICAgIHRoaXMuY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzLmZpbHRlcihcbiAgICAgIChjOiBSZWFsdGltZUNoYW5uZWwpID0+IGMuX2pvaW5SZWYoKSAhPT0gY2hhbm5lbC5fam9pblJlZigpXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgY29ubmVjdGlvbiBoYW5kbGVycy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIHNldHVwQ29ubmVjdGlvbigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICB0aGlzLmNvbm4uYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLl9vbkNvbm5PcGVuKClcbiAgICAgIHRoaXMuY29ubi5vbmVycm9yID0gKGVycm9yOiBXZWJTb2NrZXRMaWtlRXJyb3IpID0+XG4gICAgICAgIHRoaXMuX29uQ29ubkVycm9yKGVycm9yIGFzIFdlYlNvY2tldExpa2VFcnJvcilcbiAgICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSAoZXZlbnQ6IGFueSkgPT4gdGhpcy5fb25Db25uTWVzc2FnZShldmVudClcbiAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gKGV2ZW50OiBhbnkpID0+IHRoaXMuX29uQ29ubkNsb3NlKGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfb25Db25uTWVzc2FnZShyYXdNZXNzYWdlOiB7IGRhdGE6IGFueSB9KSB7XG4gICAgdGhpcy5kZWNvZGUocmF3TWVzc2FnZS5kYXRhLCAobXNnOiBSZWFsdGltZU1lc3NhZ2UpID0+IHtcbiAgICAgIGxldCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmIH0gPSBtc2dcblxuICAgICAgaWYgKHJlZiAmJiByZWYgPT09IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZikge1xuICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nKFxuICAgICAgICAncmVjZWl2ZScsXG4gICAgICAgIGAke3BheWxvYWQuc3RhdHVzIHx8ICcnfSAke3RvcGljfSAke2V2ZW50fSAke1xuICAgICAgICAgIChyZWYgJiYgJygnICsgcmVmICsgJyknKSB8fCAnJ1xuICAgICAgICB9YCxcbiAgICAgICAgcGF5bG9hZFxuICAgICAgKVxuICAgICAgdGhpcy5jaGFubmVsc1xuICAgICAgICAuZmlsdGVyKChjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwpID0+IGNoYW5uZWwuX2lzTWVtYmVyKHRvcGljKSlcbiAgICAgICAgLmZvckVhY2goKGNoYW5uZWw6IFJlYWx0aW1lQ2hhbm5lbCkgPT5cbiAgICAgICAgICBjaGFubmVsLl90cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYpXG4gICAgICAgIClcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZS5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2sobXNnKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIGFzeW5jIF9vbkNvbm5PcGVuKCkge1xuICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCBgY29ubmVjdGVkIHRvICR7dGhpcy5lbmRwb2ludFVSTCgpfWApXG4gICAgdGhpcy5mbHVzaFNlbmRCdWZmZXIoKVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKVxuICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHNldEludGVydmFsKFxuICAgICAgICAoKSA9PiB0aGlzLnNlbmRIZWFydGJlYXQoKSxcbiAgICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLndvcmtlclVybCkge1xuICAgICAgICB0aGlzLmxvZygnd29ya2VyJywgYHN0YXJ0aW5nIHdvcmtlciBmb3IgZnJvbSAke3RoaXMud29ya2VyVXJsfWApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZygnd29ya2VyJywgYHN0YXJ0aW5nIGRlZmF1bHQgd29ya2VyYClcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2JqZWN0VXJsID0gdGhpcy5fd29ya2VyT2JqZWN0VXJsKHRoaXMud29ya2VyVXJsISlcbiAgICAgIHRoaXMud29ya2VyUmVmID0gbmV3IFdvcmtlcihvYmplY3RVcmwpXG4gICAgICB0aGlzLndvcmtlclJlZi5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKCd3b3JrZXInLCAnd29ya2VyIGVycm9yJywgZXJyb3IubWVzc2FnZSlcbiAgICAgICAgdGhpcy53b3JrZXJSZWYhLnRlcm1pbmF0ZSgpXG4gICAgICB9XG4gICAgICB0aGlzLndvcmtlclJlZi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEuZXZlbnQgPT09ICdrZWVwQWxpdmUnKSB7XG4gICAgICAgICAgdGhpcy5zZW5kSGVhcnRiZWF0KClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy53b3JrZXJSZWYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBldmVudDogJ3N0YXJ0JyxcbiAgICAgICAgaW50ZXJ2YWw6IHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKSFcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBwcml2YXRlIF9vbkNvbm5DbG9zZShldmVudDogYW55KSB7XG4gICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsICdjbG9zZScsIGV2ZW50KVxuICAgIHRoaXMuX3RyaWdnZXJDaGFuRXJyb3IoKVxuICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmNsb3NlLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhldmVudCkpXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX29uQ29ubkVycm9yKGVycm9yOiBXZWJTb2NrZXRMaWtlRXJyb3IpIHtcbiAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgZXJyb3IubWVzc2FnZSlcbiAgICB0aGlzLl90cmlnZ2VyQ2hhbkVycm9yKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhlcnJvcikpXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgX3RyaWdnZXJDaGFuRXJyb3IoKSB7XG4gICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKChjaGFubmVsOiBSZWFsdGltZUNoYW5uZWwpID0+XG4gICAgICBjaGFubmVsLl90cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmVycm9yKVxuICAgIClcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBfYXBwZW5kUGFyYW1zKFxuICAgIHVybDogc3RyaW5nLFxuICAgIHBhcmFtczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxuICApOiBzdHJpbmcge1xuICAgIGlmIChPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgICBjb25zdCBwcmVmaXggPSB1cmwubWF0Y2goL1xcPy8pID8gJyYnIDogJz8nXG4gICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcylcblxuICAgIHJldHVybiBgJHt1cmx9JHtwcmVmaXh9JHtxdWVyeX1gXG4gIH1cblxuICBwcml2YXRlIF93b3JrZXJPYmplY3RVcmwodXJsOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICAgIGxldCByZXN1bHRfdXJsOiBzdHJpbmdcbiAgICBpZiAodXJsKSB7XG4gICAgICByZXN1bHRfdXJsID0gdXJsXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbV09SS0VSX1NDUklQVF0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnIH0pXG4gICAgICByZXN1bHRfdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0X3VybFxuICB9XG59XG5cbmNsYXNzIFdTV2ViU29ja2V0RHVtbXkge1xuICBiaW5hcnlUeXBlOiBzdHJpbmcgPSAnYXJyYXlidWZmZXInXG4gIGNsb3NlOiBGdW5jdGlvblxuICBvbmNsb3NlOiBGdW5jdGlvbiA9ICgpID0+IHt9XG4gIG9uZXJyb3I6IEZ1bmN0aW9uID0gKCkgPT4ge31cbiAgb25tZXNzYWdlOiBGdW5jdGlvbiA9ICgpID0+IHt9XG4gIG9ub3BlbjogRnVuY3Rpb24gPSAoKSA9PiB7fVxuICByZWFkeVN0YXRlOiBudW1iZXIgPSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmdcbiAgc2VuZDogRnVuY3Rpb24gPSAoKSA9PiB7fVxuICB1cmw6IHN0cmluZyB8IFVSTCB8IG51bGwgPSBudWxsXG5cbiAgY29uc3RydWN0b3IoXG4gICAgYWRkcmVzczogc3RyaW5nLFxuICAgIF9wcm90b2NvbHM6IHVuZGVmaW5lZCxcbiAgICBvcHRpb25zOiB7IGNsb3NlOiBGdW5jdGlvbiB9XG4gICkge1xuICAgIHRoaXMudXJsID0gYWRkcmVzc1xuICAgIHRoaXMuY2xvc2UgPSBvcHRpb25zLmNsb3NlXG4gIH1cbn1cbiIsICJleHBvcnQgY2xhc3MgU3RvcmFnZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwcm90ZWN0ZWQgX19pc1N0b3JhZ2VFcnJvciA9IHRydWVcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdTdG9yYWdlRXJyb3InXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RvcmFnZUVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgU3RvcmFnZUVycm9yIHtcbiAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ19faXNTdG9yYWdlRXJyb3InIGluIGVycm9yXG59XG5cbmV4cG9ydCBjbGFzcyBTdG9yYWdlQXBpRXJyb3IgZXh0ZW5kcyBTdG9yYWdlRXJyb3Ige1xuICBzdGF0dXM6IG51bWJlclxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgc3RhdHVzOiBudW1iZXIpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdTdG9yYWdlQXBpRXJyb3InXG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXNcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0b3JhZ2VVbmtub3duRXJyb3IgZXh0ZW5kcyBTdG9yYWdlRXJyb3Ige1xuICBvcmlnaW5hbEVycm9yOiB1bmtub3duXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBvcmlnaW5hbEVycm9yOiB1bmtub3duKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnU3RvcmFnZVVua25vd25FcnJvcidcbiAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yXG4gIH1cbn1cbiIsICJ0eXBlIEZldGNoID0gdHlwZW9mIGZldGNoXG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2g/OiBGZXRjaCk6IEZldGNoID0+IHtcbiAgbGV0IF9mZXRjaDogRmV0Y2hcbiAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgX2ZldGNoID0gY3VzdG9tRmV0Y2hcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgX2ZldGNoID0gKC4uLmFyZ3MpID0+XG4gICAgICBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJyBhcyBhbnkpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT4gZmV0Y2goLi4uYXJncykpXG4gIH0gZWxzZSB7XG4gICAgX2ZldGNoID0gZmV0Y2hcbiAgfVxuICByZXR1cm4gKC4uLmFyZ3MpID0+IF9mZXRjaCguLi5hcmdzKVxufVxuXG5leHBvcnQgY29uc3QgcmVzb2x2ZVJlc3BvbnNlID0gYXN5bmMgKCk6IFByb21pc2U8dHlwZW9mIFJlc3BvbnNlPiA9PiB7XG4gIGlmICh0eXBlb2YgUmVzcG9uc2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiAoYXdhaXQgaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcgYXMgYW55KSkuUmVzcG9uc2VcbiAgfVxuXG4gIHJldHVybiBSZXNwb25zZVxufVxuXG5leHBvcnQgY29uc3QgcmVjdXJzaXZlVG9DYW1lbCA9IChpdGVtOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdW5rbm93biA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgcmV0dXJuIGl0ZW0ubWFwKChlbCkgPT4gcmVjdXJzaXZlVG9DYW1lbChlbCkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdmdW5jdGlvbicgfHwgaXRlbSAhPT0gT2JqZWN0KGl0ZW0pKSB7XG4gICAgcmV0dXJuIGl0ZW1cbiAgfVxuXG4gIGNvbnN0IHJlc3VsdDogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9XG4gIE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IG5ld0tleSA9IGtleS5yZXBsYWNlKC8oWy1fXVthLXpdKS9naSwgKGMpID0+IGMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9bLV9dL2csICcnKSlcbiAgICByZXN1bHRbbmV3S2V5XSA9IHJlY3Vyc2l2ZVRvQ2FtZWwodmFsdWUpXG4gIH0pXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwgImltcG9ydCB7IFN0b3JhZ2VBcGlFcnJvciwgU3RvcmFnZVVua25vd25FcnJvciB9IGZyb20gJy4vZXJyb3JzJ1xuaW1wb3J0IHsgcmVzb2x2ZVJlc3BvbnNlIH0gZnJvbSAnLi9oZWxwZXJzJ1xuaW1wb3J0IHsgRmV0Y2hQYXJhbWV0ZXJzIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IHR5cGUgRmV0Y2ggPSB0eXBlb2YgZmV0Y2hcblxuZXhwb3J0IGludGVyZmFjZSBGZXRjaE9wdGlvbnMge1xuICBoZWFkZXJzPzoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9XG4gIG5vUmVzb2x2ZUpzb24/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIFJlcXVlc3RNZXRob2RUeXBlID0gJ0dFVCcgfCAnUE9TVCcgfCAnUFVUJyB8ICdERUxFVEUnIHwgJ0hFQUQnXG5cbmNvbnN0IF9nZXRFcnJvck1lc3NhZ2UgPSAoZXJyOiBhbnkpOiBzdHJpbmcgPT5cbiAgZXJyLm1zZyB8fCBlcnIubWVzc2FnZSB8fCBlcnIuZXJyb3JfZGVzY3JpcHRpb24gfHwgZXJyLmVycm9yIHx8IEpTT04uc3RyaW5naWZ5KGVycilcblxuY29uc3QgaGFuZGxlRXJyb3IgPSBhc3luYyAoXG4gIGVycm9yOiB1bmtub3duLFxuICByZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWQsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnNcbikgPT4ge1xuICBjb25zdCBSZXMgPSBhd2FpdCByZXNvbHZlUmVzcG9uc2UoKVxuXG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIFJlcyAmJiAhb3B0aW9ucz8ubm9SZXNvbHZlSnNvbikge1xuICAgIGVycm9yXG4gICAgICAuanNvbigpXG4gICAgICAudGhlbigoZXJyKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgU3RvcmFnZUFwaUVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyKSwgZXJyb3Iuc3RhdHVzIHx8IDUwMCkpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBTdG9yYWdlVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyKSwgZXJyKSlcbiAgICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KG5ldyBTdG9yYWdlVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCBlcnJvcikpXG4gIH1cbn1cblxuY29uc3QgX2dldFJlcXVlc3RQYXJhbXMgPSAoXG4gIG1ldGhvZDogUmVxdWVzdE1ldGhvZFR5cGUsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnMsXG4gIGJvZHk/OiBvYmplY3RcbikgPT4ge1xuICBjb25zdCBwYXJhbXM6IHsgW2s6IHN0cmluZ106IGFueSB9ID0geyBtZXRob2QsIGhlYWRlcnM6IG9wdGlvbnM/LmhlYWRlcnMgfHwge30gfVxuXG4gIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG5cbiAgcGFyYW1zLmhlYWRlcnMgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfVxuXG4gIGlmIChib2R5KSB7XG4gICAgcGFyYW1zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KVxuICB9XG4gIHJldHVybiB7IC4uLnBhcmFtcywgLi4ucGFyYW1ldGVycyB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9oYW5kbGVSZXF1ZXN0KFxuICBmZXRjaGVyOiBGZXRjaCxcbiAgbWV0aG9kOiBSZXF1ZXN0TWV0aG9kVHlwZSxcbiAgdXJsOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnMsXG4gIGJvZHk/OiBvYmplY3Rcbik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZmV0Y2hlcih1cmwsIF9nZXRSZXF1ZXN0UGFyYW1zKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkpXG4gICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmICghcmVzdWx0Lm9rKSB0aHJvdyByZXN1bHRcbiAgICAgICAgaWYgKG9wdGlvbnM/Lm5vUmVzb2x2ZUpzb24pIHJldHVybiByZXN1bHRcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qc29uKClcbiAgICAgIH0pXG4gICAgICAudGhlbigoZGF0YSkgPT4gcmVzb2x2ZShkYXRhKSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IGhhbmRsZUVycm9yKGVycm9yLCByZWplY3QsIG9wdGlvbnMpKVxuICB9KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0KFxuICBmZXRjaGVyOiBGZXRjaCxcbiAgdXJsOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnNcbik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCAnR0VUJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcG9zdChcbiAgZmV0Y2hlcjogRmV0Y2gsXG4gIHVybDogc3RyaW5nLFxuICBib2R5OiBvYmplY3QsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnNcbik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCAnUE9TVCcsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHB1dChcbiAgZmV0Y2hlcjogRmV0Y2gsXG4gIHVybDogc3RyaW5nLFxuICBib2R5OiBvYmplY3QsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnNcbik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCAnUFVUJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGVhZChcbiAgZmV0Y2hlcjogRmV0Y2gsXG4gIHVybDogc3RyaW5nLFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzXG4pOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoXG4gICAgZmV0Y2hlcixcbiAgICAnSEVBRCcsXG4gICAgdXJsLFxuICAgIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgIH0sXG4gICAgcGFyYW1ldGVyc1xuICApXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmUoXG4gIGZldGNoZXI6IEZldGNoLFxuICB1cmw6IHN0cmluZyxcbiAgYm9keTogb2JqZWN0LFxuICBvcHRpb25zPzogRmV0Y2hPcHRpb25zLFxuICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzXG4pOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ0RFTEVURScsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSlcbn1cbiIsICJpbXBvcnQgeyBpc1N0b3JhZ2VFcnJvciwgU3RvcmFnZUVycm9yLCBTdG9yYWdlVW5rbm93bkVycm9yIH0gZnJvbSAnLi4vbGliL2Vycm9ycydcbmltcG9ydCB7IEZldGNoLCBnZXQsIGhlYWQsIHBvc3QsIHJlbW92ZSB9IGZyb20gJy4uL2xpYi9mZXRjaCdcbmltcG9ydCB7IHJlY3Vyc2l2ZVRvQ2FtZWwsIHJlc29sdmVGZXRjaCB9IGZyb20gJy4uL2xpYi9oZWxwZXJzJ1xuaW1wb3J0IHtcbiAgRmlsZU9iamVjdCxcbiAgRmlsZU9wdGlvbnMsXG4gIFNlYXJjaE9wdGlvbnMsXG4gIEZldGNoUGFyYW1ldGVycyxcbiAgVHJhbnNmb3JtT3B0aW9ucyxcbiAgRGVzdGluYXRpb25PcHRpb25zLFxuICBGaWxlT2JqZWN0VjIsXG4gIENhbWVsaXplLFxufSBmcm9tICcuLi9saWIvdHlwZXMnXG5cbmNvbnN0IERFRkFVTFRfU0VBUkNIX09QVElPTlMgPSB7XG4gIGxpbWl0OiAxMDAsXG4gIG9mZnNldDogMCxcbiAgc29ydEJ5OiB7XG4gICAgY29sdW1uOiAnbmFtZScsXG4gICAgb3JkZXI6ICdhc2MnLFxuICB9LFxufVxuXG5jb25zdCBERUZBVUxUX0ZJTEVfT1BUSU9OUzogRmlsZU9wdGlvbnMgPSB7XG4gIGNhY2hlQ29udHJvbDogJzM2MDAnLFxuICBjb250ZW50VHlwZTogJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcsXG4gIHVwc2VydDogZmFsc2UsXG59XG5cbnR5cGUgRmlsZUJvZHkgPVxuICB8IEFycmF5QnVmZmVyXG4gIHwgQXJyYXlCdWZmZXJWaWV3XG4gIHwgQmxvYlxuICB8IEJ1ZmZlclxuICB8IEZpbGVcbiAgfCBGb3JtRGF0YVxuICB8IE5vZGVKUy5SZWFkYWJsZVN0cmVhbVxuICB8IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+XG4gIHwgVVJMU2VhcmNoUGFyYW1zXG4gIHwgc3RyaW5nXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JhZ2VGaWxlQXBpIHtcbiAgcHJvdGVjdGVkIHVybDogc3RyaW5nXG4gIHByb3RlY3RlZCBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gIHByb3RlY3RlZCBidWNrZXRJZD86IHN0cmluZ1xuICBwcm90ZWN0ZWQgZmV0Y2g6IEZldGNoXG5cbiAgY29uc3RydWN0b3IoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9LFxuICAgIGJ1Y2tldElkPzogc3RyaW5nLFxuICAgIGZldGNoPzogRmV0Y2hcbiAgKSB7XG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gICAgdGhpcy5idWNrZXRJZCA9IGJ1Y2tldElkXG4gICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGxvYWRzIGEgZmlsZSB0byBhbiBleGlzdGluZyBidWNrZXQgb3IgcmVwbGFjZXMgYW4gZXhpc3RpbmcgZmlsZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggd2l0aCBhIG5ldyBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSBtZXRob2QgSFRUUCBtZXRob2QuXG4gICAqIEBwYXJhbSBwYXRoIFRoZSByZWxhdGl2ZSBmaWxlIHBhdGguIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwbG9hZC5cbiAgICogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB1cGxvYWRPclVwZGF0ZShcbiAgICBtZXRob2Q6ICdQT1NUJyB8ICdQVVQnLFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBmaWxlQm9keTogRmlsZUJvZHksXG4gICAgZmlsZU9wdGlvbnM/OiBGaWxlT3B0aW9uc1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IGlkOiBzdHJpbmc7IHBhdGg6IHN0cmluZzsgZnVsbFBhdGg6IHN0cmluZyB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IGJvZHlcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IC4uLkRFRkFVTFRfRklMRV9PUFRJT05TLCAuLi5maWxlT3B0aW9ucyB9XG4gICAgICBsZXQgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICAgLi4udGhpcy5oZWFkZXJzLFxuICAgICAgICAuLi4obWV0aG9kID09PSAnUE9TVCcgJiYgeyAneC11cHNlcnQnOiBTdHJpbmcob3B0aW9ucy51cHNlcnQgYXMgYm9vbGVhbikgfSksXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YVxuXG4gICAgICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBib2R5ID0gbmV3IEZvcm1EYXRhKClcbiAgICAgICAgYm9keS5hcHBlbmQoJ2NhY2hlQ29udHJvbCcsIG9wdGlvbnMuY2FjaGVDb250cm9sIGFzIHN0cmluZylcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgYm9keS5hcHBlbmQoJ21ldGFkYXRhJywgdGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpXG4gICAgICAgIH1cbiAgICAgICAgYm9keS5hcHBlbmQoJycsIGZpbGVCb2R5KVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgYm9keSA9IGZpbGVCb2R5XG4gICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCBhcyBzdHJpbmcpXG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgIGJvZHkuYXBwZW5kKCdtZXRhZGF0YScsIHRoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib2R5ID0gZmlsZUJvZHlcbiAgICAgICAgaGVhZGVyc1snY2FjaGUtY29udHJvbCddID0gYG1heC1hZ2U9JHtvcHRpb25zLmNhY2hlQ29udHJvbH1gXG4gICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gb3B0aW9ucy5jb250ZW50VHlwZSBhcyBzdHJpbmdcblxuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICBoZWFkZXJzWyd4LW1ldGFkYXRhJ10gPSB0aGlzLnRvQmFzZTY0KHRoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWxlT3B0aW9ucz8uaGVhZGVycykge1xuICAgICAgICBoZWFkZXJzID0geyAuLi5oZWFkZXJzLCAuLi5maWxlT3B0aW9ucy5oZWFkZXJzIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgY2xlYW5QYXRoID0gdGhpcy5fcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpXG4gICAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChjbGVhblBhdGgpXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmZldGNoKGAke3RoaXMudXJsfS9vYmplY3QvJHtfcGF0aH1gLCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgYm9keTogYm9keSBhcyBCb2R5SW5pdCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgLi4uKG9wdGlvbnM/LmR1cGxleCA/IHsgZHVwbGV4OiBvcHRpb25zLmR1cGxleCB9IDoge30pLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKClcblxuICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHsgcGF0aDogY2xlYW5QYXRoLCBpZDogZGF0YS5JZCwgZnVsbFBhdGg6IGRhdGEuS2V5IH0sXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZGF0YVxuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGxvYWRzIGEgZmlsZSB0byBhbiBleGlzdGluZyBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG4gICAqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cbiAgICovXG4gIGFzeW5jIHVwbG9hZChcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgZmlsZUJvZHk6IEZpbGVCb2R5LFxuICAgIGZpbGVPcHRpb25zPzogRmlsZU9wdGlvbnNcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBpZDogc3RyaW5nOyBwYXRoOiBzdHJpbmc7IGZ1bGxQYXRoOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMudXBsb2FkT3JVcGRhdGUoJ1BPU1QnLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkIGEgZmlsZSB3aXRoIGEgdG9rZW4gZ2VuZXJhdGVkIGZyb20gYGNyZWF0ZVNpZ25lZFVwbG9hZFVybGAuXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG4gICAqIEBwYXJhbSB0b2tlbiBUaGUgdG9rZW4gZ2VuZXJhdGVkIGZyb20gYGNyZWF0ZVNpZ25lZFVwbG9hZFVybGBcbiAgICogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuICAgKi9cbiAgYXN5bmMgdXBsb2FkVG9TaWduZWRVcmwoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgZmlsZUJvZHk6IEZpbGVCb2R5LFxuICAgIGZpbGVPcHRpb25zPzogRmlsZU9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3QgY2xlYW5QYXRoID0gdGhpcy5fcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpXG4gICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgoY2xlYW5QYXRoKVxuXG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh0aGlzLnVybCArIGAvb2JqZWN0L3VwbG9hZC9zaWduLyR7X3BhdGh9YClcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgndG9rZW4nLCB0b2tlbilcblxuICAgIHRyeSB7XG4gICAgICBsZXQgYm9keVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgdXBzZXJ0OiBERUZBVUxUX0ZJTEVfT1BUSU9OUy51cHNlcnQsIC4uLmZpbGVPcHRpb25zIH1cbiAgICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgLi4ueyAneC11cHNlcnQnOiBTdHJpbmcob3B0aW9ucy51cHNlcnQgYXMgYm9vbGVhbikgfSxcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgYm9keSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCBhcyBzdHJpbmcpXG4gICAgICAgIGJvZHkuYXBwZW5kKCcnLCBmaWxlQm9keSlcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgIGJvZHkgPSBmaWxlQm9keVxuICAgICAgICBib2R5LmFwcGVuZCgnY2FjaGVDb250cm9sJywgb3B0aW9ucy5jYWNoZUNvbnRyb2wgYXMgc3RyaW5nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYm9keSA9IGZpbGVCb2R5XG4gICAgICAgIGhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSA9IGBtYXgtYWdlPSR7b3B0aW9ucy5jYWNoZUNvbnRyb2x9YFxuICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IG9wdGlvbnMuY29udGVudFR5cGUgYXMgc3RyaW5nXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgYm9keTogYm9keSBhcyBCb2R5SW5pdCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpXG5cbiAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7IHBhdGg6IGNsZWFuUGF0aCwgZnVsbFBhdGg6IGRhdGEuS2V5IH0sXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZGF0YVxuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2lnbmVkIHVwbG9hZCBVUkwuXG4gICAqIFNpZ25lZCB1cGxvYWQgVVJMcyBjYW4gYmUgdXNlZCB0byB1cGxvYWQgZmlsZXMgdG8gdGhlIGJ1Y2tldCB3aXRob3V0IGZ1cnRoZXIgYXV0aGVudGljYXRpb24uXG4gICAqIFRoZXkgYXJlIHZhbGlkIGZvciAyIGhvdXJzLlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAqIEBwYXJhbSBvcHRpb25zLnVwc2VydCBJZiBzZXQgdG8gdHJ1ZSwgYWxsb3dzIHRoZSBmaWxlIHRvIGJlIG92ZXJ3cml0dGVuIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlU2lnbmVkVXBsb2FkVXJsKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyB1cHNlcnQ6IGJvb2xlYW4gfVxuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IHNpZ25lZFVybDogc3RyaW5nOyB0b2tlbjogc3RyaW5nOyBwYXRoOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKVxuXG4gICAgICBjb25zdCBoZWFkZXJzID0geyAuLi50aGlzLmhlYWRlcnMgfVxuXG4gICAgICBpZiAob3B0aW9ucz8udXBzZXJ0KSB7XG4gICAgICAgIGhlYWRlcnNbJ3gtdXBzZXJ0J10gPSAndHJ1ZSdcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9vYmplY3QvdXBsb2FkL3NpZ24vJHtfcGF0aH1gLFxuICAgICAgICB7fSxcbiAgICAgICAgeyBoZWFkZXJzIH1cbiAgICAgIClcblxuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh0aGlzLnVybCArIGRhdGEudXJsKVxuXG4gICAgICBjb25zdCB0b2tlbiA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCd0b2tlbicpXG5cbiAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcignTm8gdG9rZW4gcmV0dXJuZWQgYnkgQVBJJylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgZGF0YTogeyBzaWduZWRVcmw6IHVybC50b1N0cmluZygpLCBwYXRoLCB0b2tlbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggVGhlIHJlbGF0aXZlIGZpbGUgcGF0aC4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAqL1xuICBhc3luYyB1cGRhdGUoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGZpbGVCb2R5OlxuICAgICAgfCBBcnJheUJ1ZmZlclxuICAgICAgfCBBcnJheUJ1ZmZlclZpZXdcbiAgICAgIHwgQmxvYlxuICAgICAgfCBCdWZmZXJcbiAgICAgIHwgRmlsZVxuICAgICAgfCBGb3JtRGF0YVxuICAgICAgfCBOb2RlSlMuUmVhZGFibGVTdHJlYW1cbiAgICAgIHwgUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbiAgICAgIHwgVVJMU2VhcmNoUGFyYW1zXG4gICAgICB8IHN0cmluZyxcbiAgICBmaWxlT3B0aW9ucz86IEZpbGVPcHRpb25zXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgaWQ6IHN0cmluZzsgcGF0aDogc3RyaW5nOyBmdWxsUGF0aDogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHJldHVybiB0aGlzLnVwbG9hZE9yVXBkYXRlKCdQVVQnLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgYW4gZXhpc3RpbmcgZmlsZSB0byBhIG5ldyBwYXRoIGluIHRoZSBzYW1lIGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtIGZyb21QYXRoIFRoZSBvcmlnaW5hbCBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICogQHBhcmFtIHRvUGF0aCBUaGUgbmV3IGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBuZXcgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLW5ldy5wbmdgLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIG1vdmUoXG4gICAgZnJvbVBhdGg6IHN0cmluZyxcbiAgICB0b1BhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogRGVzdGluYXRpb25PcHRpb25zXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgbWVzc2FnZTogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L29iamVjdC9tb3ZlYCxcbiAgICAgICAge1xuICAgICAgICAgIGJ1Y2tldElkOiB0aGlzLmJ1Y2tldElkLFxuICAgICAgICAgIHNvdXJjZUtleTogZnJvbVBhdGgsXG4gICAgICAgICAgZGVzdGluYXRpb25LZXk6IHRvUGF0aCxcbiAgICAgICAgICBkZXN0aW5hdGlvbkJ1Y2tldDogb3B0aW9ucz8uZGVzdGluYXRpb25CdWNrZXQsXG4gICAgICAgIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyBhbiBleGlzdGluZyBmaWxlIHRvIGEgbmV3IHBhdGggaW4gdGhlIHNhbWUgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbVBhdGggVGhlIG9yaWdpbmFsIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgKiBAcGFyYW0gdG9QYXRoIFRoZSBuZXcgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIG5ldyBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UtY29weS5wbmdgLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIGNvcHkoXG4gICAgZnJvbVBhdGg6IHN0cmluZyxcbiAgICB0b1BhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogRGVzdGluYXRpb25PcHRpb25zXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgcGF0aDogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L29iamVjdC9jb3B5YCxcbiAgICAgICAge1xuICAgICAgICAgIGJ1Y2tldElkOiB0aGlzLmJ1Y2tldElkLFxuICAgICAgICAgIHNvdXJjZUtleTogZnJvbVBhdGgsXG4gICAgICAgICAgZGVzdGluYXRpb25LZXk6IHRvUGF0aCxcbiAgICAgICAgICBkZXN0aW5hdGlvbkJ1Y2tldDogb3B0aW9ucz8uZGVzdGluYXRpb25CdWNrZXQsXG4gICAgICAgIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGE6IHsgcGF0aDogZGF0YS5LZXkgfSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNpZ25lZCBVUkwuIFVzZSBhIHNpZ25lZCBVUkwgdG8gc2hhcmUgYSBmaWxlIGZvciBhIGZpeGVkIGFtb3VudCBvZiB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMIGV4cGlyZXMuIEZvciBleGFtcGxlLCBgNjBgIGZvciBhIFVSTCB3aGljaCBpcyB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG4gICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG4gICAqL1xuICBhc3luYyBjcmVhdGVTaWduZWRVcmwoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGV4cGlyZXNJbjogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiB7IGRvd25sb2FkPzogc3RyaW5nIHwgYm9vbGVhbjsgdHJhbnNmb3JtPzogVHJhbnNmb3JtT3B0aW9ucyB9XG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgc2lnbmVkVXJsOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKVxuXG4gICAgICBsZXQgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9vYmplY3Qvc2lnbi8ke19wYXRofWAsXG4gICAgICAgIHsgZXhwaXJlc0luLCAuLi4ob3B0aW9ucz8udHJhbnNmb3JtID8geyB0cmFuc2Zvcm06IG9wdGlvbnMudHJhbnNmb3JtIH0gOiB7fSkgfSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuICAgICAgY29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gb3B0aW9ucz8uZG93bmxvYWRcbiAgICAgICAgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/ICcnIDogb3B0aW9ucy5kb3dubG9hZH1gXG4gICAgICAgIDogJydcbiAgICAgIGNvbnN0IHNpZ25lZFVybCA9IGVuY29kZVVSSShgJHt0aGlzLnVybH0ke2RhdGEuc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApXG4gICAgICBkYXRhID0geyBzaWduZWRVcmwgfVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBtdWx0aXBsZSBzaWduZWQgVVJMcy4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRocyBUaGUgZmlsZSBwYXRocyB0byBiZSBkb3dubG9hZGVkLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lcy4gRm9yIGV4YW1wbGUgYFsnZm9sZGVyL2ltYWdlLnBuZycsICdmb2xkZXIyL2ltYWdlMi5wbmcnXWAuXG4gICAqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMcyBleHBpcmUuIEZvciBleGFtcGxlLCBgNjBgIGZvciBVUkxzIHdoaWNoIGFyZSB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG4gICAqL1xuICBhc3luYyBjcmVhdGVTaWduZWRVcmxzKFxuICAgIHBhdGhzOiBzdHJpbmdbXSxcbiAgICBleHBpcmVzSW46IG51bWJlcixcbiAgICBvcHRpb25zPzogeyBkb3dubG9hZDogc3RyaW5nIHwgYm9vbGVhbiB9XG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgZXJyb3I6IHN0cmluZyB8IG51bGw7IHBhdGg6IHN0cmluZyB8IG51bGw7IHNpZ25lZFVybDogc3RyaW5nIH1bXVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vb2JqZWN0L3NpZ24vJHt0aGlzLmJ1Y2tldElkfWAsXG4gICAgICAgIHsgZXhwaXJlc0luLCBwYXRocyB9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG5cbiAgICAgIGNvbnN0IGRvd25sb2FkUXVlcnlQYXJhbSA9IG9wdGlvbnM/LmRvd25sb2FkXG4gICAgICAgID8gYCZkb3dubG9hZD0ke29wdGlvbnMuZG93bmxvYWQgPT09IHRydWUgPyAnJyA6IG9wdGlvbnMuZG93bmxvYWR9YFxuICAgICAgICA6ICcnXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBkYXRhLm1hcCgoZGF0dW06IHsgc2lnbmVkVVJMOiBzdHJpbmcgfSkgPT4gKHtcbiAgICAgICAgICAuLi5kYXR1bSxcbiAgICAgICAgICBzaWduZWRVcmw6IGRhdHVtLnNpZ25lZFVSTFxuICAgICAgICAgICAgPyBlbmNvZGVVUkkoYCR7dGhpcy51cmx9JHtkYXR1bS5zaWduZWRVUkx9JHtkb3dubG9hZFF1ZXJ5UGFyYW19YClcbiAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgfSkpLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERvd25sb2FkcyBhIGZpbGUgZnJvbSBhIHByaXZhdGUgYnVja2V0LiBGb3IgcHVibGljIGJ1Y2tldHMsIG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBVUkwgcmV0dXJuZWQgZnJvbSBgZ2V0UHVibGljVXJsYCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgZnVsbCBwYXRoIGFuZCBmaWxlIG5hbWUgb2YgdGhlIGZpbGUgdG8gYmUgZG93bmxvYWRlZC4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuICAgKi9cbiAgYXN5bmMgZG93bmxvYWQoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IHRyYW5zZm9ybT86IFRyYW5zZm9ybU9wdGlvbnMgfVxuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBCbG9iXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICBjb25zdCB3YW50c1RyYW5zZm9ybWF0aW9uID0gdHlwZW9mIG9wdGlvbnM/LnRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCdcbiAgICBjb25zdCByZW5kZXJQYXRoID0gd2FudHNUcmFuc2Zvcm1hdGlvbiA/ICdyZW5kZXIvaW1hZ2UvYXV0aGVudGljYXRlZCcgOiAnb2JqZWN0J1xuICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uUXVlcnkgPSB0aGlzLnRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKG9wdGlvbnM/LnRyYW5zZm9ybSB8fCB7fSlcbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IHRyYW5zZm9ybWF0aW9uUXVlcnkgPyBgPyR7dHJhbnNmb3JtYXRpb25RdWVyeX1gIDogJydcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKVxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS8ke3JlbmRlclBhdGh9LyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgIH0pXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmJsb2IoKVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFuIGV4aXN0aW5nIGZpbGUuXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqL1xuICBhc3luYyBpbmZvKFxuICAgIHBhdGg6IHN0cmluZ1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBDYW1lbGl6ZTxGaWxlT2JqZWN0VjI+XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgICAgfVxuICA+IHtcbiAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC9pbmZvLyR7X3BhdGh9YCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4geyBkYXRhOiByZWN1cnNpdmVUb0NhbWVsKGRhdGEpIGFzIENhbWVsaXplPEZpbGVPYmplY3RWMj4sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgZXhpc3RlbmNlIG9mIGEgZmlsZS5cbiAgICogQHBhcmFtIHBhdGhcbiAgICovXG4gIGFzeW5jIGV4aXN0cyhcbiAgICBwYXRoOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogYm9vbGVhblxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBib29sZWFuXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aClcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBoZWFkKHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvJHtfcGF0aH1gLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiB7IGRhdGE6IHRydWUsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSAmJiBlcnJvciBpbnN0YW5jZW9mIFN0b3JhZ2VVbmtub3duRXJyb3IpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxFcnJvciA9IChlcnJvci5vcmlnaW5hbEVycm9yIGFzIHVua25vd24pIGFzIHsgc3RhdHVzOiBudW1iZXIgfVxuXG4gICAgICAgIGlmIChbNDAwLCA0MDRdLmluY2x1ZGVzKG9yaWdpbmFsRXJyb3I/LnN0YXR1cykpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiBmYWxzZSwgZXJyb3IgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgc2ltcGxlIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCB0aGUgVVJMIGZvciBhbiBhc3NldCBpbiBhIHB1YmxpYyBidWNrZXQuIElmIHlvdSBkbyBub3Qgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiwgeW91IGNhbiBjb25zdHJ1Y3QgdGhlIHB1YmxpYyBVUkwgYnkgY29uY2F0ZW5hdGluZyB0aGUgYnVja2V0IFVSTCB3aXRoIHRoZSBwYXRoIHRvIHRoZSBhc3NldC5cbiAgICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB2ZXJpZnkgaWYgdGhlIGJ1Y2tldCBpcyBwdWJsaWMuIElmIGEgcHVibGljIFVSTCBpcyBjcmVhdGVkIGZvciBhIGJ1Y2tldCB3aGljaCBpcyBub3QgcHVibGljLCB5b3Ugd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZCB0aGUgYXNzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIGFuZCBuYW1lIG9mIHRoZSBmaWxlIHRvIGdlbmVyYXRlIHRoZSBwdWJsaWMgVVJMIGZvci4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCBUcmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cbiAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cbiAgICovXG4gIGdldFB1YmxpY1VybChcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgZG93bmxvYWQ/OiBzdHJpbmcgfCBib29sZWFuOyB0cmFuc2Zvcm0/OiBUcmFuc2Zvcm1PcHRpb25zIH1cbiAgKTogeyBkYXRhOiB7IHB1YmxpY1VybDogc3RyaW5nIH0gfSB7XG4gICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aClcbiAgICBjb25zdCBfcXVlcnlTdHJpbmcgPSBbXVxuXG4gICAgY29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gb3B0aW9ucz8uZG93bmxvYWRcbiAgICAgID8gYGRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/ICcnIDogb3B0aW9ucy5kb3dubG9hZH1gXG4gICAgICA6ICcnXG5cbiAgICBpZiAoZG93bmxvYWRRdWVyeVBhcmFtICE9PSAnJykge1xuICAgICAgX3F1ZXJ5U3RyaW5nLnB1c2goZG93bmxvYWRRdWVyeVBhcmFtKVxuICAgIH1cblxuICAgIGNvbnN0IHdhbnRzVHJhbnNmb3JtYXRpb24gPSB0eXBlb2Ygb3B0aW9ucz8udHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJ1xuICAgIGNvbnN0IHJlbmRlclBhdGggPSB3YW50c1RyYW5zZm9ybWF0aW9uID8gJ3JlbmRlci9pbWFnZScgOiAnb2JqZWN0J1xuICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uUXVlcnkgPSB0aGlzLnRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKG9wdGlvbnM/LnRyYW5zZm9ybSB8fCB7fSlcblxuICAgIGlmICh0cmFuc2Zvcm1hdGlvblF1ZXJ5ICE9PSAnJykge1xuICAgICAgX3F1ZXJ5U3RyaW5nLnB1c2godHJhbnNmb3JtYXRpb25RdWVyeSlcbiAgICB9XG5cbiAgICBsZXQgcXVlcnlTdHJpbmcgPSBfcXVlcnlTdHJpbmcuam9pbignJicpXG4gICAgaWYgKHF1ZXJ5U3RyaW5nICE9PSAnJykge1xuICAgICAgcXVlcnlTdHJpbmcgPSBgPyR7cXVlcnlTdHJpbmd9YFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiB7IHB1YmxpY1VybDogZW5jb2RlVVJJKGAke3RoaXMudXJsfS8ke3JlbmRlclBhdGh9L3B1YmxpYy8ke19wYXRofSR7cXVlcnlTdHJpbmd9YCkgfSxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBmaWxlcyB3aXRoaW4gdGhlIHNhbWUgYnVja2V0XG4gICAqXG4gICAqIEBwYXJhbSBwYXRocyBBbiBhcnJheSBvZiBmaWxlcyB0byBkZWxldGUsIGluY2x1ZGluZyB0aGUgcGF0aCBhbmQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBbYCdmb2xkZXIvaW1hZ2UucG5nJ2BdLlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlKFxuICAgIHBhdGhzOiBzdHJpbmdbXVxuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBGaWxlT2JqZWN0W11cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVtb3ZlKFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vb2JqZWN0LyR7dGhpcy5idWNrZXRJZH1gLFxuICAgICAgICB7IHByZWZpeGVzOiBwYXRocyB9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZmlsZSBtZXRhZGF0YVxuICAgKiBAcGFyYW0gaWQgdGhlIGZpbGUgaWQgdG8gcmV0cmlldmUgbWV0YWRhdGFcbiAgICovXG4gIC8vIGFzeW5jIGdldE1ldGFkYXRhKFxuICAvLyAgIGlkOiBzdHJpbmdcbiAgLy8gKTogUHJvbWlzZTxcbiAgLy8gICB8IHtcbiAgLy8gICAgICAgZGF0YTogTWV0YWRhdGFcbiAgLy8gICAgICAgZXJyb3I6IG51bGxcbiAgLy8gICAgIH1cbiAgLy8gICB8IHtcbiAgLy8gICAgICAgZGF0YTogbnVsbFxuICAvLyAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gIC8vICAgICB9XG4gIC8vID4ge1xuICAvLyAgIHRyeSB7XG4gIC8vICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9tZXRhZGF0YS8ke2lkfWAsIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pXG4gIC8vICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gIC8vICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgLy8gICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgLy8gICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAvLyAgICAgfVxuXG4gIC8vICAgICB0aHJvdyBlcnJvclxuICAvLyAgIH1cbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZmlsZSBtZXRhZGF0YVxuICAgKiBAcGFyYW0gaWQgdGhlIGZpbGUgaWQgdG8gdXBkYXRlIG1ldGFkYXRhXG4gICAqIEBwYXJhbSBtZXRhIHRoZSBuZXcgZmlsZSBtZXRhZGF0YVxuICAgKi9cbiAgLy8gYXN5bmMgdXBkYXRlTWV0YWRhdGEoXG4gIC8vICAgaWQ6IHN0cmluZyxcbiAgLy8gICBtZXRhOiBNZXRhZGF0YVxuICAvLyApOiBQcm9taXNlPFxuICAvLyAgIHwge1xuICAvLyAgICAgICBkYXRhOiBNZXRhZGF0YVxuICAvLyAgICAgICBlcnJvcjogbnVsbFxuICAvLyAgICAgfVxuICAvLyAgIHwge1xuICAvLyAgICAgICBkYXRhOiBudWxsXG4gIC8vICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgLy8gICAgIH1cbiAgLy8gPiB7XG4gIC8vICAgdHJ5IHtcbiAgLy8gICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAvLyAgICAgICB0aGlzLmZldGNoLFxuICAvLyAgICAgICBgJHt0aGlzLnVybH0vbWV0YWRhdGEvJHtpZH1gLFxuICAvLyAgICAgICB7IC4uLm1ldGEgfSxcbiAgLy8gICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAvLyAgICAgKVxuICAvLyAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAvLyAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gIC8vICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gIC8vICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgLy8gICAgIH1cblxuICAvLyAgICAgdGhyb3cgZXJyb3JcbiAgLy8gICB9XG4gIC8vIH1cblxuICAvKipcbiAgICogTGlzdHMgYWxsIHRoZSBmaWxlcyB3aXRoaW4gYSBidWNrZXQuXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBmb2xkZXIgcGF0aC5cbiAgICovXG4gIGFzeW5jIGxpc3QoXG4gICAgcGF0aD86IHN0cmluZyxcbiAgICBvcHRpb25zPzogU2VhcmNoT3B0aW9ucyxcbiAgICBwYXJhbWV0ZXJzPzogRmV0Y2hQYXJhbWV0ZXJzXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IEZpbGVPYmplY3RbXVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJvZHkgPSB7IC4uLkRFRkFVTFRfU0VBUkNIX09QVElPTlMsIC4uLm9wdGlvbnMsIHByZWZpeDogcGF0aCB8fCAnJyB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L29iamVjdC9saXN0LyR7dGhpcy5idWNrZXRJZH1gLFxuICAgICAgICBib2R5LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9LFxuICAgICAgICBwYXJhbWV0ZXJzXG4gICAgICApXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBlbmNvZGVNZXRhZGF0YShtZXRhZGF0YTogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSlcbiAgfVxuXG4gIHRvQmFzZTY0KGRhdGE6IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgIH1cbiAgICByZXR1cm4gYnRvYShkYXRhKVxuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0RmluYWxQYXRoKHBhdGg6IHN0cmluZykge1xuICAgIHJldHVybiBgJHt0aGlzLmJ1Y2tldElkfS8ke3BhdGh9YFxuICB9XG5cbiAgcHJpdmF0ZSBfcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGg6IHN0cmluZykge1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL15cXC98XFwvJC9nLCAnJykucmVwbGFjZSgvXFwvKy9nLCAnLycpXG4gIH1cblxuICBwcml2YXRlIHRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKHRyYW5zZm9ybTogVHJhbnNmb3JtT3B0aW9ucykge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdXG4gICAgaWYgKHRyYW5zZm9ybS53aWR0aCkge1xuICAgICAgcGFyYW1zLnB1c2goYHdpZHRoPSR7dHJhbnNmb3JtLndpZHRofWApXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5oZWlnaHQpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGBoZWlnaHQ9JHt0cmFuc2Zvcm0uaGVpZ2h0fWApXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5yZXNpemUpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGByZXNpemU9JHt0cmFuc2Zvcm0ucmVzaXplfWApXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5mb3JtYXQpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGBmb3JtYXQ9JHt0cmFuc2Zvcm0uZm9ybWF0fWApXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5xdWFsaXR5KSB7XG4gICAgICBwYXJhbXMucHVzaChgcXVhbGl0eT0ke3RyYW5zZm9ybS5xdWFsaXR5fWApXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcy5qb2luKCcmJylcbiAgfVxufVxuIiwgIi8vIGdlbmVyYXRlZCBieSBnZW52ZXJzaW9uXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjcuMSdcbiIsICJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJ1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfSEVBREVSUyA9IHsgJ1gtQ2xpZW50LUluZm8nOiBgc3RvcmFnZS1qcy8ke3ZlcnNpb259YCB9XG4iLCAiaW1wb3J0IHsgREVGQVVMVF9IRUFERVJTIH0gZnJvbSAnLi4vbGliL2NvbnN0YW50cydcbmltcG9ydCB7IGlzU3RvcmFnZUVycm9yLCBTdG9yYWdlRXJyb3IgfSBmcm9tICcuLi9saWIvZXJyb3JzJ1xuaW1wb3J0IHsgRmV0Y2gsIGdldCwgcG9zdCwgcHV0LCByZW1vdmUgfSBmcm9tICcuLi9saWIvZmV0Y2gnXG5pbXBvcnQgeyByZXNvbHZlRmV0Y2ggfSBmcm9tICcuLi9saWIvaGVscGVycydcbmltcG9ydCB7IEJ1Y2tldCB9IGZyb20gJy4uL2xpYi90eXBlcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RvcmFnZUJ1Y2tldEFwaSB7XG4gIHByb3RlY3RlZCB1cmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxuICBwcm90ZWN0ZWQgZmV0Y2g6IEZldGNoXG5cbiAgY29uc3RydWN0b3IodXJsOiBzdHJpbmcsIGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fSwgZmV0Y2g/OiBGZXRjaCkge1xuICAgIHRoaXMudXJsID0gdXJsXG4gICAgdGhpcy5oZWFkZXJzID0geyAuLi5ERUZBVUxUX0hFQURFUlMsIC4uLmhlYWRlcnMgfVxuICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goZmV0Y2gpXG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFsbCBTdG9yYWdlIGJ1Y2tldHMgd2l0aGluIGFuIGV4aXN0aW5nIHByb2plY3QuXG4gICAqL1xuICBhc3luYyBsaXN0QnVja2V0cygpOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBCdWNrZXRbXVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L2J1Y2tldGAsIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgU3RvcmFnZSBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byByZXRyaWV2ZS5cbiAgICovXG4gIGFzeW5jIGdldEJ1Y2tldChcbiAgICBpZDogc3RyaW5nXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IEJ1Y2tldFxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L2J1Y2tldC8ke2lkfWAsIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFN0b3JhZ2UgYnVja2V0XG4gICAqXG4gICAqIEBwYXJhbSBpZCBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYnVja2V0IHlvdSBhcmUgY3JlYXRpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zLnB1YmxpYyBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgYnVja2V0LiBQdWJsaWMgYnVja2V0cyBkb24ndCByZXF1aXJlIGFuIGF1dGhvcml6YXRpb24gdG9rZW4gdG8gZG93bmxvYWQgb2JqZWN0cywgYnV0IHN0aWxsIHJlcXVpcmUgYSB2YWxpZCB0b2tlbiBmb3IgYWxsIG90aGVyIG9wZXJhdGlvbnMuIEJ5IGRlZmF1bHQsIGJ1Y2tldHMgYXJlIHByaXZhdGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLmZpbGVTaXplTGltaXQgc3BlY2lmaWVzIHRoZSBtYXggZmlsZSBzaXplIGluIGJ5dGVzIHRoYXQgY2FuIGJlIHVwbG9hZGVkIHRvIHRoaXMgYnVja2V0LlxuICAgKiBUaGUgZ2xvYmFsIGZpbGUgc2l6ZSBsaW1pdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhpcyB2YWx1ZS5cbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggZG9lc24ndCBzZXQgYSBwZXIgYnVja2V0IGZpbGUgc2l6ZSBsaW1pdC5cbiAgICogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyBzcGVjaWZpZXMgdGhlIGFsbG93ZWQgbWltZSB0eXBlcyB0aGF0IHRoaXMgYnVja2V0IGNhbiBhY2NlcHQgZHVyaW5nIHVwbG9hZC5cbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggYWxsb3dzIGZpbGVzIHdpdGggYWxsIG1pbWUgdHlwZXMgdG8gYmUgdXBsb2FkZWQuXG4gICAqIEVhY2ggbWltZSB0eXBlIHNwZWNpZmllZCBjYW4gYmUgYSB3aWxkY2FyZCwgZS5nLiBpbWFnZS8qLCBvciBhIHNwZWNpZmljIG1pbWUgdHlwZSwgZS5nLiBpbWFnZS9wbmcuXG4gICAqIEByZXR1cm5zIG5ld2x5IGNyZWF0ZWQgYnVja2V0IGlkXG4gICAqL1xuICBhc3luYyBjcmVhdGVCdWNrZXQoXG4gICAgaWQ6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwdWJsaWM6IGJvb2xlYW5cbiAgICAgIGZpbGVTaXplTGltaXQ/OiBudW1iZXIgfCBzdHJpbmcgfCBudWxsXG4gICAgICBhbGxvd2VkTWltZVR5cGVzPzogc3RyaW5nW10gfCBudWxsXG4gICAgfSA9IHtcbiAgICAgIHB1YmxpYzogZmFsc2UsXG4gICAgfVxuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiBQaWNrPEJ1Y2tldCwgJ25hbWUnPlxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vYnVja2V0YCxcbiAgICAgICAge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIG5hbWU6IGlkLFxuICAgICAgICAgIHB1YmxpYzogb3B0aW9ucy5wdWJsaWMsXG4gICAgICAgICAgZmlsZV9zaXplX2xpbWl0OiBvcHRpb25zLmZpbGVTaXplTGltaXQsXG4gICAgICAgICAgYWxsb3dlZF9taW1lX3R5cGVzOiBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXMsXG4gICAgICAgIH0sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBTdG9yYWdlIGJ1Y2tldFxuICAgKlxuICAgKiBAcGFyYW0gaWQgQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIHVwZGF0aW5nLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5wdWJsaWMgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGJ1Y2tldC4gUHVibGljIGJ1Y2tldHMgZG9uJ3QgcmVxdWlyZSBhbiBhdXRob3JpemF0aW9uIHRva2VuIHRvIGRvd25sb2FkIG9iamVjdHMsIGJ1dCBzdGlsbCByZXF1aXJlIGEgdmFsaWQgdG9rZW4gZm9yIGFsbCBvdGhlciBvcGVyYXRpb25zLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5maWxlU2l6ZUxpbWl0IHNwZWNpZmllcyB0aGUgbWF4IGZpbGUgc2l6ZSBpbiBieXRlcyB0aGF0IGNhbiBiZSB1cGxvYWRlZCB0byB0aGlzIGJ1Y2tldC5cbiAgICogVGhlIGdsb2JhbCBmaWxlIHNpemUgbGltaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgdmFsdWUuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGRvZXNuJ3Qgc2V0IGEgcGVyIGJ1Y2tldCBmaWxlIHNpemUgbGltaXQuXG4gICAqIEBwYXJhbSBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXMgc3BlY2lmaWVzIHRoZSBhbGxvd2VkIG1pbWUgdHlwZXMgdGhhdCB0aGlzIGJ1Y2tldCBjYW4gYWNjZXB0IGR1cmluZyB1cGxvYWQuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGFsbG93cyBmaWxlcyB3aXRoIGFsbCBtaW1lIHR5cGVzIHRvIGJlIHVwbG9hZGVkLlxuICAgKiBFYWNoIG1pbWUgdHlwZSBzcGVjaWZpZWQgY2FuIGJlIGEgd2lsZGNhcmQsIGUuZy4gaW1hZ2UvKiwgb3IgYSBzcGVjaWZpYyBtaW1lIHR5cGUsIGUuZy4gaW1hZ2UvcG5nLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlQnVja2V0KFxuICAgIGlkOiBzdHJpbmcsXG4gICAgb3B0aW9uczoge1xuICAgICAgcHVibGljOiBib29sZWFuXG4gICAgICBmaWxlU2l6ZUxpbWl0PzogbnVtYmVyIHwgc3RyaW5nIHwgbnVsbFxuICAgICAgYWxsb3dlZE1pbWVUeXBlcz86IHN0cmluZ1tdIHwgbnVsbFxuICAgIH1cbiAgKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBtZXNzYWdlOiBzdHJpbmcgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAgIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwdXQoXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH1gLFxuICAgICAgICB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgbmFtZTogaWQsXG4gICAgICAgICAgcHVibGljOiBvcHRpb25zLnB1YmxpYyxcbiAgICAgICAgICBmaWxlX3NpemVfbGltaXQ6IG9wdGlvbnMuZmlsZVNpemVMaW1pdCxcbiAgICAgICAgICBhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyxcbiAgICAgICAgfSxcbiAgICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgICAgKVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgb2JqZWN0cyBpbnNpZGUgYSBzaW5nbGUgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gZW1wdHkuXG4gICAqL1xuICBhc3luYyBlbXB0eUJ1Y2tldChcbiAgICBpZDogc3RyaW5nXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgbWVzc2FnZTogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgYCR7dGhpcy51cmx9L2J1Y2tldC8ke2lkfS9lbXB0eWAsXG4gICAgICAgIHt9LFxuICAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgICApXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGV4aXN0aW5nIGJ1Y2tldC4gQSBidWNrZXQgY2FuJ3QgYmUgZGVsZXRlZCB3aXRoIGV4aXN0aW5nIG9iamVjdHMgaW5zaWRlIGl0LlxuICAgKiBZb3UgbXVzdCBmaXJzdCBgZW1wdHkoKWAgdGhlIGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGRlbGV0ZS5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZUJ1Y2tldChcbiAgICBpZDogc3RyaW5nXG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHsgbWVzc2FnZTogc3RyaW5nIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgICB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVtb3ZlKFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9YCxcbiAgICAgICAge30sXG4gICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IFN0b3JhZ2VGaWxlQXBpIGZyb20gJy4vcGFja2FnZXMvU3RvcmFnZUZpbGVBcGknXG5pbXBvcnQgU3RvcmFnZUJ1Y2tldEFwaSBmcm9tICcuL3BhY2thZ2VzL1N0b3JhZ2VCdWNrZXRBcGknXG5pbXBvcnQgeyBGZXRjaCB9IGZyb20gJy4vbGliL2ZldGNoJ1xuXG5leHBvcnQgY2xhc3MgU3RvcmFnZUNsaWVudCBleHRlbmRzIFN0b3JhZ2VCdWNrZXRBcGkge1xuICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZywgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9LCBmZXRjaD86IEZldGNoKSB7XG4gICAgc3VwZXIodXJsLCBoZWFkZXJzLCBmZXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGZpbGUgb3BlcmF0aW9uIGluIGEgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gaWQgVGhlIGJ1Y2tldCBpZCB0byBvcGVyYXRlIG9uLlxuICAgKi9cbiAgZnJvbShpZDogc3RyaW5nKTogU3RvcmFnZUZpbGVBcGkge1xuICAgIHJldHVybiBuZXcgU3RvcmFnZUZpbGVBcGkodGhpcy51cmwsIHRoaXMuaGVhZGVycywgaWQsIHRoaXMuZmV0Y2gpXG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjQ3LjE2J1xuIiwgIi8vIGNvbnN0YW50cy50c1xuaW1wb3J0IHsgUmVhbHRpbWVDbGllbnRPcHRpb25zIH0gZnJvbSAnQHN1cGFiYXNlL3JlYWx0aW1lLWpzJ1xuaW1wb3J0IHsgU3VwYWJhc2VBdXRoQ2xpZW50T3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJ1xuXG5sZXQgSlNfRU5WID0gJydcbi8vIEB0cy1pZ25vcmVcbmlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgSlNfRU5WID0gJ2Rlbm8nXG59IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgSlNfRU5WID0gJ3dlYidcbn0gZWxzZSBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgSlNfRU5WID0gJ3JlYWN0LW5hdGl2ZSdcbn0gZWxzZSB7XG4gIEpTX0VOViA9ICdub2RlJ1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBzdXBhYmFzZS1qcy0ke0pTX0VOVn0vJHt2ZXJzaW9ufWAgfVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9HTE9CQUxfT1BUSU9OUyA9IHtcbiAgaGVhZGVyczogREVGQVVMVF9IRUFERVJTLFxufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9EQl9PUFRJT05TID0ge1xuICBzY2hlbWE6ICdwdWJsaWMnLFxufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9BVVRIX09QVElPTlM6IFN1cGFiYXNlQXV0aENsaWVudE9wdGlvbnMgPSB7XG4gIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuICBkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWUsXG4gIGZsb3dUeXBlOiAnaW1wbGljaXQnLFxufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9SRUFMVElNRV9PUFRJT05TOiBSZWFsdGltZUNsaWVudE9wdGlvbnMgPSB7fVxuIiwgIi8vIEB0cy1pZ25vcmVcbmltcG9ydCBub2RlRmV0Y2gsIHsgSGVhZGVycyBhcyBOb2RlRmV0Y2hIZWFkZXJzIH0gZnJvbSAnQHN1cGFiYXNlL25vZGUtZmV0Y2gnXG5cbnR5cGUgRmV0Y2ggPSB0eXBlb2YgZmV0Y2hcblxuZXhwb3J0IGNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaD86IEZldGNoKTogRmV0Y2ggPT4ge1xuICBsZXQgX2ZldGNoOiBGZXRjaFxuICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaFxuICB9IGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBfZmV0Y2ggPSBub2RlRmV0Y2ggYXMgdW5rbm93biBhcyBGZXRjaFxuICB9IGVsc2Uge1xuICAgIF9mZXRjaCA9IGZldGNoXG4gIH1cbiAgcmV0dXJuICguLi5hcmdzOiBQYXJhbWV0ZXJzPEZldGNoPikgPT4gX2ZldGNoKC4uLmFyZ3MpXG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlSGVhZGVyc0NvbnN0cnVjdG9yID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIEhlYWRlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIE5vZGVGZXRjaEhlYWRlcnNcbiAgfVxuXG4gIHJldHVybiBIZWFkZXJzXG59XG5cbmV4cG9ydCBjb25zdCBmZXRjaFdpdGhBdXRoID0gKFxuICBzdXBhYmFzZUtleTogc3RyaW5nLFxuICBnZXRBY2Nlc3NUb2tlbjogKCkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsPixcbiAgY3VzdG9tRmV0Y2g/OiBGZXRjaFxuKTogRmV0Y2ggPT4ge1xuICBjb25zdCBmZXRjaCA9IHJlc29sdmVGZXRjaChjdXN0b21GZXRjaClcbiAgY29uc3QgSGVhZGVyc0NvbnN0cnVjdG9yID0gcmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvcigpXG5cbiAgcmV0dXJuIGFzeW5jIChpbnB1dCwgaW5pdCkgPT4ge1xuICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gKGF3YWl0IGdldEFjY2Vzc1Rva2VuKCkpID8/IHN1cGFiYXNlS2V5XG4gICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVyc0NvbnN0cnVjdG9yKGluaXQ/LmhlYWRlcnMpXG5cbiAgICBpZiAoIWhlYWRlcnMuaGFzKCdhcGlrZXknKSkge1xuICAgICAgaGVhZGVycy5zZXQoJ2FwaWtleScsIHN1cGFiYXNlS2V5KVxuICAgIH1cblxuICAgIGlmICghaGVhZGVycy5oYXMoJ0F1dGhvcml6YXRpb24nKSkge1xuICAgICAgaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7YWNjZXNzVG9rZW59YClcbiAgICB9XG5cbiAgICByZXR1cm4gZmV0Y2goaW5wdXQsIHsgLi4uaW5pdCwgaGVhZGVycyB9KVxuICB9XG59XG4iLCAiLy8gaGVscGVycy50c1xuaW1wb3J0IHsgU3VwYWJhc2VDbGllbnRPcHRpb25zIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIHV1aWQoKSB7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsXG4gICAgICB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFRyYWlsaW5nU2xhc2godXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcLyQvLCAnJylcbn1cblxuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVNldHRpbmdEZWZhdWx0czxcbiAgRGF0YWJhc2UgPSBhbnksXG4gIFNjaGVtYU5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZSA9ICdwdWJsaWMnIGV4dGVuZHMga2V5b2YgRGF0YWJhc2VcbiAgICA/ICdwdWJsaWMnXG4gICAgOiBzdHJpbmcgJiBrZXlvZiBEYXRhYmFzZVxuPihcbiAgb3B0aW9uczogU3VwYWJhc2VDbGllbnRPcHRpb25zPFNjaGVtYU5hbWU+LFxuICBkZWZhdWx0czogU3VwYWJhc2VDbGllbnRPcHRpb25zPGFueT5cbik6IFJlcXVpcmVkPFN1cGFiYXNlQ2xpZW50T3B0aW9uczxTY2hlbWFOYW1lPj4ge1xuICBjb25zdCB7XG4gICAgZGI6IGRiT3B0aW9ucyxcbiAgICBhdXRoOiBhdXRoT3B0aW9ucyxcbiAgICByZWFsdGltZTogcmVhbHRpbWVPcHRpb25zLFxuICAgIGdsb2JhbDogZ2xvYmFsT3B0aW9ucyxcbiAgfSA9IG9wdGlvbnNcbiAgY29uc3Qge1xuICAgIGRiOiBERUZBVUxUX0RCX09QVElPTlMsXG4gICAgYXV0aDogREVGQVVMVF9BVVRIX09QVElPTlMsXG4gICAgcmVhbHRpbWU6IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyxcbiAgICBnbG9iYWw6IERFRkFVTFRfR0xPQkFMX09QVElPTlMsXG4gIH0gPSBkZWZhdWx0c1xuXG4gIGNvbnN0IHJlc3VsdDogUmVxdWlyZWQ8U3VwYWJhc2VDbGllbnRPcHRpb25zPFNjaGVtYU5hbWU+PiA9IHtcbiAgICBkYjoge1xuICAgICAgLi4uREVGQVVMVF9EQl9PUFRJT05TLFxuICAgICAgLi4uZGJPcHRpb25zLFxuICAgIH0sXG4gICAgYXV0aDoge1xuICAgICAgLi4uREVGQVVMVF9BVVRIX09QVElPTlMsXG4gICAgICAuLi5hdXRoT3B0aW9ucyxcbiAgICB9LFxuICAgIHJlYWx0aW1lOiB7XG4gICAgICAuLi5ERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsXG4gICAgICAuLi5yZWFsdGltZU9wdGlvbnMsXG4gICAgfSxcbiAgICBnbG9iYWw6IHtcbiAgICAgIC4uLkRFRkFVTFRfR0xPQkFMX09QVElPTlMsXG4gICAgICAuLi5nbG9iYWxPcHRpb25zLFxuICAgIH0sXG4gICAgYWNjZXNzVG9rZW46IGFzeW5jICgpID0+ICcnLFxuICB9XG5cbiAgaWYgKG9wdGlvbnMuYWNjZXNzVG9rZW4pIHtcbiAgICByZXN1bHQuYWNjZXNzVG9rZW4gPSBvcHRpb25zLmFjY2Vzc1Rva2VuXG4gIH0gZWxzZSB7XG4gICAgLy8gaGFjayBhcm91bmQgUmVxdWlyZWQ8PlxuICAgIGRlbGV0ZSAocmVzdWx0IGFzIGFueSkuYWNjZXNzVG9rZW5cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cbiIsICJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjY3LjMnXG4iLCAiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbidcbmV4cG9ydCBjb25zdCBHT1RSVUVfVVJMID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6OTk5OSdcbmV4cG9ydCBjb25zdCBTVE9SQUdFX0tFWSA9ICdzdXBhYmFzZS5hdXRoLnRva2VuJ1xuZXhwb3J0IGNvbnN0IEFVRElFTkNFID0gJydcbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYGdvdHJ1ZS1qcy8ke3ZlcnNpb259YCB9XG5leHBvcnQgY29uc3QgRVhQSVJZX01BUkdJTiA9IDEwIC8vIGluIHNlY29uZHNcbmV4cG9ydCBjb25zdCBORVRXT1JLX0ZBSUxVUkUgPSB7XG4gIE1BWF9SRVRSSUVTOiAxMCxcbiAgUkVUUllfSU5URVJWQUw6IDIsIC8vIGluIGRlY2lzZWNvbmRzXG59XG5cbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSA9ICdYLVN1cGFiYXNlLUFwaS1WZXJzaW9uJ1xuZXhwb3J0IGNvbnN0IEFQSV9WRVJTSU9OUyA9IHtcbiAgJzIwMjQtMDEtMDEnOiB7XG4gICAgdGltZXN0YW1wOiBEYXRlLnBhcnNlKCcyMDI0LTAxLTAxVDAwOjAwOjAwLjBaJyksXG4gICAgbmFtZTogJzIwMjQtMDEtMDEnLFxuICB9LFxufVxuIiwgImltcG9ydCB7IEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FIH0gZnJvbSAnLi9jb25zdGFudHMnXG5pbXBvcnQgeyBTdXBwb3J0ZWRTdG9yYWdlIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGlyZXNBdChleHBpcmVzSW46IG51bWJlcikge1xuICBjb25zdCB0aW1lTm93ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMClcbiAgcmV0dXJuIHRpbWVOb3cgKyBleHBpcmVzSW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHV1aWQoKSB7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCxcbiAgICAgIHYgPSBjID09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDhcbiAgICByZXR1cm4gdi50b1N0cmluZygxNilcbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuY29uc3QgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cyA9IHtcbiAgdGVzdGVkOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGxvY2FsU3RvcmFnZSBpcyBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLlxuICovXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNMb2NhbFN0b3JhZ2UgPSAoKSA9PiB7XG4gIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIERPTSBleGNlcHRpb24gd2hlbiBhY2Nlc3NpbmcgYGxvY2FsU3RvcmFnZWBcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCkge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlXG4gIH1cblxuICBjb25zdCByYW5kb21LZXkgPSBgbHN3dC0ke01hdGgucmFuZG9tKCl9JHtNYXRoLnJhbmRvbSgpfWBcblxuICB0cnkge1xuICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnNldEl0ZW0ocmFuZG9tS2V5LCByYW5kb21LZXkpXG4gICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShyYW5kb21LZXkpXG5cbiAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCA9IHRydWVcbiAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlID0gdHJ1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gbG9jYWxTdG9yYWdlIGNhbid0IGJlIHdyaXR0ZW4gdG9cbiAgICAvLyBodHRwczovL3d3dy5jaHJvbWl1bS5vcmcvZm9yLXRlc3RlcnMvYnVnLXJlcG9ydGluZy1ndWlkZWxpbmVzL3VuY2F1Z2h0LXNlY3VyaXR5ZXJyb3ItZmFpbGVkLXRvLXJlYWQtdGhlLWxvY2Fsc3RvcmFnZS1wcm9wZXJ0eS1mcm9tLXdpbmRvdy1hY2Nlc3MtaXMtZGVuaWVkLWZvci10aGlzLWRvY3VtZW50XG5cbiAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCA9IHRydWVcbiAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlID0gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlXG59XG5cbi8qKlxuICogRXh0cmFjdHMgcGFyYW1ldGVycyBlbmNvZGVkIGluIHRoZSBVUkwgYm90aCBpbiB0aGUgcXVlcnkgYW5kIGZyYWdtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXJzRnJvbVVSTChocmVmOiBzdHJpbmcpIHtcbiAgY29uc3QgcmVzdWx0OiB7IFtwYXJhbWV0ZXI6IHN0cmluZ106IHN0cmluZyB9ID0ge31cblxuICBjb25zdCB1cmwgPSBuZXcgVVJMKGhyZWYpXG5cbiAgaWYgKHVybC5oYXNoICYmIHVybC5oYXNoWzBdID09PSAnIycpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGFzaFNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModXJsLmhhc2guc3Vic3RyaW5nKDEpKVxuICAgICAgaGFzaFNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAvLyBoYXNoIGlzIG5vdCBhIHF1ZXJ5IHN0cmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIHNlYXJjaCBwYXJhbWV0ZXJzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGhhc2ggcGFyYW1ldGVyc1xuICB1cmwuc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlXG4gIH0pXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG50eXBlIEZldGNoID0gdHlwZW9mIGZldGNoXG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2g/OiBGZXRjaCk6IEZldGNoID0+IHtcbiAgbGV0IF9mZXRjaDogRmV0Y2hcbiAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgX2ZldGNoID0gY3VzdG9tRmV0Y2hcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgX2ZldGNoID0gKC4uLmFyZ3MpID0+XG4gICAgICBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJyBhcyBhbnkpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT4gZmV0Y2goLi4uYXJncykpXG4gIH0gZWxzZSB7XG4gICAgX2ZldGNoID0gZmV0Y2hcbiAgfVxuICByZXR1cm4gKC4uLmFyZ3MpID0+IF9mZXRjaCguLi5hcmdzKVxufVxuXG5leHBvcnQgY29uc3QgbG9va3NMaWtlRmV0Y2hSZXNwb25zZSA9IChtYXliZVJlc3BvbnNlOiB1bmtub3duKTogbWF5YmVSZXNwb25zZSBpcyBSZXNwb25zZSA9PiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIG1heWJlUmVzcG9uc2UgPT09ICdvYmplY3QnICYmXG4gICAgbWF5YmVSZXNwb25zZSAhPT0gbnVsbCAmJlxuICAgICdzdGF0dXMnIGluIG1heWJlUmVzcG9uc2UgJiZcbiAgICAnb2snIGluIG1heWJlUmVzcG9uc2UgJiZcbiAgICAnanNvbicgaW4gbWF5YmVSZXNwb25zZSAmJlxuICAgIHR5cGVvZiAobWF5YmVSZXNwb25zZSBhcyBhbnkpLmpzb24gPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG4vLyBTdG9yYWdlIGhlbHBlcnNcbmV4cG9ydCBjb25zdCBzZXRJdGVtQXN5bmMgPSBhc3luYyAoXG4gIHN0b3JhZ2U6IFN1cHBvcnRlZFN0b3JhZ2UsXG4gIGtleTogc3RyaW5nLFxuICBkYXRhOiBhbnlcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBhd2FpdCBzdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShkYXRhKSlcbn1cblxuZXhwb3J0IGNvbnN0IGdldEl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlOiBTdXBwb3J0ZWRTdG9yYWdlLCBrZXk6IHN0cmluZyk6IFByb21pc2U8dW5rbm93bj4gPT4ge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IHN0b3JhZ2UuZ2V0SXRlbShrZXkpXG5cbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmVtb3ZlSXRlbUFzeW5jID0gYXN5bmMgKHN0b3JhZ2U6IFN1cHBvcnRlZFN0b3JhZ2UsIGtleTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGF3YWl0IHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCYXNlNjRVUkwodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGtleSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSdcbiAgbGV0IGJhc2U2NCA9ICcnXG4gIGxldCBjaHIxLCBjaHIyLCBjaHIzXG4gIGxldCBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0XG4gIGxldCBpID0gMFxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJy0nLCAnKycpLnJlcGxhY2UoJ18nLCAnLycpXG5cbiAgd2hpbGUgKGkgPCB2YWx1ZS5sZW5ndGgpIHtcbiAgICBlbmMxID0ga2V5LmluZGV4T2YodmFsdWUuY2hhckF0KGkrKykpXG4gICAgZW5jMiA9IGtleS5pbmRleE9mKHZhbHVlLmNoYXJBdChpKyspKVxuICAgIGVuYzMgPSBrZXkuaW5kZXhPZih2YWx1ZS5jaGFyQXQoaSsrKSlcbiAgICBlbmM0ID0ga2V5LmluZGV4T2YodmFsdWUuY2hhckF0KGkrKykpXG4gICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNClcbiAgICBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMilcbiAgICBjaHIzID0gKChlbmMzICYgMykgPDwgNikgfCBlbmM0XG4gICAgYmFzZTY0ID0gYmFzZTY0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIxKVxuXG4gICAgaWYgKGVuYzMgIT0gNjQgJiYgY2hyMiAhPSAwKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpXG4gICAgfVxuICAgIGlmIChlbmM0ICE9IDY0ICYmIGNocjMgIT0gMCkge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIzKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYmFzZTY0XG59XG5cbi8qKlxuICogQSBkZWZlcnJlZCByZXByZXNlbnRzIHNvbWUgYXN5bmNocm9ub3VzIHdvcmsgdGhhdCBpcyBub3QgeWV0IGZpbmlzaGVkLCB3aGljaFxuICogbWF5IG9yIG1heSBub3QgY3VsbWluYXRlIGluIGEgdmFsdWUuXG4gKiBUYWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbWlrZS1ub3J0aC90eXBlcy9ibG9iL21hc3Rlci9zcmMvYXN5bmMudHNcbiAqL1xuZXhwb3J0IGNsYXNzIERlZmVycmVkPFQgPSBhbnk+IHtcbiAgcHVibGljIHN0YXRpYyBwcm9taXNlQ29uc3RydWN0b3I6IFByb21pc2VDb25zdHJ1Y3RvciA9IFByb21pc2VcblxuICBwdWJsaWMgcmVhZG9ubHkgcHJvbWlzZSE6IFByb21pc2VMaWtlPFQ+XG5cbiAgcHVibGljIHJlYWRvbmx5IHJlc29sdmUhOiAodmFsdWU/OiBUIHwgUHJvbWlzZUxpa2U8VD4pID0+IHZvaWRcblxuICBwdWJsaWMgcmVhZG9ubHkgcmVqZWN0ITogKHJlYXNvbj86IGFueSkgPT4gYW55XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgIDsodGhpcyBhcyBhbnkpLnByb21pc2UgPSBuZXcgRGVmZXJyZWQucHJvbWlzZUNvbnN0cnVjdG9yKChyZXMsIHJlaikgPT4ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gICAgICA7KHRoaXMgYXMgYW55KS5yZXNvbHZlID0gcmVzXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgIDsodGhpcyBhcyBhbnkpLnJlamVjdCA9IHJlalxuICAgIH0pXG4gIH1cbn1cblxuLy8gVGFrZW4gZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzg1NTIwMDMvaG93LXRvLWRlY29kZS1qd3QtdG9rZW4taW4tamF2YXNjcmlwdC13aXRob3V0LXVzaW5nLWEtbGlicmFyeVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUpXVFBheWxvYWQodG9rZW46IHN0cmluZykge1xuICAvLyBSZWdleCBjaGVja3MgZm9yIGJhc2U2NHVybCBmb3JtYXRcbiAgY29uc3QgYmFzZTY0VXJsUmVnZXggPSAvXihbYS16MC05Xy1dezR9KSooJHxbYS16MC05Xy1dezN9PT8kfFthLXowLTlfLV17Mn0oPT0pPyQpJC9pXG5cbiAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdCgnLicpXG5cbiAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignSldUIGlzIG5vdCB2YWxpZDogbm90IGEgSldUIHN0cnVjdHVyZScpXG4gIH1cblxuICBpZiAoIWJhc2U2NFVybFJlZ2V4LnRlc3QocGFydHNbMV0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdKV1QgaXMgbm90IHZhbGlkOiBwYXlsb2FkIGlzIG5vdCBpbiBiYXNlNjR1cmwgZm9ybWF0JylcbiAgfVxuXG4gIGNvbnN0IGJhc2U2NFVybCA9IHBhcnRzWzFdXG4gIHJldHVybiBKU09OLnBhcnNlKGRlY29kZUJhc2U2NFVSTChiYXNlNjRVcmwpKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gbnVsbCBhZnRlciBzb21lIHRpbWUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzbGVlcCh0aW1lOiBudW1iZXIpOiBQcm9taXNlPG51bGw+IHtcbiAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChhY2NlcHQpID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IGFjY2VwdChudWxsKSwgdGltZSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcHJvdmlkZWQgYXN5bmMgZnVuY3Rpb24gaW50byBhIHJldHJ5YWJsZSBmdW5jdGlvbi4gRWFjaCByZXN1bHRcbiAqIG9yIHRocm93biBlcnJvciBpcyBzZW50IHRvIHRoZSBpc1JldHJ5YWJsZSBmdW5jdGlvbiB3aGljaCBzaG91bGQgcmV0dXJuIHRydWVcbiAqIGlmIHRoZSBmdW5jdGlvbiBzaG91bGQgcnVuIGFnYWluLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV0cnlhYmxlPFQ+KFxuICBmbjogKGF0dGVtcHQ6IG51bWJlcikgPT4gUHJvbWlzZTxUPixcbiAgaXNSZXRyeWFibGU6IChhdHRlbXB0OiBudW1iZXIsIGVycm9yOiBhbnkgfCBudWxsLCByZXN1bHQ/OiBUKSA9PiBib29sZWFuXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFQ+KChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgIDsoYXN5bmMgKCkgPT4ge1xuICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBJbmZpbml0eTsgYXR0ZW1wdCsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oYXR0ZW1wdClcblxuICAgICAgICAgIGlmICghaXNSZXRyeWFibGUoYXR0ZW1wdCwgbnVsbCwgcmVzdWx0KSkge1xuICAgICAgICAgICAgYWNjZXB0KHJlc3VsdClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgaWYgKCFpc1JldHJ5YWJsZShhdHRlbXB0LCBlKSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSgpXG4gIH0pXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gZGVjMmhleChkZWM6IG51bWJlcikge1xuICByZXR1cm4gKCcwJyArIGRlYy50b1N0cmluZygxNikpLnN1YnN0cigtMilcbn1cblxuLy8gRnVuY3Rpb25zIGJlbG93IHRha2VuIGZyb206IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYzMzA5NDA5L2NyZWF0aW5nLWEtY29kZS12ZXJpZmllci1hbmQtY2hhbGxlbmdlLWZvci1wa2NlLWF1dGgtb24tc3BvdGlmeS1hcGktaW4tcmVhY3Rqc1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUEtDRVZlcmlmaWVyKCkge1xuICBjb25zdCB2ZXJpZmllckxlbmd0aCA9IDU2XG4gIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KHZlcmlmaWVyTGVuZ3RoKVxuICBpZiAodHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdCBjaGFyU2V0ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LS5ffidcbiAgICBjb25zdCBjaGFyU2V0TGVuID0gY2hhclNldC5sZW5ndGhcbiAgICBsZXQgdmVyaWZpZXIgPSAnJ1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVyaWZpZXJMZW5ndGg7IGkrKykge1xuICAgICAgdmVyaWZpZXIgKz0gY2hhclNldC5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhclNldExlbikpXG4gICAgfVxuICAgIHJldHVybiB2ZXJpZmllclxuICB9XG4gIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpXG4gIHJldHVybiBBcnJheS5mcm9tKGFycmF5LCBkZWMyaGV4KS5qb2luKCcnKVxufVxuXG5hc3luYyBmdW5jdGlvbiBzaGEyNTYocmFuZG9tU3RyaW5nOiBzdHJpbmcpIHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG4gIGNvbnN0IGVuY29kZWREYXRhID0gZW5jb2Rlci5lbmNvZGUocmFuZG9tU3RyaW5nKVxuICBjb25zdCBoYXNoID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBlbmNvZGVkRGF0YSlcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShoYXNoKVxuXG4gIHJldHVybiBBcnJheS5mcm9tKGJ5dGVzKVxuICAgIC5tYXAoKGMpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYykpXG4gICAgLmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NHVybGVuY29kZShzdHI6IHN0cmluZykge1xuICByZXR1cm4gYnRvYShzdHIpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpLnJlcGxhY2UoLz0rJC8sICcnKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVQS0NFQ2hhbGxlbmdlKHZlcmlmaWVyOiBzdHJpbmcpIHtcbiAgY29uc3QgaGFzQ3J5cHRvU3VwcG9ydCA9XG4gICAgdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY3J5cHRvLnN1YnRsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnXG5cbiAgaWYgKCFoYXNDcnlwdG9TdXBwb3J0KSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1dlYkNyeXB0byBBUEkgaXMgbm90IHN1cHBvcnRlZC4gQ29kZSBjaGFsbGVuZ2UgbWV0aG9kIHdpbGwgZGVmYXVsdCB0byB1c2UgcGxhaW4gaW5zdGVhZCBvZiBzaGEyNTYuJ1xuICAgIClcbiAgICByZXR1cm4gdmVyaWZpZXJcbiAgfVxuICBjb25zdCBoYXNoZWQgPSBhd2FpdCBzaGEyNTYodmVyaWZpZXIpXG4gIHJldHVybiBiYXNlNjR1cmxlbmNvZGUoaGFzaGVkKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChcbiAgc3RvcmFnZTogU3VwcG9ydGVkU3RvcmFnZSxcbiAgc3RvcmFnZUtleTogc3RyaW5nLFxuICBpc1Bhc3N3b3JkUmVjb3ZlcnkgPSBmYWxzZVxuKSB7XG4gIGNvbnN0IGNvZGVWZXJpZmllciA9IGdlbmVyYXRlUEtDRVZlcmlmaWVyKClcbiAgbGV0IHN0b3JlZENvZGVWZXJpZmllciA9IGNvZGVWZXJpZmllclxuICBpZiAoaXNQYXNzd29yZFJlY292ZXJ5KSB7XG4gICAgc3RvcmVkQ29kZVZlcmlmaWVyICs9ICcvUEFTU1dPUkRfUkVDT1ZFUlknXG4gIH1cbiAgYXdhaXQgc2V0SXRlbUFzeW5jKHN0b3JhZ2UsIGAke3N0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgLCBzdG9yZWRDb2RlVmVyaWZpZXIpXG4gIGNvbnN0IGNvZGVDaGFsbGVuZ2UgPSBhd2FpdCBnZW5lcmF0ZVBLQ0VDaGFsbGVuZ2UoY29kZVZlcmlmaWVyKVxuICBjb25zdCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gY29kZVZlcmlmaWVyID09PSBjb2RlQ2hhbGxlbmdlID8gJ3BsYWluJyA6ICdzMjU2J1xuICByZXR1cm4gW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdXG59XG5cbi8qKiBQYXJzZXMgdGhlIEFQSSB2ZXJzaW9uIHdoaWNoIGlzIDJZWVktTU0tREQuICovXG5jb25zdCBBUElfVkVSU0lPTl9SRUdFWCA9IC9eMlswLTldezN9LSgwWzEtOV18MVswLTJdKS0oMFsxLTldfDFbMC05XXwyWzAtOV18M1swLTFdKSQvaVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZXNwb25zZUFQSVZlcnNpb24ocmVzcG9uc2U6IFJlc3BvbnNlKSB7XG4gIGNvbnN0IGFwaVZlcnNpb24gPSByZXNwb25zZS5oZWFkZXJzLmdldChBUElfVkVSU0lPTl9IRUFERVJfTkFNRSlcblxuICBpZiAoIWFwaVZlcnNpb24pIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgaWYgKCFhcGlWZXJzaW9uLm1hdGNoKEFQSV9WRVJTSU9OX1JFR0VYKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHthcGlWZXJzaW9ufVQwMDowMDowMC4wWmApXG4gICAgcmV0dXJuIGRhdGVcbiAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuIiwgImltcG9ydCB7IFdlYWtQYXNzd29yZFJlYXNvbnMgfSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHsgRXJyb3JDb2RlIH0gZnJvbSAnLi9lcnJvci1jb2RlcydcblxuZXhwb3J0IGNsYXNzIEF1dGhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIEVycm9yIGNvZGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBlcnJvci4gTW9zdCBlcnJvcnMgY29taW5nIGZyb21cbiAgICogSFRUUCByZXNwb25zZXMgd2lsbCBoYXZlIGEgY29kZSwgdGhvdWdoIHNvbWUgZXJyb3JzIHRoYXQgb2NjdXJcbiAgICogYmVmb3JlIGEgcmVzcG9uc2UgaXMgcmVjZWl2ZWQgd2lsbCBub3QgaGF2ZSBvbmUgcHJlc2VudC4gSW4gdGhhdFxuICAgKiBjYXNlIHtAbGluayAjc3RhdHVzfSB3aWxsIGFsc28gYmUgdW5kZWZpbmVkLlxuICAgKi9cbiAgY29kZTogRXJyb3JDb2RlIHwgKHN0cmluZyAmIHt9KSB8IHVuZGVmaW5lZFxuXG4gIC8qKiBIVFRQIHN0YXR1cyBjb2RlIHRoYXQgY2F1c2VkIHRoZSBlcnJvci4gKi9cbiAgc3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWRcblxuICBwcm90ZWN0ZWQgX19pc0F1dGhFcnJvciA9IHRydWVcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1cz86IG51bWJlciwgY29kZT86IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0F1dGhFcnJvcidcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c1xuICAgIHRoaXMuY29kZSA9IGNvZGVcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBBdXRoRXJyb3Ige1xuICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnX19pc0F1dGhFcnJvcicgaW4gZXJyb3Jcbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhBcGlFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gIHN0YXR1czogbnVtYmVyXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBzdGF0dXM6IG51bWJlciwgY29kZTogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgc3RhdHVzLCBjb2RlKVxuICAgIHRoaXMubmFtZSA9ICdBdXRoQXBpRXJyb3InXG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXNcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aEFwaUVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgQXV0aEFwaUVycm9yIHtcbiAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aEFwaUVycm9yJ1xufVxuXG5leHBvcnQgY2xhc3MgQXV0aFVua25vd25FcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gIG9yaWdpbmFsRXJyb3I6IHVua25vd25cblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIG9yaWdpbmFsRXJyb3I6IHVua25vd24pIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdBdXRoVW5rbm93bkVycm9yJ1xuICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3JcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ3VzdG9tQXV0aEVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgbmFtZTogc3RyaW5nXG4gIHN0YXR1czogbnVtYmVyXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyLCBjb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBzdGF0dXMsIGNvZGUpXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ0F1dGggc2Vzc2lvbiBtaXNzaW5nIScsICdBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcicsIDQwMCwgdW5kZWZpbmVkKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKGVycm9yOiBhbnkpOiBlcnJvciBpcyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciB7XG4gIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yJ1xufVxuXG5leHBvcnQgY2xhc3MgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignQXV0aCBzZXNzaW9uIG9yIHVzZXIgbWlzc2luZycsICdBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcicsIDUwMCwgdW5kZWZpbmVkKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlLCAnQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yJywgNDAwLCB1bmRlZmluZWQpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gIGRldGFpbHM6IHsgZXJyb3I6IHN0cmluZzsgY29kZTogc3RyaW5nIH0gfCBudWxsID0gbnVsbFxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGRldGFpbHM6IHsgZXJyb3I6IHN0cmluZzsgY29kZTogc3RyaW5nIH0gfCBudWxsID0gbnVsbCkge1xuICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3InLCA1MDAsIHVuZGVmaW5lZClcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzXG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBkZXRhaWxzOiB0aGlzLmRldGFpbHMsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihcbiAgZXJyb3I6IGFueVxuKTogZXJyb3IgaXMgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIHtcbiAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yJ1xufVxuXG5leHBvcnQgY2xhc3MgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgZGV0YWlsczogeyBlcnJvcjogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBkZXRhaWxzOiB7IGVycm9yOiBzdHJpbmc7IGNvZGU6IHN0cmluZyB9IHwgbnVsbCA9IG51bGwpIHtcbiAgICBzdXBlcihtZXNzYWdlLCAnQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yJywgNTAwLCB1bmRlZmluZWQpXG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlsc1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgZGV0YWlsczogdGhpcy5kZXRhaWxzLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhSZXRyeWFibGVGZXRjaEVycm9yJywgc3RhdHVzLCB1bmRlZmluZWQpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciB7XG4gIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhSZXRyeWFibGVGZXRjaEVycm9yJ1xufVxuXG4vKipcbiAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIG9uIGNlcnRhaW4gbWV0aG9kcyB3aGVuIHRoZSBwYXNzd29yZCB1c2VkIGlzIGRlZW1lZFxuICogd2Vhay4gSW5zcGVjdCB0aGUgcmVhc29ucyB0byBpZGVudGlmeSB3aGF0IHBhc3N3b3JkIHN0cmVuZ3RoIHJ1bGVzIGFyZVxuICogaW5hZGVxdWF0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhXZWFrUGFzc3dvcmRFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gIC8qKlxuICAgKiBSZWFzb25zIHdoeSB0aGUgcGFzc3dvcmQgaXMgZGVlbWVkIHdlYWsuXG4gICAqL1xuICByZWFzb25zOiBXZWFrUGFzc3dvcmRSZWFzb25zW11cblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyLCByZWFzb25zOiBzdHJpbmdbXSkge1xuICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoV2Vha1Bhc3N3b3JkRXJyb3InLCBzdGF0dXMsICd3ZWFrX3Bhc3N3b3JkJylcblxuICAgIHRoaXMucmVhc29ucyA9IHJlYXNvbnNcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBBdXRoV2Vha1Bhc3N3b3JkRXJyb3Ige1xuICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoV2Vha1Bhc3N3b3JkRXJyb3InXG59XG4iLCAiaW1wb3J0IHsgQVBJX1ZFUlNJT05TLCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSB9IGZyb20gJy4vY29uc3RhbnRzJ1xuaW1wb3J0IHsgZXhwaXJlc0F0LCBsb29rc0xpa2VGZXRjaFJlc3BvbnNlLCBwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbiB9IGZyb20gJy4vaGVscGVycydcbmltcG9ydCB7XG4gIEF1dGhSZXNwb25zZSxcbiAgQXV0aFJlc3BvbnNlUGFzc3dvcmQsXG4gIFNTT1Jlc3BvbnNlLFxuICBHZW5lcmF0ZUxpbmtQcm9wZXJ0aWVzLFxuICBHZW5lcmF0ZUxpbmtSZXNwb25zZSxcbiAgVXNlcixcbiAgVXNlclJlc3BvbnNlLFxufSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHtcbiAgQXV0aEFwaUVycm9yLFxuICBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcixcbiAgQXV0aFdlYWtQYXNzd29yZEVycm9yLFxuICBBdXRoVW5rbm93bkVycm9yLFxuICBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcixcbn0gZnJvbSAnLi9lcnJvcnMnXG5cbmV4cG9ydCB0eXBlIEZldGNoID0gdHlwZW9mIGZldGNoXG5cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hPcHRpb25zIHtcbiAgaGVhZGVycz86IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuICBub1Jlc29sdmVKc29uPzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZldGNoUGFyYW1ldGVycyB7XG4gIHNpZ25hbD86IEFib3J0U2lnbmFsXG59XG5cbmV4cG9ydCB0eXBlIFJlcXVlc3RNZXRob2RUeXBlID0gJ0dFVCcgfCAnUE9TVCcgfCAnUFVUJyB8ICdERUxFVEUnXG5cbmNvbnN0IF9nZXRFcnJvck1lc3NhZ2UgPSAoZXJyOiBhbnkpOiBzdHJpbmcgPT5cbiAgZXJyLm1zZyB8fCBlcnIubWVzc2FnZSB8fCBlcnIuZXJyb3JfZGVzY3JpcHRpb24gfHwgZXJyLmVycm9yIHx8IEpTT04uc3RyaW5naWZ5KGVycilcblxuY29uc3QgTkVUV09SS19FUlJPUl9DT0RFUyA9IFs1MDIsIDUwMywgNTA0XVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3I6IHVua25vd24pIHtcbiAgaWYgKCFsb29rc0xpa2VGZXRjaFJlc3BvbnNlKGVycm9yKSkge1xuICAgIHRocm93IG5ldyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSwgMClcbiAgfVxuXG4gIGlmIChORVRXT1JLX0VSUk9SX0NPREVTLmluY2x1ZGVzKGVycm9yLnN0YXR1cykpIHtcbiAgICAvLyBzdGF0dXMgaW4gNTAwLi4uNTk5IHJhbmdlIC0gc2VydmVyIGhhZCBhbiBlcnJvciwgcmVxdWVzdCBtaWdodCBiZSByZXRyeWVkLlxuICAgIHRocm93IG5ldyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSwgZXJyb3Iuc3RhdHVzKVxuICB9XG5cbiAgbGV0IGRhdGE6IGFueVxuICB0cnkge1xuICAgIGRhdGEgPSBhd2FpdCBlcnJvci5qc29uKClcbiAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgdGhyb3cgbmV3IEF1dGhVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZShlKSwgZSlcbiAgfVxuXG4gIGxldCBlcnJvckNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuXG4gIGNvbnN0IHJlc3BvbnNlQVBJVmVyc2lvbiA9IHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uKGVycm9yKVxuICBpZiAoXG4gICAgcmVzcG9uc2VBUElWZXJzaW9uICYmXG4gICAgcmVzcG9uc2VBUElWZXJzaW9uLmdldFRpbWUoKSA+PSBBUElfVkVSU0lPTlNbJzIwMjQtMDEtMDEnXS50aW1lc3RhbXAgJiZcbiAgICB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICBkYXRhICYmXG4gICAgdHlwZW9mIGRhdGEuY29kZSA9PT0gJ3N0cmluZydcbiAgKSB7XG4gICAgZXJyb3JDb2RlID0gZGF0YS5jb2RlXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgJiYgdHlwZW9mIGRhdGEuZXJyb3JfY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICBlcnJvckNvZGUgPSBkYXRhLmVycm9yX2NvZGVcbiAgfVxuXG4gIGlmICghZXJyb3JDb2RlKSB7XG4gICAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHdlYWsgcGFzc3dvcmQgZXJyb3JzLCB3aGVuIHRoZXJlIHdlcmUgbm8gZXJyb3IgY29kZXNcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIGRhdGEgJiZcbiAgICAgIHR5cGVvZiBkYXRhLndlYWtfcGFzc3dvcmQgPT09ICdvYmplY3QnICYmXG4gICAgICBkYXRhLndlYWtfcGFzc3dvcmQgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkoZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMpICYmXG4gICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5sZW5ndGggJiZcbiAgICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zLnJlZHVjZSgoYTogYm9vbGVhbiwgaTogYW55KSA9PiBhICYmIHR5cGVvZiBpID09PSAnc3RyaW5nJywgdHJ1ZSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoXG4gICAgICAgIF9nZXRFcnJvck1lc3NhZ2UoZGF0YSksXG4gICAgICAgIGVycm9yLnN0YXR1cyxcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnNcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXJyb3JDb2RlID09PSAnd2Vha19wYXNzd29yZCcpIHtcbiAgICB0aHJvdyBuZXcgQXV0aFdlYWtQYXNzd29yZEVycm9yKFxuICAgICAgX2dldEVycm9yTWVzc2FnZShkYXRhKSxcbiAgICAgIGVycm9yLnN0YXR1cyxcbiAgICAgIGRhdGEud2Vha19wYXNzd29yZD8ucmVhc29ucyB8fCBbXVxuICAgIClcbiAgfSBlbHNlIGlmIChlcnJvckNvZGUgPT09ICdzZXNzaW9uX25vdF9mb3VuZCcpIHtcbiAgICAvLyBUaGUgYHNlc3Npb25faWRgIGluc2lkZSB0aGUgSldUIGRvZXMgbm90IGNvcnJlc3BvbmQgdG8gYSByb3cgaW4gdGhlXG4gICAgLy8gYHNlc3Npb25zYCB0YWJsZS4gVGhpcyB1c3VhbGx5IG1lYW5zIHRoZSB1c2VyIGhhcyBzaWduZWQgb3V0LCBoYXMgYmVlblxuICAgIC8vIGRlbGV0ZWQsIG9yIHRoZWlyIHNlc3Npb24gaGFzIHNvbWVob3cgYmVlbiB0ZXJtaW5hdGVkLlxuICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG4gIH1cblxuICB0aHJvdyBuZXcgQXV0aEFwaUVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZGF0YSksIGVycm9yLnN0YXR1cyB8fCA1MDAsIGVycm9yQ29kZSlcbn1cblxuY29uc3QgX2dldFJlcXVlc3RQYXJhbXMgPSAoXG4gIG1ldGhvZDogUmVxdWVzdE1ldGhvZFR5cGUsXG4gIG9wdGlvbnM/OiBGZXRjaE9wdGlvbnMsXG4gIHBhcmFtZXRlcnM/OiBGZXRjaFBhcmFtZXRlcnMsXG4gIGJvZHk/OiBvYmplY3RcbikgPT4ge1xuICBjb25zdCBwYXJhbXM6IHsgW2s6IHN0cmluZ106IGFueSB9ID0geyBtZXRob2QsIGhlYWRlcnM6IG9wdGlvbnM/LmhlYWRlcnMgfHwge30gfVxuXG4gIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG5cbiAgcGFyYW1zLmhlYWRlcnMgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04JywgLi4ub3B0aW9ucz8uaGVhZGVycyB9XG4gIHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgcmV0dXJuIHsgLi4ucGFyYW1zLCAuLi5wYXJhbWV0ZXJzIH1cbn1cblxuaW50ZXJmYWNlIEdvdHJ1ZVJlcXVlc3RPcHRpb25zIGV4dGVuZHMgRmV0Y2hPcHRpb25zIHtcbiAgand0Pzogc3RyaW5nXG4gIHJlZGlyZWN0VG8/OiBzdHJpbmdcbiAgYm9keT86IG9iamVjdFxuICBxdWVyeT86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRoYXQgdHJhbnNmb3JtcyBhcGkgcmVzcG9uc2UgZnJvbSBnb3RydWUgaW50byBhIGRlc2lyYWJsZSAvIHN0YW5kYXJkaXNlZCBmb3JtYXRcbiAgICovXG4gIHhmb3JtPzogKGRhdGE6IGFueSkgPT4gYW55XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfcmVxdWVzdChcbiAgZmV0Y2hlcjogRmV0Y2gsXG4gIG1ldGhvZDogUmVxdWVzdE1ldGhvZFR5cGUsXG4gIHVybDogc3RyaW5nLFxuICBvcHRpb25zPzogR290cnVlUmVxdWVzdE9wdGlvbnNcbikge1xuICBjb25zdCBoZWFkZXJzID0ge1xuICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gIH1cblxuICBpZiAoIWhlYWRlcnNbQVBJX1ZFUlNJT05fSEVBREVSX05BTUVdKSB7XG4gICAgaGVhZGVyc1tBUElfVkVSU0lPTl9IRUFERVJfTkFNRV0gPSBBUElfVkVSU0lPTlNbJzIwMjQtMDEtMDEnXS5uYW1lXG4gIH1cblxuICBpZiAob3B0aW9ucz8uand0KSB7XG4gICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke29wdGlvbnMuand0fWBcbiAgfVxuXG4gIGNvbnN0IHFzID0gb3B0aW9ucz8ucXVlcnkgPz8ge31cbiAgaWYgKG9wdGlvbnM/LnJlZGlyZWN0VG8pIHtcbiAgICBxc1sncmVkaXJlY3RfdG8nXSA9IG9wdGlvbnMucmVkaXJlY3RUb1xuICB9XG5cbiAgY29uc3QgcXVlcnlTdHJpbmcgPSBPYmplY3Qua2V5cyhxcykubGVuZ3RoID8gJz8nICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhxcykudG9TdHJpbmcoKSA6ICcnXG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBfaGFuZGxlUmVxdWVzdChcbiAgICBmZXRjaGVyLFxuICAgIG1ldGhvZCxcbiAgICB1cmwgKyBxdWVyeVN0cmluZyxcbiAgICB7XG4gICAgICBoZWFkZXJzLFxuICAgICAgbm9SZXNvbHZlSnNvbjogb3B0aW9ucz8ubm9SZXNvbHZlSnNvbixcbiAgICB9LFxuICAgIHt9LFxuICAgIG9wdGlvbnM/LmJvZHlcbiAgKVxuICByZXR1cm4gb3B0aW9ucz8ueGZvcm0gPyBvcHRpb25zPy54Zm9ybShkYXRhKSA6IHsgZGF0YTogeyAuLi5kYXRhIH0sIGVycm9yOiBudWxsIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QoXG4gIGZldGNoZXI6IEZldGNoLFxuICBtZXRob2Q6IFJlcXVlc3RNZXRob2RUeXBlLFxuICB1cmw6IHN0cmluZyxcbiAgb3B0aW9ucz86IEZldGNoT3B0aW9ucyxcbiAgcGFyYW1ldGVycz86IEZldGNoUGFyYW1ldGVycyxcbiAgYm9keT86IG9iamVjdFxuKTogUHJvbWlzZTxhbnk+IHtcbiAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IF9nZXRSZXF1ZXN0UGFyYW1zKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSlcblxuICBsZXQgcmVzdWx0OiBhbnlcblxuICB0cnkge1xuICAgIHJlc3VsdCA9IGF3YWl0IGZldGNoZXIodXJsLCB7XG4gICAgICAuLi5yZXF1ZXN0UGFyYW1zLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpXG5cbiAgICAvLyBmZXRjaCBmYWlsZWQsIGxpa2VseSBkdWUgdG8gYSBuZXR3b3JrIG9yIENPUlMgZXJyb3JcbiAgICB0aHJvdyBuZXcgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoX2dldEVycm9yTWVzc2FnZShlKSwgMClcbiAgfVxuXG4gIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgYXdhaXQgaGFuZGxlRXJyb3IocmVzdWx0KVxuICB9XG5cbiAgaWYgKG9wdGlvbnM/Lm5vUmVzb2x2ZUpzb24pIHtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCByZXN1bHQuanNvbigpXG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIGF3YWl0IGhhbmRsZUVycm9yKGUpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9zZXNzaW9uUmVzcG9uc2UoZGF0YTogYW55KTogQXV0aFJlc3BvbnNlIHtcbiAgbGV0IHNlc3Npb24gPSBudWxsXG4gIGlmIChoYXNTZXNzaW9uKGRhdGEpKSB7XG4gICAgc2Vzc2lvbiA9IHsgLi4uZGF0YSB9XG5cbiAgICBpZiAoIWRhdGEuZXhwaXJlc19hdCkge1xuICAgICAgc2Vzc2lvbi5leHBpcmVzX2F0ID0gZXhwaXJlc0F0KGRhdGEuZXhwaXJlc19pbilcbiAgICB9XG4gIH1cblxuICBjb25zdCB1c2VyOiBVc2VyID0gZGF0YS51c2VyID8/IChkYXRhIGFzIFVzZXIpXG4gIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbiwgdXNlciB9LCBlcnJvcjogbnVsbCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQoZGF0YTogYW55KTogQXV0aFJlc3BvbnNlUGFzc3dvcmQge1xuICBjb25zdCByZXNwb25zZSA9IF9zZXNzaW9uUmVzcG9uc2UoZGF0YSkgYXMgQXV0aFJlc3BvbnNlUGFzc3dvcmRcblxuICBpZiAoXG4gICAgIXJlc3BvbnNlLmVycm9yICYmXG4gICAgZGF0YS53ZWFrX3Bhc3N3b3JkICYmXG4gICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZCA9PT0gJ29iamVjdCcgJiZcbiAgICBBcnJheS5pc0FycmF5KGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKSAmJlxuICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zLmxlbmd0aCAmJlxuICAgIGRhdGEud2Vha19wYXNzd29yZC5tZXNzYWdlICYmXG4gICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZC5tZXNzYWdlID09PSAnc3RyaW5nJyAmJlxuICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zLnJlZHVjZSgoYTogYm9vbGVhbiwgaTogYW55KSA9PiBhICYmIHR5cGVvZiBpID09PSAnc3RyaW5nJywgdHJ1ZSlcbiAgKSB7XG4gICAgcmVzcG9uc2UuZGF0YS53ZWFrX3Bhc3N3b3JkID0gZGF0YS53ZWFrX3Bhc3N3b3JkXG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF91c2VyUmVzcG9uc2UoZGF0YTogYW55KTogVXNlclJlc3BvbnNlIHtcbiAgY29uc3QgdXNlcjogVXNlciA9IGRhdGEudXNlciA/PyAoZGF0YSBhcyBVc2VyKVxuICByZXR1cm4geyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IG51bGwgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX3Nzb1Jlc3BvbnNlKGRhdGE6IGFueSk6IFNTT1Jlc3BvbnNlIHtcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX2dlbmVyYXRlTGlua1Jlc3BvbnNlKGRhdGE6IGFueSk6IEdlbmVyYXRlTGlua1Jlc3BvbnNlIHtcbiAgY29uc3QgeyBhY3Rpb25fbGluaywgZW1haWxfb3RwLCBoYXNoZWRfdG9rZW4sIHJlZGlyZWN0X3RvLCB2ZXJpZmljYXRpb25fdHlwZSwgLi4ucmVzdCB9ID0gZGF0YVxuXG4gIGNvbnN0IHByb3BlcnRpZXM6IEdlbmVyYXRlTGlua1Byb3BlcnRpZXMgPSB7XG4gICAgYWN0aW9uX2xpbmssXG4gICAgZW1haWxfb3RwLFxuICAgIGhhc2hlZF90b2tlbixcbiAgICByZWRpcmVjdF90byxcbiAgICB2ZXJpZmljYXRpb25fdHlwZSxcbiAgfVxuXG4gIGNvbnN0IHVzZXI6IFVzZXIgPSB7IC4uLnJlc3QgfVxuICByZXR1cm4ge1xuICAgIGRhdGE6IHtcbiAgICAgIHByb3BlcnRpZXMsXG4gICAgICB1c2VyLFxuICAgIH0sXG4gICAgZXJyb3I6IG51bGwsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9ub1Jlc29sdmVKc29uUmVzcG9uc2UoZGF0YTogYW55KTogUmVzcG9uc2Uge1xuICByZXR1cm4gZGF0YVxufVxuXG4vKipcbiAqIGhhc1Nlc3Npb24gY2hlY2tzIGlmIHRoZSByZXNwb25zZSBvYmplY3QgY29udGFpbnMgYSB2YWxpZCBzZXNzaW9uXG4gKiBAcGFyYW0gZGF0YSBBIHJlc3BvbnNlIG9iamVjdFxuICogQHJldHVybnMgdHJ1ZSBpZiBhIHNlc3Npb24gaXMgaW4gdGhlIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGhhc1Nlc3Npb24oZGF0YTogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiBkYXRhLmFjY2Vzc190b2tlbiAmJiBkYXRhLnJlZnJlc2hfdG9rZW4gJiYgZGF0YS5leHBpcmVzX2luXG59XG4iLCAiaW1wb3J0IHtcbiAgRmV0Y2gsXG4gIF9nZW5lcmF0ZUxpbmtSZXNwb25zZSxcbiAgX25vUmVzb2x2ZUpzb25SZXNwb25zZSxcbiAgX3JlcXVlc3QsXG4gIF91c2VyUmVzcG9uc2UsXG59IGZyb20gJy4vbGliL2ZldGNoJ1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi9saWIvaGVscGVycydcbmltcG9ydCB7XG4gIEFkbWluVXNlckF0dHJpYnV0ZXMsXG4gIEdlbmVyYXRlTGlua1BhcmFtcyxcbiAgR2VuZXJhdGVMaW5rUmVzcG9uc2UsXG4gIFBhZ2luYXRpb24sXG4gIFVzZXIsXG4gIFVzZXJSZXNwb25zZSxcbiAgR29UcnVlQWRtaW5NRkFBcGksXG4gIEF1dGhNRkFBZG1pbkRlbGV0ZUZhY3RvclBhcmFtcyxcbiAgQXV0aE1GQUFkbWluRGVsZXRlRmFjdG9yUmVzcG9uc2UsXG4gIEF1dGhNRkFBZG1pbkxpc3RGYWN0b3JzUGFyYW1zLFxuICBBdXRoTUZBQWRtaW5MaXN0RmFjdG9yc1Jlc3BvbnNlLFxuICBQYWdlUGFyYW1zLFxufSBmcm9tICcuL2xpYi90eXBlcydcbmltcG9ydCB7IEF1dGhFcnJvciwgaXNBdXRoRXJyb3IgfSBmcm9tICcuL2xpYi9lcnJvcnMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdvVHJ1ZUFkbWluQXBpIHtcbiAgLyoqIENvbnRhaW5zIGFsbCBNRkEgYWRtaW5pc3RyYXRpb24gbWV0aG9kcy4gKi9cbiAgbWZhOiBHb1RydWVBZG1pbk1GQUFwaVxuXG4gIHByb3RlY3RlZCB1cmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgaGVhZGVyczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9XG4gIHByb3RlY3RlZCBmZXRjaDogRmV0Y2hcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgdXJsID0gJycsXG4gICAgaGVhZGVycyA9IHt9LFxuICAgIGZldGNoLFxuICB9OiB7XG4gICAgdXJsOiBzdHJpbmdcbiAgICBoZWFkZXJzPzoge1xuICAgICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gICAgfVxuICAgIGZldGNoPzogRmV0Y2hcbiAgfSkge1xuICAgIHRoaXMudXJsID0gdXJsXG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVyc1xuICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goZmV0Y2gpXG4gICAgdGhpcy5tZmEgPSB7XG4gICAgICBsaXN0RmFjdG9yczogdGhpcy5fbGlzdEZhY3RvcnMuYmluZCh0aGlzKSxcbiAgICAgIGRlbGV0ZUZhY3RvcjogdGhpcy5fZGVsZXRlRmFjdG9yLmJpbmQodGhpcyksXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBsb2dnZWQtaW4gc2Vzc2lvbi5cbiAgICogQHBhcmFtIGp3dCBBIHZhbGlkLCBsb2dnZWQtaW4gSldULlxuICAgKiBAcGFyYW0gc2NvcGUgVGhlIGxvZ291dCBzb3BlLlxuICAgKi9cbiAgYXN5bmMgc2lnbk91dChcbiAgICBqd3Q6IHN0cmluZyxcbiAgICBzY29wZTogJ2dsb2JhbCcgfCAnbG9jYWwnIHwgJ290aGVycycgPSAnZ2xvYmFsJ1xuICApOiBQcm9taXNlPHsgZGF0YTogbnVsbDsgZXJyb3I6IEF1dGhFcnJvciB8IG51bGwgfT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9sb2dvdXQ/c2NvcGU9JHtzY29wZX1gLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgand0LFxuICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGFuIGludml0ZSBsaW5rIHRvIGFuIGVtYWlsIGFkZHJlc3MuXG4gICAqIEBwYXJhbSBlbWFpbCBUaGUgZW1haWwgYWRkcmVzcyBvZiB0aGUgdXNlci5cbiAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIGJlIGluY2x1ZGVkIHdoZW4gaW52aXRpbmcuXG4gICAqL1xuICBhc3luYyBpbnZpdGVVc2VyQnlFbWFpbChcbiAgICBlbWFpbDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIC8qKiBBIGN1c3RvbSBkYXRhIG9iamVjdCB0byBzdG9yZSBhZGRpdGlvbmFsIG1ldGFkYXRhIGFib3V0IHRoZSB1c2VyLiBUaGlzIG1hcHMgdG8gdGhlIGBhdXRoLnVzZXJzLnVzZXJfbWV0YWRhdGFgIGNvbHVtbi4gKi9cbiAgICAgIGRhdGE/OiBvYmplY3RcblxuICAgICAgLyoqIFRoZSBVUkwgd2hpY2ggd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZW1haWwgbGluayBzZW50IHRvIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy4gT25jZSBjbGlja2VkIHRoZSB1c2VyIHdpbGwgZW5kIHVwIG9uIHRoaXMgVVJMLiAqL1xuICAgICAgcmVkaXJlY3RUbz86IHN0cmluZ1xuICAgIH0gPSB7fVxuICApOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vaW52aXRlYCwge1xuICAgICAgICBib2R5OiB7IGVtYWlsLCBkYXRhOiBvcHRpb25zLmRhdGEgfSxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgZW1haWwgbGlua3MgYW5kIE9UUHMgdG8gYmUgc2VudCB2aWEgYSBjdXN0b20gZW1haWwgcHJvdmlkZXIuXG4gICAqIEBwYXJhbSBlbWFpbCBUaGUgdXNlcidzIGVtYWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5wYXNzd29yZCBVc2VyIHBhc3N3b3JkLiBGb3Igc2lnbnVwIG9ubHkuXG4gICAqIEBwYXJhbSBvcHRpb25zLmRhdGEgT3B0aW9uYWwgdXNlciBtZXRhZGF0YS4gRm9yIHNpZ251cCBvbmx5LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIFRoZSByZWRpcmVjdCB1cmwgd2hpY2ggc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBnZW5lcmF0ZWQgbGlua1xuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVMaW5rKHBhcmFtczogR2VuZXJhdGVMaW5rUGFyYW1zKTogUHJvbWlzZTxHZW5lcmF0ZUxpbmtSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IG9wdGlvbnMsIC4uLnJlc3QgfSA9IHBhcmFtc1xuICAgICAgY29uc3QgYm9keTogYW55ID0geyAuLi5yZXN0LCAuLi5vcHRpb25zIH1cbiAgICAgIGlmICgnbmV3RW1haWwnIGluIHJlc3QpIHtcbiAgICAgICAgLy8gcmVwbGFjZSBuZXdFbWFpbCB3aXRoIG5ld19lbWFpbCBpbiByZXF1ZXN0IGJvZHlcbiAgICAgICAgYm9keS5uZXdfZW1haWwgPSByZXN0Py5uZXdFbWFpbFxuICAgICAgICBkZWxldGUgYm9keVsnbmV3RW1haWwnXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2FkbWluL2dlbmVyYXRlX2xpbmtgLCB7XG4gICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgeGZvcm06IF9nZW5lcmF0ZUxpbmtSZXNwb25zZSxcbiAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucz8ucmVkaXJlY3RUbyxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgICAgICAgdXNlcjogbnVsbCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8vIFVzZXIgQWRtaW4gQVBJXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHVzZXIuXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAqL1xuICBhc3luYyBjcmVhdGVVc2VyKGF0dHJpYnV0ZXM6IEFkbWluVXNlckF0dHJpYnV0ZXMpOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnNgLCB7XG4gICAgICAgIGJvZHk6IGF0dHJpYnV0ZXMsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgdXNlcnMuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAqIEBwYXJhbSBwYXJhbXMgQW4gb2JqZWN0IHdoaWNoIHN1cHBvcnRzIGBwYWdlYCBhbmQgYHBlclBhZ2VgIGFzIG51bWJlcnMsIHRvIGFsdGVyIHRoZSBwYWdpbmF0ZWQgcmVzdWx0cy5cbiAgICovXG4gIGFzeW5jIGxpc3RVc2VycyhcbiAgICBwYXJhbXM/OiBQYWdlUGFyYW1zXG4gICk6IFByb21pc2U8XG4gICAgfCB7IGRhdGE6IHsgdXNlcnM6IFVzZXJbXTsgYXVkOiBzdHJpbmcgfSAmIFBhZ2luYXRpb247IGVycm9yOiBudWxsIH1cbiAgICB8IHsgZGF0YTogeyB1c2VyczogW10gfTsgZXJyb3I6IEF1dGhFcnJvciB9XG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYWdpbmF0aW9uOiBQYWdpbmF0aW9uID0geyBuZXh0UGFnZTogbnVsbCwgbGFzdFBhZ2U6IDAsIHRvdGFsOiAwIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vyc2AsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgICAgICBxdWVyeToge1xuICAgICAgICAgIHBhZ2U6IHBhcmFtcz8ucGFnZT8udG9TdHJpbmcoKSA/PyAnJyxcbiAgICAgICAgICBwZXJfcGFnZTogcGFyYW1zPy5wZXJQYWdlPy50b1N0cmluZygpID8/ICcnLFxuICAgICAgICB9LFxuICAgICAgICB4Zm9ybTogX25vUmVzb2x2ZUpzb25SZXNwb25zZSxcbiAgICAgIH0pXG4gICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHRocm93IHJlc3BvbnNlLmVycm9yXG5cbiAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICBjb25zdCB0b3RhbCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXRvdGFsLWNvdW50JykgPz8gMFxuICAgICAgY29uc3QgbGlua3MgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnbGluaycpPy5zcGxpdCgnLCcpID8/IFtdXG4gICAgICBpZiAobGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICBsaW5rcy5mb3JFYWNoKChsaW5rOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBwYWdlID0gcGFyc2VJbnQobGluay5zcGxpdCgnOycpWzBdLnNwbGl0KCc9JylbMV0uc3Vic3RyaW5nKDAsIDEpKVxuICAgICAgICAgIGNvbnN0IHJlbCA9IEpTT04ucGFyc2UobGluay5zcGxpdCgnOycpWzFdLnNwbGl0KCc9JylbMV0pXG4gICAgICAgICAgcGFnaW5hdGlvbltgJHtyZWx9UGFnZWBdID0gcGFnZVxuICAgICAgICB9KVxuXG4gICAgICAgIHBhZ2luYXRpb24udG90YWwgPSBwYXJzZUludCh0b3RhbClcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgLi4udXNlcnMsIC4uLnBhZ2luYXRpb24gfSwgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcnM6IFtdIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB1c2VyIGJ5IGlkLlxuICAgKlxuICAgKiBAcGFyYW0gdWlkIFRoZSB1c2VyJ3MgdW5pcXVlIGlkZW50aWZpZXJcbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGFzeW5jIGdldFVzZXJCeUlkKHVpZDogc3RyaW5nKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHt1aWR9YCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB1c2VyIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBkYXRhIHlvdSB3YW50IHRvIHVwZGF0ZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVVzZXJCeUlkKHVpZDogc3RyaW5nLCBhdHRyaWJ1dGVzOiBBZG1pblVzZXJBdHRyaWJ1dGVzKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQVVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHt1aWR9YCwge1xuICAgICAgICBib2R5OiBhdHRyaWJ1dGVzLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSB1c2VyLiBSZXF1aXJlcyBhIGBzZXJ2aWNlX3JvbGVgIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGlkIFRoZSB1c2VyIGlkIHlvdSB3YW50IHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIHNob3VsZFNvZnREZWxldGUgSWYgdHJ1ZSwgdGhlbiB0aGUgdXNlciB3aWxsIGJlIHNvZnQtZGVsZXRlZCBmcm9tIHRoZSBhdXRoIHNjaGVtYS4gU29mdCBkZWxldGlvbiBhbGxvd3MgdXNlciBpZGVudGlmaWNhdGlvbiBmcm9tIHRoZSBoYXNoZWQgdXNlciBJRCBidXQgaXMgbm90IHJldmVyc2libGUuXG4gICAqIERlZmF1bHRzIHRvIGZhbHNlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlVXNlcihpZDogc3RyaW5nLCBzaG91bGRTb2Z0RGVsZXRlID0gZmFsc2UpOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke2lkfWAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgc2hvdWxkX3NvZnRfZGVsZXRlOiBzaG91bGRTb2Z0RGVsZXRlLFxuICAgICAgICB9LFxuICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9saXN0RmFjdG9ycyhcbiAgICBwYXJhbXM6IEF1dGhNRkFBZG1pbkxpc3RGYWN0b3JzUGFyYW1zXG4gICk6IFByb21pc2U8QXV0aE1GQUFkbWluTGlzdEZhY3RvcnNSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgJ0dFVCcsXG4gICAgICAgIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3BhcmFtcy51c2VySWR9L2ZhY3RvcnNgLFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIHhmb3JtOiAoZmFjdG9yczogYW55KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGZhY3RvcnMgfSwgZXJyb3I6IG51bGwgfVxuICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfZGVsZXRlRmFjdG9yKFxuICAgIHBhcmFtczogQXV0aE1GQUFkbWluRGVsZXRlRmFjdG9yUGFyYW1zXG4gICk6IFByb21pc2U8QXV0aE1GQUFkbWluRGVsZXRlRmFjdG9yUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IF9yZXF1ZXN0KFxuICAgICAgICB0aGlzLmZldGNoLFxuICAgICAgICAnREVMRVRFJyxcbiAgICAgICAgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7cGFyYW1zLnVzZXJJZH0vZmFjdG9ycy8ke3BhcmFtcy5pZH1gLFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICB9XG4gICAgICApXG5cbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHsgc3VwcG9ydHNMb2NhbFN0b3JhZ2UgfSBmcm9tICcuL2hlbHBlcnMnXG5pbXBvcnQgeyBTdXBwb3J0ZWRTdG9yYWdlIH0gZnJvbSAnLi90eXBlcydcblxuLyoqXG4gKiBQcm92aWRlcyBzYWZlIGFjY2VzcyB0byB0aGUgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UgcHJvcGVydHkuXG4gKi9cbmV4cG9ydCBjb25zdCBsb2NhbFN0b3JhZ2VBZGFwdGVyOiBTdXBwb3J0ZWRTdG9yYWdlID0ge1xuICBnZXRJdGVtOiAoa2V5KSA9PiB7XG4gICAgaWYgKCFzdXBwb3J0c0xvY2FsU3RvcmFnZSgpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSlcbiAgfSxcbiAgc2V0SXRlbTogKGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAoIXN1cHBvcnRzTG9jYWxTdG9yYWdlKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSlcbiAgfSxcbiAgcmVtb3ZlSXRlbTogKGtleSkgPT4ge1xuICAgIGlmICghc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG4gIH0sXG59XG5cbi8qKlxuICogUmV0dXJucyBhIGxvY2FsU3RvcmFnZS1saWtlIG9iamVjdCB0aGF0IHN0b3JlcyB0aGUga2V5LXZhbHVlIHBhaXJzIGluXG4gKiBtZW1vcnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHN0b3JlOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge30pOiBTdXBwb3J0ZWRTdG9yYWdlIHtcbiAgcmV0dXJuIHtcbiAgICBnZXRJdGVtOiAoa2V5KSA9PiB7XG4gICAgICByZXR1cm4gc3RvcmVba2V5XSB8fCBudWxsXG4gICAgfSxcblxuICAgIHNldEl0ZW06IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICBzdG9yZVtrZXldID0gdmFsdWVcbiAgICB9LFxuXG4gICAgcmVtb3ZlSXRlbTogKGtleSkgPT4ge1xuICAgICAgZGVsZXRlIHN0b3JlW2tleV1cbiAgICB9LFxuICB9XG59XG4iLCAiLyoqXG4gKiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvZ2xvYmFsdGhpc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcG9seWZpbGxHbG9iYWxUaGlzKCkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm5cbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgJ19fbWFnaWNfXycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB9KVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBtYWdpYydcbiAgICBfX21hZ2ljX18uZ2xvYmFsVGhpcyA9IF9fbWFnaWNfX1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBtYWdpYydcbiAgICBkZWxldGUgT2JqZWN0LnByb3RvdHlwZS5fX21hZ2ljX19cbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBnbG9iYWxzJ1xuICAgICAgc2VsZi5nbG9iYWxUaGlzID0gc2VsZlxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IHN1cHBvcnRzTG9jYWxTdG9yYWdlIH0gZnJvbSAnLi9oZWxwZXJzJ1xuXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGNvbnN0IGludGVybmFscyA9IHtcbiAgLyoqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIGRlYnVnOiAhIShcbiAgICBnbG9iYWxUaGlzICYmXG4gICAgc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSAmJlxuICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlICYmXG4gICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc3VwYWJhc2UuZ290cnVlLWpzLmxvY2tzLmRlYnVnJykgPT09ICd0cnVlJ1xuICApLFxufVxuXG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGEgbG9jayBjYW5ub3QgYmUgYWNxdWlyZWQgYWZ0ZXIgc29tZSBhbW91bnQgb2YgdGltZS5cbiAqXG4gKiBVc2UgdGhlIHtAbGluayAjaXNBY3F1aXJlVGltZW91dH0gcHJvcGVydHkgaW5zdGVhZCBvZiBjaGVja2luZyB3aXRoIGBpbnN0YW5jZW9mYC5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgaXNBY3F1aXJlVGltZW91dCA9IHRydWVcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIHt9XG5leHBvcnQgY2xhc3MgUHJvY2Vzc0xvY2tBY3F1aXJlVGltZW91dEVycm9yIGV4dGVuZHMgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3Ige31cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgZ2xvYmFsIGV4Y2x1c2l2ZSBsb2NrIHVzaW5nIHRoZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgQVBJLiBJdFxuICogaXMgYXZhaWxhYmxlIG9uIGFsbCBicm93c2VycyByZWxlYXNlZCBhZnRlciAyMDIyLTAzLTE1IHdpdGggU2FmYXJpIGJlaW5nIHRoZVxuICogbGFzdCBvbmUgdG8gcmVsZWFzZSBzdXBwb3J0LiBJZiB0aGUgQVBJIGlzIG5vdCBhdmFpbGFibGUsIHRoaXMgZnVuY3Rpb24gd2lsbFxuICogdGhyb3cuIE1ha2Ugc3VyZSB5b3UgY2hlY2sgYXZhaWxhYmxpbGl0eSBiZWZvcmUgY29uZmlndXJpbmcge0BsaW5rXG4gKiBHb1RydWVDbGllbnR9LlxuICpcbiAqIFlvdSBjYW4gdHVybiBvbiBkZWJ1Z2dpbmcgYnkgc2V0dGluZyB0aGUgYHN1cGFiYXNlLmdvdHJ1ZS1qcy5sb2Nrcy5kZWJ1Z2BcbiAqIGxvY2FsIHN0b3JhZ2UgaXRlbSB0byBgdHJ1ZWAuXG4gKlxuICogSW50ZXJuYWxzOlxuICpcbiAqIFNpbmNlIHRoZSBMb2NrTWFuYWdlciBBUEkgZG9lcyBub3QgcHJlc2VydmUgc3RhY2sgdHJhY2VzIGZvciB0aGUgYXN5bmNcbiAqIGZ1bmN0aW9uIHBhc3NlZCBpbiB0aGUgYHJlcXVlc3RgIG1ldGhvZCwgYSB0cmljayBpcyB1c2VkIHdoZXJlIGFjcXVpcmluZyB0aGVcbiAqIGxvY2sgcmVsZWFzZXMgYSBwcmV2aW91c2x5IHN0YXJ0ZWQgcHJvbWlzZSB0byBydW4gdGhlIG9wZXJhdGlvbiBpbiB0aGUgYGZuYFxuICogZnVuY3Rpb24uIFRoZSBsb2NrIHdhaXRzIGZvciB0aGF0IHByb21pc2UgdG8gZmluaXNoICh3aXRoIG9yIHdpdGhvdXQgZXJyb3IpLFxuICogd2hpbGUgdGhlIGZ1bmN0aW9uIHdpbGwgZmluYWxseSB3YWl0IGZvciB0aGUgcmVzdWx0IGFueXdheS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBsb2NrIHRvIGJlIGFjcXVpcmVkLlxuICogQHBhcmFtIGFjcXVpcmVUaW1lb3V0IElmIG5lZ2F0aXZlLCBubyB0aW1lb3V0LiBJZiAwIGFuIGVycm9yIGlzIHRocm93biBpZlxuICogICAgICAgICAgICAgICAgICAgICAgIHRoZSBsb2NrIGNhbid0IGJlIGFjcXVpcmVkIHdpdGhvdXQgd2FpdGluZy4gSWYgcG9zaXRpdmUsIHRoZSBsb2NrIGFjcXVpcmVcbiAqICAgICAgICAgICAgICAgICAgICAgICB3aWxsIHRpbWUgb3V0IGFmdGVyIHNvIG1hbnkgbWlsbGlzZWNvbmRzLiBBbiBlcnJvciBpc1xuICogICAgICAgICAgICAgICAgICAgICAgIGEgdGltZW91dCBpZiBpdCBoYXMgYGlzQWNxdWlyZVRpbWVvdXRgIHNldCB0byB0cnVlLlxuICogQHBhcmFtIGZuIFRoZSBvcGVyYXRpb24gdG8gcnVuIG9uY2UgdGhlIGxvY2sgaXMgYWNxdWlyZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBuYXZpZ2F0b3JMb2NrPFI+KFxuICBuYW1lOiBzdHJpbmcsXG4gIGFjcXVpcmVUaW1lb3V0OiBudW1iZXIsXG4gIGZuOiAoKSA9PiBQcm9taXNlPFI+XG4pOiBQcm9taXNlPFI+IHtcbiAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBhY3F1aXJlIGxvY2snLCBuYW1lLCBhY3F1aXJlVGltZW91dClcbiAgfVxuXG4gIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlcigpXG5cbiAgaWYgKGFjcXVpcmVUaW1lb3V0ID4gMCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2sgYWNxdWlyZSB0aW1lZCBvdXQnLCBuYW1lKVxuICAgICAgfVxuICAgIH0sIGFjcXVpcmVUaW1lb3V0KVxuICB9XG5cbiAgLy8gTUROIGFydGljbGU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Mb2NrTWFuYWdlci9yZXF1ZXN0XG5cbiAgLy8gV3JhcHBpbmcgbmF2aWdhdG9yLmxvY2tzLnJlcXVlc3QoKSB3aXRoIGEgcGxhaW4gUHJvbWlzZSBpcyBkb25lIGFzIHNvbWVcbiAgLy8gbGlicmFyaWVzIGxpa2Ugem9uZS5qcyBwYXRjaCB0aGUgUHJvbWlzZSBvYmplY3QgdG8gdHJhY2sgdGhlIGV4ZWN1dGlvblxuICAvLyBjb250ZXh0LiBIb3dldmVyLCBpdCBhcHBlYXJzIHRoYXQgbW9zdCBicm93c2VycyB1c2UgYW4gaW50ZXJuYWwgcHJvbWlzZVxuICAvLyBpbXBsZW1lbnRhdGlvbiB3aGVuIHVzaW5nIHRoZSBuYXZpZ2F0b3IubG9ja3MucmVxdWVzdCgpIEFQSSBjYXVzaW5nIHRoZW1cbiAgLy8gdG8gbG9zZSBjb250ZXh0IGFuZCBlbWl0IGNvbmZ1c2luZyBsb2cgbWVzc2FnZXMgb3IgYnJlYWsgY2VydGFpbiBmZWF0dXJlcy5cbiAgLy8gVGhpcyB3cmFwcGluZyBpcyBiZWxpZXZlZCB0byBoZWxwIHpvbmUuanMgdHJhY2sgdGhlIGV4ZWN1dGlvbiBjb250ZXh0XG4gIC8vIGJldHRlci5cbiAgcmV0dXJuIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT5cbiAgICBnbG9iYWxUaGlzLm5hdmlnYXRvci5sb2Nrcy5yZXF1ZXN0KFxuICAgICAgbmFtZSxcbiAgICAgIGFjcXVpcmVUaW1lb3V0ID09PSAwXG4gICAgICAgID8ge1xuICAgICAgICAgICAgbW9kZTogJ2V4Y2x1c2l2ZScsXG4gICAgICAgICAgICBpZkF2YWlsYWJsZTogdHJ1ZSxcbiAgICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgbW9kZTogJ2V4Y2x1c2l2ZScsXG4gICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgfSxcbiAgICAgIGFzeW5jIChsb2NrKSA9PiB7XG4gICAgICAgIGlmIChsb2NrKSB7XG4gICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IGFjcXVpcmVkJywgbmFtZSwgbG9jay5uYW1lKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiByZWxlYXNlZCcsIG5hbWUsIGxvY2submFtZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGFjcXVpcmVUaW1lb3V0ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBub3QgaW1tZWRpYXRlbHkgYXZhaWxhYmxlJywgbmFtZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IE5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yKFxuICAgICAgICAgICAgICBgQWNxdWlyaW5nIGFuIGV4Y2x1c2l2ZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgbG9jayBcIiR7bmFtZX1cIiBpbW1lZGlhdGVseSBmYWlsZWRgXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnbG9iYWxUaGlzLm5hdmlnYXRvci5sb2Nrcy5xdWVyeSgpXG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICdAc3VwYWJhc2UvZ290cnVlLWpzOiBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgc3RhdGUnLFxuICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAnICAnKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgJ0BzdXBhYmFzZS9nb3RydWUtanM6IEVycm9yIHdoZW4gcXVlcnlpbmcgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHN0YXRlJyxcbiAgICAgICAgICAgICAgICAgIGVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQnJvd3NlciBpcyBub3QgZm9sbG93aW5nIHRoZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgc3BlYywgaXRcbiAgICAgICAgICAgIC8vIHJldHVybmVkIGEgbnVsbCBsb2NrIHdoZW4gd2UgZGlkbid0IHVzZSBpZkF2YWlsYWJsZS4gU28gd2UgY2FuXG4gICAgICAgICAgICAvLyBwcmV0ZW5kIHRoZSBsb2NrIGlzIGFjcXVpcmVkIGluIHRoZSBuYW1lIG9mIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIC8vIGFuZCB1c2VyIGV4cGVyaWVuY2UgYW5kIGp1c3QgcnVuIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ0BzdXBhYmFzZS9nb3RydWUtanM6IE5hdmlnYXRvciBMb2NrTWFuYWdlciByZXR1cm5lZCBhIG51bGwgbG9jayB3aGVuIHVzaW5nICNyZXF1ZXN0IHdpdGhvdXQgaWZBdmFpbGFibGUgc2V0IHRvIHRydWUsIGl0IGFwcGVhcnMgdGhpcyBicm93c2VyIGlzIG5vdCBmb2xsb3dpbmcgdGhlIExvY2tNYW5hZ2VyIHNwZWMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0xvY2tNYW5hZ2VyL3JlcXVlc3QnXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuICApXG59XG5cbmNvbnN0IFBST0NFU1NfTE9DS1M6IHsgW25hbWU6IHN0cmluZ106IFByb21pc2U8YW55PiB9ID0ge31cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgZ2xvYmFsIGV4Y2x1c2l2ZSBsb2NrIHRoYXQgd29ya3Mgb25seSBpbiB0aGUgY3VycmVudCBwcm9jZXNzLlxuICogVXNlZnVsIGZvciBlbnZpcm9ubWVudHMgbGlrZSBSZWFjdCBOYXRpdmUgb3Igb3RoZXIgbm9uLWJyb3dzZXJcbiAqIHNpbmdsZS1wcm9jZXNzIChpLmUuIG5vIGNvbmNlcHQgb2YgXCJ0YWJzXCIpIGVudmlyb25tZW50cy5cbiAqXG4gKiBVc2Uge0BsaW5rICNuYXZpZ2F0b3JMb2NrfSBpbiBicm93c2VyIGVudmlyb25tZW50cy5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBsb2NrIHRvIGJlIGFjcXVpcmVkLlxuICogQHBhcmFtIGFjcXVpcmVUaW1lb3V0IElmIG5lZ2F0aXZlLCBubyB0aW1lb3V0LiBJZiAwIGFuIGVycm9yIGlzIHRocm93biBpZlxuICogICAgICAgICAgICAgICAgICAgICAgIHRoZSBsb2NrIGNhbid0IGJlIGFjcXVpcmVkIHdpdGhvdXQgd2FpdGluZy4gSWYgcG9zaXRpdmUsIHRoZSBsb2NrIGFjcXVpcmVcbiAqICAgICAgICAgICAgICAgICAgICAgICB3aWxsIHRpbWUgb3V0IGFmdGVyIHNvIG1hbnkgbWlsbGlzZWNvbmRzLiBBbiBlcnJvciBpc1xuICogICAgICAgICAgICAgICAgICAgICAgIGEgdGltZW91dCBpZiBpdCBoYXMgYGlzQWNxdWlyZVRpbWVvdXRgIHNldCB0byB0cnVlLlxuICogQHBhcmFtIGZuIFRoZSBvcGVyYXRpb24gdG8gcnVuIG9uY2UgdGhlIGxvY2sgaXMgYWNxdWlyZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzTG9jazxSPihcbiAgbmFtZTogc3RyaW5nLFxuICBhY3F1aXJlVGltZW91dDogbnVtYmVyLFxuICBmbjogKCkgPT4gUHJvbWlzZTxSPlxuKTogUHJvbWlzZTxSPiB7XG4gIGNvbnN0IHByZXZpb3VzT3BlcmF0aW9uID0gUFJPQ0VTU19MT0NLU1tuYW1lXSA/PyBQcm9taXNlLnJlc29sdmUoKVxuXG4gIGNvbnN0IGN1cnJlbnRPcGVyYXRpb24gPSBQcm9taXNlLnJhY2UoXG4gICAgW1xuICAgICAgcHJldmlvdXNPcGVyYXRpb24uY2F0Y2goKCkgPT4ge1xuICAgICAgICAvLyBpZ25vcmUgZXJyb3Igb2YgcHJldmlvdXMgb3BlcmF0aW9uIHRoYXQgd2UncmUgd2FpdGluZyB0byBmaW5pc2hcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH0pLFxuICAgICAgYWNxdWlyZVRpbWVvdXQgPj0gMFxuICAgICAgICA/IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgbmV3IFByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcihcbiAgICAgICAgICAgICAgICAgIGBBY3F1cmluZyBwcm9jZXNzIGxvY2sgd2l0aCBuYW1lIFwiJHtuYW1lfVwiIHRpbWVkIG91dGBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0sIGFjcXVpcmVUaW1lb3V0KVxuICAgICAgICAgIH0pXG4gICAgICAgIDogbnVsbCxcbiAgICBdLmZpbHRlcigoeCkgPT4geClcbiAgKVxuICAgIC5jYXRjaCgoZTogYW55KSA9PiB7XG4gICAgICBpZiAoZSAmJiBlLmlzQWNxdWlyZVRpbWVvdXQpIHtcbiAgICAgICAgdGhyb3cgZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0pXG4gICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gcHJldmlvdXMgb3BlcmF0aW9ucyBmaW5pc2hlZCBhbmQgd2UgZGlkbid0IGdldCBhIHJhY2Ugb24gdGhlIGFjcXVpcmVcbiAgICAgIC8vIHRpbWVvdXQsIHNvIHRoZSBjdXJyZW50IG9wZXJhdGlvbiBjYW4gZmluYWxseSBzdGFydFxuICAgICAgcmV0dXJuIGF3YWl0IGZuKClcbiAgICB9KVxuXG4gIFBST0NFU1NfTE9DS1NbbmFtZV0gPSBjdXJyZW50T3BlcmF0aW9uLmNhdGNoKGFzeW5jIChlOiBhbnkpID0+IHtcbiAgICBpZiAoZSAmJiBlLmlzQWNxdWlyZVRpbWVvdXQpIHtcbiAgICAgIC8vIGlmIHRoZSBjdXJyZW50IG9wZXJhdGlvbiB0aW1lZCBvdXQsIGl0IGRvZXNuJ3QgbWVhbiB0aGF0IHRoZSBwcmV2aW91c1xuICAgICAgLy8gb3BlcmF0aW9uIGZpbmlzaGVkLCBzbyB3ZSBuZWVkIGNvbnRudWUgd2FpdGluZyBmb3IgaXQgdG8gZmluaXNoXG4gICAgICBhd2FpdCBwcmV2aW91c09wZXJhdGlvblxuXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHRocm93IGVcbiAgfSlcblxuICAvLyBmaW5hbGx5IHdhaXQgZm9yIHRoZSBjdXJyZW50IG9wZXJhdGlvbiB0byBmaW5pc2ggc3VjY2Vzc2Z1bGx5LCB3aXRoIGFuXG4gIC8vIGVycm9yIG9yIHdpdGggYW4gYWNxdWlyZSB0aW1lb3V0IGVycm9yXG4gIHJldHVybiBhd2FpdCBjdXJyZW50T3BlcmF0aW9uXG59XG4iLCAiaW1wb3J0IEdvVHJ1ZUFkbWluQXBpIGZyb20gJy4vR29UcnVlQWRtaW5BcGknXG5pbXBvcnQgeyBERUZBVUxUX0hFQURFUlMsIEVYUElSWV9NQVJHSU4sIEdPVFJVRV9VUkwsIFNUT1JBR0VfS0VZIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJ1xuaW1wb3J0IHtcbiAgQXV0aEVycm9yLFxuICBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IsXG4gIEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcixcbiAgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yLFxuICBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcixcbiAgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IsXG4gIEF1dGhVbmtub3duRXJyb3IsXG4gIGlzQXV0aEFwaUVycm9yLFxuICBpc0F1dGhFcnJvcixcbiAgaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcixcbiAgaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcixcbiAgaXNBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IsXG59IGZyb20gJy4vbGliL2Vycm9ycydcbmltcG9ydCB7XG4gIEZldGNoLFxuICBfcmVxdWVzdCxcbiAgX3Nlc3Npb25SZXNwb25zZSxcbiAgX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkLFxuICBfdXNlclJlc3BvbnNlLFxuICBfc3NvUmVzcG9uc2UsXG59IGZyb20gJy4vbGliL2ZldGNoJ1xuaW1wb3J0IHtcbiAgZGVjb2RlSldUUGF5bG9hZCxcbiAgRGVmZXJyZWQsXG4gIGdldEl0ZW1Bc3luYyxcbiAgaXNCcm93c2VyLFxuICByZW1vdmVJdGVtQXN5bmMsXG4gIHJlc29sdmVGZXRjaCxcbiAgc2V0SXRlbUFzeW5jLFxuICB1dWlkLFxuICByZXRyeWFibGUsXG4gIHNsZWVwLFxuICBzdXBwb3J0c0xvY2FsU3RvcmFnZSxcbiAgcGFyc2VQYXJhbWV0ZXJzRnJvbVVSTCxcbiAgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCxcbn0gZnJvbSAnLi9saWIvaGVscGVycydcbmltcG9ydCB7IGxvY2FsU3RvcmFnZUFkYXB0ZXIsIG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL2xpYi9sb2NhbC1zdG9yYWdlJ1xuaW1wb3J0IHsgcG9seWZpbGxHbG9iYWxUaGlzIH0gZnJvbSAnLi9saWIvcG9seWZpbGxzJ1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vbGliL3ZlcnNpb24nXG5pbXBvcnQgeyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciwgbmF2aWdhdG9yTG9jayB9IGZyb20gJy4vbGliL2xvY2tzJ1xuXG5pbXBvcnQgdHlwZSB7XG4gIEF1dGhDaGFuZ2VFdmVudCxcbiAgQXV0aFJlc3BvbnNlLFxuICBBdXRoUmVzcG9uc2VQYXNzd29yZCxcbiAgQXV0aFRva2VuUmVzcG9uc2UsXG4gIEF1dGhUb2tlblJlc3BvbnNlUGFzc3dvcmQsXG4gIEF1dGhPdHBSZXNwb25zZSxcbiAgQ2FsbFJlZnJlc2hUb2tlblJlc3VsdCxcbiAgR29UcnVlQ2xpZW50T3B0aW9ucyxcbiAgSW5pdGlhbGl6ZVJlc3VsdCxcbiAgT0F1dGhSZXNwb25zZSxcbiAgU1NPUmVzcG9uc2UsXG4gIFByb3ZpZGVyLFxuICBTZXNzaW9uLFxuICBTaWduSW5XaXRoSWRUb2tlbkNyZWRlbnRpYWxzLFxuICBTaWduSW5XaXRoT0F1dGhDcmVkZW50aWFscyxcbiAgU2lnbkluV2l0aFBhc3N3b3JkQ3JlZGVudGlhbHMsXG4gIFNpZ25JbldpdGhQYXNzd29yZGxlc3NDcmVkZW50aWFscyxcbiAgU2lnblVwV2l0aFBhc3N3b3JkQ3JlZGVudGlhbHMsXG4gIFNpZ25JbldpdGhTU08sXG4gIFNpZ25PdXQsXG4gIFN1YnNjcmlwdGlvbixcbiAgU3VwcG9ydGVkU3RvcmFnZSxcbiAgVXNlcixcbiAgVXNlckF0dHJpYnV0ZXMsXG4gIFVzZXJSZXNwb25zZSxcbiAgVmVyaWZ5T3RwUGFyYW1zLFxuICBHb1RydWVNRkFBcGksXG4gIE1GQUVucm9sbFBhcmFtcyxcbiAgQXV0aE1GQUVucm9sbFJlc3BvbnNlLFxuICBNRkFDaGFsbGVuZ2VQYXJhbXMsXG4gIEF1dGhNRkFDaGFsbGVuZ2VSZXNwb25zZSxcbiAgTUZBVW5lbnJvbGxQYXJhbXMsXG4gIEF1dGhNRkFVbmVucm9sbFJlc3BvbnNlLFxuICBNRkFWZXJpZnlQYXJhbXMsXG4gIEF1dGhNRkFWZXJpZnlSZXNwb25zZSxcbiAgQXV0aE1GQUxpc3RGYWN0b3JzUmVzcG9uc2UsXG4gIEFNUkVudHJ5LFxuICBBdXRoTUZBR2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsUmVzcG9uc2UsXG4gIEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbHMsXG4gIEZhY3RvcixcbiAgTUZBQ2hhbGxlbmdlQW5kVmVyaWZ5UGFyYW1zLFxuICBSZXNlbmRQYXJhbXMsXG4gIEF1dGhGbG93VHlwZSxcbiAgTG9ja0Z1bmMsXG4gIFVzZXJJZGVudGl0eSxcbiAgU2lnbkluQW5vbnltb3VzbHlDcmVkZW50aWFscyxcbn0gZnJvbSAnLi9saWIvdHlwZXMnXG5pbXBvcnQge1xuICBNRkFFbnJvbGxUT1RQUGFyYW1zLFxuICBNRkFFbnJvbGxQaG9uZVBhcmFtcyxcbiAgQXV0aE1GQUVucm9sbFRPVFBSZXNwb25zZSxcbiAgQXV0aE1GQUVucm9sbFBob25lUmVzcG9uc2UsXG59IGZyb20gJy4vbGliL2ludGVybmFsLXR5cGVzJ1xuXG5wb2x5ZmlsbEdsb2JhbFRoaXMoKSAvLyBNYWtlIFwiZ2xvYmFsVGhpc1wiIGF2YWlsYWJsZVxuXG5jb25zdCBERUZBVUxUX09QVElPTlM6IE9taXQ8UmVxdWlyZWQ8R29UcnVlQ2xpZW50T3B0aW9ucz4sICdmZXRjaCcgfCAnc3RvcmFnZScgfCAnbG9jayc+ID0ge1xuICB1cmw6IEdPVFJVRV9VUkwsXG4gIHN0b3JhZ2VLZXk6IFNUT1JBR0VfS0VZLFxuICBhdXRvUmVmcmVzaFRva2VuOiB0cnVlLFxuICBwZXJzaXN0U2Vzc2lvbjogdHJ1ZSxcbiAgZGV0ZWN0U2Vzc2lvbkluVXJsOiB0cnVlLFxuICBoZWFkZXJzOiBERUZBVUxUX0hFQURFUlMsXG4gIGZsb3dUeXBlOiAnaW1wbGljaXQnLFxuICBkZWJ1ZzogZmFsc2UsXG4gIGhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXI6IGZhbHNlLFxufVxuXG4vKiogQ3VycmVudCBzZXNzaW9uIHdpbGwgYmUgY2hlY2tlZCBmb3IgcmVmcmVzaCBhdCB0aGlzIGludGVydmFsLiAqL1xuY29uc3QgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT04gPSAzMCAqIDEwMDBcblxuLyoqXG4gKiBBIHRva2VuIHJlZnJlc2ggd2lsbCBiZSBhdHRlbXB0ZWQgdGhpcyBtYW55IHRpY2tzIGJlZm9yZSB0aGUgY3VycmVudCBzZXNzaW9uIGV4cGlyZXMuICovXG5jb25zdCBBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTEQgPSAzXG5cbmFzeW5jIGZ1bmN0aW9uIGxvY2tOb09wPFI+KG5hbWU6IHN0cmluZywgYWNxdWlyZVRpbWVvdXQ6IG51bWJlciwgZm46ICgpID0+IFByb21pc2U8Uj4pOiBQcm9taXNlPFI+IHtcbiAgcmV0dXJuIGF3YWl0IGZuKClcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR29UcnVlQ2xpZW50IHtcbiAgcHJpdmF0ZSBzdGF0aWMgbmV4dEluc3RhbmNlSUQgPSAwXG5cbiAgcHJpdmF0ZSBpbnN0YW5jZUlEOiBudW1iZXJcblxuICAvKipcbiAgICogTmFtZXNwYWNlIGZvciB0aGUgR29UcnVlIGFkbWluIG1ldGhvZHMuXG4gICAqIFRoZXNlIG1ldGhvZHMgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiBhIHRydXN0ZWQgc2VydmVyLXNpZGUgZW52aXJvbm1lbnQuXG4gICAqL1xuICBhZG1pbjogR29UcnVlQWRtaW5BcGlcbiAgLyoqXG4gICAqIE5hbWVzcGFjZSBmb3IgdGhlIE1GQSBtZXRob2RzLlxuICAgKi9cbiAgbWZhOiBHb1RydWVNRkFBcGlcbiAgLyoqXG4gICAqIFRoZSBzdG9yYWdlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoZSB2YWx1ZXMgc2F2ZWQgaW4gbG9jYWxTdG9yYWdlXG4gICAqL1xuICBwcm90ZWN0ZWQgc3RvcmFnZUtleTogc3RyaW5nXG5cbiAgcHJvdGVjdGVkIGZsb3dUeXBlOiBBdXRoRmxvd1R5cGVcblxuICBwcm90ZWN0ZWQgYXV0b1JlZnJlc2hUb2tlbjogYm9vbGVhblxuICBwcm90ZWN0ZWQgcGVyc2lzdFNlc3Npb246IGJvb2xlYW5cbiAgcHJvdGVjdGVkIHN0b3JhZ2U6IFN1cHBvcnRlZFN0b3JhZ2VcbiAgcHJvdGVjdGVkIG1lbW9yeVN0b3JhZ2U6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gfCBudWxsID0gbnVsbFxuICBwcm90ZWN0ZWQgc3RhdGVDaGFuZ2VFbWl0dGVyczogTWFwPHN0cmluZywgU3Vic2NyaXB0aW9uPiA9IG5ldyBNYXAoKVxuICBwcm90ZWN0ZWQgYXV0b1JlZnJlc2hUaWNrZXI6IFJldHVyblR5cGU8dHlwZW9mIHNldEludGVydmFsPiB8IG51bGwgPSBudWxsXG4gIHByb3RlY3RlZCB2aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrOiAoKCkgPT4gUHJvbWlzZTxhbnk+KSB8IG51bGwgPSBudWxsXG4gIHByb3RlY3RlZCByZWZyZXNoaW5nRGVmZXJyZWQ6IERlZmVycmVkPENhbGxSZWZyZXNoVG9rZW5SZXN1bHQ+IHwgbnVsbCA9IG51bGxcbiAgLyoqXG4gICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBhc3luYyBjbGllbnQgaW5pdGlhbGl6YXRpb24uXG4gICAqIFdoZW4gbnVsbCBvciBub3QgeWV0IHJlc29sdmVkIHRoZSBhdXRoIHN0YXRlIGlzIGB1bmtub3duYFxuICAgKiBPbmNlIHJlc29sdmVkIHRoZSB0aGUgYXV0aCBzdGF0ZSBpcyBrbm93biBhbmQgaXQncyBzYXZlIHRvIGNhbGwgYW55IGZ1cnRoZXIgY2xpZW50IG1ldGhvZHMuXG4gICAqIEtlZXAgZXh0cmEgY2FyZSB0byBuZXZlciByZWplY3Qgb3IgdGhyb3cgdW5jYXVnaHQgZXJyb3JzXG4gICAqL1xuICBwcm90ZWN0ZWQgaW5pdGlhbGl6ZVByb21pc2U6IFByb21pc2U8SW5pdGlhbGl6ZVJlc3VsdD4gfCBudWxsID0gbnVsbFxuICBwcm90ZWN0ZWQgZGV0ZWN0U2Vzc2lvbkluVXJsID0gdHJ1ZVxuICBwcm90ZWN0ZWQgdXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIGhlYWRlcnM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuICBwcm90ZWN0ZWQgaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciA9IGZhbHNlXG4gIHByb3RlY3RlZCBzdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gZmFsc2VcbiAgcHJvdGVjdGVkIGZldGNoOiBGZXRjaFxuICBwcm90ZWN0ZWQgbG9jazogTG9ja0Z1bmNcbiAgcHJvdGVjdGVkIGxvY2tBY3F1aXJlZCA9IGZhbHNlXG4gIHByb3RlY3RlZCBwZW5kaW5nSW5Mb2NrOiBQcm9taXNlPGFueT5bXSA9IFtdXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gYnJvYWRjYXN0IHN0YXRlIGNoYW5nZSBldmVudHMgdG8gb3RoZXIgdGFicyBsaXN0ZW5pbmcuXG4gICAqL1xuICBwcm90ZWN0ZWQgYnJvYWRjYXN0Q2hhbm5lbDogQnJvYWRjYXN0Q2hhbm5lbCB8IG51bGwgPSBudWxsXG5cbiAgcHJvdGVjdGVkIGxvZ0RlYnVnTWVzc2FnZXM6IGJvb2xlYW5cbiAgcHJvdGVjdGVkIGxvZ2dlcjogKG1lc3NhZ2U6IHN0cmluZywgLi4uYXJnczogYW55W10pID0+IHZvaWQgPSBjb25zb2xlLmxvZ1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgY2xpZW50IGZvciB1c2UgaW4gdGhlIGJyb3dzZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBHb1RydWVDbGllbnRPcHRpb25zKSB7XG4gICAgdGhpcy5pbnN0YW5jZUlEID0gR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEXG4gICAgR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEICs9IDFcblxuICAgIGlmICh0aGlzLmluc3RhbmNlSUQgPiAwICYmIGlzQnJvd3NlcigpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdNdWx0aXBsZSBHb1RydWVDbGllbnQgaW5zdGFuY2VzIGRldGVjdGVkIGluIHRoZSBzYW1lIGJyb3dzZXIgY29udGV4dC4gSXQgaXMgbm90IGFuIGVycm9yLCBidXQgdGhpcyBzaG91bGQgYmUgYXZvaWRlZCBhcyBpdCBtYXkgcHJvZHVjZSB1bmRlZmluZWQgYmVoYXZpb3Igd2hlbiB1c2VkIGNvbmN1cnJlbnRseSB1bmRlciB0aGUgc2FtZSBzdG9yYWdlIGtleS4nXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7IC4uLkRFRkFVTFRfT1BUSU9OUywgLi4ub3B0aW9ucyB9XG5cbiAgICB0aGlzLmxvZ0RlYnVnTWVzc2FnZXMgPSAhIXNldHRpbmdzLmRlYnVnXG4gICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5kZWJ1ZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5sb2dnZXIgPSBzZXR0aW5ncy5kZWJ1Z1xuICAgIH1cblxuICAgIHRoaXMucGVyc2lzdFNlc3Npb24gPSBzZXR0aW5ncy5wZXJzaXN0U2Vzc2lvblxuICAgIHRoaXMuc3RvcmFnZUtleSA9IHNldHRpbmdzLnN0b3JhZ2VLZXlcbiAgICB0aGlzLmF1dG9SZWZyZXNoVG9rZW4gPSBzZXR0aW5ncy5hdXRvUmVmcmVzaFRva2VuXG4gICAgdGhpcy5hZG1pbiA9IG5ldyBHb1RydWVBZG1pbkFwaSh7XG4gICAgICB1cmw6IHNldHRpbmdzLnVybCxcbiAgICAgIGhlYWRlcnM6IHNldHRpbmdzLmhlYWRlcnMsXG4gICAgICBmZXRjaDogc2V0dGluZ3MuZmV0Y2gsXG4gICAgfSlcblxuICAgIHRoaXMudXJsID0gc2V0dGluZ3MudXJsXG4gICAgdGhpcy5oZWFkZXJzID0gc2V0dGluZ3MuaGVhZGVyc1xuICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goc2V0dGluZ3MuZmV0Y2gpXG4gICAgdGhpcy5sb2NrID0gc2V0dGluZ3MubG9jayB8fCBsb2NrTm9PcFxuICAgIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsID0gc2V0dGluZ3MuZGV0ZWN0U2Vzc2lvbkluVXJsXG4gICAgdGhpcy5mbG93VHlwZSA9IHNldHRpbmdzLmZsb3dUeXBlXG4gICAgdGhpcy5oYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyID0gc2V0dGluZ3MuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlclxuXG4gICAgaWYgKHNldHRpbmdzLmxvY2spIHtcbiAgICAgIHRoaXMubG9jayA9IHNldHRpbmdzLmxvY2tcbiAgICB9IGVsc2UgaWYgKGlzQnJvd3NlcigpICYmIGdsb2JhbFRoaXM/Lm5hdmlnYXRvcj8ubG9ja3MpIHtcbiAgICAgIHRoaXMubG9jayA9IG5hdmlnYXRvckxvY2tcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2NrID0gbG9ja05vT3BcbiAgICB9XG5cbiAgICB0aGlzLm1mYSA9IHtcbiAgICAgIHZlcmlmeTogdGhpcy5fdmVyaWZ5LmJpbmQodGhpcyksXG4gICAgICBlbnJvbGw6IHRoaXMuX2Vucm9sbC5iaW5kKHRoaXMpLFxuICAgICAgdW5lbnJvbGw6IHRoaXMuX3VuZW5yb2xsLmJpbmQodGhpcyksXG4gICAgICBjaGFsbGVuZ2U6IHRoaXMuX2NoYWxsZW5nZS5iaW5kKHRoaXMpLFxuICAgICAgbGlzdEZhY3RvcnM6IHRoaXMuX2xpc3RGYWN0b3JzLmJpbmQodGhpcyksXG4gICAgICBjaGFsbGVuZ2VBbmRWZXJpZnk6IHRoaXMuX2NoYWxsZW5nZUFuZFZlcmlmeS5iaW5kKHRoaXMpLFxuICAgICAgZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsOiB0aGlzLl9nZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwuYmluZCh0aGlzKSxcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wZXJzaXN0U2Vzc2lvbikge1xuICAgICAgaWYgKHNldHRpbmdzLnN0b3JhZ2UpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc2V0dGluZ3Muc3RvcmFnZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzTG9jYWxTdG9yYWdlKCkpIHtcbiAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBsb2NhbFN0b3JhZ2VBZGFwdGVyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0ge31cbiAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHRoaXMubWVtb3J5U3RvcmFnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lbW9yeVN0b3JhZ2UgPSB7fVxuICAgICAgdGhpcy5zdG9yYWdlID0gbWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlcih0aGlzLm1lbW9yeVN0b3JhZ2UpXG4gICAgfVxuXG4gICAgaWYgKGlzQnJvd3NlcigpICYmIGdsb2JhbFRoaXMuQnJvYWRjYXN0Q2hhbm5lbCAmJiB0aGlzLnBlcnNpc3RTZXNzaW9uICYmIHRoaXMuc3RvcmFnZUtleSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbmV3IGdsb2JhbFRoaXMuQnJvYWRjYXN0Q2hhbm5lbCh0aGlzLnN0b3JhZ2VLZXkpXG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnRmFpbGVkIHRvIGNyZWF0ZSBhIG5ldyBCcm9hZGNhc3RDaGFubmVsLCBtdWx0aS10YWIgc3RhdGUgY2hhbmdlcyB3aWxsIG5vdCBiZSBhdmFpbGFibGUnLFxuICAgICAgICAgIGVcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWw/LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ3JlY2VpdmVkIGJyb2FkY2FzdCBub3RpZmljYXRpb24gZnJvbSBvdGhlciB0YWIgb3IgY2xpZW50JywgZXZlbnQpXG5cbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoZXZlbnQuZGF0YS5ldmVudCwgZXZlbnQuZGF0YS5zZXNzaW9uLCBmYWxzZSkgLy8gYnJvYWRjYXN0ID0gZmFsc2Ugc28gd2UgZG9uJ3QgZ2V0IGFuIGVuZGxlc3MgbG9vcCBvZiBtZXNzYWdlc1xuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmluaXRpYWxpemUoKVxuICB9XG5cbiAgcHJpdmF0ZSBfZGVidWcoLi4uYXJnczogYW55W10pOiBHb1RydWVDbGllbnQge1xuICAgIGlmICh0aGlzLmxvZ0RlYnVnTWVzc2FnZXMpIHtcbiAgICAgIHRoaXMubG9nZ2VyKFxuICAgICAgICBgR29UcnVlQ2xpZW50QCR7dGhpcy5pbnN0YW5jZUlEfSAoJHt2ZXJzaW9ufSkgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YCxcbiAgICAgICAgLi4uYXJnc1xuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNsaWVudCBzZXNzaW9uIGVpdGhlciBmcm9tIHRoZSB1cmwgb3IgZnJvbSBzdG9yYWdlLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuIGluc3RhbnRpYXRpbmcgdGhlIGNsaWVudCwgYnV0IHNob3VsZCBhbHNvIGJlIGNhbGxlZFxuICAgKiBtYW51YWxseSB3aGVuIGNoZWNraW5nIGZvciBhbiBlcnJvciBmcm9tIGFuIGF1dGggcmVkaXJlY3QgKG9hdXRoLCBtYWdpY2xpbmssIHBhc3N3b3JkIHJlY292ZXJ5LCBldGMpLlxuICAgKi9cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPEluaXRpYWxpemVSZXN1bHQ+IHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXplUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcbiAgICB9XG5cbiAgICB0aGlzLmluaXRpYWxpemVQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5faW5pdGlhbGl6ZSgpXG4gICAgICB9KVxuICAgIH0pKClcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogSU1QT1JUQU5UOlxuICAgKiAxLiBOZXZlciB0aHJvdyBpbiB0aGlzIG1ldGhvZCwgYXMgaXQgaXMgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAqIDIuIE5ldmVyIHJldHVybiBhIHNlc3Npb24gZnJvbSB0aGlzIG1ldGhvZCBhcyBpdCB3b3VsZCBiZSBjYWNoZWQgb3ZlclxuICAgKiAgICB0aGUgd2hvbGUgbGlmZXRpbWUgb2YgdGhlIGNsaWVudFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfaW5pdGlhbGl6ZSgpOiBQcm9taXNlPEluaXRpYWxpemVSZXN1bHQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyYW1zID0gcGFyc2VQYXJhbWV0ZXJzRnJvbVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICAgIGxldCBjYWxsYmFja1VybFR5cGUgPSAnbm9uZSdcbiAgICAgIGlmICh0aGlzLl9pc0ltcGxpY2l0R3JhbnRDYWxsYmFjayhwYXJhbXMpKSB7XG4gICAgICAgIGNhbGxiYWNrVXJsVHlwZSA9ICdpbXBsaWNpdCdcbiAgICAgIH0gZWxzZSBpZiAoYXdhaXQgdGhpcy5faXNQS0NFQ2FsbGJhY2socGFyYW1zKSkge1xuICAgICAgICBjYWxsYmFja1VybFR5cGUgPSAncGtjZSdcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBdHRlbXB0IHRvIGdldCB0aGUgc2Vzc2lvbiBmcm9tIHRoZSBVUkwgb25seSBpZiB0aGVzZSBjb25kaXRpb25zIGFyZSBmdWxmaWxsZWRcbiAgICAgICAqXG4gICAgICAgKiBOb3RlOiBJZiB0aGUgVVJMIGlzbid0IG9uZSBvZiB0aGUgY2FsbGJhY2sgdXJsIHR5cGVzIChpbXBsaWNpdCBvciBwa2NlKSxcbiAgICAgICAqIHRoZW4gdGhlcmUgY291bGQgYmUgYW4gZXhpc3Rpbmcgc2Vzc2lvbiBzbyB3ZSBkb24ndCB3YW50IHRvIHByZW1hdHVyZWx5IHJlbW92ZSBpdFxuICAgICAgICovXG4gICAgICBpZiAoaXNCcm93c2VyKCkgJiYgdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgJiYgY2FsbGJhY2tVcmxUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0U2Vzc2lvbkZyb21VUkwocGFyYW1zLCBjYWxsYmFja1VybFR5cGUpXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdlcnJvciBkZXRlY3Rpbmcgc2Vzc2lvbiBmcm9tIFVSTCcsIGVycm9yKVxuXG4gICAgICAgICAgaWYgKGlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gZXJyb3IuZGV0YWlscz8uY29kZVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBlcnJvckNvZGUgPT09ICdpZGVudGl0eV9hbHJlYWR5X2V4aXN0cycgfHxcbiAgICAgICAgICAgICAgZXJyb3JDb2RlID09PSAnaWRlbnRpdHlfbm90X2ZvdW5kJyB8fFxuICAgICAgICAgICAgICBlcnJvckNvZGUgPT09ICdzaW5nbGVfaWRlbnRpdHlfbm90X2RlbGV0YWJsZSdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZmFpbGVkIGxvZ2luIGF0dGVtcHQgdmlhIHVybCxcbiAgICAgICAgICAvLyByZW1vdmUgb2xkIHNlc3Npb24gYXMgaW4gdmVyaWZ5T3RwLCBzaWduVXAgYW5kIHNpZ25JbldpdGgqXG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG5cbiAgICAgICAgICByZXR1cm4geyBlcnJvciB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHNlc3Npb24sIHJlZGlyZWN0VHlwZSB9ID0gZGF0YVxuXG4gICAgICAgIHRoaXMuX2RlYnVnKFxuICAgICAgICAgICcjX2luaXRpYWxpemUoKScsXG4gICAgICAgICAgJ2RldGVjdGVkIHNlc3Npb24gaW4gVVJMJyxcbiAgICAgICAgICBzZXNzaW9uLFxuICAgICAgICAgICdyZWRpcmVjdCB0eXBlJyxcbiAgICAgICAgICByZWRpcmVjdFR5cGVcbiAgICAgICAgKVxuXG4gICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pXG5cbiAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgaWYgKHJlZGlyZWN0VHlwZSA9PT0gJ3JlY292ZXJ5Jykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1BBU1NXT1JEX1JFQ09WRVJZJywgc2Vzc2lvbilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pXG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKVxuXG4gICAgICAgIHJldHVybiB7IGVycm9yOiBudWxsIH1cbiAgICAgIH1cbiAgICAgIC8vIG5vIGxvZ2luIGF0dGVtcHQgdmlhIGNhbGxiYWNrIHVybCB0cnkgdG8gcmVjb3ZlciBzZXNzaW9uIGZyb20gc3RvcmFnZVxuICAgICAgYXdhaXQgdGhpcy5fcmVjb3ZlckFuZFJlZnJlc2goKVxuICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGR1cmluZyBpbml0aWFsaXphdGlvbicsIGVycm9yKSxcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgdGhpcy5faGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpXG4gICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBhbm9ueW1vdXMgdXNlci5cbiAgICpcbiAgICogQHJldHVybnMgQSBzZXNzaW9uIHdoZXJlIHRoZSBpc19hbm9ueW1vdXMgY2xhaW0gaW4gdGhlIGFjY2VzcyB0b2tlbiBKV1Qgc2V0IHRvIHRydWVcbiAgICovXG4gIGFzeW5jIHNpZ25JbkFub255bW91c2x5KGNyZWRlbnRpYWxzPzogU2lnbkluQW5vbnltb3VzbHlDcmVkZW50aWFscyk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgZGF0YTogY3JlZGVudGlhbHM/Lm9wdGlvbnM/LmRhdGEgPz8ge30sXG4gICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogY3JlZGVudGlhbHM/Lm9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICB9LFxuICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgIH0pXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXNcblxuICAgICAgaWYgKGVycm9yIHx8ICFkYXRhKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwgPSBkYXRhLnNlc3Npb25cbiAgICAgIGNvbnN0IHVzZXI6IFVzZXIgfCBudWxsID0gZGF0YS51c2VyXG5cbiAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbilcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHVzZXIuXG4gICAqXG4gICAqIEJlIGF3YXJlIHRoYXQgaWYgYSB1c2VyIGFjY291bnQgZXhpc3RzIGluIHRoZSBzeXN0ZW0geW91IG1heSBnZXQgYmFjayBhblxuICAgKiBlcnJvciBtZXNzYWdlIHRoYXQgYXR0ZW1wdHMgdG8gaGlkZSB0aGlzIGluZm9ybWF0aW9uIGZyb20gdGhlIHVzZXIuXG4gICAqIFRoaXMgbWV0aG9kIGhhcyBzdXBwb3J0IGZvciBQS0NFIHZpYSBlbWFpbCBzaWdudXBzLiBUaGUgUEtDRSBmbG93IGNhbm5vdCBiZSB1c2VkIHdoZW4gYXV0b2NvbmZpcm0gaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHJldHVybnMgQSBsb2dnZWQtaW4gc2Vzc2lvbiBpZiB0aGUgc2VydmVyIGhhcyBcImF1dG9jb25maXJtXCIgT05cbiAgICogQHJldHVybnMgQSB1c2VyIGlmIHRoZSBzZXJ2ZXIgaGFzIFwiYXV0b2NvbmZpcm1cIiBPRkZcbiAgICovXG4gIGFzeW5jIHNpZ25VcChjcmVkZW50aWFsczogU2lnblVwV2l0aFBhc3N3b3JkQ3JlZGVudGlhbHMpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgcmVzOiBBdXRoUmVzcG9uc2VcbiAgICAgIGlmICgnZW1haWwnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFsc1xuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2Q6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICA7W2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZUtleVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnM/LmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgZGF0YTogb3B0aW9ucz8uZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCB7IHBob25lLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHNcbiAgICAgICAgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc2lnbnVwYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgZGF0YTogb3B0aW9ucz8uZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIGNoYW5uZWw6IG9wdGlvbnM/LmNoYW5uZWwgPz8gJ3NtcycsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcihcbiAgICAgICAgICAnWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gZW1haWwgb3IgcGhvbmUgbnVtYmVyIGFuZCBhIHBhc3N3b3JkJ1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc1xuXG4gICAgICBpZiAoZXJyb3IgfHwgIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlc3Npb246IFNlc3Npb24gfCBudWxsID0gZGF0YS5zZXNzaW9uXG4gICAgICBjb25zdCB1c2VyOiBVc2VyIHwgbnVsbCA9IGRhdGEudXNlclxuXG4gICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbilcbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9nIGluIGFuIGV4aXN0aW5nIHVzZXIgd2l0aCBhbiBlbWFpbCBhbmQgcGFzc3dvcmQgb3IgcGhvbmUgYW5kIHBhc3N3b3JkLlxuICAgKlxuICAgKiBCZSBhd2FyZSB0aGF0IHlvdSBtYXkgZ2V0IGJhY2sgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IHdpbGwgbm90IGRpc3Rpbmd1aXNoXG4gICAqIGJldHdlZW4gdGhlIGNhc2VzIHdoZXJlIHRoZSBhY2NvdW50IGRvZXMgbm90IGV4aXN0IG9yIHRoYXQgdGhlXG4gICAqIGVtYWlsL3Bob25lIGFuZCBwYXNzd29yZCBjb21iaW5hdGlvbiBpcyB3cm9uZyBvciB0aGF0IHRoZSBhY2NvdW50IGNhbiBvbmx5XG4gICAqIGJlIGFjY2Vzc2VkIHZpYSBzb2NpYWwgbG9naW4uXG4gICAqL1xuICBhc3luYyBzaWduSW5XaXRoUGFzc3dvcmQoXG4gICAgY3JlZGVudGlhbHM6IFNpZ25JbldpdGhQYXNzd29yZENyZWRlbnRpYWxzXG4gICk6IFByb21pc2U8QXV0aFRva2VuUmVzcG9uc2VQYXNzd29yZD4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgcmVzOiBBdXRoUmVzcG9uc2VQYXNzd29yZFxuICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBlbWFpbCwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGFzc3dvcmRgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBwaG9uZSwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGFzc3dvcmRgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKFxuICAgICAgICAgICdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH0gZWxzZSBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCkgfVxuICAgICAgfVxuICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pXG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdXNlcjogZGF0YS51c2VyLFxuICAgICAgICAgIHNlc3Npb246IGRhdGEuc2Vzc2lvbixcbiAgICAgICAgICAuLi4oZGF0YS53ZWFrX3Bhc3N3b3JkID8geyB3ZWFrUGFzc3dvcmQ6IGRhdGEud2Vha19wYXNzd29yZCB9IDogbnVsbCksXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yLFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgaW4gYW4gZXhpc3RpbmcgdXNlciB2aWEgYSB0aGlyZC1wYXJ0eSBwcm92aWRlci5cbiAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgdGhlIFBLQ0UgZmxvdy5cbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhPQXV0aChjcmVkZW50aWFsczogU2lnbkluV2l0aE9BdXRoQ3JlZGVudGlhbHMpOiBQcm9taXNlPE9BdXRoUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5faGFuZGxlUHJvdmlkZXJTaWduSW4oY3JlZGVudGlhbHMucHJvdmlkZXIsIHtcbiAgICAgIHJlZGlyZWN0VG86IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnJlZGlyZWN0VG8sXG4gICAgICBzY29wZXM6IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnNjb3BlcyxcbiAgICAgIHF1ZXJ5UGFyYW1zOiBjcmVkZW50aWFscy5vcHRpb25zPy5xdWVyeVBhcmFtcyxcbiAgICAgIHNraXBCcm93c2VyUmVkaXJlY3Q6IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnNraXBCcm93c2VyUmVkaXJlY3QsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgaW4gYW4gZXhpc3RpbmcgdXNlciBieSBleGNoYW5naW5nIGFuIEF1dGggQ29kZSBpc3N1ZWQgZHVyaW5nIHRoZSBQS0NFIGZsb3cuXG4gICAqL1xuICBhc3luYyBleGNoYW5nZUNvZGVGb3JTZXNzaW9uKGF1dGhDb2RlOiBzdHJpbmcpOiBQcm9taXNlPEF1dGhUb2tlblJlc3BvbnNlPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihhdXRoQ29kZSlcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihhdXRoQ29kZTogc3RyaW5nKTogUHJvbWlzZTxcbiAgICB8IHtcbiAgICAgICAgZGF0YTogeyBzZXNzaW9uOiBTZXNzaW9uOyB1c2VyOiBVc2VyOyByZWRpcmVjdFR5cGU6IHN0cmluZyB8IG51bGwgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwgeyBkYXRhOiB7IHNlc3Npb246IG51bGw7IHVzZXI6IG51bGw7IHJlZGlyZWN0VHlwZTogbnVsbCB9OyBlcnJvcjogQXV0aEVycm9yIH1cbiAgPiB7XG4gICAgY29uc3Qgc3RvcmFnZUl0ZW0gPSBhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKVxuICAgIGNvbnN0IFtjb2RlVmVyaWZpZXIsIHJlZGlyZWN0VHlwZV0gPSAoKHN0b3JhZ2VJdGVtID8/ICcnKSBhcyBzdHJpbmcpLnNwbGl0KCcvJylcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdChcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgJ1BPU1QnLFxuICAgICAgICBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1wa2NlYCxcbiAgICAgICAge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBhdXRoX2NvZGU6IGF1dGhDb2RlLFxuICAgICAgICAgICAgY29kZV92ZXJpZmllcjogY29kZVZlcmlmaWVyLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LFxuICAgICAgICAgIGVycm9yOiBuZXcgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKSxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pXG4gICAgICB9XG4gICAgICByZXR1cm4geyBkYXRhOiB7IC4uLmRhdGEsIHJlZGlyZWN0VHlwZTogcmVkaXJlY3RUeXBlID8/IG51bGwgfSwgZXJyb3IgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgcmVkaXJlY3RUeXBlOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHNpZ25pbmcgaW4gd2l0aCBhbiBPSURDIElEIHRva2VuLiBUaGUgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgdXNlZFxuICAgKiBzaG91bGQgYmUgZW5hYmxlZCBhbmQgY29uZmlndXJlZC5cbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhJZFRva2VuKGNyZWRlbnRpYWxzOiBTaWduSW5XaXRoSWRUb2tlbkNyZWRlbnRpYWxzKTogUHJvbWlzZTxBdXRoVG9rZW5SZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IG9wdGlvbnMsIHByb3ZpZGVyLCB0b2tlbiwgYWNjZXNzX3Rva2VuLCBub25jZSB9ID0gY3JlZGVudGlhbHNcblxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1pZF90b2tlbmAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgaWRfdG9rZW46IHRva2VuLFxuICAgICAgICAgIGFjY2Vzc190b2tlbixcbiAgICAgICAgICBub25jZSxcbiAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgfSxcbiAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXNcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfSBlbHNlIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSxcbiAgICAgICAgICBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCksXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIG1hZ2ljbGluayBvciBhIG9uZS10aW1lIHBhc3N3b3JkIChPVFApLlxuICAgKlxuICAgKiBJZiB0aGUgYHt7IC5Db25maXJtYXRpb25VUkwgfX1gIHZhcmlhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgZW1haWwgdGVtcGxhdGUsIGEgbWFnaWNsaW5rIHdpbGwgYmUgc2VudC5cbiAgICogSWYgdGhlIGB7eyAuVG9rZW4gfX1gIHZhcmlhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgZW1haWwgdGVtcGxhdGUsIGFuIE9UUCB3aWxsIGJlIHNlbnQuXG4gICAqIElmIHlvdSdyZSB1c2luZyBwaG9uZSBzaWduLWlucywgb25seSBhbiBPVFAgd2lsbCBiZSBzZW50LiBZb3Ugd29uJ3QgYmUgYWJsZSB0byBzZW5kIGEgbWFnaWNsaW5rIGZvciBwaG9uZSBzaWduLWlucy5cbiAgICpcbiAgICogQmUgYXdhcmUgdGhhdCB5b3UgbWF5IGdldCBiYWNrIGFuIGVycm9yIG1lc3NhZ2UgdGhhdCB3aWxsIG5vdCBkaXN0aW5ndWlzaFxuICAgKiBiZXR3ZWVuIHRoZSBjYXNlcyB3aGVyZSB0aGUgYWNjb3VudCBkb2VzIG5vdCBleGlzdCBvciwgdGhhdCB0aGUgYWNjb3VudFxuICAgKiBjYW4gb25seSBiZSBhY2Nlc3NlZCB2aWEgc29jaWFsIGxvZ2luLlxuICAgKlxuICAgKiBEbyBub3RlIHRoYXQgeW91IHdpbGwgbmVlZCB0byBjb25maWd1cmUgYSBXaGF0c2FwcCBzZW5kZXIgb24gVHdpbGlvXG4gICAqIGlmIHlvdSBhcmUgdXNpbmcgcGhvbmUgc2lnbiBpbiB3aXRoIHRoZSAnd2hhdHNhcHAnIGNoYW5uZWwuIFRoZSB3aGF0c2FwcFxuICAgKiBjaGFubmVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gb3RoZXIgcHJvdmlkZXJzXG4gICAqIGF0IHRoaXMgdGltZS5cbiAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgUEtDRSB3aGVuIGFuIGVtYWlsIGlzIHBhc3NlZC5cbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhPdHAoY3JlZGVudGlhbHM6IFNpZ25JbldpdGhQYXNzd29yZGxlc3NDcmVkZW50aWFscyk6IFByb21pc2U8QXV0aE90cFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICgnZW1haWwnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgZW1haWwsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZDogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgIDtbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlS2V5XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L290cGAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICBkYXRhOiBvcHRpb25zPy5kYXRhID8/IHt9LFxuICAgICAgICAgICAgY3JlYXRlX3VzZXI6IG9wdGlvbnM/LnNob3VsZENyZWF0ZVVzZXIgPz8gdHJ1ZSxcbiAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnM/LmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zPy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCB7IHBob25lLCBvcHRpb25zIH0gPSBjcmVkZW50aWFsc1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9vdHBgLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgZGF0YTogb3B0aW9ucz8uZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIGNyZWF0ZV91c2VyOiBvcHRpb25zPy5zaG91bGRDcmVhdGVVc2VyID8/IHRydWUsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgIGNoYW5uZWw6IG9wdGlvbnM/LmNoYW5uZWwgPz8gJ3NtcycsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsLCBtZXNzYWdlSWQ6IGRhdGE/Lm1lc3NhZ2VfaWQgfSwgZXJyb3IgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcignWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gZW1haWwgb3IgcGhvbmUgbnVtYmVyLicpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9nIGluIGEgdXNlciBnaXZlbiBhIFVzZXIgc3VwcGxpZWQgT1RQIG9yIFRva2VuSGFzaCByZWNlaXZlZCB0aHJvdWdoIG1vYmlsZSBvciBlbWFpbC5cbiAgICovXG4gIGFzeW5jIHZlcmlmeU90cChwYXJhbXM6IFZlcmlmeU90cFBhcmFtcyk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCByZWRpcmVjdFRvOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgICAgIGxldCBjYXB0Y2hhVG9rZW46IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICAgICAgaWYgKCdvcHRpb25zJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgcmVkaXJlY3RUbyA9IHBhcmFtcy5vcHRpb25zPy5yZWRpcmVjdFRvXG4gICAgICAgIGNhcHRjaGFUb2tlbiA9IHBhcmFtcy5vcHRpb25zPy5jYXB0Y2hhVG9rZW5cbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3ZlcmlmeWAsIHtcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IGNhcHRjaGFUb2tlbiB9LFxuICAgICAgICB9LFxuICAgICAgICByZWRpcmVjdFRvLFxuICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgIH0pXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCBvbiB0b2tlbiB2ZXJpZmljYXRpb24uJylcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwgPSBkYXRhLnNlc3Npb25cbiAgICAgIGNvbnN0IHVzZXI6IFVzZXIgPSBkYXRhLnVzZXJcblxuICAgICAgaWYgKHNlc3Npb24/LmFjY2Vzc190b2tlbikge1xuICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uIGFzIFNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKFxuICAgICAgICAgIHBhcmFtcy50eXBlID09ICdyZWNvdmVyeScgPyAnUEFTU1dPUkRfUkVDT1ZFUlknIDogJ1NJR05FRF9JTicsXG4gICAgICAgICAgc2Vzc2lvblxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgYSBzaW5nbGUtc2lnbiBvbiB1c2luZyBhbiBlbnRlcnByaXNlIElkZW50aXR5IFByb3ZpZGVyLiBBXG4gICAqIHN1Y2Nlc3NmdWwgU1NPIGF0dGVtcHQgd2lsbCByZWRpcmVjdCB0aGUgY3VycmVudCBwYWdlIHRvIHRoZSBpZGVudGl0eVxuICAgKiBwcm92aWRlciBhdXRob3JpemF0aW9uIHBhZ2UuIFRoZSByZWRpcmVjdCBVUkwgaXMgaW1wbGVtZW50YXRpb24gYW5kIFNTT1xuICAgKiBwcm90b2NvbCBzcGVjaWZpYy5cbiAgICpcbiAgICogWW91IGNhbiB1c2UgaXQgYnkgcHJvdmlkaW5nIGEgU1NPIGRvbWFpbi4gVHlwaWNhbGx5IHlvdSBjYW4gZXh0cmFjdCB0aGlzXG4gICAqIGRvbWFpbiBieSBhc2tpbmcgdXNlcnMgZm9yIHRoZWlyIGVtYWlsIGFkZHJlc3MuIElmIHRoaXMgZG9tYWluIGlzXG4gICAqIHJlZ2lzdGVyZWQgb24gdGhlIEF1dGggaW5zdGFuY2UgdGhlIHJlZGlyZWN0IHdpbGwgdXNlIHRoYXQgb3JnYW5pemF0aW9uJ3NcbiAgICogY3VycmVudGx5IGFjdGl2ZSBTU08gSWRlbnRpdHkgUHJvdmlkZXIgZm9yIHRoZSBsb2dpbi5cbiAgICpcbiAgICogSWYgeW91IGhhdmUgYnVpbHQgYW4gb3JnYW5pemF0aW9uLXNwZWNpZmljIGxvZ2luIHBhZ2UsIHlvdSBjYW4gdXNlIHRoZVxuICAgKiBvcmdhbml6YXRpb24ncyBTU08gSWRlbnRpdHkgUHJvdmlkZXIgVVVJRCBkaXJlY3RseSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgc2lnbkluV2l0aFNTTyhwYXJhbXM6IFNpZ25JbldpdGhTU08pOiBQcm9taXNlPFNTT1Jlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb2RlQ2hhbGxlbmdlOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2Q6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgIDtbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKFxuICAgICAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgICAgICB0aGlzLnN0b3JhZ2VLZXlcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc3NvYCwge1xuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgLi4uKCdwcm92aWRlcklkJyBpbiBwYXJhbXMgPyB7IHByb3ZpZGVyX2lkOiBwYXJhbXMucHJvdmlkZXJJZCB9IDogbnVsbCksXG4gICAgICAgICAgLi4uKCdkb21haW4nIGluIHBhcmFtcyA/IHsgZG9tYWluOiBwYXJhbXMuZG9tYWluIH0gOiBudWxsKSxcbiAgICAgICAgICByZWRpcmVjdF90bzogcGFyYW1zLm9wdGlvbnM/LnJlZGlyZWN0VG8gPz8gdW5kZWZpbmVkLFxuICAgICAgICAgIC4uLihwYXJhbXM/Lm9wdGlvbnM/LmNhcHRjaGFUb2tlblxuICAgICAgICAgICAgPyB7IGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IHBhcmFtcy5vcHRpb25zLmNhcHRjaGFUb2tlbiB9IH1cbiAgICAgICAgICAgIDogbnVsbCksXG4gICAgICAgICAgc2tpcF9odHRwX3JlZGlyZWN0OiB0cnVlLCAvLyBmZXRjaCBkb2VzIG5vdCBoYW5kbGUgcmVkaXJlY3RzXG4gICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kLFxuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHhmb3JtOiBfc3NvUmVzcG9uc2UsXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVhdXRoZW50aWNhdGlvbiBPVFAgdG8gdGhlIHVzZXIncyBlbWFpbCBvciBwaG9uZSBudW1iZXIuXG4gICAqIFJlcXVpcmVzIHRoZSB1c2VyIHRvIGJlIHNpZ25lZC1pbi5cbiAgICovXG4gIGFzeW5jIHJlYXV0aGVudGljYXRlKCk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVhdXRoZW50aWNhdGUoKVxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9yZWF1dGhlbnRpY2F0ZSgpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkYXRhOiB7IHNlc3Npb24gfSxcbiAgICAgICAgICBlcnJvcjogc2Vzc2lvbkVycm9yLFxuICAgICAgICB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHRocm93IHNlc3Npb25FcnJvclxuICAgICAgICBpZiAoIXNlc3Npb24pIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG5cbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9yZWF1dGhlbnRpY2F0ZWAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2VuZHMgYW4gZXhpc3Rpbmcgc2lnbnVwIGNvbmZpcm1hdGlvbiBlbWFpbCwgZW1haWwgY2hhbmdlIGVtYWlsLCBTTVMgT1RQIG9yIHBob25lIGNoYW5nZSBPVFAuXG4gICAqL1xuICBhc3luYyByZXNlbmQoY3JlZGVudGlhbHM6IFJlc2VuZFBhcmFtcyk6IFByb21pc2U8QXV0aE90cFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy51cmx9L3Jlc2VuZGBcbiAgICAgIGlmICgnZW1haWwnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgZW1haWwsIHR5cGUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgZW5kcG9pbnQsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucz8uY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zPy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9IGVsc2UgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBwaG9uZSwgdHlwZSwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHNcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBlbmRwb2ludCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zPy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIG1lc3NhZ2VJZDogZGF0YT8ubWVzc2FnZV9pZCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKFxuICAgICAgICAnWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gZW1haWwgb3IgcGhvbmUgbnVtYmVyIGFuZCBhIHR5cGUnXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNlc3Npb24sIHJlZnJlc2hpbmcgaXQgaWYgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiBUaGUgc2Vzc2lvbiByZXR1cm5lZCBjYW4gYmUgbnVsbCBpZiB0aGUgc2Vzc2lvbiBpcyBub3QgZGV0ZWN0ZWQgd2hpY2ggY2FuIGhhcHBlbiBpbiB0aGUgZXZlbnQgYSB1c2VyIGlzIG5vdCBzaWduZWQtaW4gb3IgaGFzIGxvZ2dlZCBvdXQuXG4gICAqXG4gICAqICoqSU1QT1JUQU5UOioqIFRoaXMgbWV0aG9kIGxvYWRzIHZhbHVlcyBkaXJlY3RseSBmcm9tIHRoZSBzdG9yYWdlIGF0dGFjaGVkXG4gICAqIHRvIHRoZSBjbGllbnQuIElmIHRoYXQgc3RvcmFnZSBpcyBiYXNlZCBvbiByZXF1ZXN0IGNvb2tpZXMgZm9yIGV4YW1wbGUsXG4gICAqIHRoZSB2YWx1ZXMgaW4gaXQgbWF5IG5vdCBiZSBhdXRoZW50aWMgYW5kIHRoZXJlZm9yZSBpdCdzIHN0cm9uZ2x5IGFkdmlzZWRcbiAgICogYWdhaW5zdCB1c2luZyB0aGlzIG1ldGhvZCBhbmQgaXRzIHJlc3VsdHMgaW4gc3VjaCBjaXJjdW1zdGFuY2VzLiBBIHdhcm5pbmdcbiAgICogd2lsbCBiZSBlbWl0dGVkIGlmIHRoaXMgaXMgZGV0ZWN0ZWQuIFVzZSB7QGxpbmsgI2dldFVzZXIoKX0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFNlc3Npb24oKSB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLyoqXG4gICAqIEFjcXVpcmVzIGEgZ2xvYmFsIGxvY2sgYmFzZWQgb24gdGhlIHN0b3JhZ2Uga2V5LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfYWNxdWlyZUxvY2s8Uj4oYWNxdWlyZVRpbWVvdXQ6IG51bWJlciwgZm46ICgpID0+IFByb21pc2U8Uj4pOiBQcm9taXNlPFI+IHtcbiAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdiZWdpbicsIGFjcXVpcmVUaW1lb3V0KVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5wZW5kaW5nSW5Mb2NrLmxlbmd0aFxuICAgICAgICAgID8gdGhpcy5wZW5kaW5nSW5Mb2NrW3RoaXMucGVuZGluZ0luTG9jay5sZW5ndGggLSAxXVxuICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKClcblxuICAgICAgICBjb25zdCByZXN1bHQgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IGxhc3RcbiAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKVxuICAgICAgICB9KSgpXG5cbiAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnB1c2goXG4gICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IHJlc3VsdFxuICAgICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICAgIC8vIHdlIGp1c3QgY2FyZSBpZiBpdCBmaW5pc2hlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKClcbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9jayhgbG9jazoke3RoaXMuc3RvcmFnZUtleX1gLCBhY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdsb2NrIGFjcXVpcmVkIGZvciBzdG9yYWdlIGtleScsIHRoaXMuc3RvcmFnZUtleSlcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMubG9ja0FjcXVpcmVkID0gdHJ1ZVxuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4oKVxuXG4gICAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnB1c2goXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdFxuICAgICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGNhcmUgaWYgaXQgZmluaXNoZWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKVxuICAgICAgICAgIClcblxuICAgICAgICAgIGF3YWl0IHJlc3VsdFxuXG4gICAgICAgICAgLy8ga2VlcCBkcmFpbmluZyB0aGUgcXVldWUgdW50aWwgdGhlcmUncyBub3RoaW5nIHRvIHdhaXQgb25cbiAgICAgICAgICB3aGlsZSAodGhpcy5wZW5kaW5nSW5Mb2NrLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgd2FpdE9uID0gWy4uLnRoaXMucGVuZGluZ0luTG9ja11cblxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwod2FpdE9uKVxuXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2suc3BsaWNlKDAsIHdhaXRPbi5sZW5ndGgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3VsdFxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2xvY2sgcmVsZWFzZWQgZm9yIHN0b3JhZ2Uga2V5JywgdGhpcy5zdG9yYWdlS2V5KVxuXG4gICAgICAgICAgdGhpcy5sb2NrQWNxdWlyZWQgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgaW5zdGVhZCBvZiB7QGxpbmsgI2dldFNlc3Npb259IGluc2lkZSB0aGUgbGlicmFyeS4gSXQgaXNcbiAgICogc2VtYW50aWNhbGx5IHVzdWFsbHkgd2hhdCB5b3Ugd2FudCwgYXMgZ2V0dGluZyBhIHNlc3Npb24gaW52b2x2ZXMgc29tZVxuICAgKiBwcm9jZXNzaW5nIGFmdGVyd2FyZHMgdGhhdCByZXF1aXJlcyBvbmx5IG9uZSBjbGllbnQgb3BlcmF0aW5nIG9uIHRoZVxuICAgKiBzZXNzaW9uIGF0IG9uY2UgYWNyb3NzIG11bHRpcGxlIHRhYnMgb3IgcHJvY2Vzc2VzLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfdXNlU2Vzc2lvbjxSPihcbiAgICBmbjogKFxuICAgICAgcmVzdWx0OlxuICAgICAgICB8IHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc2Vzc2lvbjogU2Vzc2lvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIHwge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBzZXNzaW9uOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcjogQXV0aEVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB8IHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc2Vzc2lvbjogbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICB9XG4gICAgKSA9PiBQcm9taXNlPFI+XG4gICk6IFByb21pc2U8Uj4ge1xuICAgIHRoaXMuX2RlYnVnKCcjX3VzZVNlc3Npb24nLCAnYmVnaW4nKVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIHRoZSB1c2Ugb2YgX19sb2FkU2Vzc2lvbiBoZXJlIGlzIHRoZSBvbmx5IGNvcnJlY3QgdXNlIG9mIHRoZSBmdW5jdGlvbiFcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX19sb2FkU2Vzc2lvbigpXG5cbiAgICAgIHJldHVybiBhd2FpdCBmbihyZXN1bHQpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2RlYnVnKCcjX3VzZVNlc3Npb24nLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTkVWRVIgVVNFIERJUkVDVExZIVxuICAgKlxuICAgKiBBbHdheXMgdXNlIHtAbGluayAjX3VzZVNlc3Npb259LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfX2xvYWRTZXNzaW9uKCk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzZXNzaW9uOiBTZXNzaW9uXG4gICAgICAgIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgICAgfVxuICAgICAgICBlcnJvcjogQXV0aEVycm9yXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzZXNzaW9uOiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH1cbiAgPiB7XG4gICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAnYmVnaW4nKVxuXG4gICAgaWYgKCF0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAndXNlZCBvdXRzaWRlIG9mIGFuIGFjcXVpcmVkIGxvY2shJywgbmV3IEVycm9yKCkuc3RhY2spXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBjdXJyZW50U2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwgPSBudWxsXG5cbiAgICAgIGNvbnN0IG1heWJlU2Vzc2lvbiA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSlcblxuICAgICAgdGhpcy5fZGVidWcoJyNnZXRTZXNzaW9uKCknLCAnc2Vzc2lvbiBmcm9tIHN0b3JhZ2UnLCBtYXliZVNlc3Npb24pXG5cbiAgICAgIGlmIChtYXliZVNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRTZXNzaW9uKG1heWJlU2Vzc2lvbikpIHtcbiAgICAgICAgICBjdXJyZW50U2Vzc2lvbiA9IG1heWJlU2Vzc2lvblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlIGlzIG5vdCB2YWxpZCcpXG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwgfSwgZXJyb3I6IG51bGwgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBoYXNFeHBpcmVkID0gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdFxuICAgICAgICA/IGN1cnJlbnRTZXNzaW9uLmV4cGlyZXNfYXQgPD0gRGF0ZS5ub3coKSAvIDEwMDBcbiAgICAgICAgOiBmYWxzZVxuXG4gICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgJyNfX2xvYWRTZXNzaW9uKCknLFxuICAgICAgICBgc2Vzc2lvbiBoYXMke2hhc0V4cGlyZWQgPyAnJyA6ICcgbm90J30gZXhwaXJlZGAsXG4gICAgICAgICdleHBpcmVzX2F0JyxcbiAgICAgICAgY3VycmVudFNlc3Npb24uZXhwaXJlc19hdFxuICAgICAgKVxuXG4gICAgICBpZiAoIWhhc0V4cGlyZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5pc1NlcnZlcikge1xuICAgICAgICAgIGxldCBzdXBwcmVzc1dhcm5pbmcgPSB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmdcbiAgICAgICAgICBjb25zdCBwcm94eVNlc3Npb246IFNlc3Npb24gPSBuZXcgUHJveHkoY3VycmVudFNlc3Npb24sIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldDogYW55LCBwcm9wOiBzdHJpbmcsIHJlY2VpdmVyOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFzdXBwcmVzc1dhcm5pbmcgJiYgcHJvcCA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBzaG93IHdhcm5pbmcgd2hlbiB0aGUgdXNlciBvYmplY3QgaXMgYmVpbmcgYWNjZXNzZWQgZnJvbSB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgJ1VzaW5nIHRoZSB1c2VyIG9iamVjdCBhcyByZXR1cm5lZCBmcm9tIHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpIG9yIGZyb20gc29tZSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKCkgZXZlbnRzIGNvdWxkIGJlIGluc2VjdXJlISBUaGlzIHZhbHVlIGNvbWVzIGRpcmVjdGx5IGZyb20gdGhlIHN0b3JhZ2UgbWVkaXVtICh1c3VhbGx5IGNvb2tpZXMgb24gdGhlIHNlcnZlcikgYW5kIG1heSBub3QgYmUgYXV0aGVudGljLiBVc2Ugc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCkgaW5zdGVhZCB3aGljaCBhdXRoZW50aWNhdGVzIHRoZSBkYXRhIGJ5IGNvbnRhY3RpbmcgdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLidcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgc3VwcHJlc3NXYXJuaW5nID0gdHJ1ZSAvLyBrZWVwcyB0aGlzIHByb3h5IGluc3RhbmNlIGZyb20gbG9nZ2luZyBhZGRpdGlvbmFsIHdhcm5pbmdzXG4gICAgICAgICAgICAgICAgdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gdHJ1ZSAvLyBrZWVwcyB0aGlzIGNsaWVudCdzIGZ1dHVyZSBwcm94eSBpbnN0YW5jZXMgZnJvbSB3YXJuaW5nXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pXG4gICAgICAgICAgY3VycmVudFNlc3Npb24gPSBwcm94eVNlc3Npb25cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogY3VycmVudFNlc3Npb24gfSwgZXJyb3I6IG51bGwgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCB1c2VyIGRldGFpbHMgaWYgdGhlcmUgaXMgYW4gZXhpc3Rpbmcgc2Vzc2lvbi4gVGhpcyBtZXRob2RcbiAgICogcGVyZm9ybXMgYSBuZXR3b3JrIHJlcXVlc3QgdG8gdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLCBzbyB0aGUgcmV0dXJuZWRcbiAgICogdmFsdWUgaXMgYXV0aGVudGljIGFuZCBjYW4gYmUgdXNlZCB0byBiYXNlIGF1dGhvcml6YXRpb24gcnVsZXMgb24uXG4gICAqXG4gICAqIEBwYXJhbSBqd3QgVGFrZXMgaW4gYW4gb3B0aW9uYWwgYWNjZXNzIHRva2VuIEpXVC4gSWYgbm8gSldUIGlzIHByb3ZpZGVkLCB0aGUgSldUIGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyB1c2VkLlxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlcihqd3Q/OiBzdHJpbmcpOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIGlmIChqd3QpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKGp3dClcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldFVzZXIoKVxuICAgIH0pXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9nZXRVc2VyKGp3dD86IHN0cmluZyk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChqd3QpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vdXNlcmAsIHtcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgand0OiBqd3QsXG4gICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm5zIGFuIGVycm9yIGlmIHRoZXJlIGlzIG5vIGFjY2Vzc190b2tlbiBvciBjdXN0b20gYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgICAgaWYgKCFkYXRhLnNlc3Npb24/LmFjY2Vzc190b2tlbiAmJiAhdGhpcy5oYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yOiBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBqd3Q6IGRhdGEuc2Vzc2lvbj8uYWNjZXNzX3Rva2VuID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgaWYgKGlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgLy8gSldUIGNvbnRhaW5zIGEgYHNlc3Npb25faWRgIHdoaWNoIGRvZXMgbm90IGNvcnJlc3BvbmQgdG8gYW4gYWN0aXZlXG4gICAgICAgICAgLy8gc2Vzc2lvbiBpbiB0aGUgZGF0YWJhc2UsIGluZGljYXRpbmcgdGhlIHVzZXIgaXMgc2lnbmVkIG91dC5cblxuICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKVxuICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHVzZXIgZGF0YSBmb3IgYSBsb2dnZWQgaW4gdXNlci5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVVzZXIoXG4gICAgYXR0cmlidXRlczogVXNlckF0dHJpYnV0ZXMsXG4gICAgb3B0aW9uczoge1xuICAgICAgZW1haWxSZWRpcmVjdFRvPzogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgfSA9IHt9XG4gICk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXBkYXRlVXNlcihhdHRyaWJ1dGVzLCBvcHRpb25zKVxuICAgIH0pXG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX3VwZGF0ZVVzZXIoXG4gICAgYXR0cmlidXRlczogVXNlckF0dHJpYnV0ZXMsXG4gICAgb3B0aW9uczoge1xuICAgICAgZW1haWxSZWRpcmVjdFRvPzogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgfSA9IHt9XG4gICk6IFByb21pc2U8VXNlclJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBzZXNzaW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlc3Npb25EYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlc3Npb246IFNlc3Npb24gPSBzZXNzaW9uRGF0YS5zZXNzaW9uXG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZDogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJyAmJiBhdHRyaWJ1dGVzLmVtYWlsICE9IG51bGwpIHtcbiAgICAgICAgICA7W2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZUtleVxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3I6IHVzZXJFcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BVVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zPy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLFxuICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgfSlcbiAgICAgICAgaWYgKHVzZXJFcnJvcikgdGhyb3cgdXNlckVycm9yXG4gICAgICAgIHNlc3Npb24udXNlciA9IGRhdGEudXNlciBhcyBVc2VyXG4gICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdVU0VSX1VQREFURUQnLCBzZXNzaW9uKVxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IHNlc3Npb24udXNlciB9LCBlcnJvcjogbnVsbCB9XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZXMgYSBKV1QgKHdpdGhvdXQgcGVyZm9ybWluZyBhbnkgdmFsaWRhdGlvbikuXG4gICAqL1xuICBwcml2YXRlIF9kZWNvZGVKV1Qoand0OiBzdHJpbmcpOiB7XG4gICAgZXhwPzogbnVtYmVyXG4gICAgYWFsPzogQXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVscyB8IG51bGxcbiAgICBhbXI/OiBBTVJFbnRyeVtdIHwgbnVsbFxuICB9IHtcbiAgICByZXR1cm4gZGVjb2RlSldUUGF5bG9hZChqd3QpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2Vzc2lvbiBkYXRhIGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbi4gSWYgdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyBleHBpcmVkLCBzZXRTZXNzaW9uIHdpbGwgdGFrZSBjYXJlIG9mIHJlZnJlc2hpbmcgaXQgdG8gb2J0YWluIGEgbmV3IHNlc3Npb24uXG4gICAqIElmIHRoZSByZWZyZXNoIHRva2VuIG9yIGFjY2VzcyB0b2tlbiBpbiB0aGUgY3VycmVudCBzZXNzaW9uIGlzIGludmFsaWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgKiBAcGFyYW0gY3VycmVudFNlc3Npb24gVGhlIGN1cnJlbnQgc2Vzc2lvbiB0aGF0IG1pbmltYWxseSBjb250YWlucyBhbiBhY2Nlc3MgdG9rZW4gYW5kIHJlZnJlc2ggdG9rZW4uXG4gICAqL1xuICBhc3luYyBzZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uOiB7XG4gICAgYWNjZXNzX3Rva2VuOiBzdHJpbmdcbiAgICByZWZyZXNoX3Rva2VuOiBzdHJpbmdcbiAgfSk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2V0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbilcbiAgICB9KVxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9zZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uOiB7XG4gICAgYWNjZXNzX3Rva2VuOiBzdHJpbmdcbiAgICByZWZyZXNoX3Rva2VuOiBzdHJpbmdcbiAgfSk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuIHx8ICFjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRpbWVOb3cgPSBEYXRlLm5vdygpIC8gMTAwMFxuICAgICAgbGV0IGV4cGlyZXNBdCA9IHRpbWVOb3dcbiAgICAgIGxldCBoYXNFeHBpcmVkID0gdHJ1ZVxuICAgICAgbGV0IHNlc3Npb246IFNlc3Npb24gfCBudWxsID0gbnVsbFxuICAgICAgY29uc3QgcGF5bG9hZCA9IGRlY29kZUpXVFBheWxvYWQoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKVxuICAgICAgaWYgKHBheWxvYWQuZXhwKSB7XG4gICAgICAgIGV4cGlyZXNBdCA9IHBheWxvYWQuZXhwXG4gICAgICAgIGhhc0V4cGlyZWQgPSBleHBpcmVzQXQgPD0gdGltZU5vd1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzRXhwaXJlZCkge1xuICAgICAgICBjb25zdCB7IHNlc3Npb246IHJlZnJlc2hlZFNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKFxuICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW5cbiAgICAgICAgKVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVmcmVzaGVkU2Vzc2lvbikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9XG4gICAgICAgIH1cbiAgICAgICAgc2Vzc2lvbiA9IHJlZnJlc2hlZFNlc3Npb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICB9XG4gICAgICAgIHNlc3Npb24gPSB7XG4gICAgICAgICAgYWNjZXNzX3Rva2VuOiBjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgcmVmcmVzaF90b2tlbjogY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbixcbiAgICAgICAgICB1c2VyOiBkYXRhLnVzZXIsXG4gICAgICAgICAgdG9rZW5fdHlwZTogJ2JlYXJlcicsXG4gICAgICAgICAgZXhwaXJlc19pbjogZXhwaXJlc0F0IC0gdGltZU5vdyxcbiAgICAgICAgICBleHBpcmVzX2F0OiBleHBpcmVzQXQsXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbilcbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwsIHVzZXI6IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHNlc3Npb24sIHJlZ2FyZGxlc3Mgb2YgZXhwaXJ5IHN0YXR1cy5cbiAgICogVGFrZXMgaW4gYW4gb3B0aW9uYWwgY3VycmVudCBzZXNzaW9uLiBJZiBub3QgcGFzc2VkIGluLCB0aGVuIHJlZnJlc2hTZXNzaW9uKCkgd2lsbCBhdHRlbXB0IHRvIHJldHJpZXZlIGl0IGZyb20gZ2V0U2Vzc2lvbigpLlxuICAgKiBJZiB0aGUgY3VycmVudCBzZXNzaW9uJ3MgcmVmcmVzaCB0b2tlbiBpcyBpbnZhbGlkLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICogQHBhcmFtIGN1cnJlbnRTZXNzaW9uIFRoZSBjdXJyZW50IHNlc3Npb24uIElmIHBhc3NlZCBpbiwgaXQgbXVzdCBjb250YWluIGEgcmVmcmVzaCB0b2tlbi5cbiAgICovXG4gIGFzeW5jIHJlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uPzogeyByZWZyZXNoX3Rva2VuOiBzdHJpbmcgfSk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pXG4gICAgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24/OiB7XG4gICAgcmVmcmVzaF90b2tlbjogc3RyaW5nXG4gIH0pOiBQcm9taXNlPEF1dGhSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmICghY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHRcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFNlc3Npb24gPSBkYXRhLnNlc3Npb24gPz8gdW5kZWZpbmVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uPy5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc2Vzc2lvbiwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbilcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IG51bGwgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBzZXNzaW9uLnVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzZXNzaW9uIGRhdGEgZnJvbSBhIFVSTCBzdHJpbmdcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2dldFNlc3Npb25Gcm9tVVJMKFxuICAgIHBhcmFtczogeyBbcGFyYW1ldGVyOiBzdHJpbmddOiBzdHJpbmcgfSxcbiAgICBjYWxsYmFja1VybFR5cGU6IHN0cmluZ1xuICApOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7IHNlc3Npb246IFNlc3Npb247IHJlZGlyZWN0VHlwZTogc3RyaW5nIHwgbnVsbCB9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbDsgcmVkaXJlY3RUeXBlOiBudWxsIH07IGVycm9yOiBBdXRoRXJyb3IgfVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFpc0Jyb3dzZXIoKSkgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm8gYnJvd3NlciBkZXRlY3RlZC4nKVxuXG4gICAgICAvLyBJZiB0aGVyZSdzIGFuIGVycm9yIGluIHRoZSBVUkwsIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgZmxvdyBpdCBpcywgd2UganVzdCByZXR1cm4gdGhlIGVycm9yLlxuICAgICAgaWYgKHBhcmFtcy5lcnJvciB8fCBwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24gfHwgcGFyYW1zLmVycm9yX2NvZGUpIHtcbiAgICAgICAgLy8gVGhlIGVycm9yIGNsYXNzIHJldHVybmVkIGltcGxpZXMgdGhhdCB0aGUgcmVkaXJlY3QgaXMgZnJvbSBhbiBpbXBsaWNpdCBncmFudCBmbG93XG4gICAgICAgIC8vIGJ1dCBpdCBjb3VsZCBhbHNvIGJlIGZyb20gYSByZWRpcmVjdCBlcnJvciBmcm9tIGEgUEtDRSBmbG93LlxuICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKFxuICAgICAgICAgIHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbiB8fCAnRXJyb3IgaW4gVVJMIHdpdGggdW5zcGVjaWZpZWQgZXJyb3JfZGVzY3JpcHRpb24nLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yOiBwYXJhbXMuZXJyb3IgfHwgJ3Vuc3BlY2lmaWVkX2Vycm9yJyxcbiAgICAgICAgICAgIGNvZGU6IHBhcmFtcy5lcnJvcl9jb2RlIHx8ICd1bnNwZWNpZmllZF9jb2RlJyxcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2tzIGZvciBtaXNtYXRjaGVzIGJldHdlZW4gdGhlIGZsb3dUeXBlIGluaXRpYWxpc2VkIGluIHRoZSBjbGllbnQgYW5kIHRoZSBVUkwgcGFyYW1ldGVyc1xuICAgICAgc3dpdGNoIChjYWxsYmFja1VybFR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW1wbGljaXQnOlxuICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IoJ05vdCBhIHZhbGlkIFBLQ0UgZmxvdyB1cmwuJylcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAncGtjZSc6XG4gICAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdpbXBsaWNpdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vdCBhIHZhbGlkIGltcGxpY2l0IGdyYW50IGZsb3cgdXJsLicpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIHRoZXJlJ3Mgbm8gbWlzbWF0Y2ggc28gd2UgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gU2luY2UgdGhpcyBpcyBhIHJlZGlyZWN0IGZvciBQS0NFLCB3ZSBhdHRlbXB0IHRvIHJldHJpZXZlIHRoZSBjb2RlIGZyb20gdGhlIFVSTCBmb3IgdGhlIGNvZGUgZXhjaGFuZ2VcbiAgICAgIGlmIChjYWxsYmFja1VybFR5cGUgPT09ICdwa2NlJykge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnYmVnaW4nLCAnaXMgUEtDRSBmbG93JywgdHJ1ZSlcbiAgICAgICAgaWYgKCFwYXJhbXMuY29kZSkgdGhyb3cgbmV3IEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcignTm8gY29kZSBkZXRlY3RlZC4nKVxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9leGNoYW5nZUNvZGVGb3JTZXNzaW9uKHBhcmFtcy5jb2RlKVxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoJ2NvZGUnKVxuXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh3aW5kb3cuaGlzdG9yeS5zdGF0ZSwgJycsIHVybC50b1N0cmluZygpKVxuXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogZGF0YS5zZXNzaW9uLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3I6IG51bGwgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHByb3ZpZGVyX3Rva2VuLFxuICAgICAgICBwcm92aWRlcl9yZWZyZXNoX3Rva2VuLFxuICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgIHJlZnJlc2hfdG9rZW4sXG4gICAgICAgIGV4cGlyZXNfaW4sXG4gICAgICAgIGV4cGlyZXNfYXQsXG4gICAgICAgIHRva2VuX3R5cGUsXG4gICAgICB9ID0gcGFyYW1zXG5cbiAgICAgIGlmICghYWNjZXNzX3Rva2VuIHx8ICFleHBpcmVzX2luIHx8ICFyZWZyZXNoX3Rva2VuIHx8ICF0b2tlbl90eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vIHNlc3Npb24gZGVmaW5lZCBpbiBVUkwnKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB0aW1lTm93ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMClcbiAgICAgIGNvbnN0IGV4cGlyZXNJbiA9IHBhcnNlSW50KGV4cGlyZXNfaW4pXG4gICAgICBsZXQgZXhwaXJlc0F0ID0gdGltZU5vdyArIGV4cGlyZXNJblxuXG4gICAgICBpZiAoZXhwaXJlc19hdCkge1xuICAgICAgICBleHBpcmVzQXQgPSBwYXJzZUludChleHBpcmVzX2F0KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBhY3R1YWxseUV4cGlyZXNJbiA9IGV4cGlyZXNBdCAtIHRpbWVOb3dcbiAgICAgIGlmIChhY3R1YWxseUV4cGlyZXNJbiAqIDEwMDAgPD0gQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT04pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBAc3VwYWJhc2UvZ290cnVlLWpzOiBTZXNzaW9uIGFzIHJldHJpZXZlZCBmcm9tIFVSTCBleHBpcmVzIGluICR7YWN0dWFsbHlFeHBpcmVzSW59cywgc2hvdWxkIGhhdmUgYmVlbiBjbG9zZXIgdG8gJHtleHBpcmVzSW59c2BcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpc3N1ZWRBdCA9IGV4cGlyZXNBdCAtIGV4cGlyZXNJblxuICAgICAgaWYgKHRpbWVOb3cgLSBpc3N1ZWRBdCA+PSAxMjApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdAc3VwYWJhc2UvZ290cnVlLWpzOiBTZXNzaW9uIGFzIHJldHJpZXZlZCBmcm9tIFVSTCB3YXMgaXNzdWVkIG92ZXIgMTIwcyBhZ28sIFVSTCBjb3VsZCBiZSBzdGFsZScsXG4gICAgICAgICAgaXNzdWVkQXQsXG4gICAgICAgICAgZXhwaXJlc0F0LFxuICAgICAgICAgIHRpbWVOb3dcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIGlmICh0aW1lTm93IC0gaXNzdWVkQXQgPCAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnQHN1cGFiYXNlL2dvdHJ1ZS1qczogU2Vzc2lvbiBhcyByZXRyaWV2ZWQgZnJvbSBVUkwgd2FzIGlzc3VlZCBpbiB0aGUgZnV0dXJlPyBDaGVjayB0aGUgZGV2aWNlIGNsb2NrIGZvciBza2V3JyxcbiAgICAgICAgICBpc3N1ZWRBdCxcbiAgICAgICAgICBleHBpcmVzQXQsXG4gICAgICAgICAgdGltZU5vd1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoYWNjZXNzX3Rva2VuKVxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBjb25zdCBzZXNzaW9uOiBTZXNzaW9uID0ge1xuICAgICAgICBwcm92aWRlcl90b2tlbixcbiAgICAgICAgcHJvdmlkZXJfcmVmcmVzaF90b2tlbixcbiAgICAgICAgYWNjZXNzX3Rva2VuLFxuICAgICAgICBleHBpcmVzX2luOiBleHBpcmVzSW4sXG4gICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCxcbiAgICAgICAgcmVmcmVzaF90b2tlbixcbiAgICAgICAgdG9rZW5fdHlwZSxcbiAgICAgICAgdXNlcjogZGF0YS51c2VyLFxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdG9rZW5zIGZyb20gVVJMXG4gICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICcnXG4gICAgICB0aGlzLl9kZWJ1ZygnI19nZXRTZXNzaW9uRnJvbVVSTCgpJywgJ2NsZWFyaW5nIHdpbmRvdy5sb2NhdGlvbi5oYXNoJylcblxuICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uLCByZWRpcmVjdFR5cGU6IHBhcmFtcy50eXBlIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBVUkwgY29udGFpbnMgcGFyYW1ldGVycyBnaXZlbiBieSBhbiBpbXBsaWNpdCBvYXV0aCBncmFudCBmbG93IChodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjc0OS5odG1sI3NlY3Rpb24tNC4yKVxuICAgKi9cbiAgcHJpdmF0ZSBfaXNJbXBsaWNpdEdyYW50Q2FsbGJhY2socGFyYW1zOiB7IFtwYXJhbWV0ZXI6IHN0cmluZ106IHN0cmluZyB9KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIEJvb2xlYW4ocGFyYW1zLmFjY2Vzc190b2tlbiB8fCBwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24pXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IFVSTCBhbmQgYmFja2luZyBzdG9yYWdlIGNvbnRhaW4gcGFyYW1ldGVycyBnaXZlbiBieSBhIFBLQ0UgZmxvd1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfaXNQS0NFQ2FsbGJhY2socGFyYW1zOiB7IFtwYXJhbWV0ZXI6IHN0cmluZ106IHN0cmluZyB9KTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgY3VycmVudFN0b3JhZ2VDb250ZW50ID0gYXdhaXQgZ2V0SXRlbUFzeW5jKFxuICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYFxuICAgIClcblxuICAgIHJldHVybiAhIShwYXJhbXMuY29kZSAmJiBjdXJyZW50U3RvcmFnZUNvbnRlbnQpXG4gIH1cblxuICAvKipcbiAgICogSW5zaWRlIGEgYnJvd3NlciBjb250ZXh0LCBgc2lnbk91dCgpYCB3aWxsIHJlbW92ZSB0aGUgbG9nZ2VkIGluIHVzZXIgZnJvbSB0aGUgYnJvd3NlciBzZXNzaW9uIGFuZCBsb2cgdGhlbSBvdXQgLSByZW1vdmluZyBhbGwgaXRlbXMgZnJvbSBsb2NhbHN0b3JhZ2UgYW5kIHRoZW4gdHJpZ2dlciBhIGBcIlNJR05FRF9PVVRcImAgZXZlbnQuXG4gICAqXG4gICAqIEZvciBzZXJ2ZXItc2lkZSBtYW5hZ2VtZW50LCB5b3UgY2FuIHJldm9rZSBhbGwgcmVmcmVzaCB0b2tlbnMgZm9yIGEgdXNlciBieSBwYXNzaW5nIGEgdXNlcidzIEpXVCB0aHJvdWdoIHRvIGBhdXRoLmFwaS5zaWduT3V0KEpXVDogc3RyaW5nKWAuXG4gICAqIFRoZXJlIGlzIG5vIHdheSB0byByZXZva2UgYSB1c2VyJ3MgYWNjZXNzIHRva2VuIGp3dCB1bnRpbCBpdCBleHBpcmVzLiBJdCBpcyByZWNvbW1lbmRlZCB0byBzZXQgYSBzaG9ydGVyIGV4cGlyeSBvbiB0aGUgand0IGZvciB0aGlzIHJlYXNvbi5cbiAgICpcbiAgICogSWYgdXNpbmcgYG90aGVyc2Agc2NvcGUsIG5vIGBTSUdORURfT1VUYCBldmVudCBpcyBmaXJlZCFcbiAgICovXG4gIGFzeW5jIHNpZ25PdXQob3B0aW9uczogU2lnbk91dCA9IHsgc2NvcGU6ICdnbG9iYWwnIH0pOiBQcm9taXNlPHsgZXJyb3I6IEF1dGhFcnJvciB8IG51bGwgfT4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NpZ25PdXQob3B0aW9ucylcbiAgICB9KVxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9zaWduT3V0KFxuICAgIHsgc2NvcGUgfTogU2lnbk91dCA9IHsgc2NvcGU6ICdnbG9iYWwnIH1cbiAgKTogUHJvbWlzZTx7IGVycm9yOiBBdXRoRXJyb3IgfCBudWxsIH0+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdFxuICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogc2Vzc2lvbkVycm9yIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gZGF0YS5zZXNzaW9uPy5hY2Nlc3NfdG9rZW5cbiAgICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCB0aGlzLmFkbWluLnNpZ25PdXQoYWNjZXNzVG9rZW4sIHNjb3BlKVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBpZ25vcmUgNDA0cyBzaW5jZSB1c2VyIG1pZ2h0IG5vdCBleGlzdCBhbnltb3JlXG4gICAgICAgICAgLy8gaWdub3JlIDQwMXMgc2luY2UgYW4gaW52YWxpZCBvciBleHBpcmVkIEpXVCBzaG91bGQgc2lnbiBvdXQgdGhlIGN1cnJlbnQgc2Vzc2lvblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgIGlzQXV0aEFwaUVycm9yKGVycm9yKSAmJlxuICAgICAgICAgICAgICAoZXJyb3Iuc3RhdHVzID09PSA0MDQgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDEgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDMpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvciB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2NvcGUgIT09ICdvdGhlcnMnKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKVxuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmVjZWl2ZSBhIG5vdGlmaWNhdGlvbiBldmVyeSB0aW1lIGFuIGF1dGggZXZlbnQgaGFwcGVucy5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIGFuIGF1dGggZXZlbnQgaGFwcGVucy5cbiAgICovXG4gIG9uQXV0aFN0YXRlQ2hhbmdlKFxuICAgIGNhbGxiYWNrOiAoZXZlbnQ6IEF1dGhDaGFuZ2VFdmVudCwgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+XG4gICk6IHtcbiAgICBkYXRhOiB7IHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uIH1cbiAgfSB7XG4gICAgY29uc3QgaWQ6IHN0cmluZyA9IHV1aWQoKVxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0ge1xuICAgICAgaWQsXG4gICAgICBjYWxsYmFjayxcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjdW5zdWJzY3JpYmUoKScsICdzdGF0ZSBjaGFuZ2UgY2FsbGJhY2sgd2l0aCBpZCByZW1vdmVkJywgaWQpXG5cbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLmRlbGV0ZShpZClcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgdGhpcy5fZGVidWcoJyNvbkF1dGhTdGF0ZUNoYW5nZSgpJywgJ3JlZ2lzdGVyZWQgY2FsbGJhY2sgd2l0aCBpZCcsIGlkKVxuXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLnNldChpZCwgc3Vic2NyaXB0aW9uKVxuICAgIDsoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZVxuXG4gICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbWl0SW5pdGlhbFNlc3Npb24oaWQpXG4gICAgICB9KVxuICAgIH0pKClcblxuICAgIHJldHVybiB7IGRhdGE6IHsgc3Vic2NyaXB0aW9uIH0gfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfZW1pdEluaXRpYWxTZXNzaW9uKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGF0YTogeyBzZXNzaW9uIH0sXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICAgIGF3YWl0IHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5nZXQoaWQpPy5jYWxsYmFjaygnSU5JVElBTF9TRVNTSU9OJywgc2Vzc2lvbilcbiAgICAgICAgdGhpcy5fZGVidWcoJ0lOSVRJQUxfU0VTU0lPTicsICdjYWxsYmFjayBpZCcsIGlkLCAnc2Vzc2lvbicsIHNlc3Npb24pXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLmdldChpZCk/LmNhbGxiYWNrKCdJTklUSUFMX1NFU1NJT04nLCBudWxsKVxuICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdlcnJvcicsIGVycilcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBhc3N3b3JkIHJlc2V0IHJlcXVlc3QgdG8gYW4gZW1haWwgYWRkcmVzcy4gVGhpcyBtZXRob2Qgc3VwcG9ydHMgdGhlIFBLQ0UgZmxvdy5cbiAgICpcbiAgICogQHBhcmFtIGVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSB1c2VyLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIFRoZSBVUkwgdG8gc2VuZCB0aGUgdXNlciB0byBhZnRlciB0aGV5IGNsaWNrIHRoZSBwYXNzd29yZCByZXNldCBsaW5rLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5jYXB0Y2hhVG9rZW4gVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLlxuICAgKi9cbiAgYXN5bmMgcmVzZXRQYXNzd29yZEZvckVtYWlsKFxuICAgIGVtYWlsOiBzdHJpbmcsXG4gICAgb3B0aW9uczoge1xuICAgICAgcmVkaXJlY3RUbz86IHN0cmluZ1xuICAgICAgY2FwdGNoYVRva2VuPzogc3RyaW5nXG4gICAgfSA9IHt9XG4gICk6IFByb21pc2U8XG4gICAgfCB7XG4gICAgICAgIGRhdGE6IHt9XG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9XG4gICAgfCB7IGRhdGE6IG51bGw7IGVycm9yOiBBdXRoRXJyb3IgfVxuICA+IHtcbiAgICBsZXQgY29kZUNoYWxsZW5nZTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZDogc3RyaW5nIHwgbnVsbCA9IG51bGxcblxuICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgIDtbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKFxuICAgICAgICB0aGlzLnN0b3JhZ2UsXG4gICAgICAgIHRoaXMuc3RvcmFnZUtleSxcbiAgICAgICAgdHJ1ZSAvLyBpc1Bhc3N3b3JkUmVjb3ZlcnlcbiAgICAgIClcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9yZWNvdmVyYCwge1xuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgZW1haWwsXG4gICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kLFxuICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIHRoZSBpZGVudGl0aWVzIGxpbmtlZCB0byBhIHVzZXIuXG4gICAqL1xuICBhc3luYyBnZXRVc2VySWRlbnRpdGllcygpOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWRlbnRpdGllczogVXNlcklkZW50aXR5W11cbiAgICAgICAgfVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwgeyBkYXRhOiBudWxsOyBlcnJvcjogQXV0aEVycm9yIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuZ2V0VXNlcigpXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICByZXR1cm4geyBkYXRhOiB7IGlkZW50aXRpZXM6IGRhdGEudXNlci5pZGVudGl0aWVzID8/IFtdIH0sIGVycm9yOiBudWxsIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuICAvKipcbiAgICogTGlua3MgYW4gb2F1dGggaWRlbnRpdHkgdG8gYW4gZXhpc3RpbmcgdXNlci5cbiAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgdGhlIFBLQ0UgZmxvdy5cbiAgICovXG4gIGFzeW5jIGxpbmtJZGVudGl0eShjcmVkZW50aWFsczogU2lnbkluV2l0aE9BdXRoQ3JlZGVudGlhbHMpOiBQcm9taXNlPE9BdXRoUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICAgIGNvbnN0IHVybDogc3RyaW5nID0gYXdhaXQgdGhpcy5fZ2V0VXJsRm9yUHJvdmlkZXIoXG4gICAgICAgICAgYCR7dGhpcy51cmx9L3VzZXIvaWRlbnRpdGllcy9hdXRob3JpemVgLFxuICAgICAgICAgIGNyZWRlbnRpYWxzLnByb3ZpZGVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlZGlyZWN0VG86IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnJlZGlyZWN0VG8sXG4gICAgICAgICAgICBzY29wZXM6IGNyZWRlbnRpYWxzLm9wdGlvbnM/LnNjb3BlcyxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBjcmVkZW50aWFscy5vcHRpb25zPy5xdWVyeVBhcmFtcyxcbiAgICAgICAgICAgIHNraXBCcm93c2VyUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgdXJsLCB7XG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIGp3dDogZGF0YS5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4gPz8gdW5kZWZpbmVkLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhY3JlZGVudGlhbHMub3B0aW9ucz8uc2tpcEJyb3dzZXJSZWRpcmVjdCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKGRhdGE/LnVybClcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRhdGE6IHsgcHJvdmlkZXI6IGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB1cmw6IGRhdGE/LnVybCB9LCBlcnJvcjogbnVsbCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBwcm92aWRlcjogY3JlZGVudGlhbHMucHJvdmlkZXIsIHVybDogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbmxpbmtzIGFuIGlkZW50aXR5IGZyb20gYSB1c2VyIGJ5IGRlbGV0aW5nIGl0LiBUaGUgdXNlciB3aWxsIG5vIGxvbmdlciBiZSBhYmxlIHRvIHNpZ24gaW4gd2l0aCB0aGF0IGlkZW50aXR5IG9uY2UgaXQncyB1bmxpbmtlZC5cbiAgICovXG4gIGFzeW5jIHVubGlua0lkZW50aXR5KGlkZW50aXR5OiBVc2VySWRlbnRpdHkpOiBQcm9taXNlPFxuICAgIHwge1xuICAgICAgICBkYXRhOiB7fVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfVxuICAgIHwgeyBkYXRhOiBudWxsOyBlcnJvcjogQXV0aEVycm9yIH1cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KFxuICAgICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgICAgJ0RFTEVURScsXG4gICAgICAgICAgYCR7dGhpcy51cmx9L3VzZXIvaWRlbnRpdGllcy8ke2lkZW50aXR5LmlkZW50aXR5X2lkfWAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgand0OiBkYXRhLnNlc3Npb24/LmFjY2Vzc190b2tlbiA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIG5ldyBKV1QuXG4gICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gQSB2YWxpZCByZWZyZXNoIHRva2VuIHRoYXQgd2FzIHJldHVybmVkIG9uIGxvZ2luLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfcmVmcmVzaEFjY2Vzc1Rva2VuKHJlZnJlc2hUb2tlbjogc3RyaW5nKTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19yZWZyZXNoQWNjZXNzVG9rZW4oJHtyZWZyZXNoVG9rZW4uc3Vic3RyaW5nKDAsIDUpfS4uLilgXG4gICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXJ0ZWRBdCA9IERhdGUubm93KClcblxuICAgICAgLy8gd2lsbCBhdHRlbXB0IHRvIHJlZnJlc2ggdGhlIHRva2VuIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgcmV0dXJuIGF3YWl0IHJldHJ5YWJsZShcbiAgICAgICAgYXN5bmMgKGF0dGVtcHQpID0+IHtcbiAgICAgICAgICBpZiAoYXR0ZW1wdCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKDIwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKSkgLy8gMjAwLCA0MDAsIDgwMCwgLi4uXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAncmVmcmVzaGluZyBhdHRlbXB0JywgYXR0ZW1wdClcblxuICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXJlZnJlc2hfdG9rZW5gLCB7XG4gICAgICAgICAgICBib2R5OiB7IHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbiB9LFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgKGF0dGVtcHQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV4dEJhY2tPZmZJbnRlcnZhbCA9IDIwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGVycm9yICYmXG4gICAgICAgICAgICBpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yKSAmJlxuICAgICAgICAgICAgLy8gcmV0cnlhYmxlIG9ubHkgaWYgdGhlIHJlcXVlc3QgY2FuIGJlIHNlbnQgYmVmb3JlIHRoZSBiYWNrb2ZmIG92ZXJmbG93cyB0aGUgdGljayBkdXJhdGlvblxuICAgICAgICAgICAgRGF0ZS5ub3coKSArIG5leHRCYWNrT2ZmSW50ZXJ2YWwgLSBzdGFydGVkQXQgPCBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTlxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycm9yKVxuXG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LCBlcnJvciB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2lzVmFsaWRTZXNzaW9uKG1heWJlU2Vzc2lvbjogdW5rbm93bik6IG1heWJlU2Vzc2lvbiBpcyBTZXNzaW9uIHtcbiAgICBjb25zdCBpc1ZhbGlkU2Vzc2lvbiA9XG4gICAgICB0eXBlb2YgbWF5YmVTZXNzaW9uID09PSAnb2JqZWN0JyAmJlxuICAgICAgbWF5YmVTZXNzaW9uICE9PSBudWxsICYmXG4gICAgICAnYWNjZXNzX3Rva2VuJyBpbiBtYXliZVNlc3Npb24gJiZcbiAgICAgICdyZWZyZXNoX3Rva2VuJyBpbiBtYXliZVNlc3Npb24gJiZcbiAgICAgICdleHBpcmVzX2F0JyBpbiBtYXliZVNlc3Npb25cblxuICAgIHJldHVybiBpc1ZhbGlkU2Vzc2lvblxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfaGFuZGxlUHJvdmlkZXJTaWduSW4oXG4gICAgcHJvdmlkZXI6IFByb3ZpZGVyLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHJlZGlyZWN0VG8/OiBzdHJpbmdcbiAgICAgIHNjb3Blcz86IHN0cmluZ1xuICAgICAgcXVlcnlQYXJhbXM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gICAgICBza2lwQnJvd3NlclJlZGlyZWN0PzogYm9vbGVhblxuICAgIH1cbiAgKSB7XG4gICAgY29uc3QgdXJsOiBzdHJpbmcgPSBhd2FpdCB0aGlzLl9nZXRVcmxGb3JQcm92aWRlcihgJHt0aGlzLnVybH0vYXV0aG9yaXplYCwgcHJvdmlkZXIsIHtcbiAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMucmVkaXJlY3RUbyxcbiAgICAgIHNjb3Blczogb3B0aW9ucy5zY29wZXMsXG4gICAgICBxdWVyeVBhcmFtczogb3B0aW9ucy5xdWVyeVBhcmFtcyxcbiAgICB9KVxuXG4gICAgdGhpcy5fZGVidWcoJyNfaGFuZGxlUHJvdmlkZXJTaWduSW4oKScsICdwcm92aWRlcicsIHByb3ZpZGVyLCAnb3B0aW9ucycsIG9wdGlvbnMsICd1cmwnLCB1cmwpXG5cbiAgICAvLyB0cnkgdG8gb3BlbiBvbiB0aGUgYnJvd3NlclxuICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhb3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybClcbiAgICB9XG5cbiAgICByZXR1cm4geyBkYXRhOiB7IHByb3ZpZGVyLCB1cmwgfSwgZXJyb3I6IG51bGwgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY292ZXJzIHRoZSBzZXNzaW9uIGZyb20gTG9jYWxTdG9yYWdlIGFuZCByZWZyZXNoZXMgdGhlIHRva2VuXG4gICAqIE5vdGU6IHRoaXMgbWV0aG9kIGlzIGFzeW5jIHRvIGFjY29tbW9kYXRlIGZvciBBc3luY1N0b3JhZ2UgZS5nLiBpbiBSZWFjdCBuYXRpdmUuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9yZWNvdmVyQW5kUmVmcmVzaCgpIHtcbiAgICBjb25zdCBkZWJ1Z05hbWUgPSAnI19yZWNvdmVyQW5kUmVmcmVzaCgpJ1xuICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJylcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSlcbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlJywgY3VycmVudFNlc3Npb24pXG5cbiAgICAgIGlmICghdGhpcy5faXNWYWxpZFNlc3Npb24oY3VycmVudFNlc3Npb24pKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3Nlc3Npb24gaXMgbm90IHZhbGlkJylcbiAgICAgICAgaWYgKGN1cnJlbnRTZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgdGltZU5vdyA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApXG4gICAgICBjb25zdCBleHBpcmVzV2l0aE1hcmdpbiA9IChjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0ID8/IEluZmluaXR5KSA8IHRpbWVOb3cgKyBFWFBJUllfTUFSR0lOXG5cbiAgICAgIHRoaXMuX2RlYnVnKFxuICAgICAgICBkZWJ1Z05hbWUsXG4gICAgICAgIGBzZXNzaW9uIGhhcyR7ZXhwaXJlc1dpdGhNYXJnaW4gPyAnJyA6ICcgbm90J30gZXhwaXJlZCB3aXRoIG1hcmdpbiBvZiAke0VYUElSWV9NQVJHSU59c2BcbiAgICAgIClcblxuICAgICAgaWYgKGV4cGlyZXNXaXRoTWFyZ2luKSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4gJiYgY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbikge1xuICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbilcblxuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcilcblxuICAgICAgICAgICAgaWYgKCFpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgICAgICAgICBkZWJ1Z05hbWUsXG4gICAgICAgICAgICAgICAgJ3JlZnJlc2ggZmFpbGVkIHdpdGggYSBub24tcmV0cnlhYmxlIGVycm9yLCByZW1vdmluZyB0aGUgc2Vzc2lvbicsXG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gcGVyc2lzdCBjdXJyZW50U2Vzc2lvbiBhZ2FpbiwgYXMgd2UganVzdCBsb2FkZWQgaXQgZnJvbVxuICAgICAgICAvLyBsb2NhbCBzdG9yYWdlOyBwZXJzaXN0aW5nIGl0IGFnYWluIG1heSBvdmVyd3JpdGUgYSB2YWx1ZSBzYXZlZCBieVxuICAgICAgICAvLyBhbm90aGVyIGNsaWVudCB3aXRoIGFjY2VzcyB0byB0aGUgc2FtZSBsb2NhbCBzdG9yYWdlXG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBjdXJyZW50U2Vzc2lvbilcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2Vycm9yJywgZXJyKVxuXG4gICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgIHJldHVyblxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2NhbGxSZWZyZXNoVG9rZW4ocmVmcmVzaFRva2VuOiBzdHJpbmcpOiBQcm9taXNlPENhbGxSZWZyZXNoVG9rZW5SZXN1bHQ+IHtcbiAgICBpZiAoIXJlZnJlc2hUb2tlbikge1xuICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcbiAgICB9XG5cbiAgICAvLyByZWZyZXNoaW5nIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3NcbiAgICBpZiAodGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZC5wcm9taXNlXG4gICAgfVxuXG4gICAgY29uc3QgZGVidWdOYW1lID0gYCNfY2FsbFJlZnJlc2hUb2tlbigke3JlZnJlc2hUb2tlbi5zdWJzdHJpbmcoMCwgNSl9Li4uKWBcblxuICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJylcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCA9IG5ldyBEZWZlcnJlZDxDYWxsUmVmcmVzaFRva2VuUmVzdWx0PigpXG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX3JlZnJlc2hBY2Nlc3NUb2tlbihyZWZyZXNoVG9rZW4pXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICBpZiAoIWRhdGEuc2Vzc2lvbikgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcblxuICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKVxuICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1RPS0VOX1JFRlJFU0hFRCcsIGRhdGEuc2Vzc2lvbilcblxuICAgICAgY29uc3QgcmVzdWx0ID0geyBzZXNzaW9uOiBkYXRhLnNlc3Npb24sIGVycm9yOiBudWxsIH1cblxuICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpXG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnJvcilcblxuICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IHNlc3Npb246IG51bGwsIGVycm9yIH1cblxuICAgICAgICBpZiAoIWlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZD8ucmVzb2x2ZShyZXN1bHQpXG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZD8ucmVqZWN0KGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBudWxsXG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX25vdGlmeUFsbFN1YnNjcmliZXJzKFxuICAgIGV2ZW50OiBBdXRoQ2hhbmdlRXZlbnQsXG4gICAgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGwsXG4gICAgYnJvYWRjYXN0ID0gdHJ1ZVxuICApIHtcbiAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19ub3RpZnlBbGxTdWJzY3JpYmVycygke2V2ZW50fSlgXG4gICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nLCBzZXNzaW9uLCBgYnJvYWRjYXN0ID0gJHticm9hZGNhc3R9YClcblxuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5icm9hZGNhc3RDaGFubmVsICYmIGJyb2FkY2FzdCkge1xuICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2UoeyBldmVudCwgc2Vzc2lvbiB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBlcnJvcnM6IGFueVtdID0gW11cbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMudmFsdWVzKCkpLm1hcChhc3luYyAoeCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHguY2FsbGJhY2soZXZlbnQsIHNlc3Npb24pXG4gICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxuXG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yc1tpXSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycm9yc1swXVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgY3VycmVudFNlc3Npb24gYW5kIGN1cnJlbnRVc2VyXG4gICAqIHByb2Nlc3MgdG8gX3N0YXJ0QXV0b1JlZnJlc2hUb2tlbiBpZiBwb3NzaWJsZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfc2F2ZVNlc3Npb24oc2Vzc2lvbjogU2Vzc2lvbikge1xuICAgIHRoaXMuX2RlYnVnKCcjX3NhdmVTZXNzaW9uKCknLCBzZXNzaW9uKVxuICAgIC8vIF9zYXZlU2Vzc2lvbiBpcyBhbHdheXMgY2FsbGVkIHdoZW5ldmVyIGEgbmV3IHNlc3Npb24gaGFzIGJlZW4gYWNxdWlyZWRcbiAgICAvLyBzbyB3ZSBjYW4gc2FmZWx5IHN1cHByZXNzIHRoZSB3YXJuaW5nIHJldHVybmVkIGJ5IGZ1dHVyZSBnZXRTZXNzaW9uIGNhbGxzXG4gICAgdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gdHJ1ZVxuICAgIGF3YWl0IHNldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSwgc2Vzc2lvbilcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX3JlbW92ZVNlc3Npb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJyNfcmVtb3ZlU2Vzc2lvbigpJylcblxuICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSlcbiAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX09VVCcsIG51bGwpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbnkgcmVnaXN0ZXJlZCB2aXNpYmlsaXR5Y2hhbmdlIGNhbGxiYWNrLlxuICAgKlxuICAgKiB7QHNlZSAjc3RhcnRBdXRvUmVmcmVzaH1cbiAgICoge0BzZWUgI3N0b3BBdXRvUmVmcmVzaH1cbiAgICovXG4gIHByaXZhdGUgX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fZGVidWcoJyNfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpJylcblxuICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrXG4gICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrID0gbnVsbFxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChjYWxsYmFjayAmJiBpc0Jyb3dzZXIoKSAmJiB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBjYWxsYmFjaylcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdyZW1vdmluZyB2aXNpYmlsaXR5Y2hhbmdlIGNhbGxiYWNrIGZhaWxlZCcsIGUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIHByaXZhdGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rICNzdGFydEF1dG9SZWZyZXNofS4gVXNlIHRoaXNcbiAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfc3RhcnRBdXRvUmVmcmVzaCgpIHtcbiAgICBhd2FpdCB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKVxuXG4gICAgdGhpcy5fZGVidWcoJyNfc3RhcnRBdXRvUmVmcmVzaCgpJylcblxuICAgIGNvbnN0IHRpY2tlciA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCksIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OKVxuICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrZXIgPSB0aWNrZXJcblxuICAgIGlmICh0aWNrZXIgJiYgdHlwZW9mIHRpY2tlciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRpY2tlci51bnJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gdGlja2VyIGlzIGEgTm9kZUpTIFRpbWVvdXQgb2JqZWN0IHRoYXQgaGFzIGFuIGB1bnJlZmAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL3RpbWVycy5odG1sI3RpbWVvdXR1bnJlZlxuICAgICAgLy8gV2hlbiBhdXRvIHJlZnJlc2ggaXMgdXNlZCBpbiBOb2RlSlMgKGxpa2UgZm9yIHRlc3RpbmcpIHRoZVxuICAgICAgLy8gYHNldEludGVydmFsYCBpcyBwcmV2ZW50aW5nIHRoZSBwcm9jZXNzIGZyb20gYmVpbmcgbWFya2VkIGFzXG4gICAgICAvLyBmaW5pc2hlZCBhbmQgdGVzdHMgcnVuIGVuZGxlc3NseS4gVGhpcyBjYW4gYmUgcHJldmVudGVkIGJ5IGNhbGxpbmdcbiAgICAgIC8vIGB1bnJlZigpYCBvbiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICAgICAgdGlja2VyLnVucmVmKClcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgaGFzIG5vIGNvbnRleHQgb2YgRGVub1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBEZW5vLnVucmVmVGltZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIHNpbWlsYXIgbGlrZSBmb3IgTm9kZUpTLCBidXQgd2l0aCB0aGUgRGVubyBBUElcbiAgICAgIC8vIGh0dHBzOi8vZGVuby5sYW5kL2FwaUBsYXRlc3Q/dW5zdGFibGUmcz1EZW5vLnVucmVmVGltZXJcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgaGFzIG5vIGNvbnRleHQgb2YgRGVub1xuICAgICAgRGVuby51bnJlZlRpbWVyKHRpY2tlcilcbiAgICB9XG5cbiAgICAvLyBydW4gdGhlIHRpY2sgaW1tZWRpYXRlbHksIGJ1dCBpbiB0aGUgbmV4dCBwYXNzIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXRcbiAgICAvLyAjX2luaXRpYWxpemUgY2FuIGJlIGFsbG93ZWQgdG8gY29tcGxldGUgd2l0aG91dCByZWN1cnNpdmVseSB3YWl0aW5nIG9uXG4gICAgLy8gaXRzZWxmXG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlXG4gICAgICBhd2FpdCB0aGlzLl9hdXRvUmVmcmVzaFRva2VuVGljaygpXG4gICAgfSwgMClcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayAjc3RvcEF1dG9SZWZyZXNofS4gVXNlIHRoaXNcbiAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfc3RvcEF1dG9SZWZyZXNoKCkge1xuICAgIHRoaXMuX2RlYnVnKCcjX3N0b3BBdXRvUmVmcmVzaCgpJylcblxuICAgIGNvbnN0IHRpY2tlciA9IHRoaXMuYXV0b1JlZnJlc2hUaWNrZXJcbiAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gbnVsbFxuXG4gICAgaWYgKHRpY2tlcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aWNrZXIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBhbiBhdXRvLXJlZnJlc2ggcHJvY2VzcyBpbiB0aGUgYmFja2dyb3VuZC4gVGhlIHNlc3Npb24gaXMgY2hlY2tlZFxuICAgKiBldmVyeSBmZXcgc2Vjb25kcy4gQ2xvc2UgdG8gdGhlIHRpbWUgb2YgZXhwaXJhdGlvbiBhIHByb2Nlc3MgaXMgc3RhcnRlZCB0b1xuICAgKiByZWZyZXNoIHRoZSBzZXNzaW9uLiBJZiByZWZyZXNoaW5nIGZhaWxzIGl0IHdpbGwgYmUgcmV0cmllZCBmb3IgYXMgbG9uZyBhc1xuICAgKiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIElmIHlvdSBzZXQgdGhlIHtAbGluayBHb1RydWVDbGllbnRPcHRpb25zI2F1dG9SZWZyZXNoVG9rZW59IHlvdSBkb24ndCBuZWVkXG4gICAqIHRvIGNhbGwgdGhpcyBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgZm9yIHlvdS5cbiAgICpcbiAgICogT24gYnJvd3NlcnMgdGhlIHJlZnJlc2ggcHJvY2VzcyB3b3JrcyBvbmx5IHdoZW4gdGhlIHRhYi93aW5kb3cgaXMgaW4gdGhlXG4gICAqIGZvcmVncm91bmQgdG8gY29uc2VydmUgcmVzb3VyY2VzIGFzIHdlbGwgYXMgcHJldmVudCByYWNlIGNvbmRpdGlvbnMgYW5kXG4gICAqIGZsb29kaW5nIGF1dGggd2l0aCByZXF1ZXN0cy4gSWYgeW91IGNhbGwgdGhpcyBtZXRob2QgYW55IG1hbmFnZWRcbiAgICogdmlzaWJpbGl0eSBjaGFuZ2UgY2FsbGJhY2sgd2lsbCBiZSByZW1vdmVkIGFuZCB5b3UgbXVzdCBtYW5hZ2UgdmlzaWJpbGl0eVxuICAgKiBjaGFuZ2VzIG9uIHlvdXIgb3duLlxuICAgKlxuICAgKiBPbiBub24tYnJvd3NlciBwbGF0Zm9ybXMgdGhlIHJlZnJlc2ggcHJvY2VzcyB3b3JrcyAqY29udGludW91c2x5KiBpbiB0aGVcbiAgICogYmFja2dyb3VuZCwgd2hpY2ggbWF5IG5vdCBiZSBkZXNpcmFibGUuIFlvdSBzaG91bGQgaG9vayBpbnRvIHlvdXJcbiAgICogcGxhdGZvcm0ncyBmb3JlZ3JvdW5kIGluZGljYXRpb24gbWVjaGFuaXNtIGFuZCBjYWxsIHRoZXNlIG1ldGhvZHNcbiAgICogYXBwcm9wcmlhdGVseSB0byBjb25zZXJ2ZSByZXNvdXJjZXMuXG4gICAqXG4gICAqIHtAc2VlICNzdG9wQXV0b1JlZnJlc2h9XG4gICAqL1xuICBhc3luYyBzdGFydEF1dG9SZWZyZXNoKCkge1xuICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKVxuICAgIGF3YWl0IHRoaXMuX3N0YXJ0QXV0b1JlZnJlc2goKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIGFuIGFjdGl2ZSBhdXRvIHJlZnJlc2ggcHJvY2VzcyBydW5uaW5nIGluIHRoZSBiYWNrZ3JvdW5kIChpZiBhbnkpLlxuICAgKlxuICAgKiBJZiB5b3UgY2FsbCB0aGlzIG1ldGhvZCBhbnkgbWFuYWdlZCB2aXNpYmlsaXR5IGNoYW5nZSBjYWxsYmFjayB3aWxsIGJlXG4gICAqIHJlbW92ZWQgYW5kIHlvdSBtdXN0IG1hbmFnZSB2aXNpYmlsaXR5IGNoYW5nZXMgb24geW91ciBvd24uXG4gICAqXG4gICAqIFNlZSB7QGxpbmsgI3N0YXJ0QXV0b1JlZnJlc2h9IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBhc3luYyBzdG9wQXV0b1JlZnJlc2goKSB7XG4gICAgdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpXG4gICAgYXdhaXQgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHRoZSBhdXRvIHJlZnJlc2ggdG9rZW4gdGljay5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCkge1xuICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCAnYmVnaW4nKVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKDAsIGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBzZXNzaW9uIH0sXG4gICAgICAgICAgICAgIH0gPSByZXN1bHRcblxuICAgICAgICAgICAgICBpZiAoIXNlc3Npb24gfHwgIXNlc3Npb24ucmVmcmVzaF90b2tlbiB8fCAhc2Vzc2lvbi5leHBpcmVzX2F0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdubyBzZXNzaW9uJylcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIHNlc3Npb24gd2lsbCBleHBpcmUgaW4gdGhpcyBtYW55IHRpY2tzIChvciBoYXMgYWxyZWFkeSBleHBpcmVkIGlmIDw9IDApXG4gICAgICAgICAgICAgIGNvbnN0IGV4cGlyZXNJblRpY2tzID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAgICAgICAoc2Vzc2lvbi5leHBpcmVzX2F0ICogMTAwMCAtIG5vdykgLyBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTlxuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgICAgICAgICAgJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsXG4gICAgICAgICAgICAgICAgYGFjY2VzcyB0b2tlbiBleHBpcmVzIGluICR7ZXhwaXJlc0luVGlja3N9IHRpY2tzLCBhIHRpY2sgbGFzdHMgJHtBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTn1tcywgcmVmcmVzaCB0aHJlc2hvbGQgaXMgJHtBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTER9IHRpY2tzYFxuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgaWYgKGV4cGlyZXNJblRpY2tzIDw9IEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oc2Vzc2lvbi5yZWZyZXNoX3Rva2VuKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJ0F1dG8gcmVmcmVzaCB0aWNrIGZhaWxlZCB3aXRoIGVycm9yLiBUaGlzIGlzIGxpa2VseSBhIHRyYW5zaWVudCBlcnJvci4nLFxuICAgICAgICAgICAgICBlXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCAnZW5kJylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIGlmIChlLmlzQWNxdWlyZVRpbWVvdXQgfHwgZSBpbnN0YW5jZW9mIExvY2tBY3F1aXJlVGltZW91dEVycm9yKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdhdXRvIHJlZnJlc2ggdG9rZW4gdGljayBsb2NrIG5vdCBhdmFpbGFibGUnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIG9uIHRoZSBicm93c2VyIC8gcGxhdGZvcm0sIHdoaWNoIGluLXR1cm4gcnVuXG4gICAqIGFsZ29yaXRobXMgd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cvdGFiIGFyZSBpbiBmb3JlZ3JvdW5kLiBPbiBub24tYnJvd3NlclxuICAgKiBwbGF0Zm9ybXMgaXQgYXNzdW1lcyBhbHdheXMgZm9yZWdyb3VuZC5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgdGhpcy5fZGVidWcoJyNfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpJylcblxuICAgIGlmICghaXNCcm93c2VyKCkgfHwgIXdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbikge1xuICAgICAgICAvLyBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgdGhlIHJlZnJlc2ggdG9rZW4gdGlja2VyIHJ1bnMgYWx3YXlzXG4gICAgICAgIHRoaXMuc3RhcnRBdXRvUmVmcmVzaCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2sgPSBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2VkKGZhbHNlKVxuXG4gICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2spXG5cbiAgICAgIC8vIG5vdyBpbW1lZGlhdGVseSBjYWxsIHRoZSB2aXNiaWxpdHkgY2hhbmdlZCBjYWxsYmFjayB0byBzZXR1cCB3aXRoIHRoZVxuICAgICAgLy8gY3VycmVudCB2aXNiaWxpdHkgc3RhdGVcbiAgICAgIGF3YWl0IHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZWQodHJ1ZSkgLy8gaW5pdGlhbCBjYWxsXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ19oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlJywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHJlZ2lzdGVyZWQgd2l0aCBgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnKWAuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9vblZpc2liaWxpdHlDaGFuZ2VkKGNhbGxlZEZyb21Jbml0aWFsaXplOiBib29sZWFuKSB7XG4gICAgY29uc3QgbWV0aG9kTmFtZSA9IGAjX29uVmlzaWJpbGl0eUNoYW5nZWQoJHtjYWxsZWRGcm9tSW5pdGlhbGl6ZX0pYFxuICAgIHRoaXMuX2RlYnVnKG1ldGhvZE5hbWUsICd2aXNpYmlsaXR5U3RhdGUnLCBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUpXG5cbiAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgLy8gaW4gYnJvd3NlciBlbnZpcm9ubWVudHMgdGhlIHJlZnJlc2ggdG9rZW4gdGlja2VyIHJ1bnMgb25seSBvbiBmb2N1c2VkIHRhYnNcbiAgICAgICAgLy8gd2hpY2ggcHJldmVudHMgcmFjZSBjb25kaXRpb25zXG4gICAgICAgIHRoaXMuX3N0YXJ0QXV0b1JlZnJlc2goKVxuICAgICAgfVxuXG4gICAgICBpZiAoIWNhbGxlZEZyb21Jbml0aWFsaXplKSB7XG4gICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkLCBpLmUuIHRoZSBicm93c2VyXG4gICAgICAgIC8vIHRyYW5zaXRpb25lZCBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlIHNvIHdlIG5lZWQgdG8gc2VlIGlmIHRoZSBzZXNzaW9uXG4gICAgICAgIC8vIHNob3VsZCBiZSByZWNvdmVyZWQgaW1tZWRpYXRlbHkuLi4gYnV0IHRvIGRvIHRoYXQgd2UgbmVlZCB0byBhY3F1aXJlXG4gICAgICAgIC8vIHRoZSBsb2NrIGZpcnN0IGFzeW5jaHJvbm91c2x5XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2VcblxuICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgIT09ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICdhY3F1aXJlZCB0aGUgbG9jayB0byByZWNvdmVyIHRoZSBzZXNzaW9uLCBidXQgdGhlIGJyb3dzZXIgdmlzaWJpbGl0eVN0YXRlIGlzIG5vIGxvbmdlciB2aXNpYmxlLCBhYm9ydGluZydcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgLy8gdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCB3aGlsZSB3YWl0aW5nIGZvciB0aGUgbG9jaywgYWJvcnRcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlY292ZXIgdGhlIHNlc3Npb25cbiAgICAgICAgICBhd2FpdCB0aGlzLl9yZWNvdmVyQW5kUmVmcmVzaCgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuKSB7XG4gICAgICAgIHRoaXMuX3N0b3BBdXRvUmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgcmVsZXZhbnQgbG9naW4gVVJMIGZvciBhIHRoaXJkLXBhcnR5IHByb3ZpZGVyLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIEEgVVJMIG9yIG1vYmlsZSBhZGRyZXNzIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBhcmUgY29uZmlybWVkLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zY29wZXMgQSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiBzY29wZXMgZ3JhbnRlZCB0byB0aGUgT0F1dGggYXBwbGljYXRpb24uXG4gICAqIEBwYXJhbSBvcHRpb25zLnF1ZXJ5UGFyYW1zIEFuIG9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgY29udGFpbmluZyBxdWVyeSBwYXJhbWV0ZXJzIGdyYW50ZWQgdG8gdGhlIE9BdXRoIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0VXJsRm9yUHJvdmlkZXIoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgcHJvdmlkZXI6IFByb3ZpZGVyLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHJlZGlyZWN0VG8/OiBzdHJpbmdcbiAgICAgIHNjb3Blcz86IHN0cmluZ1xuICAgICAgcXVlcnlQYXJhbXM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gICAgICBza2lwQnJvd3NlclJlZGlyZWN0PzogYm9vbGVhblxuICAgIH1cbiAgKSB7XG4gICAgY29uc3QgdXJsUGFyYW1zOiBzdHJpbmdbXSA9IFtgcHJvdmlkZXI9JHtlbmNvZGVVUklDb21wb25lbnQocHJvdmlkZXIpfWBdXG4gICAgaWYgKG9wdGlvbnM/LnJlZGlyZWN0VG8pIHtcbiAgICAgIHVybFBhcmFtcy5wdXNoKGByZWRpcmVjdF90bz0ke2VuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLnJlZGlyZWN0VG8pfWApXG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5zY29wZXMpIHtcbiAgICAgIHVybFBhcmFtcy5wdXNoKGBzY29wZXM9JHtlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5zY29wZXMpfWApXG4gICAgfVxuICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgIGNvbnN0IFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QoXG4gICAgICAgIHRoaXMuc3RvcmFnZSxcbiAgICAgICAgdGhpcy5zdG9yYWdlS2V5XG4gICAgICApXG5cbiAgICAgIGNvbnN0IGZsb3dQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGAke2VuY29kZVVSSUNvbXBvbmVudChjb2RlQ2hhbGxlbmdlKX1gLFxuICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGAke2VuY29kZVVSSUNvbXBvbmVudChjb2RlQ2hhbGxlbmdlTWV0aG9kKX1gLFxuICAgICAgfSlcbiAgICAgIHVybFBhcmFtcy5wdXNoKGZsb3dQYXJhbXMudG9TdHJpbmcoKSlcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LnF1ZXJ5UGFyYW1zKSB7XG4gICAgICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucy5xdWVyeVBhcmFtcylcbiAgICAgIHVybFBhcmFtcy5wdXNoKHF1ZXJ5LnRvU3RyaW5nKCkpXG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICB1cmxQYXJhbXMucHVzaChgc2tpcF9odHRwX3JlZGlyZWN0PSR7b3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0fWApXG4gICAgfVxuXG4gICAgcmV0dXJuIGAke3VybH0/JHt1cmxQYXJhbXMuam9pbignJicpfWBcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX3VuZW5yb2xsKHBhcmFtczogTUZBVW5lbnJvbGxQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFVbmVucm9sbFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L2ZhY3RvcnMvJHtwYXJhbXMuZmFjdG9ySWR9YCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICBqd3Q6IHNlc3Npb25EYXRhPy5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNlbnJvbGx9XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9lbnJvbGwocGFyYW1zOiBNRkFFbnJvbGxUT1RQUGFyYW1zKTogUHJvbWlzZTxBdXRoTUZBRW5yb2xsVE9UUFJlc3BvbnNlPlxuICBwcml2YXRlIGFzeW5jIF9lbnJvbGwocGFyYW1zOiBNRkFFbnJvbGxQaG9uZVBhcmFtcyk6IFByb21pc2U8QXV0aE1GQUVucm9sbFBob25lUmVzcG9uc2U+XG4gIHByaXZhdGUgYXN5bmMgX2Vucm9sbChwYXJhbXM6IE1GQUVucm9sbFBhcmFtcyk6IFByb21pc2U8QXV0aE1GQUVucm9sbFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0XG4gICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgZnJpZW5kbHlfbmFtZTogcGFyYW1zLmZyaWVuZGx5TmFtZSxcbiAgICAgICAgICBmYWN0b3JfdHlwZTogcGFyYW1zLmZhY3RvclR5cGUsXG4gICAgICAgICAgLi4uKHBhcmFtcy5mYWN0b3JUeXBlID09PSAncGhvbmUnID8geyBwaG9uZTogcGFyYW1zLnBob25lIH0gOiB7IGlzc3VlcjogcGFyYW1zLmlzc3VlciB9KSxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ZhY3RvcnNgLCB7XG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgand0OiBzZXNzaW9uRGF0YT8uc2Vzc2lvbj8uYWNjZXNzX3Rva2VuLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuZmFjdG9yVHlwZSA9PT0gJ3RvdHAnICYmIGRhdGE/LnRvdHA/LnFyX2NvZGUpIHtcbiAgICAgICAgICBkYXRhLnRvdHAucXJfY29kZSA9IGBkYXRhOmltYWdlL3N2Zyt4bWw7dXRmLTgsJHtkYXRhLnRvdHAucXJfY29kZX1gXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSN2ZXJpZnl9XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF92ZXJpZnkocGFyYW1zOiBNRkFWZXJpZnlQYXJhbXMpOiBQcm9taXNlPEF1dGhNRkFWZXJpZnlSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdFxuICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KFxuICAgICAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgICAgICdQT1NUJyxcbiAgICAgICAgICAgIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfS92ZXJpZnlgLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBib2R5OiB7IGNvZGU6IHBhcmFtcy5jb2RlLCBjaGFsbGVuZ2VfaWQ6IHBhcmFtcy5jaGFsbGVuZ2VJZCB9LFxuICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgIGp3dDogc2Vzc2lvbkRhdGE/LnNlc3Npb24/LmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oe1xuICAgICAgICAgICAgZXhwaXJlc19hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkgKyBkYXRhLmV4cGlyZXNfaW4sXG4gICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ01GQV9DSEFMTEVOR0VfVkVSSUZJRUQnLCBkYXRhKVxuXG4gICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgR29UcnVlTUZBQXBpI2NoYWxsZW5nZX1cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2NoYWxsZW5nZShwYXJhbXM6IE1GQUNoYWxsZW5nZVBhcmFtcyk6IFByb21pc2U8QXV0aE1GQUNoYWxsZW5nZVJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0XG4gICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KFxuICAgICAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgICAgICdQT1NUJyxcbiAgICAgICAgICAgIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfS9jaGFsbGVuZ2VgLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBib2R5OiB7IGNoYW5uZWw6IHBhcmFtcy5jaGFubmVsIH0sXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgand0OiBzZXNzaW9uRGF0YT8uc2Vzc2lvbj8uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNjaGFsbGVuZ2VBbmRWZXJpZnl9XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9jaGFsbGVuZ2VBbmRWZXJpZnkoXG4gICAgcGFyYW1zOiBNRkFDaGFsbGVuZ2VBbmRWZXJpZnlQYXJhbXNcbiAgKTogUHJvbWlzZTxBdXRoTUZBVmVyaWZ5UmVzcG9uc2U+IHtcbiAgICAvLyBib3RoIF9jaGFsbGVuZ2UgYW5kIF92ZXJpZnkgaW5kZXBlbmRlbnRseSBhY3F1aXJlIHRoZSBsb2NrLCBzbyBubyBuZWVkXG4gICAgLy8gdG8gYWNxdWlyZSBpdCBoZXJlXG5cbiAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZURhdGEsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9ID0gYXdhaXQgdGhpcy5fY2hhbGxlbmdlKHtcbiAgICAgIGZhY3RvcklkOiBwYXJhbXMuZmFjdG9ySWQsXG4gICAgfSlcbiAgICBpZiAoY2hhbGxlbmdlRXJyb3IpIHtcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3ZlcmlmeSh7XG4gICAgICBmYWN0b3JJZDogcGFyYW1zLmZhY3RvcklkLFxuICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZURhdGEuaWQsXG4gICAgICBjb2RlOiBwYXJhbXMuY29kZSxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNsaXN0RmFjdG9yc31cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2xpc3RGYWN0b3JzKCk6IFByb21pc2U8QXV0aE1GQUxpc3RGYWN0b3JzUmVzcG9uc2U+IHtcbiAgICAvLyB1c2UgI2dldFVzZXIgaW5zdGVhZCBvZiAjX2dldFVzZXIgYXMgdGhlIGZvcm1lciBhY3F1aXJlcyBhIGxvY2tcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7IHVzZXIgfSxcbiAgICAgIGVycm9yOiB1c2VyRXJyb3IsXG4gICAgfSA9IGF3YWl0IHRoaXMuZ2V0VXNlcigpXG4gICAgaWYgKHVzZXJFcnJvcikge1xuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHVzZXJFcnJvciB9XG4gICAgfVxuXG4gICAgY29uc3QgZmFjdG9ycyA9IHVzZXI/LmZhY3RvcnMgfHwgW11cbiAgICBjb25zdCB0b3RwID0gZmFjdG9ycy5maWx0ZXIoXG4gICAgICAoZmFjdG9yKSA9PiBmYWN0b3IuZmFjdG9yX3R5cGUgPT09ICd0b3RwJyAmJiBmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnXG4gICAgKVxuICAgIGNvbnN0IHBob25lID0gZmFjdG9ycy5maWx0ZXIoXG4gICAgICAoZmFjdG9yKSA9PiBmYWN0b3IuZmFjdG9yX3R5cGUgPT09ICdwaG9uZScgJiYgZmFjdG9yLnN0YXR1cyA9PT0gJ3ZlcmlmaWVkJ1xuICAgIClcblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGFsbDogZmFjdG9ycyxcbiAgICAgICAgdG90cCxcbiAgICAgICAgcGhvbmUsXG4gICAgICB9LFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWx9XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9nZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwoKTogUHJvbWlzZTxBdXRoTUZBR2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRhdGE6IHsgc2Vzc2lvbiB9LFxuICAgICAgICAgIGVycm9yOiBzZXNzaW9uRXJyb3IsXG4gICAgICAgIH0gPSByZXN1bHRcbiAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB7IGN1cnJlbnRMZXZlbDogbnVsbCwgbmV4dExldmVsOiBudWxsLCBjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzOiBbXSB9LFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuX2RlY29kZUpXVChzZXNzaW9uLmFjY2Vzc190b2tlbilcblxuICAgICAgICBsZXQgY3VycmVudExldmVsOiBBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWxzIHwgbnVsbCA9IG51bGxcblxuICAgICAgICBpZiAocGF5bG9hZC5hYWwpIHtcbiAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBwYXlsb2FkLmFhbFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5leHRMZXZlbDogQXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVscyB8IG51bGwgPSBjdXJyZW50TGV2ZWxcblxuICAgICAgICBjb25zdCB2ZXJpZmllZEZhY3RvcnMgPVxuICAgICAgICAgIHNlc3Npb24udXNlci5mYWN0b3JzPy5maWx0ZXIoKGZhY3RvcjogRmFjdG9yKSA9PiBmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnKSA/PyBbXVxuXG4gICAgICAgIGlmICh2ZXJpZmllZEZhY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG5leHRMZXZlbCA9ICdhYWwyJ1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kcyA9IHBheWxvYWQuYW1yIHx8IFtdXG5cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBjdXJyZW50TGV2ZWwsIG5leHRMZXZlbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kcyB9LCBlcnJvcjogbnVsbCB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbiIsICJpbXBvcnQgR29UcnVlQ2xpZW50IGZyb20gJy4vR29UcnVlQ2xpZW50J1xuXG5jb25zdCBBdXRoQ2xpZW50ID0gR29UcnVlQ2xpZW50XG5cbmV4cG9ydCBkZWZhdWx0IEF1dGhDbGllbnRcbiIsICJpbXBvcnQgeyBBdXRoQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG5pbXBvcnQgeyBTdXBhYmFzZUF1dGhDbGllbnRPcHRpb25zIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGNsYXNzIFN1cGFiYXNlQXV0aENsaWVudCBleHRlbmRzIEF1dGhDbGllbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTdXBhYmFzZUF1dGhDbGllbnRPcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucylcbiAgfVxufVxuIiwgImltcG9ydCB7IEZ1bmN0aW9uc0NsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9mdW5jdGlvbnMtanMnXG5pbXBvcnQgeyBBdXRoQ2hhbmdlRXZlbnQgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbmltcG9ydCB7XG4gIFBvc3RncmVzdENsaWVudCxcbiAgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcbiAgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxufSBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJ1xuaW1wb3J0IHtcbiAgUmVhbHRpbWVDaGFubmVsLFxuICBSZWFsdGltZUNoYW5uZWxPcHRpb25zLFxuICBSZWFsdGltZUNsaWVudCxcbiAgUmVhbHRpbWVDbGllbnRPcHRpb25zLFxufSBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnXG5pbXBvcnQgeyBTdG9yYWdlQ2xpZW50IGFzIFN1cGFiYXNlU3RvcmFnZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdG9yYWdlLWpzJ1xuaW1wb3J0IHtcbiAgREVGQVVMVF9HTE9CQUxfT1BUSU9OUyxcbiAgREVGQVVMVF9EQl9PUFRJT05TLFxuICBERUZBVUxUX0FVVEhfT1BUSU9OUyxcbiAgREVGQVVMVF9SRUFMVElNRV9PUFRJT05TLFxufSBmcm9tICcuL2xpYi9jb25zdGFudHMnXG5pbXBvcnQgeyBmZXRjaFdpdGhBdXRoIH0gZnJvbSAnLi9saWIvZmV0Y2gnXG5pbXBvcnQgeyBzdHJpcFRyYWlsaW5nU2xhc2gsIGFwcGx5U2V0dGluZ0RlZmF1bHRzIH0gZnJvbSAnLi9saWIvaGVscGVycydcbmltcG9ydCB7IFN1cGFiYXNlQXV0aENsaWVudCB9IGZyb20gJy4vbGliL1N1cGFiYXNlQXV0aENsaWVudCdcbmltcG9ydCB7IEZldGNoLCBHZW5lcmljU2NoZW1hLCBTdXBhYmFzZUNsaWVudE9wdGlvbnMsIFN1cGFiYXNlQXV0aENsaWVudE9wdGlvbnMgfSBmcm9tICcuL2xpYi90eXBlcydcblxuLyoqXG4gKiBTdXBhYmFzZSBDbGllbnQuXG4gKlxuICogQW4gaXNvbW9ycGhpYyBKYXZhc2NyaXB0IGNsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBQb3N0Z3Jlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3VwYWJhc2VDbGllbnQ8XG4gIERhdGFiYXNlID0gYW55LFxuICBTY2hlbWFOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgRGF0YWJhc2UgPSAncHVibGljJyBleHRlbmRzIGtleW9mIERhdGFiYXNlXG4gICAgPyAncHVibGljJ1xuICAgIDogc3RyaW5nICYga2V5b2YgRGF0YWJhc2UsXG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEgPSBEYXRhYmFzZVtTY2hlbWFOYW1lXSBleHRlbmRzIEdlbmVyaWNTY2hlbWFcbiAgICA/IERhdGFiYXNlW1NjaGVtYU5hbWVdXG4gICAgOiBhbnlcbj4ge1xuICAvKipcbiAgICogU3VwYWJhc2UgQXV0aCBhbGxvd3MgeW91IHRvIGNyZWF0ZSBhbmQgbWFuYWdlIHVzZXIgc2Vzc2lvbnMgZm9yIGFjY2VzcyB0byBkYXRhIHRoYXQgaXMgc2VjdXJlZCBieSBhY2Nlc3MgcG9saWNpZXMuXG4gICAqL1xuICBhdXRoOiBTdXBhYmFzZUF1dGhDbGllbnRcbiAgcmVhbHRpbWU6IFJlYWx0aW1lQ2xpZW50XG5cbiAgcHJvdGVjdGVkIHJlYWx0aW1lVXJsOiBzdHJpbmdcbiAgcHJvdGVjdGVkIGF1dGhVcmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgc3RvcmFnZVVybDogc3RyaW5nXG4gIHByb3RlY3RlZCBmdW5jdGlvbnNVcmw6IHN0cmluZ1xuICBwcm90ZWN0ZWQgcmVzdDogUG9zdGdyZXN0Q2xpZW50PERhdGFiYXNlLCBTY2hlbWFOYW1lLCBTY2hlbWE+XG4gIHByb3RlY3RlZCBzdG9yYWdlS2V5OiBzdHJpbmdcbiAgcHJvdGVjdGVkIGZldGNoPzogRmV0Y2hcbiAgcHJvdGVjdGVkIGNoYW5nZWRBY2Nlc3NUb2tlbj86IHN0cmluZ1xuICBwcm90ZWN0ZWQgYWNjZXNzVG9rZW4/OiAoKSA9PiBQcm9taXNlPHN0cmluZyB8IG51bGw+XG5cbiAgcHJvdGVjdGVkIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGNsaWVudCBmb3IgdXNlIGluIHRoZSBicm93c2VyLlxuICAgKiBAcGFyYW0gc3VwYWJhc2VVcmwgVGhlIHVuaXF1ZSBTdXBhYmFzZSBVUkwgd2hpY2ggaXMgc3VwcGxpZWQgd2hlbiB5b3UgY3JlYXRlIGEgbmV3IHByb2plY3QgaW4geW91ciBwcm9qZWN0IGRhc2hib2FyZC5cbiAgICogQHBhcmFtIHN1cGFiYXNlS2V5IFRoZSB1bmlxdWUgU3VwYWJhc2UgS2V5IHdoaWNoIGlzIHN1cHBsaWVkIHdoZW4geW91IGNyZWF0ZSBhIG5ldyBwcm9qZWN0IGluIHlvdXIgcHJvamVjdCBkYXNoYm9hcmQuXG4gICAqIEBwYXJhbSBvcHRpb25zLmRiLnNjaGVtYSBZb3UgY2FuIHN3aXRjaCBpbiBiZXR3ZWVuIHNjaGVtYXMuIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuYXV0aC5hdXRvUmVmcmVzaFRva2VuIFNldCB0byBcInRydWVcIiBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlZnJlc2ggdGhlIHRva2VuIGJlZm9yZSBleHBpcmluZy5cbiAgICogQHBhcmFtIG9wdGlvbnMuYXV0aC5wZXJzaXN0U2Vzc2lvbiBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSBzYXZlIHRoZSB1c2VyIHNlc3Npb24gaW50byBsb2NhbCBzdG9yYWdlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5hdXRoLmRldGVjdFNlc3Npb25JblVybCBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSBkZXRlY3RzIE9BdXRoIGdyYW50cyBpbiB0aGUgVVJMIGFuZCBzaWducyBpbiB0aGUgdXNlci5cbiAgICogQHBhcmFtIG9wdGlvbnMucmVhbHRpbWUgT3B0aW9ucyBwYXNzZWQgYWxvbmcgdG8gcmVhbHRpbWUtanMgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSBvcHRpb25zLmdsb2JhbC5mZXRjaCBBIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvbi5cbiAgICogQHBhcmFtIG9wdGlvbnMuZ2xvYmFsLmhlYWRlcnMgQW55IGFkZGl0aW9uYWwgaGVhZGVycyB0byBzZW5kIHdpdGggZWFjaCBuZXR3b3JrIHJlcXVlc3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgc3VwYWJhc2VVcmw6IHN0cmluZyxcbiAgICBwcm90ZWN0ZWQgc3VwYWJhc2VLZXk6IHN0cmluZyxcbiAgICBvcHRpb25zPzogU3VwYWJhc2VDbGllbnRPcHRpb25zPFNjaGVtYU5hbWU+XG4gICkge1xuICAgIGlmICghc3VwYWJhc2VVcmwpIHRocm93IG5ldyBFcnJvcignc3VwYWJhc2VVcmwgaXMgcmVxdWlyZWQuJylcbiAgICBpZiAoIXN1cGFiYXNlS2V5KSB0aHJvdyBuZXcgRXJyb3IoJ3N1cGFiYXNlS2V5IGlzIHJlcXVpcmVkLicpXG5cbiAgICBjb25zdCBfc3VwYWJhc2VVcmwgPSBzdHJpcFRyYWlsaW5nU2xhc2goc3VwYWJhc2VVcmwpXG5cbiAgICB0aGlzLnJlYWx0aW1lVXJsID0gYCR7X3N1cGFiYXNlVXJsfS9yZWFsdGltZS92MWAucmVwbGFjZSgvXmh0dHAvaSwgJ3dzJylcbiAgICB0aGlzLmF1dGhVcmwgPSBgJHtfc3VwYWJhc2VVcmx9L2F1dGgvdjFgXG4gICAgdGhpcy5zdG9yYWdlVXJsID0gYCR7X3N1cGFiYXNlVXJsfS9zdG9yYWdlL3YxYFxuICAgIHRoaXMuZnVuY3Rpb25zVXJsID0gYCR7X3N1cGFiYXNlVXJsfS9mdW5jdGlvbnMvdjFgXG5cbiAgICAvLyBkZWZhdWx0IHN0b3JhZ2Uga2V5IHVzZXMgdGhlIHN1cGFiYXNlIHByb2plY3QgcmVmIGFzIGEgbmFtZXNwYWNlXG4gICAgY29uc3QgZGVmYXVsdFN0b3JhZ2VLZXkgPSBgc2ItJHtuZXcgVVJMKHRoaXMuYXV0aFVybCkuaG9zdG5hbWUuc3BsaXQoJy4nKVswXX0tYXV0aC10b2tlbmBcbiAgICBjb25zdCBERUZBVUxUUyA9IHtcbiAgICAgIGRiOiBERUZBVUxUX0RCX09QVElPTlMsXG4gICAgICByZWFsdGltZTogREVGQVVMVF9SRUFMVElNRV9PUFRJT05TLFxuICAgICAgYXV0aDogeyAuLi5ERUZBVUxUX0FVVEhfT1BUSU9OUywgc3RvcmFnZUtleTogZGVmYXVsdFN0b3JhZ2VLZXkgfSxcbiAgICAgIGdsb2JhbDogREVGQVVMVF9HTE9CQUxfT1BUSU9OUyxcbiAgICB9XG5cbiAgICBjb25zdCBzZXR0aW5ncyA9IGFwcGx5U2V0dGluZ0RlZmF1bHRzKG9wdGlvbnMgPz8ge30sIERFRkFVTFRTKVxuXG4gICAgdGhpcy5zdG9yYWdlS2V5ID0gc2V0dGluZ3MuYXV0aC5zdG9yYWdlS2V5ID8/ICcnXG4gICAgdGhpcy5oZWFkZXJzID0gc2V0dGluZ3MuZ2xvYmFsLmhlYWRlcnMgPz8ge31cblxuICAgIGlmICghc2V0dGluZ3MuYWNjZXNzVG9rZW4pIHtcbiAgICAgIHRoaXMuYXV0aCA9IHRoaXMuX2luaXRTdXBhYmFzZUF1dGhDbGllbnQoXG4gICAgICAgIHNldHRpbmdzLmF1dGggPz8ge30sXG4gICAgICAgIHRoaXMuaGVhZGVycyxcbiAgICAgICAgc2V0dGluZ3MuZ2xvYmFsLmZldGNoXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBzZXR0aW5ncy5hY2Nlc3NUb2tlblxuXG4gICAgICB0aGlzLmF1dGggPSBuZXcgUHJveHk8U3VwYWJhc2VBdXRoQ2xpZW50Pih7fSBhcyBhbnksIHtcbiAgICAgICAgZ2V0OiAoXywgcHJvcCkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBAc3VwYWJhc2Uvc3VwYWJhc2UtanM6IFN1cGFiYXNlIENsaWVudCBpcyBjb25maWd1cmVkIHdpdGggdGhlIGFjY2Vzc1Rva2VuIG9wdGlvbiwgYWNjZXNzaW5nIHN1cGFiYXNlLmF1dGguJHtTdHJpbmcoXG4gICAgICAgICAgICAgIHByb3BcbiAgICAgICAgICAgICl9IGlzIG5vdCBwb3NzaWJsZWBcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuZmV0Y2ggPSBmZXRjaFdpdGhBdXRoKHN1cGFiYXNlS2V5LCB0aGlzLl9nZXRBY2Nlc3NUb2tlbi5iaW5kKHRoaXMpLCBzZXR0aW5ncy5nbG9iYWwuZmV0Y2gpXG4gICAgdGhpcy5yZWFsdGltZSA9IHRoaXMuX2luaXRSZWFsdGltZUNsaWVudCh7XG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBhY2Nlc3NUb2tlbjogdGhpcy5fZ2V0QWNjZXNzVG9rZW4uYmluZCh0aGlzKSxcbiAgICAgIC4uLnNldHRpbmdzLnJlYWx0aW1lLFxuICAgIH0pXG4gICAgdGhpcy5yZXN0ID0gbmV3IFBvc3RncmVzdENsaWVudChgJHtfc3VwYWJhc2VVcmx9L3Jlc3QvdjFgLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IHNldHRpbmdzLmRiLnNjaGVtYSxcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgIH0pXG5cbiAgICBpZiAoIXNldHRpbmdzLmFjY2Vzc1Rva2VuKSB7XG4gICAgICB0aGlzLl9saXN0ZW5Gb3JBdXRoRXZlbnRzKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3VwYWJhc2UgRnVuY3Rpb25zIGFsbG93cyB5b3UgdG8gZGVwbG95IGFuZCBpbnZva2UgZWRnZSBmdW5jdGlvbnMuXG4gICAqL1xuICBnZXQgZnVuY3Rpb25zKCk6IEZ1bmN0aW9uc0NsaWVudCB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbnNDbGllbnQodGhpcy5mdW5jdGlvbnNVcmwsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIGN1c3RvbUZldGNoOiB0aGlzLmZldGNoLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU3VwYWJhc2UgU3RvcmFnZSBhbGxvd3MgeW91IHRvIG1hbmFnZSB1c2VyLWdlbmVyYXRlZCBjb250ZW50LCBzdWNoIGFzIHBob3RvcyBvciB2aWRlb3MuXG4gICAqL1xuICBnZXQgc3RvcmFnZSgpOiBTdXBhYmFzZVN0b3JhZ2VDbGllbnQge1xuICAgIHJldHVybiBuZXcgU3VwYWJhc2VTdG9yYWdlQ2xpZW50KHRoaXMuc3RvcmFnZVVybCwgdGhpcy5oZWFkZXJzLCB0aGlzLmZldGNoKVxuICB9XG5cbiAgLy8gTk9URTogc2lnbmF0dXJlcyBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIFBvc3RncmVzdENsaWVudC5mcm9tXG4gIGZyb208XG4gICAgVGFibGVOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgU2NoZW1hWydUYWJsZXMnXSxcbiAgICBUYWJsZSBleHRlbmRzIFNjaGVtYVsnVGFibGVzJ11bVGFibGVOYW1lXVxuICA+KHJlbGF0aW9uOiBUYWJsZU5hbWUpOiBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8U2NoZW1hLCBUYWJsZSwgVGFibGVOYW1lPlxuICBmcm9tPFZpZXdOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgU2NoZW1hWydWaWV3cyddLCBWaWV3IGV4dGVuZHMgU2NoZW1hWydWaWV3cyddW1ZpZXdOYW1lXT4oXG4gICAgcmVsYXRpb246IFZpZXdOYW1lXG4gICk6IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjxTY2hlbWEsIFZpZXcsIFZpZXdOYW1lPlxuICAvKipcbiAgICogUGVyZm9ybSBhIHF1ZXJ5IG9uIGEgdGFibGUgb3IgYSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gcmVsYXRpb24gLSBUaGUgdGFibGUgb3IgdmlldyBuYW1lIHRvIHF1ZXJ5XG4gICAqL1xuICBmcm9tKHJlbGF0aW9uOiBzdHJpbmcpOiBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI8U2NoZW1hLCBhbnksIGFueT4ge1xuICAgIHJldHVybiB0aGlzLnJlc3QuZnJvbShyZWxhdGlvbilcbiAgfVxuXG4gIC8vIE5PVEU6IHNpZ25hdHVyZXMgbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCBQb3N0Z3Jlc3RDbGllbnQuc2NoZW1hXG4gIC8qKlxuICAgKiBTZWxlY3QgYSBzY2hlbWEgdG8gcXVlcnkgb3IgcGVyZm9ybSBhbiBmdW5jdGlvbiAocnBjKSBjYWxsLlxuICAgKlxuICAgKiBUaGUgc2NoZW1hIG5lZWRzIHRvIGJlIG9uIHRoZSBsaXN0IG9mIGV4cG9zZWQgc2NoZW1hcyBpbnNpZGUgU3VwYWJhc2UuXG4gICAqXG4gICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIHF1ZXJ5XG4gICAqL1xuICBzY2hlbWE8RHluYW1pY1NjaGVtYSBleHRlbmRzIHN0cmluZyAmIGtleW9mIERhdGFiYXNlPihcbiAgICBzY2hlbWE6IER5bmFtaWNTY2hlbWFcbiAgKTogUG9zdGdyZXN0Q2xpZW50PFxuICAgIERhdGFiYXNlLFxuICAgIER5bmFtaWNTY2hlbWEsXG4gICAgRGF0YWJhc2VbRHluYW1pY1NjaGVtYV0gZXh0ZW5kcyBHZW5lcmljU2NoZW1hID8gRGF0YWJhc2VbRHluYW1pY1NjaGVtYV0gOiBhbnlcbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5zY2hlbWE8RHluYW1pY1NjaGVtYT4oc2NoZW1hKVxuICB9XG5cbiAgLy8gTk9URTogc2lnbmF0dXJlcyBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIFBvc3RncmVzdENsaWVudC5ycGNcbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBmdW5jdGlvbiBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gbmFtZSB0byBjYWxsXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBjYWxsXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG4gICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICogQHBhcmFtIG9wdGlvbnMuZ2V0IC0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aFxuICAgKiByZWFkLW9ubHkgYWNjZXNzIG1vZGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIHJldHVybmVkIGJ5IHRoZVxuICAgKiBmdW5jdGlvbi4gT25seSBhcHBsaWNhYmxlIGZvciBbc2V0LXJldHVybmluZ1xuICAgKiBmdW5jdGlvbnNdKGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9mdW5jdGlvbnMtc3JmLmh0bWwpLlxuICAgKlxuICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAqIGhvb2QuXG4gICAqXG4gICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAqXG4gICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICogbnVtYmVycy5cbiAgICovXG4gIHJwYzxGbk5hbWUgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBTY2hlbWFbJ0Z1bmN0aW9ucyddLCBGbiBleHRlbmRzIFNjaGVtYVsnRnVuY3Rpb25zJ11bRm5OYW1lXT4oXG4gICAgZm46IEZuTmFtZSxcbiAgICBhcmdzOiBGblsnQXJncyddID0ge30sXG4gICAgb3B0aW9uczoge1xuICAgICAgaGVhZD86IGJvb2xlYW5cbiAgICAgIGdldD86IGJvb2xlYW5cbiAgICAgIGNvdW50PzogJ2V4YWN0JyB8ICdwbGFubmVkJyB8ICdlc3RpbWF0ZWQnXG4gICAgfSA9IHt9XG4gICk6IFBvc3RncmVzdEZpbHRlckJ1aWxkZXI8XG4gICAgU2NoZW1hLFxuICAgIEZuWydSZXR1cm5zJ10gZXh0ZW5kcyBhbnlbXVxuICAgICAgPyBGblsnUmV0dXJucyddW251bWJlcl0gZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICAgICAgICA/IEZuWydSZXR1cm5zJ11bbnVtYmVyXVxuICAgICAgICA6IG5ldmVyXG4gICAgICA6IG5ldmVyLFxuICAgIEZuWydSZXR1cm5zJ10sXG4gICAgRm5OYW1lLFxuICAgIG51bGxcbiAgPiB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5ycGMoZm4sIGFyZ3MsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlYWx0aW1lIGNoYW5uZWwgd2l0aCBCcm9hZGNhc3QsIFByZXNlbmNlLCBhbmQgUG9zdGdyZXMgQ2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBSZWFsdGltZSBjaGFubmVsLlxuICAgKlxuICAgKi9cbiAgY2hhbm5lbChuYW1lOiBzdHJpbmcsIG9wdHM6IFJlYWx0aW1lQ2hhbm5lbE9wdGlvbnMgPSB7IGNvbmZpZzoge30gfSk6IFJlYWx0aW1lQ2hhbm5lbCB7XG4gICAgcmV0dXJuIHRoaXMucmVhbHRpbWUuY2hhbm5lbChuYW1lLCBvcHRzKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIFJlYWx0aW1lIGNoYW5uZWxzLlxuICAgKi9cbiAgZ2V0Q2hhbm5lbHMoKTogUmVhbHRpbWVDaGFubmVsW10ge1xuICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLmdldENoYW5uZWxzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgUmVhbHRpbWUgY2hhbm5lbCBmcm9tIFJlYWx0aW1lIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFsdGltZUNoYW5uZWx9IGNoYW5uZWwgLSBUaGUgbmFtZSBvZiB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cbiAgICpcbiAgICovXG4gIHJlbW92ZUNoYW5uZWwoY2hhbm5lbDogUmVhbHRpbWVDaGFubmVsKTogUHJvbWlzZTwnb2snIHwgJ3RpbWVkIG91dCcgfCAnZXJyb3InPiB7XG4gICAgcmV0dXJuIHRoaXMucmVhbHRpbWUucmVtb3ZlQ2hhbm5lbChjaGFubmVsKVxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhbGwgUmVhbHRpbWUgY2hhbm5lbHMgZnJvbSBSZWFsdGltZSBjbGllbnQuXG4gICAqL1xuICByZW1vdmVBbGxDaGFubmVscygpOiBQcm9taXNlPCgnb2snIHwgJ3RpbWVkIG91dCcgfCAnZXJyb3InKVtdPiB7XG4gICAgcmV0dXJuIHRoaXMucmVhbHRpbWUucmVtb3ZlQWxsQ2hhbm5lbHMoKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0QWNjZXNzVG9rZW4oKSB7XG4gICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFjY2Vzc1Rva2VuKClcbiAgICB9XG5cbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHRoaXMuYXV0aC5nZXRTZXNzaW9uKClcblxuICAgIHJldHVybiBkYXRhLnNlc3Npb24/LmFjY2Vzc190b2tlbiA/PyBudWxsXG4gIH1cblxuICBwcml2YXRlIF9pbml0U3VwYWJhc2VBdXRoQ2xpZW50KFxuICAgIHtcbiAgICAgIGF1dG9SZWZyZXNoVG9rZW4sXG4gICAgICBwZXJzaXN0U2Vzc2lvbixcbiAgICAgIGRldGVjdFNlc3Npb25JblVybCxcbiAgICAgIHN0b3JhZ2UsXG4gICAgICBzdG9yYWdlS2V5LFxuICAgICAgZmxvd1R5cGUsXG4gICAgICBsb2NrLFxuICAgICAgZGVidWcsXG4gICAgfTogU3VwYWJhc2VBdXRoQ2xpZW50T3B0aW9ucyxcbiAgICBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgICBmZXRjaD86IEZldGNoXG4gICkge1xuICAgIGNvbnN0IGF1dGhIZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuc3VwYWJhc2VLZXl9YCxcbiAgICAgIGFwaWtleTogYCR7dGhpcy5zdXBhYmFzZUtleX1gLFxuICAgIH1cbiAgICByZXR1cm4gbmV3IFN1cGFiYXNlQXV0aENsaWVudCh7XG4gICAgICB1cmw6IHRoaXMuYXV0aFVybCxcbiAgICAgIGhlYWRlcnM6IHsgLi4uYXV0aEhlYWRlcnMsIC4uLmhlYWRlcnMgfSxcbiAgICAgIHN0b3JhZ2VLZXk6IHN0b3JhZ2VLZXksXG4gICAgICBhdXRvUmVmcmVzaFRva2VuLFxuICAgICAgcGVyc2lzdFNlc3Npb24sXG4gICAgICBkZXRlY3RTZXNzaW9uSW5VcmwsXG4gICAgICBzdG9yYWdlLFxuICAgICAgZmxvd1R5cGUsXG4gICAgICBsb2NrLFxuICAgICAgZGVidWcsXG4gICAgICBmZXRjaCxcbiAgICAgIC8vIGF1dGggY2hlY2tzIGlmIHRoZXJlIGlzIGEgY3VzdG9tIGF1dGhvcml6YWl0b24gaGVhZGVyIHVzaW5nIHRoaXMgZmxhZ1xuICAgICAgLy8gc28gaXQga25vd3Mgd2hldGhlciB0byByZXR1cm4gYW4gZXJyb3Igd2hlbiBnZXRVc2VyIGlzIGNhbGxlZCB3aXRoIG5vIHNlc3Npb25cbiAgICAgIGhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXI6ICdBdXRob3JpemF0aW9uJyBpbiB0aGlzLmhlYWRlcnMsXG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgX2luaXRSZWFsdGltZUNsaWVudChvcHRpb25zOiBSZWFsdGltZUNsaWVudE9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlYWx0aW1lQ2xpZW50KHRoaXMucmVhbHRpbWVVcmwsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBwYXJhbXM6IHsgLi4ueyBhcGlrZXk6IHRoaXMuc3VwYWJhc2VLZXkgfSwgLi4ub3B0aW9ucz8ucGFyYW1zIH0sXG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgX2xpc3RlbkZvckF1dGhFdmVudHMoKSB7XG4gICAgbGV0IGRhdGEgPSB0aGlzLmF1dGgub25BdXRoU3RhdGVDaGFuZ2UoKGV2ZW50LCBzZXNzaW9uKSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVUb2tlbkNoYW5nZWQoZXZlbnQsICdDTElFTlQnLCBzZXNzaW9uPy5hY2Nlc3NfdG9rZW4pXG4gICAgfSlcbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgcHJpdmF0ZSBfaGFuZGxlVG9rZW5DaGFuZ2VkKFxuICAgIGV2ZW50OiBBdXRoQ2hhbmdlRXZlbnQsXG4gICAgc291cmNlOiAnQ0xJRU5UJyB8ICdTVE9SQUdFJyxcbiAgICB0b2tlbj86IHN0cmluZ1xuICApIHtcbiAgICBpZiAoXG4gICAgICAoZXZlbnQgPT09ICdUT0tFTl9SRUZSRVNIRUQnIHx8IGV2ZW50ID09PSAnU0lHTkVEX0lOJykgJiZcbiAgICAgIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuICE9PSB0b2tlblxuICAgICkge1xuICAgICAgdGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gPSB0b2tlblxuICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09ICdTSUdORURfT1VUJykge1xuICAgICAgdGhpcy5yZWFsdGltZS5zZXRBdXRoKClcbiAgICAgIGlmIChzb3VyY2UgPT0gJ1NUT1JBR0UnKSB0aGlzLmF1dGguc2lnbk91dCgpXG4gICAgICB0aGlzLmNoYW5nZWRBY2Nlc3NUb2tlbiA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCBTdXBhYmFzZUNsaWVudCBmcm9tICcuL1N1cGFiYXNlQ2xpZW50J1xuaW1wb3J0IHR5cGUgeyBHZW5lcmljU2NoZW1hLCBTdXBhYmFzZUNsaWVudE9wdGlvbnMgfSBmcm9tICcuL2xpYi90eXBlcydcblxuZXhwb3J0ICogZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG5leHBvcnQgdHlwZSB7IFVzZXIgYXMgQXV0aFVzZXIsIFNlc3Npb24gYXMgQXV0aFNlc3Npb24gfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbmV4cG9ydCB7XG4gIHR5cGUgUG9zdGdyZXN0UmVzcG9uc2UsXG4gIHR5cGUgUG9zdGdyZXN0U2luZ2xlUmVzcG9uc2UsXG4gIHR5cGUgUG9zdGdyZXN0TWF5YmVTaW5nbGVSZXNwb25zZSxcbiAgUG9zdGdyZXN0RXJyb3IsXG59IGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnXG5leHBvcnQge1xuICBGdW5jdGlvbnNIdHRwRXJyb3IsXG4gIEZ1bmN0aW9uc0ZldGNoRXJyb3IsXG4gIEZ1bmN0aW9uc1JlbGF5RXJyb3IsXG4gIEZ1bmN0aW9uc0Vycm9yLFxuICB0eXBlIEZ1bmN0aW9uSW52b2tlT3B0aW9ucyxcbiAgRnVuY3Rpb25SZWdpb24sXG59IGZyb20gJ0BzdXBhYmFzZS9mdW5jdGlvbnMtanMnXG5leHBvcnQgKiBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFN1cGFiYXNlQ2xpZW50IH0gZnJvbSAnLi9TdXBhYmFzZUNsaWVudCdcbmV4cG9ydCB0eXBlIHsgU3VwYWJhc2VDbGllbnRPcHRpb25zLCBRdWVyeVJlc3VsdCwgUXVlcnlEYXRhLCBRdWVyeUVycm9yIH0gZnJvbSAnLi9saWIvdHlwZXMnXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTdXBhYmFzZSBDbGllbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVDbGllbnQgPSA8XG4gIERhdGFiYXNlID0gYW55LFxuICBTY2hlbWFOYW1lIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgRGF0YWJhc2UgPSAncHVibGljJyBleHRlbmRzIGtleW9mIERhdGFiYXNlXG4gICAgPyAncHVibGljJ1xuICAgIDogc3RyaW5nICYga2V5b2YgRGF0YWJhc2UsXG4gIFNjaGVtYSBleHRlbmRzIEdlbmVyaWNTY2hlbWEgPSBEYXRhYmFzZVtTY2hlbWFOYW1lXSBleHRlbmRzIEdlbmVyaWNTY2hlbWFcbiAgICA/IERhdGFiYXNlW1NjaGVtYU5hbWVdXG4gICAgOiBhbnlcbj4oXG4gIHN1cGFiYXNlVXJsOiBzdHJpbmcsXG4gIHN1cGFiYXNlS2V5OiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBTdXBhYmFzZUNsaWVudE9wdGlvbnM8U2NoZW1hTmFtZT5cbik6IFN1cGFiYXNlQ2xpZW50PERhdGFiYXNlLCBTY2hlbWFOYW1lLCBTY2hlbWE+ID0+IHtcbiAgcmV0dXJuIG5ldyBTdXBhYmFzZUNsaWVudDxEYXRhYmFzZSwgU2NoZW1hTmFtZSwgU2NoZW1hPihzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpXG59XG4iLCAiLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGNodW5raW5nIHRleHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaHVua1NldHRpbmdzIHtcblx0Y2h1bmtTaXplOiBudW1iZXI7ICAgICAgIC8vIFNpemUgb2YgZWFjaCBjaHVuayBpbiBjaGFyYWN0ZXJzXG5cdGNodW5rT3ZlcmxhcDogbnVtYmVyOyAgICAvLyBPdmVybGFwIGJldHdlZW4gY2h1bmtzXG5cdG1pbkNodW5rU2l6ZTogbnVtYmVyOyAgICAvLyBNaW5pbXVtIHNpemUgb2YgYSBjaHVua1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGV4Y2x1ZGVkIHBhdGhzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXhjbHVzaW9uU2V0dGluZ3Mge1xuXHRleGNsdWRlZEZvbGRlcnM6IHN0cmluZ1tdOyAgICAgIC8vIFVzZXItZGVmaW5lZCBmb2xkZXJzIHRvIGV4Y2x1ZGUgZnJvbSBwcm9jZXNzaW5nXG5cdGV4Y2x1ZGVkRmlsZVR5cGVzOiBzdHJpbmdbXTsgICAgLy8gVXNlci1kZWZpbmVkIGZpbGUgZXh0ZW5zaW9ucyB0byBleGNsdWRlXG5cdGV4Y2x1ZGVkRmlsZVByZWZpeGVzOiBzdHJpbmdbXTsgLy8gVXNlci1kZWZpbmVkIGZpbGUgbmFtZSBwcmVmaXhlcyB0byBleGNsdWRlXG5cdGV4Y2x1ZGVkRmlsZXM6IHN0cmluZ1tdOyAgICAgICAgLy8gVXNlci1kZWZpbmVkIHNwZWNpZmljIGZpbGVzIHRvIGV4Y2x1ZGVcblx0Ly8gU3lzdGVtLWxldmVsIGV4Y2x1c2lvbnMgdGhhdCBhcmUgYWx3YXlzIGFwcGxpZWQgYnV0IG5vdCBzaG93biBpbiBVSVxuXHRzeXN0ZW1FeGNsdWRlZEZvbGRlcnM6IHN0cmluZ1tdO1xuXHRzeXN0ZW1FeGNsdWRlZEZpbGVUeXBlczogc3RyaW5nW107XG5cdHN5c3RlbUV4Y2x1ZGVkRmlsZVByZWZpeGVzOiBzdHJpbmdbXTtcblx0c3lzdGVtRXhjbHVkZWRGaWxlczogc3RyaW5nW107XG59XG5cbi8qKlxuICogT3BlbkFJIEFQSSBzZXR0aW5nc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIE9wZW5BSVNldHRpbmdzIHtcblx0YXBpS2V5OiBzdHJpbmc7ICAgICAgICAgLy8gQVBJIGtleSBmb3IgT3BlbkFJXG5cdG1vZGVsOiBzdHJpbmc7ICAgICAgICAgIC8vIE1vZGVsIHRvIHVzZSBmb3IgZW1iZWRkaW5nc1xuXHRtYXhUb2tlbnM6IG51bWJlcjsgICAgICAvLyBNYXhpbXVtIHRva2VucyBmb3IgYSBzaW5nbGUgcmVxdWVzdFxuXHR0ZW1wZXJhdHVyZTogbnVtYmVyOyAgICAvLyBTYW1wbGluZyB0ZW1wZXJhdHVyZSBmb3IgZ2VuZXJhdGlvblxufVxuXG4vKipcbiAqIFN1cGFiYXNlIGNvbm5lY3Rpb24gc2V0dGluZ3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdXBhYmFzZVNldHRpbmdzIHtcblx0dXJsOiBzdHJpbmc7ICAgICAgICAgICAgICAvLyBTdXBhYmFzZSBwcm9qZWN0IFVSTFxuXHRhcGlLZXk6IHN0cmluZzsgICAgICAgICAgLy8gU3VwYWJhc2UgQVBJIGtleVxuXHRpbml0aWFsaXplZD86IGJvb2xlYW47ICAgIC8vIFdoZXRoZXIgZGF0YWJhc2UgaXMgaW5pdGlhbGl6ZWRcblx0bGFzdFNldHVwQXR0ZW1wdD86IG51bWJlcjsgLy8gVGltZXN0YW1wIG9mIGxhc3Qgc2V0dXAgYXR0ZW1wdFxuXHRzZXR1cFJldHJpZXM/OiBudW1iZXI7ICAgIC8vIE51bWJlciBvZiBzZXR1cCBhdHRlbXB0c1xufVxuXG4vKipcbiAqIFByb2Nlc3NpbmcgcXVldWUgc2V0dGluZ3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBRdWV1ZVNldHRpbmdzIHtcblx0bWF4Q29uY3VycmVudDogbnVtYmVyOyAgLy8gTWF4aW11bSBjb25jdXJyZW50IHRhc2tzXG5cdHJldHJ5QXR0ZW1wdHM6IG51bWJlcjsgIC8vIE51bWJlciBvZiByZXRyeSBhdHRlbXB0c1xuXHRyZXRyeURlbGF5OiBudW1iZXI7ICAgICAvLyBEZWxheSBiZXR3ZWVuIHJldHJpZXMgaW4gbWlsbGlzZWNvbmRzXG59XG5cbi8qKlxuICogRGVidWcgYW5kIGxvZ2dpbmcgc2V0dGluZ3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZWJ1Z1NldHRpbmdzIHtcblx0ZW5hYmxlRGVidWdMb2dzOiBib29sZWFuOyAgLy8gRW5hYmxlIGRldGFpbGVkIGRlYnVnIGxvZ3Ncblx0bG9nTGV2ZWw6ICdlcnJvcicgfCAnd2FybicgfCAnaW5mbycgfCAnZGVidWcnOyAgLy8gTG9nZ2luZyBsZXZlbFxuXHRsb2dUb0ZpbGU6IGJvb2xlYW47ICAgICAgICAvLyBXaGV0aGVyIHRvIGxvZyB0byBhIGZpbGVcbn1cblxuLyoqXG4gKiBEZXZpY2UgaW5mb3JtYXRpb24gZm9yIGNyb3NzLWRldmljZSBjb29yZGluYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZXZpY2VJbmZvIHtcblx0ZGV2aWNlSWQ6IHN0cmluZzsgICAgICAgICAvLyBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGRldmljZVxuXHRuYW1lOiBzdHJpbmc7ICAgICAgICAgICAgIC8vIFVzZXItZnJpZW5kbHkgbmFtZSBmb3IgdGhlIGRldmljZVxuXHRwbGF0Zm9ybTogc3RyaW5nOyAgICAgICAgIC8vIE9wZXJhdGluZyBzeXN0ZW0vcGxhdGZvcm1cblx0bGFzdFNlZW46IG51bWJlcjsgICAgICAgICAvLyBUaW1lc3RhbXAgd2hlbiBkZXZpY2Ugd2FzIGxhc3QgYWN0aXZlXG5cdGxhc3RTeW5jVGltZTogbnVtYmVyOyAgICAgLy8gVGltZXN0YW1wIG9mIGxhc3Qgc3VjY2Vzc2Z1bCBzeW5jXG59XG5cbi8qKlxuICogRW5oYW5jZWQgc3luYyBzZXR0aW5ncyB3aXRoIGNyb3NzLWRldmljZSBjb29yZGluYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTeW5jU2V0dGluZ3Mge1xuXHRzeW5jRmlsZVBhdGg6IHN0cmluZzsgICAgICAgICAgIC8vIFBhdGggdG8gdGhlIHN5bmMgZmlsZVxuXHRiYWNrdXBJbnRlcnZhbDogbnVtYmVyOyAgICAgICAgIC8vIFRpbWUgYmV0d2VlbiBiYWNrdXBzIChtcylcblx0Y2hlY2tJbnRlcnZhbDogbnVtYmVyOyAgICAgICAgICAvLyBUaW1lIGJldHdlZW4gc3luYyBjaGVja3MgKG1zKVxuXHRjaGVja0F0dGVtcHRzOiBudW1iZXI7ICAgICAgICAgIC8vIE51bWJlciBvZiBzeW5jIGNoZWNrIGF0dGVtcHRzXG5cdHRpbWVvdXQ6IG51bWJlcjsgICAgICAgICAgICAgICAgLy8gVGltZW91dCBmb3Igc3luYyBvcGVyYXRpb25zIChtcylcblx0cmVxdWlyZVN5bmM6IGJvb2xlYW47ICAgICAgICAgICAvLyBXaGV0aGVyIHN5bmMgaXMgcmVxdWlyZWQgYmVmb3JlIHN0YXJ0dXBcblx0Ly8gTmV3IGNyb3NzLWRldmljZSBzZXR0aW5nc1xuXHRkZXZpY2VJZDogc3RyaW5nOyAgICAgICAgICAgICAgIC8vIFVuaXF1ZSBpZGVudGlmaWVyIGZvciBjdXJyZW50IGRldmljZVxuXHRkZXZpY2VOYW1lOiBzdHJpbmc7ICAgICAgICAgICAgIC8vIFVzZXItY29uZmlndXJhYmxlIGRldmljZSBuYW1lXG5cdGtub3duRGV2aWNlczogRGV2aWNlSW5mb1tdOyAgICAgLy8gSW5mb3JtYXRpb24gYWJvdXQgYWxsIGtub3duIGRldmljZXNcblx0Y29ubmVjdGlvbkNoZWNrSW50ZXJ2YWw6IG51bWJlcjsgLy8gSG93IG9mdGVuIHRvIGNoZWNrIGRhdGFiYXNlIGNvbm5lY3Rpb25cblx0b2ZmbGluZVF1ZXVlRW5hYmxlZDogYm9vbGVhbjsgICAvLyBXaGV0aGVyIHRvIHF1ZXVlIG9wZXJhdGlvbnMgd2hlbiBvZmZsaW5lXG5cdGNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5OiAnbmV3ZXN0LXdpbnMnIHwgJ21hbnVhbCcgfCAna2VlcC1ib3RoJzsgLy8gSG93IHRvIGhhbmRsZSBjb25mbGljdHNcbn1cblxuLyoqXG4gKiBJbml0aWFsIHN5bmMgc2V0dGluZ3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbml0aWFsU3luY1NldHRpbmdzIHtcblx0YmF0Y2hTaXplOiBudW1iZXI7ICAgICAgICAgICAgIC8vIE51bWJlciBvZiBmaWxlcyBwZXIgYmF0Y2hcblx0bWF4Q29uY3VycmVudEJhdGNoZXM6IG51bWJlcjsgIC8vIE1heGltdW0gY29uY3VycmVudCBiYXRjaCBwcm9jZXNzaW5nXG5cdGVuYWJsZUF1dG9Jbml0aWFsU3luYzogYm9vbGVhbjsgLy8gQXV0by1zdGFydCBpbml0aWFsIHN5bmNcblx0cHJpb3JpdHlSdWxlczogUHJpb3JpdHlSdWxlW107IC8vIFJ1bGVzIGZvciBmaWxlIHByb2Nlc3NpbmcgcHJpb3JpdHlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmlvcml0eVJ1bGUge1xuXHRwYXR0ZXJuOiBzdHJpbmc7ICAgLy8gUGF0dGVybiB0byBtYXRjaCBpbiBmaWxlIHBhdGhcblx0cHJpb3JpdHk6IG51bWJlcjsgIC8vIFByaW9yaXR5IGxldmVsIChoaWdoZXIgPSBwcm9jZXNzZWQgZmlyc3QpXG59XG5cbi8qKlxuICogTmV3IHVwZGF0ZSBiZWhhdmlvciBzZXR0aW5ncyBmb3IgZmlsZSBwcm9jZXNzaW5nXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlQmVoYXZpb3JTZXR0aW5ncyB7XG4gICAgZGVib3VuY2VUaW1lOiBudW1iZXI7ICAgICAgICAgICAgICAvLyBEZWJvdW5jZSBkZWxheSBpbiBtaWxsaXNlY29uZHMgZm9yIHVwZGF0ZSBvcGVyYXRpb25zXG4gICAgcHJvY2Vzc2luZ01vZGU6ICdpbnN0YW50JyB8ICdkZWxheWVkJzsgIC8vIFdoZXRoZXIgdXBkYXRlcyBhcmUgcHJvY2Vzc2VkIGluc3RhbnRseSBvciBhZnRlciBhIGRlbGF5XG4gICAgcHJpb3JpdHlPdmVycmlkZTogbnVtYmVyOyAgICAgICAgICAvLyBEZWZhdWx0IHByb2Nlc3NpbmcgcHJpb3JpdHkgb3ZlcnJpZGUgZm9yIHVwZGF0ZSB0YXNrc1xufVxuXG4vKipcbiAqIE1haW4gc2V0dGluZ3MgaW50ZXJmYWNlIGZvciB0aGUgcGx1Z2luXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWluZE1hdHJpeFNldHRpbmdzIHtcblx0Ly8gVmF1bHQgaWRlbnRpZmljYXRpb25cblx0dmF1bHRJZDogc3RyaW5nIHwgbnVsbDsgICAgICAvLyBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHZhdWx0XG5cdGxhc3RLbm93blZhdWx0TmFtZTogc3RyaW5nOyAgLy8gTGFzdCBrbm93biBuYW1lIG9mIHRoZSB2YXVsdFxuXHQvLyBBUEkgQ29uZmlndXJhdGlvblxuXHRzdXBhYmFzZTogU3VwYWJhc2VTZXR0aW5nczsgIC8vIFN1cGFiYXNlIGNvbmZpZ3VyYXRpb25cblx0b3BlbmFpOiBPcGVuQUlTZXR0aW5nczsgICAgICAvLyBPcGVuQUkgY29uZmlndXJhdGlvblxuXHQvLyBQcm9jZXNzaW5nIHNldHRpbmdzXG5cdGNodW5raW5nOiBDaHVua1NldHRpbmdzOyAgICAgLy8gVGV4dCBjaHVua2luZyBzZXR0aW5nc1xuXHRxdWV1ZTogUXVldWVTZXR0aW5nczsgICAgICAgIC8vIFF1ZXVlIHByb2Nlc3Npbmcgc2V0dGluZ3Ncblx0Ly8gRXhjbHVzaW9uIHBhdHRlcm5zXG5cdGV4Y2x1c2lvbnM6IEV4Y2x1c2lvblNldHRpbmdzOyAgLy8gUGF0aHMgYW5kIGZpbGUgdHlwZXMgdG8gZXhjbHVkZVxuXHQvLyBEZWJ1ZyBzZXR0aW5nc1xuXHRkZWJ1ZzogRGVidWdTZXR0aW5nczsgICAgICAgIC8vIERlYnVnZ2luZyBhbmQgbG9nZ2luZyBjb25maWd1cmF0aW9uXG5cdC8vIEZlYXR1cmUgZmxhZ3Ncblx0ZW5hYmxlQXV0b1N5bmM6IGJvb2xlYW47ICAgICAgLy8gRW5hYmxlIGF1dG9tYXRpYyBzeW5jaHJvbml6YXRpb25cblx0ZW5hYmxlTm90aWZpY2F0aW9uczogYm9vbGVhbjsgLy8gU2hvdyBub3RpZmljYXRpb25zIGZvciBhY3Rpb25zXG5cdGVuYWJsZVByb2dyZXNzQmFyOiBib29sZWFuOyAgIC8vIFNob3cgYSBwcm9ncmVzcyBiYXIgZHVyaW5nIHRhc2tzXG5cdC8vIFN5bmMgc2V0dGluZ3Ncblx0c3luYzogU3luY1NldHRpbmdzO1xuXHQvLyBJbml0aWFsIHN5bmMgc2V0dGluZ3Ncblx0aW5pdGlhbFN5bmM6IEluaXRpYWxTeW5jU2V0dGluZ3M7XG5cdC8vIE5ldyB1cGRhdGUgYmVoYXZpb3Igc2V0dGluZ3Ncblx0dXBkYXRlQmVoYXZpb3I6IFVwZGF0ZUJlaGF2aW9yU2V0dGluZ3M7XG59XG5cbi8qKlxuICogRGVmYXVsdCBjaHVua2luZyBvcHRpb25zIGZvciB0ZXh0IHByb2Nlc3NpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ0hVTktJTkdfT1BUSU9OUzogQ2h1bmtTZXR0aW5ncyA9IHtcblx0Y2h1bmtTaXplOiAxMDAwLCAgICAgICAvLyBEZWZhdWx0IHNpemUgb2YgZWFjaCBjaHVuayBpbiBjaGFyYWN0ZXJzXG5cdGNodW5rT3ZlcmxhcDogMjAwLCAgICAgLy8gRGVmYXVsdCBvdmVybGFwIGJldHdlZW4gY2h1bmtzXG5cdG1pbkNodW5rU2l6ZTogMTAwLCAgICAgLy8gTWluaW11bSBjaHVuayBzaXplIHRvIGVuc3VyZSB1c2FiaWxpdHlcbn07XG5cbi8qKlxuICogRGVmYXVsdCB1cGRhdGUgYmVoYXZpb3Igc2V0dGluZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVVBEQVRFX0JFSEFWSU9SOiBVcGRhdGVCZWhhdmlvclNldHRpbmdzID0ge1xuICAgIGRlYm91bmNlVGltZTogMTAwMCwgICAgICAgICAgICAgLy8gMSBzZWNvbmQgZGVib3VuY2UgZGVsYXkgYnkgZGVmYXVsdFxuICAgIHByb2Nlc3NpbmdNb2RlOiAnaW5zdGFudCcsICAgICAgLy8gUHJvY2VzcyB1cGRhdGVzIGluc3RhbnRseSBieSBkZWZhdWx0XG4gICAgcHJpb3JpdHlPdmVycmlkZTogMSAgICAgICAgICAgICAvLyBEZWZhdWx0IHByaW9yaXR5IGxldmVsIGZvciB1cGRhdGUgb3BlcmF0aW9uc1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHVuaXF1ZSBkZXZpY2UgaWRlbnRpZmllclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVEZXZpY2VJZCgpOiBzdHJpbmcge1xuXHRyZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbn1cblxuLyoqXG4gKiBHZXQgcGxhdGZvcm0gaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYXRmb3JtSW5mbygpOiBzdHJpbmcge1xuXHRjb25zdCB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblx0aWYgKHVzZXJBZ2VudC5pbmRleE9mKCdXaW4nKSAhPT0gLTEpIHJldHVybiAnV2luZG93cyc7XG5cdGlmICh1c2VyQWdlbnQuaW5kZXhPZignTWFjJykgIT09IC0xKSByZXR1cm4gJ21hY09TJztcblx0aWYgKHVzZXJBZ2VudC5pbmRleE9mKCdpUGhvbmUnKSAhPT0gLTEgfHwgdXNlckFnZW50LmluZGV4T2YoJ2lQYWQnKSAhPT0gLTEpIHJldHVybiAnaU9TJztcblx0aWYgKHVzZXJBZ2VudC5pbmRleE9mKCdBbmRyb2lkJykgIT09IC0xKSByZXR1cm4gJ0FuZHJvaWQnO1xuXHRpZiAodXNlckFnZW50LmluZGV4T2YoJ0xpbnV4JykgIT09IC0xKSByZXR1cm4gJ0xpbnV4Jztcblx0cmV0dXJuICdVbmtub3duJztcbn1cblxuLyoqXG4gKiBTeXN0ZW0tbGV2ZWwgZXhjbHVzaW9ucyB0aGF0IGFyZSBhbHdheXMgYXBwbGllZCBidXQgbm90IHNob3duIGluIFVJXG4gKi9cbmV4cG9ydCBjb25zdCBTWVNURU1fRVhDTFVTSU9OUyA9IHtcblx0Zm9sZGVyczogW1xuXHRcdCcub2JzaWRpYW4nLCAgICAgICAgICAgLy8gT2JzaWRpYW4gY29uZmlnIGZvbGRlclxuXHRcdCcudHJhc2gnLCAgICAgICAgICAgICAgLy8gT2JzaWRpYW4gdHJhc2ggZm9sZGVyXG5cdFx0Jy5naXQnLCAgICAgICAgICAgICAgICAvLyBHaXQgZm9sZGVyIGlmIHVzZWRcblx0XHQnbm9kZV9tb2R1bGVzJyAgICAgICAgIC8vIE5vZGUgbW9kdWxlcyBpZiB1c2VkXG5cdF0sXG5cdGZpbGVUeXBlczogW1xuXHRcdCcubXAzJywgJy5qcGcnLCAnLnBuZycsICcucGRmJywgLy8gTm9uLW1hcmtkb3duIGZpbGVzXG5cdFx0Jy5leGNhbGlkcmF3JyAgICAgICAgICAgICAgICAgICAgLy8gRXhjYWxpZHJhdyBmaWxlc1xuXHRdLFxuXHRmaWxlUHJlZml4ZXM6IFsnXycsICcuJ10sICAgLy8gSGlkZGVuIGFuZCBzcGVjaWFsIGZpbGVzXG5cdGZpbGVzOiBbXG5cdFx0J19taW5kbWF0cml4c3luYy5tZCcsICAgICAgICAgICAvLyBTeW5jIGZpbGVcblx0XHQnX21pbmRtYXRyaXhzeW5jLm1kLmJhY2t1cCcgICAgIC8vIFN5bmMgYmFja3VwIGZpbGVcblx0XVxufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNldHRpbmdzIHdoZW4gcGx1Z2luIGlzIGZpcnN0IGluaXRpYWxpemVkXG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBNaW5kTWF0cml4U2V0dGluZ3MgPSB7XG5cdHZhdWx0SWQ6IG51bGwsXG5cdGxhc3RLbm93blZhdWx0TmFtZTogJycsXG5cdHN1cGFiYXNlOiB7XG5cdFx0dXJsOiAnJyxcblx0XHRhcGlLZXk6ICcnLFxuXHRcdGluaXRpYWxpemVkOiBmYWxzZSxcblx0XHRsYXN0U2V0dXBBdHRlbXB0OiAwLFxuXHRcdHNldHVwUmV0cmllczogMCxcblx0fSxcblx0b3BlbmFpOiB7XG5cdFx0YXBpS2V5OiAnJyxcblx0XHRtb2RlbDogJ3RleHQtZW1iZWRkaW5nLWFkYS0wMDInLFxuXHRcdG1heFRva2VuczogODAwMCxcblx0XHR0ZW1wZXJhdHVyZTogMC4wLFxuXHR9LFxuXHRjaHVua2luZzogeyAuLi5ERUZBVUxUX0NIVU5LSU5HX09QVElPTlMgfSxcblx0cXVldWU6IHtcblx0XHRtYXhDb25jdXJyZW50OiAzLFxuXHRcdHJldHJ5QXR0ZW1wdHM6IDMsXG5cdFx0cmV0cnlEZWxheTogMTAwMCxcblx0fSxcblx0ZXhjbHVzaW9uczoge1xuXHRcdGV4Y2x1ZGVkRm9sZGVyczogW10sXG5cdFx0ZXhjbHVkZWRGaWxlVHlwZXM6IFtdLFxuXHRcdGV4Y2x1ZGVkRmlsZVByZWZpeGVzOiBbXSxcblx0XHRleGNsdWRlZEZpbGVzOiBbXSxcblx0XHRzeXN0ZW1FeGNsdWRlZEZvbGRlcnM6IFsuLi5TWVNURU1fRVhDTFVTSU9OUy5mb2xkZXJzXSxcblx0XHRzeXN0ZW1FeGNsdWRlZEZpbGVUeXBlczogWy4uLlNZU1RFTV9FWENMVVNJT05TLmZpbGVUeXBlc10sXG5cdFx0c3lzdGVtRXhjbHVkZWRGaWxlUHJlZml4ZXM6IFsuLi5TWVNURU1fRVhDTFVTSU9OUy5maWxlUHJlZml4ZXNdLFxuXHRcdHN5c3RlbUV4Y2x1ZGVkRmlsZXM6IFsuLi5TWVNURU1fRVhDTFVTSU9OUy5maWxlc11cblx0fSxcblx0ZGVidWc6IHtcblx0XHRlbmFibGVEZWJ1Z0xvZ3M6IGZhbHNlLFxuXHRcdGxvZ0xldmVsOiAnaW5mbycsXG5cdFx0bG9nVG9GaWxlOiBmYWxzZSxcblx0fSxcblx0ZW5hYmxlQXV0b1N5bmM6IHRydWUsXG5cdGVuYWJsZU5vdGlmaWNhdGlvbnM6IHRydWUsXG5cdGVuYWJsZVByb2dyZXNzQmFyOiB0cnVlLFxuXHRzeW5jOiB7XG5cdFx0c3luY0ZpbGVQYXRoOiAnX21pbmRtYXRyaXhzeW5jLm1kJyxcblx0XHRiYWNrdXBJbnRlcnZhbDogMzYwMDAwMCwgIC8vIDEgaG91ciBpbiBtaWxsaXNlY29uZHNcblx0XHRjaGVja0ludGVydmFsOiAzMDAwMDAsICAgIC8vIDUgbWludXRlcyBpbiBtaWxsaXNlY29uZHNcblx0XHRjaGVja0F0dGVtcHRzOiAzLFxuXHRcdHRpbWVvdXQ6IDQwMDAwLFxuXHRcdHJlcXVpcmVTeW5jOiB0cnVlLFxuXHRcdGRldmljZUlkOiBnZW5lcmF0ZURldmljZUlkKCksXG5cdFx0ZGV2aWNlTmFtZTogYERldmljZS0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApfWAsXG5cdFx0a25vd25EZXZpY2VzOiBbXSxcblx0XHRjb25uZWN0aW9uQ2hlY2tJbnRlcnZhbDogNjAwMDAsIC8vIDEgbWludXRlXG5cdFx0b2ZmbGluZVF1ZXVlRW5hYmxlZDogdHJ1ZSxcblx0XHRjb25mbGljdFJlc29sdXRpb25TdHJhdGVneTogJ25ld2VzdC13aW5zJ1xuXHR9LFxuXHRpbml0aWFsU3luYzoge1xuXHRcdGJhdGNoU2l6ZTogNTAsXG5cdFx0bWF4Q29uY3VycmVudEJhdGNoZXM6IDMsXG5cdFx0ZW5hYmxlQXV0b0luaXRpYWxTeW5jOiB0cnVlLFxuXHRcdHByaW9yaXR5UnVsZXM6IFtcblx0XHRcdHsgcGF0dGVybjogJ2RhaWx5LycsIHByaW9yaXR5OiAzIH0sXG5cdFx0XHR7IHBhdHRlcm46ICdwcm9qZWN0cy8nLCBwcmlvcml0eTogMiB9LFxuXHRcdFx0eyBwYXR0ZXJuOiAnYXJjaGl2ZS8nLCBwcmlvcml0eTogMSB9XG5cdFx0XVxuXHR9LFxuXHR1cGRhdGVCZWhhdmlvcjoge1xuXHRcdC4uLkRFRkFVTFRfVVBEQVRFX0JFSEFWSU9SXG5cdH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGNvbWJpbmVkIGxpc3Qgb2YgYWxsIGV4Y2x1c2lvbnMgKHN5c3RlbSArIHVzZXIpIHVzZWQgZm9yIHByb2Nlc3NpbmcuXG4gKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW50ZXJuYWxseSBmb3IgZmlsZSBwcm9jZXNzaW5nIGFuZCBjb21iaW5lcyBib3RoIHVzZXItZGVmaW5lZCBhbmQgc3lzdGVtLWxldmVsIGV4Y2x1c2lvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxFeGNsdXNpb25zKHNldHRpbmdzOiBNaW5kTWF0cml4U2V0dGluZ3MpOiB7XG5cdGV4Y2x1ZGVkRm9sZGVyczogc3RyaW5nW10sXG5cdGV4Y2x1ZGVkRmlsZVR5cGVzOiBzdHJpbmdbXSxcblx0ZXhjbHVkZWRGaWxlUHJlZml4ZXM6IHN0cmluZ1tdLFxuXHRleGNsdWRlZEZpbGVzOiBzdHJpbmdbXVxufSB7XG5cdGNvbnN0IGV4Y2x1c2lvbnMgPSBzZXR0aW5ncy5leGNsdXNpb25zO1xuXHRyZXR1cm4ge1xuXHRcdGV4Y2x1ZGVkRm9sZGVyczogW1xuXHRcdFx0Li4uZXhjbHVzaW9ucy5zeXN0ZW1FeGNsdWRlZEZvbGRlcnMgfHwgU1lTVEVNX0VYQ0xVU0lPTlMuZm9sZGVycyxcblx0XHRcdC4uLmV4Y2x1c2lvbnMuZXhjbHVkZWRGb2xkZXJzIHx8IFtdXG5cdFx0XSxcblx0XHRleGNsdWRlZEZpbGVUeXBlczogW1xuXHRcdFx0Li4uZXhjbHVzaW9ucy5zeXN0ZW1FeGNsdWRlZEZpbGVUeXBlcyB8fCBTWVNURU1fRVhDTFVTSU9OUy5maWxlVHlwZXMsXG5cdFx0XHQuLi5leGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVR5cGVzIHx8IFtdXG5cdFx0XSxcblx0XHRleGNsdWRlZEZpbGVQcmVmaXhlczogW1xuXHRcdFx0Li4uZXhjbHVzaW9ucy5zeXN0ZW1FeGNsdWRlZEZpbGVQcmVmaXhlcyB8fCBTWVNURU1fRVhDTFVTSU9OUy5maWxlUHJlZml4ZXMsXG5cdFx0XHQuLi5leGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVByZWZpeGVzIHx8IFtdXG5cdFx0XSxcblx0XHRleGNsdWRlZEZpbGVzOiBbXG5cdFx0XHQuLi5leGNsdXNpb25zLnN5c3RlbUV4Y2x1ZGVkRmlsZXMgfHwgU1lTVEVNX0VYQ0xVU0lPTlMuZmlsZXMsXG5cdFx0XHQuLi5leGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMgfHwgW11cblx0XHRdXG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBvbmx5IHRoZSB1c2VyLWRlZmluZWQgZXhjbHVzaW9ucyAod2l0aG91dCBzeXN0ZW0tbGV2ZWwgZGVmYXVsdHMpLlxuICogVGhpcyBoZWxwZXIgY2FuIGJlIHVzZWQgaW4gVUkgY29tcG9uZW50cyB0byBlbnN1cmUgdGhhdCBzeXN0ZW0gZXhjbHVzaW9ucyByZW1haW4gaGlkZGVuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlckV4Y2x1c2lvbnMoc2V0dGluZ3M6IE1pbmRNYXRyaXhTZXR0aW5ncyk6IHtcblx0ZXhjbHVkZWRGb2xkZXJzOiBzdHJpbmdbXSxcblx0ZXhjbHVkZWRGaWxlVHlwZXM6IHN0cmluZ1tdLFxuXHRleGNsdWRlZEZpbGVQcmVmaXhlczogc3RyaW5nW10sXG5cdGV4Y2x1ZGVkRmlsZXM6IHN0cmluZ1tdXG59IHtcblx0Y29uc3QgZXhjbHVzaW9ucyA9IHNldHRpbmdzLmV4Y2x1c2lvbnM7XG5cdHJldHVybiB7XG5cdFx0ZXhjbHVkZWRGb2xkZXJzOiBleGNsdXNpb25zLmV4Y2x1ZGVkRm9sZGVycyB8fCBbXSxcblx0XHRleGNsdWRlZEZpbGVUeXBlczogZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcyB8fCBbXSxcblx0XHRleGNsdWRlZEZpbGVQcmVmaXhlczogZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVQcmVmaXhlcyB8fCBbXSxcblx0XHRleGNsdWRlZEZpbGVzOiBleGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMgfHwgW11cblx0fTtcbn1cblxuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGEgdmF1bHQgaXMgaW5pdGlhbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhdWx0SW5pdGlhbGl6ZWQoc2V0dGluZ3M6IE1pbmRNYXRyaXhTZXR0aW5ncyk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gc2V0dGluZ3MudmF1bHRJZCAhPT0gbnVsbCAmJiBzZXR0aW5ncy52YXVsdElkICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3MudmF1bHRJZCAhPT0gJyc7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGNyZWF0ZSBhIG5ldyB2YXVsdCBJRC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVmF1bHRJZCgpOiBzdHJpbmcge1xuXHRyZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbn1cbiIsICJpbXBvcnQgeyBjcmVhdGVDbGllbnQsIFN1cGFiYXNlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcbmltcG9ydCB7IERvY3VtZW50Q2h1bmssIERvY3VtZW50TWV0YWRhdGEgfSBmcm9tICcuLi9tb2RlbHMvRG9jdW1lbnRDaHVuayc7XG5pbXBvcnQgeyBNaW5kTWF0cml4U2V0dGluZ3MsIGlzVmF1bHRJbml0aWFsaXplZCB9IGZyb20gJy4uL3NldHRpbmdzL1NldHRpbmdzJztcbmltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcmVjb3JkIGZyb20gb2JzaWRpYW5fZmlsZV9zdGF0dXMuXG4gKi9cbmludGVyZmFjZSBGaWxlU3RhdHVzUmVjb3JkIHtcblx0dmF1bHRfaWQ6IHN0cmluZztcblx0ZmlsZV9wYXRoOiBzdHJpbmc7XG5cdGxhc3RfbW9kaWZpZWQ6IG51bWJlcjtcblx0bGFzdF92ZWN0b3JpemVkPzogc3RyaW5nO1xuXHRjb250ZW50X2hhc2g/OiBzdHJpbmc7XG5cdHN0YXR1cz86IHN0cmluZztcblx0dGFncz86IHN0cmluZ1tdO1xuXHRhbGlhc2VzPzogc3RyaW5nW107XG5cdGxpbmtzPzogc3RyaW5nW107XG5cdGNyZWF0ZWRfYXQ/OiBzdHJpbmc7XG5cdHVwZGF0ZWRfYXQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBTdXBhYmFzZVNlcnZpY2Uge1xuXHRwcml2YXRlIGNsaWVudDogU3VwYWJhc2VDbGllbnQgfCBudWxsO1xuXHRwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogU3VwYWJhc2VTZXJ2aWNlIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgc2V0dGluZ3M6IE1pbmRNYXRyaXhTZXR0aW5ncztcblx0cHJpdmF0ZSByZWFkb25seSBUQUJMRV9OQU1FID0gJ29ic2lkaWFuX2RvY3VtZW50cyc7XG5cdHByaXZhdGUgcmVhZG9ubHkgRklMRV9TVEFUVVNfVEFCTEUgPSAnb2JzaWRpYW5fZmlsZV9zdGF0dXMnO1xuXHQvLyBUcmFjayBkZWxldGlvbiBvcGVyYXRpb25zIGZvciBhIGdpdmVuIGZpbGUgdG8gYXZvaWQgY29uY3VycmVudCBkZWxldGVzXG5cdHByaXZhdGUgZGVsZXRlT3BlcmF0aW9uc0luUHJvZ3Jlc3M6IE1hcDxzdHJpbmcsIGJvb2xlYW4+ID0gbmV3IE1hcCgpO1xuXG5cdHByaXZhdGUgY29uc3RydWN0b3Ioc2V0dGluZ3M6IE1pbmRNYXRyaXhTZXR0aW5ncykge1xuXHRcdGlmICghc2V0dGluZ3Muc3VwYWJhc2UudXJsIHx8ICFzZXR0aW5ncy5zdXBhYmFzZS5hcGlLZXkpIHtcblx0XHRcdGNvbnNvbGUud2FybignU3VwYWJhc2UgY29uZmlndXJhdGlvbiBpcyBpbmNvbXBsZXRlLiBTdXBhYmFzZSBzZXJ2aWNlIHdpbGwgbm90IGJlIGluaXRpYWxpemVkLicpO1xuXHRcdFx0dGhpcy5jbGllbnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIWlzVmF1bHRJbml0aWFsaXplZChzZXR0aW5ncykpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVmF1bHQgaXMgbm90IGluaXRpYWxpemVkJyk7XG5cdFx0fVxuXHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcblx0XHR0aGlzLmNsaWVudCA9IGNyZWF0ZUNsaWVudChzZXR0aW5ncy5zdXBhYmFzZS51cmwsIHNldHRpbmdzLnN1cGFiYXNlLmFwaUtleSk7XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljIGFzeW5jIGdldEluc3RhbmNlKHNldHRpbmdzOiBNaW5kTWF0cml4U2V0dGluZ3MpOiBQcm9taXNlPFN1cGFiYXNlU2VydmljZSB8IG51bGw+IHtcblx0XHRpZiAoIXNldHRpbmdzLnN1cGFiYXNlLnVybCB8fCAhc2V0dGluZ3Muc3VwYWJhc2UuYXBpS2V5KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNvbmZpZ3VyYXRpb24gaXMgaW5jb21wbGV0ZS4gUmV0dXJuaW5nIG51bGwuJyk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0aWYgKCFTdXBhYmFzZVNlcnZpY2UuaW5zdGFuY2UpIHtcblx0XHRcdFN1cGFiYXNlU2VydmljZS5pbnN0YW5jZSA9IG5ldyBTdXBhYmFzZVNlcnZpY2Uoc2V0dGluZ3MpO1xuXHRcdFx0YXdhaXQgU3VwYWJhc2VTZXJ2aWNlLmluc3RhbmNlLmluaXRpYWxpemVEYXRhYmFzZSgpO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRTdXBhYmFzZVNlcnZpY2UuaW5zdGFuY2Uuc2V0dGluZ3Muc3VwYWJhc2UudXJsICE9PSBzZXR0aW5ncy5zdXBhYmFzZS51cmwgfHxcblx0XHRcdFN1cGFiYXNlU2VydmljZS5pbnN0YW5jZS5zZXR0aW5ncy5zdXBhYmFzZS5hcGlLZXkgIT09IHNldHRpbmdzLnN1cGFiYXNlLmFwaUtleSB8fFxuXHRcdFx0U3VwYWJhc2VTZXJ2aWNlLmluc3RhbmNlLnNldHRpbmdzLnZhdWx0SWQgIT09IHNldHRpbmdzLnZhdWx0SWRcblx0XHQpIHtcblx0XHRcdFN1cGFiYXNlU2VydmljZS5pbnN0YW5jZSA9IG5ldyBTdXBhYmFzZVNlcnZpY2Uoc2V0dGluZ3MpO1xuXHRcdFx0YXdhaXQgU3VwYWJhc2VTZXJ2aWNlLmluc3RhbmNlLmluaXRpYWxpemVEYXRhYmFzZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gU3VwYWJhc2VTZXJ2aWNlLmluc3RhbmNlO1xuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBpbml0aWFsaXplRGF0YWJhc2UoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdTdXBhYmFzZSBjbGllbnQgaXMgbm90IGluaXRpYWxpemVkLiBTa2lwcGluZyBkYXRhYmFzZSBpbml0aWFsaXphdGlvbi4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdG5ldyBOb3RpY2UoJ0NoZWNraW5nIGRhdGFiYXNlIGNvbm5lY3Rpb24uLi4nKTtcblx0XHRcdC8vIFZlcmlmeSBjb25uZWN0aW9uIGJ5IHNlbGVjdGluZyBmcm9tIG9ic2lkaWFuX2RvY3VtZW50c1xuXHRcdFx0Y29uc3QgeyBlcnJvcjogdGVzdEVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLlRBQkxFX05BTUUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJylcblx0XHRcdFx0LmxpbWl0KDEpO1xuXHRcdFx0aWYgKHRlc3RFcnJvciAmJiAhdGVzdEVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZDogJHt0ZXN0RXJyb3IubWVzc2FnZX1gKTtcblx0XHRcdH1cblx0XHRcdC8vIEVuc3VyZSB0aGUgZmlsZSBzdGF0dXMgdGFibGUgZXhpc3RzXG5cdFx0XHRhd2FpdCB0aGlzLmluaXRpYWxpemVGaWxlU3RhdHVzVGFibGUoKTtcblx0XHRcdG5ldyBOb3RpY2UoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gdmVyaWZpZWQnKTtcblx0XHRcdHRoaXMuc2V0dGluZ3Muc3VwYWJhc2UuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdEYXRhYmFzZSBpbml0aWFsaXphdGlvbiBlcnJvcjonLCBlcnJvcik7XG5cdFx0XHRuZXcgTm90aWNlKGBEYXRhYmFzZSBlcnJvcjogJHsoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2V9YCk7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRW5zdXJlcyB0aGF0IG9ic2lkaWFuX2ZpbGVfc3RhdHVzIHRhYmxlIGV4aXN0cy5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZUZpbGVTdGF0dXNUYWJsZSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSByZXR1cm47XG5cdFx0dHJ5IHtcblx0XHRcdC8vIENoZWNrIGlmIGZpbGUgc3RhdHVzIHRhYmxlIGV4aXN0c1xuXHRcdFx0Y29uc3QgeyBlcnJvcjogY2hlY2tFcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5GSUxFX1NUQVRVU19UQUJMRSlcblx0XHRcdFx0LnNlbGVjdCgnaWQnKVxuXHRcdFx0XHQubGltaXQoMSk7XG5cdFx0XHRpZiAoY2hlY2tFcnJvciAmJiBjaGVja0Vycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0ZpbGUgc3RhdHVzIHRhYmxlIG1pc3NpbmcuIFBsZWFzZSBjcmVhdGUgaXQgbWFudWFsbHkgb3IgcnVuIHNldHVwIFNRTC4nKTtcblx0XHRcdFx0bmV3IE5vdGljZSgnU29tZSBkYXRhYmFzZSB0YWJsZXMgYXJlIG1pc3NpbmcuIFBsdWdpbiB3aWxsIHdvcmsgd2l0aCBsaW1pdGVkIGZ1bmN0aW9uYWxpdHkuJywgNTAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnRmlsZSBzdGF0dXMgdGFibGUgZXhpc3RzIGFuZCBpcyBhY2Nlc3NpYmxlJyk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBmaWxlIHN0YXR1cyB0YWJsZTonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBpbml0aWFsaXplIGZpbGUgc3RhdHVzIHRhYmxlOiAkeyhlcnJvciBhcyBFcnJvcikubWVzc2FnZX1gKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSW5zZXJ0cyBvciB1cGRhdGVzIGRvY3VtZW50IGNodW5rcyBpbiB0aGUgb2JzaWRpYW5fZG9jdW1lbnRzIHRhYmxlIHVzaW5nIGFuIGF0b21pYyB0cmFuc2FjdGlvbi5cblx0ICogSW1wcm92ZW1lbnRzOlxuXHQgKiAtIFRyYW5zYWN0aW9uIGhhbmRsaW5nIHRvIGVuc3VyZSBhdG9taWNpdHlcblx0ICogLSBWZXJpZmljYXRpb24gb2YgZGVsZXRpb24gc3VjY2VzcyBiZWZvcmUgaW5zZXJ0aW9uXG5cdCAqIC0gUHJvcGVyIGVycm9yIGhhbmRsaW5nIGFuZCByZXRyeSBsb2dpY1xuXHQgKiAtIFByZXZlbnRzIGNvbmN1cnJlbnQgZGVsZXRpb25zIG9uIHRoZSBzYW1lIGZpbGVcblx0ICovXG5cdHB1YmxpYyBhc3luYyB1cHNlcnRDaHVua3MoY2h1bmtzOiBEb2N1bWVudENodW5rW10pOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNsaWVudCBpcyBub3QgaW5pdGlhbGl6ZWQuIFNraXBwaW5nIHVwc2VydENodW5rcy4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0Y29uc29sZS5sb2coJ05vIGNodW5rcyB0byB1cHNlcnQnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgdGhlIG9ic2lkaWFuSWQgZnJvbSB0aGUgZmlyc3QgY2h1bmtcblx0XHRjb25zdCBvYnNpZGlhbklkID0gY2h1bmtzWzBdLm1ldGFkYXRhLm9ic2lkaWFuSWQ7XG5cblx0XHQvLyBDaGVjayBpZiBhIGRlbGV0ZSBvcGVyYXRpb24gaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyBmb3IgdGhpcyBmaWxlXG5cdFx0aWYgKHRoaXMuZGVsZXRlT3BlcmF0aW9uc0luUHJvZ3Jlc3MuZ2V0KG9ic2lkaWFuSWQpKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oYERlbGV0ZSBvcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcyBmb3IgJHtvYnNpZGlhbklkfS4gUXVldWVpbmcgdXBkYXRlLmApO1xuXHRcdFx0Ly8gV2FpdCBmb3IgcHJldmlvdXMgb3BlcmF0aW9uIHRvIGNvbXBsZXRlIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuXHRcdFx0bGV0IHJldHJ5Q291bnQgPSAwO1xuXHRcdFx0Y29uc3QgbWF4UmV0cmllcyA9IDU7XG5cdFx0XHRjb25zdCBiYXNlRGVsYXkgPSA1MDA7IC8vIG1zXG5cblx0XHRcdHdoaWxlICh0aGlzLmRlbGV0ZU9wZXJhdGlvbnNJblByb2dyZXNzLmdldChvYnNpZGlhbklkKSAmJiByZXRyeUNvdW50IDwgbWF4UmV0cmllcykge1xuXHRcdFx0XHRjb25zdCBkZWxheSA9IGJhc2VEZWxheSAqIE1hdGgucG93KDIsIHJldHJ5Q291bnQpO1xuXHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcblx0XHRcdFx0cmV0cnlDb3VudCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5kZWxldGVPcGVyYXRpb25zSW5Qcm9ncmVzcy5nZXQob2JzaWRpYW5JZCkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBEZWxldGlvbiBvcGVyYXRpb24gdGltZW91dCBmb3IgJHtvYnNpZGlhbklkfWApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE1hcmsgZGVsZXRpb24gYXMgaW4gcHJvZ3Jlc3Ncblx0XHR0aGlzLmRlbGV0ZU9wZXJhdGlvbnNJblByb2dyZXNzLnNldChvYnNpZGlhbklkLCB0cnVlKTtcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBQcmVwYXJlIG5ldyBjaHVuayBkYXRhIGZvciBpbnNlcnRpb25cblx0XHRcdGNvbnN0IGNodW5rc1RvSW5zZXJ0ID0gY2h1bmtzLm1hcChjaHVuayA9PiAoe1xuXHRcdFx0XHR2YXVsdF9pZDogdGhpcy5zZXR0aW5ncy52YXVsdElkLFxuXHRcdFx0XHRvYnNpZGlhbl9pZDogY2h1bmsubWV0YWRhdGEub2JzaWRpYW5JZCxcblx0XHRcdFx0Y2h1bmtfaW5kZXg6IGNodW5rLmNodW5rSW5kZXgsXG5cdFx0XHRcdGNvbnRlbnQ6IGNodW5rLmNvbnRlbnQsXG5cdFx0XHRcdG1ldGFkYXRhOiBjaHVuay5tZXRhZGF0YSxcblx0XHRcdFx0ZW1iZWRkaW5nOiBjaHVuay5lbWJlZGRpbmcsXG5cdFx0XHRcdGxhc3RfdXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuXHRcdFx0XHR2ZWN0b3JpemVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcblx0XHRcdH0pKTtcblxuXHRcdFx0Ly8gUmVjb3JkIG9yaWdpbmFsIG51bWJlciBvZiBjaHVua3MgZm9yIHZlcmlmaWNhdGlvblxuXHRcdFx0Y29uc3QgY2h1bmtDb3VudCA9IGNodW5rc1RvSW5zZXJ0Lmxlbmd0aDtcblx0XHRcdGNvbnNvbGUubG9nKGBQcmVwYXJpbmcgdG8gdXBkYXRlICR7Y2h1bmtDb3VudH0gY2h1bmtzIGZvciBmaWxlOiAke29ic2lkaWFuSWR9YCk7XG5cblx0XHRcdC8vIEV4ZWN1dGUgZGVsZXRlIGFuZCBpbnNlcnQgb3BlcmF0aW9ucyBpbiBhIHRyYW5zYWN0aW9uLWxpa2UgbWFubmVyXG5cdFx0XHQvLyBGaXJzdCBkZWxldGUgZXhpc3RpbmcgY2h1bmtzIGZvciB0aGlzIGZpbGUuXG5cdFx0XHQvLyBNb2RpZmllZCBxdWVyeTogcmVtb3ZlIC5zZWxlY3QoJ2NvdW50JykgYW5kIHVzZSBoZWFkIGNvdW50IGluc3RlYWQuXG5cdFx0XHRjb25zdCB7IGVycm9yOiBkZWxldGVFcnJvciwgY291bnQ6IGRlbGV0ZWRDb3VudCB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5UQUJMRV9OQU1FKVxuXHRcdFx0XHQuZGVsZXRlKClcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmVxKCdvYnNpZGlhbl9pZCcsIG9ic2lkaWFuSWQpXG5cdFx0XHRcdC5zZWxlY3QoJyonLCB7IGhlYWQ6IHRydWUsIGNvdW50OiAnZXhhY3QnIH0pO1xuXHRcdFx0aWYgKGRlbGV0ZUVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGV4aXN0aW5nIGNodW5rczonLCBkZWxldGVFcnJvcik7XG5cdFx0XHRcdHRocm93IGRlbGV0ZUVycm9yO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBkZWxldGVkICR7ZGVsZXRlZENvdW50fSBleGlzdGluZyBjaHVua3MgZm9yICR7b2JzaWRpYW5JZH1gKTtcblxuXHRcdFx0Ly8gVmVyaWZ5IHRoZXJlIGFyZSBubyByZW1haW5pbmcgY2h1bmtzIChkb3VibGUtY2hlY2sgZGVsZXRpb24pXG5cdFx0XHRjb25zdCB7IGRhdGE6IHJlbWFpbmluZ0RhdGEsIGVycm9yOiBjb3VudEVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLlRBQkxFX05BTUUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuXHRcdFx0XHQuZXEoJ3ZhdWx0X2lkJywgdGhpcy5zZXR0aW5ncy52YXVsdElkKVxuXHRcdFx0XHQuZXEoJ29ic2lkaWFuX2lkJywgb2JzaWRpYW5JZCk7XG5cdFx0XHRpZiAoY291bnRFcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciB2ZXJpZnlpbmcgZGVsZXRpb246JywgY291bnRFcnJvcik7XG5cdFx0XHRcdHRocm93IGNvdW50RXJyb3I7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJlbWFpbmluZ0NvdW50ID0gcmVtYWluaW5nRGF0YT8ubGVuZ3RoIHx8IDA7XG5cdFx0XHRpZiAocmVtYWluaW5nQ291bnQgPiAwKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybihgRGVsZXRpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogJHtyZW1haW5pbmdDb3VudH0gY2h1bmtzIHN0aWxsIGV4aXN0IGZvciAke29ic2lkaWFuSWR9YCk7XG5cdFx0XHRcdC8vIEF0dGVtcHQgZGVsZXRpb24gYWdhaW4gaWYgY2h1bmtzIHJlbWFpblxuXHRcdFx0XHRjb25zdCB7IGVycm9yOiByZXRyeUVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHRcdC5mcm9tKHRoaXMuVEFCTEVfTkFNRSlcblx0XHRcdFx0XHQuZGVsZXRlKClcblx0XHRcdFx0XHQuZXEoJ3ZhdWx0X2lkJywgdGhpcy5zZXR0aW5ncy52YXVsdElkKVxuXHRcdFx0XHRcdC5lcSgnb2JzaWRpYW5faWQnLCBvYnNpZGlhbklkKTtcblx0XHRcdFx0aWYgKHJldHJ5RXJyb3IpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjbGVhbiB1cCByZW1haW5pbmcgY2h1bmtzOiAke3JldHJ5RXJyb3IubWVzc2FnZX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBOb3cgaW5zZXJ0IHRoZSBuZXcgY2h1bmtzIGluIGJhdGNoZXMgdG8gYXZvaWQgcG90ZW50aWFsIHBheWxvYWQgbGltaXRzXG5cdFx0XHRjb25zdCBCQVRDSF9TSVpFID0gNTA7IC8vIEFkanVzdCBiYXNlZCBvbiB5b3VyIFN1cGFiYXNlIGxpbWl0c1xuXHRcdFx0Y29uc3QgYmF0Y2hlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rc1RvSW5zZXJ0Lmxlbmd0aDsgaSArPSBCQVRDSF9TSVpFKSB7XG5cdFx0XHRcdGJhdGNoZXMucHVzaChjaHVua3NUb0luc2VydC5zbGljZShpLCBpICsgQkFUQ0hfU0laRSkpO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5sb2coYEluc2VydGluZyAke2NodW5rc1RvSW5zZXJ0Lmxlbmd0aH0gY2h1bmtzIGluICR7YmF0Y2hlcy5sZW5ndGh9IGJhdGNoZXNgKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGJhdGNoID0gYmF0Y2hlc1tpXTtcblx0XHRcdFx0Y29uc29sZS5sb2coYFByb2Nlc3NpbmcgYmF0Y2ggJHtpICsgMX0vJHtiYXRjaGVzLmxlbmd0aH0gd2l0aCAke2JhdGNoLmxlbmd0aH0gY2h1bmtzYCk7XG5cdFx0XHRcdGNvbnN0IHsgZXJyb3I6IGluc2VydEVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHRcdC5mcm9tKHRoaXMuVEFCTEVfTkFNRSlcblx0XHRcdFx0XHQuaW5zZXJ0KGJhdGNoKTtcblx0XHRcdFx0aWYgKGluc2VydEVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihgRXJyb3IgaW5zZXJ0aW5nIGJhdGNoICR7aSArIDF9OmAsIGluc2VydEVycm9yKTtcblx0XHRcdFx0XHQvLyBDbGVhbiB1cCBwYXJ0aWFsbHkgaW5zZXJ0ZWQgZGF0YSBvbiBlcnJvclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMuY2xlYW51cFBhcnRpYWxJbnNlcnQob2JzaWRpYW5JZCk7XG5cdFx0XHRcdFx0dGhyb3cgaW5zZXJ0RXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVmVyaWZ5IGFsbCBjaHVua3Mgd2VyZSBpbnNlcnRlZFxuXHRcdFx0Y29uc3QgeyBkYXRhOiBpbnNlcnRlZERhdGEsIGVycm9yOiB2ZXJpZnlFcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5UQUJMRV9OQU1FKVxuXHRcdFx0XHQuc2VsZWN0KCdpZCcsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmVxKCdvYnNpZGlhbl9pZCcsIG9ic2lkaWFuSWQpO1xuXHRcdFx0aWYgKHZlcmlmeUVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBpbnNlcnRpb246JywgdmVyaWZ5RXJyb3IpO1xuXHRcdFx0XHR0aHJvdyB2ZXJpZnlFcnJvcjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaW5zZXJ0ZWRDb3VudCA9IGluc2VydGVkRGF0YT8ubGVuZ3RoIHx8IDA7XG5cdFx0XHRpZiAoaW5zZXJ0ZWRDb3VudCAhPT0gY2h1bmtDb3VudCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oYEluc2VydGlvbiB2ZXJpZmljYXRpb246IEV4cGVjdGVkICR7Y2h1bmtDb3VudH0gY2h1bmtzLCBmb3VuZCAke2luc2VydGVkQ291bnR9YCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSBmaWxlIHN0YXR1cyB0byB0cmFjayB2ZWN0b3JpemF0aW9uXG5cdFx0XHRhd2FpdCB0aGlzLnVwZGF0ZUZpbGVWZWN0b3JpemF0aW9uU3RhdHVzKGNodW5rc1swXS5tZXRhZGF0YSk7XG5cdFx0XHRjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgY2h1bmtzOicsIHtcblx0XHRcdFx0bnVtYmVyT2ZDaHVua3M6IGNodW5rcy5sZW5ndGgsXG5cdFx0XHRcdHZhdWx0SWQ6IHRoaXMuc2V0dGluZ3MudmF1bHRJZCxcblx0XHRcdFx0b2JzaWRpYW5JZFxuXHRcdFx0fSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB1cHNlcnQgY2h1bmtzOicsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHQvLyBDbGVhciBkZWxldGlvbiBpbiBwcm9ncmVzcyBmbGFnXG5cdFx0XHR0aGlzLmRlbGV0ZU9wZXJhdGlvbnNJblByb2dyZXNzLnNldChvYnNpZGlhbklkLCBmYWxzZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFucyB1cCBwYXJ0aWFsIGluc2VydHMgaWYgYW4gZXJyb3Igb2NjdXJzIGR1cmluZyBiYXRjaCBpbnNlcnRpb25cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgY2xlYW51cFBhcnRpYWxJbnNlcnQob2JzaWRpYW5JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkgcmV0dXJuO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGNvbnNvbGUubG9nKGBDbGVhbmluZyB1cCBwYXJ0aWFsIGluc2VydCBmb3IgJHtvYnNpZGlhbklkfWApO1xuXHRcdFx0Y29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5UQUJMRV9OQU1FKVxuXHRcdFx0XHQuZGVsZXRlKClcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmVxKCdvYnNpZGlhbl9pZCcsIG9ic2lkaWFuSWQpO1xuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNsZWFuaW5nIHVwIHBhcnRpYWwgaW5zZXJ0OicsIGVycm9yKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgY2xlYW5lZCB1cCBwYXJ0aWFsIGluc2VydCBmb3IgJHtvYnNpZGlhbklkfWApO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGNsZWFudXBFcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGNsZWFudXAgb2YgcGFydGlhbCBpbnNlcnQ6JywgY2xlYW51cEVycm9yKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQnVsayB1cHNlcnQgbWV0aG9kIGZvciBmaWxlIHN0YXR1cyByZWNvcmRzLlxuXHQgKiBJbXByb3ZlcyBwZXJmb3JtYW5jZSBmb3IgbGFyZ2UgdmF1bHRzLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGJ1bGtVcHNlcnRGaWxlU3RhdHVzZXMoc3RhdHVzZXM6IEZpbGVTdGF0dXNSZWNvcmRbXSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHtcblx0XHRcdGNvbnNvbGUud2FybignU3VwYWJhc2UgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZC4gU2tpcHBpbmcgYnVsa1Vwc2VydEZpbGVTdGF0dXNlcy4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdGlmIChzdGF0dXNlcy5sZW5ndGggPT09IDApIHJldHVybjtcblx0XHRcdGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC51cHNlcnQoc3RhdHVzZXMsIHsgb25Db25mbGljdDogJ3ZhdWx0X2lkLGZpbGVfcGF0aCcgfSk7XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGJ1bGsgdXBzZXJ0IG9mIGZpbGUgc3RhdHVzZXM6JywgZXJyb3IpO1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH1cblx0XHRcdGNvbnNvbGUubG9nKGBCdWxrIHVwc2VydCBvZiAke3N0YXR1c2VzLmxlbmd0aH0gZmlsZSBzdGF0dXNlcyBzdWNjZXNzZnVsLmApO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gYnVsayB1cHNlcnQgZmlsZSBzdGF0dXNlczonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBvciB1cGRhdGVzIGEgcmVjb3JkIGluIHRoZSBvYnNpZGlhbl9maWxlX3N0YXR1cyB0YWJsZVxuXHQgKiB0byByZWZsZWN0IHRoZSBsYXRlc3QgZmlsZSBzdGF0dXMgdXNpbmcgcHJvdmlkZWQgbWV0YWRhdGEuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgdXBkYXRlRmlsZVZlY3Rvcml6YXRpb25TdGF0dXMobWV0YWRhdGE6IERvY3VtZW50TWV0YWRhdGEpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNsaWVudCBpcyBub3QgaW5pdGlhbGl6ZWQuIFNraXBwaW5nIHVwZGF0ZUZpbGVWZWN0b3JpemF0aW9uU3RhdHVzLicpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0Ly8gQ2hlY2sgaWYgZmlsZSBzdGF0dXMgdGFibGUgZXhpc3RzXG5cdFx0XHRjb25zdCB7IGVycm9yOiBjaGVja0Vycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLkZJTEVfU1RBVFVTX1RBQkxFKVxuXHRcdFx0XHQuc2VsZWN0KCdpZCcpXG5cdFx0XHRcdC5saW1pdCgxKTtcblx0XHRcdGlmIChjaGVja0Vycm9yICYmIGNoZWNrRXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZG9lcyBub3QgZXhpc3QnKSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZpbGUgc3RhdHVzIHRhYmxlIGRvZXMgbm90IGV4aXN0LiBTa2lwcGluZyBzdGF0dXMgdXBkYXRlLicpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBDb25zdHJ1Y3QgYSBGaWxlU3RhdHVzUmVjb3JkXG5cdFx0XHRjb25zdCBmaWxlU3RhdHVzOiBGaWxlU3RhdHVzUmVjb3JkID0ge1xuXHRcdFx0XHR2YXVsdF9pZDogdGhpcy5zZXR0aW5ncy52YXVsdElkISxcblx0XHRcdFx0ZmlsZV9wYXRoOiBtZXRhZGF0YS5vYnNpZGlhbklkLFxuXHRcdFx0XHRsYXN0X21vZGlmaWVkOiBtZXRhZGF0YS5sYXN0TW9kaWZpZWQsXG5cdFx0XHRcdGxhc3RfdmVjdG9yaXplZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuXHRcdFx0XHRjb250ZW50X2hhc2g6IG1ldGFkYXRhLmN1c3RvbU1ldGFkYXRhPy5jb250ZW50SGFzaCB8fCAnJyxcblx0XHRcdFx0c3RhdHVzOiAndmVjdG9yaXplZCcsIC8vIE1hcmsgYXMgc3VjY2Vzc2Z1bGx5IHZlY3Rvcml6ZWRcblx0XHRcdFx0dGFnczogbWV0YWRhdGEudGFncyB8fCBbXSxcblx0XHRcdFx0YWxpYXNlczogbWV0YWRhdGEuY3VzdG9tTWV0YWRhdGE/LmFsaWFzZXMgfHwgW10sXG5cdFx0XHRcdGxpbmtzOiBtZXRhZGF0YS5saW5rcyB8fCBbXSxcblx0XHRcdFx0dXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG5cdFx0XHR9O1xuXHRcdFx0Ly8gVXBzZXJ0IHRoZSByZWNvcmQgaW50byB0aGUgZmlsZSBzdGF0dXMgdGFibGVcblx0XHRcdGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC51cHNlcnQoZmlsZVN0YXR1cywgeyBvbkNvbmZsaWN0OiAndmF1bHRfaWQsZmlsZV9wYXRoJyB9KTtcblx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBmaWxlIHZlY3Rvcml6YXRpb24gc3RhdHVzOicsIGVycm9yKTtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cdFx0XHRjb25zb2xlLmxvZygnRmlsZSB2ZWN0b3JpemF0aW9uIHN0YXR1cyB1cGRhdGVkOicsIG1ldGFkYXRhLm9ic2lkaWFuSWQpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGZpbGUgdmVjdG9yaXphdGlvbiBzdGF0dXM6JywgZXJyb3IpO1xuXHRcdFx0Ly8gTm9uLWNyaXRpY2FsLCBzbyBqdXN0IGxvZyB0aGUgZXJyb3Jcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTWFya3MgYSBmaWxlIGFzIGRlbGV0ZWQgaW4gdGhlIG9ic2lkaWFuX2ZpbGVfc3RhdHVzIHRhYmxlLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIHVwZGF0ZUZpbGVTdGF0dXNPbkRlbGV0ZShmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkgcmV0dXJuO1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCB7IGVycm9yOiBjaGVja0Vycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLkZJTEVfU1RBVFVTX1RBQkxFKVxuXHRcdFx0XHQuc2VsZWN0KCdpZCcpXG5cdFx0XHRcdC5saW1pdCgxKTtcblx0XHRcdGlmIChjaGVja0Vycm9yICYmIGNoZWNrRXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZG9lcyBub3QgZXhpc3QnKSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZpbGUgc3RhdHVzIHRhYmxlIGRvZXMgbm90IGV4aXN0LiBTa2lwcGluZyBzdGF0dXMgdXBkYXRlIG9uIGRlbGV0ZS4nKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5GSUxFX1NUQVRVU19UQUJMRSlcblx0XHRcdFx0LnVwZGF0ZSh7XG5cdFx0XHRcdFx0c3RhdHVzOiAnZGVsZXRlZCcsXG5cdFx0XHRcdFx0dXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5lcSgndmF1bHRfaWQnLCB0aGlzLnNldHRpbmdzLnZhdWx0SWQpXG5cdFx0XHRcdC5lcSgnZmlsZV9wYXRoJywgZmlsZVBhdGgpO1xuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGZpbGUgc3RhdHVzIG9uIGRlbGV0ZTonLCBlcnJvcik7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGZpbGUgc3RhdHVzIG9uIGRlbGV0ZTonLCBlcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIERlbGV0ZXMgZG9jdW1lbnQgY2h1bmtzIGZvciBhIGdpdmVuIG9ic2lkaWFuSWQgZnJvbSB0aGUgb2JzaWRpYW5fZG9jdW1lbnRzIHRhYmxlLlxuXHQgKiBJbXByb3ZlZCB3aXRoIHRyYWNraW5nIG9mIG9wZXJhdGlvbiBwcm9ncmVzcyBhbmQgdmVyaWZpY2F0aW9uLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGRlbGV0ZURvY3VtZW50Q2h1bmtzKG9ic2lkaWFuSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHtcblx0XHRcdGNvbnNvbGUud2FybignU3VwYWJhc2UgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZC4gU2tpcHBpbmcgZGVsZXRlRG9jdW1lbnRDaHVua3MuJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgYSBkZWxldGlvbiBpcyBhbHJlYWR5IGluIHByb2dyZXNzIGZvciB0aGlzIGZpbGUsIHdhaXQgYnJpZWZseS5cblx0XHRpZiAodGhpcy5kZWxldGVPcGVyYXRpb25zSW5Qcm9ncmVzcy5nZXQob2JzaWRpYW5JZCkpIHtcblx0XHRcdGNvbnNvbGUud2FybihgRGVsZXRlIG9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzIGZvciAke29ic2lkaWFuSWR9LiBXYWl0aW5nLi4uYCk7XG5cdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG5cdFx0XHRpZiAodGhpcy5kZWxldGVPcGVyYXRpb25zSW5Qcm9ncmVzcy5nZXQob2JzaWRpYW5JZCkpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coYFN0aWxsIHdhaXRpbmcgZm9yIGRlbGV0ZSBvcGVyYXRpb24gb24gJHtvYnNpZGlhbklkfS4uLmApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTWFyayBkZWxldGlvbiBhcyBpbiBwcm9ncmVzcy5cblx0XHR0aGlzLmRlbGV0ZU9wZXJhdGlvbnNJblByb2dyZXNzLnNldChvYnNpZGlhbklkLCB0cnVlKTtcblxuXHRcdHRyeSB7XG5cdFx0XHRjb25zb2xlLmxvZyhgU3RhcnRpbmcgZGVsZXRpb24gb2YgY2h1bmtzIGZvciAke29ic2lkaWFuSWR9YCk7XG5cblx0XHRcdC8vIENoZWNrIGhvdyBtYW55IGNodW5rcyBleGlzdCAodXNpbmcgYSBwbGFpbiBzZWxlY3QgcXVlcnkpLlxuXHRcdFx0Y29uc3QgeyBkYXRhOiBpbml0aWFsRGF0YSwgZXJyb3I6IGluaXRpYWxDb3VudEVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLlRBQkxFX05BTUUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJylcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmVxKCdvYnNpZGlhbl9pZCcsIG9ic2lkaWFuSWQpO1xuXHRcdFx0aWYgKGluaXRpYWxDb3VudEVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGV4aXN0aW5nIGNodW5rczonLCBpbml0aWFsQ291bnRFcnJvcik7XG5cdFx0XHRcdHRocm93IGluaXRpYWxDb3VudEVycm9yO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgaW5pdGlhbENvdW50ID0gaW5pdGlhbERhdGEgPyBpbml0aWFsRGF0YS5sZW5ndGggOiAwO1xuXHRcdFx0Y29uc29sZS5sb2coYEZvdW5kICR7aW5pdGlhbENvdW50fSBjaHVua3MgdG8gZGVsZXRlIGZvciAke29ic2lkaWFuSWR9YCk7XG5cblx0XHRcdC8vIElmIHRoZXJlIGFyZSBubyBjaHVua3MsIHdlIGNhbiBkaXJlY3RseSBwdXJnZSB0aGUgZmlsZSBzdGF0dXMuXG5cdFx0XHRpZiAoaW5pdGlhbENvdW50ID09PSAwKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMucHVyZ2VGaWxlU3RhdHVzKG9ic2lkaWFuSWQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlbGV0ZSB0aGUgY2h1bmtzLlxuXHRcdFx0Y29uc3QgeyBlcnJvcjogZGVsZXRlRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuVEFCTEVfTkFNRSlcblx0XHRcdFx0LmRlbGV0ZSgpXG5cdFx0XHRcdC5lcSgndmF1bHRfaWQnLCB0aGlzLnNldHRpbmdzLnZhdWx0SWQpXG5cdFx0XHRcdC5lcSgnb2JzaWRpYW5faWQnLCBvYnNpZGlhbklkKTtcblx0XHRcdGlmIChkZWxldGVFcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBjaHVua3M6JywgZGVsZXRlRXJyb3IpO1xuXHRcdFx0XHR0aHJvdyBkZWxldGVFcnJvcjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2FpdCBicmllZmx5IHRvIGxldCB0aGUgZGVsZXRpb24gcHJvcGFnYXRlLlxuXHRcdFx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuXG5cdFx0XHQvLyBWZXJpZnkgZGVsZXRpb24gYnkgc2VsZWN0aW5nIHJlbWFpbmluZyByb3dzLlxuXHRcdFx0Y29uc3QgeyBkYXRhOiByZW1haW5pbmdEYXRhLCBlcnJvcjogdmVyaWZ5RXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuVEFCTEVfTkFNRSlcblx0XHRcdFx0LnNlbGVjdCgnaWQnKVxuXHRcdFx0XHQuZXEoJ3ZhdWx0X2lkJywgdGhpcy5zZXR0aW5ncy52YXVsdElkKVxuXHRcdFx0XHQuZXEoJ29ic2lkaWFuX2lkJywgb2JzaWRpYW5JZCk7XG5cdFx0XHRpZiAodmVyaWZ5RXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIGRlbGV0aW9uOicsIHZlcmlmeUVycm9yKTtcblx0XHRcdFx0dGhyb3cgdmVyaWZ5RXJyb3I7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCByZW1haW5pbmdDb3VudCA9IHJlbWFpbmluZ0RhdGEgPyByZW1haW5pbmdEYXRhLmxlbmd0aCA6IDA7XG5cdFx0XHRpZiAocmVtYWluaW5nQ291bnQgPiAwKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybihgRGVsZXRpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogJHtyZW1haW5pbmdDb3VudH0gY2h1bmtzIHN0aWxsIGV4aXN0IGZvciAke29ic2lkaWFuSWR9YCk7XG5cdFx0XHRcdC8vIElmIHRoZXJlIGFyZSBsZWZ0b3ZlciBjaHVua3MsIGRvIG5vdCBwdXJnZSB5ZXQuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWxsIGNodW5rcyBoYXZlIGJlZW4gcmVtb3ZlZDsgcHVyZ2UgdGhlIGZpbGUgc3RhdHVzIHJlY29yZC5cblx0XHRcdGF3YWl0IHRoaXMucHVyZ2VGaWxlU3RhdHVzKG9ic2lkaWFuSWQpO1xuXHRcdFx0Y29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBwdXJnZWQgZmlsZSBzdGF0dXMgZm9yICR7b2JzaWRpYW5JZH1gKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBjaHVua3M6JywgZXJyb3IpO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdC8vIENsZWFyIHRoZSBkZWxldGlvbi1pbi1wcm9ncmVzcyBmbGFnLlxuXHRcdFx0dGhpcy5kZWxldGVPcGVyYXRpb25zSW5Qcm9ncmVzcy5zZXQob2JzaWRpYW5JZCwgZmFsc2UpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgZG9jdW1lbnQgY2h1bmtzIGZvciBhIGdpdmVuIG9ic2lkaWFuSWQuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgZ2V0RG9jdW1lbnRDaHVua3Mob2JzaWRpYW5JZDogc3RyaW5nKTogUHJvbWlzZTxEb2N1bWVudENodW5rW10+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNsaWVudCBpcyBub3QgaW5pdGlhbGl6ZWQuIFNraXBwaW5nIGdldERvY3VtZW50Q2h1bmtzLicpO1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5UQUJMRV9OQU1FKVxuXHRcdFx0XHQuc2VsZWN0KCcqJylcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmVxKCdvYnNpZGlhbl9pZCcsIG9ic2lkaWFuSWQpXG5cdFx0XHRcdC5vcmRlcignY2h1bmtfaW5kZXgnKTtcblx0XHRcdGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRyZXR1cm4gZGF0YS5tYXAocm93ID0+ICh7XG5cdFx0XHRcdGNvbnRlbnQ6IHJvdy5jb250ZW50LFxuXHRcdFx0XHRjaHVua0luZGV4OiByb3cuY2h1bmtfaW5kZXgsXG5cdFx0XHRcdG1ldGFkYXRhOiByb3cubWV0YWRhdGEgYXMgRG9jdW1lbnRNZXRhZGF0YSxcblx0XHRcdFx0ZW1iZWRkaW5nOiByb3cuZW1iZWRkaW5nLFxuXHRcdFx0XHR2ZWN0b3JpemVkX2F0OiByb3cudmVjdG9yaXplZF9hdFxuXHRcdFx0fSkpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGNodW5rczonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGEgZmlsZSBoYXMgYmVlbiB2ZWN0b3JpemVkIGJhc2VkIG9uIHRoZSBvYnNpZGlhbl9maWxlX3N0YXR1cyB0YWJsZS5cblx0ICovXG5cdHB1YmxpYyBhc3luYyBpc0ZpbGVWZWN0b3JpemVkKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSByZXR1cm4gZmFsc2U7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZXJyb3I6IGNoZWNrRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJylcblx0XHRcdFx0LmxpbWl0KDEpO1xuXHRcdFx0aWYgKGNoZWNrRXJyb3IgJiYgY2hlY2tFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdkb2VzIG5vdCBleGlzdCcpKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignRmlsZSBzdGF0dXMgdGFibGUgZG9lcyBub3QgZXhpc3QuIEFzc3VtaW5nIGZpbGUgaXMgbm90IHZlY3Rvcml6ZWQuJyk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJ3N0YXR1cywgbGFzdF92ZWN0b3JpemVkJylcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmVxKCdmaWxlX3BhdGgnLCBmaWxlUGF0aClcblx0XHRcdFx0LnNpbmdsZSgpO1xuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdGlmIChlcnJvci5jb2RlID09PSAnUEdSU1QxMTYnKSB7XG5cdFx0XHRcdFx0Ly8gUm93IG5vdCBmb3VuZFxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkYXRhICYmIGRhdGEuc3RhdHVzID09PSAndmVjdG9yaXplZCcgJiYgISFkYXRhLmxhc3RfdmVjdG9yaXplZDtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNoZWNrIGlmIGZpbGUgaXMgdmVjdG9yaXplZDonLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgdmVjdG9yaXphdGlvbiBzdGF0dXMgb2YgYSBmaWxlIGZyb20gdGhlIGRhdGFiYXNlLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGdldEZpbGVWZWN0b3JpemF0aW9uU3RhdHVzKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHtcblx0XHRpc1ZlY3Rvcml6ZWQ6IGJvb2xlYW47XG5cdFx0bGFzdE1vZGlmaWVkOiBudW1iZXI7XG5cdFx0bGFzdFZlY3Rvcml6ZWQ6IHN0cmluZyB8IG51bGw7XG5cdFx0Y29udGVudEhhc2g6IHN0cmluZyB8IG51bGw7XG5cdFx0c3RhdHVzOiBzdHJpbmcgfCBudWxsO1xuXHR9PiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aXNWZWN0b3JpemVkOiBmYWxzZSxcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiAwLFxuXHRcdFx0XHRsYXN0VmVjdG9yaXplZDogbnVsbCxcblx0XHRcdFx0Y29udGVudEhhc2g6IG51bGwsXG5cdFx0XHRcdHN0YXR1czogbnVsbFxuXHRcdFx0fTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZXJyb3I6IGNoZWNrRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJylcblx0XHRcdFx0LmxpbWl0KDEpO1xuXHRcdFx0aWYgKGNoZWNrRXJyb3IgJiYgY2hlY2tFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdkb2VzIG5vdCBleGlzdCcpKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignRmlsZSBzdGF0dXMgdGFibGUgZG9lcyBub3QgZXhpc3QuIFJldHVybmluZyBkZWZhdWx0IHN0YXR1cy4nKTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpc1ZlY3Rvcml6ZWQ6IGZhbHNlLFxuXHRcdFx0XHRcdGxhc3RNb2RpZmllZDogMCxcblx0XHRcdFx0XHRsYXN0VmVjdG9yaXplZDogbnVsbCxcblx0XHRcdFx0XHRjb250ZW50SGFzaDogbnVsbCxcblx0XHRcdFx0XHRzdGF0dXM6IG51bGxcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJyonKVxuXHRcdFx0XHQuZXEoJ3ZhdWx0X2lkJywgdGhpcy5zZXR0aW5ncy52YXVsdElkKVxuXHRcdFx0XHQuZXEoJ2ZpbGVfcGF0aCcsIGZpbGVQYXRoKVxuXHRcdFx0XHQuc2luZ2xlKCk7XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0aWYgKGVycm9yLmNvZGUgPT09ICdQR1JTVDExNicpIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0aXNWZWN0b3JpemVkOiBmYWxzZSxcblx0XHRcdFx0XHRcdGxhc3RNb2RpZmllZDogMCxcblx0XHRcdFx0XHRcdGxhc3RWZWN0b3JpemVkOiBudWxsLFxuXHRcdFx0XHRcdFx0Y29udGVudEhhc2g6IG51bGwsXG5cdFx0XHRcdFx0XHRzdGF0dXM6IG51bGxcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aXNWZWN0b3JpemVkOiBkYXRhLnN0YXR1cyA9PT0gJ3ZlY3Rvcml6ZWQnLFxuXHRcdFx0XHRsYXN0TW9kaWZpZWQ6IGRhdGEubGFzdF9tb2RpZmllZCxcblx0XHRcdFx0bGFzdFZlY3Rvcml6ZWQ6IGRhdGEubGFzdF92ZWN0b3JpemVkLFxuXHRcdFx0XHRjb250ZW50SGFzaDogZGF0YS5jb250ZW50X2hhc2gsXG5cdFx0XHRcdHN0YXR1czogZGF0YS5zdGF0dXNcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgZmlsZSB2ZWN0b3JpemF0aW9uIHN0YXR1czonLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRpc1ZlY3Rvcml6ZWQ6IGZhbHNlLFxuXHRcdFx0XHRsYXN0TW9kaWZpZWQ6IDAsXG5cdFx0XHRcdGxhc3RWZWN0b3JpemVkOiBudWxsLFxuXHRcdFx0XHRjb250ZW50SGFzaDogbnVsbCxcblx0XHRcdFx0c3RhdHVzOiBudWxsXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIGEgZmlsZSBuZWVkcyB2ZWN0b3JpemluZyBiYXNlZCBvbiBsYXN0X21vZGlmaWVkIGFuZCBjb250ZW50X2hhc2guXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgbmVlZHNWZWN0b3JpemluZyhcblx0XHRmaWxlUGF0aDogc3RyaW5nLFxuXHRcdGxhc3RNb2RpZmllZDogbnVtYmVyLFxuXHRcdGNvbnRlbnRIYXNoOiBzdHJpbmdcblx0KTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkgcmV0dXJuIHRydWU7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZXJyb3I6IGNoZWNrRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJylcblx0XHRcdFx0LmxpbWl0KDEpO1xuXHRcdFx0aWYgKGNoZWNrRXJyb3IgJiYgY2hlY2tFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdkb2VzIG5vdCBleGlzdCcpKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignRmlsZSBzdGF0dXMgdGFibGUgZG9lcyBub3QgZXhpc3QuIEFzc3VtaW5nIGZpbGUgbmVlZHMgdmVjdG9yaXppbmcuJyk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy5nZXRGaWxlVmVjdG9yaXphdGlvblN0YXR1cyhmaWxlUGF0aCk7XG5cdFx0XHRpZiAoIXN0YXR1cy5zdGF0dXMpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7IC8vIE5vIHJlY29yZCBtZWFucyBpdCBuZWVkcyB2ZWN0b3JpemluZ1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN0YXR1cy5jb250ZW50SGFzaCAhPT0gY29udGVudEhhc2gpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7IC8vIENvbnRlbnQgaGFzIGNoYW5nZWRcblx0XHRcdH1cblx0XHRcdGlmIChsYXN0TW9kaWZpZWQgPiBzdGF0dXMubGFzdE1vZGlmaWVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlOyAvLyBGaWxlIG1vZGlmaWVkIHNpbmNlIGxhc3QgdmVjdG9yaXphdGlvblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2hlY2sgaWYgZmlsZSBuZWVkcyB2ZWN0b3JpemluZzonLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gRGVmYXVsdCB0byBuZWVkaW5nIHZlY3Rvcml6YXRpb24gb24gZXJyb3JzXG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyBhbGwgZmlsZXMgdGhhdCBkbyBub3QgaGF2ZSBhIHN0YXR1cyBvZiAndmVjdG9yaXplZCcgaW4gdGhlIGRhdGFiYXNlLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGdldEZpbGVzTmVlZGluZ1ZlY3Rvcml6YXRpb24oKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHJldHVybiBbXTtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgeyBlcnJvcjogY2hlY2tFcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5GSUxFX1NUQVRVU19UQUJMRSlcblx0XHRcdFx0LnNlbGVjdCgnaWQnKVxuXHRcdFx0XHQubGltaXQoMSk7XG5cdFx0XHRpZiAoY2hlY2tFcnJvciAmJiBjaGVja0Vycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdGaWxlIHN0YXR1cyB0YWJsZSBkb2VzIG5vdCBleGlzdC4gVW5hYmxlIHRvIGRldGVybWluZSBmaWxlcyBuZWVkaW5nIHZlY3Rvcml6YXRpb24uJyk7XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5zZWxlY3QoJ2ZpbGVfcGF0aCcpXG5cdFx0XHRcdC5lcSgndmF1bHRfaWQnLCB0aGlzLnNldHRpbmdzLnZhdWx0SWQpXG5cdFx0XHRcdC5ub3QoJ3N0YXR1cycsICdlcScsICd2ZWN0b3JpemVkJyk7XG5cdFx0XHRpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0cmV0dXJuIGRhdGEubWFwKChyb3c6IHsgZmlsZV9wYXRoOiBzdHJpbmcgfSkgPT4gcm93LmZpbGVfcGF0aCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgZmlsZXMgbmVlZGluZyB2ZWN0b3JpemF0aW9uOicsIGVycm9yKTtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUGVyZm9ybXMgYSBzZW1hbnRpYyBzZWFyY2ggdXNpbmcgdGhlIG1hdGNoX2RvY3VtZW50cyBmdW5jdGlvbi5cblx0ICovXG5cdHB1YmxpYyBhc3luYyBzZW1hbnRpY1NlYXJjaChlbWJlZGRpbmc6IG51bWJlcltdLCBsaW1pdDogbnVtYmVyID0gNSk6IFByb21pc2U8QXJyYXk8e1xuXHRcdGNvbnRlbnQ6IHN0cmluZztcblx0XHRtZXRhZGF0YTogRG9jdW1lbnRNZXRhZGF0YTtcblx0XHRzaW1pbGFyaXR5OiBudW1iZXI7XG5cdH0+PiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdTdXBhYmFzZSBjbGllbnQgaXMgbm90IGluaXRpYWxpemVkLiBTa2lwcGluZyBzZW1hbnRpY1NlYXJjaC4nKTtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50LnJwYygnbWF0Y2hfZG9jdW1lbnRzJywge1xuXHRcdFx0XHRxdWVyeV9lbWJlZGRpbmc6IGVtYmVkZGluZyxcblx0XHRcdFx0c2VhcmNoX3ZhdWx0X2lkOiB0aGlzLnNldHRpbmdzLnZhdWx0SWQsXG5cdFx0XHRcdG1hdGNoX2NvdW50OiBsaW1pdFxuXHRcdFx0fSk7XG5cdFx0XHRpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0cmV0dXJuIGRhdGEubWFwKChyb3c6IGFueSkgPT4gKHtcblx0XHRcdFx0Y29udGVudDogcm93LmNvbnRlbnQsXG5cdFx0XHRcdG1ldGFkYXRhOiByb3cubWV0YWRhdGEgYXMgRG9jdW1lbnRNZXRhZGF0YSxcblx0XHRcdFx0c2ltaWxhcml0eTogcm93LnNpbWlsYXJpdHlcblx0XHRcdH0pKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBlcmZvcm0gc2VtYW50aWMgc2VhcmNoOicsIGVycm9yKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUZXN0cyB0aGUgY29ubmVjdGlvbiBieSBzZWxlY3RpbmcgZnJvbSB0aGUgb2JzaWRpYW5fZG9jdW1lbnRzIHRhYmxlLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIHRlc3RDb25uZWN0aW9uKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHJldHVybiBmYWxzZTtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5UQUJMRV9OQU1FKVxuXHRcdFx0XHQuc2VsZWN0KCdpZCcpXG5cdFx0XHRcdC5saW1pdCgxKTtcblx0XHRcdC8vIENvbnNpZGVyIGNvbm5lY3RlZCBldmVuIGlmIHRhYmxlIGRvZXNuJ3QgZXhpc3Rcblx0XHRcdGlmIChlcnJvciAmJiBlcnJvci5tZXNzYWdlICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gIWVycm9yO1xuXHRcdH0gY2F0Y2gge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFsbCB1bmlxdWUgb2JzaWRpYW5faWRzIGZyb20gdGhlIG9ic2lkaWFuX2RvY3VtZW50cyB0YWJsZSBmb3IgdGhlIGN1cnJlbnQgdmF1bHQuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgZ2V0QWxsRG9jdW1lbnRJZHMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHtcblx0XHRcdGNvbnNvbGUud2FybignU3VwYWJhc2UgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZC4gU2tpcHBpbmcgZ2V0QWxsRG9jdW1lbnRJZHMuJyk7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLlRBQkxFX05BTUUpXG5cdFx0XHRcdC5zZWxlY3QoJ29ic2lkaWFuX2lkJylcblx0XHRcdFx0LmVxKCd2YXVsdF9pZCcsIHRoaXMuc2V0dGluZ3MudmF1bHRJZClcblx0XHRcdFx0LmRpc3RpbmN0KCk7XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0aWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGF0YS5tYXAoKHJvdzogYW55KSA9PiByb3cub2JzaWRpYW5faWQpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGRvY3VtZW50IElEczonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyB0aGUgcmVxdWlyZWQgZGF0YWJhc2UgdGFibGVzIGlmIG5lZWRlZCAobWFudWFsIGludm9jYXRpb24pLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGNyZWF0ZVJlcXVpcmVkVGFibGVzKCk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHN1Y2Nlc3M6IGZhbHNlLFxuXHRcdFx0XHRtZXNzYWdlOiAnU3VwYWJhc2UgY2xpZW50IG5vdCBpbml0aWFsaXplZCdcblx0XHRcdH07XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHQvLyBBdHRlbXB0IHRvIGNyZWF0ZSB0aGUgZmlsZSBzdGF0dXMgdGFibGVcblx0XHRcdGNvbnN0IGNyZWF0ZUZpbGVTdGF0dXNUYWJsZVNRTCA9IGBcblx0XHRcdFx0Q1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgJHt0aGlzLkZJTEVfU1RBVFVTX1RBQkxFfSAoXG5cdFx0XHRcdFx0aWQgQklHU0VSSUFMIFBSSU1BUlkgS0VZLFxuXHRcdFx0XHRcdHZhdWx0X2lkIFRFWFQgTk9UIE5VTEwsXG5cdFx0XHRcdFx0ZmlsZV9wYXRoIFRFWFQgTk9UIE5VTEwsXG5cdFx0XHRcdFx0bGFzdF9tb2RpZmllZCBCSUdJTlQgTk9UIE5VTEwsXG5cdFx0XHRcdFx0bGFzdF92ZWN0b3JpemVkIFRJTUVTVEFNUFRaLFxuXHRcdFx0XHRcdGNvbnRlbnRfaGFzaCBURVhULFxuXHRcdFx0XHRcdHN0YXR1cyBURVhULFxuXHRcdFx0XHRcdHRhZ3MgVEVYVFtdLFxuXHRcdFx0XHRcdGFsaWFzZXMgVEVYVFtdLFxuXHRcdFx0XHRcdGxpbmtzIFRFWFRbXSxcblx0XHRcdFx0XHRjcmVhdGVkX2F0IFRJTUVTVEFNUFRaIERFRkFVTFQgQ1VSUkVOVF9USU1FU1RBTVAsXG5cdFx0XHRcdFx0dXBkYXRlZF9hdCBUSU1FU1RBTVBUWiBERUZBVUxUIENVUlJFTlRfVElNRVNUQU1QLFxuXHRcdFx0XHRcdFVOSVFVRSh2YXVsdF9pZCwgZmlsZV9wYXRoKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRDUkVBVEUgSU5ERVggSUYgTk9UIEVYSVNUUyBpZHhfZmlsZV9zdGF0dXNfdmF1bHRfcGF0aCBPTiAke3RoaXMuRklMRV9TVEFUVVNfVEFCTEV9KHZhdWx0X2lkLCBmaWxlX3BhdGgpO1xuXHRcdFx0YDtcblx0XHRcdC8vIEV4ZWN1dGUgdmlhIGEgUG9zdGdyZXMgUlBDOyBub3RlIHRoYXQgdGhpcyBtYXkgcmVxdWlyZSBlbGV2YXRlZCBwcml2aWxlZ2VzLlxuXHRcdFx0Y29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnQucnBjKCdydW5fc3FsJywgeyBzcWw6IGNyZWF0ZUZpbGVTdGF0dXNUYWJsZVNRTCB9KTtcblx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRyZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogYENvdWxkIG5vdCBjcmVhdGUgdGFibGVzOiAke2Vycm9yLm1lc3NhZ2V9YCB9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZTogJ1RhYmxlcyBjcmVhdGVkIHN1Y2Nlc3NmdWxseScgfTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0cmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6IGBFcnJvciBjcmVhdGluZyB0YWJsZXM6ICR7KGVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWAgfTtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgdXBkYXRlRmlsZVBhdGgob2xkUGF0aDogc3RyaW5nLCBuZXdQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSByZXR1cm47XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC51cGRhdGUoeyBmaWxlX3BhdGg6IG5ld1BhdGgsIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KVxuXHRcdFx0XHQuZXEoJ3ZhdWx0X2lkJywgdGhpcy5zZXR0aW5ncy52YXVsdElkKVxuXHRcdFx0XHQuZXEoJ2ZpbGVfcGF0aCcsIG9sZFBhdGgpO1xuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5sb2coYEZpbGUgcGF0aCB1cGRhdGVkIGZyb20gJHtvbGRQYXRofSB0byAke25ld1BhdGh9YCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGZpbGUgcGF0aDonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgcHVyZ2VGaWxlU3RhdHVzKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNsaWVudCBpcyBub3QgaW5pdGlhbGl6ZWQuIFNraXBwaW5nIHB1cmdlRmlsZVN0YXR1cy4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50XG5cdFx0XHRcdC5mcm9tKHRoaXMuRklMRV9TVEFUVVNfVEFCTEUpXG5cdFx0XHRcdC5kZWxldGUoKVxuXHRcdFx0XHQuZXEoJ3ZhdWx0X2lkJywgdGhpcy5zZXR0aW5ncy52YXVsdElkKVxuXHRcdFx0XHQuZXEoJ2ZpbGVfcGF0aCcsIGZpbGVQYXRoKTtcblx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBwdXJnaW5nIGZpbGUgc3RhdHVzOicsIGVycm9yKTtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cdFx0XHRjb25zb2xlLmxvZyhgUHVyZ2VkIGZpbGUgc3RhdHVzIHJlY29yZCBmb3IgJHtmaWxlUGF0aH1gKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHB1cmdlIGZpbGUgc3RhdHVzIHJlY29yZDonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGFsbCByZXF1aXJlZCB0YWJsZXMgZXhpc3QgYW5kIGFyZSBwcm9wZXJseSBzZXQgdXAuXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHN0YXR1cyBvZiBlYWNoIHRhYmxlIGFuZCBhbnkgbWlzc2luZyB0YWJsZXMuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgY2hlY2tEYXRhYmFzZVNldHVwKCk6IFByb21pc2U8e1xuXHRcdGlzQ29tcGxldGU6IGJvb2xlYW47XG5cdFx0bWlzc2luZ1RhYmxlczogc3RyaW5nW107XG5cdFx0ZXJyb3I/OiBzdHJpbmc7XG5cdH0+IHtcblx0XHRpZiAoIXRoaXMuY2xpZW50KSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRpc0NvbXBsZXRlOiBmYWxzZSxcblx0XHRcdFx0bWlzc2luZ1RhYmxlczogW3RoaXMuVEFCTEVfTkFNRSwgdGhpcy5GSUxFX1NUQVRVU19UQUJMRV0sXG5cdFx0XHRcdGVycm9yOiAnU3VwYWJhc2UgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZCdcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Y29uc3QgbWlzc2luZ1RhYmxlczogc3RyaW5nW10gPSBbXTtcblx0XHRsZXQgZXJyb3I6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBDaGVjayBvYnNpZGlhbl9kb2N1bWVudHMgdGFibGVcblx0XHRcdGNvbnN0IHsgZXJyb3I6IGRvY3VtZW50c0Vycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudFxuXHRcdFx0XHQuZnJvbSh0aGlzLlRBQkxFX05BTUUpXG5cdFx0XHRcdC5zZWxlY3QoJ2lkJylcblx0XHRcdFx0LmxpbWl0KDEpO1xuXHRcdFx0aWYgKGRvY3VtZW50c0Vycm9yICYmIGRvY3VtZW50c0Vycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcblx0XHRcdFx0bWlzc2luZ1RhYmxlcy5wdXNoKHRoaXMuVEFCTEVfTkFNRSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIG9ic2lkaWFuX2ZpbGVfc3RhdHVzIHRhYmxlXG5cdFx0XHRjb25zdCB7IGVycm9yOiBzdGF0dXNFcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnRcblx0XHRcdFx0LmZyb20odGhpcy5GSUxFX1NUQVRVU19UQUJMRSlcblx0XHRcdFx0LnNlbGVjdCgnaWQnKVxuXHRcdFx0XHQubGltaXQoMSk7XG5cdFx0XHRpZiAoc3RhdHVzRXJyb3IgJiYgc3RhdHVzRXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZG9lcyBub3QgZXhpc3QnKSkge1xuXHRcdFx0XHRtaXNzaW5nVGFibGVzLnB1c2godGhpcy5GSUxFX1NUQVRVU19UQUJMRSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGlmIHZlY3RvciBleHRlbnNpb24gaXMgaW5zdGFsbGVkXG5cdFx0XHRjb25zdCB7IGVycm9yOiB2ZWN0b3JFcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnQucnBjKCd2ZWN0b3Jfbm9ybScsIHsgdmVjdG9yOiBbMSwgMF0gfSk7XG5cdFx0XHRpZiAodmVjdG9yRXJyb3IgJiYgdmVjdG9yRXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZnVuY3Rpb24gdmVjdG9yX25vcm0nKSkge1xuXHRcdFx0XHRlcnJvciA9ICdWZWN0b3IgZXh0ZW5zaW9uIGlzIG5vdCBpbnN0YWxsZWQnO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRpc0NvbXBsZXRlOiBtaXNzaW5nVGFibGVzLmxlbmd0aCA9PT0gMCAmJiAhZXJyb3IsXG5cdFx0XHRcdG1pc3NpbmdUYWJsZXMsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgZGF0YWJhc2Ugc2V0dXA6JywgZXJyKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGlzQ29tcGxldGU6IGZhbHNlLFxuXHRcdFx0XHRtaXNzaW5nVGFibGVzOiBbdGhpcy5UQUJMRV9OQU1FLCB0aGlzLkZJTEVfU1RBVFVTX1RBQkxFXSxcblx0XHRcdFx0ZXJyb3I6IGBFcnJvciBjaGVja2luZyBkYXRhYmFzZSBzZXR1cDogJHsoZXJyIGFzIEVycm9yKS5tZXNzYWdlfWBcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlc2V0cyB0aGUgZGF0YWJhc2UgYnkgZHJvcHBpbmcgYW5kIHJlY3JlYXRpbmcgYWxsIHRhYmxlcy5cblx0ICogV0FSTklORzogVGhpcyB3aWxsIGRlbGV0ZSBhbGwgZGF0YSBpbiB0aGUgdGFibGVzLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIHJlc2V0RGF0YWJhc2UoKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U6IHN0cmluZyB9PiB7XG5cdFx0aWYgKCF0aGlzLmNsaWVudCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c3VjY2VzczogZmFsc2UsXG5cdFx0XHRcdG1lc3NhZ2U6ICdTdXBhYmFzZSBjbGllbnQgaXMgbm90IGluaXRpYWxpemVkJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gRHJvcCB0YWJsZXMgaWYgdGhleSBleGlzdFxuXHRcdFx0YXdhaXQgdGhpcy5jbGllbnQucnBjKCdkcm9wX3RhYmxlc19pZl9leGlzdCcpO1xuXHRcdFx0XG5cdFx0XHQvLyBSZWNyZWF0ZSB0YWJsZXNcblx0XHRcdGNvbnN0IHsgZXJyb3I6IGNyZWF0ZUVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudC5ycGMoJ2NyZWF0ZV9yZXF1aXJlZF90YWJsZXMnKTtcblx0XHRcdGlmIChjcmVhdGVFcnJvcikge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgdGFibGVzOiAke2NyZWF0ZUVycm9yLm1lc3NhZ2V9YCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHN1Y2Nlc3M6IHRydWUsXG5cdFx0XHRcdG1lc3NhZ2U6ICdEYXRhYmFzZSByZXNldCBzdWNjZXNzZnVsbHknXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgcmVzZXR0aW5nIGRhdGFiYXNlOicsIGVycik7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzdWNjZXNzOiBmYWxzZSxcblx0XHRcdFx0bWVzc2FnZTogYEVycm9yIHJlc2V0dGluZyBkYXRhYmFzZTogJHsoZXJyIGFzIEVycm9yKS5tZXNzYWdlfWBcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEZvcm1hdCB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdF9mb3JtYXQ6IEZvcm1hdCA9ICdSRkMzOTg2JztcbmV4cG9ydCBjb25zdCBmb3JtYXR0ZXJzOiBSZWNvcmQ8Rm9ybWF0LCAoc3RyOiBQcm9wZXJ0eUtleSkgPT4gc3RyaW5nPiA9IHtcbiAgUkZDMTczODogKHY6IFByb3BlcnR5S2V5KSA9PiBTdHJpbmcodikucmVwbGFjZSgvJTIwL2csICcrJyksXG4gIFJGQzM5ODY6ICh2OiBQcm9wZXJ0eUtleSkgPT4gU3RyaW5nKHYpLFxufTtcbmV4cG9ydCBjb25zdCBSRkMxNzM4ID0gJ1JGQzE3MzgnO1xuZXhwb3J0IGNvbnN0IFJGQzM5ODYgPSAnUkZDMzk4Nic7XG4iLCAiaW1wb3J0IHsgUkZDMTczOCB9IGZyb20gJy4vZm9ybWF0cyc7XG5pbXBvcnQgdHlwZSB7IERlZmF1bHRFbmNvZGVyLCBGb3JtYXQgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGlzX2FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuY29uc3QgaGV4X3RhYmxlID0gKCgpID0+IHtcbiAgY29uc3QgYXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgIGFycmF5LnB1c2goJyUnICsgKChpIDwgMTYgPyAnMCcgOiAnJykgKyBpLnRvU3RyaW5nKDE2KSkudG9VcHBlckNhc2UoKSk7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59KSgpO1xuXG5mdW5jdGlvbiBjb21wYWN0X3F1ZXVlPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PihxdWV1ZTogQXJyYXk8eyBvYmo6IFQ7IHByb3A6IHN0cmluZyB9Pikge1xuICB3aGlsZSAocXVldWUubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IGl0ZW0gPSBxdWV1ZS5wb3AoKTtcbiAgICBpZiAoIWl0ZW0pIGNvbnRpbnVlO1xuXG4gICAgY29uc3Qgb2JqID0gaXRlbS5vYmpbaXRlbS5wcm9wXTtcblxuICAgIGlmIChpc19hcnJheShvYmopKSB7XG4gICAgICBjb25zdCBjb21wYWN0ZWQ6IHVua25vd25bXSA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG9iai5sZW5ndGg7ICsraikge1xuICAgICAgICBpZiAodHlwZW9mIG9ialtqXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb21wYWN0ZWQucHVzaChvYmpbal0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGl0ZW0ub2JqW2l0ZW0ucHJvcF0gPSBjb21wYWN0ZWQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFycmF5X3RvX29iamVjdChzb3VyY2U6IGFueVtdLCBvcHRpb25zOiB7IHBsYWluT2JqZWN0czogYm9vbGVhbiB9KSB7XG4gIGNvbnN0IG9iaiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvYmpbaV0gPSBzb3VyY2VbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlKFxuICB0YXJnZXQ6IGFueSxcbiAgc291cmNlOiBhbnksXG4gIG9wdGlvbnM6IHsgcGxhaW5PYmplY3RzPzogYm9vbGVhbjsgYWxsb3dQcm90b3R5cGVzPzogYm9vbGVhbiB9ID0ge30sXG4pIHtcbiAgaWYgKCFzb3VyY2UpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgaWYgKGlzX2FycmF5KHRhcmdldCkpIHtcbiAgICAgIHRhcmdldC5wdXNoKHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKG9wdGlvbnMgJiYgKG9wdGlvbnMucGxhaW5PYmplY3RzIHx8IG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSkgfHxcbiAgICAgICAgIWhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNvdXJjZSlcbiAgICAgICkge1xuICAgICAgICB0YXJnZXRbc291cmNlXSA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbdGFyZ2V0LCBzb3VyY2VdO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBpZiAoIXRhcmdldCB8fCB0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBbdGFyZ2V0XS5jb25jYXQoc291cmNlKTtcbiAgfVxuXG4gIGxldCBtZXJnZVRhcmdldCA9IHRhcmdldDtcbiAgaWYgKGlzX2FycmF5KHRhcmdldCkgJiYgIWlzX2FycmF5KHNvdXJjZSkpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbWVyZ2VUYXJnZXQgPSBhcnJheV90b19vYmplY3QodGFyZ2V0LCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChpc19hcnJheSh0YXJnZXQpICYmIGlzX2FycmF5KHNvdXJjZSkpIHtcbiAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgaWYgKGhhcy5jYWxsKHRhcmdldCwgaSkpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0SXRlbSA9IHRhcmdldFtpXTtcbiAgICAgICAgaWYgKHRhcmdldEl0ZW0gJiYgdHlwZW9mIHRhcmdldEl0ZW0gPT09ICdvYmplY3QnICYmIGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGFyZ2V0W2ldID0gbWVyZ2UodGFyZ2V0SXRlbSwgaXRlbSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtpXSA9IGl0ZW07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgaWYgKGhhcy5jYWxsKGFjYywga2V5KSkge1xuICAgICAgYWNjW2tleV0gPSBtZXJnZShhY2Nba2V5XSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCBtZXJnZVRhcmdldCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25fc2luZ2xlX3NvdXJjZSh0YXJnZXQ6IGFueSwgc291cmNlOiBhbnkpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgIGFjY1trZXldID0gc291cmNlW2tleV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgdGFyZ2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShzdHI6IHN0cmluZywgXzogYW55LCBjaGFyc2V0OiBzdHJpbmcpIHtcbiAgY29uc3Qgc3RyV2l0aG91dFBsdXMgPSBzdHIucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gIGlmIChjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAvLyB1bmVzY2FwZSBuZXZlciB0aHJvd3MsIG5vIHRyeS4uLmNhdGNoIG5lZWRlZDpcbiAgICByZXR1cm4gc3RyV2l0aG91dFBsdXMucmVwbGFjZSgvJVswLTlhLWZdezJ9L2dpLCB1bmVzY2FwZSk7XG4gIH1cbiAgLy8gdXRmLThcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cldpdGhvdXRQbHVzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBzdHJXaXRob3V0UGx1cztcbiAgfVxufVxuXG5jb25zdCBsaW1pdCA9IDEwMjQ7XG5cbmV4cG9ydCBjb25zdCBlbmNvZGU6IChcbiAgc3RyOiBhbnksXG4gIGRlZmF1bHRFbmNvZGVyOiBEZWZhdWx0RW5jb2RlcixcbiAgY2hhcnNldDogc3RyaW5nLFxuICB0eXBlOiAna2V5JyB8ICd2YWx1ZScsXG4gIGZvcm1hdDogRm9ybWF0LFxuKSA9PiBzdHJpbmcgPSAoc3RyLCBfZGVmYXVsdEVuY29kZXIsIGNoYXJzZXQsIF9raW5kLCBmb3JtYXQ6IEZvcm1hdCkgPT4ge1xuICAvLyBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBieSBCcmlhbiBXaGl0ZSBmb3IgdGhlIGlvLmpzIGNvcmUgcXVlcnlzdHJpbmcgbGlicmFyeS5cbiAgLy8gSXQgaGFzIGJlZW4gYWRhcHRlZCBoZXJlIGZvciBzdHJpY3RlciBhZGhlcmVuY2UgdG8gUkZDIDM5ODZcbiAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgbGV0IHN0cmluZyA9IHN0cjtcbiAgaWYgKHR5cGVvZiBzdHIgPT09ICdzeW1ib2wnKSB7XG4gICAgc3RyaW5nID0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN0cik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSBTdHJpbmcoc3RyKTtcbiAgfVxuXG4gIGlmIChjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICByZXR1cm4gZXNjYXBlKHN0cmluZykucmVwbGFjZSgvJXVbMC05YS1mXXs0fS9naSwgZnVuY3Rpb24gKCQwKSB7XG4gICAgICByZXR1cm4gJyUyNiUyMycgKyBwYXJzZUludCgkMC5zbGljZSgyKSwgMTYpICsgJyUzQic7XG4gICAgfSk7XG4gIH1cblxuICBsZXQgb3V0ID0gJyc7XG4gIGZvciAobGV0IGogPSAwOyBqIDwgc3RyaW5nLmxlbmd0aDsgaiArPSBsaW1pdCkge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzdHJpbmcubGVuZ3RoID49IGxpbWl0ID8gc3RyaW5nLnNsaWNlKGosIGogKyBsaW1pdCkgOiBzdHJpbmc7XG4gICAgY29uc3QgYXJyID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnQubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxldCBjID0gc2VnbWVudC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKFxuICAgICAgICBjID09PSAweDJkIHx8IC8vIC1cbiAgICAgICAgYyA9PT0gMHgyZSB8fCAvLyAuXG4gICAgICAgIGMgPT09IDB4NWYgfHwgLy8gX1xuICAgICAgICBjID09PSAweDdlIHx8IC8vIH5cbiAgICAgICAgKGMgPj0gMHgzMCAmJiBjIDw9IDB4MzkpIHx8IC8vIDAtOVxuICAgICAgICAoYyA+PSAweDQxICYmIGMgPD0gMHg1YSkgfHwgLy8gYS16XG4gICAgICAgIChjID49IDB4NjEgJiYgYyA8PSAweDdhKSB8fCAvLyBBLVpcbiAgICAgICAgKGZvcm1hdCA9PT0gUkZDMTczOCAmJiAoYyA9PT0gMHgyOCB8fCBjID09PSAweDI5KSkgLy8gKCApXG4gICAgICApIHtcbiAgICAgICAgYXJyW2Fyci5sZW5ndGhdID0gc2VnbWVudC5jaGFyQXQoaSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgYXJyW2Fyci5sZW5ndGhdID0gaGV4X3RhYmxlW2NdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICBhcnJbYXJyLmxlbmd0aF0gPSBoZXhfdGFibGVbMHhjMCB8IChjID4+IDYpXSEgKyBoZXhfdGFibGVbMHg4MCB8IChjICYgMHgzZildO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGMgPCAweGQ4MDAgfHwgYyA+PSAweGUwMDApIHtcbiAgICAgICAgYXJyW2Fyci5sZW5ndGhdID1cbiAgICAgICAgICBoZXhfdGFibGVbMHhlMCB8IChjID4+IDEyKV0hICsgaGV4X3RhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNmKV0gKyBoZXhfdGFibGVbMHg4MCB8IChjICYgMHgzZildO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgICAgYyA9IDB4MTAwMDAgKyAoKChjICYgMHgzZmYpIDw8IDEwKSB8IChzZWdtZW50LmNoYXJDb2RlQXQoaSkgJiAweDNmZikpO1xuXG4gICAgICBhcnJbYXJyLmxlbmd0aF0gPVxuICAgICAgICBoZXhfdGFibGVbMHhmMCB8IChjID4+IDE4KV0hICtcbiAgICAgICAgaGV4X3RhYmxlWzB4ODAgfCAoKGMgPj4gMTIpICYgMHgzZildICtcbiAgICAgICAgaGV4X3RhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNmKV0gK1xuICAgICAgICBoZXhfdGFibGVbMHg4MCB8IChjICYgMHgzZildO1xuICAgIH1cblxuICAgIG91dCArPSBhcnIuam9pbignJyk7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhY3QodmFsdWU6IGFueSkge1xuICBjb25zdCBxdWV1ZSA9IFt7IG9iajogeyBvOiB2YWx1ZSB9LCBwcm9wOiAnbycgfV07XG4gIGNvbnN0IHJlZnMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgaXRlbSA9IHF1ZXVlW2ldO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBvYmogPSBpdGVtLm9ialtpdGVtLnByb3BdO1xuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2pdITtcbiAgICAgIGNvbnN0IHZhbCA9IG9ialtrZXldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiByZWZzLmluZGV4T2YodmFsKSA9PT0gLTEpIHtcbiAgICAgICAgcXVldWUucHVzaCh7IG9iajogb2JqLCBwcm9wOiBrZXkgfSk7XG4gICAgICAgIHJlZnMucHVzaCh2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbXBhY3RfcXVldWUocXVldWUpO1xuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzX3JlZ2V4cChvYmo6IGFueSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNfYnVmZmVyKG9iajogYW55KSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhKG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZShhOiBhbnksIGI6IGFueSkge1xuICByZXR1cm4gW10uY29uY2F0KGEsIGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVfbWFwPFQ+KHZhbDogVFtdLCBmbjogKHY6IFQpID0+IFQpIHtcbiAgaWYgKGlzX2FycmF5KHZhbCkpIHtcbiAgICBjb25zdCBtYXBwZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbWFwcGVkLnB1c2goZm4odmFsW2ldISkpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwcGVkO1xuICB9XG4gIHJldHVybiBmbih2YWwpO1xufVxuIiwgImltcG9ydCB7IGVuY29kZSwgaXNfYnVmZmVyLCBtYXliZV9tYXAgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGRlZmF1bHRfZm9ybWF0LCBmb3JtYXR0ZXJzIH0gZnJvbSAnLi9mb3JtYXRzJztcbmltcG9ydCB0eXBlIHsgTm9uTnVsbGFibGVQcm9wZXJ0aWVzLCBTdHJpbmdpZnlPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmNvbnN0IGFycmF5X3ByZWZpeF9nZW5lcmF0b3JzID0ge1xuICBicmFja2V0cyhwcmVmaXg6IFByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIFN0cmluZyhwcmVmaXgpICsgJ1tdJztcbiAgfSxcbiAgY29tbWE6ICdjb21tYScsXG4gIGluZGljZXMocHJlZml4OiBQcm9wZXJ0eUtleSwga2V5OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gU3RyaW5nKHByZWZpeCkgKyAnWycgKyBrZXkgKyAnXSc7XG4gIH0sXG4gIHJlcGVhdChwcmVmaXg6IFByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIFN0cmluZyhwcmVmaXgpO1xuICB9LFxufTtcblxuY29uc3QgaXNfYXJyYXkgPSBBcnJheS5pc0FycmF5O1xuY29uc3QgcHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xuY29uc3QgcHVzaF90b19hcnJheSA9IGZ1bmN0aW9uIChhcnI6IGFueVtdLCB2YWx1ZV9vcl9hcnJheTogYW55KSB7XG4gIHB1c2guYXBwbHkoYXJyLCBpc19hcnJheSh2YWx1ZV9vcl9hcnJheSkgPyB2YWx1ZV9vcl9hcnJheSA6IFt2YWx1ZV9vcl9hcnJheV0pO1xufTtcblxuY29uc3QgdG9fSVNPID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmc7XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBhZGRRdWVyeVByZWZpeDogZmFsc2UsXG4gIGFsbG93RG90czogZmFsc2UsXG4gIGFsbG93RW1wdHlBcnJheXM6IGZhbHNlLFxuICBhcnJheUZvcm1hdDogJ2luZGljZXMnLFxuICBjaGFyc2V0OiAndXRmLTgnLFxuICBjaGFyc2V0U2VudGluZWw6IGZhbHNlLFxuICBkZWxpbWl0ZXI6ICcmJyxcbiAgZW5jb2RlOiB0cnVlLFxuICBlbmNvZGVEb3RJbktleXM6IGZhbHNlLFxuICBlbmNvZGVyOiBlbmNvZGUsXG4gIGVuY29kZVZhbHVlc09ubHk6IGZhbHNlLFxuICBmb3JtYXQ6IGRlZmF1bHRfZm9ybWF0LFxuICBmb3JtYXR0ZXI6IGZvcm1hdHRlcnNbZGVmYXVsdF9mb3JtYXRdLFxuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgaW5kaWNlczogZmFsc2UsXG4gIHNlcmlhbGl6ZURhdGUoZGF0ZSkge1xuICAgIHJldHVybiB0b19JU08uY2FsbChkYXRlKTtcbiAgfSxcbiAgc2tpcE51bGxzOiBmYWxzZSxcbiAgc3RyaWN0TnVsbEhhbmRsaW5nOiBmYWxzZSxcbn0gYXMgTm9uTnVsbGFibGVQcm9wZXJ0aWVzPFN0cmluZ2lmeU9wdGlvbnMgJiB7IGZvcm1hdHRlcjogKHR5cGVvZiBmb3JtYXR0ZXJzKVsnUkZDMTczOCddIH0+O1xuXG5mdW5jdGlvbiBpc19ub25fbnVsbGlzaF9wcmltaXRpdmUodjogdW5rbm93bik6IHYgaXMgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IHN5bWJvbCB8IGJpZ2ludCB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHYgPT09ICdudW1iZXInIHx8XG4gICAgdHlwZW9mIHYgPT09ICdib29sZWFuJyB8fFxuICAgIHR5cGVvZiB2ID09PSAnc3ltYm9sJyB8fFxuICAgIHR5cGVvZiB2ID09PSAnYmlnaW50J1xuICApO1xufVxuXG5jb25zdCBzZW50aW5lbCA9IHt9O1xuXG5mdW5jdGlvbiBpbm5lcl9zdHJpbmdpZnkoXG4gIG9iamVjdDogYW55LFxuICBwcmVmaXg6IFByb3BlcnR5S2V5LFxuICBnZW5lcmF0ZUFycmF5UHJlZml4OiBTdHJpbmdpZnlPcHRpb25zWydhcnJheUZvcm1hdCddIHwgKChwcmVmaXg6IHN0cmluZywga2V5OiBzdHJpbmcpID0+IHN0cmluZyksXG4gIGNvbW1hUm91bmRUcmlwOiBib29sZWFuLFxuICBhbGxvd0VtcHR5QXJyYXlzOiBib29sZWFuLFxuICBzdHJpY3ROdWxsSGFuZGxpbmc6IGJvb2xlYW4sXG4gIHNraXBOdWxsczogYm9vbGVhbixcbiAgZW5jb2RlRG90SW5LZXlzOiBib29sZWFuLFxuICBlbmNvZGVyOiBTdHJpbmdpZnlPcHRpb25zWydlbmNvZGVyJ10sXG4gIGZpbHRlcjogU3RyaW5naWZ5T3B0aW9uc1snZmlsdGVyJ10sXG4gIHNvcnQ6IFN0cmluZ2lmeU9wdGlvbnNbJ3NvcnQnXSxcbiAgYWxsb3dEb3RzOiBTdHJpbmdpZnlPcHRpb25zWydhbGxvd0RvdHMnXSxcbiAgc2VyaWFsaXplRGF0ZTogU3RyaW5naWZ5T3B0aW9uc1snc2VyaWFsaXplRGF0ZSddLFxuICBmb3JtYXQ6IFN0cmluZ2lmeU9wdGlvbnNbJ2Zvcm1hdCddLFxuICBmb3JtYXR0ZXI6IFN0cmluZ2lmeU9wdGlvbnNbJ2Zvcm1hdHRlciddLFxuICBlbmNvZGVWYWx1ZXNPbmx5OiBib29sZWFuLFxuICBjaGFyc2V0OiBTdHJpbmdpZnlPcHRpb25zWydjaGFyc2V0J10sXG4gIHNpZGVDaGFubmVsOiBXZWFrTWFwPGFueSwgYW55Pixcbikge1xuICBsZXQgb2JqID0gb2JqZWN0O1xuXG4gIGxldCB0bXBfc2MgPSBzaWRlQ2hhbm5lbDtcbiAgbGV0IHN0ZXAgPSAwO1xuICBsZXQgZmluZF9mbGFnID0gZmFsc2U7XG4gIHdoaWxlICgodG1wX3NjID0gdG1wX3NjLmdldChzZW50aW5lbCkpICE9PSB2b2lkIHVuZGVmaW5lZCAmJiAhZmluZF9mbGFnKSB7XG4gICAgLy8gV2hlcmUgb2JqZWN0IGxhc3QgYXBwZWFyZWQgaW4gdGhlIHJlZiB0cmVlXG4gICAgY29uc3QgcG9zID0gdG1wX3NjLmdldChvYmplY3QpO1xuICAgIHN0ZXAgKz0gMTtcbiAgICBpZiAodHlwZW9mIHBvcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChwb3MgPT09IHN0ZXApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0N5Y2xpYyBvYmplY3QgdmFsdWUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmRfZmxhZyA9IHRydWU7IC8vIEJyZWFrIHdoaWxlXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdG1wX3NjLmdldChzZW50aW5lbCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzdGVwID0gMDtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9iaiA9IGZpbHRlcihwcmVmaXgsIG9iaik7XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIG9iaiA9IHNlcmlhbGl6ZURhdGU/LihvYmopO1xuICB9IGVsc2UgaWYgKGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgaXNfYXJyYXkob2JqKSkge1xuICAgIG9iaiA9IG1heWJlX21hcChvYmosIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplRGF0ZT8uKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBpZiAoc3RyaWN0TnVsbEhhbmRsaW5nKSB7XG4gICAgICByZXR1cm4gZW5jb2RlciAmJiAhZW5jb2RlVmFsdWVzT25seSA/XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGVuY29kZXIocHJlZml4LCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAna2V5JywgZm9ybWF0KVxuICAgICAgICA6IHByZWZpeDtcbiAgICB9XG5cbiAgICBvYmogPSAnJztcbiAgfVxuXG4gIGlmIChpc19ub25fbnVsbGlzaF9wcmltaXRpdmUob2JqKSB8fCBpc19idWZmZXIob2JqKSkge1xuICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICBjb25zdCBrZXlfdmFsdWUgPVxuICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5ID8gcHJlZml4XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICA6IGVuY29kZXIocHJlZml4LCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAna2V5JywgZm9ybWF0KTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGZvcm1hdHRlcj8uKGtleV92YWx1ZSkgK1xuICAgICAgICAgICc9JyArXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGZvcm1hdHRlcj8uKGVuY29kZXIob2JqLCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAndmFsdWUnLCBmb3JtYXQpKSxcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbZm9ybWF0dGVyPy4ocHJlZml4KSArICc9JyArIGZvcm1hdHRlcj8uKFN0cmluZyhvYmopKV07XG4gIH1cblxuICBjb25zdCB2YWx1ZXM6IHN0cmluZ1tdID0gW107XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIGxldCBvYmpfa2V5cztcbiAgaWYgKGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgaXNfYXJyYXkob2JqKSkge1xuICAgIC8vIHdlIG5lZWQgdG8gam9pbiBlbGVtZW50cyBpblxuICAgIGlmIChlbmNvZGVWYWx1ZXNPbmx5ICYmIGVuY29kZXIpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdmFsdWVzIG9ubHlcbiAgICAgIG9iaiA9IG1heWJlX21hcChvYmosIGVuY29kZXIpO1xuICAgIH1cbiAgICBvYmpfa2V5cyA9IFt7IHZhbHVlOiBvYmoubGVuZ3RoID4gMCA/IG9iai5qb2luKCcsJykgfHwgbnVsbCA6IHZvaWQgdW5kZWZpbmVkIH1dO1xuICB9IGVsc2UgaWYgKGlzX2FycmF5KGZpbHRlcikpIHtcbiAgICBvYmpfa2V5cyA9IGZpbHRlcjtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBvYmpfa2V5cyA9IHNvcnQgPyBrZXlzLnNvcnQoc29ydCkgOiBrZXlzO1xuICB9XG5cbiAgY29uc3QgZW5jb2RlZF9wcmVmaXggPSBlbmNvZGVEb3RJbktleXMgPyBTdHJpbmcocHJlZml4KS5yZXBsYWNlKC9cXC4vZywgJyUyRScpIDogU3RyaW5nKHByZWZpeCk7XG5cbiAgY29uc3QgYWRqdXN0ZWRfcHJlZml4ID1cbiAgICBjb21tYVJvdW5kVHJpcCAmJiBpc19hcnJheShvYmopICYmIG9iai5sZW5ndGggPT09IDEgPyBlbmNvZGVkX3ByZWZpeCArICdbXScgOiBlbmNvZGVkX3ByZWZpeDtcblxuICBpZiAoYWxsb3dFbXB0eUFycmF5cyAmJiBpc19hcnJheShvYmopICYmIG9iai5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYWRqdXN0ZWRfcHJlZml4ICsgJ1tdJztcbiAgfVxuXG4gIGZvciAobGV0IGogPSAwOyBqIDwgb2JqX2tleXMubGVuZ3RoOyArK2opIHtcbiAgICBjb25zdCBrZXkgPSBvYmpfa2V5c1tqXTtcbiAgICBjb25zdCB2YWx1ZSA9XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Yga2V5LnZhbHVlICE9PSAndW5kZWZpbmVkJyA/IGtleS52YWx1ZSA6IG9ialtrZXkgYXMgYW55XTtcblxuICAgIGlmIChza2lwTnVsbHMgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBlbmNvZGVkX2tleSA9IGFsbG93RG90cyAmJiBlbmNvZGVEb3RJbktleXMgPyAoa2V5IGFzIGFueSkucmVwbGFjZSgvXFwuL2csICclMkUnKSA6IGtleTtcbiAgICBjb25zdCBrZXlfcHJlZml4ID1cbiAgICAgIGlzX2FycmF5KG9iaikgP1xuICAgICAgICB0eXBlb2YgZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeChhZGp1c3RlZF9wcmVmaXgsIGVuY29kZWRfa2V5KVxuICAgICAgICA6IGFkanVzdGVkX3ByZWZpeFxuICAgICAgOiBhZGp1c3RlZF9wcmVmaXggKyAoYWxsb3dEb3RzID8gJy4nICsgZW5jb2RlZF9rZXkgOiAnWycgKyBlbmNvZGVkX2tleSArICddJyk7XG5cbiAgICBzaWRlQ2hhbm5lbC5zZXQob2JqZWN0LCBzdGVwKTtcbiAgICBjb25zdCB2YWx1ZVNpZGVDaGFubmVsID0gbmV3IFdlYWtNYXAoKTtcbiAgICB2YWx1ZVNpZGVDaGFubmVsLnNldChzZW50aW5lbCwgc2lkZUNoYW5uZWwpO1xuICAgIHB1c2hfdG9fYXJyYXkoXG4gICAgICB2YWx1ZXMsXG4gICAgICBpbm5lcl9zdHJpbmdpZnkoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBrZXlfcHJlZml4LFxuICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICBjb21tYVJvdW5kVHJpcCxcbiAgICAgICAgYWxsb3dFbXB0eUFycmF5cyxcbiAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgIGVuY29kZURvdEluS2V5cyxcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIGVuY29kZVZhbHVlc09ubHkgJiYgaXNfYXJyYXkob2JqKSA/IG51bGwgOiBlbmNvZGVyLFxuICAgICAgICBmaWx0ZXIsXG4gICAgICAgIHNvcnQsXG4gICAgICAgIGFsbG93RG90cyxcbiAgICAgICAgc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgZm9ybWF0LFxuICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgIGVuY29kZVZhbHVlc09ubHksXG4gICAgICAgIGNoYXJzZXQsXG4gICAgICAgIHZhbHVlU2lkZUNoYW5uZWwsXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gdmFsdWVzO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVfc3RyaW5naWZ5X29wdGlvbnMoXG4gIG9wdHM6IFN0cmluZ2lmeU9wdGlvbnMgPSBkZWZhdWx0cyxcbik6IE5vbk51bGxhYmxlUHJvcGVydGllczxPbWl0PFN0cmluZ2lmeU9wdGlvbnMsICdpbmRpY2VzJz4+ICYgeyBpbmRpY2VzPzogYm9vbGVhbiB9IHtcbiAgaWYgKHR5cGVvZiBvcHRzLmFsbG93RW1wdHlBcnJheXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmFsbG93RW1wdHlBcnJheXMgIT09ICdib29sZWFuJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BhbGxvd0VtcHR5QXJyYXlzYCBvcHRpb24gY2FuIG9ubHkgYmUgYHRydWVgIG9yIGBmYWxzZWAsIHdoZW4gcHJvdmlkZWQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0cy5lbmNvZGVEb3RJbktleXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmVuY29kZURvdEluS2V5cyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYGVuY29kZURvdEluS2V5c2Agb3B0aW9uIGNhbiBvbmx5IGJlIGB0cnVlYCBvciBgZmFsc2VgLCB3aGVuIHByb3ZpZGVkJyk7XG4gIH1cblxuICBpZiAob3B0cy5lbmNvZGVyICE9PSBudWxsICYmIHR5cGVvZiBvcHRzLmVuY29kZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmVuY29kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgY29uc3QgY2hhcnNldCA9IG9wdHMuY2hhcnNldCB8fCBkZWZhdWx0cy5jaGFyc2V0O1xuICBpZiAodHlwZW9mIG9wdHMuY2hhcnNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAndXRmLTgnICYmIG9wdHMuY2hhcnNldCAhPT0gJ2lzby04ODU5LTEnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNoYXJzZXQgb3B0aW9uIG11c3QgYmUgZWl0aGVyIHV0Zi04LCBpc28tODg1OS0xLCBvciB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIGxldCBmb3JtYXQgPSBkZWZhdWx0X2Zvcm1hdDtcbiAgaWYgKHR5cGVvZiBvcHRzLmZvcm1hdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoIWhhcy5jYWxsKGZvcm1hdHRlcnMsIG9wdHMuZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBmb3JtYXQgb3B0aW9uIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICBmb3JtYXQgPSBvcHRzLmZvcm1hdDtcbiAgfVxuICBjb25zdCBmb3JtYXR0ZXIgPSBmb3JtYXR0ZXJzW2Zvcm1hdF07XG5cbiAgbGV0IGZpbHRlciA9IGRlZmF1bHRzLmZpbHRlcjtcbiAgaWYgKHR5cGVvZiBvcHRzLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyB8fCBpc19hcnJheShvcHRzLmZpbHRlcikpIHtcbiAgICBmaWx0ZXIgPSBvcHRzLmZpbHRlcjtcbiAgfVxuXG4gIGxldCBhcnJheUZvcm1hdDogU3RyaW5naWZ5T3B0aW9uc1snYXJyYXlGb3JtYXQnXTtcbiAgaWYgKG9wdHMuYXJyYXlGb3JtYXQgJiYgb3B0cy5hcnJheUZvcm1hdCBpbiBhcnJheV9wcmVmaXhfZ2VuZXJhdG9ycykge1xuICAgIGFycmF5Rm9ybWF0ID0gb3B0cy5hcnJheUZvcm1hdDtcbiAgfSBlbHNlIGlmICgnaW5kaWNlcycgaW4gb3B0cykge1xuICAgIGFycmF5Rm9ybWF0ID0gb3B0cy5pbmRpY2VzID8gJ2luZGljZXMnIDogJ3JlcGVhdCc7XG4gIH0gZWxzZSB7XG4gICAgYXJyYXlGb3JtYXQgPSBkZWZhdWx0cy5hcnJheUZvcm1hdDtcbiAgfVxuXG4gIGlmICgnY29tbWFSb3VuZFRyaXAnIGluIG9wdHMgJiYgdHlwZW9mIG9wdHMuY29tbWFSb3VuZFRyaXAgIT09ICdib29sZWFuJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Bjb21tYVJvdW5kVHJpcGAgbXVzdCBiZSBhIGJvb2xlYW4sIG9yIGFic2VudCcpO1xuICB9XG5cbiAgY29uc3QgYWxsb3dEb3RzID1cbiAgICB0eXBlb2Ygb3B0cy5hbGxvd0RvdHMgPT09ICd1bmRlZmluZWQnID9cbiAgICAgICEhb3B0cy5lbmNvZGVEb3RJbktleXMgPT09IHRydWUgP1xuICAgICAgICB0cnVlXG4gICAgICA6IGRlZmF1bHRzLmFsbG93RG90c1xuICAgIDogISFvcHRzLmFsbG93RG90cztcblxuICByZXR1cm4ge1xuICAgIGFkZFF1ZXJ5UHJlZml4OiB0eXBlb2Ygb3B0cy5hZGRRdWVyeVByZWZpeCA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5hZGRRdWVyeVByZWZpeCA6IGRlZmF1bHRzLmFkZFF1ZXJ5UHJlZml4LFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBhbGxvd0RvdHM6IGFsbG93RG90cyxcbiAgICBhbGxvd0VtcHR5QXJyYXlzOlxuICAgICAgdHlwZW9mIG9wdHMuYWxsb3dFbXB0eUFycmF5cyA9PT0gJ2Jvb2xlYW4nID8gISFvcHRzLmFsbG93RW1wdHlBcnJheXMgOiBkZWZhdWx0cy5hbGxvd0VtcHR5QXJyYXlzLFxuICAgIGFycmF5Rm9ybWF0OiBhcnJheUZvcm1hdCxcbiAgICBjaGFyc2V0OiBjaGFyc2V0LFxuICAgIGNoYXJzZXRTZW50aW5lbDpcbiAgICAgIHR5cGVvZiBvcHRzLmNoYXJzZXRTZW50aW5lbCA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5jaGFyc2V0U2VudGluZWwgOiBkZWZhdWx0cy5jaGFyc2V0U2VudGluZWwsXG4gICAgY29tbWFSb3VuZFRyaXA6ICEhb3B0cy5jb21tYVJvdW5kVHJpcCxcbiAgICBkZWxpbWl0ZXI6IHR5cGVvZiBvcHRzLmRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5kZWxpbWl0ZXIgOiBvcHRzLmRlbGltaXRlcixcbiAgICBlbmNvZGU6IHR5cGVvZiBvcHRzLmVuY29kZSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5lbmNvZGUgOiBkZWZhdWx0cy5lbmNvZGUsXG4gICAgZW5jb2RlRG90SW5LZXlzOlxuICAgICAgdHlwZW9mIG9wdHMuZW5jb2RlRG90SW5LZXlzID09PSAnYm9vbGVhbicgPyBvcHRzLmVuY29kZURvdEluS2V5cyA6IGRlZmF1bHRzLmVuY29kZURvdEluS2V5cyxcbiAgICBlbmNvZGVyOiB0eXBlb2Ygb3B0cy5lbmNvZGVyID09PSAnZnVuY3Rpb24nID8gb3B0cy5lbmNvZGVyIDogZGVmYXVsdHMuZW5jb2RlcixcbiAgICBlbmNvZGVWYWx1ZXNPbmx5OlxuICAgICAgdHlwZW9mIG9wdHMuZW5jb2RlVmFsdWVzT25seSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5lbmNvZGVWYWx1ZXNPbmx5IDogZGVmYXVsdHMuZW5jb2RlVmFsdWVzT25seSxcbiAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcbiAgICBzZXJpYWxpemVEYXRlOiB0eXBlb2Ygb3B0cy5zZXJpYWxpemVEYXRlID09PSAnZnVuY3Rpb24nID8gb3B0cy5zZXJpYWxpemVEYXRlIDogZGVmYXVsdHMuc2VyaWFsaXplRGF0ZSxcbiAgICBza2lwTnVsbHM6IHR5cGVvZiBvcHRzLnNraXBOdWxscyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5za2lwTnVsbHMgOiBkZWZhdWx0cy5za2lwTnVsbHMsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHNvcnQ6IHR5cGVvZiBvcHRzLnNvcnQgPT09ICdmdW5jdGlvbicgPyBvcHRzLnNvcnQgOiBudWxsLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzpcbiAgICAgIHR5cGVvZiBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgOiBkZWZhdWx0cy5zdHJpY3ROdWxsSGFuZGxpbmcsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkob2JqZWN0OiBhbnksIG9wdHM6IFN0cmluZ2lmeU9wdGlvbnMgPSB7fSkge1xuICBsZXQgb2JqID0gb2JqZWN0O1xuICBjb25zdCBvcHRpb25zID0gbm9ybWFsaXplX3N0cmluZ2lmeV9vcHRpb25zKG9wdHMpO1xuXG4gIGxldCBvYmpfa2V5czogUHJvcGVydHlLZXlbXSB8IHVuZGVmaW5lZDtcbiAgbGV0IGZpbHRlcjtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgb2JqID0gZmlsdGVyKCcnLCBvYmopO1xuICB9IGVsc2UgaWYgKGlzX2FycmF5KG9wdGlvbnMuZmlsdGVyKSkge1xuICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgIG9ial9rZXlzID0gZmlsdGVyO1xuICB9XG5cbiAgY29uc3Qga2V5czogc3RyaW5nW10gPSBbXTtcblxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgY29uc3QgZ2VuZXJhdGVBcnJheVByZWZpeCA9IGFycmF5X3ByZWZpeF9nZW5lcmF0b3JzW29wdGlvbnMuYXJyYXlGb3JtYXRdO1xuICBjb25zdCBjb21tYVJvdW5kVHJpcCA9IGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgb3B0aW9ucy5jb21tYVJvdW5kVHJpcDtcblxuICBpZiAoIW9ial9rZXlzKSB7XG4gICAgb2JqX2tleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgIG9ial9rZXlzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgfVxuXG4gIGNvbnN0IHNpZGVDaGFubmVsID0gbmV3IFdlYWtNYXAoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmpfa2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGtleSA9IG9ial9rZXlzW2ldITtcblxuICAgIGlmIChvcHRpb25zLnNraXBOdWxscyAmJiBvYmpba2V5XSA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHB1c2hfdG9fYXJyYXkoXG4gICAgICBrZXlzLFxuICAgICAgaW5uZXJfc3RyaW5naWZ5KFxuICAgICAgICBvYmpba2V5XSxcbiAgICAgICAga2V5LFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgICAgIGNvbW1hUm91bmRUcmlwLFxuICAgICAgICBvcHRpb25zLmFsbG93RW1wdHlBcnJheXMsXG4gICAgICAgIG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICBvcHRpb25zLnNraXBOdWxscyxcbiAgICAgICAgb3B0aW9ucy5lbmNvZGVEb3RJbktleXMsXG4gICAgICAgIG9wdGlvbnMuZW5jb2RlID8gb3B0aW9ucy5lbmNvZGVyIDogbnVsbCxcbiAgICAgICAgb3B0aW9ucy5maWx0ZXIsXG4gICAgICAgIG9wdGlvbnMuc29ydCxcbiAgICAgICAgb3B0aW9ucy5hbGxvd0RvdHMsXG4gICAgICAgIG9wdGlvbnMuc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgb3B0aW9ucy5mb3JtYXQsXG4gICAgICAgIG9wdGlvbnMuZm9ybWF0dGVyLFxuICAgICAgICBvcHRpb25zLmVuY29kZVZhbHVlc09ubHksXG4gICAgICAgIG9wdGlvbnMuY2hhcnNldCxcbiAgICAgICAgc2lkZUNoYW5uZWwsXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBqb2luZWQgPSBrZXlzLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIpO1xuICBsZXQgcHJlZml4ID0gb3B0aW9ucy5hZGRRdWVyeVByZWZpeCA9PT0gdHJ1ZSA/ICc/JyA6ICcnO1xuXG4gIGlmIChvcHRpb25zLmNoYXJzZXRTZW50aW5lbCkge1xuICAgIGlmIChvcHRpb25zLmNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCcmIzEwMDAzOycpLCB0aGUgXCJudW1lcmljIGVudGl0eVwiIHJlcHJlc2VudGF0aW9uIG9mIGEgY2hlY2ttYXJrXG4gICAgICBwcmVmaXggKz0gJ3V0Zjg9JTI2JTIzMTAwMDMlM0ImJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCdcdTI3MTMnKVxuICAgICAgcHJlZml4ICs9ICd1dGY4PSVFMiU5QyU5MyYnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBqb2luZWQubGVuZ3RoID4gMCA/IHByZWZpeCArIGpvaW5lZCA6ICcnO1xufVxuIiwgImV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzQuNzkuMSc7IC8vIHgtcmVsZWFzZS1wbGVhc2UtdmVyc2lvblxuIiwgIi8qKlxuICogRGlzY2xhaW1lcjogbW9kdWxlcyBpbiBfc2hpbXMgYXJlbid0IGludGVuZGVkIHRvIGJlIGltcG9ydGVkIGJ5IFNESyB1c2Vycy5cbiAqL1xuaW1wb3J0IHsgdHlwZSBSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uL2NvcmUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNoaW1zIHtcbiAga2luZDogc3RyaW5nO1xuICBmZXRjaDogYW55O1xuICBSZXF1ZXN0OiBhbnk7XG4gIFJlc3BvbnNlOiBhbnk7XG4gIEhlYWRlcnM6IGFueTtcbiAgRm9ybURhdGE6IGFueTtcbiAgQmxvYjogYW55O1xuICBGaWxlOiBhbnk7XG4gIFJlYWRhYmxlU3RyZWFtOiBhbnk7XG4gIGdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zOiA8VCA9IFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgICBmb3JtOiBTaGltc1snRm9ybURhdGEnXSxcbiAgICBvcHRzOiBSZXF1ZXN0T3B0aW9uczxUPixcbiAgKSA9PiBQcm9taXNlPFJlcXVlc3RPcHRpb25zPFQ+PjtcbiAgZ2V0RGVmYXVsdEFnZW50OiAodXJsOiBzdHJpbmcpID0+IGFueTtcbiAgZmlsZUZyb21QYXRoOlxuICAgIHwgKChwYXRoOiBzdHJpbmcsIGZpbGVuYW1lPzogc3RyaW5nLCBvcHRpb25zPzoge30pID0+IFByb21pc2U8U2hpbXNbJ0ZpbGUnXT4pXG4gICAgfCAoKHBhdGg6IHN0cmluZywgb3B0aW9ucz86IHt9KSA9PiBQcm9taXNlPFNoaW1zWydGaWxlJ10+KTtcbiAgaXNGc1JlYWRTdHJlYW06ICh2YWx1ZTogYW55KSA9PiBib29sZWFuO1xufVxuXG5leHBvcnQgbGV0IGF1dG8gPSBmYWxzZTtcbmV4cG9ydCBsZXQga2luZDogU2hpbXNbJ2tpbmQnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgZmV0Y2g6IFNoaW1zWydmZXRjaCddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBSZXF1ZXN0OiBTaGltc1snUmVxdWVzdCddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBSZXNwb25zZTogU2hpbXNbJ1Jlc3BvbnNlJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IEhlYWRlcnM6IFNoaW1zWydIZWFkZXJzJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IEZvcm1EYXRhOiBTaGltc1snRm9ybURhdGEnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgQmxvYjogU2hpbXNbJ0Jsb2InXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgRmlsZTogU2hpbXNbJ0ZpbGUnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgUmVhZGFibGVTdHJlYW06IFNoaW1zWydSZWFkYWJsZVN0cmVhbSddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9uczogU2hpbXNbJ2dldE11bHRpcGFydFJlcXVlc3RPcHRpb25zJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGdldERlZmF1bHRBZ2VudDogU2hpbXNbJ2dldERlZmF1bHRBZ2VudCddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBmaWxlRnJvbVBhdGg6IFNoaW1zWydmaWxlRnJvbVBhdGgnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgaXNGc1JlYWRTdHJlYW06IFNoaW1zWydpc0ZzUmVhZFN0cmVhbSddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0U2hpbXMoc2hpbXM6IFNoaW1zLCBvcHRpb25zOiB7IGF1dG86IGJvb2xlYW4gfSA9IHsgYXV0bzogZmFsc2UgfSkge1xuICBpZiAoYXV0bykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGB5b3UgbXVzdCBcXGBpbXBvcnQgJ29wZW5haS9zaGltcy8ke3NoaW1zLmtpbmR9J1xcYCBiZWZvcmUgaW1wb3J0aW5nIGFueXRoaW5nIGVsc2UgZnJvbSBvcGVuYWlgLFxuICAgICk7XG4gIH1cbiAgaWYgKGtpbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbid0IFxcYGltcG9ydCAnb3BlbmFpL3NoaW1zLyR7c2hpbXMua2luZH0nXFxgIGFmdGVyIFxcYGltcG9ydCAnb3BlbmFpL3NoaW1zLyR7a2luZH0nXFxgYCk7XG4gIH1cbiAgYXV0byA9IG9wdGlvbnMuYXV0bztcbiAga2luZCA9IHNoaW1zLmtpbmQ7XG4gIGZldGNoID0gc2hpbXMuZmV0Y2g7XG4gIFJlcXVlc3QgPSBzaGltcy5SZXF1ZXN0O1xuICBSZXNwb25zZSA9IHNoaW1zLlJlc3BvbnNlO1xuICBIZWFkZXJzID0gc2hpbXMuSGVhZGVycztcbiAgRm9ybURhdGEgPSBzaGltcy5Gb3JtRGF0YTtcbiAgQmxvYiA9IHNoaW1zLkJsb2I7XG4gIEZpbGUgPSBzaGltcy5GaWxlO1xuICBSZWFkYWJsZVN0cmVhbSA9IHNoaW1zLlJlYWRhYmxlU3RyZWFtO1xuICBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucyA9IHNoaW1zLmdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zO1xuICBnZXREZWZhdWx0QWdlbnQgPSBzaGltcy5nZXREZWZhdWx0QWdlbnQ7XG4gIGZpbGVGcm9tUGF0aCA9IHNoaW1zLmZpbGVGcm9tUGF0aDtcbiAgaXNGc1JlYWRTdHJlYW0gPSBzaGltcy5pc0ZzUmVhZFN0cmVhbTtcbn1cbiIsICIvKipcbiAqIERpc2NsYWltZXI6IG1vZHVsZXMgaW4gX3NoaW1zIGFyZW4ndCBpbnRlbmRlZCB0byBiZSBpbXBvcnRlZCBieSBTREsgdXNlcnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNdWx0aXBhcnRCb2R5IHtcbiAgY29uc3RydWN0b3IocHVibGljIGJvZHk6IGFueSkge31cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdNdWx0aXBhcnRCb2R5JztcbiAgfVxufVxuIiwgIi8qKlxuICogRGlzY2xhaW1lcjogbW9kdWxlcyBpbiBfc2hpbXMgYXJlbid0IGludGVuZGVkIHRvIGJlIGltcG9ydGVkIGJ5IFNESyB1c2Vycy5cbiAqL1xuaW1wb3J0IHsgTXVsdGlwYXJ0Qm9keSB9IGZyb20gJy4vTXVsdGlwYXJ0Qm9keSc7XG5pbXBvcnQgeyB0eXBlIFJlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgeyB0eXBlIFNoaW1zIH0gZnJvbSAnLi9yZWdpc3RyeSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdW50aW1lKHsgbWFudWFsbHlJbXBvcnRlZCB9OiB7IG1hbnVhbGx5SW1wb3J0ZWQ/OiBib29sZWFuIH0gPSB7fSk6IFNoaW1zIHtcbiAgY29uc3QgcmVjb21tZW5kYXRpb24gPVxuICAgIG1hbnVhbGx5SW1wb3J0ZWQgP1xuICAgICAgYFlvdSBtYXkgbmVlZCB0byB1c2UgcG9seWZpbGxzYFxuICAgIDogYEFkZCBvbmUgb2YgdGhlc2UgaW1wb3J0cyBiZWZvcmUgeW91ciBmaXJzdCBcXGBpbXBvcnQgXHUyMDI2IGZyb20gJ29wZW5haSdcXGA6XG4tIFxcYGltcG9ydCAnb3BlbmFpL3NoaW1zL25vZGUnXFxgIChpZiB5b3UncmUgcnVubmluZyBvbiBOb2RlKVxuLSBcXGBpbXBvcnQgJ29wZW5haS9zaGltcy93ZWInXFxgIChvdGhlcndpc2UpXG5gO1xuXG4gIGxldCBfZmV0Y2gsIF9SZXF1ZXN0LCBfUmVzcG9uc2UsIF9IZWFkZXJzO1xuICB0cnkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBfZmV0Y2ggPSBmZXRjaDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgX1JlcXVlc3QgPSBSZXF1ZXN0O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBfUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgX0hlYWRlcnMgPSBIZWFkZXJzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGB0aGlzIGVudmlyb25tZW50IGlzIG1pc3NpbmcgdGhlIGZvbGxvd2luZyBXZWIgRmV0Y2ggQVBJIHR5cGU6ICR7XG4gICAgICAgIChlcnJvciBhcyBhbnkpLm1lc3NhZ2VcbiAgICAgIH0uICR7cmVjb21tZW5kYXRpb259YCxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnd2ViJyxcbiAgICBmZXRjaDogX2ZldGNoLFxuICAgIFJlcXVlc3Q6IF9SZXF1ZXN0LFxuICAgIFJlc3BvbnNlOiBfUmVzcG9uc2UsXG4gICAgSGVhZGVyczogX0hlYWRlcnMsXG4gICAgRm9ybURhdGE6XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnID8gRm9ybURhdGEgOiAoXG4gICAgICAgIGNsYXNzIEZvcm1EYXRhIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBmaWxlIHVwbG9hZHMgYXJlbid0IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50IHlldCBhcyAnRm9ybURhdGEnIGlzIHVuZGVmaW5lZC4gJHtyZWNvbW1lbmRhdGlvbn1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgQmxvYjpcbiAgICAgIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyA/IEJsb2IgOiAoXG4gICAgICAgIGNsYXNzIEJsb2Ige1xuICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgZmlsZSB1cGxvYWRzIGFyZW4ndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCB5ZXQgYXMgJ0Jsb2InIGlzIHVuZGVmaW5lZC4gJHtyZWNvbW1lbmRhdGlvbn1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgRmlsZTpcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyA/IEZpbGUgOiAoXG4gICAgICAgIGNsYXNzIEZpbGUge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYGZpbGUgdXBsb2FkcyBhcmVuJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQgeWV0IGFzICdGaWxlJyBpcyB1bmRlZmluZWQuICR7cmVjb21tZW5kYXRpb259YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgIFJlYWRhYmxlU3RyZWFtOlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdHlwZW9mIFJlYWRhYmxlU3RyZWFtICE9PSAndW5kZWZpbmVkJyA/IFJlYWRhYmxlU3RyZWFtIDogKFxuICAgICAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgc3RyZWFtaW5nIGlzbid0IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50IHlldCBhcyAnUmVhZGFibGVTdHJlYW0nIGlzIHVuZGVmaW5lZC4gJHtyZWNvbW1lbmRhdGlvbn1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnM6IGFzeW5jIDxUID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZm9ybTogRm9ybURhdGEsXG4gICAgICBvcHRzOiBSZXF1ZXN0T3B0aW9uczxUPixcbiAgICApOiBQcm9taXNlPFJlcXVlc3RPcHRpb25zPFQ+PiA9PiAoe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGJvZHk6IG5ldyBNdWx0aXBhcnRCb2R5KGZvcm0pIGFzIGFueSxcbiAgICB9KSxcbiAgICBnZXREZWZhdWx0QWdlbnQ6ICh1cmw6IHN0cmluZykgPT4gdW5kZWZpbmVkLFxuICAgIGZpbGVGcm9tUGF0aDogKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIGBmaWxlRnJvbVBhdGhgIGZ1bmN0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGluIE5vZGUuIFNlZSB0aGUgUkVBRE1FIGZvciBtb3JlIGRldGFpbHM6IGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlI2ZpbGUtdXBsb2FkcycsXG4gICAgICApO1xuICAgIH0sXG4gICAgaXNGc1JlYWRTdHJlYW06ICh2YWx1ZTogYW55KSA9PiBmYWxzZSxcbiAgfTtcbn1cbiIsICIvKipcbiAqIERpc2NsYWltZXI6IG1vZHVsZXMgaW4gX3NoaW1zIGFyZW4ndCBpbnRlbmRlZCB0byBiZSBpbXBvcnRlZCBieSBTREsgdXNlcnMuXG4gKi9cbmltcG9ydCAqIGFzIHNoaW1zIGZyb20gJy4vcmVnaXN0cnkubWpzJztcbmltcG9ydCAqIGFzIGF1dG8gZnJvbSAnb3BlbmFpL19zaGltcy9hdXRvL3J1bnRpbWUnO1xuaWYgKCFzaGltcy5raW5kKSBzaGltcy5zZXRTaGltcyhhdXRvLmdldFJ1bnRpbWUoKSwgeyBhdXRvOiB0cnVlIH0pO1xuZXhwb3J0ICogZnJvbSAnLi9yZWdpc3RyeS5tanMnO1xuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IGNhc3RUb0Vycm9yLCBIZWFkZXJzIH0gZnJvbSAnLi9jb3JlJztcblxuZXhwb3J0IGNsYXNzIE9wZW5BSUVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuZXhwb3J0IGNsYXNzIEFQSUVycm9yPFxuICBUU3RhdHVzIGV4dGVuZHMgbnVtYmVyIHwgdW5kZWZpbmVkID0gbnVtYmVyIHwgdW5kZWZpbmVkLFxuICBUSGVhZGVycyBleHRlbmRzIEhlYWRlcnMgfCB1bmRlZmluZWQgPSBIZWFkZXJzIHwgdW5kZWZpbmVkLFxuICBURXJyb3IgZXh0ZW5kcyBPYmplY3QgfCB1bmRlZmluZWQgPSBPYmplY3QgfCB1bmRlZmluZWQsXG4+IGV4dGVuZHMgT3BlbkFJRXJyb3Ige1xuICAvKiogSFRUUCBzdGF0dXMgZm9yIHRoZSByZXNwb25zZSB0aGF0IGNhdXNlZCB0aGUgZXJyb3IgKi9cbiAgcmVhZG9ubHkgc3RhdHVzOiBUU3RhdHVzO1xuICAvKiogSFRUUCBoZWFkZXJzIGZvciB0aGUgcmVzcG9uc2UgdGhhdCBjYXVzZWQgdGhlIGVycm9yICovXG4gIHJlYWRvbmx5IGhlYWRlcnM6IFRIZWFkZXJzO1xuICAvKiogSlNPTiBib2R5IG9mIHRoZSByZXNwb25zZSB0aGF0IGNhdXNlZCB0aGUgZXJyb3IgKi9cbiAgcmVhZG9ubHkgZXJyb3I6IFRFcnJvcjtcblxuICByZWFkb25seSBjb2RlOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xuICByZWFkb25seSBwYXJhbTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIHJlYWRvbmx5IHJlcXVlc3RfaWQ6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3Ioc3RhdHVzOiBUU3RhdHVzLCBlcnJvcjogVEVycm9yLCBtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGhlYWRlcnM6IFRIZWFkZXJzKSB7XG4gICAgc3VwZXIoYCR7QVBJRXJyb3IubWFrZU1lc3NhZ2Uoc3RhdHVzLCBlcnJvciwgbWVzc2FnZSl9YCk7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLnJlcXVlc3RfaWQgPSBoZWFkZXJzPy5bJ3gtcmVxdWVzdC1pZCddO1xuICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcblxuICAgIGNvbnN0IGRhdGEgPSBlcnJvciBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIHRoaXMuY29kZSA9IGRhdGE/LlsnY29kZSddO1xuICAgIHRoaXMucGFyYW0gPSBkYXRhPy5bJ3BhcmFtJ107XG4gICAgdGhpcy50eXBlID0gZGF0YT8uWyd0eXBlJ107XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBtYWtlTWVzc2FnZShzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZCwgZXJyb3I6IGFueSwgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbXNnID1cbiAgICAgIGVycm9yPy5tZXNzYWdlID9cbiAgICAgICAgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnID9cbiAgICAgICAgICBlcnJvci5tZXNzYWdlXG4gICAgICAgIDogSlNPTi5zdHJpbmdpZnkoZXJyb3IubWVzc2FnZSlcbiAgICAgIDogZXJyb3IgPyBKU09OLnN0cmluZ2lmeShlcnJvcilcbiAgICAgIDogbWVzc2FnZTtcblxuICAgIGlmIChzdGF0dXMgJiYgbXNnKSB7XG4gICAgICByZXR1cm4gYCR7c3RhdHVzfSAke21zZ31gO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzKSB7XG4gICAgICByZXR1cm4gYCR7c3RhdHVzfSBzdGF0dXMgY29kZSAobm8gYm9keSlgO1xuICAgIH1cbiAgICBpZiAobXNnKSB7XG4gICAgICByZXR1cm4gbXNnO1xuICAgIH1cbiAgICByZXR1cm4gJyhubyBzdGF0dXMgY29kZSBvciBib2R5KSc7XG4gIH1cblxuICBzdGF0aWMgZ2VuZXJhdGUoXG4gICAgc3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gICAgZXJyb3JSZXNwb25zZTogT2JqZWN0IHwgdW5kZWZpbmVkLFxuICAgIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBoZWFkZXJzOiBIZWFkZXJzIHwgdW5kZWZpbmVkLFxuICApOiBBUElFcnJvciB7XG4gICAgaWYgKCFzdGF0dXMgfHwgIWhlYWRlcnMpIHtcbiAgICAgIHJldHVybiBuZXcgQVBJQ29ubmVjdGlvbkVycm9yKHsgbWVzc2FnZSwgY2F1c2U6IGNhc3RUb0Vycm9yKGVycm9yUmVzcG9uc2UpIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGVycm9yID0gKGVycm9yUmVzcG9uc2UgYXMgUmVjb3JkPHN0cmluZywgYW55Pik/LlsnZXJyb3InXTtcblxuICAgIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgICAgcmV0dXJuIG5ldyBCYWRSZXF1ZXN0RXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICByZXR1cm4gbmV3IFBlcm1pc3Npb25EZW5pZWRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIHJldHVybiBuZXcgTm90Rm91bmRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MDkpIHtcbiAgICAgIHJldHVybiBuZXcgQ29uZmxpY3RFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MjIpIHtcbiAgICAgIHJldHVybiBuZXcgVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IDQyOSkge1xuICAgICAgcmV0dXJuIG5ldyBSYXRlTGltaXRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID49IDUwMCkge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbFNlcnZlckVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQVBJRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFQSVVzZXJBYm9ydEVycm9yIGV4dGVuZHMgQVBJRXJyb3I8dW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZD4ge1xuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfTogeyBtZXNzYWdlPzogc3RyaW5nIH0gPSB7fSkge1xuICAgIHN1cGVyKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBtZXNzYWdlIHx8ICdSZXF1ZXN0IHdhcyBhYm9ydGVkLicsIHVuZGVmaW5lZCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFQSUNvbm5lY3Rpb25FcnJvciBleHRlbmRzIEFQSUVycm9yPHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQ+IHtcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlLCBjYXVzZSB9OiB7IG1lc3NhZ2U/OiBzdHJpbmcgfCB1bmRlZmluZWQ7IGNhdXNlPzogRXJyb3IgfCB1bmRlZmluZWQgfSkge1xuICAgIHN1cGVyKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBtZXNzYWdlIHx8ICdDb25uZWN0aW9uIGVycm9yLicsIHVuZGVmaW5lZCk7XG4gICAgLy8gaW4gc29tZSBlbnZpcm9ubWVudHMgdGhlICdjYXVzZScgcHJvcGVydHkgaXMgYWxyZWFkeSBkZWNsYXJlZFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoY2F1c2UpIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvciBleHRlbmRzIEFQSUNvbm5lY3Rpb25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9OiB7IG1lc3NhZ2U/OiBzdHJpbmcgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBtZXNzYWdlOiBtZXNzYWdlID8/ICdSZXF1ZXN0IHRpbWVkIG91dC4nIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCYWRSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBBUElFcnJvcjw0MDAsIEhlYWRlcnM+IHt9XG5cbmV4cG9ydCBjbGFzcyBBdXRoZW50aWNhdGlvbkVycm9yIGV4dGVuZHMgQVBJRXJyb3I8NDAxLCBIZWFkZXJzPiB7fVxuXG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbkRlbmllZEVycm9yIGV4dGVuZHMgQVBJRXJyb3I8NDAzLCBIZWFkZXJzPiB7fVxuXG5leHBvcnQgY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIEFQSUVycm9yPDQwNCwgSGVhZGVycz4ge31cblxuZXhwb3J0IGNsYXNzIENvbmZsaWN0RXJyb3IgZXh0ZW5kcyBBUElFcnJvcjw0MDksIEhlYWRlcnM+IHt9XG5cbmV4cG9ydCBjbGFzcyBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IgZXh0ZW5kcyBBUElFcnJvcjw0MjIsIEhlYWRlcnM+IHt9XG5cbmV4cG9ydCBjbGFzcyBSYXRlTGltaXRFcnJvciBleHRlbmRzIEFQSUVycm9yPDQyOSwgSGVhZGVycz4ge31cblxuZXhwb3J0IGNsYXNzIEludGVybmFsU2VydmVyRXJyb3IgZXh0ZW5kcyBBUElFcnJvcjxudW1iZXIsIEhlYWRlcnM+IHt9XG5cbmV4cG9ydCBjbGFzcyBMZW5ndGhGaW5pc2hSZWFzb25FcnJvciBleHRlbmRzIE9wZW5BSUVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYENvdWxkIG5vdCBwYXJzZSByZXNwb25zZSBjb250ZW50IGFzIHRoZSBsZW5ndGggbGltaXQgd2FzIHJlYWNoZWRgKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ29udGVudEZpbHRlckZpbmlzaFJlYXNvbkVycm9yIGV4dGVuZHMgT3BlbkFJRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihgQ291bGQgbm90IHBhcnNlIHJlc3BvbnNlIGNvbnRlbnQgYXMgdGhlIHJlcXVlc3Qgd2FzIHJlamVjdGVkIGJ5IHRoZSBjb250ZW50IGZpbHRlcmApO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgT3BlbkFJRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcic7XG5cbnR5cGUgQnl0ZXMgPSBzdHJpbmcgfCBBcnJheUJ1ZmZlciB8IFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgcmUtaW1wbGVtZW50YXRpb24gb2YgaHR0cHgncyBgTGluZURlY29kZXJgIGluIFB5dGhvbiB0aGF0IGhhbmRsZXMgaW5jcmVtZW50YWxseVxuICogcmVhZGluZyBsaW5lcyBmcm9tIHRleHQuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2VuY29kZS9odHRweC9ibG9iLzkyMDMzM2VhOTgxMThlOWNmNjE3ZjI0NjkwNWQ3YjIwMjUxMDk0MWMvaHR0cHgvX2RlY29kZXJzLnB5I0wyNThcbiAqL1xuZXhwb3J0IGNsYXNzIExpbmVEZWNvZGVyIHtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHN0YXRpYyBORVdMSU5FX0NIQVJTID0gbmV3IFNldChbJ1xcbicsICdcXHInXSk7XG4gIHN0YXRpYyBORVdMSU5FX1JFR0VYUCA9IC9cXHJcXG58W1xcblxccl0vZztcblxuICBidWZmZXI6IHN0cmluZ1tdO1xuICB0cmFpbGluZ0NSOiBib29sZWFuO1xuICB0ZXh0RGVjb2RlcjogYW55OyAvLyBUZXh0RGVjb2RlciBmb3VuZCBpbiBicm93c2Vyczsgbm90IHR5cGVkIHRvIGF2b2lkIHB1bGxpbmcgaW4gZWl0aGVyIFwiZG9tXCIgb3IgXCJub2RlXCIgdHlwZXMuXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB0aGlzLnRyYWlsaW5nQ1IgPSBmYWxzZTtcbiAgfVxuXG4gIGRlY29kZShjaHVuazogQnl0ZXMpOiBzdHJpbmdbXSB7XG4gICAgbGV0IHRleHQgPSB0aGlzLmRlY29kZVRleHQoY2h1bmspO1xuXG4gICAgaWYgKHRoaXMudHJhaWxpbmdDUikge1xuICAgICAgdGV4dCA9ICdcXHInICsgdGV4dDtcbiAgICAgIHRoaXMudHJhaWxpbmdDUiA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGV4dC5lbmRzV2l0aCgnXFxyJykpIHtcbiAgICAgIHRoaXMudHJhaWxpbmdDUiA9IHRydWU7XG4gICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgfVxuXG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgdHJhaWxpbmdOZXdsaW5lID0gTGluZURlY29kZXIuTkVXTElORV9DSEFSUy5oYXModGV4dFt0ZXh0Lmxlbmd0aCAtIDFdIHx8ICcnKTtcbiAgICBsZXQgbGluZXMgPSB0ZXh0LnNwbGl0KExpbmVEZWNvZGVyLk5FV0xJTkVfUkVHRVhQKTtcblxuICAgIC8vIGlmIHRoZXJlIGlzIGEgdHJhaWxpbmcgbmV3IGxpbmUgdGhlbiB0aGUgbGFzdCBlbnRyeSB3aWxsIGJlIGFuIGVtcHR5XG4gICAgLy8gc3RyaW5nIHdoaWNoIHdlIGRvbid0IGNhcmUgYWJvdXRcbiAgICBpZiAodHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICBsaW5lcy5wb3AoKTtcbiAgICB9XG5cbiAgICBpZiAobGluZXMubGVuZ3RoID09PSAxICYmICF0cmFpbGluZ05ld2xpbmUpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2gobGluZXNbMF0hKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgbGluZXMgPSBbdGhpcy5idWZmZXIuam9pbignJykgKyBsaW5lc1swXSwgLi4ubGluZXMuc2xpY2UoMSldO1xuICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoIXRyYWlsaW5nTmV3bGluZSkge1xuICAgICAgdGhpcy5idWZmZXIgPSBbbGluZXMucG9wKCkgfHwgJyddO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuXG4gIGRlY29kZVRleHQoYnl0ZXM6IEJ5dGVzKTogc3RyaW5nIHtcbiAgICBpZiAoYnl0ZXMgPT0gbnVsbCkgcmV0dXJuICcnO1xuICAgIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSByZXR1cm4gYnl0ZXM7XG5cbiAgICAvLyBOb2RlOlxuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBieXRlcy50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMpLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihcbiAgICAgICAgYFVuZXhwZWN0ZWQ6IHJlY2VpdmVkIG5vbi1VaW50OEFycmF5ICgke2J5dGVzLmNvbnN0cnVjdG9yLm5hbWV9KSBzdHJlYW0gY2h1bmsgaW4gYW4gZW52aXJvbm1lbnQgd2l0aCBhIGdsb2JhbCBcIkJ1ZmZlclwiIGRlZmluZWQsIHdoaWNoIHRoaXMgbGlicmFyeSBhc3N1bWVzIHRvIGJlIE5vZGUuIFBsZWFzZSByZXBvcnQgdGhpcyBlcnJvci5gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBCcm93c2VyXG4gICAgaWYgKHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgYnl0ZXMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICB0aGlzLnRleHREZWNvZGVyID8/PSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dERlY29kZXIuZGVjb2RlKGJ5dGVzKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZDogcmVjZWl2ZWQgbm9uLVVpbnQ4QXJyYXkvQXJyYXlCdWZmZXIgKCR7XG4gICAgICAgICAgKGJ5dGVzIGFzIGFueSkuY29uc3RydWN0b3IubmFtZVxuICAgICAgICB9KSBpbiBhIHdlYiBwbGF0Zm9ybS4gUGxlYXNlIHJlcG9ydCB0aGlzIGVycm9yLmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihcbiAgICAgIGBVbmV4cGVjdGVkOiBuZWl0aGVyIEJ1ZmZlciBub3IgVGV4dERlY29kZXIgYXJlIGF2YWlsYWJsZSBhcyBnbG9iYWxzLiBQbGVhc2UgcmVwb3J0IHRoaXMgZXJyb3IuYCxcbiAgICApO1xuICB9XG5cbiAgZmx1c2goKTogc3RyaW5nW10ge1xuICAgIGlmICghdGhpcy5idWZmZXIubGVuZ3RoICYmICF0aGlzLnRyYWlsaW5nQ1IpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBsaW5lcyA9IFt0aGlzLmJ1ZmZlci5qb2luKCcnKV07XG4gICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB0aGlzLnRyYWlsaW5nQ1IgPSBmYWxzZTtcbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBSZWFkYWJsZVN0cmVhbSwgdHlwZSBSZXNwb25zZSB9IGZyb20gJy4vX3NoaW1zL2luZGV4JztcbmltcG9ydCB7IE9wZW5BSUVycm9yIH0gZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQgeyBMaW5lRGVjb2RlciB9IGZyb20gJy4vaW50ZXJuYWwvZGVjb2RlcnMvbGluZSc7XG5cbmltcG9ydCB7IEFQSUVycm9yIH0gZnJvbSAnLi9lcnJvcic7XG5cbnR5cGUgQnl0ZXMgPSBzdHJpbmcgfCBBcnJheUJ1ZmZlciB8IFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG5leHBvcnQgdHlwZSBTZXJ2ZXJTZW50RXZlbnQgPSB7XG4gIGV2ZW50OiBzdHJpbmcgfCBudWxsO1xuICBkYXRhOiBzdHJpbmc7XG4gIHJhdzogc3RyaW5nW107XG59O1xuXG5leHBvcnQgY2xhc3MgU3RyZWFtPEl0ZW0+IGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZTxJdGVtPiB7XG4gIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGl0ZXJhdG9yOiAoKSA9PiBBc3luY0l0ZXJhdG9yPEl0ZW0+LFxuICAgIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcixcbiAgKSB7XG4gICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU1NFUmVzcG9uc2U8SXRlbT4ocmVzcG9uc2U6IFJlc3BvbnNlLCBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIpOiBTdHJlYW08SXRlbT4ge1xuICAgIGxldCBjb25zdW1lZCA9IGZhbHNlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24qIGl0ZXJhdG9yKCk6IEFzeW5jSXRlcmF0b3I8SXRlbSwgYW55LCB1bmRlZmluZWQ+IHtcbiAgICAgIGlmIChjb25zdW1lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpdGVyYXRlIG92ZXIgYSBjb25zdW1lZCBzdHJlYW0sIHVzZSBgLnRlZSgpYCB0byBzcGxpdCB0aGUgc3RyZWFtLicpO1xuICAgICAgfVxuICAgICAgY29uc3VtZWQgPSB0cnVlO1xuICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3Qgc3NlIG9mIF9pdGVyU1NFTWVzc2FnZXMocmVzcG9uc2UsIGNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgaWYgKGRvbmUpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgaWYgKHNzZS5kYXRhLnN0YXJ0c1dpdGgoJ1tET05FXScpKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzc2UuZXZlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShzc2UuZGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBwYXJzZSBtZXNzYWdlIGludG8gSlNPTjpgLCBzc2UuZGF0YSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZyb20gY2h1bms6YCwgc3NlLnJhdyk7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKHVuZGVmaW5lZCwgZGF0YS5lcnJvciwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB5aWVsZCBkYXRhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHNzZS5kYXRhKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IHBhcnNlIG1lc3NhZ2UgaW50byBKU09OOmAsIHNzZS5kYXRhKTtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRnJvbSBjaHVuazpgLCBzc2UucmF3KTtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IElzIHRoaXMgd2hlcmUgdGhlIGVycm9yIHNob3VsZCBiZSB0aHJvd24/XG4gICAgICAgICAgICBpZiAoc3NlLmV2ZW50ID09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKHVuZGVmaW5lZCwgZGF0YS5lcnJvciwgZGF0YS5tZXNzYWdlLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgeyBldmVudDogc3NlLmV2ZW50LCBkYXRhOiBkYXRhIH0gYXMgYW55O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgY2FsbHMgYHN0cmVhbS5jb250cm9sbGVyLmFib3J0KClgLCB3ZSBzaG91bGQgZXhpdCB3aXRob3V0IHRocm93aW5nLlxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSByZXR1cm47XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBgYnJlYWtgcywgYWJvcnQgdGhlIG9uZ29pbmcgcmVxdWVzdC5cbiAgICAgICAgaWYgKCFkb25lKSBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTdHJlYW0oaXRlcmF0b3IsIGNvbnRyb2xsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIFN0cmVhbSBmcm9tIGEgbmV3bGluZS1zZXBhcmF0ZWQgUmVhZGFibGVTdHJlYW1cbiAgICogd2hlcmUgZWFjaCBpdGVtIGlzIGEgSlNPTiB2YWx1ZS5cbiAgICovXG4gIHN0YXRpYyBmcm9tUmVhZGFibGVTdHJlYW08SXRlbT4ocmVhZGFibGVTdHJlYW06IFJlYWRhYmxlU3RyZWFtLCBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIpOiBTdHJlYW08SXRlbT4ge1xuICAgIGxldCBjb25zdW1lZCA9IGZhbHNlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24qIGl0ZXJMaW5lcygpOiBBc3luY0dlbmVyYXRvcjxzdHJpbmcsIHZvaWQsIHVua25vd24+IHtcbiAgICAgIGNvbnN0IGxpbmVEZWNvZGVyID0gbmV3IExpbmVEZWNvZGVyKCk7XG5cbiAgICAgIGNvbnN0IGl0ZXIgPSByZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmFibGU8Qnl0ZXM+KHJlYWRhYmxlU3RyZWFtKTtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaXRlcikge1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZGVjb2RlKGNodW5rKSkge1xuICAgICAgICAgIHlpZWxkIGxpbmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVEZWNvZGVyLmZsdXNoKCkpIHtcbiAgICAgICAgeWllbGQgbGluZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiogaXRlcmF0b3IoKTogQXN5bmNJdGVyYXRvcjxJdGVtLCBhbnksIHVuZGVmaW5lZD4ge1xuICAgICAgaWYgKGNvbnN1bWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGl0ZXJhdGUgb3ZlciBhIGNvbnN1bWVkIHN0cmVhbSwgdXNlIGAudGVlKClgIHRvIHNwbGl0IHRoZSBzdHJlYW0uJyk7XG4gICAgICB9XG4gICAgICBjb25zdW1lZCA9IHRydWU7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBsaW5lIG9mIGl0ZXJMaW5lcygpKSB7XG4gICAgICAgICAgaWYgKGRvbmUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChsaW5lKSB5aWVsZCBKU09OLnBhcnNlKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBjYWxscyBgc3RyZWFtLmNvbnRyb2xsZXIuYWJvcnQoKWAsIHdlIHNob3VsZCBleGl0IHdpdGhvdXQgdGhyb3dpbmcuXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHJldHVybjtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGBicmVha2BzLCBhYm9ydCB0aGUgb25nb2luZyByZXF1ZXN0LlxuICAgICAgICBpZiAoIWRvbmUpIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFN0cmVhbShpdGVyYXRvciwgY29udHJvbGxlcik7XG4gIH1cblxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk6IEFzeW5jSXRlcmF0b3I8SXRlbT4ge1xuICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIHRoZSBzdHJlYW0gaW50byB0d28gc3RyZWFtcyB3aGljaCBjYW4gYmVcbiAgICogaW5kZXBlbmRlbnRseSByZWFkIGZyb20gYXQgZGlmZmVyZW50IHNwZWVkcy5cbiAgICovXG4gIHRlZSgpOiBbU3RyZWFtPEl0ZW0+LCBTdHJlYW08SXRlbT5dIHtcbiAgICBjb25zdCBsZWZ0OiBBcnJheTxQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PEl0ZW0+Pj4gPSBbXTtcbiAgICBjb25zdCByaWdodDogQXJyYXk8UHJvbWlzZTxJdGVyYXRvclJlc3VsdDxJdGVtPj4+ID0gW107XG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yKCk7XG5cbiAgICBjb25zdCB0ZWVJdGVyYXRvciA9IChxdWV1ZTogQXJyYXk8UHJvbWlzZTxJdGVyYXRvclJlc3VsdDxJdGVtPj4+KTogQXN5bmNJdGVyYXRvcjxJdGVtPiA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgbGVmdC5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICByaWdodC5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBxdWV1ZS5zaGlmdCgpITtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHJldHVybiBbXG4gICAgICBuZXcgU3RyZWFtKCgpID0+IHRlZUl0ZXJhdG9yKGxlZnQpLCB0aGlzLmNvbnRyb2xsZXIpLFxuICAgICAgbmV3IFN0cmVhbSgoKSA9PiB0ZWVJdGVyYXRvcihyaWdodCksIHRoaXMuY29udHJvbGxlciksXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIHN0cmVhbSB0byBhIG5ld2xpbmUtc2VwYXJhdGVkIFJlYWRhYmxlU3RyZWFtIG9mXG4gICAqIEpTT04gc3RyaW5naWZpZWQgdmFsdWVzIGluIHRoZSBzdHJlYW1cbiAgICogd2hpY2ggY2FuIGJlIHR1cm5lZCBiYWNrIGludG8gYSBTdHJlYW0gd2l0aCBgU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbSgpYC5cbiAgICovXG4gIHRvUmVhZGFibGVTdHJlYW0oKTogUmVhZGFibGVTdHJlYW0ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBpdGVyOiBBc3luY0l0ZXJhdG9yPEl0ZW0+O1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIGl0ZXIgPSBzZWxmW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHB1bGwoY3RybDogYW55KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlci5uZXh0KCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybiBjdHJsLmNsb3NlKCk7XG5cbiAgICAgICAgICBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdcXG4nKTtcblxuICAgICAgICAgIGN0cmwuZW5xdWV1ZShieXRlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGN0cmwuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGNhbmNlbCgpIHtcbiAgICAgICAgYXdhaXQgaXRlci5yZXR1cm4/LigpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIF9pdGVyU1NFTWVzc2FnZXMoXG4gIHJlc3BvbnNlOiBSZXNwb25zZSxcbiAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyLFxuKTogQXN5bmNHZW5lcmF0b3I8U2VydmVyU2VudEV2ZW50LCB2b2lkLCB1bmtub3duPiB7XG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYEF0dGVtcHRlZCB0byBpdGVyYXRlIG92ZXIgYSByZXNwb25zZSB3aXRoIG5vIGJvZHlgKTtcbiAgfVxuXG4gIGNvbnN0IHNzZURlY29kZXIgPSBuZXcgU1NFRGVjb2RlcigpO1xuICBjb25zdCBsaW5lRGVjb2RlciA9IG5ldyBMaW5lRGVjb2RlcigpO1xuXG4gIGNvbnN0IGl0ZXIgPSByZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmFibGU8Qnl0ZXM+KHJlc3BvbnNlLmJvZHkpO1xuICBmb3IgYXdhaXQgKGNvbnN0IHNzZUNodW5rIG9mIGl0ZXJTU0VDaHVua3MoaXRlcikpIHtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZGVjb2RlKHNzZUNodW5rKSkge1xuICAgICAgY29uc3Qgc3NlID0gc3NlRGVjb2Rlci5kZWNvZGUobGluZSk7XG4gICAgICBpZiAoc3NlKSB5aWVsZCBzc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVEZWNvZGVyLmZsdXNoKCkpIHtcbiAgICBjb25zdCBzc2UgPSBzc2VEZWNvZGVyLmRlY29kZShsaW5lKTtcbiAgICBpZiAoc3NlKSB5aWVsZCBzc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBhc3luYyBpdGVyYWJsZSBpdGVyYXRvciwgaXRlcmF0ZXMgb3ZlciBpdCBhbmQgeWllbGRzIGZ1bGxcbiAqIFNTRSBjaHVua3MsIGkuZS4geWllbGRzIHdoZW4gYSBkb3VibGUgbmV3LWxpbmUgaXMgZW5jb3VudGVyZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uKiBpdGVyU1NFQ2h1bmtzKGl0ZXJhdG9yOiBBc3luY0l0ZXJhYmxlSXRlcmF0b3I8Qnl0ZXM+KTogQXN5bmNHZW5lcmF0b3I8VWludDhBcnJheT4ge1xuICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KCk7XG5cbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpdGVyYXRvcikge1xuICAgIGlmIChjaHVuayA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBiaW5hcnlDaHVuayA9XG4gICAgICBjaHVuayBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoY2h1bmspXG4gICAgICA6IHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgPyBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoY2h1bmspXG4gICAgICA6IGNodW5rO1xuXG4gICAgbGV0IG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIGJpbmFyeUNodW5rLmxlbmd0aCk7XG4gICAgbmV3RGF0YS5zZXQoZGF0YSk7XG4gICAgbmV3RGF0YS5zZXQoYmluYXJ5Q2h1bmssIGRhdGEubGVuZ3RoKTtcbiAgICBkYXRhID0gbmV3RGF0YTtcblxuICAgIGxldCBwYXR0ZXJuSW5kZXg7XG4gICAgd2hpbGUgKChwYXR0ZXJuSW5kZXggPSBmaW5kRG91YmxlTmV3bGluZUluZGV4KGRhdGEpKSAhPT0gLTEpIHtcbiAgICAgIHlpZWxkIGRhdGEuc2xpY2UoMCwgcGF0dGVybkluZGV4KTtcbiAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKHBhdHRlcm5JbmRleCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgIHlpZWxkIGRhdGE7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZERvdWJsZU5ld2xpbmVJbmRleChidWZmZXI6IFVpbnQ4QXJyYXkpOiBudW1iZXIge1xuICAvLyBUaGlzIGZ1bmN0aW9uIHNlYXJjaGVzIHRoZSBidWZmZXIgZm9yIHRoZSBlbmQgcGF0dGVybnMgKFxcclxcciwgXFxuXFxuLCBcXHJcXG5cXHJcXG4pXG4gIC8vIGFuZCByZXR1cm5zIHRoZSBpbmRleCByaWdodCBhZnRlciB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbnkgcGF0dGVybixcbiAgLy8gb3IgLTEgaWYgbm9uZSBvZiB0aGUgcGF0dGVybnMgYXJlIGZvdW5kLlxuICBjb25zdCBuZXdsaW5lID0gMHgwYTsgLy8gXFxuXG4gIGNvbnN0IGNhcnJpYWdlID0gMHgwZDsgLy8gXFxyXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgaWYgKGJ1ZmZlcltpXSA9PT0gbmV3bGluZSAmJiBidWZmZXJbaSArIDFdID09PSBuZXdsaW5lKSB7XG4gICAgICAvLyBcXG5cXG5cbiAgICAgIHJldHVybiBpICsgMjtcbiAgICB9XG4gICAgaWYgKGJ1ZmZlcltpXSA9PT0gY2FycmlhZ2UgJiYgYnVmZmVyW2kgKyAxXSA9PT0gY2FycmlhZ2UpIHtcbiAgICAgIC8vIFxcclxcclxuICAgICAgcmV0dXJuIGkgKyAyO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBidWZmZXJbaV0gPT09IGNhcnJpYWdlICYmXG4gICAgICBidWZmZXJbaSArIDFdID09PSBuZXdsaW5lICYmXG4gICAgICBpICsgMyA8IGJ1ZmZlci5sZW5ndGggJiZcbiAgICAgIGJ1ZmZlcltpICsgMl0gPT09IGNhcnJpYWdlICYmXG4gICAgICBidWZmZXJbaSArIDNdID09PSBuZXdsaW5lXG4gICAgKSB7XG4gICAgICAvLyBcXHJcXG5cXHJcXG5cbiAgICAgIHJldHVybiBpICsgNDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmNsYXNzIFNTRURlY29kZXIge1xuICBwcml2YXRlIGRhdGE6IHN0cmluZ1tdO1xuICBwcml2YXRlIGV2ZW50OiBzdHJpbmcgfCBudWxsO1xuICBwcml2YXRlIGNodW5rczogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ldmVudCA9IG51bGw7XG4gICAgdGhpcy5kYXRhID0gW107XG4gICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgfVxuXG4gIGRlY29kZShsaW5lOiBzdHJpbmcpIHtcbiAgICBpZiAobGluZS5lbmRzV2l0aCgnXFxyJykpIHtcbiAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cmluZygwLCBsaW5lLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIGlmICghbGluZSkge1xuICAgICAgLy8gZW1wdHkgbGluZSBhbmQgd2UgZGlkbid0IHByZXZpb3VzbHkgZW5jb3VudGVyIGFueSBtZXNzYWdlc1xuICAgICAgaWYgKCF0aGlzLmV2ZW50ICYmICF0aGlzLmRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgICAgY29uc3Qgc3NlOiBTZXJ2ZXJTZW50RXZlbnQgPSB7XG4gICAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgICBkYXRhOiB0aGlzLmRhdGEuam9pbignXFxuJyksXG4gICAgICAgIHJhdzogdGhpcy5jaHVua3MsXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmV2ZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgdGhpcy5jaHVua3MgPSBbXTtcblxuICAgICAgcmV0dXJuIHNzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNodW5rcy5wdXNoKGxpbmUpO1xuXG4gICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnOicpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgW2ZpZWxkbmFtZSwgXywgdmFsdWVdID0gcGFydGl0aW9uKGxpbmUsICc6Jyk7XG5cbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnICcpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxKTtcbiAgICB9XG5cbiAgICBpZiAoZmllbGRuYW1lID09PSAnZXZlbnQnKSB7XG4gICAgICB0aGlzLmV2ZW50ID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChmaWVsZG5hbWUgPT09ICdkYXRhJykge1xuICAgICAgdGhpcy5kYXRhLnB1c2godmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKiBUaGlzIGlzIGFuIGludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0aGF0J3MganVzdCB1c2VkIGZvciB0ZXN0aW5nICovXG5leHBvcnQgZnVuY3Rpb24gX2RlY29kZUNodW5rcyhjaHVua3M6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IExpbmVEZWNvZGVyKCk7XG4gIGNvbnN0IGxpbmVzOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgIGxpbmVzLnB1c2goLi4uZGVjb2Rlci5kZWNvZGUoY2h1bmspKTtcbiAgfVxuXG4gIHJldHVybiBsaW5lcztcbn1cblxuZnVuY3Rpb24gcGFydGl0aW9uKHN0cjogc3RyaW5nLCBkZWxpbWl0ZXI6IHN0cmluZyk6IFtzdHJpbmcsIHN0cmluZywgc3RyaW5nXSB7XG4gIGNvbnN0IGluZGV4ID0gc3RyLmluZGV4T2YoZGVsaW1pdGVyKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIHJldHVybiBbc3RyLnN1YnN0cmluZygwLCBpbmRleCksIGRlbGltaXRlciwgc3RyLnN1YnN0cmluZyhpbmRleCArIGRlbGltaXRlci5sZW5ndGgpXTtcbiAgfVxuXG4gIHJldHVybiBbc3RyLCAnJywgJyddO1xufVxuXG4vKipcbiAqIE1vc3QgYnJvd3NlcnMgZG9uJ3QgeWV0IGhhdmUgYXN5bmMgaXRlcmFibGUgc3VwcG9ydCBmb3IgUmVhZGFibGVTdHJlYW0sXG4gKiBhbmQgTm9kZSBoYXMgYSB2ZXJ5IGRpZmZlcmVudCB3YXkgb2YgcmVhZGluZyBieXRlcyBmcm9tIGl0cyBcIlJlYWRhYmxlU3RyZWFtXCIuXG4gKlxuICogVGhpcyBwb2x5ZmlsbCB3YXMgcHVsbGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL01hdHRpYXNCdWVsZW5zL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3B1bGwvMTIyI2lzc3VlY29tbWVudC0xNjI3MzU0NDkwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmFibGU8VD4oc3RyZWFtOiBhbnkpOiBBc3luY0l0ZXJhYmxlSXRlcmF0b3I8VD4ge1xuICBpZiAoc3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkgcmV0dXJuIHN0cmVhbTtcblxuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIHJldHVybiB7XG4gICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChyZXN1bHQ/LmRvbmUpIHJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgd2hlbiBzdHJlYW0gYmVjb21lcyBjbG9zZWRcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayB3aGVuIHN0cmVhbSBiZWNvbWVzIGVycm9yZWRcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIHJldHVybigpIHtcbiAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSByZWFkZXIuY2FuY2VsKCk7XG4gICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIGF3YWl0IGNhbmNlbFByb21pc2U7XG4gICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgfSxcbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyB0eXBlIFJlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi9jb3JlJztcbmltcG9ydCB7XG4gIEZvcm1EYXRhLFxuICBGaWxlLFxuICB0eXBlIEJsb2IsXG4gIHR5cGUgRmlsZVByb3BlcnR5QmFnLFxuICBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucyxcbiAgdHlwZSBGc1JlYWRTdHJlYW0sXG4gIGlzRnNSZWFkU3RyZWFtLFxufSBmcm9tICcuL19zaGltcy9pbmRleCc7XG5pbXBvcnQgeyBNdWx0aXBhcnRCb2R5IH0gZnJvbSAnLi9fc2hpbXMvTXVsdGlwYXJ0Qm9keSc7XG5leHBvcnQgeyBmaWxlRnJvbVBhdGggfSBmcm9tICcuL19zaGltcy9pbmRleCc7XG5cbnR5cGUgQmxvYkxpa2VQYXJ0ID0gc3RyaW5nIHwgQXJyYXlCdWZmZXIgfCBBcnJheUJ1ZmZlclZpZXcgfCBCbG9iTGlrZSB8IFVpbnQ4QXJyYXkgfCBEYXRhVmlldztcbmV4cG9ydCB0eXBlIEJsb2JQYXJ0ID0gc3RyaW5nIHwgQXJyYXlCdWZmZXIgfCBBcnJheUJ1ZmZlclZpZXcgfCBCbG9iIHwgVWludDhBcnJheSB8IERhdGFWaWV3O1xuXG4vKipcbiAqIFR5cGljYWxseSwgdGhpcyBpcyBhIG5hdGl2ZSBcIkZpbGVcIiBjbGFzcy5cbiAqXG4gKiBXZSBwcm92aWRlIHRoZSB7QGxpbmsgdG9GaWxlfSB1dGlsaXR5IHRvIGNvbnZlcnQgYSB2YXJpZXR5IG9mIG9iamVjdHNcbiAqIGludG8gdGhlIEZpbGUgY2xhc3MuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhIGZldGNoIFJlc3BvbnNlLCBvciBpbiBOb2RlLFxuICogdGhlIHJlc3VsdCBvZiBmcy5jcmVhdGVSZWFkU3RyZWFtKCkuXG4gKi9cbmV4cG9ydCB0eXBlIFVwbG9hZGFibGUgPSBGaWxlTGlrZSB8IFJlc3BvbnNlTGlrZSB8IEZzUmVhZFN0cmVhbTtcblxuLyoqXG4gKiBJbnRlbmRlZCB0byBtYXRjaCB3ZWIuQmxvYiwgbm9kZS5CbG9iLCBub2RlLWZldGNoLkJsb2IsIGV0Yy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCbG9iTGlrZSB7XG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0Jsb2Ivc2l6ZSkgKi9cbiAgcmVhZG9ubHkgc2l6ZTogbnVtYmVyO1xuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9CbG9iL3R5cGUpICovXG4gIHJlYWRvbmx5IHR5cGU6IHN0cmluZztcbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQmxvYi90ZXh0KSAqL1xuICB0ZXh0KCk6IFByb21pc2U8c3RyaW5nPjtcbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQmxvYi9zbGljZSkgKi9cbiAgc2xpY2Uoc3RhcnQ/OiBudW1iZXIsIGVuZD86IG51bWJlcik6IEJsb2JMaWtlO1xuICAvLyB1bmZvcnR1bmF0ZWx5IEB0eXBlcy9ub2RlLWZldGNoQF4yLjYuNCBkb2Vzbid0IHR5cGUgdGhlIGFycmF5QnVmZmVyIG1ldGhvZFxufVxuXG4vKipcbiAqIEludGVuZGVkIHRvIG1hdGNoIHdlYi5GaWxlLCBub2RlLkZpbGUsIG5vZGUtZmV0Y2guRmlsZSwgZXRjLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVMaWtlIGV4dGVuZHMgQmxvYkxpa2Uge1xuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9GaWxlL2xhc3RNb2RpZmllZCkgKi9cbiAgcmVhZG9ubHkgbGFzdE1vZGlmaWVkOiBudW1iZXI7XG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0ZpbGUvbmFtZSkgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEludGVuZGVkIHRvIG1hdGNoIHdlYi5SZXNwb25zZSwgbm9kZS5SZXNwb25zZSwgbm9kZS1mZXRjaC5SZXNwb25zZSwgZXRjLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlTGlrZSB7XG4gIHVybDogc3RyaW5nO1xuICBibG9iKCk6IFByb21pc2U8QmxvYkxpa2U+O1xufVxuXG5leHBvcnQgY29uc3QgaXNSZXNwb25zZUxpa2UgPSAodmFsdWU6IGFueSk6IHZhbHVlIGlzIFJlc3BvbnNlTGlrZSA9PlxuICB2YWx1ZSAhPSBudWxsICYmXG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgdHlwZW9mIHZhbHVlLnVybCA9PT0gJ3N0cmluZycgJiZcbiAgdHlwZW9mIHZhbHVlLmJsb2IgPT09ICdmdW5jdGlvbic7XG5cbmV4cG9ydCBjb25zdCBpc0ZpbGVMaWtlID0gKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBGaWxlTGlrZSA9PlxuICB2YWx1ZSAhPSBudWxsICYmXG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgdHlwZW9mIHZhbHVlLm5hbWUgPT09ICdzdHJpbmcnICYmXG4gIHR5cGVvZiB2YWx1ZS5sYXN0TW9kaWZpZWQgPT09ICdudW1iZXInICYmXG4gIGlzQmxvYkxpa2UodmFsdWUpO1xuXG4vKipcbiAqIFRoZSBCbG9iTGlrZSB0eXBlIG9taXRzIGFycmF5QnVmZmVyKCkgYmVjYXVzZSBAdHlwZXMvbm9kZS1mZXRjaEBeMi42LjQgbGFja3MgaXQ7IGJ1dCB0aGlzIGNoZWNrXG4gKiBhZGRzIHRoZSBhcnJheUJ1ZmZlcigpIG1ldGhvZCB0eXBlIGJlY2F1c2UgaXQgaXMgYXZhaWxhYmxlIGFuZCB1c2VkIGF0IHJ1bnRpbWVcbiAqL1xuZXhwb3J0IGNvbnN0IGlzQmxvYkxpa2UgPSAodmFsdWU6IGFueSk6IHZhbHVlIGlzIEJsb2JMaWtlICYgeyBhcnJheUJ1ZmZlcigpOiBQcm9taXNlPEFycmF5QnVmZmVyPiB9ID0+XG4gIHZhbHVlICE9IG51bGwgJiZcbiAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICB0eXBlb2YgdmFsdWUuc2l6ZSA9PT0gJ251bWJlcicgJiZcbiAgdHlwZW9mIHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnICYmXG4gIHR5cGVvZiB2YWx1ZS50ZXh0ID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiB2YWx1ZS5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgdmFsdWUuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbic7XG5cbmV4cG9ydCBjb25zdCBpc1VwbG9hZGFibGUgPSAodmFsdWU6IGFueSk6IHZhbHVlIGlzIFVwbG9hZGFibGUgPT4ge1xuICByZXR1cm4gaXNGaWxlTGlrZSh2YWx1ZSkgfHwgaXNSZXNwb25zZUxpa2UodmFsdWUpIHx8IGlzRnNSZWFkU3RyZWFtKHZhbHVlKTtcbn07XG5cbmV4cG9ydCB0eXBlIFRvRmlsZUlucHV0ID0gVXBsb2FkYWJsZSB8IEV4Y2x1ZGU8QmxvYkxpa2VQYXJ0LCBzdHJpbmc+IHwgQXN5bmNJdGVyYWJsZTxCbG9iTGlrZVBhcnQ+O1xuXG4vKipcbiAqIEhlbHBlciBmb3IgY3JlYXRpbmcgYSB7QGxpbmsgRmlsZX0gdG8gcGFzcyB0byBhbiBTREsgdXBsb2FkIG1ldGhvZCBmcm9tIGEgdmFyaWV0eSBvZiBkaWZmZXJlbnQgZGF0YSBmb3JtYXRzXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHJhdyBjb250ZW50IG9mIHRoZSBmaWxlLiAgQ2FuIGJlIGFuIHtAbGluayBVcGxvYWRhYmxlfSwge0BsaW5rIEJsb2JMaWtlUGFydH0sIG9yIHtAbGluayBBc3luY0l0ZXJhYmxlfSBvZiB7QGxpbmsgQmxvYkxpa2VQYXJ0fXNcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZS4gSWYgb21pdHRlZCwgdG9GaWxlIHdpbGwgdHJ5IHRvIGRldGVybWluZSBhIGZpbGUgbmFtZSBmcm9tIGJpdHMgaWYgcG9zc2libGVcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy50eXBlIHRoZSBNSU1FIHR5cGUgb2YgdGhlIGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0aW9ucy5sYXN0TW9kaWZpZWQgdGhlIGxhc3QgbW9kaWZpZWQgdGltZXN0YW1wXG4gKiBAcmV0dXJucyBhIHtAbGluayBGaWxlfSB3aXRoIHRoZSBnaXZlbiBwcm9wZXJ0aWVzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0b0ZpbGUoXG4gIHZhbHVlOiBUb0ZpbGVJbnB1dCB8IFByb21pc2VMaWtlPFRvRmlsZUlucHV0PixcbiAgbmFtZT86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQsXG4gIG9wdGlvbnM/OiBGaWxlUHJvcGVydHlCYWcgfCB1bmRlZmluZWQsXG4pOiBQcm9taXNlPEZpbGVMaWtlPiB7XG4gIC8vIElmIGl0J3MgYSBwcm9taXNlLCByZXNvbHZlIGl0LlxuICB2YWx1ZSA9IGF3YWl0IHZhbHVlO1xuXG4gIC8vIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYSBgRmlsZWAgd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICBpZiAoaXNGaWxlTGlrZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNSZXNwb25zZUxpa2UodmFsdWUpKSB7XG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IHZhbHVlLmJsb2IoKTtcbiAgICBuYW1lIHx8PSBuZXcgVVJMKHZhbHVlLnVybCkucGF0aG5hbWUuc3BsaXQoL1tcXFxcL10vKS5wb3AoKSA/PyAndW5rbm93bl9maWxlJztcblxuICAgIC8vIHdlIG5lZWQgdG8gY29udmVydCB0aGUgYEJsb2JgIGludG8gYW4gYXJyYXkgYnVmZmVyIGJlY2F1c2UgdGhlIGBCbG9iYCBjbGFzc1xuICAgIC8vIHRoYXQgYG5vZGUtZmV0Y2hgIGRlZmluZXMgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIHdlYiBzdGFuZGFyZCB3aGljaCByZXN1bHRzXG4gICAgLy8gaW4gYG5ldyBGaWxlYCBpbnRlcnByZXRpbmcgaXQgYXMgYSBzdHJpbmcgaW5zdGVhZCBvZiBiaW5hcnkgZGF0YS5cbiAgICBjb25zdCBkYXRhID0gaXNCbG9iTGlrZShibG9iKSA/IFsoYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpKSBhcyBhbnldIDogW2Jsb2JdO1xuXG4gICAgcmV0dXJuIG5ldyBGaWxlKGRhdGEsIG5hbWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3QgYml0cyA9IGF3YWl0IGdldEJ5dGVzKHZhbHVlKTtcblxuICBuYW1lIHx8PSBnZXROYW1lKHZhbHVlKSA/PyAndW5rbm93bl9maWxlJztcblxuICBpZiAoIW9wdGlvbnM/LnR5cGUpIHtcbiAgICBjb25zdCB0eXBlID0gKGJpdHNbMF0gYXMgYW55KT8udHlwZTtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB0eXBlIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBGaWxlKGJpdHMsIG5hbWUsIG9wdGlvbnMpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRCeXRlcyh2YWx1ZTogVG9GaWxlSW5wdXQpOiBQcm9taXNlPEFycmF5PEJsb2JQYXJ0Pj4ge1xuICBsZXQgcGFydHM6IEFycmF5PEJsb2JQYXJ0PiA9IFtdO1xuICBpZiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkgfHwgLy8gaW5jbHVkZXMgVWludDhBcnJheSwgQnVmZmVyLCBldGMuXG4gICAgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclxuICApIHtcbiAgICBwYXJ0cy5wdXNoKHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKHZhbHVlKSkge1xuICAgIHBhcnRzLnB1c2goYXdhaXQgdmFsdWUuYXJyYXlCdWZmZXIoKSk7XG4gIH0gZWxzZSBpZiAoXG4gICAgaXNBc3luY0l0ZXJhYmxlSXRlcmF0b3IodmFsdWUpIC8vIGluY2x1ZGVzIFJlYWRhYmxlLCBSZWFkYWJsZVN0cmVhbSwgZXRjLlxuICApIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHZhbHVlKSB7XG4gICAgICBwYXJ0cy5wdXNoKGNodW5rIGFzIEJsb2JQYXJ0KTsgLy8gVE9ETywgY29uc2lkZXIgdmFsaWRhdGluZz9cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFVuZXhwZWN0ZWQgZGF0YSB0eXBlOiAke3R5cGVvZiB2YWx1ZX07IGNvbnN0cnVjdG9yOiAke3ZhbHVlPy5jb25zdHJ1Y3RvclxuICAgICAgICA/Lm5hbWV9OyBwcm9wczogJHtwcm9wc0ZvckVycm9yKHZhbHVlKX1gLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbmZ1bmN0aW9uIHByb3BzRm9yRXJyb3IodmFsdWU6IGFueSk6IHN0cmluZyB7XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICByZXR1cm4gYFske3Byb3BzLm1hcCgocCkgPT4gYFwiJHtwfVwiYCkuam9pbignLCAnKX1dYDtcbn1cblxuZnVuY3Rpb24gZ2V0TmFtZSh2YWx1ZTogYW55KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIChcbiAgICBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIodmFsdWUubmFtZSkgfHxcbiAgICBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIodmFsdWUuZmlsZW5hbWUpIHx8XG4gICAgLy8gRm9yIGZzLlJlYWRTdHJlYW1cbiAgICBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIodmFsdWUucGF0aCk/LnNwbGl0KC9bXFxcXC9dLykucG9wKClcbiAgKTtcbn1cblxuY29uc3QgZ2V0U3RyaW5nRnJvbU1heWJlQnVmZmVyID0gKHg6IHN0cmluZyB8IEJ1ZmZlciB8IHVua25vd24pOiBzdHJpbmcgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSByZXR1cm4geDtcbiAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBCdWZmZXIpIHJldHVybiBTdHJpbmcoeCk7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5jb25zdCBpc0FzeW5jSXRlcmFibGVJdGVyYXRvciA9ICh2YWx1ZTogYW55KTogdmFsdWUgaXMgQXN5bmNJdGVyYWJsZUl0ZXJhdG9yPHVua25vd24+ID0+XG4gIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgaXNNdWx0aXBhcnRCb2R5ID0gKGJvZHk6IGFueSk6IGJvZHkgaXMgTXVsdGlwYXJ0Qm9keSA9PlxuICBib2R5ICYmIHR5cGVvZiBib2R5ID09PSAnb2JqZWN0JyAmJiBib2R5LmJvZHkgJiYgYm9keVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTXVsdGlwYXJ0Qm9keSc7XG5cbi8qKlxuICogUmV0dXJucyBhIG11bHRpcGFydC9mb3JtLWRhdGEgcmVxdWVzdCBpZiBhbnkgcGFydCBvZiB0aGUgZ2l2ZW4gcmVxdWVzdCBib2R5IGNvbnRhaW5zIGEgRmlsZSAvIEJsb2IgdmFsdWUuXG4gKiBPdGhlcndpc2UgcmV0dXJucyB0aGUgcmVxdWVzdCBhcyBpcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG1heWJlTXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zID0gYXN5bmMgPFQgPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gIG9wdHM6IFJlcXVlc3RPcHRpb25zPFQ+LFxuKTogUHJvbWlzZTxSZXF1ZXN0T3B0aW9uczxUIHwgTXVsdGlwYXJ0Qm9keT4+ID0+IHtcbiAgaWYgKCFoYXNVcGxvYWRhYmxlVmFsdWUob3B0cy5ib2R5KSkgcmV0dXJuIG9wdHM7XG5cbiAgY29uc3QgZm9ybSA9IGF3YWl0IGNyZWF0ZUZvcm0ob3B0cy5ib2R5KTtcbiAgcmV0dXJuIGdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zKGZvcm0sIG9wdHMpO1xufTtcblxuZXhwb3J0IGNvbnN0IG11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyA9IGFzeW5jIDxUID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KFxuICBvcHRzOiBSZXF1ZXN0T3B0aW9uczxUPixcbik6IFByb21pc2U8UmVxdWVzdE9wdGlvbnM8VCB8IE11bHRpcGFydEJvZHk+PiA9PiB7XG4gIGNvbnN0IGZvcm0gPSBhd2FpdCBjcmVhdGVGb3JtKG9wdHMuYm9keSk7XG4gIHJldHVybiBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucyhmb3JtLCBvcHRzKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVGb3JtID0gYXN5bmMgPFQgPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oYm9keTogVCB8IHVuZGVmaW5lZCk6IFByb21pc2U8Rm9ybURhdGE+ID0+IHtcbiAgY29uc3QgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyhib2R5IHx8IHt9KS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYWRkRm9ybVZhbHVlKGZvcm0sIGtleSwgdmFsdWUpKSk7XG4gIHJldHVybiBmb3JtO1xufTtcblxuY29uc3QgaGFzVXBsb2FkYWJsZVZhbHVlID0gKHZhbHVlOiB1bmtub3duKTogYm9vbGVhbiA9PiB7XG4gIGlmIChpc1VwbG9hZGFibGUodmFsdWUpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWUuc29tZShoYXNVcGxvYWRhYmxlVmFsdWUpO1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgaWYgKGhhc1VwbG9hZGFibGVWYWx1ZSgodmFsdWUgYXMgYW55KVtrXSkpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBhZGRGb3JtVmFsdWUgPSBhc3luYyAoZm9ybTogRm9ybURhdGEsIGtleTogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBgUmVjZWl2ZWQgbnVsbCBmb3IgXCIke2tleX1cIjsgdG8gcGFzcyBudWxsIGluIEZvcm1EYXRhLCB5b3UgbXVzdCB1c2UgdGhlIHN0cmluZyAnbnVsbCdgLFxuICAgICk7XG4gIH1cblxuICAvLyBUT0RPOiBtYWtlIG5lc3RlZCBmb3JtYXRzIGNvbmZpZ3VyYWJsZVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgZm9ybS5hcHBlbmQoa2V5LCBTdHJpbmcodmFsdWUpKTtcbiAgfSBlbHNlIGlmIChpc1VwbG9hZGFibGUodmFsdWUpKSB7XG4gICAgY29uc3QgZmlsZSA9IGF3YWl0IHRvRmlsZSh2YWx1ZSk7XG4gICAgZm9ybS5hcHBlbmQoa2V5LCBmaWxlIGFzIEZpbGUpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwodmFsdWUubWFwKChlbnRyeSkgPT4gYWRkRm9ybVZhbHVlKGZvcm0sIGtleSArICdbXScsIGVudHJ5KSkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5tYXAoKFtuYW1lLCBwcm9wXSkgPT4gYWRkRm9ybVZhbHVlKGZvcm0sIGAke2tleX1bJHtuYW1lfV1gLCBwcm9wKSksXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYEludmFsaWQgdmFsdWUgZ2l2ZW4gdG8gZm9ybSwgZXhwZWN0ZWQgYSBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb2JqZWN0LCBBcnJheSwgRmlsZSBvciBCbG9iIGJ1dCBnb3QgJHt2YWx1ZX0gaW5zdGVhZGAsXG4gICAgKTtcbiAgfVxufTtcbiIsICJpbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSAnLi92ZXJzaW9uJztcbmltcG9ydCB7IFN0cmVhbSB9IGZyb20gJy4vc3RyZWFtaW5nJztcbmltcG9ydCB7XG4gIE9wZW5BSUVycm9yLFxuICBBUElFcnJvcixcbiAgQVBJQ29ubmVjdGlvbkVycm9yLFxuICBBUElDb25uZWN0aW9uVGltZW91dEVycm9yLFxuICBBUElVc2VyQWJvcnRFcnJvcixcbn0gZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQge1xuICBraW5kIGFzIHNoaW1zS2luZCxcbiAgdHlwZSBSZWFkYWJsZSxcbiAgZ2V0RGVmYXVsdEFnZW50LFxuICB0eXBlIEFnZW50LFxuICBmZXRjaCxcbiAgdHlwZSBSZXF1ZXN0SW5mbyxcbiAgdHlwZSBSZXF1ZXN0SW5pdCxcbiAgdHlwZSBSZXNwb25zZSxcbiAgdHlwZSBIZWFkZXJzSW5pdCxcbn0gZnJvbSAnLi9fc2hpbXMvaW5kZXgnO1xuZXhwb3J0IHsgdHlwZSBSZXNwb25zZSB9O1xuaW1wb3J0IHsgQmxvYkxpa2UsIGlzQmxvYkxpa2UsIGlzTXVsdGlwYXJ0Qm9keSB9IGZyb20gJy4vdXBsb2Fkcyc7XG5leHBvcnQge1xuICBtYXliZU11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyxcbiAgbXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zLFxuICBjcmVhdGVGb3JtLFxuICB0eXBlIFVwbG9hZGFibGUsXG59IGZyb20gJy4vdXBsb2Fkcyc7XG5cbmV4cG9ydCB0eXBlIEZldGNoID0gKHVybDogUmVxdWVzdEluZm8sIGluaXQ/OiBSZXF1ZXN0SW5pdCkgPT4gUHJvbWlzZTxSZXNwb25zZT47XG5cbnR5cGUgUHJvbWlzZU9yVmFsdWU8VD4gPSBUIHwgUHJvbWlzZTxUPjtcblxudHlwZSBBUElSZXNwb25zZVByb3BzID0ge1xuICByZXNwb25zZTogUmVzcG9uc2U7XG4gIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnM7XG4gIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcjtcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGRlZmF1bHRQYXJzZVJlc3BvbnNlPFQ+KHByb3BzOiBBUElSZXNwb25zZVByb3BzKTogUHJvbWlzZTxXaXRoUmVxdWVzdElEPFQ+PiB7XG4gIGNvbnN0IHsgcmVzcG9uc2UgfSA9IHByb3BzO1xuICBpZiAocHJvcHMub3B0aW9ucy5zdHJlYW0pIHtcbiAgICBkZWJ1ZygncmVzcG9uc2UnLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnVybCwgcmVzcG9uc2UuaGVhZGVycywgcmVzcG9uc2UuYm9keSk7XG5cbiAgICAvLyBOb3RlOiB0aGVyZSBpcyBhbiBpbnZhcmlhbnQgaGVyZSB0aGF0IGlzbid0IHJlcHJlc2VudGVkIGluIHRoZSB0eXBlIHN5c3RlbVxuICAgIC8vIHRoYXQgaWYgeW91IHNldCBgc3RyZWFtOiB0cnVlYCB0aGUgcmVzcG9uc2UgdHlwZSBtdXN0IGFsc28gYmUgYFN0cmVhbTxUPmBcblxuICAgIGlmIChwcm9wcy5vcHRpb25zLl9fc3RyZWFtQ2xhc3MpIHtcbiAgICAgIHJldHVybiBwcm9wcy5vcHRpb25zLl9fc3RyZWFtQ2xhc3MuZnJvbVNTRVJlc3BvbnNlKHJlc3BvbnNlLCBwcm9wcy5jb250cm9sbGVyKSBhcyBhbnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmVhbS5mcm9tU1NFUmVzcG9uc2UocmVzcG9uc2UsIHByb3BzLmNvbnRyb2xsZXIpIGFzIGFueTtcbiAgfVxuXG4gIC8vIGZldGNoIHJlZnVzZXMgdG8gcmVhZCB0aGUgYm9keSB3aGVuIHRoZSBzdGF0dXMgY29kZSBpcyAyMDQuXG4gIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNCkge1xuICAgIHJldHVybiBudWxsIGFzIFdpdGhSZXF1ZXN0SUQ8VD47XG4gIH1cblxuICBpZiAocHJvcHMub3B0aW9ucy5fX2JpbmFyeVJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlIGFzIHVua25vd24gYXMgV2l0aFJlcXVlc3RJRDxUPjtcbiAgfVxuXG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICBjb25zdCBpc0pTT04gPVxuICAgIGNvbnRlbnRUeXBlPy5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpIHx8IGNvbnRlbnRUeXBlPy5pbmNsdWRlcygnYXBwbGljYXRpb24vdm5kLmFwaStqc29uJyk7XG4gIGlmIChpc0pTT04pIHtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgZGVidWcoJ3Jlc3BvbnNlJywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS51cmwsIHJlc3BvbnNlLmhlYWRlcnMsIGpzb24pO1xuXG4gICAgcmV0dXJuIF9hZGRSZXF1ZXN0SUQoanNvbiwgcmVzcG9uc2UpO1xuICB9XG5cbiAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgZGVidWcoJ3Jlc3BvbnNlJywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS51cmwsIHJlc3BvbnNlLmhlYWRlcnMsIHRleHQpO1xuXG4gIC8vIFRPRE8gaGFuZGxlIGJsb2IsIGFycmF5YnVmZmVyLCBvdGhlciBjb250ZW50IHR5cGVzLCBldGMuXG4gIHJldHVybiB0ZXh0IGFzIHVua25vd24gYXMgV2l0aFJlcXVlc3RJRDxUPjtcbn1cblxudHlwZSBXaXRoUmVxdWVzdElEPFQ+ID1cbiAgVCBleHRlbmRzIEFycmF5PGFueT4gfCBSZXNwb25zZSB8IEFic3RyYWN0UGFnZTxhbnk+ID8gVFxuICA6IFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+ID8gVCAmIHsgX3JlcXVlc3RfaWQ/OiBzdHJpbmcgfCBudWxsIH1cbiAgOiBUO1xuXG5mdW5jdGlvbiBfYWRkUmVxdWVzdElEPFQ+KHZhbHVlOiBULCByZXNwb25zZTogUmVzcG9uc2UpOiBXaXRoUmVxdWVzdElEPFQ+IHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlIGFzIFdpdGhSZXF1ZXN0SUQ8VD47XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlLCAnX3JlcXVlc3RfaWQnLCB7XG4gICAgdmFsdWU6IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXJlcXVlc3QtaWQnKSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgfSkgYXMgV2l0aFJlcXVlc3RJRDxUPjtcbn1cblxuLyoqXG4gKiBBIHN1YmNsYXNzIG9mIGBQcm9taXNlYCBwcm92aWRpbmcgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kc1xuICogZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIFNESy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFQSVByb21pc2U8VD4gZXh0ZW5kcyBQcm9taXNlPFdpdGhSZXF1ZXN0SUQ8VD4+IHtcbiAgcHJpdmF0ZSBwYXJzZWRQcm9taXNlOiBQcm9taXNlPFdpdGhSZXF1ZXN0SUQ8VD4+IHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVzcG9uc2VQcm9taXNlOiBQcm9taXNlPEFQSVJlc3BvbnNlUHJvcHM+LFxuICAgIHByaXZhdGUgcGFyc2VSZXNwb25zZTogKFxuICAgICAgcHJvcHM6IEFQSVJlc3BvbnNlUHJvcHMsXG4gICAgKSA9PiBQcm9taXNlT3JWYWx1ZTxXaXRoUmVxdWVzdElEPFQ+PiA9IGRlZmF1bHRQYXJzZVJlc3BvbnNlLFxuICApIHtcbiAgICBzdXBlcigocmVzb2x2ZSkgPT4ge1xuICAgICAgLy8gdGhpcyBpcyBtYXliZSBhIGJpdCB3ZWlyZCBidXQgdGhpcyBoYXMgdG8gYmUgYSBuby1vcCB0byBub3QgaW1wbGljaXRseVxuICAgICAgLy8gcGFyc2UgdGhlIHJlc3BvbnNlIGJvZHk7IGluc3RlYWQgLnRoZW4sIC5jYXRjaCwgLmZpbmFsbHkgYXJlIG92ZXJyaWRkZW5cbiAgICAgIC8vIHRvIHBhcnNlIHRoZSByZXNwb25zZVxuICAgICAgcmVzb2x2ZShudWxsIGFzIGFueSk7XG4gICAgfSk7XG4gIH1cblxuICBfdGhlblVud3JhcDxVPih0cmFuc2Zvcm06IChkYXRhOiBULCBwcm9wczogQVBJUmVzcG9uc2VQcm9wcykgPT4gVSk6IEFQSVByb21pc2U8VT4ge1xuICAgIHJldHVybiBuZXcgQVBJUHJvbWlzZSh0aGlzLnJlc3BvbnNlUHJvbWlzZSwgYXN5bmMgKHByb3BzKSA9PlxuICAgICAgX2FkZFJlcXVlc3RJRCh0cmFuc2Zvcm0oYXdhaXQgdGhpcy5wYXJzZVJlc3BvbnNlKHByb3BzKSwgcHJvcHMpLCBwcm9wcy5yZXNwb25zZSksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByYXcgYFJlc3BvbnNlYCBpbnN0YW5jZSBpbnN0ZWFkIG9mIHBhcnNpbmcgdGhlIHJlc3BvbnNlXG4gICAqIGRhdGEuXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIHBhcnNlIHRoZSByZXNwb25zZSBib2R5IGJ1dCBzdGlsbCBnZXQgdGhlIGBSZXNwb25zZWBcbiAgICogaW5zdGFuY2UsIHlvdSBjYW4gdXNlIHtAbGluayB3aXRoUmVzcG9uc2UoKX0uXG4gICAqXG4gICAqIFx1RDgzRFx1REM0QiBHZXR0aW5nIHRoZSB3cm9uZyBUeXBlU2NyaXB0IHR5cGUgZm9yIGBSZXNwb25zZWA/XG4gICAqIFRyeSBzZXR0aW5nIGBcIm1vZHVsZVJlc29sdXRpb25cIjogXCJOb2RlTmV4dFwiYCBpZiB5b3UgY2FuLFxuICAgKiBvciBhZGQgb25lIG9mIHRoZXNlIGltcG9ydHMgYmVmb3JlIHlvdXIgZmlyc3QgYGltcG9ydCBcdTIwMjYgZnJvbSAnb3BlbmFpJ2A6XG4gICAqIC0gYGltcG9ydCAnb3BlbmFpL3NoaW1zL25vZGUnYCAoaWYgeW91J3JlIHJ1bm5pbmcgb24gTm9kZSlcbiAgICogLSBgaW1wb3J0ICdvcGVuYWkvc2hpbXMvd2ViJ2AgKG90aGVyd2lzZSlcbiAgICovXG4gIGFzUmVzcG9uc2UoKTogUHJvbWlzZTxSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUHJvbWlzZS50aGVuKChwKSA9PiBwLnJlc3BvbnNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwYXJzZWQgcmVzcG9uc2UgZGF0YSwgdGhlIHJhdyBgUmVzcG9uc2VgIGluc3RhbmNlIGFuZCB0aGUgSUQgb2YgdGhlIHJlcXVlc3QsXG4gICAqIHJldHVybmVkIHZpYSB0aGUgWC1SZXF1ZXN0LUlEIGhlYWRlciB3aGljaCBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZyByZXF1ZXN0cyBhbmQgcmVwb3J0aW5nXG4gICAqIGlzc3VlcyB0byBPcGVuQUkuXG4gICAqXG4gICAqIElmIHlvdSBqdXN0IHdhbnQgdG8gZ2V0IHRoZSByYXcgYFJlc3BvbnNlYCBpbnN0YW5jZSB3aXRob3V0IHBhcnNpbmcgaXQsXG4gICAqIHlvdSBjYW4gdXNlIHtAbGluayBhc1Jlc3BvbnNlKCl9LlxuICAgKlxuICAgKlxuICAgKiBcdUQ4M0RcdURDNEIgR2V0dGluZyB0aGUgd3JvbmcgVHlwZVNjcmlwdCB0eXBlIGZvciBgUmVzcG9uc2VgP1xuICAgKiBUcnkgc2V0dGluZyBgXCJtb2R1bGVSZXNvbHV0aW9uXCI6IFwiTm9kZU5leHRcImAgaWYgeW91IGNhbixcbiAgICogb3IgYWRkIG9uZSBvZiB0aGVzZSBpbXBvcnRzIGJlZm9yZSB5b3VyIGZpcnN0IGBpbXBvcnQgXHUyMDI2IGZyb20gJ29wZW5haSdgOlxuICAgKiAtIGBpbXBvcnQgJ29wZW5haS9zaGltcy9ub2RlJ2AgKGlmIHlvdSdyZSBydW5uaW5nIG9uIE5vZGUpXG4gICAqIC0gYGltcG9ydCAnb3BlbmFpL3NoaW1zL3dlYidgIChvdGhlcndpc2UpXG4gICAqL1xuICBhc3luYyB3aXRoUmVzcG9uc2UoKTogUHJvbWlzZTx7IGRhdGE6IFQ7IHJlc3BvbnNlOiBSZXNwb25zZTsgcmVxdWVzdF9pZDogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCB9PiB7XG4gICAgY29uc3QgW2RhdGEsIHJlc3BvbnNlXSA9IGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLnBhcnNlKCksIHRoaXMuYXNSZXNwb25zZSgpXSk7XG4gICAgcmV0dXJuIHsgZGF0YSwgcmVzcG9uc2UsIHJlcXVlc3RfaWQ6IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXJlcXVlc3QtaWQnKSB9O1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZSgpOiBQcm9taXNlPFdpdGhSZXF1ZXN0SUQ8VD4+IHtcbiAgICBpZiAoIXRoaXMucGFyc2VkUHJvbWlzZSkge1xuICAgICAgdGhpcy5wYXJzZWRQcm9taXNlID0gdGhpcy5yZXNwb25zZVByb21pc2UudGhlbih0aGlzLnBhcnNlUmVzcG9uc2UpIGFzIGFueSBhcyBQcm9taXNlPFdpdGhSZXF1ZXN0SUQ8VD4+O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZWRQcm9taXNlO1xuICB9XG5cbiAgb3ZlcnJpZGUgdGhlbjxUUmVzdWx0MSA9IFdpdGhSZXF1ZXN0SUQ8VD4sIFRSZXN1bHQyID0gbmV2ZXI+KFxuICAgIG9uZnVsZmlsbGVkPzogKCh2YWx1ZTogV2l0aFJlcXVlc3RJRDxUPikgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4pIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBvbnJlamVjdGVkPzogKChyZWFzb246IGFueSkgPT4gVFJlc3VsdDIgfCBQcm9taXNlTGlrZTxUUmVzdWx0Mj4pIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgKTogUHJvbWlzZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2UoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcbiAgfVxuXG4gIG92ZXJyaWRlIGNhdGNoPFRSZXN1bHQgPSBuZXZlcj4oXG4gICAgb25yZWplY3RlZD86ICgocmVhc29uOiBhbnkpID0+IFRSZXN1bHQgfCBQcm9taXNlTGlrZTxUUmVzdWx0PikgfCB1bmRlZmluZWQgfCBudWxsLFxuICApOiBQcm9taXNlPFdpdGhSZXF1ZXN0SUQ8VD4gfCBUUmVzdWx0PiB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2UoKS5jYXRjaChvbnJlamVjdGVkKTtcbiAgfVxuXG4gIG92ZXJyaWRlIGZpbmFsbHkob25maW5hbGx5PzogKCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkIHwgbnVsbCk6IFByb21pc2U8V2l0aFJlcXVlc3RJRDxUPj4ge1xuICAgIHJldHVybiB0aGlzLnBhcnNlKCkuZmluYWxseShvbmZpbmFsbHkpO1xuICB9XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBUElDbGllbnQge1xuICBiYXNlVVJMOiBzdHJpbmc7XG4gIG1heFJldHJpZXM6IG51bWJlcjtcbiAgdGltZW91dDogbnVtYmVyO1xuICBodHRwQWdlbnQ6IEFnZW50IHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgZmV0Y2g6IEZldGNoO1xuICBwcm90ZWN0ZWQgaWRlbXBvdGVuY3lIZWFkZXI/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVUkwsXG4gICAgbWF4UmV0cmllcyA9IDIsXG4gICAgdGltZW91dCA9IDYwMDAwMCwgLy8gMTAgbWludXRlc1xuICAgIGh0dHBBZ2VudCxcbiAgICBmZXRjaDogb3ZlcnJpZGRlbkZldGNoLFxuICB9OiB7XG4gICAgYmFzZVVSTDogc3RyaW5nO1xuICAgIG1heFJldHJpZXM/OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgdGltZW91dDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGh0dHBBZ2VudDogQWdlbnQgfCB1bmRlZmluZWQ7XG4gICAgZmV0Y2g6IEZldGNoIHwgdW5kZWZpbmVkO1xuICB9KSB7XG4gICAgdGhpcy5iYXNlVVJMID0gYmFzZVVSTDtcbiAgICB0aGlzLm1heFJldHJpZXMgPSB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcignbWF4UmV0cmllcycsIG1heFJldHJpZXMpO1xuICAgIHRoaXMudGltZW91dCA9IHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKCd0aW1lb3V0JywgdGltZW91dCk7XG4gICAgdGhpcy5odHRwQWdlbnQgPSBodHRwQWdlbnQ7XG5cbiAgICB0aGlzLmZldGNoID0gb3ZlcnJpZGRlbkZldGNoID8/IGZldGNoO1xuICB9XG5cbiAgcHJvdGVjdGVkIGF1dGhIZWFkZXJzKG9wdHM6IEZpbmFsUmVxdWVzdE9wdGlvbnMpOiBIZWFkZXJzIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhpcyB0byBhZGQgeW91ciBvd24gZGVmYXVsdCBoZWFkZXJzLCBmb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHtcbiAgICogICAgLi4uc3VwZXIuZGVmYXVsdEhlYWRlcnMoKSxcbiAgICogICAgQXV0aG9yaXphdGlvbjogJ0JlYXJlciAxMjMnLFxuICAgKiAgfVxuICAgKi9cbiAgcHJvdGVjdGVkIGRlZmF1bHRIZWFkZXJzKG9wdHM6IEZpbmFsUmVxdWVzdE9wdGlvbnMpOiBIZWFkZXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ1VzZXItQWdlbnQnOiB0aGlzLmdldFVzZXJBZ2VudCgpLFxuICAgICAgLi4uZ2V0UGxhdGZvcm1IZWFkZXJzKCksXG4gICAgICAuLi50aGlzLmF1dGhIZWFkZXJzKG9wdHMpLFxuICAgIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZGVmYXVsdFF1ZXJ5KCk6IERlZmF1bHRRdWVyeSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhpcyB0byBhZGQgeW91ciBvd24gaGVhZGVycyB2YWxpZGF0aW9uOlxuICAgKi9cbiAgcHJvdGVjdGVkIHZhbGlkYXRlSGVhZGVycyhoZWFkZXJzOiBIZWFkZXJzLCBjdXN0b21IZWFkZXJzOiBIZWFkZXJzKSB7fVxuXG4gIHByb3RlY3RlZCBkZWZhdWx0SWRlbXBvdGVuY3lLZXkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYHN0YWlubGVzcy1ub2RlLXJldHJ5LSR7dXVpZDQoKX1gO1xuICB9XG5cbiAgZ2V0PFJlcSwgUnNwPihwYXRoOiBzdHJpbmcsIG9wdHM/OiBQcm9taXNlT3JWYWx1ZTxSZXF1ZXN0T3B0aW9uczxSZXE+Pik6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kUmVxdWVzdCgnZ2V0JywgcGF0aCwgb3B0cyk7XG4gIH1cblxuICBwb3N0PFJlcSwgUnNwPihwYXRoOiBzdHJpbmcsIG9wdHM/OiBQcm9taXNlT3JWYWx1ZTxSZXF1ZXN0T3B0aW9uczxSZXE+Pik6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kUmVxdWVzdCgncG9zdCcsIHBhdGgsIG9wdHMpO1xuICB9XG5cbiAgcGF0Y2g8UmVxLCBSc3A+KHBhdGg6IHN0cmluZywgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+KTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwYXRjaCcsIHBhdGgsIG9wdHMpO1xuICB9XG5cbiAgcHV0PFJlcSwgUnNwPihwYXRoOiBzdHJpbmcsIG9wdHM/OiBQcm9taXNlT3JWYWx1ZTxSZXF1ZXN0T3B0aW9uczxSZXE+Pik6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kUmVxdWVzdCgncHV0JywgcGF0aCwgb3B0cyk7XG4gIH1cblxuICBkZWxldGU8UmVxLCBSc3A+KHBhdGg6IHN0cmluZywgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+KTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdkZWxldGUnLCBwYXRoLCBvcHRzKTtcbiAgfVxuXG4gIHByaXZhdGUgbWV0aG9kUmVxdWVzdDxSZXEsIFJzcD4oXG4gICAgbWV0aG9kOiBIVFRQTWV0aG9kLFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRzPzogUHJvbWlzZU9yVmFsdWU8UmVxdWVzdE9wdGlvbnM8UmVxPj4sXG4gICk6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcbiAgICAgIFByb21pc2UucmVzb2x2ZShvcHRzKS50aGVuKGFzeW5jIChvcHRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPVxuICAgICAgICAgIG9wdHMgJiYgaXNCbG9iTGlrZShvcHRzPy5ib2R5KSA/IG5ldyBEYXRhVmlldyhhd2FpdCBvcHRzLmJvZHkuYXJyYXlCdWZmZXIoKSlcbiAgICAgICAgICA6IG9wdHM/LmJvZHkgaW5zdGFuY2VvZiBEYXRhVmlldyA/IG9wdHMuYm9keVxuICAgICAgICAgIDogb3B0cz8uYm9keSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IERhdGFWaWV3KG9wdHMuYm9keSlcbiAgICAgICAgICA6IG9wdHMgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KG9wdHM/LmJvZHkpID8gbmV3IERhdGFWaWV3KG9wdHMuYm9keS5idWZmZXIpXG4gICAgICAgICAgOiBvcHRzPy5ib2R5O1xuICAgICAgICByZXR1cm4geyBtZXRob2QsIHBhdGgsIC4uLm9wdHMsIGJvZHkgfTtcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBnZXRBUElMaXN0PEl0ZW0sIFBhZ2VDbGFzcyBleHRlbmRzIEFic3RyYWN0UGFnZTxJdGVtPiA9IEFic3RyYWN0UGFnZTxJdGVtPj4oXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIFBhZ2U6IG5ldyAoLi4uYXJnczogYW55W10pID0+IFBhZ2VDbGFzcyxcbiAgICBvcHRzPzogUmVxdWVzdE9wdGlvbnM8YW55PixcbiAgKTogUGFnZVByb21pc2U8UGFnZUNsYXNzLCBJdGVtPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdEFQSUxpc3QoUGFnZSwgeyBtZXRob2Q6ICdnZXQnLCBwYXRoLCAuLi5vcHRzIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVDb250ZW50TGVuZ3RoKGJvZHk6IHVua25vd24pOiBzdHJpbmcgfCBudWxsIHtcbiAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKGJvZHksICd1dGY4JykudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICBjb25zdCBlbmNvZGVkID0gZW5jb2Rlci5lbmNvZGUoYm9keSk7XG4gICAgICAgIHJldHVybiBlbmNvZGVkLmxlbmd0aC50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpKSB7XG4gICAgICByZXR1cm4gYm9keS5ieXRlTGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBidWlsZFJlcXVlc3Q8UmVxPihcbiAgICBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zPFJlcT4sXG4gICAgeyByZXRyeUNvdW50ID0gMCB9OiB7IHJldHJ5Q291bnQ/OiBudW1iZXIgfSA9IHt9LFxuICApOiB7IHJlcTogUmVxdWVzdEluaXQ7IHVybDogc3RyaW5nOyB0aW1lb3V0OiBudW1iZXIgfSB7XG4gICAgY29uc3QgeyBtZXRob2QsIHBhdGgsIHF1ZXJ5LCBoZWFkZXJzOiBoZWFkZXJzID0ge30gfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBib2R5ID1cbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyhvcHRpb25zLmJvZHkpIHx8IChvcHRpb25zLl9fYmluYXJ5UmVxdWVzdCAmJiB0eXBlb2Ygb3B0aW9ucy5ib2R5ID09PSAnc3RyaW5nJykgP1xuICAgICAgICBvcHRpb25zLmJvZHlcbiAgICAgIDogaXNNdWx0aXBhcnRCb2R5KG9wdGlvbnMuYm9keSkgPyBvcHRpb25zLmJvZHkuYm9keVxuICAgICAgOiBvcHRpb25zLmJvZHkgPyBKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvZHksIG51bGwsIDIpXG4gICAgICA6IG51bGw7XG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IHRoaXMuY2FsY3VsYXRlQ29udGVudExlbmd0aChib2R5KTtcblxuICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRVUkwocGF0aCEsIHF1ZXJ5KTtcbiAgICBpZiAoJ3RpbWVvdXQnIGluIG9wdGlvbnMpIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKCd0aW1lb3V0Jywgb3B0aW9ucy50aW1lb3V0KTtcbiAgICBjb25zdCB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0ID8/IHRoaXMudGltZW91dDtcbiAgICBjb25zdCBodHRwQWdlbnQgPSBvcHRpb25zLmh0dHBBZ2VudCA/PyB0aGlzLmh0dHBBZ2VudCA/PyBnZXREZWZhdWx0QWdlbnQodXJsKTtcbiAgICBjb25zdCBtaW5BZ2VudFRpbWVvdXQgPSB0aW1lb3V0ICsgMTAwMDtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgKGh0dHBBZ2VudCBhcyBhbnkpPy5vcHRpb25zPy50aW1lb3V0ID09PSAnbnVtYmVyJyAmJlxuICAgICAgbWluQWdlbnRUaW1lb3V0ID4gKChodHRwQWdlbnQgYXMgYW55KS5vcHRpb25zLnRpbWVvdXQgPz8gMClcbiAgICApIHtcbiAgICAgIC8vIEFsbG93IGFueSBnaXZlbiByZXF1ZXN0IHRvIGJ1bXAgb3VyIGFnZW50IGFjdGl2ZSBzb2NrZXQgdGltZW91dC5cbiAgICAgIC8vIFRoaXMgbWF5IHNlZW0gc3RyYW5nZSwgYnV0IGxlYWtpbmcgYWN0aXZlIHNvY2tldHMgc2hvdWxkIGJlIHJhcmUgYW5kIG5vdCBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMsXG4gICAgICAvLyBhbmQgd2l0aG91dCBtdXRhdGluZyBhZ2VudCB3ZSB3b3VsZCBuZWVkIHRvIGNyZWF0ZSBtb3JlIG9mIHRoZW0uXG4gICAgICAvLyBUaGlzIHRyYWRlb2ZmIG9wdGltaXplcyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAoaHR0cEFnZW50IGFzIGFueSkub3B0aW9ucy50aW1lb3V0ID0gbWluQWdlbnRUaW1lb3V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlkZW1wb3RlbmN5SGVhZGVyICYmIG1ldGhvZCAhPT0gJ2dldCcpIHtcbiAgICAgIGlmICghb3B0aW9ucy5pZGVtcG90ZW5jeUtleSkgb3B0aW9ucy5pZGVtcG90ZW5jeUtleSA9IHRoaXMuZGVmYXVsdElkZW1wb3RlbmN5S2V5KCk7XG4gICAgICBoZWFkZXJzW3RoaXMuaWRlbXBvdGVuY3lIZWFkZXJdID0gb3B0aW9ucy5pZGVtcG90ZW5jeUtleTtcbiAgICB9XG5cbiAgICBjb25zdCByZXFIZWFkZXJzID0gdGhpcy5idWlsZEhlYWRlcnMoeyBvcHRpb25zLCBoZWFkZXJzLCBjb250ZW50TGVuZ3RoLCByZXRyeUNvdW50IH0pO1xuXG4gICAgY29uc3QgcmVxOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIC4uLihib2R5ICYmIHsgYm9keTogYm9keSBhcyBhbnkgfSksXG4gICAgICBoZWFkZXJzOiByZXFIZWFkZXJzLFxuICAgICAgLi4uKGh0dHBBZ2VudCAmJiB7IGFnZW50OiBodHRwQWdlbnQgfSksXG4gICAgICAvLyBAdHMtaWdub3JlIG5vZGUtZmV0Y2ggdXNlcyBhIGN1c3RvbSBBYm9ydFNpZ25hbCB0eXBlIHRoYXQgaXNcbiAgICAgIC8vIG5vdCBjb21wYXRpYmxlIHdpdGggc3RhbmRhcmQgd2ViIHR5cGVzXG4gICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsID8/IG51bGwsXG4gICAgfTtcblxuICAgIHJldHVybiB7IHJlcSwgdXJsLCB0aW1lb3V0IH07XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkSGVhZGVycyh7XG4gICAgb3B0aW9ucyxcbiAgICBoZWFkZXJzLFxuICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgcmV0cnlDb3VudCxcbiAgfToge1xuICAgIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnM7XG4gICAgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZD47XG4gICAgY29udGVudExlbmd0aDogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgICByZXRyeUNvdW50OiBudW1iZXI7XG4gIH0pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICBjb25zdCByZXFIZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgaWYgKGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIHJlcUhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPSBjb250ZW50TGVuZ3RoO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRIZWFkZXJzID0gdGhpcy5kZWZhdWx0SGVhZGVycyhvcHRpb25zKTtcbiAgICBhcHBseUhlYWRlcnNNdXQocmVxSGVhZGVycywgZGVmYXVsdEhlYWRlcnMpO1xuICAgIGFwcGx5SGVhZGVyc011dChyZXFIZWFkZXJzLCBoZWFkZXJzKTtcblxuICAgIC8vIGxldCBidWlsdGluIGZldGNoIHNldCB0aGUgQ29udGVudC1UeXBlIGZvciBtdWx0aXBhcnQgYm9kaWVzXG4gICAgaWYgKGlzTXVsdGlwYXJ0Qm9keShvcHRpb25zLmJvZHkpICYmIHNoaW1zS2luZCAhPT0gJ25vZGUnKSB7XG4gICAgICBkZWxldGUgcmVxSGVhZGVyc1snY29udGVudC10eXBlJ107XG4gICAgfVxuXG4gICAgLy8gRG9uJ3Qgc2V0IHRoZSByZXRyeSBjb3VudCBoZWFkZXIgaWYgaXQgd2FzIGFscmVhZHkgc2V0IG9yIHJlbW92ZWQgdGhyb3VnaCBkZWZhdWx0IGhlYWRlcnMgb3IgYnkgdGhlXG4gICAgLy8gY2FsbGVyLiBXZSBjaGVjayBgZGVmYXVsdEhlYWRlcnNgIGFuZCBgaGVhZGVyc2AsIHdoaWNoIGNhbiBjb250YWluIG51bGxzLCBpbnN0ZWFkIG9mIGByZXFIZWFkZXJzYCB0b1xuICAgIC8vIGFjY291bnQgZm9yIHRoZSByZW1vdmFsIGNhc2UuXG4gICAgaWYgKFxuICAgICAgZ2V0SGVhZGVyKGRlZmF1bHRIZWFkZXJzLCAneC1zdGFpbmxlc3MtcmV0cnktY291bnQnKSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICBnZXRIZWFkZXIoaGVhZGVycywgJ3gtc3RhaW5sZXNzLXJldHJ5LWNvdW50JykgPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgcmVxSGVhZGVyc1sneC1zdGFpbmxlc3MtcmV0cnktY291bnQnXSA9IFN0cmluZyhyZXRyeUNvdW50KTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbGlkYXRlSGVhZGVycyhyZXFIZWFkZXJzLCBoZWFkZXJzKTtcblxuICAgIHJldHVybiByZXFIZWFkZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYXMgYSBjYWxsYmFjayBmb3IgbXV0YXRpbmcgdGhlIGdpdmVuIGBGaW5hbFJlcXVlc3RPcHRpb25zYCBvYmplY3QuXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgcHJlcGFyZU9wdGlvbnMob3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge31cblxuICAvKipcbiAgICogVXNlZCBhcyBhIGNhbGxiYWNrIGZvciBtdXRhdGluZyB0aGUgZ2l2ZW4gYFJlcXVlc3RJbml0YCBvYmplY3QuXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlcyB3aGVyZSB5b3Ugd2FudCB0byBhZGQgY2VydGFpbiBoZWFkZXJzIGJhc2VkIG9mZiBvZlxuICAgKiB0aGUgcmVxdWVzdCBwcm9wZXJ0aWVzLCBlLmcuIGBtZXRob2RgIG9yIGB1cmxgLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIHByZXBhcmVSZXF1ZXN0KFxuICAgIHJlcXVlc3Q6IFJlcXVlc3RJbml0LFxuICAgIHsgdXJsLCBvcHRpb25zIH06IHsgdXJsOiBzdHJpbmc7IG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnMgfSxcbiAgKTogUHJvbWlzZTx2b2lkPiB7fVxuXG4gIHByb3RlY3RlZCBwYXJzZUhlYWRlcnMoaGVhZGVyczogSGVhZGVyc0luaXQgfCBudWxsIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIChcbiAgICAgICFoZWFkZXJzID8ge31cbiAgICAgIDogU3ltYm9sLml0ZXJhdG9yIGluIGhlYWRlcnMgP1xuICAgICAgICBPYmplY3QuZnJvbUVudHJpZXMoQXJyYXkuZnJvbShoZWFkZXJzIGFzIEl0ZXJhYmxlPHN0cmluZ1tdPikubWFwKChoZWFkZXIpID0+IFsuLi5oZWFkZXJdKSlcbiAgICAgIDogeyAuLi5oZWFkZXJzIH1cbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG1ha2VTdGF0dXNFcnJvcihcbiAgICBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgICBlcnJvcjogT2JqZWN0IHwgdW5kZWZpbmVkLFxuICAgIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBoZWFkZXJzOiBIZWFkZXJzIHwgdW5kZWZpbmVkLFxuICApOiBBUElFcnJvciB7XG4gICAgcmV0dXJuIEFQSUVycm9yLmdlbmVyYXRlKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICB9XG5cbiAgcmVxdWVzdDxSZXEsIFJzcD4oXG4gICAgb3B0aW9uczogUHJvbWlzZU9yVmFsdWU8RmluYWxSZXF1ZXN0T3B0aW9uczxSZXE+PixcbiAgICByZW1haW5pbmdSZXRyaWVzOiBudW1iZXIgfCBudWxsID0gbnVsbCxcbiAgKTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gbmV3IEFQSVByb21pc2UodGhpcy5tYWtlUmVxdWVzdChvcHRpb25zLCByZW1haW5pbmdSZXRyaWVzKSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIG1ha2VSZXF1ZXN0PFJlcT4oXG4gICAgb3B0aW9uc0lucHV0OiBQcm9taXNlT3JWYWx1ZTxGaW5hbFJlcXVlc3RPcHRpb25zPFJlcT4+LFxuICAgIHJldHJpZXNSZW1haW5pbmc6IG51bWJlciB8IG51bGwsXG4gICk6IFByb21pc2U8QVBJUmVzcG9uc2VQcm9wcz4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBvcHRpb25zSW5wdXQ7XG4gICAgY29uc3QgbWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcyA/PyB0aGlzLm1heFJldHJpZXM7XG4gICAgaWYgKHJldHJpZXNSZW1haW5pbmcgPT0gbnVsbCkge1xuICAgICAgcmV0cmllc1JlbWFpbmluZyA9IG1heFJldHJpZXM7XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5wcmVwYXJlT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIGNvbnN0IHsgcmVxLCB1cmwsIHRpbWVvdXQgfSA9IHRoaXMuYnVpbGRSZXF1ZXN0KG9wdGlvbnMsIHsgcmV0cnlDb3VudDogbWF4UmV0cmllcyAtIHJldHJpZXNSZW1haW5pbmcgfSk7XG5cbiAgICBhd2FpdCB0aGlzLnByZXBhcmVSZXF1ZXN0KHJlcSwgeyB1cmwsIG9wdGlvbnMgfSk7XG5cbiAgICBkZWJ1ZygncmVxdWVzdCcsIHVybCwgb3B0aW9ucywgcmVxLmhlYWRlcnMpO1xuXG4gICAgaWYgKG9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaFdpdGhUaW1lb3V0KHVybCwgcmVxLCB0aW1lb3V0LCBjb250cm9sbGVyKS5jYXRjaChjYXN0VG9FcnJvcik7XG5cbiAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgICAgfVxuICAgICAgaWYgKHJldHJpZXNSZW1haW5pbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KG9wdGlvbnMsIHJldHJpZXNSZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3BvbnNlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICB0aHJvdyBuZXcgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcigpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEFQSUNvbm5lY3Rpb25FcnJvcih7IGNhdXNlOiByZXNwb25zZSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBjcmVhdGVSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmV0cmllc1JlbWFpbmluZyAmJiB0aGlzLnNob3VsZFJldHJ5KHJlc3BvbnNlKSkge1xuICAgICAgICBjb25zdCByZXRyeU1lc3NhZ2UgPSBgcmV0cnlpbmcsICR7cmV0cmllc1JlbWFpbmluZ30gYXR0ZW1wdHMgcmVtYWluaW5nYDtcbiAgICAgICAgZGVidWcoYHJlc3BvbnNlIChlcnJvcjsgJHtyZXRyeU1lc3NhZ2V9KWAsIHJlc3BvbnNlLnN0YXR1cywgdXJsLCByZXNwb25zZUhlYWRlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3Qob3B0aW9ucywgcmV0cmllc1JlbWFpbmluZywgcmVzcG9uc2VIZWFkZXJzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXJyVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoZSkgPT4gY2FzdFRvRXJyb3IoZSkubWVzc2FnZSk7XG4gICAgICBjb25zdCBlcnJKU09OID0gc2FmZUpTT04oZXJyVGV4dCk7XG4gICAgICBjb25zdCBlcnJNZXNzYWdlID0gZXJySlNPTiA/IHVuZGVmaW5lZCA6IGVyclRleHQ7XG4gICAgICBjb25zdCByZXRyeU1lc3NhZ2UgPSByZXRyaWVzUmVtYWluaW5nID8gYChlcnJvcjsgbm8gbW9yZSByZXRyaWVzIGxlZnQpYCA6IGAoZXJyb3I7IG5vdCByZXRyeWFibGUpYDtcblxuICAgICAgZGVidWcoYHJlc3BvbnNlIChlcnJvcjsgJHtyZXRyeU1lc3NhZ2V9KWAsIHJlc3BvbnNlLnN0YXR1cywgdXJsLCByZXNwb25zZUhlYWRlcnMsIGVyck1lc3NhZ2UpO1xuXG4gICAgICBjb25zdCBlcnIgPSB0aGlzLm1ha2VTdGF0dXNFcnJvcihyZXNwb25zZS5zdGF0dXMsIGVyckpTT04sIGVyck1lc3NhZ2UsIHJlc3BvbnNlSGVhZGVycyk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcmVzcG9uc2UsIG9wdGlvbnMsIGNvbnRyb2xsZXIgfTtcbiAgfVxuXG4gIHJlcXVlc3RBUElMaXN0PEl0ZW0gPSB1bmtub3duLCBQYWdlQ2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFBhZ2U8SXRlbT4gPSBBYnN0cmFjdFBhZ2U8SXRlbT4+KFxuICAgIFBhZ2U6IG5ldyAoLi4uYXJnczogQ29uc3RydWN0b3JQYXJhbWV0ZXJzPHR5cGVvZiBBYnN0cmFjdFBhZ2U+KSA9PiBQYWdlQ2xhc3MsXG4gICAgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucyxcbiAgKTogUGFnZVByb21pc2U8UGFnZUNsYXNzLCBJdGVtPiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHRoaXMubWFrZVJlcXVlc3Qob3B0aW9ucywgbnVsbCk7XG4gICAgcmV0dXJuIG5ldyBQYWdlUHJvbWlzZTxQYWdlQ2xhc3MsIEl0ZW0+KHRoaXMsIHJlcXVlc3QsIFBhZ2UpO1xuICB9XG5cbiAgYnVpbGRVUkw8UmVxPihwYXRoOiBzdHJpbmcsIHF1ZXJ5OiBSZXEgfCBudWxsIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgICBjb25zdCB1cmwgPVxuICAgICAgaXNBYnNvbHV0ZVVSTChwYXRoKSA/XG4gICAgICAgIG5ldyBVUkwocGF0aClcbiAgICAgIDogbmV3IFVSTCh0aGlzLmJhc2VVUkwgKyAodGhpcy5iYXNlVVJMLmVuZHNXaXRoKCcvJykgJiYgcGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoLnNsaWNlKDEpIDogcGF0aCkpO1xuXG4gICAgY29uc3QgZGVmYXVsdFF1ZXJ5ID0gdGhpcy5kZWZhdWx0UXVlcnkoKTtcbiAgICBpZiAoIWlzRW1wdHlPYmooZGVmYXVsdFF1ZXJ5KSkge1xuICAgICAgcXVlcnkgPSB7IC4uLmRlZmF1bHRRdWVyeSwgLi4ucXVlcnkgfSBhcyBSZXE7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcgJiYgcXVlcnkgJiYgIUFycmF5LmlzQXJyYXkocXVlcnkpKSB7XG4gICAgICB1cmwuc2VhcmNoID0gdGhpcy5zdHJpbmdpZnlRdWVyeShxdWVyeSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHN0cmluZyB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHF1ZXJ5KVxuICAgICAgLmZpbHRlcigoW18sIHZhbHVlXSkgPT4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJylcbiAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICAgIGBDYW5ub3Qgc3RyaW5naWZ5IHR5cGUgJHt0eXBlb2YgdmFsdWV9OyBFeHBlY3RlZCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgbnVsbC4gSWYgeW91IG5lZWQgdG8gcGFzcyBuZXN0ZWQgcXVlcnkgcGFyYW1ldGVycywgeW91IGNhbiBtYW51YWxseSBlbmNvZGUgdGhlbSwgZS5nLiB7IHF1ZXJ5OiB7ICdmb29ba2V5MV0nOiB2YWx1ZTEsICdmb29ba2V5Ml0nOiB2YWx1ZTIgfSB9LCBhbmQgcGxlYXNlIG9wZW4gYSBHaXRIdWIgaXNzdWUgcmVxdWVzdGluZyBiZXR0ZXIgc3VwcG9ydCBmb3IgeW91ciB1c2UgY2FzZS5gLFxuICAgICAgICApO1xuICAgICAgfSlcbiAgICAgIC5qb2luKCcmJyk7XG4gIH1cblxuICBhc3luYyBmZXRjaFdpdGhUaW1lb3V0KFxuICAgIHVybDogUmVxdWVzdEluZm8sXG4gICAgaW5pdDogUmVxdWVzdEluaXQgfCB1bmRlZmluZWQsXG4gICAgbXM6IG51bWJlcixcbiAgICBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIsXG4gICk6IFByb21pc2U8UmVzcG9uc2U+IHtcbiAgICBjb25zdCB7IHNpZ25hbCwgLi4ub3B0aW9ucyB9ID0gaW5pdCB8fCB7fTtcbiAgICBpZiAoc2lnbmFsKSBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiBjb250cm9sbGVyLmFib3J0KCkpO1xuXG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCBtcyk7XG5cbiAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIGFzIGFueSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcbiAgICBpZiAoZmV0Y2hPcHRpb25zLm1ldGhvZCkge1xuICAgICAgLy8gQ3VzdG9tIG1ldGhvZHMgbGlrZSAncGF0Y2gnIG5lZWQgdG8gYmUgdXBwZXJjYXNlZFxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMjk0XG4gICAgICBmZXRjaE9wdGlvbnMubWV0aG9kID0gZmV0Y2hPcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAvLyB1c2UgdW5kZWZpbmVkIHRoaXMgYmluZGluZzsgZmV0Y2ggZXJyb3JzIGlmIGJvdW5kIHRvIHNvbWV0aGluZyBlbHNlIGluIGJyb3dzZXIvY2xvdWRmbGFyZVxuICAgICAgdGhpcy5mZXRjaC5jYWxsKHVuZGVmaW5lZCwgdXJsLCBmZXRjaE9wdGlvbnMpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHNob3VsZFJldHJ5KHJlc3BvbnNlOiBSZXNwb25zZSk6IGJvb2xlYW4ge1xuICAgIC8vIE5vdGUgdGhpcyBpcyBub3QgYSBzdGFuZGFyZCBoZWFkZXIuXG4gICAgY29uc3Qgc2hvdWxkUmV0cnlIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1zaG91bGQtcmV0cnknKTtcblxuICAgIC8vIElmIHRoZSBzZXJ2ZXIgZXhwbGljaXRseSBzYXlzIHdoZXRoZXIgb3Igbm90IHRvIHJldHJ5LCBvYmV5LlxuICAgIGlmIChzaG91bGRSZXRyeUhlYWRlciA9PT0gJ3RydWUnKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoc2hvdWxkUmV0cnlIZWFkZXIgPT09ICdmYWxzZScpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIFJldHJ5IG9uIHJlcXVlc3QgdGltZW91dHMuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA4KSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIFJldHJ5IG9uIGxvY2sgdGltZW91dHMuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA5KSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIFJldHJ5IG9uIHJhdGUgbGltaXRzLlxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBSZXRyeSBpbnRlcm5hbCBlcnJvcnMuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA1MDApIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZXRyeVJlcXVlc3QoXG4gICAgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucyxcbiAgICByZXRyaWVzUmVtYWluaW5nOiBudW1iZXIsXG4gICAgcmVzcG9uc2VIZWFkZXJzPzogSGVhZGVycyB8IHVuZGVmaW5lZCxcbiAgKTogUHJvbWlzZTxBUElSZXNwb25zZVByb3BzPiB7XG4gICAgbGV0IHRpbWVvdXRNaWxsaXM6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICAgIC8vIE5vdGUgdGhlIGByZXRyeS1hZnRlci1tc2AgaGVhZGVyIG1heSBub3QgYmUgc3RhbmRhcmQsIGJ1dCBpcyBhIGdvb2QgaWRlYSBhbmQgd2UnZCBsaWtlIHByb2FjdGl2ZSBzdXBwb3J0IGZvciBpdC5cbiAgICBjb25zdCByZXRyeUFmdGVyTWlsbGlzSGVhZGVyID0gcmVzcG9uc2VIZWFkZXJzPy5bJ3JldHJ5LWFmdGVyLW1zJ107XG4gICAgaWYgKHJldHJ5QWZ0ZXJNaWxsaXNIZWFkZXIpIHtcbiAgICAgIGNvbnN0IHRpbWVvdXRNcyA9IHBhcnNlRmxvYXQocmV0cnlBZnRlck1pbGxpc0hlYWRlcik7XG4gICAgICBpZiAoIU51bWJlci5pc05hTih0aW1lb3V0TXMpKSB7XG4gICAgICAgIHRpbWVvdXRNaWxsaXMgPSB0aW1lb3V0TXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWJvdXQgdGhlIFJldHJ5LUFmdGVyIGhlYWRlcjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1JldHJ5LUFmdGVyXG4gICAgY29uc3QgcmV0cnlBZnRlckhlYWRlciA9IHJlc3BvbnNlSGVhZGVycz8uWydyZXRyeS1hZnRlciddO1xuICAgIGlmIChyZXRyeUFmdGVySGVhZGVyICYmICF0aW1lb3V0TWlsbGlzKSB7XG4gICAgICBjb25zdCB0aW1lb3V0U2Vjb25kcyA9IHBhcnNlRmxvYXQocmV0cnlBZnRlckhlYWRlcik7XG4gICAgICBpZiAoIU51bWJlci5pc05hTih0aW1lb3V0U2Vjb25kcykpIHtcbiAgICAgICAgdGltZW91dE1pbGxpcyA9IHRpbWVvdXRTZWNvbmRzICogMTAwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXRNaWxsaXMgPSBEYXRlLnBhcnNlKHJldHJ5QWZ0ZXJIZWFkZXIpIC0gRGF0ZS5ub3coKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgQVBJIGFza3MgdXMgdG8gd2FpdCBhIGNlcnRhaW4gYW1vdW50IG9mIHRpbWUgKGFuZCBpdCdzIGEgcmVhc29uYWJsZSBhbW91bnQpLFxuICAgIC8vIGp1c3QgZG8gd2hhdCBpdCBzYXlzLCBidXQgb3RoZXJ3aXNlIGNhbGN1bGF0ZSBhIGRlZmF1bHRcbiAgICBpZiAoISh0aW1lb3V0TWlsbGlzICYmIDAgPD0gdGltZW91dE1pbGxpcyAmJiB0aW1lb3V0TWlsbGlzIDwgNjAgKiAxMDAwKSkge1xuICAgICAgY29uc3QgbWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcyA/PyB0aGlzLm1heFJldHJpZXM7XG4gICAgICB0aW1lb3V0TWlsbGlzID0gdGhpcy5jYWxjdWxhdGVEZWZhdWx0UmV0cnlUaW1lb3V0TWlsbGlzKHJldHJpZXNSZW1haW5pbmcsIG1heFJldHJpZXMpO1xuICAgIH1cbiAgICBhd2FpdCBzbGVlcCh0aW1lb3V0TWlsbGlzKTtcblxuICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KG9wdGlvbnMsIHJldHJpZXNSZW1haW5pbmcgLSAxKTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlRGVmYXVsdFJldHJ5VGltZW91dE1pbGxpcyhyZXRyaWVzUmVtYWluaW5nOiBudW1iZXIsIG1heFJldHJpZXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgaW5pdGlhbFJldHJ5RGVsYXkgPSAwLjU7XG4gICAgY29uc3QgbWF4UmV0cnlEZWxheSA9IDguMDtcblxuICAgIGNvbnN0IG51bVJldHJpZXMgPSBtYXhSZXRyaWVzIC0gcmV0cmllc1JlbWFpbmluZztcblxuICAgIC8vIEFwcGx5IGV4cG9uZW50aWFsIGJhY2tvZmYsIGJ1dCBub3QgbW9yZSB0aGFuIHRoZSBtYXguXG4gICAgY29uc3Qgc2xlZXBTZWNvbmRzID0gTWF0aC5taW4oaW5pdGlhbFJldHJ5RGVsYXkgKiBNYXRoLnBvdygyLCBudW1SZXRyaWVzKSwgbWF4UmV0cnlEZWxheSk7XG5cbiAgICAvLyBBcHBseSBzb21lIGppdHRlciwgdGFrZSB1cCB0byBhdCBtb3N0IDI1IHBlcmNlbnQgb2YgdGhlIHJldHJ5IHRpbWUuXG4gICAgY29uc3Qgaml0dGVyID0gMSAtIE1hdGgucmFuZG9tKCkgKiAwLjI1O1xuXG4gICAgcmV0dXJuIHNsZWVwU2Vjb25kcyAqIGppdHRlciAqIDEwMDA7XG4gIH1cblxuICBwcml2YXRlIGdldFVzZXJBZ2VudCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9L0pTICR7VkVSU0lPTn1gO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFBhZ2VJbmZvID0geyB1cmw6IFVSTCB9IHwgeyBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgbnVsbCB9O1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RQYWdlPEl0ZW0+IGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZTxJdGVtPiB7XG4gICNjbGllbnQ6IEFQSUNsaWVudDtcbiAgcHJvdGVjdGVkIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnM7XG5cbiAgcHJvdGVjdGVkIHJlc3BvbnNlOiBSZXNwb25zZTtcbiAgcHJvdGVjdGVkIGJvZHk6IHVua25vd247XG5cbiAgY29uc3RydWN0b3IoY2xpZW50OiBBUElDbGllbnQsIHJlc3BvbnNlOiBSZXNwb25zZSwgYm9keTogdW5rbm93biwgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucykge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBuZXh0UGFnZUluZm8gaW5zdGVhZFxuICAgKi9cbiAgYWJzdHJhY3QgbmV4dFBhZ2VQYXJhbXMoKTogUGFydGlhbDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4gfCBudWxsO1xuICBhYnN0cmFjdCBuZXh0UGFnZUluZm8oKTogUGFnZUluZm8gfCBudWxsO1xuXG4gIGFic3RyYWN0IGdldFBhZ2luYXRlZEl0ZW1zKCk6IEl0ZW1bXTtcblxuICBoYXNOZXh0UGFnZSgpOiBib29sZWFuIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuZ2V0UGFnaW5hdGVkSXRlbXMoKTtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLm5leHRQYWdlSW5mbygpICE9IG51bGw7XG4gIH1cblxuICBhc3luYyBnZXROZXh0UGFnZSgpOiBQcm9taXNlPHRoaXM+IHtcbiAgICBjb25zdCBuZXh0SW5mbyA9IHRoaXMubmV4dFBhZ2VJbmZvKCk7XG4gICAgaWYgKCFuZXh0SW5mbykge1xuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICAnTm8gbmV4dCBwYWdlIGV4cGVjdGVkOyBwbGVhc2UgY2hlY2sgYC5oYXNOZXh0UGFnZSgpYCBiZWZvcmUgY2FsbGluZyBgLmdldE5leHRQYWdlKClgLicsXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBuZXh0T3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zIH07XG4gICAgaWYgKCdwYXJhbXMnIGluIG5leHRJbmZvICYmIHR5cGVvZiBuZXh0T3B0aW9ucy5xdWVyeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG5leHRPcHRpb25zLnF1ZXJ5ID0geyAuLi5uZXh0T3B0aW9ucy5xdWVyeSwgLi4ubmV4dEluZm8ucGFyYW1zIH07XG4gICAgfSBlbHNlIGlmICgndXJsJyBpbiBuZXh0SW5mbykge1xuICAgICAgY29uc3QgcGFyYW1zID0gWy4uLk9iamVjdC5lbnRyaWVzKG5leHRPcHRpb25zLnF1ZXJ5IHx8IHt9KSwgLi4ubmV4dEluZm8udXJsLnNlYXJjaFBhcmFtcy5lbnRyaWVzKCldO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcGFyYW1zKSB7XG4gICAgICAgIG5leHRJbmZvLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgdmFsdWUgYXMgYW55KTtcbiAgICAgIH1cbiAgICAgIG5leHRPcHRpb25zLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgbmV4dE9wdGlvbnMucGF0aCA9IG5leHRJbmZvLnVybC50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2xpZW50LnJlcXVlc3RBUElMaXN0KHRoaXMuY29uc3RydWN0b3IgYXMgYW55LCBuZXh0T3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyAqaXRlclBhZ2VzKCk6IEFzeW5jR2VuZXJhdG9yPHRoaXM+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICBsZXQgcGFnZTogdGhpcyA9IHRoaXM7XG4gICAgeWllbGQgcGFnZTtcbiAgICB3aGlsZSAocGFnZS5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICBwYWdlID0gYXdhaXQgcGFnZS5nZXROZXh0UGFnZSgpO1xuICAgICAgeWllbGQgcGFnZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpOiBBc3luY0dlbmVyYXRvcjxJdGVtPiB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBwYWdlIG9mIHRoaXMuaXRlclBhZ2VzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBwYWdlLmdldFBhZ2luYXRlZEl0ZW1zKCkpIHtcbiAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHN1YmNsYXNzIG9mIFByb21pc2Ugd2lsbCByZXNvbHZlIHRvIGFuIGluc3RhbnRpYXRlZCBQYWdlIG9uY2UgdGhlIHJlcXVlc3QgY29tcGxldGVzLlxuICpcbiAqIEl0IGFsc28gaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlIHRvIGFsbG93IGF1dG8tcGFnaW5hdGluZyBpdGVyYXRpb24gb24gYW4gdW5hd2FpdGVkIGxpc3QgY2FsbCwgZWc6XG4gKlxuICogICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGNsaWVudC5pdGVtcy5saXN0KCkpIHtcbiAqICAgICAgY29uc29sZS5sb2coaXRlbSlcbiAqICAgIH1cbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2VQcm9taXNlPFxuICAgIFBhZ2VDbGFzcyBleHRlbmRzIEFic3RyYWN0UGFnZTxJdGVtPixcbiAgICBJdGVtID0gUmV0dXJuVHlwZTxQYWdlQ2xhc3NbJ2dldFBhZ2luYXRlZEl0ZW1zJ10+W251bWJlcl0sXG4gID5cbiAgZXh0ZW5kcyBBUElQcm9taXNlPFBhZ2VDbGFzcz5cbiAgaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPEl0ZW0+XG57XG4gIGNvbnN0cnVjdG9yKFxuICAgIGNsaWVudDogQVBJQ2xpZW50LFxuICAgIHJlcXVlc3Q6IFByb21pc2U8QVBJUmVzcG9uc2VQcm9wcz4sXG4gICAgUGFnZTogbmV3ICguLi5hcmdzOiBDb25zdHJ1Y3RvclBhcmFtZXRlcnM8dHlwZW9mIEFic3RyYWN0UGFnZT4pID0+IFBhZ2VDbGFzcyxcbiAgKSB7XG4gICAgc3VwZXIoXG4gICAgICByZXF1ZXN0LFxuICAgICAgYXN5bmMgKHByb3BzKSA9PlxuICAgICAgICBuZXcgUGFnZShcbiAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgcHJvcHMucmVzcG9uc2UsXG4gICAgICAgICAgYXdhaXQgZGVmYXVsdFBhcnNlUmVzcG9uc2UocHJvcHMpLFxuICAgICAgICAgIHByb3BzLm9wdGlvbnMsXG4gICAgICAgICkgYXMgV2l0aFJlcXVlc3RJRDxQYWdlQ2xhc3M+LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgYXV0by1wYWdpbmF0aW5nIGl0ZXJhdGlvbiBvbiBhbiB1bmF3YWl0ZWQgbGlzdCBjYWxsLCBlZzpcbiAgICpcbiAgICogICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGNsaWVudC5pdGVtcy5saXN0KCkpIHtcbiAgICogICAgICBjb25zb2xlLmxvZyhpdGVtKVxuICAgKiAgICB9XG4gICAqL1xuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpOiBBc3luY0dlbmVyYXRvcjxJdGVtPiB7XG4gICAgY29uc3QgcGFnZSA9IGF3YWl0IHRoaXM7XG4gICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIHBhZ2UpIHtcbiAgICAgIHlpZWxkIGl0ZW07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSZXNwb25zZUhlYWRlcnMgPSAoXG4gIGhlYWRlcnM6IEF3YWl0ZWQ8UmV0dXJuVHlwZTxGZXRjaD4+WydoZWFkZXJzJ10sXG4pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0+IHtcbiAgcmV0dXJuIG5ldyBQcm94eShcbiAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBoZWFkZXJzLmVudHJpZXMoKSxcbiAgICApLFxuICAgIHtcbiAgICAgIGdldCh0YXJnZXQsIG5hbWUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbmFtZS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2tleS50b0xvd2VyQ2FzZSgpXSB8fCB0YXJnZXRba2V5XTtcbiAgICAgIH0sXG4gICAgfSxcbiAgKTtcbn07XG5cbnR5cGUgSFRUUE1ldGhvZCA9ICdnZXQnIHwgJ3Bvc3QnIHwgJ3B1dCcgfCAncGF0Y2gnIHwgJ2RlbGV0ZSc7XG5cbmV4cG9ydCB0eXBlIFJlcXVlc3RDbGllbnQgPSB7IGZldGNoOiBGZXRjaCB9O1xuZXhwb3J0IHR5cGUgSGVhZGVycyA9IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ+O1xuZXhwb3J0IHR5cGUgRGVmYXVsdFF1ZXJ5ID0gUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPjtcbmV4cG9ydCB0eXBlIEtleXNFbnVtPFQ+ID0geyBbUCBpbiBrZXlvZiBSZXF1aXJlZDxUPl06IHRydWUgfTtcblxuZXhwb3J0IHR5cGUgUmVxdWVzdE9wdGlvbnM8XG4gIFJlcSA9IHVua25vd24gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IFJlYWRhYmxlIHwgQmxvYkxpa2UgfCBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlcixcbj4gPSB7XG4gIG1ldGhvZD86IEhUVFBNZXRob2Q7XG4gIHBhdGg/OiBzdHJpbmc7XG4gIHF1ZXJ5PzogUmVxIHwgdW5kZWZpbmVkO1xuICBib2R5PzogUmVxIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgaGVhZGVycz86IEhlYWRlcnMgfCB1bmRlZmluZWQ7XG5cbiAgbWF4UmV0cmllcz86IG51bWJlcjtcbiAgc3RyZWFtPzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgdGltZW91dD86IG51bWJlcjtcbiAgaHR0cEFnZW50PzogQWdlbnQ7XG4gIHNpZ25hbD86IEFib3J0U2lnbmFsIHwgdW5kZWZpbmVkIHwgbnVsbDtcbiAgaWRlbXBvdGVuY3lLZXk/OiBzdHJpbmc7XG5cbiAgX19iaW5hcnlSZXF1ZXN0PzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgX19iaW5hcnlSZXNwb25zZT86IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gIF9fc3RyZWFtQ2xhc3M/OiB0eXBlb2YgU3RyZWFtO1xufTtcblxuLy8gVGhpcyBpcyByZXF1aXJlZCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgaWYgYSBnaXZlbiBvYmplY3QgbWF0Y2hlcyB0aGUgUmVxdWVzdE9wdGlvbnNcbi8vIHR5cGUgYXQgcnVudGltZS4gV2hpbGUgdGhpcyByZXF1aXJlcyBkdXBsaWNhdGlvbiwgaXQgaXMgZW5mb3JjZWQgYnkgdGhlIFR5cGVTY3JpcHRcbi8vIGNvbXBpbGVyIHN1Y2ggdGhhdCBhbnkgbWlzc2luZyAvIGV4dHJhbmVvdXMga2V5cyB3aWxsIGNhdXNlIGFuIGVycm9yLlxuY29uc3QgcmVxdWVzdE9wdGlvbnNLZXlzOiBLZXlzRW51bTxSZXF1ZXN0T3B0aW9ucz4gPSB7XG4gIG1ldGhvZDogdHJ1ZSxcbiAgcGF0aDogdHJ1ZSxcbiAgcXVlcnk6IHRydWUsXG4gIGJvZHk6IHRydWUsXG4gIGhlYWRlcnM6IHRydWUsXG5cbiAgbWF4UmV0cmllczogdHJ1ZSxcbiAgc3RyZWFtOiB0cnVlLFxuICB0aW1lb3V0OiB0cnVlLFxuICBodHRwQWdlbnQ6IHRydWUsXG4gIHNpZ25hbDogdHJ1ZSxcbiAgaWRlbXBvdGVuY3lLZXk6IHRydWUsXG5cbiAgX19iaW5hcnlSZXF1ZXN0OiB0cnVlLFxuICBfX2JpbmFyeVJlc3BvbnNlOiB0cnVlLFxuICBfX3N0cmVhbUNsYXNzOiB0cnVlLFxufTtcblxuZXhwb3J0IGNvbnN0IGlzUmVxdWVzdE9wdGlvbnMgPSAob2JqOiB1bmtub3duKTogb2JqIGlzIFJlcXVlc3RPcHRpb25zID0+IHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJlxuICAgIG9iaiAhPT0gbnVsbCAmJlxuICAgICFpc0VtcHR5T2JqKG9iaikgJiZcbiAgICBPYmplY3Qua2V5cyhvYmopLmV2ZXJ5KChrKSA9PiBoYXNPd24ocmVxdWVzdE9wdGlvbnNLZXlzLCBrKSlcbiAgKTtcbn07XG5cbmV4cG9ydCB0eXBlIEZpbmFsUmVxdWVzdE9wdGlvbnM8UmVxID0gdW5rbm93biB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgUmVhZGFibGUgfCBEYXRhVmlldz4gPVxuICBSZXF1ZXN0T3B0aW9uczxSZXE+ICYge1xuICAgIG1ldGhvZDogSFRUUE1ldGhvZDtcbiAgICBwYXRoOiBzdHJpbmc7XG4gIH07XG5cbmRlY2xhcmUgY29uc3QgRGVubzogYW55O1xuZGVjbGFyZSBjb25zdCBFZGdlUnVudGltZTogYW55O1xudHlwZSBBcmNoID0gJ3gzMicgfCAneDY0JyB8ICdhcm0nIHwgJ2FybTY0JyB8IGBvdGhlcjoke3N0cmluZ31gIHwgJ3Vua25vd24nO1xudHlwZSBQbGF0Zm9ybU5hbWUgPVxuICB8ICdNYWNPUydcbiAgfCAnTGludXgnXG4gIHwgJ1dpbmRvd3MnXG4gIHwgJ0ZyZWVCU0QnXG4gIHwgJ09wZW5CU0QnXG4gIHwgJ2lPUydcbiAgfCAnQW5kcm9pZCdcbiAgfCBgT3RoZXI6JHtzdHJpbmd9YFxuICB8ICdVbmtub3duJztcbnR5cGUgQnJvd3NlciA9ICdpZScgfCAnZWRnZScgfCAnY2hyb21lJyB8ICdmaXJlZm94JyB8ICdzYWZhcmknO1xudHlwZSBQbGF0Zm9ybVByb3BlcnRpZXMgPSB7XG4gICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJztcbiAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IHN0cmluZztcbiAgJ1gtU3RhaW5sZXNzLU9TJzogUGxhdGZvcm1OYW1lO1xuICAnWC1TdGFpbmxlc3MtQXJjaCc6IEFyY2g7XG4gICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ25vZGUnIHwgJ2Rlbm8nIHwgJ2VkZ2UnIHwgYGJyb3dzZXI6JHtCcm93c2VyfWAgfCAndW5rbm93bic7XG4gICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiBzdHJpbmc7XG59O1xuY29uc3QgZ2V0UGxhdGZvcm1Qcm9wZXJ0aWVzID0gKCk6IFBsYXRmb3JtUHJvcGVydGllcyA9PiB7XG4gIGlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcgJiYgRGVuby5idWlsZCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJyxcbiAgICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICAgJ1gtU3RhaW5sZXNzLU9TJzogbm9ybWFsaXplUGxhdGZvcm0oRGVuby5idWlsZC5vcyksXG4gICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6IG5vcm1hbGl6ZUFyY2goRGVuby5idWlsZC5hcmNoKSxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ2Rlbm8nLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6XG4gICAgICAgIHR5cGVvZiBEZW5vLnZlcnNpb24gPT09ICdzdHJpbmcnID8gRGVuby52ZXJzaW9uIDogRGVuby52ZXJzaW9uPy5kZW5vID8/ICd1bmtub3duJyxcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgRWRnZVJ1bnRpbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJyxcbiAgICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICAgJ1gtU3RhaW5sZXNzLU9TJzogJ1Vua25vd24nLFxuICAgICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiBgb3RoZXI6JHtFZGdlUnVudGltZX1gLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAnZWRnZScsXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogcHJvY2Vzcy52ZXJzaW9uLFxuICAgIH07XG4gIH1cbiAgLy8gQ2hlY2sgaWYgTm9kZS5qc1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyA/IHByb2Nlc3MgOiAwKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJyxcbiAgICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICAgJ1gtU3RhaW5sZXNzLU9TJzogbm9ybWFsaXplUGxhdGZvcm0ocHJvY2Vzcy5wbGF0Zm9ybSksXG4gICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6IG5vcm1hbGl6ZUFyY2gocHJvY2Vzcy5hcmNoKSxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ25vZGUnLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IHByb2Nlc3MudmVyc2lvbixcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgYnJvd3NlckluZm8gPSBnZXRCcm93c2VySW5mbygpO1xuICBpZiAoYnJvd3NlckluZm8pIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAnWC1TdGFpbmxlc3MtT1MnOiAnVW5rbm93bicsXG4gICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6ICd1bmtub3duJyxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogYGJyb3dzZXI6JHticm93c2VySW5mby5icm93c2VyfWAsXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogYnJvd3NlckluZm8udmVyc2lvbixcbiAgICB9O1xuICB9XG5cbiAgLy8gVE9ETyBhZGQgc3VwcG9ydCBmb3IgQ2xvdWRmbGFyZSB3b3JrZXJzLCBldGMuXG4gIHJldHVybiB7XG4gICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICdYLVN0YWlubGVzcy1PUyc6ICdVbmtub3duJyxcbiAgICAnWC1TdGFpbmxlc3MtQXJjaCc6ICd1bmtub3duJyxcbiAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICd1bmtub3duJyxcbiAgICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogJ3Vua25vd24nLFxuICB9O1xufTtcblxudHlwZSBCcm93c2VySW5mbyA9IHtcbiAgYnJvd3NlcjogQnJvd3NlcjtcbiAgdmVyc2lvbjogc3RyaW5nO1xufTtcblxuZGVjbGFyZSBjb25zdCBuYXZpZ2F0b3I6IHsgdXNlckFnZW50OiBzdHJpbmcgfSB8IHVuZGVmaW5lZDtcblxuLy8gTm90ZTogbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vSlMtRGV2VG9vbHMvaG9zdC1lbnZpcm9ubWVudC9ibG9iL2IxYWI3OWVjZGUzN2RiNWQ2ZTE2M2MwNTBlNTRmZTdkMjg3ZDdjOTIvc3JjL2lzb21vcnBoaWMuYnJvd3Nlci50c1xuZnVuY3Rpb24gZ2V0QnJvd3NlckluZm8oKTogQnJvd3NlckluZm8gfCBudWxsIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICFuYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE5PVEU6IFRoZSBvcmRlciBtYXR0ZXJzIGhlcmUhXG4gIGNvbnN0IGJyb3dzZXJQYXR0ZXJucyA9IFtcbiAgICB7IGtleTogJ2VkZ2UnIGFzIGNvbnN0LCBwYXR0ZXJuOiAvRWRnZSg/OlxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgIHsga2V5OiAnaWUnIGFzIGNvbnN0LCBwYXR0ZXJuOiAvTVNJRSg/OlxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgIHsga2V5OiAnaWUnIGFzIGNvbnN0LCBwYXR0ZXJuOiAvVHJpZGVudCg/Oi4qcnZcXDooXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgIHsga2V5OiAnY2hyb21lJyBhcyBjb25zdCwgcGF0dGVybjogL0Nocm9tZSg/OlxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgIHsga2V5OiAnZmlyZWZveCcgYXMgY29uc3QsIHBhdHRlcm46IC9GaXJlZm94KD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgeyBrZXk6ICdzYWZhcmknIGFzIGNvbnN0LCBwYXR0ZXJuOiAvKD86VmVyc2lvblxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/KD86XFxXK01vYmlsZVxcUyopP1xcVytTYWZhcmkvIH0sXG4gIF07XG5cbiAgLy8gRmluZCB0aGUgRklSU1QgbWF0Y2hpbmcgYnJvd3NlclxuICBmb3IgKGNvbnN0IHsga2V5LCBwYXR0ZXJuIH0gb2YgYnJvd3NlclBhdHRlcm5zKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBjb25zdCBtYWpvciA9IG1hdGNoWzFdIHx8IDA7XG4gICAgICBjb25zdCBtaW5vciA9IG1hdGNoWzJdIHx8IDA7XG4gICAgICBjb25zdCBwYXRjaCA9IG1hdGNoWzNdIHx8IDA7XG5cbiAgICAgIHJldHVybiB7IGJyb3dzZXI6IGtleSwgdmVyc2lvbjogYCR7bWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9YCB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBub3JtYWxpemVBcmNoID0gKGFyY2g6IHN0cmluZyk6IEFyY2ggPT4ge1xuICAvLyBOb2RlIGRvY3M6XG4gIC8vIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc2FyY2hcbiAgLy8gRGVubyBkb2NzOlxuICAvLyAtIGh0dHBzOi8vZG9jLmRlbm8ubGFuZC9kZW5vL3N0YWJsZS9+L0Rlbm8uYnVpbGRcbiAgaWYgKGFyY2ggPT09ICd4MzInKSByZXR1cm4gJ3gzMic7XG4gIGlmIChhcmNoID09PSAneDg2XzY0JyB8fCBhcmNoID09PSAneDY0JykgcmV0dXJuICd4NjQnO1xuICBpZiAoYXJjaCA9PT0gJ2FybScpIHJldHVybiAnYXJtJztcbiAgaWYgKGFyY2ggPT09ICdhYXJjaDY0JyB8fCBhcmNoID09PSAnYXJtNjQnKSByZXR1cm4gJ2FybTY0JztcbiAgaWYgKGFyY2gpIHJldHVybiBgb3RoZXI6JHthcmNofWA7XG4gIHJldHVybiAndW5rbm93bic7XG59O1xuXG5jb25zdCBub3JtYWxpemVQbGF0Zm9ybSA9IChwbGF0Zm9ybTogc3RyaW5nKTogUGxhdGZvcm1OYW1lID0+IHtcbiAgLy8gTm9kZSBwbGF0Zm9ybXM6XG4gIC8vIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc3BsYXRmb3JtXG4gIC8vIERlbm8gcGxhdGZvcm1zOlxuICAvLyAtIGh0dHBzOi8vZG9jLmRlbm8ubGFuZC9kZW5vL3N0YWJsZS9+L0Rlbm8uYnVpbGRcbiAgLy8gLSBodHRwczovL2dpdGh1Yi5jb20vZGVub2xhbmQvZGVuby9pc3N1ZXMvMTQ3OTlcblxuICBwbGF0Zm9ybSA9IHBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gTk9URTogdGhpcyBpT1MgY2hlY2sgaXMgdW50ZXN0ZWQgYW5kIG1heSBub3Qgd29ya1xuICAvLyBOb2RlIGRvZXMgbm90IHdvcmsgbmF0aXZlbHkgb24gSU9TLCB0aGVyZSBpcyBhIGZvcmsgYXRcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy1tb2JpbGUvbm9kZWpzLW1vYmlsZVxuICAvLyBob3dldmVyIGl0IGlzIHVua25vd24gYXQgdGhlIHRpbWUgb2Ygd3JpdGluZyBob3cgdG8gZGV0ZWN0IGlmIGl0IGlzIHJ1bm5pbmdcbiAgaWYgKHBsYXRmb3JtLmluY2x1ZGVzKCdpb3MnKSkgcmV0dXJuICdpT1MnO1xuICBpZiAocGxhdGZvcm0gPT09ICdhbmRyb2lkJykgcmV0dXJuICdBbmRyb2lkJztcbiAgaWYgKHBsYXRmb3JtID09PSAnZGFyd2luJykgcmV0dXJuICdNYWNPUyc7XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ3dpbjMyJykgcmV0dXJuICdXaW5kb3dzJztcbiAgaWYgKHBsYXRmb3JtID09PSAnZnJlZWJzZCcpIHJldHVybiAnRnJlZUJTRCc7XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKSByZXR1cm4gJ09wZW5CU0QnO1xuICBpZiAocGxhdGZvcm0gPT09ICdsaW51eCcpIHJldHVybiAnTGludXgnO1xuICBpZiAocGxhdGZvcm0pIHJldHVybiBgT3RoZXI6JHtwbGF0Zm9ybX1gO1xuICByZXR1cm4gJ1Vua25vd24nO1xufTtcblxubGV0IF9wbGF0Zm9ybUhlYWRlcnM6IFBsYXRmb3JtUHJvcGVydGllcztcbmNvbnN0IGdldFBsYXRmb3JtSGVhZGVycyA9ICgpID0+IHtcbiAgcmV0dXJuIChfcGxhdGZvcm1IZWFkZXJzID8/PSBnZXRQbGF0Zm9ybVByb3BlcnRpZXMoKSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2FmZUpTT04gPSAodGV4dDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLXNjaGVtZS1zdHJpbmdcbmNvbnN0IHN0YXJ0c1dpdGhTY2hlbWVSZWdleHAgPSAvXlthLXpdW2EtejAtOSsuLV0qOi9pO1xuY29uc3QgaXNBYnNvbHV0ZVVSTCA9ICh1cmw6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gc3RhcnRzV2l0aFNjaGVtZVJlZ2V4cC50ZXN0KHVybCk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2xlZXAgPSAobXM6IG51bWJlcikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcblxuY29uc3QgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIgPSAobmFtZTogc3RyaW5nLCBuOiB1bmtub3duKTogbnVtYmVyID0+IHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihuKSkge1xuICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgJHtuYW1lfSBtdXN0IGJlIGFuIGludGVnZXJgKTtcbiAgfVxuICBpZiAobiA8IDApIHtcbiAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJgKTtcbiAgfVxuICByZXR1cm4gbjtcbn07XG5cbmV4cG9ydCBjb25zdCBjYXN0VG9FcnJvciA9IChlcnI6IGFueSk6IEVycm9yID0+IHtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gZXJyO1xuICBpZiAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiYgZXJyICE9PSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoZXJyKSk7XG4gICAgfSBjYXRjaCB7fVxuICB9XG4gIHJldHVybiBuZXcgRXJyb3IoZXJyKTtcbn07XG5cbmV4cG9ydCBjb25zdCBlbnN1cmVQcmVzZW50ID0gPFQ+KHZhbHVlOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFQgPT4ge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBFeHBlY3RlZCBhIHZhbHVlIHRvIGJlIGdpdmVuIGJ1dCByZWNlaXZlZCAke3ZhbHVlfSBpbnN0ZWFkLmApO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJlYWQgYW4gZW52aXJvbm1lbnQgdmFyaWFibGUuXG4gKlxuICogVHJpbXMgYmVnaW5uaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICpcbiAqIFdpbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgZG9lc24ndCBleGlzdCBvciBjYW5ub3QgYmUgYWNjZXNzZWQuXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkRW52ID0gKGVudjogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBwcm9jZXNzLmVudj8uW2Vudl0/LnRyaW0oKSA/PyB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBEZW5vLmVudj8uZ2V0Py4oZW52KT8udHJpbSgpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgY29uc3QgY29lcmNlSW50ZWdlciA9ICh2YWx1ZTogdW5rbm93bik6IG51bWJlciA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcblxuICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYENvdWxkIG5vdCBjb2VyY2UgJHt2YWx1ZX0gKHR5cGU6ICR7dHlwZW9mIHZhbHVlfSkgaW50byBhIG51bWJlcmApO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvZXJjZUZsb2F0ID0gKHZhbHVlOiB1bmtub3duKTogbnVtYmVyID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB2YWx1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcblxuICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYENvdWxkIG5vdCBjb2VyY2UgJHt2YWx1ZX0gKHR5cGU6ICR7dHlwZW9mIHZhbHVlfSkgaW50byBhIG51bWJlcmApO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvZXJjZUJvb2xlYW4gPSAodmFsdWU6IHVua25vd24pOiBib29sZWFuID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gdmFsdWU7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSByZXR1cm4gdmFsdWUgPT09ICd0cnVlJztcbiAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xufTtcblxuZXhwb3J0IGNvbnN0IG1heWJlQ29lcmNlSW50ZWdlciA9ICh2YWx1ZTogdW5rbm93bik6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gY29lcmNlSW50ZWdlcih2YWx1ZSk7XG59O1xuXG5leHBvcnQgY29uc3QgbWF5YmVDb2VyY2VGbG9hdCA9ICh2YWx1ZTogdW5rbm93bik6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gY29lcmNlRmxvYXQodmFsdWUpO1xufTtcblxuZXhwb3J0IGNvbnN0IG1heWJlQ29lcmNlQm9vbGVhbiA9ICh2YWx1ZTogdW5rbm93bik6IGJvb2xlYW4gfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGNvZXJjZUJvb2xlYW4odmFsdWUpO1xufTtcblxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM0NDkxMjg3XG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eU9iaihvYmo6IE9iamVjdCB8IG51bGwgfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgaWYgKCFvYmopIHJldHVybiB0cnVlO1xuICBmb3IgKGNvbnN0IF9rIGluIG9iaikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gaHR0cHM6Ly9lc2xpbnQub3JnL2RvY3MvbGF0ZXN0L3J1bGVzL25vLXByb3RvdHlwZS1idWlsdGluc1xuZXhwb3J0IGZ1bmN0aW9uIGhhc093bihvYmo6IE9iamVjdCwga2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbi8qKlxuICogQ29waWVzIGhlYWRlcnMgZnJvbSBcIm5ld0hlYWRlcnNcIiBvbnRvIFwidGFyZ2V0SGVhZGVyc1wiLFxuICogdXNpbmcgbG93ZXItY2FzZSBmb3IgYWxsIHByb3BlcnRpZXMsXG4gKiBpZ25vcmluZyBhbnkga2V5cyB3aXRoIHVuZGVmaW5lZCB2YWx1ZXMsXG4gKiBhbmQgZGVsZXRpbmcgYW55IGtleXMgd2l0aCBudWxsIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlIZWFkZXJzTXV0KHRhcmdldEhlYWRlcnM6IEhlYWRlcnMsIG5ld0hlYWRlcnM6IEhlYWRlcnMpOiB2b2lkIHtcbiAgZm9yIChjb25zdCBrIGluIG5ld0hlYWRlcnMpIHtcbiAgICBpZiAoIWhhc093bihuZXdIZWFkZXJzLCBrKSkgY29udGludWU7XG4gICAgY29uc3QgbG93ZXJLZXkgPSBrLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCFsb3dlcktleSkgY29udGludWU7XG5cbiAgICBjb25zdCB2YWwgPSBuZXdIZWFkZXJzW2tdO1xuXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgZGVsZXRlIHRhcmdldEhlYWRlcnNbbG93ZXJLZXldO1xuICAgIH0gZWxzZSBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldEhlYWRlcnNbbG93ZXJLZXldID0gdmFsO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBTRU5TSVRJVkVfSEVBREVSUyA9IG5ldyBTZXQoWydhdXRob3JpemF0aW9uJywgJ2FwaS1rZXknXSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJ1ZyhhY3Rpb246IHN0cmluZywgLi4uYXJnczogYW55W10pIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzPy5lbnY/LlsnREVCVUcnXSA9PT0gJ3RydWUnKSB7XG4gICAgY29uc3QgbW9kaWZpZWRBcmdzID0gYXJncy5tYXAoKGFyZykgPT4ge1xuICAgICAgaWYgKCFhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIHNlbnNpdGl2ZSBoZWFkZXJzIGluIHJlcXVlc3QgYm9keSAnaGVhZGVycycgb2JqZWN0XG4gICAgICBpZiAoYXJnWydoZWFkZXJzJ10pIHtcbiAgICAgICAgLy8gY2xvbmUgc28gd2UgZG9uJ3QgbXV0YXRlXG4gICAgICAgIGNvbnN0IG1vZGlmaWVkQXJnID0geyAuLi5hcmcsIGhlYWRlcnM6IHsgLi4uYXJnWydoZWFkZXJzJ10gfSB9O1xuXG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIGluIGFyZ1snaGVhZGVycyddKSB7XG4gICAgICAgICAgaWYgKFNFTlNJVElWRV9IRUFERVJTLmhhcyhoZWFkZXIudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIG1vZGlmaWVkQXJnWydoZWFkZXJzJ11baGVhZGVyXSA9ICdSRURBQ1RFRCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vZGlmaWVkQXJnO1xuICAgICAgfVxuXG4gICAgICBsZXQgbW9kaWZpZWRBcmcgPSBudWxsO1xuXG4gICAgICAvLyBDaGVjayBmb3Igc2Vuc2l0aXZlIGhlYWRlcnMgaW4gaGVhZGVycyBvYmplY3RcbiAgICAgIGZvciAoY29uc3QgaGVhZGVyIGluIGFyZykge1xuICAgICAgICBpZiAoU0VOU0lUSVZFX0hFQURFUlMuaGFzKGhlYWRlci50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgIC8vIGF2b2lkIG1ha2luZyBhIGNvcHkgdW50aWwgd2UgbmVlZCB0b1xuICAgICAgICAgIG1vZGlmaWVkQXJnID8/PSB7IC4uLmFyZyB9O1xuICAgICAgICAgIG1vZGlmaWVkQXJnW2hlYWRlcl0gPSAnUkVEQUNURUQnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb2RpZmllZEFyZyA/PyBhcmc7XG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coYE9wZW5BSTpERUJVRzoke2FjdGlvbn1gLCAuLi5tb2RpZmllZEFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxMTc1MjNcbiAqL1xuY29uc3QgdXVpZDQgPSAoKSA9PiB7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMDtcbiAgICBjb25zdCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcbiAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzUnVubmluZ0luQnJvd3NlciA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGVhZGVyc1Byb3RvY29sIHtcbiAgZ2V0OiAoaGVhZGVyOiBzdHJpbmcpID0+IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG59XG5leHBvcnQgdHlwZSBIZWFkZXJzTGlrZSA9IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkPiB8IEhlYWRlcnNQcm90b2NvbDtcblxuZXhwb3J0IGNvbnN0IGlzSGVhZGVyc1Byb3RvY29sID0gKGhlYWRlcnM6IGFueSk6IGhlYWRlcnMgaXMgSGVhZGVyc1Byb3RvY29sID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBoZWFkZXJzPy5nZXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0UmVxdWlyZWRIZWFkZXIgPSAoaGVhZGVyczogSGVhZGVyc0xpa2UgfCBIZWFkZXJzLCBoZWFkZXI6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGZvdW5kSGVhZGVyID0gZ2V0SGVhZGVyKGhlYWRlcnMsIGhlYWRlcik7XG4gIGlmIChmb3VuZEhlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCAke2hlYWRlcn0gaGVhZGVyYCk7XG4gIH1cbiAgcmV0dXJuIGZvdW5kSGVhZGVyO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEhlYWRlciA9IChoZWFkZXJzOiBIZWFkZXJzTGlrZSB8IEhlYWRlcnMsIGhlYWRlcjogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgY29uc3QgbG93ZXJDYXNlZEhlYWRlciA9IGhlYWRlci50b0xvd2VyQ2FzZSgpO1xuICBpZiAoaXNIZWFkZXJzUHJvdG9jb2woaGVhZGVycykpIHtcbiAgICAvLyB0byBkZWFsIHdpdGggdGhlIGNhc2Ugd2hlcmUgdGhlIGhlYWRlciBsb29rcyBsaWtlIFN0YWlubGVzcy1FdmVudC1JZFxuICAgIGNvbnN0IGludGVyY2Fwc0hlYWRlciA9XG4gICAgICBoZWFkZXJbMF0/LnRvVXBwZXJDYXNlKCkgK1xuICAgICAgaGVhZGVyLnN1YnN0cmluZygxKS5yZXBsYWNlKC8oW15cXHddKShcXHcpL2csIChfbSwgZzEsIGcyKSA9PiBnMSArIGcyLnRvVXBwZXJDYXNlKCkpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFtoZWFkZXIsIGxvd2VyQ2FzZWRIZWFkZXIsIGhlYWRlci50b1VwcGVyQ2FzZSgpLCBpbnRlcmNhcHNIZWFkZXJdKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlcnMuZ2V0KGtleSk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSBsb3dlckNhc2VkSGVhZGVyKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSAxKSByZXR1cm4gdmFsdWVbMF07XG4gICAgICAgIGNvbnNvbGUud2FybihgUmVjZWl2ZWQgJHt2YWx1ZS5sZW5ndGh9IGVudHJpZXMgZm9yIHRoZSAke2hlYWRlcn0gaGVhZGVyLCB1c2luZyB0aGUgZmlyc3QgZW50cnkuYCk7XG4gICAgICAgIHJldHVybiB2YWx1ZVswXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgc3RyaW5nIHRvIEJhc2U2NCBmb3JtYXQuXG4gKi9cbmV4cG9ydCBjb25zdCB0b0Jhc2U2NCA9IChzdHI6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpOiBzdHJpbmcgPT4ge1xuICBpZiAoIXN0cikgcmV0dXJuICcnO1xuICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGJ0b2Eoc3RyKTtcbiAgfVxuXG4gIHRocm93IG5ldyBPcGVuQUlFcnJvcignQ2Fubm90IGdlbmVyYXRlIGI2NCBzdHJpbmc7IEV4cGVjdGVkIGBCdWZmZXJgIG9yIGBidG9hYCB0byBiZSBkZWZpbmVkJyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmoob2JqOiB1bmtub3duKTogb2JqIGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9iaik7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQWJzdHJhY3RQYWdlLCBSZXNwb25zZSwgQVBJQ2xpZW50LCBGaW5hbFJlcXVlc3RPcHRpb25zLCBQYWdlSW5mbyB9IGZyb20gJy4vY29yZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnZVJlc3BvbnNlPEl0ZW0+IHtcbiAgZGF0YTogQXJyYXk8SXRlbT47XG5cbiAgb2JqZWN0OiBzdHJpbmc7XG59XG5cbi8qKlxuICogTm90ZTogbm8gcGFnaW5hdGlvbiBhY3R1YWxseSBvY2N1cnMgeWV0LCB0aGlzIGlzIGZvciBmb3J3YXJkcy1jb21wYXRpYmlsaXR5LlxuICovXG5leHBvcnQgY2xhc3MgUGFnZTxJdGVtPiBleHRlbmRzIEFic3RyYWN0UGFnZTxJdGVtPiBpbXBsZW1lbnRzIFBhZ2VSZXNwb25zZTxJdGVtPiB7XG4gIGRhdGE6IEFycmF5PEl0ZW0+O1xuXG4gIG9iamVjdDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGNsaWVudDogQVBJQ2xpZW50LCByZXNwb25zZTogUmVzcG9uc2UsIGJvZHk6IFBhZ2VSZXNwb25zZTxJdGVtPiwgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucykge1xuICAgIHN1cGVyKGNsaWVudCwgcmVzcG9uc2UsIGJvZHksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5kYXRhID0gYm9keS5kYXRhIHx8IFtdO1xuICAgIHRoaXMub2JqZWN0ID0gYm9keS5vYmplY3Q7XG4gIH1cblxuICBnZXRQYWdpbmF0ZWRJdGVtcygpOiBJdGVtW10ge1xuICAgIHJldHVybiB0aGlzLmRhdGEgPz8gW107XG4gIH1cblxuICAvLyBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGBuZXh0UGFnZUluZm8oKWAgaW5zdGVhZFxuICAvKipcbiAgICogVGhpcyBwYWdlIHJlcHJlc2VudHMgYSByZXNwb25zZSB0aGF0IGlzbid0IGFjdHVhbGx5IHBhZ2luYXRlZCBhdCB0aGUgQVBJIGxldmVsXG4gICAqIHNvIHRoZXJlIHdpbGwgbmV2ZXIgYmUgYW55IG5leHQgcGFnZSBwYXJhbXMuXG4gICAqL1xuICBuZXh0UGFnZVBhcmFtcygpOiBudWxsIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG5leHRQYWdlSW5mbygpOiBudWxsIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEN1cnNvclBhZ2VSZXNwb25zZTxJdGVtPiB7XG4gIGRhdGE6IEFycmF5PEl0ZW0+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEN1cnNvclBhZ2VQYXJhbXMge1xuICBhZnRlcj86IHN0cmluZztcblxuICBsaW1pdD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEN1cnNvclBhZ2U8SXRlbSBleHRlbmRzIHsgaWQ6IHN0cmluZyB9PlxuICBleHRlbmRzIEFic3RyYWN0UGFnZTxJdGVtPlxuICBpbXBsZW1lbnRzIEN1cnNvclBhZ2VSZXNwb25zZTxJdGVtPlxue1xuICBkYXRhOiBBcnJheTxJdGVtPjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBjbGllbnQ6IEFQSUNsaWVudCxcbiAgICByZXNwb25zZTogUmVzcG9uc2UsXG4gICAgYm9keTogQ3Vyc29yUGFnZVJlc3BvbnNlPEl0ZW0+LFxuICAgIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnMsXG4gICkge1xuICAgIHN1cGVyKGNsaWVudCwgcmVzcG9uc2UsIGJvZHksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5kYXRhID0gYm9keS5kYXRhIHx8IFtdO1xuICB9XG5cbiAgZ2V0UGFnaW5hdGVkSXRlbXMoKTogSXRlbVtdIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhID8/IFtdO1xuICB9XG5cbiAgLy8gQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBgbmV4dFBhZ2VJbmZvKClgIGluc3RlYWRcbiAgbmV4dFBhZ2VQYXJhbXMoKTogUGFydGlhbDxDdXJzb3JQYWdlUGFyYW1zPiB8IG51bGwge1xuICAgIGNvbnN0IGluZm8gPSB0aGlzLm5leHRQYWdlSW5mbygpO1xuICAgIGlmICghaW5mbykgcmV0dXJuIG51bGw7XG4gICAgaWYgKCdwYXJhbXMnIGluIGluZm8pIHJldHVybiBpbmZvLnBhcmFtcztcbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuZnJvbUVudHJpZXMoaW5mby51cmwuc2VhcmNoUGFyYW1zKTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgbmV4dFBhZ2VJbmZvKCk6IFBhZ2VJbmZvIHwgbnVsbCB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0UGFnaW5hdGVkSXRlbXMoKTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXT8uaWQ7XG4gICAgaWYgKCFpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcGFyYW1zOiB7IGFmdGVyOiBpZCB9IH07XG4gIH1cbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgdHlwZSB7IE9wZW5BSSB9IGZyb20gJy4vaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgQVBJUmVzb3VyY2Uge1xuICBwcm90ZWN0ZWQgX2NsaWVudDogT3BlbkFJO1xuXG4gIGNvbnN0cnVjdG9yKGNsaWVudDogT3BlbkFJKSB7XG4gICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICB9XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBBUElQcm9taXNlIH0gZnJvbSAnLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ2hhdENvbXBsZXRpb25zQVBJIGZyb20gJy4vY29tcGxldGlvbnMnO1xuaW1wb3J0ICogYXMgQ29tcGxldGlvbnNBUEkgZnJvbSAnLi4vY29tcGxldGlvbnMnO1xuaW1wb3J0ICogYXMgU2hhcmVkIGZyb20gJy4uL3NoYXJlZCc7XG5pbXBvcnQgKiBhcyBDaGF0QVBJIGZyb20gJy4vY2hhdCc7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tICcuLi8uLi9zdHJlYW1pbmcnO1xuXG5leHBvcnQgY2xhc3MgQ29tcGxldGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbW9kZWwgcmVzcG9uc2UgZm9yIHRoZSBnaXZlbiBjaGF0IGNvbnZlcnNhdGlvbi4gTGVhcm4gbW9yZSBpbiB0aGVcbiAgICogW3RleHQgZ2VuZXJhdGlvbl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3RleHQtZ2VuZXJhdGlvbiksXG4gICAqIFt2aXNpb25dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy92aXNpb24pLCBhbmRcbiAgICogW2F1ZGlvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYXVkaW8pIGd1aWRlcy5cbiAgICpcbiAgICogUGFyYW1ldGVyIHN1cHBvcnQgY2FuIGRpZmZlciBkZXBlbmRpbmcgb24gdGhlIG1vZGVsIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqIHJlc3BvbnNlLCBwYXJ0aWN1bGFybHkgZm9yIG5ld2VyIHJlYXNvbmluZyBtb2RlbHMuIFBhcmFtZXRlcnMgdGhhdCBhcmUgb25seVxuICAgKiBzdXBwb3J0ZWQgZm9yIHJlYXNvbmluZyBtb2RlbHMgYXJlIG5vdGVkIGJlbG93LiBGb3IgdGhlIGN1cnJlbnQgc3RhdGUgb2ZcbiAgICogdW5zdXBwb3J0ZWQgcGFyYW1ldGVycyBpbiByZWFzb25pbmcgbW9kZWxzLFxuICAgKiBbcmVmZXIgdG8gdGhlIHJlYXNvbmluZyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3JlYXNvbmluZykuXG4gICAqL1xuICBjcmVhdGUoXG4gICAgYm9keTogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8Q2hhdENvbXBsZXRpb24+O1xuICBjcmVhdGUoXG4gICAgYm9keTogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8U3RyZWFtPENoYXRDb21wbGV0aW9uQ2h1bms+PjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08Q2hhdENvbXBsZXRpb25DaHVuaz4gfCBDaGF0Q29tcGxldGlvbj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxDaGF0Q29tcGxldGlvbj4gfCBBUElQcm9taXNlPFN0cmVhbTxDaGF0Q29tcGxldGlvbkNodW5rPj4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2NoYXQvY29tcGxldGlvbnMnLCB7IGJvZHksIC4uLm9wdGlvbnMsIHN0cmVhbTogYm9keS5zdHJlYW0gPz8gZmFsc2UgfSkgYXNcbiAgICAgIHwgQVBJUHJvbWlzZTxDaGF0Q29tcGxldGlvbj5cbiAgICAgIHwgQVBJUHJvbWlzZTxTdHJlYW08Q2hhdENvbXBsZXRpb25DaHVuaz4+O1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNoYXQgY29tcGxldGlvbiByZXNwb25zZSByZXR1cm5lZCBieSBtb2RlbCwgYmFzZWQgb24gdGhlIHByb3ZpZGVkXG4gKiBpbnB1dC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbiB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY2hhdCBjb21wbGV0aW9uLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGNoYXQgY29tcGxldGlvbiBjaG9pY2VzLiBDYW4gYmUgbW9yZSB0aGFuIG9uZSBpZiBgbmAgaXMgZ3JlYXRlclxuICAgKiB0aGFuIDEuXG4gICAqL1xuICBjaG9pY2VzOiBBcnJheTxDaGF0Q29tcGxldGlvbi5DaG9pY2U+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIG9mIHdoZW4gdGhlIGNoYXQgY29tcGxldGlvbiB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHVzZWQgZm9yIHRoZSBjaGF0IGNvbXBsZXRpb24uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgY2hhdC5jb21wbGV0aW9uYC5cbiAgICovXG4gIG9iamVjdDogJ2NoYXQuY29tcGxldGlvbic7XG5cbiAgLyoqXG4gICAqIFRoZSBzZXJ2aWNlIHRpZXIgdXNlZCBmb3IgcHJvY2Vzc2luZyB0aGUgcmVxdWVzdC4gVGhpcyBmaWVsZCBpcyBvbmx5IGluY2x1ZGVkIGlmXG4gICAqIHRoZSBgc2VydmljZV90aWVyYCBwYXJhbWV0ZXIgaXMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgc2VydmljZV90aWVyPzogJ3NjYWxlJyB8ICdkZWZhdWx0JyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoaXMgZmluZ2VycHJpbnQgcmVwcmVzZW50cyB0aGUgYmFja2VuZCBjb25maWd1cmF0aW9uIHRoYXQgdGhlIG1vZGVsIHJ1bnMgd2l0aC5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgYHNlZWRgIHJlcXVlc3QgcGFyYW1ldGVyIHRvIHVuZGVyc3RhbmQgd2hlblxuICAgKiBiYWNrZW5kIGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUgdGhhdCBtaWdodCBpbXBhY3QgZGV0ZXJtaW5pc20uXG4gICAqL1xuICBzeXN0ZW1fZmluZ2VycHJpbnQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBjb21wbGV0aW9uIHJlcXVlc3QuXG4gICAqL1xuICB1c2FnZT86IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25Vc2FnZTtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0Q29tcGxldGlvbiB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ2hvaWNlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVhc29uIHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLiBUaGlzIHdpbGwgYmUgYHN0b3BgIGlmIHRoZSBtb2RlbFxuICAgICAqIGhpdCBhIG5hdHVyYWwgc3RvcCBwb2ludCBvciBhIHByb3ZpZGVkIHN0b3Agc2VxdWVuY2UsIGBsZW5ndGhgIGlmIHRoZSBtYXhpbXVtXG4gICAgICogbnVtYmVyIG9mIHRva2VucyBzcGVjaWZpZWQgaW4gdGhlIHJlcXVlc3Qgd2FzIHJlYWNoZWQsIGBjb250ZW50X2ZpbHRlcmAgaWZcbiAgICAgKiBjb250ZW50IHdhcyBvbWl0dGVkIGR1ZSB0byBhIGZsYWcgZnJvbSBvdXIgY29udGVudCBmaWx0ZXJzLCBgdG9vbF9jYWxsc2AgaWYgdGhlXG4gICAgICogbW9kZWwgY2FsbGVkIGEgdG9vbCwgb3IgYGZ1bmN0aW9uX2NhbGxgIChkZXByZWNhdGVkKSBpZiB0aGUgbW9kZWwgY2FsbGVkIGFcbiAgICAgKiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmaW5pc2hfcmVhc29uOiAnc3RvcCcgfCAnbGVuZ3RoJyB8ICd0b29sX2NhbGxzJyB8ICdjb250ZW50X2ZpbHRlcicgfCAnZnVuY3Rpb25fY2FsbCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGNob2ljZSBpbiB0aGUgbGlzdCBvZiBjaG9pY2VzLlxuICAgICAqL1xuICAgIGluZGV4OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBMb2cgcHJvYmFiaWxpdHkgaW5mb3JtYXRpb24gZm9yIHRoZSBjaG9pY2UuXG4gICAgICovXG4gICAgbG9ncHJvYnM6IENob2ljZS5Mb2dwcm9icyB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIGNoYXQgY29tcGxldGlvbiBtZXNzYWdlIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgbWVzc2FnZTogQ2hhdENvbXBsZXRpb25zQVBJLkNoYXRDb21wbGV0aW9uTWVzc2FnZTtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgQ2hvaWNlIHtcbiAgICAvKipcbiAgICAgKiBMb2cgcHJvYmFiaWxpdHkgaW5mb3JtYXRpb24gZm9yIHRoZSBjaG9pY2UuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBMb2dwcm9icyB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBtZXNzYWdlIGNvbnRlbnQgdG9rZW5zIHdpdGggbG9nIHByb2JhYmlsaXR5IGluZm9ybWF0aW9uLlxuICAgICAgICovXG4gICAgICBjb250ZW50OiBBcnJheTxDaGF0Q29tcGxldGlvbnNBUEkuQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2I+IHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgbWVzc2FnZSByZWZ1c2FsIHRva2VucyB3aXRoIGxvZyBwcm9iYWJpbGl0eSBpbmZvcm1hdGlvbi5cbiAgICAgICAqL1xuICAgICAgcmVmdXNhbDogQXJyYXk8Q2hhdENvbXBsZXRpb25zQVBJLkNoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iPiB8IG51bGw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVzc2FnZXMgc2VudCBieSB0aGUgbW9kZWwgaW4gcmVzcG9uc2UgdG8gdXNlciBtZXNzYWdlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSB7XG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgbWVzc2FnZXMgYXV0aG9yLCBpbiB0aGlzIGNhc2UgYGFzc2lzdGFudGAuXG4gICAqL1xuICByb2xlOiAnYXNzaXN0YW50JztcblxuICAvKipcbiAgICogRGF0YSBhYm91dCBhIHByZXZpb3VzIGF1ZGlvIHJlc3BvbnNlIGZyb20gdGhlIG1vZGVsLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2F1ZGlvKS5cbiAgICovXG4gIGF1ZGlvPzogQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0uQXVkaW8gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGFzc2lzdGFudCBtZXNzYWdlLiBSZXF1aXJlZCB1bmxlc3MgYHRvb2xfY2FsbHNgIG9yXG4gICAqIGBmdW5jdGlvbl9jYWxsYCBpcyBzcGVjaWZpZWQuXG4gICAqL1xuICBjb250ZW50Pzogc3RyaW5nIHwgQXJyYXk8Q2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQgfCBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0UmVmdXNhbD4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZDogRGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgYnkgYHRvb2xfY2FsbHNgLiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mXG4gICAqIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgZnVuY3Rpb25fY2FsbD86IENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtLkZ1bmN0aW9uQ2FsbCB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIG5hbWUgZm9yIHRoZSBwYXJ0aWNpcGFudC4gUHJvdmlkZXMgdGhlIG1vZGVsIGluZm9ybWF0aW9uIHRvXG4gICAqIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBwYXJ0aWNpcGFudHMgb2YgdGhlIHNhbWUgcm9sZS5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSByZWZ1c2FsIG1lc3NhZ2UgYnkgdGhlIGFzc2lzdGFudC5cbiAgICovXG4gIHJlZnVzYWw/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgdG9vbCBjYWxscyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLCBzdWNoIGFzIGZ1bmN0aW9uIGNhbGxzLlxuICAgKi9cbiAgdG9vbF9jYWxscz86IEFycmF5PENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsPjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSB7XG4gIC8qKlxuICAgKiBEYXRhIGFib3V0IGEgcHJldmlvdXMgYXVkaW8gcmVzcG9uc2UgZnJvbSB0aGUgbW9kZWwuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYXVkaW8pLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBBdWRpbyB7XG4gICAgLyoqXG4gICAgICogVW5pcXVlIGlkZW50aWZpZXIgZm9yIGEgcHJldmlvdXMgYXVkaW8gcmVzcG9uc2UgZnJvbSB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgaWQ6IHN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZDogRGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgYnkgYHRvb2xfY2FsbHNgLiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mXG4gICAqIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkNhbGwge1xuICAgIC8qKlxuICAgICAqIFRoZSBhcmd1bWVudHMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpbiBKU09OXG4gICAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAgICogaGFsbHVjaW5hdGUgcGFyYW1ldGVycyBub3QgZGVmaW5lZCBieSB5b3VyIGZ1bmN0aW9uIHNjaGVtYS4gVmFsaWRhdGUgdGhlXG4gICAgICogYXJndW1lbnRzIGluIHlvdXIgY29kZSBiZWZvcmUgY2FsbGluZyB5b3VyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGFyZ3VtZW50czogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogSWYgdGhlIGF1ZGlvIG91dHB1dCBtb2RhbGl0eSBpcyByZXF1ZXN0ZWQsIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGRhdGEgYWJvdXQgdGhlXG4gKiBhdWRpbyByZXNwb25zZSBmcm9tIHRoZSBtb2RlbC5cbiAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYXVkaW8pLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQXVkaW8ge1xuICAvKipcbiAgICogVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYXVkaW8gcmVzcG9uc2UuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBCYXNlNjQgZW5jb2RlZCBhdWRpbyBieXRlcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBpblxuICAgKiB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGRhdGE6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGlzIGF1ZGlvIHJlc3BvbnNlIHdpbGwgbm8gbG9uZ2VyIGJlXG4gICAqIGFjY2Vzc2libGUgb24gdGhlIHNlcnZlciBmb3IgdXNlIGluIG11bHRpLXR1cm4gY29udmVyc2F0aW9ucy5cbiAgICovXG4gIGV4cGlyZXNfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVHJhbnNjcmlwdCBvZiB0aGUgYXVkaW8gZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIHRyYW5zY3JpcHQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBQYXJhbWV0ZXJzIGZvciBhdWRpbyBvdXRwdXQuIFJlcXVpcmVkIHdoZW4gYXVkaW8gb3V0cHV0IGlzIHJlcXVlc3RlZCB3aXRoXG4gKiBgbW9kYWxpdGllczogW1wiYXVkaW9cIl1gLlxuICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9hdWRpbykuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25BdWRpb1BhcmFtIHtcbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgb3V0cHV0IGF1ZGlvIGZvcm1hdC4gTXVzdCBiZSBvbmUgb2YgYHdhdmAsIGBtcDNgLCBgZmxhY2AsIGBvcHVzYCxcbiAgICogb3IgYHBjbTE2YC5cbiAgICovXG4gIGZvcm1hdDogJ3dhdicgfCAnbXAzJyB8ICdmbGFjJyB8ICdvcHVzJyB8ICdwY20xNic7XG5cbiAgLyoqXG4gICAqIFRoZSB2b2ljZSB0aGUgbW9kZWwgdXNlcyB0byByZXNwb25kLiBTdXBwb3J0ZWQgdm9pY2VzIGFyZSBgYXNoYCwgYGJhbGxhZGAsXG4gICAqIGBjb3JhbGAsIGBzYWdlYCwgYW5kIGB2ZXJzZWAgKGFsc28gc3VwcG9ydGVkIGJ1dCBub3QgcmVjb21tZW5kZWQgYXJlIGBhbGxveWAsXG4gICAqIGBlY2hvYCwgYW5kIGBzaGltbWVyYDsgdGhlc2Ugdm9pY2VzIGFyZSBsZXNzIGV4cHJlc3NpdmUpLlxuICAgKi9cbiAgdm9pY2U6ICdhbGxveScgfCAnYXNoJyB8ICdiYWxsYWQnIHwgJ2NvcmFsJyB8ICdlY2hvJyB8ICdzYWdlJyB8ICdzaGltbWVyJyB8ICd2ZXJzZSc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHN0cmVhbWVkIGNodW5rIG9mIGEgY2hhdCBjb21wbGV0aW9uIHJlc3BvbnNlIHJldHVybmVkIGJ5IG1vZGVsLFxuICogYmFzZWQgb24gdGhlIHByb3ZpZGVkIGlucHV0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ2h1bmsge1xuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNoYXQgY29tcGxldGlvbi4gRWFjaCBjaHVuayBoYXMgdGhlIHNhbWUgSUQuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgY2hhdCBjb21wbGV0aW9uIGNob2ljZXMuIENhbiBjb250YWluIG1vcmUgdGhhbiBvbmUgZWxlbWVudHMgaWYgYG5gIGlzXG4gICAqIGdyZWF0ZXIgdGhhbiAxLiBDYW4gYWxzbyBiZSBlbXB0eSBmb3IgdGhlIGxhc3QgY2h1bmsgaWYgeW91IHNldFxuICAgKiBgc3RyZWFtX29wdGlvbnM6IHtcImluY2x1ZGVfdXNhZ2VcIjogdHJ1ZX1gLlxuICAgKi9cbiAgY2hvaWNlczogQXJyYXk8Q2hhdENvbXBsZXRpb25DaHVuay5DaG9pY2U+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIG9mIHdoZW4gdGhlIGNoYXQgY29tcGxldGlvbiB3YXMgY3JlYXRlZC4gRWFjaFxuICAgKiBjaHVuayBoYXMgdGhlIHNhbWUgdGltZXN0YW1wLlxuICAgKi9cbiAgY3JlYXRlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdG8gZ2VuZXJhdGUgdGhlIGNvbXBsZXRpb24uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgY2hhdC5jb21wbGV0aW9uLmNodW5rYC5cbiAgICovXG4gIG9iamVjdDogJ2NoYXQuY29tcGxldGlvbi5jaHVuayc7XG5cbiAgLyoqXG4gICAqIFRoZSBzZXJ2aWNlIHRpZXIgdXNlZCBmb3IgcHJvY2Vzc2luZyB0aGUgcmVxdWVzdC4gVGhpcyBmaWVsZCBpcyBvbmx5IGluY2x1ZGVkIGlmXG4gICAqIHRoZSBgc2VydmljZV90aWVyYCBwYXJhbWV0ZXIgaXMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgc2VydmljZV90aWVyPzogJ3NjYWxlJyB8ICdkZWZhdWx0JyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoaXMgZmluZ2VycHJpbnQgcmVwcmVzZW50cyB0aGUgYmFja2VuZCBjb25maWd1cmF0aW9uIHRoYXQgdGhlIG1vZGVsIHJ1bnMgd2l0aC5cbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgYHNlZWRgIHJlcXVlc3QgcGFyYW1ldGVyIHRvIHVuZGVyc3RhbmQgd2hlblxuICAgKiBiYWNrZW5kIGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUgdGhhdCBtaWdodCBpbXBhY3QgZGV0ZXJtaW5pc20uXG4gICAqL1xuICBzeXN0ZW1fZmluZ2VycHJpbnQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIGZpZWxkIHRoYXQgd2lsbCBvbmx5IGJlIHByZXNlbnQgd2hlbiB5b3Ugc2V0XG4gICAqIGBzdHJlYW1fb3B0aW9uczoge1wiaW5jbHVkZV91c2FnZVwiOiB0cnVlfWAgaW4geW91ciByZXF1ZXN0LiBXaGVuIHByZXNlbnQsIGl0XG4gICAqIGNvbnRhaW5zIGEgbnVsbCB2YWx1ZSBleGNlcHQgZm9yIHRoZSBsYXN0IGNodW5rIHdoaWNoIGNvbnRhaW5zIHRoZSB0b2tlbiB1c2FnZVxuICAgKiBzdGF0aXN0aWNzIGZvciB0aGUgZW50aXJlIHJlcXVlc3QuXG4gICAqL1xuICB1c2FnZT86IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25Vc2FnZSB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdENvbXBsZXRpb25DaHVuayB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ2hvaWNlIHtcbiAgICAvKipcbiAgICAgKiBBIGNoYXQgY29tcGxldGlvbiBkZWx0YSBnZW5lcmF0ZWQgYnkgc3RyZWFtZWQgbW9kZWwgcmVzcG9uc2VzLlxuICAgICAqL1xuICAgIGRlbHRhOiBDaG9pY2UuRGVsdGE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVhc29uIHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLiBUaGlzIHdpbGwgYmUgYHN0b3BgIGlmIHRoZSBtb2RlbFxuICAgICAqIGhpdCBhIG5hdHVyYWwgc3RvcCBwb2ludCBvciBhIHByb3ZpZGVkIHN0b3Agc2VxdWVuY2UsIGBsZW5ndGhgIGlmIHRoZSBtYXhpbXVtXG4gICAgICogbnVtYmVyIG9mIHRva2VucyBzcGVjaWZpZWQgaW4gdGhlIHJlcXVlc3Qgd2FzIHJlYWNoZWQsIGBjb250ZW50X2ZpbHRlcmAgaWZcbiAgICAgKiBjb250ZW50IHdhcyBvbWl0dGVkIGR1ZSB0byBhIGZsYWcgZnJvbSBvdXIgY29udGVudCBmaWx0ZXJzLCBgdG9vbF9jYWxsc2AgaWYgdGhlXG4gICAgICogbW9kZWwgY2FsbGVkIGEgdG9vbCwgb3IgYGZ1bmN0aW9uX2NhbGxgIChkZXByZWNhdGVkKSBpZiB0aGUgbW9kZWwgY2FsbGVkIGFcbiAgICAgKiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmaW5pc2hfcmVhc29uOiAnc3RvcCcgfCAnbGVuZ3RoJyB8ICd0b29sX2NhbGxzJyB8ICdjb250ZW50X2ZpbHRlcicgfCAnZnVuY3Rpb25fY2FsbCcgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBjaG9pY2UgaW4gdGhlIGxpc3Qgb2YgY2hvaWNlcy5cbiAgICAgKi9cbiAgICBpbmRleDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogTG9nIHByb2JhYmlsaXR5IGluZm9ybWF0aW9uIGZvciB0aGUgY2hvaWNlLlxuICAgICAqL1xuICAgIGxvZ3Byb2JzPzogQ2hvaWNlLkxvZ3Byb2JzIHwgbnVsbDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgQ2hvaWNlIHtcbiAgICAvKipcbiAgICAgKiBBIGNoYXQgY29tcGxldGlvbiBkZWx0YSBnZW5lcmF0ZWQgYnkgc3RyZWFtZWQgbW9kZWwgcmVzcG9uc2VzLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgRGVsdGEge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGNodW5rIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ/OiBzdHJpbmcgfCBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBkZXByZWNhdGVkOiBEZXByZWNhdGVkIGFuZCByZXBsYWNlZCBieSBgdG9vbF9jYWxsc2AuIFRoZSBuYW1lIGFuZCBhcmd1bWVudHMgb2ZcbiAgICAgICAqIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbl9jYWxsPzogRGVsdGEuRnVuY3Rpb25DYWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSByZWZ1c2FsIG1lc3NhZ2UgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICAgICAqL1xuICAgICAgcmVmdXNhbD86IHN0cmluZyB8IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHJvbGUgb2YgdGhlIGF1dGhvciBvZiB0aGlzIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIHJvbGU/OiAnc3lzdGVtJyB8ICd1c2VyJyB8ICdhc3Npc3RhbnQnIHwgJ3Rvb2wnO1xuXG4gICAgICB0b29sX2NhbGxzPzogQXJyYXk8RGVsdGEuVG9vbENhbGw+O1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgRGVsdGEge1xuICAgICAgLyoqXG4gICAgICAgKiBAZGVwcmVjYXRlZDogRGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgYnkgYHRvb2xfY2FsbHNgLiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mXG4gICAgICAgKiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICAgICAqL1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkNhbGwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICAgICAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAgICAgICAqIGhhbGx1Y2luYXRlIHBhcmFtZXRlcnMgbm90IGRlZmluZWQgYnkgeW91ciBmdW5jdGlvbiBzY2hlbWEuIFZhbGlkYXRlIHRoZVxuICAgICAgICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBhcmd1bWVudHM/OiBzdHJpbmc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgbmFtZT86IHN0cmluZztcbiAgICAgIH1cblxuICAgICAgZXhwb3J0IGludGVyZmFjZSBUb29sQ2FsbCB7XG4gICAgICAgIGluZGV4OiBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgaWQ/OiBzdHJpbmc7XG5cbiAgICAgICAgZnVuY3Rpb24/OiBUb29sQ2FsbC5GdW5jdGlvbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wuIEN1cnJlbnRseSwgb25seSBgZnVuY3Rpb25gIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHR5cGU/OiAnZnVuY3Rpb24nO1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgbmFtZXNwYWNlIFRvb2xDYWxsIHtcbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICAgICAgICAgKiBmb3JtYXQuIE5vdGUgdGhhdCB0aGUgbW9kZWwgZG9lcyBub3QgYWx3YXlzIGdlbmVyYXRlIHZhbGlkIEpTT04sIGFuZCBtYXlcbiAgICAgICAgICAgKiBoYWxsdWNpbmF0ZSBwYXJhbWV0ZXJzIG5vdCBkZWZpbmVkIGJ5IHlvdXIgZnVuY3Rpb24gc2NoZW1hLiBWYWxpZGF0ZSB0aGVcbiAgICAgICAgICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAgICAgICAgICovXG4gICAgICAgICAgYXJndW1lbnRzPzogc3RyaW5nO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICAgICAgICovXG4gICAgICAgICAgbmFtZT86IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvZyBwcm9iYWJpbGl0eSBpbmZvcm1hdGlvbiBmb3IgdGhlIGNob2ljZS5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIExvZ3Byb2JzIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIG1lc3NhZ2UgY29udGVudCB0b2tlbnMgd2l0aCBsb2cgcHJvYmFiaWxpdHkgaW5mb3JtYXRpb24uXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ6IEFycmF5PENoYXRDb21wbGV0aW9uc0FQSS5DaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYj4gfCBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBtZXNzYWdlIHJlZnVzYWwgdG9rZW5zIHdpdGggbG9nIHByb2JhYmlsaXR5IGluZm9ybWF0aW9uLlxuICAgICAgICovXG4gICAgICByZWZ1c2FsOiBBcnJheTxDaGF0Q29tcGxldGlvbnNBUEkuQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2I+IHwgbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBMZWFybiBhYm91dFxuICogW3RleHQgaW5wdXRzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvdGV4dC1nZW5lcmF0aW9uKS5cbiAqL1xuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydCA9XG4gIHwgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHRcbiAgfCBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2VcbiAgfCBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW5wdXRBdWRpbztcblxuLyoqXG4gKiBMZWFybiBhYm91dCBbaW1hZ2UgaW5wdXRzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvdmlzaW9uKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2Uge1xuICBpbWFnZV91cmw6IENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbWFnZS5JbWFnZVVSTDtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIGNvbnRlbnQgcGFydC5cbiAgICovXG4gIHR5cGU6ICdpbWFnZV91cmwnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbWFnZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VVUkwge1xuICAgIC8qKlxuICAgICAqIEVpdGhlciBhIFVSTCBvZiB0aGUgaW1hZ2Ugb3IgdGhlIGJhc2U2NCBlbmNvZGVkIGltYWdlIGRhdGEuXG4gICAgICovXG4gICAgdXJsOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGRldGFpbCBsZXZlbCBvZiB0aGUgaW1hZ2UuIExlYXJuIG1vcmUgaW4gdGhlXG4gICAgICogW1Zpc2lvbiBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3Zpc2lvbiNsb3ctb3ItaGlnaC1maWRlbGl0eS1pbWFnZS11bmRlcnN0YW5kaW5nKS5cbiAgICAgKi9cbiAgICBkZXRhaWw/OiAnYXV0bycgfCAnbG93JyB8ICdoaWdoJztcbiAgfVxufVxuXG4vKipcbiAqIExlYXJuIGFib3V0IFthdWRpbyBpbnB1dHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9hdWRpbykuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydElucHV0QXVkaW8ge1xuICBpbnB1dF9hdWRpbzogQ2hhdENvbXBsZXRpb25Db250ZW50UGFydElucHV0QXVkaW8uSW5wdXRBdWRpbztcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIGNvbnRlbnQgcGFydC4gQWx3YXlzIGBpbnB1dF9hdWRpb2AuXG4gICAqL1xuICB0eXBlOiAnaW5wdXRfYXVkaW8nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbnB1dEF1ZGlvIHtcbiAgZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvIHtcbiAgICAvKipcbiAgICAgKiBCYXNlNjQgZW5jb2RlZCBhdWRpbyBkYXRhLlxuICAgICAqL1xuICAgIGRhdGE6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb3JtYXQgb2YgdGhlIGVuY29kZWQgYXVkaW8gZGF0YS4gQ3VycmVudGx5IHN1cHBvcnRzIFwid2F2XCIgYW5kIFwibXAzXCIuXG4gICAgICovXG4gICAgZm9ybWF0OiAnd2F2JyB8ICdtcDMnO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFJlZnVzYWwge1xuICAvKipcbiAgICogVGhlIHJlZnVzYWwgbWVzc2FnZSBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgcmVmdXNhbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgY29udGVudCBwYXJ0LlxuICAgKi9cbiAgdHlwZTogJ3JlZnVzYWwnO1xufVxuXG4vKipcbiAqIExlYXJuIGFib3V0XG4gKiBbdGV4dCBpbnB1dHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy90ZXh0LWdlbmVyYXRpb24pLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0IHtcbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGNvbnRlbnQuXG4gICAqL1xuICB0ZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBjb250ZW50IHBhcnQuXG4gICAqL1xuICB0eXBlOiAndGV4dCc7XG59XG5cbi8qKlxuICogRGV2ZWxvcGVyLXByb3ZpZGVkIGluc3RydWN0aW9ucyB0aGF0IHRoZSBtb2RlbCBzaG91bGQgZm9sbG93LCByZWdhcmRsZXNzIG9mXG4gKiBtZXNzYWdlcyBzZW50IGJ5IHRoZSB1c2VyLiBXaXRoIG8xIG1vZGVscyBhbmQgbmV3ZXIsIGBkZXZlbG9wZXJgIG1lc3NhZ2VzXG4gKiByZXBsYWNlIHRoZSBwcmV2aW91cyBgc3lzdGVtYCBtZXNzYWdlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkRldmVsb3Blck1lc3NhZ2VQYXJhbSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGRldmVsb3BlciBtZXNzYWdlLlxuICAgKi9cbiAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8Q2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgbWVzc2FnZXMgYXV0aG9yLCBpbiB0aGlzIGNhc2UgYGRldmVsb3BlcmAuXG4gICAqL1xuICByb2xlOiAnZGV2ZWxvcGVyJztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIHBhcnRpY2lwYW50LiBQcm92aWRlcyB0aGUgbW9kZWwgaW5mb3JtYXRpb24gdG9cbiAgICogZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHBhcnRpY2lwYW50cyBvZiB0aGUgc2FtZSByb2xlLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciBmdW5jdGlvbiB2aWEgYHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifWAgZm9yY2VzIHRoZSBtb2RlbFxuICogdG8gY2FsbCB0aGF0IGZ1bmN0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uRnVuY3Rpb25DYWxsT3B0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25GdW5jdGlvbk1lc3NhZ2VQYXJhbSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGZ1bmN0aW9uIG1lc3NhZ2UuXG4gICAqL1xuICBjb250ZW50OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICovXG4gIG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIG1lc3NhZ2VzIGF1dGhvciwgaW4gdGhpcyBjYXNlIGBmdW5jdGlvbmAuXG4gICAqL1xuICByb2xlOiAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEEgY2hhdCBjb21wbGV0aW9uIG1lc3NhZ2UgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2Uge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgY29udGVudDogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHJlZnVzYWwgbWVzc2FnZSBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgcmVmdXNhbDogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIGF1dGhvciBvZiB0aGlzIG1lc3NhZ2UuXG4gICAqL1xuICByb2xlOiAnYXNzaXN0YW50JztcblxuICAvKipcbiAgICogSWYgdGhlIGF1ZGlvIG91dHB1dCBtb2RhbGl0eSBpcyByZXF1ZXN0ZWQsIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGRhdGEgYWJvdXQgdGhlXG4gICAqIGF1ZGlvIHJlc3BvbnNlIGZyb20gdGhlIG1vZGVsLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2F1ZGlvKS5cbiAgICovXG4gIGF1ZGlvPzogQ2hhdENvbXBsZXRpb25BdWRpbyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkOiBEZXByZWNhdGVkIGFuZCByZXBsYWNlZCBieSBgdG9vbF9jYWxsc2AuIFRoZSBuYW1lIGFuZCBhcmd1bWVudHMgb2ZcbiAgICogYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQsIGFzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICBmdW5jdGlvbl9jYWxsPzogQ2hhdENvbXBsZXRpb25NZXNzYWdlLkZ1bmN0aW9uQ2FsbCB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSB0b29sIGNhbGxzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwsIHN1Y2ggYXMgZnVuY3Rpb24gY2FsbHMuXG4gICAqL1xuICB0b29sX2NhbGxzPzogQXJyYXk8Q2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGw+O1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZDogRGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgYnkgYHRvb2xfY2FsbHNgLiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mXG4gICAqIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkNhbGwge1xuICAgIC8qKlxuICAgICAqIFRoZSBhcmd1bWVudHMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpbiBKU09OXG4gICAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAgICogaGFsbHVjaW5hdGUgcGFyYW1ldGVycyBub3QgZGVmaW5lZCBieSB5b3VyIGZ1bmN0aW9uIHNjaGVtYS4gVmFsaWRhdGUgdGhlXG4gICAgICogYXJndW1lbnRzIGluIHlvdXIgY29kZSBiZWZvcmUgY2FsbGluZyB5b3VyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGFyZ3VtZW50czogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogRGV2ZWxvcGVyLXByb3ZpZGVkIGluc3RydWN0aW9ucyB0aGF0IHRoZSBtb2RlbCBzaG91bGQgZm9sbG93LCByZWdhcmRsZXNzIG9mXG4gKiBtZXNzYWdlcyBzZW50IGJ5IHRoZSB1c2VyLiBXaXRoIG8xIG1vZGVscyBhbmQgbmV3ZXIsIGBkZXZlbG9wZXJgIG1lc3NhZ2VzXG4gKiByZXBsYWNlIHRoZSBwcmV2aW91cyBgc3lzdGVtYCBtZXNzYWdlcy5cbiAqL1xuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0gPVxuICB8IENoYXRDb21wbGV0aW9uRGV2ZWxvcGVyTWVzc2FnZVBhcmFtXG4gIHwgQ2hhdENvbXBsZXRpb25TeXN0ZW1NZXNzYWdlUGFyYW1cbiAgfCBDaGF0Q29tcGxldGlvblVzZXJNZXNzYWdlUGFyYW1cbiAgfCBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbVxuICB8IENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbVxuICB8IENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gdGhhdCB0aGUgbW9kZWwgY2FsbGVkLlxuICAgKi9cbiAgZnVuY3Rpb246IENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsLkZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbC4gQ3VycmVudGx5LCBvbmx5IGBmdW5jdGlvbmAgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgdHlwZTogJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCB7XG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gdGhhdCB0aGUgbW9kZWwgY2FsbGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICAgKiBmb3JtYXQuIE5vdGUgdGhhdCB0aGUgbW9kZWwgZG9lcyBub3QgYWx3YXlzIGdlbmVyYXRlIHZhbGlkIEpTT04sIGFuZCBtYXlcbiAgICAgKiBoYWxsdWNpbmF0ZSBwYXJhbWV0ZXJzIG5vdCBkZWZpbmVkIGJ5IHlvdXIgZnVuY3Rpb24gc2NoZW1hLiBWYWxpZGF0ZSB0aGVcbiAgICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXJndW1lbnRzOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmc7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25Nb2RhbGl0eSA9ICd0ZXh0JyB8ICdhdWRpbyc7XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgdG9vbCB0aGUgbW9kZWwgc2hvdWxkIHVzZS4gVXNlIHRvIGZvcmNlIHRoZSBtb2RlbCB0byBjYWxsIGEgc3BlY2lmaWNcbiAqIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlIHtcbiAgZnVuY3Rpb246IENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlLkZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbC4gQ3VycmVudGx5LCBvbmx5IGBmdW5jdGlvbmAgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgdHlwZTogJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0Q29tcGxldGlvbk5hbWVkVG9vbENob2ljZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIFN0YXRpYyBwcmVkaWN0ZWQgb3V0cHV0IGNvbnRlbnQsIHN1Y2ggYXMgdGhlIGNvbnRlbnQgb2YgYSB0ZXh0IGZpbGUgdGhhdCBpc1xuICogYmVpbmcgcmVnZW5lcmF0ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25QcmVkaWN0aW9uQ29udGVudCB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudCB0aGF0IHNob3VsZCBiZSBtYXRjaGVkIHdoZW4gZ2VuZXJhdGluZyBhIG1vZGVsIHJlc3BvbnNlLiBJZlxuICAgKiBnZW5lcmF0ZWQgdG9rZW5zIHdvdWxkIG1hdGNoIHRoaXMgY29udGVudCwgdGhlIGVudGlyZSBtb2RlbCByZXNwb25zZSBjYW4gYmVcbiAgICogcmV0dXJuZWQgbXVjaCBtb3JlIHF1aWNrbHkuXG4gICAqL1xuICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dD47XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBwcmVkaWN0ZWQgY29udGVudCB5b3Ugd2FudCB0byBwcm92aWRlLiBUaGlzIHR5cGUgaXMgY3VycmVudGx5XG4gICAqIGFsd2F5cyBgY29udGVudGAuXG4gICAqL1xuICB0eXBlOiAnY29udGVudCc7XG59XG5cbi8qKlxuICogKipvMSBtb2RlbHMgb25seSoqXG4gKlxuICogQ29uc3RyYWlucyBlZmZvcnQgb24gcmVhc29uaW5nIGZvclxuICogW3JlYXNvbmluZyBtb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9yZWFzb25pbmcpLiBDdXJyZW50bHlcbiAqIHN1cHBvcnRlZCB2YWx1ZXMgYXJlIGBsb3dgLCBgbWVkaXVtYCwgYW5kIGBoaWdoYC4gUmVkdWNpbmcgcmVhc29uaW5nIGVmZm9ydCBjYW5cbiAqIHJlc3VsdCBpbiBmYXN0ZXIgcmVzcG9uc2VzIGFuZCBmZXdlciB0b2tlbnMgdXNlZCBvbiByZWFzb25pbmcgaW4gYSByZXNwb25zZS5cbiAqL1xuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25SZWFzb25pbmdFZmZvcnQgPSAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnO1xuXG4vKipcbiAqIFRoZSByb2xlIG9mIHRoZSBhdXRob3Igb2YgYSBtZXNzYWdlXG4gKi9cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uUm9sZSA9ICdzeXN0ZW0nIHwgJ3VzZXInIHwgJ2Fzc2lzdGFudCcgfCAndG9vbCcgfCAnZnVuY3Rpb24nO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHN0cmVhbWluZyByZXNwb25zZS4gT25seSBzZXQgdGhpcyB3aGVuIHlvdSBzZXQgYHN0cmVhbTogdHJ1ZWAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25TdHJlYW1PcHRpb25zIHtcbiAgLyoqXG4gICAqIElmIHNldCwgYW4gYWRkaXRpb25hbCBjaHVuayB3aWxsIGJlIHN0cmVhbWVkIGJlZm9yZSB0aGUgYGRhdGE6IFtET05FXWAgbWVzc2FnZS5cbiAgICogVGhlIGB1c2FnZWAgZmllbGQgb24gdGhpcyBjaHVuayBzaG93cyB0aGUgdG9rZW4gdXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIGVudGlyZVxuICAgKiByZXF1ZXN0LCBhbmQgdGhlIGBjaG9pY2VzYCBmaWVsZCB3aWxsIGFsd2F5cyBiZSBhbiBlbXB0eSBhcnJheS4gQWxsIG90aGVyIGNodW5rc1xuICAgKiB3aWxsIGFsc28gaW5jbHVkZSBhIGB1c2FnZWAgZmllbGQsIGJ1dCB3aXRoIGEgbnVsbCB2YWx1ZS5cbiAgICovXG4gIGluY2x1ZGVfdXNhZ2U/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIERldmVsb3Blci1wcm92aWRlZCBpbnN0cnVjdGlvbnMgdGhhdCB0aGUgbW9kZWwgc2hvdWxkIGZvbGxvdywgcmVnYXJkbGVzcyBvZlxuICogbWVzc2FnZXMgc2VudCBieSB0aGUgdXNlci4gV2l0aCBvMSBtb2RlbHMgYW5kIG5ld2VyLCB1c2UgYGRldmVsb3BlcmAgbWVzc2FnZXNcbiAqIGZvciB0aGlzIHB1cnBvc2UgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvblN5c3RlbU1lc3NhZ2VQYXJhbSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIHN5c3RlbSBtZXNzYWdlLlxuICAgKi9cbiAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8Q2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgbWVzc2FnZXMgYXV0aG9yLCBpbiB0aGlzIGNhc2UgYHN5c3RlbWAuXG4gICAqL1xuICByb2xlOiAnc3lzdGVtJztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIHBhcnRpY2lwYW50LiBQcm92aWRlcyB0aGUgbW9kZWwgaW5mb3JtYXRpb24gdG9cbiAgICogZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHBhcnRpY2lwYW50cyBvZiB0aGUgc2FtZSByb2xlLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYiB7XG4gIC8qKlxuICAgKiBUaGUgdG9rZW4uXG4gICAqL1xuICB0b2tlbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgaW50ZWdlcnMgcmVwcmVzZW50aW5nIHRoZSBVVEYtOCBieXRlcyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdG9rZW4uXG4gICAqIFVzZWZ1bCBpbiBpbnN0YW5jZXMgd2hlcmUgY2hhcmFjdGVycyBhcmUgcmVwcmVzZW50ZWQgYnkgbXVsdGlwbGUgdG9rZW5zIGFuZFxuICAgKiB0aGVpciBieXRlIHJlcHJlc2VudGF0aW9ucyBtdXN0IGJlIGNvbWJpbmVkIHRvIGdlbmVyYXRlIHRoZSBjb3JyZWN0IHRleHRcbiAgICogcmVwcmVzZW50YXRpb24uIENhbiBiZSBgbnVsbGAgaWYgdGhlcmUgaXMgbm8gYnl0ZXMgcmVwcmVzZW50YXRpb24gZm9yIHRoZSB0b2tlbi5cbiAgICovXG4gIGJ5dGVzOiBBcnJheTxudW1iZXI+IHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGxvZyBwcm9iYWJpbGl0eSBvZiB0aGlzIHRva2VuLCBpZiBpdCBpcyB3aXRoaW4gdGhlIHRvcCAyMCBtb3N0IGxpa2VseVxuICAgKiB0b2tlbnMuIE90aGVyd2lzZSwgdGhlIHZhbHVlIGAtOTk5OS4wYCBpcyB1c2VkIHRvIHNpZ25pZnkgdGhhdCB0aGUgdG9rZW4gaXMgdmVyeVxuICAgKiB1bmxpa2VseS5cbiAgICovXG4gIGxvZ3Byb2I6IG51bWJlcjtcblxuICAvKipcbiAgICogTGlzdCBvZiB0aGUgbW9zdCBsaWtlbHkgdG9rZW5zIGFuZCB0aGVpciBsb2cgcHJvYmFiaWxpdHksIGF0IHRoaXMgdG9rZW5cbiAgICogcG9zaXRpb24uIEluIHJhcmUgY2FzZXMsIHRoZXJlIG1heSBiZSBmZXdlciB0aGFuIHRoZSBudW1iZXIgb2YgcmVxdWVzdGVkXG4gICAqIGB0b3BfbG9ncHJvYnNgIHJldHVybmVkLlxuICAgKi9cbiAgdG9wX2xvZ3Byb2JzOiBBcnJheTxDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYi5Ub3BMb2dwcm9iPjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYiB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9wTG9ncHJvYiB7XG4gICAgLyoqXG4gICAgICogVGhlIHRva2VuLlxuICAgICAqL1xuICAgIHRva2VuOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgaW50ZWdlcnMgcmVwcmVzZW50aW5nIHRoZSBVVEYtOCBieXRlcyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdG9rZW4uXG4gICAgICogVXNlZnVsIGluIGluc3RhbmNlcyB3aGVyZSBjaGFyYWN0ZXJzIGFyZSByZXByZXNlbnRlZCBieSBtdWx0aXBsZSB0b2tlbnMgYW5kXG4gICAgICogdGhlaXIgYnl0ZSByZXByZXNlbnRhdGlvbnMgbXVzdCBiZSBjb21iaW5lZCB0byBnZW5lcmF0ZSB0aGUgY29ycmVjdCB0ZXh0XG4gICAgICogcmVwcmVzZW50YXRpb24uIENhbiBiZSBgbnVsbGAgaWYgdGhlcmUgaXMgbm8gYnl0ZXMgcmVwcmVzZW50YXRpb24gZm9yIHRoZSB0b2tlbi5cbiAgICAgKi9cbiAgICBieXRlczogQXJyYXk8bnVtYmVyPiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9nIHByb2JhYmlsaXR5IG9mIHRoaXMgdG9rZW4sIGlmIGl0IGlzIHdpdGhpbiB0aGUgdG9wIDIwIG1vc3QgbGlrZWx5XG4gICAgICogdG9rZW5zLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBgLTk5OTkuMGAgaXMgdXNlZCB0byBzaWduaWZ5IHRoYXQgdGhlIHRva2VuIGlzIHZlcnlcbiAgICAgKiB1bmxpa2VseS5cbiAgICAgKi9cbiAgICBsb2dwcm9iOiBudW1iZXI7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvblRvb2wge1xuICBmdW5jdGlvbjogU2hhcmVkLkZ1bmN0aW9uRGVmaW5pdGlvbjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wuIEN1cnJlbnRseSwgb25seSBgZnVuY3Rpb25gIGlzIHN1cHBvcnRlZC5cbiAgICovXG4gIHR5cGU6ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgdG9vbCBpcyBjYWxsZWQgYnkgdGhlIG1vZGVsLiBgbm9uZWAgbWVhbnMgdGhlIG1vZGVsIHdpbGxcbiAqIG5vdCBjYWxsIGFueSB0b29sIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBtZWFucyB0aGUgbW9kZWwgY2FuXG4gKiBwaWNrIGJldHdlZW4gZ2VuZXJhdGluZyBhIG1lc3NhZ2Ugb3IgY2FsbGluZyBvbmUgb3IgbW9yZSB0b29scy4gYHJlcXVpcmVkYCBtZWFuc1xuICogdGhlIG1vZGVsIG11c3QgY2FsbCBvbmUgb3IgbW9yZSB0b29scy4gU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgdG9vbCB2aWFcbiAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gKiBjYWxsIHRoYXQgdG9vbC5cbiAqXG4gKiBgbm9uZWAgaXMgdGhlIGRlZmF1bHQgd2hlbiBubyB0b29scyBhcmUgcHJlc2VudC4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IGlmIHRvb2xzXG4gKiBhcmUgcHJlc2VudC5cbiAqL1xuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sQ2hvaWNlT3B0aW9uID0gJ25vbmUnIHwgJ2F1dG8nIHwgJ3JlcXVpcmVkJyB8IENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIHRvb2wgbWVzc2FnZS5cbiAgICovXG4gIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0PjtcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIG1lc3NhZ2VzIGF1dGhvciwgaW4gdGhpcyBjYXNlIGB0b29sYC5cbiAgICovXG4gIHJvbGU6ICd0b29sJztcblxuICAvKipcbiAgICogVG9vbCBjYWxsIHRoYXQgdGhpcyBtZXNzYWdlIGlzIHJlc3BvbmRpbmcgdG8uXG4gICAqL1xuICB0b29sX2NhbGxfaWQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBNZXNzYWdlcyBzZW50IGJ5IGFuIGVuZCB1c2VyLCBjb250YWluaW5nIHByb21wdHMgb3IgYWRkaXRpb25hbCBjb250ZXh0XG4gKiBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvblVzZXJNZXNzYWdlUGFyYW0ge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSB1c2VyIG1lc3NhZ2UuXG4gICAqL1xuICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0PjtcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIG1lc3NhZ2VzIGF1dGhvciwgaW4gdGhpcyBjYXNlIGB1c2VyYC5cbiAgICovXG4gIHJvbGU6ICd1c2VyJztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIHBhcnRpY2lwYW50LiBQcm92aWRlcyB0aGUgbW9kZWwgaW5mb3JtYXRpb24gdG9cbiAgICogZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHBhcnRpY2lwYW50cyBvZiB0aGUgc2FtZSByb2xlLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkXG4gKi9cbmV4cG9ydCB0eXBlIENyZWF0ZUNoYXRDb21wbGV0aW9uUmVxdWVzdE1lc3NhZ2UgPSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbTtcblxuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMgPVxuICB8IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nXG4gIHwgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBtZXNzYWdlcyBjb21wcmlzaW5nIHRoZSBjb252ZXJzYXRpb24gc28gZmFyLiBEZXBlbmRpbmcgb24gdGhlXG4gICAqIFttb2RlbF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzKSB5b3UgdXNlLCBkaWZmZXJlbnQgbWVzc2FnZVxuICAgKiB0eXBlcyAobW9kYWxpdGllcykgYXJlIHN1cHBvcnRlZCwgbGlrZVxuICAgKiBbdGV4dF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3RleHQtZ2VuZXJhdGlvbiksXG4gICAqIFtpbWFnZXNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy92aXNpb24pLCBhbmRcbiAgICogW2F1ZGlvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYXVkaW8pLlxuICAgKi9cbiAgbWVzc2FnZXM6IEFycmF5PENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtPjtcblxuICAvKipcbiAgICogSUQgb2YgdGhlIG1vZGVsIHRvIHVzZS4gU2VlIHRoZVxuICAgKiBbbW9kZWwgZW5kcG9pbnQgY29tcGF0aWJpbGl0eV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI21vZGVsLWVuZHBvaW50LWNvbXBhdGliaWxpdHkpXG4gICAqIHRhYmxlIGZvciBkZXRhaWxzIG9uIHdoaWNoIG1vZGVscyB3b3JrIHdpdGggdGhlIENoYXQgQVBJLlxuICAgKi9cbiAgbW9kZWw6IChzdHJpbmcgJiB7fSkgfCBDaGF0QVBJLkNoYXRNb2RlbDtcblxuICAvKipcbiAgICogUGFyYW1ldGVycyBmb3IgYXVkaW8gb3V0cHV0LiBSZXF1aXJlZCB3aGVuIGF1ZGlvIG91dHB1dCBpcyByZXF1ZXN0ZWQgd2l0aFxuICAgKiBgbW9kYWxpdGllczogW1wiYXVkaW9cIl1gLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2F1ZGlvKS5cbiAgICovXG4gIGF1ZGlvPzogQ2hhdENvbXBsZXRpb25BdWRpb1BhcmFtIHwgbnVsbDtcblxuICAvKipcbiAgICogTnVtYmVyIGJldHdlZW4gLTIuMCBhbmQgMi4wLiBQb3NpdGl2ZSB2YWx1ZXMgcGVuYWxpemUgbmV3IHRva2VucyBiYXNlZCBvbiB0aGVpclxuICAgKiBleGlzdGluZyBmcmVxdWVuY3kgaW4gdGhlIHRleHQgc28gZmFyLCBkZWNyZWFzaW5nIHRoZSBtb2RlbCdzIGxpa2VsaWhvb2QgdG9cbiAgICogcmVwZWF0IHRoZSBzYW1lIGxpbmUgdmVyYmF0aW0uXG4gICAqL1xuICBmcmVxdWVuY3lfcGVuYWx0eT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgYHRvb2xfY2hvaWNlYC5cbiAgICpcbiAgICogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC5cbiAgICpcbiAgICogYG5vbmVgIG1lYW5zIHRoZSBtb2RlbCB3aWxsIG5vdCBjYWxsIGEgZnVuY3Rpb24gYW5kIGluc3RlYWQgZ2VuZXJhdGVzIGEgbWVzc2FnZS5cbiAgICpcbiAgICogYGF1dG9gIG1lYW5zIHRoZSBtb2RlbCBjYW4gcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yIGNhbGxpbmcgYVxuICAgKiBmdW5jdGlvbi5cbiAgICpcbiAgICogU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgZnVuY3Rpb24gdmlhIGB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn1gIGZvcmNlcyB0aGUgbW9kZWxcbiAgICogdG8gY2FsbCB0aGF0IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBgbm9uZWAgaXMgdGhlIGRlZmF1bHQgd2hlbiBubyBmdW5jdGlvbnMgYXJlIHByZXNlbnQuIGBhdXRvYCBpcyB0aGUgZGVmYXVsdCBpZlxuICAgKiBmdW5jdGlvbnMgYXJlIHByZXNlbnQuXG4gICAqL1xuICBmdW5jdGlvbl9jYWxsPzogJ25vbmUnIHwgJ2F1dG8nIHwgQ2hhdENvbXBsZXRpb25GdW5jdGlvbkNhbGxPcHRpb247XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgYHRvb2xzYC5cbiAgICpcbiAgICogQSBsaXN0IG9mIGZ1bmN0aW9ucyB0aGUgbW9kZWwgbWF5IGdlbmVyYXRlIEpTT04gaW5wdXRzIGZvci5cbiAgICovXG4gIGZ1bmN0aW9ucz86IEFycmF5PENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLkZ1bmN0aW9uPjtcblxuICAvKipcbiAgICogTW9kaWZ5IHRoZSBsaWtlbGlob29kIG9mIHNwZWNpZmllZCB0b2tlbnMgYXBwZWFyaW5nIGluIHRoZSBjb21wbGV0aW9uLlxuICAgKlxuICAgKiBBY2NlcHRzIGEgSlNPTiBvYmplY3QgdGhhdCBtYXBzIHRva2VucyAoc3BlY2lmaWVkIGJ5IHRoZWlyIHRva2VuIElEIGluIHRoZVxuICAgKiB0b2tlbml6ZXIpIHRvIGFuIGFzc29jaWF0ZWQgYmlhcyB2YWx1ZSBmcm9tIC0xMDAgdG8gMTAwLiBNYXRoZW1hdGljYWxseSwgdGhlXG4gICAqIGJpYXMgaXMgYWRkZWQgdG8gdGhlIGxvZ2l0cyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIHByaW9yIHRvIHNhbXBsaW5nLiBUaGUgZXhhY3RcbiAgICogZWZmZWN0IHdpbGwgdmFyeSBwZXIgbW9kZWwsIGJ1dCB2YWx1ZXMgYmV0d2VlbiAtMSBhbmQgMSBzaG91bGQgZGVjcmVhc2Ugb3JcbiAgICogaW5jcmVhc2UgbGlrZWxpaG9vZCBvZiBzZWxlY3Rpb247IHZhbHVlcyBsaWtlIC0xMDAgb3IgMTAwIHNob3VsZCByZXN1bHQgaW4gYSBiYW5cbiAgICogb3IgZXhjbHVzaXZlIHNlbGVjdGlvbiBvZiB0aGUgcmVsZXZhbnQgdG9rZW4uXG4gICAqL1xuICBsb2dpdF9iaWFzPzogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmV0dXJuIGxvZyBwcm9iYWJpbGl0aWVzIG9mIHRoZSBvdXRwdXQgdG9rZW5zIG9yIG5vdC4gSWYgdHJ1ZSxcbiAgICogcmV0dXJucyB0aGUgbG9nIHByb2JhYmlsaXRpZXMgb2YgZWFjaCBvdXRwdXQgdG9rZW4gcmV0dXJuZWQgaW4gdGhlIGBjb250ZW50YCBvZlxuICAgKiBgbWVzc2FnZWAuXG4gICAqL1xuICBsb2dwcm9icz86IGJvb2xlYW4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiB1cHBlciBib3VuZCBmb3IgdGhlIG51bWJlciBvZiB0b2tlbnMgdGhhdCBjYW4gYmUgZ2VuZXJhdGVkIGZvciBhIGNvbXBsZXRpb24sXG4gICAqIGluY2x1ZGluZyB2aXNpYmxlIG91dHB1dCB0b2tlbnMgYW5kXG4gICAqIFtyZWFzb25pbmcgdG9rZW5zXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvcmVhc29uaW5nKS5cbiAgICovXG4gIG1heF9jb21wbGV0aW9uX3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBbdG9rZW5zXSgvdG9rZW5pemVyKSB0aGF0IGNhbiBiZSBnZW5lcmF0ZWQgaW4gdGhlIGNoYXRcbiAgICogY29tcGxldGlvbi4gVGhpcyB2YWx1ZSBjYW4gYmUgdXNlZCB0byBjb250cm9sXG4gICAqIFtjb3N0c10oaHR0cHM6Ly9vcGVuYWkuY29tL2FwaS9wcmljaW5nLykgZm9yIHRleHQgZ2VuZXJhdGVkIHZpYSBBUEkuXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgaXMgbm93IGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgYG1heF9jb21wbGV0aW9uX3Rva2Vuc2AsIGFuZCBpcyBub3RcbiAgICogY29tcGF0aWJsZSB3aXRoXG4gICAqIFtvMSBzZXJpZXMgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvcmVhc29uaW5nKS5cbiAgICovXG4gIG1heF90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBEZXZlbG9wZXItZGVmaW5lZCB0YWdzIGFuZCB2YWx1ZXMgdXNlZCBmb3IgZmlsdGVyaW5nIGNvbXBsZXRpb25zIGluIHRoZVxuICAgKiBbZGFzaGJvYXJkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vY2hhdC1jb21wbGV0aW9ucykuXG4gICAqL1xuICBtZXRhZGF0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPdXRwdXQgdHlwZXMgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgbW9kZWwgdG8gZ2VuZXJhdGUgZm9yIHRoaXMgcmVxdWVzdC4gTW9zdFxuICAgKiBtb2RlbHMgYXJlIGNhcGFibGUgb2YgZ2VuZXJhdGluZyB0ZXh0LCB3aGljaCBpcyB0aGUgZGVmYXVsdDpcbiAgICpcbiAgICogYFtcInRleHRcIl1gXG4gICAqXG4gICAqIFRoZSBgZ3B0LTRvLWF1ZGlvLXByZXZpZXdgIG1vZGVsIGNhbiBhbHNvIGJlIHVzZWQgdG9cbiAgICogW2dlbmVyYXRlIGF1ZGlvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYXVkaW8pLiBUbyByZXF1ZXN0IHRoYXRcbiAgICogdGhpcyBtb2RlbCBnZW5lcmF0ZSBib3RoIHRleHQgYW5kIGF1ZGlvIHJlc3BvbnNlcywgeW91IGNhbiB1c2U6XG4gICAqXG4gICAqIGBbXCJ0ZXh0XCIsIFwiYXVkaW9cIl1gXG4gICAqL1xuICBtb2RhbGl0aWVzPzogQXJyYXk8Q2hhdENvbXBsZXRpb25Nb2RhbGl0eT4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBIb3cgbWFueSBjaGF0IGNvbXBsZXRpb24gY2hvaWNlcyB0byBnZW5lcmF0ZSBmb3IgZWFjaCBpbnB1dCBtZXNzYWdlLiBOb3RlIHRoYXRcbiAgICogeW91IHdpbGwgYmUgY2hhcmdlZCBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIGdlbmVyYXRlZCB0b2tlbnMgYWNyb3NzIGFsbCBvZiB0aGVcbiAgICogY2hvaWNlcy4gS2VlcCBgbmAgYXMgYDFgIHRvIG1pbmltaXplIGNvc3RzLlxuICAgKi9cbiAgbj86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlXG4gICAqIFtwYXJhbGxlbCBmdW5jdGlvbiBjYWxsaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZnVuY3Rpb24tY2FsbGluZyNjb25maWd1cmluZy1wYXJhbGxlbC1mdW5jdGlvbi1jYWxsaW5nKVxuICAgKiBkdXJpbmcgdG9vbCB1c2UuXG4gICAqL1xuICBwYXJhbGxlbF90b29sX2NhbGxzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogU3RhdGljIHByZWRpY3RlZCBvdXRwdXQgY29udGVudCwgc3VjaCBhcyB0aGUgY29udGVudCBvZiBhIHRleHQgZmlsZSB0aGF0IGlzXG4gICAqIGJlaW5nIHJlZ2VuZXJhdGVkLlxuICAgKi9cbiAgcHJlZGljdGlvbj86IENoYXRDb21wbGV0aW9uUHJlZGljdGlvbkNvbnRlbnQgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgYmV0d2VlbiAtMi4wIGFuZCAyLjAuIFBvc2l0aXZlIHZhbHVlcyBwZW5hbGl6ZSBuZXcgdG9rZW5zIGJhc2VkIG9uXG4gICAqIHdoZXRoZXIgdGhleSBhcHBlYXIgaW4gdGhlIHRleHQgc28gZmFyLCBpbmNyZWFzaW5nIHRoZSBtb2RlbCdzIGxpa2VsaWhvb2QgdG9cbiAgICogdGFsayBhYm91dCBuZXcgdG9waWNzLlxuICAgKi9cbiAgcHJlc2VuY2VfcGVuYWx0eT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqICoqbzEgbW9kZWxzIG9ubHkqKlxuICAgKlxuICAgKiBDb25zdHJhaW5zIGVmZm9ydCBvbiByZWFzb25pbmcgZm9yXG4gICAqIFtyZWFzb25pbmcgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvcmVhc29uaW5nKS4gQ3VycmVudGx5XG4gICAqIHN1cHBvcnRlZCB2YWx1ZXMgYXJlIGBsb3dgLCBgbWVkaXVtYCwgYW5kIGBoaWdoYC4gUmVkdWNpbmcgcmVhc29uaW5nIGVmZm9ydCBjYW5cbiAgICogcmVzdWx0IGluIGZhc3RlciByZXNwb25zZXMgYW5kIGZld2VyIHRva2VucyB1c2VkIG9uIHJlYXNvbmluZyBpbiBhIHJlc3BvbnNlLlxuICAgKi9cbiAgcmVhc29uaW5nX2VmZm9ydD86IENoYXRDb21wbGV0aW9uUmVhc29uaW5nRWZmb3J0O1xuXG4gIC8qKlxuICAgKiBBbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fc2NoZW1hXCIsIFwianNvbl9zY2hlbWFcIjogey4uLn0gfWAgZW5hYmxlcyBTdHJ1Y3R1cmVkXG4gICAqIE91dHB1dHMgd2hpY2ggZW5zdXJlcyB0aGUgbW9kZWwgd2lsbCBtYXRjaCB5b3VyIHN1cHBsaWVkIEpTT04gc2NoZW1hLiBMZWFybiBtb3JlXG4gICAqIGluIHRoZVxuICAgKiBbU3RydWN0dXJlZCBPdXRwdXRzIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc3RydWN0dXJlZC1vdXRwdXRzKS5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBlbnN1cmVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzpcbiAgICB8IFNoYXJlZC5SZXNwb25zZUZvcm1hdFRleHRcbiAgICB8IFNoYXJlZC5SZXNwb25zZUZvcm1hdEpTT05PYmplY3RcbiAgICB8IFNoYXJlZC5SZXNwb25zZUZvcm1hdEpTT05TY2hlbWE7XG5cbiAgLyoqXG4gICAqIFRoaXMgZmVhdHVyZSBpcyBpbiBCZXRhLiBJZiBzcGVjaWZpZWQsIG91ciBzeXN0ZW0gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG9cbiAgICogc2FtcGxlIGRldGVybWluaXN0aWNhbGx5LCBzdWNoIHRoYXQgcmVwZWF0ZWQgcmVxdWVzdHMgd2l0aCB0aGUgc2FtZSBgc2VlZGAgYW5kXG4gICAqIHBhcmFtZXRlcnMgc2hvdWxkIHJldHVybiB0aGUgc2FtZSByZXN1bHQuIERldGVybWluaXNtIGlzIG5vdCBndWFyYW50ZWVkLCBhbmQgeW91XG4gICAqIHNob3VsZCByZWZlciB0byB0aGUgYHN5c3RlbV9maW5nZXJwcmludGAgcmVzcG9uc2UgcGFyYW1ldGVyIHRvIG1vbml0b3IgY2hhbmdlc1xuICAgKiBpbiB0aGUgYmFja2VuZC5cbiAgICovXG4gIHNlZWQ/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGxhdGVuY3kgdGllciB0byB1c2UgZm9yIHByb2Nlc3NpbmcgdGhlIHJlcXVlc3QuIFRoaXMgcGFyYW1ldGVyIGlzXG4gICAqIHJlbGV2YW50IGZvciBjdXN0b21lcnMgc3Vic2NyaWJlZCB0byB0aGUgc2NhbGUgdGllciBzZXJ2aWNlOlxuICAgKlxuICAgKiAtIElmIHNldCB0byAnYXV0bycsIGFuZCB0aGUgUHJvamVjdCBpcyBTY2FsZSB0aWVyIGVuYWJsZWQsIHRoZSBzeXN0ZW0gd2lsbFxuICAgKiAgIHV0aWxpemUgc2NhbGUgdGllciBjcmVkaXRzIHVudGlsIHRoZXkgYXJlIGV4aGF1c3RlZC5cbiAgICogLSBJZiBzZXQgdG8gJ2F1dG8nLCBhbmQgdGhlIFByb2plY3QgaXMgbm90IFNjYWxlIHRpZXIgZW5hYmxlZCwgdGhlIHJlcXVlc3Qgd2lsbFxuICAgKiAgIGJlIHByb2Nlc3NlZCB1c2luZyB0aGUgZGVmYXVsdCBzZXJ2aWNlIHRpZXIgd2l0aCBhIGxvd2VyIHVwdGltZSBTTEEgYW5kIG5vXG4gICAqICAgbGF0ZW5jeSBndWFyZW50ZWUuXG4gICAqIC0gSWYgc2V0IHRvICdkZWZhdWx0JywgdGhlIHJlcXVlc3Qgd2lsbCBiZSBwcm9jZXNzZWQgdXNpbmcgdGhlIGRlZmF1bHQgc2VydmljZVxuICAgKiAgIHRpZXIgd2l0aCBhIGxvd2VyIHVwdGltZSBTTEEgYW5kIG5vIGxhdGVuY3kgZ3VhcmVudGVlLlxuICAgKiAtIFdoZW4gbm90IHNldCwgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgJ2F1dG8nLlxuICAgKlxuICAgKiBXaGVuIHRoaXMgcGFyYW1ldGVyIGlzIHNldCwgdGhlIHJlc3BvbnNlIGJvZHkgd2lsbCBpbmNsdWRlIHRoZSBgc2VydmljZV90aWVyYFxuICAgKiB1dGlsaXplZC5cbiAgICovXG4gIHNlcnZpY2VfdGllcj86ICdhdXRvJyB8ICdkZWZhdWx0JyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFVwIHRvIDQgc2VxdWVuY2VzIHdoZXJlIHRoZSBBUEkgd2lsbCBzdG9wIGdlbmVyYXRpbmcgZnVydGhlciB0b2tlbnMuXG4gICAqL1xuICBzdG9wPzogc3RyaW5nIHwgbnVsbCB8IEFycmF5PHN0cmluZz47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRvIHN0b3JlIHRoZSBvdXRwdXQgb2YgdGhpcyBjaGF0IGNvbXBsZXRpb24gcmVxdWVzdCBmb3IgdXNlIGluXG4gICAqIG91ciBbbW9kZWwgZGlzdGlsbGF0aW9uXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZGlzdGlsbGF0aW9uKVxuICAgKiBvciBbZXZhbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9ldmFscykgcHJvZHVjdHMuXG4gICAqL1xuICBzdG9yZT86IGJvb2xlYW4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJZiBzZXQsIHBhcnRpYWwgbWVzc2FnZSBkZWx0YXMgd2lsbCBiZSBzZW50LCBsaWtlIGluIENoYXRHUFQuIFRva2VucyB3aWxsIGJlXG4gICAqIHNlbnQgYXMgZGF0YS1vbmx5XG4gICAqIFtzZXJ2ZXItc2VudCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2ZXItc2VudF9ldmVudHMvVXNpbmdfc2VydmVyLXNlbnRfZXZlbnRzI0V2ZW50X3N0cmVhbV9mb3JtYXQpXG4gICAqIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSwgd2l0aCB0aGUgc3RyZWFtIHRlcm1pbmF0ZWQgYnkgYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9jb29rYm9vay5vcGVuYWkuY29tL2V4YW1wbGVzL2hvd190b19zdHJlYW1fY29tcGxldGlvbnMpLlxuICAgKi9cbiAgc3RyZWFtPzogYm9vbGVhbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgZm9yIHN0cmVhbWluZyByZXNwb25zZS4gT25seSBzZXQgdGhpcyB3aGVuIHlvdSBzZXQgYHN0cmVhbTogdHJ1ZWAuXG4gICAqL1xuICBzdHJlYW1fb3B0aW9ucz86IENoYXRDb21wbGV0aW9uU3RyZWFtT3B0aW9ucyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoYXQgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdG8gdXNlLCBiZXR3ZWVuIDAgYW5kIDIuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbFxuICAgKiBtYWtlIHRoZSBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZVxuICAgKiBmb2N1c2VkIGFuZCBkZXRlcm1pbmlzdGljLiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgYHRvcF9wYCBidXRcbiAgICogbm90IGJvdGguXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIHdoaWNoIChpZiBhbnkpIHRvb2wgaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC4gYG5vbmVgIG1lYW5zIHRoZSBtb2RlbCB3aWxsXG4gICAqIG5vdCBjYWxsIGFueSB0b29sIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBtZWFucyB0aGUgbW9kZWwgY2FuXG4gICAqIHBpY2sgYmV0d2VlbiBnZW5lcmF0aW5nIGEgbWVzc2FnZSBvciBjYWxsaW5nIG9uZSBvciBtb3JlIHRvb2xzLiBgcmVxdWlyZWRgIG1lYW5zXG4gICAqIHRoZSBtb2RlbCBtdXN0IGNhbGwgb25lIG9yIG1vcmUgdG9vbHMuIFNwZWNpZnlpbmcgYSBwYXJ0aWN1bGFyIHRvb2wgdmlhXG4gICAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gICAqIGNhbGwgdGhhdCB0b29sLlxuICAgKlxuICAgKiBgbm9uZWAgaXMgdGhlIGRlZmF1bHQgd2hlbiBubyB0b29scyBhcmUgcHJlc2VudC4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IGlmIHRvb2xzXG4gICAqIGFyZSBwcmVzZW50LlxuICAgKi9cbiAgdG9vbF9jaG9pY2U/OiBDaGF0Q29tcGxldGlvblRvb2xDaG9pY2VPcHRpb247XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0b29scyB0aGUgbW9kZWwgbWF5IGNhbGwuIEN1cnJlbnRseSwgb25seSBmdW5jdGlvbnMgYXJlIHN1cHBvcnRlZCBhcyBhXG4gICAqIHRvb2wuIFVzZSB0aGlzIHRvIHByb3ZpZGUgYSBsaXN0IG9mIGZ1bmN0aW9ucyB0aGUgbW9kZWwgbWF5IGdlbmVyYXRlIEpTT04gaW5wdXRzXG4gICAqIGZvci4gQSBtYXggb2YgMTI4IGZ1bmN0aW9ucyBhcmUgc3VwcG9ydGVkLlxuICAgKi9cbiAgdG9vbHM/OiBBcnJheTxDaGF0Q29tcGxldGlvblRvb2w+O1xuXG4gIC8qKlxuICAgKiBBbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMjAgc3BlY2lmeWluZyB0aGUgbnVtYmVyIG9mIG1vc3QgbGlrZWx5IHRva2VucyB0b1xuICAgKiByZXR1cm4gYXQgZWFjaCB0b2tlbiBwb3NpdGlvbiwgZWFjaCB3aXRoIGFuIGFzc29jaWF0ZWQgbG9nIHByb2JhYmlsaXR5LlxuICAgKiBgbG9ncHJvYnNgIG11c3QgYmUgc2V0IHRvIGB0cnVlYCBpZiB0aGlzIHBhcmFtZXRlciBpcyB1c2VkLlxuICAgKi9cbiAgdG9wX2xvZ3Byb2JzPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgYHRlbXBlcmF0dXJlYCBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgcmVwcmVzZW50aW5nIHlvdXIgZW5kLXVzZXIsIHdoaWNoIGNhbiBoZWxwIE9wZW5BSSB0byBtb25pdG9yXG4gICAqIGFuZCBkZXRlY3QgYWJ1c2UuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc2FmZXR5LWJlc3QtcHJhY3RpY2VzI2VuZC11c2VyLWlkcykuXG4gICAqL1xuICB1c2VyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLiBNdXN0IGJlIGEteiwgQS1aLCAwLTksIG9yIGNvbnRhaW5cbiAgICAgKiB1bmRlcnNjb3JlcyBhbmQgZGFzaGVzLCB3aXRoIGEgbWF4aW11bSBsZW5ndGggb2YgNjQuXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQSBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoZSBmdW5jdGlvbiBkb2VzLCB1c2VkIGJ5IHRoZSBtb2RlbCB0byBjaG9vc2Ugd2hlbiBhbmRcbiAgICAgKiBob3cgdG8gY2FsbCB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGFyYW1ldGVycyB0aGUgZnVuY3Rpb25zIGFjY2VwdHMsIGRlc2NyaWJlZCBhcyBhIEpTT04gU2NoZW1hIG9iamVjdC4gU2VlIHRoZVxuICAgICAqIFtndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2Z1bmN0aW9uLWNhbGxpbmcpIGZvciBleGFtcGxlcyxcbiAgICAgKiBhbmQgdGhlXG4gICAgICogW0pTT04gU2NoZW1hIHJlZmVyZW5jZV0oaHR0cHM6Ly9qc29uLXNjaGVtYS5vcmcvdW5kZXJzdGFuZGluZy1qc29uLXNjaGVtYS8pIGZvclxuICAgICAqIGRvY3VtZW50YXRpb24gYWJvdXQgdGhlIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIE9taXR0aW5nIGBwYXJhbWV0ZXJzYCBkZWZpbmVzIGEgZnVuY3Rpb24gd2l0aCBhbiBlbXB0eSBwYXJhbWV0ZXIgbGlzdC5cbiAgICAgKi9cbiAgICBwYXJhbWV0ZXJzPzogU2hhcmVkLkZ1bmN0aW9uUGFyYW1ldGVycztcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nID1cbiAgICBDaGF0Q29tcGxldGlvbnNBUEkuQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmc7XG4gIGV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nID0gQ2hhdENvbXBsZXRpb25zQVBJLkNoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyBpbnN0ZWFkXG4gKi9cbmV4cG9ydCB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXMgPSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcztcblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBleHRlbmRzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBJZiBzZXQsIHBhcnRpYWwgbWVzc2FnZSBkZWx0YXMgd2lsbCBiZSBzZW50LCBsaWtlIGluIENoYXRHUFQuIFRva2VucyB3aWxsIGJlXG4gICAqIHNlbnQgYXMgZGF0YS1vbmx5XG4gICAqIFtzZXJ2ZXItc2VudCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2ZXItc2VudF9ldmVudHMvVXNpbmdfc2VydmVyLXNlbnRfZXZlbnRzI0V2ZW50X3N0cmVhbV9mb3JtYXQpXG4gICAqIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSwgd2l0aCB0aGUgc3RyZWFtIHRlcm1pbmF0ZWQgYnkgYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9jb29rYm9vay5vcGVuYWkuY29tL2V4YW1wbGVzL2hvd190b19zdHJlYW1fY29tcGxldGlvbnMpLlxuICAgKi9cbiAgc3RyZWFtPzogZmFsc2UgfCBudWxsO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBpbnN0ZWFkXG4gKi9cbmV4cG9ydCB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgPSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZztcblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBleHRlbmRzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBJZiBzZXQsIHBhcnRpYWwgbWVzc2FnZSBkZWx0YXMgd2lsbCBiZSBzZW50LCBsaWtlIGluIENoYXRHUFQuIFRva2VucyB3aWxsIGJlXG4gICAqIHNlbnQgYXMgZGF0YS1vbmx5XG4gICAqIFtzZXJ2ZXItc2VudCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2ZXItc2VudF9ldmVudHMvVXNpbmdfc2VydmVyLXNlbnRfZXZlbnRzI0V2ZW50X3N0cmVhbV9mb3JtYXQpXG4gICAqIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSwgd2l0aCB0aGUgc3RyZWFtIHRlcm1pbmF0ZWQgYnkgYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9jb29rYm9vay5vcGVuYWkuY29tL2V4YW1wbGVzL2hvd190b19zdHJlYW1fY29tcGxldGlvbnMpLlxuICAgKi9cbiAgc3RyZWFtOiB0cnVlO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBpbnN0ZWFkXG4gKi9cbmV4cG9ydCB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIENvbXBsZXRpb25zIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uIGFzIENoYXRDb21wbGV0aW9uLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkF1ZGlvIGFzIENoYXRDb21wbGV0aW9uQXVkaW8sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkF1ZGlvUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25BdWRpb1BhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25DaHVuayBhcyBDaGF0Q29tcGxldGlvbkNodW5rLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydCBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydEltYWdlIGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbWFnZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbnB1dEF1ZGlvIGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbnB1dEF1ZGlvLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFJlZnVzYWwgYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFJlZnVzYWwsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dCBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0VGV4dCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uRGV2ZWxvcGVyTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uRGV2ZWxvcGVyTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25GdW5jdGlvbkNhbGxPcHRpb24gYXMgQ2hhdENvbXBsZXRpb25GdW5jdGlvbkNhbGxPcHRpb24sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2UgYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCBhcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTW9kYWxpdHkgYXMgQ2hhdENvbXBsZXRpb25Nb2RhbGl0eSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlIGFzIENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25QcmVkaWN0aW9uQ29udGVudCBhcyBDaGF0Q29tcGxldGlvblByZWRpY3Rpb25Db250ZW50LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25SZWFzb25pbmdFZmZvcnQgYXMgQ2hhdENvbXBsZXRpb25SZWFzb25pbmdFZmZvcnQsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblJvbGUgYXMgQ2hhdENvbXBsZXRpb25Sb2xlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25TdHJlYW1PcHRpb25zIGFzIENoYXRDb21wbGV0aW9uU3RyZWFtT3B0aW9ucyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uU3lzdGVtTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uU3lzdGVtTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2IgYXMgQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2IsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblRvb2wgYXMgQ2hhdENvbXBsZXRpb25Ub29sLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sQ2hvaWNlT3B0aW9uIGFzIENoYXRDb21wbGV0aW9uVG9vbENob2ljZU9wdGlvbixcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvblRvb2xNZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblVzZXJNZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25Vc2VyTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ3JlYXRlQ2hhdENvbXBsZXRpb25SZXF1ZXN0TWVzc2FnZSBhcyBDcmVhdGVDaGF0Q29tcGxldGlvblJlcXVlc3RNZXNzYWdlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMgYXMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIGFzIENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBhcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGFzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICAgIHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBhcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgQ29tcGxldGlvbnNBUEkgZnJvbSAnLi9jb21wbGV0aW9ucyc7XG5pbXBvcnQge1xuICBDaGF0Q29tcGxldGlvbixcbiAgQ2hhdENvbXBsZXRpb25Bc3Npc3RhbnRNZXNzYWdlUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uQXVkaW8sXG4gIENoYXRDb21wbGV0aW9uQXVkaW9QYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25DaHVuayxcbiAgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydCxcbiAgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydEltYWdlLFxuICBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW5wdXRBdWRpbyxcbiAgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFJlZnVzYWwsXG4gIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0LFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICBDaGF0Q29tcGxldGlvbkRldmVsb3Blck1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25GdW5jdGlvbkNhbGxPcHRpb24sXG4gIENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uTWVzc2FnZSxcbiAgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsLFxuICBDaGF0Q29tcGxldGlvbk1vZGFsaXR5LFxuICBDaGF0Q29tcGxldGlvbk5hbWVkVG9vbENob2ljZSxcbiAgQ2hhdENvbXBsZXRpb25QcmVkaWN0aW9uQ29udGVudCxcbiAgQ2hhdENvbXBsZXRpb25SZWFzb25pbmdFZmZvcnQsXG4gIENoYXRDb21wbGV0aW9uUm9sZSxcbiAgQ2hhdENvbXBsZXRpb25TdHJlYW1PcHRpb25zLFxuICBDaGF0Q29tcGxldGlvblN5c3RlbU1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2IsXG4gIENoYXRDb21wbGV0aW9uVG9vbCxcbiAgQ2hhdENvbXBsZXRpb25Ub29sQ2hvaWNlT3B0aW9uLFxuICBDaGF0Q29tcGxldGlvblRvb2xNZXNzYWdlUGFyYW0sXG4gIENoYXRDb21wbGV0aW9uVXNlck1lc3NhZ2VQYXJhbSxcbiAgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgQ29tcGxldGlvbnMsXG4gIENyZWF0ZUNoYXRDb21wbGV0aW9uUmVxdWVzdE1lc3NhZ2UsXG59IGZyb20gJy4vY29tcGxldGlvbnMnO1xuXG5leHBvcnQgY2xhc3MgQ2hhdCBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgY29tcGxldGlvbnM6IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zID0gbmV3IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zKHRoaXMuX2NsaWVudCk7XG59XG5cbmV4cG9ydCB0eXBlIENoYXRNb2RlbCA9XG4gIHwgJ28xJ1xuICB8ICdvMS0yMDI0LTEyLTE3J1xuICB8ICdvMS1wcmV2aWV3J1xuICB8ICdvMS1wcmV2aWV3LTIwMjQtMDktMTInXG4gIHwgJ28xLW1pbmknXG4gIHwgJ28xLW1pbmktMjAyNC0wOS0xMidcbiAgfCAnZ3B0LTRvJ1xuICB8ICdncHQtNG8tMjAyNC0xMS0yMCdcbiAgfCAnZ3B0LTRvLTIwMjQtMDgtMDYnXG4gIHwgJ2dwdC00by0yMDI0LTA1LTEzJ1xuICB8ICdncHQtNG8tYXVkaW8tcHJldmlldydcbiAgfCAnZ3B0LTRvLWF1ZGlvLXByZXZpZXctMjAyNC0xMC0wMSdcbiAgfCAnZ3B0LTRvLWF1ZGlvLXByZXZpZXctMjAyNC0xMi0xNydcbiAgfCAnZ3B0LTRvLW1pbmktYXVkaW8tcHJldmlldydcbiAgfCAnZ3B0LTRvLW1pbmktYXVkaW8tcHJldmlldy0yMDI0LTEyLTE3J1xuICB8ICdjaGF0Z3B0LTRvLWxhdGVzdCdcbiAgfCAnZ3B0LTRvLW1pbmknXG4gIHwgJ2dwdC00by1taW5pLTIwMjQtMDctMTgnXG4gIHwgJ2dwdC00LXR1cmJvJ1xuICB8ICdncHQtNC10dXJiby0yMDI0LTA0LTA5J1xuICB8ICdncHQtNC0wMTI1LXByZXZpZXcnXG4gIHwgJ2dwdC00LXR1cmJvLXByZXZpZXcnXG4gIHwgJ2dwdC00LTExMDYtcHJldmlldydcbiAgfCAnZ3B0LTQtdmlzaW9uLXByZXZpZXcnXG4gIHwgJ2dwdC00J1xuICB8ICdncHQtNC0wMzE0J1xuICB8ICdncHQtNC0wNjEzJ1xuICB8ICdncHQtNC0zMmsnXG4gIHwgJ2dwdC00LTMyay0wMzE0J1xuICB8ICdncHQtNC0zMmstMDYxMydcbiAgfCAnZ3B0LTMuNS10dXJibydcbiAgfCAnZ3B0LTMuNS10dXJiby0xNmsnXG4gIHwgJ2dwdC0zLjUtdHVyYm8tMDMwMSdcbiAgfCAnZ3B0LTMuNS10dXJiby0wNjEzJ1xuICB8ICdncHQtMy41LXR1cmJvLTExMDYnXG4gIHwgJ2dwdC0zLjUtdHVyYm8tMDEyNSdcbiAgfCAnZ3B0LTMuNS10dXJiby0xNmstMDYxMyc7XG5cbkNoYXQuQ29tcGxldGlvbnMgPSBDb21wbGV0aW9ucztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIENoYXQge1xuICBleHBvcnQgeyB0eXBlIENoYXRNb2RlbCBhcyBDaGF0TW9kZWwgfTtcblxuICBleHBvcnQge1xuICAgIENvbXBsZXRpb25zIGFzIENvbXBsZXRpb25zLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb24gYXMgQ2hhdENvbXBsZXRpb24sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQXVkaW8gYXMgQ2hhdENvbXBsZXRpb25BdWRpbyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQXVkaW9QYXJhbSBhcyBDaGF0Q29tcGxldGlvbkF1ZGlvUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNodW5rIGFzIENoYXRDb21wbGV0aW9uQ2h1bmssXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0IGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnQsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2UgYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydEltYWdlLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydElucHV0QXVkaW8gYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydElucHV0QXVkaW8sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0UmVmdXNhbCBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0UmVmdXNhbCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0IGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRUZXh0LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25EZXZlbG9wZXJNZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25EZXZlbG9wZXJNZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uQ2FsbE9wdGlvbiBhcyBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uQ2FsbE9wdGlvbixcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25GdW5jdGlvbk1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZSBhcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2UsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsIGFzIENoYXRDb21wbGV0aW9uTWVzc2FnZVRvb2xDYWxsLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Nb2RhbGl0eSBhcyBDaGF0Q29tcGxldGlvbk1vZGFsaXR5LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25OYW1lZFRvb2xDaG9pY2UgYXMgQ2hhdENvbXBsZXRpb25OYW1lZFRvb2xDaG9pY2UsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblByZWRpY3Rpb25Db250ZW50IGFzIENoYXRDb21wbGV0aW9uUHJlZGljdGlvbkNvbnRlbnQsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblJlYXNvbmluZ0VmZm9ydCBhcyBDaGF0Q29tcGxldGlvblJlYXNvbmluZ0VmZm9ydCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uUm9sZSBhcyBDaGF0Q29tcGxldGlvblJvbGUsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblN0cmVhbU9wdGlvbnMgYXMgQ2hhdENvbXBsZXRpb25TdHJlYW1PcHRpb25zLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25TeXN0ZW1NZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25TeXN0ZW1NZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYiBhcyBDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYixcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVG9vbCBhcyBDaGF0Q29tcGxldGlvblRvb2wsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblRvb2xDaG9pY2VPcHRpb24gYXMgQ2hhdENvbXBsZXRpb25Ub29sQ2hvaWNlT3B0aW9uLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVXNlck1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvblVzZXJNZXNzYWdlUGFyYW0sXG4gICAgdHlwZSBDcmVhdGVDaGF0Q29tcGxldGlvblJlcXVlc3RNZXNzYWdlIGFzIENyZWF0ZUNoYXRDb21wbGV0aW9uUmVxdWVzdE1lc3NhZ2UsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyBhcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXMgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGFzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBhcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgYXMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gICAgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGFzIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uL2NvcmUnO1xuaW1wb3J0IHsgdHlwZSBSZXNwb25zZSB9IGZyb20gJy4uLy4uL19zaGltcy9pbmRleCc7XG5cbmV4cG9ydCBjbGFzcyBTcGVlY2ggZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYXVkaW8gZnJvbSB0aGUgaW5wdXQgdGV4dC5cbiAgICovXG4gIGNyZWF0ZShib2R5OiBTcGVlY2hDcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvYXVkaW8vc3BlZWNoJywge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgIF9fYmluYXJ5UmVzcG9uc2U6IHRydWUsXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgU3BlZWNoTW9kZWwgPSAndHRzLTEnIHwgJ3R0cy0xLWhkJztcblxuZXhwb3J0IGludGVyZmFjZSBTcGVlY2hDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIHRleHQgdG8gZ2VuZXJhdGUgYXVkaW8gZm9yLiBUaGUgbWF4aW11bSBsZW5ndGggaXMgNDA5NiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgaW5wdXQ6IHN0cmluZztcblxuICAvKipcbiAgICogT25lIG9mIHRoZSBhdmFpbGFibGUgW1RUUyBtb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyN0dHMpOlxuICAgKiBgdHRzLTFgIG9yIGB0dHMtMS1oZGBcbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgU3BlZWNoTW9kZWw7XG5cbiAgLyoqXG4gICAqIFRoZSB2b2ljZSB0byB1c2Ugd2hlbiBnZW5lcmF0aW5nIHRoZSBhdWRpby4gU3VwcG9ydGVkIHZvaWNlcyBhcmUgYGFsbG95YCxcbiAgICogYGVjaG9gLCBgZmFibGVgLCBgb255eGAsIGBub3ZhYCwgYW5kIGBzaGltbWVyYC4gUHJldmlld3Mgb2YgdGhlIHZvaWNlcyBhcmVcbiAgICogYXZhaWxhYmxlIGluIHRoZVxuICAgKiBbVGV4dCB0byBzcGVlY2ggZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy90ZXh0LXRvLXNwZWVjaCN2b2ljZS1vcHRpb25zKS5cbiAgICovXG4gIHZvaWNlOiAnYWxsb3knIHwgJ2VjaG8nIHwgJ2ZhYmxlJyB8ICdvbnl4JyB8ICdub3ZhJyB8ICdzaGltbWVyJztcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCB0byBhdWRpbyBpbi4gU3VwcG9ydGVkIGZvcm1hdHMgYXJlIGBtcDNgLCBgb3B1c2AsIGBhYWNgLCBgZmxhY2AsXG4gICAqIGB3YXZgLCBhbmQgYHBjbWAuXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiAnbXAzJyB8ICdvcHVzJyB8ICdhYWMnIHwgJ2ZsYWMnIHwgJ3dhdicgfCAncGNtJztcblxuICAvKipcbiAgICogVGhlIHNwZWVkIG9mIHRoZSBnZW5lcmF0ZWQgYXVkaW8uIFNlbGVjdCBhIHZhbHVlIGZyb20gYDAuMjVgIHRvIGA0LjBgLiBgMS4wYCBpc1xuICAgKiB0aGUgZGVmYXVsdC5cbiAgICovXG4gIHNwZWVkPzogbnVtYmVyO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgU3BlZWNoIHtcbiAgZXhwb3J0IHsgdHlwZSBTcGVlY2hNb2RlbCBhcyBTcGVlY2hNb2RlbCwgdHlwZSBTcGVlY2hDcmVhdGVQYXJhbXMgYXMgU3BlZWNoQ3JlYXRlUGFyYW1zIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQXVkaW9BUEkgZnJvbSAnLi9hdWRpbyc7XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2NyaXB0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFRyYW5zY3JpYmVzIGF1ZGlvIGludG8gdGhlIGlucHV0IGxhbmd1YWdlLlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIGJvZHk6IFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXM8J2pzb24nIHwgdW5kZWZpbmVkPixcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFRyYW5zY3JpcHRpb24+O1xuICBjcmVhdGUoXG4gICAgYm9keTogVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtczwndmVyYm9zZV9qc29uJz4sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxUcmFuc2NyaXB0aW9uVmVyYm9zZT47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zPCdzcnQnIHwgJ3Z0dCcgfCAndGV4dCc+LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8c3RyaW5nPjtcbiAgY3JlYXRlKGJvZHk6IFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFRyYW5zY3JpcHRpb24+O1xuICBjcmVhdGUoXG4gICAgYm9keTogVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFRyYW5zY3JpcHRpb25DcmVhdGVSZXNwb25zZSB8IHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2F1ZGlvL3RyYW5zY3JpcHRpb25zJywgQ29yZS5tdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0cmFuc2NyaXB0aW9uIHJlc3BvbnNlIHJldHVybmVkIGJ5IG1vZGVsLCBiYXNlZCBvbiB0aGUgcHJvdmlkZWRcbiAqIGlucHV0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zY3JpcHRpb24ge1xuICAvKipcbiAgICogVGhlIHRyYW5zY3JpYmVkIHRleHQuXG4gICAqL1xuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNjcmlwdGlvblNlZ21lbnQge1xuICAvKipcbiAgICogVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHNlZ21lbnQuXG4gICAqL1xuICBpZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBdmVyYWdlIGxvZ3Byb2Igb2YgdGhlIHNlZ21lbnQuIElmIHRoZSB2YWx1ZSBpcyBsb3dlciB0aGFuIC0xLCBjb25zaWRlciB0aGVcbiAgICogbG9ncHJvYnMgZmFpbGVkLlxuICAgKi9cbiAgYXZnX2xvZ3Byb2I6IG51bWJlcjtcblxuICAvKipcbiAgICogQ29tcHJlc3Npb24gcmF0aW8gb2YgdGhlIHNlZ21lbnQuIElmIHRoZSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gMi40LCBjb25zaWRlciB0aGVcbiAgICogY29tcHJlc3Npb24gZmFpbGVkLlxuICAgKi9cbiAgY29tcHJlc3Npb25fcmF0aW86IG51bWJlcjtcblxuICAvKipcbiAgICogRW5kIHRpbWUgb2YgdGhlIHNlZ21lbnQgaW4gc2Vjb25kcy5cbiAgICovXG4gIGVuZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBQcm9iYWJpbGl0eSBvZiBubyBzcGVlY2ggaW4gdGhlIHNlZ21lbnQuIElmIHRoZSB2YWx1ZSBpcyBoaWdoZXIgdGhhbiAxLjAgYW5kIHRoZVxuICAgKiBgYXZnX2xvZ3Byb2JgIGlzIGJlbG93IC0xLCBjb25zaWRlciB0aGlzIHNlZ21lbnQgc2lsZW50LlxuICAgKi9cbiAgbm9fc3BlZWNoX3Byb2I6IG51bWJlcjtcblxuICAvKipcbiAgICogU2VlayBvZmZzZXQgb2YgdGhlIHNlZ21lbnQuXG4gICAqL1xuICBzZWVrOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRpbWUgb2YgdGhlIHNlZ21lbnQgaW4gc2Vjb25kcy5cbiAgICovXG4gIHN0YXJ0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRlbXBlcmF0dXJlIHBhcmFtZXRlciB1c2VkIGZvciBnZW5lcmF0aW5nIHRoZSBzZWdtZW50LlxuICAgKi9cbiAgdGVtcGVyYXR1cmU6IG51bWJlcjtcblxuICAvKipcbiAgICogVGV4dCBjb250ZW50IG9mIHRoZSBzZWdtZW50LlxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBcnJheSBvZiB0b2tlbiBJRHMgZm9yIHRoZSB0ZXh0IGNvbnRlbnQuXG4gICAqL1xuICB0b2tlbnM6IEFycmF5PG51bWJlcj47XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHZlcmJvc2UganNvbiB0cmFuc2NyaXB0aW9uIHJlc3BvbnNlIHJldHVybmVkIGJ5IG1vZGVsLCBiYXNlZCBvbiB0aGVcbiAqIHByb3ZpZGVkIGlucHV0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zY3JpcHRpb25WZXJib3NlIHtcbiAgLyoqXG4gICAqIFRoZSBkdXJhdGlvbiBvZiB0aGUgaW5wdXQgYXVkaW8uXG4gICAqL1xuICBkdXJhdGlvbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbGFuZ3VhZ2Ugb2YgdGhlIGlucHV0IGF1ZGlvLlxuICAgKi9cbiAgbGFuZ3VhZ2U6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHRyYW5zY3JpYmVkIHRleHQuXG4gICAqL1xuICB0ZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNlZ21lbnRzIG9mIHRoZSB0cmFuc2NyaWJlZCB0ZXh0IGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIGRldGFpbHMuXG4gICAqL1xuICBzZWdtZW50cz86IEFycmF5PFRyYW5zY3JpcHRpb25TZWdtZW50PjtcblxuICAvKipcbiAgICogRXh0cmFjdGVkIHdvcmRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHRpbWVzdGFtcHMuXG4gICAqL1xuICB3b3Jkcz86IEFycmF5PFRyYW5zY3JpcHRpb25Xb3JkPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2NyaXB0aW9uV29yZCB7XG4gIC8qKlxuICAgKiBFbmQgdGltZSBvZiB0aGUgd29yZCBpbiBzZWNvbmRzLlxuICAgKi9cbiAgZW5kOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRpbWUgb2YgdGhlIHdvcmQgaW4gc2Vjb25kcy5cbiAgICovXG4gIHN0YXJ0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIHdvcmQuXG4gICAqL1xuICB3b3JkOiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRyYW5zY3JpcHRpb24gcmVzcG9uc2UgcmV0dXJuZWQgYnkgbW9kZWwsIGJhc2VkIG9uIHRoZSBwcm92aWRlZFxuICogaW5wdXQuXG4gKi9cbmV4cG9ydCB0eXBlIFRyYW5zY3JpcHRpb25DcmVhdGVSZXNwb25zZSA9IFRyYW5zY3JpcHRpb24gfCBUcmFuc2NyaXB0aW9uVmVyYm9zZTtcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zPFxuICBSZXNwb25zZUZvcm1hdCBleHRlbmRzIEF1ZGlvQVBJLkF1ZGlvUmVzcG9uc2VGb3JtYXQgfCB1bmRlZmluZWQgPSBBdWRpb0FQSS5BdWRpb1Jlc3BvbnNlRm9ybWF0IHwgdW5kZWZpbmVkLFxuPiB7XG4gIC8qKlxuICAgKiBUaGUgYXVkaW8gZmlsZSBvYmplY3QgKG5vdCBmaWxlIG5hbWUpIHRvIHRyYW5zY3JpYmUsIGluIG9uZSBvZiB0aGVzZSBmb3JtYXRzOlxuICAgKiBmbGFjLCBtcDMsIG1wNCwgbXBlZywgbXBnYSwgbTRhLCBvZ2csIHdhdiwgb3Igd2VibS5cbiAgICovXG4gIGZpbGU6IENvcmUuVXBsb2FkYWJsZTtcblxuICAvKipcbiAgICogSUQgb2YgdGhlIG1vZGVsIHRvIHVzZS4gT25seSBgd2hpc3Blci0xYCAod2hpY2ggaXMgcG93ZXJlZCBieSBvdXIgb3BlbiBzb3VyY2VcbiAgICogV2hpc3BlciBWMiBtb2RlbCkgaXMgY3VycmVudGx5IGF2YWlsYWJsZS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgQXVkaW9BUEkuQXVkaW9Nb2RlbDtcblxuICAvKipcbiAgICogVGhlIGxhbmd1YWdlIG9mIHRoZSBpbnB1dCBhdWRpby4gU3VwcGx5aW5nIHRoZSBpbnB1dCBsYW5ndWFnZSBpblxuICAgKiBbSVNPLTYzOS0xXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX0lTT182MzktMV9jb2RlcykgZm9ybWF0IHdpbGxcbiAgICogaW1wcm92ZSBhY2N1cmFjeSBhbmQgbGF0ZW5jeS5cbiAgICovXG4gIGxhbmd1YWdlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCB0ZXh0IHRvIGd1aWRlIHRoZSBtb2RlbCdzIHN0eWxlIG9yIGNvbnRpbnVlIGEgcHJldmlvdXMgYXVkaW9cbiAgICogc2VnbWVudC4gVGhlXG4gICAqIFtwcm9tcHRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zcGVlY2gtdG8tdGV4dCNwcm9tcHRpbmcpXG4gICAqIHNob3VsZCBtYXRjaCB0aGUgYXVkaW8gbGFuZ3VhZ2UuXG4gICAqL1xuICBwcm9tcHQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCwgaW4gb25lIG9mIHRoZXNlIG9wdGlvbnM6IGBqc29uYCwgYHRleHRgLCBgc3J0YCxcbiAgICogYHZlcmJvc2VfanNvbmAsIG9yIGB2dHRgLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogUmVzcG9uc2VGb3JtYXQ7XG5cbiAgLyoqXG4gICAqIFRoZSBzYW1wbGluZyB0ZW1wZXJhdHVyZSwgYmV0d2VlbiAwIGFuZCAxLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGwgbWFrZSB0aGVcbiAgICogb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmUgZm9jdXNlZCBhbmRcbiAgICogZGV0ZXJtaW5pc3RpYy4gSWYgc2V0IHRvIDAsIHRoZSBtb2RlbCB3aWxsIHVzZVxuICAgKiBbbG9nIHByb2JhYmlsaXR5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Mb2dfcHJvYmFiaWxpdHkpIHRvXG4gICAqIGF1dG9tYXRpY2FsbHkgaW5jcmVhc2UgdGhlIHRlbXBlcmF0dXJlIHVudGlsIGNlcnRhaW4gdGhyZXNob2xkcyBhcmUgaGl0LlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lc3RhbXAgZ3JhbnVsYXJpdGllcyB0byBwb3B1bGF0ZSBmb3IgdGhpcyB0cmFuc2NyaXB0aW9uLlxuICAgKiBgcmVzcG9uc2VfZm9ybWF0YCBtdXN0IGJlIHNldCBgdmVyYm9zZV9qc29uYCB0byB1c2UgdGltZXN0YW1wIGdyYW51bGFyaXRpZXMuXG4gICAqIEVpdGhlciBvciBib3RoIG9mIHRoZXNlIG9wdGlvbnMgYXJlIHN1cHBvcnRlZDogYHdvcmRgLCBvciBgc2VnbWVudGAuIE5vdGU6IFRoZXJlXG4gICAqIGlzIG5vIGFkZGl0aW9uYWwgbGF0ZW5jeSBmb3Igc2VnbWVudCB0aW1lc3RhbXBzLCBidXQgZ2VuZXJhdGluZyB3b3JkIHRpbWVzdGFtcHNcbiAgICogaW5jdXJzIGFkZGl0aW9uYWwgbGF0ZW5jeS5cbiAgICovXG4gIHRpbWVzdGFtcF9ncmFudWxhcml0aWVzPzogQXJyYXk8J3dvcmQnIHwgJ3NlZ21lbnQnPjtcbn1cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFRyYW5zY3JpcHRpb25zIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIFRyYW5zY3JpcHRpb24gYXMgVHJhbnNjcmlwdGlvbixcbiAgICB0eXBlIFRyYW5zY3JpcHRpb25TZWdtZW50IGFzIFRyYW5zY3JpcHRpb25TZWdtZW50LFxuICAgIHR5cGUgVHJhbnNjcmlwdGlvblZlcmJvc2UgYXMgVHJhbnNjcmlwdGlvblZlcmJvc2UsXG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uV29yZCBhcyBUcmFuc2NyaXB0aW9uV29yZCxcbiAgICB0eXBlIFRyYW5zY3JpcHRpb25DcmVhdGVSZXNwb25zZSBhcyBUcmFuc2NyaXB0aW9uQ3JlYXRlUmVzcG9uc2UsXG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zIGFzIFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQXVkaW9BUEkgZnJvbSAnLi9hdWRpbyc7XG5pbXBvcnQgKiBhcyBUcmFuc2NyaXB0aW9uc0FQSSBmcm9tICcuL3RyYW5zY3JpcHRpb25zJztcblxuZXhwb3J0IGNsYXNzIFRyYW5zbGF0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFRyYW5zbGF0ZXMgYXVkaW8gaW50byBFbmdsaXNoLlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIGJvZHk6IFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zPCdqc29uJyB8IHVuZGVmaW5lZD4sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxUcmFuc2xhdGlvbj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtczwndmVyYm9zZV9qc29uJz4sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxUcmFuc2xhdGlvblZlcmJvc2U+O1xuICBjcmVhdGUoXG4gICAgYm9keTogVHJhbnNsYXRpb25DcmVhdGVQYXJhbXM8J3RleHQnIHwgJ3NydCcgfCAndnR0Jz4sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxzdHJpbmc+O1xuICBjcmVhdGUoYm9keTogVHJhbnNsYXRpb25DcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFRyYW5zbGF0aW9uPjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VHJhbnNsYXRpb25DcmVhdGVSZXNwb25zZSB8IHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2F1ZGlvL3RyYW5zbGF0aW9ucycsIENvcmUubXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zKHsgYm9keSwgLi4ub3B0aW9ucyB9KSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xhdGlvbiB7XG4gIHRleHQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xhdGlvblZlcmJvc2Uge1xuICAvKipcbiAgICogVGhlIGR1cmF0aW9uIG9mIHRoZSBpbnB1dCBhdWRpby5cbiAgICovXG4gIGR1cmF0aW9uOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBsYW5ndWFnZSBvZiB0aGUgb3V0cHV0IHRyYW5zbGF0aW9uIChhbHdheXMgYGVuZ2xpc2hgKS5cbiAgICovXG4gIGxhbmd1YWdlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0cmFuc2xhdGVkIHRleHQuXG4gICAqL1xuICB0ZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNlZ21lbnRzIG9mIHRoZSB0cmFuc2xhdGVkIHRleHQgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgZGV0YWlscy5cbiAgICovXG4gIHNlZ21lbnRzPzogQXJyYXk8VHJhbnNjcmlwdGlvbnNBUEkuVHJhbnNjcmlwdGlvblNlZ21lbnQ+O1xufVxuXG5leHBvcnQgdHlwZSBUcmFuc2xhdGlvbkNyZWF0ZVJlc3BvbnNlID0gVHJhbnNsYXRpb24gfCBUcmFuc2xhdGlvblZlcmJvc2U7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNsYXRpb25DcmVhdGVQYXJhbXM8XG4gIFJlc3BvbnNlRm9ybWF0IGV4dGVuZHMgQXVkaW9BUEkuQXVkaW9SZXNwb25zZUZvcm1hdCB8IHVuZGVmaW5lZCA9IEF1ZGlvQVBJLkF1ZGlvUmVzcG9uc2VGb3JtYXQgfCB1bmRlZmluZWQsXG4+IHtcbiAgLyoqXG4gICAqIFRoZSBhdWRpbyBmaWxlIG9iamVjdCAobm90IGZpbGUgbmFtZSkgdHJhbnNsYXRlLCBpbiBvbmUgb2YgdGhlc2UgZm9ybWF0czogZmxhYyxcbiAgICogbXAzLCBtcDQsIG1wZWcsIG1wZ2EsIG00YSwgb2dnLCB3YXYsIG9yIHdlYm0uXG4gICAqL1xuICBmaWxlOiBDb3JlLlVwbG9hZGFibGU7XG5cbiAgLyoqXG4gICAqIElEIG9mIHRoZSBtb2RlbCB0byB1c2UuIE9ubHkgYHdoaXNwZXItMWAgKHdoaWNoIGlzIHBvd2VyZWQgYnkgb3VyIG9wZW4gc291cmNlXG4gICAqIFdoaXNwZXIgVjIgbW9kZWwpIGlzIGN1cnJlbnRseSBhdmFpbGFibGUuXG4gICAqL1xuICBtb2RlbDogKHN0cmluZyAmIHt9KSB8IEF1ZGlvQVBJLkF1ZGlvTW9kZWw7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIHRleHQgdG8gZ3VpZGUgdGhlIG1vZGVsJ3Mgc3R5bGUgb3IgY29udGludWUgYSBwcmV2aW91cyBhdWRpb1xuICAgKiBzZWdtZW50LiBUaGVcbiAgICogW3Byb21wdF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3NwZWVjaC10by10ZXh0I3Byb21wdGluZylcbiAgICogc2hvdWxkIGJlIGluIEVuZ2xpc2guXG4gICAqL1xuICBwcm9tcHQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCwgaW4gb25lIG9mIHRoZXNlIG9wdGlvbnM6IGBqc29uYCwgYHRleHRgLCBgc3J0YCxcbiAgICogYHZlcmJvc2VfanNvbmAsIG9yIGB2dHRgLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogUmVzcG9uc2VGb3JtYXQ7XG5cbiAgLyoqXG4gICAqIFRoZSBzYW1wbGluZyB0ZW1wZXJhdHVyZSwgYmV0d2VlbiAwIGFuZCAxLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGwgbWFrZSB0aGVcbiAgICogb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmUgZm9jdXNlZCBhbmRcbiAgICogZGV0ZXJtaW5pc3RpYy4gSWYgc2V0IHRvIDAsIHRoZSBtb2RlbCB3aWxsIHVzZVxuICAgKiBbbG9nIHByb2JhYmlsaXR5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Mb2dfcHJvYmFiaWxpdHkpIHRvXG4gICAqIGF1dG9tYXRpY2FsbHkgaW5jcmVhc2UgdGhlIHRlbXBlcmF0dXJlIHVudGlsIGNlcnRhaW4gdGhyZXNob2xkcyBhcmUgaGl0LlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBUcmFuc2xhdGlvbnMge1xuICBleHBvcnQge1xuICAgIHR5cGUgVHJhbnNsYXRpb24gYXMgVHJhbnNsYXRpb24sXG4gICAgdHlwZSBUcmFuc2xhdGlvblZlcmJvc2UgYXMgVHJhbnNsYXRpb25WZXJib3NlLFxuICAgIHR5cGUgVHJhbnNsYXRpb25DcmVhdGVSZXNwb25zZSBhcyBUcmFuc2xhdGlvbkNyZWF0ZVJlc3BvbnNlLFxuICAgIHR5cGUgVHJhbnNsYXRpb25DcmVhdGVQYXJhbXMgYXMgVHJhbnNsYXRpb25DcmVhdGVQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBTcGVlY2hBUEkgZnJvbSAnLi9zcGVlY2gnO1xuaW1wb3J0IHsgU3BlZWNoLCBTcGVlY2hDcmVhdGVQYXJhbXMsIFNwZWVjaE1vZGVsIH0gZnJvbSAnLi9zcGVlY2gnO1xuaW1wb3J0ICogYXMgVHJhbnNjcmlwdGlvbnNBUEkgZnJvbSAnLi90cmFuc2NyaXB0aW9ucyc7XG5pbXBvcnQge1xuICBUcmFuc2NyaXB0aW9uLFxuICBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zLFxuICBUcmFuc2NyaXB0aW9uQ3JlYXRlUmVzcG9uc2UsXG4gIFRyYW5zY3JpcHRpb25TZWdtZW50LFxuICBUcmFuc2NyaXB0aW9uVmVyYm9zZSxcbiAgVHJhbnNjcmlwdGlvbldvcmQsXG4gIFRyYW5zY3JpcHRpb25zLFxufSBmcm9tICcuL3RyYW5zY3JpcHRpb25zJztcbmltcG9ydCAqIGFzIFRyYW5zbGF0aW9uc0FQSSBmcm9tICcuL3RyYW5zbGF0aW9ucyc7XG5pbXBvcnQge1xuICBUcmFuc2xhdGlvbixcbiAgVHJhbnNsYXRpb25DcmVhdGVQYXJhbXMsXG4gIFRyYW5zbGF0aW9uQ3JlYXRlUmVzcG9uc2UsXG4gIFRyYW5zbGF0aW9uVmVyYm9zZSxcbiAgVHJhbnNsYXRpb25zLFxufSBmcm9tICcuL3RyYW5zbGF0aW9ucyc7XG5cbmV4cG9ydCBjbGFzcyBBdWRpbyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgdHJhbnNjcmlwdGlvbnM6IFRyYW5zY3JpcHRpb25zQVBJLlRyYW5zY3JpcHRpb25zID0gbmV3IFRyYW5zY3JpcHRpb25zQVBJLlRyYW5zY3JpcHRpb25zKHRoaXMuX2NsaWVudCk7XG4gIHRyYW5zbGF0aW9uczogVHJhbnNsYXRpb25zQVBJLlRyYW5zbGF0aW9ucyA9IG5ldyBUcmFuc2xhdGlvbnNBUEkuVHJhbnNsYXRpb25zKHRoaXMuX2NsaWVudCk7XG4gIHNwZWVjaDogU3BlZWNoQVBJLlNwZWVjaCA9IG5ldyBTcGVlY2hBUEkuU3BlZWNoKHRoaXMuX2NsaWVudCk7XG59XG5cbmV4cG9ydCB0eXBlIEF1ZGlvTW9kZWwgPSAnd2hpc3Blci0xJztcblxuLyoqXG4gKiBUaGUgZm9ybWF0IG9mIHRoZSBvdXRwdXQsIGluIG9uZSBvZiB0aGVzZSBvcHRpb25zOiBganNvbmAsIGB0ZXh0YCwgYHNydGAsXG4gKiBgdmVyYm9zZV9qc29uYCwgb3IgYHZ0dGAuXG4gKi9cbmV4cG9ydCB0eXBlIEF1ZGlvUmVzcG9uc2VGb3JtYXQgPSAnanNvbicgfCAndGV4dCcgfCAnc3J0JyB8ICd2ZXJib3NlX2pzb24nIHwgJ3Z0dCc7XG5cbkF1ZGlvLlRyYW5zY3JpcHRpb25zID0gVHJhbnNjcmlwdGlvbnM7XG5BdWRpby5UcmFuc2xhdGlvbnMgPSBUcmFuc2xhdGlvbnM7XG5BdWRpby5TcGVlY2ggPSBTcGVlY2g7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBBdWRpbyB7XG4gIGV4cG9ydCB7IHR5cGUgQXVkaW9Nb2RlbCBhcyBBdWRpb01vZGVsLCB0eXBlIEF1ZGlvUmVzcG9uc2VGb3JtYXQgYXMgQXVkaW9SZXNwb25zZUZvcm1hdCB9O1xuXG4gIGV4cG9ydCB7XG4gICAgVHJhbnNjcmlwdGlvbnMgYXMgVHJhbnNjcmlwdGlvbnMsXG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uIGFzIFRyYW5zY3JpcHRpb24sXG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uU2VnbWVudCBhcyBUcmFuc2NyaXB0aW9uU2VnbWVudCxcbiAgICB0eXBlIFRyYW5zY3JpcHRpb25WZXJib3NlIGFzIFRyYW5zY3JpcHRpb25WZXJib3NlLFxuICAgIHR5cGUgVHJhbnNjcmlwdGlvbldvcmQgYXMgVHJhbnNjcmlwdGlvbldvcmQsXG4gICAgdHlwZSBUcmFuc2NyaXB0aW9uQ3JlYXRlUmVzcG9uc2UgYXMgVHJhbnNjcmlwdGlvbkNyZWF0ZVJlc3BvbnNlLFxuICAgIHR5cGUgVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtcyBhcyBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgVHJhbnNsYXRpb25zIGFzIFRyYW5zbGF0aW9ucyxcbiAgICB0eXBlIFRyYW5zbGF0aW9uIGFzIFRyYW5zbGF0aW9uLFxuICAgIHR5cGUgVHJhbnNsYXRpb25WZXJib3NlIGFzIFRyYW5zbGF0aW9uVmVyYm9zZSxcbiAgICB0eXBlIFRyYW5zbGF0aW9uQ3JlYXRlUmVzcG9uc2UgYXMgVHJhbnNsYXRpb25DcmVhdGVSZXNwb25zZSxcbiAgICB0eXBlIFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zIGFzIFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7IFNwZWVjaCBhcyBTcGVlY2gsIHR5cGUgU3BlZWNoTW9kZWwgYXMgU3BlZWNoTW9kZWwsIHR5cGUgU3BlZWNoQ3JlYXRlUGFyYW1zIGFzIFNwZWVjaENyZWF0ZVBhcmFtcyB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCAqIGFzIEJhdGNoZXNBUEkgZnJvbSAnLi9iYXRjaGVzJztcbmltcG9ydCB7IEN1cnNvclBhZ2UsIHR5cGUgQ3Vyc29yUGFnZVBhcmFtcyB9IGZyb20gJy4uL3BhZ2luYXRpb24nO1xuXG5leHBvcnQgY2xhc3MgQmF0Y2hlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGV4ZWN1dGVzIGEgYmF0Y2ggZnJvbSBhbiB1cGxvYWRlZCBmaWxlIG9mIHJlcXVlc3RzXG4gICAqL1xuICBjcmVhdGUoYm9keTogQmF0Y2hDcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEJhdGNoPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvYmF0Y2hlcycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBiYXRjaC5cbiAgICovXG4gIHJldHJpZXZlKGJhdGNoSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8QmF0Y2g+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL2JhdGNoZXMvJHtiYXRjaElkfWAsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgeW91ciBvcmdhbml6YXRpb24ncyBiYXRjaGVzLlxuICAgKi9cbiAgbGlzdChxdWVyeT86IEJhdGNoTGlzdFBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPEJhdGNoZXNQYWdlLCBCYXRjaD47XG4gIGxpc3Qob3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPEJhdGNoZXNQYWdlLCBCYXRjaD47XG4gIGxpc3QoXG4gICAgcXVlcnk6IEJhdGNoTGlzdFBhcmFtcyB8IENvcmUuUmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxCYXRjaGVzUGFnZSwgQmF0Y2g+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3Qoe30sIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KCcvYmF0Y2hlcycsIEJhdGNoZXNQYWdlLCB7IHF1ZXJ5LCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYW4gaW4tcHJvZ3Jlc3MgYmF0Y2guIFRoZSBiYXRjaCB3aWxsIGJlIGluIHN0YXR1cyBgY2FuY2VsbGluZ2AgZm9yIHVwIHRvXG4gICAqIDEwIG1pbnV0ZXMsIGJlZm9yZSBjaGFuZ2luZyB0byBgY2FuY2VsbGVkYCwgd2hlcmUgaXQgd2lsbCBoYXZlIHBhcnRpYWwgcmVzdWx0c1xuICAgKiAoaWYgYW55KSBhdmFpbGFibGUgaW4gdGhlIG91dHB1dCBmaWxlLlxuICAgKi9cbiAgY2FuY2VsKGJhdGNoSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8QmF0Y2g+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC9iYXRjaGVzLyR7YmF0Y2hJZH0vY2FuY2VsYCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJhdGNoZXNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxCYXRjaD4ge31cblxuZXhwb3J0IGludGVyZmFjZSBCYXRjaCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIGZyYW1lIHdpdGhpbiB3aGljaCB0aGUgYmF0Y2ggc2hvdWxkIGJlIHByb2Nlc3NlZC5cbiAgICovXG4gIGNvbXBsZXRpb25fd2luZG93OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGJhdGNoIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgT3BlbkFJIEFQSSBlbmRwb2ludCB1c2VkIGJ5IHRoZSBiYXRjaC5cbiAgICovXG4gIGVuZHBvaW50OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgaW5wdXQgZmlsZSBmb3IgdGhlIGJhdGNoLlxuICAgKi9cbiAgaW5wdXRfZmlsZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgYmF0Y2hgLlxuICAgKi9cbiAgb2JqZWN0OiAnYmF0Y2gnO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIGJhdGNoLlxuICAgKi9cbiAgc3RhdHVzOlxuICAgIHwgJ3ZhbGlkYXRpbmcnXG4gICAgfCAnZmFpbGVkJ1xuICAgIHwgJ2luX3Byb2dyZXNzJ1xuICAgIHwgJ2ZpbmFsaXppbmcnXG4gICAgfCAnY29tcGxldGVkJ1xuICAgIHwgJ2V4cGlyZWQnXG4gICAgfCAnY2FuY2VsbGluZydcbiAgICB8ICdjYW5jZWxsZWQnO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBiYXRjaCB3YXMgY2FuY2VsbGVkLlxuICAgKi9cbiAgY2FuY2VsbGVkX2F0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBiYXRjaCBzdGFydGVkIGNhbmNlbGxpbmcuXG4gICAqL1xuICBjYW5jZWxsaW5nX2F0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBiYXRjaCB3YXMgY29tcGxldGVkLlxuICAgKi9cbiAgY29tcGxldGVkX2F0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgY29udGFpbmluZyB0aGUgb3V0cHV0cyBvZiByZXF1ZXN0cyB3aXRoIGVycm9ycy5cbiAgICovXG4gIGVycm9yX2ZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgZXJyb3JzPzogQmF0Y2guRXJyb3JzO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBiYXRjaCBleHBpcmVkLlxuICAgKi9cbiAgZXhwaXJlZF9hdD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgYmF0Y2ggd2lsbCBleHBpcmUuXG4gICAqL1xuICBleHBpcmVzX2F0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBiYXRjaCBmYWlsZWQuXG4gICAqL1xuICBmYWlsZWRfYXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGJhdGNoIHN0YXJ0ZWQgZmluYWxpemluZy5cbiAgICovXG4gIGZpbmFsaXppbmdfYXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGJhdGNoIHN0YXJ0ZWQgcHJvY2Vzc2luZy5cbiAgICovXG4gIGluX3Byb2dyZXNzX2F0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgY29udGFpbmluZyB0aGUgb3V0cHV0cyBvZiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQgcmVxdWVzdHMuXG4gICAqL1xuICBvdXRwdXRfZmlsZV9pZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJlcXVlc3QgY291bnRzIGZvciBkaWZmZXJlbnQgc3RhdHVzZXMgd2l0aGluIHRoZSBiYXRjaC5cbiAgICovXG4gIHJlcXVlc3RfY291bnRzPzogQmF0Y2hSZXF1ZXN0Q291bnRzO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEJhdGNoIHtcbiAgZXhwb3J0IGludGVyZmFjZSBFcnJvcnMge1xuICAgIGRhdGE/OiBBcnJheTxCYXRjaGVzQVBJLkJhdGNoRXJyb3I+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYGxpc3RgLlxuICAgICAqL1xuICAgIG9iamVjdD86IHN0cmluZztcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhdGNoRXJyb3Ige1xuICAvKipcbiAgICogQW4gZXJyb3IgY29kZSBpZGVudGlmeWluZyB0aGUgZXJyb3IgdHlwZS5cbiAgICovXG4gIGNvZGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBsaW5lIG51bWJlciBvZiB0aGUgaW5wdXQgZmlsZSB3aGVyZSB0aGUgZXJyb3Igb2NjdXJyZWQsIGlmIGFwcGxpY2FibGUuXG4gICAqL1xuICBsaW5lPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBodW1hbi1yZWFkYWJsZSBtZXNzYWdlIHByb3ZpZGluZyBtb3JlIGRldGFpbHMgYWJvdXQgdGhlIGVycm9yLlxuICAgKi9cbiAgbWVzc2FnZT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciB0aGF0IGNhdXNlZCB0aGUgZXJyb3IsIGlmIGFwcGxpY2FibGUuXG4gICAqL1xuICBwYXJhbT86IHN0cmluZyB8IG51bGw7XG59XG5cbi8qKlxuICogVGhlIHJlcXVlc3QgY291bnRzIGZvciBkaWZmZXJlbnQgc3RhdHVzZXMgd2l0aGluIHRoZSBiYXRjaC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCYXRjaFJlcXVlc3RDb3VudHMge1xuICAvKipcbiAgICogTnVtYmVyIG9mIHJlcXVlc3RzIHRoYXQgaGF2ZSBiZWVuIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAqL1xuICBjb21wbGV0ZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHJlcXVlc3RzIHRoYXQgaGF2ZSBmYWlsZWQuXG4gICAqL1xuICBmYWlsZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVG90YWwgbnVtYmVyIG9mIHJlcXVlc3RzIGluIHRoZSBiYXRjaC5cbiAgICovXG4gIHRvdGFsOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmF0Y2hDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIHRpbWUgZnJhbWUgd2l0aGluIHdoaWNoIHRoZSBiYXRjaCBzaG91bGQgYmUgcHJvY2Vzc2VkLiBDdXJyZW50bHkgb25seSBgMjRoYFxuICAgKiBpcyBzdXBwb3J0ZWQuXG4gICAqL1xuICBjb21wbGV0aW9uX3dpbmRvdzogJzI0aCc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbmRwb2ludCB0byBiZSB1c2VkIGZvciBhbGwgcmVxdWVzdHMgaW4gdGhlIGJhdGNoLiBDdXJyZW50bHlcbiAgICogYC92MS9jaGF0L2NvbXBsZXRpb25zYCwgYC92MS9lbWJlZGRpbmdzYCwgYW5kIGAvdjEvY29tcGxldGlvbnNgIGFyZSBzdXBwb3J0ZWQuXG4gICAqIE5vdGUgdGhhdCBgL3YxL2VtYmVkZGluZ3NgIGJhdGNoZXMgYXJlIGFsc28gcmVzdHJpY3RlZCB0byBhIG1heGltdW0gb2YgNTAsMDAwXG4gICAqIGVtYmVkZGluZyBpbnB1dHMgYWNyb3NzIGFsbCByZXF1ZXN0cyBpbiB0aGUgYmF0Y2guXG4gICAqL1xuICBlbmRwb2ludDogJy92MS9jaGF0L2NvbXBsZXRpb25zJyB8ICcvdjEvZW1iZWRkaW5ncycgfCAnL3YxL2NvbXBsZXRpb25zJztcblxuICAvKipcbiAgICogVGhlIElEIG9mIGFuIHVwbG9hZGVkIGZpbGUgdGhhdCBjb250YWlucyByZXF1ZXN0cyBmb3IgdGhlIG5ldyBiYXRjaC5cbiAgICpcbiAgICogU2VlIFt1cGxvYWQgZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9jcmVhdGUpXG4gICAqIGZvciBob3cgdG8gdXBsb2FkIGEgZmlsZS5cbiAgICpcbiAgICogWW91ciBpbnB1dCBmaWxlIG11c3QgYmUgZm9ybWF0dGVkIGFzIGFcbiAgICogW0pTT05MIGZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYmF0Y2gvcmVxdWVzdC1pbnB1dCksXG4gICAqIGFuZCBtdXN0IGJlIHVwbG9hZGVkIHdpdGggdGhlIHB1cnBvc2UgYGJhdGNoYC4gVGhlIGZpbGUgY2FuIGNvbnRhaW4gdXAgdG8gNTAsMDAwXG4gICAqIHJlcXVlc3RzLCBhbmQgY2FuIGJlIHVwIHRvIDIwMCBNQiBpbiBzaXplLlxuICAgKi9cbiAgaW5wdXRfZmlsZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjdXN0b20gbWV0YWRhdGEgZm9yIHRoZSBiYXRjaC5cbiAgICovXG4gIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmF0Y2hMaXN0UGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7fVxuXG5CYXRjaGVzLkJhdGNoZXNQYWdlID0gQmF0Y2hlc1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBCYXRjaGVzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIEJhdGNoIGFzIEJhdGNoLFxuICAgIHR5cGUgQmF0Y2hFcnJvciBhcyBCYXRjaEVycm9yLFxuICAgIHR5cGUgQmF0Y2hSZXF1ZXN0Q291bnRzIGFzIEJhdGNoUmVxdWVzdENvdW50cyxcbiAgICBCYXRjaGVzUGFnZSBhcyBCYXRjaGVzUGFnZSxcbiAgICB0eXBlIEJhdGNoQ3JlYXRlUGFyYW1zIGFzIEJhdGNoQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgQmF0Y2hMaXN0UGFyYW1zIGFzIEJhdGNoTGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBTaGFyZWQgZnJvbSAnLi4vc2hhcmVkJztcbmltcG9ydCAqIGFzIENoYXRBUEkgZnJvbSAnLi4vY2hhdC9jaGF0JztcbmltcG9ydCAqIGFzIE1lc3NhZ2VzQVBJIGZyb20gJy4vdGhyZWFkcy9tZXNzYWdlcyc7XG5pbXBvcnQgKiBhcyBUaHJlYWRzQVBJIGZyb20gJy4vdGhyZWFkcy90aHJlYWRzJztcbmltcG9ydCAqIGFzIFZlY3RvclN0b3Jlc0FQSSBmcm9tICcuL3ZlY3Rvci1zdG9yZXMvdmVjdG9yLXN0b3Jlcyc7XG5pbXBvcnQgKiBhcyBSdW5zQVBJIGZyb20gJy4vdGhyZWFkcy9ydW5zL3J1bnMnO1xuaW1wb3J0ICogYXMgU3RlcHNBUEkgZnJvbSAnLi90aHJlYWRzL3J1bnMvc3RlcHMnO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSwgdHlwZSBDdXJzb3JQYWdlUGFyYW1zIH0gZnJvbSAnLi4vLi4vcGFnaW5hdGlvbic7XG5cbmV4cG9ydCBjbGFzcyBBc3Npc3RhbnRzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlIGFuIGFzc2lzdGFudCB3aXRoIGEgbW9kZWwgYW5kIGluc3RydWN0aW9ucy5cbiAgICovXG4gIGNyZWF0ZShib2R5OiBBc3Npc3RhbnRDcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEFzc2lzdGFudD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2Fzc2lzdGFudHMnLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGFuIGFzc2lzdGFudC5cbiAgICovXG4gIHJldHJpZXZlKGFzc2lzdGFudElkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEFzc2lzdGFudD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvYXNzaXN0YW50cy8ke2Fzc2lzdGFudElkfWAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIGFuIGFzc2lzdGFudC5cbiAgICovXG4gIHVwZGF0ZShcbiAgICBhc3Npc3RhbnRJZDogc3RyaW5nLFxuICAgIGJvZHk6IEFzc2lzdGFudFVwZGF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPEFzc2lzdGFudD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH1gLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgYXNzaXN0YW50cy5cbiAgICovXG4gIGxpc3QoXG4gICAgcXVlcnk/OiBBc3Npc3RhbnRMaXN0UGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEFzc2lzdGFudHNQYWdlLCBBc3Npc3RhbnQ+O1xuICBsaXN0KG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5QYWdlUHJvbWlzZTxBc3Npc3RhbnRzUGFnZSwgQXNzaXN0YW50PjtcbiAgbGlzdChcbiAgICBxdWVyeTogQXNzaXN0YW50TGlzdFBhcmFtcyB8IENvcmUuUmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxBc3Npc3RhbnRzUGFnZSwgQXNzaXN0YW50PiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0KHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdCgnL2Fzc2lzdGFudHMnLCBBc3Npc3RhbnRzUGFnZSwge1xuICAgICAgcXVlcnksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYW4gYXNzaXN0YW50LlxuICAgKi9cbiAgZGVsKGFzc2lzdGFudElkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEFzc2lzdGFudERlbGV0ZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQXNzaXN0YW50c1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlPEFzc2lzdGFudD4ge31cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGBhc3Npc3RhbnRgIHRoYXQgY2FuIGNhbGwgdGhlIG1vZGVsIGFuZCB1c2UgdG9vbHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXNzaXN0YW50IHtcbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgYXNzaXN0YW50IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGFzc2lzdGFudC4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDUxMiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgZGVzY3JpcHRpb246IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzeXN0ZW0gaW5zdHJ1Y3Rpb25zIHRoYXQgdGhlIGFzc2lzdGFudCB1c2VzLiBUaGUgbWF4aW11bSBsZW5ndGggaXMgMjU2LDAwMFxuICAgKiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zOiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YTogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIElEIG9mIHRoZSBtb2RlbCB0byB1c2UuIFlvdSBjYW4gdXNlIHRoZVxuICAgKiBbTGlzdCBtb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzL2xpc3QpIEFQSSB0b1xuICAgKiBzZWUgYWxsIG9mIHlvdXIgYXZhaWxhYmxlIG1vZGVscywgb3Igc2VlIG91clxuICAgKiBbTW9kZWwgb3ZlcnZpZXddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscykgZm9yIGRlc2NyaXB0aW9ucyBvZlxuICAgKiB0aGVtLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGFzc2lzdGFudC4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDI1NiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgbmFtZTogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYGFzc2lzdGFudGAuXG4gICAqL1xuICBvYmplY3Q6ICdhc3Npc3RhbnQnO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdG9vbCBlbmFibGVkIG9uIHRoZSBhc3Npc3RhbnQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMTI4IHRvb2xzIHBlclxuICAgKiBhc3Npc3RhbnQuIFRvb2xzIGNhbiBiZSBvZiB0eXBlcyBgY29kZV9pbnRlcnByZXRlcmAsIGBmaWxlX3NlYXJjaGAsIG9yXG4gICAqIGBmdW5jdGlvbmAuXG4gICAqL1xuICB0b29sczogQXJyYXk8QXNzaXN0YW50VG9vbD47XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAgICogW0dQVC00b10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00byksXG4gICAqIFtHUFQtNCBUdXJib10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00LXR1cmJvLWFuZC1ncHQtNCksXG4gICAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9zY2hlbWFcIiwgXCJqc29uX3NjaGVtYVwiOiB7Li4ufSB9YCBlbmFibGVzIFN0cnVjdHVyZWRcbiAgICogT3V0cHV0cyB3aGljaCBlbnN1cmVzIHRoZSBtb2RlbCB3aWxsIG1hdGNoIHlvdXIgc3VwcGxpZWQgSlNPTiBzY2hlbWEuIExlYXJuIG1vcmVcbiAgICogaW4gdGhlXG4gICAqIFtTdHJ1Y3R1cmVkIE91dHB1dHMgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zdHJ1Y3R1cmVkLW91dHB1dHMpLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGVuc3VyZXMgdGhlXG4gICAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICAgKlxuICAgKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gICAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAgICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAgICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAgICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICAgKiBtYXggY29udGV4dCBsZW5ndGguXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBUaHJlYWRzQVBJLkFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBhc3Npc3RhbnQncyB0b29scy4gVGhlIHJlc291cmNlcyBhcmVcbiAgICogc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlc1xuICAgKiBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZVxuICAgKiBJRHMuXG4gICAqL1xuICB0b29sX3Jlc291cmNlcz86IEFzc2lzdGFudC5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgdGVtcGVyYXR1cmUgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdG9wX3A/OiBudW1iZXIgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEFzc2lzdGFudCB7XG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgdXNlZCBieSB0aGUgYXNzaXN0YW50J3MgdG9vbHMuIFRoZSByZXNvdXJjZXMgYXJlXG4gICAqIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXNcbiAgICogYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVcbiAgICogSURzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYGAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlc1xuICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIElEIG9mIHRoZVxuICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgYXNzaXN0YW50LiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvXG4gICAgICAgKiB0aGUgYXNzaXN0YW50LlxuICAgICAgICovXG4gICAgICB2ZWN0b3Jfc3RvcmVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBc3Npc3RhbnREZWxldGVkIHtcbiAgaWQ6IHN0cmluZztcblxuICBkZWxldGVkOiBib29sZWFuO1xuXG4gIG9iamVjdDogJ2Fzc2lzdGFudC5kZWxldGVkJztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGV2ZW50IGVtaXR0ZWQgd2hlbiBzdHJlYW1pbmcgYSBSdW4uXG4gKlxuICogRWFjaCBldmVudCBpbiBhIHNlcnZlci1zZW50IGV2ZW50cyBzdHJlYW0gaGFzIGFuIGBldmVudGAgYW5kIGBkYXRhYCBwcm9wZXJ0eTpcbiAqXG4gKiBgYGBcbiAqIGV2ZW50OiB0aHJlYWQuY3JlYXRlZFxuICogZGF0YToge1wiaWRcIjogXCJ0aHJlYWRfMTIzXCIsIFwib2JqZWN0XCI6IFwidGhyZWFkXCIsIC4uLn1cbiAqIGBgYFxuICpcbiAqIFdlIGVtaXQgZXZlbnRzIHdoZW5ldmVyIGEgbmV3IG9iamVjdCBpcyBjcmVhdGVkLCB0cmFuc2l0aW9ucyB0byBhIG5ldyBzdGF0ZSwgb3JcbiAqIGlzIGJlaW5nIHN0cmVhbWVkIGluIHBhcnRzIChkZWx0YXMpLiBGb3IgZXhhbXBsZSwgd2UgZW1pdCBgdGhyZWFkLnJ1bi5jcmVhdGVkYFxuICogd2hlbiBhIG5ldyBydW4gaXMgY3JlYXRlZCwgYHRocmVhZC5ydW4uY29tcGxldGVkYCB3aGVuIGEgcnVuIGNvbXBsZXRlcywgYW5kIHNvXG4gKiBvbi4gV2hlbiBhbiBBc3Npc3RhbnQgY2hvb3NlcyB0byBjcmVhdGUgYSBtZXNzYWdlIGR1cmluZyBhIHJ1biwgd2UgZW1pdCBhXG4gKiBgdGhyZWFkLm1lc3NhZ2UuY3JlYXRlZCBldmVudGAsIGEgYHRocmVhZC5tZXNzYWdlLmluX3Byb2dyZXNzYCBldmVudCwgbWFueVxuICogYHRocmVhZC5tZXNzYWdlLmRlbHRhYCBldmVudHMsIGFuZCBmaW5hbGx5IGEgYHRocmVhZC5tZXNzYWdlLmNvbXBsZXRlZGAgZXZlbnQuXG4gKlxuICogV2UgbWF5IGFkZCBhZGRpdGlvbmFsIGV2ZW50cyBvdmVyIHRpbWUsIHNvIHdlIHJlY29tbWVuZCBoYW5kbGluZyB1bmtub3duIGV2ZW50c1xuICogZ3JhY2VmdWxseSBpbiB5b3VyIGNvZGUuIFNlZSB0aGVcbiAqIFtBc3Npc3RhbnRzIEFQSSBxdWlja3N0YXJ0XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL292ZXJ2aWV3KVxuICogdG8gbGVhcm4gaG93IHRvIGludGVncmF0ZSB0aGUgQXNzaXN0YW50cyBBUEkgd2l0aCBzdHJlYW1pbmcuXG4gKi9cbmV4cG9ydCB0eXBlIEFzc2lzdGFudFN0cmVhbUV2ZW50ID1cbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRDcmVhdGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuQ3JlYXRlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1blF1ZXVlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1bkluUHJvZ3Jlc3NcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5SZXF1aXJlc0FjdGlvblxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1bkNvbXBsZXRlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1bkluY29tcGxldGVcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5GYWlsZWRcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5DYW5jZWxsaW5nXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuQ2FuY2VsbGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuRXhwaXJlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBDcmVhdGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcEluUHJvZ3Jlc3NcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwRGVsdGFcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwQ29tcGxldGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcEZhaWxlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBDYW5jZWxsZWRcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwRXhwaXJlZFxuICB8IEFzc2lzdGFudFN0cmVhbUV2ZW50LlRocmVhZE1lc3NhZ2VDcmVhdGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkTWVzc2FnZUluUHJvZ3Jlc3NcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRNZXNzYWdlRGVsdGFcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5UaHJlYWRNZXNzYWdlQ29tcGxldGVkXG4gIHwgQXNzaXN0YW50U3RyZWFtRXZlbnQuVGhyZWFkTWVzc2FnZUluY29tcGxldGVcbiAgfCBBc3Npc3RhbnRTdHJlYW1FdmVudC5FcnJvckV2ZW50O1xuXG5leHBvcnQgbmFtZXNwYWNlIEFzc2lzdGFudFN0cmVhbUV2ZW50IHtcbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgbmV3XG4gICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcy9vYmplY3QpIGlzXG4gICAqIGNyZWF0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZENyZWF0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSB0aHJlYWQgdGhhdCBjb250YWluc1xuICAgICAqIFttZXNzYWdlc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcykuXG4gICAgICovXG4gICAgZGF0YTogVGhyZWFkc0FQSS5UaHJlYWQ7XG5cbiAgICBldmVudDogJ3RocmVhZC5jcmVhdGVkJztcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZW5hYmxlIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24uXG4gICAgICovXG4gICAgZW5hYmxlZD86IGJvb2xlYW47XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBuZXdcbiAgICogW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdCkgaXMgY3JlYXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuQ3JlYXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmNyZWF0ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogbW92ZXMgdG8gYSBgcXVldWVkYCBzdGF0dXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blF1ZXVlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnF1ZXVlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBtb3ZlcyB0byBhbiBgaW5fcHJvZ3Jlc3NgIHN0YXR1cy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuSW5Qcm9ncmVzcyB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmluX3Byb2dyZXNzJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIG1vdmVzIHRvIGEgYHJlcXVpcmVzX2FjdGlvbmAgc3RhdHVzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5SZXF1aXJlc0FjdGlvbiB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnJlcXVpcmVzX2FjdGlvbic7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBpcyBjb21wbGV0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkNvbXBsZXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmNvbXBsZXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBlbmRzIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuSW5jb21wbGV0ZSB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmluY29tcGxldGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogZmFpbHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkZhaWxlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmZhaWxlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBtb3ZlcyB0byBhIGBjYW5jZWxsaW5nYCBzdGF0dXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkNhbmNlbGxpbmcge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5jYW5jZWxsaW5nJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIGlzIGNhbmNlbGxlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuQ2FuY2VsbGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uY2FuY2VsbGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIGV4cGlyZXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1bkV4cGlyZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5leHBpcmVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIGlzIGNyZWF0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBDcmVhdGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc3RlcCBpbiBleGVjdXRpb24gb2YgYSBydW4uXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmNyZWF0ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogbW92ZXMgdG8gYW4gYGluX3Byb2dyZXNzYCBzdGF0ZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcEluUHJvZ3Jlc3Mge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuaW5fcHJvZ3Jlc3MnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIHBhcnRzIG9mIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogYXJlIGJlaW5nIHN0cmVhbWVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwRGVsdGEge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBydW4gc3RlcCBkZWx0YSBpLmUuIGFueSBjaGFuZ2VkIGZpZWxkcyBvbiBhIHJ1biBzdGVwIGR1cmluZ1xuICAgICAqIHN0cmVhbWluZy5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwRGVsdGFFdmVudDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmRlbHRhJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIGlzIGNvbXBsZXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcENvbXBsZXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5jb21wbGV0ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogZmFpbHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBGYWlsZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuZmFpbGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gICAqIGlzIGNhbmNlbGxlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcENhbmNlbGxlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5jYW5jZWxsZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogZXhwaXJlcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcEV4cGlyZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuZXhwaXJlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbbWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcy9vYmplY3QpIGlzXG4gICAqIGNyZWF0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZE1lc3NhZ2VDcmVhdGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgbWVzc2FnZSB3aXRoaW4gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogTWVzc2FnZXNBUEkuTWVzc2FnZTtcblxuICAgIGV2ZW50OiAndGhyZWFkLm1lc3NhZ2UuY3JlYXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbbWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcy9vYmplY3QpIG1vdmVzXG4gICAqIHRvIGFuIGBpbl9wcm9ncmVzc2Agc3RhdGUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZE1lc3NhZ2VJblByb2dyZXNzIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgbWVzc2FnZSB3aXRoaW4gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogTWVzc2FnZXNBUEkuTWVzc2FnZTtcblxuICAgIGV2ZW50OiAndGhyZWFkLm1lc3NhZ2UuaW5fcHJvZ3Jlc3MnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIHBhcnRzIG9mIGFcbiAgICogW01lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMvb2JqZWN0KSBhcmVcbiAgICogYmVpbmcgc3RyZWFtZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZE1lc3NhZ2VEZWx0YSB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIG1lc3NhZ2UgZGVsdGEgaS5lLiBhbnkgY2hhbmdlZCBmaWVsZHMgb24gYSBtZXNzYWdlIGR1cmluZ1xuICAgICAqIHN0cmVhbWluZy5cbiAgICAgKi9cbiAgICBkYXRhOiBNZXNzYWdlc0FQSS5NZXNzYWdlRGVsdGFFdmVudDtcblxuICAgIGV2ZW50OiAndGhyZWFkLm1lc3NhZ2UuZGVsdGEnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW21lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMvb2JqZWN0KSBpc1xuICAgKiBjb21wbGV0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZE1lc3NhZ2VDb21wbGV0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIHdpdGhpbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBNZXNzYWdlc0FQSS5NZXNzYWdlO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQubWVzc2FnZS5jb21wbGV0ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW21lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMvb2JqZWN0KSBlbmRzXG4gICAqIGJlZm9yZSBpdCBpcyBjb21wbGV0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZE1lc3NhZ2VJbmNvbXBsZXRlIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgbWVzc2FnZSB3aXRoaW4gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogTWVzc2FnZXNBUEkuTWVzc2FnZTtcblxuICAgIGV2ZW50OiAndGhyZWFkLm1lc3NhZ2UuaW5jb21wbGV0ZSc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYW5cbiAgICogW2Vycm9yXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZXJyb3ItY29kZXMjYXBpLWVycm9ycykgb2NjdXJzLlxuICAgKiBUaGlzIGNhbiBoYXBwZW4gZHVlIHRvIGFuIGludGVybmFsIHNlcnZlciBlcnJvciBvciBhIHRpbWVvdXQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEVycm9yRXZlbnQge1xuICAgIGRhdGE6IFNoYXJlZC5FcnJvck9iamVjdDtcblxuICAgIGV2ZW50OiAnZXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIEFzc2lzdGFudFRvb2wgPSBDb2RlSW50ZXJwcmV0ZXJUb29sIHwgRmlsZVNlYXJjaFRvb2wgfCBGdW5jdGlvblRvb2w7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyVG9vbCB7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0b29sIGJlaW5nIGRlZmluZWQ6IGBjb2RlX2ludGVycHJldGVyYFxuICAgKi9cbiAgdHlwZTogJ2NvZGVfaW50ZXJwcmV0ZXInO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2hUb29sIHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRvb2wgYmVpbmcgZGVmaW5lZDogYGZpbGVfc2VhcmNoYFxuICAgKi9cbiAgdHlwZTogJ2ZpbGVfc2VhcmNoJztcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIGZvciB0aGUgZmlsZSBzZWFyY2ggdG9vbC5cbiAgICovXG4gIGZpbGVfc2VhcmNoPzogRmlsZVNlYXJjaFRvb2wuRmlsZVNlYXJjaDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaWxlU2VhcmNoVG9vbCB7XG4gIC8qKlxuICAgKiBPdmVycmlkZXMgZm9yIHRoZSBmaWxlIHNlYXJjaCB0b29sLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVzdWx0cyB0aGUgZmlsZSBzZWFyY2ggdG9vbCBzaG91bGQgb3V0cHV0LiBUaGUgZGVmYXVsdCBpc1xuICAgICAqIDIwIGZvciBgZ3B0LTQqYCBtb2RlbHMgYW5kIDUgZm9yIGBncHQtMy41LXR1cmJvYC4gVGhpcyBudW1iZXIgc2hvdWxkIGJlIGJldHdlZW5cbiAgICAgKiAxIGFuZCA1MCBpbmNsdXNpdmUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbGUgc2VhcmNoIHRvb2wgbWF5IG91dHB1dCBmZXdlciB0aGFuIGBtYXhfbnVtX3Jlc3VsdHNgIHJlc3VsdHMuXG4gICAgICogU2VlIHRoZVxuICAgICAqIFtmaWxlIHNlYXJjaCB0b29sIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvdG9vbHMvZmlsZS1zZWFyY2gjY3VzdG9taXppbmctZmlsZS1zZWFyY2gtc2V0dGluZ3MpXG4gICAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgbWF4X251bV9yZXN1bHRzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJhbmtpbmcgb3B0aW9ucyBmb3IgdGhlIGZpbGUgc2VhcmNoLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgZmlsZSBzZWFyY2ggdG9vbFxuICAgICAqIHdpbGwgdXNlIHRoZSBgYXV0b2AgcmFua2VyIGFuZCBhIHNjb3JlX3RocmVzaG9sZCBvZiAwLlxuICAgICAqXG4gICAgICogU2VlIHRoZVxuICAgICAqIFtmaWxlIHNlYXJjaCB0b29sIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvdG9vbHMvZmlsZS1zZWFyY2gjY3VzdG9taXppbmctZmlsZS1zZWFyY2gtc2V0dGluZ3MpXG4gICAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgcmFua2luZ19vcHRpb25zPzogRmlsZVNlYXJjaC5SYW5raW5nT3B0aW9ucztcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgRmlsZVNlYXJjaCB7XG4gICAgLyoqXG4gICAgICogVGhlIHJhbmtpbmcgb3B0aW9ucyBmb3IgdGhlIGZpbGUgc2VhcmNoLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgZmlsZSBzZWFyY2ggdG9vbFxuICAgICAqIHdpbGwgdXNlIHRoZSBgYXV0b2AgcmFua2VyIGFuZCBhIHNjb3JlX3RocmVzaG9sZCBvZiAwLlxuICAgICAqXG4gICAgICogU2VlIHRoZVxuICAgICAqIFtmaWxlIHNlYXJjaCB0b29sIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvdG9vbHMvZmlsZS1zZWFyY2gjY3VzdG9taXppbmctZmlsZS1zZWFyY2gtc2V0dGluZ3MpXG4gICAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBSYW5raW5nT3B0aW9ucyB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBzY29yZSB0aHJlc2hvbGQgZm9yIHRoZSBmaWxlIHNlYXJjaC4gQWxsIHZhbHVlcyBtdXN0IGJlIGEgZmxvYXRpbmcgcG9pbnRcbiAgICAgICAqIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICAgKi9cbiAgICAgIHNjb3JlX3RocmVzaG9sZDogbnVtYmVyO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSByYW5rZXIgdG8gdXNlIGZvciB0aGUgZmlsZSBzZWFyY2guIElmIG5vdCBzcGVjaWZpZWQgd2lsbCB1c2UgdGhlIGBhdXRvYFxuICAgICAgICogcmFua2VyLlxuICAgICAgICovXG4gICAgICByYW5rZXI/OiAnYXV0bycgfCAnZGVmYXVsdF8yMDI0XzA4XzIxJztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvblRvb2wge1xuICBmdW5jdGlvbjogU2hhcmVkLkZ1bmN0aW9uRGVmaW5pdGlvbjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdG9vbCBiZWluZyBkZWZpbmVkOiBgZnVuY3Rpb25gXG4gICAqL1xuICB0eXBlOiAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIE9jY3VycyB3aGVuIGFcbiAqIFttZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzL29iamVjdCkgaXNcbiAqIGNyZWF0ZWQuXG4gKi9cbmV4cG9ydCB0eXBlIE1lc3NhZ2VTdHJlYW1FdmVudCA9XG4gIHwgTWVzc2FnZVN0cmVhbUV2ZW50LlRocmVhZE1lc3NhZ2VDcmVhdGVkXG4gIHwgTWVzc2FnZVN0cmVhbUV2ZW50LlRocmVhZE1lc3NhZ2VJblByb2dyZXNzXG4gIHwgTWVzc2FnZVN0cmVhbUV2ZW50LlRocmVhZE1lc3NhZ2VEZWx0YVxuICB8IE1lc3NhZ2VTdHJlYW1FdmVudC5UaHJlYWRNZXNzYWdlQ29tcGxldGVkXG4gIHwgTWVzc2FnZVN0cmVhbUV2ZW50LlRocmVhZE1lc3NhZ2VJbmNvbXBsZXRlO1xuXG5leHBvcnQgbmFtZXNwYWNlIE1lc3NhZ2VTdHJlYW1FdmVudCB7XG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFttZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzL29iamVjdCkgaXNcbiAgICogY3JlYXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkTWVzc2FnZUNyZWF0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIHdpdGhpbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBNZXNzYWdlc0FQSS5NZXNzYWdlO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQubWVzc2FnZS5jcmVhdGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhXG4gICAqIFttZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzL29iamVjdCkgbW92ZXNcbiAgICogdG8gYW4gYGluX3Byb2dyZXNzYCBzdGF0ZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkTWVzc2FnZUluUHJvZ3Jlc3Mge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIHdpdGhpbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBNZXNzYWdlc0FQSS5NZXNzYWdlO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQubWVzc2FnZS5pbl9wcm9ncmVzcyc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gcGFydHMgb2YgYVxuICAgKiBbTWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcy9vYmplY3QpIGFyZVxuICAgKiBiZWluZyBzdHJlYW1lZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkTWVzc2FnZURlbHRhIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgbWVzc2FnZSBkZWx0YSBpLmUuIGFueSBjaGFuZ2VkIGZpZWxkcyBvbiBhIG1lc3NhZ2UgZHVyaW5nXG4gICAgICogc3RyZWFtaW5nLlxuICAgICAqL1xuICAgIGRhdGE6IE1lc3NhZ2VzQVBJLk1lc3NhZ2VEZWx0YUV2ZW50O1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQubWVzc2FnZS5kZWx0YSc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbbWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcy9vYmplY3QpIGlzXG4gICAqIGNvbXBsZXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkTWVzc2FnZUNvbXBsZXRlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIG1lc3NhZ2Ugd2l0aGluIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IE1lc3NhZ2VzQVBJLk1lc3NhZ2U7XG5cbiAgICBldmVudDogJ3RocmVhZC5tZXNzYWdlLmNvbXBsZXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbbWVzc2FnZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tZXNzYWdlcy9vYmplY3QpIGVuZHNcbiAgICogYmVmb3JlIGl0IGlzIGNvbXBsZXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkTWVzc2FnZUluY29tcGxldGUge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIHdpdGhpbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBNZXNzYWdlc0FQSS5NZXNzYWdlO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQubWVzc2FnZS5pbmNvbXBsZXRlJztcbiAgfVxufVxuXG4vKipcbiAqIE9jY3VycyB3aGVuIGFcbiAqIFtydW4gc3RlcF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW4tc3RlcHMvc3RlcC1vYmplY3QpXG4gKiBpcyBjcmVhdGVkLlxuICovXG5leHBvcnQgdHlwZSBSdW5TdGVwU3RyZWFtRXZlbnQgPVxuICB8IFJ1blN0ZXBTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwQ3JlYXRlZFxuICB8IFJ1blN0ZXBTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwSW5Qcm9ncmVzc1xuICB8IFJ1blN0ZXBTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwRGVsdGFcbiAgfCBSdW5TdGVwU3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcENvbXBsZXRlZFxuICB8IFJ1blN0ZXBTdHJlYW1FdmVudC5UaHJlYWRSdW5TdGVwRmFpbGVkXG4gIHwgUnVuU3RlcFN0cmVhbUV2ZW50LlRocmVhZFJ1blN0ZXBDYW5jZWxsZWRcbiAgfCBSdW5TdGVwU3RyZWFtRXZlbnQuVGhyZWFkUnVuU3RlcEV4cGlyZWQ7XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuU3RlcFN0cmVhbUV2ZW50IHtcbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogaXMgY3JlYXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcENyZWF0ZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBzdGVwIGluIGV4ZWN1dGlvbiBvZiBhIHJ1bi5cbiAgICAgKi9cbiAgICBkYXRhOiBTdGVwc0FQSS5SdW5TdGVwO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuY3JlYXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBtb3ZlcyB0byBhbiBgaW5fcHJvZ3Jlc3NgIHN0YXRlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwSW5Qcm9ncmVzcyB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5pbl9wcm9ncmVzcyc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gcGFydHMgb2YgYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBhcmUgYmVpbmcgc3RyZWFtZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blN0ZXBEZWx0YSB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHJ1biBzdGVwIGRlbHRhIGkuZS4gYW55IGNoYW5nZWQgZmllbGRzIG9uIGEgcnVuIHN0ZXAgZHVyaW5nXG4gICAgICogc3RyZWFtaW5nLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXBEZWx0YUV2ZW50O1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLnN0ZXAuZGVsdGEnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogaXMgY29tcGxldGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwQ29tcGxldGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc3RlcCBpbiBleGVjdXRpb24gb2YgYSBydW4uXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmNvbXBsZXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBmYWlscy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuU3RlcEZhaWxlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5mYWlsZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGFcbiAgICogW3J1biBzdGVwXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bi1zdGVwcy9zdGVwLW9iamVjdClcbiAgICogaXMgY2FuY2VsbGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwQ2FuY2VsbGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc3RlcCBpbiBleGVjdXRpb24gb2YgYSBydW4uXG4gICAgICovXG4gICAgZGF0YTogU3RlcHNBUEkuUnVuU3RlcDtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5zdGVwLmNhbmNlbGxlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYVxuICAgKiBbcnVuIHN0ZXBdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVuLXN0ZXBzL3N0ZXAtb2JqZWN0KVxuICAgKiBleHBpcmVzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5TdGVwRXhwaXJlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICAgICAqL1xuICAgIGRhdGE6IFN0ZXBzQVBJLlJ1blN0ZXA7XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uc3RlcC5leHBpcmVkJztcbiAgfVxufVxuXG4vKipcbiAqIE9jY3VycyB3aGVuIGEgbmV3XG4gKiBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KSBpcyBjcmVhdGVkLlxuICovXG5leHBvcnQgdHlwZSBSdW5TdHJlYW1FdmVudCA9XG4gIHwgUnVuU3RyZWFtRXZlbnQuVGhyZWFkUnVuQ3JlYXRlZFxuICB8IFJ1blN0cmVhbUV2ZW50LlRocmVhZFJ1blF1ZXVlZFxuICB8IFJ1blN0cmVhbUV2ZW50LlRocmVhZFJ1bkluUHJvZ3Jlc3NcbiAgfCBSdW5TdHJlYW1FdmVudC5UaHJlYWRSdW5SZXF1aXJlc0FjdGlvblxuICB8IFJ1blN0cmVhbUV2ZW50LlRocmVhZFJ1bkNvbXBsZXRlZFxuICB8IFJ1blN0cmVhbUV2ZW50LlRocmVhZFJ1bkluY29tcGxldGVcbiAgfCBSdW5TdHJlYW1FdmVudC5UaHJlYWRSdW5GYWlsZWRcbiAgfCBSdW5TdHJlYW1FdmVudC5UaHJlYWRSdW5DYW5jZWxsaW5nXG4gIHwgUnVuU3RyZWFtRXZlbnQuVGhyZWFkUnVuQ2FuY2VsbGVkXG4gIHwgUnVuU3RyZWFtRXZlbnQuVGhyZWFkUnVuRXhwaXJlZDtcblxuZXhwb3J0IG5hbWVzcGFjZSBSdW5TdHJlYW1FdmVudCB7XG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIG5ld1xuICAgKiBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KSBpcyBjcmVhdGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5DcmVhdGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uY3JlYXRlZCc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBtb3ZlcyB0byBhIGBxdWV1ZWRgIHN0YXR1cy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuUXVldWVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4ucXVldWVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIG1vdmVzIHRvIGFuIGBpbl9wcm9ncmVzc2Agc3RhdHVzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5JblByb2dyZXNzIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uaW5fcHJvZ3Jlc3MnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogbW92ZXMgdG8gYSBgcmVxdWlyZXNfYWN0aW9uYCBzdGF0dXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRocmVhZFJ1blJlcXVpcmVzQWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4ucmVxdWlyZXNfYWN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIGlzIGNvbXBsZXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuQ29tcGxldGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uY29tcGxldGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIGVuZHMgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5JbmNvbXBsZXRlIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uaW5jb21wbGV0ZSc7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXJzIHdoZW4gYSBbcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvb2JqZWN0KVxuICAgKiBmYWlscy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuRmFpbGVkIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiBydW4gb24gYVxuICAgICAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gICAgICovXG4gICAgZGF0YTogUnVuc0FQSS5SdW47XG5cbiAgICBldmVudDogJ3RocmVhZC5ydW4uZmFpbGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBPY2N1cnMgd2hlbiBhIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9vYmplY3QpXG4gICAqIG1vdmVzIHRvIGEgYGNhbmNlbGxpbmdgIHN0YXR1cy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuQ2FuY2VsbGluZyB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmNhbmNlbGxpbmcnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogaXMgY2FuY2VsbGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWRSdW5DYW5jZWxsZWQge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXhlY3V0aW9uIHJ1biBvbiBhXG4gICAgICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAgICAgKi9cbiAgICBkYXRhOiBSdW5zQVBJLlJ1bjtcblxuICAgIGV2ZW50OiAndGhyZWFkLnJ1bi5jYW5jZWxsZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIE9jY3VycyB3aGVuIGEgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL29iamVjdClcbiAgICogZXhwaXJlcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkUnVuRXhwaXJlZCB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAgICAgKiBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpLlxuICAgICAqL1xuICAgIGRhdGE6IFJ1bnNBUEkuUnVuO1xuXG4gICAgZXZlbnQ6ICd0aHJlYWQucnVuLmV4cGlyZWQnO1xuICB9XG59XG5cbi8qKlxuICogT2NjdXJzIHdoZW4gYSBuZXdcbiAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcy9vYmplY3QpIGlzXG4gKiBjcmVhdGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRocmVhZFN0cmVhbUV2ZW50IHtcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSB0aHJlYWQgdGhhdCBjb250YWluc1xuICAgKiBbbWVzc2FnZXNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMpLlxuICAgKi9cbiAgZGF0YTogVGhyZWFkc0FQSS5UaHJlYWQ7XG5cbiAgZXZlbnQ6ICd0aHJlYWQuY3JlYXRlZCc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24uXG4gICAqL1xuICBlbmFibGVkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBc3Npc3RhbnRDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogSUQgb2YgdGhlIG1vZGVsIHRvIHVzZS4gWW91IGNhbiB1c2UgdGhlXG4gICAqIFtMaXN0IG1vZGVsc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tb2RlbHMvbGlzdCkgQVBJIHRvXG4gICAqIHNlZSBhbGwgb2YgeW91ciBhdmFpbGFibGUgbW9kZWxzLCBvciBzZWUgb3VyXG4gICAqIFtNb2RlbCBvdmVydmlld10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzKSBmb3IgZGVzY3JpcHRpb25zIG9mXG4gICAqIHRoZW0uXG4gICAqL1xuICBtb2RlbDogKHN0cmluZyAmIHt9KSB8IENoYXRBUEkuQ2hhdE1vZGVsO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGFzc2lzdGFudC4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDUxMiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgZGVzY3JpcHRpb24/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIGluc3RydWN0aW9ucyB0aGF0IHRoZSBhc3Npc3RhbnQgdXNlcy4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDI1NiwwMDBcbiAgICogY2hhcmFjdGVycy5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBhc3Npc3RhbnQuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyAyNTYgY2hhcmFjdGVycy5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gICAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNG8pLFxuICAgKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICAgKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fc2NoZW1hXCIsIFwianNvbl9zY2hlbWFcIjogey4uLn0gfWAgZW5hYmxlcyBTdHJ1Y3R1cmVkXG4gICAqIE91dHB1dHMgd2hpY2ggZW5zdXJlcyB0aGUgbW9kZWwgd2lsbCBtYXRjaCB5b3VyIHN1cHBsaWVkIEpTT04gc2NoZW1hLiBMZWFybiBtb3JlXG4gICAqIGluIHRoZVxuICAgKiBbU3RydWN0dXJlZCBPdXRwdXRzIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc3RydWN0dXJlZC1vdXRwdXRzKS5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBlbnN1cmVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogVGhyZWFkc0FQSS5Bc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoYXQgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdG8gdXNlLCBiZXR3ZWVuIDAgYW5kIDIuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbFxuICAgKiBtYWtlIHRoZSBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZVxuICAgKiBmb2N1c2VkIGFuZCBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgdXNlZCBieSB0aGUgYXNzaXN0YW50J3MgdG9vbHMuIFRoZSByZXNvdXJjZXMgYXJlXG4gICAqIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXNcbiAgICogYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVcbiAgICogSURzLlxuICAgKi9cbiAgdG9vbF9yZXNvdXJjZXM/OiBBc3Npc3RhbnRDcmVhdGVQYXJhbXMuVG9vbFJlc291cmNlcyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0b29sIGVuYWJsZWQgb24gdGhlIGFzc2lzdGFudC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxMjggdG9vbHMgcGVyXG4gICAqIGFzc2lzdGFudC4gVG9vbHMgY2FuIGJlIG9mIHR5cGVzIGBjb2RlX2ludGVycHJldGVyYCwgYGZpbGVfc2VhcmNoYCwgb3JcbiAgICogYGZ1bmN0aW9uYC5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50VG9vbD47XG5cbiAgLyoqXG4gICAqIEFuIGFsdGVybmF0aXZlIHRvIHNhbXBsaW5nIHdpdGggdGVtcGVyYXR1cmUsIGNhbGxlZCBudWNsZXVzIHNhbXBsaW5nLCB3aGVyZSB0aGVcbiAgICogbW9kZWwgY29uc2lkZXJzIHRoZSByZXN1bHRzIG9mIHRoZSB0b2tlbnMgd2l0aCB0b3BfcCBwcm9iYWJpbGl0eSBtYXNzLiBTbyAwLjFcbiAgICogbWVhbnMgb25seSB0aGUgdG9rZW5zIGNvbXByaXNpbmcgdGhlIHRvcCAxMCUgcHJvYmFiaWxpdHkgbWFzcyBhcmUgY29uc2lkZXJlZC5cbiAgICpcbiAgICogV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIHRlbXBlcmF0dXJlIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRvcF9wPzogbnVtYmVyIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBBc3Npc3RhbnRDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIGFzc2lzdGFudCdzIHRvb2xzLiBUaGUgcmVzb3VyY2VzIGFyZVxuICAgKiBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzXG4gICAqIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlXG4gICAqIElEcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgY29kZV9pbnRlcnByZXRlcj86IFRvb2xSZXNvdXJjZXMuQ29kZUludGVycHJldGVyO1xuXG4gICAgZmlsZV9zZWFyY2g/OiBUb29sUmVzb3VyY2VzLkZpbGVTZWFyY2g7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgbWFkZVxuICAgICAgICogYXZhaWxhYmxlIHRvIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlc1xuICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyBhc3Npc3RhbnQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAqIHRoZSBhc3Npc3RhbnQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgaGVscGVyIHRvIGNyZWF0ZSBhXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogd2l0aCBmaWxlX2lkcyBhbmQgYXR0YWNoIGl0IHRvIHRoaXMgYXNzaXN0YW50LiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDFcbiAgICAgICAqIHZlY3RvciBzdG9yZSBhdHRhY2hlZCB0byB0aGUgYXNzaXN0YW50LlxuICAgICAgICovXG4gICAgICB2ZWN0b3Jfc3RvcmVzPzogQXJyYXk8RmlsZVNlYXJjaC5WZWN0b3JTdG9yZT47XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmUge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNodW5raW5nIHN0cmF0ZWd5IHVzZWQgdG8gY2h1bmsgdGhlIGZpbGUocykuIElmIG5vdCBzZXQsIHdpbGwgdXNlIHRoZSBgYXV0b2BcbiAgICAgICAgICogc3RyYXRlZ3kuIE9ubHkgYXBwbGljYWJsZSBpZiBgZmlsZV9pZHNgIGlzIG5vbi1lbXB0eS5cbiAgICAgICAgICovXG4gICAgICAgIGNodW5raW5nX3N0cmF0ZWd5PzogVmVjdG9yU3RvcmVzQVBJLkZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIHRvXG4gICAgICAgICAqIGFkZCB0byB0aGUgdmVjdG9yIHN0b3JlLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEwMDAwIGZpbGVzIGluIGEgdmVjdG9yXG4gICAgICAgICAqIHN0b3JlLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdmVjdG9yIHN0b3JlLiBUaGlzIGNhbiBiZVxuICAgICAgICAgKiB1c2VmdWwgZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdmVjdG9yIHN0b3JlIGluIGEgc3RydWN0dXJlZFxuICAgICAgICAgKiBmb3JtYXQuIEtleXMgY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW1cbiAgICAgICAgICogb2YgNTEyIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgICAgICovXG4gICAgICAgIG1ldGFkYXRhPzogdW5rbm93bjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBc3Npc3RhbnRVcGRhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBhc3Npc3RhbnQuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyA1MTIgY2hhcmFjdGVycy5cbiAgICovXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHN5c3RlbSBpbnN0cnVjdGlvbnMgdGhhdCB0aGUgYXNzaXN0YW50IHVzZXMuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyAyNTYsMDAwXG4gICAqIGNoYXJhY3RlcnMuXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBZb3UgY2FuIHVzZSB0aGVcbiAgICogW0xpc3QgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscy9saXN0KSBBUEkgdG9cbiAgICogc2VlIGFsbCBvZiB5b3VyIGF2YWlsYWJsZSBtb2RlbHMsIG9yIHNlZSBvdXJcbiAgICogW01vZGVsIG92ZXJ2aWV3XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMpIGZvciBkZXNjcmlwdGlvbnMgb2ZcbiAgICogdGhlbS5cbiAgICovXG4gIG1vZGVsPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgYXNzaXN0YW50LiBUaGUgbWF4aW11bSBsZW5ndGggaXMgMjU2IGNoYXJhY3RlcnMuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBmb3JtYXQgdGhhdCB0aGUgbW9kZWwgbXVzdCBvdXRwdXQuIENvbXBhdGlibGUgd2l0aFxuICAgKiBbR1BULTRvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTRvKSxcbiAgICogW0dQVC00IFR1cmJvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTQtdHVyYm8tYW5kLWdwdC00KSxcbiAgICogYW5kIGFsbCBHUFQtMy41IFR1cmJvIG1vZGVscyBzaW5jZSBgZ3B0LTMuNS10dXJiby0xMTA2YC5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX3NjaGVtYVwiLCBcImpzb25fc2NoZW1hXCI6IHsuLi59IH1gIGVuYWJsZXMgU3RydWN0dXJlZFxuICAgKiBPdXRwdXRzIHdoaWNoIGVuc3VyZXMgdGhlIG1vZGVsIHdpbGwgbWF0Y2ggeW91ciBzdXBwbGllZCBKU09OIHNjaGVtYS4gTGVhcm4gbW9yZVxuICAgKiBpbiB0aGVcbiAgICogW1N0cnVjdHVyZWQgT3V0cHV0cyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3N0cnVjdHVyZWQtb3V0cHV0cykuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9vYmplY3RcIiB9YCBlbmFibGVzIEpTT04gbW9kZSwgd2hpY2ggZW5zdXJlcyB0aGVcbiAgICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gICAqXG4gICAqICoqSW1wb3J0YW50OioqIHdoZW4gdXNpbmcgSlNPTiBtb2RlLCB5b3UgKiptdXN0KiogYWxzbyBpbnN0cnVjdCB0aGUgbW9kZWwgdG9cbiAgICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICAgKiBnZW5lcmF0ZSBhbiB1bmVuZGluZyBzdHJlYW0gb2Ygd2hpdGVzcGFjZSB1bnRpbCB0aGUgZ2VuZXJhdGlvbiByZWFjaGVzIHRoZSB0b2tlblxuICAgKiBsaW1pdCwgcmVzdWx0aW5nIGluIGEgbG9uZy1ydW5uaW5nIGFuZCBzZWVtaW5nbHkgXCJzdHVja1wiIHJlcXVlc3QuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICAgKiBpbmRpY2F0ZXMgdGhlIGdlbmVyYXRpb24gZXhjZWVkZWQgYG1heF90b2tlbnNgIG9yIHRoZSBjb252ZXJzYXRpb24gZXhjZWVkZWQgdGhlXG4gICAqIG1heCBjb250ZXh0IGxlbmd0aC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86IFRocmVhZHNBUEkuQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIGFzc2lzdGFudCdzIHRvb2xzLiBUaGUgcmVzb3VyY2VzIGFyZVxuICAgKiBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzXG4gICAqIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlXG4gICAqIElEcy5cbiAgICovXG4gIHRvb2xfcmVzb3VyY2VzPzogQXNzaXN0YW50VXBkYXRlUGFyYW1zLlRvb2xSZXNvdXJjZXMgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdG9vbCBlbmFibGVkIG9uIHRoZSBhc3Npc3RhbnQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMTI4IHRvb2xzIHBlclxuICAgKiBhc3Npc3RhbnQuIFRvb2xzIGNhbiBiZSBvZiB0eXBlcyBgY29kZV9pbnRlcnByZXRlcmAsIGBmaWxlX3NlYXJjaGAsIG9yXG4gICAqIGBmdW5jdGlvbmAuXG4gICAqL1xuICB0b29scz86IEFycmF5PEFzc2lzdGFudFRvb2w+O1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQXNzaXN0YW50VXBkYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBhc3Npc3RhbnQncyB0b29scy4gVGhlIHJlc291cmNlcyBhcmVcbiAgICogc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlc1xuICAgKiBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZVxuICAgKiBJRHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGNvZGVfaW50ZXJwcmV0ZXI/OiBUb29sUmVzb3VyY2VzLkNvZGVJbnRlcnByZXRlcjtcblxuICAgIGZpbGVfc2VhcmNoPzogVG9vbFJlc291cmNlcy5GaWxlU2VhcmNoO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyB0aGUgbGlzdCBvZlxuICAgICAgICogW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlIGF2YWlsYWJsZVxuICAgICAgICogdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzIGFzc29jaWF0ZWRcbiAgICAgICAqIHdpdGggdGhlIHRvb2wuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZXMgdGhlXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyBhc3Npc3RhbnQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAqIHRoZSBhc3Npc3RhbnQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFzc2lzdGFudExpc3RQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgY3Vyc29yIGZvciB1c2UgaW4gcGFnaW5hdGlvbi4gYGJlZm9yZWAgaXMgYW4gb2JqZWN0IElEIHRoYXQgZGVmaW5lcyB5b3VyIHBsYWNlXG4gICAqIGluIHRoZSBsaXN0LiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBtYWtlIGEgbGlzdCByZXF1ZXN0IGFuZCByZWNlaXZlIDEwMCBvYmplY3RzLFxuICAgKiBzdGFydGluZyB3aXRoIG9ial9mb28sIHlvdXIgc3Vic2VxdWVudCBjYWxsIGNhbiBpbmNsdWRlIGJlZm9yZT1vYmpfZm9vIGluIG9yZGVyXG4gICAqIHRvIGZldGNoIHRoZSBwcmV2aW91cyBwYWdlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgYmVmb3JlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTb3J0IG9yZGVyIGJ5IHRoZSBgY3JlYXRlZF9hdGAgdGltZXN0YW1wIG9mIHRoZSBvYmplY3RzLiBgYXNjYCBmb3IgYXNjZW5kaW5nXG4gICAqIG9yZGVyIGFuZCBgZGVzY2AgZm9yIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAqL1xuICBvcmRlcj86ICdhc2MnIHwgJ2Rlc2MnO1xufVxuXG5Bc3Npc3RhbnRzLkFzc2lzdGFudHNQYWdlID0gQXNzaXN0YW50c1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBBc3Npc3RhbnRzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIEFzc2lzdGFudCBhcyBBc3Npc3RhbnQsXG4gICAgdHlwZSBBc3Npc3RhbnREZWxldGVkIGFzIEFzc2lzdGFudERlbGV0ZWQsXG4gICAgdHlwZSBBc3Npc3RhbnRTdHJlYW1FdmVudCBhcyBBc3Npc3RhbnRTdHJlYW1FdmVudCxcbiAgICB0eXBlIEFzc2lzdGFudFRvb2wgYXMgQXNzaXN0YW50VG9vbCxcbiAgICB0eXBlIENvZGVJbnRlcnByZXRlclRvb2wgYXMgQ29kZUludGVycHJldGVyVG9vbCxcbiAgICB0eXBlIEZpbGVTZWFyY2hUb29sIGFzIEZpbGVTZWFyY2hUb29sLFxuICAgIHR5cGUgRnVuY3Rpb25Ub29sIGFzIEZ1bmN0aW9uVG9vbCxcbiAgICB0eXBlIE1lc3NhZ2VTdHJlYW1FdmVudCBhcyBNZXNzYWdlU3RyZWFtRXZlbnQsXG4gICAgdHlwZSBSdW5TdGVwU3RyZWFtRXZlbnQgYXMgUnVuU3RlcFN0cmVhbUV2ZW50LFxuICAgIHR5cGUgUnVuU3RyZWFtRXZlbnQgYXMgUnVuU3RyZWFtRXZlbnQsXG4gICAgdHlwZSBUaHJlYWRTdHJlYW1FdmVudCBhcyBUaHJlYWRTdHJlYW1FdmVudCxcbiAgICBBc3Npc3RhbnRzUGFnZSBhcyBBc3Npc3RhbnRzUGFnZSxcbiAgICB0eXBlIEFzc2lzdGFudENyZWF0ZVBhcmFtcyBhcyBBc3Npc3RhbnRDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBBc3Npc3RhbnRVcGRhdGVQYXJhbXMgYXMgQXNzaXN0YW50VXBkYXRlUGFyYW1zLFxuICAgIHR5cGUgQXNzaXN0YW50TGlzdFBhcmFtcyBhcyBBc3Npc3RhbnRMaXN0UGFyYW1zLFxuICB9O1xufVxuIiwgImltcG9ydCB7IHR5cGUgQ2hhdENvbXBsZXRpb25SdW5uZXIgfSBmcm9tICcuL0NoYXRDb21wbGV0aW9uUnVubmVyJztcbmltcG9ydCB7IHR5cGUgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIgfSBmcm9tICcuL0NoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyJztcbmltcG9ydCB7IEpTT05TY2hlbWEgfSBmcm9tICcuL2pzb25zY2hlbWEnO1xuXG50eXBlIFByb21pc2VPclZhbHVlPFQ+ID0gVCB8IFByb21pc2U8VD47XG5cbmV4cG9ydCB0eXBlIFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncyBleHRlbmRzIG9iamVjdD4gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gYXJncyB0aGUgcmV0dXJuIHZhbHVlIGZyb20gYHBhcnNlYC5cbiAgICogQHBhcmFtIHJ1bm5lciB0aGUgcnVubmVyIGV2YWx1YXRpbmcgdGhpcyBjYWxsYmFjay5cbiAgICogQHJldHVybnMgYSBzdHJpbmcgdG8gc2VuZCBiYWNrIHRvIE9wZW5BSS5cbiAgICovXG4gIGZ1bmN0aW9uOiAoXG4gICAgYXJnczogQXJncyxcbiAgICBydW5uZXI6IENoYXRDb21wbGV0aW9uUnVubmVyPHVua25vd24+IHwgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXI8dW5rbm93bj4sXG4gICkgPT4gUHJvbWlzZU9yVmFsdWU8dW5rbm93bj47XG4gIC8qKlxuICAgKiBAcGFyYW0gaW5wdXQgdGhlIHJhdyBhcmdzIGZyb20gdGhlIE9wZW5BSSBmdW5jdGlvbiBjYWxsLlxuICAgKiBAcmV0dXJucyB0aGUgcGFyc2VkIGFyZ3VtZW50cyB0byBwYXNzIHRvIGBmdW5jdGlvbmBcbiAgICovXG4gIHBhcnNlOiAoaW5wdXQ6IHN0cmluZykgPT4gUHJvbWlzZU9yVmFsdWU8QXJncz47XG4gIC8qKlxuICAgKiBUaGUgcGFyYW1ldGVycyB0aGUgZnVuY3Rpb24gYWNjZXB0cywgZGVzY3JpYmVzIGFzIGEgSlNPTiBTY2hlbWEgb2JqZWN0LlxuICAgKi9cbiAgcGFyYW1ldGVyczogSlNPTlNjaGVtYTtcbiAgLyoqXG4gICAqIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgZnVuY3Rpb24gZG9lcywgdXNlZCBieSB0aGUgbW9kZWwgdG8gY2hvb3NlIHdoZW4gYW5kIGhvdyB0byBjYWxsIHRoZSBmdW5jdGlvbi5cbiAgICovXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLiBXaWxsIGRlZmF1bHQgdG8gZnVuY3Rpb24ubmFtZSBpZiBvbWl0dGVkLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgc3RyaWN0PzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCB0eXBlIFJ1bm5hYmxlRnVuY3Rpb25XaXRob3V0UGFyc2UgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gYXJncyB0aGUgcmF3IGFyZ3MgZnJvbSB0aGUgT3BlbkFJIGZ1bmN0aW9uIGNhbGwuXG4gICAqIEByZXR1cm5zIGEgc3RyaW5nIHRvIHNlbmQgYmFjayB0byBPcGVuQUlcbiAgICovXG4gIGZ1bmN0aW9uOiAoXG4gICAgYXJnczogc3RyaW5nLFxuICAgIHJ1bm5lcjogQ2hhdENvbXBsZXRpb25SdW5uZXI8dW5rbm93bj4gfCBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcjx1bmtub3duPixcbiAgKSA9PiBQcm9taXNlT3JWYWx1ZTx1bmtub3duPjtcbiAgLyoqXG4gICAqIFRoZSBwYXJhbWV0ZXJzIHRoZSBmdW5jdGlvbiBhY2NlcHRzLCBkZXNjcmliZXMgYXMgYSBKU09OIFNjaGVtYSBvYmplY3QuXG4gICAqL1xuICBwYXJhbWV0ZXJzOiBKU09OU2NoZW1hO1xuICAvKipcbiAgICogQSBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoZSBmdW5jdGlvbiBkb2VzLCB1c2VkIGJ5IHRoZSBtb2RlbCB0byBjaG9vc2Ugd2hlbiBhbmQgaG93IHRvIGNhbGwgdGhlIGZ1bmN0aW9uLlxuICAgKi9cbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQuIFdpbGwgZGVmYXVsdCB0byBmdW5jdGlvbi5uYW1lIGlmIG9taXR0ZWQuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBzdHJpY3Q/OiBib29sZWFuIHwgdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IHR5cGUgUnVubmFibGVGdW5jdGlvbjxBcmdzIGV4dGVuZHMgb2JqZWN0IHwgc3RyaW5nPiA9XG4gIEFyZ3MgZXh0ZW5kcyBzdHJpbmcgPyBSdW5uYWJsZUZ1bmN0aW9uV2l0aG91dFBhcnNlXG4gIDogQXJncyBleHRlbmRzIG9iamVjdCA/IFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncz5cbiAgOiBuZXZlcjtcblxuZXhwb3J0IHR5cGUgUnVubmFibGVUb29sRnVuY3Rpb248QXJncyBleHRlbmRzIG9iamVjdCB8IHN0cmluZz4gPVxuICBBcmdzIGV4dGVuZHMgc3RyaW5nID8gUnVubmFibGVUb29sRnVuY3Rpb25XaXRob3V0UGFyc2VcbiAgOiBBcmdzIGV4dGVuZHMgb2JqZWN0ID8gUnVubmFibGVUb29sRnVuY3Rpb25XaXRoUGFyc2U8QXJncz5cbiAgOiBuZXZlcjtcblxuZXhwb3J0IHR5cGUgUnVubmFibGVUb29sRnVuY3Rpb25XaXRob3V0UGFyc2UgPSB7XG4gIHR5cGU6ICdmdW5jdGlvbic7XG4gIGZ1bmN0aW9uOiBSdW5uYWJsZUZ1bmN0aW9uV2l0aG91dFBhcnNlO1xufTtcbmV4cG9ydCB0eXBlIFJ1bm5hYmxlVG9vbEZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3MgZXh0ZW5kcyBvYmplY3Q+ID0ge1xuICB0eXBlOiAnZnVuY3Rpb24nO1xuICBmdW5jdGlvbjogUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzPjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1J1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncyBleHRlbmRzIG9iamVjdD4oXG4gIGZuOiBhbnksXG4pOiBmbiBpcyBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3M+IHtcbiAgcmV0dXJuIHR5cGVvZiAoZm4gYXMgYW55KS5wYXJzZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IHR5cGUgQmFzZUZ1bmN0aW9uc0FyZ3MgPSByZWFkb25seSAob2JqZWN0IHwgc3RyaW5nKVtdO1xuXG5leHBvcnQgdHlwZSBSdW5uYWJsZUZ1bmN0aW9uczxGdW5jdGlvbnNBcmdzIGV4dGVuZHMgQmFzZUZ1bmN0aW9uc0FyZ3M+ID1cbiAgW2FueVtdXSBleHRlbmRzIFtGdW5jdGlvbnNBcmdzXSA/IHJlYWRvbmx5IFJ1bm5hYmxlRnVuY3Rpb248YW55PltdXG4gIDoge1xuICAgICAgW0luZGV4IGluIGtleW9mIEZ1bmN0aW9uc0FyZ3NdOiBJbmRleCBleHRlbmRzIG51bWJlciA/IFJ1bm5hYmxlRnVuY3Rpb248RnVuY3Rpb25zQXJnc1tJbmRleF0+XG4gICAgICA6IEZ1bmN0aW9uc0FyZ3NbSW5kZXhdO1xuICAgIH07XG5cbmV4cG9ydCB0eXBlIFJ1bm5hYmxlVG9vbHM8RnVuY3Rpb25zQXJncyBleHRlbmRzIEJhc2VGdW5jdGlvbnNBcmdzPiA9XG4gIFthbnlbXV0gZXh0ZW5kcyBbRnVuY3Rpb25zQXJnc10gPyByZWFkb25seSBSdW5uYWJsZVRvb2xGdW5jdGlvbjxhbnk+W11cbiAgOiB7XG4gICAgICBbSW5kZXggaW4ga2V5b2YgRnVuY3Rpb25zQXJnc106IEluZGV4IGV4dGVuZHMgbnVtYmVyID8gUnVubmFibGVUb29sRnVuY3Rpb248RnVuY3Rpb25zQXJnc1tJbmRleF0+XG4gICAgICA6IEZ1bmN0aW9uc0FyZ3NbSW5kZXhdO1xuICAgIH07XG5cbi8qKlxuICogVGhpcyBpcyBoZWxwZXIgY2xhc3MgZm9yIHBhc3NpbmcgYSBgZnVuY3Rpb25gIGFuZCBgcGFyc2VgIHdoZXJlIHRoZSBgZnVuY3Rpb25gXG4gKiBhcmd1bWVudCB0eXBlIG1hdGNoZXMgdGhlIGBwYXJzZWAgcmV0dXJuIHR5cGUuXG4gKlxuICogQGRlcHJlY2F0ZWQgLSBwbGVhc2UgdXNlIFBhcnNpbmdUb29sRnVuY3Rpb24gaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnNpbmdGdW5jdGlvbjxBcmdzIGV4dGVuZHMgb2JqZWN0PiB7XG4gIGZ1bmN0aW9uOiBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3M+WydmdW5jdGlvbiddO1xuICBwYXJzZTogUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzPlsncGFyc2UnXTtcbiAgcGFyYW1ldGVyczogUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzPlsncGFyYW1ldGVycyddO1xuICBkZXNjcmlwdGlvbjogUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzPlsnZGVzY3JpcHRpb24nXTtcbiAgbmFtZT86IFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2U8QXJncz5bJ25hbWUnXTtcblxuICBjb25zdHJ1Y3RvcihpbnB1dDogUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZTxBcmdzPikge1xuICAgIHRoaXMuZnVuY3Rpb24gPSBpbnB1dC5mdW5jdGlvbjtcbiAgICB0aGlzLnBhcnNlID0gaW5wdXQucGFyc2U7XG4gICAgdGhpcy5wYXJhbWV0ZXJzID0gaW5wdXQucGFyYW1ldGVycztcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gaW5wdXQuZGVzY3JpcHRpb247XG4gICAgdGhpcy5uYW1lID0gaW5wdXQubmFtZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgaGVscGVyIGNsYXNzIGZvciBwYXNzaW5nIGEgYGZ1bmN0aW9uYCBhbmQgYHBhcnNlYCB3aGVyZSB0aGUgYGZ1bmN0aW9uYFxuICogYXJndW1lbnQgdHlwZSBtYXRjaGVzIHRoZSBgcGFyc2VgIHJldHVybiB0eXBlLlxuICovXG5leHBvcnQgY2xhc3MgUGFyc2luZ1Rvb2xGdW5jdGlvbjxBcmdzIGV4dGVuZHMgb2JqZWN0PiB7XG4gIHR5cGU6ICdmdW5jdGlvbic7XG4gIGZ1bmN0aW9uOiBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3M+O1xuXG4gIGNvbnN0cnVjdG9yKGlucHV0OiBSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlPEFyZ3M+KSB7XG4gICAgdGhpcy50eXBlID0gJ2Z1bmN0aW9uJztcbiAgICB0aGlzLmZ1bmN0aW9uID0gaW5wdXQ7XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICB0eXBlIENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtLFxuICB0eXBlIENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW0sXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0sXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sTWVzc2FnZVBhcmFtLFxufSBmcm9tICcuLi9yZXNvdXJjZXMnO1xuXG5leHBvcnQgY29uc3QgaXNBc3Npc3RhbnRNZXNzYWdlID0gKFxuICBtZXNzYWdlOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSB8IG51bGwgfCB1bmRlZmluZWQsXG4pOiBtZXNzYWdlIGlzIENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtID0+IHtcbiAgcmV0dXJuIG1lc3NhZ2U/LnJvbGUgPT09ICdhc3Npc3RhbnQnO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb25NZXNzYWdlID0gKFxuICBtZXNzYWdlOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSB8IG51bGwgfCB1bmRlZmluZWQsXG4pOiBtZXNzYWdlIGlzIENoYXRDb21wbGV0aW9uRnVuY3Rpb25NZXNzYWdlUGFyYW0gPT4ge1xuICByZXR1cm4gbWVzc2FnZT8ucm9sZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbmV4cG9ydCBjb25zdCBpc1Rvb2xNZXNzYWdlID0gKFxuICBtZXNzYWdlOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSB8IG51bGwgfCB1bmRlZmluZWQsXG4pOiBtZXNzYWdlIGlzIENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbSA9PiB7XG4gIHJldHVybiBtZXNzYWdlPy5yb2xlID09PSAndG9vbCc7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNQcmVzZW50PFQ+KG9iajogVCB8IG51bGwgfCB1bmRlZmluZWQpOiBvYmogaXMgVCB7XG4gIHJldHVybiBvYmogIT0gbnVsbDtcbn1cbiIsICJpbXBvcnQgeyBBUElVc2VyQWJvcnRFcnJvciwgT3BlbkFJRXJyb3IgfSBmcm9tICcuLi9lcnJvcic7XG5cbmV4cG9ydCBjbGFzcyBFdmVudFN0cmVhbTxFdmVudFR5cGVzIGV4dGVuZHMgQmFzZUV2ZW50cz4ge1xuICBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cbiAgI2Nvbm5lY3RlZFByb21pc2U6IFByb21pc2U8dm9pZD47XG4gICNyZXNvbHZlQ29ubmVjdGVkUHJvbWlzZTogKCkgPT4gdm9pZCA9ICgpID0+IHt9O1xuICAjcmVqZWN0Q29ubmVjdGVkUHJvbWlzZTogKGVycm9yOiBPcGVuQUlFcnJvcikgPT4gdm9pZCA9ICgpID0+IHt9O1xuXG4gICNlbmRQcm9taXNlOiBQcm9taXNlPHZvaWQ+O1xuICAjcmVzb2x2ZUVuZFByb21pc2U6ICgpID0+IHZvaWQgPSAoKSA9PiB7fTtcbiAgI3JlamVjdEVuZFByb21pc2U6IChlcnJvcjogT3BlbkFJRXJyb3IpID0+IHZvaWQgPSAoKSA9PiB7fTtcblxuICAjbGlzdGVuZXJzOiB7XG4gICAgW0V2ZW50IGluIGtleW9mIEV2ZW50VHlwZXNdPzogRXZlbnRMaXN0ZW5lcnM8RXZlbnRUeXBlcywgRXZlbnQ+O1xuICB9ID0ge307XG5cbiAgI2VuZGVkID0gZmFsc2U7XG4gICNlcnJvcmVkID0gZmFsc2U7XG4gICNhYm9ydGVkID0gZmFsc2U7XG4gICNjYXRjaGluZ1Byb21pc2VDcmVhdGVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy4jY29ubmVjdGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuI3Jlc29sdmVDb25uZWN0ZWRQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMuI3JlamVjdENvbm5lY3RlZFByb21pc2UgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB0aGlzLiNlbmRQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy4jcmVzb2x2ZUVuZFByb21pc2UgPSByZXNvbHZlO1xuICAgICAgdGhpcy4jcmVqZWN0RW5kUHJvbWlzZSA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIC8vIERvbid0IGxldCB0aGVzZSBwcm9taXNlcyBjYXVzZSB1bmhhbmRsZWQgcmVqZWN0aW9uIGVycm9ycy5cbiAgICAvLyB3ZSB3aWxsIG1hbnVhbGx5IGNhdXNlIGFuIHVuaGFuZGxlZCByZWplY3Rpb24gZXJyb3IgbGF0ZXJcbiAgICAvLyBpZiB0aGUgdXNlciBoYXNuJ3QgcmVnaXN0ZXJlZCBhbnkgZXJyb3IgbGlzdGVuZXIgb3IgY2FsbGVkXG4gICAgLy8gYW55IHByb21pc2UtcmV0dXJuaW5nIG1ldGhvZC5cbiAgICB0aGlzLiNjb25uZWN0ZWRQcm9taXNlLmNhdGNoKCgpID0+IHt9KTtcbiAgICB0aGlzLiNlbmRQcm9taXNlLmNhdGNoKCgpID0+IHt9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfcnVuKHRoaXM6IEV2ZW50U3RyZWFtPEV2ZW50VHlwZXM+LCBleGVjdXRvcjogKCkgPT4gUHJvbWlzZTxhbnk+KSB7XG4gICAgLy8gVW5mb3J0dW5hdGVseSBpZiB3ZSBjYWxsIGBleGVjdXRvcigpYCBpbW1lZGlhdGVseSB3ZSBnZXQgcnVudGltZSBlcnJvcnMgYWJvdXRcbiAgICAvLyByZWZlcmVuY2VzIHRvIGB0aGlzYCBiZWZvcmUgdGhlIGBzdXBlcigpYCBjb25zdHJ1Y3RvciBjYWxsIHJldHVybnMuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBleGVjdXRvcigpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbWl0RmluYWwoKTtcbiAgICAgICAgdGhpcy5fZW1pdCgnZW5kJyk7XG4gICAgICB9LCB0aGlzLiNoYW5kbGVFcnJvci5iaW5kKHRoaXMpKTtcbiAgICB9LCAwKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY29ubmVjdGVkKHRoaXM6IEV2ZW50U3RyZWFtPEV2ZW50VHlwZXM+KSB7XG4gICAgaWYgKHRoaXMuZW5kZWQpIHJldHVybjtcbiAgICB0aGlzLiNyZXNvbHZlQ29ubmVjdGVkUHJvbWlzZSgpO1xuICAgIHRoaXMuX2VtaXQoJ2Nvbm5lY3QnKTtcbiAgfVxuXG4gIGdldCBlbmRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy4jZW5kZWQ7XG4gIH1cblxuICBnZXQgZXJyb3JlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy4jZXJyb3JlZDtcbiAgfVxuXG4gIGdldCBhYm9ydGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLiNhYm9ydGVkO1xuICB9XG5cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGZvciB0aGUgZXZlbnQuXG4gICAqIE5vIGNoZWNrcyBhcmUgbWFkZSB0byBzZWUgaWYgdGhlIGxpc3RlbmVyIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQuIE11bHRpcGxlIGNhbGxzIHBhc3NpbmdcbiAgICogdGhlIHNhbWUgY29tYmluYXRpb24gb2YgZXZlbnQgYW5kIGxpc3RlbmVyIHdpbGwgcmVzdWx0IGluIHRoZSBsaXN0ZW5lciBiZWluZyBhZGRlZCwgYW5kXG4gICAqIGNhbGxlZCwgbXVsdGlwbGUgdGltZXMuXG4gICAqIEByZXR1cm5zIHRoaXMgQ2hhdENvbXBsZXRpb25TdHJlYW0sIHNvIHRoYXQgY2FsbHMgY2FuIGJlIGNoYWluZWRcbiAgICovXG4gIG9uPEV2ZW50IGV4dGVuZHMga2V5b2YgRXZlbnRUeXBlcz4oZXZlbnQ6IEV2ZW50LCBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjxFdmVudFR5cGVzLCBFdmVudD4pOiB0aGlzIHtcbiAgICBjb25zdCBsaXN0ZW5lcnM6IEV2ZW50TGlzdGVuZXJzPEV2ZW50VHlwZXMsIEV2ZW50PiA9XG4gICAgICB0aGlzLiNsaXN0ZW5lcnNbZXZlbnRdIHx8ICh0aGlzLiNsaXN0ZW5lcnNbZXZlbnRdID0gW10pO1xuICAgIGxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIGZyb20gdGhlIGxpc3RlbmVyIGFycmF5IGZvciB0aGUgZXZlbnQuXG4gICAqIG9mZigpIHdpbGwgcmVtb3ZlLCBhdCBtb3N0LCBvbmUgaW5zdGFuY2Ugb2YgYSBsaXN0ZW5lciBmcm9tIHRoZSBsaXN0ZW5lciBhcnJheS4gSWYgYW55IHNpbmdsZVxuICAgKiBsaXN0ZW5lciBoYXMgYmVlbiBhZGRlZCBtdWx0aXBsZSB0aW1lcyB0byB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQsIHRoZW5cbiAgICogb2ZmKCkgbXVzdCBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgdG8gcmVtb3ZlIGVhY2ggaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHRoaXMgQ2hhdENvbXBsZXRpb25TdHJlYW0sIHNvIHRoYXQgY2FsbHMgY2FuIGJlIGNoYWluZWRcbiAgICovXG4gIG9mZjxFdmVudCBleHRlbmRzIGtleW9mIEV2ZW50VHlwZXM+KGV2ZW50OiBFdmVudCwgbGlzdGVuZXI6IEV2ZW50TGlzdGVuZXI8RXZlbnRUeXBlcywgRXZlbnQ+KTogdGhpcyB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy4jbGlzdGVuZXJzW2V2ZW50XTtcbiAgICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuZmluZEluZGV4KChsKSA9PiBsLmxpc3RlbmVyID09PSBsaXN0ZW5lcik7XG4gICAgaWYgKGluZGV4ID49IDApIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBvbmUtdGltZSBsaXN0ZW5lciBmdW5jdGlvbiBmb3IgdGhlIGV2ZW50LiBUaGUgbmV4dCB0aW1lIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQsXG4gICAqIHRoaXMgbGlzdGVuZXIgaXMgcmVtb3ZlZCBhbmQgdGhlbiBpbnZva2VkLlxuICAgKiBAcmV0dXJucyB0aGlzIENoYXRDb21wbGV0aW9uU3RyZWFtLCBzbyB0aGF0IGNhbGxzIGNhbiBiZSBjaGFpbmVkXG4gICAqL1xuICBvbmNlPEV2ZW50IGV4dGVuZHMga2V5b2YgRXZlbnRUeXBlcz4oZXZlbnQ6IEV2ZW50LCBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjxFdmVudFR5cGVzLCBFdmVudD4pOiB0aGlzIHtcbiAgICBjb25zdCBsaXN0ZW5lcnM6IEV2ZW50TGlzdGVuZXJzPEV2ZW50VHlwZXMsIEV2ZW50PiA9XG4gICAgICB0aGlzLiNsaXN0ZW5lcnNbZXZlbnRdIHx8ICh0aGlzLiNsaXN0ZW5lcnNbZXZlbnRdID0gW10pO1xuICAgIGxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IHRydWUgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBzaW1pbGFyIHRvIGAub25jZSgpYCwgYnV0IHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdGhlIG5leHQgdGltZVxuICAgKiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLCBpbnN0ZWFkIG9mIGNhbGxpbmcgYSBsaXN0ZW5lciBjYWxsYmFjay5cbiAgICogQHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdGhlIG5leHQgdGltZSBnaXZlbiBldmVudCBpcyB0cmlnZ2VyZWQsXG4gICAqIG9yIHJlamVjdHMgaWYgYW4gZXJyb3IgaXMgZW1pdHRlZC4gIChJZiB5b3UgcmVxdWVzdCB0aGUgJ2Vycm9yJyBldmVudCxcbiAgICogcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBlcnJvcikuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHN0cmVhbS5lbWl0dGVkKCdtZXNzYWdlJykgLy8gcmVqZWN0cyBpZiB0aGUgc3RyZWFtIGVycm9yc1xuICAgKi9cbiAgZW1pdHRlZDxFdmVudCBleHRlbmRzIGtleW9mIEV2ZW50VHlwZXM+KFxuICAgIGV2ZW50OiBFdmVudCxcbiAgKTogUHJvbWlzZTxcbiAgICBFdmVudFBhcmFtZXRlcnM8RXZlbnRUeXBlcywgRXZlbnQ+IGV4dGVuZHMgW2luZmVyIFBhcmFtXSA/IFBhcmFtXG4gICAgOiBFdmVudFBhcmFtZXRlcnM8RXZlbnRUeXBlcywgRXZlbnQ+IGV4dGVuZHMgW10gPyB2b2lkXG4gICAgOiBFdmVudFBhcmFtZXRlcnM8RXZlbnRUeXBlcywgRXZlbnQ+XG4gID4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLiNjYXRjaGluZ1Byb21pc2VDcmVhdGVkID0gdHJ1ZTtcbiAgICAgIGlmIChldmVudCAhPT0gJ2Vycm9yJykgdGhpcy5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICB0aGlzLm9uY2UoZXZlbnQsIHJlc29sdmUgYXMgYW55KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGRvbmUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy4jY2F0Y2hpbmdQcm9taXNlQ3JlYXRlZCA9IHRydWU7XG4gICAgYXdhaXQgdGhpcy4jZW5kUHJvbWlzZTtcbiAgfVxuXG4gICNoYW5kbGVFcnJvcih0aGlzOiBFdmVudFN0cmVhbTxFdmVudFR5cGVzPiwgZXJyb3I6IHVua25vd24pIHtcbiAgICB0aGlzLiNlcnJvcmVkID0gdHJ1ZTtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgIGVycm9yID0gbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFQSVVzZXJBYm9ydEVycm9yKSB7XG4gICAgICB0aGlzLiNhYm9ydGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLl9lbWl0KCdhYm9ydCcsIGVycm9yKTtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgT3BlbkFJRXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGNvbnN0IG9wZW5BSUVycm9yOiBPcGVuQUlFcnJvciA9IG5ldyBPcGVuQUlFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIG9wZW5BSUVycm9yLmNhdXNlID0gZXJyb3I7XG4gICAgICByZXR1cm4gdGhpcy5fZW1pdCgnZXJyb3InLCBvcGVuQUlFcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lbWl0KCdlcnJvcicsIG5ldyBPcGVuQUlFcnJvcihTdHJpbmcoZXJyb3IpKSk7XG4gIH1cblxuICBfZW1pdDxFdmVudCBleHRlbmRzIGtleW9mIEJhc2VFdmVudHM+KGV2ZW50OiBFdmVudCwgLi4uYXJnczogRXZlbnRQYXJhbWV0ZXJzPEJhc2VFdmVudHMsIEV2ZW50Pik6IHZvaWQ7XG4gIF9lbWl0PEV2ZW50IGV4dGVuZHMga2V5b2YgRXZlbnRUeXBlcz4oZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiBFdmVudFBhcmFtZXRlcnM8RXZlbnRUeXBlcywgRXZlbnQ+KTogdm9pZDtcbiAgX2VtaXQ8RXZlbnQgZXh0ZW5kcyBrZXlvZiBFdmVudFR5cGVzPihcbiAgICB0aGlzOiBFdmVudFN0cmVhbTxFdmVudFR5cGVzPixcbiAgICBldmVudDogRXZlbnQsXG4gICAgLi4uYXJnczogRXZlbnRQYXJhbWV0ZXJzPEV2ZW50VHlwZXMsIEV2ZW50PlxuICApIHtcbiAgICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3QgZW1pdCBhbnkgZXZlbnRzIGFmdGVyIGVuZFxuICAgIGlmICh0aGlzLiNlbmRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudCA9PT0gJ2VuZCcpIHtcbiAgICAgIHRoaXMuI2VuZGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuI3Jlc29sdmVFbmRQcm9taXNlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdGVuZXJzOiBFdmVudExpc3RlbmVyczxFdmVudFR5cGVzLCBFdmVudD4gfCB1bmRlZmluZWQgPSB0aGlzLiNsaXN0ZW5lcnNbZXZlbnRdO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuI2xpc3RlbmVyc1tldmVudF0gPSBsaXN0ZW5lcnMuZmlsdGVyKChsKSA9PiAhbC5vbmNlKSBhcyBhbnk7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoeyBsaXN0ZW5lciB9OiBhbnkpID0+IGxpc3RlbmVyKC4uLihhcmdzIGFzIGFueSkpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQgPT09ICdhYm9ydCcpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gYXJnc1swXSBhcyBBUElVc2VyQWJvcnRFcnJvcjtcbiAgICAgIGlmICghdGhpcy4jY2F0Y2hpbmdQcm9taXNlQ3JlYXRlZCAmJiAhbGlzdGVuZXJzPy5sZW5ndGgpIHtcbiAgICAgICAgUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgdGhpcy4jcmVqZWN0Q29ubmVjdGVkUHJvbWlzZShlcnJvcik7XG4gICAgICB0aGlzLiNyZWplY3RFbmRQcm9taXNlKGVycm9yKTtcbiAgICAgIHRoaXMuX2VtaXQoJ2VuZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudCA9PT0gJ2Vycm9yJykge1xuICAgICAgLy8gTk9URTogX2VtaXQoJ2Vycm9yJywgZXJyb3IpIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBmcm9tICNoYW5kbGVFcnJvcigpLlxuXG4gICAgICBjb25zdCBlcnJvciA9IGFyZ3NbMF0gYXMgT3BlbkFJRXJyb3I7XG4gICAgICBpZiAoIXRoaXMuI2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQgJiYgIWxpc3RlbmVycz8ubGVuZ3RoKSB7XG4gICAgICAgIC8vIFRyaWdnZXIgYW4gdW5oYW5kbGVkIHJlamVjdGlvbiBpZiB0aGUgdXNlciBoYXNuJ3QgcmVnaXN0ZXJlZCBhbnkgZXJyb3IgaGFuZGxlcnMuXG4gICAgICAgIC8vIElmIHlvdSBhcmUgc2VlaW5nIHN0YWNrIHRyYWNlcyBoZXJlLCBtYWtlIHN1cmUgdG8gaGFuZGxlIGVycm9ycyB2aWEgZWl0aGVyOlxuICAgICAgICAvLyAtIHJ1bm5lci5vbignZXJyb3InLCAoKSA9PiAuLi4pXG4gICAgICAgIC8vIC0gYXdhaXQgcnVubmVyLmRvbmUoKVxuICAgICAgICAvLyAtIGF3YWl0IHJ1bm5lci5maW5hbENoYXRDb21wbGV0aW9uKClcbiAgICAgICAgLy8gLSBldGMuXG4gICAgICAgIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3JlamVjdENvbm5lY3RlZFByb21pc2UoZXJyb3IpO1xuICAgICAgdGhpcy4jcmVqZWN0RW5kUHJvbWlzZShlcnJvcik7XG4gICAgICB0aGlzLl9lbWl0KCdlbmQnKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2VtaXRGaW5hbCgpOiB2b2lkIHt9XG59XG5cbnR5cGUgRXZlbnRMaXN0ZW5lcjxFdmVudHMsIEV2ZW50VHlwZSBleHRlbmRzIGtleW9mIEV2ZW50cz4gPSBFdmVudHNbRXZlbnRUeXBlXTtcblxudHlwZSBFdmVudExpc3RlbmVyczxFdmVudHMsIEV2ZW50VHlwZSBleHRlbmRzIGtleW9mIEV2ZW50cz4gPSBBcnJheTx7XG4gIGxpc3RlbmVyOiBFdmVudExpc3RlbmVyPEV2ZW50cywgRXZlbnRUeXBlPjtcbiAgb25jZT86IGJvb2xlYW47XG59PjtcblxuZXhwb3J0IHR5cGUgRXZlbnRQYXJhbWV0ZXJzPEV2ZW50cywgRXZlbnRUeXBlIGV4dGVuZHMga2V5b2YgRXZlbnRzPiA9IHtcbiAgW0V2ZW50IGluIEV2ZW50VHlwZV06IEV2ZW50TGlzdGVuZXI8RXZlbnRzLCBFdmVudFR5cGU+IGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFApID0+IGFueSA/IFAgOiBuZXZlcjtcbn1bRXZlbnRUeXBlXTtcblxuZXhwb3J0IGludGVyZmFjZSBCYXNlRXZlbnRzIHtcbiAgY29ubmVjdDogKCkgPT4gdm9pZDtcbiAgZXJyb3I6IChlcnJvcjogT3BlbkFJRXJyb3IpID0+IHZvaWQ7XG4gIGFib3J0OiAoZXJyb3I6IEFQSVVzZXJBYm9ydEVycm9yKSA9PiB2b2lkO1xuICBlbmQ6ICgpID0+IHZvaWQ7XG59XG4iLCAiaW1wb3J0IHtcbiAgQ2hhdENvbXBsZXRpb24sXG4gIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCxcbiAgQ2hhdENvbXBsZXRpb25Ub29sLFxufSBmcm9tICcuLi9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucyc7XG5pbXBvcnQge1xuICBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1Rvb2xSdW5uZXJQYXJhbXMsXG4gIENoYXRDb21wbGV0aW9uU3RyZWFtUGFyYW1zLFxuICBDaGF0Q29tcGxldGlvblRvb2xSdW5uZXJQYXJhbXMsXG4gIFBhcnNlZENoYXRDb21wbGV0aW9uLFxuICBQYXJzZWRDaG9pY2UsXG4gIFBhcnNlZEZ1bmN0aW9uVG9vbENhbGwsXG59IGZyb20gJy4uL3Jlc291cmNlcy9iZXRhL2NoYXQvY29tcGxldGlvbnMnO1xuaW1wb3J0IHsgUmVzcG9uc2VGb3JtYXRKU09OU2NoZW1hIH0gZnJvbSAnLi4vcmVzb3VyY2VzL3NoYXJlZCc7XG5pbXBvcnQgeyBDb250ZW50RmlsdGVyRmluaXNoUmVhc29uRXJyb3IsIExlbmd0aEZpbmlzaFJlYXNvbkVycm9yLCBPcGVuQUlFcnJvciB9IGZyb20gJy4uL2Vycm9yJztcblxudHlwZSBBbnlDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyA9XG4gIHwgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNcbiAgfCBDaGF0Q29tcGxldGlvblRvb2xSdW5uZXJQYXJhbXM8YW55PlxuICB8IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nVG9vbFJ1bm5lclBhcmFtczxhbnk+XG4gIHwgQ2hhdENvbXBsZXRpb25TdHJlYW1QYXJhbXM7XG5cbmV4cG9ydCB0eXBlIEV4dHJhY3RQYXJzZWRDb250ZW50RnJvbVBhcmFtczxQYXJhbXMgZXh0ZW5kcyBBbnlDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcz4gPVxuICBQYXJhbXNbJ3Jlc3BvbnNlX2Zvcm1hdCddIGV4dGVuZHMgQXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0PGluZmVyIFA+ID8gUCA6IG51bGw7XG5cbmV4cG9ydCB0eXBlIEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdDxQYXJzZWRUPiA9IFJlc3BvbnNlRm9ybWF0SlNPTlNjaGVtYSAmIHtcbiAgX19vdXRwdXQ6IFBhcnNlZFQ7IC8vIHR5cGUtbGV2ZWwgb25seVxuXG4gICRicmFuZDogJ2F1dG8tcGFyc2VhYmxlLXJlc3BvbnNlLWZvcm1hdCc7XG4gICRwYXJzZVJhdyhjb250ZW50OiBzdHJpbmcpOiBQYXJzZWRUO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQYXJzZWFibGVSZXNwb25zZUZvcm1hdDxQYXJzZWRUPihcbiAgcmVzcG9uc2VfZm9ybWF0OiBSZXNwb25zZUZvcm1hdEpTT05TY2hlbWEsXG4gIHBhcnNlcjogKGNvbnRlbnQ6IHN0cmluZykgPT4gUGFyc2VkVCxcbik6IEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdDxQYXJzZWRUPiB7XG4gIGNvbnN0IG9iaiA9IHsgLi4ucmVzcG9uc2VfZm9ybWF0IH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqLCB7XG4gICAgJGJyYW5kOiB7XG4gICAgICB2YWx1ZTogJ2F1dG8tcGFyc2VhYmxlLXJlc3BvbnNlLWZvcm1hdCcsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgICRwYXJzZVJhdzoge1xuICAgICAgdmFsdWU6IHBhcnNlcixcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0sXG4gIH0pO1xuXG4gIHJldHVybiBvYmogYXMgQXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0PFBhcnNlZFQ+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRvUGFyc2FibGVSZXNwb25zZUZvcm1hdDxQYXJzZWRUPihcbiAgcmVzcG9uc2VfZm9ybWF0OiBhbnksXG4pOiByZXNwb25zZV9mb3JtYXQgaXMgQXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0PFBhcnNlZFQ+IHtcbiAgcmV0dXJuIHJlc3BvbnNlX2Zvcm1hdD8uWyckYnJhbmQnXSA9PT0gJ2F1dG8tcGFyc2VhYmxlLXJlc3BvbnNlLWZvcm1hdCc7XG59XG5cbnR5cGUgVG9vbE9wdGlvbnMgPSB7XG4gIG5hbWU6IHN0cmluZztcbiAgYXJndW1lbnRzOiBhbnk7XG4gIGZ1bmN0aW9uPzogKChhcmdzOiBhbnkpID0+IGFueSkgfCB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgdHlwZSBBdXRvUGFyc2VhYmxlVG9vbDxcbiAgT3B0aW9uc1QgZXh0ZW5kcyBUb29sT3B0aW9ucyxcbiAgSGFzRnVuY3Rpb24gPSBPcHRpb25zVFsnZnVuY3Rpb24nXSBleHRlbmRzIEZ1bmN0aW9uID8gdHJ1ZSA6IGZhbHNlLFxuPiA9IENoYXRDb21wbGV0aW9uVG9vbCAmIHtcbiAgX19hcmd1bWVudHM6IE9wdGlvbnNUWydhcmd1bWVudHMnXTsgLy8gdHlwZS1sZXZlbCBvbmx5XG4gIF9fbmFtZTogT3B0aW9uc1RbJ25hbWUnXTsgLy8gdHlwZS1sZXZlbCBvbmx5XG4gIF9faGFzRnVuY3Rpb246IEhhc0Z1bmN0aW9uOyAvLyB0eXBlLWxldmVsIG9ubHlcblxuICAkYnJhbmQ6ICdhdXRvLXBhcnNlYWJsZS10b29sJztcbiAgJGNhbGxiYWNrOiAoKGFyZ3M6IE9wdGlvbnNUWydhcmd1bWVudHMnXSkgPT4gYW55KSB8IHVuZGVmaW5lZDtcbiAgJHBhcnNlUmF3KGFyZ3M6IHN0cmluZyk6IE9wdGlvbnNUWydhcmd1bWVudHMnXTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUGFyc2VhYmxlVG9vbDxPcHRpb25zVCBleHRlbmRzIFRvb2xPcHRpb25zPihcbiAgdG9vbDogQ2hhdENvbXBsZXRpb25Ub29sLFxuICB7XG4gICAgcGFyc2VyLFxuICAgIGNhbGxiYWNrLFxuICB9OiB7XG4gICAgcGFyc2VyOiAoY29udGVudDogc3RyaW5nKSA9PiBPcHRpb25zVFsnYXJndW1lbnRzJ107XG4gICAgY2FsbGJhY2s6ICgoYXJnczogYW55KSA9PiBhbnkpIHwgdW5kZWZpbmVkO1xuICB9LFxuKTogQXV0b1BhcnNlYWJsZVRvb2w8T3B0aW9uc1RbJ2FyZ3VtZW50cyddPiB7XG4gIGNvbnN0IG9iaiA9IHsgLi4udG9vbCB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iaiwge1xuICAgICRicmFuZDoge1xuICAgICAgdmFsdWU6ICdhdXRvLXBhcnNlYWJsZS10b29sJyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgJHBhcnNlUmF3OiB7XG4gICAgICB2YWx1ZTogcGFyc2VyLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICAkY2FsbGJhY2s6IHtcbiAgICAgIHZhbHVlOiBjYWxsYmFjayxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0sXG4gIH0pO1xuXG4gIHJldHVybiBvYmogYXMgQXV0b1BhcnNlYWJsZVRvb2w8T3B0aW9uc1RbJ2FyZ3VtZW50cyddPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0b1BhcnNhYmxlVG9vbCh0b29sOiBhbnkpOiB0b29sIGlzIEF1dG9QYXJzZWFibGVUb29sPGFueT4ge1xuICByZXR1cm4gdG9vbD8uWyckYnJhbmQnXSA9PT0gJ2F1dG8tcGFyc2VhYmxlLXRvb2wnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVQYXJzZUNoYXRDb21wbGV0aW9uPFxuICBQYXJhbXMgZXh0ZW5kcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyB8IG51bGwsXG4gIFBhcnNlZFQgPSBQYXJhbXMgZXh0ZW5kcyBudWxsID8gbnVsbCA6IEV4dHJhY3RQYXJzZWRDb250ZW50RnJvbVBhcmFtczxOb25OdWxsYWJsZTxQYXJhbXM+Pixcbj4oY29tcGxldGlvbjogQ2hhdENvbXBsZXRpb24sIHBhcmFtczogUGFyYW1zKTogUGFyc2VkQ2hhdENvbXBsZXRpb248UGFyc2VkVD4ge1xuICBpZiAoIXBhcmFtcyB8fCAhaGFzQXV0b1BhcnNlYWJsZUlucHV0KHBhcmFtcykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29tcGxldGlvbixcbiAgICAgIGNob2ljZXM6IGNvbXBsZXRpb24uY2hvaWNlcy5tYXAoKGNob2ljZSkgPT4gKHtcbiAgICAgICAgLi4uY2hvaWNlLFxuICAgICAgICBtZXNzYWdlOiB7IC4uLmNob2ljZS5tZXNzYWdlLCBwYXJzZWQ6IG51bGwsIHRvb2xfY2FsbHM6IGNob2ljZS5tZXNzYWdlLnRvb2xfY2FsbHMgPz8gW10gfSxcbiAgICAgIH0pKSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlQ2hhdENvbXBsZXRpb24oY29tcGxldGlvbiwgcGFyYW1zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ2hhdENvbXBsZXRpb248XG4gIFBhcmFtcyBleHRlbmRzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICBQYXJzZWRUID0gRXh0cmFjdFBhcnNlZENvbnRlbnRGcm9tUGFyYW1zPFBhcmFtcz4sXG4+KGNvbXBsZXRpb246IENoYXRDb21wbGV0aW9uLCBwYXJhbXM6IFBhcmFtcyk6IFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+IHtcbiAgY29uc3QgY2hvaWNlczogQXJyYXk8UGFyc2VkQ2hvaWNlPFBhcnNlZFQ+PiA9IGNvbXBsZXRpb24uY2hvaWNlcy5tYXAoKGNob2ljZSk6IFBhcnNlZENob2ljZTxQYXJzZWRUPiA9PiB7XG4gICAgaWYgKGNob2ljZS5maW5pc2hfcmVhc29uID09PSAnbGVuZ3RoJykge1xuICAgICAgdGhyb3cgbmV3IExlbmd0aEZpbmlzaFJlYXNvbkVycm9yKCk7XG4gICAgfVxuXG4gICAgaWYgKGNob2ljZS5maW5pc2hfcmVhc29uID09PSAnY29udGVudF9maWx0ZXInKSB7XG4gICAgICB0aHJvdyBuZXcgQ29udGVudEZpbHRlckZpbmlzaFJlYXNvbkVycm9yKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNob2ljZSxcbiAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgLi4uY2hvaWNlLm1lc3NhZ2UsXG4gICAgICAgIHRvb2xfY2FsbHM6IGNob2ljZS5tZXNzYWdlLnRvb2xfY2FsbHM/Lm1hcCgodG9vbENhbGwpID0+IHBhcnNlVG9vbENhbGwocGFyYW1zLCB0b29sQ2FsbCkpID8/IFtdLFxuICAgICAgICBwYXJzZWQ6XG4gICAgICAgICAgY2hvaWNlLm1lc3NhZ2UuY29udGVudCAmJiAhY2hvaWNlLm1lc3NhZ2UucmVmdXNhbCA/XG4gICAgICAgICAgICBwYXJzZVJlc3BvbnNlRm9ybWF0KHBhcmFtcywgY2hvaWNlLm1lc3NhZ2UuY29udGVudClcbiAgICAgICAgICA6IG51bGwsXG4gICAgICB9LFxuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiB7IC4uLmNvbXBsZXRpb24sIGNob2ljZXMgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VSZXNwb25zZUZvcm1hdDxcbiAgUGFyYW1zIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gIFBhcnNlZFQgPSBFeHRyYWN0UGFyc2VkQ29udGVudEZyb21QYXJhbXM8UGFyYW1zPixcbj4ocGFyYW1zOiBQYXJhbXMsIGNvbnRlbnQ6IHN0cmluZyk6IFBhcnNlZFQgfCBudWxsIHtcbiAgaWYgKHBhcmFtcy5yZXNwb25zZV9mb3JtYXQ/LnR5cGUgIT09ICdqc29uX3NjaGVtYScpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChwYXJhbXMucmVzcG9uc2VfZm9ybWF0Py50eXBlID09PSAnanNvbl9zY2hlbWEnKSB7XG4gICAgaWYgKCckcGFyc2VSYXcnIGluIHBhcmFtcy5yZXNwb25zZV9mb3JtYXQpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlX2Zvcm1hdCA9IHBhcmFtcy5yZXNwb25zZV9mb3JtYXQgYXMgQXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0PFBhcnNlZFQ+O1xuXG4gICAgICByZXR1cm4gcmVzcG9uc2VfZm9ybWF0LiRwYXJzZVJhdyhjb250ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gSlNPTi5wYXJzZShjb250ZW50KTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRvb2xDYWxsPFBhcmFtcyBleHRlbmRzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zPihcbiAgcGFyYW1zOiBQYXJhbXMsXG4gIHRvb2xDYWxsOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCxcbik6IFBhcnNlZEZ1bmN0aW9uVG9vbENhbGwge1xuICBjb25zdCBpbnB1dFRvb2wgPSBwYXJhbXMudG9vbHM/LmZpbmQoKGlucHV0VG9vbCkgPT4gaW5wdXRUb29sLmZ1bmN0aW9uPy5uYW1lID09PSB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lKTtcbiAgcmV0dXJuIHtcbiAgICAuLi50b29sQ2FsbCxcbiAgICBmdW5jdGlvbjoge1xuICAgICAgLi4udG9vbENhbGwuZnVuY3Rpb24sXG4gICAgICBwYXJzZWRfYXJndW1lbnRzOlxuICAgICAgICBpc0F1dG9QYXJzYWJsZVRvb2woaW5wdXRUb29sKSA/IGlucHV0VG9vbC4kcGFyc2VSYXcodG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKVxuICAgICAgICA6IGlucHV0VG9vbD8uZnVuY3Rpb24uc3RyaWN0ID8gSlNPTi5wYXJzZSh0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMpXG4gICAgICAgIDogbnVsbCxcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkUGFyc2VUb29sQ2FsbChcbiAgcGFyYW1zOiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyB8IG51bGwgfCB1bmRlZmluZWQsXG4gIHRvb2xDYWxsOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCxcbik6IGJvb2xlYW4ge1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0VG9vbCA9IHBhcmFtcy50b29scz8uZmluZCgoaW5wdXRUb29sKSA9PiBpbnB1dFRvb2wuZnVuY3Rpb24/Lm5hbWUgPT09IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUpO1xuICByZXR1cm4gaXNBdXRvUGFyc2FibGVUb29sKGlucHV0VG9vbCkgfHwgaW5wdXRUb29sPy5mdW5jdGlvbi5zdHJpY3QgfHwgZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNBdXRvUGFyc2VhYmxlSW5wdXQocGFyYW1zOiBBbnlDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyk6IGJvb2xlYW4ge1xuICBpZiAoaXNBdXRvUGFyc2FibGVSZXNwb25zZUZvcm1hdChwYXJhbXMucmVzcG9uc2VfZm9ybWF0KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBwYXJhbXMudG9vbHM/LnNvbWUoXG4gICAgICAodCkgPT4gaXNBdXRvUGFyc2FibGVUb29sKHQpIHx8ICh0LnR5cGUgPT09ICdmdW5jdGlvbicgJiYgdC5mdW5jdGlvbi5zdHJpY3QgPT09IHRydWUpLFxuICAgICkgPz8gZmFsc2VcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlSW5wdXRUb29scyh0b29sczogQ2hhdENvbXBsZXRpb25Ub29sW10gfCB1bmRlZmluZWQpIHtcbiAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xzID8/IFtdKSB7XG4gICAgaWYgKHRvb2wudHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICBgQ3VycmVudGx5IG9ubHkgXFxgZnVuY3Rpb25cXGAgdG9vbCB0eXBlcyBzdXBwb3J0IGF1dG8tcGFyc2luZzsgUmVjZWl2ZWQgXFxgJHt0b29sLnR5cGV9XFxgYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRvb2wuZnVuY3Rpb24uc3RyaWN0ICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoXG4gICAgICAgIGBUaGUgXFxgJHt0b29sLmZ1bmN0aW9uLm5hbWV9XFxgIHRvb2wgaXMgbm90IG1hcmtlZCB3aXRoIFxcYHN0cmljdDogdHJ1ZVxcYC4gT25seSBzdHJpY3QgZnVuY3Rpb24gdG9vbHMgY2FuIGJlIGF1dG8tcGFyc2VkYCxcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7IHR5cGUgQ29tcGxldGlvblVzYWdlIH0gZnJvbSAnLi4vcmVzb3VyY2VzL2NvbXBsZXRpb25zJztcbmltcG9ydCB7XG4gIHR5cGUgQ2hhdENvbXBsZXRpb24sXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlLFxuICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtLFxuICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICB0eXBlIENoYXRDb21wbGV0aW9uVG9vbCxcbn0gZnJvbSAnLi4vcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMnO1xuaW1wb3J0IHsgT3BlbkFJRXJyb3IgfSBmcm9tICcuLi9lcnJvcic7XG5pbXBvcnQge1xuICB0eXBlIFJ1bm5hYmxlRnVuY3Rpb24sXG4gIGlzUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZSxcbiAgdHlwZSBCYXNlRnVuY3Rpb25zQXJncyxcbiAgUnVubmFibGVUb29sRnVuY3Rpb24sXG59IGZyb20gJy4vUnVubmFibGVGdW5jdGlvbic7XG5pbXBvcnQgeyBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uUnVubmVyUGFyYW1zLCBDaGF0Q29tcGxldGlvblRvb2xSdW5uZXJQYXJhbXMgfSBmcm9tICcuL0NoYXRDb21wbGV0aW9uUnVubmVyJztcbmltcG9ydCB7XG4gIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nRnVuY3Rpb25SdW5uZXJQYXJhbXMsXG4gIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nVG9vbFJ1bm5lclBhcmFtcyxcbn0gZnJvbSAnLi9DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcic7XG5pbXBvcnQgeyBpc0Fzc2lzdGFudE1lc3NhZ2UsIGlzRnVuY3Rpb25NZXNzYWdlLCBpc1Rvb2xNZXNzYWdlIH0gZnJvbSAnLi9jaGF0Q29tcGxldGlvblV0aWxzJztcbmltcG9ydCB7IEJhc2VFdmVudHMsIEV2ZW50U3RyZWFtIH0gZnJvbSAnLi9FdmVudFN0cmVhbSc7XG5pbXBvcnQgeyBQYXJzZWRDaGF0Q29tcGxldGlvbiB9IGZyb20gJy4uL3Jlc291cmNlcy9iZXRhL2NoYXQvY29tcGxldGlvbnMnO1xuaW1wb3J0IE9wZW5BSSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyBpc0F1dG9QYXJzYWJsZVRvb2wsIHBhcnNlQ2hhdENvbXBsZXRpb24gfSBmcm9tICcuLi9saWIvcGFyc2VyJztcblxuY29uc3QgREVGQVVMVF9NQVhfQ0hBVF9DT01QTEVUSU9OUyA9IDEwO1xuZXhwb3J0IGludGVyZmFjZSBSdW5uZXJPcHRpb25zIGV4dGVuZHMgQ29yZS5SZXF1ZXN0T3B0aW9ucyB7XG4gIC8qKiBIb3cgbWFueSByZXF1ZXN0cyB0byBtYWtlIGJlZm9yZSBjYW5jZWxpbmcuIERlZmF1bHQgMTAuICovXG4gIG1heENoYXRDb21wbGV0aW9ucz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXI8XG4gIEV2ZW50VHlwZXMgZXh0ZW5kcyBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzLFxuICBQYXJzZWRULFxuPiBleHRlbmRzIEV2ZW50U3RyZWFtPEV2ZW50VHlwZXM+IHtcbiAgcHJvdGVjdGVkIF9jaGF0Q29tcGxldGlvbnM6IFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+W10gPSBbXTtcbiAgbWVzc2FnZXM6IENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtW10gPSBbXTtcblxuICBwcm90ZWN0ZWQgX2FkZENoYXRDb21wbGV0aW9uKFxuICAgIHRoaXM6IEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXI8QWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cywgUGFyc2VkVD4sXG4gICAgY2hhdENvbXBsZXRpb246IFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+LFxuICApOiBQYXJzZWRDaGF0Q29tcGxldGlvbjxQYXJzZWRUPiB7XG4gICAgdGhpcy5fY2hhdENvbXBsZXRpb25zLnB1c2goY2hhdENvbXBsZXRpb24pO1xuICAgIHRoaXMuX2VtaXQoJ2NoYXRDb21wbGV0aW9uJywgY2hhdENvbXBsZXRpb24pO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjaGF0Q29tcGxldGlvbi5jaG9pY2VzWzBdPy5tZXNzYWdlO1xuICAgIGlmIChtZXNzYWdlKSB0aGlzLl9hZGRNZXNzYWdlKG1lc3NhZ2UgYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0pO1xuICAgIHJldHVybiBjaGF0Q29tcGxldGlvbjtcbiAgfVxuXG4gIHByb3RlY3RlZCBfYWRkTWVzc2FnZShcbiAgICB0aGlzOiBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyPEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMsIFBhcnNlZFQ+LFxuICAgIG1lc3NhZ2U6IENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtLFxuICAgIGVtaXQgPSB0cnVlLFxuICApIHtcbiAgICBpZiAoISgnY29udGVudCcgaW4gbWVzc2FnZSkpIG1lc3NhZ2UuY29udGVudCA9IG51bGw7XG5cbiAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG5cbiAgICBpZiAoZW1pdCkge1xuICAgICAgdGhpcy5fZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgaWYgKChpc0Z1bmN0aW9uTWVzc2FnZShtZXNzYWdlKSB8fCBpc1Rvb2xNZXNzYWdlKG1lc3NhZ2UpKSAmJiBtZXNzYWdlLmNvbnRlbnQpIHtcbiAgICAgICAgLy8gTm90ZSwgdGhpcyBhc3N1bWVzIHRoYXQge3JvbGU6ICd0b29sJywgY29udGVudDogXHUyMDI2fSBpcyBhbHdheXMgdGhlIHJlc3VsdCBvZiBhIGNhbGwgb2YgdG9vbCBvZiB0eXBlPWZ1bmN0aW9uLlxuICAgICAgICB0aGlzLl9lbWl0KCdmdW5jdGlvbkNhbGxSZXN1bHQnLCBtZXNzYWdlLmNvbnRlbnQgYXMgc3RyaW5nKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBc3Npc3RhbnRNZXNzYWdlKG1lc3NhZ2UpICYmIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCkge1xuICAgICAgICB0aGlzLl9lbWl0KCdmdW5jdGlvbkNhbGwnLCBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwpO1xuICAgICAgfSBlbHNlIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2UobWVzc2FnZSkgJiYgbWVzc2FnZS50b29sX2NhbGxzKSB7XG4gICAgICAgIGZvciAoY29uc3QgdG9vbF9jYWxsIG9mIG1lc3NhZ2UudG9vbF9jYWxscykge1xuICAgICAgICAgIGlmICh0b29sX2NhbGwudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fZW1pdCgnZnVuY3Rpb25DYWxsJywgdG9vbF9jYWxsLmZ1bmN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZmluYWwgQ2hhdENvbXBsZXRpb24sIG9yIHJlamVjdHNcbiAgICogaWYgYW4gZXJyb3Igb2NjdXJyZWQgb3IgdGhlIHN0cmVhbSBlbmRlZCBwcmVtYXR1cmVseSB3aXRob3V0IHByb2R1Y2luZyBhIENoYXRDb21wbGV0aW9uLlxuICAgKi9cbiAgYXN5bmMgZmluYWxDaGF0Q29tcGxldGlvbigpOiBQcm9taXNlPFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+PiB7XG4gICAgYXdhaXQgdGhpcy5kb25lKCk7XG4gICAgY29uc3QgY29tcGxldGlvbiA9IHRoaXMuX2NoYXRDb21wbGV0aW9uc1t0aGlzLl9jaGF0Q29tcGxldGlvbnMubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFjb21wbGV0aW9uKSB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoJ3N0cmVhbSBlbmRlZCB3aXRob3V0IHByb2R1Y2luZyBhIENoYXRDb21wbGV0aW9uJyk7XG4gICAgcmV0dXJuIGNvbXBsZXRpb247XG4gIH1cblxuICAjZ2V0RmluYWxDb250ZW50KCk6IHN0cmluZyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLiNnZXRGaW5hbE1lc3NhZ2UoKS5jb250ZW50ID8/IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY29udGVudCBvZiB0aGUgZmluYWwgQ2hhdENvbXBsZXRpb25NZXNzYWdlLCBvciByZWplY3RzXG4gICAqIGlmIGFuIGVycm9yIG9jY3VycmVkIG9yIHRoZSBzdHJlYW0gZW5kZWQgcHJlbWF0dXJlbHkgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbk1lc3NhZ2UuXG4gICAqL1xuICBhc3luYyBmaW5hbENvbnRlbnQoKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gICAgYXdhaXQgdGhpcy5kb25lKCk7XG4gICAgcmV0dXJuIHRoaXMuI2dldEZpbmFsQ29udGVudCgpO1xuICB9XG5cbiAgI2dldEZpbmFsTWVzc2FnZSgpOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2Uge1xuICAgIGxldCBpID0gdGhpcy5tZXNzYWdlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW2ldO1xuICAgICAgaWYgKGlzQXNzaXN0YW50TWVzc2FnZShtZXNzYWdlKSkge1xuICAgICAgICBjb25zdCB7IGZ1bmN0aW9uX2NhbGwsIC4uLnJlc3QgfSA9IG1lc3NhZ2U7XG5cbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBhdWRpbyBoZXJlXG4gICAgICAgIGNvbnN0IHJldDogT21pdDxDaGF0Q29tcGxldGlvbk1lc3NhZ2UsICdhdWRpbyc+ID0ge1xuICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgY29udGVudDogKG1lc3NhZ2UgYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlKS5jb250ZW50ID8/IG51bGwsXG4gICAgICAgICAgcmVmdXNhbDogKG1lc3NhZ2UgYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlKS5yZWZ1c2FsID8/IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmdW5jdGlvbl9jYWxsKSB7XG4gICAgICAgICAgcmV0LmZ1bmN0aW9uX2NhbGwgPSBmdW5jdGlvbl9jYWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcignc3RyZWFtIGVuZGVkIHdpdGhvdXQgcHJvZHVjaW5nIGEgQ2hhdENvbXBsZXRpb25NZXNzYWdlIHdpdGggcm9sZT1hc3Npc3RhbnQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSB0aGUgZmluYWwgYXNzaXN0YW50IENoYXRDb21wbGV0aW9uTWVzc2FnZSByZXNwb25zZSxcbiAgICogb3IgcmVqZWN0cyBpZiBhbiBlcnJvciBvY2N1cnJlZCBvciB0aGUgc3RyZWFtIGVuZGVkIHByZW1hdHVyZWx5IHdpdGhvdXQgcHJvZHVjaW5nIGEgQ2hhdENvbXBsZXRpb25NZXNzYWdlLlxuICAgKi9cbiAgYXN5bmMgZmluYWxNZXNzYWdlKCk6IFByb21pc2U8Q2hhdENvbXBsZXRpb25NZXNzYWdlPiB7XG4gICAgYXdhaXQgdGhpcy5kb25lKCk7XG4gICAgcmV0dXJuIHRoaXMuI2dldEZpbmFsTWVzc2FnZSgpO1xuICB9XG5cbiAgI2dldEZpbmFsRnVuY3Rpb25DYWxsKCk6IENoYXRDb21wbGV0aW9uTWVzc2FnZS5GdW5jdGlvbkNhbGwgfCB1bmRlZmluZWQge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLm1lc3NhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlc1tpXTtcbiAgICAgIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2UobWVzc2FnZSkgJiYgbWVzc2FnZT8uZnVuY3Rpb25fY2FsbCkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXNzaXN0YW50TWVzc2FnZShtZXNzYWdlKSAmJiBtZXNzYWdlPy50b29sX2NhbGxzPy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UudG9vbF9jYWxscy5hdCgtMSk/LmZ1bmN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBjb250ZW50IG9mIHRoZSBmaW5hbCBGdW5jdGlvbkNhbGwsIG9yIHJlamVjdHNcbiAgICogaWYgYW4gZXJyb3Igb2NjdXJyZWQgb3IgdGhlIHN0cmVhbSBlbmRlZCBwcmVtYXR1cmVseSB3aXRob3V0IHByb2R1Y2luZyBhIENoYXRDb21wbGV0aW9uTWVzc2FnZS5cbiAgICovXG4gIGFzeW5jIGZpbmFsRnVuY3Rpb25DYWxsKCk6IFByb21pc2U8Q2hhdENvbXBsZXRpb25NZXNzYWdlLkZ1bmN0aW9uQ2FsbCB8IHVuZGVmaW5lZD4ge1xuICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgIHJldHVybiB0aGlzLiNnZXRGaW5hbEZ1bmN0aW9uQ2FsbCgpO1xuICB9XG5cbiAgI2dldEZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0KCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMubWVzc2FnZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW2ldO1xuICAgICAgaWYgKGlzRnVuY3Rpb25NZXNzYWdlKG1lc3NhZ2UpICYmIG1lc3NhZ2UuY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGlzVG9vbE1lc3NhZ2UobWVzc2FnZSkgJiZcbiAgICAgICAgbWVzc2FnZS5jb250ZW50ICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5zb21lKFxuICAgICAgICAgICh4KSA9PlxuICAgICAgICAgICAgeC5yb2xlID09PSAnYXNzaXN0YW50JyAmJlxuICAgICAgICAgICAgeC50b29sX2NhbGxzPy5zb21lKCh5KSA9PiB5LnR5cGUgPT09ICdmdW5jdGlvbicgJiYgeS5pZCA9PT0gbWVzc2FnZS50b29sX2NhbGxfaWQpLFxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UuY29udGVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBhc3luYyBmaW5hbEZ1bmN0aW9uQ2FsbFJlc3VsdCgpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgIHJldHVybiB0aGlzLiNnZXRGaW5hbEZ1bmN0aW9uQ2FsbFJlc3VsdCgpO1xuICB9XG5cbiAgI2NhbGN1bGF0ZVRvdGFsVXNhZ2UoKTogQ29tcGxldGlvblVzYWdlIHtcbiAgICBjb25zdCB0b3RhbDogQ29tcGxldGlvblVzYWdlID0ge1xuICAgICAgY29tcGxldGlvbl90b2tlbnM6IDAsXG4gICAgICBwcm9tcHRfdG9rZW5zOiAwLFxuICAgICAgdG90YWxfdG9rZW5zOiAwLFxuICAgIH07XG4gICAgZm9yIChjb25zdCB7IHVzYWdlIH0gb2YgdGhpcy5fY2hhdENvbXBsZXRpb25zKSB7XG4gICAgICBpZiAodXNhZ2UpIHtcbiAgICAgICAgdG90YWwuY29tcGxldGlvbl90b2tlbnMgKz0gdXNhZ2UuY29tcGxldGlvbl90b2tlbnM7XG4gICAgICAgIHRvdGFsLnByb21wdF90b2tlbnMgKz0gdXNhZ2UucHJvbXB0X3Rva2VucztcbiAgICAgICAgdG90YWwudG90YWxfdG9rZW5zICs9IHVzYWdlLnRvdGFsX3Rva2VucztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG5cbiAgYXN5bmMgdG90YWxVc2FnZSgpOiBQcm9taXNlPENvbXBsZXRpb25Vc2FnZT4ge1xuICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgIHJldHVybiB0aGlzLiNjYWxjdWxhdGVUb3RhbFVzYWdlKCk7XG4gIH1cblxuICBhbGxDaGF0Q29tcGxldGlvbnMoKTogQ2hhdENvbXBsZXRpb25bXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9jaGF0Q29tcGxldGlvbnNdO1xuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIF9lbWl0RmluYWwoXG4gICAgdGhpczogQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcjxBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzLCBQYXJzZWRUPixcbiAgKSB7XG4gICAgY29uc3QgY29tcGxldGlvbiA9IHRoaXMuX2NoYXRDb21wbGV0aW9uc1t0aGlzLl9jaGF0Q29tcGxldGlvbnMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGNvbXBsZXRpb24pIHRoaXMuX2VtaXQoJ2ZpbmFsQ2hhdENvbXBsZXRpb24nLCBjb21wbGV0aW9uKTtcbiAgICBjb25zdCBmaW5hbE1lc3NhZ2UgPSB0aGlzLiNnZXRGaW5hbE1lc3NhZ2UoKTtcbiAgICBpZiAoZmluYWxNZXNzYWdlKSB0aGlzLl9lbWl0KCdmaW5hbE1lc3NhZ2UnLCBmaW5hbE1lc3NhZ2UpO1xuICAgIGNvbnN0IGZpbmFsQ29udGVudCA9IHRoaXMuI2dldEZpbmFsQ29udGVudCgpO1xuICAgIGlmIChmaW5hbENvbnRlbnQpIHRoaXMuX2VtaXQoJ2ZpbmFsQ29udGVudCcsIGZpbmFsQ29udGVudCk7XG5cbiAgICBjb25zdCBmaW5hbEZ1bmN0aW9uQ2FsbCA9IHRoaXMuI2dldEZpbmFsRnVuY3Rpb25DYWxsKCk7XG4gICAgaWYgKGZpbmFsRnVuY3Rpb25DYWxsKSB0aGlzLl9lbWl0KCdmaW5hbEZ1bmN0aW9uQ2FsbCcsIGZpbmFsRnVuY3Rpb25DYWxsKTtcblxuICAgIGNvbnN0IGZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0ID0gdGhpcy4jZ2V0RmluYWxGdW5jdGlvbkNhbGxSZXN1bHQoKTtcbiAgICBpZiAoZmluYWxGdW5jdGlvbkNhbGxSZXN1bHQgIT0gbnVsbCkgdGhpcy5fZW1pdCgnZmluYWxGdW5jdGlvbkNhbGxSZXN1bHQnLCBmaW5hbEZ1bmN0aW9uQ2FsbFJlc3VsdCk7XG5cbiAgICBpZiAodGhpcy5fY2hhdENvbXBsZXRpb25zLnNvbWUoKGMpID0+IGMudXNhZ2UpKSB7XG4gICAgICB0aGlzLl9lbWl0KCd0b3RhbFVzYWdlJywgdGhpcy4jY2FsY3VsYXRlVG90YWxVc2FnZSgpKTtcbiAgICB9XG4gIH1cblxuICAjdmFsaWRhdGVQYXJhbXMocGFyYW1zOiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyk6IHZvaWQge1xuICAgIGlmIChwYXJhbXMubiAhPSBudWxsICYmIHBhcmFtcy5uID4gMSkge1xuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICAnQ2hhdENvbXBsZXRpb24gY29udmVuaWVuY2UgaGVscGVycyBvbmx5IHN1cHBvcnQgbj0xIGF0IHRoaXMgdGltZS4gVG8gdXNlIG4+MSwgcGxlYXNlIHVzZSBjaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSgpIGRpcmVjdGx5LicsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfY3JlYXRlQ2hhdENvbXBsZXRpb24oXG4gICAgY2xpZW50OiBPcGVuQUksXG4gICAgcGFyYW1zOiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxQYXJzZWRDaGF0Q29tcGxldGlvbjxQYXJzZWRUPj4ge1xuICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbDtcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gdGhpcy5jb250cm9sbGVyLmFib3J0KCkpO1xuICAgIH1cbiAgICB0aGlzLiN2YWxpZGF0ZVBhcmFtcyhwYXJhbXMpO1xuXG4gICAgY29uc3QgY2hhdENvbXBsZXRpb24gPSBhd2FpdCBjbGllbnQuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoXG4gICAgICB7IC4uLnBhcmFtcywgc3RyZWFtOiBmYWxzZSB9LFxuICAgICAgeyAuLi5vcHRpb25zLCBzaWduYWw6IHRoaXMuY29udHJvbGxlci5zaWduYWwgfSxcbiAgICApO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCgpO1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGF0Q29tcGxldGlvbihwYXJzZUNoYXRDb21wbGV0aW9uKGNoYXRDb21wbGV0aW9uLCBwYXJhbXMpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfcnVuQ2hhdENvbXBsZXRpb24oXG4gICAgY2xpZW50OiBPcGVuQUksXG4gICAgcGFyYW1zOiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxDaGF0Q29tcGxldGlvbj4ge1xuICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwYXJhbXMubWVzc2FnZXMpIHtcbiAgICAgIHRoaXMuX2FkZE1lc3NhZ2UobWVzc2FnZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fY3JlYXRlQ2hhdENvbXBsZXRpb24oY2xpZW50LCBwYXJhbXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9ydW5GdW5jdGlvbnM8RnVuY3Rpb25zQXJncyBleHRlbmRzIEJhc2VGdW5jdGlvbnNBcmdzPihcbiAgICBjbGllbnQ6IE9wZW5BSSxcbiAgICBwYXJhbXM6XG4gICAgICB8IENoYXRDb21wbGV0aW9uRnVuY3Rpb25SdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncz5cbiAgICAgIHwgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdGdW5jdGlvblJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzPixcbiAgICBvcHRpb25zPzogUnVubmVyT3B0aW9ucyxcbiAgKSB7XG4gICAgY29uc3Qgcm9sZSA9ICdmdW5jdGlvbicgYXMgY29uc3Q7XG4gICAgY29uc3QgeyBmdW5jdGlvbl9jYWxsID0gJ2F1dG8nLCBzdHJlYW0sIC4uLnJlc3RQYXJhbXMgfSA9IHBhcmFtcztcbiAgICBjb25zdCBzaW5nbGVGdW5jdGlvblRvQ2FsbCA9IHR5cGVvZiBmdW5jdGlvbl9jYWxsICE9PSAnc3RyaW5nJyAmJiBmdW5jdGlvbl9jYWxsPy5uYW1lO1xuICAgIGNvbnN0IHsgbWF4Q2hhdENvbXBsZXRpb25zID0gREVGQVVMVF9NQVhfQ0hBVF9DT01QTEVUSU9OUyB9ID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGNvbnN0IGZ1bmN0aW9uc0J5TmFtZTogUmVjb3JkPHN0cmluZywgUnVubmFibGVGdW5jdGlvbjxhbnk+PiA9IHt9O1xuICAgIGZvciAoY29uc3QgZiBvZiBwYXJhbXMuZnVuY3Rpb25zKSB7XG4gICAgICBmdW5jdGlvbnNCeU5hbWVbZi5uYW1lIHx8IGYuZnVuY3Rpb24ubmFtZV0gPSBmO1xuICAgIH1cblxuICAgIGNvbnN0IGZ1bmN0aW9uczogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMuRnVuY3Rpb25bXSA9IHBhcmFtcy5mdW5jdGlvbnMubWFwKFxuICAgICAgKGYpOiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcy5GdW5jdGlvbiA9PiAoe1xuICAgICAgICBuYW1lOiBmLm5hbWUgfHwgZi5mdW5jdGlvbi5uYW1lLFxuICAgICAgICBwYXJhbWV0ZXJzOiBmLnBhcmFtZXRlcnMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBmLmRlc2NyaXB0aW9uLFxuICAgICAgfSksXG4gICAgKTtcblxuICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwYXJhbXMubWVzc2FnZXMpIHtcbiAgICAgIHRoaXMuX2FkZE1lc3NhZ2UobWVzc2FnZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4Q2hhdENvbXBsZXRpb25zOyArK2kpIHtcbiAgICAgIGNvbnN0IGNoYXRDb21wbGV0aW9uOiBDaGF0Q29tcGxldGlvbiA9IGF3YWl0IHRoaXMuX2NyZWF0ZUNoYXRDb21wbGV0aW9uKFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5yZXN0UGFyYW1zLFxuICAgICAgICAgIGZ1bmN0aW9uX2NhbGwsXG4gICAgICAgICAgZnVuY3Rpb25zLFxuICAgICAgICAgIG1lc3NhZ2VzOiBbLi4udGhpcy5tZXNzYWdlc10sXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGNoYXRDb21wbGV0aW9uLmNob2ljZXNbMF0/Lm1lc3NhZ2U7XG4gICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIG1lc3NhZ2UgaW4gQ2hhdENvbXBsZXRpb24gcmVzcG9uc2VgKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWVzc2FnZS5mdW5jdGlvbl9jYWxsKSByZXR1cm47XG4gICAgICBjb25zdCB7IG5hbWUsIGFyZ3VtZW50czogYXJncyB9ID0gbWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgY29uc3QgZm4gPSBmdW5jdGlvbnNCeU5hbWVbbmFtZV07XG4gICAgICBpZiAoIWZuKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBgSW52YWxpZCBmdW5jdGlvbl9jYWxsOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfS4gQXZhaWxhYmxlIG9wdGlvbnMgYXJlOiAke2Z1bmN0aW9uc1xuICAgICAgICAgIC5tYXAoKGYpID0+IEpTT04uc3RyaW5naWZ5KGYubmFtZSkpXG4gICAgICAgICAgLmpvaW4oJywgJyl9LiBQbGVhc2UgdHJ5IGFnYWluYDtcblxuICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgbmFtZSwgY29udGVudCB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHNpbmdsZUZ1bmN0aW9uVG9DYWxsICYmIHNpbmdsZUZ1bmN0aW9uVG9DYWxsICE9PSBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBgSW52YWxpZCBmdW5jdGlvbl9jYWxsOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfS4gJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBzaW5nbGVGdW5jdGlvblRvQ2FsbCxcbiAgICAgICAgKX0gcmVxdWVzdGVkLiBQbGVhc2UgdHJ5IGFnYWluYDtcblxuICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgbmFtZSwgY29udGVudCB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBwYXJzZWQ7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWQgPSBpc1J1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2UoZm4pID8gYXdhaXQgZm4ucGFyc2UoYXJncykgOiBhcmdzO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7XG4gICAgICAgICAgcm9sZSxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGNvbnRlbnQ6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGl0IGNhbid0IHJ1bGUgb3V0IGBuZXZlcmAgdHlwZS5cbiAgICAgIGNvbnN0IHJhd0NvbnRlbnQgPSBhd2FpdCBmbi5mdW5jdGlvbihwYXJzZWQsIHRoaXMpO1xuICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuI3N0cmluZ2lmeUZ1bmN0aW9uQ2FsbFJlc3VsdChyYXdDb250ZW50KTtcblxuICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGUsIG5hbWUsIGNvbnRlbnQgfSk7XG5cbiAgICAgIGlmIChzaW5nbGVGdW5jdGlvblRvQ2FsbCkgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfcnVuVG9vbHM8RnVuY3Rpb25zQXJncyBleHRlbmRzIEJhc2VGdW5jdGlvbnNBcmdzPihcbiAgICBjbGllbnQ6IE9wZW5BSSxcbiAgICBwYXJhbXM6XG4gICAgICB8IENoYXRDb21wbGV0aW9uVG9vbFJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzPlxuICAgICAgfCBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1Rvb2xSdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncz4sXG4gICAgb3B0aW9ucz86IFJ1bm5lck9wdGlvbnMsXG4gICkge1xuICAgIGNvbnN0IHJvbGUgPSAndG9vbCcgYXMgY29uc3Q7XG4gICAgY29uc3QgeyB0b29sX2Nob2ljZSA9ICdhdXRvJywgc3RyZWFtLCAuLi5yZXN0UGFyYW1zIH0gPSBwYXJhbXM7XG4gICAgY29uc3Qgc2luZ2xlRnVuY3Rpb25Ub0NhbGwgPSB0eXBlb2YgdG9vbF9jaG9pY2UgIT09ICdzdHJpbmcnICYmIHRvb2xfY2hvaWNlPy5mdW5jdGlvbj8ubmFtZTtcbiAgICBjb25zdCB7IG1heENoYXRDb21wbGV0aW9ucyA9IERFRkFVTFRfTUFYX0NIQVRfQ09NUExFVElPTlMgfSA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBUT0RPKHNvbWVkYXkpOiBjbGVhbiB0aGlzIGxvZ2ljIHVwXG4gICAgY29uc3QgaW5wdXRUb29scyA9IHBhcmFtcy50b29scy5tYXAoKHRvb2wpOiBSdW5uYWJsZVRvb2xGdW5jdGlvbjxhbnk+ID0+IHtcbiAgICAgIGlmIChpc0F1dG9QYXJzYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgaWYgKCF0b29sLiRjYWxsYmFjaykge1xuICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcignVG9vbCBnaXZlbiB0byBgLnJ1blRvb2xzKClgIHRoYXQgZG9lcyBub3QgaGF2ZSBhbiBhc3NvY2lhdGVkIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uOiB0b29sLiRjYWxsYmFjayxcbiAgICAgICAgICAgIG5hbWU6IHRvb2wuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmZ1bmN0aW9uLmRlc2NyaXB0aW9uIHx8ICcnLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogdG9vbC5mdW5jdGlvbi5wYXJhbWV0ZXJzIGFzIGFueSxcbiAgICAgICAgICAgIHBhcnNlOiB0b29sLiRwYXJzZVJhdyxcbiAgICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9vbCBhcyBhbnkgYXMgUnVubmFibGVUb29sRnVuY3Rpb248YW55PjtcbiAgICB9KTtcblxuICAgIGNvbnN0IGZ1bmN0aW9uc0J5TmFtZTogUmVjb3JkPHN0cmluZywgUnVubmFibGVGdW5jdGlvbjxhbnk+PiA9IHt9O1xuICAgIGZvciAoY29uc3QgZiBvZiBpbnB1dFRvb2xzKSB7XG4gICAgICBpZiAoZi50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZ1bmN0aW9uc0J5TmFtZVtmLmZ1bmN0aW9uLm5hbWUgfHwgZi5mdW5jdGlvbi5mdW5jdGlvbi5uYW1lXSA9IGYuZnVuY3Rpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdG9vbHM6IENoYXRDb21wbGV0aW9uVG9vbFtdID1cbiAgICAgICd0b29scycgaW4gcGFyYW1zID9cbiAgICAgICAgaW5wdXRUb29scy5tYXAoKHQpID0+XG4gICAgICAgICAgdC50eXBlID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0LmZ1bmN0aW9uLm5hbWUgfHwgdC5mdW5jdGlvbi5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHQuZnVuY3Rpb24ucGFyYW1ldGVycyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdC5mdW5jdGlvbi5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzdHJpY3Q6IHQuZnVuY3Rpb24uc3RyaWN0LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogKHQgYXMgdW5rbm93biBhcyBDaGF0Q29tcGxldGlvblRvb2wpLFxuICAgICAgICApXG4gICAgICA6ICh1bmRlZmluZWQgYXMgYW55KTtcblxuICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwYXJhbXMubWVzc2FnZXMpIHtcbiAgICAgIHRoaXMuX2FkZE1lc3NhZ2UobWVzc2FnZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4Q2hhdENvbXBsZXRpb25zOyArK2kpIHtcbiAgICAgIGNvbnN0IGNoYXRDb21wbGV0aW9uOiBDaGF0Q29tcGxldGlvbiA9IGF3YWl0IHRoaXMuX2NyZWF0ZUNoYXRDb21wbGV0aW9uKFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5yZXN0UGFyYW1zLFxuICAgICAgICAgIHRvb2xfY2hvaWNlLFxuICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgIG1lc3NhZ2VzOiBbLi4udGhpcy5tZXNzYWdlc10sXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGNoYXRDb21wbGV0aW9uLmNob2ljZXNbMF0/Lm1lc3NhZ2U7XG4gICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIG1lc3NhZ2UgaW4gQ2hhdENvbXBsZXRpb24gcmVzcG9uc2VgKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWVzc2FnZS50b29sX2NhbGxzPy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHRvb2xfY2FsbCBvZiBtZXNzYWdlLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgaWYgKHRvb2xfY2FsbC50eXBlICE9PSAnZnVuY3Rpb24nKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdG9vbF9jYWxsX2lkID0gdG9vbF9jYWxsLmlkO1xuICAgICAgICBjb25zdCB7IG5hbWUsIGFyZ3VtZW50czogYXJncyB9ID0gdG9vbF9jYWxsLmZ1bmN0aW9uO1xuICAgICAgICBjb25zdCBmbiA9IGZ1bmN0aW9uc0J5TmFtZVtuYW1lXTtcblxuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGBJbnZhbGlkIHRvb2xfY2FsbDogJHtKU09OLnN0cmluZ2lmeShuYW1lKX0uIEF2YWlsYWJsZSBvcHRpb25zIGFyZTogJHtPYmplY3Qua2V5cyhcbiAgICAgICAgICAgIGZ1bmN0aW9uc0J5TmFtZSxcbiAgICAgICAgICApXG4gICAgICAgICAgICAubWFwKChuYW1lKSA9PiBKU09OLnN0cmluZ2lmeShuYW1lKSlcbiAgICAgICAgICAgIC5qb2luKCcsICcpfS4gUGxlYXNlIHRyeSBhZ2FpbmA7XG5cbiAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgdG9vbF9jYWxsX2lkLCBjb250ZW50IH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHNpbmdsZUZ1bmN0aW9uVG9DYWxsICYmIHNpbmdsZUZ1bmN0aW9uVG9DYWxsICE9PSBuYW1lKSB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGBJbnZhbGlkIHRvb2xfY2FsbDogJHtKU09OLnN0cmluZ2lmeShuYW1lKX0uICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBzaW5nbGVGdW5jdGlvblRvQ2FsbCxcbiAgICAgICAgICApfSByZXF1ZXN0ZWQuIFBsZWFzZSB0cnkgYWdhaW5gO1xuXG4gICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGUsIHRvb2xfY2FsbF9pZCwgY29udGVudCB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwYXJzZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFyc2VkID0gaXNSdW5uYWJsZUZ1bmN0aW9uV2l0aFBhcnNlKGZuKSA/IGF3YWl0IGZuLnBhcnNlKGFyZ3MpIDogYXJncztcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zdCBjb250ZW50ID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoeyByb2xlLCB0b29sX2NhbGxfaWQsIGNvbnRlbnQgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGl0IGNhbid0IHJ1bGUgb3V0IGBuZXZlcmAgdHlwZS5cbiAgICAgICAgY29uc3QgcmF3Q29udGVudCA9IGF3YWl0IGZuLmZ1bmN0aW9uKHBhcnNlZCwgdGhpcyk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLiNzdHJpbmdpZnlGdW5jdGlvbkNhbGxSZXN1bHQocmF3Q29udGVudCk7XG4gICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoeyByb2xlLCB0b29sX2NhbGxfaWQsIGNvbnRlbnQgfSk7XG5cbiAgICAgICAgaWYgKHNpbmdsZUZ1bmN0aW9uVG9DYWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgI3N0cmluZ2lmeUZ1bmN0aW9uQ2FsbFJlc3VsdChyYXdDb250ZW50OiB1bmtub3duKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIHJhd0NvbnRlbnQgPT09ICdzdHJpbmcnID8gcmF3Q29udGVudFxuICAgICAgOiByYXdDb250ZW50ID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJ1xuICAgICAgOiBKU09OLnN0cmluZ2lmeShyYXdDb250ZW50KVxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzIGV4dGVuZHMgQmFzZUV2ZW50cyB7XG4gIGZ1bmN0aW9uQ2FsbDogKGZ1bmN0aW9uQ2FsbDogQ2hhdENvbXBsZXRpb25NZXNzYWdlLkZ1bmN0aW9uQ2FsbCkgPT4gdm9pZDtcbiAgbWVzc2FnZTogKG1lc3NhZ2U6IENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtKSA9PiB2b2lkO1xuICBjaGF0Q29tcGxldGlvbjogKGNvbXBsZXRpb246IENoYXRDb21wbGV0aW9uKSA9PiB2b2lkO1xuICBmaW5hbENvbnRlbnQ6IChjb250ZW50U25hcHNob3Q6IHN0cmluZykgPT4gdm9pZDtcbiAgZmluYWxNZXNzYWdlOiAobWVzc2FnZTogQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0pID0+IHZvaWQ7XG4gIGZpbmFsQ2hhdENvbXBsZXRpb246IChjb21wbGV0aW9uOiBDaGF0Q29tcGxldGlvbikgPT4gdm9pZDtcbiAgZmluYWxGdW5jdGlvbkNhbGw6IChmdW5jdGlvbkNhbGw6IENoYXRDb21wbGV0aW9uTWVzc2FnZS5GdW5jdGlvbkNhbGwpID0+IHZvaWQ7XG4gIGZ1bmN0aW9uQ2FsbFJlc3VsdDogKGNvbnRlbnQ6IHN0cmluZykgPT4gdm9pZDtcbiAgZmluYWxGdW5jdGlvbkNhbGxSZXN1bHQ6IChjb250ZW50OiBzdHJpbmcpID0+IHZvaWQ7XG4gIHRvdGFsVXNhZ2U6ICh1c2FnZTogQ29tcGxldGlvblVzYWdlKSA9PiB2b2lkO1xufVxuIiwgImltcG9ydCB7XG4gIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0sXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG59IGZyb20gJy4uL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zJztcbmltcG9ydCB7IHR5cGUgUnVubmFibGVGdW5jdGlvbnMsIHR5cGUgQmFzZUZ1bmN0aW9uc0FyZ3MsIFJ1bm5hYmxlVG9vbHMgfSBmcm9tICcuL1J1bm5hYmxlRnVuY3Rpb24nO1xuaW1wb3J0IHtcbiAgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcixcbiAgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cyxcbiAgUnVubmVyT3B0aW9ucyxcbn0gZnJvbSAnLi9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyJztcbmltcG9ydCB7IGlzQXNzaXN0YW50TWVzc2FnZSB9IGZyb20gJy4vY2hhdENvbXBsZXRpb25VdGlscyc7XG5pbXBvcnQgT3BlbkFJIGZyb20gJy4uL2luZGV4JztcbmltcG9ydCB7IEF1dG9QYXJzZWFibGVUb29sIH0gZnJvbSAnLi4vbGliL3BhcnNlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMgZXh0ZW5kcyBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyRXZlbnRzIHtcbiAgY29udGVudDogKGNvbnRlbnQ6IHN0cmluZykgPT4gdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25GdW5jdGlvblJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzIGV4dGVuZHMgQmFzZUZ1bmN0aW9uc0FyZ3M+ID0gT21pdDxcbiAgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICdmdW5jdGlvbnMnXG4+ICYge1xuICBmdW5jdGlvbnM6IFJ1bm5hYmxlRnVuY3Rpb25zPEZ1bmN0aW9uc0FyZ3M+O1xufTtcblxuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3MgZXh0ZW5kcyBCYXNlRnVuY3Rpb25zQXJncz4gPSBPbWl0PFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgJ3Rvb2xzJ1xuPiAmIHtcbiAgdG9vbHM6IFJ1bm5hYmxlVG9vbHM8RnVuY3Rpb25zQXJncz4gfCBBdXRvUGFyc2VhYmxlVG9vbDxhbnksIHRydWU+W107XG59O1xuXG5leHBvcnQgY2xhc3MgQ2hhdENvbXBsZXRpb25SdW5uZXI8UGFyc2VkVCA9IG51bGw+IGV4dGVuZHMgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcjxcbiAgQ2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMsXG4gIFBhcnNlZFRcbj4ge1xuICAvKiogQGRlcHJlY2F0ZWQgLSBwbGVhc2UgdXNlIGBydW5Ub29sc2AgaW5zdGVhZC4gKi9cbiAgc3RhdGljIHJ1bkZ1bmN0aW9ucyhcbiAgICBjbGllbnQ6IE9wZW5BSSxcbiAgICBwYXJhbXM6IENoYXRDb21wbGV0aW9uRnVuY3Rpb25SdW5uZXJQYXJhbXM8YW55W10+LFxuICAgIG9wdGlvbnM/OiBSdW5uZXJPcHRpb25zLFxuICApOiBDaGF0Q29tcGxldGlvblJ1bm5lcjxudWxsPiB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IENoYXRDb21wbGV0aW9uUnVubmVyKCk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3J1bkZ1bmN0aW9ucycgfSxcbiAgICB9O1xuICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fcnVuRnVuY3Rpb25zKGNsaWVudCwgcGFyYW1zLCBvcHRzKSk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxuXG4gIHN0YXRpYyBydW5Ub29sczxQYXJzZWRUPihcbiAgICBjbGllbnQ6IE9wZW5BSSxcbiAgICBwYXJhbXM6IENoYXRDb21wbGV0aW9uVG9vbFJ1bm5lclBhcmFtczxhbnlbXT4sXG4gICAgb3B0aW9ucz86IFJ1bm5lck9wdGlvbnMsXG4gICk6IENoYXRDb21wbGV0aW9uUnVubmVyPFBhcnNlZFQ+IHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgQ2hhdENvbXBsZXRpb25SdW5uZXI8UGFyc2VkVD4oKTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAncnVuVG9vbHMnIH0sXG4gICAgfTtcbiAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX3J1blRvb2xzKGNsaWVudCwgcGFyYW1zLCBvcHRzKSk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxuXG4gIG92ZXJyaWRlIF9hZGRNZXNzYWdlKFxuICAgIHRoaXM6IENoYXRDb21wbGV0aW9uUnVubmVyPFBhcnNlZFQ+LFxuICAgIG1lc3NhZ2U6IENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtLFxuICAgIGVtaXQ6IGJvb2xlYW4gPSB0cnVlLFxuICApIHtcbiAgICBzdXBlci5fYWRkTWVzc2FnZShtZXNzYWdlLCBlbWl0KTtcbiAgICBpZiAoaXNBc3Npc3RhbnRNZXNzYWdlKG1lc3NhZ2UpICYmIG1lc3NhZ2UuY29udGVudCkge1xuICAgICAgdGhpcy5fZW1pdCgnY29udGVudCcsIG1lc3NhZ2UuY29udGVudCBhcyBzdHJpbmcpO1xuICAgIH1cbiAgfVxufVxuIiwgImNvbnN0IFNUUiA9IDBiMDAwMDAwMDAxO1xuY29uc3QgTlVNID0gMGIwMDAwMDAwMTA7XG5jb25zdCBBUlIgPSAwYjAwMDAwMDEwMDtcbmNvbnN0IE9CSiA9IDBiMDAwMDAxMDAwO1xuY29uc3QgTlVMTCA9IDBiMDAwMDEwMDAwO1xuY29uc3QgQk9PTCA9IDBiMDAwMTAwMDAwO1xuY29uc3QgTkFOID0gMGIwMDEwMDAwMDA7XG5jb25zdCBJTkZJTklUWSA9IDBiMDEwMDAwMDAwO1xuY29uc3QgTUlOVVNfSU5GSU5JVFkgPSAwYjEwMDAwMDAwMDtcblxuY29uc3QgSU5GID0gSU5GSU5JVFkgfCBNSU5VU19JTkZJTklUWTtcbmNvbnN0IFNQRUNJQUwgPSBOVUxMIHwgQk9PTCB8IElORiB8IE5BTjtcbmNvbnN0IEFUT00gPSBTVFIgfCBOVU0gfCBTUEVDSUFMO1xuY29uc3QgQ09MTEVDVElPTiA9IEFSUiB8IE9CSjtcbmNvbnN0IEFMTCA9IEFUT00gfCBDT0xMRUNUSU9OO1xuXG5jb25zdCBBbGxvdyA9IHtcbiAgU1RSLFxuICBOVU0sXG4gIEFSUixcbiAgT0JKLFxuICBOVUxMLFxuICBCT09MLFxuICBOQU4sXG4gIElORklOSVRZLFxuICBNSU5VU19JTkZJTklUWSxcbiAgSU5GLFxuICBTUEVDSUFMLFxuICBBVE9NLFxuICBDT0xMRUNUSU9OLFxuICBBTEwsXG59O1xuXG4vLyBUaGUgSlNPTiBzdHJpbmcgc2VnbWVudCB3YXMgdW5hYmxlIHRvIGJlIHBhcnNlZCBjb21wbGV0ZWx5XG5jbGFzcyBQYXJ0aWFsSlNPTiBleHRlbmRzIEVycm9yIHt9XG5cbmNsYXNzIE1hbGZvcm1lZEpTT04gZXh0ZW5kcyBFcnJvciB7fVxuXG4vKipcbiAqIFBhcnNlIGluY29tcGxldGUgSlNPTlxuICogQHBhcmFtIHtzdHJpbmd9IGpzb25TdHJpbmcgUGFydGlhbCBKU09OIHRvIGJlIHBhcnNlZFxuICogQHBhcmFtIHtudW1iZXJ9IGFsbG93UGFydGlhbCBTcGVjaWZ5IHdoYXQgdHlwZXMgYXJlIGFsbG93ZWQgdG8gYmUgcGFydGlhbCwgc2VlIHtAbGluayBBbGxvd30gZm9yIGRldGFpbHNcbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgSlNPTlxuICogQHRocm93cyB7UGFydGlhbEpTT059IElmIHRoZSBKU09OIGlzIGluY29tcGxldGUgKHJlbGF0ZWQgdG8gdGhlIGBhbGxvd2AgcGFyYW1ldGVyKVxuICogQHRocm93cyB7TWFsZm9ybWVkSlNPTn0gSWYgdGhlIEpTT04gaXMgbWFsZm9ybWVkXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSlNPTihqc29uU3RyaW5nOiBzdHJpbmcsIGFsbG93UGFydGlhbDogbnVtYmVyID0gQWxsb3cuQUxMKTogYW55IHtcbiAgaWYgKHR5cGVvZiBqc29uU3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGluZyBzdHIsIGdvdCAke3R5cGVvZiBqc29uU3RyaW5nfWApO1xuICB9XG4gIGlmICghanNvblN0cmluZy50cmltKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7anNvblN0cmluZ30gaXMgZW1wdHlgKTtcbiAgfVxuICByZXR1cm4gX3BhcnNlSlNPTihqc29uU3RyaW5nLnRyaW0oKSwgYWxsb3dQYXJ0aWFsKTtcbn1cblxuY29uc3QgX3BhcnNlSlNPTiA9IChqc29uU3RyaW5nOiBzdHJpbmcsIGFsbG93OiBudW1iZXIpID0+IHtcbiAgY29uc3QgbGVuZ3RoID0ganNvblN0cmluZy5sZW5ndGg7XG4gIGxldCBpbmRleCA9IDA7XG5cbiAgY29uc3QgbWFya1BhcnRpYWxKU09OID0gKG1zZzogc3RyaW5nKSA9PiB7XG4gICAgdGhyb3cgbmV3IFBhcnRpYWxKU09OKGAke21zZ30gYXQgcG9zaXRpb24gJHtpbmRleH1gKTtcbiAgfTtcblxuICBjb25zdCB0aHJvd01hbGZvcm1lZEVycm9yID0gKG1zZzogc3RyaW5nKSA9PiB7XG4gICAgdGhyb3cgbmV3IE1hbGZvcm1lZEpTT04oYCR7bXNnfSBhdCBwb3NpdGlvbiAke2luZGV4fWApO1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlQW55OiAoKSA9PiBhbnkgPSAoKSA9PiB7XG4gICAgc2tpcEJsYW5rKCk7XG4gICAgaWYgKGluZGV4ID49IGxlbmd0aCkgbWFya1BhcnRpYWxKU09OKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICAgIGlmIChqc29uU3RyaW5nW2luZGV4XSA9PT0gJ1wiJykgcmV0dXJuIHBhcnNlU3RyKCk7XG4gICAgaWYgKGpzb25TdHJpbmdbaW5kZXhdID09PSAneycpIHJldHVybiBwYXJzZU9iaigpO1xuICAgIGlmIChqc29uU3RyaW5nW2luZGV4XSA9PT0gJ1snKSByZXR1cm4gcGFyc2VBcnIoKTtcbiAgICBpZiAoXG4gICAgICBqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCwgaW5kZXggKyA0KSA9PT0gJ251bGwnIHx8XG4gICAgICAoQWxsb3cuTlVMTCAmIGFsbG93ICYmIGxlbmd0aCAtIGluZGV4IDwgNCAmJiAnbnVsbCcuc3RhcnRzV2l0aChqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCkpKVxuICAgICkge1xuICAgICAgaW5kZXggKz0gNDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCwgaW5kZXggKyA0KSA9PT0gJ3RydWUnIHx8XG4gICAgICAoQWxsb3cuQk9PTCAmIGFsbG93ICYmIGxlbmd0aCAtIGluZGV4IDwgNCAmJiAndHJ1ZScuc3RhcnRzV2l0aChqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCkpKVxuICAgICkge1xuICAgICAgaW5kZXggKz0gNDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCwgaW5kZXggKyA1KSA9PT0gJ2ZhbHNlJyB8fFxuICAgICAgKEFsbG93LkJPT0wgJiBhbGxvdyAmJiBsZW5ndGggLSBpbmRleCA8IDUgJiYgJ2ZhbHNlJy5zdGFydHNXaXRoKGpzb25TdHJpbmcuc3Vic3RyaW5nKGluZGV4KSkpXG4gICAgKSB7XG4gICAgICBpbmRleCArPSA1O1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCwgaW5kZXggKyA4KSA9PT0gJ0luZmluaXR5JyB8fFxuICAgICAgKEFsbG93LklORklOSVRZICYgYWxsb3cgJiYgbGVuZ3RoIC0gaW5kZXggPCA4ICYmICdJbmZpbml0eScuc3RhcnRzV2l0aChqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCkpKVxuICAgICkge1xuICAgICAgaW5kZXggKz0gODtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAganNvblN0cmluZy5zdWJzdHJpbmcoaW5kZXgsIGluZGV4ICsgOSkgPT09ICctSW5maW5pdHknIHx8XG4gICAgICAoQWxsb3cuTUlOVVNfSU5GSU5JVFkgJiBhbGxvdyAmJlxuICAgICAgICAxIDwgbGVuZ3RoIC0gaW5kZXggJiZcbiAgICAgICAgbGVuZ3RoIC0gaW5kZXggPCA5ICYmXG4gICAgICAgICctSW5maW5pdHknLnN0YXJ0c1dpdGgoanNvblN0cmluZy5zdWJzdHJpbmcoaW5kZXgpKSlcbiAgICApIHtcbiAgICAgIGluZGV4ICs9IDk7XG4gICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCwgaW5kZXggKyAzKSA9PT0gJ05hTicgfHxcbiAgICAgIChBbGxvdy5OQU4gJiBhbGxvdyAmJiBsZW5ndGggLSBpbmRleCA8IDMgJiYgJ05hTicuc3RhcnRzV2l0aChqc29uU3RyaW5nLnN1YnN0cmluZyhpbmRleCkpKVxuICAgICkge1xuICAgICAgaW5kZXggKz0gMztcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiBwYXJzZU51bSgpO1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlU3RyOiAoKSA9PiBzdHJpbmcgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RhcnQgPSBpbmRleDtcbiAgICBsZXQgZXNjYXBlID0gZmFsc2U7XG4gICAgaW5kZXgrKzsgLy8gc2tpcCBpbml0aWFsIHF1b3RlXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoICYmIChqc29uU3RyaW5nW2luZGV4XSAhPT0gJ1wiJyB8fCAoZXNjYXBlICYmIGpzb25TdHJpbmdbaW5kZXggLSAxXSA9PT0gJ1xcXFwnKSkpIHtcbiAgICAgIGVzY2FwZSA9IGpzb25TdHJpbmdbaW5kZXhdID09PSAnXFxcXCcgPyAhZXNjYXBlIDogZmFsc2U7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgICBpZiAoanNvblN0cmluZy5jaGFyQXQoaW5kZXgpID09ICdcIicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCArK2luZGV4IC0gTnVtYmVyKGVzY2FwZSkpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3dNYWxmb3JtZWRFcnJvcihTdHJpbmcoZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQWxsb3cuU1RSICYgYWxsb3cpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBpbmRleCAtIE51bWJlcihlc2NhcGUpKSArICdcIicpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBTeW50YXhFcnJvcjogSW52YWxpZCBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGpzb25TdHJpbmcubGFzdEluZGV4T2YoJ1xcXFwnKSkgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFya1BhcnRpYWxKU09OKCdVbnRlcm1pbmF0ZWQgc3RyaW5nIGxpdGVyYWwnKTtcbiAgfTtcblxuICBjb25zdCBwYXJzZU9iaiA9ICgpID0+IHtcbiAgICBpbmRleCsrOyAvLyBza2lwIGluaXRpYWwgYnJhY2VcbiAgICBza2lwQmxhbmsoKTtcbiAgICBjb25zdCBvYmo6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKGpzb25TdHJpbmdbaW5kZXhdICE9PSAnfScpIHtcbiAgICAgICAgc2tpcEJsYW5rKCk7XG4gICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGggJiYgQWxsb3cuT0JKICYgYWxsb3cpIHJldHVybiBvYmo7XG4gICAgICAgIGNvbnN0IGtleSA9IHBhcnNlU3RyKCk7XG4gICAgICAgIHNraXBCbGFuaygpO1xuICAgICAgICBpbmRleCsrOyAvLyBza2lwIGNvbG9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUFueSgpO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZSwgd3JpdGFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChBbGxvdy5PQkogJiBhbGxvdykgcmV0dXJuIG9iajtcbiAgICAgICAgICBlbHNlIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcEJsYW5rKCk7XG4gICAgICAgIGlmIChqc29uU3RyaW5nW2luZGV4XSA9PT0gJywnKSBpbmRleCsrOyAvLyBza2lwIGNvbW1hXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKEFsbG93Lk9CSiAmIGFsbG93KSByZXR1cm4gb2JqO1xuICAgICAgZWxzZSBtYXJrUGFydGlhbEpTT04oXCJFeHBlY3RlZCAnfScgYXQgZW5kIG9mIG9iamVjdFwiKTtcbiAgICB9XG4gICAgaW5kZXgrKzsgLy8gc2tpcCBmaW5hbCBicmFjZVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgY29uc3QgcGFyc2VBcnIgPSAoKSA9PiB7XG4gICAgaW5kZXgrKzsgLy8gc2tpcCBpbml0aWFsIGJyYWNrZXRcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKGpzb25TdHJpbmdbaW5kZXhdICE9PSAnXScpIHtcbiAgICAgICAgYXJyLnB1c2gocGFyc2VBbnkoKSk7XG4gICAgICAgIHNraXBCbGFuaygpO1xuICAgICAgICBpZiAoanNvblN0cmluZ1tpbmRleF0gPT09ICcsJykge1xuICAgICAgICAgIGluZGV4Kys7IC8vIHNraXAgY29tbWFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChBbGxvdy5BUlIgJiBhbGxvdykge1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfVxuICAgICAgbWFya1BhcnRpYWxKU09OKFwiRXhwZWN0ZWQgJ10nIGF0IGVuZCBvZiBhcnJheVwiKTtcbiAgICB9XG4gICAgaW5kZXgrKzsgLy8gc2tpcCBmaW5hbCBicmFja2V0XG4gICAgcmV0dXJuIGFycjtcbiAgfTtcblxuICBjb25zdCBwYXJzZU51bSA9ICgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIGlmIChqc29uU3RyaW5nID09PSAnLScgJiYgQWxsb3cuTlVNICYgYWxsb3cpIG1hcmtQYXJ0aWFsSlNPTihcIk5vdCBzdXJlIHdoYXQgJy0nIGlzXCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChBbGxvdy5OVU0gJiBhbGxvdykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoJy4nID09PSBqc29uU3RyaW5nW2pzb25TdHJpbmcubGVuZ3RoIC0gMV0pXG4gICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcuc3Vic3RyaW5nKDAsIGpzb25TdHJpbmcubGFzdEluZGV4T2YoJy4nKSkpO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZy5zdWJzdHJpbmcoMCwganNvblN0cmluZy5sYXN0SW5kZXhPZignZScpKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgICB0aHJvd01hbGZvcm1lZEVycm9yKFN0cmluZyhlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnQgPSBpbmRleDtcblxuICAgIGlmIChqc29uU3RyaW5nW2luZGV4XSA9PT0gJy0nKSBpbmRleCsrO1xuICAgIHdoaWxlIChqc29uU3RyaW5nW2luZGV4XSAmJiAhJyxdfScuaW5jbHVkZXMoanNvblN0cmluZ1tpbmRleF0hKSkgaW5kZXgrKztcblxuICAgIGlmIChpbmRleCA9PSBsZW5ndGggJiYgIShBbGxvdy5OVU0gJiBhbGxvdykpIG1hcmtQYXJ0aWFsSlNPTignVW50ZXJtaW5hdGVkIG51bWJlciBsaXRlcmFsJyk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGluZGV4KSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGpzb25TdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBpbmRleCkgPT09ICctJyAmJiBBbGxvdy5OVU0gJiBhbGxvdylcbiAgICAgICAgbWFya1BhcnRpYWxKU09OKFwiTm90IHN1cmUgd2hhdCAnLScgaXNcIik7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uU3RyaW5nLnN1YnN0cmluZyhzdGFydCwganNvblN0cmluZy5sYXN0SW5kZXhPZignZScpKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93TWFsZm9ybWVkRXJyb3IoU3RyaW5nKGUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc2tpcEJsYW5rID0gKCkgPT4ge1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCAmJiAnIFxcblxcclxcdCcuaW5jbHVkZXMoanNvblN0cmluZ1tpbmRleF0hKSkge1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHBhcnNlQW55KCk7XG59O1xuXG4vLyB1c2luZyB0aGlzIGZ1bmN0aW9uIHdpdGggbWFsZm9ybWVkIEpTT04gaXMgdW5kZWZpbmVkIGJlaGF2aW9yXG5jb25zdCBwYXJ0aWFsUGFyc2UgPSAoaW5wdXQ6IHN0cmluZykgPT4gcGFyc2VKU09OKGlucHV0LCBBbGxvdy5BTEwgXiBBbGxvdy5OVU0pO1xuXG5leHBvcnQgeyBwYXJ0aWFsUGFyc2UsIFBhcnRpYWxKU09OLCBNYWxmb3JtZWRKU09OIH07XG4iLCAiaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7XG4gIE9wZW5BSUVycm9yLFxuICBBUElVc2VyQWJvcnRFcnJvcixcbiAgTGVuZ3RoRmluaXNoUmVhc29uRXJyb3IsXG4gIENvbnRlbnRGaWx0ZXJGaW5pc2hSZWFzb25FcnJvcixcbn0gZnJvbSAnLi4vZXJyb3InO1xuaW1wb3J0IHtcbiAgQ2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2IsXG4gIHR5cGUgQ2hhdENvbXBsZXRpb24sXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25DaHVuayxcbiAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2UsXG59IGZyb20gJy4uL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zJztcbmltcG9ydCB7XG4gIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXIsXG4gIHR5cGUgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cyxcbn0gZnJvbSAnLi9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyJztcbmltcG9ydCB7IHR5cGUgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9fc2hpbXMvaW5kZXgnO1xuaW1wb3J0IHsgU3RyZWFtIH0gZnJvbSAnLi4vc3RyZWFtaW5nJztcbmltcG9ydCBPcGVuQUkgZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHsgUGFyc2VkQ2hhdENvbXBsZXRpb24gfSBmcm9tICcuLi9yZXNvdXJjZXMvYmV0YS9jaGF0L2NvbXBsZXRpb25zJztcbmltcG9ydCB7XG4gIEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdCxcbiAgaGFzQXV0b1BhcnNlYWJsZUlucHV0LFxuICBpc0F1dG9QYXJzYWJsZVJlc3BvbnNlRm9ybWF0LFxuICBpc0F1dG9QYXJzYWJsZVRvb2wsXG4gIG1heWJlUGFyc2VDaGF0Q29tcGxldGlvbixcbiAgc2hvdWxkUGFyc2VUb29sQ2FsbCxcbn0gZnJvbSAnLi4vbGliL3BhcnNlcic7XG5pbXBvcnQgeyBwYXJ0aWFsUGFyc2UgfSBmcm9tICcuLi9fdmVuZG9yL3BhcnRpYWwtanNvbi1wYXJzZXIvcGFyc2VyJztcblxuZXhwb3J0IGludGVyZmFjZSBDb250ZW50RGVsdGFFdmVudCB7XG4gIGRlbHRhOiBzdHJpbmc7XG4gIHNuYXBzaG90OiBzdHJpbmc7XG4gIHBhcnNlZDogdW5rbm93biB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGVudERvbmVFdmVudDxQYXJzZWRUID0gbnVsbD4ge1xuICBjb250ZW50OiBzdHJpbmc7XG4gIHBhcnNlZDogUGFyc2VkVCB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVmdXNhbERlbHRhRXZlbnQge1xuICBkZWx0YTogc3RyaW5nO1xuICBzbmFwc2hvdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlZnVzYWxEb25lRXZlbnQge1xuICByZWZ1c2FsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25Ub29sQ2FsbEFyZ3VtZW50c0RlbHRhRXZlbnQge1xuICBuYW1lOiBzdHJpbmc7XG5cbiAgaW5kZXg6IG51bWJlcjtcblxuICBhcmd1bWVudHM6IHN0cmluZztcblxuICBwYXJzZWRfYXJndW1lbnRzOiB1bmtub3duO1xuXG4gIGFyZ3VtZW50c19kZWx0YTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uVG9vbENhbGxBcmd1bWVudHNEb25lRXZlbnQge1xuICBuYW1lOiBzdHJpbmc7XG5cbiAgaW5kZXg6IG51bWJlcjtcblxuICBhcmd1bWVudHM6IHN0cmluZztcblxuICBwYXJzZWRfYXJndW1lbnRzOiB1bmtub3duO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ1Byb2JzQ29udGVudERlbHRhRXZlbnQge1xuICBjb250ZW50OiBBcnJheTxDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYj47XG4gIHNuYXBzaG90OiBBcnJheTxDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9nUHJvYnNDb250ZW50RG9uZUV2ZW50IHtcbiAgY29udGVudDogQXJyYXk8Q2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2I+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ1Byb2JzUmVmdXNhbERlbHRhRXZlbnQge1xuICByZWZ1c2FsOiBBcnJheTxDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYj47XG4gIHNuYXBzaG90OiBBcnJheTxDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9nUHJvYnNSZWZ1c2FsRG9uZUV2ZW50IHtcbiAgcmVmdXNhbDogQXJyYXk8Q2hhdENvbXBsZXRpb25Ub2tlbkxvZ3Byb2I+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uU3RyZWFtRXZlbnRzPFBhcnNlZFQgPSBudWxsPiBleHRlbmRzIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMge1xuICBjb250ZW50OiAoY29udGVudERlbHRhOiBzdHJpbmcsIGNvbnRlbnRTbmFwc2hvdDogc3RyaW5nKSA9PiB2b2lkO1xuICBjaHVuazogKGNodW5rOiBDaGF0Q29tcGxldGlvbkNodW5rLCBzbmFwc2hvdDogQ2hhdENvbXBsZXRpb25TbmFwc2hvdCkgPT4gdm9pZDtcblxuICAnY29udGVudC5kZWx0YSc6IChwcm9wczogQ29udGVudERlbHRhRXZlbnQpID0+IHZvaWQ7XG4gICdjb250ZW50LmRvbmUnOiAocHJvcHM6IENvbnRlbnREb25lRXZlbnQ8UGFyc2VkVD4pID0+IHZvaWQ7XG5cbiAgJ3JlZnVzYWwuZGVsdGEnOiAocHJvcHM6IFJlZnVzYWxEZWx0YUV2ZW50KSA9PiB2b2lkO1xuICAncmVmdXNhbC5kb25lJzogKHByb3BzOiBSZWZ1c2FsRG9uZUV2ZW50KSA9PiB2b2lkO1xuXG4gICd0b29sX2NhbGxzLmZ1bmN0aW9uLmFyZ3VtZW50cy5kZWx0YSc6IChwcm9wczogRnVuY3Rpb25Ub29sQ2FsbEFyZ3VtZW50c0RlbHRhRXZlbnQpID0+IHZvaWQ7XG4gICd0b29sX2NhbGxzLmZ1bmN0aW9uLmFyZ3VtZW50cy5kb25lJzogKHByb3BzOiBGdW5jdGlvblRvb2xDYWxsQXJndW1lbnRzRG9uZUV2ZW50KSA9PiB2b2lkO1xuXG4gICdsb2dwcm9icy5jb250ZW50LmRlbHRhJzogKHByb3BzOiBMb2dQcm9ic0NvbnRlbnREZWx0YUV2ZW50KSA9PiB2b2lkO1xuICAnbG9ncHJvYnMuY29udGVudC5kb25lJzogKHByb3BzOiBMb2dQcm9ic0NvbnRlbnREb25lRXZlbnQpID0+IHZvaWQ7XG5cbiAgJ2xvZ3Byb2JzLnJlZnVzYWwuZGVsdGEnOiAocHJvcHM6IExvZ1Byb2JzUmVmdXNhbERlbHRhRXZlbnQpID0+IHZvaWQ7XG4gICdsb2dwcm9icy5yZWZ1c2FsLmRvbmUnOiAocHJvcHM6IExvZ1Byb2JzUmVmdXNhbERvbmVFdmVudCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25TdHJlYW1QYXJhbXMgPSBPbWl0PENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSwgJ3N0cmVhbSc+ICYge1xuICBzdHJlYW0/OiB0cnVlO1xufTtcblxuaW50ZXJmYWNlIENob2ljZUV2ZW50U3RhdGUge1xuICBjb250ZW50X2RvbmU6IGJvb2xlYW47XG4gIHJlZnVzYWxfZG9uZTogYm9vbGVhbjtcbiAgbG9ncHJvYnNfY29udGVudF9kb25lOiBib29sZWFuO1xuICBsb2dwcm9ic19yZWZ1c2FsX2RvbmU6IGJvb2xlYW47XG4gIGN1cnJlbnRfdG9vbF9jYWxsX2luZGV4OiBudW1iZXIgfCBudWxsO1xuICBkb25lX3Rvb2xfY2FsbHM6IFNldDxudW1iZXI+O1xufVxuXG5leHBvcnQgY2xhc3MgQ2hhdENvbXBsZXRpb25TdHJlYW08UGFyc2VkVCA9IG51bGw+XG4gIGV4dGVuZHMgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcjxDaGF0Q29tcGxldGlvblN0cmVhbUV2ZW50czxQYXJzZWRUPiwgUGFyc2VkVD5cbiAgaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPENoYXRDb21wbGV0aW9uQ2h1bms+XG57XG4gICNwYXJhbXM6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIHwgbnVsbDtcbiAgI2Nob2ljZUV2ZW50U3RhdGVzOiBDaG9pY2VFdmVudFN0YXRlW107XG4gICNjdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdDogQ2hhdENvbXBsZXRpb25TbmFwc2hvdCB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXM6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIHwgbnVsbCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jcGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuI2Nob2ljZUV2ZW50U3RhdGVzID0gW107XG4gIH1cblxuICBnZXQgY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3QoKTogQ2hhdENvbXBsZXRpb25TbmFwc2hvdCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90O1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVuZGVkIGZvciB1c2Ugb24gdGhlIGZyb250ZW5kLCBjb25zdW1pbmcgYSBzdHJlYW0gcHJvZHVjZWQgd2l0aFxuICAgKiBgLnRvUmVhZGFibGVTdHJlYW0oKWAgb24gdGhlIGJhY2tlbmQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBtZXNzYWdlcyBzZW50IHRvIHRoZSBtb2RlbCBkbyBub3QgYXBwZWFyIGluIGAub24oJ21lc3NhZ2UnKWBcbiAgICogaW4gdGhpcyBjb250ZXh0LlxuICAgKi9cbiAgc3RhdGljIGZyb21SZWFkYWJsZVN0cmVhbShzdHJlYW06IFJlYWRhYmxlU3RyZWFtKTogQ2hhdENvbXBsZXRpb25TdHJlYW08bnVsbD4ge1xuICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBDaGF0Q29tcGxldGlvblN0cmVhbShudWxsKTtcbiAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX2Zyb21SZWFkYWJsZVN0cmVhbShzdHJlYW0pKTtcbiAgICByZXR1cm4gcnVubmVyO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUNoYXRDb21wbGV0aW9uPFBhcnNlZFQ+KFxuICAgIGNsaWVudDogT3BlbkFJLFxuICAgIHBhcmFtczogQ2hhdENvbXBsZXRpb25TdHJlYW1QYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENoYXRDb21wbGV0aW9uU3RyZWFtPFBhcnNlZFQ+IHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgQ2hhdENvbXBsZXRpb25TdHJlYW08UGFyc2VkVD4ocGFyYW1zIGFzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nKTtcbiAgICBydW5uZXIuX3J1bigoKSA9PlxuICAgICAgcnVubmVyLl9ydW5DaGF0Q29tcGxldGlvbihcbiAgICAgICAgY2xpZW50LFxuICAgICAgICB7IC4uLnBhcmFtcywgc3RyZWFtOiB0cnVlIH0sXG4gICAgICAgIHsgLi4ub3B0aW9ucywgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtSGVscGVyLU1ldGhvZCc6ICdzdHJlYW0nIH0gfSxcbiAgICAgICksXG4gICAgKTtcbiAgICByZXR1cm4gcnVubmVyO1xuICB9XG5cbiAgI2JlZ2luUmVxdWVzdCgpIHtcbiAgICBpZiAodGhpcy5lbmRlZCkgcmV0dXJuO1xuICAgIHRoaXMuI2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgI2dldENob2ljZUV2ZW50U3RhdGUoY2hvaWNlOiBDaGF0Q29tcGxldGlvblNuYXBzaG90LkNob2ljZSk6IENob2ljZUV2ZW50U3RhdGUge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuI2Nob2ljZUV2ZW50U3RhdGVzW2Nob2ljZS5pbmRleF07XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgc3RhdGUgPSB7XG4gICAgICBjb250ZW50X2RvbmU6IGZhbHNlLFxuICAgICAgcmVmdXNhbF9kb25lOiBmYWxzZSxcbiAgICAgIGxvZ3Byb2JzX2NvbnRlbnRfZG9uZTogZmFsc2UsXG4gICAgICBsb2dwcm9ic19yZWZ1c2FsX2RvbmU6IGZhbHNlLFxuICAgICAgZG9uZV90b29sX2NhbGxzOiBuZXcgU2V0KCksXG4gICAgICBjdXJyZW50X3Rvb2xfY2FsbF9pbmRleDogbnVsbCxcbiAgICB9O1xuICAgIHRoaXMuI2Nob2ljZUV2ZW50U3RhdGVzW2Nob2ljZS5pbmRleF0gPSBzdGF0ZTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICAjYWRkQ2h1bmsodGhpczogQ2hhdENvbXBsZXRpb25TdHJlYW08UGFyc2VkVD4sIGNodW5rOiBDaGF0Q29tcGxldGlvbkNodW5rKSB7XG4gICAgaWYgKHRoaXMuZW5kZWQpIHJldHVybjtcblxuICAgIGNvbnN0IGNvbXBsZXRpb24gPSB0aGlzLiNhY2N1bXVsYXRlQ2hhdENvbXBsZXRpb24oY2h1bmspO1xuICAgIHRoaXMuX2VtaXQoJ2NodW5rJywgY2h1bmssIGNvbXBsZXRpb24pO1xuXG4gICAgZm9yIChjb25zdCBjaG9pY2Ugb2YgY2h1bmsuY2hvaWNlcykge1xuICAgICAgY29uc3QgY2hvaWNlU25hcHNob3QgPSBjb21wbGV0aW9uLmNob2ljZXNbY2hvaWNlLmluZGV4XSE7XG5cbiAgICAgIGlmIChcbiAgICAgICAgY2hvaWNlLmRlbHRhLmNvbnRlbnQgIT0gbnVsbCAmJlxuICAgICAgICBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlPy5yb2xlID09PSAnYXNzaXN0YW50JyAmJlxuICAgICAgICBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlPy5jb250ZW50XG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fZW1pdCgnY29udGVudCcsIGNob2ljZS5kZWx0YS5jb250ZW50LCBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICB0aGlzLl9lbWl0KCdjb250ZW50LmRlbHRhJywge1xuICAgICAgICAgIGRlbHRhOiBjaG9pY2UuZGVsdGEuY29udGVudCxcbiAgICAgICAgICBzbmFwc2hvdDogY2hvaWNlU25hcHNob3QubWVzc2FnZS5jb250ZW50LFxuICAgICAgICAgIHBhcnNlZDogY2hvaWNlU25hcHNob3QubWVzc2FnZS5wYXJzZWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGNob2ljZS5kZWx0YS5yZWZ1c2FsICE9IG51bGwgJiZcbiAgICAgICAgY2hvaWNlU25hcHNob3QubWVzc2FnZT8ucm9sZSA9PT0gJ2Fzc2lzdGFudCcgJiZcbiAgICAgICAgY2hvaWNlU25hcHNob3QubWVzc2FnZT8ucmVmdXNhbFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJ3JlZnVzYWwuZGVsdGEnLCB7XG4gICAgICAgICAgZGVsdGE6IGNob2ljZS5kZWx0YS5yZWZ1c2FsLFxuICAgICAgICAgIHNuYXBzaG90OiBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLnJlZnVzYWwsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hvaWNlLmxvZ3Byb2JzPy5jb250ZW50ICE9IG51bGwgJiYgY2hvaWNlU25hcHNob3QubWVzc2FnZT8ucm9sZSA9PT0gJ2Fzc2lzdGFudCcpIHtcbiAgICAgICAgdGhpcy5fZW1pdCgnbG9ncHJvYnMuY29udGVudC5kZWx0YScsIHtcbiAgICAgICAgICBjb250ZW50OiBjaG9pY2UubG9ncHJvYnM/LmNvbnRlbnQsXG4gICAgICAgICAgc25hcHNob3Q6IGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzPy5jb250ZW50ID8/IFtdLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNob2ljZS5sb2dwcm9icz8ucmVmdXNhbCAhPSBudWxsICYmIGNob2ljZVNuYXBzaG90Lm1lc3NhZ2U/LnJvbGUgPT09ICdhc3Npc3RhbnQnKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJ2xvZ3Byb2JzLnJlZnVzYWwuZGVsdGEnLCB7XG4gICAgICAgICAgcmVmdXNhbDogY2hvaWNlLmxvZ3Byb2JzPy5yZWZ1c2FsLFxuICAgICAgICAgIHNuYXBzaG90OiBjaG9pY2VTbmFwc2hvdC5sb2dwcm9icz8ucmVmdXNhbCA/PyBbXSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jZ2V0Q2hvaWNlRXZlbnRTdGF0ZShjaG9pY2VTbmFwc2hvdCk7XG5cbiAgICAgIGlmIChjaG9pY2VTbmFwc2hvdC5maW5pc2hfcmVhc29uKSB7XG4gICAgICAgIHRoaXMuI2VtaXRDb250ZW50RG9uZUV2ZW50cyhjaG9pY2VTbmFwc2hvdCk7XG5cbiAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRfdG9vbF9jYWxsX2luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLiNlbWl0VG9vbENhbGxEb25lRXZlbnQoY2hvaWNlU25hcHNob3QsIHN0YXRlLmN1cnJlbnRfdG9vbF9jYWxsX2luZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIGNob2ljZS5kZWx0YS50b29sX2NhbGxzID8/IFtdKSB7XG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50X3Rvb2xfY2FsbF9pbmRleCAhPT0gdG9vbENhbGwuaW5kZXgpIHtcbiAgICAgICAgICB0aGlzLiNlbWl0Q29udGVudERvbmVFdmVudHMoY2hvaWNlU25hcHNob3QpO1xuXG4gICAgICAgICAgLy8gbmV3IHRvb2wgY2FsbCBzdGFydGVkLCB0aGUgcHJldmlvdXMgb25lIGlzIGRvbmVcbiAgICAgICAgICBpZiAoc3RhdGUuY3VycmVudF90b29sX2NhbGxfaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jZW1pdFRvb2xDYWxsRG9uZUV2ZW50KGNob2ljZVNuYXBzaG90LCBzdGF0ZS5jdXJyZW50X3Rvb2xfY2FsbF9pbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuY3VycmVudF90b29sX2NhbGxfaW5kZXggPSB0b29sQ2FsbC5pbmRleDtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCB0b29sQ2FsbERlbHRhIG9mIGNob2ljZS5kZWx0YS50b29sX2NhbGxzID8/IFtdKSB7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsU25hcHNob3QgPSBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLnRvb2xfY2FsbHM/Llt0b29sQ2FsbERlbHRhLmluZGV4XTtcbiAgICAgICAgaWYgKCF0b29sQ2FsbFNuYXBzaG90Py50eXBlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9vbENhbGxTbmFwc2hvdD8udHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMuX2VtaXQoJ3Rvb2xfY2FsbHMuZnVuY3Rpb24uYXJndW1lbnRzLmRlbHRhJywge1xuICAgICAgICAgICAgbmFtZTogdG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbj8ubmFtZSxcbiAgICAgICAgICAgIGluZGV4OiB0b29sQ2FsbERlbHRhLmluZGV4LFxuICAgICAgICAgICAgYXJndW1lbnRzOiB0b29sQ2FsbFNuYXBzaG90LmZ1bmN0aW9uLmFyZ3VtZW50cyxcbiAgICAgICAgICAgIHBhcnNlZF9hcmd1bWVudHM6IHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24ucGFyc2VkX2FyZ3VtZW50cyxcbiAgICAgICAgICAgIGFyZ3VtZW50c19kZWx0YTogdG9vbENhbGxEZWx0YS5mdW5jdGlvbj8uYXJndW1lbnRzID8/ICcnLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2VydE5ldmVyKHRvb2xDYWxsU25hcHNob3Q/LnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgI2VtaXRUb29sQ2FsbERvbmVFdmVudChjaG9pY2VTbmFwc2hvdDogQ2hhdENvbXBsZXRpb25TbmFwc2hvdC5DaG9pY2UsIHRvb2xDYWxsSW5kZXg6IG51bWJlcikge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jZ2V0Q2hvaWNlRXZlbnRTdGF0ZShjaG9pY2VTbmFwc2hvdCk7XG4gICAgaWYgKHN0YXRlLmRvbmVfdG9vbF9jYWxscy5oYXModG9vbENhbGxJbmRleCkpIHtcbiAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgZmlyZWQgdGhlIGRvbmUgZXZlbnRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0b29sQ2FsbFNuYXBzaG90ID0gY2hvaWNlU25hcHNob3QubWVzc2FnZS50b29sX2NhbGxzPy5bdG9vbENhbGxJbmRleF07XG4gICAgaWYgKCF0b29sQ2FsbFNuYXBzaG90KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHRvb2wgY2FsbCBzbmFwc2hvdCcpO1xuICAgIH1cbiAgICBpZiAoIXRvb2xDYWxsU25hcHNob3QudHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29sIGNhbGwgc25hcHNob3QgbWlzc2luZyBgdHlwZWAnKTtcbiAgICB9XG5cbiAgICBpZiAodG9vbENhbGxTbmFwc2hvdC50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBpbnB1dFRvb2wgPSB0aGlzLiNwYXJhbXM/LnRvb2xzPy5maW5kKFxuICAgICAgICAodG9vbCkgPT4gdG9vbC50eXBlID09PSAnZnVuY3Rpb24nICYmIHRvb2wuZnVuY3Rpb24ubmFtZSA9PT0gdG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbi5uYW1lLFxuICAgICAgKTtcblxuICAgICAgdGhpcy5fZW1pdCgndG9vbF9jYWxscy5mdW5jdGlvbi5hcmd1bWVudHMuZG9uZScsIHtcbiAgICAgICAgbmFtZTogdG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICBpbmRleDogdG9vbENhbGxJbmRleCxcbiAgICAgICAgYXJndW1lbnRzOiB0b29sQ2FsbFNuYXBzaG90LmZ1bmN0aW9uLmFyZ3VtZW50cyxcbiAgICAgICAgcGFyc2VkX2FyZ3VtZW50czpcbiAgICAgICAgICBpc0F1dG9QYXJzYWJsZVRvb2woaW5wdXRUb29sKSA/IGlucHV0VG9vbC4kcGFyc2VSYXcodG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbi5hcmd1bWVudHMpXG4gICAgICAgICAgOiBpbnB1dFRvb2w/LmZ1bmN0aW9uLnN0cmljdCA/IEpTT04ucGFyc2UodG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbi5hcmd1bWVudHMpXG4gICAgICAgICAgOiBudWxsLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydE5ldmVyKHRvb2xDYWxsU25hcHNob3QudHlwZSk7XG4gICAgfVxuICB9XG5cbiAgI2VtaXRDb250ZW50RG9uZUV2ZW50cyhjaG9pY2VTbmFwc2hvdDogQ2hhdENvbXBsZXRpb25TbmFwc2hvdC5DaG9pY2UpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuI2dldENob2ljZUV2ZW50U3RhdGUoY2hvaWNlU25hcHNob3QpO1xuXG4gICAgaWYgKGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UuY29udGVudCAmJiAhc3RhdGUuY29udGVudF9kb25lKSB7XG4gICAgICBzdGF0ZS5jb250ZW50X2RvbmUgPSB0cnVlO1xuXG4gICAgICBjb25zdCByZXNwb25zZUZvcm1hdCA9IHRoaXMuI2dldEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdCgpO1xuXG4gICAgICB0aGlzLl9lbWl0KCdjb250ZW50LmRvbmUnLCB7XG4gICAgICAgIGNvbnRlbnQ6IGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgcGFyc2VkOiByZXNwb25zZUZvcm1hdCA/IHJlc3BvbnNlRm9ybWF0LiRwYXJzZVJhdyhjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLmNvbnRlbnQpIDogKG51bGwgYXMgYW55KSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLnJlZnVzYWwgJiYgIXN0YXRlLnJlZnVzYWxfZG9uZSkge1xuICAgICAgc3RhdGUucmVmdXNhbF9kb25lID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fZW1pdCgncmVmdXNhbC5kb25lJywgeyByZWZ1c2FsOiBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLnJlZnVzYWwgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzPy5jb250ZW50ICYmICFzdGF0ZS5sb2dwcm9ic19jb250ZW50X2RvbmUpIHtcbiAgICAgIHN0YXRlLmxvZ3Byb2JzX2NvbnRlbnRfZG9uZSA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2VtaXQoJ2xvZ3Byb2JzLmNvbnRlbnQuZG9uZScsIHsgY29udGVudDogY2hvaWNlU25hcHNob3QubG9ncHJvYnMuY29udGVudCB9KTtcbiAgICB9XG5cbiAgICBpZiAoY2hvaWNlU25hcHNob3QubG9ncHJvYnM/LnJlZnVzYWwgJiYgIXN0YXRlLmxvZ3Byb2JzX3JlZnVzYWxfZG9uZSkge1xuICAgICAgc3RhdGUubG9ncHJvYnNfcmVmdXNhbF9kb25lID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fZW1pdCgnbG9ncHJvYnMucmVmdXNhbC5kb25lJywgeyByZWZ1c2FsOiBjaG9pY2VTbmFwc2hvdC5sb2dwcm9icy5yZWZ1c2FsIH0pO1xuICAgIH1cbiAgfVxuXG4gICNlbmRSZXF1ZXN0KCk6IFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+IHtcbiAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBzdHJlYW0gaGFzIGVuZGVkLCB0aGlzIHNob3VsZG4ndCBoYXBwZW5gKTtcbiAgICB9XG4gICAgY29uc3Qgc25hcHNob3QgPSB0aGlzLiNjdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdDtcbiAgICBpZiAoIXNuYXBzaG90KSB7XG4gICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYHJlcXVlc3QgZW5kZWQgd2l0aG91dCBzZW5kaW5nIGFueSBjaHVua3NgKTtcbiAgICB9XG4gICAgdGhpcy4jY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4jY2hvaWNlRXZlbnRTdGF0ZXMgPSBbXTtcbiAgICByZXR1cm4gZmluYWxpemVDaGF0Q29tcGxldGlvbihzbmFwc2hvdCwgdGhpcy4jcGFyYW1zKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBhc3luYyBfY3JlYXRlQ2hhdENvbXBsZXRpb24oXG4gICAgY2xpZW50OiBPcGVuQUksXG4gICAgcGFyYW1zOiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxQYXJzZWRDaGF0Q29tcGxldGlvbjxQYXJzZWRUPj4ge1xuICAgIHN1cGVyLl9jcmVhdGVDaGF0Q29tcGxldGlvbjtcbiAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXMuY29udHJvbGxlci5hYm9ydCgpKTtcbiAgICB9XG4gICAgdGhpcy4jYmVnaW5SZXF1ZXN0KCk7XG5cbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBjbGllbnQuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoXG4gICAgICB7IC4uLnBhcmFtcywgc3RyZWFtOiB0cnVlIH0sXG4gICAgICB7IC4uLm9wdGlvbnMsIHNpZ25hbDogdGhpcy5jb250cm9sbGVyLnNpZ25hbCB9LFxuICAgICk7XG4gICAgdGhpcy5fY29ubmVjdGVkKCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgIHRoaXMuI2FkZENodW5rKGNodW5rKTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5jb250cm9sbGVyLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hZGRDaGF0Q29tcGxldGlvbih0aGlzLiNlbmRSZXF1ZXN0KCkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9mcm9tUmVhZGFibGVTdHJlYW0oXG4gICAgcmVhZGFibGVTdHJlYW06IFJlYWRhYmxlU3RyZWFtLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBQcm9taXNlPENoYXRDb21wbGV0aW9uPiB7XG4gICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgIGlmIChzaWduYWwpIHtcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgfVxuICAgIHRoaXMuI2JlZ2luUmVxdWVzdCgpO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCgpO1xuICAgIGNvbnN0IHN0cmVhbSA9IFN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW08Q2hhdENvbXBsZXRpb25DaHVuaz4ocmVhZGFibGVTdHJlYW0sIHRoaXMuY29udHJvbGxlcik7XG4gICAgbGV0IGNoYXRJZDtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgaWYgKGNoYXRJZCAmJiBjaGF0SWQgIT09IGNodW5rLmlkKSB7XG4gICAgICAgIC8vIEEgbmV3IHJlcXVlc3QgaGFzIGJlZW4gbWFkZS5cbiAgICAgICAgdGhpcy5fYWRkQ2hhdENvbXBsZXRpb24odGhpcy4jZW5kUmVxdWVzdCgpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4jYWRkQ2h1bmsoY2h1bmspO1xuICAgICAgY2hhdElkID0gY2h1bmsuaWQ7XG4gICAgfVxuICAgIGlmIChzdHJlYW0uY29udHJvbGxlci5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hhdENvbXBsZXRpb24odGhpcy4jZW5kUmVxdWVzdCgpKTtcbiAgfVxuXG4gICNnZXRBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQoKTogQXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0PFBhcnNlZFQ+IHwgbnVsbCB7XG4gICAgY29uc3QgcmVzcG9uc2VGb3JtYXQgPSB0aGlzLiNwYXJhbXM/LnJlc3BvbnNlX2Zvcm1hdDtcbiAgICBpZiAoaXNBdXRvUGFyc2FibGVSZXNwb25zZUZvcm1hdDxQYXJzZWRUPihyZXNwb25zZUZvcm1hdCkpIHtcbiAgICAgIHJldHVybiByZXNwb25zZUZvcm1hdDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gICNhY2N1bXVsYXRlQ2hhdENvbXBsZXRpb24oY2h1bms6IENoYXRDb21wbGV0aW9uQ2h1bmspOiBDaGF0Q29tcGxldGlvblNuYXBzaG90IHtcbiAgICBsZXQgc25hcHNob3QgPSB0aGlzLiNjdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdDtcbiAgICBjb25zdCB7IGNob2ljZXMsIC4uLnJlc3QgfSA9IGNodW5rO1xuICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgIHNuYXBzaG90ID0gdGhpcy4jY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3QgPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGNob2ljZXM6IFtdLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmFzc2lnbihzbmFwc2hvdCwgcmVzdCk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB7IGRlbHRhLCBmaW5pc2hfcmVhc29uLCBpbmRleCwgbG9ncHJvYnMgPSBudWxsLCAuLi5vdGhlciB9IG9mIGNodW5rLmNob2ljZXMpIHtcbiAgICAgIGxldCBjaG9pY2UgPSBzbmFwc2hvdC5jaG9pY2VzW2luZGV4XTtcbiAgICAgIGlmICghY2hvaWNlKSB7XG4gICAgICAgIGNob2ljZSA9IHNuYXBzaG90LmNob2ljZXNbaW5kZXhdID0geyBmaW5pc2hfcmVhc29uLCBpbmRleCwgbWVzc2FnZToge30sIGxvZ3Byb2JzLCAuLi5vdGhlciB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobG9ncHJvYnMpIHtcbiAgICAgICAgaWYgKCFjaG9pY2UubG9ncHJvYnMpIHtcbiAgICAgICAgICBjaG9pY2UubG9ncHJvYnMgPSBPYmplY3QuYXNzaWduKHt9LCBsb2dwcm9icyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgeyBjb250ZW50LCByZWZ1c2FsLCAuLi5yZXN0IH0gPSBsb2dwcm9icztcbiAgICAgICAgICBhc3NlcnRJc0VtcHR5KHJlc3QpO1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2hvaWNlLmxvZ3Byb2JzLCByZXN0KTtcblxuICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICBjaG9pY2UubG9ncHJvYnMuY29udGVudCA/Pz0gW107XG4gICAgICAgICAgICBjaG9pY2UubG9ncHJvYnMuY29udGVudC5wdXNoKC4uLmNvbnRlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZWZ1c2FsKSB7XG4gICAgICAgICAgICBjaG9pY2UubG9ncHJvYnMucmVmdXNhbCA/Pz0gW107XG4gICAgICAgICAgICBjaG9pY2UubG9ncHJvYnMucmVmdXNhbC5wdXNoKC4uLnJlZnVzYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluaXNoX3JlYXNvbikge1xuICAgICAgICBjaG9pY2UuZmluaXNoX3JlYXNvbiA9IGZpbmlzaF9yZWFzb247XG5cbiAgICAgICAgaWYgKHRoaXMuI3BhcmFtcyAmJiBoYXNBdXRvUGFyc2VhYmxlSW5wdXQodGhpcy4jcGFyYW1zKSkge1xuICAgICAgICAgIGlmIChmaW5pc2hfcmVhc29uID09PSAnbGVuZ3RoJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IExlbmd0aEZpbmlzaFJlYXNvbkVycm9yKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZpbmlzaF9yZWFzb24gPT09ICdjb250ZW50X2ZpbHRlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb250ZW50RmlsdGVyRmluaXNoUmVhc29uRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihjaG9pY2UsIG90aGVyKTtcblxuICAgICAgaWYgKCFkZWx0YSkgY29udGludWU7IC8vIFNob3VsZG4ndCBoYXBwZW47IGp1c3QgaW4gY2FzZS5cblxuICAgICAgY29uc3QgeyBjb250ZW50LCByZWZ1c2FsLCBmdW5jdGlvbl9jYWxsLCByb2xlLCB0b29sX2NhbGxzLCAuLi5yZXN0IH0gPSBkZWx0YTtcbiAgICAgIGFzc2VydElzRW1wdHkocmVzdCk7XG4gICAgICBPYmplY3QuYXNzaWduKGNob2ljZS5tZXNzYWdlLCByZXN0KTtcblxuICAgICAgaWYgKHJlZnVzYWwpIHtcbiAgICAgICAgY2hvaWNlLm1lc3NhZ2UucmVmdXNhbCA9IChjaG9pY2UubWVzc2FnZS5yZWZ1c2FsIHx8ICcnKSArIHJlZnVzYWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChyb2xlKSBjaG9pY2UubWVzc2FnZS5yb2xlID0gcm9sZTtcbiAgICAgIGlmIChmdW5jdGlvbl9jYWxsKSB7XG4gICAgICAgIGlmICghY2hvaWNlLm1lc3NhZ2UuZnVuY3Rpb25fY2FsbCkge1xuICAgICAgICAgIGNob2ljZS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPSBmdW5jdGlvbl9jYWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmdW5jdGlvbl9jYWxsLm5hbWUpIGNob2ljZS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwubmFtZSA9IGZ1bmN0aW9uX2NhbGwubmFtZTtcbiAgICAgICAgICBpZiAoZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMpIHtcbiAgICAgICAgICAgIGNob2ljZS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzID8/PSAnJztcbiAgICAgICAgICAgIGNob2ljZS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICs9IGZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgY2hvaWNlLm1lc3NhZ2UuY29udGVudCA9IChjaG9pY2UubWVzc2FnZS5jb250ZW50IHx8ICcnKSArIGNvbnRlbnQ7XG5cbiAgICAgICAgaWYgKCFjaG9pY2UubWVzc2FnZS5yZWZ1c2FsICYmIHRoaXMuI2dldEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdCgpKSB7XG4gICAgICAgICAgY2hvaWNlLm1lc3NhZ2UucGFyc2VkID0gcGFydGlhbFBhcnNlKGNob2ljZS5tZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0b29sX2NhbGxzKSB7XG4gICAgICAgIGlmICghY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxscykgY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxscyA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgeyBpbmRleCwgaWQsIHR5cGUsIGZ1bmN0aW9uOiBmbiwgLi4ucmVzdCB9IG9mIHRvb2xfY2FsbHMpIHtcbiAgICAgICAgICBjb25zdCB0b29sX2NhbGwgPSAoY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxsc1tpbmRleF0gPz89XG4gICAgICAgICAgICB7fSBhcyBDaGF0Q29tcGxldGlvblNuYXBzaG90LkNob2ljZS5NZXNzYWdlLlRvb2xDYWxsKTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRvb2xfY2FsbCwgcmVzdCk7XG4gICAgICAgICAgaWYgKGlkKSB0b29sX2NhbGwuaWQgPSBpZDtcbiAgICAgICAgICBpZiAodHlwZSkgdG9vbF9jYWxsLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIGlmIChmbikgdG9vbF9jYWxsLmZ1bmN0aW9uID8/PSB7IG5hbWU6IGZuLm5hbWUgPz8gJycsIGFyZ3VtZW50czogJycgfTtcbiAgICAgICAgICBpZiAoZm4/Lm5hbWUpIHRvb2xfY2FsbC5mdW5jdGlvbiEubmFtZSA9IGZuLm5hbWU7XG4gICAgICAgICAgaWYgKGZuPy5hcmd1bWVudHMpIHtcbiAgICAgICAgICAgIHRvb2xfY2FsbC5mdW5jdGlvbiEuYXJndW1lbnRzICs9IGZuLmFyZ3VtZW50cztcblxuICAgICAgICAgICAgaWYgKHNob3VsZFBhcnNlVG9vbENhbGwodGhpcy4jcGFyYW1zLCB0b29sX2NhbGwpKSB7XG4gICAgICAgICAgICAgIHRvb2xfY2FsbC5mdW5jdGlvbiEucGFyc2VkX2FyZ3VtZW50cyA9IHBhcnRpYWxQYXJzZSh0b29sX2NhbGwuZnVuY3Rpb24hLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbmFwc2hvdDtcbiAgfVxuXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0odGhpczogQ2hhdENvbXBsZXRpb25TdHJlYW08UGFyc2VkVD4pOiBBc3luY0l0ZXJhdG9yPENoYXRDb21wbGV0aW9uQ2h1bms+IHtcbiAgICBjb25zdCBwdXNoUXVldWU6IENoYXRDb21wbGV0aW9uQ2h1bmtbXSA9IFtdO1xuICAgIGNvbnN0IHJlYWRRdWV1ZToge1xuICAgICAgcmVzb2x2ZTogKGNodW5rOiBDaGF0Q29tcGxldGlvbkNodW5rIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuICAgICAgcmVqZWN0OiAoZXJyOiB1bmtub3duKSA9PiB2b2lkO1xuICAgIH1bXSA9IFtdO1xuICAgIGxldCBkb25lID0gZmFsc2U7XG5cbiAgICB0aGlzLm9uKCdjaHVuaycsIChjaHVuaykgPT4ge1xuICAgICAgY29uc3QgcmVhZGVyID0gcmVhZFF1ZXVlLnNoaWZ0KCk7XG4gICAgICBpZiAocmVhZGVyKSB7XG4gICAgICAgIHJlYWRlci5yZXNvbHZlKGNodW5rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hRdWV1ZS5wdXNoKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMub24oJ2VuZCcsICgpID0+IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgcmVhZFF1ZXVlKSB7XG4gICAgICAgIHJlYWRlci5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICB9KTtcblxuICAgIHRoaXMub24oJ2Fib3J0JywgKGVycikgPT4ge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiByZWFkUXVldWUpIHtcbiAgICAgICAgcmVhZGVyLnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVhZFF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgcmVhZFF1ZXVlKSB7XG4gICAgICAgIHJlYWRlci5yZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlYWRRdWV1ZS5sZW5ndGggPSAwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGFzeW5jICgpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PENoYXRDb21wbGV0aW9uQ2h1bms+PiA9PiB7XG4gICAgICAgIGlmICghcHVzaFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxDaGF0Q29tcGxldGlvbkNodW5rIHwgdW5kZWZpbmVkPigocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgICAgICAgcmVhZFF1ZXVlLnB1c2goeyByZXNvbHZlLCByZWplY3QgfSksXG4gICAgICAgICAgKS50aGVuKChjaHVuaykgPT4gKGNodW5rID8geyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0gOiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNodW5rID0gcHVzaFF1ZXVlLnNoaWZ0KCkhO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH07XG4gICAgICB9LFxuICAgICAgcmV0dXJuOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRoaXMuYWJvcnQoKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgdG9SZWFkYWJsZVN0cmVhbSgpOiBSZWFkYWJsZVN0cmVhbSB7XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IFN0cmVhbSh0aGlzW1N5bWJvbC5hc3luY0l0ZXJhdG9yXS5iaW5kKHRoaXMpLCB0aGlzLmNvbnRyb2xsZXIpO1xuICAgIHJldHVybiBzdHJlYW0udG9SZWFkYWJsZVN0cmVhbSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplQ2hhdENvbXBsZXRpb248UGFyc2VkVD4oXG4gIHNuYXBzaG90OiBDaGF0Q29tcGxldGlvblNuYXBzaG90LFxuICBwYXJhbXM6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIHwgbnVsbCxcbik6IFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+IHtcbiAgY29uc3QgeyBpZCwgY2hvaWNlcywgY3JlYXRlZCwgbW9kZWwsIHN5c3RlbV9maW5nZXJwcmludCwgLi4ucmVzdCB9ID0gc25hcHNob3Q7XG4gIGNvbnN0IGNvbXBsZXRpb246IENoYXRDb21wbGV0aW9uID0ge1xuICAgIC4uLnJlc3QsXG4gICAgaWQsXG4gICAgY2hvaWNlczogY2hvaWNlcy5tYXAoXG4gICAgICAoeyBtZXNzYWdlLCBmaW5pc2hfcmVhc29uLCBpbmRleCwgbG9ncHJvYnMsIC4uLmNob2ljZVJlc3QgfSk6IENoYXRDb21wbGV0aW9uLkNob2ljZSA9PiB7XG4gICAgICAgIGlmICghZmluaXNoX3JlYXNvbikge1xuICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBmaW5pc2hfcmVhc29uIGZvciBjaG9pY2UgJHtpbmRleH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgY29udGVudCA9IG51bGwsIGZ1bmN0aW9uX2NhbGwsIHRvb2xfY2FsbHMsIC4uLm1lc3NhZ2VSZXN0IH0gPSBtZXNzYWdlO1xuICAgICAgICBjb25zdCByb2xlID0gbWVzc2FnZS5yb2xlIGFzICdhc3Npc3RhbnQnOyAvLyB0aGlzIGlzIHdoYXQgd2UgZXhwZWN0OyBpbiB0aGVvcnkgaXQgY291bGQgYmUgZGlmZmVyZW50IHdoaWNoIHdvdWxkIG1ha2Ugb3VyIHR5cGVzIGEgc2xpZ2h0IGxpZSBidXQgd291bGQgYmUgZmluZS5cbiAgICAgICAgaWYgKCFyb2xlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIHJvbGUgZm9yIGNob2ljZSAke2luZGV4fWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZ1bmN0aW9uX2NhbGwpIHtcbiAgICAgICAgICBjb25zdCB7IGFyZ3VtZW50czogYXJncywgbmFtZSB9ID0gZnVuY3Rpb25fY2FsbDtcbiAgICAgICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYG1pc3NpbmcgZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgZm9yIGNob2ljZSAke2luZGV4fWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIGZ1bmN0aW9uX2NhbGwubmFtZSBmb3IgY2hvaWNlICR7aW5kZXh9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNob2ljZVJlc3QsXG4gICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IHsgYXJndW1lbnRzOiBhcmdzLCBuYW1lIH0sXG4gICAgICAgICAgICAgIHJvbGUsXG4gICAgICAgICAgICAgIHJlZnVzYWw6IG1lc3NhZ2UucmVmdXNhbCA/PyBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbmlzaF9yZWFzb24sXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIGxvZ3Byb2JzLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9vbF9jYWxscykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jaG9pY2VSZXN0LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBmaW5pc2hfcmVhc29uLFxuICAgICAgICAgICAgbG9ncHJvYnMsXG4gICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgIC4uLm1lc3NhZ2VSZXN0LFxuICAgICAgICAgICAgICByb2xlLFxuICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICByZWZ1c2FsOiBtZXNzYWdlLnJlZnVzYWwgPz8gbnVsbCxcbiAgICAgICAgICAgICAgdG9vbF9jYWxsczogdG9vbF9jYWxscy5tYXAoKHRvb2xfY2FsbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZnVuY3Rpb246IGZuLCB0eXBlLCBpZCwgLi4udG9vbFJlc3QgfSA9IHRvb2xfY2FsbDtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFyZ3VtZW50czogYXJncywgbmFtZSwgLi4uZm5SZXN0IH0gPSBmbiB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIGNob2ljZXNbJHtpbmRleH1dLnRvb2xfY2FsbHNbJHtpfV0uaWRcXG4ke3N0cihzbmFwc2hvdCl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBjaG9pY2VzWyR7aW5kZXh9XS50b29sX2NhbGxzWyR7aX1dLnR5cGVcXG4ke3N0cihzbmFwc2hvdCl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYG1pc3NpbmcgY2hvaWNlc1ske2luZGV4fV0udG9vbF9jYWxsc1ske2l9XS5mdW5jdGlvbi5uYW1lXFxuJHtzdHIoc25hcHNob3QpfWAsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBtaXNzaW5nIGNob2ljZXNbJHtpbmRleH1dLnRvb2xfY2FsbHNbJHtpfV0uZnVuY3Rpb24uYXJndW1lbnRzXFxuJHtzdHIoc25hcHNob3QpfWAsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnRvb2xSZXN0LCBpZCwgdHlwZSwgZnVuY3Rpb246IHsgLi4uZm5SZXN0LCBuYW1lLCBhcmd1bWVudHM6IGFyZ3MgfSB9O1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmNob2ljZVJlc3QsXG4gICAgICAgICAgbWVzc2FnZTogeyAuLi5tZXNzYWdlUmVzdCwgY29udGVudCwgcm9sZSwgcmVmdXNhbDogbWVzc2FnZS5yZWZ1c2FsID8/IG51bGwgfSxcbiAgICAgICAgICBmaW5pc2hfcmVhc29uLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIGxvZ3Byb2JzLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICApLFxuICAgIGNyZWF0ZWQsXG4gICAgbW9kZWwsXG4gICAgb2JqZWN0OiAnY2hhdC5jb21wbGV0aW9uJyxcbiAgICAuLi4oc3lzdGVtX2ZpbmdlcnByaW50ID8geyBzeXN0ZW1fZmluZ2VycHJpbnQgfSA6IHt9KSxcbiAgfTtcblxuICByZXR1cm4gbWF5YmVQYXJzZUNoYXRDb21wbGV0aW9uKGNvbXBsZXRpb24sIHBhcmFtcyk7XG59XG5cbmZ1bmN0aW9uIHN0cih4OiB1bmtub3duKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3RyZWFtZWQgY2h1bmsgb2YgYSBjaGF0IGNvbXBsZXRpb24gcmVzcG9uc2UgcmV0dXJuZWQgYnkgbW9kZWwsXG4gKiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgaW5wdXQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25TbmFwc2hvdCB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY2hhdCBjb21wbGV0aW9uLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGNoYXQgY29tcGxldGlvbiBjaG9pY2VzLiBDYW4gYmUgbW9yZSB0aGFuIG9uZSBpZiBgbmAgaXMgZ3JlYXRlclxuICAgKiB0aGFuIDEuXG4gICAqL1xuICBjaG9pY2VzOiBBcnJheTxDaGF0Q29tcGxldGlvblNuYXBzaG90LkNob2ljZT47XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgb2Ygd2hlbiB0aGUgY2hhdCBjb21wbGV0aW9uIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdG8gZ2VuZXJhdGUgdGhlIGNvbXBsZXRpb24uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8vIE5vdGUgd2UgZG8gbm90IGluY2x1ZGUgYW4gXCJvYmplY3RcIiB0eXBlIG9uIHRoZSBzbmFwc2hvdCxcbiAgLy8gYmVjYXVzZSB0aGUgb2JqZWN0IGlzIG5vdCBhIHZhbGlkIFwiY2hhdC5jb21wbGV0aW9uXCIgdW50aWwgZmluYWxpemVkLlxuICAvLyBvYmplY3Q6ICdjaGF0LmNvbXBsZXRpb24nO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZpbmdlcnByaW50IHJlcHJlc2VudHMgdGhlIGJhY2tlbmQgY29uZmlndXJhdGlvbiB0aGF0IHRoZSBtb2RlbCBydW5zIHdpdGguXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGBzZWVkYCByZXF1ZXN0IHBhcmFtZXRlciB0byB1bmRlcnN0YW5kIHdoZW5cbiAgICogYmFja2VuZCBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlIHRoYXQgbWlnaHQgaW1wYWN0IGRldGVybWluaXNtLlxuICAgKi9cbiAgc3lzdGVtX2ZpbmdlcnByaW50Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uU25hcHNob3Qge1xuICBleHBvcnQgaW50ZXJmYWNlIENob2ljZSB7XG4gICAgLyoqXG4gICAgICogQSBjaGF0IGNvbXBsZXRpb24gZGVsdGEgZ2VuZXJhdGVkIGJ5IHN0cmVhbWVkIG1vZGVsIHJlc3BvbnNlcy5cbiAgICAgKi9cbiAgICBtZXNzYWdlOiBDaG9pY2UuTWVzc2FnZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZWFzb24gdGhlIG1vZGVsIHN0b3BwZWQgZ2VuZXJhdGluZyB0b2tlbnMuIFRoaXMgd2lsbCBiZSBgc3RvcGAgaWYgdGhlIG1vZGVsXG4gICAgICogaGl0IGEgbmF0dXJhbCBzdG9wIHBvaW50IG9yIGEgcHJvdmlkZWQgc3RvcCBzZXF1ZW5jZSwgYGxlbmd0aGAgaWYgdGhlIG1heGltdW1cbiAgICAgKiBudW1iZXIgb2YgdG9rZW5zIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdCB3YXMgcmVhY2hlZCwgYGNvbnRlbnRfZmlsdGVyYCBpZlxuICAgICAqIGNvbnRlbnQgd2FzIG9taXR0ZWQgZHVlIHRvIGEgZmxhZyBmcm9tIG91ciBjb250ZW50IGZpbHRlcnMsIG9yIGBmdW5jdGlvbl9jYWxsYFxuICAgICAqIGlmIHRoZSBtb2RlbCBjYWxsZWQgYSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmaW5pc2hfcmVhc29uOiBDaGF0Q29tcGxldGlvbi5DaG9pY2VbJ2ZpbmlzaF9yZWFzb24nXSB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBMb2cgcHJvYmFiaWxpdHkgaW5mb3JtYXRpb24gZm9yIHRoZSBjaG9pY2UuXG4gICAgICovXG4gICAgbG9ncHJvYnM6IENoYXRDb21wbGV0aW9uLkNob2ljZS5Mb2dwcm9icyB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGNob2ljZSBpbiB0aGUgbGlzdCBvZiBjaG9pY2VzLlxuICAgICAqL1xuICAgIGluZGV4OiBudW1iZXI7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIENob2ljZSB7XG4gICAgLyoqXG4gICAgICogQSBjaGF0IGNvbXBsZXRpb24gZGVsdGEgZ2VuZXJhdGVkIGJ5IHN0cmVhbWVkIG1vZGVsIHJlc3BvbnNlcy5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGNodW5rIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ/OiBzdHJpbmcgfCBudWxsO1xuXG4gICAgICByZWZ1c2FsPzogc3RyaW5nIHwgbnVsbDtcblxuICAgICAgcGFyc2VkPzogdW5rbm93biB8IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgYW5kIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZVxuICAgICAgICogbW9kZWwuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uX2NhbGw/OiBNZXNzYWdlLkZ1bmN0aW9uQ2FsbDtcblxuICAgICAgdG9vbF9jYWxscz86IEFycmF5PE1lc3NhZ2UuVG9vbENhbGw+O1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSByb2xlIG9mIHRoZSBhdXRob3Igb2YgdGhpcyBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICByb2xlPzogJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50JyB8ICdmdW5jdGlvbicgfCAndG9vbCc7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBNZXNzYWdlIHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgVG9vbENhbGwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgICBpZDogc3RyaW5nO1xuXG4gICAgICAgIGZ1bmN0aW9uOiBUb29sQ2FsbC5GdW5jdGlvbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wuXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nO1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgbmFtZXNwYWNlIFRvb2xDYWxsIHtcbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICAgICAgICAgKiBmb3JtYXQuIE5vdGUgdGhhdCB0aGUgbW9kZWwgZG9lcyBub3QgYWx3YXlzIGdlbmVyYXRlIHZhbGlkIEpTT04sIGFuZCBtYXlcbiAgICAgICAgICAgKiBoYWxsdWNpbmF0ZSBwYXJhbWV0ZXJzIG5vdCBkZWZpbmVkIGJ5IHlvdXIgZnVuY3Rpb24gc2NoZW1hLiBWYWxpZGF0ZSB0aGVcbiAgICAgICAgICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAgICAgICAgICovXG4gICAgICAgICAgYXJndW1lbnRzOiBzdHJpbmc7XG5cbiAgICAgICAgICBwYXJzZWRfYXJndW1lbnRzPzogdW5rbm93bjtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuYW1lIGFuZCBhcmd1bWVudHMgb2YgYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQsIGFzIGdlbmVyYXRlZCBieSB0aGVcbiAgICAgICAqIG1vZGVsLlxuICAgICAgICovXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQ2FsbCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGgsIGFzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaW4gSlNPTlxuICAgICAgICAgKiBmb3JtYXQuIE5vdGUgdGhhdCB0aGUgbW9kZWwgZG9lcyBub3QgYWx3YXlzIGdlbmVyYXRlIHZhbGlkIEpTT04sIGFuZCBtYXlcbiAgICAgICAgICogaGFsbHVjaW5hdGUgcGFyYW1ldGVycyBub3QgZGVmaW5lZCBieSB5b3VyIGZ1bmN0aW9uIHNjaGVtYS4gVmFsaWRhdGUgdGhlXG4gICAgICAgICAqIGFyZ3VtZW50cyBpbiB5b3VyIGNvZGUgYmVmb3JlIGNhbGxpbmcgeW91ciBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGFyZ3VtZW50cz86IHN0cmluZztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgICBuYW1lPzogc3RyaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG50eXBlIEFzc2VydElzRW1wdHk8VCBleHRlbmRzIHt9PiA9IGtleW9mIFQgZXh0ZW5kcyBuZXZlciA/IFQgOiBuZXZlcjtcblxuLyoqXG4gKiBFbnN1cmVzIHRoZSBnaXZlbiBhcmd1bWVudCBpcyBhbiBlbXB0eSBvYmplY3QsIHVzZWZ1bCBmb3JcbiAqIGFzc2VydGluZyB0aGF0IGFsbCBrbm93biBwcm9wZXJ0aWVzIG9uIGFuIG9iamVjdCBoYXZlIGJlZW5cbiAqIGRlc3RydWN0dXJlZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNFbXB0eTxUIGV4dGVuZHMge30+KG9iajogQXNzZXJ0SXNFbXB0eTxUPik6IGFzc2VydHMgb2JqIGlzIEFzc2VydElzRW1wdHk8VD4ge1xuICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIGFzc2VydE5ldmVyKF94OiBuZXZlcikge31cbiIsICJpbXBvcnQge1xuICB0eXBlIENoYXRDb21wbGV0aW9uQ2h1bmssXG4gIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG59IGZyb20gJy4uL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zJztcbmltcG9ydCB7IFJ1bm5lck9wdGlvbnMsIHR5cGUgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lckV2ZW50cyB9IGZyb20gJy4vQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcic7XG5pbXBvcnQgeyB0eXBlIFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vX3NoaW1zL2luZGV4JztcbmltcG9ydCB7IFJ1bm5hYmxlVG9vbHMsIHR5cGUgQmFzZUZ1bmN0aW9uc0FyZ3MsIHR5cGUgUnVubmFibGVGdW5jdGlvbnMgfSBmcm9tICcuL1J1bm5hYmxlRnVuY3Rpb24nO1xuaW1wb3J0IHsgQ2hhdENvbXBsZXRpb25TbmFwc2hvdCwgQ2hhdENvbXBsZXRpb25TdHJlYW0gfSBmcm9tICcuL0NoYXRDb21wbGV0aW9uU3RyZWFtJztcbmltcG9ydCBPcGVuQUkgZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHsgQXV0b1BhcnNlYWJsZVRvb2wgfSBmcm9tICcuLi9saWIvcGFyc2VyJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvblN0cmVhbUV2ZW50cyBleHRlbmRzIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJFdmVudHMge1xuICBjb250ZW50OiAoY29udGVudERlbHRhOiBzdHJpbmcsIGNvbnRlbnRTbmFwc2hvdDogc3RyaW5nKSA9PiB2b2lkO1xuICBjaHVuazogKGNodW5rOiBDaGF0Q29tcGxldGlvbkNodW5rLCBzbmFwc2hvdDogQ2hhdENvbXBsZXRpb25TbmFwc2hvdCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdGdW5jdGlvblJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzIGV4dGVuZHMgQmFzZUZ1bmN0aW9uc0FyZ3M+ID0gT21pdDxcbiAgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gICdmdW5jdGlvbnMnXG4+ICYge1xuICBmdW5jdGlvbnM6IFJ1bm5hYmxlRnVuY3Rpb25zPEZ1bmN0aW9uc0FyZ3M+O1xufTtcblxuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdUb29sUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3MgZXh0ZW5kcyBCYXNlRnVuY3Rpb25zQXJncz4gPSBPbWl0PFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgJ3Rvb2xzJ1xuPiAmIHtcbiAgdG9vbHM6IFJ1bm5hYmxlVG9vbHM8RnVuY3Rpb25zQXJncz4gfCBBdXRvUGFyc2VhYmxlVG9vbDxhbnksIHRydWU+W107XG59O1xuXG5leHBvcnQgY2xhc3MgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXI8UGFyc2VkVCA9IG51bGw+XG4gIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25TdHJlYW08UGFyc2VkVD5cbiAgaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPENoYXRDb21wbGV0aW9uQ2h1bms+XG57XG4gIHN0YXRpYyBvdmVycmlkZSBmcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSk6IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyPG51bGw+IHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIobnVsbCk7XG4gICAgcnVubmVyLl9ydW4oKCkgPT4gcnVubmVyLl9mcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCAtIHBsZWFzZSB1c2UgYHJ1blRvb2xzYCBpbnN0ZWFkLiAqL1xuICBzdGF0aWMgcnVuRnVuY3Rpb25zPFQgZXh0ZW5kcyAoc3RyaW5nIHwgb2JqZWN0KVtdPihcbiAgICBjbGllbnQ6IE9wZW5BSSxcbiAgICBwYXJhbXM6IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nRnVuY3Rpb25SdW5uZXJQYXJhbXM8VD4sXG4gICAgb3B0aW9ucz86IFJ1bm5lck9wdGlvbnMsXG4gICk6IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyPG51bGw+IHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIobnVsbCk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3J1bkZ1bmN0aW9ucycgfSxcbiAgICB9O1xuICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fcnVuRnVuY3Rpb25zKGNsaWVudCwgcGFyYW1zLCBvcHRzKSk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxuXG4gIHN0YXRpYyBydW5Ub29sczxUIGV4dGVuZHMgKHN0cmluZyB8IG9iamVjdClbXSwgUGFyc2VkVCA9IG51bGw+KFxuICAgIGNsaWVudDogT3BlbkFJLFxuICAgIHBhcmFtczogQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdUb29sUnVubmVyUGFyYW1zPFQ+LFxuICAgIG9wdGlvbnM/OiBSdW5uZXJPcHRpb25zLFxuICApOiBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcjxQYXJzZWRUPiB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyPFBhcnNlZFQ+KFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIHRoZXNlIHR5cGVzIGFyZSBpbmNvbXBhdGlibGVcbiAgICAgIHBhcmFtcyxcbiAgICApO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtSGVscGVyLU1ldGhvZCc6ICdydW5Ub29scycgfSxcbiAgICB9O1xuICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fcnVuVG9vbHMoY2xpZW50LCBwYXJhbXMsIG9wdHMpKTtcbiAgICByZXR1cm4gcnVubmVyO1xuICB9XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgQ2hhdENvbXBsZXRpb25SdW5uZXIsIENoYXRDb21wbGV0aW9uRnVuY3Rpb25SdW5uZXJQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25SdW5uZXInO1xuaW1wb3J0IHtcbiAgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIsXG4gIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nRnVuY3Rpb25SdW5uZXJQYXJhbXMsXG59IGZyb20gJy4uLy4uLy4uL2xpYi9DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcic7XG5pbXBvcnQgeyBCYXNlRnVuY3Rpb25zQXJncyB9IGZyb20gJy4uLy4uLy4uL2xpYi9SdW5uYWJsZUZ1bmN0aW9uJztcbmltcG9ydCB7IFJ1bm5lck9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9saWIvQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcic7XG5pbXBvcnQgeyBDaGF0Q29tcGxldGlvblRvb2xSdW5uZXJQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25SdW5uZXInO1xuaW1wb3J0IHsgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdUb29sUnVubmVyUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyJztcbmltcG9ydCB7IENoYXRDb21wbGV0aW9uU3RyZWFtLCB0eXBlIENoYXRDb21wbGV0aW9uU3RyZWFtUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtJztcbmltcG9ydCB7XG4gIENoYXRDb21wbGV0aW9uLFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgQ2hhdENvbXBsZXRpb25NZXNzYWdlLFxuICBDaGF0Q29tcGxldGlvbk1lc3NhZ2VUb29sQ2FsbCxcbn0gZnJvbSAnLi4vLi4vY2hhdC9jb21wbGV0aW9ucyc7XG5pbXBvcnQgeyBFeHRyYWN0UGFyc2VkQ29udGVudEZyb21QYXJhbXMsIHBhcnNlQ2hhdENvbXBsZXRpb24sIHZhbGlkYXRlSW5wdXRUb29scyB9IGZyb20gJy4uLy4uLy4uL2xpYi9wYXJzZXInO1xuXG5leHBvcnQge1xuICBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcixcbiAgdHlwZSBDaGF0Q29tcGxldGlvblN0cmVhbWluZ0Z1bmN0aW9uUnVubmVyUGFyYW1zLFxufSBmcm9tICcuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXInO1xuZXhwb3J0IHtcbiAgdHlwZSBSdW5uYWJsZUZ1bmN0aW9uLFxuICB0eXBlIFJ1bm5hYmxlRnVuY3Rpb25zLFxuICB0eXBlIFJ1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2UsXG4gIHR5cGUgUnVubmFibGVGdW5jdGlvbldpdGhvdXRQYXJzZSxcbiAgUGFyc2luZ0Z1bmN0aW9uLFxuICBQYXJzaW5nVG9vbEZ1bmN0aW9uLFxufSBmcm9tICcuLi8uLi8uLi9saWIvUnVubmFibGVGdW5jdGlvbic7XG5leHBvcnQgeyB0eXBlIENoYXRDb21wbGV0aW9uVG9vbFJ1bm5lclBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL2xpYi9DaGF0Q29tcGxldGlvblJ1bm5lcic7XG5leHBvcnQgeyB0eXBlIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nVG9vbFJ1bm5lclBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL2xpYi9DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcic7XG5leHBvcnQgeyBDaGF0Q29tcGxldGlvblN0cmVhbSwgdHlwZSBDaGF0Q29tcGxldGlvblN0cmVhbVBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL2xpYi9DaGF0Q29tcGxldGlvblN0cmVhbSc7XG5leHBvcnQge1xuICBDaGF0Q29tcGxldGlvblJ1bm5lcixcbiAgdHlwZSBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uUnVubmVyUGFyYW1zLFxufSBmcm9tICcuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25SdW5uZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnNlZEZ1bmN0aW9uIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwuRnVuY3Rpb24ge1xuICBwYXJzZWRfYXJndW1lbnRzPzogdW5rbm93bjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRGdW5jdGlvblRvb2xDYWxsIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwge1xuICBmdW5jdGlvbjogUGFyc2VkRnVuY3Rpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkQ2hhdENvbXBsZXRpb25NZXNzYWdlPFBhcnNlZFQ+IGV4dGVuZHMgQ2hhdENvbXBsZXRpb25NZXNzYWdlIHtcbiAgcGFyc2VkOiBQYXJzZWRUIHwgbnVsbDtcbiAgdG9vbF9jYWxsczogQXJyYXk8UGFyc2VkRnVuY3Rpb25Ub29sQ2FsbD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkQ2hvaWNlPFBhcnNlZFQ+IGV4dGVuZHMgQ2hhdENvbXBsZXRpb24uQ2hvaWNlIHtcbiAgbWVzc2FnZTogUGFyc2VkQ2hhdENvbXBsZXRpb25NZXNzYWdlPFBhcnNlZFQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnNlZENoYXRDb21wbGV0aW9uPFBhcnNlZFQ+IGV4dGVuZHMgQ2hhdENvbXBsZXRpb24ge1xuICBjaG9pY2VzOiBBcnJheTxQYXJzZWRDaG9pY2U8UGFyc2VkVD4+O1xufVxuXG5leHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvblBhcnNlUGFyYW1zID0gQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmc7XG5cbmV4cG9ydCBjbGFzcyBDb21wbGV0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgcGFyc2U8UGFyYW1zIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25QYXJzZVBhcmFtcywgUGFyc2VkVCA9IEV4dHJhY3RQYXJzZWRDb250ZW50RnJvbVBhcmFtczxQYXJhbXM+PihcbiAgICBib2R5OiBQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxQYXJzZWRDaGF0Q29tcGxldGlvbjxQYXJzZWRUPj4ge1xuICAgIHZhbGlkYXRlSW5wdXRUb29scyhib2R5LnRvb2xzKTtcblxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuY2hhdC5jb21wbGV0aW9uc1xuICAgICAgLmNyZWF0ZShib2R5LCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ2JldGEuY2hhdC5jb21wbGV0aW9ucy5wYXJzZScsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgICAgLl90aGVuVW53cmFwKChjb21wbGV0aW9uKSA9PiBwYXJzZUNoYXRDb21wbGV0aW9uKGNvbXBsZXRpb24sIGJvZHkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCAtIHVzZSBgcnVuVG9vbHNgIGluc3RlYWQuXG4gICAqL1xuICBydW5GdW5jdGlvbnM8RnVuY3Rpb25zQXJncyBleHRlbmRzIEJhc2VGdW5jdGlvbnNBcmdzPihcbiAgICBib2R5OiBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uUnVubmVyUGFyYW1zPEZ1bmN0aW9uc0FyZ3M+LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDaGF0Q29tcGxldGlvblJ1bm5lcjxudWxsPjtcbiAgcnVuRnVuY3Rpb25zPEZ1bmN0aW9uc0FyZ3MgZXh0ZW5kcyBCYXNlRnVuY3Rpb25zQXJncz4oXG4gICAgYm9keTogQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdGdW5jdGlvblJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzPixcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXI8bnVsbD47XG4gIHJ1bkZ1bmN0aW9uczxGdW5jdGlvbnNBcmdzIGV4dGVuZHMgQmFzZUZ1bmN0aW9uc0FyZ3M+KFxuICAgIGJvZHk6XG4gICAgICB8IENoYXRDb21wbGV0aW9uRnVuY3Rpb25SdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncz5cbiAgICAgIHwgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdGdW5jdGlvblJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzPixcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ2hhdENvbXBsZXRpb25SdW5uZXI8bnVsbD4gfCBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcjxudWxsPiB7XG4gICAgaWYgKGJvZHkuc3RyZWFtKSB7XG4gICAgICByZXR1cm4gQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIucnVuRnVuY3Rpb25zKFxuICAgICAgICB0aGlzLl9jbGllbnQsXG4gICAgICAgIGJvZHkgYXMgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdGdW5jdGlvblJ1bm5lclBhcmFtczxGdW5jdGlvbnNBcmdzPixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBDaGF0Q29tcGxldGlvblJ1bm5lci5ydW5GdW5jdGlvbnMoXG4gICAgICB0aGlzLl9jbGllbnQsXG4gICAgICBib2R5IGFzIENoYXRDb21wbGV0aW9uRnVuY3Rpb25SdW5uZXJQYXJhbXM8RnVuY3Rpb25zQXJncz4sXG4gICAgICBvcHRpb25zLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQSBjb252ZW5pZW5jZSBoZWxwZXIgZm9yIHVzaW5nIHRvb2wgY2FsbHMgd2l0aCB0aGUgL2NoYXQvY29tcGxldGlvbnMgZW5kcG9pbnRcbiAgICogd2hpY2ggYXV0b21hdGljYWxseSBjYWxscyB0aGUgSmF2YVNjcmlwdCBmdW5jdGlvbnMgeW91IHByb3ZpZGUgYW5kIHNlbmRzIHRoZWlyXG4gICAqIHJlc3VsdHMgYmFjayB0byB0aGUgL2NoYXQvY29tcGxldGlvbnMgZW5kcG9pbnQsIGxvb3BpbmcgYXMgbG9uZyBhcyB0aGUgbW9kZWxcbiAgICogcmVxdWVzdHMgZnVuY3Rpb24gY2FsbHMuXG4gICAqXG4gICAqIEZvciBtb3JlIGRldGFpbHMgYW5kIGV4YW1wbGVzLCBzZWVcbiAgICogW3RoZSBkb2NzXShodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlI2F1dG9tYXRlZC1mdW5jdGlvbi1jYWxscylcbiAgICovXG4gIHJ1blRvb2xzPFxuICAgIFBhcmFtcyBleHRlbmRzIENoYXRDb21wbGV0aW9uVG9vbFJ1bm5lclBhcmFtczxhbnk+LFxuICAgIFBhcnNlZFQgPSBFeHRyYWN0UGFyc2VkQ29udGVudEZyb21QYXJhbXM8UGFyYW1zPixcbiAgPihib2R5OiBQYXJhbXMsIG9wdGlvbnM/OiBSdW5uZXJPcHRpb25zKTogQ2hhdENvbXBsZXRpb25SdW5uZXI8UGFyc2VkVD47XG5cbiAgcnVuVG9vbHM8XG4gICAgUGFyYW1zIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdUb29sUnVubmVyUGFyYW1zPGFueT4sXG4gICAgUGFyc2VkVCA9IEV4dHJhY3RQYXJzZWRDb250ZW50RnJvbVBhcmFtczxQYXJhbXM+LFxuICA+KGJvZHk6IFBhcmFtcywgb3B0aW9ucz86IFJ1bm5lck9wdGlvbnMpOiBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcjxQYXJzZWRUPjtcblxuICBydW5Ub29sczxcbiAgICBQYXJhbXMgZXh0ZW5kcyBDaGF0Q29tcGxldGlvblRvb2xSdW5uZXJQYXJhbXM8YW55PiB8IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nVG9vbFJ1bm5lclBhcmFtczxhbnk+LFxuICAgIFBhcnNlZFQgPSBFeHRyYWN0UGFyc2VkQ29udGVudEZyb21QYXJhbXM8UGFyYW1zPixcbiAgPihcbiAgICBib2R5OiBQYXJhbXMsXG4gICAgb3B0aW9ucz86IFJ1bm5lck9wdGlvbnMsXG4gICk6IENoYXRDb21wbGV0aW9uUnVubmVyPFBhcnNlZFQ+IHwgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXI8UGFyc2VkVD4ge1xuICAgIGlmIChib2R5LnN0cmVhbSkge1xuICAgICAgcmV0dXJuIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyLnJ1blRvb2xzKFxuICAgICAgICB0aGlzLl9jbGllbnQsXG4gICAgICAgIGJvZHkgYXMgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdUb29sUnVubmVyUGFyYW1zPGFueT4sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBDaGF0Q29tcGxldGlvblJ1bm5lci5ydW5Ub29scyh0aGlzLl9jbGllbnQsIGJvZHkgYXMgQ2hhdENvbXBsZXRpb25Ub29sUnVubmVyUGFyYW1zPGFueT4sIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjaGF0IGNvbXBsZXRpb24gc3RyZWFtXG4gICAqL1xuICBzdHJlYW08UGFyYW1zIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25TdHJlYW1QYXJhbXMsIFBhcnNlZFQgPSBFeHRyYWN0UGFyc2VkQ29udGVudEZyb21QYXJhbXM8UGFyYW1zPj4oXG4gICAgYm9keTogUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDaGF0Q29tcGxldGlvblN0cmVhbTxQYXJzZWRUPiB7XG4gICAgcmV0dXJuIENoYXRDb21wbGV0aW9uU3RyZWFtLmNyZWF0ZUNoYXRDb21wbGV0aW9uKHRoaXMuX2NsaWVudCwgYm9keSwgb3B0aW9ucyk7XG4gIH1cbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvbXBsZXRpb25zQVBJIGZyb20gJy4vY29tcGxldGlvbnMnO1xuXG5leHBvcnQgY2xhc3MgQ2hhdCBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgY29tcGxldGlvbnM6IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zID0gbmV3IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zKHRoaXMuX2NsaWVudCk7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdCB7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbnMgPSBDb21wbGV0aW9uc0FQSS5Db21wbGV0aW9ucztcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5cbmV4cG9ydCBjbGFzcyBTZXNzaW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlcGhlbWVyYWwgQVBJIHRva2VuIGZvciB1c2UgaW4gY2xpZW50LXNpZGUgYXBwbGljYXRpb25zIHdpdGggdGhlXG4gICAqIFJlYWx0aW1lIEFQSS4gQ2FuIGJlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgc2FtZSBzZXNzaW9uIHBhcmFtZXRlcnMgYXMgdGhlXG4gICAqIGBzZXNzaW9uLnVwZGF0ZWAgY2xpZW50IGV2ZW50LlxuICAgKlxuICAgKiBJdCByZXNwb25kcyB3aXRoIGEgc2Vzc2lvbiBvYmplY3QsIHBsdXMgYSBgY2xpZW50X3NlY3JldGAga2V5IHdoaWNoIGNvbnRhaW5zIGFcbiAgICogdXNhYmxlIGVwaGVtZXJhbCBBUEkgdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB0byBhdXRoZW50aWNhdGUgYnJvd3NlciBjbGllbnRzIGZvclxuICAgKiB0aGUgUmVhbHRpbWUgQVBJLlxuICAgKi9cbiAgY3JlYXRlKGJvZHk6IFNlc3Npb25DcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFNlc3Npb25DcmVhdGVSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL3JlYWx0aW1lL3Nlc3Npb25zJywge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUmVhbHRpbWUgc2Vzc2lvbiBvYmplY3QgY29uZmlndXJhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uIHtcbiAgLyoqXG4gICAqIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgc2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBpZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCBvZiBpbnB1dCBhdWRpby4gT3B0aW9ucyBhcmUgYHBjbTE2YCwgYGc3MTFfdWxhd2AsIG9yIGBnNzExX2FsYXdgLlxuICAgKi9cbiAgaW5wdXRfYXVkaW9fZm9ybWF0PzogJ3BjbTE2JyB8ICdnNzExX3VsYXcnIHwgJ2c3MTFfYWxhdyc7XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gZm9yIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24sIGRlZmF1bHRzIHRvIG9mZiBhbmQgY2FuIGJlIHNldCB0b1xuICAgKiBgbnVsbGAgdG8gdHVybiBvZmYgb25jZSBvbi4gSW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiBpcyBub3QgbmF0aXZlIHRvIHRoZVxuICAgKiBtb2RlbCwgc2luY2UgdGhlIG1vZGVsIGNvbnN1bWVzIGF1ZGlvIGRpcmVjdGx5LiBUcmFuc2NyaXB0aW9uIHJ1bnNcbiAgICogYXN5bmNocm9ub3VzbHkgdGhyb3VnaCBXaGlzcGVyIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyByb3VnaCBndWlkYW5jZSByYXRoZXJcbiAgICogdGhhbiB0aGUgcmVwcmVzZW50YXRpb24gdW5kZXJzdG9vZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICBpbnB1dF9hdWRpb190cmFuc2NyaXB0aW9uPzogU2Vzc2lvbi5JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgc3lzdGVtIGluc3RydWN0aW9ucyAoaS5lLiBzeXN0ZW0gbWVzc2FnZSkgcHJlcGVuZGVkIHRvIG1vZGVsIGNhbGxzLlxuICAgKiBUaGlzIGZpZWxkIGFsbG93cyB0aGUgY2xpZW50IHRvIGd1aWRlIHRoZSBtb2RlbCBvbiBkZXNpcmVkIHJlc3BvbnNlcy4gVGhlIG1vZGVsXG4gICAqIGNhbiBiZSBpbnN0cnVjdGVkIG9uIHJlc3BvbnNlIGNvbnRlbnQgYW5kIGZvcm1hdCwgKGUuZy4gXCJiZSBleHRyZW1lbHkgc3VjY2luY3RcIixcbiAgICogXCJhY3QgZnJpZW5kbHlcIiwgXCJoZXJlIGFyZSBleGFtcGxlcyBvZiBnb29kIHJlc3BvbnNlc1wiKSBhbmQgb24gYXVkaW8gYmVoYXZpb3JcbiAgICogKGUuZy4gXCJ0YWxrIHF1aWNrbHlcIiwgXCJpbmplY3QgZW1vdGlvbiBpbnRvIHlvdXIgdm9pY2VcIiwgXCJsYXVnaCBmcmVxdWVudGx5XCIpLiBUaGVcbiAgICogaW5zdHJ1Y3Rpb25zIGFyZSBub3QgZ3VhcmFudGVlZCB0byBiZSBmb2xsb3dlZCBieSB0aGUgbW9kZWwsIGJ1dCB0aGV5IHByb3ZpZGVcbiAgICogZ3VpZGFuY2UgdG8gdGhlIG1vZGVsIG9uIHRoZSBkZXNpcmVkIGJlaGF2aW9yLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIHNlcnZlciBzZXRzIGRlZmF1bHQgaW5zdHJ1Y3Rpb25zIHdoaWNoIHdpbGwgYmUgdXNlZCBpZiB0aGlzIGZpZWxkXG4gICAqIGlzIG5vdCBzZXQgYW5kIGFyZSB2aXNpYmxlIGluIHRoZSBgc2Vzc2lvbi5jcmVhdGVkYCBldmVudCBhdCB0aGUgc3RhcnQgb2YgdGhlXG4gICAqIHNlc3Npb24uXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIG91dHB1dCB0b2tlbnMgZm9yIGEgc2luZ2xlIGFzc2lzdGFudCByZXNwb25zZSwgaW5jbHVzaXZlIG9mXG4gICAqIHRvb2wgY2FsbHMuIFByb3ZpZGUgYW4gaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDQwOTYgdG8gbGltaXQgb3V0cHV0IHRva2Vucywgb3JcbiAgICogYGluZmAgZm9yIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSB0b2tlbnMgZm9yIGEgZ2l2ZW4gbW9kZWwuIERlZmF1bHRzIHRvIGBpbmZgLlxuICAgKi9cbiAgbWF4X3Jlc3BvbnNlX291dHB1dF90b2tlbnM/OiBudW1iZXIgfCAnaW5mJztcblxuICAvKipcbiAgICogVGhlIHNldCBvZiBtb2RhbGl0aWVzIHRoZSBtb2RlbCBjYW4gcmVzcG9uZCB3aXRoLiBUbyBkaXNhYmxlIGF1ZGlvLCBzZXQgdGhpcyB0b1xuICAgKiBbXCJ0ZXh0XCJdLlxuICAgKi9cbiAgbW9kYWxpdGllcz86IEFycmF5PCd0ZXh0JyB8ICdhdWRpbyc+O1xuXG4gIC8qKlxuICAgKiBUaGUgUmVhbHRpbWUgbW9kZWwgdXNlZCBmb3IgdGhpcyBzZXNzaW9uLlxuICAgKi9cbiAgbW9kZWw/OlxuICAgIHwgKHN0cmluZyAmIHt9KVxuICAgIHwgJ2dwdC00by1yZWFsdGltZS1wcmV2aWV3J1xuICAgIHwgJ2dwdC00by1yZWFsdGltZS1wcmV2aWV3LTIwMjQtMTAtMDEnXG4gICAgfCAnZ3B0LTRvLXJlYWx0aW1lLXByZXZpZXctMjAyNC0xMi0xNydcbiAgICB8ICdncHQtNG8tbWluaS1yZWFsdGltZS1wcmV2aWV3J1xuICAgIHwgJ2dwdC00by1taW5pLXJlYWx0aW1lLXByZXZpZXctMjAyNC0xMi0xNyc7XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgb2Ygb3V0cHV0IGF1ZGlvLiBPcHRpb25zIGFyZSBgcGNtMTZgLCBgZzcxMV91bGF3YCwgb3IgYGc3MTFfYWxhd2AuXG4gICAqL1xuICBvdXRwdXRfYXVkaW9fZm9ybWF0PzogJ3BjbTE2JyB8ICdnNzExX3VsYXcnIHwgJ2c3MTFfYWxhdyc7XG5cbiAgLyoqXG4gICAqIFNhbXBsaW5nIHRlbXBlcmF0dXJlIGZvciB0aGUgbW9kZWwsIGxpbWl0ZWQgdG8gWzAuNiwgMS4yXS4gRGVmYXVsdHMgdG8gMC44LlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEhvdyB0aGUgbW9kZWwgY2hvb3NlcyB0b29scy4gT3B0aW9ucyBhcmUgYGF1dG9gLCBgbm9uZWAsIGByZXF1aXJlZGAsIG9yIHNwZWNpZnlcbiAgICogYSBmdW5jdGlvbi5cbiAgICovXG4gIHRvb2xfY2hvaWNlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUb29scyAoZnVuY3Rpb25zKSBhdmFpbGFibGUgdG8gdGhlIG1vZGVsLlxuICAgKi9cbiAgdG9vbHM/OiBBcnJheTxTZXNzaW9uLlRvb2w+O1xuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciB0dXJuIGRldGVjdGlvbi4gQ2FuIGJlIHNldCB0byBgbnVsbGAgdG8gdHVybiBvZmYuIFNlcnZlciBWQURcbiAgICogbWVhbnMgdGhhdCB0aGUgbW9kZWwgd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IGFuZCBlbmQgb2Ygc3BlZWNoIGJhc2VkIG9uIGF1ZGlvXG4gICAqIHZvbHVtZSBhbmQgcmVzcG9uZCBhdCB0aGUgZW5kIG9mIHVzZXIgc3BlZWNoLlxuICAgKi9cbiAgdHVybl9kZXRlY3Rpb24/OiBTZXNzaW9uLlR1cm5EZXRlY3Rpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgdm9pY2UgdGhlIG1vZGVsIHVzZXMgdG8gcmVzcG9uZC4gVm9pY2UgY2Fubm90IGJlIGNoYW5nZWQgZHVyaW5nIHRoZSBzZXNzaW9uXG4gICAqIG9uY2UgdGhlIG1vZGVsIGhhcyByZXNwb25kZWQgd2l0aCBhdWRpbyBhdCBsZWFzdCBvbmNlLiBDdXJyZW50IHZvaWNlIG9wdGlvbnMgYXJlXG4gICAqIGBhbGxveWAsIGBhc2hgLCBgYmFsbGFkYCwgYGNvcmFsYCwgYGVjaG9gIGBzYWdlYCwgYHNoaW1tZXJgIGFuZCBgdmVyc2VgLlxuICAgKi9cbiAgdm9pY2U/OiAnYWxsb3knIHwgJ2FzaCcgfCAnYmFsbGFkJyB8ICdjb3JhbCcgfCAnZWNobycgfCAnc2FnZScgfCAnc2hpbW1lcicgfCAndmVyc2UnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFNlc3Npb24ge1xuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiwgZGVmYXVsdHMgdG8gb2ZmIGFuZCBjYW4gYmUgc2V0IHRvXG4gICAqIGBudWxsYCB0byB0dXJuIG9mZiBvbmNlIG9uLiBJbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uIGlzIG5vdCBuYXRpdmUgdG8gdGhlXG4gICAqIG1vZGVsLCBzaW5jZSB0aGUgbW9kZWwgY29uc3VtZXMgYXVkaW8gZGlyZWN0bHkuIFRyYW5zY3JpcHRpb24gcnVuc1xuICAgKiBhc3luY2hyb25vdXNseSB0aHJvdWdoIFdoaXNwZXIgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIHJvdWdoIGd1aWRhbmNlIHJhdGhlclxuICAgKiB0aGFuIHRoZSByZXByZXNlbnRhdGlvbiB1bmRlcnN0b29kIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlbCB0byB1c2UgZm9yIHRyYW5zY3JpcHRpb24sIGB3aGlzcGVyLTFgIGlzIHRoZSBvbmx5IGN1cnJlbnRseSBzdXBwb3J0ZWRcbiAgICAgKiBtb2RlbC5cbiAgICAgKi9cbiAgICBtb2RlbD86IHN0cmluZztcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbCB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBmdW5jdGlvbiwgaW5jbHVkaW5nIGd1aWRhbmNlIG9uIHdoZW4gYW5kIGhvdyB0byBjYWxsIGl0LFxuICAgICAqIGFuZCBndWlkYW5jZSBhYm91dCB3aGF0IHRvIHRlbGwgdGhlIHVzZXIgd2hlbiBjYWxsaW5nIChpZiBhbnl0aGluZykuXG4gICAgICovXG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbmFtZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFBhcmFtZXRlcnMgb2YgdGhlIGZ1bmN0aW9uIGluIEpTT04gU2NoZW1hLlxuICAgICAqL1xuICAgIHBhcmFtZXRlcnM/OiB1bmtub3duO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wsIGkuZS4gYGZ1bmN0aW9uYC5cbiAgICAgKi9cbiAgICB0eXBlPzogJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciB0dXJuIGRldGVjdGlvbi4gQ2FuIGJlIHNldCB0byBgbnVsbGAgdG8gdHVybiBvZmYuIFNlcnZlciBWQURcbiAgICogbWVhbnMgdGhhdCB0aGUgbW9kZWwgd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IGFuZCBlbmQgb2Ygc3BlZWNoIGJhc2VkIG9uIGF1ZGlvXG4gICAqIHZvbHVtZSBhbmQgcmVzcG9uZCBhdCB0aGUgZW5kIG9mIHVzZXIgc3BlZWNoLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUdXJuRGV0ZWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgYXVkaW8gdG8gaW5jbHVkZSBiZWZvcmUgdGhlIFZBRCBkZXRlY3RlZCBzcGVlY2ggKGluIG1pbGxpc2Vjb25kcykuXG4gICAgICogRGVmYXVsdHMgdG8gMzAwbXMuXG4gICAgICovXG4gICAgcHJlZml4X3BhZGRpbmdfbXM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBEdXJhdGlvbiBvZiBzaWxlbmNlIHRvIGRldGVjdCBzcGVlY2ggc3RvcCAoaW4gbWlsbGlzZWNvbmRzKS4gRGVmYXVsdHMgdG8gNTAwbXMuXG4gICAgICogV2l0aCBzaG9ydGVyIHZhbHVlcyB0aGUgbW9kZWwgd2lsbCByZXNwb25kIG1vcmUgcXVpY2tseSwgYnV0IG1heSBqdW1wIGluIG9uXG4gICAgICogc2hvcnQgcGF1c2VzIGZyb20gdGhlIHVzZXIuXG4gICAgICovXG4gICAgc2lsZW5jZV9kdXJhdGlvbl9tcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRpb24gdGhyZXNob2xkIGZvciBWQUQgKDAuMCB0byAxLjApLCB0aGlzIGRlZmF1bHRzIHRvIDAuNS4gQSBoaWdoZXJcbiAgICAgKiB0aHJlc2hvbGQgd2lsbCByZXF1aXJlIGxvdWRlciBhdWRpbyB0byBhY3RpdmF0ZSB0aGUgbW9kZWwsIGFuZCB0aHVzIG1pZ2h0XG4gICAgICogcGVyZm9ybSBiZXR0ZXIgaW4gbm9pc3kgZW52aXJvbm1lbnRzLlxuICAgICAqL1xuICAgIHRocmVzaG9sZD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgdHVybiBkZXRlY3Rpb24sIG9ubHkgYHNlcnZlcl92YWRgIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgdHlwZT86ICdzZXJ2ZXJfdmFkJztcbiAgfVxufVxuXG4vKipcbiAqIEEgbmV3IFJlYWx0aW1lIHNlc3Npb24gY29uZmlndXJhdGlvbiwgd2l0aCBhbiBlcGhlcm1lcmFsIGtleS4gRGVmYXVsdCBUVEwgZm9yXG4gKiBrZXlzIGlzIG9uZSBtaW51dGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbkNyZWF0ZVJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIEVwaGVtZXJhbCBrZXkgcmV0dXJuZWQgYnkgdGhlIEFQSS5cbiAgICovXG4gIGNsaWVudF9zZWNyZXQ/OiBTZXNzaW9uQ3JlYXRlUmVzcG9uc2UuQ2xpZW50U2VjcmV0O1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IG9mIGlucHV0IGF1ZGlvLiBPcHRpb25zIGFyZSBgcGNtMTZgLCBgZzcxMV91bGF3YCwgb3IgYGc3MTFfYWxhd2AuXG4gICAqL1xuICBpbnB1dF9hdWRpb19mb3JtYXQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gZm9yIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24sIGRlZmF1bHRzIHRvIG9mZiBhbmQgY2FuIGJlIHNldCB0b1xuICAgKiBgbnVsbGAgdG8gdHVybiBvZmYgb25jZSBvbi4gSW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiBpcyBub3QgbmF0aXZlIHRvIHRoZVxuICAgKiBtb2RlbCwgc2luY2UgdGhlIG1vZGVsIGNvbnN1bWVzIGF1ZGlvIGRpcmVjdGx5LiBUcmFuc2NyaXB0aW9uIHJ1bnNcbiAgICogYXN5bmNocm9ub3VzbHkgdGhyb3VnaCBXaGlzcGVyIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyByb3VnaCBndWlkYW5jZSByYXRoZXJcbiAgICogdGhhbiB0aGUgcmVwcmVzZW50YXRpb24gdW5kZXJzdG9vZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICBpbnB1dF9hdWRpb190cmFuc2NyaXB0aW9uPzogU2Vzc2lvbkNyZWF0ZVJlc3BvbnNlLklucHV0QXVkaW9UcmFuc2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBzeXN0ZW0gaW5zdHJ1Y3Rpb25zIChpLmUuIHN5c3RlbSBtZXNzYWdlKSBwcmVwZW5kZWQgdG8gbW9kZWwgY2FsbHMuXG4gICAqIFRoaXMgZmllbGQgYWxsb3dzIHRoZSBjbGllbnQgdG8gZ3VpZGUgdGhlIG1vZGVsIG9uIGRlc2lyZWQgcmVzcG9uc2VzLiBUaGUgbW9kZWxcbiAgICogY2FuIGJlIGluc3RydWN0ZWQgb24gcmVzcG9uc2UgY29udGVudCBhbmQgZm9ybWF0LCAoZS5nLiBcImJlIGV4dHJlbWVseSBzdWNjaW5jdFwiLFxuICAgKiBcImFjdCBmcmllbmRseVwiLCBcImhlcmUgYXJlIGV4YW1wbGVzIG9mIGdvb2QgcmVzcG9uc2VzXCIpIGFuZCBvbiBhdWRpbyBiZWhhdmlvclxuICAgKiAoZS5nLiBcInRhbGsgcXVpY2tseVwiLCBcImluamVjdCBlbW90aW9uIGludG8geW91ciB2b2ljZVwiLCBcImxhdWdoIGZyZXF1ZW50bHlcIikuIFRoZVxuICAgKiBpbnN0cnVjdGlvbnMgYXJlIG5vdCBndWFyYW50ZWVkIHRvIGJlIGZvbGxvd2VkIGJ5IHRoZSBtb2RlbCwgYnV0IHRoZXkgcHJvdmlkZVxuICAgKiBndWlkYW5jZSB0byB0aGUgbW9kZWwgb24gdGhlIGRlc2lyZWQgYmVoYXZpb3IuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgc2VydmVyIHNldHMgZGVmYXVsdCBpbnN0cnVjdGlvbnMgd2hpY2ggd2lsbCBiZSB1c2VkIGlmIHRoaXMgZmllbGRcbiAgICogaXMgbm90IHNldCBhbmQgYXJlIHZpc2libGUgaW4gdGhlIGBzZXNzaW9uLmNyZWF0ZWRgIGV2ZW50IGF0IHRoZSBzdGFydCBvZiB0aGVcbiAgICogc2Vzc2lvbi5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZztcblxuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2Ygb3V0cHV0IHRva2VucyBmb3IgYSBzaW5nbGUgYXNzaXN0YW50IHJlc3BvbnNlLCBpbmNsdXNpdmUgb2ZcbiAgICogdG9vbCBjYWxscy4gUHJvdmlkZSBhbiBpbnRlZ2VyIGJldHdlZW4gMSBhbmQgNDA5NiB0byBsaW1pdCBvdXRwdXQgdG9rZW5zLCBvclxuICAgKiBgaW5mYCBmb3IgdGhlIG1heGltdW0gYXZhaWxhYmxlIHRva2VucyBmb3IgYSBnaXZlbiBtb2RlbC4gRGVmYXVsdHMgdG8gYGluZmAuXG4gICAqL1xuICBtYXhfcmVzcG9uc2Vfb3V0cHV0X3Rva2Vucz86IG51bWJlciB8ICdpbmYnO1xuXG4gIC8qKlxuICAgKiBUaGUgc2V0IG9mIG1vZGFsaXRpZXMgdGhlIG1vZGVsIGNhbiByZXNwb25kIHdpdGguIFRvIGRpc2FibGUgYXVkaW8sIHNldCB0aGlzIHRvXG4gICAqIFtcInRleHRcIl0uXG4gICAqL1xuICBtb2RhbGl0aWVzPzogQXJyYXk8J3RleHQnIHwgJ2F1ZGlvJz47XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgb2Ygb3V0cHV0IGF1ZGlvLiBPcHRpb25zIGFyZSBgcGNtMTZgLCBgZzcxMV91bGF3YCwgb3IgYGc3MTFfYWxhd2AuXG4gICAqL1xuICBvdXRwdXRfYXVkaW9fZm9ybWF0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTYW1wbGluZyB0ZW1wZXJhdHVyZSBmb3IgdGhlIG1vZGVsLCBsaW1pdGVkIHRvIFswLjYsIDEuMl0uIERlZmF1bHRzIHRvIDAuOC5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBIb3cgdGhlIG1vZGVsIGNob29zZXMgdG9vbHMuIE9wdGlvbnMgYXJlIGBhdXRvYCwgYG5vbmVgLCBgcmVxdWlyZWRgLCBvciBzcGVjaWZ5XG4gICAqIGEgZnVuY3Rpb24uXG4gICAqL1xuICB0b29sX2Nob2ljZT86IHN0cmluZztcblxuICAvKipcbiAgICogVG9vbHMgKGZ1bmN0aW9ucykgYXZhaWxhYmxlIHRvIHRoZSBtb2RlbC5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8U2Vzc2lvbkNyZWF0ZVJlc3BvbnNlLlRvb2w+O1xuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciB0dXJuIGRldGVjdGlvbi4gQ2FuIGJlIHNldCB0byBgbnVsbGAgdG8gdHVybiBvZmYuIFNlcnZlciBWQURcbiAgICogbWVhbnMgdGhhdCB0aGUgbW9kZWwgd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IGFuZCBlbmQgb2Ygc3BlZWNoIGJhc2VkIG9uIGF1ZGlvXG4gICAqIHZvbHVtZSBhbmQgcmVzcG9uZCBhdCB0aGUgZW5kIG9mIHVzZXIgc3BlZWNoLlxuICAgKi9cbiAgdHVybl9kZXRlY3Rpb24/OiBTZXNzaW9uQ3JlYXRlUmVzcG9uc2UuVHVybkRldGVjdGlvbjtcblxuICAvKipcbiAgICogVGhlIHZvaWNlIHRoZSBtb2RlbCB1c2VzIHRvIHJlc3BvbmQuIFZvaWNlIGNhbm5vdCBiZSBjaGFuZ2VkIGR1cmluZyB0aGUgc2Vzc2lvblxuICAgKiBvbmNlIHRoZSBtb2RlbCBoYXMgcmVzcG9uZGVkIHdpdGggYXVkaW8gYXQgbGVhc3Qgb25jZS4gQ3VycmVudCB2b2ljZSBvcHRpb25zIGFyZVxuICAgKiBgYWxsb3lgLCBgYXNoYCwgYGJhbGxhZGAsIGBjb3JhbGAsIGBlY2hvYCBgc2FnZWAsIGBzaGltbWVyYCBhbmQgYHZlcnNlYC5cbiAgICovXG4gIHZvaWNlPzogJ2FsbG95JyB8ICdhc2gnIHwgJ2JhbGxhZCcgfCAnY29yYWwnIHwgJ2VjaG8nIHwgJ3NhZ2UnIHwgJ3NoaW1tZXInIHwgJ3ZlcnNlJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBTZXNzaW9uQ3JlYXRlUmVzcG9uc2Uge1xuICAvKipcbiAgICogRXBoZW1lcmFsIGtleSByZXR1cm5lZCBieSB0aGUgQVBJLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDbGllbnRTZWNyZXQge1xuICAgIC8qKlxuICAgICAqIFRpbWVzdGFtcCBmb3Igd2hlbiB0aGUgdG9rZW4gZXhwaXJlcy4gQ3VycmVudGx5LCBhbGwgdG9rZW5zIGV4cGlyZSBhZnRlciBvbmVcbiAgICAgKiBtaW51dGUuXG4gICAgICovXG4gICAgZXhwaXJlc19hdD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEVwaGVtZXJhbCBrZXkgdXNhYmxlIGluIGNsaWVudCBlbnZpcm9ubWVudHMgdG8gYXV0aGVudGljYXRlIGNvbm5lY3Rpb25zIHRvIHRoZVxuICAgICAqIFJlYWx0aW1lIEFQSS4gVXNlIHRoaXMgaW4gY2xpZW50LXNpZGUgZW52aXJvbm1lbnRzIHJhdGhlciB0aGFuIGEgc3RhbmRhcmQgQVBJXG4gICAgICogdG9rZW4sIHdoaWNoIHNob3VsZCBvbmx5IGJlIHVzZWQgc2VydmVyLXNpZGUuXG4gICAgICovXG4gICAgdmFsdWU/OiBzdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiwgZGVmYXVsdHMgdG8gb2ZmIGFuZCBjYW4gYmUgc2V0IHRvXG4gICAqIGBudWxsYCB0byB0dXJuIG9mZiBvbmNlIG9uLiBJbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uIGlzIG5vdCBuYXRpdmUgdG8gdGhlXG4gICAqIG1vZGVsLCBzaW5jZSB0aGUgbW9kZWwgY29uc3VtZXMgYXVkaW8gZGlyZWN0bHkuIFRyYW5zY3JpcHRpb24gcnVuc1xuICAgKiBhc3luY2hyb25vdXNseSB0aHJvdWdoIFdoaXNwZXIgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIHJvdWdoIGd1aWRhbmNlIHJhdGhlclxuICAgKiB0aGFuIHRoZSByZXByZXNlbnRhdGlvbiB1bmRlcnN0b29kIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlbCB0byB1c2UgZm9yIHRyYW5zY3JpcHRpb24sIGB3aGlzcGVyLTFgIGlzIHRoZSBvbmx5IGN1cnJlbnRseSBzdXBwb3J0ZWRcbiAgICAgKiBtb2RlbC5cbiAgICAgKi9cbiAgICBtb2RlbD86IHN0cmluZztcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbCB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBmdW5jdGlvbiwgaW5jbHVkaW5nIGd1aWRhbmNlIG9uIHdoZW4gYW5kIGhvdyB0byBjYWxsIGl0LFxuICAgICAqIGFuZCBndWlkYW5jZSBhYm91dCB3aGF0IHRvIHRlbGwgdGhlIHVzZXIgd2hlbiBjYWxsaW5nIChpZiBhbnl0aGluZykuXG4gICAgICovXG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbmFtZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFBhcmFtZXRlcnMgb2YgdGhlIGZ1bmN0aW9uIGluIEpTT04gU2NoZW1hLlxuICAgICAqL1xuICAgIHBhcmFtZXRlcnM/OiB1bmtub3duO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wsIGkuZS4gYGZ1bmN0aW9uYC5cbiAgICAgKi9cbiAgICB0eXBlPzogJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciB0dXJuIGRldGVjdGlvbi4gQ2FuIGJlIHNldCB0byBgbnVsbGAgdG8gdHVybiBvZmYuIFNlcnZlciBWQURcbiAgICogbWVhbnMgdGhhdCB0aGUgbW9kZWwgd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IGFuZCBlbmQgb2Ygc3BlZWNoIGJhc2VkIG9uIGF1ZGlvXG4gICAqIHZvbHVtZSBhbmQgcmVzcG9uZCBhdCB0aGUgZW5kIG9mIHVzZXIgc3BlZWNoLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUdXJuRGV0ZWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgYXVkaW8gdG8gaW5jbHVkZSBiZWZvcmUgdGhlIFZBRCBkZXRlY3RlZCBzcGVlY2ggKGluIG1pbGxpc2Vjb25kcykuXG4gICAgICogRGVmYXVsdHMgdG8gMzAwbXMuXG4gICAgICovXG4gICAgcHJlZml4X3BhZGRpbmdfbXM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBEdXJhdGlvbiBvZiBzaWxlbmNlIHRvIGRldGVjdCBzcGVlY2ggc3RvcCAoaW4gbWlsbGlzZWNvbmRzKS4gRGVmYXVsdHMgdG8gNTAwbXMuXG4gICAgICogV2l0aCBzaG9ydGVyIHZhbHVlcyB0aGUgbW9kZWwgd2lsbCByZXNwb25kIG1vcmUgcXVpY2tseSwgYnV0IG1heSBqdW1wIGluIG9uXG4gICAgICogc2hvcnQgcGF1c2VzIGZyb20gdGhlIHVzZXIuXG4gICAgICovXG4gICAgc2lsZW5jZV9kdXJhdGlvbl9tcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRpb24gdGhyZXNob2xkIGZvciBWQUQgKDAuMCB0byAxLjApLCB0aGlzIGRlZmF1bHRzIHRvIDAuNS4gQSBoaWdoZXJcbiAgICAgKiB0aHJlc2hvbGQgd2lsbCByZXF1aXJlIGxvdWRlciBhdWRpbyB0byBhY3RpdmF0ZSB0aGUgbW9kZWwsIGFuZCB0aHVzIG1pZ2h0XG4gICAgICogcGVyZm9ybSBiZXR0ZXIgaW4gbm9pc3kgZW52aXJvbm1lbnRzLlxuICAgICAqL1xuICAgIHRocmVzaG9sZD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgdHVybiBkZXRlY3Rpb24sIG9ubHkgYHNlcnZlcl92YWRgIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgdHlwZT86IHN0cmluZztcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlc3Npb25DcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIFJlYWx0aW1lIG1vZGVsIHVzZWQgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICovXG4gIG1vZGVsOlxuICAgIHwgJ2dwdC00by1yZWFsdGltZS1wcmV2aWV3J1xuICAgIHwgJ2dwdC00by1yZWFsdGltZS1wcmV2aWV3LTIwMjQtMTAtMDEnXG4gICAgfCAnZ3B0LTRvLXJlYWx0aW1lLXByZXZpZXctMjAyNC0xMi0xNydcbiAgICB8ICdncHQtNG8tbWluaS1yZWFsdGltZS1wcmV2aWV3J1xuICAgIHwgJ2dwdC00by1taW5pLXJlYWx0aW1lLXByZXZpZXctMjAyNC0xMi0xNyc7XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgb2YgaW5wdXQgYXVkaW8uIE9wdGlvbnMgYXJlIGBwY20xNmAsIGBnNzExX3VsYXdgLCBvciBgZzcxMV9hbGF3YC5cbiAgICovXG4gIGlucHV0X2F1ZGlvX2Zvcm1hdD86ICdwY20xNicgfCAnZzcxMV91bGF3JyB8ICdnNzExX2FsYXcnO1xuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciBpbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uLCBkZWZhdWx0cyB0byBvZmYgYW5kIGNhbiBiZSBzZXQgdG9cbiAgICogYG51bGxgIHRvIHR1cm4gb2ZmIG9uY2Ugb24uIElucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24gaXMgbm90IG5hdGl2ZSB0byB0aGVcbiAgICogbW9kZWwsIHNpbmNlIHRoZSBtb2RlbCBjb25zdW1lcyBhdWRpbyBkaXJlY3RseS4gVHJhbnNjcmlwdGlvbiBydW5zXG4gICAqIGFzeW5jaHJvbm91c2x5IHRocm91Z2ggV2hpc3BlciBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgcm91Z2ggZ3VpZGFuY2UgcmF0aGVyXG4gICAqIHRoYW4gdGhlIHJlcHJlc2VudGF0aW9uIHVuZGVyc3Rvb2QgYnkgdGhlIG1vZGVsLlxuICAgKi9cbiAgaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbj86IFNlc3Npb25DcmVhdGVQYXJhbXMuSW5wdXRBdWRpb1RyYW5zY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHN5c3RlbSBpbnN0cnVjdGlvbnMgKGkuZS4gc3lzdGVtIG1lc3NhZ2UpIHByZXBlbmRlZCB0byBtb2RlbCBjYWxscy5cbiAgICogVGhpcyBmaWVsZCBhbGxvd3MgdGhlIGNsaWVudCB0byBndWlkZSB0aGUgbW9kZWwgb24gZGVzaXJlZCByZXNwb25zZXMuIFRoZSBtb2RlbFxuICAgKiBjYW4gYmUgaW5zdHJ1Y3RlZCBvbiByZXNwb25zZSBjb250ZW50IGFuZCBmb3JtYXQsIChlLmcuIFwiYmUgZXh0cmVtZWx5IHN1Y2NpbmN0XCIsXG4gICAqIFwiYWN0IGZyaWVuZGx5XCIsIFwiaGVyZSBhcmUgZXhhbXBsZXMgb2YgZ29vZCByZXNwb25zZXNcIikgYW5kIG9uIGF1ZGlvIGJlaGF2aW9yXG4gICAqIChlLmcuIFwidGFsayBxdWlja2x5XCIsIFwiaW5qZWN0IGVtb3Rpb24gaW50byB5b3VyIHZvaWNlXCIsIFwibGF1Z2ggZnJlcXVlbnRseVwiKS4gVGhlXG4gICAqIGluc3RydWN0aW9ucyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gYmUgZm9sbG93ZWQgYnkgdGhlIG1vZGVsLCBidXQgdGhleSBwcm92aWRlXG4gICAqIGd1aWRhbmNlIHRvIHRoZSBtb2RlbCBvbiB0aGUgZGVzaXJlZCBiZWhhdmlvci5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBzZXJ2ZXIgc2V0cyBkZWZhdWx0IGluc3RydWN0aW9ucyB3aGljaCB3aWxsIGJlIHVzZWQgaWYgdGhpcyBmaWVsZFxuICAgKiBpcyBub3Qgc2V0IGFuZCBhcmUgdmlzaWJsZSBpbiB0aGUgYHNlc3Npb24uY3JlYXRlZGAgZXZlbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZVxuICAgKiBzZXNzaW9uLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiBvdXRwdXQgdG9rZW5zIGZvciBhIHNpbmdsZSBhc3Npc3RhbnQgcmVzcG9uc2UsIGluY2x1c2l2ZSBvZlxuICAgKiB0b29sIGNhbGxzLiBQcm92aWRlIGFuIGludGVnZXIgYmV0d2VlbiAxIGFuZCA0MDk2IHRvIGxpbWl0IG91dHB1dCB0b2tlbnMsIG9yXG4gICAqIGBpbmZgIGZvciB0aGUgbWF4aW11bSBhdmFpbGFibGUgdG9rZW5zIGZvciBhIGdpdmVuIG1vZGVsLiBEZWZhdWx0cyB0byBgaW5mYC5cbiAgICovXG4gIG1heF9yZXNwb25zZV9vdXRwdXRfdG9rZW5zPzogbnVtYmVyIHwgJ2luZic7XG5cbiAgLyoqXG4gICAqIFRoZSBzZXQgb2YgbW9kYWxpdGllcyB0aGUgbW9kZWwgY2FuIHJlc3BvbmQgd2l0aC4gVG8gZGlzYWJsZSBhdWRpbywgc2V0IHRoaXMgdG9cbiAgICogW1widGV4dFwiXS5cbiAgICovXG4gIG1vZGFsaXRpZXM/OiBBcnJheTwndGV4dCcgfCAnYXVkaW8nPjtcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCBvZiBvdXRwdXQgYXVkaW8uIE9wdGlvbnMgYXJlIGBwY20xNmAsIGBnNzExX3VsYXdgLCBvciBgZzcxMV9hbGF3YC5cbiAgICovXG4gIG91dHB1dF9hdWRpb19mb3JtYXQ/OiAncGNtMTYnIHwgJ2c3MTFfdWxhdycgfCAnZzcxMV9hbGF3JztcblxuICAvKipcbiAgICogU2FtcGxpbmcgdGVtcGVyYXR1cmUgZm9yIHRoZSBtb2RlbCwgbGltaXRlZCB0byBbMC42LCAxLjJdLiBEZWZhdWx0cyB0byAwLjguXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcblxuICAvKipcbiAgICogSG93IHRoZSBtb2RlbCBjaG9vc2VzIHRvb2xzLiBPcHRpb25zIGFyZSBgYXV0b2AsIGBub25lYCwgYHJlcXVpcmVkYCwgb3Igc3BlY2lmeVxuICAgKiBhIGZ1bmN0aW9uLlxuICAgKi9cbiAgdG9vbF9jaG9pY2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRvb2xzIChmdW5jdGlvbnMpIGF2YWlsYWJsZSB0byB0aGUgbW9kZWwuXG4gICAqL1xuICB0b29scz86IEFycmF5PFNlc3Npb25DcmVhdGVQYXJhbXMuVG9vbD47XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gZm9yIHR1cm4gZGV0ZWN0aW9uLiBDYW4gYmUgc2V0IHRvIGBudWxsYCB0byB0dXJuIG9mZi4gU2VydmVyIFZBRFxuICAgKiBtZWFucyB0aGF0IHRoZSBtb2RlbCB3aWxsIGRldGVjdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiBzcGVlY2ggYmFzZWQgb24gYXVkaW9cbiAgICogdm9sdW1lIGFuZCByZXNwb25kIGF0IHRoZSBlbmQgb2YgdXNlciBzcGVlY2guXG4gICAqL1xuICB0dXJuX2RldGVjdGlvbj86IFNlc3Npb25DcmVhdGVQYXJhbXMuVHVybkRldGVjdGlvbjtcblxuICAvKipcbiAgICogVGhlIHZvaWNlIHRoZSBtb2RlbCB1c2VzIHRvIHJlc3BvbmQuIFZvaWNlIGNhbm5vdCBiZSBjaGFuZ2VkIGR1cmluZyB0aGUgc2Vzc2lvblxuICAgKiBvbmNlIHRoZSBtb2RlbCBoYXMgcmVzcG9uZGVkIHdpdGggYXVkaW8gYXQgbGVhc3Qgb25jZS4gQ3VycmVudCB2b2ljZSBvcHRpb25zIGFyZVxuICAgKiBgYWxsb3lgLCBgYXNoYCwgYGJhbGxhZGAsIGBjb3JhbGAsIGBlY2hvYCBgc2FnZWAsIGBzaGltbWVyYCBhbmQgYHZlcnNlYC5cbiAgICovXG4gIHZvaWNlPzogJ2FsbG95JyB8ICdhc2gnIHwgJ2JhbGxhZCcgfCAnY29yYWwnIHwgJ2VjaG8nIHwgJ3NhZ2UnIHwgJ3NoaW1tZXInIHwgJ3ZlcnNlJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBTZXNzaW9uQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gZm9yIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24sIGRlZmF1bHRzIHRvIG9mZiBhbmQgY2FuIGJlIHNldCB0b1xuICAgKiBgbnVsbGAgdG8gdHVybiBvZmYgb25jZSBvbi4gSW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiBpcyBub3QgbmF0aXZlIHRvIHRoZVxuICAgKiBtb2RlbCwgc2luY2UgdGhlIG1vZGVsIGNvbnN1bWVzIGF1ZGlvIGRpcmVjdGx5LiBUcmFuc2NyaXB0aW9uIHJ1bnNcbiAgICogYXN5bmNocm9ub3VzbHkgdGhyb3VnaCBXaGlzcGVyIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyByb3VnaCBndWlkYW5jZSByYXRoZXJcbiAgICogdGhhbiB0aGUgcmVwcmVzZW50YXRpb24gdW5kZXJzdG9vZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9UcmFuc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwgdG8gdXNlIGZvciB0cmFuc2NyaXB0aW9uLCBgd2hpc3Blci0xYCBpcyB0aGUgb25seSBjdXJyZW50bHkgc3VwcG9ydGVkXG4gICAgICogbW9kZWwuXG4gICAgICovXG4gICAgbW9kZWw/OiBzdHJpbmc7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFRvb2wge1xuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgZnVuY3Rpb24sIGluY2x1ZGluZyBndWlkYW5jZSBvbiB3aGVuIGFuZCBob3cgdG8gY2FsbCBpdCxcbiAgICAgKiBhbmQgZ3VpZGFuY2UgYWJvdXQgd2hhdCB0byB0ZWxsIHRoZSB1c2VyIHdoZW4gY2FsbGluZyAoaWYgYW55dGhpbmcpLlxuICAgICAqL1xuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG5hbWU/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBQYXJhbWV0ZXJzIG9mIHRoZSBmdW5jdGlvbiBpbiBKU09OIFNjaGVtYS5cbiAgICAgKi9cbiAgICBwYXJhbWV0ZXJzPzogdW5rbm93bjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSB0b29sLCBpLmUuIGBmdW5jdGlvbmAuXG4gICAgICovXG4gICAgdHlwZT86ICdmdW5jdGlvbic7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgdHVybiBkZXRlY3Rpb24uIENhbiBiZSBzZXQgdG8gYG51bGxgIHRvIHR1cm4gb2ZmLiBTZXJ2ZXIgVkFEXG4gICAqIG1lYW5zIHRoYXQgdGhlIG1vZGVsIHdpbGwgZGV0ZWN0IHRoZSBzdGFydCBhbmQgZW5kIG9mIHNwZWVjaCBiYXNlZCBvbiBhdWRpb1xuICAgKiB2b2x1bWUgYW5kIHJlc3BvbmQgYXQgdGhlIGVuZCBvZiB1c2VyIHNwZWVjaC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVHVybkRldGVjdGlvbiB7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdG8gYXV0b21hdGljYWxseSBnZW5lcmF0ZSBhIHJlc3BvbnNlIHdoZW4gVkFEIGlzIGVuYWJsZWQuIGB0cnVlYFxuICAgICAqIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgY3JlYXRlX3Jlc3BvbnNlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEFtb3VudCBvZiBhdWRpbyB0byBpbmNsdWRlIGJlZm9yZSB0aGUgVkFEIGRldGVjdGVkIHNwZWVjaCAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICAgKiBEZWZhdWx0cyB0byAzMDBtcy5cbiAgICAgKi9cbiAgICBwcmVmaXhfcGFkZGluZ19tcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIER1cmF0aW9uIG9mIHNpbGVuY2UgdG8gZGV0ZWN0IHNwZWVjaCBzdG9wIChpbiBtaWxsaXNlY29uZHMpLiBEZWZhdWx0cyB0byA1MDBtcy5cbiAgICAgKiBXaXRoIHNob3J0ZXIgdmFsdWVzIHRoZSBtb2RlbCB3aWxsIHJlc3BvbmQgbW9yZSBxdWlja2x5LCBidXQgbWF5IGp1bXAgaW4gb25cbiAgICAgKiBzaG9ydCBwYXVzZXMgZnJvbSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBzaWxlbmNlX2R1cmF0aW9uX21zPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGlvbiB0aHJlc2hvbGQgZm9yIFZBRCAoMC4wIHRvIDEuMCksIHRoaXMgZGVmYXVsdHMgdG8gMC41LiBBIGhpZ2hlclxuICAgICAqIHRocmVzaG9sZCB3aWxsIHJlcXVpcmUgbG91ZGVyIGF1ZGlvIHRvIGFjdGl2YXRlIHRoZSBtb2RlbCwgYW5kIHRodXMgbWlnaHRcbiAgICAgKiBwZXJmb3JtIGJldHRlciBpbiBub2lzeSBlbnZpcm9ubWVudHMuXG4gICAgICovXG4gICAgdGhyZXNob2xkPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiB0dXJuIGRldGVjdGlvbiwgb25seSBgc2VydmVyX3ZhZGAgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICB0eXBlPzogc3RyaW5nO1xuICB9XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBTZXNzaW9ucyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBTZXNzaW9uIGFzIFNlc3Npb24sXG4gICAgdHlwZSBTZXNzaW9uQ3JlYXRlUmVzcG9uc2UgYXMgU2Vzc2lvbkNyZWF0ZVJlc3BvbnNlLFxuICAgIHR5cGUgU2Vzc2lvbkNyZWF0ZVBhcmFtcyBhcyBTZXNzaW9uQ3JlYXRlUGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgUmVhbHRpbWVBUEkgZnJvbSAnLi9yZWFsdGltZSc7XG5pbXBvcnQgKiBhcyBTZXNzaW9uc0FQSSBmcm9tICcuL3Nlc3Npb25zJztcbmltcG9ydCB7XG4gIFNlc3Npb24gYXMgU2Vzc2lvbnNBUElTZXNzaW9uLFxuICBTZXNzaW9uQ3JlYXRlUGFyYW1zLFxuICBTZXNzaW9uQ3JlYXRlUmVzcG9uc2UsXG4gIFNlc3Npb25zLFxufSBmcm9tICcuL3Nlc3Npb25zJztcblxuZXhwb3J0IGNsYXNzIFJlYWx0aW1lIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICBzZXNzaW9uczogU2Vzc2lvbnNBUEkuU2Vzc2lvbnMgPSBuZXcgU2Vzc2lvbnNBUEkuU2Vzc2lvbnModGhpcy5fY2xpZW50KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGEgY29udmVyc2F0aW9uIGlzIGNyZWF0ZWQuIEVtaXR0ZWQgcmlnaHQgYWZ0ZXIgc2Vzc2lvbiBjcmVhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb25DcmVhdGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIGNvbnZlcnNhdGlvbiByZXNvdXJjZS5cbiAgICovXG4gIGNvbnZlcnNhdGlvbjogQ29udmVyc2F0aW9uQ3JlYXRlZEV2ZW50LkNvbnZlcnNhdGlvbjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGNvbnZlcnNhdGlvbi5jcmVhdGVkYC5cbiAgICovXG4gIHR5cGU6ICdjb252ZXJzYXRpb24uY3JlYXRlZCc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29udmVyc2F0aW9uQ3JlYXRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBjb252ZXJzYXRpb24gcmVzb3VyY2UuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgY29udmVyc2F0aW9uLlxuICAgICAqL1xuICAgIGlkPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCB0eXBlLCBtdXN0IGJlIGByZWFsdGltZS5jb252ZXJzYXRpb25gLlxuICAgICAqL1xuICAgIG9iamVjdD86ICdyZWFsdGltZS5jb252ZXJzYXRpb24nO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGl0ZW0gdG8gYWRkIHRvIHRoZSBjb252ZXJzYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uSXRlbSB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBpdGVtLCB0aGlzIGNhbiBiZSBnZW5lcmF0ZWQgYnkgdGhlIGNsaWVudCB0byBoZWxwIG1hbmFnZVxuICAgKiBzZXJ2ZXItc2lkZSBjb250ZXh0LCBidXQgaXMgbm90IHJlcXVpcmVkIGJlY2F1c2UgdGhlIHNlcnZlciB3aWxsIGdlbmVyYXRlIG9uZSBpZlxuICAgKiBub3QgcHJvdmlkZWQuXG4gICAqL1xuICBpZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGFyZ3VtZW50cyBvZiB0aGUgZnVuY3Rpb24gY2FsbCAoZm9yIGBmdW5jdGlvbl9jYWxsYCBpdGVtcykuXG4gICAqL1xuICBhcmd1bWVudHM/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgZnVuY3Rpb24gY2FsbCAoZm9yIGBmdW5jdGlvbl9jYWxsYCBhbmQgYGZ1bmN0aW9uX2NhbGxfb3V0cHV0YFxuICAgKiBpdGVtcykuIElmIHBhc3NlZCBvbiBhIGBmdW5jdGlvbl9jYWxsX291dHB1dGAgaXRlbSwgdGhlIHNlcnZlciB3aWxsIGNoZWNrIHRoYXQgYVxuICAgKiBgZnVuY3Rpb25fY2FsbGAgaXRlbSB3aXRoIHRoZSBzYW1lIElEIGV4aXN0cyBpbiB0aGUgY29udmVyc2F0aW9uIGhpc3RvcnkuXG4gICAqL1xuICBjYWxsX2lkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZSwgYXBwbGljYWJsZSBmb3IgYG1lc3NhZ2VgIGl0ZW1zLlxuICAgKlxuICAgKiAtIE1lc3NhZ2UgaXRlbXMgb2Ygcm9sZSBgc3lzdGVtYCBzdXBwb3J0IG9ubHkgYGlucHV0X3RleHRgIGNvbnRlbnRcbiAgICogLSBNZXNzYWdlIGl0ZW1zIG9mIHJvbGUgYHVzZXJgIHN1cHBvcnQgYGlucHV0X3RleHRgIGFuZCBgaW5wdXRfYXVkaW9gIGNvbnRlbnRcbiAgICogLSBNZXNzYWdlIGl0ZW1zIG9mIHJvbGUgYGFzc2lzdGFudGAgc3VwcG9ydCBgdGV4dGAgY29udGVudC5cbiAgICovXG4gIGNvbnRlbnQ/OiBBcnJheTxDb252ZXJzYXRpb25JdGVtQ29udGVudD47XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiBiZWluZyBjYWxsZWQgKGZvciBgZnVuY3Rpb25fY2FsbGAgaXRlbXMpLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogSWRlbnRpZmllciBmb3IgdGhlIEFQSSBvYmplY3QgYmVpbmcgcmV0dXJuZWQgLSBhbHdheXMgYHJlYWx0aW1lLml0ZW1gLlxuICAgKi9cbiAgb2JqZWN0PzogJ3JlYWx0aW1lLml0ZW0nO1xuXG4gIC8qKlxuICAgKiBUaGUgb3V0cHV0IG9mIHRoZSBmdW5jdGlvbiBjYWxsIChmb3IgYGZ1bmN0aW9uX2NhbGxfb3V0cHV0YCBpdGVtcykuXG4gICAqL1xuICBvdXRwdXQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSByb2xlIG9mIHRoZSBtZXNzYWdlIHNlbmRlciAoYHVzZXJgLCBgYXNzaXN0YW50YCwgYHN5c3RlbWApLCBvbmx5IGFwcGxpY2FibGVcbiAgICogZm9yIGBtZXNzYWdlYCBpdGVtcy5cbiAgICovXG4gIHJvbGU/OiAndXNlcicgfCAnYXNzaXN0YW50JyB8ICdzeXN0ZW0nO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhdHVzIG9mIHRoZSBpdGVtIChgY29tcGxldGVkYCwgYGluY29tcGxldGVgKS4gVGhlc2UgaGF2ZSBubyBlZmZlY3Qgb24gdGhlXG4gICAqIGNvbnZlcnNhdGlvbiwgYnV0IGFyZSBhY2NlcHRlZCBmb3IgY29uc2lzdGVuY3kgd2l0aCB0aGVcbiAgICogYGNvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZWRgIGV2ZW50LlxuICAgKi9cbiAgc3RhdHVzPzogJ2NvbXBsZXRlZCcgfCAnaW5jb21wbGV0ZSc7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBpdGVtIChgbWVzc2FnZWAsIGBmdW5jdGlvbl9jYWxsYCwgYGZ1bmN0aW9uX2NhbGxfb3V0cHV0YCkuXG4gICAqL1xuICB0eXBlPzogJ21lc3NhZ2UnIHwgJ2Z1bmN0aW9uX2NhbGwnIHwgJ2Z1bmN0aW9uX2NhbGxfb3V0cHV0Jztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb25JdGVtQ29udGVudCB7XG4gIC8qKlxuICAgKiBJRCBvZiBhIHByZXZpb3VzIGNvbnZlcnNhdGlvbiBpdGVtIHRvIHJlZmVyZW5jZSAoZm9yIGBpdGVtX3JlZmVyZW5jZWAgY29udGVudFxuICAgKiB0eXBlcyBpbiBgcmVzcG9uc2UuY3JlYXRlYCBldmVudHMpLiBUaGVzZSBjYW4gcmVmZXJlbmNlIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXJcbiAgICogY3JlYXRlZCBpdGVtcy5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBCYXNlNjQtZW5jb2RlZCBhdWRpbyBieXRlcywgdXNlZCBmb3IgYGlucHV0X2F1ZGlvYCBjb250ZW50IHR5cGUuXG4gICAqL1xuICBhdWRpbz86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHRleHQgY29udGVudCwgdXNlZCBmb3IgYGlucHV0X3RleHRgIGFuZCBgdGV4dGAgY29udGVudCB0eXBlcy5cbiAgICovXG4gIHRleHQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0cmFuc2NyaXB0IG9mIHRoZSBhdWRpbywgdXNlZCBmb3IgYGlucHV0X2F1ZGlvYCBjb250ZW50IHR5cGUuXG4gICAqL1xuICB0cmFuc2NyaXB0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCB0eXBlIChgaW5wdXRfdGV4dGAsIGBpbnB1dF9hdWRpb2AsIGBpdGVtX3JlZmVyZW5jZWAsIGB0ZXh0YCkuXG4gICAqL1xuICB0eXBlPzogJ2lucHV0X3RleHQnIHwgJ2lucHV0X2F1ZGlvJyB8ICdpdGVtX3JlZmVyZW5jZScgfCAndGV4dCc7XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IEl0ZW0gdG8gdGhlIENvbnZlcnNhdGlvbidzIGNvbnRleHQsIGluY2x1ZGluZyBtZXNzYWdlcywgZnVuY3Rpb25cbiAqIGNhbGxzLCBhbmQgZnVuY3Rpb24gY2FsbCByZXNwb25zZXMuIFRoaXMgZXZlbnQgY2FuIGJlIHVzZWQgYm90aCB0byBwb3B1bGF0ZSBhXG4gKiBcImhpc3RvcnlcIiBvZiB0aGUgY29udmVyc2F0aW9uIGFuZCB0byBhZGQgbmV3IGl0ZW1zIG1pZC1zdHJlYW0sIGJ1dCBoYXMgdGhlXG4gKiBjdXJyZW50IGxpbWl0YXRpb24gdGhhdCBpdCBjYW5ub3QgcG9wdWxhdGUgYXNzaXN0YW50IGF1ZGlvIG1lc3NhZ2VzLlxuICpcbiAqIElmIHN1Y2Nlc3NmdWwsIHRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kIHdpdGggYSBgY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlZGAgZXZlbnQsXG4gKiBvdGhlcndpc2UgYW4gYGVycm9yYCBldmVudCB3aWxsIGJlIHNlbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uSXRlbUNyZWF0ZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpdGVtIHRvIGFkZCB0byB0aGUgY29udmVyc2F0aW9uLlxuICAgKi9cbiAgaXRlbTogQ29udmVyc2F0aW9uSXRlbTtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGNvbnZlcnNhdGlvbi5pdGVtLmNyZWF0ZWAuXG4gICAqL1xuICB0eXBlOiAnY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlJztcblxuICAvKipcbiAgICogT3B0aW9uYWwgY2xpZW50LWdlbmVyYXRlZCBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBwcmVjZWRpbmcgaXRlbSBhZnRlciB3aGljaCB0aGUgbmV3IGl0ZW0gd2lsbCBiZSBpbnNlcnRlZC4gSWYgbm90XG4gICAqIHNldCwgdGhlIG5ldyBpdGVtIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgY29udmVyc2F0aW9uLiBJZiBzZXQsIGl0XG4gICAqIGFsbG93cyBhbiBpdGVtIHRvIGJlIGluc2VydGVkIG1pZC1jb252ZXJzYXRpb24uIElmIHRoZSBJRCBjYW5ub3QgYmUgZm91bmQsIGFuXG4gICAqIGVycm9yIHdpbGwgYmUgcmV0dXJuZWQgYW5kIHRoZSBpdGVtIHdpbGwgbm90IGJlIGFkZGVkLlxuICAgKi9cbiAgcHJldmlvdXNfaXRlbV9pZD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGEgY29udmVyc2F0aW9uIGl0ZW0gaXMgY3JlYXRlZC4gVGhlcmUgYXJlIHNldmVyYWwgc2NlbmFyaW9zIHRoYXRcbiAqIHByb2R1Y2UgdGhpcyBldmVudDpcbiAqXG4gKiAtIFRoZSBzZXJ2ZXIgaXMgZ2VuZXJhdGluZyBhIFJlc3BvbnNlLCB3aGljaCBpZiBzdWNjZXNzZnVsIHdpbGwgcHJvZHVjZSBlaXRoZXJcbiAqICAgb25lIG9yIHR3byBJdGVtcywgd2hpY2ggd2lsbCBiZSBvZiB0eXBlIGBtZXNzYWdlYCAocm9sZSBgYXNzaXN0YW50YCkgb3IgdHlwZVxuICogICBgZnVuY3Rpb25fY2FsbGAuXG4gKiAtIFRoZSBpbnB1dCBhdWRpbyBidWZmZXIgaGFzIGJlZW4gY29tbWl0dGVkLCBlaXRoZXIgYnkgdGhlIGNsaWVudCBvciB0aGUgc2VydmVyXG4gKiAgIChpbiBgc2VydmVyX3ZhZGAgbW9kZSkuIFRoZSBzZXJ2ZXIgd2lsbCB0YWtlIHRoZSBjb250ZW50IG9mIHRoZSBpbnB1dCBhdWRpb1xuICogICBidWZmZXIgYW5kIGFkZCBpdCB0byBhIG5ldyB1c2VyIG1lc3NhZ2UgSXRlbS5cbiAqIC0gVGhlIGNsaWVudCBoYXMgc2VudCBhIGBjb252ZXJzYXRpb24uaXRlbS5jcmVhdGVgIGV2ZW50IHRvIGFkZCBhIG5ldyBJdGVtIHRvXG4gKiAgIHRoZSBDb252ZXJzYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uSXRlbUNyZWF0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICovXG4gIGl0ZW06IENvbnZlcnNhdGlvbkl0ZW07XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcHJlY2VkaW5nIGl0ZW0gaW4gdGhlIENvbnZlcnNhdGlvbiBjb250ZXh0LCBhbGxvd3MgdGhlIGNsaWVudCB0b1xuICAgKiB1bmRlcnN0YW5kIHRoZSBvcmRlciBvZiB0aGUgY29udmVyc2F0aW9uLlxuICAgKi9cbiAgcHJldmlvdXNfaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlZGAuXG4gICAqL1xuICB0eXBlOiAnY29udmVyc2F0aW9uLml0ZW0uY3JlYXRlZCc7XG59XG5cbi8qKlxuICogU2VuZCB0aGlzIGV2ZW50IHdoZW4geW91IHdhbnQgdG8gcmVtb3ZlIGFueSBpdGVtIGZyb20gdGhlIGNvbnZlcnNhdGlvbiBoaXN0b3J5LlxuICogVGhlIHNlcnZlciB3aWxsIHJlc3BvbmQgd2l0aCBhIGBjb252ZXJzYXRpb24uaXRlbS5kZWxldGVkYCBldmVudCwgdW5sZXNzIHRoZVxuICogaXRlbSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY29udmVyc2F0aW9uIGhpc3RvcnksIGluIHdoaWNoIGNhc2UgdGhlIHNlcnZlciB3aWxsXG4gKiByZXNwb25kIHdpdGggYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uSXRlbURlbGV0ZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgaXRlbSB0byBkZWxldGUuXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBjb252ZXJzYXRpb24uaXRlbS5kZWxldGVgLlxuICAgKi9cbiAgdHlwZTogJ2NvbnZlcnNhdGlvbi5pdGVtLmRlbGV0ZSc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGNsaWVudC1nZW5lcmF0ZWQgSUQgdXNlZCB0byBpZGVudGlmeSB0aGlzIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhbiBpdGVtIGluIHRoZSBjb252ZXJzYXRpb24gaXMgZGVsZXRlZCBieSB0aGUgY2xpZW50IHdpdGggYVxuICogYGNvbnZlcnNhdGlvbi5pdGVtLmRlbGV0ZWAgZXZlbnQuIFRoaXMgZXZlbnQgaXMgdXNlZCB0byBzeW5jaHJvbml6ZSB0aGUgc2VydmVyJ3NcbiAqIHVuZGVyc3RhbmRpbmcgb2YgdGhlIGNvbnZlcnNhdGlvbiBoaXN0b3J5IHdpdGggdGhlIGNsaWVudCdzIHZpZXcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uSXRlbURlbGV0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGl0ZW0gdGhhdCB3YXMgZGVsZXRlZC5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGNvbnZlcnNhdGlvbi5pdGVtLmRlbGV0ZWRgLlxuICAgKi9cbiAgdHlwZTogJ2NvbnZlcnNhdGlvbi5pdGVtLmRlbGV0ZWQnO1xufVxuXG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgdGhlIG91dHB1dCBvZiBhdWRpbyB0cmFuc2NyaXB0aW9uIGZvciB1c2VyIGF1ZGlvIHdyaXR0ZW4gdG8gdGhlXG4gKiB1c2VyIGF1ZGlvIGJ1ZmZlci4gVHJhbnNjcmlwdGlvbiBiZWdpbnMgd2hlbiB0aGUgaW5wdXQgYXVkaW8gYnVmZmVyIGlzIGNvbW1pdHRlZFxuICogYnkgdGhlIGNsaWVudCBvciBzZXJ2ZXIgKGluIGBzZXJ2ZXJfdmFkYCBtb2RlKS4gVHJhbnNjcmlwdGlvbiBydW5zXG4gKiBhc3luY2hyb25vdXNseSB3aXRoIFJlc3BvbnNlIGNyZWF0aW9uLCBzbyB0aGlzIGV2ZW50IG1heSBjb21lIGJlZm9yZSBvciBhZnRlclxuICogdGhlIFJlc3BvbnNlIGV2ZW50cy5cbiAqXG4gKiBSZWFsdGltZSBBUEkgbW9kZWxzIGFjY2VwdCBhdWRpbyBuYXRpdmVseSwgYW5kIHRodXMgaW5wdXQgdHJhbnNjcmlwdGlvbiBpcyBhXG4gKiBzZXBhcmF0ZSBwcm9jZXNzIHJ1biBvbiBhIHNlcGFyYXRlIEFTUiAoQXV0b21hdGljIFNwZWVjaCBSZWNvZ25pdGlvbikgbW9kZWwsXG4gKiBjdXJyZW50bHkgYWx3YXlzIGB3aGlzcGVyLTFgLiBUaHVzIHRoZSB0cmFuc2NyaXB0IG1heSBkaXZlcmdlIHNvbWV3aGF0IGZyb20gdGhlXG4gKiBtb2RlbCdzIGludGVycHJldGF0aW9uLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSByb3VnaCBndWlkZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb25JdGVtSW5wdXRBdWRpb1RyYW5zY3JpcHRpb25Db21wbGV0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCBjb250YWluaW5nIHRoZSBhdWRpby5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB1c2VyIG1lc3NhZ2UgaXRlbSBjb250YWluaW5nIHRoZSBhdWRpby5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHRyYW5zY3JpYmVkIHRleHQuXG4gICAqL1xuICB0cmFuc2NyaXB0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBjb252ZXJzYXRpb24uaXRlbS5pbnB1dF9hdWRpb190cmFuc2NyaXB0aW9uLmNvbXBsZXRlZGAuXG4gICAqL1xuICB0eXBlOiAnY29udmVyc2F0aW9uLml0ZW0uaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbi5jb21wbGV0ZWQnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiBpcyBjb25maWd1cmVkLCBhbmQgYSB0cmFuc2NyaXB0aW9uXG4gKiByZXF1ZXN0IGZvciBhIHVzZXIgbWVzc2FnZSBmYWlsZWQuIFRoZXNlIGV2ZW50cyBhcmUgc2VwYXJhdGUgZnJvbSBvdGhlciBgZXJyb3JgXG4gKiBldmVudHMgc28gdGhhdCB0aGUgY2xpZW50IGNhbiBpZGVudGlmeSB0aGUgcmVsYXRlZCBJdGVtLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbkl0ZW1JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbkZhaWxlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGNvbnRhaW5pbmcgdGhlIGF1ZGlvLlxuICAgKi9cbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBEZXRhaWxzIG9mIHRoZSB0cmFuc2NyaXB0aW9uIGVycm9yLlxuICAgKi9cbiAgZXJyb3I6IENvbnZlcnNhdGlvbkl0ZW1JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbkZhaWxlZEV2ZW50LkVycm9yO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHVzZXIgbWVzc2FnZSBpdGVtLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgY29udmVyc2F0aW9uLml0ZW0uaW5wdXRfYXVkaW9fdHJhbnNjcmlwdGlvbi5mYWlsZWRgLlxuICAgKi9cbiAgdHlwZTogJ2NvbnZlcnNhdGlvbi5pdGVtLmlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24uZmFpbGVkJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDb252ZXJzYXRpb25JdGVtSW5wdXRBdWRpb1RyYW5zY3JpcHRpb25GYWlsZWRFdmVudCB7XG4gIC8qKlxuICAgKiBEZXRhaWxzIG9mIHRoZSB0cmFuc2NyaXB0aW9uIGVycm9yLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBFcnJvciB7XG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSwgaWYgYW55LlxuICAgICAqL1xuICAgIGNvZGU/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgbWVzc2FnZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFBhcmFtZXRlciByZWxhdGVkIHRvIHRoZSBlcnJvciwgaWYgYW55LlxuICAgICAqL1xuICAgIHBhcmFtPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgZXJyb3IuXG4gICAgICovXG4gICAgdHlwZT86IHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIFNlbmQgdGhpcyBldmVudCB0byB0cnVuY2F0ZSBhIHByZXZpb3VzIGFzc2lzdGFudCBtZXNzYWdlXHUyMDE5cyBhdWRpby4gVGhlIHNlcnZlclxuICogd2lsbCBwcm9kdWNlIGF1ZGlvIGZhc3RlciB0aGFuIHJlYWx0aW1lLCBzbyB0aGlzIGV2ZW50IGlzIHVzZWZ1bCB3aGVuIHRoZSB1c2VyXG4gKiBpbnRlcnJ1cHRzIHRvIHRydW5jYXRlIGF1ZGlvIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBzZW50IHRvIHRoZSBjbGllbnQgYnV0IG5vdFxuICogeWV0IHBsYXllZC4gVGhpcyB3aWxsIHN5bmNocm9uaXplIHRoZSBzZXJ2ZXIncyB1bmRlcnN0YW5kaW5nIG9mIHRoZSBhdWRpbyB3aXRoXG4gKiB0aGUgY2xpZW50J3MgcGxheWJhY2suXG4gKlxuICogVHJ1bmNhdGluZyBhdWRpbyB3aWxsIGRlbGV0ZSB0aGUgc2VydmVyLXNpZGUgdGV4dCB0cmFuc2NyaXB0IHRvIGVuc3VyZSB0aGVyZSBpc1xuICogbm90IHRleHQgaW4gdGhlIGNvbnRleHQgdGhhdCBoYXNuJ3QgYmVlbiBoZWFyZCBieSB0aGUgdXNlci5cbiAqXG4gKiBJZiBzdWNjZXNzZnVsLCB0aGUgc2VydmVyIHdpbGwgcmVzcG9uZCB3aXRoIGEgYGNvbnZlcnNhdGlvbi5pdGVtLnRydW5jYXRlZGBcbiAqIGV2ZW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbkl0ZW1UcnVuY2F0ZUV2ZW50IHtcbiAgLyoqXG4gICAqIEluY2x1c2l2ZSBkdXJhdGlvbiB1cCB0byB3aGljaCBhdWRpbyBpcyB0cnVuY2F0ZWQsIGluIG1pbGxpc2Vjb25kcy4gSWYgdGhlXG4gICAqIGF1ZGlvX2VuZF9tcyBpcyBncmVhdGVyIHRoYW4gdGhlIGFjdHVhbCBhdWRpbyBkdXJhdGlvbiwgdGhlIHNlcnZlciB3aWxsIHJlc3BvbmRcbiAgICogd2l0aCBhbiBlcnJvci5cbiAgICovXG4gIGF1ZGlvX2VuZF9tczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCB0byB0cnVuY2F0ZS4gU2V0IHRoaXMgdG8gMC5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBhc3Npc3RhbnQgbWVzc2FnZSBpdGVtIHRvIHRydW5jYXRlLiBPbmx5IGFzc2lzdGFudCBtZXNzYWdlIGl0ZW1zXG4gICAqIGNhbiBiZSB0cnVuY2F0ZWQuXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBjb252ZXJzYXRpb24uaXRlbS50cnVuY2F0ZWAuXG4gICAqL1xuICB0eXBlOiAnY29udmVyc2F0aW9uLml0ZW0udHJ1bmNhdGUnO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjbGllbnQtZ2VuZXJhdGVkIElEIHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYW4gZWFybGllciBhc3Npc3RhbnQgYXVkaW8gbWVzc2FnZSBpdGVtIGlzIHRydW5jYXRlZCBieSB0aGUgY2xpZW50XG4gKiB3aXRoIGEgYGNvbnZlcnNhdGlvbi5pdGVtLnRydW5jYXRlYCBldmVudC4gVGhpcyBldmVudCBpcyB1c2VkIHRvIHN5bmNocm9uaXplIHRoZVxuICogc2VydmVyJ3MgdW5kZXJzdGFuZGluZyBvZiB0aGUgYXVkaW8gd2l0aCB0aGUgY2xpZW50J3MgcGxheWJhY2suXG4gKlxuICogVGhpcyBhY3Rpb24gd2lsbCB0cnVuY2F0ZSB0aGUgYXVkaW8gYW5kIHJlbW92ZSB0aGUgc2VydmVyLXNpZGUgdGV4dCB0cmFuc2NyaXB0XG4gKiB0byBlbnN1cmUgdGhlcmUgaXMgbm8gdGV4dCBpbiB0aGUgY29udGV4dCB0aGF0IGhhc24ndCBiZWVuIGhlYXJkIGJ5IHRoZSB1c2VyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbkl0ZW1UcnVuY2F0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24gdXAgdG8gd2hpY2ggdGhlIGF1ZGlvIHdhcyB0cnVuY2F0ZWQsIGluIG1pbGxpc2Vjb25kcy5cbiAgICovXG4gIGF1ZGlvX2VuZF9tczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCB0aGF0IHdhcyB0cnVuY2F0ZWQuXG4gICAqL1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgYXNzaXN0YW50IG1lc3NhZ2UgaXRlbSB0aGF0IHdhcyB0cnVuY2F0ZWQuXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBjb252ZXJzYXRpb24uaXRlbS50cnVuY2F0ZWRgLlxuICAgKi9cbiAgdHlwZTogJ2NvbnZlcnNhdGlvbi5pdGVtLnRydW5jYXRlZCc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMsIHdoaWNoIGNvdWxkIGJlIGEgY2xpZW50IHByb2JsZW0gb3IgYSBzZXJ2ZXJcbiAqIHByb2JsZW0uIE1vc3QgZXJyb3JzIGFyZSByZWNvdmVyYWJsZSBhbmQgdGhlIHNlc3Npb24gd2lsbCBzdGF5IG9wZW4sIHdlXG4gKiByZWNvbW1lbmQgdG8gaW1wbGVtZW50b3JzIHRvIG1vbml0b3IgYW5kIGxvZyBlcnJvciBtZXNzYWdlcyBieSBkZWZhdWx0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yRXZlbnQge1xuICAvKipcbiAgICogRGV0YWlscyBvZiB0aGUgZXJyb3IuXG4gICAqL1xuICBlcnJvcjogRXJyb3JFdmVudC5FcnJvcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGVycm9yYC5cbiAgICovXG4gIHR5cGU6ICdlcnJvcic7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRXJyb3JFdmVudCB7XG4gIC8qKlxuICAgKiBEZXRhaWxzIG9mIHRoZSBlcnJvci5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEEgaHVtYW4tcmVhZGFibGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBtZXNzYWdlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBlcnJvciAoZS5nLiwgXCJpbnZhbGlkX3JlcXVlc3RfZXJyb3JcIiwgXCJzZXJ2ZXJfZXJyb3JcIikuXG4gICAgICovXG4gICAgdHlwZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSwgaWYgYW55LlxuICAgICAqL1xuICAgIGNvZGU/OiBzdHJpbmcgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50X2lkIG9mIHRoZSBjbGllbnQgZXZlbnQgdGhhdCBjYXVzZWQgdGhlIGVycm9yLCBpZiBhcHBsaWNhYmxlLlxuICAgICAqL1xuICAgIGV2ZW50X2lkPzogc3RyaW5nIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFBhcmFtZXRlciByZWxhdGVkIHRvIHRoZSBlcnJvciwgaWYgYW55LlxuICAgICAqL1xuICAgIHBhcmFtPzogc3RyaW5nIHwgbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFNlbmQgdGhpcyBldmVudCB0byBhcHBlbmQgYXVkaW8gYnl0ZXMgdG8gdGhlIGlucHV0IGF1ZGlvIGJ1ZmZlci4gVGhlIGF1ZGlvXG4gKiBidWZmZXIgaXMgdGVtcG9yYXJ5IHN0b3JhZ2UgeW91IGNhbiB3cml0ZSB0byBhbmQgbGF0ZXIgY29tbWl0LiBJbiBTZXJ2ZXIgVkFEXG4gKiBtb2RlLCB0aGUgYXVkaW8gYnVmZmVyIGlzIHVzZWQgdG8gZGV0ZWN0IHNwZWVjaCBhbmQgdGhlIHNlcnZlciB3aWxsIGRlY2lkZSB3aGVuXG4gKiB0byBjb21taXQuIFdoZW4gU2VydmVyIFZBRCBpcyBkaXNhYmxlZCwgeW91IG11c3QgY29tbWl0IHRoZSBhdWRpbyBidWZmZXJcbiAqIG1hbnVhbGx5LlxuICpcbiAqIFRoZSBjbGllbnQgbWF5IGNob29zZSBob3cgbXVjaCBhdWRpbyB0byBwbGFjZSBpbiBlYWNoIGV2ZW50IHVwIHRvIGEgbWF4aW11bSBvZlxuICogMTUgTWlCLCBmb3IgZXhhbXBsZSBzdHJlYW1pbmcgc21hbGxlciBjaHVua3MgZnJvbSB0aGUgY2xpZW50IG1heSBhbGxvdyB0aGUgVkFEXG4gKiB0byBiZSBtb3JlIHJlc3BvbnNpdmUuIFVubGlrZSBtYWRlIG90aGVyIGNsaWVudCBldmVudHMsIHRoZSBzZXJ2ZXIgd2lsbCBub3Qgc2VuZFxuICogYSBjb25maXJtYXRpb24gcmVzcG9uc2UgdG8gdGhpcyBldmVudC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvQnVmZmVyQXBwZW5kRXZlbnQge1xuICAvKipcbiAgICogQmFzZTY0LWVuY29kZWQgYXVkaW8gYnl0ZXMuIFRoaXMgbXVzdCBiZSBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSB0aGVcbiAgICogYGlucHV0X2F1ZGlvX2Zvcm1hdGAgZmllbGQgaW4gdGhlIHNlc3Npb24gY29uZmlndXJhdGlvbi5cbiAgICovXG4gIGF1ZGlvOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBpbnB1dF9hdWRpb19idWZmZXIuYXBwZW5kYC5cbiAgICovXG4gIHR5cGU6ICdpbnB1dF9hdWRpb19idWZmZXIuYXBwZW5kJztcblxuICAvKipcbiAgICogT3B0aW9uYWwgY2xpZW50LWdlbmVyYXRlZCBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBTZW5kIHRoaXMgZXZlbnQgdG8gY2xlYXIgdGhlIGF1ZGlvIGJ5dGVzIGluIHRoZSBidWZmZXIuIFRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kXG4gKiB3aXRoIGFuIGBpbnB1dF9hdWRpb19idWZmZXIuY2xlYXJlZGAgZXZlbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb0J1ZmZlckNsZWFyRXZlbnQge1xuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGlucHV0X2F1ZGlvX2J1ZmZlci5jbGVhcmAuXG4gICAqL1xuICB0eXBlOiAnaW5wdXRfYXVkaW9fYnVmZmVyLmNsZWFyJztcblxuICAvKipcbiAgICogT3B0aW9uYWwgY2xpZW50LWdlbmVyYXRlZCBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIHRoZSBpbnB1dCBhdWRpbyBidWZmZXIgaXMgY2xlYXJlZCBieSB0aGUgY2xpZW50IHdpdGggYVxuICogYGlucHV0X2F1ZGlvX2J1ZmZlci5jbGVhcmAgZXZlbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb0J1ZmZlckNsZWFyZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgaW5wdXRfYXVkaW9fYnVmZmVyLmNsZWFyZWRgLlxuICAgKi9cbiAgdHlwZTogJ2lucHV0X2F1ZGlvX2J1ZmZlci5jbGVhcmVkJztcbn1cblxuLyoqXG4gKiBTZW5kIHRoaXMgZXZlbnQgdG8gY29tbWl0IHRoZSB1c2VyIGlucHV0IGF1ZGlvIGJ1ZmZlciwgd2hpY2ggd2lsbCBjcmVhdGUgYSBuZXdcbiAqIHVzZXIgbWVzc2FnZSBpdGVtIGluIHRoZSBjb252ZXJzYXRpb24uIFRoaXMgZXZlbnQgd2lsbCBwcm9kdWNlIGFuIGVycm9yIGlmIHRoZVxuICogaW5wdXQgYXVkaW8gYnVmZmVyIGlzIGVtcHR5LiBXaGVuIGluIFNlcnZlciBWQUQgbW9kZSwgdGhlIGNsaWVudCBkb2VzIG5vdCBuZWVkXG4gKiB0byBzZW5kIHRoaXMgZXZlbnQsIHRoZSBzZXJ2ZXIgd2lsbCBjb21taXQgdGhlIGF1ZGlvIGJ1ZmZlciBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIENvbW1pdHRpbmcgdGhlIGlucHV0IGF1ZGlvIGJ1ZmZlciB3aWxsIHRyaWdnZXIgaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiAoaWZcbiAqIGVuYWJsZWQgaW4gc2Vzc2lvbiBjb25maWd1cmF0aW9uKSwgYnV0IGl0IHdpbGwgbm90IGNyZWF0ZSBhIHJlc3BvbnNlIGZyb20gdGhlXG4gKiBtb2RlbC4gVGhlIHNlcnZlciB3aWxsIHJlc3BvbmQgd2l0aCBhbiBgaW5wdXRfYXVkaW9fYnVmZmVyLmNvbW1pdHRlZGAgZXZlbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRBdWRpb0J1ZmZlckNvbW1pdEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBpbnB1dF9hdWRpb19idWZmZXIuY29tbWl0YC5cbiAgICovXG4gIHR5cGU6ICdpbnB1dF9hdWRpb19idWZmZXIuY29tbWl0JztcblxuICAvKipcbiAgICogT3B0aW9uYWwgY2xpZW50LWdlbmVyYXRlZCBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGFuIGlucHV0IGF1ZGlvIGJ1ZmZlciBpcyBjb21taXR0ZWQsIGVpdGhlciBieSB0aGUgY2xpZW50IG9yXG4gKiBhdXRvbWF0aWNhbGx5IGluIHNlcnZlciBWQUQgbW9kZS4gVGhlIGBpdGVtX2lkYCBwcm9wZXJ0eSBpcyB0aGUgSUQgb2YgdGhlIHVzZXJcbiAqIG1lc3NhZ2UgaXRlbSB0aGF0IHdpbGwgYmUgY3JlYXRlZCwgdGh1cyBhIGBjb252ZXJzYXRpb24uaXRlbS5jcmVhdGVkYCBldmVudCB3aWxsXG4gKiBhbHNvIGJlIHNlbnQgdG8gdGhlIGNsaWVudC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvQnVmZmVyQ29tbWl0dGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB1c2VyIG1lc3NhZ2UgaXRlbSB0aGF0IHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBwcmVjZWRpbmcgaXRlbSBhZnRlciB3aGljaCB0aGUgbmV3IGl0ZW0gd2lsbCBiZSBpbnNlcnRlZC5cbiAgICovXG4gIHByZXZpb3VzX2l0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGlucHV0X2F1ZGlvX2J1ZmZlci5jb21taXR0ZWRgLlxuICAgKi9cbiAgdHlwZTogJ2lucHV0X2F1ZGlvX2J1ZmZlci5jb21taXR0ZWQnO1xufVxuXG4vKipcbiAqIFNlbnQgYnkgdGhlIHNlcnZlciB3aGVuIGluIGBzZXJ2ZXJfdmFkYCBtb2RlIHRvIGluZGljYXRlIHRoYXQgc3BlZWNoIGhhcyBiZWVuXG4gKiBkZXRlY3RlZCBpbiB0aGUgYXVkaW8gYnVmZmVyLiBUaGlzIGNhbiBoYXBwZW4gYW55IHRpbWUgYXVkaW8gaXMgYWRkZWQgdG8gdGhlXG4gKiBidWZmZXIgKHVubGVzcyBzcGVlY2ggaXMgYWxyZWFkeSBkZXRlY3RlZCkuIFRoZSBjbGllbnQgbWF5IHdhbnQgdG8gdXNlIHRoaXNcbiAqIGV2ZW50IHRvIGludGVycnVwdCBhdWRpbyBwbGF5YmFjayBvciBwcm92aWRlIHZpc3VhbCBmZWVkYmFjayB0byB0aGUgdXNlci5cbiAqXG4gKiBUaGUgY2xpZW50IHNob3VsZCBleHBlY3QgdG8gcmVjZWl2ZSBhIGBpbnB1dF9hdWRpb19idWZmZXIuc3BlZWNoX3N0b3BwZWRgIGV2ZW50XG4gKiB3aGVuIHNwZWVjaCBzdG9wcy4gVGhlIGBpdGVtX2lkYCBwcm9wZXJ0eSBpcyB0aGUgSUQgb2YgdGhlIHVzZXIgbWVzc2FnZSBpdGVtXG4gKiB0aGF0IHdpbGwgYmUgY3JlYXRlZCB3aGVuIHNwZWVjaCBzdG9wcyBhbmQgd2lsbCBhbHNvIGJlIGluY2x1ZGVkIGluIHRoZVxuICogYGlucHV0X2F1ZGlvX2J1ZmZlci5zcGVlY2hfc3RvcHBlZGAgZXZlbnQgKHVubGVzcyB0aGUgY2xpZW50IG1hbnVhbGx5IGNvbW1pdHNcbiAqIHRoZSBhdWRpbyBidWZmZXIgZHVyaW5nIFZBRCBhY3RpdmF0aW9uKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvQnVmZmVyU3BlZWNoU3RhcnRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIE1pbGxpc2Vjb25kcyBmcm9tIHRoZSBzdGFydCBvZiBhbGwgYXVkaW8gd3JpdHRlbiB0byB0aGUgYnVmZmVyIGR1cmluZyB0aGVcbiAgICogc2Vzc2lvbiB3aGVuIHNwZWVjaCB3YXMgZmlyc3QgZGV0ZWN0ZWQuIFRoaXMgd2lsbCBjb3JyZXNwb25kIHRvIHRoZSBiZWdpbm5pbmcgb2ZcbiAgICogYXVkaW8gc2VudCB0byB0aGUgbW9kZWwsIGFuZCB0aHVzIGluY2x1ZGVzIHRoZSBgcHJlZml4X3BhZGRpbmdfbXNgIGNvbmZpZ3VyZWQgaW5cbiAgICogdGhlIFNlc3Npb24uXG4gICAqL1xuICBhdWRpb19zdGFydF9tczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHVzZXIgbWVzc2FnZSBpdGVtIHRoYXQgd2lsbCBiZSBjcmVhdGVkIHdoZW4gc3BlZWNoIHN0b3BzLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgaW5wdXRfYXVkaW9fYnVmZmVyLnNwZWVjaF9zdGFydGVkYC5cbiAgICovXG4gIHR5cGU6ICdpbnB1dF9hdWRpb19idWZmZXIuc3BlZWNoX3N0YXJ0ZWQnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIGluIGBzZXJ2ZXJfdmFkYCBtb2RlIHdoZW4gdGhlIHNlcnZlciBkZXRlY3RzIHRoZSBlbmQgb2Ygc3BlZWNoIGluIHRoZVxuICogYXVkaW8gYnVmZmVyLiBUaGUgc2VydmVyIHdpbGwgYWxzbyBzZW5kIGFuIGBjb252ZXJzYXRpb24uaXRlbS5jcmVhdGVkYCBldmVudFxuICogd2l0aCB0aGUgdXNlciBtZXNzYWdlIGl0ZW0gdGhhdCBpcyBjcmVhdGVkIGZyb20gdGhlIGF1ZGlvIGJ1ZmZlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dEF1ZGlvQnVmZmVyU3BlZWNoU3RvcHBlZEV2ZW50IHtcbiAgLyoqXG4gICAqIE1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgc2Vzc2lvbiBzdGFydGVkIHdoZW4gc3BlZWNoIHN0b3BwZWQuIFRoaXMgd2lsbCBjb3JyZXNwb25kXG4gICAqIHRvIHRoZSBlbmQgb2YgYXVkaW8gc2VudCB0byB0aGUgbW9kZWwsIGFuZCB0aHVzIGluY2x1ZGVzIHRoZVxuICAgKiBgbWluX3NpbGVuY2VfZHVyYXRpb25fbXNgIGNvbmZpZ3VyZWQgaW4gdGhlIFNlc3Npb24uXG4gICAqL1xuICBhdWRpb19lbmRfbXM6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB1c2VyIG1lc3NhZ2UgaXRlbSB0aGF0IHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYGlucHV0X2F1ZGlvX2J1ZmZlci5zcGVlY2hfc3RvcHBlZGAuXG4gICAqL1xuICB0eXBlOiAnaW5wdXRfYXVkaW9fYnVmZmVyLnNwZWVjaF9zdG9wcGVkJztcbn1cblxuLyoqXG4gKiBFbWl0dGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBSZXNwb25zZSB0byBpbmRpY2F0ZSB0aGUgdXBkYXRlZCByYXRlIGxpbWl0cy4gV2hlblxuICogYSBSZXNwb25zZSBpcyBjcmVhdGVkIHNvbWUgdG9rZW5zIHdpbGwgYmUgXCJyZXNlcnZlZFwiIGZvciB0aGUgb3V0cHV0IHRva2VucywgdGhlXG4gKiByYXRlIGxpbWl0cyBzaG93biBoZXJlIHJlZmxlY3QgdGhhdCByZXNlcnZhdGlvbiwgd2hpY2ggaXMgdGhlbiBhZGp1c3RlZFxuICogYWNjb3JkaW5nbHkgb25jZSB0aGUgUmVzcG9uc2UgaXMgY29tcGxldGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJhdGVMaW1pdHNVcGRhdGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogTGlzdCBvZiByYXRlIGxpbWl0IGluZm9ybWF0aW9uLlxuICAgKi9cbiAgcmF0ZV9saW1pdHM6IEFycmF5PFJhdGVMaW1pdHNVcGRhdGVkRXZlbnQuUmF0ZUxpbWl0PjtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJhdGVfbGltaXRzLnVwZGF0ZWRgLlxuICAgKi9cbiAgdHlwZTogJ3JhdGVfbGltaXRzLnVwZGF0ZWQnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJhdGVMaW1pdHNVcGRhdGVkRXZlbnQge1xuICBleHBvcnQgaW50ZXJmYWNlIFJhdGVMaW1pdCB7XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSBmb3IgdGhlIHJhdGUgbGltaXQuXG4gICAgICovXG4gICAgbGltaXQ/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcmF0ZSBsaW1pdCAoYHJlcXVlc3RzYCwgYHRva2Vuc2ApLlxuICAgICAqL1xuICAgIG5hbWU/OiAncmVxdWVzdHMnIHwgJ3Rva2Vucyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVtYWluaW5nIHZhbHVlIGJlZm9yZSB0aGUgbGltaXQgaXMgcmVhY2hlZC5cbiAgICAgKi9cbiAgICByZW1haW5pbmc/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmRzIHVudGlsIHRoZSByYXRlIGxpbWl0IHJlc2V0cy5cbiAgICAgKi9cbiAgICByZXNldF9zZWNvbmRzPzogbnVtYmVyO1xuICB9XG59XG5cbi8qKlxuICogQWxsIGV2ZW50cyB0aGF0IHRoZSBjbGllbnQgY2FuIHNlbmQgdG8gdGhlIFJlYWx0aW1lIEFQSVxuICovXG5leHBvcnQgdHlwZSBSZWFsdGltZUNsaWVudEV2ZW50ID1cbiAgfCBTZXNzaW9uVXBkYXRlRXZlbnRcbiAgfCBJbnB1dEF1ZGlvQnVmZmVyQXBwZW5kRXZlbnRcbiAgfCBJbnB1dEF1ZGlvQnVmZmVyQ29tbWl0RXZlbnRcbiAgfCBJbnB1dEF1ZGlvQnVmZmVyQ2xlYXJFdmVudFxuICB8IENvbnZlcnNhdGlvbkl0ZW1DcmVhdGVFdmVudFxuICB8IENvbnZlcnNhdGlvbkl0ZW1UcnVuY2F0ZUV2ZW50XG4gIHwgQ29udmVyc2F0aW9uSXRlbURlbGV0ZUV2ZW50XG4gIHwgUmVzcG9uc2VDcmVhdGVFdmVudFxuICB8IFJlc3BvbnNlQ2FuY2VsRXZlbnQ7XG5cbi8qKlxuICogVGhlIHJlc3BvbnNlIHJlc291cmNlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlYWx0aW1lUmVzcG9uc2Uge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBpZD86IHN0cmluZztcblxuICAvKipcbiAgICogRGV2ZWxvcGVyLXByb3ZpZGVkIHN0cmluZyBrZXktdmFsdWUgcGFpcnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmVzcG9uc2UuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIG11c3QgYmUgYHJlYWx0aW1lLnJlc3BvbnNlYC5cbiAgICovXG4gIG9iamVjdD86ICdyZWFsdGltZS5yZXNwb25zZSc7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIG91dHB1dCBpdGVtcyBnZW5lcmF0ZWQgYnkgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0PzogQXJyYXk8Q29udmVyc2F0aW9uSXRlbT47XG5cbiAgLyoqXG4gICAqIFRoZSBmaW5hbCBzdGF0dXMgb2YgdGhlIHJlc3BvbnNlIChgY29tcGxldGVkYCwgYGNhbmNlbGxlZGAsIGBmYWlsZWRgLCBvclxuICAgKiBgaW5jb21wbGV0ZWApLlxuICAgKi9cbiAgc3RhdHVzPzogJ2NvbXBsZXRlZCcgfCAnY2FuY2VsbGVkJyB8ICdmYWlsZWQnIHwgJ2luY29tcGxldGUnO1xuXG4gIC8qKlxuICAgKiBBZGRpdGlvbmFsIGRldGFpbHMgYWJvdXQgdGhlIHN0YXR1cy5cbiAgICovXG4gIHN0YXR1c19kZXRhaWxzPzogUmVhbHRpbWVSZXNwb25zZVN0YXR1cztcblxuICAvKipcbiAgICogVXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIFJlc3BvbnNlLCB0aGlzIHdpbGwgY29ycmVzcG9uZCB0byBiaWxsaW5nLiBBIFJlYWx0aW1lXG4gICAqIEFQSSBzZXNzaW9uIHdpbGwgbWFpbnRhaW4gYSBjb252ZXJzYXRpb24gY29udGV4dCBhbmQgYXBwZW5kIG5ldyBJdGVtcyB0byB0aGVcbiAgICogQ29udmVyc2F0aW9uLCB0aHVzIG91dHB1dCBmcm9tIHByZXZpb3VzIHR1cm5zICh0ZXh0IGFuZCBhdWRpbyB0b2tlbnMpIHdpbGxcbiAgICogYmVjb21lIHRoZSBpbnB1dCBmb3IgbGF0ZXIgdHVybnMuXG4gICAqL1xuICB1c2FnZT86IFJlYWx0aW1lUmVzcG9uc2VVc2FnZTtcbn1cblxuLyoqXG4gKiBBZGRpdGlvbmFsIGRldGFpbHMgYWJvdXQgdGhlIHN0YXR1cy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWFsdGltZVJlc3BvbnNlU3RhdHVzIHtcbiAgLyoqXG4gICAqIEEgZGVzY3JpcHRpb24gb2YgdGhlIGVycm9yIHRoYXQgY2F1c2VkIHRoZSByZXNwb25zZSB0byBmYWlsLCBwb3B1bGF0ZWQgd2hlbiB0aGVcbiAgICogYHN0YXR1c2AgaXMgYGZhaWxlZGAuXG4gICAqL1xuICBlcnJvcj86IFJlYWx0aW1lUmVzcG9uc2VTdGF0dXMuRXJyb3I7XG5cbiAgLyoqXG4gICAqIFRoZSByZWFzb24gdGhlIFJlc3BvbnNlIGRpZCBub3QgY29tcGxldGUuIEZvciBhIGBjYW5jZWxsZWRgIFJlc3BvbnNlLCBvbmUgb2ZcbiAgICogYHR1cm5fZGV0ZWN0ZWRgICh0aGUgc2VydmVyIFZBRCBkZXRlY3RlZCBhIG5ldyBzdGFydCBvZiBzcGVlY2gpIG9yXG4gICAqIGBjbGllbnRfY2FuY2VsbGVkYCAodGhlIGNsaWVudCBzZW50IGEgY2FuY2VsIGV2ZW50KS4gRm9yIGFuIGBpbmNvbXBsZXRlYFxuICAgKiBSZXNwb25zZSwgb25lIG9mIGBtYXhfb3V0cHV0X3Rva2Vuc2Agb3IgYGNvbnRlbnRfZmlsdGVyYCAodGhlIHNlcnZlci1zaWRlIHNhZmV0eVxuICAgKiBmaWx0ZXIgYWN0aXZhdGVkIGFuZCBjdXQgb2ZmIHRoZSByZXNwb25zZSkuXG4gICAqL1xuICByZWFzb24/OiAndHVybl9kZXRlY3RlZCcgfCAnY2xpZW50X2NhbmNlbGxlZCcgfCAnbWF4X291dHB1dF90b2tlbnMnIHwgJ2NvbnRlbnRfZmlsdGVyJztcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgZXJyb3IgdGhhdCBjYXVzZWQgdGhlIHJlc3BvbnNlIHRvIGZhaWwsIGNvcnJlc3BvbmRpbmcgd2l0aCB0aGVcbiAgICogYHN0YXR1c2AgZmllbGQgKGBjb21wbGV0ZWRgLCBgY2FuY2VsbGVkYCwgYGluY29tcGxldGVgLCBgZmFpbGVkYCkuXG4gICAqL1xuICB0eXBlPzogJ2NvbXBsZXRlZCcgfCAnY2FuY2VsbGVkJyB8ICdpbmNvbXBsZXRlJyB8ICdmYWlsZWQnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJlYWx0aW1lUmVzcG9uc2VTdGF0dXMge1xuICAvKipcbiAgICogQSBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3IgdGhhdCBjYXVzZWQgdGhlIHJlc3BvbnNlIHRvIGZhaWwsIHBvcHVsYXRlZCB3aGVuIHRoZVxuICAgKiBgc3RhdHVzYCBpcyBgZmFpbGVkYC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUsIGlmIGFueS5cbiAgICAgKi9cbiAgICBjb2RlPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgZXJyb3IuXG4gICAgICovXG4gICAgdHlwZT86IHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBSZXNwb25zZSwgdGhpcyB3aWxsIGNvcnJlc3BvbmQgdG8gYmlsbGluZy4gQSBSZWFsdGltZVxuICogQVBJIHNlc3Npb24gd2lsbCBtYWludGFpbiBhIGNvbnZlcnNhdGlvbiBjb250ZXh0IGFuZCBhcHBlbmQgbmV3IEl0ZW1zIHRvIHRoZVxuICogQ29udmVyc2F0aW9uLCB0aHVzIG91dHB1dCBmcm9tIHByZXZpb3VzIHR1cm5zICh0ZXh0IGFuZCBhdWRpbyB0b2tlbnMpIHdpbGxcbiAqIGJlY29tZSB0aGUgaW5wdXQgZm9yIGxhdGVyIHR1cm5zLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlYWx0aW1lUmVzcG9uc2VVc2FnZSB7XG4gIC8qKlxuICAgKiBEZXRhaWxzIGFib3V0IHRoZSBpbnB1dCB0b2tlbnMgdXNlZCBpbiB0aGUgUmVzcG9uc2UuXG4gICAqL1xuICBpbnB1dF90b2tlbl9kZXRhaWxzPzogUmVhbHRpbWVSZXNwb25zZVVzYWdlLklucHV0VG9rZW5EZXRhaWxzO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGlucHV0IHRva2VucyB1c2VkIGluIHRoZSBSZXNwb25zZSwgaW5jbHVkaW5nIHRleHQgYW5kIGF1ZGlvXG4gICAqIHRva2Vucy5cbiAgICovXG4gIGlucHV0X3Rva2Vucz86IG51bWJlcjtcblxuICAvKipcbiAgICogRGV0YWlscyBhYm91dCB0aGUgb3V0cHV0IHRva2VucyB1c2VkIGluIHRoZSBSZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF90b2tlbl9kZXRhaWxzPzogUmVhbHRpbWVSZXNwb25zZVVzYWdlLk91dHB1dFRva2VuRGV0YWlscztcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBvdXRwdXQgdG9rZW5zIHNlbnQgaW4gdGhlIFJlc3BvbnNlLCBpbmNsdWRpbmcgdGV4dCBhbmQgYXVkaW9cbiAgICogdG9rZW5zLlxuICAgKi9cbiAgb3V0cHV0X3Rva2Vucz86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHRvdGFsIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIFJlc3BvbnNlIGluY2x1ZGluZyBpbnB1dCBhbmQgb3V0cHV0IHRleHQgYW5kXG4gICAqIGF1ZGlvIHRva2Vucy5cbiAgICovXG4gIHRvdGFsX3Rva2Vucz86IG51bWJlcjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSZWFsdGltZVJlc3BvbnNlVXNhZ2Uge1xuICAvKipcbiAgICogRGV0YWlscyBhYm91dCB0aGUgaW5wdXQgdG9rZW5zIHVzZWQgaW4gdGhlIFJlc3BvbnNlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBJbnB1dFRva2VuRGV0YWlscyB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBhdWRpbyB0b2tlbnMgdXNlZCBpbiB0aGUgUmVzcG9uc2UuXG4gICAgICovXG4gICAgYXVkaW9fdG9rZW5zPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBjYWNoZWQgdG9rZW5zIHVzZWQgaW4gdGhlIFJlc3BvbnNlLlxuICAgICAqL1xuICAgIGNhY2hlZF90b2tlbnM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRleHQgdG9rZW5zIHVzZWQgaW4gdGhlIFJlc3BvbnNlLlxuICAgICAqL1xuICAgIHRleHRfdG9rZW5zPzogbnVtYmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFpbHMgYWJvdXQgdGhlIG91dHB1dCB0b2tlbnMgdXNlZCBpbiB0aGUgUmVzcG9uc2UuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIE91dHB1dFRva2VuRGV0YWlscyB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBhdWRpbyB0b2tlbnMgdXNlZCBpbiB0aGUgUmVzcG9uc2UuXG4gICAgICovXG4gICAgYXVkaW9fdG9rZW5zPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiB0ZXh0IHRva2VucyB1c2VkIGluIHRoZSBSZXNwb25zZS5cbiAgICAgKi9cbiAgICB0ZXh0X3Rva2Vucz86IG51bWJlcjtcbiAgfVxufVxuXG4vKipcbiAqIEFsbCBldmVudHMgdGhhdCB0aGUgUmVhbHRpbWUgQVBJIGNhbiBzZW5kIGJhY2tcbiAqL1xuZXhwb3J0IHR5cGUgUmVhbHRpbWVTZXJ2ZXJFdmVudCA9XG4gIHwgRXJyb3JFdmVudFxuICB8IFNlc3Npb25DcmVhdGVkRXZlbnRcbiAgfCBTZXNzaW9uVXBkYXRlZEV2ZW50XG4gIHwgQ29udmVyc2F0aW9uQ3JlYXRlZEV2ZW50XG4gIHwgSW5wdXRBdWRpb0J1ZmZlckNvbW1pdHRlZEV2ZW50XG4gIHwgSW5wdXRBdWRpb0J1ZmZlckNsZWFyZWRFdmVudFxuICB8IElucHV0QXVkaW9CdWZmZXJTcGVlY2hTdGFydGVkRXZlbnRcbiAgfCBJbnB1dEF1ZGlvQnVmZmVyU3BlZWNoU3RvcHBlZEV2ZW50XG4gIHwgQ29udmVyc2F0aW9uSXRlbUNyZWF0ZWRFdmVudFxuICB8IENvbnZlcnNhdGlvbkl0ZW1JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbkNvbXBsZXRlZEV2ZW50XG4gIHwgQ29udmVyc2F0aW9uSXRlbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uRmFpbGVkRXZlbnRcbiAgfCBDb252ZXJzYXRpb25JdGVtVHJ1bmNhdGVkRXZlbnRcbiAgfCBDb252ZXJzYXRpb25JdGVtRGVsZXRlZEV2ZW50XG4gIHwgUmVzcG9uc2VDcmVhdGVkRXZlbnRcbiAgfCBSZXNwb25zZURvbmVFdmVudFxuICB8IFJlc3BvbnNlT3V0cHV0SXRlbUFkZGVkRXZlbnRcbiAgfCBSZXNwb25zZU91dHB1dEl0ZW1Eb25lRXZlbnRcbiAgfCBSZXNwb25zZUNvbnRlbnRQYXJ0QWRkZWRFdmVudFxuICB8IFJlc3BvbnNlQ29udGVudFBhcnREb25lRXZlbnRcbiAgfCBSZXNwb25zZVRleHREZWx0YUV2ZW50XG4gIHwgUmVzcG9uc2VUZXh0RG9uZUV2ZW50XG4gIHwgUmVzcG9uc2VBdWRpb1RyYW5zY3JpcHREZWx0YUV2ZW50XG4gIHwgUmVzcG9uc2VBdWRpb1RyYW5zY3JpcHREb25lRXZlbnRcbiAgfCBSZXNwb25zZUF1ZGlvRGVsdGFFdmVudFxuICB8IFJlc3BvbnNlQXVkaW9Eb25lRXZlbnRcbiAgfCBSZXNwb25zZUZ1bmN0aW9uQ2FsbEFyZ3VtZW50c0RlbHRhRXZlbnRcbiAgfCBSZXNwb25zZUZ1bmN0aW9uQ2FsbEFyZ3VtZW50c0RvbmVFdmVudFxuICB8IFJhdGVMaW1pdHNVcGRhdGVkRXZlbnQ7XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiB0aGUgbW9kZWwtZ2VuZXJhdGVkIGF1ZGlvIGlzIHVwZGF0ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VBdWRpb0RlbHRhRXZlbnQge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgaW4gdGhlIGl0ZW0ncyBjb250ZW50IGFycmF5LlxuICAgKi9cbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBCYXNlNjQtZW5jb2RlZCBhdWRpbyBkYXRhIGRlbHRhLlxuICAgKi9cbiAgZGVsdGE6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBpdGVtLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSByZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLmF1ZGlvLmRlbHRhYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5hdWRpby5kZWx0YSc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiB0aGUgbW9kZWwtZ2VuZXJhdGVkIGF1ZGlvIGlzIGRvbmUuIEFsc28gZW1pdHRlZCB3aGVuIGEgUmVzcG9uc2UgaXNcbiAqIGludGVycnVwdGVkLCBpbmNvbXBsZXRlLCBvciBjYW5jZWxsZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VBdWRpb0RvbmVFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCBpbiB0aGUgaXRlbSdzIGNvbnRlbnQgYXJyYXkuXG4gICAqL1xuICBjb250ZW50X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgaXRlbS5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaXRlbSBpbiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSByZXNwb25zZS5cbiAgICovXG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5hdWRpby5kb25lYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5hdWRpby5kb25lJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIHRoZSBtb2RlbC1nZW5lcmF0ZWQgdHJhbnNjcmlwdGlvbiBvZiBhdWRpbyBvdXRwdXQgaXMgdXBkYXRlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUF1ZGlvVHJhbnNjcmlwdERlbHRhRXZlbnQge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgaW4gdGhlIGl0ZW0ncyBjb250ZW50IGFycmF5LlxuICAgKi9cbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNjcmlwdCBkZWx0YS5cbiAgICovXG4gIGRlbHRhOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgaXRlbS5cbiAgICovXG4gIGl0ZW1faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaXRlbSBpbiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSByZXNwb25zZS5cbiAgICovXG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5hdWRpb190cmFuc2NyaXB0LmRlbHRhYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5hdWRpb190cmFuc2NyaXB0LmRlbHRhJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIHRoZSBtb2RlbC1nZW5lcmF0ZWQgdHJhbnNjcmlwdGlvbiBvZiBhdWRpbyBvdXRwdXQgaXMgZG9uZVxuICogc3RyZWFtaW5nLiBBbHNvIGVtaXR0ZWQgd2hlbiBhIFJlc3BvbnNlIGlzIGludGVycnVwdGVkLCBpbmNvbXBsZXRlLCBvclxuICogY2FuY2VsbGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQXVkaW9UcmFuc2NyaXB0RG9uZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGluIHRoZSBpdGVtJ3MgY29udGVudCBhcnJheS5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBpdGVtLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSByZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGZpbmFsIHRyYW5zY3JpcHQgb2YgdGhlIGF1ZGlvLlxuICAgKi9cbiAgdHJhbnNjcmlwdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UuYXVkaW9fdHJhbnNjcmlwdC5kb25lYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5hdWRpb190cmFuc2NyaXB0LmRvbmUnO1xufVxuXG4vKipcbiAqIFNlbmQgdGhpcyBldmVudCB0byBjYW5jZWwgYW4gaW4tcHJvZ3Jlc3MgcmVzcG9uc2UuIFRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kIHdpdGhcbiAqIGEgYHJlc3BvbnNlLmNhbmNlbGxlZGAgZXZlbnQgb3IgYW4gZXJyb3IgaWYgdGhlcmUgaXMgbm8gcmVzcG9uc2UgdG8gY2FuY2VsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQ2FuY2VsRXZlbnQge1xuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLmNhbmNlbGAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UuY2FuY2VsJztcblxuICAvKipcbiAgICogT3B0aW9uYWwgY2xpZW50LWdlbmVyYXRlZCBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZD86IHN0cmluZztcblxuICAvKipcbiAgICogQSBzcGVjaWZpYyByZXNwb25zZSBJRCB0byBjYW5jZWwgLSBpZiBub3QgcHJvdmlkZWQsIHdpbGwgY2FuY2VsIGFuIGluLXByb2dyZXNzXG4gICAqIHJlc3BvbnNlIGluIHRoZSBkZWZhdWx0IGNvbnZlcnNhdGlvbi5cbiAgICovXG4gIHJlc3BvbnNlX2lkPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBuZXcgY29udGVudCBwYXJ0IGlzIGFkZGVkIHRvIGFuIGFzc2lzdGFudCBtZXNzYWdlIGl0ZW0gZHVyaW5nXG4gKiByZXNwb25zZSBnZW5lcmF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQ29udGVudFBhcnRBZGRlZEV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGluIHRoZSBpdGVtJ3MgY29udGVudCBhcnJheS5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBpdGVtIHRvIHdoaWNoIHRoZSBjb250ZW50IHBhcnQgd2FzIGFkZGVkLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSByZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBwYXJ0IHRoYXQgd2FzIGFkZGVkLlxuICAgKi9cbiAgcGFydDogUmVzcG9uc2VDb250ZW50UGFydEFkZGVkRXZlbnQuUGFydDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSByZXNwb25zZS5cbiAgICovXG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5jb250ZW50X3BhcnQuYWRkZWRgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLmNvbnRlbnRfcGFydC5hZGRlZCc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUmVzcG9uc2VDb250ZW50UGFydEFkZGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnQgcGFydCB0aGF0IHdhcyBhZGRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgUGFydCB7XG4gICAgLyoqXG4gICAgICogQmFzZTY0LWVuY29kZWQgYXVkaW8gZGF0YSAoaWYgdHlwZSBpcyBcImF1ZGlvXCIpLlxuICAgICAqL1xuICAgIGF1ZGlvPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgY29udGVudCAoaWYgdHlwZSBpcyBcInRleHRcIikuXG4gICAgICovXG4gICAgdGV4dD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2NyaXB0IG9mIHRoZSBhdWRpbyAoaWYgdHlwZSBpcyBcImF1ZGlvXCIpLlxuICAgICAqL1xuICAgIHRyYW5zY3JpcHQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGVudCB0eXBlIChcInRleHRcIiwgXCJhdWRpb1wiKS5cbiAgICAgKi9cbiAgICB0eXBlPzogJ3RleHQnIHwgJ2F1ZGlvJztcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBjb250ZW50IHBhcnQgaXMgZG9uZSBzdHJlYW1pbmcgaW4gYW4gYXNzaXN0YW50IG1lc3NhZ2UgaXRlbS5cbiAqIEFsc28gZW1pdHRlZCB3aGVuIGEgUmVzcG9uc2UgaXMgaW50ZXJydXB0ZWQsIGluY29tcGxldGUsIG9yIGNhbmNlbGxlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUNvbnRlbnRQYXJ0RG9uZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGluIHRoZSBpdGVtJ3MgY29udGVudCBhcnJheS5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBpdGVtLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSByZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBwYXJ0IHRoYXQgaXMgZG9uZS5cbiAgICovXG4gIHBhcnQ6IFJlc3BvbnNlQ29udGVudFBhcnREb25lRXZlbnQuUGFydDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSByZXNwb25zZS5cbiAgICovXG4gIHJlc3BvbnNlX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5jb250ZW50X3BhcnQuZG9uZWAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UuY29udGVudF9wYXJ0LmRvbmUnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJlc3BvbnNlQ29udGVudFBhcnREb25lRXZlbnQge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnQgcGFydCB0aGF0IGlzIGRvbmUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFBhcnQge1xuICAgIC8qKlxuICAgICAqIEJhc2U2NC1lbmNvZGVkIGF1ZGlvIGRhdGEgKGlmIHR5cGUgaXMgXCJhdWRpb1wiKS5cbiAgICAgKi9cbiAgICBhdWRpbz86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IGNvbnRlbnQgKGlmIHR5cGUgaXMgXCJ0ZXh0XCIpLlxuICAgICAqL1xuICAgIHRleHQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNjcmlwdCBvZiB0aGUgYXVkaW8gKGlmIHR5cGUgaXMgXCJhdWRpb1wiKS5cbiAgICAgKi9cbiAgICB0cmFuc2NyaXB0Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRlbnQgdHlwZSAoXCJ0ZXh0XCIsIFwiYXVkaW9cIikuXG4gICAgICovXG4gICAgdHlwZT86ICd0ZXh0JyB8ICdhdWRpbyc7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGV2ZW50IGluc3RydWN0cyB0aGUgc2VydmVyIHRvIGNyZWF0ZSBhIFJlc3BvbnNlLCB3aGljaCBtZWFucyB0cmlnZ2VyaW5nXG4gKiBtb2RlbCBpbmZlcmVuY2UuIFdoZW4gaW4gU2VydmVyIFZBRCBtb2RlLCB0aGUgc2VydmVyIHdpbGwgY3JlYXRlIFJlc3BvbnNlc1xuICogYXV0b21hdGljYWxseS5cbiAqXG4gKiBBIFJlc3BvbnNlIHdpbGwgaW5jbHVkZSBhdCBsZWFzdCBvbmUgSXRlbSwgYW5kIG1heSBoYXZlIHR3bywgaW4gd2hpY2ggY2FzZSB0aGVcbiAqIHNlY29uZCB3aWxsIGJlIGEgZnVuY3Rpb24gY2FsbC4gVGhlc2UgSXRlbXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgY29udmVyc2F0aW9uXG4gKiBoaXN0b3J5LlxuICpcbiAqIFRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kIHdpdGggYSBgcmVzcG9uc2UuY3JlYXRlZGAgZXZlbnQsIGV2ZW50cyBmb3IgSXRlbXMgYW5kXG4gKiBjb250ZW50IGNyZWF0ZWQsIGFuZCBmaW5hbGx5IGEgYHJlc3BvbnNlLmRvbmVgIGV2ZW50IHRvIGluZGljYXRlIHRoZSBSZXNwb25zZSBpc1xuICogY29tcGxldGUuXG4gKlxuICogVGhlIGByZXNwb25zZS5jcmVhdGVgIGV2ZW50IGluY2x1ZGVzIGluZmVyZW5jZSBjb25maWd1cmF0aW9uIGxpa2VcbiAqIGBpbnN0cnVjdGlvbnNgLCBhbmQgYHRlbXBlcmF0dXJlYC4gVGhlc2UgZmllbGRzIHdpbGwgb3ZlcnJpZGUgdGhlIFNlc3Npb24nc1xuICogY29uZmlndXJhdGlvbiBmb3IgdGhpcyBSZXNwb25zZSBvbmx5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlQ3JlYXRlRXZlbnQge1xuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLmNyZWF0ZWAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UuY3JlYXRlJztcblxuICAvKipcbiAgICogT3B0aW9uYWwgY2xpZW50LWdlbmVyYXRlZCBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZD86IHN0cmluZztcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFJlYWx0aW1lIHJlc3BvbnNlIHdpdGggdGhlc2UgcGFyYW1ldGVyc1xuICAgKi9cbiAgcmVzcG9uc2U/OiBSZXNwb25zZUNyZWF0ZUV2ZW50LlJlc3BvbnNlO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJlc3BvbnNlQ3JlYXRlRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFJlYWx0aW1lIHJlc3BvbnNlIHdpdGggdGhlc2UgcGFyYW1ldGVyc1xuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZSB7XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgd2hpY2ggY29udmVyc2F0aW9uIHRoZSByZXNwb25zZSBpcyBhZGRlZCB0by4gQ3VycmVudGx5IHN1cHBvcnRzIGBhdXRvYFxuICAgICAqIGFuZCBgbm9uZWAsIHdpdGggYGF1dG9gIGFzIHRoZSBkZWZhdWx0IHZhbHVlLiBUaGUgYGF1dG9gIHZhbHVlIG1lYW5zIHRoYXQgdGhlXG4gICAgICogY29udGVudHMgb2YgdGhlIHJlc3BvbnNlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGRlZmF1bHQgY29udmVyc2F0aW9uLiBTZXQgdGhpcyB0b1xuICAgICAqIGBub25lYCB0byBjcmVhdGUgYW4gb3V0LW9mLWJhbmQgcmVzcG9uc2Ugd2hpY2ggd2lsbCBub3QgYWRkIGl0ZW1zIHRvIGRlZmF1bHRcbiAgICAgKiBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgY29udmVyc2F0aW9uPzogKHN0cmluZyAmIHt9KSB8ICdhdXRvJyB8ICdub25lJztcblxuICAgIC8qKlxuICAgICAqIElucHV0IGl0ZW1zIHRvIGluY2x1ZGUgaW4gdGhlIHByb21wdCBmb3IgdGhlIG1vZGVsLiBDcmVhdGVzIGEgbmV3IGNvbnRleHQgZm9yXG4gICAgICogdGhpcyByZXNwb25zZSwgd2l0aG91dCBpbmNsdWRpbmcgdGhlIGRlZmF1bHQgY29udmVyc2F0aW9uLiBDYW4gaW5jbHVkZVxuICAgICAqIHJlZmVyZW5jZXMgdG8gaXRlbXMgZnJvbSB0aGUgZGVmYXVsdCBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgaW5wdXQ/OiBBcnJheTxSZWFsdGltZUFQSS5Db252ZXJzYXRpb25JdGVtPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHN5c3RlbSBpbnN0cnVjdGlvbnMgKGkuZS4gc3lzdGVtIG1lc3NhZ2UpIHByZXBlbmRlZCB0byBtb2RlbCBjYWxscy5cbiAgICAgKiBUaGlzIGZpZWxkIGFsbG93cyB0aGUgY2xpZW50IHRvIGd1aWRlIHRoZSBtb2RlbCBvbiBkZXNpcmVkIHJlc3BvbnNlcy4gVGhlIG1vZGVsXG4gICAgICogY2FuIGJlIGluc3RydWN0ZWQgb24gcmVzcG9uc2UgY29udGVudCBhbmQgZm9ybWF0LCAoZS5nLiBcImJlIGV4dHJlbWVseSBzdWNjaW5jdFwiLFxuICAgICAqIFwiYWN0IGZyaWVuZGx5XCIsIFwiaGVyZSBhcmUgZXhhbXBsZXMgb2YgZ29vZCByZXNwb25zZXNcIikgYW5kIG9uIGF1ZGlvIGJlaGF2aW9yXG4gICAgICogKGUuZy4gXCJ0YWxrIHF1aWNrbHlcIiwgXCJpbmplY3QgZW1vdGlvbiBpbnRvIHlvdXIgdm9pY2VcIiwgXCJsYXVnaCBmcmVxdWVudGx5XCIpLiBUaGVcbiAgICAgKiBpbnN0cnVjdGlvbnMgYXJlIG5vdCBndWFyYW50ZWVkIHRvIGJlIGZvbGxvd2VkIGJ5IHRoZSBtb2RlbCwgYnV0IHRoZXkgcHJvdmlkZVxuICAgICAqIGd1aWRhbmNlIHRvIHRoZSBtb2RlbCBvbiB0aGUgZGVzaXJlZCBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGUgc2VydmVyIHNldHMgZGVmYXVsdCBpbnN0cnVjdGlvbnMgd2hpY2ggd2lsbCBiZSB1c2VkIGlmIHRoaXMgZmllbGRcbiAgICAgKiBpcyBub3Qgc2V0IGFuZCBhcmUgdmlzaWJsZSBpbiB0aGUgYHNlc3Npb24uY3JlYXRlZGAgZXZlbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAqIHNlc3Npb24uXG4gICAgICovXG4gICAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBudW1iZXIgb2Ygb3V0cHV0IHRva2VucyBmb3IgYSBzaW5nbGUgYXNzaXN0YW50IHJlc3BvbnNlLCBpbmNsdXNpdmUgb2ZcbiAgICAgKiB0b29sIGNhbGxzLiBQcm92aWRlIGFuIGludGVnZXIgYmV0d2VlbiAxIGFuZCA0MDk2IHRvIGxpbWl0IG91dHB1dCB0b2tlbnMsIG9yXG4gICAgICogYGluZmAgZm9yIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSB0b2tlbnMgZm9yIGEgZ2l2ZW4gbW9kZWwuIERlZmF1bHRzIHRvIGBpbmZgLlxuICAgICAqL1xuICAgIG1heF9yZXNwb25zZV9vdXRwdXRfdG9rZW5zPzogbnVtYmVyIHwgJ2luZic7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGltdW0gb2YgNTEyXG4gICAgICogY2hhcmFjdGVycyBsb25nLlxuICAgICAqL1xuICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2V0IG9mIG1vZGFsaXRpZXMgdGhlIG1vZGVsIGNhbiByZXNwb25kIHdpdGguIFRvIGRpc2FibGUgYXVkaW8sIHNldCB0aGlzIHRvXG4gICAgICogW1widGV4dFwiXS5cbiAgICAgKi9cbiAgICBtb2RhbGl0aWVzPzogQXJyYXk8J3RleHQnIHwgJ2F1ZGlvJz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybWF0IG9mIG91dHB1dCBhdWRpby4gT3B0aW9ucyBhcmUgYHBjbTE2YCwgYGc3MTFfdWxhd2AsIG9yIGBnNzExX2FsYXdgLlxuICAgICAqL1xuICAgIG91dHB1dF9hdWRpb19mb3JtYXQ/OiAncGNtMTYnIHwgJ2c3MTFfdWxhdycgfCAnZzcxMV9hbGF3JztcblxuICAgIC8qKlxuICAgICAqIFNhbXBsaW5nIHRlbXBlcmF0dXJlIGZvciB0aGUgbW9kZWwsIGxpbWl0ZWQgdG8gWzAuNiwgMS4yXS4gRGVmYXVsdHMgdG8gMC44LlxuICAgICAqL1xuICAgIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogSG93IHRoZSBtb2RlbCBjaG9vc2VzIHRvb2xzLiBPcHRpb25zIGFyZSBgYXV0b2AsIGBub25lYCwgYHJlcXVpcmVkYCwgb3Igc3BlY2lmeVxuICAgICAqIGEgZnVuY3Rpb24sIGxpa2UgYHtcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifX1gLlxuICAgICAqL1xuICAgIHRvb2xfY2hvaWNlPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVG9vbHMgKGZ1bmN0aW9ucykgYXZhaWxhYmxlIHRvIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICB0b29scz86IEFycmF5PFJlc3BvbnNlLlRvb2w+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZvaWNlIHRoZSBtb2RlbCB1c2VzIHRvIHJlc3BvbmQuIFZvaWNlIGNhbm5vdCBiZSBjaGFuZ2VkIGR1cmluZyB0aGUgc2Vzc2lvblxuICAgICAqIG9uY2UgdGhlIG1vZGVsIGhhcyByZXNwb25kZWQgd2l0aCBhdWRpbyBhdCBsZWFzdCBvbmNlLiBDdXJyZW50IHZvaWNlIG9wdGlvbnMgYXJlXG4gICAgICogYGFsbG95YCwgYGFzaGAsIGBiYWxsYWRgLCBgY29yYWxgLCBgZWNob2AgYHNhZ2VgLCBgc2hpbW1lcmAgYW5kIGB2ZXJzZWAuXG4gICAgICovXG4gICAgdm9pY2U/OiAnYWxsb3knIHwgJ2FzaCcgfCAnYmFsbGFkJyB8ICdjb3JhbCcgfCAnZWNobycgfCAnc2FnZScgfCAnc2hpbW1lcicgfCAndmVyc2UnO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBSZXNwb25zZSB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBUb29sIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBmdW5jdGlvbiwgaW5jbHVkaW5nIGd1aWRhbmNlIG9uIHdoZW4gYW5kIGhvdyB0byBjYWxsIGl0LFxuICAgICAgICogYW5kIGd1aWRhbmNlIGFib3V0IHdoYXQgdG8gdGVsbCB0aGUgdXNlciB3aGVuIGNhbGxpbmcgKGlmIGFueXRoaW5nKS5cbiAgICAgICAqL1xuICAgICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAgICovXG4gICAgICBuYW1lPzogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFBhcmFtZXRlcnMgb2YgdGhlIGZ1bmN0aW9uIGluIEpTT04gU2NoZW1hLlxuICAgICAgICovXG4gICAgICBwYXJhbWV0ZXJzPzogdW5rbm93bjtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbCwgaS5lLiBgZnVuY3Rpb25gLlxuICAgICAgICovXG4gICAgICB0eXBlPzogJ2Z1bmN0aW9uJztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGEgbmV3IFJlc3BvbnNlIGlzIGNyZWF0ZWQuIFRoZSBmaXJzdCBldmVudCBvZiByZXNwb25zZSBjcmVhdGlvbixcbiAqIHdoZXJlIHRoZSByZXNwb25zZSBpcyBpbiBhbiBpbml0aWFsIHN0YXRlIG9mIGBpbl9wcm9ncmVzc2AuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VDcmVhdGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJlc3BvbnNlIHJlc291cmNlLlxuICAgKi9cbiAgcmVzcG9uc2U6IFJlYWx0aW1lUmVzcG9uc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5jcmVhdGVkYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5jcmVhdGVkJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGEgUmVzcG9uc2UgaXMgZG9uZSBzdHJlYW1pbmcuIEFsd2F5cyBlbWl0dGVkLCBubyBtYXR0ZXIgdGhlIGZpbmFsXG4gKiBzdGF0ZS4gVGhlIFJlc3BvbnNlIG9iamVjdCBpbmNsdWRlZCBpbiB0aGUgYHJlc3BvbnNlLmRvbmVgIGV2ZW50IHdpbGwgaW5jbHVkZVxuICogYWxsIG91dHB1dCBJdGVtcyBpbiB0aGUgUmVzcG9uc2UgYnV0IHdpbGwgb21pdCB0aGUgcmF3IGF1ZGlvIGRhdGEuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VEb25lRXZlbnQge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJlc3BvbnNlIHJlc291cmNlLlxuICAgKi9cbiAgcmVzcG9uc2U6IFJlYWx0aW1lUmVzcG9uc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGByZXNwb25zZS5kb25lYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS5kb25lJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIHRoZSBtb2RlbC1nZW5lcmF0ZWQgZnVuY3Rpb24gY2FsbCBhcmd1bWVudHMgYXJlIHVwZGF0ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VGdW5jdGlvbkNhbGxBcmd1bWVudHNEZWx0YUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgZnVuY3Rpb24gY2FsbC5cbiAgICovXG4gIGNhbGxfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGFyZ3VtZW50cyBkZWx0YSBhcyBhIEpTT04gc3RyaW5nLlxuICAgKi9cbiAgZGVsdGE6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBmdW5jdGlvbiBjYWxsIGl0ZW0uXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGl0ZW0gaW4gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UuZnVuY3Rpb25fY2FsbF9hcmd1bWVudHMuZGVsdGFgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLmZ1bmN0aW9uX2NhbGxfYXJndW1lbnRzLmRlbHRhJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIHRoZSBtb2RlbC1nZW5lcmF0ZWQgZnVuY3Rpb24gY2FsbCBhcmd1bWVudHMgYXJlIGRvbmUgc3RyZWFtaW5nLlxuICogQWxzbyBlbWl0dGVkIHdoZW4gYSBSZXNwb25zZSBpcyBpbnRlcnJ1cHRlZCwgaW5jb21wbGV0ZSwgb3IgY2FuY2VsbGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlRnVuY3Rpb25DYWxsQXJndW1lbnRzRG9uZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBmaW5hbCBhcmd1bWVudHMgYXMgYSBKU09OIHN0cmluZy5cbiAgICovXG4gIGFyZ3VtZW50czogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwuXG4gICAqL1xuICBjYWxsX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgZnVuY3Rpb24gY2FsbCBpdGVtLlxuICAgKi9cbiAgaXRlbV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSByZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLmZ1bmN0aW9uX2NhbGxfYXJndW1lbnRzLmRvbmVgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLmZ1bmN0aW9uX2NhbGxfYXJndW1lbnRzLmRvbmUnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBuZXcgSXRlbSBpcyBjcmVhdGVkIGR1cmluZyBSZXNwb25zZSBnZW5lcmF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlT3V0cHV0SXRlbUFkZGVkRXZlbnQge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc2VydmVyIGV2ZW50LlxuICAgKi9cbiAgZXZlbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGl0ZW0gdG8gYWRkIHRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAqL1xuICBpdGVtOiBDb252ZXJzYXRpb25JdGVtO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpdGVtIGluIHRoZSBSZXNwb25zZS5cbiAgICovXG4gIG91dHB1dF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFJlc3BvbnNlIHRvIHdoaWNoIHRoZSBpdGVtIGJlbG9uZ3MuXG4gICAqL1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2Uub3V0cHV0X2l0ZW0uYWRkZWRgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLm91dHB1dF9pdGVtLmFkZGVkJztcbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGFuIEl0ZW0gaXMgZG9uZSBzdHJlYW1pbmcuIEFsc28gZW1pdHRlZCB3aGVuIGEgUmVzcG9uc2UgaXNcbiAqIGludGVycnVwdGVkLCBpbmNvbXBsZXRlLCBvciBjYW5jZWxsZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VPdXRwdXRJdGVtRG9uZUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHNlcnZlciBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpdGVtIHRvIGFkZCB0byB0aGUgY29udmVyc2F0aW9uLlxuICAgKi9cbiAgaXRlbTogQ29udmVyc2F0aW9uSXRlbTtcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaXRlbSBpbiB0aGUgUmVzcG9uc2UuXG4gICAqL1xuICBvdXRwdXRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBSZXNwb25zZSB0byB3aGljaCB0aGUgaXRlbSBiZWxvbmdzLlxuICAgKi9cbiAgcmVzcG9uc2VfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHJlc3BvbnNlLm91dHB1dF9pdGVtLmRvbmVgLlxuICAgKi9cbiAgdHlwZTogJ3Jlc3BvbnNlLm91dHB1dF9pdGVtLmRvbmUnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gdGhlIHRleHQgdmFsdWUgb2YgYSBcInRleHRcIiBjb250ZW50IHBhcnQgaXMgdXBkYXRlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZVRleHREZWx0YUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGluIHRoZSBpdGVtJ3MgY29udGVudCBhcnJheS5cbiAgICovXG4gIGNvbnRlbnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHRleHQgZGVsdGEuXG4gICAqL1xuICBkZWx0YTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGl0ZW0uXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGl0ZW0gaW4gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UudGV4dC5kZWx0YWAuXG4gICAqL1xuICB0eXBlOiAncmVzcG9uc2UudGV4dC5kZWx0YSc7XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiB0aGUgdGV4dCB2YWx1ZSBvZiBhIFwidGV4dFwiIGNvbnRlbnQgcGFydCBpcyBkb25lIHN0cmVhbWluZy4gQWxzb1xuICogZW1pdHRlZCB3aGVuIGEgUmVzcG9uc2UgaXMgaW50ZXJydXB0ZWQsIGluY29tcGxldGUsIG9yIGNhbmNlbGxlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZVRleHREb25lRXZlbnQge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgaW4gdGhlIGl0ZW0ncyBjb250ZW50IGFycmF5LlxuICAgKi9cbiAgY29udGVudF9pbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGl0ZW0uXG4gICAqL1xuICBpdGVtX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGl0ZW0gaW4gdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgb3V0cHV0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICByZXNwb25zZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZmluYWwgdGV4dCBjb250ZW50LlxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZSwgbXVzdCBiZSBgcmVzcG9uc2UudGV4dC5kb25lYC5cbiAgICovXG4gIHR5cGU6ICdyZXNwb25zZS50ZXh0LmRvbmUnO1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBTZXNzaW9uIGlzIGNyZWF0ZWQuIEVtaXR0ZWQgYXV0b21hdGljYWxseSB3aGVuIGEgbmV3IGNvbm5lY3Rpb25cbiAqIGlzIGVzdGFibGlzaGVkIGFzIHRoZSBmaXJzdCBzZXJ2ZXIgZXZlbnQuIFRoaXMgZXZlbnQgd2lsbCBjb250YWluIHRoZSBkZWZhdWx0XG4gKiBTZXNzaW9uIGNvbmZpZ3VyYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbkNyZWF0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZWFsdGltZSBzZXNzaW9uIG9iamVjdCBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgc2Vzc2lvbjogU2Vzc2lvbnNBUEkuU2Vzc2lvbjtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHNlc3Npb24uY3JlYXRlZGAuXG4gICAqL1xuICB0eXBlOiAnc2Vzc2lvbi5jcmVhdGVkJztcbn1cblxuLyoqXG4gKiBTZW5kIHRoaXMgZXZlbnQgdG8gdXBkYXRlIHRoZSBzZXNzaW9uXHUyMDE5cyBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uIFRoZSBjbGllbnQgbWF5XG4gKiBzZW5kIHRoaXMgZXZlbnQgYXQgYW55IHRpbWUgdG8gdXBkYXRlIHRoZSBzZXNzaW9uIGNvbmZpZ3VyYXRpb24sIGFuZCBhbnkgZmllbGRcbiAqIG1heSBiZSB1cGRhdGVkIGF0IGFueSB0aW1lLCBleGNlcHQgZm9yIFwidm9pY2VcIi4gVGhlIHNlcnZlciB3aWxsIHJlc3BvbmQgd2l0aCBhXG4gKiBgc2Vzc2lvbi51cGRhdGVkYCBldmVudCB0aGF0IHNob3dzIHRoZSBmdWxsIGVmZmVjdGl2ZSBjb25maWd1cmF0aW9uLiBPbmx5IGZpZWxkc1xuICogdGhhdCBhcmUgcHJlc2VudCBhcmUgdXBkYXRlZCwgdGh1cyB0aGUgY29ycmVjdCB3YXkgdG8gY2xlYXIgYSBmaWVsZCBsaWtlXG4gKiBcImluc3RydWN0aW9uc1wiIGlzIHRvIHBhc3MgYW4gZW1wdHkgc3RyaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlc3Npb25VcGRhdGVFdmVudCB7XG4gIC8qKlxuICAgKiBSZWFsdGltZSBzZXNzaW9uIG9iamVjdCBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgc2Vzc2lvbjogU2Vzc2lvblVwZGF0ZUV2ZW50LlNlc3Npb247XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0eXBlLCBtdXN0IGJlIGBzZXNzaW9uLnVwZGF0ZWAuXG4gICAqL1xuICB0eXBlOiAnc2Vzc2lvbi51cGRhdGUnO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjbGllbnQtZ2VuZXJhdGVkIElEIHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBldmVudC5cbiAgICovXG4gIGV2ZW50X2lkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFNlc3Npb25VcGRhdGVFdmVudCB7XG4gIC8qKlxuICAgKiBSZWFsdGltZSBzZXNzaW9uIG9iamVjdCBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgUmVhbHRpbWUgbW9kZWwgdXNlZCBmb3IgdGhpcyBzZXNzaW9uLlxuICAgICAqL1xuICAgIG1vZGVsOlxuICAgICAgfCAnZ3B0LTRvLXJlYWx0aW1lLXByZXZpZXcnXG4gICAgICB8ICdncHQtNG8tcmVhbHRpbWUtcHJldmlldy0yMDI0LTEwLTAxJ1xuICAgICAgfCAnZ3B0LTRvLXJlYWx0aW1lLXByZXZpZXctMjAyNC0xMi0xNydcbiAgICAgIHwgJ2dwdC00by1taW5pLXJlYWx0aW1lLXByZXZpZXcnXG4gICAgICB8ICdncHQtNG8tbWluaS1yZWFsdGltZS1wcmV2aWV3LTIwMjQtMTItMTcnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcm1hdCBvZiBpbnB1dCBhdWRpby4gT3B0aW9ucyBhcmUgYHBjbTE2YCwgYGc3MTFfdWxhd2AsIG9yIGBnNzExX2FsYXdgLlxuICAgICAqL1xuICAgIGlucHV0X2F1ZGlvX2Zvcm1hdD86ICdwY20xNicgfCAnZzcxMV91bGF3JyB8ICdnNzExX2FsYXcnO1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgaW5wdXQgYXVkaW8gdHJhbnNjcmlwdGlvbiwgZGVmYXVsdHMgdG8gb2ZmIGFuZCBjYW4gYmUgc2V0IHRvXG4gICAgICogYG51bGxgIHRvIHR1cm4gb2ZmIG9uY2Ugb24uIElucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24gaXMgbm90IG5hdGl2ZSB0byB0aGVcbiAgICAgKiBtb2RlbCwgc2luY2UgdGhlIG1vZGVsIGNvbnN1bWVzIGF1ZGlvIGRpcmVjdGx5LiBUcmFuc2NyaXB0aW9uIHJ1bnNcbiAgICAgKiBhc3luY2hyb25vdXNseSB0aHJvdWdoIFdoaXNwZXIgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIHJvdWdoIGd1aWRhbmNlIHJhdGhlclxuICAgICAqIHRoYW4gdGhlIHJlcHJlc2VudGF0aW9uIHVuZGVyc3Rvb2QgYnkgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGlucHV0X2F1ZGlvX3RyYW5zY3JpcHRpb24/OiBTZXNzaW9uLklucHV0QXVkaW9UcmFuc2NyaXB0aW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgc3lzdGVtIGluc3RydWN0aW9ucyAoaS5lLiBzeXN0ZW0gbWVzc2FnZSkgcHJlcGVuZGVkIHRvIG1vZGVsIGNhbGxzLlxuICAgICAqIFRoaXMgZmllbGQgYWxsb3dzIHRoZSBjbGllbnQgdG8gZ3VpZGUgdGhlIG1vZGVsIG9uIGRlc2lyZWQgcmVzcG9uc2VzLiBUaGUgbW9kZWxcbiAgICAgKiBjYW4gYmUgaW5zdHJ1Y3RlZCBvbiByZXNwb25zZSBjb250ZW50IGFuZCBmb3JtYXQsIChlLmcuIFwiYmUgZXh0cmVtZWx5IHN1Y2NpbmN0XCIsXG4gICAgICogXCJhY3QgZnJpZW5kbHlcIiwgXCJoZXJlIGFyZSBleGFtcGxlcyBvZiBnb29kIHJlc3BvbnNlc1wiKSBhbmQgb24gYXVkaW8gYmVoYXZpb3JcbiAgICAgKiAoZS5nLiBcInRhbGsgcXVpY2tseVwiLCBcImluamVjdCBlbW90aW9uIGludG8geW91ciB2b2ljZVwiLCBcImxhdWdoIGZyZXF1ZW50bHlcIikuIFRoZVxuICAgICAqIGluc3RydWN0aW9ucyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gYmUgZm9sbG93ZWQgYnkgdGhlIG1vZGVsLCBidXQgdGhleSBwcm92aWRlXG4gICAgICogZ3VpZGFuY2UgdG8gdGhlIG1vZGVsIG9uIHRoZSBkZXNpcmVkIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBzZXJ2ZXIgc2V0cyBkZWZhdWx0IGluc3RydWN0aW9ucyB3aGljaCB3aWxsIGJlIHVzZWQgaWYgdGhpcyBmaWVsZFxuICAgICAqIGlzIG5vdCBzZXQgYW5kIGFyZSB2aXNpYmxlIGluIHRoZSBgc2Vzc2lvbi5jcmVhdGVkYCBldmVudCBhdCB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICogc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBpbnN0cnVjdGlvbnM/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBvdXRwdXQgdG9rZW5zIGZvciBhIHNpbmdsZSBhc3Npc3RhbnQgcmVzcG9uc2UsIGluY2x1c2l2ZSBvZlxuICAgICAqIHRvb2wgY2FsbHMuIFByb3ZpZGUgYW4gaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDQwOTYgdG8gbGltaXQgb3V0cHV0IHRva2Vucywgb3JcbiAgICAgKiBgaW5mYCBmb3IgdGhlIG1heGltdW0gYXZhaWxhYmxlIHRva2VucyBmb3IgYSBnaXZlbiBtb2RlbC4gRGVmYXVsdHMgdG8gYGluZmAuXG4gICAgICovXG4gICAgbWF4X3Jlc3BvbnNlX291dHB1dF90b2tlbnM/OiBudW1iZXIgfCAnaW5mJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZXQgb2YgbW9kYWxpdGllcyB0aGUgbW9kZWwgY2FuIHJlc3BvbmQgd2l0aC4gVG8gZGlzYWJsZSBhdWRpbywgc2V0IHRoaXMgdG9cbiAgICAgKiBbXCJ0ZXh0XCJdLlxuICAgICAqL1xuICAgIG1vZGFsaXRpZXM/OiBBcnJheTwndGV4dCcgfCAnYXVkaW8nPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb3JtYXQgb2Ygb3V0cHV0IGF1ZGlvLiBPcHRpb25zIGFyZSBgcGNtMTZgLCBgZzcxMV91bGF3YCwgb3IgYGc3MTFfYWxhd2AuXG4gICAgICovXG4gICAgb3V0cHV0X2F1ZGlvX2Zvcm1hdD86ICdwY20xNicgfCAnZzcxMV91bGF3JyB8ICdnNzExX2FsYXcnO1xuXG4gICAgLyoqXG4gICAgICogU2FtcGxpbmcgdGVtcGVyYXR1cmUgZm9yIHRoZSBtb2RlbCwgbGltaXRlZCB0byBbMC42LCAxLjJdLiBEZWZhdWx0cyB0byAwLjguXG4gICAgICovXG4gICAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBIb3cgdGhlIG1vZGVsIGNob29zZXMgdG9vbHMuIE9wdGlvbnMgYXJlIGBhdXRvYCwgYG5vbmVgLCBgcmVxdWlyZWRgLCBvciBzcGVjaWZ5XG4gICAgICogYSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB0b29sX2Nob2ljZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRvb2xzIChmdW5jdGlvbnMpIGF2YWlsYWJsZSB0byB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgdG9vbHM/OiBBcnJheTxTZXNzaW9uLlRvb2w+O1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgdHVybiBkZXRlY3Rpb24uIENhbiBiZSBzZXQgdG8gYG51bGxgIHRvIHR1cm4gb2ZmLiBTZXJ2ZXIgVkFEXG4gICAgICogbWVhbnMgdGhhdCB0aGUgbW9kZWwgd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IGFuZCBlbmQgb2Ygc3BlZWNoIGJhc2VkIG9uIGF1ZGlvXG4gICAgICogdm9sdW1lIGFuZCByZXNwb25kIGF0IHRoZSBlbmQgb2YgdXNlciBzcGVlY2guXG4gICAgICovXG4gICAgdHVybl9kZXRlY3Rpb24/OiBTZXNzaW9uLlR1cm5EZXRlY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdm9pY2UgdGhlIG1vZGVsIHVzZXMgdG8gcmVzcG9uZC4gVm9pY2UgY2Fubm90IGJlIGNoYW5nZWQgZHVyaW5nIHRoZSBzZXNzaW9uXG4gICAgICogb25jZSB0aGUgbW9kZWwgaGFzIHJlc3BvbmRlZCB3aXRoIGF1ZGlvIGF0IGxlYXN0IG9uY2UuIEN1cnJlbnQgdm9pY2Ugb3B0aW9ucyBhcmVcbiAgICAgKiBgYWxsb3lgLCBgYXNoYCwgYGJhbGxhZGAsIGBjb3JhbGAsIGBlY2hvYCBgc2FnZWAsIGBzaGltbWVyYCBhbmQgYHZlcnNlYC5cbiAgICAgKi9cbiAgICB2b2ljZT86ICdhbGxveScgfCAnYXNoJyB8ICdiYWxsYWQnIHwgJ2NvcmFsJyB8ICdlY2hvJyB8ICdzYWdlJyB8ICdzaGltbWVyJyB8ICd2ZXJzZSc7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFNlc3Npb24ge1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIGlucHV0IGF1ZGlvIHRyYW5zY3JpcHRpb24sIGRlZmF1bHRzIHRvIG9mZiBhbmQgY2FuIGJlIHNldCB0b1xuICAgICAqIGBudWxsYCB0byB0dXJuIG9mZiBvbmNlIG9uLiBJbnB1dCBhdWRpbyB0cmFuc2NyaXB0aW9uIGlzIG5vdCBuYXRpdmUgdG8gdGhlXG4gICAgICogbW9kZWwsIHNpbmNlIHRoZSBtb2RlbCBjb25zdW1lcyBhdWRpbyBkaXJlY3RseS4gVHJhbnNjcmlwdGlvbiBydW5zXG4gICAgICogYXN5bmNocm9ub3VzbHkgdGhyb3VnaCBXaGlzcGVyIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyByb3VnaCBndWlkYW5jZSByYXRoZXJcbiAgICAgKiB0aGFuIHRoZSByZXByZXNlbnRhdGlvbiB1bmRlcnN0b29kIGJ5IHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIElucHV0QXVkaW9UcmFuc2NyaXB0aW9uIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG1vZGVsIHRvIHVzZSBmb3IgdHJhbnNjcmlwdGlvbiwgYHdoaXNwZXItMWAgaXMgdGhlIG9ubHkgY3VycmVudGx5IHN1cHBvcnRlZFxuICAgICAgICogbW9kZWwuXG4gICAgICAgKi9cbiAgICAgIG1vZGVsPzogc3RyaW5nO1xuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgVG9vbCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgZnVuY3Rpb24sIGluY2x1ZGluZyBndWlkYW5jZSBvbiB3aGVuIGFuZCBob3cgdG8gY2FsbCBpdCxcbiAgICAgICAqIGFuZCBndWlkYW5jZSBhYm91dCB3aGF0IHRvIHRlbGwgdGhlIHVzZXIgd2hlbiBjYWxsaW5nIChpZiBhbnl0aGluZykuXG4gICAgICAgKi9cbiAgICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgICAqL1xuICAgICAgbmFtZT86IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBQYXJhbWV0ZXJzIG9mIHRoZSBmdW5jdGlvbiBpbiBKU09OIFNjaGVtYS5cbiAgICAgICAqL1xuICAgICAgcGFyYW1ldGVycz86IHVua25vd247XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wsIGkuZS4gYGZ1bmN0aW9uYC5cbiAgICAgICAqL1xuICAgICAgdHlwZT86ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgdHVybiBkZXRlY3Rpb24uIENhbiBiZSBzZXQgdG8gYG51bGxgIHRvIHR1cm4gb2ZmLiBTZXJ2ZXIgVkFEXG4gICAgICogbWVhbnMgdGhhdCB0aGUgbW9kZWwgd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IGFuZCBlbmQgb2Ygc3BlZWNoIGJhc2VkIG9uIGF1ZGlvXG4gICAgICogdm9sdW1lIGFuZCByZXNwb25kIGF0IHRoZSBlbmQgb2YgdXNlciBzcGVlY2guXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBUdXJuRGV0ZWN0aW9uIHtcbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciBvciBub3QgdG8gYXV0b21hdGljYWxseSBnZW5lcmF0ZSBhIHJlc3BvbnNlIHdoZW4gVkFEIGlzIGVuYWJsZWQuIGB0cnVlYFxuICAgICAgICogYnkgZGVmYXVsdC5cbiAgICAgICAqL1xuICAgICAgY3JlYXRlX3Jlc3BvbnNlPzogYm9vbGVhbjtcblxuICAgICAgLyoqXG4gICAgICAgKiBBbW91bnQgb2YgYXVkaW8gdG8gaW5jbHVkZSBiZWZvcmUgdGhlIFZBRCBkZXRlY3RlZCBzcGVlY2ggKGluIG1pbGxpc2Vjb25kcykuXG4gICAgICAgKiBEZWZhdWx0cyB0byAzMDBtcy5cbiAgICAgICAqL1xuICAgICAgcHJlZml4X3BhZGRpbmdfbXM/OiBudW1iZXI7XG5cbiAgICAgIC8qKlxuICAgICAgICogRHVyYXRpb24gb2Ygc2lsZW5jZSB0byBkZXRlY3Qgc3BlZWNoIHN0b3AgKGluIG1pbGxpc2Vjb25kcykuIERlZmF1bHRzIHRvIDUwMG1zLlxuICAgICAgICogV2l0aCBzaG9ydGVyIHZhbHVlcyB0aGUgbW9kZWwgd2lsbCByZXNwb25kIG1vcmUgcXVpY2tseSwgYnV0IG1heSBqdW1wIGluIG9uXG4gICAgICAgKiBzaG9ydCBwYXVzZXMgZnJvbSB0aGUgdXNlci5cbiAgICAgICAqL1xuICAgICAgc2lsZW5jZV9kdXJhdGlvbl9tcz86IG51bWJlcjtcblxuICAgICAgLyoqXG4gICAgICAgKiBBY3RpdmF0aW9uIHRocmVzaG9sZCBmb3IgVkFEICgwLjAgdG8gMS4wKSwgdGhpcyBkZWZhdWx0cyB0byAwLjUuIEEgaGlnaGVyXG4gICAgICAgKiB0aHJlc2hvbGQgd2lsbCByZXF1aXJlIGxvdWRlciBhdWRpbyB0byBhY3RpdmF0ZSB0aGUgbW9kZWwsIGFuZCB0aHVzIG1pZ2h0XG4gICAgICAgKiBwZXJmb3JtIGJldHRlciBpbiBub2lzeSBlbnZpcm9ubWVudHMuXG4gICAgICAgKi9cbiAgICAgIHRocmVzaG9sZD86IG51bWJlcjtcblxuICAgICAgLyoqXG4gICAgICAgKiBUeXBlIG9mIHR1cm4gZGV0ZWN0aW9uLCBvbmx5IGBzZXJ2ZXJfdmFkYCBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlxuICAgICAgICovXG4gICAgICB0eXBlPzogc3RyaW5nO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBzZXNzaW9uIGlzIHVwZGF0ZWQgd2l0aCBhIGBzZXNzaW9uLnVwZGF0ZWAgZXZlbnQsIHVubGVzcyB0aGVyZVxuICogaXMgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvblVwZGF0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzZXJ2ZXIgZXZlbnQuXG4gICAqL1xuICBldmVudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZWFsdGltZSBzZXNzaW9uIG9iamVjdCBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgc2Vzc2lvbjogU2Vzc2lvbnNBUEkuU2Vzc2lvbjtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUsIG11c3QgYmUgYHNlc3Npb24udXBkYXRlZGAuXG4gICAqL1xuICB0eXBlOiAnc2Vzc2lvbi51cGRhdGVkJztcbn1cblxuUmVhbHRpbWUuU2Vzc2lvbnMgPSBTZXNzaW9ucztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFJlYWx0aW1lIHtcbiAgZXhwb3J0IHtcbiAgICBTZXNzaW9ucyBhcyBTZXNzaW9ucyxcbiAgICB0eXBlIFNlc3Npb25zQVBJU2Vzc2lvbiBhcyBTZXNzaW9uLFxuICAgIHR5cGUgU2Vzc2lvbkNyZWF0ZVJlc3BvbnNlIGFzIFNlc3Npb25DcmVhdGVSZXNwb25zZSxcbiAgICB0eXBlIFNlc3Npb25DcmVhdGVQYXJhbXMgYXMgU2Vzc2lvbkNyZWF0ZVBhcmFtcyxcbiAgfTtcbn1cbiIsICJpbXBvcnQge1xuICBUZXh0Q29udGVudEJsb2NrLFxuICBJbWFnZUZpbGVDb250ZW50QmxvY2ssXG4gIE1lc3NhZ2UsXG4gIE1lc3NhZ2VDb250ZW50RGVsdGEsXG4gIFRleHQsXG4gIEltYWdlRmlsZSxcbiAgVGV4dERlbHRhLFxuICBNZXNzYWdlRGVsdGEsXG4gIE1lc3NhZ2VDb250ZW50LFxufSBmcm9tICcuLi9yZXNvdXJjZXMvYmV0YS90aHJlYWRzL21lc3NhZ2VzJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgeyBSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0IHtcbiAgUnVuLFxuICBSdW5DcmVhdGVQYXJhbXNCYXNlLFxuICBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gIFJ1bnMsXG4gIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zQmFzZSxcbiAgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmcsXG59IGZyb20gJy4uL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvcnVucy9ydW5zJztcbmltcG9ydCB7IHR5cGUgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9fc2hpbXMvaW5kZXgnO1xuaW1wb3J0IHsgU3RyZWFtIH0gZnJvbSAnLi4vc3RyZWFtaW5nJztcbmltcG9ydCB7IEFQSVVzZXJBYm9ydEVycm9yLCBPcGVuQUlFcnJvciB9IGZyb20gJy4uL2Vycm9yJztcbmltcG9ydCB7XG4gIEFzc2lzdGFudFN0cmVhbUV2ZW50LFxuICBNZXNzYWdlU3RyZWFtRXZlbnQsXG4gIFJ1blN0ZXBTdHJlYW1FdmVudCxcbiAgUnVuU3RyZWFtRXZlbnQsXG59IGZyb20gJy4uL3Jlc291cmNlcy9iZXRhL2Fzc2lzdGFudHMnO1xuaW1wb3J0IHsgUnVuU3RlcCwgUnVuU3RlcERlbHRhLCBUb29sQ2FsbCwgVG9vbENhbGxEZWx0YSB9IGZyb20gJy4uL3Jlc291cmNlcy9iZXRhL3RocmVhZHMvcnVucy9zdGVwcyc7XG5pbXBvcnQgeyBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlLCBUaHJlYWRzIH0gZnJvbSAnLi4vcmVzb3VyY2VzL2JldGEvdGhyZWFkcy90aHJlYWRzJztcbmltcG9ydCB7IEJhc2VFdmVudHMsIEV2ZW50U3RyZWFtIH0gZnJvbSAnLi9FdmVudFN0cmVhbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXNzaXN0YW50U3RyZWFtRXZlbnRzIGV4dGVuZHMgQmFzZUV2ZW50cyB7XG4gIHJ1bjogKHJ1bjogUnVuKSA9PiB2b2lkO1xuXG4gIC8vTmV3IGV2ZW50IHN0cnVjdHVyZVxuICBtZXNzYWdlQ3JlYXRlZDogKG1lc3NhZ2U6IE1lc3NhZ2UpID0+IHZvaWQ7XG4gIG1lc3NhZ2VEZWx0YTogKG1lc3NhZ2U6IE1lc3NhZ2VEZWx0YSwgc25hcHNob3Q6IE1lc3NhZ2UpID0+IHZvaWQ7XG4gIG1lc3NhZ2VEb25lOiAobWVzc2FnZTogTWVzc2FnZSkgPT4gdm9pZDtcblxuICBydW5TdGVwQ3JlYXRlZDogKHJ1blN0ZXA6IFJ1blN0ZXApID0+IHZvaWQ7XG4gIHJ1blN0ZXBEZWx0YTogKGRlbHRhOiBSdW5TdGVwRGVsdGEsIHNuYXBzaG90OiBSdW5zLlJ1blN0ZXApID0+IHZvaWQ7XG4gIHJ1blN0ZXBEb25lOiAocnVuU3RlcDogUnVucy5SdW5TdGVwLCBzbmFwc2hvdDogUnVucy5SdW5TdGVwKSA9PiB2b2lkO1xuXG4gIHRvb2xDYWxsQ3JlYXRlZDogKHRvb2xDYWxsOiBUb29sQ2FsbCkgPT4gdm9pZDtcbiAgdG9vbENhbGxEZWx0YTogKGRlbHRhOiBUb29sQ2FsbERlbHRhLCBzbmFwc2hvdDogVG9vbENhbGwpID0+IHZvaWQ7XG4gIHRvb2xDYWxsRG9uZTogKHRvb2xDYWxsOiBUb29sQ2FsbCkgPT4gdm9pZDtcblxuICB0ZXh0Q3JlYXRlZDogKGNvbnRlbnQ6IFRleHQpID0+IHZvaWQ7XG4gIHRleHREZWx0YTogKGRlbHRhOiBUZXh0RGVsdGEsIHNuYXBzaG90OiBUZXh0KSA9PiB2b2lkO1xuICB0ZXh0RG9uZTogKGNvbnRlbnQ6IFRleHQsIHNuYXBzaG90OiBNZXNzYWdlKSA9PiB2b2lkO1xuXG4gIC8vTm8gY3JlYXRlZCBvciBkZWx0YSBhcyB0aGlzIGlzIG5vdCBzdHJlYW1lZFxuICBpbWFnZUZpbGVEb25lOiAoY29udGVudDogSW1hZ2VGaWxlLCBzbmFwc2hvdDogTWVzc2FnZSkgPT4gdm9pZDtcblxuICBldmVudDogKGV2ZW50OiBBc3Npc3RhbnRTdHJlYW1FdmVudCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zQmFzZVN0cmVhbSA9IE9taXQ8VGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zQmFzZSwgJ3N0cmVhbSc+ICYge1xuICBzdHJlYW0/OiB0cnVlO1xufTtcblxuZXhwb3J0IHR5cGUgUnVuQ3JlYXRlUGFyYW1zQmFzZVN0cmVhbSA9IE9taXQ8UnVuQ3JlYXRlUGFyYW1zQmFzZSwgJ3N0cmVhbSc+ICYge1xuICBzdHJlYW0/OiB0cnVlO1xufTtcblxuZXhwb3J0IHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW0gPSBPbWl0PFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zQmFzZSwgJ3N0cmVhbSc+ICYge1xuICBzdHJlYW0/OiB0cnVlO1xufTtcblxuZXhwb3J0IGNsYXNzIEFzc2lzdGFudFN0cmVhbVxuICBleHRlbmRzIEV2ZW50U3RyZWFtPEFzc2lzdGFudFN0cmVhbUV2ZW50cz5cbiAgaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPEFzc2lzdGFudFN0cmVhbUV2ZW50Plxue1xuICAvL1RyYWNrIGFsbCBldmVudHMgaW4gYSBzaW5nbGUgbGlzdCBmb3IgcmVmZXJlbmNlXG4gICNldmVudHM6IEFzc2lzdGFudFN0cmVhbUV2ZW50W10gPSBbXTtcblxuICAvL1VzZWQgdG8gYWNjdW11bGF0ZSBkZWx0YXNcbiAgLy9XZSBhcmUgYWNjdW11bGF0aW5nIG1hbnkgdHlwZXMgc28gdGhlIHZhbHVlIGhlcmUgaXMgbm90IHN0cmljdFxuICAjcnVuU3RlcFNuYXBzaG90czogeyBbaWQ6IHN0cmluZ106IFJ1bnMuUnVuU3RlcCB9ID0ge307XG4gICNtZXNzYWdlU25hcHNob3RzOiB7IFtpZDogc3RyaW5nXTogTWVzc2FnZSB9ID0ge307XG4gICNtZXNzYWdlU25hcHNob3Q6IE1lc3NhZ2UgfCB1bmRlZmluZWQ7XG4gICNmaW5hbFJ1bjogUnVuIHwgdW5kZWZpbmVkO1xuICAjY3VycmVudENvbnRlbnRJbmRleDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAjY3VycmVudENvbnRlbnQ6IE1lc3NhZ2VDb250ZW50IHwgdW5kZWZpbmVkO1xuICAjY3VycmVudFRvb2xDYWxsSW5kZXg6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgI2N1cnJlbnRUb29sQ2FsbDogVG9vbENhbGwgfCB1bmRlZmluZWQ7XG5cbiAgLy9Gb3IgY3VycmVudCBzbmFwc2hvdCBtZXRob2RzXG4gICNjdXJyZW50RXZlbnQ6IEFzc2lzdGFudFN0cmVhbUV2ZW50IHwgdW5kZWZpbmVkO1xuICAjY3VycmVudFJ1blNuYXBzaG90OiBSdW4gfCB1bmRlZmluZWQ7XG4gICNjdXJyZW50UnVuU3RlcFNuYXBzaG90OiBSdW5zLlJ1blN0ZXAgfCB1bmRlZmluZWQ7XG5cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpOiBBc3luY0l0ZXJhdG9yPEFzc2lzdGFudFN0cmVhbUV2ZW50PiB7XG4gICAgY29uc3QgcHVzaFF1ZXVlOiBBc3Npc3RhbnRTdHJlYW1FdmVudFtdID0gW107XG4gICAgY29uc3QgcmVhZFF1ZXVlOiB7XG4gICAgICByZXNvbHZlOiAoY2h1bms6IEFzc2lzdGFudFN0cmVhbUV2ZW50IHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuICAgICAgcmVqZWN0OiAoZXJyOiB1bmtub3duKSA9PiB2b2lkO1xuICAgIH1bXSA9IFtdO1xuICAgIGxldCBkb25lID0gZmFsc2U7XG5cbiAgICAvL0NhdGNoIGFsbCBmb3IgcGFzc2luZyBhbG9uZyBhbGwgZXZlbnRzXG4gICAgdGhpcy5vbignZXZlbnQnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlYWRRdWV1ZS5zaGlmdCgpO1xuICAgICAgaWYgKHJlYWRlcikge1xuICAgICAgICByZWFkZXIucmVzb2x2ZShldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoUXVldWUucHVzaChldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHJlYWRRdWV1ZSkge1xuICAgICAgICByZWFkZXIucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgcmVhZFF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdhYm9ydCcsIChlcnIpID0+IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgcmVhZFF1ZXVlKSB7XG4gICAgICAgIHJlYWRlci5yZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlYWRRdWV1ZS5sZW5ndGggPSAwO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHJlYWRRdWV1ZSkge1xuICAgICAgICByZWFkZXIucmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBhc3luYyAoKTogUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxBc3Npc3RhbnRTdHJlYW1FdmVudD4+ID0+IHtcbiAgICAgICAgaWYgKCFwdXNoUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPEFzc2lzdGFudFN0cmVhbUV2ZW50IHwgdW5kZWZpbmVkPigocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgICAgICAgcmVhZFF1ZXVlLnB1c2goeyByZXNvbHZlLCByZWplY3QgfSksXG4gICAgICAgICAgKS50aGVuKChjaHVuaykgPT4gKGNodW5rID8geyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0gOiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNodW5rID0gcHVzaFF1ZXVlLnNoaWZ0KCkhO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH07XG4gICAgICB9LFxuICAgICAgcmV0dXJuOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRoaXMuYWJvcnQoKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGZyb21SZWFkYWJsZVN0cmVhbShzdHJlYW06IFJlYWRhYmxlU3RyZWFtKTogQXNzaXN0YW50U3RyZWFtIHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgQXNzaXN0YW50U3RyZWFtKCk7XG4gICAgcnVubmVyLl9ydW4oKCkgPT4gcnVubmVyLl9mcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfZnJvbVJlYWRhYmxlU3RyZWFtKFxuICAgIHJlYWRhYmxlU3RyZWFtOiBSZWFkYWJsZVN0cmVhbSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxSdW4+IHtcbiAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXMuY29udHJvbGxlci5hYm9ydCgpKTtcbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdGVkKCk7XG4gICAgY29uc3Qgc3RyZWFtID0gU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbTxBc3Npc3RhbnRTdHJlYW1FdmVudD4ocmVhZGFibGVTdHJlYW0sIHRoaXMuY29udHJvbGxlcik7XG4gICAgZm9yIGF3YWl0IChjb25zdCBldmVudCBvZiBzdHJlYW0pIHtcbiAgICAgIHRoaXMuI2FkZEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5jb250cm9sbGVyLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hZGRSdW4odGhpcy4jZW5kUmVxdWVzdCgpKTtcbiAgfVxuXG4gIHRvUmVhZGFibGVTdHJlYW0oKTogUmVhZGFibGVTdHJlYW0ge1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBTdHJlYW0odGhpc1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0uYmluZCh0aGlzKSwgdGhpcy5jb250cm9sbGVyKTtcbiAgICByZXR1cm4gc3RyZWFtLnRvUmVhZGFibGVTdHJlYW0oKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVUb29sQXNzaXN0YW50U3RyZWFtKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBydW5zOiBSdW5zLFxuICAgIHBhcmFtczogUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW0sXG4gICAgb3B0aW9uczogUmVxdWVzdE9wdGlvbnMgfCB1bmRlZmluZWQsXG4gICk6IEFzc2lzdGFudFN0cmVhbSB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IEFzc2lzdGFudFN0cmVhbSgpO1xuICAgIHJ1bm5lci5fcnVuKCgpID0+XG4gICAgICBydW5uZXIuX3J1blRvb2xBc3Npc3RhbnRTdHJlYW0odGhyZWFkSWQsIHJ1bklkLCBydW5zLCBwYXJhbXMsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtSGVscGVyLU1ldGhvZCc6ICdzdHJlYW0nIH0sXG4gICAgICB9KSxcbiAgICApO1xuICAgIHJldHVybiBydW5uZXI7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX2NyZWF0ZVRvb2xBc3Npc3RhbnRTdHJlYW0oXG4gICAgcnVuOiBSdW5zLFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBwYXJhbXM6IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBQcm9taXNlPFJ1bj4ge1xuICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbDtcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gdGhpcy5jb250cm9sbGVyLmFib3J0KCkpO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHk6IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtaW5nID0geyAuLi5wYXJhbXMsIHN0cmVhbTogdHJ1ZSB9O1xuICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHJ1bi5zdWJtaXRUb29sT3V0cHV0cyh0aHJlYWRJZCwgcnVuSWQsIGJvZHksIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBzaWduYWw6IHRoaXMuY29udHJvbGxlci5zaWduYWwsXG4gICAgfSk7XG5cbiAgICB0aGlzLl9jb25uZWN0ZWQoKTtcblxuICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2Ygc3RyZWFtKSB7XG4gICAgICB0aGlzLiNhZGRFdmVudChldmVudCk7XG4gICAgfVxuICAgIGlmIChzdHJlYW0uY29udHJvbGxlci5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9hZGRSdW4odGhpcy4jZW5kUmVxdWVzdCgpKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVUaHJlYWRBc3Npc3RhbnRTdHJlYW0oXG4gICAgcGFyYW1zOiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlU3RyZWFtLFxuICAgIHRocmVhZDogVGhyZWFkcyxcbiAgICBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFzc2lzdGFudFN0cmVhbSB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IEFzc2lzdGFudFN0cmVhbSgpO1xuICAgIHJ1bm5lci5fcnVuKCgpID0+XG4gICAgICBydW5uZXIuX3RocmVhZEFzc2lzdGFudFN0cmVhbShwYXJhbXMsIHRocmVhZCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3N0cmVhbScgfSxcbiAgICAgIH0pLFxuICAgICk7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVBc3Npc3RhbnRTdHJlYW0oXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5zOiBSdW5zLFxuICAgIHBhcmFtczogUnVuQ3JlYXRlUGFyYW1zQmFzZVN0cmVhbSxcbiAgICBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFzc2lzdGFudFN0cmVhbSB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IEFzc2lzdGFudFN0cmVhbSgpO1xuICAgIHJ1bm5lci5fcnVuKCgpID0+XG4gICAgICBydW5uZXIuX3J1bkFzc2lzdGFudFN0cmVhbSh0aHJlYWRJZCwgcnVucywgcGFyYW1zLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAnc3RyZWFtJyB9LFxuICAgICAgfSksXG4gICAgKTtcbiAgICByZXR1cm4gcnVubmVyO1xuICB9XG5cbiAgY3VycmVudEV2ZW50KCk6IEFzc2lzdGFudFN0cmVhbUV2ZW50IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudEV2ZW50O1xuICB9XG5cbiAgY3VycmVudFJ1bigpOiBSdW4gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50UnVuU25hcHNob3Q7XG4gIH1cblxuICBjdXJyZW50TWVzc2FnZVNuYXBzaG90KCk6IE1lc3NhZ2UgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLiNtZXNzYWdlU25hcHNob3Q7XG4gIH1cblxuICBjdXJyZW50UnVuU3RlcFNuYXBzaG90KCk6IFJ1bnMuUnVuU3RlcCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRSdW5TdGVwU25hcHNob3Q7XG4gIH1cblxuICBhc3luYyBmaW5hbFJ1blN0ZXBzKCk6IFByb21pc2U8UnVucy5SdW5TdGVwW10+IHtcbiAgICBhd2FpdCB0aGlzLmRvbmUoKTtcblxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuI3J1blN0ZXBTbmFwc2hvdHMpO1xuICB9XG5cbiAgYXN5bmMgZmluYWxNZXNzYWdlcygpOiBQcm9taXNlPE1lc3NhZ2VbXT4ge1xuICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy4jbWVzc2FnZVNuYXBzaG90cyk7XG4gIH1cblxuICBhc3luYyBmaW5hbFJ1bigpOiBQcm9taXNlPFJ1bj4ge1xuICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgIGlmICghdGhpcy4jZmluYWxSdW4pIHRocm93IEVycm9yKCdGaW5hbCBydW4gd2FzIG5vdCByZWNlaXZlZC4nKTtcblxuICAgIHJldHVybiB0aGlzLiNmaW5hbFJ1bjtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfY3JlYXRlVGhyZWFkQXNzaXN0YW50U3RyZWFtKFxuICAgIHRocmVhZDogVGhyZWFkcyxcbiAgICBwYXJhbXM6IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc0Jhc2UsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IFByb21pc2U8UnVuPiB7XG4gICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgIGlmIChzaWduYWwpIHtcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keTogUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nID0geyAuLi5wYXJhbXMsIHN0cmVhbTogdHJ1ZSB9O1xuICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHRocmVhZC5jcmVhdGVBbmRSdW4oYm9keSwgeyAuLi5vcHRpb25zLCBzaWduYWw6IHRoaXMuY29udHJvbGxlci5zaWduYWwgfSk7XG5cbiAgICB0aGlzLl9jb25uZWN0ZWQoKTtcblxuICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2Ygc3RyZWFtKSB7XG4gICAgICB0aGlzLiNhZGRFdmVudChldmVudCk7XG4gICAgfVxuICAgIGlmIChzdHJlYW0uY29udHJvbGxlci5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9hZGRSdW4odGhpcy4jZW5kUmVxdWVzdCgpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfY3JlYXRlQXNzaXN0YW50U3RyZWFtKFxuICAgIHJ1bjogUnVucyxcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHBhcmFtczogUnVuQ3JlYXRlUGFyYW1zQmFzZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxSdW4+IHtcbiAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXMuY29udHJvbGxlci5hYm9ydCgpKTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5OiBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSB7IC4uLnBhcmFtcywgc3RyZWFtOiB0cnVlIH07XG4gICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgcnVuLmNyZWF0ZSh0aHJlYWRJZCwgYm9keSwgeyAuLi5vcHRpb25zLCBzaWduYWw6IHRoaXMuY29udHJvbGxlci5zaWduYWwgfSk7XG5cbiAgICB0aGlzLl9jb25uZWN0ZWQoKTtcblxuICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2Ygc3RyZWFtKSB7XG4gICAgICB0aGlzLiNhZGRFdmVudChldmVudCk7XG4gICAgfVxuICAgIGlmIChzdHJlYW0uY29udHJvbGxlci5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9hZGRSdW4odGhpcy4jZW5kUmVxdWVzdCgpKTtcbiAgfVxuXG4gICNhZGRFdmVudChldmVudDogQXNzaXN0YW50U3RyZWFtRXZlbnQpIHtcbiAgICBpZiAodGhpcy5lbmRlZCkgcmV0dXJuO1xuXG4gICAgdGhpcy4jY3VycmVudEV2ZW50ID0gZXZlbnQ7XG5cbiAgICB0aGlzLiNoYW5kbGVFdmVudChldmVudCk7XG5cbiAgICBzd2l0Y2ggKGV2ZW50LmV2ZW50KSB7XG4gICAgICBjYXNlICd0aHJlYWQuY3JlYXRlZCc6XG4gICAgICAgIC8vTm8gYWN0aW9uIG9uIHRoaXMgZXZlbnQuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0aHJlYWQucnVuLmNyZWF0ZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5xdWV1ZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5pbl9wcm9ncmVzcyc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnJlcXVpcmVzX2FjdGlvbic6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmNvbXBsZXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmZhaWxlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmNhbmNlbGxpbmcnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jYW5jZWxsZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5leHBpcmVkJzpcbiAgICAgICAgdGhpcy4jaGFuZGxlUnVuKGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jcmVhdGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5pbl9wcm9ncmVzcyc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZGVsdGEnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmNvbXBsZXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZmFpbGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jYW5jZWxsZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmV4cGlyZWQnOlxuICAgICAgICB0aGlzLiNoYW5kbGVSdW5TdGVwKGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmNyZWF0ZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuaW5fcHJvZ3Jlc3MnOlxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuZGVsdGEnOlxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuY29tcGxldGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmluY29tcGxldGUnOlxuICAgICAgICB0aGlzLiNoYW5kbGVNZXNzYWdlKGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgLy9UaGlzIGlzIGluY2x1ZGVkIGZvciBjb21wbGV0ZW5lc3MsIGJ1dCBlcnJvcnMgYXJlIHByb2Nlc3NlZCBpbiB0aGUgU1NFIGV2ZW50IHByb2Nlc3Npbmcgc28gdGhpcyBzaG91bGQgbm90IG9jY3VyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRW5jb3VudGVyZWQgYW4gZXJyb3IgZXZlbnQgaW4gZXZlbnQgcHJvY2Vzc2luZyAtIGVycm9ycyBzaG91bGQgYmUgcHJvY2Vzc2VkIGVhcmxpZXInLFxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gICNlbmRSZXF1ZXN0KCk6IFJ1biB7XG4gICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgc3RyZWFtIGhhcyBlbmRlZCwgdGhpcyBzaG91bGRuJ3QgaGFwcGVuYCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLiNmaW5hbFJ1bikgdGhyb3cgRXJyb3IoJ0ZpbmFsIHJ1biBoYXMgbm90IGJlZW4gcmVjZWl2ZWQnKTtcblxuICAgIHJldHVybiB0aGlzLiNmaW5hbFJ1bjtcbiAgfVxuXG4gICNoYW5kbGVNZXNzYWdlKHRoaXM6IEFzc2lzdGFudFN0cmVhbSwgZXZlbnQ6IE1lc3NhZ2VTdHJlYW1FdmVudCkge1xuICAgIGNvbnN0IFthY2N1bXVsYXRlZE1lc3NhZ2UsIG5ld0NvbnRlbnRdID0gdGhpcy4jYWNjdW11bGF0ZU1lc3NhZ2UoZXZlbnQsIHRoaXMuI21lc3NhZ2VTbmFwc2hvdCk7XG4gICAgdGhpcy4jbWVzc2FnZVNuYXBzaG90ID0gYWNjdW11bGF0ZWRNZXNzYWdlO1xuICAgIHRoaXMuI21lc3NhZ2VTbmFwc2hvdHNbYWNjdW11bGF0ZWRNZXNzYWdlLmlkXSA9IGFjY3VtdWxhdGVkTWVzc2FnZTtcblxuICAgIGZvciAoY29uc3QgY29udGVudCBvZiBuZXdDb250ZW50KSB7XG4gICAgICBjb25zdCBzbmFwc2hvdENvbnRlbnQgPSBhY2N1bXVsYXRlZE1lc3NhZ2UuY29udGVudFtjb250ZW50LmluZGV4XTtcbiAgICAgIGlmIChzbmFwc2hvdENvbnRlbnQ/LnR5cGUgPT0gJ3RleHQnKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJ3RleHRDcmVhdGVkJywgc25hcHNob3RDb250ZW50LnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAoZXZlbnQuZXZlbnQpIHtcbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmNyZWF0ZWQnOlxuICAgICAgICB0aGlzLl9lbWl0KCdtZXNzYWdlQ3JlYXRlZCcsIGV2ZW50LmRhdGEpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuaW5fcHJvZ3Jlc3MnOlxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuZGVsdGEnOlxuICAgICAgICB0aGlzLl9lbWl0KCdtZXNzYWdlRGVsdGEnLCBldmVudC5kYXRhLmRlbHRhLCBhY2N1bXVsYXRlZE1lc3NhZ2UpO1xuXG4gICAgICAgIGlmIChldmVudC5kYXRhLmRlbHRhLmNvbnRlbnQpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRlbnQgb2YgZXZlbnQuZGF0YS5kZWx0YS5jb250ZW50KSB7XG4gICAgICAgICAgICAvL0lmIGl0IGlzIHRleHQgZGVsdGEsIGVtaXQgYSB0ZXh0IGRlbHRhIGV2ZW50XG4gICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09ICd0ZXh0JyAmJiBjb250ZW50LnRleHQpIHtcbiAgICAgICAgICAgICAgbGV0IHRleHREZWx0YSA9IGNvbnRlbnQudGV4dDtcbiAgICAgICAgICAgICAgbGV0IHNuYXBzaG90ID0gYWNjdW11bGF0ZWRNZXNzYWdlLmNvbnRlbnRbY29udGVudC5pbmRleF07XG4gICAgICAgICAgICAgIGlmIChzbmFwc2hvdCAmJiBzbmFwc2hvdC50eXBlID09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3RleHREZWx0YScsIHRleHREZWx0YSwgc25hcHNob3QudGV4dCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1RoZSBzbmFwc2hvdCBhc3NvY2lhdGVkIHdpdGggdGhpcyB0ZXh0IGRlbHRhIGlzIG5vdCB0ZXh0IG9yIG1pc3NpbmcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29udGVudC5pbmRleCAhPSB0aGlzLiNjdXJyZW50Q29udGVudEluZGV4KSB7XG4gICAgICAgICAgICAgIC8vU2VlIGlmIHdlIGhhdmUgaW4gcHJvZ3Jlc3MgY29udGVudFxuICAgICAgICAgICAgICBpZiAodGhpcy4jY3VycmVudENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuI2N1cnJlbnRDb250ZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCd0ZXh0RG9uZScsIHRoaXMuI2N1cnJlbnRDb250ZW50LnRleHQsIHRoaXMuI21lc3NhZ2VTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnaW1hZ2VfZmlsZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2ltYWdlRmlsZURvbmUnLCB0aGlzLiNjdXJyZW50Q29udGVudC5pbWFnZV9maWxlLCB0aGlzLiNtZXNzYWdlU25hcHNob3QpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLiNjdXJyZW50Q29udGVudEluZGV4ID0gY29udGVudC5pbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy4jY3VycmVudENvbnRlbnQgPSBhY2N1bXVsYXRlZE1lc3NhZ2UuY29udGVudFtjb250ZW50LmluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuY29tcGxldGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmluY29tcGxldGUnOlxuICAgICAgICAvL1dlIGVtaXQgdGhlIGxhdGVzdCBjb250ZW50IHdlIHdlcmUgd29ya2luZyBvbiBvbiBjb21wbGV0aW9uIChpbmNsdWRpbmcgaW5jb21wbGV0ZSlcbiAgICAgICAgaWYgKHRoaXMuI2N1cnJlbnRDb250ZW50SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb250ZW50ID0gZXZlbnQuZGF0YS5jb250ZW50W3RoaXMuI2N1cnJlbnRDb250ZW50SW5kZXhdO1xuICAgICAgICAgIGlmIChjdXJyZW50Q29udGVudCkge1xuICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50Q29udGVudC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2ltYWdlX2ZpbGUnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2ltYWdlRmlsZURvbmUnLCBjdXJyZW50Q29udGVudC5pbWFnZV9maWxlLCB0aGlzLiNtZXNzYWdlU25hcHNob3QpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCd0ZXh0RG9uZScsIGN1cnJlbnRDb250ZW50LnRleHQsIHRoaXMuI21lc3NhZ2VTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuI21lc3NhZ2VTbmFwc2hvdCkge1xuICAgICAgICAgIHRoaXMuX2VtaXQoJ21lc3NhZ2VEb25lJywgZXZlbnQuZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNtZXNzYWdlU25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgI2hhbmRsZVJ1blN0ZXAodGhpczogQXNzaXN0YW50U3RyZWFtLCBldmVudDogUnVuU3RlcFN0cmVhbUV2ZW50KSB7XG4gICAgY29uc3QgYWNjdW11bGF0ZWRSdW5TdGVwID0gdGhpcy4jYWNjdW11bGF0ZVJ1blN0ZXAoZXZlbnQpO1xuICAgIHRoaXMuI2N1cnJlbnRSdW5TdGVwU25hcHNob3QgPSBhY2N1bXVsYXRlZFJ1blN0ZXA7XG5cbiAgICBzd2l0Y2ggKGV2ZW50LmV2ZW50KSB7XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY3JlYXRlZCc6XG4gICAgICAgIHRoaXMuX2VtaXQoJ3J1blN0ZXBDcmVhdGVkJywgZXZlbnQuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmRlbHRhJzpcbiAgICAgICAgY29uc3QgZGVsdGEgPSBldmVudC5kYXRhLmRlbHRhO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZGVsdGEuc3RlcF9kZXRhaWxzICYmXG4gICAgICAgICAgZGVsdGEuc3RlcF9kZXRhaWxzLnR5cGUgPT0gJ3Rvb2xfY2FsbHMnICYmXG4gICAgICAgICAgZGVsdGEuc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHMgJiZcbiAgICAgICAgICBhY2N1bXVsYXRlZFJ1blN0ZXAuc3RlcF9kZXRhaWxzLnR5cGUgPT0gJ3Rvb2xfY2FsbHMnXG4gICAgICAgICkge1xuICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgZGVsdGEuc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgIGlmICh0b29sQ2FsbC5pbmRleCA9PSB0aGlzLiNjdXJyZW50VG9vbENhbGxJbmRleCkge1xuICAgICAgICAgICAgICB0aGlzLl9lbWl0KFxuICAgICAgICAgICAgICAgICd0b29sQ2FsbERlbHRhJyxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbCxcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZFJ1blN0ZXAuc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHNbdG9vbENhbGwuaW5kZXhdIGFzIFRvb2xDYWxsLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuI2N1cnJlbnRUb29sQ2FsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3Rvb2xDYWxsRG9uZScsIHRoaXMuI2N1cnJlbnRUb29sQ2FsbCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLiNjdXJyZW50VG9vbENhbGxJbmRleCA9IHRvb2xDYWxsLmluZGV4O1xuICAgICAgICAgICAgICB0aGlzLiNjdXJyZW50VG9vbENhbGwgPSBhY2N1bXVsYXRlZFJ1blN0ZXAuc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHNbdG9vbENhbGwuaW5kZXhdO1xuICAgICAgICAgICAgICBpZiAodGhpcy4jY3VycmVudFRvb2xDYWxsKSB0aGlzLl9lbWl0KCd0b29sQ2FsbENyZWF0ZWQnLCB0aGlzLiNjdXJyZW50VG9vbENhbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VtaXQoJ3J1blN0ZXBEZWx0YScsIGV2ZW50LmRhdGEuZGVsdGEsIGFjY3VtdWxhdGVkUnVuU3RlcCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmNvbXBsZXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZmFpbGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jYW5jZWxsZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmV4cGlyZWQnOlxuICAgICAgICB0aGlzLiNjdXJyZW50UnVuU3RlcFNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gZXZlbnQuZGF0YS5zdGVwX2RldGFpbHM7XG4gICAgICAgIGlmIChkZXRhaWxzLnR5cGUgPT0gJ3Rvb2xfY2FsbHMnKSB7XG4gICAgICAgICAgaWYgKHRoaXMuI2N1cnJlbnRUb29sQ2FsbCkge1xuICAgICAgICAgICAgdGhpcy5fZW1pdCgndG9vbENhbGxEb25lJywgdGhpcy4jY3VycmVudFRvb2xDYWxsIGFzIFRvb2xDYWxsKTtcbiAgICAgICAgICAgIHRoaXMuI2N1cnJlbnRUb29sQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW1pdCgncnVuU3RlcERvbmUnLCBldmVudC5kYXRhLCBhY2N1bXVsYXRlZFJ1blN0ZXApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5pbl9wcm9ncmVzcyc6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gICNoYW5kbGVFdmVudCh0aGlzOiBBc3Npc3RhbnRTdHJlYW0sIGV2ZW50OiBBc3Npc3RhbnRTdHJlYW1FdmVudCkge1xuICAgIHRoaXMuI2V2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICB0aGlzLl9lbWl0KCdldmVudCcsIGV2ZW50KTtcbiAgfVxuXG4gICNhY2N1bXVsYXRlUnVuU3RlcChldmVudDogUnVuU3RlcFN0cmVhbUV2ZW50KTogUnVucy5SdW5TdGVwIHtcbiAgICBzd2l0Y2ggKGV2ZW50LmV2ZW50KSB7XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY3JlYXRlZCc6XG4gICAgICAgIHRoaXMuI3J1blN0ZXBTbmFwc2hvdHNbZXZlbnQuZGF0YS5pZF0gPSBldmVudC5kYXRhO1xuICAgICAgICByZXR1cm4gZXZlbnQuZGF0YTtcblxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmRlbHRhJzpcbiAgICAgICAgbGV0IHNuYXBzaG90ID0gdGhpcy4jcnVuU3RlcFNuYXBzaG90c1tldmVudC5kYXRhLmlkXSBhcyBSdW5zLlJ1blN0ZXA7XG4gICAgICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignUmVjZWl2ZWQgYSBSdW5TdGVwRGVsdGEgYmVmb3JlIGNyZWF0aW9uIG9mIGEgc25hcHNob3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkYXRhID0gZXZlbnQuZGF0YTtcblxuICAgICAgICBpZiAoZGF0YS5kZWx0YSkge1xuICAgICAgICAgIGNvbnN0IGFjY3VtdWxhdGVkID0gQXNzaXN0YW50U3RyZWFtLmFjY3VtdWxhdGVEZWx0YShzbmFwc2hvdCwgZGF0YS5kZWx0YSkgYXMgUnVucy5SdW5TdGVwO1xuICAgICAgICAgIHRoaXMuI3J1blN0ZXBTbmFwc2hvdHNbZXZlbnQuZGF0YS5pZF0gPSBhY2N1bXVsYXRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLiNydW5TdGVwU25hcHNob3RzW2V2ZW50LmRhdGEuaWRdIGFzIFJ1bnMuUnVuU3RlcDtcblxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmNvbXBsZXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZmFpbGVkJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jYW5jZWxsZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmV4cGlyZWQnOlxuICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmluX3Byb2dyZXNzJzpcbiAgICAgICAgdGhpcy4jcnVuU3RlcFNuYXBzaG90c1tldmVudC5kYXRhLmlkXSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICh0aGlzLiNydW5TdGVwU25hcHNob3RzW2V2ZW50LmRhdGEuaWRdKSByZXR1cm4gdGhpcy4jcnVuU3RlcFNuYXBzaG90c1tldmVudC5kYXRhLmlkXSBhcyBSdW5zLlJ1blN0ZXA7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBzbmFwc2hvdCBhdmFpbGFibGUnKTtcbiAgfVxuXG4gICNhY2N1bXVsYXRlTWVzc2FnZShcbiAgICBldmVudDogQXNzaXN0YW50U3RyZWFtRXZlbnQsXG4gICAgc25hcHNob3Q6IE1lc3NhZ2UgfCB1bmRlZmluZWQsXG4gICk6IFtNZXNzYWdlLCBNZXNzYWdlQ29udGVudERlbHRhW11dIHtcbiAgICBsZXQgbmV3Q29udGVudDogTWVzc2FnZUNvbnRlbnREZWx0YVtdID0gW107XG5cbiAgICBzd2l0Y2ggKGV2ZW50LmV2ZW50KSB7XG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5jcmVhdGVkJzpcbiAgICAgICAgLy9PbiBjcmVhdGlvbiB0aGUgc25hcHNob3QgaXMganVzdCB0aGUgaW5pdGlhbCBtZXNzYWdlXG4gICAgICAgIHJldHVybiBbZXZlbnQuZGF0YSwgbmV3Q29udGVudF07XG5cbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmRlbHRhJzpcbiAgICAgICAgaWYgKCFzbmFwc2hvdCkge1xuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgJ1JlY2VpdmVkIGEgZGVsdGEgd2l0aCBubyBleGlzdGluZyBzbmFwc2hvdCAodGhlcmUgc2hvdWxkIGJlIG9uZSBmcm9tIG1lc3NhZ2UgY3JlYXRpb24pJyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRhdGEgPSBldmVudC5kYXRhO1xuXG4gICAgICAgIC8vSWYgdGhpcyBkZWx0YSBkb2VzIG5vdCBoYXZlIGNvbnRlbnQsIG5vdGhpbmcgdG8gcHJvY2Vzc1xuICAgICAgICBpZiAoZGF0YS5kZWx0YS5jb250ZW50KSB7XG4gICAgICAgICAgZm9yIChjb25zdCBjb250ZW50RWxlbWVudCBvZiBkYXRhLmRlbHRhLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmIChjb250ZW50RWxlbWVudC5pbmRleCBpbiBzbmFwc2hvdC5jb250ZW50KSB7XG4gICAgICAgICAgICAgIGxldCBjdXJyZW50Q29udGVudCA9IHNuYXBzaG90LmNvbnRlbnRbY29udGVudEVsZW1lbnQuaW5kZXhdO1xuICAgICAgICAgICAgICBzbmFwc2hvdC5jb250ZW50W2NvbnRlbnRFbGVtZW50LmluZGV4XSA9IHRoaXMuI2FjY3VtdWxhdGVDb250ZW50KFxuICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZW50LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc25hcHNob3QuY29udGVudFtjb250ZW50RWxlbWVudC5pbmRleF0gPSBjb250ZW50RWxlbWVudCBhcyBNZXNzYWdlQ29udGVudDtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5ldyBlbGVtZW50XG4gICAgICAgICAgICAgIG5ld0NvbnRlbnQucHVzaChjb250ZW50RWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtzbmFwc2hvdCwgbmV3Q29udGVudF07XG5cbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmluX3Byb2dyZXNzJzpcbiAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmNvbXBsZXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5pbmNvbXBsZXRlJzpcbiAgICAgICAgLy9ObyBjaGFuZ2VzIG9uIG90aGVyIHRocmVhZCBldmVudHNcbiAgICAgICAgaWYgKHNuYXBzaG90KSB7XG4gICAgICAgICAgcmV0dXJuIFtzbmFwc2hvdCwgbmV3Q29udGVudF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlY2VpdmVkIHRocmVhZCBtZXNzYWdlIGV2ZW50IHdpdGggbm8gZXhpc3Rpbmcgc25hcHNob3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBFcnJvcignVHJpZWQgdG8gYWNjdW11bGF0ZSBhIG5vbi1tZXNzYWdlIGV2ZW50Jyk7XG4gIH1cblxuICAjYWNjdW11bGF0ZUNvbnRlbnQoXG4gICAgY29udGVudEVsZW1lbnQ6IE1lc3NhZ2VDb250ZW50RGVsdGEsXG4gICAgY3VycmVudENvbnRlbnQ6IE1lc3NhZ2VDb250ZW50IHwgdW5kZWZpbmVkLFxuICApOiBUZXh0Q29udGVudEJsb2NrIHwgSW1hZ2VGaWxlQ29udGVudEJsb2NrIHtcbiAgICByZXR1cm4gQXNzaXN0YW50U3RyZWFtLmFjY3VtdWxhdGVEZWx0YShjdXJyZW50Q29udGVudCBhcyB1bmtub3duIGFzIFJlY29yZDxhbnksIGFueT4sIGNvbnRlbnRFbGVtZW50KSBhc1xuICAgICAgfCBUZXh0Q29udGVudEJsb2NrXG4gICAgICB8IEltYWdlRmlsZUNvbnRlbnRCbG9jaztcbiAgfVxuXG4gIHN0YXRpYyBhY2N1bXVsYXRlRGVsdGEoYWNjOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBkZWx0YTogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgIGZvciAoY29uc3QgW2tleSwgZGVsdGFWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGVsdGEpKSB7XG4gICAgICBpZiAoIWFjYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGFjY1trZXldID0gZGVsdGFWYWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBhY2NWYWx1ZSA9IGFjY1trZXldO1xuICAgICAgaWYgKGFjY1ZhbHVlID09PSBudWxsIHx8IGFjY1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWNjW2tleV0gPSBkZWx0YVZhbHVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgZG9uJ3QgYWNjdW11bGF0ZSB0aGVzZSBzcGVjaWFsIHByb3BlcnRpZXNcbiAgICAgIGlmIChrZXkgPT09ICdpbmRleCcgfHwga2V5ID09PSAndHlwZScpIHtcbiAgICAgICAgYWNjW2tleV0gPSBkZWx0YVZhbHVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVHlwZS1zcGVjaWZpYyBhY2N1bXVsYXRpb24gbG9naWNcbiAgICAgIGlmICh0eXBlb2YgYWNjVmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBkZWx0YVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBhY2NWYWx1ZSArPSBkZWx0YVZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYWNjVmFsdWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBkZWx0YVZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBhY2NWYWx1ZSArPSBkZWx0YVZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChDb3JlLmlzT2JqKGFjY1ZhbHVlKSAmJiBDb3JlLmlzT2JqKGRlbHRhVmFsdWUpKSB7XG4gICAgICAgIGFjY1ZhbHVlID0gdGhpcy5hY2N1bXVsYXRlRGVsdGEoYWNjVmFsdWUgYXMgUmVjb3JkPHN0cmluZywgYW55PiwgZGVsdGFWYWx1ZSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+KTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhY2NWYWx1ZSkgJiYgQXJyYXkuaXNBcnJheShkZWx0YVZhbHVlKSkge1xuICAgICAgICBpZiAoYWNjVmFsdWUuZXZlcnkoKHgpID0+IHR5cGVvZiB4ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgeCA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgYWNjVmFsdWUucHVzaCguLi5kZWx0YVZhbHVlKTsgLy8gVXNlIHNwcmVhZCBzeW50YXggZm9yIGVmZmljaWVudCBhZGRpdGlvblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBkZWx0YUVudHJ5IG9mIGRlbHRhVmFsdWUpIHtcbiAgICAgICAgICBpZiAoIUNvcmUuaXNPYmooZGVsdGFFbnRyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXJyYXkgZGVsdGEgZW50cnkgdG8gYmUgYW4gb2JqZWN0IGJ1dCBnb3Q6ICR7ZGVsdGFFbnRyeX1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpbmRleCA9IGRlbHRhRW50cnlbJ2luZGV4J107XG4gICAgICAgICAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZGVsdGFFbnRyeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGFycmF5IGRlbHRhIGVudHJ5IHRvIGhhdmUgYW4gYGluZGV4YCBwcm9wZXJ0eScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFycmF5IGRlbHRhIGVudHJ5IFxcYGluZGV4XFxgIHByb3BlcnR5IHRvIGJlIGEgbnVtYmVyIGJ1dCBnb3QgJHtpbmRleH1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBhY2NFbnRyeSA9IGFjY1ZhbHVlW2luZGV4XTtcbiAgICAgICAgICBpZiAoYWNjRW50cnkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYWNjVmFsdWUucHVzaChkZWx0YUVudHJ5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjVmFsdWVbaW5kZXhdID0gdGhpcy5hY2N1bXVsYXRlRGVsdGEoYWNjRW50cnksIGRlbHRhRW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKGBVbmhhbmRsZWQgcmVjb3JkIHR5cGU6ICR7a2V5fSwgZGVsdGFWYWx1ZTogJHtkZWx0YVZhbHVlfSwgYWNjVmFsdWU6ICR7YWNjVmFsdWV9YCk7XG4gICAgICB9XG4gICAgICBhY2Nba2V5XSA9IGFjY1ZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH1cblxuICAjaGFuZGxlUnVuKHRoaXM6IEFzc2lzdGFudFN0cmVhbSwgZXZlbnQ6IFJ1blN0cmVhbUV2ZW50KSB7XG4gICAgdGhpcy4jY3VycmVudFJ1blNuYXBzaG90ID0gZXZlbnQuZGF0YTtcbiAgICBzd2l0Y2ggKGV2ZW50LmV2ZW50KSB7XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmNyZWF0ZWQnOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4ucXVldWVkJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmluX3Byb2dyZXNzJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aHJlYWQucnVuLnJlcXVpcmVzX2FjdGlvbic6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmNhbmNlbGxlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmZhaWxlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmNvbXBsZXRlZCc6XG4gICAgICBjYXNlICd0aHJlYWQucnVuLmV4cGlyZWQnOlxuICAgICAgICB0aGlzLiNmaW5hbFJ1biA9IGV2ZW50LmRhdGE7XG4gICAgICAgIGlmICh0aGlzLiNjdXJyZW50VG9vbENhbGwpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0KCd0b29sQ2FsbERvbmUnLCB0aGlzLiNjdXJyZW50VG9vbENhbGwpO1xuICAgICAgICAgIHRoaXMuI2N1cnJlbnRUb29sQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RocmVhZC5ydW4uY2FuY2VsbGluZyc6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfYWRkUnVuKHJ1bjogUnVuKTogUnVuIHtcbiAgICByZXR1cm4gcnVuO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF90aHJlYWRBc3Npc3RhbnRTdHJlYW0oXG4gICAgcGFyYW1zOiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlLFxuICAgIHRocmVhZDogVGhyZWFkcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxSdW4+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fY3JlYXRlVGhyZWFkQXNzaXN0YW50U3RyZWFtKHRocmVhZCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfcnVuQXNzaXN0YW50U3RyZWFtKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuczogUnVucyxcbiAgICBwYXJhbXM6IFJ1bkNyZWF0ZVBhcmFtc0Jhc2UsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IFByb21pc2U8UnVuPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2NyZWF0ZUFzc2lzdGFudFN0cmVhbShydW5zLCB0aHJlYWRJZCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBfcnVuVG9vbEFzc2lzdGFudFN0cmVhbShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgcnVuczogUnVucyxcbiAgICBwYXJhbXM6IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBQcm9taXNlPFJ1bj4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9jcmVhdGVUb29sQXNzaXN0YW50U3RyZWFtKHJ1bnMsIHRocmVhZElkLCBydW5JZCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgfVxufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIEFzc2lzdGFudHNBUEkgZnJvbSAnLi4vYXNzaXN0YW50cyc7XG5pbXBvcnQgeyBDdXJzb3JQYWdlLCB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9wYWdpbmF0aW9uJztcblxuZXhwb3J0IGNsYXNzIE1lc3NhZ2VzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbWVzc2FnZS5cbiAgICovXG4gIGNyZWF0ZShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIGJvZHk6IE1lc3NhZ2VDcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxNZXNzYWdlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9tZXNzYWdlc2AsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhIG1lc3NhZ2UuXG4gICAqL1xuICByZXRyaWV2ZSh0aHJlYWRJZDogc3RyaW5nLCBtZXNzYWdlSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8TWVzc2FnZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9tZXNzYWdlcy8ke21lc3NhZ2VJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZmllcyBhIG1lc3NhZ2UuXG4gICAqL1xuICB1cGRhdGUoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBtZXNzYWdlSWQ6IHN0cmluZyxcbiAgICBib2R5OiBNZXNzYWdlVXBkYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8TWVzc2FnZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vbWVzc2FnZXMvJHttZXNzYWdlSWR9YCwge1xuICAgICAgYm9keSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIG1lc3NhZ2VzIGZvciBhIGdpdmVuIHRocmVhZC5cbiAgICovXG4gIGxpc3QoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBxdWVyeT86IE1lc3NhZ2VMaXN0UGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPE1lc3NhZ2VzUGFnZSwgTWVzc2FnZT47XG4gIGxpc3QodGhyZWFkSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPE1lc3NhZ2VzUGFnZSwgTWVzc2FnZT47XG4gIGxpc3QoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBxdWVyeTogTWVzc2FnZUxpc3RQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8TWVzc2FnZXNQYWdlLCBNZXNzYWdlPiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0KHRocmVhZElkLCB7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L21lc3NhZ2VzYCwgTWVzc2FnZXNQYWdlLCB7XG4gICAgICBxdWVyeSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBtZXNzYWdlLlxuICAgKi9cbiAgZGVsKHRocmVhZElkOiBzdHJpbmcsIG1lc3NhZ2VJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxNZXNzYWdlRGVsZXRlZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZGVsZXRlKGAvdGhyZWFkcy8ke3RocmVhZElkfS9tZXNzYWdlcy8ke21lc3NhZ2VJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWVzc2FnZXNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxNZXNzYWdlPiB7fVxuXG4vKipcbiAqIEEgY2l0YXRpb24gd2l0aGluIHRoZSBtZXNzYWdlIHRoYXQgcG9pbnRzIHRvIGEgc3BlY2lmaWMgcXVvdGUgZnJvbSBhIHNwZWNpZmljXG4gKiBGaWxlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzaXN0YW50IG9yIHRoZSBtZXNzYWdlLiBHZW5lcmF0ZWQgd2hlbiB0aGUgYXNzaXN0YW50XG4gKiB1c2VzIHRoZSBcImZpbGVfc2VhcmNoXCIgdG9vbCB0byBzZWFyY2ggZmlsZXMuXG4gKi9cbmV4cG9ydCB0eXBlIEFubm90YXRpb24gPSBGaWxlQ2l0YXRpb25Bbm5vdGF0aW9uIHwgRmlsZVBhdGhBbm5vdGF0aW9uO1xuXG4vKipcbiAqIEEgY2l0YXRpb24gd2l0aGluIHRoZSBtZXNzYWdlIHRoYXQgcG9pbnRzIHRvIGEgc3BlY2lmaWMgcXVvdGUgZnJvbSBhIHNwZWNpZmljXG4gKiBGaWxlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzaXN0YW50IG9yIHRoZSBtZXNzYWdlLiBHZW5lcmF0ZWQgd2hlbiB0aGUgYXNzaXN0YW50XG4gKiB1c2VzIHRoZSBcImZpbGVfc2VhcmNoXCIgdG9vbCB0byBzZWFyY2ggZmlsZXMuXG4gKi9cbmV4cG9ydCB0eXBlIEFubm90YXRpb25EZWx0YSA9IEZpbGVDaXRhdGlvbkRlbHRhQW5ub3RhdGlvbiB8IEZpbGVQYXRoRGVsdGFBbm5vdGF0aW9uO1xuXG4vKipcbiAqIEEgY2l0YXRpb24gd2l0aGluIHRoZSBtZXNzYWdlIHRoYXQgcG9pbnRzIHRvIGEgc3BlY2lmaWMgcXVvdGUgZnJvbSBhIHNwZWNpZmljXG4gKiBGaWxlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzaXN0YW50IG9yIHRoZSBtZXNzYWdlLiBHZW5lcmF0ZWQgd2hlbiB0aGUgYXNzaXN0YW50XG4gKiB1c2VzIHRoZSBcImZpbGVfc2VhcmNoXCIgdG9vbCB0byBzZWFyY2ggZmlsZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUNpdGF0aW9uQW5ub3RhdGlvbiB7XG4gIGVuZF9pbmRleDogbnVtYmVyO1xuXG4gIGZpbGVfY2l0YXRpb246IEZpbGVDaXRhdGlvbkFubm90YXRpb24uRmlsZUNpdGF0aW9uO1xuXG4gIHN0YXJ0X2luZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGluIHRoZSBtZXNzYWdlIGNvbnRlbnQgdGhhdCBuZWVkcyB0byBiZSByZXBsYWNlZC5cbiAgICovXG4gIHRleHQ6IHN0cmluZztcblxuICAvKipcbiAgICogQWx3YXlzIGBmaWxlX2NpdGF0aW9uYC5cbiAgICovXG4gIHR5cGU6ICdmaWxlX2NpdGF0aW9uJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaWxlQ2l0YXRpb25Bbm5vdGF0aW9uIHtcbiAgZXhwb3J0IGludGVyZmFjZSBGaWxlQ2l0YXRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgc3BlY2lmaWMgRmlsZSB0aGUgY2l0YXRpb24gaXMgZnJvbS5cbiAgICAgKi9cbiAgICBmaWxlX2lkOiBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNpdGF0aW9uIHdpdGhpbiB0aGUgbWVzc2FnZSB0aGF0IHBvaW50cyB0byBhIHNwZWNpZmljIHF1b3RlIGZyb20gYSBzcGVjaWZpY1xuICogRmlsZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2lzdGFudCBvciB0aGUgbWVzc2FnZS4gR2VuZXJhdGVkIHdoZW4gdGhlIGFzc2lzdGFudFxuICogdXNlcyB0aGUgXCJmaWxlX3NlYXJjaFwiIHRvb2wgdG8gc2VhcmNoIGZpbGVzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVDaXRhdGlvbkRlbHRhQW5ub3RhdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGFubm90YXRpb24gaW4gdGhlIHRleHQgY29udGVudCBwYXJ0LlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogQWx3YXlzIGBmaWxlX2NpdGF0aW9uYC5cbiAgICovXG4gIHR5cGU6ICdmaWxlX2NpdGF0aW9uJztcblxuICBlbmRfaW5kZXg/OiBudW1iZXI7XG5cbiAgZmlsZV9jaXRhdGlvbj86IEZpbGVDaXRhdGlvbkRlbHRhQW5ub3RhdGlvbi5GaWxlQ2l0YXRpb247XG5cbiAgc3RhcnRfaW5kZXg/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGluIHRoZSBtZXNzYWdlIGNvbnRlbnQgdGhhdCBuZWVkcyB0byBiZSByZXBsYWNlZC5cbiAgICovXG4gIHRleHQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRmlsZUNpdGF0aW9uRGVsdGFBbm5vdGF0aW9uIHtcbiAgZXhwb3J0IGludGVyZmFjZSBGaWxlQ2l0YXRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgc3BlY2lmaWMgRmlsZSB0aGUgY2l0YXRpb24gaXMgZnJvbS5cbiAgICAgKi9cbiAgICBmaWxlX2lkPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNwZWNpZmljIHF1b3RlIGluIHRoZSBmaWxlLlxuICAgICAqL1xuICAgIHF1b3RlPzogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogQSBVUkwgZm9yIHRoZSBmaWxlIHRoYXQncyBnZW5lcmF0ZWQgd2hlbiB0aGUgYXNzaXN0YW50IHVzZWQgdGhlXG4gKiBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCB0byBnZW5lcmF0ZSBhIGZpbGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVBhdGhBbm5vdGF0aW9uIHtcbiAgZW5kX2luZGV4OiBudW1iZXI7XG5cbiAgZmlsZV9wYXRoOiBGaWxlUGF0aEFubm90YXRpb24uRmlsZVBhdGg7XG5cbiAgc3RhcnRfaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHRleHQgaW4gdGhlIG1lc3NhZ2UgY29udGVudCB0aGF0IG5lZWRzIHRvIGJlIHJlcGxhY2VkLlxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYGZpbGVfcGF0aGAuXG4gICAqL1xuICB0eXBlOiAnZmlsZV9wYXRoJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaWxlUGF0aEFubm90YXRpb24ge1xuICBleHBvcnQgaW50ZXJmYWNlIEZpbGVQYXRoIHtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdGhhdCB3YXMgZ2VuZXJhdGVkLlxuICAgICAqL1xuICAgIGZpbGVfaWQ6IHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIEEgVVJMIGZvciB0aGUgZmlsZSB0aGF0J3MgZ2VuZXJhdGVkIHdoZW4gdGhlIGFzc2lzdGFudCB1c2VkIHRoZVxuICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgdG8gZ2VuZXJhdGUgYSBmaWxlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVQYXRoRGVsdGFBbm5vdGF0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgYW5ub3RhdGlvbiBpbiB0aGUgdGV4dCBjb250ZW50IHBhcnQuXG4gICAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYGZpbGVfcGF0aGAuXG4gICAqL1xuICB0eXBlOiAnZmlsZV9wYXRoJztcblxuICBlbmRfaW5kZXg/OiBudW1iZXI7XG5cbiAgZmlsZV9wYXRoPzogRmlsZVBhdGhEZWx0YUFubm90YXRpb24uRmlsZVBhdGg7XG5cbiAgc3RhcnRfaW5kZXg/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGluIHRoZSBtZXNzYWdlIGNvbnRlbnQgdGhhdCBuZWVkcyB0byBiZSByZXBsYWNlZC5cbiAgICovXG4gIHRleHQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRmlsZVBhdGhEZWx0YUFubm90YXRpb24ge1xuICBleHBvcnQgaW50ZXJmYWNlIEZpbGVQYXRoIHtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdGhhdCB3YXMgZ2VuZXJhdGVkLlxuICAgICAqL1xuICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZUZpbGUge1xuICAvKipcbiAgICogVGhlIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRCBvZiB0aGUgaW1hZ2VcbiAgICogaW4gdGhlIG1lc3NhZ2UgY29udGVudC4gU2V0IGBwdXJwb3NlPVwidmlzaW9uXCJgIHdoZW4gdXBsb2FkaW5nIHRoZSBGaWxlIGlmIHlvdVxuICAgKiBuZWVkIHRvIGxhdGVyIGRpc3BsYXkgdGhlIGZpbGUgY29udGVudC5cbiAgICovXG4gIGZpbGVfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkZXRhaWwgbGV2ZWwgb2YgdGhlIGltYWdlIGlmIHNwZWNpZmllZCBieSB0aGUgdXNlci4gYGxvd2AgdXNlc1xuICAgKiBmZXdlciB0b2tlbnMsIHlvdSBjYW4gb3B0IGluIHRvIGhpZ2ggcmVzb2x1dGlvbiB1c2luZyBgaGlnaGAuXG4gICAqL1xuICBkZXRhaWw/OiAnYXV0bycgfCAnbG93JyB8ICdoaWdoJztcbn1cblxuLyoqXG4gKiBSZWZlcmVuY2VzIGFuIGltYWdlIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKVxuICogaW4gdGhlIGNvbnRlbnQgb2YgYSBtZXNzYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlRmlsZUNvbnRlbnRCbG9jayB7XG4gIGltYWdlX2ZpbGU6IEltYWdlRmlsZTtcblxuICAvKipcbiAgICogQWx3YXlzIGBpbWFnZV9maWxlYC5cbiAgICovXG4gIHR5cGU6ICdpbWFnZV9maWxlJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZUZpbGVEZWx0YSB7XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGRldGFpbCBsZXZlbCBvZiB0aGUgaW1hZ2UgaWYgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyLiBgbG93YCB1c2VzXG4gICAqIGZld2VyIHRva2VucywgeW91IGNhbiBvcHQgaW4gdG8gaGlnaCByZXNvbHV0aW9uIHVzaW5nIGBoaWdoYC5cbiAgICovXG4gIGRldGFpbD86ICdhdXRvJyB8ICdsb3cnIHwgJ2hpZ2gnO1xuXG4gIC8qKlxuICAgKiBUaGUgW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEIG9mIHRoZSBpbWFnZVxuICAgKiBpbiB0aGUgbWVzc2FnZSBjb250ZW50LiBTZXQgYHB1cnBvc2U9XCJ2aXNpb25cImAgd2hlbiB1cGxvYWRpbmcgdGhlIEZpbGUgaWYgeW91XG4gICAqIG5lZWQgdG8gbGF0ZXIgZGlzcGxheSB0aGUgZmlsZSBjb250ZW50LlxuICAgKi9cbiAgZmlsZV9pZD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZWZlcmVuY2VzIGFuIGltYWdlIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKVxuICogaW4gdGhlIGNvbnRlbnQgb2YgYSBtZXNzYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlRmlsZURlbHRhQmxvY2sge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IHBhcnQgaW4gdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYGltYWdlX2ZpbGVgLlxuICAgKi9cbiAgdHlwZTogJ2ltYWdlX2ZpbGUnO1xuXG4gIGltYWdlX2ZpbGU/OiBJbWFnZUZpbGVEZWx0YTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZVVSTCB7XG4gIC8qKlxuICAgKiBUaGUgZXh0ZXJuYWwgVVJMIG9mIHRoZSBpbWFnZSwgbXVzdCBiZSBhIHN1cHBvcnRlZCBpbWFnZSB0eXBlczoganBlZywganBnLCBwbmcsXG4gICAqIGdpZiwgd2VicC5cbiAgICovXG4gIHVybDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGRldGFpbCBsZXZlbCBvZiB0aGUgaW1hZ2UuIGBsb3dgIHVzZXMgZmV3ZXIgdG9rZW5zLCB5b3UgY2FuIG9wdCBpblxuICAgKiB0byBoaWdoIHJlc29sdXRpb24gdXNpbmcgYGhpZ2hgLiBEZWZhdWx0IHZhbHVlIGlzIGBhdXRvYFxuICAgKi9cbiAgZGV0YWlsPzogJ2F1dG8nIHwgJ2xvdycgfCAnaGlnaCc7XG59XG5cbi8qKlxuICogUmVmZXJlbmNlcyBhbiBpbWFnZSBVUkwgaW4gdGhlIGNvbnRlbnQgb2YgYSBtZXNzYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlVVJMQ29udGVudEJsb2NrIHtcbiAgaW1hZ2VfdXJsOiBJbWFnZVVSTDtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIGNvbnRlbnQgcGFydC5cbiAgICovXG4gIHR5cGU6ICdpbWFnZV91cmwnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlVVJMRGVsdGEge1xuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkZXRhaWwgbGV2ZWwgb2YgdGhlIGltYWdlLiBgbG93YCB1c2VzIGZld2VyIHRva2VucywgeW91IGNhbiBvcHQgaW5cbiAgICogdG8gaGlnaCByZXNvbHV0aW9uIHVzaW5nIGBoaWdoYC5cbiAgICovXG4gIGRldGFpbD86ICdhdXRvJyB8ICdsb3cnIHwgJ2hpZ2gnO1xuXG4gIC8qKlxuICAgKiBUaGUgVVJMIG9mIHRoZSBpbWFnZSwgbXVzdCBiZSBhIHN1cHBvcnRlZCBpbWFnZSB0eXBlczoganBlZywganBnLCBwbmcsIGdpZixcbiAgICogd2VicC5cbiAgICovXG4gIHVybD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZWZlcmVuY2VzIGFuIGltYWdlIFVSTCBpbiB0aGUgY29udGVudCBvZiBhIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VVUkxEZWx0YUJsb2NrIHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY29udGVudCBwYXJ0IGluIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogQWx3YXlzIGBpbWFnZV91cmxgLlxuICAgKi9cbiAgdHlwZTogJ2ltYWdlX3VybCc7XG5cbiAgaW1hZ2VfdXJsPzogSW1hZ2VVUkxEZWx0YTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgbWVzc2FnZSB3aXRoaW4gYVxuICogW3RocmVhZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS90aHJlYWRzKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlIHtcbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogSWYgYXBwbGljYWJsZSwgdGhlIElEIG9mIHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIHRoYXRcbiAgICogYXV0aG9yZWQgdGhpcyBtZXNzYWdlLlxuICAgKi9cbiAgYXNzaXN0YW50X2lkOiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgZmlsZXMgYXR0YWNoZWQgdG8gdGhlIG1lc3NhZ2UsIGFuZCB0aGUgdG9vbHMgdGhleSB3ZXJlIGFkZGVkIHRvLlxuICAgKi9cbiAgYXR0YWNobWVudHM6IEFycmF5PE1lc3NhZ2UuQXR0YWNobWVudD4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBtZXNzYWdlIHdhcyBjb21wbGV0ZWQuXG4gICAqL1xuICBjb21wbGV0ZWRfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBtZXNzYWdlIGluIGFycmF5IG9mIHRleHQgYW5kL29yIGltYWdlcy5cbiAgICovXG4gIGNvbnRlbnQ6IEFycmF5PE1lc3NhZ2VDb250ZW50PjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgbWVzc2FnZSB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgbWVzc2FnZSB3YXMgbWFya2VkIGFzIGluY29tcGxldGUuXG4gICAqL1xuICBpbmNvbXBsZXRlX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPbiBhbiBpbmNvbXBsZXRlIG1lc3NhZ2UsIGRldGFpbHMgYWJvdXQgd2h5IHRoZSBtZXNzYWdlIGlzIGluY29tcGxldGUuXG4gICAqL1xuICBpbmNvbXBsZXRlX2RldGFpbHM6IE1lc3NhZ2UuSW5jb21wbGV0ZURldGFpbHMgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YTogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGB0aHJlYWQubWVzc2FnZWAuXG4gICAqL1xuICBvYmplY3Q6ICd0aHJlYWQubWVzc2FnZSc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbnRpdHkgdGhhdCBwcm9kdWNlZCB0aGUgbWVzc2FnZS4gT25lIG9mIGB1c2VyYCBvciBgYXNzaXN0YW50YC5cbiAgICovXG4gIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFtydW5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucylcbiAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSBjcmVhdGlvbiBvZiB0aGlzIG1lc3NhZ2UuIFZhbHVlIGlzIGBudWxsYCB3aGVuIG1lc3NhZ2VzIGFyZVxuICAgKiBjcmVhdGVkIG1hbnVhbGx5IHVzaW5nIHRoZSBjcmVhdGUgbWVzc2FnZSBvciBjcmVhdGUgdGhyZWFkIGVuZHBvaW50cy5cbiAgICovXG4gIHJ1bl9pZDogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHN0YXR1cyBvZiB0aGUgbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGVpdGhlciBgaW5fcHJvZ3Jlc3NgLCBgaW5jb21wbGV0ZWAsIG9yXG4gICAqIGBjb21wbGV0ZWRgLlxuICAgKi9cbiAgc3RhdHVzOiAnaW5fcHJvZ3Jlc3MnIHwgJ2luY29tcGxldGUnIHwgJ2NvbXBsZXRlZCc7XG5cbiAgLyoqXG4gICAqIFRoZSBbdGhyZWFkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3RocmVhZHMpIElEIHRoYXRcbiAgICogdGhpcyBtZXNzYWdlIGJlbG9uZ3MgdG8uXG4gICAqL1xuICB0aHJlYWRfaWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBNZXNzYWdlIHtcbiAgZXhwb3J0IGludGVyZmFjZSBBdHRhY2htZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gYXR0YWNoIHRvIHRoZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG9vbHMgdG8gYWRkIHRoaXMgZmlsZSB0by5cbiAgICAgKi9cbiAgICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEF0dGFjaG1lbnQuQXNzaXN0YW50VG9vbHNGaWxlU2VhcmNoVHlwZU9ubHk+O1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBBdHRhY2htZW50IHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIEFzc2lzdGFudFRvb2xzRmlsZVNlYXJjaFR5cGVPbmx5IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHR5cGUgb2YgdG9vbCBiZWluZyBkZWZpbmVkOiBgZmlsZV9zZWFyY2hgXG4gICAgICAgKi9cbiAgICAgIHR5cGU6ICdmaWxlX3NlYXJjaCc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGFuIGluY29tcGxldGUgbWVzc2FnZSwgZGV0YWlscyBhYm91dCB3aHkgdGhlIG1lc3NhZ2UgaXMgaW5jb21wbGV0ZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSW5jb21wbGV0ZURldGFpbHMge1xuICAgIC8qKlxuICAgICAqIFRoZSByZWFzb24gdGhlIG1lc3NhZ2UgaXMgaW5jb21wbGV0ZS5cbiAgICAgKi9cbiAgICByZWFzb246ICdjb250ZW50X2ZpbHRlcicgfCAnbWF4X3Rva2VucycgfCAncnVuX2NhbmNlbGxlZCcgfCAncnVuX2V4cGlyZWQnIHwgJ3J1bl9mYWlsZWQnO1xuICB9XG59XG5cbi8qKlxuICogUmVmZXJlbmNlcyBhbiBpbWFnZSBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcylcbiAqIGluIHRoZSBjb250ZW50IG9mIGEgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IHR5cGUgTWVzc2FnZUNvbnRlbnQgPVxuICB8IEltYWdlRmlsZUNvbnRlbnRCbG9ja1xuICB8IEltYWdlVVJMQ29udGVudEJsb2NrXG4gIHwgVGV4dENvbnRlbnRCbG9ja1xuICB8IFJlZnVzYWxDb250ZW50QmxvY2s7XG5cbi8qKlxuICogUmVmZXJlbmNlcyBhbiBpbWFnZSBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcylcbiAqIGluIHRoZSBjb250ZW50IG9mIGEgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IHR5cGUgTWVzc2FnZUNvbnRlbnREZWx0YSA9XG4gIHwgSW1hZ2VGaWxlRGVsdGFCbG9ja1xuICB8IFRleHREZWx0YUJsb2NrXG4gIHwgUmVmdXNhbERlbHRhQmxvY2tcbiAgfCBJbWFnZVVSTERlbHRhQmxvY2s7XG5cbi8qKlxuICogUmVmZXJlbmNlcyBhbiBpbWFnZSBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcylcbiAqIGluIHRoZSBjb250ZW50IG9mIGEgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IHR5cGUgTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0gPSBJbWFnZUZpbGVDb250ZW50QmxvY2sgfCBJbWFnZVVSTENvbnRlbnRCbG9jayB8IFRleHRDb250ZW50QmxvY2tQYXJhbTtcblxuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlRGVsZXRlZCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgZGVsZXRlZDogYm9vbGVhbjtcblxuICBvYmplY3Q6ICd0aHJlYWQubWVzc2FnZS5kZWxldGVkJztcbn1cblxuLyoqXG4gKiBUaGUgZGVsdGEgY29udGFpbmluZyB0aGUgZmllbGRzIHRoYXQgaGF2ZSBjaGFuZ2VkIG9uIHRoZSBNZXNzYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VEZWx0YSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZSBpbiBhcnJheSBvZiB0ZXh0IGFuZC9vciBpbWFnZXMuXG4gICAqL1xuICBjb250ZW50PzogQXJyYXk8TWVzc2FnZUNvbnRlbnREZWx0YT47XG5cbiAgLyoqXG4gICAqIFRoZSBlbnRpdHkgdGhhdCBwcm9kdWNlZCB0aGUgbWVzc2FnZS4gT25lIG9mIGB1c2VyYCBvciBgYXNzaXN0YW50YC5cbiAgICovXG4gIHJvbGU/OiAndXNlcicgfCAnYXNzaXN0YW50Jztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgbWVzc2FnZSBkZWx0YSBpLmUuIGFueSBjaGFuZ2VkIGZpZWxkcyBvbiBhIG1lc3NhZ2UgZHVyaW5nXG4gKiBzdHJlYW1pbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZURlbHRhRXZlbnQge1xuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIgb2YgdGhlIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVsdGEgY29udGFpbmluZyB0aGUgZmllbGRzIHRoYXQgaGF2ZSBjaGFuZ2VkIG9uIHRoZSBNZXNzYWdlLlxuICAgKi9cbiAgZGVsdGE6IE1lc3NhZ2VEZWx0YTtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYHRocmVhZC5tZXNzYWdlLmRlbHRhYC5cbiAgICovXG4gIG9iamVjdDogJ3RocmVhZC5tZXNzYWdlLmRlbHRhJztcbn1cblxuLyoqXG4gKiBUaGUgcmVmdXNhbCBjb250ZW50IGdlbmVyYXRlZCBieSB0aGUgYXNzaXN0YW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlZnVzYWxDb250ZW50QmxvY2sge1xuICByZWZ1c2FsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgcmVmdXNhbGAuXG4gICAqL1xuICB0eXBlOiAncmVmdXNhbCc7XG59XG5cbi8qKlxuICogVGhlIHJlZnVzYWwgY29udGVudCB0aGF0IGlzIHBhcnQgb2YgYSBtZXNzYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlZnVzYWxEZWx0YUJsb2NrIHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgcmVmdXNhbCBwYXJ0IGluIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogQWx3YXlzIGByZWZ1c2FsYC5cbiAgICovXG4gIHR5cGU6ICdyZWZ1c2FsJztcblxuICByZWZ1c2FsPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRleHQge1xuICBhbm5vdGF0aW9uczogQXJyYXk8QW5ub3RhdGlvbj47XG5cbiAgLyoqXG4gICAqIFRoZSBkYXRhIHRoYXQgbWFrZXMgdXAgdGhlIHRleHQuXG4gICAqL1xuICB2YWx1ZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRoZSB0ZXh0IGNvbnRlbnQgdGhhdCBpcyBwYXJ0IG9mIGEgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZXh0Q29udGVudEJsb2NrIHtcbiAgdGV4dDogVGV4dDtcblxuICAvKipcbiAgICogQWx3YXlzIGB0ZXh0YC5cbiAgICovXG4gIHR5cGU6ICd0ZXh0Jztcbn1cblxuLyoqXG4gKiBUaGUgdGV4dCBjb250ZW50IHRoYXQgaXMgcGFydCBvZiBhIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dENvbnRlbnRCbG9ja1BhcmFtIHtcbiAgLyoqXG4gICAqIFRleHQgY29udGVudCB0byBiZSBzZW50IHRvIHRoZSBtb2RlbFxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYHRleHRgLlxuICAgKi9cbiAgdHlwZTogJ3RleHQnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRleHREZWx0YSB7XG4gIGFubm90YXRpb25zPzogQXJyYXk8QW5ub3RhdGlvbkRlbHRhPjtcblxuICAvKipcbiAgICogVGhlIGRhdGEgdGhhdCBtYWtlcyB1cCB0aGUgdGV4dC5cbiAgICovXG4gIHZhbHVlPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRoZSB0ZXh0IGNvbnRlbnQgdGhhdCBpcyBwYXJ0IG9mIGEgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZXh0RGVsdGFCbG9jayB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGNvbnRlbnQgcGFydCBpbiB0aGUgbWVzc2FnZS5cbiAgICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgdGV4dGAuXG4gICAqL1xuICB0eXBlOiAndGV4dCc7XG5cbiAgdGV4dD86IFRleHREZWx0YTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8TWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0+O1xuXG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgZW50aXR5IHRoYXQgaXMgY3JlYXRpbmcgdGhlIG1lc3NhZ2UuIEFsbG93ZWQgdmFsdWVzIGluY2x1ZGU6XG4gICAqXG4gICAqIC0gYHVzZXJgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgc2VudCBieSBhbiBhY3R1YWwgdXNlciBhbmQgc2hvdWxkIGJlIHVzZWQgaW5cbiAgICogICBtb3N0IGNhc2VzIHRvIHJlcHJlc2VudCB1c2VyLWdlbmVyYXRlZCBtZXNzYWdlcy5cbiAgICogLSBgYXNzaXN0YW50YDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGdlbmVyYXRlZCBieSB0aGUgYXNzaXN0YW50LiBVc2UgdGhpc1xuICAgKiAgIHZhbHVlIHRvIGluc2VydCBtZXNzYWdlcyBmcm9tIHRoZSBhc3Npc3RhbnQgaW50byB0aGUgY29udmVyc2F0aW9uLlxuICAgKi9cbiAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byB0aGUgbWVzc2FnZSwgYW5kIHRoZSB0b29scyB0aGV5IHNob3VsZCBiZSBhZGRlZCB0by5cbiAgICovXG4gIGF0dGFjaG1lbnRzPzogQXJyYXk8TWVzc2FnZUNyZWF0ZVBhcmFtcy5BdHRhY2htZW50PiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgTWVzc2FnZUNyZWF0ZVBhcmFtcyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudCB7XG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBmaWxlIHRvIGF0dGFjaCB0byB0aGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBmaWxlX2lkPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvb2xzIHRvIGFkZCB0aGlzIGZpbGUgdG8uXG4gICAgICovXG4gICAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkNvZGVJbnRlcnByZXRlclRvb2wgfCBBdHRhY2htZW50LkZpbGVTZWFyY2g+O1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBBdHRhY2htZW50IHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdHlwZSBvZiB0b29sIGJlaW5nIGRlZmluZWQ6IGBmaWxlX3NlYXJjaGBcbiAgICAgICAqL1xuICAgICAgdHlwZTogJ2ZpbGVfc2VhcmNoJztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlVXBkYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZUxpc3RQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgY3Vyc29yIGZvciB1c2UgaW4gcGFnaW5hdGlvbi4gYGJlZm9yZWAgaXMgYW4gb2JqZWN0IElEIHRoYXQgZGVmaW5lcyB5b3VyIHBsYWNlXG4gICAqIGluIHRoZSBsaXN0LiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBtYWtlIGEgbGlzdCByZXF1ZXN0IGFuZCByZWNlaXZlIDEwMCBvYmplY3RzLFxuICAgKiBzdGFydGluZyB3aXRoIG9ial9mb28sIHlvdXIgc3Vic2VxdWVudCBjYWxsIGNhbiBpbmNsdWRlIGJlZm9yZT1vYmpfZm9vIGluIG9yZGVyXG4gICAqIHRvIGZldGNoIHRoZSBwcmV2aW91cyBwYWdlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgYmVmb3JlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTb3J0IG9yZGVyIGJ5IHRoZSBgY3JlYXRlZF9hdGAgdGltZXN0YW1wIG9mIHRoZSBvYmplY3RzLiBgYXNjYCBmb3IgYXNjZW5kaW5nXG4gICAqIG9yZGVyIGFuZCBgZGVzY2AgZm9yIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAqL1xuICBvcmRlcj86ICdhc2MnIHwgJ2Rlc2MnO1xuXG4gIC8qKlxuICAgKiBGaWx0ZXIgbWVzc2FnZXMgYnkgdGhlIHJ1biBJRCB0aGF0IGdlbmVyYXRlZCB0aGVtLlxuICAgKi9cbiAgcnVuX2lkPzogc3RyaW5nO1xufVxuXG5NZXNzYWdlcy5NZXNzYWdlc1BhZ2UgPSBNZXNzYWdlc1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBNZXNzYWdlcyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBBbm5vdGF0aW9uIGFzIEFubm90YXRpb24sXG4gICAgdHlwZSBBbm5vdGF0aW9uRGVsdGEgYXMgQW5ub3RhdGlvbkRlbHRhLFxuICAgIHR5cGUgRmlsZUNpdGF0aW9uQW5ub3RhdGlvbiBhcyBGaWxlQ2l0YXRpb25Bbm5vdGF0aW9uLFxuICAgIHR5cGUgRmlsZUNpdGF0aW9uRGVsdGFBbm5vdGF0aW9uIGFzIEZpbGVDaXRhdGlvbkRlbHRhQW5ub3RhdGlvbixcbiAgICB0eXBlIEZpbGVQYXRoQW5ub3RhdGlvbiBhcyBGaWxlUGF0aEFubm90YXRpb24sXG4gICAgdHlwZSBGaWxlUGF0aERlbHRhQW5ub3RhdGlvbiBhcyBGaWxlUGF0aERlbHRhQW5ub3RhdGlvbixcbiAgICB0eXBlIEltYWdlRmlsZSBhcyBJbWFnZUZpbGUsXG4gICAgdHlwZSBJbWFnZUZpbGVDb250ZW50QmxvY2sgYXMgSW1hZ2VGaWxlQ29udGVudEJsb2NrLFxuICAgIHR5cGUgSW1hZ2VGaWxlRGVsdGEgYXMgSW1hZ2VGaWxlRGVsdGEsXG4gICAgdHlwZSBJbWFnZUZpbGVEZWx0YUJsb2NrIGFzIEltYWdlRmlsZURlbHRhQmxvY2ssXG4gICAgdHlwZSBJbWFnZVVSTCBhcyBJbWFnZVVSTCxcbiAgICB0eXBlIEltYWdlVVJMQ29udGVudEJsb2NrIGFzIEltYWdlVVJMQ29udGVudEJsb2NrLFxuICAgIHR5cGUgSW1hZ2VVUkxEZWx0YSBhcyBJbWFnZVVSTERlbHRhLFxuICAgIHR5cGUgSW1hZ2VVUkxEZWx0YUJsb2NrIGFzIEltYWdlVVJMRGVsdGFCbG9jayxcbiAgICB0eXBlIE1lc3NhZ2UgYXMgTWVzc2FnZSxcbiAgICB0eXBlIE1lc3NhZ2VDb250ZW50IGFzIE1lc3NhZ2VDb250ZW50LFxuICAgIHR5cGUgTWVzc2FnZUNvbnRlbnREZWx0YSBhcyBNZXNzYWdlQ29udGVudERlbHRhLFxuICAgIHR5cGUgTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0gYXMgTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0sXG4gICAgdHlwZSBNZXNzYWdlRGVsZXRlZCBhcyBNZXNzYWdlRGVsZXRlZCxcbiAgICB0eXBlIE1lc3NhZ2VEZWx0YSBhcyBNZXNzYWdlRGVsdGEsXG4gICAgdHlwZSBNZXNzYWdlRGVsdGFFdmVudCBhcyBNZXNzYWdlRGVsdGFFdmVudCxcbiAgICB0eXBlIFJlZnVzYWxDb250ZW50QmxvY2sgYXMgUmVmdXNhbENvbnRlbnRCbG9jayxcbiAgICB0eXBlIFJlZnVzYWxEZWx0YUJsb2NrIGFzIFJlZnVzYWxEZWx0YUJsb2NrLFxuICAgIHR5cGUgVGV4dCBhcyBUZXh0LFxuICAgIHR5cGUgVGV4dENvbnRlbnRCbG9jayBhcyBUZXh0Q29udGVudEJsb2NrLFxuICAgIHR5cGUgVGV4dENvbnRlbnRCbG9ja1BhcmFtIGFzIFRleHRDb250ZW50QmxvY2tQYXJhbSxcbiAgICB0eXBlIFRleHREZWx0YSBhcyBUZXh0RGVsdGEsXG4gICAgdHlwZSBUZXh0RGVsdGFCbG9jayBhcyBUZXh0RGVsdGFCbG9jayxcbiAgICBNZXNzYWdlc1BhZ2UgYXMgTWVzc2FnZXNQYWdlLFxuICAgIHR5cGUgTWVzc2FnZUNyZWF0ZVBhcmFtcyBhcyBNZXNzYWdlQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgTWVzc2FnZVVwZGF0ZVBhcmFtcyBhcyBNZXNzYWdlVXBkYXRlUGFyYW1zLFxuICAgIHR5cGUgTWVzc2FnZUxpc3RQYXJhbXMgYXMgTWVzc2FnZUxpc3RQYXJhbXMsXG4gIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi8uLi8uLi8uLi9yZXNvdXJjZSc7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgU3RlcHNBUEkgZnJvbSAnLi9zdGVwcyc7XG5pbXBvcnQgeyBDdXJzb3JQYWdlLCB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi8uLi9wYWdpbmF0aW9uJztcblxuZXhwb3J0IGNsYXNzIFN0ZXBzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogUmV0cmlldmVzIGEgcnVuIHN0ZXAuXG4gICAqL1xuICByZXRyaWV2ZShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgc3RlcElkOiBzdHJpbmcsXG4gICAgcXVlcnk/OiBTdGVwUmV0cmlldmVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxSdW5TdGVwPjtcbiAgcmV0cmlldmUoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIHN0ZXBJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8UnVuU3RlcD47XG4gIHJldHJpZXZlKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBzdGVwSWQ6IHN0cmluZyxcbiAgICBxdWVyeTogU3RlcFJldHJpZXZlUGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8UnVuU3RlcD4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmUodGhyZWFkSWQsIHJ1bklkLCBzdGVwSWQsIHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9L3N0ZXBzLyR7c3RlcElkfWAsIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgcnVuIHN0ZXBzIGJlbG9uZ2luZyB0byBhIHJ1bi5cbiAgICovXG4gIGxpc3QoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIHF1ZXJ5PzogU3RlcExpc3RQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8UnVuU3RlcHNQYWdlLCBSdW5TdGVwPjtcbiAgbGlzdChcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8UnVuU3RlcHNQYWdlLCBSdW5TdGVwPjtcbiAgbGlzdChcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgcXVlcnk6IFN0ZXBMaXN0UGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFJ1blN0ZXBzUGFnZSwgUnVuU3RlcD4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdCh0aHJlYWRJZCwgcnVuSWQsIHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfS9zdGVwc2AsIFJ1blN0ZXBzUGFnZSwge1xuICAgICAgcXVlcnksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUnVuU3RlcHNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxSdW5TdGVwPiB7fVxuXG4vKipcbiAqIFRleHQgb3V0cHV0IGZyb20gdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsIGFzIHBhcnQgb2YgYSBydW4gc3RlcC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXJMb2dzIHtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGluIHRoZSBvdXRwdXRzIGFycmF5LlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogQWx3YXlzIGBsb2dzYC5cbiAgICovXG4gIHR5cGU6ICdsb2dzJztcblxuICAvKipcbiAgICogVGhlIHRleHQgb3V0cHV0IGZyb20gdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsLlxuICAgKi9cbiAgbG9ncz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXJPdXRwdXRJbWFnZSB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCBpbiB0aGUgb3V0cHV0cyBhcnJheS5cbiAgICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgaW1hZ2VgLlxuICAgKi9cbiAgdHlwZTogJ2ltYWdlJztcblxuICBpbWFnZT86IENvZGVJbnRlcnByZXRlck91dHB1dEltYWdlLkltYWdlO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENvZGVJbnRlcnByZXRlck91dHB1dEltYWdlIHtcbiAgZXhwb3J0IGludGVyZmFjZSBJbWFnZSB7XG4gICAgLyoqXG4gICAgICogVGhlIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRCBvZiB0aGVcbiAgICAgKiBpbWFnZS5cbiAgICAgKi9cbiAgICBmaWxlX2lkPzogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogRGV0YWlscyBvZiB0aGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwgdGhlIHJ1biBzdGVwIHdhcyBpbnZvbHZlZCBpbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbCB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbC5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbCBkZWZpbml0aW9uLlxuICAgKi9cbiAgY29kZV9pbnRlcnByZXRlcjogQ29kZUludGVycHJldGVyVG9vbENhbGwuQ29kZUludGVycHJldGVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0b29sIGNhbGwuIFRoaXMgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIGBjb2RlX2ludGVycHJldGVyYCBmb3IgdGhpc1xuICAgKiB0eXBlIG9mIHRvb2wgY2FsbC5cbiAgICovXG4gIHR5cGU6ICdjb2RlX2ludGVycHJldGVyJztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbCB7XG4gIC8qKlxuICAgKiBUaGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwgZGVmaW5pdGlvbi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5wdXQgdG8gdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsLlxuICAgICAqL1xuICAgIGlucHV0OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0cyBmcm9tIHRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbC4gQ29kZSBJbnRlcnByZXRlciBjYW4gb3V0cHV0IG9uZVxuICAgICAqIG9yIG1vcmUgaXRlbXMsIGluY2x1ZGluZyB0ZXh0IChgbG9nc2ApIG9yIGltYWdlcyAoYGltYWdlYCkuIEVhY2ggb2YgdGhlc2UgYXJlXG4gICAgICogcmVwcmVzZW50ZWQgYnkgYSBkaWZmZXJlbnQgb2JqZWN0IHR5cGUuXG4gICAgICovXG4gICAgb3V0cHV0czogQXJyYXk8Q29kZUludGVycHJldGVyLkxvZ3MgfCBDb2RlSW50ZXJwcmV0ZXIuSW1hZ2U+O1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgIC8qKlxuICAgICAqIFRleHQgb3V0cHV0IGZyb20gdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsIGFzIHBhcnQgb2YgYSBydW4gc3RlcC5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIExvZ3Mge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdGV4dCBvdXRwdXQgZnJvbSB0aGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwuXG4gICAgICAgKi9cbiAgICAgIGxvZ3M6IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBBbHdheXMgYGxvZ3NgLlxuICAgICAgICovXG4gICAgICB0eXBlOiAnbG9ncyc7XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBJbWFnZSB7XG4gICAgICBpbWFnZTogSW1hZ2UuSW1hZ2U7XG5cbiAgICAgIC8qKlxuICAgICAgICogQWx3YXlzIGBpbWFnZWAuXG4gICAgICAgKi9cbiAgICAgIHR5cGU6ICdpbWFnZSc7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBJbWFnZSB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEltYWdlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSUQgb2YgdGhlXG4gICAgICAgICAqIGltYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZV9pZDogc3RyaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERldGFpbHMgb2YgdGhlIENvZGUgSW50ZXJwcmV0ZXIgdG9vbCBjYWxsIHRoZSBydW4gc3RlcCB3YXMgaW52b2x2ZWQgaW4uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyVG9vbENhbGxEZWx0YSB7XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIHRvb2wgY2FsbCBpbiB0aGUgdG9vbCBjYWxscyBhcnJheS5cbiAgICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRvb2wgY2FsbC4gVGhpcyBpcyBhbHdheXMgZ29pbmcgdG8gYmUgYGNvZGVfaW50ZXJwcmV0ZXJgIGZvciB0aGlzXG4gICAqIHR5cGUgb2YgdG9vbCBjYWxsLlxuICAgKi9cbiAgdHlwZTogJ2NvZGVfaW50ZXJwcmV0ZXInO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbC5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwgZGVmaW5pdGlvbi5cbiAgICovXG4gIGNvZGVfaW50ZXJwcmV0ZXI/OiBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbERlbHRhLkNvZGVJbnRlcnByZXRlcjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbERlbHRhIHtcbiAgLyoqXG4gICAqIFRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbCBkZWZpbml0aW9uLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnB1dCB0byB0aGUgQ29kZSBJbnRlcnByZXRlciB0b29sIGNhbGwuXG4gICAgICovXG4gICAgaW5wdXQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0cyBmcm9tIHRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbC4gQ29kZSBJbnRlcnByZXRlciBjYW4gb3V0cHV0IG9uZVxuICAgICAqIG9yIG1vcmUgaXRlbXMsIGluY2x1ZGluZyB0ZXh0IChgbG9nc2ApIG9yIGltYWdlcyAoYGltYWdlYCkuIEVhY2ggb2YgdGhlc2UgYXJlXG4gICAgICogcmVwcmVzZW50ZWQgYnkgYSBkaWZmZXJlbnQgb2JqZWN0IHR5cGUuXG4gICAgICovXG4gICAgb3V0cHV0cz86IEFycmF5PFN0ZXBzQVBJLkNvZGVJbnRlcnByZXRlckxvZ3MgfCBTdGVwc0FQSS5Db2RlSW50ZXJwcmV0ZXJPdXRwdXRJbWFnZT47XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoVG9vbENhbGwge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwgb2JqZWN0LlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogRm9yIG5vdywgdGhpcyBpcyBhbHdheXMgZ29pbmcgdG8gYmUgYW4gZW1wdHkgb2JqZWN0LlxuICAgKi9cbiAgZmlsZV9zZWFyY2g6IEZpbGVTZWFyY2hUb29sQ2FsbC5GaWxlU2VhcmNoO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0b29sIGNhbGwuIFRoaXMgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIGBmaWxlX3NlYXJjaGAgZm9yIHRoaXMgdHlwZSBvZlxuICAgKiB0b29sIGNhbGwuXG4gICAqL1xuICB0eXBlOiAnZmlsZV9zZWFyY2gnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZpbGVTZWFyY2hUb29sQ2FsbCB7XG4gIC8qKlxuICAgKiBGb3Igbm93LCB0aGlzIGlzIGFsd2F5cyBnb2luZyB0byBiZSBhbiBlbXB0eSBvYmplY3QuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgIC8qKlxuICAgICAqIFRoZSByYW5raW5nIG9wdGlvbnMgZm9yIHRoZSBmaWxlIHNlYXJjaC5cbiAgICAgKi9cbiAgICByYW5raW5nX29wdGlvbnM/OiBGaWxlU2VhcmNoLlJhbmtpbmdPcHRpb25zO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdHMgb2YgdGhlIGZpbGUgc2VhcmNoLlxuICAgICAqL1xuICAgIHJlc3VsdHM/OiBBcnJheTxGaWxlU2VhcmNoLlJlc3VsdD47XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIEZpbGVTZWFyY2gge1xuICAgIC8qKlxuICAgICAqIFRoZSByYW5raW5nIG9wdGlvbnMgZm9yIHRoZSBmaWxlIHNlYXJjaC5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIFJhbmtpbmdPcHRpb25zIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHJhbmtlciB1c2VkIGZvciB0aGUgZmlsZSBzZWFyY2guXG4gICAgICAgKi9cbiAgICAgIHJhbmtlcjogJ2RlZmF1bHRfMjAyNF8wOF8yMSc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHNjb3JlIHRocmVzaG9sZCBmb3IgdGhlIGZpbGUgc2VhcmNoLiBBbGwgdmFsdWVzIG11c3QgYmUgYSBmbG9hdGluZyBwb2ludFxuICAgICAgICogbnVtYmVyIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgICAqL1xuICAgICAgc2NvcmVfdGhyZXNob2xkOiBudW1iZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSByZXN1bHQgaW5zdGFuY2Ugb2YgdGhlIGZpbGUgc2VhcmNoLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgUmVzdWx0IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIElEIG9mIHRoZSBmaWxlIHRoYXQgcmVzdWx0IHdhcyBmb3VuZCBpbi5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZDogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRoYXQgcmVzdWx0IHdhcyBmb3VuZCBpbi5cbiAgICAgICAqL1xuICAgICAgZmlsZV9uYW1lOiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHNjb3JlIG9mIHRoZSByZXN1bHQuIEFsbCB2YWx1ZXMgbXVzdCBiZSBhIGZsb2F0aW5nIHBvaW50IG51bWJlciBiZXR3ZWVuIDBcbiAgICAgICAqIGFuZCAxLlxuICAgICAgICovXG4gICAgICBzY29yZTogbnVtYmVyO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjb250ZW50IG9mIHRoZSByZXN1bHQgdGhhdCB3YXMgZm91bmQuIFRoZSBjb250ZW50IGlzIG9ubHkgaW5jbHVkZWQgaWZcbiAgICAgICAqIHJlcXVlc3RlZCB2aWEgdGhlIGluY2x1ZGUgcXVlcnkgcGFyYW1ldGVyLlxuICAgICAgICovXG4gICAgICBjb250ZW50PzogQXJyYXk8UmVzdWx0LkNvbnRlbnQ+O1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgUmVzdWx0IHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29udGVudCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBjb250ZW50IG9mIHRoZSBmaWxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dD86IHN0cmluZztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIGNvbnRlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlPzogJ3RleHQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2hUb29sQ2FsbERlbHRhIHtcbiAgLyoqXG4gICAqIEZvciBub3csIHRoaXMgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIGFuIGVtcHR5IG9iamVjdC5cbiAgICovXG4gIGZpbGVfc2VhcmNoOiB1bmtub3duO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIHRvb2wgY2FsbCBpbiB0aGUgdG9vbCBjYWxscyBhcnJheS5cbiAgICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRvb2wgY2FsbC4gVGhpcyBpcyBhbHdheXMgZ29pbmcgdG8gYmUgYGZpbGVfc2VhcmNoYCBmb3IgdGhpcyB0eXBlIG9mXG4gICAqIHRvb2wgY2FsbC5cbiAgICovXG4gIHR5cGU6ICdmaWxlX3NlYXJjaCc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsIG9iamVjdC5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uVG9vbENhbGwge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwgb2JqZWN0LlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGRlZmluaXRpb24gb2YgdGhlIGZ1bmN0aW9uIHRoYXQgd2FzIGNhbGxlZC5cbiAgICovXG4gIGZ1bmN0aW9uOiBGdW5jdGlvblRvb2xDYWxsLkZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0b29sIGNhbGwuIFRoaXMgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIGBmdW5jdGlvbmAgZm9yIHRoaXMgdHlwZSBvZlxuICAgKiB0b29sIGNhbGwuXG4gICAqL1xuICB0eXBlOiAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZ1bmN0aW9uVG9vbENhbGwge1xuICAvKipcbiAgICogVGhlIGRlZmluaXRpb24gb2YgdGhlIGZ1bmN0aW9uIHRoYXQgd2FzIGNhbGxlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBhcmd1bWVudHM6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0IG9mIHRoZSBmdW5jdGlvbi4gVGhpcyB3aWxsIGJlIGBudWxsYCBpZiB0aGUgb3V0cHV0cyBoYXZlIG5vdCBiZWVuXG4gICAgICogW3N1Ym1pdHRlZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zL3N1Ym1pdFRvb2xPdXRwdXRzKVxuICAgICAqIHlldC5cbiAgICAgKi9cbiAgICBvdXRwdXQ6IHN0cmluZyB8IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvblRvb2xDYWxsRGVsdGEge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSB0b29sIGNhbGwgaW4gdGhlIHRvb2wgY2FsbHMgYXJyYXkuXG4gICAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0b29sIGNhbGwuIFRoaXMgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIGBmdW5jdGlvbmAgZm9yIHRoaXMgdHlwZSBvZlxuICAgKiB0b29sIGNhbGwuXG4gICAqL1xuICB0eXBlOiAnZnVuY3Rpb24nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbCBvYmplY3QuXG4gICAqL1xuICBpZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGRlZmluaXRpb24gb2YgdGhlIGZ1bmN0aW9uIHRoYXQgd2FzIGNhbGxlZC5cbiAgICovXG4gIGZ1bmN0aW9uPzogRnVuY3Rpb25Ub29sQ2FsbERlbHRhLkZ1bmN0aW9uO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZ1bmN0aW9uVG9vbENhbGxEZWx0YSB7XG4gIC8qKlxuICAgKiBUaGUgZGVmaW5pdGlvbiBvZiB0aGUgZnVuY3Rpb24gdGhhdCB3YXMgY2FsbGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGFyZ3VtZW50cz86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBuYW1lPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dCBvZiB0aGUgZnVuY3Rpb24uIFRoaXMgd2lsbCBiZSBgbnVsbGAgaWYgdGhlIG91dHB1dHMgaGF2ZSBub3QgYmVlblxuICAgICAqIFtzdWJtaXR0ZWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvcnVucy9zdWJtaXRUb29sT3V0cHV0cylcbiAgICAgKiB5ZXQuXG4gICAgICovXG4gICAgb3V0cHV0Pzogc3RyaW5nIHwgbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIERldGFpbHMgb2YgdGhlIG1lc3NhZ2UgY3JlYXRpb24gYnkgdGhlIHJ1biBzdGVwLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VDcmVhdGlvblN0ZXBEZXRhaWxzIHtcbiAgbWVzc2FnZV9jcmVhdGlvbjogTWVzc2FnZUNyZWF0aW9uU3RlcERldGFpbHMuTWVzc2FnZUNyZWF0aW9uO1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYG1lc3NhZ2VfY3JlYXRpb25gLlxuICAgKi9cbiAgdHlwZTogJ21lc3NhZ2VfY3JlYXRpb24nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIE1lc3NhZ2VDcmVhdGlvblN0ZXBEZXRhaWxzIHtcbiAgZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlQ3JlYXRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgbWVzc2FnZSB0aGF0IHdhcyBjcmVhdGVkIGJ5IHRoaXMgcnVuIHN0ZXAuXG4gICAgICovXG4gICAgbWVzc2FnZV9pZDogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHN0ZXAgaW4gZXhlY3V0aW9uIG9mIGEgcnVuLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJ1blN0ZXAge1xuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIgb2YgdGhlIHJ1biBzdGVwLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgcnVuIHN0ZXAuXG4gICAqL1xuICBhc3Npc3RhbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHN0ZXAgd2FzIGNhbmNlbGxlZC5cbiAgICovXG4gIGNhbmNlbGxlZF9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHN0ZXAgY29tcGxldGVkLlxuICAgKi9cbiAgY29tcGxldGVkX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBydW4gc3RlcCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHN0ZXAgZXhwaXJlZC4gQSBzdGVwIGlzXG4gICAqIGNvbnNpZGVyZWQgZXhwaXJlZCBpZiB0aGUgcGFyZW50IHJ1biBpcyBleHBpcmVkLlxuICAgKi9cbiAgZXhwaXJlZF9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHN0ZXAgZmFpbGVkLlxuICAgKi9cbiAgZmFpbGVkX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbGFzdCBlcnJvciBhc3NvY2lhdGVkIHdpdGggdGhpcyBydW4gc3RlcC4gV2lsbCBiZSBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4gICAqIGVycm9ycy5cbiAgICovXG4gIGxhc3RfZXJyb3I6IFJ1blN0ZXAuTGFzdEVycm9yIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE6IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgdGhyZWFkLnJ1bi5zdGVwYC5cbiAgICovXG4gIG9iamVjdDogJ3RocmVhZC5ydW4uc3RlcCc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgW3J1bl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9ydW5zKSB0aGF0XG4gICAqIHRoaXMgcnVuIHN0ZXAgaXMgYSBwYXJ0IG9mLlxuICAgKi9cbiAgcnVuX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBzdGF0dXMgb2YgdGhlIHJ1biBzdGVwLCB3aGljaCBjYW4gYmUgZWl0aGVyIGBpbl9wcm9ncmVzc2AsIGBjYW5jZWxsZWRgLFxuICAgKiBgZmFpbGVkYCwgYGNvbXBsZXRlZGAsIG9yIGBleHBpcmVkYC5cbiAgICovXG4gIHN0YXR1czogJ2luX3Byb2dyZXNzJyB8ICdjYW5jZWxsZWQnIHwgJ2ZhaWxlZCcgfCAnY29tcGxldGVkJyB8ICdleHBpcmVkJztcblxuICAvKipcbiAgICogVGhlIGRldGFpbHMgb2YgdGhlIHJ1biBzdGVwLlxuICAgKi9cbiAgc3RlcF9kZXRhaWxzOiBNZXNzYWdlQ3JlYXRpb25TdGVwRGV0YWlscyB8IFRvb2xDYWxsc1N0ZXBEZXRhaWxzO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcylcbiAgICogdGhhdCB3YXMgcnVuLlxuICAgKi9cbiAgdGhyZWFkX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHJ1biBzdGVwLCB3aGljaCBjYW4gYmUgZWl0aGVyIGBtZXNzYWdlX2NyZWF0aW9uYCBvciBgdG9vbF9jYWxsc2AuXG4gICAqL1xuICB0eXBlOiAnbWVzc2FnZV9jcmVhdGlvbicgfCAndG9vbF9jYWxscyc7XG5cbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgcmVsYXRlZCB0byB0aGUgcnVuIHN0ZXAuIFRoaXMgdmFsdWUgd2lsbCBiZSBgbnVsbGAgd2hpbGUgdGhlXG4gICAqIHJ1biBzdGVwJ3Mgc3RhdHVzIGlzIGBpbl9wcm9ncmVzc2AuXG4gICAqL1xuICB1c2FnZTogUnVuU3RlcC5Vc2FnZSB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuU3RlcCB7XG4gIC8qKlxuICAgKiBUaGUgbGFzdCBlcnJvciBhc3NvY2lhdGVkIHdpdGggdGhpcyBydW4gc3RlcC4gV2lsbCBiZSBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4gICAqIGVycm9ycy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgTGFzdEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBPbmUgb2YgYHNlcnZlcl9lcnJvcmAgb3IgYHJhdGVfbGltaXRfZXhjZWVkZWRgLlxuICAgICAqL1xuICAgIGNvZGU6ICdzZXJ2ZXJfZXJyb3InIHwgJ3JhdGVfbGltaXRfZXhjZWVkZWQnO1xuXG4gICAgLyoqXG4gICAgICogQSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3IuXG4gICAgICovXG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgcmVsYXRlZCB0byB0aGUgcnVuIHN0ZXAuIFRoaXMgdmFsdWUgd2lsbCBiZSBgbnVsbGAgd2hpbGUgdGhlXG4gICAqIHJ1biBzdGVwJ3Mgc3RhdHVzIGlzIGBpbl9wcm9ncmVzc2AuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFVzYWdlIHtcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1biBzdGVwLlxuICAgICAqL1xuICAgIGNvbXBsZXRpb25fdG9rZW5zOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgcHJvbXB0IHRva2VucyB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgcnVuIHN0ZXAuXG4gICAgICovXG4gICAgcHJvbXB0X3Rva2VuczogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVG90YWwgbnVtYmVyIG9mIHRva2VucyB1c2VkIChwcm9tcHQgKyBjb21wbGV0aW9uKS5cbiAgICAgKi9cbiAgICB0b3RhbF90b2tlbnM6IG51bWJlcjtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBkZWx0YSBjb250YWluaW5nIHRoZSBmaWVsZHMgdGhhdCBoYXZlIGNoYW5nZWQgb24gdGhlIHJ1biBzdGVwLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJ1blN0ZXBEZWx0YSB7XG4gIC8qKlxuICAgKiBUaGUgZGV0YWlscyBvZiB0aGUgcnVuIHN0ZXAuXG4gICAqL1xuICBzdGVwX2RldGFpbHM/OiBSdW5TdGVwRGVsdGFNZXNzYWdlRGVsdGEgfCBUb29sQ2FsbERlbHRhT2JqZWN0O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBydW4gc3RlcCBkZWx0YSBpLmUuIGFueSBjaGFuZ2VkIGZpZWxkcyBvbiBhIHJ1biBzdGVwIGR1cmluZ1xuICogc3RyZWFtaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJ1blN0ZXBEZWx0YUV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBydW4gc3RlcCwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWx0YSBjb250YWluaW5nIHRoZSBmaWVsZHMgdGhhdCBoYXZlIGNoYW5nZWQgb24gdGhlIHJ1biBzdGVwLlxuICAgKi9cbiAgZGVsdGE6IFJ1blN0ZXBEZWx0YTtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYHRocmVhZC5ydW4uc3RlcC5kZWx0YWAuXG4gICAqL1xuICBvYmplY3Q6ICd0aHJlYWQucnVuLnN0ZXAuZGVsdGEnO1xufVxuXG4vKipcbiAqIERldGFpbHMgb2YgdGhlIG1lc3NhZ2UgY3JlYXRpb24gYnkgdGhlIHJ1biBzdGVwLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJ1blN0ZXBEZWx0YU1lc3NhZ2VEZWx0YSB7XG4gIC8qKlxuICAgKiBBbHdheXMgYG1lc3NhZ2VfY3JlYXRpb25gLlxuICAgKi9cbiAgdHlwZTogJ21lc3NhZ2VfY3JlYXRpb24nO1xuXG4gIG1lc3NhZ2VfY3JlYXRpb24/OiBSdW5TdGVwRGVsdGFNZXNzYWdlRGVsdGEuTWVzc2FnZUNyZWF0aW9uO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJ1blN0ZXBEZWx0YU1lc3NhZ2VEZWx0YSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZUNyZWF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIG1lc3NhZ2UgdGhhdCB3YXMgY3JlYXRlZCBieSB0aGlzIHJ1biBzdGVwLlxuICAgICAqL1xuICAgIG1lc3NhZ2VfaWQ/OiBzdHJpbmc7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgUnVuU3RlcEluY2x1ZGUgPSAnc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHNbKl0uZmlsZV9zZWFyY2gucmVzdWx0c1sqXS5jb250ZW50JztcblxuLyoqXG4gKiBEZXRhaWxzIG9mIHRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbCB0aGUgcnVuIHN0ZXAgd2FzIGludm9sdmVkIGluLlxuICovXG5leHBvcnQgdHlwZSBUb29sQ2FsbCA9IENvZGVJbnRlcnByZXRlclRvb2xDYWxsIHwgRmlsZVNlYXJjaFRvb2xDYWxsIHwgRnVuY3Rpb25Ub29sQ2FsbDtcblxuLyoqXG4gKiBEZXRhaWxzIG9mIHRoZSBDb2RlIEludGVycHJldGVyIHRvb2wgY2FsbCB0aGUgcnVuIHN0ZXAgd2FzIGludm9sdmVkIGluLlxuICovXG5leHBvcnQgdHlwZSBUb29sQ2FsbERlbHRhID0gQ29kZUludGVycHJldGVyVG9vbENhbGxEZWx0YSB8IEZpbGVTZWFyY2hUb29sQ2FsbERlbHRhIHwgRnVuY3Rpb25Ub29sQ2FsbERlbHRhO1xuXG4vKipcbiAqIERldGFpbHMgb2YgdGhlIHRvb2wgY2FsbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUb29sQ2FsbERlbHRhT2JqZWN0IHtcbiAgLyoqXG4gICAqIEFsd2F5cyBgdG9vbF9jYWxsc2AuXG4gICAqL1xuICB0eXBlOiAndG9vbF9jYWxscyc7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIHRvb2wgY2FsbHMgdGhlIHJ1biBzdGVwIHdhcyBpbnZvbHZlZCBpbi4gVGhlc2UgY2FuIGJlIGFzc29jaWF0ZWRcbiAgICogd2l0aCBvbmUgb2YgdGhyZWUgdHlwZXMgb2YgdG9vbHM6IGBjb2RlX2ludGVycHJldGVyYCwgYGZpbGVfc2VhcmNoYCwgb3JcbiAgICogYGZ1bmN0aW9uYC5cbiAgICovXG4gIHRvb2xfY2FsbHM/OiBBcnJheTxUb29sQ2FsbERlbHRhPjtcbn1cblxuLyoqXG4gKiBEZXRhaWxzIG9mIHRoZSB0b29sIGNhbGwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbENhbGxzU3RlcERldGFpbHMge1xuICAvKipcbiAgICogQW4gYXJyYXkgb2YgdG9vbCBjYWxscyB0aGUgcnVuIHN0ZXAgd2FzIGludm9sdmVkIGluLiBUaGVzZSBjYW4gYmUgYXNzb2NpYXRlZFxuICAgKiB3aXRoIG9uZSBvZiB0aHJlZSB0eXBlcyBvZiB0b29sczogYGNvZGVfaW50ZXJwcmV0ZXJgLCBgZmlsZV9zZWFyY2hgLCBvclxuICAgKiBgZnVuY3Rpb25gLlxuICAgKi9cbiAgdG9vbF9jYWxsczogQXJyYXk8VG9vbENhbGw+O1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYHRvb2xfY2FsbHNgLlxuICAgKi9cbiAgdHlwZTogJ3Rvb2xfY2FsbHMnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0ZXBSZXRyaWV2ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgYWRkaXRpb25hbCBmaWVsZHMgdG8gaW5jbHVkZSBpbiB0aGUgcmVzcG9uc2UuIEN1cnJlbnRseSB0aGUgb25seVxuICAgKiBzdXBwb3J0ZWQgdmFsdWUgaXMgYHN0ZXBfZGV0YWlscy50b29sX2NhbGxzWypdLmZpbGVfc2VhcmNoLnJlc3VsdHNbKl0uY29udGVudGBcbiAgICogdG8gZmV0Y2ggdGhlIGZpbGUgc2VhcmNoIHJlc3VsdCBjb250ZW50LlxuICAgKlxuICAgKiBTZWUgdGhlXG4gICAqIFtmaWxlIHNlYXJjaCB0b29sIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvdG9vbHMvZmlsZS1zZWFyY2gjY3VzdG9taXppbmctZmlsZS1zZWFyY2gtc2V0dGluZ3MpXG4gICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgaW5jbHVkZT86IEFycmF5PFJ1blN0ZXBJbmNsdWRlPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGVwTGlzdFBhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge1xuICAvKipcbiAgICogQSBjdXJzb3IgZm9yIHVzZSBpbiBwYWdpbmF0aW9uLiBgYmVmb3JlYCBpcyBhbiBvYmplY3QgSUQgdGhhdCBkZWZpbmVzIHlvdXIgcGxhY2VcbiAgICogaW4gdGhlIGxpc3QuIEZvciBpbnN0YW5jZSwgaWYgeW91IG1ha2UgYSBsaXN0IHJlcXVlc3QgYW5kIHJlY2VpdmUgMTAwIG9iamVjdHMsXG4gICAqIHN0YXJ0aW5nIHdpdGggb2JqX2ZvbywgeW91ciBzdWJzZXF1ZW50IGNhbGwgY2FuIGluY2x1ZGUgYmVmb3JlPW9ial9mb28gaW4gb3JkZXJcbiAgICogdG8gZmV0Y2ggdGhlIHByZXZpb3VzIHBhZ2Ugb2YgdGhlIGxpc3QuXG4gICAqL1xuICBiZWZvcmU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBhZGRpdGlvbmFsIGZpZWxkcyB0byBpbmNsdWRlIGluIHRoZSByZXNwb25zZS4gQ3VycmVudGx5IHRoZSBvbmx5XG4gICAqIHN1cHBvcnRlZCB2YWx1ZSBpcyBgc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHNbKl0uZmlsZV9zZWFyY2gucmVzdWx0c1sqXS5jb250ZW50YFxuICAgKiB0byBmZXRjaCB0aGUgZmlsZSBzZWFyY2ggcmVzdWx0IGNvbnRlbnQuXG4gICAqXG4gICAqIFNlZSB0aGVcbiAgICogW2ZpbGUgc2VhcmNoIHRvb2wgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy90b29scy9maWxlLXNlYXJjaCNjdXN0b21pemluZy1maWxlLXNlYXJjaC1zZXR0aW5ncylcbiAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbmNsdWRlPzogQXJyYXk8UnVuU3RlcEluY2x1ZGU+O1xuXG4gIC8qKlxuICAgKiBTb3J0IG9yZGVyIGJ5IHRoZSBgY3JlYXRlZF9hdGAgdGltZXN0YW1wIG9mIHRoZSBvYmplY3RzLiBgYXNjYCBmb3IgYXNjZW5kaW5nXG4gICAqIG9yZGVyIGFuZCBgZGVzY2AgZm9yIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAqL1xuICBvcmRlcj86ICdhc2MnIHwgJ2Rlc2MnO1xufVxuXG5TdGVwcy5SdW5TdGVwc1BhZ2UgPSBSdW5TdGVwc1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBTdGVwcyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBDb2RlSW50ZXJwcmV0ZXJMb2dzIGFzIENvZGVJbnRlcnByZXRlckxvZ3MsXG4gICAgdHlwZSBDb2RlSW50ZXJwcmV0ZXJPdXRwdXRJbWFnZSBhcyBDb2RlSW50ZXJwcmV0ZXJPdXRwdXRJbWFnZSxcbiAgICB0eXBlIENvZGVJbnRlcnByZXRlclRvb2xDYWxsIGFzIENvZGVJbnRlcnByZXRlclRvb2xDYWxsLFxuICAgIHR5cGUgQ29kZUludGVycHJldGVyVG9vbENhbGxEZWx0YSBhcyBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbERlbHRhLFxuICAgIHR5cGUgRmlsZVNlYXJjaFRvb2xDYWxsIGFzIEZpbGVTZWFyY2hUb29sQ2FsbCxcbiAgICB0eXBlIEZpbGVTZWFyY2hUb29sQ2FsbERlbHRhIGFzIEZpbGVTZWFyY2hUb29sQ2FsbERlbHRhLFxuICAgIHR5cGUgRnVuY3Rpb25Ub29sQ2FsbCBhcyBGdW5jdGlvblRvb2xDYWxsLFxuICAgIHR5cGUgRnVuY3Rpb25Ub29sQ2FsbERlbHRhIGFzIEZ1bmN0aW9uVG9vbENhbGxEZWx0YSxcbiAgICB0eXBlIE1lc3NhZ2VDcmVhdGlvblN0ZXBEZXRhaWxzIGFzIE1lc3NhZ2VDcmVhdGlvblN0ZXBEZXRhaWxzLFxuICAgIHR5cGUgUnVuU3RlcCBhcyBSdW5TdGVwLFxuICAgIHR5cGUgUnVuU3RlcERlbHRhIGFzIFJ1blN0ZXBEZWx0YSxcbiAgICB0eXBlIFJ1blN0ZXBEZWx0YUV2ZW50IGFzIFJ1blN0ZXBEZWx0YUV2ZW50LFxuICAgIHR5cGUgUnVuU3RlcERlbHRhTWVzc2FnZURlbHRhIGFzIFJ1blN0ZXBEZWx0YU1lc3NhZ2VEZWx0YSxcbiAgICB0eXBlIFJ1blN0ZXBJbmNsdWRlIGFzIFJ1blN0ZXBJbmNsdWRlLFxuICAgIHR5cGUgVG9vbENhbGwgYXMgVG9vbENhbGwsXG4gICAgdHlwZSBUb29sQ2FsbERlbHRhIGFzIFRvb2xDYWxsRGVsdGEsXG4gICAgdHlwZSBUb29sQ2FsbERlbHRhT2JqZWN0IGFzIFRvb2xDYWxsRGVsdGFPYmplY3QsXG4gICAgdHlwZSBUb29sQ2FsbHNTdGVwRGV0YWlscyBhcyBUb29sQ2FsbHNTdGVwRGV0YWlscyxcbiAgICBSdW5TdGVwc1BhZ2UgYXMgUnVuU3RlcHNQYWdlLFxuICAgIHR5cGUgU3RlcFJldHJpZXZlUGFyYW1zIGFzIFN0ZXBSZXRyaWV2ZVBhcmFtcyxcbiAgICB0eXBlIFN0ZXBMaXN0UGFyYW1zIGFzIFN0ZXBMaXN0UGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0IHsgQVBJUHJvbWlzZSB9IGZyb20gJy4uLy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi8uLi8uLi9jb3JlJztcbmltcG9ydCB7IEFzc2lzdGFudFN0cmVhbSwgUnVuQ3JlYXRlUGFyYW1zQmFzZVN0cmVhbSB9IGZyb20gJy4uLy4uLy4uLy4uL2xpYi9Bc3Npc3RhbnRTdHJlYW0nO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tICcuLi8uLi8uLi8uLi9jb3JlJztcbmltcG9ydCB7IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGliL0Fzc2lzdGFudFN0cmVhbSc7XG5pbXBvcnQgKiBhcyBSdW5zQVBJIGZyb20gJy4vcnVucyc7XG5pbXBvcnQgKiBhcyBBc3Npc3RhbnRzQVBJIGZyb20gJy4uLy4uL2Fzc2lzdGFudHMnO1xuaW1wb3J0ICogYXMgQ2hhdEFQSSBmcm9tICcuLi8uLi8uLi9jaGF0L2NoYXQnO1xuaW1wb3J0ICogYXMgTWVzc2FnZXNBUEkgZnJvbSAnLi4vbWVzc2FnZXMnO1xuaW1wb3J0ICogYXMgVGhyZWFkc0FQSSBmcm9tICcuLi90aHJlYWRzJztcbmltcG9ydCAqIGFzIFN0ZXBzQVBJIGZyb20gJy4vc3RlcHMnO1xuaW1wb3J0IHtcbiAgQ29kZUludGVycHJldGVyTG9ncyxcbiAgQ29kZUludGVycHJldGVyT3V0cHV0SW1hZ2UsXG4gIENvZGVJbnRlcnByZXRlclRvb2xDYWxsLFxuICBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbERlbHRhLFxuICBGaWxlU2VhcmNoVG9vbENhbGwsXG4gIEZpbGVTZWFyY2hUb29sQ2FsbERlbHRhLFxuICBGdW5jdGlvblRvb2xDYWxsLFxuICBGdW5jdGlvblRvb2xDYWxsRGVsdGEsXG4gIE1lc3NhZ2VDcmVhdGlvblN0ZXBEZXRhaWxzLFxuICBSdW5TdGVwLFxuICBSdW5TdGVwRGVsdGEsXG4gIFJ1blN0ZXBEZWx0YUV2ZW50LFxuICBSdW5TdGVwRGVsdGFNZXNzYWdlRGVsdGEsXG4gIFJ1blN0ZXBJbmNsdWRlLFxuICBSdW5TdGVwc1BhZ2UsXG4gIFN0ZXBMaXN0UGFyYW1zLFxuICBTdGVwUmV0cmlldmVQYXJhbXMsXG4gIFN0ZXBzLFxuICBUb29sQ2FsbCxcbiAgVG9vbENhbGxEZWx0YSxcbiAgVG9vbENhbGxEZWx0YU9iamVjdCxcbiAgVG9vbENhbGxzU3RlcERldGFpbHMsXG59IGZyb20gJy4vc3RlcHMnO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSwgdHlwZSBDdXJzb3JQYWdlUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vLi4vcGFnaW5hdGlvbic7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tICcuLi8uLi8uLi8uLi9zdHJlYW1pbmcnO1xuXG5leHBvcnQgY2xhc3MgUnVucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgc3RlcHM6IFN0ZXBzQVBJLlN0ZXBzID0gbmV3IFN0ZXBzQVBJLlN0ZXBzKHRoaXMuX2NsaWVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJ1bi5cbiAgICovXG4gIGNyZWF0ZShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHBhcmFtczogUnVuQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFJ1bj47XG4gIGNyZWF0ZShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHBhcmFtczogUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50Pj47XG4gIGNyZWF0ZShcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHBhcmFtczogUnVuQ3JlYXRlUGFyYW1zQmFzZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4gfCBSdW4+O1xuICBjcmVhdGUoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBwYXJhbXM6IFJ1bkNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxSdW4+IHwgQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4+IHtcbiAgICBjb25zdCB7IGluY2x1ZGUsIC4uLmJvZHkgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnNgLCB7XG4gICAgICBxdWVyeTogeyBpbmNsdWRlIH0sXG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICBzdHJlYW06IHBhcmFtcy5zdHJlYW0gPz8gZmFsc2UsXG4gICAgfSkgYXMgQVBJUHJvbWlzZTxSdW4+IHwgQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4+O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIHJ1bi5cbiAgICovXG4gIHJldHJpZXZlKHRocmVhZElkOiBzdHJpbmcsIHJ1bklkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFJ1bj4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZpZXMgYSBydW4uXG4gICAqL1xuICB1cGRhdGUoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIGJvZHk6IFJ1blVwZGF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFJ1bj4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfWAsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBydW5zIGJlbG9uZ2luZyB0byBhIHRocmVhZC5cbiAgICovXG4gIGxpc3QoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBxdWVyeT86IFJ1bkxpc3RQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8UnVuc1BhZ2UsIFJ1bj47XG4gIGxpc3QodGhyZWFkSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPFJ1bnNQYWdlLCBSdW4+O1xuICBsaXN0KFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcXVlcnk6IFJ1bkxpc3RQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8UnVuc1BhZ2UsIFJ1bj4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdCh0aHJlYWRJZCwge30sIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zYCwgUnVuc1BhZ2UsIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyBhIHJ1biB0aGF0IGlzIGBpbl9wcm9ncmVzc2AuXG4gICAqL1xuICBjYW5jZWwodGhyZWFkSWQ6IHN0cmluZywgcnVuSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8UnVuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9L2NhbmNlbGAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIHRvIGNyZWF0ZSBhIHJ1biBhbiBwb2xsIGZvciBhIHRlcm1pbmFsIHN0YXRlLiBNb3JlIGluZm9ybWF0aW9uIG9uIFJ1blxuICAgKiBsaWZlY3ljbGVzIGNhbiBiZSBmb3VuZCBoZXJlOlxuICAgKiBodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL2hvdy1pdC13b3Jrcy9ydW5zLWFuZC1ydW4tc3RlcHNcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUFuZFBvbGwoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBib2R5OiBSdW5DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMgJiB7IHBvbGxJbnRlcnZhbE1zPzogbnVtYmVyIH0sXG4gICk6IFByb21pc2U8UnVuPiB7XG4gICAgY29uc3QgcnVuID0gYXdhaXQgdGhpcy5jcmVhdGUodGhyZWFkSWQsIGJvZHksIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnBvbGwodGhyZWFkSWQsIHJ1bi5pZCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgUnVuIHN0cmVhbVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYHN0cmVhbWAgaW5zdGVhZFxuICAgKi9cbiAgY3JlYXRlQW5kU3RyZWFtKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgYm9keTogUnVuQ3JlYXRlUGFyYW1zQmFzZVN0cmVhbSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQXNzaXN0YW50U3RyZWFtIHtcbiAgICByZXR1cm4gQXNzaXN0YW50U3RyZWFtLmNyZWF0ZUFzc2lzdGFudFN0cmVhbSh0aHJlYWRJZCwgdGhpcy5fY2xpZW50LmJldGEudGhyZWFkcy5ydW5zLCBib2R5LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGhlbHBlciB0byBwb2xsIGEgcnVuIHN0YXR1cyB1bnRpbCBpdCByZWFjaGVzIGEgdGVybWluYWwgc3RhdGUuIE1vcmVcbiAgICogaW5mb3JtYXRpb24gb24gUnVuIGxpZmVjeWNsZXMgY2FuIGJlIGZvdW5kIGhlcmU6XG4gICAqIGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvaG93LWl0LXdvcmtzL3J1bnMtYW5kLXJ1bi1zdGVwc1xuICAgKi9cbiAgYXN5bmMgcG9sbChcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMgJiB7IHBvbGxJbnRlcnZhbE1zPzogbnVtYmVyIH0sXG4gICk6IFByb21pc2U8UnVuPiB7XG4gICAgY29uc3QgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLVBvbGwtSGVscGVyJzogJ3RydWUnIH07XG5cbiAgICBpZiAob3B0aW9ucz8ucG9sbEludGVydmFsTXMpIHtcbiAgICAgIGhlYWRlcnNbJ1gtU3RhaW5sZXNzLUN1c3RvbS1Qb2xsLUludGVydmFsJ10gPSBvcHRpb25zLnBvbGxJbnRlcnZhbE1zLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZGF0YTogcnVuLCByZXNwb25zZSB9ID0gYXdhaXQgdGhpcy5yZXRyaWV2ZSh0aHJlYWRJZCwgcnVuSWQsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAuLi5oZWFkZXJzIH0sXG4gICAgICB9KS53aXRoUmVzcG9uc2UoKTtcblxuICAgICAgc3dpdGNoIChydW4uc3RhdHVzKSB7XG4gICAgICAgIC8vSWYgd2UgYXJlIGluIGFueSBzb3J0IG9mIGludGVybWVkaWF0ZSBzdGF0ZSB3ZSBwb2xsXG4gICAgICAgIGNhc2UgJ3F1ZXVlZCc6XG4gICAgICAgIGNhc2UgJ2luX3Byb2dyZXNzJzpcbiAgICAgICAgY2FzZSAnY2FuY2VsbGluZyc6XG4gICAgICAgICAgbGV0IHNsZWVwSW50ZXJ2YWwgPSA1MDAwO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnM/LnBvbGxJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICBzbGVlcEludGVydmFsID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVySW50ZXJ2YWwgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnb3BlbmFpLXBvbGwtYWZ0ZXItbXMnKTtcbiAgICAgICAgICAgIGlmIChoZWFkZXJJbnRlcnZhbCkge1xuICAgICAgICAgICAgICBjb25zdCBoZWFkZXJJbnRlcnZhbE1zID0gcGFyc2VJbnQoaGVhZGVySW50ZXJ2YWwpO1xuICAgICAgICAgICAgICBpZiAoIWlzTmFOKGhlYWRlckludGVydmFsTXMpKSB7XG4gICAgICAgICAgICAgICAgc2xlZXBJbnRlcnZhbCA9IGhlYWRlckludGVydmFsTXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgc2xlZXAoc2xlZXBJbnRlcnZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vV2UgcmV0dXJuIHRoZSBydW4gaW4gYW55IHRlcm1pbmFsIHN0YXRlLlxuICAgICAgICBjYXNlICdyZXF1aXJlc19hY3Rpb24nOlxuICAgICAgICBjYXNlICdpbmNvbXBsZXRlJzpcbiAgICAgICAgY2FzZSAnY2FuY2VsbGVkJzpcbiAgICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgY2FzZSAnZXhwaXJlZCc6XG4gICAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgUnVuIHN0cmVhbVxuICAgKi9cbiAgc3RyZWFtKHRocmVhZElkOiBzdHJpbmcsIGJvZHk6IFJ1bkNyZWF0ZVBhcmFtc0Jhc2VTdHJlYW0sIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQXNzaXN0YW50U3RyZWFtIHtcbiAgICByZXR1cm4gQXNzaXN0YW50U3RyZWFtLmNyZWF0ZUFzc2lzdGFudFN0cmVhbSh0aHJlYWRJZCwgdGhpcy5fY2xpZW50LmJldGEudGhyZWFkcy5ydW5zLCBib2R5LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGEgcnVuIGhhcyB0aGUgYHN0YXR1czogXCJyZXF1aXJlc19hY3Rpb25cImAgYW5kIGByZXF1aXJlZF9hY3Rpb24udHlwZWAgaXNcbiAgICogYHN1Ym1pdF90b29sX291dHB1dHNgLCB0aGlzIGVuZHBvaW50IGNhbiBiZSB1c2VkIHRvIHN1Ym1pdCB0aGUgb3V0cHV0cyBmcm9tIHRoZVxuICAgKiB0b29sIGNhbGxzIG9uY2UgdGhleSdyZSBhbGwgY29tcGxldGVkLiBBbGwgb3V0cHV0cyBtdXN0IGJlIHN1Ym1pdHRlZCBpbiBhIHNpbmdsZVxuICAgKiByZXF1ZXN0LlxuICAgKi9cbiAgc3VibWl0VG9vbE91dHB1dHMoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIGJvZHk6IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFJ1bj47XG4gIHN1Ym1pdFRvb2xPdXRwdXRzKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBib2R5OiBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbWluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4+O1xuICBzdWJtaXRUb29sT3V0cHV0cyhcbiAgICB0aHJlYWRJZDogc3RyaW5nLFxuICAgIHJ1bklkOiBzdHJpbmcsXG4gICAgYm9keTogUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNCYXNlLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50PiB8IFJ1bj47XG4gIHN1Ym1pdFRvb2xPdXRwdXRzKFxuICAgIHRocmVhZElkOiBzdHJpbmcsXG4gICAgcnVuSWQ6IHN0cmluZyxcbiAgICBib2R5OiBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxSdW4+IHwgQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH0vc3VibWl0X3Rvb2xfb3V0cHV0c2AsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgIHN0cmVhbTogYm9keS5zdHJlYW0gPz8gZmFsc2UsXG4gICAgfSkgYXMgQVBJUHJvbWlzZTxSdW4+IHwgQVBJUHJvbWlzZTxTdHJlYW08QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRTdHJlYW1FdmVudD4+O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIHRvIHN1Ym1pdCBhIHRvb2wgb3V0cHV0IHRvIGEgcnVuIGFuZCBwb2xsIGZvciBhIHRlcm1pbmFsIHJ1biBzdGF0ZS5cbiAgICogTW9yZSBpbmZvcm1hdGlvbiBvbiBSdW4gbGlmZWN5Y2xlcyBjYW4gYmUgZm91bmQgaGVyZTpcbiAgICogaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy9ob3ctaXQtd29ya3MvcnVucy1hbmQtcnVuLXN0ZXBzXG4gICAqL1xuICBhc3luYyBzdWJtaXRUb29sT3V0cHV0c0FuZFBvbGwoXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIGJvZHk6IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zICYgeyBwb2xsSW50ZXJ2YWxNcz86IG51bWJlciB9LFxuICApOiBQcm9taXNlPFJ1bj4ge1xuICAgIGNvbnN0IHJ1biA9IGF3YWl0IHRoaXMuc3VibWl0VG9vbE91dHB1dHModGhyZWFkSWQsIHJ1bklkLCBib2R5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5wb2xsKHRocmVhZElkLCBydW4uaWQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1Ym1pdCB0aGUgdG9vbCBvdXRwdXRzIGZyb20gYSBwcmV2aW91cyBydW4gYW5kIHN0cmVhbSB0aGUgcnVuIHRvIGEgdGVybWluYWxcbiAgICogc3RhdGUuIE1vcmUgaW5mb3JtYXRpb24gb24gUnVuIGxpZmVjeWNsZXMgY2FuIGJlIGZvdW5kIGhlcmU6XG4gICAqIGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvaG93LWl0LXdvcmtzL3J1bnMtYW5kLXJ1bi1zdGVwc1xuICAgKi9cbiAgc3VibWl0VG9vbE91dHB1dHNTdHJlYW0oXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcbiAgICBydW5JZDogc3RyaW5nLFxuICAgIGJvZHk6IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBc3Npc3RhbnRTdHJlYW0ge1xuICAgIHJldHVybiBBc3Npc3RhbnRTdHJlYW0uY3JlYXRlVG9vbEFzc2lzdGFudFN0cmVhbShcbiAgICAgIHRocmVhZElkLFxuICAgICAgcnVuSWQsXG4gICAgICB0aGlzLl9jbGllbnQuYmV0YS50aHJlYWRzLnJ1bnMsXG4gICAgICBib2R5LFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSdW5zUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8UnVuPiB7fVxuXG4vKipcbiAqIFRvb2wgY2FsbCBvYmplY3RzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVxdWlyZWRBY3Rpb25GdW5jdGlvblRvb2xDYWxsIHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsLiBUaGlzIElEIG11c3QgYmUgcmVmZXJlbmNlZCB3aGVuIHlvdSBzdWJtaXQgdGhlIHRvb2xcbiAgICogb3V0cHV0cyBpbiB1c2luZyB0aGVcbiAgICogW1N1Ym1pdCB0b29sIG91dHB1dHMgdG8gcnVuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3J1bnMvc3VibWl0VG9vbE91dHB1dHMpXG4gICAqIGVuZHBvaW50LlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIGRlZmluaXRpb24uXG4gICAqL1xuICBmdW5jdGlvbjogUmVxdWlyZWRBY3Rpb25GdW5jdGlvblRvb2xDYWxsLkZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0b29sIGNhbGwgdGhlIG91dHB1dCBpcyByZXF1aXJlZCBmb3IuIEZvciBub3csIHRoaXMgaXMgYWx3YXlzXG4gICAqIGBmdW5jdGlvbmAuXG4gICAqL1xuICB0eXBlOiAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJlcXVpcmVkQWN0aW9uRnVuY3Rpb25Ub29sQ2FsbCB7XG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gZGVmaW5pdGlvbi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBhcmd1bWVudHMgdGhhdCB0aGUgbW9kZWwgZXhwZWN0cyB5b3UgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXJndW1lbnRzOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBleGVjdXRpb24gcnVuIG9uIGFcbiAqIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcykuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUnVuIHtcbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIHVzZWQgZm9yXG4gICAqIGV4ZWN1dGlvbiBvZiB0aGlzIHJ1bi5cbiAgICovXG4gIGFzc2lzdGFudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBydW4gd2FzIGNhbmNlbGxlZC5cbiAgICovXG4gIGNhbmNlbGxlZF9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHdhcyBjb21wbGV0ZWQuXG4gICAqL1xuICBjb21wbGV0ZWRfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIHJ1biB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHdpbGwgZXhwaXJlLlxuICAgKi9cbiAgZXhwaXJlc19hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIGZhaWxlZC5cbiAgICovXG4gIGZhaWxlZF9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogRGV0YWlscyBvbiB3aHkgdGhlIHJ1biBpcyBpbmNvbXBsZXRlLiBXaWxsIGJlIGBudWxsYCBpZiB0aGUgcnVuIGlzIG5vdFxuICAgKiBpbmNvbXBsZXRlLlxuICAgKi9cbiAgaW5jb21wbGV0ZV9kZXRhaWxzOiBSdW4uSW5jb21wbGV0ZURldGFpbHMgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5zdHJ1Y3Rpb25zIHRoYXQgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdXNlZCBmb3JcbiAgICogdGhpcyBydW4uXG4gICAqL1xuICBpbnN0cnVjdGlvbnM6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGxhc3QgZXJyb3IgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcnVuLiBXaWxsIGJlIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gZXJyb3JzLlxuICAgKi9cbiAgbGFzdF9lcnJvcjogUnVuLkxhc3RFcnJvciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2VucyBzcGVjaWZpZWQgdG8gaGF2ZSBiZWVuIHVzZWQgb3ZlciB0aGVcbiAgICogY291cnNlIG9mIHRoZSBydW4uXG4gICAqL1xuICBtYXhfY29tcGxldGlvbl90b2tlbnM6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zIHNwZWNpZmllZCB0byBoYXZlIGJlZW4gdXNlZCBvdmVyIHRoZSBjb3Vyc2VcbiAgICogb2YgdGhlIHJ1bi5cbiAgICovXG4gIG1heF9wcm9tcHRfdG9rZW5zOiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YTogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlbCB0aGF0IHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIHVzZWQgZm9yXG4gICAqIHRoaXMgcnVuLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYHRocmVhZC5ydW5gLlxuICAgKi9cbiAgb2JqZWN0OiAndGhyZWFkLnJ1bic7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlXG4gICAqIFtwYXJhbGxlbCBmdW5jdGlvbiBjYWxsaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZnVuY3Rpb24tY2FsbGluZyNjb25maWd1cmluZy1wYXJhbGxlbC1mdW5jdGlvbi1jYWxsaW5nKVxuICAgKiBkdXJpbmcgdG9vbCB1c2UuXG4gICAqL1xuICBwYXJhbGxlbF90b29sX2NhbGxzOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEZXRhaWxzIG9uIHRoZSBhY3Rpb24gcmVxdWlyZWQgdG8gY29udGludWUgdGhlIHJ1bi4gV2lsbCBiZSBgbnVsbGAgaWYgbm8gYWN0aW9uXG4gICAqIGlzIHJlcXVpcmVkLlxuICAgKi9cbiAgcmVxdWlyZWRfYWN0aW9uOiBSdW4uUmVxdWlyZWRBY3Rpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gICAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNG8pLFxuICAgKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICAgKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fc2NoZW1hXCIsIFwianNvbl9zY2hlbWFcIjogey4uLn0gfWAgZW5hYmxlcyBTdHJ1Y3R1cmVkXG4gICAqIE91dHB1dHMgd2hpY2ggZW5zdXJlcyB0aGUgbW9kZWwgd2lsbCBtYXRjaCB5b3VyIHN1cHBsaWVkIEpTT04gc2NoZW1hLiBMZWFybiBtb3JlXG4gICAqIGluIHRoZVxuICAgKiBbU3RydWN0dXJlZCBPdXRwdXRzIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc3RydWN0dXJlZC1vdXRwdXRzKS5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBlbnN1cmVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0OiBUaHJlYWRzQVBJLkFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgcnVuIHdhcyBzdGFydGVkLlxuICAgKi9cbiAgc3RhcnRlZF9hdDogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHN0YXR1cyBvZiB0aGUgcnVuLCB3aGljaCBjYW4gYmUgZWl0aGVyIGBxdWV1ZWRgLCBgaW5fcHJvZ3Jlc3NgLFxuICAgKiBgcmVxdWlyZXNfYWN0aW9uYCwgYGNhbmNlbGxpbmdgLCBgY2FuY2VsbGVkYCwgYGZhaWxlZGAsIGBjb21wbGV0ZWRgLFxuICAgKiBgaW5jb21wbGV0ZWAsIG9yIGBleHBpcmVkYC5cbiAgICovXG4gIHN0YXR1czogUnVuU3RhdHVzO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFt0aHJlYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdGhyZWFkcylcbiAgICogdGhhdCB3YXMgZXhlY3V0ZWQgb24gYXMgYSBwYXJ0IG9mIHRoaXMgcnVuLlxuICAgKi9cbiAgdGhyZWFkX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIHdoaWNoIChpZiBhbnkpIHRvb2wgaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC4gYG5vbmVgIG1lYW5zIHRoZSBtb2RlbCB3aWxsXG4gICAqIG5vdCBjYWxsIGFueSB0b29scyBhbmQgaW5zdGVhZCBnZW5lcmF0ZXMgYSBtZXNzYWdlLiBgYXV0b2AgaXMgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICogYW5kIG1lYW5zIHRoZSBtb2RlbCBjYW4gcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yIGNhbGxpbmcgb25lIG9yIG1vcmVcbiAgICogdG9vbHMuIGByZXF1aXJlZGAgbWVhbnMgdGhlIG1vZGVsIG11c3QgY2FsbCBvbmUgb3IgbW9yZSB0b29scyBiZWZvcmUgcmVzcG9uZGluZ1xuICAgKiB0byB0aGUgdXNlci4gU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgdG9vbCBsaWtlIGB7XCJ0eXBlXCI6IFwiZmlsZV9zZWFyY2hcIn1gIG9yXG4gICAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gICAqIGNhbGwgdGhhdCB0b29sLlxuICAgKi9cbiAgdG9vbF9jaG9pY2U6IFRocmVhZHNBUEkuQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIHRvb2xzIHRoYXQgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdXNlZCBmb3JcbiAgICogdGhpcyBydW4uXG4gICAqL1xuICB0b29sczogQXJyYXk8QXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRUb29sPjtcblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIHRydW5jYXRpb25fc3RyYXRlZ3k6IFJ1bi5UcnVuY2F0aW9uU3RyYXRlZ3kgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBVc2FnZSBzdGF0aXN0aWNzIHJlbGF0ZWQgdG8gdGhlIHJ1bi4gVGhpcyB2YWx1ZSB3aWxsIGJlIGBudWxsYCBpZiB0aGUgcnVuIGlzIG5vdFxuICAgKiBpbiBhIHRlcm1pbmFsIHN0YXRlIChpLmUuIGBpbl9wcm9ncmVzc2AsIGBxdWV1ZWRgLCBldGMuKS5cbiAgICovXG4gIHVzYWdlOiBSdW4uVXNhZ2UgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdXNlZCBmb3IgdGhpcyBydW4uIElmIG5vdCBzZXQsIGRlZmF1bHRzIHRvIDEuXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBudWNsZXVzIHNhbXBsaW5nIHZhbHVlIHVzZWQgZm9yIHRoaXMgcnVuLiBJZiBub3Qgc2V0LCBkZWZhdWx0cyB0byAxLlxuICAgKi9cbiAgdG9wX3A/OiBudW1iZXIgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJ1biB7XG4gIC8qKlxuICAgKiBEZXRhaWxzIG9uIHdoeSB0aGUgcnVuIGlzIGluY29tcGxldGUuIFdpbGwgYmUgYG51bGxgIGlmIHRoZSBydW4gaXMgbm90XG4gICAqIGluY29tcGxldGUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEluY29tcGxldGVEZXRhaWxzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVhc29uIHdoeSB0aGUgcnVuIGlzIGluY29tcGxldGUuIFRoaXMgd2lsbCBwb2ludCB0byB3aGljaCBzcGVjaWZpYyB0b2tlblxuICAgICAqIGxpbWl0IHdhcyByZWFjaGVkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgcnVuLlxuICAgICAqL1xuICAgIHJlYXNvbj86ICdtYXhfY29tcGxldGlvbl90b2tlbnMnIHwgJ21heF9wcm9tcHRfdG9rZW5zJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbGFzdCBlcnJvciBhc3NvY2lhdGVkIHdpdGggdGhpcyBydW4uIFdpbGwgYmUgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBlcnJvcnMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIExhc3RFcnJvciB7XG4gICAgLyoqXG4gICAgICogT25lIG9mIGBzZXJ2ZXJfZXJyb3JgLCBgcmF0ZV9saW1pdF9leGNlZWRlZGAsIG9yIGBpbnZhbGlkX3Byb21wdGAuXG4gICAgICovXG4gICAgY29kZTogJ3NlcnZlcl9lcnJvcicgfCAncmF0ZV9saW1pdF9leGNlZWRlZCcgfCAnaW52YWxpZF9wcm9tcHQnO1xuXG4gICAgLyoqXG4gICAgICogQSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3IuXG4gICAgICovXG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFpbHMgb24gdGhlIGFjdGlvbiByZXF1aXJlZCB0byBjb250aW51ZSB0aGUgcnVuLiBXaWxsIGJlIGBudWxsYCBpZiBubyBhY3Rpb25cbiAgICogaXMgcmVxdWlyZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFJlcXVpcmVkQWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBEZXRhaWxzIG9uIHRoZSB0b29sIG91dHB1dHMgbmVlZGVkIGZvciB0aGlzIHJ1biB0byBjb250aW51ZS5cbiAgICAgKi9cbiAgICBzdWJtaXRfdG9vbF9vdXRwdXRzOiBSZXF1aXJlZEFjdGlvbi5TdWJtaXRUb29sT3V0cHV0cztcblxuICAgIC8qKlxuICAgICAqIEZvciBub3csIHRoaXMgaXMgYWx3YXlzIGBzdWJtaXRfdG9vbF9vdXRwdXRzYC5cbiAgICAgKi9cbiAgICB0eXBlOiAnc3VibWl0X3Rvb2xfb3V0cHV0cyc7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFJlcXVpcmVkQWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBEZXRhaWxzIG9uIHRoZSB0b29sIG91dHB1dHMgbmVlZGVkIGZvciB0aGlzIHJ1biB0byBjb250aW51ZS5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIFN1Ym1pdFRvb2xPdXRwdXRzIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIHRoZSByZWxldmFudCB0b29sIGNhbGxzLlxuICAgICAgICovXG4gICAgICB0b29sX2NhbGxzOiBBcnJheTxSdW5zQVBJLlJlcXVpcmVkQWN0aW9uRnVuY3Rpb25Ub29sQ2FsbD47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRydW5jYXRpb25TdHJhdGVneSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRydW5jYXRpb24gc3RyYXRlZ3kgdG8gdXNlIGZvciB0aGUgdGhyZWFkLiBUaGUgZGVmYXVsdCBpcyBgYXV0b2AuIElmIHNldCB0b1xuICAgICAqIGBsYXN0X21lc3NhZ2VzYCwgdGhlIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCB0byB0aGUgbiBtb3N0IHJlY2VudCBtZXNzYWdlcyBpblxuICAgICAqIHRoZSB0aHJlYWQuIFdoZW4gc2V0IHRvIGBhdXRvYCwgbWVzc2FnZXMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdGhyZWFkIHdpbGwgYmVcbiAgICAgKiBkcm9wcGVkIHRvIGZpdCB0aGUgY29udGV4dCBsZW5ndGggb2YgdGhlIG1vZGVsLCBgbWF4X3Byb21wdF90b2tlbnNgLlxuICAgICAqL1xuICAgIHR5cGU6ICdhdXRvJyB8ICdsYXN0X21lc3NhZ2VzJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbW9zdCByZWNlbnQgbWVzc2FnZXMgZnJvbSB0aGUgdGhyZWFkIHdoZW4gY29uc3RydWN0aW5nIHRoZSBjb250ZXh0XG4gICAgICogZm9yIHRoZSBydW4uXG4gICAgICovXG4gICAgbGFzdF9tZXNzYWdlcz86IG51bWJlciB8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVXNhZ2Ugc3RhdGlzdGljcyByZWxhdGVkIHRvIHRoZSBydW4uIFRoaXMgdmFsdWUgd2lsbCBiZSBgbnVsbGAgaWYgdGhlIHJ1biBpcyBub3RcbiAgICogaW4gYSB0ZXJtaW5hbCBzdGF0ZSAoaS5lLiBgaW5fcHJvZ3Jlc3NgLCBgcXVldWVkYCwgZXRjLikuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFVzYWdlIHtcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBjb21wbGV0aW9uX3Rva2VuczogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHByb21wdCB0b2tlbnMgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBwcm9tcHRfdG9rZW5zOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUb3RhbCBudW1iZXIgb2YgdG9rZW5zIHVzZWQgKHByb21wdCArIGNvbXBsZXRpb24pLlxuICAgICAqL1xuICAgIHRvdGFsX3Rva2VuczogbnVtYmVyO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHN0YXR1cyBvZiB0aGUgcnVuLCB3aGljaCBjYW4gYmUgZWl0aGVyIGBxdWV1ZWRgLCBgaW5fcHJvZ3Jlc3NgLFxuICogYHJlcXVpcmVzX2FjdGlvbmAsIGBjYW5jZWxsaW5nYCwgYGNhbmNlbGxlZGAsIGBmYWlsZWRgLCBgY29tcGxldGVkYCxcbiAqIGBpbmNvbXBsZXRlYCwgb3IgYGV4cGlyZWRgLlxuICovXG5leHBvcnQgdHlwZSBSdW5TdGF0dXMgPVxuICB8ICdxdWV1ZWQnXG4gIHwgJ2luX3Byb2dyZXNzJ1xuICB8ICdyZXF1aXJlc19hY3Rpb24nXG4gIHwgJ2NhbmNlbGxpbmcnXG4gIHwgJ2NhbmNlbGxlZCdcbiAgfCAnZmFpbGVkJ1xuICB8ICdjb21wbGV0ZWQnXG4gIHwgJ2luY29tcGxldGUnXG4gIHwgJ2V4cGlyZWQnO1xuXG5leHBvcnQgdHlwZSBSdW5DcmVhdGVQYXJhbXMgPSBSdW5DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgfCBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBUaGUgSUQgb2YgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdG8gdXNlIHRvXG4gICAqIGV4ZWN1dGUgdGhpcyBydW4uXG4gICAqL1xuICBhc3Npc3RhbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogUXVlcnkgcGFyYW06IEEgbGlzdCBvZiBhZGRpdGlvbmFsIGZpZWxkcyB0byBpbmNsdWRlIGluIHRoZSByZXNwb25zZS4gQ3VycmVudGx5XG4gICAqIHRoZSBvbmx5IHN1cHBvcnRlZCB2YWx1ZSBpc1xuICAgKiBgc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHNbKl0uZmlsZV9zZWFyY2gucmVzdWx0c1sqXS5jb250ZW50YCB0byBmZXRjaCB0aGUgZmlsZVxuICAgKiBzZWFyY2ggcmVzdWx0IGNvbnRlbnQuXG4gICAqXG4gICAqIFNlZSB0aGVcbiAgICogW2ZpbGUgc2VhcmNoIHRvb2wgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy90b29scy9maWxlLXNlYXJjaCNjdXN0b21pemluZy1maWxlLXNlYXJjaC1zZXR0aW5ncylcbiAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbmNsdWRlPzogQXJyYXk8U3RlcHNBUEkuUnVuU3RlcEluY2x1ZGU+O1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBBcHBlbmRzIGFkZGl0aW9uYWwgaW5zdHJ1Y3Rpb25zIGF0IHRoZSBlbmQgb2YgdGhlIGluc3RydWN0aW9ucyBmb3JcbiAgICogdGhlIHJ1bi4gVGhpcyBpcyB1c2VmdWwgZm9yIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzIHdpdGhvdXRcbiAgICogb3ZlcnJpZGluZyBvdGhlciBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICBhZGRpdGlvbmFsX2luc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IEFkZHMgYWRkaXRpb25hbCBtZXNzYWdlcyB0byB0aGUgdGhyZWFkIGJlZm9yZSBjcmVhdGluZyB0aGUgcnVuLlxuICAgKi9cbiAgYWRkaXRpb25hbF9tZXNzYWdlcz86IEFycmF5PFJ1bkNyZWF0ZVBhcmFtcy5BZGRpdGlvbmFsTWVzc2FnZT4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBPdmVycmlkZXMgdGhlXG4gICAqIFtpbnN0cnVjdGlvbnNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cy9jcmVhdGVBc3Npc3RhbnQpXG4gICAqIG9mIHRoZSBhc3Npc3RhbnQuIFRoaXMgaXMgdXNlZnVsIGZvciBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlXG4gICAqIGNvdXJzZSBvZiB0aGUgcnVuLiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2ZcbiAgICogY29tcGxldGlvbiB0b2tlbnMgc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1blxuICAgKiBleGNlZWRzIHRoZSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzXG4gICAqIGBpbmNvbXBsZXRlYC4gU2VlIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfY29tcGxldGlvbl90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcHJvbXB0IHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZVxuICAgKiBvZiB0aGUgcnVuLiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgcHJvbXB0XG4gICAqIHRva2VucyBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlXG4gICAqIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuXG4gICAqIFNlZSBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X3Byb21wdF90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpc1xuICAgKiBjYW4gYmUgdXNlZnVsIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhXG4gICAqIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlXG4gICAqIGEgbWF4aXVtIG9mIDUxMiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBUaGUgSUQgb2YgdGhlXG4gICAqIFtNb2RlbF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tb2RlbHMpIHRvIGJlIHVzZWQgdG9cbiAgICogZXhlY3V0ZSB0aGlzIHJ1bi4gSWYgYSB2YWx1ZSBpcyBwcm92aWRlZCBoZXJlLCBpdCB3aWxsIG92ZXJyaWRlIHRoZSBtb2RlbFxuICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2lzdGFudC4gSWYgbm90LCB0aGUgbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3Npc3RhbnRcbiAgICogd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgbW9kZWw/OiAoc3RyaW5nICYge30pIHwgQ2hhdEFQSS5DaGF0TW9kZWwgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBXaGV0aGVyIHRvIGVuYWJsZVxuICAgKiBbcGFyYWxsZWwgZnVuY3Rpb24gY2FsbGluZ10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2Z1bmN0aW9uLWNhbGxpbmcjY29uZmlndXJpbmctcGFyYWxsZWwtZnVuY3Rpb24tY2FsbGluZylcbiAgICogZHVyaW5nIHRvb2wgdXNlLlxuICAgKi9cbiAgcGFyYWxsZWxfdG9vbF9jYWxscz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAgICogW0dQVC00b10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00byksXG4gICAqIFtHUFQtNCBUdXJib10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzI2dwdC00LXR1cmJvLWFuZC1ncHQtNCksXG4gICAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9zY2hlbWFcIiwgXCJqc29uX3NjaGVtYVwiOiB7Li4ufSB9YCBlbmFibGVzIFN0cnVjdHVyZWRcbiAgICogT3V0cHV0cyB3aGljaCBlbnN1cmVzIHRoZSBtb2RlbCB3aWxsIG1hdGNoIHlvdXIgc3VwcGxpZWQgSlNPTiBzY2hlbWEuIExlYXJuIG1vcmVcbiAgICogaW4gdGhlXG4gICAqIFtTdHJ1Y3R1cmVkIE91dHB1dHMgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zdHJ1Y3R1cmVkLW91dHB1dHMpLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGVuc3VyZXMgdGhlXG4gICAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICAgKlxuICAgKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gICAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAgICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAgICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAgICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICAgKiBtYXggY29udGV4dCBsZW5ndGguXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBUaHJlYWRzQVBJLkFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogSWYgYHRydWVgLCByZXR1cm5zIGEgc3RyZWFtIG9mIGV2ZW50cyB0aGF0IGhhcHBlbiBkdXJpbmcgdGhlIFJ1biBhc1xuICAgKiBzZXJ2ZXItc2VudCBldmVudHMsIHRlcm1pbmF0aW5nIHdoZW4gdGhlIFJ1biBlbnRlcnMgYSB0ZXJtaW5hbCBzdGF0ZSB3aXRoIGFcbiAgICogYGRhdGE6IFtET05FXWAgbWVzc2FnZS5cbiAgICovXG4gIHN0cmVhbT86IGJvb2xlYW4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzXG4gICAqIGxpa2UgMC44IHdpbGwgbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlXG4gICAqIGl0IG1vcmUgZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQm9keSBwYXJhbTogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgdG9vbCBpcyBjYWxsZWQgYnkgdGhlIG1vZGVsLiBgbm9uZWAgbWVhbnNcbiAgICogdGhlIG1vZGVsIHdpbGwgbm90IGNhbGwgYW55IHRvb2xzIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBpcyB0aGVcbiAgICogZGVmYXVsdCB2YWx1ZSBhbmQgbWVhbnMgdGhlIG1vZGVsIGNhbiBwaWNrIGJldHdlZW4gZ2VuZXJhdGluZyBhIG1lc3NhZ2Ugb3JcbiAgICogY2FsbGluZyBvbmUgb3IgbW9yZSB0b29scy4gYHJlcXVpcmVkYCBtZWFucyB0aGUgbW9kZWwgbXVzdCBjYWxsIG9uZSBvciBtb3JlXG4gICAqIHRvb2xzIGJlZm9yZSByZXNwb25kaW5nIHRvIHRoZSB1c2VyLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciB0b29sIGxpa2VcbiAgICogYHtcInR5cGVcIjogXCJmaWxlX3NlYXJjaFwifWAgb3JcbiAgICogYHtcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifX1gIGZvcmNlcyB0aGUgbW9kZWwgdG9cbiAgICogY2FsbCB0aGF0IHRvb2wuXG4gICAqL1xuICB0b29sX2Nob2ljZT86IFRocmVhZHNBUEkuQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IE92ZXJyaWRlIHRoZSB0b29scyB0aGUgYXNzaXN0YW50IGNhbiB1c2UgZm9yIHRoaXMgcnVuLiBUaGlzIGlzXG4gICAqIHVzZWZ1bCBmb3IgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQXNzaXN0YW50VG9vbD4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1c1xuICAgKiBzYW1wbGluZywgd2hlcmUgdGhlIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3BcbiAgICogcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlXG4gICAqIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlXG4gICAqIHRoaXMgdG8gY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICB0cnVuY2F0aW9uX3N0cmF0ZWd5PzogUnVuQ3JlYXRlUGFyYW1zLlRydW5jYXRpb25TdHJhdGVneSB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuQ3JlYXRlUGFyYW1zIHtcbiAgZXhwb3J0IGludGVyZmFjZSBBZGRpdGlvbmFsTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8TWVzc2FnZXNBUEkuTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJvbGUgb2YgdGhlIGVudGl0eSB0aGF0IGlzIGNyZWF0aW5nIHRoZSBtZXNzYWdlLiBBbGxvd2VkIHZhbHVlcyBpbmNsdWRlOlxuICAgICAqXG4gICAgICogLSBgdXNlcmA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBzZW50IGJ5IGFuIGFjdHVhbCB1c2VyIGFuZCBzaG91bGQgYmUgdXNlZCBpblxuICAgICAqICAgbW9zdCBjYXNlcyB0byByZXByZXNlbnQgdXNlci1nZW5lcmF0ZWQgbWVzc2FnZXMuXG4gICAgICogLSBgYXNzaXN0YW50YDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGdlbmVyYXRlZCBieSB0aGUgYXNzaXN0YW50LiBVc2UgdGhpc1xuICAgICAqICAgdmFsdWUgdG8gaW5zZXJ0IG1lc3NhZ2VzIGZyb20gdGhlIGFzc2lzdGFudCBpbnRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgZmlsZXMgYXR0YWNoZWQgdG8gdGhlIG1lc3NhZ2UsIGFuZCB0aGUgdG9vbHMgdGhleSBzaG91bGQgYmUgYWRkZWQgdG8uXG4gICAgICovXG4gICAgYXR0YWNobWVudHM/OiBBcnJheTxBZGRpdGlvbmFsTWVzc2FnZS5BdHRhY2htZW50PiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICovXG4gICAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgQWRkaXRpb25hbE1lc3NhZ2Uge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBhdHRhY2ggdG8gdGhlIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRvb2xzIHRvIGFkZCB0aGlzIGZpbGUgdG8uXG4gICAgICAgKi9cbiAgICAgIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXR0YWNobWVudC5GaWxlU2VhcmNoPjtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIEF0dGFjaG1lbnQge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRvb2wgYmVpbmcgZGVmaW5lZDogYGZpbGVfc2VhcmNoYFxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2ZpbGVfc2VhcmNoJztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVHJ1bmNhdGlvblN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJ1bmNhdGlvbiBzdHJhdGVneSB0byB1c2UgZm9yIHRoZSB0aHJlYWQuIFRoZSBkZWZhdWx0IGlzIGBhdXRvYC4gSWYgc2V0IHRvXG4gICAgICogYGxhc3RfbWVzc2FnZXNgLCB0aGUgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHRvIHRoZSBuIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGluXG4gICAgICogdGhlIHRocmVhZC4gV2hlbiBzZXQgdG8gYGF1dG9gLCBtZXNzYWdlcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSB0aHJlYWQgd2lsbCBiZVxuICAgICAqIGRyb3BwZWQgdG8gZml0IHRoZSBjb250ZXh0IGxlbmd0aCBvZiB0aGUgbW9kZWwsIGBtYXhfcHJvbXB0X3Rva2Vuc2AuXG4gICAgICovXG4gICAgdHlwZTogJ2F1dG8nIHwgJ2xhc3RfbWVzc2FnZXMnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtb3N0IHJlY2VudCBtZXNzYWdlcyBmcm9tIHRoZSB0aHJlYWQgd2hlbiBjb25zdHJ1Y3RpbmcgdGhlIGNvbnRleHRcbiAgICAgKiBmb3IgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBsYXN0X21lc3NhZ2VzPzogbnVtYmVyIHwgbnVsbDtcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIFJ1bkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyA9IFJ1bnNBUEkuUnVuQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nO1xuICBleHBvcnQgdHlwZSBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSBSdW5zQVBJLlJ1bkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSdW5DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgZXh0ZW5kcyBSdW5DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIEJvZHkgcGFyYW06IElmIGB0cnVlYCwgcmV0dXJucyBhIHN0cmVhbSBvZiBldmVudHMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoZSBSdW4gYXNcbiAgICogc2VydmVyLXNlbnQgZXZlbnRzLCB0ZXJtaW5hdGluZyB3aGVuIHRoZSBSdW4gZW50ZXJzIGEgdGVybWluYWwgc3RhdGUgd2l0aCBhXG4gICAqIGBkYXRhOiBbRE9ORV1gIG1lc3NhZ2UuXG4gICAqL1xuICBzdHJlYW0/OiBmYWxzZSB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGV4dGVuZHMgUnVuQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBCb2R5IHBhcmFtOiBJZiBgdHJ1ZWAsIHJldHVybnMgYSBzdHJlYW0gb2YgZXZlbnRzIHRoYXQgaGFwcGVuIGR1cmluZyB0aGUgUnVuIGFzXG4gICAqIHNlcnZlci1zZW50IGV2ZW50cywgdGVybWluYXRpbmcgd2hlbiB0aGUgUnVuIGVudGVycyBhIHRlcm1pbmFsIHN0YXRlIHdpdGggYVxuICAgKiBgZGF0YTogW0RPTkVdYCBtZXNzYWdlLlxuICAgKi9cbiAgc3RyZWFtOiB0cnVlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1blVwZGF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1bkxpc3RQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgY3Vyc29yIGZvciB1c2UgaW4gcGFnaW5hdGlvbi4gYGJlZm9yZWAgaXMgYW4gb2JqZWN0IElEIHRoYXQgZGVmaW5lcyB5b3VyIHBsYWNlXG4gICAqIGluIHRoZSBsaXN0LiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBtYWtlIGEgbGlzdCByZXF1ZXN0IGFuZCByZWNlaXZlIDEwMCBvYmplY3RzLFxuICAgKiBzdGFydGluZyB3aXRoIG9ial9mb28sIHlvdXIgc3Vic2VxdWVudCBjYWxsIGNhbiBpbmNsdWRlIGJlZm9yZT1vYmpfZm9vIGluIG9yZGVyXG4gICAqIHRvIGZldGNoIHRoZSBwcmV2aW91cyBwYWdlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgYmVmb3JlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTb3J0IG9yZGVyIGJ5IHRoZSBgY3JlYXRlZF9hdGAgdGltZXN0YW1wIG9mIHRoZSBvYmplY3RzLiBgYXNjYCBmb3IgYXNjZW5kaW5nXG4gICAqIG9yZGVyIGFuZCBgZGVzY2AgZm9yIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAqL1xuICBvcmRlcj86ICdhc2MnIHwgJ2Rlc2MnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1bkNyZWF0ZUFuZFBvbGxQYXJhbXMge1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZVxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIHRvIHVzZSB0b1xuICAgKiBleGVjdXRlIHRoaXMgcnVuLlxuICAgKi9cbiAgYXNzaXN0YW50X2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgYWRkaXRpb25hbCBpbnN0cnVjdGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgaW5zdHJ1Y3Rpb25zIGZvciB0aGUgcnVuLiBUaGlzXG4gICAqIGlzIHVzZWZ1bCBmb3IgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMgd2l0aG91dCBvdmVycmlkaW5nIG90aGVyXG4gICAqIGluc3RydWN0aW9ucy5cbiAgICovXG4gIGFkZGl0aW9uYWxfaW5zdHJ1Y3Rpb25zPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogQWRkcyBhZGRpdGlvbmFsIG1lc3NhZ2VzIHRvIHRoZSB0aHJlYWQgYmVmb3JlIGNyZWF0aW5nIHRoZSBydW4uXG4gICAqL1xuICBhZGRpdGlvbmFsX21lc3NhZ2VzPzogQXJyYXk8UnVuQ3JlYXRlQW5kUG9sbFBhcmFtcy5BZGRpdGlvbmFsTWVzc2FnZT4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgdGhlXG4gICAqIFtpbnN0cnVjdGlvbnNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cy9jcmVhdGVBc3Npc3RhbnQpXG4gICAqIG9mIHRoZSBhc3Npc3RhbnQuIFRoaXMgaXMgdXNlZnVsIGZvciBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGVcbiAgICogcnVuLiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogY29tcGxldGlvbiB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC4gU2VlXG4gICAqIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfY29tcGxldGlvbl90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcHJvbXB0IHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgcnVuLlxuICAgKiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgcHJvbXB0IHRva2Vuc1xuICAgKiBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlIG51bWJlciBvZlxuICAgKiBwcm9tcHQgdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X3Byb21wdF90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFtNb2RlbF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tb2RlbHMpIHRvXG4gICAqIGJlIHVzZWQgdG8gZXhlY3V0ZSB0aGlzIHJ1bi4gSWYgYSB2YWx1ZSBpcyBwcm92aWRlZCBoZXJlLCBpdCB3aWxsIG92ZXJyaWRlIHRoZVxuICAgKiBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2lzdGFudC4gSWYgbm90LCB0aGUgbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgKiBhc3Npc3RhbnQgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgbW9kZWw/OlxuICAgIHwgKHN0cmluZyAmIHt9KVxuICAgIHwgJ2dwdC00bydcbiAgICB8ICdncHQtNG8tMjAyNC0wNS0xMydcbiAgICB8ICdncHQtNC10dXJibydcbiAgICB8ICdncHQtNC10dXJiby0yMDI0LTA0LTA5J1xuICAgIHwgJ2dwdC00LTAxMjUtcHJldmlldydcbiAgICB8ICdncHQtNC10dXJiby1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LTExMDYtcHJldmlldydcbiAgICB8ICdncHQtNC12aXNpb24tcHJldmlldydcbiAgICB8ICdncHQtNCdcbiAgICB8ICdncHQtNC0wMzE0J1xuICAgIHwgJ2dwdC00LTA2MTMnXG4gICAgfCAnZ3B0LTQtMzJrJ1xuICAgIHwgJ2dwdC00LTMyay0wMzE0J1xuICAgIHwgJ2dwdC00LTMyay0wNjEzJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8nXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xNmsnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0wNjEzJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTEwNidcbiAgICB8ICdncHQtMy41LXR1cmJvLTAxMjUnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xNmstMDYxMydcbiAgICB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAgICogW0dQVC00b10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzL2dwdC00byksXG4gICAqIFtHUFQtNCBUdXJib10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzL2dwdC00LXR1cmJvLWFuZC1ncHQtNCksXG4gICAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9vYmplY3RcIiB9YCBlbmFibGVzIEpTT04gbW9kZSwgd2hpY2ggZ3VhcmFudGVlcyB0aGVcbiAgICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gICAqXG4gICAqICoqSW1wb3J0YW50OioqIHdoZW4gdXNpbmcgSlNPTiBtb2RlLCB5b3UgKiptdXN0KiogYWxzbyBpbnN0cnVjdCB0aGUgbW9kZWwgdG9cbiAgICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICAgKiBnZW5lcmF0ZSBhbiB1bmVuZGluZyBzdHJlYW0gb2Ygd2hpdGVzcGFjZSB1bnRpbCB0aGUgZ2VuZXJhdGlvbiByZWFjaGVzIHRoZSB0b2tlblxuICAgKiBsaW1pdCwgcmVzdWx0aW5nIGluIGEgbG9uZy1ydW5uaW5nIGFuZCBzZWVtaW5nbHkgXCJzdHVja1wiIHJlcXVlc3QuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICAgKiBpbmRpY2F0ZXMgdGhlIGdlbmVyYXRpb24gZXhjZWVkZWQgYG1heF90b2tlbnNgIG9yIHRoZSBjb252ZXJzYXRpb24gZXhjZWVkZWQgdGhlXG4gICAqIG1heCBjb250ZXh0IGxlbmd0aC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86IFRocmVhZHNBUEkuQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgdG9vbCBpcyBjYWxsZWQgYnkgdGhlIG1vZGVsLiBgbm9uZWAgbWVhbnMgdGhlIG1vZGVsIHdpbGxcbiAgICogbm90IGNhbGwgYW55IHRvb2xzIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBpcyB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgKiBhbmQgbWVhbnMgdGhlIG1vZGVsIGNhbiBwaWNrIGJldHdlZW4gZ2VuZXJhdGluZyBhIG1lc3NhZ2Ugb3IgY2FsbGluZyBvbmUgb3IgbW9yZVxuICAgKiB0b29scy4gYHJlcXVpcmVkYCBtZWFucyB0aGUgbW9kZWwgbXVzdCBjYWxsIG9uZSBvciBtb3JlIHRvb2xzIGJlZm9yZSByZXNwb25kaW5nXG4gICAqIHRvIHRoZSB1c2VyLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciB0b29sIGxpa2UgYHtcInR5cGVcIjogXCJmaWxlX3NlYXJjaFwifWAgb3JcbiAgICogYHtcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifX1gIGZvcmNlcyB0aGUgbW9kZWwgdG9cbiAgICogY2FsbCB0aGF0IHRvb2wuXG4gICAqL1xuICB0b29sX2Nob2ljZT86IFRocmVhZHNBUEkuQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSB0b29scyB0aGUgYXNzaXN0YW50IGNhbiB1c2UgZm9yIHRoaXMgcnVuLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQXNzaXN0YW50VG9vbD4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICB0cnVuY2F0aW9uX3N0cmF0ZWd5PzogUnVuQ3JlYXRlQW5kUG9sbFBhcmFtcy5UcnVuY2F0aW9uU3RyYXRlZ3kgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJ1bkNyZWF0ZUFuZFBvbGxQYXJhbXMge1xuICBleHBvcnQgaW50ZXJmYWNlIEFkZGl0aW9uYWxNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCBjb250ZW50cyBvZiB0aGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBjb250ZW50OiBzdHJpbmcgfCBBcnJheTxNZXNzYWdlc0FQSS5NZXNzYWdlQ29udGVudFBhcnRQYXJhbT47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm9sZSBvZiB0aGUgZW50aXR5IHRoYXQgaXMgY3JlYXRpbmcgdGhlIG1lc3NhZ2UuIEFsbG93ZWQgdmFsdWVzIGluY2x1ZGU6XG4gICAgICpcbiAgICAgKiAtIGB1c2VyYDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIHNlbnQgYnkgYW4gYWN0dWFsIHVzZXIgYW5kIHNob3VsZCBiZSB1c2VkIGluXG4gICAgICogICBtb3N0IGNhc2VzIHRvIHJlcHJlc2VudCB1c2VyLWdlbmVyYXRlZCBtZXNzYWdlcy5cbiAgICAgKiAtIGBhc3Npc3RhbnRgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBhc3Npc3RhbnQuIFVzZSB0aGlzXG4gICAgICogICB2YWx1ZSB0byBpbnNlcnQgbWVzc2FnZXMgZnJvbSB0aGUgYXNzaXN0YW50IGludG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgKi9cbiAgICByb2xlOiAndXNlcicgfCAnYXNzaXN0YW50JztcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byB0aGUgbWVzc2FnZSwgYW5kIHRoZSB0b29scyB0aGV5IHNob3VsZCBiZSBhZGRlZCB0by5cbiAgICAgKi9cbiAgICBhdHRhY2htZW50cz86IEFycmF5PEFkZGl0aW9uYWxNZXNzYWdlLkF0dGFjaG1lbnQ+IHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgKi9cbiAgICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBBZGRpdGlvbmFsTWVzc2FnZSB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBBdHRhY2htZW50IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIElEIG9mIHRoZSBmaWxlIHRvIGF0dGFjaCB0byB0aGUgbWVzc2FnZS5cbiAgICAgICAqL1xuICAgICAgZmlsZV9pZD86IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdG9vbHMgdG8gYWRkIHRoaXMgZmlsZSB0by5cbiAgICAgICAqL1xuICAgICAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkNvZGVJbnRlcnByZXRlclRvb2wgfCBBc3Npc3RhbnRzQVBJLkZpbGVTZWFyY2hUb29sPjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVHJ1bmNhdGlvblN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJ1bmNhdGlvbiBzdHJhdGVneSB0byB1c2UgZm9yIHRoZSB0aHJlYWQuIFRoZSBkZWZhdWx0IGlzIGBhdXRvYC4gSWYgc2V0IHRvXG4gICAgICogYGxhc3RfbWVzc2FnZXNgLCB0aGUgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHRvIHRoZSBuIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGluXG4gICAgICogdGhlIHRocmVhZC4gV2hlbiBzZXQgdG8gYGF1dG9gLCBtZXNzYWdlcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSB0aHJlYWQgd2lsbCBiZVxuICAgICAqIGRyb3BwZWQgdG8gZml0IHRoZSBjb250ZXh0IGxlbmd0aCBvZiB0aGUgbW9kZWwsIGBtYXhfcHJvbXB0X3Rva2Vuc2AuXG4gICAgICovXG4gICAgdHlwZTogJ2F1dG8nIHwgJ2xhc3RfbWVzc2FnZXMnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtb3N0IHJlY2VudCBtZXNzYWdlcyBmcm9tIHRoZSB0aHJlYWQgd2hlbiBjb25zdHJ1Y3RpbmcgdGhlIGNvbnRleHRcbiAgICAgKiBmb3IgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBsYXN0X21lc3NhZ2VzPzogbnVtYmVyIHwgbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1bkNyZWF0ZUFuZFN0cmVhbVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdG8gdXNlIHRvXG4gICAqIGV4ZWN1dGUgdGhpcyBydW4uXG4gICAqL1xuICBhc3Npc3RhbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQXBwZW5kcyBhZGRpdGlvbmFsIGluc3RydWN0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSBpbnN0cnVjdGlvbnMgZm9yIHRoZSBydW4uIFRoaXNcbiAgICogaXMgdXNlZnVsIGZvciBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcyB3aXRob3V0IG92ZXJyaWRpbmcgb3RoZXJcbiAgICogaW5zdHJ1Y3Rpb25zLlxuICAgKi9cbiAgYWRkaXRpb25hbF9pbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBZGRzIGFkZGl0aW9uYWwgbWVzc2FnZXMgdG8gdGhlIHRocmVhZCBiZWZvcmUgY3JlYXRpbmcgdGhlIHJ1bi5cbiAgICovXG4gIGFkZGl0aW9uYWxfbWVzc2FnZXM/OiBBcnJheTxSdW5DcmVhdGVBbmRTdHJlYW1QYXJhbXMuQWRkaXRpb25hbE1lc3NhZ2U+IHwgbnVsbDtcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIHRoZVxuICAgKiBbaW5zdHJ1Y3Rpb25zXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMvY3JlYXRlQXNzaXN0YW50KVxuICAgKiBvZiB0aGUgYXNzaXN0YW50LiBUaGlzIGlzIHVzZWZ1bCBmb3IgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlXG4gICAqIHJ1bi4gVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zXG4gICAqIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGUgbnVtYmVyIG9mXG4gICAqIGNvbXBsZXRpb24gdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X2NvbXBsZXRpb25fdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHByb21wdCB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1bi5cbiAgICogVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIHByb21wdCB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogcHJvbXB0IHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLiBTZWVcbiAgICogYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9wcm9tcHRfdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBbTW9kZWxdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzKSB0b1xuICAgKiBiZSB1c2VkIHRvIGV4ZWN1dGUgdGhpcyBydW4uIElmIGEgdmFsdWUgaXMgcHJvdmlkZWQgaGVyZSwgaXQgd2lsbCBvdmVycmlkZSB0aGVcbiAgICogbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3Npc3RhbnQuIElmIG5vdCwgdGhlIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICogYXNzaXN0YW50IHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIG1vZGVsPzpcbiAgICB8IChzdHJpbmcgJiB7fSlcbiAgICB8ICdncHQtNG8nXG4gICAgfCAnZ3B0LTRvLTIwMjQtMDUtMTMnXG4gICAgfCAnZ3B0LTQtdHVyYm8nXG4gICAgfCAnZ3B0LTQtdHVyYm8tMjAyNC0wNC0wOSdcbiAgICB8ICdncHQtNC0wMTI1LXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtdHVyYm8tcHJldmlldydcbiAgICB8ICdncHQtNC0xMTA2LXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtdmlzaW9uLXByZXZpZXcnXG4gICAgfCAnZ3B0LTQnXG4gICAgfCAnZ3B0LTQtMDMxNCdcbiAgICB8ICdncHQtNC0wNjEzJ1xuICAgIHwgJ2dwdC00LTMyaydcbiAgICB8ICdncHQtNC0zMmstMDMxNCdcbiAgICB8ICdncHQtNC0zMmstMDYxMydcbiAgICB8ICdncHQtMy41LXR1cmJvJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTZrJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMDYxMydcbiAgICB8ICdncHQtMy41LXR1cmJvLTExMDYnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0wMTI1J1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTZrLTA2MTMnXG4gICAgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gICAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscy9ncHQtNG8pLFxuICAgKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscy9ncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICAgKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGd1YXJhbnRlZXMgdGhlXG4gICAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICAgKlxuICAgKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gICAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAgICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAgICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAgICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICAgKiBtYXggY29udGV4dCBsZW5ndGguXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBUaHJlYWRzQVBJLkFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqL1xuICB0ZW1wZXJhdHVyZT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIHdoaWNoIChpZiBhbnkpIHRvb2wgaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC4gYG5vbmVgIG1lYW5zIHRoZSBtb2RlbCB3aWxsXG4gICAqIG5vdCBjYWxsIGFueSB0b29scyBhbmQgaW5zdGVhZCBnZW5lcmF0ZXMgYSBtZXNzYWdlLiBgYXV0b2AgaXMgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICogYW5kIG1lYW5zIHRoZSBtb2RlbCBjYW4gcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yIGNhbGxpbmcgb25lIG9yIG1vcmVcbiAgICogdG9vbHMuIGByZXF1aXJlZGAgbWVhbnMgdGhlIG1vZGVsIG11c3QgY2FsbCBvbmUgb3IgbW9yZSB0b29scyBiZWZvcmUgcmVzcG9uZGluZ1xuICAgKiB0byB0aGUgdXNlci4gU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgdG9vbCBsaWtlIGB7XCJ0eXBlXCI6IFwiZmlsZV9zZWFyY2hcIn1gIG9yXG4gICAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gICAqIGNhbGwgdGhhdCB0b29sLlxuICAgKi9cbiAgdG9vbF9jaG9pY2U/OiBUaHJlYWRzQVBJLkFzc2lzdGFudFRvb2xDaG9pY2VPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgdG9vbHMgdGhlIGFzc2lzdGFudCBjYW4gdXNlIGZvciB0aGlzIHJ1bi4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzLlxuICAgKi9cbiAgdG9vbHM/OiBBcnJheTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFRvb2w+IHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgdGVtcGVyYXR1cmUgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdG9wX3A/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgdHJ1bmNhdGlvbl9zdHJhdGVneT86IFJ1bkNyZWF0ZUFuZFN0cmVhbVBhcmFtcy5UcnVuY2F0aW9uU3RyYXRlZ3kgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFJ1bkNyZWF0ZUFuZFN0cmVhbVBhcmFtcyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQWRkaXRpb25hbE1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PE1lc3NhZ2VzQVBJLk1lc3NhZ2VDb250ZW50UGFydFBhcmFtPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSByb2xlIG9mIHRoZSBlbnRpdHkgdGhhdCBpcyBjcmVhdGluZyB0aGUgbWVzc2FnZS4gQWxsb3dlZCB2YWx1ZXMgaW5jbHVkZTpcbiAgICAgKlxuICAgICAqIC0gYHVzZXJgOiBJbmRpY2F0ZXMgdGhlIG1lc3NhZ2UgaXMgc2VudCBieSBhbiBhY3R1YWwgdXNlciBhbmQgc2hvdWxkIGJlIHVzZWQgaW5cbiAgICAgKiAgIG1vc3QgY2FzZXMgdG8gcmVwcmVzZW50IHVzZXItZ2VuZXJhdGVkIG1lc3NhZ2VzLlxuICAgICAqIC0gYGFzc2lzdGFudGA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBnZW5lcmF0ZWQgYnkgdGhlIGFzc2lzdGFudC4gVXNlIHRoaXNcbiAgICAgKiAgIHZhbHVlIHRvIGluc2VydCBtZXNzYWdlcyBmcm9tIHRoZSBhc3Npc3RhbnQgaW50byB0aGUgY29udmVyc2F0aW9uLlxuICAgICAqL1xuICAgIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xuXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIHRoZSBtZXNzYWdlLCBhbmQgdGhlIHRvb2xzIHRoZXkgc2hvdWxkIGJlIGFkZGVkIHRvLlxuICAgICAqL1xuICAgIGF0dGFjaG1lbnRzPzogQXJyYXk8QWRkaXRpb25hbE1lc3NhZ2UuQXR0YWNobWVudD4gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAgICogY2hhcmFjdGVycyBsb25nLlxuICAgICAqL1xuICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIEFkZGl0aW9uYWxNZXNzYWdlIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIEF0dGFjaG1lbnQge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gYXR0YWNoIHRvIHRoZSBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkPzogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0b29scyB0byBhZGQgdGhpcyBmaWxlIHRvLlxuICAgICAgICovXG4gICAgICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEFzc2lzdGFudHNBUEkuRmlsZVNlYXJjaFRvb2w+O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUcnVuY2F0aW9uU3RyYXRlZ3kge1xuICAgIC8qKlxuICAgICAqIFRoZSB0cnVuY2F0aW9uIHN0cmF0ZWd5IHRvIHVzZSBmb3IgdGhlIHRocmVhZC4gVGhlIGRlZmF1bHQgaXMgYGF1dG9gLiBJZiBzZXQgdG9cbiAgICAgKiBgbGFzdF9tZXNzYWdlc2AsIHRoZSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgdG8gdGhlIG4gbW9zdCByZWNlbnQgbWVzc2FnZXMgaW5cbiAgICAgKiB0aGUgdGhyZWFkLiBXaGVuIHNldCB0byBgYXV0b2AsIG1lc3NhZ2VzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHRocmVhZCB3aWxsIGJlXG4gICAgICogZHJvcHBlZCB0byBmaXQgdGhlIGNvbnRleHQgbGVuZ3RoIG9mIHRoZSBtb2RlbCwgYG1heF9wcm9tcHRfdG9rZW5zYC5cbiAgICAgKi9cbiAgICB0eXBlOiAnYXV0bycgfCAnbGFzdF9tZXNzYWdlcyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGZyb20gdGhlIHRocmVhZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgY29udGV4dFxuICAgICAqIGZvciB0aGUgcnVuLlxuICAgICAqL1xuICAgIGxhc3RfbWVzc2FnZXM/OiBudW1iZXIgfCBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuU3RyZWFtUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGVcbiAgICogW2Fzc2lzdGFudF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSB0byB1c2UgdG9cbiAgICogZXhlY3V0ZSB0aGlzIHJ1bi5cbiAgICovXG4gIGFzc2lzdGFudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBcHBlbmRzIGFkZGl0aW9uYWwgaW5zdHJ1Y3Rpb25zIGF0IHRoZSBlbmQgb2YgdGhlIGluc3RydWN0aW9ucyBmb3IgdGhlIHJ1bi4gVGhpc1xuICAgKiBpcyB1c2VmdWwgZm9yIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzIHdpdGhvdXQgb3ZlcnJpZGluZyBvdGhlclxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICBhZGRpdGlvbmFsX2luc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEFkZHMgYWRkaXRpb25hbCBtZXNzYWdlcyB0byB0aGUgdGhyZWFkIGJlZm9yZSBjcmVhdGluZyB0aGUgcnVuLlxuICAgKi9cbiAgYWRkaXRpb25hbF9tZXNzYWdlcz86IEFycmF5PFJ1blN0cmVhbVBhcmFtcy5BZGRpdGlvbmFsTWVzc2FnZT4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgdGhlXG4gICAqIFtpbnN0cnVjdGlvbnNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cy9jcmVhdGVBc3Npc3RhbnQpXG4gICAqIG9mIHRoZSBhc3Npc3RhbnQuIFRoaXMgaXMgdXNlZnVsIGZvciBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIGluc3RydWN0aW9ucz86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGVcbiAgICogcnVuLiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogY29tcGxldGlvbiB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC4gU2VlXG4gICAqIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfY29tcGxldGlvbl90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcHJvbXB0IHRva2VucyB0aGF0IG1heSBiZSB1c2VkIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgcnVuLlxuICAgKiBUaGUgcnVuIHdpbGwgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHVzZSBvbmx5IHRoZSBudW1iZXIgb2YgcHJvbXB0IHRva2Vuc1xuICAgKiBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlIG51bWJlciBvZlxuICAgKiBwcm9tcHQgdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X3Byb21wdF90b2tlbnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIFtNb2RlbF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9tb2RlbHMpIHRvXG4gICAqIGJlIHVzZWQgdG8gZXhlY3V0ZSB0aGlzIHJ1bi4gSWYgYSB2YWx1ZSBpcyBwcm92aWRlZCBoZXJlLCBpdCB3aWxsIG92ZXJyaWRlIHRoZVxuICAgKiBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2lzdGFudC4gSWYgbm90LCB0aGUgbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgKiBhc3Npc3RhbnQgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgbW9kZWw/OlxuICAgIHwgKHN0cmluZyAmIHt9KVxuICAgIHwgJ2dwdC00bydcbiAgICB8ICdncHQtNG8tMjAyNC0wNS0xMydcbiAgICB8ICdncHQtNC10dXJibydcbiAgICB8ICdncHQtNC10dXJiby0yMDI0LTA0LTA5J1xuICAgIHwgJ2dwdC00LTAxMjUtcHJldmlldydcbiAgICB8ICdncHQtNC10dXJiby1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LTExMDYtcHJldmlldydcbiAgICB8ICdncHQtNC12aXNpb24tcHJldmlldydcbiAgICB8ICdncHQtNCdcbiAgICB8ICdncHQtNC0wMzE0J1xuICAgIHwgJ2dwdC00LTA2MTMnXG4gICAgfCAnZ3B0LTQtMzJrJ1xuICAgIHwgJ2dwdC00LTMyay0wMzE0J1xuICAgIHwgJ2dwdC00LTMyay0wNjEzJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8nXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xNmsnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0wNjEzJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTEwNidcbiAgICB8ICdncHQtMy41LXR1cmJvLTAxMjUnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xNmstMDYxMydcbiAgICB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAgICogW0dQVC00b10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzL2dwdC00byksXG4gICAqIFtHUFQtNCBUdXJib10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvbW9kZWxzL2dwdC00LXR1cmJvLWFuZC1ncHQtNCksXG4gICAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gICAqXG4gICAqIFNldHRpbmcgdG8gYHsgXCJ0eXBlXCI6IFwianNvbl9vYmplY3RcIiB9YCBlbmFibGVzIEpTT04gbW9kZSwgd2hpY2ggZ3VhcmFudGVlcyB0aGVcbiAgICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gICAqXG4gICAqICoqSW1wb3J0YW50OioqIHdoZW4gdXNpbmcgSlNPTiBtb2RlLCB5b3UgKiptdXN0KiogYWxzbyBpbnN0cnVjdCB0aGUgbW9kZWwgdG9cbiAgICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICAgKiBnZW5lcmF0ZSBhbiB1bmVuZGluZyBzdHJlYW0gb2Ygd2hpdGVzcGFjZSB1bnRpbCB0aGUgZ2VuZXJhdGlvbiByZWFjaGVzIHRoZSB0b2tlblxuICAgKiBsaW1pdCwgcmVzdWx0aW5nIGluIGEgbG9uZy1ydW5uaW5nIGFuZCBzZWVtaW5nbHkgXCJzdHVja1wiIHJlcXVlc3QuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICAgKiBpbmRpY2F0ZXMgdGhlIGdlbmVyYXRpb24gZXhjZWVkZWQgYG1heF90b2tlbnNgIG9yIHRoZSBjb252ZXJzYXRpb24gZXhjZWVkZWQgdGhlXG4gICAqIG1heCBjb250ZXh0IGxlbmd0aC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86IFRocmVhZHNBUEkuQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQ29udHJvbHMgd2hpY2ggKGlmIGFueSkgdG9vbCBpcyBjYWxsZWQgYnkgdGhlIG1vZGVsLiBgbm9uZWAgbWVhbnMgdGhlIG1vZGVsIHdpbGxcbiAgICogbm90IGNhbGwgYW55IHRvb2xzIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBpcyB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgKiBhbmQgbWVhbnMgdGhlIG1vZGVsIGNhbiBwaWNrIGJldHdlZW4gZ2VuZXJhdGluZyBhIG1lc3NhZ2Ugb3IgY2FsbGluZyBvbmUgb3IgbW9yZVxuICAgKiB0b29scy4gYHJlcXVpcmVkYCBtZWFucyB0aGUgbW9kZWwgbXVzdCBjYWxsIG9uZSBvciBtb3JlIHRvb2xzIGJlZm9yZSByZXNwb25kaW5nXG4gICAqIHRvIHRoZSB1c2VyLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciB0b29sIGxpa2UgYHtcInR5cGVcIjogXCJmaWxlX3NlYXJjaFwifWAgb3JcbiAgICogYHtcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifX1gIGZvcmNlcyB0aGUgbW9kZWwgdG9cbiAgICogY2FsbCB0aGF0IHRvb2wuXG4gICAqL1xuICB0b29sX2Nob2ljZT86IFRocmVhZHNBUEkuQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSB0b29scyB0aGUgYXNzaXN0YW50IGNhbiB1c2UgZm9yIHRoaXMgcnVuLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQXNzaXN0YW50VG9vbD4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICB0cnVuY2F0aW9uX3N0cmF0ZWd5PzogUnVuU3RyZWFtUGFyYW1zLlRydW5jYXRpb25TdHJhdGVneSB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuU3RyZWFtUGFyYW1zIHtcbiAgZXhwb3J0IGludGVyZmFjZSBBZGRpdGlvbmFsTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8TWVzc2FnZXNBUEkuTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJvbGUgb2YgdGhlIGVudGl0eSB0aGF0IGlzIGNyZWF0aW5nIHRoZSBtZXNzYWdlLiBBbGxvd2VkIHZhbHVlcyBpbmNsdWRlOlxuICAgICAqXG4gICAgICogLSBgdXNlcmA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBzZW50IGJ5IGFuIGFjdHVhbCB1c2VyIGFuZCBzaG91bGQgYmUgdXNlZCBpblxuICAgICAqICAgbW9zdCBjYXNlcyB0byByZXByZXNlbnQgdXNlci1nZW5lcmF0ZWQgbWVzc2FnZXMuXG4gICAgICogLSBgYXNzaXN0YW50YDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGdlbmVyYXRlZCBieSB0aGUgYXNzaXN0YW50LiBVc2UgdGhpc1xuICAgICAqICAgdmFsdWUgdG8gaW5zZXJ0IG1lc3NhZ2VzIGZyb20gdGhlIGFzc2lzdGFudCBpbnRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgZmlsZXMgYXR0YWNoZWQgdG8gdGhlIG1lc3NhZ2UsIGFuZCB0aGUgdG9vbHMgdGhleSBzaG91bGQgYmUgYWRkZWQgdG8uXG4gICAgICovXG4gICAgYXR0YWNobWVudHM/OiBBcnJheTxBZGRpdGlvbmFsTWVzc2FnZS5BdHRhY2htZW50PiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICovXG4gICAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgQWRkaXRpb25hbE1lc3NhZ2Uge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBhdHRhY2ggdG8gdGhlIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWQ/OiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRvb2xzIHRvIGFkZCB0aGlzIGZpbGUgdG8uXG4gICAgICAgKi9cbiAgICAgIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXNzaXN0YW50c0FQSS5GaWxlU2VhcmNoVG9vbD47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRydW5jYXRpb25TdHJhdGVneSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRydW5jYXRpb24gc3RyYXRlZ3kgdG8gdXNlIGZvciB0aGUgdGhyZWFkLiBUaGUgZGVmYXVsdCBpcyBgYXV0b2AuIElmIHNldCB0b1xuICAgICAqIGBsYXN0X21lc3NhZ2VzYCwgdGhlIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCB0byB0aGUgbiBtb3N0IHJlY2VudCBtZXNzYWdlcyBpblxuICAgICAqIHRoZSB0aHJlYWQuIFdoZW4gc2V0IHRvIGBhdXRvYCwgbWVzc2FnZXMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdGhyZWFkIHdpbGwgYmVcbiAgICAgKiBkcm9wcGVkIHRvIGZpdCB0aGUgY29udGV4dCBsZW5ndGggb2YgdGhlIG1vZGVsLCBgbWF4X3Byb21wdF90b2tlbnNgLlxuICAgICAqL1xuICAgIHR5cGU6ICdhdXRvJyB8ICdsYXN0X21lc3NhZ2VzJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbW9zdCByZWNlbnQgbWVzc2FnZXMgZnJvbSB0aGUgdGhyZWFkIHdoZW4gY29uc3RydWN0aW5nIHRoZSBjb250ZXh0XG4gICAgICogZm9yIHRoZSBydW4uXG4gICAgICovXG4gICAgbGFzdF9tZXNzYWdlcz86IG51bWJlciB8IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXMgPVxuICB8IFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nXG4gIHwgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0b29scyBmb3Igd2hpY2ggdGhlIG91dHB1dHMgYXJlIGJlaW5nIHN1Ym1pdHRlZC5cbiAgICovXG4gIHRvb2xfb3V0cHV0czogQXJyYXk8UnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXMuVG9vbE91dHB1dD47XG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgcmV0dXJucyBhIHN0cmVhbSBvZiBldmVudHMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoZSBSdW4gYXMgc2VydmVyLXNlbnRcbiAgICogZXZlbnRzLCB0ZXJtaW5hdGluZyB3aGVuIHRoZSBSdW4gZW50ZXJzIGEgdGVybWluYWwgc3RhdGUgd2l0aCBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqL1xuICBzdHJlYW0/OiBib29sZWFuIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtcyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbE91dHB1dCB7XG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dCBvZiB0aGUgdG9vbCBjYWxsIHRvIGJlIHN1Ym1pdHRlZCB0byBjb250aW51ZSB0aGUgcnVuLlxuICAgICAqL1xuICAgIG91dHB1dD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsIGluIHRoZSBgcmVxdWlyZWRfYWN0aW9uYCBvYmplY3Qgd2l0aGluIHRoZSBydW4gb2JqZWN0XG4gICAgICogdGhlIG91dHB1dCBpcyBiZWluZyBzdWJtaXR0ZWQgZm9yLlxuICAgICAqL1xuICAgIHRvb2xfY2FsbF9pZD86IHN0cmluZztcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nID0gUnVuc0FQSS5SdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc05vblN0cmVhbWluZztcbiAgZXhwb3J0IHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmcgPSBSdW5zQVBJLlJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zU3RyZWFtaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nIGV4dGVuZHMgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgcmV0dXJucyBhIHN0cmVhbSBvZiBldmVudHMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoZSBSdW4gYXMgc2VydmVyLXNlbnRcbiAgICogZXZlbnRzLCB0ZXJtaW5hdGluZyB3aGVuIHRoZSBSdW4gZW50ZXJzIGEgdGVybWluYWwgc3RhdGUgd2l0aCBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqL1xuICBzdHJlYW0/OiBmYWxzZSB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmcgZXh0ZW5kcyBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogSWYgYHRydWVgLCByZXR1cm5zIGEgc3RyZWFtIG9mIGV2ZW50cyB0aGF0IGhhcHBlbiBkdXJpbmcgdGhlIFJ1biBhcyBzZXJ2ZXItc2VudFxuICAgKiBldmVudHMsIHRlcm1pbmF0aW5nIHdoZW4gdGhlIFJ1biBlbnRlcnMgYSB0ZXJtaW5hbCBzdGF0ZSB3aXRoIGEgYGRhdGE6IFtET05FXWBcbiAgICogbWVzc2FnZS5cbiAgICovXG4gIHN0cmVhbTogdHJ1ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSdW5TdWJtaXRUb29sT3V0cHV0c0FuZFBvbGxQYXJhbXMge1xuICAvKipcbiAgICogQSBsaXN0IG9mIHRvb2xzIGZvciB3aGljaCB0aGUgb3V0cHV0cyBhcmUgYmVpbmcgc3VibWl0dGVkLlxuICAgKi9cbiAgdG9vbF9vdXRwdXRzOiBBcnJheTxSdW5TdWJtaXRUb29sT3V0cHV0c0FuZFBvbGxQYXJhbXMuVG9vbE91dHB1dD47XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgUnVuU3VibWl0VG9vbE91dHB1dHNBbmRQb2xsUGFyYW1zIHtcbiAgZXhwb3J0IGludGVyZmFjZSBUb29sT3V0cHV0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0IG9mIHRoZSB0b29sIGNhbGwgdG8gYmUgc3VibWl0dGVkIHRvIGNvbnRpbnVlIHRoZSBydW4uXG4gICAgICovXG4gICAgb3V0cHV0Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwgaW4gdGhlIGByZXF1aXJlZF9hY3Rpb25gIG9iamVjdCB3aXRoaW4gdGhlIHJ1biBvYmplY3RcbiAgICAgKiB0aGUgb3V0cHV0IGlzIGJlaW5nIHN1Ym1pdHRlZCBmb3IuXG4gICAgICovXG4gICAgdG9vbF9jYWxsX2lkPzogc3RyaW5nO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVuU3VibWl0VG9vbE91dHB1dHNTdHJlYW1QYXJhbXMge1xuICAvKipcbiAgICogQSBsaXN0IG9mIHRvb2xzIGZvciB3aGljaCB0aGUgb3V0cHV0cyBhcmUgYmVpbmcgc3VibWl0dGVkLlxuICAgKi9cbiAgdG9vbF9vdXRwdXRzOiBBcnJheTxSdW5TdWJtaXRUb29sT3V0cHV0c1N0cmVhbVBhcmFtcy5Ub29sT3V0cHV0Pjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBSdW5TdWJtaXRUb29sT3V0cHV0c1N0cmVhbVBhcmFtcyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbE91dHB1dCB7XG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dCBvZiB0aGUgdG9vbCBjYWxsIHRvIGJlIHN1Ym1pdHRlZCB0byBjb250aW51ZSB0aGUgcnVuLlxuICAgICAqL1xuICAgIG91dHB1dD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsIGluIHRoZSBgcmVxdWlyZWRfYWN0aW9uYCBvYmplY3Qgd2l0aGluIHRoZSBydW4gb2JqZWN0XG4gICAgICogdGhlIG91dHB1dCBpcyBiZWluZyBzdWJtaXR0ZWQgZm9yLlxuICAgICAqL1xuICAgIHRvb2xfY2FsbF9pZD86IHN0cmluZztcbiAgfVxufVxuXG5SdW5zLlJ1bnNQYWdlID0gUnVuc1BhZ2U7XG5SdW5zLlN0ZXBzID0gU3RlcHM7XG5SdW5zLlJ1blN0ZXBzUGFnZSA9IFJ1blN0ZXBzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFJ1bnMge1xuICBleHBvcnQge1xuICAgIHR5cGUgUmVxdWlyZWRBY3Rpb25GdW5jdGlvblRvb2xDYWxsIGFzIFJlcXVpcmVkQWN0aW9uRnVuY3Rpb25Ub29sQ2FsbCxcbiAgICB0eXBlIFJ1biBhcyBSdW4sXG4gICAgdHlwZSBSdW5TdGF0dXMgYXMgUnVuU3RhdHVzLFxuICAgIFJ1bnNQYWdlIGFzIFJ1bnNQYWdlLFxuICAgIHR5cGUgUnVuQ3JlYXRlUGFyYW1zIGFzIFJ1bkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIFJ1bkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBhcyBSdW5DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmcgYXMgUnVuQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICAgIHR5cGUgUnVuVXBkYXRlUGFyYW1zIGFzIFJ1blVwZGF0ZVBhcmFtcyxcbiAgICB0eXBlIFJ1bkxpc3RQYXJhbXMgYXMgUnVuTGlzdFBhcmFtcyxcbiAgICB0eXBlIFJ1bkNyZWF0ZUFuZFBvbGxQYXJhbXMsXG4gICAgdHlwZSBSdW5DcmVhdGVBbmRTdHJlYW1QYXJhbXMsXG4gICAgdHlwZSBSdW5TdHJlYW1QYXJhbXMsXG4gICAgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtcyBhcyBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtcyxcbiAgICB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nIGFzIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmcgYXMgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNTdHJlYW1pbmcsXG4gICAgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c0FuZFBvbGxQYXJhbXMsXG4gICAgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c1N0cmVhbVBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIFN0ZXBzIGFzIFN0ZXBzLFxuICAgIHR5cGUgQ29kZUludGVycHJldGVyTG9ncyBhcyBDb2RlSW50ZXJwcmV0ZXJMb2dzLFxuICAgIHR5cGUgQ29kZUludGVycHJldGVyT3V0cHV0SW1hZ2UgYXMgQ29kZUludGVycHJldGVyT3V0cHV0SW1hZ2UsXG4gICAgdHlwZSBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbCBhcyBDb2RlSW50ZXJwcmV0ZXJUb29sQ2FsbCxcbiAgICB0eXBlIENvZGVJbnRlcnByZXRlclRvb2xDYWxsRGVsdGEgYXMgQ29kZUludGVycHJldGVyVG9vbENhbGxEZWx0YSxcbiAgICB0eXBlIEZpbGVTZWFyY2hUb29sQ2FsbCBhcyBGaWxlU2VhcmNoVG9vbENhbGwsXG4gICAgdHlwZSBGaWxlU2VhcmNoVG9vbENhbGxEZWx0YSBhcyBGaWxlU2VhcmNoVG9vbENhbGxEZWx0YSxcbiAgICB0eXBlIEZ1bmN0aW9uVG9vbENhbGwgYXMgRnVuY3Rpb25Ub29sQ2FsbCxcbiAgICB0eXBlIEZ1bmN0aW9uVG9vbENhbGxEZWx0YSBhcyBGdW5jdGlvblRvb2xDYWxsRGVsdGEsXG4gICAgdHlwZSBNZXNzYWdlQ3JlYXRpb25TdGVwRGV0YWlscyBhcyBNZXNzYWdlQ3JlYXRpb25TdGVwRGV0YWlscyxcbiAgICB0eXBlIFJ1blN0ZXAgYXMgUnVuU3RlcCxcbiAgICB0eXBlIFJ1blN0ZXBEZWx0YSBhcyBSdW5TdGVwRGVsdGEsXG4gICAgdHlwZSBSdW5TdGVwRGVsdGFFdmVudCBhcyBSdW5TdGVwRGVsdGFFdmVudCxcbiAgICB0eXBlIFJ1blN0ZXBEZWx0YU1lc3NhZ2VEZWx0YSBhcyBSdW5TdGVwRGVsdGFNZXNzYWdlRGVsdGEsXG4gICAgdHlwZSBSdW5TdGVwSW5jbHVkZSBhcyBSdW5TdGVwSW5jbHVkZSxcbiAgICB0eXBlIFRvb2xDYWxsIGFzIFRvb2xDYWxsLFxuICAgIHR5cGUgVG9vbENhbGxEZWx0YSBhcyBUb29sQ2FsbERlbHRhLFxuICAgIHR5cGUgVG9vbENhbGxEZWx0YU9iamVjdCBhcyBUb29sQ2FsbERlbHRhT2JqZWN0LFxuICAgIHR5cGUgVG9vbENhbGxzU3RlcERldGFpbHMgYXMgVG9vbENhbGxzU3RlcERldGFpbHMsXG4gICAgUnVuU3RlcHNQYWdlIGFzIFJ1blN0ZXBzUGFnZSxcbiAgICB0eXBlIFN0ZXBSZXRyaWV2ZVBhcmFtcyBhcyBTdGVwUmV0cmlldmVQYXJhbXMsXG4gICAgdHlwZSBTdGVwTGlzdFBhcmFtcyBhcyBTdGVwTGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCB7IEFzc2lzdGFudFN0cmVhbSwgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zQmFzZVN0cmVhbSB9IGZyb20gJy4uLy4uLy4uL2xpYi9Bc3Npc3RhbnRTdHJlYW0nO1xuaW1wb3J0IHsgQVBJUHJvbWlzZSB9IGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIFRocmVhZHNBUEkgZnJvbSAnLi90aHJlYWRzJztcbmltcG9ydCAqIGFzIFNoYXJlZCBmcm9tICcuLi8uLi9zaGFyZWQnO1xuaW1wb3J0ICogYXMgQXNzaXN0YW50c0FQSSBmcm9tICcuLi9hc3Npc3RhbnRzJztcbmltcG9ydCAqIGFzIENoYXRBUEkgZnJvbSAnLi4vLi4vY2hhdC9jaGF0JztcbmltcG9ydCAqIGFzIE1lc3NhZ2VzQVBJIGZyb20gJy4vbWVzc2FnZXMnO1xuaW1wb3J0IHtcbiAgQW5ub3RhdGlvbixcbiAgQW5ub3RhdGlvbkRlbHRhLFxuICBGaWxlQ2l0YXRpb25Bbm5vdGF0aW9uLFxuICBGaWxlQ2l0YXRpb25EZWx0YUFubm90YXRpb24sXG4gIEZpbGVQYXRoQW5ub3RhdGlvbixcbiAgRmlsZVBhdGhEZWx0YUFubm90YXRpb24sXG4gIEltYWdlRmlsZSxcbiAgSW1hZ2VGaWxlQ29udGVudEJsb2NrLFxuICBJbWFnZUZpbGVEZWx0YSxcbiAgSW1hZ2VGaWxlRGVsdGFCbG9jayxcbiAgSW1hZ2VVUkwsXG4gIEltYWdlVVJMQ29udGVudEJsb2NrLFxuICBJbWFnZVVSTERlbHRhLFxuICBJbWFnZVVSTERlbHRhQmxvY2ssXG4gIE1lc3NhZ2UgYXMgTWVzc2FnZXNBUElNZXNzYWdlLFxuICBNZXNzYWdlQ29udGVudCxcbiAgTWVzc2FnZUNvbnRlbnREZWx0YSxcbiAgTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0sXG4gIE1lc3NhZ2VDcmVhdGVQYXJhbXMsXG4gIE1lc3NhZ2VEZWxldGVkLFxuICBNZXNzYWdlRGVsdGEsXG4gIE1lc3NhZ2VEZWx0YUV2ZW50LFxuICBNZXNzYWdlTGlzdFBhcmFtcyxcbiAgTWVzc2FnZVVwZGF0ZVBhcmFtcyxcbiAgTWVzc2FnZXMsXG4gIE1lc3NhZ2VzUGFnZSxcbiAgUmVmdXNhbENvbnRlbnRCbG9jayxcbiAgUmVmdXNhbERlbHRhQmxvY2ssXG4gIFRleHQsXG4gIFRleHRDb250ZW50QmxvY2ssXG4gIFRleHRDb250ZW50QmxvY2tQYXJhbSxcbiAgVGV4dERlbHRhLFxuICBUZXh0RGVsdGFCbG9jayxcbn0gZnJvbSAnLi9tZXNzYWdlcyc7XG5pbXBvcnQgKiBhcyBWZWN0b3JTdG9yZXNBUEkgZnJvbSAnLi4vdmVjdG9yLXN0b3Jlcy92ZWN0b3Itc3RvcmVzJztcbmltcG9ydCAqIGFzIFJ1bnNBUEkgZnJvbSAnLi9ydW5zL3J1bnMnO1xuaW1wb3J0IHtcbiAgUmVxdWlyZWRBY3Rpb25GdW5jdGlvblRvb2xDYWxsLFxuICBSdW4sXG4gIFJ1bkNyZWF0ZUFuZFBvbGxQYXJhbXMsXG4gIFJ1bkNyZWF0ZUFuZFN0cmVhbVBhcmFtcyxcbiAgUnVuQ3JlYXRlUGFyYW1zLFxuICBSdW5DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gIFJ1bkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgUnVuTGlzdFBhcmFtcyxcbiAgUnVuU3RhdHVzLFxuICBSdW5TdHJlYW1QYXJhbXMsXG4gIFJ1blN1Ym1pdFRvb2xPdXRwdXRzQW5kUG9sbFBhcmFtcyxcbiAgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXMsXG4gIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zTm9uU3RyZWFtaW5nLFxuICBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbWluZyxcbiAgUnVuU3VibWl0VG9vbE91dHB1dHNTdHJlYW1QYXJhbXMsXG4gIFJ1blVwZGF0ZVBhcmFtcyxcbiAgUnVucyxcbiAgUnVuc1BhZ2UsXG59IGZyb20gJy4vcnVucy9ydW5zJztcbmltcG9ydCB7IFN0cmVhbSB9IGZyb20gJy4uLy4uLy4uL3N0cmVhbWluZyc7XG5cbmV4cG9ydCBjbGFzcyBUaHJlYWRzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICBydW5zOiBSdW5zQVBJLlJ1bnMgPSBuZXcgUnVuc0FQSS5SdW5zKHRoaXMuX2NsaWVudCk7XG4gIG1lc3NhZ2VzOiBNZXNzYWdlc0FQSS5NZXNzYWdlcyA9IG5ldyBNZXNzYWdlc0FQSS5NZXNzYWdlcyh0aGlzLl9jbGllbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0aHJlYWQuXG4gICAqL1xuICBjcmVhdGUoYm9keT86IFRocmVhZENyZWF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8VGhyZWFkPjtcbiAgY3JlYXRlKG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFRocmVhZD47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBUaHJlYWRDcmVhdGVQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxUaHJlYWQ+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhib2R5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHt9LCBib2R5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvdGhyZWFkcycsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSB0aHJlYWQuXG4gICAqL1xuICByZXRyaWV2ZSh0aHJlYWRJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxUaHJlYWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL3RocmVhZHMvJHt0aHJlYWRJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZmllcyBhIHRocmVhZC5cbiAgICovXG4gIHVwZGF0ZSh0aHJlYWRJZDogc3RyaW5nLCBib2R5OiBUaHJlYWRVcGRhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFRocmVhZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3RocmVhZHMvJHt0aHJlYWRJZH1gLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgdGhyZWFkLlxuICAgKi9cbiAgZGVsKHRocmVhZElkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFRocmVhZERlbGV0ZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL3RocmVhZHMvJHt0aHJlYWRJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0aHJlYWQgYW5kIHJ1biBpdCBpbiBvbmUgcmVxdWVzdC5cbiAgICovXG4gIGNyZWF0ZUFuZFJ1bihcbiAgICBib2R5OiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8UnVuc0FQSS5SdW4+O1xuICBjcmVhdGVBbmRSdW4oXG4gICAgYm9keTogVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50Pj47XG4gIGNyZWF0ZUFuZFJ1bihcbiAgICBib2R5OiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50PiB8IFJ1bnNBUEkuUnVuPjtcbiAgY3JlYXRlQW5kUnVuKFxuICAgIGJvZHk6IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxSdW5zQVBJLlJ1bj4gfCBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50Pj4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL3RocmVhZHMvcnVucycsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgIHN0cmVhbTogYm9keS5zdHJlYW0gPz8gZmFsc2UsXG4gICAgfSkgYXMgQVBJUHJvbWlzZTxSdW5zQVBJLlJ1bj4gfCBBUElQcm9taXNlPFN0cmVhbTxBc3Npc3RhbnRzQVBJLkFzc2lzdGFudFN0cmVhbUV2ZW50Pj47XG4gIH1cblxuICAvKipcbiAgICogQSBoZWxwZXIgdG8gY3JlYXRlIGEgdGhyZWFkLCBzdGFydCBhIHJ1biBhbmQgdGhlbiBwb2xsIGZvciBhIHRlcm1pbmFsIHN0YXRlLlxuICAgKiBNb3JlIGluZm9ybWF0aW9uIG9uIFJ1biBsaWZlY3ljbGVzIGNhbiBiZSBmb3VuZCBoZXJlOlxuICAgKiBodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL2hvdy1pdC13b3Jrcy9ydW5zLWFuZC1ydW4tc3RlcHNcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUFuZFJ1blBvbGwoXG4gICAgYm9keTogVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zICYgeyBwb2xsSW50ZXJ2YWxNcz86IG51bWJlciB9LFxuICApOiBQcm9taXNlPFRocmVhZHMuUnVuPiB7XG4gICAgY29uc3QgcnVuID0gYXdhaXQgdGhpcy5jcmVhdGVBbmRSdW4oYm9keSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucnVucy5wb2xsKHJ1bi50aHJlYWRfaWQsIHJ1bi5pZCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGhyZWFkIGFuZCBzdHJlYW0gdGhlIHJ1biBiYWNrXG4gICAqL1xuICBjcmVhdGVBbmRSdW5TdHJlYW0oXG4gICAgYm9keTogVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zQmFzZVN0cmVhbSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQXNzaXN0YW50U3RyZWFtIHtcbiAgICByZXR1cm4gQXNzaXN0YW50U3RyZWFtLmNyZWF0ZVRocmVhZEFzc2lzdGFudFN0cmVhbShib2R5LCB0aGlzLl9jbGllbnQuYmV0YS50aHJlYWRzLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgZm9ybWF0IHRoYXQgdGhlIG1vZGVsIG11c3Qgb3V0cHV0LiBDb21wYXRpYmxlIHdpdGhcbiAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNG8pLFxuICogW0dQVC00IFR1cmJvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjZ3B0LTQtdHVyYm8tYW5kLWdwdC00KSxcbiAqIGFuZCBhbGwgR1BULTMuNSBUdXJibyBtb2RlbHMgc2luY2UgYGdwdC0zLjUtdHVyYm8tMTEwNmAuXG4gKlxuICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX3NjaGVtYVwiLCBcImpzb25fc2NoZW1hXCI6IHsuLi59IH1gIGVuYWJsZXMgU3RydWN0dXJlZFxuICogT3V0cHV0cyB3aGljaCBlbnN1cmVzIHRoZSBtb2RlbCB3aWxsIG1hdGNoIHlvdXIgc3VwcGxpZWQgSlNPTiBzY2hlbWEuIExlYXJuIG1vcmVcbiAqIGluIHRoZVxuICogW1N0cnVjdHVyZWQgT3V0cHV0cyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3N0cnVjdHVyZWQtb3V0cHV0cykuXG4gKlxuICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBlbnN1cmVzIHRoZVxuICogbWVzc2FnZSB0aGUgbW9kZWwgZ2VuZXJhdGVzIGlzIHZhbGlkIEpTT04uXG4gKlxuICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICogcHJvZHVjZSBKU09OIHlvdXJzZWxmIHZpYSBhIHN5c3RlbSBvciB1c2VyIG1lc3NhZ2UuIFdpdGhvdXQgdGhpcywgdGhlIG1vZGVsIG1heVxuICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAqIHRoZSBtZXNzYWdlIGNvbnRlbnQgbWF5IGJlIHBhcnRpYWxseSBjdXQgb2ZmIGlmIGBmaW5pc2hfcmVhc29uPVwibGVuZ3RoXCJgLCB3aGljaFxuICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICovXG5leHBvcnQgdHlwZSBBc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiA9XG4gIHwgJ2F1dG8nXG4gIHwgU2hhcmVkLlJlc3BvbnNlRm9ybWF0VGV4dFxuICB8IFNoYXJlZC5SZXNwb25zZUZvcm1hdEpTT05PYmplY3RcbiAgfCBTaGFyZWQuUmVzcG9uc2VGb3JtYXRKU09OU2NoZW1hO1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIHRvb2wgdGhlIG1vZGVsIHNob3VsZCB1c2UuIFVzZSB0byBmb3JjZSB0aGUgbW9kZWwgdG8gY2FsbCBhIHNwZWNpZmljXG4gKiB0b29sLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFzc2lzdGFudFRvb2xDaG9pY2Uge1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wuIElmIHR5cGUgaXMgYGZ1bmN0aW9uYCwgdGhlIGZ1bmN0aW9uIG5hbWUgbXVzdCBiZSBzZXRcbiAgICovXG4gIHR5cGU6ICdmdW5jdGlvbicgfCAnY29kZV9pbnRlcnByZXRlcicgfCAnZmlsZV9zZWFyY2gnO1xuXG4gIGZ1bmN0aW9uPzogQXNzaXN0YW50VG9vbENob2ljZUZ1bmN0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFzc2lzdGFudFRvb2xDaG9pY2VGdW5jdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICovXG4gIG5hbWU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBDb250cm9scyB3aGljaCAoaWYgYW55KSB0b29sIGlzIGNhbGxlZCBieSB0aGUgbW9kZWwuIGBub25lYCBtZWFucyB0aGUgbW9kZWwgd2lsbFxuICogbm90IGNhbGwgYW55IHRvb2xzIGFuZCBpbnN0ZWFkIGdlbmVyYXRlcyBhIG1lc3NhZ2UuIGBhdXRvYCBpcyB0aGUgZGVmYXVsdCB2YWx1ZVxuICogYW5kIG1lYW5zIHRoZSBtb2RlbCBjYW4gcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yIGNhbGxpbmcgb25lIG9yIG1vcmVcbiAqIHRvb2xzLiBgcmVxdWlyZWRgIG1lYW5zIHRoZSBtb2RlbCBtdXN0IGNhbGwgb25lIG9yIG1vcmUgdG9vbHMgYmVmb3JlIHJlc3BvbmRpbmdcbiAqIHRvIHRoZSB1c2VyLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciB0b29sIGxpa2UgYHtcInR5cGVcIjogXCJmaWxlX3NlYXJjaFwifWAgb3JcbiAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gKiBjYWxsIHRoYXQgdG9vbC5cbiAqL1xuZXhwb3J0IHR5cGUgQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiA9ICdub25lJyB8ICdhdXRvJyB8ICdyZXF1aXJlZCcgfCBBc3Npc3RhbnRUb29sQ2hvaWNlO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0aHJlYWQgdGhhdCBjb250YWluc1xuICogW21lc3NhZ2VzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUaHJlYWQge1xuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSB0aHJlYWQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhOiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYHRocmVhZGAuXG4gICAqL1xuICBvYmplY3Q6ICd0aHJlYWQnO1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICovXG4gIHRvb2xfcmVzb3VyY2VzOiBUaHJlYWQuVG9vbFJlc291cmNlcyB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVGhyZWFkIHtcbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYXNzaXN0YW50J3MgdG9vbHMgaW4gdGhpc1xuICAgKiB0aHJlYWQuIFRoZSByZXNvdXJjZXMgYXJlIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGVcbiAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgKiB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgSURzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzXG4gICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2wuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGVcbiAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgKiBhdHRhY2hlZCB0byB0aGlzIHRocmVhZC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvciBzdG9yZSBhdHRhY2hlZCB0b1xuICAgICAgICogdGhlIHRocmVhZC5cbiAgICAgICAqL1xuICAgICAgdmVjdG9yX3N0b3JlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkRGVsZXRlZCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgZGVsZXRlZDogYm9vbGVhbjtcblxuICBvYmplY3Q6ICd0aHJlYWQuZGVsZXRlZCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBbbWVzc2FnZXNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMpIHRvXG4gICAqIHN0YXJ0IHRoZSB0aHJlYWQgd2l0aC5cbiAgICovXG4gIG1lc3NhZ2VzPzogQXJyYXk8VGhyZWFkQ3JlYXRlUGFyYW1zLk1lc3NhZ2U+O1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICovXG4gIHRvb2xfcmVzb3VyY2VzPzogVGhyZWFkQ3JlYXRlUGFyYW1zLlRvb2xSZXNvdXJjZXMgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFRocmVhZENyZWF0ZVBhcmFtcyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8TWVzc2FnZXNBUEkuTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJvbGUgb2YgdGhlIGVudGl0eSB0aGF0IGlzIGNyZWF0aW5nIHRoZSBtZXNzYWdlLiBBbGxvd2VkIHZhbHVlcyBpbmNsdWRlOlxuICAgICAqXG4gICAgICogLSBgdXNlcmA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBzZW50IGJ5IGFuIGFjdHVhbCB1c2VyIGFuZCBzaG91bGQgYmUgdXNlZCBpblxuICAgICAqICAgbW9zdCBjYXNlcyB0byByZXByZXNlbnQgdXNlci1nZW5lcmF0ZWQgbWVzc2FnZXMuXG4gICAgICogLSBgYXNzaXN0YW50YDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGdlbmVyYXRlZCBieSB0aGUgYXNzaXN0YW50LiBVc2UgdGhpc1xuICAgICAqICAgdmFsdWUgdG8gaW5zZXJ0IG1lc3NhZ2VzIGZyb20gdGhlIGFzc2lzdGFudCBpbnRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgZmlsZXMgYXR0YWNoZWQgdG8gdGhlIG1lc3NhZ2UsIGFuZCB0aGUgdG9vbHMgdGhleSBzaG91bGQgYmUgYWRkZWQgdG8uXG4gICAgICovXG4gICAgYXR0YWNobWVudHM/OiBBcnJheTxNZXNzYWdlLkF0dGFjaG1lbnQ+IHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgKi9cbiAgICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBNZXNzYWdlIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIEF0dGFjaG1lbnQge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gYXR0YWNoIHRvIHRoZSBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkPzogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0b29scyB0byBhZGQgdGhpcyBmaWxlIHRvLlxuICAgICAgICovXG4gICAgICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEF0dGFjaG1lbnQuRmlsZVNlYXJjaD47XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBBdHRhY2htZW50IHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0b29sIGJlaW5nIGRlZmluZWQ6IGBmaWxlX3NlYXJjaGBcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdmaWxlX3NlYXJjaCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYXNzaXN0YW50J3MgdG9vbHMgaW4gdGhpc1xuICAgKiB0aHJlYWQuIFRoZSByZXNvdXJjZXMgYXJlIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGVcbiAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgKiB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgSURzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzXG4gICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2wuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGVcbiAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgKiBhdHRhY2hlZCB0byB0aGlzIHRocmVhZC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxIHZlY3RvciBzdG9yZSBhdHRhY2hlZCB0b1xuICAgICAgICogdGhlIHRocmVhZC5cbiAgICAgICAqL1xuICAgICAgdmVjdG9yX3N0b3JlX2lkcz86IEFycmF5PHN0cmluZz47XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBoZWxwZXIgdG8gY3JlYXRlIGFcbiAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgKiB3aXRoIGZpbGVfaWRzIGFuZCBhdHRhY2ggaXQgdG8gdGhpcyB0aHJlYWQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3JcbiAgICAgICAqIHN0b3JlIGF0dGFjaGVkIHRvIHRoZSB0aHJlYWQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZXM/OiBBcnJheTxGaWxlU2VhcmNoLlZlY3RvclN0b3JlPjtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIEZpbGVTZWFyY2gge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2h1bmtpbmcgc3RyYXRlZ3kgdXNlZCB0byBjaHVuayB0aGUgZmlsZShzKS4gSWYgbm90IHNldCwgd2lsbCB1c2UgdGhlIGBhdXRvYFxuICAgICAgICAgKiBzdHJhdGVneS4gT25seSBhcHBsaWNhYmxlIGlmIGBmaWxlX2lkc2AgaXMgbm9uLWVtcHR5LlxuICAgICAgICAgKi9cbiAgICAgICAgY2h1bmtpbmdfc3RyYXRlZ3k/OiBWZWN0b3JTdG9yZXNBUEkuRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgdG9cbiAgICAgICAgICogYWRkIHRvIHRoZSB2ZWN0b3Igc3RvcmUuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMTAwMDAgZmlsZXMgaW4gYSB2ZWN0b3JcbiAgICAgICAgICogc3RvcmUuXG4gICAgICAgICAqL1xuICAgICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB2ZWN0b3Igc3RvcmUuIFRoaXMgY2FuIGJlXG4gICAgICAgICAqIHVzZWZ1bCBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2ZWN0b3Igc3RvcmUgaW4gYSBzdHJ1Y3R1cmVkXG4gICAgICAgICAqIGZvcm1hdC4gS2V5cyBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bVxuICAgICAgICAgKiBvZiA1MTIgY2hhcmFjdGVycyBsb25nLlxuICAgICAgICAgKi9cbiAgICAgICAgbWV0YWRhdGE/OiB1bmtub3duO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRocmVhZFVwZGF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAqL1xuICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICovXG4gIHRvb2xfcmVzb3VyY2VzPzogVGhyZWFkVXBkYXRlUGFyYW1zLlRvb2xSZXNvdXJjZXMgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFRocmVhZFVwZGF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgY29kZV9pbnRlcnByZXRlcj86IFRvb2xSZXNvdXJjZXMuQ29kZUludGVycHJldGVyO1xuXG4gICAgZmlsZV9zZWFyY2g/OiBUb29sUmVzb3VyY2VzLkZpbGVTZWFyY2g7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgbWFkZVxuICAgICAgICogYXZhaWxhYmxlIHRvIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlc1xuICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyB0aHJlYWQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAqIHRoZSB0aHJlYWQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXMgPVxuICB8IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc05vblN0cmVhbWluZ1xuICB8IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc1N0cmVhbWluZztcblxuZXhwb3J0IGludGVyZmFjZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGVcbiAgICogW2Fzc2lzdGFudF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSB0byB1c2UgdG9cbiAgICogZXhlY3V0ZSB0aGlzIHJ1bi5cbiAgICovXG4gIGFzc2lzdGFudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBzeXN0ZW0gbWVzc2FnZSBvZiB0aGUgYXNzaXN0YW50LiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlXG4gICAqIHJ1bi4gVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zXG4gICAqIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGUgbnVtYmVyIG9mXG4gICAqIGNvbXBsZXRpb24gdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X2NvbXBsZXRpb25fdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHByb21wdCB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1bi5cbiAgICogVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIHByb21wdCB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogcHJvbXB0IHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLiBTZWVcbiAgICogYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9wcm9tcHRfdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBbTW9kZWxdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzKSB0b1xuICAgKiBiZSB1c2VkIHRvIGV4ZWN1dGUgdGhpcyBydW4uIElmIGEgdmFsdWUgaXMgcHJvdmlkZWQgaGVyZSwgaXQgd2lsbCBvdmVycmlkZSB0aGVcbiAgICogbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3Npc3RhbnQuIElmIG5vdCwgdGhlIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICogYXNzaXN0YW50IHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIG1vZGVsPzogKHN0cmluZyAmIHt9KSB8IENoYXRBUEkuQ2hhdE1vZGVsIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGVcbiAgICogW3BhcmFsbGVsIGZ1bmN0aW9uIGNhbGxpbmddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9mdW5jdGlvbi1jYWxsaW5nI2NvbmZpZ3VyaW5nLXBhcmFsbGVsLWZ1bmN0aW9uLWNhbGxpbmcpXG4gICAqIGR1cmluZyB0b29sIHVzZS5cbiAgICovXG4gIHBhcmFsbGVsX3Rvb2xfY2FsbHM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gICAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNG8pLFxuICAgKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscyNncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICAgKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fc2NoZW1hXCIsIFwianNvbl9zY2hlbWFcIjogey4uLn0gfWAgZW5hYmxlcyBTdHJ1Y3R1cmVkXG4gICAqIE91dHB1dHMgd2hpY2ggZW5zdXJlcyB0aGUgbW9kZWwgd2lsbCBtYXRjaCB5b3VyIHN1cHBsaWVkIEpTT04gc2NoZW1hLiBMZWFybiBtb3JlXG4gICAqIGluIHRoZVxuICAgKiBbU3RydWN0dXJlZCBPdXRwdXRzIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc3RydWN0dXJlZC1vdXRwdXRzKS5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBlbnN1cmVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHJldHVybnMgYSBzdHJlYW0gb2YgZXZlbnRzIHRoYXQgaGFwcGVuIGR1cmluZyB0aGUgUnVuIGFzIHNlcnZlci1zZW50XG4gICAqIGV2ZW50cywgdGVybWluYXRpbmcgd2hlbiB0aGUgUnVuIGVudGVycyBhIHRlcm1pbmFsIHN0YXRlIHdpdGggYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKi9cbiAgc3RyZWFtPzogYm9vbGVhbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoYXQgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdG8gdXNlLCBiZXR3ZWVuIDAgYW5kIDIuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbFxuICAgKiBtYWtlIHRoZSBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZVxuICAgKiBmb2N1c2VkIGFuZCBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJZiBubyB0aHJlYWQgaXMgcHJvdmlkZWQsIGFuIGVtcHR5IHRocmVhZCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqL1xuICB0aHJlYWQ/OiBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXMuVGhyZWFkO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyB3aGljaCAoaWYgYW55KSB0b29sIGlzIGNhbGxlZCBieSB0aGUgbW9kZWwuIGBub25lYCBtZWFucyB0aGUgbW9kZWwgd2lsbFxuICAgKiBub3QgY2FsbCBhbnkgdG9vbHMgYW5kIGluc3RlYWQgZ2VuZXJhdGVzIGEgbWVzc2FnZS4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAqIGFuZCBtZWFucyB0aGUgbW9kZWwgY2FuIHBpY2sgYmV0d2VlbiBnZW5lcmF0aW5nIGEgbWVzc2FnZSBvciBjYWxsaW5nIG9uZSBvciBtb3JlXG4gICAqIHRvb2xzLiBgcmVxdWlyZWRgIG1lYW5zIHRoZSBtb2RlbCBtdXN0IGNhbGwgb25lIG9yIG1vcmUgdG9vbHMgYmVmb3JlIHJlc3BvbmRpbmdcbiAgICogdG8gdGhlIHVzZXIuIFNwZWNpZnlpbmcgYSBwYXJ0aWN1bGFyIHRvb2wgbGlrZSBge1widHlwZVwiOiBcImZpbGVfc2VhcmNoXCJ9YCBvclxuICAgKiBge1widHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIm15X2Z1bmN0aW9uXCJ9fWAgZm9yY2VzIHRoZSBtb2RlbCB0b1xuICAgKiBjYWxsIHRoYXQgdG9vbC5cbiAgICovXG4gIHRvb2xfY2hvaWNlPzogQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBhc3Npc3RhbnQncyB0b29scy4gVGhlIHJlc291cmNlcyBhcmVcbiAgICogc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlc1xuICAgKiBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZVxuICAgKiBJRHMuXG4gICAqL1xuICB0b29sX3Jlc291cmNlcz86IFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtcy5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHRvb2xzIHRoZSBhc3Npc3RhbnQgY2FuIHVzZSBmb3IgdGhpcyBydW4uIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8XG4gICAgQXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXNzaXN0YW50c0FQSS5GaWxlU2VhcmNoVG9vbCB8IEFzc2lzdGFudHNBUEkuRnVuY3Rpb25Ub29sXG4gID4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICB0cnVuY2F0aW9uX3N0cmF0ZWd5PzogVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zLlRydW5jYXRpb25TdHJhdGVneSB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zIHtcbiAgLyoqXG4gICAqIElmIG5vIHRocmVhZCBpcyBwcm92aWRlZCwgYW4gZW1wdHkgdGhyZWFkIHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkIHtcbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgW21lc3NhZ2VzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzKSB0b1xuICAgICAqIHN0YXJ0IHRoZSB0aHJlYWQgd2l0aC5cbiAgICAgKi9cbiAgICBtZXNzYWdlcz86IEFycmF5PFRocmVhZC5NZXNzYWdlPjtcblxuICAgIC8qKlxuICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgKi9cbiAgICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBhc3Npc3RhbnQncyB0b29scyBpbiB0aGlzXG4gICAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgICAqIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBJRHMuXG4gICAgICovXG4gICAgdG9vbF9yZXNvdXJjZXM/OiBUaHJlYWQuVG9vbFJlc291cmNlcyB8IG51bGw7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRocmVhZCB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRleHQgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PE1lc3NhZ2VzQVBJLk1lc3NhZ2VDb250ZW50UGFydFBhcmFtPjtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcm9sZSBvZiB0aGUgZW50aXR5IHRoYXQgaXMgY3JlYXRpbmcgdGhlIG1lc3NhZ2UuIEFsbG93ZWQgdmFsdWVzIGluY2x1ZGU6XG4gICAgICAgKlxuICAgICAgICogLSBgdXNlcmA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBzZW50IGJ5IGFuIGFjdHVhbCB1c2VyIGFuZCBzaG91bGQgYmUgdXNlZCBpblxuICAgICAgICogICBtb3N0IGNhc2VzIHRvIHJlcHJlc2VudCB1c2VyLWdlbmVyYXRlZCBtZXNzYWdlcy5cbiAgICAgICAqIC0gYGFzc2lzdGFudGA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBnZW5lcmF0ZWQgYnkgdGhlIGFzc2lzdGFudC4gVXNlIHRoaXNcbiAgICAgICAqICAgdmFsdWUgdG8gaW5zZXJ0IG1lc3NhZ2VzIGZyb20gdGhlIGFzc2lzdGFudCBpbnRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICAgKi9cbiAgICAgIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byB0aGUgbWVzc2FnZSwgYW5kIHRoZSB0b29scyB0aGV5IHNob3VsZCBiZSBhZGRlZCB0by5cbiAgICAgICAqL1xuICAgICAgYXR0YWNobWVudHM/OiBBcnJheTxNZXNzYWdlLkF0dGFjaG1lbnQ+IHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAgICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICAgKi9cbiAgICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBNZXNzYWdlIHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gYXR0YWNoIHRvIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZV9pZD86IHN0cmluZztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvb2xzIHRvIGFkZCB0aGlzIGZpbGUgdG8uXG4gICAgICAgICAqL1xuICAgICAgICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEF0dGFjaG1lbnQuRmlsZVNlYXJjaD47XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydCBuYW1lc3BhY2UgQXR0YWNobWVudCB7XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIHR5cGUgb2YgdG9vbCBiZWluZyBkZWZpbmVkOiBgZmlsZV9zZWFyY2hgXG4gICAgICAgICAgICovXG4gICAgICAgICAgdHlwZTogJ2ZpbGVfc2VhcmNoJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYXNzaXN0YW50J3MgdG9vbHMgaW4gdGhpc1xuICAgICAqIHRocmVhZC4gVGhlIHJlc291cmNlcyBhcmUgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZVxuICAgICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICAgKiB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgSURzLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICAgIGZpbGVfc2VhcmNoPzogVG9vbFJlc291cmNlcy5GaWxlU2VhcmNoO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgICAqIGF2YWlsYWJsZSB0byB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMjAgZmlsZXNcbiAgICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlXG4gICAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgdGhyZWFkLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvXG4gICAgICAgICAqIHRoZSB0aHJlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB2ZWN0b3Jfc3RvcmVfaWRzPzogQXJyYXk8c3RyaW5nPjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBoZWxwZXIgdG8gY3JlYXRlIGFcbiAgICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAgICogd2l0aCBmaWxlX2lkcyBhbmQgYXR0YWNoIGl0IHRvIHRoaXMgdGhyZWFkLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yXG4gICAgICAgICAqIHN0b3JlIGF0dGFjaGVkIHRvIHRoZSB0aHJlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB2ZWN0b3Jfc3RvcmVzPzogQXJyYXk8RmlsZVNlYXJjaC5WZWN0b3JTdG9yZT47XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydCBuYW1lc3BhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmUge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBjaHVua2luZyBzdHJhdGVneSB1c2VkIHRvIGNodW5rIHRoZSBmaWxlKHMpLiBJZiBub3Qgc2V0LCB3aWxsIHVzZSB0aGUgYGF1dG9gXG4gICAgICAgICAgICogc3RyYXRlZ3kuIE9ubHkgYXBwbGljYWJsZSBpZiBgZmlsZV9pZHNgIGlzIG5vbi1lbXB0eS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjaHVua2luZ19zdHJhdGVneT86IFZlY3RvclN0b3Jlc0FQSS5GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgdG9cbiAgICAgICAgICAgKiBhZGQgdG8gdGhlIHZlY3RvciBzdG9yZS4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxMDAwMCBmaWxlcyBpbiBhIHZlY3RvclxuICAgICAgICAgICAqIHN0b3JlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB2ZWN0b3Igc3RvcmUuIFRoaXMgY2FuIGJlXG4gICAgICAgICAgICogdXNlZnVsIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZlY3RvciBzdG9yZSBpbiBhIHN0cnVjdHVyZWRcbiAgICAgICAgICAgKiBmb3JtYXQuIEtleXMgY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW1cbiAgICAgICAgICAgKiBvZiA1MTIgY2hhcmFjdGVycyBsb25nLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1ldGFkYXRhPzogdW5rbm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgdXNlZCBieSB0aGUgYXNzaXN0YW50J3MgdG9vbHMuIFRoZSByZXNvdXJjZXMgYXJlXG4gICAqIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXNcbiAgICogYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVcbiAgICogSURzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzXG4gICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2wuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSUQgb2YgdGhlXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyBhc3Npc3RhbnQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAqIHRoZSBhc3Npc3RhbnQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUcnVuY2F0aW9uU3RyYXRlZ3kge1xuICAgIC8qKlxuICAgICAqIFRoZSB0cnVuY2F0aW9uIHN0cmF0ZWd5IHRvIHVzZSBmb3IgdGhlIHRocmVhZC4gVGhlIGRlZmF1bHQgaXMgYGF1dG9gLiBJZiBzZXQgdG9cbiAgICAgKiBgbGFzdF9tZXNzYWdlc2AsIHRoZSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgdG8gdGhlIG4gbW9zdCByZWNlbnQgbWVzc2FnZXMgaW5cbiAgICAgKiB0aGUgdGhyZWFkLiBXaGVuIHNldCB0byBgYXV0b2AsIG1lc3NhZ2VzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHRocmVhZCB3aWxsIGJlXG4gICAgICogZHJvcHBlZCB0byBmaXQgdGhlIGNvbnRleHQgbGVuZ3RoIG9mIHRoZSBtb2RlbCwgYG1heF9wcm9tcHRfdG9rZW5zYC5cbiAgICAgKi9cbiAgICB0eXBlOiAnYXV0bycgfCAnbGFzdF9tZXNzYWdlcyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGZyb20gdGhlIHRocmVhZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgY29udGV4dFxuICAgICAqIGZvciB0aGUgcnVuLlxuICAgICAqL1xuICAgIGxhc3RfbWVzc2FnZXM/OiBudW1iZXIgfCBudWxsO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zTm9uU3RyZWFtaW5nID0gVGhyZWFkc0FQSS5UaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNOb25TdHJlYW1pbmc7XG4gIGV4cG9ydCB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc1N0cmVhbWluZyA9IFRocmVhZHNBUEkuVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zU3RyZWFtaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc05vblN0cmVhbWluZyBleHRlbmRzIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogSWYgYHRydWVgLCByZXR1cm5zIGEgc3RyZWFtIG9mIGV2ZW50cyB0aGF0IGhhcHBlbiBkdXJpbmcgdGhlIFJ1biBhcyBzZXJ2ZXItc2VudFxuICAgKiBldmVudHMsIHRlcm1pbmF0aW5nIHdoZW4gdGhlIFJ1biBlbnRlcnMgYSB0ZXJtaW5hbCBzdGF0ZSB3aXRoIGEgYGRhdGE6IFtET05FXWBcbiAgICogbWVzc2FnZS5cbiAgICovXG4gIHN0cmVhbT86IGZhbHNlIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNTdHJlYW1pbmcgZXh0ZW5kcyBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgcmV0dXJucyBhIHN0cmVhbSBvZiBldmVudHMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoZSBSdW4gYXMgc2VydmVyLXNlbnRcbiAgICogZXZlbnRzLCB0ZXJtaW5hdGluZyB3aGVuIHRoZSBSdW4gZW50ZXJzIGEgdGVybWluYWwgc3RhdGUgd2l0aCBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqL1xuICBzdHJlYW06IHRydWU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkQ3JlYXRlQW5kUnVuUG9sbFBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlXG4gICAqIFthc3Npc3RhbnRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgdG8gdXNlIHRvXG4gICAqIGV4ZWN1dGUgdGhpcyBydW4uXG4gICAqL1xuICBhc3Npc3RhbnRfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgc3lzdGVtIG1lc3NhZ2Ugb2YgdGhlIGFzc2lzdGFudC4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb24gYSBwZXItcnVuIGJhc2lzLlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zIHRoYXQgbWF5IGJlIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZVxuICAgKiBydW4uIFRoZSBydW4gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdXNlIG9ubHkgdGhlIG51bWJlciBvZiBjb21wbGV0aW9uIHRva2Vuc1xuICAgKiBzcGVjaWZpZWQsIGFjcm9zcyBtdWx0aXBsZSB0dXJucyBvZiB0aGUgcnVuLiBJZiB0aGUgcnVuIGV4Y2VlZHMgdGhlIG51bWJlciBvZlxuICAgKiBjb21wbGV0aW9uIHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLiBTZWVcbiAgICogYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9jb21wbGV0aW9uX3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zIHRoYXQgbWF5IGJlIHVzZWQgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBydW4uXG4gICAqIFRoZSBydW4gd2lsbCBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdXNlIG9ubHkgdGhlIG51bWJlciBvZiBwcm9tcHQgdG9rZW5zXG4gICAqIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGUgbnVtYmVyIG9mXG4gICAqIHByb21wdCB0b2tlbnMgc3BlY2lmaWVkLCB0aGUgcnVuIHdpbGwgZW5kIHdpdGggc3RhdHVzIGBpbmNvbXBsZXRlYC4gU2VlXG4gICAqIGBpbmNvbXBsZXRlX2RldGFpbHNgIGZvciBtb3JlIGluZm8uXG4gICAqL1xuICBtYXhfcHJvbXB0X3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgW01vZGVsXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscykgdG9cbiAgICogYmUgdXNlZCB0byBleGVjdXRlIHRoaXMgcnVuLiBJZiBhIHZhbHVlIGlzIHByb3ZpZGVkIGhlcmUsIGl0IHdpbGwgb3ZlcnJpZGUgdGhlXG4gICAqIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzaXN0YW50LiBJZiBub3QsIHRoZSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAqIGFzc2lzdGFudCB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICBtb2RlbD86XG4gICAgfCAoc3RyaW5nICYge30pXG4gICAgfCAnZ3B0LTRvJ1xuICAgIHwgJ2dwdC00by0yMDI0LTA1LTEzJ1xuICAgIHwgJ2dwdC00LXR1cmJvJ1xuICAgIHwgJ2dwdC00LXR1cmJvLTIwMjQtMDQtMDknXG4gICAgfCAnZ3B0LTQtMDEyNS1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LXR1cmJvLXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtMTEwNi1wcmV2aWV3J1xuICAgIHwgJ2dwdC00LXZpc2lvbi1wcmV2aWV3J1xuICAgIHwgJ2dwdC00J1xuICAgIHwgJ2dwdC00LTAzMTQnXG4gICAgfCAnZ3B0LTQtMDYxMydcbiAgICB8ICdncHQtNC0zMmsnXG4gICAgfCAnZ3B0LTQtMzJrLTAzMTQnXG4gICAgfCAnZ3B0LTQtMzJrLTA2MTMnXG4gICAgfCAnZ3B0LTMuNS10dXJibydcbiAgICB8ICdncHQtMy41LXR1cmJvLTE2aydcbiAgICB8ICdncHQtMy41LXR1cmJvLTA2MTMnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xMTA2J1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMDEyNSdcbiAgICB8ICdncHQtMy41LXR1cmJvLTE2ay0wNjEzJ1xuICAgIHwgbnVsbDtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBmb3JtYXQgdGhhdCB0aGUgbW9kZWwgbXVzdCBvdXRwdXQuIENvbXBhdGlibGUgd2l0aFxuICAgKiBbR1BULTRvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMvZ3B0LTRvKSxcbiAgICogW0dQVC00IFR1cmJvXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMvZ3B0LTQtdHVyYm8tYW5kLWdwdC00KSxcbiAgICogYW5kIGFsbCBHUFQtMy41IFR1cmJvIG1vZGVscyBzaW5jZSBgZ3B0LTMuNS10dXJiby0xMTA2YC5cbiAgICpcbiAgICogU2V0dGluZyB0byBgeyBcInR5cGVcIjogXCJqc29uX29iamVjdFwiIH1gIGVuYWJsZXMgSlNPTiBtb2RlLCB3aGljaCBndWFyYW50ZWVzIHRoZVxuICAgKiBtZXNzYWdlIHRoZSBtb2RlbCBnZW5lcmF0ZXMgaXMgdmFsaWQgSlNPTi5cbiAgICpcbiAgICogKipJbXBvcnRhbnQ6Kiogd2hlbiB1c2luZyBKU09OIG1vZGUsIHlvdSAqKm11c3QqKiBhbHNvIGluc3RydWN0IHRoZSBtb2RlbCB0b1xuICAgKiBwcm9kdWNlIEpTT04geW91cnNlbGYgdmlhIGEgc3lzdGVtIG9yIHVzZXIgbWVzc2FnZS4gV2l0aG91dCB0aGlzLCB0aGUgbW9kZWwgbWF5XG4gICAqIGdlbmVyYXRlIGFuIHVuZW5kaW5nIHN0cmVhbSBvZiB3aGl0ZXNwYWNlIHVudGlsIHRoZSBnZW5lcmF0aW9uIHJlYWNoZXMgdGhlIHRva2VuXG4gICAqIGxpbWl0LCByZXN1bHRpbmcgaW4gYSBsb25nLXJ1bm5pbmcgYW5kIHNlZW1pbmdseSBcInN0dWNrXCIgcmVxdWVzdC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhlIG1lc3NhZ2UgY29udGVudCBtYXkgYmUgcGFydGlhbGx5IGN1dCBvZmYgaWYgYGZpbmlzaF9yZWFzb249XCJsZW5ndGhcImAsIHdoaWNoXG4gICAqIGluZGljYXRlcyB0aGUgZ2VuZXJhdGlvbiBleGNlZWRlZCBgbWF4X3Rva2Vuc2Agb3IgdGhlIGNvbnZlcnNhdGlvbiBleGNlZWRlZCB0aGVcbiAgICogbWF4IGNvbnRleHQgbGVuZ3RoLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogSWYgbm8gdGhyZWFkIGlzIHByb3ZpZGVkLCBhbiBlbXB0eSB0aHJlYWQgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgdGhyZWFkPzogVGhyZWFkQ3JlYXRlQW5kUnVuUG9sbFBhcmFtcy5UaHJlYWQ7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIHdoaWNoIChpZiBhbnkpIHRvb2wgaXMgY2FsbGVkIGJ5IHRoZSBtb2RlbC4gYG5vbmVgIG1lYW5zIHRoZSBtb2RlbCB3aWxsXG4gICAqIG5vdCBjYWxsIGFueSB0b29scyBhbmQgaW5zdGVhZCBnZW5lcmF0ZXMgYSBtZXNzYWdlLiBgYXV0b2AgaXMgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICogYW5kIG1lYW5zIHRoZSBtb2RlbCBjYW4gcGljayBiZXR3ZWVuIGdlbmVyYXRpbmcgYSBtZXNzYWdlIG9yIGNhbGxpbmcgb25lIG9yIG1vcmVcbiAgICogdG9vbHMuIGByZXF1aXJlZGAgbWVhbnMgdGhlIG1vZGVsIG11c3QgY2FsbCBvbmUgb3IgbW9yZSB0b29scyBiZWZvcmUgcmVzcG9uZGluZ1xuICAgKiB0byB0aGUgdXNlci4gU3BlY2lmeWluZyBhIHBhcnRpY3VsYXIgdG9vbCBsaWtlIGB7XCJ0eXBlXCI6IFwiZmlsZV9zZWFyY2hcIn1gIG9yXG4gICAqIGB7XCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwibXlfZnVuY3Rpb25cIn19YCBmb3JjZXMgdGhlIG1vZGVsIHRvXG4gICAqIGNhbGwgdGhhdCB0b29sLlxuICAgKi9cbiAgdG9vbF9jaG9pY2U/OiBBc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIGFzc2lzdGFudCdzIHRvb2xzLiBUaGUgcmVzb3VyY2VzIGFyZVxuICAgKiBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzXG4gICAqIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlXG4gICAqIElEcy5cbiAgICovXG4gIHRvb2xfcmVzb3VyY2VzPzogVGhyZWFkQ3JlYXRlQW5kUnVuUG9sbFBhcmFtcy5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHRvb2xzIHRoZSBhc3Npc3RhbnQgY2FuIHVzZSBmb3IgdGhpcyBydW4uIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8XG4gICAgQXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXNzaXN0YW50c0FQSS5GaWxlU2VhcmNoVG9vbCB8IEFzc2lzdGFudHNBUEkuRnVuY3Rpb25Ub29sXG4gID4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICB0cnVuY2F0aW9uX3N0cmF0ZWd5PzogVGhyZWFkQ3JlYXRlQW5kUnVuUG9sbFBhcmFtcy5UcnVuY2F0aW9uU3RyYXRlZ3kgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFRocmVhZENyZWF0ZUFuZFJ1blBvbGxQYXJhbXMge1xuICAvKipcbiAgICogSWYgbm8gdGhyZWFkIGlzIHByb3ZpZGVkLCBhbiBlbXB0eSB0aHJlYWQgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUaHJlYWQge1xuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBbbWVzc2FnZXNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMpIHRvXG4gICAgICogc3RhcnQgdGhlIHRocmVhZCB3aXRoLlxuICAgICAqL1xuICAgIG1lc3NhZ2VzPzogQXJyYXk8VGhyZWFkLk1lc3NhZ2U+O1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAgICogY2hhcmFjdGVycyBsb25nLlxuICAgICAqL1xuICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGFzc2lzdGFudCdzIHRvb2xzIGluIHRoaXNcbiAgICAgKiB0aHJlYWQuIFRoZSByZXNvdXJjZXMgYXJlIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGVcbiAgICAgKiBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgXG4gICAgICogdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIElEcy5cbiAgICAgKi9cbiAgICB0b29sX3Jlc291cmNlcz86IFRocmVhZC5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVGhyZWFkIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdGV4dCBjb250ZW50cyBvZiB0aGUgbWVzc2FnZS5cbiAgICAgICAqL1xuICAgICAgY29udGVudDogc3RyaW5nIHwgQXJyYXk8TWVzc2FnZXNBUEkuTWVzc2FnZUNvbnRlbnRQYXJ0UGFyYW0+O1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSByb2xlIG9mIHRoZSBlbnRpdHkgdGhhdCBpcyBjcmVhdGluZyB0aGUgbWVzc2FnZS4gQWxsb3dlZCB2YWx1ZXMgaW5jbHVkZTpcbiAgICAgICAqXG4gICAgICAgKiAtIGB1c2VyYDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIHNlbnQgYnkgYW4gYWN0dWFsIHVzZXIgYW5kIHNob3VsZCBiZSB1c2VkIGluXG4gICAgICAgKiAgIG1vc3QgY2FzZXMgdG8gcmVwcmVzZW50IHVzZXItZ2VuZXJhdGVkIG1lc3NhZ2VzLlxuICAgICAgICogLSBgYXNzaXN0YW50YDogSW5kaWNhdGVzIHRoZSBtZXNzYWdlIGlzIGdlbmVyYXRlZCBieSB0aGUgYXNzaXN0YW50LiBVc2UgdGhpc1xuICAgICAgICogICB2YWx1ZSB0byBpbnNlcnQgbWVzc2FnZXMgZnJvbSB0aGUgYXNzaXN0YW50IGludG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgICAqL1xuICAgICAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIHRoZSBtZXNzYWdlLCBhbmQgdGhlIHRvb2xzIHRoZXkgc2hvdWxkIGJlIGFkZGVkIHRvLlxuICAgICAgICovXG4gICAgICBhdHRhY2htZW50cz86IEFycmF5PE1lc3NhZ2UuQXR0YWNobWVudD4gfCBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgICAqIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LiBLZXlzXG4gICAgICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgICAqL1xuICAgICAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIE1lc3NhZ2Uge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBBdHRhY2htZW50IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBhdHRhY2ggdG8gdGhlIG1lc3NhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBmaWxlX2lkPzogc3RyaW5nO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG9vbHMgdG8gYWRkIHRoaXMgZmlsZSB0by5cbiAgICAgICAgICovXG4gICAgICAgIHRvb2xzPzogQXJyYXk8QXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXNzaXN0YW50c0FQSS5GaWxlU2VhcmNoVG9vbD47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBhc3Npc3RhbnQncyB0b29scyBpbiB0aGlzXG4gICAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgICAqIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBJRHMuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICAgIGNvZGVfaW50ZXJwcmV0ZXI/OiBUb29sUmVzb3VyY2VzLkNvZGVJbnRlcnByZXRlcjtcblxuICAgICAgZmlsZV9zZWFyY2g/OiBUb29sUmVzb3VyY2VzLkZpbGVTZWFyY2g7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIG1hZGVcbiAgICAgICAgICogYXZhaWxhYmxlIHRvIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlc1xuICAgICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2wuXG4gICAgICAgICAqL1xuICAgICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVcbiAgICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyB0aHJlYWQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAgICogdGhlIHRocmVhZC5cbiAgICAgICAgICovXG4gICAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGhlbHBlciB0byBjcmVhdGUgYVxuICAgICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICAgKiB3aXRoIGZpbGVfaWRzIGFuZCBhdHRhY2ggaXQgdG8gdGhpcyB0aHJlYWQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3JcbiAgICAgICAgICogc3RvcmUgYXR0YWNoZWQgdG8gdGhlIHRocmVhZC5cbiAgICAgICAgICovXG4gICAgICAgIHZlY3Rvcl9zdG9yZXM/OiBBcnJheTxGaWxlU2VhcmNoLlZlY3RvclN0b3JlPjtcbiAgICAgIH1cblxuICAgICAgZXhwb3J0IG5hbWVzcGFjZSBGaWxlU2VhcmNoIHtcbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgdG9cbiAgICAgICAgICAgKiBhZGQgdG8gdGhlIHZlY3RvciBzdG9yZS4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAxMDAwMCBmaWxlcyBpbiBhIHZlY3RvclxuICAgICAgICAgICAqIHN0b3JlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB2ZWN0b3Igc3RvcmUuIFRoaXMgY2FuIGJlXG4gICAgICAgICAgICogdXNlZnVsIGZvciBzdG9yaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZlY3RvciBzdG9yZSBpbiBhIHN0cnVjdHVyZWRcbiAgICAgICAgICAgKiBmb3JtYXQuIEtleXMgY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW1cbiAgICAgICAgICAgKiBvZiA1MTIgY2hhcmFjdGVycyBsb25nLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1ldGFkYXRhPzogdW5rbm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNldCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgdXNlZCBieSB0aGUgYXNzaXN0YW50J3MgdG9vbHMuIFRoZSByZXNvdXJjZXMgYXJlXG4gICAqIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIHRvb2wuIEZvciBleGFtcGxlLCB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXNcbiAgICogYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVcbiAgICogSURzLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUb29sUmVzb3VyY2VzIHtcbiAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICBmaWxlX3NlYXJjaD86IFRvb2xSZXNvdXJjZXMuRmlsZVNlYXJjaDtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBDb2RlSW50ZXJwcmV0ZXIge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDIwIGZpbGVzXG4gICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2wuXG4gICAgICAgKi9cbiAgICAgIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSUQgb2YgdGhlXG4gICAgICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgICAgICogYXR0YWNoZWQgdG8gdGhpcyBhc3Npc3RhbnQuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMSB2ZWN0b3Igc3RvcmUgYXR0YWNoZWQgdG9cbiAgICAgICAqIHRoZSBhc3Npc3RhbnQuXG4gICAgICAgKi9cbiAgICAgIHZlY3Rvcl9zdG9yZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9scyBmb3IgaG93IGEgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHByaW9yIHRvIHRoZSBydW4uIFVzZSB0aGlzIHRvXG4gICAqIGNvbnRyb2wgdGhlIGludGlhbCBjb250ZXh0IHdpbmRvdyBvZiB0aGUgcnVuLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUcnVuY2F0aW9uU3RyYXRlZ3kge1xuICAgIC8qKlxuICAgICAqIFRoZSB0cnVuY2F0aW9uIHN0cmF0ZWd5IHRvIHVzZSBmb3IgdGhlIHRocmVhZC4gVGhlIGRlZmF1bHQgaXMgYGF1dG9gLiBJZiBzZXQgdG9cbiAgICAgKiBgbGFzdF9tZXNzYWdlc2AsIHRoZSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgdG8gdGhlIG4gbW9zdCByZWNlbnQgbWVzc2FnZXMgaW5cbiAgICAgKiB0aGUgdGhyZWFkLiBXaGVuIHNldCB0byBgYXV0b2AsIG1lc3NhZ2VzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHRocmVhZCB3aWxsIGJlXG4gICAgICogZHJvcHBlZCB0byBmaXQgdGhlIGNvbnRleHQgbGVuZ3RoIG9mIHRoZSBtb2RlbCwgYG1heF9wcm9tcHRfdG9rZW5zYC5cbiAgICAgKi9cbiAgICB0eXBlOiAnYXV0bycgfCAnbGFzdF9tZXNzYWdlcyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGZyb20gdGhlIHRocmVhZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgY29udGV4dFxuICAgICAqIGZvciB0aGUgcnVuLlxuICAgICAqL1xuICAgIGxhc3RfbWVzc2FnZXM/OiBudW1iZXIgfCBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkQ3JlYXRlQW5kUnVuU3RyZWFtUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGVcbiAgICogW2Fzc2lzdGFudF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hc3Npc3RhbnRzKSB0byB1c2UgdG9cbiAgICogZXhlY3V0ZSB0aGlzIHJ1bi5cbiAgICovXG4gIGFzc2lzdGFudF9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBzeXN0ZW0gbWVzc2FnZSBvZiB0aGUgYXNzaXN0YW50LiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvbiBhIHBlci1ydW4gYmFzaXMuXG4gICAqL1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29tcGxldGlvbiB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlXG4gICAqIHJ1bi4gVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIGNvbXBsZXRpb24gdG9rZW5zXG4gICAqIHNwZWNpZmllZCwgYWNyb3NzIG11bHRpcGxlIHR1cm5zIG9mIHRoZSBydW4uIElmIHRoZSBydW4gZXhjZWVkcyB0aGUgbnVtYmVyIG9mXG4gICAqIGNvbXBsZXRpb24gdG9rZW5zIHNwZWNpZmllZCwgdGhlIHJ1biB3aWxsIGVuZCB3aXRoIHN0YXR1cyBgaW5jb21wbGV0ZWAuIFNlZVxuICAgKiBgaW5jb21wbGV0ZV9kZXRhaWxzYCBmb3IgbW9yZSBpbmZvLlxuICAgKi9cbiAgbWF4X2NvbXBsZXRpb25fdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHByb21wdCB0b2tlbnMgdGhhdCBtYXkgYmUgdXNlZCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHJ1bi5cbiAgICogVGhlIHJ1biB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB1c2Ugb25seSB0aGUgbnVtYmVyIG9mIHByb21wdCB0b2tlbnNcbiAgICogc3BlY2lmaWVkLCBhY3Jvc3MgbXVsdGlwbGUgdHVybnMgb2YgdGhlIHJ1bi4gSWYgdGhlIHJ1biBleGNlZWRzIHRoZSBudW1iZXIgb2ZcbiAgICogcHJvbXB0IHRva2VucyBzcGVjaWZpZWQsIHRoZSBydW4gd2lsbCBlbmQgd2l0aCBzdGF0dXMgYGluY29tcGxldGVgLiBTZWVcbiAgICogYGluY29tcGxldGVfZGV0YWlsc2AgZm9yIG1vcmUgaW5mby5cbiAgICovXG4gIG1heF9wcm9tcHRfdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBbTW9kZWxdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzKSB0b1xuICAgKiBiZSB1c2VkIHRvIGV4ZWN1dGUgdGhpcyBydW4uIElmIGEgdmFsdWUgaXMgcHJvdmlkZWQgaGVyZSwgaXQgd2lsbCBvdmVycmlkZSB0aGVcbiAgICogbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3Npc3RhbnQuIElmIG5vdCwgdGhlIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICogYXNzaXN0YW50IHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIG1vZGVsPzpcbiAgICB8IChzdHJpbmcgJiB7fSlcbiAgICB8ICdncHQtNG8nXG4gICAgfCAnZ3B0LTRvLTIwMjQtMDUtMTMnXG4gICAgfCAnZ3B0LTQtdHVyYm8nXG4gICAgfCAnZ3B0LTQtdHVyYm8tMjAyNC0wNC0wOSdcbiAgICB8ICdncHQtNC0wMTI1LXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtdHVyYm8tcHJldmlldydcbiAgICB8ICdncHQtNC0xMTA2LXByZXZpZXcnXG4gICAgfCAnZ3B0LTQtdmlzaW9uLXByZXZpZXcnXG4gICAgfCAnZ3B0LTQnXG4gICAgfCAnZ3B0LTQtMDMxNCdcbiAgICB8ICdncHQtNC0wNjEzJ1xuICAgIHwgJ2dwdC00LTMyaydcbiAgICB8ICdncHQtNC0zMmstMDMxNCdcbiAgICB8ICdncHQtNC0zMmstMDYxMydcbiAgICB8ICdncHQtMy41LXR1cmJvJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTZrJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMDYxMydcbiAgICB8ICdncHQtMy41LXR1cmJvLTExMDYnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0wMTI1J1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMTZrLTA2MTMnXG4gICAgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZvcm1hdCB0aGF0IHRoZSBtb2RlbCBtdXN0IG91dHB1dC4gQ29tcGF0aWJsZSB3aXRoXG4gICAqIFtHUFQtNG9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscy9ncHQtNG8pLFxuICAgKiBbR1BULTQgVHVyYm9dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscy9ncHQtNC10dXJiby1hbmQtZ3B0LTQpLFxuICAgKiBhbmQgYWxsIEdQVC0zLjUgVHVyYm8gbW9kZWxzIHNpbmNlIGBncHQtMy41LXR1cmJvLTExMDZgLlxuICAgKlxuICAgKiBTZXR0aW5nIHRvIGB7IFwidHlwZVwiOiBcImpzb25fb2JqZWN0XCIgfWAgZW5hYmxlcyBKU09OIG1vZGUsIHdoaWNoIGd1YXJhbnRlZXMgdGhlXG4gICAqIG1lc3NhZ2UgdGhlIG1vZGVsIGdlbmVyYXRlcyBpcyB2YWxpZCBKU09OLlxuICAgKlxuICAgKiAqKkltcG9ydGFudDoqKiB3aGVuIHVzaW5nIEpTT04gbW9kZSwgeW91ICoqbXVzdCoqIGFsc28gaW5zdHJ1Y3QgdGhlIG1vZGVsIHRvXG4gICAqIHByb2R1Y2UgSlNPTiB5b3Vyc2VsZiB2aWEgYSBzeXN0ZW0gb3IgdXNlciBtZXNzYWdlLiBXaXRob3V0IHRoaXMsIHRoZSBtb2RlbCBtYXlcbiAgICogZ2VuZXJhdGUgYW4gdW5lbmRpbmcgc3RyZWFtIG9mIHdoaXRlc3BhY2UgdW50aWwgdGhlIGdlbmVyYXRpb24gcmVhY2hlcyB0aGUgdG9rZW5cbiAgICogbGltaXQsIHJlc3VsdGluZyBpbiBhIGxvbmctcnVubmluZyBhbmQgc2VlbWluZ2x5IFwic3R1Y2tcIiByZXF1ZXN0LiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGUgbWVzc2FnZSBjb250ZW50IG1heSBiZSBwYXJ0aWFsbHkgY3V0IG9mZiBpZiBgZmluaXNoX3JlYXNvbj1cImxlbmd0aFwiYCwgd2hpY2hcbiAgICogaW5kaWNhdGVzIHRoZSBnZW5lcmF0aW9uIGV4Y2VlZGVkIGBtYXhfdG9rZW5zYCBvciB0aGUgY29udmVyc2F0aW9uIGV4Y2VlZGVkIHRoZVxuICAgKiBtYXggY29udGV4dCBsZW5ndGguXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBBc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoYXQgc2FtcGxpbmcgdGVtcGVyYXR1cmUgdG8gdXNlLCBiZXR3ZWVuIDAgYW5kIDIuIEhpZ2hlciB2YWx1ZXMgbGlrZSAwLjggd2lsbFxuICAgKiBtYWtlIHRoZSBvdXRwdXQgbW9yZSByYW5kb20sIHdoaWxlIGxvd2VyIHZhbHVlcyBsaWtlIDAuMiB3aWxsIG1ha2UgaXQgbW9yZVxuICAgKiBmb2N1c2VkIGFuZCBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJZiBubyB0aHJlYWQgaXMgcHJvdmlkZWQsIGFuIGVtcHR5IHRocmVhZCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqL1xuICB0aHJlYWQ/OiBUaHJlYWRDcmVhdGVBbmRSdW5TdHJlYW1QYXJhbXMuVGhyZWFkO1xuXG4gIC8qKlxuICAgKiBDb250cm9scyB3aGljaCAoaWYgYW55KSB0b29sIGlzIGNhbGxlZCBieSB0aGUgbW9kZWwuIGBub25lYCBtZWFucyB0aGUgbW9kZWwgd2lsbFxuICAgKiBub3QgY2FsbCBhbnkgdG9vbHMgYW5kIGluc3RlYWQgZ2VuZXJhdGVzIGEgbWVzc2FnZS4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAqIGFuZCBtZWFucyB0aGUgbW9kZWwgY2FuIHBpY2sgYmV0d2VlbiBnZW5lcmF0aW5nIGEgbWVzc2FnZSBvciBjYWxsaW5nIG9uZSBvciBtb3JlXG4gICAqIHRvb2xzLiBgcmVxdWlyZWRgIG1lYW5zIHRoZSBtb2RlbCBtdXN0IGNhbGwgb25lIG9yIG1vcmUgdG9vbHMgYmVmb3JlIHJlc3BvbmRpbmdcbiAgICogdG8gdGhlIHVzZXIuIFNwZWNpZnlpbmcgYSBwYXJ0aWN1bGFyIHRvb2wgbGlrZSBge1widHlwZVwiOiBcImZpbGVfc2VhcmNoXCJ9YCBvclxuICAgKiBge1widHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIm15X2Z1bmN0aW9uXCJ9fWAgZm9yY2VzIHRoZSBtb2RlbCB0b1xuICAgKiBjYWxsIHRoYXQgdG9vbC5cbiAgICovXG4gIHRvb2xfY2hvaWNlPzogQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSB1c2VkIGJ5IHRoZSBhc3Npc3RhbnQncyB0b29scy4gVGhlIHJlc291cmNlcyBhcmVcbiAgICogc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbCByZXF1aXJlc1xuICAgKiBhIGxpc3Qgb2YgZmlsZSBJRHMsIHdoaWxlIHRoZSBgZmlsZV9zZWFyY2hgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZVxuICAgKiBJRHMuXG4gICAqL1xuICB0b29sX3Jlc291cmNlcz86IFRocmVhZENyZWF0ZUFuZFJ1blN0cmVhbVBhcmFtcy5Ub29sUmVzb3VyY2VzIHwgbnVsbDtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHRvb2xzIHRoZSBhc3Npc3RhbnQgY2FuIHVzZSBmb3IgdGhpcyBydW4uIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9uIGEgcGVyLXJ1biBiYXNpcy5cbiAgICovXG4gIHRvb2xzPzogQXJyYXk8XG4gICAgQXNzaXN0YW50c0FQSS5Db2RlSW50ZXJwcmV0ZXJUb29sIHwgQXNzaXN0YW50c0FQSS5GaWxlU2VhcmNoVG9vbCB8IEFzc2lzdGFudHNBUEkuRnVuY3Rpb25Ub29sXG4gID4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciB0ZW1wZXJhdHVyZSBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGZvciBob3cgYSB0aHJlYWQgd2lsbCBiZSB0cnVuY2F0ZWQgcHJpb3IgdG8gdGhlIHJ1bi4gVXNlIHRoaXMgdG9cbiAgICogY29udHJvbCB0aGUgaW50aWFsIGNvbnRleHQgd2luZG93IG9mIHRoZSBydW4uXG4gICAqL1xuICB0cnVuY2F0aW9uX3N0cmF0ZWd5PzogVGhyZWFkQ3JlYXRlQW5kUnVuU3RyZWFtUGFyYW1zLlRydW5jYXRpb25TdHJhdGVneSB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVGhyZWFkQ3JlYXRlQW5kUnVuU3RyZWFtUGFyYW1zIHtcbiAgLyoqXG4gICAqIElmIG5vIHRocmVhZCBpcyBwcm92aWRlZCwgYW4gZW1wdHkgdGhyZWFkIHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkIHtcbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgW21lc3NhZ2VzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzKSB0b1xuICAgICAqIHN0YXJ0IHRoZSB0aHJlYWQgd2l0aC5cbiAgICAgKi9cbiAgICBtZXNzYWdlcz86IEFycmF5PFRocmVhZC5NZXNzYWdlPjtcblxuICAgIC8qKlxuICAgICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAqIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtIG9mIDUxMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgKi9cbiAgICBtZXRhZGF0YT86IHVua25vd24gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBhc3Npc3RhbnQncyB0b29scyBpbiB0aGlzXG4gICAgICogdGhyZWFkLiBUaGUgcmVzb3VyY2VzIGFyZSBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlXG4gICAgICogYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIGZpbGUgSURzLCB3aGlsZSB0aGUgYGZpbGVfc2VhcmNoYFxuICAgICAqIHRvb2wgcmVxdWlyZXMgYSBsaXN0IG9mIHZlY3RvciBzdG9yZSBJRHMuXG4gICAgICovXG4gICAgdG9vbF9yZXNvdXJjZXM/OiBUaHJlYWQuVG9vbFJlc291cmNlcyB8IG51bGw7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRocmVhZCB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRleHQgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ6IHN0cmluZyB8IEFycmF5PE1lc3NhZ2VzQVBJLk1lc3NhZ2VDb250ZW50UGFydFBhcmFtPjtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcm9sZSBvZiB0aGUgZW50aXR5IHRoYXQgaXMgY3JlYXRpbmcgdGhlIG1lc3NhZ2UuIEFsbG93ZWQgdmFsdWVzIGluY2x1ZGU6XG4gICAgICAgKlxuICAgICAgICogLSBgdXNlcmA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBzZW50IGJ5IGFuIGFjdHVhbCB1c2VyIGFuZCBzaG91bGQgYmUgdXNlZCBpblxuICAgICAgICogICBtb3N0IGNhc2VzIHRvIHJlcHJlc2VudCB1c2VyLWdlbmVyYXRlZCBtZXNzYWdlcy5cbiAgICAgICAqIC0gYGFzc2lzdGFudGA6IEluZGljYXRlcyB0aGUgbWVzc2FnZSBpcyBnZW5lcmF0ZWQgYnkgdGhlIGFzc2lzdGFudC4gVXNlIHRoaXNcbiAgICAgICAqICAgdmFsdWUgdG8gaW5zZXJ0IG1lc3NhZ2VzIGZyb20gdGhlIGFzc2lzdGFudCBpbnRvIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICAgKi9cbiAgICAgIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byB0aGUgbWVzc2FnZSwgYW5kIHRoZSB0b29scyB0aGV5IHNob3VsZCBiZSBhZGRlZCB0by5cbiAgICAgICAqL1xuICAgICAgYXR0YWNobWVudHM/OiBBcnJheTxNZXNzYWdlLkF0dGFjaG1lbnQ+IHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGFuIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gICAgICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgICAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAgICAgKiBjaGFyYWN0ZXJzIGxvbmcuXG4gICAgICAgKi9cbiAgICAgIG1ldGFkYXRhPzogdW5rbm93biB8IG51bGw7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBNZXNzYWdlIHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gYXR0YWNoIHRvIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZV9pZD86IHN0cmluZztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvb2xzIHRvIGFkZCB0aGlzIGZpbGUgdG8uXG4gICAgICAgICAqL1xuICAgICAgICB0b29scz86IEFycmF5PEFzc2lzdGFudHNBUEkuQ29kZUludGVycHJldGVyVG9vbCB8IEFzc2lzdGFudHNBUEkuRmlsZVNlYXJjaFRvb2w+O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYXNzaXN0YW50J3MgdG9vbHMgaW4gdGhpc1xuICAgICAqIHRocmVhZC4gVGhlIHJlc291cmNlcyBhcmUgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgdG9vbC4gRm9yIGV4YW1wbGUsIHRoZVxuICAgICAqIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGBcbiAgICAgKiB0b29sIHJlcXVpcmVzIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgSURzLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgICBjb2RlX2ludGVycHJldGVyPzogVG9vbFJlc291cmNlcy5Db2RlSW50ZXJwcmV0ZXI7XG5cbiAgICAgIGZpbGVfc2VhcmNoPzogVG9vbFJlc291cmNlcy5GaWxlU2VhcmNoO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIENvZGVJbnRlcnByZXRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgW2ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyBtYWRlXG4gICAgICAgICAqIGF2YWlsYWJsZSB0byB0aGUgYGNvZGVfaW50ZXJwcmV0ZXJgIHRvb2wuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMjAgZmlsZXNcbiAgICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZV9pZHM/OiBBcnJheTxzdHJpbmc+O1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEZpbGVTZWFyY2gge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlXG4gICAgICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAgICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgdGhyZWFkLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvXG4gICAgICAgICAqIHRoZSB0aHJlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB2ZWN0b3Jfc3RvcmVfaWRzPzogQXJyYXk8c3RyaW5nPjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBoZWxwZXIgdG8gY3JlYXRlIGFcbiAgICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAgICogd2l0aCBmaWxlX2lkcyBhbmQgYXR0YWNoIGl0IHRvIHRoaXMgdGhyZWFkLiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yXG4gICAgICAgICAqIHN0b3JlIGF0dGFjaGVkIHRvIHRoZSB0aHJlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB2ZWN0b3Jfc3RvcmVzPzogQXJyYXk8RmlsZVNlYXJjaC5WZWN0b3JTdG9yZT47XG4gICAgICB9XG5cbiAgICAgIGV4cG9ydCBuYW1lc3BhY2UgRmlsZVNlYXJjaCB7XG4gICAgICAgIGV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmUge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgbGlzdCBvZiBbZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSURzIHRvXG4gICAgICAgICAgICogYWRkIHRvIHRoZSB2ZWN0b3Igc3RvcmUuIFRoZXJlIGNhbiBiZSBhIG1heGltdW0gb2YgMTAwMDAgZmlsZXMgaW4gYSB2ZWN0b3JcbiAgICAgICAgICAgKiBzdG9yZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBTZXQgb2YgMTYga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdmVjdG9yIHN0b3JlLiBUaGlzIGNhbiBiZVxuICAgICAgICAgICAqIHVzZWZ1bCBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2ZWN0b3Igc3RvcmUgaW4gYSBzdHJ1Y3R1cmVkXG4gICAgICAgICAgICogZm9ybWF0LiBLZXlzIGNhbiBiZSBhIG1heGltdW0gb2YgNjQgY2hhcmFjdGVycyBsb25nIGFuZCB2YWx1ZXMgY2FuIGJlIGEgbWF4aXVtXG4gICAgICAgICAgICogb2YgNTEyIGNoYXJhY3RlcnMgbG9uZy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBtZXRhZGF0YT86IHVua25vd247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBzZXQgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIGFzc2lzdGFudCdzIHRvb2xzLiBUaGUgcmVzb3VyY2VzIGFyZVxuICAgKiBzcGVjaWZpYyB0byB0aGUgdHlwZSBvZiB0b29sLiBGb3IgZXhhbXBsZSwgdGhlIGBjb2RlX2ludGVycHJldGVyYCB0b29sIHJlcXVpcmVzXG4gICAqIGEgbGlzdCBvZiBmaWxlIElEcywgd2hpbGUgdGhlIGBmaWxlX3NlYXJjaGAgdG9vbCByZXF1aXJlcyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlXG4gICAqIElEcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbFJlc291cmNlcyB7XG4gICAgY29kZV9pbnRlcnByZXRlcj86IFRvb2xSZXNvdXJjZXMuQ29kZUludGVycHJldGVyO1xuXG4gICAgZmlsZV9zZWFyY2g/OiBUb29sUmVzb3VyY2VzLkZpbGVTZWFyY2g7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRvb2xSZXNvdXJjZXMge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQ29kZUludGVycHJldGVyIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBsaXN0IG9mIFtmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgbWFkZVxuICAgICAgICogYXZhaWxhYmxlIHRvIHRoZSBgY29kZV9pbnRlcnByZXRlcmAgdG9vbC4gVGhlcmUgY2FuIGJlIGEgbWF4aW11bSBvZiAyMCBmaWxlc1xuICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sLlxuICAgICAgICovXG4gICAgICBmaWxlX2lkcz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBGaWxlU2VhcmNoIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIElEIG9mIHRoZVxuICAgICAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdClcbiAgICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgYXNzaXN0YW50LiBUaGVyZSBjYW4gYmUgYSBtYXhpbXVtIG9mIDEgdmVjdG9yIHN0b3JlIGF0dGFjaGVkIHRvXG4gICAgICAgKiB0aGUgYXNzaXN0YW50LlxuICAgICAgICovXG4gICAgICB2ZWN0b3Jfc3RvcmVfaWRzPzogQXJyYXk8c3RyaW5nPjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgZm9yIGhvdyBhIHRocmVhZCB3aWxsIGJlIHRydW5jYXRlZCBwcmlvciB0byB0aGUgcnVuLiBVc2UgdGhpcyB0b1xuICAgKiBjb250cm9sIHRoZSBpbnRpYWwgY29udGV4dCB3aW5kb3cgb2YgdGhlIHJ1bi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVHJ1bmNhdGlvblN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJ1bmNhdGlvbiBzdHJhdGVneSB0byB1c2UgZm9yIHRoZSB0aHJlYWQuIFRoZSBkZWZhdWx0IGlzIGBhdXRvYC4gSWYgc2V0IHRvXG4gICAgICogYGxhc3RfbWVzc2FnZXNgLCB0aGUgdGhyZWFkIHdpbGwgYmUgdHJ1bmNhdGVkIHRvIHRoZSBuIG1vc3QgcmVjZW50IG1lc3NhZ2VzIGluXG4gICAgICogdGhlIHRocmVhZC4gV2hlbiBzZXQgdG8gYGF1dG9gLCBtZXNzYWdlcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSB0aHJlYWQgd2lsbCBiZVxuICAgICAqIGRyb3BwZWQgdG8gZml0IHRoZSBjb250ZXh0IGxlbmd0aCBvZiB0aGUgbW9kZWwsIGBtYXhfcHJvbXB0X3Rva2Vuc2AuXG4gICAgICovXG4gICAgdHlwZTogJ2F1dG8nIHwgJ2xhc3RfbWVzc2FnZXMnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtb3N0IHJlY2VudCBtZXNzYWdlcyBmcm9tIHRoZSB0aHJlYWQgd2hlbiBjb25zdHJ1Y3RpbmcgdGhlIGNvbnRleHRcbiAgICAgKiBmb3IgdGhlIHJ1bi5cbiAgICAgKi9cbiAgICBsYXN0X21lc3NhZ2VzPzogbnVtYmVyIHwgbnVsbDtcbiAgfVxufVxuXG5UaHJlYWRzLlJ1bnMgPSBSdW5zO1xuVGhyZWFkcy5SdW5zUGFnZSA9IFJ1bnNQYWdlO1xuVGhyZWFkcy5NZXNzYWdlcyA9IE1lc3NhZ2VzO1xuVGhyZWFkcy5NZXNzYWdlc1BhZ2UgPSBNZXNzYWdlc1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBUaHJlYWRzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIEFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uIGFzIEFzc2lzdGFudFJlc3BvbnNlRm9ybWF0T3B0aW9uLFxuICAgIHR5cGUgQXNzaXN0YW50VG9vbENob2ljZSBhcyBBc3Npc3RhbnRUb29sQ2hvaWNlLFxuICAgIHR5cGUgQXNzaXN0YW50VG9vbENob2ljZUZ1bmN0aW9uIGFzIEFzc2lzdGFudFRvb2xDaG9pY2VGdW5jdGlvbixcbiAgICB0eXBlIEFzc2lzdGFudFRvb2xDaG9pY2VPcHRpb24gYXMgQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbixcbiAgICB0eXBlIFRocmVhZCBhcyBUaHJlYWQsXG4gICAgdHlwZSBUaHJlYWREZWxldGVkIGFzIFRocmVhZERlbGV0ZWQsXG4gICAgdHlwZSBUaHJlYWRDcmVhdGVQYXJhbXMgYXMgVGhyZWFkQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgVGhyZWFkVXBkYXRlUGFyYW1zIGFzIFRocmVhZFVwZGF0ZVBhcmFtcyxcbiAgICB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtcyBhcyBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXMsXG4gICAgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNOb25TdHJlYW1pbmcgYXMgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zU3RyZWFtaW5nIGFzIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc1N0cmVhbWluZyxcbiAgICB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blBvbGxQYXJhbXMsXG4gICAgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5TdHJlYW1QYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHtcbiAgICBSdW5zIGFzIFJ1bnMsXG4gICAgdHlwZSBSZXF1aXJlZEFjdGlvbkZ1bmN0aW9uVG9vbENhbGwgYXMgUmVxdWlyZWRBY3Rpb25GdW5jdGlvblRvb2xDYWxsLFxuICAgIHR5cGUgUnVuIGFzIFJ1bixcbiAgICB0eXBlIFJ1blN0YXR1cyBhcyBSdW5TdGF0dXMsXG4gICAgUnVuc1BhZ2UgYXMgUnVuc1BhZ2UsXG4gICAgdHlwZSBSdW5DcmVhdGVQYXJhbXMgYXMgUnVuQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgUnVuQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGFzIFJ1bkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIFJ1bkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBhcyBSdW5DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gICAgdHlwZSBSdW5VcGRhdGVQYXJhbXMgYXMgUnVuVXBkYXRlUGFyYW1zLFxuICAgIHR5cGUgUnVuTGlzdFBhcmFtcyBhcyBSdW5MaXN0UGFyYW1zLFxuICAgIHR5cGUgUnVuQ3JlYXRlQW5kUG9sbFBhcmFtcyxcbiAgICB0eXBlIFJ1bkNyZWF0ZUFuZFN0cmVhbVBhcmFtcyxcbiAgICB0eXBlIFJ1blN0cmVhbVBhcmFtcyxcbiAgICB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zIGFzIFJ1blN1Ym1pdFRvb2xPdXRwdXRzUGFyYW1zLFxuICAgIHR5cGUgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNOb25TdHJlYW1pbmcgYXMgUnVuU3VibWl0VG9vbE91dHB1dHNQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbWluZyBhcyBSdW5TdWJtaXRUb29sT3V0cHV0c1BhcmFtc1N0cmVhbWluZyxcbiAgICB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzQW5kUG9sbFBhcmFtcyxcbiAgICB0eXBlIFJ1blN1Ym1pdFRvb2xPdXRwdXRzU3RyZWFtUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgTWVzc2FnZXMgYXMgTWVzc2FnZXMsXG4gICAgdHlwZSBBbm5vdGF0aW9uIGFzIEFubm90YXRpb24sXG4gICAgdHlwZSBBbm5vdGF0aW9uRGVsdGEgYXMgQW5ub3RhdGlvbkRlbHRhLFxuICAgIHR5cGUgRmlsZUNpdGF0aW9uQW5ub3RhdGlvbiBhcyBGaWxlQ2l0YXRpb25Bbm5vdGF0aW9uLFxuICAgIHR5cGUgRmlsZUNpdGF0aW9uRGVsdGFBbm5vdGF0aW9uIGFzIEZpbGVDaXRhdGlvbkRlbHRhQW5ub3RhdGlvbixcbiAgICB0eXBlIEZpbGVQYXRoQW5ub3RhdGlvbiBhcyBGaWxlUGF0aEFubm90YXRpb24sXG4gICAgdHlwZSBGaWxlUGF0aERlbHRhQW5ub3RhdGlvbiBhcyBGaWxlUGF0aERlbHRhQW5ub3RhdGlvbixcbiAgICB0eXBlIEltYWdlRmlsZSBhcyBJbWFnZUZpbGUsXG4gICAgdHlwZSBJbWFnZUZpbGVDb250ZW50QmxvY2sgYXMgSW1hZ2VGaWxlQ29udGVudEJsb2NrLFxuICAgIHR5cGUgSW1hZ2VGaWxlRGVsdGEgYXMgSW1hZ2VGaWxlRGVsdGEsXG4gICAgdHlwZSBJbWFnZUZpbGVEZWx0YUJsb2NrIGFzIEltYWdlRmlsZURlbHRhQmxvY2ssXG4gICAgdHlwZSBJbWFnZVVSTCBhcyBJbWFnZVVSTCxcbiAgICB0eXBlIEltYWdlVVJMQ29udGVudEJsb2NrIGFzIEltYWdlVVJMQ29udGVudEJsb2NrLFxuICAgIHR5cGUgSW1hZ2VVUkxEZWx0YSBhcyBJbWFnZVVSTERlbHRhLFxuICAgIHR5cGUgSW1hZ2VVUkxEZWx0YUJsb2NrIGFzIEltYWdlVVJMRGVsdGFCbG9jayxcbiAgICB0eXBlIE1lc3NhZ2VzQVBJTWVzc2FnZSBhcyBNZXNzYWdlLFxuICAgIHR5cGUgTWVzc2FnZUNvbnRlbnQgYXMgTWVzc2FnZUNvbnRlbnQsXG4gICAgdHlwZSBNZXNzYWdlQ29udGVudERlbHRhIGFzIE1lc3NhZ2VDb250ZW50RGVsdGEsXG4gICAgdHlwZSBNZXNzYWdlQ29udGVudFBhcnRQYXJhbSBhcyBNZXNzYWdlQ29udGVudFBhcnRQYXJhbSxcbiAgICB0eXBlIE1lc3NhZ2VEZWxldGVkIGFzIE1lc3NhZ2VEZWxldGVkLFxuICAgIHR5cGUgTWVzc2FnZURlbHRhIGFzIE1lc3NhZ2VEZWx0YSxcbiAgICB0eXBlIE1lc3NhZ2VEZWx0YUV2ZW50IGFzIE1lc3NhZ2VEZWx0YUV2ZW50LFxuICAgIHR5cGUgUmVmdXNhbENvbnRlbnRCbG9jayBhcyBSZWZ1c2FsQ29udGVudEJsb2NrLFxuICAgIHR5cGUgUmVmdXNhbERlbHRhQmxvY2sgYXMgUmVmdXNhbERlbHRhQmxvY2ssXG4gICAgdHlwZSBUZXh0IGFzIFRleHQsXG4gICAgdHlwZSBUZXh0Q29udGVudEJsb2NrIGFzIFRleHRDb250ZW50QmxvY2ssXG4gICAgdHlwZSBUZXh0Q29udGVudEJsb2NrUGFyYW0gYXMgVGV4dENvbnRlbnRCbG9ja1BhcmFtLFxuICAgIHR5cGUgVGV4dERlbHRhIGFzIFRleHREZWx0YSxcbiAgICB0eXBlIFRleHREZWx0YUJsb2NrIGFzIFRleHREZWx0YUJsb2NrLFxuICAgIE1lc3NhZ2VzUGFnZSBhcyBNZXNzYWdlc1BhZ2UsXG4gICAgdHlwZSBNZXNzYWdlQ3JlYXRlUGFyYW1zIGFzIE1lc3NhZ2VDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBNZXNzYWdlVXBkYXRlUGFyYW1zIGFzIE1lc3NhZ2VVcGRhdGVQYXJhbXMsXG4gICAgdHlwZSBNZXNzYWdlTGlzdFBhcmFtcyBhcyBNZXNzYWdlTGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICIvKipcbiAqIExpa2UgYFByb21pc2UuYWxsU2V0dGxlZCgpYCBidXQgdGhyb3dzIGFuIGVycm9yIGlmIGFueSBwcm9taXNlcyBhcmUgcmVqZWN0ZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBhbGxTZXR0bGVkV2l0aFRocm93ID0gYXN5bmMgPFI+KHByb21pc2VzOiBQcm9taXNlPFI+W10pOiBQcm9taXNlPFJbXT4gPT4ge1xuICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHByb21pc2VzKTtcbiAgY29uc3QgcmVqZWN0ZWQgPSByZXN1bHRzLmZpbHRlcigocmVzdWx0KTogcmVzdWx0IGlzIFByb21pc2VSZWplY3RlZFJlc3VsdCA9PiByZXN1bHQuc3RhdHVzID09PSAncmVqZWN0ZWQnKTtcbiAgaWYgKHJlamVjdGVkLmxlbmd0aCkge1xuICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlamVjdGVkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKHJlc3VsdC5yZWFzb24pO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihgJHtyZWplY3RlZC5sZW5ndGh9IHByb21pc2UocykgZmFpbGVkIC0gc2VlIHRoZSBhYm92ZSBlcnJvcnNgKTtcbiAgfVxuXG4gIC8vIE5vdGU6IFRTIHdhcyBjb21wbGFpbmluZyBhYm91dCB1c2luZyBgLmZpbHRlcigpLm1hcCgpYCBoZXJlIGZvciBzb21lIHJlYXNvblxuICBjb25zdCB2YWx1ZXM6IFJbXSA9IFtdO1xuICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgICB2YWx1ZXMucHVzaChyZXN1bHQudmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufTtcbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IHNsZWVwLCBVcGxvYWRhYmxlLCBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0ICogYXMgVmVjdG9yU3RvcmVzQVBJIGZyb20gJy4vdmVjdG9yLXN0b3Jlcyc7XG5pbXBvcnQgeyBDdXJzb3JQYWdlLCB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9wYWdpbmF0aW9uJztcblxuZXhwb3J0IGNsYXNzIEZpbGVzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlIGEgdmVjdG9yIHN0b3JlIGZpbGUgYnkgYXR0YWNoaW5nIGFcbiAgICogW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIHRvIGFcbiAgICogW3ZlY3RvciBzdG9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS92ZWN0b3Itc3RvcmVzL29iamVjdCkuXG4gICAqL1xuICBjcmVhdGUoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGJvZHk6IEZpbGVDcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGU+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH0vZmlsZXNgLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgdmVjdG9yIHN0b3JlIGZpbGUuXG4gICAqL1xuICByZXRyaWV2ZShcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgZmlsZUlkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGU+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlcy8ke2ZpbGVJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmUgZmlsZXMuXG4gICAqL1xuICBsaXN0KFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBxdWVyeT86IEZpbGVMaXN0UGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFZlY3RvclN0b3JlRmlsZXNQYWdlLCBWZWN0b3JTdG9yZUZpbGU+O1xuICBsaXN0KFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVzUGFnZSwgVmVjdG9yU3RvcmVGaWxlPjtcbiAgbGlzdChcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgcXVlcnk6IEZpbGVMaXN0UGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFZlY3RvclN0b3JlRmlsZXNQYWdlLCBWZWN0b3JTdG9yZUZpbGU+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3QodmVjdG9yU3RvcmVJZCwge30sIHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9L2ZpbGVzYCwgVmVjdG9yU3RvcmVGaWxlc1BhZ2UsIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgdmVjdG9yIHN0b3JlIGZpbGUuIFRoaXMgd2lsbCByZW1vdmUgdGhlIGZpbGUgZnJvbSB0aGUgdmVjdG9yIHN0b3JlIGJ1dFxuICAgKiB0aGUgZmlsZSBpdHNlbGYgd2lsbCBub3QgYmUgZGVsZXRlZC4gVG8gZGVsZXRlIHRoZSBmaWxlLCB1c2UgdGhlXG4gICAqIFtkZWxldGUgZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9kZWxldGUpXG4gICAqIGVuZHBvaW50LlxuICAgKi9cbiAgZGVsKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBmaWxlSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFZlY3RvclN0b3JlRmlsZURlbGV0ZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlcy8ke2ZpbGVJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYSBmaWxlIHRvIHRoZSBnaXZlbiB2ZWN0b3Igc3RvcmUgYW5kIHdhaXQgZm9yIGl0IHRvIGJlIHByb2Nlc3NlZC5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZUFuZFBvbGwoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGJvZHk6IEZpbGVDcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMgJiB7IHBvbGxJbnRlcnZhbE1zPzogbnVtYmVyIH0sXG4gICk6IFByb21pc2U8VmVjdG9yU3RvcmVGaWxlPiB7XG4gICAgY29uc3QgZmlsZSA9IGF3YWl0IHRoaXMuY3JlYXRlKHZlY3RvclN0b3JlSWQsIGJvZHksIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnBvbGwodmVjdG9yU3RvcmVJZCwgZmlsZS5pZCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogV2FpdCBmb3IgdGhlIHZlY3RvciBzdG9yZSBmaWxlIHRvIGZpbmlzaCBwcm9jZXNzaW5nLlxuICAgKlxuICAgKiBOb3RlOiB0aGlzIHdpbGwgcmV0dXJuIGV2ZW4gaWYgdGhlIGZpbGUgZmFpbGVkIHRvIHByb2Nlc3MsIHlvdSBuZWVkIHRvIGNoZWNrXG4gICAqIGZpbGUubGFzdF9lcnJvciBhbmQgZmlsZS5zdGF0dXMgdG8gaGFuZGxlIHRoZXNlIGNhc2VzXG4gICAqL1xuICBhc3luYyBwb2xsKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBmaWxlSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyAmIHsgcG9sbEludGVydmFsTXM/OiBudW1iZXIgfSxcbiAgKTogUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGU+IHtcbiAgICBjb25zdCBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0geyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtUG9sbC1IZWxwZXInOiAndHJ1ZScgfTtcbiAgICBpZiAob3B0aW9ucz8ucG9sbEludGVydmFsTXMpIHtcbiAgICAgIGhlYWRlcnNbJ1gtU3RhaW5sZXNzLUN1c3RvbS1Qb2xsLUludGVydmFsJ10gPSBvcHRpb25zLnBvbGxJbnRlcnZhbE1zLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBmaWxlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJldHJpZXZlKHZlY3RvclN0b3JlSWQsIGZpbGVJZCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgfSkud2l0aFJlc3BvbnNlKCk7XG5cbiAgICAgIGNvbnN0IGZpbGUgPSBmaWxlUmVzcG9uc2UuZGF0YTtcblxuICAgICAgc3dpdGNoIChmaWxlLnN0YXR1cykge1xuICAgICAgICBjYXNlICdpbl9wcm9ncmVzcyc6XG4gICAgICAgICAgbGV0IHNsZWVwSW50ZXJ2YWwgPSA1MDAwO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnM/LnBvbGxJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICBzbGVlcEludGVydmFsID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVySW50ZXJ2YWwgPSBmaWxlUmVzcG9uc2UucmVzcG9uc2UuaGVhZGVycy5nZXQoJ29wZW5haS1wb2xsLWFmdGVyLW1zJyk7XG4gICAgICAgICAgICBpZiAoaGVhZGVySW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgY29uc3QgaGVhZGVySW50ZXJ2YWxNcyA9IHBhcnNlSW50KGhlYWRlckludGVydmFsKTtcbiAgICAgICAgICAgICAgaWYgKCFpc05hTihoZWFkZXJJbnRlcnZhbE1zKSkge1xuICAgICAgICAgICAgICAgIHNsZWVwSW50ZXJ2YWwgPSBoZWFkZXJJbnRlcnZhbE1zO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IHNsZWVwKHNsZWVwSW50ZXJ2YWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGxvYWQgYSBmaWxlIHRvIHRoZSBgZmlsZXNgIEFQSSBhbmQgdGhlbiBhdHRhY2ggaXQgdG8gdGhlIGdpdmVuIHZlY3RvciBzdG9yZS5cbiAgICpcbiAgICogTm90ZSB0aGUgZmlsZSB3aWxsIGJlIGFzeW5jaHJvbm91c2x5IHByb2Nlc3NlZCAoeW91IGNhbiB1c2UgdGhlIGFsdGVybmF0aXZlXG4gICAqIHBvbGxpbmcgaGVscGVyIG1ldGhvZCB0byB3YWl0IGZvciBwcm9jZXNzaW5nIHRvIGNvbXBsZXRlKS5cbiAgICovXG4gIGFzeW5jIHVwbG9hZChcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgZmlsZTogVXBsb2FkYWJsZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGU+IHtcbiAgICBjb25zdCBmaWxlSW5mbyA9IGF3YWl0IHRoaXMuX2NsaWVudC5maWxlcy5jcmVhdGUoeyBmaWxlOiBmaWxlLCBwdXJwb3NlOiAnYXNzaXN0YW50cycgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlKHZlY3RvclN0b3JlSWQsIHsgZmlsZV9pZDogZmlsZUluZm8uaWQgfSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgZmlsZSB0byBhIHZlY3RvciBzdG9yZSBhbmQgcG9sbCB1bnRpbCBwcm9jZXNzaW5nIGlzIGNvbXBsZXRlLlxuICAgKi9cbiAgYXN5bmMgdXBsb2FkQW5kUG9sbChcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgZmlsZTogVXBsb2FkYWJsZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyAmIHsgcG9sbEludGVydmFsTXM/OiBudW1iZXIgfSxcbiAgKTogUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGU+IHtcbiAgICBjb25zdCBmaWxlSW5mbyA9IGF3YWl0IHRoaXMudXBsb2FkKHZlY3RvclN0b3JlSWQsIGZpbGUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnBvbGwodmVjdG9yU3RvcmVJZCwgZmlsZUluZm8uaWQsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBWZWN0b3JTdG9yZUZpbGVzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8VmVjdG9yU3RvcmVGaWxlPiB7fVxuXG4vKipcbiAqIEEgbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byBhIHZlY3RvciBzdG9yZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZUZpbGUge1xuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIsIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGluIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSB2ZWN0b3Igc3RvcmUgZmlsZSB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGxhc3QgZXJyb3IgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdmVjdG9yIHN0b3JlIGZpbGUuIFdpbGwgYmUgYG51bGxgIGlmIHRoZXJlXG4gICAqIGFyZSBubyBlcnJvcnMuXG4gICAqL1xuICBsYXN0X2Vycm9yOiBWZWN0b3JTdG9yZUZpbGUuTGFzdEVycm9yIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYHZlY3Rvcl9zdG9yZS5maWxlYC5cbiAgICovXG4gIG9iamVjdDogJ3ZlY3Rvcl9zdG9yZS5maWxlJztcblxuICAvKipcbiAgICogVGhlIHN0YXR1cyBvZiB0aGUgdmVjdG9yIHN0b3JlIGZpbGUsIHdoaWNoIGNhbiBiZSBlaXRoZXIgYGluX3Byb2dyZXNzYCxcbiAgICogYGNvbXBsZXRlZGAsIGBjYW5jZWxsZWRgLCBvciBgZmFpbGVkYC4gVGhlIHN0YXR1cyBgY29tcGxldGVkYCBpbmRpY2F0ZXMgdGhhdCB0aGVcbiAgICogdmVjdG9yIHN0b3JlIGZpbGUgaXMgcmVhZHkgZm9yIHVzZS5cbiAgICovXG4gIHN0YXR1czogJ2luX3Byb2dyZXNzJyB8ICdjb21wbGV0ZWQnIHwgJ2NhbmNlbGxlZCcgfCAnZmFpbGVkJztcblxuICAvKipcbiAgICogVGhlIHRvdGFsIHZlY3RvciBzdG9yZSB1c2FnZSBpbiBieXRlcy4gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGRpZmZlcmVudCBmcm9tIHRoZVxuICAgKiBvcmlnaW5hbCBmaWxlIHNpemUuXG4gICAqL1xuICB1c2FnZV9ieXRlczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlXG4gICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpXG4gICAqIHRoYXQgdGhlIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBpc1xuICAgKiBhdHRhY2hlZCB0by5cbiAgICovXG4gIHZlY3Rvcl9zdG9yZV9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RyYXRlZ3kgdXNlZCB0byBjaHVuayB0aGUgZmlsZS5cbiAgICovXG4gIGNodW5raW5nX3N0cmF0ZWd5PzogVmVjdG9yU3RvcmVzQVBJLkZpbGVDaHVua2luZ1N0cmF0ZWd5O1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFZlY3RvclN0b3JlRmlsZSB7XG4gIC8qKlxuICAgKiBUaGUgbGFzdCBlcnJvciBhc3NvY2lhdGVkIHdpdGggdGhpcyB2ZWN0b3Igc3RvcmUgZmlsZS4gV2lsbCBiZSBgbnVsbGAgaWYgdGhlcmVcbiAgICogYXJlIG5vIGVycm9ycy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgTGFzdEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBPbmUgb2YgYHNlcnZlcl9lcnJvcmAgb3IgYHJhdGVfbGltaXRfZXhjZWVkZWRgLlxuICAgICAqL1xuICAgIGNvZGU6ICdzZXJ2ZXJfZXJyb3InIHwgJ3Vuc3VwcG9ydGVkX2ZpbGUnIHwgJ2ludmFsaWRfZmlsZSc7XG5cbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvci5cbiAgICAgKi9cbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZUZpbGVEZWxldGVkIHtcbiAgaWQ6IHN0cmluZztcblxuICBkZWxldGVkOiBib29sZWFuO1xuXG4gIG9iamVjdDogJ3ZlY3Rvcl9zdG9yZS5maWxlLmRlbGV0ZWQnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogQSBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgSUQgdGhhdCB0aGVcbiAgICogdmVjdG9yIHN0b3JlIHNob3VsZCB1c2UuIFVzZWZ1bCBmb3IgdG9vbHMgbGlrZSBgZmlsZV9zZWFyY2hgIHRoYXQgY2FuIGFjY2Vzc1xuICAgKiBmaWxlcy5cbiAgICovXG4gIGZpbGVfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGNodW5raW5nIHN0cmF0ZWd5IHVzZWQgdG8gY2h1bmsgdGhlIGZpbGUocykuIElmIG5vdCBzZXQsIHdpbGwgdXNlIHRoZSBgYXV0b2BcbiAgICogc3RyYXRlZ3kuIE9ubHkgYXBwbGljYWJsZSBpZiBgZmlsZV9pZHNgIGlzIG5vbi1lbXB0eS5cbiAgICovXG4gIGNodW5raW5nX3N0cmF0ZWd5PzogVmVjdG9yU3RvcmVzQVBJLkZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUxpc3RQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgY3Vyc29yIGZvciB1c2UgaW4gcGFnaW5hdGlvbi4gYGJlZm9yZWAgaXMgYW4gb2JqZWN0IElEIHRoYXQgZGVmaW5lcyB5b3VyIHBsYWNlXG4gICAqIGluIHRoZSBsaXN0LiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBtYWtlIGEgbGlzdCByZXF1ZXN0IGFuZCByZWNlaXZlIDEwMCBvYmplY3RzLFxuICAgKiBzdGFydGluZyB3aXRoIG9ial9mb28sIHlvdXIgc3Vic2VxdWVudCBjYWxsIGNhbiBpbmNsdWRlIGJlZm9yZT1vYmpfZm9vIGluIG9yZGVyXG4gICAqIHRvIGZldGNoIHRoZSBwcmV2aW91cyBwYWdlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgYmVmb3JlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGaWx0ZXIgYnkgZmlsZSBzdGF0dXMuIE9uZSBvZiBgaW5fcHJvZ3Jlc3NgLCBgY29tcGxldGVkYCwgYGZhaWxlZGAsIGBjYW5jZWxsZWRgLlxuICAgKi9cbiAgZmlsdGVyPzogJ2luX3Byb2dyZXNzJyB8ICdjb21wbGV0ZWQnIHwgJ2ZhaWxlZCcgfCAnY2FuY2VsbGVkJztcblxuICAvKipcbiAgICogU29ydCBvcmRlciBieSB0aGUgYGNyZWF0ZWRfYXRgIHRpbWVzdGFtcCBvZiB0aGUgb2JqZWN0cy4gYGFzY2AgZm9yIGFzY2VuZGluZ1xuICAgKiBvcmRlciBhbmQgYGRlc2NgIGZvciBkZXNjZW5kaW5nIG9yZGVyLlxuICAgKi9cbiAgb3JkZXI/OiAnYXNjJyB8ICdkZXNjJztcbn1cblxuRmlsZXMuVmVjdG9yU3RvcmVGaWxlc1BhZ2UgPSBWZWN0b3JTdG9yZUZpbGVzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEZpbGVzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIFZlY3RvclN0b3JlRmlsZSBhcyBWZWN0b3JTdG9yZUZpbGUsXG4gICAgdHlwZSBWZWN0b3JTdG9yZUZpbGVEZWxldGVkIGFzIFZlY3RvclN0b3JlRmlsZURlbGV0ZWQsXG4gICAgVmVjdG9yU3RvcmVGaWxlc1BhZ2UgYXMgVmVjdG9yU3RvcmVGaWxlc1BhZ2UsXG4gICAgdHlwZSBGaWxlQ3JlYXRlUGFyYW1zIGFzIEZpbGVDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBGaWxlTGlzdFBhcmFtcyBhcyBGaWxlTGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCB7IHNsZWVwIH0gZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgeyBVcGxvYWRhYmxlIH0gZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgeyBhbGxTZXR0bGVkV2l0aFRocm93IH0gZnJvbSAnLi4vLi4vLi4vbGliL1V0aWwnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIEZpbGVzQVBJIGZyb20gJy4vZmlsZXMnO1xuaW1wb3J0IHsgVmVjdG9yU3RvcmVGaWxlc1BhZ2UgfSBmcm9tICcuL2ZpbGVzJztcbmltcG9ydCAqIGFzIFZlY3RvclN0b3Jlc0FQSSBmcm9tICcuL3ZlY3Rvci1zdG9yZXMnO1xuaW1wb3J0IHsgdHlwZSBDdXJzb3JQYWdlUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vcGFnaW5hdGlvbic7XG5cbmV4cG9ydCBjbGFzcyBGaWxlQmF0Y2hlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIHZlY3RvciBzdG9yZSBmaWxlIGJhdGNoLlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBib2R5OiBGaWxlQmF0Y2hDcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVCYXRjaD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlX2JhdGNoZXNgLCB7XG4gICAgICBib2R5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgdmVjdG9yIHN0b3JlIGZpbGUgYmF0Y2guXG4gICAqL1xuICByZXRyaWV2ZShcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgYmF0Y2hJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8VmVjdG9yU3RvcmVGaWxlQmF0Y2g+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlX2JhdGNoZXMvJHtiYXRjaElkfWAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCBhIHZlY3RvciBzdG9yZSBmaWxlIGJhdGNoLiBUaGlzIGF0dGVtcHRzIHRvIGNhbmNlbCB0aGUgcHJvY2Vzc2luZyBvZlxuICAgKiBmaWxlcyBpbiB0aGlzIGJhdGNoIGFzIHNvb24gYXMgcG9zc2libGUuXG4gICAqL1xuICBjYW5jZWwoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGJhdGNoSWQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFZlY3RvclN0b3JlRmlsZUJhdGNoPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9L2ZpbGVfYmF0Y2hlcy8ke2JhdGNoSWR9L2NhbmNlbGAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHZlY3RvciBzdG9yZSBiYXRjaCBhbmQgcG9sbCB1bnRpbCBhbGwgZmlsZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZC5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZUFuZFBvbGwoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGJvZHk6IEZpbGVCYXRjaENyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyAmIHsgcG9sbEludGVydmFsTXM/OiBudW1iZXIgfSxcbiAgKTogUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVCYXRjaD4ge1xuICAgIGNvbnN0IGJhdGNoID0gYXdhaXQgdGhpcy5jcmVhdGUodmVjdG9yU3RvcmVJZCwgYm9keSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucG9sbCh2ZWN0b3JTdG9yZUlkLCBiYXRjaC5pZCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgdmVjdG9yIHN0b3JlIGZpbGVzIGluIGEgYmF0Y2guXG4gICAqL1xuICBsaXN0RmlsZXMoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIGJhdGNoSWQ6IHN0cmluZyxcbiAgICBxdWVyeT86IEZpbGVCYXRjaExpc3RGaWxlc1BhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVzUGFnZSwgRmlsZXNBUEkuVmVjdG9yU3RvcmVGaWxlPjtcbiAgbGlzdEZpbGVzKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBiYXRjaElkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8VmVjdG9yU3RvcmVGaWxlc1BhZ2UsIEZpbGVzQVBJLlZlY3RvclN0b3JlRmlsZT47XG4gIGxpc3RGaWxlcyhcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgYmF0Y2hJZDogc3RyaW5nLFxuICAgIHF1ZXJ5OiBGaWxlQmF0Y2hMaXN0RmlsZXNQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8VmVjdG9yU3RvcmVGaWxlc1BhZ2UsIEZpbGVzQVBJLlZlY3RvclN0b3JlRmlsZT4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdEZpbGVzKHZlY3RvclN0b3JlSWQsIGJhdGNoSWQsIHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdChcbiAgICAgIGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9L2ZpbGVfYmF0Y2hlcy8ke2JhdGNoSWR9L2ZpbGVzYCxcbiAgICAgIFZlY3RvclN0b3JlRmlsZXNQYWdlLFxuICAgICAgeyBxdWVyeSwgLi4ub3B0aW9ucywgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSB9LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogV2FpdCBmb3IgdGhlIGdpdmVuIGZpbGUgYmF0Y2ggdG8gYmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBOb3RlOiB0aGlzIHdpbGwgcmV0dXJuIGV2ZW4gaWYgb25lIG9mIHRoZSBmaWxlcyBmYWlsZWQgdG8gcHJvY2VzcywgeW91IG5lZWQgdG9cbiAgICogY2hlY2sgYmF0Y2guZmlsZV9jb3VudHMuZmFpbGVkX2NvdW50IHRvIGhhbmRsZSB0aGlzIGNhc2UuXG4gICAqL1xuICBhc3luYyBwb2xsKFxuICAgIHZlY3RvclN0b3JlSWQ6IHN0cmluZyxcbiAgICBiYXRjaElkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMgJiB7IHBvbGxJbnRlcnZhbE1zPzogbnVtYmVyIH0sXG4gICk6IFByb21pc2U8VmVjdG9yU3RvcmVGaWxlQmF0Y2g+IHtcbiAgICBjb25zdCBoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0geyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtUG9sbC1IZWxwZXInOiAndHJ1ZScgfTtcbiAgICBpZiAob3B0aW9ucz8ucG9sbEludGVydmFsTXMpIHtcbiAgICAgIGhlYWRlcnNbJ1gtU3RhaW5sZXNzLUN1c3RvbS1Qb2xsLUludGVydmFsJ10gPSBvcHRpb25zLnBvbGxJbnRlcnZhbE1zLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZGF0YTogYmF0Y2gsIHJlc3BvbnNlIH0gPSBhd2FpdCB0aGlzLnJldHJpZXZlKHZlY3RvclN0b3JlSWQsIGJhdGNoSWQsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgIH0pLndpdGhSZXNwb25zZSgpO1xuXG4gICAgICBzd2l0Y2ggKGJhdGNoLnN0YXR1cykge1xuICAgICAgICBjYXNlICdpbl9wcm9ncmVzcyc6XG4gICAgICAgICAgbGV0IHNsZWVwSW50ZXJ2YWwgPSA1MDAwO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnM/LnBvbGxJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICBzbGVlcEludGVydmFsID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVySW50ZXJ2YWwgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnb3BlbmFpLXBvbGwtYWZ0ZXItbXMnKTtcbiAgICAgICAgICAgIGlmIChoZWFkZXJJbnRlcnZhbCkge1xuICAgICAgICAgICAgICBjb25zdCBoZWFkZXJJbnRlcnZhbE1zID0gcGFyc2VJbnQoaGVhZGVySW50ZXJ2YWwpO1xuICAgICAgICAgICAgICBpZiAoIWlzTmFOKGhlYWRlckludGVydmFsTXMpKSB7XG4gICAgICAgICAgICAgICAgc2xlZXBJbnRlcnZhbCA9IGhlYWRlckludGVydmFsTXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgc2xlZXAoc2xlZXBJbnRlcnZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgIGNhc2UgJ2NhbmNlbGxlZCc6XG4gICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgICAgcmV0dXJuIGJhdGNoO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGxvYWRzIHRoZSBnaXZlbiBmaWxlcyBjb25jdXJyZW50bHkgYW5kIHRoZW4gY3JlYXRlcyBhIHZlY3RvciBzdG9yZSBmaWxlIGJhdGNoLlxuICAgKlxuICAgKiBUaGUgY29uY3VycmVuY3kgbGltaXQgaXMgY29uZmlndXJhYmxlIHVzaW5nIHRoZSBgbWF4Q29uY3VycmVuY3lgIHBhcmFtZXRlci5cbiAgICovXG4gIGFzeW5jIHVwbG9hZEFuZFBvbGwoXG4gICAgdmVjdG9yU3RvcmVJZDogc3RyaW5nLFxuICAgIHsgZmlsZXMsIGZpbGVJZHMgPSBbXSB9OiB7IGZpbGVzOiBVcGxvYWRhYmxlW107IGZpbGVJZHM/OiBzdHJpbmdbXSB9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zICYgeyBwb2xsSW50ZXJ2YWxNcz86IG51bWJlcjsgbWF4Q29uY3VycmVuY3k/OiBudW1iZXIgfSxcbiAgKTogUHJvbWlzZTxWZWN0b3JTdG9yZUZpbGVCYXRjaD4ge1xuICAgIGlmIChmaWxlcyA9PSBudWxsIHx8IGZpbGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBObyBcXGBmaWxlc1xcYCBwcm92aWRlZCB0byBwcm9jZXNzLiBJZiB5b3UndmUgYWxyZWFkeSB1cGxvYWRlZCBmaWxlcyB5b3Ugc2hvdWxkIHVzZSBcXGAuY3JlYXRlQW5kUG9sbCgpXFxgIGluc3RlYWRgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25maWd1cmVkQ29uY3VycmVuY3kgPSBvcHRpb25zPy5tYXhDb25jdXJyZW5jeSA/PyA1O1xuXG4gICAgLy8gV2UgY2FwIHRoZSBudW1iZXIgb2Ygd29ya2VycyBhdCB0aGUgbnVtYmVyIG9mIGZpbGVzIChzbyB3ZSBkb24ndCBzdGFydCBhbnkgdW5uZWNlc3Nhcnkgd29ya2VycylcbiAgICBjb25zdCBjb25jdXJyZW5jeUxpbWl0ID0gTWF0aC5taW4oY29uZmlndXJlZENvbmN1cnJlbmN5LCBmaWxlcy5sZW5ndGgpO1xuXG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xuICAgIGNvbnN0IGZpbGVJdGVyYXRvciA9IGZpbGVzLnZhbHVlcygpO1xuICAgIGNvbnN0IGFsbEZpbGVJZHM6IHN0cmluZ1tdID0gWy4uLmZpbGVJZHNdO1xuXG4gICAgLy8gVGhpcyBjb2RlIGlzIGJhc2VkIG9uIHRoaXMgZGVzaWduLiBUaGUgbGlicmFyaWVzIGRvbid0IGFjY29tbW9kYXRlIG91ciBlbnZpcm9ubWVudCBsaW1pdHMuXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDA2Mzk0MzIvd2hhdC1pcy10aGUtYmVzdC13YXktdG8tbGltaXQtY29uY3VycmVuY3ktd2hlbi11c2luZy1lczZzLXByb21pc2UtYWxsXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0ZpbGVzKGl0ZXJhdG9yOiBJdGVyYWJsZUl0ZXJhdG9yPFVwbG9hZGFibGU+KSB7XG4gICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgIGNvbnN0IGZpbGVPYmogPSBhd2FpdCBjbGllbnQuZmlsZXMuY3JlYXRlKHsgZmlsZTogaXRlbSwgcHVycG9zZTogJ2Fzc2lzdGFudHMnIH0sIG9wdGlvbnMpO1xuICAgICAgICBhbGxGaWxlSWRzLnB1c2goZmlsZU9iai5pZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgd29ya2VycyB0byBwcm9jZXNzIHJlc3VsdHNcbiAgICBjb25zdCB3b3JrZXJzID0gQXJyYXkoY29uY3VycmVuY3lMaW1pdCkuZmlsbChmaWxlSXRlcmF0b3IpLm1hcChwcm9jZXNzRmlsZXMpO1xuXG4gICAgLy8gV2FpdCBmb3IgYWxsIHByb2Nlc3NpbmcgdG8gY29tcGxldGUuXG4gICAgYXdhaXQgYWxsU2V0dGxlZFdpdGhUaHJvdyh3b3JrZXJzKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZUFuZFBvbGwodmVjdG9yU3RvcmVJZCwge1xuICAgICAgZmlsZV9pZHM6IGFsbEZpbGVJZHMsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGJhdGNoIG9mIGZpbGVzIGF0dGFjaGVkIHRvIGEgdmVjdG9yIHN0b3JlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlRmlsZUJhdGNoIHtcbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgdmVjdG9yIHN0b3JlIGZpbGVzIGJhdGNoIHdhc1xuICAgKiBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIGZpbGVfY291bnRzOiBWZWN0b3JTdG9yZUZpbGVCYXRjaC5GaWxlQ291bnRzO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgdmVjdG9yX3N0b3JlLmZpbGVfYmF0Y2hgLlxuICAgKi9cbiAgb2JqZWN0OiAndmVjdG9yX3N0b3JlLmZpbGVzX2JhdGNoJztcblxuICAvKipcbiAgICogVGhlIHN0YXR1cyBvZiB0aGUgdmVjdG9yIHN0b3JlIGZpbGVzIGJhdGNoLCB3aGljaCBjYW4gYmUgZWl0aGVyIGBpbl9wcm9ncmVzc2AsXG4gICAqIGBjb21wbGV0ZWRgLCBgY2FuY2VsbGVkYCBvciBgZmFpbGVkYC5cbiAgICovXG4gIHN0YXR1czogJ2luX3Byb2dyZXNzJyB8ICdjb21wbGV0ZWQnIHwgJ2NhbmNlbGxlZCcgfCAnZmFpbGVkJztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZVxuICAgKiBbdmVjdG9yIHN0b3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3ZlY3Rvci1zdG9yZXMvb2JqZWN0KVxuICAgKiB0aGF0IHRoZSBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgaXNcbiAgICogYXR0YWNoZWQgdG8uXG4gICAqL1xuICB2ZWN0b3Jfc3RvcmVfaWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBWZWN0b3JTdG9yZUZpbGVCYXRjaCB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRmlsZUNvdW50cyB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBmaWxlcyB0aGF0IHdoZXJlIGNhbmNlbGxlZC5cbiAgICAgKi9cbiAgICBjYW5jZWxsZWQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZmlsZXMgdGhhdCBoYXZlIGJlZW4gcHJvY2Vzc2VkLlxuICAgICAqL1xuICAgIGNvbXBsZXRlZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBmaWxlcyB0aGF0IGhhdmUgZmFpbGVkIHRvIHByb2Nlc3MuXG4gICAgICovXG4gICAgZmFpbGVkOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGZpbGVzIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQuXG4gICAgICovXG4gICAgaW5fcHJvZ3Jlc3M6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgZmlsZXMuXG4gICAgICovXG4gICAgdG90YWw6IG51bWJlcjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVCYXRjaENyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMpIElEcyB0aGF0XG4gICAqIHRoZSB2ZWN0b3Igc3RvcmUgc2hvdWxkIHVzZS4gVXNlZnVsIGZvciB0b29scyBsaWtlIGBmaWxlX3NlYXJjaGAgdGhhdCBjYW4gYWNjZXNzXG4gICAqIGZpbGVzLlxuICAgKi9cbiAgZmlsZV9pZHM6IEFycmF5PHN0cmluZz47XG5cbiAgLyoqXG4gICAqIFRoZSBjaHVua2luZyBzdHJhdGVneSB1c2VkIHRvIGNodW5rIHRoZSBmaWxlKHMpLiBJZiBub3Qgc2V0LCB3aWxsIHVzZSB0aGUgYGF1dG9gXG4gICAqIHN0cmF0ZWd5LiBPbmx5IGFwcGxpY2FibGUgaWYgYGZpbGVfaWRzYCBpcyBub24tZW1wdHkuXG4gICAqL1xuICBjaHVua2luZ19zdHJhdGVneT86IFZlY3RvclN0b3Jlc0FQSS5GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVCYXRjaExpc3RGaWxlc1BhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge1xuICAvKipcbiAgICogQSBjdXJzb3IgZm9yIHVzZSBpbiBwYWdpbmF0aW9uLiBgYmVmb3JlYCBpcyBhbiBvYmplY3QgSUQgdGhhdCBkZWZpbmVzIHlvdXIgcGxhY2VcbiAgICogaW4gdGhlIGxpc3QuIEZvciBpbnN0YW5jZSwgaWYgeW91IG1ha2UgYSBsaXN0IHJlcXVlc3QgYW5kIHJlY2VpdmUgMTAwIG9iamVjdHMsXG4gICAqIHN0YXJ0aW5nIHdpdGggb2JqX2ZvbywgeW91ciBzdWJzZXF1ZW50IGNhbGwgY2FuIGluY2x1ZGUgYmVmb3JlPW9ial9mb28gaW4gb3JkZXJcbiAgICogdG8gZmV0Y2ggdGhlIHByZXZpb3VzIHBhZ2Ugb2YgdGhlIGxpc3QuXG4gICAqL1xuICBiZWZvcmU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZpbHRlciBieSBmaWxlIHN0YXR1cy4gT25lIG9mIGBpbl9wcm9ncmVzc2AsIGBjb21wbGV0ZWRgLCBgZmFpbGVkYCwgYGNhbmNlbGxlZGAuXG4gICAqL1xuICBmaWx0ZXI/OiAnaW5fcHJvZ3Jlc3MnIHwgJ2NvbXBsZXRlZCcgfCAnZmFpbGVkJyB8ICdjYW5jZWxsZWQnO1xuXG4gIC8qKlxuICAgKiBTb3J0IG9yZGVyIGJ5IHRoZSBgY3JlYXRlZF9hdGAgdGltZXN0YW1wIG9mIHRoZSBvYmplY3RzLiBgYXNjYCBmb3IgYXNjZW5kaW5nXG4gICAqIG9yZGVyIGFuZCBgZGVzY2AgZm9yIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAqL1xuICBvcmRlcj86ICdhc2MnIHwgJ2Rlc2MnO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgRmlsZUJhdGNoZXMge1xuICBleHBvcnQge1xuICAgIHR5cGUgVmVjdG9yU3RvcmVGaWxlQmF0Y2ggYXMgVmVjdG9yU3RvcmVGaWxlQmF0Y2gsXG4gICAgdHlwZSBGaWxlQmF0Y2hDcmVhdGVQYXJhbXMgYXMgRmlsZUJhdGNoQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgRmlsZUJhdGNoTGlzdEZpbGVzUGFyYW1zIGFzIEZpbGVCYXRjaExpc3RGaWxlc1BhcmFtcyxcbiAgfTtcbn1cblxuZXhwb3J0IHsgVmVjdG9yU3RvcmVGaWxlc1BhZ2UgfTtcbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBGaWxlQmF0Y2hlc0FQSSBmcm9tICcuL2ZpbGUtYmF0Y2hlcyc7XG5pbXBvcnQge1xuICBGaWxlQmF0Y2hDcmVhdGVQYXJhbXMsXG4gIEZpbGVCYXRjaExpc3RGaWxlc1BhcmFtcyxcbiAgRmlsZUJhdGNoZXMsXG4gIFZlY3RvclN0b3JlRmlsZUJhdGNoLFxufSBmcm9tICcuL2ZpbGUtYmF0Y2hlcyc7XG5pbXBvcnQgKiBhcyBGaWxlc0FQSSBmcm9tICcuL2ZpbGVzJztcbmltcG9ydCB7XG4gIEZpbGVDcmVhdGVQYXJhbXMsXG4gIEZpbGVMaXN0UGFyYW1zLFxuICBGaWxlcyxcbiAgVmVjdG9yU3RvcmVGaWxlLFxuICBWZWN0b3JTdG9yZUZpbGVEZWxldGVkLFxuICBWZWN0b3JTdG9yZUZpbGVzUGFnZSxcbn0gZnJvbSAnLi9maWxlcyc7XG5pbXBvcnQgeyBDdXJzb3JQYWdlLCB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9wYWdpbmF0aW9uJztcblxuZXhwb3J0IGNsYXNzIFZlY3RvclN0b3JlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgZmlsZXM6IEZpbGVzQVBJLkZpbGVzID0gbmV3IEZpbGVzQVBJLkZpbGVzKHRoaXMuX2NsaWVudCk7XG4gIGZpbGVCYXRjaGVzOiBGaWxlQmF0Y2hlc0FQSS5GaWxlQmF0Y2hlcyA9IG5ldyBGaWxlQmF0Y2hlc0FQSS5GaWxlQmF0Y2hlcyh0aGlzLl9jbGllbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICBjcmVhdGUoYm9keTogVmVjdG9yU3RvcmVDcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFZlY3RvclN0b3JlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvdmVjdG9yX3N0b3JlcycsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICByZXRyaWV2ZSh2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFZlY3RvclN0b3JlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZmllcyBhIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIHVwZGF0ZShcbiAgICB2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsXG4gICAgYm9keTogVmVjdG9yU3RvcmVVcGRhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxWZWN0b3JTdG9yZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfWAsIHtcbiAgICAgIGJvZHksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB2ZWN0b3Igc3RvcmVzLlxuICAgKi9cbiAgbGlzdChcbiAgICBxdWVyeT86IFZlY3RvclN0b3JlTGlzdFBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxWZWN0b3JTdG9yZXNQYWdlLCBWZWN0b3JTdG9yZT47XG4gIGxpc3Qob3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPFZlY3RvclN0b3Jlc1BhZ2UsIFZlY3RvclN0b3JlPjtcbiAgbGlzdChcbiAgICBxdWVyeTogVmVjdG9yU3RvcmVMaXN0UGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPFZlY3RvclN0b3Jlc1BhZ2UsIFZlY3RvclN0b3JlPiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0KHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdCgnL3ZlY3Rvcl9zdG9yZXMnLCBWZWN0b3JTdG9yZXNQYWdlLCB7XG4gICAgICBxdWVyeSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIGRlbCh2ZWN0b3JTdG9yZUlkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFZlY3RvclN0b3JlRGVsZXRlZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZGVsZXRlKGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFZlY3RvclN0b3Jlc1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlPFZlY3RvclN0b3JlPiB7fVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHN0cmF0ZWd5LiBUaGlzIHN0cmF0ZWd5IGN1cnJlbnRseSB1c2VzIGEgYG1heF9jaHVua19zaXplX3Rva2Vuc2Agb2ZcbiAqIGA4MDBgIGFuZCBgY2h1bmtfb3ZlcmxhcF90b2tlbnNgIG9mIGA0MDBgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEF1dG9GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtIHtcbiAgLyoqXG4gICAqIEFsd2F5cyBgYXV0b2AuXG4gICAqL1xuICB0eXBlOiAnYXV0byc7XG59XG5cbi8qKlxuICogVGhlIHN0cmF0ZWd5IHVzZWQgdG8gY2h1bmsgdGhlIGZpbGUuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbGVDaHVua2luZ1N0cmF0ZWd5ID0gU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QgfCBPdGhlckZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0O1xuXG4vKipcbiAqIFRoZSBjaHVua2luZyBzdHJhdGVneSB1c2VkIHRvIGNodW5rIHRoZSBmaWxlKHMpLiBJZiBub3Qgc2V0LCB3aWxsIHVzZSB0aGUgYGF1dG9gXG4gKiBzdHJhdGVneS4gT25seSBhcHBsaWNhYmxlIGlmIGBmaWxlX2lkc2AgaXMgbm9uLWVtcHR5LlxuICovXG5leHBvcnQgdHlwZSBGaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtID0gQXV0b0ZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0gfCBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdFBhcmFtO1xuXG4vKipcbiAqIFRoaXMgaXMgcmV0dXJuZWQgd2hlbiB0aGUgY2h1bmtpbmcgc3RyYXRlZ3kgaXMgdW5rbm93bi4gVHlwaWNhbGx5LCB0aGlzIGlzXG4gKiBiZWNhdXNlIHRoZSBmaWxlIHdhcyBpbmRleGVkIGJlZm9yZSB0aGUgYGNodW5raW5nX3N0cmF0ZWd5YCBjb25jZXB0IHdhc1xuICogaW50cm9kdWNlZCBpbiB0aGUgQVBJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE90aGVyRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3Qge1xuICAvKipcbiAgICogQWx3YXlzIGBvdGhlcmAuXG4gICAqL1xuICB0eXBlOiAnb3RoZXInO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5IHtcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgdG9rZW5zIHRoYXQgb3ZlcmxhcCBiZXR3ZWVuIGNodW5rcy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDQwMGAuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgb3ZlcmxhcCBtdXN0IG5vdCBleGNlZWQgaGFsZiBvZiBgbWF4X2NodW5rX3NpemVfdG9rZW5zYC5cbiAgICovXG4gIGNodW5rX292ZXJsYXBfdG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0b2tlbnMgaW4gZWFjaCBjaHVuay4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDgwMGAuIFRoZVxuICAgKiBtaW5pbXVtIHZhbHVlIGlzIGAxMDBgIGFuZCB0aGUgbWF4aW11bSB2YWx1ZSBpcyBgNDA5NmAuXG4gICAqL1xuICBtYXhfY2h1bmtfc2l6ZV90b2tlbnM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdCB7XG4gIHN0YXRpYzogU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3k7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgc3RhdGljYC5cbiAgICovXG4gIHR5cGU6ICdzdGF0aWMnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0UGFyYW0ge1xuICBzdGF0aWM6IFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5O1xuXG4gIC8qKlxuICAgKiBBbHdheXMgYHN0YXRpY2AuXG4gICAqL1xuICB0eXBlOiAnc3RhdGljJztcbn1cblxuLyoqXG4gKiBBIHZlY3RvciBzdG9yZSBpcyBhIGNvbGxlY3Rpb24gb2YgcHJvY2Vzc2VkIGZpbGVzIGNhbiBiZSB1c2VkIGJ5IHRoZVxuICogYGZpbGVfc2VhcmNoYCB0b29sLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlIHtcbiAgLyoqXG4gICAqIFRoZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiBBUEkgZW5kcG9pbnRzLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgdmVjdG9yIHN0b3JlIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIGZpbGVfY291bnRzOiBWZWN0b3JTdG9yZS5GaWxlQ291bnRzO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSB2ZWN0b3Igc3RvcmUgd2FzIGxhc3QgYWN0aXZlLlxuICAgKi9cbiAgbGFzdF9hY3RpdmVfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCBvZiAxNiBrZXktdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogZm9yIHN0b3JpbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IGluIGEgc3RydWN0dXJlZCBmb3JtYXQuIEtleXNcbiAgICogY2FuIGJlIGEgbWF4aW11bSBvZiA2NCBjaGFyYWN0ZXJzIGxvbmcgYW5kIHZhbHVlcyBjYW4gYmUgYSBtYXhpdW0gb2YgNTEyXG4gICAqIGNoYXJhY3RlcnMgbG9uZy5cbiAgICovXG4gIG1ldGFkYXRhOiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgYHZlY3Rvcl9zdG9yZWAuXG4gICAqL1xuICBvYmplY3Q6ICd2ZWN0b3Jfc3RvcmUnO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhdHVzIG9mIHRoZSB2ZWN0b3Igc3RvcmUsIHdoaWNoIGNhbiBiZSBlaXRoZXIgYGV4cGlyZWRgLCBgaW5fcHJvZ3Jlc3NgLCBvclxuICAgKiBgY29tcGxldGVkYC4gQSBzdGF0dXMgb2YgYGNvbXBsZXRlZGAgaW5kaWNhdGVzIHRoYXQgdGhlIHZlY3RvciBzdG9yZSBpcyByZWFkeVxuICAgKiBmb3IgdXNlLlxuICAgKi9cbiAgc3RhdHVzOiAnZXhwaXJlZCcgfCAnaW5fcHJvZ3Jlc3MnIHwgJ2NvbXBsZXRlZCc7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgdXNlZCBieSB0aGUgZmlsZXMgaW4gdGhlIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIHVzYWdlX2J5dGVzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBleHBpcmF0aW9uIHBvbGljeSBmb3IgYSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICBleHBpcmVzX2FmdGVyPzogVmVjdG9yU3RvcmUuRXhwaXJlc0FmdGVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSB2ZWN0b3Igc3RvcmUgd2lsbCBleHBpcmUuXG4gICAqL1xuICBleHBpcmVzX2F0PzogbnVtYmVyIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBWZWN0b3JTdG9yZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRmlsZUNvdW50cyB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBmaWxlcyB0aGF0IHdlcmUgY2FuY2VsbGVkLlxuICAgICAqL1xuICAgIGNhbmNlbGxlZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBmaWxlcyB0aGF0IGhhdmUgYmVlbiBzdWNjZXNzZnVsbHkgcHJvY2Vzc2VkLlxuICAgICAqL1xuICAgIGNvbXBsZXRlZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBmaWxlcyB0aGF0IGhhdmUgZmFpbGVkIHRvIHByb2Nlc3MuXG4gICAgICovXG4gICAgZmFpbGVkOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGZpbGVzIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQuXG4gICAgICovXG4gICAgaW5fcHJvZ3Jlc3M6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgZmlsZXMuXG4gICAgICovXG4gICAgdG90YWw6IG51bWJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZXhwaXJhdGlvbiBwb2xpY3kgZm9yIGEgdmVjdG9yIHN0b3JlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBFeHBpcmVzQWZ0ZXIge1xuICAgIC8qKlxuICAgICAqIEFuY2hvciB0aW1lc3RhbXAgYWZ0ZXIgd2hpY2ggdGhlIGV4cGlyYXRpb24gcG9saWN5IGFwcGxpZXMuIFN1cHBvcnRlZCBhbmNob3JzOlxuICAgICAqIGBsYXN0X2FjdGl2ZV9hdGAuXG4gICAgICovXG4gICAgYW5jaG9yOiAnbGFzdF9hY3RpdmVfYXQnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBkYXlzIGFmdGVyIHRoZSBhbmNob3IgdGltZSB0aGF0IHRoZSB2ZWN0b3Igc3RvcmUgd2lsbCBleHBpcmUuXG4gICAgICovXG4gICAgZGF5czogbnVtYmVyO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yU3RvcmVEZWxldGVkIHtcbiAgaWQ6IHN0cmluZztcblxuICBkZWxldGVkOiBib29sZWFuO1xuXG4gIG9iamVjdDogJ3ZlY3Rvcl9zdG9yZS5kZWxldGVkJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZUNyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgY2h1bmtpbmcgc3RyYXRlZ3kgdXNlZCB0byBjaHVuayB0aGUgZmlsZShzKS4gSWYgbm90IHNldCwgd2lsbCB1c2UgdGhlIGBhdXRvYFxuICAgKiBzdHJhdGVneS4gT25seSBhcHBsaWNhYmxlIGlmIGBmaWxlX2lkc2AgaXMgbm9uLWVtcHR5LlxuICAgKi9cbiAgY2h1bmtpbmdfc3RyYXRlZ3k/OiBGaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtO1xuXG4gIC8qKlxuICAgKiBUaGUgZXhwaXJhdGlvbiBwb2xpY3kgZm9yIGEgdmVjdG9yIHN0b3JlLlxuICAgKi9cbiAgZXhwaXJlc19hZnRlcj86IFZlY3RvclN0b3JlQ3JlYXRlUGFyYW1zLkV4cGlyZXNBZnRlcjtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSBJRHMgdGhhdFxuICAgKiB0aGUgdmVjdG9yIHN0b3JlIHNob3VsZCB1c2UuIFVzZWZ1bCBmb3IgdG9vbHMgbGlrZSBgZmlsZV9zZWFyY2hgIHRoYXQgY2FuIGFjY2Vzc1xuICAgKiBmaWxlcy5cbiAgICovXG4gIGZpbGVfaWRzPzogQXJyYXk8c3RyaW5nPjtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVmVjdG9yU3RvcmVDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIGV4cGlyYXRpb24gcG9saWN5IGZvciBhIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXhwaXJlc0FmdGVyIHtcbiAgICAvKipcbiAgICAgKiBBbmNob3IgdGltZXN0YW1wIGFmdGVyIHdoaWNoIHRoZSBleHBpcmF0aW9uIHBvbGljeSBhcHBsaWVzLiBTdXBwb3J0ZWQgYW5jaG9yczpcbiAgICAgKiBgbGFzdF9hY3RpdmVfYXRgLlxuICAgICAqL1xuICAgIGFuY2hvcjogJ2xhc3RfYWN0aXZlX2F0JztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZGF5cyBhZnRlciB0aGUgYW5jaG9yIHRpbWUgdGhhdCB0aGUgdmVjdG9yIHN0b3JlIHdpbGwgZXhwaXJlLlxuICAgICAqL1xuICAgIGRheXM6IG51bWJlcjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlY3RvclN0b3JlVXBkYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBleHBpcmF0aW9uIHBvbGljeSBmb3IgYSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICBleHBpcmVzX2FmdGVyPzogVmVjdG9yU3RvcmVVcGRhdGVQYXJhbXMuRXhwaXJlc0FmdGVyIHwgbnVsbDtcblxuICAvKipcbiAgICogU2V0IG9mIDE2IGtleS12YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhbiBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiBmb3Igc3RvcmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC4gS2V5c1xuICAgKiBjYW4gYmUgYSBtYXhpbXVtIG9mIDY0IGNoYXJhY3RlcnMgbG9uZyBhbmQgdmFsdWVzIGNhbiBiZSBhIG1heGl1bSBvZiA1MTJcbiAgICogY2hhcmFjdGVycyBsb25nLlxuICAgKi9cbiAgbWV0YWRhdGE/OiB1bmtub3duIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHZlY3RvciBzdG9yZS5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFZlY3RvclN0b3JlVXBkYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBleHBpcmF0aW9uIHBvbGljeSBmb3IgYSB2ZWN0b3Igc3RvcmUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEV4cGlyZXNBZnRlciB7XG4gICAgLyoqXG4gICAgICogQW5jaG9yIHRpbWVzdGFtcCBhZnRlciB3aGljaCB0aGUgZXhwaXJhdGlvbiBwb2xpY3kgYXBwbGllcy4gU3VwcG9ydGVkIGFuY2hvcnM6XG4gICAgICogYGxhc3RfYWN0aXZlX2F0YC5cbiAgICAgKi9cbiAgICBhbmNob3I6ICdsYXN0X2FjdGl2ZV9hdCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRheXMgYWZ0ZXIgdGhlIGFuY2hvciB0aW1lIHRoYXQgdGhlIHZlY3RvciBzdG9yZSB3aWxsIGV4cGlyZS5cbiAgICAgKi9cbiAgICBkYXlzOiBudW1iZXI7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZWN0b3JTdG9yZUxpc3RQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgY3Vyc29yIGZvciB1c2UgaW4gcGFnaW5hdGlvbi4gYGJlZm9yZWAgaXMgYW4gb2JqZWN0IElEIHRoYXQgZGVmaW5lcyB5b3VyIHBsYWNlXG4gICAqIGluIHRoZSBsaXN0LiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBtYWtlIGEgbGlzdCByZXF1ZXN0IGFuZCByZWNlaXZlIDEwMCBvYmplY3RzLFxuICAgKiBzdGFydGluZyB3aXRoIG9ial9mb28sIHlvdXIgc3Vic2VxdWVudCBjYWxsIGNhbiBpbmNsdWRlIGJlZm9yZT1vYmpfZm9vIGluIG9yZGVyXG4gICAqIHRvIGZldGNoIHRoZSBwcmV2aW91cyBwYWdlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgYmVmb3JlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTb3J0IG9yZGVyIGJ5IHRoZSBgY3JlYXRlZF9hdGAgdGltZXN0YW1wIG9mIHRoZSBvYmplY3RzLiBgYXNjYCBmb3IgYXNjZW5kaW5nXG4gICAqIG9yZGVyIGFuZCBgZGVzY2AgZm9yIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAqL1xuICBvcmRlcj86ICdhc2MnIHwgJ2Rlc2MnO1xufVxuXG5WZWN0b3JTdG9yZXMuVmVjdG9yU3RvcmVzUGFnZSA9IFZlY3RvclN0b3Jlc1BhZ2U7XG5WZWN0b3JTdG9yZXMuRmlsZXMgPSBGaWxlcztcblZlY3RvclN0b3Jlcy5WZWN0b3JTdG9yZUZpbGVzUGFnZSA9IFZlY3RvclN0b3JlRmlsZXNQYWdlO1xuVmVjdG9yU3RvcmVzLkZpbGVCYXRjaGVzID0gRmlsZUJhdGNoZXM7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBWZWN0b3JTdG9yZXMge1xuICBleHBvcnQge1xuICAgIHR5cGUgQXV0b0ZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0gYXMgQXV0b0ZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0sXG4gICAgdHlwZSBGaWxlQ2h1bmtpbmdTdHJhdGVneSBhcyBGaWxlQ2h1bmtpbmdTdHJhdGVneSxcbiAgICB0eXBlIEZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0gYXMgRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbSxcbiAgICB0eXBlIE90aGVyRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QgYXMgT3RoZXJGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdCxcbiAgICB0eXBlIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5IGFzIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5LFxuICAgIHR5cGUgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QgYXMgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QsXG4gICAgdHlwZSBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdFBhcmFtIGFzIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0UGFyYW0sXG4gICAgdHlwZSBWZWN0b3JTdG9yZSBhcyBWZWN0b3JTdG9yZSxcbiAgICB0eXBlIFZlY3RvclN0b3JlRGVsZXRlZCBhcyBWZWN0b3JTdG9yZURlbGV0ZWQsXG4gICAgVmVjdG9yU3RvcmVzUGFnZSBhcyBWZWN0b3JTdG9yZXNQYWdlLFxuICAgIHR5cGUgVmVjdG9yU3RvcmVDcmVhdGVQYXJhbXMgYXMgVmVjdG9yU3RvcmVDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBWZWN0b3JTdG9yZVVwZGF0ZVBhcmFtcyBhcyBWZWN0b3JTdG9yZVVwZGF0ZVBhcmFtcyxcbiAgICB0eXBlIFZlY3RvclN0b3JlTGlzdFBhcmFtcyBhcyBWZWN0b3JTdG9yZUxpc3RQYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHtcbiAgICBGaWxlcyBhcyBGaWxlcyxcbiAgICB0eXBlIFZlY3RvclN0b3JlRmlsZSBhcyBWZWN0b3JTdG9yZUZpbGUsXG4gICAgdHlwZSBWZWN0b3JTdG9yZUZpbGVEZWxldGVkIGFzIFZlY3RvclN0b3JlRmlsZURlbGV0ZWQsXG4gICAgVmVjdG9yU3RvcmVGaWxlc1BhZ2UgYXMgVmVjdG9yU3RvcmVGaWxlc1BhZ2UsXG4gICAgdHlwZSBGaWxlQ3JlYXRlUGFyYW1zIGFzIEZpbGVDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBGaWxlTGlzdFBhcmFtcyBhcyBGaWxlTGlzdFBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIEZpbGVCYXRjaGVzIGFzIEZpbGVCYXRjaGVzLFxuICAgIHR5cGUgVmVjdG9yU3RvcmVGaWxlQmF0Y2ggYXMgVmVjdG9yU3RvcmVGaWxlQmF0Y2gsXG4gICAgdHlwZSBGaWxlQmF0Y2hDcmVhdGVQYXJhbXMgYXMgRmlsZUJhdGNoQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgRmlsZUJhdGNoTGlzdEZpbGVzUGFyYW1zIGFzIEZpbGVCYXRjaExpc3RGaWxlc1BhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIEFzc2lzdGFudHNBUEkgZnJvbSAnLi9hc3Npc3RhbnRzJztcbmltcG9ydCAqIGFzIENoYXRBUEkgZnJvbSAnLi9jaGF0L2NoYXQnO1xuaW1wb3J0IHtcbiAgQXNzaXN0YW50LFxuICBBc3Npc3RhbnRDcmVhdGVQYXJhbXMsXG4gIEFzc2lzdGFudERlbGV0ZWQsXG4gIEFzc2lzdGFudExpc3RQYXJhbXMsXG4gIEFzc2lzdGFudFN0cmVhbUV2ZW50LFxuICBBc3Npc3RhbnRUb29sLFxuICBBc3Npc3RhbnRVcGRhdGVQYXJhbXMsXG4gIEFzc2lzdGFudHMsXG4gIEFzc2lzdGFudHNQYWdlLFxuICBDb2RlSW50ZXJwcmV0ZXJUb29sLFxuICBGaWxlU2VhcmNoVG9vbCxcbiAgRnVuY3Rpb25Ub29sLFxuICBNZXNzYWdlU3RyZWFtRXZlbnQsXG4gIFJ1blN0ZXBTdHJlYW1FdmVudCxcbiAgUnVuU3RyZWFtRXZlbnQsXG4gIFRocmVhZFN0cmVhbUV2ZW50LFxufSBmcm9tICcuL2Fzc2lzdGFudHMnO1xuaW1wb3J0ICogYXMgUmVhbHRpbWVBUEkgZnJvbSAnLi9yZWFsdGltZS9yZWFsdGltZSc7XG5pbXBvcnQgeyBSZWFsdGltZSB9IGZyb20gJy4vcmVhbHRpbWUvcmVhbHRpbWUnO1xuaW1wb3J0ICogYXMgVGhyZWFkc0FQSSBmcm9tICcuL3RocmVhZHMvdGhyZWFkcyc7XG5pbXBvcnQge1xuICBBc3Npc3RhbnRSZXNwb25zZUZvcm1hdE9wdGlvbixcbiAgQXNzaXN0YW50VG9vbENob2ljZSxcbiAgQXNzaXN0YW50VG9vbENob2ljZUZ1bmN0aW9uLFxuICBBc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uLFxuICBUaHJlYWQsXG4gIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtcyxcbiAgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zTm9uU3RyZWFtaW5nLFxuICBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNTdHJlYW1pbmcsXG4gIFRocmVhZENyZWF0ZUFuZFJ1blBvbGxQYXJhbXMsXG4gIFRocmVhZENyZWF0ZUFuZFJ1blN0cmVhbVBhcmFtcyxcbiAgVGhyZWFkQ3JlYXRlUGFyYW1zLFxuICBUaHJlYWREZWxldGVkLFxuICBUaHJlYWRVcGRhdGVQYXJhbXMsXG4gIFRocmVhZHMsXG59IGZyb20gJy4vdGhyZWFkcy90aHJlYWRzJztcbmltcG9ydCAqIGFzIFZlY3RvclN0b3Jlc0FQSSBmcm9tICcuL3ZlY3Rvci1zdG9yZXMvdmVjdG9yLXN0b3Jlcyc7XG5pbXBvcnQge1xuICBBdXRvRmlsZUNodW5raW5nU3RyYXRlZ3lQYXJhbSxcbiAgRmlsZUNodW5raW5nU3RyYXRlZ3ksXG4gIEZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0sXG4gIE90aGVyRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QsXG4gIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5LFxuICBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdCxcbiAgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3RQYXJhbSxcbiAgVmVjdG9yU3RvcmUsXG4gIFZlY3RvclN0b3JlQ3JlYXRlUGFyYW1zLFxuICBWZWN0b3JTdG9yZURlbGV0ZWQsXG4gIFZlY3RvclN0b3JlTGlzdFBhcmFtcyxcbiAgVmVjdG9yU3RvcmVVcGRhdGVQYXJhbXMsXG4gIFZlY3RvclN0b3JlcyxcbiAgVmVjdG9yU3RvcmVzUGFnZSxcbn0gZnJvbSAnLi92ZWN0b3Itc3RvcmVzL3ZlY3Rvci1zdG9yZXMnO1xuaW1wb3J0IHsgQ2hhdCB9IGZyb20gJy4vY2hhdC9jaGF0JztcblxuZXhwb3J0IGNsYXNzIEJldGEgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIHJlYWx0aW1lOiBSZWFsdGltZUFQSS5SZWFsdGltZSA9IG5ldyBSZWFsdGltZUFQSS5SZWFsdGltZSh0aGlzLl9jbGllbnQpO1xuICB2ZWN0b3JTdG9yZXM6IFZlY3RvclN0b3Jlc0FQSS5WZWN0b3JTdG9yZXMgPSBuZXcgVmVjdG9yU3RvcmVzQVBJLlZlY3RvclN0b3Jlcyh0aGlzLl9jbGllbnQpO1xuICBjaGF0OiBDaGF0QVBJLkNoYXQgPSBuZXcgQ2hhdEFQSS5DaGF0KHRoaXMuX2NsaWVudCk7XG4gIGFzc2lzdGFudHM6IEFzc2lzdGFudHNBUEkuQXNzaXN0YW50cyA9IG5ldyBBc3Npc3RhbnRzQVBJLkFzc2lzdGFudHModGhpcy5fY2xpZW50KTtcbiAgdGhyZWFkczogVGhyZWFkc0FQSS5UaHJlYWRzID0gbmV3IFRocmVhZHNBUEkuVGhyZWFkcyh0aGlzLl9jbGllbnQpO1xufVxuXG5CZXRhLlJlYWx0aW1lID0gUmVhbHRpbWU7XG5CZXRhLlZlY3RvclN0b3JlcyA9IFZlY3RvclN0b3JlcztcbkJldGEuVmVjdG9yU3RvcmVzUGFnZSA9IFZlY3RvclN0b3Jlc1BhZ2U7XG5CZXRhLkFzc2lzdGFudHMgPSBBc3Npc3RhbnRzO1xuQmV0YS5Bc3Npc3RhbnRzUGFnZSA9IEFzc2lzdGFudHNQYWdlO1xuQmV0YS5UaHJlYWRzID0gVGhyZWFkcztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEJldGEge1xuICBleHBvcnQgeyBSZWFsdGltZSBhcyBSZWFsdGltZSB9O1xuXG4gIGV4cG9ydCB7XG4gICAgVmVjdG9yU3RvcmVzIGFzIFZlY3RvclN0b3JlcyxcbiAgICB0eXBlIEF1dG9GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtIGFzIEF1dG9GaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtLFxuICAgIHR5cGUgRmlsZUNodW5raW5nU3RyYXRlZ3kgYXMgRmlsZUNodW5raW5nU3RyYXRlZ3ksXG4gICAgdHlwZSBGaWxlQ2h1bmtpbmdTdHJhdGVneVBhcmFtIGFzIEZpbGVDaHVua2luZ1N0cmF0ZWd5UGFyYW0sXG4gICAgdHlwZSBPdGhlckZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0IGFzIE90aGVyRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3QsXG4gICAgdHlwZSBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneSBhcyBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneSxcbiAgICB0eXBlIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0IGFzIFN0YXRpY0ZpbGVDaHVua2luZ1N0cmF0ZWd5T2JqZWN0LFxuICAgIHR5cGUgU3RhdGljRmlsZUNodW5raW5nU3RyYXRlZ3lPYmplY3RQYXJhbSBhcyBTdGF0aWNGaWxlQ2h1bmtpbmdTdHJhdGVneU9iamVjdFBhcmFtLFxuICAgIHR5cGUgVmVjdG9yU3RvcmUgYXMgVmVjdG9yU3RvcmUsXG4gICAgdHlwZSBWZWN0b3JTdG9yZURlbGV0ZWQgYXMgVmVjdG9yU3RvcmVEZWxldGVkLFxuICAgIFZlY3RvclN0b3Jlc1BhZ2UgYXMgVmVjdG9yU3RvcmVzUGFnZSxcbiAgICB0eXBlIFZlY3RvclN0b3JlQ3JlYXRlUGFyYW1zIGFzIFZlY3RvclN0b3JlQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgVmVjdG9yU3RvcmVVcGRhdGVQYXJhbXMgYXMgVmVjdG9yU3RvcmVVcGRhdGVQYXJhbXMsXG4gICAgdHlwZSBWZWN0b3JTdG9yZUxpc3RQYXJhbXMgYXMgVmVjdG9yU3RvcmVMaXN0UGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7IENoYXQgfTtcblxuICBleHBvcnQge1xuICAgIEFzc2lzdGFudHMgYXMgQXNzaXN0YW50cyxcbiAgICB0eXBlIEFzc2lzdGFudCBhcyBBc3Npc3RhbnQsXG4gICAgdHlwZSBBc3Npc3RhbnREZWxldGVkIGFzIEFzc2lzdGFudERlbGV0ZWQsXG4gICAgdHlwZSBBc3Npc3RhbnRTdHJlYW1FdmVudCBhcyBBc3Npc3RhbnRTdHJlYW1FdmVudCxcbiAgICB0eXBlIEFzc2lzdGFudFRvb2wgYXMgQXNzaXN0YW50VG9vbCxcbiAgICB0eXBlIENvZGVJbnRlcnByZXRlclRvb2wgYXMgQ29kZUludGVycHJldGVyVG9vbCxcbiAgICB0eXBlIEZpbGVTZWFyY2hUb29sIGFzIEZpbGVTZWFyY2hUb29sLFxuICAgIHR5cGUgRnVuY3Rpb25Ub29sIGFzIEZ1bmN0aW9uVG9vbCxcbiAgICB0eXBlIE1lc3NhZ2VTdHJlYW1FdmVudCBhcyBNZXNzYWdlU3RyZWFtRXZlbnQsXG4gICAgdHlwZSBSdW5TdGVwU3RyZWFtRXZlbnQgYXMgUnVuU3RlcFN0cmVhbUV2ZW50LFxuICAgIHR5cGUgUnVuU3RyZWFtRXZlbnQgYXMgUnVuU3RyZWFtRXZlbnQsXG4gICAgdHlwZSBUaHJlYWRTdHJlYW1FdmVudCBhcyBUaHJlYWRTdHJlYW1FdmVudCxcbiAgICBBc3Npc3RhbnRzUGFnZSBhcyBBc3Npc3RhbnRzUGFnZSxcbiAgICB0eXBlIEFzc2lzdGFudENyZWF0ZVBhcmFtcyBhcyBBc3Npc3RhbnRDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBBc3Npc3RhbnRVcGRhdGVQYXJhbXMgYXMgQXNzaXN0YW50VXBkYXRlUGFyYW1zLFxuICAgIHR5cGUgQXNzaXN0YW50TGlzdFBhcmFtcyBhcyBBc3Npc3RhbnRMaXN0UGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgVGhyZWFkcyBhcyBUaHJlYWRzLFxuICAgIHR5cGUgQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24gYXMgQXNzaXN0YW50UmVzcG9uc2VGb3JtYXRPcHRpb24sXG4gICAgdHlwZSBBc3Npc3RhbnRUb29sQ2hvaWNlIGFzIEFzc2lzdGFudFRvb2xDaG9pY2UsXG4gICAgdHlwZSBBc3Npc3RhbnRUb29sQ2hvaWNlRnVuY3Rpb24gYXMgQXNzaXN0YW50VG9vbENob2ljZUZ1bmN0aW9uLFxuICAgIHR5cGUgQXNzaXN0YW50VG9vbENob2ljZU9wdGlvbiBhcyBBc3Npc3RhbnRUb29sQ2hvaWNlT3B0aW9uLFxuICAgIHR5cGUgVGhyZWFkIGFzIFRocmVhZCxcbiAgICB0eXBlIFRocmVhZERlbGV0ZWQgYXMgVGhyZWFkRGVsZXRlZCxcbiAgICB0eXBlIFRocmVhZENyZWF0ZVBhcmFtcyBhcyBUaHJlYWRDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBUaHJlYWRVcGRhdGVQYXJhbXMgYXMgVGhyZWFkVXBkYXRlUGFyYW1zLFxuICAgIHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zIGFzIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtcyxcbiAgICB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blBhcmFtc05vblN0cmVhbWluZyBhcyBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBUaHJlYWRDcmVhdGVBbmRSdW5QYXJhbXNTdHJlYW1pbmcgYXMgVGhyZWFkQ3JlYXRlQW5kUnVuUGFyYW1zU3RyZWFtaW5nLFxuICAgIHR5cGUgVGhyZWFkQ3JlYXRlQW5kUnVuUG9sbFBhcmFtcyxcbiAgICB0eXBlIFRocmVhZENyZWF0ZUFuZFJ1blN0cmVhbVBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uL3Jlc291cmNlJztcbmltcG9ydCB7IEFQSVByb21pc2UgfSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDb21wbGV0aW9uc0FQSSBmcm9tICcuL2NvbXBsZXRpb25zJztcbmltcG9ydCAqIGFzIENoYXRDb21wbGV0aW9uc0FQSSBmcm9tICcuL2NoYXQvY29tcGxldGlvbnMnO1xuaW1wb3J0IHsgU3RyZWFtIH0gZnJvbSAnLi4vc3RyZWFtaW5nJztcblxuZXhwb3J0IGNsYXNzIENvbXBsZXRpb25zIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbXBsZXRpb24gZm9yIHRoZSBwcm92aWRlZCBwcm9tcHQgYW5kIHBhcmFtZXRlcnMuXG4gICAqL1xuICBjcmVhdGUoYm9keTogQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBBUElQcm9taXNlPENvbXBsZXRpb24+O1xuICBjcmVhdGUoXG4gICAgYm9keTogQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08Q29tcGxldGlvbj4+O1xuICBjcmVhdGUoXG4gICAgYm9keTogQ29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2UsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8U3RyZWFtPENvbXBsZXRpb24+IHwgQ29tcGxldGlvbj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPENvbXBsZXRpb24+IHwgQVBJUHJvbWlzZTxTdHJlYW08Q29tcGxldGlvbj4+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9jb21wbGV0aW9ucycsIHsgYm9keSwgLi4ub3B0aW9ucywgc3RyZWFtOiBib2R5LnN0cmVhbSA/PyBmYWxzZSB9KSBhc1xuICAgICAgfCBBUElQcm9taXNlPENvbXBsZXRpb24+XG4gICAgICB8IEFQSVByb21pc2U8U3RyZWFtPENvbXBsZXRpb24+PjtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb21wbGV0aW9uIHJlc3BvbnNlIGZyb20gdGhlIEFQSS4gTm90ZTogYm90aCB0aGUgc3RyZWFtZWQgYW5kXG4gKiBub24tc3RyZWFtZWQgcmVzcG9uc2Ugb2JqZWN0cyBzaGFyZSB0aGUgc2FtZSBzaGFwZSAodW5saWtlIHRoZSBjaGF0IGVuZHBvaW50KS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjb21wbGV0aW9uLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgY29tcGxldGlvbiBjaG9pY2VzIHRoZSBtb2RlbCBnZW5lcmF0ZWQgZm9yIHRoZSBpbnB1dCBwcm9tcHQuXG4gICAqL1xuICBjaG9pY2VzOiBBcnJheTxDb21wbGV0aW9uQ2hvaWNlPjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBvZiB3aGVuIHRoZSBjb21wbGV0aW9uIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdXNlZCBmb3IgY29tcGxldGlvbi5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwidGV4dF9jb21wbGV0aW9uXCJcbiAgICovXG4gIG9iamVjdDogJ3RleHRfY29tcGxldGlvbic7XG5cbiAgLyoqXG4gICAqIFRoaXMgZmluZ2VycHJpbnQgcmVwcmVzZW50cyB0aGUgYmFja2VuZCBjb25maWd1cmF0aW9uIHRoYXQgdGhlIG1vZGVsIHJ1bnMgd2l0aC5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgYHNlZWRgIHJlcXVlc3QgcGFyYW1ldGVyIHRvIHVuZGVyc3RhbmQgd2hlblxuICAgKiBiYWNrZW5kIGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUgdGhhdCBtaWdodCBpbXBhY3QgZGV0ZXJtaW5pc20uXG4gICAqL1xuICBzeXN0ZW1fZmluZ2VycHJpbnQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBjb21wbGV0aW9uIHJlcXVlc3QuXG4gICAqL1xuICB1c2FnZT86IENvbXBsZXRpb25Vc2FnZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uQ2hvaWNlIHtcbiAgLyoqXG4gICAqIFRoZSByZWFzb24gdGhlIG1vZGVsIHN0b3BwZWQgZ2VuZXJhdGluZyB0b2tlbnMuIFRoaXMgd2lsbCBiZSBgc3RvcGAgaWYgdGhlIG1vZGVsXG4gICAqIGhpdCBhIG5hdHVyYWwgc3RvcCBwb2ludCBvciBhIHByb3ZpZGVkIHN0b3Agc2VxdWVuY2UsIGBsZW5ndGhgIGlmIHRoZSBtYXhpbXVtXG4gICAqIG51bWJlciBvZiB0b2tlbnMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0IHdhcyByZWFjaGVkLCBvciBgY29udGVudF9maWx0ZXJgIGlmXG4gICAqIGNvbnRlbnQgd2FzIG9taXR0ZWQgZHVlIHRvIGEgZmxhZyBmcm9tIG91ciBjb250ZW50IGZpbHRlcnMuXG4gICAqL1xuICBmaW5pc2hfcmVhc29uOiAnc3RvcCcgfCAnbGVuZ3RoJyB8ICdjb250ZW50X2ZpbHRlcic7XG5cbiAgaW5kZXg6IG51bWJlcjtcblxuICBsb2dwcm9iczogQ29tcGxldGlvbkNob2ljZS5Mb2dwcm9icyB8IG51bGw7XG5cbiAgdGV4dDogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENvbXBsZXRpb25DaG9pY2Uge1xuICBleHBvcnQgaW50ZXJmYWNlIExvZ3Byb2JzIHtcbiAgICB0ZXh0X29mZnNldD86IEFycmF5PG51bWJlcj47XG5cbiAgICB0b2tlbl9sb2dwcm9icz86IEFycmF5PG51bWJlcj47XG5cbiAgICB0b2tlbnM/OiBBcnJheTxzdHJpbmc+O1xuXG4gICAgdG9wX2xvZ3Byb2JzPzogQXJyYXk8UmVjb3JkPHN0cmluZywgbnVtYmVyPj47XG4gIH1cbn1cblxuLyoqXG4gKiBVc2FnZSBzdGF0aXN0aWNzIGZvciB0aGUgY29tcGxldGlvbiByZXF1ZXN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25Vc2FnZSB7XG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgdG9rZW5zIGluIHRoZSBnZW5lcmF0ZWQgY29tcGxldGlvbi5cbiAgICovXG4gIGNvbXBsZXRpb25fdG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiB0b2tlbnMgaW4gdGhlIHByb21wdC5cbiAgICovXG4gIHByb21wdF90b2tlbnM6IG51bWJlcjtcblxuICAvKipcbiAgICogVG90YWwgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIHRoZSByZXF1ZXN0IChwcm9tcHQgKyBjb21wbGV0aW9uKS5cbiAgICovXG4gIHRvdGFsX3Rva2VuczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBCcmVha2Rvd24gb2YgdG9rZW5zIHVzZWQgaW4gYSBjb21wbGV0aW9uLlxuICAgKi9cbiAgY29tcGxldGlvbl90b2tlbnNfZGV0YWlscz86IENvbXBsZXRpb25Vc2FnZS5Db21wbGV0aW9uVG9rZW5zRGV0YWlscztcblxuICAvKipcbiAgICogQnJlYWtkb3duIG9mIHRva2VucyB1c2VkIGluIHRoZSBwcm9tcHQuXG4gICAqL1xuICBwcm9tcHRfdG9rZW5zX2RldGFpbHM/OiBDb21wbGV0aW9uVXNhZ2UuUHJvbXB0VG9rZW5zRGV0YWlscztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDb21wbGV0aW9uVXNhZ2Uge1xuICAvKipcbiAgICogQnJlYWtkb3duIG9mIHRva2VucyB1c2VkIGluIGEgY29tcGxldGlvbi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvblRva2Vuc0RldGFpbHMge1xuICAgIC8qKlxuICAgICAqIFdoZW4gdXNpbmcgUHJlZGljdGVkIE91dHB1dHMsIHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBwcmVkaWN0aW9uIHRoYXRcbiAgICAgKiBhcHBlYXJlZCBpbiB0aGUgY29tcGxldGlvbi5cbiAgICAgKi9cbiAgICBhY2NlcHRlZF9wcmVkaWN0aW9uX3Rva2Vucz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEF1ZGlvIGlucHV0IHRva2VucyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGF1ZGlvX3Rva2Vucz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRva2VucyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGZvciByZWFzb25pbmcuXG4gICAgICovXG4gICAgcmVhc29uaW5nX3Rva2Vucz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdXNpbmcgUHJlZGljdGVkIE91dHB1dHMsIHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBwcmVkaWN0aW9uIHRoYXQgZGlkXG4gICAgICogbm90IGFwcGVhciBpbiB0aGUgY29tcGxldGlvbi4gSG93ZXZlciwgbGlrZSByZWFzb25pbmcgdG9rZW5zLCB0aGVzZSB0b2tlbnMgYXJlXG4gICAgICogc3RpbGwgY291bnRlZCBpbiB0aGUgdG90YWwgY29tcGxldGlvbiB0b2tlbnMgZm9yIHB1cnBvc2VzIG9mIGJpbGxpbmcsIG91dHB1dCxcbiAgICAgKiBhbmQgY29udGV4dCB3aW5kb3cgbGltaXRzLlxuICAgICAqL1xuICAgIHJlamVjdGVkX3ByZWRpY3Rpb25fdG9rZW5zPzogbnVtYmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEJyZWFrZG93biBvZiB0b2tlbnMgdXNlZCBpbiB0aGUgcHJvbXB0LlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBQcm9tcHRUb2tlbnNEZXRhaWxzIHtcbiAgICAvKipcbiAgICAgKiBBdWRpbyBpbnB1dCB0b2tlbnMgcHJlc2VudCBpbiB0aGUgcHJvbXB0LlxuICAgICAqL1xuICAgIGF1ZGlvX3Rva2Vucz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCB0b2tlbnMgcHJlc2VudCBpbiB0aGUgcHJvbXB0LlxuICAgICAqL1xuICAgIGNhY2hlZF90b2tlbnM/OiBudW1iZXI7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyA9IENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgfCBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIElEIG9mIHRoZSBtb2RlbCB0byB1c2UuIFlvdSBjYW4gdXNlIHRoZVxuICAgKiBbTGlzdCBtb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzL2xpc3QpIEFQSSB0b1xuICAgKiBzZWUgYWxsIG9mIHlvdXIgYXZhaWxhYmxlIG1vZGVscywgb3Igc2VlIG91clxuICAgKiBbTW9kZWwgb3ZlcnZpZXddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscykgZm9yIGRlc2NyaXB0aW9ucyBvZlxuICAgKiB0aGVtLlxuICAgKi9cbiAgbW9kZWw6IChzdHJpbmcgJiB7fSkgfCAnZ3B0LTMuNS10dXJiby1pbnN0cnVjdCcgfCAnZGF2aW5jaS0wMDInIHwgJ2JhYmJhZ2UtMDAyJztcblxuICAvKipcbiAgICogVGhlIHByb21wdChzKSB0byBnZW5lcmF0ZSBjb21wbGV0aW9ucyBmb3IsIGVuY29kZWQgYXMgYSBzdHJpbmcsIGFycmF5IG9mXG4gICAqIHN0cmluZ3MsIGFycmF5IG9mIHRva2Vucywgb3IgYXJyYXkgb2YgdG9rZW4gYXJyYXlzLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgPHxlbmRvZnRleHR8PiBpcyB0aGUgZG9jdW1lbnQgc2VwYXJhdG9yIHRoYXQgdGhlIG1vZGVsIHNlZXMgZHVyaW5nXG4gICAqIHRyYWluaW5nLCBzbyBpZiBhIHByb21wdCBpcyBub3Qgc3BlY2lmaWVkIHRoZSBtb2RlbCB3aWxsIGdlbmVyYXRlIGFzIGlmIGZyb20gdGhlXG4gICAqIGJlZ2lubmluZyBvZiBhIG5ldyBkb2N1bWVudC5cbiAgICovXG4gIHByb21wdDogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPiB8IEFycmF5PG51bWJlcj4gfCBBcnJheTxBcnJheTxudW1iZXI+PiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBgYmVzdF9vZmAgY29tcGxldGlvbnMgc2VydmVyLXNpZGUgYW5kIHJldHVybnMgdGhlIFwiYmVzdFwiICh0aGUgb25lIHdpdGhcbiAgICogdGhlIGhpZ2hlc3QgbG9nIHByb2JhYmlsaXR5IHBlciB0b2tlbikuIFJlc3VsdHMgY2Fubm90IGJlIHN0cmVhbWVkLlxuICAgKlxuICAgKiBXaGVuIHVzZWQgd2l0aCBgbmAsIGBiZXN0X29mYCBjb250cm9scyB0aGUgbnVtYmVyIG9mIGNhbmRpZGF0ZSBjb21wbGV0aW9ucyBhbmRcbiAgICogYG5gIHNwZWNpZmllcyBob3cgbWFueSB0byByZXR1cm4gXHUyMDEzIGBiZXN0X29mYCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBgbmAuXG4gICAqXG4gICAqICoqTm90ZToqKiBCZWNhdXNlIHRoaXMgcGFyYW1ldGVyIGdlbmVyYXRlcyBtYW55IGNvbXBsZXRpb25zLCBpdCBjYW4gcXVpY2tseVxuICAgKiBjb25zdW1lIHlvdXIgdG9rZW4gcXVvdGEuIFVzZSBjYXJlZnVsbHkgYW5kIGVuc3VyZSB0aGF0IHlvdSBoYXZlIHJlYXNvbmFibGVcbiAgICogc2V0dGluZ3MgZm9yIGBtYXhfdG9rZW5zYCBhbmQgYHN0b3BgLlxuICAgKi9cbiAgYmVzdF9vZj86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEVjaG8gYmFjayB0aGUgcHJvbXB0IGluIGFkZGl0aW9uIHRvIHRoZSBjb21wbGV0aW9uXG4gICAqL1xuICBlY2hvPzogYm9vbGVhbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE51bWJlciBiZXR3ZWVuIC0yLjAgYW5kIDIuMC4gUG9zaXRpdmUgdmFsdWVzIHBlbmFsaXplIG5ldyB0b2tlbnMgYmFzZWQgb24gdGhlaXJcbiAgICogZXhpc3RpbmcgZnJlcXVlbmN5IGluIHRoZSB0ZXh0IHNvIGZhciwgZGVjcmVhc2luZyB0aGUgbW9kZWwncyBsaWtlbGlob29kIHRvXG4gICAqIHJlcGVhdCB0aGUgc2FtZSBsaW5lIHZlcmJhdGltLlxuICAgKlxuICAgKiBbU2VlIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgZnJlcXVlbmN5IGFuZCBwcmVzZW5jZSBwZW5hbHRpZXMuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvdGV4dC1nZW5lcmF0aW9uKVxuICAgKi9cbiAgZnJlcXVlbmN5X3BlbmFsdHk/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIGxpa2VsaWhvb2Qgb2Ygc3BlY2lmaWVkIHRva2VucyBhcHBlYXJpbmcgaW4gdGhlIGNvbXBsZXRpb24uXG4gICAqXG4gICAqIEFjY2VwdHMgYSBKU09OIG9iamVjdCB0aGF0IG1hcHMgdG9rZW5zIChzcGVjaWZpZWQgYnkgdGhlaXIgdG9rZW4gSUQgaW4gdGhlIEdQVFxuICAgKiB0b2tlbml6ZXIpIHRvIGFuIGFzc29jaWF0ZWQgYmlhcyB2YWx1ZSBmcm9tIC0xMDAgdG8gMTAwLiBZb3UgY2FuIHVzZSB0aGlzXG4gICAqIFt0b2tlbml6ZXIgdG9vbF0oL3Rva2VuaXplcj92aWV3PWJwZSkgdG8gY29udmVydCB0ZXh0IHRvIHRva2VuIElEcy5cbiAgICogTWF0aGVtYXRpY2FsbHksIHRoZSBiaWFzIGlzIGFkZGVkIHRvIHRoZSBsb2dpdHMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBwcmlvciB0b1xuICAgKiBzYW1wbGluZy4gVGhlIGV4YWN0IGVmZmVjdCB3aWxsIHZhcnkgcGVyIG1vZGVsLCBidXQgdmFsdWVzIGJldHdlZW4gLTEgYW5kIDFcbiAgICogc2hvdWxkIGRlY3JlYXNlIG9yIGluY3JlYXNlIGxpa2VsaWhvb2Qgb2Ygc2VsZWN0aW9uOyB2YWx1ZXMgbGlrZSAtMTAwIG9yIDEwMFxuICAgKiBzaG91bGQgcmVzdWx0IGluIGEgYmFuIG9yIGV4Y2x1c2l2ZSBzZWxlY3Rpb24gb2YgdGhlIHJlbGV2YW50IHRva2VuLlxuICAgKlxuICAgKiBBcyBhbiBleGFtcGxlLCB5b3UgY2FuIHBhc3MgYHtcIjUwMjU2XCI6IC0xMDB9YCB0byBwcmV2ZW50IHRoZSA8fGVuZG9mdGV4dHw+IHRva2VuXG4gICAqIGZyb20gYmVpbmcgZ2VuZXJhdGVkLlxuICAgKi9cbiAgbG9naXRfYmlhcz86IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJbmNsdWRlIHRoZSBsb2cgcHJvYmFiaWxpdGllcyBvbiB0aGUgYGxvZ3Byb2JzYCBtb3N0IGxpa2VseSBvdXRwdXQgdG9rZW5zLCBhc1xuICAgKiB3ZWxsIHRoZSBjaG9zZW4gdG9rZW5zLiBGb3IgZXhhbXBsZSwgaWYgYGxvZ3Byb2JzYCBpcyA1LCB0aGUgQVBJIHdpbGwgcmV0dXJuIGFcbiAgICogbGlzdCBvZiB0aGUgNSBtb3N0IGxpa2VseSB0b2tlbnMuIFRoZSBBUEkgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBgbG9ncHJvYmAgb2ZcbiAgICogdGhlIHNhbXBsZWQgdG9rZW4sIHNvIHRoZXJlIG1heSBiZSB1cCB0byBgbG9ncHJvYnMrMWAgZWxlbWVudHMgaW4gdGhlIHJlc3BvbnNlLlxuICAgKlxuICAgKiBUaGUgbWF4aW11bSB2YWx1ZSBmb3IgYGxvZ3Byb2JzYCBpcyA1LlxuICAgKi9cbiAgbG9ncHJvYnM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgW3Rva2Vuc10oL3Rva2VuaXplcikgdGhhdCBjYW4gYmUgZ2VuZXJhdGVkIGluIHRoZVxuICAgKiBjb21wbGV0aW9uLlxuICAgKlxuICAgKiBUaGUgdG9rZW4gY291bnQgb2YgeW91ciBwcm9tcHQgcGx1cyBgbWF4X3Rva2Vuc2AgY2Fubm90IGV4Y2VlZCB0aGUgbW9kZWwnc1xuICAgKiBjb250ZXh0IGxlbmd0aC5cbiAgICogW0V4YW1wbGUgUHl0aG9uIGNvZGVdKGh0dHBzOi8vY29va2Jvb2sub3BlbmFpLmNvbS9leGFtcGxlcy9ob3dfdG9fY291bnRfdG9rZW5zX3dpdGhfdGlrdG9rZW4pXG4gICAqIGZvciBjb3VudGluZyB0b2tlbnMuXG4gICAqL1xuICBtYXhfdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogSG93IG1hbnkgY29tcGxldGlvbnMgdG8gZ2VuZXJhdGUgZm9yIGVhY2ggcHJvbXB0LlxuICAgKlxuICAgKiAqKk5vdGU6KiogQmVjYXVzZSB0aGlzIHBhcmFtZXRlciBnZW5lcmF0ZXMgbWFueSBjb21wbGV0aW9ucywgaXQgY2FuIHF1aWNrbHlcbiAgICogY29uc3VtZSB5b3VyIHRva2VuIHF1b3RhLiBVc2UgY2FyZWZ1bGx5IGFuZCBlbnN1cmUgdGhhdCB5b3UgaGF2ZSByZWFzb25hYmxlXG4gICAqIHNldHRpbmdzIGZvciBgbWF4X3Rva2Vuc2AgYW5kIGBzdG9wYC5cbiAgICovXG4gIG4/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgYmV0d2VlbiAtMi4wIGFuZCAyLjAuIFBvc2l0aXZlIHZhbHVlcyBwZW5hbGl6ZSBuZXcgdG9rZW5zIGJhc2VkIG9uXG4gICAqIHdoZXRoZXIgdGhleSBhcHBlYXIgaW4gdGhlIHRleHQgc28gZmFyLCBpbmNyZWFzaW5nIHRoZSBtb2RlbCdzIGxpa2VsaWhvb2QgdG9cbiAgICogdGFsayBhYm91dCBuZXcgdG9waWNzLlxuICAgKlxuICAgKiBbU2VlIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgZnJlcXVlbmN5IGFuZCBwcmVzZW5jZSBwZW5hbHRpZXMuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvdGV4dC1nZW5lcmF0aW9uKVxuICAgKi9cbiAgcHJlc2VuY2VfcGVuYWx0eT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIElmIHNwZWNpZmllZCwgb3VyIHN5c3RlbSB3aWxsIG1ha2UgYSBiZXN0IGVmZm9ydCB0byBzYW1wbGUgZGV0ZXJtaW5pc3RpY2FsbHksXG4gICAqIHN1Y2ggdGhhdCByZXBlYXRlZCByZXF1ZXN0cyB3aXRoIHRoZSBzYW1lIGBzZWVkYCBhbmQgcGFyYW1ldGVycyBzaG91bGQgcmV0dXJuXG4gICAqIHRoZSBzYW1lIHJlc3VsdC5cbiAgICpcbiAgICogRGV0ZXJtaW5pc20gaXMgbm90IGd1YXJhbnRlZWQsIGFuZCB5b3Ugc2hvdWxkIHJlZmVyIHRvIHRoZSBgc3lzdGVtX2ZpbmdlcnByaW50YFxuICAgKiByZXNwb25zZSBwYXJhbWV0ZXIgdG8gbW9uaXRvciBjaGFuZ2VzIGluIHRoZSBiYWNrZW5kLlxuICAgKi9cbiAgc2VlZD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFVwIHRvIDQgc2VxdWVuY2VzIHdoZXJlIHRoZSBBUEkgd2lsbCBzdG9wIGdlbmVyYXRpbmcgZnVydGhlciB0b2tlbnMuIFRoZVxuICAgKiByZXR1cm5lZCB0ZXh0IHdpbGwgbm90IGNvbnRhaW4gdGhlIHN0b3Agc2VxdWVuY2UuXG4gICAqL1xuICBzdG9wPzogc3RyaW5nIHwgbnVsbCB8IEFycmF5PHN0cmluZz47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3RyZWFtIGJhY2sgcGFydGlhbCBwcm9ncmVzcy4gSWYgc2V0LCB0b2tlbnMgd2lsbCBiZSBzZW50IGFzXG4gICAqIGRhdGEtb25seVxuICAgKiBbc2VydmVyLXNlbnQgZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmVyLXNlbnRfZXZlbnRzL1VzaW5nX3NlcnZlci1zZW50X2V2ZW50cyNFdmVudF9zdHJlYW1fZm9ybWF0KVxuICAgKiBhcyB0aGV5IGJlY29tZSBhdmFpbGFibGUsIHdpdGggdGhlIHN0cmVhbSB0ZXJtaW5hdGVkIGJ5IGEgYGRhdGE6IFtET05FXWBcbiAgICogbWVzc2FnZS5cbiAgICogW0V4YW1wbGUgUHl0aG9uIGNvZGVdKGh0dHBzOi8vY29va2Jvb2sub3BlbmFpLmNvbS9leGFtcGxlcy9ob3dfdG9fc3RyZWFtX2NvbXBsZXRpb25zKS5cbiAgICovXG4gIHN0cmVhbT86IGJvb2xlYW4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciBzdHJlYW1pbmcgcmVzcG9uc2UuIE9ubHkgc2V0IHRoaXMgd2hlbiB5b3Ugc2V0IGBzdHJlYW06IHRydWVgLlxuICAgKi9cbiAgc3RyZWFtX29wdGlvbnM/OiBDaGF0Q29tcGxldGlvbnNBUEkuQ2hhdENvbXBsZXRpb25TdHJlYW1PcHRpb25zIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHN1ZmZpeCB0aGF0IGNvbWVzIGFmdGVyIGEgY29tcGxldGlvbiBvZiBpbnNlcnRlZCB0ZXh0LlxuICAgKlxuICAgKiBUaGlzIHBhcmFtZXRlciBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgYGdwdC0zLjUtdHVyYm8taW5zdHJ1Y3RgLlxuICAgKi9cbiAgc3VmZml4Pzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciBgdG9wX3BgIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgYHRlbXBlcmF0dXJlYCBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgcmVwcmVzZW50aW5nIHlvdXIgZW5kLXVzZXIsIHdoaWNoIGNhbiBoZWxwIE9wZW5BSSB0byBtb25pdG9yXG4gICAqIGFuZCBkZXRlY3QgYWJ1c2UuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc2FmZXR5LWJlc3QtcHJhY3RpY2VzI2VuZC11c2VyLWlkcykuXG4gICAqL1xuICB1c2VyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENvbXBsZXRpb25DcmVhdGVQYXJhbXMge1xuICBleHBvcnQgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nID0gQ29tcGxldGlvbnNBUEkuQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZztcbiAgZXhwb3J0IHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyA9IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyBleHRlbmRzIENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3RyZWFtIGJhY2sgcGFydGlhbCBwcm9ncmVzcy4gSWYgc2V0LCB0b2tlbnMgd2lsbCBiZSBzZW50IGFzXG4gICAqIGRhdGEtb25seVxuICAgKiBbc2VydmVyLXNlbnQgZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmVyLXNlbnRfZXZlbnRzL1VzaW5nX3NlcnZlci1zZW50X2V2ZW50cyNFdmVudF9zdHJlYW1fZm9ybWF0KVxuICAgKiBhcyB0aGV5IGJlY29tZSBhdmFpbGFibGUsIHdpdGggdGhlIHN0cmVhbSB0ZXJtaW5hdGVkIGJ5IGEgYGRhdGE6IFtET05FXWBcbiAgICogbWVzc2FnZS5cbiAgICogW0V4YW1wbGUgUHl0aG9uIGNvZGVdKGh0dHBzOi8vY29va2Jvb2sub3BlbmFpLmNvbS9leGFtcGxlcy9ob3dfdG9fc3RyZWFtX2NvbXBsZXRpb25zKS5cbiAgICovXG4gIHN0cmVhbT86IGZhbHNlIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGV4dGVuZHMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogV2hldGhlciB0byBzdHJlYW0gYmFjayBwYXJ0aWFsIHByb2dyZXNzLiBJZiBzZXQsIHRva2VucyB3aWxsIGJlIHNlbnQgYXNcbiAgICogZGF0YS1vbmx5XG4gICAqIFtzZXJ2ZXItc2VudCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2ZXItc2VudF9ldmVudHMvVXNpbmdfc2VydmVyLXNlbnRfZXZlbnRzI0V2ZW50X3N0cmVhbV9mb3JtYXQpXG4gICAqIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSwgd2l0aCB0aGUgc3RyZWFtIHRlcm1pbmF0ZWQgYnkgYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9jb29rYm9vay5vcGVuYWkuY29tL2V4YW1wbGVzL2hvd190b19zdHJlYW1fY29tcGxldGlvbnMpLlxuICAgKi9cbiAgc3RyZWFtOiB0cnVlO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgQ29tcGxldGlvbnMge1xuICBleHBvcnQge1xuICAgIHR5cGUgQ29tcGxldGlvbiBhcyBDb21wbGV0aW9uLFxuICAgIHR5cGUgQ29tcGxldGlvbkNob2ljZSBhcyBDb21wbGV0aW9uQ2hvaWNlLFxuICAgIHR5cGUgQ29tcGxldGlvblVzYWdlIGFzIENvbXBsZXRpb25Vc2FnZSxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXMgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vY29yZSc7XG5cbmV4cG9ydCBjbGFzcyBFbWJlZGRpbmdzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBlbWJlZGRpbmcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgaW5wdXQgdGV4dC5cbiAgICovXG4gIGNyZWF0ZShcbiAgICBib2R5OiBFbWJlZGRpbmdDcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxDcmVhdGVFbWJlZGRpbmdSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2VtYmVkZGluZ3MnLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVFbWJlZGRpbmdSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBlbWJlZGRpbmdzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwuXG4gICAqL1xuICBkYXRhOiBBcnJheTxFbWJlZGRpbmc+O1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgbW9kZWwgdXNlZCB0byBnZW5lcmF0ZSB0aGUgZW1iZWRkaW5nLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgXCJsaXN0XCIuXG4gICAqL1xuICBvYmplY3Q6ICdsaXN0JztcblxuICAvKipcbiAgICogVGhlIHVzYWdlIGluZm9ybWF0aW9uIGZvciB0aGUgcmVxdWVzdC5cbiAgICovXG4gIHVzYWdlOiBDcmVhdGVFbWJlZGRpbmdSZXNwb25zZS5Vc2FnZTtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDcmVhdGVFbWJlZGRpbmdSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBUaGUgdXNhZ2UgaW5mb3JtYXRpb24gZm9yIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBVc2FnZSB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiB0b2tlbnMgdXNlZCBieSB0aGUgcHJvbXB0LlxuICAgICAqL1xuICAgIHByb21wdF90b2tlbnM6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgdG9rZW5zIHVzZWQgYnkgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgdG90YWxfdG9rZW5zOiBudW1iZXI7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGVtYmVkZGluZyB2ZWN0b3IgcmV0dXJuZWQgYnkgZW1iZWRkaW5nIGVuZHBvaW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVtYmVkZGluZyB7XG4gIC8qKlxuICAgKiBUaGUgZW1iZWRkaW5nIHZlY3Rvciwgd2hpY2ggaXMgYSBsaXN0IG9mIGZsb2F0cy4gVGhlIGxlbmd0aCBvZiB2ZWN0b3IgZGVwZW5kcyBvblxuICAgKiB0aGUgbW9kZWwgYXMgbGlzdGVkIGluIHRoZVxuICAgKiBbZW1iZWRkaW5nIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZW1iZWRkaW5ncykuXG4gICAqL1xuICBlbWJlZGRpbmc6IEFycmF5PG51bWJlcj47XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgZW1iZWRkaW5nIGluIHRoZSBsaXN0IG9mIGVtYmVkZGluZ3MuXG4gICAqL1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcImVtYmVkZGluZ1wiLlxuICAgKi9cbiAgb2JqZWN0OiAnZW1iZWRkaW5nJztcbn1cblxuZXhwb3J0IHR5cGUgRW1iZWRkaW5nTW9kZWwgPSAndGV4dC1lbWJlZGRpbmctYWRhLTAwMicgfCAndGV4dC1lbWJlZGRpbmctMy1zbWFsbCcgfCAndGV4dC1lbWJlZGRpbmctMy1sYXJnZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW1iZWRkaW5nQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIElucHV0IHRleHQgdG8gZW1iZWQsIGVuY29kZWQgYXMgYSBzdHJpbmcgb3IgYXJyYXkgb2YgdG9rZW5zLiBUbyBlbWJlZCBtdWx0aXBsZVxuICAgKiBpbnB1dHMgaW4gYSBzaW5nbGUgcmVxdWVzdCwgcGFzcyBhbiBhcnJheSBvZiBzdHJpbmdzIG9yIGFycmF5IG9mIHRva2VuIGFycmF5cy5cbiAgICogVGhlIGlucHV0IG11c3Qgbm90IGV4Y2VlZCB0aGUgbWF4IGlucHV0IHRva2VucyBmb3IgdGhlIG1vZGVsICg4MTkyIHRva2VucyBmb3JcbiAgICogYHRleHQtZW1iZWRkaW5nLWFkYS0wMDJgKSwgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZywgYW5kIGFueSBhcnJheSBtdXN0IGJlIDIwNDhcbiAgICogZGltZW5zaW9ucyBvciBsZXNzLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9jb29rYm9vay5vcGVuYWkuY29tL2V4YW1wbGVzL2hvd190b19jb3VudF90b2tlbnNfd2l0aF90aWt0b2tlbilcbiAgICogZm9yIGNvdW50aW5nIHRva2Vucy5cbiAgICovXG4gIGlucHV0OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+IHwgQXJyYXk8bnVtYmVyPiB8IEFycmF5PEFycmF5PG51bWJlcj4+O1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBZb3UgY2FuIHVzZSB0aGVcbiAgICogW0xpc3QgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscy9saXN0KSBBUEkgdG9cbiAgICogc2VlIGFsbCBvZiB5b3VyIGF2YWlsYWJsZSBtb2RlbHMsIG9yIHNlZSBvdXJcbiAgICogW01vZGVsIG92ZXJ2aWV3XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMpIGZvciBkZXNjcmlwdGlvbnMgb2ZcbiAgICogdGhlbS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgRW1iZWRkaW5nTW9kZWw7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgZGltZW5zaW9ucyB0aGUgcmVzdWx0aW5nIG91dHB1dCBlbWJlZGRpbmdzIHNob3VsZCBoYXZlLiBPbmx5XG4gICAqIHN1cHBvcnRlZCBpbiBgdGV4dC1lbWJlZGRpbmctM2AgYW5kIGxhdGVyIG1vZGVscy5cbiAgICovXG4gIGRpbWVuc2lvbnM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBmb3JtYXQgdG8gcmV0dXJuIHRoZSBlbWJlZGRpbmdzIGluLiBDYW4gYmUgZWl0aGVyIGBmbG9hdGAgb3JcbiAgICogW2BiYXNlNjRgXShodHRwczovL3B5cGkub3JnL3Byb2plY3QvcHliYXNlNjQvKS5cbiAgICovXG4gIGVuY29kaW5nX2Zvcm1hdD86ICdmbG9hdCcgfCAnYmFzZTY0JztcblxuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciByZXByZXNlbnRpbmcgeW91ciBlbmQtdXNlciwgd2hpY2ggY2FuIGhlbHAgT3BlbkFJIHRvIG1vbml0b3JcbiAgICogYW5kIGRldGVjdCBhYnVzZS5cbiAgICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zYWZldHktYmVzdC1wcmFjdGljZXMjZW5kLXVzZXItaWRzKS5cbiAgICovXG4gIHVzZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBFbWJlZGRpbmdzIHtcbiAgZXhwb3J0IHtcbiAgICB0eXBlIENyZWF0ZUVtYmVkZGluZ1Jlc3BvbnNlIGFzIENyZWF0ZUVtYmVkZGluZ1Jlc3BvbnNlLFxuICAgIHR5cGUgRW1iZWRkaW5nIGFzIEVtYmVkZGluZyxcbiAgICB0eXBlIEVtYmVkZGluZ01vZGVsIGFzIEVtYmVkZGluZ01vZGVsLFxuICAgIHR5cGUgRW1iZWRkaW5nQ3JlYXRlUGFyYW1zIGFzIEVtYmVkZGluZ0NyZWF0ZVBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7IHNsZWVwIH0gZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgeyBBUElDb25uZWN0aW9uVGltZW91dEVycm9yIH0gZnJvbSAnLi4vZXJyb3InO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7IEN1cnNvclBhZ2UsIHR5cGUgQ3Vyc29yUGFnZVBhcmFtcyB9IGZyb20gJy4uL3BhZ2luYXRpb24nO1xuaW1wb3J0IHsgdHlwZSBSZXNwb25zZSB9IGZyb20gJy4uL19zaGltcy9pbmRleCc7XG5cbmV4cG9ydCBjbGFzcyBGaWxlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFVwbG9hZCBhIGZpbGUgdGhhdCBjYW4gYmUgdXNlZCBhY3Jvc3MgdmFyaW91cyBlbmRwb2ludHMuIEluZGl2aWR1YWwgZmlsZXMgY2FuIGJlXG4gICAqIHVwIHRvIDUxMiBNQiwgYW5kIHRoZSBzaXplIG9mIGFsbCBmaWxlcyB1cGxvYWRlZCBieSBvbmUgb3JnYW5pemF0aW9uIGNhbiBiZSB1cFxuICAgKiB0byAxMDAgR0IuXG4gICAqXG4gICAqIFRoZSBBc3Npc3RhbnRzIEFQSSBzdXBwb3J0cyBmaWxlcyB1cCB0byAyIG1pbGxpb24gdG9rZW5zIGFuZCBvZiBzcGVjaWZpYyBmaWxlXG4gICAqIHR5cGVzLiBTZWUgdGhlXG4gICAqIFtBc3Npc3RhbnRzIFRvb2xzIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL3Rvb2xzKSBmb3JcbiAgICogZGV0YWlscy5cbiAgICpcbiAgICogVGhlIEZpbmUtdHVuaW5nIEFQSSBvbmx5IHN1cHBvcnRzIGAuanNvbmxgIGZpbGVzLiBUaGUgaW5wdXQgYWxzbyBoYXMgY2VydGFpblxuICAgKiByZXF1aXJlZCBmb3JtYXRzIGZvciBmaW5lLXR1bmluZ1xuICAgKiBbY2hhdF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maW5lLXR1bmluZy9jaGF0LWlucHV0KSBvclxuICAgKiBbY29tcGxldGlvbnNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmluZS10dW5pbmcvY29tcGxldGlvbnMtaW5wdXQpXG4gICAqIG1vZGVscy5cbiAgICpcbiAgICogVGhlIEJhdGNoIEFQSSBvbmx5IHN1cHBvcnRzIGAuanNvbmxgIGZpbGVzIHVwIHRvIDIwMCBNQiBpbiBzaXplLiBUaGUgaW5wdXQgYWxzb1xuICAgKiBoYXMgYSBzcGVjaWZpYyByZXF1aXJlZFxuICAgKiBbZm9ybWF0XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2JhdGNoL3JlcXVlc3QtaW5wdXQpLlxuICAgKlxuICAgKiBQbGVhc2UgW2NvbnRhY3QgdXNdKGh0dHBzOi8vaGVscC5vcGVuYWkuY29tLykgaWYgeW91IG5lZWQgdG8gaW5jcmVhc2UgdGhlc2VcbiAgICogc3RvcmFnZSBsaW1pdHMuXG4gICAqL1xuICBjcmVhdGUoYm9keTogRmlsZUNyZWF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8RmlsZU9iamVjdD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2ZpbGVzJywgQ29yZS5tdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IGEgc3BlY2lmaWMgZmlsZS5cbiAgICovXG4gIHJldHJpZXZlKGZpbGVJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxGaWxlT2JqZWN0PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC9maWxlcy8ke2ZpbGVJZH1gLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmaWxlcy5cbiAgICovXG4gIGxpc3QocXVlcnk/OiBGaWxlTGlzdFBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPEZpbGVPYmplY3RzUGFnZSwgRmlsZU9iamVjdD47XG4gIGxpc3Qob3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPEZpbGVPYmplY3RzUGFnZSwgRmlsZU9iamVjdD47XG4gIGxpc3QoXG4gICAgcXVlcnk6IEZpbGVMaXN0UGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbGVPYmplY3RzUGFnZSwgRmlsZU9iamVjdD4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdCh7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy9maWxlcycsIEZpbGVPYmplY3RzUGFnZSwgeyBxdWVyeSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBmaWxlLlxuICAgKi9cbiAgZGVsKGZpbGVJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxGaWxlRGVsZXRlZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZGVsZXRlKGAvZmlsZXMvJHtmaWxlSWR9YCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIHNwZWNpZmllZCBmaWxlLlxuICAgKi9cbiAgY29udGVudChmaWxlSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8UmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL2ZpbGVzLyR7ZmlsZUlkfS9jb250ZW50YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgQWNjZXB0OiAnYXBwbGljYXRpb24vYmluYXJ5JywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgX19iaW5hcnlSZXNwb25zZTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGUgc3BlY2lmaWVkIGZpbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBgLmNvbnRlbnQoKWAgbWV0aG9kIHNob3VsZCBiZSB1c2VkIGluc3RlYWRcbiAgICovXG4gIHJldHJpZXZlQ29udGVudChmaWxlSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC9maWxlcy8ke2ZpbGVJZH0vY29udGVudGAsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhaXRzIGZvciB0aGUgZ2l2ZW4gZmlsZSB0byBiZSBwcm9jZXNzZWQsIGRlZmF1bHQgdGltZW91dCBpcyAzMCBtaW5zLlxuICAgKi9cbiAgYXN5bmMgd2FpdEZvclByb2Nlc3NpbmcoXG4gICAgaWQ6IHN0cmluZyxcbiAgICB7IHBvbGxJbnRlcnZhbCA9IDUwMDAsIG1heFdhaXQgPSAzMCAqIDYwICogMTAwMCB9OiB7IHBvbGxJbnRlcnZhbD86IG51bWJlcjsgbWF4V2FpdD86IG51bWJlciB9ID0ge30sXG4gICk6IFByb21pc2U8RmlsZU9iamVjdD4ge1xuICAgIGNvbnN0IFRFUk1JTkFMX1NUQVRFUyA9IG5ldyBTZXQoWydwcm9jZXNzZWQnLCAnZXJyb3InLCAnZGVsZXRlZCddKTtcblxuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgZmlsZSA9IGF3YWl0IHRoaXMucmV0cmlldmUoaWQpO1xuXG4gICAgd2hpbGUgKCFmaWxlLnN0YXR1cyB8fCAhVEVSTUlOQUxfU1RBVEVTLmhhcyhmaWxlLnN0YXR1cykpIHtcbiAgICAgIGF3YWl0IHNsZWVwKHBvbGxJbnRlcnZhbCk7XG5cbiAgICAgIGZpbGUgPSBhd2FpdCB0aGlzLnJldHJpZXZlKGlkKTtcbiAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnQgPiBtYXhXYWl0KSB7XG4gICAgICAgIHRocm93IG5ldyBBUElDb25uZWN0aW9uVGltZW91dEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBgR2l2aW5nIHVwIG9uIHdhaXRpbmcgZm9yIGZpbGUgJHtpZH0gdG8gZmluaXNoIHByb2Nlc3NpbmcgYWZ0ZXIgJHttYXhXYWl0fSBtaWxsaXNlY29uZHMuYCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZpbGVPYmplY3RzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8RmlsZU9iamVjdD4ge31cblxuZXhwb3J0IHR5cGUgRmlsZUNvbnRlbnQgPSBzdHJpbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZURlbGV0ZWQge1xuICBpZDogc3RyaW5nO1xuXG4gIGRlbGV0ZWQ6IGJvb2xlYW47XG5cbiAgb2JqZWN0OiAnZmlsZSc7XG59XG5cbi8qKlxuICogVGhlIGBGaWxlYCBvYmplY3QgcmVwcmVzZW50cyBhIGRvY3VtZW50IHRoYXQgaGFzIGJlZW4gdXBsb2FkZWQgdG8gT3BlbkFJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVPYmplY3Qge1xuICAvKipcbiAgICogVGhlIGZpbGUgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gdGhlIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgZmlsZSwgaW4gYnl0ZXMuXG4gICAqL1xuICBieXRlczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBmaWxlIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZmlsZS5cbiAgICovXG4gIGZpbGVuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGBmaWxlYC5cbiAgICovXG4gIG9iamVjdDogJ2ZpbGUnO1xuXG4gIC8qKlxuICAgKiBUaGUgaW50ZW5kZWQgcHVycG9zZSBvZiB0aGUgZmlsZS4gU3VwcG9ydGVkIHZhbHVlcyBhcmUgYGFzc2lzdGFudHNgLFxuICAgKiBgYXNzaXN0YW50c19vdXRwdXRgLCBgYmF0Y2hgLCBgYmF0Y2hfb3V0cHV0YCwgYGZpbmUtdHVuZWAsIGBmaW5lLXR1bmUtcmVzdWx0c2BcbiAgICogYW5kIGB2aXNpb25gLlxuICAgKi9cbiAgcHVycG9zZTpcbiAgICB8ICdhc3Npc3RhbnRzJ1xuICAgIHwgJ2Fzc2lzdGFudHNfb3V0cHV0J1xuICAgIHwgJ2JhdGNoJ1xuICAgIHwgJ2JhdGNoX291dHB1dCdcbiAgICB8ICdmaW5lLXR1bmUnXG4gICAgfCAnZmluZS10dW5lLXJlc3VsdHMnXG4gICAgfCAndmlzaW9uJztcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQ6IERlcHJlY2F0ZWQuIFRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgZmlsZSwgd2hpY2ggY2FuIGJlIGVpdGhlclxuICAgKiBgdXBsb2FkZWRgLCBgcHJvY2Vzc2VkYCwgb3IgYGVycm9yYC5cbiAgICovXG4gIHN0YXR1czogJ3VwbG9hZGVkJyB8ICdwcm9jZXNzZWQnIHwgJ2Vycm9yJztcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQ6IERlcHJlY2F0ZWQuIEZvciBkZXRhaWxzIG9uIHdoeSBhIGZpbmUtdHVuaW5nIHRyYWluaW5nIGZpbGUgZmFpbGVkXG4gICAqIHZhbGlkYXRpb24sIHNlZSB0aGUgYGVycm9yYCBmaWVsZCBvbiBgZmluZV90dW5pbmcuam9iYC5cbiAgICovXG4gIHN0YXR1c19kZXRhaWxzPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRoZSBpbnRlbmRlZCBwdXJwb3NlIG9mIHRoZSB1cGxvYWRlZCBmaWxlLlxuICpcbiAqIFVzZSBcImFzc2lzdGFudHNcIiBmb3JcbiAqIFtBc3Npc3RhbnRzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpIGFuZFxuICogW01lc3NhZ2VdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbWVzc2FnZXMpIGZpbGVzLFxuICogXCJ2aXNpb25cIiBmb3IgQXNzaXN0YW50cyBpbWFnZSBmaWxlIGlucHV0cywgXCJiYXRjaFwiIGZvclxuICogW0JhdGNoIEFQSV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2JhdGNoKSwgYW5kIFwiZmluZS10dW5lXCIgZm9yXG4gKiBbRmluZS10dW5pbmddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmluZS10dW5pbmcpLlxuICovXG5leHBvcnQgdHlwZSBGaWxlUHVycG9zZSA9ICdhc3Npc3RhbnRzJyB8ICdiYXRjaCcgfCAnZmluZS10dW5lJyB8ICd2aXNpb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIEZpbGUgb2JqZWN0IChub3QgZmlsZSBuYW1lKSB0byBiZSB1cGxvYWRlZC5cbiAgICovXG4gIGZpbGU6IENvcmUuVXBsb2FkYWJsZTtcblxuICAvKipcbiAgICogVGhlIGludGVuZGVkIHB1cnBvc2Ugb2YgdGhlIHVwbG9hZGVkIGZpbGUuXG4gICAqXG4gICAqIFVzZSBcImFzc2lzdGFudHNcIiBmb3JcbiAgICogW0Fzc2lzdGFudHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYXNzaXN0YW50cykgYW5kXG4gICAqIFtNZXNzYWdlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21lc3NhZ2VzKSBmaWxlcyxcbiAgICogXCJ2aXNpb25cIiBmb3IgQXNzaXN0YW50cyBpbWFnZSBmaWxlIGlucHV0cywgXCJiYXRjaFwiIGZvclxuICAgKiBbQmF0Y2ggQVBJXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvYmF0Y2gpLCBhbmQgXCJmaW5lLXR1bmVcIiBmb3JcbiAgICogW0ZpbmUtdHVuaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuaW5nKS5cbiAgICovXG4gIHB1cnBvc2U6IEZpbGVQdXJwb3NlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVMaXN0UGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBTb3J0IG9yZGVyIGJ5IHRoZSBgY3JlYXRlZF9hdGAgdGltZXN0YW1wIG9mIHRoZSBvYmplY3RzLiBgYXNjYCBmb3IgYXNjZW5kaW5nXG4gICAqIG9yZGVyIGFuZCBgZGVzY2AgZm9yIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAqL1xuICBvcmRlcj86ICdhc2MnIHwgJ2Rlc2MnO1xuXG4gIC8qKlxuICAgKiBPbmx5IHJldHVybiBmaWxlcyB3aXRoIHRoZSBnaXZlbiBwdXJwb3NlLlxuICAgKi9cbiAgcHVycG9zZT86IHN0cmluZztcbn1cblxuRmlsZXMuRmlsZU9iamVjdHNQYWdlID0gRmlsZU9iamVjdHNQYWdlO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgRmlsZXMge1xuICBleHBvcnQge1xuICAgIHR5cGUgRmlsZUNvbnRlbnQgYXMgRmlsZUNvbnRlbnQsXG4gICAgdHlwZSBGaWxlRGVsZXRlZCBhcyBGaWxlRGVsZXRlZCxcbiAgICB0eXBlIEZpbGVPYmplY3QgYXMgRmlsZU9iamVjdCxcbiAgICB0eXBlIEZpbGVQdXJwb3NlIGFzIEZpbGVQdXJwb3NlLFxuICAgIEZpbGVPYmplY3RzUGFnZSBhcyBGaWxlT2JqZWN0c1BhZ2UsXG4gICAgdHlwZSBGaWxlQ3JlYXRlUGFyYW1zIGFzIEZpbGVDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBGaWxlTGlzdFBhcmFtcyBhcyBGaWxlTGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgeyBDdXJzb3JQYWdlLCB0eXBlIEN1cnNvclBhZ2VQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9wYWdpbmF0aW9uJztcblxuZXhwb3J0IGNsYXNzIENoZWNrcG9pbnRzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogTGlzdCBjaGVja3BvaW50cyBmb3IgYSBmaW5lLXR1bmluZyBqb2IuXG4gICAqL1xuICBsaXN0KFxuICAgIGZpbmVUdW5pbmdKb2JJZDogc3RyaW5nLFxuICAgIHF1ZXJ5PzogQ2hlY2twb2ludExpc3RQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSwgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnQ+O1xuICBsaXN0KFxuICAgIGZpbmVUdW5pbmdKb2JJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UsIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50PjtcbiAgbGlzdChcbiAgICBmaW5lVHVuaW5nSm9iSWQ6IHN0cmluZyxcbiAgICBxdWVyeTogQ2hlY2twb2ludExpc3RQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSwgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnQ+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3QoZmluZVR1bmluZ0pvYklkLCB7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoXG4gICAgICBgL2ZpbmVfdHVuaW5nL2pvYnMvJHtmaW5lVHVuaW5nSm9iSWR9L2NoZWNrcG9pbnRzYCxcbiAgICAgIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UsXG4gICAgICB7IHF1ZXJ5LCAuLi5vcHRpb25zIH0sXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8RmluZVR1bmluZ0pvYkNoZWNrcG9pbnQ+IHt9XG5cbi8qKlxuICogVGhlIGBmaW5lX3R1bmluZy5qb2IuY2hlY2twb2ludGAgb2JqZWN0IHJlcHJlc2VudHMgYSBtb2RlbCBjaGVja3BvaW50IGZvciBhXG4gKiBmaW5lLXR1bmluZyBqb2IgdGhhdCBpcyByZWFkeSB0byB1c2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnQge1xuICAvKipcbiAgICogVGhlIGNoZWNrcG9pbnQgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gdGhlIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBjaGVja3BvaW50IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZmluZS10dW5lZCBjaGVja3BvaW50IG1vZGVsIHRoYXQgaXMgY3JlYXRlZC5cbiAgICovXG4gIGZpbmVfdHVuZWRfbW9kZWxfY2hlY2twb2ludDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZmluZS10dW5pbmcgam9iIHRoYXQgdGhpcyBjaGVja3BvaW50IHdhcyBjcmVhdGVkIGZyb20uXG4gICAqL1xuICBmaW5lX3R1bmluZ19qb2JfaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogTWV0cmljcyBhdCB0aGUgc3RlcCBudW1iZXIgZHVyaW5nIHRoZSBmaW5lLXR1bmluZyBqb2IuXG4gICAqL1xuICBtZXRyaWNzOiBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludC5NZXRyaWNzO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcImZpbmVfdHVuaW5nLmpvYi5jaGVja3BvaW50XCIuXG4gICAqL1xuICBvYmplY3Q6ICdmaW5lX3R1bmluZy5qb2IuY2hlY2twb2ludCc7XG5cbiAgLyoqXG4gICAqIFRoZSBzdGVwIG51bWJlciB0aGF0IHRoZSBjaGVja3BvaW50IHdhcyBjcmVhdGVkIGF0LlxuICAgKi9cbiAgc3RlcF9udW1iZXI6IG51bWJlcjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludCB7XG4gIC8qKlxuICAgKiBNZXRyaWNzIGF0IHRoZSBzdGVwIG51bWJlciBkdXJpbmcgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgTWV0cmljcyB7XG4gICAgZnVsbF92YWxpZF9sb3NzPzogbnVtYmVyO1xuXG4gICAgZnVsbF92YWxpZF9tZWFuX3Rva2VuX2FjY3VyYWN5PzogbnVtYmVyO1xuXG4gICAgc3RlcD86IG51bWJlcjtcblxuICAgIHRyYWluX2xvc3M/OiBudW1iZXI7XG5cbiAgICB0cmFpbl9tZWFuX3Rva2VuX2FjY3VyYWN5PzogbnVtYmVyO1xuXG4gICAgdmFsaWRfbG9zcz86IG51bWJlcjtcblxuICAgIHZhbGlkX21lYW5fdG9rZW5fYWNjdXJhY3k/OiBudW1iZXI7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGVja3BvaW50TGlzdFBhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge31cblxuQ2hlY2twb2ludHMuRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSA9IEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2U7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBDaGVja3BvaW50cyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludCBhcyBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludCxcbiAgICBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlIGFzIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UsXG4gICAgdHlwZSBDaGVja3BvaW50TGlzdFBhcmFtcyBhcyBDaGVja3BvaW50TGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBDaGVja3BvaW50c0FQSSBmcm9tICcuL2NoZWNrcG9pbnRzJztcbmltcG9ydCB7XG4gIENoZWNrcG9pbnRMaXN0UGFyYW1zLFxuICBDaGVja3BvaW50cyxcbiAgRmluZVR1bmluZ0pvYkNoZWNrcG9pbnQsXG4gIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UsXG59IGZyb20gJy4vY2hlY2twb2ludHMnO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSwgdHlwZSBDdXJzb3JQYWdlUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vcGFnaW5hdGlvbic7XG5cbmV4cG9ydCBjbGFzcyBKb2JzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICBjaGVja3BvaW50czogQ2hlY2twb2ludHNBUEkuQ2hlY2twb2ludHMgPSBuZXcgQ2hlY2twb2ludHNBUEkuQ2hlY2twb2ludHModGhpcy5fY2xpZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZpbmUtdHVuaW5nIGpvYiB3aGljaCBiZWdpbnMgdGhlIHByb2Nlc3Mgb2YgY3JlYXRpbmcgYSBuZXcgbW9kZWwgZnJvbVxuICAgKiBhIGdpdmVuIGRhdGFzZXQuXG4gICAqXG4gICAqIFJlc3BvbnNlIGluY2x1ZGVzIGRldGFpbHMgb2YgdGhlIGVucXVldWVkIGpvYiBpbmNsdWRpbmcgam9iIHN0YXR1cyBhbmQgdGhlIG5hbWVcbiAgICogb2YgdGhlIGZpbmUtdHVuZWQgbW9kZWxzIG9uY2UgY29tcGxldGUuXG4gICAqXG4gICAqIFtMZWFybiBtb3JlIGFib3V0IGZpbmUtdHVuaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAqL1xuICBjcmVhdGUoYm9keTogSm9iQ3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxGaW5lVHVuaW5nSm9iPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvZmluZV90dW5pbmcvam9icycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW5mbyBhYm91dCBhIGZpbmUtdHVuaW5nIGpvYi5cbiAgICpcbiAgICogW0xlYXJuIG1vcmUgYWJvdXQgZmluZS10dW5pbmddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9maW5lLXR1bmluZylcbiAgICovXG4gIHJldHJpZXZlKGZpbmVUdW5pbmdKb2JJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxGaW5lVHVuaW5nSm9iPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC9maW5lX3R1bmluZy9qb2JzLyR7ZmluZVR1bmluZ0pvYklkfWAsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgeW91ciBvcmdhbml6YXRpb24ncyBmaW5lLXR1bmluZyBqb2JzXG4gICAqL1xuICBsaXN0KFxuICAgIHF1ZXJ5PzogSm9iTGlzdFBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5QYWdlUHJvbWlzZTxGaW5lVHVuaW5nSm9ic1BhZ2UsIEZpbmVUdW5pbmdKb2I+O1xuICBsaXN0KG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5QYWdlUHJvbWlzZTxGaW5lVHVuaW5nSm9ic1BhZ2UsIEZpbmVUdW5pbmdKb2I+O1xuICBsaXN0KFxuICAgIHF1ZXJ5OiBKb2JMaXN0UGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JzUGFnZSwgRmluZVR1bmluZ0pvYj4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdCh7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy9maW5lX3R1bmluZy9qb2JzJywgRmluZVR1bmluZ0pvYnNQYWdlLCB7IHF1ZXJ5LCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEltbWVkaWF0ZWx5IGNhbmNlbCBhIGZpbmUtdHVuZSBqb2IuXG4gICAqL1xuICBjYW5jZWwoZmluZVR1bmluZ0pvYklkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEZpbmVUdW5pbmdKb2I+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC9maW5lX3R1bmluZy9qb2JzLyR7ZmluZVR1bmluZ0pvYklkfS9jYW5jZWxgLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc3RhdHVzIHVwZGF0ZXMgZm9yIGEgZmluZS10dW5pbmcgam9iLlxuICAgKi9cbiAgbGlzdEV2ZW50cyhcbiAgICBmaW5lVHVuaW5nSm9iSWQ6IHN0cmluZyxcbiAgICBxdWVyeT86IEpvYkxpc3RFdmVudHNQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UsIEZpbmVUdW5pbmdKb2JFdmVudD47XG4gIGxpc3RFdmVudHMoXG4gICAgZmluZVR1bmluZ0pvYklkOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UsIEZpbmVUdW5pbmdKb2JFdmVudD47XG4gIGxpc3RFdmVudHMoXG4gICAgZmluZVR1bmluZ0pvYklkOiBzdHJpbmcsXG4gICAgcXVlcnk6IEpvYkxpc3RFdmVudHNQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UsIEZpbmVUdW5pbmdKb2JFdmVudD4ge1xuICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdEV2ZW50cyhmaW5lVHVuaW5nSm9iSWQsIHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdChgL2ZpbmVfdHVuaW5nL2pvYnMvJHtmaW5lVHVuaW5nSm9iSWR9L2V2ZW50c2AsIEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlLCB7XG4gICAgICBxdWVyeSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZpbmVUdW5pbmdKb2JzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8RmluZVR1bmluZ0pvYj4ge31cblxuZXhwb3J0IGNsYXNzIEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxGaW5lVHVuaW5nSm9iRXZlbnQ+IHt9XG5cbi8qKlxuICogVGhlIGBmaW5lX3R1bmluZy5qb2JgIG9iamVjdCByZXByZXNlbnRzIGEgZmluZS10dW5pbmcgam9iIHRoYXQgaGFzIGJlZW4gY3JlYXRlZFxuICogdGhyb3VnaCB0aGUgQVBJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbmVUdW5pbmdKb2Ige1xuICAvKipcbiAgICogVGhlIG9iamVjdCBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGZpbmUtdHVuaW5nIGpvYiB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogRm9yIGZpbmUtdHVuaW5nIGpvYnMgdGhhdCBoYXZlIGBmYWlsZWRgLCB0aGlzIHdpbGwgY29udGFpbiBtb3JlIGluZm9ybWF0aW9uIG9uXG4gICAqIHRoZSBjYXVzZSBvZiB0aGUgZmFpbHVyZS5cbiAgICovXG4gIGVycm9yOiBGaW5lVHVuaW5nSm9iLkVycm9yIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZpbmUtdHVuZWQgbW9kZWwgdGhhdCBpcyBiZWluZyBjcmVhdGVkLiBUaGUgdmFsdWUgd2lsbCBiZSBudWxsXG4gICAqIGlmIHRoZSBmaW5lLXR1bmluZyBqb2IgaXMgc3RpbGwgcnVubmluZy5cbiAgICovXG4gIGZpbmVfdHVuZWRfbW9kZWw6IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGZpbmUtdHVuaW5nIGpvYiB3YXMgZmluaXNoZWQuIFRoZVxuICAgKiB2YWx1ZSB3aWxsIGJlIG51bGwgaWYgdGhlIGZpbmUtdHVuaW5nIGpvYiBpcyBzdGlsbCBydW5uaW5nLlxuICAgKi9cbiAgZmluaXNoZWRfYXQ6IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi4gVGhpcyB2YWx1ZSB3aWxsIG9ubHkgYmVcbiAgICogcmV0dXJuZWQgd2hlbiBydW5uaW5nIGBzdXBlcnZpc2VkYCBqb2JzLlxuICAgKi9cbiAgaHlwZXJwYXJhbWV0ZXJzOiBGaW5lVHVuaW5nSm9iLkh5cGVycGFyYW1ldGVycztcblxuICAvKipcbiAgICogVGhlIGJhc2UgbW9kZWwgdGhhdCBpcyBiZWluZyBmaW5lLXR1bmVkLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgXCJmaW5lX3R1bmluZy5qb2JcIi5cbiAgICovXG4gIG9iamVjdDogJ2ZpbmVfdHVuaW5nLmpvYic7XG5cbiAgLyoqXG4gICAqIFRoZSBvcmdhbml6YXRpb24gdGhhdCBvd25zIHRoZSBmaW5lLXR1bmluZyBqb2IuXG4gICAqL1xuICBvcmdhbml6YXRpb25faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGNvbXBpbGVkIHJlc3VsdHMgZmlsZSBJRChzKSBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi4gWW91IGNhbiByZXRyaWV2ZSB0aGVcbiAgICogcmVzdWx0cyB3aXRoIHRoZVxuICAgKiBbRmlsZXMgQVBJXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL3JldHJpZXZlLWNvbnRlbnRzKS5cbiAgICovXG4gIHJlc3VsdF9maWxlczogQXJyYXk8c3RyaW5nPjtcblxuICAvKipcbiAgICogVGhlIHNlZWQgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIHNlZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBmaW5lLXR1bmluZyBqb2IsIHdoaWNoIGNhbiBiZSBlaXRoZXJcbiAgICogYHZhbGlkYXRpbmdfZmlsZXNgLCBgcXVldWVkYCwgYHJ1bm5pbmdgLCBgc3VjY2VlZGVkYCwgYGZhaWxlZGAsIG9yIGBjYW5jZWxsZWRgLlxuICAgKi9cbiAgc3RhdHVzOiAndmFsaWRhdGluZ19maWxlcycgfCAncXVldWVkJyB8ICdydW5uaW5nJyB8ICdzdWNjZWVkZWQnIHwgJ2ZhaWxlZCcgfCAnY2FuY2VsbGVkJztcblxuICAvKipcbiAgICogVGhlIHRvdGFsIG51bWJlciBvZiBiaWxsYWJsZSB0b2tlbnMgcHJvY2Vzc2VkIGJ5IHRoaXMgZmluZS10dW5pbmcgam9iLiBUaGUgdmFsdWVcbiAgICogd2lsbCBiZSBudWxsIGlmIHRoZSBmaW5lLXR1bmluZyBqb2IgaXMgc3RpbGwgcnVubmluZy5cbiAgICovXG4gIHRyYWluZWRfdG9rZW5zOiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgZmlsZSBJRCB1c2VkIGZvciB0cmFpbmluZy4gWW91IGNhbiByZXRyaWV2ZSB0aGUgdHJhaW5pbmcgZGF0YSB3aXRoIHRoZVxuICAgKiBbRmlsZXMgQVBJXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL3JldHJpZXZlLWNvbnRlbnRzKS5cbiAgICovXG4gIHRyYWluaW5nX2ZpbGU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGZpbGUgSUQgdXNlZCBmb3IgdmFsaWRhdGlvbi4gWW91IGNhbiByZXRyaWV2ZSB0aGUgdmFsaWRhdGlvbiByZXN1bHRzIHdpdGhcbiAgICogdGhlXG4gICAqIFtGaWxlcyBBUEldKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMvcmV0cmlldmUtY29udGVudHMpLlxuICAgKi9cbiAgdmFsaWRhdGlvbl9maWxlOiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBmaW5lLXR1bmluZyBqb2IgaXMgZXN0aW1hdGVkIHRvXG4gICAqIGZpbmlzaC4gVGhlIHZhbHVlIHdpbGwgYmUgbnVsbCBpZiB0aGUgZmluZS10dW5pbmcgam9iIGlzIG5vdCBydW5uaW5nLlxuICAgKi9cbiAgZXN0aW1hdGVkX2ZpbmlzaD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBpbnRlZ3JhdGlvbnMgdG8gZW5hYmxlIGZvciB0aGlzIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIGludGVncmF0aW9ucz86IEFycmF5PEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uT2JqZWN0PiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgdXNlZCBmb3IgZmluZS10dW5pbmcuXG4gICAqL1xuICBtZXRob2Q/OiBGaW5lVHVuaW5nSm9iLk1ldGhvZDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaW5lVHVuaW5nSm9iIHtcbiAgLyoqXG4gICAqIEZvciBmaW5lLXR1bmluZyBqb2JzIHRoYXQgaGF2ZSBgZmFpbGVkYCwgdGhpcyB3aWxsIGNvbnRhaW4gbW9yZSBpbmZvcm1hdGlvbiBvblxuICAgKiB0aGUgY2F1c2Ugb2YgdGhlIGZhaWx1cmUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBBIG1hY2hpbmUtcmVhZGFibGUgZXJyb3IgY29kZS5cbiAgICAgKi9cbiAgICBjb2RlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgbWVzc2FnZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcmFtZXRlciB0aGF0IHdhcyBpbnZhbGlkLCB1c3VhbGx5IGB0cmFpbmluZ19maWxlYCBvciBgdmFsaWRhdGlvbl9maWxlYC5cbiAgICAgKiBUaGlzIGZpZWxkIHdpbGwgYmUgbnVsbCBpZiB0aGUgZmFpbHVyZSB3YXMgbm90IHBhcmFtZXRlci1zcGVjaWZpYy5cbiAgICAgKi9cbiAgICBwYXJhbTogc3RyaW5nIHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuIFRoaXMgdmFsdWUgd2lsbCBvbmx5IGJlXG4gICAqIHJldHVybmVkIHdoZW4gcnVubmluZyBgc3VwZXJ2aXNlZGAgam9icy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSHlwZXJwYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgZXhhbXBsZXMgaW4gZWFjaCBiYXRjaC4gQSBsYXJnZXIgYmF0Y2ggc2l6ZSBtZWFucyB0aGF0IG1vZGVsXG4gICAgICogcGFyYW1ldGVycyBhcmUgdXBkYXRlZCBsZXNzIGZyZXF1ZW50bHksIGJ1dCB3aXRoIGxvd2VyIHZhcmlhbmNlLlxuICAgICAqL1xuICAgIGJhdGNoX3NpemU/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBTY2FsaW5nIGZhY3RvciBmb3IgdGhlIGxlYXJuaW5nIHJhdGUuIEEgc21hbGxlciBsZWFybmluZyByYXRlIG1heSBiZSB1c2VmdWwgdG9cbiAgICAgKiBhdm9pZCBvdmVyZml0dGluZy5cbiAgICAgKi9cbiAgICBsZWFybmluZ19yYXRlX211bHRpcGxpZXI/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGVwb2NocyB0byB0cmFpbiB0aGUgbW9kZWwgZm9yLiBBbiBlcG9jaCByZWZlcnMgdG8gb25lIGZ1bGwgY3ljbGVcbiAgICAgKiB0aHJvdWdoIHRoZSB0cmFpbmluZyBkYXRhc2V0LlxuICAgICAqL1xuICAgIG5fZXBvY2hzPzogJ2F1dG8nIHwgbnVtYmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgdXNlZCBmb3IgZmluZS10dW5pbmcuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIE1ldGhvZCB7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIERQTyBmaW5lLXR1bmluZyBtZXRob2QuXG4gICAgICovXG4gICAgZHBvPzogTWV0aG9kLkRwbztcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBlcnZpc2VkIGZpbmUtdHVuaW5nIG1ldGhvZC5cbiAgICAgKi9cbiAgICBzdXBlcnZpc2VkPzogTWV0aG9kLlN1cGVydmlzZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBtZXRob2QuIElzIGVpdGhlciBgc3VwZXJ2aXNlZGAgb3IgYGRwb2AuXG4gICAgICovXG4gICAgdHlwZT86ICdzdXBlcnZpc2VkJyB8ICdkcG8nO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBNZXRob2Qge1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBEUE8gZmluZS10dW5pbmcgbWV0aG9kLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgRHBvIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgICAgICovXG4gICAgICBoeXBlcnBhcmFtZXRlcnM/OiBEcG8uSHlwZXJwYXJhbWV0ZXJzO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgRHBvIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgICAgICovXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEh5cGVycGFyYW1ldGVycyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgZXhhbXBsZXMgaW4gZWFjaCBiYXRjaC4gQSBsYXJnZXIgYmF0Y2ggc2l6ZSBtZWFucyB0aGF0IG1vZGVsXG4gICAgICAgICAqIHBhcmFtZXRlcnMgYXJlIHVwZGF0ZWQgbGVzcyBmcmVxdWVudGx5LCBidXQgd2l0aCBsb3dlciB2YXJpYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIGJhdGNoX3NpemU/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiZXRhIHZhbHVlIGZvciB0aGUgRFBPIG1ldGhvZC4gQSBoaWdoZXIgYmV0YSB2YWx1ZSB3aWxsIGluY3JlYXNlIHRoZSB3ZWlnaHRcbiAgICAgICAgICogb2YgdGhlIHBlbmFsdHkgYmV0d2VlbiB0aGUgcG9saWN5IGFuZCByZWZlcmVuY2UgbW9kZWwuXG4gICAgICAgICAqL1xuICAgICAgICBiZXRhPzogJ2F1dG8nIHwgbnVtYmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY2FsaW5nIGZhY3RvciBmb3IgdGhlIGxlYXJuaW5nIHJhdGUuIEEgc21hbGxlciBsZWFybmluZyByYXRlIG1heSBiZSB1c2VmdWwgdG9cbiAgICAgICAgICogYXZvaWQgb3ZlcmZpdHRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBsZWFybmluZ19yYXRlX211bHRpcGxpZXI/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgZXBvY2hzIHRvIHRyYWluIHRoZSBtb2RlbCBmb3IuIEFuIGVwb2NoIHJlZmVycyB0byBvbmUgZnVsbCBjeWNsZVxuICAgICAgICAgKiB0aHJvdWdoIHRoZSB0cmFpbmluZyBkYXRhc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgbl9lcG9jaHM/OiAnYXV0bycgfCBudW1iZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIHN1cGVydmlzZWQgZmluZS10dW5pbmcgbWV0aG9kLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgU3VwZXJ2aXNlZCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICAgICAqL1xuICAgICAgaHlwZXJwYXJhbWV0ZXJzPzogU3VwZXJ2aXNlZC5IeXBlcnBhcmFtZXRlcnM7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBTdXBlcnZpc2VkIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgICAgICovXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEh5cGVycGFyYW1ldGVycyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgZXhhbXBsZXMgaW4gZWFjaCBiYXRjaC4gQSBsYXJnZXIgYmF0Y2ggc2l6ZSBtZWFucyB0aGF0IG1vZGVsXG4gICAgICAgICAqIHBhcmFtZXRlcnMgYXJlIHVwZGF0ZWQgbGVzcyBmcmVxdWVudGx5LCBidXQgd2l0aCBsb3dlciB2YXJpYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIGJhdGNoX3NpemU/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxpbmcgZmFjdG9yIGZvciB0aGUgbGVhcm5pbmcgcmF0ZS4gQSBzbWFsbGVyIGxlYXJuaW5nIHJhdGUgbWF5IGJlIHVzZWZ1bCB0b1xuICAgICAgICAgKiBhdm9pZCBvdmVyZml0dGluZy5cbiAgICAgICAgICovXG4gICAgICAgIGxlYXJuaW5nX3JhdGVfbXVsdGlwbGllcj86ICdhdXRvJyB8IG51bWJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBlcG9jaHMgdG8gdHJhaW4gdGhlIG1vZGVsIGZvci4gQW4gZXBvY2ggcmVmZXJzIHRvIG9uZSBmdWxsIGN5Y2xlXG4gICAgICAgICAqIHRocm91Z2ggdGhlIHRyYWluaW5nIGRhdGFzZXQuXG4gICAgICAgICAqL1xuICAgICAgICBuX2Vwb2Nocz86ICdhdXRvJyB8IG51bWJlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBGaW5lLXR1bmluZyBqb2IgZXZlbnQgb2JqZWN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmluZVR1bmluZ0pvYkV2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgaWRlbnRpZmllci5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGZpbmUtdHVuaW5nIGpvYiB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGxvZyBsZXZlbCBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBsZXZlbDogJ2luZm8nIHwgJ3dhcm4nIHwgJ2Vycm9yJztcblxuICAvKipcbiAgICogVGhlIG1lc3NhZ2Ugb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgbWVzc2FnZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcImZpbmVfdHVuaW5nLmpvYi5ldmVudFwiLlxuICAgKi9cbiAgb2JqZWN0OiAnZmluZV90dW5pbmcuam9iLmV2ZW50JztcblxuICAvKipcbiAgICogVGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cbiAgICovXG4gIGRhdGE/OiB1bmtub3duO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBldmVudC5cbiAgICovXG4gIHR5cGU/OiAnbWVzc2FnZScgfCAnbWV0cmljcyc7XG59XG5cbmV4cG9ydCB0eXBlIEZpbmVUdW5pbmdKb2JJbnRlZ3JhdGlvbiA9IEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uT2JqZWN0O1xuXG4vKipcbiAqIFRoZSBzZXR0aW5ncyBmb3IgeW91ciBpbnRlZ3JhdGlvbiB3aXRoIFdlaWdodHMgYW5kIEJpYXNlcy4gVGhpcyBwYXlsb2FkXG4gKiBzcGVjaWZpZXMgdGhlIHByb2plY3QgdGhhdCBtZXRyaWNzIHdpbGwgYmUgc2VudCB0by4gT3B0aW9uYWxseSwgeW91IGNhbiBzZXQgYW5cbiAqIGV4cGxpY2l0IGRpc3BsYXkgbmFtZSBmb3IgeW91ciBydW4sIGFkZCB0YWdzIHRvIHlvdXIgcnVuLCBhbmQgc2V0IGEgZGVmYXVsdFxuICogZW50aXR5ICh0ZWFtLCB1c2VybmFtZSwgZXRjKSB0byBiZSBhc3NvY2lhdGVkIHdpdGggeW91ciBydW4uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb24ge1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHByb2plY3QgdGhhdCB0aGUgbmV3IHJ1biB3aWxsIGJlIGNyZWF0ZWQgdW5kZXIuXG4gICAqL1xuICBwcm9qZWN0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbnRpdHkgdG8gdXNlIGZvciB0aGUgcnVuLiBUaGlzIGFsbG93cyB5b3UgdG8gc2V0IHRoZSB0ZWFtIG9yIHVzZXJuYW1lIG9mXG4gICAqIHRoZSBXYW5kQiB1c2VyIHRoYXQgeW91IHdvdWxkIGxpa2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBydW4uIElmIG5vdCBzZXQsIHRoZVxuICAgKiBkZWZhdWx0IGVudGl0eSBmb3IgdGhlIHJlZ2lzdGVyZWQgV2FuZEIgQVBJIGtleSBpcyB1c2VkLlxuICAgKi9cbiAgZW50aXR5Pzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogQSBkaXNwbGF5IG5hbWUgdG8gc2V0IGZvciB0aGUgcnVuLiBJZiBub3Qgc2V0LCB3ZSB3aWxsIHVzZSB0aGUgSm9iIElEIGFzIHRoZVxuICAgKiBuYW1lLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0YWdzIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBuZXdseSBjcmVhdGVkIHJ1bi4gVGhlc2UgdGFncyBhcmUgcGFzc2VkXG4gICAqIHRocm91Z2ggZGlyZWN0bHkgdG8gV2FuZEIuIFNvbWUgZGVmYXVsdCB0YWdzIGFyZSBnZW5lcmF0ZWQgYnkgT3BlbkFJOlxuICAgKiBcIm9wZW5haS9maW5ldHVuZVwiLCBcIm9wZW5haS97YmFzZS1tb2RlbH1cIiwgXCJvcGVuYWkve2Z0am9iLWFiY2RlZn1cIi5cbiAgICovXG4gIHRhZ3M/OiBBcnJheTxzdHJpbmc+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uT2JqZWN0IHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBpbnRlZ3JhdGlvbiBiZWluZyBlbmFibGVkIGZvciB0aGUgZmluZS10dW5pbmcgam9iXG4gICAqL1xuICB0eXBlOiAnd2FuZGInO1xuXG4gIC8qKlxuICAgKiBUaGUgc2V0dGluZ3MgZm9yIHlvdXIgaW50ZWdyYXRpb24gd2l0aCBXZWlnaHRzIGFuZCBCaWFzZXMuIFRoaXMgcGF5bG9hZFxuICAgKiBzcGVjaWZpZXMgdGhlIHByb2plY3QgdGhhdCBtZXRyaWNzIHdpbGwgYmUgc2VudCB0by4gT3B0aW9uYWxseSwgeW91IGNhbiBzZXQgYW5cbiAgICogZXhwbGljaXQgZGlzcGxheSBuYW1lIGZvciB5b3VyIHJ1biwgYWRkIHRhZ3MgdG8geW91ciBydW4sIGFuZCBzZXQgYSBkZWZhdWx0XG4gICAqIGVudGl0eSAodGVhbSwgdXNlcm5hbWUsIGV0YykgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHlvdXIgcnVuLlxuICAgKi9cbiAgd2FuZGI6IEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEpvYkNyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgbW9kZWwgdG8gZmluZS10dW5lLiBZb3UgY2FuIHNlbGVjdCBvbmUgb2YgdGhlXG4gICAqIFtzdXBwb3J0ZWQgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcjd2hpY2gtbW9kZWxzLWNhbi1iZS1maW5lLXR1bmVkKS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgJ2JhYmJhZ2UtMDAyJyB8ICdkYXZpbmNpLTAwMicgfCAnZ3B0LTMuNS10dXJibycgfCAnZ3B0LTRvLW1pbmknO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgYW4gdXBsb2FkZWQgZmlsZSB0aGF0IGNvbnRhaW5zIHRyYWluaW5nIGRhdGEuXG4gICAqXG4gICAqIFNlZSBbdXBsb2FkIGZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMvY3JlYXRlKVxuICAgKiBmb3IgaG93IHRvIHVwbG9hZCBhIGZpbGUuXG4gICAqXG4gICAqIFlvdXIgZGF0YXNldCBtdXN0IGJlIGZvcm1hdHRlZCBhcyBhIEpTT05MIGZpbGUuIEFkZGl0aW9uYWxseSwgeW91IG11c3QgdXBsb2FkXG4gICAqIHlvdXIgZmlsZSB3aXRoIHRoZSBwdXJwb3NlIGBmaW5lLXR1bmVgLlxuICAgKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGZpbGUgc2hvdWxkIGRpZmZlciBkZXBlbmRpbmcgb24gaWYgdGhlIG1vZGVsIHVzZXMgdGhlXG4gICAqIFtjaGF0XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuaW5nL2NoYXQtaW5wdXQpLFxuICAgKiBbY29tcGxldGlvbnNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmluZS10dW5pbmcvY29tcGxldGlvbnMtaW5wdXQpXG4gICAqIGZvcm1hdCwgb3IgaWYgdGhlIGZpbmUtdHVuaW5nIG1ldGhvZCB1c2VzIHRoZVxuICAgKiBbcHJlZmVyZW5jZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maW5lLXR1bmluZy9wcmVmZXJlbmNlLWlucHV0KVxuICAgKiBmb3JtYXQuXG4gICAqXG4gICAqIFNlZSB0aGUgW2ZpbmUtdHVuaW5nIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICB0cmFpbmluZ19maWxlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi4gVGhpcyB2YWx1ZSBpcyBub3cgZGVwcmVjYXRlZFxuICAgKiBpbiBmYXZvciBvZiBgbWV0aG9kYCwgYW5kIHNob3VsZCBiZSBwYXNzZWQgaW4gdW5kZXIgdGhlIGBtZXRob2RgIHBhcmFtZXRlci5cbiAgICovXG4gIGh5cGVycGFyYW1ldGVycz86IEpvYkNyZWF0ZVBhcmFtcy5IeXBlcnBhcmFtZXRlcnM7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBpbnRlZ3JhdGlvbnMgdG8gZW5hYmxlIGZvciB5b3VyIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIGludGVncmF0aW9ucz86IEFycmF5PEpvYkNyZWF0ZVBhcmFtcy5JbnRlZ3JhdGlvbj4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWV0aG9kIHVzZWQgZm9yIGZpbmUtdHVuaW5nLlxuICAgKi9cbiAgbWV0aG9kPzogSm9iQ3JlYXRlUGFyYW1zLk1ldGhvZDtcblxuICAvKipcbiAgICogVGhlIHNlZWQgY29udHJvbHMgdGhlIHJlcHJvZHVjaWJpbGl0eSBvZiB0aGUgam9iLiBQYXNzaW5nIGluIHRoZSBzYW1lIHNlZWQgYW5kXG4gICAqIGpvYiBwYXJhbWV0ZXJzIHNob3VsZCBwcm9kdWNlIHRoZSBzYW1lIHJlc3VsdHMsIGJ1dCBtYXkgZGlmZmVyIGluIHJhcmUgY2FzZXMuIElmXG4gICAqIGEgc2VlZCBpcyBub3Qgc3BlY2lmaWVkLCBvbmUgd2lsbCBiZSBnZW5lcmF0ZWQgZm9yIHlvdS5cbiAgICovXG4gIHNlZWQ/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHN0cmluZyBvZiB1cCB0byA2NCBjaGFyYWN0ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB5b3VyIGZpbmUtdHVuZWQgbW9kZWxcbiAgICogbmFtZS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGEgYHN1ZmZpeGAgb2YgXCJjdXN0b20tbW9kZWwtbmFtZVwiIHdvdWxkIHByb2R1Y2UgYSBtb2RlbCBuYW1lIGxpa2VcbiAgICogYGZ0OmdwdC00by1taW5pOm9wZW5haTpjdXN0b20tbW9kZWwtbmFtZTo3cDRsVVJlbGAuXG4gICAqL1xuICBzdWZmaXg/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgYW4gdXBsb2FkZWQgZmlsZSB0aGF0IGNvbnRhaW5zIHZhbGlkYXRpb24gZGF0YS5cbiAgICpcbiAgICogSWYgeW91IHByb3ZpZGUgdGhpcyBmaWxlLCB0aGUgZGF0YSBpcyB1c2VkIHRvIGdlbmVyYXRlIHZhbGlkYXRpb24gbWV0cmljc1xuICAgKiBwZXJpb2RpY2FsbHkgZHVyaW5nIGZpbmUtdHVuaW5nLiBUaGVzZSBtZXRyaWNzIGNhbiBiZSB2aWV3ZWQgaW4gdGhlIGZpbmUtdHVuaW5nXG4gICAqIHJlc3VsdHMgZmlsZS4gVGhlIHNhbWUgZGF0YSBzaG91bGQgbm90IGJlIHByZXNlbnQgaW4gYm90aCB0cmFpbiBhbmQgdmFsaWRhdGlvblxuICAgKiBmaWxlcy5cbiAgICpcbiAgICogWW91ciBkYXRhc2V0IG11c3QgYmUgZm9ybWF0dGVkIGFzIGEgSlNPTkwgZmlsZS4gWW91IG11c3QgdXBsb2FkIHlvdXIgZmlsZSB3aXRoXG4gICAqIHRoZSBwdXJwb3NlIGBmaW5lLXR1bmVgLlxuICAgKlxuICAgKiBTZWUgdGhlIFtmaW5lLXR1bmluZyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2ZpbmUtdHVuaW5nKVxuICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgdmFsaWRhdGlvbl9maWxlPzogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBKb2JDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQ6IFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi4gVGhpcyB2YWx1ZSBpcyBub3dcbiAgICogZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBgbWV0aG9kYCwgYW5kIHNob3VsZCBiZSBwYXNzZWQgaW4gdW5kZXIgdGhlIGBtZXRob2RgXG4gICAqIHBhcmFtZXRlci5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSHlwZXJwYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgZXhhbXBsZXMgaW4gZWFjaCBiYXRjaC4gQSBsYXJnZXIgYmF0Y2ggc2l6ZSBtZWFucyB0aGF0IG1vZGVsXG4gICAgICogcGFyYW1ldGVycyBhcmUgdXBkYXRlZCBsZXNzIGZyZXF1ZW50bHksIGJ1dCB3aXRoIGxvd2VyIHZhcmlhbmNlLlxuICAgICAqL1xuICAgIGJhdGNoX3NpemU/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBTY2FsaW5nIGZhY3RvciBmb3IgdGhlIGxlYXJuaW5nIHJhdGUuIEEgc21hbGxlciBsZWFybmluZyByYXRlIG1heSBiZSB1c2VmdWwgdG9cbiAgICAgKiBhdm9pZCBvdmVyZml0dGluZy5cbiAgICAgKi9cbiAgICBsZWFybmluZ19yYXRlX211bHRpcGxpZXI/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGVwb2NocyB0byB0cmFpbiB0aGUgbW9kZWwgZm9yLiBBbiBlcG9jaCByZWZlcnMgdG8gb25lIGZ1bGwgY3ljbGVcbiAgICAgKiB0aHJvdWdoIHRoZSB0cmFpbmluZyBkYXRhc2V0LlxuICAgICAqL1xuICAgIG5fZXBvY2hzPzogJ2F1dG8nIHwgbnVtYmVyO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBJbnRlZ3JhdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgaW50ZWdyYXRpb24gdG8gZW5hYmxlLiBDdXJyZW50bHksIG9ubHkgXCJ3YW5kYlwiIChXZWlnaHRzIGFuZCBCaWFzZXMpXG4gICAgICogaXMgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIHR5cGU6ICd3YW5kYic7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2V0dGluZ3MgZm9yIHlvdXIgaW50ZWdyYXRpb24gd2l0aCBXZWlnaHRzIGFuZCBCaWFzZXMuIFRoaXMgcGF5bG9hZFxuICAgICAqIHNwZWNpZmllcyB0aGUgcHJvamVjdCB0aGF0IG1ldHJpY3Mgd2lsbCBiZSBzZW50IHRvLiBPcHRpb25hbGx5LCB5b3UgY2FuIHNldCBhblxuICAgICAqIGV4cGxpY2l0IGRpc3BsYXkgbmFtZSBmb3IgeW91ciBydW4sIGFkZCB0YWdzIHRvIHlvdXIgcnVuLCBhbmQgc2V0IGEgZGVmYXVsdFxuICAgICAqIGVudGl0eSAodGVhbSwgdXNlcm5hbWUsIGV0YykgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHlvdXIgcnVuLlxuICAgICAqL1xuICAgIHdhbmRiOiBJbnRlZ3JhdGlvbi5XYW5kYjtcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgSW50ZWdyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXR0aW5ncyBmb3IgeW91ciBpbnRlZ3JhdGlvbiB3aXRoIFdlaWdodHMgYW5kIEJpYXNlcy4gVGhpcyBwYXlsb2FkXG4gICAgICogc3BlY2lmaWVzIHRoZSBwcm9qZWN0IHRoYXQgbWV0cmljcyB3aWxsIGJlIHNlbnQgdG8uIE9wdGlvbmFsbHksIHlvdSBjYW4gc2V0IGFuXG4gICAgICogZXhwbGljaXQgZGlzcGxheSBuYW1lIGZvciB5b3VyIHJ1biwgYWRkIHRhZ3MgdG8geW91ciBydW4sIGFuZCBzZXQgYSBkZWZhdWx0XG4gICAgICogZW50aXR5ICh0ZWFtLCB1c2VybmFtZSwgZXRjKSB0byBiZSBhc3NvY2lhdGVkIHdpdGggeW91ciBydW4uXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBXYW5kYiB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9qZWN0IHRoYXQgdGhlIG5ldyBydW4gd2lsbCBiZSBjcmVhdGVkIHVuZGVyLlxuICAgICAgICovXG4gICAgICBwcm9qZWN0OiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGVudGl0eSB0byB1c2UgZm9yIHRoZSBydW4uIFRoaXMgYWxsb3dzIHlvdSB0byBzZXQgdGhlIHRlYW0gb3IgdXNlcm5hbWUgb2ZcbiAgICAgICAqIHRoZSBXYW5kQiB1c2VyIHRoYXQgeW91IHdvdWxkIGxpa2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBydW4uIElmIG5vdCBzZXQsIHRoZVxuICAgICAgICogZGVmYXVsdCBlbnRpdHkgZm9yIHRoZSByZWdpc3RlcmVkIFdhbmRCIEFQSSBrZXkgaXMgdXNlZC5cbiAgICAgICAqL1xuICAgICAgZW50aXR5Pzogc3RyaW5nIHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGRpc3BsYXkgbmFtZSB0byBzZXQgZm9yIHRoZSBydW4uIElmIG5vdCBzZXQsIHdlIHdpbGwgdXNlIHRoZSBKb2IgSUQgYXMgdGhlXG4gICAgICAgKiBuYW1lLlxuICAgICAgICovXG4gICAgICBuYW1lPzogc3RyaW5nIHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGxpc3Qgb2YgdGFncyB0byBiZSBhdHRhY2hlZCB0byB0aGUgbmV3bHkgY3JlYXRlZCBydW4uIFRoZXNlIHRhZ3MgYXJlIHBhc3NlZFxuICAgICAgICogdGhyb3VnaCBkaXJlY3RseSB0byBXYW5kQi4gU29tZSBkZWZhdWx0IHRhZ3MgYXJlIGdlbmVyYXRlZCBieSBPcGVuQUk6XG4gICAgICAgKiBcIm9wZW5haS9maW5ldHVuZVwiLCBcIm9wZW5haS97YmFzZS1tb2RlbH1cIiwgXCJvcGVuYWkve2Z0am9iLWFiY2RlZn1cIi5cbiAgICAgICAqL1xuICAgICAgdGFncz86IEFycmF5PHN0cmluZz47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgdXNlZCBmb3IgZmluZS10dW5pbmcuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIE1ldGhvZCB7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIERQTyBmaW5lLXR1bmluZyBtZXRob2QuXG4gICAgICovXG4gICAgZHBvPzogTWV0aG9kLkRwbztcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBlcnZpc2VkIGZpbmUtdHVuaW5nIG1ldGhvZC5cbiAgICAgKi9cbiAgICBzdXBlcnZpc2VkPzogTWV0aG9kLlN1cGVydmlzZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBtZXRob2QuIElzIGVpdGhlciBgc3VwZXJ2aXNlZGAgb3IgYGRwb2AuXG4gICAgICovXG4gICAgdHlwZT86ICdzdXBlcnZpc2VkJyB8ICdkcG8nO1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBNZXRob2Qge1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBEUE8gZmluZS10dW5pbmcgbWV0aG9kLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgRHBvIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgICAgICovXG4gICAgICBoeXBlcnBhcmFtZXRlcnM/OiBEcG8uSHlwZXJwYXJhbWV0ZXJzO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgRHBvIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgICAgICovXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEh5cGVycGFyYW1ldGVycyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgZXhhbXBsZXMgaW4gZWFjaCBiYXRjaC4gQSBsYXJnZXIgYmF0Y2ggc2l6ZSBtZWFucyB0aGF0IG1vZGVsXG4gICAgICAgICAqIHBhcmFtZXRlcnMgYXJlIHVwZGF0ZWQgbGVzcyBmcmVxdWVudGx5LCBidXQgd2l0aCBsb3dlciB2YXJpYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIGJhdGNoX3NpemU/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiZXRhIHZhbHVlIGZvciB0aGUgRFBPIG1ldGhvZC4gQSBoaWdoZXIgYmV0YSB2YWx1ZSB3aWxsIGluY3JlYXNlIHRoZSB3ZWlnaHRcbiAgICAgICAgICogb2YgdGhlIHBlbmFsdHkgYmV0d2VlbiB0aGUgcG9saWN5IGFuZCByZWZlcmVuY2UgbW9kZWwuXG4gICAgICAgICAqL1xuICAgICAgICBiZXRhPzogJ2F1dG8nIHwgbnVtYmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY2FsaW5nIGZhY3RvciBmb3IgdGhlIGxlYXJuaW5nIHJhdGUuIEEgc21hbGxlciBsZWFybmluZyByYXRlIG1heSBiZSB1c2VmdWwgdG9cbiAgICAgICAgICogYXZvaWQgb3ZlcmZpdHRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBsZWFybmluZ19yYXRlX211bHRpcGxpZXI/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgZXBvY2hzIHRvIHRyYWluIHRoZSBtb2RlbCBmb3IuIEFuIGVwb2NoIHJlZmVycyB0byBvbmUgZnVsbCBjeWNsZVxuICAgICAgICAgKiB0aHJvdWdoIHRoZSB0cmFpbmluZyBkYXRhc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgbl9lcG9jaHM/OiAnYXV0bycgfCBudW1iZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIHN1cGVydmlzZWQgZmluZS10dW5pbmcgbWV0aG9kLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgU3VwZXJ2aXNlZCB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICAgICAqL1xuICAgICAgaHlwZXJwYXJhbWV0ZXJzPzogU3VwZXJ2aXNlZC5IeXBlcnBhcmFtZXRlcnM7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBTdXBlcnZpc2VkIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLlxuICAgICAgICovXG4gICAgICBleHBvcnQgaW50ZXJmYWNlIEh5cGVycGFyYW1ldGVycyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgZXhhbXBsZXMgaW4gZWFjaCBiYXRjaC4gQSBsYXJnZXIgYmF0Y2ggc2l6ZSBtZWFucyB0aGF0IG1vZGVsXG4gICAgICAgICAqIHBhcmFtZXRlcnMgYXJlIHVwZGF0ZWQgbGVzcyBmcmVxdWVudGx5LCBidXQgd2l0aCBsb3dlciB2YXJpYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIGJhdGNoX3NpemU/OiAnYXV0bycgfCBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxpbmcgZmFjdG9yIGZvciB0aGUgbGVhcm5pbmcgcmF0ZS4gQSBzbWFsbGVyIGxlYXJuaW5nIHJhdGUgbWF5IGJlIHVzZWZ1bCB0b1xuICAgICAgICAgKiBhdm9pZCBvdmVyZml0dGluZy5cbiAgICAgICAgICovXG4gICAgICAgIGxlYXJuaW5nX3JhdGVfbXVsdGlwbGllcj86ICdhdXRvJyB8IG51bWJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBlcG9jaHMgdG8gdHJhaW4gdGhlIG1vZGVsIGZvci4gQW4gZXBvY2ggcmVmZXJzIHRvIG9uZSBmdWxsIGN5Y2xlXG4gICAgICAgICAqIHRocm91Z2ggdGhlIHRyYWluaW5nIGRhdGFzZXQuXG4gICAgICAgICAqL1xuICAgICAgICBuX2Vwb2Nocz86ICdhdXRvJyB8IG51bWJlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBKb2JMaXN0UGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIEpvYkxpc3RFdmVudHNQYXJhbXMgZXh0ZW5kcyBDdXJzb3JQYWdlUGFyYW1zIHt9XG5cbkpvYnMuRmluZVR1bmluZ0pvYnNQYWdlID0gRmluZVR1bmluZ0pvYnNQYWdlO1xuSm9icy5GaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSA9IEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlO1xuSm9icy5DaGVja3BvaW50cyA9IENoZWNrcG9pbnRzO1xuSm9icy5GaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlID0gRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEpvYnMge1xuICBleHBvcnQge1xuICAgIHR5cGUgRmluZVR1bmluZ0pvYiBhcyBGaW5lVHVuaW5nSm9iLFxuICAgIHR5cGUgRmluZVR1bmluZ0pvYkV2ZW50IGFzIEZpbmVUdW5pbmdKb2JFdmVudCxcbiAgICB0eXBlIEZpbmVUdW5pbmdKb2JJbnRlZ3JhdGlvbiBhcyBGaW5lVHVuaW5nSm9iSW50ZWdyYXRpb24sXG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbiBhcyBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbixcbiAgICB0eXBlIEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uT2JqZWN0IGFzIEZpbmVUdW5pbmdKb2JXYW5kYkludGVncmF0aW9uT2JqZWN0LFxuICAgIEZpbmVUdW5pbmdKb2JzUGFnZSBhcyBGaW5lVHVuaW5nSm9ic1BhZ2UsXG4gICAgRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UgYXMgRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UsXG4gICAgdHlwZSBKb2JDcmVhdGVQYXJhbXMgYXMgSm9iQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgSm9iTGlzdFBhcmFtcyBhcyBKb2JMaXN0UGFyYW1zLFxuICAgIHR5cGUgSm9iTGlzdEV2ZW50c1BhcmFtcyBhcyBKb2JMaXN0RXZlbnRzUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgQ2hlY2twb2ludHMgYXMgQ2hlY2twb2ludHMsXG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludCBhcyBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludCxcbiAgICBGaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlIGFzIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UsXG4gICAgdHlwZSBDaGVja3BvaW50TGlzdFBhcmFtcyBhcyBDaGVja3BvaW50TGlzdFBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIEpvYnNBUEkgZnJvbSAnLi9qb2JzL2pvYnMnO1xuaW1wb3J0IHtcbiAgRmluZVR1bmluZ0pvYixcbiAgRmluZVR1bmluZ0pvYkV2ZW50LFxuICBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSxcbiAgRmluZVR1bmluZ0pvYkludGVncmF0aW9uLFxuICBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbixcbiAgRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb25PYmplY3QsXG4gIEZpbmVUdW5pbmdKb2JzUGFnZSxcbiAgSm9iQ3JlYXRlUGFyYW1zLFxuICBKb2JMaXN0RXZlbnRzUGFyYW1zLFxuICBKb2JMaXN0UGFyYW1zLFxuICBKb2JzLFxufSBmcm9tICcuL2pvYnMvam9icyc7XG5cbmV4cG9ydCBjbGFzcyBGaW5lVHVuaW5nIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICBqb2JzOiBKb2JzQVBJLkpvYnMgPSBuZXcgSm9ic0FQSS5Kb2JzKHRoaXMuX2NsaWVudCk7XG59XG5cbkZpbmVUdW5pbmcuSm9icyA9IEpvYnM7XG5GaW5lVHVuaW5nLkZpbmVUdW5pbmdKb2JzUGFnZSA9IEZpbmVUdW5pbmdKb2JzUGFnZTtcbkZpbmVUdW5pbmcuRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UgPSBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEZpbmVUdW5pbmcge1xuICBleHBvcnQge1xuICAgIEpvYnMgYXMgSm9icyxcbiAgICB0eXBlIEZpbmVUdW5pbmdKb2IgYXMgRmluZVR1bmluZ0pvYixcbiAgICB0eXBlIEZpbmVUdW5pbmdKb2JFdmVudCBhcyBGaW5lVHVuaW5nSm9iRXZlbnQsXG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iSW50ZWdyYXRpb24gYXMgRmluZVR1bmluZ0pvYkludGVncmF0aW9uLFxuICAgIHR5cGUgRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb24gYXMgRmluZVR1bmluZ0pvYldhbmRiSW50ZWdyYXRpb24sXG4gICAgdHlwZSBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbk9iamVjdCBhcyBGaW5lVHVuaW5nSm9iV2FuZGJJbnRlZ3JhdGlvbk9iamVjdCxcbiAgICBGaW5lVHVuaW5nSm9ic1BhZ2UgYXMgRmluZVR1bmluZ0pvYnNQYWdlLFxuICAgIEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlIGFzIEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlLFxuICAgIHR5cGUgSm9iQ3JlYXRlUGFyYW1zIGFzIEpvYkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIEpvYkxpc3RQYXJhbXMgYXMgSm9iTGlzdFBhcmFtcyxcbiAgICB0eXBlIEpvYkxpc3RFdmVudHNQYXJhbXMgYXMgSm9iTGlzdEV2ZW50c1BhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vY29yZSc7XG5cbmV4cG9ydCBjbGFzcyBJbWFnZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdmFyaWF0aW9uIG9mIGEgZ2l2ZW4gaW1hZ2UuXG4gICAqL1xuICBjcmVhdGVWYXJpYXRpb24oXG4gICAgYm9keTogSW1hZ2VDcmVhdGVWYXJpYXRpb25QYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxJbWFnZXNSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2ltYWdlcy92YXJpYXRpb25zJywgQ29yZS5tdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGVkaXRlZCBvciBleHRlbmRlZCBpbWFnZSBnaXZlbiBhbiBvcmlnaW5hbCBpbWFnZSBhbmQgYSBwcm9tcHQuXG4gICAqL1xuICBlZGl0KGJvZHk6IEltYWdlRWRpdFBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8SW1hZ2VzUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9pbWFnZXMvZWRpdHMnLCBDb3JlLm11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyh7IGJvZHksIC4uLm9wdGlvbnMgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW1hZ2UgZ2l2ZW4gYSBwcm9tcHQuXG4gICAqL1xuICBnZW5lcmF0ZShib2R5OiBJbWFnZUdlbmVyYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxJbWFnZXNSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2ltYWdlcy9nZW5lcmF0aW9ucycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHVybCBvciB0aGUgY29udGVudCBvZiBhbiBpbWFnZSBnZW5lcmF0ZWQgYnkgdGhlIE9wZW5BSSBBUEkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2Uge1xuICAvKipcbiAgICogVGhlIGJhc2U2NC1lbmNvZGVkIEpTT04gb2YgdGhlIGdlbmVyYXRlZCBpbWFnZSwgaWYgYHJlc3BvbnNlX2Zvcm1hdGAgaXNcbiAgICogYGI2NF9qc29uYC5cbiAgICovXG4gIGI2NF9qc29uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcHJvbXB0IHRoYXQgd2FzIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGltYWdlLCBpZiB0aGVyZSB3YXMgYW55IHJldmlzaW9uIHRvIHRoZVxuICAgKiBwcm9tcHQuXG4gICAqL1xuICByZXZpc2VkX3Byb21wdD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVSTCBvZiB0aGUgZ2VuZXJhdGVkIGltYWdlLCBpZiBgcmVzcG9uc2VfZm9ybWF0YCBpcyBgdXJsYCAoZGVmYXVsdCkuXG4gICAqL1xuICB1cmw/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIEltYWdlTW9kZWwgPSAnZGFsbC1lLTInIHwgJ2RhbGwtZS0zJztcblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZXNSZXNwb25zZSB7XG4gIGNyZWF0ZWQ6IG51bWJlcjtcblxuICBkYXRhOiBBcnJheTxJbWFnZT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VDcmVhdGVWYXJpYXRpb25QYXJhbXMge1xuICAvKipcbiAgICogVGhlIGltYWdlIHRvIHVzZSBhcyB0aGUgYmFzaXMgZm9yIHRoZSB2YXJpYXRpb24ocykuIE11c3QgYmUgYSB2YWxpZCBQTkcgZmlsZSxcbiAgICogbGVzcyB0aGFuIDRNQiwgYW5kIHNxdWFyZS5cbiAgICovXG4gIGltYWdlOiBDb3JlLlVwbG9hZGFibGU7XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlbCB0byB1c2UgZm9yIGltYWdlIGdlbmVyYXRpb24uIE9ubHkgYGRhbGwtZS0yYCBpcyBzdXBwb3J0ZWQgYXQgdGhpc1xuICAgKiB0aW1lLlxuICAgKi9cbiAgbW9kZWw/OiAoc3RyaW5nICYge30pIHwgSW1hZ2VNb2RlbCB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgaW1hZ2VzIHRvIGdlbmVyYXRlLiBNdXN0IGJlIGJldHdlZW4gMSBhbmQgMTAuIEZvciBgZGFsbC1lLTNgLCBvbmx5XG4gICAqIGBuPTFgIGlzIHN1cHBvcnRlZC5cbiAgICovXG4gIG4/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IGluIHdoaWNoIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzIGFyZSByZXR1cm5lZC4gTXVzdCBiZSBvbmUgb2YgYHVybGAgb3JcbiAgICogYGI2NF9qc29uYC4gVVJMcyBhcmUgb25seSB2YWxpZCBmb3IgNjAgbWludXRlcyBhZnRlciB0aGUgaW1hZ2UgaGFzIGJlZW5cbiAgICogZ2VuZXJhdGVkLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogJ3VybCcgfCAnYjY0X2pzb24nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIGdlbmVyYXRlZCBpbWFnZXMuIE11c3QgYmUgb25lIG9mIGAyNTZ4MjU2YCwgYDUxMng1MTJgLCBvclxuICAgKiBgMTAyNHgxMDI0YC5cbiAgICovXG4gIHNpemU/OiAnMjU2eDI1NicgfCAnNTEyeDUxMicgfCAnMTAyNHgxMDI0JyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgcmVwcmVzZW50aW5nIHlvdXIgZW5kLXVzZXIsIHdoaWNoIGNhbiBoZWxwIE9wZW5BSSB0byBtb25pdG9yXG4gICAqIGFuZCBkZXRlY3QgYWJ1c2UuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc2FmZXR5LWJlc3QtcHJhY3RpY2VzI2VuZC11c2VyLWlkcykuXG4gICAqL1xuICB1c2VyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlRWRpdFBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgaW1hZ2UgdG8gZWRpdC4gTXVzdCBiZSBhIHZhbGlkIFBORyBmaWxlLCBsZXNzIHRoYW4gNE1CLCBhbmQgc3F1YXJlLiBJZiBtYXNrXG4gICAqIGlzIG5vdCBwcm92aWRlZCwgaW1hZ2UgbXVzdCBoYXZlIHRyYW5zcGFyZW5jeSwgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIHRoZSBtYXNrLlxuICAgKi9cbiAgaW1hZ2U6IENvcmUuVXBsb2FkYWJsZTtcblxuICAvKipcbiAgICogQSB0ZXh0IGRlc2NyaXB0aW9uIG9mIHRoZSBkZXNpcmVkIGltYWdlKHMpLiBUaGUgbWF4aW11bSBsZW5ndGggaXMgMTAwMFxuICAgKiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgcHJvbXB0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFuIGFkZGl0aW9uYWwgaW1hZ2Ugd2hvc2UgZnVsbHkgdHJhbnNwYXJlbnQgYXJlYXMgKGUuZy4gd2hlcmUgYWxwaGEgaXMgemVybylcbiAgICogaW5kaWNhdGUgd2hlcmUgYGltYWdlYCBzaG91bGQgYmUgZWRpdGVkLiBNdXN0IGJlIGEgdmFsaWQgUE5HIGZpbGUsIGxlc3MgdGhhblxuICAgKiA0TUIsIGFuZCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMgYXMgYGltYWdlYC5cbiAgICovXG4gIG1hc2s/OiBDb3JlLlVwbG9hZGFibGU7XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlbCB0byB1c2UgZm9yIGltYWdlIGdlbmVyYXRpb24uIE9ubHkgYGRhbGwtZS0yYCBpcyBzdXBwb3J0ZWQgYXQgdGhpc1xuICAgKiB0aW1lLlxuICAgKi9cbiAgbW9kZWw/OiAoc3RyaW5nICYge30pIHwgSW1hZ2VNb2RlbCB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgaW1hZ2VzIHRvIGdlbmVyYXRlLiBNdXN0IGJlIGJldHdlZW4gMSBhbmQgMTAuXG4gICAqL1xuICBuPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCBpbiB3aGljaCB0aGUgZ2VuZXJhdGVkIGltYWdlcyBhcmUgcmV0dXJuZWQuIE11c3QgYmUgb25lIG9mIGB1cmxgIG9yXG4gICAqIGBiNjRfanNvbmAuIFVSTHMgYXJlIG9ubHkgdmFsaWQgZm9yIDYwIG1pbnV0ZXMgYWZ0ZXIgdGhlIGltYWdlIGhhcyBiZWVuXG4gICAqIGdlbmVyYXRlZC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86ICd1cmwnIHwgJ2I2NF9qc29uJyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBNdXN0IGJlIG9uZSBvZiBgMjU2eDI1NmAsIGA1MTJ4NTEyYCwgb3JcbiAgICogYDEwMjR4MTAyNGAuXG4gICAqL1xuICBzaXplPzogJzI1NngyNTYnIHwgJzUxMng1MTInIHwgJzEwMjR4MTAyNCcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIHJlcHJlc2VudGluZyB5b3VyIGVuZC11c2VyLCB3aGljaCBjYW4gaGVscCBPcGVuQUkgdG8gbW9uaXRvclxuICAgKiBhbmQgZGV0ZWN0IGFidXNlLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3NhZmV0eS1iZXN0LXByYWN0aWNlcyNlbmQtdXNlci1pZHMpLlxuICAgKi9cbiAgdXNlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZUdlbmVyYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIEEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgZGVzaXJlZCBpbWFnZShzKS4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDEwMDBcbiAgICogY2hhcmFjdGVycyBmb3IgYGRhbGwtZS0yYCBhbmQgNDAwMCBjaGFyYWN0ZXJzIGZvciBgZGFsbC1lLTNgLlxuICAgKi9cbiAgcHJvbXB0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlbCB0byB1c2UgZm9yIGltYWdlIGdlbmVyYXRpb24uXG4gICAqL1xuICBtb2RlbD86IChzdHJpbmcgJiB7fSkgfCBJbWFnZU1vZGVsIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBpbWFnZXMgdG8gZ2VuZXJhdGUuIE11c3QgYmUgYmV0d2VlbiAxIGFuZCAxMC4gRm9yIGBkYWxsLWUtM2AsIG9ubHlcbiAgICogYG49MWAgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgbj86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBxdWFsaXR5IG9mIHRoZSBpbWFnZSB0aGF0IHdpbGwgYmUgZ2VuZXJhdGVkLiBgaGRgIGNyZWF0ZXMgaW1hZ2VzIHdpdGggZmluZXJcbiAgICogZGV0YWlscyBhbmQgZ3JlYXRlciBjb25zaXN0ZW5jeSBhY3Jvc3MgdGhlIGltYWdlLiBUaGlzIHBhcmFtIGlzIG9ubHkgc3VwcG9ydGVkXG4gICAqIGZvciBgZGFsbC1lLTNgLlxuICAgKi9cbiAgcXVhbGl0eT86ICdzdGFuZGFyZCcgfCAnaGQnO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IGluIHdoaWNoIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzIGFyZSByZXR1cm5lZC4gTXVzdCBiZSBvbmUgb2YgYHVybGAgb3JcbiAgICogYGI2NF9qc29uYC4gVVJMcyBhcmUgb25seSB2YWxpZCBmb3IgNjAgbWludXRlcyBhZnRlciB0aGUgaW1hZ2UgaGFzIGJlZW5cbiAgICogZ2VuZXJhdGVkLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogJ3VybCcgfCAnYjY0X2pzb24nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIGdlbmVyYXRlZCBpbWFnZXMuIE11c3QgYmUgb25lIG9mIGAyNTZ4MjU2YCwgYDUxMng1MTJgLCBvclxuICAgKiBgMTAyNHgxMDI0YCBmb3IgYGRhbGwtZS0yYC4gTXVzdCBiZSBvbmUgb2YgYDEwMjR4MTAyNGAsIGAxNzkyeDEwMjRgLCBvclxuICAgKiBgMTAyNHgxNzkyYCBmb3IgYGRhbGwtZS0zYCBtb2RlbHMuXG4gICAqL1xuICBzaXplPzogJzI1NngyNTYnIHwgJzUxMng1MTInIHwgJzEwMjR4MTAyNCcgfCAnMTc5MngxMDI0JyB8ICcxMDI0eDE3OTInIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHN0eWxlIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBNdXN0IGJlIG9uZSBvZiBgdml2aWRgIG9yIGBuYXR1cmFsYC4gVml2aWRcbiAgICogY2F1c2VzIHRoZSBtb2RlbCB0byBsZWFuIHRvd2FyZHMgZ2VuZXJhdGluZyBoeXBlci1yZWFsIGFuZCBkcmFtYXRpYyBpbWFnZXMuXG4gICAqIE5hdHVyYWwgY2F1c2VzIHRoZSBtb2RlbCB0byBwcm9kdWNlIG1vcmUgbmF0dXJhbCwgbGVzcyBoeXBlci1yZWFsIGxvb2tpbmdcbiAgICogaW1hZ2VzLiBUaGlzIHBhcmFtIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBgZGFsbC1lLTNgLlxuICAgKi9cbiAgc3R5bGU/OiAndml2aWQnIHwgJ25hdHVyYWwnIHwgbnVsbDtcblxuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciByZXByZXNlbnRpbmcgeW91ciBlbmQtdXNlciwgd2hpY2ggY2FuIGhlbHAgT3BlbkFJIHRvIG1vbml0b3JcbiAgICogYW5kIGRldGVjdCBhYnVzZS5cbiAgICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zYWZldHktYmVzdC1wcmFjdGljZXMjZW5kLXVzZXItaWRzKS5cbiAgICovXG4gIHVzZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBJbWFnZXMge1xuICBleHBvcnQge1xuICAgIHR5cGUgSW1hZ2UgYXMgSW1hZ2UsXG4gICAgdHlwZSBJbWFnZU1vZGVsIGFzIEltYWdlTW9kZWwsXG4gICAgdHlwZSBJbWFnZXNSZXNwb25zZSBhcyBJbWFnZXNSZXNwb25zZSxcbiAgICB0eXBlIEltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zIGFzIEltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zLFxuICAgIHR5cGUgSW1hZ2VFZGl0UGFyYW1zIGFzIEltYWdlRWRpdFBhcmFtcyxcbiAgICB0eXBlIEltYWdlR2VuZXJhdGVQYXJhbXMgYXMgSW1hZ2VHZW5lcmF0ZVBhcmFtcyxcbiAgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSAnLi4vcGFnaW5hdGlvbic7XG5cbmV4cG9ydCBjbGFzcyBNb2RlbHMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBtb2RlbCBpbnN0YW5jZSwgcHJvdmlkaW5nIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IHRoZSBtb2RlbCBzdWNoIGFzXG4gICAqIHRoZSBvd25lciBhbmQgcGVybWlzc2lvbmluZy5cbiAgICovXG4gIHJldHJpZXZlKG1vZGVsOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPE1vZGVsPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC9tb2RlbHMvJHttb2RlbH1gLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0cyB0aGUgY3VycmVudGx5IGF2YWlsYWJsZSBtb2RlbHMsIGFuZCBwcm92aWRlcyBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCBlYWNoXG4gICAqIG9uZSBzdWNoIGFzIHRoZSBvd25lciBhbmQgYXZhaWxhYmlsaXR5LlxuICAgKi9cbiAgbGlzdChvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuUGFnZVByb21pc2U8TW9kZWxzUGFnZSwgTW9kZWw+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy9tb2RlbHMnLCBNb2RlbHNQYWdlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBmaW5lLXR1bmVkIG1vZGVsLiBZb3UgbXVzdCBoYXZlIHRoZSBPd25lciByb2xlIGluIHlvdXIgb3JnYW5pemF0aW9uIHRvXG4gICAqIGRlbGV0ZSBhIG1vZGVsLlxuICAgKi9cbiAgZGVsKG1vZGVsOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPE1vZGVsRGVsZXRlZD4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQuZGVsZXRlKGAvbW9kZWxzLyR7bW9kZWx9YCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3RlOiBubyBwYWdpbmF0aW9uIGFjdHVhbGx5IG9jY3VycyB5ZXQsIHRoaXMgaXMgZm9yIGZvcndhcmRzLWNvbXBhdGliaWxpdHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2RlbHNQYWdlIGV4dGVuZHMgUGFnZTxNb2RlbD4ge31cblxuLyoqXG4gKiBEZXNjcmliZXMgYW4gT3BlbkFJIG1vZGVsIG9mZmVyaW5nIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgQVBJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVsIHtcbiAgLyoqXG4gICAqIFRoZSBtb2RlbCBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgd2hlbiB0aGUgbW9kZWwgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwibW9kZWxcIi5cbiAgICovXG4gIG9iamVjdDogJ21vZGVsJztcblxuICAvKipcbiAgICogVGhlIG9yZ2FuaXphdGlvbiB0aGF0IG93bnMgdGhlIG1vZGVsLlxuICAgKi9cbiAgb3duZWRfYnk6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb2RlbERlbGV0ZWQge1xuICBpZDogc3RyaW5nO1xuXG4gIGRlbGV0ZWQ6IGJvb2xlYW47XG5cbiAgb2JqZWN0OiBzdHJpbmc7XG59XG5cbk1vZGVscy5Nb2RlbHNQYWdlID0gTW9kZWxzUGFnZTtcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIE1vZGVscyB7XG4gIGV4cG9ydCB7IHR5cGUgTW9kZWwgYXMgTW9kZWwsIHR5cGUgTW9kZWxEZWxldGVkIGFzIE1vZGVsRGVsZXRlZCwgTW9kZWxzUGFnZSBhcyBNb2RlbHNQYWdlIH07XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tICcuLi9yZXNvdXJjZSc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4uL2NvcmUnO1xuXG5leHBvcnQgY2xhc3MgTW9kZXJhdGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDbGFzc2lmaWVzIGlmIHRleHQgYW5kL29yIGltYWdlIGlucHV0cyBhcmUgcG90ZW50aWFsbHkgaGFybWZ1bC4gTGVhcm4gbW9yZSBpblxuICAgKiB0aGUgW21vZGVyYXRpb24gZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9tb2RlcmF0aW9uKS5cbiAgICovXG4gIGNyZWF0ZShcbiAgICBib2R5OiBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8TW9kZXJhdGlvbkNyZWF0ZVJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvbW9kZXJhdGlvbnMnLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb2RlcmF0aW9uIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0aGUgY2F0ZWdvcmllcywgYW5kIHdoZXRoZXIgdGhleSBhcmUgZmxhZ2dlZCBvciBub3QuXG4gICAqL1xuICBjYXRlZ29yaWVzOiBNb2RlcmF0aW9uLkNhdGVnb3JpZXM7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0aGUgY2F0ZWdvcmllcyBhbG9uZyB3aXRoIHRoZSBpbnB1dCB0eXBlKHMpIHRoYXQgdGhlIHNjb3JlIGFwcGxpZXMgdG8uXG4gICAqL1xuICBjYXRlZ29yeV9hcHBsaWVkX2lucHV0X3R5cGVzOiBNb2RlcmF0aW9uLkNhdGVnb3J5QXBwbGllZElucHV0VHlwZXM7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0aGUgY2F0ZWdvcmllcyBhbG9uZyB3aXRoIHRoZWlyIHNjb3JlcyBhcyBwcmVkaWN0ZWQgYnkgbW9kZWwuXG4gICAqL1xuICBjYXRlZ29yeV9zY29yZXM6IE1vZGVyYXRpb24uQ2F0ZWdvcnlTY29yZXM7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgYW55IG9mIHRoZSBiZWxvdyBjYXRlZ29yaWVzIGFyZSBmbGFnZ2VkLlxuICAgKi9cbiAgZmxhZ2dlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBNb2RlcmF0aW9uIHtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0aGUgY2F0ZWdvcmllcywgYW5kIHdoZXRoZXIgdGhleSBhcmUgZmxhZ2dlZCBvciBub3QuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIENhdGVnb3JpZXMge1xuICAgIC8qKlxuICAgICAqIENvbnRlbnQgdGhhdCBleHByZXNzZXMsIGluY2l0ZXMsIG9yIHByb21vdGVzIGhhcmFzc2luZyBsYW5ndWFnZSB0b3dhcmRzIGFueVxuICAgICAqIHRhcmdldC5cbiAgICAgKi9cbiAgICBoYXJhc3NtZW50OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogSGFyYXNzbWVudCBjb250ZW50IHRoYXQgYWxzbyBpbmNsdWRlcyB2aW9sZW5jZSBvciBzZXJpb3VzIGhhcm0gdG93YXJkcyBhbnlcbiAgICAgKiB0YXJnZXQuXG4gICAgICovXG4gICAgJ2hhcmFzc21lbnQvdGhyZWF0ZW5pbmcnOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB0aGF0IGV4cHJlc3NlcywgaW5jaXRlcywgb3IgcHJvbW90ZXMgaGF0ZSBiYXNlZCBvbiByYWNlLCBnZW5kZXIsXG4gICAgICogZXRobmljaXR5LCByZWxpZ2lvbiwgbmF0aW9uYWxpdHksIHNleHVhbCBvcmllbnRhdGlvbiwgZGlzYWJpbGl0eSBzdGF0dXMsIG9yXG4gICAgICogY2FzdGUuIEhhdGVmdWwgY29udGVudCBhaW1lZCBhdCBub24tcHJvdGVjdGVkIGdyb3VwcyAoZS5nLiwgY2hlc3MgcGxheWVycykgaXNcbiAgICAgKiBoYXJhc3NtZW50LlxuICAgICAqL1xuICAgIGhhdGU6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBIYXRlZnVsIGNvbnRlbnQgdGhhdCBhbHNvIGluY2x1ZGVzIHZpb2xlbmNlIG9yIHNlcmlvdXMgaGFybSB0b3dhcmRzIHRoZSB0YXJnZXRlZFxuICAgICAqIGdyb3VwIGJhc2VkIG9uIHJhY2UsIGdlbmRlciwgZXRobmljaXR5LCByZWxpZ2lvbiwgbmF0aW9uYWxpdHksIHNleHVhbFxuICAgICAqIG9yaWVudGF0aW9uLCBkaXNhYmlsaXR5IHN0YXR1cywgb3IgY2FzdGUuXG4gICAgICovXG4gICAgJ2hhdGUvdGhyZWF0ZW5pbmcnOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB0aGF0IGluY2x1ZGVzIGluc3RydWN0aW9ucyBvciBhZHZpY2UgdGhhdCBmYWNpbGl0YXRlIHRoZSBwbGFubmluZyBvclxuICAgICAqIGV4ZWN1dGlvbiBvZiB3cm9uZ2RvaW5nLCBvciB0aGF0IGdpdmVzIGFkdmljZSBvciBpbnN0cnVjdGlvbiBvbiBob3cgdG8gY29tbWl0XG4gICAgICogaWxsaWNpdCBhY3RzLiBGb3IgZXhhbXBsZSwgXCJob3cgdG8gc2hvcGxpZnRcIiB3b3VsZCBmaXQgdGhpcyBjYXRlZ29yeS5cbiAgICAgKi9cbiAgICBpbGxpY2l0OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB0aGF0IGluY2x1ZGVzIGluc3RydWN0aW9ucyBvciBhZHZpY2UgdGhhdCBmYWNpbGl0YXRlIHRoZSBwbGFubmluZyBvclxuICAgICAqIGV4ZWN1dGlvbiBvZiB3cm9uZ2RvaW5nIHRoYXQgYWxzbyBpbmNsdWRlcyB2aW9sZW5jZSwgb3IgdGhhdCBnaXZlcyBhZHZpY2Ugb3JcbiAgICAgKiBpbnN0cnVjdGlvbiBvbiB0aGUgcHJvY3VyZW1lbnQgb2YgYW55IHdlYXBvbi5cbiAgICAgKi9cbiAgICAnaWxsaWNpdC92aW9sZW50JzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgdGhhdCBwcm9tb3RlcywgZW5jb3VyYWdlcywgb3IgZGVwaWN0cyBhY3RzIG9mIHNlbGYtaGFybSwgc3VjaCBhc1xuICAgICAqIHN1aWNpZGUsIGN1dHRpbmcsIGFuZCBlYXRpbmcgZGlzb3JkZXJzLlxuICAgICAqL1xuICAgICdzZWxmLWhhcm0nOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB0aGF0IGVuY291cmFnZXMgcGVyZm9ybWluZyBhY3RzIG9mIHNlbGYtaGFybSwgc3VjaCBhcyBzdWljaWRlLCBjdXR0aW5nLFxuICAgICAqIGFuZCBlYXRpbmcgZGlzb3JkZXJzLCBvciB0aGF0IGdpdmVzIGluc3RydWN0aW9ucyBvciBhZHZpY2Ugb24gaG93IHRvIGNvbW1pdCBzdWNoXG4gICAgICogYWN0cy5cbiAgICAgKi9cbiAgICAnc2VsZi1oYXJtL2luc3RydWN0aW9ucyc6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IHdoZXJlIHRoZSBzcGVha2VyIGV4cHJlc3NlcyB0aGF0IHRoZXkgYXJlIGVuZ2FnaW5nIG9yIGludGVuZCB0byBlbmdhZ2VcbiAgICAgKiBpbiBhY3RzIG9mIHNlbGYtaGFybSwgc3VjaCBhcyBzdWljaWRlLCBjdXR0aW5nLCBhbmQgZWF0aW5nIGRpc29yZGVycy5cbiAgICAgKi9cbiAgICAnc2VsZi1oYXJtL2ludGVudCc6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IG1lYW50IHRvIGFyb3VzZSBzZXh1YWwgZXhjaXRlbWVudCwgc3VjaCBhcyB0aGUgZGVzY3JpcHRpb24gb2Ygc2V4dWFsXG4gICAgICogYWN0aXZpdHksIG9yIHRoYXQgcHJvbW90ZXMgc2V4dWFsIHNlcnZpY2VzIChleGNsdWRpbmcgc2V4IGVkdWNhdGlvbiBhbmRcbiAgICAgKiB3ZWxsbmVzcykuXG4gICAgICovXG4gICAgc2V4dWFsOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogU2V4dWFsIGNvbnRlbnQgdGhhdCBpbmNsdWRlcyBhbiBpbmRpdmlkdWFsIHdobyBpcyB1bmRlciAxOCB5ZWFycyBvbGQuXG4gICAgICovXG4gICAgJ3NleHVhbC9taW5vcnMnOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB0aGF0IGRlcGljdHMgZGVhdGgsIHZpb2xlbmNlLCBvciBwaHlzaWNhbCBpbmp1cnkuXG4gICAgICovXG4gICAgdmlvbGVuY2U6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IHRoYXQgZGVwaWN0cyBkZWF0aCwgdmlvbGVuY2UsIG9yIHBoeXNpY2FsIGluanVyeSBpbiBncmFwaGljIGRldGFpbC5cbiAgICAgKi9cbiAgICAndmlvbGVuY2UvZ3JhcGhpYyc6IGJvb2xlYW47XG4gIH1cblxuICAvKipcbiAgICogQSBsaXN0IG9mIHRoZSBjYXRlZ29yaWVzIGFsb25nIHdpdGggdGhlIGlucHV0IHR5cGUocykgdGhhdCB0aGUgc2NvcmUgYXBwbGllcyB0by5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ2F0ZWdvcnlBcHBsaWVkSW5wdXRUeXBlcyB7XG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICdoYXJhc3NtZW50Jy5cbiAgICAgKi9cbiAgICBoYXJhc3NtZW50OiBBcnJheTwndGV4dCc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICdoYXJhc3NtZW50L3RocmVhdGVuaW5nJy5cbiAgICAgKi9cbiAgICAnaGFyYXNzbWVudC90aHJlYXRlbmluZyc6IEFycmF5PCd0ZXh0Jz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ2hhdGUnLlxuICAgICAqL1xuICAgIGhhdGU6IEFycmF5PCd0ZXh0Jz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ2hhdGUvdGhyZWF0ZW5pbmcnLlxuICAgICAqL1xuICAgICdoYXRlL3RocmVhdGVuaW5nJzogQXJyYXk8J3RleHQnPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAnaWxsaWNpdCcuXG4gICAgICovXG4gICAgaWxsaWNpdDogQXJyYXk8J3RleHQnPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAnaWxsaWNpdC92aW9sZW50Jy5cbiAgICAgKi9cbiAgICAnaWxsaWNpdC92aW9sZW50JzogQXJyYXk8J3RleHQnPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAnc2VsZi1oYXJtJy5cbiAgICAgKi9cbiAgICAnc2VsZi1oYXJtJzogQXJyYXk8J3RleHQnIHwgJ2ltYWdlJz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ3NlbGYtaGFybS9pbnN0cnVjdGlvbnMnLlxuICAgICAqL1xuICAgICdzZWxmLWhhcm0vaW5zdHJ1Y3Rpb25zJzogQXJyYXk8J3RleHQnIHwgJ2ltYWdlJz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ3NlbGYtaGFybS9pbnRlbnQnLlxuICAgICAqL1xuICAgICdzZWxmLWhhcm0vaW50ZW50JzogQXJyYXk8J3RleHQnIHwgJ2ltYWdlJz47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwbGllZCBpbnB1dCB0eXBlKHMpIGZvciB0aGUgY2F0ZWdvcnkgJ3NleHVhbCcuXG4gICAgICovXG4gICAgc2V4dWFsOiBBcnJheTwndGV4dCcgfCAnaW1hZ2UnPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBsaWVkIGlucHV0IHR5cGUocykgZm9yIHRoZSBjYXRlZ29yeSAnc2V4dWFsL21pbm9ycycuXG4gICAgICovXG4gICAgJ3NleHVhbC9taW5vcnMnOiBBcnJheTwndGV4dCc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICd2aW9sZW5jZScuXG4gICAgICovXG4gICAgdmlvbGVuY2U6IEFycmF5PCd0ZXh0JyB8ICdpbWFnZSc+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcGxpZWQgaW5wdXQgdHlwZShzKSBmb3IgdGhlIGNhdGVnb3J5ICd2aW9sZW5jZS9ncmFwaGljJy5cbiAgICAgKi9cbiAgICAndmlvbGVuY2UvZ3JhcGhpYyc6IEFycmF5PCd0ZXh0JyB8ICdpbWFnZSc+O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0aGUgY2F0ZWdvcmllcyBhbG9uZyB3aXRoIHRoZWlyIHNjb3JlcyBhcyBwcmVkaWN0ZWQgYnkgbW9kZWwuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIENhdGVnb3J5U2NvcmVzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnaGFyYXNzbWVudCcuXG4gICAgICovXG4gICAgaGFyYXNzbWVudDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ2hhcmFzc21lbnQvdGhyZWF0ZW5pbmcnLlxuICAgICAqL1xuICAgICdoYXJhc3NtZW50L3RocmVhdGVuaW5nJzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ2hhdGUnLlxuICAgICAqL1xuICAgIGhhdGU6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdoYXRlL3RocmVhdGVuaW5nJy5cbiAgICAgKi9cbiAgICAnaGF0ZS90aHJlYXRlbmluZyc6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdpbGxpY2l0Jy5cbiAgICAgKi9cbiAgICBpbGxpY2l0OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnaWxsaWNpdC92aW9sZW50Jy5cbiAgICAgKi9cbiAgICAnaWxsaWNpdC92aW9sZW50JzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ3NlbGYtaGFybScuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybSc6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdzZWxmLWhhcm0vaW5zdHJ1Y3Rpb25zJy5cbiAgICAgKi9cbiAgICAnc2VsZi1oYXJtL2luc3RydWN0aW9ucyc6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdzZWxmLWhhcm0vaW50ZW50Jy5cbiAgICAgKi9cbiAgICAnc2VsZi1oYXJtL2ludGVudCc6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdzZXh1YWwnLlxuICAgICAqL1xuICAgIHNleHVhbDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ3NleHVhbC9taW5vcnMnLlxuICAgICAqL1xuICAgICdzZXh1YWwvbWlub3JzJzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ3Zpb2xlbmNlJy5cbiAgICAgKi9cbiAgICB2aW9sZW5jZTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ3Zpb2xlbmNlL2dyYXBoaWMnLlxuICAgICAqL1xuICAgICd2aW9sZW5jZS9ncmFwaGljJzogbnVtYmVyO1xuICB9XG59XG5cbi8qKlxuICogQW4gb2JqZWN0IGRlc2NyaWJpbmcgYW4gaW1hZ2UgdG8gY2xhc3NpZnkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZXJhdGlvbkltYWdlVVJMSW5wdXQge1xuICAvKipcbiAgICogQ29udGFpbnMgZWl0aGVyIGFuIGltYWdlIFVSTCBvciBhIGRhdGEgVVJMIGZvciBhIGJhc2U2NCBlbmNvZGVkIGltYWdlLlxuICAgKi9cbiAgaW1hZ2VfdXJsOiBNb2RlcmF0aW9uSW1hZ2VVUkxJbnB1dC5JbWFnZVVSTDtcblxuICAvKipcbiAgICogQWx3YXlzIGBpbWFnZV91cmxgLlxuICAgKi9cbiAgdHlwZTogJ2ltYWdlX3VybCc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgTW9kZXJhdGlvbkltYWdlVVJMSW5wdXQge1xuICAvKipcbiAgICogQ29udGFpbnMgZWl0aGVyIGFuIGltYWdlIFVSTCBvciBhIGRhdGEgVVJMIGZvciBhIGJhc2U2NCBlbmNvZGVkIGltYWdlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBJbWFnZVVSTCB7XG4gICAgLyoqXG4gICAgICogRWl0aGVyIGEgVVJMIG9mIHRoZSBpbWFnZSBvciB0aGUgYmFzZTY0IGVuY29kZWQgaW1hZ2UgZGF0YS5cbiAgICAgKi9cbiAgICB1cmw6IHN0cmluZztcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBNb2RlcmF0aW9uTW9kZWwgPVxuICB8ICdvbW5pLW1vZGVyYXRpb24tbGF0ZXN0J1xuICB8ICdvbW5pLW1vZGVyYXRpb24tMjAyNC0wOS0yNidcbiAgfCAndGV4dC1tb2RlcmF0aW9uLWxhdGVzdCdcbiAgfCAndGV4dC1tb2RlcmF0aW9uLXN0YWJsZSc7XG5cbi8qKlxuICogQW4gb2JqZWN0IGRlc2NyaWJpbmcgYW4gaW1hZ2UgdG8gY2xhc3NpZnkuXG4gKi9cbmV4cG9ydCB0eXBlIE1vZGVyYXRpb25NdWx0aU1vZGFsSW5wdXQgPSBNb2RlcmF0aW9uSW1hZ2VVUkxJbnB1dCB8IE1vZGVyYXRpb25UZXh0SW5wdXQ7XG5cbi8qKlxuICogQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGV4dCB0byBjbGFzc2lmeS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNb2RlcmF0aW9uVGV4dElucHV0IHtcbiAgLyoqXG4gICAqIEEgc3RyaW5nIG9mIHRleHQgdG8gY2xhc3NpZnkuXG4gICAqL1xuICB0ZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgdGV4dGAuXG4gICAqL1xuICB0eXBlOiAndGV4dCc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBpZiBhIGdpdmVuIHRleHQgaW5wdXQgaXMgcG90ZW50aWFsbHkgaGFybWZ1bC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNb2RlcmF0aW9uQ3JlYXRlUmVzcG9uc2Uge1xuICAvKipcbiAgICogVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgbW9kZXJhdGlvbiByZXF1ZXN0LlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIG1vZGVyYXRpb24gcmVzdWx0cy5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBtb2RlcmF0aW9uIG9iamVjdHMuXG4gICAqL1xuICByZXN1bHRzOiBBcnJheTxNb2RlcmF0aW9uPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIElucHV0IChvciBpbnB1dHMpIHRvIGNsYXNzaWZ5LiBDYW4gYmUgYSBzaW5nbGUgc3RyaW5nLCBhbiBhcnJheSBvZiBzdHJpbmdzLCBvclxuICAgKiBhbiBhcnJheSBvZiBtdWx0aS1tb2RhbCBpbnB1dCBvYmplY3RzIHNpbWlsYXIgdG8gb3RoZXIgbW9kZWxzLlxuICAgKi9cbiAgaW5wdXQ6IHN0cmluZyB8IEFycmF5PHN0cmluZz4gfCBBcnJheTxNb2RlcmF0aW9uTXVsdGlNb2RhbElucHV0PjtcblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgbW9kZXJhdGlvbiBtb2RlbCB5b3Ugd291bGQgbGlrZSB0byB1c2UuIExlYXJuIG1vcmUgaW5cbiAgICogW3RoZSBtb2RlcmF0aW9uIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvbW9kZXJhdGlvbiksIGFuZFxuICAgKiBsZWFybiBhYm91dCBhdmFpbGFibGUgbW9kZWxzXG4gICAqIFtoZXJlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMjbW9kZXJhdGlvbikuXG4gICAqL1xuICBtb2RlbD86IChzdHJpbmcgJiB7fSkgfCBNb2RlcmF0aW9uTW9kZWw7XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBNb2RlcmF0aW9ucyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBNb2RlcmF0aW9uIGFzIE1vZGVyYXRpb24sXG4gICAgdHlwZSBNb2RlcmF0aW9uSW1hZ2VVUkxJbnB1dCBhcyBNb2RlcmF0aW9uSW1hZ2VVUkxJbnB1dCxcbiAgICB0eXBlIE1vZGVyYXRpb25Nb2RlbCBhcyBNb2RlcmF0aW9uTW9kZWwsXG4gICAgdHlwZSBNb2RlcmF0aW9uTXVsdGlNb2RhbElucHV0IGFzIE1vZGVyYXRpb25NdWx0aU1vZGFsSW5wdXQsXG4gICAgdHlwZSBNb2RlcmF0aW9uVGV4dElucHV0IGFzIE1vZGVyYXRpb25UZXh0SW5wdXQsXG4gICAgdHlwZSBNb2RlcmF0aW9uQ3JlYXRlUmVzcG9uc2UgYXMgTW9kZXJhdGlvbkNyZWF0ZVJlc3BvbnNlLFxuICAgIHR5cGUgTW9kZXJhdGlvbkNyZWF0ZVBhcmFtcyBhcyBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zLFxuICB9O1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2UnO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuLi8uLi9jb3JlJztcblxuZXhwb3J0IGNsYXNzIFBhcnRzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQWRkcyBhXG4gICAqIFtQYXJ0XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3VwbG9hZHMvcGFydC1vYmplY3QpIHRvIGFuXG4gICAqIFtVcGxvYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdXBsb2Fkcy9vYmplY3QpIG9iamVjdC5cbiAgICogQSBQYXJ0IHJlcHJlc2VudHMgYSBjaHVuayBvZiBieXRlcyBmcm9tIHRoZSBmaWxlIHlvdSBhcmUgdHJ5aW5nIHRvIHVwbG9hZC5cbiAgICpcbiAgICogRWFjaCBQYXJ0IGNhbiBiZSBhdCBtb3N0IDY0IE1CLCBhbmQgeW91IGNhbiBhZGQgUGFydHMgdW50aWwgeW91IGhpdCB0aGUgVXBsb2FkXG4gICAqIG1heGltdW0gb2YgOCBHQi5cbiAgICpcbiAgICogSXQgaXMgcG9zc2libGUgdG8gYWRkIG11bHRpcGxlIFBhcnRzIGluIHBhcmFsbGVsLiBZb3UgY2FuIGRlY2lkZSB0aGUgaW50ZW5kZWRcbiAgICogb3JkZXIgb2YgdGhlIFBhcnRzIHdoZW4geW91XG4gICAqIFtjb21wbGV0ZSB0aGUgVXBsb2FkXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3VwbG9hZHMvY29tcGxldGUpLlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIHVwbG9hZElkOiBzdHJpbmcsXG4gICAgYm9keTogUGFydENyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFVwbG9hZFBhcnQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoXG4gICAgICBgL3VwbG9hZHMvJHt1cGxvYWRJZH0vcGFydHNgLFxuICAgICAgQ29yZS5tdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pLFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgdXBsb2FkIFBhcnQgcmVwcmVzZW50cyBhIGNodW5rIG9mIGJ5dGVzIHdlIGNhbiBhZGQgdG8gYW4gVXBsb2FkIG9iamVjdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGxvYWRQYXJ0IHtcbiAgLyoqXG4gICAqIFRoZSB1cGxvYWQgUGFydCB1bmlxdWUgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIFBhcnQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGB1cGxvYWQucGFydGAuXG4gICAqL1xuICBvYmplY3Q6ICd1cGxvYWQucGFydCc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgVXBsb2FkIG9iamVjdCB0aGF0IHRoaXMgUGFydCB3YXMgYWRkZWQgdG8uXG4gICAqL1xuICB1cGxvYWRfaWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJ0Q3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBjaHVuayBvZiBieXRlcyBmb3IgdGhpcyBQYXJ0LlxuICAgKi9cbiAgZGF0YTogQ29yZS5VcGxvYWRhYmxlO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgUGFydHMge1xuICBleHBvcnQgeyB0eXBlIFVwbG9hZFBhcnQgYXMgVXBsb2FkUGFydCwgdHlwZSBQYXJ0Q3JlYXRlUGFyYW1zIGFzIFBhcnRDcmVhdGVQYXJhbXMgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBGaWxlc0FQSSBmcm9tICcuLi9maWxlcyc7XG5pbXBvcnQgKiBhcyBQYXJ0c0FQSSBmcm9tICcuL3BhcnRzJztcbmltcG9ydCB7IFBhcnRDcmVhdGVQYXJhbXMsIFBhcnRzLCBVcGxvYWRQYXJ0IH0gZnJvbSAnLi9wYXJ0cyc7XG5cbmV4cG9ydCBjbGFzcyBVcGxvYWRzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICBwYXJ0czogUGFydHNBUEkuUGFydHMgPSBuZXcgUGFydHNBUEkuUGFydHModGhpcy5fY2xpZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnRlcm1lZGlhdGVcbiAgICogW1VwbG9hZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS91cGxvYWRzL29iamVjdCkgb2JqZWN0XG4gICAqIHRoYXQgeW91IGNhbiBhZGRcbiAgICogW1BhcnRzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL3VwbG9hZHMvcGFydC1vYmplY3QpIHRvLlxuICAgKiBDdXJyZW50bHksIGFuIFVwbG9hZCBjYW4gYWNjZXB0IGF0IG1vc3QgOCBHQiBpbiB0b3RhbCBhbmQgZXhwaXJlcyBhZnRlciBhbiBob3VyXG4gICAqIGFmdGVyIHlvdSBjcmVhdGUgaXQuXG4gICAqXG4gICAqIE9uY2UgeW91IGNvbXBsZXRlIHRoZSBVcGxvYWQsIHdlIHdpbGwgY3JlYXRlIGFcbiAgICogW0ZpbGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMvb2JqZWN0KSBvYmplY3QgdGhhdFxuICAgKiBjb250YWlucyBhbGwgdGhlIHBhcnRzIHlvdSB1cGxvYWRlZC4gVGhpcyBGaWxlIGlzIHVzYWJsZSBpbiB0aGUgcmVzdCBvZiBvdXJcbiAgICogcGxhdGZvcm0gYXMgYSByZWd1bGFyIEZpbGUgb2JqZWN0LlxuICAgKlxuICAgKiBGb3IgY2VydGFpbiBgcHVycG9zZWBzLCB0aGUgY29ycmVjdCBgbWltZV90eXBlYCBtdXN0IGJlIHNwZWNpZmllZC4gUGxlYXNlIHJlZmVyXG4gICAqIHRvIGRvY3VtZW50YXRpb24gZm9yIHRoZSBzdXBwb3J0ZWQgTUlNRSB0eXBlcyBmb3IgeW91ciB1c2UgY2FzZTpcbiAgICpcbiAgICogLSBbQXNzaXN0YW50c10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy90b29scy9maWxlLXNlYXJjaCNzdXBwb3J0ZWQtZmlsZXMpXG4gICAqXG4gICAqIEZvciBndWlkYW5jZSBvbiB0aGUgcHJvcGVyIGZpbGVuYW1lIGV4dGVuc2lvbnMgZm9yIGVhY2ggcHVycG9zZSwgcGxlYXNlIGZvbGxvd1xuICAgKiB0aGUgZG9jdW1lbnRhdGlvbiBvblxuICAgKiBbY3JlYXRpbmcgYSBGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL2NyZWF0ZSkuXG4gICAqL1xuICBjcmVhdGUoYm9keTogVXBsb2FkQ3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxVcGxvYWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy91cGxvYWRzJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgdGhlIFVwbG9hZC4gTm8gUGFydHMgbWF5IGJlIGFkZGVkIGFmdGVyIGFuIFVwbG9hZCBpcyBjYW5jZWxsZWQuXG4gICAqL1xuICBjYW5jZWwodXBsb2FkSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8VXBsb2FkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdXBsb2Fkcy8ke3VwbG9hZElkfS9jYW5jZWxgLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZXMgdGhlXG4gICAqIFtVcGxvYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdXBsb2Fkcy9vYmplY3QpLlxuICAgKlxuICAgKiBXaXRoaW4gdGhlIHJldHVybmVkIFVwbG9hZCBvYmplY3QsIHRoZXJlIGlzIGEgbmVzdGVkXG4gICAqIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL29iamVjdCkgb2JqZWN0IHRoYXRcbiAgICogaXMgcmVhZHkgdG8gdXNlIGluIHRoZSByZXN0IG9mIHRoZSBwbGF0Zm9ybS5cbiAgICpcbiAgICogWW91IGNhbiBzcGVjaWZ5IHRoZSBvcmRlciBvZiB0aGUgUGFydHMgYnkgcGFzc2luZyBpbiBhbiBvcmRlcmVkIGxpc3Qgb2YgdGhlIFBhcnRcbiAgICogSURzLlxuICAgKlxuICAgKiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHVwbG9hZGVkIHVwb24gY29tcGxldGlvbiBtdXN0IG1hdGNoIHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgICogaW5pdGlhbGx5IHNwZWNpZmllZCB3aGVuIGNyZWF0aW5nIHRoZSBVcGxvYWQgb2JqZWN0LiBObyBQYXJ0cyBtYXkgYmUgYWRkZWQgYWZ0ZXJcbiAgICogYW4gVXBsb2FkIGlzIGNvbXBsZXRlZC5cbiAgICovXG4gIGNvbXBsZXRlKFxuICAgIHVwbG9hZElkOiBzdHJpbmcsXG4gICAgYm9keTogVXBsb2FkQ29tcGxldGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxVcGxvYWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC91cGxvYWRzLyR7dXBsb2FkSWR9L2NvbXBsZXRlYCwgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICB9XG59XG5cbi8qKlxuICogVGhlIFVwbG9hZCBvYmplY3QgY2FuIGFjY2VwdCBieXRlIGNodW5rcyBpbiB0aGUgZm9ybSBvZiBQYXJ0cy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGxvYWQge1xuICAvKipcbiAgICogVGhlIFVwbG9hZCB1bmlxdWUgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbnRlbmRlZCBudW1iZXIgb2YgYnl0ZXMgdG8gYmUgdXBsb2FkZWQuXG4gICAqL1xuICBieXRlczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBVcGxvYWQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIFVwbG9hZCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGV4cGlyZXNfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQuXG4gICAqL1xuICBmaWxlbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcInVwbG9hZFwiLlxuICAgKi9cbiAgb2JqZWN0OiAndXBsb2FkJztcblxuICAvKipcbiAgICogVGhlIGludGVuZGVkIHB1cnBvc2Ugb2YgdGhlIGZpbGUuXG4gICAqIFtQbGVhc2UgcmVmZXIgaGVyZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9vYmplY3QjZmlsZXMvb2JqZWN0LXB1cnBvc2UpXG4gICAqIGZvciBhY2NlcHRhYmxlIHZhbHVlcy5cbiAgICovXG4gIHB1cnBvc2U6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHN0YXR1cyBvZiB0aGUgVXBsb2FkLlxuICAgKi9cbiAgc3RhdHVzOiAncGVuZGluZycgfCAnY29tcGxldGVkJyB8ICdjYW5jZWxsZWQnIHwgJ2V4cGlyZWQnO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVhZHkgRmlsZSBvYmplY3QgYWZ0ZXIgdGhlIFVwbG9hZCBpcyBjb21wbGV0ZWQuXG4gICAqL1xuICBmaWxlPzogRmlsZXNBUEkuRmlsZU9iamVjdCB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBsb2FkQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhlIGZpbGUgeW91IGFyZSB1cGxvYWRpbmcuXG4gICAqL1xuICBieXRlczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byB1cGxvYWQuXG4gICAqL1xuICBmaWxlbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgTUlNRSB0eXBlIG9mIHRoZSBmaWxlLlxuICAgKlxuICAgKiBUaGlzIG11c3QgZmFsbCB3aXRoaW4gdGhlIHN1cHBvcnRlZCBNSU1FIHR5cGVzIGZvciB5b3VyIGZpbGUgcHVycG9zZS4gU2VlIHRoZVxuICAgKiBzdXBwb3J0ZWQgTUlNRSB0eXBlcyBmb3IgYXNzaXN0YW50cyBhbmQgdmlzaW9uLlxuICAgKi9cbiAgbWltZV90eXBlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpbnRlbmRlZCBwdXJwb3NlIG9mIHRoZSB1cGxvYWRlZCBmaWxlLlxuICAgKlxuICAgKiBTZWUgdGhlXG4gICAqIFtkb2N1bWVudGF0aW9uIG9uIEZpbGUgcHVycG9zZXNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvZmlsZXMvY3JlYXRlI2ZpbGVzLWNyZWF0ZS1wdXJwb3NlKS5cbiAgICovXG4gIHB1cnBvc2U6IEZpbGVzQVBJLkZpbGVQdXJwb3NlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwbG9hZENvbXBsZXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBvcmRlcmVkIGxpc3Qgb2YgUGFydCBJRHMuXG4gICAqL1xuICBwYXJ0X2lkczogQXJyYXk8c3RyaW5nPjtcblxuICAvKipcbiAgICogVGhlIG9wdGlvbmFsIG1kNSBjaGVja3N1bSBmb3IgdGhlIGZpbGUgY29udGVudHMgdG8gdmVyaWZ5IGlmIHRoZSBieXRlcyB1cGxvYWRlZFxuICAgKiBtYXRjaGVzIHdoYXQgeW91IGV4cGVjdC5cbiAgICovXG4gIG1kNT86IHN0cmluZztcbn1cblxuVXBsb2Fkcy5QYXJ0cyA9IFBhcnRzO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVXBsb2FkcyB7XG4gIGV4cG9ydCB7XG4gICAgdHlwZSBVcGxvYWQgYXMgVXBsb2FkLFxuICAgIHR5cGUgVXBsb2FkQ3JlYXRlUGFyYW1zIGFzIFVwbG9hZENyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIFVwbG9hZENvbXBsZXRlUGFyYW1zIGFzIFVwbG9hZENvbXBsZXRlUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7IFBhcnRzIGFzIFBhcnRzLCB0eXBlIFVwbG9hZFBhcnQgYXMgVXBsb2FkUGFydCwgdHlwZSBQYXJ0Q3JlYXRlUGFyYW1zIGFzIFBhcnRDcmVhdGVQYXJhbXMgfTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuXG5pbXBvcnQgeyB0eXBlIEFnZW50LCB0eXBlIFJlcXVlc3RJbml0IH0gZnJvbSAnLi9fc2hpbXMvaW5kZXgnO1xuaW1wb3J0ICogYXMgcXMgZnJvbSAnLi9pbnRlcm5hbC9xcyc7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4vY29yZSc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQgKiBhcyBQYWdpbmF0aW9uIGZyb20gJy4vcGFnaW5hdGlvbic7XG5pbXBvcnQgeyB0eXBlIEN1cnNvclBhZ2VQYXJhbXMsIEN1cnNvclBhZ2VSZXNwb25zZSwgUGFnZVJlc3BvbnNlIH0gZnJvbSAnLi9wYWdpbmF0aW9uJztcbmltcG9ydCAqIGFzIFVwbG9hZHMgZnJvbSAnLi91cGxvYWRzJztcbmltcG9ydCAqIGFzIEFQSSBmcm9tICcuL3Jlc291cmNlcy9pbmRleCc7XG5pbXBvcnQge1xuICBCYXRjaCxcbiAgQmF0Y2hDcmVhdGVQYXJhbXMsXG4gIEJhdGNoRXJyb3IsXG4gIEJhdGNoTGlzdFBhcmFtcyxcbiAgQmF0Y2hSZXF1ZXN0Q291bnRzLFxuICBCYXRjaGVzLFxuICBCYXRjaGVzUGFnZSxcbn0gZnJvbSAnLi9yZXNvdXJjZXMvYmF0Y2hlcyc7XG5pbXBvcnQge1xuICBDb21wbGV0aW9uLFxuICBDb21wbGV0aW9uQ2hvaWNlLFxuICBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICBDb21wbGV0aW9uVXNhZ2UsXG4gIENvbXBsZXRpb25zLFxufSBmcm9tICcuL3Jlc291cmNlcy9jb21wbGV0aW9ucyc7XG5pbXBvcnQge1xuICBDcmVhdGVFbWJlZGRpbmdSZXNwb25zZSxcbiAgRW1iZWRkaW5nLFxuICBFbWJlZGRpbmdDcmVhdGVQYXJhbXMsXG4gIEVtYmVkZGluZ01vZGVsLFxuICBFbWJlZGRpbmdzLFxufSBmcm9tICcuL3Jlc291cmNlcy9lbWJlZGRpbmdzJztcbmltcG9ydCB7XG4gIEZpbGVDb250ZW50LFxuICBGaWxlQ3JlYXRlUGFyYW1zLFxuICBGaWxlRGVsZXRlZCxcbiAgRmlsZUxpc3RQYXJhbXMsXG4gIEZpbGVPYmplY3QsXG4gIEZpbGVPYmplY3RzUGFnZSxcbiAgRmlsZVB1cnBvc2UsXG4gIEZpbGVzLFxufSBmcm9tICcuL3Jlc291cmNlcy9maWxlcyc7XG5pbXBvcnQge1xuICBJbWFnZSxcbiAgSW1hZ2VDcmVhdGVWYXJpYXRpb25QYXJhbXMsXG4gIEltYWdlRWRpdFBhcmFtcyxcbiAgSW1hZ2VHZW5lcmF0ZVBhcmFtcyxcbiAgSW1hZ2VNb2RlbCxcbiAgSW1hZ2VzLFxuICBJbWFnZXNSZXNwb25zZSxcbn0gZnJvbSAnLi9yZXNvdXJjZXMvaW1hZ2VzJztcbmltcG9ydCB7IE1vZGVsLCBNb2RlbERlbGV0ZWQsIE1vZGVscywgTW9kZWxzUGFnZSB9IGZyb20gJy4vcmVzb3VyY2VzL21vZGVscyc7XG5pbXBvcnQge1xuICBNb2RlcmF0aW9uLFxuICBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zLFxuICBNb2RlcmF0aW9uQ3JlYXRlUmVzcG9uc2UsXG4gIE1vZGVyYXRpb25JbWFnZVVSTElucHV0LFxuICBNb2RlcmF0aW9uTW9kZWwsXG4gIE1vZGVyYXRpb25NdWx0aU1vZGFsSW5wdXQsXG4gIE1vZGVyYXRpb25UZXh0SW5wdXQsXG4gIE1vZGVyYXRpb25zLFxufSBmcm9tICcuL3Jlc291cmNlcy9tb2RlcmF0aW9ucyc7XG5pbXBvcnQgeyBBdWRpbywgQXVkaW9Nb2RlbCwgQXVkaW9SZXNwb25zZUZvcm1hdCB9IGZyb20gJy4vcmVzb3VyY2VzL2F1ZGlvL2F1ZGlvJztcbmltcG9ydCB7IEJldGEgfSBmcm9tICcuL3Jlc291cmNlcy9iZXRhL2JldGEnO1xuaW1wb3J0IHsgQ2hhdCwgQ2hhdE1vZGVsIH0gZnJvbSAnLi9yZXNvdXJjZXMvY2hhdC9jaGF0JztcbmltcG9ydCB7XG4gIENoYXRDb21wbGV0aW9uLFxuICBDaGF0Q29tcGxldGlvbkFzc2lzdGFudE1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25BdWRpbyxcbiAgQ2hhdENvbXBsZXRpb25BdWRpb1BhcmFtLFxuICBDaGF0Q29tcGxldGlvbkNodW5rLFxuICBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0LFxuICBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2UsXG4gIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbnB1dEF1ZGlvLFxuICBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0UmVmdXNhbCxcbiAgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQsXG4gIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcsXG4gIENoYXRDb21wbGV0aW9uRGV2ZWxvcGVyTWVzc2FnZVBhcmFtLFxuICBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uQ2FsbE9wdGlvbixcbiAgQ2hhdENvbXBsZXRpb25GdW5jdGlvbk1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25NZXNzYWdlLFxuICBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwsXG4gIENoYXRDb21wbGV0aW9uTW9kYWxpdHksXG4gIENoYXRDb21wbGV0aW9uTmFtZWRUb29sQ2hvaWNlLFxuICBDaGF0Q29tcGxldGlvblByZWRpY3Rpb25Db250ZW50LFxuICBDaGF0Q29tcGxldGlvblJlYXNvbmluZ0VmZm9ydCxcbiAgQ2hhdENvbXBsZXRpb25Sb2xlLFxuICBDaGF0Q29tcGxldGlvblN0cmVhbU9wdGlvbnMsXG4gIENoYXRDb21wbGV0aW9uU3lzdGVtTWVzc2FnZVBhcmFtLFxuICBDaGF0Q29tcGxldGlvblRva2VuTG9ncHJvYixcbiAgQ2hhdENvbXBsZXRpb25Ub29sLFxuICBDaGF0Q29tcGxldGlvblRvb2xDaG9pY2VPcHRpb24sXG4gIENoYXRDb21wbGV0aW9uVG9vbE1lc3NhZ2VQYXJhbSxcbiAgQ2hhdENvbXBsZXRpb25Vc2VyTWVzc2FnZVBhcmFtLFxufSBmcm9tICcuL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zJztcbmltcG9ydCB7IEZpbmVUdW5pbmcgfSBmcm9tICcuL3Jlc291cmNlcy9maW5lLXR1bmluZy9maW5lLXR1bmluZyc7XG5pbXBvcnQge1xuICBVcGxvYWQsXG4gIFVwbG9hZENvbXBsZXRlUGFyYW1zLFxuICBVcGxvYWRDcmVhdGVQYXJhbXMsXG4gIFVwbG9hZHMgYXMgVXBsb2Fkc0FQSVVwbG9hZHMsXG59IGZyb20gJy4vcmVzb3VyY2VzL3VwbG9hZHMvdXBsb2Fkcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xpZW50T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBwcm9jZXNzLmVudlsnT1BFTkFJX0FQSV9LRVknXS5cbiAgICovXG4gIGFwaUtleT86IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogRGVmYXVsdHMgdG8gcHJvY2Vzcy5lbnZbJ09QRU5BSV9PUkdfSUQnXS5cbiAgICovXG4gIG9yZ2FuaXphdGlvbj86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIHByb2Nlc3MuZW52WydPUEVOQUlfUFJPSkVDVF9JRCddLlxuICAgKi9cbiAgcHJvamVjdD86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGJhc2UgVVJMIGZvciB0aGUgQVBJLCBlLmcuLCBcImh0dHBzOi8vYXBpLmV4YW1wbGUuY29tL3YyL1wiXG4gICAqXG4gICAqIERlZmF1bHRzIHRvIHByb2Nlc3MuZW52WydPUEVOQUlfQkFTRV9VUkwnXS5cbiAgICovXG4gIGJhc2VVUkw/OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSB0aGF0IHRoZSBjbGllbnQgc2hvdWxkIHdhaXQgZm9yIGEgcmVzcG9uc2VcbiAgICogZnJvbSB0aGUgc2VydmVyIGJlZm9yZSB0aW1pbmcgb3V0IGEgc2luZ2xlIHJlcXVlc3QuXG4gICAqXG4gICAqIE5vdGUgdGhhdCByZXF1ZXN0IHRpbWVvdXRzIGFyZSByZXRyaWVkIGJ5IGRlZmF1bHQsIHNvIGluIGEgd29yc3QtY2FzZSBzY2VuYXJpbyB5b3UgbWF5IHdhaXRcbiAgICogbXVjaCBsb25nZXIgdGhhbiB0aGlzIHRpbWVvdXQgYmVmb3JlIHRoZSBwcm9taXNlIHN1Y2NlZWRzIG9yIGZhaWxzLlxuICAgKi9cbiAgdGltZW91dD86IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQW4gSFRUUCBhZ2VudCB1c2VkIHRvIG1hbmFnZSBIVFRQKFMpIGNvbm5lY3Rpb25zLlxuICAgKlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIGFuIGFnZW50IHdpbGwgYmUgY29uc3RydWN0ZWQgYnkgZGVmYXVsdCBpbiB0aGUgTm9kZS5qcyBlbnZpcm9ubWVudCxcbiAgICogb3RoZXJ3aXNlIG5vIGFnZW50IGlzIHVzZWQuXG4gICAqL1xuICBodHRwQWdlbnQ/OiBBZ2VudCB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogU3BlY2lmeSBhIGN1c3RvbSBgZmV0Y2hgIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIHdlIHVzZSBgbm9kZS1mZXRjaGAgb24gTm9kZS5qcyBhbmQgb3RoZXJ3aXNlIGV4cGVjdCB0aGF0IGBmZXRjaGAgaXNcbiAgICogZGVmaW5lZCBnbG9iYWxseS5cbiAgICovXG4gIGZldGNoPzogQ29yZS5GZXRjaCB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHRoYXQgdGhlIGNsaWVudCB3aWxsIHJldHJ5IGEgcmVxdWVzdCBpbiBjYXNlIG9mIGFcbiAgICogdGVtcG9yYXJ5IGZhaWx1cmUsIGxpa2UgYSBuZXR3b3JrIGVycm9yIG9yIGEgNVhYIGVycm9yIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgbWF4UmV0cmllcz86IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogRGVmYXVsdCBoZWFkZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAqXG4gICAqIFRoZXNlIGNhbiBiZSByZW1vdmVkIGluIGluZGl2aWR1YWwgcmVxdWVzdHMgYnkgZXhwbGljaXRseSBzZXR0aW5nIHRoZVxuICAgKiBoZWFkZXIgdG8gYHVuZGVmaW5lZGAgb3IgYG51bGxgIGluIHJlcXVlc3Qgb3B0aW9ucy5cbiAgICovXG4gIGRlZmF1bHRIZWFkZXJzPzogQ29yZS5IZWFkZXJzIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHF1ZXJ5IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICpcbiAgICogVGhlc2UgY2FuIGJlIHJlbW92ZWQgaW4gaW5kaXZpZHVhbCByZXF1ZXN0cyBieSBleHBsaWNpdGx5IHNldHRpbmcgdGhlXG4gICAqIHBhcmFtIHRvIGB1bmRlZmluZWRgIGluIHJlcXVlc3Qgb3B0aW9ucy5cbiAgICovXG4gIGRlZmF1bHRRdWVyeT86IENvcmUuRGVmYXVsdFF1ZXJ5IHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0LCBjbGllbnQtc2lkZSB1c2Ugb2YgdGhpcyBsaWJyYXJ5IGlzIG5vdCBhbGxvd2VkLCBhcyBpdCByaXNrcyBleHBvc2luZyB5b3VyIHNlY3JldCBBUEkgY3JlZGVudGlhbHMgdG8gYXR0YWNrZXJzLlxuICAgKiBPbmx5IHNldCB0aGlzIG9wdGlvbiB0byBgdHJ1ZWAgaWYgeW91IHVuZGVyc3RhbmQgdGhlIHJpc2tzIGFuZCBoYXZlIGFwcHJvcHJpYXRlIG1pdGlnYXRpb25zIGluIHBsYWNlLlxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI/OiBib29sZWFuIHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEFQSSBDbGllbnQgZm9yIGludGVyZmFjaW5nIHdpdGggdGhlIE9wZW5BSSBBUEkuXG4gKi9cbmV4cG9ydCBjbGFzcyBPcGVuQUkgZXh0ZW5kcyBDb3JlLkFQSUNsaWVudCB7XG4gIGFwaUtleTogc3RyaW5nO1xuICBvcmdhbml6YXRpb246IHN0cmluZyB8IG51bGw7XG4gIHByb2plY3Q6IHN0cmluZyB8IG51bGw7XG5cbiAgcHJpdmF0ZSBfb3B0aW9uczogQ2xpZW50T3B0aW9ucztcblxuICAvKipcbiAgICogQVBJIENsaWVudCBmb3IgaW50ZXJmYWNpbmcgd2l0aCB0aGUgT3BlbkFJIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtvcHRzLmFwaUtleT1wcm9jZXNzLmVudlsnT1BFTkFJX0FQSV9LRVknXSA/PyB1bmRlZmluZWRdXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdHMub3JnYW5pemF0aW9uPXByb2Nlc3MuZW52WydPUEVOQUlfT1JHX0lEJ10gPz8gbnVsbF1cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0cy5wcm9qZWN0PXByb2Nlc3MuZW52WydPUEVOQUlfUFJPSkVDVF9JRCddID8/IG51bGxdXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYXNlVVJMPXByb2Nlc3MuZW52WydPUEVOQUlfQkFTRV9VUkwnXSA/PyBodHRwczovL2FwaS5vcGVuYWkuY29tL3YxXSAtIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGJhc2UgVVJMIGZvciB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZW91dD0xMCBtaW51dGVzXSAtIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRoZSBjbGllbnQgd2lsbCB3YWl0IGZvciBhIHJlc3BvbnNlIGJlZm9yZSB0aW1pbmcgb3V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaHR0cEFnZW50XSAtIEFuIEhUVFAgYWdlbnQgdXNlZCB0byBtYW5hZ2UgSFRUUChzKSBjb25uZWN0aW9ucy5cbiAgICogQHBhcmFtIHtDb3JlLkZldGNofSBbb3B0cy5mZXRjaF0gLSBTcGVjaWZ5IGEgY3VzdG9tIGBmZXRjaGAgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5tYXhSZXRyaWVzPTJdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHRoZSBjbGllbnQgd2lsbCByZXRyeSBhIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7Q29yZS5IZWFkZXJzfSBvcHRzLmRlZmF1bHRIZWFkZXJzIC0gRGVmYXVsdCBoZWFkZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAqIEBwYXJhbSB7Q29yZS5EZWZhdWx0UXVlcnl9IG9wdHMuZGVmYXVsdFF1ZXJ5IC0gRGVmYXVsdCBxdWVyeSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI9ZmFsc2VdIC0gQnkgZGVmYXVsdCwgY2xpZW50LXNpZGUgdXNlIG9mIHRoaXMgbGlicmFyeSBpcyBub3QgYWxsb3dlZCwgYXMgaXQgcmlza3MgZXhwb3NpbmcgeW91ciBzZWNyZXQgQVBJIGNyZWRlbnRpYWxzIHRvIGF0dGFja2Vycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVVJMID0gQ29yZS5yZWFkRW52KCdPUEVOQUlfQkFTRV9VUkwnKSxcbiAgICBhcGlLZXkgPSBDb3JlLnJlYWRFbnYoJ09QRU5BSV9BUElfS0VZJyksXG4gICAgb3JnYW5pemF0aW9uID0gQ29yZS5yZWFkRW52KCdPUEVOQUlfT1JHX0lEJykgPz8gbnVsbCxcbiAgICBwcm9qZWN0ID0gQ29yZS5yZWFkRW52KCdPUEVOQUlfUFJPSkVDVF9JRCcpID8/IG51bGwsXG4gICAgLi4ub3B0c1xuICB9OiBDbGllbnRPcHRpb25zID0ge30pIHtcbiAgICBpZiAoYXBpS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuT3BlbkFJRXJyb3IoXG4gICAgICAgIFwiVGhlIE9QRU5BSV9BUElfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG1pc3Npbmcgb3IgZW1wdHk7IGVpdGhlciBwcm92aWRlIGl0LCBvciBpbnN0YW50aWF0ZSB0aGUgT3BlbkFJIGNsaWVudCB3aXRoIGFuIGFwaUtleSBvcHRpb24sIGxpa2UgbmV3IE9wZW5BSSh7IGFwaUtleTogJ015IEFQSSBLZXknIH0pLlwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zOiBDbGllbnRPcHRpb25zID0ge1xuICAgICAgYXBpS2V5LFxuICAgICAgb3JnYW5pemF0aW9uLFxuICAgICAgcHJvamVjdCxcbiAgICAgIC4uLm9wdHMsXG4gICAgICBiYXNlVVJMOiBiYXNlVVJMIHx8IGBodHRwczovL2FwaS5vcGVuYWkuY29tL3YxYCxcbiAgICB9O1xuXG4gICAgaWYgKCFvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dCcm93c2VyICYmIENvcmUuaXNSdW5uaW5nSW5Ccm93c2VyKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuT3BlbkFJRXJyb3IoXG4gICAgICAgIFwiSXQgbG9va3MgbGlrZSB5b3UncmUgcnVubmluZyBpbiBhIGJyb3dzZXItbGlrZSBlbnZpcm9ubWVudC5cXG5cXG5UaGlzIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGFzIGl0IHJpc2tzIGV4cG9zaW5nIHlvdXIgc2VjcmV0IEFQSSBjcmVkZW50aWFscyB0byBhdHRhY2tlcnMuXFxuSWYgeW91IHVuZGVyc3RhbmQgdGhlIHJpc2tzIGFuZCBoYXZlIGFwcHJvcHJpYXRlIG1pdGlnYXRpb25zIGluIHBsYWNlLFxcbnlvdSBjYW4gc2V0IHRoZSBgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXJgIG9wdGlvbiB0byBgdHJ1ZWAsIGUuZy4sXFxuXFxubmV3IE9wZW5BSSh7IGFwaUtleSwgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI6IHRydWUgfSk7XFxuXFxuaHR0cHM6Ly9oZWxwLm9wZW5haS5jb20vZW4vYXJ0aWNsZXMvNTExMjU5NS1iZXN0LXByYWN0aWNlcy1mb3ItYXBpLWtleS1zYWZldHlcXG5cIixcbiAgICAgICk7XG4gICAgfVxuXG4gICAgc3VwZXIoe1xuICAgICAgYmFzZVVSTDogb3B0aW9ucy5iYXNlVVJMISxcbiAgICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCA/PyA2MDAwMDAgLyogMTAgbWludXRlcyAqLyxcbiAgICAgIGh0dHBBZ2VudDogb3B0aW9ucy5odHRwQWdlbnQsXG4gICAgICBtYXhSZXRyaWVzOiBvcHRpb25zLm1heFJldHJpZXMsXG4gICAgICBmZXRjaDogb3B0aW9ucy5mZXRjaCxcbiAgICB9KTtcblxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgdGhpcy5vcmdhbml6YXRpb24gPSBvcmdhbml6YXRpb247XG4gICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgfVxuXG4gIGNvbXBsZXRpb25zOiBBUEkuQ29tcGxldGlvbnMgPSBuZXcgQVBJLkNvbXBsZXRpb25zKHRoaXMpO1xuICBjaGF0OiBBUEkuQ2hhdCA9IG5ldyBBUEkuQ2hhdCh0aGlzKTtcbiAgZW1iZWRkaW5nczogQVBJLkVtYmVkZGluZ3MgPSBuZXcgQVBJLkVtYmVkZGluZ3ModGhpcyk7XG4gIGZpbGVzOiBBUEkuRmlsZXMgPSBuZXcgQVBJLkZpbGVzKHRoaXMpO1xuICBpbWFnZXM6IEFQSS5JbWFnZXMgPSBuZXcgQVBJLkltYWdlcyh0aGlzKTtcbiAgYXVkaW86IEFQSS5BdWRpbyA9IG5ldyBBUEkuQXVkaW8odGhpcyk7XG4gIG1vZGVyYXRpb25zOiBBUEkuTW9kZXJhdGlvbnMgPSBuZXcgQVBJLk1vZGVyYXRpb25zKHRoaXMpO1xuICBtb2RlbHM6IEFQSS5Nb2RlbHMgPSBuZXcgQVBJLk1vZGVscyh0aGlzKTtcbiAgZmluZVR1bmluZzogQVBJLkZpbmVUdW5pbmcgPSBuZXcgQVBJLkZpbmVUdW5pbmcodGhpcyk7XG4gIGJldGE6IEFQSS5CZXRhID0gbmV3IEFQSS5CZXRhKHRoaXMpO1xuICBiYXRjaGVzOiBBUEkuQmF0Y2hlcyA9IG5ldyBBUEkuQmF0Y2hlcyh0aGlzKTtcbiAgdXBsb2FkczogQVBJLlVwbG9hZHMgPSBuZXcgQVBJLlVwbG9hZHModGhpcyk7XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGRlZmF1bHRRdWVyeSgpOiBDb3JlLkRlZmF1bHRRdWVyeSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZGVmYXVsdFF1ZXJ5O1xuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGRlZmF1bHRIZWFkZXJzKG9wdHM6IENvcmUuRmluYWxSZXF1ZXN0T3B0aW9ucyk6IENvcmUuSGVhZGVycyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmRlZmF1bHRIZWFkZXJzKG9wdHMpLFxuICAgICAgJ09wZW5BSS1Pcmdhbml6YXRpb24nOiB0aGlzLm9yZ2FuaXphdGlvbixcbiAgICAgICdPcGVuQUktUHJvamVjdCc6IHRoaXMucHJvamVjdCxcbiAgICAgIC4uLnRoaXMuX29wdGlvbnMuZGVmYXVsdEhlYWRlcnMsXG4gICAgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBhdXRoSGVhZGVycyhvcHRzOiBDb3JlLkZpbmFsUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkhlYWRlcnMge1xuICAgIHJldHVybiB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLmFwaUtleX1gIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgc3RyaW5naWZ5UXVlcnkocXVlcnk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogc3RyaW5nIHtcbiAgICByZXR1cm4gcXMuc3RyaW5naWZ5KHF1ZXJ5LCB7IGFycmF5Rm9ybWF0OiAnYnJhY2tldHMnIH0pO1xuICB9XG5cbiAgc3RhdGljIE9wZW5BSSA9IHRoaXM7XG4gIHN0YXRpYyBERUZBVUxUX1RJTUVPVVQgPSA2MDAwMDA7IC8vIDEwIG1pbnV0ZXNcblxuICBzdGF0aWMgT3BlbkFJRXJyb3IgPSBFcnJvcnMuT3BlbkFJRXJyb3I7XG4gIHN0YXRpYyBBUElFcnJvciA9IEVycm9ycy5BUElFcnJvcjtcbiAgc3RhdGljIEFQSUNvbm5lY3Rpb25FcnJvciA9IEVycm9ycy5BUElDb25uZWN0aW9uRXJyb3I7XG4gIHN0YXRpYyBBUElDb25uZWN0aW9uVGltZW91dEVycm9yID0gRXJyb3JzLkFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3I7XG4gIHN0YXRpYyBBUElVc2VyQWJvcnRFcnJvciA9IEVycm9ycy5BUElVc2VyQWJvcnRFcnJvcjtcbiAgc3RhdGljIE5vdEZvdW5kRXJyb3IgPSBFcnJvcnMuTm90Rm91bmRFcnJvcjtcbiAgc3RhdGljIENvbmZsaWN0RXJyb3IgPSBFcnJvcnMuQ29uZmxpY3RFcnJvcjtcbiAgc3RhdGljIFJhdGVMaW1pdEVycm9yID0gRXJyb3JzLlJhdGVMaW1pdEVycm9yO1xuICBzdGF0aWMgQmFkUmVxdWVzdEVycm9yID0gRXJyb3JzLkJhZFJlcXVlc3RFcnJvcjtcbiAgc3RhdGljIEF1dGhlbnRpY2F0aW9uRXJyb3IgPSBFcnJvcnMuQXV0aGVudGljYXRpb25FcnJvcjtcbiAgc3RhdGljIEludGVybmFsU2VydmVyRXJyb3IgPSBFcnJvcnMuSW50ZXJuYWxTZXJ2ZXJFcnJvcjtcbiAgc3RhdGljIFBlcm1pc3Npb25EZW5pZWRFcnJvciA9IEVycm9ycy5QZXJtaXNzaW9uRGVuaWVkRXJyb3I7XG4gIHN0YXRpYyBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IgPSBFcnJvcnMuVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yO1xuXG4gIHN0YXRpYyB0b0ZpbGUgPSBVcGxvYWRzLnRvRmlsZTtcbiAgc3RhdGljIGZpbGVGcm9tUGF0aCA9IFVwbG9hZHMuZmlsZUZyb21QYXRoO1xufVxuXG5PcGVuQUkuQ29tcGxldGlvbnMgPSBDb21wbGV0aW9ucztcbk9wZW5BSS5DaGF0ID0gQ2hhdDtcbk9wZW5BSS5FbWJlZGRpbmdzID0gRW1iZWRkaW5ncztcbk9wZW5BSS5GaWxlcyA9IEZpbGVzO1xuT3BlbkFJLkZpbGVPYmplY3RzUGFnZSA9IEZpbGVPYmplY3RzUGFnZTtcbk9wZW5BSS5JbWFnZXMgPSBJbWFnZXM7XG5PcGVuQUkuQXVkaW8gPSBBdWRpbztcbk9wZW5BSS5Nb2RlcmF0aW9ucyA9IE1vZGVyYXRpb25zO1xuT3BlbkFJLk1vZGVscyA9IE1vZGVscztcbk9wZW5BSS5Nb2RlbHNQYWdlID0gTW9kZWxzUGFnZTtcbk9wZW5BSS5GaW5lVHVuaW5nID0gRmluZVR1bmluZztcbk9wZW5BSS5CZXRhID0gQmV0YTtcbk9wZW5BSS5CYXRjaGVzID0gQmF0Y2hlcztcbk9wZW5BSS5CYXRjaGVzUGFnZSA9IEJhdGNoZXNQYWdlO1xuT3BlbkFJLlVwbG9hZHMgPSBVcGxvYWRzQVBJVXBsb2FkcztcbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBPcGVuQUkge1xuICBleHBvcnQgdHlwZSBSZXF1ZXN0T3B0aW9ucyA9IENvcmUuUmVxdWVzdE9wdGlvbnM7XG5cbiAgZXhwb3J0IGltcG9ydCBQYWdlID0gUGFnaW5hdGlvbi5QYWdlO1xuICBleHBvcnQgeyB0eXBlIFBhZ2VSZXNwb25zZSBhcyBQYWdlUmVzcG9uc2UgfTtcblxuICBleHBvcnQgaW1wb3J0IEN1cnNvclBhZ2UgPSBQYWdpbmF0aW9uLkN1cnNvclBhZ2U7XG4gIGV4cG9ydCB7IHR5cGUgQ3Vyc29yUGFnZVBhcmFtcyBhcyBDdXJzb3JQYWdlUGFyYW1zLCB0eXBlIEN1cnNvclBhZ2VSZXNwb25zZSBhcyBDdXJzb3JQYWdlUmVzcG9uc2UgfTtcblxuICBleHBvcnQge1xuICAgIENvbXBsZXRpb25zIGFzIENvbXBsZXRpb25zLFxuICAgIHR5cGUgQ29tcGxldGlvbiBhcyBDb21wbGV0aW9uLFxuICAgIHR5cGUgQ29tcGxldGlvbkNob2ljZSBhcyBDb21wbGV0aW9uQ2hvaWNlLFxuICAgIHR5cGUgQ29tcGxldGlvblVzYWdlIGFzIENvbXBsZXRpb25Vc2FnZSxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXMgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyxcbiAgICB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgYXMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIENoYXQgYXMgQ2hhdCxcbiAgICB0eXBlIENoYXRNb2RlbCBhcyBDaGF0TW9kZWwsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbiBhcyBDaGF0Q29tcGxldGlvbixcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uQXNzaXN0YW50TWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25BdWRpbyBhcyBDaGF0Q29tcGxldGlvbkF1ZGlvLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25BdWRpb1BhcmFtIGFzIENoYXRDb21wbGV0aW9uQXVkaW9QYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ2h1bmsgYXMgQ2hhdENvbXBsZXRpb25DaHVuayxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnQgYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRJbWFnZSBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW1hZ2UsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW5wdXRBdWRpbyBhcyBDaGF0Q29tcGxldGlvbkNvbnRlbnRQYXJ0SW5wdXRBdWRpbyxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRSZWZ1c2FsIGFzIENoYXRDb21wbGV0aW9uQ29udGVudFBhcnRSZWZ1c2FsLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQgYXMgQ2hhdENvbXBsZXRpb25Db250ZW50UGFydFRleHQsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkRldmVsb3Blck1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvbkRldmVsb3Blck1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uRnVuY3Rpb25DYWxsT3B0aW9uIGFzIENoYXRDb21wbGV0aW9uRnVuY3Rpb25DYWxsT3B0aW9uLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25GdW5jdGlvbk1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvbkZ1bmN0aW9uTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlIGFzIENoYXRDb21wbGV0aW9uTWVzc2FnZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwgYXMgQ2hhdENvbXBsZXRpb25NZXNzYWdlVG9vbENhbGwsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk1vZGFsaXR5IGFzIENoYXRDb21wbGV0aW9uTW9kYWxpdHksXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbk5hbWVkVG9vbENob2ljZSBhcyBDaGF0Q29tcGxldGlvbk5hbWVkVG9vbENob2ljZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uUHJlZGljdGlvbkNvbnRlbnQgYXMgQ2hhdENvbXBsZXRpb25QcmVkaWN0aW9uQ29udGVudCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uUmVhc29uaW5nRWZmb3J0IGFzIENoYXRDb21wbGV0aW9uUmVhc29uaW5nRWZmb3J0LFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Sb2xlIGFzIENoYXRDb21wbGV0aW9uUm9sZSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uU3RyZWFtT3B0aW9ucyBhcyBDaGF0Q29tcGxldGlvblN0cmVhbU9wdGlvbnMsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblN5c3RlbU1lc3NhZ2VQYXJhbSBhcyBDaGF0Q29tcGxldGlvblN5c3RlbU1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iIGFzIENoYXRDb21wbGV0aW9uVG9rZW5Mb2dwcm9iLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Ub29sIGFzIENoYXRDb21wbGV0aW9uVG9vbCxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uVG9vbENob2ljZU9wdGlvbiBhcyBDaGF0Q29tcGxldGlvblRvb2xDaG9pY2VPcHRpb24sXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvblRvb2xNZXNzYWdlUGFyYW0gYXMgQ2hhdENvbXBsZXRpb25Ub29sTWVzc2FnZVBhcmFtLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25Vc2VyTWVzc2FnZVBhcmFtIGFzIENoYXRDb21wbGV0aW9uVXNlck1lc3NhZ2VQYXJhbSxcbiAgICB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIGFzIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgYXMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyBhcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIEVtYmVkZGluZ3MgYXMgRW1iZWRkaW5ncyxcbiAgICB0eXBlIENyZWF0ZUVtYmVkZGluZ1Jlc3BvbnNlIGFzIENyZWF0ZUVtYmVkZGluZ1Jlc3BvbnNlLFxuICAgIHR5cGUgRW1iZWRkaW5nIGFzIEVtYmVkZGluZyxcbiAgICB0eXBlIEVtYmVkZGluZ01vZGVsIGFzIEVtYmVkZGluZ01vZGVsLFxuICAgIHR5cGUgRW1iZWRkaW5nQ3JlYXRlUGFyYW1zIGFzIEVtYmVkZGluZ0NyZWF0ZVBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIEZpbGVzIGFzIEZpbGVzLFxuICAgIHR5cGUgRmlsZUNvbnRlbnQgYXMgRmlsZUNvbnRlbnQsXG4gICAgdHlwZSBGaWxlRGVsZXRlZCBhcyBGaWxlRGVsZXRlZCxcbiAgICB0eXBlIEZpbGVPYmplY3QgYXMgRmlsZU9iamVjdCxcbiAgICB0eXBlIEZpbGVQdXJwb3NlIGFzIEZpbGVQdXJwb3NlLFxuICAgIEZpbGVPYmplY3RzUGFnZSBhcyBGaWxlT2JqZWN0c1BhZ2UsXG4gICAgdHlwZSBGaWxlQ3JlYXRlUGFyYW1zIGFzIEZpbGVDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBGaWxlTGlzdFBhcmFtcyBhcyBGaWxlTGlzdFBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIEltYWdlcyBhcyBJbWFnZXMsXG4gICAgdHlwZSBJbWFnZSBhcyBJbWFnZSxcbiAgICB0eXBlIEltYWdlTW9kZWwgYXMgSW1hZ2VNb2RlbCxcbiAgICB0eXBlIEltYWdlc1Jlc3BvbnNlIGFzIEltYWdlc1Jlc3BvbnNlLFxuICAgIHR5cGUgSW1hZ2VDcmVhdGVWYXJpYXRpb25QYXJhbXMgYXMgSW1hZ2VDcmVhdGVWYXJpYXRpb25QYXJhbXMsXG4gICAgdHlwZSBJbWFnZUVkaXRQYXJhbXMgYXMgSW1hZ2VFZGl0UGFyYW1zLFxuICAgIHR5cGUgSW1hZ2VHZW5lcmF0ZVBhcmFtcyBhcyBJbWFnZUdlbmVyYXRlUGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7IEF1ZGlvIGFzIEF1ZGlvLCB0eXBlIEF1ZGlvTW9kZWwgYXMgQXVkaW9Nb2RlbCwgdHlwZSBBdWRpb1Jlc3BvbnNlRm9ybWF0IGFzIEF1ZGlvUmVzcG9uc2VGb3JtYXQgfTtcblxuICBleHBvcnQge1xuICAgIE1vZGVyYXRpb25zIGFzIE1vZGVyYXRpb25zLFxuICAgIHR5cGUgTW9kZXJhdGlvbiBhcyBNb2RlcmF0aW9uLFxuICAgIHR5cGUgTW9kZXJhdGlvbkltYWdlVVJMSW5wdXQgYXMgTW9kZXJhdGlvbkltYWdlVVJMSW5wdXQsXG4gICAgdHlwZSBNb2RlcmF0aW9uTW9kZWwgYXMgTW9kZXJhdGlvbk1vZGVsLFxuICAgIHR5cGUgTW9kZXJhdGlvbk11bHRpTW9kYWxJbnB1dCBhcyBNb2RlcmF0aW9uTXVsdGlNb2RhbElucHV0LFxuICAgIHR5cGUgTW9kZXJhdGlvblRleHRJbnB1dCBhcyBNb2RlcmF0aW9uVGV4dElucHV0LFxuICAgIHR5cGUgTW9kZXJhdGlvbkNyZWF0ZVJlc3BvbnNlIGFzIE1vZGVyYXRpb25DcmVhdGVSZXNwb25zZSxcbiAgICB0eXBlIE1vZGVyYXRpb25DcmVhdGVQYXJhbXMgYXMgTW9kZXJhdGlvbkNyZWF0ZVBhcmFtcyxcbiAgfTtcblxuICBleHBvcnQge1xuICAgIE1vZGVscyBhcyBNb2RlbHMsXG4gICAgdHlwZSBNb2RlbCBhcyBNb2RlbCxcbiAgICB0eXBlIE1vZGVsRGVsZXRlZCBhcyBNb2RlbERlbGV0ZWQsXG4gICAgTW9kZWxzUGFnZSBhcyBNb2RlbHNQYWdlLFxuICB9O1xuXG4gIGV4cG9ydCB7IEZpbmVUdW5pbmcgYXMgRmluZVR1bmluZyB9O1xuXG4gIGV4cG9ydCB7IEJldGEgYXMgQmV0YSB9O1xuXG4gIGV4cG9ydCB7XG4gICAgQmF0Y2hlcyBhcyBCYXRjaGVzLFxuICAgIHR5cGUgQmF0Y2ggYXMgQmF0Y2gsXG4gICAgdHlwZSBCYXRjaEVycm9yIGFzIEJhdGNoRXJyb3IsXG4gICAgdHlwZSBCYXRjaFJlcXVlc3RDb3VudHMgYXMgQmF0Y2hSZXF1ZXN0Q291bnRzLFxuICAgIEJhdGNoZXNQYWdlIGFzIEJhdGNoZXNQYWdlLFxuICAgIHR5cGUgQmF0Y2hDcmVhdGVQYXJhbXMgYXMgQmF0Y2hDcmVhdGVQYXJhbXMsXG4gICAgdHlwZSBCYXRjaExpc3RQYXJhbXMgYXMgQmF0Y2hMaXN0UGFyYW1zLFxuICB9O1xuXG4gIGV4cG9ydCB7XG4gICAgVXBsb2Fkc0FQSVVwbG9hZHMgYXMgVXBsb2FkcyxcbiAgICB0eXBlIFVwbG9hZCBhcyBVcGxvYWQsXG4gICAgdHlwZSBVcGxvYWRDcmVhdGVQYXJhbXMgYXMgVXBsb2FkQ3JlYXRlUGFyYW1zLFxuICAgIHR5cGUgVXBsb2FkQ29tcGxldGVQYXJhbXMgYXMgVXBsb2FkQ29tcGxldGVQYXJhbXMsXG4gIH07XG5cbiAgZXhwb3J0IHR5cGUgRXJyb3JPYmplY3QgPSBBUEkuRXJyb3JPYmplY3Q7XG4gIGV4cG9ydCB0eXBlIEZ1bmN0aW9uRGVmaW5pdGlvbiA9IEFQSS5GdW5jdGlvbkRlZmluaXRpb247XG4gIGV4cG9ydCB0eXBlIEZ1bmN0aW9uUGFyYW1ldGVycyA9IEFQSS5GdW5jdGlvblBhcmFtZXRlcnM7XG4gIGV4cG9ydCB0eXBlIFJlc3BvbnNlRm9ybWF0SlNPTk9iamVjdCA9IEFQSS5SZXNwb25zZUZvcm1hdEpTT05PYmplY3Q7XG4gIGV4cG9ydCB0eXBlIFJlc3BvbnNlRm9ybWF0SlNPTlNjaGVtYSA9IEFQSS5SZXNwb25zZUZvcm1hdEpTT05TY2hlbWE7XG4gIGV4cG9ydCB0eXBlIFJlc3BvbnNlRm9ybWF0VGV4dCA9IEFQSS5SZXNwb25zZUZvcm1hdFRleHQ7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQXp1cmUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKiogQVBJIENsaWVudCBmb3IgaW50ZXJmYWNpbmcgd2l0aCB0aGUgQXp1cmUgT3BlbkFJIEFQSS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXp1cmVDbGllbnRPcHRpb25zIGV4dGVuZHMgQ2xpZW50T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBwcm9jZXNzLmVudlsnT1BFTkFJX0FQSV9WRVJTSU9OJ10uXG4gICAqL1xuICBhcGlWZXJzaW9uPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBZb3VyIEF6dXJlIGVuZHBvaW50LCBpbmNsdWRpbmcgdGhlIHJlc291cmNlLCBlLmcuIGBodHRwczovL2V4YW1wbGUtcmVzb3VyY2UuYXp1cmUub3BlbmFpLmNvbS9gXG4gICAqL1xuICBlbmRwb2ludD86IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQSBtb2RlbCBkZXBsb3ltZW50LCBpZiBnaXZlbiwgc2V0cyB0aGUgYmFzZSBjbGllbnQgVVJMIHRvIGluY2x1ZGUgYC9kZXBsb3ltZW50cy97ZGVwbG95bWVudH1gLlxuICAgKiBOb3RlOiB0aGlzIG1lYW5zIHlvdSB3b24ndCBiZSBhYmxlIHRvIHVzZSBub24tZGVwbG95bWVudCBlbmRwb2ludHMuIE5vdCBzdXBwb3J0ZWQgd2l0aCBBc3Npc3RhbnRzIEFQSXMuXG4gICAqL1xuICBkZXBsb3ltZW50Pzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBwcm9jZXNzLmVudlsnQVpVUkVfT1BFTkFJX0FQSV9LRVknXS5cbiAgICovXG4gIGFwaUtleT86IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gYWNjZXNzIHRva2VuIGZvciBNaWNyb3NvZnQgRW50cmEgKGZvcm1lcmx5IGtub3duIGFzIEF6dXJlIEFjdGl2ZSBEaXJlY3RvcnkpLFxuICAgKiB3aGljaCB3aWxsIGJlIGludm9rZWQgb24gZXZlcnkgcmVxdWVzdC5cbiAgICovXG4gIGF6dXJlQURUb2tlblByb3ZpZGVyPzogKCgpID0+IFByb21pc2U8c3RyaW5nPikgfCB1bmRlZmluZWQ7XG59XG5cbi8qKiBBUEkgQ2xpZW50IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBBenVyZSBPcGVuQUkgQVBJLiAqL1xuZXhwb3J0IGNsYXNzIEF6dXJlT3BlbkFJIGV4dGVuZHMgT3BlbkFJIHtcbiAgcHJpdmF0ZSBfYXp1cmVBRFRva2VuUHJvdmlkZXI6ICgoKSA9PiBQcm9taXNlPHN0cmluZz4pIHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIF9kZXBsb3ltZW50OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGFwaVZlcnNpb246IHN0cmluZyA9ICcnO1xuICAvKipcbiAgICogQVBJIENsaWVudCBmb3IgaW50ZXJmYWNpbmcgd2l0aCB0aGUgQXp1cmUgT3BlbkFJIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtvcHRzLmFwaVZlcnNpb249cHJvY2Vzcy5lbnZbJ09QRU5BSV9BUElfVkVSU0lPTiddID8/IHVuZGVmaW5lZF1cbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtvcHRzLmVuZHBvaW50PXByb2Nlc3MuZW52WydBWlVSRV9PUEVOQUlfRU5EUE9JTlQnXSA/PyB1bmRlZmluZWRdIC0gWW91ciBBenVyZSBlbmRwb2ludCwgaW5jbHVkaW5nIHRoZSByZXNvdXJjZSwgZS5nLiBgaHR0cHM6Ly9leGFtcGxlLXJlc291cmNlLmF6dXJlLm9wZW5haS5jb20vYFxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW29wdHMuYXBpS2V5PXByb2Nlc3MuZW52WydBWlVSRV9PUEVOQUlfQVBJX0tFWSddID8/IHVuZGVmaW5lZF1cbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IG9wdHMuZGVwbG95bWVudCAtIEEgbW9kZWwgZGVwbG95bWVudCwgaWYgZ2l2ZW4sIHNldHMgdGhlIGJhc2UgY2xpZW50IFVSTCB0byBpbmNsdWRlIGAvZGVwbG95bWVudHMve2RlcGxveW1lbnR9YC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0cy5vcmdhbml6YXRpb249cHJvY2Vzcy5lbnZbJ09QRU5BSV9PUkdfSUQnXSA/PyBudWxsXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFzZVVSTD1wcm9jZXNzLmVudlsnT1BFTkFJX0JBU0VfVVJMJ11dIC0gU2V0cyB0aGUgYmFzZSBVUkwgZm9yIHRoZSBBUEksIGUuZy4gYGh0dHBzOi8vZXhhbXBsZS1yZXNvdXJjZS5henVyZS5vcGVuYWkuY29tL29wZW5haS9gLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZW91dD0xMCBtaW51dGVzXSAtIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRoZSBjbGllbnQgd2lsbCB3YWl0IGZvciBhIHJlc3BvbnNlIGJlZm9yZSB0aW1pbmcgb3V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaHR0cEFnZW50XSAtIEFuIEhUVFAgYWdlbnQgdXNlZCB0byBtYW5hZ2UgSFRUUChzKSBjb25uZWN0aW9ucy5cbiAgICogQHBhcmFtIHtDb3JlLkZldGNofSBbb3B0cy5mZXRjaF0gLSBTcGVjaWZ5IGEgY3VzdG9tIGBmZXRjaGAgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5tYXhSZXRyaWVzPTJdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHRoZSBjbGllbnQgd2lsbCByZXRyeSBhIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7Q29yZS5IZWFkZXJzfSBvcHRzLmRlZmF1bHRIZWFkZXJzIC0gRGVmYXVsdCBoZWFkZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAqIEBwYXJhbSB7Q29yZS5EZWZhdWx0UXVlcnl9IG9wdHMuZGVmYXVsdFF1ZXJ5IC0gRGVmYXVsdCBxdWVyeSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI9ZmFsc2VdIC0gQnkgZGVmYXVsdCwgY2xpZW50LXNpZGUgdXNlIG9mIHRoaXMgbGlicmFyeSBpcyBub3QgYWxsb3dlZCwgYXMgaXQgcmlza3MgZXhwb3NpbmcgeW91ciBzZWNyZXQgQVBJIGNyZWRlbnRpYWxzIHRvIGF0dGFja2Vycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVVJMID0gQ29yZS5yZWFkRW52KCdPUEVOQUlfQkFTRV9VUkwnKSxcbiAgICBhcGlLZXkgPSBDb3JlLnJlYWRFbnYoJ0FaVVJFX09QRU5BSV9BUElfS0VZJyksXG4gICAgYXBpVmVyc2lvbiA9IENvcmUucmVhZEVudignT1BFTkFJX0FQSV9WRVJTSU9OJyksXG4gICAgZW5kcG9pbnQsXG4gICAgZGVwbG95bWVudCxcbiAgICBhenVyZUFEVG9rZW5Qcm92aWRlcixcbiAgICBkYW5nZXJvdXNseUFsbG93QnJvd3NlcixcbiAgICAuLi5vcHRzXG4gIH06IEF6dXJlQ2xpZW50T3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFhcGlWZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKFxuICAgICAgICBcIlRoZSBPUEVOQUlfQVBJX1ZFUlNJT04gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbWlzc2luZyBvciBlbXB0eTsgZWl0aGVyIHByb3ZpZGUgaXQsIG9yIGluc3RhbnRpYXRlIHRoZSBBenVyZU9wZW5BSSBjbGllbnQgd2l0aCBhbiBhcGlWZXJzaW9uIG9wdGlvbiwgbGlrZSBuZXcgQXp1cmVPcGVuQUkoeyBhcGlWZXJzaW9uOiAnTXkgQVBJIFZlcnNpb24nIH0pLlwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGF6dXJlQURUb2tlblByb3ZpZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkYW5nZXJvdXNseUFsbG93QnJvd3NlciA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFhenVyZUFEVG9rZW5Qcm92aWRlciAmJiAhYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKFxuICAgICAgICAnTWlzc2luZyBjcmVkZW50aWFscy4gUGxlYXNlIHBhc3Mgb25lIG9mIGBhcGlLZXlgIGFuZCBgYXp1cmVBRFRva2VuUHJvdmlkZXJgLCBvciBzZXQgdGhlIGBBWlVSRV9PUEVOQUlfQVBJX0tFWWAgZW52aXJvbm1lbnQgdmFyaWFibGUuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGF6dXJlQURUb2tlblByb3ZpZGVyICYmIGFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcihcbiAgICAgICAgJ1RoZSBgYXBpS2V5YCBhbmQgYGF6dXJlQURUb2tlblByb3ZpZGVyYCBhcmd1bWVudHMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZTsgb25seSBvbmUgY2FuIGJlIHBhc3NlZCBhdCBhIHRpbWUuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZGVmaW5lIGEgc2VudGluZWwgdmFsdWUgdG8gYXZvaWQgYW55IHR5cGluZyBpc3N1ZXNcbiAgICBhcGlLZXkgPz89IEFQSV9LRVlfU0VOVElORUw7XG5cbiAgICBvcHRzLmRlZmF1bHRRdWVyeSA9IHsgLi4ub3B0cy5kZWZhdWx0UXVlcnksICdhcGktdmVyc2lvbic6IGFwaVZlcnNpb24gfTtcblxuICAgIGlmICghYmFzZVVSTCkge1xuICAgICAgaWYgKCFlbmRwb2ludCkge1xuICAgICAgICBlbmRwb2ludCA9IHByb2Nlc3MuZW52WydBWlVSRV9PUEVOQUlfRU5EUE9JTlQnXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbmRwb2ludCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKFxuICAgICAgICAgICdNdXN0IHByb3ZpZGUgb25lIG9mIHRoZSBgYmFzZVVSTGAgb3IgYGVuZHBvaW50YCBhcmd1bWVudHMsIG9yIHRoZSBgQVpVUkVfT1BFTkFJX0VORFBPSU5UYCBlbnZpcm9ubWVudCB2YXJpYWJsZScsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGJhc2VVUkwgPSBgJHtlbmRwb2ludH0vb3BlbmFpYDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVuZHBvaW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcnMuT3BlbkFJRXJyb3IoJ2Jhc2VVUkwgYW5kIGVuZHBvaW50IGFyZSBtdXR1YWxseSBleGNsdXNpdmUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdXBlcih7XG4gICAgICBhcGlLZXksXG4gICAgICBiYXNlVVJMLFxuICAgICAgLi4ub3B0cyxcbiAgICAgIC4uLihkYW5nZXJvdXNseUFsbG93QnJvd3NlciAhPT0gdW5kZWZpbmVkID8geyBkYW5nZXJvdXNseUFsbG93QnJvd3NlciB9IDoge30pLFxuICAgIH0pO1xuXG4gICAgdGhpcy5fYXp1cmVBRFRva2VuUHJvdmlkZXIgPSBhenVyZUFEVG9rZW5Qcm92aWRlcjtcbiAgICB0aGlzLmFwaVZlcnNpb24gPSBhcGlWZXJzaW9uO1xuICAgIHRoaXMuX2RlcGxveW1lbnQgPSBkZXBsb3ltZW50O1xuICB9XG5cbiAgb3ZlcnJpZGUgYnVpbGRSZXF1ZXN0KG9wdGlvbnM6IENvcmUuRmluYWxSZXF1ZXN0T3B0aW9uczx1bmtub3duPik6IHtcbiAgICByZXE6IFJlcXVlc3RJbml0O1xuICAgIHVybDogc3RyaW5nO1xuICAgIHRpbWVvdXQ6IG51bWJlcjtcbiAgfSB7XG4gICAgaWYgKF9kZXBsb3ltZW50c19lbmRwb2ludHMuaGFzKG9wdGlvbnMucGF0aCkgJiYgb3B0aW9ucy5tZXRob2QgPT09ICdwb3N0JyAmJiBvcHRpb25zLmJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFDb3JlLmlzT2JqKG9wdGlvbnMuYm9keSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZXF1ZXN0IGJvZHkgdG8gYmUgYW4gb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX2RlcGxveW1lbnQgfHwgb3B0aW9ucy5ib2R5Wydtb2RlbCddO1xuICAgICAgaWYgKG1vZGVsICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuYmFzZVVSTC5pbmNsdWRlcygnL2RlcGxveW1lbnRzJykpIHtcbiAgICAgICAgb3B0aW9ucy5wYXRoID0gYC9kZXBsb3ltZW50cy8ke21vZGVsfSR7b3B0aW9ucy5wYXRofWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5idWlsZFJlcXVlc3Qob3B0aW9ucyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9nZXRBenVyZUFEVG9rZW4oKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2F6dXJlQURUb2tlblByb3ZpZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHRoaXMuX2F6dXJlQURUb2tlblByb3ZpZGVyKCk7XG4gICAgICBpZiAoIXRva2VuIHx8IHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgJ2F6dXJlQURUb2tlblByb3ZpZGVyJyBhcmd1bWVudCB0byByZXR1cm4gYSBzdHJpbmcgYnV0IGl0IHJldHVybmVkICR7dG9rZW59YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBhdXRoSGVhZGVycyhvcHRzOiBDb3JlLkZpbmFsUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkhlYWRlcnMge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBhc3luYyBwcmVwYXJlT3B0aW9ucyhvcHRzOiBDb3JlLkZpbmFsUmVxdWVzdE9wdGlvbnM8dW5rbm93bj4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdXNlciBzaG91bGQgcHJvdmlkZSBhIGJlYXJlciB0b2tlbiBwcm92aWRlciBpZiB0aGV5IHdhbnRcbiAgICAgKiB0byB1c2UgQXp1cmUgQUQgYXV0aGVudGljYXRpb24uIFRoZSB1c2VyIHNob3VsZG4ndCBzZXQgdGhlXG4gICAgICogQXV0aG9yaXphdGlvbiBoZWFkZXIgbWFudWFsbHkgYmVjYXVzZSB0aGUgaGVhZGVyIGlzIG92ZXJ3cml0dGVuXG4gICAgICogd2l0aCB0aGUgQXp1cmUgQUQgdG9rZW4gaWYgYSBiZWFyZXIgdG9rZW4gcHJvdmlkZXIgaXMgcHJvdmlkZWQuXG4gICAgICovXG4gICAgaWYgKG9wdHMuaGVhZGVycz8uWydhcGkta2V5J10pIHtcbiAgICAgIHJldHVybiBzdXBlci5wcmVwYXJlT3B0aW9ucyhvcHRzKTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLl9nZXRBenVyZUFEVG9rZW4oKTtcbiAgICBvcHRzLmhlYWRlcnMgPz89IHt9O1xuICAgIGlmICh0b2tlbikge1xuICAgICAgb3B0cy5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dG9rZW59YDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYXBpS2V5ICE9PSBBUElfS0VZX1NFTlRJTkVMKSB7XG4gICAgICBvcHRzLmhlYWRlcnNbJ2FwaS1rZXknXSA9IHRoaXMuYXBpS2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKCdVbmFibGUgdG8gaGFuZGxlIGF1dGgnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnByZXBhcmVPcHRpb25zKG9wdHMpO1xuICB9XG59XG5cbmNvbnN0IF9kZXBsb3ltZW50c19lbmRwb2ludHMgPSBuZXcgU2V0KFtcbiAgJy9jb21wbGV0aW9ucycsXG4gICcvY2hhdC9jb21wbGV0aW9ucycsXG4gICcvZW1iZWRkaW5ncycsXG4gICcvYXVkaW8vdHJhbnNjcmlwdGlvbnMnLFxuICAnL2F1ZGlvL3RyYW5zbGF0aW9ucycsXG4gICcvYXVkaW8vc3BlZWNoJyxcbiAgJy9pbWFnZXMvZ2VuZXJhdGlvbnMnLFxuXSk7XG5cbmNvbnN0IEFQSV9LRVlfU0VOVElORUwgPSAnPE1pc3NpbmcgS2V5Pic7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRW5kIEF6dXJlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IHsgdG9GaWxlLCBmaWxlRnJvbVBhdGggfSBmcm9tICcuL3VwbG9hZHMnO1xuZXhwb3J0IHtcbiAgT3BlbkFJRXJyb3IsXG4gIEFQSUVycm9yLFxuICBBUElDb25uZWN0aW9uRXJyb3IsXG4gIEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IsXG4gIEFQSVVzZXJBYm9ydEVycm9yLFxuICBOb3RGb3VuZEVycm9yLFxuICBDb25mbGljdEVycm9yLFxuICBSYXRlTGltaXRFcnJvcixcbiAgQmFkUmVxdWVzdEVycm9yLFxuICBBdXRoZW50aWNhdGlvbkVycm9yLFxuICBJbnRlcm5hbFNlcnZlckVycm9yLFxuICBQZXJtaXNzaW9uRGVuaWVkRXJyb3IsXG4gIFVucHJvY2Vzc2FibGVFbnRpdHlFcnJvcixcbn0gZnJvbSAnLi9lcnJvcic7XG5cbmV4cG9ydCBkZWZhdWx0IE9wZW5BSTtcbiIsICJpbXBvcnQgT3BlbkFJIGZyb20gJ29wZW5haSc7XG5pbXBvcnQgeyBFbWJlZGRpbmdSZXNwb25zZSB9IGZyb20gJy4uL21vZGVscy9Eb2N1bWVudENodW5rJztcbmltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEVycm9ySGFuZGxlciB9IGZyb20gJy4uL3V0aWxzL0Vycm9ySGFuZGxlcic7XG5pbXBvcnQgeyBPcGVuQUlTZXR0aW5ncyB9IGZyb20gJy4uL3NldHRpbmdzL1NldHRpbmdzJztcblxuZXhwb3J0IGNsYXNzIE9wZW5BSVNlcnZpY2Uge1xuXHRwcml2YXRlIGNsaWVudDogT3BlbkFJIHwgbnVsbDtcblx0cHJpdmF0ZSByYXRlTGltaXREZWxheTogbnVtYmVyID0gMjA7IC8vIG1zIGJldHdlZW4gcmVxdWVzdHNcblx0cHJpdmF0ZSBsYXN0UmVxdWVzdFRpbWU6IG51bWJlciA9IDA7XG5cdHByaXZhdGUgcmVhZG9ubHkgZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXI7XG5cdHByaXZhdGUgc2V0dGluZ3M6IE9wZW5BSVNldHRpbmdzO1xuXG5cdGNvbnN0cnVjdG9yKHNldHRpbmdzOiBPcGVuQUlTZXR0aW5ncywgZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXIpIHtcblx0XHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG5cdFx0dGhpcy5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG5cblx0XHRpZiAoIXNldHRpbmdzLmFwaUtleSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdPcGVuQUkgQVBJIGtleSBpcyBtaXNzaW5nLiBPcGVuQUlTZXJ2aWNlIHdpbGwgbm90IGJlIGluaXRpYWxpemVkLicpO1xuXHRcdFx0dGhpcy5jbGllbnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEluaXRpYWxpemUgT3BlbkFJIGNsaWVudCB3aXRoIGJyb3dzZXIgc3VwcG9ydFxuXHRcdHRoaXMuY2xpZW50ID0gbmV3IE9wZW5BSSh7XG5cdFx0XHRhcGlLZXk6IHNldHRpbmdzLmFwaUtleSxcblx0XHRcdGRhbmdlcm91c2x5QWxsb3dCcm93c2VyOiB0cnVlLCAvLyBFbmFibGUgYnJvd3Nlci1saWtlIGVudmlyb25tZW50IHVzYWdlXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhlIHNlcnZpY2UgaXMgaW5pdGlhbGl6ZWRcblx0ICovXG5cdHB1YmxpYyBpc0luaXRpYWxpemVkKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLmNsaWVudCAhPT0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGVtYmVkZGluZ3MgZm9yIHRoZSBnaXZlbiB0ZXh0IGNodW5rcyB3aXRoIHJhdGUgbGltaXRpbmcgYW5kIHJldHJpZXNcblx0ICovXG5cdGFzeW5jIGNyZWF0ZUVtYmVkZGluZ3MoY2h1bmtzOiBzdHJpbmdbXSk6IFByb21pc2U8RW1iZWRkaW5nUmVzcG9uc2VbXT4ge1xuXHRcdGlmICghdGhpcy5jbGllbnQpIHtcblx0XHRcdGNvbnNvbGUud2FybignT3BlbkFJU2VydmljZSBpcyBub3QgaW5pdGlhbGl6ZWQuIENhbm5vdCBjcmVhdGUgZW1iZWRkaW5ncy4nKTtcblx0XHRcdG5ldyBOb3RpY2UoJ09wZW5BSSBBUEkga2V5IGlzIG1pc3NpbmcuIFBsZWFzZSBzZXQgaXQgaW4gdGhlIHBsdWdpbiBzZXR0aW5ncy4nKTtcblx0XHRcdHJldHVybiBjaHVua3MubWFwKCgpID0+ICh7XG5cdFx0XHRcdGRhdGE6IFtdLFxuXHRcdFx0XHR1c2FnZTogeyBwcm9tcHRfdG9rZW5zOiAwLCB0b3RhbF90b2tlbnM6IDAgfSxcblx0XHRcdFx0bW9kZWw6IFwidGV4dC1lbWJlZGRpbmctYWRhLTAwMlwiLCAvLyBEZWZhdWx0IG1vZGVsIHRvIG1haW50YWluIG91dHB1dCBjb25zaXN0ZW5jeVxuXHRcdFx0fSkpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGVtYmVkZGluZ3M6IEVtYmVkZGluZ1Jlc3BvbnNlW10gPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgdGltZVNpbmNlTGFzdFJlcXVlc3QgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0UmVxdWVzdFRpbWU7XG5cdFx0XHRcdGlmICh0aW1lU2luY2VMYXN0UmVxdWVzdCA8IHRoaXMucmF0ZUxpbWl0RGVsYXkpIHtcblx0XHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KHJlc29sdmUsIHRoaXMucmF0ZUxpbWl0RGVsYXkgLSB0aW1lU2luY2VMYXN0UmVxdWVzdClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRXhwbGljaXRseSBzZXQgdGhlIG1vZGVsIHRvIGB0ZXh0LWVtYmVkZGluZy1hZGEtMDAyYFxuXHRcdFx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LmVtYmVkZGluZ3MuY3JlYXRlKHtcblx0XHRcdFx0XHRtb2RlbDogXCJ0ZXh0LWVtYmVkZGluZy1hZGEtMDAyXCIsIC8vIFVzZSB0aGUgY29ycmVjdCBtb2RlbFxuXHRcdFx0XHRcdGlucHV0OiBjaHVua3NbaV0sXG5cdFx0XHRcdFx0ZW5jb2RpbmdfZm9ybWF0OiBcImZsb2F0XCIsXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRoaXMubGFzdFJlcXVlc3RUaW1lID0gRGF0ZS5ub3coKTtcblxuXHRcdFx0XHRlbWJlZGRpbmdzLnB1c2goe1xuXHRcdFx0XHRcdGRhdGE6IFtcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0ZW1iZWRkaW5nOiByZXNwb25zZS5kYXRhWzBdLmVtYmVkZGluZyxcblx0XHRcdFx0XHRcdFx0aW5kZXg6IGksXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0dXNhZ2U6IHtcblx0XHRcdFx0XHRcdHByb21wdF90b2tlbnM6IHJlc3BvbnNlLnVzYWdlLnByb21wdF90b2tlbnMsXG5cdFx0XHRcdFx0XHR0b3RhbF90b2tlbnM6IHJlc3BvbnNlLnVzYWdlLnRvdGFsX3Rva2Vucyxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG1vZGVsOiByZXNwb25zZS5tb2RlbCxcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHR0aGlzLmhhbmRsZUVtYmVkZGluZ0Vycm9yKGVycm9yLCBjaHVua3NbaV0pO1xuXHRcdFx0XHRlbWJlZGRpbmdzLnB1c2goe1xuXHRcdFx0XHRcdGRhdGE6IFtdLFxuXHRcdFx0XHRcdHVzYWdlOiB7IHByb21wdF90b2tlbnM6IDAsIHRvdGFsX3Rva2VuczogMCB9LFxuXHRcdFx0XHRcdG1vZGVsOiBcInRleHQtZW1iZWRkaW5nLWFkYS0wMDJcIixcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVtYmVkZGluZ3M7XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyB2YXJpb3VzIHR5cGVzIG9mIE9wZW5BSSBBUEkgZXJyb3JzXG5cdCAqL1xuXHRwcml2YXRlIGhhbmRsZUVtYmVkZGluZ0Vycm9yKGVycm9yOiBhbnksIGNodW5rOiBzdHJpbmcpOiB2b2lkIHtcblx0XHRsZXQgZXJyb3JNZXNzYWdlOiBzdHJpbmc7XG5cblx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBPcGVuQUkuQVBJRXJyb3IpIHtcblx0XHRcdHN3aXRjaCAoZXJyb3Iuc3RhdHVzKSB7XG5cdFx0XHRcdGNhc2UgNDI5OlxuXHRcdFx0XHRcdGVycm9yTWVzc2FnZSA9ICdSYXRlIGxpbWl0IGV4Y2VlZGVkLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgNDAxOlxuXHRcdFx0XHRcdGVycm9yTWVzc2FnZSA9ICdJbnZhbGlkIEFQSSBrZXkuIFBsZWFzZSBjaGVjayB5b3VyIHNldHRpbmdzLic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgNDEzOlxuXHRcdFx0XHRcdGVycm9yTWVzc2FnZSA9ICdUZXh0IGNodW5rIHRvbyBsYXJnZSBmb3IgZW1iZWRkaW5nLic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0ZXJyb3JNZXNzYWdlID0gYE9wZW5BSSBBUEkgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRlcnJvck1lc3NhZ2UgPSBgVW5leHBlY3RlZCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWA7XG5cdFx0fVxuXG5cdFx0Ly8gTG9nIHRoZSBlcnJvciB0aHJvdWdoIHRoZSBjZW50cmFsaXplZCBlcnJvciBoYW5kbGVyXG5cdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdGNvbnRleHQ6ICdPcGVuQUlTZXJ2aWNlLmNyZWF0ZUVtYmVkZGluZ3MnLFxuXHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0Y2h1bmtQcmV2aWV3OiBjaHVuay5zdWJzdHJpbmcoMCwgMTAwKSArICcuLi4nIC8vIEZpcnN0IDEwMCBjaGFycyBmb3IgY29udGV4dFxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0bmV3IE5vdGljZShgRXJyb3IgY3JlYXRpbmcgZW1iZWRkaW5nOiAke2Vycm9yTWVzc2FnZX1gKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHNlcnZpY2Ugc2V0dGluZ3Ncblx0ICovXG5cdHVwZGF0ZVNldHRpbmdzKHNldHRpbmdzOiBPcGVuQUlTZXR0aW5ncyk6IHZvaWQge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcblxuXHRcdGlmICghc2V0dGluZ3MuYXBpS2V5KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ09wZW5BSSBBUEkga2V5IGlzIG1pc3NpbmcuIE9wZW5BSVNlcnZpY2Ugd2lsbCBub3QgYmUgaW5pdGlhbGl6ZWQuJyk7XG5cdFx0XHR0aGlzLmNsaWVudCA9IG51bGw7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVpbml0aWFsaXplIHRoZSBPcGVuQUkgY2xpZW50IHdpdGggdXBkYXRlZCBzZXR0aW5nc1xuXHRcdHRoaXMuY2xpZW50ID0gbmV3IE9wZW5BSSh7XG5cdFx0XHRhcGlLZXk6IHNldHRpbmdzLmFwaUtleSxcblx0XHRcdGRhbmdlcm91c2x5QWxsb3dCcm93c2VyOiB0cnVlLCAvLyBFbnN1cmUgdGhpcyByZW1haW5zIGVuYWJsZWRcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHJhdGUgbGltaXRpbmcgcGFyYW1ldGVyc1xuXHQgKi9cblx0dXBkYXRlUmF0ZUxpbWl0KGRlbGF5TXM6IG51bWJlcik6IHZvaWQge1xuXHRcdHRoaXMucmF0ZUxpbWl0RGVsYXkgPSBkZWxheU1zO1xuXHR9XG59XG4iLCAiLy8gc3JjL3NlcnZpY2VzL1F1ZXVlU2VydmljZS50c1xuaW1wb3J0IHsgVmF1bHQsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgVGV4dFNwbGl0dGVyIH0gZnJvbSAnLi4vdXRpbHMvVGV4dFNwbGl0dGVyJztcbmltcG9ydCB7XG5cdFByb2Nlc3NpbmdUYXNrLFxuXHRUYXNrU3RhdHVzLFxuXHRUYXNrVHlwZSxcblx0UXVldWVTdGF0cyxcblx0VGFza1Byb2dyZXNzLFxuXHRUYXNrUHJvY2Vzc2luZ0Vycm9yXG59IGZyb20gJy4uL21vZGVscy9Qcm9jZXNzaW5nVGFzayc7XG5pbXBvcnQgeyBFcnJvckhhbmRsZXIgfSBmcm9tICcuLi91dGlscy9FcnJvckhhbmRsZXInO1xuaW1wb3J0IHsgTm90aWZpY2F0aW9uTWFuYWdlciB9IGZyb20gJy4uL3V0aWxzL05vdGlmaWNhdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgU3VwYWJhc2VTZXJ2aWNlIH0gZnJvbSAnLi9TdXBhYmFzZVNlcnZpY2UnO1xuaW1wb3J0IHsgT3BlbkFJU2VydmljZSB9IGZyb20gJy4vT3BlbkFJU2VydmljZSc7XG5pbXBvcnQgeyBERUZBVUxUX0NIVU5LSU5HX09QVElPTlMgfSBmcm9tICcuLi9zZXR0aW5ncy9TZXR0aW5ncyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuL0V2ZW50RW1pdHRlcic7XG5cbmV4cG9ydCBjbGFzcyBRdWV1ZVNlcnZpY2Uge1xuXHRwcml2YXRlIHF1ZXVlOiBQcm9jZXNzaW5nVGFza1tdID0gW107XG5cdHByaXZhdGUgcHJvY2Vzc2luZ1F1ZXVlOiBQcm9jZXNzaW5nVGFza1tdID0gW107XG5cdHByaXZhdGUgaXNQcm9jZXNzaW5nOiBib29sZWFuID0gZmFsc2U7XG5cdHByaXZhdGUgaXNTdG9wcGVkOiBib29sZWFuID0gdHJ1ZTtcblx0cHJpdmF0ZSBwcm9jZXNzaW5nSW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgdGV4dFNwbGl0dGVyOiBUZXh0U3BsaXR0ZXI7XG5cdHByaXZhdGUgdmF1bHQ6IFZhdWx0O1xuXHQvLyBFdmVudCBlbWl0dGVyIGZvciBxdWV1ZSBldmVudHNcblx0cHJpdmF0ZSBldmVudEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjtcblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRwcml2YXRlIG1heENvbmN1cnJlbnQ6IG51bWJlcixcblx0XHRwcml2YXRlIG1heFJldHJpZXM6IG51bWJlcixcblx0XHRwcml2YXRlIHN1cGFiYXNlU2VydmljZTogU3VwYWJhc2VTZXJ2aWNlIHwgbnVsbCxcblx0XHRwcml2YXRlIG9wZW5BSVNlcnZpY2U6IE9wZW5BSVNlcnZpY2UgfCBudWxsLFxuXHRcdHByaXZhdGUgZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXIsXG5cdFx0cHJpdmF0ZSBub3RpZmljYXRpb25NYW5hZ2VyOiBOb3RpZmljYXRpb25NYW5hZ2VyLFxuXHRcdHZhdWx0OiBWYXVsdCxcblx0XHRjaHVua1NldHRpbmdzPzogeyBjaHVua1NpemU6IG51bWJlcjsgY2h1bmtPdmVybGFwOiBudW1iZXI7IG1pbkNodW5rU2l6ZTogbnVtYmVyIH1cblx0KSB7XG5cdFx0dGhpcy52YXVsdCA9IHZhdWx0O1xuXHRcdGNvbnN0IHZhbGlkYXRlZENodW5rU2V0dGluZ3MgPSBjaHVua1NldHRpbmdzIHx8IHsgLi4uREVGQVVMVF9DSFVOS0lOR19PUFRJT05TIH07XG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMudGV4dFNwbGl0dGVyID0gbmV3IFRleHRTcGxpdHRlcih2YWxpZGF0ZWRDaHVua1NldHRpbmdzKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ1F1ZXVlU2VydmljZS5jb25zdHJ1Y3RvcicsXG5cdFx0XHRcdG1ldGFkYXRhOiB2YWxpZGF0ZWRDaHVua1NldHRpbmdzLFxuXHRcdFx0fSk7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFRleHRTcGxpdHRlciB3aXRoIHByb3ZpZGVkIHNldHRpbmdzLicpO1xuXHRcdH1cblx0XHR0aGlzLmV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblx0fVxuXG5cdHB1YmxpYyBzdGFydCgpOiB2b2lkIHtcblx0XHRpZiAoIXRoaXMuaXNTdG9wcGVkKSByZXR1cm47XG5cdFx0dGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcblx0XHR0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuXHRcdHRoaXMucHJvY2Vzc2luZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuXHRcdFx0aWYgKCF0aGlzLmlzUHJvY2Vzc2luZykge1xuXHRcdFx0XHR0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuXHRcdFx0fVxuXHRcdH0sIDEwMDApO1xuXHRcdC8vIEVtaXQgaW5pdGlhbCBxdWV1ZSBzdGF0dXNcblx0XHR0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdxdWV1ZS1zdGF0dXMnLCB7XG5cdFx0XHRxdWV1ZVNpemU6IHRoaXMucXVldWUubGVuZ3RoLFxuXHRcdFx0cGVuZGluZ0NoYW5nZXM6IDAsXG5cdFx0XHRwcm9jZXNzaW5nQ291bnQ6IHRoaXMucHJvY2Vzc2luZ1F1ZXVlLmxlbmd0aCxcblx0XHRcdHN0YXR1czogJ3Byb2Nlc3NpbmcnXG5cdFx0fSk7XG5cdH1cblxuXHRwdWJsaWMgc3RvcCgpOiB2b2lkIHtcblx0XHR0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG5cdFx0aWYgKHRoaXMucHJvY2Vzc2luZ0ludGVydmFsKSB7XG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMucHJvY2Vzc2luZ0ludGVydmFsKTtcblx0XHRcdHRoaXMucHJvY2Vzc2luZ0ludGVydmFsID0gbnVsbDtcblx0XHR9XG5cdFx0dGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgncXVldWUtc3RhdHVzJywge1xuXHRcdFx0cXVldWVTaXplOiB0aGlzLnF1ZXVlLmxlbmd0aCxcblx0XHRcdHBlbmRpbmdDaGFuZ2VzOiAwLFxuXHRcdFx0cHJvY2Vzc2luZ0NvdW50OiB0aGlzLnByb2Nlc3NpbmdRdWV1ZS5sZW5ndGgsXG5cdFx0XHRzdGF0dXM6ICdwYXVzZWQnXG5cdFx0fSk7XG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgYWRkVGFzayh0YXNrOiBQcm9jZXNzaW5nVGFzayk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+PSAxMDAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoVGFza1Byb2Nlc3NpbmdFcnJvci5RVUVVRV9GVUxMKTtcblx0XHR9XG5cdFx0Y29uc29sZS5sb2coJ0FkZGluZyB0YXNrIHRvIHF1ZXVlOicsIHsgaWQ6IHRhc2suaWQsIHR5cGU6IHRhc2sudHlwZSwgcHJpb3JpdHk6IHRhc2sucHJpb3JpdHkgfSk7XG5cblx0XHQvLyBDaGVjayBmb3IgZHVwbGljYXRlIG9yIGNvbmZsaWN0aW5nIHRhc2tzIG9uIHRoZSBzYW1lIGZpbGUuXG5cdFx0Y29uc3QgZXhpc3RpbmdUYXNrSW5kZXggPSB0aGlzLnF1ZXVlLmZpbmRJbmRleCh0ID0+IHQuaWQgPT09IHRhc2suaWQpO1xuXHRcdGNvbnN0IHByb2Nlc3NpbmdUYXNrSW5kZXggPSB0aGlzLnByb2Nlc3NpbmdRdWV1ZS5maW5kSW5kZXgodCA9PiB0LmlkID09PSB0YXNrLmlkKTtcblxuXHRcdGlmICh0YXNrLnR5cGUgPT09IFRhc2tUeXBlLkRFTEVURSkge1xuXHRcdFx0Ly8gREVMRVRFIHRhc2tzIGdldCBoaWdoZXN0IHByaW9yaXR5LlxuXHRcdFx0dGFzay5wcmlvcml0eSA9IDM7XG5cdFx0XHRpZiAocHJvY2Vzc2luZ1Rhc2tJbmRleCA+PSAwKSB7XG5cdFx0XHRcdGNvbnN0IHByb2Nlc3NpbmdUYXNrID0gdGhpcy5wcm9jZXNzaW5nUXVldWVbcHJvY2Vzc2luZ1Rhc2tJbmRleF07XG5cdFx0XHRcdGlmIChwcm9jZXNzaW5nVGFzay50eXBlICE9PSBUYXNrVHlwZS5ERUxFVEUpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhgQ29uZmxpY3QgaW4gcHJvY2Vzc2luZyBmb3IgJHt0YXNrLmlkfS4gTWFya2luZyBleGlzdGluZyB0YXNrIGFzIENBTkNFTExFRC5gKTtcblx0XHRcdFx0XHRwcm9jZXNzaW5nVGFzay5zdGF0dXMgPSBUYXNrU3RhdHVzLkNBTkNFTExFRDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGV4aXN0aW5nVGFza0luZGV4ID49IDApIHtcblx0XHRcdFx0Y29uc3QgZXhpc3RpbmdUYXNrID0gdGhpcy5xdWV1ZVtleGlzdGluZ1Rhc2tJbmRleF07XG5cdFx0XHRcdGlmIChleGlzdGluZ1Rhc2sudHlwZSA9PT0gVGFza1R5cGUuREVMRVRFKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coYER1cGxpY2F0ZSBERUxFVEUgdGFzayBmb3IgJHt0YXNrLmlkfS4gSWdub3JpbmcuYCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGBSZXBsYWNpbmcgZXhpc3RpbmcgJHtleGlzdGluZ1Rhc2sudHlwZX0gdGFzayBmb3IgJHt0YXNrLmlkfSB3aXRoIERFTEVURSB0YXNrLmApO1xuXHRcdFx0XHRcdHRoaXMucXVldWUuc3BsaWNlKGV4aXN0aW5nVGFza0luZGV4LCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gVW5zaGlmdCB0byBwcmlvcml0aXplIGRlbGV0aW9uXG5cdFx0XHR0aGlzLnF1ZXVlLnVuc2hpZnQodGFzayk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEZvciBDUkVBVEUvVVBEQVRFIHRhc2tzLCBpZiBhIERFTEVURSBpcyBwZW5kaW5nLCBza2lwIHRoZSB1cGRhdGUuXG5cdFx0XHRjb25zdCBoYXNEZWxldGVUYXNrID0gdGhpcy5xdWV1ZS5zb21lKHQgPT4gdC5pZCA9PT0gdGFzay5pZCAmJiB0LnR5cGUgPT09IFRhc2tUeXBlLkRFTEVURSk7XG5cdFx0XHRpZiAoaGFzRGVsZXRlVGFzaykge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhgU2tpcHBpbmcgJHt0YXNrLnR5cGV9IGZvciAke3Rhc2suaWR9IGFzIERFTEVURSBpcyBwZW5kaW5nLmApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoZXhpc3RpbmdUYXNrSW5kZXggPj0gMCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhgUmVwbGFjaW5nIGV4aXN0aW5nIHRhc2sgZm9yICR7dGFzay5pZH0gd2l0aCBuZXcgJHt0YXNrLnR5cGV9IHRhc2suYCk7XG5cdFx0XHRcdHRoaXMucXVldWVbZXhpc3RpbmdUYXNrSW5kZXhdID0gdGFzaztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEFkZCBiYXNlZCBvbiBwcmlvcml0eS5cblx0XHRcdFx0aWYgKHRhc2sucHJpb3JpdHkgPj0gMikge1xuXHRcdFx0XHRcdHRoaXMucXVldWUudW5zaGlmdCh0YXNrKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnF1ZXVlLnB1c2godGFzayk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBFbWl0IHByb2dyZXNzIHVwZGF0ZSBldmVudC5cblx0XHR0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdxdWV1ZS1wcm9ncmVzcycsIHtcblx0XHRcdHByb2Nlc3NlZDogMCxcblx0XHRcdHRvdGFsOiB0aGlzLnF1ZXVlLmxlbmd0aCxcblx0XHRcdGN1cnJlbnRUYXNrOiB0YXNrLmlkXG5cdFx0fSk7XG5cblx0XHRpZiAoIXRoaXMuaXNQcm9jZXNzaW5nICYmICF0aGlzLmlzU3RvcHBlZCkge1xuXHRcdFx0dGhpcy5wcm9jZXNzUXVldWUoKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIHByb2Nlc3NRdWV1ZSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAodGhpcy5pc1Byb2Nlc3NpbmcgfHwgdGhpcy5pc1N0b3BwZWQgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBTb3J0IHRhc2tzIGJ5IHByaW9yaXR5LCB0aGVuIERFTEVURSB0YXNrcywgdGhlbiBieSBjcmVhdGlvbiB0aW1lLlxuXHRcdFx0dGhpcy5xdWV1ZS5zb3J0KChhLCBiKSA9PiB7XG5cdFx0XHRcdGlmIChiLnByaW9yaXR5ICE9PSBhLnByaW9yaXR5KSByZXR1cm4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHk7XG5cdFx0XHRcdGlmIChhLnR5cGUgPT09IFRhc2tUeXBlLkRFTEVURSAmJiBiLnR5cGUgIT09IFRhc2tUeXBlLkRFTEVURSkgcmV0dXJuIC0xO1xuXHRcdFx0XHRpZiAoYi50eXBlID09PSBUYXNrVHlwZS5ERUxFVEUgJiYgYS50eXBlICE9PSBUYXNrVHlwZS5ERUxFVEUpIHJldHVybiAxO1xuXHRcdFx0XHRyZXR1cm4gYS5jcmVhdGVkQXQgLSBiLmNyZWF0ZWRBdDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBHcm91cCB0YXNrcyBieSBmaWxlIGlkIHRvIHJlc29sdmUgY29sbGlzaW9ucy5cblx0XHRcdGNvbnN0IHRhc2tzQnlGaWxlID0gbmV3IE1hcDxzdHJpbmcsIFByb2Nlc3NpbmdUYXNrW10+KCk7XG5cdFx0XHR0aGlzLnF1ZXVlLmZvckVhY2godGFzayA9PiB7XG5cdFx0XHRcdGlmICghdGFza3NCeUZpbGUuaGFzKHRhc2suaWQpKSB7XG5cdFx0XHRcdFx0dGFza3NCeUZpbGUuc2V0KHRhc2suaWQsIFtdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0YXNrc0J5RmlsZS5nZXQodGFzay5pZCkhLnB1c2godGFzayk7XG5cdFx0XHR9KTtcblxuXHRcdFx0bGV0IHRhc2tzVG9Qcm9jZXNzOiBQcm9jZXNzaW5nVGFza1tdID0gW107XG5cdFx0XHRmb3IgKGNvbnN0IFtmaWxlSWQsIGZpbGVUYXNrc10gb2YgdGFza3NCeUZpbGUuZW50cmllcygpKSB7XG5cdFx0XHRcdGlmIChmaWxlVGFza3MubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGBEZXRlY3RlZCAke2ZpbGVUYXNrcy5sZW5ndGh9IHRhc2tzIGZvciAke2ZpbGVJZH0sIHJlc29sdmluZyBjb2xsaXNpb25zLmApO1xuXHRcdFx0XHRcdGNvbnN0IGRlbGV0ZVRhc2sgPSBmaWxlVGFza3MuZmluZCh0ID0+IHQudHlwZSA9PT0gVGFza1R5cGUuREVMRVRFKTtcblx0XHRcdFx0XHRpZiAoZGVsZXRlVGFzaykge1xuXHRcdFx0XHRcdFx0dGFza3NUb1Byb2Nlc3MucHVzaChkZWxldGVUYXNrKTtcblx0XHRcdFx0XHRcdHRoaXMucXVldWUgPSB0aGlzLnF1ZXVlLmZpbHRlcih0ID0+IHQuaWQgIT09IGZpbGVJZCk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhgS2VlcGluZyBvbmx5IERFTEVURSB0YXNrIGZvciAke2ZpbGVJZH1gKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc3QgbW9zdFJlY2VudFRhc2sgPSBmaWxlVGFza3MucmVkdWNlKChsYXRlc3QsIGN1cnJlbnQpID0+XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQudXBkYXRlZEF0ID4gbGF0ZXN0LnVwZGF0ZWRBdCA/IGN1cnJlbnQgOiBsYXRlc3QsIGZpbGVUYXNrc1swXSk7XG5cdFx0XHRcdFx0XHR0YXNrc1RvUHJvY2Vzcy5wdXNoKG1vc3RSZWNlbnRUYXNrKTtcblx0XHRcdFx0XHRcdHRoaXMucXVldWUgPSB0aGlzLnF1ZXVlLmZpbHRlcih0ID0+IHQuaWQgIT09IGZpbGVJZCB8fCB0ID09PSBtb3N0UmVjZW50VGFzayk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhgS2VlcGluZyBtb3N0IHJlY2VudCB0YXNrIGZvciAke2ZpbGVJZH1gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRmlsbCB0YXNrc1RvUHJvY2VzcyB3aXRoIHJlbWFpbmluZyB0YXNrcyB1bnRpbCB3ZSBoaXQgdGhlIGNvbmN1cnJlbmN5IGxpbWl0LlxuXHRcdFx0Zm9yIChjb25zdCB0YXNrIG9mIHRoaXMucXVldWUpIHtcblx0XHRcdFx0aWYgKHRhc2tzVG9Qcm9jZXNzLnNvbWUodCA9PiB0LmlkID09PSB0YXNrLmlkKSkgY29udGludWU7XG5cdFx0XHRcdHRhc2tzVG9Qcm9jZXNzLnB1c2godGFzayk7XG5cdFx0XHRcdGlmICh0YXNrc1RvUHJvY2Vzcy5sZW5ndGggKyB0aGlzLnByb2Nlc3NpbmdRdWV1ZS5sZW5ndGggPj0gdGhpcy5tYXhDb25jdXJyZW50KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIHNlbGVjdGVkIHRhc2tzIGZyb20gdGhlIG1haW4gcXVldWUuXG5cdFx0XHRmb3IgKGNvbnN0IHRhc2sgb2YgdGFza3NUb1Byb2Nlc3MpIHtcblx0XHRcdFx0Y29uc3QgaW5kZXggPSB0aGlzLnF1ZXVlLmluZGV4T2YodGFzayk7XG5cdFx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0XHR0aGlzLnF1ZXVlLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUHJvY2VzcyBzZWxlY3RlZCB0YXNrcy5cblx0XHRcdGZvciAoY29uc3QgdGFzayBvZiB0YXNrc1RvUHJvY2Vzcykge1xuXHRcdFx0XHRpZiAodGhpcy5wcm9jZXNzaW5nUXVldWUubGVuZ3RoID49IHRoaXMubWF4Q29uY3VycmVudCkge1xuXHRcdFx0XHRcdHRoaXMucXVldWUudW5zaGlmdCh0YXNrKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnByb2Nlc3NpbmdRdWV1ZS5wdXNoKHRhc2spO1xuXHRcdFx0XHR0aGlzLnByb2Nlc3NUYXNrKHRhc2spLmNhdGNoKGVycm9yID0+IHtcblx0XHRcdFx0XHR0aGlzLmhhbmRsZVRhc2tFcnJvcih0YXNrLCBlcnJvcik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdxdWV1ZS1zdGF0dXMnLCB7XG5cdFx0XHRcdHF1ZXVlU2l6ZTogdGhpcy5xdWV1ZS5sZW5ndGgsXG5cdFx0XHRcdHBlbmRpbmdDaGFuZ2VzOiB0aGlzLnF1ZXVlLmxlbmd0aCArIHRoaXMucHJvY2Vzc2luZ1F1ZXVlLmxlbmd0aCxcblx0XHRcdFx0cHJvY2Vzc2luZ0NvdW50OiB0aGlzLnByb2Nlc3NpbmdRdWV1ZS5sZW5ndGgsXG5cdFx0XHRcdHN0YXR1czogJ3Byb2Nlc3NpbmcnXG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1F1ZXVlU2VydmljZS5wcm9jZXNzUXVldWUnIH0pO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuXHRcdFx0aWYgKHRoaXMucXVldWUubGVuZ3RoID4gMCAmJiAhdGhpcy5pc1N0b3BwZWQpIHtcblx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB0aGlzLnByb2Nlc3NRdWV1ZSgpLCAxMDApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc1Rhc2sodGFzazogUHJvY2Vzc2luZ1Rhc2spOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zb2xlLmxvZygnUHJvY2Vzc2luZyB0YXNrOicsIHsgaWQ6IHRhc2suaWQsIHR5cGU6IHRhc2sudHlwZSwgc3RhdHVzOiB0YXNrLnN0YXR1cyB9KTtcblx0XHR0cnkge1xuXHRcdFx0dGFzay5zdGF0dXMgPSBUYXNrU3RhdHVzLlBST0NFU1NJTkc7XG5cdFx0XHR0YXNrLnN0YXJ0ZWRBdCA9IERhdGUubm93KCk7XG5cdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDAsIGBTdGFydGluZyAke3Rhc2sudHlwZS50b0xvd2VyQ2FzZSgpfWApO1xuXHRcdFx0c3dpdGNoICh0YXNrLnR5cGUpIHtcblx0XHRcdFx0Y2FzZSBUYXNrVHlwZS5DUkVBVEU6XG5cdFx0XHRcdGNhc2UgVGFza1R5cGUuVVBEQVRFOlxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucHJvY2Vzc0NyZWF0ZVVwZGF0ZVRhc2sodGFzayk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgVGFza1R5cGUuREVMRVRFOlxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucHJvY2Vzc0RlbGV0ZVRhc2sodGFzayk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0YXNrIHR5cGU6ICR7dGFzay50eXBlfWApO1xuXHRcdFx0fVxuXHRcdFx0dGFzay5zdGF0dXMgPSBUYXNrU3RhdHVzLkNPTVBMRVRFRDtcblx0XHRcdHRhc2suY29tcGxldGVkQXQgPSBEYXRlLm5vdygpO1xuXHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCAxMDAsICdUYXNrIGNvbXBsZXRlZCcpO1xuXHRcdFx0Y29uc29sZS5sb2coJ1Rhc2sgY29tcGxldGVkIHN1Y2Nlc3NmdWxseTonLCB0YXNrLmlkKTtcblx0XHRcdHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3F1ZXVlLXByb2dyZXNzJywge1xuXHRcdFx0XHRwcm9jZXNzZWQ6IDEsXG5cdFx0XHRcdHRvdGFsOiB0aGlzLnF1ZXVlLmxlbmd0aCArIDEsXG5cdFx0XHRcdGN1cnJlbnRUYXNrOiB0YXNrLmlkXG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgcHJvY2Vzc2luZyB0YXNrOicsIHsgdGFza0lkOiB0YXNrLmlkLCBlcnJvciB9KTtcblx0XHRcdGF3YWl0IHRoaXMuaGFuZGxlVGFza0Vycm9yKHRhc2ssIGVycm9yKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dGhpcy5yZW1vdmVGcm9tUHJvY2Vzc2luZ1F1ZXVlKHRhc2spO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc0NyZWF0ZVVwZGF0ZVRhc2sodGFzazogUHJvY2Vzc2luZ1Rhc2spOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXRoaXMuc3VwYWJhc2VTZXJ2aWNlIHx8ICF0aGlzLm9wZW5BSVNlcnZpY2UpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgc2VydmljZXMgbm90IGluaXRpYWxpemVkJyk7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRjb25zb2xlLmxvZygnUmVhZGluZyBmaWxlOicsIHRhc2suaWQpO1xuXHRcdFx0Y29uc3QgZmlsZSA9IHRoaXMudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRhc2suaWQpO1xuXHRcdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZpbGUgbm90IGZvdW5kIG9yIG5vdCBhIFRGaWxlOiAke3Rhc2suaWR9YCk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCB0aW1pbmdzID0ge1xuXHRcdFx0XHRzdGFydDogRGF0ZS5ub3coKSxcblx0XHRcdFx0cmVhZENvbXBsZXRlOiAwLFxuXHRcdFx0XHRjaHVua2luZ0NvbXBsZXRlOiAwLFxuXHRcdFx0XHRlbWJlZGRpbmdDb21wbGV0ZTogMCxcblx0XHRcdFx0c2F2ZUNvbXBsZXRlOiAwXG5cdFx0XHR9O1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHQucmVhZChmaWxlKTtcblx0XHRcdHRpbWluZ3MucmVhZENvbXBsZXRlID0gRGF0ZS5ub3coKTtcblx0XHRcdGNvbnNvbGUubG9nKCdGaWxlIGNvbnRlbnQgcmVhZDonLCB7XG5cdFx0XHRcdGZpbGVJZDogdGFzay5pZCxcblx0XHRcdFx0Y29udGVudExlbmd0aDogY29udGVudC5sZW5ndGgsXG5cdFx0XHRcdHJlYWRUaW1lOiB0aW1pbmdzLnJlYWRDb21wbGV0ZSAtIHRpbWluZ3Muc3RhcnRcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCAyMCwgJ1NwbGl0dGluZyBjb250ZW50Jyk7XG5cdFx0XHRjb25zdCBjaHVua3MgPSBhd2FpdCB0aGlzLnRleHRTcGxpdHRlci5zcGxpdERvY3VtZW50KGNvbnRlbnQsIHRhc2subWV0YWRhdGEpO1xuXHRcdFx0dGltaW5ncy5jaHVua2luZ0NvbXBsZXRlID0gRGF0ZS5ub3coKTtcblx0XHRcdGlmICghY2h1bmtzIHx8ICFBcnJheS5pc0FycmF5KGNodW5rcykgfHwgY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnTm8gdmFsaWQgY2h1bmtzIGNyZWF0ZWQgZm9yIGZpbGU6Jywge1xuXHRcdFx0XHRcdGZpbGVJZDogdGFzay5pZCxcblx0XHRcdFx0XHRjb250ZW50TGVuZ3RoOiBjb250ZW50Lmxlbmd0aCxcblx0XHRcdFx0XHRzZXR0aW5nczogdGhpcy50ZXh0U3BsaXR0ZXIuZ2V0U2V0dGluZ3MoKVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKHRoaXMuc3VwYWJhc2VTZXJ2aWNlKSB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UudXBkYXRlRmlsZVZlY3Rvcml6YXRpb25TdGF0dXModGFzay5tZXRhZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5sb2coJ0NvbnRlbnQgc3BsaXQgaW50byBjaHVua3M6Jywge1xuXHRcdFx0XHRudW1iZXJPZkNodW5rczogY2h1bmtzLmxlbmd0aCxcblx0XHRcdFx0Y2h1bmtTaXplczogY2h1bmtzLm1hcChjID0+IGMuY29udGVudC5sZW5ndGgpLFxuXHRcdFx0XHRjaHVua2luZ1RpbWU6IHRpbWluZ3MuY2h1bmtpbmdDb21wbGV0ZSAtIHRpbWluZ3MucmVhZENvbXBsZXRlXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMubm90aWZ5UHJvZ3Jlc3ModGFzay5pZCwgNDAsICdHZW5lcmF0aW5nIGVtYmVkZGluZ3MnKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGVtYmVkUHJvZ3Jlc3MgPSBNYXRoLmZsb29yKDQwICsgKGkgLyBjaHVua3MubGVuZ3RoKSAqIDMwKTtcblx0XHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCBlbWJlZFByb2dyZXNzLCBgR2VuZXJhdGluZyBlbWJlZGRpbmcgJHtpICsgMX0vJHtjaHVua3MubGVuZ3RofWApO1xuXHRcdFx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMub3BlbkFJU2VydmljZS5jcmVhdGVFbWJlZGRpbmdzKFtjaHVua3NbaV0uY29udGVudF0pO1xuXHRcdFx0XHRpZiAocmVzcG9uc2UubGVuZ3RoID4gMCAmJiByZXNwb25zZVswXS5kYXRhLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRjaHVua3NbaV0uZW1iZWRkaW5nID0gcmVzcG9uc2VbMF0uZGF0YVswXS5lbWJlZGRpbmc7XG5cdFx0XHRcdFx0Y2h1bmtzW2ldLnZlY3Rvcml6ZWRfYXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coYEdlbmVyYXRlZCBlbWJlZGRpbmcgZm9yIGNodW5rICR7aSArIDF9LyR7Y2h1bmtzLmxlbmd0aH1gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZW5lcmF0ZSBlbWJlZGRpbmcgZm9yIGNodW5rICR7aSArIDF9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRpbWluZ3MuZW1iZWRkaW5nQ29tcGxldGUgPSBEYXRlLm5vdygpO1xuXHRcdFx0Y29uc3QgZW5oYW5jZWRDaHVua3MgPSBjaHVua3MubWFwKGNodW5rID0+ICh7XG5cdFx0XHRcdC4uLmNodW5rLFxuXHRcdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHRcdC4uLmNodW5rLm1ldGFkYXRhLFxuXHRcdFx0XHRcdGFsaWFzZXM6IGNodW5rLm1ldGFkYXRhLmFsaWFzZXMgfHwgW10sXG5cdFx0XHRcdFx0bGlua3M6IGNodW5rLm1ldGFkYXRhLmxpbmtzIHx8IFtdLFxuXHRcdFx0XHRcdHRhZ3M6IGNodW5rLm1ldGFkYXRhLnRhZ3MgfHwgW11cblx0XHRcdFx0fVxuXHRcdFx0fSkpO1xuXHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCA3MCwgJ1NhdmluZyB0byBkYXRhYmFzZScpO1xuXHRcdFx0bGV0IHNhdmVBdHRlbXB0cyA9IDA7XG5cdFx0XHRjb25zdCBtYXhTYXZlQXR0ZW1wdHMgPSAzO1xuXHRcdFx0bGV0IHNhdmVkU3VjY2Vzc2Z1bGx5ID0gZmFsc2U7XG5cdFx0XHR3aGlsZSAoIXNhdmVkU3VjY2Vzc2Z1bGx5ICYmIHNhdmVBdHRlbXB0cyA8IG1heFNhdmVBdHRlbXB0cykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLnVwc2VydENodW5rcyhlbmhhbmNlZENodW5rcyk7XG5cdFx0XHRcdFx0c2F2ZWRTdWNjZXNzZnVsbHkgPSB0cnVlO1xuXHRcdFx0XHR9IGNhdGNoIChzYXZlRXJyb3IpIHtcblx0XHRcdFx0XHRzYXZlQXR0ZW1wdHMrKztcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGBFcnJvciBzYXZpbmcgY2h1bmtzIChhdHRlbXB0ICR7c2F2ZUF0dGVtcHRzfS8ke21heFNhdmVBdHRlbXB0c30pOmAsIHNhdmVFcnJvcik7XG5cdFx0XHRcdFx0aWYgKHNhdmVBdHRlbXB0cyA+PSBtYXhTYXZlQXR0ZW1wdHMpIHRocm93IHNhdmVFcnJvcjtcblx0XHRcdFx0XHRjb25zdCBiYWNrb2ZmVGltZSA9IE1hdGgucG93KDIsIHNhdmVBdHRlbXB0cykgKiAxMDAwO1xuXHRcdFx0XHRcdHRoaXMubm90aWZ5UHJvZ3Jlc3ModGFzay5pZCwgNzAsIGBSZXRyeWluZyBkYXRhYmFzZSBzYXZlIGluICR7YmFja29mZlRpbWUgLyAxMDAwfXNgKTtcblx0XHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgYmFja29mZlRpbWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGltaW5ncy5zYXZlQ29tcGxldGUgPSBEYXRlLm5vdygpO1xuXHRcdFx0Y29uc29sZS5sb2coJ0NodW5rcyBzYXZlZCB0byBkYXRhYmFzZTonLCB7XG5cdFx0XHRcdG51bWJlck9mQ2h1bmtzOiBlbmhhbmNlZENodW5rcy5sZW5ndGgsXG5cdFx0XHRcdGZpbGVJZDogdGFzay5pZCxcblx0XHRcdFx0dGltaW5nczoge1xuXHRcdFx0XHRcdHRvdGFsOiB0aW1pbmdzLnNhdmVDb21wbGV0ZSAtIHRpbWluZ3Muc3RhcnQsXG5cdFx0XHRcdFx0cmVhZDogdGltaW5ncy5yZWFkQ29tcGxldGUgLSB0aW1pbmdzLnN0YXJ0LFxuXHRcdFx0XHRcdGNodW5raW5nOiB0aW1pbmdzLmNodW5raW5nQ29tcGxldGUgLSB0aW1pbmdzLnJlYWRDb21wbGV0ZSxcblx0XHRcdFx0XHRlbWJlZGRpbmc6IHRpbWluZ3MuZW1iZWRkaW5nQ29tcGxldGUgLSB0aW1pbmdzLmNodW5raW5nQ29tcGxldGUsXG5cdFx0XHRcdFx0c2F2ZTogdGltaW5ncy5zYXZlQ29tcGxldGUgLSB0aW1pbmdzLmVtYmVkZGluZ0NvbXBsZXRlXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCAxMDAsICdQcm9jZXNzaW5nIGNvbXBsZXRlZCcpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBpbiBwcm9jZXNzQ3JlYXRlVXBkYXRlVGFzazonLCB7IGVycm9yLCB0YXNrSWQ6IHRhc2suaWQsIG1ldGFkYXRhOiB0YXNrLm1ldGFkYXRhIH0pO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBwcm9jZXNzRGVsZXRlVGFzayh0YXNrOiBQcm9jZXNzaW5nVGFzayk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghdGhpcy5zdXBhYmFzZVNlcnZpY2UpIHRocm93IG5ldyBFcnJvcignU3VwYWJhc2Ugc2VydmljZSBub3QgaW5pdGlhbGl6ZWQnKTtcblx0XHR0cnkge1xuXHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCAxMCwgJ1N0YXJ0aW5nIGRlbGV0aW9uIHByb2Nlc3MnKTtcblx0XHRcdGNvbnNvbGUubG9nKGBDaGVja2luZyBkb2N1bWVudCBiZWZvcmUgZGVsZXRpb246ICR7dGFzay5tZXRhZGF0YS5vYnNpZGlhbklkfWApO1xuXHRcdFx0Y29uc3QgY2h1bmtzID0gYXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UuZ2V0RG9jdW1lbnRDaHVua3ModGFzay5tZXRhZGF0YS5vYnNpZGlhbklkKTtcblx0XHRcdGNvbnN0IGNodW5rQ291bnQgPSBjaHVua3MubGVuZ3RoO1xuXHRcdFx0aWYgKGNodW5rQ291bnQgPiAwKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGBGb3VuZCAke2NodW5rQ291bnR9IGNodW5rcyB0byBkZWxldGUgZm9yICR7dGFzay5tZXRhZGF0YS5vYnNpZGlhbklkfWApO1xuXHRcdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDMwLCBgRGVsZXRpbmcgJHtjaHVua0NvdW50fSBjaHVua3NgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGBObyBjaHVua3MgZm91bmQgZm9yIGRlbGV0aW9uOiAke3Rhc2subWV0YWRhdGEub2JzaWRpYW5JZH1gKTtcblx0XHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCAzMCwgJ05vIGNodW5rcyB0byBkZWxldGUnKTtcblx0XHRcdH1cblx0XHRcdGxldCBkZWxldGVBdHRlbXB0cyA9IDA7XG5cdFx0XHRjb25zdCBtYXhEZWxldGVBdHRlbXB0cyA9IDM7XG5cdFx0XHRsZXQgZGVsZXRlZFN1Y2Nlc3NmdWxseSA9IGZhbHNlO1xuXHRcdFx0d2hpbGUgKCFkZWxldGVkU3VjY2Vzc2Z1bGx5ICYmIGRlbGV0ZUF0dGVtcHRzIDwgbWF4RGVsZXRlQXR0ZW1wdHMpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR0aGlzLm5vdGlmeVByb2dyZXNzKHRhc2suaWQsIDUwLCBkZWxldGVBdHRlbXB0cyA+IDAgPyBgRGVsZXRpb24gYXR0ZW1wdCAke2RlbGV0ZUF0dGVtcHRzICsgMX0vJHttYXhEZWxldGVBdHRlbXB0c31gIDogJ0RlbGV0aW5nIGZyb20gZGF0YWJhc2UnKTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS5kZWxldGVEb2N1bWVudENodW5rcyh0YXNrLm1ldGFkYXRhLm9ic2lkaWFuSWQpO1xuXHRcdFx0XHRcdGRlbGV0ZWRTdWNjZXNzZnVsbHkgPSB0cnVlO1xuXHRcdFx0XHRcdGNvbnN0IHJlbWFpbmluZ0NodW5rcyA9IGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLmdldERvY3VtZW50Q2h1bmtzKHRhc2subWV0YWRhdGEub2JzaWRpYW5JZCk7XG5cdFx0XHRcdFx0aWYgKHJlbWFpbmluZ0NodW5rcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oYERlbGV0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6ICR7cmVtYWluaW5nQ2h1bmtzLmxlbmd0aH0gY2h1bmtzIHN0aWxsIGV4aXN0YCk7XG5cdFx0XHRcdFx0XHRkZWxldGVkU3VjY2Vzc2Z1bGx5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYERlbGV0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQgZm9yICR7dGFzay5tZXRhZGF0YS5vYnNpZGlhbklkfWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoZGVsZXRlRXJyb3IpIHtcblx0XHRcdFx0XHRkZWxldGVBdHRlbXB0cysrO1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nIGNodW5rcyAoYXR0ZW1wdCAke2RlbGV0ZUF0dGVtcHRzfS8ke21heERlbGV0ZUF0dGVtcHRzfSk6YCwgZGVsZXRlRXJyb3IpO1xuXHRcdFx0XHRcdGlmIChkZWxldGVBdHRlbXB0cyA+PSBtYXhEZWxldGVBdHRlbXB0cykgdGhyb3cgZGVsZXRlRXJyb3I7XG5cdFx0XHRcdFx0Y29uc3QgYmFja29mZlRpbWUgPSBNYXRoLnBvdygyLCBkZWxldGVBdHRlbXB0cykgKiAxMDAwO1xuXHRcdFx0XHRcdHRoaXMubm90aWZ5UHJvZ3Jlc3ModGFzay5pZCwgNTAsIGBXaWxsIHJldHJ5IGRlbGV0aW9uIGluICR7YmFja29mZlRpbWUgLyAxMDAwfXNgKTtcblx0XHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgYmFja29mZlRpbWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5ub3RpZnlQcm9ncmVzcyh0YXNrLmlkLCA4MCwgJ1VwZGF0aW5nIGZpbGUgc3RhdHVzJyk7XG5cdFx0XHRhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS51cGRhdGVGaWxlU3RhdHVzT25EZWxldGUodGFzay5tZXRhZGF0YS5vYnNpZGlhbklkKTtcblx0XHRcdHRoaXMubm90aWZ5UHJvZ3Jlc3ModGFzay5pZCwgMTAwLCAnRGVsZXRlIGNvbXBsZXRlZCcpO1xuXHRcdFx0Y29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBkZWxldGVkIGRvY3VtZW50OiAke3Rhc2subWV0YWRhdGEub2JzaWRpYW5JZH1gKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgaW4gcHJvY2Vzc0RlbGV0ZVRhc2s6JywgeyBlcnJvciwgdGFza0lkOiB0YXNrLmlkLCBtZXRhZGF0YTogdGFzay5tZXRhZGF0YSB9KTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgaGFuZGxlVGFza0Vycm9yKHRhc2s6IFByb2Nlc3NpbmdUYXNrLCBlcnJvcjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dGFzay5yZXRyeUNvdW50ID0gKHRhc2sucmV0cnlDb3VudCB8fCAwKSArIDE7XG5cdFx0dGFzay51cGRhdGVkQXQgPSBEYXRlLm5vdygpO1xuXHRcdGlmICh0YXNrLnJldHJ5Q291bnQgPCB0aGlzLm1heFJldHJpZXMpIHtcblx0XHRcdHRhc2suc3RhdHVzID0gVGFza1N0YXR1cy5SRVRSWUlORztcblx0XHRcdHRoaXMucXVldWUudW5zaGlmdCh0YXNrKTtcblx0XHRcdHRoaXMubm90aWZ5UHJvZ3Jlc3ModGFzay5pZCwgMCwgYFJldHJ5IGF0dGVtcHQgJHt0YXNrLnJldHJ5Q291bnR9YCk7XG5cdFx0XHRjb25zb2xlLmxvZygnVGFzayBxdWV1ZWQgZm9yIHJldHJ5OicsIHsgdGFza0lkOiB0YXNrLmlkLCByZXRyeUNvdW50OiB0YXNrLnJldHJ5Q291bnQsIG1heFJldHJpZXM6IHRoaXMubWF4UmV0cmllcyB9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFzay5zdGF0dXMgPSBUYXNrU3RhdHVzLkZBSUxFRDtcblx0XHRcdHRhc2suZXJyb3IgPSB7XG5cdFx0XHRcdG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG5cdFx0XHRcdGNvZGU6IGVycm9yLmNvZGUgfHwgJ1VOS05PV05fRVJST1InLFxuXHRcdFx0XHRzdGFjazogZXJyb3Iuc3RhY2ssXG5cdFx0XHR9O1xuXHRcdFx0dGFzay5jb21wbGV0ZWRBdCA9IERhdGUubm93KCk7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdUYXNrIGZhaWxlZCBhZnRlciBtYXggcmV0cmllczonLCB7IHRhc2tJZDogdGFzay5pZCwgZXJyb3I6IHRhc2suZXJyb3IgfSk7XG5cdFx0fVxuXHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdRdWV1ZVNlcnZpY2UucHJvY2Vzc1Rhc2snLCB0YXNrSWQ6IHRhc2suaWQsIHRhc2tUeXBlOiB0YXNrLnR5cGUgfSk7XG5cdFx0dGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgncXVldWUtcHJvZ3Jlc3MnLCB7IHByb2Nlc3NlZDogMCwgdG90YWw6IHRoaXMucXVldWUubGVuZ3RoLCBjdXJyZW50VGFzazogdGFzay5pZCB9KTtcblx0fVxuXG5cdHByaXZhdGUgcmVtb3ZlRnJvbVByb2Nlc3NpbmdRdWV1ZSh0YXNrOiBQcm9jZXNzaW5nVGFzayk6IHZvaWQge1xuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5wcm9jZXNzaW5nUXVldWUuZmluZEluZGV4KHQgPT4gdC5pZCA9PT0gdGFzay5pZCk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0dGhpcy5wcm9jZXNzaW5nUXVldWUuc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIG5vdGlmeVByb2dyZXNzKHRhc2tJZDogc3RyaW5nLCBwcm9ncmVzczogbnVtYmVyLCBtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcblx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIudXBkYXRlUHJvZ3Jlc3Moe1xuXHRcdFx0dGFza0lkLFxuXHRcdFx0cHJvZ3Jlc3MsXG5cdFx0XHRjdXJyZW50U3RlcDogbWVzc2FnZSxcblx0XHRcdHRvdGFsU3RlcHM6IDEsXG5cdFx0XHRjdXJyZW50U3RlcE51bWJlcjogMSxcblx0XHR9KTtcblx0XHR0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdxdWV1ZS1wcm9ncmVzcycsIHsgcHJvY2Vzc2VkOiBwcm9ncmVzcywgdG90YWw6IDEwMCwgY3VycmVudFRhc2s6IHRhc2tJZCB9KTtcblx0fVxuXG5cdHB1YmxpYyBnZXRRdWV1ZVN0YXRzKCk6IFF1ZXVlU3RhdHMge1xuXHRcdGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cdFx0Y29uc3Qgb25lSG91ciA9IDYwICogNjAgKiAxMDAwO1xuXHRcdGNvbnN0IHRhc2tzQnlTdGF0dXMgPSB0aGlzLnF1ZXVlLnJlZHVjZSgoYWNjLCB0YXNrKSA9PiB7XG5cdFx0XHRhY2NbdGFzay5zdGF0dXNdID0gKGFjY1t0YXNrLnN0YXR1c10gfHwgMCkgKyAxO1xuXHRcdFx0cmV0dXJuIGFjYztcblx0XHR9LCB7fSBhcyBSZWNvcmQ8VGFza1N0YXR1cywgbnVtYmVyPik7XG5cdFx0Y29uc3QgdGFza3NCeVR5cGUgPSB0aGlzLnF1ZXVlLnJlZHVjZSgoYWNjLCB0YXNrKSA9PiB7XG5cdFx0XHRhY2NbdGFzay50eXBlXSA9IChhY2NbdGFzay50eXBlXSB8fCAwKSArIDE7XG5cdFx0XHRyZXR1cm4gYWNjO1xuXHRcdH0sIHt9IGFzIFJlY29yZDxUYXNrVHlwZSwgbnVtYmVyPik7XG5cdFx0Y29uc3QgY29tcGxldGVkVGFza3MgPSB0aGlzLnF1ZXVlLmZpbHRlcih0YXNrID0+IHRhc2suc3RhdHVzID09PSBUYXNrU3RhdHVzLkNPTVBMRVRFRCAmJiB0YXNrLmNvbXBsZXRlZEF0KTtcblx0XHRjb25zdCBhdmVyYWdlVGltZSA9IGNvbXBsZXRlZFRhc2tzLmxlbmd0aCA+IDBcblx0XHRcdD8gY29tcGxldGVkVGFza3MucmVkdWNlKChzdW0sIHRhc2spID0+IHN1bSArICh0YXNrLmNvbXBsZXRlZEF0ISAtIHRhc2suc3RhcnRlZEF0ISksIDApIC8gY29tcGxldGVkVGFza3MubGVuZ3RoXG5cdFx0XHQ6IDA7XG5cdFx0Y29uc3QgdGFza3NMYXN0SG91ciA9IGNvbXBsZXRlZFRhc2tzLmZpbHRlcih0YXNrID0+IHRhc2suY29tcGxldGVkQXQhID4gbm93IC0gb25lSG91cikubGVuZ3RoO1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3RhbFRhc2tzOiB0aGlzLnF1ZXVlLmxlbmd0aCxcblx0XHRcdHRhc2tzQnlTdGF0dXMsXG5cdFx0XHR0YXNrc0J5VHlwZSxcblx0XHRcdGF2ZXJhZ2VQcm9jZXNzaW5nVGltZTogYXZlcmFnZVRpbWUsXG5cdFx0XHRmYWlsZWRUYXNrczogdGFza3NCeVN0YXR1c1tUYXNrU3RhdHVzLkZBSUxFRF0gfHwgMCxcblx0XHRcdHJldHJ5aW5nVGFza3M6IHRhc2tzQnlTdGF0dXNbVGFza1N0YXR1cy5SRVRSWUlOR10gfHwgMCxcblx0XHRcdHRhc2tzTGFzdEhvdXIsXG5cdFx0fTtcblx0fVxuXG5cdHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcblx0XHR0aGlzLnF1ZXVlID0gW107XG5cdFx0dGhpcy5wcm9jZXNzaW5nUXVldWUgPSBbXTtcblx0XHR0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIuY2xlYXIoKTtcblx0fVxuXG5cdHB1YmxpYyB1cGRhdGVTZXR0aW5ncyhzZXR0aW5nczogeyBtYXhDb25jdXJyZW50OiBudW1iZXI7IG1heFJldHJpZXM6IG51bWJlcjsgY2h1bmtTZXR0aW5ncz86IHsgY2h1bmtTaXplOiBudW1iZXI7IGNodW5rT3ZlcmxhcDogbnVtYmVyOyBtaW5DaHVua1NpemU6IG51bWJlciB9IH0pOiB2b2lkIHtcblx0XHR0aGlzLm1heENvbmN1cnJlbnQgPSBzZXR0aW5ncy5tYXhDb25jdXJyZW50O1xuXHRcdHRoaXMubWF4UmV0cmllcyA9IHNldHRpbmdzLm1heFJldHJpZXM7XG5cdFx0aWYgKHNldHRpbmdzLmNodW5rU2V0dGluZ3MpIHtcblx0XHRcdHRoaXMudGV4dFNwbGl0dGVyID0gbmV3IFRleHRTcGxpdHRlcihzZXR0aW5ncy5jaHVua1NldHRpbmdzKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU3Vic2NyaWJlIHRvIHF1ZXVlIGV2ZW50cy5cblx0ICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gc3Vic2NyaWJlIHRvLlxuXHQgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0cHVibGljIG9uPFQgZXh0ZW5kcyBrZXlvZiBhbnk+KGV2ZW50TmFtZTogVCwgY2FsbGJhY2s6IChkYXRhOiBhbnkpID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcblx0XHRyZXR1cm4gdGhpcy5ldmVudEVtaXR0ZXIub24oZXZlbnROYW1lIGFzIGFueSwgY2FsbGJhY2spO1xuXHR9XG59XG4iLCAiLy8gc3JjL3NlcnZpY2VzL01ldGFkYXRhRXh0cmFjdG9yLnRzXG5pbXBvcnQgeyBURmlsZSwgcGFyc2VZYW1sIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgRG9jdW1lbnRNZXRhZGF0YSwgRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IgfSBmcm9tICcuLi9tb2RlbHMvRG9jdW1lbnRDaHVuayc7XG5cbmV4cG9ydCBjbGFzcyBNZXRhZGF0YUV4dHJhY3RvciB7XG5cdC8qKlxuXHQgKiBFeHRyYWN0cyBhbGwgbWV0YWRhdGEgZnJvbSBhbiBPYnNpZGlhbiBmaWxlXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgZXh0cmFjdE1ldGFkYXRhKGZpbGU6IFRGaWxlLCBjb250ZW50Pzogc3RyaW5nKTogUHJvbWlzZTxEb2N1bWVudE1ldGFkYXRhPiB7XG5cdFx0Y29uc3QgZmlsZUNvbnRlbnQgPSBjb250ZW50IHx8IGF3YWl0IGZpbGUudmF1bHQucmVhZChmaWxlKTtcblx0XHRjb25zdCBmcm9udE1hdHRlciA9IHRoaXMuZXh0cmFjdEZyb250TWF0dGVyKGZpbGVDb250ZW50KTtcblx0XHRjb25zdCBtZXRhZGF0YTogRG9jdW1lbnRNZXRhZGF0YSA9IHtcblx0XHRcdG9ic2lkaWFuSWQ6IGZpbGUucGF0aCxcblx0XHRcdHBhdGg6IGZpbGUucGF0aCxcblx0XHRcdGxhc3RNb2RpZmllZDogZmlsZS5zdGF0Lm10aW1lLFxuXHRcdFx0Y3JlYXRlZDogZmlsZS5zdGF0LmN0aW1lLFxuXHRcdFx0c2l6ZTogZmlsZS5zdGF0LnNpemUsXG5cdFx0XHRmcm9udE1hdHRlcjogZnJvbnRNYXR0ZXIsXG5cdFx0XHR0YWdzOiB0aGlzLmV4dHJhY3RUYWdzKGZpbGVDb250ZW50LCBmcm9udE1hdHRlciksXG5cdFx0XHRsaW5rczogdGhpcy5leHRyYWN0TGlua3MoZmlsZUNvbnRlbnQpLFxuXHRcdFx0Y3VzdG9tTWV0YWRhdGE6IHt9XG5cdFx0fTtcblxuXHRcdC8vIEV4dHJhY3Qgb3B0aW9uYWwgYWxpYXNlcyBmcm9tIGZyb250bWF0dGVyXG5cdFx0Y29uc3QgYWxpYXNlcyA9IHRoaXMuZXh0cmFjdEFsaWFzZXMoZnJvbnRNYXR0ZXIpO1xuXHRcdGlmIChhbGlhc2VzLmxlbmd0aCA+IDApIHtcblx0XHRcdG1ldGFkYXRhLmN1c3RvbU1ldGFkYXRhLmFsaWFzZXMgPSBhbGlhc2VzO1xuXHRcdH1cblxuXHRcdC8vIEV4dHJhY3Qgc291cmNlIGxvY2F0aW9uIGlmIGF2YWlsYWJsZVxuXHRcdGNvbnN0IGxvYyA9IHRoaXMuZXh0cmFjdFNvdXJjZUxvY2F0aW9uKGZyb250TWF0dGVyKTtcblx0XHRpZiAobG9jKSB7XG5cdFx0XHRtZXRhZGF0YS5sb2MgPSBsb2M7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIG90aGVyIG9wdGlvbmFsIGZyb250bWF0dGVyIGZpZWxkcyBpZiBwcmVzZW50XG5cdFx0aWYgKGZyb250TWF0dGVyPy5zb3VyY2UpIHtcblx0XHRcdG1ldGFkYXRhLnNvdXJjZSA9IGZyb250TWF0dGVyLnNvdXJjZTtcblx0XHR9XG5cdFx0aWYgKGZyb250TWF0dGVyPy5maWxlX2lkKSB7XG5cdFx0XHRtZXRhZGF0YS5maWxlX2lkID0gZnJvbnRNYXR0ZXIuZmlsZV9pZDtcblx0XHR9XG5cdFx0aWYgKGZyb250TWF0dGVyPy5ibG9iVHlwZSkge1xuXHRcdFx0bWV0YWRhdGEuYmxvYlR5cGUgPSBmcm9udE1hdHRlci5ibG9iVHlwZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWV0YWRhdGE7XG5cdH1cblxuXHQvKipcblx0ICogRXh0cmFjdHMgbWV0YWRhdGEgZnJvbSB0aGUgcHJvdmlkZWQgY29udGVudCBhbmQgbWVyZ2VzIGl0IHdpdGggdGhlIGdpdmVuIGJhc2UgbWV0YWRhdGEgYW5kIGZyb250IG1hdHRlci5cblx0ICogVGhpcyBuZXcgbWV0aG9kIGlzIHVzZWQgYnkgdGhlIFRleHRTcGxpdHRlciB0byBlbmhhbmNlIG1ldGFkYXRhIGJhc2VkIG9uIHBhcnNlZCBmcm9udCBtYXR0ZXIuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgZXh0cmFjdE1ldGFkYXRhRnJvbUNvbnRlbnQoXG5cdFx0Y29udGVudDogc3RyaW5nLFxuXHRcdGJhc2VNZXRhZGF0YTogRG9jdW1lbnRNZXRhZGF0YSxcblx0XHRmcm9udE1hdHRlcjogUmVjb3JkPHN0cmluZywgYW55PiB8IG51bGxcblx0KTogUHJvbWlzZTxEb2N1bWVudE1ldGFkYXRhPiB7XG5cdFx0Y29uc3QgbWVyZ2VkID0geyAuLi5iYXNlTWV0YWRhdGEgfTtcblx0XHRpZiAoZnJvbnRNYXR0ZXIpIHtcblx0XHRcdG1lcmdlZC5mcm9udE1hdHRlciA9IGZyb250TWF0dGVyO1xuXHRcdFx0Ly8gTWVyZ2UgdGFncyBmcm9tIGZyb250IG1hdHRlclxuXHRcdFx0aWYgKGZyb250TWF0dGVyLnRhZ3MpIHtcblx0XHRcdFx0bWVyZ2VkLnRhZ3MgPSBBcnJheS5pc0FycmF5KGZyb250TWF0dGVyLnRhZ3MpID8gZnJvbnRNYXR0ZXIudGFncyA6IFtmcm9udE1hdHRlci50YWdzXTtcblx0XHRcdH1cblx0XHRcdC8vIE1lcmdlIGFsaWFzZXMgaW50byBjdXN0b21NZXRhZGF0YVxuXHRcdFx0aWYgKGZyb250TWF0dGVyLmFsaWFzZXMpIHtcblx0XHRcdFx0bWVyZ2VkLmN1c3RvbU1ldGFkYXRhID0gbWVyZ2VkLmN1c3RvbU1ldGFkYXRhIHx8IHt9O1xuXHRcdFx0XHRtZXJnZWQuY3VzdG9tTWV0YWRhdGEuYWxpYXNlcyA9IEFycmF5LmlzQXJyYXkoZnJvbnRNYXR0ZXIuYWxpYXNlcylcblx0XHRcdFx0XHQ/IGZyb250TWF0dGVyLmFsaWFzZXNcblx0XHRcdFx0XHQ6IFtmcm9udE1hdHRlci5hbGlhc2VzXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1lcmdlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFeHRyYWN0cyBZQU1MIGZyb250IG1hdHRlciBmcm9tIGRvY3VtZW50IGNvbnRlbnRcblx0ICovXG5cdHByaXZhdGUgZXh0cmFjdEZyb250TWF0dGVyKGNvbnRlbnQ6IHN0cmluZyk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBmcm9udE1hdHRlck1hdGNoID0gY29udGVudC5tYXRjaCgvXi0tLVxcbihbXFxzXFxTXSo/KVxcbi0tLS8pO1xuXHRcdFx0aWYgKCFmcm9udE1hdHRlck1hdGNoKSByZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0Y29uc3QgeWFtbCA9IGZyb250TWF0dGVyTWF0Y2hbMV07XG5cdFx0XHRyZXR1cm4gcGFyc2VZYW1sKHlhbWwpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIGZyb250bWF0dGVyOicsIGVycm9yKTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgJHtEb2N1bWVudFByb2Nlc3NpbmdFcnJvci5ZQU1MX1BBUlNFX0VSUk9SfTogJHtlcnJvci5tZXNzYWdlfWApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFeHRyYWN0cyBpbnRlcm5hbCBsaW5rcyBmcm9tIGRvY3VtZW50IGNvbnRlbnQuXG5cdCAqL1xuXHRwcml2YXRlIGV4dHJhY3RMaW5rcyhjb250ZW50OiBzdHJpbmcpOiBzdHJpbmdbXSB7XG5cdFx0Y29uc3QgbGlua1JlZ2V4ID0gL1xcW1xcWyguKj8pKD86XFx8Lio/KT9cXF1cXF0vZztcblx0XHRjb25zdCBsaW5rcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXHRcdGxldCBtYXRjaDtcblx0XHR3aGlsZSAoKG1hdGNoID0gbGlua1JlZ2V4LmV4ZWMoY29udGVudCkpICE9PSBudWxsKSB7XG5cdFx0XHRjb25zdCBsaW5rID0gbWF0Y2hbMV0uc3BsaXQoJ3wnKVswXTtcblx0XHRcdGNvbnN0IGNsZWFuTGluayA9IHRoaXMuY2xlYW5MaW5rKGxpbmspO1xuXHRcdFx0aWYgKGNsZWFuTGluaykge1xuXHRcdFx0XHRsaW5rcy5hZGQoY2xlYW5MaW5rKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIEFycmF5LmZyb20obGlua3MpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFucyBhbmQgbm9ybWFsaXplcyBhIGxpbmsgcGF0aC5cblx0ICovXG5cdHByaXZhdGUgY2xlYW5MaW5rKGxpbms6IHN0cmluZyk6IHN0cmluZyB7XG5cdFx0bGV0IGNsZWFuTGluayA9IGxpbmsuc3BsaXQoJyMnKVswXTtcblx0XHRjbGVhbkxpbmsgPSBjbGVhbkxpbmsuc3BsaXQoJz8nKVswXTtcblx0XHRjbGVhbkxpbmsgPSBjbGVhbkxpbmsudHJpbSgpO1xuXHRcdHJldHVybiBjbGVhbkxpbms7XG5cdH1cblxuXHQvKipcblx0ICogRXh0cmFjdHMgdGFncyBmcm9tIGJvdGggY29udGVudCBhbmQgZnJvbnQgbWF0dGVyLlxuXHQgKi9cblx0cHJpdmF0ZSBleHRyYWN0VGFncyhjb250ZW50OiBzdHJpbmcsIGZyb250TWF0dGVyPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHN0cmluZ1tdIHtcblx0XHRjb25zdCB0YWdzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cdFx0Y29uc3QgdGFnUmVnZXggPSAvIyhbQS1aYS16MC05L18tXSspL2c7XG5cdFx0bGV0IG1hdGNoO1xuXHRcdHdoaWxlICgobWF0Y2ggPSB0YWdSZWdleC5leGVjKGNvbnRlbnQpKSAhPT0gbnVsbCkge1xuXHRcdFx0dGFncy5hZGQobWF0Y2hbMV0pO1xuXHRcdH1cblx0XHRpZiAoZnJvbnRNYXR0ZXI/LnRhZ3MpIHtcblx0XHRcdGNvbnN0IGZyb250TWF0dGVyVGFncyA9IEFycmF5LmlzQXJyYXkoZnJvbnRNYXR0ZXIudGFncylcblx0XHRcdFx0PyBmcm9udE1hdHRlci50YWdzXG5cdFx0XHRcdDogW2Zyb250TWF0dGVyLnRhZ3NdO1xuXHRcdFx0ZnJvbnRNYXR0ZXJUYWdzLmZvckVhY2godGFnID0+IHtcblx0XHRcdFx0aWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0Y29uc3QgY2xlYW5UYWcgPSB0YWcuc3RhcnRzV2l0aCgnIycpID8gdGFnLnNsaWNlKDEpIDogdGFnO1xuXHRcdFx0XHRcdHRhZ3MuYWRkKGNsZWFuVGFnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBBcnJheS5mcm9tKHRhZ3MpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4dHJhY3RzIGFsaWFzZXMgZnJvbSBmcm9udCBtYXR0ZXIuXG5cdCAqL1xuXHRwcml2YXRlIGV4dHJhY3RBbGlhc2VzKGZyb250TWF0dGVyPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHN0cmluZ1tdIHtcblx0XHRpZiAoIWZyb250TWF0dGVyPy5hbGlhc2VzKSByZXR1cm4gW107XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZnJvbnRNYXR0ZXIuYWxpYXNlcykpIHtcblx0XHRcdHJldHVybiBmcm9udE1hdHRlci5hbGlhc2VzLmZpbHRlcihhbGlhcyA9PiB0eXBlb2YgYWxpYXMgPT09ICdzdHJpbmcnKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBmcm9udE1hdHRlci5hbGlhc2VzID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIFtmcm9udE1hdHRlci5hbGlhc2VzXTtcblx0XHR9XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4dHJhY3RzIHNvdXJjZSBsb2NhdGlvbiBpbmZvcm1hdGlvbiBmcm9tIGZyb250IG1hdHRlci5cblx0ICovXG5cdHByaXZhdGUgZXh0cmFjdFNvdXJjZUxvY2F0aW9uKGZyb250TWF0dGVyPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHsgbGluZXM6IHsgZnJvbTogbnVtYmVyOyB0bzogbnVtYmVyIH0gfSB8IHVuZGVmaW5lZCB7XG5cdFx0aWYgKCFmcm9udE1hdHRlcj8ubG9jPy5saW5lcz8uZnJvbSB8fCAhZnJvbnRNYXR0ZXI/LmxvYz8ubGluZXM/LnRvKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0bGluZXM6IHtcblx0XHRcdFx0ZnJvbTogTnVtYmVyKGZyb250TWF0dGVyLmxvYy5saW5lcy5mcm9tKSxcblx0XHRcdFx0dG86IE51bWJlcihmcm9udE1hdHRlci5sb2MubGluZXMudG8pXG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufVxuIiwgIi8vVGV4dFNwbGl0dGVyLnRzXG5pbXBvcnQge1xuXHREb2N1bWVudENodW5rLFxuXHREb2N1bWVudE1ldGFkYXRhLFxuXHREb2N1bWVudFByb2Nlc3NpbmdFcnJvcixcbn0gZnJvbSAnLi4vbW9kZWxzL0RvY3VtZW50Q2h1bmsnO1xuaW1wb3J0IHsgREVGQVVMVF9DSFVOS0lOR19PUFRJT05TIH0gZnJvbSAnLi4vc2V0dGluZ3MvU2V0dGluZ3MnO1xuaW1wb3J0IHsgTWV0YWRhdGFFeHRyYWN0b3IgfSBmcm9tICcuLi9zZXJ2aWNlcy9NZXRhZGF0YUV4dHJhY3Rvcic7XG5cbmV4cG9ydCBjbGFzcyBUZXh0U3BsaXR0ZXIge1xuXHRwcml2YXRlIHNldHRpbmdzOiB7XG5cdFx0Y2h1bmtTaXplOiBudW1iZXI7XG5cdFx0Y2h1bmtPdmVybGFwOiBudW1iZXI7XG5cdFx0bWluQ2h1bmtTaXplOiBudW1iZXI7XG5cdH07XG5cdHByaXZhdGUgbWV0YWRhdGFFeHRyYWN0b3I6IE1ldGFkYXRhRXh0cmFjdG9yO1xuXHQvLyBSZWdleCBwYXR0ZXJucyBmb3Igc3BsaXR0aW5nXG5cdHByaXZhdGUgcmVhZG9ubHkgU0VOVEVOQ0VfQk9VTkRBUlkgPSAvWy4hP11cXHMrLztcblx0cHJpdmF0ZSByZWFkb25seSBQQVJBR1JBUEhfQk9VTkRBUlkgPSAvXFxuXFxzKlxcbi87XG5cdHByaXZhdGUgcmVhZG9ubHkgWUFNTF9GUk9OVF9NQVRURVIgPSAvXi0tLVxcbihbXFxzXFxTXSo/KVxcbi0tLS87XG5cblx0Y29uc3RydWN0b3IoXG5cdFx0c2V0dGluZ3M/OiB7IGNodW5rU2l6ZTogbnVtYmVyOyBjaHVua092ZXJsYXA6IG51bWJlcjsgbWluQ2h1bmtTaXplOiBudW1iZXIgfSxcblx0XHRtZXRhZGF0YUV4dHJhY3Rvcj86IE1ldGFkYXRhRXh0cmFjdG9yXG5cdCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7IC4uLkRFRkFVTFRfQ0hVTktJTkdfT1BUSU9OUyB9O1xuXHRcdHRoaXMudmFsaWRhdGVTZXR0aW5ncyh0aGlzLnNldHRpbmdzKTtcblx0XHR0aGlzLm1ldGFkYXRhRXh0cmFjdG9yID0gbWV0YWRhdGFFeHRyYWN0b3IgfHwgbmV3IE1ldGFkYXRhRXh0cmFjdG9yKCk7XG5cdH1cblxuXHQvKiogUmV0dXJucyB0aGUgY3VycmVudCBjaHVua2luZyBzZXR0aW5ncy4gKi9cblx0cHVibGljIGdldFNldHRpbmdzKCk6IHsgY2h1bmtTaXplOiBudW1iZXI7IGNodW5rT3ZlcmxhcDogbnVtYmVyOyBtaW5DaHVua1NpemU6IG51bWJlciB9IHtcblx0XHRyZXR1cm4gdGhpcy5zZXR0aW5ncztcblx0fVxuXG5cdHByaXZhdGUgdmFsaWRhdGVTZXR0aW5ncyhzZXR0aW5nczogeyBjaHVua1NpemU6IG51bWJlcjsgY2h1bmtPdmVybGFwOiBudW1iZXI7IG1pbkNodW5rU2l6ZTogbnVtYmVyIH0pOiB2b2lkIHtcblx0XHRpZiAoc2V0dGluZ3MuY2h1bmtTaXplIDw9IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ2h1bmsgc2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLicpO1xuXHRcdH1cblx0XHRpZiAoc2V0dGluZ3MuY2h1bmtPdmVybGFwID49IHNldHRpbmdzLmNodW5rU2l6ZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDaHVuayBvdmVybGFwIG11c3QgYmUgbGVzcyB0aGFuIGNodW5rIHNpemUuJyk7XG5cdFx0fVxuXHRcdGlmIChzZXR0aW5ncy5taW5DaHVua1NpemUgPiBzZXR0aW5ncy5jaHVua1NpemUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWluaW11bSBjaHVuayBzaXplIG11c3Qgbm90IGV4Y2VlZCBjaHVuayBzaXplLicpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTcGxpdHMgYSBkb2N1bWVudCBpbnRvIGNodW5rcyB3aGlsZSBlbmhhbmNpbmcgbWV0YWRhdGEuXG5cdCAqIEV4dHJhY3RzIFlBTUwgZnJvbnQgbWF0dGVyIGlmIHByZXNlbnQsIGFuZCB0aGVuIHVzZXMgdGhlIE1ldGFkYXRhRXh0cmFjdG9yXG5cdCAqIHRvIG1lcmdlIGFkZGl0aW9uYWwgbWV0YWRhdGEgKGUuZy4sIHRhZ3MsIGFsaWFzZXMsIGxpbmtzKSBpbnRvIHRoZSBiYXNlIG1ldGFkYXRhLlxuXHQgKlxuXHQgKiBAcGFyYW0gY29udGVudCBUaGUgZnVsbCB0ZXh0IGNvbnRlbnQgb2YgdGhlIGRvY3VtZW50LlxuXHQgKiBAcGFyYW0gbWV0YWRhdGEgQmFzZSBtZXRhZGF0YSBmb3IgdGhlIGRvY3VtZW50LlxuXHQgKiBAcGFyYW0gYWJvcnRTaWduYWwgT3B0aW9uYWwgQWJvcnRTaWduYWwgdG8gY2FuY2VsIHRoZSBvcGVyYXRpb24uXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIERvY3VtZW50Q2h1bmsuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgc3BsaXREb2N1bWVudChcblx0XHRjb250ZW50OiBzdHJpbmcsXG5cdFx0bWV0YWRhdGE6IERvY3VtZW50TWV0YWRhdGEsXG5cdFx0YWJvcnRTaWduYWw/OiBBYm9ydFNpZ25hbFxuXHQpOiBQcm9taXNlPERvY3VtZW50Q2h1bmtbXT4ge1xuXHRcdGNvbnN0IHBlcmZvcm1hbmNlTWV0cmljczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuXHRcdGNvbnN0IG92ZXJhbGxTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGNvbnNvbGUubG9nKCdTdGFydGluZyBkb2N1bWVudCBzcGxpdCcsIHsgY29udGVudExlbmd0aDogY29udGVudC5sZW5ndGgsIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzIH0pO1xuXG5cdFx0XHRpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCBzcGxpdHRpbmcgYWJvcnRlZCBiZWZvcmUgc3RhcnQnKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFjb250ZW50Py50cmltKCkpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0VtcHR5IGNvbnRlbnQgcmVjZWl2ZWQnKTtcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdHRlbXB0IHRvIGV4dHJhY3QgWUFNTCBmcm9udCBtYXR0ZXIgd2l0aG91dCBhbHRlcmluZyB0aGUgb3JpZ2luYWwgY29udGVudC5cblx0XHRcdGxldCBmcm9udE1hdHRlciA9IG51bGw7XG5cdFx0XHRjb25zdCBmcm9udE1hdHRlck1hdGNoID0gdGhpcy5ZQU1MX0ZST05UX01BVFRFUi5leGVjKGNvbnRlbnQpO1xuXHRcdFx0aWYgKGZyb250TWF0dGVyTWF0Y2gpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmcm9udE1hdHRlciA9IHRoaXMucGFyc2VGcm9udE1hdHRlcihmcm9udE1hdHRlck1hdGNoWzFdKTtcblx0XHRcdFx0XHQvLyBFbmhhbmNlIG1ldGFkYXRhIHVzaW5nIE1ldGFkYXRhRXh0cmFjdG9yIHdpdGggZXh0cmFjdGVkIGZyb250IG1hdHRlci5cblx0XHRcdFx0XHRjb25zdCBlbmhhbmNlZE1ldGFkYXRhID0gYXdhaXQgdGhpcy5tZXRhZGF0YUV4dHJhY3Rvci5leHRyYWN0TWV0YWRhdGFGcm9tQ29udGVudChcblx0XHRcdFx0XHRcdGNvbnRlbnQsXG5cdFx0XHRcdFx0XHRtZXRhZGF0YSxcblx0XHRcdFx0XHRcdGZyb250TWF0dGVyXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRtZXRhZGF0YSA9IHsgLi4ubWV0YWRhdGEsIC4uLmVuaGFuY2VkTWV0YWRhdGEgfTtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygnRnJvbnQgbWF0dGVyIGV4dHJhY3RlZCBhbmQgbWV0YWRhdGEgZW5oYW5jZWQnLCB7IGZyb250TWF0dGVyIH0pO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIGZyb250IG1hdHRlcicsIGVycm9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0cmltbWVkQ29udGVudCA9IGNvbnRlbnQudHJpbSgpO1xuXHRcdFx0aWYgKGFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRG9jdW1lbnQgc3BsaXR0aW5nIGFib3J0ZWQgYWZ0ZXIgZnJvbnQgbWF0dGVyIHByb2Nlc3NpbmcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgY29udGVudCBpcyBzbWFsbGVyIHRoYW4gdGhlIGNodW5rIHNpemUsIHJldHVybiBhcyBhIHNpbmdsZSBjaHVuay5cblx0XHRcdGlmICh0cmltbWVkQ29udGVudC5sZW5ndGggPD0gTWF0aC5tYXgodGhpcy5zZXR0aW5ncy5taW5DaHVua1NpemUsIHRoaXMuc2V0dGluZ3MuY2h1bmtTaXplKSkge1xuXHRcdFx0XHRpZiAodHJpbW1lZENvbnRlbnQubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ05vIGNvbnRlbnQgYWZ0ZXIgdHJpbW1pbmcsIHJldHVybmluZyBlbXB0eSBhcnJheScpO1xuXHRcdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zb2xlLmxvZygnQ29udGVudCBpcyBzbWFsbGVyIHRoYW4gY2h1bmsgc2l6ZSwgY3JlYXRpbmcgc2luZ2xlIGNodW5rJywge1xuXHRcdFx0XHRcdGNvbnRlbnRMZW5ndGg6IHRyaW1tZWRDb250ZW50Lmxlbmd0aCxcblx0XHRcdFx0XHRjaHVua1NpemU6IHRoaXMuc2V0dGluZ3MuY2h1bmtTaXplLFxuXHRcdFx0XHRcdG1pbkNodW5rU2l6ZTogdGhpcy5zZXR0aW5ncy5taW5DaHVua1NpemUsXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRjb25zdCBzaW5nbGVDaHVuayA9IHRoaXMuY3JlYXRlQ2h1bmsodHJpbW1lZENvbnRlbnQsIDAsIG1ldGFkYXRhKTtcblx0XHRcdFx0cGVyZm9ybWFuY2VNZXRyaWNzLnNpbmdsZUNodW5rVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gb3ZlcmFsbFN0YXJ0O1xuXHRcdFx0XHRjb25zb2xlLmxvZygnQ3JlYXRlZCBzaW5nbGUgY2h1bmsnLCB7IGNodW5rU2l6ZTogc2luZ2xlQ2h1bmsuY29udGVudC5sZW5ndGgsIHByZXZpZXc6IHNpbmdsZUNodW5rLmNvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMCkgfSk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGBEb2N1bWVudCBzcGxpdCBjb21wbGV0ZWQgaW4gJHtwZXJmb3JtYW5jZS5ub3coKSAtIG92ZXJhbGxTdGFydH0gbXNgLCBwZXJmb3JtYW5jZU1ldHJpY3MpO1xuXHRcdFx0XHRyZXR1cm4gW3NpbmdsZUNodW5rXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3BsaXQgY29udGVudCBpbnRvIHBhcmFncmFwaHMuXG5cdFx0XHRjb25zdCBwYXJhZ3JhcGhzID0gY29udGVudC5zcGxpdCh0aGlzLlBBUkFHUkFQSF9CT1VOREFSWSlcblx0XHRcdFx0Lm1hcChwID0+IHAudHJpbSgpKVxuXHRcdFx0XHQuZmlsdGVyKHAgPT4gcC5sZW5ndGggPiAwKTtcblx0XHRcdGNvbnNvbGUubG9nKCdTcGxpdCBpbnRvIHBhcmFncmFwaHMnLCB7IHBhcmFncmFwaENvdW50OiBwYXJhZ3JhcGhzLmxlbmd0aCwgcGFyYWdyYXBoczogcGFyYWdyYXBocy5tYXAocCA9PiBwLnN1YnN0cmluZygwLCAxMDApKSB9KTtcblxuXHRcdFx0aWYgKGFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRG9jdW1lbnQgc3BsaXR0aW5nIGFib3J0ZWQgYWZ0ZXIgcGFyYWdyYXBoIHNwbGl0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBjaHVua3M6IERvY3VtZW50Q2h1bmtbXSA9IFtdO1xuXHRcdFx0bGV0IGN1cnJlbnRDaHVuayA9ICcnO1xuXHRcdFx0bGV0IGNodW5rSW5kZXggPSAwO1xuXG5cdFx0XHQvLyBQcm9jZXNzIGVhY2ggcGFyYWdyYXBoXG5cdFx0XHRmb3IgKGNvbnN0IHBhcmFncmFwaCBvZiBwYXJhZ3JhcGhzKSB7XG5cdFx0XHRcdGlmIChhYm9ydFNpZ25hbD8uYWJvcnRlZCkge1xuXHRcdFx0XHRcdC8vIENsZWFudXAgYW55IHBhcnRpYWwgcmVzdWx0cyBpZiBhYm9ydGVkXG5cdFx0XHRcdFx0Y2h1bmtzID0gW107XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCBzcGxpdHRpbmcgYWJvcnRlZCBkdXJpbmcgcHJvY2Vzc2luZycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElmIHBhcmFncmFwaCBpcyBsYXJnZXIgdGhhbiB0aGUgY2h1bmsgc2l6ZSwgc3BsaXQgaXQgaW50byBzZW50ZW5jZXMuXG5cdFx0XHRcdGlmIChwYXJhZ3JhcGgubGVuZ3RoID49IHRoaXMuc2V0dGluZ3MuY2h1bmtTaXplKSB7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRDaHVuaykge1xuXHRcdFx0XHRcdFx0Y2h1bmtzLnB1c2godGhpcy5jcmVhdGVDaHVuayhjdXJyZW50Q2h1bmssIGNodW5rSW5kZXgrKywgbWV0YWRhdGEpKTtcblx0XHRcdFx0XHRcdGN1cnJlbnRDaHVuayA9ICcnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBzZW50ZW5jZXMgPSBwYXJhZ3JhcGguc3BsaXQodGhpcy5TRU5URU5DRV9CT1VOREFSWSk7XG5cdFx0XHRcdFx0bGV0IHNlbnRlbmNlQ2h1bmsgPSAnJztcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHNlbnRlbmNlIG9mIHNlbnRlbmNlcykge1xuXHRcdFx0XHRcdFx0aWYgKGFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG5cdFx0XHRcdFx0XHRcdGNodW5rcyA9IFtdO1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0RvY3VtZW50IHNwbGl0dGluZyBhYm9ydGVkIGR1cmluZyBzZW50ZW5jZSBwcm9jZXNzaW5nJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb25zdCB0cmltbWVkU2VudGVuY2UgPSBzZW50ZW5jZS50cmltKCk7XG5cdFx0XHRcdFx0XHRpZiAoIXRyaW1tZWRTZW50ZW5jZSkgY29udGludWU7XG5cdFx0XHRcdFx0XHRpZiAoKHNlbnRlbmNlQ2h1bmsgKyAnICcgKyB0cmltbWVkU2VudGVuY2UpLmxlbmd0aCA+IHRoaXMuc2V0dGluZ3MuY2h1bmtTaXplKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChzZW50ZW5jZUNodW5rKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2h1bmtzLnB1c2godGhpcy5jcmVhdGVDaHVuayhzZW50ZW5jZUNodW5rLCBjaHVua0luZGV4KyssIG1ldGFkYXRhKSk7XG5cdFx0XHRcdFx0XHRcdFx0c2VudGVuY2VDaHVuayA9IHRyaW1tZWRTZW50ZW5jZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgdmVyeSBsb25nIHNlbnRlbmNlcywgZm9yY2Ugc3BsaXQuXG5cdFx0XHRcdFx0XHRcdFx0bGV0IHBvc2l0aW9uID0gMDtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAocG9zaXRpb24gPCB0cmltbWVkU2VudGVuY2UubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBjaHVua1RleHQgPSB0cmltbWVkU2VudGVuY2Uuc2xpY2UoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRNYXRoLm1pbihwb3NpdGlvbiArIHRoaXMuc2V0dGluZ3MuY2h1bmtTaXplLCB0cmltbWVkU2VudGVuY2UubGVuZ3RoKVxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdGNodW5rcy5wdXNoKHRoaXMuY3JlYXRlQ2h1bmsoY2h1bmtUZXh0LCBjaHVua0luZGV4KyssIG1ldGFkYXRhKSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSB0aGlzLnNldHRpbmdzLmNodW5rU2l6ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0c2VudGVuY2VDaHVuayA9ICcnO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzZW50ZW5jZUNodW5rICs9IChzZW50ZW5jZUNodW5rID8gJyAnIDogJycpICsgdHJpbW1lZFNlbnRlbmNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc2VudGVuY2VDaHVuaykge1xuXHRcdFx0XHRcdFx0Y2h1bmtzLnB1c2godGhpcy5jcmVhdGVDaHVuayhzZW50ZW5jZUNodW5rLCBjaHVua0luZGV4KyssIG1ldGFkYXRhKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEFjY3VtdWxhdGUgcGFyYWdyYXBocyB1bnRpbCByZWFjaGluZyBjaHVuayBzaXplLlxuXHRcdFx0XHRcdGNvbnN0IHBvdGVudGlhbENodW5rU2l6ZSA9IGN1cnJlbnRDaHVua1xuXHRcdFx0XHRcdFx0PyBjdXJyZW50Q2h1bmsubGVuZ3RoICsgMiArIHBhcmFncmFwaC5sZW5ndGhcblx0XHRcdFx0XHRcdDogcGFyYWdyYXBoLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAocG90ZW50aWFsQ2h1bmtTaXplIDw9IHRoaXMuc2V0dGluZ3MuY2h1bmtTaXplKSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50Q2h1bmsgKz0gKGN1cnJlbnRDaHVuayA/ICdcXG5cXG4nIDogJycpICsgcGFyYWdyYXBoO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudENodW5rKSB7XG5cdFx0XHRcdFx0XHRcdGNodW5rcy5wdXNoKHRoaXMuY3JlYXRlQ2h1bmsoY3VycmVudENodW5rLCBjaHVua0luZGV4KyssIG1ldGFkYXRhKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjdXJyZW50Q2h1bmsgPSBwYXJhZ3JhcGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY3VycmVudENodW5rKSB7XG5cdFx0XHRcdGNodW5rcy5wdXNoKHRoaXMuY3JlYXRlQ2h1bmsoY3VycmVudENodW5rLCBjaHVua0luZGV4KyssIG1ldGFkYXRhKSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMCAmJiB0cmltbWVkQ29udGVudC5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdDcmVhdGluZyBmYWxsYmFjayBjaHVuayBmb3IgY29udGVudCcsIHsgY29udGVudExlbmd0aDogdHJpbW1lZENvbnRlbnQubGVuZ3RoIH0pO1xuXHRcdFx0XHRjaHVua3MucHVzaCh0aGlzLmNyZWF0ZUNodW5rKHRyaW1tZWRDb250ZW50LCAwLCBtZXRhZGF0YSkpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQXBwbHkgb3ZlcmxhcCBiZXR3ZWVuIGNodW5rcyBpZiBjb25maWd1cmVkLlxuXHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuY2h1bmtPdmVybGFwID4gMCAmJiBjaHVua3MubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRjaHVua3MgPSB0aGlzLmFwcGx5T3ZlcmxhcChjaHVua3MpO1xuXHRcdFx0fVxuXG5cdFx0XHRwZXJmb3JtYW5jZU1ldHJpY3MudG90YWxTcGxpdHRpbmdUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBvdmVyYWxsU3RhcnQ7XG5cdFx0XHRjb25zb2xlLmxvZygnRmluaXNoZWQgY3JlYXRpbmcgY2h1bmtzJywge1xuXHRcdFx0XHRjaHVua0NvdW50OiBjaHVua3MubGVuZ3RoLFxuXHRcdFx0XHRjaHVua1NpemVzOiBjaHVua3MubWFwKGMgPT4gYy5jb250ZW50Lmxlbmd0aCksXG5cdFx0XHRcdGNodW5rUHJldmlld3M6IGNodW5rcy5tYXAoYyA9PiAoe1xuXHRcdFx0XHRcdGluZGV4OiBjLmNodW5rSW5kZXgsXG5cdFx0XHRcdFx0c2l6ZTogYy5jb250ZW50Lmxlbmd0aCxcblx0XHRcdFx0XHRwcmV2aWV3OiBjLmNvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMCksXG5cdFx0XHRcdH0pKSxcblx0XHRcdFx0cGVyZm9ybWFuY2VNZXRyaWNzXG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBjaHVua3M7XG5cdFx0fSBjYXRjaCAoZXJyb3I6IGFueSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgaW4gc3BsaXREb2N1bWVudCcsIGVycm9yKTtcblx0XHRcdC8vIEVuc3VyZSBhbnkgcGFydGlhbCByZXN1bHRzIGFyZSBjbGVhbmVkIHVwXG5cdFx0XHR0aHJvdyB7XG5cdFx0XHRcdHR5cGU6IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLkNIVU5LSU5HX0VSUk9SLFxuXHRcdFx0XHRtZXNzYWdlOiAnRXJyb3Igb2NjdXJyZWQgZHVyaW5nIGRvY3VtZW50IGNodW5raW5nJyxcblx0XHRcdFx0ZGV0YWlsczogZXJyb3IubWVzc2FnZSxcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBjcmVhdGVDaHVuayhjb250ZW50OiBzdHJpbmcsIGluZGV4OiBudW1iZXIsIG1ldGFkYXRhOiBEb2N1bWVudE1ldGFkYXRhKTogRG9jdW1lbnRDaHVuayB7XG5cdFx0Y29uc3QgdHJpbW1lZENvbnRlbnQgPSBjb250ZW50LnRyaW0oKTtcblx0XHRpZiAodHJpbW1lZENvbnRlbnQubGVuZ3RoIDwgdGhpcy5zZXR0aW5ncy5taW5DaHVua1NpemUpIHtcblx0XHRcdGNvbnNvbGUud2FybignQ2h1bmsgc21hbGxlciB0aGFuIG1pbkNodW5rU2l6ZScsIHtcblx0XHRcdFx0c2l6ZTogdHJpbW1lZENvbnRlbnQubGVuZ3RoLFxuXHRcdFx0XHRtaW5TaXplOiB0aGlzLnNldHRpbmdzLm1pbkNodW5rU2l6ZSxcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0Y29udGVudDogdHJpbW1lZENvbnRlbnQsXG5cdFx0XHRjaHVua0luZGV4OiBpbmRleCxcblx0XHRcdG1ldGFkYXRhOiB7IC4uLm1ldGFkYXRhIH0sXG5cdFx0fTtcblx0fVxuXG5cdHByaXZhdGUgYXBwbHlPdmVybGFwKGNodW5rczogRG9jdW1lbnRDaHVua1tdKTogRG9jdW1lbnRDaHVua1tdIHtcblx0XHRpZiAoY2h1bmtzLmxlbmd0aCA8PSAxKSByZXR1cm4gY2h1bmtzO1xuXHRcdGNvbnN0IGNodW5rc1dpdGhPdmVybGFwID0gWy4uLmNodW5rc107XG5cdFx0Zm9yIChsZXQgaSA9IGNodW5rc1dpdGhPdmVybGFwLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcblx0XHRcdGNvbnN0IGN1cnJlbnRDaHVuayA9IHsgLi4uY2h1bmtzV2l0aE92ZXJsYXBbaV0gfTtcblx0XHRcdGNvbnN0IHByZXZpb3VzQ2h1bmsgPSBjaHVua3NXaXRoT3ZlcmxhcFtpIC0gMV07XG5cdFx0XHRjb25zdCBvdmVybGFwVGV4dCA9IHByZXZpb3VzQ2h1bmsuY29udGVudC5zbGljZSgtdGhpcy5zZXR0aW5ncy5jaHVua092ZXJsYXApO1xuXHRcdFx0aWYgKG92ZXJsYXBUZXh0KSB7XG5cdFx0XHRcdGNodW5rc1dpdGhPdmVybGFwW2ldID0ge1xuXHRcdFx0XHRcdC4uLmN1cnJlbnRDaHVuayxcblx0XHRcdFx0XHRjb250ZW50OiBvdmVybGFwVGV4dCArICdcXG5cXG4nICsgY3VycmVudENodW5rLmNvbnRlbnQsXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjaHVua3NXaXRoT3ZlcmxhcDtcblx0fVxuXG5cdHByaXZhdGUgcGFyc2VGcm9udE1hdHRlcihmcm9udE1hdHRlcjogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHJlc3VsdDogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuXHRcdFx0Y29uc3QgbGluZXMgPSBmcm9udE1hdHRlci5zcGxpdCgnXFxuJyk7XG5cdFx0XHRmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcblx0XHRcdFx0Y29uc3QgdHJpbW1lZExpbmUgPSBsaW5lLnRyaW0oKTtcblx0XHRcdFx0aWYgKCF0cmltbWVkTGluZSB8fCB0cmltbWVkTGluZS5zdGFydHNXaXRoKCcjJykpIGNvbnRpbnVlO1xuXHRcdFx0XHRjb25zdCBzZXBhcmF0b3JJbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuXHRcdFx0XHRpZiAoc2VwYXJhdG9ySW5kZXggPT09IC0xKSBjb250aW51ZTtcblx0XHRcdFx0Y29uc3Qga2V5ID0gbGluZS5zbGljZSgwLCBzZXBhcmF0b3JJbmRleCkudHJpbSgpO1xuXHRcdFx0XHRsZXQgdmFsdWUgPSBsaW5lLnNsaWNlKHNlcGFyYXRvckluZGV4ICsgMSkudHJpbSgpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL15bXCInXSguKilbXCInXSQvLCAnJDEnKTtcblx0XHRcdFx0aWYgKHZhbHVlLnN0YXJ0c1dpdGgoJy0gJykpIHtcblx0XHRcdFx0XHRyZXN1bHRba2V5XSA9IHZhbHVlXG5cdFx0XHRcdFx0XHQuc3BsaXQoJ1xcbicpXG5cdFx0XHRcdFx0XHQubWFwKGl0ZW0gPT4gaXRlbS5yZXBsYWNlKCctICcsICcnKS50cmltKCkpXG5cdFx0XHRcdFx0XHQuZmlsdGVyKEJvb2xlYW4pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc3VsdFtrZXldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIGZyb250IG1hdHRlcicsIGVycm9yKTtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cdH1cbn1cbiIsICIvLyBzcmMvc2VydmljZXMvRXZlbnRFbWl0dGVyLnRzXG5pbXBvcnQgeyBRdWV1ZUV2ZW50VHlwZXMsIFF1ZXVlRXZlbnRDYWxsYmFjayB9IGZyb20gJy4uL21vZGVscy9RdWV1ZUV2ZW50cyc7XG5cbmV4cG9ydCBjbGFzcyBFdmVudEVtaXR0ZXIge1xuXHRwcml2YXRlIGxpc3RlbmVyczogTWFwPHN0cmluZywgU2V0PEZ1bmN0aW9uPj4gPSBuZXcgTWFwKCk7XG5cblx0LyoqXG5cdCAqIEVtaXQgYW4gZXZlbnQgd2l0aCBhc3NvY2lhdGVkIGRhdGEuXG5cdCAqIExpc3RlbmVycyByZWdpc3RlcmVkIGZvciB0aGlzIGV2ZW50IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGRhdGEuXG5cdCAqL1xuXHRlbWl0PFQgZXh0ZW5kcyBrZXlvZiBRdWV1ZUV2ZW50VHlwZXM+KGV2ZW50OiBULCBkYXRhOiBRdWV1ZUV2ZW50VHlwZXNbVF0pOiB2b2lkIHtcblx0XHRjb25zdCBjYWxsYmFja3MgPSB0aGlzLmxpc3RlbmVycy5nZXQoZXZlbnQpO1xuXHRcdGlmIChjYWxsYmFja3MpIHtcblx0XHRcdGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZGF0YSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihgRXJyb3IgaW4gbGlzdGVuZXIgZm9yIGV2ZW50IFwiJHtldmVudH1cIjpgLCBlcnJvcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIHNwZWNpZmllZCBldmVudCBpcyBlbWl0dGVkLlxuXHQgKiBSZXR1cm5zIGFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLlxuXHQgKi9cblx0b248VCBleHRlbmRzIGtleW9mIFF1ZXVlRXZlbnRUeXBlcz4oZXZlbnQ6IFQsIGNhbGxiYWNrOiBRdWV1ZUV2ZW50Q2FsbGJhY2s8VD4pOiAoKSA9PiB2b2lkIHtcblx0XHRpZiAoIXRoaXMubGlzdGVuZXJzLmhhcyhldmVudCkpIHtcblx0XHRcdHRoaXMubGlzdGVuZXJzLnNldChldmVudCwgbmV3IFNldCgpKTtcblx0XHR9XG5cdFx0dGhpcy5saXN0ZW5lcnMuZ2V0KGV2ZW50KT8uYWRkKGNhbGxiYWNrKTtcblx0XHQvLyBSZXR1cm4gYW4gdW5zdWJzY3JpYmUgZnVuY3Rpb24uXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHRoaXMubGlzdGVuZXJzLmdldChldmVudCk/LmRlbGV0ZShjYWxsYmFjayk7XG5cdFx0fTtcblx0fVxufVxuIiwgIi8vIHNyYy91dGlscy9GaWxlVHJhY2tlci50c1xuaW1wb3J0IHsgVEFic3RyYWN0RmlsZSwgVEZpbGUsIFZhdWx0IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgRXJyb3JIYW5kbGVyIH0gZnJvbSAnLi9FcnJvckhhbmRsZXInO1xuaW1wb3J0IHsgRG9jdW1lbnRNZXRhZGF0YSB9IGZyb20gJy4uL21vZGVscy9Eb2N1bWVudENodW5rJztcbmltcG9ydCB7IFN5bmNGaWxlTWFuYWdlciB9IGZyb20gJy4uL3NlcnZpY2VzL1N5bmNGaWxlTWFuYWdlcic7XG5pbXBvcnQgeyBTdXBhYmFzZVNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9TdXBhYmFzZVNlcnZpY2UnO1xuLy8gT3B0aW9uYWw6IEltcG9ydCBPZmZsaW5lUXVldWVNYW5hZ2VyIGlmIGF2YWlsYWJsZVxuaW1wb3J0IHsgT2ZmbGluZVF1ZXVlTWFuYWdlciB9IGZyb20gJy4uL3NlcnZpY2VzL09mZmxpbmVRdWV1ZU1hbmFnZXInO1xuXG5pbnRlcmZhY2UgRmlsZUV2ZW50IHtcblx0dHlwZTogJ2NyZWF0ZScgfCAnbW9kaWZ5JyB8ICdkZWxldGUnIHwgJ3JlbmFtZSc7XG5cdGZpbGU6IFRGaWxlO1xuXHRvbGRQYXRoPzogc3RyaW5nO1xuXHR0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEZpbGVUcmFja2VyIHtcblx0cHJpdmF0ZSBldmVudFF1ZXVlOiBGaWxlRXZlbnRbXSA9IFtdO1xuXHRwcml2YXRlIGlzUHJvY2Vzc2luZzogYm9vbGVhbiA9IGZhbHNlO1xuXHRwcml2YXRlIHByb2Nlc3NpbmdUaW1lb3V0OiBudW1iZXIgPSAxMDAwOyAvLyBEZWJvdW5jZSB0aW1lIGluIG1zXG5cdHByaXZhdGUgc3luY01hbmFnZXI6IFN5bmNGaWxlTWFuYWdlcjtcblx0cHJpdmF0ZSByZWFkb25seSBzeW5jRmlsZVBhdGg6IHN0cmluZztcblx0Ly8gT3B0aW9uYWwgb2ZmbGluZSBxdWV1ZSBtYW5hZ2VyIGZvciBvZmZsaW5lIG9wZXJhdGlvbnNcblx0cHJpdmF0ZSBvZmZsaW5lUXVldWVNYW5hZ2VyOiBPZmZsaW5lUXVldWVNYW5hZ2VyIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgbWF4RmlsZVNpemVCeXRlczogbnVtYmVyID0gMTAgKiAxMDI0ICogMTAyNDtcblxuXHQvKipcblx0ICogQHBhcmFtIHZhdWx0IFRoZSBPYnNpZGlhbiB2YXVsdCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIGVycm9ySGFuZGxlciBDZW50cmFsaXplZCBlcnJvciBoYW5kbGVyLlxuXHQgKiBAcGFyYW0gc3luY0ZpbGVQYXRoIFBhdGggdG8gdGhlIHN5bmMgZmlsZS5cblx0ICogQHBhcmFtIHN1cGFiYXNlU2VydmljZSBPcHRpb25hbCBTdXBhYmFzZSBzZXJ2aWNlIGluc3RhbmNlLlxuXHQgKiBAcGFyYW0gb2ZmbGluZVF1ZXVlTWFuYWdlciBPcHRpb25hbCBPZmZsaW5lUXVldWVNYW5hZ2VyIGZvciBvZmZsaW5lIG1vZGUuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihcblx0XHRwcml2YXRlIHZhdWx0OiBWYXVsdCxcblx0XHRwcml2YXRlIGVycm9ySGFuZGxlcjogRXJyb3JIYW5kbGVyLFxuXHRcdHN5bmNGaWxlUGF0aDogc3RyaW5nID0gJ19taW5kbWF0cml4c3luYy5tZCcsXG5cdFx0cHJpdmF0ZSBzdXBhYmFzZVNlcnZpY2U6IFN1cGFiYXNlU2VydmljZSB8IG51bGwgPSBudWxsLFxuXHRcdG9mZmxpbmVRdWV1ZU1hbmFnZXI/OiBPZmZsaW5lUXVldWVNYW5hZ2VyXG5cdCkge1xuXHRcdHRoaXMuc3luY0ZpbGVQYXRoID0gc3luY0ZpbGVQYXRoO1xuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN5bmMgbWFuYWdlciB1c2luZyB0aGUgcHJvdmlkZWQgc3luYyBmaWxlIHBhdGguXG5cdFx0dGhpcy5zeW5jTWFuYWdlciA9IG5ldyBTeW5jRmlsZU1hbmFnZXIodmF1bHQsIGVycm9ySGFuZGxlciwgc3luY0ZpbGVQYXRoKTtcblx0XHRpZiAob2ZmbGluZVF1ZXVlTWFuYWdlcikge1xuXHRcdFx0dGhpcy5vZmZsaW5lUXVldWVNYW5hZ2VyID0gb2ZmbGluZVF1ZXVlTWFuYWdlcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgZmlsZSB0cmFja2VyLlxuXHQgKiBJZiBhIFN1cGFiYXNlIHNlcnZpY2UgaXMgYXZhaWxhYmxlLCByZWNvbmNpbGUgdGhlIGRhdGFiYXNlIHdpdGggdGhlIGxvY2FsIHN5bmMgZmlsZS5cblx0ICovXG5cdGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnNvbGUubG9nKCdbRmlsZVRyYWNrZXIuaW5pdGlhbGl6ZV0gU3RhcnRpbmcgRmlsZVRyYWNrZXIgaW5pdGlhbGl6YXRpb24nKTtcblx0XHRcdGNvbnNvbGUubG9nKGBbRmlsZVRyYWNrZXIuaW5pdGlhbGl6ZV0gU3luYyBmaWxlIHBhdGg6ICR7dGhpcy5zeW5jRmlsZVBhdGh9YCk7XG5cdFx0XHQvLyBJbml0aWFsaXplIHN5bmMgbWFuYWdlciAoZmFsbGJhY2sgZm9yIG9mZmxpbmUgbW9kZSlcblx0XHRcdGF3YWl0IHRoaXMuc3luY01hbmFnZXIuaW5pdGlhbGl6ZSgpO1xuXHRcdFx0Ly8gSWYgU3VwYWJhc2Ugc2VydmljZSBpcyBhdmFpbGFibGUsIHJlY29uY2lsZSBEQiBzdGF0dXMgd2l0aCBsb2NhbCBmaWxlIHN0YXRlLlxuXHRcdFx0aWYgKHRoaXMuc3VwYWJhc2VTZXJ2aWNlKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMucmVjb25jaWxlRGF0YWJhc2VXaXRoU3luY0ZpbGUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdTdXBhYmFzZSBzZXJ2aWNlIG5vdCBhdmFpbGFibGUuIFVzaW5nIHN5bmMgZmlsZSBvbmx5IGZvciB0cmFja2luZy4nKTtcblx0XHRcdH1cblx0XHRcdGNvbnNvbGUubG9nKCdGaWxlVHJhY2tlciBpbml0aWFsaXplZC4nKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ0ZpbGVUcmFja2VyLmluaXRpYWxpemUnIH0pO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlY29uY2lsZSBkYXRhYmFzZSByZWNvcmRzIHdpdGggbG9jYWwgc3luYyBmaWxlIGVudHJpZXMuXG5cdCAqIEVuc3VyZXMgdGhhdCBlYWNoIGZpbGUgaW4gdGhlIHZhdWx0IGhhcyBhbiB1cC10by1kYXRlIHN0YXR1cyBpbiB0aGUgZGF0YWJhc2UuXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIHJlY29uY2lsZURhdGFiYXNlV2l0aFN5bmNGaWxlKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXRoaXMuc3VwYWJhc2VTZXJ2aWNlKSByZXR1cm47XG5cdFx0XHQvLyBSZXRyaWV2ZSBhbGwgc3luYyBlbnRyaWVzIGZyb20gdGhlIGxvY2FsIHN5bmMgZmlsZVxuXHRcdFx0Y29uc3Qgc3luY0VudHJpZXMgPSBhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLmdldEFsbFN5bmNFbnRyaWVzKCk7XG5cdFx0XHRjb25zdCBlbnRyaWVzTWFwID0gbmV3IE1hcChzeW5jRW50cmllcy5tYXAoZW50cnkgPT4gW2VudHJ5LmZpbGVQYXRoLCBlbnRyeV0pKTtcblx0XHRcdC8vIEl0ZXJhdGUgb3ZlciBhbGwgZmlsZXMgaW4gdGhlIHZhdWx0XG5cdFx0XHRjb25zdCBmaWxlcyA9IHRoaXMudmF1bHQuZ2V0RmlsZXMoKTtcblx0XHRcdGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuXHRcdFx0XHQvLyBPbmx5IHByb2Nlc3MgbWFya2Rvd24gZmlsZXMgdGhhdCBhcmUgbm90IGV4Y2x1ZGVkXG5cdFx0XHRcdGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkgfHwgIXRoaXMuc2hvdWxkVHJhY2tGaWxlKGZpbGUucGF0aCkpIGNvbnRpbnVlO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIEdldCBmaWxlIHN0YXR1cyBmcm9tIHRoZSBkYXRhYmFzZVxuXHRcdFx0XHRcdGNvbnN0IGRiU3RhdHVzID0gYXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UuZ2V0RmlsZVZlY3Rvcml6YXRpb25TdGF0dXMoZmlsZS5wYXRoKTtcblx0XHRcdFx0XHRjb25zdCBjdXJyZW50SGFzaCA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlRmlsZUhhc2goZmlsZSk7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGZpbGUgaXMgbWFya2VkIGFzIHZlY3Rvcml6ZWQgYnV0IHRoZSBmaWxlIGhhcyBjaGFuZ2VkLCB1cGRhdGUgc3RhdHVzIHRvIFBFTkRJTkdcblx0XHRcdFx0XHRpZiAoZGJTdGF0dXMuaXNWZWN0b3JpemVkKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBmaWxlTW9kaWZpZWRTaW5jZURiID0gZmlsZS5zdGF0Lm10aW1lID4gKGRiU3RhdHVzLmxhc3RNb2RpZmllZCB8fCAwKTtcblx0XHRcdFx0XHRcdGlmIChmaWxlTW9kaWZpZWRTaW5jZURiKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5jcmVhdGVGaWxlTWV0YWRhdGEoZmlsZSk7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLnVwZGF0ZUZpbGVWZWN0b3JpemF0aW9uU3RhdHVzKG1ldGFkYXRhKTtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coYERhdGFiYXNlIHJlY29yZCB1cGRhdGVkIHRvIFBFTkRJTkcgZm9yIG1vZGlmaWVkIGZpbGU6ICR7ZmlsZS5wYXRofWApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBObyB2YWxpZCByZWNvcmQgb3Igbm90IHZlY3Rvcml6ZWQgeWV0XHUyMDE0Y3JlYXRlIG9yIHVwZGF0ZSBpdCBpbiB0aGUgZGF0YWJhc2Vcblx0XHRcdFx0XHRcdGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5jcmVhdGVGaWxlTWV0YWRhdGEoZmlsZSk7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS51cGRhdGVGaWxlVmVjdG9yaXphdGlvblN0YXR1cyhtZXRhZGF0YSk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhgRGF0YWJhc2UgcmVjb3JkIGNyZWF0ZWQvdXBkYXRlZCBmb3IgZmlsZTogJHtmaWxlLnBhdGh9YCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7XG5cdFx0XHRcdFx0XHRjb250ZXh0OiAnRmlsZVRyYWNrZXIucmVjb25jaWxlRGF0YWJhc2VXaXRoU3luY0ZpbGUnLFxuXHRcdFx0XHRcdFx0bWV0YWRhdGE6IHsgZmlsZVBhdGg6IGZpbGUucGF0aCB9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIEZvciBmaWxlcyB0aGF0IGV4aXN0IGluIHRoZSBzeW5jIGZpbGUgYnV0IGFyZSBkZWxldGVkIGZyb20gdGhlIHZhdWx0LFxuXHRcdFx0Ly8gbWFyayB0aGVtIGFzIGRlbGV0ZWQgaW4gdGhlIGRhdGFiYXNlLlxuXHRcdFx0Zm9yIChjb25zdCBlbnRyeSBvZiBzeW5jRW50cmllcykge1xuXHRcdFx0XHRjb25zdCBmaWxlID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZW50cnkuZmlsZVBhdGgpO1xuXHRcdFx0XHRpZiAoIWZpbGUgJiYgZW50cnkuc3RhdHVzICE9PSAnRVJST1InICYmIHRoaXMuc3VwYWJhc2VTZXJ2aWNlKSB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UudXBkYXRlRmlsZVN0YXR1c09uRGVsZXRlKGVudHJ5LmZpbGVQYXRoKTtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhgRGF0YWJhc2UgcmVjb3JkIG1hcmtlZCBhcyBkZWxldGVkIGZvciBmaWxlOiAke2VudHJ5LmZpbGVQYXRofWApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlY29uY2lsaW5nIGRhdGFiYXNlIHdpdGggc3luYyBmaWxlOicsIGVycm9yKTtcblx0XHRcdC8vIE5vbi1jcml0aWNhbDsgZG8gbm90IHRocm93LlxuXHRcdH1cblx0fVxuXG5cdGFzeW5jIGhhbmRsZUNyZWF0ZShmaWxlOiBUQWJzdHJhY3RGaWxlKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB8fCAhdGhpcy5zaG91bGRUcmFja0ZpbGUoZmlsZS5wYXRoKSkgcmV0dXJuO1xuXHRcdGNvbnN0IGV2ZW50OiBGaWxlRXZlbnQgPSB7IHR5cGU6ICdjcmVhdGUnLCBmaWxlLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfTtcblx0XHRhd2FpdCB0aGlzLnF1ZXVlRXZlbnQoZXZlbnQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZSBmaWxlIG1vZGlmaWNhdGlvbiBldmVudHMuXG5cdCAqIEVuaGFuY2VkIHdpdGggY2hhbmdlIGRldGVjdGlvbiBhbmQgaW50ZWxsaWdlbnQgZGVib3VuY2luZy5cblx0ICovXG5cdGFzeW5jIGhhbmRsZU1vZGlmeShmaWxlOiBUQWJzdHJhY3RGaWxlKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB8fCAhdGhpcy5zaG91bGRUcmFja0ZpbGUoZmlsZSkpIHJldHVybjtcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBDaGVjayBpZiB0aGlzIGZpbGUgd2FzIHJlY2VudGx5IG1vZGlmaWVkXG5cdFx0XHRjb25zdCByZWNlbnRDaGFuZ2UgPSB0aGlzLnJlY2VudENoYW5nZXMuZ2V0KGZpbGUucGF0aCk7XG5cdFx0XHRjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBoYXNoIGZvciBjaGFuZ2UgZGV0ZWN0aW9uXG5cdFx0XHRjb25zdCBoYXNoID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVGaWxlSGFzaChmaWxlKTtcblxuXHRcdFx0Ly8gSWYgdGhlIGZpbGUgd2FzIHJlY2VudGx5IHByb2Nlc3NlZCBhbmQgY29udGVudCBoYXNuJ3QgY2hhbmdlZCwgZGVib3VuY2UgbW9yZSBhZ2dyZXNzaXZlbHlcblx0XHRcdGlmIChyZWNlbnRDaGFuZ2UgJiZcblx0XHRcdFx0cmVjZW50Q2hhbmdlLmhhc2ggPT09IGhhc2ggJiZcblx0XHRcdFx0KGN1cnJlbnRUaW1lIC0gcmVjZW50Q2hhbmdlLmxhc3RQcm9jZXNzZWQpIDwgKHRoaXMucHJvY2Vzc2luZ1RpbWVvdXQgKiAyKSkge1xuXG5cdFx0XHRcdGNvbnNvbGUubG9nKGBTa2lwcGluZyByZWR1bmRhbnQgdXBkYXRlIGZvciAke2ZpbGUucGF0aH0gLSBjb250ZW50IHVuY2hhbmdlZGApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGZpbGUgd2FzIHJlY2VudGx5IHByb2Nlc3NlZCBidXQgY29udGVudCBoYXMgY2hhbmdlZCwgd2UnbGwgcXVldWUgaXRcblx0XHRcdGlmIChyZWNlbnRDaGFuZ2UpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coYENvbnRlbnQgY2hhbmdlZCBmb3IgJHtmaWxlLnBhdGh9LiBQcmV2aW91cyBoYXNoOiAke3JlY2VudENoYW5nZS5oYXNoLnN1YnN0cmluZygwLCA4KX0uLi4sIE5ldyBoYXNoOiAke2hhc2guc3Vic3RyaW5nKDAsIDgpfS4uLmApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgdGhlIHJlY2VudCBjaGFuZ2VzIHJlY29yZFxuXHRcdFx0dGhpcy5yZWNlbnRDaGFuZ2VzLnNldChmaWxlLnBhdGgsIHtcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiBmaWxlLnN0YXQubXRpbWUsXG5cdFx0XHRcdGhhc2gsXG5cdFx0XHRcdGxhc3RQcm9jZXNzZWQ6IGN1cnJlbnRUaW1lXG5cdFx0XHR9KTtcblxuXHRcdFx0Y29uc3QgZXZlbnQ6IEZpbGVFdmVudCA9IHtcblx0XHRcdFx0dHlwZTogJ21vZGlmeScsXG5cdFx0XHRcdGZpbGUsXG5cdFx0XHRcdHRpbWVzdGFtcDogY3VycmVudFRpbWUsXG5cdFx0XHRcdGhhc2hcblx0XHRcdH07XG5cblx0XHRcdGF3YWl0IHRoaXMucXVldWVFdmVudChldmVudCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7XG5cdFx0XHRcdGNvbnRleHQ6ICdGaWxlVHJhY2tlci5oYW5kbGVNb2RpZnknLFxuXHRcdFx0XHRtZXRhZGF0YTogeyBmaWxlUGF0aDogZmlsZS5wYXRoIH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIGhhbmRsZURlbGV0ZShmaWxlOiBUQWJzdHJhY3RGaWxlKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB8fCAhdGhpcy5zaG91bGRUcmFja0ZpbGUoZmlsZS5wYXRoKSkgcmV0dXJuO1xuXHRcdGNvbnN0IGV2ZW50OiBGaWxlRXZlbnQgPSB7IHR5cGU6ICdkZWxldGUnLCBmaWxlLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfTtcblx0XHRhd2FpdCB0aGlzLnF1ZXVlRXZlbnQoZXZlbnQpO1xuXG5cdFx0Ly8gSWYgb2ZmbGluZSBxdWV1ZSBtYW5hZ2VyIGlzIGVuYWJsZWQsIHF1ZXVlIHRoZSBkZWxldGlvbiBvcGVyYXRpb24uXG5cdFx0aWYgKHRoaXMub2ZmbGluZVF1ZXVlTWFuYWdlcikge1xuXHRcdFx0YXdhaXQgdGhpcy5vZmZsaW5lUXVldWVNYW5hZ2VyLnF1ZXVlT3BlcmF0aW9uKHtcblx0XHRcdFx0b3BlcmF0aW9uVHlwZTogJ2RlbGV0ZScsXG5cdFx0XHRcdGZpbGVJZDogZmlsZS5wYXRoLFxuXHRcdFx0XHR0aW1lc3RhbXA6IERhdGUubm93KClcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5zdXBhYmFzZVNlcnZpY2UpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLnVwZGF0ZUZpbGVTdGF0dXNPbkRlbGV0ZShmaWxlLnBhdGgpO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgZGF0YWJhc2UgZm9yIGRlbGV0ZWQgZmlsZTonLCBlcnJvcik7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEZhbGxiYWNrIHRvIHVwZGF0aW5nIHRoZSBzeW5jIGZpbGVcblx0XHRcdGF3YWl0IHRoaXMuc3luY01hbmFnZXIudXBkYXRlU3luY1N0YXR1cyhmaWxlLnBhdGgsICdPSycsIHtcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiBEYXRlLm5vdygpLFxuXHRcdFx0XHRoYXNoOiAnJ1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgaGFuZGxlUmVuYW1lKGZpbGU6IFRBYnN0cmFjdEZpbGUsIG9sZFBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkgfHwgIXRoaXMuc2hvdWxkVHJhY2tGaWxlKGZpbGUucGF0aCkpIHJldHVybjtcblx0XHRjb25zdCBldmVudDogRmlsZUV2ZW50ID0geyB0eXBlOiAncmVuYW1lJywgZmlsZSwgb2xkUGF0aCwgdGltZXN0YW1wOiBEYXRlLm5vdygpIH07XG5cdFx0YXdhaXQgdGhpcy5xdWV1ZUV2ZW50KGV2ZW50KTtcblx0XHRjb25zdCBuZXdIYXNoID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVGaWxlSGFzaChmaWxlKTtcblx0XHRjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuY3JlYXRlRmlsZU1ldGFkYXRhKGZpbGUpO1xuXG5cdFx0Ly8gSWYgb2ZmbGluZSwgcXVldWUgcmVuYW1lIG9wZXJhdGlvblxuXHRcdGlmICh0aGlzLm9mZmxpbmVRdWV1ZU1hbmFnZXIpIHtcblx0XHRcdGF3YWl0IHRoaXMub2ZmbGluZVF1ZXVlTWFuYWdlci5xdWV1ZU9wZXJhdGlvbih7XG5cdFx0XHRcdG9wZXJhdGlvblR5cGU6ICdyZW5hbWUnLFxuXHRcdFx0XHRmaWxlSWQ6IGZpbGUucGF0aCxcblx0XHRcdFx0bWV0YWRhdGE6IHsgb2xkUGF0aCB9LFxuXHRcdFx0XHR0aW1lc3RhbXA6IERhdGUubm93KClcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5zdXBhYmFzZVNlcnZpY2UpIHtcblx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLnVwZGF0ZUZpbGVWZWN0b3JpemF0aW9uU3RhdHVzKG1ldGFkYXRhKTtcblx0XHRcdGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLnVwZGF0ZUZpbGVTdGF0dXNPbkRlbGV0ZShvbGRQYXRoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXdhaXQgdGhpcy5zeW5jTWFuYWdlci51cGRhdGVTeW5jU3RhdHVzKGZpbGUucGF0aCwgJ1BFTkRJTkcnLCB7XG5cdFx0XHRcdGxhc3RNb2RpZmllZDogZmlsZS5zdGF0Lm10aW1lLFxuXHRcdFx0XHRoYXNoOiBuZXdIYXNoXG5cdFx0XHR9KTtcblx0XHRcdGF3YWl0IHRoaXMuc3luY01hbmFnZXIudXBkYXRlU3luY1N0YXR1cyhvbGRQYXRoLCAnT0snLCB7XG5cdFx0XHRcdGxhc3RNb2RpZmllZDogRGF0ZS5ub3coKSxcblx0XHRcdFx0aGFzaDogJydcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBRdWV1ZSBhbiBldmVudCBmb3IgcHJvY2Vzc2luZyB3aXRoIGludGVsbGlnZW50IGRlYm91bmNpbmcuXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIHF1ZXVlRXZlbnQoZXZlbnQ6IEZpbGVFdmVudCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdC8vIEFkZCB0aGUgZXZlbnQgdG8gdGhlIHF1ZXVlXG5cdFx0dGhpcy5ldmVudFF1ZXVlLnB1c2goZXZlbnQpO1xuXG5cdFx0Ly8gSWYgbm90IGFscmVhZHkgcHJvY2Vzc2luZywgc3RhcnQgYSB0aW1lciBiYXNlZCBvbiBldmVudCB0eXBlXG5cdFx0aWYgKCF0aGlzLmlzUHJvY2Vzc2luZykge1xuXHRcdFx0Ly8gVXNlIHN0YW5kYXJkIGRlYm91bmNlIHRpbWUgZm9yIG1vc3QgZXZlbnRzXG5cdFx0XHRsZXQgZGVib3VuY2VUaW1lID0gdGhpcy5wcm9jZXNzaW5nVGltZW91dDtcblxuXHRcdFx0Ly8gRm9yIGRlbGV0ZSBhbmQgcmVuYW1lIGV2ZW50cywgdXNlIGEgc2hvcnRlciBkZWJvdW5jZSB0aW1lXG5cdFx0XHRpZiAoZXZlbnQudHlwZSA9PT0gJ2RlbGV0ZScgfHwgZXZlbnQudHlwZSA9PT0gJ3JlbmFtZScpIHtcblx0XHRcdFx0ZGVib3VuY2VUaW1lID0gTWF0aC5taW4oZGVib3VuY2VUaW1lIC8gMiwgNTAwKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIHJhcGlkIHR5cGluZyBzY2VuYXJpb3MsIHVzZSBhIGxvbmdlciBkZWJvdW5jZSB0aW1lXG5cdFx0XHRpZiAoZXZlbnQudHlwZSA9PT0gJ21vZGlmeScpIHtcblx0XHRcdFx0Y29uc3QgcmVjZW50RXZlbnRzID0gdGhpcy5ldmVudFF1ZXVlLmZpbHRlcihlID0+XG5cdFx0XHRcdFx0ZS5maWxlLnBhdGggPT09IGV2ZW50LmZpbGUucGF0aCAmJlxuXHRcdFx0XHRcdGUudHlwZSA9PT0gJ21vZGlmeScgJiZcblx0XHRcdFx0XHQoZXZlbnQudGltZXN0YW1wIC0gZS50aW1lc3RhbXApIDwgNTAwMFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmIChyZWNlbnRFdmVudHMubGVuZ3RoID4gMykge1xuXHRcdFx0XHRcdC8vIE11bHRpcGxlIHJhcGlkIGNoYW5nZXMgZGV0ZWN0ZWQsIGluY3JlYXNlIGRlYm91bmNlIHRpbWVcblx0XHRcdFx0XHRkZWJvdW5jZVRpbWUgPSBNYXRoLm1heChkZWJvdW5jZVRpbWUgKiAyLCAzMDAwKTtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhgSW5jcmVhc2VkIGRlYm91bmNlIHRpbWUgdG8gJHtkZWJvdW5jZVRpbWV9bXMgZm9yIHJhcGlkIGNoYW5nZXMgdG8gJHtldmVudC5maWxlLnBhdGh9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB0aGlzLnByb2Nlc3NFdmVudFF1ZXVlKCksIGRlYm91bmNlVGltZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgdGhlIGV2ZW50IHF1ZXVlIHdpdGggaW1wcm92ZWQgY29uZmxpY3QgaGFuZGxpbmcuXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIHByb2Nlc3NFdmVudFF1ZXVlKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICh0aGlzLmlzUHJvY2Vzc2luZyB8fCB0aGlzLmV2ZW50UXVldWUubGVuZ3RoID09PSAwKSByZXR1cm47XG5cblx0XHR0aGlzLmlzUHJvY2Vzc2luZyA9IHRydWU7XG5cdFx0Y29uc29sZS5sb2coYFByb2Nlc3NpbmcgJHt0aGlzLmV2ZW50UXVldWUubGVuZ3RofSBxdWV1ZWQgZXZlbnRzYCk7XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gR3JvdXAgZXZlbnRzIGJ5IGZpbGUgcGF0aCBmb3IgaW50ZWxsaWdlbnQgcHJvY2Vzc2luZ1xuXHRcdFx0Y29uc3QgZXZlbnRzQnlQYXRoID0gbmV3IE1hcDxzdHJpbmcsIEZpbGVFdmVudFtdPigpO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGV2ZW50IG9mIHRoaXMuZXZlbnRRdWV1ZSkge1xuXHRcdFx0XHRjb25zdCBwYXRoID0gZXZlbnQuZmlsZS5wYXRoO1xuXHRcdFx0XHRpZiAoIWV2ZW50c0J5UGF0aC5oYXMocGF0aCkpIHtcblx0XHRcdFx0XHRldmVudHNCeVBhdGguc2V0KHBhdGgsIFtdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRldmVudHNCeVBhdGguZ2V0KHBhdGgpPy5wdXNoKGV2ZW50KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHJvY2VzcyBldmVudHMgZm9yIGVhY2ggZmlsZSB3aXRoIHByb3BlciBwcmlvcml0aXphdGlvblxuXHRcdFx0Y29uc3QgcGF0aHMgPSBBcnJheS5mcm9tKGV2ZW50c0J5UGF0aC5rZXlzKCkpO1xuXG5cdFx0XHQvLyBQcm9jZXNzIGRlbGV0ZSBvcGVyYXRpb25zIGZpcnN0XG5cdFx0XHRjb25zdCBkZWxldGVGaXJzdCA9IHBhdGhzLnNvcnQoKGEsIGIpID0+IHtcblx0XHRcdFx0Y29uc3QgYUhhc0RlbGV0ZSA9IGV2ZW50c0J5UGF0aC5nZXQoYSk/LnNvbWUoZSA9PiBlLnR5cGUgPT09ICdkZWxldGUnKSA/PyBmYWxzZTtcblx0XHRcdFx0Y29uc3QgYkhhc0RlbGV0ZSA9IGV2ZW50c0J5UGF0aC5nZXQoYik/LnNvbWUoZSA9PiBlLnR5cGUgPT09ICdkZWxldGUnKSA/PyBmYWxzZTtcblxuXHRcdFx0XHRpZiAoYUhhc0RlbGV0ZSAmJiAhYkhhc0RlbGV0ZSkgcmV0dXJuIC0xO1xuXHRcdFx0XHRpZiAoIWFIYXNEZWxldGUgJiYgYkhhc0RlbGV0ZSkgcmV0dXJuIDE7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fSk7XG5cblx0XHRcdGZvciAoY29uc3QgcGF0aCBvZiBkZWxldGVGaXJzdCkge1xuXHRcdFx0XHRjb25zdCBldmVudHMgPSBldmVudHNCeVBhdGguZ2V0KHBhdGgpO1xuXHRcdFx0XHRpZiAoZXZlbnRzKSB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wcm9jZXNzRmlsZUV2ZW50cyhwYXRoLCBldmVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHRoZSBldmVudCBxdWV1ZVxuXHRcdFx0dGhpcy5ldmVudFF1ZXVlID0gW107XG5cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ0ZpbGVUcmFja2VyLnByb2Nlc3NFdmVudFF1ZXVlJyB9KTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dGhpcy5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gSWYgZXZlbnRzIHdlcmUgYWRkZWQgZHVyaW5nIHByb2Nlc3NpbmcsIHRyaWdnZXIgYW5vdGhlciBwcm9jZXNzIGN5Y2xlXG5cdFx0XHRpZiAodGhpcy5ldmVudFF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB0aGlzLnByb2Nlc3NFdmVudFF1ZXVlKCksIDEwMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgYWxsIGV2ZW50cyBmb3IgYSBzaW5nbGUgZmlsZSB3aXRoIGltcHJvdmVkIGNoYW5nZSBkZXRlY3Rpb24uXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIHByb2Nlc3NGaWxlRXZlbnRzKHBhdGg6IHN0cmluZywgZXZlbnRzOiBGaWxlRXZlbnRbXSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdC8vIFNvcnQgZXZlbnRzIGJ5IHRpbWVzdGFtcCB0byBlbnN1cmUgY29ycmVjdCBvcmRlclxuXHRcdGV2ZW50cy5zb3J0KChhLCBiKSA9PiBhLnRpbWVzdGFtcCAtIGIudGltZXN0YW1wKTtcblxuXHRcdC8vIEdldCB0aGUgZmluYWwgZXZlbnQgYWZ0ZXIgYWxsIGNoYW5nZXNcblx0XHRjb25zdCBmaW5hbEV2ZW50ID0gZXZlbnRzW2V2ZW50cy5sZW5ndGggLSAxXTtcblxuXHRcdGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nICR7ZXZlbnRzLmxlbmd0aH0gZXZlbnRzIGZvciAke3BhdGh9LCBmaW5hbCBldmVudDogJHtmaW5hbEV2ZW50LnR5cGV9YCk7XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gRGVsZXRlIGV2ZW50cyBhcmUgaGFuZGxlZCBpbW1lZGlhdGVseSBpbiBoYW5kbGVEZWxldGUsIG5vIGZ1cnRoZXIgcHJvY2Vzc2luZyBuZWVkZWRcblx0XHRcdGlmIChmaW5hbEV2ZW50LnR5cGUgPT09ICdkZWxldGUnKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGBTa2lwcGluZyBmdXJ0aGVyIHByb2Nlc3NpbmcgZm9yIGRlbGV0ZWQgZmlsZTogJHtwYXRofWApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEdldCB0aGUgaGFzaCBlaXRoZXIgZnJvbSB0aGUgZXZlbnQgb3IgY2FsY3VsYXRlIGl0XG5cdFx0XHRjb25zdCBuZXdIYXNoID0gZmluYWxFdmVudC5oYXNoIHx8IGF3YWl0IHRoaXMuY2FsY3VsYXRlRmlsZUhhc2goZmluYWxFdmVudC5maWxlKTtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHRoZSBmaWxlIG5lZWRzIHZlY3Rvcml6aW5nIGJhc2VkIG9uIGF2YWlsYWJsZSBzZXJ2aWNlc1xuXHRcdFx0bGV0IG5lZWRzVmVjdG9yaXppbmcgPSB0cnVlO1xuXG5cdFx0XHRpZiAodGhpcy5zdXBhYmFzZVNlcnZpY2UpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRuZWVkc1ZlY3Rvcml6aW5nID0gYXdhaXQgdGhpcy5zdXBhYmFzZVNlcnZpY2UubmVlZHNWZWN0b3JpemluZyhcblx0XHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0XHRmaW5hbEV2ZW50LmZpbGUuc3RhdC5tdGltZSxcblx0XHRcdFx0XHRcdG5ld0hhc2hcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0aWYgKCFuZWVkc1ZlY3Rvcml6aW5nKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhgRmlsZSAke3BhdGh9IGRvZXMgbm90IG5lZWQgdmVjdG9yaXppbmcgLSBubyBzaWduaWZpY2FudCBjaGFuZ2VzYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGlmIGZpbGUgbmVlZHMgdmVjdG9yaXppbmc6JywgZXJyb3IpO1xuXHRcdFx0XHRcdG5lZWRzVmVjdG9yaXppbmcgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBGYWxsYmFjayB0byBzeW5jIGZpbGUgc3RhdHVzIGNoZWNrXG5cdFx0XHRcdGNvbnN0IHN5bmNTdGF0dXMgPSBhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLmdldFN5bmNTdGF0dXMocGF0aCk7XG5cblx0XHRcdFx0aWYgKHN5bmNTdGF0dXMgJiZcblx0XHRcdFx0XHRzeW5jU3RhdHVzLmhhc2ggPT09IG5ld0hhc2ggJiZcblx0XHRcdFx0XHRmaW5hbEV2ZW50LmZpbGUuc3RhdC5tdGltZSA8PSBzeW5jU3RhdHVzLmxhc3RNb2RpZmllZCAmJlxuXHRcdFx0XHRcdHN5bmNTdGF0dXMuc3RhdHVzICE9PSAnUEVORElORycpIHtcblxuXHRcdFx0XHRcdG5lZWRzVmVjdG9yaXppbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhgRmlsZSAke3BhdGh9IGRvZXMgbm90IG5lZWQgdmVjdG9yaXppbmcgYWNjb3JkaW5nIHRvIHN5bmMgZmlsZSBzdGF0dXNgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgdHJhY2tpbmcgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHZlY3Rvcml6YXRpb24gaXMgbmVlZGVkXG5cdFx0XHR0aGlzLnJlY2VudENoYW5nZXMuc2V0KHBhdGgsIHtcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiBmaW5hbEV2ZW50LmZpbGUuc3RhdC5tdGltZSxcblx0XHRcdFx0aGFzaDogbmV3SGFzaCxcblx0XHRcdFx0bGFzdFByb2Nlc3NlZDogRGF0ZS5ub3coKVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIE9ubHkgcHJvY2VlZCB3aXRoIHZlY3Rvcml6YXRpb24gaWYgbmVlZGVkXG5cdFx0XHRpZiAobmVlZHNWZWN0b3JpemluZykge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhgVXBkYXRpbmcgc3RhdHVzIGZvciAke3BhdGh9IHdpdGggaGFzaCAke25ld0hhc2guc3Vic3RyaW5nKDAsIDgpfS4uLmApO1xuXG5cdFx0XHRcdC8vIENyZWF0ZSBtZXRhZGF0YSB3aXRoIGNvbnRlbnQgaGFzaCBmb3IgcmVsaWFibGUgY2hhbmdlIGRldGVjdGlvblxuXHRcdFx0XHRjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuY3JlYXRlRmlsZU1ldGFkYXRhKGZpbmFsRXZlbnQuZmlsZSk7XG5cdFx0XHRcdG1ldGFkYXRhLmN1c3RvbU1ldGFkYXRhLmNvbnRlbnRIYXNoID0gbmV3SGFzaDtcblxuXHRcdFx0XHRpZiAodGhpcy5zdXBhYmFzZVNlcnZpY2UpIHtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS51cGRhdGVGaWxlVmVjdG9yaXphdGlvblN0YXR1cyhtZXRhZGF0YSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5zeW5jTWFuYWdlci51cGRhdGVTeW5jU3RhdHVzKHBhdGgsICdQRU5ESU5HJywge1xuXHRcdFx0XHRcdFx0bGFzdE1vZGlmaWVkOiBmaW5hbEV2ZW50LmZpbGUuc3RhdC5tdGltZSxcblx0XHRcdFx0XHRcdGhhc2g6IG5ld0hhc2hcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0XHRjb250ZXh0OiAnRmlsZVRyYWNrZXIucHJvY2Vzc0ZpbGVFdmVudHMnLFxuXHRcdFx0XHRtZXRhZGF0YTogeyBwYXRoLCBldmVudFR5cGU6IGZpbmFsRXZlbnQudHlwZSB9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGNhbGN1bGF0ZUZpbGVIYXNoKGZpbGU6IFRGaWxlKTogUHJvbWlzZTxzdHJpbmc+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHQucmVhZChmaWxlKTtcblx0XHRcdHJldHVybiBhd2FpdCB0aGlzLmhhc2hTdHJpbmcoY29udGVudCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdGaWxlVHJhY2tlci5jYWxjdWxhdGVGaWxlSGFzaCcsIG1ldGFkYXRhOiB7IGZpbGVQYXRoOiBmaWxlLnBhdGggfSB9KTtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGhhc2hTdHJpbmcoc3RyOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuXHRcdGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblx0XHRjb25zdCBkYXRhID0gZW5jb2Rlci5lbmNvZGUoc3RyKTtcblx0XHRjb25zdCBidWZmZXIgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGRhdGEpO1xuXHRcdHJldHVybiBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpXG5cdFx0XHQubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSlcblx0XHRcdC5qb2luKCcnKTtcblx0fVxuXG5cdHB1YmxpYyBhc3luYyBjcmVhdGVGaWxlTWV0YWRhdGEoZmlsZTogVEZpbGUpOiBQcm9taXNlPERvY3VtZW50TWV0YWRhdGE+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHQucmVhZChmaWxlKTtcblx0XHRcdGNvbnN0IGxpbmVDb3VudCA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpLmxlbmd0aDtcblx0XHRcdGxldCBhZGRpdGlvbmFsTWV0YWRhdGEgPSB7fTtcblx0XHRcdGlmICh0aGlzLnN1cGFiYXNlU2VydmljZSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNvbnN0IHN0YXR1cyA9IGF3YWl0IHRoaXMuc3VwYWJhc2VTZXJ2aWNlLmdldEZpbGVWZWN0b3JpemF0aW9uU3RhdHVzKGZpbGUucGF0aCk7XG5cdFx0XHRcdFx0aWYgKHN0YXR1cy5pc1ZlY3Rvcml6ZWQpIHtcblx0XHRcdFx0XHRcdGFkZGl0aW9uYWxNZXRhZGF0YSA9IHtcblx0XHRcdFx0XHRcdFx0bGFzdFZlY3Rvcml6ZWQ6IHN0YXR1cy5sYXN0VmVjdG9yaXplZCxcblx0XHRcdFx0XHRcdFx0Y29udGVudEhhc2g6IHN0YXR1cy5jb250ZW50SGFzaFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBmaWxlIHN0YXR1cyBmcm9tIGRhdGFiYXNlOicsIGVycm9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0b2JzaWRpYW5JZDogZmlsZS5wYXRoLFxuXHRcdFx0XHRwYXRoOiBmaWxlLnBhdGgsXG5cdFx0XHRcdGxhc3RNb2RpZmllZDogZmlsZS5zdGF0Lm10aW1lLFxuXHRcdFx0XHRjcmVhdGVkOiBmaWxlLnN0YXQuY3RpbWUsXG5cdFx0XHRcdHNpemU6IGZpbGUuc3RhdC5zaXplLFxuXHRcdFx0XHRjdXN0b21NZXRhZGF0YTogeyAuLi5hZGRpdGlvbmFsTWV0YWRhdGEgfSxcblx0XHRcdFx0bG9jOiB7IGxpbmVzOiB7IGZyb206IDEsIHRvOiBsaW5lQ291bnQgfSB9LFxuXHRcdFx0XHRzb3VyY2U6IFwib2JzaWRpYW5cIixcblx0XHRcdFx0ZmlsZV9pZDogZmlsZS5wYXRoLFxuXHRcdFx0XHRibG9iVHlwZTogXCJ0ZXh0L21hcmtkb3duXCJcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdGaWxlVHJhY2tlci5jcmVhdGVGaWxlTWV0YWRhdGEnLCBtZXRhZGF0YTogeyBmaWxlUGF0aDogZmlsZS5wYXRoIH0gfSk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRvYnNpZGlhbklkOiBmaWxlLnBhdGgsXG5cdFx0XHRcdHBhdGg6IGZpbGUucGF0aCxcblx0XHRcdFx0bGFzdE1vZGlmaWVkOiBmaWxlLnN0YXQubXRpbWUsXG5cdFx0XHRcdGNyZWF0ZWQ6IGZpbGUuc3RhdC5jdGltZSxcblx0XHRcdFx0c2l6ZTogZmlsZS5zdGF0LnNpemUsXG5cdFx0XHRcdGN1c3RvbU1ldGFkYXRhOiB7fVxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYSBmaWxlIHNob3VsZCBiZSB0cmFja2VkIGFuZCBwcm9jZXNzZWQuXG5cdCAqIEVuaGFuY2VkIHdpdGggYWRkaXRpb25hbCBleGNsdXNpb24gbG9naWMuXG5cdCAqL1xuXHRwcml2YXRlIHNob3VsZFRyYWNrRmlsZShmaWxlOiBURmlsZSk6IGJvb2xlYW4ge1xuXHRcdGlmICghdGhpcy5zZXR0aW5ncyB8fCAhaXNWYXVsdEluaXRpYWxpemVkKHRoaXMuc2V0dGluZ3MpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLmVuYWJsZUF1dG9TeW5jKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGNvbWJpbmVkIGV4Y2x1c2lvbnMgKHN5c3RlbSArIHVzZXIpXG5cdFx0Y29uc3QgYWxsRXhjbHVzaW9ucyA9IGdldEFsbEV4Y2x1c2lvbnModGhpcy5zZXR0aW5ncyk7XG5cblx0XHRjb25zdCBmaWxlUGF0aCA9IGZpbGUucGF0aDtcblx0XHRjb25zdCBmaWxlTmFtZSA9IGZpbGUubmFtZTtcblxuXHRcdC8vIENoZWNrIGlmIHRoaXMgaXMgdGhlIHN5bmMgZmlsZSBkaXJlY3RseVxuXHRcdGlmIChmaWxlUGF0aCA9PT0gdGhpcy5zZXR0aW5ncy5zeW5jLnN5bmNGaWxlUGF0aCB8fFxuXHRcdFx0ZmlsZVBhdGggPT09IHRoaXMuc2V0dGluZ3Muc3luYy5zeW5jRmlsZVBhdGggKyAnLmJhY2t1cCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgZmlsZSBpcyBiaW5hcnkgb3Igbm9uLXRleHQgYmFzZWRcblx0XHRjb25zdCBpc0JpbmFyeUZpbGUgPSB0aGlzLmlzQmluYXJ5RmlsZShmaWxlTmFtZSk7XG5cdFx0aWYgKGlzQmluYXJ5RmlsZSkge1xuXHRcdFx0Y29uc29sZS5sb2coYFNraXBwaW5nIGJpbmFyeSBmaWxlOiAke2ZpbGVOYW1lfWApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZpbGUgc2l6ZSBjb25zdHJhaW50cyAtIHNraXAgZXh0cmVtZWx5IGxhcmdlIGZpbGVzXG5cdFx0aWYgKGZpbGUuc3RhdC5zaXplID4gdGhpcy5tYXhGaWxlU2l6ZUJ5dGVzKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhgU2tpcHBpbmcgZmlsZSBleGNlZWRpbmcgc2l6ZSBsaW1pdDogJHtmaWxlTmFtZX0gKCR7ZmlsZS5zdGF0LnNpemV9IGJ5dGVzKWApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGV4Y2x1ZGVkIGZpbGVzXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoYWxsRXhjbHVzaW9ucy5leGNsdWRlZEZpbGVzKSAmJlxuXHRcdFx0YWxsRXhjbHVzaW9ucy5leGNsdWRlZEZpbGVzLmluY2x1ZGVzKGZpbGVOYW1lKSkge1xuXHRcdFx0Y29uc29sZS5sb2coJ1NraXBwaW5nIGV4Y2x1ZGVkIGZpbGU6JywgZmlsZU5hbWUpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGV4Y2x1ZGVkIGZvbGRlcnNcblx0XHRpZiAoQXJyYXkuaXNBcnJheShhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRm9sZGVycykpIHtcblx0XHRcdGNvbnN0IGlzRXhjbHVkZWRGb2xkZXIgPSBhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRm9sZGVycy5zb21lKGZvbGRlciA9PiB7XG5cdFx0XHRcdGNvbnN0IG5vcm1hbGl6ZWRGb2xkZXIgPSBmb2xkZXIuZW5kc1dpdGgoJy8nKSA/IGZvbGRlciA6IGZvbGRlciArICcvJztcblx0XHRcdFx0cmV0dXJuIGZpbGVQYXRoLnN0YXJ0c1dpdGgobm9ybWFsaXplZEZvbGRlcik7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChpc0V4Y2x1ZGVkRm9sZGVyKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdTa2lwcGluZyBmaWxlIGluIGV4Y2x1ZGVkIGZvbGRlcjonLCBmaWxlUGF0aCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDaGVjayBleGNsdWRlZCBmaWxlIHR5cGVzXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoYWxsRXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcykpIHtcblx0XHRcdGNvbnN0IGlzRXhjbHVkZWRUeXBlID0gYWxsRXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcy5zb21lKFxuXHRcdFx0XHRleHQgPT4gZmlsZVBhdGgudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQudG9Mb3dlckNhc2UoKSlcblx0XHRcdCk7XG5cdFx0XHRpZiAoaXNFeGNsdWRlZFR5cGUpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ1NraXBwaW5nIGV4Y2x1ZGVkIGZpbGUgdHlwZTonLCBmaWxlUGF0aCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDaGVjayBleGNsdWRlZCBmaWxlIHByZWZpeGVzXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoYWxsRXhjbHVzaW9ucy5leGNsdWRlZEZpbGVQcmVmaXhlcykpIHtcblx0XHRcdGNvbnN0IGlzRXhjbHVkZWRQcmVmaXggPSBhbGxFeGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVByZWZpeGVzLnNvbWUoXG5cdFx0XHRcdHByZWZpeCA9PiBmaWxlTmFtZS5zdGFydHNXaXRoKHByZWZpeClcblx0XHRcdCk7XG5cdFx0XHRpZiAoaXNFeGNsdWRlZFByZWZpeCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnU2tpcHBpbmcgZmlsZSB3aXRoIGV4Y2x1ZGVkIHByZWZpeDonLCBmaWxlTmFtZSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFJldHJpZXZlIHN5bmMgc3RhdHVzIGZvciBhIGdpdmVuIGZpbGUgZnJvbSB0aGUgc3luYyBmaWxlLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGdldFN5bmNTdGF0dXMocGF0aDogc3RyaW5nKSB7XG5cdFx0cmV0dXJuIGF3YWl0IHRoaXMuc3luY01hbmFnZXIuZ2V0U3luY1N0YXR1cyhwYXRoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZSBhbGwgc3luYyBzdGF0dXNlcy5cblx0ICovXG5cdHB1YmxpYyBhc3luYyBnZXRBbGxTeW5jU3RhdHVzZXMoKSB7XG5cdFx0cmV0dXJuIGF3YWl0IHRoaXMuc3luY01hbmFnZXIuZ2V0QWxsU3luY0VudHJpZXMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBbGxvd3MgbGF0ZSBiaW5kaW5nIG9mIHRoZSBTdXBhYmFzZSBzZXJ2aWNlLlxuXHQgKi9cblx0cHVibGljIHNldFN1cGFiYXNlU2VydmljZShzZXJ2aWNlOiBTdXBhYmFzZVNlcnZpY2UpOiB2b2lkIHtcblx0XHR0aGlzLnN1cGFiYXNlU2VydmljZSA9IHNlcnZpY2U7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXIgdGhlIGV2ZW50IHF1ZXVlLlxuXHQgKi9cblx0cHVibGljIGNsZWFyUXVldWUoKTogdm9pZCB7XG5cdFx0dGhpcy5ldmVudFF1ZXVlID0gW107XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBwcm9jZXNzaW5nIHRpbWVvdXQuXG5cdCAqL1xuXHRwdWJsaWMgc2V0UHJvY2Vzc2luZ1RpbWVvdXQodGltZW91dDogbnVtYmVyKTogdm9pZCB7XG5cdFx0dGhpcy5wcm9jZXNzaW5nVGltZW91dCA9IHRpbWVvdXQ7XG5cdH1cblxuXHQvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGRldGVybWluZSBpZiBhIGZpbGUgaXMgbGlrZWx5IGJpbmFyeSBiYXNlZCBvbiBleHRlbnNpb25cbiAgICAqL1xuXHRwcml2YXRlIGlzQmluYXJ5RmlsZShmaWxlTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG5cdFx0Y29uc3QgYmluYXJ5RXh0ZW5zaW9ucyA9IFtcblx0XHRcdCcuanBnJywgJy5qcGVnJywgJy5wbmcnLCAnLmdpZicsICcuYm1wJywgJy50aWZmJywgJy5pY28nLFxuXHRcdFx0Jy5wZGYnLCAnLnppcCcsICcuN3onLCAnLnJhcicsICcudGFyJywgJy5neicsXG5cdFx0XHQnLm1wMycsICcubXA0JywgJy53YXYnLCAnLm9nZycsICcuZmxhYycsXG5cdFx0XHQnLmV4ZScsICcuZGxsJywgJy5zbycsICcuZHlsaWInLFxuXHRcdFx0Jy5kYicsICcuc3FsaXRlJ1xuXHRcdF07XG5cblx0XHRyZXR1cm4gYmluYXJ5RXh0ZW5zaW9ucy5zb21lKGV4dCA9PlxuXHRcdFx0ZmlsZU5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpXG5cdFx0KTtcblx0fVxufVxuIiwgIi8vIHNyYy9zZXJ2aWNlcy9TeW5jRmlsZU1hbmFnZXIudHNcbmltcG9ydCB7IFRGaWxlLCBWYXVsdCwgcGFyc2VZYW1sLCBzdHJpbmdpZnlZYW1sIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgRXJyb3JIYW5kbGVyIH0gZnJvbSAnLi4vdXRpbHMvRXJyb3JIYW5kbGVyJztcbmltcG9ydCB7IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yIH0gZnJvbSAnLi4vbW9kZWxzL0RvY3VtZW50Q2h1bmsnO1xuaW1wb3J0IHtcblx0U3luY0ZpbGVEYXRhLFxuXHRTeW5jVmFsaWRhdGlvblJlc3VsdCxcblx0U3luY0Vycm9yVHlwZSxcblx0U3luY1N0YXRlLFxuXHRjcmVhdGVFbXB0eVN5bmNGaWxlRGF0YSxcblx0dXBkYXRlRGV2aWNlSW5TeW5jRmlsZSxcblx0YWRkQ29ubmVjdGlvbkV2ZW50LFxuXHR1cGRhdGVEYXRhYmFzZVN0YXR1cyxcblx0dXBkYXRlRGV2aWNlU3luY1RpbWUsXG5cdHRyaW1TeW5jSGlzdG9yeUFycmF5cyxcblx0U3luY0NvbmZsaWN0XG59IGZyb20gJy4uL21vZGVscy9TeW5jTW9kZWxzJztcblxuZXhwb3J0IGNsYXNzIFN5bmNGaWxlTWFuYWdlciB7XG5cdHByaXZhdGUgc3luY0ZpbGVQYXRoOiBzdHJpbmc7XG5cdHByaXZhdGUgYmFja3VwUGF0aDogc3RyaW5nO1xuXHRwcml2YXRlIGxhc3RCYWNrdXA6IG51bWJlciA9IDA7XG5cdHByaXZhdGUgYmFja3VwSW50ZXJ2YWw6IG51bWJlcjtcblx0cHJpdmF0ZSBzeW5jRmlsZTogVEZpbGUgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBjdXJyZW50U3luY0RhdGE6IFN5bmNGaWxlRGF0YSB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIHZhdWx0SWQ6IHN0cmluZztcblx0cHJpdmF0ZSBkZXZpY2VJZDogc3RyaW5nO1xuXHRwcml2YXRlIGRldmljZU5hbWU6IHN0cmluZztcblx0cHJpdmF0ZSBwbHVnaW5WZXJzaW9uOiBzdHJpbmc7XG5cblx0Y29uc3RydWN0b3IoXG5cdFx0cHJpdmF0ZSB2YXVsdDogVmF1bHQsXG5cdFx0cHJpdmF0ZSBlcnJvckhhbmRsZXI6IEVycm9ySGFuZGxlcixcblx0XHRzeW5jRmlsZVBhdGg6IHN0cmluZyA9ICdfbWluZG1hdHJpeHN5bmMubWQnLFxuXHRcdGJhY2t1cEludGVydmFsOiBudW1iZXIgPSAzNjAwMDAwLCAvLyAxIGhvdXIgaW4gbWlsbGlzZWNvbmRzXG5cdFx0dmF1bHRJZDogc3RyaW5nLFxuXHRcdGRldmljZUlkOiBzdHJpbmcsXG5cdFx0ZGV2aWNlTmFtZTogc3RyaW5nLFxuXHRcdHBsdWdpblZlcnNpb246IHN0cmluZ1xuXHQpIHtcblx0XHR0aGlzLnN5bmNGaWxlUGF0aCA9IHN5bmNGaWxlUGF0aDtcblx0XHR0aGlzLmJhY2t1cFBhdGggPSBgJHtzeW5jRmlsZVBhdGh9LmJhY2t1cGA7XG5cdFx0dGhpcy5iYWNrdXBJbnRlcnZhbCA9IGJhY2t1cEludGVydmFsO1xuXHRcdHRoaXMudmF1bHRJZCA9IHZhdWx0SWQ7XG5cdFx0dGhpcy5kZXZpY2VJZCA9IGRldmljZUlkO1xuXHRcdHRoaXMuZGV2aWNlTmFtZSA9IGRldmljZU5hbWU7XG5cdFx0dGhpcy5wbHVnaW5WZXJzaW9uID0gcGx1Z2luVmVyc2lvbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIG9yIHZhbGlkYXRlIHRoZSBzeW5jIGZpbGVcblx0ICovXG5cdGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTxTeW5jVmFsaWRhdGlvblJlc3VsdD4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBDaGVjayBpZiBzeW5jIGZpbGUgZXhpc3RzXG5cdFx0XHRjb25zdCBleGlzdGluZ0ZpbGUgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLnN5bmNGaWxlUGF0aCk7XG5cdFx0XHRpZiAoZXhpc3RpbmdGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcblx0XHRcdFx0dGhpcy5zeW5jRmlsZSA9IGV4aXN0aW5nRmlsZTtcblx0XHRcdFx0Ly8gVmFsaWRhdGUgZXhpc3RpbmcgZmlsZSBhbmQgcGFyc2UgaXRzIGNvbnRlbnRzXG5cdFx0XHRcdGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBhd2FpdCB0aGlzLnZhbGlkYXRlU3luY0ZpbGUoKTtcblx0XHRcdFx0aWYgKCF2YWxpZGF0aW9uUmVzdWx0LmlzVmFsaWQpIHtcblx0XHRcdFx0XHRjb25zdCByZWNvdmVyZWQgPSBhd2FpdCB0aGlzLnJlcGFpclN5bmNGaWxlKCk7XG5cdFx0XHRcdFx0aWYgKCFyZWNvdmVyZWQpIHtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuY3JlYXRlU3luY0ZpbGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIENyZWF0ZSBuZXcgc3luYyBmaWxlXG5cdFx0XHRcdGF3YWl0IHRoaXMuY3JlYXRlU3luY0ZpbGUoKTtcblx0XHRcdH1cblx0XHRcdC8vIENyZWF0ZSBpbml0aWFsIGJhY2t1cFxuXHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVCYWNrdXAoKTtcblx0XHRcdHJldHVybiBhd2FpdCB0aGlzLnZhbGlkYXRlU3luY0ZpbGUoKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHtcblx0XHRcdFx0Y29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci5pbml0aWFsaXplJyxcblx0XHRcdFx0bWV0YWRhdGE6IHsgc3luY0ZpbGVQYXRoOiB0aGlzLnN5bmNGaWxlUGF0aCB9XG5cdFx0XHR9KTtcblx0XHRcdC8vIFRyeSB0byBjcmVhdGUgYSBuZXcgZmlsZSBhcyBhIGxhc3QgcmVzb3J0XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZVN5bmNGaWxlKCk7XG5cdFx0XHRcdHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcblx0XHRcdH0gY2F0Y2ggKGNyZWF0ZUVycm9yKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aXNWYWxpZDogZmFsc2UsXG5cdFx0XHRcdFx0ZXJyb3I6IGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBzeW5jIGZpbGU6ICR7Y3JlYXRlRXJyb3IubWVzc2FnZX1gXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIG5ldyBzeW5jIGZpbGUgd2l0aCB0aGUgbmV3IHN0cnVjdHVyZVxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBjcmVhdGVTeW5jRmlsZSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zb2xlLmxvZygnU3RhcnRpbmcgc3luYyBmaWxlIGNyZWF0aW9uIHdpdGggd2FpdCBwZXJpb2RzLi4uJyk7XG5cblx0XHQvLyBJbmNyZWFzZWQgZGVsYXkgZm9yIHNhZmVyIGZpbGUgb3BlcmF0aW9uc1xuXHRcdGNvbnN0IEZJTEVfT1BfREVMQVkgPSAxMDAwOyAvLyAxIHNlY29uZFxuXG5cdFx0Ly8gRmlyc3QgY2hlY2sgaWYgdGhlIGZpbGUgZXhpc3RzXG5cdFx0Y29uc3QgZXhpc3RpbmdGaWxlID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5zeW5jRmlsZVBhdGgpO1xuXG5cdFx0Ly8gQ3JlYXRlIG5ldyBzeW5jIGRhdGFcblx0XHR0aGlzLmN1cnJlbnRTeW5jRGF0YSA9IGNyZWF0ZUVtcHR5U3luY0ZpbGVEYXRhKFxuXHRcdFx0dGhpcy52YXVsdElkLFxuXHRcdFx0dGhpcy5kZXZpY2VJZCxcblx0XHRcdHRoaXMuZGV2aWNlTmFtZSxcblx0XHRcdHRoaXMucGx1Z2luVmVyc2lvblxuXHRcdCk7XG5cblx0XHQvLyBHZW5lcmF0ZSBpbml0aWFsIGNvbnRlbnRcblx0XHRjb25zdCBpbml0aWFsQ29udGVudCA9IHRoaXMuZ2VuZXJhdGVTeW5jRmlsZUNvbnRlbnQodGhpcy5jdXJyZW50U3luY0RhdGEpO1xuXG5cdFx0Ly8gSWYgZmlsZSBleGlzdHMsIHByaW9yaXRpemUgbW9kaWZ5aW5nIGl0IGluc3RlYWQgb2YgZGVsZXRpbmcgYW5kIHJlY3JlYXRpbmdcblx0XHRpZiAoZXhpc3RpbmdGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdFeGlzdGluZyBzeW5jIGZpbGUgZm91bmQsIGF0dGVtcHRpbmcgdG8gbW9kaWZ5IGl0Jyk7XG5cdFx0XHRcdHRoaXMuc3luY0ZpbGUgPSBleGlzdGluZ0ZpbGU7XG5cdFx0XHRcdGF3YWl0IHRoaXMudmF1bHQubW9kaWZ5KGV4aXN0aW5nRmlsZSwgaW5pdGlhbENvbnRlbnQpO1xuXHRcdFx0XHRjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IG1vZGlmaWVkIGV4aXN0aW5nIHN5bmMgZmlsZScpO1xuXG5cdFx0XHRcdC8vIFdhaXQgYSBiaXQgdG8gZW5zdXJlIGZpbGUgc3lzdGVtIG9wZXJhdGlvbnMgY29tcGxldGVcblx0XHRcdFx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIEZJTEVfT1BfREVMQVkpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBjYXRjaCAobW9kaWZ5RXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gbW9kaWZ5IGV4aXN0aW5nIHN5bmMgZmlsZSwgd2lsbCB0cnkgZGVsZXRlIGFuZCByZWNyZWF0ZTonLCBtb2RpZnlFcnJvcik7XG5cblx0XHRcdFx0Ly8gSWYgbW9kaWZpY2F0aW9uIGZhaWxzLCB0cnkgZGVsZXRlIGFuZCByZWNyZWF0ZSBhcHByb2FjaFxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMudmF1bHQuZGVsZXRlKGV4aXN0aW5nRmlsZSk7XG5cdFx0XHRcdFx0Ly8gTG9uZ2VyIGRlbGF5IGFmdGVyIGRlbGV0aW9uXG5cdFx0XHRcdFx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIEZJTEVfT1BfREVMQVkpKTtcblx0XHRcdFx0fSBjYXRjaCAoZGVsZXRlRXJyb3IpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIGV4aXN0aW5nIHN5bmMgZmlsZTonLCBkZWxldGVFcnJvcik7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgbW9kaWZ5IG9yIGRlbGV0ZSBzeW5jIGZpbGU6ICR7bW9kaWZ5RXJyb3IubWVzc2FnZX0sICR7ZGVsZXRlRXJyb3IubWVzc2FnZX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpbGUgZG9lc24ndCBleGlzdCBvciB3YXMgZGVsZXRlZCwgcHJvY2VlZCB3aXRoIGNyZWF0aW9uXG5cdFx0Y29uc29sZS5sb2coJ1dhaXRpbmcgYmVmb3JlIGNyZWF0aW5nIHN5bmMgZmlsZS4uLicpO1xuXHRcdGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBGSUxFX09QX0RFTEFZKSk7XG5cblx0XHQvLyBNdWx0aXBsZSBhdHRlbXB0cyBmb3IgY3JlYXRpb24gd2l0aCBpbmNyZWFzaW5nIGRlbGF5c1xuXHRcdGxldCBjcmVhdGVBdHRlbXB0cyA9IDA7XG5cdFx0Y29uc3QgbWF4QXR0ZW1wdHMgPSAzO1xuXG5cdFx0d2hpbGUgKGNyZWF0ZUF0dGVtcHRzIDwgbWF4QXR0ZW1wdHMpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuc3luY0ZpbGUgPSBhd2FpdCB0aGlzLnZhdWx0LmNyZWF0ZSh0aGlzLnN5bmNGaWxlUGF0aCwgaW5pdGlhbENvbnRlbnQpO1xuXHRcdFx0XHRjb25zb2xlLmxvZygnU3luYyBmaWxlIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fSBjYXRjaCAoY3JlYXRlRXJyb3IpIHtcblx0XHRcdFx0Y3JlYXRlQXR0ZW1wdHMrKztcblx0XHRcdFx0Y29uc29sZS53YXJuKGBDcmVhdGUgYXR0ZW1wdCAke2NyZWF0ZUF0dGVtcHRzfSBmYWlsZWQ6YCwgY3JlYXRlRXJyb3IpO1xuXG5cdFx0XHRcdGlmIChjcmVhdGVBdHRlbXB0cyA+PSBtYXhBdHRlbXB0cykge1xuXHRcdFx0XHRcdC8vIExhc3QgcmVzb3J0OiBjaGVjayBpZiBmaWxlIGV4aXN0cyBkZXNwaXRlIGNyZWF0aW9uIGVycm9yXG5cdFx0XHRcdFx0Y29uc3QgZmluYWxDaGVjayA9IHRoaXMudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMuc3luY0ZpbGVQYXRoKTtcblx0XHRcdFx0XHRpZiAoZmluYWxDaGVjayBpbnN0YW5jZW9mIFRGaWxlKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZygnU3luYyBmaWxlIGV4aXN0cyBkZXNwaXRlIGNyZWF0aW9uIGVycm9yLCB1c2luZyBpdCcpO1xuXHRcdFx0XHRcdFx0dGhpcy5zeW5jRmlsZSA9IGZpbmFsQ2hlY2s7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHN5bmMgZmlsZSBhZnRlciAke21heEF0dGVtcHRzfSBhdHRlbXB0czogJHtjcmVhdGVFcnJvci5tZXNzYWdlfWApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRXhwb25lbnRpYWwgYmFja29mZiBmb3IgcmV0cmllc1xuXHRcdFx0XHRjb25zdCB3YWl0VGltZSA9IEZJTEVfT1BfREVMQVkgKiAoY3JlYXRlQXR0ZW1wdHMgKyAxKTtcblx0XHRcdFx0Y29uc29sZS5sb2coYFdhaXRpbmcgJHt3YWl0VGltZX1tcyBiZWZvcmUgcmV0cnkuLi5gKTtcblx0XHRcdFx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHdhaXRUaW1lKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gVmVyaWZ5IGZpbGUgZXhpc3RzIGFuZCBpcyByZWFkYWJsZVxuXHRcdGNvbnN0IGZpbGVFeGlzdHMgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLnN5bmNGaWxlUGF0aCk7XG5cdFx0aWYgKCFmaWxlRXhpc3RzKSB7XG5cdFx0XHR0aHJvdyB0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVTeW5jRXJyb3IoXG5cdFx0XHRcdFN5bmNFcnJvclR5cGUuU1lOQ19GSUxFX01JU1NJTkcsXG5cdFx0XHRcdCdTeW5jIGZpbGUgY3JlYXRpb24gZmFpbGVkIC0gZmlsZSBub3QgZm91bmQgYWZ0ZXIgd2FpdCBwZXJpb2QnLFxuXHRcdFx0XHR7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIuY3JlYXRlU3luY0ZpbGUnIH0sXG5cdFx0XHRcdHVuZGVmaW5lZCxcblx0XHRcdFx0dGhpcy5kZXZpY2VJZCxcblx0XHRcdFx0ZmFsc2Vcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Y29uc29sZS5sb2coJ1N5bmMgZmlsZSBjcmVhdGlvbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGUgc3luYyBmaWxlIGNvbnRlbnQgZnJvbSBkYXRhXG5cdCAqL1xuXHRwcml2YXRlIGdlbmVyYXRlU3luY0ZpbGVDb250ZW50KGRhdGE6IFN5bmNGaWxlRGF0YSk6IHN0cmluZyB7XG5cdFx0Ly8gQ29udmVydCBkYXRhIHRvIFlBTUwgdXNpbmcgT2JzaWRpYW4ncyBidWlsdC1pbiBmdW5jdGlvblxuXHRcdGNvbnN0IHlhbWxDb250ZW50ID0gc3RyaW5naWZ5WWFtbChkYXRhKTtcblx0XHQvLyBSZXR1cm4gYXMgbWFya2Rvd24gd2l0aCBZQU1MIGZyb250IG1hdHRlclxuXHRcdHJldHVybiBgLS0tXFxuJHt5YW1sQ29udGVudH0tLS1cXG5cXG4jIyBNaW5kIE1hdHJpeCBTeW5jIEZpbGVcXG5cXG5UaGlzIGZpbGUgbWFuYWdlcyBjcm9zcy1kZXZpY2UgY29vcmRpbmF0aW9uIGZvciB0aGUgTWluZCBNYXRyaXggcGx1Z2luLlxcbkRvIG5vdCBtb2RpZnkgdGhpcyBmaWxlIG1hbnVhbGx5LlxcbmA7XG5cdH1cblxuXHQvKipcblx0ICogVmFsaWRhdGUgc3luYyBmaWxlIHN0cnVjdHVyZSBhbmQgY29udGVudFxuXHQgKi9cblx0YXN5bmMgdmFsaWRhdGVTeW5jRmlsZSgpOiBQcm9taXNlPFN5bmNWYWxpZGF0aW9uUmVzdWx0PiB7XG5cdFx0aWYgKCF0aGlzLnN5bmNGaWxlKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRpc1ZhbGlkOiBmYWxzZSxcblx0XHRcdFx0ZXJyb3I6ICdTeW5jIGZpbGUgbm90IGluaXRpYWxpemVkJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHQucmVhZCh0aGlzLnN5bmNGaWxlKTtcblx0XHRcdC8vIEV4dHJhY3QgWUFNTCBmcm9udCBtYXR0ZXJcblx0XHRcdGNvbnN0IHlhbWxNYXRjaCA9IGNvbnRlbnQubWF0Y2goL14tLS1cXG4oW1xcc1xcU10qPylcXG4tLS0vKTtcblx0XHRcdGlmICgheWFtbE1hdGNoKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdJbnZhbGlkIHN5bmMgZmlsZSBmb3JtYXQ6IE1pc3NpbmcgWUFNTCBmcm9udCBtYXR0ZXIuIFdpbGwgcmVjcmVhdGUgZmlsZS4nKTtcblx0XHRcdFx0Ly8gSW5zdGVhZCBvZiBqdXN0IHJldHVybmluZyBhbiBlcnJvciwgcmVjcmVhdGUgdGhlIGZpbGVcblx0XHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVTeW5jRmlsZSgpO1xuXHRcdFx0XHRyZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07XG5cdFx0XHR9XG5cdFx0XHQvLyBQYXJzZSBZQU1MIGNvbnRlbnQgdXNpbmcgT2JzaWRpYW4ncyBidWlsdC1pbiBmdW5jdGlvblxuXHRcdFx0Y29uc3QgeWFtbENvbnRlbnQgPSB5YW1sTWF0Y2hbMV07XG5cdFx0XHRsZXQgcGFyc2VkRGF0YTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHBhcnNlZERhdGEgPSBwYXJzZVlhbWwoeWFtbENvbnRlbnQpO1xuXHRcdFx0fSBjYXRjaCAocGFyc2VFcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnRmFpbGVkIHRvIHBhcnNlIFlBTUwgY29udGVudDonLCBwYXJzZUVycm9yKTtcblx0XHRcdFx0Ly8gSWYgcGFyc2luZyBmYWlscywgcmVjcmVhdGUgdGhlIGZpbGVcblx0XHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVTeW5jRmlsZSgpO1xuXHRcdFx0XHRyZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07XG5cdFx0XHR9XG5cdFx0XHQvLyBWYWxpZGF0ZSBiYXNpYyBzdHJ1Y3R1cmVcblx0XHRcdGlmICghcGFyc2VkRGF0YSB8fCB0eXBlb2YgcGFyc2VkRGF0YSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0ludmFsaWQgc3luYyBmaWxlIGZvcm1hdDogQ2Fubm90IHBhcnNlIFlBTUwgY29udGVudC4gV2lsbCByZWNyZWF0ZSBmaWxlLicpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZVN5bmNGaWxlKCk7XG5cdFx0XHRcdHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcblx0XHRcdH1cblx0XHRcdC8vIENoZWNrIGlmIHRoaXMgaXMgYW4gb2xkIGZvcm1hdCBzeW5jIGZpbGUgKGhhcyBhIHRhYmxlIHN0cnVjdHVyZSlcblx0XHRcdGlmIChjb250ZW50LmluY2x1ZGVzKCd8IEZpbGUgUGF0aCB8IExhc3QgTW9kaWZpZWQgfCcpKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdEZXRlY3RlZCBvbGQgZm9ybWF0IHN5bmMgZmlsZS4gV2lsbCBjb252ZXJ0IHRvIG5ldyBmb3JtYXQuJyk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuY3JlYXRlU3luY0ZpbGUoKTtcblx0XHRcdFx0cmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ2hlY2sgcmVxdWlyZWQgZmllbGRzXG5cdFx0XHRpZiAoXG5cdFx0XHRcdCFwYXJzZWREYXRhLmhlYWRlciB8fFxuXHRcdFx0XHQhcGFyc2VkRGF0YS5oZWFkZXIudmF1bHRJZCB8fFxuXHRcdFx0XHQhcGFyc2VkRGF0YS5oZWFkZXIubGFzdEdsb2JhbFN5bmMgfHxcblx0XHRcdFx0IXBhcnNlZERhdGEuaGVhZGVyLmRldmljZXNcblx0XHRcdCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnSW52YWxpZCBzeW5jIGZpbGUgZm9ybWF0OiBNaXNzaW5nIHJlcXVpcmVkIGZpZWxkcy4gV2lsbCByZWNyZWF0ZSBmaWxlLicpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZVN5bmNGaWxlKCk7XG5cdFx0XHRcdHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcblx0XHRcdH1cblx0XHRcdC8vIFZlcmlmeSB2YXVsdCBJRCBtYXRjaGVzXG5cdFx0XHRpZiAocGFyc2VkRGF0YS5oZWFkZXIudmF1bHRJZCAhPT0gdGhpcy52YXVsdElkKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdWYXVsdCBJRCBtaXNtYXRjaC4gT2xkIElEOicsIHBhcnNlZERhdGEuaGVhZGVyLnZhdWx0SWQsICdOZXcgSUQ6JywgdGhpcy52YXVsdElkKTtcblx0XHRcdFx0Ly8gVXBkYXRlIHRoZSB2YXVsdCBJRCB0byBtYXRjaCB0aGUgY3VycmVudCBvbmVcblx0XHRcdFx0cGFyc2VkRGF0YS5oZWFkZXIudmF1bHRJZCA9IHRoaXMudmF1bHRJZDtcblx0XHRcdH1cblx0XHRcdC8vIFN0b3JlIHRoZSBwYXJzZWQgZGF0YVxuXHRcdFx0dGhpcy5jdXJyZW50U3luY0RhdGEgPSBwYXJzZWREYXRhIGFzIFN5bmNGaWxlRGF0YTtcblx0XHRcdC8vIEVuc3VyZSBhbGwgcmVxdWlyZWQgcHJvcGVydGllcyBleGlzdCBpbiB0aGUgZGF0YSBzdHJ1Y3R1cmVcblx0XHRcdGlmICghdGhpcy5jdXJyZW50U3luY0RhdGEuY29ubmVjdGlvbkV2ZW50cykgdGhpcy5jdXJyZW50U3luY0RhdGEuY29ubmVjdGlvbkV2ZW50cyA9IFtdO1xuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YS5wZW5kaW5nT3BlcmF0aW9ucykgdGhpcy5jdXJyZW50U3luY0RhdGEucGVuZGluZ09wZXJhdGlvbnMgPSBbXTtcblx0XHRcdGlmICghdGhpcy5jdXJyZW50U3luY0RhdGEuY29uZmxpY3RzKSB0aGlzLmN1cnJlbnRTeW5jRGF0YS5jb25mbGljdHMgPSBbXTtcblx0XHRcdGlmICghdGhpcy5jdXJyZW50U3luY0RhdGEubGFzdERhdGFiYXNlQ2hlY2spIHRoaXMuY3VycmVudFN5bmNEYXRhLmxhc3REYXRhYmFzZUNoZWNrID0gRGF0ZS5ub3coKTtcblx0XHRcdGlmICghdGhpcy5jdXJyZW50U3luY0RhdGEuZGF0YWJhc2VTdGF0dXMpIHRoaXMuY3VycmVudFN5bmNEYXRhLmRhdGFiYXNlU3RhdHVzID0gJ3Vua25vd24nO1xuXG5cdFx0XHQvLyBJbml0aWFsaXplIGZpbGVTdGF0dXNlcyBpZiBpdCBkb2Vzbid0IGV4aXN0XG5cdFx0XHRpZiAoIXRoaXMuY3VycmVudFN5bmNEYXRhLmhlYWRlci5maWxlU3RhdHVzZXMpIHRoaXMuY3VycmVudFN5bmNEYXRhLmhlYWRlci5maWxlU3RhdHVzZXMgPSB7fTtcblxuXHRcdFx0Ly8gVXBkYXRlIGRldmljZSBpbmZvcm1hdGlvblxuXHRcdFx0dGhpcy5jdXJyZW50U3luY0RhdGEgPSB1cGRhdGVEZXZpY2VJblN5bmNGaWxlKFxuXHRcdFx0XHR0aGlzLmN1cnJlbnRTeW5jRGF0YSxcblx0XHRcdFx0dGhpcy5kZXZpY2VJZCxcblx0XHRcdFx0dGhpcy5kZXZpY2VOYW1lLFxuXHRcdFx0XHR0aGlzLnBsdWdpblZlcnNpb25cblx0XHRcdCk7XG5cdFx0XHQvLyBXcml0ZSBiYWNrIHRoZSB1cGRhdGVkIGRhdGFcblx0XHRcdGF3YWl0IHRoaXMud3JpdGVTeW5jRmlsZSh0aGlzLmN1cnJlbnRTeW5jRGF0YSk7XG5cdFx0XHRyZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIudmFsaWRhdGVTeW5jRmlsZScgfSk7XG5cdFx0XHRjb25zb2xlLmxvZygnRmFpbGVkIHRvIHZhbGlkYXRlIHN5bmMgZmlsZSwgd2lsbCByZWNyZWF0ZTonLCBlcnJvcik7XG5cdFx0XHQvLyBUcnkgdG8gcmVjcmVhdGUgdGhlIGZpbGUgYXMgYSBsYXN0IHJlc29ydFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVTeW5jRmlsZSgpO1xuXHRcdFx0XHRyZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07XG5cdFx0XHR9IGNhdGNoIChjcmVhdGVFcnJvcikge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGlzVmFsaWQ6IGZhbHNlLFxuXHRcdFx0XHRcdGVycm9yOiBgRmFpbGVkIHRvIHZhbGlkYXRlIGFuZCByZWNyZWF0ZSBzeW5jIGZpbGU6ICR7Y3JlYXRlRXJyb3IubWVzc2FnZX1gXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEFsaWFzIGZvciB2YWxpZGF0ZVN5bmNGaWxlKCkgdG8gc3VwcG9ydCBsZWdhY3kgY2FsbHMuXG5cdCAqL1xuXHRhc3luYyB2YWxpZGF0ZVN5bmNTdGF0ZSgpOiBQcm9taXNlPFN5bmNWYWxpZGF0aW9uUmVzdWx0PiB7XG5cdFx0cmV0dXJuIGF3YWl0IHRoaXMudmFsaWRhdGVTeW5jRmlsZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlcGFpciBjb3JydXB0ZWQgc3luYyBmaWxlXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIHJlcGFpclN5bmNGaWxlKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBUcnkgdG8gcmVzdG9yZSBmcm9tIGJhY2t1cCBmaXJzdFxuXHRcdFx0Y29uc3QgcmVzdG9yZWQgPSBhd2FpdCB0aGlzLnJlc3RvcmVGcm9tQmFja3VwKCk7XG5cdFx0XHRpZiAocmVzdG9yZWQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiByZXN0b3JhdGlvbiBmYWlscywgY3JlYXRlIG5ldyBzeW5jIGZpbGVcblx0XHRcdGF3YWl0IHRoaXMuY3JlYXRlU3luY0ZpbGUoKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwge1xuXHRcdFx0XHRjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLnJlcGFpclN5bmNGaWxlJyxcblx0XHRcdFx0bWV0YWRhdGE6IHsgc3luY0ZpbGVQYXRoOiB0aGlzLnN5bmNGaWxlUGF0aCB9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVhZCBhbmQgcGFyc2UgdGhlIHN5bmMgZmlsZVxuXHQgKi9cblx0YXN5bmMgcmVhZFN5bmNGaWxlKCk6IFByb21pc2U8U3luY0ZpbGVEYXRhIHwgbnVsbD4ge1xuXHRcdGlmICghdGhpcy5zeW5jRmlsZSkge1xuXHRcdFx0dGhyb3cgdGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlU3luY0Vycm9yKFxuXHRcdFx0XHRTeW5jRXJyb3JUeXBlLlNZTkNfRklMRV9NSVNTSU5HLFxuXHRcdFx0XHQnU3luYyBmaWxlIG5vdCBpbml0aWFsaXplZCcsXG5cdFx0XHRcdHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci5yZWFkU3luY0ZpbGUnIH0sXG5cdFx0XHRcdHVuZGVmaW5lZCxcblx0XHRcdFx0dGhpcy5kZXZpY2VJZFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHQucmVhZCh0aGlzLnN5bmNGaWxlKTtcblx0XHRcdC8vIEV4dHJhY3QgWUFNTCBmcm9udCBtYXR0ZXJcblx0XHRcdGNvbnN0IHlhbWxNYXRjaCA9IGNvbnRlbnQubWF0Y2goL14tLS1cXG4oW1xcc1xcU10qPylcXG4tLS0vKTtcblx0XHRcdGlmICgheWFtbE1hdGNoKSB7XG5cdFx0XHRcdHRocm93IHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZVN5bmNFcnJvcihcblx0XHRcdFx0XHRTeW5jRXJyb3JUeXBlLlNZTkNfRklMRV9DT1JSVVBULFxuXHRcdFx0XHRcdCdJbnZhbGlkIHN5bmMgZmlsZSBmb3JtYXQ6IE1pc3NpbmcgWUFNTCBmcm9udCBtYXR0ZXInLFxuXHRcdFx0XHRcdHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci5yZWFkU3luY0ZpbGUnIH0sXG5cdFx0XHRcdFx0dW5kZWZpbmVkLFxuXHRcdFx0XHRcdHRoaXMuZGV2aWNlSWRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdC8vIFBhcnNlIFlBTUwgY29udGVudCB1c2luZyBPYnNpZGlhbidzIGJ1aWx0LWluIGZ1bmN0aW9uXG5cdFx0XHRjb25zdCB5YW1sQ29udGVudCA9IHlhbWxNYXRjaFsxXTtcblx0XHRcdGNvbnN0IHBhcnNlZERhdGEgPSBwYXJzZVlhbWwoeWFtbENvbnRlbnQpIGFzIFN5bmNGaWxlRGF0YTtcblx0XHRcdGlmICghcGFyc2VkRGF0YSB8fCAhcGFyc2VkRGF0YS5oZWFkZXIpIHtcblx0XHRcdFx0dGhyb3cgdGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlU3luY0Vycm9yKFxuXHRcdFx0XHRcdFN5bmNFcnJvclR5cGUuU1lOQ19GSUxFX0NPUlJVUFQsXG5cdFx0XHRcdFx0J0ludmFsaWQgc3luYyBmaWxlIGZvcm1hdDogTWlzc2luZyByZXF1aXJlZCBmaWVsZHMnLFxuXHRcdFx0XHRcdHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci5yZWFkU3luY0ZpbGUnIH0sXG5cdFx0XHRcdFx0dW5kZWZpbmVkLFxuXHRcdFx0XHRcdHRoaXMuZGV2aWNlSWRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdC8vIENhY2hlIHRoZSBwYXJzZWQgZGF0YVxuXHRcdFx0dGhpcy5jdXJyZW50U3luY0RhdGEgPSBwYXJzZWREYXRhO1xuXHRcdFx0cmV0dXJuIHBhcnNlZERhdGE7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmICghdGhpcy5lcnJvckhhbmRsZXIuaXNTeW5jRXJyb3IoZXJyb3IpKSB7XG5cdFx0XHRcdHRocm93IHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZVN5bmNFcnJvcihcblx0XHRcdFx0XHRTeW5jRXJyb3JUeXBlLlNZTkNfRklMRV9DT1JSVVBULFxuXHRcdFx0XHRcdGBFcnJvciByZWFkaW5nIHN5bmMgZmlsZTogJHtlcnJvci5tZXNzYWdlfWAsXG5cdFx0XHRcdFx0eyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLnJlYWRTeW5jRmlsZScgfSxcblx0XHRcdFx0XHR1bmRlZmluZWQsXG5cdFx0XHRcdFx0dGhpcy5kZXZpY2VJZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFdyaXRlIHN5bmMgZGF0YSB0byB0aGUgc3luYyBmaWxlXG5cdCAqL1xuXHRhc3luYyB3cml0ZVN5bmNGaWxlKGRhdGE6IFN5bmNGaWxlRGF0YSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghdGhpcy5zeW5jRmlsZSkge1xuXHRcdFx0dGhyb3cgdGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlU3luY0Vycm9yKFxuXHRcdFx0XHRTeW5jRXJyb3JUeXBlLlNZTkNfRklMRV9NSVNTSU5HLFxuXHRcdFx0XHQnU3luYyBmaWxlIG5vdCBpbml0aWFsaXplZCcsXG5cdFx0XHRcdHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci53cml0ZVN5bmNGaWxlJyB9LFxuXHRcdFx0XHR1bmRlZmluZWQsXG5cdFx0XHRcdHRoaXMuZGV2aWNlSWRcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIFVwZGF0ZSBzeW5jIGZpbGUgY29udGVudFxuXHRcdFx0Y29uc3QgY29udGVudCA9IHRoaXMuZ2VuZXJhdGVTeW5jRmlsZUNvbnRlbnQoZGF0YSk7XG5cdFx0XHRhd2FpdCB0aGlzLnZhdWx0Lm1vZGlmeSh0aGlzLnN5bmNGaWxlLCBjb250ZW50KTtcblx0XHRcdC8vIFVwZGF0ZSBjYWNoZWQgZGF0YVxuXHRcdFx0dGhpcy5jdXJyZW50U3luY0RhdGEgPSBkYXRhO1xuXHRcdFx0Ly8gQ3JlYXRlIGJhY2t1cCBpZiBuZWVkZWRcblx0XHRcdGlmIChEYXRlLm5vdygpIC0gdGhpcy5sYXN0QmFja3VwID49IHRoaXMuYmFja3VwSW50ZXJ2YWwpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVCYWNrdXAoKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhyb3cgdGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlU3luY0Vycm9yKFxuXHRcdFx0XHRTeW5jRXJyb3JUeXBlLlVOS05PV05fRVJST1IsXG5cdFx0XHRcdGBGYWlsZWQgdG8gd3JpdGUgc3luYyBmaWxlOiAke2Vycm9yLm1lc3NhZ2V9YCxcblx0XHRcdFx0eyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLndyaXRlU3luY0ZpbGUnIH0sXG5cdFx0XHRcdHVuZGVmaW5lZCxcblx0XHRcdFx0dGhpcy5kZXZpY2VJZFxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIGEgYmFja3VwIG9mIHRoZSBzeW5jIGZpbGVcblx0ICovXG5cdHByaXZhdGUgYXN5bmMgY3JlYXRlQmFja3VwKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICghdGhpcy5zeW5jRmlsZSkgcmV0dXJuO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLnZhdWx0LnJlYWQodGhpcy5zeW5jRmlsZSk7XG5cdFx0XHRjb25zdCBiYWNrdXBGaWxlID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5iYWNrdXBQYXRoKTtcblx0XHRcdGlmIChiYWNrdXBGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy52YXVsdC5tb2RpZnkoYmFja3VwRmlsZSwgY29udGVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnZhdWx0LmNyZWF0ZSh0aGlzLmJhY2t1cFBhdGgsIGNvbnRlbnQpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5sYXN0QmFja3VwID0gRGF0ZS5ub3coKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci5jcmVhdGVCYWNrdXAnIH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXN0b3JlIHN5bmMgZmlsZSBmcm9tIGJhY2t1cFxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyByZXN0b3JlRnJvbUJhY2t1cCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRjb25zdCBiYWNrdXBGaWxlID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5iYWNrdXBQYXRoKTtcblx0XHRpZiAoIShiYWNrdXBGaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLnZhdWx0LnJlYWQoYmFja3VwRmlsZSk7XG5cdFx0XHRpZiAodGhpcy5zeW5jRmlsZSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnZhdWx0Lm1vZGlmeSh0aGlzLnN5bmNGaWxlLCBjb250ZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuc3luY0ZpbGUgPSBhd2FpdCB0aGlzLnZhdWx0LmNyZWF0ZSh0aGlzLnN5bmNGaWxlUGF0aCwgY29udGVudCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUcnkgdG8gcGFyc2UgdGhlIHJlc3RvcmVkIGNvbnRlbnRcblx0XHRcdGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBhd2FpdCB0aGlzLnZhbGlkYXRlU3luY0ZpbGUoKTtcblx0XHRcdHJldHVybiB2YWxpZGF0aW9uUmVzdWx0LmlzVmFsaWQ7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIucmVzdG9yZUZyb21CYWNrdXAnIH0pO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGRhdGFiYXNlIGNvbm5lY3Rpb24gc3RhdHVzXG5cdCAqL1xuXHRhc3luYyB1cGRhdGVEYXRhYmFzZVN0YXR1cyhzdGF0dXM6ICdhdmFpbGFibGUnIHwgJ3VuYXZhaWxhYmxlJyB8ICd1bmtub3duJyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBSZWFkIGN1cnJlbnQgZGF0YSBpZiBub3QgY2FjaGVkXG5cdFx0XHRpZiAoIXRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMucmVhZFN5bmNGaWxlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmN1cnJlbnRTeW5jRGF0YSkge1xuXHRcdFx0XHQvLyBVcGRhdGUgc3RhdHVzXG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWREYXRhID0gdXBkYXRlRGF0YWJhc2VTdGF0dXModGhpcy5jdXJyZW50U3luY0RhdGEsIHN0YXR1cyk7XG5cdFx0XHRcdC8vIElmIHN0YXR1cyBjaGFuZ2VkIHRvIHVuYXZhaWxhYmxlLCBhZGQgY29ubmVjdGlvbiBldmVudFxuXHRcdFx0XHRpZiAoc3RhdHVzID09PSAndW5hdmFpbGFibGUnICYmIHRoaXMuY3VycmVudFN5bmNEYXRhLmRhdGFiYXNlU3RhdHVzICE9PSAndW5hdmFpbGFibGUnKSB7XG5cdFx0XHRcdFx0dXBkYXRlZERhdGEuY29ubmVjdGlvbkV2ZW50cy5wdXNoKHtcblx0XHRcdFx0XHRcdHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcblx0XHRcdFx0XHRcdGV2ZW50VHlwZTogJ2Rpc2Nvbm5lY3RlZCcsXG5cdFx0XHRcdFx0XHRkZXZpY2VJZDogdGhpcy5kZXZpY2VJZCxcblx0XHRcdFx0XHRcdGRldGFpbHM6ICdEYXRhYmFzZSBjb25uZWN0aW9uIGxvc3QnXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gSWYgc3RhdHVzIGNoYW5nZWQgdG8gYXZhaWxhYmxlLCBhZGQgY29ubmVjdGlvbiBldmVudFxuXHRcdFx0XHRpZiAoc3RhdHVzID09PSAnYXZhaWxhYmxlJyAmJiB0aGlzLmN1cnJlbnRTeW5jRGF0YS5kYXRhYmFzZVN0YXR1cyAhPT0gJ2F2YWlsYWJsZScpIHtcblx0XHRcdFx0XHR1cGRhdGVkRGF0YS5jb25uZWN0aW9uRXZlbnRzLnB1c2goe1xuXHRcdFx0XHRcdFx0dGltZXN0YW1wOiBEYXRlLm5vdygpLFxuXHRcdFx0XHRcdFx0ZXZlbnRUeXBlOiAnY29ubmVjdGVkJyxcblx0XHRcdFx0XHRcdGRldmljZUlkOiB0aGlzLmRldmljZUlkLFxuXHRcdFx0XHRcdFx0ZGV0YWlsczogJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQnXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVHJpbSBhcnJheXMgdG8gcHJldmVudCBleGNlc3NpdmUgZ3Jvd3RoXG5cdFx0XHRcdGNvbnN0IHRyaW1tZWREYXRhID0gdHJpbVN5bmNIaXN0b3J5QXJyYXlzKHVwZGF0ZWREYXRhKTtcblx0XHRcdFx0Ly8gV3JpdGUgdXBkYXRlZCBkYXRhXG5cdFx0XHRcdGF3YWl0IHRoaXMud3JpdGVTeW5jRmlsZSh0cmltbWVkRGF0YSk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7XG5cdFx0XHRcdGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIudXBkYXRlRGF0YWJhc2VTdGF0dXMnLFxuXHRcdFx0XHRtZXRhZGF0YTogeyBzdGF0dXMgfVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBkZXZpY2Ugc3luYyB0aW1lc3RhbXAgYW5kIHN0YXR1c1xuXHQgKi9cblx0YXN5bmMgdXBkYXRlRGV2aWNlU3luY1RpbWVzdGFtcCgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gUmVhZCBjdXJyZW50IGRhdGEgaWYgbm90IGNhY2hlZFxuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnJlYWRTeW5jRmlsZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHRcdC8vIFVwZGF0ZSBkZXZpY2Ugc3luYyB0aW1lXG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWREYXRhID0gdXBkYXRlRGV2aWNlU3luY1RpbWUodGhpcy5jdXJyZW50U3luY0RhdGEsIHRoaXMuZGV2aWNlSWQpO1xuXHRcdFx0XHQvLyBXcml0ZSB1cGRhdGVkIGRhdGFcblx0XHRcdFx0YXdhaXQgdGhpcy53cml0ZVN5bmNGaWxlKHVwZGF0ZWREYXRhKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci51cGRhdGVEZXZpY2VTeW5jVGltZXN0YW1wJyB9KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogKipOZXcgTWV0aG9kOioqXG5cdCAqIFVwZGF0ZXMgdGhlIHN5bmMgc3RhdHVzIGZvciBhIGdpdmVuIGZpbGUgaW4gdGhlIHN5bmMgZmlsZS5cblx0ICogVGhpcyBtZXRob2QgaXMgdXNlZCBhcyBhIGZhbGxiYWNrIHdoZW4gdGhlIGRhdGFiYXNlIGlzbid0IGF2YWlsYWJsZS5cblx0ICovXG5cdGFzeW5jIHVwZGF0ZVN5bmNTdGF0dXMoZmlsZVBhdGg6IHN0cmluZywgc3RhdHVzOiBzdHJpbmcsIGFkZGl0aW9uYWxEYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Ly8gRW5zdXJlIHdlIGhhdmUgdGhlIGN1cnJlbnQgc3luYyBkYXRhXG5cdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YSkge1xuXHRcdFx0YXdhaXQgdGhpcy5yZWFkU3luY0ZpbGUoKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHQvLyBBc3N1bWluZyB5b3VyIHN5bmMgZmlsZSBoZWFkZXIgY29udGFpbnMgYSBmaWxlU3RhdHVzZXMgbWFwXG5cdFx0XHR0aGlzLmN1cnJlbnRTeW5jRGF0YS5oZWFkZXIuZmlsZVN0YXR1c2VzID0gdGhpcy5jdXJyZW50U3luY0RhdGEuaGVhZGVyLmZpbGVTdGF0dXNlcyB8fCB7fTtcblx0XHRcdHRoaXMuY3VycmVudFN5bmNEYXRhLmhlYWRlci5maWxlU3RhdHVzZXNbZmlsZVBhdGhdID0ge1xuXHRcdFx0XHRzdGF0dXMsXG5cdFx0XHRcdGxhc3RNb2RpZmllZDogYWRkaXRpb25hbERhdGEubGFzdE1vZGlmaWVkLFxuXHRcdFx0XHRoYXNoOiBhZGRpdGlvbmFsRGF0YS5oYXNoLFxuXHRcdFx0XHR1cGRhdGVkQXQ6IERhdGUubm93KClcblx0XHRcdH07XG5cdFx0XHRhd2FpdCB0aGlzLndyaXRlU3luY0ZpbGUodGhpcy5jdXJyZW50U3luY0RhdGEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJTeW5jIGZpbGUgZGF0YSB1bmF2YWlsYWJsZSBmb3IgdXBkYXRlU3luY1N0YXR1c1wiKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgc3luYyBzdGF0dXMgZm9yIGEgc3BlY2lmaWMgZmlsZSBwYXRoLlxuXHQgKi9cblx0YXN5bmMgZ2V0U3luY1N0YXR1cyhwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHsgc3RhdHVzOiBzdHJpbmc7IGxhc3RNb2RpZmllZDogbnVtYmVyOyBoYXNoOiBzdHJpbmcgfSB8IG51bGw+IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnJlYWRTeW5jRmlsZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5jdXJyZW50U3luY0RhdGEgJiYgdGhpcy5jdXJyZW50U3luY0RhdGEuaGVhZGVyLmZpbGVTdGF0dXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jdXJyZW50U3luY0RhdGEuaGVhZGVyLmZpbGVTdGF0dXNlc1twYXRoXSB8fCBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci5nZXRTeW5jU3RhdHVzJywgbWV0YWRhdGE6IHsgcGF0aCB9IH0pO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBhbGwgcGVuZGluZyBvcGVyYXRpb25zXG5cdCAqL1xuXHRhc3luYyBnZXRQZW5kaW5nT3BlcmF0aW9ucygpOiBQcm9taXNlPEFycmF5PHtcblx0XHRpZDogc3RyaW5nO1xuXHRcdGZpbGVJZDogc3RyaW5nO1xuXHRcdG9wZXJhdGlvblR5cGU6IHN0cmluZztcblx0XHR0aW1lc3RhbXA6IG51bWJlcjtcblx0XHRkZXZpY2VJZDogc3RyaW5nO1xuXHRcdG1ldGFkYXRhPzogYW55O1xuXHRcdHN0YXR1czogc3RyaW5nO1xuXHR9Pj4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBSZWFkIGN1cnJlbnQgZGF0YSBpZiBub3QgY2FjaGVkXG5cdFx0XHRpZiAoIXRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMucmVhZFN5bmNGaWxlKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5jdXJyZW50U3luY0RhdGE/LnBlbmRpbmdPcGVyYXRpb25zIHx8IFtdO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLmdldFBlbmRpbmdPcGVyYXRpb25zJyB9KTtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGN1cnJlbnQgc3luYyBzdGF0ZVxuXHQgKi9cblx0YXN5bmMgZ2V0U3luY1N0YXRlKCk6IFByb21pc2U8U3luY1N0YXRlPiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFJlYWQgY3VycmVudCBkYXRhIGlmIG5vdCBjYWNoZWRcblx0XHRcdGlmICghdGhpcy5jdXJyZW50U3luY0RhdGEpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy5yZWFkU3luY0ZpbGUoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmN1cnJlbnRTeW5jRGF0YT8uaGVhZGVyLnN5bmNTdGF0ZSB8fCBTeW5jU3RhdGUuVU5LTk9XTjtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci5nZXRTeW5jU3RhdGUnIH0pO1xuXHRcdFx0cmV0dXJuIFN5bmNTdGF0ZS5VTktOT1dOO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgYWxsIGtub3duIGRldmljZXNcblx0ICovXG5cdGFzeW5jIGdldEtub3duRGV2aWNlcygpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHtcblx0XHRkZXZpY2VJZDogc3RyaW5nO1xuXHRcdG5hbWU6IHN0cmluZztcblx0XHRwbGF0Zm9ybTogc3RyaW5nO1xuXHRcdGxhc3RTZWVuOiBudW1iZXI7XG5cdFx0bGFzdFN5bmNUaW1lOiBudW1iZXI7XG5cdH0+PiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFJlYWQgY3VycmVudCBkYXRhIGlmIG5vdCBjYWNoZWRcblx0XHRcdGlmICghdGhpcy5jdXJyZW50U3luY0RhdGEpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy5yZWFkU3luY0ZpbGUoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmN1cnJlbnRTeW5jRGF0YT8uaGVhZGVyLmRldmljZXMgfHwge307XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIuZ2V0S25vd25EZXZpY2VzJyB9KTtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhlcmUgYXJlIGNvbmZsaWN0cyB0aGF0IG5lZWQgcmVzb2x1dGlvblxuXHQgKi9cblx0YXN5bmMgZGV0ZWN0Q29uZmxpY3RzKCk6IFByb21pc2U8U3luY0NvbmZsaWN0W10+IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnJlYWRTeW5jRmlsZSgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRW5oYW5jZWQ6IEZpbHRlciBmb3IgY29uZmxpY3RzIHdpdGggbW9yZSBkZXRhaWxlZCBtZXRhZGF0YSAoaWYgbmVlZGVkKVxuXHRcdFx0Y29uc3QgcGVuZGluZ0NvbmZsaWN0cyA9IHRoaXMuY3VycmVudFN5bmNEYXRhPy5jb25mbGljdHMuZmlsdGVyKFxuXHRcdFx0XHRjb25mbGljdCA9PiBjb25mbGljdC5yZXNvbHV0aW9uU3RhdHVzID09PSAncGVuZGluZydcblx0XHRcdCkgfHwgW107XG5cdFx0XHRyZXR1cm4gcGVuZGluZ0NvbmZsaWN0cztcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci5kZXRlY3RDb25mbGljdHMnIH0pO1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBdHRlbXB0IHRvIHJlc29sdmUgYSBjb25mbGljdCBiYXNlZCBvbiBhIGdpdmVuIHJlc29sdXRpb24gc3RyYXRlZ3kuXG5cdCAqIFN1cHBvcnRzIHN0cmF0ZWdpZXM6XG5cdCAqIC0gXCJuZXdlc3Qtd2luc1wiOiBBdXRvbWF0aWNhbGx5IHJlc29sdmVzIGJ5IGZhdm9yaW5nIHRoZSBtb3N0IHJlY2VudCB1cGRhdGUuXG5cdCAqIC0gXCJrZWVwLWJvdGhcIjogTWFya3MgYXMgcmVzb2x2ZWQgYW5kIGxlYXZlcyBib3RoIHZlcnNpb25zIGludGFjdC5cblx0ICogLSBcIm1hbnVhbFwiOiBGbGFncyB0aGUgY29uZmxpY3QgZm9yIG1hbnVhbCBpbnRlcnZlbnRpb24gKGRvZXMgbm90IGF1dG8tcmVzb2x2ZSkuXG5cdCAqL1xuXHRhc3luYyByZXNvbHZlQ29uZmxpY3QoY29uZmxpY3RJZDogc3RyaW5nLCByZXNvbHV0aW9uU3RyYXRlZ3k6ICduZXdlc3Qtd2lucycgfCAnbWFudWFsJyB8ICdrZWVwLWJvdGgnKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghdGhpcy5jdXJyZW50U3luY0RhdGEpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy5yZWFkU3luY0ZpbGUoKTtcblx0XHRcdH1cblx0XHRcdC8vIEZpbmQgdGhlIGNvbmZsaWN0IGJ5IElEXG5cdFx0XHRjb25zdCBjb25mbGljdEluZGV4ID0gdGhpcy5jdXJyZW50U3luY0RhdGE/LmNvbmZsaWN0cy5maW5kSW5kZXgoYyA9PiBjLmlkID09PSBjb25mbGljdElkKTtcblx0XHRcdGlmIChjb25mbGljdEluZGV4ID09PSB1bmRlZmluZWQgfHwgY29uZmxpY3RJbmRleCA8IDApIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdDb25mbGljdCBub3QgZm91bmQ6JywgY29uZmxpY3RJZCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IGNvbmZsaWN0ID0gdGhpcy5jdXJyZW50U3luY0RhdGEhLmNvbmZsaWN0c1tjb25mbGljdEluZGV4XTtcblx0XHRcdHN3aXRjaCAocmVzb2x1dGlvblN0cmF0ZWd5KSB7XG5cdFx0XHRcdGNhc2UgJ25ld2VzdC13aW5zJzpcblx0XHRcdFx0XHQvLyBJbiBhIHJlYWwgc2NlbmFyaW8sIGNvbXBhcmUgdGltZXN0YW1wcyBvciBjb250ZW50IGhhc2hlcyBoZXJlLlxuXHRcdFx0XHRcdGNvbmZsaWN0LnJlc29sdXRpb25TdHJhdGVneSA9ICduZXdlc3Qtd2lucyc7XG5cdFx0XHRcdFx0Y29uZmxpY3QucmVzb2x1dGlvblN0YXR1cyA9ICdyZXNvbHZlZCc7XG5cdFx0XHRcdFx0Y29uZmxpY3QucmVzb2x2ZWRBdCA9IERhdGUubm93KCk7XG5cdFx0XHRcdFx0Y29uZmxpY3QucmVzb2x2ZWRCeSA9IHRoaXMuZGV2aWNlSWQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2tlZXAtYm90aCc6XG5cdFx0XHRcdFx0Ly8gT3B0aW9uYWxseSwgZHVwbGljYXRlIHRoZSBmaWxlIGVudHJ5IGluIHRoZSBkYXRhYmFzZSBhbmQgbWFyayBjb25mbGljdCBhcyByZXNvbHZlZC5cblx0XHRcdFx0XHRjb25mbGljdC5yZXNvbHV0aW9uU3RyYXRlZ3kgPSAna2VlcC1ib3RoJztcblx0XHRcdFx0XHRjb25mbGljdC5yZXNvbHV0aW9uU3RhdHVzID0gJ3Jlc29sdmVkJztcblx0XHRcdFx0XHRjb25mbGljdC5yZXNvbHZlZEF0ID0gRGF0ZS5ub3coKTtcblx0XHRcdFx0XHRjb25mbGljdC5yZXNvbHZlZEJ5ID0gdGhpcy5kZXZpY2VJZDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnbWFudWFsJzpcblx0XHRcdFx0XHQvLyBEbyBub3QgYXV0by1yZXNvbHZlOyBmbGFnIGZvciBtYW51YWwgaW50ZXJ2ZW50aW9uLlxuXHRcdFx0XHRcdGNvbmZsaWN0LnJlc29sdXRpb25TdHJhdGVneSA9ICdtYW51YWwnO1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdNYW51YWwgcmVzb2x1dGlvbiByZXF1aXJlZCBmb3IgY29uZmxpY3Q6JywgY29uZmxpY3RJZCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcmVzb2x1dGlvbiBzdHJhdGVneScpO1xuXHRcdFx0fVxuXHRcdFx0YXdhaXQgdGhpcy53cml0ZVN5bmNGaWxlKHRoaXMuY3VycmVudFN5bmNEYXRhISk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ1N5bmNGaWxlTWFuYWdlci5yZXNvbHZlQ29uZmxpY3QnLCBtZXRhZGF0YTogeyBjb25mbGljdElkIH0gfSk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEF0dGVtcHQgdG8gcmVzb2x2ZSBhbGwgZGV0ZWN0ZWQgY29uZmxpY3RzIHVzaW5nIGEgZGVmYXVsdCBzdHJhdGVneS5cblx0ICovXG5cdGFzeW5jIHJlc29sdmVBbGxDb25mbGljdHMoZGVmYXVsdFN0cmF0ZWd5OiAnbmV3ZXN0LXdpbnMnIHwgJ21hbnVhbCcgfCAna2VlcC1ib3RoJyA9ICduZXdlc3Qtd2lucycpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29uZmxpY3RzID0gYXdhaXQgdGhpcy5kZXRlY3RDb25mbGljdHMoKTtcblx0XHRcdGZvciAoY29uc3QgY29uZmxpY3Qgb2YgY29uZmxpY3RzKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMucmVzb2x2ZUNvbmZsaWN0KGNvbmZsaWN0LmlkLCBkZWZhdWx0U3RyYXRlZ3kpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLnJlc29sdmVBbGxDb25mbGljdHMnIH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGxhc3Qgc3luYyB0aW1lc3RhbXAgaW4gdGhlIHN5bmMgZmlsZSBoZWFkZXIuXG5cdCAqL1xuXHRhc3luYyB1cGRhdGVMYXN0U3luYygpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCF0aGlzLmN1cnJlbnRTeW5jRGF0YSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnJlYWRTeW5jRmlsZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuY3VycmVudFN5bmNEYXRhKSB7XG5cdFx0XHRcdHRoaXMuY3VycmVudFN5bmNEYXRhLmhlYWRlci5sYXN0R2xvYmFsU3luYyA9IERhdGUubm93KCk7XG5cdFx0XHRcdGF3YWl0IHRoaXMud3JpdGVTeW5jRmlsZSh0aGlzLmN1cnJlbnRTeW5jRGF0YSk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdTeW5jRmlsZU1hbmFnZXIudXBkYXRlTGFzdFN5bmMnIH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGFsbCBzeW5jIGVudHJpZXMgZnJvbSB0aGUgc3luYyBmaWxlLlxuXHQgKi9cblx0YXN5bmMgZ2V0QWxsU3luY0VudHJpZXMoKTogUHJvbWlzZTxBcnJheTx7IGZpbGVQYXRoOiBzdHJpbmc7IHN0YXR1czogc3RyaW5nOyBsYXN0TW9kaWZpZWQ6IG51bWJlcjsgaGFzaDogc3RyaW5nIH0+PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghdGhpcy5jdXJyZW50U3luY0RhdGEpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy5yZWFkU3luY0ZpbGUoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuY3VycmVudFN5bmNEYXRhICYmIHRoaXMuY3VycmVudFN5bmNEYXRhLmhlYWRlci5maWxlU3RhdHVzZXMpIHtcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMuY3VycmVudFN5bmNEYXRhLmhlYWRlci5maWxlU3RhdHVzZXMpLm1hcCgoW2ZpbGVQYXRoLCBkYXRhXSkgPT4gKHtcblx0XHRcdFx0XHRmaWxlUGF0aCxcblx0XHRcdFx0XHRzdGF0dXM6IGRhdGEuc3RhdHVzLFxuXHRcdFx0XHRcdGxhc3RNb2RpZmllZDogZGF0YS5sYXN0TW9kaWZpZWQsXG5cdFx0XHRcdFx0aGFzaDogZGF0YS5oYXNoXG5cdFx0XHRcdH0pKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLmdldEFsbFN5bmNFbnRyaWVzJyB9KTtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQXR0ZW1wdCByZWNvdmVyeSBvcGVyYXRpb25zIHdoZW4gc3luYyBpc3N1ZXMgYXJlIGRldGVjdGVkLlxuXHQgKi9cblx0YXN5bmMgYXR0ZW1wdFJlY292ZXJ5KCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBBdHRlbXB0IHRvIHJlc3RvcmUgZnJvbSBiYWNrdXBcblx0XHRcdGNvbnN0IHJlY292ZXJlZCA9IGF3YWl0IHRoaXMucmVzdG9yZUZyb21CYWNrdXAoKTtcblx0XHRcdGlmIChyZWNvdmVyZWQpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSByZWNvdmVyZWQgZnJvbSBiYWNrdXAnKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGJhY2t1cCByZXN0b3JhdGlvbiBmYWlscywgdHJ5IHRvIHJlY3JlYXRlIHRoZSBzeW5jIGZpbGVcblx0XHRcdGNvbnNvbGUubG9nKCdCYWNrdXAgcmVzdG9yYXRpb24gZmFpbGVkLCBhdHRlbXB0aW5nIHRvIHJlY3JlYXRlIHN5bmMgZmlsZScpO1xuXHRcdFx0YXdhaXQgdGhpcy5jcmVhdGVTeW5jRmlsZSgpO1xuXG5cdFx0XHQvLyBWZXJpZnkgdGhlIG5ldyBmaWxlIGlzIHZhbGlkXG5cdFx0XHRjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgdGhpcy52YWxpZGF0ZVN5bmNGaWxlKCk7XG5cdFx0XHRyZXR1cm4gdmFsaWRhdGlvblJlc3VsdC5pc1ZhbGlkO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnU3luY0ZpbGVNYW5hZ2VyLmF0dGVtcHRSZWNvdmVyeScgfSk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG59XG4iLCAiLy8gc3JjL21vZGVscy9TeW5jTW9kZWxzLnRzXG5cbi8qKlxuICogRGVmaW5lcyB0aGUgc3RydWN0dXJlIGFuZCB0eXBlcyBmb3Igc3luYyBmaWxlIGNvb3JkaW5hdGlvblxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGRldmljZSBrbm93biBieSB0aGUgc3luYyBzeXN0ZW1cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTeW5jRGV2aWNlIHtcbiAgICBkZXZpY2VJZDogc3RyaW5nOyAgICAgICAgIC8vIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGRldmljZVxuICAgIG5hbWU6IHN0cmluZzsgICAgICAgICAgICAgLy8gVXNlci1mcmllbmRseSBkZXZpY2UgbmFtZVxuICAgIHBsYXRmb3JtOiBzdHJpbmc7ICAgICAgICAgLy8gT3BlcmF0aW5nIHN5c3RlbS9wbGF0Zm9ybVxuICAgIGxhc3RTZWVuOiBudW1iZXI7ICAgICAgICAgLy8gVGltZXN0YW1wIHdoZW4gZGV2aWNlIHdhcyBsYXN0IGFjdGl2ZVxuICAgIGxhc3RTeW5jVGltZTogbnVtYmVyOyAgICAgLy8gTGFzdCBzdWNjZXNzZnVsIGRhdGFiYXNlIHN5bmMgdGltZXN0YW1wXG4gICAgb2JzaWRpYW5WZXJzaW9uPzogc3RyaW5nOyAvLyBPYnNpZGlhbiB2ZXJzaW9uIChvcHRpb25hbClcbiAgICBwbHVnaW5WZXJzaW9uPzogc3RyaW5nOyAgIC8vIFBsdWdpbiB2ZXJzaW9uIChvcHRpb25hbClcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBvdmVyYWxsIHN5bmMgc3RhdGVcbiAqL1xuZXhwb3J0IGVudW0gU3luY1N0YXRlIHtcbiAgICBVTktOT1dOID0gJ3Vua25vd24nLFxuICAgIElOSVRJQUxJWklORyA9ICdpbml0aWFsaXppbmcnLFxuICAgIE9OTElORSA9ICdvbmxpbmUnLFxuICAgIE9GRkxJTkUgPSAnb2ZmbGluZScsXG4gICAgRVJST1IgPSAnZXJyb3InLFxuICAgIENPTkZMSUNUID0gJ2NvbmZsaWN0J1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb25uZWN0aW9uIGV2ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29ubmVjdGlvbkV2ZW50IHtcbiAgICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgICBldmVudFR5cGU6ICdjb25uZWN0ZWQnIHwgJ2Rpc2Nvbm5lY3RlZCc7XG4gICAgZGV2aWNlSWQ6IHN0cmluZztcbiAgICBkZXRhaWxzPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzeW5jIG9wZXJhdGlvbiBwZXJmb3JtZWQgZHVyaW5nIG9mZmxpbmUgbW9kZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBlbmRpbmdPcGVyYXRpb24ge1xuICAgIGlkOiBzdHJpbmc7ICAgICAgICAgICAgICAgLy8gVW5pcXVlIG9wZXJhdGlvbiBJRFxuICAgIGZpbGVJZDogc3RyaW5nOyAgICAgICAgICAgLy8gRmlsZSBwYXRoIHRoaXMgb3BlcmF0aW9uIGFmZmVjdHNcbiAgICBvcGVyYXRpb25UeXBlOiAnY3JlYXRlJyB8ICd1cGRhdGUnIHwgJ2RlbGV0ZScgfCAncmVuYW1lJztcbiAgICB0aW1lc3RhbXA6IG51bWJlcjsgICAgICAgIC8vIFdoZW4gdGhlIG9wZXJhdGlvbiBvY2N1cnJlZFxuICAgIGRldmljZUlkOiBzdHJpbmc7ICAgICAgICAgLy8gRGV2aWNlIHRoYXQgcGVyZm9ybWVkIHRoZSBvcGVyYXRpb25cbiAgICBtZXRhZGF0YT86IHsgICAgICAgICAgICAgIC8vIEFkZGl0aW9uYWwgb3BlcmF0aW9uIGRhdGFcbiAgICAgICAgb2xkUGF0aD86IHN0cmluZzsgICAgIC8vIEZvciByZW5hbWUgb3BlcmF0aW9uc1xuICAgICAgICBjb250ZW50SGFzaD86IHN0cmluZzsgLy8gRm9yIGNyZWF0ZS91cGRhdGUgb3BlcmF0aW9uc1xuICAgICAgICBsYXN0TW9kaWZpZWQ/OiBudW1iZXI7IC8vIExhc3QgbW9kaWZpZWQgdGltZXN0YW1wXG4gICAgfTtcbiAgICBzdGF0dXM6ICdwZW5kaW5nJyB8ICdwcm9jZXNzaW5nJyB8ICdlcnJvcic7XG4gICAgZXJyb3JEZXRhaWxzPzogc3RyaW5nOyAgICAvLyBFcnJvciBpbmZvcm1hdGlvbiBpZiBzdGF0dXMgaXMgJ2Vycm9yJ1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBkZXRlY3RlZCBjb25mbGljdCBiZXR3ZWVuIGRldmljZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTeW5jQ29uZmxpY3Qge1xuICAgIGlkOiBzdHJpbmc7ICAgICAgICAgICAgICAgICAgICAvLyBVbmlxdWUgY29uZmxpY3QgSURcbiAgICBmaWxlSWQ6IHN0cmluZzsgICAgICAgICAgICAgICAgLy8gRmlsZSBwYXRoIHdpdGggY29uZmxpY3RcbiAgICBkZXRlY3RlZEF0OiBudW1iZXI7ICAgICAgICAgICAgLy8gV2hlbiBjb25mbGljdCB3YXMgZGV0ZWN0ZWRcbiAgICBkZXZpY2VzOiBzdHJpbmdbXTsgICAgICAgICAgICAgLy8gRGV2aWNlIElEcyBpbnZvbHZlZCBpbiBjb25mbGljdFxuICAgIHJlc29sdXRpb25TdGF0dXM6ICdwZW5kaW5nJyB8ICdyZXNvbHZlZCc7XG4gICAgcmVzb2x1dGlvblN0cmF0ZWd5PzogJ25ld2VzdC13aW5zJyB8ICdtYW51YWwnIHwgJ2tlZXAtYm90aCc7XG4gICAgcmVzb2x2ZWRBdD86IG51bWJlcjsgICAgICAgICAgIC8vIFdoZW4gY29uZmxpY3Qgd2FzIHJlc29sdmVkXG4gICAgcmVzb2x2ZWRCeT86IHN0cmluZzsgICAgICAgICAgIC8vIERldmljZSBJRCB0aGF0IHJlc29sdmVkIHRoZSBjb25mbGljdFxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHN0cnVjdHVyZSBvZiB0aGUgc3luYyBmaWxlIFlBTUwgaGVhZGVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3luY0ZpbGVIZWFkZXIge1xuICAgIGxhc3RHbG9iYWxTeW5jOiBudW1iZXI7ICAgICAgICAgICAgIC8vIExhc3QgdGltZSBhbnkgZGV2aWNlIHN5bmNlZCBzdWNjZXNzZnVsbHlcbiAgICBzeW5jU3RhdGU6IFN5bmNTdGF0ZTsgICAgICAgICAgICAgICAvLyBDdXJyZW50IHN5bmMgc3RhdGVcbiAgICB2YXVsdElkOiBzdHJpbmc7ICAgICAgICAgICAgICAgICAgICAvLyBWYXVsdCBpZGVudGlmaWVyXG4gICAgcGx1Z2luVmVyc2lvbjogc3RyaW5nOyAgICAgICAgICAgICAgLy8gUGx1Z2luIHZlcnNpb24gdGhhdCBsYXN0IHdyb3RlIHRoaXMgZmlsZVxuICAgIGxhc3RXcml0ZXI6IHN0cmluZzsgICAgICAgICAgICAgICAgIC8vIERldmljZSBJRCB0aGF0IGxhc3Qgd3JvdGUgdGhpcyBmaWxlXG4gICAgZGV2aWNlczogUmVjb3JkPHN0cmluZywgU3luY0RldmljZT47IC8vIE1hcCBvZiBkZXZpY2UgSURzIHRvIGRldmljZSBpbmZvXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZnVsbCBzdHJ1Y3R1cmUgb2YgdGhlIHN5bmMgZmlsZVxuICogVGhpcyB3aWxsIGJlIHNlcmlhbGl6ZWQgdG8vZnJvbSBZQU1MXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3luY0ZpbGVEYXRhIHtcbiAgICBoZWFkZXI6IFN5bmNGaWxlSGVhZGVyO1xuICAgIGNvbm5lY3Rpb25FdmVudHM6IENvbm5lY3Rpb25FdmVudFtdOyAgIC8vIFJlY2VudCBjb25uZWN0aW9uIHN0YXRlIGNoYW5nZXNcbiAgICBwZW5kaW5nT3BlcmF0aW9uczogUGVuZGluZ09wZXJhdGlvbltdOyAvLyBPcGVyYXRpb25zIHF1ZXVlZCBkdXJpbmcgb2ZmbGluZSBtb2RlXG4gICAgY29uZmxpY3RzOiBTeW5jQ29uZmxpY3RbXTsgICAgICAgICAgICAvLyBEZXRlY3RlZCBzeW5jIGNvbmZsaWN0c1xuICAgIGxhc3REYXRhYmFzZUNoZWNrOiBudW1iZXI7ICAgICAgICAgICAgLy8gTGFzdCB0aW1lIGRhdGFiYXNlIGNvbm5lY3Rpdml0eSB3YXMgY2hlY2tlZFxuICAgIGRhdGFiYXNlU3RhdHVzOiAnYXZhaWxhYmxlJyB8ICd1bmF2YWlsYWJsZScgfCAndW5rbm93bic7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdmFsaWRhdGlvbiBzdGF0dXMgb2YgdGhlIHN5bmMgZmlsZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNWYWxpZGF0aW9uUmVzdWx0IHtcbiAgICBpc1ZhbGlkOiBib29sZWFuO1xuICAgIGVycm9yPzogc3RyaW5nO1xuICAgIGRldGFpbHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufVxuXG4vKipcbiAqIEVycm9yIHR5cGVzIHNwZWNpZmljIHRvIHN5bmMgb3BlcmF0aW9uc1xuICovXG5leHBvcnQgZW51bSBTeW5jRXJyb3JUeXBlIHtcbiAgICBTWU5DX0ZJTEVfTUlTU0lORyA9ICdzeW5jX2ZpbGVfbWlzc2luZycsXG4gICAgU1lOQ19GSUxFX0NPUlJVUFQgPSAnc3luY19maWxlX2NvcnJ1cHQnLFxuICAgIFNZTkNfRklMRV9PVVREQVRFRCA9ICdzeW5jX2ZpbGVfb3V0ZGF0ZWQnLFxuICAgIERFVklDRV9NSVNNQVRDSCA9ICdkZXZpY2VfbWlzbWF0Y2gnLFxuICAgIENPTkZMSUNUX0RFVEVDVEVEID0gJ2NvbmZsaWN0X2RldGVjdGVkJyxcbiAgICBEQVRBQkFTRV9VTkFWQUlMQUJMRSA9ICdkYXRhYmFzZV91bmF2YWlsYWJsZScsXG4gICAgU1lOQ19JTlRFUlJVUFRFRCA9ICdzeW5jX2ludGVycnVwdGVkJyxcbiAgICBVTktOT1dOX0VSUk9SID0gJ3Vua25vd25fZXJyb3InXG59XG5cbi8qKlxuICogRGVmYXVsdCBtYXhpbXVtIGl0ZW1zIHRvIGtlZXAgaW4gZWFjaCBoaXN0b3J5IGxpc3RcbiAqL1xuZXhwb3J0IGNvbnN0IE1BWF9DT05ORUNUSU9OX0VWRU5UUyA9IDIwO1xuZXhwb3J0IGNvbnN0IE1BWF9QRU5ESU5HX09QRVJBVElPTlMgPSAxMDA7XG5leHBvcnQgY29uc3QgTUFYX0NPTkZMSUNUUyA9IDUwO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgcGxhdGZvcm0gaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYXRmb3JtSW5mbygpOiBzdHJpbmcge1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gICAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdXaW4nKSAhPT0gLTEpIHJldHVybiAnV2luZG93cyc7XG4gICAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdNYWMnKSAhPT0gLTEpIHJldHVybiAnbWFjT1MnO1xuICAgIGlmICh1c2VyQWdlbnQuaW5kZXhPZignaVBob25lJykgIT09IC0xIHx8IHVzZXJBZ2VudC5pbmRleE9mKCdpUGFkJykgIT09IC0xKSByZXR1cm4gJ2lPUyc7XG4gICAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdBbmRyb2lkJykgIT09IC0xKSByZXR1cm4gJ0FuZHJvaWQnO1xuICAgIGlmICh1c2VyQWdlbnQuaW5kZXhPZignTGludXgnKSAhPT0gLTEpIHJldHVybiAnTGludXgnO1xuXG4gICAgcmV0dXJuICdVbmtub3duJztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGVtcHR5IHN5bmMgZmlsZSBkYXRhIHN0cnVjdHVyZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW1wdHlTeW5jRmlsZURhdGEoXG4gICAgdmF1bHRJZDogc3RyaW5nLFxuICAgIGRldmljZUlkOiBzdHJpbmcsXG4gICAgZGV2aWNlTmFtZTogc3RyaW5nLFxuICAgIHBsdWdpblZlcnNpb246IHN0cmluZ1xuKTogU3luY0ZpbGVEYXRhIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gZ2V0UGxhdGZvcm1JbmZvKCk7XG5cbiAgICBjb25zdCBkZXZpY2U6IFN5bmNEZXZpY2UgPSB7XG4gICAgICAgIGRldmljZUlkLFxuICAgICAgICBuYW1lOiBkZXZpY2VOYW1lLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgbGFzdFNlZW46IG5vdyxcbiAgICAgICAgbGFzdFN5bmNUaW1lOiBub3dcbiAgICB9O1xuXG4gICAgY29uc3QgZGV2aWNlczogUmVjb3JkPHN0cmluZywgU3luY0RldmljZT4gPSB7fTtcbiAgICBkZXZpY2VzW2RldmljZUlkXSA9IGRldmljZTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlcjoge1xuICAgICAgICAgICAgbGFzdEdsb2JhbFN5bmM6IG5vdyxcbiAgICAgICAgICAgIHN5bmNTdGF0ZTogU3luY1N0YXRlLklOSVRJQUxJWklORyxcbiAgICAgICAgICAgIHZhdWx0SWQsXG4gICAgICAgICAgICBwbHVnaW5WZXJzaW9uLFxuICAgICAgICAgICAgbGFzdFdyaXRlcjogZGV2aWNlSWQsXG4gICAgICAgICAgICBkZXZpY2VzXG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3Rpb25FdmVudHM6IFtdLFxuICAgICAgICBwZW5kaW5nT3BlcmF0aW9uczogW10sXG4gICAgICAgIGNvbmZsaWN0czogW10sXG4gICAgICAgIGxhc3REYXRhYmFzZUNoZWNrOiBub3csXG4gICAgICAgIGRhdGFiYXNlU3RhdHVzOiAndW5rbm93bidcbiAgICB9O1xufVxuXG4vKipcbiAqIFRyaW1zIGhpc3RvcnkgYXJyYXlzIHRvIGtlZXAgdGhlbSBhdCBhIHJlYXNvbmFibGUgc2l6ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVN5bmNIaXN0b3J5QXJyYXlzKGRhdGE6IFN5bmNGaWxlRGF0YSk6IFN5bmNGaWxlRGF0YSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgY29ubmVjdGlvbkV2ZW50czogZGF0YS5jb25uZWN0aW9uRXZlbnRzLnNsaWNlKC1NQVhfQ09OTkVDVElPTl9FVkVOVFMpLFxuICAgICAgICBwZW5kaW5nT3BlcmF0aW9uczogZGF0YS5wZW5kaW5nT3BlcmF0aW9ucy5zbGljZSgtTUFYX1BFTkRJTkdfT1BFUkFUSU9OUyksXG4gICAgICAgIGNvbmZsaWN0czogZGF0YS5jb25mbGljdHMuc2xpY2UoLU1BWF9DT05GTElDVFMpXG4gICAgfTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGRldmljZSBpbmZvcm1hdGlvbiBpbiB0aGUgc3luYyBmaWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVEZXZpY2VJblN5bmNGaWxlKFxuICAgIGRhdGE6IFN5bmNGaWxlRGF0YSxcbiAgICBkZXZpY2VJZDogc3RyaW5nLFxuICAgIGRldmljZU5hbWU6IHN0cmluZyxcbiAgICBwbHVnaW5WZXJzaW9uPzogc3RyaW5nXG4pOiBTeW5jRmlsZURhdGEge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcGxhdGZvcm0gPSBnZXRQbGF0Zm9ybUluZm8oKTtcblxuICAgIC8vIERlZXAgY2xvbmUgdGhlIGRhdGEgdG8gYXZvaWQgbXV0YXRpb25zXG4gICAgY29uc3QgbmV3RGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpIGFzIFN5bmNGaWxlRGF0YTtcblxuICAgIGlmICghbmV3RGF0YS5oZWFkZXIuZGV2aWNlcykge1xuICAgICAgICBuZXdEYXRhLmhlYWRlci5kZXZpY2VzID0ge307XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIG9yIGNyZWF0ZSBkZXZpY2UgZW50cnlcbiAgICBpZiAobmV3RGF0YS5oZWFkZXIuZGV2aWNlc1tkZXZpY2VJZF0pIHtcbiAgICAgICAgbmV3RGF0YS5oZWFkZXIuZGV2aWNlc1tkZXZpY2VJZF0gPSB7XG4gICAgICAgICAgICAuLi5uZXdEYXRhLmhlYWRlci5kZXZpY2VzW2RldmljZUlkXSxcbiAgICAgICAgICAgIG5hbWU6IGRldmljZU5hbWUsXG4gICAgICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgICAgIGxhc3RTZWVuOiBub3csXG4gICAgICAgICAgICBwbHVnaW5WZXJzaW9uOiBwbHVnaW5WZXJzaW9uIHx8IG5ld0RhdGEuaGVhZGVyLmRldmljZXNbZGV2aWNlSWRdLnBsdWdpblZlcnNpb25cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuZXdEYXRhLmhlYWRlci5kZXZpY2VzW2RldmljZUlkXSA9IHtcbiAgICAgICAgICAgIGRldmljZUlkLFxuICAgICAgICAgICAgbmFtZTogZGV2aWNlTmFtZSxcbiAgICAgICAgICAgIHBsYXRmb3JtLFxuICAgICAgICAgICAgbGFzdFNlZW46IG5vdyxcbiAgICAgICAgICAgIGxhc3RTeW5jVGltZTogbm93LFxuICAgICAgICAgICAgcGx1Z2luVmVyc2lvblxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG5ld0RhdGEuaGVhZGVyLmxhc3RXcml0ZXIgPSBkZXZpY2VJZDtcbiAgICBpZiAocGx1Z2luVmVyc2lvbikge1xuICAgICAgICBuZXdEYXRhLmhlYWRlci5wbHVnaW5WZXJzaW9uID0gcGx1Z2luVmVyc2lvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RGF0YTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgY29ubmVjdGlvbiBldmVudCB0byB0aGUgc3luYyBmaWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDb25uZWN0aW9uRXZlbnQoXG4gICAgZGF0YTogU3luY0ZpbGVEYXRhLFxuICAgIGV2ZW50VHlwZTogJ2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJyxcbiAgICBkZXZpY2VJZDogc3RyaW5nLFxuICAgIGRldGFpbHM/OiBzdHJpbmdcbik6IFN5bmNGaWxlRGF0YSB7XG4gICAgY29uc3QgbmV3RGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpIGFzIFN5bmNGaWxlRGF0YTtcblxuICAgIG5ld0RhdGEuY29ubmVjdGlvbkV2ZW50cy5wdXNoKHtcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBldmVudFR5cGUsXG4gICAgICAgIGRldmljZUlkLFxuICAgICAgICBkZXRhaWxzXG4gICAgfSk7XG5cbiAgICAvLyBLZWVwIGFycmF5IHNpemUgbWFuYWdlYWJsZVxuICAgIGlmIChuZXdEYXRhLmNvbm5lY3Rpb25FdmVudHMubGVuZ3RoID4gTUFYX0NPTk5FQ1RJT05fRVZFTlRTKSB7XG4gICAgICAgIG5ld0RhdGEuY29ubmVjdGlvbkV2ZW50cyA9IG5ld0RhdGEuY29ubmVjdGlvbkV2ZW50cy5zbGljZSgtTUFYX0NPTk5FQ1RJT05fRVZFTlRTKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RGF0YTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgcGVuZGluZyBvcGVyYXRpb24gdG8gdGhlIHN5bmMgZmlsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUGVuZGluZ09wZXJhdGlvbihcbiAgICBkYXRhOiBTeW5jRmlsZURhdGEsXG4gICAgZmlsZUlkOiBzdHJpbmcsXG4gICAgb3BlcmF0aW9uVHlwZTogJ2NyZWF0ZScgfCAndXBkYXRlJyB8ICdkZWxldGUnIHwgJ3JlbmFtZScsXG4gICAgZGV2aWNlSWQ6IHN0cmluZyxcbiAgICBtZXRhZGF0YT86IHtcbiAgICAgICAgb2xkUGF0aD86IHN0cmluZztcbiAgICAgICAgY29udGVudEhhc2g/OiBzdHJpbmc7XG4gICAgICAgIGxhc3RNb2RpZmllZD86IG51bWJlcjtcbiAgICB9XG4pOiBTeW5jRmlsZURhdGEge1xuICAgIGNvbnN0IG5ld0RhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpKSBhcyBTeW5jRmlsZURhdGE7XG5cbiAgICBuZXdEYXRhLnBlbmRpbmdPcGVyYXRpb25zLnB1c2goe1xuICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcbiAgICAgICAgZmlsZUlkLFxuICAgICAgICBvcGVyYXRpb25UeXBlLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIGRldmljZUlkLFxuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgc3RhdHVzOiAncGVuZGluZydcbiAgICB9KTtcblxuICAgIC8vIEtlZXAgYXJyYXkgc2l6ZSBtYW5hZ2VhYmxlXG4gICAgaWYgKG5ld0RhdGEucGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoID4gTUFYX1BFTkRJTkdfT1BFUkFUSU9OUykge1xuICAgICAgICBuZXdEYXRhLnBlbmRpbmdPcGVyYXRpb25zID0gbmV3RGF0YS5wZW5kaW5nT3BlcmF0aW9ucy5zbGljZSgtTUFYX1BFTkRJTkdfT1BFUkFUSU9OUyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0RhdGE7XG59XG5cbi8qKlxuICogQWRkcyBhIHN5bmMgY29uZmxpY3QgdG8gdGhlIHN5bmMgZmlsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkU3luY0NvbmZsaWN0KFxuICAgIGRhdGE6IFN5bmNGaWxlRGF0YSxcbiAgICBmaWxlSWQ6IHN0cmluZyxcbiAgICBkZXZpY2VzOiBzdHJpbmdbXVxuKTogU3luY0ZpbGVEYXRhIHtcbiAgICBjb25zdCBuZXdEYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSkgYXMgU3luY0ZpbGVEYXRhO1xuXG4gICAgbmV3RGF0YS5jb25mbGljdHMucHVzaCh7XG4gICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgICBmaWxlSWQsXG4gICAgICAgIGRldGVjdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgIGRldmljZXMsXG4gICAgICAgIHJlc29sdXRpb25TdGF0dXM6ICdwZW5kaW5nJ1xuICAgIH0pO1xuXG4gICAgLy8gS2VlcCBhcnJheSBzaXplIG1hbmFnZWFibGVcbiAgICBpZiAobmV3RGF0YS5jb25mbGljdHMubGVuZ3RoID4gTUFYX0NPTkZMSUNUUykge1xuICAgICAgICBuZXdEYXRhLmNvbmZsaWN0cyA9IG5ld0RhdGEuY29uZmxpY3RzLnNsaWNlKC1NQVhfQ09ORkxJQ1RTKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc3luYyBzdGF0ZSB0byBpbmRpY2F0ZSBjb25mbGljdFxuICAgIG5ld0RhdGEuaGVhZGVyLnN5bmNTdGF0ZSA9IFN5bmNTdGF0ZS5DT05GTElDVDtcblxuICAgIHJldHVybiBuZXdEYXRhO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGRhdGFiYXNlIHN0YXR1cyBpbiB0aGUgc3luYyBmaWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVEYXRhYmFzZVN0YXR1cyhcbiAgICBkYXRhOiBTeW5jRmlsZURhdGEsXG4gICAgc3RhdHVzOiAnYXZhaWxhYmxlJyB8ICd1bmF2YWlsYWJsZScgfCAndW5rbm93bidcbik6IFN5bmNGaWxlRGF0YSB7XG4gICAgY29uc3QgbmV3RGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpIGFzIFN5bmNGaWxlRGF0YTtcblxuICAgIG5ld0RhdGEuZGF0YWJhc2VTdGF0dXMgPSBzdGF0dXM7XG4gICAgbmV3RGF0YS5sYXN0RGF0YWJhc2VDaGVjayA9IERhdGUubm93KCk7XG5cbiAgICAvLyBVcGRhdGUgc3luYyBzdGF0ZSBiYXNlZCBvbiBkYXRhYmFzZSBzdGF0dXNcbiAgICBpZiAoc3RhdHVzID09PSAndW5hdmFpbGFibGUnKSB7XG4gICAgICAgIG5ld0RhdGEuaGVhZGVyLnN5bmNTdGF0ZSA9IFN5bmNTdGF0ZS5PRkZMSU5FO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSAnYXZhaWxhYmxlJykge1xuICAgICAgICBuZXdEYXRhLmhlYWRlci5zeW5jU3RhdGUgPSBTeW5jU3RhdGUuT05MSU5FO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdEYXRhO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGxhc3Qgc3luYyB0aW1lIGZvciBhIGRldmljZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlRGV2aWNlU3luY1RpbWUoXG4gICAgZGF0YTogU3luY0ZpbGVEYXRhLFxuICAgIGRldmljZUlkOiBzdHJpbmdcbik6IFN5bmNGaWxlRGF0YSB7XG4gICAgY29uc3QgbmV3RGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpIGFzIFN5bmNGaWxlRGF0YTtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgaWYgKG5ld0RhdGEuaGVhZGVyLmRldmljZXMgJiYgbmV3RGF0YS5oZWFkZXIuZGV2aWNlc1tkZXZpY2VJZF0pIHtcbiAgICAgICAgbmV3RGF0YS5oZWFkZXIuZGV2aWNlc1tkZXZpY2VJZF0ubGFzdFN5bmNUaW1lID0gbm93O1xuICAgICAgICBuZXdEYXRhLmhlYWRlci5kZXZpY2VzW2RldmljZUlkXS5sYXN0U2VlbiA9IG5vdztcbiAgICAgICAgbmV3RGF0YS5oZWFkZXIubGFzdEdsb2JhbFN5bmMgPSBub3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0RhdGE7XG59XG4iLCAiLy8gc3JjL3V0aWxzL0Vycm9ySGFuZGxlci50c1xuaW1wb3J0IHsgRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IgfSBmcm9tICcuLi9tb2RlbHMvRG9jdW1lbnRDaHVuayc7XG5pbXBvcnQgeyBUYXNrUHJvY2Vzc2luZ0Vycm9yIH0gZnJvbSAnLi4vbW9kZWxzL1Byb2Nlc3NpbmdUYXNrJztcbmltcG9ydCB7IFN5bmNFcnJvclR5cGUgfSBmcm9tICcuLi9tb2RlbHMvU3luY01vZGVscyc7XG5pbXBvcnQgeyBEZWJ1Z1NldHRpbmdzIH0gZnJvbSAnLi4vc2V0dGluZ3MvU2V0dGluZ3MnO1xuaW1wb3J0IHsgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgUG9zdGdyZXN0RXJyb3IgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yQ29udGV4dCB7XG5cdGNvbnRleHQ6IHN0cmluZztcblx0dGFza0lkPzogc3RyaW5nO1xuXHR0YXNrVHlwZT86IHN0cmluZztcblx0bWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yTG9nIHtcblx0dGltZXN0YW1wOiBudW1iZXI7XG5cdGVycm9yOiBFcnJvcjtcblx0Y29udGV4dDogRXJyb3JDb250ZXh0O1xuXHRsZXZlbDogJ2Vycm9yJyB8ICd3YXJuJyB8ICdpbmZvJyB8ICdkZWJ1Zyc7XG5cdGhhbmRsZWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3VwYWJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29kZTogc3RyaW5nO1xuXHRkZXRhaWxzOiBzdHJpbmc7XG5cdGhpbnQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3luY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHR0eXBlOiBTeW5jRXJyb3JUeXBlO1xuXHRkZXRhaWxzPzogUmVjb3JkPHN0cmluZywgYW55Pjtcblx0ZGV2aWNlSWQ/OiBzdHJpbmc7XG5cdHJlY292ZXJhYmxlOiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgRXJyb3JIYW5kbGVyIHtcblx0cHJpdmF0ZSBlcnJvckxvZ3M6IEVycm9yTG9nW10gPSBbXTtcblx0cHJpdmF0ZSByZWFkb25seSBtYXhMb2dzOiBudW1iZXIgPSAxMDA7XG5cdHByaXZhdGUgc2V0dGluZ3M6IERlYnVnU2V0dGluZ3M7XG5cdHByaXZhdGUgbG9nRmlsZVBhdGg/OiBzdHJpbmc7XG5cblx0Y29uc3RydWN0b3Ioc2V0dGluZ3M6IERlYnVnU2V0dGluZ3MsIHZhdWx0UGF0aD86IHN0cmluZykge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcblx0XHRpZiAoc2V0dGluZ3MubG9nVG9GaWxlICYmIHZhdWx0UGF0aCkge1xuXHRcdFx0dGhpcy5sb2dGaWxlUGF0aCA9IGAke3ZhdWx0UGF0aH0vLm9ic2lkaWFuL21pbmQtbWF0cml4LmxvZ2A7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgZXJyb3JzIHdpdGggY29udGV4dCBhbmQgb3B0aW9uYWwgcmVjb3ZlcnkuXG5cdCAqL1xuXHRoYW5kbGVFcnJvcihlcnJvcjogYW55LCBjb250ZXh0OiBFcnJvckNvbnRleHQsIGxldmVsOiAnZXJyb3InIHwgJ3dhcm4nIHwgJ2luZm8nIHwgJ2RlYnVnJyA9ICdlcnJvcicpOiB2b2lkIHtcblx0XHRpZiAoIXRoaXMuc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRjb25zdCBlcnJvckxvZzogRXJyb3JMb2cgPSB7XG5cdFx0XHR0aW1lc3RhbXA6IERhdGUubm93KCksXG5cdFx0XHRlcnJvcjogdGhpcy5ub3JtYWxpemVFcnJvcihlcnJvciksXG5cdFx0XHRjb250ZXh0LFxuXHRcdFx0bGV2ZWwsXG5cdFx0XHRoYW5kbGVkOiBmYWxzZVxuXHRcdH07XG5cdFx0dGhpcy5lcnJvckxvZ3MudW5zaGlmdChlcnJvckxvZyk7XG5cdFx0aWYgKHRoaXMuZXJyb3JMb2dzLmxlbmd0aCA+IHRoaXMubWF4TG9ncykge1xuXHRcdFx0dGhpcy5lcnJvckxvZ3MucG9wKCk7XG5cdFx0fVxuXHRcdC8vIFNob3cgYSBub3RpY2UgZm9yIGltcG9ydGFudCBlcnJvcnMuXG5cdFx0aWYgKGxldmVsID09PSAnZXJyb3InIHx8IChsZXZlbCA9PT0gJ3dhcm4nICYmIHRoaXMuc2V0dGluZ3MubG9nTGV2ZWwgPT09ICdkZWJ1ZycpKSB7XG5cdFx0XHRuZXcgTm90aWNlKGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuXHRcdH1cblx0XHQvLyBEZWJ1ZyBsb2dnaW5nLlxuXHRcdGlmICh0aGlzLnNldHRpbmdzLmVuYWJsZURlYnVnTG9ncykge1xuXHRcdFx0Y29uc29sZS5ncm91cChgWyR7bGV2ZWwudG9VcHBlckNhc2UoKX1dICR7Y29udGV4dC5jb250ZXh0fWApO1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgZGV0YWlsczonLCBlcnJvcik7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdDb250ZXh0OicsIGNvbnRleHQpO1xuXHRcdFx0aWYgKGVycm9yLnN0YWNrKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1N0YWNrIHRyYWNlOicsIGVycm9yLnN0YWNrKTtcblx0XHRcdH1cblx0XHRcdGNvbnNvbGUuZ3JvdXBFbmQoKTtcblx0XHR9XG5cdFx0Ly8gRmlsZSBsb2dnaW5nIGlmIGVuYWJsZWQuXG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MubG9nVG9GaWxlICYmIHRoaXMubG9nRmlsZVBhdGgpIHtcblx0XHRcdHRoaXMud3JpdGVUb0xvZ0ZpbGUoZXJyb3JMb2cpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuZCBoYW5kbGVzIGEgc3luYyBlcnJvci5cblx0ICovXG5cdGhhbmRsZVN5bmNFcnJvcihcblx0XHR0eXBlOiBTeW5jRXJyb3JUeXBlLFxuXHRcdG1lc3NhZ2U6IHN0cmluZyxcblx0XHRjb250ZXh0OiBFcnJvckNvbnRleHQsXG5cdFx0ZGV0YWlscz86IFJlY29yZDxzdHJpbmcsIGFueT4sXG5cdFx0ZGV2aWNlSWQ/OiBzdHJpbmcsXG5cdFx0cmVjb3ZlcmFibGU6IGJvb2xlYW4gPSB0cnVlXG5cdCk6IFN5bmNFcnJvciB7XG5cdFx0Y29uc3QgZXJyb3I6IFN5bmNFcnJvciA9IHtcblx0XHRcdG5hbWU6ICdTeW5jRXJyb3InLFxuXHRcdFx0bWVzc2FnZSxcblx0XHRcdHR5cGUsXG5cdFx0XHRkZXRhaWxzLFxuXHRcdFx0ZGV2aWNlSWQsXG5cdFx0XHRyZWNvdmVyYWJsZSxcblx0XHRcdHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFja1xuXHRcdH07XG5cdFx0dGhpcy5oYW5kbGVFcnJvcihlcnJvciwgY29udGV4dCwgcmVjb3ZlcmFibGUgPyAnd2FybicgOiAnZXJyb3InKTtcblx0XHRyZXR1cm4gZXJyb3I7XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBjb25uZWN0aW9uIGVycm9ycyBzcGVjaWZpY2FsbHkgZm9yIHN5bmMgb3BlcmF0aW9ucy5cblx0ICovXG5cdGhhbmRsZUNvbm5lY3Rpb25FcnJvcihlcnJvcjogYW55LCBjb250ZXh0OiBzdHJpbmcsIGRldmljZUlkPzogc3RyaW5nKTogdm9pZCB7XG5cdFx0bGV0IHN5bmNFcnJvcjogU3luY0Vycm9yO1xuXHRcdGlmIChlcnJvciAmJiBlcnJvci50eXBlICYmIE9iamVjdC52YWx1ZXMoU3luY0Vycm9yVHlwZSkuaW5jbHVkZXMoZXJyb3IudHlwZSBhcyBTeW5jRXJyb3JUeXBlKSkge1xuXHRcdFx0c3luY0Vycm9yID0gZXJyb3IgYXMgU3luY0Vycm9yO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzeW5jRXJyb3IgPSB7XG5cdFx0XHRcdG5hbWU6ICdTeW5jRXJyb3InLFxuXHRcdFx0XHRtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdEYXRhYmFzZSBjb25uZWN0aW9uIGVycm9yJyxcblx0XHRcdFx0dHlwZTogU3luY0Vycm9yVHlwZS5EQVRBQkFTRV9VTkFWQUlMQUJMRSxcblx0XHRcdFx0ZGV0YWlsczogeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9LFxuXHRcdFx0XHRkZXZpY2VJZCxcblx0XHRcdFx0cmVjb3ZlcmFibGU6IHRydWUsXG5cdFx0XHRcdHN0YWNrOiBlcnJvci5zdGFjayB8fCBuZXcgRXJyb3IoKS5zdGFja1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0dGhpcy5oYW5kbGVFcnJvcihzeW5jRXJyb3IsIHsgY29udGV4dCB9LCAnd2FybicpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZXJyb3IgbGV2ZWwgc2hvdWxkIGJlIGxvZ2dlZC5cblx0ICovXG5cdHByaXZhdGUgc2hvdWxkTG9nKGxldmVsOiAnZXJyb3InIHwgJ3dhcm4nIHwgJ2luZm8nIHwgJ2RlYnVnJyk6IGJvb2xlYW4ge1xuXHRcdGNvbnN0IGxldmVscyA9IHsgZXJyb3I6IDAsIHdhcm46IDEsIGluZm86IDIsIGRlYnVnOiAzIH07XG5cdFx0cmV0dXJuIGxldmVsc1tsZXZlbF0gPD0gbGV2ZWxzW3RoaXMuc2V0dGluZ3MubG9nTGV2ZWxdO1xuXHR9XG5cblx0LyoqXG5cdCAqIE5vcm1hbGl6ZXMgZGlmZmVyZW50IGVycm9yIGZvcm1hdHMuXG5cdCAqL1xuXHRwcml2YXRlIG5vcm1hbGl6ZUVycm9yKGVycm9yOiBhbnkpOiBFcnJvciB7XG5cdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiBlcnJvcjtcblx0XHR9XG5cdFx0Ly8gSGFuZGxlIFN5bmMgZXJyb3JzLlxuXHRcdGlmIChlcnJvciAmJiBlcnJvci50eXBlICYmIE9iamVjdC52YWx1ZXMoU3luY0Vycm9yVHlwZSkuaW5jbHVkZXMoZXJyb3IudHlwZSBhcyBTeW5jRXJyb3JUeXBlKSkge1xuXHRcdFx0Y29uc3Qgc3luY0Vycm9yID0gbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UgfHwgJ1N5bmMgZXJyb3InKTtcblx0XHRcdHN5bmNFcnJvci5uYW1lID0gJ1N5bmNFcnJvcic7XG5cdFx0XHRPYmplY3QuYXNzaWduKHN5bmNFcnJvciwgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIHN5bmNFcnJvcjtcblx0XHR9XG5cdFx0Ly8gSGFuZGxlIFN1cGFiYXNlIGVycm9ycy5cblx0XHRpZiAodGhpcy5pc1N1cGFiYXNlRXJyb3IoZXJyb3IpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEVycm9yKGBEYXRhYmFzZSBlcnJvciAoJHtlcnJvci5jb2RlfSk6ICR7ZXJyb3IubWVzc2FnZX0ke2Vycm9yLmhpbnQgPyBgIC0gJHtlcnJvci5oaW50fWAgOiAnJ31gKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBuZXcgRXJyb3IoZXJyb3IpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Y29uc3QgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InO1xuXHRcdFx0Y29uc3Qgbm9ybWFsaXplZEVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHRcdFx0T2JqZWN0LmFzc2lnbihub3JtYWxpemVkRXJyb3IsIGVycm9yKTtcblx0XHRcdHJldHVybiBub3JtYWxpemVkRXJyb3I7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgRXJyb3IoJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUeXBlIGd1YXJkIGZvciBTdXBhYmFzZSBlcnJvcnMuXG5cdCAqL1xuXHRwcml2YXRlIGlzU3VwYWJhc2VFcnJvcihlcnJvcjogYW55KTogZXJyb3IgaXMgUG9zdGdyZXN0RXJyb3Ige1xuXHRcdHJldHVybiBlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmICdjb2RlJyBpbiBlcnJvciAmJiAnZGV0YWlscycgaW4gZXJyb3I7XG5cdH1cblxuXHQvKipcblx0ICogVHlwZSBndWFyZCBmb3IgU3luYyBlcnJvcnMuXG5cdCAqL1xuXHRpc1N5bmNFcnJvcihlcnJvcjogYW55KTogZXJyb3IgaXMgU3luY0Vycm9yIHtcblx0XHRyZXR1cm4gZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiAndHlwZScgaW4gZXJyb3IgJiYgT2JqZWN0LnZhbHVlcyhTeW5jRXJyb3JUeXBlKS5pbmNsdWRlcyhlcnJvci50eXBlIGFzIFN5bmNFcnJvclR5cGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNob3dzIGFuIGFwcHJvcHJpYXRlIG5vdGlmaWNhdGlvbiBiYXNlZCBvbiBlcnJvciB0eXBlLlxuXHQgKi9cblx0cHJpdmF0ZSBzaG93RXJyb3JOb3RpZmljYXRpb24oZXJyb3I6IGFueSk6IHZvaWQge1xuXHRcdGxldCBtZXNzYWdlID0gJ0FuIGVycm9yIG9jY3VycmVkJztcblx0XHRsZXQgZHVyYXRpb24gPSA0MDAwO1xuXHRcdGlmICh0aGlzLmlzU3luY0Vycm9yKGVycm9yKSkge1xuXHRcdFx0c3dpdGNoKGVycm9yLnR5cGUpIHtcblx0XHRcdFx0Y2FzZSBTeW5jRXJyb3JUeXBlLlNZTkNfRklMRV9NSVNTSU5HOlxuXHRcdFx0XHRcdG1lc3NhZ2UgPSAnU3luYyBmaWxlIGlzIG1pc3NpbmcuIFdpbGwgYXR0ZW1wdCB0byByZWNyZWF0ZS4nO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFN5bmNFcnJvclR5cGUuU1lOQ19GSUxFX0NPUlJVUFQ6XG5cdFx0XHRcdFx0bWVzc2FnZSA9ICdTeW5jIGZpbGUgaXMgY29ycnVwdGVkLiBXaWxsIGF0dGVtcHQgdG8gcmVwYWlyLic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgU3luY0Vycm9yVHlwZS5ERVZJQ0VfTUlTTUFUQ0g6XG5cdFx0XHRcdFx0bWVzc2FnZSA9ICdEZXZpY2UgaWRlbnRpZmljYXRpb24gaXNzdWUuIENoZWNrIHBsdWdpbiBzZXR0aW5ncy4nO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFN5bmNFcnJvclR5cGUuQ09ORkxJQ1RfREVURUNURUQ6XG5cdFx0XHRcdFx0bWVzc2FnZSA9ICdTeW5jIGNvbmZsaWN0IGRldGVjdGVkLiBDaGVjayBzeW5jIHN0YXR1cyBmb3IgZGV0YWlscy4nO1xuXHRcdFx0XHRcdGR1cmF0aW9uID0gNjAwMDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBTeW5jRXJyb3JUeXBlLkRBVEFCQVNFX1VOQVZBSUxBQkxFOlxuXHRcdFx0XHRcdG1lc3NhZ2UgPSAnRGF0YWJhc2UgY29ubmVjdGlvbiB1bmF2YWlsYWJsZS4gT3BlcmF0aW5nIGluIG9mZmxpbmUgbW9kZS4nO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFN5bmNFcnJvclR5cGUuU1lOQ19JTlRFUlJVUFRFRDpcblx0XHRcdFx0XHRtZXNzYWdlID0gJ1N5bmMgb3BlcmF0aW9uIHdhcyBpbnRlcnJ1cHRlZC4gV2lsbCByZXRyeS4nO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdG1lc3NhZ2UgPSBgU3luYyBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLmlzU3VwYWJhc2VFcnJvcihlcnJvcikpIHtcblx0XHRcdHN3aXRjaCAoZXJyb3IuY29kZSkge1xuXHRcdFx0XHRjYXNlICc0MlAwMSc6XG5cdFx0XHRcdFx0bWVzc2FnZSA9ICdEYXRhYmFzZSB0YWJsZSBub3QgZm91bmQuIFBsZWFzZSBydW4gc2V0dXAgU1FMLic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJzQyNTAxJzpcblx0XHRcdFx0XHRtZXNzYWdlID0gJ0luc3VmZmljaWVudCBkYXRhYmFzZSBwZXJtaXNzaW9ucy4nO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICcyMzUwNSc6XG5cdFx0XHRcdFx0bWVzc2FnZSA9ICdEdXBsaWNhdGUgZW50cnkgZm91bmQuJztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRtZXNzYWdlID0gYERhdGFiYXNlIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YDtcblx0XHRcdH1cblx0XHRcdGR1cmF0aW9uID0gNjAwMDtcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLkNIVU5LSU5HX0VSUk9SKSB7XG5cdFx0XHRtZXNzYWdlID0gJ0Vycm9yIHNwbGl0dGluZyBkb2N1bWVudCBpbnRvIGNodW5rcyc7XG5cdFx0fSBlbHNlIGlmIChlcnJvci50eXBlID09PSBEb2N1bWVudFByb2Nlc3NpbmdFcnJvci5FTUJFRERJTkdfRVJST1IpIHtcblx0XHRcdG1lc3NhZ2UgPSAnRXJyb3IgZ2VuZXJhdGluZyBlbWJlZGRpbmdzJztcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLkRBVEFCQVNFX0VSUk9SKSB7XG5cdFx0XHRtZXNzYWdlID0gJ0RhdGFiYXNlIG9wZXJhdGlvbiBmYWlsZWQnO1xuXHRcdH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gRG9jdW1lbnRQcm9jZXNzaW5nRXJyb3IuSU5WQUxJRF9NRVRBREFUQSkge1xuXHRcdFx0bWVzc2FnZSA9ICdJbnZhbGlkIGRvY3VtZW50IG1ldGFkYXRhJztcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLkZJTEVfQUNDRVNTX0VSUk9SKSB7XG5cdFx0XHRtZXNzYWdlID0gJ0Vycm9yIGFjY2Vzc2luZyBmaWxlJztcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IERvY3VtZW50UHJvY2Vzc2luZ0Vycm9yLllBTUxfUEFSU0VfRVJST1IpIHtcblx0XHRcdG1lc3NhZ2UgPSAnRXJyb3IgcGFyc2luZyBZQU1MIGZyb250IG1hdHRlcic7XG5cdFx0fSBlbHNlIGlmIChlcnJvci50eXBlID09PSBEb2N1bWVudFByb2Nlc3NpbmdFcnJvci5WRUNUT1JfRVhURU5TSU9OX0VSUk9SKSB7XG5cdFx0XHRtZXNzYWdlID0gJ1ZlY3RvciBleHRlbnNpb24gbm90IGF2YWlsYWJsZSc7XG5cdFx0fSBlbHNlIGlmIChlcnJvci50eXBlID09PSBEb2N1bWVudFByb2Nlc3NpbmdFcnJvci5TWU5DX0VSUk9SKSB7XG5cdFx0XHRtZXNzYWdlID0gJ1N5bmMgb3BlcmF0aW9uIGZhaWxlZCc7XG5cdFx0fSBlbHNlIGlmIChlcnJvci50eXBlID09PSBUYXNrUHJvY2Vzc2luZ0Vycm9yLlFVRVVFX0ZVTEwpIHtcblx0XHRcdG1lc3NhZ2UgPSAnVGFzayBxdWV1ZSBpcyBmdWxsJztcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IFRhc2tQcm9jZXNzaW5nRXJyb3IuVEFTS19USU1FT1VUKSB7XG5cdFx0XHRtZXNzYWdlID0gJ1Rhc2sgdGltZWQgb3V0Jztcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IFRhc2tQcm9jZXNzaW5nRXJyb3IuVEFTS19DQU5DRUxMRUQpIHtcblx0XHRcdG1lc3NhZ2UgPSAnVGFzayB3YXMgY2FuY2VsbGVkJztcblx0XHR9IGVsc2UgaWYgKGVycm9yLnR5cGUgPT09IFRhc2tQcm9jZXNzaW5nRXJyb3IuTUFYX1JFVFJJRVNfRVhDRUVERUQpIHtcblx0XHRcdG1lc3NhZ2UgPSAnTWF4aW11bSByZXRyeSBhdHRlbXB0cyBleGNlZWRlZCc7XG5cdFx0fSBlbHNlIGlmIChlcnJvci50eXBlID09PSBUYXNrUHJvY2Vzc2luZ0Vycm9yLklOVkFMSURfVEFTS19TVEFURSkge1xuXHRcdFx0bWVzc2FnZSA9ICdJbnZhbGlkIHRhc2sgc3RhdGUnO1xuXHRcdH0gZWxzZSBpZiAoZXJyb3IudHlwZSA9PT0gVGFza1Byb2Nlc3NpbmdFcnJvci5UQVNLX05PVF9GT1VORCkge1xuXHRcdFx0bWVzc2FnZSA9ICdUYXNrIG5vdCBmb3VuZCc7XG5cdFx0fVxuXHRcdGlmIChlcnJvci5tZXNzYWdlICYmICF0aGlzLmlzU3luY0Vycm9yKGVycm9yKSkge1xuXHRcdFx0bWVzc2FnZSA9IGAke21lc3NhZ2V9OiAke2Vycm9yLm1lc3NhZ2V9YDtcblx0XHR9XG5cdFx0bmV3IE5vdGljZShtZXNzYWdlLCBkdXJhdGlvbik7XG5cdH1cblxuXHQvKipcblx0ICogV3JpdGVzIGVycm9yIGxvZyB0byBmaWxlLlxuXHQgKi9cblx0cHJpdmF0ZSB3cml0ZVRvTG9nRmlsZShsb2c6IEVycm9yTG9nKTogdm9pZCB7XG5cdFx0aWYgKCF0aGlzLmxvZ0ZpbGVQYXRoKSByZXR1cm47XG5cdFx0Y29uc3QgbG9nRW50cnkgPSB7XG5cdFx0XHR0aW1lc3RhbXA6IG5ldyBEYXRlKGxvZy50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCksXG5cdFx0XHRsZXZlbDogbG9nLmxldmVsLnRvVXBwZXJDYXNlKCksXG5cdFx0XHRjb250ZXh0OiBsb2cuY29udGV4dC5jb250ZXh0LFxuXHRcdFx0ZXJyb3I6IGxvZy5lcnJvci5tZXNzYWdlLFxuXHRcdFx0c3RhY2s6IGxvZy5lcnJvci5zdGFjayxcblx0XHRcdG1ldGFkYXRhOiBsb2cuY29udGV4dC5tZXRhZGF0YVxuXHRcdH07XG5cdFx0dHJ5IHtcblx0XHRcdGlmICgod2luZG93IGFzIGFueSkuYXBwPy52YXVsdD8uYWRhcHRlcj8uYXBwZW5kKSB7XG5cdFx0XHRcdCh3aW5kb3cgYXMgYW55KS5hcHAudmF1bHQuYWRhcHRlci5hcHBlbmQoXG5cdFx0XHRcdFx0dGhpcy5sb2dGaWxlUGF0aCxcblx0XHRcdFx0XHRKU09OLnN0cmluZ2lmeShsb2dFbnRyeSkgKyAnXFxuJ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gd3JpdGUgdG8gbG9nIGZpbGU6JywgZXJyb3IpO1xuXHRcdH1cblx0fVxuXG5cdHVwZGF0ZVNldHRpbmdzKHNldHRpbmdzOiBEZWJ1Z1NldHRpbmdzKTogdm9pZCB7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuXHR9XG5cblx0Z2V0UmVjZW50TG9ncyhjb3VudDogbnVtYmVyID0gMTApOiBFcnJvckxvZ1tdIHtcblx0XHRyZXR1cm4gdGhpcy5lcnJvckxvZ3Muc2xpY2UoMCwgY291bnQpO1xuXHR9XG5cblx0Y2xlYXJMb2dzKCk6IHZvaWQge1xuXHRcdHRoaXMuZXJyb3JMb2dzID0gW107XG5cdH1cblxuXHRnZXRFcnJvclN0YXRzKCk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xuXHRcdHJldHVybiB0aGlzLmVycm9yTG9ncy5yZWR1Y2UoKGFjYywgbG9nKSA9PiB7XG5cdFx0XHRjb25zdCBlcnJvclR5cGUgPSBsb2cuZXJyb3IubmFtZSB8fCAnVW5rbm93bic7XG5cdFx0XHRhY2NbZXJyb3JUeXBlXSA9IChhY2NbZXJyb3JUeXBlXSB8fCAwKSArIDE7XG5cdFx0XHRyZXR1cm4gYWNjO1xuXHRcdH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIG51bWJlcj4pO1xuXHR9XG5cblx0Z2V0U3luY0Vycm9yU3RhdHMoKTogUmVjb3JkPFN5bmNFcnJvclR5cGUsIG51bWJlcj4ge1xuXHRcdGNvbnN0IHN0YXRzID0ge30gYXMgUmVjb3JkPFN5bmNFcnJvclR5cGUsIG51bWJlcj47XG5cdFx0T2JqZWN0LnZhbHVlcyhTeW5jRXJyb3JUeXBlKS5mb3JFYWNoKHR5cGUgPT4ge1xuXHRcdFx0c3RhdHNbdHlwZSBhcyBTeW5jRXJyb3JUeXBlXSA9IDA7XG5cdFx0fSk7XG5cdFx0dGhpcy5lcnJvckxvZ3MuZm9yRWFjaChsb2cgPT4ge1xuXHRcdFx0aWYgKHRoaXMuaXNTeW5jRXJyb3IobG9nLmVycm9yKSkge1xuXHRcdFx0XHRzdGF0c1tsb2cuZXJyb3IudHlwZV0gPSAoc3RhdHNbbG9nLmVycm9yLnR5cGVdIHx8IDApICsgMTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gc3RhdHM7XG5cdH1cbn1cbiIsICIvLyBzcmMvdXRpbHMvTm90aWZpY2F0aW9uTWFuYWdlci50c1xuaW1wb3J0IHsgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgVGFza1Byb2dyZXNzIH0gZnJvbSAnLi4vbW9kZWxzL1Byb2Nlc3NpbmdUYXNrJztcblxuZXhwb3J0IGNsYXNzIE5vdGlmaWNhdGlvbk1hbmFnZXIge1xuXHRwcml2YXRlIGZpeGVkUHJvZ3Jlc3NCYXI6IHtcblx0XHRjb250YWluZXI6IEhUTUxFbGVtZW50O1xuXHRcdGZpbGw6IEhUTUxFbGVtZW50O1xuXHRcdHRleHQ6IEhUTUxFbGVtZW50O1xuXHR9IHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgc3RhdHVzQmFySXRlbTogSFRNTEVsZW1lbnQ7XG5cdHByaXZhdGUgZW5hYmxlTm90aWZpY2F0aW9uczogYm9vbGVhbjtcblx0cHJpdmF0ZSBlbmFibGVQcm9ncmVzc0JhcjogYm9vbGVhbjtcblx0cHJpdmF0ZSBub3RpZmljYXRpb25RdWV1ZTogc3RyaW5nW10gPSBbXTtcblx0cHJpdmF0ZSBpc1Byb2Nlc3NpbmdRdWV1ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHN0YXR1c0JhckVsOiBIVE1MRWxlbWVudCxcblx0XHRlbmFibGVOb3RpZmljYXRpb25zOiBib29sZWFuLFxuXHRcdGVuYWJsZVByb2dyZXNzQmFyOiBib29sZWFuXG5cdCkge1xuXHRcdHRoaXMuc3RhdHVzQmFySXRlbSA9IHN0YXR1c0JhckVsO1xuXHRcdHRoaXMuZW5hYmxlTm90aWZpY2F0aW9ucyA9IGVuYWJsZU5vdGlmaWNhdGlvbnM7XG5cdFx0dGhpcy5lbmFibGVQcm9ncmVzc0JhciA9IGVuYWJsZVByb2dyZXNzQmFyO1xuXHRcdHRoaXMuaW5pdGlhbGl6ZVN0YXR1c0JhcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNob3dzIGEgbm90aWZpY2F0aW9uIG1lc3NhZ2UuXG5cdCAqL1xuXHRzaG93Tm90aWZpY2F0aW9uKG1lc3NhZ2U6IHN0cmluZywgZHVyYXRpb246IG51bWJlciA9IDQwMDApOiB2b2lkIHtcblx0XHRpZiAoIXRoaXMuZW5hYmxlTm90aWZpY2F0aW9ucykgcmV0dXJuO1xuXHRcdC8vIFF1ZXVlIG5vdGlmaWNhdGlvbiB0byBhdm9pZCBzcGFtbWluZyB0aGUgVUkuXG5cdFx0dGhpcy5ub3RpZmljYXRpb25RdWV1ZS5wdXNoKG1lc3NhZ2UpO1xuXHRcdGlmICghdGhpcy5pc1Byb2Nlc3NpbmdRdWV1ZSkge1xuXHRcdFx0dGhpcy5wcm9jZXNzTm90aWZpY2F0aW9uUXVldWUoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgZml4ZWQgcHJvZ3Jlc3MgYmFyIHdpdGggdGhlIGN1cnJlbnQgcHJvZ3Jlc3MgKGluIHBlcmNlbnQpIGFuZCBzdGF0dXMgbWVzc2FnZS5cblx0ICovXG5cdHVwZGF0ZVByb2dyZXNzKHByb2dyZXNzOiBUYXNrUHJvZ3Jlc3MpOiB2b2lkIHtcblx0XHRpZiAoIXRoaXMuZW5hYmxlUHJvZ3Jlc3NCYXIpIHJldHVybjtcblx0XHQvLyBDcmVhdGUgdGhlIGZpeGVkIHByb2dyZXNzIGJhciBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuXHRcdGlmICghdGhpcy5maXhlZFByb2dyZXNzQmFyKSB7XG5cdFx0XHR0aGlzLmZpeGVkUHJvZ3Jlc3NCYXIgPSB0aGlzLmNyZWF0ZUZpeGVkUHJvZ3Jlc3NCYXIoKTtcblx0XHR9XG5cdFx0Y29uc3QgcHJvZ3Jlc3NQZXJjZW50YWdlID0gTWF0aC5yb3VuZChwcm9ncmVzcy5wcm9ncmVzcyk7XG5cdFx0dGhpcy5maXhlZFByb2dyZXNzQmFyLmZpbGwuc3R5bGUud2lkdGggPSBgJHtwcm9ncmVzc1BlcmNlbnRhZ2V9JWA7XG5cdFx0Ly8gRGlzcGxheSB0aGUgcGVyY2VudGFnZSBhbG9uZyB3aXRoIGEgY3VzdG9tIHN0YXR1cyBtZXNzYWdlLlxuXHRcdHRoaXMuZml4ZWRQcm9ncmVzc0Jhci50ZXh0LnRleHRDb250ZW50ID0gYCR7cHJvZ3Jlc3NQZXJjZW50YWdlfSUgLSAke3Byb2dyZXNzLmN1cnJlbnRTdGVwfSAoJHtwcm9ncmVzcy5jdXJyZW50U3RlcE51bWJlcn0vJHtwcm9ncmVzcy50b3RhbFN0ZXBzfSlgO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRoZSBzdGF0dXMgYmFyIGNvbnRhaW5lci5cblx0ICovXG5cdHByaXZhdGUgaW5pdGlhbGl6ZVN0YXR1c0JhcigpOiB2b2lkIHtcblx0XHQvLyBDbGVhciBhbnkgZXhpc3RpbmcgY29udGVudC5cblx0XHR0aGlzLnN0YXR1c0Jhckl0ZW0uaW5uZXJIVE1MID0gJyc7XG5cdFx0Ly8gQ3JlYXRlIGEgY29udGFpbmVyIGVsZW1lbnQgKGlmIG5lZWRlZCkgdG8gaG9zdCB0aGUgZml4ZWQgcHJvZ3Jlc3MgYmFyLlxuXHRcdGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdGNvbnRhaW5lci5hZGRDbGFzcygnZml4ZWQtcHJvZ3Jlc3MtY29udGFpbmVyJyk7XG5cdFx0dGhpcy5zdGF0dXNCYXJJdGVtLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIGZpeGVkIHByb2dyZXNzIGJhciBlbGVtZW50LlxuXHQgKi9cblx0cHJpdmF0ZSBjcmVhdGVGaXhlZFByb2dyZXNzQmFyKCk6IHsgY29udGFpbmVyOiBIVE1MRWxlbWVudDsgZmlsbDogSFRNTEVsZW1lbnQ7IHRleHQ6IEhUTUxFbGVtZW50IH0ge1xuXHRcdGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdGNvbnRhaW5lci5hZGRDbGFzcygnZml4ZWQtcHJvZ3Jlc3MtYmFyLWNvbnRhaW5lcicpO1xuXG5cdFx0Y29uc3QgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0YmFyLmFkZENsYXNzKCdmaXhlZC1wcm9ncmVzcy1iYXInKTtcblxuXHRcdGNvbnN0IGZpbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRmaWxsLmFkZENsYXNzKCdmaXhlZC1wcm9ncmVzcy1maWxsJyk7XG5cblx0XHRjb25zdCB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0dGV4dC5hZGRDbGFzcygnZml4ZWQtcHJvZ3Jlc3MtdGV4dCcpO1xuXG5cdFx0YmFyLmFwcGVuZENoaWxkKGZpbGwpO1xuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChiYXIpO1xuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0ZXh0KTtcblx0XHR0aGlzLnN0YXR1c0Jhckl0ZW0uYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuXHRcdHJldHVybiB7IGNvbnRhaW5lciwgZmlsbCwgdGV4dCB9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3NlcyB0aGUgbm90aWZpY2F0aW9uIHF1ZXVlIHNlcXVlbnRpYWxseS5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc05vdGlmaWNhdGlvblF1ZXVlKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICh0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlIHx8IHRoaXMubm90aWZpY2F0aW9uUXVldWUubGVuZ3RoID09PSAwKSByZXR1cm47XG5cdFx0dGhpcy5pc1Byb2Nlc3NpbmdRdWV1ZSA9IHRydWU7XG5cdFx0dHJ5IHtcblx0XHRcdHdoaWxlICh0aGlzLm5vdGlmaWNhdGlvblF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc3QgbWVzc2FnZSA9IHRoaXMubm90aWZpY2F0aW9uUXVldWUuc2hpZnQoKTtcblx0XHRcdFx0aWYgKG1lc3NhZ2UpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKG1lc3NhZ2UpO1xuXHRcdFx0XHRcdC8vIFdhaXQgYSBiaXQgYmV0d2VlbiBub3RpZmljYXRpb25zIHRvIGF2b2lkIHNwYW1taW5nLlxuXHRcdFx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgbm90aWZpY2F0aW9uIHNldHRpbmdzLlxuXHQgKi9cblx0dXBkYXRlU2V0dGluZ3MoZW5hYmxlTm90aWZpY2F0aW9uczogYm9vbGVhbiwgZW5hYmxlUHJvZ3Jlc3NCYXI6IGJvb2xlYW4pOiB2b2lkIHtcblx0XHR0aGlzLmVuYWJsZU5vdGlmaWNhdGlvbnMgPSBlbmFibGVOb3RpZmljYXRpb25zO1xuXHRcdHRoaXMuZW5hYmxlUHJvZ3Jlc3NCYXIgPSBlbmFibGVQcm9ncmVzc0Jhcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgYWxsIG5vdGlmaWNhdGlvbnMuXG5cdCAqL1xuXHRjbGVhcigpOiB2b2lkIHtcblx0XHR0aGlzLm5vdGlmaWNhdGlvblF1ZXVlID0gW107XG5cdH1cbn1cbiIsICIvL1NldHRpbmdzVGFiLnRzXG5pbXBvcnQgeyBBcHAsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBNaW5kTWF0cml4UGx1Z2luIGZyb20gJy4uL21haW4nO1xuaW1wb3J0IHsgTWluZE1hdHJpeFNldHRpbmdzLCBnZW5lcmF0ZVZhdWx0SWQsIGlzVmF1bHRJbml0aWFsaXplZCwgZ2V0VXNlckV4Y2x1c2lvbnMsIFNZU1RFTV9FWENMVVNJT05TIH0gZnJvbSAnLi9TZXR0aW5ncyc7XG5pbXBvcnQgeyBTdXBhYmFzZVNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9TdXBhYmFzZVNlcnZpY2UnO1xuXG5leHBvcnQgY2xhc3MgTWluZE1hdHJpeFNldHRpbmdzVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG5cdHBsdWdpbjogTWluZE1hdHJpeFBsdWdpbjtcblx0c2V0dGluZ3M6IE1pbmRNYXRyaXhTZXR0aW5ncztcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBNaW5kTWF0cml4UGx1Z2luKSB7XG5cdFx0c3VwZXIoYXBwLCBwbHVnaW4pO1xuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBwbHVnaW4uc2V0dGluZ3M7XG5cdH1cblxuXHRhc3luYyBkaXNwbGF5KCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblxuXHRcdC8vIERlYnVnZ2luZzogTG9nIGFsbCBleGNsdXNpb24gc2V0dGluZ3MgdG8gY29uc29sZVxuXHRcdGNvbnNvbGUubG9nKFwiREVCVUcgLSBBbGwgRXhjbHVzaW9uIFNldHRpbmdzOlwiLCB7XG5cdFx0XHR1c2VyU2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucyxcblx0XHRcdHN5c3RlbURlZmF1bHRzOiBTWVNURU1fRVhDTFVTSU9OU1xuXHRcdH0pO1xuXG5cdFx0Ly8gVmF1bHQgSWRlbnRpZmljYXRpb24gU2VjdGlvblxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1ZhdWx0IElkZW50aWZpY2F0aW9uJyB9KTtcblxuXHRcdGlmIChpc1ZhdWx0SW5pdGlhbGl6ZWQodGhpcy5zZXR0aW5ncykpIHtcblx0XHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0XHQuc2V0TmFtZSgnVmF1bHQgSUQnKVxuXHRcdFx0XHQuc2V0RGVzYygnVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgdmF1bHQgaW4gdGhlIGRhdGFiYXNlLicpXG5cdFx0XHRcdC5hZGRUZXh0KHRleHQgPT5cblx0XHRcdFx0XHR0ZXh0LnNldFZhbHVlKHRoaXMuc2V0dGluZ3MudmF1bHRJZCEpXG5cdFx0XHRcdFx0XHQuc2V0RGlzYWJsZWQodHJ1ZSlcblx0XHRcdFx0KTtcblxuXHRcdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXROYW1lKCdWYXVsdCBOYW1lJylcblx0XHRcdFx0LnNldERlc2MoJ1RoZSBuYW1lIG9mIHlvdXIgY3VycmVudCB2YXVsdC4nKVxuXHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+XG5cdFx0XHRcdFx0dGV4dC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzLmxhc3RLbm93blZhdWx0TmFtZSlcblx0XHRcdFx0XHRcdC5zZXREaXNhYmxlZCh0cnVlKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdFx0LnNldE5hbWUoJ1Jlc2V0IFZhdWx0IElEJylcblx0XHRcdFx0LnNldERlc2MoJ0dlbmVyYXRlIGEgbmV3IHZhdWx0IElEIChyZXF1aXJlcyBmdWxsIHJlc3luYykuJylcblx0XHRcdFx0LmFkZEJ1dHRvbihidG4gPT5cblx0XHRcdFx0XHRidG4uc2V0QnV0dG9uVGV4dCgnUmVzZXQnKVxuXHRcdFx0XHRcdFx0LnNldFdhcm5pbmcoKVxuXHRcdFx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBjb25maXJtZWQgPSBhd2FpdCB0aGlzLnNob3dSZXNldENvbmZpcm1hdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRpZiAoY29uZmlybWVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy52YXVsdElkID0gZ2VuZXJhdGVWYXVsdElkKCk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5sYXN0S25vd25WYXVsdE5hbWUgPSB0aGlzLmFwcC52YXVsdC5nZXROYW1lKCk7XG5cdFx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnVmF1bHQgSUQgaGFzIGJlZW4gcmVzZXQuIFBsZWFzZSByZXN5bmMgeW91ciB2YXVsdC4nKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmRpc3BsYXkoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXROYW1lKCdJbml0aWFsaXplIFZhdWx0Jylcblx0XHRcdFx0LnNldERlc2MoJ0dlbmVyYXRlIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgdmF1bHQgdG8gYmVnaW4gc3luY2luZy4nKVxuXHRcdFx0XHQuYWRkQnV0dG9uKGJ0biA9PlxuXHRcdFx0XHRcdGJ0bi5zZXRCdXR0b25UZXh0KCdJbml0aWFsaXplJylcblx0XHRcdFx0XHRcdC5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy52YXVsdElkID0gZ2VuZXJhdGVWYXVsdElkKCk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MubGFzdEtub3duVmF1bHROYW1lID0gdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpO1xuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnVmF1bHQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuJyk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZGlzcGxheSgpO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBTdXBhYmFzZSBTZXR0aW5ncyBTZWN0aW9uXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnU3VwYWJhc2UgQ29uZmlndXJhdGlvbicgfSk7XG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnU3VwYWJhc2UgVVJMJylcblx0XHRcdC5zZXREZXNjKCdUaGUgVVJMIG9mIHlvdXIgU3VwYWJhc2UgcHJvamVjdCAoZS5nLiwgaHR0cHM6Ly95b3VyLXByb2plY3Quc3VwYWJhc2UuY28pLicpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+XG5cdFx0XHRcdHRleHQuc2V0UGxhY2Vob2xkZXIoJ2h0dHBzOi8veW91ci1wcm9qZWN0LnN1cGFiYXNlLmNvJylcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5zdXBhYmFzZS51cmwpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5zdXBhYmFzZS51cmwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnU3VwYWJhc2UgVVJMIHVwZGF0ZWQuJyk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdCk7XG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnU3VwYWJhc2UgQVBJIEtleScpXG5cdFx0XHQuc2V0RGVzYygnWW91ciBTdXBhYmFzZSBBUEkga2V5IChmb3VuZCBpbiB5b3VyIFN1cGFiYXNlIGRhc2hib2FyZCkuJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT5cblx0XHRcdFx0dGV4dC5zZXRQbGFjZWhvbGRlcignRW50ZXIgeW91ciBBUEkga2V5Jylcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5zdXBhYmFzZS5hcGlLZXkpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5zdXBhYmFzZS5hcGlLZXkgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnU3VwYWJhc2UgQVBJIGtleSB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0Ly8gT3BlbkFJIFNldHRpbmdzIFNlY3Rpb25cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdPcGVuQUkgQ29uZmlndXJhdGlvbicgfSk7XG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnT3BlbkFJIEFQSSBLZXknKVxuXHRcdFx0LnNldERlc2MoJ1lvdXIgT3BlbkFJIEFQSSBrZXkgZm9yIGdlbmVyYXRpbmcgZW1iZWRkaW5ncy4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PlxuXHRcdFx0XHR0ZXh0LnNldFBsYWNlaG9sZGVyKCdFbnRlciB5b3VyIEFQSSBrZXknKVxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzLm9wZW5haS5hcGlLZXkpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5vcGVuYWkuYXBpS2V5ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ09wZW5BSSBBUEkga2V5IHVwZGF0ZWQuJyk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHQvLyBEb2N1bWVudCBQcm9jZXNzaW5nIFNldHRpbmdzIFNlY3Rpb25cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdEb2N1bWVudCBQcm9jZXNzaW5nJyB9KTtcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdDaHVuayBTaXplJylcblx0XHRcdC5zZXREZXNjKCdNYXhpbXVtIHNpemUgb2YgdGV4dCBjaHVua3MgKGluIGNoYXJhY3RlcnMpLicpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+XG5cdFx0XHRcdHRleHQuc2V0VmFsdWUoU3RyaW5nKHRoaXMuc2V0dGluZ3MuY2h1bmtpbmcuY2h1bmtTaXplKSlcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBudW1WYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cdFx0XHRcdFx0XHRpZiAoIWlzTmFOKG51bVZhbHVlKSAmJiBudW1WYWx1ZSA+IDApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jaHVua2luZy5jaHVua1NpemUgPSBudW1WYWx1ZTtcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0NodW5rIHNpemUgdXBkYXRlZC4nKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0KTtcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdDaHVuayBPdmVybGFwJylcblx0XHRcdC5zZXREZXNjKCdPdmVybGFwIGJldHdlZW4gdGV4dCBjaHVua3MgKGluIGNoYXJhY3RlcnMpLicpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+XG5cdFx0XHRcdHRleHQuc2V0VmFsdWUoU3RyaW5nKHRoaXMuc2V0dGluZ3MuY2h1bmtpbmcuY2h1bmtPdmVybGFwKSlcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBudW1WYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cdFx0XHRcdFx0XHRpZiAoIWlzTmFOKG51bVZhbHVlKSAmJiBudW1WYWx1ZSA+PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuY2h1bmtpbmcuY2h1bmtPdmVybGFwID0gbnVtVmFsdWU7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdDaHVuayBvdmVybGFwIHVwZGF0ZWQuJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHQvLyBFeGNsdXNpb24gU2V0dGluZ3MgU2VjdGlvbiAtIE9ubHkgc2hvd2luZyB1c2VyLWRlZmluZWQgZXhjbHVzaW9uc1xuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0V4Y2x1c2lvbnMnIH0pO1xuXG5cdFx0Ly8gR2V0IG9ubHkgdXNlci1kZWZpbmVkIGV4Y2x1c2lvbnMgZm9yIFVJIGRpc3BsYXlcblx0XHRjb25zdCB1c2VyRXhjbHVzaW9ucyA9IGdldFVzZXJFeGNsdXNpb25zKHRoaXMuc2V0dGluZ3MpO1xuXG5cdFx0Ly8gRGVidWc6IExvZyB1c2VyIGV4Y2x1c2lvbnMgZnJvbSB0aGUgZnVuY3Rpb25cblx0XHRjb25zb2xlLmxvZyhcIkRFQlVHIC0gVXNlciBFeGNsdXNpb25zIGZyb20gZ2V0VXNlckV4Y2x1c2lvbnMoKTpcIiwgdXNlckV4Y2x1c2lvbnMpO1xuXG5cdFx0Ly8gRmlsdGVyIG91dCBhbnkgc3lzdGVtIGV4Y2x1c2lvbnMgdGhhdCBtaWdodCBoYXZlIGJlZW4gYWNjaWRlbnRhbGx5IHNhdmVkIGluIHVzZXIgbGlzdHNcblx0XHRjb25zdCBzeXN0ZW1Gb2xkZXJzID0gbmV3IFNldChTWVNURU1fRVhDTFVTSU9OUy5mb2xkZXJzKTtcblx0XHRjb25zdCBzeXN0ZW1GaWxlVHlwZXMgPSBuZXcgU2V0KFNZU1RFTV9FWENMVVNJT05TLmZpbGVUeXBlcyk7XG5cdFx0Y29uc3Qgc3lzdGVtRmlsZVByZWZpeGVzID0gbmV3IFNldChTWVNURU1fRVhDTFVTSU9OUy5maWxlUHJlZml4ZXMpO1xuXHRcdGNvbnN0IHN5c3RlbUZpbGVzID0gbmV3IFNldChTWVNURU1fRVhDTFVTSU9OUy5maWxlcyk7XG5cblx0XHQvLyBEZWJ1ZzogTG9nIHRoZSBzeXN0ZW0gZXhjbHVzaW9uIHNldHNcblx0XHRjb25zb2xlLmxvZyhcIkRFQlVHIC0gU3lzdGVtIEV4Y2x1c2lvbiBTZXRzOlwiLCB7XG5cdFx0XHRmb2xkZXJzOiBBcnJheS5mcm9tKHN5c3RlbUZvbGRlcnMpLFxuXHRcdFx0ZmlsZVR5cGVzOiBBcnJheS5mcm9tKHN5c3RlbUZpbGVUeXBlcyksXG5cdFx0XHRmaWxlUHJlZml4ZXM6IEFycmF5LmZyb20oc3lzdGVtRmlsZVByZWZpeGVzKSxcblx0XHRcdGZpbGVzOiBBcnJheS5mcm9tKHN5c3RlbUZpbGVzKVxuXHRcdH0pO1xuXG5cdFx0Ly8gRmlsdGVyIG91dCBzeXN0ZW0gaXRlbXMgZnJvbSB1c2VyIGV4Y2x1c2lvbnNcblx0XHRjb25zdCBmaWx0ZXJlZFVzZXJGb2xkZXJzID0gdXNlckV4Y2x1c2lvbnMuZXhjbHVkZWRGb2xkZXJzLmZpbHRlcihmb2xkZXIgPT4gIXN5c3RlbUZvbGRlcnMuaGFzKGZvbGRlcikpO1xuXHRcdGNvbnN0IGZpbHRlcmVkVXNlckZpbGVUeXBlcyA9IHVzZXJFeGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVR5cGVzLmZpbHRlcih0eXBlID0+ICFzeXN0ZW1GaWxlVHlwZXMuaGFzKHR5cGUpKTtcblx0XHRjb25zdCBmaWx0ZXJlZFVzZXJGaWxlUHJlZml4ZXMgPSB1c2VyRXhjbHVzaW9ucy5leGNsdWRlZEZpbGVQcmVmaXhlcy5maWx0ZXIocHJlZml4ID0+ICFzeXN0ZW1GaWxlUHJlZml4ZXMuaGFzKHByZWZpeCkpO1xuXHRcdGNvbnN0IGZpbHRlcmVkVXNlckZpbGVzID0gdXNlckV4Y2x1c2lvbnMuZXhjbHVkZWRGaWxlcy5maWx0ZXIoZmlsZSA9PiAhc3lzdGVtRmlsZXMuaGFzKGZpbGUpKTtcblxuXHRcdC8vIERlYnVnOiBMb2cgdGhlIGZpbHRlcmVkIGV4Y2x1c2lvbnNcblx0XHRjb25zb2xlLmxvZyhcIkRFQlVHIC0gRmlsdGVyZWQgVXNlciBFeGNsdXNpb25zOlwiLCB7XG5cdFx0XHRmb2xkZXJzOiBmaWx0ZXJlZFVzZXJGb2xkZXJzLFxuXHRcdFx0ZmlsZVR5cGVzOiBmaWx0ZXJlZFVzZXJGaWxlVHlwZXMsXG5cdFx0XHRmaWxlUHJlZml4ZXM6IGZpbHRlcmVkVXNlckZpbGVQcmVmaXhlcyxcblx0XHRcdGZpbGVzOiBmaWx0ZXJlZFVzZXJGaWxlc1xuXHRcdH0pO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnRXhjbHVkZWQgRm9sZGVycycpXG5cdFx0XHQuc2V0RGVzYygnRm9sZGVycyB0byBleGNsdWRlIGZyb20gc3luY2luZyAoY29tbWEtc2VwYXJhdGVkKS4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gZmlsdGVyZWRVc2VyRm9sZGVycy5qb2luKCcsICcpO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkRFQlVHIC0gU2V0dGluZyBleGNsdWRlZCBmb2xkZXJzIGZpZWxkIHZhbHVlOlwiLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiB0ZXh0LnNldFBsYWNlaG9sZGVyKCdmb2xkZXIxLCBmb2xkZXIyJylcblx0XHRcdFx0XHQuc2V0VmFsdWUodmFsdWUpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJERUJVRyAtIEZvbGRlcnMgb25DaGFuZ2UgZXZlbnQgdmFsdWU6XCIsIHZhbHVlKTtcblx0XHRcdFx0XHRcdC8vIFNhdmUgb25seSB1c2VyLWRlZmluZWQgZm9sZGVycywgZW5zdXJpbmcgd2UgZG9uJ3QgZHVwbGljYXRlIHN5c3RlbSBmb2xkZXJzXG5cdFx0XHRcdFx0XHRjb25zdCB1c2VyRm9sZGVycyA9IHZhbHVlLnNwbGl0KCcsJykubWFwKHMgPT4gcy50cmltKCkpLmZpbHRlcihzID0+IHMpO1xuXHRcdFx0XHRcdFx0Y29uc3QgZmluYWxGb2xkZXJzID0gdXNlckZvbGRlcnMuZmlsdGVyKGZvbGRlciA9PiAhc3lzdGVtRm9sZGVycy5oYXMoZm9sZGVyKSk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkRFQlVHIC0gRmluYWwgZm9sZGVycyB0byBzYXZlOlwiLCBmaW5hbEZvbGRlcnMpO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLmV4Y2x1ZGVkRm9sZGVycyA9IGZpbmFsRm9sZGVycztcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnRXhjbHVkZWQgZm9sZGVycyB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdFeGNsdWRlZCBGaWxlIFR5cGVzJylcblx0XHRcdC5zZXREZXNjKCdGaWxlIGV4dGVuc2lvbnMgdG8gZXhjbHVkZSAoY29tbWEtc2VwYXJhdGVkLCBpbmNsdWRlIHRoZSBkb3QpLicpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBmaWx0ZXJlZFVzZXJGaWxlVHlwZXMuam9pbignLCAnKTtcblxuXHRcdFx0XHRyZXR1cm4gdGV4dC5zZXRQbGFjZWhvbGRlcignLnR5cGUxLCAudHlwZTInKVxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh2YWx1ZSlcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCB1c2VyRmlsZVR5cGVzID0gdmFsdWUuc3BsaXQoJywnKS5tYXAocyA9PiBzLnRyaW0oKSkuZmlsdGVyKHMgPT4gcyk7XG5cdFx0XHRcdFx0XHRjb25zdCBmaW5hbEZpbGVUeXBlcyA9IHVzZXJGaWxlVHlwZXMuZmlsdGVyKHR5cGUgPT4gIXN5c3RlbUZpbGVUeXBlcy5oYXModHlwZSkpO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVR5cGVzID0gZmluYWxGaWxlVHlwZXM7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0V4Y2x1ZGVkIGZpbGUgdHlwZXMgdXBkYXRlZC4nKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnRXhjbHVkZWQgRmlsZSBQcmVmaXhlcycpXG5cdFx0XHQuc2V0RGVzYygnRmlsZSBuYW1lIHByZWZpeGVzIHRvIGV4Y2x1ZGUgKGNvbW1hLXNlcGFyYXRlZCkuJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGZpbHRlcmVkVXNlckZpbGVQcmVmaXhlcy5qb2luKCcsICcpO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkRFQlVHIC0gU2V0dGluZyBleGNsdWRlZCBmaWxlIHByZWZpeGVzIGZpZWxkIHZhbHVlOlwiLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiB0ZXh0LnNldFBsYWNlaG9sZGVyKCd0ZW1wLCBkcmFmdCcpXG5cdFx0XHRcdFx0LnNldFZhbHVlKHZhbHVlKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiREVCVUcgLSBGaWxlIHByZWZpeGVzIG9uQ2hhbmdlIGV2ZW50IHZhbHVlOlwiLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHQvLyBTYXZlIG9ubHkgdXNlci1kZWZpbmVkIHByZWZpeGVzLCBlbnN1cmluZyB3ZSBkb24ndCBkdXBsaWNhdGUgc3lzdGVtIHByZWZpeGVzXG5cdFx0XHRcdFx0XHRjb25zdCB1c2VyRmlsZVByZWZpeGVzID0gdmFsdWUuc3BsaXQoJywnKS5tYXAocyA9PiBzLnRyaW0oKSkuZmlsdGVyKHMgPT4gcyk7XG5cdFx0XHRcdFx0XHRjb25zdCBmaW5hbEZpbGVQcmVmaXhlcyA9IHVzZXJGaWxlUHJlZml4ZXMuZmlsdGVyKHByZWZpeCA9PiAhc3lzdGVtRmlsZVByZWZpeGVzLmhhcyhwcmVmaXgpKTtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiREVCVUcgLSBGaW5hbCBmaWxlIHByZWZpeGVzIHRvIHNhdmU6XCIsIGZpbmFsRmlsZVByZWZpeGVzKTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVQcmVmaXhlcyA9IGZpbmFsRmlsZVByZWZpeGVzO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdFeGNsdWRlZCBmaWxlIHByZWZpeGVzIHVwZGF0ZWQuJyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0V4Y2x1ZGVkIEZpbGVzJylcblx0XHRcdC5zZXREZXNjKCdTcGVjaWZpYyBmaWxlcyB0byBleGNsdWRlIGZyb20gc3luY2luZyAoY29tbWEtc2VwYXJhdGVkKS4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gZmlsdGVyZWRVc2VyRmlsZXMuam9pbignLCAnKTtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJERUJVRyAtIFNldHRpbmcgZXhjbHVkZWQgZmlsZXMgZmllbGQgdmFsdWU6XCIsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIHRleHQuc2V0UGxhY2Vob2xkZXIoJ2ZpbGUxLm1kLCBmaWxlMi5tZCcpXG5cdFx0XHRcdFx0LnNldFZhbHVlKHZhbHVlKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiREVCVUcgLSBGaWxlcyBvbkNoYW5nZSBldmVudCB2YWx1ZTpcIiwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0Ly8gU2F2ZSBvbmx5IHVzZXItZGVmaW5lZCBmaWxlcywgZW5zdXJpbmcgd2UgZG9uJ3QgZHVwbGljYXRlIHN5c3RlbSBmaWxlc1xuXHRcdFx0XHRcdFx0Y29uc3QgdXNlckZpbGVzID0gdmFsdWUuc3BsaXQoJywnKS5tYXAocyA9PiBzLnRyaW0oKSkuZmlsdGVyKHMgPT4gcyk7XG5cdFx0XHRcdFx0XHRjb25zdCBmaW5hbEZpbGVzID0gdXNlckZpbGVzLmZpbHRlcihmaWxlID0+ICFzeXN0ZW1GaWxlcy5oYXMoZmlsZSkpO1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJERUJVRyAtIEZpbmFsIGZpbGVzIHRvIHNhdmU6XCIsIGZpbmFsRmlsZXMpO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMgPSBmaW5hbEZpbGVzO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdFeGNsdWRlZCBmaWxlcyB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHQvLyBJbXByb3ZlZCBpbmZvIHRleHQgYWJvdXQgc3lzdGVtIGRlZmF1bHRzXG5cdFx0Y29uc3QgaW5mb0RpdiA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ3NldHRpbmctaXRlbS1kZXNjcmlwdGlvbicgfSk7XG5cdFx0aW5mb0Rpdi5pbm5lckhUTUwgPSBgXG5cdFx0XHQ8cD48c3Ryb25nPk5vdGU6PC9zdHJvbmc+IFRoZSBmb2xsb3dpbmcgaXRlbXMgYXJlIGF1dG9tYXRpY2FsbHkgZXhjbHVkZWQgYnkgdGhlIHN5c3RlbTo8L3A+XG5cdFx0XHQ8cD48c3Ryb25nPkZvbGRlcnM6PC9zdHJvbmc+ICR7U1lTVEVNX0VYQ0xVU0lPTlMuZm9sZGVycy5qb2luKCcsICcpfTwvcD5cblx0XHRcdDxwPjxzdHJvbmc+RmlsZSBUeXBlczo8L3N0cm9uZz4gJHtTWVNURU1fRVhDTFVTSU9OUy5maWxlVHlwZXMuam9pbignLCAnKX08L3A+XG5cdFx0XHQ8cD48c3Ryb25nPkZpbGUgUHJlZml4ZXM6PC9zdHJvbmc+ICR7U1lTVEVNX0VYQ0xVU0lPTlMuZmlsZVByZWZpeGVzLmpvaW4oJywgJyl9PC9wPlxuXHRcdFx0PHA+PHN0cm9uZz5GaWxlczo8L3N0cm9uZz4gJHtTWVNURU1fRVhDTFVTSU9OUy5maWxlcy5qb2luKCcsICcpfTwvcD5cblx0XHRgO1xuXG5cdFx0Ly8gUXVldWUgJiBTeW5jIFNldHRpbmdzIFNlY3Rpb25cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdRdWV1ZSAmIFN5bmMgU2V0dGluZ3MnIH0pO1xuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0F1dG8gU3luYycpXG5cdFx0XHQuc2V0RGVzYygnQXV0b21hdGljYWxseSBzeW5jIGNoYW5nZXMgdG8gdGhlIGRhdGFiYXNlIHdoZW4gZmlsZXMgYXJlIG1vZGlmaWVkLicpXG5cdFx0XHQuYWRkVG9nZ2xlKHRvZ2dsZSA9PlxuXHRcdFx0XHR0b2dnbGUuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5lbmFibGVBdXRvU3luYylcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmVuYWJsZUF1dG9TeW5jID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0F1dG8gc3luYyB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHQpO1xuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ1N5bmMgRmlsZSBQYXRoJylcblx0XHRcdC5zZXREZXNjKCdUaGUgcGF0aCBmb3IgdGhlIGRlZGljYXRlZCBzeW5jIGZpbGUuJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT5cblx0XHRcdFx0dGV4dC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzLnN5bmMuc3luY0ZpbGVQYXRoKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3luYy5zeW5jRmlsZVBhdGggPSB2YWx1ZTtcblx0XHRcdFx0XHRcdC8vIEFsc28gdXBkYXRlIHRoZSBzeXN0ZW0gZXhjbHVkZWQgZmlsZXNcblx0XHRcdFx0XHRcdGNvbnN0IHN5c3RlbUZpbGVzID0gdGhpcy5zZXR0aW5ncy5leGNsdXNpb25zLnN5c3RlbUV4Y2x1ZGVkRmlsZXM7XG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgb2xkIHN5bmMgZmlsZSByZWZlcmVuY2VzXG5cdFx0XHRcdFx0XHRjb25zdCBvbGRTeW5jRmlsZUluZGV4ID0gc3lzdGVtRmlsZXMuZmluZEluZGV4KGYgPT4gZiA9PT0gJ19taW5kbWF0cml4c3luYy5tZCcpO1xuXHRcdFx0XHRcdFx0Y29uc3Qgb2xkU3luY0JhY2t1cEluZGV4ID0gc3lzdGVtRmlsZXMuZmluZEluZGV4KGYgPT4gZiA9PT0gJ19taW5kbWF0cml4c3luYy5tZC5iYWNrdXAnKTtcblx0XHRcdFx0XHRcdGlmIChvbGRTeW5jRmlsZUluZGV4ICE9PSAtMSkgc3lzdGVtRmlsZXMuc3BsaWNlKG9sZFN5bmNGaWxlSW5kZXgsIDEpO1xuXHRcdFx0XHRcdFx0aWYgKG9sZFN5bmNCYWNrdXBJbmRleCAhPT0gLTEpIHN5c3RlbUZpbGVzLnNwbGljZShvbGRTeW5jQmFja3VwSW5kZXgsIDEpO1xuXHRcdFx0XHRcdFx0Ly8gQWRkIG5ldyBzeW5jIGZpbGUgcmVmZXJlbmNlc1xuXHRcdFx0XHRcdFx0c3lzdGVtRmlsZXMucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRzeXN0ZW1GaWxlcy5wdXNoKHZhbHVlICsgJy5iYWNrdXAnKTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnU3luYyBmaWxlIHBhdGggdXBkYXRlZC4nKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdC8vIERlYnVnIFNldHRpbmdzIFNlY3Rpb25cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdEZWJ1ZyBTZXR0aW5ncycgfSk7XG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnRW5hYmxlIERlYnVnIExvZ3MnKVxuXHRcdFx0LnNldERlc2MoJ0VuYWJsZSBkZXRhaWxlZCBkZWJ1ZyBsb2dzIGluIHRoZSBjb25zb2xlLicpXG5cdFx0XHQuYWRkVG9nZ2xlKHRvZ2dsZSA9PlxuXHRcdFx0XHR0b2dnbGUuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5kZWJ1Zy5lbmFibGVEZWJ1Z0xvZ3MpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5kZWJ1Zy5lbmFibGVEZWJ1Z0xvZ3MgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnRGVidWcgbG9ncyBzZXR0aW5nIHVwZGF0ZWQuJyk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdCk7XG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnTG9nIExldmVsJylcblx0XHRcdC5zZXREZXNjKCdTZWxlY3QgdGhlIGxldmVsIG9mIGRldGFpbCBmb3IgZGVidWcgbG9nZ2luZy4nKVxuXHRcdFx0LmFkZERyb3Bkb3duKGRyb3Bkb3duID0+XG5cdFx0XHRcdGRyb3Bkb3duLmFkZE9wdGlvbignZXJyb3InLCAnRXJyb3InKVxuXHRcdFx0XHRcdC5hZGRPcHRpb24oJ3dhcm4nLCAnV2FybmluZycpXG5cdFx0XHRcdFx0LmFkZE9wdGlvbignaW5mbycsICdJbmZvJylcblx0XHRcdFx0XHQuYWRkT3B0aW9uKCdkZWJ1ZycsICdEZWJ1ZycpXG5cdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc2V0dGluZ3MuZGVidWcubG9nTGV2ZWwpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5kZWJ1Zy5sb2dMZXZlbCA9IHZhbHVlIGFzICdlcnJvcicgfCAnd2FybicgfCAnaW5mbycgfCAnZGVidWcnO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdMb2cgbGV2ZWwgdXBkYXRlZC4nKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0KTtcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdMb2cgdG8gRmlsZScpXG5cdFx0XHQuc2V0RGVzYygnU2F2ZSBkZWJ1ZyBsb2dzIHRvIGEgZmlsZSBpbiB5b3VyIHZhdWx0LicpXG5cdFx0XHQuYWRkVG9nZ2xlKHRvZ2dsZSA9PlxuXHRcdFx0XHR0b2dnbGUuc2V0VmFsdWUodGhpcy5zZXR0aW5ncy5kZWJ1Zy5sb2dUb0ZpbGUpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5kZWJ1Zy5sb2dUb0ZpbGUgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnTG9nIHRvIGZpbGUgc2V0dGluZyB1cGRhdGVkLicpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0Ly8gRGF0YWJhc2UgTWFuYWdlbWVudCBTZWN0aW9uXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnRGF0YWJhc2UgTWFuYWdlbWVudCcgfSk7XG5cblx0XHQvLyBEYXRhYmFzZSBTdGF0dXNcblx0XHRjb25zdCBzdGF0dXNDb250YWluZXIgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoJ2RhdGFiYXNlLXN0YXR1cy1jb250YWluZXInKTtcblx0XHRjb25zdCBzdGF0dXNUZXh0ID0gc3RhdHVzQ29udGFpbmVyLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnQ2hlY2tpbmcgZGF0YWJhc2Ugc3RhdHVzLi4uJyB9KTtcblx0XHRcblx0XHQvLyBUZXN0IENvbm5lY3Rpb24gQnV0dG9uXG5cdFx0Y29uc3QgdGVzdEJ1dHRvbiA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdUZXN0IERhdGFiYXNlIENvbm5lY3Rpb24nIH0pO1xuXHRcdHRlc3RCdXR0b24ub25DbGlja0V2ZW50KGFzeW5jICgpID0+IHtcblx0XHRcdHRlc3RCdXR0b24uc2V0QXR0cignZGlzYWJsZWQnLCAndHJ1ZScpO1xuXHRcdFx0c3RhdHVzVGV4dC5zZXRUZXh0KCdUZXN0aW5nIGNvbm5lY3Rpb24uLi4nKTtcblx0XHRcdFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3Qgc3VwYWJhc2UgPSBhd2FpdCBTdXBhYmFzZVNlcnZpY2UuZ2V0SW5zdGFuY2UodGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xuXHRcdFx0XHRpZiAoIXN1cGFiYXNlKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dC5zZXRUZXh0KCdcdTI3NEMgRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQ6IEludmFsaWQgY3JlZGVudGlhbHMnKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBzZXR1cFN0YXR1cyA9IGF3YWl0IHN1cGFiYXNlLmNoZWNrRGF0YWJhc2VTZXR1cCgpO1xuXHRcdFx0XHRpZiAoc2V0dXBTdGF0dXMuaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQuc2V0VGV4dCgnXHUyNzA1IERhdGFiYXNlIGNvbm5lY3Rpb24gc3VjY2Vzc2Z1bCBhbmQgYWxsIHRhYmxlcyBhcmUgc2V0IHVwIGNvcnJlY3RseScpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCBtZXNzYWdlID0gJ1x1MjZBMFx1RkUwRiBEYXRhYmFzZSBzZXR1cCBpbmNvbXBsZXRlOic7XG5cdFx0XHRcdFx0aWYgKHNldHVwU3RhdHVzLm1pc3NpbmdUYWJsZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0bWVzc2FnZSArPSBgXFxuTWlzc2luZyB0YWJsZXM6ICR7c2V0dXBTdGF0dXMubWlzc2luZ1RhYmxlcy5qb2luKCcsICcpfWA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzZXR1cFN0YXR1cy5lcnJvcikge1xuXHRcdFx0XHRcdFx0bWVzc2FnZSArPSBgXFxuRXJyb3I6ICR7c2V0dXBTdGF0dXMuZXJyb3J9YDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3RhdHVzVGV4dC5zZXRUZXh0KG1lc3NhZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRzdGF0dXNUZXh0LnNldFRleHQoYFx1Mjc0QyBEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZDogJHsoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2V9YCk7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHR0ZXN0QnV0dG9uLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIFJlc2V0IERhdGFiYXNlIEJ1dHRvblxuXHRcdGNvbnN0IHJlc2V0QnV0dG9uID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ2J1dHRvbicsIHsgXG5cdFx0XHR0ZXh0OiAnUmVzZXQgRGF0YWJhc2UnLFxuXHRcdFx0Y2xzOiAnbW9kLXdhcm5pbmcnXG5cdFx0fSk7XG5cdFx0cmVzZXRCdXR0b24ub25DbGlja0V2ZW50KGFzeW5jICgpID0+IHtcblx0XHRcdGNvbnN0IGNvbmZpcm1lZCA9IGF3YWl0IG5ldyBQcm9taXNlPGJvb2xlYW4+KChyZXNvbHZlKSA9PiB7XG5cdFx0XHRcdGNvbnN0IG5vdGljZSA9IG5ldyBOb3RpY2UoJ1RoaXMgd2lsbCBkZWxldGUgYWxsIGRhdGEgaW4gdGhlIGRhdGFiYXNlLiBBcmUgeW91IHN1cmU/Jyk7XG5cdFx0XHRcdG5vdGljZS5zZXRNZXNzYWdlKCdUaGlzIHdpbGwgZGVsZXRlIGFsbCBkYXRhIGluIHRoZSBkYXRhYmFzZS4gQXJlIHlvdSBzdXJlPycsIFtcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0ZXh0OiAnWWVzJyxcblx0XHRcdFx0XHRcdGNhbGxiYWNrOiAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdG5vdGljZS5oaWRlKCk7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUodHJ1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0ZXh0OiAnTm8nLFxuXHRcdFx0XHRcdFx0Y2FsbGJhY2s6ICgpID0+IHtcblx0XHRcdFx0XHRcdFx0bm90aWNlLmhpZGUoKTtcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShmYWxzZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRdKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoIWNvbmZpcm1lZCkgcmV0dXJuO1xuXG5cdFx0XHRyZXNldEJ1dHRvbi5zZXRBdHRyKCdkaXNhYmxlZCcsICd0cnVlJyk7XG5cdFx0XHRzdGF0dXNUZXh0LnNldFRleHQoJ1Jlc2V0dGluZyBkYXRhYmFzZS4uLicpO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCBzdXBhYmFzZSA9IGF3YWl0IFN1cGFiYXNlU2VydmljZS5nZXRJbnN0YW5jZSh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XG5cdFx0XHRcdGlmICghc3VwYWJhc2UpIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0LnNldFRleHQoJ1x1Mjc0QyBEYXRhYmFzZSByZXNldCBmYWlsZWQ6IEludmFsaWQgY3JlZGVudGlhbHMnKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCBzdXBhYmFzZS5yZXNldERhdGFiYXNlKCk7XG5cdFx0XHRcdGlmIChyZXN1bHQuc3VjY2Vzcykge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQuc2V0VGV4dCgnXHUyNzA1IERhdGFiYXNlIHJlc2V0IHN1Y2Nlc3NmdWxseScpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQuc2V0VGV4dChgXHUyNzRDIERhdGFiYXNlIHJlc2V0IGZhaWxlZDogJHtyZXN1bHQubWVzc2FnZX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0c3RhdHVzVGV4dC5zZXRUZXh0KGBcdTI3NEMgRGF0YWJhc2UgcmVzZXQgZmFpbGVkOiAkeyhlcnJvciBhcyBFcnJvcikubWVzc2FnZX1gKTtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHJlc2V0QnV0dG9uLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgc2hvd1Jlc2V0Q29uZmlybWF0aW9uKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuXHRcdFx0Y29uc3QgbW9kYWwgPSB0aGlzLmFwcC5tb2RhbDtcblx0XHRcdG1vZGFsLm9wZW4oKG1vZGFsKSA9PiB7XG5cdFx0XHRcdG1vZGFsLnRpdGxlRWwuc2V0VGV4dCgnUmVzZXQgVmF1bHQgSUQnKTtcblx0XHRcdFx0bW9kYWwuY29udGVudEVsLnNldFRleHQoXG5cdFx0XHRcdFx0J1dhcm5pbmc6IFJlc2V0dGluZyB0aGUgdmF1bHQgSUQgd2lsbCBkaXNjb25uZWN0IHRoaXMgdmF1bHQgZnJvbSBpdHMgZXhpc3RpbmcgZGF0YWJhc2UgZW50cmllcy4gVGhpcyBvcGVyYXRpb24gY2Fubm90IGJlIHVuZG9uZS4gQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGNvbnRpbnVlPydcblx0XHRcdFx0KTtcblx0XHRcdFx0bW9kYWwuYWRkQnV0dG9uKChidG4pID0+IHtcblx0XHRcdFx0XHRidG4uc2V0QnV0dG9uVGV4dCgnQ2FuY2VsJykub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKGZhbHNlKTtcblx0XHRcdFx0XHRcdG1vZGFsLmNsb3NlKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRtb2RhbC5hZGRCdXR0b24oKGJ0bikgPT4ge1xuXHRcdFx0XHRcdGJ0bi5zZXRCdXR0b25UZXh0KCdSZXNldCcpLnNldFdhcm5pbmcoKS5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHRcdHJlc29sdmUodHJ1ZSk7XG5cdFx0XHRcdFx0XHRtb2RhbC5jbG9zZSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG59XG4iLCAiLy8gc3JjL3NlcnZpY2VzL0luaXRpYWxTeW5jTWFuYWdlci50c1xuaW1wb3J0IHsgVEZpbGUsIFZhdWx0LCBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBFcnJvckhhbmRsZXIgfSBmcm9tICcuLi91dGlscy9FcnJvckhhbmRsZXInO1xuaW1wb3J0IHsgTm90aWZpY2F0aW9uTWFuYWdlciB9IGZyb20gJy4uL3V0aWxzL05vdGlmaWNhdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgUXVldWVTZXJ2aWNlIH0gZnJvbSAnLi9RdWV1ZVNlcnZpY2UnO1xuaW1wb3J0IHsgU3luY0ZpbGVNYW5hZ2VyIH0gZnJvbSAnLi9TeW5jRmlsZU1hbmFnZXInO1xuaW1wb3J0IHsgTWV0YWRhdGFFeHRyYWN0b3IgfSBmcm9tICcuL01ldGFkYXRhRXh0cmFjdG9yJztcbmltcG9ydCB7IFN1cGFiYXNlU2VydmljZSB9IGZyb20gJy4vU3VwYWJhc2VTZXJ2aWNlJztcblxuaW50ZXJmYWNlIEluaXRpYWxTeW5jT3B0aW9ucyB7XG5cdGJhdGNoU2l6ZTogbnVtYmVyO1xuXHRtYXhDb25jdXJyZW50QmF0Y2hlczogbnVtYmVyO1xuXHRlbmFibGVBdXRvSW5pdGlhbFN5bmM6IGJvb2xlYW47XG5cdHByaW9yaXR5UnVsZXM6IFByaW9yaXR5UnVsZVtdO1xuXHRzeW5jRmlsZVBhdGg/OiBzdHJpbmc7XG5cdGV4Y2x1c2lvbnM/OiB7XG5cdFx0ZXhjbHVkZWRGb2xkZXJzOiBzdHJpbmdbXTtcblx0XHRleGNsdWRlZEZpbGVUeXBlczogc3RyaW5nW107XG5cdFx0ZXhjbHVkZWRGaWxlUHJlZml4ZXM6IHN0cmluZ1tdO1xuXHRcdGV4Y2x1ZGVkRmlsZXM6IHN0cmluZ1tdO1xuXHR9O1xufVxuXG5pbnRlcmZhY2UgUHJpb3JpdHlSdWxlIHtcblx0cGF0dGVybjogc3RyaW5nO1xuXHRwcmlvcml0eTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgU3luY0JhdGNoIHtcblx0aWQ6IHN0cmluZztcblx0ZmlsZXM6IFRGaWxlW107XG5cdHN0YXR1czogJ3BlbmRpbmcnIHwgJ3Byb2Nlc3NpbmcnIHwgJ2NvbXBsZXRlZCcgfCAnZmFpbGVkJztcblx0cHJvZ3Jlc3M6IG51bWJlcjtcblx0c3RhcnRUaW1lPzogbnVtYmVyO1xuXHRlbmRUaW1lPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNQcm9ncmVzcyB7XG5cdHRvdGFsRmlsZXM6IG51bWJlcjtcblx0cHJvY2Vzc2VkRmlsZXM6IG51bWJlcjtcblx0Y3VycmVudEJhdGNoOiBudW1iZXI7XG5cdHRvdGFsQmF0Y2hlczogbnVtYmVyO1xuXHRzdGFydFRpbWU6IG51bWJlcjtcblx0ZXN0aW1hdGVkVGltZVJlbWFpbmluZz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEluaXRpYWxTeW5jTWFuYWdlciB7XG5cdHByaXZhdGUgYmF0Y2hlczogU3luY0JhdGNoW10gPSBbXTtcblx0cHJpdmF0ZSBwcm9ncmVzczogU3luY1Byb2dyZXNzO1xuXHRwcml2YXRlIGlzUnVubmluZzogYm9vbGVhbiA9IGZhbHNlO1xuXHRwcml2YXRlIGxhc3RQcm9jZXNzZWRJbmRleDogbnVtYmVyID0gMDsgLy8gRm9yIHJlc3VtaW5nIGludGVycnVwdGVkIHN5bmNzXG5cdHByaXZhdGUgcHJvY2Vzc2luZ1RpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogSW5pdGlhbFN5bmNPcHRpb25zO1xuXHRwcml2YXRlIHN1cGFiYXNlU2VydmljZTogU3VwYWJhc2VTZXJ2aWNlIHwgbnVsbDtcblx0cHJpdmF0ZSByZXN1bWVGaWxlTGlzdDogVEZpbGVbXSA9IFtdO1xuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByaXZhdGUgdmF1bHQ6IFZhdWx0LFxuXHRcdHByaXZhdGUgcXVldWVTZXJ2aWNlOiBRdWV1ZVNlcnZpY2UsXG5cdFx0cHJpdmF0ZSBzeW5jTWFuYWdlcjogU3luY0ZpbGVNYW5hZ2VyLFxuXHRcdHByaXZhdGUgbWV0YWRhdGFFeHRyYWN0b3I6IE1ldGFkYXRhRXh0cmFjdG9yLFxuXHRcdHByaXZhdGUgZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXIsXG5cdFx0cHJpdmF0ZSBub3RpZmljYXRpb25NYW5hZ2VyOiBOb3RpZmljYXRpb25NYW5hZ2VyLFxuXHRcdHN1cGFiYXNlU2VydmljZTogU3VwYWJhc2VTZXJ2aWNlIHwgbnVsbCxcblx0XHRvcHRpb25zOiBQYXJ0aWFsPEluaXRpYWxTeW5jT3B0aW9ucz4gPSB7fVxuXHQpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSB7XG5cdFx0XHRiYXRjaFNpemU6IDUwLFxuXHRcdFx0bWF4Q29uY3VycmVudEJhdGNoZXM6IDMsXG5cdFx0XHRlbmFibGVBdXRvSW5pdGlhbFN5bmM6IHRydWUsXG5cdFx0XHRwcmlvcml0eVJ1bGVzOiBbXSxcblx0XHRcdHN5bmNGaWxlUGF0aDogJ19taW5kbWF0cml4c3luYy5tZCcsXG5cdFx0XHRleGNsdXNpb25zOiB7XG5cdFx0XHRcdGV4Y2x1ZGVkRm9sZGVyczogW10sXG5cdFx0XHRcdGV4Y2x1ZGVkRmlsZVR5cGVzOiBbXSxcblx0XHRcdFx0ZXhjbHVkZWRGaWxlUHJlZml4ZXM6IFtdLFxuXHRcdFx0XHRleGNsdWRlZEZpbGVzOiBbXVxuXHRcdFx0fSxcblx0XHRcdC4uLm9wdGlvbnNcblx0XHR9O1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSB7XG5cdFx0XHR0b3RhbEZpbGVzOiAwLFxuXHRcdFx0cHJvY2Vzc2VkRmlsZXM6IDAsXG5cdFx0XHRjdXJyZW50QmF0Y2g6IDAsXG5cdFx0XHR0b3RhbEJhdGNoZXM6IDAsXG5cdFx0XHRzdGFydFRpbWU6IDBcblx0XHR9O1xuXHRcdHRoaXMuc3VwYWJhc2VTZXJ2aWNlID0gc3VwYWJhc2VTZXJ2aWNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZpbHRlcnMgZmlsZXMgYmFzZWQgb24gZXhjbHVzaW9uIHJ1bGVzLlxuXHQgKi9cblx0cHJpdmF0ZSBmaWx0ZXJFeGNsdWRlZEZpbGVzKGZpbGVzOiBURmlsZVtdKTogVEZpbGVbXSB7XG5cdFx0Y29uc3Qgc3luY0ZpbGVQYXRoID0gdGhpcy5vcHRpb25zLnN5bmNGaWxlUGF0aCB8fCAnX21pbmRtYXRyaXhzeW5jLm1kJztcblx0XHRjb25zdCBleGNsdXNpb25zID0gdGhpcy5vcHRpb25zLmV4Y2x1c2lvbnMgfHwge1xuXHRcdFx0ZXhjbHVkZWRGb2xkZXJzOiBbXSxcblx0XHRcdGV4Y2x1ZGVkRmlsZVR5cGVzOiBbXSxcblx0XHRcdGV4Y2x1ZGVkRmlsZVByZWZpeGVzOiBbXSxcblx0XHRcdGV4Y2x1ZGVkRmlsZXM6IFtdXG5cdFx0fTtcblxuXHRcdHJldHVybiBmaWxlcy5maWx0ZXIoZmlsZSA9PiB7XG5cdFx0XHRjb25zdCBmaWxlUGF0aCA9IGZpbGUucGF0aDtcblx0XHRcdGNvbnN0IGZpbGVOYW1lID0gZmlsZS5uYW1lO1xuXHRcdFx0Ly8gRXhjbHVkZSBzeW5jIGZpbGVzIGV4cGxpY2l0bHlcblx0XHRcdGlmIChcblx0XHRcdFx0ZmlsZVBhdGggPT09IHN5bmNGaWxlUGF0aCB8fFxuXHRcdFx0XHRmaWxlUGF0aCA9PT0gJ19taW5kbWF0cml4c3luYy5tZCcgfHxcblx0XHRcdFx0ZmlsZVBhdGggPT09ICdfbWluZG1hdHJpeHN5bmMubWQuYmFja3VwJ1xuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmIChleGNsdXNpb25zLmV4Y2x1ZGVkRmlsZXMuaW5jbHVkZXMoZmlsZU5hbWUpKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRpZiAoZXhjbHVzaW9ucy5leGNsdWRlZEZvbGRlcnMuc29tZShmb2xkZXIgPT4gZmlsZVBhdGguc3RhcnRzV2l0aChmb2xkZXIuZW5kc1dpdGgoJy8nKSA/IGZvbGRlciA6IGZvbGRlciArICcvJykpKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRpZiAoZXhjbHVzaW9ucy5leGNsdWRlZEZpbGVUeXBlcy5zb21lKGV4dCA9PiBmaWxlUGF0aC50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dC50b0xvd2VyQ2FzZSgpKSkpIHJldHVybiBmYWxzZTtcblx0XHRcdGlmIChleGNsdXNpb25zLmV4Y2x1ZGVkRmlsZVByZWZpeGVzLnNvbWUocHJlZml4ID0+IGZpbGVOYW1lLnN0YXJ0c1dpdGgocHJlZml4KSkpIHJldHVybiBmYWxzZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyB0aGUgaW5pdGlhbCBzeW5jIHByb2Nlc3MuXG5cdCAqIFNjYW5zIGFsbCBtYXJrZG93biBmaWxlcyBpbiB0aGUgdmF1bHQgYW5kIHVwZGF0ZXMgdGhlaXIgc3RhdHVzIGluIHRoZSBkYXRhYmFzZS5cblx0ICogUmVzdW1lcyBmcm9tIHRoZSBsYXN0IHByb2Nlc3NlZCBmaWxlIGlmIHRoZSBzeW5jIGlzIGludGVycnVwdGVkLlxuXHQgKi9cblx0YXN5bmMgc3RhcnRTeW5jKCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICh0aGlzLmlzUnVubmluZykge1xuXHRcdFx0Y29uc29sZS5sb2coJ0luaXRpYWwgc3luYyBhbHJlYWR5IHJ1bm5pbmcnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcblx0XHRcdHRoaXMucHJvZ3Jlc3Muc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdGNvbnNvbGUubG9nKCdTdGFydGluZyBpbml0aWFsIHN5bmMuLi4nKTtcblxuXHRcdFx0Ly8gR2V0IGFuZCBmaWx0ZXIgYWxsIG1hcmtkb3duIGZpbGVzXG5cdFx0XHRjb25zdCBhbGxGaWxlcyA9IHRoaXMudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuXHRcdFx0Y29uc3QgZmlsZXMgPSB0aGlzLmZpbHRlckV4Y2x1ZGVkRmlsZXMoYWxsRmlsZXMpO1xuXHRcdFx0dGhpcy5yZXN1bWVGaWxlTGlzdCA9IGF3YWl0IHRoaXMuc29ydEZpbGVzQnlQcmlvcml0eShmaWxlcyk7XG5cdFx0XHR0aGlzLnByb2dyZXNzLnRvdGFsRmlsZXMgPSB0aGlzLnJlc3VtZUZpbGVMaXN0Lmxlbmd0aDtcblx0XHRcdGNvbnNvbGUubG9nKGBUb3RhbCBmaWxlcyB0byBzeW5jOiAke3RoaXMucHJvZ3Jlc3MudG90YWxGaWxlc31gKTtcblxuXHRcdFx0Ly8gQ3JlYXRlIGJhdGNoZXMgZnJvbSB0aGUgZmlsZXMgc3RhcnRpbmcgZnJvbSBsYXN0UHJvY2Vzc2VkSW5kZXhcblx0XHRcdHRoaXMuYmF0Y2hlcyA9IHRoaXMuY3JlYXRlQmF0Y2hlcyh0aGlzLnJlc3VtZUZpbGVMaXN0LnNsaWNlKHRoaXMubGFzdFByb2Nlc3NlZEluZGV4KSk7XG5cdFx0XHR0aGlzLnByb2dyZXNzLnRvdGFsQmF0Y2hlcyA9IHRoaXMuYmF0Y2hlcy5sZW5ndGg7XG5cdFx0XHRjb25zb2xlLmxvZyhgQ3JlYXRlZCAke3RoaXMucHJvZ3Jlc3MudG90YWxCYXRjaGVzfSBiYXRjaGVzIGZvciBzeW5jaW5nYCk7XG5cblx0XHRcdC8vIFByb2Nlc3MgZWFjaCBiYXRjaCBjb25jdXJyZW50bHkgd2l0aCBhIGxpbWl0XG5cdFx0XHRhd2FpdCB0aGlzLnByb2Nlc3NCYXRjaGVzKCk7XG5cblx0XHRcdG5ldyBOb3RpY2UoJ0luaXRpYWwgc3luYyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG5cdFx0XHRjb25zb2xlLmxvZygnSW5pdGlhbCBzeW5jIGNvbXBsZXRlZCcpO1xuXHRcdFx0Ly8gUmVzZXQgcmVzdW1lIGluZGV4IG9uIHN1Y2Nlc3Ncblx0XHRcdHRoaXMubGFzdFByb2Nlc3NlZEluZGV4ID0gMDtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ0luaXRpYWxTeW5jTWFuYWdlci5zdGFydFN5bmMnIH0pO1xuXHRcdFx0bmV3IE5vdGljZSgnSW5pdGlhbCBzeW5jIGZhaWxlZC4gQ2hlY2sgY29uc29sZSBmb3IgZGV0YWlscy4nKTtcblx0XHRcdC8vIFJlc3VtZSBmcm9tIHRoZSBsYXN0IHByb2Nlc3NlZCBpbmRleCBvbiBmYWlsdXJlXG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNvcnQgZmlsZXMgYnkgcHJpb3JpdHkgYmFzZWQgb24gcnVsZXMuXG5cdCAqIEZpbGVzIG1hdGNoaW5nIGhpZ2hlciBwcmlvcml0eSBydWxlcyBhcmUgc29ydGVkIHRvIHRoZSBmcm9udC5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgc29ydEZpbGVzQnlQcmlvcml0eShmaWxlczogVEZpbGVbXSk6IFByb21pc2U8VEZpbGVbXT4ge1xuXHRcdHJldHVybiBmaWxlcy5zb3J0KChhLCBiKSA9PiB7XG5cdFx0XHRjb25zdCBwcmlvcml0eUEgPSB0aGlzLmdldEZpbGVQcmlvcml0eShhLnBhdGgpO1xuXHRcdFx0Y29uc3QgcHJpb3JpdHlCID0gdGhpcy5nZXRGaWxlUHJpb3JpdHkoYi5wYXRoKTtcblx0XHRcdGNvbnNvbGUubG9nKGBQcmlvcml0eSBmb3IgJHthLnBhdGh9OiAke3ByaW9yaXR5QX0sICR7Yi5wYXRofTogJHtwcmlvcml0eUJ9YCk7XG5cdFx0XHRyZXR1cm4gcHJpb3JpdHlCIC0gcHJpb3JpdHlBO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgcHJvY2Vzc2luZyBwcmlvcml0eSBmb3IgYSBmaWxlLlxuXHQgKiBSZXR1cm5zIHRoZSBoaWdoZXN0IG1hdGNoaW5nIHJ1bGUgcHJpb3JpdHkgb3IgZGVmYXVsdHMgdG8gMS5cblx0ICovXG5cdHByaXZhdGUgZ2V0RmlsZVByaW9yaXR5KHBhdGg6IHN0cmluZyk6IG51bWJlciB7XG5cdFx0Zm9yIChjb25zdCBydWxlIG9mIHRoaXMub3B0aW9ucy5wcmlvcml0eVJ1bGVzKSB7XG5cdFx0XHRpZiAocGF0aC5pbmNsdWRlcyhydWxlLnBhdHRlcm4pKSB7XG5cdFx0XHRcdHJldHVybiBydWxlLnByaW9yaXR5O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYmF0Y2hlcyBvZiBmaWxlcyBmb3IgcHJvY2Vzc2luZy5cblx0ICovXG5cdHByaXZhdGUgY3JlYXRlQmF0Y2hlcyhmaWxlczogVEZpbGVbXSk6IFN5bmNCYXRjaFtdIHtcblx0XHRjb25zdCBzeW5jRmlsZVBhdGggPSB0aGlzLm9wdGlvbnMuc3luY0ZpbGVQYXRoIHx8ICdfbWluZG1hdHJpeHN5bmMubWQnO1xuXHRcdC8vIEVuc3VyZSBzeW5jIGZpbGUgaXMgbm90IGluY2x1ZGVkXG5cdFx0ZmlsZXMgPSBmaWxlcy5maWx0ZXIoZmlsZSA9PiBmaWxlLnBhdGggIT09IHN5bmNGaWxlUGF0aCAmJiBmaWxlLnBhdGggIT09ICdfbWluZG1hdHJpeHN5bmMubWQnICYmIGZpbGUucGF0aCAhPT0gJ19taW5kbWF0cml4c3luYy5tZC5iYWNrdXAnKTtcblx0XHRjb25zdCBiYXRjaGVzOiBTeW5jQmF0Y2hbXSA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpICs9IHRoaXMub3B0aW9ucy5iYXRjaFNpemUpIHtcblx0XHRcdGNvbnN0IGJhdGNoRmlsZXMgPSBmaWxlcy5zbGljZShpLCBpICsgdGhpcy5vcHRpb25zLmJhdGNoU2l6ZSk7XG5cdFx0XHRiYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRpZDogYGJhdGNoLSR7TWF0aC5mbG9vcihpIC8gdGhpcy5vcHRpb25zLmJhdGNoU2l6ZSl9YCxcblx0XHRcdFx0ZmlsZXM6IGJhdGNoRmlsZXMsXG5cdFx0XHRcdHN0YXR1czogJ3BlbmRpbmcnLFxuXHRcdFx0XHRwcm9ncmVzczogMFxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBiYXRjaGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgYmF0Y2hlcyBjb25jdXJyZW50bHkgd2l0aCBhIGxpbWl0LlxuXHQgKiBVcGRhdGVzIHJlc3VtZSBwcm9ncmVzcyBpbiBjYXNlIG9mIGludGVycnVwdGlvbi5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc0JhdGNoZXMoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgYWN0aXZlQmF0Y2hlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXHRcdGZvciAoY29uc3QgYmF0Y2ggb2YgdGhpcy5iYXRjaGVzKSB7XG5cdFx0XHQvLyBXYWl0IHVudGlsIGFjdGl2ZSBiYXRjaGVzIGFyZSBiZWxvdyB0aGUgY29uY3VycmVudCBsaW1pdFxuXHRcdFx0d2hpbGUgKGFjdGl2ZUJhdGNoZXMuc2l6ZSA+PSB0aGlzLm9wdGlvbnMubWF4Q29uY3VycmVudEJhdGNoZXMpIHtcblx0XHRcdFx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuXHRcdFx0fVxuXHRcdFx0YWN0aXZlQmF0Y2hlcy5hZGQoYmF0Y2guaWQpO1xuXHRcdFx0dGhpcy5wcm9jZXNzQmF0Y2goYmF0Y2gpXG5cdFx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRhY3RpdmVCYXRjaGVzLmRlbGV0ZShiYXRjaC5pZCk7XG5cdFx0XHRcdFx0Ly8gVXBkYXRlIHJlc3VtZSBpbmRleCBhZnRlciBiYXRjaCBjb21wbGV0ZXNcblx0XHRcdFx0XHR0aGlzLmxhc3RQcm9jZXNzZWRJbmRleCArPSBiYXRjaC5maWxlcy5sZW5ndGg7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coYENvbXBsZXRlZCAke2JhdGNoLmlkfSwgcmVzdW1pbmcgYXQgaW5kZXggJHt0aGlzLmxhc3RQcm9jZXNzZWRJbmRleH1gKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmNhdGNoKGVycm9yID0+IHtcblx0XHRcdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnSW5pdGlhbFN5bmNNYW5hZ2VyLnByb2Nlc3NCYXRjaCcsIG1ldGFkYXRhOiB7IGJhdGNoSWQ6IGJhdGNoLmlkIH0gfSk7XG5cdFx0XHRcdFx0YWN0aXZlQmF0Y2hlcy5kZWxldGUoYmF0Y2guaWQpO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cdFx0Ly8gV2FpdCB1bnRpbCBhbGwgYmF0Y2hlcyBhcmUgcHJvY2Vzc2VkXG5cdFx0d2hpbGUgKGFjdGl2ZUJhdGNoZXMuc2l6ZSA+IDApIHtcblx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUHJvY2VzcyBhIHNpbmdsZSBiYXRjaCBvZiBmaWxlcy5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgcHJvY2Vzc0JhdGNoKGJhdGNoOiBTeW5jQmF0Y2gpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0cnkge1xuXHRcdFx0YmF0Y2guc3RhdHVzID0gJ3Byb2Nlc3NpbmcnO1xuXHRcdFx0YmF0Y2guc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nICR7YmF0Y2guaWR9IHdpdGggJHtiYXRjaC5maWxlcy5sZW5ndGh9IGZpbGVzYCk7XG5cdFx0XHRmb3IgKGNvbnN0IGZpbGUgb2YgYmF0Y2guZmlsZXMpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnByb2Nlc3NGaWxlKGZpbGUpO1xuXHRcdFx0XHRcdHRoaXMucHJvZ3Jlc3MucHJvY2Vzc2VkRmlsZXMrKztcblx0XHRcdFx0XHRiYXRjaC5wcm9ncmVzcyA9ICh0aGlzLnByb2dyZXNzLnByb2Nlc3NlZEZpbGVzIC8gdGhpcy5wcm9ncmVzcy50b3RhbEZpbGVzKSAqIDEwMDtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZVByb2dyZXNzTm90aWZpY2F0aW9uKCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0dGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIHsgY29udGV4dDogJ0luaXRpYWxTeW5jTWFuYWdlci5wcm9jZXNzRmlsZScsIG1ldGFkYXRhOiB7IGZpbGVQYXRoOiBmaWxlLnBhdGggfSB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YmF0Y2guc3RhdHVzID0gJ2NvbXBsZXRlZCc7XG5cdFx0XHRiYXRjaC5lbmRUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdGNvbnNvbGUubG9nKGBCYXRjaCAke2JhdGNoLmlkfSBjb21wbGV0ZWQgaW4gJHtiYXRjaC5lbmRUaW1lIC0gKGJhdGNoLnN0YXJ0VGltZSB8fCAwKX0gbXNgKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0YmF0Y2guc3RhdHVzID0gJ2ZhaWxlZCc7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUHJvY2VzcyBhIHNpbmdsZSBmaWxlLlxuXHQgKiBFeHRyYWN0cyBtZXRhZGF0YSwgY2FsY3VsYXRlcyBmaWxlIGhhc2gsIGFuZCB1cGRhdGVzIGl0cyBzdGF0dXMuXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIHByb2Nlc3NGaWxlKGZpbGU6IFRGaWxlKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIFNraXAgc3luYyBmaWxlIGlmIHNvbWVob3cgcmVhY2hlZCBoZXJlXG5cdFx0XHRjb25zdCBzeW5jRmlsZVBhdGggPSB0aGlzLm9wdGlvbnMuc3luY0ZpbGVQYXRoIHx8ICdfbWluZG1hdHJpeHN5bmMubWQnO1xuXHRcdFx0aWYgKGZpbGUucGF0aCA9PT0gc3luY0ZpbGVQYXRoIHx8IGZpbGUucGF0aCA9PT0gJ19taW5kbWF0cml4c3luYy5tZCcgfHwgZmlsZS5wYXRoID09PSAnX21pbmRtYXRyaXhzeW5jLm1kLmJhY2t1cCcpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLm1ldGFkYXRhRXh0cmFjdG9yLmV4dHJhY3RNZXRhZGF0YShmaWxlKTtcblx0XHRcdGNvbnN0IGZpbGVIYXNoID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVGaWxlSGFzaChmaWxlKTtcblx0XHRcdC8vIFVwZGF0ZSBmaWxlIHN0YXR1cyBpbiB0aGUgZGF0YWJhc2UgaWYgYXZhaWxhYmxlOyBlbHNlLCB1cGRhdGUgc3luYyBmaWxlIHN0YXR1cy5cblx0XHRcdGlmICh0aGlzLnN1cGFiYXNlU2VydmljZSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS51cGRhdGVGaWxlVmVjdG9yaXphdGlvblN0YXR1cyhtZXRhZGF0YSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnN5bmNNYW5hZ2VyLnVwZGF0ZVN5bmNTdGF0dXMoZmlsZS5wYXRoLCAnUEVORElORycsIHtcblx0XHRcdFx0XHRsYXN0TW9kaWZpZWQ6IGZpbGUuc3RhdC5tdGltZSxcblx0XHRcdFx0XHRoYXNoOiBmaWxlSGFzaFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdC8vIFF1ZXVlIGZpbGUgcHJvY2Vzc2luZyBmb3IgZnVydGhlciBzdGVwcyAobGlrZSBlbWJlZGRpbmcgZ2VuZXJhdGlvbilcblx0XHRcdGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdFx0dGhpcy5xdWV1ZVNlcnZpY2UuYWRkVGFzayh7XG5cdFx0XHRcdFx0aWQ6IGZpbGUucGF0aCxcblx0XHRcdFx0XHR0eXBlOiAnQ1JFQVRFJyxcblx0XHRcdFx0XHRwcmlvcml0eTogdGhpcy5nZXRGaWxlUHJpb3JpdHkoZmlsZS5wYXRoKSxcblx0XHRcdFx0XHRtYXhSZXRyaWVzOiAzLFxuXHRcdFx0XHRcdHJldHJ5Q291bnQ6IDAsXG5cdFx0XHRcdFx0Y3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuXHRcdFx0XHRcdHVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcblx0XHRcdFx0XHRzdGF0dXM6ICdQRU5ESU5HJyxcblx0XHRcdFx0XHRtZXRhZGF0YSxcblx0XHRcdFx0XHRkYXRhOiB7fVxuXHRcdFx0XHR9KS50aGVuKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHQvLyBNYXJrIGZpbGUgYXMgcHJvY2Vzc2VkIGluIHRoZSBkYXRhYmFzZSBvciBzeW5jIGZpbGUuXG5cdFx0XHRcdFx0aWYgKHRoaXMuc3VwYWJhc2VTZXJ2aWNlKSB7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnN1cGFiYXNlU2VydmljZS51cGRhdGVGaWxlVmVjdG9yaXphdGlvblN0YXR1cyhtZXRhZGF0YSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuc3luY01hbmFnZXIudXBkYXRlU3luY1N0YXR1cyhmaWxlLnBhdGgsICdPSycsIHtcblx0XHRcdFx0XHRcdFx0bGFzdE1vZGlmaWVkOiBmaWxlLnN0YXQubXRpbWUsXG5cdFx0XHRcdFx0XHRcdGhhc2g6IGZpbGVIYXNoXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHR9KS5jYXRjaChyZWplY3QpO1xuXHRcdFx0fSk7XG5cdFx0XHRjb25zb2xlLmxvZyhgUHJvY2Vzc2VkIGZpbGU6ICR7ZmlsZS5wYXRofWApO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgeyBjb250ZXh0OiAnSW5pdGlhbFN5bmNNYW5hZ2VyLnByb2Nlc3NGaWxlJywgbWV0YWRhdGE6IHsgZmlsZVBhdGg6IGZpbGUucGF0aCB9IH0pO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSBTSEEtMjU2IGhhc2ggb2YgYSBmaWxlJ3MgY29udGVudC5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgY2FsY3VsYXRlRmlsZUhhc2goZmlsZTogVEZpbGUpOiBQcm9taXNlPHN0cmluZz4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkKGZpbGUpO1xuXHRcdFx0Y29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXHRcdFx0Y29uc3QgZGF0YSA9IGVuY29kZXIuZW5jb2RlKGNvbnRlbnQpO1xuXHRcdFx0Y29uc3QgYnVmZmVyID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBkYXRhKTtcblx0XHRcdHJldHVybiBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpXG5cdFx0XHRcdC5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKVxuXHRcdFx0XHQuam9pbignJyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCB7IGNvbnRleHQ6ICdJbml0aWFsU3luY01hbmFnZXIuY2FsY3VsYXRlRmlsZUhhc2gnLCBtZXRhZGF0YTogeyBmaWxlUGF0aDogZmlsZS5wYXRoIH0gfSk7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBwcm9ncmVzcyBub3RpZmljYXRpb25zLlxuXHQgKi9cblx0cHJpdmF0ZSB1cGRhdGVQcm9ncmVzc05vdGlmaWNhdGlvbigpOiB2b2lkIHtcblx0XHRjb25zdCBwcm9ncmVzc1BlcmNlbnRhZ2UgPSAodGhpcy5wcm9ncmVzcy5wcm9jZXNzZWRGaWxlcyAvIHRoaXMucHJvZ3Jlc3MudG90YWxGaWxlcykgKiAxMDA7XG5cdFx0dGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyLnVwZGF0ZVByb2dyZXNzKHtcblx0XHRcdHRhc2tJZDogJ2luaXRpYWwtc3luYycsXG5cdFx0XHRwcm9ncmVzczogcHJvZ3Jlc3NQZXJjZW50YWdlLFxuXHRcdFx0Y3VycmVudFN0ZXA6IGBQcm9jZXNzaW5nIGZpbGVzICgke3RoaXMucHJvZ3Jlc3MucHJvY2Vzc2VkRmlsZXN9LyR7dGhpcy5wcm9ncmVzcy50b3RhbEZpbGVzfSlgLFxuXHRcdFx0dG90YWxTdGVwczogdGhpcy5wcm9ncmVzcy50b3RhbEJhdGNoZXMsXG5cdFx0XHRjdXJyZW50U3RlcE51bWJlcjogdGhpcy5wcm9ncmVzcy5jdXJyZW50QmF0Y2ggKyAxLFxuXHRcdFx0ZXN0aW1hdGVkVGltZVJlbWFpbmluZzogdGhpcy5jYWxjdWxhdGVFc3RpbWF0ZWRUaW1lUmVtYWluaW5nKCksXG5cdFx0XHRkZXRhaWxzOiB7XG5cdFx0XHRcdHByb2Nlc3NlZEZpbGVzOiB0aGlzLnByb2dyZXNzLnByb2Nlc3NlZEZpbGVzLFxuXHRcdFx0XHR0b3RhbEZpbGVzOiB0aGlzLnByb2dyZXNzLnRvdGFsRmlsZXNcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgZXN0aW1hdGVkIHRpbWUgcmVtYWluaW5nIGJhc2VkIG9uIHByb2dyZXNzLlxuXHQgKi9cblx0cHJpdmF0ZSBjYWxjdWxhdGVFc3RpbWF0ZWRUaW1lUmVtYWluaW5nKCk6IG51bWJlciB7XG5cdFx0Y29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSB0aGlzLnByb2dyZXNzLnN0YXJ0VGltZTtcblx0XHRjb25zdCBmaWxlc1Blck1zID0gdGhpcy5wcm9ncmVzcy5wcm9jZXNzZWRGaWxlcyAvIGVsYXBzZWQ7XG5cdFx0Y29uc3QgcmVtYWluaW5nRmlsZXMgPSB0aGlzLnByb2dyZXNzLnRvdGFsRmlsZXMgLSB0aGlzLnByb2dyZXNzLnByb2Nlc3NlZEZpbGVzO1xuXHRcdHJldHVybiBmaWxlc1Blck1zID4gMCA/IHJlbWFpbmluZ0ZpbGVzIC8gZmlsZXNQZXJNcyA6IDA7XG5cdH1cblxuXHQvKipcblx0ICogU3RvcHMgdGhlIGluaXRpYWwgc3luYyBwcm9jZXNzLlxuXHQgKi9cblx0c3RvcCgpOiB2b2lkIHtcblx0XHR0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuXHRcdGlmICh0aGlzLnByb2Nlc3NpbmdUaW1lb3V0KSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5wcm9jZXNzaW5nVGltZW91dCk7XG5cdFx0XHR0aGlzLnByb2Nlc3NpbmdUaW1lb3V0ID0gbnVsbDtcblx0XHR9XG5cdFx0bmV3IE5vdGljZSgnSW5pdGlhbCBzeW5jIHN0b3BwZWQnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgY3VycmVudCBzeW5jIHByb2dyZXNzLlxuXHQgKi9cblx0Z2V0UHJvZ3Jlc3MoKTogU3luY1Byb2dyZXNzIHtcblx0XHRyZXR1cm4geyAuLi50aGlzLnByb2dyZXNzIH07XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHN5bmMgb3B0aW9ucy5cblx0ICovXG5cdHVwZGF0ZU9wdGlvbnMob3B0aW9uczogUGFydGlhbDxJbml0aWFsU3luY09wdGlvbnM+KTogdm9pZCB7XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXHR9XG59XG4iLCAiLy8gc3JjL3NlcnZpY2VzL1N0YXR1c01hbmFnZXIudHNcbmltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcblxuZXhwb3J0IGVudW0gUGx1Z2luU3RhdHVzIHtcbiAgICBJTklUSUFMSVpJTkcgPSAnaW5pdGlhbGl6aW5nJyxcbiAgICBXQUlUSU5HX0ZPUl9TWU5DID0gJ3dhaXRpbmdfc3luYycsXG4gICAgQ0hFQ0tJTkdfRklMRSA9ICdjaGVja2luZ19maWxlJyxcbiAgICBSRUFEWSA9ICdyZWFkeScsXG4gICAgRVJST1IgPSAnZXJyb3InLFxuICAgIFFVRVVJTkcgPSAncXVldWluZycsXG4gICAgUFJPQ0VTU0lOR19RVUVVRSA9ICdwcm9jZXNzaW5nX3F1ZXVlJyxcbiAgICBQRU5ESU5HID0gJ3BlbmRpbmcnLCAgICAgICAgIC8vIE5ldzogd2hlbiBhbiBvcGVyYXRpb24gaXMgcGVuZGluZ1xuICAgIElOX1BST0dSRVNTID0gJ2luX3Byb2dyZXNzJywgLy8gTmV3OiB3aGVuIGFuIG9wZXJhdGlvbiBpcyBhY3RpdmVseSBwcm9jZXNzaW5nXG4gICAgQ09NUExFVEVEID0gJ2NvbXBsZXRlZCcgICAgICAvLyBOZXc6IHdoZW4gYW4gb3BlcmF0aW9uIGhhcyBmaW5pc2hlZCBzdWNjZXNzZnVsbHlcbn1cblxuaW50ZXJmYWNlIFN0YXR1c0RldGFpbHMge1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgICBlcnJvcj86IEVycm9yO1xuICAgIHByb2dyZXNzPzogbnVtYmVyOyAvLyBQZXJjZW50YWdlICgwLTEwMClcbiAgICBxdWV1ZVNpemU/OiBudW1iZXI7XG4gICAgcGVuZGluZ0NoYW5nZXM/OiBudW1iZXI7XG4gICAgY29ubmVjdGl2aXR5U3RhdHVzPzogJ29ubGluZScgfCAnb2ZmbGluZScgfCAndW5rbm93bic7XG4gICAgbGFzdERhdGFiYXNlQ2hlY2s/OiBudW1iZXI7XG4gICAgLy8gQWRkaXRpb25hbCBkZXRhaWxzIGZvciBvcGVyYXRpb25zXG4gICAgb3BlcmF0aW9uPzogc3RyaW5nO1xuICAgIHN0ZXA/OiBzdHJpbmc7XG59XG5cbnR5cGUgU3RhdHVzQ2hhbmdlQ2FsbGJhY2sgPSAoc3RhdHVzOiBQbHVnaW5TdGF0dXMsIGRldGFpbHM6IFN0YXR1c0RldGFpbHMpID0+IHZvaWQ7XG5cbmV4cG9ydCBjbGFzcyBTdGF0dXNNYW5hZ2VyIHtcbiAgICBwcml2YXRlIGN1cnJlbnRTdGF0dXM6IFBsdWdpblN0YXR1cztcbiAgICBwcml2YXRlIHN0YXR1c0RldGFpbHM6IFN0YXR1c0RldGFpbHM7XG4gICAgcHJpdmF0ZSBzdGF0dXNCYXJJdGVtOiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIHN1YnNjcmliZXJzOiBTZXQ8U3RhdHVzQ2hhbmdlQ2FsbGJhY2s+O1xuXG4gICAgY29uc3RydWN0b3Ioc3RhdHVzQmFySXRlbTogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNCYXJJdGVtID0gc3RhdHVzQmFySXRlbTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdHVzID0gUGx1Z2luU3RhdHVzLklOSVRJQUxJWklORztcbiAgICAgICAgdGhpcy5zdGF0dXNEZXRhaWxzID0ge1xuICAgICAgICAgICAgbWVzc2FnZTogJ0luaXRpYWxpemluZyBwbHVnaW4uLi4nLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgY29ubmVjdGl2aXR5U3RhdHVzOiAndW5rbm93bidcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGN1cnJlbnQgc3RhdHVzIHdpdGggbmV3IGRldGFpbHMuXG4gICAgICovXG4gICAgcHVibGljIHNldFN0YXR1cyhzdGF0dXM6IFBsdWdpblN0YXR1cywgZGV0YWlsczogUGFydGlhbDxTdGF0dXNEZXRhaWxzPiA9IHt9KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG9sZFN0YXR1cyA9IHRoaXMuY3VycmVudFN0YXR1cztcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLnN0YXR1c0RldGFpbHMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnN0YXR1c0RldGFpbHMsXG4gICAgICAgICAgICAuLi5kZXRhaWxzLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKCk7XG4gICAgICAgIGlmIChvbGRTdGF0dXMgIT09IHN0YXR1cykge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09IFBsdWdpblN0YXR1cy5FUlJPUiAmJiBkZXRhaWxzLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYE1pbmQgTWF0cml4OiAke2RldGFpbHMubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBzdGF0dXMgYW5kIGRldGFpbHMuXG4gICAgICovXG4gICAgcHVibGljIGdldFN0YXR1cygpOiB7IHN0YXR1czogUGx1Z2luU3RhdHVzOyBkZXRhaWxzOiBTdGF0dXNEZXRhaWxzIH0ge1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHRoaXMuY3VycmVudFN0YXR1cywgZGV0YWlsczogeyAuLi50aGlzLnN0YXR1c0RldGFpbHMgfSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byBzdGF0dXMgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3Vic2NyaWJlKGNhbGxiYWNrOiBTdGF0dXNDaGFuZ2VDYWxsYmFjayk6ICgpID0+IHZvaWQge1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmFkZChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzdGF0dXMgYmFyIFVJLlxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlU3RhdHVzQmFyKCk6IHZvaWQge1xuICAgICAgICAvLyBDbGVhciBleGlzdGluZyBjb250ZW50XG4gICAgICAgIHRoaXMuc3RhdHVzQmFySXRlbS5pbm5lckhUTUwgPSAnJztcblxuICAgICAgICAvLyBDcmVhdGUgYW5kIGFwcGVuZCB0aGUgc3RhdHVzIGljb25cbiAgICAgICAgY29uc3QgaWNvbiA9IHRoaXMuY3JlYXRlU3RhdHVzSWNvbigpO1xuICAgICAgICB0aGlzLnN0YXR1c0Jhckl0ZW0uYXBwZW5kQ2hpbGQoaWNvbik7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFuZCBhcHBlbmQgdGhlIHN0YXR1cyBkZXRhaWxzIHRleHRcbiAgICAgICAgY29uc3QgZGV0YWlsc1RleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGRldGFpbHNUZXh0LmFkZENsYXNzKCdtaW5kLW1hdHJpeC1zdGF0dXMtZGV0YWlscycpO1xuICAgICAgICBsZXQgZGlzcGxheVRleHQgPSB0aGlzLnN0YXR1c0RldGFpbHMubWVzc2FnZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzRGV0YWlscy5vcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0ICs9IGAgWyR7dGhpcy5zdGF0dXNEZXRhaWxzLm9wZXJhdGlvbn1dYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXNEZXRhaWxzLnN0ZXApIHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0ICs9IGAgLSAke3RoaXMuc3RhdHVzRGV0YWlscy5zdGVwfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzRGV0YWlscy5wcm9ncmVzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkaXNwbGF5VGV4dCArPSBgICgke3RoaXMuc3RhdHVzRGV0YWlscy5wcm9ncmVzc30lKWA7XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWlsc1RleHQudGV4dENvbnRlbnQgPSBkaXNwbGF5VGV4dDtcbiAgICAgICAgdGhpcy5zdGF0dXNCYXJJdGVtLmFwcGVuZENoaWxkKGRldGFpbHNUZXh0KTtcblxuICAgICAgICAvLyBDb21wb3NlIHRvb2x0aXAgd2l0aCBhZGRpdGlvbmFsIGRldGFpbHNcbiAgICAgICAgbGV0IHRvb2x0aXAgPSB0aGlzLnN0YXR1c0RldGFpbHMubWVzc2FnZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzRGV0YWlscy5jb25uZWN0aXZpdHlTdGF0dXMpIHtcbiAgICAgICAgICAgIHRvb2x0aXAgKz0gYCB8IENvbm5lY3Rpdml0eTogJHt0aGlzLnN0YXR1c0RldGFpbHMuY29ubmVjdGl2aXR5U3RhdHVzfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzRGV0YWlscy5sYXN0RGF0YWJhc2VDaGVjaykge1xuICAgICAgICAgICAgdG9vbHRpcCArPSBgIHwgTGFzdCBEQiBDaGVjazogJHtuZXcgRGF0ZSh0aGlzLnN0YXR1c0RldGFpbHMubGFzdERhdGFiYXNlQ2hlY2spLnRvTG9jYWxlVGltZVN0cmluZygpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzRGV0YWlscy5xdWV1ZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9vbHRpcCArPSBgIHwgUXVldWU6ICR7dGhpcy5zdGF0dXNEZXRhaWxzLnF1ZXVlU2l6ZX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1c0RldGFpbHMucGVuZGluZ0NoYW5nZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9vbHRpcCArPSBgIHwgUGVuZGluZzogJHt0aGlzLnN0YXR1c0RldGFpbHMucGVuZGluZ0NoYW5nZXN9YDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXR1c0Jhckl0ZW0uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdG9vbHRpcCk7XG4gICAgICAgIHRoaXMuc3RhdHVzQmFySXRlbS5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgbmV3IE5vdGljZSh0b29sdGlwKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc3RhdHVzIGljb24gZWxlbWVudCBiYXNlZCBvbiBjdXJyZW50IHN0YXR1cy5cbiAgICAgKi9cbiAgICBwcml2YXRlIGNyZWF0ZVN0YXR1c0ljb24oKTogSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdCBpY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBpY29uLmFkZENsYXNzKCdtaW5kLW1hdHJpeC1zdGF0dXMtaWNvbicpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuY3VycmVudFN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBQbHVnaW5TdGF0dXMuUkVBRFk6XG4gICAgICAgICAgICBjYXNlIFBsdWdpblN0YXR1cy5DT01QTEVURUQ6XG4gICAgICAgICAgICAgICAgaWNvbi5hZGRDbGFzcygnaXMtcmVhZHknKTtcbiAgICAgICAgICAgICAgICBpY29uLmlubmVySFRNTCA9ICdcdTI1Q0YnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQbHVnaW5TdGF0dXMuRVJST1I6XG4gICAgICAgICAgICAgICAgaWNvbi5hZGRDbGFzcygnaXMtZXJyb3InKTtcbiAgICAgICAgICAgICAgICBpY29uLmlubmVySFRNTCA9ICdcdTI2QTAnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQbHVnaW5TdGF0dXMuV0FJVElOR19GT1JfU1lOQzpcbiAgICAgICAgICAgIGNhc2UgUGx1Z2luU3RhdHVzLkNIRUNLSU5HX0ZJTEU6XG4gICAgICAgICAgICBjYXNlIFBsdWdpblN0YXR1cy5RVUVVSU5HOlxuICAgICAgICAgICAgY2FzZSBQbHVnaW5TdGF0dXMuUFJPQ0VTU0lOR19RVUVVRTpcbiAgICAgICAgICAgIGNhc2UgUGx1Z2luU3RhdHVzLlBFTkRJTkc6XG4gICAgICAgICAgICAgICAgaWNvbi5hZGRDbGFzcygnaXMtd29ya2luZycpO1xuICAgICAgICAgICAgICAgIGljb24uaW5uZXJIVE1MID0gJ1x1MjFCQic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFBsdWdpblN0YXR1cy5JTl9QUk9HUkVTUzpcbiAgICAgICAgICAgICAgICBpY29uLmFkZENsYXNzKCdpcy1pbi1wcm9ncmVzcycpO1xuICAgICAgICAgICAgICAgIGljb24uaW5uZXJIVE1MID0gJ1x1MjVDQic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGljb24uYWRkQ2xhc3MoJ2lzLWluaXRpYWxpemluZycpO1xuICAgICAgICAgICAgICAgIGljb24uaW5uZXJIVE1MID0gJ1x1MjVDQic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGljb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IGFsbCBzdWJzY3JpYmVycyBvZiBhIHN0YXR1cyBjaGFuZ2UuXG4gICAgICovXG4gICAgcHJpdmF0ZSBub3RpZnlTdWJzY3JpYmVycygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5jdXJyZW50U3RhdHVzLCB0aGlzLnN0YXR1c0RldGFpbHMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBzdGF0dXMgY2hhbmdlIHN1YnNjcmliZXI6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgcGx1Z2luIGlzIGN1cnJlbnRseSBpbiBhIHNwZWNpZmljIHN0YXR1cy5cbiAgICAgKi9cbiAgICBwdWJsaWMgaXNJblN0YXR1cyhzdGF0dXM6IFBsdWdpblN0YXR1cyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U3RhdHVzID09PSBzdGF0dXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHByb2dyZXNzIGZvciB0aGUgY3VycmVudCB0YXNrIHdpdGggZGV0YWlsZWQgc3RlcCBpbmZvLlxuICAgICAqIEBwYXJhbSBwcm9ncmVzcyBQZXJjZW50YWdlIG9mIGNvbXBsZXRpb24uXG4gICAgICogQHBhcmFtIGN1cnJlbnRTdGVwIERlc2NyaXB0aW9uIG9mIHRoZSBjdXJyZW50IHN0ZXAuXG4gICAgICogQHBhcmFtIG9wZXJhdGlvbiBPcHRpb25hbCBvcGVyYXRpb24gbmFtZS5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbERldGFpbHMgT3B0aW9uYWwgZXh0cmEgZGV0YWlscy5cbiAgICAgKi9cbiAgICBwdWJsaWMgdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3M6IG51bWJlciwgY3VycmVudFN0ZXA6IHN0cmluZywgb3BlcmF0aW9uPzogc3RyaW5nLCBhZGRpdGlvbmFsRGV0YWlscz86IFBhcnRpYWw8U3RhdHVzRGV0YWlscz4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdGF0dXNEZXRhaWxzLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgIHRoaXMuc3RhdHVzRGV0YWlscy5zdGVwID0gY3VycmVudFN0ZXA7XG4gICAgICAgIGlmIChvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzRGV0YWlscy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZGl0aW9uYWxEZXRhaWxzKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0RldGFpbHMgPSB7IC4uLnRoaXMuc3RhdHVzRGV0YWlscywgLi4uYWRkaXRpb25hbERldGFpbHMgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcigpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBQbHVnaW4sIFRBYnN0cmFjdEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBTdGF0dXNNYW5hZ2VyLCBQbHVnaW5TdGF0dXMgfSBmcm9tICcuL1N0YXR1c01hbmFnZXInO1xuXG5leHBvcnQgY2xhc3MgU3luY0RldGVjdGlvbk1hbmFnZXIge1xuICAgIHByaXZhdGUgbGFzdFN5bmNBY3Rpdml0eTogbnVtYmVyID0gMDtcbiAgICBwcml2YXRlIHN5bmNDaGVja0ludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgcXVpZXRQZXJpb2RSZWFjaGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBpc1dhaXRpbmdGb3JRdWlldFBlcmlvZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgUVVJRVRfUEVSSU9EX01TID0gNTAwMDsgLy8gNSBzZWNvbmRzXG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBwbHVnaW46IFBsdWdpbixcbiAgICAgICAgcHJpdmF0ZSBzdGF0dXNNYW5hZ2VyOiBTdGF0dXNNYW5hZ2VyLFxuICAgICAgICBwcml2YXRlIG9uUXVpZXRQZXJpb2RSZWFjaGVkOiAoKSA9PiB2b2lkXG4gICAgKSB7fVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgbW9uaXRvcmluZyBmb3Igc3luYyBhY3Rpdml0eVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGFydE1vbml0b3JpbmcoKTogdm9pZCB7XG4gICAgICAgIC8vIFRyYWNrIGZpbGUgY2hhbmdlcyBhcyBwb3RlbnRpYWwgc3luYyBhY3Rpdml0eVxuICAgICAgICB0aGlzLnBsdWdpbi5yZWdpc3RlckV2ZW50KFxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uYXBwLnZhdWx0Lm9uKCdtb2RpZnknLCAoKSA9PiB0aGlzLnJlY29yZFN5bmNBY3Rpdml0eSgpKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBsdWdpbi5yZWdpc3RlckV2ZW50KFxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uYXBwLnZhdWx0Lm9uKCdjcmVhdGUnLCAoKSA9PiB0aGlzLnJlY29yZFN5bmNBY3Rpdml0eSgpKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBsdWdpbi5yZWdpc3RlckV2ZW50KFxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uYXBwLnZhdWx0Lm9uKCdkZWxldGUnLCAoKSA9PiB0aGlzLnJlY29yZFN5bmNBY3Rpdml0eSgpKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFN0YXJ0IGNoZWNraW5nIGZvciBxdWlldCBwZXJpb2RcbiAgICAgICAgdGhpcy5zdGFydFF1aWV0UGVyaW9kQ2hlY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNvcmQgc3luYyBhY3Rpdml0eSBhbmQgcmVzZXQgcXVpZXQgcGVyaW9kXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWNvcmRTeW5jQWN0aXZpdHkoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubGFzdFN5bmNBY3Rpdml0eSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMucXVpZXRQZXJpb2RSZWFjaGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNXYWl0aW5nRm9yUXVpZXRQZXJpb2QpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzTWFuYWdlci5zZXRTdGF0dXMoUGx1Z2luU3RhdHVzLldBSVRJTkdfRk9SX1NZTkMsIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnV2FpdGluZyBmb3IgT2JzaWRpYW4gc3luYyB0byBzZXR0bGUuLi4nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGNoZWNraW5nIGZvciBxdWlldCBwZXJpb2RcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXJ0UXVpZXRQZXJpb2RDaGVjaygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzV2FpdGluZ0ZvclF1aWV0UGVyaW9kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RTeW5jID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdFN5bmNBY3Rpdml0eTtcblxuICAgICAgICAgICAgaWYgKHRpbWVTaW5jZUxhc3RTeW5jID49IHRoaXMuUVVJRVRfUEVSSU9EX01TICYmICF0aGlzLnF1aWV0UGVyaW9kUmVhY2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucXVpZXRQZXJpb2RSZWFjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzV2FpdGluZ0ZvclF1aWV0UGVyaW9kID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNDaGVja0ludGVydmFsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9uUXVpZXRQZXJpb2RSZWFjaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMDApOyAvLyBDaGVjayBldmVyeSBzZWNvbmRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIG1vbml0b3JpbmcgZm9yIHN5bmMgYWN0aXZpdHlcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RvcE1vbml0b3JpbmcoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnN5bmNDaGVja0ludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuc3luY0NoZWNrSW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5zeW5jQ2hlY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1dhaXRpbmdGb3JRdWlldFBlcmlvZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGN1cnJlbnRseSB3YWl0aW5nIGZvciBxdWlldCBwZXJpb2RcbiAgICAgKi9cbiAgICBwdWJsaWMgaXNXYWl0aW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1dhaXRpbmdGb3JRdWlldFBlcmlvZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGltZSBzaW5jZSBsYXN0IHN5bmMgYWN0aXZpdHlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0VGltZVNpbmNlTGFzdFN5bmMoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLmxhc3RTeW5jQWN0aXZpdHk7XG4gICAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQSxpQkFBQUE7QUFBQSxFQUFBLGVBQUFDO0FBQUEsRUFBQSxnQkFBQUM7QUFBQSxFQUFBO0FBQUEsZUFBQUM7QUFBQTtBQUFBLElBR0ksV0FVQSxjQUVTQSxRQUVOLGlCQUVNSCxVQUNBQyxVQUNBQztBQXJCYjtBQUFBO0FBQUE7QUFHQSxJQUFJLFlBQVksV0FBVztBQUl2QixVQUFJLE9BQU8sU0FBUyxhQUFhO0FBQUUsZUFBTztBQUFBLE1BQU07QUFDaEQsVUFBSSxPQUFPLFdBQVcsYUFBYTtBQUFFLGVBQU87QUFBQSxNQUFRO0FBQ3BELFVBQUksT0FBTyxXQUFXLGFBQWE7QUFBRSxlQUFPO0FBQUEsTUFBUTtBQUNwRCxZQUFNLElBQUksTUFBTSxnQ0FBZ0M7QUFBQSxJQUNwRDtBQUVBLElBQUksZUFBZSxVQUFVO0FBRXRCLElBQU1DLFNBQVEsYUFBYTtBQUVsQyxJQUFPLGtCQUFRLGFBQWEsTUFBTSxLQUFLLFlBQVk7QUFFNUMsSUFBTUgsV0FBVSxhQUFhO0FBQzdCLElBQU1DLFdBQVUsYUFBYTtBQUM3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QzVCLGdCQUFNLEtBQUssbUJBQW1CLFVBQVU7QUFBQSxRQUN6QyxPQUFPO0FBQ04sY0FBSSx5QkFBTyxzQ0FBc0M7QUFBQSxRQUNsRDtBQUFBLE1BQ0Q7QUFBQSxJQUNELENBQUM7QUFFRCxTQUFLLFdBQVc7QUFBQSxNQUNmLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLFVBQVUsTUFBTTtBQXRvQm5CLFlBQUFBO0FBdW9CSSxTQUFBQSxNQUFBLEtBQUssdUJBQUwsZ0JBQUFBLElBQXlCO0FBQ3pCLFlBQUkseUJBQU8sc0JBQXNCO0FBQUEsTUFDbEM7QUFBQSxJQUNELENBQUM7QUFBQSxFQUNGO0FBQ0Q7IiwKICAibmFtZXMiOiBbIkhlYWRlcnMiLCAiUmVxdWVzdCIsICJSZXNwb25zZSIsICJmZXRjaCIsICJQb3N0Z3Jlc3RFcnJvciIsICJQb3N0Z3Jlc3RCdWlsZGVyIiwgInJlcyIsICJfYSIsICJQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyIiwgIl9hIiwgIlBvc3RncmVzdEZpbHRlckJ1aWxkZXIiLCAiUG9zdGdyZXN0UXVlcnlCdWlsZGVyIiwgImZldGNoIiwgImhlYWQiLCAiUG9zdGdyZXN0Q2xpZW50IiwgImZldGNoIiwgImhlYWQiLCAiZ2V0IiwgIm1vZHVsZSIsICJpbXBvcnRfb2JzaWRpYW4iLCAiZmV0Y2giLCAiRnVuY3Rpb25SZWdpb24iLCAiX2EiLCAiaW5kZXgiLCAiU09DS0VUX1NUQVRFUyIsICJDSEFOTkVMX1NUQVRFUyIsICJDSEFOTkVMX0VWRU5UUyIsICJUUkFOU1BPUlRTIiwgIkNPTk5FQ1RJT05fU1RBVEUiLCAiUG9zdGdyZXNUeXBlcyIsICJfYSIsICJfYSIsICJSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTIiwgIl9hIiwgIlJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UIiwgIlJFQUxUSU1FX0xJU1RFTl9UWVBFUyIsICJSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTIiwgIl9hIiwgInB1c2giLCAiX2IiLCAidHlwZSIsICJub29wIiwgImZldGNoIiwgIl9hIiwgImtpbmQiLCAicmVzb2x2ZUZldGNoIiwgImZldGNoIiwgIl9fYXdhaXRlciIsICJfX2F3YWl0ZXIiLCAiZmV0Y2giLCAicmVzb2x2ZUZldGNoIiwgInZlcnNpb24iLCAiREVGQVVMVF9IRUFERVJTIiwgInZlcnNpb24iLCAiZmV0Y2giLCAiREVGQVVMVF9IRUFERVJTIiwgInJlc29sdmVGZXRjaCIsICJmZXRjaCIsICJ2ZXJzaW9uIiwgIkRFRkFVTFRfSEVBREVSUyIsICJ2ZXJzaW9uIiwgInJlc29sdmVGZXRjaCIsICJIZWFkZXJzIiwgImZldGNoIiwgIl9fYXdhaXRlciIsICJfYSIsICJkZWZhdWx0cyIsICJERUZBVUxUX0RCX09QVElPTlMiLCAiREVGQVVMVF9BVVRIX09QVElPTlMiLCAiREVGQVVMVF9SRUFMVElNRV9PUFRJT05TIiwgIkRFRkFVTFRfR0xPQkFMX09QVElPTlMiLCAiX19hd2FpdGVyIiwgInZlcnNpb24iLCAiREVGQVVMVF9IRUFERVJTIiwgInZlcnNpb24iLCAicmVzb2x2ZUZldGNoIiwgImZldGNoIiwgIl9hIiwgInN0ciIsICJfZ2V0RXJyb3JNZXNzYWdlIiwgImhhbmRsZUVycm9yIiwgIl9hIiwgIl9nZXRSZXF1ZXN0UGFyYW1zIiwgIl9oYW5kbGVSZXF1ZXN0IiwgImZldGNoIiwgInJlc29sdmVGZXRjaCIsICJfX3Jlc3QiLCAiX2EiLCAiREVGQVVMVF9IRUFERVJTIiwgInJlc29sdmVGZXRjaCIsICJfYSIsICJ2ZXJzaW9uIiwgInJlc3VsdCIsICJleHBpcmVzQXQiLCAiZXJyb3IiLCAiZGF0YSIsICJfYSIsICJkZWJ1ZyIsICJmZXRjaCIsICJnZXRBbGxFeGNsdXNpb25zIiwgImlzVmF1bHRJbml0aWFsaXplZCIsICJpc1ZhdWx0SW5pdGlhbGl6ZWQiLCAiX2EiLCAibGltaXQiLCAic3RyIiwgImlzX2FycmF5IiwgImZldGNoIiwgIlJlcXVlc3QiLCAiUmVzcG9uc2UiLCAiSGVhZGVycyIsICJGb3JtRGF0YSIsICJCbG9iIiwgIkZpbGUiLCAiUmVhZGFibGVTdHJlYW0iLCAiX2EiLCAic2VsZiIsICJSZWFkYWJsZVN0cmVhbSIsICJfYSIsICJzdHIiLCAiaW5kZXgiLCAiX2EiLCAiRmlsZSIsICJGb3JtRGF0YSIsICJmZXRjaCIsICJvcHRzIiwgIlBhZ2UiLCAiX2EiLCAicmV0cnlNZXNzYWdlIiwgInNsZWVwIiwgIl9hIiwgIl9hIiwgIm1vZGlmaWVkQXJnIiwgIl9hIiwgIl9hIiwgIl9hIiwgIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCAiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsICJpbmRleCIsICJfYSIsICJpbnB1dFRvb2wiLCAiX2EiLCAiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsICJjb250ZW50IiwgIm5hbWUiLCAiX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxNZXNzYWdlIiwgIl9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsRnVuY3Rpb25DYWxsIiwgIl9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0IiwgIl9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2NhbGN1bGF0ZVRvdGFsVXNhZ2UiLCAiX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfdmFsaWRhdGVQYXJhbXMiLCAiX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfc3RyaW5naWZ5RnVuY3Rpb25DYWxsUmVzdWx0IiwgImluZGV4IiwgImVzY2FwZSIsICJlIiwgIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCAiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsICJfYSIsICJfQ2hhdENvbXBsZXRpb25TdHJlYW1fYmVnaW5SZXF1ZXN0IiwgIl9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRDaG9pY2VFdmVudFN0YXRlIiwgIl9DaGF0Q29tcGxldGlvblN0cmVhbV9hZGRDaHVuayIsICJfQ2hhdENvbXBsZXRpb25TdHJlYW1fZW1pdFRvb2xDYWxsRG9uZUV2ZW50IiwgIl9DaGF0Q29tcGxldGlvblN0cmVhbV9lbWl0Q29udGVudERvbmVFdmVudHMiLCAiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VuZFJlcXVlc3QiLCAiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2dldEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdCIsICJfQ2hhdENvbXBsZXRpb25TdHJlYW1fYWNjdW11bGF0ZUNoYXRDb21wbGV0aW9uIiwgImluZGV4IiwgImNvbnRlbnQiLCAicmVmdXNhbCIsICJyZXN0IiwgIl9iIiwgIl9jIiwgIl9kIiwgImNodW5rIiwgImlkIiwgIkNvbXBsZXRpb25zIiwgIkNoYXQiLCAiQ29tcGxldGlvbnMiLCAiY2h1bmsiLCAiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsICJfYSIsICJpbmRleCIsICJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IiwgIl9Bc3Npc3RhbnRTdHJlYW1fZW5kUmVxdWVzdCIsICJfQXNzaXN0YW50U3RyZWFtX2hhbmRsZU1lc3NhZ2UiLCAiX0Fzc2lzdGFudFN0cmVhbV9oYW5kbGVSdW5TdGVwIiwgIl9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlRXZlbnQiLCAiX0Fzc2lzdGFudFN0cmVhbV9hY2N1bXVsYXRlUnVuU3RlcCIsICJfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVNZXNzYWdlIiwgIl9Bc3Npc3RhbnRTdHJlYW1fYWNjdW11bGF0ZUNvbnRlbnQiLCAiX0Fzc2lzdGFudFN0cmVhbV9oYW5kbGVSdW4iLCAiX2EiLCAic2xlZXAiLCAiX2EiLCAic2xlZXAiLCAic2xlZXAiLCAiX2EiLCAiQ2hhdCIsICJDb21wbGV0aW9ucyIsICJfYSIsICJGaWxlcyIsICJzbGVlcCIsICJfYSIsICJDb21wbGV0aW9ucyIsICJGaWxlcyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJfYSIsICJpbmRleCIsICJfYSIsICJpbmRleCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgIlN5bmNFcnJvclR5cGUiLCAiX2EiLCAiX2EiLCAic3RyIiwgImltcG9ydF9vYnNpZGlhbiIsICJfYSIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImlzVmF1bHRJbml0aWFsaXplZCIsICJ2YWx1ZSIsICJzeXN0ZW1GaWxlcyIsICJtb2RhbCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgIl9hIiwgImlzVmF1bHRJbml0aWFsaXplZCIsICJnZXRBbGxFeGNsdXNpb25zIl0KfQo=
